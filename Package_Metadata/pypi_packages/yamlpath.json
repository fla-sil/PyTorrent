{"info": {"author": "William W. Kimball, Jr., MBA, MSIS", "author_email": "github-yamlpath@kimballstuff.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: ISC License (ISCL)", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# YAML Path and Command-Line Tools\n\n[![Build Status](https://travis-ci.org/wwkimball/yamlpath.svg?branch=master)](https://travis-ci.org/wwkimball/yamlpath)\n[![Python versions](https://img.shields.io/pypi/pyversions/yamlpath.svg)](https://pypi.org/project/yamlpath/)\n[![PyPI version](https://badge.fury.io/py/yamlpath.svg)](https://pypi.org/project/yamlpath/)\n[![Downloads](https://pepy.tech/badge/yamlpath)](https://pepy.tech/project/yamlpath)\n[![Coverage Status](https://coveralls.io/repos/github/wwkimball/yamlpath/badge.svg?branch=master)](https://coveralls.io/github/wwkimball/yamlpath?branch=master)\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/6bcc1f2767854390923a8d25a2e4a191)](https://www.codacy.com/manual/wwkimball/yamlpath?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=wwkimball/yamlpath&amp;utm_campaign=Badge_Grade)\n\nAlong with providing a\n[standard for defining YAML Paths](https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path),\nthis project aims to provide\n[generally-useful command-line tools](https://github.com/wwkimball/yamlpath/wiki/Command-Line-(CLI)-Tools)\nwhich implement YAML Paths.  These bring intuitive YAML, EYAML, JSON, and\ncompatible data parsing and editing capabilties to the command-line.  It is\nalso a\n[Python library](https://github.com/wwkimball/yamlpath/wiki/Python-Library)\nfor other projects to readily employ YAML Paths.\n\n## Contents\n\n1. [Introduction](#introduction)\n2. [Illustration](#illustration)\n3. [Installing](#installing)\n4. [Supported YAML Path Segments](#supported-yaml-path-segments)\n5. [Based on ruamel.yaml and Python 3](#based-on-ruamelyaml-and-python-3)\n6. [The Files of This Project](#the-files-of-this-project)\n   1. [Command-Line Tools](#command-line-tools)\n   2. [Libraries](#libraries)\n7. [Basic Usage](#basic-usage)\n   1. [Basic Usage:  Command-Line Tools](#basic-usage--command-line-tools)\n      1. [Rotate Your EYAML Keys](#rotate-your-eyaml-keys)\n      2. [Get a YAML Value](#get-a-yaml-value)\n      3. [Search For YAML Paths](#search-for-yaml-paths)\n      4. [Change a YAML Value](#change-a-yaml-value)\n   2. [Basic Usage:  Libraries](#basic-usage--libraries)\n      1. [Initialize ruamel.yaml and These Helpers](#initialize-ruamelyaml-and-these-helpers)\n      2. [Searching for YAML Nodes](#searching-for-yaml-nodes)\n      3. [Changing Values](#changing-values)\n\n## Introduction\n\nThis project presents and utilizes YAML Paths, which are a powerful, intuitive\nmeans of identifying one *or more* nodes within [YAML](https://yaml.org/),\n[EYAML](https://github.com/voxpupuli/hiera-eyaml), or compatible data structures\nlike [JSON](https://www.json.org/).  Both dot-notation (inspired by\n[Hiera](https://github.com/puppetlabs/hiera)) and forward-slash-notation\n(influenced by [XPath](https://www.w3schools.com/xml/xml_xpath.asp)) are\nsupported.  The [libraries](#libraries) (modules) and several [command-line tool\nimplementations](#command-line-tools) are provided.  With these, you can build\nYAML Path support right into your own application or easily use its capabilities\nright away from the command-line to retrieve or update YAML/Compatible data.\n\nThis implementation of YAML Path is a *query language* in addition to a *node\ndescriptor*.  With it, you can describe or select a single precise node or\nsearch for any number of nodes that match some criteria.  Keys, values, and\nelements can all be searched at any number of levels within the data structure\nusing the same query.  Collectors can also be used to gather and further select\nfrom otherwise disparate parts of the source data.\n\nThe [project Wiki](https://github.com/wwkimball/yamlpath/wiki) provides a\ndeeper dive into these concepts.\n\n## Illustration\n\nTo illustrate some of these concepts, consider these samples:\n\n```yaml\n---\nhash:\n  child_attr:\n    key: 5280\n```\n\nThis value, `5280`, can be identified via YAML Path as any of:\n\n1. `hash.child_attr.key` (dot-notation)\n2. `hash.child_attr[.=key]` (search all child keys for one named, `key`, and\n   yield its value)\n3. `/hash/child_attr/key` (same as 1 but in forward-slash notation)\n4. `/hash/child_attr[.=key]` (same as 2 but in forward-slash notation)\n\n```yaml\n---\naliases:\n  - &first_anchor Simple string value\n```\n\nWith YAML Path, you can select this anchored value by any of these equivalent\nexpressions:\n\n1. `aliases[0]` (explicit array element number)\n2. `aliases.0` (implicit array element number in dot-notation)\n3. `aliases[&first_anchor]` (search by Anchor name)\n4. `aliases[.^Simple]` (search for any elements starting with \"Simple\")\n5. `aliases[.%string]` (search for any elements containing \"string\")\n6. `aliases[.$value]` (search for any elements ending with \"value\")\n7. `aliases[.=~/^(\\b[Ss][a-z]+\\s){2}[a-z]+$/]` (search for any elements matching\n   a complex Regular Expression, which happens to match the example)\n8. `/aliases[0]` (same as 1 but in forward-slash notation)\n9. `/aliases/0` (same as 2 but in forward-slash notation)\n10. `/aliases[&first_anchor]` (same as 3 but in forward-slash notation)\n\n```yaml\n---\nusers:\n  - name: User One\n    password: ENC[PKCS7,MIIBiQY...Jk==]\n    roles:\n      - Writers\n  - name: User Two\n    password: ENC[PKCS7,MIIBiQY...vF==]\n    roles:\n      - Power Users\n      - Editors\n```\n\nWith an example like this, YAML Path enables:\n\n* selection of single nodes: `/users/0/roles/0` = `Writers`\n* all children nodes of any given parent: `/users/1/roles` =\n  `[\"Power Users\", \"Editors\"]`\n* searching by a child attribute: `/users[name=\"User One\"]/password` =\n  `Some decrypted value, provided you have the appropriate EYAML keys`\n* pass-through selections against arrays-of-hashes: `/users/roles` =\n  `[\"Writers\"]\\n[\"Power Users\", \"Editors\"]` (each user's list of roles are a\n  seperate result)\n* collection of disparate results: `(/users/name)` =\n  `[\"User One\", \"User Two\"]` (all names appear in a single result instead of\n  one per line)\n\nFor a deeper exploration of YAML Path's capabilities, please visit the\n[project Wiki](https://github.com/wwkimball/yamlpath/wiki).\n\n## Supported YAML Path Segments\n\nA YAML Path *segment* is the text between seperators which identifies zero or\nmore parent or leaf nodes within the data structure.  For dot-notation, a path\nlike `hash.key` identifies two segments:  `hash` (a parent node) and `key` (a\nleaf node).  The same path in forward-slash notation would be:  `/hash/key`.\n\nYAML Path understands these segment types:\n\n* Top-level Hash key selection: `key`\n* Explicit top-level array element selection: `[#]` where `#` is the zero-based\n  element number; `#` can also be negative, causing the element to be selected\n  from the end of the Array\n* Implicit array element selection **or** numbered hash key selection: `#`\n  where `#` is the 0-based element number **or** exact name of a hash key which\n  is itself a number\n* Top-level (Hash) Anchor lookups: `&anchor_name` (the `&` is required to\n  indicate you are seeking an Anchor by name)\n* Hash sub-keys:  `hash.child.key` or `/hash/child/key`\n* Demarcation for dotted Hash keys:  `hash.'dotted.child.key'` or\n  `hash.\"dotted.child.key\"` (not necessary when using forward-slash notation,\n  `/hash/dotted.child.key`)\n* Named Array element selection:  `array[#]`, `array.#`, `/array[#]`, or\n  `/array/#` where `array` is the name of the Hash key containing Array data\n  and `#` is the 0-based element number\n* Anchor lookups in named Arrays:  `array[&anchor_name]`  where `array` is the\n  name of the Hash key containing Array data and both of the `[]` pair and `&`\n  are required to indicate you are seeking an Anchor by name within an Array\n* Array slicing: `array[start#:stop#]` where `start#` is the first inclusive,\n  zero-based element and `stop#` is the last exclusive element to select;\n  either or both can be negative, causing the elements to be selected from the\n  end of the Array; when `start#` and `stop#` are identical, it is the same as\n  `array[start#]`\n* Hash slicing: `hash[min:max]` where `min` and `max` are alphanumeric terms\n  between which the Hash's keys are compared\n* Escape symbol recognition:  `hash.dotted\\.child\\.key`,\n  `/hash/whacked\\/child\\/key`, and `keys_with_\\\\slashes`\n* Hash attribute searches (which can return zero or more matches):\n  * Exact match:  `hash[name=admin]`\n  * Starts With match:  `hash[name^adm]`\n  * Ends With match:  `hash[name$min]`\n  * Contains match:  `hash[name%dmi]`\n  * Less Than match: `hash[access_level<500]`\n  * Greater Than match: `hash[access_level>0]`\n  * Less Than or Equal match: `hash[access_level<=100]`\n  * Greater Than or Equal match: `hash[access_level>=0]`\n  * Regular Expression matches: `hash[access_level=~/^\\D+$/]` (the `/` Regular\n    Expression delimiter can be substituted for any character you need, except\n    white-space; note that `/` does not interfere with forward-slash notation\n    *and it does not need to be escaped* because the entire search expression is\n    contained within a `[]` pair)\n  * Invert any match with `!`, like: `hash[name!=admin]` or even\n    `hash[!name=admin]` (the former syntax is used when YAML Paths are\n    stringified but both forms are equivalent)\n  * Demarcate and/or escape expression operands, like:\n    `hash[full\\ name=\"Some User\\'s Name\"]` (note that embedded, single `'` and\n    `\"` must be escaped lest they be deemed unmatched demarcation pairings)\n  * Multi-level matching: `hash[name%admin].pass[encrypted!^ENC\\[]` or\n    `/hash[name%admin]/pass[encrypted!^ENC\\[]`\n* Array element searches with all of the search methods above via `.` (yields\n  any matching elements): `array[.>9000]`\n* Hash key-name searches with all of the search methods above via `.` (yields\n  their values, not the keys themselves): `hash[.^app_]`\n* Array-of-Hashes Pass-Through Selection:  Omit a selector for the elements of\n  an Array-of-Hashes and all matching Hash attributes at that level will be\n  yielded (or searched when there is more to the path).  For example,\n  `warriors[1].power_level` or `/warriors[1]/power_level` will return the\n  power_level attribute of only the second Hash in an Array-of-Hashes while\n  `warriors.power_level` or `/warriors/power_level` will return the power_level\n  attribute of every Hash in the same Array-of-Hashes.  Of course these results\n  can be filtered in multiple ways, like `warriors[power_level>9000]`,\n  `/warriors[power_level>9000]`, `warriors.power_level[.>9000]`, and\n  `/warriors/power_level[.>9000]` all yield only the power_level from *all*\n  warriors with power_levels over 9,000 within the same array of warrior hashes.\n* Collectors:  Placing any portion of the YAML Path within parenthesis defines a\n  virtual list collector, like `(YAML Path)`; concatenation and exclusion\n  operators are supported -- `+` and `-`, respectively -- along with nesting,\n  like `(...)-((...)+(...))`\n* Complex combinations:\n  `some::deep.hierarchy[with!=\"\"].'any.valid'[.=~/(yaml|json)/][data%structure].or.complexity[4].2`\n  or `/some::deep/hierarchy[with!=\"\"]/any.valid[.=~/(yaml|json)/][data%structure]/or/complexity[4]/2`\n\nThis implementation of YAML Path encourages creativity.  Use whichever notation\nand segment types that make the most sense to you in each application.\n\nThe [project Wiki provides more illustrative details of YAML Path Segments](https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path).\n\n## Installing\n\nThis project requires [Python](https://www.python.org/) 3.  It is tested\nagainst Pythons 3.6 through 3.8.  Most operating systems and distributions\nhave access to Python 3 even if only Python 2 -- or no Python, at all -- came\npre-installed.  It is generally safe to have more than one version of Python\non your system at the same time, especially when using\n[virtual Python environments](https://docs.python.org/3/library/venv.html).\n\nEach published version of this project can be installed from\n[PyPI](https://pypi.org/) using `pip`.  Note that on systems with more than one\nversion of Python, you will probably need to use `pip3`, or equivalent (e.g.:\nCygwin users may need to use `pip3.6`).\n\n```shell\npip3 install yamlpath\n```\n\nEYAML support is entirely optional.  You do not need EYAML to use YAML Path.\nThat YAML Path supports EYAML is a service to a substantial audience:  Puppet\nusers.  At the time of this writing, EYAML (classified as a Hiera\nback-end/plug-in) is available only as a Ruby Gem.  That said, it provides a\ncommand-line tool, `eyaml`, which can be employed by this otherwise Python\nproject.  To enjoy EYAML support, install compatible versions of ruby and\nrubygems, then execute:\n\n```shell\ngem install hiera-eyaml\n```\n\nIf this puts the `eyaml` command on your system `PATH`, nothing more need be\ndone apart from generating or obtaining your encryption keys.  Otherwise, you\ncan tell YAML Path library and tools where to find the `eyaml` command.\n\n## Based on ruamel.yaml and Python 3\n\nIn order to support the best available YAML editing capability (so called,\nround-trip editing with support for comment preservation), this project is based\non [ruamel.yaml](https://bitbucket.org/ruamel/yaml/overview) for\nPython 3.  While ruamel.yaml is based on PyYAML --\nPython's \"standard\" YAML library -- ruamel.yaml is [objectively better than\nPyYAML](https://yaml.readthedocs.io/en/latest/pyyaml.html), which lacks critical\nround-trip editing capabilities as well as up-to-date YAML/Compatible data\nparsing capabilities (at the time of this writing).\n\nShould PyYAML ever merge with -- or at least, catch up with -- ruamel.yaml, this\nproject can be (lightly) adapted to depend on it, instead.  These conversations\nmay offer some insight into when or whether this might happen:\n\n* [Is this time to pass the baton?](https://github.com/yaml/pyyaml/issues/31)\n* [Rebase off ruamel? - many new valuable features](https://github.com/yaml/pyyaml/issues/46)\n\n## The Files of This Project\n\nThis repository contains:\n\n1. Generally-useful Python library files.  These contain the reusable core of\n   this project's YAML Path capabilities.\n2. Some implementations of those libraries, exhibiting their capabilities and\n   simple-to-use APIs as command-line tools.\n3. Various support, documentation, and build files.\n\n### Command-Line Tools\n\nThis project provides some command-line tool implementations which utilize YAML\nPath.  For some use-case examples of these tools,\n[see below](#basic-usage--command-line-tools).\n\nThe supplied command-line tools include:\n\n* [eyaml-rotate-keys](yamlpath/commands/eyaml_rotate_keys.py)\n\n```text\nusage: eyaml-rotate-keys [-h] [-V] [-d | -v | -q] [-b] [-x EYAML]\n                         -i OLDPRIVATEKEY -c OLDPUBLICKEY\n                         -r NEWPRIVATEKEY -u NEWPUBLICKEY\n                         YAML_FILE [YAML_FILE ...]\n\nRotates the encryption keys used for all EYAML values within a set of YAML\nfiles, decrypting with old keys and re-encrypting using replacement keys.\n\npositional arguments:\n  YAML_FILE             one or more YAML files containing EYAML values\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n  -b, --backup          save a backup of each modified YAML_FILE with an extra\n                        .bak file-extension\n  -x EYAML, --eyaml EYAML\n                        the eyaml binary to use when it isn't on the PATH\n\nEYAML_KEYS:\n  All key arguments are required\n\n  -r NEWPRIVATEKEY, --newprivatekey NEWPRIVATEKEY\n                        the new EYAML private key\n  -u NEWPUBLICKEY, --newpublickey NEWPUBLICKEY\n                        the new EYAML public key\n  -i OLDPRIVATEKEY, --oldprivatekey OLDPRIVATEKEY\n                        the old EYAML private key\n  -c OLDPUBLICKEY, --oldpublickey OLDPUBLICKEY\n                        the old EYAML public key\n\nAny YAML_FILEs lacking EYAML values will not be modified (or backed up, even\nwhen -b/--backup is specified).\n```\n\n* [yaml-get](yamlpath/commands/yaml_get.py)\n\n```text\nusage: yaml-get [-h] [-V] -p YAML_PATH\n                [-t ['.', '/', 'auto', 'dot', 'fslash']] [-x EYAML]\n                [-r PRIVATEKEY] [-u PUBLICKEY] [-d | -v | -q]\n                YAML_FILE\n\nRetrieves one or more values from a YAML file at a specified YAML Path. Output\nis printed to STDOUT, one line per result. When a result is a complex data-\ntype (Array or Hash), a JSON dump is produced to represent it. EYAML can be\nemployed to decrypt the values.\n\npositional arguments:\n  YAML_FILE             the YAML file to query\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which YAML Path seperator to use when\n                        rendering results; default=dot\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n\nrequired settings:\n  -p YAML_PATH, --query YAML_PATH\n                        YAML Path to query\n\nEYAML options:\n  Left unset, the EYAML keys will default to your system or user defaults.\n  Both keys must be set either here or in your system or user EYAML\n  configuration file when using EYAML.\n\n  -x EYAML, --eyaml EYAML\n                        the eyaml binary to use when it isn't on the PATH\n  -r PRIVATEKEY, --privatekey PRIVATEKEY\n                        EYAML private key\n  -u PUBLICKEY, --publickey PUBLICKEY\n                        EYAML public key\n\nFor more information about YAML Paths, please visit\nhttps://github.com/wwkimball/yamlpath.\n```\n\n* [yaml-paths](yamlpath/commands/yaml_paths.py)\n\n```text\nusage: yaml-paths [-h] [-V] -s EXPRESSION [-c EXPRESSION] [-d | -v | -q] [-m]\n                  [-L] [-F] [-X] [-P] [-t ['.', '/', 'auto', 'dot', 'fslash']]\n                  [-i | -k | -K] [-a] [-A | -Y | -y | -l] [-e] [-x EYAML]\n                  [-r PRIVATEKEY] [-u PUBLICKEY]\n                  YAML_FILE [YAML_FILE ...]\n\nReturns zero or more YAML Paths indicating where in given YAML/Compatible data\none or more search expressions match. Values, keys, and/or anchors can be\nsearched. EYAML can be employed to search encrypted values.\n\npositional arguments:\n  YAML_FILE             one or more YAML files to search\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n  -c EXPRESSION, --except EXPRESSION\n                        except results matching this search expression; can be\n                        set more than once\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all non-result output except errors\n  -m, --expand          expand matching parent nodes to list all permissible\n                        child leaf nodes (see \"reference handling options\" for\n                        restrictions)\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which YAML Path seperator to use when\n                        rendering results; default=dot\n  -a, --refnames        also search the names of &anchor and *alias references\n\nrequired settings:\n  -s EXPRESSION, --search EXPRESSION\n                        the search expression; can be set more than once\n\nresult printing options:\n  -L, --values          print the values or elements along with each YAML Path\n                        (complex results are emitted as JSON; use --expand to\n                        emit only simple values)\n  -F, --nofile          omit source file path and name decorators from the\n                        output (applies only when searching multiple files)\n  -X, --noexpression    omit search expression decorators from the output\n  -P, --noyamlpath      omit YAML Paths from the output (useful with --values\n                        or to indicate whether a file has any matches without\n                        printing them all, perhaps especially with\n                        --noexpression)\n\nkey name searching options:\n  -i, --ignorekeynames  (default) do not search key names\n  -k, --keynames        search key names in addition to values and array\n                        elements\n  -K, --onlykeynames    only search key names (ignore all values and array\n                        elements)\n\nreference handling options:\n  Indicate how to treat anchor and alias references. An anchor is an\n  original, reusable key or value. All aliases become replaced by the\n  anchors they reference when YAML data is read. These options specify how\n  to handle this duplication of keys and values. Note that the default\n  behavior includes all aliased keys but not aliased values.\n\n  -A, --anchorsonly     include only original matching key and value anchors\n                        in results, discarding all aliased keys and values\n                        (including child nodes)\n  -Y, --allowkeyaliases\n                        (default) include matching key aliases, permitting\n                        search traversal into their child nodes\n  -y, --allowvaluealiases\n                        include matching value aliases (does not permit search\n                        traversal into aliased keys)\n  -l, --allowaliases    include all matching key and value aliases\n\nEYAML options:\n  Left unset, the EYAML keys will default to your system or user defaults.\n  Both keys must be set either here or in your system or user EYAML\n  configuration file when using EYAML.\n\n  -e, --decrypt         decrypt EYAML values in order to search them\n                        (otherwise, search the encrypted blob)\n  -x EYAML, --eyaml EYAML\n                        the eyaml binary to use when it isn't on the PATH\n  -r PRIVATEKEY, --privatekey PRIVATEKEY\n                        EYAML private key\n  -u PUBLICKEY, --publickey PUBLICKEY\n                        EYAML public key\n\nA search or exception EXPRESSION takes the form of a YAML Path search operator\n-- %, $, =, ^, >, <, >=, <=, =~, or ! -- followed by the search term, omitting\nthe left-hand operand. For more information about YAML Paths, please visit\nhttps://github.com/wwkimball/yamlpath.\n```\n\n* [yaml-set](yamlpath/commands/yaml_set.py)\n\n```text\nusage: yaml-set [-h] [-V] -g YAML_PATH [-a VALUE | -f FILE | -i | -R LENGTH]\n                [-F {bare,boolean,default,dquote,float,folded,int,literal,squote}]\n                [-c CHECK] [-s YAML_PATH] [-m] [-b]\n                [-t ['.', '/', 'auto', 'dot', 'fslash']] [-e] [-x EYAML]\n                [-r PRIVATEKEY] [-u PUBLICKEY] [-d | -v | -q]\n                YAML_FILE\n\nChanges one or more values in a YAML file at a specified YAML Path. Matched\nvalues can be checked before they are replaced to mitigate accidental change.\nWhen matching singular results, the value can be archived to another key\nbefore it is replaced. Further, EYAML can be employed to encrypt the new\nvalues and/or decrypt an old value before checking them.\n\npositional arguments:\n  YAML_FILE             the YAML file to update\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n  -F {bare,boolean,default,dquote,float,folded,int,literal,squote}, --format {bare,boolean,default,dquote,float,folded,int,literal,squote}\n                        override automatic formatting of the new value\n  -c CHECK, --check CHECK\n                        check the value before replacing it\n  -s YAML_PATH, --saveto YAML_PATH\n                        save the old value to YAML_PATH before replacing it;\n                        implies --mustexist\n  -m, --mustexist       require that the --change YAML_PATH already exist in\n                        YAML_FILE\n  -b, --backup          save a backup YAML_FILE with an extra .bak file-\n                        extension\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which YAML Path seperator to use when\n                        rendering results; default=dot\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n\nrequired settings:\n  -g YAML_PATH, --change YAML_PATH\n                        YAML Path where the target value is found\n\ninput options:\n  -a VALUE, --value VALUE\n                        set the new value from the command-line instead of\n                        STDIN\n  -f FILE, --file FILE  read the new value from file (discarding any trailing\n                        new-lines)\n  -i, --stdin           accept the new value from STDIN (best for sensitive\n                        data)\n  -R LENGTH, --random LENGTH\n                        randomly generate a replacement value of a set length\n\nEYAML options:\n  Left unset, the EYAML keys will default to your system or user defaults.\n  You do not need to supply a private key unless you enable --check and the\n  old value is encrypted.\n\n  -e, --eyamlcrypt      encrypt the new value using EYAML\n  -x EYAML, --eyaml EYAML\n                        the eyaml binary to use when it isn't on the PATH\n  -r PRIVATEKEY, --privatekey PRIVATEKEY\n                        EYAML private key\n  -u PUBLICKEY, --publickey PUBLICKEY\n                        EYAML public key\n\nWhen no changes are made, no backup is created, even when -b/--backup is\nspecified. For more information about YAML Paths, please visit\nhttps://github.com/wwkimball/yamlpath.\n```\n\n### Libraries\n\nWhile there are several supporting library files like enumerations, types, and\nexceptions, the most interesting library files include:\n\n* [yamlpath.py](yamlpath/yamlpath.py) -- The core YAML Path parser logic.\n* [processor.py](yamlpath/processor.py) -- Processes YAMLPath instances to read\n  or write data to YAML/Compatible sources.\n* [eyamlprocessor.py](yamlpath/eyaml/eyamlprocessor.py) -- Extends the\n  Processor class to support EYAML data encryption and decryption.\n\n## Basic Usage\n\nThe files of this project can be used either as command-line tools or as\nlibraries to supplement your own work.\n\n### Basic Usage:  Command-Line Tools\n\nThe command-line tools are self-documented and [their documentation is captured\nabove](#command-line-tools) for easy reference.  Simply pass `--help` to them in\norder to obtain the same detailed documentation.\n\nPlease review [the comprehensive test_commands_*.py unit tests](/tests/) to\nexplore samples of YAML files and the many ways these tools help get and set\ntheir data.\n\nThe following are some simple examples of their typical use-cases.\n\n#### Rotate Your EYAML Keys\n\nIf the eyaml command is already on your PATH (if not, be sure to also supply\nthe optional `--eyaml` or `-x` argument):\n\n```shell\neyaml-rotate-keys \\\n  --oldprivatekey=~/old-keys/private_key.pkcs7.pem \\\n  --oldpublickey=~/old-keys/public_key.pkcs7.pem \\\n  --newprivatekey=~/new-keys/private_key.pkcs7.pem \\\n  --newpublickey=~/new-keys/public_key.pkcs7.pem \\\n  my_1st_yaml_file.yaml my_2nd_yaml_file.eyaml ... my_Nth_yaml_file.yaml\n```\n\nYou could combine this with `find` and `xargs` if your E/YAML file are\ndispersed through a directory hierarchy, as with Hiera data.\n\n##### EYAML Compatibility Alert\n\nThe maintainers of the hiera-eyaml project have released version 3.x and it is\n*not backward compatible* with encryption certificates generated for\nhiera-eyaml version 2.x.  This has nothing to do with YAML Path and is alerted\nhere only as a courtesy to YAML Path users.  **If you upgrade your\ninstallation of hiera-eyaml without first updating your encryption\ncertificates and using a tool like eyaml-rotate-keys (provided here) to\nre-encrypt your data with the replacement certificates, hiera-eyaml 3.x will\nfail to decrypt your data!**  This is *not* a problem with YAML Path.\nhiera-eyaml certificate compatibility is well outside the purview of YAML Path\nand its tools.\n\n#### Get a YAML Value\n\nAt its simplest:\n\n```shell\nyaml-get \\\n  --query=see.documentation.above.for.many.samples \\\n  my_yaml_file.yaml\n```\n\n#### Search For YAML Paths\n\nSimplest use:\n\n```shell\nyaml-paths \\\n  --search=%word \\\n  /some/directory/*.yaml\n```\n\nSearch for multiple expressions and exclude unwanted results:\n\n```shell\nyaml-paths \\\n  --search=^another \\\n  --search=$word \\\n  --except=%bad \\\n  /some/directory/*.yaml\n```\n\nReturn all leaf nodes under matching parents (most useful when matching against Hash keys and you only want the original leaf nodes beneath them):\n\n```shell\nyaml-paths \\\n  --expand \\\n  --keynames \\\n  --search==parent_node \\\n  /some/directory/*.yaml\n```\n\n#### Change a YAML Value\n\nFor a no-frills change to a YAML file with deeply nested Hash structures:\n\n```shell\nyaml-set \\\n  --change=see.documentation.above.for.many.samples \\\n  --value=\"New Value\" \\\n  my_yaml_file.yaml\n```\n\nTo rotate a password, preserving the old password perhaps so your automation can\napply the new password to your application(s):\n\n```shell\nyaml-set \\\n  --mustexist \\\n  --change=the.new.password \\\n  --saveto=the.old.password \\\n  --value=\"New Password\" \\\n  my_yaml_file.yaml\n```\n\nFor the extremely cautious, you could check the old password before rotating\nit and save a backup of the original file:\n\n```shell\nyaml-set \\\n  --mustexist \\\n  --change=the.new.password \\\n  --saveto=the.old.password \\\n  --check=\"Old Password\" \\\n  --value=\"New Password\" \\\n  --backup \\\n  my_yaml_file.yaml\n```\n\nYou can also add EYAML encryption (assuming the `eyaml` command is on your\nPATH; if not, you can pass `--eyaml` to specify its location).  In this example,\nI add the optional `--format=folded` so that the long EYAML value is broken up\ninto a multi-line value rather than one very long string.  This is the preferred\nformat for human legibility as well as EYAML consumers like\n[Puppet](http://puppet.com).  Note that `--format` has several other settings\nand applies only to new values.\n\n```shell\nyaml-set \\\n  --change=the.new.password \\\n  --mustexist \\\n  --saveto=the.old.password \\\n  --check=\"Old Password\" \\\n  --value=\"New Password\" \\\n  --eyamlcrypt \\\n  --format=folded \\\n  --backup \\\n  my_yaml_file.yaml\n```\n\nYou can even tell EYAML which keys to use, if not your default system or user\nkeys:\n\n```shell\nyaml-set \\\n  --change=the.new.password \\\n  --mustexist \\\n  --saveto=the.old.password \\\n  --check=\"Old Password\" \\\n  --value=\"New Password\" \\\n  --eyamlcrypt \\\n  --format=folded \\\n  --privatekey=/secret/keys/private_key.pkcs7.pem \\\n  --publickey=/secret/keys/public_key.pkcs7.pem \\\n  --backup \\\n  my_yaml_file.yaml\n```\n\nNote that for even greater security scenarios, you can keep the new value off of\nyour command-line, process list, and command history by swapping out `--value`\nfor one of `--stdin`, `--file`, or even `--random LENGTH` (use Python's\nstrongest random value generator if you don't need to specify the replacement\nvalue in advance).\n\n### Basic Usage:  Libraries\n\nAs for the libraries, they are also heavily documented and the example\nimplementations may perhaps serve as good copy-paste fodder (provided you give\ncredit to the source).  That said, here's a general flow/synopsis.\n\n#### Initialize ruamel.yaml and These Helpers\n\nYour preferences may differ, but I use this setup for round-trip YAML parsing\nand editing with ruamel.yaml.  When you need to process EYAML encrypted data,\nreplace `yamlpath.Processor` with `yamlpath.eyaml.EYAMLProcessor` and add error\nhandling for `yamlpath.eyaml.EYAMLCommandException`.\n\nNote that `import yamlpath.patches` is entirely optional.  I wrote and use it to\nblock ruamel.yaml's Emitter from injecting unnecessary newlines into folded\nvalues (it improperly converts every single new-line into two for left-flushed\nmulti-line values, at the time of this writing).  Since \"block\" output EYAML\nvalues are left-flushed multi-line folded strings, this fix is necessary when\nusing EYAML features.  At least, until ruamel.yaml has its own fix for this\nissue.\n\nNote also that these examples use `ConsolePrinter` to handle STDOUT and STDERR\nmessaging.  You don't have to.  However, some kind of logger must be passed to\nthese libraries so they can write messages _somewhere_.  Your custom message\nhandler or logger must provide the same API as `ConsolePrinter`; review the\nheader documentation in [consoleprinter.py](yamlpath/wrappers/consoleprinter.py)\nfor details.  Generally speaking, it would be trivial to write your own custom\nwrapper for Python's standard logging facilities if you require targets other\nthan STDOUT and STDERR.\n\n```python\nimport sys\n\nfrom ruamel.yaml import YAML\nfrom ruamel.yaml.parser import ParserError\n\nimport yamlpath.patches\nfrom yamlpath.func import get_yaml_data, get_yaml_editor\nfrom yamlpath.wrappers import ConsolePrinter\nfrom yamlpath import Processor\n\n# Process command-line arguments and initialize the output writer\nargs = processcli()\nlog = ConsolePrinter(args)\n\n# Prep the YAML parser and round-trip editor (tweak to your needs)\nyaml = get_yaml_editor()\n\n# At this point, you'd load or parse your YAML file, stream, or string.  When\n# loading from file, I typically follow this pattern:\nyaml_data = get_yaml_data(yaml, log, yaml_file)\nif yaml_data is None:\n    # There was an issue loading the file; an error message has already been\n    # printed.\n    exit(1)\n\n# Pass the log writer and parsed YAML data to the YAMLPath processor\nprocessor = Processor(log, yaml_data)\n\n# At this point, the processor is ready to handle YAMLPaths\n```\n\n#### Searching for YAML Nodes\n\nThese libraries use [Generators](https://wiki.python.org/moin/Generators) to get\nnodes from parsed YAML data.  Identify which node(s) to get via YAML Path\nstrings.  You should also catch `yamlpath.exceptions.YAMLPathException`s\nunless you prefer Python's native stack traces.  When using EYAML, you should\nalso catch `yamlpath.eyaml.exceptions.EYAMLCommandException`s for the same\nreason.  Whether you are working with a single result or many, you should\nconsume the Generator output with a pattern similar to:\n\n```python\nfrom yamlpath import YAMLPath\nfrom yamlpath.exceptions import YAMLPathException\n\nyaml_path = YAMLPath(\"see.documentation.above.for.many.samples\")\ntry:\n    for node_coordinate in processor.get_nodes(yaml_path):\n        log.debug(\"Got {} from '{}'.\".format(node_coordinate, yaml_path))\n        # Do something with each node_coordinate.node (the actual data)\nexcept YAMLPathException as ex:\n    # If merely retrieving data, this exception may be deemed non-critical\n    # unless your later code absolutely depends upon a result.\n    log.error(ex)\n```\n\n#### Changing Values\n\nAt its simplest, you only need to supply the the YAML Path to one or more nodes\nto update, and the value to apply to them.  Catching\n`yamlpath.exceptions.YAMLPathException` is optional but usually preferred over\nallowing Python to dump the call stack in front of your users.  When using\nEYAML, the same applies to `yamlpath.eyaml.exceptions.EYAMLCommandException`.\n\n```python\nfrom yamlpath.exceptions import YAMLPathException\n\ntry:\n    processor.set_value(yaml_path, new_value)\nexcept YAMLPathException as ex:\n    log.critical(ex, 119)\nexcept EYAMLCommandException as ex:\n    log.critical(ex, 120)\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/wwkimball/yamlpath", "keywords": "yaml eyaml yaml-path", "license": "ISC", "maintainer": "", "maintainer_email": "", "name": "yamlpath", "package_url": "https://pypi.org/project/yamlpath/", "platform": "", "project_url": "https://pypi.org/project/yamlpath/", "project_urls": {"Homepage": "https://github.com/wwkimball/yamlpath"}, "release_url": "https://pypi.org/project/yamlpath/2.3.4/", "requires_dist": null, "requires_python": ">3.6.0", "summary": "Read and change YAML/Compatible data using powerful, intuitive, command-line friendly syntax", "version": "2.3.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>YAML Path and Command-Line Tools</h1>\n<p><a href=\"https://travis-ci.org/wwkimball/yamlpath\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f90495f768b7fc53e81b23a276f2d360dfbd585e/68747470733a2f2f7472617669732d63692e6f72672f77776b696d62616c6c2f79616d6c706174682e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.org/project/yamlpath/\" rel=\"nofollow\"><img alt=\"Python versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cc9a7e2de455874f8046fd16e68870dd482ea9ae/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f79616d6c706174682e737667\"></a>\n<a href=\"https://pypi.org/project/yamlpath/\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7cd725a1b3301b7dd30629b8114917649226e53a/68747470733a2f2f62616467652e667572792e696f2f70792f79616d6c706174682e737667\"></a>\n<a href=\"https://pepy.tech/project/yamlpath\" rel=\"nofollow\"><img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1c4f1dcc1158eeb1f6d1181f6b4cfa6c14c78229/68747470733a2f2f706570792e746563682f62616467652f79616d6c70617468\"></a>\n<a href=\"https://coveralls.io/github/wwkimball/yamlpath?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9264e1944196a6c6781da0247e6adfee107c5e19/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f77776b696d62616c6c2f79616d6c706174682f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://www.codacy.com/manual/wwkimball/yamlpath?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=wwkimball/yamlpath&amp;utm_campaign=Badge_Grade\" rel=\"nofollow\"><img alt=\"Codacy Badge\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/655d1b34d8d09c8d89130cc472f1c060f341ea42/68747470733a2f2f6170692e636f646163792e636f6d2f70726f6a6563742f62616467652f47726164652f3662636331663237363738353433393039323361386432356132653461313931\"></a></p>\n<p>Along with providing a\n<a href=\"https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path\" rel=\"nofollow\">standard for defining YAML Paths</a>,\nthis project aims to provide\n<a href=\"https://github.com/wwkimball/yamlpath/wiki/Command-Line-(CLI)-Tools\" rel=\"nofollow\">generally-useful command-line tools</a>\nwhich implement YAML Paths.  These bring intuitive YAML, EYAML, JSON, and\ncompatible data parsing and editing capabilties to the command-line.  It is\nalso a\n<a href=\"https://github.com/wwkimball/yamlpath/wiki/Python-Library\" rel=\"nofollow\">Python library</a>\nfor other projects to readily employ YAML Paths.</p>\n<h2>Contents</h2>\n<ol>\n<li><a href=\"#introduction\" rel=\"nofollow\">Introduction</a></li>\n<li><a href=\"#illustration\" rel=\"nofollow\">Illustration</a></li>\n<li><a href=\"#installing\" rel=\"nofollow\">Installing</a></li>\n<li><a href=\"#supported-yaml-path-segments\" rel=\"nofollow\">Supported YAML Path Segments</a></li>\n<li><a href=\"#based-on-ruamelyaml-and-python-3\" rel=\"nofollow\">Based on ruamel.yaml and Python 3</a></li>\n<li><a href=\"#the-files-of-this-project\" rel=\"nofollow\">The Files of This Project</a>\n<ol>\n<li><a href=\"#command-line-tools\" rel=\"nofollow\">Command-Line Tools</a></li>\n<li><a href=\"#libraries\" rel=\"nofollow\">Libraries</a></li>\n</ol>\n</li>\n<li><a href=\"#basic-usage\" rel=\"nofollow\">Basic Usage</a>\n<ol>\n<li><a href=\"#basic-usage--command-line-tools\" rel=\"nofollow\">Basic Usage:  Command-Line Tools</a>\n<ol>\n<li><a href=\"#rotate-your-eyaml-keys\" rel=\"nofollow\">Rotate Your EYAML Keys</a></li>\n<li><a href=\"#get-a-yaml-value\" rel=\"nofollow\">Get a YAML Value</a></li>\n<li><a href=\"#search-for-yaml-paths\" rel=\"nofollow\">Search For YAML Paths</a></li>\n<li><a href=\"#change-a-yaml-value\" rel=\"nofollow\">Change a YAML Value</a></li>\n</ol>\n</li>\n<li><a href=\"#basic-usage--libraries\" rel=\"nofollow\">Basic Usage:  Libraries</a>\n<ol>\n<li><a href=\"#initialize-ruamelyaml-and-these-helpers\" rel=\"nofollow\">Initialize ruamel.yaml and These Helpers</a></li>\n<li><a href=\"#searching-for-yaml-nodes\" rel=\"nofollow\">Searching for YAML Nodes</a></li>\n<li><a href=\"#changing-values\" rel=\"nofollow\">Changing Values</a></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2>Introduction</h2>\n<p>This project presents and utilizes YAML Paths, which are a powerful, intuitive\nmeans of identifying one <em>or more</em> nodes within <a href=\"https://yaml.org/\" rel=\"nofollow\">YAML</a>,\n<a href=\"https://github.com/voxpupuli/hiera-eyaml\" rel=\"nofollow\">EYAML</a>, or compatible data structures\nlike <a href=\"https://www.json.org/\" rel=\"nofollow\">JSON</a>.  Both dot-notation (inspired by\n<a href=\"https://github.com/puppetlabs/hiera\" rel=\"nofollow\">Hiera</a>) and forward-slash-notation\n(influenced by <a href=\"https://www.w3schools.com/xml/xml_xpath.asp\" rel=\"nofollow\">XPath</a>) are\nsupported.  The <a href=\"#libraries\" rel=\"nofollow\">libraries</a> (modules) and several <a href=\"#command-line-tools\" rel=\"nofollow\">command-line tool\nimplementations</a> are provided.  With these, you can build\nYAML Path support right into your own application or easily use its capabilities\nright away from the command-line to retrieve or update YAML/Compatible data.</p>\n<p>This implementation of YAML Path is a <em>query language</em> in addition to a <em>node\ndescriptor</em>.  With it, you can describe or select a single precise node or\nsearch for any number of nodes that match some criteria.  Keys, values, and\nelements can all be searched at any number of levels within the data structure\nusing the same query.  Collectors can also be used to gather and further select\nfrom otherwise disparate parts of the source data.</p>\n<p>The <a href=\"https://github.com/wwkimball/yamlpath/wiki\" rel=\"nofollow\">project Wiki</a> provides a\ndeeper dive into these concepts.</p>\n<h2>Illustration</h2>\n<p>To illustrate some of these concepts, consider these samples:</p>\n<pre><span class=\"nn\">---</span>\n<span class=\"nt\">hash</span><span class=\"p\">:</span>\n  <span class=\"nt\">child_attr</span><span class=\"p\">:</span>\n    <span class=\"nt\">key</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">5280</span>\n</pre>\n<p>This value, <code>5280</code>, can be identified via YAML Path as any of:</p>\n<ol>\n<li><code>hash.child_attr.key</code> (dot-notation)</li>\n<li><code>hash.child_attr[.=key]</code> (search all child keys for one named, <code>key</code>, and\nyield its value)</li>\n<li><code>/hash/child_attr/key</code> (same as 1 but in forward-slash notation)</li>\n<li><code>/hash/child_attr[.=key]</code> (same as 2 but in forward-slash notation)</li>\n</ol>\n<pre><span class=\"nn\">---</span>\n<span class=\"nt\">aliases</span><span class=\"p\">:</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nl\">&amp;first_anchor</span> <span class=\"l l-Scalar l-Scalar-Plain\">Simple string value</span>\n</pre>\n<p>With YAML Path, you can select this anchored value by any of these equivalent\nexpressions:</p>\n<ol>\n<li><code>aliases[0]</code> (explicit array element number)</li>\n<li><code>aliases.0</code> (implicit array element number in dot-notation)</li>\n<li><code>aliases[&amp;first_anchor]</code> (search by Anchor name)</li>\n<li><code>aliases[.^Simple]</code> (search for any elements starting with \"Simple\")</li>\n<li><code>aliases[.%string]</code> (search for any elements containing \"string\")</li>\n<li><code>aliases[.$value]</code> (search for any elements ending with \"value\")</li>\n<li><code>aliases[.=~/^(\\b[Ss][a-z]+\\s){2}[a-z]+$/]</code> (search for any elements matching\na complex Regular Expression, which happens to match the example)</li>\n<li><code>/aliases[0]</code> (same as 1 but in forward-slash notation)</li>\n<li><code>/aliases/0</code> (same as 2 but in forward-slash notation)</li>\n<li><code>/aliases[&amp;first_anchor]</code> (same as 3 but in forward-slash notation)</li>\n</ol>\n<pre><span class=\"nn\">---</span>\n<span class=\"nt\">users</span><span class=\"p\">:</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">name</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">User One</span>\n    <span class=\"nt\">password</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">ENC[PKCS7,MIIBiQY...Jk==]</span>\n    <span class=\"nt\">roles</span><span class=\"p\">:</span>\n      <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">Writers</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">name</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">User Two</span>\n    <span class=\"nt\">password</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">ENC[PKCS7,MIIBiQY...vF==]</span>\n    <span class=\"nt\">roles</span><span class=\"p\">:</span>\n      <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">Power Users</span>\n      <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">Editors</span>\n</pre>\n<p>With an example like this, YAML Path enables:</p>\n<ul>\n<li>selection of single nodes: <code>/users/0/roles/0</code> = <code>Writers</code></li>\n<li>all children nodes of any given parent: <code>/users/1/roles</code> =\n<code>[\"Power Users\", \"Editors\"]</code></li>\n<li>searching by a child attribute: <code>/users[name=\"User One\"]/password</code> =\n<code>Some decrypted value, provided you have the appropriate EYAML keys</code></li>\n<li>pass-through selections against arrays-of-hashes: <code>/users/roles</code> =\n<code>[\"Writers\"]\\n[\"Power Users\", \"Editors\"]</code> (each user's list of roles are a\nseperate result)</li>\n<li>collection of disparate results: <code>(/users/name)</code> =\n<code>[\"User One\", \"User Two\"]</code> (all names appear in a single result instead of\none per line)</li>\n</ul>\n<p>For a deeper exploration of YAML Path's capabilities, please visit the\n<a href=\"https://github.com/wwkimball/yamlpath/wiki\" rel=\"nofollow\">project Wiki</a>.</p>\n<h2>Supported YAML Path Segments</h2>\n<p>A YAML Path <em>segment</em> is the text between seperators which identifies zero or\nmore parent or leaf nodes within the data structure.  For dot-notation, a path\nlike <code>hash.key</code> identifies two segments:  <code>hash</code> (a parent node) and <code>key</code> (a\nleaf node).  The same path in forward-slash notation would be:  <code>/hash/key</code>.</p>\n<p>YAML Path understands these segment types:</p>\n<ul>\n<li>Top-level Hash key selection: <code>key</code></li>\n<li>Explicit top-level array element selection: <code>[#]</code> where <code>#</code> is the zero-based\nelement number; <code>#</code> can also be negative, causing the element to be selected\nfrom the end of the Array</li>\n<li>Implicit array element selection <strong>or</strong> numbered hash key selection: <code>#</code>\nwhere <code>#</code> is the 0-based element number <strong>or</strong> exact name of a hash key which\nis itself a number</li>\n<li>Top-level (Hash) Anchor lookups: <code>&amp;anchor_name</code> (the <code>&amp;</code> is required to\nindicate you are seeking an Anchor by name)</li>\n<li>Hash sub-keys:  <code>hash.child.key</code> or <code>/hash/child/key</code></li>\n<li>Demarcation for dotted Hash keys:  <code>hash.'dotted.child.key'</code> or\n<code>hash.\"dotted.child.key\"</code> (not necessary when using forward-slash notation,\n<code>/hash/dotted.child.key</code>)</li>\n<li>Named Array element selection:  <code>array[#]</code>, <code>array.#</code>, <code>/array[#]</code>, or\n<code>/array/#</code> where <code>array</code> is the name of the Hash key containing Array data\nand <code>#</code> is the 0-based element number</li>\n<li>Anchor lookups in named Arrays:  <code>array[&amp;anchor_name]</code>  where <code>array</code> is the\nname of the Hash key containing Array data and both of the <code>[]</code> pair and <code>&amp;</code>\nare required to indicate you are seeking an Anchor by name within an Array</li>\n<li>Array slicing: <code>array[start#:stop#]</code> where <code>start#</code> is the first inclusive,\nzero-based element and <code>stop#</code> is the last exclusive element to select;\neither or both can be negative, causing the elements to be selected from the\nend of the Array; when <code>start#</code> and <code>stop#</code> are identical, it is the same as\n<code>array[start#]</code></li>\n<li>Hash slicing: <code>hash[min:max]</code> where <code>min</code> and <code>max</code> are alphanumeric terms\nbetween which the Hash's keys are compared</li>\n<li>Escape symbol recognition:  <code>hash.dotted\\.child\\.key</code>,\n<code>/hash/whacked\\/child\\/key</code>, and <code>keys_with_\\\\slashes</code></li>\n<li>Hash attribute searches (which can return zero or more matches):\n<ul>\n<li>Exact match:  <code>hash[name=admin]</code></li>\n<li>Starts With match:  <code>hash[name^adm]</code></li>\n<li>Ends With match:  <code>hash[name$min]</code></li>\n<li>Contains match:  <code>hash[name%dmi]</code></li>\n<li>Less Than match: <code>hash[access_level&lt;500]</code></li>\n<li>Greater Than match: <code>hash[access_level&gt;0]</code></li>\n<li>Less Than or Equal match: <code>hash[access_level&lt;=100]</code></li>\n<li>Greater Than or Equal match: <code>hash[access_level&gt;=0]</code></li>\n<li>Regular Expression matches: <code>hash[access_level=~/^\\D+$/]</code> (the <code>/</code> Regular\nExpression delimiter can be substituted for any character you need, except\nwhite-space; note that <code>/</code> does not interfere with forward-slash notation\n<em>and it does not need to be escaped</em> because the entire search expression is\ncontained within a <code>[]</code> pair)</li>\n<li>Invert any match with <code>!</code>, like: <code>hash[name!=admin]</code> or even\n<code>hash[!name=admin]</code> (the former syntax is used when YAML Paths are\nstringified but both forms are equivalent)</li>\n<li>Demarcate and/or escape expression operands, like:\n<code>hash[full\\ name=\"Some User\\'s Name\"]</code> (note that embedded, single <code>'</code> and\n<code>\"</code> must be escaped lest they be deemed unmatched demarcation pairings)</li>\n<li>Multi-level matching: <code>hash[name%admin].pass[encrypted!^ENC\\[]</code> or\n<code>/hash[name%admin]/pass[encrypted!^ENC\\[]</code></li>\n</ul>\n</li>\n<li>Array element searches with all of the search methods above via <code>.</code> (yields\nany matching elements): <code>array[.&gt;9000]</code></li>\n<li>Hash key-name searches with all of the search methods above via <code>.</code> (yields\ntheir values, not the keys themselves): <code>hash[.^app_]</code></li>\n<li>Array-of-Hashes Pass-Through Selection:  Omit a selector for the elements of\nan Array-of-Hashes and all matching Hash attributes at that level will be\nyielded (or searched when there is more to the path).  For example,\n<code>warriors[1].power_level</code> or <code>/warriors[1]/power_level</code> will return the\npower_level attribute of only the second Hash in an Array-of-Hashes while\n<code>warriors.power_level</code> or <code>/warriors/power_level</code> will return the power_level\nattribute of every Hash in the same Array-of-Hashes.  Of course these results\ncan be filtered in multiple ways, like <code>warriors[power_level&gt;9000]</code>,\n<code>/warriors[power_level&gt;9000]</code>, <code>warriors.power_level[.&gt;9000]</code>, and\n<code>/warriors/power_level[.&gt;9000]</code> all yield only the power_level from <em>all</em>\nwarriors with power_levels over 9,000 within the same array of warrior hashes.</li>\n<li>Collectors:  Placing any portion of the YAML Path within parenthesis defines a\nvirtual list collector, like <code>(YAML Path)</code>; concatenation and exclusion\noperators are supported -- <code>+</code> and <code>-</code>, respectively -- along with nesting,\nlike <code>(...)-((...)+(...))</code></li>\n<li>Complex combinations:\n<code>some::deep.hierarchy[with!=\"\"].'any.valid'[.=~/(yaml|json)/][data%structure].or.complexity[4].2</code>\nor <code>/some::deep/hierarchy[with!=\"\"]/any.valid[.=~/(yaml|json)/][data%structure]/or/complexity[4]/2</code></li>\n</ul>\n<p>This implementation of YAML Path encourages creativity.  Use whichever notation\nand segment types that make the most sense to you in each application.</p>\n<p>The <a href=\"https://github.com/wwkimball/yamlpath/wiki/Segments-of-a-YAML-Path\" rel=\"nofollow\">project Wiki provides more illustrative details of YAML Path Segments</a>.</p>\n<h2>Installing</h2>\n<p>This project requires <a href=\"https://www.python.org/\" rel=\"nofollow\">Python</a> 3.  It is tested\nagainst Pythons 3.6 through 3.8.  Most operating systems and distributions\nhave access to Python 3 even if only Python 2 -- or no Python, at all -- came\npre-installed.  It is generally safe to have more than one version of Python\non your system at the same time, especially when using\n<a href=\"https://docs.python.org/3/library/venv.html\" rel=\"nofollow\">virtual Python environments</a>.</p>\n<p>Each published version of this project can be installed from\n<a href=\"https://pypi.org/\" rel=\"nofollow\">PyPI</a> using <code>pip</code>.  Note that on systems with more than one\nversion of Python, you will probably need to use <code>pip3</code>, or equivalent (e.g.:\nCygwin users may need to use <code>pip3.6</code>).</p>\n<pre>pip3 install yamlpath\n</pre>\n<p>EYAML support is entirely optional.  You do not need EYAML to use YAML Path.\nThat YAML Path supports EYAML is a service to a substantial audience:  Puppet\nusers.  At the time of this writing, EYAML (classified as a Hiera\nback-end/plug-in) is available only as a Ruby Gem.  That said, it provides a\ncommand-line tool, <code>eyaml</code>, which can be employed by this otherwise Python\nproject.  To enjoy EYAML support, install compatible versions of ruby and\nrubygems, then execute:</p>\n<pre>gem install hiera-eyaml\n</pre>\n<p>If this puts the <code>eyaml</code> command on your system <code>PATH</code>, nothing more need be\ndone apart from generating or obtaining your encryption keys.  Otherwise, you\ncan tell YAML Path library and tools where to find the <code>eyaml</code> command.</p>\n<h2>Based on ruamel.yaml and Python 3</h2>\n<p>In order to support the best available YAML editing capability (so called,\nround-trip editing with support for comment preservation), this project is based\non <a href=\"https://bitbucket.org/ruamel/yaml/overview\" rel=\"nofollow\">ruamel.yaml</a> for\nPython 3.  While ruamel.yaml is based on PyYAML --\nPython's \"standard\" YAML library -- ruamel.yaml is <a href=\"https://yaml.readthedocs.io/en/latest/pyyaml.html\" rel=\"nofollow\">objectively better than\nPyYAML</a>, which lacks critical\nround-trip editing capabilities as well as up-to-date YAML/Compatible data\nparsing capabilities (at the time of this writing).</p>\n<p>Should PyYAML ever merge with -- or at least, catch up with -- ruamel.yaml, this\nproject can be (lightly) adapted to depend on it, instead.  These conversations\nmay offer some insight into when or whether this might happen:</p>\n<ul>\n<li><a href=\"https://github.com/yaml/pyyaml/issues/31\" rel=\"nofollow\">Is this time to pass the baton?</a></li>\n<li><a href=\"https://github.com/yaml/pyyaml/issues/46\" rel=\"nofollow\">Rebase off ruamel? - many new valuable features</a></li>\n</ul>\n<h2>The Files of This Project</h2>\n<p>This repository contains:</p>\n<ol>\n<li>Generally-useful Python library files.  These contain the reusable core of\nthis project's YAML Path capabilities.</li>\n<li>Some implementations of those libraries, exhibiting their capabilities and\nsimple-to-use APIs as command-line tools.</li>\n<li>Various support, documentation, and build files.</li>\n</ol>\n<h3>Command-Line Tools</h3>\n<p>This project provides some command-line tool implementations which utilize YAML\nPath.  For some use-case examples of these tools,\n<a href=\"#basic-usage--command-line-tools\" rel=\"nofollow\">see below</a>.</p>\n<p>The supplied command-line tools include:</p>\n<ul>\n<li><a href=\"yamlpath/commands/eyaml_rotate_keys.py\" rel=\"nofollow\">eyaml-rotate-keys</a></li>\n</ul>\n<pre>usage: eyaml-rotate-keys [-h] [-V] [-d | -v | -q] [-b] [-x EYAML]\n                         -i OLDPRIVATEKEY -c OLDPUBLICKEY\n                         -r NEWPRIVATEKEY -u NEWPUBLICKEY\n                         YAML_FILE [YAML_FILE ...]\n\nRotates the encryption keys used for all EYAML values within a set of YAML\nfiles, decrypting with old keys and re-encrypting using replacement keys.\n\npositional arguments:\n  YAML_FILE             one or more YAML files containing EYAML values\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n  -b, --backup          save a backup of each modified YAML_FILE with an extra\n                        .bak file-extension\n  -x EYAML, --eyaml EYAML\n                        the eyaml binary to use when it isn't on the PATH\n\nEYAML_KEYS:\n  All key arguments are required\n\n  -r NEWPRIVATEKEY, --newprivatekey NEWPRIVATEKEY\n                        the new EYAML private key\n  -u NEWPUBLICKEY, --newpublickey NEWPUBLICKEY\n                        the new EYAML public key\n  -i OLDPRIVATEKEY, --oldprivatekey OLDPRIVATEKEY\n                        the old EYAML private key\n  -c OLDPUBLICKEY, --oldpublickey OLDPUBLICKEY\n                        the old EYAML public key\n\nAny YAML_FILEs lacking EYAML values will not be modified (or backed up, even\nwhen -b/--backup is specified).\n</pre>\n<ul>\n<li><a href=\"yamlpath/commands/yaml_get.py\" rel=\"nofollow\">yaml-get</a></li>\n</ul>\n<pre>usage: yaml-get [-h] [-V] -p YAML_PATH\n                [-t ['.', '/', 'auto', 'dot', 'fslash']] [-x EYAML]\n                [-r PRIVATEKEY] [-u PUBLICKEY] [-d | -v | -q]\n                YAML_FILE\n\nRetrieves one or more values from a YAML file at a specified YAML Path. Output\nis printed to STDOUT, one line per result. When a result is a complex data-\ntype (Array or Hash), a JSON dump is produced to represent it. EYAML can be\nemployed to decrypt the values.\n\npositional arguments:\n  YAML_FILE             the YAML file to query\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which YAML Path seperator to use when\n                        rendering results; default=dot\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n\nrequired settings:\n  -p YAML_PATH, --query YAML_PATH\n                        YAML Path to query\n\nEYAML options:\n  Left unset, the EYAML keys will default to your system or user defaults.\n  Both keys must be set either here or in your system or user EYAML\n  configuration file when using EYAML.\n\n  -x EYAML, --eyaml EYAML\n                        the eyaml binary to use when it isn't on the PATH\n  -r PRIVATEKEY, --privatekey PRIVATEKEY\n                        EYAML private key\n  -u PUBLICKEY, --publickey PUBLICKEY\n                        EYAML public key\n\nFor more information about YAML Paths, please visit\nhttps://github.com/wwkimball/yamlpath.\n</pre>\n<ul>\n<li><a href=\"yamlpath/commands/yaml_paths.py\" rel=\"nofollow\">yaml-paths</a></li>\n</ul>\n<pre>usage: yaml-paths [-h] [-V] -s EXPRESSION [-c EXPRESSION] [-d | -v | -q] [-m]\n                  [-L] [-F] [-X] [-P] [-t ['.', '/', 'auto', 'dot', 'fslash']]\n                  [-i | -k | -K] [-a] [-A | -Y | -y | -l] [-e] [-x EYAML]\n                  [-r PRIVATEKEY] [-u PUBLICKEY]\n                  YAML_FILE [YAML_FILE ...]\n\nReturns zero or more YAML Paths indicating where in given YAML/Compatible data\none or more search expressions match. Values, keys, and/or anchors can be\nsearched. EYAML can be employed to search encrypted values.\n\npositional arguments:\n  YAML_FILE             one or more YAML files to search\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n  -c EXPRESSION, --except EXPRESSION\n                        except results matching this search expression; can be\n                        set more than once\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all non-result output except errors\n  -m, --expand          expand matching parent nodes to list all permissible\n                        child leaf nodes (see \"reference handling options\" for\n                        restrictions)\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which YAML Path seperator to use when\n                        rendering results; default=dot\n  -a, --refnames        also search the names of &amp;anchor and *alias references\n\nrequired settings:\n  -s EXPRESSION, --search EXPRESSION\n                        the search expression; can be set more than once\n\nresult printing options:\n  -L, --values          print the values or elements along with each YAML Path\n                        (complex results are emitted as JSON; use --expand to\n                        emit only simple values)\n  -F, --nofile          omit source file path and name decorators from the\n                        output (applies only when searching multiple files)\n  -X, --noexpression    omit search expression decorators from the output\n  -P, --noyamlpath      omit YAML Paths from the output (useful with --values\n                        or to indicate whether a file has any matches without\n                        printing them all, perhaps especially with\n                        --noexpression)\n\nkey name searching options:\n  -i, --ignorekeynames  (default) do not search key names\n  -k, --keynames        search key names in addition to values and array\n                        elements\n  -K, --onlykeynames    only search key names (ignore all values and array\n                        elements)\n\nreference handling options:\n  Indicate how to treat anchor and alias references. An anchor is an\n  original, reusable key or value. All aliases become replaced by the\n  anchors they reference when YAML data is read. These options specify how\n  to handle this duplication of keys and values. Note that the default\n  behavior includes all aliased keys but not aliased values.\n\n  -A, --anchorsonly     include only original matching key and value anchors\n                        in results, discarding all aliased keys and values\n                        (including child nodes)\n  -Y, --allowkeyaliases\n                        (default) include matching key aliases, permitting\n                        search traversal into their child nodes\n  -y, --allowvaluealiases\n                        include matching value aliases (does not permit search\n                        traversal into aliased keys)\n  -l, --allowaliases    include all matching key and value aliases\n\nEYAML options:\n  Left unset, the EYAML keys will default to your system or user defaults.\n  Both keys must be set either here or in your system or user EYAML\n  configuration file when using EYAML.\n\n  -e, --decrypt         decrypt EYAML values in order to search them\n                        (otherwise, search the encrypted blob)\n  -x EYAML, --eyaml EYAML\n                        the eyaml binary to use when it isn't on the PATH\n  -r PRIVATEKEY, --privatekey PRIVATEKEY\n                        EYAML private key\n  -u PUBLICKEY, --publickey PUBLICKEY\n                        EYAML public key\n\nA search or exception EXPRESSION takes the form of a YAML Path search operator\n-- %, $, =, ^, &gt;, &lt;, &gt;=, &lt;=, =~, or ! -- followed by the search term, omitting\nthe left-hand operand. For more information about YAML Paths, please visit\nhttps://github.com/wwkimball/yamlpath.\n</pre>\n<ul>\n<li><a href=\"yamlpath/commands/yaml_set.py\" rel=\"nofollow\">yaml-set</a></li>\n</ul>\n<pre>usage: yaml-set [-h] [-V] -g YAML_PATH [-a VALUE | -f FILE | -i | -R LENGTH]\n                [-F {bare,boolean,default,dquote,float,folded,int,literal,squote}]\n                [-c CHECK] [-s YAML_PATH] [-m] [-b]\n                [-t ['.', '/', 'auto', 'dot', 'fslash']] [-e] [-x EYAML]\n                [-r PRIVATEKEY] [-u PUBLICKEY] [-d | -v | -q]\n                YAML_FILE\n\nChanges one or more values in a YAML file at a specified YAML Path. Matched\nvalues can be checked before they are replaced to mitigate accidental change.\nWhen matching singular results, the value can be archived to another key\nbefore it is replaced. Further, EYAML can be employed to encrypt the new\nvalues and/or decrypt an old value before checking them.\n\npositional arguments:\n  YAML_FILE             the YAML file to update\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -V, --version         show program's version number and exit\n  -F {bare,boolean,default,dquote,float,folded,int,literal,squote}, --format {bare,boolean,default,dquote,float,folded,int,literal,squote}\n                        override automatic formatting of the new value\n  -c CHECK, --check CHECK\n                        check the value before replacing it\n  -s YAML_PATH, --saveto YAML_PATH\n                        save the old value to YAML_PATH before replacing it;\n                        implies --mustexist\n  -m, --mustexist       require that the --change YAML_PATH already exist in\n                        YAML_FILE\n  -b, --backup          save a backup YAML_FILE with an extra .bak file-\n                        extension\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which YAML Path seperator to use when\n                        rendering results; default=dot\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n\nrequired settings:\n  -g YAML_PATH, --change YAML_PATH\n                        YAML Path where the target value is found\n\ninput options:\n  -a VALUE, --value VALUE\n                        set the new value from the command-line instead of\n                        STDIN\n  -f FILE, --file FILE  read the new value from file (discarding any trailing\n                        new-lines)\n  -i, --stdin           accept the new value from STDIN (best for sensitive\n                        data)\n  -R LENGTH, --random LENGTH\n                        randomly generate a replacement value of a set length\n\nEYAML options:\n  Left unset, the EYAML keys will default to your system or user defaults.\n  You do not need to supply a private key unless you enable --check and the\n  old value is encrypted.\n\n  -e, --eyamlcrypt      encrypt the new value using EYAML\n  -x EYAML, --eyaml EYAML\n                        the eyaml binary to use when it isn't on the PATH\n  -r PRIVATEKEY, --privatekey PRIVATEKEY\n                        EYAML private key\n  -u PUBLICKEY, --publickey PUBLICKEY\n                        EYAML public key\n\nWhen no changes are made, no backup is created, even when -b/--backup is\nspecified. For more information about YAML Paths, please visit\nhttps://github.com/wwkimball/yamlpath.\n</pre>\n<h3>Libraries</h3>\n<p>While there are several supporting library files like enumerations, types, and\nexceptions, the most interesting library files include:</p>\n<ul>\n<li><a href=\"yamlpath/yamlpath.py\" rel=\"nofollow\">yamlpath.py</a> -- The core YAML Path parser logic.</li>\n<li><a href=\"yamlpath/processor.py\" rel=\"nofollow\">processor.py</a> -- Processes YAMLPath instances to read\nor write data to YAML/Compatible sources.</li>\n<li><a href=\"yamlpath/eyaml/eyamlprocessor.py\" rel=\"nofollow\">eyamlprocessor.py</a> -- Extends the\nProcessor class to support EYAML data encryption and decryption.</li>\n</ul>\n<h2>Basic Usage</h2>\n<p>The files of this project can be used either as command-line tools or as\nlibraries to supplement your own work.</p>\n<h3>Basic Usage:  Command-Line Tools</h3>\n<p>The command-line tools are self-documented and <a href=\"#command-line-tools\" rel=\"nofollow\">their documentation is captured\nabove</a> for easy reference.  Simply pass <code>--help</code> to them in\norder to obtain the same detailed documentation.</p>\n<p>Please review <a href=\"/tests/\" rel=\"nofollow\">the comprehensive test_commands_*.py unit tests</a> to\nexplore samples of YAML files and the many ways these tools help get and set\ntheir data.</p>\n<p>The following are some simple examples of their typical use-cases.</p>\n<h4>Rotate Your EYAML Keys</h4>\n<p>If the eyaml command is already on your PATH (if not, be sure to also supply\nthe optional <code>--eyaml</code> or <code>-x</code> argument):</p>\n<pre>eyaml-rotate-keys <span class=\"se\">\\</span>\n  --oldprivatekey<span class=\"o\">=</span>~/old-keys/private_key.pkcs7.pem <span class=\"se\">\\</span>\n  --oldpublickey<span class=\"o\">=</span>~/old-keys/public_key.pkcs7.pem <span class=\"se\">\\</span>\n  --newprivatekey<span class=\"o\">=</span>~/new-keys/private_key.pkcs7.pem <span class=\"se\">\\</span>\n  --newpublickey<span class=\"o\">=</span>~/new-keys/public_key.pkcs7.pem <span class=\"se\">\\</span>\n  my_1st_yaml_file.yaml my_2nd_yaml_file.eyaml ... my_Nth_yaml_file.yaml\n</pre>\n<p>You could combine this with <code>find</code> and <code>xargs</code> if your E/YAML file are\ndispersed through a directory hierarchy, as with Hiera data.</p>\n<h5>EYAML Compatibility Alert</h5>\n<p>The maintainers of the hiera-eyaml project have released version 3.x and it is\n<em>not backward compatible</em> with encryption certificates generated for\nhiera-eyaml version 2.x.  This has nothing to do with YAML Path and is alerted\nhere only as a courtesy to YAML Path users.  <strong>If you upgrade your\ninstallation of hiera-eyaml without first updating your encryption\ncertificates and using a tool like eyaml-rotate-keys (provided here) to\nre-encrypt your data with the replacement certificates, hiera-eyaml 3.x will\nfail to decrypt your data!</strong>  This is <em>not</em> a problem with YAML Path.\nhiera-eyaml certificate compatibility is well outside the purview of YAML Path\nand its tools.</p>\n<h4>Get a YAML Value</h4>\n<p>At its simplest:</p>\n<pre>yaml-get <span class=\"se\">\\</span>\n  --query<span class=\"o\">=</span>see.documentation.above.for.many.samples <span class=\"se\">\\</span>\n  my_yaml_file.yaml\n</pre>\n<h4>Search For YAML Paths</h4>\n<p>Simplest use:</p>\n<pre>yaml-paths <span class=\"se\">\\</span>\n  --search<span class=\"o\">=</span>%word <span class=\"se\">\\</span>\n  /some/directory/*.yaml\n</pre>\n<p>Search for multiple expressions and exclude unwanted results:</p>\n<pre>yaml-paths <span class=\"se\">\\</span>\n  --search<span class=\"o\">=</span>^another <span class=\"se\">\\</span>\n  --search<span class=\"o\">=</span><span class=\"nv\">$word</span> <span class=\"se\">\\</span>\n  --except<span class=\"o\">=</span>%bad <span class=\"se\">\\</span>\n  /some/directory/*.yaml\n</pre>\n<p>Return all leaf nodes under matching parents (most useful when matching against Hash keys and you only want the original leaf nodes beneath them):</p>\n<pre>yaml-paths <span class=\"se\">\\</span>\n  --expand <span class=\"se\">\\</span>\n  --keynames <span class=\"se\">\\</span>\n  --search<span class=\"o\">==</span>parent_node <span class=\"se\">\\</span>\n  /some/directory/*.yaml\n</pre>\n<h4>Change a YAML Value</h4>\n<p>For a no-frills change to a YAML file with deeply nested Hash structures:</p>\n<pre>yaml-set <span class=\"se\">\\</span>\n  --change<span class=\"o\">=</span>see.documentation.above.for.many.samples <span class=\"se\">\\</span>\n  --value<span class=\"o\">=</span><span class=\"s2\">\"New Value\"</span> <span class=\"se\">\\</span>\n  my_yaml_file.yaml\n</pre>\n<p>To rotate a password, preserving the old password perhaps so your automation can\napply the new password to your application(s):</p>\n<pre>yaml-set <span class=\"se\">\\</span>\n  --mustexist <span class=\"se\">\\</span>\n  --change<span class=\"o\">=</span>the.new.password <span class=\"se\">\\</span>\n  --saveto<span class=\"o\">=</span>the.old.password <span class=\"se\">\\</span>\n  --value<span class=\"o\">=</span><span class=\"s2\">\"New Password\"</span> <span class=\"se\">\\</span>\n  my_yaml_file.yaml\n</pre>\n<p>For the extremely cautious, you could check the old password before rotating\nit and save a backup of the original file:</p>\n<pre>yaml-set <span class=\"se\">\\</span>\n  --mustexist <span class=\"se\">\\</span>\n  --change<span class=\"o\">=</span>the.new.password <span class=\"se\">\\</span>\n  --saveto<span class=\"o\">=</span>the.old.password <span class=\"se\">\\</span>\n  --check<span class=\"o\">=</span><span class=\"s2\">\"Old Password\"</span> <span class=\"se\">\\</span>\n  --value<span class=\"o\">=</span><span class=\"s2\">\"New Password\"</span> <span class=\"se\">\\</span>\n  --backup <span class=\"se\">\\</span>\n  my_yaml_file.yaml\n</pre>\n<p>You can also add EYAML encryption (assuming the <code>eyaml</code> command is on your\nPATH; if not, you can pass <code>--eyaml</code> to specify its location).  In this example,\nI add the optional <code>--format=folded</code> so that the long EYAML value is broken up\ninto a multi-line value rather than one very long string.  This is the preferred\nformat for human legibility as well as EYAML consumers like\n<a href=\"http://puppet.com\" rel=\"nofollow\">Puppet</a>.  Note that <code>--format</code> has several other settings\nand applies only to new values.</p>\n<pre>yaml-set <span class=\"se\">\\</span>\n  --change<span class=\"o\">=</span>the.new.password <span class=\"se\">\\</span>\n  --mustexist <span class=\"se\">\\</span>\n  --saveto<span class=\"o\">=</span>the.old.password <span class=\"se\">\\</span>\n  --check<span class=\"o\">=</span><span class=\"s2\">\"Old Password\"</span> <span class=\"se\">\\</span>\n  --value<span class=\"o\">=</span><span class=\"s2\">\"New Password\"</span> <span class=\"se\">\\</span>\n  --eyamlcrypt <span class=\"se\">\\</span>\n  --format<span class=\"o\">=</span>folded <span class=\"se\">\\</span>\n  --backup <span class=\"se\">\\</span>\n  my_yaml_file.yaml\n</pre>\n<p>You can even tell EYAML which keys to use, if not your default system or user\nkeys:</p>\n<pre>yaml-set <span class=\"se\">\\</span>\n  --change<span class=\"o\">=</span>the.new.password <span class=\"se\">\\</span>\n  --mustexist <span class=\"se\">\\</span>\n  --saveto<span class=\"o\">=</span>the.old.password <span class=\"se\">\\</span>\n  --check<span class=\"o\">=</span><span class=\"s2\">\"Old Password\"</span> <span class=\"se\">\\</span>\n  --value<span class=\"o\">=</span><span class=\"s2\">\"New Password\"</span> <span class=\"se\">\\</span>\n  --eyamlcrypt <span class=\"se\">\\</span>\n  --format<span class=\"o\">=</span>folded <span class=\"se\">\\</span>\n  --privatekey<span class=\"o\">=</span>/secret/keys/private_key.pkcs7.pem <span class=\"se\">\\</span>\n  --publickey<span class=\"o\">=</span>/secret/keys/public_key.pkcs7.pem <span class=\"se\">\\</span>\n  --backup <span class=\"se\">\\</span>\n  my_yaml_file.yaml\n</pre>\n<p>Note that for even greater security scenarios, you can keep the new value off of\nyour command-line, process list, and command history by swapping out <code>--value</code>\nfor one of <code>--stdin</code>, <code>--file</code>, or even <code>--random LENGTH</code> (use Python's\nstrongest random value generator if you don't need to specify the replacement\nvalue in advance).</p>\n<h3>Basic Usage:  Libraries</h3>\n<p>As for the libraries, they are also heavily documented and the example\nimplementations may perhaps serve as good copy-paste fodder (provided you give\ncredit to the source).  That said, here's a general flow/synopsis.</p>\n<h4>Initialize ruamel.yaml and These Helpers</h4>\n<p>Your preferences may differ, but I use this setup for round-trip YAML parsing\nand editing with ruamel.yaml.  When you need to process EYAML encrypted data,\nreplace <code>yamlpath.Processor</code> with <code>yamlpath.eyaml.EYAMLProcessor</code> and add error\nhandling for <code>yamlpath.eyaml.EYAMLCommandException</code>.</p>\n<p>Note that <code>import yamlpath.patches</code> is entirely optional.  I wrote and use it to\nblock ruamel.yaml's Emitter from injecting unnecessary newlines into folded\nvalues (it improperly converts every single new-line into two for left-flushed\nmulti-line values, at the time of this writing).  Since \"block\" output EYAML\nvalues are left-flushed multi-line folded strings, this fix is necessary when\nusing EYAML features.  At least, until ruamel.yaml has its own fix for this\nissue.</p>\n<p>Note also that these examples use <code>ConsolePrinter</code> to handle STDOUT and STDERR\nmessaging.  You don't have to.  However, some kind of logger must be passed to\nthese libraries so they can write messages <em>somewhere</em>.  Your custom message\nhandler or logger must provide the same API as <code>ConsolePrinter</code>; review the\nheader documentation in <a href=\"yamlpath/wrappers/consoleprinter.py\" rel=\"nofollow\">consoleprinter.py</a>\nfor details.  Generally speaking, it would be trivial to write your own custom\nwrapper for Python's standard logging facilities if you require targets other\nthan STDOUT and STDERR.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">ruamel.yaml</span> <span class=\"kn\">import</span> <span class=\"n\">YAML</span>\n<span class=\"kn\">from</span> <span class=\"nn\">ruamel.yaml.parser</span> <span class=\"kn\">import</span> <span class=\"n\">ParserError</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">yamlpath.patches</span>\n<span class=\"kn\">from</span> <span class=\"nn\">yamlpath.func</span> <span class=\"kn\">import</span> <span class=\"n\">get_yaml_data</span><span class=\"p\">,</span> <span class=\"n\">get_yaml_editor</span>\n<span class=\"kn\">from</span> <span class=\"nn\">yamlpath.wrappers</span> <span class=\"kn\">import</span> <span class=\"n\">ConsolePrinter</span>\n<span class=\"kn\">from</span> <span class=\"nn\">yamlpath</span> <span class=\"kn\">import</span> <span class=\"n\">Processor</span>\n\n<span class=\"c1\"># Process command-line arguments and initialize the output writer</span>\n<span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"n\">processcli</span><span class=\"p\">()</span>\n<span class=\"n\">log</span> <span class=\"o\">=</span> <span class=\"n\">ConsolePrinter</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Prep the YAML parser and round-trip editor (tweak to your needs)</span>\n<span class=\"n\">yaml</span> <span class=\"o\">=</span> <span class=\"n\">get_yaml_editor</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># At this point, you'd load or parse your YAML file, stream, or string.  When</span>\n<span class=\"c1\"># loading from file, I typically follow this pattern:</span>\n<span class=\"n\">yaml_data</span> <span class=\"o\">=</span> <span class=\"n\">get_yaml_data</span><span class=\"p\">(</span><span class=\"n\">yaml</span><span class=\"p\">,</span> <span class=\"n\">log</span><span class=\"p\">,</span> <span class=\"n\">yaml_file</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">yaml_data</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"c1\"># There was an issue loading the file; an error message has already been</span>\n    <span class=\"c1\"># printed.</span>\n    <span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Pass the log writer and parsed YAML data to the YAMLPath processor</span>\n<span class=\"n\">processor</span> <span class=\"o\">=</span> <span class=\"n\">Processor</span><span class=\"p\">(</span><span class=\"n\">log</span><span class=\"p\">,</span> <span class=\"n\">yaml_data</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># At this point, the processor is ready to handle YAMLPaths</span>\n</pre>\n<h4>Searching for YAML Nodes</h4>\n<p>These libraries use <a href=\"https://wiki.python.org/moin/Generators\" rel=\"nofollow\">Generators</a> to get\nnodes from parsed YAML data.  Identify which node(s) to get via YAML Path\nstrings.  You should also catch <code>yamlpath.exceptions.YAMLPathException</code>s\nunless you prefer Python's native stack traces.  When using EYAML, you should\nalso catch <code>yamlpath.eyaml.exceptions.EYAMLCommandException</code>s for the same\nreason.  Whether you are working with a single result or many, you should\nconsume the Generator output with a pattern similar to:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">yamlpath</span> <span class=\"kn\">import</span> <span class=\"n\">YAMLPath</span>\n<span class=\"kn\">from</span> <span class=\"nn\">yamlpath.exceptions</span> <span class=\"kn\">import</span> <span class=\"n\">YAMLPathException</span>\n\n<span class=\"n\">yaml_path</span> <span class=\"o\">=</span> <span class=\"n\">YAMLPath</span><span class=\"p\">(</span><span class=\"s2\">\"see.documentation.above.for.many.samples\"</span><span class=\"p\">)</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">node_coordinate</span> <span class=\"ow\">in</span> <span class=\"n\">processor</span><span class=\"o\">.</span><span class=\"n\">get_nodes</span><span class=\"p\">(</span><span class=\"n\">yaml_path</span><span class=\"p\">):</span>\n        <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">debug</span><span class=\"p\">(</span><span class=\"s2\">\"Got </span><span class=\"si\">{}</span><span class=\"s2\"> from '</span><span class=\"si\">{}</span><span class=\"s2\">'.\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">node_coordinate</span><span class=\"p\">,</span> <span class=\"n\">yaml_path</span><span class=\"p\">))</span>\n        <span class=\"c1\"># Do something with each node_coordinate.node (the actual data)</span>\n<span class=\"k\">except</span> <span class=\"n\">YAMLPathException</span> <span class=\"k\">as</span> <span class=\"n\">ex</span><span class=\"p\">:</span>\n    <span class=\"c1\"># If merely retrieving data, this exception may be deemed non-critical</span>\n    <span class=\"c1\"># unless your later code absolutely depends upon a result.</span>\n    <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">error</span><span class=\"p\">(</span><span class=\"n\">ex</span><span class=\"p\">)</span>\n</pre>\n<h4>Changing Values</h4>\n<p>At its simplest, you only need to supply the the YAML Path to one or more nodes\nto update, and the value to apply to them.  Catching\n<code>yamlpath.exceptions.YAMLPathException</code> is optional but usually preferred over\nallowing Python to dump the call stack in front of your users.  When using\nEYAML, the same applies to <code>yamlpath.eyaml.exceptions.EYAMLCommandException</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">yamlpath.exceptions</span> <span class=\"kn\">import</span> <span class=\"n\">YAMLPathException</span>\n\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">processor</span><span class=\"o\">.</span><span class=\"n\">set_value</span><span class=\"p\">(</span><span class=\"n\">yaml_path</span><span class=\"p\">,</span> <span class=\"n\">new_value</span><span class=\"p\">)</span>\n<span class=\"k\">except</span> <span class=\"n\">YAMLPathException</span> <span class=\"k\">as</span> <span class=\"n\">ex</span><span class=\"p\">:</span>\n    <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">critical</span><span class=\"p\">(</span><span class=\"n\">ex</span><span class=\"p\">,</span> <span class=\"mi\">119</span><span class=\"p\">)</span>\n<span class=\"k\">except</span> <span class=\"n\">EYAMLCommandException</span> <span class=\"k\">as</span> <span class=\"n\">ex</span><span class=\"p\">:</span>\n    <span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">critical</span><span class=\"p\">(</span><span class=\"n\">ex</span><span class=\"p\">,</span> <span class=\"mi\">120</span><span class=\"p\">)</span>\n</pre>\n\n          </div>"}, "last_serial": 6770355, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "957c61b7fe468b446a828e2b68145e70", "sha256": "2abd622f403eb27d6780109857e6b2427025227217afffd1c9463435abd53a3e"}, "downloads": -1, "filename": "yamlpath-1.0.0.tar.gz", "has_sig": false, "md5_digest": "957c61b7fe468b446a828e2b68145e70", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33823, "upload_time": "2019-05-08T03:38:09", "upload_time_iso_8601": "2019-05-08T03:38:09.467457Z", "url": "https://files.pythonhosted.org/packages/c6/11/c91e5514c8530cc307b4d381c92c7b0b89f70aa2285beec4a940bb17347a/yamlpath-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "d81b290f14e302732ec85683c741df33", "sha256": "f5d9370da28ba7f562a191b6b7dbfe86ba1aa4720e74392ed2f168d14d398c73"}, "downloads": -1, "filename": "yamlpath-1.1.0.tar.gz", "has_sig": false, "md5_digest": "d81b290f14e302732ec85683c741df33", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34748, "upload_time": "2019-05-09T22:35:11", "upload_time_iso_8601": "2019-05-09T22:35:11.864714Z", "url": "https://files.pythonhosted.org/packages/e0/6b/7d56e78ec0fd12f957f0789f93d1c6df1afdaaface8d29cac4757291a728/yamlpath-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "f43a268434bb970c9377dd03b1192107", "sha256": "c9ebb31a717c9ae67d825338f76356a1bde3e8484af208a205e751e40f3d6df7"}, "downloads": -1, "filename": "yamlpath-1.1.1.tar.gz", "has_sig": false, "md5_digest": "f43a268434bb970c9377dd03b1192107", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42219, "upload_time": "2019-05-10T06:29:08", "upload_time_iso_8601": "2019-05-10T06:29:08.025569Z", "url": "https://files.pythonhosted.org/packages/75/f5/281ab60c1dd7a183bd10c5b45306894919042afdb5d8ee054a23f2bf19d2/yamlpath-1.1.1.tar.gz", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "a4fc1c7162f318d2818521e6c3fa38dd", "sha256": "b6bc27ff17905c8f3cb3d7819eeead63537d4a052b133e43c3cd05ef4bfa9400"}, "downloads": -1, "filename": "yamlpath-1.1.2.tar.gz", "has_sig": false, "md5_digest": "a4fc1c7162f318d2818521e6c3fa38dd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42530, "upload_time": "2019-05-10T23:53:31", "upload_time_iso_8601": "2019-05-10T23:53:31.403258Z", "url": "https://files.pythonhosted.org/packages/8e/5e/71cb98565ba564a908ced722232e6f5efde89fa65a178c68000864f466b6/yamlpath-1.1.2.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "c35b5f38d69901df874e9f2a2121f42f", "sha256": "1e0d44f803fb190f897370e7889003268159fa3ff8db07fb1c2e9b7554c0c30b"}, "downloads": -1, "filename": "yamlpath-1.2.0.tar.gz", "has_sig": false, "md5_digest": "c35b5f38d69901df874e9f2a2121f42f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 46429, "upload_time": "2019-05-13T05:51:11", "upload_time_iso_8601": "2019-05-13T05:51:11.861787Z", "url": "https://files.pythonhosted.org/packages/71/c0/e7831c500c4577d58e31723087d64ecc0cacd811bc2224344bc273ede2b3/yamlpath-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "de69356ecd3ca67457383b58f67de568", "sha256": "f7d5461968058aa7c8ab6898b2fd6f8129dcd02a09af1d77d730a9e711ad0242"}, "downloads": -1, "filename": "yamlpath-1.2.1.tar.gz", "has_sig": false, "md5_digest": "de69356ecd3ca67457383b58f67de568", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47009, "upload_time": "2019-05-13T20:57:30", "upload_time_iso_8601": "2019-05-13T20:57:30.761212Z", "url": "https://files.pythonhosted.org/packages/eb/af/6bcc31135726d6d4a39ee7210d5b25589e79708705c3db59ed49f69231ed/yamlpath-1.2.1.tar.gz", "yanked": false}], "1.2.2": [{"comment_text": "", "digests": {"md5": "9bc9b54c491189a6e050d572d5c9b23c", "sha256": "1419b08e4280740625b8ca3dc5fecd870f3ea9322a95e263c6547707e37e23f0"}, "downloads": -1, "filename": "yamlpath-1.2.2.tar.gz", "has_sig": false, "md5_digest": "9bc9b54c491189a6e050d572d5c9b23c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49721, "upload_time": "2019-05-14T20:17:33", "upload_time_iso_8601": "2019-05-14T20:17:33.813387Z", "url": "https://files.pythonhosted.org/packages/5a/c6/a68296d7c1253958db892035a0c1817d407ec64130e9e5deaadeb5bf378f/yamlpath-1.2.2.tar.gz", "yanked": false}], "1.2.3": [{"comment_text": "", "digests": {"md5": "85a257eaf4836e334b50e4b9e6db6878", "sha256": "ddf009f55c565c40b15a6c60fab6a38491a47a434fb92afe705edf260577db6d"}, "downloads": -1, "filename": "yamlpath-1.2.3.tar.gz", "has_sig": false, "md5_digest": "85a257eaf4836e334b50e4b9e6db6878", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 49744, "upload_time": "2019-05-16T04:17:13", "upload_time_iso_8601": "2019-05-16T04:17:13.889232Z", "url": "https://files.pythonhosted.org/packages/e5/ed/1255e8ac378f007bd9a1e51fe0cff3aa9df5f758850756b83fba9f2e3878/yamlpath-1.2.3.tar.gz", "yanked": false}], "1.2.4": [{"comment_text": "", "digests": {"md5": "872b4d46bf321aed8de3934ec6356931", "sha256": "847818273945be81ab17222beb4826709c8c13f5b95c5424dfc4f293702b21ea"}, "downloads": -1, "filename": "yamlpath-1.2.4.tar.gz", "has_sig": false, "md5_digest": "872b4d46bf321aed8de3934ec6356931", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 50429, "upload_time": "2019-05-17T23:06:01", "upload_time_iso_8601": "2019-05-17T23:06:01.272737Z", "url": "https://files.pythonhosted.org/packages/d1/f3/249efd648a08ad286575893fd3aadf4027cd16dafe49c6be90d6467fa795/yamlpath-1.2.4.tar.gz", "yanked": false}], "1.2.5": [{"comment_text": "", "digests": {"md5": "74f81572216afa21381ad83d772f0738", "sha256": "1b82a0efd6fc3ea634a7179fedeb2490ad2a3b22122e5760f95b1f1f27b39746"}, "downloads": -1, "filename": "yamlpath-1.2.5.tar.gz", "has_sig": false, "md5_digest": "74f81572216afa21381ad83d772f0738", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 50548, "upload_time": "2019-05-23T19:04:58", "upload_time_iso_8601": "2019-05-23T19:04:58.269671Z", "url": "https://files.pythonhosted.org/packages/0a/61/05ca33b6f29a3e878e7a4c366f7aee51e4df842278946519df2e5bd7d36f/yamlpath-1.2.5.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "0df0a7b2bf131b0e10cf6e5506f5c0bf", "sha256": "7bf0effc671ce9490ef66c79585a0c93c737599022315855a4e79490be06aaf9"}, "downloads": -1, "filename": "yamlpath-2.0.0.tar.gz", "has_sig": false, "md5_digest": "0df0a7b2bf131b0e10cf6e5506f5c0bf", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 56545, "upload_time": "2019-05-27T19:31:10", "upload_time_iso_8601": "2019-05-27T19:31:10.976170Z", "url": "https://files.pythonhosted.org/packages/4f/44/61842c8f788c12c416906141fc6e8c57e87b13f284c4559b5f767604730f/yamlpath-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "c9a387ac0bfdb5d5de08bbbf30c01a72", "sha256": "dd46fb3f330d62e70b7d6e4750bd7b9db5920601c2949fbed0727c9177330380"}, "downloads": -1, "filename": "yamlpath-2.0.1.tar.gz", "has_sig": false, "md5_digest": "c9a387ac0bfdb5d5de08bbbf30c01a72", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 56662, "upload_time": "2019-05-29T15:42:48", "upload_time_iso_8601": "2019-05-29T15:42:48.040596Z", "url": "https://files.pythonhosted.org/packages/d5/93/88baebde6b36d002f039f757ead59668d75c5258ef5f2a1568c312371eea/yamlpath-2.0.1.tar.gz", "yanked": false}], "2.0.2": [{"comment_text": "", "digests": {"md5": "2ed2957ac17885f243ceb19f508fe605", "sha256": "8088d58995574a83844a1787cb83f11d4472a6ab5f7e3b1032bc30303e72c3a3"}, "downloads": -1, "filename": "yamlpath-2.0.2.tar.gz", "has_sig": false, "md5_digest": "2ed2957ac17885f243ceb19f508fe605", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 57368, "upload_time": "2019-05-30T21:13:17", "upload_time_iso_8601": "2019-05-30T21:13:17.218291Z", "url": "https://files.pythonhosted.org/packages/a8/b5/e9bef7eb3b37d541d24853dd8b163e7bf5c556242e2e4dccb09894c65419/yamlpath-2.0.2.tar.gz", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "1714f52c8c59b0fe1961408fc5fc4266", "sha256": "b3a323dd11ff208c31fd2872ef070caa8c4b332a1512ed40c614598f46acd237"}, "downloads": -1, "filename": "yamlpath-2.1.0.tar.gz", "has_sig": false, "md5_digest": "1714f52c8c59b0fe1961408fc5fc4266", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 63281, "upload_time": "2019-06-06T04:16:34", "upload_time_iso_8601": "2019-06-06T04:16:34.567444Z", "url": "https://files.pythonhosted.org/packages/dd/77/b6764edc579117c9a6f82490882ce7db0009767745500469d69ef40abe06/yamlpath-2.1.0.tar.gz", "yanked": false}], "2.1.1": [{"comment_text": "", "digests": {"md5": "ba9b9a1877235492132de3e57b888e1f", "sha256": "5766ce79aa34193c1ba825f05d4153b1aac738f98d4863560f542737e109fb77"}, "downloads": -1, "filename": "yamlpath-2.1.1.tar.gz", "has_sig": false, "md5_digest": "ba9b9a1877235492132de3e57b888e1f", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 65429, "upload_time": "2019-06-07T02:19:12", "upload_time_iso_8601": "2019-06-07T02:19:12.585124Z", "url": "https://files.pythonhosted.org/packages/ee/59/3c72da21685a3d4850c9a48b2d2736e7b23d5ce198be2206f742ac098b0d/yamlpath-2.1.1.tar.gz", "yanked": false}], "2.2.0": [{"comment_text": "", "digests": {"md5": "ed2142d6293feb1fa0da19aaa4146c96", "sha256": "d95d1d1c33f8c3f69932bc8b604c50dd61fde21cc14e58a00cb31b30a1fbb031"}, "downloads": -1, "filename": "yamlpath-2.2.0.tar.gz", "has_sig": false, "md5_digest": "ed2142d6293feb1fa0da19aaa4146c96", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 68182, "upload_time": "2019-06-09T23:32:46", "upload_time_iso_8601": "2019-06-09T23:32:46.028216Z", "url": "https://files.pythonhosted.org/packages/be/39/9886ae1accfb506f5bde4e5e6bbd1d41678e446b7c2e006531d9cf7e14ec/yamlpath-2.2.0.tar.gz", "yanked": false}], "2.3.0": [{"comment_text": "", "digests": {"md5": "7b1ee77a37e21096a039258a783c8bfa", "sha256": "2348975655dcd0fca1c52857ef0c76da00724db92d43505893d5c0e02c82c868"}, "downloads": -1, "filename": "yamlpath-2.3.0.tar.gz", "has_sig": false, "md5_digest": "7b1ee77a37e21096a039258a783c8bfa", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 69629, "upload_time": "2019-09-22T01:54:57", "upload_time_iso_8601": "2019-09-22T01:54:57.458558Z", "url": "https://files.pythonhosted.org/packages/8a/83/9b423563de491ba2eaa29edbc5643a2ebf328350d0f76928d2fa19492d6b/yamlpath-2.3.0.tar.gz", "yanked": false}], "2.3.1": [{"comment_text": "", "digests": {"md5": "f67a6c39c31fcc1813793e48d2716eec", "sha256": "e7e7698df414d90a31928c06dbcadfab97d09edc1c05ff0447651ad4b1cf7474"}, "downloads": -1, "filename": "yamlpath-2.3.1.tar.gz", "has_sig": false, "md5_digest": "f67a6c39c31fcc1813793e48d2716eec", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 72696, "upload_time": "2020-02-05T02:46:52", "upload_time_iso_8601": "2020-02-05T02:46:52.321487Z", "url": "https://files.pythonhosted.org/packages/8f/81/290c7e7fcbc5c15b8fb67296a6f7af343e0b24605746cd5d12fc5c928496/yamlpath-2.3.1.tar.gz", "yanked": false}], "2.3.2": [{"comment_text": "", "digests": {"md5": "7757350dd2afb2e4965ad4287d949cb0", "sha256": "540d0ecd0dcce57df280269a8dec5bafd057e5b8668992b9ade86b36976e1111"}, "downloads": -1, "filename": "yamlpath-2.3.2.tar.gz", "has_sig": false, "md5_digest": "7757350dd2afb2e4965ad4287d949cb0", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 72060, "upload_time": "2020-03-03T20:07:18", "upload_time_iso_8601": "2020-03-03T20:07:18.584427Z", "url": "https://files.pythonhosted.org/packages/5f/3d/9602aa0910301254cd47ba2d829c51024119fda13b2ce8cbb56efa845b16/yamlpath-2.3.2.tar.gz", "yanked": false}], "2.3.3": [{"comment_text": "", "digests": {"md5": "410db51196e7538a0df527d9938eb9e8", "sha256": "f0127b4bff7801595f6b6f35f5c06558bace1f53547c9146b517b932dd45b4b3"}, "downloads": -1, "filename": "yamlpath-2.3.3.tar.gz", "has_sig": false, "md5_digest": "410db51196e7538a0df527d9938eb9e8", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 72064, "upload_time": "2020-03-04T04:47:55", "upload_time_iso_8601": "2020-03-04T04:47:55.263525Z", "url": "https://files.pythonhosted.org/packages/7f/39/464b0aa9fee1972c4867838a00cf82b1041e55d44d53b19463134a56169d/yamlpath-2.3.3.tar.gz", "yanked": false}], "2.3.4": [{"comment_text": "", "digests": {"md5": "a7fdf49f1d051a44efcafce23f8afd4c", "sha256": "d760b734d97fc79231e7a32d59027b5dc0a777e2e4d666d3de56b7dcaddc6136"}, "downloads": -1, "filename": "yamlpath-2.3.4.tar.gz", "has_sig": false, "md5_digest": "a7fdf49f1d051a44efcafce23f8afd4c", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 73689, "upload_time": "2020-03-08T04:10:38", "upload_time_iso_8601": "2020-03-08T04:10:38.474984Z", "url": "https://files.pythonhosted.org/packages/ce/ec/fde803cb01781ce32be21f5fd384383a1a96f10f02f05c1061d17385d931/yamlpath-2.3.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a7fdf49f1d051a44efcafce23f8afd4c", "sha256": "d760b734d97fc79231e7a32d59027b5dc0a777e2e4d666d3de56b7dcaddc6136"}, "downloads": -1, "filename": "yamlpath-2.3.4.tar.gz", "has_sig": false, "md5_digest": "a7fdf49f1d051a44efcafce23f8afd4c", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.6.0", "size": 73689, "upload_time": "2020-03-08T04:10:38", "upload_time_iso_8601": "2020-03-08T04:10:38.474984Z", "url": "https://files.pythonhosted.org/packages/ce/ec/fde803cb01781ce32be21f5fd384383a1a96f10f02f05c1061d17385d931/yamlpath-2.3.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:23:16 2020"}