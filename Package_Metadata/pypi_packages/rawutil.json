{"info": {"author": "Tyulis", "author_email": "tyulis@laposte.net", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3 :: Only", "Topic :: Utilities"], "description": "rawutil\n=======\nA single-file pure-python module to deal with binary packed data\n\nRawutil documentation\n=====================\n\n**rawutil** is a python3 module to read and write binary packed data\n\nThere is two ways to use it:\n\n-\tLike *struct*, with string structures\n-\tWith the TypeReader and TypeWriter objects\n\n1-String structures\n-------------------\nrawutil can be used like struct, with structures stored as strings. rawutil is almost fully compatible with struct. If in a program, you can replace all instances of \"struct\" by \"rawutil\", it should work exactly same (see below for differences).\n\nrawutil has the same 3 main functions as struct::\n\n\tpack(stct, *data) -> bytes\n\t\tPacks the elements in a bytes object as described by the stucture specified by the stct argument\n\n\tpack(stct, *data, file) -> None\n\t\tPacks the elements in the given file-like object as described by the stucture specified by the stct argument\n\n\tunpack(stct, data, refdata=())\n\t\tUnpacks the binary data given as a bytes object as described by the structure in the stct argument, and returns elements as a list\n\t\tdata can also be a file-like object. In this case, unpacking will start at the beginning of the file (it performs a file.seek(0))\n\t\tThe refdata option is a tuple which contains the data used by the external references, see below.\n\t\tNote that unlike its struct equivalent, it won't raise an exception if the data length doesn't match the structure length.\n\n\tunpack_from(stct, data, offset=0, refdata=(), getptr=False)\n\t\tUnpacks the data as described by the stct argument from the specified offset, and returns elements as a list\n\t\tdata can also be a file-like object. In this case, unpacking will start at the specified location (performs file.seek(offset))\n\t\tThe refdata argument is used for external references, see below\n\t\tIf getptr is True, this function returns *unpacked, ptr* instead of only *unpacked*. The pointer is the offset where the unpacking has ended\n\n\nrawutil structures can match variable lengths, so there is not any *calcsize* function.\n\nString structures reference\n----------------------------\nThe structure is a str object.\n\nIt can begin by a character to specify the byte order, exactly like *struct*:\n\n+----+----------------------------------------------+\n|Chr.| Effect                                       |\n+====+==============================================+\n| =  |  Uses the system byte order and alignment    |\n+----+----------------------------------------------+\n| @  |  Uses the system byte order without alignment|\n+----+----------------------------------------------+\n| !  |  Network byte order (same as >)              |\n+----+----------------------------------------------+\n| >  |  Big endian                                  |\n+----+----------------------------------------------+\n| <  |  Little endian                               |\n+----+----------------------------------------------+\n\nWhen there is no byte order mark, the byte order defaults to @\n\nThen, the format string really begins. Note that, unlike *struct*'s ones, rawutil stuctures can contain as many spaces as you want.\n\nElements\n--------\nFirst, all elements usable in *struct* can be used with rawutil:\n\n+-----+--------+--------------------------------------------------------+\n|Chr. | Type   | Description                                            |\n+=====+========+========================================================+\n|  c  | char   | Returns a 1-byte bytes object                          |\n+-----+--------+--------------------------------------------------------+\n|  b  | int8   | Signed 8-bits (1 byte) integer                         |\n+-----+--------+--------------------------------------------------------+\n|  B  | uint8  | Unsigned 8-bits integer                                |\n+-----+--------+--------------------------------------------------------+\n|  ?  | bool   | Returns a boolean from a byte (False if 0, else True)  |\n+-----+--------+--------------------------------------------------------+\n|  h  | int16  | Signed 16-bits (2 bytes) integer                       |\n+-----+--------+--------------------------------------------------------+\n|  H  | uint16 | Unsigned 16-bits integer                               |\n+-----+--------+--------------------------------------------------------+\n|  i  | int32  | Signed 32-bits (4 bytes) integer                       |\n+-----+--------+--------------------------------------------------------+\n|  I  | uint32 | Unsigned 32-bits integer                               |\n+-----+--------+--------------------------------------------------------+\n|  l  | int32  | Signed 32-bits (4 bytes) integer                       |\n+-----+--------+--------------------------------------------------------+\n|  L  | uint32 | Unsigned 32-bits integer                               |\n+-----+--------+--------------------------------------------------------+\n|  q  | int64  | Signed 64-bits (8 bytes) integer                       |\n+-----+--------+--------------------------------------------------------+\n|  Q  | uint64 | Unsigned 64-bits integer                               |\n+-----+--------+--------------------------------------------------------+\n|  f  | float  | 32-bits float                                          |\n+-----+--------+--------------------------------------------------------+\n|  d  | double | 64-bits double                                         |\n+-----+--------+--------------------------------------------------------+\n|  s  | string | Returns a bytes object                                 |\n+-----+--------+--------------------------------------------------------+\n|  x  | void   | Padding byte: doesn't return anything                  |\n+-----+--------+--------------------------------------------------------+\n\nNote that s should be used with a length: \"12s\" will return a 12-bytes bytes object, unlike \"12c\" which returns 12 1-bytes bytes objects. Note also that the P and N are not available, and n is not used as an ssize_t like in *struct*\n\nThere is also new format characters introduced in rawutil:\n\n+-----+--------+-------------------------------------------------------------+\n|Chr. | Type   | Description                                                 |\n+=====+========+=============================================================+\n|  u  | int24  | Signed 24-bits (3 bytes) integer                            |\n+-----+--------+-------------------------------------------------------------+\n|  U  | uint24 | Unsigned 24-bits integer                                    |\n+-----+--------+-------------------------------------------------------------+\n|  n  | string | Null-terminated string                                      |\n+-----+--------+-------------------------------------------------------------+\n|  a  | pad    | Alignment: aligns to a multiple of the specified number     |\n+-----+--------+-------------------------------------------------------------+\n|  X  | hex    | Works like s but returns the bytes as an hexadecimal string |\n+-----+--------+-------------------------------------------------------------+\n|  $  | bytes  | Go to the end                                               |\n+-----+--------+-------------------------------------------------------------+\n\nThe \"n\" element returns a bytes object. The string is read from the current pointer position, until a null byte (0x00) is found. The null byte is not included in the returned string. At packing, it packs a bytes object, and adds a null byte at the end\n\nThe \"a\" element performs an alignment. It should be used like \"20a\": the number represents the alignment. When unpacking, it places the pointer at the next multiple of the alignment. It doesn't return anything. When packing, it will add null bytes until a multiple of the aligment length is reached (skip it in the data arguments)\n\nThe \"$\" element represents the end. At unpacking, it returns all the remaining unread data as a bytes object, and ends the reading (it places the pointer at the data's end). At packing, it appends the corresponding bytes object in the data arguments at the end of the packed bytes, and ends the packing.\n\nThen, rawutil adds groups and iterators.\n----------------------------------------\n\nThese elements can group other elements and unpack them several times\n\nThe () element represents a group. It should be used like that:\n\n\t\"4s I2H (2B 2H) 20a\"\n\nAll elements between the brackets will be unpacked as a substructure, in a list. Here, it can returns for example:\n\n\t[b'test', 10000, 326, 1919, [11, 19, 112, 1222] , b'\\x00\\x00']\n\nAt packing, all data packed in the group should be in a list, like this.\n\nThen, the [] element is an iterator. It should be used like that:\n\n\t\"h 4[2B]\"\n\nIt will read the substructure as many times as precised before the [. It will returns a list of lists, like this:\n\n\t[-1234, [[11, 12], [111, 112], [9, 99], [31, 112]]]\n\nFinally, the {} iterator will iterate until the end of data is reached (so don't precise the iterations count). Like [], it returns a list of lists. For examples, this structure:\n\n\t'4s {Bn}'\n\nWith this data:\n\n\tb'TEST\\x01Yes\\x00\\x02No\\x00'\n\nReturns:\n\n\t[b'TEST', [[1, b'Yes'], [2, b'No']]]\n\n\nFinally, rawutil includes references\n------------------------------------\n\nThere is two different types of references: external and internal references.\n\nThe external references are represented with '#'. They are replaced by the corresponding element in the refdata argument. For example, with this call::\n\n\tdata = b'<some bytes>!'\n\trawutil.unpack('#0c #1s #2c', data, refdata=(1, len(data) - 3, 2))\n\n\"#0\" is replaced by 1, \"#1\" by (len(data) - 3), here 10, and \"#2\" by 2: the final structure is '1c 10s 2c' so it will return:\n\n\t[b'<', b'some bytes', b'>', b'!']\n\nThen, the internal references. They are represented by a \"/\", and should be used like this:\n\n\t'4s 2B /2[2s]'\n\nThe number near the \"/\" is the index of the reference. The reference will be replaced by the unpacked element at the specified index, here the second \"B\", so with this data:\n\n\tb'TEST\\xff\\x06zyXWvuTSrqPO'\n\nIt will return:\n\n\t[b'TEST', 255, 6, [[b'zy'], [b'XW'], [b'vu'], [b'TS'], [b'rq'], [b'PO']]]\n\nHere, the element 2 of the unpacked elements contains 6, so the \"/2\" is replaced by \"6\", so it is interpreted as '4s 2B 6[2s]', so [2s] is unpacked as many times as specified by the element 2.\n\nInternal references can also be relative, with '/p'. You can use for example this structure:\n\n\t'2B /p2[2s]'\n\nWith this data:\n\n\tb'\\x04\\xffJJkkLLmm'\n\nIt will return:\n\n\t[4, 255, [[b'JJ', b'kk', b'LL', b'mm']]]\n\nSo the \"/p2\" will be replaced by the element situated 2 elements before, here, the first B, so here, 4\n\nObjects\n=======\n\nYou can also use rawutil with objects TypeReader and TypeWriter.\n\n\tTypeReader(byteorder='@')\n\tTypeWriter(byteorder='@')\n\nThe byteorder argument is the used byteorder mark, exactly like the format strings' one. You can also specify it using the byteorder attribute of these objects.\n\nYou can easily subclass it to create a reader or writer class for the format you want.\n\nThese two objects have the pack, unpack and unpack_from methods, which are exactly the sames as the module-level ones, but if the byte order is not precised in the structure, it defaults to the byteorder attribute instead of \"@\".\n\nFirst, the TypeReader object can read elements from a bytes-like or file-like object. It has the following methods:\n\n\tbit(n, bit, length=1)\n\t\tReturns the specified bits in the n integer. Returns (length) bits\n\tnibbles(n)\n\t\tReturns the high and low nibbles of a byte\n\tsigned_nibbles(n)\n\t\tReturns the high and low signed nibbles of a byte\n\nAll its other methods takes 2 arguments:\n\n\tTypeReader.uint8(data, ptr=0)\n\nptr is the offset to start reading. If None, reading starts at the current file position (given by file.tell()), or at 0 if data is a bytes-like object. All its other methods returns (unpacked, ptr), where unpacked is the unpacked elements, and ptr is the offset where the reading ended.\n\nThe TypeReader objects have the following methods::\n\n\tuint8(data, ptr=None)\n\tuint16(data, ptr=None)\n\tuint24(data, ptr=None)\n\tuint32(data, ptr=None)\n\tuint64(data, ptr=None)\n\tint8(data, ptr=None)\n\tint16(data, ptr=None)\n\tint24(data, ptr=None)\n\tint32(data, ptr=None)\n\tint64(data, ptr=None)\n\tfloat32(data, ptr=None) = float(...)\n\tdouble(data, ptr=None)  #64 bits double\n\tstring(data, ptr=None)  #null-terminated string, like the \"n\" format character\n\tutf16string(data, ptr=None)  #null-terminated UTF-16 string\n\nThen, the TypeWriter object can pack some elements. It has the following methods: (data argument is the element to pack, out can be the output file-like objects)::\n\n\tnibbles(high, low)  #returns the byte formed by the two nibbles\n\tsigned_nibbles(high, low)  #idem with signed nibbles\n\tint8(data, out=None)\n\tint16(data, out=None)\n\tint24(data, out=None)\n\tint32(data, out=None)\n\tint64(data, out=None)\n\tuint8(data, out=None)\n\tuint16(data, out=None)\n\tuint24(data, out=None)\n\tuint32(data, out=None)\n\tuint64(data, out=None)\n\tfloat32(data, out=None) = float(...)\n\tdouble(data, out=None)  #64 bits double\n\tstring(data, align=0, out=None)  #align is the minimal size to pack. Packs a bytes object as a null-terminated string\n\tutf16string(data, align=0, out=None)\n\tpad(num)  #Returns the given number of null bytes\n\talign(data, alignnment)  #Returns null bytes to fill to a multiple of the alignment\n\nThere are not any non-builtin dependencies.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Tyulis/rawutil", "keywords": "structures struct binary bytes formats", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "rawutil", "package_url": "https://pypi.org/project/rawutil/", "platform": "", "project_url": "https://pypi.org/project/rawutil/", "project_urls": {"Homepage": "https://github.com/Tyulis/rawutil"}, "release_url": "https://pypi.org/project/rawutil/2.4.11/", "requires_dist": null, "requires_python": ">=3.4", "summary": "A single-file, pure-python package to deal with binary packed data", "version": "2.4.11", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"rawutil\">\n<h2>rawutil</h2>\n<p>A single-file pure-python module to deal with binary packed data</p>\n</div>\n<div id=\"rawutil-documentation\">\n<h2>Rawutil documentation</h2>\n<p><strong>rawutil</strong> is a python3 module to read and write binary packed data</p>\n<p>There is two ways to use it:</p>\n<ul>\n<li>Like <em>struct</em>, with string structures</li>\n<li>With the TypeReader and TypeWriter objects</li>\n</ul>\n<div id=\"string-structures\">\n<h3>1-String structures</h3>\n<p>rawutil can be used like struct, with structures stored as strings. rawutil is almost fully compatible with struct. If in a program, you can replace all instances of \u201cstruct\u201d by \u201crawutil\u201d, it should work exactly same (see below for differences).</p>\n<p>rawutil has the same 3 main functions as struct:</p>\n<pre>pack(stct, *data) -&gt; bytes\n        Packs the elements in a bytes object as described by the stucture specified by the stct argument\n\npack(stct, *data, file) -&gt; None\n        Packs the elements in the given file-like object as described by the stucture specified by the stct argument\n\nunpack(stct, data, refdata=())\n        Unpacks the binary data given as a bytes object as described by the structure in the stct argument, and returns elements as a list\n        data can also be a file-like object. In this case, unpacking will start at the beginning of the file (it performs a file.seek(0))\n        The refdata option is a tuple which contains the data used by the external references, see below.\n        Note that unlike its struct equivalent, it won't raise an exception if the data length doesn't match the structure length.\n\nunpack_from(stct, data, offset=0, refdata=(), getptr=False)\n        Unpacks the data as described by the stct argument from the specified offset, and returns elements as a list\n        data can also be a file-like object. In this case, unpacking will start at the specified location (performs file.seek(offset))\n        The refdata argument is used for external references, see below\n        If getptr is True, this function returns *unpacked, ptr* instead of only *unpacked*. The pointer is the offset where the unpacking has ended\n</pre>\n<p>rawutil structures can match variable lengths, so there is not any <em>calcsize</em> function.</p>\n</div>\n<div id=\"string-structures-reference\">\n<h3>String structures reference</h3>\n<p>The structure is a str object.</p>\n<p>It can begin by a character to specify the byte order, exactly like <em>struct</em>:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Chr.</th>\n<th>Effect</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>=</td>\n<td>Uses the system byte order and alignment</td>\n</tr>\n<tr><td>@</td>\n<td>Uses the system byte order without alignment</td>\n</tr>\n<tr><td>!</td>\n<td>Network byte order (same as &gt;)</td>\n</tr>\n<tr><td>&gt;</td>\n<td>Big endian</td>\n</tr>\n<tr><td>&lt;</td>\n<td>Little endian</td>\n</tr>\n</tbody>\n</table>\n<p>When there is no byte order mark, the byte order defaults to @</p>\n<p>Then, the format string really begins. Note that, unlike <em>struct</em>\u2019s ones, rawutil stuctures can contain as many spaces as you want.</p>\n</div>\n<div id=\"elements\">\n<h3>Elements</h3>\n<p>First, all elements usable in <em>struct</em> can be used with rawutil:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Chr.</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>c</td>\n<td>char</td>\n<td>Returns a 1-byte bytes object</td>\n</tr>\n<tr><td>b</td>\n<td>int8</td>\n<td>Signed 8-bits (1 byte) integer</td>\n</tr>\n<tr><td>B</td>\n<td>uint8</td>\n<td>Unsigned 8-bits integer</td>\n</tr>\n<tr><td>?</td>\n<td>bool</td>\n<td>Returns a boolean from a byte (False if 0, else True)</td>\n</tr>\n<tr><td>h</td>\n<td>int16</td>\n<td>Signed 16-bits (2 bytes) integer</td>\n</tr>\n<tr><td>H</td>\n<td>uint16</td>\n<td>Unsigned 16-bits integer</td>\n</tr>\n<tr><td>i</td>\n<td>int32</td>\n<td>Signed 32-bits (4 bytes) integer</td>\n</tr>\n<tr><td>I</td>\n<td>uint32</td>\n<td>Unsigned 32-bits integer</td>\n</tr>\n<tr><td>l</td>\n<td>int32</td>\n<td>Signed 32-bits (4 bytes) integer</td>\n</tr>\n<tr><td>L</td>\n<td>uint32</td>\n<td>Unsigned 32-bits integer</td>\n</tr>\n<tr><td>q</td>\n<td>int64</td>\n<td>Signed 64-bits (8 bytes) integer</td>\n</tr>\n<tr><td>Q</td>\n<td>uint64</td>\n<td>Unsigned 64-bits integer</td>\n</tr>\n<tr><td>f</td>\n<td>float</td>\n<td>32-bits float</td>\n</tr>\n<tr><td>d</td>\n<td>double</td>\n<td>64-bits double</td>\n</tr>\n<tr><td>s</td>\n<td>string</td>\n<td>Returns a bytes object</td>\n</tr>\n<tr><td>x</td>\n<td>void</td>\n<td>Padding byte: doesn\u2019t return anything</td>\n</tr>\n</tbody>\n</table>\n<p>Note that s should be used with a length: \u201c12s\u201d will return a 12-bytes bytes object, unlike \u201c12c\u201d which returns 12 1-bytes bytes objects. Note also that the P and N are not available, and n is not used as an ssize_t like in <em>struct</em></p>\n<p>There is also new format characters introduced in rawutil:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Chr.</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>u</td>\n<td>int24</td>\n<td>Signed 24-bits (3 bytes) integer</td>\n</tr>\n<tr><td>U</td>\n<td>uint24</td>\n<td>Unsigned 24-bits integer</td>\n</tr>\n<tr><td>n</td>\n<td>string</td>\n<td>Null-terminated string</td>\n</tr>\n<tr><td>a</td>\n<td>pad</td>\n<td>Alignment: aligns to a multiple of the specified number</td>\n</tr>\n<tr><td>X</td>\n<td>hex</td>\n<td>Works like s but returns the bytes as an hexadecimal string</td>\n</tr>\n<tr><td>$</td>\n<td>bytes</td>\n<td>Go to the end</td>\n</tr>\n</tbody>\n</table>\n<p>The \u201cn\u201d element returns a bytes object. The string is read from the current pointer position, until a null byte (0x00) is found. The null byte is not included in the returned string. At packing, it packs a bytes object, and adds a null byte at the end</p>\n<p>The \u201ca\u201d element performs an alignment. It should be used like \u201c20a\u201d: the number represents the alignment. When unpacking, it places the pointer at the next multiple of the alignment. It doesn\u2019t return anything. When packing, it will add null bytes until a multiple of the aligment length is reached (skip it in the data arguments)</p>\n<p>The \u201c$\u201d element represents the end. At unpacking, it returns all the remaining unread data as a bytes object, and ends the reading (it places the pointer at the data\u2019s end). At packing, it appends the corresponding bytes object in the data arguments at the end of the packed bytes, and ends the packing.</p>\n</div>\n<div id=\"then-rawutil-adds-groups-and-iterators\">\n<h3>Then, rawutil adds groups and iterators.</h3>\n<p>These elements can group other elements and unpack them several times</p>\n<p>The () element represents a group. It should be used like that:</p>\n<blockquote>\n\u201c4s I2H (2B 2H) 20a\u201d</blockquote>\n<p>All elements between the brackets will be unpacked as a substructure, in a list. Here, it can returns for example:</p>\n<blockquote>\n[b\u2019test\u2019, 10000, 326, 1919, [11, 19, 112, 1222] , b\u2019x00x00\u2019]</blockquote>\n<p>At packing, all data packed in the group should be in a list, like this.</p>\n<p>Then, the [] element is an iterator. It should be used like that:</p>\n<blockquote>\n\u201ch 4[2B]\u201d</blockquote>\n<p>It will read the substructure as many times as precised before the [. It will returns a list of lists, like this:</p>\n<blockquote>\n[-1234, [[11, 12], [111, 112], [9, 99], [31, 112]]]</blockquote>\n<p>Finally, the {} iterator will iterate until the end of data is reached (so don\u2019t precise the iterations count). Like [], it returns a list of lists. For examples, this structure:</p>\n<blockquote>\n\u20184s {Bn}\u2019</blockquote>\n<p>With this data:</p>\n<blockquote>\nb\u2019TESTx01Yesx00x02Nox00\u2019</blockquote>\n<p>Returns:</p>\n<blockquote>\n[b\u2019TEST\u2019, [[1, b\u2019Yes\u2019], [2, b\u2019No\u2019]]]</blockquote>\n</div>\n<div id=\"finally-rawutil-includes-references\">\n<h3>Finally, rawutil includes references</h3>\n<p>There is two different types of references: external and internal references.</p>\n<p>The external references are represented with \u2018#\u2019. They are replaced by the corresponding element in the refdata argument. For example, with this call:</p>\n<pre>data = b'&lt;some bytes&gt;!'\nrawutil.unpack('#0c #1s #2c', data, refdata=(1, len(data) - 3, 2))\n</pre>\n<p>\u201c#0\u201d is replaced by 1, \u201c#1\u201d by (len(data) - 3), here 10, and \u201c#2\u201d by 2: the final structure is \u20181c 10s 2c\u2019 so it will return:</p>\n<blockquote>\n[b\u2019&lt;\u2019, b\u2019some bytes\u2019, b\u2019&gt;\u2019, b\u2019!\u2019]</blockquote>\n<p>Then, the internal references. They are represented by a \u201c/\u201d, and should be used like this:</p>\n<blockquote>\n\u20184s 2B /2[2s]\u2019</blockquote>\n<p>The number near the \u201c/\u201d is the index of the reference. The reference will be replaced by the unpacked element at the specified index, here the second \u201cB\u201d, so with this data:</p>\n<blockquote>\nb\u2019TESTxffx06zyXWvuTSrqPO\u2019</blockquote>\n<p>It will return:</p>\n<blockquote>\n[b\u2019TEST\u2019, 255, 6, [[b\u2019zy\u2019], [b\u2019XW\u2019], [b\u2019vu\u2019], [b\u2019TS\u2019], [b\u2019rq\u2019], [b\u2019PO\u2019]]]</blockquote>\n<p>Here, the element 2 of the unpacked elements contains 6, so the \u201c/2\u201d is replaced by \u201c6\u201d, so it is interpreted as \u20184s 2B 6[2s]\u2019, so [2s] is unpacked as many times as specified by the element 2.</p>\n<p>Internal references can also be relative, with \u2018/p\u2019. You can use for example this structure:</p>\n<blockquote>\n\u20182B /p2[2s]\u2019</blockquote>\n<p>With this data:</p>\n<blockquote>\nb\u2019x04xffJJkkLLmm\u2019</blockquote>\n<p>It will return:</p>\n<blockquote>\n[4, 255, [[b\u2019JJ\u2019, b\u2019kk\u2019, b\u2019LL\u2019, b\u2019mm\u2019]]]</blockquote>\n<p>So the \u201c/p2\u201d will be replaced by the element situated 2 elements before, here, the first B, so here, 4</p>\n</div>\n</div>\n<div id=\"objects\">\n<h2>Objects</h2>\n<p>You can also use rawutil with objects TypeReader and TypeWriter.</p>\n<blockquote>\nTypeReader(byteorder=\u2019@\u2019)\nTypeWriter(byteorder=\u2019@\u2019)</blockquote>\n<p>The byteorder argument is the used byteorder mark, exactly like the format strings\u2019 one. You can also specify it using the byteorder attribute of these objects.</p>\n<p>You can easily subclass it to create a reader or writer class for the format you want.</p>\n<p>These two objects have the pack, unpack and unpack_from methods, which are exactly the sames as the module-level ones, but if the byte order is not precised in the structure, it defaults to the byteorder attribute instead of \u201c@\u201d.</p>\n<p>First, the TypeReader object can read elements from a bytes-like or file-like object. It has the following methods:</p>\n<blockquote>\n<dl>\n<dt>bit(n, bit, length=1)</dt>\n<dd>Returns the specified bits in the n integer. Returns (length) bits</dd>\n<dt>nibbles(n)</dt>\n<dd>Returns the high and low nibbles of a byte</dd>\n<dt>signed_nibbles(n)</dt>\n<dd>Returns the high and low signed nibbles of a byte</dd>\n</dl>\n</blockquote>\n<p>All its other methods takes 2 arguments:</p>\n<blockquote>\nTypeReader.uint8(data, ptr=0)</blockquote>\n<p>ptr is the offset to start reading. If None, reading starts at the current file position (given by file.tell()), or at 0 if data is a bytes-like object. All its other methods returns (unpacked, ptr), where unpacked is the unpacked elements, and ptr is the offset where the reading ended.</p>\n<p>The TypeReader objects have the following methods:</p>\n<pre>uint8(data, ptr=None)\nuint16(data, ptr=None)\nuint24(data, ptr=None)\nuint32(data, ptr=None)\nuint64(data, ptr=None)\nint8(data, ptr=None)\nint16(data, ptr=None)\nint24(data, ptr=None)\nint32(data, ptr=None)\nint64(data, ptr=None)\nfloat32(data, ptr=None) = float(...)\ndouble(data, ptr=None)  #64 bits double\nstring(data, ptr=None)  #null-terminated string, like the \"n\" format character\nutf16string(data, ptr=None)  #null-terminated UTF-16 string\n</pre>\n<p>Then, the TypeWriter object can pack some elements. It has the following methods: (data argument is the element to pack, out can be the output file-like objects):</p>\n<pre>nibbles(high, low)  #returns the byte formed by the two nibbles\nsigned_nibbles(high, low)  #idem with signed nibbles\nint8(data, out=None)\nint16(data, out=None)\nint24(data, out=None)\nint32(data, out=None)\nint64(data, out=None)\nuint8(data, out=None)\nuint16(data, out=None)\nuint24(data, out=None)\nuint32(data, out=None)\nuint64(data, out=None)\nfloat32(data, out=None) = float(...)\ndouble(data, out=None)  #64 bits double\nstring(data, align=0, out=None)  #align is the minimal size to pack. Packs a bytes object as a null-terminated string\nutf16string(data, align=0, out=None)\npad(num)  #Returns the given number of null bytes\nalign(data, alignnment)  #Returns null bytes to fill to a multiple of the alignment\n</pre>\n<p>There are not any non-builtin dependencies.</p>\n</div>\n\n          </div>"}, "last_serial": 7128604, "releases": {"2.4.10": [{"comment_text": "", "digests": {"md5": "d98be61d23750c678f1b0b54b1e342f9", "sha256": "ea3f287830abf4a484560262f3e156c1652d50051b521f9f09421d0733584b03"}, "downloads": -1, "filename": "rawutil-2.4.10.tar.gz", "has_sig": false, "md5_digest": "d98be61d23750c678f1b0b54b1e342f9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 13201, "upload_time": "2019-03-09T16:14:47", "upload_time_iso_8601": "2019-03-09T16:14:47.185752Z", "url": "https://files.pythonhosted.org/packages/5b/76/2ce9f3d1b2427f28b09d81a9ffcd4e50e7a43161803648448ee92f4580ce/rawutil-2.4.10.tar.gz", "yanked": false}], "2.4.11": [{"comment_text": "", "digests": {"md5": "4e143846b792b759508459cdc89ad06d", "sha256": "3ee6a5ed67e2fdd11ae707efb211e125cff8fbb4be920b7760fec0bdb216aef5"}, "downloads": -1, "filename": "rawutil-2.4.11-py3-none-any.whl", "has_sig": false, "md5_digest": "4e143846b792b759508459cdc89ad06d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.4", "size": 9872, "upload_time": "2020-04-29T12:56:36", "upload_time_iso_8601": "2020-04-29T12:56:36.590361Z", "url": "https://files.pythonhosted.org/packages/81/20/c62493b6d8b7098f3b3ab3b5cf8f67c521df36cb6ab2e272059e54cef022/rawutil-2.4.11-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "77d76b34828f02f2645d0cd805966c33", "sha256": "76fd9de9f3e20135d358acd66eedfa2b43a4c7eaf49c27a34e59340f91785ce0"}, "downloads": -1, "filename": "rawutil-2.4.11.tar.gz", "has_sig": false, "md5_digest": "77d76b34828f02f2645d0cd805966c33", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 12555, "upload_time": "2020-04-29T12:56:37", "upload_time_iso_8601": "2020-04-29T12:56:37.921915Z", "url": "https://files.pythonhosted.org/packages/da/b9/d203156e6bf195b7d4ed913fa180bc57bdb8c5af3ba9dba3c09ca0b21766/rawutil-2.4.11.tar.gz", "yanked": false}], "2.4.8": [{"comment_text": "", "digests": {"md5": "69b7127352b5f3270e5b86bec4f38ba7", "sha256": "8f332cbfe0cfb1548015f427d80f85046bca3fc5389ca6ba3608bbf0042008ea"}, "downloads": -1, "filename": "rawutil-2.4.8.tar.gz", "has_sig": false, "md5_digest": "69b7127352b5f3270e5b86bec4f38ba7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 9272, "upload_time": "2017-12-03T16:01:39", "upload_time_iso_8601": "2017-12-03T16:01:39.814928Z", "url": "https://files.pythonhosted.org/packages/48/c5/41d5508e82ed5fc123f997e85183632dddd3a5e733f25b87591693b18400/rawutil-2.4.8.tar.gz", "yanked": false}], "2.4.9": [{"comment_text": "", "digests": {"md5": "8cde4117cff2e9a28b085d0286a85d09", "sha256": "cf99c83837cedc3b3a2e54ae2168dbd9dbc46837bbac60c0ac45d054195f9fa0"}, "downloads": -1, "filename": "rawutil-2.4.9.tar.gz", "has_sig": false, "md5_digest": "8cde4117cff2e9a28b085d0286a85d09", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 10584, "upload_time": "2017-12-03T16:34:47", "upload_time_iso_8601": "2017-12-03T16:34:47.841748Z", "url": "https://files.pythonhosted.org/packages/44/ac/a323325c0a0d541f27f6a8ef5b1eafb4dd4972b42c0e48dd3fa6148760f3/rawutil-2.4.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4e143846b792b759508459cdc89ad06d", "sha256": "3ee6a5ed67e2fdd11ae707efb211e125cff8fbb4be920b7760fec0bdb216aef5"}, "downloads": -1, "filename": "rawutil-2.4.11-py3-none-any.whl", "has_sig": false, "md5_digest": "4e143846b792b759508459cdc89ad06d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.4", "size": 9872, "upload_time": "2020-04-29T12:56:36", "upload_time_iso_8601": "2020-04-29T12:56:36.590361Z", "url": "https://files.pythonhosted.org/packages/81/20/c62493b6d8b7098f3b3ab3b5cf8f67c521df36cb6ab2e272059e54cef022/rawutil-2.4.11-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "77d76b34828f02f2645d0cd805966c33", "sha256": "76fd9de9f3e20135d358acd66eedfa2b43a4c7eaf49c27a34e59340f91785ce0"}, "downloads": -1, "filename": "rawutil-2.4.11.tar.gz", "has_sig": false, "md5_digest": "77d76b34828f02f2645d0cd805966c33", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 12555, "upload_time": "2020-04-29T12:56:37", "upload_time_iso_8601": "2020-04-29T12:56:37.921915Z", "url": "https://files.pythonhosted.org/packages/da/b9/d203156e6bf195b7d4ed913fa180bc57bdb8c5af3ba9dba3c09ca0b21766/rawutil-2.4.11.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:06:57 2020"}