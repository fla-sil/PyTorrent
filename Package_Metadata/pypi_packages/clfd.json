{"info": {"author": "Vincent Morello", "author_email": "vmorello@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: Unix", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Astronomy"], "description": "[![arXiv](http://img.shields.io/badge/astro.ph-1811.04929-B31B1B.svg)](https://arxiv.org/abs/1811.04929)  ![License](https://img.shields.io/badge/License-MIT-green.svg)  ![Python versions](https://img.shields.io/pypi/pyversions/clfd.svg)\n\n# clfd\n\n**NOTE:** version 0.3+ can now be installed via `pip install`. **If you have an older version and want to upgrade please read the installation instructions below**\n\n``clfd`` stands for **cl**ean **f**olded **d**ata, and implements smart interference removal algorithms to be used on _folded_ pulsar search and pulsar timing data. They are based on a simple outlier detection method and require very little to no human input, which is the main reason for their efficacy. These cleaning algorithms were initially developed for a complete re-processing of the High Time Resolution Universe (HTRU) survey, and can be credited with the discovery of several pulsars that would have otherwise been missed. \n\n## Citation\n\nIf using ``clfd`` contributes to a project that leads to a scientific publication, please cite the article  \n[\"The High Time Resolution Universe survey XIV: Discovery of 23 pulsars through GPU-accelerated reprocessing\"](https://arxiv.org/abs/1811.04929)\n\nA detailed explanation of ``clfd``'s algorithms and a visual demonstration of what they can do on real Parkes data can be found in section 2.4. The idea is to convert each profile (there is one profile per channel and per sub-integration) to a small set of representative features (e.g. standard deviation, peak-to-peak difference) and to flag outliers in the resulting feature space. Since v0.2.2, ``clfd``  outputs report plots to visualize the outlier flagging process and the resulting two-dimensional time-frequency mask applied to the clean archive. Here's the output of a ``clfd`` run on a Parkes observation of the pulsar J0735-62, where the red lines delimit the automatically inferred acceptable value range for each feature:\n\n![Corner Plot](docs/corner_plot.png)\n\n![Profile Mask](docs/profile_mask.png)\n\n## Interfaces to existing data formats\n\nThe implementation of the cleaning algorithms is entirely decoupled from the input/output data format, and interfaces to any folded data format can be easily implemented. Currently, ``clfd`` can read and write PSRFITS archives via the python bindings of [PSRCHIVE](http://psrchive.sourceforge.net/). An interface to [PRESTO](https://www.cv.nrao.edu/~sransom/presto/)'s pfd archives can be added if there are any expressions of interest.\n\n## Python version\n\nThe core of ``clfd`` is fully compatible with both python 2.7 and python 3, but you will have to use whichever python version that your [PSRCHIVE](http://psrchive.sourceforge.net/) python bindings require. Recent (2019+) installations of psrchive may require python3, while older ones are only compatible with python2. Keep that in mind if you are planning to install ``clfd`` in a virtual environment with [conda](https://conda.io/docs/user-guide/tasks/manage-environments.html) or any similar alternative.\n\n\n## Dependencies\n\nStrict dependencies:  \n\n- ``numpy``\n- ``pandas``\n\nOptional but recommended:  \n\n- ``pytables``: to save and load cleaning reports in HDF5 format\n- ``matplotlib``: to plot cleaning reports in particular\n\n\n## Installation\n\nThere are three main choices here, given in decreasing order of recommendation. \n**Important note to users of 0.2.x and earlier versions**: the package name in `setup.py` was changed from `clfd-pulsar` to `clfd` in version 0.3.0. This has the potential to cause some trouble. **When upgrading from a version older than v0.3.0, users should first cleanly uninstall any older versions of** `clfd` by typing `pip uninstall clfd-pulsar`. Also, if you created a shell alias called `clfd` that points to `apps/cleanup.py`, please remove it, as the new setup script now automatically takes care of creating it (via a console_scripts entry point).\n\n\n#### Installing with pip\n\nThe easiest method is to use pip install, which pulls the latest release from the python package index and installs all missing dependencies:\n```\npip install clfd\n```\n\nOnce installed, import the module and run the unit tests:\n```\nIn [1]: import clfd\n\nIn [2]: clfd.test()\n.................\n----------------------------------------------------------------------\nRan 17 tests in 1.261s\n\nOK\n```\nNote that if the PSRCHIVE python bindings cannot be imported, then all PSRCHIVE-related tests will be skipped, which will visible in the output above. Tests related to saving / loading reports will also be skipped if ``pytables`` is not available.\n\n\nFinally, check that the main command-line application of `clfd` has been placed in your `PATH`:\n```\nclfd -h\n```\nAnd you should see the full help of the application, see next section for more details.\n\n\n#### Editable installation\n\nAlternatively, you can clone the repository and in the base directory of `clfd` just type:\n\n```bash\nmake install\n```\n\nThis simply runs ``pip install`` in [editable mode](https://pip.pypa.io/en/latest/reference/pip_install/#editable-installs), which means you can freely edit the code. It also installs all required dependencies with ``pip``.\n\n\n#### The PYTHONPATH method\n\nIf you are not allowed to install packages with ``pip`` (this may be the case on some computing clusters) or like to play it old school, then you can simply clone the repository and add the base directory of ``clfd`` to your ``PYTHONPATH`` environment variable, but then:\n1. You have to install the required dependencies manually.\n2. The main command-line application `clfd` (see below) will **NOT** be placed in your `PATH` automatically, which means that you may want to create a shell alias that points to `clfd/apps/cleanup.py` to make life enjoyable.\n\nI warmly recommend using one of the methods above unless you have no other option.\n\n\n## Command line usage\n\nIf your installation went well, a command-line application `clfd` should now appear in your `PATH` and be callable from anywhere. It points to the ``cleanup.py`` script in the ``apps`` sub-directory, and can batch process multiple files / archives at once. For detailed help on command line arguments:\n\n```bash\nclfd -h\n```\n\nRunning with default arguments should work very well in the vast majority of cases. For example, to process a batch of `PSRCHIVE` archive files placed in the ``~/folded_data`` directory:\n```\nclfd ~/folded_data/*.ar\n```\nThis leaves the input files intact, and produces cleaned copies which are placed in the same directory, with the an additional ``.clfd`` extension appended. Report files in HDF5 format are also saved as ``BASENAME_clfd_report.h5`` where ``BASENAME`` is the archive file name without its extension. A Report stores all inputs and outputs of a clfd run on an archive, they can easily be loaded and manipulated interactively in IPython. See also section \"Working with reports\" below for more details.\n\n```python\n>>> from clfd import Report\n>>> r = Report.load(\"SomeArchive_clfd_report.h5\")\n>>> r.corner_plot()\n>>> r.profile_mask_plot()\n```\n\nThe masking of bad time-phase bins can be enabled with the `--despike` option. However, it is disabled by default as there is a small chance that it could affect pulses from a very bright low-DM pulsar, and it also tends to fail in the worst RFI environments. Be careful when using that option, and check that you are getting an improvement of data quality out of it.\n\n\n## Interactive Usage\n\nThe command-line application may be the most practical way of getting the job done, but it just calls functions that are accessible to the user as well. It might be useful to check or plot intermediate outputs. The example below exposes the computation steps: featurization, outlier flagging and application of the outlier mask to the original archive.\n\n```python\n>>> import psrchive\n>>> import clfd\n\n# Load folded archive produced with PSRCHIVE\n>>> cube = clfd.DataCube.from_psrchive(\"archive.ar\")\n\n# Compute chosen profile features.\n# The output is a pandas DataFrame with feature names as columns, and (subint, channel) tuples as rows.\n>>> features = clfd.featurize(cube, features=('std', 'ptp', 'lfamp'))\n>>> print(features)\n                     std       ptp     lfamp\nsubint channel                              \n0      0        0.042826  0.224936  0.786012\n       1        0.000210  0.003367  0.003367\n       2        0.002779  0.006757  0.009283\n       3        0.002778  0.006757  0.020955\n...                  ...       ...       ...\n57     1020     0.050708  0.309764  0.171277\n       1021     0.048685  0.272727  0.928349\n       1022     0.055210  0.314584  1.463649\n       1023     0.058338  0.346801  1.077389\n\n[59392 rows x 3 columns]\n\n# From there, compute profile mask, optionally excluding some known bad channels from the analysis. \n# The example archive here contains Parkes BPSR data, and we know that the first 150 channels are always bad.\n>>> stats, mask = clfd.profile_mask(features, q=2.0, zap_channels=range(150))\n\n# 'stats' contains the 1st and 3rd quantiles, inter-quartile range and min/max acceptable values for each feature.\n# vmin = q1 - q x iqr\n# vmax = q3 + q x iqr\n# Where 'q' is the parameter passed to the profile_mask function above.\n>>> print(stats)\n\n           std       ptp     lfamp\nq1    0.037299  0.202817  0.376125\nq3    0.040031  0.235003  0.918363\niqr   0.002733  0.032185  0.542239\nvmin  0.031833  0.138447 -0.708352\nvmax  0.045497  0.299373  2.002841\n\n# 'mask' is a boolean array of shape (num_subints, num_channels), whose value is True for bad profiles.\n# Any frequency channels specified via the 'zap_channels' argument above are forcibly set to True\n>>> mask.shape\n(58, 1024)\n\n>>> mask\narray([[ True,  True,  True, ..., False, False, False],\n       [ True,  True,  True, ..., False, False, False],\n       [ True,  True,  True, ..., False, False, False],\n       ...,\n       [ True,  True,  True, ..., False, False, False],\n       [ True,  True,  True, ..., False, False, False],\n       [ True,  True,  True, ...,  True,  True,  True]])\n\n# Applying the mask to the original archive and saving the output is a format-dependent operation. \n# For each format there is a corresponding Handler class in the clfd.handlers sub-module, which implements methods to apply a mask to the original file and save the output.\n>>> from clfd.interfaces import PsrchiveInterface\n\n# In PSRCHIVE, every profile has a weight parameter. This sets the weight of every bad profile to 0.\n# We can then save the clean data as a new archive in PSRFITS format.\n>>> archive = psrchive.Archive_load(\"archive.ar\")\n>>> PsrchiveInterface.apply_profile_mask(mask, archive)\n>>> PsrchiveInterface.save(\"archive_clean.ar\", archive)\n\n# Optionally, we can then use the zero DM spike removal algorithm. Here the idea is to look for\n# outliers in the zero DM time-phase plot, and replace them by appropriate values (inferred \n# from the data) across the frequency dimension.\n>>> tpmask, valid_chans, repvals = clfd.time_phase_mask(cube, q=4.0, zap_channels=zap_channels)\n\n# 'mask' is a boolean array of shape (num_subints, num_phase_bins), whose value is True for bad time-phase bins.\n# 'valid_chans' is the list of channels NOT included in zap_channels\n# 'repvals' is a numpy array with the same shape as the data cube, containing appropriate replacement values\n>>> PsrchiveInterface.apply_time_phase_mask(tpmask, valid_chans, repvals, archive)\n>>> PsrchiveInterface.save(\"archive_cleanest.ar\", archive)\n```\n\n## Working with reports\n\nRunning the main command line application produces report files with some useful information about the cleaning performed. Reports store all inputs and outputs of a clfd run on an archive. **NOTE: Reports are very much a feature in development and may change in the future**. At the moment (``v0.2.2`` and above), a Report object has the following attributes:\n\n- ``frequencies``: channel frequencies in MHz\n- ``feature_names``: list of feature names used\n- ``features``: pandas.DataFrame returned by the ``featurize()`` function\n- ``stats``: pandas.DataFrame returned by the ``featurize()`` function\n- ``profmask``: boolean profile mask returned by the ``profile_mask()`` function. This is a numpy array with shape (num_subints, num_channels)\n- ``qmask``: value of the Tukey parameter ``q`` passed to ``profile_mask()``\n- ``zap_channels``: zap_channels argument that passed to ``profile_mask()``\n- ``tpmask``: mask returned by ``time_phase_mask()`` if the function was called (i.e. when the cleanup executable is called with the ``--despike`` option). If time_phase_mask() was NOT called, tpmask will be ``None``. Otherwise, ``tpmask`` is a numpy array with shape (num_subints, num_phase_bins).\n- ``qspike``: value of the Tukey parameter 'q' passed to ``time_phase_mask()``. If ``time_phase_mask()`` was NOT called, tpmask will be ``None``.\n- ``version``: version of clfd that was used to produce this report.\n\nAnd there are two methods to generate nice plots, of which you can see examples above:\n- ``corner_plot()``: pairwise scatter plot of profile features and single feature histograms. Each point represents a single profile (there is one profile per (subint, channel) tuple), and the red lines the inlier (i.e. acceptable) value ranges for each feature. Anything outside the inlier range has been flagged as anomalous and zero-weighted in the output archive.\n- ``profile_mask_plot()``: A view of the two-dimensional profile mask, along with the fraction of data masked in each channel and each sub-integration.\n\nMore attributes and plots will be added in future versions.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/v-morello/clfd", "keywords": "", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "clfd", "package_url": "https://pypi.org/project/clfd/", "platform": "", "project_url": "https://pypi.org/project/clfd/", "project_urls": {"Homepage": "https://github.com/v-morello/clfd"}, "release_url": "https://pypi.org/project/clfd/0.3.2/", "requires_dist": null, "requires_python": "", "summary": "Smart RFI removal algorithms to be used on folded pulsar search and timing data", "version": "0.3.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://arxiv.org/abs/1811.04929\" rel=\"nofollow\"><img alt=\"arXiv\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/865d087fae59947ec6f71d97ec16f57458fff27c/687474703a2f2f696d672e736869656c64732e696f2f62616467652f617374726f2e70682d313831312e30343932392d4233314231422e737667\"></a>  <img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5aab1d039acf22567ba072834df6bce204ac48ad/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d677265656e2e737667\">  <img alt=\"Python versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f400788acd2d90d89274d4417db876aa32a68255/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f636c66642e737667\"></p>\n<h1>clfd</h1>\n<p><strong>NOTE:</strong> version 0.3+ can now be installed via <code>pip install</code>. <strong>If you have an older version and want to upgrade please read the installation instructions below</strong></p>\n<p><code>clfd</code> stands for <strong>cl</strong>ean <strong>f</strong>olded <strong>d</strong>ata, and implements smart interference removal algorithms to be used on <em>folded</em> pulsar search and pulsar timing data. They are based on a simple outlier detection method and require very little to no human input, which is the main reason for their efficacy. These cleaning algorithms were initially developed for a complete re-processing of the High Time Resolution Universe (HTRU) survey, and can be credited with the discovery of several pulsars that would have otherwise been missed.</p>\n<h2>Citation</h2>\n<p>If using <code>clfd</code> contributes to a project that leads to a scientific publication, please cite the article<br>\n<a href=\"https://arxiv.org/abs/1811.04929\" rel=\"nofollow\">\"The High Time Resolution Universe survey XIV: Discovery of 23 pulsars through GPU-accelerated reprocessing\"</a></p>\n<p>A detailed explanation of <code>clfd</code>'s algorithms and a visual demonstration of what they can do on real Parkes data can be found in section 2.4. The idea is to convert each profile (there is one profile per channel and per sub-integration) to a small set of representative features (e.g. standard deviation, peak-to-peak difference) and to flag outliers in the resulting feature space. Since v0.2.2, <code>clfd</code>  outputs report plots to visualize the outlier flagging process and the resulting two-dimensional time-frequency mask applied to the clean archive. Here's the output of a <code>clfd</code> run on a Parkes observation of the pulsar J0735-62, where the red lines delimit the automatically inferred acceptable value range for each feature:</p>\n<p><img alt=\"Corner Plot\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4c2fc5f18644142bbee31d55ea4ba7f97131ccec/646f63732f636f726e65725f706c6f742e706e67\"></p>\n<p><img alt=\"Profile Mask\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3c6b6e62531a03dca4959167f3cb28599d9c6c52/646f63732f70726f66696c655f6d61736b2e706e67\"></p>\n<h2>Interfaces to existing data formats</h2>\n<p>The implementation of the cleaning algorithms is entirely decoupled from the input/output data format, and interfaces to any folded data format can be easily implemented. Currently, <code>clfd</code> can read and write PSRFITS archives via the python bindings of <a href=\"http://psrchive.sourceforge.net/\" rel=\"nofollow\">PSRCHIVE</a>. An interface to <a href=\"https://www.cv.nrao.edu/%7Esransom/presto/\" rel=\"nofollow\">PRESTO</a>'s pfd archives can be added if there are any expressions of interest.</p>\n<h2>Python version</h2>\n<p>The core of <code>clfd</code> is fully compatible with both python 2.7 and python 3, but you will have to use whichever python version that your <a href=\"http://psrchive.sourceforge.net/\" rel=\"nofollow\">PSRCHIVE</a> python bindings require. Recent (2019+) installations of psrchive may require python3, while older ones are only compatible with python2. Keep that in mind if you are planning to install <code>clfd</code> in a virtual environment with <a href=\"https://conda.io/docs/user-guide/tasks/manage-environments.html\" rel=\"nofollow\">conda</a> or any similar alternative.</p>\n<h2>Dependencies</h2>\n<p>Strict dependencies:</p>\n<ul>\n<li><code>numpy</code></li>\n<li><code>pandas</code></li>\n</ul>\n<p>Optional but recommended:</p>\n<ul>\n<li><code>pytables</code>: to save and load cleaning reports in HDF5 format</li>\n<li><code>matplotlib</code>: to plot cleaning reports in particular</li>\n</ul>\n<h2>Installation</h2>\n<p>There are three main choices here, given in decreasing order of recommendation.\n<strong>Important note to users of 0.2.x and earlier versions</strong>: the package name in <code>setup.py</code> was changed from <code>clfd-pulsar</code> to <code>clfd</code> in version 0.3.0. This has the potential to cause some trouble. <strong>When upgrading from a version older than v0.3.0, users should first cleanly uninstall any older versions of</strong> <code>clfd</code> by typing <code>pip uninstall clfd-pulsar</code>. Also, if you created a shell alias called <code>clfd</code> that points to <code>apps/cleanup.py</code>, please remove it, as the new setup script now automatically takes care of creating it (via a console_scripts entry point).</p>\n<h4>Installing with pip</h4>\n<p>The easiest method is to use pip install, which pulls the latest release from the python package index and installs all missing dependencies:</p>\n<pre><code>pip install clfd\n</code></pre>\n<p>Once installed, import the module and run the unit tests:</p>\n<pre><code>In [1]: import clfd\n\nIn [2]: clfd.test()\n.................\n----------------------------------------------------------------------\nRan 17 tests in 1.261s\n\nOK\n</code></pre>\n<p>Note that if the PSRCHIVE python bindings cannot be imported, then all PSRCHIVE-related tests will be skipped, which will visible in the output above. Tests related to saving / loading reports will also be skipped if <code>pytables</code> is not available.</p>\n<p>Finally, check that the main command-line application of <code>clfd</code> has been placed in your <code>PATH</code>:</p>\n<pre><code>clfd -h\n</code></pre>\n<p>And you should see the full help of the application, see next section for more details.</p>\n<h4>Editable installation</h4>\n<p>Alternatively, you can clone the repository and in the base directory of <code>clfd</code> just type:</p>\n<pre>make install\n</pre>\n<p>This simply runs <code>pip install</code> in <a href=\"https://pip.pypa.io/en/latest/reference/pip_install/#editable-installs\" rel=\"nofollow\">editable mode</a>, which means you can freely edit the code. It also installs all required dependencies with <code>pip</code>.</p>\n<h4>The PYTHONPATH method</h4>\n<p>If you are not allowed to install packages with <code>pip</code> (this may be the case on some computing clusters) or like to play it old school, then you can simply clone the repository and add the base directory of <code>clfd</code> to your <code>PYTHONPATH</code> environment variable, but then:</p>\n<ol>\n<li>You have to install the required dependencies manually.</li>\n<li>The main command-line application <code>clfd</code> (see below) will <strong>NOT</strong> be placed in your <code>PATH</code> automatically, which means that you may want to create a shell alias that points to <code>clfd/apps/cleanup.py</code> to make life enjoyable.</li>\n</ol>\n<p>I warmly recommend using one of the methods above unless you have no other option.</p>\n<h2>Command line usage</h2>\n<p>If your installation went well, a command-line application <code>clfd</code> should now appear in your <code>PATH</code> and be callable from anywhere. It points to the <code>cleanup.py</code> script in the <code>apps</code> sub-directory, and can batch process multiple files / archives at once. For detailed help on command line arguments:</p>\n<pre>clfd -h\n</pre>\n<p>Running with default arguments should work very well in the vast majority of cases. For example, to process a batch of <code>PSRCHIVE</code> archive files placed in the <code>~/folded_data</code> directory:</p>\n<pre><code>clfd ~/folded_data/*.ar\n</code></pre>\n<p>This leaves the input files intact, and produces cleaned copies which are placed in the same directory, with the an additional <code>.clfd</code> extension appended. Report files in HDF5 format are also saved as <code>BASENAME_clfd_report.h5</code> where <code>BASENAME</code> is the archive file name without its extension. A Report stores all inputs and outputs of a clfd run on an archive, they can easily be loaded and manipulated interactively in IPython. See also section \"Working with reports\" below for more details.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">clfd</span> <span class=\"kn\">import</span> <span class=\"n\">Report</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">Report</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s2\">\"SomeArchive_clfd_report.h5\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">corner_plot</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">profile_mask_plot</span><span class=\"p\">()</span>\n</pre>\n<p>The masking of bad time-phase bins can be enabled with the <code>--despike</code> option. However, it is disabled by default as there is a small chance that it could affect pulses from a very bright low-DM pulsar, and it also tends to fail in the worst RFI environments. Be careful when using that option, and check that you are getting an improvement of data quality out of it.</p>\n<h2>Interactive Usage</h2>\n<p>The command-line application may be the most practical way of getting the job done, but it just calls functions that are accessible to the user as well. It might be useful to check or plot intermediate outputs. The example below exposes the computation steps: featurization, outlier flagging and application of the outlier mask to the original archive.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">psrchive</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">clfd</span>\n\n<span class=\"c1\"># Load folded archive produced with PSRCHIVE</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cube</span> <span class=\"o\">=</span> <span class=\"n\">clfd</span><span class=\"o\">.</span><span class=\"n\">DataCube</span><span class=\"o\">.</span><span class=\"n\">from_psrchive</span><span class=\"p\">(</span><span class=\"s2\">\"archive.ar\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Compute chosen profile features.</span>\n<span class=\"c1\"># The output is a pandas DataFrame with feature names as columns, and (subint, channel) tuples as rows.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">features</span> <span class=\"o\">=</span> <span class=\"n\">clfd</span><span class=\"o\">.</span><span class=\"n\">featurize</span><span class=\"p\">(</span><span class=\"n\">cube</span><span class=\"p\">,</span> <span class=\"n\">features</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">'std'</span><span class=\"p\">,</span> <span class=\"s1\">'ptp'</span><span class=\"p\">,</span> <span class=\"s1\">'lfamp'</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">features</span><span class=\"p\">)</span>\n                     <span class=\"n\">std</span>       <span class=\"n\">ptp</span>     <span class=\"n\">lfamp</span>\n<span class=\"n\">subint</span> <span class=\"n\">channel</span>                              \n<span class=\"mi\">0</span>      <span class=\"mi\">0</span>        <span class=\"mf\">0.042826</span>  <span class=\"mf\">0.224936</span>  <span class=\"mf\">0.786012</span>\n       <span class=\"mi\">1</span>        <span class=\"mf\">0.000210</span>  <span class=\"mf\">0.003367</span>  <span class=\"mf\">0.003367</span>\n       <span class=\"mi\">2</span>        <span class=\"mf\">0.002779</span>  <span class=\"mf\">0.006757</span>  <span class=\"mf\">0.009283</span>\n       <span class=\"mi\">3</span>        <span class=\"mf\">0.002778</span>  <span class=\"mf\">0.006757</span>  <span class=\"mf\">0.020955</span>\n<span class=\"o\">...</span>                  <span class=\"o\">...</span>       <span class=\"o\">...</span>       <span class=\"o\">...</span>\n<span class=\"mi\">57</span>     <span class=\"mi\">1020</span>     <span class=\"mf\">0.050708</span>  <span class=\"mf\">0.309764</span>  <span class=\"mf\">0.171277</span>\n       <span class=\"mi\">1021</span>     <span class=\"mf\">0.048685</span>  <span class=\"mf\">0.272727</span>  <span class=\"mf\">0.928349</span>\n       <span class=\"mi\">1022</span>     <span class=\"mf\">0.055210</span>  <span class=\"mf\">0.314584</span>  <span class=\"mf\">1.463649</span>\n       <span class=\"mi\">1023</span>     <span class=\"mf\">0.058338</span>  <span class=\"mf\">0.346801</span>  <span class=\"mf\">1.077389</span>\n\n<span class=\"p\">[</span><span class=\"mi\">59392</span> <span class=\"n\">rows</span> <span class=\"n\">x</span> <span class=\"mi\">3</span> <span class=\"n\">columns</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># From there, compute profile mask, optionally excluding some known bad channels from the analysis. </span>\n<span class=\"c1\"># The example archive here contains Parkes BPSR data, and we know that the first 150 channels are always bad.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">stats</span><span class=\"p\">,</span> <span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">clfd</span><span class=\"o\">.</span><span class=\"n\">profile_mask</span><span class=\"p\">(</span><span class=\"n\">features</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"o\">=</span><span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"n\">zap_channels</span><span class=\"o\">=</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">150</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># 'stats' contains the 1st and 3rd quantiles, inter-quartile range and min/max acceptable values for each feature.</span>\n<span class=\"c1\"># vmin = q1 - q x iqr</span>\n<span class=\"c1\"># vmax = q3 + q x iqr</span>\n<span class=\"c1\"># Where 'q' is the parameter passed to the profile_mask function above.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">stats</span><span class=\"p\">)</span>\n\n           <span class=\"n\">std</span>       <span class=\"n\">ptp</span>     <span class=\"n\">lfamp</span>\n<span class=\"n\">q1</span>    <span class=\"mf\">0.037299</span>  <span class=\"mf\">0.202817</span>  <span class=\"mf\">0.376125</span>\n<span class=\"n\">q3</span>    <span class=\"mf\">0.040031</span>  <span class=\"mf\">0.235003</span>  <span class=\"mf\">0.918363</span>\n<span class=\"n\">iqr</span>   <span class=\"mf\">0.002733</span>  <span class=\"mf\">0.032185</span>  <span class=\"mf\">0.542239</span>\n<span class=\"n\">vmin</span>  <span class=\"mf\">0.031833</span>  <span class=\"mf\">0.138447</span> <span class=\"o\">-</span><span class=\"mf\">0.708352</span>\n<span class=\"n\">vmax</span>  <span class=\"mf\">0.045497</span>  <span class=\"mf\">0.299373</span>  <span class=\"mf\">2.002841</span>\n\n<span class=\"c1\"># 'mask' is a boolean array of shape (num_subints, num_channels), whose value is True for bad profiles.</span>\n<span class=\"c1\"># Any frequency channels specified via the 'zap_channels' argument above are forcibly set to True</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">mask</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">58</span><span class=\"p\">,</span> <span class=\"mi\">1024</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">mask</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">],</span>\n       <span class=\"o\">...</span><span class=\"p\">,</span>\n       <span class=\"p\">[</span> <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">]])</span>\n\n<span class=\"c1\"># Applying the mask to the original archive and saving the output is a format-dependent operation. </span>\n<span class=\"c1\"># For each format there is a corresponding Handler class in the clfd.handlers sub-module, which implements methods to apply a mask to the original file and save the output.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">clfd.interfaces</span> <span class=\"kn\">import</span> <span class=\"n\">PsrchiveInterface</span>\n\n<span class=\"c1\"># In PSRCHIVE, every profile has a weight parameter. This sets the weight of every bad profile to 0.</span>\n<span class=\"c1\"># We can then save the clean data as a new archive in PSRFITS format.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">archive</span> <span class=\"o\">=</span> <span class=\"n\">psrchive</span><span class=\"o\">.</span><span class=\"n\">Archive_load</span><span class=\"p\">(</span><span class=\"s2\">\"archive.ar\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">PsrchiveInterface</span><span class=\"o\">.</span><span class=\"n\">apply_profile_mask</span><span class=\"p\">(</span><span class=\"n\">mask</span><span class=\"p\">,</span> <span class=\"n\">archive</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">PsrchiveInterface</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"s2\">\"archive_clean.ar\"</span><span class=\"p\">,</span> <span class=\"n\">archive</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Optionally, we can then use the zero DM spike removal algorithm. Here the idea is to look for</span>\n<span class=\"c1\"># outliers in the zero DM time-phase plot, and replace them by appropriate values (inferred </span>\n<span class=\"c1\"># from the data) across the frequency dimension.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">tpmask</span><span class=\"p\">,</span> <span class=\"n\">valid_chans</span><span class=\"p\">,</span> <span class=\"n\">repvals</span> <span class=\"o\">=</span> <span class=\"n\">clfd</span><span class=\"o\">.</span><span class=\"n\">time_phase_mask</span><span class=\"p\">(</span><span class=\"n\">cube</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"o\">=</span><span class=\"mf\">4.0</span><span class=\"p\">,</span> <span class=\"n\">zap_channels</span><span class=\"o\">=</span><span class=\"n\">zap_channels</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># 'mask' is a boolean array of shape (num_subints, num_phase_bins), whose value is True for bad time-phase bins.</span>\n<span class=\"c1\"># 'valid_chans' is the list of channels NOT included in zap_channels</span>\n<span class=\"c1\"># 'repvals' is a numpy array with the same shape as the data cube, containing appropriate replacement values</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">PsrchiveInterface</span><span class=\"o\">.</span><span class=\"n\">apply_time_phase_mask</span><span class=\"p\">(</span><span class=\"n\">tpmask</span><span class=\"p\">,</span> <span class=\"n\">valid_chans</span><span class=\"p\">,</span> <span class=\"n\">repvals</span><span class=\"p\">,</span> <span class=\"n\">archive</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">PsrchiveInterface</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"s2\">\"archive_cleanest.ar\"</span><span class=\"p\">,</span> <span class=\"n\">archive</span><span class=\"p\">)</span>\n</pre>\n<h2>Working with reports</h2>\n<p>Running the main command line application produces report files with some useful information about the cleaning performed. Reports store all inputs and outputs of a clfd run on an archive. <strong>NOTE: Reports are very much a feature in development and may change in the future</strong>. At the moment (<code>v0.2.2</code> and above), a Report object has the following attributes:</p>\n<ul>\n<li><code>frequencies</code>: channel frequencies in MHz</li>\n<li><code>feature_names</code>: list of feature names used</li>\n<li><code>features</code>: pandas.DataFrame returned by the <code>featurize()</code> function</li>\n<li><code>stats</code>: pandas.DataFrame returned by the <code>featurize()</code> function</li>\n<li><code>profmask</code>: boolean profile mask returned by the <code>profile_mask()</code> function. This is a numpy array with shape (num_subints, num_channels)</li>\n<li><code>qmask</code>: value of the Tukey parameter <code>q</code> passed to <code>profile_mask()</code></li>\n<li><code>zap_channels</code>: zap_channels argument that passed to <code>profile_mask()</code></li>\n<li><code>tpmask</code>: mask returned by <code>time_phase_mask()</code> if the function was called (i.e. when the cleanup executable is called with the <code>--despike</code> option). If time_phase_mask() was NOT called, tpmask will be <code>None</code>. Otherwise, <code>tpmask</code> is a numpy array with shape (num_subints, num_phase_bins).</li>\n<li><code>qspike</code>: value of the Tukey parameter 'q' passed to <code>time_phase_mask()</code>. If <code>time_phase_mask()</code> was NOT called, tpmask will be <code>None</code>.</li>\n<li><code>version</code>: version of clfd that was used to produce this report.</li>\n</ul>\n<p>And there are two methods to generate nice plots, of which you can see examples above:</p>\n<ul>\n<li><code>corner_plot()</code>: pairwise scatter plot of profile features and single feature histograms. Each point represents a single profile (there is one profile per (subint, channel) tuple), and the red lines the inlier (i.e. acceptable) value ranges for each feature. Anything outside the inlier range has been flagged as anomalous and zero-weighted in the output archive.</li>\n<li><code>profile_mask_plot()</code>: A view of the two-dimensional profile mask, along with the fraction of data masked in each channel and each sub-integration.</li>\n</ul>\n<p>More attributes and plots will be added in future versions.</p>\n\n          </div>"}, "last_serial": 6253297, "releases": {"0.3.0": [{"comment_text": "", "digests": {"md5": "b443f40393f538ae6274e7007217a7c3", "sha256": "4cef90a94617fb37ff3553aefc675e6d3466f55aae3c74b981f148ed9aa2270e"}, "downloads": -1, "filename": "clfd-0.3.0.tar.gz", "has_sig": false, "md5_digest": "b443f40393f538ae6274e7007217a7c3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 684733, "upload_time": "2019-07-20T20:32:54", "upload_time_iso_8601": "2019-07-20T20:32:54.938999Z", "url": "https://files.pythonhosted.org/packages/17/68/2166b04de185ee1279c44814526fc27275af99e6254e6013bb2b8fe8eebb/clfd-0.3.0.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "2041c787849e85518b07a1468e0d2b13", "sha256": "73e13e57f4814037790a41fdf0b1b6821f7b8b7ea77c0a75c7bf9c7f64d97604"}, "downloads": -1, "filename": "clfd-0.3.1.tar.gz", "has_sig": false, "md5_digest": "2041c787849e85518b07a1468e0d2b13", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 685070, "upload_time": "2019-11-19T17:00:42", "upload_time_iso_8601": "2019-11-19T17:00:42.108359Z", "url": "https://files.pythonhosted.org/packages/a0/9d/8a9dd232885a098b5c75345f9b6c225e085bc7ae47dcd924ea0ce3fd57db/clfd-0.3.1.tar.gz", "yanked": false}], "0.3.2": [{"comment_text": "", "digests": {"md5": "5cf771f83c2500b2fd3bf75ea2c6b350", "sha256": "cf9fe3026430953864be27d49bfa2e652e386c42c74f4b7f3b161c3a83469dd7"}, "downloads": -1, "filename": "clfd-0.3.2.tar.gz", "has_sig": false, "md5_digest": "5cf771f83c2500b2fd3bf75ea2c6b350", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 685706, "upload_time": "2019-12-06T09:46:16", "upload_time_iso_8601": "2019-12-06T09:46:16.738916Z", "url": "https://files.pythonhosted.org/packages/c3/54/a7bd855ec0da38f6ada15a0d2d364585447338185ca50563899bfb4c648f/clfd-0.3.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5cf771f83c2500b2fd3bf75ea2c6b350", "sha256": "cf9fe3026430953864be27d49bfa2e652e386c42c74f4b7f3b161c3a83469dd7"}, "downloads": -1, "filename": "clfd-0.3.2.tar.gz", "has_sig": false, "md5_digest": "5cf771f83c2500b2fd3bf75ea2c6b350", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 685706, "upload_time": "2019-12-06T09:46:16", "upload_time_iso_8601": "2019-12-06T09:46:16.738916Z", "url": "https://files.pythonhosted.org/packages/c3/54/a7bd855ec0da38f6ada15a0d2d364585447338185ca50563899bfb4c648f/clfd-0.3.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:19:03 2020"}