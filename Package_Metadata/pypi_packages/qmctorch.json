{"info": {"author": "['Nicolas Renaud', 'Felipe Zapata']", "author_email": "n.renaud@esciencecenter.nl", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Chemistry"], "description": "# QMCTorch\n\nPytorch Implementation of Real Space Quantum Monte Carlo Simulations of Molecular Systems\n\n[![Build Status](https://travis-ci.com/NLESC-JCER/QMCTorch.svg?branch=master)](https://travis-ci.com/NLESC-JCER/QMCTorch)\n[![Coverage Status](https://coveralls.io/repos/github/NLESC-JCER/QMCTorch/badge.svg?branch=master)](https://coveralls.io/github/NLESC-JCER/QMCTorch?branch=master)\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/5d99212add2a4f0591adc6248fec258d)](https://www.codacy.com/manual/NicoRenaud/QMCTorch?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=NLESC-JCER/QMCTorch&amp;utm_campaign=Badge_Grade)\n[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.3780094.svg)](https://doi.org/10.5281/zenodo.3780094)\n\n## Documentation \nhttps://qmctorch.readthedocs.io/en/latest/intro.html\n\n\n<!-- \n## Introduction\n\nQMCTorch allows to leverage deep learning to optimize QMC wave functions. The package offers solutions to optimize particle-in-a-box model as well as molecular systems. It uses `pytorch` as a deep learning framework and `pyscf` or `adf` to obtain the basis set information and the first guess of the molecular orbitals.\n\nThe three main ingredients of any calculations are :\n\n* a neural network that calculates the value of the wave function at a given point\n* a sampler able to generate sampling points of the wave function\n* an optimizer (as those provided by `pytorch`)\n\nThe wave function is encoded in the simple multilayer neural network depicted below:\n\n<p align=\"center\">\n<img src=\"./pics/mol_nn.png\" title=\"Neural network used for molecular systems\">\n</p>\n\nStarting from the positions of the walkers, the `AtomicOrbital` layer computes the value of each atomic orbital for each electrons. The second layer is a linear transformation that computes the molecular orbital as linear combination of AOs. Then the `SlaterPooling` finally computes the value of the Slater determinant and the last layer create the CI expansion. A `Jastrow` layer also computes the Jastrow factor that is multiplied with the CI expansion. \n\n## Wave function optmization of H2\n\nAs an illustrative example let's optimize the wave function of H2 using the following script :\n\n```python\nimport sys\nfrom torch import optim\n\nfrom qmctorch.wavefunction import Orbital, Molecule\nfrom qmctorch.solver import SolverOrbital\nfrom qmctorch.sampler import Metropolis\nfrom qmctorch.utils import plot_energy, set_torch_double_precision\n\nset_torch_double_precision()\n\n# define the molecule\nmol = Molecule(atom='H 0 0 -0.69; H 0 0 0.69',\n               calculator='pyscf',\n               basis='dzp',\n               unit='bohr')\n\n# define the wave function\nwf = Orbital(mol, configs='cas(2,2)')\n\n#sampler\nsampler = Metropolis(nwalkers=500, nstep=2000, step_size=0.2,\n                     ndim=wf.ndim, nelec=wf.nelec,\n                     init=mol.domain('atomic'),\n                     move={'type': 'all-elec', 'proba': 'normal'})\n\n# optimizer\nlr_dict = [{'params': wf.jastrow.parameters(), 'lr': 3E-3},\n           {'params': wf.ao.parameters(), 'lr': 1E-6},\n           {'params': wf.mo.parameters(), 'lr': 1E-3},\n           {'params': wf.fc.parameters(), 'lr': 3E-3}]\nopt = optim.Adam(lr_dict)\n\n# scheduler\nscheduler = optim.lr_scheduler.StepLR(opt, step_size=100, gamma=0.90)\n\n# solver\nsolver = SolverOrbital(wf=wf, sampler=sampler,\n                       optimizer=opt, scheduler=None)\n\n# optimize jatrow and CI only (freeze ao and mo)\nsolver.configure(task='wf_opt', freeze=['ao', 'mo'])\n\n# initial sampling\nsolver.initial_sampling(ntherm=1000, ndecor=100)\n\n# resampling\nsolver.resampling(nstep=20)\n\n# run the optimization\ndata = solver.run(250, loss='energy')\n\n# plot the data\ne, v = plot_energy(solver.obs_dict, e0=-1.1645, show_variance=True)\n```\n\nThe `Molecule` class allows to easily define molecular structure and the basis set used to describe its electronic structure Gaussian (`gto`) and Slater (`sto`) atomic orbitals are supported. The `Orbital` class defines the neural network that encodes the wave function ansatz. The sampler is here set to a simple `Metroplois` using 500 walkers each performing 2000 steps. The `Adam` optimizer is chosen with a simple linear scheduler. All these objects are assembled in the `SolverOrbital` that is then configured and run for 250 epoch. The result of this optimization is depicted below :\n\n<p align=\"center\">\n<img src=\"./pics/h2_dzp.png\" title=\"Wave function optimization of a H2 molecule\">\n</p>\n\nAs seen here both the energy and the variance of the wave function decreases during the optimization\n\n## Geometry optimization of a water molecule\n\n`QMCTorch` can also be used to perform geometry optimization as the atomic coordinate are variational parameters of the `AtomicOrbital` layer. For example the following example optimize a water molecule :\n\n```python\n\nmol = Molecule(atom='water.xyz', unit='angs',\n               calculator='pyscf', basis='dz')\n\n# define the wave function\nwf = Orbital(mol,configs='ground_state')\n\n# sampler\nsampler = Metropolis(nwalkers=1000, nstep=2000, step_size=0.2,\n                     nelec=wf.nelec, ndim=wf.ndim,\n                     init=mol.domain('atomic'),\n                     move={'type': 'all-elec', 'proba': 'normal'})\n\n# optimizer\nopt = optim.Adam(wf.parameters(), lr=0.005)\n\n# solver\nsolver = SolverOrbital(wf=wf, sampler=sampler,optimizer=opt)\nsolver.configure(task='geo_opt')\nsolver.observable(['local_energy','atomic_distances'])\nsolver.run(50,loss='energy')\nsolver.save_traj('h2o_traj.xyz')\n```\n\nNote that comfiguring the solver to perform a geometry optimization is done in one single line. The results of this optimization is shown below :\n\n<p align=\"center\">\n<img src=\"./pics/h2o.gif\" title=\"Wave function Ooptimization of a H2 molecule\">\n</p> -->\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/NLESC-JCER/QMCTorch", "keywords": "qmctorch", "license": "Apache Software License 2.0", "maintainer": "", "maintainer_email": "", "name": "qmctorch", "package_url": "https://pypi.org/project/qmctorch/", "platform": "", "project_url": "https://pypi.org/project/qmctorch/", "project_urls": {"Homepage": "https://github.com/NLESC-JCER/QMCTorch"}, "release_url": "https://pypi.org/project/qmctorch/0.1.0/", "requires_dist": ["autograd", "cython", "matplotlib", "numpy", "pyyaml (>=5.1)", "schema", "scipy", "tqdm", "torch", "pyscf", "mendeleev", "prospector[with_pyroma] ; extra == 'dev'", "yapf ; extra == 'dev'", "isort ; extra == 'dev'", "recommonmark ; extra == 'doc'", "sphinx ; extra == 'doc'", "sphinx-rtd-theme ; extra == 'doc'", "coverage ; extra == 'test'", "pycodestyle ; extra == 'test'", "pytest ; extra == 'test'", "pytest-cov ; extra == 'test'", "pytest-runner ; extra == 'test'"], "requires_python": "", "summary": "Pytorch Implementation of Quantum Monte Carlo", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>QMCTorch</h1>\n<p>Pytorch Implementation of Real Space Quantum Monte Carlo Simulations of Molecular Systems</p>\n<p><a href=\"https://travis-ci.com/NLESC-JCER/QMCTorch\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9f2524e71a66c88a7f27a1eb6cf8043ecf2eaec2/68747470733a2f2f7472617669732d63692e636f6d2f4e4c4553432d4a4345522f514d43546f7263682e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/NLESC-JCER/QMCTorch?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/aa2ed24254ab88d10ca049807b5695efbe4dd226/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f4e4c4553432d4a4345522f514d43546f7263682f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://www.codacy.com/manual/NicoRenaud/QMCTorch?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=NLESC-JCER/QMCTorch&amp;utm_campaign=Badge_Grade\" rel=\"nofollow\"><img alt=\"Codacy Badge\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/452362e2b95b288b207939b4e69eddd966917370/68747470733a2f2f6170692e636f646163792e636f6d2f70726f6a6563742f62616467652f47726164652f3564393932313261646432613466303539316164633632343866656332353864\"></a>\n<a href=\"https://doi.org/10.5281/zenodo.3780094\" rel=\"nofollow\"><img alt=\"DOI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f99abb248b63c630497a007db589232b10afe62d/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f444f492f31302e353238312f7a656e6f646f2e333738303039342e737667\"></a></p>\n<h2>Documentation</h2>\n<p><a href=\"https://qmctorch.readthedocs.io/en/latest/intro.html\" rel=\"nofollow\">https://qmctorch.readthedocs.io/en/latest/intro.html</a></p>\n\n\n          </div>"}, "last_serial": 7144894, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "01da447ec88d18b34b3597ab1a1a8406", "sha256": "0f874f928bffb044aa0b29897ec42d61b76c44ac2b6b0261e6620e86a7bc3aac"}, "downloads": -1, "filename": "qmctorch-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "01da447ec88d18b34b3597ab1a1a8406", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 69316, "upload_time": "2020-05-01T13:20:40", "upload_time_iso_8601": "2020-05-01T13:20:40.833183Z", "url": "https://files.pythonhosted.org/packages/37/37/c744a2d4a6ecacdaa0b7d09c262b477ae35d380ae86c76bc95164ea6efee/qmctorch-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f1bc9f67f54f0ba26a1f03bfa1a3a4bf", "sha256": "096c269d8edeefc2c22fe42d3a2fbc73a3d913dd21053985bca3ec42d0670aec"}, "downloads": -1, "filename": "qmctorch-0.1.0.tar.gz", "has_sig": false, "md5_digest": "f1bc9f67f54f0ba26a1f03bfa1a3a4bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52198, "upload_time": "2020-05-01T13:20:42", "upload_time_iso_8601": "2020-05-01T13:20:42.990676Z", "url": "https://files.pythonhosted.org/packages/ea/38/ceece1515a7923d8b21af0a4e46b6d01ff6f30cc6e96c5efc8c10fc8873a/qmctorch-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "01da447ec88d18b34b3597ab1a1a8406", "sha256": "0f874f928bffb044aa0b29897ec42d61b76c44ac2b6b0261e6620e86a7bc3aac"}, "downloads": -1, "filename": "qmctorch-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "01da447ec88d18b34b3597ab1a1a8406", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 69316, "upload_time": "2020-05-01T13:20:40", "upload_time_iso_8601": "2020-05-01T13:20:40.833183Z", "url": "https://files.pythonhosted.org/packages/37/37/c744a2d4a6ecacdaa0b7d09c262b477ae35d380ae86c76bc95164ea6efee/qmctorch-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f1bc9f67f54f0ba26a1f03bfa1a3a4bf", "sha256": "096c269d8edeefc2c22fe42d3a2fbc73a3d913dd21053985bca3ec42d0670aec"}, "downloads": -1, "filename": "qmctorch-0.1.0.tar.gz", "has_sig": false, "md5_digest": "f1bc9f67f54f0ba26a1f03bfa1a3a4bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52198, "upload_time": "2020-05-01T13:20:42", "upload_time_iso_8601": "2020-05-01T13:20:42.990676Z", "url": "https://files.pythonhosted.org/packages/ea/38/ceece1515a7923d8b21af0a4e46b6d01ff6f30cc6e96c5efc8c10fc8873a/qmctorch-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:09:25 2020"}