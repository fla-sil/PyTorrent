{"info": {"author": "Roger Ineichen and the Zope Community", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope :: 3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP"], "description": "==============\n z3c.template\n==============\n\n\n.. image:: https://img.shields.io/pypi/v/z3c.template.svg\n        :target: https://pypi.python.org/pypi/z3c.template/\n        :alt: Latest release\n\n.. image:: https://img.shields.io/pypi/pyversions/z3c.template.svg\n        :target: https://pypi.org/project/z3c.template/\n        :alt: Supported Python versions\n\n.. image:: https://travis-ci.org/zopefoundation/z3c.template.svg?branch=master\n        :target: https://travis-ci.org/zopefoundation/z3c.template\n\n.. image:: https://coveralls.io/repos/github/zopefoundation/z3c.template/badge.svg?branch=master\n        :target: https://coveralls.io/github/zopefoundation/z3c.template?branch=master\n\n\nThis package allows you to register templates independently from view code.\n\nIn Zope 3, when registering a ``browser:page`` both presentation and computation\nare registered together. Unfortunately the registration tangles presentation\nand computation so tightly that it is not possible to re-register a different\ntemplate depending on context. (You can override the whole registration but\nthis is not the main point of this package.)\n\nWith z3c.template the registration is split up between the view and the\ntemplate and allows to differentiate the template based on the skin layer and\nthe view.\n\nIn addition this package lays the foundation to differentiate between\ntemplates that provide specific presentation templates and generic layout\ntemplates.\n\n\n.. contents::\n\n===============\n Z3C Templates\n===============\n\nThis package allows us to separate the registration of the view code and the\nlayout.\n\nA template is used for separate the HTML part from a view. This is done in\nz3 via a page templates. Such page template are implemented in the view,\nregistered included in a page directive etc. But they do not use the adapter\npattern which makes it hard to replace existing templates.\n\nAnother part of template is, that they normaly separate one part presenting\ncontent from a view and another part offer a layout used by the content\ntemplate.\n\nHow can this package make it simpler to use templates?\n\nTemplates can be registered as adapters adapting context, request where the\ncontext is a view implementation. Such a template get adapted from the view\nif the template is needed. This adaption makes it very pluggable and modular.\n\nWe offer two base template directive for register content producing templates\nand layout producing tempaltes. This is most the time enough but you also\ncan register different type of templates using a specific interface. This\ncould be usefull if your view implementation needs to separate HTMl in\nmore then one template. Now let's take a look how we an use this templates.\n\n\nContent template\n================\n\nFirst let's show how we use a template for produce content from a view:\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n  >>> contentTemplate = os.path.join(temp_dir, 'contentTemplate.pt')\n  >>> with open(contentTemplate, 'w') as file:\n  ...     _ = file.write('<div>demo content</div>')\n\nAnd register a view class implementing a interface:\n\n  >>> import zope.interface\n  >>> from z3c.template import interfaces\n  >>> from zope.pagetemplate.interfaces import IPageTemplate\n  >>> from zope.publisher.browser import BrowserPage\n\n  >>> class IMyView(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IMyView)\n  ... class MyView(BrowserPage):\n  ...     template = None\n  ...     def render(self):\n  ...         if self.template is None:\n  ...             template = zope.component.getMultiAdapter(\n  ...                 (self, self.request), interfaces.IContentTemplate)\n  ...             return template(self)\n  ...         return self.template()\n\nLet's call the view and check the output:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n  >>> view = MyView(root, request)\n\nSince the template is not yet registered, rendering the view will fail:\n\n  >>> print(view.render())\n  Traceback (most recent call last):\n  ...\n  zope.interface.interfaces.ComponentLookupError: ......\n\nLet's now register the template (commonly done using ZCML):\n\n  >>> from zope import component\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n  >>> from z3c.template.template import TemplateFactory\n\nThe template factory allows us to create a ViewPageTeplateFile instance.\n\n  >>> factory = TemplateFactory(contentTemplate, 'text/html')\n  >>> factory\n  <z3c.template.template.TemplateFactory object at ...>\n\nWe register the factory on a view interface and a layer.\n\n  >>> component.provideAdapter(\n  ...     factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer),\n  ...     interfaces.IContentTemplate)\n  >>> template = component.getMultiAdapter((view, request),\n  ...     interfaces.IPageTemplate)\n\n  >>> template\n  <...ViewPageTemplateFile...>\n\nNow that we have a registered layout template for the default layer we can\ncall our view again.\n\n  >>> print(view.render())\n  <div>demo content</div>\n\nNow we register a new template on the specific interface of our view.\n\n  >>> myTemplate = os.path.join(temp_dir, 'myTemplate.pt')\n  >>> with open(myTemplate, 'w') as file:\n  ...     _ = file.write('<div>My content</div>')\n  >>> factory = TemplateFactory(myTemplate, 'text/html')\n  >>> component.provideAdapter(\n  ...     factory,\n  ...     (IMyView, IDefaultBrowserLayer), interfaces.IContentTemplate)\n  >>> print(view.render())\n  <div>My content</div>\n\nIt is possible to provide the template directly.\n\nWe create a new template.\n\n  >>> viewContent = os.path.join(temp_dir, 'viewContent.pt')\n  >>> with open(viewContent, 'w') as file:\n  ...     _ = file.write('<div>view content</div>')\n\nand a view:\n\n  >>> from z3c.template import ViewPageTemplateFile\n  >>> @zope.interface.implementer(IMyView)\n  ... class MyViewWithTemplate(BrowserPage):\n  ...     template = ViewPageTemplateFile(viewContent)\n  ...     def render(self):\n  ...         if self.template is None:\n  ...             template = zope.component.getMultiAdapter(\n  ...                 (self, self.request), interfaces.IContentTemplate)\n  ...             return template(self)\n  ...         return self.template()\n  >>> contentView = MyViewWithTemplate(root, request)\n\nIf we render this view we get the implemented layout template and not the\nregistered one.\n\n  >>> print(contentView.render())\n  <div>view content</div>\n\n\nLayout template\n===============\n\nFirst we nee to register a new view class calling a layout template. Note,\nthat this view uses the __call__ method for invoke a layout template:\n\n  >>> class ILayoutView(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(ILayoutView)\n  ... class LayoutView(BrowserPage):\n  ...     layout = None\n  ...     def __call__(self):\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter(\n  ...                 (self, self.request), interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n  >>> view2 = LayoutView(root, request)\n\nDefine and register a new layout template:\n\n  >>> layoutTemplate = os.path.join(temp_dir, 'layoutTemplate.pt')\n  >>> with open(layoutTemplate, 'w') as file:\n  ...     _ = file.write('<div>demo layout</div>')\n  >>> factory = TemplateFactory(layoutTemplate, 'text/html')\n\nWe register the template factory on a view interface and a layer providing the\nILayoutTemplate interface.\n\n  >>> component.provideAdapter(factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer),\n  ...      interfaces.ILayoutTemplate)\n  >>> layout = component.getMultiAdapter(\n  ...     (view2, request), interfaces.ILayoutTemplate)\n\n  >>> layout\n  <...ViewPageTemplateFile...>\n\nNow that we have a registered layout template for the default layer we can\ncall our view again.\n\n  >>> print(view2())\n  <div>demo layout</div>\n\nNow we register a new layout template on the specific interface of our view.\n\n  >>> myLayout = os.path.join(temp_dir, 'myLayout.pt')\n  >>> with open(myLayout, 'w') as file:\n  ...     _ = file.write('<div>My layout</div>')\n  >>> factory = TemplateFactory(myLayout, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (ILayoutView, IDefaultBrowserLayer),\n  ...      interfaces.ILayoutTemplate)\n  >>> print(view2())\n  <div>My layout</div>\n\nIt is possible to provide the layout template directly.\n\nWe create a new template.\n\n  >>> viewLayout = os.path.join(temp_dir, 'viewLayout.pt')\n  >>> with open(viewLayout, 'w') as file:\n  ...     _ = file.write('''<div>view layout</div>''')\n\n  >>> @zope.interface.implementer(ILayoutView)\n  ... class LayoutViewWithLayoutTemplate(BrowserPage):\n  ...     layout = ViewPageTemplateFile(viewLayout)\n  ...     def __call__(self):\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter((self, self.request),\n  ...                 interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n  >>> layoutView = LayoutViewWithLayoutTemplate(root, request)\n\nIf we render this view we get the implemented layout template and not the\nregistered one.\n\n  >>> print(layoutView())\n  <div>view layout</div>\n\n\nSince we return the layout template in the sample views above, how can we get\nthe content from the used view? This is not directly a part of this package\nbut let's show some pattern were can be used for render content in a used\nlayout template. Note, since we offer to register each layout template for\na specific view, you can always very selectiv this layout pattern. This means\nyou can use the defualt z3 macro based layout registration in combination with\nthis layout concept if you register a own layout template.\n\nThe simplest concept is calling the content from the view in the layout\ntemplate is to call it from a method. Let's define a view providing a layout\ntemplate and offer a method for call content.\n\n  >>> class IFullView(zope.interface.Interface):\n  ...     pass\n\n  >>> @zope.interface.implementer(IFullView)\n  ... class FullView(BrowserPage):\n  ...     layout = None\n  ...     def render(self):\n  ...         return u'rendered content'\n  ...     def __call__(self):\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter((self, self.request),\n  ...                 interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n  >>> completeView = FullView(root, request)\n\nNow define a layout for the view and register them:\n\n  >>> completeLayout = os.path.join(temp_dir, 'completeLayout.pt')\n  >>> with open(completeLayout, 'w') as file:\n  ...     _ = file.write('''\n  ...   <div tal:content=\"view/render\">\n  ...     Full layout\n  ...   </div>\n  ... ''')\n\n  >>> factory = TemplateFactory(completeLayout, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (IFullView, IDefaultBrowserLayer), interfaces.ILayoutTemplate)\n\nNow let's see if the layout template can call the content via calling render\non the view:\n\n  >>> print(completeView.__call__())\n  <div>rendered content</div>\n\n\nContent and Layout\n==================\n\nNow let's show how we combine this two templates in a real use case:\n\n  >>> class IDocumentView(zope.interface.Interface):\n  ...     pass\n\n  >>> @zope.interface.implementer(IDocumentView)\n  ... class DocumentView(BrowserPage):\n  ...     template = None\n  ...     layout = None\n  ...     attr = None\n  ...     def update(self):\n  ...         self.attr = u'content updated'\n  ...     def render(self):\n  ...         if self.template is None:\n  ...             template = zope.component.getMultiAdapter(\n  ...                 (self, self.request), IPageTemplate)\n  ...             return template(self)\n  ...         return self.template()\n  ...     def __call__(self):\n  ...         self.update()\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter((self, self.request),\n  ...                 interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n\nDefine and register a content template...\n\n  >>> template = os.path.join(temp_dir, 'template.pt')\n  >>> with open(template, 'w') as file:\n  ...     _ = file.write('''\n  ...   <div tal:content=\"view/attr\">\n  ...     here comes the value of attr\n  ...   </div>\n  ... ''')\n\n  >>> factory = TemplateFactory(template, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (IDocumentView, IDefaultBrowserLayer), IPageTemplate)\n\nand define and register a layout template:\n\n  >>> layout = os.path.join(temp_dir, 'layout.pt')\n  >>> with open(layout, 'w') as file:\n  ...     _ = file.write('''\n  ... <html>\n  ...   <body>\n  ...     <div tal:content=\"structure view/render\">\n  ...       here comes the rendered content\n  ...     </div>\n  ...   </body>\n  ... </html>\n  ... ''')\n\n  >>> factory = TemplateFactory(layout, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (IDocumentView, IDefaultBrowserLayer), interfaces.ILayoutTemplate)\n\nNow call the view and check the result:\n\n  >>> documentView = DocumentView(root, request)\n  >>> print(documentView())\n  <html>\n    <body>\n      <div>\n        <div>content updated</div>\n      </div>\n    </body>\n  </html>\n\n\nMacros\n======\n\nUse of macros.\n\n  >>> macroTemplate = os.path.join(temp_dir, 'macroTemplate.pt')\n  >>> with open(macroTemplate, 'w') as file:\n  ...     _ = file.write('''\n  ...   <metal:block define-macro=\"macro1\">\n  ...     <div>macro1</div>\n  ...   </metal:block>\n  ...   <metal:block define-macro=\"macro2\">\n  ...     <div>macro2</div>\n  ...     <div tal:content=\"options/div2\">the content of div 2</div>\n  ...   </metal:block>\n  ...   ''')\n\n  >>> factory = TemplateFactory(macroTemplate, 'text/html', 'macro1')\n  >>> print(factory(view, request)())\n  <div>macro1</div>\n  >>> m2factory = TemplateFactory(macroTemplate, 'text/html', 'macro2')\n  >>> print(m2factory(view, request)(div2=\"from the options\"))\n  <div>macro2</div>\n  <div>from the options</div>\n\n\nWhy didn't we use named templates from the ``zope.formlib`` package?\n\nWhile named templates allow us to separate the view code from the template\nregistration, they are not registrable for a particular layer making it\nimpossible to implement multiple skins using named templates.\n\n\nUse case ``simple template``\n============================\n\nAnd for the simplest possible use we provide a hook for call registered\ntemplates. Such page templates can get called with the getPageTemplate method\nand return a registered bound ViewTemplate a la ViewPageTemplateFile or\nNamedTemplate.\n\nThe getViewTemplate allows us to use the new template registration\nsystem with all existing implementations such as `zope.formlib` and\n`zope.viewlet`.\n\n  >>> from z3c.template.template import getPageTemplate\n  >>> class IUseOfViewTemplate(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IUseOfViewTemplate)\n  ... class UseOfViewTemplate(object):\n  ...\n  ...     template = getPageTemplate()\n  ...\n  ...     def __init__(self, context, request):\n  ...         self.context = context\n  ...         self.request = request\n\nBy defining the \"template\" property as a \"getPageTemplate\" a lookup for\na registered template is done when it is called.\n\n  >>> simple = UseOfViewTemplate(root, request)\n  >>> print(simple.template())\n  <div>demo content</div>\n\nBecause the demo template was registered for any (\"None\") interface we see the\ndemo template when rendering our new view. We register a new template\nespecially for the new view. Also note that the \"macroTemplate\" has been\ncreated earlier in this test.\n\n  >>> factory = TemplateFactory(contentTemplate, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (IUseOfViewTemplate, IDefaultBrowserLayer), IPageTemplate)\n  >>> print(simple.template())\n  <div>demo content</div>\n\n\nContext-specific templates\n==========================\n\nThe ``TemplateFactory`` can be also used for (view, request, context)\nlookup. It's useful when you want to override a template for specific\ncontent object or type.\n\nLet's define a sample content type and instantiate a view for it.\n\n  >>> class IContent(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IContent)\n  ... class Content(object):\n  ...     pass\n\n  >>> content = Content()\n  >>> view = UseOfViewTemplate(content, request)\n\nNow, let's provide a (view, request, context) adapter using TemplateFactory.\n\n  >>> contextTemplate = os.path.join(temp_dir, 'context.pt')\n  >>> with open(contextTemplate, 'w') as file:\n  ...     _ = file.write('<div>context-specific</div>')\n  >>> factory = TemplateFactory(contextTemplate, 'text/html')\n\n  >>> component.provideAdapter(factory,\n  ...     (IUseOfViewTemplate, IDefaultBrowserLayer, IContent),\n  ...     interfaces.IContentTemplate)\n\nFirst. Let's try to simply get it as a multi-adapter.\n\n  >>> template = zope.component.getMultiAdapter((view, request, content),\n  ...                 interfaces.IContentTemplate)\n  >>> print(template(view))\n  <div>context-specific</div>\n\nThe ``getPageTemplate`` and friends will try to lookup a context-specific\ntemplate before doing more generic (view, request) lookup, so our view\nshould already use our context-specific template:\n\n  >>> print(view.template())\n  <div>context-specific</div>\n\n\nUse case ``template by interface``\n==================================\n\nTemplates can also get registered on different interfaces then IPageTemplate\nor ILayoutTemplate.\n\n  >>> from z3c.template.template import getViewTemplate\n  >>> class IMyTemplate(zope.interface.Interface):\n  ...     \"\"\"My custom tempalte marker.\"\"\"\n\n  >>> factory = TemplateFactory(contentTemplate, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer), IMyTemplate)\n\nNow define a view using such a custom template registration:\n\n  >>> class IMyTemplateView(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IMyTemplateView)\n  ... class MyTemplateView(object):\n  ...\n  ...     template = getViewTemplate(IMyTemplate)\n  ...\n  ...     def __init__(self, context, request):\n  ...         self.context = context\n  ...         self.request = request\n\n  >>> myTempalteView = MyTemplateView(root, request)\n  >>> print(myTempalteView.template())\n  <div>demo content</div>\n\n\nUse case ``named template``\n===========================\n\nTemplates can also get registered on names. In this expample we use a named\ntemplate combined with a custom template marker interface.\n\n  >>> class IMyNamedTemplate(zope.interface.Interface):\n  ...     \"\"\"My custom template marker.\"\"\"\n\n  >>> factory = TemplateFactory(contentTemplate, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer), IMyNamedTemplate,\n  ...     name='my template')\n\nNow define a view using such a custom named template registration:\n\n  >>> class IMyNamedTemplateView(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IMyNamedTemplateView)\n  ... class MyNamedTemplateView(object):\n  ...\n  ...     template = getViewTemplate(IMyNamedTemplate, 'my template')\n  ...\n  ...     def __init__(self, context, request):\n  ...         self.context = context\n  ...         self.request = request\n\n  >>> myNamedTempalteView = MyNamedTemplateView(root, request)\n  >>> print(myNamedTempalteView.template())\n  <div>demo content</div>\n\n\nUse case ``named layout template``\n==================================\n\nWe can also register a new layout template by name and use it in a view:\n\n  >>> from z3c.template.template import getLayoutTemplate\n\n  >>> editLayout = os.path.join(temp_dir, 'editLayout.pt')\n  >>> with open(editLayout, 'w') as file:\n  ...     _ = file.write('''\n  ...   <div>Edit layout</div>\n  ...   <div tal:content=\"view/render\">content</div>\n  ... ''')\n  >>> factory = TemplateFactory(editLayout, 'text/html')\n  >>> component.provideAdapter(factory,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer),\n  ...      interfaces.ILayoutTemplate, name='edit')\n\nNow define a view using such a custom named template registration:\n\n  >>> class MyEditView(BrowserPage):\n  ...\n  ...     layout = getLayoutTemplate('edit')\n  ...\n  ...     def render(self):\n  ...         return u'edit content'\n  ...\n  ...     def __call__(self):\n  ...         if self.layout is None:\n  ...             layout = zope.component.getMultiAdapter((self, self.request),\n  ...                 interfaces.ILayoutTemplate)\n  ...             return layout(self)\n  ...         return self.layout()\n\n  >>> myEditView = MyEditView(root, request)\n  >>> print(myEditView())\n  <div>Edit layout</div>\n  <div>edit content</div>\n\n\nCleanup\n=======\n\n  >>> import shutil\n  >>> shutil.rmtree(temp_dir)\n\n\nPagelet\n=======\n\nSee ``z3c.pagelet`` for another template based layout generating implementation.\n\n====================\n Template directive\n====================\n\nShow how we can use the template directive. Register the meta configuration for\nthe directive.\n\n  >>> import sys\n  >>> from zope.configuration import xmlconfig\n  >>> import z3c.template\n  >>> context = xmlconfig.file('meta.zcml', z3c.template)\n\n\nPageTemplate\n============\n\nWe need a custom content template\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n  >>> content_file = os.path.join(temp_dir, 'content.pt')\n  >>> with open(content_file, 'w') as file:\n  ...     _ = file.write('''<div>content</div>''')\n\nand a interface\n\n  >>> import zope.interface\n  >>> class IView(zope.interface.Interface):\n  ...     \"\"\"Marker interface\"\"\"\n\nand a view class:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> @zope.interface.implementer(IView)\n  ... class View(object):\n  ...     def __init__(self, context, request):\n  ...         self.context = context\n  ...         self.request = request\n  >>> request = TestRequest()\n  >>> view = View(object(), request)\n\nMake them available under the fake package ``custom``:\n\n  >>> sys.modules['custom'] = type(\n  ...     'Module', (),\n  ...     {'IView': IView})()\n\nand register them as a template within the ``z3c:template`` directive:\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % content_file, context=context)\n\nLet's get the template\n\n  >>> import zope.component\n  >>> from z3c.template.interfaces import IContentTemplate\n  >>> template = zope.component.queryMultiAdapter(\n  ...     (view, request),\n  ...     interface=IContentTemplate)\n\nand check them:\n\n  >>> from z3c.template.template import ViewPageTemplateFile\n  >>> isinstance(template, ViewPageTemplateFile)\n  True\n  >>> isinstance(template.content_type, str)\n  True\n\n  >>> print(template(view))\n  <div>content</div>\n\nErrors\n------\n\nIf we try to use a path to a template that does not exist, we\nget an error:\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       template=\"this_file_does_not_exist\"\n  ...       for=\"custom.IView\"\n  ...       />\n  ... </configure>\n  ... \"\"\", context=context)\n  Traceback (most recent call last):\n  ...\n  ConfigurationError: ('No such file', '...this_file_does_not_exist')\n  File \"<string>\", line 4.2-7.8\n\nLayout template\n===============\n\nDefine a layout template\n\n  >>> layout_file = os.path.join(temp_dir, 'layout.pt')\n  >>> with open(layout_file, 'w') as file:\n  ...     _ = file.write('''<div>layout</div>''')\n\nand register them as a layout template within the ``z3c:layout`` directive:\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:layout\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % layout_file, context=context)\n\nLet's get the template\n\n  >>> from z3c.template.interfaces import ILayoutTemplate\n  >>> layout = zope.component.queryMultiAdapter((view, request),\n  ...     interface=ILayoutTemplate)\n\nand check them:\n\n  >>> isinstance(layout, ViewPageTemplateFile)\n  True\n  >>> isinstance(layout.content_type, str)\n  True\n\n  >>> print(layout(view))\n  <div>layout</div>\n\n\nContext-specific template\n=========================\n\nMost of views have some object as their context and it's ofter very\nuseful to be able register context-specific template. We can do that\nusing the ``context`` argument of the ZCML directive.\n\nLet's define some content type:\n\n  >>> class IContent(zope.interface.Interface):\n  ...     pass\n  >>> @zope.interface.implementer(IContent)\n  ... class Content(object):\n  ...     pass\n\n  >>> sys.modules['custom'].IContent = IContent\n\nNow, we can register a template for this class. Let's create one and\nregister:\n\n  >>> context_file = os.path.join(temp_dir, 'context.pt')\n  >>> with open(context_file, 'w') as file:\n  ...     _ = file.write('''<div>i'm context-specific</div>''')\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       context=\"custom.IContent\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % context_file, context=context)\n\nWe can now lookup it using the (view, request, context) discriminator:\n\n  >>> content = Content()\n  >>> view = View(content, request)\n\n  >>> template = zope.component.queryMultiAdapter((view, request, content),\n  ...     interface=IContentTemplate)\n\n  >>> print(template(view))\n  <div>i'm context-specific</div>\n\nThe same will work with layout registration directive:\n\n  >>> context_layout_file = os.path.join(temp_dir, 'context_layout.pt')\n  >>> with open(context_layout_file, 'w') as file:\n  ...     _ = file.write('''<div>context-specific layout</div>''')\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:layout\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       context=\"custom.IContent\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % context_layout_file, context=context)\n\n  >>> layout = zope.component.queryMultiAdapter((view, request, content),\n  ...     interface=ILayoutTemplate)\n\n  >>> print(layout(view))\n  <div>context-specific layout</div>\n\n\nNamed template\n==============\n\nIts possible to register template by name. Let us register a pagelet with the\nname edit:\n\n  >>> editTemplate = os.path.join(temp_dir, 'edit.pt')\n  >>> with open(editTemplate, 'w') as file:\n  ...     _ = file.write('''<div>edit</div>''')\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       name=\"edit\"\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % editTemplate, context=context)\n\nAnd call it:\n\n  >>> from z3c.template.interfaces import ILayoutTemplate\n  >>> template = zope.component.queryMultiAdapter(\n  ...     (view, request),\n  ...     interface=IContentTemplate, name='edit')\n\n  >>> print(template(view))\n  <div>edit</div>\n\n\nCustom template\n===============\n\nOr you can define own interfaces and register templates for them:\n\n  >>> from zope.pagetemplate.interfaces import IPageTemplate\n  >>> class IMyTemplate(IPageTemplate):\n  ...     \"\"\"My template\"\"\"\n\nMake the template interface available as a custom module class.\n\n  >>> sys.modules['custom'].IMyTemplate = IMyTemplate\n\nDfine a new template\n\n  >>> interfaceTemplate = os.path.join(temp_dir, 'interface.pt')\n  >>> with open(interfaceTemplate, 'w') as file:\n  ...     _ = file.write('''<div>interface</div>''')\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:template\n  ...       template=\"%s\"\n  ...       for=\"custom.IView\"\n  ...       provides=\"custom.IMyTemplate\"\n  ...       />\n  ... </configure>\n  ... \"\"\" % interfaceTemplate, context=context)\n\nLet's see if we get the template by the new interface:\n\n  >>> from z3c.template.interfaces import ILayoutTemplate\n  >>> template = zope.component.queryMultiAdapter((view, request),\n  ...     interface=IMyTemplate,)\n\n  >>> print(template(view))\n  <div>interface</div>\n\n\nCleanup\n=======\n\nNow we need to clean up the custom module.\n\n  >>> del sys.modules['custom']\n\n=========\n CHANGES\n=========\n\n3.1.0 (2019-02-05)\n==================\n\n- Adapt tests to `zope.configuration >= 4.2`.\n- Add support for Python 3.7.\n\n\n3.0.0 (2017-10-18)\n==================\n\n- Add support for PyPy.\n- Add support for Python 3.4, 3.5 and 3.6.\n- Drop support for Python 2.6 and 3.3.\n- Make bound page templates have ``__self__`` and ``__func__``\n  attributes to be more like Python 3 bound methods. (``im_func`` and\n  ``im_self`` remain available.) See `issue 3\n  <https://github.com/zopefoundation/z3c.template/issues/3>`_.\n- Depend on Chameleon >= 3.0, z3c.pt >= 2.1 and z3c.ptcompat >= 2.1.0\n  due to possible rendering issues. See `PR 2\n  <https://github.com/zopefoundation/z3c.template/pull/2>`_.\n\n2.0.0 (2015-11-09)\n==================\n\n- Standardize namespace ``__init__``\n\n\n2.0.0a2 (2013-02-25)\n====================\n\n- Make sure the of the templates content type is a native string instead\n  forced bytes.\n\n\n2.0.0a1 (2013-02-22)\n====================\n\n- Added support for Python 3.3.\n\n- Replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Dropped support for Python 2.4 and 2.5.\n\n\n1.4.1 (2012-02-15)\n==================\n\n- Remove hooks to use ViewPageTemplateFile from z3c.pt because this breaks when\n  z3c.pt is available, but z3c.ptcompat is not included. As recommended by notes\n  below.\n\n\n1.4.0 (2011-10-29)\n==================\n\n- Moved z3c.pt include to extras_require chameleon. This makes the package\n  independent from chameleon and friends and allows to include this\n  dependencies in your own project.\n\n- Upgrade to chameleon 2.0 template engine and use the newest z3c.pt and\n  z3c.ptcompat packages adjusted to work with chameleon 2.0.\n\n  See the notes from the z3c.ptcompat package:\n\n  Update z3c.ptcompat implementation to use component-based template engine\n  configuration, plugging directly into the Zope Toolkit framework.\n\n  The z3c.ptcompat package no longer provides template classes, or ZCML\n  directives; you should import directly from the ZTK codebase.\n\n  Note that the ``PREFER_Z3C_PT`` environment option has been\n  rendered obsolete; instead, this is now managed via component\n  configuration.\n\n  Also note that the chameleon CHAMELEON_CACHE environment value changed from\n  True/False to a path. Skip this property if you don't like to use a cache.\n  None or False defined in buildout environment section doesn't work. At least\n  with chameleon <= 2.5.4\n\n  Attention: You need to include the configure.zcml file from z3c.ptcompat\n  for enable the z3c.pt template engine. The configure.zcml will plugin the\n  template engine. Also remove any custom built hooks which will import\n  z3c.ptcompat in your tests or other places.\n\n\n1.3.0 (2011-10-28)\n==================\n\n- Update to z3c.ptcompat 1.0 (and as a result, to the z3c.pt 2.x series).\n\n- Using Python's ``doctest`` module instead of depreacted\n  ``zope.testing.doctest``.\n\n\n1.2.1 (2009-08-22)\n==================\n\n* Corrected description of ``ITemplateDirective.name``.\n\n* Added `zcml.txt` to ``long_description`` to show up on pypi.\n\n* Removed zpkg helper files and zcml slugs.\n\n\n1.2.0 (2009-02-26)\n==================\n\n* Add support for context-specific templates. Now, templates can be\n  registered and looked up using (view, request, context) triple.\n  To do that, pass the ``context`` argument to the ZCML directives.\n  The ``getPageTemplate`` and friends will now try to lookup context\n  specific template first and then fall back to (view, request) lookup.\n\n* Allow use of ``z3c.pt`` using ``z3c.ptcompat`` compatibility layer.\n\n* Forward the template kwargs to the options of the macro\n\n* Changed package's mailing list address to zope-dev at zope.org\n  instead of retired one.\n\n1.1.0 (2007-10-08)\n==================\n\n* Added an ``IContentTemplate`` interface which is used for\n  ``<z3c:template>``.\n\n1.0.0 (2007-??-??)\n==================\n\n* Initial release.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/zopefoundation/z3c.template", "keywords": "zope3 template layout zpt pagetemplate", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "z3c.template", "package_url": "https://pypi.org/project/z3c.template/", "platform": "", "project_url": "https://pypi.org/project/z3c.template/", "project_urls": {"Homepage": "https://github.com/zopefoundation/z3c.template"}, "release_url": "https://pypi.org/project/z3c.template/3.1.0/", "requires_dist": ["setuptools", "zope.browserpage", "zope.component", "zope.configuration (>=4.2.0)", "zope.interface", "zope.pagetemplate", "zope.publisher", "zope.schema", "chameleon (>=3.0); extra == 'chameleon'", "z3c.pt (>=3.1.0); extra == 'chameleon'", "z3c.ptcompat (>=2.1.0); extra == 'chameleon'", "chameleon (>=3.0); extra == 'test'", "z3c.pt (>=3.1.0); extra == 'test'", "z3c.ptcompat (>=2.1.0); extra == 'test'", "zope.testing; extra == 'test'", "zope.testrunner; extra == 'test'", "zope.traversing; extra == 'test'"], "requires_python": "", "summary": "A package implementing advanced Page Template patterns.", "version": "3.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"z3c-template\">\n<h2><a href=\"#id13\" rel=\"nofollow\">z3c.template</a></h2>\n<a href=\"https://pypi.python.org/pypi/z3c.template/\" rel=\"nofollow\"><img alt=\"Latest release\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3c17f79804f3fdebc53bc3fbef57396e0c9e24e3/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7a33632e74656d706c6174652e737667\"></a>\n<a href=\"https://pypi.org/project/z3c.template/\" rel=\"nofollow\"><img alt=\"Supported Python versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/377c1d3a769cd52e5c6c01b517fd89c28aa10c20/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f7a33632e74656d706c6174652e737667\"></a>\n<a href=\"https://travis-ci.org/zopefoundation/z3c.template\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/zopefoundation/z3c.template.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ee52b2ff1f3c2cdbe7525207c82b0b41d3574b95/68747470733a2f2f7472617669732d63692e6f72672f7a6f7065666f756e646174696f6e2f7a33632e74656d706c6174652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/zopefoundation/z3c.template?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/zopefoundation/z3c.template/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8e91ea477d8997c6b02c8e1872c221437dda7436/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f7a6f7065666f756e646174696f6e2f7a33632e74656d706c6174652f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<p>This package allows you to register templates independently from view code.</p>\n<p>In Zope 3, when registering a <tt>browser:page</tt> both presentation and computation\nare registered together. Unfortunately the registration tangles presentation\nand computation so tightly that it is not possible to re-register a different\ntemplate depending on context. (You can override the whole registration but\nthis is not the main point of this package.)</p>\n<p>With z3c.template the registration is split up between the view and the\ntemplate and allows to differentiate the template based on the skin layer and\nthe view.</p>\n<p>In addition this package lays the foundation to differentiate between\ntemplates that provide specific presentation templates and generic layout\ntemplates.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#z3c-template\" id=\"id13\" rel=\"nofollow\">z3c.template</a></li>\n<li><a href=\"#z3c-templates\" id=\"id14\" rel=\"nofollow\">Z3C Templates</a><ul>\n<li><a href=\"#content-template\" id=\"id15\" rel=\"nofollow\">Content template</a></li>\n<li><a href=\"#layout-template\" id=\"id16\" rel=\"nofollow\">Layout template</a></li>\n<li><a href=\"#content-and-layout\" id=\"id17\" rel=\"nofollow\">Content and Layout</a></li>\n<li><a href=\"#macros\" id=\"id18\" rel=\"nofollow\">Macros</a></li>\n<li><a href=\"#use-case-simple-template\" id=\"id19\" rel=\"nofollow\">Use case <tt>simple template</tt></a></li>\n<li><a href=\"#context-specific-templates\" id=\"id20\" rel=\"nofollow\">Context-specific templates</a></li>\n<li><a href=\"#use-case-template-by-interface\" id=\"id21\" rel=\"nofollow\">Use case <tt>template by interface</tt></a></li>\n<li><a href=\"#use-case-named-template\" id=\"id22\" rel=\"nofollow\">Use case <tt>named template</tt></a></li>\n<li><a href=\"#use-case-named-layout-template\" id=\"id23\" rel=\"nofollow\">Use case <tt>named layout template</tt></a></li>\n<li><a href=\"#cleanup\" id=\"id24\" rel=\"nofollow\">Cleanup</a></li>\n<li><a href=\"#pagelet\" id=\"id25\" rel=\"nofollow\">Pagelet</a></li>\n</ul>\n</li>\n<li><a href=\"#template-directive\" id=\"id26\" rel=\"nofollow\">Template directive</a><ul>\n<li><a href=\"#pagetemplate\" id=\"id27\" rel=\"nofollow\">PageTemplate</a><ul>\n<li><a href=\"#errors\" id=\"id28\" rel=\"nofollow\">Errors</a></li>\n</ul>\n</li>\n<li><a href=\"#id1\" id=\"id29\" rel=\"nofollow\">Layout template</a></li>\n<li><a href=\"#context-specific-template\" id=\"id30\" rel=\"nofollow\">Context-specific template</a></li>\n<li><a href=\"#named-template\" id=\"id31\" rel=\"nofollow\">Named template</a></li>\n<li><a href=\"#custom-template\" id=\"id32\" rel=\"nofollow\">Custom template</a></li>\n<li><a href=\"#id2\" id=\"id33\" rel=\"nofollow\">Cleanup</a></li>\n</ul>\n</li>\n<li><a href=\"#changes\" id=\"id34\" rel=\"nofollow\">CHANGES</a><ul>\n<li><a href=\"#id3\" id=\"id35\" rel=\"nofollow\">3.1.0 (2019-02-05)</a></li>\n<li><a href=\"#id4\" id=\"id36\" rel=\"nofollow\">3.0.0 (2017-10-18)</a></li>\n<li><a href=\"#id5\" id=\"id37\" rel=\"nofollow\">2.0.0 (2015-11-09)</a></li>\n<li><a href=\"#a2-2013-02-25\" id=\"id38\" rel=\"nofollow\">2.0.0a2 (2013-02-25)</a></li>\n<li><a href=\"#a1-2013-02-22\" id=\"id39\" rel=\"nofollow\">2.0.0a1 (2013-02-22)</a></li>\n<li><a href=\"#id6\" id=\"id40\" rel=\"nofollow\">1.4.1 (2012-02-15)</a></li>\n<li><a href=\"#id7\" id=\"id41\" rel=\"nofollow\">1.4.0 (2011-10-29)</a></li>\n<li><a href=\"#id8\" id=\"id42\" rel=\"nofollow\">1.3.0 (2011-10-28)</a></li>\n<li><a href=\"#id9\" id=\"id43\" rel=\"nofollow\">1.2.1 (2009-08-22)</a></li>\n<li><a href=\"#id10\" id=\"id44\" rel=\"nofollow\">1.2.0 (2009-02-26)</a></li>\n<li><a href=\"#id11\" id=\"id45\" rel=\"nofollow\">1.1.0 (2007-10-08)</a></li>\n<li><a href=\"#id12\" id=\"id46\" rel=\"nofollow\">1.0.0 (2007-??-??)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"z3c-templates\">\n<h2><a href=\"#id14\" rel=\"nofollow\">Z3C Templates</a></h2>\n<p>This package allows us to separate the registration of the view code and the\nlayout.</p>\n<p>A template is used for separate the HTML part from a view. This is done in\nz3 via a page templates. Such page template are implemented in the view,\nregistered included in a page directive etc. But they do not use the adapter\npattern which makes it hard to replace existing templates.</p>\n<p>Another part of template is, that they normaly separate one part presenting\ncontent from a view and another part offer a layout used by the content\ntemplate.</p>\n<p>How can this package make it simpler to use templates?</p>\n<p>Templates can be registered as adapters adapting context, request where the\ncontext is a view implementation. Such a template get adapted from the view\nif the template is needed. This adaption makes it very pluggable and modular.</p>\n<p>We offer two base template directive for register content producing templates\nand layout producing tempaltes. This is most the time enough but you also\ncan register different type of templates using a specific interface. This\ncould be usefull if your view implementation needs to separate HTMl in\nmore then one template. Now let\u2019s take a look how we an use this templates.</p>\n<div id=\"content-template\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Content template</a></h3>\n<p>First let\u2019s show how we use a template for produce content from a view:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os, tempfile\n&gt;&gt;&gt; temp_dir = tempfile.mkdtemp()\n&gt;&gt;&gt; contentTemplate = os.path.join(temp_dir, 'contentTemplate.pt')\n&gt;&gt;&gt; with open(contentTemplate, 'w') as file:\n...     _ = file.write('&lt;div&gt;demo content&lt;/div&gt;')\n</pre>\n</blockquote>\n<p>And register a view class implementing a interface:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; from z3c.template import interfaces\n&gt;&gt;&gt; from zope.pagetemplate.interfaces import IPageTemplate\n&gt;&gt;&gt; from zope.publisher.browser import BrowserPage\n</pre>\n<pre>&gt;&gt;&gt; class IMyView(zope.interface.Interface):\n...     pass\n&gt;&gt;&gt; @zope.interface.implementer(IMyView)\n... class MyView(BrowserPage):\n...     template = None\n...     def render(self):\n...         if self.template is None:\n...             template = zope.component.getMultiAdapter(\n...                 (self, self.request), interfaces.IContentTemplate)\n...             return template(self)\n...         return self.template()\n</pre>\n</blockquote>\n<p>Let\u2019s call the view and check the output:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; view = MyView(root, request)\n</pre>\n</blockquote>\n<p>Since the template is not yet registered, rendering the view will fail:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(view.render())\nTraceback (most recent call last):\n...\nzope.interface.interfaces.ComponentLookupError: ......\n</pre>\n</blockquote>\n<p>Let\u2019s now register the template (commonly done using ZCML):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope import component\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n&gt;&gt;&gt; from z3c.template.template import TemplateFactory\n</pre>\n</blockquote>\n<p>The template factory allows us to create a ViewPageTeplateFile instance.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(contentTemplate, 'text/html')\n&gt;&gt;&gt; factory\n&lt;z3c.template.template.TemplateFactory object at ...&gt;\n</pre>\n</blockquote>\n<p>We register the factory on a view interface and a layer.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; component.provideAdapter(\n...     factory,\n...     (zope.interface.Interface, IDefaultBrowserLayer),\n...     interfaces.IContentTemplate)\n&gt;&gt;&gt; template = component.getMultiAdapter((view, request),\n...     interfaces.IPageTemplate)\n</pre>\n<pre>&gt;&gt;&gt; template\n&lt;...ViewPageTemplateFile...&gt;\n</pre>\n</blockquote>\n<p>Now that we have a registered layout template for the default layer we can\ncall our view again.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(view.render())\n&lt;div&gt;demo content&lt;/div&gt;\n</pre>\n</blockquote>\n<p>Now we register a new template on the specific interface of our view.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; myTemplate = os.path.join(temp_dir, 'myTemplate.pt')\n&gt;&gt;&gt; with open(myTemplate, 'w') as file:\n...     _ = file.write('&lt;div&gt;My content&lt;/div&gt;')\n&gt;&gt;&gt; factory = TemplateFactory(myTemplate, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(\n...     factory,\n...     (IMyView, IDefaultBrowserLayer), interfaces.IContentTemplate)\n&gt;&gt;&gt; print(view.render())\n&lt;div&gt;My content&lt;/div&gt;\n</pre>\n</blockquote>\n<p>It is possible to provide the template directly.</p>\n<p>We create a new template.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; viewContent = os.path.join(temp_dir, 'viewContent.pt')\n&gt;&gt;&gt; with open(viewContent, 'w') as file:\n...     _ = file.write('&lt;div&gt;view content&lt;/div&gt;')\n</pre>\n</blockquote>\n<p>and a view:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.template import ViewPageTemplateFile\n&gt;&gt;&gt; @zope.interface.implementer(IMyView)\n... class MyViewWithTemplate(BrowserPage):\n...     template = ViewPageTemplateFile(viewContent)\n...     def render(self):\n...         if self.template is None:\n...             template = zope.component.getMultiAdapter(\n...                 (self, self.request), interfaces.IContentTemplate)\n...             return template(self)\n...         return self.template()\n&gt;&gt;&gt; contentView = MyViewWithTemplate(root, request)\n</pre>\n</blockquote>\n<p>If we render this view we get the implemented layout template and not the\nregistered one.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(contentView.render())\n&lt;div&gt;view content&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"layout-template\">\n<h3><a href=\"#id16\" rel=\"nofollow\">Layout template</a></h3>\n<p>First we nee to register a new view class calling a layout template. Note,\nthat this view uses the __call__ method for invoke a layout template:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class ILayoutView(zope.interface.Interface):\n...     pass\n&gt;&gt;&gt; @zope.interface.implementer(ILayoutView)\n... class LayoutView(BrowserPage):\n...     layout = None\n...     def __call__(self):\n...         if self.layout is None:\n...             layout = zope.component.getMultiAdapter(\n...                 (self, self.request), interfaces.ILayoutTemplate)\n...             return layout(self)\n...         return self.layout()\n&gt;&gt;&gt; view2 = LayoutView(root, request)\n</pre>\n</blockquote>\n<p>Define and register a new layout template:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; layoutTemplate = os.path.join(temp_dir, 'layoutTemplate.pt')\n&gt;&gt;&gt; with open(layoutTemplate, 'w') as file:\n...     _ = file.write('&lt;div&gt;demo layout&lt;/div&gt;')\n&gt;&gt;&gt; factory = TemplateFactory(layoutTemplate, 'text/html')\n</pre>\n</blockquote>\n<p>We register the template factory on a view interface and a layer providing the\nILayoutTemplate interface.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; component.provideAdapter(factory,\n...     (zope.interface.Interface, IDefaultBrowserLayer),\n...      interfaces.ILayoutTemplate)\n&gt;&gt;&gt; layout = component.getMultiAdapter(\n...     (view2, request), interfaces.ILayoutTemplate)\n</pre>\n<pre>&gt;&gt;&gt; layout\n&lt;...ViewPageTemplateFile...&gt;\n</pre>\n</blockquote>\n<p>Now that we have a registered layout template for the default layer we can\ncall our view again.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(view2())\n&lt;div&gt;demo layout&lt;/div&gt;\n</pre>\n</blockquote>\n<p>Now we register a new layout template on the specific interface of our view.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; myLayout = os.path.join(temp_dir, 'myLayout.pt')\n&gt;&gt;&gt; with open(myLayout, 'w') as file:\n...     _ = file.write('&lt;div&gt;My layout&lt;/div&gt;')\n&gt;&gt;&gt; factory = TemplateFactory(myLayout, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(factory,\n...     (ILayoutView, IDefaultBrowserLayer),\n...      interfaces.ILayoutTemplate)\n&gt;&gt;&gt; print(view2())\n&lt;div&gt;My layout&lt;/div&gt;\n</pre>\n</blockquote>\n<p>It is possible to provide the layout template directly.</p>\n<p>We create a new template.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; viewLayout = os.path.join(temp_dir, 'viewLayout.pt')\n&gt;&gt;&gt; with open(viewLayout, 'w') as file:\n...     _ = file.write('''&lt;div&gt;view layout&lt;/div&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(ILayoutView)\n... class LayoutViewWithLayoutTemplate(BrowserPage):\n...     layout = ViewPageTemplateFile(viewLayout)\n...     def __call__(self):\n...         if self.layout is None:\n...             layout = zope.component.getMultiAdapter((self, self.request),\n...                 interfaces.ILayoutTemplate)\n...             return layout(self)\n...         return self.layout()\n&gt;&gt;&gt; layoutView = LayoutViewWithLayoutTemplate(root, request)\n</pre>\n</blockquote>\n<p>If we render this view we get the implemented layout template and not the\nregistered one.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(layoutView())\n&lt;div&gt;view layout&lt;/div&gt;\n</pre>\n</blockquote>\n<p>Since we return the layout template in the sample views above, how can we get\nthe content from the used view? This is not directly a part of this package\nbut let\u2019s show some pattern were can be used for render content in a used\nlayout template. Note, since we offer to register each layout template for\na specific view, you can always very selectiv this layout pattern. This means\nyou can use the defualt z3 macro based layout registration in combination with\nthis layout concept if you register a own layout template.</p>\n<p>The simplest concept is calling the content from the view in the layout\ntemplate is to call it from a method. Let\u2019s define a view providing a layout\ntemplate and offer a method for call content.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IFullView(zope.interface.Interface):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IFullView)\n... class FullView(BrowserPage):\n...     layout = None\n...     def render(self):\n...         return u'rendered content'\n...     def __call__(self):\n...         if self.layout is None:\n...             layout = zope.component.getMultiAdapter((self, self.request),\n...                 interfaces.ILayoutTemplate)\n...             return layout(self)\n...         return self.layout()\n&gt;&gt;&gt; completeView = FullView(root, request)\n</pre>\n</blockquote>\n<p>Now define a layout for the view and register them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; completeLayout = os.path.join(temp_dir, 'completeLayout.pt')\n&gt;&gt;&gt; with open(completeLayout, 'w') as file:\n...     _ = file.write('''\n...   &lt;div tal:content=\"view/render\"&gt;\n...     Full layout\n...   &lt;/div&gt;\n... ''')\n</pre>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(completeLayout, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(factory,\n...     (IFullView, IDefaultBrowserLayer), interfaces.ILayoutTemplate)\n</pre>\n</blockquote>\n<p>Now let\u2019s see if the layout template can call the content via calling render\non the view:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(completeView.__call__())\n&lt;div&gt;rendered content&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"content-and-layout\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Content and Layout</a></h3>\n<p>Now let\u2019s show how we combine this two templates in a real use case:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IDocumentView(zope.interface.Interface):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IDocumentView)\n... class DocumentView(BrowserPage):\n...     template = None\n...     layout = None\n...     attr = None\n...     def update(self):\n...         self.attr = u'content updated'\n...     def render(self):\n...         if self.template is None:\n...             template = zope.component.getMultiAdapter(\n...                 (self, self.request), IPageTemplate)\n...             return template(self)\n...         return self.template()\n...     def __call__(self):\n...         self.update()\n...         if self.layout is None:\n...             layout = zope.component.getMultiAdapter((self, self.request),\n...                 interfaces.ILayoutTemplate)\n...             return layout(self)\n...         return self.layout()\n</pre>\n</blockquote>\n<p>Define and register a content template\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; template = os.path.join(temp_dir, 'template.pt')\n&gt;&gt;&gt; with open(template, 'w') as file:\n...     _ = file.write('''\n...   &lt;div tal:content=\"view/attr\"&gt;\n...     here comes the value of attr\n...   &lt;/div&gt;\n... ''')\n</pre>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(template, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(factory,\n...     (IDocumentView, IDefaultBrowserLayer), IPageTemplate)\n</pre>\n</blockquote>\n<p>and define and register a layout template:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; layout = os.path.join(temp_dir, 'layout.pt')\n&gt;&gt;&gt; with open(layout, 'w') as file:\n...     _ = file.write('''\n... &lt;html&gt;\n...   &lt;body&gt;\n...     &lt;div tal:content=\"structure view/render\"&gt;\n...       here comes the rendered content\n...     &lt;/div&gt;\n...   &lt;/body&gt;\n... &lt;/html&gt;\n... ''')\n</pre>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(layout, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(factory,\n...     (IDocumentView, IDefaultBrowserLayer), interfaces.ILayoutTemplate)\n</pre>\n</blockquote>\n<p>Now call the view and check the result:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; documentView = DocumentView(root, request)\n&gt;&gt;&gt; print(documentView())\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;div&gt;\n      &lt;div&gt;content updated&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"macros\">\n<h3><a href=\"#id18\" rel=\"nofollow\">Macros</a></h3>\n<p>Use of macros.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; macroTemplate = os.path.join(temp_dir, 'macroTemplate.pt')\n&gt;&gt;&gt; with open(macroTemplate, 'w') as file:\n...     _ = file.write('''\n...   &lt;metal:block define-macro=\"macro1\"&gt;\n...     &lt;div&gt;macro1&lt;/div&gt;\n...   &lt;/metal:block&gt;\n...   &lt;metal:block define-macro=\"macro2\"&gt;\n...     &lt;div&gt;macro2&lt;/div&gt;\n...     &lt;div tal:content=\"options/div2\"&gt;the content of div 2&lt;/div&gt;\n...   &lt;/metal:block&gt;\n...   ''')\n</pre>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(macroTemplate, 'text/html', 'macro1')\n&gt;&gt;&gt; print(factory(view, request)())\n&lt;div&gt;macro1&lt;/div&gt;\n&gt;&gt;&gt; m2factory = TemplateFactory(macroTemplate, 'text/html', 'macro2')\n&gt;&gt;&gt; print(m2factory(view, request)(div2=\"from the options\"))\n&lt;div&gt;macro2&lt;/div&gt;\n&lt;div&gt;from the options&lt;/div&gt;\n</pre>\n</blockquote>\n<p>Why didn\u2019t we use named templates from the <tt>zope.formlib</tt> package?</p>\n<p>While named templates allow us to separate the view code from the template\nregistration, they are not registrable for a particular layer making it\nimpossible to implement multiple skins using named templates.</p>\n</div>\n<div id=\"use-case-simple-template\">\n<h3><a href=\"#id19\" rel=\"nofollow\">Use case <tt>simple template</tt></a></h3>\n<p>And for the simplest possible use we provide a hook for call registered\ntemplates. Such page templates can get called with the getPageTemplate method\nand return a registered bound ViewTemplate a la ViewPageTemplateFile or\nNamedTemplate.</p>\n<p>The getViewTemplate allows us to use the new template registration\nsystem with all existing implementations such as <cite>zope.formlib</cite> and\n<cite>zope.viewlet</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.template.template import getPageTemplate\n&gt;&gt;&gt; class IUseOfViewTemplate(zope.interface.Interface):\n...     pass\n&gt;&gt;&gt; @zope.interface.implementer(IUseOfViewTemplate)\n... class UseOfViewTemplate(object):\n...\n...     template = getPageTemplate()\n...\n...     def __init__(self, context, request):\n...         self.context = context\n...         self.request = request\n</pre>\n</blockquote>\n<p>By defining the \u201ctemplate\u201d property as a \u201cgetPageTemplate\u201d a lookup for\na registered template is done when it is called.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; simple = UseOfViewTemplate(root, request)\n&gt;&gt;&gt; print(simple.template())\n&lt;div&gt;demo content&lt;/div&gt;\n</pre>\n</blockquote>\n<p>Because the demo template was registered for any (\u201cNone\u201d) interface we see the\ndemo template when rendering our new view. We register a new template\nespecially for the new view. Also note that the \u201cmacroTemplate\u201d has been\ncreated earlier in this test.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(contentTemplate, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(factory,\n...     (IUseOfViewTemplate, IDefaultBrowserLayer), IPageTemplate)\n&gt;&gt;&gt; print(simple.template())\n&lt;div&gt;demo content&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"context-specific-templates\">\n<h3><a href=\"#id20\" rel=\"nofollow\">Context-specific templates</a></h3>\n<p>The <tt>TemplateFactory</tt> can be also used for (view, request, context)\nlookup. It\u2019s useful when you want to override a template for specific\ncontent object or type.</p>\n<p>Let\u2019s define a sample content type and instantiate a view for it.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IContent(zope.interface.Interface):\n...     pass\n&gt;&gt;&gt; @zope.interface.implementer(IContent)\n... class Content(object):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; content = Content()\n&gt;&gt;&gt; view = UseOfViewTemplate(content, request)\n</pre>\n</blockquote>\n<p>Now, let\u2019s provide a (view, request, context) adapter using TemplateFactory.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; contextTemplate = os.path.join(temp_dir, 'context.pt')\n&gt;&gt;&gt; with open(contextTemplate, 'w') as file:\n...     _ = file.write('&lt;div&gt;context-specific&lt;/div&gt;')\n&gt;&gt;&gt; factory = TemplateFactory(contextTemplate, 'text/html')\n</pre>\n<pre>&gt;&gt;&gt; component.provideAdapter(factory,\n...     (IUseOfViewTemplate, IDefaultBrowserLayer, IContent),\n...     interfaces.IContentTemplate)\n</pre>\n</blockquote>\n<p>First. Let\u2019s try to simply get it as a multi-adapter.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; template = zope.component.getMultiAdapter((view, request, content),\n...                 interfaces.IContentTemplate)\n&gt;&gt;&gt; print(template(view))\n&lt;div&gt;context-specific&lt;/div&gt;\n</pre>\n</blockquote>\n<p>The <tt>getPageTemplate</tt> and friends will try to lookup a context-specific\ntemplate before doing more generic (view, request) lookup, so our view\nshould already use our context-specific template:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(view.template())\n&lt;div&gt;context-specific&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"use-case-template-by-interface\">\n<h3><a href=\"#id21\" rel=\"nofollow\">Use case <tt>template by interface</tt></a></h3>\n<p>Templates can also get registered on different interfaces then IPageTemplate\nor ILayoutTemplate.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.template.template import getViewTemplate\n&gt;&gt;&gt; class IMyTemplate(zope.interface.Interface):\n...     \"\"\"My custom tempalte marker.\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(contentTemplate, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(factory,\n...     (zope.interface.Interface, IDefaultBrowserLayer), IMyTemplate)\n</pre>\n</blockquote>\n<p>Now define a view using such a custom template registration:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IMyTemplateView(zope.interface.Interface):\n...     pass\n&gt;&gt;&gt; @zope.interface.implementer(IMyTemplateView)\n... class MyTemplateView(object):\n...\n...     template = getViewTemplate(IMyTemplate)\n...\n...     def __init__(self, context, request):\n...         self.context = context\n...         self.request = request\n</pre>\n<pre>&gt;&gt;&gt; myTempalteView = MyTemplateView(root, request)\n&gt;&gt;&gt; print(myTempalteView.template())\n&lt;div&gt;demo content&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"use-case-named-template\">\n<h3><a href=\"#id22\" rel=\"nofollow\">Use case <tt>named template</tt></a></h3>\n<p>Templates can also get registered on names. In this expample we use a named\ntemplate combined with a custom template marker interface.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IMyNamedTemplate(zope.interface.Interface):\n...     \"\"\"My custom template marker.\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(contentTemplate, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(factory,\n...     (zope.interface.Interface, IDefaultBrowserLayer), IMyNamedTemplate,\n...     name='my template')\n</pre>\n</blockquote>\n<p>Now define a view using such a custom named template registration:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IMyNamedTemplateView(zope.interface.Interface):\n...     pass\n&gt;&gt;&gt; @zope.interface.implementer(IMyNamedTemplateView)\n... class MyNamedTemplateView(object):\n...\n...     template = getViewTemplate(IMyNamedTemplate, 'my template')\n...\n...     def __init__(self, context, request):\n...         self.context = context\n...         self.request = request\n</pre>\n<pre>&gt;&gt;&gt; myNamedTempalteView = MyNamedTemplateView(root, request)\n&gt;&gt;&gt; print(myNamedTempalteView.template())\n&lt;div&gt;demo content&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"use-case-named-layout-template\">\n<h3><a href=\"#id23\" rel=\"nofollow\">Use case <tt>named layout template</tt></a></h3>\n<p>We can also register a new layout template by name and use it in a view:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.template.template import getLayoutTemplate\n</pre>\n<pre>&gt;&gt;&gt; editLayout = os.path.join(temp_dir, 'editLayout.pt')\n&gt;&gt;&gt; with open(editLayout, 'w') as file:\n...     _ = file.write('''\n...   &lt;div&gt;Edit layout&lt;/div&gt;\n...   &lt;div tal:content=\"view/render\"&gt;content&lt;/div&gt;\n... ''')\n&gt;&gt;&gt; factory = TemplateFactory(editLayout, 'text/html')\n&gt;&gt;&gt; component.provideAdapter(factory,\n...     (zope.interface.Interface, IDefaultBrowserLayer),\n...      interfaces.ILayoutTemplate, name='edit')\n</pre>\n</blockquote>\n<p>Now define a view using such a custom named template registration:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MyEditView(BrowserPage):\n...\n...     layout = getLayoutTemplate('edit')\n...\n...     def render(self):\n...         return u'edit content'\n...\n...     def __call__(self):\n...         if self.layout is None:\n...             layout = zope.component.getMultiAdapter((self, self.request),\n...                 interfaces.ILayoutTemplate)\n...             return layout(self)\n...         return self.layout()\n</pre>\n<pre>&gt;&gt;&gt; myEditView = MyEditView(root, request)\n&gt;&gt;&gt; print(myEditView())\n&lt;div&gt;Edit layout&lt;/div&gt;\n&lt;div&gt;edit content&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"cleanup\">\n<h3><a href=\"#id24\" rel=\"nofollow\">Cleanup</a></h3>\n<blockquote>\n<pre>&gt;&gt;&gt; import shutil\n&gt;&gt;&gt; shutil.rmtree(temp_dir)\n</pre>\n</blockquote>\n</div>\n<div id=\"pagelet\">\n<h3><a href=\"#id25\" rel=\"nofollow\">Pagelet</a></h3>\n<p>See <tt>z3c.pagelet</tt> for another template based layout generating implementation.</p>\n</div>\n</div>\n<div id=\"template-directive\">\n<h2><a href=\"#id26\" rel=\"nofollow\">Template directive</a></h2>\n<p>Show how we can use the template directive. Register the meta configuration for\nthe directive.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; from zope.configuration import xmlconfig\n&gt;&gt;&gt; import z3c.template\n&gt;&gt;&gt; context = xmlconfig.file('meta.zcml', z3c.template)\n</pre>\n</blockquote>\n<div id=\"pagetemplate\">\n<h3><a href=\"#id27\" rel=\"nofollow\">PageTemplate</a></h3>\n<p>We need a custom content template</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os, tempfile\n&gt;&gt;&gt; temp_dir = tempfile.mkdtemp()\n&gt;&gt;&gt; content_file = os.path.join(temp_dir, 'content.pt')\n&gt;&gt;&gt; with open(content_file, 'w') as file:\n...     _ = file.write('''&lt;div&gt;content&lt;/div&gt;''')\n</pre>\n</blockquote>\n<p>and a interface</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; class IView(zope.interface.Interface):\n...     \"\"\"Marker interface\"\"\"\n</pre>\n</blockquote>\n<p>and a view class:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; @zope.interface.implementer(IView)\n... class View(object):\n...     def __init__(self, context, request):\n...         self.context = context\n...         self.request = request\n&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; view = View(object(), request)\n</pre>\n</blockquote>\n<p>Make them available under the fake package <tt>custom</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sys.modules['custom'] = type(\n...     'Module', (),\n...     {'IView': IView})()\n</pre>\n</blockquote>\n<p>and register them as a template within the <tt>z3c:template</tt> directive:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure\n...     xmlns:z3c=\"http://namespaces.zope.org/z3c\"&gt;\n...   &lt;z3c:template\n...       template=\"%s\"\n...       for=\"custom.IView\"\n...       /&gt;\n... &lt;/configure&gt;\n... \"\"\" % content_file, context=context)\n</pre>\n</blockquote>\n<p>Let\u2019s get the template</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from z3c.template.interfaces import IContentTemplate\n&gt;&gt;&gt; template = zope.component.queryMultiAdapter(\n...     (view, request),\n...     interface=IContentTemplate)\n</pre>\n</blockquote>\n<p>and check them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.template.template import ViewPageTemplateFile\n&gt;&gt;&gt; isinstance(template, ViewPageTemplateFile)\nTrue\n&gt;&gt;&gt; isinstance(template.content_type, str)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; print(template(view))\n&lt;div&gt;content&lt;/div&gt;\n</pre>\n</blockquote>\n<div id=\"errors\">\n<h4><a href=\"#id28\" rel=\"nofollow\">Errors</a></h4>\n<p>If we try to use a path to a template that does not exist, we\nget an error:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure\n...     xmlns:z3c=\"http://namespaces.zope.org/z3c\"&gt;\n...   &lt;z3c:template\n...       template=\"this_file_does_not_exist\"\n...       for=\"custom.IView\"\n...       /&gt;\n... &lt;/configure&gt;\n... \"\"\", context=context)\nTraceback (most recent call last):\n...\nConfigurationError: ('No such file', '...this_file_does_not_exist')\nFile \"&lt;string&gt;\", line 4.2-7.8\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"id1\">\n<h3><a href=\"#id29\" rel=\"nofollow\">Layout template</a></h3>\n<p>Define a layout template</p>\n<blockquote>\n<pre>&gt;&gt;&gt; layout_file = os.path.join(temp_dir, 'layout.pt')\n&gt;&gt;&gt; with open(layout_file, 'w') as file:\n...     _ = file.write('''&lt;div&gt;layout&lt;/div&gt;''')\n</pre>\n</blockquote>\n<p>and register them as a layout template within the <tt>z3c:layout</tt> directive:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure\n...     xmlns:z3c=\"http://namespaces.zope.org/z3c\"&gt;\n...   &lt;z3c:layout\n...       template=\"%s\"\n...       for=\"custom.IView\"\n...       /&gt;\n... &lt;/configure&gt;\n... \"\"\" % layout_file, context=context)\n</pre>\n</blockquote>\n<p>Let\u2019s get the template</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.template.interfaces import ILayoutTemplate\n&gt;&gt;&gt; layout = zope.component.queryMultiAdapter((view, request),\n...     interface=ILayoutTemplate)\n</pre>\n</blockquote>\n<p>and check them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; isinstance(layout, ViewPageTemplateFile)\nTrue\n&gt;&gt;&gt; isinstance(layout.content_type, str)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; print(layout(view))\n&lt;div&gt;layout&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"context-specific-template\">\n<h3><a href=\"#id30\" rel=\"nofollow\">Context-specific template</a></h3>\n<p>Most of views have some object as their context and it\u2019s ofter very\nuseful to be able register context-specific template. We can do that\nusing the <tt>context</tt> argument of the ZCML directive.</p>\n<p>Let\u2019s define some content type:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IContent(zope.interface.Interface):\n...     pass\n&gt;&gt;&gt; @zope.interface.implementer(IContent)\n... class Content(object):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; sys.modules['custom'].IContent = IContent\n</pre>\n</blockquote>\n<p>Now, we can register a template for this class. Let\u2019s create one and\nregister:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context_file = os.path.join(temp_dir, 'context.pt')\n&gt;&gt;&gt; with open(context_file, 'w') as file:\n...     _ = file.write('''&lt;div&gt;i'm context-specific&lt;/div&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure\n...     xmlns:z3c=\"http://namespaces.zope.org/z3c\"&gt;\n...   &lt;z3c:template\n...       template=\"%s\"\n...       for=\"custom.IView\"\n...       context=\"custom.IContent\"\n...       /&gt;\n... &lt;/configure&gt;\n... \"\"\" % context_file, context=context)\n</pre>\n</blockquote>\n<p>We can now lookup it using the (view, request, context) discriminator:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = Content()\n&gt;&gt;&gt; view = View(content, request)\n</pre>\n<pre>&gt;&gt;&gt; template = zope.component.queryMultiAdapter((view, request, content),\n...     interface=IContentTemplate)\n</pre>\n<pre>&gt;&gt;&gt; print(template(view))\n&lt;div&gt;i'm context-specific&lt;/div&gt;\n</pre>\n</blockquote>\n<p>The same will work with layout registration directive:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context_layout_file = os.path.join(temp_dir, 'context_layout.pt')\n&gt;&gt;&gt; with open(context_layout_file, 'w') as file:\n...     _ = file.write('''&lt;div&gt;context-specific layout&lt;/div&gt;''')\n&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure\n...     xmlns:z3c=\"http://namespaces.zope.org/z3c\"&gt;\n...   &lt;z3c:layout\n...       template=\"%s\"\n...       for=\"custom.IView\"\n...       context=\"custom.IContent\"\n...       /&gt;\n... &lt;/configure&gt;\n... \"\"\" % context_layout_file, context=context)\n</pre>\n<pre>&gt;&gt;&gt; layout = zope.component.queryMultiAdapter((view, request, content),\n...     interface=ILayoutTemplate)\n</pre>\n<pre>&gt;&gt;&gt; print(layout(view))\n&lt;div&gt;context-specific layout&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"named-template\">\n<h3><a href=\"#id31\" rel=\"nofollow\">Named template</a></h3>\n<p>Its possible to register template by name. Let us register a pagelet with the\nname edit:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; editTemplate = os.path.join(temp_dir, 'edit.pt')\n&gt;&gt;&gt; with open(editTemplate, 'w') as file:\n...     _ = file.write('''&lt;div&gt;edit&lt;/div&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure\n...     xmlns:z3c=\"http://namespaces.zope.org/z3c\"&gt;\n...   &lt;z3c:template\n...       name=\"edit\"\n...       template=\"%s\"\n...       for=\"custom.IView\"\n...       /&gt;\n... &lt;/configure&gt;\n... \"\"\" % editTemplate, context=context)\n</pre>\n</blockquote>\n<p>And call it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.template.interfaces import ILayoutTemplate\n&gt;&gt;&gt; template = zope.component.queryMultiAdapter(\n...     (view, request),\n...     interface=IContentTemplate, name='edit')\n</pre>\n<pre>&gt;&gt;&gt; print(template(view))\n&lt;div&gt;edit&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"custom-template\">\n<h3><a href=\"#id32\" rel=\"nofollow\">Custom template</a></h3>\n<p>Or you can define own interfaces and register templates for them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.pagetemplate.interfaces import IPageTemplate\n&gt;&gt;&gt; class IMyTemplate(IPageTemplate):\n...     \"\"\"My template\"\"\"\n</pre>\n</blockquote>\n<p>Make the template interface available as a custom module class.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sys.modules['custom'].IMyTemplate = IMyTemplate\n</pre>\n</blockquote>\n<p>Dfine a new template</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interfaceTemplate = os.path.join(temp_dir, 'interface.pt')\n&gt;&gt;&gt; with open(interfaceTemplate, 'w') as file:\n...     _ = file.write('''&lt;div&gt;interface&lt;/div&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure\n...     xmlns:z3c=\"http://namespaces.zope.org/z3c\"&gt;\n...   &lt;z3c:template\n...       template=\"%s\"\n...       for=\"custom.IView\"\n...       provides=\"custom.IMyTemplate\"\n...       /&gt;\n... &lt;/configure&gt;\n... \"\"\" % interfaceTemplate, context=context)\n</pre>\n</blockquote>\n<p>Let\u2019s see if we get the template by the new interface:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.template.interfaces import ILayoutTemplate\n&gt;&gt;&gt; template = zope.component.queryMultiAdapter((view, request),\n...     interface=IMyTemplate,)\n</pre>\n<pre>&gt;&gt;&gt; print(template(view))\n&lt;div&gt;interface&lt;/div&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id33\" rel=\"nofollow\">Cleanup</a></h3>\n<p>Now we need to clean up the custom module.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del sys.modules['custom']\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id34\" rel=\"nofollow\">CHANGES</a></h2>\n<div id=\"id3\">\n<h3><a href=\"#id35\" rel=\"nofollow\">3.1.0 (2019-02-05)</a></h3>\n<ul>\n<li>Adapt tests to <cite>zope.configuration &gt;= 4.2</cite>.</li>\n<li>Add support for Python 3.7.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id36\" rel=\"nofollow\">3.0.0 (2017-10-18)</a></h3>\n<ul>\n<li>Add support for PyPy.</li>\n<li>Add support for Python 3.4, 3.5 and 3.6.</li>\n<li>Drop support for Python 2.6 and 3.3.</li>\n<li>Make bound page templates have <tt>__self__</tt> and <tt>__func__</tt>\nattributes to be more like Python 3 bound methods. (<tt>im_func</tt> and\n<tt>im_self</tt> remain available.) See <a href=\"https://github.com/zopefoundation/z3c.template/issues/3\" rel=\"nofollow\">issue 3</a>.</li>\n<li>Depend on Chameleon &gt;= 3.0, z3c.pt &gt;= 2.1 and z3c.ptcompat &gt;= 2.1.0\ndue to possible rendering issues. See <a href=\"https://github.com/zopefoundation/z3c.template/pull/2\" rel=\"nofollow\">PR 2</a>.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id37\" rel=\"nofollow\">2.0.0 (2015-11-09)</a></h3>\n<ul>\n<li>Standardize namespace <tt>__init__</tt></li>\n</ul>\n</div>\n<div id=\"a2-2013-02-25\">\n<h3><a href=\"#id38\" rel=\"nofollow\">2.0.0a2 (2013-02-25)</a></h3>\n<ul>\n<li>Make sure the of the templates content type is a native string instead\nforced bytes.</li>\n</ul>\n</div>\n<div id=\"a1-2013-02-22\">\n<h3><a href=\"#id39\" rel=\"nofollow\">2.0.0a1 (2013-02-22)</a></h3>\n<ul>\n<li>Added support for Python 3.3.</li>\n<li>Replaced deprecated <tt>zope.interface.implements</tt> usage with equivalent\n<tt>zope.interface.implementer</tt> decorator.</li>\n<li>Dropped support for Python 2.4 and 2.5.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id40\" rel=\"nofollow\">1.4.1 (2012-02-15)</a></h3>\n<ul>\n<li>Remove hooks to use ViewPageTemplateFile from z3c.pt because this breaks when\nz3c.pt is available, but z3c.ptcompat is not included. As recommended by notes\nbelow.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id41\" rel=\"nofollow\">1.4.0 (2011-10-29)</a></h3>\n<ul>\n<li><p>Moved z3c.pt include to extras_require chameleon. This makes the package\nindependent from chameleon and friends and allows to include this\ndependencies in your own project.</p>\n</li>\n<li><p>Upgrade to chameleon 2.0 template engine and use the newest z3c.pt and\nz3c.ptcompat packages adjusted to work with chameleon 2.0.</p>\n<p>See the notes from the z3c.ptcompat package:</p>\n<p>Update z3c.ptcompat implementation to use component-based template engine\nconfiguration, plugging directly into the Zope Toolkit framework.</p>\n<p>The z3c.ptcompat package no longer provides template classes, or ZCML\ndirectives; you should import directly from the ZTK codebase.</p>\n<p>Note that the <tt>PREFER_Z3C_PT</tt> environment option has been\nrendered obsolete; instead, this is now managed via component\nconfiguration.</p>\n<p>Also note that the chameleon CHAMELEON_CACHE environment value changed from\nTrue/False to a path. Skip this property if you don\u2019t like to use a cache.\nNone or False defined in buildout environment section doesn\u2019t work. At least\nwith chameleon &lt;= 2.5.4</p>\n<p>Attention: You need to include the configure.zcml file from z3c.ptcompat\nfor enable the z3c.pt template engine. The configure.zcml will plugin the\ntemplate engine. Also remove any custom built hooks which will import\nz3c.ptcompat in your tests or other places.</p>\n</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id42\" rel=\"nofollow\">1.3.0 (2011-10-28)</a></h3>\n<ul>\n<li>Update to z3c.ptcompat 1.0 (and as a result, to the z3c.pt 2.x series).</li>\n<li>Using Python\u2019s <tt>doctest</tt> module instead of depreacted\n<tt>zope.testing.doctest</tt>.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id43\" rel=\"nofollow\">1.2.1 (2009-08-22)</a></h3>\n<ul>\n<li>Corrected description of <tt>ITemplateDirective.name</tt>.</li>\n<li>Added <cite>zcml.txt</cite> to <tt>long_description</tt> to show up on pypi.</li>\n<li>Removed zpkg helper files and zcml slugs.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id44\" rel=\"nofollow\">1.2.0 (2009-02-26)</a></h3>\n<ul>\n<li>Add support for context-specific templates. Now, templates can be\nregistered and looked up using (view, request, context) triple.\nTo do that, pass the <tt>context</tt> argument to the ZCML directives.\nThe <tt>getPageTemplate</tt> and friends will now try to lookup context\nspecific template first and then fall back to (view, request) lookup.</li>\n<li>Allow use of <tt>z3c.pt</tt> using <tt>z3c.ptcompat</tt> compatibility layer.</li>\n<li>Forward the template kwargs to the options of the macro</li>\n<li>Changed package\u2019s mailing list address to zope-dev at zope.org\ninstead of retired one.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3><a href=\"#id45\" rel=\"nofollow\">1.1.0 (2007-10-08)</a></h3>\n<ul>\n<li>Added an <tt>IContentTemplate</tt> interface which is used for\n<tt>&lt;z3c:template&gt;</tt>.</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3><a href=\"#id46\" rel=\"nofollow\">1.0.0 (2007-??-??)</a></h3>\n<ul>\n<li>Initial release.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4782658, "releases": {"1.1.0": [{"comment_text": "", "digests": {"md5": "a94a46b7b63e1c2a82862f4fbb31472a", "sha256": "3e95b73cc3d2f7aa61d2cf1592449a187322a312b0bd47a7ce3ead8e811cc234"}, "downloads": -1, "filename": "z3c.template-1.1.0.tar.gz", "has_sig": false, "md5_digest": "a94a46b7b63e1c2a82862f4fbb31472a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17025, "upload_time": "2007-10-09T01:07:35", "upload_time_iso_8601": "2007-10-09T01:07:35Z", "url": "https://files.pythonhosted.org/packages/93/6b/87cd95b593f5668c62e06b54cb5081f6ef7135aa32cff7cb6dd7a779add2/z3c.template-1.1.0.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "f75c4c6ca665d2bb5b511ec0f420c448", "sha256": "40b4aaa0487eaff946eabac49f33c2da6409dec9c179747366de18af4e6e05b0"}, "downloads": -1, "filename": "z3c.template-1.2.0.tar.gz", "has_sig": false, "md5_digest": "f75c4c6ca665d2bb5b511ec0f420c448", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18635, "upload_time": "2009-02-26T15:34:35", "upload_time_iso_8601": "2009-02-26T15:34:35.680410Z", "url": "https://files.pythonhosted.org/packages/11/1b/766f3c3e458c54e2588493a546085c1fda8ac5c6de43e0af1016bbec80d4/z3c.template-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "c315cdf17169afd17236e3a78b03ce40", "sha256": "1a2fd75e0010d96b09bb15127c7b91723d3ecd8e7ee2979eb01c9f39543e653e"}, "downloads": -1, "filename": "z3c.template-1.2.1.tar.gz", "has_sig": false, "md5_digest": "c315cdf17169afd17236e3a78b03ce40", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22015, "upload_time": "2009-08-22T13:53:14", "upload_time_iso_8601": "2009-08-22T13:53:14.698805Z", "url": "https://files.pythonhosted.org/packages/97/dd/74c90b2832fde71de50100ceeafb09c56be11b957a01ec174620aecb806f/z3c.template-1.2.1.tar.gz", "yanked": false}], "1.3": [], "1.3.0": [{"comment_text": "", "digests": {"md5": "904daeb51a62fe7c1d1d1b5608524bb9", "sha256": "684dabdc6b539e8260098585f79316f4fc41a47cd0e7bb3e5ef10c382b468c67"}, "downloads": -1, "filename": "z3c.template-1.3.0.zip", "has_sig": false, "md5_digest": "904daeb51a62fe7c1d1d1b5608524bb9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32335, "upload_time": "2011-10-28T04:30:16", "upload_time_iso_8601": "2011-10-28T04:30:16.660939Z", "url": "https://files.pythonhosted.org/packages/50/3f/76e604b27b9914fbfa4c6548ff38e3d2032b65029902b24e5b97b03d9338/z3c.template-1.3.0.zip", "yanked": false}], "1.4.0": [{"comment_text": "", "digests": {"md5": "14543d2f224409e663122a523c844176", "sha256": "e9ea540527935a451a11f526cb9c108a98f6c5b9d3ba0a575a05fef7f772009b"}, "downloads": -1, "filename": "z3c.template-1.4.0.zip", "has_sig": false, "md5_digest": "14543d2f224409e663122a523c844176", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34277, "upload_time": "2011-10-29T23:21:53", "upload_time_iso_8601": "2011-10-29T23:21:53.365290Z", "url": "https://files.pythonhosted.org/packages/cf/38/3e193a198848c753bbb4d90fe91fd5616a5dab1639e03066b3bb59aa5932/z3c.template-1.4.0.zip", "yanked": false}], "1.4.1": [{"comment_text": "", "digests": {"md5": "330e2dba8cd064d5790392afd9f460dd", "sha256": "b67d3cd29403f3d540a474067fb203ff590460e92ed805b845416d0245ca9834"}, "downloads": -1, "filename": "z3c.template-1.4.1.tar.gz", "has_sig": false, "md5_digest": "330e2dba8cd064d5790392afd9f460dd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25612, "upload_time": "2012-02-15T19:23:29", "upload_time_iso_8601": "2012-02-15T19:23:29.405237Z", "url": "https://files.pythonhosted.org/packages/d2/de/be4dec58fb7aaf295c20462ec33b5f1e0d55f8281fe49c58cea2462a6fff/z3c.template-1.4.1.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "3ccfcfbb6c0ec26db70c80c6627a5332", "sha256": "9dbf4d8c86e9229cbba32725e2ebb3a0126cba83e4d248e4d81fea41af0936ba"}, "downloads": -1, "filename": "z3c.template-2.0.0.tar.gz", "has_sig": false, "md5_digest": "3ccfcfbb6c0ec26db70c80c6627a5332", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26680, "upload_time": "2015-11-09T14:17:52", "upload_time_iso_8601": "2015-11-09T14:17:52.054153Z", "url": "https://files.pythonhosted.org/packages/16/36/56e77bca1ebafc2e4a0c555ac358b4c0a2150d1863d46d0ee34abacbdf17/z3c.template-2.0.0.tar.gz", "yanked": false}], "2.0.0a1": [{"comment_text": "", "digests": {"md5": "b8e5660f57f8a4ea0e6d682c3a1c03f3", "sha256": "067ba247f3bca3714fb9296c92b62123592cbe409f9928f8466e67728173d6cc"}, "downloads": -1, "filename": "z3c.template-2.0.0a1.zip", "has_sig": false, "md5_digest": "b8e5660f57f8a4ea0e6d682c3a1c03f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36715, "upload_time": "2013-02-23T01:38:10", "upload_time_iso_8601": "2013-02-23T01:38:10.501131Z", "url": "https://files.pythonhosted.org/packages/52/fa/41d0ed66bbb838eb8af41a58a584b51cbbe687681f5dde3ecfbcf07a9bb5/z3c.template-2.0.0a1.zip", "yanked": false}], "2.0.0a2": [{"comment_text": "", "digests": {"md5": "931528442436caf3d8f51de7825547d1", "sha256": "afad5e81a7cf8d933556857ac6bc2390adf3bd87dc84f8a3ff41bc8270bae079"}, "downloads": -1, "filename": "z3c.template-2.0.0a2.zip", "has_sig": false, "md5_digest": "931528442436caf3d8f51de7825547d1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36872, "upload_time": "2013-02-25T14:31:19", "upload_time_iso_8601": "2013-02-25T14:31:19.848876Z", "url": "https://files.pythonhosted.org/packages/77/76/f45073a1494e88ffad5c9835a220b7382e73f52c639b1dd1ddaf87add4e0/z3c.template-2.0.0a2.zip", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "889f05c56ffd6ec29be18b5e36a54d35", "sha256": "8938b41d4e7f515d0de32dfea0fa09d932107672b6a657e753aaa46c5b152d77"}, "downloads": -1, "filename": "z3c.template-3.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "889f05c56ffd6ec29be18b5e36a54d35", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 30082, "upload_time": "2017-10-18T10:42:06", "upload_time_iso_8601": "2017-10-18T10:42:06.250004Z", "url": "https://files.pythonhosted.org/packages/4f/66/5470b36572c7f9c900465fc814b7976825496170576f821fd0e9bc46d0c4/z3c.template-3.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8f1933b39ffb1c714cf4f76b285ef5c8", "sha256": "ec0ff3274d7a8845b8eda4f15e04d4500f2dee3ed8282e450fd0cd1345ea8db8"}, "downloads": -1, "filename": "z3c.template-3.0.0.tar.gz", "has_sig": false, "md5_digest": "8f1933b39ffb1c714cf4f76b285ef5c8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28602, "upload_time": "2017-10-18T10:42:08", "upload_time_iso_8601": "2017-10-18T10:42:08.451664Z", "url": "https://files.pythonhosted.org/packages/9b/ce/ad884f55c01f03c01585934dddc2901776d159220445355cf2f470b2642c/z3c.template-3.0.0.tar.gz", "yanked": false}], "3.1.0": [{"comment_text": "", "digests": {"md5": "51955a2da733fdfc6e4d5edf520829c5", "sha256": "562a42bc95779f5de5a7cfd12ed88fee733445d28a0a927404a8560bcf615c01"}, "downloads": -1, "filename": "z3c.template-3.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "51955a2da733fdfc6e4d5edf520829c5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 29959, "upload_time": "2019-02-05T15:40:54", "upload_time_iso_8601": "2019-02-05T15:40:54.338306Z", "url": "https://files.pythonhosted.org/packages/21/ff/1e565399d1aec6091ccd7a15bd0a1f68375a39151c5b1b8f38da27128c0f/z3c.template-3.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "279c2c761963a29019adff6a97ee2117", "sha256": "66d7186a2c7baa874a93147c3e94b998c1d92abe1c6f807df0317f56f4af7eb1"}, "downloads": -1, "filename": "z3c.template-3.1.0.tar.gz", "has_sig": false, "md5_digest": "279c2c761963a29019adff6a97ee2117", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28688, "upload_time": "2019-02-05T15:40:56", "upload_time_iso_8601": "2019-02-05T15:40:56.967236Z", "url": "https://files.pythonhosted.org/packages/63/39/6748a4207dc825404897c72dc0261c8d76d8b482e8467f386957b622a662/z3c.template-3.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "51955a2da733fdfc6e4d5edf520829c5", "sha256": "562a42bc95779f5de5a7cfd12ed88fee733445d28a0a927404a8560bcf615c01"}, "downloads": -1, "filename": "z3c.template-3.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "51955a2da733fdfc6e4d5edf520829c5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 29959, "upload_time": "2019-02-05T15:40:54", "upload_time_iso_8601": "2019-02-05T15:40:54.338306Z", "url": "https://files.pythonhosted.org/packages/21/ff/1e565399d1aec6091ccd7a15bd0a1f68375a39151c5b1b8f38da27128c0f/z3c.template-3.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "279c2c761963a29019adff6a97ee2117", "sha256": "66d7186a2c7baa874a93147c3e94b998c1d92abe1c6f807df0317f56f4af7eb1"}, "downloads": -1, "filename": "z3c.template-3.1.0.tar.gz", "has_sig": false, "md5_digest": "279c2c761963a29019adff6a97ee2117", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28688, "upload_time": "2019-02-05T15:40:56", "upload_time_iso_8601": "2019-02-05T15:40:56.967236Z", "url": "https://files.pythonhosted.org/packages/63/39/6748a4207dc825404897c72dc0261c8d76d8b482e8467f386957b622a662/z3c.template-3.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:23 2020"}