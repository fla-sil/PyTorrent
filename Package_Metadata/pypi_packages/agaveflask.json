{"info": {"author": "Joe Stubbs", "author_email": "jstubbs@tacc.utexas.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5"], "description": "# agaveflask #\n\n## Overview ##\n\nA common set of Python modules for writing flask services for the Agave Platform. The package officially requires Python\n3.4+, though some functionality may work with Python 2.\n\n\n## Installation ##\npip install agaveflask\n\nRequires Python header files and a C++ compiler on top of gcc. On Debian/Ubuntu systems:\napt-get install python3-dev g++\n\n\n## Usage ##\n\nagaveflask provides the following modules:\n\n* auth.py - configurable authentication/authorization routines.\n* config.py - config parsing.\n* errors.py - exception classes raised by agaveflask.\n* store.py - python bindings for persistence.\n* utils.py - general request/response utilities.\n\nIt relies on a configuration file for the service. Create a file called service.conf in one of `/`, `/etc`, or `$pwd`.\nSee service.conf.ex in this repository for settings used by this library.\n\n\n## Using Docker ##\n\n### Packaging ###\nIf you are packaging your flask service with Docker, agaveflask provides a base image, agaveapi/flask_api, that\nsimplifies your Dockerfile and provides a configurable entrypoint for both development and production deployments. In\nmost cases, all you need to do is add your service code and your requirements.txt file. For example, if you have a\nflask service with a requirements.txt file and code that resides in a directory called \"service\", the Dockerfile can\nbe as simple as:\n\n```\nfrom agaveapi/flask_api\nADD requirements.txt /requirements.txt\nRUN pip install -r /requirements.txt\nADD service /service\n```\n\n### Suggested Package Layout ###\n\nFor simple microservices, we make the following recommendations for minimal configuration at deployment time.\n\n* Place the service code in a Python package called `service` that resides at the root of the Docker image (i.e. `/service`).\n* Within `/service`, have a python module called `api.py` where the wsgi application is instantiated.\n* Call the actual wsgi application object `app`.\n\nBeyond standard flask operations, additional suggestions for the `api.py` module include:\n\n* Add cors support.\n* Set up authentication and authorization for your API using the agaveflask authn_and_authz() method.\n* Start a development server within `__main__`.\n\nHere is a typical example:\n\n```\nfrom flask import Flask\nfrom flask_cors import CORS\n\nfrom agaveflask.utils import AgaveApi, handle_error\nfrom agaveflask.auth import authn_and_authz\n\nfrom resources import JwtResource\n\n# create the wsgi application object\napp = Flask(__name__)\n\n# add CORS support\nCORS(app)\n\n# create an AgaveApi object so that convenience utilities are available:\napi = AgaveApi(app)\n\n# Set up Authn/z for the API\n@app.before_request\ndef auth():\n    authn_and_authz()\n\n# Set up error handling\n@app.errorhandler(Exception)\ndef handle_all_errors(e):\n    return handle_error(e)\n\n# Add the resources\napi.add_resource(JwtResource, '/admin/jwt')\n\n# start a development server\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True)\n```\n\n### Deployment Configuration ###\nThe entry point is configured through environmental variables. Using the `server` variable toggles between a\ndevelopment server you have created in your api module and gunicorn, meant for production.\nAll other settings are used to help the entrypoint find\nyour wsgi application. If you are able to use the recommended file system structure and layout, you may be able to\nrely exclusively on the image defaults.\n\nHere is a complete list of config variables, their usage, and their default values:\n\n* server: Value 'dev' attempts to starts up a development server by executing your module's `__main__` method. Any\nother value starts up gunicorn. Default is 'dev'.\n* package: path to package containing service code (no trailing slash). Default is '/service'.\n* module: name of python module (not including '.py') containing the wsgi application object. Default is 'api'.\n* app: name of the wsgi application object. Default is 'app'.\n* port: port to start the server on when running with gunicorn. Default is 5000.\n\n\n### Docker compose Example ###\nThe following snippet from a hypothetical docker-compose.yml file illustrates typical usage. In this example we have a\nfolder, `services`, containing two services like so:\n\n* `/services/serviceA/api.py`\n* `/services/serviceB/api.py`\n\nWe are bundling into the same docker image (`jdoe/my_services`). Because of this we need to set the indvidual packages for each using environmental variables. We also set the server\nvariable so that we use gunicorn.\n\n```\n.  .  .\n\nserviceA:\n    image: jdoe/my_services\n    ports:\n        - \"5000:5000\"\n    volumes:\n        - ./local-dev.conf:/etc/service.conf\n    environment:\n        package: /services/serviceA\n        server: gunicorn\n\nserviceB:\n    image: jdoe/my_services\n    ports:\n        - \"5001:5000\"\n    volumes:\n        - ./local-dev.conf:/etc/service.conf\n    environment:\n        package: /services/serviceA\n        server: gunicorn\n\n.  .  .\n\n```", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/agaveapi/agaveflask", "keywords": "", "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "agaveflask", "package_url": "https://pypi.org/project/agaveflask/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/agaveflask/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://bitbucket.org/agaveapi/agaveflask"}, "release_url": "https://pypi.org/project/agaveflask/0.2.0/", "requires_dist": null, "requires_python": null, "summary": "Common package for authoring Agave services in flask/Flask-RESTful", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            # agaveflask #<br><br>## Overview ##<br><br>A common set of Python modules for writing flask services for the Agave Platform. The package officially requires Python<br>3.4+, though some functionality may work with Python 2.<br><br><br>## Installation ##<br>pip install agaveflask<br><br>Requires Python header files and a C++ compiler on top of gcc. On Debian/Ubuntu systems:<br>apt-get install python3-dev g++<br><br><br>## Usage ##<br><br>agaveflask provides the following modules:<br><br>* auth.py - configurable authentication/authorization routines.<br>* config.py - config parsing.<br>* errors.py - exception classes raised by agaveflask.<br>* store.py - python bindings for persistence.<br>* utils.py - general request/response utilities.<br><br>It relies on a configuration file for the service. Create a file called service.conf in one of `/`, `/etc`, or `$pwd`.<br>See service.conf.ex in this repository for settings used by this library.<br><br><br>## Using Docker ##<br><br>### Packaging ###<br>If you are packaging your flask service with Docker, agaveflask provides a base image, agaveapi/flask_api, that<br>simplifies your Dockerfile and provides a configurable entrypoint for both development and production deployments. In<br>most cases, all you need to do is add your service code and your requirements.txt file. For example, if you have a<br>flask service with a requirements.txt file and code that resides in a directory called \"service\", the Dockerfile can<br>be as simple as:<br><br>```<br>from agaveapi/flask_api<br>ADD requirements.txt /requirements.txt<br>RUN pip install -r /requirements.txt<br>ADD service /service<br>```<br><br>### Suggested Package Layout ###<br><br>For simple microservices, we make the following recommendations for minimal configuration at deployment time.<br><br>* Place the service code in a Python package called `service` that resides at the root of the Docker image (i.e. `/service`).<br>* Within `/service`, have a python module called `api.py` where the wsgi application is instantiated.<br>* Call the actual wsgi application object `app`.<br><br>Beyond standard flask operations, additional suggestions for the `api.py` module include:<br><br>* Add cors support.<br>* Set up authentication and authorization for your API using the agaveflask authn_and_authz() method.<br>* Start a development server within `__main__`.<br><br>Here is a typical example:<br><br>```<br>from flask import Flask<br>from flask_cors import CORS<br><br>from agaveflask.utils import AgaveApi, handle_error<br>from agaveflask.auth import authn_and_authz<br><br>from resources import JwtResource<br><br># create the wsgi application object<br>app = Flask(__name__)<br><br># add CORS support<br>CORS(app)<br><br># create an AgaveApi object so that convenience utilities are available:<br>api = AgaveApi(app)<br><br># Set up Authn/z for the API<br>@app.before_request<br>def auth():<br>    authn_and_authz()<br><br># Set up error handling<br>@app.errorhandler(Exception)<br>def handle_all_errors(e):<br>    return handle_error(e)<br><br># Add the resources<br>api.add_resource(JwtResource, '/admin/jwt')<br><br># start a development server<br>if __name__ == '__main__':<br>    app.run(host='0.0.0.0', debug=True)<br>```<br><br>### Deployment Configuration ###<br>The entry point is configured through environmental variables. Using the `server` variable toggles between a<br>development server you have created in your api module and gunicorn, meant for production.<br>All other settings are used to help the entrypoint find<br>your wsgi application. If you are able to use the recommended file system structure and layout, you may be able to<br>rely exclusively on the image defaults.<br><br>Here is a complete list of config variables, their usage, and their default values:<br><br>* server: Value 'dev' attempts to starts up a development server by executing your module's `__main__` method. Any<br>other value starts up gunicorn. Default is 'dev'.<br>* package: path to package containing service code (no trailing slash). Default is '/service'.<br>* module: name of python module (not including '.py') containing the wsgi application object. Default is 'api'.<br>* app: name of the wsgi application object. Default is 'app'.<br>* port: port to start the server on when running with gunicorn. Default is 5000.<br><br><br>### Docker compose Example ###<br>The following snippet from a hypothetical docker-compose.yml file illustrates typical usage. In this example we have a<br>folder, `services`, containing two services like so:<br><br>* `/services/serviceA/api.py`<br>* `/services/serviceB/api.py`<br><br>We are bundling into the same docker image (`jdoe/my_services`). Because of this we need to set the indvidual packages for each using environmental variables. We also set the server<br>variable so that we use gunicorn.<br><br>```<br>.  .  .<br><br>serviceA:<br>    image: jdoe/my_services<br>    ports:<br>        - \"5000:5000\"<br>    volumes:<br>        - ./local-dev.conf:/etc/service.conf<br>    environment:<br>        package: /services/serviceA<br>        server: gunicorn<br><br>serviceB:<br>    image: jdoe/my_services<br>    ports:<br>        - \"5001:5000\"<br>    volumes:<br>        - ./local-dev.conf:/etc/service.conf<br>    environment:<br>        package: /services/serviceA<br>        server: gunicorn<br><br>.  .  .<br><br>```\n          </div>"}, "last_serial": 2588332, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "ae101242dbc8615c7054f055ef285adb", "sha256": "2c8185fc0ac05d53c480290d758421e57bbf9189b70ee321db0f56f0f4afe33e"}, "downloads": -1, "filename": "agaveflask-0.0.1.tar.gz", "has_sig": false, "md5_digest": "ae101242dbc8615c7054f055ef285adb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7873, "upload_time": "2016-08-26T22:00:47", "upload_time_iso_8601": "2016-08-26T22:00:47.502368Z", "url": "https://files.pythonhosted.org/packages/c3/95/1a92c230cabec56f0290349284567b9073266407ad7e374b50d619f78fb2/agaveflask-0.0.1.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "e6e38103b83315bf4736d4ac5cfe90b0", "sha256": "7646fabcff72c445a569673926038e1cc0e990a2b1ad1aa840f6945da5803e5e"}, "downloads": -1, "filename": "agaveflask-0.1.0.tar.gz", "has_sig": false, "md5_digest": "e6e38103b83315bf4736d4ac5cfe90b0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7867, "upload_time": "2016-08-26T22:02:30", "upload_time_iso_8601": "2016-08-26T22:02:30.211839Z", "url": "https://files.pythonhosted.org/packages/1b/a0/ecd54453c49cc44d00728615d76bf50659a188c06fa951d72f3e8bc01064/agaveflask-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "93c549bc6e567541093bff20ef92964f", "sha256": "bdd655b37ed4f2d1db2551bc6e88fea55a9211894bc6fe6409e3fee5f95c7295"}, "downloads": -1, "filename": "agaveflask-0.2.0.tar.gz", "has_sig": false, "md5_digest": "93c549bc6e567541093bff20ef92964f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11531, "upload_time": "2017-01-20T19:31:15", "upload_time_iso_8601": "2017-01-20T19:31:15.488190Z", "url": "https://files.pythonhosted.org/packages/4a/4b/6f6cae6d2aa00f2823bcfd7fdd3aed330a09c156b40ed54b9e5debc81a7c/agaveflask-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "93c549bc6e567541093bff20ef92964f", "sha256": "bdd655b37ed4f2d1db2551bc6e88fea55a9211894bc6fe6409e3fee5f95c7295"}, "downloads": -1, "filename": "agaveflask-0.2.0.tar.gz", "has_sig": false, "md5_digest": "93c549bc6e567541093bff20ef92964f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11531, "upload_time": "2017-01-20T19:31:15", "upload_time_iso_8601": "2017-01-20T19:31:15.488190Z", "url": "https://files.pythonhosted.org/packages/4a/4b/6f6cae6d2aa00f2823bcfd7fdd3aed330a09c156b40ed54b9e5debc81a7c/agaveflask-0.2.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:22:37 2020"}