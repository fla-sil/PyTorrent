{"info": {"author": "Kilian Evang", "author_email": "kilian.evang@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "![Produce logo](https://raw.githubusercontent.com/texttheater/produce/master/img/logo/Produce_Logo_300.png)\n==============================================\n\nProduce is an incremental build system for the command line, like Make or redo,\nbut different: it is scriptable in Python and it supports multiple variable\nparts in file names. This makes it ideal for doing things beyond compiling\ncode, like setting up replicable scientific experiments.\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents** \n\n- [Requirements](#requirements)\n- [Installing Produce](#installing-produce)\n- [Usage](#usage)\n- [Motivation](#motivation)\n- [Build automation: basic requirements](#build-automation-basic-requirements)\n- [Make syntax vs. Produce syntax and a tour of the basic features](#make-syntax-vs-produce-syntax-and-a-tour-of-the-basic-features)\n  - [Rules, expansions, escaping and comments](#rules-expansions-escaping-and-comments)\n  - [Named and unnamed dependencies](#named-and-unnamed-dependencies)\n  - [Multiple wildcards, regular expressions and matching conditions](#multiple-wildcards-regular-expressions-and-matching-conditions)\n  - [Special targets vs. special attributes](#special-targets-vs-special-attributes)\n  - [Python expressions and global variables](#python-expressions-and-global-variables)\n- [Running Produce](#running-produce)\n  - [Status and debugging messages](#status-and-debugging-messages)\n  - [Error handling and aborting](#error-handling-and-aborting)\n  - [How targets are matched against rules](#how-targets-are-matched-against-rules)\n- [Advanced usage](#advanced-usage)\n  - [Whitespace and indentation in values](#whitespace-and-indentation-in-values)\n  - [The prelude](#the-prelude)\n  - [`shell`: choosing the recipe interpreter](#shell-choosing-the-recipe-interpreter)\n  - [Running jobs in parallel](#running-jobs-in-parallel)\n  - [Dependency files](#dependency-files)\n  - [Rules with multiple outputs](#rules-with-multiple-outputs)\n    - [\u201cSideways\u201d dependencies](#sideways-dependencies)\n  - [Producing the outputs for all inputs](#producing-the-outputs-for-all-inputs)\n- [All special attributes at a glance](#all-special-attributes-at-a-glance)\n  - [In rules](#in-rules)\n  - [In the global section](#in-the-global-section)\n- [Getting in touch](#getting-in-touch)\n- [Acknowledgments](#acknowledgments)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\nRequirements\n------------\n\n* A Unix-like operating system such as Linux or Mac OS X. Windows Subsystem for\n  Linux may also work.\n* Python 3.4 or higher\n* Git (for downloading Produce)\n\nInstalling Produce\n------------------\n\nInstall the latest release using pip:\n\n    pip3 install produce\n\nOr get the development version by running the following command in a convenient\nlocation:\n\n    git clone https://github.com/texttheater/produce\n\nThis will create a directory called `produce`. To update to the latest version\nof Produce later, you can just go into that directory and run:\n\n    git pull\n\nThe `produce` directory contains an executable Python script also called\n`produce`. This is all you need to run Produce. Just make sure it is in your\n`PATH`, e.g. by copying it to `/usr/local/bin` or by linking to it from your\n`$HOME/bin` directory.\n\nUsage\n-----\n\nWhen invoked, Produce will first look for a file called `produce.ini` in the\ncurrent working directory. Its format is documented in this document. If you\nwant a quick start, have a look at\n[an example project](https://github.com/texttheater/produce/tree/master/doc/samples/tokenization).\n\nYou may also have a look at the\n[PyGrunn 2014 slides](https://texttheater.github.io/produce-pygrunn2014)\nfor a quick introduction.\n\nMotivation\n----------\n\nProduce is a build automation tool. Build automation is useful whenever you\nhave one or several input files from which one or several output files are\ngenerated automatically \u2013 possibly in multiple steps, so that you have\nintermediate files.\n\nThe classic case for this is compiling C programs, where a simple project might\nlook like this:\n\n![example dependency chart for compiling a C program](img/compiling.png)\n\nBut build automation is also useful in other areas, such as science. For\nexample, in the [Groningen Meaning Bank](http://gmb.let.rug.nl/) project, a\nNatural Language Processing pipeline is combined with corrections from human\nexperts to build a collection of texts with linguistic annotations in a\nbootstraping fashion.\n\nIn the following simplified setup, processing starts with a text file\n(`en.txt`) which is first part-of-speech-tagged (`en.pos`), then analyzed\nsyntactically (`en.syn`) by a parser and finally analyzed semantically\n(`en.sem`). Each step is first carried out automatically by an NLP tool\n(`*.auto`) but then corrections by human annotators (`*.corr`) are applied\nto build the main version of the file which then serves as input to further\nprocessing. Every time a new human correction is added, parts of the\npipeline must be re-run:\n\n![example dependency chart for running an NLP pipeline](img/pipeline.png)\n\nOr take running machine learning experiments: we have a collection of labeled\ndata, split into a training portion and testing portions. We have various\nfeature sets and want to know which one produces the best model. So we train a\nseparate model based on each feature set and on the training data, and generate\ncorresponding labeled outputs and evaluation reports based on the development\ntest data:\n\n![example dependency chart for running machine learning experiments](img/ml.png)\n\nA [number](http://kbroman.github.io/minimal_make/)\n[of](http://bost.ocks.org/mike/make/) [articles](http://zmjones.com/make/)\npoint out that build automation is an invaluable help in setting up experiments\nin a self-documenting manner, so that they can still be understood, replicated\nand modified months or years later, by you, your colleagues or other\nresearchers. Many people use Make for this purpose, and so did I, for a while.\nI specifically liked:\n\n* *The declarative notation.* Every step of the workflow is expressed as a\n  _rule_, listing the _target_, its direct dependencies and the command to run\n  (the _recipe_). Together with a good file naming scheme, this almost\n  eliminates the need for documentation.\n* *The Unix philosophy.* Make is, at its core, a thin wrapper around shell\n  scripts. For orchestrating the steps, you use Make, and for executing them,\n  you use the full power of shell scripts. Each tool does one thing, and does\n  it well. This reliance on shell scripts is something that sets Make apart\n  from specialized build tools such as Ant or A-A-P.\n* *The wide availability.* Make is installed by default on almost every Unix\n  system, making it ideal for disseminating and exchanging code because the\n  Makefile format is widely known and can be run everywhere.\n\nSo, if Make has so many advantages, why yet another build automation tool?\nThere are two reasons:\n\n* *Make\u2019s syntax.* Although the basic syntax is extremely simple, as soon as\n  you want to go a _little bit_ beyond what it offers and use more advanced\n  features, things get quite arcane very quickly.\n* *Wildcards are quite limited.* If you want to match on the name of a specific\n  target to generate its dependencies dynamically, you can only use one\n  wildcard. If your names are a bit more complex than that, you have to resort\n  to black magic like Make\u2019s built-in string manipulation functions that don\u2019t\n  compare favorably to languages like Python or even Perl, or rely on external\n  tools. In either case, your Makefiles become extremely hard to read, bugs\n  slip in easily and the simplicity afforded by the declarative paradigm is\n  largely lost.\n\nProduce is thus designed as a tool that copies Make\u2019s virtues and improves a\ngreat deal on its deficiencies by using a still simple, but much more powerful\nsyntax for mapping targets to dependencies. Only the core functionality of Make\nis mimicked \u2013 advanced functions of Make such as built-in rules specific to\ncompiling C programs are not covered. Produce is general-purpose.\n\nProduce is written in Python 3 and scriptable in Python 3. Whenever I write\nPython below, I mean Python 3.\n\nBuild automation: basic requirements\n------------------------------------\n\nLet\u2019s review the basic functionality we expect of a build automation tool:\n\n* Allows you to run multiple steps of a workflow with a single command, in the\n  right order.\n* Notices when inputs have changed and runs exactly those steps again that are\n  needed to bring the outputs up to speed, no more or less.\n\nIn addition, some build automation tools satisfy the following requirement\n(Produce currently doesn\u2019t):\n\n* Intermediate files can be deleted without affecting up-to-dateness \u2013 if the\n  outputs are newer than the inputs, the workflow will not be re-run.\n\nMake syntax vs. Produce syntax and a tour of the basic features\n---------------------------------------------------------------\n\nWhen you run the `produce` command (usually followed by the targets you want\nbuilt), Produce will look for a file in the current directory, called\n`produce.ini` by default. This is the \u201cProducefile\u201d. Let\u2019s introduce\nProducefile syntax by comparing it to Makefile syntax.\n\n### Rules, expansions, escaping and comments\n\nHere is a Makefile for a tiny C project:\n\n    # Compile\n    %.o : %.c\n    \tcc -c $<\n\n    # Link\n    % : %.o\n    \tcc -o $@ $<\n\nAnd here is the corresponding `produce.ini`:\n\n    # Compile\n    [%{name}.o]\n    dep.c = %{name}.c\n    recipe = cc -c %{c}\n\n    # Link\n    [%{name}]\n    dep.o = %{name}.o\n    recipe = cc -o %{target} %{o}\n\nEasy enough, right? Produce syntax is a dialect of the widely known INI syntax,\nconsisting of sections with headings in square brackets, followed by\nattribute-value pairs separated by `=`. In Produce\u2019s case, sections represent\n_rules_, the section headings are _target patterns_ matching _targets_ to\nbuild, and the attribute-value pairs specify the target\u2019s direct dependencies\nand the recipe to run it.\n\nDependencies are typically listed each as one attribute of the form `dep.name`\nwhere `name` stands for a name you give to the dependency \u2013 e.g., its file\ntype. This way, you can refer to it in the recipe using an _expansion_.\n\nExpansions have the form `%{...}`. In the target pattern, they are used as\nwildcards. When the rule is invoked on a specific target, they match any string\nand assign it to the variable name specified between the curly braces. In\nattribute values, they are used like variables, expanding to the value\nassociated with the variable name. Besides target matching, values can also be\nassigned to variable names by attribute-value pairs, as with e.g.\n`dep.c = %{name}.c`. Here, `c` is the variable name; the `dep.` prefix just\ntells Produce that this particular value is also a dependency.\n\nIf you need a literal percent sign in some attribute value, you need to escape\nit as `%%`.\n\nThe `target` variable is automatically available when the rule is invoked,\ncontaining the target matched by the target pattern.\n\nLines starting with `#` are for comments and ignored.\n\nSo far, so good \u2013 a readable syntax, I hope, but a bit more verbose than that\nof Makefiles. What does this added verbosity buy us? We will see in the next\nsubsections.\n\n### Named and unnamed dependencies\n\nTo see why naming dependencies is a good idea, consider the following Makefile\nrule:\n\n    out/%.pos : out/%.pos.auto out/%.pos.corr\n    \t./src/scripts/apply_corrections $< \\\n            --corrections out/$*.pos.corr > $@\n\nThis could be from the Natural Language Processing project we saw as the second\nexample above: the rule is for making the final `pos` file from the\nautomatically generated `pos.auto` file and the `pos.corr` file with manual\ncorrections, thus it has two direct dependencies, specified on the first line.\nThe recipe refers to the first dependency using the shorthand `$<`, but there\nis no such shorthand for other dependencies. So we have to type out the second\ndependency again in the recipe, taking care to replace the wildcard `%` with\nthe magic variable `$*`. This is ugly because it violates the golden principle\n\u201cDon\u2019t repeat yourself!\u201d If we write something twice in a Makefile, not only is\nit more work to type, but also if we want to change it later, we have to change\nit in two places, and there\u2019s a good chance we\u2019ll forget that.\n\nProduce\u2019s named dependencies avoid this problem: once specified, you can refer\nto every dependency using its name. Here is the Produce rule corresponding to\nthe above Makefile rule:\n\n    [out/%{name}.pos]\n    dep.auto = %{name}.pos.auto\n    dep.corr = %{name}.pos.corr\n    recipe = ./src/scripts/apply_corrections %{auto} %{corr} > %{target}\n\nNote that you don\u2019t _have_ to name dependencies. Sometimes you don\u2019t need to\nrefer back to them. Here is an example rule that compiles a LaTeX document:\n\n    [%{name}.pdf]\n    deps = %{name}.tex bibliography.bib\n    recipe =\n    \tpdflatex %{name}\n    \tbibtex %{name}\n    \tpdflatex %{name}\n    \tpdflatex %{name}\n\nThe TeX tools are smart enough to fill in the file name extension if we just\ngive them the basename that we got by matching the target. In such cases, it\ncan be more convenient not to name the dependencies and list them all on one\nline. This is what the `deps` attribute is for. It is parsed using Python\u2019s\n[`shlex.split`](https://docs.python.org/3/library/shlex.html?highlight=shlex#shlex.split)\nfunction \u2013 consult the Python documentation for escaping rules and such. You\ncan also mix `dep.*` attributes and `deps` in one rule.\n\nNote that, as in many INI dialects, attribute values (here: the recipe) can\nspan multiple lines as long as each line after the first is indented. See\n[Whitespace and indentation in values](#whitespace-and-indentation-in-values)\nbelow for details.\n\nNote also that dependency lists can also be generated dynamically \u2013 see the\nsection on [dependency files](#dependency-files) below.\n\n### Multiple wildcards, regular expressions and matching conditions\n\nThe ability to use more than one wildcard in target patterns is Produce\u2019s\nkiller feature because not many other build automations tools offer it.\nThe only one I know of so far is [plmake](https://github.com/cmungall/plmake).\nRake and others do offer full regular expressions which are strictly more\npowerful but not as easy to read. Don\u2019t worry, Produce supports them too and\nmore, we will come to that. But first consider the following Produce rule,\nwhich might stem from the third example project we saw in the introduction,\nthe machine learning one:\n\n    [out/%{corpus}.%{portion}.%{fset}.labeled]\n    dep.model = out/%{corpus}.train.%{fset}.model\n    dep.input = out/%{corpus}.%{portion}.feat\n    recipe = wapiti label -m %{model} %{input} > %{target}\n\nLabeled output files here follow a certain naming convention: four parts,\nseparated by periods. The first one specifies the data collection (e.g. a\nlinguistic corpus), the second one the portion of the data that is\nautomatically labeled in this step (either the development portion or the test\nportion), the third one specifies the feature set used and the fourth one is\nthe extension `labeled`. For each of the three first parts, we use a wildcard\nto match it. We can then freely use these three wildcards to specify the\ndependencies: the model we use for labelling depends on the corpus and on the\nfeature set but not on the portion to label: the portion used for training the\nmodel is always the training portion. The input to labelling is a file\ncontaining the data portion to label, together with the extracted features. We\nassume that this file always contains all features we can extract even if we\u2019re\nnot going to use them in a particular model, so this dependency does not depend\non the feature set.\n\nA Makefile rule to achieve something similar would look something like this:\n\n    .SECONDEXPANSION:\n    out/%.labeled : out/$$(subst test,train,$$(subst dev,train,$$*)).model \\\n                    out/$$(basename $$*).feat\n            wapiti label -m $< out/$(basename $*).feat > $@\n\nIf you are like me, this is orders of magnitude less readable than the Produce\nversion. Getting a Makefile rule like this to function properly will certainly\nmake you feel smart, but hopefully also feel miserable about the brain cycles\nwasted getting your head around the bizarre syntax, the double dollars and the\nsecond expansion.\n\nA wildcard will match _anything_. If you need more control about which targets\nare matched, you can use a\n[Python regular expression](https://docs.python.org/3/library/re.html?highlight=re#module-re)\nbetween slashes as the target pattern. For example, if we want to make sure\nthat our rule only matches targets where the second part of the filename is\neither `dev` or `test`, we could do it like this:\n\n    [/out/(?P<corpus>.*)\\.(?P<portion>dev|test)\\.(?P<fset>.*)\\.labeled/]\n    dep.model = out/%{corpus}.train.%{fset}.model\n    dep.input = out/%{corpus}.%{portion}.feat\n    recipe = wapiti label -m %{model} %{input} > %{target}\n\nThe regular expression in this rule\u2019s header is almost precisely what the above\nheader with three wildcards is translated to by Produce internally, with the\ndifference that the subexpression matching the second part is now `dev|test`\nrather than `.*`. We are using a little-known feature of regular expressions\nhere, namely the `(?P<...>)` syntax that allows us to assign names to\nsubexpressions by which you can refer to the matched part later.\n\nNote the slashes at the beginning and end are just a signal to Produce to\ninterpret what is in-between as a regular expressions. You do not have to\nescape slashes within your regular expression.\n\nWhile regular expressions are powerful, they make your Producefile less\nreadable. A better way to write the above rule is by sticking to ordinary\nwildcards and using a separate _matching condition_ to check for `dev|test`:\n\n    [out/%{corpus}.%{portion}.%{fset}.labeled]\n    cond = %{portion in ('dev', 'test')}\n    dep.model = out/%{corpus}.train.%{fset}.model\n    dep.input = out/%{corpus}.%{portion}.feat\n    recipe = wapiti label -m %{model} %{input} > %{target}\n\nA matching condition is specified as the `cond` attribute. We can use any\nPython expression. It is evaluated only if the target pattern matches the\nrequested target. If it evaluates to a \u201ctruthy\u201d value, the rule matches and\nthe recipe is executed. If it evaluates to a \u201cfalsy\u201d value, the rule does\nnot match, and Produce moves on, trying to match the next rule in the\nProducefile.\n\nNote that the Python expression is given as an expansion. At this point we\nshould explain a few fine points:\n\n1. Whenever we used expansions so far, the variable names inside were actually\n   Python expressions, albeit of a simple kind: single variable names. But as\n   we see now, we can use arbitrary Python expressions. Expansions used as\n   wildcards in the target pattern are an exception, of course: they can only\n   consist of a single variable name.\n2. The variables we use in rules are actually Python variables.\n3. Attribute values are always strings, so if a Python expression is used to\n   generate (part of) an attribute value, not the value of the expression\n   itself is used but whatever its `__str__` method returns. Thus, in the\n   above rule, the value of the `cond` variable is not `True` or `False`, but\n   `'True'` or `'False'`. In order to interpret the value as a Boolean, Produce\n   calls\n   [ast.literal\\_eval](https://docs.python.org/3/library/ast.html?highlight=literal_eval#ast.literal_eval)\n   on the string. So if the string contains anything other than a literal\n   Python expression, this is an error.\n\nAs an exception to what we said about `__str__`, if an expansion evaluates to\nsomething that is not a string but has an `__iter__` method, it will be treated\nas a sequence and rendered as a white-space separated list, the elements\nproperly shell-quoted and escaped. Note also that parentheses are automatically\nadded around an expansion so it is very convenient to use generator expressions\nfor expansions. All of this is illustrated in the following rule:\n\n    [Whole.txt]\n    deps = %{'Part {}.txt'.format(i) for i in range(4)}\n    recipe = cat %{deps} > %{target}\n\n### Special targets vs. special attributes\n\nBesides not naming all dependencies, there is another reason why Make\u2019s syntax\nis too simple for its own good. When some rule needs to have a special\nproperty, Make usually requires a \u201cspecial target\u201d that syntactically looks\nlike a target but is actually a declaration and has no obvious visual\nconnection to the rule(s) it applies to. We have already seen an example of the\ndreaded `.SECONDEXPANSION`. Another common special target is `.PHONY`, marking\ntargets that are just jobs to be run, without producing an output file. For\nexample:\n\n    .PHONY: clean\n    clean:\n    \trm *.o temp\n\nIt would be easier and more logical if the \u201cphoniness\u201d was declared as part of\nthe rule rather than some external declaration. This is was Produce does. The\nProduce equivalent of declaring targets phony is to set the `type` attribute of\ntheir rule to `task` (the default is `file`). With this the rule above is\nwritten as follows:\n\n    [vacuum]\n    type = task\n    recipe = rm *.o temp\n\nNote that since it is ungrammatical to \u201cproduce a clean\u201d, I invented a naming\nconvention according to which the task that cleans up your project directory is\ncalled `vacuum` because it produces a vacuum. It\u2019s silly, I know.\n\nFor other special attributes besides `task`, see [All special attributes at a\nglance](#all-special-attributes-at-a-glance) below.\n\n### Python expressions and global variables\n\nAs we have already seen, Produce\u2019s expansions can contain arbitrary Python\nexpressions. This is not only useful for specifying Boolean matching\nconditions, but also for string manipulation, in particular for playing with\ndependencies. This is a pain in Make, because Make implements its own string\nmanipulation language which from today\u2019s perspective (since we have Python)\nnot only reinvents the wheel, but reinvents it poorly, with a rather dangerous\nsyntax. Consider the following (contrived) example from the GNU Make manual\nwhere you have a list of dependencies in a global variable and filter them to\nretain only those ending in `.c` or `.s`:\n\n    sources := foo.c bar.c baz.s ugh.h\n    foo: $(sources)\n    \tcc $(filter %.c %.s,$(sources)) -o foo\n\nWith Produce, we can just hand the string manipulation to Python, a language\nwe already know and (hopefully) like:\n\n    []\n    sources = foo.c bar.c baz.s ugh.h\n\n    [foo]\n    deps = %{sources}\n    recipe = cc %{f for f in sources.split() \\\n    \t\tif f.endswith('.c') or f.endswith('.s')}\n\nThis example also introduces the _global section_, a section headed by `[]`,\nthus named with the empty string. The attributes here define global variables\naccessible from all rules. The global section may only appear once and only at\nthe beginning of a Producefile.\n\nRunning Produce\n---------------\n\nProduce is invoked from the command line by the command `produce`, usually\nfollowed by the target(s) to produce. These can be omitted if the Producefile\nspecifies one or more default targets. By default, Produce will look for\n`produce.ini` in the current working directory and complain if it does not\nexist.\n\nA number of options can be used to control Produce\u2019s behavior, as listed in its\nhelp message:\n\n    usage: produce [-h] [-B | -b] [-d] [-f FILE] [-j JOBS] [-n] [-u FILE]\n                   [target [target ...]]\n\n    positional arguments:\n      target                The target(s) to produce - if omitted, default target\n                            from Producefile is used\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      -B, --always-build    Unconditionally build all specified targets and their\n                            dependencies\n      -b, --always-build-specified\n                            Unconditionally build all specified targets, but treat\n                            their dependencies normally (only build if out of\n                            date)\n      -d, --debug           Print debugging information. Give this option multiple\n                            times for more information.\n      -f FILE, --file FILE  Use FILE as a Producefile\n      -j JOBS, --jobs JOBS  Specifies the number of jobs (recipes) to run\n                            simultaneously\n      -n, --dry-run         Print status messages, but do not run recipes\n      -u FILE, --pretend-up-to-date FILE\n                            Do not rebuild FILE or its dependencies (unless they\n                            are also depended on by other targets) even if out of\n                            date, but make sure that future invocations of Produce\n                            will still treat them as out of date by increasing the\n                            modification times of their changed dependencies as\n                            necessary.\n\n### Status and debugging messages\n\nWhen it starts (re)building a target, Produce will tell you so with a status\nmessage in green where the target is indented according to how deep in the\ndependency graph it is. On successful completion of a target, a similar message\nwith `complete` is printed. If an error occurs while a target is being built,\nProduce instead prints an `incomplete` message in red. The latter indicates\ncontrolled shutdown: the recipe has been killed and incomplete outputs have\nbeen renamed (see below). If you see a `(re)building` message but no\n`(in)complete` message for some target, something went really wrong \u2013 this\nshould never happen. In that case, better check for yourself if any incomplete\noutputs are still hanging around.\n\nGiving the `-d`/`--debug` option one, two or three times will cause Produce to\nadditionally flood your terminal with a few, some more or lots of messages that\nmay be helpful for debugging.\n\n### Error handling and aborting\n\nWhen a recipe fails, i.e. its interpreter returns an exit status other than 0,\nthe corresponding target file (if any) may already have been created or\ntouched, potentially leading the next invocation of Produce to believe that it\nis up to date, even though it probably doesn\u2019t have the correct contents. Such\ninconsistencies can lead to users tearing their hair out. In order to avoid\nthis, Produce will, when a recipe fails, make sure that the target file does\nnot stay there. It could just delete it, but that might be unwise because the\nuser might want to inspect the output file of the erroneous recipe for\ndebugging. So, Produce renames the target file by appending a `~` to the\nfilename (a common naming convention for short-lived \u201cbackups\u201d).\n\nIf multiple recipes are running in parallel and one fails, Produce will kill\nall of them, do the renaming and abort immediately.\n\nThe same is true if Produce receives an interrupt signal. So you can safely\nabort a production process in your terminal by pressing `Ctrl+C`.\n\n### How targets are matched against rules\n\nWhen producing a target, either because asked to by the user or because the\ntarget is required by another one, Produce will always work through the\nProducefile from top to bottom and use the first rule that matches the target.\nA rule matches a target if both the target pattern matches and the matching\ncondition (if any) subsequently evaluates to true.\n\nNote that unlike most INI dialects, Produce allows for multiple sections with\nthe same heading. It makes sense to have the same target pattern multiple times\nwhen there are matching conditions to make subdistinctions.\n\nIf no rule matches a target, Produce aborts with an error message.\n\nAdvanced usage\n--------------\n\n### Whitespace and indentation in values\n\nAn attribute value can span multiple lines as long as each line after the first\nis indented with some whitespace. The recommended indentation is either one tab\nor four spaces. If you make use of this, it is recommended to leave the first\nline (after the attribute name and the `=`) blank so all lines of the value are\nconsistently aligned.\n\nThe _second_ line of a value (i.e. the first indented one) determines the kind\nand amount of whitespace expected to start each subsequent line. This\nwhitespace will _not_ be part of the attribute value. _Additional_ whitespace\nafter the initial amount is, however, preserved. This is important e.g. for\nPython code and the reason why Produce is no longer using Python\u2019s\n`configparser` module.\n\nAll whitespace at the very beginning and at the very end of an attribute value\nwill be stripped away.\n\nFor example, in the following rule, the recipe spans two lines:\n\n    [paper.pdf]\n    dep.tex = paper.tex\n    dep.bib = paper.bib\n    recipe =\n        pdflatex paper\n        pdflatex paper\n\n### The prelude\n\nIf you use Python expressions in your recipes, you will often need to import\nPython modules or define functions to use in these expressions. You can do this\nby putting the imports, function definitions and other Python code into the\nspecial `prelude` attribute in the [global\nsection](#python-expressions-and-global-variables). For example, put this at\nthe beginning of your Producefile to import the `errno`, `glob` and `os`\nmodules and define a helper function for creating directories.\n\n    []\n    prelude =\n        import errno\n        import glob\n        import os\n\n        def makedirs(path):\n            try:\n                os.makedirs(path)\n            except OSError, error:\n                if error.errno != errno.EEXIST:\n                    raise error\n\n### `shell`: choosing the recipe interpreter\n\nBy default, recipes are (after doing expansions) handed to the `bash` command\nfor execution. If you would rather write your recipe in `zsh`, `perl`, `python`\nor any other language, that\u2019s no problem. Just specify the interpreter in the\n`shell` attribute of the rule.\n\n### Running jobs in parallel\n\nUse the `-j JOBS` command line option to specify the number of jobs Produce\nruns in parallel. By default, Produce reserves one job slot for each recipe.\nFor recipes that run multiple parallel jobs themselves, it is recommended to\nspecify the number of jobs via the `jobs` attribute. Produce will then reserve\nthat many job slots for this recipe (but no more than `JOBS`).\n\nHere is an example where the target `b` is created by a recipe that runs in\nparallel:\n\n    [a]\n    deps = b c d\n    recipe = touch %{target}\n\n    [b]\n    dep.input = input.txt\n    dep.my_script = ./my_script.sh\n    jobs = 8\n    recipe = parallel --gnu -n %{jobs} -k %{my_script} %{input} > %{target}\n\n    [c]\n    dep.my_script = ./my_script.sh\n    recipe = %{my_script} c > %{target}\n\n    [d]\n    dep.my_script = ./my_script.sh\n    recipe = %{my_script} d > %{target}\n\nRunning `produce -j 8 a` will run up to 8 jobs in parallel. In this example,\nthe recipes for `c` and `d` may run in parallel. The recipe for `b` will not\nrun in parallel with any other recipe because it uses all 8 job slots.\n\n### Dependency files\n\nSometimes the question which other files a file depends on is more complex and\nmay change frequently over the lifetime of a project, e.g. in the cases of\nsource files that import other header files, modules etc. In such cases, it\nwould be nice to have the dependencies automatically listed by a script.\nProduce supports this via the `depfile` attribute in rules: here, you can\nspecify the name of a _dependency file_, a text file that contains\ndependencies, one per line. Produce will read them and add them to the list of\ndependencies for the matched target. Also, Produce will try to produce the\ndependency file (i.e. make it up to date) _prior_ to reading it. So you can\nwrite another rule that tells Produce how to generate each dependency file, and\nthe rest is automatic.\n\nFor example, the following rule might be used to generate a dependency file\nlisting the source file and header files required for compiling a C object.\nThis example uses `.d` as the extension for dependency files. It runs `cc -MM`\nto use the C compiler\u2019s dependency discovery feature and then some shell magic\nto convert the output from a Makefile rule into a simple dependency list:\n\n    [%{name}.d]\n    dep.c = %{name}.c\n    recipe =\n        cc -MM -I. %{name} | sed -e 's/.*: //' | sed -e 's/^ *//' | \\\n        perl -pe 's/ (\\\\\\n)?/\\n/g' > %{target}\n\nThe following rule could then be used to create the actual object file. The\n`depfile` attribute makes sure that whenever an included header file changes,\nthe object file will be rebuilt:\n\n    [%{name}.o]\n    dep.src = %{name}.c\n    depfile = %{name}.d\n    recipe =\n        cc -c -o %{target} %{src}\n\nNote that the `.c` file will end up in the dependency list twice, once from\n`dep.src` and once from the dependency file. This does not matter, Produce is\nsmart enough not to do the same thing twice.\n\nWarning: dependency files are made up to date even in dry-run mode!\n\n### Rules with multiple outputs\n\nSometimes you have a command that creates multiple files at once because their\ncreation is inherently linked to the same process \u2013 it wouldn\u2019t make sense to\ntry and create them in neatly separated steps. Splitting a file up into\nmultiple chunks is such a case:\n\n    split -n 4 data.txt\n\nThis command creates four files called `xaa`, `xab`, `xac` and `xad`. It gets\ncomplicated when these output files individually are dependencies of further\ntargets, as in this example:\n\n    [split_and_zip]\n    type = task\n    deps = xaa.zip xab.zip xac.zip xad.zip\n\n    [%{name}.zip]\n    dep.file = %{name}\n    recipe = zip %{target} %{file}\n\n    [%{chunk}]\n    dep.txt = data.txt\n    recipe = split -n 4 %{txt}\n\nIf we run the task `split_and_zip`, it will try to create its (indirect)\ndependencies `xaa`, `xab`, `xac` and `xad` independently of each other. Each\ntime, the last rule will match, and each time, the exact same recipe will be\nexecuted. This is unncecessary work, one time would be sufficient because it\ncreates all four files in each case. Worse, if we run Produce in parallel,\nmultiple instances of the recipe may run in parallel and corrupt the data.\n\nThe solution is to explicitly declare which files a rule produces, other than\nthe target. The `outputs` attribute serves this purpose. With it, the last rule\nis rewritten as follows:\n\n    [%{chunk}]\n    outputs = xaa xab xac xad\n    dep.txt = data.txt\n    recipe = split -n 4 %{txt}\n\nAdditionally, it is good style to add a matching condition to prevent that the\nrule accidentally matches something that is not its output:\n\n    [%{chunk}]\n    outputs = xaa xab xac xad\n    cond = %{target in outputs.split()}\n    dep.txt = data.txt\n    recipe = split -n 4 %{txt}\n\nInstead of a single `outputs` attribute, separate attributes with the `out.`\nprefix can be used, and both styles can also be mixed, similar to\n`dep.`/`deps`. Here is an example of a rule using the `out.` style to declare\nthat while producing a `.pdf` file it will also produce an `.aux` file:\n\n    [%{name}.pdf]\n    dep.tex = %{name}.tex\n    out.aux = %{name}.aux\n    recipe =\n        pdflatex %{tex}\n\n#### \u201cSideways\u201d dependencies\n\nSuppose there is a target A that has some additional output file B. What if a\ntarget C wants to declare a dependency on B? For this to work, there must be a\nrule matching B. B, of course, is produced when A is produced. So, effectively,\nin order to produce B, A must be produced. We can express this as a dependency:\nB depends on A. You can write a rule that will tell Produce to produce A when B\nis requested:\n\n    [B]\n    dep.a = A\n\n(TODO: What if A is up to date but B does not exist?)\n\nSuch a rule only serves to \u201cguide\u201d Produce from B to A. It cannot contain its\nown recipe. This would not make the sense as it is the rule for A that creates\nB. If you included a recipe, Produce would complain about a cyclic dependency.\n\nHere is a more concrete example: the rule for `paper.pdf` produces an\nadditional output `paper.aux`. Another rule, for `paper.info`, depends on\n`paper.aux`. In order for Produce to be able to satisfy this dependency,\n`paper.aux` is declared as depending on `paper.pdf`.\n\n    [paper.info]\n    dep.aux = paper.aux\n    recipe = cat %{aux} | ./my_tool > %{target}\n\n    [paper.aux]\n    dep.pdf = paper.pdf\n\n    [paper.pdf]\n    dep.tex = paper.tex\n    outputs = paper.aux\n    recipe =\n        pdflatex paper\n\nThere is one final problem here: after running the recipe for `paper.pdf`, the\nmodification time of `paper.pdf` may well be greater than that of `paper.aux`.\nSince we declared `paper.aux` dependent on `paper.pdf`, this means that\n`paper.aux` appears as out of date to Produce even though we just produced it.\nA simple and effective way to prevent this is to include `touch %{outputs}` as \nthe last line of any rule with multiple outputs. The last rule above thus\nbecomes:\n\n    [paper.pdf]\n    dep.tex = paper.tex\n    outputs = paper.aux\n    recipe =\n        pdflatex paper\n        touch %{outputs}\n\n### Producing the outputs for all inputs\n\nSuppose you have a number of input files (say `inputs/input001.txt` to\n`inputs/input100.txt`). Each input can be processed to yield an output file\n(say `models/model001` to `models/model100`) \u2013 for example, by the following\nrule:\n\n    [models/model%{num}]\n    dep.input = inputs/input%{num}.txt\n    dep.train = bin/train\n    recipe = ./%{train} %{input} %{target}\n\nNow you would like to automatically produce the model for every input that is\nthere. You can do this by writing a _task_, i.e., a rule for a target that is\nnot a file but is just invoked. The task for the example might look like this:\n\n    [all_models]\n    type = task\n    deps = %{'models/{}'.format(i.replace('input', 'model').replace('.txt, \\\n             '') for i in os.listdir('inputs')}\n\nThis task does not need a recipe because all it does is pull in all the models\nthrough its dependencies. The dependencies are specified through an arbitrary\nPython expression, in this case it looks at the inputs directory and returns\nthe names of the models corresponding to each input. It uses the `os` module,\nwhich needs to be imported. So let\u2019s add a global section with a prelude to do\nthis. The whole Producefile then looks like this:\n\n    []\n    prelude =\n        import os\n\n    [models/model%{num}]\n    dep.input = inputs/input%{num}.txt\n    dep.train = bin/train\n    recipe = ./%{train} %{input} %{target}\n\n    [all_models]\n    type = task\n    deps = %{'models/{}'.format(i.replace('input', 'model').replace('.txt, \\\n             '') for i in os.listdir('inputs')}\n\nAnd to produce all models, all you need to do is tell Produce to produce the\n`all_models` task:\n\n    $ produce all_models\n\n## All special attributes at a glance\n\nFor your reference, here are all the rule attributes that currently have a\nspecial meaning to Produce:\n\n### In rules\n\n<dl>\n    <dt><code>target</code></dt>\n    <dd>When a rule matches a target, this variable is always set to that\n    target, mainly so you can refer to it in the recipe. It is illegal to set\n    the <code>target</code> attribute yourself. Also see\n    <a href=\"#rules-expansions-escaping-and-comments\">Rules, expansions, escaping and comments</a>.</dd>\n    <dt><code>cond</code></dt>\n    <dd>Allows to specify a _matching condition_ in addition to the target\n    pattern. Typically it is given as a single expansion with a boolean Python\n    expression. It is expanded immediately after a target matches the rule. The\n    resulting string must be a Python literal. If \u201ctruthy\u201d, the rule matches\n    and its expansion/execution continues. If \u201cfalsy\u201d, the rule does not match\n    the target and Produce proceeds with the next rule, trying to match the\n    target. Also see <a href=\"#multiple-wildcards-regular-expressions-and-matching-conditions\">Multiple wildcards, regular expressions and matching conditions</a>.</dd>\n    <dt><code>dep.*</code></dt>\n    <dd>The asterisk stands for a name chosen by you, which is the actual name\n    of the variable the attribute value will be assigned to. The <code>dep.</code> prefix,\n    not part of the variable name, tells Produce that this is a dependency,\n    i.e. that the target given by the value must be made up to date before the\n    recipe of this rule can be run. Also see\n    <a href=\"#named-and-unnamed-dependencies\">Named an unnamed depenencies</a>.</dd>\n    <dt><code>deps</code></dt>\n    <dd>Like <code>dep.*</code>, but allows for specifying multiple unnamed dependencies\n    in one attribute value. The format is roughly a space-separated list. For\n    details, see\n    <a href=\"https://docs.python.org/3/library/shlex.html?highlight=shlex#shlex.split\"><code>shlex.split</code></a>.\n    Also see <a href=\"#named-and-unnamed-dependencies\">Named an unnamed depenencies</a>.</dd>\n    <dt><code>depfile</code></dt>\n    <dd>Another way to specify (additional) dependencies: the name of a file\n    from which dependencies are read, one per line. Additionally, Produce will\n    try to make that file up to date prior to reading it. Also see\n    <a href=\"#dependency-files\">Dependency files</a>.</dd>\n    <dt><code>type</code></dt>\n    <dd>Is either <code>file</code> (default) or <code>task</code>. If <code>file</code>, the target is supposed\n    to be a file that the recipe creates/updates if it runs successfully. If\n    <code>task</code>, the target is an arbitrary name given to some task that the recipe\n    executes. Crucially, task-type targets are always assumed to be out of\n    date, regardless of the possible existence and age of a file with the same\n    name. Also see\n    <a href=\"#special-targets-vs-special-attributes\">Special targets vs. special attributes</a></dd>\n    <dt><code>recipe</code></dt>\n    <dd>The command(s) to run to build the target, typically a single shell\n    command or a short shell script. Unlike Make, each line is not run in\n    isolation, but the whole script is passed to the interpreter as a whole,\n    after doing expansions. This way, you can e.g. define a shell variable\n    on one line and use it on the next. Also see\n    <a href=\"#rules-expansions-escaping-and-comments\">Rules, expansions, escaping and comments</a>.</dd>\n    <dt><code>shell</code></dt>\n    <dd>See <a href=\"#shell-choosing-the-recipe-interpreter\"><code>shell</code>: choosing the recipe interpreter</a></dd>\n    <dt><code>out.*</code></dt>\n    <dd>See <a href=\"#rules-with-multiple-outputs\">Rules with multiple outputs</a></dd>\n    <dt><code>outputs</code></dt>\n    <dd>See <a href=\"#rules-with-multiple-outputs\">Rules with multiple outputs</a></dd>\n    <dt><code>jobs</code></dt>\n    <dd>See <a href=\"#running-jobs-in-parallel\">Running jobs in parallel</a></dd>\n</dl>\n\n### In the global section\n\n<dl>\n    <dt><code>default</code></dt>\n    <dd>A list\n    (parsed by <a href=\"https://docs.python.org/3/library/shlex.html?highlight=shlex#shlex.split\"><code>shlex.split</code></a>)\n    of default targets that are produced if the user does not specify any\n    targets when calling Produce.</dd>\n    <dt><code>prelude</code></dt>\n    <dd>See <a href=\"#the-prelude\">The prelude</a></dd>\n</dl>\n\nGetting in touch\n----------------\n\nProduce is being developed by Kilian Evang <%{firstname}@%{lastname}.name>.\nI would love to hear from you if you find it useful, if you have questions, bug\nreports or feature requests.\n\nAcknowledgments\n---------------\n\nThe Produce logo was designed by [Valerio Basile](https://valeriobasile.github.io).\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/texttheater/produce", "keywords": "make,builder,automation", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "produce", "package_url": "https://pypi.org/project/produce/", "platform": "", "project_url": "https://pypi.org/project/produce/", "project_urls": {"Homepage": "https://github.com/texttheater/produce"}, "release_url": "https://pypi.org/project/produce/0.3.1/", "requires_dist": null, "requires_python": "", "summary": "Replacement for Make geared towards processing data rather than compiling code", "version": "0.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1><img alt=\"Produce logo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7a5a380e51d8c7bb35249b7f138c8edbbc306ec0/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f74657874746865617465722f70726f647563652f6d61737465722f696d672f6c6f676f2f50726f647563655f4c6f676f5f3330302e706e67\"></h1>\n<p>Produce is an incremental build system for the command line, like Make or redo,\nbut different: it is scriptable in Python and it supports multiple variable\nparts in file names. This makes it ideal for doing things beyond compiling\ncode, like setting up replicable scientific experiments.</p>\n\n\n<p><strong>Table of Contents</strong></p>\n<ul>\n<li><a href=\"#requirements\" rel=\"nofollow\">Requirements</a></li>\n<li><a href=\"#installing-produce\" rel=\"nofollow\">Installing Produce</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a></li>\n<li><a href=\"#motivation\" rel=\"nofollow\">Motivation</a></li>\n<li><a href=\"#build-automation-basic-requirements\" rel=\"nofollow\">Build automation: basic requirements</a></li>\n<li><a href=\"#make-syntax-vs-produce-syntax-and-a-tour-of-the-basic-features\" rel=\"nofollow\">Make syntax vs. Produce syntax and a tour of the basic features</a>\n<ul>\n<li><a href=\"#rules-expansions-escaping-and-comments\" rel=\"nofollow\">Rules, expansions, escaping and comments</a></li>\n<li><a href=\"#named-and-unnamed-dependencies\" rel=\"nofollow\">Named and unnamed dependencies</a></li>\n<li><a href=\"#multiple-wildcards-regular-expressions-and-matching-conditions\" rel=\"nofollow\">Multiple wildcards, regular expressions and matching conditions</a></li>\n<li><a href=\"#special-targets-vs-special-attributes\" rel=\"nofollow\">Special targets vs. special attributes</a></li>\n<li><a href=\"#python-expressions-and-global-variables\" rel=\"nofollow\">Python expressions and global variables</a></li>\n</ul>\n</li>\n<li><a href=\"#running-produce\" rel=\"nofollow\">Running Produce</a>\n<ul>\n<li><a href=\"#status-and-debugging-messages\" rel=\"nofollow\">Status and debugging messages</a></li>\n<li><a href=\"#error-handling-and-aborting\" rel=\"nofollow\">Error handling and aborting</a></li>\n<li><a href=\"#how-targets-are-matched-against-rules\" rel=\"nofollow\">How targets are matched against rules</a></li>\n</ul>\n</li>\n<li><a href=\"#advanced-usage\" rel=\"nofollow\">Advanced usage</a>\n<ul>\n<li><a href=\"#whitespace-and-indentation-in-values\" rel=\"nofollow\">Whitespace and indentation in values</a></li>\n<li><a href=\"#the-prelude\" rel=\"nofollow\">The prelude</a></li>\n<li><a href=\"#shell-choosing-the-recipe-interpreter\" rel=\"nofollow\"><code>shell</code>: choosing the recipe interpreter</a></li>\n<li><a href=\"#running-jobs-in-parallel\" rel=\"nofollow\">Running jobs in parallel</a></li>\n<li><a href=\"#dependency-files\" rel=\"nofollow\">Dependency files</a></li>\n<li><a href=\"#rules-with-multiple-outputs\" rel=\"nofollow\">Rules with multiple outputs</a>\n<ul>\n<li><a href=\"#sideways-dependencies\" rel=\"nofollow\">\u201cSideways\u201d dependencies</a></li>\n</ul>\n</li>\n<li><a href=\"#producing-the-outputs-for-all-inputs\" rel=\"nofollow\">Producing the outputs for all inputs</a></li>\n</ul>\n</li>\n<li><a href=\"#all-special-attributes-at-a-glance\" rel=\"nofollow\">All special attributes at a glance</a>\n<ul>\n<li><a href=\"#in-rules\" rel=\"nofollow\">In rules</a></li>\n<li><a href=\"#in-the-global-section\" rel=\"nofollow\">In the global section</a></li>\n</ul>\n</li>\n<li><a href=\"#getting-in-touch\" rel=\"nofollow\">Getting in touch</a></li>\n<li><a href=\"#acknowledgments\" rel=\"nofollow\">Acknowledgments</a></li>\n</ul>\n\n<h2>Requirements</h2>\n<ul>\n<li>A Unix-like operating system such as Linux or Mac OS X. Windows Subsystem for\nLinux may also work.</li>\n<li>Python 3.4 or higher</li>\n<li>Git (for downloading Produce)</li>\n</ul>\n<h2>Installing Produce</h2>\n<p>Install the latest release using pip:</p>\n<pre><code>pip3 install produce\n</code></pre>\n<p>Or get the development version by running the following command in a convenient\nlocation:</p>\n<pre><code>git clone https://github.com/texttheater/produce\n</code></pre>\n<p>This will create a directory called <code>produce</code>. To update to the latest version\nof Produce later, you can just go into that directory and run:</p>\n<pre><code>git pull\n</code></pre>\n<p>The <code>produce</code> directory contains an executable Python script also called\n<code>produce</code>. This is all you need to run Produce. Just make sure it is in your\n<code>PATH</code>, e.g. by copying it to <code>/usr/local/bin</code> or by linking to it from your\n<code>$HOME/bin</code> directory.</p>\n<h2>Usage</h2>\n<p>When invoked, Produce will first look for a file called <code>produce.ini</code> in the\ncurrent working directory. Its format is documented in this document. If you\nwant a quick start, have a look at\n<a href=\"https://github.com/texttheater/produce/tree/master/doc/samples/tokenization\" rel=\"nofollow\">an example project</a>.</p>\n<p>You may also have a look at the\n<a href=\"https://texttheater.github.io/produce-pygrunn2014\" rel=\"nofollow\">PyGrunn 2014 slides</a>\nfor a quick introduction.</p>\n<h2>Motivation</h2>\n<p>Produce is a build automation tool. Build automation is useful whenever you\nhave one or several input files from which one or several output files are\ngenerated automatically \u2013 possibly in multiple steps, so that you have\nintermediate files.</p>\n<p>The classic case for this is compiling C programs, where a simple project might\nlook like this:</p>\n<p><img alt=\"example dependency chart for compiling a C program\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6f485fa6707f598df828525c0d0b0f8e49972984/696d672f636f6d70696c696e672e706e67\"></p>\n<p>But build automation is also useful in other areas, such as science. For\nexample, in the <a href=\"http://gmb.let.rug.nl/\" rel=\"nofollow\">Groningen Meaning Bank</a> project, a\nNatural Language Processing pipeline is combined with corrections from human\nexperts to build a collection of texts with linguistic annotations in a\nbootstraping fashion.</p>\n<p>In the following simplified setup, processing starts with a text file\n(<code>en.txt</code>) which is first part-of-speech-tagged (<code>en.pos</code>), then analyzed\nsyntactically (<code>en.syn</code>) by a parser and finally analyzed semantically\n(<code>en.sem</code>). Each step is first carried out automatically by an NLP tool\n(<code>*.auto</code>) but then corrections by human annotators (<code>*.corr</code>) are applied\nto build the main version of the file which then serves as input to further\nprocessing. Every time a new human correction is added, parts of the\npipeline must be re-run:</p>\n<p><img alt=\"example dependency chart for running an NLP pipeline\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a7c96d3e7c67f2bcc26a449eb896be801935f43c/696d672f706970656c696e652e706e67\"></p>\n<p>Or take running machine learning experiments: we have a collection of labeled\ndata, split into a training portion and testing portions. We have various\nfeature sets and want to know which one produces the best model. So we train a\nseparate model based on each feature set and on the training data, and generate\ncorresponding labeled outputs and evaluation reports based on the development\ntest data:</p>\n<p><img alt=\"example dependency chart for running machine learning experiments\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8e3a19a6a334e6b8752a34f0f2bae976d2e5fb37/696d672f6d6c2e706e67\"></p>\n<p>A <a href=\"http://kbroman.github.io/minimal_make/\" rel=\"nofollow\">number</a>\n<a href=\"http://bost.ocks.org/mike/make/\" rel=\"nofollow\">of</a> <a href=\"http://zmjones.com/make/\" rel=\"nofollow\">articles</a>\npoint out that build automation is an invaluable help in setting up experiments\nin a self-documenting manner, so that they can still be understood, replicated\nand modified months or years later, by you, your colleagues or other\nresearchers. Many people use Make for this purpose, and so did I, for a while.\nI specifically liked:</p>\n<ul>\n<li><em>The declarative notation.</em> Every step of the workflow is expressed as a\n<em>rule</em>, listing the <em>target</em>, its direct dependencies and the command to run\n(the <em>recipe</em>). Together with a good file naming scheme, this almost\neliminates the need for documentation.</li>\n<li><em>The Unix philosophy.</em> Make is, at its core, a thin wrapper around shell\nscripts. For orchestrating the steps, you use Make, and for executing them,\nyou use the full power of shell scripts. Each tool does one thing, and does\nit well. This reliance on shell scripts is something that sets Make apart\nfrom specialized build tools such as Ant or A-A-P.</li>\n<li><em>The wide availability.</em> Make is installed by default on almost every Unix\nsystem, making it ideal for disseminating and exchanging code because the\nMakefile format is widely known and can be run everywhere.</li>\n</ul>\n<p>So, if Make has so many advantages, why yet another build automation tool?\nThere are two reasons:</p>\n<ul>\n<li><em>Make\u2019s syntax.</em> Although the basic syntax is extremely simple, as soon as\nyou want to go a <em>little bit</em> beyond what it offers and use more advanced\nfeatures, things get quite arcane very quickly.</li>\n<li><em>Wildcards are quite limited.</em> If you want to match on the name of a specific\ntarget to generate its dependencies dynamically, you can only use one\nwildcard. If your names are a bit more complex than that, you have to resort\nto black magic like Make\u2019s built-in string manipulation functions that don\u2019t\ncompare favorably to languages like Python or even Perl, or rely on external\ntools. In either case, your Makefiles become extremely hard to read, bugs\nslip in easily and the simplicity afforded by the declarative paradigm is\nlargely lost.</li>\n</ul>\n<p>Produce is thus designed as a tool that copies Make\u2019s virtues and improves a\ngreat deal on its deficiencies by using a still simple, but much more powerful\nsyntax for mapping targets to dependencies. Only the core functionality of Make\nis mimicked \u2013 advanced functions of Make such as built-in rules specific to\ncompiling C programs are not covered. Produce is general-purpose.</p>\n<p>Produce is written in Python 3 and scriptable in Python 3. Whenever I write\nPython below, I mean Python 3.</p>\n<h2>Build automation: basic requirements</h2>\n<p>Let\u2019s review the basic functionality we expect of a build automation tool:</p>\n<ul>\n<li>Allows you to run multiple steps of a workflow with a single command, in the\nright order.</li>\n<li>Notices when inputs have changed and runs exactly those steps again that are\nneeded to bring the outputs up to speed, no more or less.</li>\n</ul>\n<p>In addition, some build automation tools satisfy the following requirement\n(Produce currently doesn\u2019t):</p>\n<ul>\n<li>Intermediate files can be deleted without affecting up-to-dateness \u2013 if the\noutputs are newer than the inputs, the workflow will not be re-run.</li>\n</ul>\n<h2>Make syntax vs. Produce syntax and a tour of the basic features</h2>\n<p>When you run the <code>produce</code> command (usually followed by the targets you want\nbuilt), Produce will look for a file in the current directory, called\n<code>produce.ini</code> by default. This is the \u201cProducefile\u201d. Let\u2019s introduce\nProducefile syntax by comparing it to Makefile syntax.</p>\n<h3>Rules, expansions, escaping and comments</h3>\n<p>Here is a Makefile for a tiny C project:</p>\n<pre><code># Compile\n%.o : %.c\n\tcc -c $&lt;\n\n# Link\n% : %.o\n\tcc -o $@ $&lt;\n</code></pre>\n<p>And here is the corresponding <code>produce.ini</code>:</p>\n<pre><code># Compile\n[%{name}.o]\ndep.c = %{name}.c\nrecipe = cc -c %{c}\n\n# Link\n[%{name}]\ndep.o = %{name}.o\nrecipe = cc -o %{target} %{o}\n</code></pre>\n<p>Easy enough, right? Produce syntax is a dialect of the widely known INI syntax,\nconsisting of sections with headings in square brackets, followed by\nattribute-value pairs separated by <code>=</code>. In Produce\u2019s case, sections represent\n<em>rules</em>, the section headings are <em>target patterns</em> matching <em>targets</em> to\nbuild, and the attribute-value pairs specify the target\u2019s direct dependencies\nand the recipe to run it.</p>\n<p>Dependencies are typically listed each as one attribute of the form <code>dep.name</code>\nwhere <code>name</code> stands for a name you give to the dependency \u2013 e.g., its file\ntype. This way, you can refer to it in the recipe using an <em>expansion</em>.</p>\n<p>Expansions have the form <code>%{...}</code>. In the target pattern, they are used as\nwildcards. When the rule is invoked on a specific target, they match any string\nand assign it to the variable name specified between the curly braces. In\nattribute values, they are used like variables, expanding to the value\nassociated with the variable name. Besides target matching, values can also be\nassigned to variable names by attribute-value pairs, as with e.g.\n<code>dep.c = %{name}.c</code>. Here, <code>c</code> is the variable name; the <code>dep.</code> prefix just\ntells Produce that this particular value is also a dependency.</p>\n<p>If you need a literal percent sign in some attribute value, you need to escape\nit as <code>%%</code>.</p>\n<p>The <code>target</code> variable is automatically available when the rule is invoked,\ncontaining the target matched by the target pattern.</p>\n<p>Lines starting with <code>#</code> are for comments and ignored.</p>\n<p>So far, so good \u2013 a readable syntax, I hope, but a bit more verbose than that\nof Makefiles. What does this added verbosity buy us? We will see in the next\nsubsections.</p>\n<h3>Named and unnamed dependencies</h3>\n<p>To see why naming dependencies is a good idea, consider the following Makefile\nrule:</p>\n<pre><code>out/%.pos : out/%.pos.auto out/%.pos.corr\n\t./src/scripts/apply_corrections $&lt; \\\n        --corrections out/$*.pos.corr &gt; $@\n</code></pre>\n<p>This could be from the Natural Language Processing project we saw as the second\nexample above: the rule is for making the final <code>pos</code> file from the\nautomatically generated <code>pos.auto</code> file and the <code>pos.corr</code> file with manual\ncorrections, thus it has two direct dependencies, specified on the first line.\nThe recipe refers to the first dependency using the shorthand <code>$&lt;</code>, but there\nis no such shorthand for other dependencies. So we have to type out the second\ndependency again in the recipe, taking care to replace the wildcard <code>%</code> with\nthe magic variable <code>$*</code>. This is ugly because it violates the golden principle\n\u201cDon\u2019t repeat yourself!\u201d If we write something twice in a Makefile, not only is\nit more work to type, but also if we want to change it later, we have to change\nit in two places, and there\u2019s a good chance we\u2019ll forget that.</p>\n<p>Produce\u2019s named dependencies avoid this problem: once specified, you can refer\nto every dependency using its name. Here is the Produce rule corresponding to\nthe above Makefile rule:</p>\n<pre><code>[out/%{name}.pos]\ndep.auto = %{name}.pos.auto\ndep.corr = %{name}.pos.corr\nrecipe = ./src/scripts/apply_corrections %{auto} %{corr} &gt; %{target}\n</code></pre>\n<p>Note that you don\u2019t <em>have</em> to name dependencies. Sometimes you don\u2019t need to\nrefer back to them. Here is an example rule that compiles a LaTeX document:</p>\n<pre><code>[%{name}.pdf]\ndeps = %{name}.tex bibliography.bib\nrecipe =\n\tpdflatex %{name}\n\tbibtex %{name}\n\tpdflatex %{name}\n\tpdflatex %{name}\n</code></pre>\n<p>The TeX tools are smart enough to fill in the file name extension if we just\ngive them the basename that we got by matching the target. In such cases, it\ncan be more convenient not to name the dependencies and list them all on one\nline. This is what the <code>deps</code> attribute is for. It is parsed using Python\u2019s\n<a href=\"https://docs.python.org/3/library/shlex.html?highlight=shlex#shlex.split\" rel=\"nofollow\"><code>shlex.split</code></a>\nfunction \u2013 consult the Python documentation for escaping rules and such. You\ncan also mix <code>dep.*</code> attributes and <code>deps</code> in one rule.</p>\n<p>Note that, as in many INI dialects, attribute values (here: the recipe) can\nspan multiple lines as long as each line after the first is indented. See\n<a href=\"#whitespace-and-indentation-in-values\" rel=\"nofollow\">Whitespace and indentation in values</a>\nbelow for details.</p>\n<p>Note also that dependency lists can also be generated dynamically \u2013 see the\nsection on <a href=\"#dependency-files\" rel=\"nofollow\">dependency files</a> below.</p>\n<h3>Multiple wildcards, regular expressions and matching conditions</h3>\n<p>The ability to use more than one wildcard in target patterns is Produce\u2019s\nkiller feature because not many other build automations tools offer it.\nThe only one I know of so far is <a href=\"https://github.com/cmungall/plmake\" rel=\"nofollow\">plmake</a>.\nRake and others do offer full regular expressions which are strictly more\npowerful but not as easy to read. Don\u2019t worry, Produce supports them too and\nmore, we will come to that. But first consider the following Produce rule,\nwhich might stem from the third example project we saw in the introduction,\nthe machine learning one:</p>\n<pre><code>[out/%{corpus}.%{portion}.%{fset}.labeled]\ndep.model = out/%{corpus}.train.%{fset}.model\ndep.input = out/%{corpus}.%{portion}.feat\nrecipe = wapiti label -m %{model} %{input} &gt; %{target}\n</code></pre>\n<p>Labeled output files here follow a certain naming convention: four parts,\nseparated by periods. The first one specifies the data collection (e.g. a\nlinguistic corpus), the second one the portion of the data that is\nautomatically labeled in this step (either the development portion or the test\nportion), the third one specifies the feature set used and the fourth one is\nthe extension <code>labeled</code>. For each of the three first parts, we use a wildcard\nto match it. We can then freely use these three wildcards to specify the\ndependencies: the model we use for labelling depends on the corpus and on the\nfeature set but not on the portion to label: the portion used for training the\nmodel is always the training portion. The input to labelling is a file\ncontaining the data portion to label, together with the extracted features. We\nassume that this file always contains all features we can extract even if we\u2019re\nnot going to use them in a particular model, so this dependency does not depend\non the feature set.</p>\n<p>A Makefile rule to achieve something similar would look something like this:</p>\n<pre><code>.SECONDEXPANSION:\nout/%.labeled : out/$$(subst test,train,$$(subst dev,train,$$*)).model \\\n                out/$$(basename $$*).feat\n        wapiti label -m $&lt; out/$(basename $*).feat &gt; $@\n</code></pre>\n<p>If you are like me, this is orders of magnitude less readable than the Produce\nversion. Getting a Makefile rule like this to function properly will certainly\nmake you feel smart, but hopefully also feel miserable about the brain cycles\nwasted getting your head around the bizarre syntax, the double dollars and the\nsecond expansion.</p>\n<p>A wildcard will match <em>anything</em>. If you need more control about which targets\nare matched, you can use a\n<a href=\"https://docs.python.org/3/library/re.html?highlight=re#module-re\" rel=\"nofollow\">Python regular expression</a>\nbetween slashes as the target pattern. For example, if we want to make sure\nthat our rule only matches targets where the second part of the filename is\neither <code>dev</code> or <code>test</code>, we could do it like this:</p>\n<pre><code>[/out/(?P&lt;corpus&gt;.*)\\.(?P&lt;portion&gt;dev|test)\\.(?P&lt;fset&gt;.*)\\.labeled/]\ndep.model = out/%{corpus}.train.%{fset}.model\ndep.input = out/%{corpus}.%{portion}.feat\nrecipe = wapiti label -m %{model} %{input} &gt; %{target}\n</code></pre>\n<p>The regular expression in this rule\u2019s header is almost precisely what the above\nheader with three wildcards is translated to by Produce internally, with the\ndifference that the subexpression matching the second part is now <code>dev|test</code>\nrather than <code>.*</code>. We are using a little-known feature of regular expressions\nhere, namely the <code>(?P&lt;...&gt;)</code> syntax that allows us to assign names to\nsubexpressions by which you can refer to the matched part later.</p>\n<p>Note the slashes at the beginning and end are just a signal to Produce to\ninterpret what is in-between as a regular expressions. You do not have to\nescape slashes within your regular expression.</p>\n<p>While regular expressions are powerful, they make your Producefile less\nreadable. A better way to write the above rule is by sticking to ordinary\nwildcards and using a separate <em>matching condition</em> to check for <code>dev|test</code>:</p>\n<pre><code>[out/%{corpus}.%{portion}.%{fset}.labeled]\ncond = %{portion in ('dev', 'test')}\ndep.model = out/%{corpus}.train.%{fset}.model\ndep.input = out/%{corpus}.%{portion}.feat\nrecipe = wapiti label -m %{model} %{input} &gt; %{target}\n</code></pre>\n<p>A matching condition is specified as the <code>cond</code> attribute. We can use any\nPython expression. It is evaluated only if the target pattern matches the\nrequested target. If it evaluates to a \u201ctruthy\u201d value, the rule matches and\nthe recipe is executed. If it evaluates to a \u201cfalsy\u201d value, the rule does\nnot match, and Produce moves on, trying to match the next rule in the\nProducefile.</p>\n<p>Note that the Python expression is given as an expansion. At this point we\nshould explain a few fine points:</p>\n<ol>\n<li>Whenever we used expansions so far, the variable names inside were actually\nPython expressions, albeit of a simple kind: single variable names. But as\nwe see now, we can use arbitrary Python expressions. Expansions used as\nwildcards in the target pattern are an exception, of course: they can only\nconsist of a single variable name.</li>\n<li>The variables we use in rules are actually Python variables.</li>\n<li>Attribute values are always strings, so if a Python expression is used to\ngenerate (part of) an attribute value, not the value of the expression\nitself is used but whatever its <code>__str__</code> method returns. Thus, in the\nabove rule, the value of the <code>cond</code> variable is not <code>True</code> or <code>False</code>, but\n<code>'True'</code> or <code>'False'</code>. In order to interpret the value as a Boolean, Produce\ncalls\n<a href=\"https://docs.python.org/3/library/ast.html?highlight=literal_eval#ast.literal_eval\" rel=\"nofollow\">ast.literal_eval</a>\non the string. So if the string contains anything other than a literal\nPython expression, this is an error.</li>\n</ol>\n<p>As an exception to what we said about <code>__str__</code>, if an expansion evaluates to\nsomething that is not a string but has an <code>__iter__</code> method, it will be treated\nas a sequence and rendered as a white-space separated list, the elements\nproperly shell-quoted and escaped. Note also that parentheses are automatically\nadded around an expansion so it is very convenient to use generator expressions\nfor expansions. All of this is illustrated in the following rule:</p>\n<pre><code>[Whole.txt]\ndeps = %{'Part {}.txt'.format(i) for i in range(4)}\nrecipe = cat %{deps} &gt; %{target}\n</code></pre>\n<h3>Special targets vs. special attributes</h3>\n<p>Besides not naming all dependencies, there is another reason why Make\u2019s syntax\nis too simple for its own good. When some rule needs to have a special\nproperty, Make usually requires a \u201cspecial target\u201d that syntactically looks\nlike a target but is actually a declaration and has no obvious visual\nconnection to the rule(s) it applies to. We have already seen an example of the\ndreaded <code>.SECONDEXPANSION</code>. Another common special target is <code>.PHONY</code>, marking\ntargets that are just jobs to be run, without producing an output file. For\nexample:</p>\n<pre><code>.PHONY: clean\nclean:\n\trm *.o temp\n</code></pre>\n<p>It would be easier and more logical if the \u201cphoniness\u201d was declared as part of\nthe rule rather than some external declaration. This is was Produce does. The\nProduce equivalent of declaring targets phony is to set the <code>type</code> attribute of\ntheir rule to <code>task</code> (the default is <code>file</code>). With this the rule above is\nwritten as follows:</p>\n<pre><code>[vacuum]\ntype = task\nrecipe = rm *.o temp\n</code></pre>\n<p>Note that since it is ungrammatical to \u201cproduce a clean\u201d, I invented a naming\nconvention according to which the task that cleans up your project directory is\ncalled <code>vacuum</code> because it produces a vacuum. It\u2019s silly, I know.</p>\n<p>For other special attributes besides <code>task</code>, see <a href=\"#all-special-attributes-at-a-glance\" rel=\"nofollow\">All special attributes at a\nglance</a> below.</p>\n<h3>Python expressions and global variables</h3>\n<p>As we have already seen, Produce\u2019s expansions can contain arbitrary Python\nexpressions. This is not only useful for specifying Boolean matching\nconditions, but also for string manipulation, in particular for playing with\ndependencies. This is a pain in Make, because Make implements its own string\nmanipulation language which from today\u2019s perspective (since we have Python)\nnot only reinvents the wheel, but reinvents it poorly, with a rather dangerous\nsyntax. Consider the following (contrived) example from the GNU Make manual\nwhere you have a list of dependencies in a global variable and filter them to\nretain only those ending in <code>.c</code> or <code>.s</code>:</p>\n<pre><code>sources := foo.c bar.c baz.s ugh.h\nfoo: $(sources)\n\tcc $(filter %.c %.s,$(sources)) -o foo\n</code></pre>\n<p>With Produce, we can just hand the string manipulation to Python, a language\nwe already know and (hopefully) like:</p>\n<pre><code>[]\nsources = foo.c bar.c baz.s ugh.h\n\n[foo]\ndeps = %{sources}\nrecipe = cc %{f for f in sources.split() \\\n\t\tif f.endswith('.c') or f.endswith('.s')}\n</code></pre>\n<p>This example also introduces the <em>global section</em>, a section headed by <code>[]</code>,\nthus named with the empty string. The attributes here define global variables\naccessible from all rules. The global section may only appear once and only at\nthe beginning of a Producefile.</p>\n<h2>Running Produce</h2>\n<p>Produce is invoked from the command line by the command <code>produce</code>, usually\nfollowed by the target(s) to produce. These can be omitted if the Producefile\nspecifies one or more default targets. By default, Produce will look for\n<code>produce.ini</code> in the current working directory and complain if it does not\nexist.</p>\n<p>A number of options can be used to control Produce\u2019s behavior, as listed in its\nhelp message:</p>\n<pre><code>usage: produce [-h] [-B | -b] [-d] [-f FILE] [-j JOBS] [-n] [-u FILE]\n               [target [target ...]]\n\npositional arguments:\n  target                The target(s) to produce - if omitted, default target\n                        from Producefile is used\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -B, --always-build    Unconditionally build all specified targets and their\n                        dependencies\n  -b, --always-build-specified\n                        Unconditionally build all specified targets, but treat\n                        their dependencies normally (only build if out of\n                        date)\n  -d, --debug           Print debugging information. Give this option multiple\n                        times for more information.\n  -f FILE, --file FILE  Use FILE as a Producefile\n  -j JOBS, --jobs JOBS  Specifies the number of jobs (recipes) to run\n                        simultaneously\n  -n, --dry-run         Print status messages, but do not run recipes\n  -u FILE, --pretend-up-to-date FILE\n                        Do not rebuild FILE or its dependencies (unless they\n                        are also depended on by other targets) even if out of\n                        date, but make sure that future invocations of Produce\n                        will still treat them as out of date by increasing the\n                        modification times of their changed dependencies as\n                        necessary.\n</code></pre>\n<h3>Status and debugging messages</h3>\n<p>When it starts (re)building a target, Produce will tell you so with a status\nmessage in green where the target is indented according to how deep in the\ndependency graph it is. On successful completion of a target, a similar message\nwith <code>complete</code> is printed. If an error occurs while a target is being built,\nProduce instead prints an <code>incomplete</code> message in red. The latter indicates\ncontrolled shutdown: the recipe has been killed and incomplete outputs have\nbeen renamed (see below). If you see a <code>(re)building</code> message but no\n<code>(in)complete</code> message for some target, something went really wrong \u2013 this\nshould never happen. In that case, better check for yourself if any incomplete\noutputs are still hanging around.</p>\n<p>Giving the <code>-d</code>/<code>--debug</code> option one, two or three times will cause Produce to\nadditionally flood your terminal with a few, some more or lots of messages that\nmay be helpful for debugging.</p>\n<h3>Error handling and aborting</h3>\n<p>When a recipe fails, i.e. its interpreter returns an exit status other than 0,\nthe corresponding target file (if any) may already have been created or\ntouched, potentially leading the next invocation of Produce to believe that it\nis up to date, even though it probably doesn\u2019t have the correct contents. Such\ninconsistencies can lead to users tearing their hair out. In order to avoid\nthis, Produce will, when a recipe fails, make sure that the target file does\nnot stay there. It could just delete it, but that might be unwise because the\nuser might want to inspect the output file of the erroneous recipe for\ndebugging. So, Produce renames the target file by appending a <code>~</code> to the\nfilename (a common naming convention for short-lived \u201cbackups\u201d).</p>\n<p>If multiple recipes are running in parallel and one fails, Produce will kill\nall of them, do the renaming and abort immediately.</p>\n<p>The same is true if Produce receives an interrupt signal. So you can safely\nabort a production process in your terminal by pressing <code>Ctrl+C</code>.</p>\n<h3>How targets are matched against rules</h3>\n<p>When producing a target, either because asked to by the user or because the\ntarget is required by another one, Produce will always work through the\nProducefile from top to bottom and use the first rule that matches the target.\nA rule matches a target if both the target pattern matches and the matching\ncondition (if any) subsequently evaluates to true.</p>\n<p>Note that unlike most INI dialects, Produce allows for multiple sections with\nthe same heading. It makes sense to have the same target pattern multiple times\nwhen there are matching conditions to make subdistinctions.</p>\n<p>If no rule matches a target, Produce aborts with an error message.</p>\n<h2>Advanced usage</h2>\n<h3>Whitespace and indentation in values</h3>\n<p>An attribute value can span multiple lines as long as each line after the first\nis indented with some whitespace. The recommended indentation is either one tab\nor four spaces. If you make use of this, it is recommended to leave the first\nline (after the attribute name and the <code>=</code>) blank so all lines of the value are\nconsistently aligned.</p>\n<p>The <em>second</em> line of a value (i.e. the first indented one) determines the kind\nand amount of whitespace expected to start each subsequent line. This\nwhitespace will <em>not</em> be part of the attribute value. <em>Additional</em> whitespace\nafter the initial amount is, however, preserved. This is important e.g. for\nPython code and the reason why Produce is no longer using Python\u2019s\n<code>configparser</code> module.</p>\n<p>All whitespace at the very beginning and at the very end of an attribute value\nwill be stripped away.</p>\n<p>For example, in the following rule, the recipe spans two lines:</p>\n<pre><code>[paper.pdf]\ndep.tex = paper.tex\ndep.bib = paper.bib\nrecipe =\n    pdflatex paper\n    pdflatex paper\n</code></pre>\n<h3>The prelude</h3>\n<p>If you use Python expressions in your recipes, you will often need to import\nPython modules or define functions to use in these expressions. You can do this\nby putting the imports, function definitions and other Python code into the\nspecial <code>prelude</code> attribute in the <a href=\"#python-expressions-and-global-variables\" rel=\"nofollow\">global\nsection</a>. For example, put this at\nthe beginning of your Producefile to import the <code>errno</code>, <code>glob</code> and <code>os</code>\nmodules and define a helper function for creating directories.</p>\n<pre><code>[]\nprelude =\n    import errno\n    import glob\n    import os\n\n    def makedirs(path):\n        try:\n            os.makedirs(path)\n        except OSError, error:\n            if error.errno != errno.EEXIST:\n                raise error\n</code></pre>\n<h3><code>shell</code>: choosing the recipe interpreter</h3>\n<p>By default, recipes are (after doing expansions) handed to the <code>bash</code> command\nfor execution. If you would rather write your recipe in <code>zsh</code>, <code>perl</code>, <code>python</code>\nor any other language, that\u2019s no problem. Just specify the interpreter in the\n<code>shell</code> attribute of the rule.</p>\n<h3>Running jobs in parallel</h3>\n<p>Use the <code>-j JOBS</code> command line option to specify the number of jobs Produce\nruns in parallel. By default, Produce reserves one job slot for each recipe.\nFor recipes that run multiple parallel jobs themselves, it is recommended to\nspecify the number of jobs via the <code>jobs</code> attribute. Produce will then reserve\nthat many job slots for this recipe (but no more than <code>JOBS</code>).</p>\n<p>Here is an example where the target <code>b</code> is created by a recipe that runs in\nparallel:</p>\n<pre><code>[a]\ndeps = b c d\nrecipe = touch %{target}\n\n[b]\ndep.input = input.txt\ndep.my_script = ./my_script.sh\njobs = 8\nrecipe = parallel --gnu -n %{jobs} -k %{my_script} %{input} &gt; %{target}\n\n[c]\ndep.my_script = ./my_script.sh\nrecipe = %{my_script} c &gt; %{target}\n\n[d]\ndep.my_script = ./my_script.sh\nrecipe = %{my_script} d &gt; %{target}\n</code></pre>\n<p>Running <code>produce -j 8 a</code> will run up to 8 jobs in parallel. In this example,\nthe recipes for <code>c</code> and <code>d</code> may run in parallel. The recipe for <code>b</code> will not\nrun in parallel with any other recipe because it uses all 8 job slots.</p>\n<h3>Dependency files</h3>\n<p>Sometimes the question which other files a file depends on is more complex and\nmay change frequently over the lifetime of a project, e.g. in the cases of\nsource files that import other header files, modules etc. In such cases, it\nwould be nice to have the dependencies automatically listed by a script.\nProduce supports this via the <code>depfile</code> attribute in rules: here, you can\nspecify the name of a <em>dependency file</em>, a text file that contains\ndependencies, one per line. Produce will read them and add them to the list of\ndependencies for the matched target. Also, Produce will try to produce the\ndependency file (i.e. make it up to date) <em>prior</em> to reading it. So you can\nwrite another rule that tells Produce how to generate each dependency file, and\nthe rest is automatic.</p>\n<p>For example, the following rule might be used to generate a dependency file\nlisting the source file and header files required for compiling a C object.\nThis example uses <code>.d</code> as the extension for dependency files. It runs <code>cc -MM</code>\nto use the C compiler\u2019s dependency discovery feature and then some shell magic\nto convert the output from a Makefile rule into a simple dependency list:</p>\n<pre><code>[%{name}.d]\ndep.c = %{name}.c\nrecipe =\n    cc -MM -I. %{name} | sed -e 's/.*: //' | sed -e 's/^ *//' | \\\n    perl -pe 's/ (\\\\\\n)?/\\n/g' &gt; %{target}\n</code></pre>\n<p>The following rule could then be used to create the actual object file. The\n<code>depfile</code> attribute makes sure that whenever an included header file changes,\nthe object file will be rebuilt:</p>\n<pre><code>[%{name}.o]\ndep.src = %{name}.c\ndepfile = %{name}.d\nrecipe =\n    cc -c -o %{target} %{src}\n</code></pre>\n<p>Note that the <code>.c</code> file will end up in the dependency list twice, once from\n<code>dep.src</code> and once from the dependency file. This does not matter, Produce is\nsmart enough not to do the same thing twice.</p>\n<p>Warning: dependency files are made up to date even in dry-run mode!</p>\n<h3>Rules with multiple outputs</h3>\n<p>Sometimes you have a command that creates multiple files at once because their\ncreation is inherently linked to the same process \u2013 it wouldn\u2019t make sense to\ntry and create them in neatly separated steps. Splitting a file up into\nmultiple chunks is such a case:</p>\n<pre><code>split -n 4 data.txt\n</code></pre>\n<p>This command creates four files called <code>xaa</code>, <code>xab</code>, <code>xac</code> and <code>xad</code>. It gets\ncomplicated when these output files individually are dependencies of further\ntargets, as in this example:</p>\n<pre><code>[split_and_zip]\ntype = task\ndeps = xaa.zip xab.zip xac.zip xad.zip\n\n[%{name}.zip]\ndep.file = %{name}\nrecipe = zip %{target} %{file}\n\n[%{chunk}]\ndep.txt = data.txt\nrecipe = split -n 4 %{txt}\n</code></pre>\n<p>If we run the task <code>split_and_zip</code>, it will try to create its (indirect)\ndependencies <code>xaa</code>, <code>xab</code>, <code>xac</code> and <code>xad</code> independently of each other. Each\ntime, the last rule will match, and each time, the exact same recipe will be\nexecuted. This is unncecessary work, one time would be sufficient because it\ncreates all four files in each case. Worse, if we run Produce in parallel,\nmultiple instances of the recipe may run in parallel and corrupt the data.</p>\n<p>The solution is to explicitly declare which files a rule produces, other than\nthe target. The <code>outputs</code> attribute serves this purpose. With it, the last rule\nis rewritten as follows:</p>\n<pre><code>[%{chunk}]\noutputs = xaa xab xac xad\ndep.txt = data.txt\nrecipe = split -n 4 %{txt}\n</code></pre>\n<p>Additionally, it is good style to add a matching condition to prevent that the\nrule accidentally matches something that is not its output:</p>\n<pre><code>[%{chunk}]\noutputs = xaa xab xac xad\ncond = %{target in outputs.split()}\ndep.txt = data.txt\nrecipe = split -n 4 %{txt}\n</code></pre>\n<p>Instead of a single <code>outputs</code> attribute, separate attributes with the <code>out.</code>\nprefix can be used, and both styles can also be mixed, similar to\n<code>dep.</code>/<code>deps</code>. Here is an example of a rule using the <code>out.</code> style to declare\nthat while producing a <code>.pdf</code> file it will also produce an <code>.aux</code> file:</p>\n<pre><code>[%{name}.pdf]\ndep.tex = %{name}.tex\nout.aux = %{name}.aux\nrecipe =\n    pdflatex %{tex}\n</code></pre>\n<h4>\u201cSideways\u201d dependencies</h4>\n<p>Suppose there is a target A that has some additional output file B. What if a\ntarget C wants to declare a dependency on B? For this to work, there must be a\nrule matching B. B, of course, is produced when A is produced. So, effectively,\nin order to produce B, A must be produced. We can express this as a dependency:\nB depends on A. You can write a rule that will tell Produce to produce A when B\nis requested:</p>\n<pre><code>[B]\ndep.a = A\n</code></pre>\n<p>(TODO: What if A is up to date but B does not exist?)</p>\n<p>Such a rule only serves to \u201cguide\u201d Produce from B to A. It cannot contain its\nown recipe. This would not make the sense as it is the rule for A that creates\nB. If you included a recipe, Produce would complain about a cyclic dependency.</p>\n<p>Here is a more concrete example: the rule for <code>paper.pdf</code> produces an\nadditional output <code>paper.aux</code>. Another rule, for <code>paper.info</code>, depends on\n<code>paper.aux</code>. In order for Produce to be able to satisfy this dependency,\n<code>paper.aux</code> is declared as depending on <code>paper.pdf</code>.</p>\n<pre><code>[paper.info]\ndep.aux = paper.aux\nrecipe = cat %{aux} | ./my_tool &gt; %{target}\n\n[paper.aux]\ndep.pdf = paper.pdf\n\n[paper.pdf]\ndep.tex = paper.tex\noutputs = paper.aux\nrecipe =\n    pdflatex paper\n</code></pre>\n<p>There is one final problem here: after running the recipe for <code>paper.pdf</code>, the\nmodification time of <code>paper.pdf</code> may well be greater than that of <code>paper.aux</code>.\nSince we declared <code>paper.aux</code> dependent on <code>paper.pdf</code>, this means that\n<code>paper.aux</code> appears as out of date to Produce even though we just produced it.\nA simple and effective way to prevent this is to include <code>touch %{outputs}</code> as\nthe last line of any rule with multiple outputs. The last rule above thus\nbecomes:</p>\n<pre><code>[paper.pdf]\ndep.tex = paper.tex\noutputs = paper.aux\nrecipe =\n    pdflatex paper\n    touch %{outputs}\n</code></pre>\n<h3>Producing the outputs for all inputs</h3>\n<p>Suppose you have a number of input files (say <code>inputs/input001.txt</code> to\n<code>inputs/input100.txt</code>). Each input can be processed to yield an output file\n(say <code>models/model001</code> to <code>models/model100</code>) \u2013 for example, by the following\nrule:</p>\n<pre><code>[models/model%{num}]\ndep.input = inputs/input%{num}.txt\ndep.train = bin/train\nrecipe = ./%{train} %{input} %{target}\n</code></pre>\n<p>Now you would like to automatically produce the model for every input that is\nthere. You can do this by writing a <em>task</em>, i.e., a rule for a target that is\nnot a file but is just invoked. The task for the example might look like this:</p>\n<pre><code>[all_models]\ntype = task\ndeps = %{'models/{}'.format(i.replace('input', 'model').replace('.txt, \\\n         '') for i in os.listdir('inputs')}\n</code></pre>\n<p>This task does not need a recipe because all it does is pull in all the models\nthrough its dependencies. The dependencies are specified through an arbitrary\nPython expression, in this case it looks at the inputs directory and returns\nthe names of the models corresponding to each input. It uses the <code>os</code> module,\nwhich needs to be imported. So let\u2019s add a global section with a prelude to do\nthis. The whole Producefile then looks like this:</p>\n<pre><code>[]\nprelude =\n    import os\n\n[models/model%{num}]\ndep.input = inputs/input%{num}.txt\ndep.train = bin/train\nrecipe = ./%{train} %{input} %{target}\n\n[all_models]\ntype = task\ndeps = %{'models/{}'.format(i.replace('input', 'model').replace('.txt, \\\n         '') for i in os.listdir('inputs')}\n</code></pre>\n<p>And to produce all models, all you need to do is tell Produce to produce the\n<code>all_models</code> task:</p>\n<pre><code>$ produce all_models\n</code></pre>\n<h2>All special attributes at a glance</h2>\n<p>For your reference, here are all the rule attributes that currently have a\nspecial meaning to Produce:</p>\n<h3>In rules</h3>\n<dl>\n    <dt><code>target</code></dt>\n    <dd>When a rule matches a target, this variable is always set to that\n    target, mainly so you can refer to it in the recipe. It is illegal to set\n    the <code>target</code> attribute yourself. Also see\n    <a href=\"#rules-expansions-escaping-and-comments\" rel=\"nofollow\">Rules, expansions, escaping and comments</a>.</dd>\n    <dt><code>cond</code></dt>\n    <dd>Allows to specify a _matching condition_ in addition to the target\n    pattern. Typically it is given as a single expansion with a boolean Python\n    expression. It is expanded immediately after a target matches the rule. The\n    resulting string must be a Python literal. If \u201ctruthy\u201d, the rule matches\n    and its expansion/execution continues. If \u201cfalsy\u201d, the rule does not match\n    the target and Produce proceeds with the next rule, trying to match the\n    target. Also see <a href=\"#multiple-wildcards-regular-expressions-and-matching-conditions\" rel=\"nofollow\">Multiple wildcards, regular expressions and matching conditions</a>.</dd>\n    <dt><code>dep.*</code></dt>\n    <dd>The asterisk stands for a name chosen by you, which is the actual name\n    of the variable the attribute value will be assigned to. The <code>dep.</code> prefix,\n    not part of the variable name, tells Produce that this is a dependency,\n    i.e. that the target given by the value must be made up to date before the\n    recipe of this rule can be run. Also see\n    <a href=\"#named-and-unnamed-dependencies\" rel=\"nofollow\">Named an unnamed depenencies</a>.</dd>\n    <dt><code>deps</code></dt>\n    <dd>Like <code>dep.*</code>, but allows for specifying multiple unnamed dependencies\n    in one attribute value. The format is roughly a space-separated list. For\n    details, see\n    <a href=\"https://docs.python.org/3/library/shlex.html?highlight=shlex#shlex.split\" rel=\"nofollow\"><code>shlex.split</code></a>.\n    Also see <a href=\"#named-and-unnamed-dependencies\" rel=\"nofollow\">Named an unnamed depenencies</a>.</dd>\n    <dt><code>depfile</code></dt>\n    <dd>Another way to specify (additional) dependencies: the name of a file\n    from which dependencies are read, one per line. Additionally, Produce will\n    try to make that file up to date prior to reading it. Also see\n    <a href=\"#dependency-files\" rel=\"nofollow\">Dependency files</a>.</dd>\n    <dt><code>type</code></dt>\n    <dd>Is either <code>file</code> (default) or <code>task</code>. If <code>file</code>, the target is supposed\n    to be a file that the recipe creates/updates if it runs successfully. If\n    <code>task</code>, the target is an arbitrary name given to some task that the recipe\n    executes. Crucially, task-type targets are always assumed to be out of\n    date, regardless of the possible existence and age of a file with the same\n    name. Also see\n    <a href=\"#special-targets-vs-special-attributes\" rel=\"nofollow\">Special targets vs. special attributes</a></dd>\n    <dt><code>recipe</code></dt>\n    <dd>The command(s) to run to build the target, typically a single shell\n    command or a short shell script. Unlike Make, each line is not run in\n    isolation, but the whole script is passed to the interpreter as a whole,\n    after doing expansions. This way, you can e.g. define a shell variable\n    on one line and use it on the next. Also see\n    <a href=\"#rules-expansions-escaping-and-comments\" rel=\"nofollow\">Rules, expansions, escaping and comments</a>.</dd>\n    <dt><code>shell</code></dt>\n    <dd>See <a href=\"#shell-choosing-the-recipe-interpreter\" rel=\"nofollow\"><code>shell</code>: choosing the recipe interpreter</a></dd>\n    <dt><code>out.*</code></dt>\n    <dd>See <a href=\"#rules-with-multiple-outputs\" rel=\"nofollow\">Rules with multiple outputs</a></dd>\n    <dt><code>outputs</code></dt>\n    <dd>See <a href=\"#rules-with-multiple-outputs\" rel=\"nofollow\">Rules with multiple outputs</a></dd>\n    <dt><code>jobs</code></dt>\n    <dd>See <a href=\"#running-jobs-in-parallel\" rel=\"nofollow\">Running jobs in parallel</a></dd>\n</dl>\n<h3>In the global section</h3>\n<dl>\n    <dt><code>default</code></dt>\n    <dd>A list\n    (parsed by <a href=\"https://docs.python.org/3/library/shlex.html?highlight=shlex#shlex.split\" rel=\"nofollow\"><code>shlex.split</code></a>)\n    of default targets that are produced if the user does not specify any\n    targets when calling Produce.</dd>\n    <dt><code>prelude</code></dt>\n    <dd>See <a href=\"#the-prelude\" rel=\"nofollow\">The prelude</a></dd>\n</dl>\n<h2>Getting in touch</h2>\n<p>Produce is being developed by Kilian Evang &lt;%{firstname}@%{lastname}.name&gt;.\nI would love to hear from you if you find it useful, if you have questions, bug\nreports or feature requests.</p>\n<h2>Acknowledgments</h2>\n<p>The Produce logo was designed by <a href=\"https://valeriobasile.github.io\" rel=\"nofollow\">Valerio Basile</a>.</p>\n\n          </div>"}, "last_serial": 7000588, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "c4f5faba00e8c559622063e66926bc49", "sha256": "265864c15a81bbb76079dbde2ed76da7746a312821ed92588d3919e2ec36c3d6"}, "downloads": -1, "filename": "produce-0.1-py3.6.egg", "has_sig": false, "md5_digest": "c4f5faba00e8c559622063e66926bc49", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": null, "size": 11144, "upload_time": "2019-04-17T16:42:24", "upload_time_iso_8601": "2019-04-17T16:42:24.950831Z", "url": "https://files.pythonhosted.org/packages/cb/a6/2c4511d909635e37f41be5652cbb656c858855c574b02a856c204586f656/produce-0.1-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "d6ea2a0bac84b007fa7d18296f3bea37", "sha256": "eb3b8f4f53a88cf893637b7cc0e81185f4674f5c3ecc6383960c365890f6637f"}, "downloads": -1, "filename": "produce-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "d6ea2a0bac84b007fa7d18296f3bea37", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12180, "upload_time": "2019-04-17T16:42:22", "upload_time_iso_8601": "2019-04-17T16:42:22.598580Z", "url": "https://files.pythonhosted.org/packages/b7/67/4f3492a893d8b9d0136f4a97e6977bbc733748c2146fa666f2d0cfc9e27c/produce-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e53efe874e0da43bf9db33ced4f0b654", "sha256": "8c614f5a4b42c63995ffe1534970c5e2f5abbdd29a740ec3367c5343ff93316e"}, "downloads": -1, "filename": "produce-0.1.tar.gz", "has_sig": false, "md5_digest": "e53efe874e0da43bf9db33ced4f0b654", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25941, "upload_time": "2019-04-17T16:42:26", "upload_time_iso_8601": "2019-04-17T16:42:26.506996Z", "url": "https://files.pythonhosted.org/packages/94/2a/d3e9ad1a88c0c6d2202a569402d26459dc4746656f3f6aa35ae8e7a18718/produce-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "f939936e9ddf54946cb3bf1158c563ae", "sha256": "bf83c766fb504c0fc7a6f9b43a52d6bd17471335c892f7bfbe8071e9ae0c3007"}, "downloads": -1, "filename": "produce-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "f939936e9ddf54946cb3bf1158c563ae", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12097, "upload_time": "2020-04-05T16:19:00", "upload_time_iso_8601": "2020-04-05T16:19:00.187005Z", "url": "https://files.pythonhosted.org/packages/73/08/3567c1728b679dea0c75e077db89c69ff8b2d56768644d8d3bcc0ee7e817/produce-0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "13a6f2570d6bd39ba0699a1e2bbbc7b6", "sha256": "ea0010ec61303ad36fe3d530b44709ed139f79f573e57d7b619537e4040537bb"}, "downloads": -1, "filename": "produce-0.2.tar.gz", "has_sig": false, "md5_digest": "13a6f2570d6bd39ba0699a1e2bbbc7b6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25758, "upload_time": "2020-04-05T16:19:02", "upload_time_iso_8601": "2020-04-05T16:19:02.447826Z", "url": "https://files.pythonhosted.org/packages/92/9f/c457d778cd90b1eaac809b74771a46b2a4a88ddde11f3ff7d5e961f16581/produce-0.2.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "a22006bb6ca3869cfc06dd4e89f5adb8", "sha256": "00e9523237e8169f0f4cbfd291c9c2fd7e02cc92cda693d75d8f9748388cf646"}, "downloads": -1, "filename": "produce-0.3.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a22006bb6ca3869cfc06dd4e89f5adb8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 27342, "upload_time": "2020-04-11T17:11:19", "upload_time_iso_8601": "2020-04-11T17:11:19.464188Z", "url": "https://files.pythonhosted.org/packages/cf/a4/3b635866e7eaaaec2153aeb55094930a96020827cdc0a56e8aeed9e8ea84/produce-0.3.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "92176b6a99ed88d14c0d356d790b05d3", "sha256": "c8cec212d3f2de1faa2a225cdcde5b4a586578b2acda47c7eab47ebdcb565614"}, "downloads": -1, "filename": "produce-0.3.1.tar.gz", "has_sig": false, "md5_digest": "92176b6a99ed88d14c0d356d790b05d3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56518, "upload_time": "2020-04-11T17:11:20", "upload_time_iso_8601": "2020-04-11T17:11:20.496906Z", "url": "https://files.pythonhosted.org/packages/00/0a/b37d519a93a58bb217307707814af03922792ca8b0f5ef7cd71e827b5cfa/produce-0.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a22006bb6ca3869cfc06dd4e89f5adb8", "sha256": "00e9523237e8169f0f4cbfd291c9c2fd7e02cc92cda693d75d8f9748388cf646"}, "downloads": -1, "filename": "produce-0.3.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a22006bb6ca3869cfc06dd4e89f5adb8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 27342, "upload_time": "2020-04-11T17:11:19", "upload_time_iso_8601": "2020-04-11T17:11:19.464188Z", "url": "https://files.pythonhosted.org/packages/cf/a4/3b635866e7eaaaec2153aeb55094930a96020827cdc0a56e8aeed9e8ea84/produce-0.3.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "92176b6a99ed88d14c0d356d790b05d3", "sha256": "c8cec212d3f2de1faa2a225cdcde5b4a586578b2acda47c7eab47ebdcb565614"}, "downloads": -1, "filename": "produce-0.3.1.tar.gz", "has_sig": false, "md5_digest": "92176b6a99ed88d14c0d356d790b05d3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56518, "upload_time": "2020-04-11T17:11:20", "upload_time_iso_8601": "2020-04-11T17:11:20.496906Z", "url": "https://files.pythonhosted.org/packages/00/0a/b37d519a93a58bb217307707814af03922792ca8b0f5ef7cd71e827b5cfa/produce-0.3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:18:48 2020"}