{"info": {"author": "Matthew Seal", "author_email": "mseal007@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Utilities"], "description": "[![Build Status](https://travis-ci.org/MSeal/py_cache_manager.svg?branch=master)](https://travis-ci.org/MSeal/py_cache_manager)\n\n# CacheMan\nA Python interface for managing dependent caches.\n\n'Ba-Bop-Ba-Dop-Bop'\n\n## Description\nThis module acts as a dependency manager for caches and is ideal for instances\nwhere a program has many repeated computations that could be safely persisted.\nThis usually entails a DB layer to house key value pairs. However, such a layer\nis sometimes overkill and managing a DB along with a project can be more effort\nthan it's worth. That's where CacheMan comes in and provides an interface\nthrough which you can define savers, loaders, builders, and dependencies with\ndisk-based defaults.\n\nBy default all caches will auto save when 10k changes occur over 60 seconds, 10\nchanges occur over 300 seconds (but after 60 seconds), or 1 change occurs within\n900 seconds (after 300 seconds). This behavior can be changed by instantiating\nan AutoSyncCache from the autosync submodule.\n\n## Dependencies\npsutil -- for asynchronous cache saving\n\n## Features\n* Drop in replacement for local memory dictionaries\n* Default persistent pickle caches\n* Non-persistent caching\n* Cache load/save/delete hooks w/ defaults\n* Cache validation hooks\n* Cache builder hooks\n* Dependent invalidation\n* Auto-Syncing caches\n\n## How to use\nBelow are some simple examples for how to use the repository.\n\n### Setting up a simple persistent cache\n    from cacheman import cacher\n\n    manager = cacher.get_cache_manager() # Optional manager name argument can be used here\n    cache = manager.register_cache('my_simple_cache') # You now have a cache!\n    print cache.get('my_key') # `None` first run, 'my_value' if this code was executed earlier\n    cache['my_key'] = 'my_value'\n    cache.save() # Changes are now persisted to disk\n    manager.save_cache_contents('my_simple_cache') # Alternative way to save a cache\n\n### Non-persistent caches\n    from cacheman import cacher\n\n    manager = cacher.get_cache_manager()\n    cache = manager.register_custom_cache('my_simple_cache', persistent=False) # You cache won't save to disk\n    cache.save() # This is a no-op\n\n### Registering hooks\n    from cacheman import cacher\n    from cacheman import cachewrap\n\n    def my_saver(cache_name, contents):\n        print(\"Save requested on {} cache content: {}\".format(cache_name, contents))\n\n    def my_loader(cache_name):\n        return { 'load': 'faked' }\n\n    manager = cacher.get_cache_manager()\n\n    cache = cachewrap.PersistentCache('my_cache', saver=my_saver, loader=my_loader)\n    # Can also use manager to set savers/loaders\n    #manager.retrieve_cache('my_cache')\n    #manager.register_saver('my_cache', my_saver)\n    #manager.register_loader('my_cache', my_loader)\n\n    cache.save() # Will print 'Save ... : { 'load': 'faked' }'\n    cache['new'] = 'real' # Add something to the cache\n    cache.save() # Will print 'Save ... : { 'load': 'faked', 'new': 'real' }'\n\n\n### Dependent caches\n    from cacheman import cacher\n\n    manager = cacher.get_cache_manager()\n    edge_cache = manager.retrieve_cache('edge_cache')\n    root_cache = manager.register_cache('root_cache')\n    manager.register_dependent_cache('root_cache', 'edge_cache')\n\n    def set_processed_value():\n        # Computes and caches 'processed' from root's 'raw' value\n        processed = edge_cache.get('processed')\n        if processed is None:\n            processed = (root_cache.get('raw') or 0) * 5\n            edge_cache['processed'] = processed\n        return processed\n\n    # A common problem with caching computed or dependent values:\n    print set_processed_value() # 0 without raw value\n    root_cache['raw'] = 1\n    print set_processed_value() # still 0 because it's cache in edge\n\n    # Now we use cache invalidation to tell downstream caches they're no longer valid\n    root_cache.invalidate() # Invalidates dependent caches\n    print edge_cache # Prints {} even though we only invalidated the root_cache\n    root_cache['raw'] = 1\n    print set_processed_value() # Now 5 because the edge was cleared before the request\n    print edge_cache # Can see {'processed': 5} propogated\n\n### Setting cache directory\n    from cacheman import cacher\n\n    # Default cache directory is '/tmp/general_cacher' or 'user\\appadata\\local\\temp\\general_cache'\n    # All pickle caches now save to namespaced directories within the base_cache_directory directory\n    manager = cacher.get_cache_manager(base_cache_directory='secret/cache/location')\n\n    cache = manager.register_cache('my_cache')\n    cache['new'] = 'real' # Add something to the cache\n    cache.save('my_cache') # Will save contents to 'secret/cache/location/general_cache/my_cache.pkl'\n\n## Navigating the Repo\n### cacheman\nPackage wrapper for the repo.\n\n### tests\nAll unit tests for the repo.\n\n## Language Preferences\n* Google Style Guide\n* Object Oriented (with a few exceptions)\n\n## TODO\nV2.1\n* cPickle with fallback to pickle by default\n* Better argument checks\n\n## Author\nAuthor(s): Matthew Seal\n\n&copy; Copyright 2013, [OpenGov](http://opengov.com)\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "https://github.com/MSeal/py_cache_manager/tarball/v2.1.0", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/MSeal/py_cache_manager", "keywords": "tables,data,analysis,extraction", "license": "New BSD", "maintainer": "", "maintainer_email": "", "name": "CacheMan", "package_url": "https://pypi.org/project/CacheMan/", "platform": "", "project_url": "https://pypi.org/project/CacheMan/", "project_urls": {"Download": "https://github.com/MSeal/py_cache_manager/tarball/v2.1.0", "Homepage": "https://github.com/MSeal/py_cache_manager"}, "release_url": "https://pypi.org/project/CacheMan/2.1.0/", "requires_dist": ["psutil (>=2.1.0)", "six (>=1.10.0)", "future (>=0.16.0)"], "requires_python": "", "summary": "A dependent cache manager", "version": "2.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            [![Build Status](https://travis-ci.org/MSeal/py_cache_manager.svg?branch=master)](https://travis-ci.org/MSeal/py_cache_manager)<br><br># CacheMan<br>A Python interface for managing dependent caches.<br><br>'Ba-Bop-Ba-Dop-Bop'<br><br>## Description<br>This module acts as a dependency manager for caches and is ideal for instances<br>where a program has many repeated computations that could be safely persisted.<br>This usually entails a DB layer to house key value pairs. However, such a layer<br>is sometimes overkill and managing a DB along with a project can be more effort<br>than it's worth. That's where CacheMan comes in and provides an interface<br>through which you can define savers, loaders, builders, and dependencies with<br>disk-based defaults.<br><br>By default all caches will auto save when 10k changes occur over 60 seconds, 10<br>changes occur over 300 seconds (but after 60 seconds), or 1 change occurs within<br>900 seconds (after 300 seconds). This behavior can be changed by instantiating<br>an AutoSyncCache from the autosync submodule.<br><br>## Dependencies<br>psutil -- for asynchronous cache saving<br><br>## Features<br>* Drop in replacement for local memory dictionaries<br>* Default persistent pickle caches<br>* Non-persistent caching<br>* Cache load/save/delete hooks w/ defaults<br>* Cache validation hooks<br>* Cache builder hooks<br>* Dependent invalidation<br>* Auto-Syncing caches<br><br>## How to use<br>Below are some simple examples for how to use the repository.<br><br>### Setting up a simple persistent cache<br>    from cacheman import cacher<br><br>    manager = cacher.get_cache_manager() # Optional manager name argument can be used here<br>    cache = manager.register_cache('my_simple_cache') # You now have a cache!<br>    print cache.get('my_key') # `None` first run, 'my_value' if this code was executed earlier<br>    cache['my_key'] = 'my_value'<br>    cache.save() # Changes are now persisted to disk<br>    manager.save_cache_contents('my_simple_cache') # Alternative way to save a cache<br><br>### Non-persistent caches<br>    from cacheman import cacher<br><br>    manager = cacher.get_cache_manager()<br>    cache = manager.register_custom_cache('my_simple_cache', persistent=False) # You cache won't save to disk<br>    cache.save() # This is a no-op<br><br>### Registering hooks<br>    from cacheman import cacher<br>    from cacheman import cachewrap<br><br>    def my_saver(cache_name, contents):<br>        print(\"Save requested on {} cache content: {}\".format(cache_name, contents))<br><br>    def my_loader(cache_name):<br>        return { 'load': 'faked' }<br><br>    manager = cacher.get_cache_manager()<br><br>    cache = cachewrap.PersistentCache('my_cache', saver=my_saver, loader=my_loader)<br>    # Can also use manager to set savers/loaders<br>    #manager.retrieve_cache('my_cache')<br>    #manager.register_saver('my_cache', my_saver)<br>    #manager.register_loader('my_cache', my_loader)<br><br>    cache.save() # Will print 'Save ... : { 'load': 'faked' }'<br>    cache['new'] = 'real' # Add something to the cache<br>    cache.save() # Will print 'Save ... : { 'load': 'faked', 'new': 'real' }'<br><br><br>### Dependent caches<br>    from cacheman import cacher<br><br>    manager = cacher.get_cache_manager()<br>    edge_cache = manager.retrieve_cache('edge_cache')<br>    root_cache = manager.register_cache('root_cache')<br>    manager.register_dependent_cache('root_cache', 'edge_cache')<br><br>    def set_processed_value():<br>        # Computes and caches 'processed' from root's 'raw' value<br>        processed = edge_cache.get('processed')<br>        if processed is None:<br>            processed = (root_cache.get('raw') or 0) * 5<br>            edge_cache['processed'] = processed<br>        return processed<br><br>    # A common problem with caching computed or dependent values:<br>    print set_processed_value() # 0 without raw value<br>    root_cache['raw'] = 1<br>    print set_processed_value() # still 0 because it's cache in edge<br><br>    # Now we use cache invalidation to tell downstream caches they're no longer valid<br>    root_cache.invalidate() # Invalidates dependent caches<br>    print edge_cache # Prints {} even though we only invalidated the root_cache<br>    root_cache['raw'] = 1<br>    print set_processed_value() # Now 5 because the edge was cleared before the request<br>    print edge_cache # Can see {'processed': 5} propogated<br><br>### Setting cache directory<br>    from cacheman import cacher<br><br>    # Default cache directory is '/tmp/general_cacher' or 'user\\appadata\\local\\temp\\general_cache'<br>    # All pickle caches now save to namespaced directories within the base_cache_directory directory<br>    manager = cacher.get_cache_manager(base_cache_directory='secret/cache/location')<br><br>    cache = manager.register_cache('my_cache')<br>    cache['new'] = 'real' # Add something to the cache<br>    cache.save('my_cache') # Will save contents to 'secret/cache/location/general_cache/my_cache.pkl'<br><br>## Navigating the Repo<br>### cacheman<br>Package wrapper for the repo.<br><br>### tests<br>All unit tests for the repo.<br><br>## Language Preferences<br>* Google Style Guide<br>* Object Oriented (with a few exceptions)<br><br>## TODO<br>V2.1<br>* cPickle with fallback to pickle by default<br>* Better argument checks<br><br>## Author<br>Author(s): Matthew Seal<br><br>&amp;copy; Copyright 2013, [OpenGov](http://opengov.com)<br><br><br>\n          </div>"}, "last_serial": 4039486, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "26f004c1bd3da0112b7da4e5c866c75e", "sha256": "526f99f8ad3e31c47122f2cac4d7290e3d5879b31e50999f63fcaf9a304cb9f3"}, "downloads": -1, "filename": "CacheMan-1.0.0.zip", "has_sig": false, "md5_digest": "26f004c1bd3da0112b7da4e5c866c75e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11553, "upload_time": "2014-04-04T21:54:35", "upload_time_iso_8601": "2014-04-04T21:54:35.298342Z", "url": "https://files.pythonhosted.org/packages/03/77/180ceecab5e4c77fb5028d9bd32308b7b076d9afa97bdf4be5efa7853552/CacheMan-1.0.0.zip", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "ac1b36a4c67a8bd99eaab48d90688f84", "sha256": "a7a49f9d47b4c63589536eea3fd8f0d6404560769c9d07757f6f001794d50669"}, "downloads": -1, "filename": "CacheMan-2.0.0.zip", "has_sig": false, "md5_digest": "ac1b36a4c67a8bd99eaab48d90688f84", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15615, "upload_time": "2014-04-25T17:31:31", "upload_time_iso_8601": "2014-04-25T17:31:31.541190Z", "url": "https://files.pythonhosted.org/packages/64/67/b13127ae61ba7713fa221cb5927a853632008ac6bea3c72852f1165715a7/CacheMan-2.0.0.zip", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "9b0d6de20bac44a8825c1d277a28b377", "sha256": "317775288b679e88b189f62c00b58b601dbbcb6e9b273fe7c2755d3436d8c4de"}, "downloads": -1, "filename": "CacheMan-2.0.1.zip", "has_sig": false, "md5_digest": "9b0d6de20bac44a8825c1d277a28b377", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16518, "upload_time": "2014-05-16T18:37:10", "upload_time_iso_8601": "2014-05-16T18:37:10.767899Z", "url": "https://files.pythonhosted.org/packages/6b/72/0f81e3e63b0d7d5d5ffe7e4cc2cf178e2acb3923894750f4e8443453dcd5/CacheMan-2.0.1.zip", "yanked": false}], "2.0.2": [{"comment_text": "", "digests": {"md5": "a3b76d7407d38a7caa56d932f4e9639c", "sha256": "667ae03a41aa4eaa1737963337856ec32c8ec5ba2c701ad16903a4ac633c548c"}, "downloads": -1, "filename": "CacheMan-2.0.2.zip", "has_sig": false, "md5_digest": "a3b76d7407d38a7caa56d932f4e9639c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17882, "upload_time": "2014-05-22T21:13:32", "upload_time_iso_8601": "2014-05-22T21:13:32.728244Z", "url": "https://files.pythonhosted.org/packages/c2/dc/a95800b27e1989a47397f4c843ac3a988f3fb6cc15f360aa6883bb379759/CacheMan-2.0.2.zip", "yanked": false}], "2.0.4": [{"comment_text": "", "digests": {"md5": "91d606ceab6a500909067bd493412272", "sha256": "f647149a56a9942359afd7a6fdc82b7d928cc1f81055b5fe9539da36de15b550"}, "downloads": -1, "filename": "CacheMan-2.0.4.zip", "has_sig": false, "md5_digest": "91d606ceab6a500909067bd493412272", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18888, "upload_time": "2015-02-18T23:40:38", "upload_time_iso_8601": "2015-02-18T23:40:38.618379Z", "url": "https://files.pythonhosted.org/packages/3d/fa/498589941afcaac623fcb7c80d7e7320e97810138c3fa4d08e0b4ad0ca77/CacheMan-2.0.4.zip", "yanked": false}], "2.0.5": [{"comment_text": "", "digests": {"md5": "98bc2bc74af1a09e71572c303bc3bbc6", "sha256": "354a9517aed0678a3a94baa7f242cfc5d57ddc54984122ba98c32e2095ecedd5"}, "downloads": -1, "filename": "CacheMan-2.0.5.zip", "has_sig": false, "md5_digest": "98bc2bc74af1a09e71572c303bc3bbc6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19008, "upload_time": "2015-09-07T09:00:08", "upload_time_iso_8601": "2015-09-07T09:00:08.902026Z", "url": "https://files.pythonhosted.org/packages/f6/3a/891b4e60ca37b50d93bb65977c09b055eccb6209df86c77ee05b9d46a641/CacheMan-2.0.5.zip", "yanked": false}], "2.0.6": [{"comment_text": "", "digests": {"md5": "f0bba91b80de8300a1de4ed96bcc7048", "sha256": "ef1039b2dd4cb9c9316913c0e4ea7a2a89539236d0a76ee257bfc1f317136831"}, "downloads": -1, "filename": "CacheMan-2.0.6.tar.gz", "has_sig": false, "md5_digest": "f0bba91b80de8300a1de4ed96bcc7048", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11900, "upload_time": "2017-04-02T04:01:50", "upload_time_iso_8601": "2017-04-02T04:01:50.648820Z", "url": "https://files.pythonhosted.org/packages/48/ea/d8effd51fb512514dfc501d734e988e6ad8f6fb0f6e30e9b1e3f6fb4c20b/CacheMan-2.0.6.tar.gz", "yanked": false}], "2.0.8": [{"comment_text": "", "digests": {"md5": "74d2a2ecea02567462795d4dad310e57", "sha256": "7e330dc2a9bbfb9672afeaa7bcaa6e8c29e479e86af73b39937ca43c2556f9fd"}, "downloads": -1, "filename": "CacheMan-2.0.8.tar.gz", "has_sig": false, "md5_digest": "74d2a2ecea02567462795d4dad310e57", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11740, "upload_time": "2018-01-23T05:27:39", "upload_time_iso_8601": "2018-01-23T05:27:39.240701Z", "url": "https://files.pythonhosted.org/packages/3e/d4/e825f4217c57ff027d0f3a5fe8896207888231d45bb2acfc36d2af5dcc57/CacheMan-2.0.8.tar.gz", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "f935f5682d9da83b27d23e92cbbc06b2", "sha256": "6b1f099ee58f86f52293f2eee475b3bf38746e9b6b6fe2f2fadd5a1fc99e7ec1"}, "downloads": -1, "filename": "CacheMan-2.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f935f5682d9da83b27d23e92cbbc06b2", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12528, "upload_time": "2018-07-07T20:47:47", "upload_time_iso_8601": "2018-07-07T20:47:47.367028Z", "url": "https://files.pythonhosted.org/packages/46/7a/d091d6337693ddb1fe1c15b18fdc1c750e0355aa79aa33268cdeaeea4458/CacheMan-2.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "430aaaa183f28bc42ab6ba3804e41aef", "sha256": "2cf7f74e7ad89230d4e0fa4d389b2fb40384fc05c968da595cfa2efafbd74dfd"}, "downloads": -1, "filename": "CacheMan-2.1.0.tar.gz", "has_sig": false, "md5_digest": "430aaaa183f28bc42ab6ba3804e41aef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11974, "upload_time": "2018-07-07T20:47:48", "upload_time_iso_8601": "2018-07-07T20:47:48.487723Z", "url": "https://files.pythonhosted.org/packages/62/fa/cd8c75d9e72f56964f15b8d86f30dcdb26ec3e6506871bbd7e5da0174343/CacheMan-2.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f935f5682d9da83b27d23e92cbbc06b2", "sha256": "6b1f099ee58f86f52293f2eee475b3bf38746e9b6b6fe2f2fadd5a1fc99e7ec1"}, "downloads": -1, "filename": "CacheMan-2.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f935f5682d9da83b27d23e92cbbc06b2", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12528, "upload_time": "2018-07-07T20:47:47", "upload_time_iso_8601": "2018-07-07T20:47:47.367028Z", "url": "https://files.pythonhosted.org/packages/46/7a/d091d6337693ddb1fe1c15b18fdc1c750e0355aa79aa33268cdeaeea4458/CacheMan-2.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "430aaaa183f28bc42ab6ba3804e41aef", "sha256": "2cf7f74e7ad89230d4e0fa4d389b2fb40384fc05c968da595cfa2efafbd74dfd"}, "downloads": -1, "filename": "CacheMan-2.1.0.tar.gz", "has_sig": false, "md5_digest": "430aaaa183f28bc42ab6ba3804e41aef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11974, "upload_time": "2018-07-07T20:47:48", "upload_time_iso_8601": "2018-07-07T20:47:48.487723Z", "url": "https://files.pythonhosted.org/packages/62/fa/cd8c75d9e72f56964f15b8d86f30dcdb26ec3e6506871bbd7e5da0174343/CacheMan-2.1.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:35:43 2020"}