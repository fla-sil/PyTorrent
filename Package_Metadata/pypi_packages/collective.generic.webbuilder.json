{"info": {"author": "Mathieu Pasquet, Jean-Philippe Camguilhem", "author_email": "kiorky@cryptelium.net, jean-philippe.camguilhem@makina-corpus.com", "bugtrack_url": null, "classifiers": ["Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "==========================\r\nIntroduction\r\n==========================\r\n\r\n.. contents::\r\n\r\n\r\nCGWB is a web interface to ``paster``, its goal is to generate a webinterface to selection options aggregated from a set of templates.\r\n\r\nImagine that you have 2 templates, the one that can deploy an application, and the other which generates the application in itself.\r\n\r\nDeclaring the two templates as a ``cgwb set`` will make a webinterface for those 2 templates. Answering correctly to the questions will produce a tarball that you ll be able download and unpack to have your base installation setup.\r\n\r\nTo make the templates available, you must define the set using ZCML.\r\n\r\n\r\nAs this server was developped as a quick and efficient interface to paster, *it is not safe to open it to wide internet.*\r\nFor security reason, just launch/use when you need it.\r\n\r\nNext versions will include some sessions/roles and improved security, it may be possible at this stage to leave it open.\r\n\r\n\r\nSee in action `here <http://cgwb-makinacorpus.rhcloud.com/>`_\r\n\r\n\r\n\r\nCredits\r\n=========================================\r\n\r\n\r\nCompanies\r\n----------------\r\n|makinacom|_\r\n\r\n* `Planet Makina Corpus <http://www.makina-corpus.org>`_\r\n* `Contact us <mailto:python@makina-corpus.org>`_\r\n\r\n.. |makinacom| image:: http://depot.makina-corpus.org/public/logo.gif\r\n.. _makinacom:  http://www.makina-corpus.com\r\n\r\nAuthors\r\n---------------\r\n\r\n    - kiorky <kiorky@cryptelium.net>\r\n    - Jean-Philippe Camguilhem <jpc@makina-corpus.com>\r\n\r\n\r\n\r\nInstallation\r\n==============\r\n\r\nInstalling cgwb in a minitage\r\n-----------------------------------\r\nYou are not obliged to run with `minitage`_ even if it is the recommended mode for running at least the plones template.\r\n\r\nAssuming that your minitage lives in ~/minitage, issue the following::\r\n\r\n    export MT=~/minitage\r\n\r\nInstall or udpate minitage in your dedicated virtualenv if any\r\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\nJust do that (you must refer to `minitage installation`_ for prerequisites)\r\n\r\nInstall virtualenv\r\n::\r\n\r\n    virtualenv --no-site-packages --distribute $MT\r\n\r\nUpdate minitage packages\r\n::\r\n\r\n    source $MT/bin/activate\r\n    easy_install -U minitage.core\r\n    easy_install -U minitage.paste\r\n    minimerge -s\r\n\r\n\r\nInstall cgwb\r\n++++++++++++++++++++++\r\nDownload & install via the minibuild\r\n::\r\n\r\n    source $MT/bin/activate\r\n    git clone http://github.com/collective/collective.generic.webbuilder-minilay.git $MT/minilays/cgwb\r\n    minimerge -v cgwb\r\n\r\n\r\nCgwb lives in ``$MT/bfg/cgwb``.\r\n\r\nGenerating & deploying your project using minitage\r\n-----------------------------------------------------------\r\nLaunching the cgwb server\r\n++++++++++++++++++++++++++++++++\r\nLaunch via ``bin/cgwb``.\r\nThis binary includes some options to let you override the default port (--port) and listenning address (--host)\r\nTo see all the available options, just use::\r\n\r\n    bin/cgwb --help\r\n\r\nIf you use minitage, mandatory to use the minitage.instances.env profile::\r\n\r\n    $MT/bin/easy_install -U minitage.paste\r\n    $MT/bin/paster create -t minitage.instances.env cgwb\r\n\r\nMINITAGE .ENV\r\n++++++++++++++++++++\r\nEach time you use cgwb, you use the .ENV::\r\n\r\n    source $MT/bfg/cgwb/sys/share/minitage/minitage.env\r\n\r\nUse it\r\n++++++++++++++\r\nLaunch it::\r\n\r\n    cd $INS\r\n    ./bin/cgwb --port=6253\r\n\r\n\r\n- At the moment, cgwb do not have some session mecanism, so the only way to replay a generation is to use the selenium firefox plugin.\r\n- If you want to store your choices to redo an updated tarball later, just install the SeleniumIDE firefox plugin and use it to record your session.\r\n- Maybe, activate selenium and\r\n\r\n    - Go to the `cgwb`_\r\n    - Choose `Generic Portal Plone3`.\r\n\r\nFilling the settings, some notes\r\n+++++++++++++++++++++++++++++++++++++++++++\r\n- project name is mandatory and must be in the form in `project` or `subproject`.\r\n- You can choose in the `Plone Products to auto checkout in development mode` the products from the community from which we should check out & use in development mode\r\n\r\nTHE IMPORTANT PART AROUND INITIATING A PROJECT\r\n+++++++++++++++++++++++++++++++++++++++++++++++++\r\n- It would be good unless you have some minitage experience to version the code prior to build, because of minitage update mecanism.\r\n- Before version/import the code in your SCM you must elude the following points:\r\n\r\n    * By default, the generated tarball contains the buildout layout and all the eggs in src, and the buildout use them as develop eggs and NOT WITH MR.DEVELOPER.\r\n      Thus for running the buildout in standalone mode\r\n    * You may decide not to include them as-is but to separate the code and version the code elsewhere.\r\n    * I would advice you to checkout the packages with mr.developer.\r\n\r\nAn example of using svn which generic/pyramid\r\n+++++++++++++++++++++++++++++++++++++++++++++\r\nWhat i would do from a generated tarball for using subversion as my SCM could be to produce this layout::\r\n\r\n    import\r\n    |-- import/eggs\r\n    |   |-- import/eggs/myproject.core\r\n    |   |   `-- import/eggs/myproject.core/trunk\r\n    `-- import/buildout\r\n\r\n\r\n- Exporting base variables::\r\n\r\n    export PROJECT=\"myproject\" # your project name as filled in the web interfacE\r\n    export TARBALL=\"$(ls -1t ~/cgwb/${PROJECT}-*.tar.gz|head -n1)\" # produced tarball\r\n    export IMPORT_URL=\"https://subversion.xxx.net/scrumpy/${PROJECT}/\" # base svn place to import\r\n\r\n- Create a temporary workspace::\r\n\r\n    mkdir -p  $PROJECT/tarball\r\n    cd $PROJECT\r\n    tar xzvf  $TARBALL -C tarball/\r\n\r\n- Create the base layout to be imported::\r\n\r\n    mkdir -p import/buildout import/eggs\r\n\r\n- Move the generated plone extensions eggs to a separate place to be imported::\r\n\r\n    for i in tarball/src/${PROJECT}*;do if [[ -d $i ]] && [[ $(basename $i) != \"themes\" ]];then j=$(basename $i);dest=import/eggs/$j/trunk; mkdir -pv  $(dirname $dest); mv -v $i $dest; fi; done\r\n\r\n- Move the buildout structure in the import layout::\r\n\r\n    cp -rf tarball/* import/buildout\r\n\r\n- Update buildout to use mr.developer instead of basic develop::\r\n\r\n    * move off the develop declaration::\r\n\r\n        sed -re \"s:(src/)?$PROJECT\\.((skin)|(tma)|(core)|(testing))::g\" -i import//buildout/etc/project/$PROJECT.cfg\r\n\r\n    * add to mr.developer sources::\r\n\r\n        sed -re \"/\\[sources\\]/{\r\n        a $PROJECT.core = svn $IMPORT_URL/eggs/$PROJECT.core/trunk\r\n        }\" -i import/buildout/etc/project/sources.cfg\r\n\r\n    * add to auto checkout packages::\r\n\r\n        sed -re \"/auto-checkout \\+=/{\r\n        a \\    $PROJECT.core\r\n        }\"  -i import/buildout/etc/project/sources.cfg\r\n        sed -re \"/eggs \\+=.*buildout:eggs/{\r\n        a \\    $PROJECT.core\r\n        }\"  -i import/buildout/etc/project/$PROJECT.cfg\r\n        sed -re \"/zcml \\+=/{\r\n        a \\    $PROJECT.core\r\n        }\"  -i import/buildout/etc/project/$PROJECT.cfg\r\n\r\n* be sure to use the right svn url to checkout::\r\n\r\n    sed -re \"s|src_uri.*|src_uri=$IMPORT_URL/buildout/|g\" -i import/buildout/minilays/$PROJECT/*\r\n\r\n* Be sure to use svn\r\n\r\n    sed -re \"s|src_type.*|src_type=svn|g\" -i import/buildout/minilays/$PROJECT/*\r\n\r\n* Import::\r\n\r\n   svn import import/ $IMPORT_URL -m \"initial import\" \r\n\r\nAn example of using svn which generic/plone\r\n+++++++++++++++++++++++++++++++++++++++++++++\r\nWhat i would do from a generated tarball for using subversion as my SCM could be to produce this layout::\r\n\r\n    import\r\n    |-- import/eggs\r\n    |   |-- import/eggs/myproject.policy\r\n    |   |   `-- import/eggs/myproject.policy/trunk\r\n    |   |-- import/eggs/myproject.skin\r\n    |   |   `-- import/eggs/myproject.skin/trunk\r\n    |   |-- import/eggs/myproject.testing\r\n    |   |   `-- import/eggs/myproject.testing/trunk\r\n    |   `-- import/eggs/myproject.tma\r\n    |       `-- import/eggs/myproject.tma/trunk\r\n    `-- import/minitage\r\n        |-- import/minitage/buildouts\r\n        |   `-- import/minitage/buildouts/zope\r\n        |       `-- import/minitage/buildouts/zope/myproject\r\n\r\n\r\n- Exporting base variables::\r\n\r\n    export PROJECT=\"myproject\" # your project name as filled in the web interfacE\r\n    export TARBALL=\"$(ls -1t ~/cgwb/${PROJECT}-*.tar.gz|head -n1)\" # produced tarball\r\n    export IMPORT_URL=\"https://subversion.xxx.net/scrumpy/${PROJECT}/ # base svn place to import\r\n\r\n- Create a temporary workspace::\r\n\r\n    mkdir -p  $PROJECT/tarball\r\n    cd $PROJECT\r\n    tar xzvf  $TARBALL -C tarball/\r\n\r\n- Create the base layout to be imported::\r\n\r\n    mkdir -p import/buildout import/eggs\r\n\r\n- Move the generated plone extensions eggs to a separate place to be imported::\r\n\r\n    for i in tarball/src/${PROJECT}*;do if [[ -d $i ]] && [[ $(basename $i) != \"themes\" ]];then j=$(basename $i);dest=import/eggs/$j/trunk; mkdir -pv  $(dirname $dest); mv -v $i $dest; fi; done\r\n\r\n- Move the buildout structure in the import layout::\r\n\r\n    cp -rf tarball/* import/buildout\r\n\r\n- Update buildout to use mr.developer instead of basic develop::\r\n\r\n    * move off the develop declaration::\r\n\r\n        sed -re \"s:(src/)?$PROJECT\\.((skin)|(tma)|(policy)|(testing))::g\" -i import//buildout/etc/project/$PROJECT.cfg\r\n\r\n    * add to mr.developer sources::\r\n\r\n        sed -re \"/\\[sources\\]/{\r\n        a $PROJECT.policy = svn $IMPORT_URL/eggs/$PROJECT.policy/trunk\r\n        a $PROJECT.tma = svn $IMPORT_URL/eggs/$PROJECT.tma/trunk\r\n        a $PROJECT.skin = svn $IMPORT_URL/eggs/$PROJECT.skin/trunk\r\n        a $PROJECT.testing = svn $IMPORT_URL/eggs/$PROJECT.testing/trunk\r\n        }\" -i import/buildout/etc/project/sources.cfg\r\n\r\n    * add to auto checkout packages::\r\n\r\n        sed -re \"/auto-checkout \\+=/{\r\n        a \\    $PROJECT.policy\r\n        a \\    $PROJECT.tma\r\n        a \\    $PROJECT.skin\r\n        a \\    $PROJECT.testing\r\n        }\"  -i import/buildout/etc/project/sources.cfg\r\n        sed -re \"/eggs \\+=.*buildout:eggs/{\r\n        a \\    $PROJECT.policy\r\n        a \\    $PROJECT.tma\r\n        a \\    $PROJECT.skin\r\n        a \\    $PROJECT.testing\r\n        }\"  -i import/buildout/etc/project/$PROJECT.cfg\r\n        sed -re \"/zcml \\+=/{\r\n        a \\    $PROJECT.policy\r\n        a \\    $PROJECT.tma\r\n        a \\    $PROJECT.skin\r\n        }\"  -i import/buildout/etc/project/$PROJECT.cfg\r\n\r\n* be sure to use the right svn url to checkout::\r\n\r\n    sed -re \"s|src_uri.*|src_uri=$IMPORT_URL/buildout/|g\" -i import/buildout/minilays/$PROJECT/*\r\n\r\n* Be sure to use svn\r\n\r\n    sed -re \"s|src_type.*|src_type=svn|g\" -i import/buildout/minilays/$PROJECT/*\r\n\r\n* Import::\r\n\r\n   svn import import/ $IMPORT_URL -m \"initial import\"\r\n\r\nAn example of using git which generic\r\n++++++++++++++++++++++++++++++++++++++++\r\nWhat i would do from a generated tarball for using subversion as my SCM could be to produce this layout::\r\n\r\n    import\r\n        |-- myproject.policy\r\n        |-- myproject.skin\r\n        |-- myproject.testing\r\n        `-- myproject.tma\r\n        `-- myproject.buildout\r\n        `-- myproject.minilay\r\n\r\n\r\n- Exporting base variables::\r\n\r\n    export PROJECT=\"myproject\"                                     # your project name as filled in the web interfacE\r\n    export TARBALL=\"$(ls -1t ~/cgwb/${PROJECT}-*.tar.gz|head -n1)\" # produced tarball\r\n    export IMPORT_URL=\"ssh://git.makina-corpus.net/var/git\"              # base svn place to import\r\n\r\n- Create a temporary workspace & the base layout to be imported::\r\n\r\n    mkdir -p  $PROJECT/\r\n    cd $PROJECT\r\n    mkdir tarball import\r\n    tar xzvf  $TARBALL -C tarball/\r\n\r\n- Move the generated plone extensions eggs to a separate place to be imported::\r\n\r\n    for i in tarball/src/*;do if [[ -d $i ]] && [[ $i != \"tarball/src/themes\" ]];then j=$(basename $i);dest=import/$j;mkdir -pv  $(dirname $dest); mv -v $i $dest; fi; done\r\n\r\n- Move the buildout structure in the import layout::\r\n\r\n    cp -rf tarball/minilays/$PROJECT   import/$PROJECT.minilay\r\n    rm -rf tarball/minilays\r\n    cp -rf tarball/ import/$PROJECT.buildout\r\n\r\n- Update buildout to use mr.developer instead of basic develop::\r\n\r\n    * move off the develop declaration::\r\n\r\n        sed -re \"s:(src/)?$PROJECT\\.((skin)|(tma)|(policy)|(testing))::g\" -i import/$PROJECT.buildout/etc/project/$PROJECT.cfg\r\n\r\n    * add to mr.developer sources::\r\n\r\n        sed -re \"/\\[sources\\]/{\r\n        a $PROJECT.policy =  git $IMPORT_URL/$PROJECT.policy\r\n        a $PROJECT.tma =     git $IMPORT_URL/$PROJECT.tma\r\n        a $PROJECT.skin =    git $IMPORT_URL/$PROJECT.skin\r\n        a $PROJECT.testing = git $IMPORT_URL/$PROJECT.testing\r\n        }\" -i import/$PROJECT.buildout/etc/project/sources.cfg\r\n\r\n    * add to auto checkout packages::\r\n\r\n        sed -re \"/auto-checkout \\+=/{\r\n        a \\    $PROJECT.policy\r\n        a \\    $PROJECT.tma\r\n        a \\    $PROJECT.skin\r\n        a \\    $PROJECT.testing\r\n        }\"  -i import/$PROJECT.buildout/etc/project/sources.cfg\r\n        sed -re \"/eggs \\+=.*buildout:eggs/{\r\n        a \\    $PROJECT.policy\r\n        a \\    $PROJECT.tma\r\n        a \\    $PROJECT.skin\r\n        a \\    $PROJECT.testing\r\n        }\"  -i import/$PROJECT.buildout/etc/project/$PROJECT.cfg\r\n        sed -re \"/zcml \\+=/{\r\n        a \\    $PROJECT.policy\r\n        a \\    $PROJECT.tma\r\n        a \\    $PROJECT.skin\r\n        }\"  -i import/$PROJECT.buildout/etc/project/$PROJECT.cfg\r\n\r\n* be sure to use the right git url to checkout::\r\n\r\n    sed -re \"s|src_uri.*|src_uri=$IMPORT_URL/$PROJECT.buildout|g\" -i import/*.minilay/*\r\n\r\n* Be sure to use git\r\n\r\n    sed -re \"s|src_type.*|src_type=git|g\" -i import/*.minilay/*\r\n\r\n* Import::\r\n\r\n   pushd import;for i in *;do echo \"Importing $i\";pushd $i;git init;git add *;git commit -am \"initial revision\";git remote add origin \"$IMPORT_URL/$i\";git push --all origin;popd;done;popd\r\n\r\nDeploy the project\r\n++++++++++++++++++++++\r\n* install the minilay::\r\n\r\n    export MT=~/minitage\r\n    svn co $IMPORT_URL/buildout/minilays/$PROJECT/ $MT/minilays/$PROJECT\r\n    # or\r\n    git clone  $IMPORT_URL/$PROJECT.minilay $MT/minilays/$PROJECT\r\n\r\n* Install it::\r\n\r\n    minimerge -v $PROJECT\r\n\r\n.. _`minitage installation`: http://minitage.org/installation.html\r\n.. _`cgwb`: http://localhost:6253\r\n.. _`minitage`: http://www.minitage.org\r\n\r\n\r\n\r\n\r\nTests & docs\r\n==============\r\nDefining sets via ZCML\r\n---------------------------------------------------\r\n\r\nA set is a collection of templates, it is also known as a 'PasterConfiguration'.\r\n::\r\n\r\n    -------------------------------------------\r\n    |\u00a0configuration                           |\r\n    |                                         |\r\n    |       -----------------------------------\r\n    |       |  templates                      |\r\n    |       -----------------------------------\r\n    |       |       |  group                  |\r\n    |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 [--------------------------\r\n    |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|      |  options         |\r\n    |       |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--------------------\r\n    |       |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\r\n    -------------------------------------------\r\n\r\n\r\nWe will redefine the 'well known' plone template as an example.\r\n\r\nFirst of all, we need to define a template\r\n::\r\n\r\n    >>> from zope.configuration import xmlconfig\r\n    >>> from zope.configuration.config import ConfigurationMachine\r\n    >>> from collective.generic.webbuilder.zcml import PasterConfiguration, Template, Group, ExcludeOption, Option\r\n    >>> from collective.generic.webbuilder.models import root\r\n    >>> from minitage.paste.projects import plone3\r\n    >>> import collective.generic.webbuilder\r\n    >>> context = ConfigurationMachine()\r\n    >>> xmlconfig.registerCommonDirectives(context)\r\n    >>> xmlconfig.include(context, 'meta.zcml', collective.generic.webbuilder)\r\n    >>> context = xmlconfig.string(\"\"\"\r\n    ... <configure xmlns=\"http://webbuilder.org/webbuilder\">\r\n    ...  <genericpaster name=\"Test Generic Portal Plone\">\r\n    ...    <!--<plugin name=\"dummy_plugin\" order=\"1\"/>-->\r\n    ...    <plugin name=\"egg_plugin\" order=\"2\"/>\r\n    ...    <template name=\"collective.generic.policy\" output=\"src\" order=\"200\">\r\n    ...       <excludeoptions prefix=\"project_.*\" />\r\n    ...       <excludeoption  name=\"python\" />\r\n    ...    </template>\r\n    ...    <template name=\"minitage.plone3\" order=\"1\">\r\n    ...       <group name=\"Minitage\" order=\"05\">\r\n    ...         <option name=\"install_method\" alias=\"ai\"/>\r\n    ...         <options prefix=\".*with.*\" default=\"true\" type=\"boolean\"/>\r\n    ...         <excludeoptions prefix=\"project_.*\" />\r\n    ...         <excludeoption  name=\"python\" />\r\n    ...       </group>\r\n    ...    </template>\r\n    ...  </genericpaster>\r\n    ... </configure>\r\n    ... \"\"\", context = context)\r\n\r\n\r\nIt will register/update the ``collective.generic.webbuilder.root.configurations`` module variable\r\n\r\nThe *genericpaster* directive\r\n++++++++++++++++++++++++++++++\r\n- Must be used at top level.\r\n- Name of a configuration of templates.\r\n\r\n::\r\n\r\n    <genericpaster name=\"Name of the configuration\"/>\r\n\r\nIt contains a list of underlying configurations\r\n::\r\n\r\n    >>> 'Test Generic Portal Plone' in root.configurations\r\n    True\r\n\r\nThe configurations objects contain a list of templates and plugins\r\n::\r\n\r\n    >>> templates = root.configurations['Test Generic Portal Plone'].templates\r\n    >>> sorted(templates.keys())\r\n    ['collective.generic.policy', 'minitage.plone3']\r\n\r\n\r\nThe *template* directive\r\n+++++++++++++++++++++++++\r\n- Must be used at genericpaster level.\r\n- It describe a relative \"paster template\". The name which you could get with ``paster create -t --list-templates``.\r\n- It has also an order which is used to order templates in the webinterface for lower to upper.\r\n\r\n::\r\n\r\n     <template name=\"Template Name\" order=\"int\">\r\n\r\n::\r\n\r\n    >>> t = templates['minitage.plone3']\r\n    >>> t.order\r\n    1\r\n    >>> t.name\r\n    'minitage.plone3'\r\n\r\n\r\nA template can also say that it must be generated under a 'subdirectory' with the ``output`` attribute.\r\n::\r\n\r\n    >>> templates['collective.generic.policy'].output\r\n    'src'\r\n\r\n\r\nThe *group* directive\r\n++++++++++++++++++++++\r\n- A template has a list of groups of options.\r\n- Groups are represented by a block of questions surrounded by the group name in the webinterface.\r\n\r\n::\r\n\r\n    <group name=\"GroupName\" order=\"int\"/>\r\n\r\nThose groups group 'paster questions'.\r\n\r\n::\r\n\r\n    >>> groups = t.groups\r\n    >>> groups.keys()\r\n    ['default', 'Minitage']\r\n    >>> g = t.groups['Minitage']\r\n    >>> t.groups['Minitage'].order\r\n    5\r\n    >>> t.groups['Minitage'].name\r\n    'Minitage'\r\n\r\nThe *options* directive\r\n++++++++++++++++++++++++\r\n- Must be used at group level.\r\n- Groups group options, Which can be grabbed by a regular expression with this directive.\r\n\r\n::\r\n\r\n    <options prefix=\"Regular expression\"  type=\"boolean|\" default=\"value\"/>\r\n\r\n- *type* can be omitted and defaults to None (text).\r\n- *default* can be omitted and no default value will be assigned (or the paster default value).\r\n\r\n::\r\n\r\n    >>> opts = g.options['.*with.*']\r\n    >>> opts.type, opts.default\r\n    ('boolean', 'true')\r\n\r\nAs you can see, there is a default group where go non-matched options which are not excluded via the ``excludeoptions`` directive.\r\n\r\n\r\nThe *option* directive\r\n++++++++++++++++++++++++\r\n- Must be used at group level.\r\n- Groups group also 'single options', Which can be grabbed by their name.\r\n- Single options and can have an alias. It is useful  if we have the same 'option name' in 2 templates of the configuration and we don't want that they share the same value (default behaviour). To be clear, we have the option 'project', in template 'a' and 'b', by default, if we choose 'foo' for 'project', the value will be 'foo' in template 'a' and 'b', and with an alias, we can choose the value for 'a' *_and_* for 'b'.\r\n\r\n::\r\n\r\n    <options name=\"name\" alias=\"alias name\"  type=\"boolean|\" default=\"value\"/>\r\n\r\n- *alias* can be omitted.\r\n- *type* can be omitted and defaults to None (text).\r\n- *default* can be omitted and no default value will be assigned (or the paster default value).\r\n\r\n::\r\n\r\n    >>> opt = g.single_options['install_method']\r\n    >>> opt.type, opt.alias, opt.default\r\n    (None, 'ai', None)\r\n\r\n\r\nThe *excludeoptions* & *excludeoption* directives\r\n+++++++++++++++++++++++++++++++++++++++++++++++++++\r\n- Must be used at group or template level (in any group of the template).\r\n\r\n::\r\n\r\n    <excludeoptions prefix=\"regular expression\"/>\r\n\r\n- exclude options from the interface\r\n- *prefix*: regular expression for the options to exclude.\r\n\r\n\r\n::\r\n\r\n    <excludeoption name=\"option name\"/>\r\n\r\n- exclude an option from the interface\r\n- *name*: name for the options to exclude.\r\n\r\n::\r\n\r\n    >>> [[getattr(templates[template].groups['default'], attr).keys() for attr in 'exclude_options', 'excludes_options'] for template in 'minitage.plone3', 'collective.generic.policy']\r\n    [[['python'], ['project_.*']], [['python'], ['project_.*']]]\r\n\r\n\r\nThe *plugin* directive\r\n++++++++++++++++++++++++\r\n- Must be used at template level.\r\n- Declare which plugin must run after the templates collection generation.\r\n- This is useful for example, to rearrange things which are generated.\r\n\r\nTo run a plugin which is declared  under \"plugin name\".\r\n::\r\n\r\n    <plugin name=\"plugin name\" order=\"int\"/>\r\n\r\n- *name*: name of the adapter\r\n- *order*: control order to run if there are more than one plugin\r\n\r\nA plugin, is a simple adapter which takes a IPasterAssembly and provides IPostGenerationPlugin\r\n::\r\n\r\n    <adapter\r\n      name=\"plugin name\"\r\n      provides=\".interfaces.IPostGenerationPlugin\"\r\n      factory=\".plugins.MyPluginFactory\"\r\n      for=\".interfaces.IPasterAssembly\"\r\n    />\r\n\r\n::\r\n\r\n    >>> plugins = root.configurations['Test Generic Portal Plone'].plugins\r\n    >>> plugins\r\n    [('egg_plugin', 2)]\r\n\r\n\r\n\r\nThe paster dance\r\n--------------------------\r\n\r\nHeart of cgwb is pythonpaste, take some of paster templates, gather them in an ihm for user inputs and answears for generating a final composition of those templates, with or without been modificated by surrounded plugins.\r\n::\r\n\r\n    User choose a configuration\r\n        --------->\r\n            read variables from templates which are in the configuration and give the appropriate choice to the user\r\n        ------------->\r\n                User inputs and submit it\r\n        -------------------->\r\n                    We generate a tarball of the assembled templates according to the answers\r\n\r\n* An option is asked only once, only you make aliases for each of the options which have the same name among templates.\r\n* As a question is asked only once, if its type is not default, you must define it in the configuration of the template which has the less order number, because there will be there the question will be asked.\r\n\r\n\r\nLoading a zcml representation of a configuration\r\n---------------------------------------------------\r\n\r\nTesting the zcml to python represetation\r\n+++++++++++++++++++++++++++++++++++++++++++++\r\n\r\nLoad our test package where we have three templates\r\n::\r\n\r\n    >>> import collective.generic.webbuilder.tests\r\n    >>> testegg = os.path.join( collective.generic.webbuilder.tests.__path__[0], 'egg', 'src')\r\n    >>> pkg_resources.working_set.add_entry(testegg)\r\n    >>> env = pkg_resources.Environment()\r\n    >>> egg = env['cgwb.tp'][0]\r\n\r\n\r\nWe have 3 templates in there waiting to be assembled\r\n::\r\n\r\n    >>> pprint(egg.get_entry_map())\r\n    {'paste.paster_create_template': {'cgwb.testpackage1': EntryPoint.parse('cgwb.testpackage1 = tp.package:Package'),\r\n                                      'cgwb.testpackage2': EntryPoint.parse('cgwb.testpackage2 = tp1.package:Package'),\r\n                                      'cgwb.testpackage3': EntryPoint.parse('cgwb.testpackage3 = tp2.package:Package')}}\r\n\r\n\r\nThe configuration\r\n+++++++++++++++++++\r\nIt is more described in the zcml part of the documentation, but it's a zcml representation of which variables from the pastertemplates we want to extract and how we want to present them to users.\r\n\r\n\r\nA sample zcml needed to assemble the packages we declared before is as follow:\r\n::\r\n\r\n    >>> paster_zcml = \"\"\"\r\n    ... <configure xmlns=\"http://namespaces.repoze.org/bfg\" xmlns:meta=\"http://namespaces.zope.org/meta\">\r\n    ...   <include package=\"collective.generic.webbuilder\" file=\"meta.zcml\"/>\r\n    ...   <configure xmlns=\"http://webbuilder.org/webbuilder\">\r\n    ...     <genericpaster name=\"test Assembler\">\r\n    ...         <template name=\"cgwb.testpackage1\" output=\"1\" order=\"1000\">\r\n    ...           <group name=\"Minitage\" order=\"05\">\r\n    ...             <option name=\"tp1option\" type=\"boolean\"/>\r\n    ...             <option name=\"tp1option3\" default=\"y\"/>\r\n    ...           </group>\r\n    ...         </template>\r\n    ...         <template name=\"cgwb.testpackage2\" output=\"2\" order=\"200\">\r\n    ...           <group name=\"Authors\" order=\"20\">\r\n    ...             <options prefix=\"^author.*\"/>\r\n    ...           </group>\r\n    ...           <excludeoptions prefix=\".*\"/>\r\n    ...         </template>\r\n    ...         <template name=\"cgwb.testpackage3\" output=\"3\" order=\"500\">\r\n    ...           <group name=\"Plone Settings\" order=\"8\">\r\n    ...             <option name=\"tp2opton2\" />\r\n    ...             <option name=\"author_email\" />\r\n    ...           </group>\r\n    ...           <group name=\"Authors\" order=\"20\">\r\n    ...             <options prefix=\"^author.*\"/>\r\n    ...           </group>\r\n    ...           <group name=\"Package tuning\" order=\"1\">\r\n    ...             <option name=\"project_name\" type=\"hidden\" default=\"tma\" alias=\"tmapn\"/>\r\n    ...           </group>\r\n    ...         </template>\r\n    ...     </genericpaster>\r\n    ...   </configure>\r\n    ... </configure>\r\n    ... \"\"\"\r\n    >>> noecho = xmlconfig.string(paster_zcml)\r\n    >>> root.configurations['test Assembler']\r\n    <collective.generic.webbuilder.zcml.PasterConfiguration object at ...>\r\n\r\n\r\nPasterAssembly object\r\n++++++++++++++++++++++++++++\r\nhave some \"log variables\" and the configuration name to search for in the \"bfgroot\".configurations dictionnary.\r\n\r\n\r\n    - ``template_data``: list of mappings in the form::\r\n\r\n        [\r\n        \u00a0{\r\n          'self': template 'zcml' object,\r\n          'name': paster template name,\r\n          'added_options': option added by this template,\r\n          'not_explicit_options': option added by this template which were not explicitly matched,\r\n          'display' : display a template or not\r\n          'groups':\r\n             {\r\n                groupname: \r\n                    {\r\n                        'name': groupname,\r\n                        'group': zcml group object:\r\n                        'options': [(paster variablen, type, optionn name, alias|None, zcml optionn|None )]\r\n                    }\r\n\r\n             },\r\n          'aliases': [ (varName, aliasName),]\r\n\r\n         }\r\n        ]\r\n\r\n\r\n    - ``added_options``: All options added for all templates\r\n\r\n\r\nGet an assembly for the wanted configuration\r\n::\r\n\r\n    >>> ta = gpaster.PasterAssembly('test Assembler')\r\n    >>> pprint(ta.__dict__.items())\r\n    [('templates_data', []),\r\n     ('configuration',\r\n      <collective.generic.webbuilder.zcml.PasterConfiguration object at ...>),\r\n     ('added_options', []),\r\n     ('configuration_name', 'test Assembler')]\r\n\r\nThe PasterAssemblyReader object\r\n+++++++++++++++++++++++++++++++++\r\nThis adapter takes as input a IPasterAssembly object and implements the IPasterAssemblyReader interface.\r\n\r\nWe have configurations stored into zcml representation, now we need to gather and map the configuration informations with the content of each \"paster template\" into a python friendly structure.\r\nThis Reader component is responsible for storing in the assembly object:\r\n\r\n    - The extracted template name\r\n    - Each group of options\r\n    - For each of those groups:\r\n\r\n        - The excluded options\r\n        - For the options which are not excluded, if applicable:\r\n\r\n          - making its alias\r\n          - Assign the default value\r\n\r\nWhat will finnally load the assembly data structures is a reader that now how to parse a configuration\r\n::\r\n\r\n    >>> reader = gpaster.PasterAssemblyReader(ta)\r\n    >>> reader.readed\r\n    False\r\n    >>> reader.read()\r\n    >>> len(ta.added_options) > 0\r\n    True\r\n    >>> reader.readed\r\n    True\r\n\r\n\r\nWe will check now that the structure loaded is as we wanted\r\n::\r\n\r\n    >>> t1 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage1')\r\n    >>> t2 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage2')\r\n    >>> t3 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage3')\r\n\r\n\r\nTemplates\r\n++++++++++\r\n\r\nOrder of templates is respected\r\n::\r\n\r\n    >>> [t['name'] for t in ta.templates_data]\r\n    ['cgwb.testpackage2', 'cgwb.testpackage3', 'cgwb.testpackage1']\r\n    >>> rt2, rt3, rt1 =  ta.templates_data\r\n\r\nGroups\r\n++++++\r\nOptions in template3, on the paster side, that we ll find on the next example\r\n::\r\n\r\n    >>> pprint([v.name for v in t3.vars])\r\n    ['namespace',\r\n     'nested_namespace',\r\n     'version',\r\n     'author',\r\n     'author_email',\r\n     'tp3option',\r\n     'tp3option3',\r\n     'keywords',\r\n     'license_name',\r\n     'project_name']\r\n\r\nFor each templates, options are grouped, and groups respect order defined in zcml::\r\n\r\n    >>> pprint([(rt3['groups'][n]['name'] , rt3['groups'][n]['options']) for n in range(len(rt3['groups']))])\r\n    [('Package tuning',\r\n      [(<var project_name default='tma' should_echo=True>,\r\n        'hidden',\r\n        'tmapn',\r\n        <collective.generic.webbuilder.zcml.Option object at ...>)]),\r\n     ('Plone Settings',\r\n      [(<var author_email default='bar@localhost' should_echo=True>,\r\n        'default',\r\n        None,\r\n        <collective.generic.webbuilder.zcml.Option object at ...>)]),\r\n     ('Authors',\r\n      [(<var author default='foo' should_echo=True>,\r\n        'default',\r\n        None,\r\n        <collective.generic.webbuilder.zcml.Options object at ...>)]),\r\n     ('default',\r\n      [(<var namespace default='%(namespace)s' should_echo=True>,\r\n        'default',\r\n        None,\r\n        None),\r\n       (<var nested_namespace default='%(package)s' should_echo=True>,\r\n        'default',\r\n        None,\r\n        None),\r\n       (<var version default='1.0' should_echo=True>, 'default', None, None),\r\n       (<var tp3option default='http://python.org' should_echo=True>,\r\n        'default',\r\n        None,\r\n        None),\r\n       (<var tp3option3 default='Project %s' should_echo=True>,\r\n        'default',\r\n        None,\r\n        None),\r\n       (<var keywords default='' should_echo=True>, 'default', None, None),\r\n       (<var license_name default='GPL' should_echo=True>,\r\n        'default',\r\n        None,\r\n        None)])]\r\n\r\n\r\nAs you can see project_name has been aliased and will be explained after.\r\n\r\n\r\nConsumed options\r\n+++++++++++++++++\r\nGoal is to insist loudly on consumed option.\r\nWhen an option is consumed by another template, it is not available in others to be asked only once.\r\nThat's why , template1 has no variables which were first asked in template3.\r\n::\r\n\r\n    >>> rt3options = []; noecho = [rt3options.extend(g['options']) for g in rt3['groups']]; rt3options = [opt[0].name for opt in rt3options]\r\n    >>> rtp1options = []; noecho = [rtp1options.extend(g['options']) for g in rt1['groups']]; rtp1options = [opt[0].name for opt in rtp1options]\r\n\r\nproject_name, author, etc. are not part of template1 options even if they are in the paster template.\r\nThey have been consumed by template3\r\n::\r\n\r\n    >>> pprint([v.name for v in t1.vars])\r\n    ['namespace',\r\n     'nested_namespace',\r\n     'version',\r\n     'author',\r\n     'author_email',\r\n     'tp1option',\r\n     'tp1option2',\r\n     'tp1option3',\r\n     'keywords',\r\n     'license_name',\r\n     'project_name']\r\n    >>> rt3options\r\n    ['project_name', 'author_email', 'author', 'namespace', 'nested_namespace', 'version', 'tp3option', 'tp3option3', 'keywords', 'license_name']\r\n    >>> rtp1options\r\n    ['tp1option', 'tp1option3', 'tp1option2', 'project_name']\r\n\r\nExcluded options\r\n+++++++++++++++++\r\n\r\nTemplate2 ignore all opions per default, even adding an option can't precedence over ignoring options.\r\nTake care of your regexes !\r\n::\r\n\r\n    >>> [g['options'] for g in rt2['groups']]\r\n    [[], []]\r\n\r\n\r\nTyped  options\r\n++++++++++++++++\r\n\r\nWe can assign type to values to use different widgets to display them in the UI for example.\r\nSupported types are:\r\n\r\n    - boolean (checkbox)\r\n    - hidden (hidden)\r\n    - default (textarea)\r\n\r\ntemplate3 define project_name as ``hidden``\r\n::\r\n\r\n    >>> rt3['groups'][0]['options'][0][1]\r\n    'hidden'\r\n\r\ntemplate1 define tp1option as ``boolean``.\r\n::\r\n\r\n    >>> rt1['groups'][0]['options'][0][1]\r\n    'boolean'\r\n\r\nIf an option default startswith 'y', 'true', or 'on', we switch the option type to boolean\r\n::\r\n\r\n    >>> rt1['groups'][0]['options'][1][1]\r\n    'boolean'\r\n\r\nOptions in the default group have ``default`` as type, as for options without explicit type\r\n::\r\n\r\n    >>> rt3[\"groups\"][3]['options'][0][1]\r\n    'default'\r\n    >>> rt3[\"groups\"][2]['options'][0][1]\r\n    'default'\r\n\r\nOption aliases\r\n+++++++++++++++\r\nWe have defined a default value and a default type for template3.project_name which is also an alias.\r\nAlias allow options with the same name but not the same value to exists within the same Assembly.\r\nDefault behaviour tells that one value is asked only once and used for all options that have the same name unless they are aliased explicitly each one of them.::\r\n\r\n    >>> rt3['groups'][0]['options']\r\n    [(<var project_name default='tma' should_echo=True>, 'hidden', 'tmapn', <collective.generic.webbuilder.zcml.Option object at ...>)]\r\n\r\n\r\nAdded options\r\n+++++++++++++\r\n\r\nWe can retrieve options added\r\n\r\n    * For one template ::\r\n\r\n        >>> rt1['added_options']\r\n        ['tp1option', 'tp1option2', 'tp1option3', 'project_name']\r\n        >>> rt2['added_options']\r\n        []\r\n        >>> rt3['added_options']\r\n        ['namespace', 'nested_namespace', 'version', 'author', 'author_email', 'tp3option', 'tp3option3', 'keywords', 'license_name', 'project_name']\r\n\r\n\r\n    * For all templates ::\r\n\r\n        >>> ta.added_options\r\n        ['namespace', 'nested_namespace', 'version', 'author', 'author_email', 'tp3option', 'tp3option3', 'keywords', 'license_name', 'tmapn', 'tp1option', 'tp1option2', 'tp1option3', 'project_name']\r\n\r\n\r\n\r\nCreating plugins to rearrange things after a successfull templates generation\r\n-------------------------------------------------------------------------------\r\n\r\n\r\n\r\nA plugin is a simple adapter\r\n++++++++++++++++++++++++++++\r\n\r\nCreating plugins to run after a generation is really simple.\r\nIt is just a matter of implementing an adapter which takes an ``\\IPasterConfiguration`` and provided ``IPostGenerationPlugin``.\r\n::\r\n\r\n    <adapter\r\n      name=\"plugin name\"\r\n      provides=\".interfaces.IPostGenerationPlugin\"\r\n      factory=\".plugins.MyPluginFactory\"\r\n      for=\".interfaces.IPasterAssembly\"\r\n    />\r\n\r\nThe eggs plugin\r\n+++++++++++++++++\r\n\r\nFor example, here is a simple plugin which take all eggs in a 'src' directory and register them in 'zcml' and 'develop' in the relative ''buildout.cfg''\r\nIt will add just the 'policy' egg to the intance's zcml option.\r\n\r\n\r\nBoiler plate to simulate a generation\r\n\r\n    >>> import tempfile, shutil, os\r\n    >>> c = os.getcwd()\r\n    >>> d = tempfile.mkdtemp()\r\n    >>> os.chdir(d)\r\n    >>> open('buildout.cfg', 'w').write('[buildout]\\ndevelop+=\\n   foo\\n[instance]\\nzcml=  too\\n')\r\n    >>> os.makedirs('src/bar/src')\r\n    >>> os.makedirs('src/policy/src')\r\n    >>> open('src/bar/setup.py', 'w').write('')\r\n    >>> open('src/policy/setup.py', 'w').write('')\r\n\r\nRunning the plugin\r\n\r\n    >>> from collective.generic.webbuilder.models import root\r\n    >>> conf = root.configurations['Generic Portal Plone3']\r\n    >>> from collective.generic.webbuilder import interfaces, paster\r\n    >>> pa = paster.PasterAssembly('Generic Portal Plone3')\r\n    >>> plugin = zope.component.queryAdapter(pa, interfaces.IPostGenerationPlugin, name='egg_plugin')\r\n    >>> plugin.process(d, 'foo', {})\r\n    >>> print open('buildout.cfg').read()\r\n    [buildout]\r\n    develop+=src/policy\r\n       src/bar\r\n       foo\r\n    eggs += policy\r\n            bar\r\n    [instance]\r\n    zcml=  too  \r\n                policy\r\n    <BLANKLINE>\r\n\r\nCleanup\r\n\r\n    >>> os.chdir(c);shutil.rmtree(d)\r\n\r\n\r\nRegistering plugins\r\n+++++++++++++++++++++\r\nPlease refer to the *plugin* zcml directive to know how to add plugins for a 'Configuration'.\r\n\r\nHere is an example about the \"eggs_plugins\"\r\n::\r\n\r\n    <configure xmlns=\"http://namespaces.repoze.org/bfg\"\r\n        xmlns:meta=\"http://namespaces.zope.org/meta\"\r\n        xmlns:cgwb=xmlns=\"http://webbuilder.org/webbuilder\">\r\n        <adapter\r\n            name=\"egg_plugin\"\r\n            provides=\".interfaces.IPostGenerationPlugin\"\r\n            factory=\".plugins.EggPlugin\"\r\n            for=\".interfaces.IPasterAssembly\"\r\n        />\r\n        <cgwb:genericpaster name=\"Generic Portal Plone\">\r\n            <cgwb:plugin name=\"egg_plugin\" order=\"2\"/>\r\n            <cgwb:template name=\"minitage.plone3\" order=\"1\">\r\n            </template>\r\n        </genericpaster>\r\n    </configure>\r\n\r\n\r\n\r\nThe paster dance\r\n--------------------------\r\n\r\nHeart of cgwb is pythonpaste, take some of paster templates, gather them in an ihm for user inputs and answears for generating a final composition of those templates, with or without been modificated by surrounded plugins.\r\n::\r\n\r\n    User choose a configuration\r\n        --------->\r\n            read variables from templates which are in the configuration and give the appropriate choice to the user\r\n        ------------->\r\n                User inputs and submit it\r\n        -------------------->\r\n                    We generate a tarball of the assembled templates according to the answers\r\n\r\n* An option is asked only once, only you make aliases for each of the options which have the same name among templates.\r\n* As a question is asked only once, if its type is not default, you must define it in the configuration of the template which has the less order number, because there will be there the question will be asked.\r\n\r\n\r\nLoading a zcml representation of a configuration\r\n---------------------------------------------------\r\n\r\nTesting the zcml to python represetation\r\n+++++++++++++++++++++++++++++++++++++++++++++\r\n\r\nLoad our test package where we have three templates\r\n::\r\n\r\n    >>> import collective.generic.webbuilder.tests\r\n    >>> testegg = os.path.join( collective.generic.webbuilder.tests.__path__[0], 'egg', 'src')\r\n    >>> pkg_resources.working_set.add_entry(testegg)\r\n    >>> env = pkg_resources.Environment()\r\n    >>> egg = env['cgwb.tp'][0]\r\n\r\nThe configuration\r\n+++++++++++++++++++\r\nIt is more described in the zcml part of the documentation, but it's a zcml representation of which variables from the pastertemplates we want to extract and how we want to present them to users.\r\n\r\n\r\nA sample zcml needed to assemble the packages we declared before is as follow:\r\n::\r\n\r\n    >>> paster_zcml = \"\"\"\r\n    ... <configure xmlns=\"http://namespaces.repoze.org/bfg\" xmlns:meta=\"http://namespaces.zope.org/meta\">\r\n    ...   <include package=\"collective.generic.webbuilder\" file=\"meta.zcml\"/>\r\n    ...   <configure xmlns=\"http://webbuilder.org/webbuilder\">\r\n    ...     <genericpaster name=\"test Assembler\">\r\n    ...         <template name=\"cgwb.testpackage1\" output=\"1\" order=\"1000\">\r\n    ...           <group name=\"Minitage\" order=\"05\">\r\n    ...             <option name=\"tp1option\" type=\"boolean\"/>\r\n    ...             <option name=\"tp1option3\" default=\"y\"/>\r\n    ...           </group>\r\n    ...         </template>\r\n    ...         <template name=\"cgwb.testpackage2\" output=\"2\" order=\"200\">\r\n    ...           <group name=\"Authors\" order=\"20\">\r\n    ...             <options prefix=\"^author.*\"/>\r\n    ...           </group>\r\n    ...           <excludeoptions prefix=\".*\"/>\r\n    ...         </template>\r\n    ...         <template name=\"cgwb.testpackage3\" output=\"3\" order=\"500\">\r\n    ...           <group name=\"Plone Settings\" order=\"8\">\r\n    ...             <option name=\"tp2opton2\" />\r\n    ...             <option name=\"author_email\" />\r\n    ...           </group>\r\n    ...           <group name=\"Authors\" order=\"20\">\r\n    ...             <options prefix=\"^author.*\"/>\r\n    ...           </group>\r\n    ...           <group name=\"Package tuning\" order=\"1\">\r\n    ...             <option name=\"project_name\" type=\"hidden\" default=\"tma\" alias=\"tmapn\"/>\r\n    ...           </group>\r\n    ...         </template>\r\n    ...     </genericpaster>\r\n    ...   </configure>\r\n    ... </configure>\r\n    ... \"\"\"\r\n    >>> noecho = xmlconfig.string(paster_zcml)\r\n    >>> root.configurations['test Assembler']\r\n    <collective.generic.webbuilder.zcml.PasterConfiguration object at ...>\r\n\r\nWe will check now that the structure loaded is as we wanted\r\n::\r\n\r\n    >>> t1 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage1')\r\n    >>> t2 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage2')\r\n    >>> t3 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage3')\r\n    >>> server, url = launch_server()\r\n    >>> browser = Browser(url)\r\n\r\nWe can see that in the main page we have the default configurations and the custom loaded one\r\n::\r\n\r\n    >>> 'test Assembler' in browser.contents\r\n    True\r\n    >>> 'Generic Portal Plone4' in browser.contents\r\n    True\r\n    >>> 'Generic Portal Plone3' in browser.contents\r\n    True\r\n\r\nFollowing the test assembler link\r\n::\r\n\r\n    >>> browser.getLink('test Assembler').click()\r\n    >>> htmlS(browser.contents).xpath('//input[@name=\"project\"]')[0]\r\n    <InputElement ... name='project' type='text'>\r\n\r\nI can submit a form and a valid it\r\n::\r\n\r\n    >>> browser.getControl(name='project').value = 'myproject'\r\n    >>> browser.getControl(name='author').value = 'tim burton'\r\n    >>> browser.getControl(name='author_email').value = 'tim burton@foo.com'\r\n    >>> browser.getControl(name='tp1option').value = False\r\n    >>> browser.getControl(name='tp1option2').value = 'Project Monster'\r\n    >>> browser.getControl(name='project_name').value = 'My Big Project'\r\n    >>> browser.getControl(name='submit_cgwbDownload').click()\r\n    >>> '.tar' in browser.contents\r\n    True\r\n\r\nThe sucessful produced result is a tarball\r\n::\r\n\r\n    >>> pprint(browser.headers.headers)\r\n    ['Server:...\r\n     'Date:...\r\n     'Content-Disposition: attachment; filename=\"myproject....tar.gz\"\\r\\n',\r\n     'Content-Transfer-Encoding: binary\\r\\n',\r\n     'Content-Length: ...\\r\\n']\r\n    >>> import tarfile\r\n    >>> tar = tarfile.open(fileobj=StringIO(browser.contents))\r\n\r\nIn the produced tarball, output directories present in the zcml configuration are respected in the tarball::\r\n\r\n    >>> files = [a.name for a in tar];files.sort();pprint(files)\r\n    ['.',\r\n     '1',\r\n     '1/myproject',\r\n     '1/myproject/test',\r\n     '2',\r\n     '2/myproject',\r\n     '2/myproject/test1',\r\n     '3',\r\n     '3/myproject',\r\n     '3/myproject/test2']\r\n    >>> templates = dict([(a.name,a) for a in tar if 'test' in a.name])\r\n    >>> t2 = templates['2/myproject/test1']\r\n    >>> t3 = templates['3/myproject/test2']\r\n    >>> t1 = templates['1/myproject/test']\r\n\r\nOptions filled in the interface are well interpreted in templates\r\n::\r\n\r\n    >>> pprint([a for a  in tar.extractfile(t1).read().split('\\n') if a.strip()])\r\n    ['namespace                 =>            %(namespace)s',\r\n     'nested_namespace          =>            %(package)s',\r\n     'version                   =>            1.0',\r\n     'author                    =>            tim burton',\r\n     'author_email              =>            tim burton@foo.com',\r\n     'tp1option                 =>            False',\r\n     'tp1option2                =>            Project Monster',\r\n     'tp1option3                =>            True',\r\n     'keywords                  =>            ',\r\n     'license_name              =>            GPL',\r\n     'project_name              =>            My Big Project']\r\n\r\nThe project_name entered for project1 is shared in project2\r\n::\r\n\r\n    >>> pprint([a for a  in tar.extractfile(t2).read().split('\\n') if a.strip()])\r\n    [\"'namespace'                =>         '%(namespace)s'\",\r\n     \"'nested_namespace'         =>         '%(package)s'\",\r\n     \"'version'                  =>         '1.0'\",\r\n     \"'author'                   =>         'tim burton'\",\r\n     \"'author_email'             =>         'tim burton@foo.com'\",\r\n     \"'keywords'                 =>         ''\",\r\n     \"'license_name'             =>         'GPL'\",\r\n     \"'project_name'             =>         'My Big Project'\",\r\n     \"'tp2option'                =>         'tp2option'\",\r\n     \"'tp2opton2'                =>         'tp2opton2'\"]\r\n\r\nthe aliased project_name (tma) takes efffect in the third template\r\n::\r\n\r\n    >>> pprint([a for a  in tar.extractfile(t3).read().split('\\n') if a.strip()])\r\n    [\"'namespace'                =>         '%(namespace)s'\",\r\n     \"'nested_namespace'         =>         '%(package)s'\",\r\n     \"'version'                  =>         '1.0'\",\r\n     \"'author'                   =>         'tim burton'\",\r\n     \"'author_email'             =>         'tim burton@foo.com'\",\r\n     \"'keywords'                 =>         ''\",\r\n     \"'license_name'             =>         'GPL'\",\r\n     \"'project_name'             =>         'tma'\",\r\n     \"'tp3option3'               =>         'Project %s'\",\r\n     \"'tp3option'                =>         'Project %s'\"]\r\n\r\n\r\n\r\n\r\nChangelog\r\n=========\r\n\r\n1.1\r\n----------\r\n\r\n* documentation, because webbuilder needs to be installed in dev mode, anyhow.\r\n\r\n1.0 \r\n----------------\r\n* Initial release", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/collective.generic.webbuilder", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "collective.generic.webbuilder", "package_url": "https://pypi.org/project/collective.generic.webbuilder/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/collective.generic.webbuilder/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/collective.generic.webbuilder"}, "release_url": "https://pypi.org/project/collective.generic.webbuilder/1.1/", "requires_dist": null, "requires_python": null, "summary": "Yet another WSGI Paste factory for paste by Makina Corpus", "version": "1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#credits\" id=\"id7\" rel=\"nofollow\">Credits</a><ul>\n<li><a href=\"#companies\" id=\"id8\" rel=\"nofollow\">Companies</a></li>\n<li><a href=\"#authors\" id=\"id9\" rel=\"nofollow\">Authors</a></li>\n</ul>\n</li>\n<li><a href=\"#installation\" id=\"id10\" rel=\"nofollow\">Installation</a><ul>\n<li><a href=\"#installing-cgwb-in-a-minitage\" id=\"id11\" rel=\"nofollow\">Installing cgwb in a minitage</a><ul>\n<li><a href=\"#install-or-udpate-minitage-in-your-dedicated-virtualenv-if-any\" id=\"id12\" rel=\"nofollow\">Install or udpate minitage in your dedicated virtualenv if any</a></li>\n<li><a href=\"#install-cgwb\" id=\"id13\" rel=\"nofollow\">Install cgwb</a></li>\n</ul>\n</li>\n<li><a href=\"#generating-deploying-your-project-using-minitage\" id=\"id14\" rel=\"nofollow\">Generating &amp; deploying your project using minitage</a><ul>\n<li><a href=\"#launching-the-cgwb-server\" id=\"id15\" rel=\"nofollow\">Launching the cgwb server</a></li>\n<li><a href=\"#minitage-env\" id=\"id16\" rel=\"nofollow\">MINITAGE .ENV</a></li>\n<li><a href=\"#use-it\" id=\"id17\" rel=\"nofollow\">Use it</a></li>\n<li><a href=\"#filling-the-settings-some-notes\" id=\"id18\" rel=\"nofollow\">Filling the settings, some notes</a></li>\n<li><a href=\"#the-important-part-around-initiating-a-project\" id=\"id19\" rel=\"nofollow\">THE IMPORTANT PART AROUND INITIATING A PROJECT</a></li>\n<li><a href=\"#an-example-of-using-svn-which-generic-pyramid\" id=\"id20\" rel=\"nofollow\">An example of using svn which generic/pyramid</a></li>\n<li><a href=\"#an-example-of-using-svn-which-generic-plone\" id=\"id21\" rel=\"nofollow\">An example of using svn which generic/plone</a></li>\n<li><a href=\"#an-example-of-using-git-which-generic\" id=\"id22\" rel=\"nofollow\">An example of using git which generic</a></li>\n<li><a href=\"#deploy-the-project\" id=\"id23\" rel=\"nofollow\">Deploy the project</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#tests-docs\" id=\"id24\" rel=\"nofollow\">Tests &amp; docs</a><ul>\n<li><a href=\"#defining-sets-via-zcml\" id=\"id25\" rel=\"nofollow\">Defining sets via ZCML</a><ul>\n<li><a href=\"#the-genericpaster-directive\" id=\"id26\" rel=\"nofollow\">The <em>genericpaster</em> directive</a></li>\n<li><a href=\"#the-template-directive\" id=\"id27\" rel=\"nofollow\">The <em>template</em> directive</a></li>\n<li><a href=\"#the-group-directive\" id=\"id28\" rel=\"nofollow\">The <em>group</em> directive</a></li>\n<li><a href=\"#the-options-directive\" id=\"id29\" rel=\"nofollow\">The <em>options</em> directive</a></li>\n<li><a href=\"#the-option-directive\" id=\"id30\" rel=\"nofollow\">The <em>option</em> directive</a></li>\n<li><a href=\"#the-excludeoptions-excludeoption-directives\" id=\"id31\" rel=\"nofollow\">The <em>excludeoptions</em> &amp; <em>excludeoption</em> directives</a></li>\n<li><a href=\"#the-plugin-directive\" id=\"id32\" rel=\"nofollow\">The <em>plugin</em> directive</a></li>\n</ul>\n</li>\n<li><a href=\"#the-paster-dance\" id=\"id33\" rel=\"nofollow\">The paster dance</a></li>\n<li><a href=\"#loading-a-zcml-representation-of-a-configuration\" id=\"id34\" rel=\"nofollow\">Loading a zcml representation of a configuration</a><ul>\n<li><a href=\"#testing-the-zcml-to-python-represetation\" id=\"id35\" rel=\"nofollow\">Testing the zcml to python represetation</a></li>\n<li><a href=\"#the-configuration\" id=\"id36\" rel=\"nofollow\">The configuration</a></li>\n<li><a href=\"#pasterassembly-object\" id=\"id37\" rel=\"nofollow\">PasterAssembly object</a></li>\n<li><a href=\"#the-pasterassemblyreader-object\" id=\"id38\" rel=\"nofollow\">The PasterAssemblyReader object</a></li>\n<li><a href=\"#templates\" id=\"id39\" rel=\"nofollow\">Templates</a></li>\n<li><a href=\"#groups\" id=\"id40\" rel=\"nofollow\">Groups</a></li>\n<li><a href=\"#consumed-options\" id=\"id41\" rel=\"nofollow\">Consumed options</a></li>\n<li><a href=\"#excluded-options\" id=\"id42\" rel=\"nofollow\">Excluded options</a></li>\n<li><a href=\"#typed-options\" id=\"id43\" rel=\"nofollow\">Typed  options</a></li>\n<li><a href=\"#option-aliases\" id=\"id44\" rel=\"nofollow\">Option aliases</a></li>\n<li><a href=\"#added-options\" id=\"id45\" rel=\"nofollow\">Added options</a></li>\n</ul>\n</li>\n<li><a href=\"#creating-plugins-to-rearrange-things-after-a-successfull-templates-generation\" id=\"id46\" rel=\"nofollow\">Creating plugins to rearrange things after a successfull templates generation</a><ul>\n<li><a href=\"#a-plugin-is-a-simple-adapter\" id=\"id47\" rel=\"nofollow\">A plugin is a simple adapter</a></li>\n<li><a href=\"#the-eggs-plugin\" id=\"id48\" rel=\"nofollow\">The eggs plugin</a></li>\n<li><a href=\"#registering-plugins\" id=\"id49\" rel=\"nofollow\">Registering plugins</a></li>\n</ul>\n</li>\n<li><a href=\"#id1\" id=\"id50\" rel=\"nofollow\">The paster dance</a></li>\n<li><a href=\"#id2\" id=\"id51\" rel=\"nofollow\">Loading a zcml representation of a configuration</a><ul>\n<li><a href=\"#id3\" id=\"id52\" rel=\"nofollow\">Testing the zcml to python represetation</a></li>\n<li><a href=\"#id4\" id=\"id53\" rel=\"nofollow\">The configuration</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#changelog\" id=\"id54\" rel=\"nofollow\">Changelog</a><ul>\n<li><a href=\"#id5\" id=\"id55\" rel=\"nofollow\">1.1</a></li>\n<li><a href=\"#id6\" id=\"id56\" rel=\"nofollow\">1.0</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<p>CGWB is a web interface to <tt>paster</tt>, its goal is to generate a webinterface to selection options aggregated from a set of templates.</p>\n<p>Imagine that you have 2 templates, the one that can deploy an application, and the other which generates the application in itself.</p>\n<p>Declaring the two templates as a <tt>cgwb set</tt> will make a webinterface for those 2 templates. Answering correctly to the questions will produce a tarball that you ll be able download and unpack to have your base installation setup.</p>\n<p>To make the templates available, you must define the set using ZCML.</p>\n<p>As this server was developped as a quick and efficient interface to paster, <em>it is not safe to open it to wide internet.</em>\nFor security reason, just launch/use when you need it.</p>\n<p>Next versions will include some sessions/roles and improved security, it may be possible at this stage to leave it open.</p>\n<p>See in action <a href=\"http://cgwb-makinacorpus.rhcloud.com/\" rel=\"nofollow\">here</a></p>\n<div id=\"credits\">\n<h2><a href=\"#id7\" rel=\"nofollow\">Credits</a></h2>\n<div id=\"companies\">\n<h3><a href=\"#id8\" rel=\"nofollow\">Companies</a></h3>\n<p><a href=\"http://www.makina-corpus.com\" rel=\"nofollow\"><img alt=\"makinacom\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2a7ff2c6fc5ab8cd2f425946f19dbfbf0aa4c1d7/687474703a2f2f6465706f742e6d616b696e612d636f727075732e6f72672f7075626c69632f6c6f676f2e676966\"></a></p>\n<ul>\n<li><a href=\"http://www.makina-corpus.org\" rel=\"nofollow\">Planet Makina Corpus</a></li>\n<li><a href=\"mailto:python%40makina-corpus.org\">Contact us</a></li>\n</ul>\n</div>\n<div id=\"authors\">\n<h3><a href=\"#id9\" rel=\"nofollow\">Authors</a></h3>\n<blockquote>\n<ul>\n<li>kiorky &lt;<a href=\"mailto:kiorky%40cryptelium.net\">kiorky<span>@</span>cryptelium<span>.</span>net</a>&gt;</li>\n<li>Jean-Philippe Camguilhem &lt;<a href=\"mailto:jpc%40makina-corpus.com\">jpc<span>@</span>makina-corpus<span>.</span>com</a>&gt;</li>\n</ul>\n</blockquote>\n</div>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Installation</a></h2>\n<div id=\"installing-cgwb-in-a-minitage\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Installing cgwb in a minitage</a></h3>\n<p>You are not obliged to run with <a href=\"http://www.minitage.org\" rel=\"nofollow\">minitage</a> even if it is the recommended mode for running at least the plones template.</p>\n<p>Assuming that your minitage lives in ~/minitage, issue the following:</p>\n<pre>export MT=~/minitage\n</pre>\n<div id=\"install-or-udpate-minitage-in-your-dedicated-virtualenv-if-any\">\n<h4><a href=\"#id12\" rel=\"nofollow\">Install or udpate minitage in your dedicated virtualenv if any</a></h4>\n<p>Just do that (you must refer to <a href=\"http://minitage.org/installation.html\" rel=\"nofollow\">minitage installation</a> for prerequisites)</p>\n<p>Install virtualenv</p>\n<pre>virtualenv --no-site-packages --distribute $MT\n</pre>\n<p>Update minitage packages</p>\n<pre>source $MT/bin/activate\neasy_install -U minitage.core\neasy_install -U minitage.paste\nminimerge -s\n</pre>\n</div>\n<div id=\"install-cgwb\">\n<h4><a href=\"#id13\" rel=\"nofollow\">Install cgwb</a></h4>\n<p>Download &amp; install via the minibuild</p>\n<pre>source $MT/bin/activate\ngit clone http://github.com/collective/collective.generic.webbuilder-minilay.git $MT/minilays/cgwb\nminimerge -v cgwb\n</pre>\n<p>Cgwb lives in <tt>$MT/bfg/cgwb</tt>.</p>\n</div>\n</div>\n<div id=\"generating-deploying-your-project-using-minitage\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Generating &amp; deploying your project using minitage</a></h3>\n<div id=\"launching-the-cgwb-server\">\n<h4><a href=\"#id15\" rel=\"nofollow\">Launching the cgwb server</a></h4>\n<p>Launch via <tt>bin/cgwb</tt>.\nThis binary includes some options to let you override the default port (\u2013port) and listenning address (\u2013host)\nTo see all the available options, just use:</p>\n<pre>bin/cgwb --help\n</pre>\n<p>If you use minitage, mandatory to use the minitage.instances.env profile:</p>\n<pre>$MT/bin/easy_install -U minitage.paste\n$MT/bin/paster create -t minitage.instances.env cgwb\n</pre>\n</div>\n<div id=\"minitage-env\">\n<h4><a href=\"#id16\" rel=\"nofollow\">MINITAGE .ENV</a></h4>\n<p>Each time you use cgwb, you use the .ENV:</p>\n<pre>source $MT/bfg/cgwb/sys/share/minitage/minitage.env\n</pre>\n</div>\n<div id=\"use-it\">\n<h4><a href=\"#id17\" rel=\"nofollow\">Use it</a></h4>\n<p>Launch it:</p>\n<pre>cd $INS\n./bin/cgwb --port=6253\n</pre>\n<ul>\n<li><p>At the moment, cgwb do not have some session mecanism, so the only way to replay a generation is to use the selenium firefox plugin.</p>\n</li>\n<li><p>If you want to store your choices to redo an updated tarball later, just install the SeleniumIDE firefox plugin and use it to record your session.</p>\n</li>\n<li><p>Maybe, activate selenium and</p>\n<blockquote>\n<ul>\n<li>Go to the <a href=\"http://localhost:6253\" rel=\"nofollow\">cgwb</a></li>\n<li>Choose <cite>Generic Portal Plone3</cite>.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</div>\n<div id=\"filling-the-settings-some-notes\">\n<h4><a href=\"#id18\" rel=\"nofollow\">Filling the settings, some notes</a></h4>\n<ul>\n<li>project name is mandatory and must be in the form in <cite>project</cite> or <cite>subproject</cite>.</li>\n<li>You can choose in the <cite>Plone Products to auto checkout in development mode</cite> the products from the community from which we should check out &amp; use in development mode</li>\n</ul>\n</div>\n<div id=\"the-important-part-around-initiating-a-project\">\n<h4><a href=\"#id19\" rel=\"nofollow\">THE IMPORTANT PART AROUND INITIATING A PROJECT</a></h4>\n<ul>\n<li><p>It would be good unless you have some minitage experience to version the code prior to build, because of minitage update mecanism.</p>\n</li>\n<li><p>Before version/import the code in your SCM you must elude the following points:</p>\n<blockquote>\n<ul>\n<li>By default, the generated tarball contains the buildout layout and all the eggs in src, and the buildout use them as develop eggs and NOT WITH MR.DEVELOPER.\nThus for running the buildout in standalone mode</li>\n<li>You may decide not to include them as-is but to separate the code and version the code elsewhere.</li>\n<li>I would advice you to checkout the packages with mr.developer.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</div>\n<div id=\"an-example-of-using-svn-which-generic-pyramid\">\n<h4><a href=\"#id20\" rel=\"nofollow\">An example of using svn which generic/pyramid</a></h4>\n<p>What i would do from a generated tarball for using subversion as my SCM could be to produce this layout:</p>\n<pre>import\n|-- import/eggs\n|   |-- import/eggs/myproject.core\n|   |   `-- import/eggs/myproject.core/trunk\n`-- import/buildout\n</pre>\n<ul>\n<li><p>Exporting base variables:</p>\n<pre>export PROJECT=\"myproject\" # your project name as filled in the web interfacE\nexport TARBALL=\"$(ls -1t ~/cgwb/${PROJECT}-*.tar.gz|head -n1)\" # produced tarball\nexport IMPORT_URL=\"https://subversion.xxx.net/scrumpy/${PROJECT}/\" # base svn place to import\n</pre>\n</li>\n<li><p>Create a temporary workspace:</p>\n<pre>mkdir -p  $PROJECT/tarball\ncd $PROJECT\ntar xzvf  $TARBALL -C tarball/\n</pre>\n</li>\n<li><p>Create the base layout to be imported:</p>\n<pre>mkdir -p import/buildout import/eggs\n</pre>\n</li>\n<li><p>Move the generated plone extensions eggs to a separate place to be imported:</p>\n<pre>for i in tarball/src/${PROJECT}*;do if [[ -d $i ]] &amp;&amp; [[ $(basename $i) != \"themes\" ]];then j=$(basename $i);dest=import/eggs/$j/trunk; mkdir -pv  $(dirname $dest); mv -v $i $dest; fi; done\n</pre>\n</li>\n<li><p>Move the buildout structure in the import layout:</p>\n<pre>cp -rf tarball/* import/buildout\n</pre>\n</li>\n<li><p>Update buildout to use mr.developer instead of basic develop:</p>\n<pre>* move off the develop declaration::\n\n    sed -re \"s:(src/)?$PROJECT\\.((skin)|(tma)|(core)|(testing))::g\" -i import//buildout/etc/project/$PROJECT.cfg\n\n* add to mr.developer sources::\n\n    sed -re \"/\\[sources\\]/{\n    a $PROJECT.core = svn $IMPORT_URL/eggs/$PROJECT.core/trunk\n    }\" -i import/buildout/etc/project/sources.cfg\n\n* add to auto checkout packages::\n\n    sed -re \"/auto-checkout \\+=/{\n    a \\    $PROJECT.core\n    }\"  -i import/buildout/etc/project/sources.cfg\n    sed -re \"/eggs \\+=.*buildout:eggs/{\n    a \\    $PROJECT.core\n    }\"  -i import/buildout/etc/project/$PROJECT.cfg\n    sed -re \"/zcml \\+=/{\n    a \\    $PROJECT.core\n    }\"  -i import/buildout/etc/project/$PROJECT.cfg\n</pre>\n</li>\n</ul>\n<ul>\n<li><p>be sure to use the right svn url to checkout:</p>\n<pre>sed -re \"s|src_uri.*|src_uri=$IMPORT_URL/buildout/|g\" -i import/buildout/minilays/$PROJECT/*\n</pre>\n</li>\n<li><p>Be sure to use svn</p>\n<blockquote>\n<p>sed -re \u201cs|src_type.*|src_type=svn|g\u201d -i import/buildout/minilays/$PROJECT/*</p>\n</blockquote>\n</li>\n<li><p>Import:</p>\n<pre>svn import import/ $IMPORT_URL -m \"initial import\"\n</pre>\n</li>\n</ul>\n</div>\n<div id=\"an-example-of-using-svn-which-generic-plone\">\n<h4><a href=\"#id21\" rel=\"nofollow\">An example of using svn which generic/plone</a></h4>\n<p>What i would do from a generated tarball for using subversion as my SCM could be to produce this layout:</p>\n<pre>import\n|-- import/eggs\n|   |-- import/eggs/myproject.policy\n|   |   `-- import/eggs/myproject.policy/trunk\n|   |-- import/eggs/myproject.skin\n|   |   `-- import/eggs/myproject.skin/trunk\n|   |-- import/eggs/myproject.testing\n|   |   `-- import/eggs/myproject.testing/trunk\n|   `-- import/eggs/myproject.tma\n|       `-- import/eggs/myproject.tma/trunk\n`-- import/minitage\n    |-- import/minitage/buildouts\n    |   `-- import/minitage/buildouts/zope\n    |       `-- import/minitage/buildouts/zope/myproject\n</pre>\n<ul>\n<li><p>Exporting base variables:</p>\n<pre>export PROJECT=\"myproject\" # your project name as filled in the web interfacE\nexport TARBALL=\"$(ls -1t ~/cgwb/${PROJECT}-*.tar.gz|head -n1)\" # produced tarball\nexport IMPORT_URL=\"https://subversion.xxx.net/scrumpy/${PROJECT}/ # base svn place to import\n</pre>\n</li>\n<li><p>Create a temporary workspace:</p>\n<pre>mkdir -p  $PROJECT/tarball\ncd $PROJECT\ntar xzvf  $TARBALL -C tarball/\n</pre>\n</li>\n<li><p>Create the base layout to be imported:</p>\n<pre>mkdir -p import/buildout import/eggs\n</pre>\n</li>\n<li><p>Move the generated plone extensions eggs to a separate place to be imported:</p>\n<pre>for i in tarball/src/${PROJECT}*;do if [[ -d $i ]] &amp;&amp; [[ $(basename $i) != \"themes\" ]];then j=$(basename $i);dest=import/eggs/$j/trunk; mkdir -pv  $(dirname $dest); mv -v $i $dest; fi; done\n</pre>\n</li>\n<li><p>Move the buildout structure in the import layout:</p>\n<pre>cp -rf tarball/* import/buildout\n</pre>\n</li>\n<li><p>Update buildout to use mr.developer instead of basic develop:</p>\n<pre>* move off the develop declaration::\n\n    sed -re \"s:(src/)?$PROJECT\\.((skin)|(tma)|(policy)|(testing))::g\" -i import//buildout/etc/project/$PROJECT.cfg\n\n* add to mr.developer sources::\n\n    sed -re \"/\\[sources\\]/{\n    a $PROJECT.policy = svn $IMPORT_URL/eggs/$PROJECT.policy/trunk\n    a $PROJECT.tma = svn $IMPORT_URL/eggs/$PROJECT.tma/trunk\n    a $PROJECT.skin = svn $IMPORT_URL/eggs/$PROJECT.skin/trunk\n    a $PROJECT.testing = svn $IMPORT_URL/eggs/$PROJECT.testing/trunk\n    }\" -i import/buildout/etc/project/sources.cfg\n\n* add to auto checkout packages::\n\n    sed -re \"/auto-checkout \\+=/{\n    a \\    $PROJECT.policy\n    a \\    $PROJECT.tma\n    a \\    $PROJECT.skin\n    a \\    $PROJECT.testing\n    }\"  -i import/buildout/etc/project/sources.cfg\n    sed -re \"/eggs \\+=.*buildout:eggs/{\n    a \\    $PROJECT.policy\n    a \\    $PROJECT.tma\n    a \\    $PROJECT.skin\n    a \\    $PROJECT.testing\n    }\"  -i import/buildout/etc/project/$PROJECT.cfg\n    sed -re \"/zcml \\+=/{\n    a \\    $PROJECT.policy\n    a \\    $PROJECT.tma\n    a \\    $PROJECT.skin\n    }\"  -i import/buildout/etc/project/$PROJECT.cfg\n</pre>\n</li>\n</ul>\n<ul>\n<li><p>be sure to use the right svn url to checkout:</p>\n<pre>sed -re \"s|src_uri.*|src_uri=$IMPORT_URL/buildout/|g\" -i import/buildout/minilays/$PROJECT/*\n</pre>\n</li>\n<li><p>Be sure to use svn</p>\n<blockquote>\n<p>sed -re \u201cs|src_type.*|src_type=svn|g\u201d -i import/buildout/minilays/$PROJECT/*</p>\n</blockquote>\n</li>\n<li><p>Import:</p>\n<pre>svn import import/ $IMPORT_URL -m \"initial import\"\n</pre>\n</li>\n</ul>\n</div>\n<div id=\"an-example-of-using-git-which-generic\">\n<h4><a href=\"#id22\" rel=\"nofollow\">An example of using git which generic</a></h4>\n<p>What i would do from a generated tarball for using subversion as my SCM could be to produce this layout:</p>\n<pre>import\n    |-- myproject.policy\n    |-- myproject.skin\n    |-- myproject.testing\n    `-- myproject.tma\n    `-- myproject.buildout\n    `-- myproject.minilay\n</pre>\n<ul>\n<li><p>Exporting base variables:</p>\n<pre>export PROJECT=\"myproject\"                                     # your project name as filled in the web interfacE\nexport TARBALL=\"$(ls -1t ~/cgwb/${PROJECT}-*.tar.gz|head -n1)\" # produced tarball\nexport IMPORT_URL=\"ssh://git.makina-corpus.net/var/git\"              # base svn place to import\n</pre>\n</li>\n<li><p>Create a temporary workspace &amp; the base layout to be imported:</p>\n<pre>mkdir -p  $PROJECT/\ncd $PROJECT\nmkdir tarball import\ntar xzvf  $TARBALL -C tarball/\n</pre>\n</li>\n<li><p>Move the generated plone extensions eggs to a separate place to be imported:</p>\n<pre>for i in tarball/src/*;do if [[ -d $i ]] &amp;&amp; [[ $i != \"tarball/src/themes\" ]];then j=$(basename $i);dest=import/$j;mkdir -pv  $(dirname $dest); mv -v $i $dest; fi; done\n</pre>\n</li>\n<li><p>Move the buildout structure in the import layout:</p>\n<pre>cp -rf tarball/minilays/$PROJECT   import/$PROJECT.minilay\nrm -rf tarball/minilays\ncp -rf tarball/ import/$PROJECT.buildout\n</pre>\n</li>\n<li><p>Update buildout to use mr.developer instead of basic develop:</p>\n<pre>* move off the develop declaration::\n\n    sed -re \"s:(src/)?$PROJECT\\.((skin)|(tma)|(policy)|(testing))::g\" -i import/$PROJECT.buildout/etc/project/$PROJECT.cfg\n\n* add to mr.developer sources::\n\n    sed -re \"/\\[sources\\]/{\n    a $PROJECT.policy =  git $IMPORT_URL/$PROJECT.policy\n    a $PROJECT.tma =     git $IMPORT_URL/$PROJECT.tma\n    a $PROJECT.skin =    git $IMPORT_URL/$PROJECT.skin\n    a $PROJECT.testing = git $IMPORT_URL/$PROJECT.testing\n    }\" -i import/$PROJECT.buildout/etc/project/sources.cfg\n\n* add to auto checkout packages::\n\n    sed -re \"/auto-checkout \\+=/{\n    a \\    $PROJECT.policy\n    a \\    $PROJECT.tma\n    a \\    $PROJECT.skin\n    a \\    $PROJECT.testing\n    }\"  -i import/$PROJECT.buildout/etc/project/sources.cfg\n    sed -re \"/eggs \\+=.*buildout:eggs/{\n    a \\    $PROJECT.policy\n    a \\    $PROJECT.tma\n    a \\    $PROJECT.skin\n    a \\    $PROJECT.testing\n    }\"  -i import/$PROJECT.buildout/etc/project/$PROJECT.cfg\n    sed -re \"/zcml \\+=/{\n    a \\    $PROJECT.policy\n    a \\    $PROJECT.tma\n    a \\    $PROJECT.skin\n    }\"  -i import/$PROJECT.buildout/etc/project/$PROJECT.cfg\n</pre>\n</li>\n</ul>\n<ul>\n<li><p>be sure to use the right git url to checkout:</p>\n<pre>sed -re \"s|src_uri.*|src_uri=$IMPORT_URL/$PROJECT.buildout|g\" -i import/*.minilay/*\n</pre>\n</li>\n<li><p>Be sure to use git</p>\n<blockquote>\n<p>sed -re \u201cs|src_type.*|src_type=git|g\u201d -i import/<em>.minilay/</em></p>\n</blockquote>\n</li>\n<li><p>Import:</p>\n<pre>pushd import;for i in *;do echo \"Importing $i\";pushd $i;git init;git add *;git commit -am \"initial revision\";git remote add origin \"$IMPORT_URL/$i\";git push --all origin;popd;done;popd\n</pre>\n</li>\n</ul>\n</div>\n<div id=\"deploy-the-project\">\n<h4><a href=\"#id23\" rel=\"nofollow\">Deploy the project</a></h4>\n<ul>\n<li><p>install the minilay:</p>\n<pre>export MT=~/minitage\nsvn co $IMPORT_URL/buildout/minilays/$PROJECT/ $MT/minilays/$PROJECT\n# or\ngit clone  $IMPORT_URL/$PROJECT.minilay $MT/minilays/$PROJECT\n</pre>\n</li>\n<li><p>Install it:</p>\n<pre>minimerge -v $PROJECT\n</pre>\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div id=\"tests-docs\">\n<h2><a href=\"#id24\" rel=\"nofollow\">Tests &amp; docs</a></h2>\n<div id=\"defining-sets-via-zcml\">\n<h3><a href=\"#id25\" rel=\"nofollow\">Defining sets via ZCML</a></h3>\n<p>A set is a collection of templates, it is also known as a \u2018PasterConfiguration\u2019.</p>\n<pre>-------------------------------------------\n|\u00a0configuration                           |\n|                                         |\n|       -----------------------------------\n|       |  templates                      |\n|       -----------------------------------\n|       |       |  group                  |\n|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 [--------------------------\n|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|      |  options         |\n|       |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--------------------\n|       |\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\n-------------------------------------------\n</pre>\n<p>We will redefine the \u2018well known\u2019 plone template as an example.</p>\n<p>First of all, we need to define a template</p>\n<pre>&gt;&gt;&gt; from zope.configuration import xmlconfig\n&gt;&gt;&gt; from zope.configuration.config import ConfigurationMachine\n&gt;&gt;&gt; from collective.generic.webbuilder.zcml import PasterConfiguration, Template, Group, ExcludeOption, Option\n&gt;&gt;&gt; from collective.generic.webbuilder.models import root\n&gt;&gt;&gt; from minitage.paste.projects import plone3\n&gt;&gt;&gt; import collective.generic.webbuilder\n&gt;&gt;&gt; context = ConfigurationMachine()\n&gt;&gt;&gt; xmlconfig.registerCommonDirectives(context)\n&gt;&gt;&gt; xmlconfig.include(context, 'meta.zcml', collective.generic.webbuilder)\n&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure xmlns=\"http://webbuilder.org/webbuilder\"&gt;\n...  &lt;genericpaster name=\"Test Generic Portal Plone\"&gt;\n...    &lt;!--&lt;plugin name=\"dummy_plugin\" order=\"1\"/&gt;--&gt;\n...    &lt;plugin name=\"egg_plugin\" order=\"2\"/&gt;\n...    &lt;template name=\"collective.generic.policy\" output=\"src\" order=\"200\"&gt;\n...       &lt;excludeoptions prefix=\"project_.*\" /&gt;\n...       &lt;excludeoption  name=\"python\" /&gt;\n...    &lt;/template&gt;\n...    &lt;template name=\"minitage.plone3\" order=\"1\"&gt;\n...       &lt;group name=\"Minitage\" order=\"05\"&gt;\n...         &lt;option name=\"install_method\" alias=\"ai\"/&gt;\n...         &lt;options prefix=\".*with.*\" default=\"true\" type=\"boolean\"/&gt;\n...         &lt;excludeoptions prefix=\"project_.*\" /&gt;\n...         &lt;excludeoption  name=\"python\" /&gt;\n...       &lt;/group&gt;\n...    &lt;/template&gt;\n...  &lt;/genericpaster&gt;\n... &lt;/configure&gt;\n... \"\"\", context = context)\n</pre>\n<p>It will register/update the <tt>collective.generic.webbuilder.root.configurations</tt> module variable</p>\n<div id=\"the-genericpaster-directive\">\n<h4><a href=\"#id26\" rel=\"nofollow\">The <em>genericpaster</em> directive</a></h4>\n<ul>\n<li>Must be used at top level.</li>\n<li>Name of a configuration of templates.</li>\n</ul>\n<pre>&lt;genericpaster name=\"Name of the configuration\"/&gt;\n</pre>\n<p>It contains a list of underlying configurations</p>\n<pre>&gt;&gt;&gt; 'Test Generic Portal Plone' in root.configurations\nTrue\n</pre>\n<p>The configurations objects contain a list of templates and plugins</p>\n<pre>&gt;&gt;&gt; templates = root.configurations['Test Generic Portal Plone'].templates\n&gt;&gt;&gt; sorted(templates.keys())\n['collective.generic.policy', 'minitage.plone3']\n</pre>\n</div>\n<div id=\"the-template-directive\">\n<h4><a href=\"#id27\" rel=\"nofollow\">The <em>template</em> directive</a></h4>\n<ul>\n<li>Must be used at genericpaster level.</li>\n<li>It describe a relative \u201cpaster template\u201d. The name which you could get with <tt>paster create <span class=\"pre\">-t</span> <span class=\"pre\">--list-templates</span></tt>.</li>\n<li>It has also an order which is used to order templates in the webinterface for lower to upper.</li>\n</ul>\n<pre>&lt;template name=\"Template Name\" order=\"int\"&gt;\n</pre>\n<pre>&gt;&gt;&gt; t = templates['minitage.plone3']\n&gt;&gt;&gt; t.order\n1\n&gt;&gt;&gt; t.name\n'minitage.plone3'\n</pre>\n<p>A template can also say that it must be generated under a \u2018subdirectory\u2019 with the <tt>output</tt> attribute.</p>\n<pre>&gt;&gt;&gt; templates['collective.generic.policy'].output\n'src'\n</pre>\n</div>\n<div id=\"the-group-directive\">\n<h4><a href=\"#id28\" rel=\"nofollow\">The <em>group</em> directive</a></h4>\n<ul>\n<li>A template has a list of groups of options.</li>\n<li>Groups are represented by a block of questions surrounded by the group name in the webinterface.</li>\n</ul>\n<pre>&lt;group name=\"GroupName\" order=\"int\"/&gt;\n</pre>\n<p>Those groups group \u2018paster questions\u2019.</p>\n<pre>&gt;&gt;&gt; groups = t.groups\n&gt;&gt;&gt; groups.keys()\n['default', 'Minitage']\n&gt;&gt;&gt; g = t.groups['Minitage']\n&gt;&gt;&gt; t.groups['Minitage'].order\n5\n&gt;&gt;&gt; t.groups['Minitage'].name\n'Minitage'\n</pre>\n</div>\n<div id=\"the-options-directive\">\n<h4><a href=\"#id29\" rel=\"nofollow\">The <em>options</em> directive</a></h4>\n<ul>\n<li>Must be used at group level.</li>\n<li>Groups group options, Which can be grabbed by a regular expression with this directive.</li>\n</ul>\n<pre>&lt;options prefix=\"Regular expression\"  type=\"boolean|\" default=\"value\"/&gt;\n</pre>\n<ul>\n<li><em>type</em> can be omitted and defaults to None (text).</li>\n<li><em>default</em> can be omitted and no default value will be assigned (or the paster default value).</li>\n</ul>\n<pre>&gt;&gt;&gt; opts = g.options['.*with.*']\n&gt;&gt;&gt; opts.type, opts.default\n('boolean', 'true')\n</pre>\n<p>As you can see, there is a default group where go non-matched options which are not excluded via the <tt>excludeoptions</tt> directive.</p>\n</div>\n<div id=\"the-option-directive\">\n<h4><a href=\"#id30\" rel=\"nofollow\">The <em>option</em> directive</a></h4>\n<ul>\n<li>Must be used at group level.</li>\n<li>Groups group also \u2018single options\u2019, Which can be grabbed by their name.</li>\n<li>Single options and can have an alias. It is useful  if we have the same \u2018option name\u2019 in 2 templates of the configuration and we don\u2019t want that they share the same value (default behaviour). To be clear, we have the option \u2018project\u2019, in template \u2018a\u2019 and \u2018b\u2019, by default, if we choose \u2018foo\u2019 for \u2018project\u2019, the value will be \u2018foo\u2019 in template \u2018a\u2019 and \u2018b\u2019, and with an alias, we can choose the value for \u2018a\u2019 <em>_and_</em> for \u2018b\u2019.</li>\n</ul>\n<pre>&lt;options name=\"name\" alias=\"alias name\"  type=\"boolean|\" default=\"value\"/&gt;\n</pre>\n<ul>\n<li><em>alias</em> can be omitted.</li>\n<li><em>type</em> can be omitted and defaults to None (text).</li>\n<li><em>default</em> can be omitted and no default value will be assigned (or the paster default value).</li>\n</ul>\n<pre>&gt;&gt;&gt; opt = g.single_options['install_method']\n&gt;&gt;&gt; opt.type, opt.alias, opt.default\n(None, 'ai', None)\n</pre>\n</div>\n<div id=\"the-excludeoptions-excludeoption-directives\">\n<h4><a href=\"#id31\" rel=\"nofollow\">The <em>excludeoptions</em> &amp; <em>excludeoption</em> directives</a></h4>\n<ul>\n<li>Must be used at group or template level (in any group of the template).</li>\n</ul>\n<pre>&lt;excludeoptions prefix=\"regular expression\"/&gt;\n</pre>\n<ul>\n<li>exclude options from the interface</li>\n<li><em>prefix</em>: regular expression for the options to exclude.</li>\n</ul>\n<pre>&lt;excludeoption name=\"option name\"/&gt;\n</pre>\n<ul>\n<li>exclude an option from the interface</li>\n<li><em>name</em>: name for the options to exclude.</li>\n</ul>\n<pre>&gt;&gt;&gt; [[getattr(templates[template].groups['default'], attr).keys() for attr in 'exclude_options', 'excludes_options'] for template in 'minitage.plone3', 'collective.generic.policy']\n[[['python'], ['project_.*']], [['python'], ['project_.*']]]\n</pre>\n</div>\n<div id=\"the-plugin-directive\">\n<h4><a href=\"#id32\" rel=\"nofollow\">The <em>plugin</em> directive</a></h4>\n<ul>\n<li>Must be used at template level.</li>\n<li>Declare which plugin must run after the templates collection generation.</li>\n<li>This is useful for example, to rearrange things which are generated.</li>\n</ul>\n<p>To run a plugin which is declared  under \u201cplugin name\u201d.</p>\n<pre>&lt;plugin name=\"plugin name\" order=\"int\"/&gt;\n</pre>\n<ul>\n<li><em>name</em>: name of the adapter</li>\n<li><em>order</em>: control order to run if there are more than one plugin</li>\n</ul>\n<p>A plugin, is a simple adapter which takes a IPasterAssembly and provides IPostGenerationPlugin</p>\n<pre>&lt;adapter\n  name=\"plugin name\"\n  provides=\".interfaces.IPostGenerationPlugin\"\n  factory=\".plugins.MyPluginFactory\"\n  for=\".interfaces.IPasterAssembly\"\n/&gt;\n</pre>\n<pre>&gt;&gt;&gt; plugins = root.configurations['Test Generic Portal Plone'].plugins\n&gt;&gt;&gt; plugins\n[('egg_plugin', 2)]\n</pre>\n</div>\n</div>\n<div id=\"the-paster-dance\">\n<h3><a href=\"#id33\" rel=\"nofollow\">The paster dance</a></h3>\n<p>Heart of cgwb is pythonpaste, take some of paster templates, gather them in an ihm for user inputs and answears for generating a final composition of those templates, with or without been modificated by surrounded plugins.</p>\n<pre>User choose a configuration\n    ---------&gt;\n        read variables from templates which are in the configuration and give the appropriate choice to the user\n    -------------&gt;\n            User inputs and submit it\n    --------------------&gt;\n                We generate a tarball of the assembled templates according to the answers\n</pre>\n<ul>\n<li>An option is asked only once, only you make aliases for each of the options which have the same name among templates.</li>\n<li>As a question is asked only once, if its type is not default, you must define it in the configuration of the template which has the less order number, because there will be there the question will be asked.</li>\n</ul>\n</div>\n<div id=\"loading-a-zcml-representation-of-a-configuration\">\n<h3><a href=\"#id34\" rel=\"nofollow\">Loading a zcml representation of a configuration</a></h3>\n<div id=\"testing-the-zcml-to-python-represetation\">\n<h4><a href=\"#id35\" rel=\"nofollow\">Testing the zcml to python represetation</a></h4>\n<p>Load our test package where we have three templates</p>\n<pre>&gt;&gt;&gt; import collective.generic.webbuilder.tests\n&gt;&gt;&gt; testegg = os.path.join( collective.generic.webbuilder.tests.__path__[0], 'egg', 'src')\n&gt;&gt;&gt; pkg_resources.working_set.add_entry(testegg)\n&gt;&gt;&gt; env = pkg_resources.Environment()\n&gt;&gt;&gt; egg = env['cgwb.tp'][0]\n</pre>\n<p>We have 3 templates in there waiting to be assembled</p>\n<pre>&gt;&gt;&gt; pprint(egg.get_entry_map())\n{'paste.paster_create_template': {'cgwb.testpackage1': EntryPoint.parse('cgwb.testpackage1 = tp.package:Package'),\n                                  'cgwb.testpackage2': EntryPoint.parse('cgwb.testpackage2 = tp1.package:Package'),\n                                  'cgwb.testpackage3': EntryPoint.parse('cgwb.testpackage3 = tp2.package:Package')}}\n</pre>\n</div>\n<div id=\"the-configuration\">\n<h4><a href=\"#id36\" rel=\"nofollow\">The configuration</a></h4>\n<p>It is more described in the zcml part of the documentation, but it\u2019s a zcml representation of which variables from the pastertemplates we want to extract and how we want to present them to users.</p>\n<p>A sample zcml needed to assemble the packages we declared before is as follow:</p>\n<pre>&gt;&gt;&gt; paster_zcml = \"\"\"\n... &lt;configure xmlns=\"http://namespaces.repoze.org/bfg\" xmlns:meta=\"http://namespaces.zope.org/meta\"&gt;\n...   &lt;include package=\"collective.generic.webbuilder\" file=\"meta.zcml\"/&gt;\n...   &lt;configure xmlns=\"http://webbuilder.org/webbuilder\"&gt;\n...     &lt;genericpaster name=\"test Assembler\"&gt;\n...         &lt;template name=\"cgwb.testpackage1\" output=\"1\" order=\"1000\"&gt;\n...           &lt;group name=\"Minitage\" order=\"05\"&gt;\n...             &lt;option name=\"tp1option\" type=\"boolean\"/&gt;\n...             &lt;option name=\"tp1option3\" default=\"y\"/&gt;\n...           &lt;/group&gt;\n...         &lt;/template&gt;\n...         &lt;template name=\"cgwb.testpackage2\" output=\"2\" order=\"200\"&gt;\n...           &lt;group name=\"Authors\" order=\"20\"&gt;\n...             &lt;options prefix=\"^author.*\"/&gt;\n...           &lt;/group&gt;\n...           &lt;excludeoptions prefix=\".*\"/&gt;\n...         &lt;/template&gt;\n...         &lt;template name=\"cgwb.testpackage3\" output=\"3\" order=\"500\"&gt;\n...           &lt;group name=\"Plone Settings\" order=\"8\"&gt;\n...             &lt;option name=\"tp2opton2\" /&gt;\n...             &lt;option name=\"author_email\" /&gt;\n...           &lt;/group&gt;\n...           &lt;group name=\"Authors\" order=\"20\"&gt;\n...             &lt;options prefix=\"^author.*\"/&gt;\n...           &lt;/group&gt;\n...           &lt;group name=\"Package tuning\" order=\"1\"&gt;\n...             &lt;option name=\"project_name\" type=\"hidden\" default=\"tma\" alias=\"tmapn\"/&gt;\n...           &lt;/group&gt;\n...         &lt;/template&gt;\n...     &lt;/genericpaster&gt;\n...   &lt;/configure&gt;\n... &lt;/configure&gt;\n... \"\"\"\n&gt;&gt;&gt; noecho = xmlconfig.string(paster_zcml)\n&gt;&gt;&gt; root.configurations['test Assembler']\n&lt;collective.generic.webbuilder.zcml.PasterConfiguration object at ...&gt;\n</pre>\n</div>\n<div id=\"pasterassembly-object\">\n<h4><a href=\"#id37\" rel=\"nofollow\">PasterAssembly object</a></h4>\n<p>have some \u201clog variables\u201d and the configuration name to search for in the \u201cbfgroot\u201d.configurations dictionnary.</p>\n<blockquote>\n<ul>\n<li><p><tt>template_data</tt>: list of mappings in the form:</p>\n<pre>[\n\u00a0{\n  'self': template 'zcml' object,\n  'name': paster template name,\n  'added_options': option added by this template,\n  'not_explicit_options': option added by this template which were not explicitly matched,\n  'display' : display a template or not\n  'groups':\n     {\n        groupname:\n            {\n                'name': groupname,\n                'group': zcml group object:\n                'options': [(paster variablen, type, optionn name, alias|None, zcml optionn|None )]\n            }\n\n     },\n  'aliases': [ (varName, aliasName),]\n\n }\n]\n</pre>\n</li>\n<li><p><tt>added_options</tt>: All options added for all templates</p>\n</li>\n</ul>\n</blockquote>\n<p>Get an assembly for the wanted configuration</p>\n<pre>&gt;&gt;&gt; ta = gpaster.PasterAssembly('test Assembler')\n&gt;&gt;&gt; pprint(ta.__dict__.items())\n[('templates_data', []),\n ('configuration',\n  &lt;collective.generic.webbuilder.zcml.PasterConfiguration object at ...&gt;),\n ('added_options', []),\n ('configuration_name', 'test Assembler')]\n</pre>\n</div>\n<div id=\"the-pasterassemblyreader-object\">\n<h4><a href=\"#id38\" rel=\"nofollow\">The PasterAssemblyReader object</a></h4>\n<p>This adapter takes as input a IPasterAssembly object and implements the IPasterAssemblyReader interface.</p>\n<p>We have configurations stored into zcml representation, now we need to gather and map the configuration informations with the content of each \u201cpaster template\u201d into a python friendly structure.\nThis Reader component is responsible for storing in the assembly object:</p>\n<blockquote>\n<ul>\n<li><p>The extracted template name</p>\n</li>\n<li><p>Each group of options</p>\n</li>\n<li><p>For each of those groups:</p>\n<blockquote>\n<ul>\n<li>The excluded options</li>\n<li>For the options which are not excluded, if applicable:<ul>\n<li>making its alias</li>\n<li>Assign the default value</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<p>What will finnally load the assembly data structures is a reader that now how to parse a configuration</p>\n<pre>&gt;&gt;&gt; reader = gpaster.PasterAssemblyReader(ta)\n&gt;&gt;&gt; reader.readed\nFalse\n&gt;&gt;&gt; reader.read()\n&gt;&gt;&gt; len(ta.added_options) &gt; 0\nTrue\n&gt;&gt;&gt; reader.readed\nTrue\n</pre>\n<p>We will check now that the structure loaded is as we wanted</p>\n<pre>&gt;&gt;&gt; t1 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage1')\n&gt;&gt;&gt; t2 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage2')\n&gt;&gt;&gt; t3 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage3')\n</pre>\n</div>\n<div id=\"templates\">\n<h4><a href=\"#id39\" rel=\"nofollow\">Templates</a></h4>\n<p>Order of templates is respected</p>\n<pre>&gt;&gt;&gt; [t['name'] for t in ta.templates_data]\n['cgwb.testpackage2', 'cgwb.testpackage3', 'cgwb.testpackage1']\n&gt;&gt;&gt; rt2, rt3, rt1 =  ta.templates_data\n</pre>\n</div>\n<div id=\"groups\">\n<h4><a href=\"#id40\" rel=\"nofollow\">Groups</a></h4>\n<p>Options in template3, on the paster side, that we ll find on the next example</p>\n<pre>&gt;&gt;&gt; pprint([v.name for v in t3.vars])\n['namespace',\n 'nested_namespace',\n 'version',\n 'author',\n 'author_email',\n 'tp3option',\n 'tp3option3',\n 'keywords',\n 'license_name',\n 'project_name']\n</pre>\n<p>For each templates, options are grouped, and groups respect order defined in zcml:</p>\n<pre>&gt;&gt;&gt; pprint([(rt3['groups'][n]['name'] , rt3['groups'][n]['options']) for n in range(len(rt3['groups']))])\n[('Package tuning',\n  [(&lt;var project_name default='tma' should_echo=True&gt;,\n    'hidden',\n    'tmapn',\n    &lt;collective.generic.webbuilder.zcml.Option object at ...&gt;)]),\n ('Plone Settings',\n  [(&lt;var author_email default='bar@localhost' should_echo=True&gt;,\n    'default',\n    None,\n    &lt;collective.generic.webbuilder.zcml.Option object at ...&gt;)]),\n ('Authors',\n  [(&lt;var author default='foo' should_echo=True&gt;,\n    'default',\n    None,\n    &lt;collective.generic.webbuilder.zcml.Options object at ...&gt;)]),\n ('default',\n  [(&lt;var namespace default='%(namespace)s' should_echo=True&gt;,\n    'default',\n    None,\n    None),\n   (&lt;var nested_namespace default='%(package)s' should_echo=True&gt;,\n    'default',\n    None,\n    None),\n   (&lt;var version default='1.0' should_echo=True&gt;, 'default', None, None),\n   (&lt;var tp3option default='http://python.org' should_echo=True&gt;,\n    'default',\n    None,\n    None),\n   (&lt;var tp3option3 default='Project %s' should_echo=True&gt;,\n    'default',\n    None,\n    None),\n   (&lt;var keywords default='' should_echo=True&gt;, 'default', None, None),\n   (&lt;var license_name default='GPL' should_echo=True&gt;,\n    'default',\n    None,\n    None)])]\n</pre>\n<p>As you can see project_name has been aliased and will be explained after.</p>\n</div>\n<div id=\"consumed-options\">\n<h4><a href=\"#id41\" rel=\"nofollow\">Consumed options</a></h4>\n<p>Goal is to insist loudly on consumed option.\nWhen an option is consumed by another template, it is not available in others to be asked only once.\nThat\u2019s why , template1 has no variables which were first asked in template3.</p>\n<pre>&gt;&gt;&gt; rt3options = []; noecho = [rt3options.extend(g['options']) for g in rt3['groups']]; rt3options = [opt[0].name for opt in rt3options]\n&gt;&gt;&gt; rtp1options = []; noecho = [rtp1options.extend(g['options']) for g in rt1['groups']]; rtp1options = [opt[0].name for opt in rtp1options]\n</pre>\n<p>project_name, author, etc. are not part of template1 options even if they are in the paster template.\nThey have been consumed by template3</p>\n<pre>&gt;&gt;&gt; pprint([v.name for v in t1.vars])\n['namespace',\n 'nested_namespace',\n 'version',\n 'author',\n 'author_email',\n 'tp1option',\n 'tp1option2',\n 'tp1option3',\n 'keywords',\n 'license_name',\n 'project_name']\n&gt;&gt;&gt; rt3options\n['project_name', 'author_email', 'author', 'namespace', 'nested_namespace', 'version', 'tp3option', 'tp3option3', 'keywords', 'license_name']\n&gt;&gt;&gt; rtp1options\n['tp1option', 'tp1option3', 'tp1option2', 'project_name']\n</pre>\n</div>\n<div id=\"excluded-options\">\n<h4><a href=\"#id42\" rel=\"nofollow\">Excluded options</a></h4>\n<p>Template2 ignore all opions per default, even adding an option can\u2019t precedence over ignoring options.\nTake care of your regexes !</p>\n<pre>&gt;&gt;&gt; [g['options'] for g in rt2['groups']]\n[[], []]\n</pre>\n</div>\n<div id=\"typed-options\">\n<h4><a href=\"#id43\" rel=\"nofollow\">Typed  options</a></h4>\n<p>We can assign type to values to use different widgets to display them in the UI for example.\nSupported types are:</p>\n<blockquote>\n<ul>\n<li>boolean (checkbox)</li>\n<li>hidden (hidden)</li>\n<li>default (textarea)</li>\n</ul>\n</blockquote>\n<p>template3 define project_name as <tt>hidden</tt></p>\n<pre>&gt;&gt;&gt; rt3['groups'][0]['options'][0][1]\n'hidden'\n</pre>\n<p>template1 define tp1option as <tt>boolean</tt>.</p>\n<pre>&gt;&gt;&gt; rt1['groups'][0]['options'][0][1]\n'boolean'\n</pre>\n<p>If an option default startswith \u2018y\u2019, \u2018true\u2019, or \u2018on\u2019, we switch the option type to boolean</p>\n<pre>&gt;&gt;&gt; rt1['groups'][0]['options'][1][1]\n'boolean'\n</pre>\n<p>Options in the default group have <tt>default</tt> as type, as for options without explicit type</p>\n<pre>&gt;&gt;&gt; rt3[\"groups\"][3]['options'][0][1]\n'default'\n&gt;&gt;&gt; rt3[\"groups\"][2]['options'][0][1]\n'default'\n</pre>\n</div>\n<div id=\"option-aliases\">\n<h4><a href=\"#id44\" rel=\"nofollow\">Option aliases</a></h4>\n<p>We have defined a default value and a default type for template3.project_name which is also an alias.\nAlias allow options with the same name but not the same value to exists within the same Assembly.\nDefault behaviour tells that one value is asked only once and used for all options that have the same name unless they are aliased explicitly each one of them.:</p>\n<pre>&gt;&gt;&gt; rt3['groups'][0]['options']\n[(&lt;var project_name default='tma' should_echo=True&gt;, 'hidden', 'tmapn', &lt;collective.generic.webbuilder.zcml.Option object at ...&gt;)]\n</pre>\n</div>\n<div id=\"added-options\">\n<h4><a href=\"#id45\" rel=\"nofollow\">Added options</a></h4>\n<p>We can retrieve options added</p>\n<blockquote>\n<ul>\n<li><p>For one template</p>\n<pre>&gt;&gt;&gt; rt1['added_options']\n['tp1option', 'tp1option2', 'tp1option3', 'project_name']\n&gt;&gt;&gt; rt2['added_options']\n[]\n&gt;&gt;&gt; rt3['added_options']\n['namespace', 'nested_namespace', 'version', 'author', 'author_email', 'tp3option', 'tp3option3', 'keywords', 'license_name', 'project_name']\n</pre>\n</li>\n<li><p>For all templates</p>\n<pre>&gt;&gt;&gt; ta.added_options\n['namespace', 'nested_namespace', 'version', 'author', 'author_email', 'tp3option', 'tp3option3', 'keywords', 'license_name', 'tmapn', 'tp1option', 'tp1option2', 'tp1option3', 'project_name']\n</pre>\n</li>\n</ul>\n</blockquote>\n</div>\n</div>\n<div id=\"creating-plugins-to-rearrange-things-after-a-successfull-templates-generation\">\n<h3><a href=\"#id46\" rel=\"nofollow\">Creating plugins to rearrange things after a successfull templates generation</a></h3>\n<div id=\"a-plugin-is-a-simple-adapter\">\n<h4><a href=\"#id47\" rel=\"nofollow\">A plugin is a simple adapter</a></h4>\n<p>Creating plugins to run after a generation is really simple.\nIt is just a matter of implementing an adapter which takes an <tt>\\IPasterConfiguration</tt> and provided <tt>IPostGenerationPlugin</tt>.</p>\n<pre>&lt;adapter\n  name=\"plugin name\"\n  provides=\".interfaces.IPostGenerationPlugin\"\n  factory=\".plugins.MyPluginFactory\"\n  for=\".interfaces.IPasterAssembly\"\n/&gt;\n</pre>\n</div>\n<div id=\"the-eggs-plugin\">\n<h4><a href=\"#id48\" rel=\"nofollow\">The eggs plugin</a></h4>\n<p>For example, here is a simple plugin which take all eggs in a \u2018src\u2019 directory and register them in \u2018zcml\u2019 and \u2018develop\u2019 in the relative \u2018\u2019buildout.cfg\u2019\u2019\nIt will add just the \u2018policy\u2019 egg to the intance\u2019s zcml option.</p>\n<p>Boiler plate to simulate a generation</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import tempfile, shutil, os\n&gt;&gt;&gt; c = os.getcwd()\n&gt;&gt;&gt; d = tempfile.mkdtemp()\n&gt;&gt;&gt; os.chdir(d)\n&gt;&gt;&gt; open('buildout.cfg', 'w').write('[buildout]\\ndevelop+=\\n   foo\\n[instance]\\nzcml=  too\\n')\n&gt;&gt;&gt; os.makedirs('src/bar/src')\n&gt;&gt;&gt; os.makedirs('src/policy/src')\n&gt;&gt;&gt; open('src/bar/setup.py', 'w').write('')\n&gt;&gt;&gt; open('src/policy/setup.py', 'w').write('')\n</pre>\n</blockquote>\n<p>Running the plugin</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from collective.generic.webbuilder.models import root\n&gt;&gt;&gt; conf = root.configurations['Generic Portal Plone3']\n&gt;&gt;&gt; from collective.generic.webbuilder import interfaces, paster\n&gt;&gt;&gt; pa = paster.PasterAssembly('Generic Portal Plone3')\n&gt;&gt;&gt; plugin = zope.component.queryAdapter(pa, interfaces.IPostGenerationPlugin, name='egg_plugin')\n&gt;&gt;&gt; plugin.process(d, 'foo', {})\n&gt;&gt;&gt; print open('buildout.cfg').read()\n[buildout]\ndevelop+=src/policy\n   src/bar\n   foo\neggs += policy\n        bar\n[instance]\nzcml=  too\n            policy\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>Cleanup</p>\n<blockquote>\n<pre>&gt;&gt;&gt; os.chdir(c);shutil.rmtree(d)\n</pre>\n</blockquote>\n</div>\n<div id=\"registering-plugins\">\n<h4><a href=\"#id49\" rel=\"nofollow\">Registering plugins</a></h4>\n<p>Please refer to the <em>plugin</em> zcml directive to know how to add plugins for a \u2018Configuration\u2019.</p>\n<p>Here is an example about the \u201ceggs_plugins\u201d</p>\n<pre>&lt;configure xmlns=\"http://namespaces.repoze.org/bfg\"\n    xmlns:meta=\"http://namespaces.zope.org/meta\"\n    xmlns:cgwb=xmlns=\"http://webbuilder.org/webbuilder\"&gt;\n    &lt;adapter\n        name=\"egg_plugin\"\n        provides=\".interfaces.IPostGenerationPlugin\"\n        factory=\".plugins.EggPlugin\"\n        for=\".interfaces.IPasterAssembly\"\n    /&gt;\n    &lt;cgwb:genericpaster name=\"Generic Portal Plone\"&gt;\n        &lt;cgwb:plugin name=\"egg_plugin\" order=\"2\"/&gt;\n        &lt;cgwb:template name=\"minitage.plone3\" order=\"1\"&gt;\n        &lt;/template&gt;\n    &lt;/genericpaster&gt;\n&lt;/configure&gt;\n</pre>\n</div>\n</div>\n<div id=\"id1\">\n<h3><a href=\"#id50\" rel=\"nofollow\">The paster dance</a></h3>\n<p>Heart of cgwb is pythonpaste, take some of paster templates, gather them in an ihm for user inputs and answears for generating a final composition of those templates, with or without been modificated by surrounded plugins.</p>\n<pre>User choose a configuration\n    ---------&gt;\n        read variables from templates which are in the configuration and give the appropriate choice to the user\n    -------------&gt;\n            User inputs and submit it\n    --------------------&gt;\n                We generate a tarball of the assembled templates according to the answers\n</pre>\n<ul>\n<li>An option is asked only once, only you make aliases for each of the options which have the same name among templates.</li>\n<li>As a question is asked only once, if its type is not default, you must define it in the configuration of the template which has the less order number, because there will be there the question will be asked.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id51\" rel=\"nofollow\">Loading a zcml representation of a configuration</a></h3>\n<div id=\"id3\">\n<h4><a href=\"#id52\" rel=\"nofollow\">Testing the zcml to python represetation</a></h4>\n<p>Load our test package where we have three templates</p>\n<pre>&gt;&gt;&gt; import collective.generic.webbuilder.tests\n&gt;&gt;&gt; testegg = os.path.join( collective.generic.webbuilder.tests.__path__[0], 'egg', 'src')\n&gt;&gt;&gt; pkg_resources.working_set.add_entry(testegg)\n&gt;&gt;&gt; env = pkg_resources.Environment()\n&gt;&gt;&gt; egg = env['cgwb.tp'][0]\n</pre>\n</div>\n<div id=\"id4\">\n<h4><a href=\"#id53\" rel=\"nofollow\">The configuration</a></h4>\n<p>It is more described in the zcml part of the documentation, but it\u2019s a zcml representation of which variables from the pastertemplates we want to extract and how we want to present them to users.</p>\n<p>A sample zcml needed to assemble the packages we declared before is as follow:</p>\n<pre>&gt;&gt;&gt; paster_zcml = \"\"\"\n... &lt;configure xmlns=\"http://namespaces.repoze.org/bfg\" xmlns:meta=\"http://namespaces.zope.org/meta\"&gt;\n...   &lt;include package=\"collective.generic.webbuilder\" file=\"meta.zcml\"/&gt;\n...   &lt;configure xmlns=\"http://webbuilder.org/webbuilder\"&gt;\n...     &lt;genericpaster name=\"test Assembler\"&gt;\n...         &lt;template name=\"cgwb.testpackage1\" output=\"1\" order=\"1000\"&gt;\n...           &lt;group name=\"Minitage\" order=\"05\"&gt;\n...             &lt;option name=\"tp1option\" type=\"boolean\"/&gt;\n...             &lt;option name=\"tp1option3\" default=\"y\"/&gt;\n...           &lt;/group&gt;\n...         &lt;/template&gt;\n...         &lt;template name=\"cgwb.testpackage2\" output=\"2\" order=\"200\"&gt;\n...           &lt;group name=\"Authors\" order=\"20\"&gt;\n...             &lt;options prefix=\"^author.*\"/&gt;\n...           &lt;/group&gt;\n...           &lt;excludeoptions prefix=\".*\"/&gt;\n...         &lt;/template&gt;\n...         &lt;template name=\"cgwb.testpackage3\" output=\"3\" order=\"500\"&gt;\n...           &lt;group name=\"Plone Settings\" order=\"8\"&gt;\n...             &lt;option name=\"tp2opton2\" /&gt;\n...             &lt;option name=\"author_email\" /&gt;\n...           &lt;/group&gt;\n...           &lt;group name=\"Authors\" order=\"20\"&gt;\n...             &lt;options prefix=\"^author.*\"/&gt;\n...           &lt;/group&gt;\n...           &lt;group name=\"Package tuning\" order=\"1\"&gt;\n...             &lt;option name=\"project_name\" type=\"hidden\" default=\"tma\" alias=\"tmapn\"/&gt;\n...           &lt;/group&gt;\n...         &lt;/template&gt;\n...     &lt;/genericpaster&gt;\n...   &lt;/configure&gt;\n... &lt;/configure&gt;\n... \"\"\"\n&gt;&gt;&gt; noecho = xmlconfig.string(paster_zcml)\n&gt;&gt;&gt; root.configurations['test Assembler']\n&lt;collective.generic.webbuilder.zcml.PasterConfiguration object at ...&gt;\n</pre>\n<p>We will check now that the structure loaded is as we wanted</p>\n<pre>&gt;&gt;&gt; t1 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage1')\n&gt;&gt;&gt; t2 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage2')\n&gt;&gt;&gt; t3 = pkg_resources.load_entry_point('cgwb.tp', 'paste.paster_create_template', 'cgwb.testpackage3')\n&gt;&gt;&gt; server, url = launch_server()\n&gt;&gt;&gt; browser = Browser(url)\n</pre>\n<p>We can see that in the main page we have the default configurations and the custom loaded one</p>\n<pre>&gt;&gt;&gt; 'test Assembler' in browser.contents\nTrue\n&gt;&gt;&gt; 'Generic Portal Plone4' in browser.contents\nTrue\n&gt;&gt;&gt; 'Generic Portal Plone3' in browser.contents\nTrue\n</pre>\n<p>Following the test assembler link</p>\n<pre>&gt;&gt;&gt; browser.getLink('test Assembler').click()\n&gt;&gt;&gt; htmlS(browser.contents).xpath('//input[@name=\"project\"]')[0]\n&lt;InputElement ... name='project' type='text'&gt;\n</pre>\n<p>I can submit a form and a valid it</p>\n<pre>&gt;&gt;&gt; browser.getControl(name='project').value = 'myproject'\n&gt;&gt;&gt; browser.getControl(name='author').value = 'tim burton'\n&gt;&gt;&gt; browser.getControl(name='author_email').value = 'tim burton@foo.com'\n&gt;&gt;&gt; browser.getControl(name='tp1option').value = False\n&gt;&gt;&gt; browser.getControl(name='tp1option2').value = 'Project Monster'\n&gt;&gt;&gt; browser.getControl(name='project_name').value = 'My Big Project'\n&gt;&gt;&gt; browser.getControl(name='submit_cgwbDownload').click()\n&gt;&gt;&gt; '.tar' in browser.contents\nTrue\n</pre>\n<p>The sucessful produced result is a tarball</p>\n<pre>&gt;&gt;&gt; pprint(browser.headers.headers)\n['Server:...\n 'Date:...\n 'Content-Disposition: attachment; filename=\"myproject....tar.gz\"\\r\\n',\n 'Content-Transfer-Encoding: binary\\r\\n',\n 'Content-Length: ...\\r\\n']\n&gt;&gt;&gt; import tarfile\n&gt;&gt;&gt; tar = tarfile.open(fileobj=StringIO(browser.contents))\n</pre>\n<p>In the produced tarball, output directories present in the zcml configuration are respected in the tarball:</p>\n<pre>&gt;&gt;&gt; files = [a.name for a in tar];files.sort();pprint(files)\n['.',\n '1',\n '1/myproject',\n '1/myproject/test',\n '2',\n '2/myproject',\n '2/myproject/test1',\n '3',\n '3/myproject',\n '3/myproject/test2']\n&gt;&gt;&gt; templates = dict([(a.name,a) for a in tar if 'test' in a.name])\n&gt;&gt;&gt; t2 = templates['2/myproject/test1']\n&gt;&gt;&gt; t3 = templates['3/myproject/test2']\n&gt;&gt;&gt; t1 = templates['1/myproject/test']\n</pre>\n<p>Options filled in the interface are well interpreted in templates</p>\n<pre>&gt;&gt;&gt; pprint([a for a  in tar.extractfile(t1).read().split('\\n') if a.strip()])\n['namespace                 =&gt;            %(namespace)s',\n 'nested_namespace          =&gt;            %(package)s',\n 'version                   =&gt;            1.0',\n 'author                    =&gt;            tim burton',\n 'author_email              =&gt;            tim burton@foo.com',\n 'tp1option                 =&gt;            False',\n 'tp1option2                =&gt;            Project Monster',\n 'tp1option3                =&gt;            True',\n 'keywords                  =&gt;            ',\n 'license_name              =&gt;            GPL',\n 'project_name              =&gt;            My Big Project']\n</pre>\n<p>The project_name entered for project1 is shared in project2</p>\n<pre>&gt;&gt;&gt; pprint([a for a  in tar.extractfile(t2).read().split('\\n') if a.strip()])\n[\"'namespace'                =&gt;         '%(namespace)s'\",\n \"'nested_namespace'         =&gt;         '%(package)s'\",\n \"'version'                  =&gt;         '1.0'\",\n \"'author'                   =&gt;         'tim burton'\",\n \"'author_email'             =&gt;         'tim burton@foo.com'\",\n \"'keywords'                 =&gt;         ''\",\n \"'license_name'             =&gt;         'GPL'\",\n \"'project_name'             =&gt;         'My Big Project'\",\n \"'tp2option'                =&gt;         'tp2option'\",\n \"'tp2opton2'                =&gt;         'tp2opton2'\"]\n</pre>\n<p>the aliased project_name (tma) takes efffect in the third template</p>\n<pre>&gt;&gt;&gt; pprint([a for a  in tar.extractfile(t3).read().split('\\n') if a.strip()])\n[\"'namespace'                =&gt;         '%(namespace)s'\",\n \"'nested_namespace'         =&gt;         '%(package)s'\",\n \"'version'                  =&gt;         '1.0'\",\n \"'author'                   =&gt;         'tim burton'\",\n \"'author_email'             =&gt;         'tim burton@foo.com'\",\n \"'keywords'                 =&gt;         ''\",\n \"'license_name'             =&gt;         'GPL'\",\n \"'project_name'             =&gt;         'tma'\",\n \"'tp3option3'               =&gt;         'Project %s'\",\n \"'tp3option'                =&gt;         'Project %s'\"]\n</pre>\n</div>\n</div>\n</div>\n<div id=\"changelog\">\n<h2><a href=\"#id54\" rel=\"nofollow\">Changelog</a></h2>\n<div id=\"id5\">\n<h3><a href=\"#id55\" rel=\"nofollow\">1.1</a></h3>\n<ul>\n<li>documentation, because webbuilder needs to be installed in dev mode, anyhow.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id56\" rel=\"nofollow\">1.0</a></h3>\n<ul>\n<li>Initial release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1030924, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "02377a230a6d976fbbbb7e38d15648dd", "sha256": "8e90347ffa4425e8a6dcd654b0703f512d62017299577fe575697b929c9c17d4"}, "downloads": -1, "filename": "collective.generic.webbuilder-1.0.tar.gz", "has_sig": false, "md5_digest": "02377a230a6d976fbbbb7e38d15648dd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 231602, "upload_time": "2011-11-24T10:45:59", "upload_time_iso_8601": "2011-11-24T10:45:59.476094Z", "url": "https://files.pythonhosted.org/packages/af/53/6262ef928aa3731eeadae90abf4dab134cae83c689dcfc46d4073615a55d/collective.generic.webbuilder-1.0.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "4adf0c9aad7efce2aa0b73eaca19ff89", "sha256": "cf3175ad2b95cf5ce47824f5ad0ee62c24c5f3446e651bf359f30d6dc9832535"}, "downloads": -1, "filename": "collective.generic.webbuilder-1.0.zip", "has_sig": false, "md5_digest": "4adf0c9aad7efce2aa0b73eaca19ff89", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 328036, "upload_time": "2010-04-21T13:13:39", "upload_time_iso_8601": "2010-04-21T13:13:39.157553Z", "url": "https://files.pythonhosted.org/packages/a0/bf/33c7be248d7a84e6c76796530b20a747ff4d6c6f6b06532dd4c834eaff87/collective.generic.webbuilder-1.0.zip", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "bfa3b0506e3af818e313940f5bd0396e", "sha256": "4ea38f499d564950fe98b8ae194fa6019f695d00adb66d9dc51cf2fa9480b04f"}, "downloads": -1, "filename": "collective.generic.webbuilder-1.1.tar.gz", "has_sig": false, "md5_digest": "bfa3b0506e3af818e313940f5bd0396e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 233630, "upload_time": "2011-11-24T11:01:58", "upload_time_iso_8601": "2011-11-24T11:01:58.030619Z", "url": "https://files.pythonhosted.org/packages/bc/e4/34eb88dc9ada4d2c7f8be3adcc283be2aecf24626efdc82494883d0a0226/collective.generic.webbuilder-1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bfa3b0506e3af818e313940f5bd0396e", "sha256": "4ea38f499d564950fe98b8ae194fa6019f695d00adb66d9dc51cf2fa9480b04f"}, "downloads": -1, "filename": "collective.generic.webbuilder-1.1.tar.gz", "has_sig": false, "md5_digest": "bfa3b0506e3af818e313940f5bd0396e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 233630, "upload_time": "2011-11-24T11:01:58", "upload_time_iso_8601": "2011-11-24T11:01:58.030619Z", "url": "https://files.pythonhosted.org/packages/bc/e4/34eb88dc9ada4d2c7f8be3adcc283be2aecf24626efdc82494883d0a0226/collective.generic.webbuilder-1.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:17:53 2020"}