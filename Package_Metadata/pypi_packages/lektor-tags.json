{"info": {"author": "A. Jesse Jiryu Davis", "author_email": "jesse@emptysquare.net", "bugtrack_url": null, "classifiers": ["Environment :: Plugins", "Environment :: Web Environment", "Framework :: Lektor", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License"], "description": "# Lektor Tags Plugin\n\n[![PyPI version](https://badge.fury.io/py/lektor-tags.svg)](https://pypi.org/project/lektor-tags/)\n<a href=\"https://github.com/ambv/black\"><img alt=\"Code style: black\" src=\"https://img.shields.io/badge/code%20style-black-000000.svg\"></a>\n\n## Introduction\n\nThis plugin implements tagging for your site. For each of your tags, it builds a page displaying a list of items that have that tag. This can be used for standard tag-based blog navigation. With this plugin you can give any number of tags to any blog posts, and a page will be created for each tag.\n\nFor example, if your site has blog posts in your `content/blog` directory tagged with `coffee` and `tea`:\n\n```\nname: First Post\n---\ntags:\n\ncoffee\ntea\n```\n\nThe `lektor-tags` plugin builds pages at these URLs:\n\n* `/blog/tag/coffee/`\n* `/blog/tag/tea/`\n\nEach page can list all the posts with that tag.\n\n## Installation\n\nAdd lektor-tags to your project from command line:\n\n```shell\nlektor plugins add lektor-tags\n```\n\nSee [the Lektor documentation for more instructions on installing plugins](https://www.getlektor.com/docs/plugins/).\n\n## Overview\n\nSay you have a \"blog-post\" model like this:\n\n```ini\n[model]\nname = Blog Post\n\n[fields.tags]\ntype = strings\n```\n\nMake a `blog-post.html` template that includes:\n\n```html\n{% if this.tags %}\n  <ul>\n    {% for t in this.tags -%}\n      <li>\n        <a href=\"{{ ('/blog@tag/' ~ t.lower())|url }}\">\n          All posts tagged {{ t }}\n        </a>\n      </li>\n    {% endfor %}\n  </ul>\n{% endif %}\n```\n\nThis expression in the template generates a *source path* for each of the blog post's tags:\n\n```jinja\n'/blog@tag/' ~ t.lower()\n```\n\nThen if the tag is \"my-tag\", the expression renders a source path like:\n\n```\n/blog/tag/my-tag\n```\n\nA Lektor source path becomes an actual URL using the `url` filter. So the template generates URLs to tag pages like:\n\n```\n<a href=\"{{ ('/blog@tag/' ~ t.lower())|url }}\"></a>\n```\n\nThis uses the source path expression from before, but pipes it through `url` to generate an actual link from the blog post to a tag page.\n\n## Configuration\n\nSet these options in `configs/tags.ini`:\n\n### `parent`\n\nRequired. The source path of the tag pages' parent page. For example:\n\n```ini\nparent = /blog\n```\n\nThen tag pages' source paths are like:\n\n```\n/blog/tag/my-tag\n```\n\nYou can specify the root as the parent:\n\n```ini\nparent = /\n```\n\n### `items`\n\nA query for all items on the page for one tag. You can use the variables `site` and `tag`. The template's `this` variable has a `parent` attribute. The default query is:\n\n```ini\nitems = this.parent.children.filter(F.tags.contains(tag))\n```\n\nYou can sort and filter with any expression:\n\n```ini\nitems = this.parent.children.filter(F.tags.contains(tag) and F.status == 'published').order_by('-pub_date')\n```\n\nIf the parent page has [a pagination query](https://www.getlektor.com/docs/guides/pagination/) you may want to use it for tagged pages:\n\n```ini\nitems = this.parent.pagination.items.filter(F.tags.contains(tag))\n```\n\nSee [the Lektor documentation for queries](https://www.getlektor.com/docs/api/db/query/).\n\n### `tags_field`\n\nThe name of the field in your model that contains tags. Defaults to `tags`. The field should be of type `strings`. See [the Lektor documentation for the `strings` type](https://www.getlektor.com/docs/api/db/types/strings/).\n\nFor example, if your model is like:\n\n```ini\n[fields.labels]\ntype = strings\n```\n\nThen add this to `tags.ini`:\n\n```ini\ntags_field = labels\n```\n\n### `template`\n\nThe template for the page that lists all posts with a certain tag. The template's `this` variable has attributes `tag` and `items`. An example template:\n\n```html\n<h1>Tag: {{ this.tag }}</h1>\n<h1>Items:</h1>\n<ul>\n  {% for i in this.items %}\n    <li><a href=\"{{ i|url }}\">{{ i._id }}</a></li>\n  {% else %}\n    <li><em>No items.</em></li>\n  {% endfor %}\n</ul>\n```\n\nSave a file like this to your project's `templates/tags.html`. If you name the file something different, like `label.html`, add this line to `tags.ini`:\n\n```ini\ntemplate = label.html\n```\n\nThe plugin provides a default template if you don't specify one.\n\n### `url_path`\n\nAn expression for the location of each tag page. You can use the variables `site` and `tag`. The `this` variable is a page with attributes `parent` and `items`. The default expression is:\n\n```ini\nurl_path = {{ this.parent.url_path }}tag/{{ tag }}\n```\n\nThis expression generates URLs like `/blog/tag/coffee`.\n\n### `ignore_missing`\n\nDefault false. To set true, add this line to `tags.ini`:\n\n```ini\nignore_missing = true\n```\n\nThis allows URLs to missing tag pages to be silently replaced with \"\". The example use case is if your `blog-post.html` template includes a statement like:\n\n```html\n{% for t in this.tags -%}\n  <a href=\"{{ ('/blog@tag/' ~ t.lower())|url }}\">{{ t }}</a>\n{% endfor %}\n```\n\nIf a blog post *draft* is not discoverable, and it has any new tags used by no published blog posts, then those tag pages do not yet exist. Turn on `ignore_missing` to allow such drafts to be built. The tag-page URL path will be the empty string \"\", until the draft is published and the tag page is created.\n\n### `tags`\n\nAdvanced configuration. An expression for the set of tags. The default expression is:\n\n```ini\ntags = parent.children.distinct(\"tags\")\n```\n\nIf you set `tags_field` to a different field name than \"tags\", the default expression uses your custom field name. For example if you have this line in `tags.ini`:\n\n```ini\ntags_field = labels\n```\n\nThen the default value of `tags` is:\n\n```ini\ntags = parent.children.distinct(\"labels\")\n```\n\nYou can use any template expression. For example, if your items have a \"published\" boolean field, you can select tags of published items:\n\n```ini\ntags = parent.children.filter(F.published).distinct(\"tags\")\n```\n\nOr even list your tags manually:\n\n```ini\ntags = [\"tag1\", \"tag2\"]\n```\n\nSee [the Lektor documentation for queries](https://www.getlektor.com/docs/api/db/query/).\n\nTags are always deduplicated, and alphabetically ordered.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/nixjdm/lektor-tags", "keywords": "Lektor plugin static-site blog tags", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "lektor-tags", "package_url": "https://pypi.org/project/lektor-tags/", "platform": "", "project_url": "https://pypi.org/project/lektor-tags/", "project_urls": {"Homepage": "https://github.com/nixjdm/lektor-tags"}, "release_url": "https://pypi.org/project/lektor-tags/0.3/", "requires_dist": ["Lektor"], "requires_python": "", "summary": "Lektor plugin to add tags.", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Lektor Tags Plugin</h1>\n<p><a href=\"https://pypi.org/project/lektor-tags/\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a239b3270defed867adb66fa135f8a80458c7f98/68747470733a2f2f62616467652e667572792e696f2f70792f6c656b746f722d746167732e737667\"></a>\n<a href=\"https://github.com/ambv/black\" rel=\"nofollow\"><img alt=\"Code style: black\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a></p>\n<h2>Introduction</h2>\n<p>This plugin implements tagging for your site. For each of your tags, it builds a page displaying a list of items that have that tag. This can be used for standard tag-based blog navigation. With this plugin you can give any number of tags to any blog posts, and a page will be created for each tag.</p>\n<p>For example, if your site has blog posts in your <code>content/blog</code> directory tagged with <code>coffee</code> and <code>tea</code>:</p>\n<pre><code>name: First Post\n---\ntags:\n\ncoffee\ntea\n</code></pre>\n<p>The <code>lektor-tags</code> plugin builds pages at these URLs:</p>\n<ul>\n<li><code>/blog/tag/coffee/</code></li>\n<li><code>/blog/tag/tea/</code></li>\n</ul>\n<p>Each page can list all the posts with that tag.</p>\n<h2>Installation</h2>\n<p>Add lektor-tags to your project from command line:</p>\n<pre>lektor plugins add lektor-tags\n</pre>\n<p>See <a href=\"https://www.getlektor.com/docs/plugins/\" rel=\"nofollow\">the Lektor documentation for more instructions on installing plugins</a>.</p>\n<h2>Overview</h2>\n<p>Say you have a \"blog-post\" model like this:</p>\n<pre><span class=\"k\">[model]</span>\n<span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"s\">Blog Post</span>\n\n<span class=\"k\">[fields.tags]</span>\n<span class=\"na\">type</span> <span class=\"o\">=</span> <span class=\"s\">strings</span>\n</pre>\n<p>Make a <code>blog-post.html</code> template that includes:</p>\n<pre>{% if this.tags %}\n  <span class=\"p\">&lt;</span><span class=\"nt\">ul</span><span class=\"p\">&gt;</span>\n    {% for t in this.tags -%}\n      <span class=\"p\">&lt;</span><span class=\"nt\">li</span><span class=\"p\">&gt;</span>\n        <span class=\"p\">&lt;</span><span class=\"nt\">a</span> <span class=\"na\">href</span><span class=\"o\">=</span><span class=\"s\">\"{{ ('/blog@tag/' ~ t.lower())|url }}\"</span><span class=\"p\">&gt;</span>\n          All posts tagged {{ t }}\n        <span class=\"p\">&lt;/</span><span class=\"nt\">a</span><span class=\"p\">&gt;</span>\n      <span class=\"p\">&lt;/</span><span class=\"nt\">li</span><span class=\"p\">&gt;</span>\n    {% endfor %}\n  <span class=\"p\">&lt;/</span><span class=\"nt\">ul</span><span class=\"p\">&gt;</span>\n{% endif %}\n</pre>\n<p>This expression in the template generates a <em>source path</em> for each of the blog post's tags:</p>\n<pre><span class=\"x\">'/blog@tag/' ~ t.lower()</span>\n</pre>\n<p>Then if the tag is \"my-tag\", the expression renders a source path like:</p>\n<pre><code>/blog/tag/my-tag\n</code></pre>\n<p>A Lektor source path becomes an actual URL using the <code>url</code> filter. So the template generates URLs to tag pages like:</p>\n<pre><code>&lt;a href=\"{{ ('/blog@tag/' ~ t.lower())|url }}\"&gt;&lt;/a&gt;\n</code></pre>\n<p>This uses the source path expression from before, but pipes it through <code>url</code> to generate an actual link from the blog post to a tag page.</p>\n<h2>Configuration</h2>\n<p>Set these options in <code>configs/tags.ini</code>:</p>\n<h3><code>parent</code></h3>\n<p>Required. The source path of the tag pages' parent page. For example:</p>\n<pre><span class=\"na\">parent</span> <span class=\"o\">=</span> <span class=\"s\">/blog</span>\n</pre>\n<p>Then tag pages' source paths are like:</p>\n<pre><code>/blog/tag/my-tag\n</code></pre>\n<p>You can specify the root as the parent:</p>\n<pre><span class=\"na\">parent</span> <span class=\"o\">=</span> <span class=\"s\">/</span>\n</pre>\n<h3><code>items</code></h3>\n<p>A query for all items on the page for one tag. You can use the variables <code>site</code> and <code>tag</code>. The template's <code>this</code> variable has a <code>parent</code> attribute. The default query is:</p>\n<pre><span class=\"na\">items</span> <span class=\"o\">=</span> <span class=\"s\">this.parent.children.filter(F.tags.contains(tag))</span>\n</pre>\n<p>You can sort and filter with any expression:</p>\n<pre><span class=\"na\">items</span> <span class=\"o\">=</span> <span class=\"s\">this.parent.children.filter(F.tags.contains(tag) and F.status == 'published').order_by('-pub_date')</span>\n</pre>\n<p>If the parent page has <a href=\"https://www.getlektor.com/docs/guides/pagination/\" rel=\"nofollow\">a pagination query</a> you may want to use it for tagged pages:</p>\n<pre><span class=\"na\">items</span> <span class=\"o\">=</span> <span class=\"s\">this.parent.pagination.items.filter(F.tags.contains(tag))</span>\n</pre>\n<p>See <a href=\"https://www.getlektor.com/docs/api/db/query/\" rel=\"nofollow\">the Lektor documentation for queries</a>.</p>\n<h3><code>tags_field</code></h3>\n<p>The name of the field in your model that contains tags. Defaults to <code>tags</code>. The field should be of type <code>strings</code>. See <a href=\"https://www.getlektor.com/docs/api/db/types/strings/\" rel=\"nofollow\">the Lektor documentation for the <code>strings</code> type</a>.</p>\n<p>For example, if your model is like:</p>\n<pre><span class=\"k\">[fields.labels]</span>\n<span class=\"na\">type</span> <span class=\"o\">=</span> <span class=\"s\">strings</span>\n</pre>\n<p>Then add this to <code>tags.ini</code>:</p>\n<pre><span class=\"na\">tags_field</span> <span class=\"o\">=</span> <span class=\"s\">labels</span>\n</pre>\n<h3><code>template</code></h3>\n<p>The template for the page that lists all posts with a certain tag. The template's <code>this</code> variable has attributes <code>tag</code> and <code>items</code>. An example template:</p>\n<pre><span class=\"p\">&lt;</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>Tag: {{ this.tag }}<span class=\"p\">&lt;/</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>Items:<span class=\"p\">&lt;/</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">ul</span><span class=\"p\">&gt;</span>\n  {% for i in this.items %}\n    <span class=\"p\">&lt;</span><span class=\"nt\">li</span><span class=\"p\">&gt;&lt;</span><span class=\"nt\">a</span> <span class=\"na\">href</span><span class=\"o\">=</span><span class=\"s\">\"{{ i|url }}\"</span><span class=\"p\">&gt;</span>{{ i._id }}<span class=\"p\">&lt;/</span><span class=\"nt\">a</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">li</span><span class=\"p\">&gt;</span>\n  {% else %}\n    <span class=\"p\">&lt;</span><span class=\"nt\">li</span><span class=\"p\">&gt;&lt;</span><span class=\"nt\">em</span><span class=\"p\">&gt;</span>No items.<span class=\"p\">&lt;/</span><span class=\"nt\">em</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">li</span><span class=\"p\">&gt;</span>\n  {% endfor %}\n<span class=\"p\">&lt;/</span><span class=\"nt\">ul</span><span class=\"p\">&gt;</span>\n</pre>\n<p>Save a file like this to your project's <code>templates/tags.html</code>. If you name the file something different, like <code>label.html</code>, add this line to <code>tags.ini</code>:</p>\n<pre><span class=\"na\">template</span> <span class=\"o\">=</span> <span class=\"s\">label.html</span>\n</pre>\n<p>The plugin provides a default template if you don't specify one.</p>\n<h3><code>url_path</code></h3>\n<p>An expression for the location of each tag page. You can use the variables <code>site</code> and <code>tag</code>. The <code>this</code> variable is a page with attributes <code>parent</code> and <code>items</code>. The default expression is:</p>\n<pre><span class=\"na\">url_path</span> <span class=\"o\">=</span> <span class=\"s\">{{ this.parent.url_path }}tag/{{ tag }}</span>\n</pre>\n<p>This expression generates URLs like <code>/blog/tag/coffee</code>.</p>\n<h3><code>ignore_missing</code></h3>\n<p>Default false. To set true, add this line to <code>tags.ini</code>:</p>\n<pre><span class=\"na\">ignore_missing</span> <span class=\"o\">=</span> <span class=\"s\">true</span>\n</pre>\n<p>This allows URLs to missing tag pages to be silently replaced with \"\". The example use case is if your <code>blog-post.html</code> template includes a statement like:</p>\n<pre>{% for t in this.tags -%}\n  <span class=\"p\">&lt;</span><span class=\"nt\">a</span> <span class=\"na\">href</span><span class=\"o\">=</span><span class=\"s\">\"{{ ('/blog@tag/' ~ t.lower())|url }}\"</span><span class=\"p\">&gt;</span>{{ t }}<span class=\"p\">&lt;/</span><span class=\"nt\">a</span><span class=\"p\">&gt;</span>\n{% endfor %}\n</pre>\n<p>If a blog post <em>draft</em> is not discoverable, and it has any new tags used by no published blog posts, then those tag pages do not yet exist. Turn on <code>ignore_missing</code> to allow such drafts to be built. The tag-page URL path will be the empty string \"\", until the draft is published and the tag page is created.</p>\n<h3><code>tags</code></h3>\n<p>Advanced configuration. An expression for the set of tags. The default expression is:</p>\n<pre><span class=\"na\">tags</span> <span class=\"o\">=</span> <span class=\"s\">parent.children.distinct(\"tags\")</span>\n</pre>\n<p>If you set <code>tags_field</code> to a different field name than \"tags\", the default expression uses your custom field name. For example if you have this line in <code>tags.ini</code>:</p>\n<pre><span class=\"na\">tags_field</span> <span class=\"o\">=</span> <span class=\"s\">labels</span>\n</pre>\n<p>Then the default value of <code>tags</code> is:</p>\n<pre><span class=\"na\">tags</span> <span class=\"o\">=</span> <span class=\"s\">parent.children.distinct(\"labels\")</span>\n</pre>\n<p>You can use any template expression. For example, if your items have a \"published\" boolean field, you can select tags of published items:</p>\n<pre><span class=\"na\">tags</span> <span class=\"o\">=</span> <span class=\"s\">parent.children.filter(F.published).distinct(\"tags\")</span>\n</pre>\n<p>Or even list your tags manually:</p>\n<pre><span class=\"na\">tags</span> <span class=\"o\">=</span> <span class=\"s\">[\"tag1\", \"tag2\"]</span>\n</pre>\n<p>See <a href=\"https://www.getlektor.com/docs/api/db/query/\" rel=\"nofollow\">the Lektor documentation for queries</a>.</p>\n<p>Tags are always deduplicated, and alphabetically ordered.</p>\n\n          </div>"}, "last_serial": 7124350, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "a2e42ee309e1b6a89f4fd6e81e210053", "sha256": "f701de3e6c4fd471fd577d17f2265ae1339e6b98363cdab1fa8ee3b361c626a2"}, "downloads": -1, "filename": "lektor-tags-0.1.tar.gz", "has_sig": false, "md5_digest": "a2e42ee309e1b6a89f4fd6e81e210053", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2756, "upload_time": "2016-04-28T15:43:13", "upload_time_iso_8601": "2016-04-28T15:43:13.553846Z", "url": "https://files.pythonhosted.org/packages/1e/65/0da890d28440697595cfcd32c41452ba8867012adf05bbdcde9d818d29b2/lektor-tags-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "53536e9c8c8e6d50ff73af8f207a2033", "sha256": "6e69fa47bc4def6477d8a1bf4a02c6e01998166a18f9e9795040421aa5c11e2b"}, "downloads": -1, "filename": "lektor_tags-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "53536e9c8c8e6d50ff73af8f207a2033", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5541, "upload_time": "2018-05-13T01:22:58", "upload_time_iso_8601": "2018-05-13T01:22:58.320971Z", "url": "https://files.pythonhosted.org/packages/aa/59/c06892bb18e8ab7f668a82fc68ca18eb65fad52004618401875d1937b6d5/lektor_tags-0.2-py3-none-any.whl", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "9741c65019c6562a179026515beb8ba2", "sha256": "e995ec987ec51649aa61d8c956552a7feae797f5b8df092fbb92e213817121d7"}, "downloads": -1, "filename": "lektor_tags-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "9741c65019c6562a179026515beb8ba2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5689, "upload_time": "2018-12-15T02:14:14", "upload_time_iso_8601": "2018-12-15T02:14:14.851074Z", "url": "https://files.pythonhosted.org/packages/67/ae/02fef1b85334d310512533601be1fbe5e21955e5a3f60f19dff4967df1b8/lektor_tags-0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "75f26a97af0048b96a3942156db0998e", "sha256": "283e1687914bdd7d4e2766678f81bfea7d6224403cb17bce9f3c66800904d949"}, "downloads": -1, "filename": "lektor-tags-0.3.tar.gz", "has_sig": false, "md5_digest": "75f26a97af0048b96a3942156db0998e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5765, "upload_time": "2018-12-15T02:14:16", "upload_time_iso_8601": "2018-12-15T02:14:16.459056Z", "url": "https://files.pythonhosted.org/packages/c3/43/bc69845f9d15555750c1fa52135283223086d2ee761443b3e0999ce7c468/lektor-tags-0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9741c65019c6562a179026515beb8ba2", "sha256": "e995ec987ec51649aa61d8c956552a7feae797f5b8df092fbb92e213817121d7"}, "downloads": -1, "filename": "lektor_tags-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "9741c65019c6562a179026515beb8ba2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5689, "upload_time": "2018-12-15T02:14:14", "upload_time_iso_8601": "2018-12-15T02:14:14.851074Z", "url": "https://files.pythonhosted.org/packages/67/ae/02fef1b85334d310512533601be1fbe5e21955e5a3f60f19dff4967df1b8/lektor_tags-0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "75f26a97af0048b96a3942156db0998e", "sha256": "283e1687914bdd7d4e2766678f81bfea7d6224403cb17bce9f3c66800904d949"}, "downloads": -1, "filename": "lektor-tags-0.3.tar.gz", "has_sig": false, "md5_digest": "75f26a97af0048b96a3942156db0998e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5765, "upload_time": "2018-12-15T02:14:16", "upload_time_iso_8601": "2018-12-15T02:14:16.459056Z", "url": "https://files.pythonhosted.org/packages/c3/43/bc69845f9d15555750c1fa52135283223086d2ee761443b3e0999ce7c468/lektor-tags-0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:06 2020"}