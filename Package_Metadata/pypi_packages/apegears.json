{"info": {"author": "shx2", "author_email": "shx222@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX", "Programming Language :: Python :: 3", "Topic :: Software Development"], "description": "=========\nApeGears\n=========\n\nAn improved ``ArgumentParser``, fully compatible with the standard ``argparse.ArgumentParser``.\n\n\nWhat is ApeGears?\n====================================\n\nApeGears' goal is making it easier to use the ``ArgumentParser``.\nIt provides simple and intuitive tools for achieving the most common use cases.\n\nApeGears defines an ``ArgumentParser`` which is a subclass of ``argparse.ArgumentParser``, and\nis fully compatible with it.\n\n\nWhat is wrong with ``argparse``?\n---------------------------------\n\nNothing.  It works great.\n\nHowever, it seems to be putting too much emphasis on being powerful, and too little on being intuitive.\nFor some actions, its interface is overly complicated.\nThe most common operations (e.g. defining flags and list arguments) are sometimes not perfectly intuitive.\n\nFurthermore, it seems to be missing some useful options, such as support for ``dict`` arguments.\nAlso, using arguments of custom types (using the ``type`` parameter) doesn't work as smoothly as you'd hope.\n\n\n\n\nFeaures\n====================================\n\nFollowing is an overview of the main features.  See below for more details on each.\n\n- Intuitive \"adder\" methods for defining arguments: ``add_positional``, ``add_optional``, ``add_flag``, ``add_list``.\n\n  - These cover the most common use cases.  You'd hardly ever need to use the basic ``add_argument`` method.\n\n- Dict arguments, using ``add_dict`` method.\n- Defining custom argument-types is simpler and more powerful, using \"specs\".\n- Builtin support for some standard python types.\n\n  - E.g. ``date``, ``datetime``, ``Path``, IP address, regular expression.\n\n- Builtin support for enum arguments.\n- Easy-to-use workaround append-with-nonempty-default `bug <https://bugs.python.org/issue16399>`_.\n- (PLANNED) Integration with other ``ArgumentParser``-related tools.\n\n\nAdder methods\n---------------------------------------\n\nThe standard all-in-one ``add_argument`` method is powerful, but not intuitive for some uses.\nIt has many kwargs, and not all combinations make sense.\n\nInstead, in most cases, you can use the more precise and convenient adder methods:\n\n- ``add_positional`` -- for defining positional arguments.\n- ``add_optional`` -- for defining optional (i.e. non-positional) arguments.\n- ``add_flag`` -- for defining (optional) flags (\"switches\").\n- ``add_list`` -- for defining (optional) list arguments.\n\n  - Multiple values can be passed in a single arg, or multiple.  The following are equivalent,\n    and result with ``{'chars': ['a', 'b', 'c', 'd']}``::\n\n        % prog.py --chars a b c d\n        % prog.py --chars a b --chars c d\n        % prog.py --chars a --chars b --chars c --chars d\n\nYou can still use the ``add_argument`` method for \"advanced\" argument definitions, but you'd rarely need to.\n\n\nDict arguments\n----------------\n\nUse ``add_dict`` for defining dict optional arguments.  E.g.::\n\n    parser.add_dict('--overrides')\n    parser.parse_args('--overrides log_level=debug logfile=out.log'.split()).overrides\n    => OrderedDict([('log_level', 'debug'), ('logfile', 'out.log')])\n\nSimilar to list arguments, multiple key-value pairs can be passed in a single arg, or multiple.\n\n\nCustom argument types\n-------------------------\n\n``argparse`` supports adding argument types by passing ``type=callable``, where ``callable``\nconverts the CLI string value to whatever you want (e.g. ``int`` converts the string to an integer).\n\nThis is not powerful enough, because often, when defining how a new argument type behaves, you'd want to include more\nthan just how to convert a CLI string.\n\nApeGears makes use of *Argument Type Specs*, which supports defining defaults for several fields:\n\n- names\n- default\n- choices\n- help\n- metavar\n\nEach of these can be explicitly overridden when calling the adder function.\n\nSuppose you have a type ``T`` which you want to use with the parser, so you define\na spec for it, ``Tspec``.\n\nFor supporting usage like ``parser.add_xxx(..., type=T, ...)``, you either:\n\n- register the spec: ``register_spec(T, Tspec)``\n- define a class attribute named ``__argparse__``. E.g.: ``T.__argparse__ = Tspec``\n\n\nAlternatively, this also works: ``parser.add_xxx(..., type=Tspec, ...)``\n\n\nArgument types for standard python types\n------------------------------------------\n\nArgument type specs are predefined for some standard python types.\nE.g., date, datetime, path, IP address, regular expression.\n\nCan be used like this::\n\n    parser.add_optional(..., type='date', ...)  # also works: type=datetime.date\n    parser.parse_args('--date 2020-03-04'.split()).date\n    => datetime.date(2020, 3, 4)\n\n\nEnum arguments\n----------------\n\nEnum types are also supported as argument types::\n\n    class Direction(Enum):\n        UP = 1\n        DOWN = 2\n        LEFT = 3\n        RIGHT = 4\n\n    parser.add_optional(type=Direction)\n    parser.parse_args('--direction LEFT'.split()).direction\n    => <Direction.LEFT: 3>\n\n\nThe append-with-nonempty-default issue\n------------------------------------------\n\nYou might have encountered a `bug <https://bugs.python.org/issue16399>`_ when using list arguments\nin the standard ``ArgumentParser``::\n\n    from argparse import ArgumentParser\n    parser = ArgumentParser()\n    parser.add_argument('list', action='append', default=['D'])\n    parser.parse_args('X'.split()).list\n    => ['D', 'X']  # expected: ['X']\n\nBasically, ``default``, instead of being used as a *default* value, is used as an *initial* value.\n\nThere is no easy-to-use workaround in the argparser level, but ApeGears provides one.\n\nThe ``add_list`` and ``add_dict`` methods include a workaround this issue.  It is enabled by default.\n\nIf you use the ``add_argument`` method directly, the workaround is disabled (for being compatible with ``argparse``),\nbut you can enable it by passing ``strict_default=True``.\n\n\nIntegration with other ``ArgumentParser``-related tools\n------------------------------------------------------------\n\nTo come...\n\n\n\nGetting Started\n====================================\n\nInstallation\n---------------\n\nUsing pip::\n\n    pip install apegears\n\n\nStart using the ``ArgumentParser``\n-----------------------------------\n\n``apegears.ArgumentParser`` is fully compatible with ``argparse``'s, so you can start\nby replacing your import lines::\n\n    import argparse            -->  import apegears\n    from argparse import ...   -->  from apegears import ...\n\n... to unleash the apes.\n\n\nWhat does the Name Mean?\n============================\nNothing. ::\n\n    argparse = list('argparse')\n    apegears = list('apegears')\n    while argparse != apegears:\n        random.shuffle(argparse)\n    print('Got it?')\n    print('Probably not...')", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/shx2/apegears", "keywords": "CLI argparse ArgumentParser optparse", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "apegears", "package_url": "https://pypi.org/project/apegears/", "platform": "POSIX", "project_url": "https://pypi.org/project/apegears/", "project_urls": {"Homepage": "https://github.com/shx2/apegears"}, "release_url": "https://pypi.org/project/apegears/0.1.0/", "requires_dist": null, "requires_python": "", "summary": "An improved ArgumentParser, fully compatible with argparse.", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>An improved <tt>ArgumentParser</tt>, fully compatible with the standard <tt>argparse.ArgumentParser</tt>.</p>\n<div id=\"what-is-apegears\">\n<h2>What is ApeGears?</h2>\n<p>ApeGears\u2019 goal is making it easier to use the <tt>ArgumentParser</tt>.\nIt provides simple and intuitive tools for achieving the most common use cases.</p>\n<p>ApeGears defines an <tt>ArgumentParser</tt> which is a subclass of <tt>argparse.ArgumentParser</tt>, and\nis fully compatible with it.</p>\n<div id=\"what-is-wrong-with-argparse\">\n<h3>What is wrong with <tt>argparse</tt>?</h3>\n<p>Nothing.  It works great.</p>\n<p>However, it seems to be putting too much emphasis on being powerful, and too little on being intuitive.\nFor some actions, its interface is overly complicated.\nThe most common operations (e.g. defining flags and list arguments) are sometimes not perfectly intuitive.</p>\n<p>Furthermore, it seems to be missing some useful options, such as support for <tt>dict</tt> arguments.\nAlso, using arguments of custom types (using the <tt>type</tt> parameter) doesn\u2019t work as smoothly as you\u2019d hope.</p>\n</div>\n</div>\n<div id=\"feaures\">\n<h2>Feaures</h2>\n<p>Following is an overview of the main features.  See below for more details on each.</p>\n<ul>\n<li>Intuitive \u201cadder\u201d methods for defining arguments: <tt>add_positional</tt>, <tt>add_optional</tt>, <tt>add_flag</tt>, <tt>add_list</tt>.<ul>\n<li>These cover the most common use cases.  You\u2019d hardly ever need to use the basic <tt>add_argument</tt> method.</li>\n</ul>\n</li>\n<li>Dict arguments, using <tt>add_dict</tt> method.</li>\n<li>Defining custom argument-types is simpler and more powerful, using \u201cspecs\u201d.</li>\n<li>Builtin support for some standard python types.<ul>\n<li>E.g. <tt>date</tt>, <tt>datetime</tt>, <tt>Path</tt>, IP address, regular expression.</li>\n</ul>\n</li>\n<li>Builtin support for enum arguments.</li>\n<li>Easy-to-use workaround append-with-nonempty-default <a href=\"https://bugs.python.org/issue16399\" rel=\"nofollow\">bug</a>.</li>\n<li>(PLANNED) Integration with other <tt>ArgumentParser</tt>-related tools.</li>\n</ul>\n<div id=\"adder-methods\">\n<h3>Adder methods</h3>\n<p>The standard all-in-one <tt>add_argument</tt> method is powerful, but not intuitive for some uses.\nIt has many kwargs, and not all combinations make sense.</p>\n<p>Instead, in most cases, you can use the more precise and convenient adder methods:</p>\n<ul>\n<li><p><tt>add_positional</tt> \u2013 for defining positional arguments.</p>\n</li>\n<li><p><tt>add_optional</tt> \u2013 for defining optional (i.e. non-positional) arguments.</p>\n</li>\n<li><p><tt>add_flag</tt> \u2013 for defining (optional) flags (\u201cswitches\u201d).</p>\n</li>\n<li><p><tt>add_list</tt> \u2013 for defining (optional) list arguments.</p>\n<ul>\n<li><p>Multiple values can be passed in a single arg, or multiple.  The following are equivalent,\nand result with <tt>{'chars': ['a', 'b', 'c', <span class=\"pre\">'d']}</span></tt>:</p>\n<pre>% prog.py --chars a b c d\n% prog.py --chars a b --chars c d\n% prog.py --chars a --chars b --chars c --chars d\n</pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>You can still use the <tt>add_argument</tt> method for \u201cadvanced\u201d argument definitions, but you\u2019d rarely need to.</p>\n</div>\n<div id=\"dict-arguments\">\n<h3>Dict arguments</h3>\n<p>Use <tt>add_dict</tt> for defining dict optional arguments.  E.g.:</p>\n<pre>parser.add_dict('--overrides')\nparser.parse_args('--overrides log_level=debug logfile=out.log'.split()).overrides\n=&gt; OrderedDict([('log_level', 'debug'), ('logfile', 'out.log')])\n</pre>\n<p>Similar to list arguments, multiple key-value pairs can be passed in a single arg, or multiple.</p>\n</div>\n<div id=\"custom-argument-types\">\n<h3>Custom argument types</h3>\n<p><tt>argparse</tt> supports adding argument types by passing <tt>type=callable</tt>, where <tt>callable</tt>\nconverts the CLI string value to whatever you want (e.g. <tt>int</tt> converts the string to an integer).</p>\n<p>This is not powerful enough, because often, when defining how a new argument type behaves, you\u2019d want to include more\nthan just how to convert a CLI string.</p>\n<p>ApeGears makes use of <em>Argument Type Specs</em>, which supports defining defaults for several fields:</p>\n<ul>\n<li>names</li>\n<li>default</li>\n<li>choices</li>\n<li>help</li>\n<li>metavar</li>\n</ul>\n<p>Each of these can be explicitly overridden when calling the adder function.</p>\n<p>Suppose you have a type <tt>T</tt> which you want to use with the parser, so you define\na spec for it, <tt>Tspec</tt>.</p>\n<p>For supporting usage like <tt><span class=\"pre\">parser.add_xxx(...,</span> type=T, <span class=\"pre\">...)</span></tt>, you either:</p>\n<ul>\n<li>register the spec: <tt>register_spec(T, Tspec)</tt></li>\n<li>define a class attribute named <tt>__argparse__</tt>. E.g.: <tt>T.__argparse__ = Tspec</tt></li>\n</ul>\n<p>Alternatively, this also works: <tt><span class=\"pre\">parser.add_xxx(...,</span> type=Tspec, <span class=\"pre\">...)</span></tt></p>\n</div>\n<div id=\"argument-types-for-standard-python-types\">\n<h3>Argument types for standard python types</h3>\n<p>Argument type specs are predefined for some standard python types.\nE.g., date, datetime, path, IP address, regular expression.</p>\n<p>Can be used like this:</p>\n<pre>parser.add_optional(..., type='date', ...)  # also works: type=datetime.date\nparser.parse_args('--date 2020-03-04'.split()).date\n=&gt; datetime.date(2020, 3, 4)\n</pre>\n</div>\n<div id=\"enum-arguments\">\n<h3>Enum arguments</h3>\n<p>Enum types are also supported as argument types:</p>\n<pre>class Direction(Enum):\n    UP = 1\n    DOWN = 2\n    LEFT = 3\n    RIGHT = 4\n\nparser.add_optional(type=Direction)\nparser.parse_args('--direction LEFT'.split()).direction\n=&gt; &lt;Direction.LEFT: 3&gt;\n</pre>\n</div>\n<div id=\"the-append-with-nonempty-default-issue\">\n<h3>The append-with-nonempty-default issue</h3>\n<p>You might have encountered a <a href=\"https://bugs.python.org/issue16399\" rel=\"nofollow\">bug</a> when using list arguments\nin the standard <tt>ArgumentParser</tt>:</p>\n<pre>from argparse import ArgumentParser\nparser = ArgumentParser()\nparser.add_argument('list', action='append', default=['D'])\nparser.parse_args('X'.split()).list\n=&gt; ['D', 'X']  # expected: ['X']\n</pre>\n<p>Basically, <tt>default</tt>, instead of being used as a <em>default</em> value, is used as an <em>initial</em> value.</p>\n<p>There is no easy-to-use workaround in the argparser level, but ApeGears provides one.</p>\n<p>The <tt>add_list</tt> and <tt>add_dict</tt> methods include a workaround this issue.  It is enabled by default.</p>\n<p>If you use the <tt>add_argument</tt> method directly, the workaround is disabled (for being compatible with <tt>argparse</tt>),\nbut you can enable it by passing <tt>strict_default=True</tt>.</p>\n</div>\n<div id=\"integration-with-other-argumentparser-related-tools\">\n<h3>Integration with other <tt>ArgumentParser</tt>-related tools</h3>\n<p>To come\u2026</p>\n</div>\n</div>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<div id=\"installation\">\n<h3>Installation</h3>\n<p>Using pip:</p>\n<pre>pip install apegears\n</pre>\n</div>\n<div id=\"start-using-the-argumentparser\">\n<h3>Start using the <tt>ArgumentParser</tt></h3>\n<p><tt>apegears.ArgumentParser</tt> is fully compatible with <tt>argparse</tt>\u2019s, so you can start\nby replacing your import lines:</p>\n<pre>import argparse            --&gt;  import apegears\nfrom argparse import ...   --&gt;  from apegears import ...\n</pre>\n<p>\u2026 to unleash the apes.</p>\n</div>\n</div>\n<div id=\"what-does-the-name-mean\">\n<h2>What does the Name Mean?</h2>\n<p>Nothing.</p>\n<pre>argparse = list('argparse')\napegears = list('apegears')\nwhile argparse != apegears:\n    random.shuffle(argparse)\nprint('Got it?')\nprint('Probably not...')\n</pre>\n</div>\n\n          </div>"}, "last_serial": 7156495, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "5c6b7745fd103bfb266f1c50b55c7643", "sha256": "43610c93d1a83fe23a2a1bfcd5184c2a382341a226335c0347431856e2ad4317"}, "downloads": -1, "filename": "apegears-0.1.0.tar.gz", "has_sig": false, "md5_digest": "5c6b7745fd103bfb266f1c50b55c7643", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13386, "upload_time": "2020-05-03T12:07:17", "upload_time_iso_8601": "2020-05-03T12:07:17.910705Z", "url": "https://files.pythonhosted.org/packages/dd/96/3a97446113f5a356c59b9b1297be3e54cc2d118e0e47f9bbe8df88d0a326/apegears-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5c6b7745fd103bfb266f1c50b55c7643", "sha256": "43610c93d1a83fe23a2a1bfcd5184c2a382341a226335c0347431856e2ad4317"}, "downloads": -1, "filename": "apegears-0.1.0.tar.gz", "has_sig": false, "md5_digest": "5c6b7745fd103bfb266f1c50b55c7643", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13386, "upload_time": "2020-05-03T12:07:17", "upload_time_iso_8601": "2020-05-03T12:07:17.910705Z", "url": "https://files.pythonhosted.org/packages/dd/96/3a97446113f5a356c59b9b1297be3e54cc2d118e0e47f9bbe8df88d0a326/apegears-0.1.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:51 2020"}