{"info": {"author": "Dustin Lacewell", "author_email": "dlacewell@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "pin\n======\n\n**pin** is a plugin-based command-line utility that helps you manage your software development projects. At it's core, it is a registry of where your projects reside on your file-system. Registering your project with **pin** lets you use utilize the various plugins. Since **pin** is generic, what this means exactly is based on what your project is and what plugins you have installed. \n\n### Installation \n\n    $ sudo pip install pin\n\n### Usage\n\nTo use **pin** you will need to source it's shell-script which is installed under the name **pin.sh**:\n\n    $ source pin.sh\n\nThe **pin** command will now be available to you. To see the core pin commands you can use the **help** command:\n\n    $ pin help\n    usage: pin [-v]\n    \n    optional arguments:\n      -v, --version  show program's version number and exit\n    \n    Available commands for /home/dlacewell/dev/mine/pin:\n    destroy  - Destroy and unregister the project from pin.\n         go  - Teleport to a specific project.\n       help  - This help information. \n       init  - Initialize pin in the current directory.\n    $ \n\nLets try out **pin init** in a new directory:\n\n    $ mkdir /tmp/testing\n    $ cd /tmp/testing\n    $ pin init\n    Creating .pin directory structure...\n    pin project initialized in: /tmp/testing\n    $\n\n**pin** has created a project directory located at */tmp/testing/.pin/* **Generally, commands that operate upon your project can be used *anywhere* below the project's root directory**. **pin** doesn't do much on it's own but plugins can add new functionality to existing commands or new commands all together. Let's go ahead and install the *pin-venv* plugins to give **pin** the ability to work with *VirtualEnv*.\n\n    $ sudo pip install pinvenv\n    ...\n    $ rm -fdr .pin/\n    $ pin init --venv\n    Creating .pin directory structure...\n    Creating virtualenv...\n    pin project initialized in: /tmp/testing\n    $ ls .pin/env\n    bin include lib\n    $\n\n### Core Commands\n\n**pin init** : Initializes the .pin directory and registers the path with ~/.pinconf/registry.yml\n\n**pin destroy** : Deletes the project's .pin directory and unregisters the project path. Only works from inside a project tree.\n\n**pin go <project-name>** : Teleports to the project root if a name is provided. If no name is provided a menu will be presented.\n\n**pin help** : Lists all pin commands including any provided by installed plugins.\n\n### Plugins\n\nPlugins to extend pin's core functionality can be found at the [Pin Cushion](https://github.com/dustinlacewell/pin/wiki/Pin-Cushion)\n\n\n### Writing Plugins\n\nPlugins for **pin** are packaged as Namespace packages. Ensure that your plugin package resembles the following structure:\n\n    yourpackage/\n      setup.py\n      requirements.tx\n      README\n      pin/\n        __init__.py\n        plugins/\n          __init__.py\n          yourpackage.py\n\nTo make your package namespaced you will need to add the following lines to each of the two **__init__.py** files:\n\n    import pkg_resources\n    pkg_resources.declare_namespace(__name__)\n\nThe two plugin-classes that you can register with pip are **commands** and **hooks**. Before covering those specifically, let's review some notable API available for plugins to use:\n\n### Utility API\n\n * **util.path_has_project(path)** : Determine if the supplied path contains the pin project-directory.\n\n * **util.get_project_root(path)** : Find the root project directory for the path, if there is one.\n\n * **util.get_settings_filename()** : Get the absolute path to the pin settings YAML file\n\n * **util.get_registry_filename()** : Get the absolute path to the pin registry YAML file\n\n\n### Writing Commands\n\nThe base command class is **command.Pincommand**. Your command will be a subclass that you register with **command.register(cls)**. There are a number of methods that you can override to define the behavior of your command. At minimum your class needs to define a class-attribute '**command**' which is the name of your command. Let's write a simple command called '*check*' the determines if the current-working-directory is inside of a pin project:\n\n    class CheckCommand(command.PinCommand):\n        command = 'check'\n\nJust to illustrate the proper way to handle arguments", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dustinlacewell/pin", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "pin", "package_url": "https://pypi.org/project/pin/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pin/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/dustinlacewell/pin"}, "release_url": "https://pypi.org/project/pin/0.1rc1/", "requires_dist": null, "requires_python": null, "summary": "pin is a generic project management tool for the commandline.", "version": "0.1rc1", "yanked": false, "html_description": "<div class=\"project-description\">\n            pin<br>======<br><br>**pin** is a plugin-based command-line utility that helps you manage your software development projects. At it's core, it is a registry of where your projects reside on your file-system. Registering your project with **pin** lets you use utilize the various plugins. Since **pin** is generic, what this means exactly is based on what your project is and what plugins you have installed. <br><br>### Installation <br><br>    $ sudo pip install pin<br><br>### Usage<br><br>To use **pin** you will need to source it's shell-script which is installed under the name **pin.sh**:<br><br>    $ source pin.sh<br><br>The **pin** command will now be available to you. To see the core pin commands you can use the **help** command:<br><br>    $ pin help<br>    usage: pin [-v]<br>    <br>    optional arguments:<br>      -v, --version  show program's version number and exit<br>    <br>    Available commands for /home/dlacewell/dev/mine/pin:<br>    destroy  - Destroy and unregister the project from pin.<br>         go  - Teleport to a specific project.<br>       help  - This help information. <br>       init  - Initialize pin in the current directory.<br>    $ <br><br>Lets try out **pin init** in a new directory:<br><br>    $ mkdir /tmp/testing<br>    $ cd /tmp/testing<br>    $ pin init<br>    Creating .pin directory structure...<br>    pin project initialized in: /tmp/testing<br>    $<br><br>**pin** has created a project directory located at */tmp/testing/.pin/* **Generally, commands that operate upon your project can be used *anywhere* below the project's root directory**. **pin** doesn't do much on it's own but plugins can add new functionality to existing commands or new commands all together. Let's go ahead and install the *pin-venv* plugins to give **pin** the ability to work with *VirtualEnv*.<br><br>    $ sudo pip install pinvenv<br>    ...<br>    $ rm -fdr .pin/<br>    $ pin init --venv<br>    Creating .pin directory structure...<br>    Creating virtualenv...<br>    pin project initialized in: /tmp/testing<br>    $ ls .pin/env<br>    bin include lib<br>    $<br><br>### Core Commands<br><br>**pin init** : Initializes the .pin directory and registers the path with ~/.pinconf/registry.yml<br><br>**pin destroy** : Deletes the project's .pin directory and unregisters the project path. Only works from inside a project tree.<br><br>**pin go &lt;project-name&gt;** : Teleports to the project root if a name is provided. If no name is provided a menu will be presented.<br><br>**pin help** : Lists all pin commands including any provided by installed plugins.<br><br>### Plugins<br><br>Plugins to extend pin's core functionality can be found at the [Pin Cushion](https://github.com/dustinlacewell/pin/wiki/Pin-Cushion)<br><br><br>### Writing Plugins<br><br>Plugins for **pin** are packaged as Namespace packages. Ensure that your plugin package resembles the following structure:<br><br>    yourpackage/<br>      setup.py<br>      requirements.tx<br>      README<br>      pin/<br>        __init__.py<br>        plugins/<br>          __init__.py<br>          yourpackage.py<br><br>To make your package namespaced you will need to add the following lines to each of the two **__init__.py** files:<br><br>    import pkg_resources<br>    pkg_resources.declare_namespace(__name__)<br><br>The two plugin-classes that you can register with pip are **commands** and **hooks**. Before covering those specifically, let's review some notable API available for plugins to use:<br><br>### Utility API<br><br> * **util.path_has_project(path)** : Determine if the supplied path contains the pin project-directory.<br><br> * **util.get_project_root(path)** : Find the root project directory for the path, if there is one.<br><br> * **util.get_settings_filename()** : Get the absolute path to the pin settings YAML file<br><br> * **util.get_registry_filename()** : Get the absolute path to the pin registry YAML file<br><br><br>### Writing Commands<br><br>The base command class is **command.Pincommand**. Your command will be a subclass that you register with **command.register(cls)**. There are a number of methods that you can override to define the behavior of your command. At minimum your class needs to define a class-attribute '**command**' which is the name of your command. Let's write a simple command called '*check*' the determines if the current-working-directory is inside of a pin project:<br><br>    class CheckCommand(command.PinCommand):<br>        command = 'check'<br><br>Just to illustrate the proper way to handle arguments\n          </div>"}, "last_serial": 796254, "releases": {"0.1rc1": [{"comment_text": "", "digests": {"md5": "772a059414e5968bb59ccf6faa1c750f", "sha256": "4b4aa0485beb767de22de5ebd91256b92f3033ff67f7786c5881a3da61aaf176"}, "downloads": -1, "filename": "pin-0.1rc1.tar.gz", "has_sig": false, "md5_digest": "772a059414e5968bb59ccf6faa1c750f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9076, "upload_time": "2011-04-15T17:55:11", "upload_time_iso_8601": "2011-04-15T17:55:11.774273Z", "url": "https://files.pythonhosted.org/packages/cf/81/f69af6685a26b435558bb7aead39127c38ce7dddb8d734a13db88ae3b9f8/pin-0.1rc1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "772a059414e5968bb59ccf6faa1c750f", "sha256": "4b4aa0485beb767de22de5ebd91256b92f3033ff67f7786c5881a3da61aaf176"}, "downloads": -1, "filename": "pin-0.1rc1.tar.gz", "has_sig": false, "md5_digest": "772a059414e5968bb59ccf6faa1c750f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9076, "upload_time": "2011-04-15T17:55:11", "upload_time_iso_8601": "2011-04-15T17:55:11.774273Z", "url": "https://files.pythonhosted.org/packages/cf/81/f69af6685a26b435558bb7aead39127c38ce7dddb8d734a13db88ae3b9f8/pin-0.1rc1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:54:37 2020"}