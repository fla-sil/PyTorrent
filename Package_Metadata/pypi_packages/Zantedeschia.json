{"info": {"author": "Thomas Kluyver", "author_email": "thomas@kluyver.me.uk", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Programming Language :: Python", "Programming Language :: Python :: 3"], "description": "Zantedeschia is an experimental alternative integration between asyncio and\nZeroMQ sockets.\n\nI started trying to use `aiozmq <https://github.com/aio-libs/aiozmq>`_, but I\nobjected to some of the design decisions. I borrowed ideas from that code, but\ndid a few things differently:\n\n1. ``aiozmq`` is built around asyncio's protocol and transport APIs, which I\n   find hard to use; even the simplest examples involve subclassing\n   ``ZmqProtocol``. Zantedeschia uses a single AsyncZMQSocket wrapper class,\n   with simple semantics.\n2. Zantedeschia does not include an RPC framework.\n3. Zantedeschia expects the user to create and connect ZMQ sockets using PyZMQ,\n   then wrap them in an AsyncZMQSocket object.\n\n*Zantedeschia* is a genus of flowers. Asyncio itself was originally codenamed\n'tulip', and a tradition developed of naming asyncio libraries after flowers.\n\nUse this at your own risk. MinRK, the author of PyZMQ, told me that I definitely\nshouldn't rely on the ZMQ file descriptors for an event loop, but I'm doing\nexactly that.\n\nPing server example:\n\n.. code:: python\n\n    import asyncio, zmq, zantedeschia\n\n    ctx = zmq.Context()\n    s = ctx.socket(zmq.REP)\n    s.bind('tcp://127.0.0.1:8123')\n    async_sock = zantedeschia.AsyncZMQSocket(s)\n\n    def pong():\n        while True:\n            msg_parts = yield from async_sock.recv_multipart()\n            yield from async_sock.send_multipart(msg_parts)\n\n    asyncio.get_event_loop().run_until_complete(pong())\n\nUsing the ``on_recv`` API instead:\n\n.. code:: python\n\n    import asyncio, zmq, zantedeschia\n\n    ctx = zmq.Context()\n    s = ctx.socket(zmq.REP)\n    s.bind('tcp://127.0.0.1:8123')\n    async_sock = zantedeschia.AsyncZMQSocket(s)\n\n    @async_sock.on_recv\n    def pong(msg_parts):\n        async_sock.send_multipart(msg_parts)\n\n    asyncio.get_event_loop().run_forever()", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/takluyver/Zantedeschia", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "Zantedeschia", "package_url": "https://pypi.org/project/Zantedeschia/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/Zantedeschia/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/takluyver/Zantedeschia"}, "release_url": "https://pypi.org/project/Zantedeschia/0.1/", "requires_dist": null, "requires_python": null, "summary": "ZeroMQ sockets integrated with the AsyncIO event loop", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Zantedeschia is an experimental alternative integration between asyncio and\nZeroMQ sockets.</p>\n<p>I started trying to use <a href=\"https://github.com/aio-libs/aiozmq\" rel=\"nofollow\">aiozmq</a>, but I\nobjected to some of the design decisions. I borrowed ideas from that code, but\ndid a few things differently:</p>\n<ol>\n<li><tt>aiozmq</tt> is built around asyncio\u2019s protocol and transport APIs, which I\nfind hard to use; even the simplest examples involve subclassing\n<tt>ZmqProtocol</tt>. Zantedeschia uses a single AsyncZMQSocket wrapper class,\nwith simple semantics.</li>\n<li>Zantedeschia does not include an RPC framework.</li>\n<li>Zantedeschia expects the user to create and connect ZMQ sockets using PyZMQ,\nthen wrap them in an AsyncZMQSocket object.</li>\n</ol>\n<p><em>Zantedeschia</em> is a genus of flowers. Asyncio itself was originally codenamed\n\u2018tulip\u2019, and a tradition developed of naming asyncio libraries after flowers.</p>\n<p>Use this at your own risk. MinRK, the author of PyZMQ, told me that I definitely\nshouldn\u2019t rely on the ZMQ file descriptors for an event loop, but I\u2019m doing\nexactly that.</p>\n<p>Ping server example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span><span class=\"o\">,</span> <span class=\"nn\">zmq</span><span class=\"o\">,</span> <span class=\"nn\">zantedeschia</span>\n\n<span class=\"n\">ctx</span> <span class=\"o\">=</span> <span class=\"n\">zmq</span><span class=\"o\">.</span><span class=\"n\">Context</span><span class=\"p\">()</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">socket</span><span class=\"p\">(</span><span class=\"n\">zmq</span><span class=\"o\">.</span><span class=\"n\">REP</span><span class=\"p\">)</span>\n<span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"s1\">'tcp://127.0.0.1:8123'</span><span class=\"p\">)</span>\n<span class=\"n\">async_sock</span> <span class=\"o\">=</span> <span class=\"n\">zantedeschia</span><span class=\"o\">.</span><span class=\"n\">AsyncZMQSocket</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">pong</span><span class=\"p\">():</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">msg_parts</span> <span class=\"o\">=</span> <span class=\"k\">yield from</span> <span class=\"n\">async_sock</span><span class=\"o\">.</span><span class=\"n\">recv_multipart</span><span class=\"p\">()</span>\n        <span class=\"k\">yield from</span> <span class=\"n\">async_sock</span><span class=\"o\">.</span><span class=\"n\">send_multipart</span><span class=\"p\">(</span><span class=\"n\">msg_parts</span><span class=\"p\">)</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">run_until_complete</span><span class=\"p\">(</span><span class=\"n\">pong</span><span class=\"p\">())</span>\n</pre>\n<p>Using the <tt>on_recv</tt> API instead:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span><span class=\"o\">,</span> <span class=\"nn\">zmq</span><span class=\"o\">,</span> <span class=\"nn\">zantedeschia</span>\n\n<span class=\"n\">ctx</span> <span class=\"o\">=</span> <span class=\"n\">zmq</span><span class=\"o\">.</span><span class=\"n\">Context</span><span class=\"p\">()</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">socket</span><span class=\"p\">(</span><span class=\"n\">zmq</span><span class=\"o\">.</span><span class=\"n\">REP</span><span class=\"p\">)</span>\n<span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"s1\">'tcp://127.0.0.1:8123'</span><span class=\"p\">)</span>\n<span class=\"n\">async_sock</span> <span class=\"o\">=</span> <span class=\"n\">zantedeschia</span><span class=\"o\">.</span><span class=\"n\">AsyncZMQSocket</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@async_sock</span><span class=\"o\">.</span><span class=\"n\">on_recv</span>\n<span class=\"k\">def</span> <span class=\"nf\">pong</span><span class=\"p\">(</span><span class=\"n\">msg_parts</span><span class=\"p\">):</span>\n    <span class=\"n\">async_sock</span><span class=\"o\">.</span><span class=\"n\">send_multipart</span><span class=\"p\">(</span><span class=\"n\">msg_parts</span><span class=\"p\">)</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">run_forever</span><span class=\"p\">()</span>\n</pre>\n\n          </div>"}, "last_serial": 1415548, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "e0d02a1d681c9e5a1cb558ec44cd840b", "sha256": "48104800c103189d4f45f8a18f353791a723ab797967a0be6afba3c75c1309d8"}, "downloads": -1, "filename": "Zantedeschia-0.1.tar.gz", "has_sig": false, "md5_digest": "e0d02a1d681c9e5a1cb558ec44cd840b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4006, "upload_time": "2015-02-09T01:29:53", "upload_time_iso_8601": "2015-02-09T01:29:53.148841Z", "url": "https://files.pythonhosted.org/packages/ba/3b/7ce39b5a9ac82e3e441eff56bb1898479c29d7455d9d30c86ac98256b364/Zantedeschia-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e0d02a1d681c9e5a1cb558ec44cd840b", "sha256": "48104800c103189d4f45f8a18f353791a723ab797967a0be6afba3c75c1309d8"}, "downloads": -1, "filename": "Zantedeschia-0.1.tar.gz", "has_sig": false, "md5_digest": "e0d02a1d681c9e5a1cb558ec44cd840b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4006, "upload_time": "2015-02-09T01:29:53", "upload_time_iso_8601": "2015-02-09T01:29:53.148841Z", "url": "https://files.pythonhosted.org/packages/ba/3b/7ce39b5a9ac82e3e441eff56bb1898479c29d7455d9d30c86ac98256b364/Zantedeschia-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:19:53 2020"}