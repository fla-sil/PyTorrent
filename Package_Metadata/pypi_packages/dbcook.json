{"info": {"author": "svilen dobrev", "author_email": "svilen_dobrev@users.sourceforge.net", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python", "Topic :: Database :: Front-Ends", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "A framework for declarative mapping of object hierarchies/relations into a\n(relational or not) database. Main idea is to abstract and hide the\nDB-related stuff as much as possible, automate all (routine) DB-definition tasks,\nstill exposing the backend where abstracting is not needed/possible.\n\nThe \"language/syntax\" itself is DB-backend independent.\nCurrently the available builder is over SQLAlchemy as backend.\n\nrepository: svn co https://dbcook.svn.sf.net/svnroot/dbcook/trunk\n\nAdditions:\n * complete bitemporal class-mix-in : trunk/dbcook/misc/timed2/\n * (independent) automatic aggregating columns : trunk/dbcook/misc/aggregator*\n * (independent) metadata management (load,copy,diff): trunk/dbcook/misc/metadata/\n\nUsage cases/levels:\n * DB-definition - completely hides/automates the table/ column/ key/ constraint/\n    mapper/ whatever creation. The user can control certain characteristics of the way\n    the mapping happens, mostly related to hierarchy and relations between objects\n    (subclasses, instances, leafs, uniqueness etc).\n * generate a source of equivalent plain SQLAlchemy-calls to build the DB-definition -\n    very useful for testing and/or generating routine mappings, with or without\n    actualy using dbcook afterwards\n * use plain SQLAlchemy once the definition is done - e.g. session.query( class)..\n * can partialy abstract the query generation, converting from plain\n    python functions/expressions (over objects' attributes) into backend/SQL clauses:\n    ``lambda self: (self.friend.manager.age < 40) & self.name.endswith('a')``\n * writing own reflectors (that walk the declared classes and\n    extract info from them), eventualy allowing different \"language/syntax\"\n\nFeatures:\n * data column types - the actual mapping is separate from object declaration\n * reference columns - plain, forward-declared, self-referential -> foreign keys\n * automatic solving of cyclical references/ dependencies (proper alter_table / post_update)\n * class inheritance, class inclusion (inheritance without db-mapping of the base),\n    and virtual classes (without instances). More in mapcontext._Base\n * polymorphism - 3 kinds of queries for each mapped class: all, base-only, subclasses only\n * any combination of table-inheritance-types within the tree -\n    joined/ concrete/ no-single-yet - defined localy or hierarchicaly;\n    beware that sql-polymorphism only works with joined-table for now\n * associations (many-to-many) - implicit and explicit\n * collections  (one-to-many)\n * dbcook.usage.samanager is a correct context-like keeper of all SQLAlchemy\n    things in one place; on destroy() will try hard to clear _all_ side-effects of its\n    existence, allowing reuse of same objects in several/different subsequent DB-mappings.\n\nTo use the framework, the internal dbcook/ has to be accessible somehow (PYTHONPATH or else).\nDependencies:\n * kjbuckets (from gadfly) for graph-arithmetics\n * SQLAlchemy, both 0.3 and 0.4\n\nExample (see trunk/dbcook/usage/example/):\n``\nimport dbcook.usage.plainwrap as o2r\nclass Text( o2r.Type): pass\n\nclass Address( Base):\n    place = Text()\n\nclass Person( o2r.Base):\n    name = Text()\n    address = o2r.Type4Reference( Address)\n    friend  = o2r.Type4Reference( 'Person')\n    DBCOOK_has_instances = True\n\nclass Employee( Person):\n    job = Text()\n    DBCOOK_inheritance = 'joined'\n\n#build it\no2r.Builder( metadata_from_sqlalchemy, locals(),\n    fieldtype_mapper= { Text: sqlalchemy.String(100) } )\n...\n``", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://dbcook.sf.net", "keywords": null, "license": "MIT License", "maintainer": null, "maintainer_email": null, "name": "dbcook", "package_url": "https://pypi.org/project/dbcook/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/dbcook/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://dbcook.sf.net"}, "release_url": "https://pypi.org/project/dbcook/0.2/", "requires_dist": null, "requires_python": null, "summary": "framework to abstract database-mapping of objects/relations as python declarations, completely hiding the DB where possible", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            A framework for declarative mapping of object hierarchies/relations into a<br>(relational or not) database. Main idea is to abstract and hide the<br>DB-related stuff as much as possible, automate all (routine) DB-definition tasks,<br>still exposing the backend where abstracting is not needed/possible.<br><br>The \"language/syntax\" itself is DB-backend independent.<br>Currently the available builder is over SQLAlchemy as backend.<br><br>repository: svn co https://dbcook.svn.sf.net/svnroot/dbcook/trunk<br><br>Additions:<br> * complete bitemporal class-mix-in : trunk/dbcook/misc/timed2/<br> * (independent) automatic aggregating columns : trunk/dbcook/misc/aggregator*<br> * (independent) metadata management (load,copy,diff): trunk/dbcook/misc/metadata/<br><br>Usage cases/levels:<br> * DB-definition - completely hides/automates the table/ column/ key/ constraint/<br>    mapper/ whatever creation. The user can control certain characteristics of the way<br>    the mapping happens, mostly related to hierarchy and relations between objects<br>    (subclasses, instances, leafs, uniqueness etc).<br> * generate a source of equivalent plain SQLAlchemy-calls to build the DB-definition -<br>    very useful for testing and/or generating routine mappings, with or without<br>    actualy using dbcook afterwards<br> * use plain SQLAlchemy once the definition is done - e.g. session.query( class)..<br> * can partialy abstract the query generation, converting from plain<br>    python functions/expressions (over objects' attributes) into backend/SQL clauses:<br>    ``lambda self: (self.friend.manager.age &lt; 40) &amp; self.name.endswith('a')``<br> * writing own reflectors (that walk the declared classes and<br>    extract info from them), eventualy allowing different \"language/syntax\"<br><br>Features:<br> * data column types - the actual mapping is separate from object declaration<br> * reference columns - plain, forward-declared, self-referential -&gt; foreign keys<br> * automatic solving of cyclical references/ dependencies (proper alter_table / post_update)<br> * class inheritance, class inclusion (inheritance without db-mapping of the base),<br>    and virtual classes (without instances). More in mapcontext._Base<br> * polymorphism - 3 kinds of queries for each mapped class: all, base-only, subclasses only<br> * any combination of table-inheritance-types within the tree -<br>    joined/ concrete/ no-single-yet - defined localy or hierarchicaly;<br>    beware that sql-polymorphism only works with joined-table for now<br> * associations (many-to-many) - implicit and explicit<br> * collections  (one-to-many)<br> * dbcook.usage.samanager is a correct context-like keeper of all SQLAlchemy<br>    things in one place; on destroy() will try hard to clear _all_ side-effects of its<br>    existence, allowing reuse of same objects in several/different subsequent DB-mappings.<br><br>To use the framework, the internal dbcook/ has to be accessible somehow (PYTHONPATH or else).<br>Dependencies:<br> * kjbuckets (from gadfly) for graph-arithmetics<br> * SQLAlchemy, both 0.3 and 0.4<br><br>Example (see trunk/dbcook/usage/example/):<br>``<br>import dbcook.usage.plainwrap as o2r<br>class Text( o2r.Type): pass<br><br>class Address( Base):<br>    place = Text()<br><br>class Person( o2r.Base):<br>    name = Text()<br>    address = o2r.Type4Reference( Address)<br>    friend  = o2r.Type4Reference( 'Person')<br>    DBCOOK_has_instances = True<br><br>class Employee( Person):<br>    job = Text()<br>    DBCOOK_inheritance = 'joined'<br><br>#build it<br>o2r.Builder( metadata_from_sqlalchemy, locals(),<br>    fieldtype_mapper= { Text: sqlalchemy.String(100) } )<br>...<br>``\n          </div>"}, "last_serial": 49400, "releases": {"0.1": [], "0.2": []}, "urls": [], "timestamp": "Fri May  8 00:39:58 2020"}