{"info": {"author": "", "author_email": "", "bugtrack_url": null, "classifiers": [], "description": "===============================\nScorekeeper\n===============================\n\n\n.. image:: https://img.shields.io/pypi/v/scorekeeper.svg\n        :target: https://pypi.python.org/pypi/scorekeeper\n\n.. image:: https://img.shields.io/travis/dhosterman/scorekeeper.svg\n        :target: https://travis-ci.org/dhosterman/scorekeeper\n\n.. image:: https://readthedocs.org/projects/scorekeeper/badge/?version=latest\n        :target: https://scorekeeper.readthedocs.io/en/latest/?badge=latest\n        :alt: Documentation Status\n\n.. image:: https://pyup.io/repos/github/dhosterman/scorekeeper/shield.svg\n     :target: https://pyup.io/repos/github/dhosterman/scorekeeper/\n     :alt: Updates\n\n\nKeep score of the results of functions over time and take action based on a generated score.\n\nSometimes, you have a problem that requires you to look at a set of circumstances over time and weigh them\nbefore taking action like intermittent failures in a system or calls to external APIs that may or may not respond.\n\nFor example, maybe you have an API endpoint you're monitoring and you want to do some self-healing, but only if\nthere are at least 5 failures in 5 minutes. You don't want to have a long-running process keeping state over 5 minutes,\nso you need something that will maintain state between calls. That might look something like this:\n\n    .. code-block:: python\n\n        @score(ShadyAPIScorekeeper, 20, threshold=100, decay=10, callback=restart_shady_api)\n        def check_shady_api():\n            if shady_api_test().successful:\n                return True\n            else:\n                return False\n            \nEvery time check_shady_api() is called and returns False, the ShadyAPIScorekeeper will accumulate 20 points. Once the\nthreshold of 100 points is reached, the callback will be executed. Because you might execute this script from a cron\njob or in some other intermittent fashion, the accumulated score for ShadyAPIScorekeeper is persisted on the local file\nsystem. Finally, the (optional) decay parameter lets you set the number of seconds it takes for the accumulated score to\ntick down by 1 point.\n\nIn this example, ShadyAPIScorekeeper is just a subclass of Scorekeeper and can have its own defaults set for things like\nthreshold, decay, and callback. This allows the decorator invocation to be much leaner. In addition, all instances of \na given subclass of Scorekeeper use the same persisted score, so you could decorate multiple functions all with different\npoints based on their severity in order to generate your final score and decide whether or not to take action.\n\nIn addition to using Scorekeeper as a decorator, you can also just directly interface with the objects you've described.\nFor example:\n\n    .. code-block:: python\n    \n        >>> score_keeper = ShadyApiScorekeeper()\n        >>> score_keeper.score\n        0\n        >>> score_keeper(10)\n        >>> score_keeper.score\n        10\n        >>> score_keeper(100)\n        Shady API restarted!\n\n\n* Free software: MIT license\n* Documentation: https://scorekeeper.readthedocs.io.\n\n\nFeatures\n--------\n\n* TODO\n\nCredits\n---------\n\nThis package was created with Cookiecutter_ and the `audreyr/cookiecutter-pypackage`_ project template.\n\n.. _Cookiecutter: https://github.com/audreyr/cookiecutter\n.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "scorekeeper", "package_url": "https://pypi.org/project/scorekeeper/", "platform": "", "project_url": "https://pypi.org/project/scorekeeper/", "project_urls": null, "release_url": "https://pypi.org/project/scorekeeper/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.python.org/pypi/scorekeeper\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/scorekeeper.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/002821c0abb931c37f7284084df981db6be6b650/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f73636f72656b65657065722e737667\"></a>\n<a href=\"https://travis-ci.org/dhosterman/scorekeeper\" rel=\"nofollow\"><img alt=\"https://img.shields.io/travis/dhosterman/scorekeeper.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/60875019e4e8564bdade52005e2a033c447f7bfb/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f64686f737465726d616e2f73636f72656b65657065722e737667\"></a>\n<a href=\"https://scorekeeper.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a94a9ad10692557837f7e1a28f3bf38a20d44e3f/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f73636f72656b65657065722f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<a href=\"https://pyup.io/repos/github/dhosterman/scorekeeper/\" rel=\"nofollow\"><img alt=\"Updates\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cd9b99e4525eedebf64c1d842db4e3f770260b9d/68747470733a2f2f707975702e696f2f7265706f732f6769746875622f64686f737465726d616e2f73636f72656b65657065722f736869656c642e737667\"></a>\n<p>Keep score of the results of functions over time and take action based on a generated score.</p>\n<p>Sometimes, you have a problem that requires you to look at a set of circumstances over time and weigh them\nbefore taking action like intermittent failures in a system or calls to external APIs that may or may not respond.</p>\n<p>For example, maybe you have an API endpoint you\u2019re monitoring and you want to do some self-healing, but only if\nthere are at least 5 failures in 5 minutes. You don\u2019t want to have a long-running process keeping state over 5 minutes,\nso you need something that will maintain state between calls. That might look something like this:</p>\n<blockquote>\n<pre><span class=\"nd\">@score</span><span class=\"p\">(</span><span class=\"n\">ShadyAPIScorekeeper</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">decay</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">restart_shady_api</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">check_shady_api</span><span class=\"p\">():</span>\n    <span class=\"k\">if</span> <span class=\"n\">shady_api_test</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">successful</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"kc\">True</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span>\n</pre>\n</blockquote>\n<p>Every time check_shady_api() is called and returns False, the ShadyAPIScorekeeper will accumulate 20 points. Once the\nthreshold of 100 points is reached, the callback will be executed. Because you might execute this script from a cron\njob or in some other intermittent fashion, the accumulated score for ShadyAPIScorekeeper is persisted on the local file\nsystem. Finally, the (optional) decay parameter lets you set the number of seconds it takes for the accumulated score to\ntick down by 1 point.</p>\n<p>In this example, ShadyAPIScorekeeper is just a subclass of Scorekeeper and can have its own defaults set for things like\nthreshold, decay, and callback. This allows the decorator invocation to be much leaner. In addition, all instances of\na given subclass of Scorekeeper use the same persisted score, so you could decorate multiple functions all with different\npoints based on their severity in order to generate your final score and decide whether or not to take action.</p>\n<p>In addition to using Scorekeeper as a decorator, you can also just directly interface with the objects you\u2019ve described.\nFor example:</p>\n<blockquote>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">score_keeper</span> <span class=\"o\">=</span> <span class=\"n\">ShadyApiScorekeeper</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">score_keeper</span><span class=\"o\">.</span><span class=\"n\">score</span>\n<span class=\"mi\">0</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">score_keeper</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">score_keeper</span><span class=\"o\">.</span><span class=\"n\">score</span>\n<span class=\"mi\">10</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">score_keeper</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"n\">Shady</span> <span class=\"n\">API</span> <span class=\"n\">restarted</span><span class=\"err\">!</span>\n</pre>\n</blockquote>\n<ul>\n<li>Free software: MIT license</li>\n<li>Documentation: <a href=\"https://scorekeeper.readthedocs.io\" rel=\"nofollow\">https://scorekeeper.readthedocs.io</a>.</li>\n</ul>\n<div id=\"features\">\n<h2>Features</h2>\n<ul>\n<li>TODO</li>\n</ul>\n</div>\n<div id=\"credits\">\n<h2>Credits</h2>\n<p>This package was created with <a href=\"https://github.com/audreyr/cookiecutter\" rel=\"nofollow\">Cookiecutter</a> and the <a href=\"https://github.com/audreyr/cookiecutter-pypackage\" rel=\"nofollow\">audreyr/cookiecutter-pypackage</a> project template.</p>\n</div>\n\n          </div>"}, "last_serial": 2368802, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "437c5a64103ff55e10011d3369a8e477", "sha256": "fe010fc15ffb298fd8960fd0dd095eb9e13ea0bda93eecd90e582ea2033cdd84"}, "downloads": -1, "filename": "scorekeeper-0.1.0.tar.gz", "has_sig": false, "md5_digest": "437c5a64103ff55e10011d3369a8e477", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14680, "upload_time": "2016-09-28T15:14:35", "upload_time_iso_8601": "2016-09-28T15:14:35.287488Z", "url": "https://files.pythonhosted.org/packages/cb/27/799f928d97e388a9afa89a5311649becc0f346f9627f544ad80088f228c3/scorekeeper-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "437c5a64103ff55e10011d3369a8e477", "sha256": "fe010fc15ffb298fd8960fd0dd095eb9e13ea0bda93eecd90e582ea2033cdd84"}, "downloads": -1, "filename": "scorekeeper-0.1.0.tar.gz", "has_sig": false, "md5_digest": "437c5a64103ff55e10011d3369a8e477", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14680, "upload_time": "2016-09-28T15:14:35", "upload_time_iso_8601": "2016-09-28T15:14:35.287488Z", "url": "https://files.pythonhosted.org/packages/cb/27/799f928d97e388a9afa89a5311649becc0f346f9627f544ad80088f228c3/scorekeeper-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:03 2020"}