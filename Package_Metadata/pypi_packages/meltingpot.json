{"info": {"author": "andrea capitanelli", "author_email": "andrea.capitanelli@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Artificial Intelligence"], "description": "\n# Meltingpot\n\nA ligthweight genetic algorithm for solving real-encoded optimization problems, with constraints too.\n\nInspired by the natural selection concept, originally developed by [Charles Darwin](https://en.wikipedia.org/wiki/Natural_selection), a genetic algorithm:\n\n1. Creates a random initial population of possible solutions (individuals).\n2. Generates a number of new populations, where each generation is created by performing:\n    - selection based on fitness evaluation,\n    - crossover between parents,\n    - mutation of individuals.\n\nWhen the generation process stops, best individual is chosen as the solution to given problem.\n\nSome caveats:\n\n- The optimization problem is handled as a *minimization* problem, that is Meltingpot tries to find the minimum of given objective function.\n- Unlike many common implementations, here fitness function is equal to the objective function: therefore, best individuals have lowest score and vice versa.\n\n### Usage examples\n\n##### Simple case\n\n```\nfrom meltingpot import GeneticAlgorithm\n\n# define the objective function - mandatory\nf = lambda x : (x[0]-1)**2+(x[1]-1)**2\n\n# define number of variables - mandatory too\nnvars = 2\n\n# init GA\nga = GeneticAlgorithm(f,nvars)\n\n# run and get solution with score\nsol,score = ga.run()\n```\n\nFunctions can be anonymous (lambda) or normal function objects. They must accept a vector of length *nvars* and return a scalar value.\n\n##### Rosenbrock function\nMinimize [Rosenbrock function](https://en.wikipedia.org/wiki/Rosenbrock_function) with a global minimum at *(1,1)*. Population set to 100 individuals, fixed mutation operator.\n\n```\nfrom meltingpot import GeneticAlgorithm, Mutation\n\n# Rosenbrock function\na = 1\nb = 100\nf = lambda x : (a-x[0])**2 + b*(x[1]-x[0]**2)**2\nnvars = 2\n\n# define mutation parameters\nmutation = Mutation(shrink=0.5,sigma=1)\n\n# define lower/upper boundaries for point coordinates\nLB=[-5,-5]\nUB=[10,10]\n\nga = GeneticAlgorithm(f,nvars,LB=LB,UB=UB,pop_size=100,mutation=mutation)\nsol,score = ga.run()\n```\n\nRun and display results:\n\n```\n>>> sol,score = ga.run()\n>>> print(sol)\n[1.00057427 1.00115261]\n>>> print(score)\n3.3118979646719515e-07\n```\n\n##### Constrained optimization\n\nMinimize the constrained G06 function, which has a minimum at *(14.095, 0.84296)* and is subject to following inequality constraints:\n\n- *-(x[0]-5)^2 - (x[1]-5)^2 + 100 <= 0*\n- *(x[0]-6)^2 + (x[1]-5)^2 - 82.81 <= 0*\n\n\n```\n# objective function - G06\nf = lambda x : (x[0]-10)**3 + (x[1]-20)**3\nnvars = 2\n\n# inequality constraints\ng1 = lambda x: -(x[0]-5)**2 - (x[1]-5)**2 + 100\ng2 = lambda x: (x[0]-6)**2 + (x[1]-5)**2 - 82.81\nics = [g1,g2]\n\n# define penalty schema\npenalty = Penalty(alpha=5,beta=5,C=1000)\n\n# define mutation operator\nmutation = Mutation(shrink=1,sigma=5)\n\n# init and run\nga = GeneticAlgorithm(f,nvars,ics=ics,LB=[13,0],UB=[100,100],pop_size=1000,num_iters=100,mutation=mutation,penalty=penalty)\nsol,score = ga.run()\n```\n\n### Boundaries\n\nLower and upper boundaries are defined by `LB` and `UB` parameters respectively. They must be a list with length equal to *nvars*.\n\nBoundaries are hard constraints, i.e. the algorithm admits only individuals inside boundaries.\n\n### Selection\n\nSelection is based on Stochastic Universal Sampling (SUS) technique and scales values according to their rank instead of their objective raw score, in order to mitigate effect of score variance. Given ranking of N individuals (where rank 1 is the most fit and N the least), scaled fitness holds 3 basic properties:\n\n1. Given an individual with rank k, it is proportional to 1/sqrt(k).\n2. Sum of scaled fitness is equal to the number of candidates needed for the new generation.\n3. Scaled values are inversely proportional to raw score, i.e. best individual has the highest scaled value and vice versa.\n\n### Elitism\n\nDefine number of elite members to keep with `elites` parameter:\n\n```\nga = GeneticAlgorithm(f,nvars,elites=2)\n```\nDefault value is `elites=2`.\n\n### Crossover\n\nCrossover rate sets the fraction of population which generated by crossover and can be set with `crossover` parameter:\n\n```\nga = GeneticAlgorithm(f,nvars,crossover=0.75)\n```\n\nDefault value is `crossover=0.6`.\n\nEach pair of parents generates two different individuals with intermediate point method: given parents *p1* and *p2*, child is *p1* + *rand*\\*(*p2*-*p1*), being *rand* uniformly distributed in [0,1].\n\n### Mutation\nThe total fraction of mutation children is equal to *1-crossover*.\n\nMutation changes individual vectors by adding a zero-mean gaussian random value to its entries; resulting value is clipped to lower/upper bounds. At each iteration sigma is updated according to a `shrink` value and the previous `sigma` value, so that *sigma_k = sigma_k-1 * (1-shrink * k/num_iters)* where *k* is current iteration. Setting *shrink=0* let `sigma` be constant.\n\nDefault values are `shrink=1` and `sigma=1`.\n\n### Constraints\n\nInequality and equality constraints can be passed as function objects using, respectively, `ics` and `ecs` parameters:\n\n```\n# objective\nf = lambda x: x[0]*x[1]\n\n# equality constraint: x+y=6\ng = lambda x: x[0]+x[1]-6\necs = [g]\n\n# customize the penalty policy\npenalty = Penalty(alpha=3,beta=3,C=100)\n\n# set boundaries\nLB = [-10,-10]\nUB = [10,10]\n\n# init and run\nga = GeneticAlgorithm(f,nvars,ecs=ecs,LB=LB,UB=UB,penalty=penalty)\nsol,score = ga.run()\n```\n\nMeltingpot handles constraints (both linear and nonlinear) through dynamic penalty functions. Penalty functions aim to replace the constrained optimization problem with an unconstrained problem, which is formed by adding cost terms - penalty functions - to the objective function. A penalty function is equal to zero if the constraint is satisfied, or a positive number if it is violated. Since individuals with lowest score are most fit, adding a positive term decreases their fitness.\n\nThe penalty evaluated at the ii-th iteration for individual *x* respect to constraint *cs* is *P = (ii\\*C)^a + v^b*, where *C*, *a* and *b* are constant values. For inequality constraints, value *v* is equal to *f(x)* if *cs* is violated or *0* otherwise. For equality constraints, *v* is equal to *abs(f(x))* is *cs* is violated or *0* otherwise.\n\nDefault values for penalty are: `C=1`,`alpha=2`,`beta=2`.\n\n### Cataclysms\n\nTo detect a premature convergence of individuals towards local solutions, a stall check is performed at each iteration. If stall conditions are verified, a catastrophic event is triggered. Cataclysms keep alive only a small fraction of most fitting individuals and re-generate the remainder of population.\n\nA stall condition is declared if average improvement in best score values over `stall_generations` is less than or equal to `tol_value`.\n\nCounters for mutation and penalty functions are reset, as a new evolution stage would actually imply.\n\n```\nfrom meltingpot import Stall\n\n# define a customized stall function\nstall = Stall(tol_value=0.1,stall_generations=10)\n\n# pass stall function\nga = GeneticAlgorithm(f,nvars,stall=stall)\n\n# set fraction of cataclism survivors\nga.survivors = 0.2\n\n```\nDefault value are `tol_value=0.01` and `stall_generations=5`.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/acapitanelli/meltingpot", "keywords": "optimization genetic algorithm constraints", "license": "MIT", "maintainer": "andrea capitanelli", "maintainer_email": "andrea.capitanelli@gmail.com", "name": "meltingpot", "package_url": "https://pypi.org/project/meltingpot/", "platform": "", "project_url": "https://pypi.org/project/meltingpot/", "project_urls": {"Homepage": "https://github.com/acapitanelli/meltingpot"}, "release_url": "https://pypi.org/project/meltingpot/1.0.0/", "requires_dist": ["numpy"], "requires_python": "", "summary": "A lightweight genetic algorithm module for optimization problems", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <br># Meltingpot<br><br>A ligthweight genetic algorithm for solving real-encoded optimization problems, with constraints too.<br><br>Inspired by the natural selection concept, originally developed by [Charles Darwin](https://en.wikipedia.org/wiki/Natural_selection), a genetic algorithm:<br><br>1. Creates a random initial population of possible solutions (individuals).<br>2. Generates a number of new populations, where each generation is created by performing:<br>    - selection based on fitness evaluation,<br>    - crossover between parents,<br>    - mutation of individuals.<br><br>When the generation process stops, best individual is chosen as the solution to given problem.<br><br>Some caveats:<br><br>- The optimization problem is handled as a *minimization* problem, that is Meltingpot tries to find the minimum of given objective function.<br>- Unlike many common implementations, here fitness function is equal to the objective function: therefore, best individuals have lowest score and vice versa.<br><br>### Usage examples<br><br>##### Simple case<br><br>```<br>from meltingpot import GeneticAlgorithm<br><br># define the objective function - mandatory<br>f = lambda x : (x[0]-1)**2+(x[1]-1)**2<br><br># define number of variables - mandatory too<br>nvars = 2<br><br># init GA<br>ga = GeneticAlgorithm(f,nvars)<br><br># run and get solution with score<br>sol,score = ga.run()<br>```<br><br>Functions can be anonymous (lambda) or normal function objects. They must accept a vector of length *nvars* and return a scalar value.<br><br>##### Rosenbrock function<br>Minimize [Rosenbrock function](https://en.wikipedia.org/wiki/Rosenbrock_function) with a global minimum at *(1,1)*. Population set to 100 individuals, fixed mutation operator.<br><br>```<br>from meltingpot import GeneticAlgorithm, Mutation<br><br># Rosenbrock function<br>a = 1<br>b = 100<br>f = lambda x : (a-x[0])**2 + b*(x[1]-x[0]**2)**2<br>nvars = 2<br><br># define mutation parameters<br>mutation = Mutation(shrink=0.5,sigma=1)<br><br># define lower/upper boundaries for point coordinates<br>LB=[-5,-5]<br>UB=[10,10]<br><br>ga = GeneticAlgorithm(f,nvars,LB=LB,UB=UB,pop_size=100,mutation=mutation)<br>sol,score = ga.run()<br>```<br><br>Run and display results:<br><br>```<br>&gt;&gt;&gt; sol,score = ga.run()<br>&gt;&gt;&gt; print(sol)<br>[1.00057427 1.00115261]<br>&gt;&gt;&gt; print(score)<br>3.3118979646719515e-07<br>```<br><br>##### Constrained optimization<br><br>Minimize the constrained G06 function, which has a minimum at *(14.095, 0.84296)* and is subject to following inequality constraints:<br><br>- *-(x[0]-5)^2 - (x[1]-5)^2 + 100 &lt;= 0*<br>- *(x[0]-6)^2 + (x[1]-5)^2 - 82.81 &lt;= 0*<br><br><br>```<br># objective function - G06<br>f = lambda x : (x[0]-10)**3 + (x[1]-20)**3<br>nvars = 2<br><br># inequality constraints<br>g1 = lambda x: -(x[0]-5)**2 - (x[1]-5)**2 + 100<br>g2 = lambda x: (x[0]-6)**2 + (x[1]-5)**2 - 82.81<br>ics = [g1,g2]<br><br># define penalty schema<br>penalty = Penalty(alpha=5,beta=5,C=1000)<br><br># define mutation operator<br>mutation = Mutation(shrink=1,sigma=5)<br><br># init and run<br>ga = GeneticAlgorithm(f,nvars,ics=ics,LB=[13,0],UB=[100,100],pop_size=1000,num_iters=100,mutation=mutation,penalty=penalty)<br>sol,score = ga.run()<br>```<br><br>### Boundaries<br><br>Lower and upper boundaries are defined by `LB` and `UB` parameters respectively. They must be a list with length equal to *nvars*.<br><br>Boundaries are hard constraints, i.e. the algorithm admits only individuals inside boundaries.<br><br>### Selection<br><br>Selection is based on Stochastic Universal Sampling (SUS) technique and scales values according to their rank instead of their objective raw score, in order to mitigate effect of score variance. Given ranking of N individuals (where rank 1 is the most fit and N the least), scaled fitness holds 3 basic properties:<br><br>1. Given an individual with rank k, it is proportional to 1/sqrt(k).<br>2. Sum of scaled fitness is equal to the number of candidates needed for the new generation.<br>3. Scaled values are inversely proportional to raw score, i.e. best individual has the highest scaled value and vice versa.<br><br>### Elitism<br><br>Define number of elite members to keep with `elites` parameter:<br><br>```<br>ga = GeneticAlgorithm(f,nvars,elites=2)<br>```<br>Default value is `elites=2`.<br><br>### Crossover<br><br>Crossover rate sets the fraction of population which generated by crossover and can be set with `crossover` parameter:<br><br>```<br>ga = GeneticAlgorithm(f,nvars,crossover=0.75)<br>```<br><br>Default value is `crossover=0.6`.<br><br>Each pair of parents generates two different individuals with intermediate point method: given parents *p1* and *p2*, child is *p1* + *rand*\\*(*p2*-*p1*), being *rand* uniformly distributed in [0,1].<br><br>### Mutation<br>The total fraction of mutation children is equal to *1-crossover*.<br><br>Mutation changes individual vectors by adding a zero-mean gaussian random value to its entries; resulting value is clipped to lower/upper bounds. At each iteration sigma is updated according to a `shrink` value and the previous `sigma` value, so that *sigma_k = sigma_k-1 * (1-shrink * k/num_iters)* where *k* is current iteration. Setting *shrink=0* let `sigma` be constant.<br><br>Default values are `shrink=1` and `sigma=1`.<br><br>### Constraints<br><br>Inequality and equality constraints can be passed as function objects using, respectively, `ics` and `ecs` parameters:<br><br>```<br># objective<br>f = lambda x: x[0]*x[1]<br><br># equality constraint: x+y=6<br>g = lambda x: x[0]+x[1]-6<br>ecs = [g]<br><br># customize the penalty policy<br>penalty = Penalty(alpha=3,beta=3,C=100)<br><br># set boundaries<br>LB = [-10,-10]<br>UB = [10,10]<br><br># init and run<br>ga = GeneticAlgorithm(f,nvars,ecs=ecs,LB=LB,UB=UB,penalty=penalty)<br>sol,score = ga.run()<br>```<br><br>Meltingpot handles constraints (both linear and nonlinear) through dynamic penalty functions. Penalty functions aim to replace the constrained optimization problem with an unconstrained problem, which is formed by adding cost terms - penalty functions - to the objective function. A penalty function is equal to zero if the constraint is satisfied, or a positive number if it is violated. Since individuals with lowest score are most fit, adding a positive term decreases their fitness.<br><br>The penalty evaluated at the ii-th iteration for individual *x* respect to constraint *cs* is *P = (ii\\*C)^a + v^b*, where *C*, *a* and *b* are constant values. For inequality constraints, value *v* is equal to *f(x)* if *cs* is violated or *0* otherwise. For equality constraints, *v* is equal to *abs(f(x))* is *cs* is violated or *0* otherwise.<br><br>Default values for penalty are: `C=1`,`alpha=2`,`beta=2`.<br><br>### Cataclysms<br><br>To detect a premature convergence of individuals towards local solutions, a stall check is performed at each iteration. If stall conditions are verified, a catastrophic event is triggered. Cataclysms keep alive only a small fraction of most fitting individuals and re-generate the remainder of population.<br><br>A stall condition is declared if average improvement in best score values over `stall_generations` is less than or equal to `tol_value`.<br><br>Counters for mutation and penalty functions are reset, as a new evolution stage would actually imply.<br><br>```<br>from meltingpot import Stall<br><br># define a customized stall function<br>stall = Stall(tol_value=0.1,stall_generations=10)<br><br># pass stall function<br>ga = GeneticAlgorithm(f,nvars,stall=stall)<br><br># set fraction of cataclism survivors<br>ga.survivors = 0.2<br><br>```<br>Default value are `tol_value=0.01` and `stall_generations=5`.<br><br><br>\n          </div>"}, "last_serial": 5226702, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "ac57e59e1c770558fc1cd02730c33073", "sha256": "196b2a5609395eafec51ed7ad1b3a22b2be7247d9bec6373c267623c03e23cde"}, "downloads": -1, "filename": "meltingpot-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "ac57e59e1c770558fc1cd02730c33073", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11747, "upload_time": "2019-05-04T21:56:06", "upload_time_iso_8601": "2019-05-04T21:56:06.736868Z", "url": "https://files.pythonhosted.org/packages/b6/bf/fc08a01184630ad46b91077a3e291fe9a165c4170e41784e40066caa2376/meltingpot-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b0499d3c5dc16d34f934143111aa2529", "sha256": "f5046c7f5a9ac0a8622c3d7eeaae4a9cd970278ee2a96fc584ab673871badb1c"}, "downloads": -1, "filename": "meltingpot-1.0.0.tar.gz", "has_sig": false, "md5_digest": "b0499d3c5dc16d34f934143111aa2529", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7810, "upload_time": "2019-05-04T21:56:08", "upload_time_iso_8601": "2019-05-04T21:56:08.858424Z", "url": "https://files.pythonhosted.org/packages/44/b4/bd9daa34a2b9e8a681b7fee169ed46701a174ccade282c46aa69ee6ba5ee/meltingpot-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ac57e59e1c770558fc1cd02730c33073", "sha256": "196b2a5609395eafec51ed7ad1b3a22b2be7247d9bec6373c267623c03e23cde"}, "downloads": -1, "filename": "meltingpot-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "ac57e59e1c770558fc1cd02730c33073", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11747, "upload_time": "2019-05-04T21:56:06", "upload_time_iso_8601": "2019-05-04T21:56:06.736868Z", "url": "https://files.pythonhosted.org/packages/b6/bf/fc08a01184630ad46b91077a3e291fe9a165c4170e41784e40066caa2376/meltingpot-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b0499d3c5dc16d34f934143111aa2529", "sha256": "f5046c7f5a9ac0a8622c3d7eeaae4a9cd970278ee2a96fc584ab673871badb1c"}, "downloads": -1, "filename": "meltingpot-1.0.0.tar.gz", "has_sig": false, "md5_digest": "b0499d3c5dc16d34f934143111aa2529", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7810, "upload_time": "2019-05-04T21:56:08", "upload_time_iso_8601": "2019-05-04T21:56:08.858424Z", "url": "https://files.pythonhosted.org/packages/44/b4/bd9daa34a2b9e8a681b7fee169ed46701a174ccade282c46aa69ee6ba5ee/meltingpot-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:22 2020"}