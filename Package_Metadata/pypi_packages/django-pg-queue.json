{"info": {"author": "SweetProcess", "author_email": "support@sweetprocess.com", "bugtrack_url": null, "classifiers": [], "description": "django-pg-queue\n=====================\n\ndjango-pg-queue is a task queue system for Django backed by postgres.\n\nIt was forked from the wonderful and simpler django-pg-queue (https://github.com/gavinwahl/django-postgres-queue/)\nWritten by Gavin Wahl.\n\n\nWhy postgres?\n-------------\n\nI thought you were never supposed to use an RDBMS as a queue? Well, postgres\nhas some features that make it not as bad as you might think, it has some\ncompelling advantages.\n\n- Transactional behavior and reliability.\n\n  Adding tasks is atomic with respect to other database work. There is no need\n  to use ``transaction.on_commit`` hooks and there is no risk of a transaction\n  being committed but the tasks it queued being lost.\n\n  Processing tasks is atomic with respect to other database work. Database work\n  done by a task will either be committed, or the task will not be marked as\n  processed, no exceptions. If the task only does database work, you achieve\n  true exactly-once message processing.\n\n- Operational simplicity\n\n  By reusing the durable, transactional storage that we're already using\n  anyway, there's no need to configure, monitor, and backup another stateful\n  service. For small teams and light workloads, this is the right trade-off.\n\n- Easy introspection\n\n  Since tasks are stored in a database table, it's easy to query and monitor\n  the state of the queue.\n\n- Safety\n\n  By using postgres transactions, there is no possibility of jobs being left in\n  a locked or ambiguous state if a worker dies. Tasks immediately become\n  available for another worker to pick up. You can even ``kill -9`` a worker\n  and be sure your database and queue will be left in a consistent state.\n\n- Priority queues\n\n  Since ordering is specified explicitly when selecting the next task to work\n  on, it's easy to ensure high-priority tasks are processed first.\n\n\n- Queues\n\n  Simply implemented by allowing filtering by a queue name in the query.\n\n\n\nDisadvantages\n-------------\n\n- Lower throughput than a dedicated queue server.\n- Harder to scale a relational database than a dedicated queue server.\n- Thundering herd. Postgres will notify all workers who LISTEN for the same name.\n- With at-least-once delivery, a postgres transaction has to be held open for\n  the duration of the task. For long running tasks, this can cause table bloat\n  and performance problems.\n- When a task crashes or raises an exception under at-least-once delivery, it\n  immediately becomes eligible to be retried. If you want to implement a retry\n  delay, you must catch exceptions and requeue the task with a delay. If your\n  task crashes without throwing an exception (eg SIGKILL), you could end up in\n  an endless retry loop that prevents other tasks from being processed.\n\n\nHow it works\n------------\n\ndjango-pg-queue is able to claim, process, and remove a task in a single (simplified)\nquery.\n\n.. code:: sql\n\n    DELETE FROM pgq_job\n    WHERE id = (\n        SELECT id\n        FROM pgq_job\n        WHERE execute_at <= now()\n        ORDER BY priority DESC, created_at\n        FOR UPDATE SKIP LOCKED\n        LIMIT 1\n    )\n    RETURNING *;\n\nAs soon as this query runs, the task is unable to be claimed by other workers.\nWhen the transaction commits, the task will be deleted. If the transaction\nrolls back or the worker crashes, the task will immediately become available\nfor another worker.\n\nTo achieve at-least-once delivery, we begin a transaction, process the task,\nthen commit the transaction. For at-most-once, we claim the task and\nimmediately commit the transaction, then process the task. For tasks that don't\nhave any external effects and only do database work, the at-least-once behavior\nis actually exactly-once (because both the claiming of the job and the database\nwork will commit or rollback together).\n\n\nComparison to Celery\n--------------------\n\ndjango-pg-queue fills the same role as Celery. You must use postgres as the backend\nand the library is small enough that you can read and understand all the code.\n\nUsage\n=====\n\nRequirements\n------------\n\ndjango-pg-queue requires Python 3, at least postgres 9.5 and at least\nDjango 2.1.\n\n\nInstallation\n------------\n\nInstall with pip::\n\n  pip install django-pg-queue\n\nThen add ``'pgq'`` to your ``INSTALLED_APPS``. Run ``manage.py migrate`` to\ncreate the jobs table.\n\nInstantiate a queue object. This can go wherever you like and be named whatever\nyou like. For example, ``someapp/queue.py``:\n\n.. code:: python\n\n    from pgq.queue import AtLeastOnceQueue\n\n    queue = AtLeastOnceQueue(\n        tasks={\n            # ...\n        },\n        queue='my-queue',\n        notify_channel='my-queue',\n    )\n\n\nYou will need to import this queue instance to queue or process tasks. Use\n``AtLeastOnceQueue`` for at-least-once delivery, or ``AtMostOnceQueue`` for\nat-most-once delivery.\n\ndjango-pg-queue comes with a management command base class that you can\nuse to consume your tasks. It can be called whatever you like, for example in a\n``someapp/managment/commands/worker.py``:\n\n.. code:: python\n\n    from pgq.commands import Worker\n\n    from someapp.queue import queue\n\n    class Command(Worker):\n        queue = queue\n\nThen you can run ``manage.py worker`` to start your worker.\n\nA task function takes two arguments -- the queue instance in use, and the Job\ninstance for this task. The function can be defined anywhere and called\nwhatever you like. Here's an example:\n\n.. code:: python\n\n    from dpq.decorators import task\n\n    from .queues import queue\n\n    @task(queue)\n    def debug_task(queue, job):\n        print(job.args)\n\nInstead of using the task decorator, you can manually register it as a task.\nAdd it to your queue instance when it is being created:\n\n.. code:: python\n\n    queue = AtLeastOnceQueue(tasks={\n        'debug_task': debug_task,\n    }, queue='my-queue')\n\nThe key is the task name, used to queue the task. It doesn't have to match the\nfunction name.\n\nTo queue the task, if you used the task decorator you may:\n\n.. code:: python\n\n    debug_task.enqueue({'some_args': 0})\n\n\nTo manually queue the task, use the ``enqueue`` method on your queue instance:\n\n.. code:: python\n\n    queue.enqueue('debug_task', {'some_args': 0})\n\nAssuming you have a worker running for this queue, the task will be run\nimmediately. The second argument must be a single json-serializeable value and\nwill be available to the task as ``job.args``.\n\nMultiple Queues\n---------------\n\nYou may run multiple queues and workers may each listen to a queue. You can have multiple workers\nlistening to the same queue too. A queue is implemented as a CharField in the database.\nThe queue would simply filter for jobs matching its queue name.\n\nBulk Enqueue\n------------\n\nMany jobs can be efficiently created using ``bulk_enqueue()`` which accepts one\ntask name for all the jobs being created and a list of dictionaries containing\n``args`` for the task to execute with and, optionally, ``priority`` and\n``execute_at`` for that particular job.\n\n.. code:: python\n\n    queue.bulk_enqueue(\n        'debug_task',\n        [\n            {'args': {'some_args': 0}},\n            {\n                'args': {'some_args': 10}\n                'priority': 10,\n                'execute_at': timezone.now() + timedelta(days=1),\n            },\n        ]\n    )\n\n\nMonitoring\n----------\n\nTasks are just database rows stored in the ``pgq_job`` table, so you can\nmonitor the system with SQL.\n\nTo get a count of current tasks:\n\n.. code:: sql\n\n    SELECT queue, count(*) FROM pgq_job WHERE execute_at <= now() GROUP BY queue\n\n\nThis will include both tasks ready to process and tasks currently being\nprocessed. To see tasks currently being processed, we need visibility into\npostgres row locks. This can be provided by the `pgrowlocks extension\n<https://www.postgresql.org/docs/9.6/static/pgrowlocks.html>`_.  Once\ninstalled, this query will count currently-running tasks:\n\n.. code:: sql\n\n    SELECT queue, count(*)\n    FROM pgrowlocks('pgq_job')\n    WHERE 'For Update' = ANY(modes)\n    GROUP BY queue;\n\nYou could join the results of ``pgrowlocks`` with ``pgq_job`` to get the full\nlist of tasks in progress if you want.\n\nLogging\n-------\n\ndjango-pg-queue logs through Python's logging framework, so can be\nconfigured with the ``LOGGING`` dict in your Django settings. It will not log\nanything under the default config, so be sure to configure some form of\nlogging. Everything is logged under the ``pgq`` namespace. Here is an example\nconfiguration that will log INFO level messages to stdout:\n\n.. code:: python\n\n    LOGGING = {\n        'version': 1,\n        'root': {\n            'level': 'DEBUG',\n            'handlers': ['console'],\n        },\n        'formatters': {\n            'verbose': {\n                'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s',\n            },\n        },\n        'handlers': {\n            'console': {\n                'level': 'INFO',\n                'class': 'logging.StreamHandler',\n                'formatter': 'verbose',\n            },\n        },\n        'loggers': {\n            'pgq': {\n                'handlers': ['console'],\n                'level': 'INFO',\n                'propagate': False,\n            },\n        }\n    }\n\nIt would also be sensible to log WARNING and higher messages to something like\nSentry:\n\n.. code:: python\n\n    LOGGING = {\n        'version': 1,\n        'root': {\n            'level': 'INFO',\n            'handlers': ['sentry', 'console'],\n        },\n        'formatters': {\n            'verbose': {\n                'format': '%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s',\n            },\n        },\n        'handlers': {\n            'console': {\n                'level': 'INFO',\n                'class': 'logging.StreamHandler',\n                'formatter': 'verbose',\n            },\n            'sentry': {\n                'level': 'WARNING',\n                'class': 'raven.contrib.django.handlers.SentryHandler',\n            },\n        },\n        'loggers': {\n            'pgq': {\n                'level': 'INFO',\n                'handlers': ['console', 'sentry'],\n                'propagate': False,\n            },\n        },\n    }\n\nYou could also log to a file by using the built-in ``logging.FileHandler``.\n\nUseful Recipes\n==============\nThese recipes aren't officially supported features of `django-pg-queue`. We provide them so that you can mimick some of the common features in other task queues.\n\n`CELERY_ALWAYS_EAGER`\n---------------------\nCelery uses the `CELERY_ALWAYS_EAGER` setting to run a task immediately, without queueing it for a worker. It could be used during tests, and while debugging in a development environment with any workers turned off.\n\n.. code:: python\n\n    class EagerAtLeastOnceQueue(AtLeastOnceQueue):\n        def enqueue(self, *args, **kwargs):\n            job = super().enqueue(*args, **kwargs)\n            if settings.QUEUE_ALWAYS_EAGER:\n                self.run_job(job)\n            return job\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/SweetProcess/django-pg-queue", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "django-pg-queue", "package_url": "https://pypi.org/project/django-pg-queue/", "platform": "", "project_url": "https://pypi.org/project/django-pg-queue/", "project_urls": {"Homepage": "https://github.com/SweetProcess/django-pg-queue"}, "release_url": "https://pypi.org/project/django-pg-queue/0.7.0/", "requires_dist": ["Django (>=2.1)"], "requires_python": "", "summary": "", "version": "0.7.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"django-pg-queue\">\n<h2>django-pg-queue</h2>\n<p>django-pg-queue is a task queue system for Django backed by postgres.</p>\n<p>It was forked from the wonderful and simpler django-pg-queue (<a href=\"https://github.com/gavinwahl/django-postgres-queue/\" rel=\"nofollow\">https://github.com/gavinwahl/django-postgres-queue/</a>)\nWritten by Gavin Wahl.</p>\n<div id=\"why-postgres\">\n<h3>Why postgres?</h3>\n<p>I thought you were never supposed to use an RDBMS as a queue? Well, postgres\nhas some features that make it not as bad as you might think, it has some\ncompelling advantages.</p>\n<ul>\n<li><p>Transactional behavior and reliability.</p>\n<p>Adding tasks is atomic with respect to other database work. There is no need\nto use <tt>transaction.on_commit</tt> hooks and there is no risk of a transaction\nbeing committed but the tasks it queued being lost.</p>\n<p>Processing tasks is atomic with respect to other database work. Database work\ndone by a task will either be committed, or the task will not be marked as\nprocessed, no exceptions. If the task only does database work, you achieve\ntrue exactly-once message processing.</p>\n</li>\n<li><p>Operational simplicity</p>\n<p>By reusing the durable, transactional storage that we\u2019re already using\nanyway, there\u2019s no need to configure, monitor, and backup another stateful\nservice. For small teams and light workloads, this is the right trade-off.</p>\n</li>\n<li><p>Easy introspection</p>\n<p>Since tasks are stored in a database table, it\u2019s easy to query and monitor\nthe state of the queue.</p>\n</li>\n<li><p>Safety</p>\n<p>By using postgres transactions, there is no possibility of jobs being left in\na locked or ambiguous state if a worker dies. Tasks immediately become\navailable for another worker to pick up. You can even <tt>kill <span class=\"pre\">-9</span></tt> a worker\nand be sure your database and queue will be left in a consistent state.</p>\n</li>\n<li><p>Priority queues</p>\n<p>Since ordering is specified explicitly when selecting the next task to work\non, it\u2019s easy to ensure high-priority tasks are processed first.</p>\n</li>\n<li><p>Queues</p>\n<p>Simply implemented by allowing filtering by a queue name in the query.</p>\n</li>\n</ul>\n</div>\n<div id=\"disadvantages\">\n<h3>Disadvantages</h3>\n<ul>\n<li>Lower throughput than a dedicated queue server.</li>\n<li>Harder to scale a relational database than a dedicated queue server.</li>\n<li>Thundering herd. Postgres will notify all workers who LISTEN for the same name.</li>\n<li>With at-least-once delivery, a postgres transaction has to be held open for\nthe duration of the task. For long running tasks, this can cause table bloat\nand performance problems.</li>\n<li>When a task crashes or raises an exception under at-least-once delivery, it\nimmediately becomes eligible to be retried. If you want to implement a retry\ndelay, you must catch exceptions and requeue the task with a delay. If your\ntask crashes without throwing an exception (eg SIGKILL), you could end up in\nan endless retry loop that prevents other tasks from being processed.</li>\n</ul>\n</div>\n<div id=\"how-it-works\">\n<h3>How it works</h3>\n<p>django-pg-queue is able to claim, process, and remove a task in a single (simplified)\nquery.</p>\n<pre><span class=\"k\">DELETE</span> <span class=\"k\">FROM</span> <span class=\"n\">pgq_job</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n    <span class=\"k\">SELECT</span> <span class=\"n\">id</span>\n    <span class=\"k\">FROM</span> <span class=\"n\">pgq_job</span>\n    <span class=\"k\">WHERE</span> <span class=\"n\">execute_at</span> <span class=\"o\">&lt;=</span> <span class=\"n\">now</span><span class=\"p\">()</span>\n    <span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">priority</span> <span class=\"k\">DESC</span><span class=\"p\">,</span> <span class=\"n\">created_at</span>\n    <span class=\"k\">FOR</span> <span class=\"k\">UPDATE</span> <span class=\"n\">SKIP</span> <span class=\"n\">LOCKED</span>\n    <span class=\"k\">LIMIT</span> <span class=\"mi\">1</span>\n<span class=\"p\">)</span>\n<span class=\"n\">RETURNING</span> <span class=\"o\">*</span><span class=\"p\">;</span>\n</pre>\n<p>As soon as this query runs, the task is unable to be claimed by other workers.\nWhen the transaction commits, the task will be deleted. If the transaction\nrolls back or the worker crashes, the task will immediately become available\nfor another worker.</p>\n<p>To achieve at-least-once delivery, we begin a transaction, process the task,\nthen commit the transaction. For at-most-once, we claim the task and\nimmediately commit the transaction, then process the task. For tasks that don\u2019t\nhave any external effects and only do database work, the at-least-once behavior\nis actually exactly-once (because both the claiming of the job and the database\nwork will commit or rollback together).</p>\n</div>\n<div id=\"comparison-to-celery\">\n<h3>Comparison to Celery</h3>\n<p>django-pg-queue fills the same role as Celery. You must use postgres as the backend\nand the library is small enough that you can read and understand all the code.</p>\n</div>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<div id=\"requirements\">\n<h3>Requirements</h3>\n<p>django-pg-queue requires Python 3, at least postgres 9.5 and at least\nDjango 2.1.</p>\n</div>\n<div id=\"installation\">\n<h3>Installation</h3>\n<p>Install with pip:</p>\n<pre>pip install django-pg-queue\n</pre>\n<p>Then add <tt>'pgq'</tt> to your <tt>INSTALLED_APPS</tt>. Run <tt>manage.py migrate</tt> to\ncreate the jobs table.</p>\n<p>Instantiate a queue object. This can go wherever you like and be named whatever\nyou like. For example, <tt>someapp/queue.py</tt>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pgq.queue</span> <span class=\"kn\">import</span> <span class=\"n\">AtLeastOnceQueue</span>\n\n<span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">AtLeastOnceQueue</span><span class=\"p\">(</span>\n    <span class=\"n\">tasks</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"c1\"># ...</span>\n    <span class=\"p\">},</span>\n    <span class=\"n\">queue</span><span class=\"o\">=</span><span class=\"s1\">'my-queue'</span><span class=\"p\">,</span>\n    <span class=\"n\">notify_channel</span><span class=\"o\">=</span><span class=\"s1\">'my-queue'</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n</pre>\n<p>You will need to import this queue instance to queue or process tasks. Use\n<tt>AtLeastOnceQueue</tt> for at-least-once delivery, or <tt>AtMostOnceQueue</tt> for\nat-most-once delivery.</p>\n<p>django-pg-queue comes with a management command base class that you can\nuse to consume your tasks. It can be called whatever you like, for example in a\n<tt>someapp/managment/commands/worker.py</tt>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pgq.commands</span> <span class=\"kn\">import</span> <span class=\"n\">Worker</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">someapp.queue</span> <span class=\"kn\">import</span> <span class=\"n\">queue</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Command</span><span class=\"p\">(</span><span class=\"n\">Worker</span><span class=\"p\">):</span>\n    <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">queue</span>\n</pre>\n<p>Then you can run <tt>manage.py worker</tt> to start your worker.</p>\n<p>A task function takes two arguments \u2013 the queue instance in use, and the Job\ninstance for this task. The function can be defined anywhere and called\nwhatever you like. Here\u2019s an example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">dpq.decorators</span> <span class=\"kn\">import</span> <span class=\"n\">task</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">.queues</span> <span class=\"kn\">import</span> <span class=\"n\">queue</span>\n\n<span class=\"nd\">@task</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">debug_task</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">,</span> <span class=\"n\">job</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">job</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">)</span>\n</pre>\n<p>Instead of using the task decorator, you can manually register it as a task.\nAdd it to your queue instance when it is being created:</p>\n<pre><span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">AtLeastOnceQueue</span><span class=\"p\">(</span><span class=\"n\">tasks</span><span class=\"o\">=</span><span class=\"p\">{</span>\n    <span class=\"s1\">'debug_task'</span><span class=\"p\">:</span> <span class=\"n\">debug_task</span><span class=\"p\">,</span>\n<span class=\"p\">},</span> <span class=\"n\">queue</span><span class=\"o\">=</span><span class=\"s1\">'my-queue'</span><span class=\"p\">)</span>\n</pre>\n<p>The key is the task name, used to queue the task. It doesn\u2019t have to match the\nfunction name.</p>\n<p>To queue the task, if you used the task decorator you may:</p>\n<pre><span class=\"n\">debug_task</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">({</span><span class=\"s1\">'some_args'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">})</span>\n</pre>\n<p>To manually queue the task, use the <tt>enqueue</tt> method on your queue instance:</p>\n<pre><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s1\">'debug_task'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'some_args'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">})</span>\n</pre>\n<p>Assuming you have a worker running for this queue, the task will be run\nimmediately. The second argument must be a single json-serializeable value and\nwill be available to the task as <tt>job.args</tt>.</p>\n</div>\n<div id=\"multiple-queues\">\n<h3>Multiple Queues</h3>\n<p>You may run multiple queues and workers may each listen to a queue. You can have multiple workers\nlistening to the same queue too. A queue is implemented as a CharField in the database.\nThe queue would simply filter for jobs matching its queue name.</p>\n</div>\n<div id=\"bulk-enqueue\">\n<h3>Bulk Enqueue</h3>\n<p>Many jobs can be efficiently created using <tt>bulk_enqueue()</tt> which accepts one\ntask name for all the jobs being created and a list of dictionaries containing\n<tt>args</tt> for the task to execute with and, optionally, <tt>priority</tt> and\n<tt>execute_at</tt> for that particular job.</p>\n<pre><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">bulk_enqueue</span><span class=\"p\">(</span>\n    <span class=\"s1\">'debug_task'</span><span class=\"p\">,</span>\n    <span class=\"p\">[</span>\n        <span class=\"p\">{</span><span class=\"s1\">'args'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'some_args'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">}},</span>\n        <span class=\"p\">{</span>\n            <span class=\"s1\">'args'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'some_args'</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">}</span>\n            <span class=\"s1\">'priority'</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>\n            <span class=\"s1\">'execute_at'</span><span class=\"p\">:</span> <span class=\"n\">timezone</span><span class=\"o\">.</span><span class=\"n\">now</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">days</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">]</span>\n<span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"monitoring\">\n<h3>Monitoring</h3>\n<p>Tasks are just database rows stored in the <tt>pgq_job</tt> table, so you can\nmonitor the system with SQL.</p>\n<p>To get a count of current tasks:</p>\n<pre><span class=\"k\">SELECT</span> <span class=\"n\">queue</span><span class=\"p\">,</span> <span class=\"k\">count</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">FROM</span> <span class=\"n\">pgq_job</span> <span class=\"k\">WHERE</span> <span class=\"n\">execute_at</span> <span class=\"o\">&lt;=</span> <span class=\"n\">now</span><span class=\"p\">()</span> <span class=\"k\">GROUP</span> <span class=\"k\">BY</span> <span class=\"n\">queue</span>\n</pre>\n<p>This will include both tasks ready to process and tasks currently being\nprocessed. To see tasks currently being processed, we need visibility into\npostgres row locks. This can be provided by the <a href=\"https://www.postgresql.org/docs/9.6/static/pgrowlocks.html\" rel=\"nofollow\">pgrowlocks extension</a>.  Once\ninstalled, this query will count currently-running tasks:</p>\n<pre><span class=\"k\">SELECT</span> <span class=\"n\">queue</span><span class=\"p\">,</span> <span class=\"k\">count</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span>\n<span class=\"k\">FROM</span> <span class=\"n\">pgrowlocks</span><span class=\"p\">(</span><span class=\"s1\">'pgq_job'</span><span class=\"p\">)</span>\n<span class=\"k\">WHERE</span> <span class=\"s1\">'For Update'</span> <span class=\"o\">=</span> <span class=\"k\">ANY</span><span class=\"p\">(</span><span class=\"n\">modes</span><span class=\"p\">)</span>\n<span class=\"k\">GROUP</span> <span class=\"k\">BY</span> <span class=\"n\">queue</span><span class=\"p\">;</span>\n</pre>\n<p>You could join the results of <tt>pgrowlocks</tt> with <tt>pgq_job</tt> to get the full\nlist of tasks in progress if you want.</p>\n</div>\n<div id=\"logging\">\n<h3>Logging</h3>\n<p>django-pg-queue logs through Python\u2019s logging framework, so can be\nconfigured with the <tt>LOGGING</tt> dict in your Django settings. It will not log\nanything under the default config, so be sure to configure some form of\nlogging. Everything is logged under the <tt>pgq</tt> namespace. Here is an example\nconfiguration that will log INFO level messages to stdout:</p>\n<pre><span class=\"n\">LOGGING</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'version'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"s1\">'root'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'level'</span><span class=\"p\">:</span> <span class=\"s1\">'DEBUG'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'handlers'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'console'</span><span class=\"p\">],</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'formatters'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'verbose'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'format'</span><span class=\"p\">:</span> <span class=\"s1\">'</span><span class=\"si\">%(levelname)s</span><span class=\"s1\"> </span><span class=\"si\">%(asctime)s</span><span class=\"s1\"> </span><span class=\"si\">%(module)s</span><span class=\"s1\"> </span><span class=\"si\">%(process)d</span><span class=\"s1\"> </span><span class=\"si\">%(thread)d</span><span class=\"s1\"> </span><span class=\"si\">%(message)s</span><span class=\"s1\">'</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'handlers'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'console'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'level'</span><span class=\"p\">:</span> <span class=\"s1\">'INFO'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'class'</span><span class=\"p\">:</span> <span class=\"s1\">'logging.StreamHandler'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'formatter'</span><span class=\"p\">:</span> <span class=\"s1\">'verbose'</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'loggers'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'pgq'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'handlers'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'console'</span><span class=\"p\">],</span>\n            <span class=\"s1\">'level'</span><span class=\"p\">:</span> <span class=\"s1\">'INFO'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'propagate'</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<p>It would also be sensible to log WARNING and higher messages to something like\nSentry:</p>\n<pre><span class=\"n\">LOGGING</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'version'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"s1\">'root'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'level'</span><span class=\"p\">:</span> <span class=\"s1\">'INFO'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'handlers'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'sentry'</span><span class=\"p\">,</span> <span class=\"s1\">'console'</span><span class=\"p\">],</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'formatters'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'verbose'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'format'</span><span class=\"p\">:</span> <span class=\"s1\">'</span><span class=\"si\">%(levelname)s</span><span class=\"s1\"> </span><span class=\"si\">%(asctime)s</span><span class=\"s1\"> </span><span class=\"si\">%(module)s</span><span class=\"s1\"> </span><span class=\"si\">%(process)d</span><span class=\"s1\"> </span><span class=\"si\">%(thread)d</span><span class=\"s1\"> </span><span class=\"si\">%(message)s</span><span class=\"s1\">'</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'handlers'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'console'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'level'</span><span class=\"p\">:</span> <span class=\"s1\">'INFO'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'class'</span><span class=\"p\">:</span> <span class=\"s1\">'logging.StreamHandler'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'formatter'</span><span class=\"p\">:</span> <span class=\"s1\">'verbose'</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'sentry'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'level'</span><span class=\"p\">:</span> <span class=\"s1\">'WARNING'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'class'</span><span class=\"p\">:</span> <span class=\"s1\">'raven.contrib.django.handlers.SentryHandler'</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'loggers'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'pgq'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'level'</span><span class=\"p\">:</span> <span class=\"s1\">'INFO'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'handlers'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'console'</span><span class=\"p\">,</span> <span class=\"s1\">'sentry'</span><span class=\"p\">],</span>\n            <span class=\"s1\">'propagate'</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n<span class=\"p\">}</span>\n</pre>\n<p>You could also log to a file by using the built-in <tt>logging.FileHandler</tt>.</p>\n</div>\n</div>\n<div id=\"useful-recipes\">\n<h2>Useful Recipes</h2>\n<p>These recipes aren\u2019t officially supported features of <cite>django-pg-queue</cite>. We provide them so that you can mimick some of the common features in other task queues.</p>\n<div id=\"celery-always-eager\">\n<h3><cite>CELERY_ALWAYS_EAGER</cite></h3>\n<p>Celery uses the <cite>CELERY_ALWAYS_EAGER</cite> setting to run a task immediately, without queueing it for a worker. It could be used during tests, and while debugging in a development environment with any workers turned off.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">EagerAtLeastOnceQueue</span><span class=\"p\">(</span><span class=\"n\">AtLeastOnceQueue</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">enqueue</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"n\">job</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">settings</span><span class=\"o\">.</span><span class=\"n\">QUEUE_ALWAYS_EAGER</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">run_job</span><span class=\"p\">(</span><span class=\"n\">job</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">job</span>\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7155974, "releases": {"0.5": [{"comment_text": "", "digests": {"md5": "60b6bd1ed825078e72111f31e07ec51a", "sha256": "a7f0b81f979de3bc83e55a38c2dec0c2f782077117054686225d4eb53780bb9c"}, "downloads": -1, "filename": "django_pg_queue-0.5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "60b6bd1ed825078e72111f31e07ec51a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 27467, "upload_time": "2020-02-28T06:14:49", "upload_time_iso_8601": "2020-02-28T06:14:49.321142Z", "url": "https://files.pythonhosted.org/packages/7f/bd/542815b6a65a4255b45eace93c3d71df76ab3ab90336036fb8abbaf80519/django_pg_queue-0.5.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b5e1aee97851baca354c0ac73b6e5c3f", "sha256": "34439c2ca237846524e2272492dbb29ed4251758681dfed8d79e27c0847deff0"}, "downloads": -1, "filename": "django_pg_queue-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "b5e1aee97851baca354c0ac73b6e5c3f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 18580, "upload_time": "2020-02-28T05:58:39", "upload_time_iso_8601": "2020-02-28T05:58:39.226799Z", "url": "https://files.pythonhosted.org/packages/7b/50/ddb5af0fb797e7b74c1151319e7fc5b4ad39eafee6de8825605e3a14d2fe/django_pg_queue-0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1af2e3d0d07ec52a82fa0245902fe3da", "sha256": "fd094e30755ff8d65ab4440f43aebae79ca35be2bb96dae8beb88aa5494f34cf"}, "downloads": -1, "filename": "django-pg-queue-0.5.tar.gz", "has_sig": false, "md5_digest": "1af2e3d0d07ec52a82fa0245902fe3da", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13978, "upload_time": "2020-02-28T05:58:42", "upload_time_iso_8601": "2020-02-28T05:58:42.390883Z", "url": "https://files.pythonhosted.org/packages/1e/56/ec24013c80870d9eb43de9ac670825a5b7360d939583aa01b602d8a7f013/django-pg-queue-0.5.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "32780ade1f64dee1eac817c13315cd7c", "sha256": "20a4207bb599c866ef01e84c997207203ba16eb831228c3534637420c5bce74f"}, "downloads": -1, "filename": "django_pg_queue-0.5.1-py3-none-any.whl", "has_sig": false, "md5_digest": "32780ade1f64dee1eac817c13315cd7c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 27464, "upload_time": "2020-02-28T06:16:55", "upload_time_iso_8601": "2020-02-28T06:16:55.344425Z", "url": "https://files.pythonhosted.org/packages/41/ec/ab0037657ac217b2bdb9b3c248efcad18b9796ccef1ee238db04b40dfb12/django_pg_queue-0.5.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "72e616cf4cb831304bb21b0bed5cb392", "sha256": "c9ec4838dfc1d6ade5734ad903a60044e2e8dd78b7a69e7cf06a70d73d6d2e58"}, "downloads": -1, "filename": "django-pg-queue-0.5.1.tar.gz", "has_sig": false, "md5_digest": "72e616cf4cb831304bb21b0bed5cb392", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13893, "upload_time": "2020-02-28T06:16:57", "upload_time_iso_8601": "2020-02-28T06:16:57.595114Z", "url": "https://files.pythonhosted.org/packages/6c/fe/7540f74d94d6971ac64317831709e31c26d5221edad7afa4b1d24d53e3be/django-pg-queue-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "dc03ab4f975412c030224a97c85a5c2f", "sha256": "0a88c41722a831196efcc99309da9425182eb65f67c363c0dc59993b33d5ad95"}, "downloads": -1, "filename": "django_pg_queue-0.5.2-py3-none-any.whl", "has_sig": false, "md5_digest": "dc03ab4f975412c030224a97c85a5c2f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13930, "upload_time": "2020-02-28T06:32:39", "upload_time_iso_8601": "2020-02-28T06:32:39.646886Z", "url": "https://files.pythonhosted.org/packages/fa/33/450dd85590cee3c546dab25e3e7e5746235a297d311f2dfe69b6a790b0ad/django_pg_queue-0.5.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "cabfcf24ba76f162388a6f71d90eb207", "sha256": "d5c7269756aaed995e30dc8352c485b7b5b6a2bd0d302413f30fdb97e092773b"}, "downloads": -1, "filename": "django-pg-queue-0.5.2.tar.gz", "has_sig": false, "md5_digest": "cabfcf24ba76f162388a6f71d90eb207", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11541, "upload_time": "2020-02-28T06:32:41", "upload_time_iso_8601": "2020-02-28T06:32:41.507681Z", "url": "https://files.pythonhosted.org/packages/9d/9f/80465c3459e975f85b2a07270454c861e807a7391650bfb44c019e7f0b72/django-pg-queue-0.5.2.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "c7fb70e577a03ee5bf72212da07f730c", "sha256": "6c36a3e1e097016283c23c6fa9dd4a01a21c7fb5d86be157f301b30b2180ab37"}, "downloads": -1, "filename": "django_pg_queue-0.6.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "c7fb70e577a03ee5bf72212da07f730c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 14223, "upload_time": "2020-04-29T12:47:57", "upload_time_iso_8601": "2020-04-29T12:47:57.976206Z", "url": "https://files.pythonhosted.org/packages/ff/e1/21f592e0defade41de22f5e0b1504df43d6ebfef6e36a6d3826862e685d7/django_pg_queue-0.6.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ec87c4551ff5359cc5ebd0fc2dcebb6d", "sha256": "e7740a7c51fd3689855ccd17f983a397bf5f20d785ba629ca75f5c7f6b56c536"}, "downloads": -1, "filename": "django-pg-queue-0.6.0.tar.gz", "has_sig": false, "md5_digest": "ec87c4551ff5359cc5ebd0fc2dcebb6d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11683, "upload_time": "2020-04-29T12:47:59", "upload_time_iso_8601": "2020-04-29T12:47:59.897089Z", "url": "https://files.pythonhosted.org/packages/e5/83/0cdcd3390a83bec701d7336767327fda230a470c890dc81c941039e748b6/django-pg-queue-0.6.0.tar.gz", "yanked": false}], "0.6.1": [{"comment_text": "", "digests": {"md5": "61e3b157fa24716ca946c471b59da13d", "sha256": "2d80c0e0c02639fcedba5df97c56f1f37a43bb88ea800b37a3e251fe0add6f4f"}, "downloads": -1, "filename": "django_pg_queue-0.6.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "61e3b157fa24716ca946c471b59da13d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 14503, "upload_time": "2020-04-30T07:42:06", "upload_time_iso_8601": "2020-04-30T07:42:06.786263Z", "url": "https://files.pythonhosted.org/packages/86/4a/5bbd917ef29e717e216449430d404e591ec9354002024ba847f274739232/django_pg_queue-0.6.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "12e2d94ae9115121971d36f9b362f620", "sha256": "d4e96a5ba76ad2d24fcd463cde2a62af90d6bf863c22712777c67cec47ed35ea"}, "downloads": -1, "filename": "django-pg-queue-0.6.1.tar.gz", "has_sig": false, "md5_digest": "12e2d94ae9115121971d36f9b362f620", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11942, "upload_time": "2020-04-30T07:42:08", "upload_time_iso_8601": "2020-04-30T07:42:08.567961Z", "url": "https://files.pythonhosted.org/packages/68/be/403e2345de870bd2364a083aa543aa114b2d5fcd867a33cd6723b1578145/django-pg-queue-0.6.1.tar.gz", "yanked": false}], "0.7.0": [{"comment_text": "", "digests": {"md5": "a984c202bec546288e33db65093a1ba3", "sha256": "ed06eb62cfba56435e6df5d0228c3c541717f26f5a7102c26fdd40e352e02fcd"}, "downloads": -1, "filename": "django_pg_queue-0.7.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a984c202bec546288e33db65093a1ba3", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15611, "upload_time": "2020-05-03T10:41:24", "upload_time_iso_8601": "2020-05-03T10:41:24.237108Z", "url": "https://files.pythonhosted.org/packages/df/17/7508737e1c766f32e30d7b43392dfb0c4dcca562d90f7c9474ed06eac25d/django_pg_queue-0.7.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f2c0d719a201cf0b87304540a99687aa", "sha256": "3de594a504c937c288d03d9622d6f0ba17f9a979687631175fe9cf65b3b39d62"}, "downloads": -1, "filename": "django-pg-queue-0.7.0.tar.gz", "has_sig": false, "md5_digest": "f2c0d719a201cf0b87304540a99687aa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13037, "upload_time": "2020-05-03T10:41:25", "upload_time_iso_8601": "2020-05-03T10:41:25.974980Z", "url": "https://files.pythonhosted.org/packages/f4/0a/76a172505966b2d248249e1b7a59eb0e479dd20d0d84ccf8d935fc8a7786/django-pg-queue-0.7.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a984c202bec546288e33db65093a1ba3", "sha256": "ed06eb62cfba56435e6df5d0228c3c541717f26f5a7102c26fdd40e352e02fcd"}, "downloads": -1, "filename": "django_pg_queue-0.7.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a984c202bec546288e33db65093a1ba3", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15611, "upload_time": "2020-05-03T10:41:24", "upload_time_iso_8601": "2020-05-03T10:41:24.237108Z", "url": "https://files.pythonhosted.org/packages/df/17/7508737e1c766f32e30d7b43392dfb0c4dcca562d90f7c9474ed06eac25d/django_pg_queue-0.7.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f2c0d719a201cf0b87304540a99687aa", "sha256": "3de594a504c937c288d03d9622d6f0ba17f9a979687631175fe9cf65b3b39d62"}, "downloads": -1, "filename": "django-pg-queue-0.7.0.tar.gz", "has_sig": false, "md5_digest": "f2c0d719a201cf0b87304540a99687aa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13037, "upload_time": "2020-05-03T10:41:25", "upload_time_iso_8601": "2020-05-03T10:41:25.974980Z", "url": "https://files.pythonhosted.org/packages/f4/0a/76a172505966b2d248249e1b7a59eb0e479dd20d0d84ccf8d935fc8a7786/django-pg-queue-0.7.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:05 2020"}