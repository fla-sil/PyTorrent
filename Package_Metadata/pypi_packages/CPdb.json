{"info": {"author": "Steven Joseph", "author_email": "steven@stevenjoseph.in", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: Unix", "Programming Language :: Python", "Topic :: Software Development :: Debuggers", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# What the what?\n \n cpdb lets you load a modified pdb/ipdb early in your (long running) python\n program, and set break points during run time. It uses a c extension to\n minimize performance impact when the debugger is enabled. The debugger\n watches a file (~/.cpdb/breakpoints) for breakpoints, you can add\n breakpoints in this file using any method and the debugger will stop\n your program and drop to a ipdb prompt when it hits the specified\n line.\n \n The break point file is in the format\n \n <full filename>:<lineno>\n \n Eg:\n \n ```\n     #this is a comment\n     /home/foo/pythonfu.py:15\n     /home/foo/bar.py:10\n ```\n \n you can use you favorite editor to insert breakpoints \\o/.\n \n There is no need to reload code or restart the app to\n set pdb break points. If there are no breakpoints specified in the\n file the debugger is disabled and there will be no performance impact,\n until the debugger is enabled again.\n \n Works across threads created by the threading module.\n \n # How ?\n \n Pdb basically hooks on sys.settrace to analyze each line being\n executed, running pdb on a large app, significantly slows it down.\n cpdb has a c-api extension method to use as the sys.settrace method\n which filters out lines on which there are no breakpoints set and\n calls the pdb dispatch only if there is a break point on the line.\n \n # Usage :\n \n     :::python\n         from cpdb import Debugger\n         Debugger().observe_breakpoints()\n \n \n # Emacs config :\n \n     :::lisp\n         (defun clear-breakpoints nil\n           (interactive)\n           (write-region \"\" nil \"~/.cpdb/breakpoints\"))\n         \n         (defun remove-breakpoint nil\n           (interactive)\n           (let ((bpfile \"~/.cpdb/breakpoints\")\n                 (bpline (format \"%s:%s\" (buffer-file-name) (line-number-at-pos (point)))))\n             (with-temp-buffer\n               (insert-file-contents bpfile)\n               (goto-char (point-min))\n               (flush-lines bpline)\n               (when (file-writable-p bpfile)\n                 (write-region (point-min) (point-max) bpfile)))))\n         \n         (defun add-breakpoint nil\n           (interactive)\n           (let ((bpfile \"~/.cpdb/breakpoints\")\n                 (bpline (format \"%s:%s\" (buffer-file-name) (line-number-at-pos (point)))))\n             (with-temp-buffer\n               (insert-file-contents bpfile)\n               (goto-char (point-min))\n               (flush-lines bpline)\n               (insert bpline)\n               (insert \"\\n\")\n               (sort-lines nil (point-min) (point-max))\n               (when (file-writable-p bpfile)\n                 (write-region (point-min) (point-max) bpfile)))))\n         \n         (define-key global-map (kbd \"<f8>\" ) 'add-breakpoint)\n         (define-key global-map (kbd \"<f7>\" ) 'remove-breakpoint)", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/jagguli/cpdb", "keywords": null, "license": "https://www.gnu.org/copyleft/gpl.html", "maintainer": null, "maintainer_email": null, "name": "CPdb", "package_url": "https://pypi.org/project/CPdb/", "platform": "unix", "project_url": "https://pypi.org/project/CPdb/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://bitbucket.org/jagguli/cpdb"}, "release_url": "https://pypi.org/project/CPdb/0.1/", "requires_dist": null, "requires_python": null, "summary": "cpdb - pdb/ipdb speed up using c extension and set/unset breakpoints without code", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            # What the what?<br> <br> cpdb lets you load a modified pdb/ipdb early in your (long running) python<br> program, and set break points during run time. It uses a c extension to<br> minimize performance impact when the debugger is enabled. The debugger<br> watches a file (~/.cpdb/breakpoints) for breakpoints, you can add<br> breakpoints in this file using any method and the debugger will stop<br> your program and drop to a ipdb prompt when it hits the specified<br> line.<br> <br> The break point file is in the format<br> <br> &lt;full filename&gt;:&lt;lineno&gt;<br> <br> Eg:<br> <br> ```<br>     #this is a comment<br>     /home/foo/pythonfu.py:15<br>     /home/foo/bar.py:10<br> ```<br> <br> you can use you favorite editor to insert breakpoints \\o/.<br> <br> There is no need to reload code or restart the app to<br> set pdb break points. If there are no breakpoints specified in the<br> file the debugger is disabled and there will be no performance impact,<br> until the debugger is enabled again.<br> <br> Works across threads created by the threading module.<br> <br> # How ?<br> <br> Pdb basically hooks on sys.settrace to analyze each line being<br> executed, running pdb on a large app, significantly slows it down.<br> cpdb has a c-api extension method to use as the sys.settrace method<br> which filters out lines on which there are no breakpoints set and<br> calls the pdb dispatch only if there is a break point on the line.<br> <br> # Usage :<br> <br>     :::python<br>         from cpdb import Debugger<br>         Debugger().observe_breakpoints()<br> <br> <br> # Emacs config :<br> <br>     :::lisp<br>         (defun clear-breakpoints nil<br>           (interactive)<br>           (write-region \"\" nil \"~/.cpdb/breakpoints\"))<br>         <br>         (defun remove-breakpoint nil<br>           (interactive)<br>           (let ((bpfile \"~/.cpdb/breakpoints\")<br>                 (bpline (format \"%s:%s\" (buffer-file-name) (line-number-at-pos (point)))))<br>             (with-temp-buffer<br>               (insert-file-contents bpfile)<br>               (goto-char (point-min))<br>               (flush-lines bpline)<br>               (when (file-writable-p bpfile)<br>                 (write-region (point-min) (point-max) bpfile)))))<br>         <br>         (defun add-breakpoint nil<br>           (interactive)<br>           (let ((bpfile \"~/.cpdb/breakpoints\")<br>                 (bpline (format \"%s:%s\" (buffer-file-name) (line-number-at-pos (point)))))<br>             (with-temp-buffer<br>               (insert-file-contents bpfile)<br>               (goto-char (point-min))<br>               (flush-lines bpline)<br>               (insert bpline)<br>               (insert \"\\n\")<br>               (sort-lines nil (point-min) (point-max))<br>               (when (file-writable-p bpfile)<br>                 (write-region (point-min) (point-max) bpfile)))))<br>         <br>         (define-key global-map (kbd \"&lt;f8&gt;\" ) 'add-breakpoint)<br>         (define-key global-map (kbd \"&lt;f7&gt;\" ) 'remove-breakpoint)\n          </div>"}, "last_serial": 1024419, "releases": {"0.1": []}, "urls": [], "timestamp": "Fri May  8 00:42:41 2020"}