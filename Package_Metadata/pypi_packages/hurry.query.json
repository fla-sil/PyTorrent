{"info": {"author": "Infrae", "author_email": "faassen@startifact.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP"], "description": "Hurry Query\n===========\n\nThe hurry query system for the zope.catalog builds on its catalog\nindexes, as well as the indexes in zc.catalog. It is in part inspired\nby AdvancedQuery for Zope 2 by Dieter Maurer, though has an independent\norigin.\n\n.. contents::\n\nSetup\n-----\n\nLet&#x27;s define a simple content object. First its interface::\n\n  &gt;&gt;&gt; from zope.interface import Interface, Attribute, implementer\n  &gt;&gt;&gt; class IContent(Interface):\n  ...     f1 = Attribute(&#x27;f1&#x27;)\n  ...     f2 = Attribute(&#x27;f2&#x27;)\n  ...     f3 = Attribute(&#x27;f3&#x27;)\n  ...     f4 = Attribute(&#x27;f4&#x27;)\n  ...     t1 = Attribute(&#x27;t1&#x27;)\n  ...     t2 = Attribute(&#x27;t2&#x27;)\n\nAnd its implementation::\n\n  &gt;&gt;&gt; import functools\n  &gt;&gt;&gt; from zope.container.contained import Contained\n  &gt;&gt;&gt; @functools.total_ordering\n  ... @implementer(IContent)\n  ... class Content(Contained):\n  ...     def __init__(self, id, f1=&#x27;&#x27;, f2=&#x27;&#x27;, f3=&#x27;&#x27;, f4=&#x27;&#x27;, t1=&#x27;&#x27;, t2=&#x27;&#x27;):\n  ...         self.id = id\n  ...         self.f1 = f1\n  ...         self.f2 = f2\n  ...         self.f3 = f3\n  ...         self.f4 = f4\n  ...         self.t1 = t1\n  ...         self.t2 = t2\n  ...     def __lt__(self, other):\n  ...         return self.id &lt; other.id\n  ...     def __eq__(self, other):\n  ...         return self.id == other.id\n  ...     def __repr__(self):\n  ...         return &#x27;&lt;Content &quot;{}&quot;&gt;&#x27;.format(self.id)\n\nThe id attribute is just so we can identify objects we find again\neasily. By including the __cmp__ method we make sure search results\ncan be stably sorted.\n\nWe use a fake int id utility here so we can test independent of\nthe full-blown zope environment::\n\n  &gt;&gt;&gt; from zope import interface\n  &gt;&gt;&gt; import zope.intid.interfaces\n  &gt;&gt;&gt; @interface.implementer(zope.intid.interfaces.IIntIds)\n  ... class DummyIntId(object):\n  ...     MARKER = &#x27;__dummy_int_id__&#x27;\n  ...     def __init__(self):\n  ...         self.counter = 0\n  ...         self.data = {}\n  ...     def register(self, obj):\n  ...         intid = getattr(obj, self.MARKER, None)\n  ...         if intid is None:\n  ...             setattr(obj, self.MARKER, self.counter)\n  ...             self.data[self.counter] = obj\n  ...             intid = self.counter\n  ...             self.counter += 1\n  ...         return intid\n  ...     def getId(self, obj):\n  ...         return getattr(obj, self.MARKER)\n  ...     def getObject(self, intid):\n  ...         return self.data[intid]\n  ...     def __iter__(self):\n  ...         return iter(self.data)\n  &gt;&gt;&gt; intid = DummyIntId()\n  &gt;&gt;&gt; from zope.component import provideUtility\n  &gt;&gt;&gt; provideUtility(intid, zope.intid.interfaces.IIntIds)\n\nNow let&#x27;s register a catalog::\n\n  &gt;&gt;&gt; from zope.catalog.interfaces import ICatalog\n  &gt;&gt;&gt; from zope.catalog.catalog import Catalog\n  &gt;&gt;&gt; catalog = Catalog()\n  &gt;&gt;&gt; provideUtility(catalog, ICatalog, &#x27;catalog1&#x27;)\n\nAnd set it up with various indexes::\n\n  &gt;&gt;&gt; from zope.catalog.field import FieldIndex\n  &gt;&gt;&gt; from zope.catalog.text import TextIndex\n  &gt;&gt;&gt; catalog[&#x27;f1&#x27;] = FieldIndex(&#x27;f1&#x27;, IContent)\n  &gt;&gt;&gt; catalog[&#x27;f2&#x27;] = FieldIndex(&#x27;f2&#x27;, IContent)\n  &gt;&gt;&gt; catalog[&#x27;f3&#x27;] = FieldIndex(&#x27;f3&#x27;, IContent)\n  &gt;&gt;&gt; catalog[&#x27;f4&#x27;] = FieldIndex(&#x27;f4&#x27;, IContent)\n  &gt;&gt;&gt; catalog[&#x27;t1&#x27;] = TextIndex(&#x27;t1&#x27;, IContent)\n  &gt;&gt;&gt; catalog[&#x27;t2&#x27;] = TextIndex(&#x27;t2&#x27;, IContent)\n\nNow let&#x27;s create some objects so that they&#x27;ll be cataloged::\n\n  &gt;&gt;&gt; content = [\n  ... Content(1, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;),\n  ... Content(2, &#x27;a&#x27;, &#x27;c&#x27;),\n  ... Content(3, &#x27;X&#x27;, &#x27;c&#x27;),\n  ... Content(4, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;),\n  ... Content(5, &#x27;X&#x27;, &#x27;b&#x27;, &#x27;e&#x27;),\n  ... Content(6, &#x27;Y&#x27;, &#x27;Z&#x27;)]\n\nAnd catalog them now::\n\n  &gt;&gt;&gt; for entry in content:\n  ...     catalog.index_doc(intid.register(entry), entry)\n\nNow let&#x27;s register a query utility::\n\n  &gt;&gt;&gt; from hurry.query.query import Query\n  &gt;&gt;&gt; from hurry.query.interfaces import IQuery\n  &gt;&gt;&gt; provideUtility(Query(), IQuery)\n\nSet up some code to make querying and display the result\neasy::\n\n  &gt;&gt;&gt; from zope.component import getUtility\n  &gt;&gt;&gt; from hurry.query.interfaces import IQuery\n  &gt;&gt;&gt; def displayQuery(q, context=None):\n  ...     query = getUtility(IQuery)\n  ...     r = query.searchResults(q, context)\n  ...     return [e.id for e in sorted(list(r))]\n\nFieldIndex Queries\n------------------\n\nWe can query for all objects indexed in this index::\n\n  &gt;&gt;&gt; from hurry.query import All\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayQuery(All(f1))\n  [1, 2, 3, 4, 5, 6]\n\nNow for a query where f1 equals a::\n\n  &gt;&gt;&gt; from hurry.query import Eq\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;))\n  [1, 2, 4]\n\nNot equals (this is more efficient than the generic ~ operator)::\n\n  &gt;&gt;&gt; from hurry.query import NotEq\n  &gt;&gt;&gt; displayQuery(NotEq(f1, &#x27;a&#x27;))\n  [3, 5, 6]\n\nTesting whether a field is in a set::\n\n  &gt;&gt;&gt; from hurry.query import In\n  &gt;&gt;&gt; displayQuery(In(f1, [&#x27;a&#x27;, &#x27;X&#x27;]))\n  [1, 2, 3, 4, 5]\n\nWhether documents are in a specified range::\n\n  &gt;&gt;&gt; from hurry.query import Between\n  &gt;&gt;&gt; displayQuery(Between(f1, &#x27;X&#x27;, &#x27;Y&#x27;))\n  [3, 5, 6]\n\nYou can leave out one end of the range::\n\n  &gt;&gt;&gt; displayQuery(Between(f1, &#x27;X&#x27;, None)) # &#x27;X&#x27; &lt; &#x27;a&#x27;\n  [1, 2, 3, 4, 5, 6]\n  &gt;&gt;&gt; displayQuery(Between(f1, None, &#x27;X&#x27;))\n  [3, 5]\n\nYou can also use greater-equals and lesser-equals for the same purpose::\n\n  &gt;&gt;&gt; from hurry.query import Ge, Le\n  &gt;&gt;&gt; displayQuery(Ge(f1, &#x27;X&#x27;))\n  [1, 2, 3, 4, 5, 6]\n  &gt;&gt;&gt; displayQuery(Le(f1, &#x27;X&#x27;))\n  [3, 5]\n\nIt&#x27;s also possible to use not with the ~ operator::\n\n  &gt;&gt;&gt; displayQuery(~Eq(f1, &#x27;a&#x27;))\n  [3, 5, 6]\n\nUsing and (&amp;)::\n\n  &gt;&gt;&gt; f2 = (&#x27;catalog1&#x27;, &#x27;f2&#x27;)\n  &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;) &amp; Eq(f2, &#x27;b&#x27;))\n  [1, 4]\n\nUsing or (|)::\n\n  &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;) | Eq(f2, &#x27;b&#x27;))\n  [1, 2, 4, 5]\n\nThese can be chained::\n\n  &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;) &amp; Eq(f2, &#x27;b&#x27;) &amp; Between(f1, &#x27;a&#x27;, &#x27;b&#x27;))\n  [1, 4]\n  &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;a&#x27;) | Eq(f1, &#x27;X&#x27;) | Eq(f2, &#x27;b&#x27;))\n  [1, 2, 3, 4, 5]\n\nAnd nested::\n\n  &gt;&gt;&gt; displayQuery((Eq(f1, &#x27;a&#x27;) | Eq(f1, &#x27;X&#x27;)) &amp; (Eq(f2, &#x27;b&#x27;) | Eq(f2, &#x27;c&#x27;)))\n  [1, 2, 3, 4, 5]\n\n&quot;and&quot; and &quot;or&quot; can also be spelled differently::\n\n  &gt;&gt;&gt; from hurry.query import And, Or\n  &gt;&gt;&gt; displayQuery(And(Eq(f1, &#x27;a&#x27;), Eq(f2, &#x27;b&#x27;)))\n  [1, 4]\n  &gt;&gt;&gt; displayQuery(Or(Eq(f1, &#x27;a&#x27;), Eq(f2, &#x27;b&#x27;)))\n  [1, 2, 4, 5]\n\nCombination of In and &amp;\n-----------------------\n\nA combination of &#x27;In&#x27; and &#x27;&amp;&#x27;::\n\n  &gt;&gt;&gt; displayQuery(In(f1, [&#x27;a&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;]))\n  [1, 2, 3, 4, 5, 6]\n  &gt;&gt;&gt; displayQuery(In(f1, [&#x27;Z&#x27;]))\n  []\n  &gt;&gt;&gt; displayQuery(In(f1, [&#x27;a&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;]) &amp; In(f1, [&#x27;Z&#x27;]))\n  []\n\n\nSetIndex queries\n----------------\n\nThe SetIndex is defined in zc.catalog.\n\n  &gt;&gt;&gt; from hurry.query import set\n\nLet&#x27;s make a catalog which uses it::\n\n  &gt;&gt;&gt; intid = DummyIntId()\n  &gt;&gt;&gt; provideUtility(intid, zope.intid.interfaces.IIntIds)\n  &gt;&gt;&gt; from zope.catalog.interfaces import ICatalog\n  &gt;&gt;&gt; from zope.catalog.catalog import Catalog\n  &gt;&gt;&gt; catalog = Catalog()\n  &gt;&gt;&gt; provideUtility(catalog, ICatalog, &#x27;catalog1&#x27;)\n  &gt;&gt;&gt; from zc.catalog.catalogindex import SetIndex\n  &gt;&gt;&gt; catalog[&#x27;f1&#x27;] = SetIndex(&#x27;f1&#x27;, IContent)\n  &gt;&gt;&gt; catalog[&#x27;f2&#x27;] = FieldIndex(&#x27;f2&#x27;, IContent)\n\nFirst let&#x27;s set up some new data::\n\n  &gt;&gt;&gt; content = [\n  ... Content(1, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], 1),\n  ... Content(2, [&#x27;a&#x27;], 1),\n  ... Content(3, [&#x27;b&#x27;], 1),\n  ... Content(4, [&#x27;c&#x27;, &#x27;d&#x27;], 2),\n  ... Content(5, [&#x27;b&#x27;, &#x27;c&#x27;], 2),\n  ... Content(6, [&#x27;a&#x27;, &#x27;c&#x27;], 2),\n  ... Content(7, [&#x27;z&#x27;], 2),\n  ... Content(8, [], 2)]  # no value, so not indexed.\n\nAnd catalog them now::\n\n  &gt;&gt;&gt; for entry in content:\n  ...     catalog.index_doc(intid.register(entry), entry)\n\nWe can query for all indexes objects:\n\n  &gt;&gt;&gt; displayQuery(set.All(f1))\n  [1, 2, 3, 4, 5, 6, 7]\n\nNow do a a &#x27;any of&#x27; query, which returns all documents that\ncontain any of the values listed::\n\n  &gt;&gt;&gt; displayQuery(set.AnyOf(f1, [&#x27;a&#x27;, &#x27;c&#x27;]))\n  [1, 2, 4, 5, 6]\n  &gt;&gt;&gt; displayQuery(set.AnyOf(f1, [&#x27;c&#x27;, &#x27;b&#x27;]))\n  [1, 3, 4, 5, 6]\n  &gt;&gt;&gt; displayQuery(set.AnyOf(f1, [&#x27;a&#x27;]))\n  [1, 2, 6]\n\nDo a &#x27;all of&#x27; query, which returns all documents that\ncontain all of the values listed::\n\n  &gt;&gt;&gt; displayQuery(set.AllOf(f1, [&#x27;a&#x27;]))\n  [1, 2, 6]\n  &gt;&gt;&gt; displayQuery(set.AllOf(f1, [&#x27;a&#x27;, &#x27;b&#x27;]))\n  [1]\n  &gt;&gt;&gt; displayQuery(set.AllOf(f1, [&#x27;a&#x27;, &#x27;c&#x27;]))\n  [1, 6]\n\nThe next interesting set of queries allows you to make evaluations of the\nvalues. For example, you can ask for all objects between a certain set of\nvalues:\n\n  &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;a&#x27;, &#x27;c&#x27;))\n  [1, 2, 3, 4, 5, 6]\n\n  &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;a&#x27;, &#x27;c&#x27;, exclude_min=True))\n  [1, 3, 4, 5, 6]\n\n  &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;b&#x27;, &#x27;c&#x27;, exclude_max=True))\n  [1, 3, 5]\n\n  &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;a&#x27;, &#x27;c&#x27;,\n  ...                             exclude_min=True, exclude_max=True))\n  [1, 3, 5]\n\nYou can also leave out one end of the range:\n\n  &gt;&gt;&gt; displayQuery(set.SetBetween(f1, &#x27;c&#x27;, None))\n  [1, 4, 5, 6, 7]\n  &gt;&gt;&gt; displayQuery(set.SetBetween(f1, None, &#x27;c&#x27;, exclude_max=True))\n  [1, 2, 3, 5, 6]\n\nYou can chain set queries:\n\n  &gt;&gt;&gt; displayQuery(set.AnyOf(f1, [&#x27;a&#x27;]) &amp; Eq(f2, 1))\n  [1, 2]\n\nThe ``set` module also supports ``zc.catalog`` extents. The first query is\n``ExtentAny``, which returns all douments matching the extent. If the the\nextent is ``None``, all document ids are returned:\n\n  &gt;&gt;&gt; displayQuery(set.ExtentAny(f1, None))\n  [1, 2, 3, 4, 5, 6, 7]\n\nIf we now create an extent that is only in the scope of the first four\ndocuments,\n\n  &gt;&gt;&gt; from zc.catalog.extentcatalog import FilterExtent\n  &gt;&gt;&gt; extent = FilterExtent(lambda extent, uid, obj: True)\n  &gt;&gt;&gt; for i in range(4):\n  ...     extent.add(i, i)\n\nthen only the first four are returned:\n\n  &gt;&gt;&gt; displayQuery(set.ExtentAny(f1, extent))\n  [1, 2, 3, 4]\n\nThe opposite query is the ``ExtentNone`` query, which returns all ids in the\nextent that are *not* in the index:\n\n  &gt;&gt;&gt; id = intid.register(Content(9, &#x27;b&#x27;))\n  &gt;&gt;&gt; id = intid.register(Content(10, &#x27;c&#x27;))\n  &gt;&gt;&gt; id = intid.register(Content(11, &#x27;a&#x27;))\n\n  &gt;&gt;&gt; extent = FilterExtent(lambda extent, uid, obj: True)\n  &gt;&gt;&gt; for i in range(11):\n  ...     extent.add(i, i)\n\n  &gt;&gt;&gt; displayQuery(set.ExtentNone(f1, extent))\n  [8, 9, 10, 11]\n\n\nValueIndex queries\n------------------\n\nThe ``ValueIndex`` is defined in ``zc.catalog`` and provides a generalization\nof the standard field index.\n\n  &gt;&gt;&gt; from hurry.query import value\n\nLet&#x27;s set up a catalog that uses this index. The ``ValueIndex`` is defined in\n``zc.catalog``. Let&#x27;s make a catalog which uses it:\n\n  &gt;&gt;&gt; intid = DummyIntId()\n  &gt;&gt;&gt; provideUtility(intid, zope.intid.interfaces.IIntIds)\n\n  &gt;&gt;&gt; from zope.catalog.interfaces import ICatalog\n  &gt;&gt;&gt; from zope.catalog.catalog import Catalog\n  &gt;&gt;&gt; catalog = Catalog()\n  &gt;&gt;&gt; provideUtility(catalog, ICatalog, &#x27;catalog1&#x27;)\n\n  &gt;&gt;&gt; from zc.catalog.catalogindex import ValueIndex\n  &gt;&gt;&gt; catalog[&#x27;f1&#x27;] = ValueIndex(&#x27;f1&#x27;, IContent)\n\nNext we set up some content data to fill the indices:\n\n  &gt;&gt;&gt; content = [\n  ... Content(1, &#x27;a&#x27;),\n  ... Content(2, &#x27;b&#x27;),\n  ... Content(3, &#x27;c&#x27;),\n  ... Content(4, &#x27;d&#x27;),\n  ... Content(5, &#x27;c&#x27;),\n  ... Content(6, &#x27;a&#x27;)]\n\nAnd catalog them now:\n\n  &gt;&gt;&gt; for entry in content:\n  ...     catalog.index_doc(intid.register(entry), entry)\n\nWe query for all indexes objects::\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayQuery(value.All(f1))\n  [1, 2, 3, 4, 5, 6]\n\nLet&#x27;s now query for all objects where ``f1`` equals &#x27;a&#x27;:\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayQuery(value.Eq(f1, &#x27;a&#x27;))\n  [1, 6]\n\nNext, let&#x27;s find all objects where ``f1`` does not equal &#x27;a&#x27;; this is more\nefficient than the generic ``~`` operator:\n\n  &gt;&gt;&gt; displayQuery(value.NotEq(f1, &#x27;a&#x27;))\n  [2, 3, 4, 5]\n\nIf all the items in the catalog satisfy the NotEq condition, the query\ndoes not crash.\n\n  &gt;&gt;&gt; displayQuery(value.NotEq(f1, &#x27;z&#x27;))\n  [1, 2, 3, 4, 5, 6]\n\nYou can also query for all objects where the value of ``f1`` is in a set of\nvalues:\n\n  &gt;&gt;&gt; displayQuery(value.In(f1, [&#x27;a&#x27;, &#x27;d&#x27;]))\n  [1, 4, 6]\n\nThe next interesting set of queries allows you to make evaluations of the\nvalues. For example, you can ask for all objects between a certain set of\nvalues:\n\n  &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;a&#x27;, &#x27;c&#x27;))\n  [1, 2, 3, 5, 6]\n\n  &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;a&#x27;, &#x27;c&#x27;, exclude_min=True))\n  [2, 3, 5]\n\n  &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;a&#x27;, &#x27;c&#x27;, exclude_max=True))\n  [1, 2, 6]\n\n  &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;a&#x27;, &#x27;c&#x27;,\n  ...                            exclude_min=True, exclude_max=True))\n  [2]\n\nYou can also leave out one end of the range:\n\n  &gt;&gt;&gt; displayQuery(value.Between(f1, &#x27;c&#x27;, None))\n  [3, 4, 5]\n  &gt;&gt;&gt; displayQuery(value.Between(f1, None, &#x27;c&#x27;))\n  [1, 2, 3, 5, 6]\n\nYou can also use greater-equals and lesser-equals for the same purpose:\n\n  &gt;&gt;&gt; displayQuery(value.Ge(f1, &#x27;c&#x27;))\n  [3, 4, 5]\n  &gt;&gt;&gt; displayQuery(value.Le(f1, &#x27;c&#x27;))\n  [1, 2, 3, 5, 6]\n\nYou can chain value queries:\n\n  &gt;&gt;&gt; displayQuery(value.Ge(f1, &#x27;c&#x27;) &amp; value.Le(f1, &#x27;c&#x27;))\n  [3, 5]\n\nThe ``value`` module also supports ``zc.catalog`` extents. The first query is\n``ExtentAny``, which returns all douments matching the extent. If the the\nextent is ``None``, all document ids are returned:\n\n  &gt;&gt;&gt; displayQuery(value.ExtentAny(f1, None))\n  [1, 2, 3, 4, 5, 6]\n\nIf we now create an extent that is only in the scope of the first four\ndocuments,\n\n  &gt;&gt;&gt; from zc.catalog.extentcatalog import FilterExtent\n  &gt;&gt;&gt; extent = FilterExtent(lambda extent, uid, obj: True)\n  &gt;&gt;&gt; for i in range(4):\n  ...     extent.add(i, i)\n\nthen only the first four are returned:\n\n  &gt;&gt;&gt; displayQuery(value.ExtentAny(f1, extent))\n  [1, 2, 3, 4]\n\nThe opposite query is the ``ExtentNone`` query, which returns all ids in the\nextent that are *not* in the index:\n\n  &gt;&gt;&gt; id = intid.register(Content(7, &#x27;b&#x27;))\n  &gt;&gt;&gt; id = intid.register(Content(8, &#x27;c&#x27;))\n  &gt;&gt;&gt; id = intid.register(Content(9, &#x27;a&#x27;))\n\n  &gt;&gt;&gt; extent = FilterExtent(lambda extent, uid, obj: True)\n  &gt;&gt;&gt; for i in range(9):\n  ...     extent.add(i, i)\n\n  &gt;&gt;&gt; displayQuery(value.ExtentNone(f1, extent))\n  [7, 8, 9]\n\n\nQuerying different indexes\n--------------------------\n\nIt&#x27;s possible to specify the context when creating a query. This context\ndetermines which index will be searched.\n\nFirst setup a second registry and second catalog and populate it.\n\n  &gt;&gt;&gt; catalog2 = Catalog()\n  &gt;&gt;&gt; from zope.component.registry import Components\n  &gt;&gt;&gt; import zope.component.interfaces\n  &gt;&gt;&gt; import zope.interface\n  &gt;&gt;&gt; intid1 = DummyIntId()\n  &gt;&gt;&gt; @zope.interface.implementer(zope.component.interfaces.IComponentLookup)\n  ... class MockSite(object):\n  ...     def __init__(self):\n  ...         self.registry = Components(&#x27;components&#x27;)\n  ...     def queryUtility(self, interface, name=&#x27;&#x27;, default=None):\n  ...         if name == &#x27;&#x27;: return intid1\n  ...         else: return catalog2\n  ...     def getSiteManager(self):\n  ...         return self.registry\n  &gt;&gt;&gt; from zope.component.hooks import setSite\n  &gt;&gt;&gt; site1 = MockSite()\n  &gt;&gt;&gt; setSite(site1)\n  &gt;&gt;&gt; catalog2[&#x27;f1&#x27;] = FieldIndex(&#x27;f1&#x27;, IContent)\n  &gt;&gt;&gt; content = [\n  ... Content(1,&#x27;A&#x27;),\n  ... Content(2,&#x27;B&#x27;),]\n  &gt;&gt;&gt; for entry in content:\n  ...     catalog2.index_doc(intid1.register(entry), entry)\n\nNow we can query this catalog by specifying the context:\n\n  &gt;&gt;&gt; query = getUtility(IQuery)\n  &gt;&gt;&gt; displayQuery(Eq(f1, &#x27;A&#x27;), context=site1)\n  [1]\n\n  &gt;&gt;&gt; displayQuery(In(f1, [&#x27;A&#x27;, &#x27;B&#x27;]), context=site1)\n  [1, 2]\n\nSorting and limiting the results\n--------------------------------\n\nIt&#x27;s possible to have the resultset sorted on one of the fields in the query.\n\n  &gt;&gt;&gt; catalog = Catalog()\n  &gt;&gt;&gt; provideUtility(catalog, ICatalog, &#x27;catalog1&#x27;)\n  &gt;&gt;&gt; catalog[&#x27;f1&#x27;] = FieldIndex(&#x27;f1&#x27;, IContent)\n  &gt;&gt;&gt; catalog[&#x27;f2&#x27;] = FieldIndex(&#x27;f2&#x27;, IContent)\n  &gt;&gt;&gt; catalog[&#x27;t&#x27;] = TextIndex(&#x27;t1&#x27;, IContent)\n\nFirst let&#x27;s set up some new data::\n\n  &gt;&gt;&gt; content = [\n  ... Content(1, &#x27;a&#x27;, 2, t1=&#x27;Beautiful is better than ugly.&#x27;),\n  ... Content(2, &#x27;a&#x27;, 3, t1=&#x27;Explicit is better than implicit&#x27;),\n  ... Content(3, &#x27;b&#x27;, 9, t1=&#x27;Simple is better than complex&#x27;),\n  ... Content(4, &#x27;c&#x27;, 8, t1=&#x27;Complex is better than complicated&#x27;),\n  ... Content(5, &#x27;c&#x27;, 7, t1=&#x27;Readability counts&#x27;),\n  ... Content(6, &#x27;a&#x27;, 1, t1=&#x27;Although practicality beats purity&#x27;)]\n\nAnd catalog them now::\n\n  &gt;&gt;&gt; for entry in content:\n  ...     catalog.index_doc(intid.register(entry), entry)\n\nDefine a convenience function for quickly displaying a result set without\nperforming any sorting here ourselves.\n\n  &gt;&gt;&gt; def displayResult(q, context=None, **kw):\n  ...     query = getUtility(IQuery)\n  ...     r = query.searchResults(q, context, **kw)\n  ...     return [e for e in r]\n\nWithout using sorting in the query itself, the resultset has an undefined\norder. We &quot;manually&quot; sort the results here to have something testable.\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; [r for r in sorted(displayResult(Eq(f1, &#x27;a&#x27;)))]\n  [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;6&quot;&gt;]\n\nNow we sort on the f2 index.\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;))\n  [&lt;Content &quot;6&quot;&gt;, &lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;]\n\nReverse the order.\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;), reverse=True)\n  [&lt;Content &quot;2&quot;&gt;, &lt;Content &quot;1&quot;&gt;, &lt;Content &quot;6&quot;&gt;]\n\nWe can limit the amount of found items.\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;), limit=2)\n  [&lt;Content &quot;6&quot;&gt;, &lt;Content &quot;1&quot;&gt;]\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;), limit=2, start=1)\n  [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;]\n\nWe can limit the reversed resultset too.\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(\n  ...   Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;f2&#x27;), limit=2, reverse=True)\n  [&lt;Content &quot;2&quot;&gt;, &lt;Content &quot;1&quot;&gt;]\n\nYou can directly pass the index as a sort field instead of a tuple:\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=catalog[&#x27;f2&#x27;])\n  [&lt;Content &quot;6&quot;&gt;, &lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;]\n\nWhenever a field is used for sorting that does not support is, an error is\nraised.\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), sort_field=(&#x27;catalog1&#x27;, &#x27;t&#x27;))\n  Traceback (most recent call last):\n  ...\n  ValueError: Index t in catalog catalog1 does not support sorting.\n\nThe resultset can still be reversed and limited even if there&#x27;s no sort_field\ngiven (Note that the actual order of the result set when not using explicit\nsorting is not defined. In this test it is assumed that the natural order of\nthe tested index is deterministic enough to be used as a proper test).\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), limit=2)\n  [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;]\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), start=1)\n  [&lt;Content &quot;2&quot;&gt;, &lt;Content &quot;6&quot;&gt;]\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), start=1, limit=1)\n  [&lt;Content &quot;2&quot;&gt;]\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), limit=2, reverse=True)\n  [&lt;Content &quot;6&quot;&gt;, &lt;Content &quot;2&quot;&gt;]\n\nResult counters\n---------------\n\nResult objects provide metadata about the result.\n\nDefine a convenience function for obtaining a result.\n\n  &gt;&gt;&gt; def getResult(q, context=None, **kw):\n  ...     query = getUtility(IQuery)\n  ...     return query.searchResults(q, context, **kw)\n\nPerforming a query with a sort_field gives a well-defined result:\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; result = getResult(Eq(f1, &#x27;a&#x27;), sort_field=catalog[&#x27;f1&#x27;])\n  &gt;&gt;&gt; [e for e in result]\n  [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;6&quot;&gt;]\n\nWe can access &#x27;total&#x27; and &#x27;count&#x27; properties, and &#x27;first()&#x27; on the result:\n\n  &gt;&gt;&gt; result.total\n  3\n  &gt;&gt;&gt; result.count\n  3\n  &gt;&gt;&gt; result.first()\n  &lt;Content &quot;1&quot;&gt;\n\nChanging &#x27;start&#x27; is reflected in the returned data:\n\n&gt;&gt;&gt; result = getResult(Eq(f1, &#x27;a&#x27;), sort_field=catalog[&#x27;f1&#x27;], start=1)\n  &gt;&gt;&gt; [e for e in result]\n  [&lt;Content &quot;2&quot;&gt;, &lt;Content &quot;6&quot;&gt;]\n\nIt also changes &#x27;count&#x27; and &#x27;first()&#x27;:\n\n  &gt;&gt;&gt; result.count\n  2\n  &gt;&gt;&gt; result.first()\n  &lt;Content &quot;2&quot;&gt;\n\nBut &#x27;total&#x27; still reflects all matches, including the hidden first one:\n\n  &gt;&gt;&gt; result.total\n  3\n\nAdding a limit:\n\n  &gt;&gt;&gt; result = getResult(Eq(f1, &#x27;a&#x27;), sort_field=catalog[&#x27;f1&#x27;], start=1,\n  ...                    limit=1)\n  &gt;&gt;&gt; [e for e in result]\n  [&lt;Content &quot;2&quot;&gt;]\n  &gt;&gt;&gt; result.total\n  3\n  &gt;&gt;&gt; result.count\n  1\n  &gt;&gt;&gt; result.first()\n  &lt;Content &quot;2&quot;&gt;\n\nThe same accessors are available on an empty result:\n\n  &gt;&gt;&gt; result = getResult(Eq(f1, &#x27;foo&#x27;), sort_field=catalog[&#x27;f1&#x27;])\n  &gt;&gt;&gt; [e for e in result]\n  []\n  &gt;&gt;&gt; result.total\n  0\n  &gt;&gt;&gt; result.count\n  0\n  &gt;&gt;&gt; result.first() is None\n  True\n\nWrapper\n-------\n\nYou can define a wrapper to be called on each result:\n\n  &gt;&gt;&gt; from zope.location import Location\n  &gt;&gt;&gt; class Wrapper(Location):\n  ...    def __init__(self, parent):\n  ...       self.parent = parent\n  ...    def __repr__(self):\n  ...       return &#x27;&lt;Wrapper &quot;{}&quot;&gt;&#x27;.format(self.parent.id)\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayResult(Eq(f1, &#x27;a&#x27;), wrapper=Wrapper)\n  [&lt;Wrapper &quot;1&quot;&gt;, &lt;Wrapper &quot;2&quot;&gt;, &lt;Wrapper &quot;6&quot;&gt;]\n\nLocate to\n---------\n\nYou can define a location where the results should be located with a proxy:\n\n  &gt;&gt;&gt; def displayParent(q, context=None, **kw):\n  ...     query = getUtility(IQuery)\n  ...     r = query.searchResults(q, context, **kw)\n  ...     return [(e.__parent__, e) or None for e in r]\n\n  &gt;&gt;&gt; f1 = (&#x27;catalog1&#x27;, &#x27;f1&#x27;)\n  &gt;&gt;&gt; displayParent(Eq(f1, &#x27;a&#x27;), limit=2)\n  [(None, &lt;Content &quot;1&quot;&gt;), (None, &lt;Content &quot;2&quot;&gt;)]\n\n  &gt;&gt;&gt; parent = Content(&#x27;parent&#x27;)\n  &gt;&gt;&gt; displayParent(Eq(f1, &#x27;a&#x27;), limit=2, locate_to=parent)\n  [(&lt;Content &quot;parent&quot;&gt;, &lt;Content &quot;1&quot;&gt;), (&lt;Content &quot;parent&quot;&gt;, &lt;Content &quot;2&quot;&gt;)]\n\nThis can be used with a wrapper:\n\n  &gt;&gt;&gt; displayParent(Eq(f1, &#x27;a&#x27;), limit=2, wrapper=Wrapper, locate_to=parent)\n  [(&lt;Content &quot;parent&quot;&gt;, &lt;Wrapper &quot;1&quot;&gt;), (&lt;Content &quot;parent&quot;&gt;, &lt;Wrapper &quot;2&quot;&gt;)]\n\nText index\n----------\n\nYou can search on text, here all the items that contains better::\n\n  &gt;&gt;&gt; from hurry.query import Text\n  &gt;&gt;&gt; t1 = (&#x27;catalog1&#x27;, &#x27;t&#x27;)\n  &gt;&gt;&gt; displayResult(Text(t1, &#x27;better&#x27;))\n  [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;3&quot;&gt;, &lt;Content &quot;4&quot;&gt;]\n\nInvalid text query returns an empty results::\n\n  &gt;&gt;&gt; displayResult(Text(t1, &#x27;?*&#x27;))\n  []\n\n\nOther terms\n-----------\n\nYou can do differences, here all the items that contains better but do\nhave a as f1::\n\n  &gt;&gt;&gt; from hurry.query import Difference\n  &gt;&gt;&gt; displayResult(Difference(Text(t1, &#x27;better&#x27;), Eq(f1, &#x27;a&#x27;)))\n  [&lt;Content &quot;3&quot;&gt;, &lt;Content &quot;4&quot;&gt;]\n\n\nThere is a special term that allows to mix objects with catalog\nqueries::\n\n  &gt;&gt;&gt; from hurry.query import Objects\n  &gt;&gt;&gt; displayResult(Objects(content))\n  [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;3&quot;&gt;, &lt;Content &quot;4&quot;&gt;, &lt;Content &quot;5&quot;&gt;, &lt;Content &quot;6&quot;&gt;]\n\nThere is a special term that allows querying objects by intid::\n\n  &gt;&gt;&gt; from hurry.query import Ids\n  &gt;&gt;&gt; displayResult(Ids())\n  []\n\n  &gt;&gt;&gt; all_intids = [intid.getId(x) for x in content]\n  &gt;&gt;&gt; displayResult(Ids(*all_intids))\n  [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;2&quot;&gt;, &lt;Content &quot;3&quot;&gt;, &lt;Content &quot;4&quot;&gt;, &lt;Content &quot;5&quot;&gt;, &lt;Content &quot;6&quot;&gt;]\n\n  &gt;&gt;&gt; odd_intids = [intid.getId(x) for x in content if x.id % 2]\n  &gt;&gt;&gt; displayResult(Ids(*odd_intids))\n  [&lt;Content &quot;1&quot;&gt;, &lt;Content &quot;3&quot;&gt;, &lt;Content &quot;5&quot;&gt;]\n\n\nCHANGES\n=======\n\n3.1 (2018-08-08)\n----------------\n\n- Add ``Ids`` term that include already known intids in a query.\n\n3.0.0 (2018-01-19)\n------------------\n\n- Support for python 3.4, 3.5 and 3.6 in addition to python 2.7\n\n- Cleanup in preparation for python3 support:\n\n  Bugfixes:\n  o API change: fix And(weighted=) keyword argument typo\n  o API change: remove utterly broken ``include_minimum`` and ``include_maximum``\n    arguments to SetBetween(), provide ``exclude_min`` and ``exclude_max`` instead.\n  o API change: fix broken SetBetween.apply(): introduce ``cache`` arg\n  o Fix ExtentNone() super delegation bug\n  o Fix TimingAwareCaching.report() edge condition bug\n\n  Major:\n  o Remove unsupported transaction_cache\n\n  Minor:\n  o Clarify HURRY_QUERY_TIMING environment and searchResults(timing=) type\n  o Fix TimingAwareCaching.report() output typo\n  o Clarify Query.searchResults(caching=) argument type\n  o Remove unreachable code path from And()\n\n  Dev:\n  o Maximize test coverage\n  o Add Travis and Tox testing configurations\n  o Bypass bootstrap.py\n  o Various python3 compatibility preparations\n\n\n2.6 (2018-01-10)\n----------------\n\n- Update dependencies not to rely on ZODB3 anymore.\n\n2.5 (2017-07-17)\n----------------\n\n- `sort_field` can be a index name or an object providing `IIndexSort` itself.\n\n- `searchResults()` accepts optional parameter `locate_to` and `wrapper`. The\n  `locate_to` is used as the `__parent__` for the location proxy put arround\n  the resulting objects. The `wrapper` is a callable callback that should\n  accept one argument for its parameter.\n\n2.4 (2017-06-22)\n----------------\n\n- Don&#x27;t throw a TypeError slicing unsorted results, fixes #6\n\n2.3 (2017-04-26)\n----------------\n\n- Define a &quot;no result&quot; result object, useful for case where application code\n  has an custom API for building query terms, but this application code\n  decides there is no query. Callers might still expect a result-like\n  object.\n\n2.2 (2017-04-26)\n----------------\n\n- The caching option to searchResults now accepts a dict-like value and it\n  will use that to allow for caching results over multiple searchResults()\n  calls. The cache invalidation then is the responsibility of the caller.\n\n2.1 (2017-02-07)\n----------------\n\n- Add the possibility to time how long a query takes. It can be\n  controlled with the new ``timing`` option to ``searchResults`` or\n  the ``HURRY_QUERY_TIMING`` environment variable.\n\n2.0.1 (2016-09-08)\n------------------\n\n- Fix log line in Text term for invalid text search.\n\n2.0 (2016-09-07)\n----------------\n\n- Add new term: Difference. It does a difference between the first and\n  the following terms passed as arguments.\n\n- Add new term: Objects. It creates a result out of the objects passed\n  in arguments. It let you mix real objects with existing catalog\n  queries (with And, Or or Difference for instance).\n\n- Add an option start to searchResult to skip the first results in the\n  results set.\n\n- Extend the result from searchResult. You have addition information\n  on the result, including the total number of results without\n  start/limit restriction. A method called first() return only the\n  first result if available or none.\n\n- Add an option caching to searchResult to cache the result of each\n  terms within a Zope transaction, speeding similar queries. If\n  disabled, terms will still be cached within the same query.\n\n\n1.2 (2015-12-16)\n----------------\n\n* Add support for an All query.\n\n1.1.1 (2012-06-22)\n------------------\n\n* ExtentNone in set.py missed a parameter ``index_id``. Thanks to Danilo\n  Botelho for the bug report.\n\n1.1.0 (2010-07-12)\n------------------\n\n* Allow the searchResults method of a Query to take an additional keyword\n  argument `sort_field` that defines that defines (catalog_name, index_name) to\n  sort on. That index in that catalog should implement IIndexSort.\n\n  In addition to this keyword argument, `limit` and `reverse` keyword arguments\n  can be passed too, that will limit the sorted resultset and/or reverse its\n  order.\n\n* Allow the searchResults method of a Query object to take an additional\n  optional context argument. This context will determine which catalog\n  the search is performed on.\n\n1.0.0 (2009-11-30)\n------------------\n\n* Refresh dependencies. Use zope.catalog and zope.intid instead of\n  zope.app.catalog and zope.app.intid respectively. Don&#x27;t zope.app.zapi.\n\n* Make package description more modern.\n\n* Clean up the code style.\n\n0.9.3 (2008-09-29)\n------------------\n\n* BUG: NotEq query no longer fails when all values in the index\n  satisfy the NotEq condition.\n\n0.9.2 (2006-09-22)\n------------------\n\n* First release on the cheeseshop.\n\n0.9.1 (2006-06-16)\n------------------\n\n* Make zc.catalog a dependency of hurry.query.\n\n0.9 (2006-05-16)\n----------------\n\n* Separate hurry.query from the other hurry packages. Eggification work.\n\n* Support for ValueIndex from zc.catalog.\n\n0.8 (2006-05-01)\n----------------\n\nInitial public release.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/hurry.query", "keywords": "zope zope3 catalog index query", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "hurry.query", "package_url": "https://pypi.org/project/hurry.query/", "platform": "", "project_url": "https://pypi.org/project/hurry.query/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/hurry.query"}, "release_url": "https://pypi.org/project/hurry.query/3.1/", "requires_dist": null, "requires_python": "", "summary": "Higher level query system for the zope.catalog", "version": "3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            Hurry Query<br>===========<br><br>The hurry query system for the zope.catalog builds on its catalog<br>indexes, as well as the indexes in zc.catalog. It is in part inspired<br>by AdvancedQuery for Zope 2 by Dieter Maurer, though has an independent<br>origin.<br><br>.. contents::<br><br>Setup<br>-----<br><br>Let&amp;#x27;s define a simple content object. First its interface::<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.interface import Interface, Attribute, implementer<br>  &amp;gt;&amp;gt;&amp;gt; class IContent(Interface):<br>  ...     f1 = Attribute(&amp;#x27;f1&amp;#x27;)<br>  ...     f2 = Attribute(&amp;#x27;f2&amp;#x27;)<br>  ...     f3 = Attribute(&amp;#x27;f3&amp;#x27;)<br>  ...     f4 = Attribute(&amp;#x27;f4&amp;#x27;)<br>  ...     t1 = Attribute(&amp;#x27;t1&amp;#x27;)<br>  ...     t2 = Attribute(&amp;#x27;t2&amp;#x27;)<br><br>And its implementation::<br><br>  &amp;gt;&amp;gt;&amp;gt; import functools<br>  &amp;gt;&amp;gt;&amp;gt; from zope.container.contained import Contained<br>  &amp;gt;&amp;gt;&amp;gt; @functools.total_ordering<br>  ... @implementer(IContent)<br>  ... class Content(Contained):<br>  ...     def __init__(self, id, f1=&amp;#x27;&amp;#x27;, f2=&amp;#x27;&amp;#x27;, f3=&amp;#x27;&amp;#x27;, f4=&amp;#x27;&amp;#x27;, t1=&amp;#x27;&amp;#x27;, t2=&amp;#x27;&amp;#x27;):<br>  ...         self.id = id<br>  ...         self.f1 = f1<br>  ...         self.f2 = f2<br>  ...         self.f3 = f3<br>  ...         self.f4 = f4<br>  ...         self.t1 = t1<br>  ...         self.t2 = t2<br>  ...     def __lt__(self, other):<br>  ...         return self.id &amp;lt; other.id<br>  ...     def __eq__(self, other):<br>  ...         return self.id == other.id<br>  ...     def __repr__(self):<br>  ...         return &amp;#x27;&amp;lt;Content &amp;quot;{}&amp;quot;&amp;gt;&amp;#x27;.format(self.id)<br><br>The id attribute is just so we can identify objects we find again<br>easily. By including the __cmp__ method we make sure search results<br>can be stably sorted.<br><br>We use a fake int id utility here so we can test independent of<br>the full-blown zope environment::<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope import interface<br>  &amp;gt;&amp;gt;&amp;gt; import zope.intid.interfaces<br>  &amp;gt;&amp;gt;&amp;gt; @interface.implementer(zope.intid.interfaces.IIntIds)<br>  ... class DummyIntId(object):<br>  ...     MARKER = &amp;#x27;__dummy_int_id__&amp;#x27;<br>  ...     def __init__(self):<br>  ...         self.counter = 0<br>  ...         self.data = {}<br>  ...     def register(self, obj):<br>  ...         intid = getattr(obj, self.MARKER, None)<br>  ...         if intid is None:<br>  ...             setattr(obj, self.MARKER, self.counter)<br>  ...             self.data[self.counter] = obj<br>  ...             intid = self.counter<br>  ...             self.counter += 1<br>  ...         return intid<br>  ...     def getId(self, obj):<br>  ...         return getattr(obj, self.MARKER)<br>  ...     def getObject(self, intid):<br>  ...         return self.data[intid]<br>  ...     def __iter__(self):<br>  ...         return iter(self.data)<br>  &amp;gt;&amp;gt;&amp;gt; intid = DummyIntId()<br>  &amp;gt;&amp;gt;&amp;gt; from zope.component import provideUtility<br>  &amp;gt;&amp;gt;&amp;gt; provideUtility(intid, zope.intid.interfaces.IIntIds)<br><br>Now let&amp;#x27;s register a catalog::<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.catalog.interfaces import ICatalog<br>  &amp;gt;&amp;gt;&amp;gt; from zope.catalog.catalog import Catalog<br>  &amp;gt;&amp;gt;&amp;gt; catalog = Catalog()<br>  &amp;gt;&amp;gt;&amp;gt; provideUtility(catalog, ICatalog, &amp;#x27;catalog1&amp;#x27;)<br><br>And set it up with various indexes::<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.catalog.field import FieldIndex<br>  &amp;gt;&amp;gt;&amp;gt; from zope.catalog.text import TextIndex<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f1&amp;#x27;] = FieldIndex(&amp;#x27;f1&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f2&amp;#x27;] = FieldIndex(&amp;#x27;f2&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f3&amp;#x27;] = FieldIndex(&amp;#x27;f3&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f4&amp;#x27;] = FieldIndex(&amp;#x27;f4&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;t1&amp;#x27;] = TextIndex(&amp;#x27;t1&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;t2&amp;#x27;] = TextIndex(&amp;#x27;t2&amp;#x27;, IContent)<br><br>Now let&amp;#x27;s create some objects so that they&amp;#x27;ll be cataloged::<br><br>  &amp;gt;&amp;gt;&amp;gt; content = [<br>  ... Content(1, &amp;#x27;a&amp;#x27;, &amp;#x27;b&amp;#x27;, &amp;#x27;d&amp;#x27;),<br>  ... Content(2, &amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;),<br>  ... Content(3, &amp;#x27;X&amp;#x27;, &amp;#x27;c&amp;#x27;),<br>  ... Content(4, &amp;#x27;a&amp;#x27;, &amp;#x27;b&amp;#x27;, &amp;#x27;e&amp;#x27;),<br>  ... Content(5, &amp;#x27;X&amp;#x27;, &amp;#x27;b&amp;#x27;, &amp;#x27;e&amp;#x27;),<br>  ... Content(6, &amp;#x27;Y&amp;#x27;, &amp;#x27;Z&amp;#x27;)]<br><br>And catalog them now::<br><br>  &amp;gt;&amp;gt;&amp;gt; for entry in content:<br>  ...     catalog.index_doc(intid.register(entry), entry)<br><br>Now let&amp;#x27;s register a query utility::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query.query import Query<br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query.interfaces import IQuery<br>  &amp;gt;&amp;gt;&amp;gt; provideUtility(Query(), IQuery)<br><br>Set up some code to make querying and display the result<br>easy::<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.component import getUtility<br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query.interfaces import IQuery<br>  &amp;gt;&amp;gt;&amp;gt; def displayQuery(q, context=None):<br>  ...     query = getUtility(IQuery)<br>  ...     r = query.searchResults(q, context)<br>  ...     return [e.id for e in sorted(list(r))]<br><br>FieldIndex Queries<br>------------------<br><br>We can query for all objects indexed in this index::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import All<br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(All(f1))<br>  [1, 2, 3, 4, 5, 6]<br><br>Now for a query where f1 equals a::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import Eq<br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Eq(f1, &amp;#x27;a&amp;#x27;))<br>  [1, 2, 4]<br><br>Not equals (this is more efficient than the generic ~ operator)::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import NotEq<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(NotEq(f1, &amp;#x27;a&amp;#x27;))<br>  [3, 5, 6]<br><br>Testing whether a field is in a set::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import In<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(In(f1, [&amp;#x27;a&amp;#x27;, &amp;#x27;X&amp;#x27;]))<br>  [1, 2, 3, 4, 5]<br><br>Whether documents are in a specified range::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import Between<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Between(f1, &amp;#x27;X&amp;#x27;, &amp;#x27;Y&amp;#x27;))<br>  [3, 5, 6]<br><br>You can leave out one end of the range::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Between(f1, &amp;#x27;X&amp;#x27;, None)) # &amp;#x27;X&amp;#x27; &amp;lt; &amp;#x27;a&amp;#x27;<br>  [1, 2, 3, 4, 5, 6]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Between(f1, None, &amp;#x27;X&amp;#x27;))<br>  [3, 5]<br><br>You can also use greater-equals and lesser-equals for the same purpose::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import Ge, Le<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Ge(f1, &amp;#x27;X&amp;#x27;))<br>  [1, 2, 3, 4, 5, 6]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Le(f1, &amp;#x27;X&amp;#x27;))<br>  [3, 5]<br><br>It&amp;#x27;s also possible to use not with the ~ operator::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(~Eq(f1, &amp;#x27;a&amp;#x27;))<br>  [3, 5, 6]<br><br>Using and (&amp;amp;)::<br><br>  &amp;gt;&amp;gt;&amp;gt; f2 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f2&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Eq(f1, &amp;#x27;a&amp;#x27;) &amp;amp; Eq(f2, &amp;#x27;b&amp;#x27;))<br>  [1, 4]<br><br>Using or (|)::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Eq(f1, &amp;#x27;a&amp;#x27;) | Eq(f2, &amp;#x27;b&amp;#x27;))<br>  [1, 2, 4, 5]<br><br>These can be chained::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Eq(f1, &amp;#x27;a&amp;#x27;) &amp;amp; Eq(f2, &amp;#x27;b&amp;#x27;) &amp;amp; Between(f1, &amp;#x27;a&amp;#x27;, &amp;#x27;b&amp;#x27;))<br>  [1, 4]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Eq(f1, &amp;#x27;a&amp;#x27;) | Eq(f1, &amp;#x27;X&amp;#x27;) | Eq(f2, &amp;#x27;b&amp;#x27;))<br>  [1, 2, 3, 4, 5]<br><br>And nested::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery((Eq(f1, &amp;#x27;a&amp;#x27;) | Eq(f1, &amp;#x27;X&amp;#x27;)) &amp;amp; (Eq(f2, &amp;#x27;b&amp;#x27;) | Eq(f2, &amp;#x27;c&amp;#x27;)))<br>  [1, 2, 3, 4, 5]<br><br>&amp;quot;and&amp;quot; and &amp;quot;or&amp;quot; can also be spelled differently::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import And, Or<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(And(Eq(f1, &amp;#x27;a&amp;#x27;), Eq(f2, &amp;#x27;b&amp;#x27;)))<br>  [1, 4]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Or(Eq(f1, &amp;#x27;a&amp;#x27;), Eq(f2, &amp;#x27;b&amp;#x27;)))<br>  [1, 2, 4, 5]<br><br>Combination of In and &amp;amp;<br>-----------------------<br><br>A combination of &amp;#x27;In&amp;#x27; and &amp;#x27;&amp;amp;&amp;#x27;::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(In(f1, [&amp;#x27;a&amp;#x27;, &amp;#x27;X&amp;#x27;, &amp;#x27;Y&amp;#x27;, &amp;#x27;Z&amp;#x27;]))<br>  [1, 2, 3, 4, 5, 6]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(In(f1, [&amp;#x27;Z&amp;#x27;]))<br>  []<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(In(f1, [&amp;#x27;a&amp;#x27;, &amp;#x27;X&amp;#x27;, &amp;#x27;Y&amp;#x27;, &amp;#x27;Z&amp;#x27;]) &amp;amp; In(f1, [&amp;#x27;Z&amp;#x27;]))<br>  []<br><br><br>SetIndex queries<br>----------------<br><br>The SetIndex is defined in zc.catalog.<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import set<br><br>Let&amp;#x27;s make a catalog which uses it::<br><br>  &amp;gt;&amp;gt;&amp;gt; intid = DummyIntId()<br>  &amp;gt;&amp;gt;&amp;gt; provideUtility(intid, zope.intid.interfaces.IIntIds)<br>  &amp;gt;&amp;gt;&amp;gt; from zope.catalog.interfaces import ICatalog<br>  &amp;gt;&amp;gt;&amp;gt; from zope.catalog.catalog import Catalog<br>  &amp;gt;&amp;gt;&amp;gt; catalog = Catalog()<br>  &amp;gt;&amp;gt;&amp;gt; provideUtility(catalog, ICatalog, &amp;#x27;catalog1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; from zc.catalog.catalogindex import SetIndex<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f1&amp;#x27;] = SetIndex(&amp;#x27;f1&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f2&amp;#x27;] = FieldIndex(&amp;#x27;f2&amp;#x27;, IContent)<br><br>First let&amp;#x27;s set up some new data::<br><br>  &amp;gt;&amp;gt;&amp;gt; content = [<br>  ... Content(1, [&amp;#x27;a&amp;#x27;, &amp;#x27;b&amp;#x27;, &amp;#x27;c&amp;#x27;], 1),<br>  ... Content(2, [&amp;#x27;a&amp;#x27;], 1),<br>  ... Content(3, [&amp;#x27;b&amp;#x27;], 1),<br>  ... Content(4, [&amp;#x27;c&amp;#x27;, &amp;#x27;d&amp;#x27;], 2),<br>  ... Content(5, [&amp;#x27;b&amp;#x27;, &amp;#x27;c&amp;#x27;], 2),<br>  ... Content(6, [&amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;], 2),<br>  ... Content(7, [&amp;#x27;z&amp;#x27;], 2),<br>  ... Content(8, [], 2)]  # no value, so not indexed.<br><br>And catalog them now::<br><br>  &amp;gt;&amp;gt;&amp;gt; for entry in content:<br>  ...     catalog.index_doc(intid.register(entry), entry)<br><br>We can query for all indexes objects:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.All(f1))<br>  [1, 2, 3, 4, 5, 6, 7]<br><br>Now do a a &amp;#x27;any of&amp;#x27; query, which returns all documents that<br>contain any of the values listed::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.AnyOf(f1, [&amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;]))<br>  [1, 2, 4, 5, 6]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.AnyOf(f1, [&amp;#x27;c&amp;#x27;, &amp;#x27;b&amp;#x27;]))<br>  [1, 3, 4, 5, 6]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.AnyOf(f1, [&amp;#x27;a&amp;#x27;]))<br>  [1, 2, 6]<br><br>Do a &amp;#x27;all of&amp;#x27; query, which returns all documents that<br>contain all of the values listed::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.AllOf(f1, [&amp;#x27;a&amp;#x27;]))<br>  [1, 2, 6]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.AllOf(f1, [&amp;#x27;a&amp;#x27;, &amp;#x27;b&amp;#x27;]))<br>  [1]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.AllOf(f1, [&amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;]))<br>  [1, 6]<br><br>The next interesting set of queries allows you to make evaluations of the<br>values. For example, you can ask for all objects between a certain set of<br>values:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.SetBetween(f1, &amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;))<br>  [1, 2, 3, 4, 5, 6]<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.SetBetween(f1, &amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;, exclude_min=True))<br>  [1, 3, 4, 5, 6]<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.SetBetween(f1, &amp;#x27;b&amp;#x27;, &amp;#x27;c&amp;#x27;, exclude_max=True))<br>  [1, 3, 5]<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.SetBetween(f1, &amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;,<br>  ...                             exclude_min=True, exclude_max=True))<br>  [1, 3, 5]<br><br>You can also leave out one end of the range:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.SetBetween(f1, &amp;#x27;c&amp;#x27;, None))<br>  [1, 4, 5, 6, 7]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.SetBetween(f1, None, &amp;#x27;c&amp;#x27;, exclude_max=True))<br>  [1, 2, 3, 5, 6]<br><br>You can chain set queries:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.AnyOf(f1, [&amp;#x27;a&amp;#x27;]) &amp;amp; Eq(f2, 1))<br>  [1, 2]<br><br>The ``set` module also supports ``zc.catalog`` extents. The first query is<br>``ExtentAny``, which returns all douments matching the extent. If the the<br>extent is ``None``, all document ids are returned:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.ExtentAny(f1, None))<br>  [1, 2, 3, 4, 5, 6, 7]<br><br>If we now create an extent that is only in the scope of the first four<br>documents,<br><br>  &amp;gt;&amp;gt;&amp;gt; from zc.catalog.extentcatalog import FilterExtent<br>  &amp;gt;&amp;gt;&amp;gt; extent = FilterExtent(lambda extent, uid, obj: True)<br>  &amp;gt;&amp;gt;&amp;gt; for i in range(4):<br>  ...     extent.add(i, i)<br><br>then only the first four are returned:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.ExtentAny(f1, extent))<br>  [1, 2, 3, 4]<br><br>The opposite query is the ``ExtentNone`` query, which returns all ids in the<br>extent that are *not* in the index:<br><br>  &amp;gt;&amp;gt;&amp;gt; id = intid.register(Content(9, &amp;#x27;b&amp;#x27;))<br>  &amp;gt;&amp;gt;&amp;gt; id = intid.register(Content(10, &amp;#x27;c&amp;#x27;))<br>  &amp;gt;&amp;gt;&amp;gt; id = intid.register(Content(11, &amp;#x27;a&amp;#x27;))<br><br>  &amp;gt;&amp;gt;&amp;gt; extent = FilterExtent(lambda extent, uid, obj: True)<br>  &amp;gt;&amp;gt;&amp;gt; for i in range(11):<br>  ...     extent.add(i, i)<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(set.ExtentNone(f1, extent))<br>  [8, 9, 10, 11]<br><br><br>ValueIndex queries<br>------------------<br><br>The ``ValueIndex`` is defined in ``zc.catalog`` and provides a generalization<br>of the standard field index.<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import value<br><br>Let&amp;#x27;s set up a catalog that uses this index. The ``ValueIndex`` is defined in<br>``zc.catalog``. Let&amp;#x27;s make a catalog which uses it:<br><br>  &amp;gt;&amp;gt;&amp;gt; intid = DummyIntId()<br>  &amp;gt;&amp;gt;&amp;gt; provideUtility(intid, zope.intid.interfaces.IIntIds)<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.catalog.interfaces import ICatalog<br>  &amp;gt;&amp;gt;&amp;gt; from zope.catalog.catalog import Catalog<br>  &amp;gt;&amp;gt;&amp;gt; catalog = Catalog()<br>  &amp;gt;&amp;gt;&amp;gt; provideUtility(catalog, ICatalog, &amp;#x27;catalog1&amp;#x27;)<br><br>  &amp;gt;&amp;gt;&amp;gt; from zc.catalog.catalogindex import ValueIndex<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f1&amp;#x27;] = ValueIndex(&amp;#x27;f1&amp;#x27;, IContent)<br><br>Next we set up some content data to fill the indices:<br><br>  &amp;gt;&amp;gt;&amp;gt; content = [<br>  ... Content(1, &amp;#x27;a&amp;#x27;),<br>  ... Content(2, &amp;#x27;b&amp;#x27;),<br>  ... Content(3, &amp;#x27;c&amp;#x27;),<br>  ... Content(4, &amp;#x27;d&amp;#x27;),<br>  ... Content(5, &amp;#x27;c&amp;#x27;),<br>  ... Content(6, &amp;#x27;a&amp;#x27;)]<br><br>And catalog them now:<br><br>  &amp;gt;&amp;gt;&amp;gt; for entry in content:<br>  ...     catalog.index_doc(intid.register(entry), entry)<br><br>We query for all indexes objects::<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.All(f1))<br>  [1, 2, 3, 4, 5, 6]<br><br>Let&amp;#x27;s now query for all objects where ``f1`` equals &amp;#x27;a&amp;#x27;:<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Eq(f1, &amp;#x27;a&amp;#x27;))<br>  [1, 6]<br><br>Next, let&amp;#x27;s find all objects where ``f1`` does not equal &amp;#x27;a&amp;#x27;; this is more<br>efficient than the generic ``~`` operator:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.NotEq(f1, &amp;#x27;a&amp;#x27;))<br>  [2, 3, 4, 5]<br><br>If all the items in the catalog satisfy the NotEq condition, the query<br>does not crash.<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.NotEq(f1, &amp;#x27;z&amp;#x27;))<br>  [1, 2, 3, 4, 5, 6]<br><br>You can also query for all objects where the value of ``f1`` is in a set of<br>values:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.In(f1, [&amp;#x27;a&amp;#x27;, &amp;#x27;d&amp;#x27;]))<br>  [1, 4, 6]<br><br>The next interesting set of queries allows you to make evaluations of the<br>values. For example, you can ask for all objects between a certain set of<br>values:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Between(f1, &amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;))<br>  [1, 2, 3, 5, 6]<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Between(f1, &amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;, exclude_min=True))<br>  [2, 3, 5]<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Between(f1, &amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;, exclude_max=True))<br>  [1, 2, 6]<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Between(f1, &amp;#x27;a&amp;#x27;, &amp;#x27;c&amp;#x27;,<br>  ...                            exclude_min=True, exclude_max=True))<br>  [2]<br><br>You can also leave out one end of the range:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Between(f1, &amp;#x27;c&amp;#x27;, None))<br>  [3, 4, 5]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Between(f1, None, &amp;#x27;c&amp;#x27;))<br>  [1, 2, 3, 5, 6]<br><br>You can also use greater-equals and lesser-equals for the same purpose:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Ge(f1, &amp;#x27;c&amp;#x27;))<br>  [3, 4, 5]<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Le(f1, &amp;#x27;c&amp;#x27;))<br>  [1, 2, 3, 5, 6]<br><br>You can chain value queries:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.Ge(f1, &amp;#x27;c&amp;#x27;) &amp;amp; value.Le(f1, &amp;#x27;c&amp;#x27;))<br>  [3, 5]<br><br>The ``value`` module also supports ``zc.catalog`` extents. The first query is<br>``ExtentAny``, which returns all douments matching the extent. If the the<br>extent is ``None``, all document ids are returned:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.ExtentAny(f1, None))<br>  [1, 2, 3, 4, 5, 6]<br><br>If we now create an extent that is only in the scope of the first four<br>documents,<br><br>  &amp;gt;&amp;gt;&amp;gt; from zc.catalog.extentcatalog import FilterExtent<br>  &amp;gt;&amp;gt;&amp;gt; extent = FilterExtent(lambda extent, uid, obj: True)<br>  &amp;gt;&amp;gt;&amp;gt; for i in range(4):<br>  ...     extent.add(i, i)<br><br>then only the first four are returned:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.ExtentAny(f1, extent))<br>  [1, 2, 3, 4]<br><br>The opposite query is the ``ExtentNone`` query, which returns all ids in the<br>extent that are *not* in the index:<br><br>  &amp;gt;&amp;gt;&amp;gt; id = intid.register(Content(7, &amp;#x27;b&amp;#x27;))<br>  &amp;gt;&amp;gt;&amp;gt; id = intid.register(Content(8, &amp;#x27;c&amp;#x27;))<br>  &amp;gt;&amp;gt;&amp;gt; id = intid.register(Content(9, &amp;#x27;a&amp;#x27;))<br><br>  &amp;gt;&amp;gt;&amp;gt; extent = FilterExtent(lambda extent, uid, obj: True)<br>  &amp;gt;&amp;gt;&amp;gt; for i in range(9):<br>  ...     extent.add(i, i)<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(value.ExtentNone(f1, extent))<br>  [7, 8, 9]<br><br><br>Querying different indexes<br>--------------------------<br><br>It&amp;#x27;s possible to specify the context when creating a query. This context<br>determines which index will be searched.<br><br>First setup a second registry and second catalog and populate it.<br><br>  &amp;gt;&amp;gt;&amp;gt; catalog2 = Catalog()<br>  &amp;gt;&amp;gt;&amp;gt; from zope.component.registry import Components<br>  &amp;gt;&amp;gt;&amp;gt; import zope.component.interfaces<br>  &amp;gt;&amp;gt;&amp;gt; import zope.interface<br>  &amp;gt;&amp;gt;&amp;gt; intid1 = DummyIntId()<br>  &amp;gt;&amp;gt;&amp;gt; @zope.interface.implementer(zope.component.interfaces.IComponentLookup)<br>  ... class MockSite(object):<br>  ...     def __init__(self):<br>  ...         self.registry = Components(&amp;#x27;components&amp;#x27;)<br>  ...     def queryUtility(self, interface, name=&amp;#x27;&amp;#x27;, default=None):<br>  ...         if name == &amp;#x27;&amp;#x27;: return intid1<br>  ...         else: return catalog2<br>  ...     def getSiteManager(self):<br>  ...         return self.registry<br>  &amp;gt;&amp;gt;&amp;gt; from zope.component.hooks import setSite<br>  &amp;gt;&amp;gt;&amp;gt; site1 = MockSite()<br>  &amp;gt;&amp;gt;&amp;gt; setSite(site1)<br>  &amp;gt;&amp;gt;&amp;gt; catalog2[&amp;#x27;f1&amp;#x27;] = FieldIndex(&amp;#x27;f1&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; content = [<br>  ... Content(1,&amp;#x27;A&amp;#x27;),<br>  ... Content(2,&amp;#x27;B&amp;#x27;),]<br>  &amp;gt;&amp;gt;&amp;gt; for entry in content:<br>  ...     catalog2.index_doc(intid1.register(entry), entry)<br><br>Now we can query this catalog by specifying the context:<br><br>  &amp;gt;&amp;gt;&amp;gt; query = getUtility(IQuery)<br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(Eq(f1, &amp;#x27;A&amp;#x27;), context=site1)<br>  [1]<br><br>  &amp;gt;&amp;gt;&amp;gt; displayQuery(In(f1, [&amp;#x27;A&amp;#x27;, &amp;#x27;B&amp;#x27;]), context=site1)<br>  [1, 2]<br><br>Sorting and limiting the results<br>--------------------------------<br><br>It&amp;#x27;s possible to have the resultset sorted on one of the fields in the query.<br><br>  &amp;gt;&amp;gt;&amp;gt; catalog = Catalog()<br>  &amp;gt;&amp;gt;&amp;gt; provideUtility(catalog, ICatalog, &amp;#x27;catalog1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f1&amp;#x27;] = FieldIndex(&amp;#x27;f1&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;f2&amp;#x27;] = FieldIndex(&amp;#x27;f2&amp;#x27;, IContent)<br>  &amp;gt;&amp;gt;&amp;gt; catalog[&amp;#x27;t&amp;#x27;] = TextIndex(&amp;#x27;t1&amp;#x27;, IContent)<br><br>First let&amp;#x27;s set up some new data::<br><br>  &amp;gt;&amp;gt;&amp;gt; content = [<br>  ... Content(1, &amp;#x27;a&amp;#x27;, 2, t1=&amp;#x27;Beautiful is better than ugly.&amp;#x27;),<br>  ... Content(2, &amp;#x27;a&amp;#x27;, 3, t1=&amp;#x27;Explicit is better than implicit&amp;#x27;),<br>  ... Content(3, &amp;#x27;b&amp;#x27;, 9, t1=&amp;#x27;Simple is better than complex&amp;#x27;),<br>  ... Content(4, &amp;#x27;c&amp;#x27;, 8, t1=&amp;#x27;Complex is better than complicated&amp;#x27;),<br>  ... Content(5, &amp;#x27;c&amp;#x27;, 7, t1=&amp;#x27;Readability counts&amp;#x27;),<br>  ... Content(6, &amp;#x27;a&amp;#x27;, 1, t1=&amp;#x27;Although practicality beats purity&amp;#x27;)]<br><br>And catalog them now::<br><br>  &amp;gt;&amp;gt;&amp;gt; for entry in content:<br>  ...     catalog.index_doc(intid.register(entry), entry)<br><br>Define a convenience function for quickly displaying a result set without<br>performing any sorting here ourselves.<br><br>  &amp;gt;&amp;gt;&amp;gt; def displayResult(q, context=None, **kw):<br>  ...     query = getUtility(IQuery)<br>  ...     r = query.searchResults(q, context, **kw)<br>  ...     return [e for e in r]<br><br>Without using sorting in the query itself, the resultset has an undefined<br>order. We &amp;quot;manually&amp;quot; sort the results here to have something testable.<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; [r for r in sorted(displayResult(Eq(f1, &amp;#x27;a&amp;#x27;)))]<br>  [&amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;]<br><br>Now we sort on the f2 index.<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=(&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f2&amp;#x27;))<br>  [&amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;]<br><br>Reverse the order.<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=(&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f2&amp;#x27;), reverse=True)<br>  [&amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;]<br><br>We can limit the amount of found items.<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=(&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f2&amp;#x27;), limit=2)<br>  [&amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;]<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=(&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f2&amp;#x27;), limit=2, start=1)<br>  [&amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;]<br><br>We can limit the reversed resultset too.<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(<br>  ...   Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=(&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f2&amp;#x27;), limit=2, reverse=True)<br>  [&amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;]<br><br>You can directly pass the index as a sort field instead of a tuple:<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=catalog[&amp;#x27;f2&amp;#x27;])<br>  [&amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;]<br><br>Whenever a field is used for sorting that does not support is, an error is<br>raised.<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=(&amp;#x27;catalog1&amp;#x27;, &amp;#x27;t&amp;#x27;))<br>  Traceback (most recent call last):<br>  ...<br>  ValueError: Index t in catalog catalog1 does not support sorting.<br><br>The resultset can still be reversed and limited even if there&amp;#x27;s no sort_field<br>given (Note that the actual order of the result set when not using explicit<br>sorting is not defined. In this test it is assumed that the natural order of<br>the tested index is deterministic enough to be used as a proper test).<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), limit=2)<br>  [&amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;]<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), start=1)<br>  [&amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;]<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), start=1, limit=1)<br>  [&amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;]<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), limit=2, reverse=True)<br>  [&amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;]<br><br>Result counters<br>---------------<br><br>Result objects provide metadata about the result.<br><br>Define a convenience function for obtaining a result.<br><br>  &amp;gt;&amp;gt;&amp;gt; def getResult(q, context=None, **kw):<br>  ...     query = getUtility(IQuery)<br>  ...     return query.searchResults(q, context, **kw)<br><br>Performing a query with a sort_field gives a well-defined result:<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; result = getResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=catalog[&amp;#x27;f1&amp;#x27;])<br>  &amp;gt;&amp;gt;&amp;gt; [e for e in result]<br>  [&amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;]<br><br>We can access &amp;#x27;total&amp;#x27; and &amp;#x27;count&amp;#x27; properties, and &amp;#x27;first()&amp;#x27; on the result:<br><br>  &amp;gt;&amp;gt;&amp;gt; result.total<br>  3<br>  &amp;gt;&amp;gt;&amp;gt; result.count<br>  3<br>  &amp;gt;&amp;gt;&amp;gt; result.first()<br>  &amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;<br><br>Changing &amp;#x27;start&amp;#x27; is reflected in the returned data:<br><br>&amp;gt;&amp;gt;&amp;gt; result = getResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=catalog[&amp;#x27;f1&amp;#x27;], start=1)<br>  &amp;gt;&amp;gt;&amp;gt; [e for e in result]<br>  [&amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;]<br><br>It also changes &amp;#x27;count&amp;#x27; and &amp;#x27;first()&amp;#x27;:<br><br>  &amp;gt;&amp;gt;&amp;gt; result.count<br>  2<br>  &amp;gt;&amp;gt;&amp;gt; result.first()<br>  &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;<br><br>But &amp;#x27;total&amp;#x27; still reflects all matches, including the hidden first one:<br><br>  &amp;gt;&amp;gt;&amp;gt; result.total<br>  3<br><br>Adding a limit:<br><br>  &amp;gt;&amp;gt;&amp;gt; result = getResult(Eq(f1, &amp;#x27;a&amp;#x27;), sort_field=catalog[&amp;#x27;f1&amp;#x27;], start=1,<br>  ...                    limit=1)<br>  &amp;gt;&amp;gt;&amp;gt; [e for e in result]<br>  [&amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;]<br>  &amp;gt;&amp;gt;&amp;gt; result.total<br>  3<br>  &amp;gt;&amp;gt;&amp;gt; result.count<br>  1<br>  &amp;gt;&amp;gt;&amp;gt; result.first()<br>  &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;<br><br>The same accessors are available on an empty result:<br><br>  &amp;gt;&amp;gt;&amp;gt; result = getResult(Eq(f1, &amp;#x27;foo&amp;#x27;), sort_field=catalog[&amp;#x27;f1&amp;#x27;])<br>  &amp;gt;&amp;gt;&amp;gt; [e for e in result]<br>  []<br>  &amp;gt;&amp;gt;&amp;gt; result.total<br>  0<br>  &amp;gt;&amp;gt;&amp;gt; result.count<br>  0<br>  &amp;gt;&amp;gt;&amp;gt; result.first() is None<br>  True<br><br>Wrapper<br>-------<br><br>You can define a wrapper to be called on each result:<br><br>  &amp;gt;&amp;gt;&amp;gt; from zope.location import Location<br>  &amp;gt;&amp;gt;&amp;gt; class Wrapper(Location):<br>  ...    def __init__(self, parent):<br>  ...       self.parent = parent<br>  ...    def __repr__(self):<br>  ...       return &amp;#x27;&amp;lt;Wrapper &amp;quot;{}&amp;quot;&amp;gt;&amp;#x27;.format(self.parent.id)<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Eq(f1, &amp;#x27;a&amp;#x27;), wrapper=Wrapper)<br>  [&amp;lt;Wrapper &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Wrapper &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Wrapper &amp;quot;6&amp;quot;&amp;gt;]<br><br>Locate to<br>---------<br><br>You can define a location where the results should be located with a proxy:<br><br>  &amp;gt;&amp;gt;&amp;gt; def displayParent(q, context=None, **kw):<br>  ...     query = getUtility(IQuery)<br>  ...     r = query.searchResults(q, context, **kw)<br>  ...     return [(e.__parent__, e) or None for e in r]<br><br>  &amp;gt;&amp;gt;&amp;gt; f1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;f1&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayParent(Eq(f1, &amp;#x27;a&amp;#x27;), limit=2)<br>  [(None, &amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;), (None, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;)]<br><br>  &amp;gt;&amp;gt;&amp;gt; parent = Content(&amp;#x27;parent&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayParent(Eq(f1, &amp;#x27;a&amp;#x27;), limit=2, locate_to=parent)<br>  [(&amp;lt;Content &amp;quot;parent&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;), (&amp;lt;Content &amp;quot;parent&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;)]<br><br>This can be used with a wrapper:<br><br>  &amp;gt;&amp;gt;&amp;gt; displayParent(Eq(f1, &amp;#x27;a&amp;#x27;), limit=2, wrapper=Wrapper, locate_to=parent)<br>  [(&amp;lt;Content &amp;quot;parent&amp;quot;&amp;gt;, &amp;lt;Wrapper &amp;quot;1&amp;quot;&amp;gt;), (&amp;lt;Content &amp;quot;parent&amp;quot;&amp;gt;, &amp;lt;Wrapper &amp;quot;2&amp;quot;&amp;gt;)]<br><br>Text index<br>----------<br><br>You can search on text, here all the items that contains better::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import Text<br>  &amp;gt;&amp;gt;&amp;gt; t1 = (&amp;#x27;catalog1&amp;#x27;, &amp;#x27;t&amp;#x27;)<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Text(t1, &amp;#x27;better&amp;#x27;))<br>  [&amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;3&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;4&amp;quot;&amp;gt;]<br><br>Invalid text query returns an empty results::<br><br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Text(t1, &amp;#x27;?*&amp;#x27;))<br>  []<br><br><br>Other terms<br>-----------<br><br>You can do differences, here all the items that contains better but do<br>have a as f1::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import Difference<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Difference(Text(t1, &amp;#x27;better&amp;#x27;), Eq(f1, &amp;#x27;a&amp;#x27;)))<br>  [&amp;lt;Content &amp;quot;3&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;4&amp;quot;&amp;gt;]<br><br><br>There is a special term that allows to mix objects with catalog<br>queries::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import Objects<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Objects(content))<br>  [&amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;3&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;4&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;5&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;]<br><br>There is a special term that allows querying objects by intid::<br><br>  &amp;gt;&amp;gt;&amp;gt; from hurry.query import Ids<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Ids())<br>  []<br><br>  &amp;gt;&amp;gt;&amp;gt; all_intids = [intid.getId(x) for x in content]<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Ids(*all_intids))<br>  [&amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;2&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;3&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;4&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;5&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;6&amp;quot;&amp;gt;]<br><br>  &amp;gt;&amp;gt;&amp;gt; odd_intids = [intid.getId(x) for x in content if x.id % 2]<br>  &amp;gt;&amp;gt;&amp;gt; displayResult(Ids(*odd_intids))<br>  [&amp;lt;Content &amp;quot;1&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;3&amp;quot;&amp;gt;, &amp;lt;Content &amp;quot;5&amp;quot;&amp;gt;]<br><br><br>CHANGES<br>=======<br><br>3.1 (2018-08-08)<br>----------------<br><br>- Add ``Ids`` term that include already known intids in a query.<br><br>3.0.0 (2018-01-19)<br>------------------<br><br>- Support for python 3.4, 3.5 and 3.6 in addition to python 2.7<br><br>- Cleanup in preparation for python3 support:<br><br>  Bugfixes:<br>  o API change: fix And(weighted=) keyword argument typo<br>  o API change: remove utterly broken ``include_minimum`` and ``include_maximum``<br>    arguments to SetBetween(), provide ``exclude_min`` and ``exclude_max`` instead.<br>  o API change: fix broken SetBetween.apply(): introduce ``cache`` arg<br>  o Fix ExtentNone() super delegation bug<br>  o Fix TimingAwareCaching.report() edge condition bug<br><br>  Major:<br>  o Remove unsupported transaction_cache<br><br>  Minor:<br>  o Clarify HURRY_QUERY_TIMING environment and searchResults(timing=) type<br>  o Fix TimingAwareCaching.report() output typo<br>  o Clarify Query.searchResults(caching=) argument type<br>  o Remove unreachable code path from And()<br><br>  Dev:<br>  o Maximize test coverage<br>  o Add Travis and Tox testing configurations<br>  o Bypass bootstrap.py<br>  o Various python3 compatibility preparations<br><br><br>2.6 (2018-01-10)<br>----------------<br><br>- Update dependencies not to rely on ZODB3 anymore.<br><br>2.5 (2017-07-17)<br>----------------<br><br>- `sort_field` can be a index name or an object providing `IIndexSort` itself.<br><br>- `searchResults()` accepts optional parameter `locate_to` and `wrapper`. The<br>  `locate_to` is used as the `__parent__` for the location proxy put arround<br>  the resulting objects. The `wrapper` is a callable callback that should<br>  accept one argument for its parameter.<br><br>2.4 (2017-06-22)<br>----------------<br><br>- Don&amp;#x27;t throw a TypeError slicing unsorted results, fixes #6<br><br>2.3 (2017-04-26)<br>----------------<br><br>- Define a &amp;quot;no result&amp;quot; result object, useful for case where application code<br>  has an custom API for building query terms, but this application code<br>  decides there is no query. Callers might still expect a result-like<br>  object.<br><br>2.2 (2017-04-26)<br>----------------<br><br>- The caching option to searchResults now accepts a dict-like value and it<br>  will use that to allow for caching results over multiple searchResults()<br>  calls. The cache invalidation then is the responsibility of the caller.<br><br>2.1 (2017-02-07)<br>----------------<br><br>- Add the possibility to time how long a query takes. It can be<br>  controlled with the new ``timing`` option to ``searchResults`` or<br>  the ``HURRY_QUERY_TIMING`` environment variable.<br><br>2.0.1 (2016-09-08)<br>------------------<br><br>- Fix log line in Text term for invalid text search.<br><br>2.0 (2016-09-07)<br>----------------<br><br>- Add new term: Difference. It does a difference between the first and<br>  the following terms passed as arguments.<br><br>- Add new term: Objects. It creates a result out of the objects passed<br>  in arguments. It let you mix real objects with existing catalog<br>  queries (with And, Or or Difference for instance).<br><br>- Add an option start to searchResult to skip the first results in the<br>  results set.<br><br>- Extend the result from searchResult. You have addition information<br>  on the result, including the total number of results without<br>  start/limit restriction. A method called first() return only the<br>  first result if available or none.<br><br>- Add an option caching to searchResult to cache the result of each<br>  terms within a Zope transaction, speeding similar queries. If<br>  disabled, terms will still be cached within the same query.<br><br><br>1.2 (2015-12-16)<br>----------------<br><br>* Add support for an All query.<br><br>1.1.1 (2012-06-22)<br>------------------<br><br>* ExtentNone in set.py missed a parameter ``index_id``. Thanks to Danilo<br>  Botelho for the bug report.<br><br>1.1.0 (2010-07-12)<br>------------------<br><br>* Allow the searchResults method of a Query to take an additional keyword<br>  argument `sort_field` that defines that defines (catalog_name, index_name) to<br>  sort on. That index in that catalog should implement IIndexSort.<br><br>  In addition to this keyword argument, `limit` and `reverse` keyword arguments<br>  can be passed too, that will limit the sorted resultset and/or reverse its<br>  order.<br><br>* Allow the searchResults method of a Query object to take an additional<br>  optional context argument. This context will determine which catalog<br>  the search is performed on.<br><br>1.0.0 (2009-11-30)<br>------------------<br><br>* Refresh dependencies. Use zope.catalog and zope.intid instead of<br>  zope.app.catalog and zope.app.intid respectively. Don&amp;#x27;t zope.app.zapi.<br><br>* Make package description more modern.<br><br>* Clean up the code style.<br><br>0.9.3 (2008-09-29)<br>------------------<br><br>* BUG: NotEq query no longer fails when all values in the index<br>  satisfy the NotEq condition.<br><br>0.9.2 (2006-09-22)<br>------------------<br><br>* First release on the cheeseshop.<br><br>0.9.1 (2006-06-16)<br>------------------<br><br>* Make zc.catalog a dependency of hurry.query.<br><br>0.9 (2006-05-16)<br>----------------<br><br>* Separate hurry.query from the other hurry packages. Eggification work.<br><br>* Support for ValueIndex from zc.catalog.<br><br>0.8 (2006-05-01)<br>----------------<br><br>Initial public release.\n          </div>"}, "last_serial": 4149306, "releases": {"0.9.2": [{"comment_text": "", "digests": {"md5": "1a65812bdd91b61df08993028693edd5", "sha256": "23acd85a4c90f171482687dd0814eff273d586b2e3d53ba4e866a30c64f20ba3"}, "downloads": -1, "filename": "hurry.query-0.9.2-py2.4.egg", "has_sig": false, "md5_digest": "1a65812bdd91b61df08993028693edd5", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 15009, "upload_time": "2006-09-22T16:30:24", "upload_time_iso_8601": "2006-09-22T16:30:24Z", "url": "https://files.pythonhosted.org/packages/0b/45/9bf61bf0509ddb3f49feea1a32739d080e91ad3ddee042d4402b56c7a219/hurry.query-0.9.2-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "bf415b239fbe370eab368c604a2f4a96", "sha256": "bc55ca80504a1bee85dc7323a8837bf01fa1dbedc42a1b35db1c716ddd2fc501"}, "downloads": -1, "filename": "hurry.query-0.9.2.tar.gz", "has_sig": false, "md5_digest": "bf415b239fbe370eab368c604a2f4a96", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7713, "upload_time": "2006-09-22T16:30:18", "upload_time_iso_8601": "2006-09-22T16:30:18Z", "url": "https://files.pythonhosted.org/packages/3e/82/8e95ed2c47f772323ccdacd43ab310f46a848d0bbed49f6acd8c727510db/hurry.query-0.9.2.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "6376819e6a1aff315d1bbca7b5e63790", "sha256": "07b944ddc05774e6171b3632fed967ac1a90fadff6c2c11cb2be5e464f30a1ae"}, "downloads": -1, "filename": "hurry.query-1.0.0.tar.gz", "has_sig": false, "md5_digest": "6376819e6a1aff315d1bbca7b5e63790", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12699, "upload_time": "2009-11-30T17:08:17", "upload_time_iso_8601": "2009-11-30T17:08:17.193092Z", "url": "https://files.pythonhosted.org/packages/5f/9d/459d6011a6fa91a8fd93b4447cca8851a5fb1d5d7606d552183e0420f17b/hurry.query-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "e5acf63d8e1ecccc7a9c02a957f05b3f", "sha256": "eff5b70c23038b4d8712268fb4732c9367a380f6a2721508bd1b9d106763327b"}, "downloads": -1, "filename": "hurry.query-1.1.0.tar.gz", "has_sig": false, "md5_digest": "e5acf63d8e1ecccc7a9c02a957f05b3f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17595, "upload_time": "2010-07-12T08:21:24", "upload_time_iso_8601": "2010-07-12T08:21:24.527928Z", "url": "https://files.pythonhosted.org/packages/1f/a1/5b8411d1fa14d9a634988d6fbb88d31daafc27fd95ed43be8f9f6ba19027/hurry.query-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "be22c3a1b5247a3536355d084c080a62", "sha256": "8d3742430c51e3d5bf7b4e13c77629f9c23c51aef0cb68d9b71a00ca14ca05f6"}, "downloads": -1, "filename": "hurry.query-1.1.1.tar.gz", "has_sig": false, "md5_digest": "be22c3a1b5247a3536355d084c080a62", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24129, "upload_time": "2012-06-22T15:19:17", "upload_time_iso_8601": "2012-06-22T15:19:17.776003Z", "url": "https://files.pythonhosted.org/packages/bf/7c/2bc6f343734a3759b9bcee494941cfce5a8120b37d2b1ee22c7a8422a686/hurry.query-1.1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "9fad10d1f6862f398b971cafe63bc4a7", "sha256": "bdf74ed71b5d2b4950592ed3ed620e621509ac1dd77591ffb88ae1e430761962"}, "downloads": -1, "filename": "hurry.query-1.2.tar.gz", "has_sig": false, "md5_digest": "9fad10d1f6862f398b971cafe63bc4a7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22053, "upload_time": "2015-12-16T16:27:03", "upload_time_iso_8601": "2015-12-16T16:27:03.474033Z", "url": "https://files.pythonhosted.org/packages/07/b5/52b869476ba399a972f28cfb492fbb71ea9c424389019fc80da0b78f06fd/hurry.query-1.2.tar.gz", "yanked": false}], "2.0": [{"comment_text": "", "digests": {"md5": "161f4dc8348cf7f9ce6b74935e673052", "sha256": "84efbadfd69e2fc029ed8452bc74d91aea792894d680d64df76018f7735adc25"}, "downloads": -1, "filename": "hurry.query-2.0.tar.gz", "has_sig": false, "md5_digest": "161f4dc8348cf7f9ce6b74935e673052", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25219, "upload_time": "2016-09-07T15:00:11", "upload_time_iso_8601": "2016-09-07T15:00:11.670299Z", "url": "https://files.pythonhosted.org/packages/73/17/37db379837a160e37771ae43e41aac3d9ac4ce8cb8c48542df1f500f8a2c/hurry.query-2.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "d526b524610e99fbe59c9de7f8dcf2cd", "sha256": "7d8340f656f2222e0bbfa74d43cbe9c03b2ff3d1dacb0ff754345c012eee3cb8"}, "downloads": -1, "filename": "hurry.query-2.0.1.tar.gz", "has_sig": false, "md5_digest": "d526b524610e99fbe59c9de7f8dcf2cd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25473, "upload_time": "2016-09-08T07:13:58", "upload_time_iso_8601": "2016-09-08T07:13:58.479609Z", "url": "https://files.pythonhosted.org/packages/b1/8b/f6c91e7a4c449670cb7ca270af691d80061858c77411085029bc499a2d9c/hurry.query-2.0.1.tar.gz", "yanked": false}], "2.1": [{"comment_text": "", "digests": {"md5": "89f5de37268064909b744f4ab1f19c65", "sha256": "7a657accaba74c614d2f1bf7983ad2a21c7282691928af52ebb1e8c3aeff4d95"}, "downloads": -1, "filename": "hurry.query-2.1.tar.gz", "has_sig": false, "md5_digest": "89f5de37268064909b744f4ab1f19c65", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27002, "upload_time": "2017-02-07T08:39:47", "upload_time_iso_8601": "2017-02-07T08:39:47.544741Z", "url": "https://files.pythonhosted.org/packages/cb/98/45bc67d0ad110cb038d2285ca0552a725b9e63333e7ee9b09d6d0fdfded8/hurry.query-2.1.tar.gz", "yanked": false}], "2.2": [{"comment_text": "", "digests": {"md5": "43d6ab56c1ba063d3c96c03c30791470", "sha256": "13563a2ea8c70cd837007aba7120726b3c0e462597a99245680517ebbb1f103e"}, "downloads": -1, "filename": "hurry.query-2.2.tar.gz", "has_sig": false, "md5_digest": "43d6ab56c1ba063d3c96c03c30791470", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25568, "upload_time": "2017-04-26T09:15:12", "upload_time_iso_8601": "2017-04-26T09:15:12.303823Z", "url": "https://files.pythonhosted.org/packages/eb/47/e5596a0db5e5b85ea6f8e8d734719bf6ecec058eccd2fd0f985e9a43cb11/hurry.query-2.2.tar.gz", "yanked": false}], "2.3": [{"comment_text": "", "digests": {"md5": "22cf4400a74dd16bc1a3c97572fb363a", "sha256": "07d129ea107ddd7b68b45f248ec64bcad278d3c121d32fb8e96eb716d0016f00"}, "downloads": -1, "filename": "hurry.query-2.3.tar.gz", "has_sig": false, "md5_digest": "22cf4400a74dd16bc1a3c97572fb363a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26388, "upload_time": "2017-04-26T09:59:22", "upload_time_iso_8601": "2017-04-26T09:59:22.688287Z", "url": "https://files.pythonhosted.org/packages/0f/c3/3276944dc439795d8f711b403cab9bd3c1c729117e6b4ed7b7ca190b8154/hurry.query-2.3.tar.gz", "yanked": false}], "2.4": [{"comment_text": "", "digests": {"md5": "b5fb3a87a4054c2a9b20c94a47abbeef", "sha256": "9ba2591cd745f3ed309a4a587fe8a872fb99e68fc0d3f473226c86ead1b49c8c"}, "downloads": -1, "filename": "hurry.query-2.4.tar.gz", "has_sig": false, "md5_digest": "b5fb3a87a4054c2a9b20c94a47abbeef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26577, "upload_time": "2017-06-22T07:07:29", "upload_time_iso_8601": "2017-06-22T07:07:29.906950Z", "url": "https://files.pythonhosted.org/packages/bc/af/edc639cdea624338a75b64e191a29bbc75583efe2a740c63c8972cbfe88e/hurry.query-2.4.tar.gz", "yanked": false}], "2.5": [{"comment_text": "", "digests": {"md5": "c459c20cdf355b9c5a6413d06a7f82cd", "sha256": "c28430f7c980f79f36ba0942ecc16335d627203b9ea6d544961bc0eca84ab234"}, "downloads": -1, "filename": "hurry.query-2.5.tar.gz", "has_sig": false, "md5_digest": "c459c20cdf355b9c5a6413d06a7f82cd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29922, "upload_time": "2017-07-17T14:20:46", "upload_time_iso_8601": "2017-07-17T14:20:46.168376Z", "url": "https://files.pythonhosted.org/packages/5b/9a/ec686933b6fab0c27dbdbc2a73a481a336d276969ab4dd249ea9f870ee8e/hurry.query-2.5.tar.gz", "yanked": false}], "2.6": [{"comment_text": "", "digests": {"md5": "ea8528f500fe9cf7b72b78a3a8b64f39", "sha256": "e04fee7de69b232a098e8d132f62c355410705034fe14412be6e7a152f92e8e8"}, "downloads": -1, "filename": "hurry.query-2.6.tar.gz", "has_sig": false, "md5_digest": "ea8528f500fe9cf7b72b78a3a8b64f39", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31004, "upload_time": "2018-01-10T13:29:57", "upload_time_iso_8601": "2018-01-10T13:29:57.836970Z", "url": "https://files.pythonhosted.org/packages/46/aa/56f3717baa427477e4f7a3bbea5f86a655356aeb2818da4af6f373c7d782/hurry.query-2.6.tar.gz", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "e44281fb4174bf681636ed64d9f9b8e0", "sha256": "a7c1a6b2c65e9f3936306630c519b9094291ab16eda9947d1e91d6656376c3c9"}, "downloads": -1, "filename": "hurry.query-3.0.0.tar.gz", "has_sig": false, "md5_digest": "e44281fb4174bf681636ed64d9f9b8e0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36438, "upload_time": "2018-01-19T12:04:45", "upload_time_iso_8601": "2018-01-19T12:04:45.097832Z", "url": "https://files.pythonhosted.org/packages/78/05/7b805e0b6695208c9393f6ec990fed3f4227f9482986522f501f367c02a3/hurry.query-3.0.0.tar.gz", "yanked": false}], "3.1": [{"comment_text": "", "digests": {"md5": "193f8d7ab9efbddfddbe6e1ff422d17a", "sha256": "b854d600a054f3071cf9b8eed2f2fd2f91649acaa083a3f02e9f6afaa95ef23f"}, "downloads": -1, "filename": "hurry.query-3.1.tar.gz", "has_sig": false, "md5_digest": "193f8d7ab9efbddfddbe6e1ff422d17a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35268, "upload_time": "2018-08-08T14:56:25", "upload_time_iso_8601": "2018-08-08T14:56:25.509414Z", "url": "https://files.pythonhosted.org/packages/11/d6/d74dce51bfc81a48fc6075b183c49439a5945ebc0a3633f36728b90d169b/hurry.query-3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "193f8d7ab9efbddfddbe6e1ff422d17a", "sha256": "b854d600a054f3071cf9b8eed2f2fd2f91649acaa083a3f02e9f6afaa95ef23f"}, "downloads": -1, "filename": "hurry.query-3.1.tar.gz", "has_sig": false, "md5_digest": "193f8d7ab9efbddfddbe6e1ff422d17a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35268, "upload_time": "2018-08-08T14:56:25", "upload_time_iso_8601": "2018-08-08T14:56:25.509414Z", "url": "https://files.pythonhosted.org/packages/11/d6/d74dce51bfc81a48fc6075b183c49439a5945ebc0a3633f36728b90d169b/hurry.query-3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:49:46 2020"}