{"info": {"author": "Braid Generator Team", "author_email": "mmnasrollahi@ucdavis.edu", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# Braid Generator\n\nBraid Generator is a project from the Department of Mathematics in the University of California, Davis. Braid Generator implements a Markov chain algorithm to generate an ensemble of braid representatives (``braidreps\") from a given braid representative of a fixed knot or link type. The project was born when we attempted to use Machine Learning techniques to study braids but found the existing data sets of braid representatives to be too small. The hope is that this program will help others generate data to help better understand braids, knot invariants, and the topology of the space of knots. For more information on\nmathematical braid groups, please refer to this [resource](https://en.wikipedia.org/wiki/Braid_group).\n\n## Getting Started\n\nThese instructions will get you a copy of the project up and running on your local machine for development and testing purposes.\n\n### Prerequisites\n\nDue to the formatting styles used in this package, `braidgenerator` is compatible with Python 3.6 or 3.7.\n\nThe only required dependency for this package is _pandas_. If installing with a local clone, make sure to have _pandas_ installed in the desired environment.\n\n```\n.\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 LICENSE.md\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 ThirdPartyLicenses\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Pandas\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 LICENSE.md\n\u251c\u2500\u2500 braidgenerator\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 braidword.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 decorators\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 braidword.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 markovchain.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 markovchain.py\n\u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 braidword.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 contact.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 index.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 markovchain.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 style.css\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 van.js\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 test_braidword.py\n    \u2514\u2500\u2500 test_markovchain.py\n```\n\n> The tree represents the hierarchy of the github repository.\n\n### Installation\n\n#### Install BraidGenerator from PyPI\n\nTo install via pip, use the following\n\n```\n$ python3 -m pip install --index-url https://test.pypi.org/simple/ --no-deps moore_braidgenerator\n```\n\n> Please note the actual project has not been put up on PyPi yet. Please\n> follow installation by repository. Package will be uploaded to PyPi in the\n> coming few days.\n\n#### Install BraidGenerator from the GitHub source\n\nFirst, clone the Knots repository onto your local machine using `git`. For more information on `git` cloning, visit this [resource](https://www.git-tower.com/learn/git/commands/git-clone).\n\n```\ngit clone https://github.com/Algebra8/Knots\n```\n\nThen, `cd` to the Knots folder and run the install command:\n\n```\ncd Knots\npython setup.py install\n```\n\n### Setup and Examples\n\n#### A quick example for the impatient user\n\nWithin Python try the following example snippet, which takes as its input a braid representative for the trefoil knot (`[1, 1, 1]`), and returns three randomized braid representatives.\n\n```\nfrom braidgenerator import MarkovChain\nimport pandas as pd\n\n# Create markov chain\nmc = MarkovChain(braidword=[1, 1, 1], maxgen=9, maxlen=10)\n\n# Model markov chain\nmc.model(num_braidreps=3, msteps=500)\n\n# Get braid representatives as words (i.e. as lists)\nbraidreps = mc.braidreps(as_word = True)\n\n```\n\nExplanations and definitions are given in detail in the sections below.\n\n#### Setting up the Braid Generator\n\nTo create a Markov Chain, simply call `MarkovChain` with at least the `braidword` argument given. The `MarkovChain` initializor has default values of\nnine and ten for the `maxgen` and `maxlen` parameters, respectively. The speficied argument of `braidword` is the initial state of the Markov process; the state space consists of other braid words representating the same knot as the (closed) initial braid.\n\n```\nfrom braidgenerator import MarkovChain\nimport pandas as pd\n\nmc = MarkovChain(braidword=[1, 2, 3], maxgen=9, maxlen=10)\n\n```\n\nAlternatively, the Markov Chain can be initialized with a `BraidWord` instead of a list. The BraidWord is wrapped around a list (the _word_).\n\n```\nfrom braidgenerator import MarkovChain\nfrom braidgenerator import BraidWord\nimport pandas as pd\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n```\n\n> Note that if the Markov Chain is initialized with a list instead of a BraidWord, it will be processed into a BraidWord behind the scenes.\n\nTo create new braidreps it suffices to call the `model` method. The method `model` takes two parameters, `num_braidreps` and `msteps`, where `num_braidreps` is the number of braidreps that are to be generated and `msteps` is the number of Markov steps taken in each random walk that produces such a braidrep. Default values are one and 100, respectively. Markov chain steps are comprised of braid relations and ``Markov moves\" (in the sense of moves on closed braids).\n\n```\nmc.model(num_braidreps=10, msteps=50)\n```\n\nOnce the modelling is complete, the braidreps and/or logs can be accessed via the following getter methods:\n\n- `MarkovChain.aggregate`\n- `MarkovChain.logs`\n- `MarkovChain.braidreps`\n- `MarkovChain.topandas`\n- `MarkovChain.tocsv`\n- `MarkovChain.totxt`\n\n#### `MarkovChain.aggregate`\n\nThe `aggregate` method will return a dictionary with two keys: _braidreps_ and _logs_, whereby _braidreps_ is a list that contains the generated braidreps and _logs_ is a list that contains the relevant Markov steps per iteration and if they were successful or not.\n\n> This aggregate dictionary is mainly a container for the relevant data and while this getter method is available, it is not recommended for retrieving the data. Better alternative methods exist for this.\n\n```\nagg = mc.aggregate()\n\nagg\n\n> {'braidreps': [], 'logs': []}\n```\n\n#### `MarkovChain.logs`\n\nThe `logs` method returns only the logs in the list format. Each element of the log is itself a dictionary that represents all the Markov steps for each braidrep created. Thus, the size of _braidreps_ and _logs_ will be the same, but each entry will contain a larger set of logs. The example below shows a MarkovChain's logs with `num_braidreps=1` and `msteps=5`\n\n```\nlogs = mc.logs()\n\nlogs[0]\n\n> {0: 'MoveType: 5, Attempted stabilize: stabilize Succeeded.',\n1: 'MoveType: 0, Attempted conjugate: conjugate Succeeded.',\n2: 'MoveType: 6, Attempted destabilize: destabilize Failed.',\n3: 'MoveType: 3, Attempted transpose: transpose Failed.',\n4: 'MoveType: 4, Attempted flip: flip Failed.'}\n```\n\n#### `MarkovChain.braidreps`\n\nThe `braidreps` method will return the list with the generated braidreps. This method takes an optional parameter `as_word` which is set to `False` by default. If left as `False` then it will return a list of BraidWords, otherwise it will return a list of words (i.e. of type list).\n\n```\n# As BraidWords with as_word set to False (default)\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\nbraidreps_asBraidWord = mc.braidreps()\n\nbraidreps_asBraidWord\n\n> [<braidword.BraidWord at 0x114dbe7b8>,\n <braidword.BraidWord at 0x114dbe7f0>,\n <braidword.BraidWord at 0x114dbe588>]\n```\n\n```\n# As words with as_word set to True\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\nbraidreps_asword = mc.braidreps(as_word=True)\n\nbraidreps_asword\n\n> [[1, 2, 3], [2, 3, 1], [1, 2]]\n```\n\n> Note that the braid that was fed into the model is not included. The first word of the second example above is a coincidence resulting from one successful destabilize and one successful stabilize.\n\n#### `MarkovChain.topandas`\n\nThe logs and braidreps can be most easily accessed via the `topandas` method. To use it, simply import _pandas_ into the script and call the `topandas` method. The method takes one optional argument, `only_braidreps`, which is set to `False` by defualt. If set to `True` then the resulting dataframe will only include the braidreps in word form. Otherwise, each entry will comprise of both the braidrep and the logs associated with it.\n\n```\n# only_braidreps set to False (default)\nimport pandas as pd\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\ndf = mc.topandas()\ndf.columns\n\n> Index(['braidreps', 'Logs'], dtype='object')\n```\n\n```\n# only_braidreps set to True\nimport pandas as pd\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\ndf = mc.topandas(only_braidreps=True)\ndf.columns\n\n> Index(['braidreps'], dtype='object')\n```\n\n#### `MarkovChain.tocsv`\n\nThe `tocsv` method exports the dataframe to a .csv file. The parameters include `path_or_filename` and `only_braidreps`, respectively. Similar to the `topandas` method, `only_braidreps` is set to `False` by default. The `path_or_filename` parameter is more interesting. If a path is not specified, the method will export the requested information to the current directory with either the name _braidreps.csv_\nor _braidreps_and_Logs.csv_, which it will implicitly interpret from the argument passed to `only_braidreps`.\n\n```\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\npath = 'some/path/onyourpc.csv'\nmc.tocsv(path_or_filename=path, only_braidreps=False)\n```\n\n#### `MarkovChain.totxt`\n\nThe `totxt` method is similar to the `topandas` and `tocsv` difference being that it exports the data to a _.txt_ file in the following format:\n\n```\nbraidrep[1]\n.\n.\n.\nbraidrep[n]\n\nlog[1]\n.\n.\n.\nlog[n]\n```\n\nAs is with to `tocsv`, the `totxt` has the two parameters\n`path_or_filename` and `only_braidreps`, respectively.\n\n### Clearing the model and setting a new BraidWord\n\nIf it is desired to use the same model to create a new set of isomoprhs, the `clear_model` method is required. This method clears the _braidagg_ container.\n\n```\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\nmc.clear_model()\n\nmc.aggregate()\n\n> {'braidreps': [], 'logs': []}\n```\n\n> Note that if not changed, the subsequent BraidWord will have been mutated. This functionality is left in as it may seem desirable for some situations and is simple enough to undo (i.e. replace the BraidWord with the `new_braidword` method).\n\nIn the event that it is desirable to set a new _BraidWord_ into an already existing method, the `new_braidword` method can be used. A list or `BraidWord` object can be passed as an argument.\n\n```\nmc.new_braidword([1, 1, 2])\n```\n\n```\nmc.new_braidword(BraidWord([1, 2, 3]))\n```\n\n> As is the case with the initializor, if a list is passed in as an argument it will be converted to a BraidWord behind the scenes.\n\n### Bonus BraidWord functionality\n\n#### `crossing_change`\n\nThe `crossing_change` method performs a crossing change on a BraidWord. That is, it returns a new BraidWord whereby\nthe generator at a specified index is inverted.\n\nThe resulting index can be set randomly with `random_index` set to `True`, or it can be set manually by setting `random_index=False` and assigning `index` with an integer value between zero and the length of the word of the BraidWord.\n\n```\nfrom braidgenerator import BraidWord\n\nbraidword = BraidWord([1, 2, 3])\n\n# Randomly set generator to be inverted\nrandom_newbraidword = braidword.crossing_change(random_index=True)\n\n# Manually set generator to be inverted\nmanual_newbraidword = braidword.crossing_change(random_index=False, index=1)\n\nrandom_newbraidword.word\n>>> [1, 2, -3]\n\nmanual_newbraidword.word\n>>> [1, -2, 3]\n```\n\n#### `resolution`\n\nThe `resolution` method performs a resolution on a BraidWord. That is, it returns a new BraidWord whereby\nthe generator at a specified index is removed and the new BraidWord's length is decreased by one.\n\nThe resulting index can be set randomly with `random_index` set to `True`, or it can be set manually by setting `random_index=False` and assigning `index` with an integer value between zero and the length of the word of the BraidWord.\n\n```\nfrom braidgenerator import BraidWord\n\nbraidword = BraidWord([1, 2, 3])\n\n# Randomly set generator to be removed\nrandom_newbraidword = braidword.resolution(random_index=True)\n\n# Manually set generator to be removed\nmanual_newbraidword = braidword.resolution(random_index=False, index=1)\n\nrandom_newbraidword.word\n>>> [2, 3]\n\nmanual_newbraidword.word\n>>> [1, 3]\n```\n\n## Running the tests\n\nTests for these scripts are included in the github repository under the paths shown below.\n\n```\n.\n|\n\u2514\u2500\u2500\u2500tests\n        test_braidword.py\n        test_markovchain.py\n```\n\n### Breakdown of tests\n\nThe given tests use Pythons UnitTest package for testing.\n**test_braidword.py** contains over 350 lines of tests with 30+ test cases (at the time of writting this readme). The test cases contain suites that test for initialization, boolean helper functions (such as `canDestabilize`, `canFlip`, etc...), and the **BraidWord** methods (such as `Destabilize`, `Flip`, etc...). Examples of **test_braidword.py** include:\n\n```\ndef test_init_pathfail_0(self):\n    '''\n    Should raise TypeError if initword\n    is not a list (args)\n    '''\n    with self.assertRaises(TypeError) as te:\n        bw = BraidWord(1)\n```\n\n```\ndef test_canCancel_pathfail(self):\n    \"\"\"Should return False when adjacent\n    generators are not inverses of one other\"\"\"\n    bw = BraidWord([1, 2, 3, -3])\n    # Execution path False\n    self.assertFalse(bw.canCancel(0))\n```\n\n```\ndef test_cancel_pathsuccess(self):\n    \"\"\"Should successfully cancel gen @idx 3\n    and should modify word\"\"\"\n    bw = BraidWord([-1, 2, 3, 1])\n    # Execution path True\n    self.assertTrue(bw.cancel(3))\n    # Word modification\n    self.assertEqual(bw.word, [2, 3])\n```\n\n**test_markovchain.py** contains roughly 200 lines of tests with 18+ test cases (at the time of writing this readme). The test cases contain suites that test mainly for initialization and that containers, such as _logs_, _braidrepisms_, and _braidagg_, vis-a-vis the `aggregate`, `logs`, and `braidreps` methods, as well as exporting methods, such as `tocsv`, `topandas`, and `totxt`, are valid (i.e. not empty). The lack of automated tests for said script is due to the probabilistic nature of the results of the `model` method. Results for this method may be tested by hand or an auxiliary program, such as ``KnotPlot.\" Examples of **test_markovchain.py** include:\n\n```\ndef test_init_pathfail_0(self):\n    \"\"\"Should throw error if BraidWord not given\"\"\"\n    with self.assertRaises(Exception) as te:\n        MarkovChain()\n```\n\n```\ndef test_aggregate(self):\n    '''\n    Should return non-empty self.braidagg\n    '''\n    mc = MarkovChain(BraidWord([1, 2, 3]))\n    mc.model(num_braidreps=1, msteps=10)\n    # Check if non-empty\n    self.assertTrue(mc.aggregate())\n```\n\n```\ndef test_logs(self):\n    '''\n    Should return non-empty self.braidagg.logs\n    '''\n    mc = MarkovChain(BraidWord([1, 2, 3]))\n    mc.model(num_braidreps=1, msteps=10)\n    # Check if non-empty\n    self.assertTrue(mc.logs())\n```\n\n> BraidWord's `crossing_change` and `resolution` methods follow similar formats and can be viewed in the `tests\\test_braidword` module in the repository.\n\n## Documentation\n\nFor more information about methods and code fragments, please refer to the [documentation](https://algebra8.github.io/braidgenerator_doc.github.io/).\n\n## Contributing\n\nPlease read [CONTRIBUTING.md](https://gist.github.com/PurpleBooth/b24679402957c63ec426) for details on our code of conduct, and the process for submitting pull requests to us.\n\n## Versioning\n\nWe use [SemVer](http://semver.org/) for versioning. For the versions available, see the [tags on this repository](https://github.com/your/project/tags).\n\n## Authors\n\n- **Allison Moore** - _Initial work_ - [allisonhmoore](https://github.com/allisonhmoore)\n- **Milad Michael Nasrollahi** - _Initial work_ - [Algebra8](https://github.com/Algebra8)\n- **Shawn Witte** - _Initial work_ - [Minirogue](https://github.com/Minirogue)\n\n<!-- See also the list of [contributors](https://github.com/your/project/contributors) who participated in this project. -->\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.\n\n## Acknowledgements\n\nThis package makes use of _pandas_ as a requirement. Please refer to the [_pandas_ license](https://github.com/pandas-dev/pandas/blob/master/LICENSE) for more information on their license.\n\nThe CONTRIBUTING.md content was adapted from PurpleBooth's [Good-CONTRIBUTING.md-template.md](https://gist.github.com/PurpleBooth/b24679402957c63ec426).\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Algebra8/Knots", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "braidgenerator", "package_url": "https://pypi.org/project/braidgenerator/", "platform": "", "project_url": "https://pypi.org/project/braidgenerator/", "project_urls": {"Homepage": "https://github.com/Algebra8/Knots"}, "release_url": "https://pypi.org/project/braidgenerator/1.0.0/", "requires_dist": ["pandas", "unittest ; extra == 'tests'"], "requires_python": "", "summary": "Braid Generator", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Braid Generator</h1>\n<p>Braid Generator is a project from the Department of Mathematics in the University of California, Davis. Braid Generator implements a Markov chain algorithm to generate an ensemble of braid representatives (``braidreps\") from a given braid representative of a fixed knot or link type. The project was born when we attempted to use Machine Learning techniques to study braids but found the existing data sets of braid representatives to be too small. The hope is that this program will help others generate data to help better understand braids, knot invariants, and the topology of the space of knots. For more information on\nmathematical braid groups, please refer to this <a href=\"https://en.wikipedia.org/wiki/Braid_group\" rel=\"nofollow\">resource</a>.</p>\n<h2>Getting Started</h2>\n<p>These instructions will get you a copy of the project up and running on your local machine for development and testing purposes.</p>\n<h3>Prerequisites</h3>\n<p>Due to the formatting styles used in this package, <code>braidgenerator</code> is compatible with Python 3.6 or 3.7.</p>\n<p>The only required dependency for this package is <em>pandas</em>. If installing with a local clone, make sure to have <em>pandas</em> installed in the desired environment.</p>\n<pre><code>.\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 LICENSE.md\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 ThirdPartyLicenses\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Pandas\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 LICENSE.md\n\u251c\u2500\u2500 braidgenerator\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 braidword.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 decorators\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 braidword.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 markovchain.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 markovchain.py\n\u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 braidword.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 contact.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 index.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 markovchain.html\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 style.css\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 van.js\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 test_braidword.py\n    \u2514\u2500\u2500 test_markovchain.py\n</code></pre>\n<blockquote>\n<p>The tree represents the hierarchy of the github repository.</p>\n</blockquote>\n<h3>Installation</h3>\n<h4>Install BraidGenerator from PyPI</h4>\n<p>To install via pip, use the following</p>\n<pre><code>$ python3 -m pip install --index-url https://test.pypi.org/simple/ --no-deps moore_braidgenerator\n</code></pre>\n<blockquote>\n<p>Please note the actual project has not been put up on PyPi yet. Please\nfollow installation by repository. Package will be uploaded to PyPi in the\ncoming few days.</p>\n</blockquote>\n<h4>Install BraidGenerator from the GitHub source</h4>\n<p>First, clone the Knots repository onto your local machine using <code>git</code>. For more information on <code>git</code> cloning, visit this <a href=\"https://www.git-tower.com/learn/git/commands/git-clone\" rel=\"nofollow\">resource</a>.</p>\n<pre><code>git clone https://github.com/Algebra8/Knots\n</code></pre>\n<p>Then, <code>cd</code> to the Knots folder and run the install command:</p>\n<pre><code>cd Knots\npython setup.py install\n</code></pre>\n<h3>Setup and Examples</h3>\n<h4>A quick example for the impatient user</h4>\n<p>Within Python try the following example snippet, which takes as its input a braid representative for the trefoil knot (<code>[1, 1, 1]</code>), and returns three randomized braid representatives.</p>\n<pre><code>from braidgenerator import MarkovChain\nimport pandas as pd\n\n# Create markov chain\nmc = MarkovChain(braidword=[1, 1, 1], maxgen=9, maxlen=10)\n\n# Model markov chain\nmc.model(num_braidreps=3, msteps=500)\n\n# Get braid representatives as words (i.e. as lists)\nbraidreps = mc.braidreps(as_word = True)\n\n</code></pre>\n<p>Explanations and definitions are given in detail in the sections below.</p>\n<h4>Setting up the Braid Generator</h4>\n<p>To create a Markov Chain, simply call <code>MarkovChain</code> with at least the <code>braidword</code> argument given. The <code>MarkovChain</code> initializor has default values of\nnine and ten for the <code>maxgen</code> and <code>maxlen</code> parameters, respectively. The speficied argument of <code>braidword</code> is the initial state of the Markov process; the state space consists of other braid words representating the same knot as the (closed) initial braid.</p>\n<pre><code>from braidgenerator import MarkovChain\nimport pandas as pd\n\nmc = MarkovChain(braidword=[1, 2, 3], maxgen=9, maxlen=10)\n\n</code></pre>\n<p>Alternatively, the Markov Chain can be initialized with a <code>BraidWord</code> instead of a list. The BraidWord is wrapped around a list (the <em>word</em>).</p>\n<pre><code>from braidgenerator import MarkovChain\nfrom braidgenerator import BraidWord\nimport pandas as pd\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n</code></pre>\n<blockquote>\n<p>Note that if the Markov Chain is initialized with a list instead of a BraidWord, it will be processed into a BraidWord behind the scenes.</p>\n</blockquote>\n<p>To create new braidreps it suffices to call the <code>model</code> method. The method <code>model</code> takes two parameters, <code>num_braidreps</code> and <code>msteps</code>, where <code>num_braidreps</code> is the number of braidreps that are to be generated and <code>msteps</code> is the number of Markov steps taken in each random walk that produces such a braidrep. Default values are one and 100, respectively. Markov chain steps are comprised of braid relations and ``Markov moves\" (in the sense of moves on closed braids).</p>\n<pre><code>mc.model(num_braidreps=10, msteps=50)\n</code></pre>\n<p>Once the modelling is complete, the braidreps and/or logs can be accessed via the following getter methods:</p>\n<ul>\n<li><code>MarkovChain.aggregate</code></li>\n<li><code>MarkovChain.logs</code></li>\n<li><code>MarkovChain.braidreps</code></li>\n<li><code>MarkovChain.topandas</code></li>\n<li><code>MarkovChain.tocsv</code></li>\n<li><code>MarkovChain.totxt</code></li>\n</ul>\n<h4><code>MarkovChain.aggregate</code></h4>\n<p>The <code>aggregate</code> method will return a dictionary with two keys: <em>braidreps</em> and <em>logs</em>, whereby <em>braidreps</em> is a list that contains the generated braidreps and <em>logs</em> is a list that contains the relevant Markov steps per iteration and if they were successful or not.</p>\n<blockquote>\n<p>This aggregate dictionary is mainly a container for the relevant data and while this getter method is available, it is not recommended for retrieving the data. Better alternative methods exist for this.</p>\n</blockquote>\n<pre><code>agg = mc.aggregate()\n\nagg\n\n&gt; {'braidreps': [], 'logs': []}\n</code></pre>\n<h4><code>MarkovChain.logs</code></h4>\n<p>The <code>logs</code> method returns only the logs in the list format. Each element of the log is itself a dictionary that represents all the Markov steps for each braidrep created. Thus, the size of <em>braidreps</em> and <em>logs</em> will be the same, but each entry will contain a larger set of logs. The example below shows a MarkovChain's logs with <code>num_braidreps=1</code> and <code>msteps=5</code></p>\n<pre><code>logs = mc.logs()\n\nlogs[0]\n\n&gt; {0: 'MoveType: 5, Attempted stabilize: stabilize Succeeded.',\n1: 'MoveType: 0, Attempted conjugate: conjugate Succeeded.',\n2: 'MoveType: 6, Attempted destabilize: destabilize Failed.',\n3: 'MoveType: 3, Attempted transpose: transpose Failed.',\n4: 'MoveType: 4, Attempted flip: flip Failed.'}\n</code></pre>\n<h4><code>MarkovChain.braidreps</code></h4>\n<p>The <code>braidreps</code> method will return the list with the generated braidreps. This method takes an optional parameter <code>as_word</code> which is set to <code>False</code> by default. If left as <code>False</code> then it will return a list of BraidWords, otherwise it will return a list of words (i.e. of type list).</p>\n<pre><code># As BraidWords with as_word set to False (default)\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\nbraidreps_asBraidWord = mc.braidreps()\n\nbraidreps_asBraidWord\n\n&gt; [&lt;braidword.BraidWord at 0x114dbe7b8&gt;,\n &lt;braidword.BraidWord at 0x114dbe7f0&gt;,\n &lt;braidword.BraidWord at 0x114dbe588&gt;]\n</code></pre>\n<pre><code># As words with as_word set to True\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\nbraidreps_asword = mc.braidreps(as_word=True)\n\nbraidreps_asword\n\n&gt; [[1, 2, 3], [2, 3, 1], [1, 2]]\n</code></pre>\n<blockquote>\n<p>Note that the braid that was fed into the model is not included. The first word of the second example above is a coincidence resulting from one successful destabilize and one successful stabilize.</p>\n</blockquote>\n<h4><code>MarkovChain.topandas</code></h4>\n<p>The logs and braidreps can be most easily accessed via the <code>topandas</code> method. To use it, simply import <em>pandas</em> into the script and call the <code>topandas</code> method. The method takes one optional argument, <code>only_braidreps</code>, which is set to <code>False</code> by defualt. If set to <code>True</code> then the resulting dataframe will only include the braidreps in word form. Otherwise, each entry will comprise of both the braidrep and the logs associated with it.</p>\n<pre><code># only_braidreps set to False (default)\nimport pandas as pd\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\ndf = mc.topandas()\ndf.columns\n\n&gt; Index(['braidreps', 'Logs'], dtype='object')\n</code></pre>\n<pre><code># only_braidreps set to True\nimport pandas as pd\n\nmc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\ndf = mc.topandas(only_braidreps=True)\ndf.columns\n\n&gt; Index(['braidreps'], dtype='object')\n</code></pre>\n<h4><code>MarkovChain.tocsv</code></h4>\n<p>The <code>tocsv</code> method exports the dataframe to a .csv file. The parameters include <code>path_or_filename</code> and <code>only_braidreps</code>, respectively. Similar to the <code>topandas</code> method, <code>only_braidreps</code> is set to <code>False</code> by default. The <code>path_or_filename</code> parameter is more interesting. If a path is not specified, the method will export the requested information to the current directory with either the name <em>braidreps.csv</em>\nor <em>braidreps_and_Logs.csv</em>, which it will implicitly interpret from the argument passed to <code>only_braidreps</code>.</p>\n<pre><code>mc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\npath = 'some/path/onyourpc.csv'\nmc.tocsv(path_or_filename=path, only_braidreps=False)\n</code></pre>\n<h4><code>MarkovChain.totxt</code></h4>\n<p>The <code>totxt</code> method is similar to the <code>topandas</code> and <code>tocsv</code> difference being that it exports the data to a <em>.txt</em> file in the following format:</p>\n<pre><code>braidrep[1]\n.\n.\n.\nbraidrep[n]\n\nlog[1]\n.\n.\n.\nlog[n]\n</code></pre>\n<p>As is with to <code>tocsv</code>, the <code>totxt</code> has the two parameters\n<code>path_or_filename</code> and <code>only_braidreps</code>, respectively.</p>\n<h3>Clearing the model and setting a new BraidWord</h3>\n<p>If it is desired to use the same model to create a new set of isomoprhs, the <code>clear_model</code> method is required. This method clears the <em>braidagg</em> container.</p>\n<pre><code>mc = MarkovChain(braidword=BraidWord([1, 2, 3]), maxgen=9, maxlen=10)\n\nmc.model(num_braidreps=3, msteps=5)\n\nmc.clear_model()\n\nmc.aggregate()\n\n&gt; {'braidreps': [], 'logs': []}\n</code></pre>\n<blockquote>\n<p>Note that if not changed, the subsequent BraidWord will have been mutated. This functionality is left in as it may seem desirable for some situations and is simple enough to undo (i.e. replace the BraidWord with the <code>new_braidword</code> method).</p>\n</blockquote>\n<p>In the event that it is desirable to set a new <em>BraidWord</em> into an already existing method, the <code>new_braidword</code> method can be used. A list or <code>BraidWord</code> object can be passed as an argument.</p>\n<pre><code>mc.new_braidword([1, 1, 2])\n</code></pre>\n<pre><code>mc.new_braidword(BraidWord([1, 2, 3]))\n</code></pre>\n<blockquote>\n<p>As is the case with the initializor, if a list is passed in as an argument it will be converted to a BraidWord behind the scenes.</p>\n</blockquote>\n<h3>Bonus BraidWord functionality</h3>\n<h4><code>crossing_change</code></h4>\n<p>The <code>crossing_change</code> method performs a crossing change on a BraidWord. That is, it returns a new BraidWord whereby\nthe generator at a specified index is inverted.</p>\n<p>The resulting index can be set randomly with <code>random_index</code> set to <code>True</code>, or it can be set manually by setting <code>random_index=False</code> and assigning <code>index</code> with an integer value between zero and the length of the word of the BraidWord.</p>\n<pre><code>from braidgenerator import BraidWord\n\nbraidword = BraidWord([1, 2, 3])\n\n# Randomly set generator to be inverted\nrandom_newbraidword = braidword.crossing_change(random_index=True)\n\n# Manually set generator to be inverted\nmanual_newbraidword = braidword.crossing_change(random_index=False, index=1)\n\nrandom_newbraidword.word\n&gt;&gt;&gt; [1, 2, -3]\n\nmanual_newbraidword.word\n&gt;&gt;&gt; [1, -2, 3]\n</code></pre>\n<h4><code>resolution</code></h4>\n<p>The <code>resolution</code> method performs a resolution on a BraidWord. That is, it returns a new BraidWord whereby\nthe generator at a specified index is removed and the new BraidWord's length is decreased by one.</p>\n<p>The resulting index can be set randomly with <code>random_index</code> set to <code>True</code>, or it can be set manually by setting <code>random_index=False</code> and assigning <code>index</code> with an integer value between zero and the length of the word of the BraidWord.</p>\n<pre><code>from braidgenerator import BraidWord\n\nbraidword = BraidWord([1, 2, 3])\n\n# Randomly set generator to be removed\nrandom_newbraidword = braidword.resolution(random_index=True)\n\n# Manually set generator to be removed\nmanual_newbraidword = braidword.resolution(random_index=False, index=1)\n\nrandom_newbraidword.word\n&gt;&gt;&gt; [2, 3]\n\nmanual_newbraidword.word\n&gt;&gt;&gt; [1, 3]\n</code></pre>\n<h2>Running the tests</h2>\n<p>Tests for these scripts are included in the github repository under the paths shown below.</p>\n<pre><code>.\n|\n\u2514\u2500\u2500\u2500tests\n        test_braidword.py\n        test_markovchain.py\n</code></pre>\n<h3>Breakdown of tests</h3>\n<p>The given tests use Pythons UnitTest package for testing.\n<strong>test_braidword.py</strong> contains over 350 lines of tests with 30+ test cases (at the time of writting this readme). The test cases contain suites that test for initialization, boolean helper functions (such as <code>canDestabilize</code>, <code>canFlip</code>, etc...), and the <strong>BraidWord</strong> methods (such as <code>Destabilize</code>, <code>Flip</code>, etc...). Examples of <strong>test_braidword.py</strong> include:</p>\n<pre><code>def test_init_pathfail_0(self):\n    '''\n    Should raise TypeError if initword\n    is not a list (args)\n    '''\n    with self.assertRaises(TypeError) as te:\n        bw = BraidWord(1)\n</code></pre>\n<pre><code>def test_canCancel_pathfail(self):\n    \"\"\"Should return False when adjacent\n    generators are not inverses of one other\"\"\"\n    bw = BraidWord([1, 2, 3, -3])\n    # Execution path False\n    self.assertFalse(bw.canCancel(0))\n</code></pre>\n<pre><code>def test_cancel_pathsuccess(self):\n    \"\"\"Should successfully cancel gen @idx 3\n    and should modify word\"\"\"\n    bw = BraidWord([-1, 2, 3, 1])\n    # Execution path True\n    self.assertTrue(bw.cancel(3))\n    # Word modification\n    self.assertEqual(bw.word, [2, 3])\n</code></pre>\n<p><strong>test_markovchain.py</strong> contains roughly 200 lines of tests with 18+ test cases (at the time of writing this readme). The test cases contain suites that test mainly for initialization and that containers, such as <em>logs</em>, <em>braidrepisms</em>, and <em>braidagg</em>, vis-a-vis the <code>aggregate</code>, <code>logs</code>, and <code>braidreps</code> methods, as well as exporting methods, such as <code>tocsv</code>, <code>topandas</code>, and <code>totxt</code>, are valid (i.e. not empty). The lack of automated tests for said script is due to the probabilistic nature of the results of the <code>model</code> method. Results for this method may be tested by hand or an auxiliary program, such as ``KnotPlot.\" Examples of <strong>test_markovchain.py</strong> include:</p>\n<pre><code>def test_init_pathfail_0(self):\n    \"\"\"Should throw error if BraidWord not given\"\"\"\n    with self.assertRaises(Exception) as te:\n        MarkovChain()\n</code></pre>\n<pre><code>def test_aggregate(self):\n    '''\n    Should return non-empty self.braidagg\n    '''\n    mc = MarkovChain(BraidWord([1, 2, 3]))\n    mc.model(num_braidreps=1, msteps=10)\n    # Check if non-empty\n    self.assertTrue(mc.aggregate())\n</code></pre>\n<pre><code>def test_logs(self):\n    '''\n    Should return non-empty self.braidagg.logs\n    '''\n    mc = MarkovChain(BraidWord([1, 2, 3]))\n    mc.model(num_braidreps=1, msteps=10)\n    # Check if non-empty\n    self.assertTrue(mc.logs())\n</code></pre>\n<blockquote>\n<p>BraidWord's <code>crossing_change</code> and <code>resolution</code> methods follow similar formats and can be viewed in the <code>tests\\test_braidword</code> module in the repository.</p>\n</blockquote>\n<h2>Documentation</h2>\n<p>For more information about methods and code fragments, please refer to the <a href=\"https://algebra8.github.io/braidgenerator_doc.github.io/\" rel=\"nofollow\">documentation</a>.</p>\n<h2>Contributing</h2>\n<p>Please read <a href=\"https://gist.github.com/PurpleBooth/b24679402957c63ec426\" rel=\"nofollow\">CONTRIBUTING.md</a> for details on our code of conduct, and the process for submitting pull requests to us.</p>\n<h2>Versioning</h2>\n<p>We use <a href=\"http://semver.org/\" rel=\"nofollow\">SemVer</a> for versioning. For the versions available, see the <a href=\"https://github.com/your/project/tags\" rel=\"nofollow\">tags on this repository</a>.</p>\n<h2>Authors</h2>\n<ul>\n<li><strong>Allison Moore</strong> - <em>Initial work</em> - <a href=\"https://github.com/allisonhmoore\" rel=\"nofollow\">allisonhmoore</a></li>\n<li><strong>Milad Michael Nasrollahi</strong> - <em>Initial work</em> - <a href=\"https://github.com/Algebra8\" rel=\"nofollow\">Algebra8</a></li>\n<li><strong>Shawn Witte</strong> - <em>Initial work</em> - <a href=\"https://github.com/Minirogue\" rel=\"nofollow\">Minirogue</a></li>\n</ul>\n\n<h2>License</h2>\n<p>This project is licensed under the MIT License - see the <a href=\"LICENSE.md\" rel=\"nofollow\">LICENSE.md</a> file for details.</p>\n<h2>Acknowledgements</h2>\n<p>This package makes use of <em>pandas</em> as a requirement. Please refer to the <a href=\"https://github.com/pandas-dev/pandas/blob/master/LICENSE\" rel=\"nofollow\"><em>pandas</em> license</a> for more information on their license.</p>\n<p>The CONTRIBUTING.md content was adapted from PurpleBooth's <a href=\"https://gist.github.com/PurpleBooth/b24679402957c63ec426\" rel=\"nofollow\">Good-CONTRIBUTING.md-template.md</a>.</p>\n\n          </div>"}, "last_serial": 5502624, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "c90c76cbcdebe910c8d18b59c779fdb6", "sha256": "ed78cc3e4d4b9d00ca07f4e17e1d7de90ef614bfcb80c778af6239fd32f1ec9c"}, "downloads": -1, "filename": "braidgenerator-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "c90c76cbcdebe910c8d18b59c779fdb6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15933, "upload_time": "2019-07-08T18:55:52", "upload_time_iso_8601": "2019-07-08T18:55:52.604526Z", "url": "https://files.pythonhosted.org/packages/fa/09/ed72f331abb8e2ea1fff19c45461aad995f25184c8969c47a72eb4c9001e/braidgenerator-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ba138f4e27a75a1b9c5073c14f0ae636", "sha256": "5926ee0e17d403f11789edb91fe234432800aa0c6a68838d38120b763174574c"}, "downloads": -1, "filename": "braidgenerator-1.0.0.tar.gz", "has_sig": false, "md5_digest": "ba138f4e27a75a1b9c5073c14f0ae636", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14235, "upload_time": "2019-07-08T18:55:55", "upload_time_iso_8601": "2019-07-08T18:55:55.098844Z", "url": "https://files.pythonhosted.org/packages/8a/16/517617856c1cb7ae6e28a9350d4f5829b338522196c6f03632eb516a763f/braidgenerator-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c90c76cbcdebe910c8d18b59c779fdb6", "sha256": "ed78cc3e4d4b9d00ca07f4e17e1d7de90ef614bfcb80c778af6239fd32f1ec9c"}, "downloads": -1, "filename": "braidgenerator-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "c90c76cbcdebe910c8d18b59c779fdb6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15933, "upload_time": "2019-07-08T18:55:52", "upload_time_iso_8601": "2019-07-08T18:55:52.604526Z", "url": "https://files.pythonhosted.org/packages/fa/09/ed72f331abb8e2ea1fff19c45461aad995f25184c8969c47a72eb4c9001e/braidgenerator-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ba138f4e27a75a1b9c5073c14f0ae636", "sha256": "5926ee0e17d403f11789edb91fe234432800aa0c6a68838d38120b763174574c"}, "downloads": -1, "filename": "braidgenerator-1.0.0.tar.gz", "has_sig": false, "md5_digest": "ba138f4e27a75a1b9c5073c14f0ae636", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14235, "upload_time": "2019-07-08T18:55:55", "upload_time_iso_8601": "2019-07-08T18:55:55.098844Z", "url": "https://files.pythonhosted.org/packages/8a/16/517617856c1cb7ae6e28a9350d4f5829b338522196c6f03632eb516a763f/braidgenerator-1.0.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:36:25 2020"}