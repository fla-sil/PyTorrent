{"info": {"author": "Chris Pressey", "author_email": "packages@catseye.tc", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Software Development :: Testing"], "description": "Falderal\n========\n\nVersion 0.13 \"Merchandise Mart\"\n\nThis is the reference distribution of Falderal, a file format for literate\ntest suites.  What sets Falderal apart from most other test frameworks is\nthat it recognizes that **your tests are for a functionality, not a particular\nimplementation of that functionality**.\n\nFalderal is particularly suited for:\n\n*   documenting programming languages with prose and examples\n*   testing multiple implementations of a programming language\n*   performing Test-Driven Language Design (TDLD)\n*   being embedded in Markdown documents\n\nFalderal in three words: \"Doctests for DSLs\".\n\nIf you're more interested in running the tools than learning about the format\nitself, skip down to [Implementation](#implementation).\n\nMotivation\n----------\n\nSay you have a programming language.  You probably have a document describing\nthe language.  That document probably includes examples.  Those examples are\nprobably intended to produce some kind of output.  That output is probably\nexpected to be a certain, predicted thing, and if it's not that thing, the\nimplementation is probably considered incorrect.\n\nSo why not write those examples in a format that can be run and tested?\n\nYou could write a bunch of standalone test sources, and store the output you\nexpect from them in a bunch of other files, and write a shell script that runs\neach program and `diff`s the output with the expected output.  But this is a\nlot of clutter \u2014 finding a particular example might not be so easy.  Each\ntest source exists in a void, not necessarily logically grouped with other,\nsimilar tests.  And any text you write describing a test needs to be in the\ncomment syntax of your programming language (if your programming language\nsupports comments) and is also detached from all the other test descriptions.\n\nYou could write unit tests in the unit test framework of your choice, but\nif your programming language has more than one implementation one day (and\nyou should really consider that possibility) then you might not be able to\nre-use it so easily for other implementations in other languages.\n\nIn a language like Python, you could write doctests, but that also ties your\ntests to one implementation of your language.  There can be awkward\nquoting issues with how you embed your test sources inside those embedded\nstrings that comprise your doctests, as well.\n\nOr... you could write a Markdown document with beautiful yet precise prose\ndescribing your wonderful language, alternating with example code (in the\nform of embedded Falderal tests) clarifying each of the points you are\nmaking; then you could use a Falderal-comprehending tool to run each of these\ntests against any implementation of your language which exists or will exist\nin the future.\n\n*And* you could even write this document *before* you even start implementing\nyour language; then when it is all clear \"on paper\", you have a target at\nwhich you can aim while writing your language.  As you implement more and more\nof it, more and more tests in your test suite will pass.  This is simply the\nidea behind Test-Driven Development (TDD) applied to language design, which we\nwill call Test-Driven Language Design (TDLD).\n\nFeatures of the Format\n----------------------\n\nFalderal is just a file format; it does not specify exactly what tools must\ndo with the tests they extract.  However, it is generally assumed that most\ntools will want to, at the very least,\n\n*   Run tests from one or more documents.\n*   Report the results, with some given level of detail.\n\nThere is, of course, a reference implementation which does both of these\nthings.  It is called py-falderal and it is written in Python 2.7.\n\nEach Falderal test is for some abstract _functionality_, and each\nfunctionality may have multiple concrete _implementations_.  Thus the same\ntests can be run multiple times, once for each implementation of the\nfunctionality they test.\n\nDirectives in the Falderal document may assign functionalities to tests,\nand may define implementations for given functionalities.  Implementations\nmay be defined outside of any document, as well.  Falderal defines one\ngeneral kind of implementation, implementation by Bourne shell command, but\nis not inherently restricted from supporting other kinds of implementations.\n\nInherent Limitations\n--------------------\n\nBeing tests, rather than proofs, Falderal tests cannot tell you that your\nimplementation of a language is correct.  If one or more tests fail, that's\nan indication that your implementation is not correct; but even if all tests\npass, you have no guarantee that the implementation doesn't do something\ncontrary to the spec in one of the infinite number of cases that you have not\nenumerated.\n\nThere is also no way to test that certain programs represent infinite loops,\nfor reasons that should be obvious.\n\nContents of this Distribution\n-----------------------------\n\nThis distribution contains:\n\n*   `doc` \u2014 contains documents about Falderal.  For the specification of\n    the file format, see\n    [`doc/Falderal_Literate_Test_Format.markdown`](doc/Falderal_Literate_Test_Format.markdown).\n    (Note that this specification should not be expected to remain stable\n    through the 0.x version series.)  There are other documents in there too.\n*   `bin/falderal` \u2014 the reference implementation of Falderal.\n    See \"Implementation\", below, for details.\n*   `script` \u2014 miscellaneous small tools intended to be used in tests.\n*   `src` \u2014 source code for py-falderal.\n*   `tests` \u2014 a set of tests for Falderal itself.  (Note that these are not\n    written in Falderal, as that would just be too confusing.)\n*   `HISTORY.markdown` \u2014 changelog for releases of Falderal.\n*   `TODO.markdown` \u2014 areas where Falderal and its implementations could be\n    improved.\n\nImplementation\n--------------\n\nThis distribution contains `falderal`, which is the reference implementation\nof Falderal, written in Python and sometimes referred to as \"py-falderal\".\n\nTo use it, you can clone this repository and run it as `bin/falderal`\nfrom the directory of your clone, or you can put the `bin` directory\non your executable search path, and run it as `falderal` anywhere.\n\nOr you can install it using `pip`:\n\n    pip install -e Falderal==0.13\n\n(Depending on your needs, you may wish to establish a virtual environment\nfirst.  Describing how to do so is outside the scope of this document.)\n\nThe implementation is (somewhat) documented in `doc/py-falderal.markdown`.\n\nDevelopment\n-----------\n\nThe git repository for the Falderal distribution can be found on GitHub at\n[https://github.com/catseye/Falderal](https://github.com/catseye/Falderal).\n\nOfficial release distfiles are available via the\n[Falderal project page](http://catseye.tc/node/Falderal) at\n[Cat's Eye Technologies](http://catseye.tc/).\n\nProjects using Falderal\n-----------------------\n\n*   [ALPACA](http://catseye.tc/node/ALPACA)\n*   [Castile](http://catseye.tc/node/Castile)\n*   [Equipage](http://catseye.tc/node/Equipage)\n*   [Exanoke](http://catseye.tc/node/Exanoke)\n*   [Flobnar](http://catseye.tc/node/Flobnar)\n*   [Hev](http://catseye.tc/node/Hev)\n*   [Iphigeneia](http://catseye.tc/node/Iphigeneia)\n*   [Madison](http://catseye.tc/node/Madison)\n*   [Pail](http://catseye.tc/node/Pail)\n*   [Pixley](http://catseye.tc/node/Pixley)\n*   [PL-{GOTO}.NET](http://catseye.tc/node/PL-{GOTO}.NET)\n*   [Quylthulg](http://catseye.tc/node/Quylthulg)\n*   [Robin](http://catseye.tc/node/Robin)\n*   [Samovar](http://catseye.tc/node/Samovar)\n*   [SixtyPical](http://catseye.tc/node/SixtyPical)\n*   [Tamsin](http://catseye.tc/node/Tamsin)\n*   [Velo](http://catseye.tc/node/Velo)\n*   [Yolk](http://catseye.tc/node/Yolk)\n*   [Xoomonk](http://catseye.tc/node/Xoomonk)\n\nXoomonk, Madison, Velo, and Exanoke are good examples of how a literate\ntest suite can be useful in both describing a programming language through\nexamples and testing that an implementation of the language does not violate\nthe language specification.  They are, in fact, exercises in Test-Driven\nLanguage Design (TDLD), where the tests were written as part of designing the\nlanguage, before any attempt at implementation; the others are more like\ntraditional test suites, written after-the-fact.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://catseye.tc/node/Falderal", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "Falderal", "package_url": "https://pypi.org/project/Falderal/", "platform": "", "project_url": "https://pypi.org/project/Falderal/", "project_urls": {"Homepage": "https://catseye.tc/node/Falderal"}, "release_url": "https://pypi.org/project/Falderal/0.13/", "requires_dist": null, "requires_python": "", "summary": "Definition of, and tools for using, the Falderal literate testing format", "version": "0.13", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Falderal</h1>\n<p>Version 0.13 \"Merchandise Mart\"</p>\n<p>This is the reference distribution of Falderal, a file format for literate\ntest suites.  What sets Falderal apart from most other test frameworks is\nthat it recognizes that <strong>your tests are for a functionality, not a particular\nimplementation of that functionality</strong>.</p>\n<p>Falderal is particularly suited for:</p>\n<ul>\n<li>documenting programming languages with prose and examples</li>\n<li>testing multiple implementations of a programming language</li>\n<li>performing Test-Driven Language Design (TDLD)</li>\n<li>being embedded in Markdown documents</li>\n</ul>\n<p>Falderal in three words: \"Doctests for DSLs\".</p>\n<p>If you're more interested in running the tools than learning about the format\nitself, skip down to <a href=\"#implementation\" rel=\"nofollow\">Implementation</a>.</p>\n<h2>Motivation</h2>\n<p>Say you have a programming language.  You probably have a document describing\nthe language.  That document probably includes examples.  Those examples are\nprobably intended to produce some kind of output.  That output is probably\nexpected to be a certain, predicted thing, and if it's not that thing, the\nimplementation is probably considered incorrect.</p>\n<p>So why not write those examples in a format that can be run and tested?</p>\n<p>You could write a bunch of standalone test sources, and store the output you\nexpect from them in a bunch of other files, and write a shell script that runs\neach program and <code>diff</code>s the output with the expected output.  But this is a\nlot of clutter \u2014 finding a particular example might not be so easy.  Each\ntest source exists in a void, not necessarily logically grouped with other,\nsimilar tests.  And any text you write describing a test needs to be in the\ncomment syntax of your programming language (if your programming language\nsupports comments) and is also detached from all the other test descriptions.</p>\n<p>You could write unit tests in the unit test framework of your choice, but\nif your programming language has more than one implementation one day (and\nyou should really consider that possibility) then you might not be able to\nre-use it so easily for other implementations in other languages.</p>\n<p>In a language like Python, you could write doctests, but that also ties your\ntests to one implementation of your language.  There can be awkward\nquoting issues with how you embed your test sources inside those embedded\nstrings that comprise your doctests, as well.</p>\n<p>Or... you could write a Markdown document with beautiful yet precise prose\ndescribing your wonderful language, alternating with example code (in the\nform of embedded Falderal tests) clarifying each of the points you are\nmaking; then you could use a Falderal-comprehending tool to run each of these\ntests against any implementation of your language which exists or will exist\nin the future.</p>\n<p><em>And</em> you could even write this document <em>before</em> you even start implementing\nyour language; then when it is all clear \"on paper\", you have a target at\nwhich you can aim while writing your language.  As you implement more and more\nof it, more and more tests in your test suite will pass.  This is simply the\nidea behind Test-Driven Development (TDD) applied to language design, which we\nwill call Test-Driven Language Design (TDLD).</p>\n<h2>Features of the Format</h2>\n<p>Falderal is just a file format; it does not specify exactly what tools must\ndo with the tests they extract.  However, it is generally assumed that most\ntools will want to, at the very least,</p>\n<ul>\n<li>Run tests from one or more documents.</li>\n<li>Report the results, with some given level of detail.</li>\n</ul>\n<p>There is, of course, a reference implementation which does both of these\nthings.  It is called py-falderal and it is written in Python 2.7.</p>\n<p>Each Falderal test is for some abstract <em>functionality</em>, and each\nfunctionality may have multiple concrete <em>implementations</em>.  Thus the same\ntests can be run multiple times, once for each implementation of the\nfunctionality they test.</p>\n<p>Directives in the Falderal document may assign functionalities to tests,\nand may define implementations for given functionalities.  Implementations\nmay be defined outside of any document, as well.  Falderal defines one\ngeneral kind of implementation, implementation by Bourne shell command, but\nis not inherently restricted from supporting other kinds of implementations.</p>\n<h2>Inherent Limitations</h2>\n<p>Being tests, rather than proofs, Falderal tests cannot tell you that your\nimplementation of a language is correct.  If one or more tests fail, that's\nan indication that your implementation is not correct; but even if all tests\npass, you have no guarantee that the implementation doesn't do something\ncontrary to the spec in one of the infinite number of cases that you have not\nenumerated.</p>\n<p>There is also no way to test that certain programs represent infinite loops,\nfor reasons that should be obvious.</p>\n<h2>Contents of this Distribution</h2>\n<p>This distribution contains:</p>\n<ul>\n<li><code>doc</code> \u2014 contains documents about Falderal.  For the specification of\nthe file format, see\n<a href=\"doc/Falderal_Literate_Test_Format.markdown\" rel=\"nofollow\"><code>doc/Falderal_Literate_Test_Format.markdown</code></a>.\n(Note that this specification should not be expected to remain stable\nthrough the 0.x version series.)  There are other documents in there too.</li>\n<li><code>bin/falderal</code> \u2014 the reference implementation of Falderal.\nSee \"Implementation\", below, for details.</li>\n<li><code>script</code> \u2014 miscellaneous small tools intended to be used in tests.</li>\n<li><code>src</code> \u2014 source code for py-falderal.</li>\n<li><code>tests</code> \u2014 a set of tests for Falderal itself.  (Note that these are not\nwritten in Falderal, as that would just be too confusing.)</li>\n<li><code>HISTORY.markdown</code> \u2014 changelog for releases of Falderal.</li>\n<li><code>TODO.markdown</code> \u2014 areas where Falderal and its implementations could be\nimproved.</li>\n</ul>\n<h2>Implementation</h2>\n<p>This distribution contains <code>falderal</code>, which is the reference implementation\nof Falderal, written in Python and sometimes referred to as \"py-falderal\".</p>\n<p>To use it, you can clone this repository and run it as <code>bin/falderal</code>\nfrom the directory of your clone, or you can put the <code>bin</code> directory\non your executable search path, and run it as <code>falderal</code> anywhere.</p>\n<p>Or you can install it using <code>pip</code>:</p>\n<pre><code>pip install -e Falderal==0.13\n</code></pre>\n<p>(Depending on your needs, you may wish to establish a virtual environment\nfirst.  Describing how to do so is outside the scope of this document.)</p>\n<p>The implementation is (somewhat) documented in <code>doc/py-falderal.markdown</code>.</p>\n<h2>Development</h2>\n<p>The git repository for the Falderal distribution can be found on GitHub at\n<a href=\"https://github.com/catseye/Falderal\" rel=\"nofollow\">https://github.com/catseye/Falderal</a>.</p>\n<p>Official release distfiles are available via the\n<a href=\"http://catseye.tc/node/Falderal\" rel=\"nofollow\">Falderal project page</a> at\n<a href=\"http://catseye.tc/\" rel=\"nofollow\">Cat's Eye Technologies</a>.</p>\n<h2>Projects using Falderal</h2>\n<ul>\n<li><a href=\"http://catseye.tc/node/ALPACA\" rel=\"nofollow\">ALPACA</a></li>\n<li><a href=\"http://catseye.tc/node/Castile\" rel=\"nofollow\">Castile</a></li>\n<li><a href=\"http://catseye.tc/node/Equipage\" rel=\"nofollow\">Equipage</a></li>\n<li><a href=\"http://catseye.tc/node/Exanoke\" rel=\"nofollow\">Exanoke</a></li>\n<li><a href=\"http://catseye.tc/node/Flobnar\" rel=\"nofollow\">Flobnar</a></li>\n<li><a href=\"http://catseye.tc/node/Hev\" rel=\"nofollow\">Hev</a></li>\n<li><a href=\"http://catseye.tc/node/Iphigeneia\" rel=\"nofollow\">Iphigeneia</a></li>\n<li><a href=\"http://catseye.tc/node/Madison\" rel=\"nofollow\">Madison</a></li>\n<li><a href=\"http://catseye.tc/node/Pail\" rel=\"nofollow\">Pail</a></li>\n<li><a href=\"http://catseye.tc/node/Pixley\" rel=\"nofollow\">Pixley</a></li>\n<li><a href=\"http://catseye.tc/node/PL-%7BGOTO%7D.NET\" rel=\"nofollow\">PL-{GOTO}.NET</a></li>\n<li><a href=\"http://catseye.tc/node/Quylthulg\" rel=\"nofollow\">Quylthulg</a></li>\n<li><a href=\"http://catseye.tc/node/Robin\" rel=\"nofollow\">Robin</a></li>\n<li><a href=\"http://catseye.tc/node/Samovar\" rel=\"nofollow\">Samovar</a></li>\n<li><a href=\"http://catseye.tc/node/SixtyPical\" rel=\"nofollow\">SixtyPical</a></li>\n<li><a href=\"http://catseye.tc/node/Tamsin\" rel=\"nofollow\">Tamsin</a></li>\n<li><a href=\"http://catseye.tc/node/Velo\" rel=\"nofollow\">Velo</a></li>\n<li><a href=\"http://catseye.tc/node/Yolk\" rel=\"nofollow\">Yolk</a></li>\n<li><a href=\"http://catseye.tc/node/Xoomonk\" rel=\"nofollow\">Xoomonk</a></li>\n</ul>\n<p>Xoomonk, Madison, Velo, and Exanoke are good examples of how a literate\ntest suite can be useful in both describing a programming language through\nexamples and testing that an implementation of the language does not violate\nthe language specification.  They are, in fact, exercises in Test-Driven\nLanguage Design (TDLD), where the tests were written as part of designing the\nlanguage, before any attempt at implementation; the others are more like\ntraditional test suites, written after-the-fact.</p>\n\n          </div>"}, "last_serial": 5971119, "releases": {"0.13": [{"comment_text": "", "digests": {"md5": "2af95757b7f56f7725e18e13bd405487", "sha256": "330d16012c567f10b63a7c74fef6ff1d1a98b3e0afb78d363dc66706702279d8"}, "downloads": -1, "filename": "Falderal-0.13-py3-none-any.whl", "has_sig": false, "md5_digest": "2af95757b7f56f7725e18e13bd405487", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16975, "upload_time": "2019-10-14T11:49:02", "upload_time_iso_8601": "2019-10-14T11:49:02.438778Z", "url": "https://files.pythonhosted.org/packages/c8/b7/36e502a3ffafaf2a091facc4f50aad4d4b98c41c4cebcaf814957f354435/Falderal-0.13-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "42c400e387f66e7f3efd61005a713b50", "sha256": "56e996707f502f32b7904b9a5f924856be7c7e048cb3f52bd2d1b40642fad3de"}, "downloads": -1, "filename": "Falderal-0.13.tar.gz", "has_sig": false, "md5_digest": "42c400e387f66e7f3efd61005a713b50", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13872, "upload_time": "2019-10-14T11:49:05", "upload_time_iso_8601": "2019-10-14T11:49:05.145715Z", "url": "https://files.pythonhosted.org/packages/85/12/46764fced7780d9b382f23a5a7713bc2809733621e3cd73897a874a48be8/Falderal-0.13.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2af95757b7f56f7725e18e13bd405487", "sha256": "330d16012c567f10b63a7c74fef6ff1d1a98b3e0afb78d363dc66706702279d8"}, "downloads": -1, "filename": "Falderal-0.13-py3-none-any.whl", "has_sig": false, "md5_digest": "2af95757b7f56f7725e18e13bd405487", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16975, "upload_time": "2019-10-14T11:49:02", "upload_time_iso_8601": "2019-10-14T11:49:02.438778Z", "url": "https://files.pythonhosted.org/packages/c8/b7/36e502a3ffafaf2a091facc4f50aad4d4b98c41c4cebcaf814957f354435/Falderal-0.13-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "42c400e387f66e7f3efd61005a713b50", "sha256": "56e996707f502f32b7904b9a5f924856be7c7e048cb3f52bd2d1b40642fad3de"}, "downloads": -1, "filename": "Falderal-0.13.tar.gz", "has_sig": false, "md5_digest": "42c400e387f66e7f3efd61005a713b50", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13872, "upload_time": "2019-10-14T11:49:05", "upload_time_iso_8601": "2019-10-14T11:49:05.145715Z", "url": "https://files.pythonhosted.org/packages/85/12/46764fced7780d9b382f23a5a7713bc2809733621e3cd73897a874a48be8/Falderal-0.13.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:43:50 2020"}