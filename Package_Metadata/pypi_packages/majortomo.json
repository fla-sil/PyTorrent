{"info": {"author": "Shahar Evron", "author_email": "shahar@shoppimon.com", "bugtrack_url": null, "classifiers": [], "description": "Majortomo\n=========\n*Majortomo* is a pure-Python [ZeroMQ MDP 0.2](https://rfc.zeromq.org/spec:18/MDP/)\n(\"Majordomo\") implementation. It provides a ready-to-use MDP Service Broker,\nas well as a Python 2.7 / 3.5+ library for implementing MDP clients and workers\nwith just a few lines of code. \n\nMDP / Majordomo is a protocol for implementing a highly scalable, lightweight \nservice oriented messaging on top of [ZeroMQ](https://zeromq.org). It is very \nuseful, for example, for facilitating communication between different\nmicro-services in a scalable, robust and fault-tolerant manner. \n\n[![Build Status](https://travis-ci.org/shoppimon/majortomo.svg?branch=master)](https://travis-ci.org/shoppimon/majortomo)\n[![Documentation Status](https://readthedocs.org/projects/majortomo/badge/?version=latest)](https://majortomo.readthedocs.io/en/latest/?badge=latest)\n\nInstallation\n------------\n\nQuick Start\n-----------\n\n### Running the Broker\n\n### Exposing a Service using an MDP Worker\n\n### Consuming a Service using an MDP Client\n\nFull Documentation\n------------------\nProject documentation is available here: https://majortomo.readthedocs.io/en/latest/\n\nUsage\n-----\n### Running the Broker\nIn most cases the MDP broker can be used as-is, simply by running it with the \nright command line arguments. You can do this by building and running it using \nDocker:\n\n    # Build the Docker image\n    $ docker build -t shoppimon/mdp-broker -f mdp-broker/Dockerfile .\n\n    # Run the broker from Docker\n    $ docker run --rm -ti shoppimon/mdp-broker -b tcp://0.0.0.0:5555 --verbose\n\nYou can run the broker with `--help` for more command line options. \n\nOf course, you can also run the broker directly using Python 3.5 and up:\n\n    $ python -m majortomo.broker --help\n\nNote that this requires setting up a virtual environemnt with the project \ndependencies, which is described below. \n\n### Installing & Using the Client and Worker modules\nTBD\n\n### Using the Client class\nSee `majortomo.echo` for a sample client implementation.\n\nThe `Client` class should normally be used directly (without subclassing) to\nsend requests to the broker (and workers). \n\n##### Opening and closing client connections\nWhile a lower-level API is available (through the `connect`, `is_connected`, \nand `close`), managing the connection to the broker is easiest done through\nthe context manager protocol:\n\n```python\nwith Client(broker_url='tcp://127.0.0.1:5555') as client:\n    client.send(b'my-service', b'frame1', b'frame2')\n    reply = client.recv_all_as_list(timeout=10.0)\n```\n\nThe example above takes care of opening and closing the ZeroMQ socket as \nneeded.\n\n**NOTE**: ZeroMQ takes care of re-creating dropped TCP connections and waiting\nfor not-yet-bound peers automatically. \n\n##### Sending Requests & Receiving Replies\nTo send a request, use the `send` method:\n\n```python\nclient.send(service_name, frame1, frame2, frame3)\n```\n\nThis method takes the service name (as `bytes`) as a first argument. \nAll other arguments are sent as message frames - the MDP protocol supports\nsending requests with more than one frame to the broker. The contents of these\nframes is application dependent and is up to you.\n\nOnce a request has been sent, you *must* read the entire reply send back from\nthe broker (or close the connection to the broker and reconnect if you wish\nto retry). \n\nThere are multiple methods for reading replies, depending on your needs: \n\n**`recv_part(timeout: float=None) -> Optional[List[bytes]]`**\n\nReceive one reply part from the broker (a reply part is a list of bytes, as it\nmay contain multiple ZeroMQ frames). \n\nIf no more parts are available (i.e. the last part was a `FINAL` reply), will\nreturn `None`.\n\n**`recv_all(timeout: float=None) -> Iterable[List[bytes]]`**\n\nReturns an iterator that yields each message part as it is received, and exists\nafter the `FINAL` reply has been received:\n\n```python\nfor part in client.recv_all(timeout=5.0): \n    do_something_with_reply_part(part)\n```\n\n**Note**: the `timeout` parameter in this case relates to the time between reply\nchunks, not to the time it would take to receive the entire reply until `FINAL`. \n\n**`recv_all_as_list(timeout: float=None) -> List[bytes]`**\n\nReturns a flat list of all message frames from all reply parts. Regardless of \nhow many `PARTIAL` replies were sent by the worker until the `FINAL` reply, \nthis method will always return a single one-dimentional list of `bytes` with\nmessage frames.\n\n##### Timeouts & Retrying\nAll `recv_*` methods of the client receive a `timeout` argument which should\nspecify the number of seconds to wait for a response (a `float` is expected \nso you can specify second fractions as well). If no `timeout` is specified, \nthe function will wait forever. \n\nOnce `recv_*` times out, a `majortomo.error.Timeout` will\nbe raised. It is sometimes useful to catch this exception and retry the \noperation after reconnecting to the broker:\n\n```python\nwhile True:\n    with Client(broker_url='tcp://127.0.0.1:5555') as client:\n        try:\n\n            client.send(b'my-service', b'frame1', b'frame2')\n            reply = client.recv_all_as_list(timeout=10.0)\n            break\n        except majortomo.error.Timeout:\n            logging.warning(\"Timed out waiting for a reply from broker, reconnecting\")\n            time.sleep(1.0)\n            continue\n```\n\nOr, if you do not wish to rely on the context manager for reconnecting (e.g. if\nthe context is managed in an outer scope):\n\n```python\n# Here `client` is passed from an outer scope\nwhile True:\n    try:\n        client.send(b'my-service', b'frame1', b'frame2')\n        reply = client.recv_all_as_list(timeout=10.0)\n        break\n    except majortomo.error.Timeout:\n        logging.warning(\"Timed out waiting for a reply from broker, reconnecting\")\n        time.sleep(1.0)\n        client.connect(reconnect=True)\n        continue\n```\n\nEven better, it is advisable to manage the number of retries and the `sleep` time\nbetween them using some kind of exponential backoff & retry library, for example\n[backoff](https://pypi.org/project/backoff/) or [redo](https://pypi.org/project/redo)\n\n#### Implementing MDP Workers\nSee `majortomo.echo` for a sample worker implementation\n\nMore details TBD\n\nCopyright & Credits\n-------------------\nMajortomo was created and is maintained by the [Shoppimon](https://www.shoppimon.com) \nteam, and is distributed under the terms of the Apache 2.0 License \n(see `LICENSE`).\n\nMajortomo is (C) Copyright 2018 Shoppimon LTD. \n\n\u00d8MQ is Copyright (c) 2007-2014 iMatix Corporation and Contributors.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/shoppimon/majortomo", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "majortomo", "package_url": "https://pypi.org/project/majortomo/", "platform": "", "project_url": "https://pypi.org/project/majortomo/", "project_urls": {"Homepage": "https://github.com/shoppimon/majortomo"}, "release_url": "https://pypi.org/project/majortomo/0.1.0/", "requires_dist": ["figcan", "pyyaml", "pyzmq", "typing ; python_version < \"3.0\""], "requires_python": "", "summary": "Majortomo - ZMQ MDP 0.2 (Majordomo) Python Implementation", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Majortomo</h1>\n<p><em>Majortomo</em> is a pure-Python <a href=\"https://rfc.zeromq.org/spec:18/MDP/\" rel=\"nofollow\">ZeroMQ MDP 0.2</a>\n(\"Majordomo\") implementation. It provides a ready-to-use MDP Service Broker,\nas well as a Python 2.7 / 3.5+ library for implementing MDP clients and workers\nwith just a few lines of code.</p>\n<p>MDP / Majordomo is a protocol for implementing a highly scalable, lightweight\nservice oriented messaging on top of <a href=\"https://zeromq.org\" rel=\"nofollow\">ZeroMQ</a>. It is very\nuseful, for example, for facilitating communication between different\nmicro-services in a scalable, robust and fault-tolerant manner.</p>\n<p><a href=\"https://travis-ci.org/shoppimon/majortomo\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a9e2eaec72cab77d1b7fd1b2930025981ce4e5af/68747470733a2f2f7472617669732d63692e6f72672f73686f7070696d6f6e2f6d616a6f72746f6d6f2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://majortomo.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e0481f88ced4097caa1a3dc68ade92df46bf1f5c/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6d616a6f72746f6d6f2f62616467652f3f76657273696f6e3d6c6174657374\"></a></p>\n<h2>Installation</h2>\n<h2>Quick Start</h2>\n<h3>Running the Broker</h3>\n<h3>Exposing a Service using an MDP Worker</h3>\n<h3>Consuming a Service using an MDP Client</h3>\n<h2>Full Documentation</h2>\n<p>Project documentation is available here: <a href=\"https://majortomo.readthedocs.io/en/latest/\" rel=\"nofollow\">https://majortomo.readthedocs.io/en/latest/</a></p>\n<h2>Usage</h2>\n<h3>Running the Broker</h3>\n<p>In most cases the MDP broker can be used as-is, simply by running it with the\nright command line arguments. You can do this by building and running it using\nDocker:</p>\n<pre><code># Build the Docker image\n$ docker build -t shoppimon/mdp-broker -f mdp-broker/Dockerfile .\n\n# Run the broker from Docker\n$ docker run --rm -ti shoppimon/mdp-broker -b tcp://0.0.0.0:5555 --verbose\n</code></pre>\n<p>You can run the broker with <code>--help</code> for more command line options.</p>\n<p>Of course, you can also run the broker directly using Python 3.5 and up:</p>\n<pre><code>$ python -m majortomo.broker --help\n</code></pre>\n<p>Note that this requires setting up a virtual environemnt with the project\ndependencies, which is described below.</p>\n<h3>Installing &amp; Using the Client and Worker modules</h3>\n<p>TBD</p>\n<h3>Using the Client class</h3>\n<p>See <code>majortomo.echo</code> for a sample client implementation.</p>\n<p>The <code>Client</code> class should normally be used directly (without subclassing) to\nsend requests to the broker (and workers).</p>\n<h5>Opening and closing client connections</h5>\n<p>While a lower-level API is available (through the <code>connect</code>, <code>is_connected</code>,\nand <code>close</code>), managing the connection to the broker is easiest done through\nthe context manager protocol:</p>\n<pre><span class=\"k\">with</span> <span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"n\">broker_url</span><span class=\"o\">=</span><span class=\"s1\">'tcp://127.0.0.1:5555'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">client</span><span class=\"p\">:</span>\n    <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'my-service'</span><span class=\"p\">,</span> <span class=\"sa\">b</span><span class=\"s1\">'frame1'</span><span class=\"p\">,</span> <span class=\"sa\">b</span><span class=\"s1\">'frame2'</span><span class=\"p\">)</span>\n    <span class=\"n\">reply</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">recv_all_as_list</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mf\">10.0</span><span class=\"p\">)</span>\n</pre>\n<p>The example above takes care of opening and closing the ZeroMQ socket as\nneeded.</p>\n<p><strong>NOTE</strong>: ZeroMQ takes care of re-creating dropped TCP connections and waiting\nfor not-yet-bound peers automatically.</p>\n<h5>Sending Requests &amp; Receiving Replies</h5>\n<p>To send a request, use the <code>send</code> method:</p>\n<pre><span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">service_name</span><span class=\"p\">,</span> <span class=\"n\">frame1</span><span class=\"p\">,</span> <span class=\"n\">frame2</span><span class=\"p\">,</span> <span class=\"n\">frame3</span><span class=\"p\">)</span>\n</pre>\n<p>This method takes the service name (as <code>bytes</code>) as a first argument.\nAll other arguments are sent as message frames - the MDP protocol supports\nsending requests with more than one frame to the broker. The contents of these\nframes is application dependent and is up to you.</p>\n<p>Once a request has been sent, you <em>must</em> read the entire reply send back from\nthe broker (or close the connection to the broker and reconnect if you wish\nto retry).</p>\n<p>There are multiple methods for reading replies, depending on your needs:</p>\n<p><strong><code>recv_part(timeout: float=None) -&gt; Optional[List[bytes]]</code></strong></p>\n<p>Receive one reply part from the broker (a reply part is a list of bytes, as it\nmay contain multiple ZeroMQ frames).</p>\n<p>If no more parts are available (i.e. the last part was a <code>FINAL</code> reply), will\nreturn <code>None</code>.</p>\n<p><strong><code>recv_all(timeout: float=None) -&gt; Iterable[List[bytes]]</code></strong></p>\n<p>Returns an iterator that yields each message part as it is received, and exists\nafter the <code>FINAL</code> reply has been received:</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">part</span> <span class=\"ow\">in</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">recv_all</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mf\">5.0</span><span class=\"p\">):</span> \n    <span class=\"n\">do_something_with_reply_part</span><span class=\"p\">(</span><span class=\"n\">part</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Note</strong>: the <code>timeout</code> parameter in this case relates to the time between reply\nchunks, not to the time it would take to receive the entire reply until <code>FINAL</code>.</p>\n<p><strong><code>recv_all_as_list(timeout: float=None) -&gt; List[bytes]</code></strong></p>\n<p>Returns a flat list of all message frames from all reply parts. Regardless of\nhow many <code>PARTIAL</code> replies were sent by the worker until the <code>FINAL</code> reply,\nthis method will always return a single one-dimentional list of <code>bytes</code> with\nmessage frames.</p>\n<h5>Timeouts &amp; Retrying</h5>\n<p>All <code>recv_*</code> methods of the client receive a <code>timeout</code> argument which should\nspecify the number of seconds to wait for a response (a <code>float</code> is expected\nso you can specify second fractions as well). If no <code>timeout</code> is specified,\nthe function will wait forever.</p>\n<p>Once <code>recv_*</code> times out, a <code>majortomo.error.Timeout</code> will\nbe raised. It is sometimes useful to catch this exception and retry the\noperation after reconnecting to the broker:</p>\n<pre><span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"k\">with</span> <span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"n\">broker_url</span><span class=\"o\">=</span><span class=\"s1\">'tcp://127.0.0.1:5555'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">client</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n\n            <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'my-service'</span><span class=\"p\">,</span> <span class=\"sa\">b</span><span class=\"s1\">'frame1'</span><span class=\"p\">,</span> <span class=\"sa\">b</span><span class=\"s1\">'frame2'</span><span class=\"p\">)</span>\n            <span class=\"n\">reply</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">recv_all_as_list</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mf\">10.0</span><span class=\"p\">)</span>\n            <span class=\"k\">break</span>\n        <span class=\"k\">except</span> <span class=\"n\">majortomo</span><span class=\"o\">.</span><span class=\"n\">error</span><span class=\"o\">.</span><span class=\"n\">Timeout</span><span class=\"p\">:</span>\n            <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">warning</span><span class=\"p\">(</span><span class=\"s2\">\"Timed out waiting for a reply from broker, reconnecting\"</span><span class=\"p\">)</span>\n            <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n            <span class=\"k\">continue</span>\n</pre>\n<p>Or, if you do not wish to rely on the context manager for reconnecting (e.g. if\nthe context is managed in an outer scope):</p>\n<pre><span class=\"c1\"># Here `client` is passed from an outer scope</span>\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'my-service'</span><span class=\"p\">,</span> <span class=\"sa\">b</span><span class=\"s1\">'frame1'</span><span class=\"p\">,</span> <span class=\"sa\">b</span><span class=\"s1\">'frame2'</span><span class=\"p\">)</span>\n        <span class=\"n\">reply</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">recv_all_as_list</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mf\">10.0</span><span class=\"p\">)</span>\n        <span class=\"k\">break</span>\n    <span class=\"k\">except</span> <span class=\"n\">majortomo</span><span class=\"o\">.</span><span class=\"n\">error</span><span class=\"o\">.</span><span class=\"n\">Timeout</span><span class=\"p\">:</span>\n        <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">warning</span><span class=\"p\">(</span><span class=\"s2\">\"Timed out waiting for a reply from broker, reconnecting\"</span><span class=\"p\">)</span>\n        <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n        <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">reconnect</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n        <span class=\"k\">continue</span>\n</pre>\n<p>Even better, it is advisable to manage the number of retries and the <code>sleep</code> time\nbetween them using some kind of exponential backoff &amp; retry library, for example\n<a href=\"https://pypi.org/project/backoff/\" rel=\"nofollow\">backoff</a> or <a href=\"https://pypi.org/project/redo\" rel=\"nofollow\">redo</a></p>\n<h4>Implementing MDP Workers</h4>\n<p>See <code>majortomo.echo</code> for a sample worker implementation</p>\n<p>More details TBD</p>\n<h2>Copyright &amp; Credits</h2>\n<p>Majortomo was created and is maintained by the <a href=\"https://www.shoppimon.com\" rel=\"nofollow\">Shoppimon</a>\nteam, and is distributed under the terms of the Apache 2.0 License\n(see <code>LICENSE</code>).</p>\n<p>Majortomo is (C) Copyright 2018 Shoppimon LTD.</p>\n<p>\u00d8MQ is Copyright (c) 2007-2014 iMatix Corporation and Contributors.</p>\n\n          </div>"}, "last_serial": 4576840, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "6e39d0fbd3f4d7c8132f8324b6cfc5a1", "sha256": "d698567058b82de3a9e80dca01a6b1bdaf9d662833b554fbd6031a234f019f94"}, "downloads": -1, "filename": "majortomo-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6e39d0fbd3f4d7c8132f8324b6cfc5a1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24385, "upload_time": "2018-12-09T07:17:01", "upload_time_iso_8601": "2018-12-09T07:17:01.584418Z", "url": "https://files.pythonhosted.org/packages/8c/41/f8f19bea25bd9752f19c1ef403dc9d941aa25958057cb98b8192d666035b/majortomo-0.1.0-py2.py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6e39d0fbd3f4d7c8132f8324b6cfc5a1", "sha256": "d698567058b82de3a9e80dca01a6b1bdaf9d662833b554fbd6031a234f019f94"}, "downloads": -1, "filename": "majortomo-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6e39d0fbd3f4d7c8132f8324b6cfc5a1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24385, "upload_time": "2018-12-09T07:17:01", "upload_time_iso_8601": "2018-12-09T07:17:01.584418Z", "url": "https://files.pythonhosted.org/packages/8c/41/f8f19bea25bd9752f19c1ef403dc9d941aa25958057cb98b8192d666035b/majortomo-0.1.0-py2.py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 00:41:50 2020"}