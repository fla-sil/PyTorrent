{"info": {"author": "Brandon Rhodes", "author_email": "brandon@rhodesmill.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Scientific/Engineering :: Astronomy"], "description": "\nCite as: `Astrophysics Source Code Library, record ascl:1112.014\n<https://ascl.net/1112.014>`_\n\nThis package can load and use a Jet Propulsion Laboratory (JPL)\nephemeris for predicting the position and velocity of a planet or other\nSolar System body.  It only needs `NumPy <http://www.numpy.org/>`_,\nwhich ``pip`` will automatically attempt to install alongside\n``pyephem`` when you run::\n\n    $ pip install jplephem\n\nIf you see NumPy compilation errors, then try downloading and installing\nNumPy directly from `its web site <http://www.numpy.org/>`_ or simply\nuse a distribution of Python with science tools already installed, like\n`Anaconda <http://continuum.io/downloads>`_.\n\nNote that ``jplephem`` offers only the logic necessary to produce plain\nthree-dimensional vectors.  Most programmers interested in astronomy\nwill want to look at `Skyfield <http://rhodesmill.org/skyfield/>`_\ninstead, which uses ``jplephem`` but converts the numbers into more\ntraditional measurements like right ascension and declination.\n\nMost users will use ``jplephem`` with the Satellite Planet Kernel (SPK)\nfiles that the NAIF facility at NASA JPL offers for use with their own\nSPICE toolkit.  They have collected their most useful kernels beneath\nthe directory:\n\nhttp://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/\n\nTo learn more about SPK files, the official `SPK Required Reading\n<http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/req/spk.html>`_\ndocument is available from the NAIF facility\u2019s web site under the NASA\nJPL domain.\n\nCommand Line Tool\n-----------------\n\nIf you have downloaded a ``.bsp`` file, you can run ``jplephem`` from\nthe command line to display the data inside of it::\n\n    python -m jplephem comment de421.bsp\n    python -m jplephem dap de421.bsp\n    python -m jplephem spk de421.bsp\n\nYou can also take a large ephemeris and produce a smaller excerpt by\nlimiting the range of dates that it covers::\n\n    python -m jplephem excerpt 2018/1/1 2018/4/1 de421.bsp excerpt421.bsp\n\nIf the input ephemeris is a URL, then `jplephem` will try to save\nbandwidth by fetching only the blocks of the remote file that are\nnecessary to cover the dates you have specified.  For example, the\nJupiter satellite ephemeris `jup310.bsp` is famously large, weighing in\na nearly a gigabyte.  But if all you need are Jupiter's satellites for a\nfew months, you can download considerably less data::\n\n    $ python -m jplephem excerpt 2018/1/1 2018/4/1 \\\n        https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/satellites/jup310.bsp \\\n        excerpt.bsp\n    $ ls -lh excerpt.bsp\n    -rw-r----- 1 brandon brandon 1.2M Feb 11 13:36 excerpt.bsp\n\nIn this case only about one-thousandth of the ephemeris's data needed to\nbe downloaded.\n\nGetting Started With DE421\n--------------------------\n\nThe DE421 ephemeris is a useful starting point.  It weighs in at 17\u00a0MB,\nbut provides predictions over the years 1900\u20132050:\n\nhttps://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\n\nAfter the kernel has downloaded, you can use ``jplephem`` to load this\nSPK file and learn about the segments it offers:\n\n>>> from jplephem.spk import SPK\n>>> kernel = SPK.open('de421.bsp')\n>>> print(kernel)\nFile type DAF/SPK and format LTL-IEEE with 15 segments:\n2414864.50..2471184.50  Solar System Barycenter (0) -> Mercury Barycenter (1)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Venus Barycenter (2)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Earth Barycenter (3)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Mars Barycenter (4)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Jupiter Barycenter (5)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Saturn Barycenter (6)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Uranus Barycenter (7)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Neptune Barycenter (8)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Pluto Barycenter (9)\n2414864.50..2471184.50  Solar System Barycenter (0) -> Sun (10)\n2414864.50..2471184.50  Earth Barycenter (3) -> Moon (301)\n2414864.50..2471184.50  Earth Barycenter (3) -> Earth (399)\n2414864.50..2471184.50  Mercury Barycenter (1) -> Mercury (199)\n2414864.50..2471184.50  Venus Barycenter (2) -> Venus (299)\n2414864.50..2471184.50  Mars Barycenter (4) -> Mars (499)\n\nSince the next few examples involve vector output, let\u2019s tell NumPy to\nmake vector output attractive.\n\n>>> import numpy as np\n>>> np.set_printoptions(precision=3)\n\nEach segment of the file lets you predict the position of an object with\nrespect to some other reference point.  If you want the coordinates of\nMars at 2457061.5 (2015 February\u00a08) with respect to the center of the\nsolar system, this ephemeris only requires you to take a single step:\n\n>>> position = kernel[0,4].compute(2457061.5)\n>>> print(position)\n[2.057e+08 4.251e+07 1.394e+07]\n\nBut learning the position of Mars with respect to the Earth takes three\nsteps, from Mars to the Solar System barycenter to the Earth-Moon\nbarycenter and finally to Earth itself:\n\n>>> position = kernel[0,4].compute(2457061.5)\n>>> position -= kernel[0,3].compute(2457061.5)\n>>> position -= kernel[3,399].compute(2457061.5)\n>>> print(position)\n[ 3.161e+08 -4.679e+07 -2.476e+07]\n\nYou can see that the output of this ephemeris is in kilometers.  If you\nuse another ephemeris, check its documentation to be sure of the units\nthat it employs.\n\nIf you supply the date as a NumPy array, then each component that is\nreturned will itself be a vector as long as your date:\n\n>>> jd = np.array([2457061.5, 2457062.5, 2457063.5, 2457064.5])\n>>> position = kernel[0,4].compute(jd)\n>>> print(position)\n[[2.057e+08 2.053e+08 2.049e+08 2.045e+08]\n [4.251e+07 4.453e+07 4.654e+07 4.855e+07]\n [1.394e+07 1.487e+07 1.581e+07 1.674e+07]]\n\nSome ephemerides include velocity inline by returning a 6-vector instead\nof a 3-vector.  For an ephemeris that does not, you can ask for the\nChebyshev polynomial to be differentiated to produce a velocity, which\nis delivered as a second return value:\n\n>>> position, velocity = kernel[0,4].compute_and_differentiate(2457061.5)\n>>> print(position)\n[2.057e+08 4.251e+07 1.394e+07]\n>>> print(velocity)\n[-363896.059 2019662.996  936169.773]\n\nThe velocity will by default be distance traveled per day, in whatever\nunits for distance the ephemeris happens to use.  To get a velocity per\nsecond, simply divide by the number of seconds in a day:\n\n>>> velocity_per_second = velocity / 86400.0\n>>> print(velocity_per_second)\n[-4.212 23.376 10.835]\n\nDetails of the API\n------------------\n\nHere are a few details for people ready to go beyond the high-level API\nprovided above and read through the code to learn more.\n\n* Instead of reading an entire ephemeris into memory, ``jplephem``\n  memory-maps the underlying file so that the operating system can\n  efficiently page into RAM only the data that your code is using.\n\n* Once the metadata has been parsed from the binary SPK file, the\n  polynomial coefficients themselves are loaded by building a NumPy\n  array object that has access to the raw binary file contents.\n  Happily, NumPy already knows how to interpret a packed array of\n  double-precision floats.  You can learn about the underlying DAF\n  \u201cDouble Precision Array File\u201d format, in case you ever need to open\n  other such array files in Python, through the ``DAF`` class in the\n  module ``jplephem.daf``.\n\n* An SPK file is made of segments.  When you first create an ``SPK``\n  kernel object ``k``, it examines the file and creates a list of\n  ``Segment`` objects that it keeps in a list under an attribute named\n  ``k.segments`` which you are free to examine in your own code by\n  looping over it.\n\n* There is more information about each segment beyond the one-line\n  summary that you get when you print out the SPK file, which you can\n  see by asking the segment to print itself verbosely:\n\n  >>> segment = kernel[3,399]\n  >>> print(segment.describe())\n  2414864.50..2471184.50  Earth Barycenter (3) -> Earth (399)\n    frame=1 data_type=2 source=DE-0421LE-0421\n\n* Each ``Segment`` loaded from the kernel has a number of attributes\n  that are loaded from the SPK file:\n\n  >>> from jplephem.spk import BaseSegment\n  >>> help(BaseSegment)\n  Help on class BaseSegment in module jplephem.spk:\n  ...\n   |  segment.source - official ephemeris name, like 'DE-0430LE-0430'\n   |  segment.start_second - initial epoch, as seconds from J2000\n   |  segment.end_second - final epoch, as seconds from J2000\n   |  segment.start_jd - start_second, converted to a Julian Date\n   |  segment.end_jd - end_second, converted to a Julian Date\n   |  segment.center - integer center identifier\n   |  segment.target - integer target identifier\n   |  segment.frame - integer frame identifier\n   |  segment.data_type - integer data type identifier\n   |  segment.start_i - index where segment starts\n   |  segment.end_i - index where segment ends\n  ...\n\n* If you want to access the raw coefficients, use the segment\n  ``load_array()`` method.  It returns two floats and a NumPy array:\n\n  >>> initial_epoch, interval_length, coefficients = segment.load_array()\n  >>> print(coefficients.shape)\n  (3, 14080, 13)\n\n* The square-bracket lookup mechanism ``kernel[3,399]`` is a\n  non-standard convenience that returns only the last matching segment\n  in the file.  While the SPK standard does say that the last segment\n  takes precedence, it also says that earlier segments for a particular\n  center-target pair should be fallen back upon for dates that the last\n  segment does not cover.  So, if you ever tackle a complicated kernel,\n  you will need to implement fallback rules that send some dates to the\n  final segment for a given center and target, but that send other dates\n  to earlier segments that are qualified to cover them.\n\n* If you are accounting for light travel time and require repeated\n  computation of the position, but then need the velocity at the end,\n  and want to avoid repeating the expensive position calculation, then\n  try out the ``segment.generate()`` method - it will let you ask for\n  the position, and then only proceed to the velocity once you are sure\n  that the light-time error is now small enough.\n\nHigh-Precision Dates\n--------------------\n\nSince all modern Julian dates are numbers larger than 2.4 million, a\nstandard 64-bit Python or NumPy float necessarily leaves only a limited\nnumber of bits available for the fractional part.  *Technical Note\n2011-02* from the United States Naval Observatory's Astronomical\nApplications Department suggests that the `precision possible with a\n64-bit floating point Julian date is around 20.1\u00a0\u00b5s\n<http://jplephem.s3.amazonaws.com/JD_precision_test.pdf>`_.\n\nIf you need to supply times and receive back planetary positions with\ngreater precision than 20.1\u00a0\u00b5s, then you have two options.\n\nFirst, you can supply times using the special ``float96`` NumPy type,\nwhich is also aliased to the name ``longfloat``.  If you provide either\na ``float96`` scalar or a ``float96`` array as your ``tdb`` parameter to\nany ``jplephem`` routine, you should get back a high-precision result.\n\nSecond, you can split your date or dates into two pieces, and supply\nthem as a pair of arguments two ``tdb`` and ``tdb2``.  One popular\napproach for how to split your date is to use the ``tdb`` float for the\ninteger Julian date, and ``tdb2`` for the fraction that specifies the\ntime of day.  Nearly all ``jplephem`` routines accept this optional\n``tdb2`` argument if you wish to provide it, thanks to the work of\nMarten van Kerkwijk!\n\nSupport for Binary PCKs\n-----------------------\n\nYou can also load and produce rotation matrices from a binary PCK file.\nIts segments are available through the ``segments`` attributes of the\nreturned object.\n\n>>> from jplephem.pck import PCK\n>>> p = PCK.open('moon_pa_de421_1900-2050.bpc')\n>>> p.segments[0].body\n31006\n>>> p.segments[0].frame\n1\n>>> p.segments[0].data_type\n2\n\nGiven a solary system barycenter Julian date, the segment will return\nthe three angles necessary to build a rotation matrix: right ascension\nof the pole, declination of the pole, and cumulative rotation of the\nbody\u2019s axis.  Typically these will all be in radians.\n\n>>> tdb = 2454540.34103\n>>> print(p.segments[0].compute(tdb, 0.0, False))\n[3.928e-02 3.878e-01 3.253e+03]\n\nYou can ask for velocity as well.\n\n>>> r, v = p.segments[0].compute(tdb, 0.0, True)\n>>> print(r)\n[3.928e-02 3.878e-01 3.253e+03]\n>>> print(v)\n[6.707e-09 4.838e-10 2.655e-06]\n\nLegacy Ephemeris Packages\n-------------------------\n\nBack before I learned about SPICE and SPK files, I had run across the\ntext-file formatted JPL ephemerides at:\n\nftp://ssd.jpl.nasa.gov/pub/eph/planets/ascii/\n\nI laboriously assembled the data in these text files into native NumPy\narray files and wrapped them each in a Python package so that users\ncould install an ephemeris with a simple command::\n\n    pip install de421\n\nIf you want to use one of these pip-installable ephemerides, you will be\nusing a slightly older API, and will lose the benefit of the efficient\nmemory-mapping that the newer SPK code performs.  With the old API, here\nis how you would load DE421 and compute a position, given a barycentric\ndynamical time expressed as a Julian date::\n\n    import de421\n    from jplephem import Ephemeris\n\n    eph = Ephemeris(de421)\n    x, y, z = eph.position('mars', 2444391.5)  # 1980.06.01\n\nFor more information about the legacy API, consult the ``jplephem``\nentry on PyPI for the final release of the 1.x series:\n\nhttps://pypi.python.org/pypi/jplephem/1.2\n\nThe ephemerides that were made available as Python packages (the\nfollowing links explain the differences between them) are:\n\n* `DE405 <http://pypi.python.org/pypi/de405>`_ (May 1997)\n  \u2014 54\u00a0MB covering years 1600 through 2200\n* `DE406 <http://pypi.python.org/pypi/de406>`_ (May 1997)\n  \u2014 190\u00a0MB covering years -3000 through 3000\n* `DE421 <http://pypi.python.org/pypi/de421>`_ (February 2008)\n  \u2014 27\u00a0MB covering years 1900 through 2050\n* `DE422 <http://pypi.python.org/pypi/de422>`_ (September 2009)\n  \u2014 531\u00a0MB covering years -3000 through 3000\n* `DE423 <http://pypi.python.org/pypi/de423>`_ (February 2010)\n  \u2014 36\u00a0MB covering years 1800 through 2200\n\n\nReporting issues\n----------------\n\nYou can report any issues, bugs, or problems at the GitHub repository:\n\nhttps://github.com/brandon-rhodes/python-jplephem/\n\n\nChangelog\n---------\n\n**2020 March 26 \u2014 Version 2.14**\n\n* Fall back to plain file I/O on platforms that support ``fileno()`` but\n  that don\u2019t support ``mmap()``, like the `Pyodide platform\n  <https://github.com/iodide-project/pyodide>`_.\n\n**2020 February 22 \u2014 Version 2.13**\n\n* The exception raised when a segment is given a Julian date outside the\n  segment\u2019s date range is now an instance of the ``ValueError`` subclass\n  ``OutOfRangeError`` that reminds the caller of the range of dates\n  supported by the SPK segment, and carries an array attribute\n  indicating which input dates were at fault.\n\n**2019 December 13 \u2014 Version 2.12**\n\n* Replaced use of NumPy ``flip()`` with a reverse slice ``[::-1]`` after\n  discovering the function was a recent addition that some user installs\n  of NumPy do not support.\n\n**2019 December 13 \u2014 Version 2.11**\n\n* Reverse the order in which Chebyshev polynomials are computed to\n  slightly increase speed, to simplify the code, and in one case\n  (comparing PCK output to NASA) to gain a partial digit of extra\n  precision.\n\n**2019 December 11 \u2014 Version 2.10**\n\n* Document and release support for ``.bcp`` binary PCK kernel files\n  through the new ``jplephem.pck`` module.\n\n**2019 January 3 \u2014 Version 2.9**\n\n* Added the ``load_array()`` method to the segment class.\n\n**2018 July 22 \u2014 Version 2.8**\n\n* Switched to a making a single memory map of the entire file, to avoid\n  running out of file descriptors when users load an ephemeris with\n  hundreds of segments.\n\n**2018 February 11 \u2014 Version 2.7**\n\n* Expanded the command line tool, most notably with the ability to fetch\n  over HTTP only those sections of a large ephemeris that cover a\n  specific range of dates, producing a smaller ``.bsp`` file.\n\n**2016 December 19 \u2014 Version 2.6**\n\n* Fixed the ability to invoke the module from the command line with\n  ``python -m jplephem``, and added a test to keep it fixed.\n\n**2015 November 9 \u2014 Version 2.5**\n\n* Move ``fileno()`` call out of the ``DAF`` constructor to support\n  fetching at least summary information from ``StringIO`` objects.\n\n**2015 November 1 \u2014 Version 2.4**\n\n* Add Windows compatibility by switching ``mmap()`` from using\n  ``PAGESIZE`` to ``ALLOCATIONGRANULARITY``.\n\n* Avoid a new NumPy deprecation warning by being careful to use only\n  integers in the NumPy ``shape`` tuple.\n\n* Add names \"TDB\" and \"TT\" to the names database for DE430.\n\n**2015 August 16 \u2014 Version 2.3**\n\n* Added auto-detection and support for old NAIF/DAF kernels like\n  ``de405.bsp`` to the main ``DAF`` class itself, instead of requiring\n  the awkward use of an entirely different alternative class.\n\n**2015 August 5 \u2014 Version 2.2**\n\n* You can now invoke ``jplephem`` from the command line.\n\n* Fixes an exception that was raised for SPK segments with a coefficient\n  count of only 2, like the DE421 and DE430 segments that provide the\n  offset of Mercury from the Mercury barycenter.\n\n* Supports old NAIF/DAF kernels like ``de405.bsp``.\n\n* The ``SPK()`` constructor is now simpler, taking a ``DAF`` object\n  instead of an open file.  This is considered an internal API change \u2014\n  the public API is the constructor ``SPK.open()``.\n\n**2015 February 24 \u2014 Version 2.1**\n\n* Switched from mapping an entire SPK file into memory at once to\n  memory-mapping each segment separately on demand.\n\n**2015 February 8 \u2014 Version 2.0**\n\n* Added support for SPICE SPK kernel files downloaded directly from\n  NASA, and designated old Python-packaged ephemerides as \u201clegacy.\u201d\n\n**2013 November 26 \u2014 Version 1.2**\n\n* Helge Eichhorn fixed the default for the ``position_and_velocity()``\n  argument ``tdb2`` so it defaults to zero days instead of 2.0 days.\n  Tests were added to prevent any future regression.\n\n**2013 July 10 \u2014 Version 1.1**\n\n* Deprecates the old ``compute()`` method in favor of separate\n  ``position()`` and ``position_and_velocity()`` methods.\n\n* Supports computing position and velocity in two separate phases by\n  saving a \u201cbundle\u201d of coefficients returned by ``compute_bundle()``.\n\n* From Marten van Kerkwijk: a second ``tdb2`` time argument, for users\n  who want to build higher precision dates out of two 64-bit floats.\n\n**2013 January 18 \u2014 Version 1.0**\n\n* Initial release\n\n\nReferences\n----------\n\nThe Jet Propulsion Laboratory's \u201cSolar System Dynamics\u201d page introduces\nthe various options for doing solar system position computations:\nhttp://ssd.jpl.nasa.gov/?ephemerides\n\nThe plain ASCII format element sets from which the ``jplephem`` Python\nephemeris packages are built, along with documentation, can be found at:\nftp://ssd.jpl.nasa.gov/pub/eph/planets/ascii/\n\nEquivalent FORTRAN code for using the ephemerides be found at the same\nFTP site: ftp://ssd.jpl.nasa.gov/pub/eph/planets/fortran/\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "jplephem", "package_url": "https://pypi.org/project/jplephem/", "platform": "", "project_url": "https://pypi.org/project/jplephem/", "project_urls": null, "release_url": "https://pypi.org/project/jplephem/2.14/", "requires_dist": null, "requires_python": "", "summary": "Use a JPL ephemeris to predict planet positions.", "version": "2.14", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Cite as: <a href=\"https://ascl.net/1112.014\" rel=\"nofollow\">Astrophysics Source Code Library, record ascl:1112.014</a></p>\n<p>This package can load and use a Jet Propulsion Laboratory (JPL)\nephemeris for predicting the position and velocity of a planet or other\nSolar System body.  It only needs <a href=\"http://www.numpy.org/\" rel=\"nofollow\">NumPy</a>,\nwhich <tt>pip</tt> will automatically attempt to install alongside\n<tt>pyephem</tt> when you run:</p>\n<pre>$ pip install jplephem\n</pre>\n<p>If you see NumPy compilation errors, then try downloading and installing\nNumPy directly from <a href=\"http://www.numpy.org/\" rel=\"nofollow\">its web site</a> or simply\nuse a distribution of Python with science tools already installed, like\n<a href=\"http://continuum.io/downloads\" rel=\"nofollow\">Anaconda</a>.</p>\n<p>Note that <tt>jplephem</tt> offers only the logic necessary to produce plain\nthree-dimensional vectors.  Most programmers interested in astronomy\nwill want to look at <a href=\"http://rhodesmill.org/skyfield/\" rel=\"nofollow\">Skyfield</a>\ninstead, which uses <tt>jplephem</tt> but converts the numbers into more\ntraditional measurements like right ascension and declination.</p>\n<p>Most users will use <tt>jplephem</tt> with the Satellite Planet Kernel (SPK)\nfiles that the NAIF facility at NASA JPL offers for use with their own\nSPICE toolkit.  They have collected their most useful kernels beneath\nthe directory:</p>\n<p><a href=\"http://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/\" rel=\"nofollow\">http://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/</a></p>\n<p>To learn more about SPK files, the official <a href=\"http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/req/spk.html\" rel=\"nofollow\">SPK Required Reading</a>\ndocument is available from the NAIF facility\u2019s web site under the NASA\nJPL domain.</p>\n<div id=\"command-line-tool\">\n<h2>Command Line Tool</h2>\n<p>If you have downloaded a <tt>.bsp</tt> file, you can run <tt>jplephem</tt> from\nthe command line to display the data inside of it:</p>\n<pre>python -m jplephem comment de421.bsp\npython -m jplephem dap de421.bsp\npython -m jplephem spk de421.bsp\n</pre>\n<p>You can also take a large ephemeris and produce a smaller excerpt by\nlimiting the range of dates that it covers:</p>\n<pre>python -m jplephem excerpt 2018/1/1 2018/4/1 de421.bsp excerpt421.bsp\n</pre>\n<p>If the input ephemeris is a URL, then <cite>jplephem</cite> will try to save\nbandwidth by fetching only the blocks of the remote file that are\nnecessary to cover the dates you have specified.  For example, the\nJupiter satellite ephemeris <cite>jup310.bsp</cite> is famously large, weighing in\na nearly a gigabyte.  But if all you need are Jupiter\u2019s satellites for a\nfew months, you can download considerably less data:</p>\n<pre>$ python -m jplephem excerpt 2018/1/1 2018/4/1 \\\n    https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/satellites/jup310.bsp \\\n    excerpt.bsp\n$ ls -lh excerpt.bsp\n-rw-r----- 1 brandon brandon 1.2M Feb 11 13:36 excerpt.bsp\n</pre>\n<p>In this case only about one-thousandth of the ephemeris\u2019s data needed to\nbe downloaded.</p>\n</div>\n<div id=\"getting-started-with-de421\">\n<h2>Getting Started With DE421</h2>\n<p>The DE421 ephemeris is a useful starting point.  It weighs in at 17\u00a0MB,\nbut provides predictions over the years 1900\u20132050:</p>\n<p><a href=\"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\" rel=\"nofollow\">https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp</a></p>\n<p>After the kernel has downloaded, you can use <tt>jplephem</tt> to load this\nSPK file and learn about the segments it offers:</p>\n<pre>&gt;&gt;&gt; from jplephem.spk import SPK\n&gt;&gt;&gt; kernel = SPK.open('de421.bsp')\n&gt;&gt;&gt; print(kernel)\nFile type DAF/SPK and format LTL-IEEE with 15 segments:\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Mercury Barycenter (1)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Venus Barycenter (2)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Earth Barycenter (3)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Mars Barycenter (4)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Jupiter Barycenter (5)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Saturn Barycenter (6)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Uranus Barycenter (7)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Neptune Barycenter (8)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Pluto Barycenter (9)\n2414864.50..2471184.50  Solar System Barycenter (0) -&gt; Sun (10)\n2414864.50..2471184.50  Earth Barycenter (3) -&gt; Moon (301)\n2414864.50..2471184.50  Earth Barycenter (3) -&gt; Earth (399)\n2414864.50..2471184.50  Mercury Barycenter (1) -&gt; Mercury (199)\n2414864.50..2471184.50  Venus Barycenter (2) -&gt; Venus (299)\n2414864.50..2471184.50  Mars Barycenter (4) -&gt; Mars (499)\n</pre>\n<p>Since the next few examples involve vector output, let\u2019s tell NumPy to\nmake vector output attractive.</p>\n<pre>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; np.set_printoptions(precision=3)\n</pre>\n<p>Each segment of the file lets you predict the position of an object with\nrespect to some other reference point.  If you want the coordinates of\nMars at 2457061.5 (2015 February\u00a08) with respect to the center of the\nsolar system, this ephemeris only requires you to take a single step:</p>\n<pre>&gt;&gt;&gt; position = kernel[0,4].compute(2457061.5)\n&gt;&gt;&gt; print(position)\n[2.057e+08 4.251e+07 1.394e+07]\n</pre>\n<p>But learning the position of Mars with respect to the Earth takes three\nsteps, from Mars to the Solar System barycenter to the Earth-Moon\nbarycenter and finally to Earth itself:</p>\n<pre>&gt;&gt;&gt; position = kernel[0,4].compute(2457061.5)\n&gt;&gt;&gt; position -= kernel[0,3].compute(2457061.5)\n&gt;&gt;&gt; position -= kernel[3,399].compute(2457061.5)\n&gt;&gt;&gt; print(position)\n[ 3.161e+08 -4.679e+07 -2.476e+07]\n</pre>\n<p>You can see that the output of this ephemeris is in kilometers.  If you\nuse another ephemeris, check its documentation to be sure of the units\nthat it employs.</p>\n<p>If you supply the date as a NumPy array, then each component that is\nreturned will itself be a vector as long as your date:</p>\n<pre>&gt;&gt;&gt; jd = np.array([2457061.5, 2457062.5, 2457063.5, 2457064.5])\n&gt;&gt;&gt; position = kernel[0,4].compute(jd)\n&gt;&gt;&gt; print(position)\n[[2.057e+08 2.053e+08 2.049e+08 2.045e+08]\n [4.251e+07 4.453e+07 4.654e+07 4.855e+07]\n [1.394e+07 1.487e+07 1.581e+07 1.674e+07]]\n</pre>\n<p>Some ephemerides include velocity inline by returning a 6-vector instead\nof a 3-vector.  For an ephemeris that does not, you can ask for the\nChebyshev polynomial to be differentiated to produce a velocity, which\nis delivered as a second return value:</p>\n<pre>&gt;&gt;&gt; position, velocity = kernel[0,4].compute_and_differentiate(2457061.5)\n&gt;&gt;&gt; print(position)\n[2.057e+08 4.251e+07 1.394e+07]\n&gt;&gt;&gt; print(velocity)\n[-363896.059 2019662.996  936169.773]\n</pre>\n<p>The velocity will by default be distance traveled per day, in whatever\nunits for distance the ephemeris happens to use.  To get a velocity per\nsecond, simply divide by the number of seconds in a day:</p>\n<pre>&gt;&gt;&gt; velocity_per_second = velocity / 86400.0\n&gt;&gt;&gt; print(velocity_per_second)\n[-4.212 23.376 10.835]\n</pre>\n</div>\n<div id=\"details-of-the-api\">\n<h2>Details of the API</h2>\n<p>Here are a few details for people ready to go beyond the high-level API\nprovided above and read through the code to learn more.</p>\n<ul>\n<li><p>Instead of reading an entire ephemeris into memory, <tt>jplephem</tt>\nmemory-maps the underlying file so that the operating system can\nefficiently page into RAM only the data that your code is using.</p>\n</li>\n<li><p>Once the metadata has been parsed from the binary SPK file, the\npolynomial coefficients themselves are loaded by building a NumPy\narray object that has access to the raw binary file contents.\nHappily, NumPy already knows how to interpret a packed array of\ndouble-precision floats.  You can learn about the underlying DAF\n\u201cDouble Precision Array File\u201d format, in case you ever need to open\nother such array files in Python, through the <tt>DAF</tt> class in the\nmodule <tt>jplephem.daf</tt>.</p>\n</li>\n<li><p>An SPK file is made of segments.  When you first create an <tt>SPK</tt>\nkernel object <tt>k</tt>, it examines the file and creates a list of\n<tt>Segment</tt> objects that it keeps in a list under an attribute named\n<tt>k.segments</tt> which you are free to examine in your own code by\nlooping over it.</p>\n</li>\n<li><p>There is more information about each segment beyond the one-line\nsummary that you get when you print out the SPK file, which you can\nsee by asking the segment to print itself verbosely:</p>\n<pre>&gt;&gt;&gt; segment = kernel[3,399]\n&gt;&gt;&gt; print(segment.describe())\n2414864.50..2471184.50  Earth Barycenter (3) -&gt; Earth (399)\n  frame=1 data_type=2 source=DE-0421LE-0421\n</pre>\n</li>\n<li><p>Each <tt>Segment</tt> loaded from the kernel has a number of attributes\nthat are loaded from the SPK file:</p>\n<pre>&gt;&gt;&gt; from jplephem.spk import BaseSegment\n&gt;&gt;&gt; help(BaseSegment)\nHelp on class BaseSegment in module jplephem.spk:\n...\n |  segment.source - official ephemeris name, like 'DE-0430LE-0430'\n |  segment.start_second - initial epoch, as seconds from J2000\n |  segment.end_second - final epoch, as seconds from J2000\n |  segment.start_jd - start_second, converted to a Julian Date\n |  segment.end_jd - end_second, converted to a Julian Date\n |  segment.center - integer center identifier\n |  segment.target - integer target identifier\n |  segment.frame - integer frame identifier\n |  segment.data_type - integer data type identifier\n |  segment.start_i - index where segment starts\n |  segment.end_i - index where segment ends\n...\n</pre>\n</li>\n<li><p>If you want to access the raw coefficients, use the segment\n<tt>load_array()</tt> method.  It returns two floats and a NumPy array:</p>\n<pre>&gt;&gt;&gt; initial_epoch, interval_length, coefficients = segment.load_array()\n&gt;&gt;&gt; print(coefficients.shape)\n(3, 14080, 13)\n</pre>\n</li>\n<li><p>The square-bracket lookup mechanism <tt>kernel[3,399]</tt> is a\nnon-standard convenience that returns only the last matching segment\nin the file.  While the SPK standard does say that the last segment\ntakes precedence, it also says that earlier segments for a particular\ncenter-target pair should be fallen back upon for dates that the last\nsegment does not cover.  So, if you ever tackle a complicated kernel,\nyou will need to implement fallback rules that send some dates to the\nfinal segment for a given center and target, but that send other dates\nto earlier segments that are qualified to cover them.</p>\n</li>\n<li><p>If you are accounting for light travel time and require repeated\ncomputation of the position, but then need the velocity at the end,\nand want to avoid repeating the expensive position calculation, then\ntry out the <tt>segment.generate()</tt> method - it will let you ask for\nthe position, and then only proceed to the velocity once you are sure\nthat the light-time error is now small enough.</p>\n</li>\n</ul>\n</div>\n<div id=\"high-precision-dates\">\n<h2>High-Precision Dates</h2>\n<p>Since all modern Julian dates are numbers larger than 2.4 million, a\nstandard 64-bit Python or NumPy float necessarily leaves only a limited\nnumber of bits available for the fractional part.  <em>Technical Note\n2011-02</em> from the United States Naval Observatory\u2019s Astronomical\nApplications Department suggests that the <a href=\"http://jplephem.s3.amazonaws.com/JD_precision_test.pdf\" rel=\"nofollow\">precision possible with a\n64-bit floating point Julian date is around 20.1\u00a0\u00b5s</a>.</p>\n<p>If you need to supply times and receive back planetary positions with\ngreater precision than 20.1\u00a0\u00b5s, then you have two options.</p>\n<p>First, you can supply times using the special <tt>float96</tt> NumPy type,\nwhich is also aliased to the name <tt>longfloat</tt>.  If you provide either\na <tt>float96</tt> scalar or a <tt>float96</tt> array as your <tt>tdb</tt> parameter to\nany <tt>jplephem</tt> routine, you should get back a high-precision result.</p>\n<p>Second, you can split your date or dates into two pieces, and supply\nthem as a pair of arguments two <tt>tdb</tt> and <tt>tdb2</tt>.  One popular\napproach for how to split your date is to use the <tt>tdb</tt> float for the\ninteger Julian date, and <tt>tdb2</tt> for the fraction that specifies the\ntime of day.  Nearly all <tt>jplephem</tt> routines accept this optional\n<tt>tdb2</tt> argument if you wish to provide it, thanks to the work of\nMarten van Kerkwijk!</p>\n</div>\n<div id=\"support-for-binary-pcks\">\n<h2>Support for Binary PCKs</h2>\n<p>You can also load and produce rotation matrices from a binary PCK file.\nIts segments are available through the <tt>segments</tt> attributes of the\nreturned object.</p>\n<pre>&gt;&gt;&gt; from jplephem.pck import PCK\n&gt;&gt;&gt; p = PCK.open('moon_pa_de421_1900-2050.bpc')\n&gt;&gt;&gt; p.segments[0].body\n31006\n&gt;&gt;&gt; p.segments[0].frame\n1\n&gt;&gt;&gt; p.segments[0].data_type\n2\n</pre>\n<p>Given a solary system barycenter Julian date, the segment will return\nthe three angles necessary to build a rotation matrix: right ascension\nof the pole, declination of the pole, and cumulative rotation of the\nbody\u2019s axis.  Typically these will all be in radians.</p>\n<pre>&gt;&gt;&gt; tdb = 2454540.34103\n&gt;&gt;&gt; print(p.segments[0].compute(tdb, 0.0, False))\n[3.928e-02 3.878e-01 3.253e+03]\n</pre>\n<p>You can ask for velocity as well.</p>\n<pre>&gt;&gt;&gt; r, v = p.segments[0].compute(tdb, 0.0, True)\n&gt;&gt;&gt; print(r)\n[3.928e-02 3.878e-01 3.253e+03]\n&gt;&gt;&gt; print(v)\n[6.707e-09 4.838e-10 2.655e-06]\n</pre>\n</div>\n<div id=\"legacy-ephemeris-packages\">\n<h2>Legacy Ephemeris Packages</h2>\n<p>Back before I learned about SPICE and SPK files, I had run across the\ntext-file formatted JPL ephemerides at:</p>\n<p><a>ftp://ssd.jpl.nasa.gov/pub/eph/planets/ascii/</a></p>\n<p>I laboriously assembled the data in these text files into native NumPy\narray files and wrapped them each in a Python package so that users\ncould install an ephemeris with a simple command:</p>\n<pre>pip install de421\n</pre>\n<p>If you want to use one of these pip-installable ephemerides, you will be\nusing a slightly older API, and will lose the benefit of the efficient\nmemory-mapping that the newer SPK code performs.  With the old API, here\nis how you would load DE421 and compute a position, given a barycentric\ndynamical time expressed as a Julian date:</p>\n<pre>import de421\nfrom jplephem import Ephemeris\n\neph = Ephemeris(de421)\nx, y, z = eph.position('mars', 2444391.5)  # 1980.06.01\n</pre>\n<p>For more information about the legacy API, consult the <tt>jplephem</tt>\nentry on PyPI for the final release of the 1.x series:</p>\n<p><a href=\"https://pypi.python.org/pypi/jplephem/1.2\" rel=\"nofollow\">https://pypi.python.org/pypi/jplephem/1.2</a></p>\n<p>The ephemerides that were made available as Python packages (the\nfollowing links explain the differences between them) are:</p>\n<ul>\n<li><a href=\"http://pypi.python.org/pypi/de405\" rel=\"nofollow\">DE405</a> (May 1997)\n\u2014 54\u00a0MB covering years 1600 through 2200</li>\n<li><a href=\"http://pypi.python.org/pypi/de406\" rel=\"nofollow\">DE406</a> (May 1997)\n\u2014 190\u00a0MB covering years -3000 through 3000</li>\n<li><a href=\"http://pypi.python.org/pypi/de421\" rel=\"nofollow\">DE421</a> (February 2008)\n\u2014 27\u00a0MB covering years 1900 through 2050</li>\n<li><a href=\"http://pypi.python.org/pypi/de422\" rel=\"nofollow\">DE422</a> (September 2009)\n\u2014 531\u00a0MB covering years -3000 through 3000</li>\n<li><a href=\"http://pypi.python.org/pypi/de423\" rel=\"nofollow\">DE423</a> (February 2010)\n\u2014 36\u00a0MB covering years 1800 through 2200</li>\n</ul>\n</div>\n<div id=\"reporting-issues\">\n<h2>Reporting issues</h2>\n<p>You can report any issues, bugs, or problems at the GitHub repository:</p>\n<p><a href=\"https://github.com/brandon-rhodes/python-jplephem/\" rel=\"nofollow\">https://github.com/brandon-rhodes/python-jplephem/</a></p>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<p><strong>2020 March 26 \u2014 Version 2.14</strong></p>\n<ul>\n<li>Fall back to plain file I/O on platforms that support <tt>fileno()</tt> but\nthat don\u2019t support <tt>mmap()</tt>, like the <a href=\"https://github.com/iodide-project/pyodide\" rel=\"nofollow\">Pyodide platform</a>.</li>\n</ul>\n<p><strong>2020 February 22 \u2014 Version 2.13</strong></p>\n<ul>\n<li>The exception raised when a segment is given a Julian date outside the\nsegment\u2019s date range is now an instance of the <tt>ValueError</tt> subclass\n<tt>OutOfRangeError</tt> that reminds the caller of the range of dates\nsupported by the SPK segment, and carries an array attribute\nindicating which input dates were at fault.</li>\n</ul>\n<p><strong>2019 December 13 \u2014 Version 2.12</strong></p>\n<ul>\n<li>Replaced use of NumPy <tt>flip()</tt> with a reverse slice <tt><span class=\"pre\">[::-1]</span></tt> after\ndiscovering the function was a recent addition that some user installs\nof NumPy do not support.</li>\n</ul>\n<p><strong>2019 December 13 \u2014 Version 2.11</strong></p>\n<ul>\n<li>Reverse the order in which Chebyshev polynomials are computed to\nslightly increase speed, to simplify the code, and in one case\n(comparing PCK output to NASA) to gain a partial digit of extra\nprecision.</li>\n</ul>\n<p><strong>2019 December 11 \u2014 Version 2.10</strong></p>\n<ul>\n<li>Document and release support for <tt>.bcp</tt> binary PCK kernel files\nthrough the new <tt>jplephem.pck</tt> module.</li>\n</ul>\n<p><strong>2019 January 3 \u2014 Version 2.9</strong></p>\n<ul>\n<li>Added the <tt>load_array()</tt> method to the segment class.</li>\n</ul>\n<p><strong>2018 July 22 \u2014 Version 2.8</strong></p>\n<ul>\n<li>Switched to a making a single memory map of the entire file, to avoid\nrunning out of file descriptors when users load an ephemeris with\nhundreds of segments.</li>\n</ul>\n<p><strong>2018 February 11 \u2014 Version 2.7</strong></p>\n<ul>\n<li>Expanded the command line tool, most notably with the ability to fetch\nover HTTP only those sections of a large ephemeris that cover a\nspecific range of dates, producing a smaller <tt>.bsp</tt> file.</li>\n</ul>\n<p><strong>2016 December 19 \u2014 Version 2.6</strong></p>\n<ul>\n<li>Fixed the ability to invoke the module from the command line with\n<tt>python <span class=\"pre\">-m</span> jplephem</tt>, and added a test to keep it fixed.</li>\n</ul>\n<p><strong>2015 November 9 \u2014 Version 2.5</strong></p>\n<ul>\n<li>Move <tt>fileno()</tt> call out of the <tt>DAF</tt> constructor to support\nfetching at least summary information from <tt>StringIO</tt> objects.</li>\n</ul>\n<p><strong>2015 November 1 \u2014 Version 2.4</strong></p>\n<ul>\n<li>Add Windows compatibility by switching <tt>mmap()</tt> from using\n<tt>PAGESIZE</tt> to <tt>ALLOCATIONGRANULARITY</tt>.</li>\n<li>Avoid a new NumPy deprecation warning by being careful to use only\nintegers in the NumPy <tt>shape</tt> tuple.</li>\n<li>Add names \u201cTDB\u201d and \u201cTT\u201d to the names database for DE430.</li>\n</ul>\n<p><strong>2015 August 16 \u2014 Version 2.3</strong></p>\n<ul>\n<li>Added auto-detection and support for old NAIF/DAF kernels like\n<tt>de405.bsp</tt> to the main <tt>DAF</tt> class itself, instead of requiring\nthe awkward use of an entirely different alternative class.</li>\n</ul>\n<p><strong>2015 August 5 \u2014 Version 2.2</strong></p>\n<ul>\n<li>You can now invoke <tt>jplephem</tt> from the command line.</li>\n<li>Fixes an exception that was raised for SPK segments with a coefficient\ncount of only 2, like the DE421 and DE430 segments that provide the\noffset of Mercury from the Mercury barycenter.</li>\n<li>Supports old NAIF/DAF kernels like <tt>de405.bsp</tt>.</li>\n<li>The <tt>SPK()</tt> constructor is now simpler, taking a <tt>DAF</tt> object\ninstead of an open file.  This is considered an internal API change \u2014\nthe public API is the constructor <tt>SPK.open()</tt>.</li>\n</ul>\n<p><strong>2015 February 24 \u2014 Version 2.1</strong></p>\n<ul>\n<li>Switched from mapping an entire SPK file into memory at once to\nmemory-mapping each segment separately on demand.</li>\n</ul>\n<p><strong>2015 February 8 \u2014 Version 2.0</strong></p>\n<ul>\n<li>Added support for SPICE SPK kernel files downloaded directly from\nNASA, and designated old Python-packaged ephemerides as \u201clegacy.\u201d</li>\n</ul>\n<p><strong>2013 November 26 \u2014 Version 1.2</strong></p>\n<ul>\n<li>Helge Eichhorn fixed the default for the <tt>position_and_velocity()</tt>\nargument <tt>tdb2</tt> so it defaults to zero days instead of 2.0 days.\nTests were added to prevent any future regression.</li>\n</ul>\n<p><strong>2013 July 10 \u2014 Version 1.1</strong></p>\n<ul>\n<li>Deprecates the old <tt>compute()</tt> method in favor of separate\n<tt>position()</tt> and <tt>position_and_velocity()</tt> methods.</li>\n<li>Supports computing position and velocity in two separate phases by\nsaving a \u201cbundle\u201d of coefficients returned by <tt>compute_bundle()</tt>.</li>\n<li>From Marten van Kerkwijk: a second <tt>tdb2</tt> time argument, for users\nwho want to build higher precision dates out of two 64-bit floats.</li>\n</ul>\n<p><strong>2013 January 18 \u2014 Version 1.0</strong></p>\n<ul>\n<li>Initial release</li>\n</ul>\n</div>\n<div id=\"references\">\n<h2>References</h2>\n<p>The Jet Propulsion Laboratory\u2019s \u201cSolar System Dynamics\u201d page introduces\nthe various options for doing solar system position computations:\n<a href=\"http://ssd.jpl.nasa.gov/?ephemerides\" rel=\"nofollow\">http://ssd.jpl.nasa.gov/?ephemerides</a></p>\n<p>The plain ASCII format element sets from which the <tt>jplephem</tt> Python\nephemeris packages are built, along with documentation, can be found at:\n<a>ftp://ssd.jpl.nasa.gov/pub/eph/planets/ascii/</a></p>\n<p>Equivalent FORTRAN code for using the ephemerides be found at the same\nFTP site: <a>ftp://ssd.jpl.nasa.gov/pub/eph/planets/fortran/</a></p>\n</div>\n\n          </div>"}, "last_serial": 6889438, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "a68973076251c407666b67e1a59bf411", "sha256": "154f894b18f770759a0ef63594fbc43c0664cf11eb376bb56494d84169330cf0"}, "downloads": -1, "filename": "jplephem-0.1.tar.gz", "has_sig": false, "md5_digest": "a68973076251c407666b67e1a59bf411", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3763, "upload_time": "2012-03-30T18:28:01", "upload_time_iso_8601": "2012-03-30T18:28:01.348839Z", "url": "https://files.pythonhosted.org/packages/01/a3/10917715ffc512043e8221083c800f7fc9ecf7b26291c32b60f401f6a6b1/jplephem-0.1.tar.gz", "yanked": false}], "1.0": [{"comment_text": "", "digests": {"md5": "5336db6641d37e62bffb1d467df8e6f7", "sha256": "932e03d9ea000682938540564116d1772746fc6811a30d16880a0c6e04d18b3a"}, "downloads": -1, "filename": "jplephem-1.0.tar.gz", "has_sig": false, "md5_digest": "5336db6641d37e62bffb1d467df8e6f7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5481, "upload_time": "2013-01-18T16:42:03", "upload_time_iso_8601": "2013-01-18T16:42:03.933080Z", "url": "https://files.pythonhosted.org/packages/e7/f5/0cc12eb9a6ac35be8051fd4cfd56a86e3c0010a7df2c47fd95be618d562c/jplephem-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "76daa26dbc508a8e1916889fc9b83f1e", "sha256": "5dfc842fa704ce6762904534b8790b6059ae209ab8c57f88903eaea17c7681d5"}, "downloads": -1, "filename": "jplephem-1.1.tar.gz", "has_sig": false, "md5_digest": "76daa26dbc508a8e1916889fc9b83f1e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9228, "upload_time": "2013-07-10T22:41:42", "upload_time_iso_8601": "2013-07-10T22:41:42.779024Z", "url": "https://files.pythonhosted.org/packages/0b/79/0aeb12c2e6ea8356231c7ffd68cd356ee4e793f2cd5b3771c4c31cf3113c/jplephem-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "99325441f9cd0c3d821ae7728e20ac04", "sha256": "66f3c2a33d71f6705c479873c3c077065bc9a69ec97290fba9255701e69d6daa"}, "downloads": -1, "filename": "jplephem-1.2.tar.gz", "has_sig": false, "md5_digest": "99325441f9cd0c3d821ae7728e20ac04", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9448, "upload_time": "2013-11-26T22:56:23", "upload_time_iso_8601": "2013-11-26T22:56:23.658801Z", "url": "https://files.pythonhosted.org/packages/cc/cf/c0f30d11e0d95b6e82e5a4dc7994a6939846e32a139e1e4b5b78e93a0727/jplephem-1.2.tar.gz", "yanked": false}], "2.0": [{"comment_text": "", "digests": {"md5": "d641b36f3ddb486cd99d3fed67ff691d", "sha256": "5b4d449f568f6f396a75368645d9e78b83132356ea31a0b1114f0ae69d233343"}, "downloads": -1, "filename": "jplephem-2.0.tar.gz", "has_sig": false, "md5_digest": "d641b36f3ddb486cd99d3fed67ff691d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21126, "upload_time": "2015-02-08T20:23:44", "upload_time_iso_8601": "2015-02-08T20:23:44.269139Z", "url": "https://files.pythonhosted.org/packages/9c/0f/8f1ad79fe13b113d139de830f69e5017dc21634d4caf0edfd5223073e33a/jplephem-2.0.tar.gz", "yanked": false}], "2.1": [{"comment_text": "", "digests": {"md5": "d20989d5ea2fea493805a9d11ec02aae", "sha256": "d4ba2ca6a8db1eb4b06726b8d797ef0612b68780a33ef84c80b07979bf3757ec"}, "downloads": -1, "filename": "jplephem-2.1.tar.gz", "has_sig": false, "md5_digest": "d20989d5ea2fea493805a9d11ec02aae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24187, "upload_time": "2015-02-24T06:56:39", "upload_time_iso_8601": "2015-02-24T06:56:39.242066Z", "url": "https://files.pythonhosted.org/packages/71/76/ca14da0d858ede740973deb96bd6320a594d55063fba30c0d0477c6c61f0/jplephem-2.1.tar.gz", "yanked": false}], "2.10": [{"comment_text": "", "digests": {"md5": "47a06010a181769d2c7e8066f0ee07b8", "sha256": "d8a6a249b33f7a1d34d3a9ca90be9566609212ecd2e8a45d3becd29888d28133"}, "downloads": -1, "filename": "jplephem-2.10.tar.gz", "has_sig": false, "md5_digest": "47a06010a181769d2c7e8066f0ee07b8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32002, "upload_time": "2019-12-11T20:39:59", "upload_time_iso_8601": "2019-12-11T20:39:59.682815Z", "url": "https://files.pythonhosted.org/packages/08/7a/0075397153608aca70ab5289610952006b782653f1aec9277adbc13bc960/jplephem-2.10.tar.gz", "yanked": false}], "2.11": [{"comment_text": "", "digests": {"md5": "2a425f939f6e770020424b7798b0f574", "sha256": "32254d2facd99811f3c3f299f82ed5cc457e9debdcd8873f03643cfc1591bc82"}, "downloads": -1, "filename": "jplephem-2.11.tar.gz", "has_sig": false, "md5_digest": "2a425f939f6e770020424b7798b0f574", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32408, "upload_time": "2019-12-13T14:09:15", "upload_time_iso_8601": "2019-12-13T14:09:15.785633Z", "url": "https://files.pythonhosted.org/packages/00/70/d6f31d1e3bdc43d170280426a8a91dcbba1a1698360695424b198e567de5/jplephem-2.11.tar.gz", "yanked": false}], "2.12": [{"comment_text": "", "digests": {"md5": "e81d20a5d5978ee15d4ef59d71168e58", "sha256": "35a3b67444c7b03433e5ffff89fe10fd78d9bc88c12aafd001631227a1782023"}, "downloads": -1, "filename": "jplephem-2.12.tar.gz", "has_sig": false, "md5_digest": "e81d20a5d5978ee15d4ef59d71168e58", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32501, "upload_time": "2019-12-13T21:05:22", "upload_time_iso_8601": "2019-12-13T21:05:22.706706Z", "url": "https://files.pythonhosted.org/packages/80/f8/153e45b24bffd0121790a23ac34bfe84a3f28c92fea017310624592f8101/jplephem-2.12.tar.gz", "yanked": false}], "2.13": [{"comment_text": "", "digests": {"md5": "f760f7a5426f2980c065aeb896554986", "sha256": "17685ac008cfc35e1fdde33477eca730dad75c8cd3e1505aedf49ac3e322cecc"}, "downloads": -1, "filename": "jplephem-2.13.tar.gz", "has_sig": false, "md5_digest": "f760f7a5426f2980c065aeb896554986", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33427, "upload_time": "2020-02-22T16:42:56", "upload_time_iso_8601": "2020-02-22T16:42:56.804432Z", "url": "https://files.pythonhosted.org/packages/9a/2c/f50972e9e579a988a64bde55014eb6d8d13f1c5358189b9f7c93c24ca1f8/jplephem-2.13.tar.gz", "yanked": false}], "2.14": [{"comment_text": "", "digests": {"md5": "0d8110950fcca5ee1f74e889bdedb277", "sha256": "316aa8ebb6d13fd2158c06b2709bcde382d04bf63bb1e48d0bce89937088c6e3"}, "downloads": -1, "filename": "jplephem-2.14.tar.gz", "has_sig": false, "md5_digest": "0d8110950fcca5ee1f74e889bdedb277", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33674, "upload_time": "2020-03-26T16:42:07", "upload_time_iso_8601": "2020-03-26T16:42:07.945324Z", "url": "https://files.pythonhosted.org/packages/6c/5b/f3228acdd1b7bba4573d2ea816a8da3193c03b16fe1b4955892cf663abc2/jplephem-2.14.tar.gz", "yanked": false}], "2.2": [{"comment_text": "", "digests": {"md5": "b2b5ab962edb9256ad50eac9778d2759", "sha256": "67a7d2c941b5646d547fac807e7a8d99e7c98d4b81af66b00d25bac767768823"}, "downloads": -1, "filename": "jplephem-2.2.tar.gz", "has_sig": false, "md5_digest": "b2b5ab962edb9256ad50eac9778d2759", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26206, "upload_time": "2015-08-05T15:18:15", "upload_time_iso_8601": "2015-08-05T15:18:15.834678Z", "url": "https://files.pythonhosted.org/packages/c1/23/7f14d50c703564230abe9852c222b22e2d4988d0b348130f79a075a15b99/jplephem-2.2.tar.gz", "yanked": false}], "2.3": [{"comment_text": "", "digests": {"md5": "33ab33cf9725f2dad6bae70d53015a6b", "sha256": "a82759772221b80c04f2fa4085553028c5e33574da04634afabd899f4164bef8"}, "downloads": -1, "filename": "jplephem-2.3.tar.gz", "has_sig": false, "md5_digest": "33ab33cf9725f2dad6bae70d53015a6b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26194, "upload_time": "2015-08-17T06:03:50", "upload_time_iso_8601": "2015-08-17T06:03:50.198600Z", "url": "https://files.pythonhosted.org/packages/22/5c/479d7f19033090cddc40c94ac4ad25faf9d8347af50634ceeabd313f176b/jplephem-2.3.tar.gz", "yanked": false}], "2.4": [{"comment_text": "", "digests": {"md5": "e0abab66562f00d21fe9e0e8ccf11a57", "sha256": "36d80594acfebb3bc77685815700538e82d40bad203e824b72f26a6c06218711"}, "downloads": -1, "filename": "jplephem-2.4.tar.gz", "has_sig": false, "md5_digest": "e0abab66562f00d21fe9e0e8ccf11a57", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26527, "upload_time": "2015-11-02T02:22:25", "upload_time_iso_8601": "2015-11-02T02:22:25.365886Z", "url": "https://files.pythonhosted.org/packages/a6/6d/9fc3e6438e96a975d3ac52b7479d17e75739222b347440480151f68698b0/jplephem-2.4.tar.gz", "yanked": false}], "2.5": [{"comment_text": "", "digests": {"md5": "2880f4a443cbc3ec3c9d90a9bc8e7d22", "sha256": "a0ecf3b0f1891d616e78d51592c77452d93c6117562c406faf9a03f7134885a5"}, "downloads": -1, "filename": "jplephem-2.5.tar.gz", "has_sig": false, "md5_digest": "2880f4a443cbc3ec3c9d90a9bc8e7d22", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26977, "upload_time": "2015-11-09T21:55:19", "upload_time_iso_8601": "2015-11-09T21:55:19.715176Z", "url": "https://files.pythonhosted.org/packages/13/3d/21349c3ff1240a0f50fe8019c7e675e14706e094f651ea495cacd55a4987/jplephem-2.5.tar.gz", "yanked": false}], "2.6": [{"comment_text": "", "digests": {"md5": "5959775cba483a88dd879a74e0b52971", "sha256": "b1be79d85d7a2fa06a122c979ab0d30d7a0c295e8c197b05c85d16a5484b2143"}, "downloads": -1, "filename": "jplephem-2.6.tar.gz", "has_sig": false, "md5_digest": "5959775cba483a88dd879a74e0b52971", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27587, "upload_time": "2016-12-20T05:40:01", "upload_time_iso_8601": "2016-12-20T05:40:01.256965Z", "url": "https://files.pythonhosted.org/packages/bc/7a/87f083aa15b1f5b20c335e875d76e5ce9065a6438adbea5c4dec9ed66632/jplephem-2.6.tar.gz", "yanked": false}], "2.7": [{"comment_text": "", "digests": {"md5": "fd8e19e397a5751f1e3bd6b936272b1a", "sha256": "328d8561ee4189f259d9a807a01b3f2b5a4ff91484b79f5cf6f99cab3354c825"}, "downloads": -1, "filename": "jplephem-2.7.tar.gz", "has_sig": false, "md5_digest": "fd8e19e397a5751f1e3bd6b936272b1a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32731, "upload_time": "2018-02-11T20:36:49", "upload_time_iso_8601": "2018-02-11T20:36:49.089466Z", "url": "https://files.pythonhosted.org/packages/96/99/566e13fb57d293d37e8d001c35894236720540b1509964fb02b23258b964/jplephem-2.7.tar.gz", "yanked": false}], "2.8": [{"comment_text": "", "digests": {"md5": "1c792b9da8e26653bfe63d2a0327c08e", "sha256": "ccb21595d59867dff5aaddd9fb812ce2e870c26a65e161e310bb85e819e4a1d6"}, "downloads": -1, "filename": "jplephem-2.8.tar.gz", "has_sig": false, "md5_digest": "1c792b9da8e26653bfe63d2a0327c08e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32899, "upload_time": "2018-07-22T20:17:41", "upload_time_iso_8601": "2018-07-22T20:17:41.039744Z", "url": "https://files.pythonhosted.org/packages/97/85/b4e37409c586ce0735f142d677458ed0b661c645064cb5bd05b4f54f3981/jplephem-2.8.tar.gz", "yanked": false}], "2.9": [{"comment_text": "", "digests": {"md5": "d30bb040b155ce6dcbfa94d5f6abe80b", "sha256": "9dffb9f3d3f6d996ade875102431fe385e8ea422da25c8ba17b0508d9ca1282b"}, "downloads": -1, "filename": "jplephem-2.9.tar.gz", "has_sig": false, "md5_digest": "d30bb040b155ce6dcbfa94d5f6abe80b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31494, "upload_time": "2019-01-04T04:35:00", "upload_time_iso_8601": "2019-01-04T04:35:00.623652Z", "url": "https://files.pythonhosted.org/packages/14/6f/354fd50e625a66c7be3f08095c0e1fa389c75453858acf2689ffa9c4fc54/jplephem-2.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0d8110950fcca5ee1f74e889bdedb277", "sha256": "316aa8ebb6d13fd2158c06b2709bcde382d04bf63bb1e48d0bce89937088c6e3"}, "downloads": -1, "filename": "jplephem-2.14.tar.gz", "has_sig": false, "md5_digest": "0d8110950fcca5ee1f74e889bdedb277", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33674, "upload_time": "2020-03-26T16:42:07", "upload_time_iso_8601": "2020-03-26T16:42:07.945324Z", "url": "https://files.pythonhosted.org/packages/6c/5b/f3228acdd1b7bba4573d2ea816a8da3193c03b16fe1b4955892cf663abc2/jplephem-2.14.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:09 2020"}