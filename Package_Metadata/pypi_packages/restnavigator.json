{"info": {"author": "Josh Kuhn", "author_email": "deontologician@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 6 - Mature", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.0", "Programming Language :: Python :: 3.1", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Topic :: Software Development :: Libraries", "Topic :: Utilities"], "description": "REST Navigator\r\n==============\r\n\r\n|Build Status| |Coverage Status| |Pypi Status| |Documentation Status|\r\n\r\nREST Navigator is a python library for interacting with hypermedia apis\r\n(`REST level\r\n3 <http://martinfowler.com/articles/richardsonMaturityModel.html#level3>`__).\r\nRight now, it only supports\r\n`HAL+JSON <http://tools.ietf.org/html/draft-kelly-json-hal-05>`__ but it\r\nshould be general enough to extend to other formats eventually. Its\r\nfirst goal is to make interacting with HAL hypermedia apis as painless\r\nas possible, while discouraging REST anti-patterns.\r\n\r\nTo install it, simply use pip:\r\n\r\n.. code:: bash\r\n\r\n    $ pip install restnavigator\r\n\r\nContents\r\n--------\r\n\r\n-  `How to use it <#how-to-use-it>`__\r\n\r\n   -  `Links <#links>`__\r\n   -  `GET requests <#get-requests>`__\r\n   -  `Link relation docs <#link-relation-docs>`__\r\n   -  `POST requests <#post-requests>`__\r\n   -  `Errors <#errors>`__\r\n   -  `Templated links <#templated-links>`__\r\n   -  `Authentication <#authentication>`__\r\n\r\n-  `Additional Topics <#additional-topics>`__\r\n\r\n   -  `Identity Map <#identity-map>`__\r\n   -  `Iterating over a Navigator <#iterating-over-a-navigator>`__\r\n   -  `Headers (Request vs. Response) <#headers-request-vs-response>`__\r\n   -  `Bracket mini-language <#bracket-minilanguage>`__\r\n   -  `Finding the right link <#finding-the-right-link>`__\r\n   -  `Default curie <#default-curie>`__\r\n   -  `Specifying an api name <#specifying-an-api-name>`__\r\n   -  `Embedded documents <#embedded-documents>`__\r\n\r\n-  `Development <#development>`__\r\n\r\n   -  `Testing <#testing>`__\r\n   -  `Planned for the future <#planned-for-the-future>`__\r\n\r\n.. raw:: html\r\n\r\n   <!-- end toc -->\r\n\r\nHow to use it\r\n-------------\r\n\r\nTo begin interacting with a HAL api, you've got to create a HALNavigator\r\nthat points to the api root. Ideally, in a hypermedia API, the root URL\r\nis the only URL that needs to be hardcoded in your application. All\r\nother URLs are obtained from the api responses themselves (think of your\r\napi client as 'clicking on links', rather than having the urls\r\nhardcoded).\r\n\r\nAs an example, we'll connect to the haltalk api.\r\n\r\n.. code:: python\r\n\r\n    >>> from restnavigator import Navigator\r\n    >>> N = Navigator.hal('http://haltalk.herokuapp.com/', default_curie=\"ht\")\r\n    >>> N\r\n    HALNavigator(Haltalk)\r\n\r\nLinks\r\n~~~~~\r\n\r\nUsually, with the index (normally at the api root), you're most\r\ninterested in the links. Let's look at those:\r\n\r\n.. code:: python\r\n\r\n    >>> N.links()\r\n    {u'ht:users': HALNavigator(Haltalk.users),\r\n     u'ht:signup': HALNavigator(Haltalk.signup),\r\n     u'ht:me': TemplatedThunk(Haltalk.users.{name}),\r\n     u'ht:latest-posts': HALNavigator(Haltalk.posts.latest)}\r\n\r\n(This may take a moment because asking for the links causes the\r\nHALNavigator to actually request the resource from the server).\r\n\r\nHere we can see that the links are organized by their relation type (the\r\nkey), and each key corresponds to a new HALNavigator that represents\r\nsome other resource. Relation types are extremely important in restful\r\napis: we need them to be able to determine what a link means in relation\r\nto the current resource, in a way that is automatable.\r\n\r\nGET requests\r\n~~~~~~~~~~~~\r\n\r\nIn addition, the root has some state associated with it which you can\r\nget in two different ways:\r\n\r\n.. code:: python\r\n\r\n    >>> N() # cached state of resource (obtained when we looked at N.links)\r\n    {u'hint_1': u'You need an account to post stuff..',\r\n     u'hint_2': u'Create one by POSTing via the ht:signup link..',\r\n     u'hint_3': u'Click the orange buttons on the right to make POST requests..',\r\n     u'hint_4': u'Click the green button to follow a link with a GET request..',\r\n     u'hint_5': u'Click the book icon to read docs for the link relation.',\r\n     u'welcome': u'Welcome to a haltalk server.'}\r\n    >>> N.fetch() # will refetch the resource from the server\r\n    {u'hint_1': u'You need an account to post stuff..',\r\n     u'hint_2': u'Create one by POSTing via the ht:signup link..',\r\n     u'hint_3': u'Click the orange buttons on the right to make POST requests..',\r\n     u'hint_4': u'Click the green button to follow a link with a GET request..',\r\n     u'hint_5': u'Click the book icon to read docs for the link relation.',\r\n     u'welcome': u'Welcome to a haltalk server.'}\r\n\r\nCalling a HALNavigator will execute a GET request against the resource\r\nand returns its value (which it will cache).\r\n\r\nLink relation docs\r\n~~~~~~~~~~~~~~~~~~\r\n\r\nLet's register a hal talk account. Unfortunately, we don't really know\r\nhow to do that, so let's look at the documentation. The ``ht:signup``\r\nlink looks promising, let's check that:\r\n\r\n.. code:: python\r\n\r\n    >>> N.docsfor('ht:signup')\r\n\r\nA browser will open to http://haltalk.herokuapp.com/rels/signup.\r\n\r\nWhat? Popping up a browser from a library call? Yes, that's how\r\nrest\\_navigator rolls. The way we see it: docs are for humans, and while\r\ncustom rel-types are URIs, they shouldn't automatically be dereferenced\r\nby a program that interacts with the api. So popping up a browser serves\r\ntwo purposes:\r\n\r\n1. It allows easy access to the documentation at the time when you most\r\n   need it: when you're mucking about in the command line trying to\r\n   figure out how to interact with the api.\r\n2. It reminds you not to try to automatically dereference the rel\r\n   documentation and parse it in your application.\r\n\r\nIf you need a more robust way to browse the api and the documentation,\r\n`HAL Browser <https://github.com/mikekelly/hal-browser>`__ is probably\r\nyour best bet.\r\n\r\nPOST requests\r\n~~~~~~~~~~~~~\r\n\r\nThe docs for ``ht:signup`` explain the format of the POST request to\r\nsign up. So let's actually sign up. Since we've set ``\"ht\"`` as our\r\ndefault curie, we can skip typing the curie for convenience. (Note:\r\nhaltalk is a toy api for example purposes, don't ever send plaintext\r\npasswords over an unencrypted connection in a real app!):\r\n\r\n.. code:: python\r\n\r\n    >>> fred23 = N['signup'].create(\r\n    ... {'username': 'fred23',\r\n    ...  'password': 'hunter2',\r\n    ...  'real_name': 'Fred 23'}\r\n    ... )\r\n    >>> fred23\r\n    HALNavigator(Haltalk.users.fred23)\r\n\r\nErrors\r\n~~~~~~\r\n\r\nIf the user name had already been in use, a 400 would have been returned\r\nfrom the haltalk api. rest\\_navigator follows the Zen of Python\r\nguideline \"Errors should never pass silently\". An exception would have\r\nbeen raised on a 400 or 500 status code. You can squelch this exception\r\nand just have the post call return a ``HALNavigator`` with a 400/500\r\nstatus code if you want:\r\n\r\n.. code:: python\r\n\r\n    >>> dup_signup = N['ht:signup'].create({\r\n    ...    'username': 'fred23',\r\n    ...    'password': 'hunter2',\r\n    ...    'real_name': 'Fred Wilson'\r\n    ... }, raise_exc=False)\r\n    >>> dup_signup\r\n    OrphanHALNavigator(Haltalk.signup)  # 400!\r\n    >>> dup_signup.status\r\n    (400, 'Bad Request')\r\n    >>> dup_signup.state\r\n    {u\"errors\": {u\"username\": [u\"is already taken\"]}}\r\n\r\nTemplated links\r\n~~~~~~~~~~~~~~~\r\n\r\nNow that we've signed up, lets take a look at our profile. The link for\r\na user's profile is a templated link, which restnavigator represents as\r\na ``PartialNavigator``. Similar to python's\r\n`functools.partial <https://docs.python.org/2/library/functools.html#functools.partial>`__,\r\na ``PartialNavigator`` is an object that needs a few more arguments to\r\ngive you a full navigator back. Despite its name, it can't talk to the\r\nnetwork by itself. Its job is to to generate new navigators for you. You\r\ncan see what variables it has by looking at its ``.variables`` attribute\r\n(its ``__repr__`` hints at this as well):\r\n\r\n.. code:: python\r\n\r\n    >>> N.links().keys()\r\n    ['ht:latest-posts', 'ht:me', 'ht:users', 'ht:signup']\r\n    >>> N['ht:me']\r\n    PartialNavigator(Haltalk.users.{name})\r\n    >>> N['ht:me'].variables\r\n    set(['name'])\r\n\r\nThe documentation for the ``ht:me`` rel type should tell us how the name\r\nparameter is supposed to work, but in this case it's fairly obvious\r\n(plug in the username). Two provide the template parameters, just call\r\nit with keyword args:\r\n\r\n.. code:: python\r\n\r\n    >>> partial_me = N['ht:me']\r\n    >>> partial_me.template_uri\r\n    'http://haltalk.herokuapp.com/users/{name}'\r\n    >>> Fred = partial_me(name='fred23')\r\n    >>> Fred\r\n    HALNavigator('haltalk.users.fred23')\r\n\r\nNow that we have a real navigator, we can fetch the resource:\r\n\r\n.. code:: python\r\n\r\n    >>> Fred()\r\n    {u'bio': None, u'real_name': u'Fred Wilson', u'username': u'fred23'}\r\n\r\nAuthentication\r\n~~~~~~~~~~~~~~\r\n\r\nIn order to post something to haltalk, we need to authenticate with our\r\nnewly created account. HALNavigator allows any `authentication method\r\nthat requests\r\nsupports <http://www.python-requests.org/en/latest/user/advanced/#custom-authentication>`__\r\n(so OAuth etc). For basic auth (which haltalk uses), we can just pass a\r\ntuple.\r\n\r\n.. code:: python\r\n\r\n    >>> N.authenticate(('fred23', 'hunter2'))  # All subsequent calls are authenticated\r\n\r\nThis doesn't send anything to the server, it just sets the\r\nauthentication details that we'll use on the next request. Other\r\nauthentication methods may contact the server immediately.\r\n\r\nNow we can put it all together to create a new post:\r\n\r\n.. code:: python\r\n\r\n    >>> N_post = N['me'](name='fred23')['posts'].create({'content': 'My first post'})\r\n    >>> N_post\r\n    HALNavigator(Haltalk.posts.523670eff0e6370002000001)\r\n    >>> N_post()\r\n    {'content': 'My first post', 'created_at': '2015-06-13T19:38:59+00:00'}\r\n\r\nIt is also possible to specify a custom requests Session object when creating \r\na new navigator.\r\n\r\nFor example, if you want to talk to a OAuth2 protected api, simply pass \r\nan OAuth2 Session object that will be used for all requests \r\ndone by HALNavigator:\r\n\r\n.. code:: python\r\n\r\n    >>> from requests_oauthlib import OAuth2Session\r\n    >>> oauth2_session = OAuth2Session(r'client_id', token='token')\r\n    >>> N = Navigator.hal('https://api.example.com', session=oauth2_session)\r\n\r\nAdditional Topics\r\n-----------------\r\n\r\nIdentity Map\r\n~~~~~~~~~~~~\r\n\r\nYou don't need to worry about inadvertently having two different\r\nnavigators pointing to the same resource. rest\\_navigator will reuse the\r\nexisting navigator instead of creating a new one\r\n\r\nIterating over a Navigator\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nIf a resource has a link with the rel \"next\", the navigator for that\r\nresource can be used as a python iterator. It will automatically raise a\r\nStopIteration exception if a resource in the chain does not have a next\r\nlink. This makes moving through paged resources really simple and\r\npythonic:\r\n\r\n.. code:: python\r\n\r\n    post_navigator = fred['ht:posts']\r\n    for post in post_navigator:\r\n        # the first post will be post_navigator itself\r\n        print(post.state)\r\n\r\nHeaders (Request vs. Response)\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nHTTP response headers are available in ``N.response.headers``\r\n\r\nHeaders that will be sent on each request can be obtained through the\r\nsession:\r\n\r\n.. code:: python\r\n\r\n    >>> N.session.headers\r\n    # Cookies, etc\r\n\r\nBracket mini-language\r\n~~~~~~~~~~~~~~~~~~~~~\r\n\r\nThe bracket (``[]``) operator on Navigators has a lot of power. As we\r\nsaw earlier, the main use is to get a new Navigator from a link\r\nrelation:\r\n\r\n.. code:: python\r\n\r\n    >>> N2 = N['curie:link_rel']\r\n\r\nBut, it can also go more than one link deep, which is equivalent to\r\nusing multiple brackets in a row:\r\n\r\n.. code:: python\r\n\r\n    >>> N3 = N['curie:first_link', 'curie:second_link']\r\n    # equivalent to:\r\n    N3 = N['curie:first_link']['curie:second_link']\r\n\r\nAnd of course, if you set a default curie, you can omit it:\r\n\r\n.. code:: python\r\n\r\n    >>> N3 = N['first_link', 'second_link']\r\n\r\nInternally, this is completely equivalent to repeatedly applying the\r\nbracket operator, so you can even use it to jump over intermediate\r\nobjects that aren't Navigators themselves:\r\n\r\n.. code:: python\r\n\r\n    >>> N['some-link', 3, 'another-link']\r\n\r\nThis would use the ``some-link`` link relation, select the third link\r\nfrom the list, and then follow ``another-link`` from that resource.\r\n\r\nFinding the right link\r\n~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nNormally, you can chain together brackets to jump from one resource to\r\nanother in one go:\r\n\r\n.. code:: python\r\n\r\n    >>> N['ht:widget']['ht:gadget']\r\n\r\nThis will return a Navigator for the ``ht:widget`` link relation and\r\nthen immediately fetch the resource and return a Navigator for the\r\n``ht:gadget`` link relation. This works great if you have only one link\r\nper relation, but HAL allows multiple links per relation. Say for\r\ninstance we have some links like the following:\r\n\r\n.. code:: javascript{\r\n\r\n    \"ht:some_rel: [\r\n        {\r\n            \"href\": \"/api/widget/1\",\r\n            \"name\": \"widget1\",\r\n            \"profile\": \"widget\"\r\n        },\r\n        {\r\n            \"href\": \"/api/widget/2\",\r\n            \"name\": \"widget2\",\r\n            \"profile\": \"widget\"\r\n        },\r\n        {\r\n            \"href\": \"/api/gadget/1\",\r\n            \"name\": \"gadget1\",\r\n            \"profile\": \"gadget\"\r\n        }\r\n    ]\r\n\r\nWhen we go to get the ``ht:some_rel``, we'll get multiple results:\r\n\r\n.. code:: python\r\n\r\n    >>> N['ht:some_rel']\r\n    [HALNavigator(api.widget[1]),\r\n     HALNavigator(api.widget[2]),\r\n     HALNavigator(api.gadget[1])]\r\n\r\nHow do we know which one is the one we want? The `HAL\r\nspec <https://tools.ietf.org/html/draft-kelly-json-hal-06#section-5.5>`__\r\nsays links with the same rel can be disambiguated by the ``name`` link\r\nproperty:\r\n\r\n.. code:: python\r\n\r\n    >>> N.links['ht:some_rel'].get_by('name', 'gadget1')\r\n    HALNavigator(api.gadget[1])\r\n    >>> N.links['ht:some_rel'].named('gadget1')  # same as previous\r\n    HALNavigator(api.gadget[1])\r\n\r\nWe could also use other properties to slice and dice the list:\r\n\r\n.. code:: python\r\n\r\n    >>> N.links['ht:some_rel'].get_by('profile', 'gadget')\r\n    HALNavigator(api.gadget[1])\r\n    >>> N.links['ht:some_rel'].getall_by('profile', 'widget')\r\n    [HALNavigator(api.widget[1]), HALNavigator(api.widget[2])]\r\n\r\nThis works for any property on links, not just the standard HAL\r\nproperties.\r\n\r\nDefault curie\r\n~~~~~~~~~~~~~\r\n\r\nYou may specify a default curie when creating your Navigator:\r\n\r\n.. code:: python\r\n\r\n    >>> N = HALNavigator('http://haltalk.herokuapp.com', curie='ht')\r\n\r\nNow, when you follow links, you may leave off the default curie if you\r\nwant:\r\n\r\n.. code:: python\r\n\r\n    >>> N.links\r\n    {'ht:users': [HALNavigator(Haltalk.users)],\r\n     'ht:signup': [HALNavigator(Haltalk.signup)],\r\n     'ht:me': [HALNavigator(Haltalk.users.{name})],\r\n     'ht:latest-posts': [HALNavigator(Haltalk.posts.latest)]\r\n    }\r\n    >>> N['ht:users']\r\n    HALNavigator(Haltalk.users)\r\n    >>> N['users']\r\n    HALNavigator(Haltalk.users)\r\n\r\nThe only exception is where the key being supplied is a `IANA registered\r\nlink\r\nrelation <http://www.iana.org/assignments/link-relations/link-relations.xhtml>`__,\r\nand there is a conflict (hint: this should be quite rare):\r\n\r\n.. code:: python\r\n\r\n    >>> N.links\r\n    {'ht:next': HALNavigator(Haltalk.unregistered),\r\n      'next': HALNavigator(Haltalk.registered)}\r\n    >>> N['next']\r\n    HALNavigator(Haltalk.registered)\r\n\r\nSpecifying an api name\r\n~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nSometimes the automatic api naming guesses poorly. If you'd like to\r\noverride the default name, you can specify it when creating the\r\nnavigator:\r\n\r\n.. code:: python\r\n\r\n    >>> N = Navigator.hal('http://api.example.com', apiname='MySpecialAPI')\r\n    HALNavigator(MySpecialAPI)\r\n\r\nEmbedded documents\r\n~~~~~~~~~~~~~~~~~~\r\n\r\nIn rest\\_navigator, embedded documents are treated transparently. This\r\nmeans that in many cases you don't need to worry about whether a\r\ndocument is embedded or whether it's just linked.\r\n\r\nAs an example, assume we have a resource like the following:\r\n\r\n.. code:: json\r\n\r\n    {\r\n      \"_links\": {\r\n         ...\r\n         \"xx:yams\": {\r\n            \"href\": \"/yams\"\r\n         }\r\n         ...\r\n      },\r\n      \"_embedded\": {\r\n         \"xx:pickles\": {\r\n           \"_links\": {\r\n             \"self\": {\"href\": \"/pickles\"}\r\n           },\r\n           \"state\": \"A pickle\"\r\n         }\r\n      }\r\n      ...\r\n    }\r\n\r\nFrom here, you would access both the ``yams`` and the ``pickles``\r\nresource with normal bracket syntax:\r\n\r\n.. code:: python\r\n\r\n    >>> Yams = N['xx:yams']\r\n    >>> Pickles = N['xx:pickles']\r\n\r\nThe only difference here is that ``Yams`` hasn't been fetched yet, while\r\n``Pickles`` is considered \"resolved\" already because we got it as an\r\nembedded document.\r\n\r\n::\r\n\r\n    >>> Yams.resolved\r\n    False\r\n    >>> Yams.state # None\r\n    >>> Pickles.resolved\r\n    True\r\n    >>> Pickles.state\r\n    {'state': 'A pickle'}\r\n\r\nIf an embedded document has a self link, you can treat it just like you\r\nwould any other resource. So if you want to refresh the resource, it's\r\nas easy as:\r\n\r\n.. code:: python\r\n\r\n    >>> Pickles.fetch()\r\n\r\nThis will fetch the current state of the resource from the uri in its\r\nself link, even if you've never directly requested that uri before. If\r\nan embedded resource doesn't have a self link, it will be an\r\n``OrphanNavigator`` with the parent set to the resource it was embedded\r\nin.\r\n\r\nOf course, if you need to directly distinguish between linked resources\r\nand embedded resources, there is an out:\r\n\r\n.. code:: python\r\n\r\n    >>> N.embedded()\r\n    {'xx:pickles': HALNavigator(api.pickles)\r\n    >>> N.links()\r\n    {'xx:yams': HALNavigator(api.yams)\r\n\r\nHowever, when using the ``in`` operator, it will look in both for a key\r\nyou're interested in:\r\n\r\n.. code:: python\r\n\r\n    >>> 'yams' in N  # default curie is taken into account!\r\n    True\r\n    >>> 'xx:yams in N\r\n    True\r\n    >>> 'xx:pickles' in N\r\n    True\r\n\r\nDevelopment\r\n-----------\r\n\r\nTesting\r\n~~~~~~~\r\n\r\nTo run tests, first install the `pytest\r\nframework <http://pytest.org/latest/getting-started.html>`__:\r\n\r\n::\r\n\r\n    $ pip install -U pytest\r\n\r\nTo run tests, execute following from the root of the source directory:\r\n\r\n::\r\n\r\n    $ py.test\r\n\r\nPlanned for the future\r\n~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n-  Ability to add hooks for different types, rels and profiles. If a\r\n   link has one of these properties, it will call your hook when doing a\r\n   server call.\r\n-  Since HAL doesn't specify what content type POSTs, PUTs, and PATCHes\r\n   need to have, you can specify the hooks based on what the server will\r\n   accept. This can trigger off either the rel type of the link, or rest\r\n   navigator can do content negotiation over HTTP with the server\r\n   directly to see what content types that resource will accept.\r\n\r\nContributors\r\n~~~~~~~~~~~~\r\n\r\nThanks very much to rest navigator's contributors:\r\n\r\n-  `dudycooly <http://github.com/dudycooly>`__\r\n-  `bubenkoff <http://github.com/bubenkoff>`__\r\n-  `bbsgfalconer <http://github.com/bbsgfalconer>`__\r\n\r\n.. |Build Status| image:: https://img.shields.io/travis/deontologician/restnavigator/next.svg\r\n   :target: https://travis-ci.org/deontologician/restnavigator\r\n.. |Coverage Status| image:: https://img.shields.io/coveralls/deontologician/rest_navigator/next.svg\r\n   :target: https://coveralls.io/r/deontologician/rest_navigator?branch=next\r\n.. |Documentation Status| image:: https://readthedocs.org/projects/rest-navigator/badge/?version=latest\r\n   :target: https://readthedocs.org/projects/rest-navigator/?badge=latest\r\n   :alt: Documentation Status\r\n.. |Pypi Status| image:: https://pypip.in/v/restnavigator/badge.png\r\n   :target: https://crate.io/packages/restnavigator/\r\n\r\n\r\nChangelog\r\n=========\r\n\r\nUnreleased\r\n----------\r\n\r\n- TBD\r\n\r\n1.0\r\n---\r\n\r\n- Embedded support\r\n- Ability to specify default curies\r\n- Resources with no URL are now represented by a special Navigator type called OrphanNavigators\r\n- IP addresses can be used in the url (@dudycooly)\r\n- All tests pass in python 2.6 -> 3.4 (@bubenkoff), and travis now runs tox to ensure they stay that way\r\n- Support the DELETE, and PATCH methods\r\n- posts allow an empty body (@bbsgfalconer)\r\n- Much improved content negotiation (@bbsgfalconer)\r\n- There was also a major refactoring that changed how Navigators are created and internally cleaned up a\r\n    lot of really messy code.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/deontologician/rest_navigator", "keywords": "REST,HAL,json,http", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "restnavigator", "package_url": "https://pypi.org/project/restnavigator/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/restnavigator/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/deontologician/rest_navigator"}, "release_url": "https://pypi.org/project/restnavigator/1.0.1/", "requires_dist": null, "requires_python": null, "summary": "A python library for interacting with HAL+JSON APIs", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            REST Navigator\n<br>==============\n<br>\n<br>|Build Status| |Coverage Status| |Pypi Status| |Documentation Status|\n<br>\n<br>REST Navigator is a python library for interacting with hypermedia apis\n<br>(`REST level\n<br>3 &lt;http://martinfowler.com/articles/richardsonMaturityModel.html#level3&gt;`__).\n<br>Right now, it only supports\n<br>`HAL+JSON &lt;http://tools.ietf.org/html/draft-kelly-json-hal-05&gt;`__ but it\n<br>should be general enough to extend to other formats eventually. Its\n<br>first goal is to make interacting with HAL hypermedia apis as painless\n<br>as possible, while discouraging REST anti-patterns.\n<br>\n<br>To install it, simply use pip:\n<br>\n<br>.. code:: bash\n<br>\n<br>    $ pip install restnavigator\n<br>\n<br>Contents\n<br>--------\n<br>\n<br>-  `How to use it &lt;#how-to-use-it&gt;`__\n<br>\n<br>   -  `Links &lt;#links&gt;`__\n<br>   -  `GET requests &lt;#get-requests&gt;`__\n<br>   -  `Link relation docs &lt;#link-relation-docs&gt;`__\n<br>   -  `POST requests &lt;#post-requests&gt;`__\n<br>   -  `Errors &lt;#errors&gt;`__\n<br>   -  `Templated links &lt;#templated-links&gt;`__\n<br>   -  `Authentication &lt;#authentication&gt;`__\n<br>\n<br>-  `Additional Topics &lt;#additional-topics&gt;`__\n<br>\n<br>   -  `Identity Map &lt;#identity-map&gt;`__\n<br>   -  `Iterating over a Navigator &lt;#iterating-over-a-navigator&gt;`__\n<br>   -  `Headers (Request vs. Response) &lt;#headers-request-vs-response&gt;`__\n<br>   -  `Bracket mini-language &lt;#bracket-minilanguage&gt;`__\n<br>   -  `Finding the right link &lt;#finding-the-right-link&gt;`__\n<br>   -  `Default curie &lt;#default-curie&gt;`__\n<br>   -  `Specifying an api name &lt;#specifying-an-api-name&gt;`__\n<br>   -  `Embedded documents &lt;#embedded-documents&gt;`__\n<br>\n<br>-  `Development &lt;#development&gt;`__\n<br>\n<br>   -  `Testing &lt;#testing&gt;`__\n<br>   -  `Planned for the future &lt;#planned-for-the-future&gt;`__\n<br>\n<br>.. raw:: html\n<br>\n<br>   &lt;!-- end toc --&gt;\n<br>\n<br>How to use it\n<br>-------------\n<br>\n<br>To begin interacting with a HAL api, you've got to create a HALNavigator\n<br>that points to the api root. Ideally, in a hypermedia API, the root URL\n<br>is the only URL that needs to be hardcoded in your application. All\n<br>other URLs are obtained from the api responses themselves (think of your\n<br>api client as 'clicking on links', rather than having the urls\n<br>hardcoded).\n<br>\n<br>As an example, we'll connect to the haltalk api.\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; from restnavigator import Navigator\n<br>    &gt;&gt;&gt; N = Navigator.hal('http://haltalk.herokuapp.com/', default_curie=\"ht\")\n<br>    &gt;&gt;&gt; N\n<br>    HALNavigator(Haltalk)\n<br>\n<br>Links\n<br>~~~~~\n<br>\n<br>Usually, with the index (normally at the api root), you're most\n<br>interested in the links. Let's look at those:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.links()\n<br>    {u'ht:users': HALNavigator(Haltalk.users),\n<br>     u'ht:signup': HALNavigator(Haltalk.signup),\n<br>     u'ht:me': TemplatedThunk(Haltalk.users.{name}),\n<br>     u'ht:latest-posts': HALNavigator(Haltalk.posts.latest)}\n<br>\n<br>(This may take a moment because asking for the links causes the\n<br>HALNavigator to actually request the resource from the server).\n<br>\n<br>Here we can see that the links are organized by their relation type (the\n<br>key), and each key corresponds to a new HALNavigator that represents\n<br>some other resource. Relation types are extremely important in restful\n<br>apis: we need them to be able to determine what a link means in relation\n<br>to the current resource, in a way that is automatable.\n<br>\n<br>GET requests\n<br>~~~~~~~~~~~~\n<br>\n<br>In addition, the root has some state associated with it which you can\n<br>get in two different ways:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N() # cached state of resource (obtained when we looked at N.links)\n<br>    {u'hint_1': u'You need an account to post stuff..',\n<br>     u'hint_2': u'Create one by POSTing via the ht:signup link..',\n<br>     u'hint_3': u'Click the orange buttons on the right to make POST requests..',\n<br>     u'hint_4': u'Click the green button to follow a link with a GET request..',\n<br>     u'hint_5': u'Click the book icon to read docs for the link relation.',\n<br>     u'welcome': u'Welcome to a haltalk server.'}\n<br>    &gt;&gt;&gt; N.fetch() # will refetch the resource from the server\n<br>    {u'hint_1': u'You need an account to post stuff..',\n<br>     u'hint_2': u'Create one by POSTing via the ht:signup link..',\n<br>     u'hint_3': u'Click the orange buttons on the right to make POST requests..',\n<br>     u'hint_4': u'Click the green button to follow a link with a GET request..',\n<br>     u'hint_5': u'Click the book icon to read docs for the link relation.',\n<br>     u'welcome': u'Welcome to a haltalk server.'}\n<br>\n<br>Calling a HALNavigator will execute a GET request against the resource\n<br>and returns its value (which it will cache).\n<br>\n<br>Link relation docs\n<br>~~~~~~~~~~~~~~~~~~\n<br>\n<br>Let's register a hal talk account. Unfortunately, we don't really know\n<br>how to do that, so let's look at the documentation. The ``ht:signup``\n<br>link looks promising, let's check that:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.docsfor('ht:signup')\n<br>\n<br>A browser will open to http://haltalk.herokuapp.com/rels/signup.\n<br>\n<br>What? Popping up a browser from a library call? Yes, that's how\n<br>rest\\_navigator rolls. The way we see it: docs are for humans, and while\n<br>custom rel-types are URIs, they shouldn't automatically be dereferenced\n<br>by a program that interacts with the api. So popping up a browser serves\n<br>two purposes:\n<br>\n<br>1. It allows easy access to the documentation at the time when you most\n<br>   need it: when you're mucking about in the command line trying to\n<br>   figure out how to interact with the api.\n<br>2. It reminds you not to try to automatically dereference the rel\n<br>   documentation and parse it in your application.\n<br>\n<br>If you need a more robust way to browse the api and the documentation,\n<br>`HAL Browser &lt;https://github.com/mikekelly/hal-browser&gt;`__ is probably\n<br>your best bet.\n<br>\n<br>POST requests\n<br>~~~~~~~~~~~~~\n<br>\n<br>The docs for ``ht:signup`` explain the format of the POST request to\n<br>sign up. So let's actually sign up. Since we've set ``\"ht\"`` as our\n<br>default curie, we can skip typing the curie for convenience. (Note:\n<br>haltalk is a toy api for example purposes, don't ever send plaintext\n<br>passwords over an unencrypted connection in a real app!):\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; fred23 = N['signup'].create(\n<br>    ... {'username': 'fred23',\n<br>    ...  'password': 'hunter2',\n<br>    ...  'real_name': 'Fred 23'}\n<br>    ... )\n<br>    &gt;&gt;&gt; fred23\n<br>    HALNavigator(Haltalk.users.fred23)\n<br>\n<br>Errors\n<br>~~~~~~\n<br>\n<br>If the user name had already been in use, a 400 would have been returned\n<br>from the haltalk api. rest\\_navigator follows the Zen of Python\n<br>guideline \"Errors should never pass silently\". An exception would have\n<br>been raised on a 400 or 500 status code. You can squelch this exception\n<br>and just have the post call return a ``HALNavigator`` with a 400/500\n<br>status code if you want:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; dup_signup = N['ht:signup'].create({\n<br>    ...    'username': 'fred23',\n<br>    ...    'password': 'hunter2',\n<br>    ...    'real_name': 'Fred Wilson'\n<br>    ... }, raise_exc=False)\n<br>    &gt;&gt;&gt; dup_signup\n<br>    OrphanHALNavigator(Haltalk.signup)  # 400!\n<br>    &gt;&gt;&gt; dup_signup.status\n<br>    (400, 'Bad Request')\n<br>    &gt;&gt;&gt; dup_signup.state\n<br>    {u\"errors\": {u\"username\": [u\"is already taken\"]}}\n<br>\n<br>Templated links\n<br>~~~~~~~~~~~~~~~\n<br>\n<br>Now that we've signed up, lets take a look at our profile. The link for\n<br>a user's profile is a templated link, which restnavigator represents as\n<br>a ``PartialNavigator``. Similar to python's\n<br>`functools.partial &lt;https://docs.python.org/2/library/functools.html#functools.partial&gt;`__,\n<br>a ``PartialNavigator`` is an object that needs a few more arguments to\n<br>give you a full navigator back. Despite its name, it can't talk to the\n<br>network by itself. Its job is to to generate new navigators for you. You\n<br>can see what variables it has by looking at its ``.variables`` attribute\n<br>(its ``__repr__`` hints at this as well):\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.links().keys()\n<br>    ['ht:latest-posts', 'ht:me', 'ht:users', 'ht:signup']\n<br>    &gt;&gt;&gt; N['ht:me']\n<br>    PartialNavigator(Haltalk.users.{name})\n<br>    &gt;&gt;&gt; N['ht:me'].variables\n<br>    set(['name'])\n<br>\n<br>The documentation for the ``ht:me`` rel type should tell us how the name\n<br>parameter is supposed to work, but in this case it's fairly obvious\n<br>(plug in the username). Two provide the template parameters, just call\n<br>it with keyword args:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; partial_me = N['ht:me']\n<br>    &gt;&gt;&gt; partial_me.template_uri\n<br>    'http://haltalk.herokuapp.com/users/{name}'\n<br>    &gt;&gt;&gt; Fred = partial_me(name='fred23')\n<br>    &gt;&gt;&gt; Fred\n<br>    HALNavigator('haltalk.users.fred23')\n<br>\n<br>Now that we have a real navigator, we can fetch the resource:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; Fred()\n<br>    {u'bio': None, u'real_name': u'Fred Wilson', u'username': u'fred23'}\n<br>\n<br>Authentication\n<br>~~~~~~~~~~~~~~\n<br>\n<br>In order to post something to haltalk, we need to authenticate with our\n<br>newly created account. HALNavigator allows any `authentication method\n<br>that requests\n<br>supports &lt;http://www.python-requests.org/en/latest/user/advanced/#custom-authentication&gt;`__\n<br>(so OAuth etc). For basic auth (which haltalk uses), we can just pass a\n<br>tuple.\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.authenticate(('fred23', 'hunter2'))  # All subsequent calls are authenticated\n<br>\n<br>This doesn't send anything to the server, it just sets the\n<br>authentication details that we'll use on the next request. Other\n<br>authentication methods may contact the server immediately.\n<br>\n<br>Now we can put it all together to create a new post:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N_post = N['me'](name='fred23')['posts'].create({'content': 'My first post'})\n<br>    &gt;&gt;&gt; N_post\n<br>    HALNavigator(Haltalk.posts.523670eff0e6370002000001)\n<br>    &gt;&gt;&gt; N_post()\n<br>    {'content': 'My first post', 'created_at': '2015-06-13T19:38:59+00:00'}\n<br>\n<br>It is also possible to specify a custom requests Session object when creating \n<br>a new navigator.\n<br>\n<br>For example, if you want to talk to a OAuth2 protected api, simply pass \n<br>an OAuth2 Session object that will be used for all requests \n<br>done by HALNavigator:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; from requests_oauthlib import OAuth2Session\n<br>    &gt;&gt;&gt; oauth2_session = OAuth2Session(r'client_id', token='token')\n<br>    &gt;&gt;&gt; N = Navigator.hal('https://api.example.com', session=oauth2_session)\n<br>\n<br>Additional Topics\n<br>-----------------\n<br>\n<br>Identity Map\n<br>~~~~~~~~~~~~\n<br>\n<br>You don't need to worry about inadvertently having two different\n<br>navigators pointing to the same resource. rest\\_navigator will reuse the\n<br>existing navigator instead of creating a new one\n<br>\n<br>Iterating over a Navigator\n<br>~~~~~~~~~~~~~~~~~~~~~~~~~~\n<br>\n<br>If a resource has a link with the rel \"next\", the navigator for that\n<br>resource can be used as a python iterator. It will automatically raise a\n<br>StopIteration exception if a resource in the chain does not have a next\n<br>link. This makes moving through paged resources really simple and\n<br>pythonic:\n<br>\n<br>.. code:: python\n<br>\n<br>    post_navigator = fred['ht:posts']\n<br>    for post in post_navigator:\n<br>        # the first post will be post_navigator itself\n<br>        print(post.state)\n<br>\n<br>Headers (Request vs. Response)\n<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n<br>\n<br>HTTP response headers are available in ``N.response.headers``\n<br>\n<br>Headers that will be sent on each request can be obtained through the\n<br>session:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.session.headers\n<br>    # Cookies, etc\n<br>\n<br>Bracket mini-language\n<br>~~~~~~~~~~~~~~~~~~~~~\n<br>\n<br>The bracket (``[]``) operator on Navigators has a lot of power. As we\n<br>saw earlier, the main use is to get a new Navigator from a link\n<br>relation:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N2 = N['curie:link_rel']\n<br>\n<br>But, it can also go more than one link deep, which is equivalent to\n<br>using multiple brackets in a row:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N3 = N['curie:first_link', 'curie:second_link']\n<br>    # equivalent to:\n<br>    N3 = N['curie:first_link']['curie:second_link']\n<br>\n<br>And of course, if you set a default curie, you can omit it:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N3 = N['first_link', 'second_link']\n<br>\n<br>Internally, this is completely equivalent to repeatedly applying the\n<br>bracket operator, so you can even use it to jump over intermediate\n<br>objects that aren't Navigators themselves:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N['some-link', 3, 'another-link']\n<br>\n<br>This would use the ``some-link`` link relation, select the third link\n<br>from the list, and then follow ``another-link`` from that resource.\n<br>\n<br>Finding the right link\n<br>~~~~~~~~~~~~~~~~~~~~~~\n<br>\n<br>Normally, you can chain together brackets to jump from one resource to\n<br>another in one go:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N['ht:widget']['ht:gadget']\n<br>\n<br>This will return a Navigator for the ``ht:widget`` link relation and\n<br>then immediately fetch the resource and return a Navigator for the\n<br>``ht:gadget`` link relation. This works great if you have only one link\n<br>per relation, but HAL allows multiple links per relation. Say for\n<br>instance we have some links like the following:\n<br>\n<br>.. code:: javascript{\n<br>\n<br>    \"ht:some_rel: [\n<br>        {\n<br>            \"href\": \"/api/widget/1\",\n<br>            \"name\": \"widget1\",\n<br>            \"profile\": \"widget\"\n<br>        },\n<br>        {\n<br>            \"href\": \"/api/widget/2\",\n<br>            \"name\": \"widget2\",\n<br>            \"profile\": \"widget\"\n<br>        },\n<br>        {\n<br>            \"href\": \"/api/gadget/1\",\n<br>            \"name\": \"gadget1\",\n<br>            \"profile\": \"gadget\"\n<br>        }\n<br>    ]\n<br>\n<br>When we go to get the ``ht:some_rel``, we'll get multiple results:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N['ht:some_rel']\n<br>    [HALNavigator(api.widget[1]),\n<br>     HALNavigator(api.widget[2]),\n<br>     HALNavigator(api.gadget[1])]\n<br>\n<br>How do we know which one is the one we want? The `HAL\n<br>spec &lt;https://tools.ietf.org/html/draft-kelly-json-hal-06#section-5.5&gt;`__\n<br>says links with the same rel can be disambiguated by the ``name`` link\n<br>property:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.links['ht:some_rel'].get_by('name', 'gadget1')\n<br>    HALNavigator(api.gadget[1])\n<br>    &gt;&gt;&gt; N.links['ht:some_rel'].named('gadget1')  # same as previous\n<br>    HALNavigator(api.gadget[1])\n<br>\n<br>We could also use other properties to slice and dice the list:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.links['ht:some_rel'].get_by('profile', 'gadget')\n<br>    HALNavigator(api.gadget[1])\n<br>    &gt;&gt;&gt; N.links['ht:some_rel'].getall_by('profile', 'widget')\n<br>    [HALNavigator(api.widget[1]), HALNavigator(api.widget[2])]\n<br>\n<br>This works for any property on links, not just the standard HAL\n<br>properties.\n<br>\n<br>Default curie\n<br>~~~~~~~~~~~~~\n<br>\n<br>You may specify a default curie when creating your Navigator:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N = HALNavigator('http://haltalk.herokuapp.com', curie='ht')\n<br>\n<br>Now, when you follow links, you may leave off the default curie if you\n<br>want:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.links\n<br>    {'ht:users': [HALNavigator(Haltalk.users)],\n<br>     'ht:signup': [HALNavigator(Haltalk.signup)],\n<br>     'ht:me': [HALNavigator(Haltalk.users.{name})],\n<br>     'ht:latest-posts': [HALNavigator(Haltalk.posts.latest)]\n<br>    }\n<br>    &gt;&gt;&gt; N['ht:users']\n<br>    HALNavigator(Haltalk.users)\n<br>    &gt;&gt;&gt; N['users']\n<br>    HALNavigator(Haltalk.users)\n<br>\n<br>The only exception is where the key being supplied is a `IANA registered\n<br>link\n<br>relation &lt;http://www.iana.org/assignments/link-relations/link-relations.xhtml&gt;`__,\n<br>and there is a conflict (hint: this should be quite rare):\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.links\n<br>    {'ht:next': HALNavigator(Haltalk.unregistered),\n<br>      'next': HALNavigator(Haltalk.registered)}\n<br>    &gt;&gt;&gt; N['next']\n<br>    HALNavigator(Haltalk.registered)\n<br>\n<br>Specifying an api name\n<br>~~~~~~~~~~~~~~~~~~~~~~\n<br>\n<br>Sometimes the automatic api naming guesses poorly. If you'd like to\n<br>override the default name, you can specify it when creating the\n<br>navigator:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N = Navigator.hal('http://api.example.com', apiname='MySpecialAPI')\n<br>    HALNavigator(MySpecialAPI)\n<br>\n<br>Embedded documents\n<br>~~~~~~~~~~~~~~~~~~\n<br>\n<br>In rest\\_navigator, embedded documents are treated transparently. This\n<br>means that in many cases you don't need to worry about whether a\n<br>document is embedded or whether it's just linked.\n<br>\n<br>As an example, assume we have a resource like the following:\n<br>\n<br>.. code:: json\n<br>\n<br>    {\n<br>      \"_links\": {\n<br>         ...\n<br>         \"xx:yams\": {\n<br>            \"href\": \"/yams\"\n<br>         }\n<br>         ...\n<br>      },\n<br>      \"_embedded\": {\n<br>         \"xx:pickles\": {\n<br>           \"_links\": {\n<br>             \"self\": {\"href\": \"/pickles\"}\n<br>           },\n<br>           \"state\": \"A pickle\"\n<br>         }\n<br>      }\n<br>      ...\n<br>    }\n<br>\n<br>From here, you would access both the ``yams`` and the ``pickles``\n<br>resource with normal bracket syntax:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; Yams = N['xx:yams']\n<br>    &gt;&gt;&gt; Pickles = N['xx:pickles']\n<br>\n<br>The only difference here is that ``Yams`` hasn't been fetched yet, while\n<br>``Pickles`` is considered \"resolved\" already because we got it as an\n<br>embedded document.\n<br>\n<br>::\n<br>\n<br>    &gt;&gt;&gt; Yams.resolved\n<br>    False\n<br>    &gt;&gt;&gt; Yams.state # None\n<br>    &gt;&gt;&gt; Pickles.resolved\n<br>    True\n<br>    &gt;&gt;&gt; Pickles.state\n<br>    {'state': 'A pickle'}\n<br>\n<br>If an embedded document has a self link, you can treat it just like you\n<br>would any other resource. So if you want to refresh the resource, it's\n<br>as easy as:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; Pickles.fetch()\n<br>\n<br>This will fetch the current state of the resource from the uri in its\n<br>self link, even if you've never directly requested that uri before. If\n<br>an embedded resource doesn't have a self link, it will be an\n<br>``OrphanNavigator`` with the parent set to the resource it was embedded\n<br>in.\n<br>\n<br>Of course, if you need to directly distinguish between linked resources\n<br>and embedded resources, there is an out:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; N.embedded()\n<br>    {'xx:pickles': HALNavigator(api.pickles)\n<br>    &gt;&gt;&gt; N.links()\n<br>    {'xx:yams': HALNavigator(api.yams)\n<br>\n<br>However, when using the ``in`` operator, it will look in both for a key\n<br>you're interested in:\n<br>\n<br>.. code:: python\n<br>\n<br>    &gt;&gt;&gt; 'yams' in N  # default curie is taken into account!\n<br>    True\n<br>    &gt;&gt;&gt; 'xx:yams in N\n<br>    True\n<br>    &gt;&gt;&gt; 'xx:pickles' in N\n<br>    True\n<br>\n<br>Development\n<br>-----------\n<br>\n<br>Testing\n<br>~~~~~~~\n<br>\n<br>To run tests, first install the `pytest\n<br>framework &lt;http://pytest.org/latest/getting-started.html&gt;`__:\n<br>\n<br>::\n<br>\n<br>    $ pip install -U pytest\n<br>\n<br>To run tests, execute following from the root of the source directory:\n<br>\n<br>::\n<br>\n<br>    $ py.test\n<br>\n<br>Planned for the future\n<br>~~~~~~~~~~~~~~~~~~~~~~\n<br>\n<br>-  Ability to add hooks for different types, rels and profiles. If a\n<br>   link has one of these properties, it will call your hook when doing a\n<br>   server call.\n<br>-  Since HAL doesn't specify what content type POSTs, PUTs, and PATCHes\n<br>   need to have, you can specify the hooks based on what the server will\n<br>   accept. This can trigger off either the rel type of the link, or rest\n<br>   navigator can do content negotiation over HTTP with the server\n<br>   directly to see what content types that resource will accept.\n<br>\n<br>Contributors\n<br>~~~~~~~~~~~~\n<br>\n<br>Thanks very much to rest navigator's contributors:\n<br>\n<br>-  `dudycooly &lt;http://github.com/dudycooly&gt;`__\n<br>-  `bubenkoff &lt;http://github.com/bubenkoff&gt;`__\n<br>-  `bbsgfalconer &lt;http://github.com/bbsgfalconer&gt;`__\n<br>\n<br>.. |Build Status| image:: https://img.shields.io/travis/deontologician/restnavigator/next.svg\n<br>   :target: https://travis-ci.org/deontologician/restnavigator\n<br>.. |Coverage Status| image:: https://img.shields.io/coveralls/deontologician/rest_navigator/next.svg\n<br>   :target: https://coveralls.io/r/deontologician/rest_navigator?branch=next\n<br>.. |Documentation Status| image:: https://readthedocs.org/projects/rest-navigator/badge/?version=latest\n<br>   :target: https://readthedocs.org/projects/rest-navigator/?badge=latest\n<br>   :alt: Documentation Status\n<br>.. |Pypi Status| image:: https://pypip.in/v/restnavigator/badge.png\n<br>   :target: https://crate.io/packages/restnavigator/\n<br>\n<br>\n<br>Changelog\n<br>=========\n<br>\n<br>Unreleased\n<br>----------\n<br>\n<br>- TBD\n<br>\n<br>1.0\n<br>---\n<br>\n<br>- Embedded support\n<br>- Ability to specify default curies\n<br>- Resources with no URL are now represented by a special Navigator type called OrphanNavigators\n<br>- IP addresses can be used in the url (@dudycooly)\n<br>- All tests pass in python 2.6 -&gt; 3.4 (@bubenkoff), and travis now runs tox to ensure they stay that way\n<br>- Support the DELETE, and PATCH methods\n<br>- posts allow an empty body (@bbsgfalconer)\n<br>- Much improved content negotiation (@bbsgfalconer)\n<br>- There was also a major refactoring that changed how Navigators are created and internally cleaned up a\n<br>    lot of really messy code.\n          </div>"}, "last_serial": 1535797, "releases": {"0.2.0": [{"comment_text": "", "digests": {"md5": "44267e37502ded162dcbf313c2df57a4", "sha256": "c5f537927c5ed380c284470834a7c57ac9d1844a26040cfc669b2402f0ea93df"}, "downloads": -1, "filename": "restnavigator-0.2.0.tar.gz", "has_sig": false, "md5_digest": "44267e37502ded162dcbf313c2df57a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9831, "upload_time": "2014-01-19T23:46:55", "upload_time_iso_8601": "2014-01-19T23:46:55.227282Z", "url": "https://files.pythonhosted.org/packages/9b/c6/af03ffb5a5b77a5033fdd96d3dd9a85b87ab05fbcccb2b8b782b6aebf291/restnavigator-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "82faed71e3916d528cb67b77d515b215", "sha256": "f4879f9c3c5ebd7af04d6d5930f5526eada72538457e3432883c25be65c254dd"}, "downloads": -1, "filename": "restnavigator-0.2.1-py2-none-any.whl", "has_sig": false, "md5_digest": "82faed71e3916d528cb67b77d515b215", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 11978, "upload_time": "2014-08-27T00:58:51", "upload_time_iso_8601": "2014-08-27T00:58:51.260055Z", "url": "https://files.pythonhosted.org/packages/8b/85/869366b799b76287431657c6942d8e0261801bdea63ca76edfc8c9bd8153/restnavigator-0.2.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d07b2ca8f5c070d77f601fadb83a5fbf", "sha256": "6e2af5e1324d62ded32d25f956f50f8ca9d5d75eab3e0023a60f063512892273"}, "downloads": -1, "filename": "restnavigator-0.2.1.tar.gz", "has_sig": false, "md5_digest": "d07b2ca8f5c070d77f601fadb83a5fbf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9966, "upload_time": "2014-08-27T00:58:49", "upload_time_iso_8601": "2014-08-27T00:58:49.102875Z", "url": "https://files.pythonhosted.org/packages/ac/cc/3b5aedb5a9671b006f56e923733b5922f26119f1f79f5c52342210f85d64/restnavigator-0.2.1.tar.gz", "yanked": false}], "1.0": [{"comment_text": "", "digests": {"md5": "8bf3452e2eac89d1f8136056ca094d5c", "sha256": "97f09e6f30c7cbd9607a763c40a83389c4b1784b21819a1f9b3aad6cb79d14ee"}, "downloads": -1, "filename": "restnavigator-1.0-py2-none-any.whl", "has_sig": false, "md5_digest": "8bf3452e2eac89d1f8136056ca094d5c", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 18569, "upload_time": "2015-03-09T06:13:11", "upload_time_iso_8601": "2015-03-09T06:13:11.563411Z", "url": "https://files.pythonhosted.org/packages/c8/01/13b2db45042327086302f25dd65033bdd6109b5ef510650ed47905c2b96c/restnavigator-1.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "da8c8e79006233659dba50aa865067b2", "sha256": "e25c282886beb670bc593111fc249d623911671862f00c91fb78f0052f60ba73"}, "downloads": -1, "filename": "restnavigator-1.0.tar.gz", "has_sig": false, "md5_digest": "da8c8e79006233659dba50aa865067b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16444, "upload_time": "2015-03-09T06:12:18", "upload_time_iso_8601": "2015-03-09T06:12:18.353801Z", "url": "https://files.pythonhosted.org/packages/2f/d0/41515a001d21b9a17b3685c5acdea5a39c7ebdaee8b9fcb786fb92d04272/restnavigator-1.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "f9adf8117d65322b199fd7131dcbfb5d", "sha256": "b18e06c5b8b8acc604ccd2acb0282c2543c17b23c3b7bc472765ec484e93d083"}, "downloads": -1, "filename": "restnavigator-1.0.1-py2-none-any.whl", "has_sig": false, "md5_digest": "f9adf8117d65322b199fd7131dcbfb5d", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 32426, "upload_time": "2015-05-05T16:01:54", "upload_time_iso_8601": "2015-05-05T16:01:54.671003Z", "url": "https://files.pythonhosted.org/packages/21/d8/a9f8c30e0e9a9dc371dccc30703151371b193393335470faad85c3f1b095/restnavigator-1.0.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f82320b852f68bd51e68f67f79081caa", "sha256": "9be39bb32ee58db5a8f8c5983dfcda95f4578eeb88a012a32b82708dc74fb4ca"}, "downloads": -1, "filename": "restnavigator-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f82320b852f68bd51e68f67f79081caa", "packagetype": "bdist_wheel", "python_version": "3.4", "requires_python": null, "size": 32423, "upload_time": "2015-05-05T16:05:35", "upload_time_iso_8601": "2015-05-05T16:05:35.862366Z", "url": "https://files.pythonhosted.org/packages/5b/f3/4ff43f25ad13ea583e6f5f1f20fb18f5a954cffbd56446e9eedafa814fdd/restnavigator-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "845796126a0aac9dccc800e6dee6283f", "sha256": "b7dde0bd0cf81bb0e0b05a1529c7093a07700cbced0ecacac8c2e9b13c4bcdfa"}, "downloads": -1, "filename": "restnavigator-1.0.1.tar.gz", "has_sig": false, "md5_digest": "845796126a0aac9dccc800e6dee6283f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36551, "upload_time": "2015-05-05T16:01:43", "upload_time_iso_8601": "2015-05-05T16:01:43.014227Z", "url": "https://files.pythonhosted.org/packages/30/60/3019c4fc93734e753096fcc18f8dfcd0aef2177ad518c76533af294e4cad/restnavigator-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f9adf8117d65322b199fd7131dcbfb5d", "sha256": "b18e06c5b8b8acc604ccd2acb0282c2543c17b23c3b7bc472765ec484e93d083"}, "downloads": -1, "filename": "restnavigator-1.0.1-py2-none-any.whl", "has_sig": false, "md5_digest": "f9adf8117d65322b199fd7131dcbfb5d", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 32426, "upload_time": "2015-05-05T16:01:54", "upload_time_iso_8601": "2015-05-05T16:01:54.671003Z", "url": "https://files.pythonhosted.org/packages/21/d8/a9f8c30e0e9a9dc371dccc30703151371b193393335470faad85c3f1b095/restnavigator-1.0.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f82320b852f68bd51e68f67f79081caa", "sha256": "9be39bb32ee58db5a8f8c5983dfcda95f4578eeb88a012a32b82708dc74fb4ca"}, "downloads": -1, "filename": "restnavigator-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f82320b852f68bd51e68f67f79081caa", "packagetype": "bdist_wheel", "python_version": "3.4", "requires_python": null, "size": 32423, "upload_time": "2015-05-05T16:05:35", "upload_time_iso_8601": "2015-05-05T16:05:35.862366Z", "url": "https://files.pythonhosted.org/packages/5b/f3/4ff43f25ad13ea583e6f5f1f20fb18f5a954cffbd56446e9eedafa814fdd/restnavigator-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "845796126a0aac9dccc800e6dee6283f", "sha256": "b7dde0bd0cf81bb0e0b05a1529c7093a07700cbced0ecacac8c2e9b13c4bcdfa"}, "downloads": -1, "filename": "restnavigator-1.0.1.tar.gz", "has_sig": false, "md5_digest": "845796126a0aac9dccc800e6dee6283f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36551, "upload_time": "2015-05-05T16:01:43", "upload_time_iso_8601": "2015-05-05T16:01:43.014227Z", "url": "https://files.pythonhosted.org/packages/30/60/3019c4fc93734e753096fcc18f8dfcd0aef2177ad518c76533af294e4cad/restnavigator-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:34 2020"}