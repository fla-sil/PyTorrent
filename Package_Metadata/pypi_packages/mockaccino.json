{"info": {"author": "Paolo Victor", "author_email": "paolovictor@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "Mockaccino 0.1\nby Paolo Victor - paolovictor@gmail.com\n\nA Python mocking library with a syntax similar to the Easymock Java mocking library.\n\nThe basic way to use it is:\n\n1. Create a mock object for the class you want to mock\n2. Invoke methods on this mock, applying modifiers such as what the call will return and how many times it will happen\n3. Put the mock on replay mode\n4. Continue the test. Invocations to a mock object's methods will be matched sequentially, unless the call is recorded with an \"always\" modifier (more on that later)\n\nCode example\n\n    import mockaccino\n\n    class Calc(object):\n        def sum(self, a, b):\n            return a + b\n\n        def is_even(self, n):\n            return n % 2 == 0\n\n    mock = mockaccino.create_mock(Calc)\n\n    mock.sum(1, 1).will_return(3).always()\n    mock.is_even(2).will_return(False)\n    mock.is_even(3).will_return(True)\n\n    mockaccino.replay(mock)\n\n    print mock.sum(1, 1) # Prints 3\n    print mock.is_even(2) # Prints False\n    print mock.sum(1, 1) # Prints 3\n    print mock.is_even(3) # Prints True\n\n    # Mocking functions\n    def function():\n        return 0\n    \n    function_mock = mockaccino.create_mock(function)\n    \n    function_mock.will_return(1)\n\n    mockaccino.replay(function_mock)\n\n    print function_mock() # Prints 1\n\nUsage\n\nCreating and changing mock state\n\n* mockaccino.create_mock(class) - returns a mock object for the specified class or function\n* mockaccino.replay(mock, ...) - sets one or more mocks on \"replay mode\", meaning that all upcoming calls will be matched against the recorded calls\n\nRecording mocks\n\nWhen a mock is not on replay mode and you call one of its methods, it will return an Expectation the represents an expected method call. For example:\n\n    mock = mockaccino.create_mock(StringIO.StringIO)\n    mock.getvalue()\n    mock.replay()\n\nCreates a mock for the StringIO.StringIO class, configures it to expect getvalue to be called once and puts it on replay mode. You may also specify parameters for the expectation, that will be matched on replay mode:\n\n    mock = mockaccino.create_mock(Calc)\n    mock.sum(2, 2)\n    mock.replay()\n    mock.sum(1, 2) # Will raise an UnexpectedCall error\n\nExpectation modifiers\n\nBesides defining the expected parameters for a method call, you may configure other behaviors like what values will be returned, how many calls are expected and whether the call will raise an error or not:\n\n    mock = mockaccino.create_mock(Calc)\n    mock.sum(2, 2).will_return(5)\n    mock.sum(1, 1).will_return(2).times(2)\n    mock.sum(0, \"cat\").will_raise(ValueError).always()\n    mock.replay() \n    mock.sum(2, 2) # Will return 5, because I like it better this way\n    mock.sum(1, 1)\n    mock.sum(1, 1)\n    mock.sum(1, 1) # This would raise an error, sum(1, 1) is expected only 2 times after sum(2, 2)\n    mock.sum(0, \"cat\") # This would raise ValueError\n\nNote that after setting an \"always\" modifier, you cannot record any other behaviors for the method or vice-versa.\n\nThe currently implemented expectation modifiers are:\n\n* times(n) - \"This method will be called n times\"\n* always() - \"Whenever this method is called, this is the expected behavior\"\n* will_return(x) - \"This method will return x\"\n* will_raise(e) - \"This method will raise an error e\"\n\nMatchers\n\nMatchers are expected parameter modifiers that let you write expectations with\ndifferent value comparison criteria, such as \"this parameter's value may be any\nint value\"\n\nExample:\n\n    from mockaccino.matchers import any\n\n    mock = mockaccino.create_mock(Calc)\n    mock.sum(any(int), 2).will_return(5).always()\n    mock.replay() \n    mock.sum(3, 2) # Returns 5\n    mock.sum(2, 2) # Returns 5\n    mock.sum(3, 1) # Raises UnexpectedCallError\n\nThe only currently implemented matcher is:\n\n* any(type)- \"The value should be of type 'type'\"\nRoadmap\n\n1. Add support for \"magic method\" (__eq__, __str__, etc) mocking\n2. Implement a \"verify\" method that checks if there are unmatched calls", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/paolovictor/mockaccino", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "mockaccino", "package_url": "https://pypi.org/project/mockaccino/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/mockaccino/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/paolovictor/mockaccino"}, "release_url": "https://pypi.org/project/mockaccino/0.2/", "requires_dist": null, "requires_python": null, "summary": "Python mocking library with an EasyMock flavor", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            Mockaccino 0.1<br>by Paolo Victor - paolovictor@gmail.com<br><br>A Python mocking library with a syntax similar to the Easymock Java mocking library.<br><br>The basic way to use it is:<br><br>1. Create a mock object for the class you want to mock<br>2. Invoke methods on this mock, applying modifiers such as what the call will return and how many times it will happen<br>3. Put the mock on replay mode<br>4. Continue the test. Invocations to a mock object's methods will be matched sequentially, unless the call is recorded with an \"always\" modifier (more on that later)<br><br>Code example<br><br>    import mockaccino<br><br>    class Calc(object):<br>        def sum(self, a, b):<br>            return a + b<br><br>        def is_even(self, n):<br>            return n % 2 == 0<br><br>    mock = mockaccino.create_mock(Calc)<br><br>    mock.sum(1, 1).will_return(3).always()<br>    mock.is_even(2).will_return(False)<br>    mock.is_even(3).will_return(True)<br><br>    mockaccino.replay(mock)<br><br>    print mock.sum(1, 1) # Prints 3<br>    print mock.is_even(2) # Prints False<br>    print mock.sum(1, 1) # Prints 3<br>    print mock.is_even(3) # Prints True<br><br>    # Mocking functions<br>    def function():<br>        return 0<br>    <br>    function_mock = mockaccino.create_mock(function)<br>    <br>    function_mock.will_return(1)<br><br>    mockaccino.replay(function_mock)<br><br>    print function_mock() # Prints 1<br><br>Usage<br><br>Creating and changing mock state<br><br>* mockaccino.create_mock(class) - returns a mock object for the specified class or function<br>* mockaccino.replay(mock, ...) - sets one or more mocks on \"replay mode\", meaning that all upcoming calls will be matched against the recorded calls<br><br>Recording mocks<br><br>When a mock is not on replay mode and you call one of its methods, it will return an Expectation the represents an expected method call. For example:<br><br>    mock = mockaccino.create_mock(StringIO.StringIO)<br>    mock.getvalue()<br>    mock.replay()<br><br>Creates a mock for the StringIO.StringIO class, configures it to expect getvalue to be called once and puts it on replay mode. You may also specify parameters for the expectation, that will be matched on replay mode:<br><br>    mock = mockaccino.create_mock(Calc)<br>    mock.sum(2, 2)<br>    mock.replay()<br>    mock.sum(1, 2) # Will raise an UnexpectedCall error<br><br>Expectation modifiers<br><br>Besides defining the expected parameters for a method call, you may configure other behaviors like what values will be returned, how many calls are expected and whether the call will raise an error or not:<br><br>    mock = mockaccino.create_mock(Calc)<br>    mock.sum(2, 2).will_return(5)<br>    mock.sum(1, 1).will_return(2).times(2)<br>    mock.sum(0, \"cat\").will_raise(ValueError).always()<br>    mock.replay() <br>    mock.sum(2, 2) # Will return 5, because I like it better this way<br>    mock.sum(1, 1)<br>    mock.sum(1, 1)<br>    mock.sum(1, 1) # This would raise an error, sum(1, 1) is expected only 2 times after sum(2, 2)<br>    mock.sum(0, \"cat\") # This would raise ValueError<br><br>Note that after setting an \"always\" modifier, you cannot record any other behaviors for the method or vice-versa.<br><br>The currently implemented expectation modifiers are:<br><br>* times(n) - \"This method will be called n times\"<br>* always() - \"Whenever this method is called, this is the expected behavior\"<br>* will_return(x) - \"This method will return x\"<br>* will_raise(e) - \"This method will raise an error e\"<br><br>Matchers<br><br>Matchers are expected parameter modifiers that let you write expectations with<br>different value comparison criteria, such as \"this parameter's value may be any<br>int value\"<br><br>Example:<br><br>    from mockaccino.matchers import any<br><br>    mock = mockaccino.create_mock(Calc)<br>    mock.sum(any(int), 2).will_return(5).always()<br>    mock.replay() <br>    mock.sum(3, 2) # Returns 5<br>    mock.sum(2, 2) # Returns 5<br>    mock.sum(3, 1) # Raises UnexpectedCallError<br><br>The only currently implemented matcher is:<br><br>* any(type)- \"The value should be of type 'type'\"<br>Roadmap<br><br>1. Add support for \"magic method\" (__eq__, __str__, etc) mocking<br>2. Implement a \"verify\" method that checks if there are unmatched calls\n          </div>"}, "last_serial": 794890, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "b44e4a514644f4cbdac245956bb5032c", "sha256": "8b9d6799c203d59ed2ca078ea112214b69eed2d7e92b2d13a3329eca0bc5aa25"}, "downloads": -1, "filename": "mockaccino-0.1.tar.gz", "has_sig": false, "md5_digest": "b44e4a514644f4cbdac245956bb5032c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7165, "upload_time": "2012-02-19T19:38:27", "upload_time_iso_8601": "2012-02-19T19:38:27.399756Z", "url": "https://files.pythonhosted.org/packages/f9/2e/332cbd29efb2c209db6e553018d182655e61edd00e155ef0f4a10a1b44e3/mockaccino-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "4f8ce1466da82ce299654248b8dec776", "sha256": "7b5ec894fcada6e38dff5f1dfae0d13c1035b6d0633b3f8753893783332dbecf"}, "downloads": -1, "filename": "mockaccino-0.2.tar.gz", "has_sig": false, "md5_digest": "4f8ce1466da82ce299654248b8dec776", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7939, "upload_time": "2012-03-02T04:17:12", "upload_time_iso_8601": "2012-03-02T04:17:12.169782Z", "url": "https://files.pythonhosted.org/packages/10/5a/4a0ad27749fe11f041ecc2d90de33028e4803b479768fd918c896a792893/mockaccino-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4f8ce1466da82ce299654248b8dec776", "sha256": "7b5ec894fcada6e38dff5f1dfae0d13c1035b6d0633b3f8753893783332dbecf"}, "downloads": -1, "filename": "mockaccino-0.2.tar.gz", "has_sig": false, "md5_digest": "4f8ce1466da82ce299654248b8dec776", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7939, "upload_time": "2012-03-02T04:17:12", "upload_time_iso_8601": "2012-03-02T04:17:12.169782Z", "url": "https://files.pythonhosted.org/packages/10/5a/4a0ad27749fe11f041ecc2d90de33028e4803b479768fd918c896a792893/mockaccino-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:53:04 2020"}