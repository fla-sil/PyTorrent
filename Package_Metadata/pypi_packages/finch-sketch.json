{"info": {"author": "Roderick Bovee & One Codex <roderick@onecodex.com>", "author_email": "Roderick Bovee & One Codex <roderick@onecodex.com>", "bugtrack_url": null, "classifiers": ["Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Topic :: Scientific/Engineering :: Bio-Informatics"], "description": "# Finch #\n\n[![CircleCI](https://circleci.com/gh/onecodex/finch-rs.svg?style=shield&circle-token=4fa4296a595f0d0e8dfcea750d76c39576f2df73)](https://circleci.com/gh/onecodex/finch-rs)\n[![DOI](http://joss.theoj.org/papers/10.21105/joss.00505/status.svg)](https://doi.org/10.21105/joss.00505)\n\nFinch is an implementation of min-wise independent permutation locality sensitive hashing (\"MinHashing\") for genomic data.\nThis repository provides a library and command-line interface that reimplements much of One Codex's [existing internal clustering/sequence search tool](http://blog.onecodex.com/2016/02/11/clustering-and-basespace/) (and adds new features/extensions!) in [Rust](https://www.rust-lang.org/en-US/).\n\n## Getting Started ##\n\n### Installation ###\nYou may build Finch from source using Rust >= `1.15`, install with `cargo install finch` if you have Rust's Cargo package manager (see [rustup](https://www.rustup.rs) for fast Cargo installation instructions), or [download a prebuilt binary](https://github.com/onecodex/finch-rs/releases).\n\n### Example Usage ###\nTo get started, we first compute sketches for several FASTA or FASTQ files. These sketches are compact, sampled representations of the underlying genomic data, and what allow `finch` to rapidly estimate distances between datasets. Sketching files uses the `finch sketch` command:\n\n```\nfinch sketch example.fastq example2.fastq\n```\n\nThe resulting sketch files (`example.fastq.sk` and `example2.fastq.sk`) can then be used with other `finch` commands (as well as with other MinHash implementations<sup>1</sup>). Note that all of Finch's commands can take either sketches or raw sequence files. If passed the latter, `finch` will sketch the files on the fly. Sketches generated on the fly are **not saved**, however, so you should call `finch sketch` if you plan to use the sketch multiple times.\n\nOnce sketched, multiple sequencing runs can be compared to determine how similar they are:\n\n```\nfinch dist example.fastq.sk example2.fastq.sk\n```\n\nThis will print results (in JSON) with some key distance statistics, including `containment` and `jaccard` similarity scores and a `mashDistance` distance estimate:\n\n\n```json\n[\n  {\n    \"commonHashes\": 30,\n    \"containment\": 0.03,\n    \"jaccard\": 0.015228426395939087,\n    \"mashDistance\": 0.1669789474914277,\n    \"query\": \"example2.fastq\",\n    \"reference\": \"example1.fastq\",\n    \"totalHashes\": 1000\n  }\n]\n```\n\nIn this case, these files have an estimated distance of ~0.17 and a containment of 0.03 (i.e., the two FASTQs share 3% of their min-mers). Note that re-computing the sketches with a larger `--n-hashes` parameter can provide additional resolution for highly similar datasets.\n\n\nNext, we may want to find the nearest genomes to our example FASTQ **across all of RefSeq**. To do this, we simply pass our example query file as the first argument and a sketch file containing all the genomes in RefSeq as the second argument (see the Example Data section for pre-computed RefSeq databases that work with `finch`):\n\n```\nfinch dist ./example.fastq.sk ./refseq_sketches_21_1000.sk --max-dist 0.2\n```\n\nHere, we also set a maximum distance of 0.2 in order to filter out less closely related genomes (a distance of 0 would be an identical genome). Setting a maximum ensures that the only relevant results are returned -- omitting this parameter would return distances to *all* of the genomes in RefSeq.\n\n_**Note**: Each of these commands is detailed further below, and more information is also available by passing the `--help` flag to each command, e.g., `finch dist --help`._\n\n## Design goals ##\nWe have 3 primary design goals with Finch:\n\n1. Support for tracking k-mer/minmer _counts_;\n\n2. Improved error filtering for use with raw sequence data (i.e., FASTQs); and\n\n3. Improved performance.\n\n\n### Support for counts ###\nFinch is one of the first MinHash implementations to support tracking the abundances of each unique _k_-mer/minmer.\nThis allows useful quick interpretations of data (e.g. visualizing sequencing depth with `finch hist`) in addition to laying the support for more advanced filtering (implemented here) and count-aware distance measures (a future area for investigation and study).\nBecause Finch also supports the [new Mash JSON compatibility format](https://github.com/marbl/Mash/blob/master/src/mash/schema-1.0.0.json), we're able to save this count information for downstream processing and comparisons.\n\n > :warning: &nbsp;Note that although Finch supports the common JSON interchange format, there may still be incompatibilites due to incompaible hashing seed values (Finch uses a seed of `0`, while Mash uses `42`; see [this issue](https://github.com/marbl/Mash/issues/12) for more discussion).\n\n### Filtering ###\nA key design goal for Finch was the ability to accurately \u2013\u00a0and _stably_ \u2013 sketch variable depth sequencing of bacterial isolates (i.e., to not require a high quality assembly). While Mash includes the ability to specify a fixed absolute cutoff (or use a Bloom filter to filter out unique minmers in a sample), in practice this filtering mechanism performs poorly across varied sequencing depths, genome sizes, and sequencing error profiles. The Finch filtering approach implemented here extends several of the ideas in the original Mash paper, as well as [prior work on clustering clinical _C. diff_ isolates](http://www.dmidjournal.com/article/S0732-8893(16)30322-4/abstract).\n\nFinch includes two classes of automated filtering (on by default for FASTQs) to address this challenge:\n\n1. *Adapative, count-based filtering*: Our default implementation \"over-sketches\" an input file (i.e., includes _n_ fold more minmers than specified by the user) and dynamically determines an appropriate count-based filtering cutoff that removes low abundance _k_-mers (which predominantly consist of random errors). As a fallback, this implementation never excludes more than an upper bound proportion of minmers that may be reasonably assumed to be erroneous (`k` times a specified `--err-filter` error rate, for a default of 21%).\n\n2. *Strandedness filtering*: We also apply a \"strandedness filter\" to remove _k_-mers that are overwhelmingly found in one orientation; in practice these are often seqeuencing adapters or other artifacts that are not representative of the underlying sample (and may erroneously reduce the similarity between two sketches).\n\nIn practice, these optimizations dramatically increase the stability and accuracy of distance estimates between variable depth isolates and finished assemblies. The below graph shows the distance between a high quality bacterial assembly and sketches of FASTQ files representing various sequencing depths across 3 filter strategies: no filtering (`cutoff=0`), \"na\u00efve\" filtering (`cutoff=1`), and Finch's adapative, variable-cutoff filtering. We use the containment measure, with results closer to `100%` being better:\n\n![Accuracy versus sequencing depth for different filtering schemes](https://github.com/onecodex/finch-rs/blob/master/paper/depth_distance.png?raw=true)\n\nNotably, this strategy performs well across sequencing depths, while fixed cutoffs of 0 and 1 never achieve the near-100% expected containment (and the former fails catastrophically at even modest depths). It is also robust to repeated errors (i.e., error _k_-mers/minmers with a count >= 2), which can begin to pose a problem at sequencing depths as low a 10-20X.\n\n### Speed/performance ###\nIn addition to some of the memory safety guarentees that Rust enables, we also see considerable speed gains over existing implementations.\nIdeally, hashing should be the rate-limiting step in MinHashing. Profiling indicates `finch` spends about a third of its time in `murmurhash3_x64_128` so we should be within an order of magnitude of this theoretical limit.\n\n|                 | Mash    | Mash (filtered) | Sourmash | Finch   | Finch (filtered) |\n|-----------------|---------|-----------------|----------|---------|------------------|\n| Time            | 238s    | 276s            | 518s     | **99s** | 104s             |\n| Max Memory (Mb) | **1.2** | 501.1           | 13.9     | 21.8    | 60.0             |60.0                        |\n\n> *Note: Benchmarks run on an Early 2015 Macbook Pro. Benchmark is sketching a 4.8Gb FASTQ file ([SRR5132341.fastq](https://www.ncbi.nlm.nih.gov/sra/?term=SRR5132341)) with a sketch size of _n=10,000_. Finch filtered results use the default options, while Mash uses `-b 500Mb` to allocate a 500Mb Bloom filter. Benchmarks used the following commits for Mash ([23776db](https://github.com/marbl/Mash/commit/23776dbe368d398639ec40f133edc06329dc3da8)) and sourmash ([5da5ee7](https://github.com/dib-lab/sourmash/commit/5da5ee7c72281ff05cb90d6ce3e8bc4d316998c5))*\n\n## Usage ##\n\nFinch supports four primary operations, with many of these operations taking similar parameters.\n\n### Shared Parameters ###\n\nFinch can take many parameters to control how sketching is performed (and these options are also available for the `dist`, `hist`, and `info` commands).\n - `-n <N>` / `--n-hashes <N>` controls the overall size of the sketch (higher values give better resolution in comparisons). Default `1000`.\n - `-k <K>` / `--kmer-length <K>` sets the size of the kmers to be hashed (higher values make comparisons much more taxonomically specific). Default `21`.\n - `--seed <S>` sets the seed for hashing. This should only be changed if directly exporting sketches for comparison with other versions of the Mash algorithm that use a non-zero default seed. Default `0`.\n\nAfter sketching, filtering is performed and can be controlled through several options:\n - `-f` / `--filter` / `--no-filter` determines whether filtering is applied or not (if not specified, filtering is performed for FASTQ files and not performed for FASTA files by default)\n - `--min-abun-filter <MIN>` / `--max-abun-filter <MAX>` sets absolute minimum and maximum abundances (inclusive) that all kmers must be present at. The minimum filter will override any adaptive error filter guessing (below).\n - `--err-filter <ERR_VALUE>` is the default adaptive filtering scheme. Conceptually `ERR_VALUE` should be approximately the error rate of the sequencer or higher. Note that high error rate sequencing data (i.e. long read sequencing) does poorly with MinHashing in general.\n - `--strand-filter <V>` sets the strand filter cutoff.\n\nNote that if there aren't enough kmers left from the oversketch to satisfy the sketch size, sketching will fail.\nThere are two options that may help:\n - `--oversketch <N>` can be used to increase the size of the oversketch (normally 200x) and increase the likelihood that the filtered version will be big enough.\n - `--no-strict` will allow Finch to proceed with a sketch smaller than the specified size. Use with caution.\n\n\n### `finch sketch` ###\n\n`finch sketch` will read through a FASTA or FASTQ file and generate a \"sketch\" that can be used for further .\n\nIf the file being read is a sketch and the filtering flag is set (`-f`/`--filter`), the abundance filters will be re-applied to the sketch to allow post-sketch filtering.\nThe strand filters can only be applied to raw FAST(A/Q) files though, as the strand-level data is lost when sketches are saved.\n\nBy default `sketch` generates `.sk` suffixed files next to the FAST(A/Q) files it sketches.\nThis can be overridden by passing either `-O` (capital O) to write to standard out or `-o <file>` (lowercase o) to write to a file.\nTo read from standard input, use a filename of `-`; this allows streaming of files into `finch`, e.g. `cat testfile.fq | finch sketch -o testfile.sk -`.\n\nSketches should be compatible with the original Mash implementation if you edit their `src/mash/hash.h` and set the hash value to `0` or if you manually override Finch's seed value by setting `--seed 42`.\n\n### `finch dist` ###\n\n`finch dist` will calculate Jaccard distances between different sketches.\nIf the files listed are FASTA/Q instead of sketches, Finch will automatically sketch them into memory using the same command-line parameters as in `sketch` or, for files after the first, the parameters used to sketch the first file.\n\nDistances and containments will only be computed from one or more queries to a collection of references; by default the first sketch in the list will be used as the query and all other sketches will be used as references.\nThis behavior can be manually overriden and other sketches can be used as references by passing `--queries <sketch_1>,<sketch_2`.\nAdditionally, passing the `--pairwise` option will calculate the distances between all sketches and each other.\n\nDue to different counting algoritms and stopping criteria, distances may be slightly different from the calculation in the original Mash program and older version of finch.\nPassing the `-old-dist` flag will revert to the older version of Finch's calculation; support for Mash's exact distance calculation has been dropped as of version 0.3.\n\n### `finch hist` ###\n\n`finch hist` will output a histogram in JSON format for each sketch provided.\nThe histogram is a list of the number of minmers at each depth, e.g. `{\"sketch_name\": [1, 0, 1]}` for a sketch with two minmers, one with a depth of 1 (first position) and one with a depth of 3 (third position).\n\n> :warning: &nbsp; You can use the following command with Matplotlib to get a quick histogram: `finch hist test.fastq.sk | python -c 'import json; import matplotlib.pyplot as plt; import sys; v = json.loads(sys.stdin.read()).values()[0]; plt.plot(range(1, len(v)+1), v); plt.show()'`. Note that the `finch hist` JSON output is likely to change in a future version to, e.g., a more compact `{count: value}` format or similar.\n\n### `finch info` ###\n\n`finch info` will output a formatted list of % GC, coverage, etc for each sketch provided.\n\n> :warning: &nbsp;Note that the values returned from this are approximate and the algoritms used to calculate are still rough and liable to change.\n\n## Example Data ##\nWe've sketched the NCBI RefSeq collection (as of March 27, 2017 using [this script](https://github.com/DerrickWood/kraken/blob/master/scripts/download_genomic_library.sh)) and made tarballs with individual sketches for each bacterial and viral genome available. Links: [_k=21_ and _n=1,000_](https://static.onecodex.com/public/finch-rs/refseq_sketches_21_1000.sk.gz), [_k=31_ and _n=1,000_](https://static.onecodex.com/public/finch-rs/refseq_sketches_31_1000.sk.gz), [_k=21_ and _n=10,000_](https://static.onecodex.com/public/finch-rs/refseq_sketches_21_10000.sk.gz), and [_k=31_ and _n=10,000_](https://static.onecodex.com/public/finch-rs/refseq_sketches_31_10000.sk.gz).\n\n## References & Notes ##\n\nThere are several other implementations of the Mash algorithm which should be compatible/comparable with this one, notably:\n - [Mash](https://github.com/marbl/Mash) - First implementation and theoretical paper\n - [SourMash](https://github.com/dib-lab/sourmash) - Newer implementation in Python; provides a number of experimental features\n\nNotes:\n- <sup>1</sup> Please see, however, [this issue tracking interoperability](https://github.com/marbl/Mash/issues/27) and note that other implementations may use a different seed value.\n\n## Python Support ##\n\nOptional Python bindings are in the `src/python.rs` file and can be built into a python library with:\n```bash\nrustup default nightly\npip install maturin\nmaturin install --cargo-extra-args=\"--features=python\" --release --strip\n# or maturin develop, etc\n# to cross-compile linux wheels:\ndocker run --rm -v $(pwd):/io konstin2/maturin:master build --cargo-extra-args=\"--features=python\" --release --strip\n```\n\nThen, e.g. to calculate the similarities between two E. coli:\n```python\nfrom finch import sketch_file\nsketch_one = sketch_file('WIS_EcoB_v2.fas')\nsketch_two = sketch_file('WIS_Eco10798_DRAFTv1.fas')\ncont, jacc = sketch_one.compare(sketch_two)\n```\n\n## Contributions ##\n\nProblems or suggestions for improvement can be reported through GitHub issues.\nWe are happy to accept and/or mentor any additions or fixes (which are best submitted as pull requests).\nFor our code of conduct, please see `CODE_OF_CONDUCT.md`.\n\n", "description_content_type": "text/markdown; charset=UTF-8; variant=GFM", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "minhash bioinformatics sketches", "license": "MIT", "maintainer": "One Codex", "maintainer_email": "", "name": "finch-sketch", "package_url": "https://pypi.org/project/finch-sketch/", "platform": "", "project_url": "https://pypi.org/project/finch-sketch/", "project_urls": null, "release_url": "https://pypi.org/project/finch-sketch/0.3.0/", "requires_dist": null, "requires_python": "", "summary": "An implementation of min-wise independent permutation locality sensitive hashing ('MinHashing') for genomic data and command-line utility for manipulation.", "version": "0.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Finch</h1>\n<p><a href=\"https://circleci.com/gh/onecodex/finch-rs\" rel=\"nofollow\"><img alt=\"CircleCI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a57df15bc3dbad5f087f94088dda78e44f1bdac9/68747470733a2f2f636972636c6563692e636f6d2f67682f6f6e65636f6465782f66696e63682d72732e7376673f7374796c653d736869656c6426636972636c652d746f6b656e3d34666134323936613539356630643065386466636561373530643736633339353736663264663733\"></a>\n<a href=\"https://doi.org/10.21105/joss.00505\" rel=\"nofollow\"><img alt=\"DOI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/598a04cec5c779411a55892c677a6c70ad982c34/687474703a2f2f6a6f73732e7468656f6a2e6f72672f7061706572732f31302e32313130352f6a6f73732e30303530352f7374617475732e737667\"></a></p>\n<p>Finch is an implementation of min-wise independent permutation locality sensitive hashing (\"MinHashing\") for genomic data.\nThis repository provides a library and command-line interface that reimplements much of One Codex's <a href=\"http://blog.onecodex.com/2016/02/11/clustering-and-basespace/\" rel=\"nofollow\">existing internal clustering/sequence search tool</a> (and adds new features/extensions!) in <a href=\"https://www.rust-lang.org/en-US/\" rel=\"nofollow\">Rust</a>.</p>\n<h2>Getting Started</h2>\n<h3>Installation</h3>\n<p>You may build Finch from source using Rust &gt;= <code>1.15</code>, install with <code>cargo install finch</code> if you have Rust's Cargo package manager (see <a href=\"https://www.rustup.rs\" rel=\"nofollow\">rustup</a> for fast Cargo installation instructions), or <a href=\"https://github.com/onecodex/finch-rs/releases\" rel=\"nofollow\">download a prebuilt binary</a>.</p>\n<h3>Example Usage</h3>\n<p>To get started, we first compute sketches for several FASTA or FASTQ files. These sketches are compact, sampled representations of the underlying genomic data, and what allow <code>finch</code> to rapidly estimate distances between datasets. Sketching files uses the <code>finch sketch</code> command:</p>\n<pre><code>finch sketch example.fastq example2.fastq\n</code></pre>\n<p>The resulting sketch files (<code>example.fastq.sk</code> and <code>example2.fastq.sk</code>) can then be used with other <code>finch</code> commands (as well as with other MinHash implementations<sup>1</sup>). Note that all of Finch's commands can take either sketches or raw sequence files. If passed the latter, <code>finch</code> will sketch the files on the fly. Sketches generated on the fly are <strong>not saved</strong>, however, so you should call <code>finch sketch</code> if you plan to use the sketch multiple times.</p>\n<p>Once sketched, multiple sequencing runs can be compared to determine how similar they are:</p>\n<pre><code>finch dist example.fastq.sk example2.fastq.sk\n</code></pre>\n<p>This will print results (in JSON) with some key distance statistics, including <code>containment</code> and <code>jaccard</code> similarity scores and a <code>mashDistance</code> distance estimate:</p>\n<pre><span class=\"p\">[</span>\n  <span class=\"p\">{</span>\n    <span class=\"nt\">\"commonHashes\"</span><span class=\"p\">:</span> <span class=\"mi\">30</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"containment\"</span><span class=\"p\">:</span> <span class=\"mf\">0.03</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"jaccard\"</span><span class=\"p\">:</span> <span class=\"mf\">0.015228426395939087</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"mashDistance\"</span><span class=\"p\">:</span> <span class=\"mf\">0.1669789474914277</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"query\"</span><span class=\"p\">:</span> <span class=\"s2\">\"example2.fastq\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"reference\"</span><span class=\"p\">:</span> <span class=\"s2\">\"example1.fastq\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"totalHashes\"</span><span class=\"p\">:</span> <span class=\"mi\">1000</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">]</span>\n</pre>\n<p>In this case, these files have an estimated distance of ~0.17 and a containment of 0.03 (i.e., the two FASTQs share 3% of their min-mers). Note that re-computing the sketches with a larger <code>--n-hashes</code> parameter can provide additional resolution for highly similar datasets.</p>\n<p>Next, we may want to find the nearest genomes to our example FASTQ <strong>across all of RefSeq</strong>. To do this, we simply pass our example query file as the first argument and a sketch file containing all the genomes in RefSeq as the second argument (see the Example Data section for pre-computed RefSeq databases that work with <code>finch</code>):</p>\n<pre><code>finch dist ./example.fastq.sk ./refseq_sketches_21_1000.sk --max-dist 0.2\n</code></pre>\n<p>Here, we also set a maximum distance of 0.2 in order to filter out less closely related genomes (a distance of 0 would be an identical genome). Setting a maximum ensures that the only relevant results are returned -- omitting this parameter would return distances to <em>all</em> of the genomes in RefSeq.</p>\n<p><em><strong>Note</strong>: Each of these commands is detailed further below, and more information is also available by passing the <code>--help</code> flag to each command, e.g., <code>finch dist --help</code>.</em></p>\n<h2>Design goals</h2>\n<p>We have 3 primary design goals with Finch:</p>\n<ol>\n<li>\n<p>Support for tracking k-mer/minmer <em>counts</em>;</p>\n</li>\n<li>\n<p>Improved error filtering for use with raw sequence data (i.e., FASTQs); and</p>\n</li>\n<li>\n<p>Improved performance.</p>\n</li>\n</ol>\n<h3>Support for counts</h3>\n<p>Finch is one of the first MinHash implementations to support tracking the abundances of each unique <em>k</em>-mer/minmer.\nThis allows useful quick interpretations of data (e.g. visualizing sequencing depth with <code>finch hist</code>) in addition to laying the support for more advanced filtering (implemented here) and count-aware distance measures (a future area for investigation and study).\nBecause Finch also supports the <a href=\"https://github.com/marbl/Mash/blob/master/src/mash/schema-1.0.0.json\" rel=\"nofollow\">new Mash JSON compatibility format</a>, we're able to save this count information for downstream processing and comparisons.</p>\n<blockquote>\n<p>:warning: \u00a0Note that although Finch supports the common JSON interchange format, there may still be incompatibilites due to incompaible hashing seed values (Finch uses a seed of <code>0</code>, while Mash uses <code>42</code>; see <a href=\"https://github.com/marbl/Mash/issues/12\" rel=\"nofollow\">this issue</a> for more discussion).</p>\n</blockquote>\n<h3>Filtering</h3>\n<p>A key design goal for Finch was the ability to accurately \u2013\u00a0and <em>stably</em> \u2013 sketch variable depth sequencing of bacterial isolates (i.e., to not require a high quality assembly). While Mash includes the ability to specify a fixed absolute cutoff (or use a Bloom filter to filter out unique minmers in a sample), in practice this filtering mechanism performs poorly across varied sequencing depths, genome sizes, and sequencing error profiles. The Finch filtering approach implemented here extends several of the ideas in the original Mash paper, as well as <a href=\"http://www.dmidjournal.com/article/S0732-8893(16)30322-4/abstract\" rel=\"nofollow\">prior work on clustering clinical <em>C. diff</em> isolates</a>.</p>\n<p>Finch includes two classes of automated filtering (on by default for FASTQs) to address this challenge:</p>\n<ol>\n<li>\n<p><em>Adapative, count-based filtering</em>: Our default implementation \"over-sketches\" an input file (i.e., includes <em>n</em> fold more minmers than specified by the user) and dynamically determines an appropriate count-based filtering cutoff that removes low abundance <em>k</em>-mers (which predominantly consist of random errors). As a fallback, this implementation never excludes more than an upper bound proportion of minmers that may be reasonably assumed to be erroneous (<code>k</code> times a specified <code>--err-filter</code> error rate, for a default of 21%).</p>\n</li>\n<li>\n<p><em>Strandedness filtering</em>: We also apply a \"strandedness filter\" to remove <em>k</em>-mers that are overwhelmingly found in one orientation; in practice these are often seqeuencing adapters or other artifacts that are not representative of the underlying sample (and may erroneously reduce the similarity between two sketches).</p>\n</li>\n</ol>\n<p>In practice, these optimizations dramatically increase the stability and accuracy of distance estimates between variable depth isolates and finished assemblies. The below graph shows the distance between a high quality bacterial assembly and sketches of FASTQ files representing various sequencing depths across 3 filter strategies: no filtering (<code>cutoff=0</code>), \"na\u00efve\" filtering (<code>cutoff=1</code>), and Finch's adapative, variable-cutoff filtering. We use the containment measure, with results closer to <code>100%</code> being better:</p>\n<p><img alt=\"Accuracy versus sequencing depth for different filtering schemes\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8dfc39c95b7382d293928583994a0567f0e22e82/68747470733a2f2f6769746875622e636f6d2f6f6e65636f6465782f66696e63682d72732f626c6f622f6d61737465722f70617065722f64657074685f64697374616e63652e706e673f7261773d74727565\"></p>\n<p>Notably, this strategy performs well across sequencing depths, while fixed cutoffs of 0 and 1 never achieve the near-100% expected containment (and the former fails catastrophically at even modest depths). It is also robust to repeated errors (i.e., error <em>k</em>-mers/minmers with a count &gt;= 2), which can begin to pose a problem at sequencing depths as low a 10-20X.</p>\n<h3>Speed/performance</h3>\n<p>In addition to some of the memory safety guarentees that Rust enables, we also see considerable speed gains over existing implementations.\nIdeally, hashing should be the rate-limiting step in MinHashing. Profiling indicates <code>finch</code> spends about a third of its time in <code>murmurhash3_x64_128</code> so we should be within an order of magnitude of this theoretical limit.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Mash</th>\n<th>Mash (filtered)</th>\n<th>Sourmash</th>\n<th>Finch</th>\n<th>Finch (filtered)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Time</td>\n<td>238s</td>\n<td>276s</td>\n<td>518s</td>\n<td><strong>99s</strong></td>\n<td>104s</td>\n</tr>\n<tr>\n<td>Max Memory (Mb)</td>\n<td><strong>1.2</strong></td>\n<td>501.1</td>\n<td>13.9</td>\n<td>21.8</td>\n<td>60.0</td>\n</tr></tbody></table>\n<blockquote>\n<p><em>Note: Benchmarks run on an Early 2015 Macbook Pro. Benchmark is sketching a 4.8Gb FASTQ file (<a href=\"https://www.ncbi.nlm.nih.gov/sra/?term=SRR5132341\" rel=\"nofollow\">SRR5132341.fastq</a>) with a sketch size of <em>n=10,000</em>. Finch filtered results use the default options, while Mash uses <code>-b 500Mb</code> to allocate a 500Mb Bloom filter. Benchmarks used the following commits for Mash (<a href=\"https://github.com/marbl/Mash/commit/23776dbe368d398639ec40f133edc06329dc3da8\" rel=\"nofollow\">23776db</a>) and sourmash (<a href=\"https://github.com/dib-lab/sourmash/commit/5da5ee7c72281ff05cb90d6ce3e8bc4d316998c5\" rel=\"nofollow\">5da5ee7</a>)</em></p>\n</blockquote>\n<h2>Usage</h2>\n<p>Finch supports four primary operations, with many of these operations taking similar parameters.</p>\n<h3>Shared Parameters</h3>\n<p>Finch can take many parameters to control how sketching is performed (and these options are also available for the <code>dist</code>, <code>hist</code>, and <code>info</code> commands).</p>\n<ul>\n<li><code>-n &lt;N&gt;</code> / <code>--n-hashes &lt;N&gt;</code> controls the overall size of the sketch (higher values give better resolution in comparisons). Default <code>1000</code>.</li>\n<li><code>-k &lt;K&gt;</code> / <code>--kmer-length &lt;K&gt;</code> sets the size of the kmers to be hashed (higher values make comparisons much more taxonomically specific). Default <code>21</code>.</li>\n<li><code>--seed &lt;S&gt;</code> sets the seed for hashing. This should only be changed if directly exporting sketches for comparison with other versions of the Mash algorithm that use a non-zero default seed. Default <code>0</code>.</li>\n</ul>\n<p>After sketching, filtering is performed and can be controlled through several options:</p>\n<ul>\n<li><code>-f</code> / <code>--filter</code> / <code>--no-filter</code> determines whether filtering is applied or not (if not specified, filtering is performed for FASTQ files and not performed for FASTA files by default)</li>\n<li><code>--min-abun-filter &lt;MIN&gt;</code> / <code>--max-abun-filter &lt;MAX&gt;</code> sets absolute minimum and maximum abundances (inclusive) that all kmers must be present at. The minimum filter will override any adaptive error filter guessing (below).</li>\n<li><code>--err-filter &lt;ERR_VALUE&gt;</code> is the default adaptive filtering scheme. Conceptually <code>ERR_VALUE</code> should be approximately the error rate of the sequencer or higher. Note that high error rate sequencing data (i.e. long read sequencing) does poorly with MinHashing in general.</li>\n<li><code>--strand-filter &lt;V&gt;</code> sets the strand filter cutoff.</li>\n</ul>\n<p>Note that if there aren't enough kmers left from the oversketch to satisfy the sketch size, sketching will fail.\nThere are two options that may help:</p>\n<ul>\n<li><code>--oversketch &lt;N&gt;</code> can be used to increase the size of the oversketch (normally 200x) and increase the likelihood that the filtered version will be big enough.</li>\n<li><code>--no-strict</code> will allow Finch to proceed with a sketch smaller than the specified size. Use with caution.</li>\n</ul>\n<h3><code>finch sketch</code></h3>\n<p><code>finch sketch</code> will read through a FASTA or FASTQ file and generate a \"sketch\" that can be used for further .</p>\n<p>If the file being read is a sketch and the filtering flag is set (<code>-f</code>/<code>--filter</code>), the abundance filters will be re-applied to the sketch to allow post-sketch filtering.\nThe strand filters can only be applied to raw FAST(A/Q) files though, as the strand-level data is lost when sketches are saved.</p>\n<p>By default <code>sketch</code> generates <code>.sk</code> suffixed files next to the FAST(A/Q) files it sketches.\nThis can be overridden by passing either <code>-O</code> (capital O) to write to standard out or <code>-o &lt;file&gt;</code> (lowercase o) to write to a file.\nTo read from standard input, use a filename of <code>-</code>; this allows streaming of files into <code>finch</code>, e.g. <code>cat testfile.fq | finch sketch -o testfile.sk -</code>.</p>\n<p>Sketches should be compatible with the original Mash implementation if you edit their <code>src/mash/hash.h</code> and set the hash value to <code>0</code> or if you manually override Finch's seed value by setting <code>--seed 42</code>.</p>\n<h3><code>finch dist</code></h3>\n<p><code>finch dist</code> will calculate Jaccard distances between different sketches.\nIf the files listed are FASTA/Q instead of sketches, Finch will automatically sketch them into memory using the same command-line parameters as in <code>sketch</code> or, for files after the first, the parameters used to sketch the first file.</p>\n<p>Distances and containments will only be computed from one or more queries to a collection of references; by default the first sketch in the list will be used as the query and all other sketches will be used as references.\nThis behavior can be manually overriden and other sketches can be used as references by passing <code>--queries &lt;sketch_1&gt;,&lt;sketch_2</code>.\nAdditionally, passing the <code>--pairwise</code> option will calculate the distances between all sketches and each other.</p>\n<p>Due to different counting algoritms and stopping criteria, distances may be slightly different from the calculation in the original Mash program and older version of finch.\nPassing the <code>-old-dist</code> flag will revert to the older version of Finch's calculation; support for Mash's exact distance calculation has been dropped as of version 0.3.</p>\n<h3><code>finch hist</code></h3>\n<p><code>finch hist</code> will output a histogram in JSON format for each sketch provided.\nThe histogram is a list of the number of minmers at each depth, e.g. <code>{\"sketch_name\": [1, 0, 1]}</code> for a sketch with two minmers, one with a depth of 1 (first position) and one with a depth of 3 (third position).</p>\n<blockquote>\n<p>:warning: \u00a0 You can use the following command with Matplotlib to get a quick histogram: <code>finch hist test.fastq.sk | python -c 'import json; import matplotlib.pyplot as plt; import sys; v = json.loads(sys.stdin.read()).values()[0]; plt.plot(range(1, len(v)+1), v); plt.show()'</code>. Note that the <code>finch hist</code> JSON output is likely to change in a future version to, e.g., a more compact <code>{count: value}</code> format or similar.</p>\n</blockquote>\n<h3><code>finch info</code></h3>\n<p><code>finch info</code> will output a formatted list of % GC, coverage, etc for each sketch provided.</p>\n<blockquote>\n<p>:warning: \u00a0Note that the values returned from this are approximate and the algoritms used to calculate are still rough and liable to change.</p>\n</blockquote>\n<h2>Example Data</h2>\n<p>We've sketched the NCBI RefSeq collection (as of March 27, 2017 using <a href=\"https://github.com/DerrickWood/kraken/blob/master/scripts/download_genomic_library.sh\" rel=\"nofollow\">this script</a>) and made tarballs with individual sketches for each bacterial and viral genome available. Links: <a href=\"https://static.onecodex.com/public/finch-rs/refseq_sketches_21_1000.sk.gz\" rel=\"nofollow\"><em>k=21</em> and <em>n=1,000</em></a>, <a href=\"https://static.onecodex.com/public/finch-rs/refseq_sketches_31_1000.sk.gz\" rel=\"nofollow\"><em>k=31</em> and <em>n=1,000</em></a>, <a href=\"https://static.onecodex.com/public/finch-rs/refseq_sketches_21_10000.sk.gz\" rel=\"nofollow\"><em>k=21</em> and <em>n=10,000</em></a>, and <a href=\"https://static.onecodex.com/public/finch-rs/refseq_sketches_31_10000.sk.gz\" rel=\"nofollow\"><em>k=31</em> and <em>n=10,000</em></a>.</p>\n<h2>References &amp; Notes</h2>\n<p>There are several other implementations of the Mash algorithm which should be compatible/comparable with this one, notably:</p>\n<ul>\n<li><a href=\"https://github.com/marbl/Mash\" rel=\"nofollow\">Mash</a> - First implementation and theoretical paper</li>\n<li><a href=\"https://github.com/dib-lab/sourmash\" rel=\"nofollow\">SourMash</a> - Newer implementation in Python; provides a number of experimental features</li>\n</ul>\n<p>Notes:</p>\n<ul>\n<li><sup>1</sup> Please see, however, <a href=\"https://github.com/marbl/Mash/issues/27\" rel=\"nofollow\">this issue tracking interoperability</a> and note that other implementations may use a different seed value.</li>\n</ul>\n<h2>Python Support</h2>\n<p>Optional Python bindings are in the <code>src/python.rs</code> file and can be built into a python library with:</p>\n<pre>rustup default nightly\npip install maturin\nmaturin install --cargo-extra-args<span class=\"o\">=</span><span class=\"s2\">\"--features=python\"</span> --release --strip\n<span class=\"c1\"># or maturin develop, etc</span>\n<span class=\"c1\"># to cross-compile linux wheels:</span>\ndocker run --rm -v <span class=\"k\">$(</span><span class=\"nb\">pwd</span><span class=\"k\">)</span>:/io konstin2/maturin:master build --cargo-extra-args<span class=\"o\">=</span><span class=\"s2\">\"--features=python\"</span> --release --strip\n</pre>\n<p>Then, e.g. to calculate the similarities between two E. coli:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">finch</span> <span class=\"kn\">import</span> <span class=\"n\">sketch_file</span>\n<span class=\"n\">sketch_one</span> <span class=\"o\">=</span> <span class=\"n\">sketch_file</span><span class=\"p\">(</span><span class=\"s1\">'WIS_EcoB_v2.fas'</span><span class=\"p\">)</span>\n<span class=\"n\">sketch_two</span> <span class=\"o\">=</span> <span class=\"n\">sketch_file</span><span class=\"p\">(</span><span class=\"s1\">'WIS_Eco10798_DRAFTv1.fas'</span><span class=\"p\">)</span>\n<span class=\"n\">cont</span><span class=\"p\">,</span> <span class=\"n\">jacc</span> <span class=\"o\">=</span> <span class=\"n\">sketch_one</span><span class=\"o\">.</span><span class=\"n\">compare</span><span class=\"p\">(</span><span class=\"n\">sketch_two</span><span class=\"p\">)</span>\n</pre>\n<h2>Contributions</h2>\n<p>Problems or suggestions for improvement can be reported through GitHub issues.\nWe are happy to accept and/or mentor any additions or fixes (which are best submitted as pull requests).\nFor our code of conduct, please see <code>CODE_OF_CONDUCT.md</code>.</p>\n\n          </div>"}, "last_serial": 6256038, "releases": {"0.3.0": [{"comment_text": "", "digests": {"md5": "919528c6391bcc3601c62ea9198ff681", "sha256": "e07e08eb33a7804245f4cc5fed16b8f1a4c1596a345b3b97c75e8cc77aa7aad7"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp35-cp35m-macosx_10_7_x86_64.whl", "has_sig": false, "md5_digest": "919528c6391bcc3601c62ea9198ff681", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": null, "size": 379094, "upload_time": "2019-12-06T20:04:41", "upload_time_iso_8601": "2019-12-06T20:04:41.571272Z", "url": "https://files.pythonhosted.org/packages/f3/8a/1f0a7c74a6108f4145eb3c18798ebb6b4b6d1af650d4a876c2d67c212f29/finch_sketch-0.3.0-cp35-cp35m-macosx_10_7_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fa83d4abf499435f29b71e7c37205dc6", "sha256": "34113cad41ab739763841c0a457bcfc23274cf259068e7b27455d9755c66acd1"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp35-cp35m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "fa83d4abf499435f29b71e7c37205dc6", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": null, "size": 456069, "upload_time": "2019-12-06T20:04:45", "upload_time_iso_8601": "2019-12-06T20:04:45.351997Z", "url": "https://files.pythonhosted.org/packages/b9/41/456399f3bfc39d7e7c3808c2d6119d28ca33aa516ea4ccdd3621a0dba736/finch_sketch-0.3.0-cp35-cp35m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1747d58a4b75c6867ffc1ec789909b83", "sha256": "9c9b676519f0cd2c8a5a79942c8acdf31414b1806909b4aeabb5a66eaa06dc2d"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp36-cp36m-macosx_10_7_x86_64.whl", "has_sig": false, "md5_digest": "1747d58a4b75c6867ffc1ec789909b83", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": null, "size": 379083, "upload_time": "2019-12-06T20:04:48", "upload_time_iso_8601": "2019-12-06T20:04:48.706476Z", "url": "https://files.pythonhosted.org/packages/9d/94/400884259cf9eb0d5d7e9a8d48d8797b397158f4eea189be0b6bc68d050e/finch_sketch-0.3.0-cp36-cp36m-macosx_10_7_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "057158ae0ec0be989a81cc4879c7e4c9", "sha256": "f23f184a753d2ee6fff234fab9c700aa715b1d07533f79110c6e5818c0a6e8ee"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp36-cp36m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "057158ae0ec0be989a81cc4879c7e4c9", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": null, "size": 456122, "upload_time": "2019-12-06T20:04:51", "upload_time_iso_8601": "2019-12-06T20:04:51.373516Z", "url": "https://files.pythonhosted.org/packages/91/e0/76a1856560c014e77fde37e8bcd0e8faaace2eb8a2b4cda75da4b49ed459/finch_sketch-0.3.0-cp36-cp36m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7aa94158c0c9f1f98817a81a2e580590", "sha256": "54e7439e62875a11a2ea8b7cc4ac5a5388da1a98cace9a4c1b5b37dd0a97e53c"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp37-cp37m-macosx_10_7_x86_64.whl", "has_sig": false, "md5_digest": "7aa94158c0c9f1f98817a81a2e580590", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 378879, "upload_time": "2019-12-06T20:04:53", "upload_time_iso_8601": "2019-12-06T20:04:53.774921Z", "url": "https://files.pythonhosted.org/packages/29/55/f6070864b9cc2ddb228dcd56a7e667d7b3d5a0c0ceb9a14df2c4b2891038/finch_sketch-0.3.0-cp37-cp37m-macosx_10_7_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7c7059f4a174a89a4fc2f6a5e7c1a2bd", "sha256": "233910a84a3a19d0a70cfb9ee841cba89e096873b2f5c6c692d44f8e968f569a"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "7c7059f4a174a89a4fc2f6a5e7c1a2bd", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 455921, "upload_time": "2019-12-06T20:04:56", "upload_time_iso_8601": "2019-12-06T20:04:56.605603Z", "url": "https://files.pythonhosted.org/packages/a8/97/f77d26e976123e018f8d416985cf9f15246dbfd934a18680cd9aeb12e4a5/finch_sketch-0.3.0-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "919528c6391bcc3601c62ea9198ff681", "sha256": "e07e08eb33a7804245f4cc5fed16b8f1a4c1596a345b3b97c75e8cc77aa7aad7"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp35-cp35m-macosx_10_7_x86_64.whl", "has_sig": false, "md5_digest": "919528c6391bcc3601c62ea9198ff681", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": null, "size": 379094, "upload_time": "2019-12-06T20:04:41", "upload_time_iso_8601": "2019-12-06T20:04:41.571272Z", "url": "https://files.pythonhosted.org/packages/f3/8a/1f0a7c74a6108f4145eb3c18798ebb6b4b6d1af650d4a876c2d67c212f29/finch_sketch-0.3.0-cp35-cp35m-macosx_10_7_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fa83d4abf499435f29b71e7c37205dc6", "sha256": "34113cad41ab739763841c0a457bcfc23274cf259068e7b27455d9755c66acd1"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp35-cp35m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "fa83d4abf499435f29b71e7c37205dc6", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": null, "size": 456069, "upload_time": "2019-12-06T20:04:45", "upload_time_iso_8601": "2019-12-06T20:04:45.351997Z", "url": "https://files.pythonhosted.org/packages/b9/41/456399f3bfc39d7e7c3808c2d6119d28ca33aa516ea4ccdd3621a0dba736/finch_sketch-0.3.0-cp35-cp35m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1747d58a4b75c6867ffc1ec789909b83", "sha256": "9c9b676519f0cd2c8a5a79942c8acdf31414b1806909b4aeabb5a66eaa06dc2d"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp36-cp36m-macosx_10_7_x86_64.whl", "has_sig": false, "md5_digest": "1747d58a4b75c6867ffc1ec789909b83", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": null, "size": 379083, "upload_time": "2019-12-06T20:04:48", "upload_time_iso_8601": "2019-12-06T20:04:48.706476Z", "url": "https://files.pythonhosted.org/packages/9d/94/400884259cf9eb0d5d7e9a8d48d8797b397158f4eea189be0b6bc68d050e/finch_sketch-0.3.0-cp36-cp36m-macosx_10_7_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "057158ae0ec0be989a81cc4879c7e4c9", "sha256": "f23f184a753d2ee6fff234fab9c700aa715b1d07533f79110c6e5818c0a6e8ee"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp36-cp36m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "057158ae0ec0be989a81cc4879c7e4c9", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": null, "size": 456122, "upload_time": "2019-12-06T20:04:51", "upload_time_iso_8601": "2019-12-06T20:04:51.373516Z", "url": "https://files.pythonhosted.org/packages/91/e0/76a1856560c014e77fde37e8bcd0e8faaace2eb8a2b4cda75da4b49ed459/finch_sketch-0.3.0-cp36-cp36m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7aa94158c0c9f1f98817a81a2e580590", "sha256": "54e7439e62875a11a2ea8b7cc4ac5a5388da1a98cace9a4c1b5b37dd0a97e53c"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp37-cp37m-macosx_10_7_x86_64.whl", "has_sig": false, "md5_digest": "7aa94158c0c9f1f98817a81a2e580590", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 378879, "upload_time": "2019-12-06T20:04:53", "upload_time_iso_8601": "2019-12-06T20:04:53.774921Z", "url": "https://files.pythonhosted.org/packages/29/55/f6070864b9cc2ddb228dcd56a7e667d7b3d5a0c0ceb9a14df2c4b2891038/finch_sketch-0.3.0-cp37-cp37m-macosx_10_7_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7c7059f4a174a89a4fc2f6a5e7c1a2bd", "sha256": "233910a84a3a19d0a70cfb9ee841cba89e096873b2f5c6c692d44f8e968f569a"}, "downloads": -1, "filename": "finch_sketch-0.3.0-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "7c7059f4a174a89a4fc2f6a5e7c1a2bd", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 455921, "upload_time": "2019-12-06T20:04:56", "upload_time_iso_8601": "2019-12-06T20:04:56.605603Z", "url": "https://files.pythonhosted.org/packages/a8/97/f77d26e976123e018f8d416985cf9f15246dbfd934a18680cd9aeb12e4a5/finch_sketch-0.3.0-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}], "timestamp": "Fri May  8 00:42:26 2020"}