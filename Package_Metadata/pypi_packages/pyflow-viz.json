{"info": {"author": "Jay Kim", "author_email": "", "bugtrack_url": null, "classifiers": [], "description": "\nPyflow-Viz\n==========\n\nPyflow is a light weight library that lets the user construct a memory efficient directed acyclic computation graph (DAG) that evaluates lazily. It can cache intermediate results, only compute the parts of the graph that has data dependency, and immediately release memory of data whose dependecy is no longer required. Pyflow is simple and light, built purely on Python, using the weak references for memory management and doubly linked list for DAG construction. \n\nUnlike computation graph based engines such as Dask or PySpark, Pyflow is not meant to be a parallel data processor, or to change the way computation resources are used. Instead, it is meant to be a light weight tool for code organization in the form of DAG and for graph visualization that can be used on top of Dask or PySpark. \n\nInstall\n-------\n\n::\n\n\tpip install pyflow-viz\n\nGetting started\n---------------\n\nLet's construct a simple computation graph: (Note the similarity of API to that of Keras functional API!)\n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tdef adding(a, b):\n\t\treturn a + b\n\n\tG = GraphBuilder()\n\ta1 = G.add(adding)(2, 2)  # you add methods with `add` instance method.\n\ta2 = G.add(adding)(3, a1)\n\ta3 = G.add(adding)(a1, a2)\n\nAt this point, no evaluation has occurred. Also, the outputs ``a1``, ``a2``, and ``a3`` are ``DataNode`` objects (well, more precisely, weak references to the ``DataNode`` objects)\nYou can kick off the evaluation by invoking ``get`` method from any of the output objects:\n\n.. code:: python\n\n\tprint(a3.get())  # 11\n\nYou can also easily visualize the DAG using ``view`` method:\n\n.. code:: python\n\n\tG.view()\n\n.. figure:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/simple_dag.png\n\n\nA couple notes:\n\n1. The API was inspired by that of the `Keras functional API <https://keras.io/getting-started/functional-api-guide/>`_\n2. For demo, we are using a simple method of adding two integers, but the input method can be any python function, including instance methods, with arbitrary inputs such as numpy array, pandas dataframe or Spark dataframe.\n3. Lastly, more often then not, you will execute the graph with ``run`` method instead of invoking ``get`` on the individual data nodes. ``run`` method will be discussed more in-depth once we understand how Pyflow manages computation and memory internally. For now, just note that you can kick off the graph this way as well, which is the preferred way:\n\n.. code:: python\n\n\tG.run()  # will run all the operation nodes\n\nYou can also pass in data nodes to get the results back this way:\n\n.. code:: python\n\n\ta1_result, a3_result = G.run(a1, a3)  # will run all the operation nodes, and return the result data values of a1, a3\n\n\nMulti-output methods\n--------------------\n\nWhat if we have a python function with multiple outputs? Due to dynamic nature of python, it is impossible to determine the number of outputs before the function is actually ran. In such a case, you need to specify the number of outputs by ``n_out`` argument:\n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tdef adding(a, b):\n\t\treturn a + b\n\n\tdef multi_output_method(a, b):\n\t\treturn a+1, b+1\n\n\tG = GraphBuilder()\n\ta1 = G.add(adding)(2, 2)\n\ta2, b2 = G.add(multi_output_method, n_out=2)(a1, 2)  # n_out argument!\n\ta3 = G.add(adding)(a2, 3)\n\ta4 = G.add(adding)(b2, a1)\n\n\tG.view()\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/multi_output.png\n   :width: 17pt\n\n\nVisualizing data flow\n---------------------\n\nThe ``view`` function actually has the ability to summarize the DAG by only showing the user the ``OperationNodes``, which it does by default. We can override this default setting by using the ``summary`` parameter of the function:\n\n.. code:: python\n\n\tG.view(summary=False)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/summary_false.png\n   :width: 17pt\n\nWith the summary functionality turned off, the complete DAG visualization will includes ``DataNodes`` as well as the ``OperationNodes``. You may be wondering what the extra records with ``(1, )`` written inside are. They signal the data persistence. We will discuss what this is, and how this works, in greater detail later. \n\n\nRemoving methods\n----------------\n\nWhen constructing a graph during an interactive session using tools like Jupyter Notebook, often there is a need to remove an operation node in order to correct for mistakes. You can achieve that by calling ``remove`` method. Let's look at an example.\n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tdef adding(x, y):\n\t\treturn x + y\n\n\tdef wrong_method(x, r):\n\t\treturn x + r\n\n\tdef correct_method(x, r):\n\t\treturn x*r\n\n\tG = GraphBuilder(verbose=False)\n\ta = G.add(adding)(1, 2)\n\tb = G.add(wrong_method)(a, 1)  # added wrong method!\n\n\tG.view(summary=False)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/removing1.png\n   :width: 17pt\n\nIn the above code, we added a ``wrong_method`` by mistake, and it needs to be replaced by ``correct_method``. If we just add the correct method on top, we will simply end up creating another node:\n\n.. code:: python\n\n\tb = G.add(correct_method)(a, 1)  # can't just add correct_method node!\n\n\tG.view(summary=False)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/removing2.png\n   :width: 17pt\n\nAs you can see, you will simply have added the correct node without removing the original wrong method. In such a situation, we need to first remove the wrong node by invoking ``remove`` method. The ``remove`` method will erase the last operation node that was added. Let's go back to where we were right after adding ``wrong_method``. At this point, call ``remove``:\n\n.. code:: python\n\n\tG.remove()\n\n\tG.view(summary=False)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/removing3.png\n   :width: 17pt\n\nAs you can see, the last operation node is now gone. ``remove`` method will also remove all children data node (thereby releasing their memory) that depends on that node. Also, it will remove all data node that holds any raw input that were fed into the operation node. It will not, however, remove any other part of the graph. \n\nAt this point, we can add the corrected version of the method:\n\n.. code:: python\n\n\tb = G.add(correct_method)(a, 1)\n\n\tG.view(summary=False)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/removing4.png\n   :width: 17pt\n\nOn a more technical note, even though there is variable ``b``, ``remove`` can still release the memory of all the associated nodes because Pyflow operates on weak references. Pyflow keeps only one strong reference per node inside the GraphBuilder class instance (i.e. ``strong_ref_dict``). To check this, simply check ``b`` variable upon invoking ``remove``. You will see that ``b`` is now a dead (weak) reference that does not point to any particular Python object in memory. \n\nLastly, you can pass in ``n`` argument to ``remove`` method. This will remove the last ``n`` operation nodes. The default value is 1, i.e. it removes the latest 1 operation node. \n\nStyling your DAG\n----------------\n\nPyflow lets the user customize the DAG visuals to a certain degree, with more to come in the future. Let's take a look at some examples.\n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tdef query_dataframe_A():\n\t\treturn 1  # pretend this was a pandas or Spark dataframe!\n\n\tdef query_dataframe_B():\n\t\treturn 2\n\n\tdef product_transform(inp):\n\t\treturn inp*2\n\n\tdef join_transform(inp1, inp2):\n\t\treturn inp1 + inp2\n\n\tdef split_transform(inp):\n\t\treturn inp+1, inp+2\n\n\tG = GraphBuilder()\n\tdf1 = G.add(query_dataframe_A)()\n\tdf2 = G.add(query_dataframe_B)()\n\tnew_df1 = G.add(product_transform)(df1)\n\tnew_df2 = G.add(product_transform)(df2)\n\tdfa, dfb = G.add(split_transform, n_out=2)(new_df2)\n\tjoined_df = G.add(join_transform)(new_df1, dfa)\n\n\tG.view()\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/queryingA.png\n   :width: 10pt\n\nBut since at a conceptual level, queries are similarly progenitors of new data, perhaps we want to put them side by side on top, and position is controlled by ``rank`` parameter. Also, since these are probably coming from some data storage, we might want to style their nodes accordingly, with different color.\n\n.. code:: python\n\n\tG = GraphBuilder()\n\tdf1 = G.add(query_dataframe_A, rank=0, shape='cylinder', color='lightblue')()\n\tdf2 = G.add(query_dataframe_B, rank=0, shape='cylinder', color='lightblue')()\n\tnew_df1 = G.add(product_transform)(df1)\n\tnew_df2 = G.add(product_transform)(df2)\n\tdfa, dfb = G.add(split_transform, n_out=2)(new_df2)\n\tjoined_df = G.add(join_transform)(new_df1, dfa)\n\n\tG.view()\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/queryingB.png\n   :width: 10pt\n\n\nBut then we might want to make the DAG a little shorter, especially if we are to add more and more intermediate steps. We can control more detailed aesthetics with ``graph_attributes``:\n\n.. code:: python\n\n\tgraph_attributes = {'graph_ranksep': 0.25}\n\n\tG.view(graph_attributes=graph_attributes)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/shortGraph.png\n   :width: 10pt\n\nYou can take a look and play around with the rest of the configurations: \n\n.. code:: python\n\n\tG.graph_attributes \n\n\t# the default settings are found at:\n\tG.default_graph_attributes\n\n\t# 'data_node_fontsize': 10, \n\t# 'data_node_shape': 'box',\n\t# 'data_node_color': None,\n\t# 'op_node_fontsize': 12,\n\t# 'op_node_shape': 'box',\n\t# 'op_node_color': 'white',\n\t# 'graph_ranksep': 0.475,\n\t# 'graph_node_fontsize': 12.85,\n\t# 'graph_node_shape': 'box3d',\n\t# 'graph_node_color': 'white',\n\t# 'graph_node_shapesize': 0.574,\n\t# 'persist_record_shape': True\n\n\n\nFinally, you can set the alias of the nodes by passing in ``method_alias`` and/or ``output_alias`` in the ``add`` method. The ``method_alias`` will set the alias of the operation node being added, and ``output_alias`` will set the alias of the child data node of that operation node. \n\n.. code:: python\n\n\tG = GraphBuilder()\n\tdfa = G.add(query_dataframe_A, rank=0, shape='cylinder', color='lightblue', output_alias='df_A')()\n\tdfb = G.add(query_dataframe_B, rank=0, shape='cylinder', color='lightblue', output_alias='df_B')()\n\tdfa1 = G.add(product_transform)(dfa)\n\tdfb1 = G.add(product_transform)(dfb)\n\t# note the list of alias for n_out = 2\n\tdfa, dfb = G.add(split_transform, n_out=2, output_alias=['first_out', 'second_out'])(dfa1)\n\tjoined_df = G.add(join_transform, output_alias='final_data')(dfb1, dfa)\n\n\tgraph_attributes = {'graph_ranksep': 0.25}\n\tG.view(summary=False, graph_attributes=graph_attributes)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/aliasingGraph.png\n   :width: 10pt\n\n\nThe default alias for operation node is the String name of the method being passed in, and the default alias for data node is simply \"data\". We do not include the example of setting ``method_alias`` to discourage its use. Setting method alias different from the method name will make look up of graph node in the code base very difficult. \n\n\nNo output methods\n-----------------\n\nOften when we are processing data, we will end up doing something with that data, whether it is to upload it somewhere, save it somewhere, or use pass it to a model, etc. In those cases, we do not expect any return data. \n\n.. code:: python\n\n\t# this method does not have return statement\n\tdef save_data(data):\n\n\t\t# save the data somewhere\n\t\t# no return statement needed\n\t\tpass\n\nPyflow will create graph accordingly, such that the outputless operation node is a leaf node. \n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tdef query_dataframe_A():\n\t\treturn 1  # pretend this was a pandas or Spark dataframe!\n\n\tdef query_dataframe_B():\n\t\treturn 2\n\n\tdef product_transform(inp):\n\t\treturn inp*2\n\n\tdef join_transform(inp1, inp2):\n\t\treturn inp1 + inp2\n\n\tdef split_transform(inp):\n\t\treturn inp+1, inp+2\n\n\tdef save_data(data):\n\t\t# save the data somewhere\n\t\t# no return statement needed\n\t\tpass\n\n\tG = GraphBuilder()\n\tdf1 = G.add(query_dataframe_A, rank=0, shape='cylinder', color='lightblue')()\n\tdf2 = G.add(query_dataframe_B, rank=0, shape='cylinder', color='lightblue')()\n\tnew_df1 = G.add(product_transform)(df1)\n\tnew_df2 = G.add(product_transform)(df2)\n\tdfa, dfb = G.add(split_transform, n_out=2)(new_df2)\n\tjoined_df = G.add(join_transform)(new_df1, dfa)\n\tG.add(save_data)(dfb)\n\tG.add(save_data)(joined_df)\n\n\tgraph_attributes = {'graph_ranksep': 0.25}\n\tG.view(summary=False, graph_attributes=graph_attributes)\n\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/no_output_.png\n   :width: 10pt\n\n\nThis is a more realistic shape of the DAG in the actual use case of data preprocessing. Also, this is why ``run`` method makes more sense to use then ``get`` method in most realistic use cases. As you can see above, there is no data node from which we can call ``get`` method to retrieve the data. We are not interested in the data per se as we are in what we can do with the data. And most of the time, when we do something with our data, the end result is not another data. This does not mean you shouldn't use ``get``. There might be situations where you would want to get the data back, especially during interactive sessions. \n\n\nGrafting graphs together\n------------------------\n\nWhen the computation graph becomes too big, the size of the visualized graph can actually end up becoming a hinderance to clean data flow documentation. Not only that, we could also benefit at the conceptual code organization level, if we had the ability to define multiple graphs and combine them together flexibly. I.e. we could treat a graph as if it was just another operation node. As of version ``0.7``, we can do this. Let's look at an example:\n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tdef adding(a, b):\n\t\treturn a+b\n\n\tG = GraphBuilder(alias='First Graph')  # notice alias at graph level!\n\ta1 = G.add(adding)(1, 2)\n\ta2 = G.add(adding)(a1, 2)\n\ta3 = G.add(adding, output_alias='leaving!')(a1, a2)\n\n\tG.view()\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/graft1.png\n   :width: 10pt\n\nLet's look at the unsummarized version to take notice of the output_alias of the last data node:\n\n.. code:: python\n\n\t# let's make it a little shorter with ranksep parameter we talked about earlier!\n\tG.view(summary=False, graph_attributes={'graph_ranksep': 0.3})\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/graft2.png\n   :width: 10pt\n\nIn the above code, we have created one graph. But we can create another graph, and graft the ``First Graph`` graph to the new graph:\n\n.. code:: python\n\n\tH = GraphBuilder(alias='Second Graph')\n\n\tb1 = H.add(adding)(1, 3)\n\tb2 = H.add(adding)(b1, a3)\n\tb3 = H.add(adding)(b1, b2)\n\n\tH.view(summary=False)  # notice that the output_alias from previous graph is also preserved! \n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/graft3_.png\n   :width: 10pt\n\nAs you can see, the previous graph is now summarized into a box. You can combine as many graphs in this way as you want. Despite this visual effect, ``b3`` is now part of one single big combined computation graph. Therefore, calling ``b3.get()`` will trigger computations in nodes that belong to both ``G`` and ``H`` as long as they are needed. As far as computation is concerned, you just have one big graph. \n\n\nSaving your DAG image\n---------------------\n\nYou can easily save your DAG image by invoking ``save_view`` method, which returns the file path of the saved image:\n\n.. code:: python\n\n\tG.save_view()\n\nThe ``save_view`` method also has ``summary`` boolean parameter. You can also set the file name and file path by passing in ``dirpath`` and ``filename`` parameter. They default to current working directory and \"digraph\" respectively. You can also set the file format as png or pdf by setting ``fileformat`` parameter. The default is png. \n\n\nComputation and memory efficiency of Pyflow\n-------------------------------------------\n\nWhen you invoke ``get`` method, pyflow will only then evaluate, and it will evaluate only the parts of the graph that is needed to be evaluated. Also, as soon as an intermediate result has no dependency, it will automatically release the memory back to the operating system. Let's take a tour of the computation process to better understand this mechanism by turning on ``verbose`` parameter. \n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tdef adding(a, b):\n\t\treturn a + b\n\n\tdef multi_output_method(a, b):\n\t\treturn a+1, b+1\n\n\tG = GraphBuilder(verbose=True)  # set verbose to True\n\ta1 = G.add(adding)(1, 2)\n\ta2, a3 = G.add(return2, n_out=2)(a1, 3)\n\ta4 = G.add(adding)(a1, 5)\n\ta5 = G.add(adding)(a4, a3)\n\n\ta5.get()\n\nWith ``verbose=True``, along with the final output, pyflow will also produce the following standard output:\n\n::\n\n\tcomputing for data_12\n\tadding_11 activated!\n\tadding_8 activated!\n\tadding_0 activated!\n\treturn2_4 activated!\n\tcomputing for data_10\n\tcomputing for data_3\n\trunning adding_0\n\tadding_0 deactivated!\n\trunning adding_8\n\tdata_3 still needed at return2_4\n\tadding_8 deactivated!\n\tcomputing for data_7\n\trunning return2_4\n\tdata_3 released!\n\treturn2_4 deactivated!\n\trunning adding_11\n\tdata_10 released!\n\tdata_7 released!\n\tadding_11 deactivated!\n\nLet's take the tour of this process by looking at the graph. Notice that in verbose mode, the graph will actually print out the uid's of the nodes not just their aliases (more on setting alias later!)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/verbose_.png\n   :width: 10pt\n\nAs pyflow tries to compute ``data_12``, it will first activate all the ``OperationNodes`` that is needed for the computation, in our case, those are ``adding_11``, ``adding_8``, ``adding_0``, ``return2_4``. It will then follow the lineage of the graph to work on intermediate results needed to proceed down the graph. Notice that as the computation proceeds, the ``OperationNodes`` that were activated are deactivated. When it gets to ``data_3``, notice that it is needed at both ``adding_8`` and ``return2_4``. Thus, once it completes ``adding_8``, it cannot yet release the memory from ``data_3``: ``data_3 still needed at return2_4``. But as soon as ``return2_4`` is ran, it releases ``data_3`` from memory, as it is not needed anymore: ``data_3 released!``. The ``DataNodes`` with raw inputs such as integers are not released since there is no way for the graph to reconstruct them. \n\nBy the same token, if you were to run the graph from middle, say, at ``a4``:\n\n.. code:: python\n\n\ta4.get()\n\nYou will see:\n\n::\n\n\tcomputing for data_10\n\tadding_8 activated!\n\tadding_0 activated!\n\tcomputing for data_3\n\trunning adding_0\n\tadding_0 deactivated!\n\trunning adding_8\n\tdata_3 released!\n\tadding_8 deactivated!\n\nIn this case, since ``return2_4`` is not activated, the ``data_3`` does not consider its presence in deciding release of memory. \n\nOn the other hand, ``run`` method will activate *all* operation nodes. This will make sure that even the operation nodes that do not have children are ran. However, the immediate memory release mechanism still applies to ``run`` method, unless otherwise specified. Refer below. \n\nMemory persistance with Pyflow\n------------------------------\n\nLastly, you have the option of either persisting all of the intermediate results, or persisting part of the intermediate results.\n\nTo persist all intermediate results, use ``persist`` parameter at ``GraphBuilder`` level:\n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tG = GraphBuilder(persist=True)  # set persist to True\n\n\ta1 = G.add(adding)(1, 2)\n\ta2, a3 = G.add(return2, n_out=2)(a1, 3)\n\ta4 = G.add(adding)(a1, 5) \n\ta5 = G.add(adding)(a4, a3)\n\n\ta5.get()\n\nWith persist enabled, after running ``a5.get()``, when you try to run ``a4.get()``, the graph will not recompute anything because ``a4`` node result will have been cached in memory. The persist is turned off by default, as it is assumed that the user of the pyflow will process large amounts of data. \n\nTo persist parts of the data, you can specify the ``persist`` parameter at ``add`` level:\n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tG = GraphBuilder(persist=False)  # default value\n\n\ta1 = G.add(adding)(1, 2)\n\ta2, a3 = G.add(return2, n_out=2)(a1, 3)\n\ta4 = G.add(adding, persist=True)(a1, 5)  # persist here\n\ta5 = G.add(adding)(a4, a3)\n\n\ta5.get()\n\nThen, when you run ``a4.get()`` it will not rerun the computation as ``a4`` result has been cached in memory although all other intermediate results will have been released.  \n\nAt last, we can understand the difference between ``run()`` and ``run(a1, a3)``. Even if you don't persist anything, either at the graph level or the node level, by passing in the ``a1, a3``, the graph will automatically persist their data for you, and return the persisted data by internally invoking ``get()`` on the nodes ``a1, a3``. The rest of data nodes are subject to the same immediate memory release mechanism. \n\nIn terms of the codes, these two are equivalent:\n\n.. code:: python\n\n\t# run() with arguments:\n\n\tfrom pyflow import GraphBuilder\n\n\tG = GraphBuilder()\n\ta1 = G.add(adding)(1, 2)\n\ta2 = G.add(adding)(a1, 3)\n\ta3 = G.add(adding)(a2, a1)\n\n\ta1_val, a3_val = G.run(a1, a3)\n\n\n\t# run() without arguments:\n\n\tG = GraphBuilder()\n\ta1 = G.add(adding, persist=True)(1, 2)\n\ta2 = G.add(adding)(a1, 3)\n\ta3 = G.add(adding)(a2, a1)\n\n\tG.run()\n\n\ta1_val = a1.get()\n\ta3_val = a3.get()\n\nAlso, when you persist certain nodes, this persistence request will manifest in the graph by an empty record box:\n\n.. code:: python\n\n\tfrom pyflow import GraphBuilder\n\n\tG = GraphBuilder()\n\ta1 = G.add(adding)(1, 2)\n\ta2 = G.add(adding)(a1, 3)\n\ta3 = G.add(adding)(a2, a1)\n\n\tG.view()\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/record1.png\n   :width: 10pt\n\nThe empty box signifies that the graph is requested to persist that data, but it does not yet hold that data because it has not yet been executed. But once you run the graph, the empty record slot will be filled by the dimensionality of the resulting data. Currently it supports PySpark dataframe, numpy array, and pandas dataframe. All other data will have a default dimension of ``(1, )``. \n\n.. code:: python\n\n\tG.run()\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/record2.png\n   :width: 10pt\n\nNow, of course, it is not the method that is being persisted but the resulting data of that op node. You can see this when you visualize the DAG with ``summary=False``:\n\n.. code:: python\n\n\tG.run(summary=False)\n\n.. image:: https://github.com/mozjay0619/pyflow-viz/blob/master/media/record3.png\n   :width: 10pt\n\nSome notes:\n\n1. The op node with record box is a short hand way of conveying the message that the child data node of that op node will be persisted. \n2. The raw data are automatically persisted, which is why you see the dimensionality information in the record box. This is because the raw user data inputs cannot be recomputed from the graph alone. But this will not be visible when ``summary=True``, because the op node will only show the record box for persisted child data node, and user supplied inputs will always be parent data node. \n3. Although this is not made explicitly visible, the final leaf data node are always persisted when ``run`` method is invoked. But this will not be explicitly shown in the graph unless the user manually supplies ``persist`` flag at the ``add`` method invocation. \n4. Lastly, the ``persist`` flag is interoperable with Spark when PySpark dataframe is the data type. This means, when you persist the data using the DAG, if the underlying data is a PySpark dataframe, the Pyflow will persist the dataframe for you. However, unpersisting is not done by the Pyflow. If you want to unpersist a dataframe, do so manually. \n\n\n\n\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "DSB 3-clause", "maintainer": "", "maintainer_email": "", "name": "pyflow-viz", "package_url": "https://pypi.org/project/pyflow-viz/", "platform": "", "project_url": "https://pypi.org/project/pyflow-viz/", "project_urls": null, "release_url": "https://pypi.org/project/pyflow-viz/0.12/", "requires_dist": ["graphviz (>=0.13.2)"], "requires_python": "", "summary": "Lazy computation directed acyclic graph builder", "version": "0.12", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Pyflow is a light weight library that lets the user construct a memory efficient directed acyclic computation graph (DAG) that evaluates lazily. It can cache intermediate results, only compute the parts of the graph that has data dependency, and immediately release memory of data whose dependecy is no longer required. Pyflow is simple and light, built purely on Python, using the weak references for memory management and doubly linked list for DAG construction.</p>\n<p>Unlike computation graph based engines such as Dask or PySpark, Pyflow is not meant to be a parallel data processor, or to change the way computation resources are used. Instead, it is meant to be a light weight tool for code organization in the form of DAG and for graph visualization that can be used on top of Dask or PySpark.</p>\n<div id=\"install\">\n<h2>Install</h2>\n<pre>pip install pyflow-viz\n</pre>\n</div>\n<div id=\"getting-started\">\n<h2>Getting started</h2>\n<p>Let\u2019s construct a simple computation graph: (Note the similarity of API to that of Keras functional API!)</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">adding</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>  <span class=\"c1\"># you add methods with `add` instance method.</span>\n<span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">)</span>\n<span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">)</span>\n</pre>\n<p>At this point, no evaluation has occurred. Also, the outputs <tt>a1</tt>, <tt>a2</tt>, and <tt>a3</tt> are <tt>DataNode</tt> objects (well, more precisely, weak references to the <tt>DataNode</tt> objects)\nYou can kick off the evaluation by invoking <tt>get</tt> method from any of the output objects:</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">a3</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">())</span>  <span class=\"c1\"># 11</span>\n</pre>\n<p>You can also easily visualize the DAG using <tt>view</tt> method:</p>\n<pre><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span>\n</pre>\n<div>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/simple_dag.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2ab56498f59aeade48bbbb222b518d7f96a201c0/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f73696d706c655f6461672e706e67\">\n</div>\n<p>A couple notes:</p>\n<ol>\n<li>The API was inspired by that of the <a href=\"https://keras.io/getting-started/functional-api-guide/\" rel=\"nofollow\">Keras functional API</a></li>\n<li>For demo, we are using a simple method of adding two integers, but the input method can be any python function, including instance methods, with arbitrary inputs such as numpy array, pandas dataframe or Spark dataframe.</li>\n<li>Lastly, more often then not, you will execute the graph with <tt>run</tt> method instead of invoking <tt>get</tt> on the individual data nodes. <tt>run</tt> method will be discussed more in-depth once we understand how Pyflow manages computation and memory internally. For now, just note that you can kick off the graph this way as well, which is the preferred way:</li>\n</ol>\n<pre><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>  <span class=\"c1\"># will run all the operation nodes</span>\n</pre>\n<p>You can also pass in data nodes to get the results back this way:</p>\n<pre><span class=\"n\">a1_result</span><span class=\"p\">,</span> <span class=\"n\">a3_result</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span>  <span class=\"c1\"># will run all the operation nodes, and return the result data values of a1, a3</span>\n</pre>\n</div>\n<div id=\"multi-output-methods\">\n<h2>Multi-output methods</h2>\n<p>What if we have a python function with multiple outputs? Due to dynamic nature of python, it is impossible to determine the number of outputs before the function is actually ran. In such a case, you need to specify the number of outputs by <tt>n_out</tt> argument:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">adding</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">multi_output_method</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">b2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">multi_output_method</span><span class=\"p\">,</span> <span class=\"n\">n_out</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>  <span class=\"c1\"># n_out argument!</span>\n<span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">a4</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">b2</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">)</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/multi_output.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/57c5343d301be36f562e37e41701f8653a7e6ce7/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f6d756c74695f6f75747075742e706e67\" width=\"17pt\">\n</div>\n<div id=\"visualizing-data-flow\">\n<h2>Visualizing data flow</h2>\n<p>The <tt>view</tt> function actually has the ability to summarize the DAG by only showing the user the <tt>OperationNodes</tt>, which it does by default. We can override this default setting by using the <tt>summary</tt> parameter of the function:</p>\n<pre><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/summary_false.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/40942cb6d1818454084fc9ba64bebcd99b9e20ed/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f73756d6d6172795f66616c73652e706e67\" width=\"17pt\">\n<p>With the summary functionality turned off, the complete DAG visualization will includes <tt>DataNodes</tt> as well as the <tt>OperationNodes</tt>. You may be wondering what the extra records with <tt>(1, )</tt> written inside are. They signal the data persistence. We will discuss what this is, and how this works, in greater detail later.</p>\n</div>\n<div id=\"removing-methods\">\n<h2>Removing methods</h2>\n<p>When constructing a graph during an interactive session using tools like Jupyter Notebook, often there is a need to remove an operation node in order to correct for mistakes. You can achieve that by calling <tt>remove</tt> method. Let\u2019s look at an example.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">adding</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">wrong_method</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">r</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">correct_method</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">r</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">(</span><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">wrong_method</span><span class=\"p\">)(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># added wrong method!</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/removing1.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a6a4c9718c5c9af6b33de9115f5cc2f3ad904cdc/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f72656d6f76696e67312e706e67\" width=\"17pt\">\n<p>In the above code, we added a <tt>wrong_method</tt> by mistake, and it needs to be replaced by <tt>correct_method</tt>. If we just add the correct method on top, we will simply end up creating another node:</p>\n<pre><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">correct_method</span><span class=\"p\">)(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># can't just add correct_method node!</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/removing2.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0736c1ea40f93fd61c34d962b93e1a174bfdbd3d/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f72656d6f76696e67322e706e67\" width=\"17pt\">\n<p>As you can see, you will simply have added the correct node without removing the original wrong method. In such a situation, we need to first remove the wrong node by invoking <tt>remove</tt> method. The <tt>remove</tt> method will erase the last operation node that was added. Let\u2019s go back to where we were right after adding <tt>wrong_method</tt>. At this point, call <tt>remove</tt>:</p>\n<pre><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">()</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/removing3.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ee487db6182102edcf8dd9d888347abdf1ac7782/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f72656d6f76696e67332e706e67\" width=\"17pt\">\n<p>As you can see, the last operation node is now gone. <tt>remove</tt> method will also remove all children data node (thereby releasing their memory) that depends on that node. Also, it will remove all data node that holds any raw input that were fed into the operation node. It will not, however, remove any other part of the graph.</p>\n<p>At this point, we can add the corrected version of the method:</p>\n<pre><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">correct_method</span><span class=\"p\">)(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/removing4.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d3a747d66738e0bc22b29737091d5b3bf2185457/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f72656d6f76696e67342e706e67\" width=\"17pt\">\n<p>On a more technical note, even though there is variable <tt>b</tt>, <tt>remove</tt> can still release the memory of all the associated nodes because Pyflow operates on weak references. Pyflow keeps only one strong reference per node inside the GraphBuilder class instance (i.e. <tt>strong_ref_dict</tt>). To check this, simply check <tt>b</tt> variable upon invoking <tt>remove</tt>. You will see that <tt>b</tt> is now a dead (weak) reference that does not point to any particular Python object in memory.</p>\n<p>Lastly, you can pass in <tt>n</tt> argument to <tt>remove</tt> method. This will remove the last <tt>n</tt> operation nodes. The default value is 1, i.e. it removes the latest 1 operation node.</p>\n</div>\n<div id=\"styling-your-dag\">\n<h2>Styling your DAG</h2>\n<p>Pyflow lets the user customize the DAG visuals to a certain degree, with more to come in the future. Let\u2019s take a look at some examples.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">query_dataframe_A</span><span class=\"p\">():</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span>  <span class=\"c1\"># pretend this was a pandas or Spark dataframe!</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">query_dataframe_B</span><span class=\"p\">():</span>\n        <span class=\"k\">return</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">product_transform</span><span class=\"p\">(</span><span class=\"n\">inp</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">inp</span><span class=\"o\">*</span><span class=\"mi\">2</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">join_transform</span><span class=\"p\">(</span><span class=\"n\">inp1</span><span class=\"p\">,</span> <span class=\"n\">inp2</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">inp1</span> <span class=\"o\">+</span> <span class=\"n\">inp2</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">split_transform</span><span class=\"p\">(</span><span class=\"n\">inp</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">inp</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">inp</span><span class=\"o\">+</span><span class=\"mi\">2</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">df1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">query_dataframe_A</span><span class=\"p\">)()</span>\n<span class=\"n\">df2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">query_dataframe_B</span><span class=\"p\">)()</span>\n<span class=\"n\">new_df1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">product_transform</span><span class=\"p\">)(</span><span class=\"n\">df1</span><span class=\"p\">)</span>\n<span class=\"n\">new_df2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">product_transform</span><span class=\"p\">)(</span><span class=\"n\">df2</span><span class=\"p\">)</span>\n<span class=\"n\">dfa</span><span class=\"p\">,</span> <span class=\"n\">dfb</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">split_transform</span><span class=\"p\">,</span> <span class=\"n\">n_out</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"n\">new_df2</span><span class=\"p\">)</span>\n<span class=\"n\">joined_df</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">join_transform</span><span class=\"p\">)(</span><span class=\"n\">new_df1</span><span class=\"p\">,</span> <span class=\"n\">dfa</span><span class=\"p\">)</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/queryingA.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/290fad7473fa21b2ff29db6220b4ba6524e929db/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f7175657279696e67412e706e67\" width=\"10pt\">\n<p>But since at a conceptual level, queries are similarly progenitors of new data, perhaps we want to put them side by side on top, and position is controlled by <tt>rank</tt> parameter. Also, since these are probably coming from some data storage, we might want to style their nodes accordingly, with different color.</p>\n<pre><span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">df1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">query_dataframe_A</span><span class=\"p\">,</span> <span class=\"n\">rank</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"s1\">'cylinder'</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"s1\">'lightblue'</span><span class=\"p\">)()</span>\n<span class=\"n\">df2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">query_dataframe_B</span><span class=\"p\">,</span> <span class=\"n\">rank</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"s1\">'cylinder'</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"s1\">'lightblue'</span><span class=\"p\">)()</span>\n<span class=\"n\">new_df1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">product_transform</span><span class=\"p\">)(</span><span class=\"n\">df1</span><span class=\"p\">)</span>\n<span class=\"n\">new_df2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">product_transform</span><span class=\"p\">)(</span><span class=\"n\">df2</span><span class=\"p\">)</span>\n<span class=\"n\">dfa</span><span class=\"p\">,</span> <span class=\"n\">dfb</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">split_transform</span><span class=\"p\">,</span> <span class=\"n\">n_out</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"n\">new_df2</span><span class=\"p\">)</span>\n<span class=\"n\">joined_df</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">join_transform</span><span class=\"p\">)(</span><span class=\"n\">new_df1</span><span class=\"p\">,</span> <span class=\"n\">dfa</span><span class=\"p\">)</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/queryingB.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1f8a751a0a5b97cc103ea59a5ff23f62ceb07a73/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f7175657279696e67422e706e67\" width=\"10pt\">\n<p>But then we might want to make the DAG a little shorter, especially if we are to add more and more intermediate steps. We can control more detailed aesthetics with <tt>graph_attributes</tt>:</p>\n<pre><span class=\"n\">graph_attributes</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'graph_ranksep'</span><span class=\"p\">:</span> <span class=\"mf\">0.25</span><span class=\"p\">}</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">graph_attributes</span><span class=\"o\">=</span><span class=\"n\">graph_attributes</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/shortGraph.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3122ec35eab571bde34a36c0bee9c7da58c1fb44/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f73686f727447726170682e706e67\" width=\"10pt\">\n<p>You can take a look and play around with the rest of the configurations:</p>\n<pre><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">graph_attributes</span>\n\n<span class=\"c1\"># the default settings are found at:</span>\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">default_graph_attributes</span>\n\n<span class=\"c1\"># 'data_node_fontsize': 10,</span>\n<span class=\"c1\"># 'data_node_shape': 'box',</span>\n<span class=\"c1\"># 'data_node_color': None,</span>\n<span class=\"c1\"># 'op_node_fontsize': 12,</span>\n<span class=\"c1\"># 'op_node_shape': 'box',</span>\n<span class=\"c1\"># 'op_node_color': 'white',</span>\n<span class=\"c1\"># 'graph_ranksep': 0.475,</span>\n<span class=\"c1\"># 'graph_node_fontsize': 12.85,</span>\n<span class=\"c1\"># 'graph_node_shape': 'box3d',</span>\n<span class=\"c1\"># 'graph_node_color': 'white',</span>\n<span class=\"c1\"># 'graph_node_shapesize': 0.574,</span>\n<span class=\"c1\"># 'persist_record_shape': True</span>\n</pre>\n<p>Finally, you can set the alias of the nodes by passing in <tt>method_alias</tt> and/or <tt>output_alias</tt> in the <tt>add</tt> method. The <tt>method_alias</tt> will set the alias of the operation node being added, and <tt>output_alias</tt> will set the alias of the child data node of that operation node.</p>\n<pre><span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">dfa</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">query_dataframe_A</span><span class=\"p\">,</span> <span class=\"n\">rank</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"s1\">'cylinder'</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"s1\">'lightblue'</span><span class=\"p\">,</span> <span class=\"n\">output_alias</span><span class=\"o\">=</span><span class=\"s1\">'df_A'</span><span class=\"p\">)()</span>\n<span class=\"n\">dfb</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">query_dataframe_B</span><span class=\"p\">,</span> <span class=\"n\">rank</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"s1\">'cylinder'</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"s1\">'lightblue'</span><span class=\"p\">,</span> <span class=\"n\">output_alias</span><span class=\"o\">=</span><span class=\"s1\">'df_B'</span><span class=\"p\">)()</span>\n<span class=\"n\">dfa1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">product_transform</span><span class=\"p\">)(</span><span class=\"n\">dfa</span><span class=\"p\">)</span>\n<span class=\"n\">dfb1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">product_transform</span><span class=\"p\">)(</span><span class=\"n\">dfb</span><span class=\"p\">)</span>\n<span class=\"c1\"># note the list of alias for n_out = 2</span>\n<span class=\"n\">dfa</span><span class=\"p\">,</span> <span class=\"n\">dfb</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">split_transform</span><span class=\"p\">,</span> <span class=\"n\">n_out</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">output_alias</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'first_out'</span><span class=\"p\">,</span> <span class=\"s1\">'second_out'</span><span class=\"p\">])(</span><span class=\"n\">dfa1</span><span class=\"p\">)</span>\n<span class=\"n\">joined_df</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">join_transform</span><span class=\"p\">,</span> <span class=\"n\">output_alias</span><span class=\"o\">=</span><span class=\"s1\">'final_data'</span><span class=\"p\">)(</span><span class=\"n\">dfb1</span><span class=\"p\">,</span> <span class=\"n\">dfa</span><span class=\"p\">)</span>\n\n<span class=\"n\">graph_attributes</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'graph_ranksep'</span><span class=\"p\">:</span> <span class=\"mf\">0.25</span><span class=\"p\">}</span>\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">graph_attributes</span><span class=\"o\">=</span><span class=\"n\">graph_attributes</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/aliasingGraph.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/adbd70aca0490b37a6d8a19706f4e4ce3edd35ba/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f616c696173696e6747726170682e706e67\" width=\"10pt\">\n<p>The default alias for operation node is the String name of the method being passed in, and the default alias for data node is simply \u201cdata\u201d. We do not include the example of setting <tt>method_alias</tt> to discourage its use. Setting method alias different from the method name will make look up of graph node in the code base very difficult.</p>\n</div>\n<div id=\"no-output-methods\">\n<h2>No output methods</h2>\n<p>Often when we are processing data, we will end up doing something with that data, whether it is to upload it somewhere, save it somewhere, or use pass it to a model, etc. In those cases, we do not expect any return data.</p>\n<pre><span class=\"c1\"># this method does not have return statement</span>\n<span class=\"k\">def</span> <span class=\"nf\">save_data</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">):</span>\n\n        <span class=\"c1\"># save the data somewhere</span>\n        <span class=\"c1\"># no return statement needed</span>\n        <span class=\"k\">pass</span>\n</pre>\n<p>Pyflow will create graph accordingly, such that the outputless operation node is a leaf node.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">query_dataframe_A</span><span class=\"p\">():</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span>  <span class=\"c1\"># pretend this was a pandas or Spark dataframe!</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">query_dataframe_B</span><span class=\"p\">():</span>\n        <span class=\"k\">return</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">product_transform</span><span class=\"p\">(</span><span class=\"n\">inp</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">inp</span><span class=\"o\">*</span><span class=\"mi\">2</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">join_transform</span><span class=\"p\">(</span><span class=\"n\">inp1</span><span class=\"p\">,</span> <span class=\"n\">inp2</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">inp1</span> <span class=\"o\">+</span> <span class=\"n\">inp2</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">split_transform</span><span class=\"p\">(</span><span class=\"n\">inp</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">inp</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">inp</span><span class=\"o\">+</span><span class=\"mi\">2</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">save_data</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"c1\"># save the data somewhere</span>\n        <span class=\"c1\"># no return statement needed</span>\n        <span class=\"k\">pass</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">df1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">query_dataframe_A</span><span class=\"p\">,</span> <span class=\"n\">rank</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"s1\">'cylinder'</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"s1\">'lightblue'</span><span class=\"p\">)()</span>\n<span class=\"n\">df2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">query_dataframe_B</span><span class=\"p\">,</span> <span class=\"n\">rank</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"s1\">'cylinder'</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"s1\">'lightblue'</span><span class=\"p\">)()</span>\n<span class=\"n\">new_df1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">product_transform</span><span class=\"p\">)(</span><span class=\"n\">df1</span><span class=\"p\">)</span>\n<span class=\"n\">new_df2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">product_transform</span><span class=\"p\">)(</span><span class=\"n\">df2</span><span class=\"p\">)</span>\n<span class=\"n\">dfa</span><span class=\"p\">,</span> <span class=\"n\">dfb</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">split_transform</span><span class=\"p\">,</span> <span class=\"n\">n_out</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"n\">new_df2</span><span class=\"p\">)</span>\n<span class=\"n\">joined_df</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">join_transform</span><span class=\"p\">)(</span><span class=\"n\">new_df1</span><span class=\"p\">,</span> <span class=\"n\">dfa</span><span class=\"p\">)</span>\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">save_data</span><span class=\"p\">)(</span><span class=\"n\">dfb</span><span class=\"p\">)</span>\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">save_data</span><span class=\"p\">)(</span><span class=\"n\">joined_df</span><span class=\"p\">)</span>\n\n<span class=\"n\">graph_attributes</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'graph_ranksep'</span><span class=\"p\">:</span> <span class=\"mf\">0.25</span><span class=\"p\">}</span>\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">graph_attributes</span><span class=\"o\">=</span><span class=\"n\">graph_attributes</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/no_output_.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/291f75dbb6620ec185a0689c1310b7f2e442db38/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f6e6f5f6f75747075745f2e706e67\" width=\"10pt\">\n<p>This is a more realistic shape of the DAG in the actual use case of data preprocessing. Also, this is why <tt>run</tt> method makes more sense to use then <tt>get</tt> method in most realistic use cases. As you can see above, there is no data node from which we can call <tt>get</tt> method to retrieve the data. We are not interested in the data per se as we are in what we can do with the data. And most of the time, when we do something with our data, the end result is not another data. This does not mean you shouldn\u2019t use <tt>get</tt>. There might be situations where you would want to get the data back, especially during interactive sessions.</p>\n</div>\n<div id=\"grafting-graphs-together\">\n<h2>Grafting graphs together</h2>\n<p>When the computation graph becomes too big, the size of the visualized graph can actually end up becoming a hinderance to clean data flow documentation. Not only that, we could also benefit at the conceptual code organization level, if we had the ability to define multiple graphs and combine them together flexibly. I.e. we could treat a graph as if it was just another operation node. As of version <tt>0.7</tt>, we can do this. Let\u2019s look at an example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">adding</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">(</span><span class=\"n\">alias</span><span class=\"o\">=</span><span class=\"s1\">'First Graph'</span><span class=\"p\">)</span>  <span class=\"c1\"># notice alias at graph level!</span>\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">,</span> <span class=\"n\">output_alias</span><span class=\"o\">=</span><span class=\"s1\">'leaving!'</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">)</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/graft1.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/98879ac2be2f5b037d5b932dcf6a62331f493207/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f6772616674312e706e67\" width=\"10pt\">\n<p>Let\u2019s look at the unsummarized version to take notice of the output_alias of the last data node:</p>\n<pre><span class=\"c1\"># let's make it a little shorter with ranksep parameter we talked about earlier!</span>\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">graph_attributes</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'graph_ranksep'</span><span class=\"p\">:</span> <span class=\"mf\">0.3</span><span class=\"p\">})</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/graft2.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/40ca4f70c7bf9a02e653ef7bd53dc2960524603d/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f6772616674322e706e67\" width=\"10pt\">\n<p>In the above code, we have created one graph. But we can create another graph, and graft the <tt>First Graph</tt> graph to the new graph:</p>\n<pre><span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">(</span><span class=\"n\">alias</span><span class=\"o\">=</span><span class=\"s1\">'Second Graph'</span><span class=\"p\">)</span>\n\n<span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">b2</span> <span class=\"o\">=</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">b1</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span>\n<span class=\"n\">b3</span> <span class=\"o\">=</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">b1</span><span class=\"p\">,</span> <span class=\"n\">b2</span><span class=\"p\">)</span>\n\n<span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>  <span class=\"c1\"># notice that the output_alias from previous graph is also preserved!</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/graft3_.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ca7c918824b1207132b9583817cd5460cb39b211/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f6772616674335f2e706e67\" width=\"10pt\">\n<p>As you can see, the previous graph is now summarized into a box. You can combine as many graphs in this way as you want. Despite this visual effect, <tt>b3</tt> is now part of one single big combined computation graph. Therefore, calling <tt>b3.get()</tt> will trigger computations in nodes that belong to both <tt>G</tt> and <tt>H</tt> as long as they are needed. As far as computation is concerned, you just have one big graph.</p>\n</div>\n<div id=\"saving-your-dag-image\">\n<h2>Saving your DAG image</h2>\n<p>You can easily save your DAG image by invoking <tt>save_view</tt> method, which returns the file path of the saved image:</p>\n<pre><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">save_view</span><span class=\"p\">()</span>\n</pre>\n<p>The <tt>save_view</tt> method also has <tt>summary</tt> boolean parameter. You can also set the file name and file path by passing in <tt>dirpath</tt> and <tt>filename</tt> parameter. They default to current working directory and \u201cdigraph\u201d respectively. You can also set the file format as png or pdf by setting <tt>fileformat</tt> parameter. The default is png.</p>\n</div>\n<div id=\"computation-and-memory-efficiency-of-pyflow\">\n<h2>Computation and memory efficiency of Pyflow</h2>\n<p>When you invoke <tt>get</tt> method, pyflow will only then evaluate, and it will evaluate only the parts of the graph that is needed to be evaluated. Also, as soon as an intermediate result has no dependency, it will automatically release the memory back to the operating system. Let\u2019s take a tour of the computation process to better understand this mechanism by turning on <tt>verbose</tt> parameter.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">adding</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">multi_output_method</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">a</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">(</span><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># set verbose to True</span>\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">return2</span><span class=\"p\">,</span> <span class=\"n\">n_out</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">a4</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"n\">a5</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a4</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span>\n\n<span class=\"n\">a5</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n</pre>\n<p>With <tt>verbose=True</tt>, along with the final output, pyflow will also produce the following standard output:</p>\n<pre>computing for data_12\nadding_11 activated!\nadding_8 activated!\nadding_0 activated!\nreturn2_4 activated!\ncomputing for data_10\ncomputing for data_3\nrunning adding_0\nadding_0 deactivated!\nrunning adding_8\ndata_3 still needed at return2_4\nadding_8 deactivated!\ncomputing for data_7\nrunning return2_4\ndata_3 released!\nreturn2_4 deactivated!\nrunning adding_11\ndata_10 released!\ndata_7 released!\nadding_11 deactivated!\n</pre>\n<p>Let\u2019s take the tour of this process by looking at the graph. Notice that in verbose mode, the graph will actually print out the uid\u2019s of the nodes not just their aliases (more on setting alias later!)</p>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/verbose_.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7cc5454179d244de54e5693e902d1ffdeb212096/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f766572626f73655f2e706e67\" width=\"10pt\">\n<p>As pyflow tries to compute <tt>data_12</tt>, it will first activate all the <tt>OperationNodes</tt> that is needed for the computation, in our case, those are <tt>adding_11</tt>, <tt>adding_8</tt>, <tt>adding_0</tt>, <tt>return2_4</tt>. It will then follow the lineage of the graph to work on intermediate results needed to proceed down the graph. Notice that as the computation proceeds, the <tt>OperationNodes</tt> that were activated are deactivated. When it gets to <tt>data_3</tt>, notice that it is needed at both <tt>adding_8</tt> and <tt>return2_4</tt>. Thus, once it completes <tt>adding_8</tt>, it cannot yet release the memory from <tt>data_3</tt>: <tt>data_3 still needed at return2_4</tt>. But as soon as <tt>return2_4</tt> is ran, it releases <tt>data_3</tt> from memory, as it is not needed anymore: <tt>data_3 released!</tt>. The <tt>DataNodes</tt> with raw inputs such as integers are not released since there is no way for the graph to reconstruct them.</p>\n<p>By the same token, if you were to run the graph from middle, say, at <tt>a4</tt>:</p>\n<pre><span class=\"n\">a4</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n</pre>\n<p>You will see:</p>\n<pre>computing for data_10\nadding_8 activated!\nadding_0 activated!\ncomputing for data_3\nrunning adding_0\nadding_0 deactivated!\nrunning adding_8\ndata_3 released!\nadding_8 deactivated!\n</pre>\n<p>In this case, since <tt>return2_4</tt> is not activated, the <tt>data_3</tt> does not consider its presence in deciding release of memory.</p>\n<p>On the other hand, <tt>run</tt> method will activate <em>all</em> operation nodes. This will make sure that even the operation nodes that do not have children are ran. However, the immediate memory release mechanism still applies to <tt>run</tt> method, unless otherwise specified. Refer below.</p>\n</div>\n<div id=\"memory-persistance-with-pyflow\">\n<h2>Memory persistance with Pyflow</h2>\n<p>Lastly, you have the option of either persisting all of the intermediate results, or persisting part of the intermediate results.</p>\n<p>To persist all intermediate results, use <tt>persist</tt> parameter at <tt>GraphBuilder</tt> level:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">(</span><span class=\"n\">persist</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># set persist to True</span>\n\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">return2</span><span class=\"p\">,</span> <span class=\"n\">n_out</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">a4</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"n\">a5</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a4</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span>\n\n<span class=\"n\">a5</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n</pre>\n<p>With persist enabled, after running <tt>a5.get()</tt>, when you try to run <tt>a4.get()</tt>, the graph will not recompute anything because <tt>a4</tt> node result will have been cached in memory. The persist is turned off by default, as it is assumed that the user of the pyflow will process large amounts of data.</p>\n<p>To persist parts of the data, you can specify the <tt>persist</tt> parameter at <tt>add</tt> level:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">(</span><span class=\"n\">persist</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>  <span class=\"c1\"># default value</span>\n\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">return2</span><span class=\"p\">,</span> <span class=\"n\">n_out</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">a4</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">,</span> <span class=\"n\">persist</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>  <span class=\"c1\"># persist here</span>\n<span class=\"n\">a5</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a4</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span>\n\n<span class=\"n\">a5</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n</pre>\n<p>Then, when you run <tt>a4.get()</tt> it will not rerun the computation as <tt>a4</tt> result has been cached in memory although all other intermediate results will have been released.</p>\n<p>At last, we can understand the difference between <tt>run()</tt> and <tt>run(a1, a3)</tt>. Even if you don\u2019t persist anything, either at the graph level or the node level, by passing in the <tt>a1, a3</tt>, the graph will automatically persist their data for you, and return the persisted data by internally invoking <tt>get()</tt> on the nodes <tt>a1, a3</tt>. The rest of data nodes are subject to the same immediate memory release mechanism.</p>\n<p>In terms of the codes, these two are equivalent:</p>\n<pre><span class=\"c1\"># run() with arguments:</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">)</span>\n\n<span class=\"n\">a1_val</span><span class=\"p\">,</span> <span class=\"n\">a3_val</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># run() without arguments:</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">,</span> <span class=\"n\">persist</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">)</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n\n<span class=\"n\">a1_val</span> <span class=\"o\">=</span> <span class=\"n\">a1</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n<span class=\"n\">a3_val</span> <span class=\"o\">=</span> <span class=\"n\">a3</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n</pre>\n<p>Also, when you persist certain nodes, this persistence request will manifest in the graph by an empty record box:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyflow</span> <span class=\"kn\">import</span> <span class=\"n\">GraphBuilder</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">GraphBuilder</span><span class=\"p\">()</span>\n<span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">adding</span><span class=\"p\">)(</span><span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">)</span>\n\n<span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/record1.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/859b513a86a392f0f2bb0d44a526b0cba58dccea/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f7265636f7264312e706e67\" width=\"10pt\">\n<p>The empty box signifies that the graph is requested to persist that data, but it does not yet hold that data because it has not yet been executed. But once you run the graph, the empty record slot will be filled by the dimensionality of the resulting data. Currently it supports PySpark dataframe, numpy array, and pandas dataframe. All other data will have a default dimension of <tt>(1, )</tt>.</p>\n<pre><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/record2.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/48e5082a4f862bec522d16afa8ffbc14d6fb029f/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f7265636f7264322e706e67\" width=\"10pt\">\n<p>Now, of course, it is not the method that is being persisted but the resulting data of that op node. You can see this when you visualize the DAG with <tt>summary=False</tt>:</p>\n<pre><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">summary</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<img alt=\"https://github.com/mozjay0619/pyflow-viz/blob/master/media/record3.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f34a33da7d80b083eb3177ddaf9850f1ff9328df/68747470733a2f2f6769746875622e636f6d2f6d6f7a6a6179303631392f7079666c6f772d76697a2f626c6f622f6d61737465722f6d656469612f7265636f7264332e706e67\" width=\"10pt\">\n<p>Some notes:</p>\n<ol>\n<li>The op node with record box is a short hand way of conveying the message that the child data node of that op node will be persisted.</li>\n<li>The raw data are automatically persisted, which is why you see the dimensionality information in the record box. This is because the raw user data inputs cannot be recomputed from the graph alone. But this will not be visible when <tt>summary=True</tt>, because the op node will only show the record box for persisted child data node, and user supplied inputs will always be parent data node.</li>\n<li>Although this is not made explicitly visible, the final leaf data node are always persisted when <tt>run</tt> method is invoked. But this will not be explicitly shown in the graph unless the user manually supplies <tt>persist</tt> flag at the <tt>add</tt> method invocation.</li>\n<li>Lastly, the <tt>persist</tt> flag is interoperable with Spark when PySpark dataframe is the data type. This means, when you persist the data using the DAG, if the underlying data is a PySpark dataframe, the Pyflow will persist the dataframe for you. However, unpersisting is not done by the Pyflow. If you want to unpersist a dataframe, do so manually.</li>\n</ol>\n</div>\n\n          </div>"}, "last_serial": 7117408, "releases": {"0.0b0": [{"comment_text": "", "digests": {"md5": "00aa61b5f0ee4cd94245c74285949abb", "sha256": "ab35a5a97b9f95ede983de3f14a5eecc34d15b9755405233b6dbd91a3fac440e"}, "downloads": -1, "filename": "pyflow_viz-0.0b0-py3-none-any.whl", "has_sig": false, "md5_digest": "00aa61b5f0ee4cd94245c74285949abb", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11847, "upload_time": "2020-03-22T23:32:25", "upload_time_iso_8601": "2020-03-22T23:32:25.505961Z", "url": "https://files.pythonhosted.org/packages/de/36/d16f1c269bdaa0e2416d5ba8e4d066fd0f578be1b156a6abe6cca4cad350/pyflow_viz-0.0b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3af2e8c829f19b8d4e1a115dc8bf57ca", "sha256": "56a4e68692a62f91e6192d01001b7e1f9ceb9b2af8a0029914af77c395c96b53"}, "downloads": -1, "filename": "pyflow-viz-0.0b0.tar.gz", "has_sig": false, "md5_digest": "3af2e8c829f19b8d4e1a115dc8bf57ca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11840, "upload_time": "2020-03-22T23:32:28", "upload_time_iso_8601": "2020-03-22T23:32:28.794408Z", "url": "https://files.pythonhosted.org/packages/89/47/800cce578087ad49759824d182a465911a5ffb1d7d38e4bfab42bfb9e700/pyflow-viz-0.0b0.tar.gz", "yanked": false}], "0.1": [{"comment_text": "", "digests": {"md5": "bbaedb606c9613368f47d7059349509a", "sha256": "3c56fa44a984b0f6ace9128e76c42919ebefb57cdc051e0b9849129a1a654d36"}, "downloads": -1, "filename": "pyflow_viz-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "bbaedb606c9613368f47d7059349509a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11761, "upload_time": "2020-03-23T17:38:13", "upload_time_iso_8601": "2020-03-23T17:38:13.581097Z", "url": "https://files.pythonhosted.org/packages/ac/55/b1c7e86b9c54ee035c49bc0106edb1f0ec5e8aea6bce83225d3db3e7f85d/pyflow_viz-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "440b258841454580c014ed10ae458370", "sha256": "973b11734040fdd9dd453586ec55d5c782c643f3367e77b722a60a01e31236c2"}, "downloads": -1, "filename": "pyflow-viz-0.1.tar.gz", "has_sig": false, "md5_digest": "440b258841454580c014ed10ae458370", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12188, "upload_time": "2020-03-23T17:38:14", "upload_time_iso_8601": "2020-03-23T17:38:14.684555Z", "url": "https://files.pythonhosted.org/packages/60/4f/a620701055bfabe97cf0da479a5037c1676e6f59cadc63911b543c0b16b4/pyflow-viz-0.1.tar.gz", "yanked": false}], "0.10": [{"comment_text": "", "digests": {"md5": "265db8d81f507a8a60b7d6b3a92c718e", "sha256": "89a2907510b3cfb08045a218a9dc70b68eef46789b05fed33e1e7eda53b89791"}, "downloads": -1, "filename": "pyflow_viz-0.10-py3-none-any.whl", "has_sig": false, "md5_digest": "265db8d81f507a8a60b7d6b3a92c718e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 19167, "upload_time": "2020-04-27T02:41:13", "upload_time_iso_8601": "2020-04-27T02:41:13.457991Z", "url": "https://files.pythonhosted.org/packages/39/6f/484310520e50972894e9cbca4505c8a36c0bff7d3eea3e7679d7f08ddfb8/pyflow_viz-0.10-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "12a51c6ee41a6a498375bc8818938047", "sha256": "e46fbab80d8c1ffc3e7034466a4307d61a51bc30c9f56672291f83b23ff5ca44"}, "downloads": -1, "filename": "pyflow-viz-0.10.tar.gz", "has_sig": false, "md5_digest": "12a51c6ee41a6a498375bc8818938047", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16613, "upload_time": "2020-04-27T02:41:14", "upload_time_iso_8601": "2020-04-27T02:41:14.938100Z", "url": "https://files.pythonhosted.org/packages/f8/35/d8fbabaa7d862b8672be34742b7ba591088a5ddb82e59854445cef10aec6/pyflow-viz-0.10.tar.gz", "yanked": false}], "0.11": [{"comment_text": "", "digests": {"md5": "2183a784f397d77b5f468c9fbfdcb3f8", "sha256": "fe6130ca8c95204027bab8137a605187d31cbb10a8270ef48c551167bb3c91c7"}, "downloads": -1, "filename": "pyflow_viz-0.11-py3-none-any.whl", "has_sig": false, "md5_digest": "2183a784f397d77b5f468c9fbfdcb3f8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 19160, "upload_time": "2020-04-27T03:00:38", "upload_time_iso_8601": "2020-04-27T03:00:38.219933Z", "url": "https://files.pythonhosted.org/packages/3c/37/97ca631a24cecd4997a5a591ef45fd9cb937b0ed62001099b60764a81d8e/pyflow_viz-0.11-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2ae7c6c1b71b12e999a9bcfc80a829ba", "sha256": "bb0d3291710420455a3c72f4768b86bff8a60cec4bdeedf60a324382be668268"}, "downloads": -1, "filename": "pyflow-viz-0.11.tar.gz", "has_sig": false, "md5_digest": "2ae7c6c1b71b12e999a9bcfc80a829ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22608, "upload_time": "2020-04-27T03:00:39", "upload_time_iso_8601": "2020-04-27T03:00:39.786010Z", "url": "https://files.pythonhosted.org/packages/59/a1/9fb9c619a5924c80d6b4fc2a75875b57bf6296780aff1306154f43714da8/pyflow-viz-0.11.tar.gz", "yanked": false}], "0.12": [{"comment_text": "", "digests": {"md5": "751d5f7bc543dbac8ea597d102217e84", "sha256": "8cc1ba1049cdcaa5c11cd9a47a9b1fb52b2a76e0911c5e59f3de4d253a79f775"}, "downloads": -1, "filename": "pyflow_viz-0.12-py3-none-any.whl", "has_sig": false, "md5_digest": "751d5f7bc543dbac8ea597d102217e84", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 20389, "upload_time": "2020-04-28T05:48:43", "upload_time_iso_8601": "2020-04-28T05:48:43.564237Z", "url": "https://files.pythonhosted.org/packages/3e/37/bd3405e559bc8b978e945e9e3befa8091caddd264c8e4401460fd4f384e1/pyflow_viz-0.12-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bad2e8d94041d57d2c071cea439b7549", "sha256": "3a517a4b6446d395fa539df7ef2f8a9fe0d7c4b2c6fa7680c1060df2bac9eec4"}, "downloads": -1, "filename": "pyflow-viz-0.12.tar.gz", "has_sig": false, "md5_digest": "bad2e8d94041d57d2c071cea439b7549", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24691, "upload_time": "2020-04-28T05:48:45", "upload_time_iso_8601": "2020-04-28T05:48:45.007448Z", "url": "https://files.pythonhosted.org/packages/3c/a4/29409ed58bfc77b4df2b43385c1b282d1c27b16546fc8fc0c38668ce8257/pyflow-viz-0.12.tar.gz", "yanked": false}], "0.12b0": [{"comment_text": "", "digests": {"md5": "630d8fd85b2bd306915dde3d1f206cf7", "sha256": "470a76005ce0503fb213310cf0b4f9019ee371786423634f1f2bff1f1bf646fe"}, "downloads": -1, "filename": "pyflow_viz-0.12b0-py3-none-any.whl", "has_sig": false, "md5_digest": "630d8fd85b2bd306915dde3d1f206cf7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 19216, "upload_time": "2020-04-27T03:38:45", "upload_time_iso_8601": "2020-04-27T03:38:45.756686Z", "url": "https://files.pythonhosted.org/packages/86/65/7870906f4caef5dd16b26ae08e0d9d2507565317a57a94d97f60703d5fee/pyflow_viz-0.12b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0b128026ab157c2b4fffe5984efb225f", "sha256": "7fd7fb46a06eb56ee7f0ae99449ba1fa7bbc9fe7235d5d3c566da9176913c55d"}, "downloads": -1, "filename": "pyflow-viz-0.12b0.tar.gz", "has_sig": false, "md5_digest": "0b128026ab157c2b4fffe5984efb225f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22646, "upload_time": "2020-04-27T03:38:47", "upload_time_iso_8601": "2020-04-27T03:38:47.152115Z", "url": "https://files.pythonhosted.org/packages/2e/58/d48cd4b6add4a4ad73a942487d61fcc1cf1d208d1a68026dc5f36bcc4763/pyflow-viz-0.12b0.tar.gz", "yanked": false}], "0.12b1": [{"comment_text": "", "digests": {"md5": "21fdfc8eca55a4691335ec257e00c0c3", "sha256": "624a6b784e7dfe0f8dfd442ee8956a212bec191d711896fbe0a91ab769e72ed9"}, "downloads": -1, "filename": "pyflow_viz-0.12b1-py3-none-any.whl", "has_sig": false, "md5_digest": "21fdfc8eca55a4691335ec257e00c0c3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 19211, "upload_time": "2020-04-27T04:43:48", "upload_time_iso_8601": "2020-04-27T04:43:48.152514Z", "url": "https://files.pythonhosted.org/packages/ef/53/a6ba47f9bae88963c5acf54236a84f07455b43a1df6a10f6b439d547b8bd/pyflow_viz-0.12b1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4a435953bd35b19057aac56826080d92", "sha256": "d8607f5c40c5b1605a1cbd3eb6039e8842e2b2368d4455142e071cf83c4dacf8"}, "downloads": -1, "filename": "pyflow-viz-0.12b1.tar.gz", "has_sig": false, "md5_digest": "4a435953bd35b19057aac56826080d92", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22639, "upload_time": "2020-04-27T04:43:49", "upload_time_iso_8601": "2020-04-27T04:43:49.901816Z", "url": "https://files.pythonhosted.org/packages/56/71/40f4167d4014c64ebdffe3d97169fc0fba37f9f5f586b6079ef59f855f6a/pyflow-viz-0.12b1.tar.gz", "yanked": false}], "0.12b2": [{"comment_text": "", "digests": {"md5": "adf0de667536fc1e129377fe41b1fa6e", "sha256": "10cf28e7d277d8994626f0f7981692ec73f6ea2050756940ca17e3d30ccdab3b"}, "downloads": -1, "filename": "pyflow_viz-0.12b2-py3-none-any.whl", "has_sig": false, "md5_digest": "adf0de667536fc1e129377fe41b1fa6e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 19213, "upload_time": "2020-04-27T04:53:50", "upload_time_iso_8601": "2020-04-27T04:53:50.819654Z", "url": "https://files.pythonhosted.org/packages/08/94/00ffe07ed126e01ad2b7b98490da9d7c86b5da8ae4d9717ff62a4c1cb460/pyflow_viz-0.12b2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "43ce9c58bcf4d94e18c272bfdfb66130", "sha256": "4c6f3a0649da2d6312954abb8a68b566f16d2175c04bf5dbf8574797805571fb"}, "downloads": -1, "filename": "pyflow-viz-0.12b2.tar.gz", "has_sig": false, "md5_digest": "43ce9c58bcf4d94e18c272bfdfb66130", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16640, "upload_time": "2020-04-27T04:53:52", "upload_time_iso_8601": "2020-04-27T04:53:52.190513Z", "url": "https://files.pythonhosted.org/packages/fa/8e/cc93c1f378b19ec102c4ced4f81af1de520a7bb67867dbdaeeaec43ececf/pyflow-viz-0.12b2.tar.gz", "yanked": false}], "0.12b3": [{"comment_text": "", "digests": {"md5": "c42eb6bf4c855c76d1dd97ab8ec802b0", "sha256": "3a79103116b1a786025908a164ba6e9f1f3cc58dad0e862c4e65dbb82ae8fc92"}, "downloads": -1, "filename": "pyflow_viz-0.12b3-py3-none-any.whl", "has_sig": false, "md5_digest": "c42eb6bf4c855c76d1dd97ab8ec802b0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 19270, "upload_time": "2020-04-27T05:47:27", "upload_time_iso_8601": "2020-04-27T05:47:27.906549Z", "url": "https://files.pythonhosted.org/packages/7d/c1/54ec3d977cd7460c25ec57f29c1e1370fe54bc7302dee45c4e900bb86fe6/pyflow_viz-0.12b3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "56fa3c1256c7cc1bf63adc7e7e85b013", "sha256": "589f0ebd71601300fa524663fd4c58b18d79a4ae1a50dea83d81d9f0504bdd87"}, "downloads": -1, "filename": "pyflow-viz-0.12b3.tar.gz", "has_sig": false, "md5_digest": "56fa3c1256c7cc1bf63adc7e7e85b013", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22682, "upload_time": "2020-04-27T05:47:29", "upload_time_iso_8601": "2020-04-27T05:47:29.161253Z", "url": "https://files.pythonhosted.org/packages/e6/c1/2cffdd0630f3d301468883a7198ebd48d040b6b8786e8c7b39edf7b7b32a/pyflow-viz-0.12b3.tar.gz", "yanked": false}], "0.1b1": [{"comment_text": "", "digests": {"md5": "7ada190918e547ad71004b672912ae68", "sha256": "79cb49d9cdd9d8285fc490b98c921ed1fad25c30397b8f71321283b34cef8003"}, "downloads": -1, "filename": "pyflow_viz-0.1b1-py3-none-any.whl", "has_sig": false, "md5_digest": "7ada190918e547ad71004b672912ae68", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11784, "upload_time": "2020-03-23T00:58:46", "upload_time_iso_8601": "2020-03-23T00:58:46.028133Z", "url": "https://files.pythonhosted.org/packages/bd/11/b32876adc538a1a230e0bb9eff0a9969487d90b4eed6601daae115dbad0e/pyflow_viz-0.1b1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "37e1c05024209a23b76cda6e580e3565", "sha256": "e39ed7243bd058a7218733d656ee040c34f8cf5249932c09249b76f9e421d35c"}, "downloads": -1, "filename": "pyflow-viz-0.1b1.tar.gz", "has_sig": false, "md5_digest": "37e1c05024209a23b76cda6e580e3565", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8976, "upload_time": "2020-03-23T00:58:47", "upload_time_iso_8601": "2020-03-23T00:58:47.378769Z", "url": "https://files.pythonhosted.org/packages/a1/6a/33a36ff641a11114ade979fb92623ecf0cca9b6dd1ca19f9c57ef4047ca5/pyflow-viz-0.1b1.tar.gz", "yanked": false}], "0.1b2": [{"comment_text": "", "digests": {"md5": "bf9336894abc6f17fc1f2a89986a17e9", "sha256": "0fd9d80c57ce048dd64789924f024dc44824e7951fd6acea2705c5a3f6c0a8c2"}, "downloads": -1, "filename": "pyflow_viz-0.1b2-py3-none-any.whl", "has_sig": false, "md5_digest": "bf9336894abc6f17fc1f2a89986a17e9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11785, "upload_time": "2020-03-23T01:16:45", "upload_time_iso_8601": "2020-03-23T01:16:45.210028Z", "url": "https://files.pythonhosted.org/packages/4e/83/42f21ecc84f240296fc9eed6cbf2e17e075299c4aaf0e43ad5fccd637bf9/pyflow_viz-0.1b2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "210364ebcb3e77b549a8854608338806", "sha256": "9f80c07f9327bd141a98cf85431f3c614653d8d2d05f1786b32f4472d407acad"}, "downloads": -1, "filename": "pyflow-viz-0.1b2.tar.gz", "has_sig": false, "md5_digest": "210364ebcb3e77b549a8854608338806", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8946, "upload_time": "2020-03-23T01:16:46", "upload_time_iso_8601": "2020-03-23T01:16:46.557565Z", "url": "https://files.pythonhosted.org/packages/d0/62/6b7239aae6e176ab643e0c874658402feb80bcc100830e7229f0c7ce4cdf/pyflow-viz-0.1b2.tar.gz", "yanked": false}], "0.1b3": [{"comment_text": "", "digests": {"md5": "b9a1ebffde854454d448c12e4adbb4ca", "sha256": "02ec3be97a1f7da572caf58e56ed98b7d9a80d30d9587705572deb4ea04d5b96"}, "downloads": -1, "filename": "pyflow_viz-0.1b3-py3-none-any.whl", "has_sig": false, "md5_digest": "b9a1ebffde854454d448c12e4adbb4ca", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11784, "upload_time": "2020-03-23T17:20:43", "upload_time_iso_8601": "2020-03-23T17:20:43.025743Z", "url": "https://files.pythonhosted.org/packages/06/91/1c3aa6cf119e0032d586b3674603cb37698805db75ec2b0e013c06a9aacc/pyflow_viz-0.1b3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a28841ba35257cd1c3d81a30aa91c9f1", "sha256": "4ae58192fd1d179a982810b282f25536a3b3fbdeed4c1d16cdaa773eee5972b7"}, "downloads": -1, "filename": "pyflow-viz-0.1b3.tar.gz", "has_sig": false, "md5_digest": "a28841ba35257cd1c3d81a30aa91c9f1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12192, "upload_time": "2020-03-23T17:20:44", "upload_time_iso_8601": "2020-03-23T17:20:44.277811Z", "url": "https://files.pythonhosted.org/packages/f8/58/51a657837da16756422de28ec1cbf881a1ca9091fb1c39234e304d8769f0/pyflow-viz-0.1b3.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "226997b7ac91ba4a9686684607ebc634", "sha256": "4af77e181dc4970652837f85410ca0d49d0bde322f634dbaaf466fedbc69e5fc"}, "downloads": -1, "filename": "pyflow_viz-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "226997b7ac91ba4a9686684607ebc634", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12348, "upload_time": "2020-03-25T20:50:09", "upload_time_iso_8601": "2020-03-25T20:50:09.021431Z", "url": "https://files.pythonhosted.org/packages/56/f2/abf3a27156ff7d4f0f711b8eb84fe0c30d58ace8c0741374b201ec046def/pyflow_viz-0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c01dd4ad6ddbc7b005e7a52c15d5430d", "sha256": "96aa358f8fd39d9adfa00bf3f2973848fd3e6bbf819420187f3ce107af6dd8a5"}, "downloads": -1, "filename": "pyflow-viz-0.2.tar.gz", "has_sig": false, "md5_digest": "c01dd4ad6ddbc7b005e7a52c15d5430d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12557, "upload_time": "2020-03-25T20:50:10", "upload_time_iso_8601": "2020-03-25T20:50:10.430780Z", "url": "https://files.pythonhosted.org/packages/cc/3c/58ecc4f42d6505a1aac753101d74c5641c2e039a27358be51dbf8153b31f/pyflow-viz-0.2.tar.gz", "yanked": false}], "0.2b0": [{"comment_text": "", "digests": {"md5": "160eabf8499590827f14f9f13989e383", "sha256": "f4ae50a1f046a2ffa90c8838e6ec65338ddde51829f55b67e1d665876e85b2a2"}, "downloads": -1, "filename": "pyflow_viz-0.2b0-py3-none-any.whl", "has_sig": false, "md5_digest": "160eabf8499590827f14f9f13989e383", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12380, "upload_time": "2020-03-25T20:17:04", "upload_time_iso_8601": "2020-03-25T20:17:04.274488Z", "url": "https://files.pythonhosted.org/packages/b0/66/21c7e35be819fd1caae4f7d5d5736ec2e3be0dabb17af81dbc80da2b35f0/pyflow_viz-0.2b0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "607742fc792c4871cc7b0134db6da1ec", "sha256": "70c2b18ff1942c8932592b48a39007efa00d6b269aae91f9dfb3f7503401f867"}, "downloads": -1, "filename": "pyflow-viz-0.2b0.tar.gz", "has_sig": false, "md5_digest": "607742fc792c4871cc7b0134db6da1ec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9504, "upload_time": "2020-03-25T20:17:05", "upload_time_iso_8601": "2020-03-25T20:17:05.441126Z", "url": "https://files.pythonhosted.org/packages/b3/b6/c70709bf60f86fe8d19cdc96e26e613202b24a2e02875e29c4f8fe323e2e/pyflow-viz-0.2b0.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "74d1ee80bcf3d856d1760b81a56360c2", "sha256": "d6a250f2d481be6a0c46eaece89d92ef3d30c834dbe0e984b0655c90c4a7966f"}, "downloads": -1, "filename": "pyflow_viz-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "74d1ee80bcf3d856d1760b81a56360c2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14128, "upload_time": "2020-03-29T23:30:11", "upload_time_iso_8601": "2020-03-29T23:30:11.634369Z", "url": "https://files.pythonhosted.org/packages/9d/dc/7aa6cbdd875a54ae83928daa863cb9bd5f3ee50d617d01366d269e97ae23/pyflow_viz-0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "961e871fb5e545920711ca1999551600", "sha256": "f59cbd08d39896bdc9ea17cd24c8d71a98a60b433147e22b78691ef4cde15b1d"}, "downloads": -1, "filename": "pyflow-viz-0.3.tar.gz", "has_sig": false, "md5_digest": "961e871fb5e545920711ca1999551600", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15435, "upload_time": "2020-03-29T23:30:13", "upload_time_iso_8601": "2020-03-29T23:30:13.056014Z", "url": "https://files.pythonhosted.org/packages/4e/b7/871ee964b723060809f34fc7832fced62798ba01e630ee7df995d000bf57/pyflow-viz-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "3d00439a3c4495485140ebe93c6774a0", "sha256": "02e0f0adb33b40c4a3a579ebac130ad8b5f90177a365f639542868286632ee92"}, "downloads": -1, "filename": "pyflow_viz-0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "3d00439a3c4495485140ebe93c6774a0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14476, "upload_time": "2020-03-30T05:22:20", "upload_time_iso_8601": "2020-03-30T05:22:20.656453Z", "url": "https://files.pythonhosted.org/packages/86/35/b475dfe0d18311f28d64cf1a161c0211b00e2dbf82aacface4e01d64798c/pyflow_viz-0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "172d532530d162000676c75447a1411b", "sha256": "ba157611893e02002e63140ade9a43b587a2b7ffc6b27018ac33264be0ec8dff"}, "downloads": -1, "filename": "pyflow-viz-0.4.tar.gz", "has_sig": false, "md5_digest": "172d532530d162000676c75447a1411b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16137, "upload_time": "2020-03-30T05:22:21", "upload_time_iso_8601": "2020-03-30T05:22:21.907311Z", "url": "https://files.pythonhosted.org/packages/e1/76/4313b131dc4d95933b28df0e9e6e64a6cfa7e5eaeed533be00816a5875b2/pyflow-viz-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "b88d30f4182bfd1c1ad5780cd158423a", "sha256": "3bb59112729fe88042cb03859b05d88196d8ba7eb59076587a76a222593e13f8"}, "downloads": -1, "filename": "pyflow_viz-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "b88d30f4182bfd1c1ad5780cd158423a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14792, "upload_time": "2020-04-02T21:19:55", "upload_time_iso_8601": "2020-04-02T21:19:55.695677Z", "url": "https://files.pythonhosted.org/packages/05/bb/4737c9ad58a0e97671dea0dad8c1ed6707b1e4e2785f845a5f9e7785b881/pyflow_viz-0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ae65acf77d977b80a759c96f53a25c02", "sha256": "d6704833cb2480c6f6ca9599abcef3dbf3856de0de382f5b52688756d12277f0"}, "downloads": -1, "filename": "pyflow-viz-0.5.tar.gz", "has_sig": false, "md5_digest": "ae65acf77d977b80a759c96f53a25c02", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16743, "upload_time": "2020-04-02T21:19:57", "upload_time_iso_8601": "2020-04-02T21:19:57.233285Z", "url": "https://files.pythonhosted.org/packages/c8/e6/616d3d16141615385a4ca86845ea8c2731f58adfc502abccbfa17f56f481/pyflow-viz-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "677ab3c1b28f634d5f5f6a862e1d8f4d", "sha256": "8f06650febc8ded373201ecb90294eea8c1c294b92a847bbb9f72fe92401ec80"}, "downloads": -1, "filename": "pyflow_viz-0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "677ab3c1b28f634d5f5f6a862e1d8f4d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16038, "upload_time": "2020-04-03T02:08:20", "upload_time_iso_8601": "2020-04-03T02:08:20.173425Z", "url": "https://files.pythonhosted.org/packages/f4/54/753a7cb6b2b973f09aab5096128b97a3390d164a6567474422bf7fc9186e/pyflow_viz-0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "94e40cf197da1dddec56add2616a8009", "sha256": "5e45a75bbbba83bea4a16c1a70c72b0a3206129790efb1f3f504284c3e133cd7"}, "downloads": -1, "filename": "pyflow-viz-0.6.tar.gz", "has_sig": false, "md5_digest": "94e40cf197da1dddec56add2616a8009", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18817, "upload_time": "2020-04-03T02:08:21", "upload_time_iso_8601": "2020-04-03T02:08:21.838072Z", "url": "https://files.pythonhosted.org/packages/e6/fa/836dd4c845343ec52b53ee24e1f4a5667285cade43db8fa4c532630e1472/pyflow-viz-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "2053d7a7a5dcc5e072febecb959959ee", "sha256": "e002108479d82cc760f6a616170868a729829a5ef72e60c3e9406df7190973d3"}, "downloads": -1, "filename": "pyflow_viz-0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "2053d7a7a5dcc5e072febecb959959ee", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17859, "upload_time": "2020-04-07T06:28:11", "upload_time_iso_8601": "2020-04-07T06:28:11.571056Z", "url": "https://files.pythonhosted.org/packages/cb/8f/df7ac10bc7242bb0d2fa4b28a8470a4492b582aabf492e3988c8b10d1e80/pyflow_viz-0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e7019e9cf9a6f64ce4853f129d135add", "sha256": "8f8b9cd79bf7b1e383472a17bdf3baaf39e4ba14f17ab64b1930fee24e7ba5e4"}, "downloads": -1, "filename": "pyflow-viz-0.7.tar.gz", "has_sig": false, "md5_digest": "e7019e9cf9a6f64ce4853f129d135add", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15400, "upload_time": "2020-04-07T06:28:13", "upload_time_iso_8601": "2020-04-07T06:28:13.306669Z", "url": "https://files.pythonhosted.org/packages/f7/41/eb1f47c0ffd123f5ca2fd4349a4e1271dde86a9051f0fb53155571e725fa/pyflow-viz-0.7.tar.gz", "yanked": false}], "0.8": [{"comment_text": "", "digests": {"md5": "76a307eb0c2f12d765c50dc5874e3f97", "sha256": "9015edf11c52466b835c7a7c4a2223452a3c2f34a6ae70d717f6ab25e484eb70"}, "downloads": -1, "filename": "pyflow_viz-0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "76a307eb0c2f12d765c50dc5874e3f97", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 18157, "upload_time": "2020-04-26T22:34:08", "upload_time_iso_8601": "2020-04-26T22:34:08.542563Z", "url": "https://files.pythonhosted.org/packages/0f/ec/8ae88f900fa510f4c2f39bf066c142e3e951ba26d7031b74dfffaae42719/pyflow_viz-0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "11adcc69c2ba0cb492ebf96e141ca852", "sha256": "2f745a2c85148c264282e6b09cfa79dae02ed250c837834553e9aeb50691cbcc"}, "downloads": -1, "filename": "pyflow-viz-0.8.tar.gz", "has_sig": false, "md5_digest": "11adcc69c2ba0cb492ebf96e141ca852", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21705, "upload_time": "2020-04-26T22:34:10", "upload_time_iso_8601": "2020-04-26T22:34:10.110092Z", "url": "https://files.pythonhosted.org/packages/91/0d/1f7922a6974ef357815e9c0857814895b1103c24ced811cbeb14ae62f719/pyflow-viz-0.8.tar.gz", "yanked": false}], "0.9": [{"comment_text": "", "digests": {"md5": "029287a88425c69f26342ff0265d3b79", "sha256": "5853f49c0f07fe538d2831f7da5868c5cf8903378224421fc089f4d20867bdb7"}, "downloads": -1, "filename": "pyflow_viz-0.9-py3-none-any.whl", "has_sig": false, "md5_digest": "029287a88425c69f26342ff0265d3b79", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 19143, "upload_time": "2020-04-27T01:57:02", "upload_time_iso_8601": "2020-04-27T01:57:02.369279Z", "url": "https://files.pythonhosted.org/packages/db/35/8d6de012fbf01b5977f948894d4f3b168325e37f169ec209d957db2a68df/pyflow_viz-0.9-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "29a29bb7daa2e1a4b3d8fc098a8dd3c7", "sha256": "fbbac032ae072085df07bd42b4eaebd669d06240df00476eb30cd9036b067626"}, "downloads": -1, "filename": "pyflow-viz-0.9.tar.gz", "has_sig": false, "md5_digest": "29a29bb7daa2e1a4b3d8fc098a8dd3c7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16593, "upload_time": "2020-04-27T01:57:03", "upload_time_iso_8601": "2020-04-27T01:57:03.776439Z", "url": "https://files.pythonhosted.org/packages/55/e8/8ed994c457f186bc69aa27dcb78a27e52317cd6f6907c95b1730c7a4dbf2/pyflow-viz-0.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "751d5f7bc543dbac8ea597d102217e84", "sha256": "8cc1ba1049cdcaa5c11cd9a47a9b1fb52b2a76e0911c5e59f3de4d253a79f775"}, "downloads": -1, "filename": "pyflow_viz-0.12-py3-none-any.whl", "has_sig": false, "md5_digest": "751d5f7bc543dbac8ea597d102217e84", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 20389, "upload_time": "2020-04-28T05:48:43", "upload_time_iso_8601": "2020-04-28T05:48:43.564237Z", "url": "https://files.pythonhosted.org/packages/3e/37/bd3405e559bc8b978e945e9e3befa8091caddd264c8e4401460fd4f384e1/pyflow_viz-0.12-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bad2e8d94041d57d2c071cea439b7549", "sha256": "3a517a4b6446d395fa539df7ef2f8a9fe0d7c4b2c6fa7680c1060df2bac9eec4"}, "downloads": -1, "filename": "pyflow-viz-0.12.tar.gz", "has_sig": false, "md5_digest": "bad2e8d94041d57d2c071cea439b7549", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24691, "upload_time": "2020-04-28T05:48:45", "upload_time_iso_8601": "2020-04-28T05:48:45.007448Z", "url": "https://files.pythonhosted.org/packages/3c/a4/29409ed58bfc77b4df2b43385c1b282d1c27b16546fc8fc0c38668ce8257/pyflow-viz-0.12.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:41 2020"}