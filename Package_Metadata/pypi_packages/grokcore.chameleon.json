{"info": {"author": "Uli Fouquet", "author_email": "grok-dev@zope.org", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy"], "description": "==================\ngrokcore.chameleon\n==================\n\n`grokcore.chameleon` makes it possible to use Chameleon page templates in Grok.\nFor more information on Grok and Chameleon page templates see:\n\n- http://pagetemplates.org/\n- http://pagetemplates.org/docs/latest/\n- http://pypi.python.org/pypi/Chameleon\n- http://grok.zope.org/\n\n.. contents::\n\nInstallation\n============\n\nNote that future versions of grok will depend itself on grokcore.chameleon\nand configure it. In other words, chameleon-based templates will be available\nby default from that version on!\n\nTo use Chameleon page templates with Grok all you need is to install\ngrokcore.chameleon as an egg and include its ZCML. The best place to do\nthis is to make `grokcore.chameleon` a dependency of your application by\nadding it to your ``install_requires`` list in ``setup.cfg``. If you\nused grokproject to create your application ``setup.py`` is located in the\nproject root. It should look something like this::\n\n   install_requires=['setuptools',\n                     'grokcore.chameleon',\n                     # Add extra requirements here\n                     ],\n\nNote that if you use the ``allow-picked-versions = false`` directive in your\nproject's ``buildout.cfg``, you will have to add version number specifications\nfor several packages to your ``[versions]`` section.\n\nThen include ``grokcore.chameleon`` in your ``configure.zcml``. If you used\ngrokproject to create your application it's at\n``src/<projectname>/configure.zcml``. Add the include line after the include\nline for grok, but before the grokking of the current package. It should look\nsomething like this::\n\n      <include package=\"grok\" />\n      <include package=\"grokcore.chameleon\" />\n      <grok:grok package=\".\" />\n\nIf you use ``autoInclude`` in your ``configure.zcml``, you should not\nhave to do this latter step.\n\nThen run ``bin/buildout`` again. You should now see buildout saying\nsomething like (where version numbers can vary)::\n\n   Getting distribution for 'grokcore.chameleon'.\n   Got grokcore.chameleon 0.5.\n\nThat's all. You can now start using Chameleon page templates in your\nGrok application.\n\nUsage\n=====\n\n``grokcore.chameleon`` supports the Grok standard of placing templates in a\ntemplates directory, for example ``app_templates``, so you can use Chameleon\npage templates by simply placing the Chameleon page templates in the templates\ndirectory, just as you would with regular ZPT templates.\n\nAlthough chameleon templates themselves do not have a standard for the file\nextensions for templates, Grok needs to have an association between an filename\nextension and a template language implementation so it knows which\nimplementation to use.\n\n`grokcore.chameleon` declares to use the extension ``*.cpt`` (``Chameleon page\ntemplate``) for Chameleon page templates.\n\nYou can also use Chameleon page templates inline. The syntax for this\nis::\n\n   from grokcore.chameleon.components import ChameleonPageTemplate\n   index = ChameleonPageTemplate('<html>the html code</html>')\n\nOr if you use files::\n\n   from grokcore.chameleon.components import ChameleonPageTemplateFile\n   index = ChameleonPageTemplateFile(filename='thefilename.html')\n\n\n====================\nDetailed Description\n====================\n\nGrok-support for using chameleon driven templates.\n\nWith `grokcore.chameleon` you can use templates parsed and rendered by\n`Chameleon`_ using the Zope Page Template templating language.\n\nChameleon Zope page templates\n=============================\n\nChameleon provides support for Zope page templates which can be used\nfrom grok writing templates with the ``.cpt`` (=Chameleon Page\nTemplate) filename extension.\n\nChameleon page templates differ from standard Zope page templates in a\nfew aspects, most notably:\n\n* Expressions are parsed in ``Python-mode`` by default. This means,\n  instead of ``tal:content=\"view/value\"`` you must use\n  ``tal:content=\"view.value\"``. Every occurence of TAL-expressions\n  starting with ``python:`` now can be shortened by skipping this\n  marker.\n\n* Also Genshi-like variable substitutions are supported. For example\n  you can write ``${myvar}`` instead of ``tal:content=\"myvar\"``.\n\nBeside this, most rules for regular Zope page templates apply also to\nchameleon page templates.\n\nSee the `Chameleon`_ page for more information.\n\n.. _Chameleon: http://chameleon.repoze.org/docs/latest/zpt.html\n\nPrerequisites\n=============\n\nBefore we can see the templates in action, we care for correct\nregistration and set some used variables:\n\n    >>> import os\n    >>> testdir = os.path.join(os.path.dirname(__file__), 'tests')\n    >>> cpt_fixture = os.path.join(testdir, 'cpt_fixture')\n    >>> template_dir = os.path.join(cpt_fixture, 'app_templates')\n\nWe register everything. Before we can grok our fixture, we have to\ngrok the `grokcore.chameleon` package. This way the new template types\nare registered with the framework:\n\n    >>> import grokcore.view\n    >>> grokcore.view.testing.grok('grokcore.chameleon')\n    >>> grokcore.view.testing.grok('grokcore.chameleon.tests.cpt_fixture')\n\nWe create a mammoth, which should provide us a bunch of chameleon page\ntemplate driven views and put it in the database to setup location\ninfo::\n\n    >>> from grokcore.chameleon.tests.cpt_fixture.app import Mammoth\n    >>> manfred = Mammoth()\n    >>> getRootFolder()['manfred'] = manfred\n\nFurthermore we prepare for getting the different views on manfred:\n\n    >>> from zope.publisher.browser import TestRequest\n    >>> from zope.component import getMultiAdapter\n    >>> request = TestRequest()\n\nSimple templates\n================\n\nWe prepared a plain cavepainting view. The template looks like this:\n\n    >>> cavepainting_cpt = os.path.join(template_dir, 'cavepainting.cpt')\n    >>> print(open(cavepainting_cpt, 'r').read())\n    <html>\n      <body>\n        A cave painting.\n      </body>\n    </html>\n\nThe rendered view looks like this:\n\n    >>> view = getMultiAdapter((manfred, request),\n    ...                         name='cavepainting')\n    >>> print(view())\n    <html>\n      <body>\n        A cave painting.\n      </body>\n    </html>\n\nSubstituting variables\n======================\n\nA template can access variables like ``view``, ``context``, ``static``\nand its methods and attributes. The ``food`` view does exactly\nthis. The template looks like this:\n\n    >>> food_cpt = os.path.join(template_dir, 'food.cpt')\n    >>> print(open(food_cpt, 'r').read())\n    <html>\n    <body>\n    <span tal:define=\"foo 'a FOO'\">\n    ${view.me_do()}\n    <span tal:replace=\"structure view.me_do()\" />\n    CSS-URL: ${path:static/test.css}\n    My context is: ${view.url(context)}\n    ${foo}\n    <span tal:replace=\"foo\" />\n    </span>\n    </body>\n    </html>\n\nThe rendered view looks like this:\n\n    >>> view = getMultiAdapter((manfred, request), name='food')\n    >>> print(view())\n    <html>\n    <body>\n    <span>\n    &lt;ME GROK EAT MAMMOTH!&gt;\n    <ME GROK EAT MAMMOTH!>\n    CSS-URL: dummy:/test.css\n    My context is: http://127.0.0.1/manfred\n    a FOO\n    a FOO\n    </span>\n    </body>\n    </html>\n\nAs we can see, there is a difference between Genshi-like substitution\nand TAL-like substitution: while both expressions::\n\n  ${view.me_do()}\n\nand::\n\n  <span tal:replace=\"view.me_do()\" />\n\nactually render the same string ``<ME GROK EAT MAMMOTH!>``, the former\ndoes this straight and plain, while the latter performs additionally\nHTML-encoding of the string. Therefore the output of both expressions\ndiffer. It's::\n\n  <ME GROK EAT MAMMOTH!>\n\nfor the former expression and::\n\n  &lt;ME GROK EAT MAMMOTH!&gt;\n\nfor the latter.\n\n\nSupported variables\n===================\n\nEach template provides at least the following vars:\n\n* ``template``\n    the template instance\n\n* ``view``\n    the associated view\n\n* ``context``\n    the context of the view\n\n* ``request``\n    the current request\n\nas we can see, when we look at the ``vars.cpt`` from our fixture:\n\n    >>> cpt_file = os.path.join(template_dir, 'vars.cpt')\n    >>> print(open(cpt_file, 'r').read())\n    <html>\n    <body>\n    This template knows about the following vars:\n    <BLANKLINE>\n      template (the template instance):\n       ${template}\n    <BLANKLINE>\n      view (the associated view):\n       ${view}\n    <BLANKLINE>\n      context (the context of the view):\n       ${context}\n    <BLANKLINE>\n      request (the current request):\n       ${request}\n    </body>\n    </html>\n\nand render it:\n\n    >>> view = getMultiAdapter((manfred, request), name='vars')\n    >>> print(view())\n    <html>\n    <body>\n    This template knows about the following vars:\n    <BLANKLINE>\n      template (the template instance):\n       &lt;PageTemplateFile ...vars.cpt&gt;\n    <BLANKLINE>\n      view (the associated view):\n       &lt;grokcore.chameleon.tests.cpt_fixture.app.Vars object at 0x...&gt;\n    <BLANKLINE>\n      context (the context of the view):\n       &lt;grokcore.chameleon.tests.cpt_fixture.app.Mammoth object at 0x...&gt;\n    <BLANKLINE>\n      request (the current request):\n       CONTENT_LENGTH:\t0\n    GATEWAY_INTERFACE:\tTestFooInterface/1.0\n    HTTP_HOST:\t127.0.0.1\n    SERVER_URL:\thttp://127.0.0.1\n    </body>\n    </html>\n\nCustom template namespace names are supported:\n\n    >>> view = getMultiAdapter((manfred, request), name='namespace')\n    >>> print(view())\n    <html>\n    <body>\n    This template knows about the following custom namespace name:\n    <BLANKLINE>\n      myname:\n       Henk\n    <BLANKLINE>\n    </body>\n    </html>\n\nInline Templates\n================\n\nWe can also define inline templates. In our ``app.py`` we defined an\ninline template like this::\n\n  from grokcore.chameleon import components\n\n  ...\n\n  class Inline(grokcore.view.View):\n    sometext = 'Some Text'\n\n  inline = components.ChameleonPageTemplate(\n      \"<html><body>ME GROK HAS INLINES! ${view.sometext}</body></html>\")\n\nIf we render this view we get:\n\n    >>> view = getMultiAdapter((manfred, request), name='inline')\n    >>> print(view())\n    <html><body>ME GROK HAS INLINES! Some Text</body></html>\n\nTAL expressions\n===============\n\nStarting with ``grokcore.chameleon`` 0.5 we deploy the all-in-one\n`Chameleon`_ package.\n\nWhat TAL/TALES expressions in templates are supported depends mainly\nfrom the installed version of `Chameleon`, while we support some\nadditional, Zope-related TALES expressions.\n\nA list of all supported expressions and statements can be found at the\n`chameleon.zpt documentation\n<http://chameleon.repoze.org/docs/latest/zpt.html>`_. The additional\nTALES expressions provided by ``grokcore.chameleon`` are:\n\n* ``exists``\n     Tell whether a name exists in the templates' namespace.\n\n* ``not``\n     Evaluate the expression to a boolean value and invert it.\n\n* ``path``\n     Handle the expression as a path and not as a Python expression.\n\n* ``provider``\n     Support for viewlet providers.\n\n.. note:: Starting with ``grokcore.chameleon`` 0.5 support for the\n          Python expression ``exists()`` has been dropped. The TALES\n          expression ``exists: path/to/something`` is still available.\n\nIn our ``app.py`` we defined a special view for showing some special\nexpressions. This also includes a viewlet::\n\n   import grok\n   from grokcore.chameleon import components\n\n   class Mammoth(grok.Application, grok.Container):\n       pass\n\n   ...\n\n   class Expressions(grok.View):\n       pass\n\n   class MainArea(grok.ViewletManager):\n       grok.name('main')\n\n   class MainContent(grok.Viewlet):\n       grok.view(Expressions)\n       grok.viewletmanager(MainArea)\n       def render(self):\n           return 'Hello from viewlet'\n\nNow we can make use of the TALES expressions ``not:``, ``path:``,\n``exists:`` and ``provider:`` in the ``expressions.cpt`` template of\nour fixture:\n\n    >>> cpt_file = os.path.join(template_dir, 'expressions.cpt')\n    >>> print(open(cpt_file, 'r').read())\n    <html>\n    <body>\n      <div tal:define=\"food 'Yummy Dinoburger'\"\n           tal:omit-tag=\"\">\n        <!-- We support `exists` -->\n        <div tal:condition=\"exists: food\">\n          ${food}\n        </div>\n    <BLANKLINE>\n        <!-- We support `not` -->\n        <div tal:content=\"not: food\" />\n        <div tal:content=\"not('food')\" />\n        <div tal:content=\"not: 1 in [2,3]\" />\n        <div tal:content=\"not: not: food\" />\n    <BLANKLINE>\n        <!-- We support `path` -->\n        <div tal:content=\"path: food/upper\" />\n    <BLANKLINE>\n        <!-- We support `provider` -->\n        <tal:main content=\"structure provider:main\" />\n    <BLANKLINE>\n      </div>\n    </body>\n    </html>\n\nand render it:\n\n    >>> view = getMultiAdapter((manfred, request), name='expressions')\n    >>> print(view())\n    <html>\n    <body>\n    <BLANKLINE>\n        <!-- We support `exists` -->\n        <div>\n          Yummy Dinoburger\n        </div>\n    <BLANKLINE>\n        <!-- We support `not` -->\n        <div>False</div>\n        <div>False</div>\n        <div>True</div>\n        <div>True</div>\n    <BLANKLINE>\n        <!-- We support `path` -->\n        <div>YUMMY DINOBURGER</div>\n    <BLANKLINE>\n        <!-- We support `provider` -->\n        Hello from viewlet\n    <BLANKLINE>\n    <BLANKLINE>\n    </body>\n    </html>\n\nTranslation\n===========\n\n    >>> # Monkeypatch zope.i18n.negotiate\n    >>> import zope.i18n\n    >>> import zope.i18n.config\n    >>> print(getMultiAdapter((manfred, request), name='menu')())\n    <html>\n    <body>\n      <h1>Menu</h1>\n      <ol>\n        <li>Deepfried breaded veal cutlets</li>\n      </ol>\n    </body>\n    </html>\n\n    >>> # What's for food today in Germany?\n    >>> # We need to monkey patch the language settings for this test.\n    >>> old_1, old_2 = zope.i18n.negotiate, zope.i18n.config.ALLOWED_LANGUAGES\n    >>> zope.i18n.negotiate = lambda context: 'de'\n    >>> zope.i18n.config.ALLOWED_LANGUAGES = ['de']\n    >>> print(getMultiAdapter((manfred, request), name='menu')())\n    <html>\n    <body>\n      <h1>Menu</h1>\n      <ol>\n        <li>Schnitzel</li>\n      </ol>\n    </body>\n    </html>\n\n    >>> # Restore the monkey patch.\n    >>> zope.i18n.negotiate, zope.i18n.config.ALLOWED_LANGUAGES = old_1, old_2\n\nMacros\n======\n\nWith ``grokcore.chameleon`` we can also use macros, although it is a bit\ndifferent from regular Zope page templates.\n\nWe can define macros like this:\n\n    >>> cpt_file = os.path.join(template_dir, 'macromaster.cpt')\n    >>> print(open(cpt_file, 'r').read())\n    <p xmlns:metal=\"http://xml.zope.org/namespaces/metal\"\n       metal:define-macro=\"hello\">\n      Hello from <b metal:define-slot=\"name\">macro master</b>\n    </p>\n\nThe defined macro ``hello`` can be rendered in another Chameleon\ntemplate with the METAL attribute ``use-macro``.\n\nTo refer to a local macro, i.e. a macros defined in the same template,\nyou can use something like::\n\n  <div metal:use-macro=\"template.macros['<macro-name>']\">\n    Replaced by macro\n  </div>\n\nwhere ``<macro-name>`` must be an existing macro name.\n\nTo refer to macros in external templates, you must use the ``path:`` expression\nlike this::\n\n  <div metal:use-macro=\"path:\n    context/@@<viewname>/template/macros/<macro-name>\">\n     Replaced by external macro\n  </div>\n\nwhere ``<viewname>`` refers to an existing view on ``context`` and ``macro-\nname`` again refers to an existing macro in the specified template.\n\nNote, that this is different from how you refer to macros in standard Zope page\ntemplates. The short notation ``view/macros/<macro-name>`` works only with\nregular Zope page templates.\n\nThe following template makes use of both methods:\n\n    >>> cpt_file = os.path.join(template_dir, 'macrouser.cpt')\n    >>> print(open(cpt_file, 'r').read())\n    <html xmlns:metal=\"http://xml.zope.org/namespaces/metal\">\n    <body>\n      <p metal:define-macro=\"hello\">\n        Hi there from macro user!\n      </p>\n      <div metal:use-macro=\"template.macros['hello']\">\n        Fill this\n      </div>\n    <BLANKLINE>\n      <div metal:use-macro=\"path: context/@@macromaster/template/macros/hello\">\n        <b metal:fill-slot=\"name\">user slot</b>\n        Fill this too\n      </div>\n    </body>\n    </html>\n\nWhen rendered also the slot defined in the master template is filled by macro\nuser content:\n\n    >>> cpt_file = os.path.join(template_dir, 'macrouser.cpt')\n    >>> view = getMultiAdapter((manfred, request), name='macrouser')\n    >>> print(view())\n    <html>\n    <body>\n      <p>\n        Hi there from macro user!\n      </p>\n      <p>\n        Hi there from macro user!\n      </p>\n    <BLANKLINE>\n    <BLANKLINE>\n      <p>\n      Hello from <b>user slot</b>\n    <BLANKLINE>\n    </p>\n    </body>\n    </html>\n\n\nClean up:\n\n    >>> del getRootFolder()['manfred']\n\nDifferences from regular Zope page templates\n============================================\n\n* Macros are referenced differently. See appropriate section above.\n\n* Expressions are parsed in ``Python-mode`` by default. This means, instead\n  of ``tal:content=\"view/value\"`` you must use ``tal:content=\"view.value\"``.\n  Every occurence of TAL-expressions starting with ``python:`` now can be\n  shortened by skipping this marker.\n\n\nCHANGES\n*******\n\n3.0.1 (2018-01-12)\n==================\n\n- Rearrange tests such that Travis CI can pick up all functional tests too.\n\n3.0.0 (2018-01-11)\n==================\n\n- Python 3 compatibility.\n\n1.0.4 (2014-07-29)\n==================\n\n- Improve the performances of the translate mechanism with Chameleon\n  2.10 or more recent.\n\n1.0.3 (2012-10-12)\n==================\n\n- Fix broken translations when using Chameleon 2.9 or more recent.\n\n1.0.2 (2012-05-07)\n==================\n\n- With not using the z3c.pt PageTemplateFile baseclass, the behaviour of\n  finding the template file relative to the module was lost. This has been\n  fixed.\n\n1.0.1 (2012-05-03)\n==================\n\n- Make sure the minimal version requirements are defined.\n\n1.0 (2012-05-01)\n================\n\n- The ``target_language`` mangling was lost in version 1.0rc4.\n  Copied from z3c.pt.\n\n1.0rc4 (2012-01-03)\n===================\n\n- Update to newes Chameleon 2.7.1\n- Using some Components/Expressions directly from Chameleon instead of z3c.pt\n\n1.0rc3 (2011-07-14)\n===================\n\n- Rename megrok.chameleon into grokcore.chameleon to make it an official part\n  of Grok.\n\nEarlier versions\n================\n\n- Earlier versions of grokcore.chameleon came by the name megrok.chameleon.", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/grokcore.chameleon", "keywords": "grok chameleon template", "license": "ZPL", "maintainer": "", "maintainer_email": "", "name": "grokcore.chameleon", "package_url": "https://pypi.org/project/grokcore.chameleon/", "platform": "", "project_url": "https://pypi.org/project/grokcore.chameleon/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/grokcore.chameleon"}, "release_url": "https://pypi.org/project/grokcore.chameleon/3.0.1/", "requires_dist": null, "requires_python": "", "summary": "Chameleon page template support for Grok", "version": "3.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"grokcore-chameleon\">\n<h2><a href=\"#id8\" rel=\"nofollow\">grokcore.chameleon</a></h2>\n<p><cite>grokcore.chameleon</cite> makes it possible to use Chameleon page templates in Grok.\nFor more information on Grok and Chameleon page templates see:</p>\n<ul>\n<li><a href=\"http://pagetemplates.org/\" rel=\"nofollow\">http://pagetemplates.org/</a></li>\n<li><a href=\"http://pagetemplates.org/docs/latest/\" rel=\"nofollow\">http://pagetemplates.org/docs/latest/</a></li>\n<li><a href=\"http://pypi.python.org/pypi/Chameleon\" rel=\"nofollow\">http://pypi.python.org/pypi/Chameleon</a></li>\n<li><a href=\"http://grok.zope.org/\" rel=\"nofollow\">http://grok.zope.org/</a></li>\n</ul>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#grokcore-chameleon\" id=\"id8\" rel=\"nofollow\">grokcore.chameleon</a><ul>\n<li><a href=\"#installation\" id=\"id9\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#usage\" id=\"id10\" rel=\"nofollow\">Usage</a></li>\n</ul>\n</li>\n<li><a href=\"#detailed-description\" id=\"id11\" rel=\"nofollow\">Detailed Description</a><ul>\n<li><a href=\"#chameleon-zope-page-templates\" id=\"id12\" rel=\"nofollow\">Chameleon Zope page templates</a></li>\n<li><a href=\"#prerequisites\" id=\"id13\" rel=\"nofollow\">Prerequisites</a></li>\n<li><a href=\"#simple-templates\" id=\"id14\" rel=\"nofollow\">Simple templates</a></li>\n<li><a href=\"#substituting-variables\" id=\"id15\" rel=\"nofollow\">Substituting variables</a></li>\n<li><a href=\"#supported-variables\" id=\"id16\" rel=\"nofollow\">Supported variables</a></li>\n<li><a href=\"#inline-templates\" id=\"id17\" rel=\"nofollow\">Inline Templates</a></li>\n<li><a href=\"#tal-expressions\" id=\"id18\" rel=\"nofollow\">TAL expressions</a></li>\n<li><a href=\"#translation\" id=\"id19\" rel=\"nofollow\">Translation</a></li>\n<li><a href=\"#macros\" id=\"id20\" rel=\"nofollow\">Macros</a></li>\n<li><a href=\"#differences-from-regular-zope-page-templates\" id=\"id21\" rel=\"nofollow\">Differences from regular Zope page templates</a><ul>\n<li><a href=\"#changes\" id=\"id22\" rel=\"nofollow\">CHANGES</a></li>\n</ul>\n</li>\n<li><a href=\"#id1\" id=\"id23\" rel=\"nofollow\">3.0.1 (2018-01-12)</a></li>\n<li><a href=\"#id2\" id=\"id24\" rel=\"nofollow\">3.0.0 (2018-01-11)</a></li>\n<li><a href=\"#id3\" id=\"id25\" rel=\"nofollow\">1.0.4 (2014-07-29)</a></li>\n<li><a href=\"#id4\" id=\"id26\" rel=\"nofollow\">1.0.3 (2012-10-12)</a></li>\n<li><a href=\"#id5\" id=\"id27\" rel=\"nofollow\">1.0.2 (2012-05-07)</a></li>\n<li><a href=\"#id6\" id=\"id28\" rel=\"nofollow\">1.0.1 (2012-05-03)</a></li>\n<li><a href=\"#id7\" id=\"id29\" rel=\"nofollow\">1.0 (2012-05-01)</a></li>\n<li><a href=\"#rc4-2012-01-03\" id=\"id30\" rel=\"nofollow\">1.0rc4 (2012-01-03)</a></li>\n<li><a href=\"#rc3-2011-07-14\" id=\"id31\" rel=\"nofollow\">1.0rc3 (2011-07-14)</a></li>\n<li><a href=\"#earlier-versions\" id=\"id32\" rel=\"nofollow\">Earlier versions</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"installation\">\n<h3><a href=\"#id9\" rel=\"nofollow\">Installation</a></h3>\n<p>Note that future versions of grok will depend itself on grokcore.chameleon\nand configure it. In other words, chameleon-based templates will be available\nby default from that version on!</p>\n<p>To use Chameleon page templates with Grok all you need is to install\ngrokcore.chameleon as an egg and include its ZCML. The best place to do\nthis is to make <cite>grokcore.chameleon</cite> a dependency of your application by\nadding it to your <tt>install_requires</tt> list in <tt>setup.cfg</tt>. If you\nused grokproject to create your application <tt>setup.py</tt> is located in the\nproject root. It should look something like this:</p>\n<pre>install_requires=['setuptools',\n                  'grokcore.chameleon',\n                  # Add extra requirements here\n                  ],\n</pre>\n<p>Note that if you use the <tt><span class=\"pre\">allow-picked-versions</span> = false</tt> directive in your\nproject\u2019s <tt>buildout.cfg</tt>, you will have to add version number specifications\nfor several packages to your <tt>[versions]</tt> section.</p>\n<p>Then include <tt>grokcore.chameleon</tt> in your <tt>configure.zcml</tt>. If you used\ngrokproject to create your application it\u2019s at\n<tt><span class=\"pre\">src/&lt;projectname&gt;/configure.zcml</span></tt>. Add the include line after the include\nline for grok, but before the grokking of the current package. It should look\nsomething like this:</p>\n<pre>&lt;include package=\"grok\" /&gt;\n&lt;include package=\"grokcore.chameleon\" /&gt;\n&lt;grok:grok package=\".\" /&gt;\n</pre>\n<p>If you use <tt>autoInclude</tt> in your <tt>configure.zcml</tt>, you should not\nhave to do this latter step.</p>\n<p>Then run <tt>bin/buildout</tt> again. You should now see buildout saying\nsomething like (where version numbers can vary):</p>\n<pre>Getting distribution for 'grokcore.chameleon'.\nGot grokcore.chameleon 0.5.\n</pre>\n<p>That\u2019s all. You can now start using Chameleon page templates in your\nGrok application.</p>\n</div>\n<div id=\"usage\">\n<h3><a href=\"#id10\" rel=\"nofollow\">Usage</a></h3>\n<p><tt>grokcore.chameleon</tt> supports the Grok standard of placing templates in a\ntemplates directory, for example <tt>app_templates</tt>, so you can use Chameleon\npage templates by simply placing the Chameleon page templates in the templates\ndirectory, just as you would with regular ZPT templates.</p>\n<p>Although chameleon templates themselves do not have a standard for the file\nextensions for templates, Grok needs to have an association between an filename\nextension and a template language implementation so it knows which\nimplementation to use.</p>\n<p><cite>grokcore.chameleon</cite> declares to use the extension <tt>*.cpt</tt> (<tt>Chameleon page\ntemplate</tt>) for Chameleon page templates.</p>\n<p>You can also use Chameleon page templates inline. The syntax for this\nis:</p>\n<pre>from grokcore.chameleon.components import ChameleonPageTemplate\nindex = ChameleonPageTemplate('&lt;html&gt;the html code&lt;/html&gt;')\n</pre>\n<p>Or if you use files:</p>\n<pre>from grokcore.chameleon.components import ChameleonPageTemplateFile\nindex = ChameleonPageTemplateFile(filename='thefilename.html')\n</pre>\n</div>\n</div>\n<div id=\"detailed-description\">\n<h2><a href=\"#id11\" rel=\"nofollow\">Detailed Description</a></h2>\n<p>Grok-support for using chameleon driven templates.</p>\n<p>With <cite>grokcore.chameleon</cite> you can use templates parsed and rendered by\n<a href=\"http://chameleon.repoze.org/docs/latest/zpt.html\" rel=\"nofollow\">Chameleon</a> using the Zope Page Template templating language.</p>\n<div id=\"chameleon-zope-page-templates\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Chameleon Zope page templates</a></h3>\n<p>Chameleon provides support for Zope page templates which can be used\nfrom grok writing templates with the <tt>.cpt</tt> (=Chameleon Page\nTemplate) filename extension.</p>\n<p>Chameleon page templates differ from standard Zope page templates in a\nfew aspects, most notably:</p>\n<ul>\n<li>Expressions are parsed in <tt><span class=\"pre\">Python-mode</span></tt> by default. This means,\ninstead of <tt><span class=\"pre\">tal:content=\"view/value\"</span></tt> you must use\n<tt><span class=\"pre\">tal:content=\"view.value\"</span></tt>. Every occurence of TAL-expressions\nstarting with <tt>python:</tt> now can be shortened by skipping this\nmarker.</li>\n<li>Also Genshi-like variable substitutions are supported. For example\nyou can write <tt>${myvar}</tt> instead of <tt><span class=\"pre\">tal:content=\"myvar\"</span></tt>.</li>\n</ul>\n<p>Beside this, most rules for regular Zope page templates apply also to\nchameleon page templates.</p>\n<p>See the <a href=\"http://chameleon.repoze.org/docs/latest/zpt.html\" rel=\"nofollow\">Chameleon</a> page for more information.</p>\n</div>\n<div id=\"prerequisites\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Prerequisites</a></h3>\n<p>Before we can see the templates in action, we care for correct\nregistration and set some used variables:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; testdir = os.path.join(os.path.dirname(__file__), 'tests')\n&gt;&gt;&gt; cpt_fixture = os.path.join(testdir, 'cpt_fixture')\n&gt;&gt;&gt; template_dir = os.path.join(cpt_fixture, 'app_templates')\n</pre>\n</blockquote>\n<p>We register everything. Before we can grok our fixture, we have to\ngrok the <cite>grokcore.chameleon</cite> package. This way the new template types\nare registered with the framework:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import grokcore.view\n&gt;&gt;&gt; grokcore.view.testing.grok('grokcore.chameleon')\n&gt;&gt;&gt; grokcore.view.testing.grok('grokcore.chameleon.tests.cpt_fixture')\n</pre>\n</blockquote>\n<p>We create a mammoth, which should provide us a bunch of chameleon page\ntemplate driven views and put it in the database to setup location\ninfo:</p>\n<pre>&gt;&gt;&gt; from grokcore.chameleon.tests.cpt_fixture.app import Mammoth\n&gt;&gt;&gt; manfred = Mammoth()\n&gt;&gt;&gt; getRootFolder()['manfred'] = manfred\n</pre>\n<p>Furthermore we prepare for getting the different views on manfred:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; from zope.component import getMultiAdapter\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n</div>\n<div id=\"simple-templates\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Simple templates</a></h3>\n<p>We prepared a plain cavepainting view. The template looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cavepainting_cpt = os.path.join(template_dir, 'cavepainting.cpt')\n&gt;&gt;&gt; print(open(cavepainting_cpt, 'r').read())\n&lt;html&gt;\n  &lt;body&gt;\n    A cave painting.\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>The rendered view looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request),\n...                         name='cavepainting')\n&gt;&gt;&gt; print(view())\n&lt;html&gt;\n  &lt;body&gt;\n    A cave painting.\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"substituting-variables\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Substituting variables</a></h3>\n<p>A template can access variables like <tt>view</tt>, <tt>context</tt>, <tt>static</tt>\nand its methods and attributes. The <tt>food</tt> view does exactly\nthis. The template looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; food_cpt = os.path.join(template_dir, 'food.cpt')\n&gt;&gt;&gt; print(open(food_cpt, 'r').read())\n&lt;html&gt;\n&lt;body&gt;\n&lt;span tal:define=\"foo 'a FOO'\"&gt;\n${view.me_do()}\n&lt;span tal:replace=\"structure view.me_do()\" /&gt;\nCSS-URL: ${path:static/test.css}\nMy context is: ${view.url(context)}\n${foo}\n&lt;span tal:replace=\"foo\" /&gt;\n&lt;/span&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>The rendered view looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='food')\n&gt;&gt;&gt; print(view())\n&lt;html&gt;\n&lt;body&gt;\n&lt;span&gt;\n&amp;lt;ME GROK EAT MAMMOTH!&amp;gt;\n&lt;ME GROK EAT MAMMOTH!&gt;\nCSS-URL: dummy:/test.css\nMy context is: http://127.0.0.1/manfred\na FOO\na FOO\n&lt;/span&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>As we can see, there is a difference between Genshi-like substitution\nand TAL-like substitution: while both expressions:</p>\n<pre>${view.me_do()}\n</pre>\n<p>and:</p>\n<pre>&lt;span tal:replace=\"view.me_do()\" /&gt;\n</pre>\n<p>actually render the same string <tt>&lt;ME GROK EAT MAMMOTH!&gt;</tt>, the former\ndoes this straight and plain, while the latter performs additionally\nHTML-encoding of the string. Therefore the output of both expressions\ndiffer. It\u2019s:</p>\n<pre>&lt;ME GROK EAT MAMMOTH!&gt;\n</pre>\n<p>for the former expression and:</p>\n<pre>&amp;lt;ME GROK EAT MAMMOTH!&amp;gt;\n</pre>\n<p>for the latter.</p>\n</div>\n<div id=\"supported-variables\">\n<h3><a href=\"#id16\" rel=\"nofollow\">Supported variables</a></h3>\n<p>Each template provides at least the following vars:</p>\n<ul>\n<li><dl>\n<dt><tt>template</tt></dt>\n<dd>the template instance</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>view</tt></dt>\n<dd>the associated view</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>context</tt></dt>\n<dd>the context of the view</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>request</tt></dt>\n<dd>the current request</dd>\n</dl>\n</li>\n</ul>\n<p>as we can see, when we look at the <tt>vars.cpt</tt> from our fixture:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'vars.cpt')\n&gt;&gt;&gt; print(open(cpt_file, 'r').read())\n&lt;html&gt;\n&lt;body&gt;\nThis template knows about the following vars:\n&lt;BLANKLINE&gt;\n  template (the template instance):\n   ${template}\n&lt;BLANKLINE&gt;\n  view (the associated view):\n   ${view}\n&lt;BLANKLINE&gt;\n  context (the context of the view):\n   ${context}\n&lt;BLANKLINE&gt;\n  request (the current request):\n   ${request}\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>and render it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='vars')\n&gt;&gt;&gt; print(view())\n&lt;html&gt;\n&lt;body&gt;\nThis template knows about the following vars:\n&lt;BLANKLINE&gt;\n  template (the template instance):\n   &amp;lt;PageTemplateFile ...vars.cpt&amp;gt;\n&lt;BLANKLINE&gt;\n  view (the associated view):\n   &amp;lt;grokcore.chameleon.tests.cpt_fixture.app.Vars object at 0x...&amp;gt;\n&lt;BLANKLINE&gt;\n  context (the context of the view):\n   &amp;lt;grokcore.chameleon.tests.cpt_fixture.app.Mammoth object at 0x...&amp;gt;\n&lt;BLANKLINE&gt;\n  request (the current request):\n   CONTENT_LENGTH:  0\nGATEWAY_INTERFACE:  TestFooInterface/1.0\nHTTP_HOST:  127.0.0.1\nSERVER_URL: http://127.0.0.1\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>Custom template namespace names are supported:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='namespace')\n&gt;&gt;&gt; print(view())\n&lt;html&gt;\n&lt;body&gt;\nThis template knows about the following custom namespace name:\n&lt;BLANKLINE&gt;\n  myname:\n   Henk\n&lt;BLANKLINE&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"inline-templates\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Inline Templates</a></h3>\n<p>We can also define inline templates. In our <tt>app.py</tt> we defined an\ninline template like this:</p>\n<pre>from grokcore.chameleon import components\n\n...\n\nclass Inline(grokcore.view.View):\n  sometext = 'Some Text'\n\ninline = components.ChameleonPageTemplate(\n    \"&lt;html&gt;&lt;body&gt;ME GROK HAS INLINES! ${view.sometext}&lt;/body&gt;&lt;/html&gt;\")\n</pre>\n<p>If we render this view we get:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='inline')\n&gt;&gt;&gt; print(view())\n&lt;html&gt;&lt;body&gt;ME GROK HAS INLINES! Some Text&lt;/body&gt;&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"tal-expressions\">\n<h3><a href=\"#id18\" rel=\"nofollow\">TAL expressions</a></h3>\n<p>Starting with <tt>grokcore.chameleon</tt> 0.5 we deploy the all-in-one\n<a href=\"http://chameleon.repoze.org/docs/latest/zpt.html\" rel=\"nofollow\">Chameleon</a> package.</p>\n<p>What TAL/TALES expressions in templates are supported depends mainly\nfrom the installed version of <cite>Chameleon</cite>, while we support some\nadditional, Zope-related TALES expressions.</p>\n<p>A list of all supported expressions and statements can be found at the\n<a href=\"http://chameleon.repoze.org/docs/latest/zpt.html\" rel=\"nofollow\">chameleon.zpt documentation</a>. The additional\nTALES expressions provided by <tt>grokcore.chameleon</tt> are:</p>\n<ul>\n<li><dl>\n<dt><tt>exists</tt></dt>\n<dd>Tell whether a name exists in the templates\u2019 namespace.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>not</tt></dt>\n<dd>Evaluate the expression to a boolean value and invert it.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>path</tt></dt>\n<dd>Handle the expression as a path and not as a Python expression.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>provider</tt></dt>\n<dd>Support for viewlet providers.</dd>\n</dl>\n</li>\n</ul>\n<div>\n<p>Note</p>\n<p>Starting with <tt>grokcore.chameleon</tt> 0.5 support for the\nPython expression <tt>exists()</tt> has been dropped. The TALES\nexpression <tt>exists: path/to/something</tt> is still available.</p>\n</div>\n<p>In our <tt>app.py</tt> we defined a special view for showing some special\nexpressions. This also includes a viewlet:</p>\n<pre>import grok\nfrom grokcore.chameleon import components\n\nclass Mammoth(grok.Application, grok.Container):\n    pass\n\n...\n\nclass Expressions(grok.View):\n    pass\n\nclass MainArea(grok.ViewletManager):\n    grok.name('main')\n\nclass MainContent(grok.Viewlet):\n    grok.view(Expressions)\n    grok.viewletmanager(MainArea)\n    def render(self):\n        return 'Hello from viewlet'\n</pre>\n<p>Now we can make use of the TALES expressions <tt>not:</tt>, <tt>path:</tt>,\n<tt>exists:</tt> and <tt>provider:</tt> in the <tt>expressions.cpt</tt> template of\nour fixture:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'expressions.cpt')\n&gt;&gt;&gt; print(open(cpt_file, 'r').read())\n&lt;html&gt;\n&lt;body&gt;\n  &lt;div tal:define=\"food 'Yummy Dinoburger'\"\n       tal:omit-tag=\"\"&gt;\n    &lt;!-- We support `exists` --&gt;\n    &lt;div tal:condition=\"exists: food\"&gt;\n      ${food}\n    &lt;/div&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `not` --&gt;\n    &lt;div tal:content=\"not: food\" /&gt;\n    &lt;div tal:content=\"not('food')\" /&gt;\n    &lt;div tal:content=\"not: 1 in [2,3]\" /&gt;\n    &lt;div tal:content=\"not: not: food\" /&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `path` --&gt;\n    &lt;div tal:content=\"path: food/upper\" /&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `provider` --&gt;\n    &lt;tal:main content=\"structure provider:main\" /&gt;\n&lt;BLANKLINE&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>and render it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='expressions')\n&gt;&gt;&gt; print(view())\n&lt;html&gt;\n&lt;body&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `exists` --&gt;\n    &lt;div&gt;\n      Yummy Dinoburger\n    &lt;/div&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `not` --&gt;\n    &lt;div&gt;False&lt;/div&gt;\n    &lt;div&gt;False&lt;/div&gt;\n    &lt;div&gt;True&lt;/div&gt;\n    &lt;div&gt;True&lt;/div&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `path` --&gt;\n    &lt;div&gt;YUMMY DINOBURGER&lt;/div&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `provider` --&gt;\n    Hello from viewlet\n&lt;BLANKLINE&gt;\n&lt;BLANKLINE&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"translation\">\n<h3><a href=\"#id19\" rel=\"nofollow\">Translation</a></h3>\n<blockquote>\n<pre>&gt;&gt;&gt; # Monkeypatch zope.i18n.negotiate\n&gt;&gt;&gt; import zope.i18n\n&gt;&gt;&gt; import zope.i18n.config\n&gt;&gt;&gt; print(getMultiAdapter((manfred, request), name='menu')())\n&lt;html&gt;\n&lt;body&gt;\n  &lt;h1&gt;Menu&lt;/h1&gt;\n  &lt;ol&gt;\n    &lt;li&gt;Deepfried breaded veal cutlets&lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<pre>&gt;&gt;&gt; # What's for food today in Germany?\n&gt;&gt;&gt; # We need to monkey patch the language settings for this test.\n&gt;&gt;&gt; old_1, old_2 = zope.i18n.negotiate, zope.i18n.config.ALLOWED_LANGUAGES\n&gt;&gt;&gt; zope.i18n.negotiate = lambda context: 'de'\n&gt;&gt;&gt; zope.i18n.config.ALLOWED_LANGUAGES = ['de']\n&gt;&gt;&gt; print(getMultiAdapter((manfred, request), name='menu')())\n&lt;html&gt;\n&lt;body&gt;\n  &lt;h1&gt;Menu&lt;/h1&gt;\n  &lt;ol&gt;\n    &lt;li&gt;Schnitzel&lt;/li&gt;\n  &lt;/ol&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<pre>&gt;&gt;&gt; # Restore the monkey patch.\n&gt;&gt;&gt; zope.i18n.negotiate, zope.i18n.config.ALLOWED_LANGUAGES = old_1, old_2\n</pre>\n</blockquote>\n</div>\n<div id=\"macros\">\n<h3><a href=\"#id20\" rel=\"nofollow\">Macros</a></h3>\n<p>With <tt>grokcore.chameleon</tt> we can also use macros, although it is a bit\ndifferent from regular Zope page templates.</p>\n<p>We can define macros like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'macromaster.cpt')\n&gt;&gt;&gt; print(open(cpt_file, 'r').read())\n&lt;p xmlns:metal=\"http://xml.zope.org/namespaces/metal\"\n   metal:define-macro=\"hello\"&gt;\n  Hello from &lt;b metal:define-slot=\"name\"&gt;macro master&lt;/b&gt;\n&lt;/p&gt;\n</pre>\n</blockquote>\n<p>The defined macro <tt>hello</tt> can be rendered in another Chameleon\ntemplate with the METAL attribute <tt><span class=\"pre\">use-macro</span></tt>.</p>\n<p>To refer to a local macro, i.e. a macros defined in the same template,\nyou can use something like:</p>\n<pre>&lt;div metal:use-macro=\"template.macros['&lt;macro-name&gt;']\"&gt;\n  Replaced by macro\n&lt;/div&gt;\n</pre>\n<p>where <tt><span class=\"pre\">&lt;macro-name&gt;</span></tt> must be an existing macro name.</p>\n<p>To refer to macros in external templates, you must use the <tt>path:</tt> expression\nlike this:</p>\n<pre>&lt;div metal:use-macro=\"path:\n  context/@@&lt;viewname&gt;/template/macros/&lt;macro-name&gt;\"&gt;\n   Replaced by external macro\n&lt;/div&gt;\n</pre>\n<p>where <tt>&lt;viewname&gt;</tt> refers to an existing view on <tt>context</tt> and <tt>macro-\nname</tt> again refers to an existing macro in the specified template.</p>\n<p>Note, that this is different from how you refer to macros in standard Zope page\ntemplates. The short notation <tt><span class=\"pre\">view/macros/&lt;macro-name&gt;</span></tt> works only with\nregular Zope page templates.</p>\n<p>The following template makes use of both methods:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'macrouser.cpt')\n&gt;&gt;&gt; print(open(cpt_file, 'r').read())\n&lt;html xmlns:metal=\"http://xml.zope.org/namespaces/metal\"&gt;\n&lt;body&gt;\n  &lt;p metal:define-macro=\"hello\"&gt;\n    Hi there from macro user!\n  &lt;/p&gt;\n  &lt;div metal:use-macro=\"template.macros['hello']\"&gt;\n    Fill this\n  &lt;/div&gt;\n&lt;BLANKLINE&gt;\n  &lt;div metal:use-macro=\"path: context/@@macromaster/template/macros/hello\"&gt;\n    &lt;b metal:fill-slot=\"name\"&gt;user slot&lt;/b&gt;\n    Fill this too\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>When rendered also the slot defined in the master template is filled by macro\nuser content:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'macrouser.cpt')\n&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='macrouser')\n&gt;&gt;&gt; print(view())\n&lt;html&gt;\n&lt;body&gt;\n  &lt;p&gt;\n    Hi there from macro user!\n  &lt;/p&gt;\n  &lt;p&gt;\n    Hi there from macro user!\n  &lt;/p&gt;\n&lt;BLANKLINE&gt;\n&lt;BLANKLINE&gt;\n  &lt;p&gt;\n  Hello from &lt;b&gt;user slot&lt;/b&gt;\n&lt;BLANKLINE&gt;\n&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>Clean up:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del getRootFolder()['manfred']\n</pre>\n</blockquote>\n</div>\n<div id=\"differences-from-regular-zope-page-templates\">\n<h3><a href=\"#id21\" rel=\"nofollow\">Differences from regular Zope page templates</a></h3>\n<ul>\n<li>Macros are referenced differently. See appropriate section above.</li>\n<li>Expressions are parsed in <tt><span class=\"pre\">Python-mode</span></tt> by default. This means, instead\nof <tt><span class=\"pre\">tal:content=\"view/value\"</span></tt> you must use <tt><span class=\"pre\">tal:content=\"view.value\"</span></tt>.\nEvery occurence of TAL-expressions starting with <tt>python:</tt> now can be\nshortened by skipping this marker.</li>\n</ul>\n<div id=\"changes\">\n<h4><a href=\"#id22\" rel=\"nofollow\">CHANGES</a></h4>\n</div>\n</div>\n<div id=\"id1\">\n<h3><a href=\"#id23\" rel=\"nofollow\">3.0.1 (2018-01-12)</a></h3>\n<ul>\n<li>Rearrange tests such that Travis CI can pick up all functional tests too.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id24\" rel=\"nofollow\">3.0.0 (2018-01-11)</a></h3>\n<ul>\n<li>Python 3 compatibility.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id25\" rel=\"nofollow\">1.0.4 (2014-07-29)</a></h3>\n<ul>\n<li>Improve the performances of the translate mechanism with Chameleon\n2.10 or more recent.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id26\" rel=\"nofollow\">1.0.3 (2012-10-12)</a></h3>\n<ul>\n<li>Fix broken translations when using Chameleon 2.9 or more recent.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id27\" rel=\"nofollow\">1.0.2 (2012-05-07)</a></h3>\n<ul>\n<li>With not using the z3c.pt PageTemplateFile baseclass, the behaviour of\nfinding the template file relative to the module was lost. This has been\nfixed.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id28\" rel=\"nofollow\">1.0.1 (2012-05-03)</a></h3>\n<ul>\n<li>Make sure the minimal version requirements are defined.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id29\" rel=\"nofollow\">1.0 (2012-05-01)</a></h3>\n<ul>\n<li>The <tt>target_language</tt> mangling was lost in version 1.0rc4.\nCopied from z3c.pt.</li>\n</ul>\n</div>\n<div id=\"rc4-2012-01-03\">\n<h3><a href=\"#id30\" rel=\"nofollow\">1.0rc4 (2012-01-03)</a></h3>\n<ul>\n<li>Update to newes Chameleon 2.7.1</li>\n<li>Using some Components/Expressions directly from Chameleon instead of z3c.pt</li>\n</ul>\n</div>\n<div id=\"rc3-2011-07-14\">\n<h3><a href=\"#id31\" rel=\"nofollow\">1.0rc3 (2011-07-14)</a></h3>\n<ul>\n<li>Rename megrok.chameleon into grokcore.chameleon to make it an official part\nof Grok.</li>\n</ul>\n</div>\n<div id=\"earlier-versions\">\n<h3><a href=\"#id32\" rel=\"nofollow\">Earlier versions</a></h3>\n<ul>\n<li>Earlier versions of grokcore.chameleon came by the name megrok.chameleon.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3483904, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "41f0c6c85e2a50ad1c8c2123669aec91", "sha256": "031c61d064fcd0207462cd79b39c89359bd492c7f0537c70109746b26aed83e9"}, "downloads": -1, "filename": "grokcore.chameleon-1.0.tar.gz", "has_sig": false, "md5_digest": "41f0c6c85e2a50ad1c8c2123669aec91", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27952, "upload_time": "2012-05-01T19:33:47", "upload_time_iso_8601": "2012-05-01T19:33:47.503056Z", "url": "https://files.pythonhosted.org/packages/5c/87/624ba28a4685543844bb2437019b96468d8379781c87f3b1f9edea09e6fe/grokcore.chameleon-1.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "2439006011ec47d2801a4f02b6271033", "sha256": "8d6f5e8a877eb0a2551d5e4fb50ec053dfb60ed6f9831994952e238d663cf9f6"}, "downloads": -1, "filename": "grokcore.chameleon-1.0.1.tar.gz", "has_sig": false, "md5_digest": "2439006011ec47d2801a4f02b6271033", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23332, "upload_time": "2012-05-03T12:12:11", "upload_time_iso_8601": "2012-05-03T12:12:11.660139Z", "url": "https://files.pythonhosted.org/packages/48/cd/5668d140213e48bb345cad27018b3b6a5347a018669cbc1046c2d73120c0/grokcore.chameleon-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "176f6a8a1a8837f0329a53e713f6e6c3", "sha256": "d796ccc6a874e2143d706c229c558f526375d523893e50f6ee01a6ac37456eb6"}, "downloads": -1, "filename": "grokcore.chameleon-1.0.2.tar.gz", "has_sig": false, "md5_digest": "176f6a8a1a8837f0329a53e713f6e6c3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24320, "upload_time": "2012-05-07T17:47:34", "upload_time_iso_8601": "2012-05-07T17:47:34.672605Z", "url": "https://files.pythonhosted.org/packages/b1/d0/3f3cf5b57096bd681405e3109b58975621a1e3fda42e2ab45d51e8179e88/grokcore.chameleon-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "304eb554f4c1e0a71cefee279b1762c3", "sha256": "52db3ed22f6f55bb709b8599ff306bd2e37424251246c657035c79a6c40f04dc"}, "downloads": -1, "filename": "grokcore.chameleon-1.0.3.tar.gz", "has_sig": false, "md5_digest": "304eb554f4c1e0a71cefee279b1762c3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20845, "upload_time": "2012-10-12T09:13:23", "upload_time_iso_8601": "2012-10-12T09:13:23.530901Z", "url": "https://files.pythonhosted.org/packages/3e/c4/e38ddea477db95ecef783b98ea47c23ef530e3036bcda0aa47b86e5acec8/grokcore.chameleon-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "1a58d62312fa0c80c336e6b57acd76c4", "sha256": "d8af82196c4d65c854c9fd3b326d39d4732eff7c82569b0b188169d55cf3cb09"}, "downloads": -1, "filename": "grokcore.chameleon-1.0.4.zip", "has_sig": false, "md5_digest": "1a58d62312fa0c80c336e6b57acd76c4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35558, "upload_time": "2014-07-29T10:16:41", "upload_time_iso_8601": "2014-07-29T10:16:41.323437Z", "url": "https://files.pythonhosted.org/packages/29/99/c2e207ea800f5998d8dccfb4b5dd337efe593d42858bc34cceeef4bb8146/grokcore.chameleon-1.0.4.zip", "yanked": false}], "1.0rc3": [{"comment_text": "", "digests": {"md5": "647532007a6e989dc0e581234078d66b", "sha256": "3da3b92bff5b2109bc9e04606d665b94b93027a23e6ae5ba2f298fa3949d90ed"}, "downloads": -1, "filename": "grokcore.chameleon-1.0rc3.tar.gz", "has_sig": false, "md5_digest": "647532007a6e989dc0e581234078d66b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19454, "upload_time": "2011-07-14T15:43:11", "upload_time_iso_8601": "2011-07-14T15:43:11.723652Z", "url": "https://files.pythonhosted.org/packages/8d/d0/3a2e8ee25ef6997c9ba740fb3aaa33c274a207c171851477a4cdb8ea4f9a/grokcore.chameleon-1.0rc3.tar.gz", "yanked": false}], "1.0rc4": [{"comment_text": "", "digests": {"md5": "662f6e92af7d7bfc48dab58bda7da275", "sha256": "486cf0726681201fd194f3dd051a6456a17949d492f0e8f77f16bfc505c9a9d2"}, "downloads": -1, "filename": "grokcore.chameleon-1.0rc4.tar.gz", "has_sig": false, "md5_digest": "662f6e92af7d7bfc48dab58bda7da275", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22650, "upload_time": "2012-01-03T14:19:28", "upload_time_iso_8601": "2012-01-03T14:19:28.026175Z", "url": "https://files.pythonhosted.org/packages/c5/79/3d0ed11c796ea9cb5b7bb3c7b3337df50d5c16b98acda37bf886b1f21c9b/grokcore.chameleon-1.0rc4.tar.gz", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "29a5a5ed7e3f442db02ef889b9993d7e", "sha256": "4dd0a1a400d6ab3d521fd99960843af3fa8ad918deb1c0b1f2179c18e3bd043b"}, "downloads": -1, "filename": "grokcore.chameleon-3.0.0.tar.gz", "has_sig": false, "md5_digest": "29a5a5ed7e3f442db02ef889b9993d7e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22721, "upload_time": "2018-01-11T08:54:42", "upload_time_iso_8601": "2018-01-11T08:54:42.994732Z", "url": "https://files.pythonhosted.org/packages/88/8b/83bff4d587a964a8373f44cec440beb2a68b7092e7aa21e51d00d7d7e3e0/grokcore.chameleon-3.0.0.tar.gz", "yanked": false}], "3.0.1": [{"comment_text": "", "digests": {"md5": "7640aa794e2b405f6ae1238639507909", "sha256": "3eb9d4b9bf34b2172e3aedd6f088e74fba2d9dd1f51aa30a4d3ef1a319167aec"}, "downloads": -1, "filename": "grokcore.chameleon-3.0.1.tar.gz", "has_sig": false, "md5_digest": "7640aa794e2b405f6ae1238639507909", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22928, "upload_time": "2018-01-12T12:52:20", "upload_time_iso_8601": "2018-01-12T12:52:20.821347Z", "url": "https://files.pythonhosted.org/packages/15/96/4917264b7f29bd82c4c5a3334d66c794c187b08a125b3d368eb3f146237e/grokcore.chameleon-3.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7640aa794e2b405f6ae1238639507909", "sha256": "3eb9d4b9bf34b2172e3aedd6f088e74fba2d9dd1f51aa30a4d3ef1a319167aec"}, "downloads": -1, "filename": "grokcore.chameleon-3.0.1.tar.gz", "has_sig": false, "md5_digest": "7640aa794e2b405f6ae1238639507909", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22928, "upload_time": "2018-01-12T12:52:20", "upload_time_iso_8601": "2018-01-12T12:52:20.821347Z", "url": "https://files.pythonhosted.org/packages/15/96/4917264b7f29bd82c4c5a3334d66c794c187b08a125b3d368eb3f146237e/grokcore.chameleon-3.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:07 2020"}