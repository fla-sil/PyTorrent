{"info": {"author": "Jonah Bernhard", "author_email": "jonah.bernhard@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Topic :: Scientific/Engineering :: Physics"], "description": "freestream\n==========\n*Free streaming and Landau matching for boost-invariant hydrodynamic initial conditions.*\n\n.. image:: https://thumbs.gfycat.com/AffectionateQuerulousAfricanwilddog-size_restricted.gif\n   :target: http://gfycat.com/AffectionateQuerulousAfricanwilddog\n\n|\n\n``freestream`` is a Python implementation of pre-equilibrium free streaming for heavy-ion collisions, as described in\n\n- J. Liu, C. Shen, U. Heinz,\n  \"Pre-equilibrium evolution effects on heavy-ion collision observables\",\n  `PRC 91 064906 (2015) <http://journals.aps.org/prc/abstract/10.1103/PhysRevC.91.064906>`_,\n  `arXiv:1504.02160 [nucl-th] <http://inspirehep.net/record/1358669>`_.\n- W. Broniowski, W. Florkowski, M. Chojnacki, A. Kisiel,\n  \"Free-streaming approximation in early dynamics of relativistic heavy-ion collisions\",\n  `PRC 80 034902 (2009) <http://journals.aps.org/prc/abstract/10.1103/PhysRevC.80.034902>`_,\n  `arXiv:0812.3393 [nucl-th] <http://inspirehep.net/record/805616>`_.\n\nInstallation\n------------\nSimply run ::\n\n   pip install freestream\n\nThe only requirements are numpy (1.8.0 or later) and scipy (0.14.0 or later).\n\nUsage\n-----\n``freestream`` has an object-oriented interface through the ``FreeStreamer`` class, which takes three parameters:\n\n.. code-block:: python\n\n   freestream.FreeStreamer(initial, grid_max, time)\n\nwhere\n\n- ``initial`` is a square array containing the initial state,\n- ``grid_max`` is the *x* and *y* maximum of the grid in fm, i.e. half the grid width (see following example),\n- ``time`` is the time to free stream in fm/c.\n\nThe ``initial`` array must contain a two-dimensional (boost-invariant) initial condition discretized onto a uniform square grid.\nIt is then interpreted as a density profile of non-interacting massless partons at time *\u03c4* = 0+.\n\nThe ``grid_max`` parameter sets the outermost *edge* of the grid, *not* the midpoint of the outer grid cell, e.g.\n\n- A 200 \u00d7 200 grid with a max of 10.0 fm has cell edges at -10.00, -9.90, ..., +10.00 and cell midpoints at -9.95, -9.85, ..., +9.95.\n- A 201 \u00d7 201 grid with a max of 10.05 fm has cell edges at -10.05, -9.95, ..., +10.05 and cell midpoints at -10.00, -9.90, ..., +10.00.\n\nThis is the same definition as the `trento <https://github.com/Duke-QCD/trento>`_ ``--grid-max`` parameter.\n\n**It is very important that the grid max is set correctly to avoid superluminal propagation.**\n\nSuppose ``initial`` is an *n* \u00d7 *n* initial condition array with a grid max of 10.0 fm and we want to free stream for 1.0 fm.\nWe first create a ``FreeStreamer`` object:\n\n.. code-block:: python\n\n   import freestream\n\n   fs = freestream.FreeStreamer(initial, 10.0, 1.0)\n\nWe can now extract the various quantities needed to initialize hydro from ``fs``.\n\nEnergy-momentum tensor *T*\\ :sup:`\u03bc\u03bd`\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n.. code-block:: python\n\n   Tuv = fs.Tuv()\n\n``Tuv`` is an *n* \u00d7 *n* \u00d7 3 \u00d7 3 array containing the full tensor at each grid point.\nIf we only want a certain component of the tensor, we can pass indices to the function:\n\n.. code-block:: python\n\n   T00 = fs.Tuv(0, 0)\n\n``T00`` is an *n* \u00d7 *n* array containing *T*\\ :sup:`00` at each grid point.\nThis is purely for syntactic convenience: ``fs.Tuv(0, 0)`` is equivalent to ``fs.Tuv()[:, :, 0, 0]``.\n\nEnergy density *e* and flow velocity *u*\\ :sup:`\u03bc`\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n.. code-block:: python\n\n   e = fs.energy_density()  # n x n\n   u = fs.flow_velocity()  # n x n x 3\n\nWe can also extract the individual components of flow velocity:\n\n.. code-block:: python\n\n   u1 = fs.flow_velocity(1)  # n x n\n\nAgain, this is equivalent to ``fs.flow_velocity()[:, :, 1]``.\n\nShear tensor \u03c0\\ :sup:`\u03bc\u03bd` and bulk pressure \u03a0\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThe shear pressure tensor \u03c0\\ :sup:`\u03bc\u03bd` works just like *T*\\ :sup:`\u03bc\u03bd`:\n\n.. code-block:: python\n\n   pi = fs.shear_tensor()  # n x n x 3 x 3\n   pi01 = fs.shear_tensor(0, 1)  # n x n\n\nThe bulk viscous pressure \u03a0 depends on the equation of state *P(e)*.\nBy default, the ideal EoS *P(e)* = *e*/3 is used:\n\n.. code-block:: python\n\n   bulk = fs.bulk_pressure()\n\nThe bulk pressure is in fact zero with the ideal EoS, but there will be small nonzero values due to numerical precision.\n\nTo use another EoS, pass a callable object to ``bulk_pressure()``:\n\n.. code-block:: python\n\n   bulk = fs.bulk_pressure(eos)\n\nFor example, suppose we have a table of pressure and energy density we want to interpolate.\nWe can use ``scipy.interpolate`` to construct a spline and pass it to ``bulk_pressure()``:\n\n.. code-block:: python\n\n   import scipy.interpolate as interp\n\n   eos_spline = interp.InterpolatedUnivariateSpline(energy_density, pressure)\n   bulk = fs.bulk_pressure(eos_spline)\n\nOther notes\n~~~~~~~~~~~\nThe code should run in a few seconds, depending on the grid size.\nComputation time is proportional to the number of grid cells (i.e. *n*\\ :sup:`2`).\n\nEnsure that the grid is large enough to accommodate radial expansion.\nThe code does not check for overflow.\n\n``FreeStreamer`` returns references to its internal arrays, so do not modify them in place\u2014make copies!\n\nTesting and internals\n---------------------\n``FreeStreamer`` uses a two-dimensional cubic spline (`scipy.interpolate.RectBivariateSpline <https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.html>`_) to construct a continuous initial condition profile from a discrete grid.\nThis is very precise provided the grid spacing is small enough.\nThe spline sometimes goes very slightly negative around sharp boundaries; ``FreeStreamer`` coerces these negative values to zero.\n\nThe script ``test.py`` contains unit tests and generates visualizations for qualitative inspection.\nTo run the tests, install nose and run::\n\n   nosetests -v test.py\n\nThere are two unit tests:\n\n- Comparison against an analytic solution for a symmetric Gaussian initial state (computed in Mathematica).\n- Comparison against a randomly-generated initial condition without interpolation.\n\nThese tests occasionally fail since there is a random component and the tolerance is somewhat stringent (every grid point must agree within 0.1%).\nWhen a test fails, it will print out a list of ratios (observed/expected).\nTypically the failures occur at the outermost grid cell where the system is very dilute, and even there it will only miss by ~0.2%.\n\nTo generate visualizations, execute ``test.py`` as a script with two arguments, the test case to visualize and a PDF output file.\nThere are three test cases:\n\n- ``gaussian1``, a narrow symmetric Gaussian centered at the origin.\n- ``gaussian2``, a wider asymmetric Gaussian offset from the origin.\n- ``random``, a randomly-generated initial condition (this is not in any way realistic, it's only for visualization).\n\nFor example::\n\n   python test.py gaussian1 freestream.pdf\n\nwill run the ``gaussian1`` test case and save results in ``freestream.pdf``.\nThe PDF contains visualizations of the initial state and everything that ``FreeStreamer`` computes.\nIn each visualization, red colors indicate positive values, blue means negative, and the maximum absolute value of the array is annotated in the upper left.\n\nAnimations\n----------\nThe included script ``animate.py`` generates animations (like the one at the top of this page) from initial conditions saved in HDF5 format (e.g. `trento <https://github.com/Duke-QCD/trento>`_ events).\nIt requires python3 with matplotlib and h5py, and of course ``freestream`` must be installed.\nTo animate a trento event, first generate some events in HDF5 format then run the script::\n\n   trento Pb Pb 10 -o events.hdf\n   ./animate.py events.hdf event_0 freestream.mp4\n\nThe first argument is the HDF5 filename, the second is the dataset to animate, and the last is the animation filename.\nRun ``./animate.py --help`` for more information including options for the animation duration, framerate, colormap, etc.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Duke-QCD/freestream", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "freestream", "package_url": "https://pypi.org/project/freestream/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/freestream/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/Duke-QCD/freestream"}, "release_url": "https://pypi.org/project/freestream/1.0.1/", "requires_dist": null, "requires_python": null, "summary": "Free streaming for heavy-ion collision initial conditions.", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><em>Free streaming and Landau matching for boost-invariant hydrodynamic initial conditions.</em></p>\n<a href=\"http://gfycat.com/AffectionateQuerulousAfricanwilddog\" rel=\"nofollow\"><img alt=\"https://thumbs.gfycat.com/AffectionateQuerulousAfricanwilddog-size_restricted.gif\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f826165d5d116295ea73da54e233e2452449fcc9/68747470733a2f2f7468756d62732e6766796361742e636f6d2f416666656374696f6e61746551756572756c6f75734166726963616e77696c64646f672d73697a655f726573747269637465642e676966\"></a>\n<div>\n<div><br></div>\n</div>\n<p><tt>freestream</tt> is a Python implementation of pre-equilibrium free streaming for heavy-ion collisions, as described in</p>\n<ul>\n<li>J. Liu, C. Shen, U. Heinz,\n\u201cPre-equilibrium evolution effects on heavy-ion collision observables\u201d,\n<a href=\"http://journals.aps.org/prc/abstract/10.1103/PhysRevC.91.064906\" rel=\"nofollow\">PRC 91 064906 (2015)</a>,\n<a href=\"http://inspirehep.net/record/1358669\" rel=\"nofollow\">arXiv:1504.02160 [nucl-th]</a>.</li>\n<li>W. Broniowski, W. Florkowski, M. Chojnacki, A. Kisiel,\n\u201cFree-streaming approximation in early dynamics of relativistic heavy-ion collisions\u201d,\n<a href=\"http://journals.aps.org/prc/abstract/10.1103/PhysRevC.80.034902\" rel=\"nofollow\">PRC 80 034902 (2009)</a>,\n<a href=\"http://inspirehep.net/record/805616\" rel=\"nofollow\">arXiv:0812.3393 [nucl-th]</a>.</li>\n</ul>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Simply run</p>\n<pre>pip install freestream\n</pre>\n<p>The only requirements are numpy (1.8.0 or later) and scipy (0.14.0 or later).</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p><tt>freestream</tt> has an object-oriented interface through the <tt>FreeStreamer</tt> class, which takes three parameters:</p>\n<pre><span class=\"n\">freestream</span><span class=\"o\">.</span><span class=\"n\">FreeStreamer</span><span class=\"p\">(</span><span class=\"n\">initial</span><span class=\"p\">,</span> <span class=\"n\">grid_max</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"p\">)</span>\n</pre>\n<p>where</p>\n<ul>\n<li><tt>initial</tt> is a square array containing the initial state,</li>\n<li><tt>grid_max</tt> is the <em>x</em> and <em>y</em> maximum of the grid in fm, i.e. half the grid width (see following example),</li>\n<li><tt>time</tt> is the time to free stream in fm/c.</li>\n</ul>\n<p>The <tt>initial</tt> array must contain a two-dimensional (boost-invariant) initial condition discretized onto a uniform square grid.\nIt is then interpreted as a density profile of non-interacting massless partons at time <em>\u03c4</em> = 0+.</p>\n<p>The <tt>grid_max</tt> parameter sets the outermost <em>edge</em> of the grid, <em>not</em> the midpoint of the outer grid cell, e.g.</p>\n<ul>\n<li>A 200 \u00d7 200 grid with a max of 10.0 fm has cell edges at -10.00, -9.90, \u2026, +10.00 and cell midpoints at -9.95, -9.85, \u2026, +9.95.</li>\n<li>A 201 \u00d7 201 grid with a max of 10.05 fm has cell edges at -10.05, -9.95, \u2026, +10.05 and cell midpoints at -10.00, -9.90, \u2026, +10.00.</li>\n</ul>\n<p>This is the same definition as the <a href=\"https://github.com/Duke-QCD/trento\" rel=\"nofollow\">trento</a> <tt><span class=\"pre\">--grid-max</span></tt> parameter.</p>\n<p><strong>It is very important that the grid max is set correctly to avoid superluminal propagation.</strong></p>\n<p>Suppose <tt>initial</tt> is an <em>n</em> \u00d7 <em>n</em> initial condition array with a grid max of 10.0 fm and we want to free stream for 1.0 fm.\nWe first create a <tt>FreeStreamer</tt> object:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">freestream</span>\n\n<span class=\"n\">fs</span> <span class=\"o\">=</span> <span class=\"n\">freestream</span><span class=\"o\">.</span><span class=\"n\">FreeStreamer</span><span class=\"p\">(</span><span class=\"n\">initial</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">)</span>\n</pre>\n<p>We can now extract the various quantities needed to initialize hydro from <tt>fs</tt>.</p>\n<div id=\"energy-momentum-tensor-t\">\n<h3>Energy-momentum tensor <em>T</em><sup>\u03bc\u03bd</sup></h3>\n<pre><span class=\"n\">Tuv</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">Tuv</span><span class=\"p\">()</span>\n</pre>\n<p><tt>Tuv</tt> is an <em>n</em> \u00d7 <em>n</em> \u00d7 3 \u00d7 3 array containing the full tensor at each grid point.\nIf we only want a certain component of the tensor, we can pass indices to the function:</p>\n<pre><span class=\"n\">T00</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">Tuv</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n</pre>\n<p><tt>T00</tt> is an <em>n</em> \u00d7 <em>n</em> array containing <em>T</em><sup>00</sup> at each grid point.\nThis is purely for syntactic convenience: <tt>fs.Tuv(0, 0)</tt> is equivalent to <tt><span class=\"pre\">fs.Tuv()[:,</span> :, 0, 0]</tt>.</p>\n</div>\n<div id=\"energy-density-e-and-flow-velocity-u\">\n<h3>Energy density <em>e</em> and flow velocity <em>u</em><sup>\u03bc</sup></h3>\n<pre><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">energy_density</span><span class=\"p\">()</span>  <span class=\"c1\"># n x n</span>\n<span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">flow_velocity</span><span class=\"p\">()</span>  <span class=\"c1\"># n x n x 3</span>\n</pre>\n<p>We can also extract the individual components of flow velocity:</p>\n<pre><span class=\"n\">u1</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">flow_velocity</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># n x n</span>\n</pre>\n<p>Again, this is equivalent to <tt><span class=\"pre\">fs.flow_velocity()[:,</span> :, 1]</tt>.</p>\n</div>\n<div id=\"shear-tensor-and-bulk-pressure\">\n<h3>Shear tensor \u03c0<sup>\u03bc\u03bd</sup> and bulk pressure \u03a0</h3>\n<p>The shear pressure tensor \u03c0<sup>\u03bc\u03bd</sup> works just like <em>T</em><sup>\u03bc\u03bd</sup>:</p>\n<pre><span class=\"n\">pi</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">shear_tensor</span><span class=\"p\">()</span>  <span class=\"c1\"># n x n x 3 x 3</span>\n<span class=\"n\">pi01</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">shear_tensor</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># n x n</span>\n</pre>\n<p>The bulk viscous pressure \u03a0 depends on the equation of state <em>P(e)</em>.\nBy default, the ideal EoS <em>P(e)</em> = <em>e</em>/3 is used:</p>\n<pre><span class=\"n\">bulk</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">bulk_pressure</span><span class=\"p\">()</span>\n</pre>\n<p>The bulk pressure is in fact zero with the ideal EoS, but there will be small nonzero values due to numerical precision.</p>\n<p>To use another EoS, pass a callable object to <tt>bulk_pressure()</tt>:</p>\n<pre><span class=\"n\">bulk</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">bulk_pressure</span><span class=\"p\">(</span><span class=\"n\">eos</span><span class=\"p\">)</span>\n</pre>\n<p>For example, suppose we have a table of pressure and energy density we want to interpolate.\nWe can use <tt>scipy.interpolate</tt> to construct a spline and pass it to <tt>bulk_pressure()</tt>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">scipy.interpolate</span> <span class=\"k\">as</span> <span class=\"nn\">interp</span>\n\n<span class=\"n\">eos_spline</span> <span class=\"o\">=</span> <span class=\"n\">interp</span><span class=\"o\">.</span><span class=\"n\">InterpolatedUnivariateSpline</span><span class=\"p\">(</span><span class=\"n\">energy_density</span><span class=\"p\">,</span> <span class=\"n\">pressure</span><span class=\"p\">)</span>\n<span class=\"n\">bulk</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">bulk_pressure</span><span class=\"p\">(</span><span class=\"n\">eos_spline</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"other-notes\">\n<h3>Other notes</h3>\n<p>The code should run in a few seconds, depending on the grid size.\nComputation time is proportional to the number of grid cells (i.e. <em>n</em><sup>2</sup>).</p>\n<p>Ensure that the grid is large enough to accommodate radial expansion.\nThe code does not check for overflow.</p>\n<p><tt>FreeStreamer</tt> returns references to its internal arrays, so do not modify them in place\u2014make copies!</p>\n</div>\n</div>\n<div id=\"testing-and-internals\">\n<h2>Testing and internals</h2>\n<p><tt>FreeStreamer</tt> uses a two-dimensional cubic spline (<a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RectBivariateSpline.html\" rel=\"nofollow\">scipy.interpolate.RectBivariateSpline</a>) to construct a continuous initial condition profile from a discrete grid.\nThis is very precise provided the grid spacing is small enough.\nThe spline sometimes goes very slightly negative around sharp boundaries; <tt>FreeStreamer</tt> coerces these negative values to zero.</p>\n<p>The script <tt>test.py</tt> contains unit tests and generates visualizations for qualitative inspection.\nTo run the tests, install nose and run:</p>\n<pre>nosetests -v test.py\n</pre>\n<p>There are two unit tests:</p>\n<ul>\n<li>Comparison against an analytic solution for a symmetric Gaussian initial state (computed in Mathematica).</li>\n<li>Comparison against a randomly-generated initial condition without interpolation.</li>\n</ul>\n<p>These tests occasionally fail since there is a random component and the tolerance is somewhat stringent (every grid point must agree within 0.1%).\nWhen a test fails, it will print out a list of ratios (observed/expected).\nTypically the failures occur at the outermost grid cell where the system is very dilute, and even there it will only miss by ~0.2%.</p>\n<p>To generate visualizations, execute <tt>test.py</tt> as a script with two arguments, the test case to visualize and a PDF output file.\nThere are three test cases:</p>\n<ul>\n<li><tt>gaussian1</tt>, a narrow symmetric Gaussian centered at the origin.</li>\n<li><tt>gaussian2</tt>, a wider asymmetric Gaussian offset from the origin.</li>\n<li><tt>random</tt>, a randomly-generated initial condition (this is not in any way realistic, it\u2019s only for visualization).</li>\n</ul>\n<p>For example:</p>\n<pre>python test.py gaussian1 freestream.pdf\n</pre>\n<p>will run the <tt>gaussian1</tt> test case and save results in <tt>freestream.pdf</tt>.\nThe PDF contains visualizations of the initial state and everything that <tt>FreeStreamer</tt> computes.\nIn each visualization, red colors indicate positive values, blue means negative, and the maximum absolute value of the array is annotated in the upper left.</p>\n</div>\n<div id=\"animations\">\n<h2>Animations</h2>\n<p>The included script <tt>animate.py</tt> generates animations (like the one at the top of this page) from initial conditions saved in HDF5 format (e.g. <a href=\"https://github.com/Duke-QCD/trento\" rel=\"nofollow\">trento</a> events).\nIt requires python3 with matplotlib and h5py, and of course <tt>freestream</tt> must be installed.\nTo animate a trento event, first generate some events in HDF5 format then run the script:</p>\n<pre>trento Pb Pb 10 -o events.hdf\n./animate.py events.hdf event_0 freestream.mp4\n</pre>\n<p>The first argument is the HDF5 filename, the second is the dataset to animate, and the last is the animation filename.\nRun <tt>./animate.py <span class=\"pre\">--help</span></tt> for more information including options for the animation duration, framerate, colormap, etc.</p>\n</div>\n\n          </div>"}, "last_serial": 2298692, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "bc16661c252883650231070125f73d8f", "sha256": "05049d5475984d662cfc0f49d3a6bc347af03b65ebe5eb139e854bb71c5f82f9"}, "downloads": -1, "filename": "freestream-1.0.0.tar.gz", "has_sig": false, "md5_digest": "bc16661c252883650231070125f73d8f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9099, "upload_time": "2015-11-30T22:24:01", "upload_time_iso_8601": "2015-11-30T22:24:01.796664Z", "url": "https://files.pythonhosted.org/packages/47/2d/eda4ee71fbe24d8be96cd51b6b8e91ab01e4a592c49cc84d946e2cfdd6f7/freestream-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "1a257aa6274a57fe07c87b56bc7e3bc8", "sha256": "e739582d74dd377b2495af494bbfddbeaf0005d88a805e51e2fc0fbdcaaae290"}, "downloads": -1, "filename": "freestream-1.0.1.tar.gz", "has_sig": false, "md5_digest": "1a257aa6274a57fe07c87b56bc7e3bc8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10256, "upload_time": "2016-08-23T19:14:35", "upload_time_iso_8601": "2016-08-23T19:14:35.355468Z", "url": "https://files.pythonhosted.org/packages/f8/6a/01e42058e4c86832a1b86c1a7b045f17ef01f55cd08b76f70628ebab9f54/freestream-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1a257aa6274a57fe07c87b56bc7e3bc8", "sha256": "e739582d74dd377b2495af494bbfddbeaf0005d88a805e51e2fc0fbdcaaae290"}, "downloads": -1, "filename": "freestream-1.0.1.tar.gz", "has_sig": false, "md5_digest": "1a257aa6274a57fe07c87b56bc7e3bc8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10256, "upload_time": "2016-08-23T19:14:35", "upload_time_iso_8601": "2016-08-23T19:14:35.355468Z", "url": "https://files.pythonhosted.org/packages/f8/6a/01e42058e4c86832a1b86c1a7b045f17ef01f55cd08b76f70628ebab9f54/freestream-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:00:28 2020"}