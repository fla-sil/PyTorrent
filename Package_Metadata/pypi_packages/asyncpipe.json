{"info": {"author": "Jacob Beck", "author_email": "pypi@jacob.ebeck.io", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: POSIX", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "## asyncpipe\n\nThis is a little module to help you chain together subprocess pipelines, a bit\nmore nicely than python natively lets you. The key element here is the support\nfor asyncio.\n\n### OS Compatibility\n\nThis will only work on versions of python that support async/await syntax\nI've only tested this on Linux. I don't see any reason why it wouldn't work on\nOSX/BSD, but it's possible. I doubt this works on Windows at all.\n\n### Python compatibility\n\nThis requires 'async' and 'await' keywords, so Python 3.5+ only.\n\n#### Motivation\n\nWhen you use a `PIPE` for stdout in the native asyncio.subprocess module, you\ndon't get back a value that can be passed to another Popen like you do in the\nsubprocess module. Instead you get a wrapper. Sometimes you can resolve that by\njust using the 'shell' execution model, but sometimes that's not a great fit.\n\nThe solution is to do an error-prone set of operations with os.pipe and linking\nup various subprocesses stdin/stdout. This gets especially ugly when you've got\na chain of 3+ shell commands.\n\n\n### Use\n\n#### Synchronous\n\nThe synchronous form is pretty straightforward:\n\n\timport asyncpipe\n\tpipe = asyncpipe.PipeBuilder('ls')\n\t# you can chain it\n\tpipe.chain('grep', '^S')\n\t# or use the 'or' operator\n\tpipe | 'wc -l'\n\tresults = pipe.call()\n\tmatches = int(results[-1].stdout.strip())\n\nAll of those return the underlying object, and the starting arguments are\noptional, so this is equivalent:\n\n\timport asyncpipe\n\tpipe = asyncpipe.PipeBuilder().chain('ls') | 'grep ^s' | ['wc' '-l']\n\tresults = pipe.call()\n\tmatches = int(results[-1].stdout.strip())\n\n\n#### Asyncronous\n\nAsync code is similar, except you need to pass the event loop as the 'loop'\nvalue to the PipeBuilder, or set it any time before calling `call_async()`:\n\n\timport asyncpipe\n\timport asyncio\n    loop = asyncio.new_event_loop()\n    # if you don't do this, you will get errors from asyncio \n    asyncio.set_event_loop(loop)\n\tpipe = asyncpipe.PipeBuilder(loop=loop)\n\tpipe.chain('ls') | 'grep ^s' | ['wc' '-l']\n\tresults = loop.run_until_complete(pipe.call_async())\n\tmatches = int(results[-1].stdout.strip())\n\nIf you were doing more in your event loop, you would of course just\n`await pipe.call_async()`!\n\n\n\n\n\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/beckjake/asyncpipe", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "asyncpipe", "package_url": "https://pypi.org/project/asyncpipe/", "platform": "", "project_url": "https://pypi.org/project/asyncpipe/", "project_urls": {"Homepage": "https://github.com/beckjake/asyncpipe"}, "release_url": "https://pypi.org/project/asyncpipe/0.0.1/", "requires_dist": null, "requires_python": "~=3.5", "summary": "An async-compatible library for composing Python shell pipelines", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h2>asyncpipe</h2>\n<p>This is a little module to help you chain together subprocess pipelines, a bit\nmore nicely than python natively lets you. The key element here is the support\nfor asyncio.</p>\n<h3>OS Compatibility</h3>\n<p>This will only work on versions of python that support async/await syntax\nI've only tested this on Linux. I don't see any reason why it wouldn't work on\nOSX/BSD, but it's possible. I doubt this works on Windows at all.</p>\n<h3>Python compatibility</h3>\n<p>This requires 'async' and 'await' keywords, so Python 3.5+ only.</p>\n<h4>Motivation</h4>\n<p>When you use a <code>PIPE</code> for stdout in the native asyncio.subprocess module, you\ndon't get back a value that can be passed to another Popen like you do in the\nsubprocess module. Instead you get a wrapper. Sometimes you can resolve that by\njust using the 'shell' execution model, but sometimes that's not a great fit.</p>\n<p>The solution is to do an error-prone set of operations with os.pipe and linking\nup various subprocesses stdin/stdout. This gets especially ugly when you've got\na chain of 3+ shell commands.</p>\n<h3>Use</h3>\n<h4>Synchronous</h4>\n<p>The synchronous form is pretty straightforward:</p>\n<pre><code>import asyncpipe\npipe = asyncpipe.PipeBuilder('ls')\n# you can chain it\npipe.chain('grep', '^S')\n# or use the 'or' operator\npipe | 'wc -l'\nresults = pipe.call()\nmatches = int(results[-1].stdout.strip())\n</code></pre>\n<p>All of those return the underlying object, and the starting arguments are\noptional, so this is equivalent:</p>\n<pre><code>import asyncpipe\npipe = asyncpipe.PipeBuilder().chain('ls') | 'grep ^s' | ['wc' '-l']\nresults = pipe.call()\nmatches = int(results[-1].stdout.strip())\n</code></pre>\n<h4>Asyncronous</h4>\n<p>Async code is similar, except you need to pass the event loop as the 'loop'\nvalue to the PipeBuilder, or set it any time before calling <code>call_async()</code>:</p>\n<pre><code>import asyncpipe\nimport asyncio\nloop = asyncio.new_event_loop()\n# if you don't do this, you will get errors from asyncio \nasyncio.set_event_loop(loop)\npipe = asyncpipe.PipeBuilder(loop=loop)\npipe.chain('ls') | 'grep ^s' | ['wc' '-l']\nresults = loop.run_until_complete(pipe.call_async())\nmatches = int(results[-1].stdout.strip())\n</code></pre>\n<p>If you were doing more in your event loop, you would of course just\n<code>await pipe.call_async()</code>!</p>\n\n          </div>"}, "last_serial": 4362177, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "e3f95c2e3cfe7e958995345f305f406d", "sha256": "ae5a3fd1b644cc05c84447d91a80687ff177cafece31de1749246927602a44c7"}, "downloads": -1, "filename": "asyncpipe-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "e3f95c2e3cfe7e958995345f305f406d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": "~=3.5", "size": 4184, "upload_time": "2018-10-11T00:39:39", "upload_time_iso_8601": "2018-10-11T00:39:39.723360Z", "url": "https://files.pythonhosted.org/packages/55/cf/b4311680fe02eaf79caa02b58bc0254169e9761c146148bc1cbbe84f4eae/asyncpipe-0.0.1-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e3f95c2e3cfe7e958995345f305f406d", "sha256": "ae5a3fd1b644cc05c84447d91a80687ff177cafece31de1749246927602a44c7"}, "downloads": -1, "filename": "asyncpipe-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "e3f95c2e3cfe7e958995345f305f406d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": "~=3.5", "size": 4184, "upload_time": "2018-10-11T00:39:39", "upload_time_iso_8601": "2018-10-11T00:39:39.723360Z", "url": "https://files.pythonhosted.org/packages/55/cf/b4311680fe02eaf79caa02b58bc0254169e9761c146148bc1cbbe84f4eae/asyncpipe-0.0.1-py3-none-any.whl", "yanked": false}], "timestamp": "Thu May  7 18:16:42 2020"}