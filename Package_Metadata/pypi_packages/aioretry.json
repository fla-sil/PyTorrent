{"info": {"author": "Kael Zhang", "author_email": "i+pypi@kael.me", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "[![](https://travis-ci.org/kaelzhang/python-aioretry.svg?branch=master)](https://travis-ci.org/kaelzhang/python-aioretry)\n[![](https://codecov.io/gh/kaelzhang/python-aioretry/branch/master/graph/badge.svg)](https://codecov.io/gh/kaelzhang/python-aioretry)\n[![](https://img.shields.io/pypi/v/aioretry.svg)](https://pypi.org/project/aioretry/)\n[![](https://img.shields.io/pypi/l/aioretry.svg)](https://github.com/kaelzhang/python-aioretry)\n\n# aioretry\n\nAsyncio retry utility for Python 3.7+\n\n## Install\n\n```sh\n$ pip install aioretry\n```\n\n## Usage\n\n```py\nimport asyncio\nfrom typing import (\n  Tuple\n)\n\nfrom aioretry import retry\n\n\ndef retry_policy(fails: int) -> Tuple[bool, float]:\n    # - It will always retry until succeeded\n    # - If fails for the first time, it will retry immediately,\n    # - If it fails again,\n    #   aioretry will perform a 100ms delay before the second retry,\n    #   200ms delay before the 3rd retry,\n    #   the 4th retry immediately,\n    #   100ms delay before the 5th retry,\n    #   etc...\n    return False, (fails - 1) % 3 * 0.1\n\n\n@retry(retry_policy)\nasync def connect_to_server():\n    # connec to server\n    ...\n\nasyncio.run(connect_to_server())\n```\n\n### Use as class instance method decorator\n\nWe could also use `retry` as a decorator for instance method\n\n```py\nclass Client:\n    @retry(retry_policy)\n    async def connect(self):\n        await self._connect()\n\nasyncio.run(Client().connect())\n```\n\n### Use instance method as retry policy\n\n`retry_policy` could be the method name of the class if `retry` is used as a decorator for instance method.\n\n```py\nclass ClientWithConfigurableRetryPolicy(Client):\n    def __init__(self, max_retries: int = 3):\n        self._max_retries = max_retries\n\n    def _retry_policy(self, fails: int) -> Tuple[bool, float]:\n        return fails > self._max_retries, fails * 0.1\n\n    # Then aioretry will use `self._retry_policy` as the retry policy.\n    # And by using a str as the parameter `retry_policy`,\n    # the decorator must be used for instance methods\n    @retry('_retry_policy')\n    async def connect(self):\n        await self._connect()\n\nasyncio.run(ClientWithConfigurableRetryPolicy(10).connect())\n```\n\n### Register an `after_failure` callback\n\nWe could also register an `after_failure` callback which will be executed after every failure of the target function if the corresponding retry is not abandoned.\n\n```py\nclass ClientTrackableFailures(ClientWithConfigurableRetryPolicy):\n    # `after_failure` could either be a sync function or an async function\n    async def _on_failure(self, error: Exception, fails: int) -> None:\n        await self._send_failure_log(error, fails)\n\n    @retry(\n      retry_policy='_retry_policy',\n\n      # Similar to `retry_policy`,\n      # `after_failure` could either be a Callable or a str\n      after_failure='_on_failture'\n    )\n    async def connect(self):\n        await self._connect()\n```\n\n\n## APIs\n\n### retry(retry_policy, after_failure)(fn)\n\n- **fn** `Callable[[...], Awaitable]` the function to be wrapped. The function should be an async function or normal function returns an awaitable.\n- **retry_policy** `Union[str, RetryPolicy]`\n- **after_failure?** `Optional[Union[str, Callable[[Exception, int], Optional[Awaitable]]]]` If specified, `after_failure` is called after each failture of `fn` and before the corresponding retry. If the retry is abandoned, `after_failture` will not be executed.\n\nReturns a wrapped function which accepts the same arguments as `fn` and returns an `Awaitable`.\n\n### RetryPolicy\n\n```py\nRetryPolicy = Callable[[int], Tuple[bool, Union[float, int]]]\n```\n\nRetry policy is used to determine what to do next after the `fn` fails to do some certain thing.\n\n```py\nabandon, delay = retry_policy(retries)\n```\n\n- `fails` is the counter number of how many times function `fn` performs as a failure. If `fn` fails for the first time, then `fails` will be `1`\n- If `abandon` is `True`, then aioretry will give up the retry and raise the exception directly, otherwise aioretry will sleep `delay` seconds (`asyncio.sleep(delay)`) before the next retry.\n\n## License\n\n[MIT](LICENSE)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kaelzhang/python-aioretry", "keywords": "aioretry", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "aioretry", "package_url": "https://pypi.org/project/aioretry/", "platform": "", "project_url": "https://pypi.org/project/aioretry/", "project_urls": {"Homepage": "https://github.com/kaelzhang/python-aioretry"}, "release_url": "https://pypi.org/project/aioretry/1.2.0/", "requires_dist": null, "requires_python": ">=3.7", "summary": "Asyncio retry utility for Python 3.7+", "version": "1.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/kaelzhang/python-aioretry\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5a411c0d4d425222583278bee126fc7005aade08/68747470733a2f2f7472617669732d63692e6f72672f6b61656c7a68616e672f707974686f6e2d61696f72657472792e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/kaelzhang/python-aioretry\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/130266e34aee989e13696422226e7255094294ab/68747470733a2f2f636f6465636f762e696f2f67682f6b61656c7a68616e672f707974686f6e2d61696f72657472792f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://pypi.org/project/aioretry/\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/adcc5f33a2888c7f043fda6cabb9d0576a972215/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f61696f72657472792e737667\"></a>\n<a href=\"https://github.com/kaelzhang/python-aioretry\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ed14a39eb19c963f473c219fb978720d39368ea9/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f61696f72657472792e737667\"></a></p>\n<h1>aioretry</h1>\n<p>Asyncio retry utility for Python 3.7+</p>\n<h2>Install</h2>\n<pre>$ pip install aioretry\n</pre>\n<h2>Usage</h2>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">typing</span> <span class=\"kn\">import</span> <span class=\"p\">(</span>\n  <span class=\"n\">Tuple</span>\n<span class=\"p\">)</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">aioretry</span> <span class=\"kn\">import</span> <span class=\"n\">retry</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">retry_policy</span><span class=\"p\">(</span><span class=\"n\">fails</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]:</span>\n    <span class=\"c1\"># - It will always retry until succeeded</span>\n    <span class=\"c1\"># - If fails for the first time, it will retry immediately,</span>\n    <span class=\"c1\"># - If it fails again,</span>\n    <span class=\"c1\">#   aioretry will perform a 100ms delay before the second retry,</span>\n    <span class=\"c1\">#   200ms delay before the 3rd retry,</span>\n    <span class=\"c1\">#   the 4th retry immediately,</span>\n    <span class=\"c1\">#   100ms delay before the 5th retry,</span>\n    <span class=\"c1\">#   etc...</span>\n    <span class=\"k\">return</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">fails</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"mi\">3</span> <span class=\"o\">*</span> <span class=\"mf\">0.1</span>\n\n\n<span class=\"nd\">@retry</span><span class=\"p\">(</span><span class=\"n\">retry_policy</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">connect_to_server</span><span class=\"p\">():</span>\n    <span class=\"c1\"># connec to server</span>\n    <span class=\"o\">...</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">connect_to_server</span><span class=\"p\">())</span>\n</pre>\n<h3>Use as class instance method decorator</h3>\n<p>We could also use <code>retry</code> as a decorator for instance method</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Client</span><span class=\"p\">:</span>\n    <span class=\"nd\">@retry</span><span class=\"p\">(</span><span class=\"n\">retry_policy</span><span class=\"p\">)</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_connect</span><span class=\"p\">()</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">Client</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">())</span>\n</pre>\n<h3>Use instance method as retry policy</h3>\n<p><code>retry_policy</code> could be the method name of the class if <code>retry</code> is used as a decorator for instance method.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">ClientWithConfigurableRetryPolicy</span><span class=\"p\">(</span><span class=\"n\">Client</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">max_retries</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_max_retries</span> <span class=\"o\">=</span> <span class=\"n\">max_retries</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_retry_policy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">fails</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]:</span>\n        <span class=\"k\">return</span> <span class=\"n\">fails</span> <span class=\"o\">&gt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_max_retries</span><span class=\"p\">,</span> <span class=\"n\">fails</span> <span class=\"o\">*</span> <span class=\"mf\">0.1</span>\n\n    <span class=\"c1\"># Then aioretry will use `self._retry_policy` as the retry policy.</span>\n    <span class=\"c1\"># And by using a str as the parameter `retry_policy`,</span>\n    <span class=\"c1\"># the decorator must be used for instance methods</span>\n    <span class=\"nd\">@retry</span><span class=\"p\">(</span><span class=\"s1\">'_retry_policy'</span><span class=\"p\">)</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_connect</span><span class=\"p\">()</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">ClientWithConfigurableRetryPolicy</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">())</span>\n</pre>\n<h3>Register an <code>after_failure</code> callback</h3>\n<p>We could also register an <code>after_failure</code> callback which will be executed after every failure of the target function if the corresponding retry is not abandoned.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">ClientTrackableFailures</span><span class=\"p\">(</span><span class=\"n\">ClientWithConfigurableRetryPolicy</span><span class=\"p\">):</span>\n    <span class=\"c1\"># `after_failure` could either be a sync function or an async function</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">_on_failure</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">:</span> <span class=\"ne\">Exception</span><span class=\"p\">,</span> <span class=\"n\">fails</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_send_failure_log</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">fails</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@retry</span><span class=\"p\">(</span>\n      <span class=\"n\">retry_policy</span><span class=\"o\">=</span><span class=\"s1\">'_retry_policy'</span><span class=\"p\">,</span>\n\n      <span class=\"c1\"># Similar to `retry_policy`,</span>\n      <span class=\"c1\"># `after_failure` could either be a Callable or a str</span>\n      <span class=\"n\">after_failure</span><span class=\"o\">=</span><span class=\"s1\">'_on_failture'</span>\n    <span class=\"p\">)</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_connect</span><span class=\"p\">()</span>\n</pre>\n<h2>APIs</h2>\n<h3>retry(retry_policy, after_failure)(fn)</h3>\n<ul>\n<li><strong>fn</strong> <code>Callable[[...], Awaitable]</code> the function to be wrapped. The function should be an async function or normal function returns an awaitable.</li>\n<li><strong>retry_policy</strong> <code>Union[str, RetryPolicy]</code></li>\n<li><strong>after_failure?</strong> <code>Optional[Union[str, Callable[[Exception, int], Optional[Awaitable]]]]</code> If specified, <code>after_failure</code> is called after each failture of <code>fn</code> and before the corresponding retry. If the retry is abandoned, <code>after_failture</code> will not be executed.</li>\n</ul>\n<p>Returns a wrapped function which accepts the same arguments as <code>fn</code> and returns an <code>Awaitable</code>.</p>\n<h3>RetryPolicy</h3>\n<pre><span class=\"n\">RetryPolicy</span> <span class=\"o\">=</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>\n</pre>\n<p>Retry policy is used to determine what to do next after the <code>fn</code> fails to do some certain thing.</p>\n<pre><span class=\"n\">abandon</span><span class=\"p\">,</span> <span class=\"n\">delay</span> <span class=\"o\">=</span> <span class=\"n\">retry_policy</span><span class=\"p\">(</span><span class=\"n\">retries</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>fails</code> is the counter number of how many times function <code>fn</code> performs as a failure. If <code>fn</code> fails for the first time, then <code>fails</code> will be <code>1</code></li>\n<li>If <code>abandon</code> is <code>True</code>, then aioretry will give up the retry and raise the exception directly, otherwise aioretry will sleep <code>delay</code> seconds (<code>asyncio.sleep(delay)</code>) before the next retry.</li>\n</ul>\n<h2>License</h2>\n<p><a href=\"LICENSE\" rel=\"nofollow\">MIT</a></p>\n\n          </div>"}, "last_serial": 7054778, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "62624ce4744db6a80864eb28b46d6aec", "sha256": "58d6cd308a5f9a8f90a030f6e0dd437dc479d7fbc68ded26b5953df5f1f5d320"}, "downloads": -1, "filename": "aioretry-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "62624ce4744db6a80864eb28b46d6aec", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4681, "upload_time": "2020-04-19T16:09:36", "upload_time_iso_8601": "2020-04-19T16:09:36.930716Z", "url": "https://files.pythonhosted.org/packages/c5/ac/995d46d90e7e75cd2eb935638b9b67462ea0c267892c1eda6655623e9a73/aioretry-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e6a35397d55b926fe403db6fcb1778fe", "sha256": "a747686e8a1be5999e2f22d881da7f747388381b899d3c961a64103609aade0a"}, "downloads": -1, "filename": "aioretry-1.0.0.tar.gz", "has_sig": false, "md5_digest": "e6a35397d55b926fe403db6fcb1778fe", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4614, "upload_time": "2020-04-19T16:09:40", "upload_time_iso_8601": "2020-04-19T16:09:40.828325Z", "url": "https://files.pythonhosted.org/packages/65/8b/35b1e99e053135ab04d072ecc2c843d0cded76f1860a390457e1e88679e5/aioretry-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "87cad169de8edd4268fb768c256ae72b", "sha256": "f9f5293b4ec26e18d6a1169e984035c8da96c738258baf0cbb203aee3a4686db"}, "downloads": -1, "filename": "aioretry-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "87cad169de8edd4268fb768c256ae72b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4700, "upload_time": "2020-04-19T16:17:23", "upload_time_iso_8601": "2020-04-19T16:17:23.488349Z", "url": "https://files.pythonhosted.org/packages/0f/b6/7d1617ee4d3cc700df0b34cc6fbbe6a4cf129977181e64a1228b2aeb1edb/aioretry-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "198dad9fb78d6822b05616a69faf201c", "sha256": "cd13c267c9bb116f7659b6941cdb8489d21ca30bcb920127f81b39f76902bf83"}, "downloads": -1, "filename": "aioretry-1.0.1.tar.gz", "has_sig": false, "md5_digest": "198dad9fb78d6822b05616a69faf201c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4633, "upload_time": "2020-04-19T16:17:25", "upload_time_iso_8601": "2020-04-19T16:17:25.316415Z", "url": "https://files.pythonhosted.org/packages/cd/f5/b29aaab8206af0d7707483470e3a9a15e1a5ff2b0d387a960568bfcb0408/aioretry-1.0.1.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "ea06def0a6c3c05c9800aeacae579770", "sha256": "0d112900b87c03b89d45199a1ae93de4299ad7c353175085fec7c189d7b3d203"}, "downloads": -1, "filename": "aioretry-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "ea06def0a6c3c05c9800aeacae579770", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4721, "upload_time": "2020-04-19T16:23:45", "upload_time_iso_8601": "2020-04-19T16:23:45.176358Z", "url": "https://files.pythonhosted.org/packages/28/02/13b0e5dbb90e9d97e6febd1b2d42248bd10a47e78cc763db77433b9cd5a4/aioretry-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2a6e1c56cd3539c4d9ae4b0590d7b0c9", "sha256": "9189ef2cbb3af27f99109065f6238bb1fca896de2ac06f135846f9547ab60559"}, "downloads": -1, "filename": "aioretry-1.1.0.tar.gz", "has_sig": false, "md5_digest": "2a6e1c56cd3539c4d9ae4b0590d7b0c9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4647, "upload_time": "2020-04-19T16:23:46", "upload_time_iso_8601": "2020-04-19T16:23:46.819263Z", "url": "https://files.pythonhosted.org/packages/b0/a8/ed2145470f8e3dc7b88df43260acba5558da4c201bd7aef72e7af9788698/aioretry-1.1.0.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "1fd28154149ec2657c99135514093848", "sha256": "97786b4472d61ee8b6a97d9c8af96896290c28dd736c60e0a0bbcf401bd0aa02"}, "downloads": -1, "filename": "aioretry-1.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1fd28154149ec2657c99135514093848", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4708, "upload_time": "2020-04-19T16:30:39", "upload_time_iso_8601": "2020-04-19T16:30:39.641678Z", "url": "https://files.pythonhosted.org/packages/38/42/c76c6fefb6b8b133f7c9ae43406e474aa6f2d23089c2e460df95f27d5202/aioretry-1.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0b36a6c50928891bef91db4e9b950a69", "sha256": "06bd14d486c16d27e6cbb95bc56167ca218d5a607027df91b80e60c316113d42"}, "downloads": -1, "filename": "aioretry-1.2.0.tar.gz", "has_sig": false, "md5_digest": "0b36a6c50928891bef91db4e9b950a69", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4613, "upload_time": "2020-04-19T16:30:42", "upload_time_iso_8601": "2020-04-19T16:30:42.411589Z", "url": "https://files.pythonhosted.org/packages/0c/36/e515fe24782b9fccae58e05f25b8e97a42ab125ce424158c831950a3cb63/aioretry-1.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1fd28154149ec2657c99135514093848", "sha256": "97786b4472d61ee8b6a97d9c8af96896290c28dd736c60e0a0bbcf401bd0aa02"}, "downloads": -1, "filename": "aioretry-1.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1fd28154149ec2657c99135514093848", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4708, "upload_time": "2020-04-19T16:30:39", "upload_time_iso_8601": "2020-04-19T16:30:39.641678Z", "url": "https://files.pythonhosted.org/packages/38/42/c76c6fefb6b8b133f7c9ae43406e474aa6f2d23089c2e460df95f27d5202/aioretry-1.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0b36a6c50928891bef91db4e9b950a69", "sha256": "06bd14d486c16d27e6cbb95bc56167ca218d5a607027df91b80e60c316113d42"}, "downloads": -1, "filename": "aioretry-1.2.0.tar.gz", "has_sig": false, "md5_digest": "0b36a6c50928891bef91db4e9b950a69", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4613, "upload_time": "2020-04-19T16:30:42", "upload_time_iso_8601": "2020-04-19T16:30:42.411589Z", "url": "https://files.pythonhosted.org/packages/0c/36/e515fe24782b9fccae58e05f25b8e97a42ab125ce424158c831950a3cb63/aioretry-1.2.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:20:51 2020"}