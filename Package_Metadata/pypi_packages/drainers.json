{"info": {"author": "Vincent Driessen", "author_email": "vincent@datafox.nl", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Operating System :: POSIX", "Programming Language :: Python", "Programming Language :: Python :: 2.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "===================================================\n drainers - Event-based draining of process output\n===================================================\n\ndrainers is an abstraction around `subprocess.Popen` to read and control\nprocess output event-wise.  It also allows you to abort running processes\neither gracefully or forcefully without having to directly interact with the\nprocesses or threads themself.\n\nOverview\n========\n\nDefining a process\n------------------\nA `Drainer` is a factory and controller wrapper around\n`subprocess.Popen` and therefore takes all of the (optional) parameters\nthat `subprocess.Popen`'s initializer takes.  For example, the minimal\n`Drainer` takes a command array::\n\n\tfrom drainers import Drainer\n\n\tdef ignore_event(line, is_err):\n\t\tpass\n\n\tmy_drainer = Drainer(['ls', '-la'], read_event_cb=ignore_event)\n\tmy_drainer.start()\n\nBut, extra arguments are allowed, too::\n\n\tmy_drainer = Drainer(['echo', '$JAVA_HOME'], shell=True, bufsize=64,\n\t\t\t\t\t\t read_event_cb=ignore_event)\n\tmy_drainer.start()\n\nThe only two arguments to `Drainer` that are reserved are\n`stdout` and `stderr`.  `Drainer` requires them to be\n`subprocess.PIPE` explicitly, and sets them for you accordingly.\n\nDefining a callback\n-------------------\n`Drainer`'s strength lies in the fact that each line that is read from the\nprocess' standard output or standard error streams leads to a callback\nfunction being invoked.  This allows you to process virtually any process'\noutput, as long as it's line-based.\n\nThe callback function can be specified using the `read_event_cb` parameter to\nthe constructor, as seen in the example above.  It is mandatory.  The callback\nfunction specified needs to have a specific signature::\n\n\tdef my_callback(line, is_err):\n\t\t...\n\nIt should take two parameters: `line` (a string) and `is_err` (a boolean).\nThe latter indicates that the line is read from the standard error stream.\nThere is nothing more to it.  It does not need to return anything: it's return\nvalue will be ignored.  Your callback may be a class method, too, like in the\nfollowing example.  Notice that in those cases, you pass `foo.my_method` as\nthe value for the `read_event_cb` parameter::\n\n\tclass MyClass(object):\n\n\t\tdef my_method(self, line, is_err):\n\t\t\t...\n\t\n\tfoo = MyClass()\n\tmy_drainer = Drainer(['ls'], read_event_cb=foo.my_method)\n\tmy_drainer.start()\n\nThe granularity currently is a single line.  If you want to read predefined\nchunks (lines) of data, use `BufferedDrainer` instead.  See\nexamples/buffer_results.py for an example.\n\nAborting processes\n------------------\n`Drainer` allows you to abort a running process in the middle of execution,\nforcefully sending the process a `terminate()` message (Python equivalent of a\nUnix `SIGTERM` message) when a certain condition arises.  By default, the\nprocess will never be terminated abnormally.  To specify termination criteria,\nimplement a callback function that takes no parameters and returns `True` if\nabortion is desired and `False` otherwise.  For example, for a long running\nprocess you might want to terminate it if the disk is getting (almost) full.\nBut checking how much space is free can be a lengthy operation, so you might\nwant to do it only sparingly::\n\n\tdef out_of_diskspace():\n\t\tleft = handytools.check_disk_free()\n\t\ttotal = handytools.check_disk_total()\n\t\treturn (left / total) < 0.03\n\n\t# The following drainer executes the cruncher and checks whether the disk\n\t# is (almost) full every 5 seconds.  It aborts if free disk space runs\n\t# under 3%.\n\tmy_drainer = Drainer(['/bin/crunch', 'inputfile', 'outputfile'],\n\t                     read_event_cb=ignore_event,\n\t\t\t\t\t\t should_abort=out_of_diskspace,\n\t\t\t\t\t\t check_interval=5.0)\n\texitcode = my_drainer.start()\n\nThe example is pretty self-explaining.  You can check the exitcode to see the\nresult of the process.\n\n\nMore examples\n=============\nSee the `examples` directory for more detailed examples.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/nvie/python-drainers/", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "drainers", "package_url": "https://pypi.org/project/drainers/", "platform": "any", "project_url": "https://pypi.org/project/drainers/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/nvie/python-drainers/"}, "release_url": "https://pypi.org/project/drainers/0.0.3/", "requires_dist": null, "requires_python": null, "summary": "Event-based draining of process output", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>drainers is an abstraction around <cite>subprocess.Popen</cite> to read and control\nprocess output event-wise.  It also allows you to abort running processes\neither gracefully or forcefully without having to directly interact with the\nprocesses or threads themself.</p>\n<div id=\"overview\">\n<h2>Overview</h2>\n<div id=\"defining-a-process\">\n<h3>Defining a process</h3>\n<p>A <cite>Drainer</cite> is a factory and controller wrapper around\n<cite>subprocess.Popen</cite> and therefore takes all of the (optional) parameters\nthat <cite>subprocess.Popen</cite>\u2019s initializer takes.  For example, the minimal\n<cite>Drainer</cite> takes a command array:</p>\n<pre>from drainers import Drainer\n\ndef ignore_event(line, is_err):\n        pass\n\nmy_drainer = Drainer(['ls', '-la'], read_event_cb=ignore_event)\nmy_drainer.start()\n</pre>\n<p>But, extra arguments are allowed, too:</p>\n<pre>my_drainer = Drainer(['echo', '$JAVA_HOME'], shell=True, bufsize=64,\n                                         read_event_cb=ignore_event)\nmy_drainer.start()\n</pre>\n<p>The only two arguments to <cite>Drainer</cite> that are reserved are\n<cite>stdout</cite> and <cite>stderr</cite>.  <cite>Drainer</cite> requires them to be\n<cite>subprocess.PIPE</cite> explicitly, and sets them for you accordingly.</p>\n</div>\n<div id=\"defining-a-callback\">\n<h3>Defining a callback</h3>\n<p><cite>Drainer</cite>\u2019s strength lies in the fact that each line that is read from the\nprocess\u2019 standard output or standard error streams leads to a callback\nfunction being invoked.  This allows you to process virtually any process\u2019\noutput, as long as it\u2019s line-based.</p>\n<p>The callback function can be specified using the <cite>read_event_cb</cite> parameter to\nthe constructor, as seen in the example above.  It is mandatory.  The callback\nfunction specified needs to have a specific signature:</p>\n<pre>def my_callback(line, is_err):\n        ...\n</pre>\n<p>It should take two parameters: <cite>line</cite> (a string) and <cite>is_err</cite> (a boolean).\nThe latter indicates that the line is read from the standard error stream.\nThere is nothing more to it.  It does not need to return anything: it\u2019s return\nvalue will be ignored.  Your callback may be a class method, too, like in the\nfollowing example.  Notice that in those cases, you pass <cite>foo.my_method</cite> as\nthe value for the <cite>read_event_cb</cite> parameter:</p>\n<pre>class MyClass(object):\n\n        def my_method(self, line, is_err):\n                ...\n\nfoo = MyClass()\nmy_drainer = Drainer(['ls'], read_event_cb=foo.my_method)\nmy_drainer.start()\n</pre>\n<p>The granularity currently is a single line.  If you want to read predefined\nchunks (lines) of data, use <cite>BufferedDrainer</cite> instead.  See\nexamples/buffer_results.py for an example.</p>\n</div>\n<div id=\"aborting-processes\">\n<h3>Aborting processes</h3>\n<p><cite>Drainer</cite> allows you to abort a running process in the middle of execution,\nforcefully sending the process a <cite>terminate()</cite> message (Python equivalent of a\nUnix <cite>SIGTERM</cite> message) when a certain condition arises.  By default, the\nprocess will never be terminated abnormally.  To specify termination criteria,\nimplement a callback function that takes no parameters and returns <cite>True</cite> if\nabortion is desired and <cite>False</cite> otherwise.  For example, for a long running\nprocess you might want to terminate it if the disk is getting (almost) full.\nBut checking how much space is free can be a lengthy operation, so you might\nwant to do it only sparingly:</p>\n<pre>def out_of_diskspace():\n        left = handytools.check_disk_free()\n        total = handytools.check_disk_total()\n        return (left / total) &lt; 0.03\n\n# The following drainer executes the cruncher and checks whether the disk\n# is (almost) full every 5 seconds.  It aborts if free disk space runs\n# under 3%.\nmy_drainer = Drainer(['/bin/crunch', 'inputfile', 'outputfile'],\n                     read_event_cb=ignore_event,\n                                         should_abort=out_of_diskspace,\n                                         check_interval=5.0)\nexitcode = my_drainer.start()\n</pre>\n<p>The example is pretty self-explaining.  You can check the exitcode to see the\nresult of the process.</p>\n</div>\n</div>\n<div id=\"more-examples\">\n<h2>More examples</h2>\n<p>See the <cite>examples</cite> directory for more detailed examples.</p>\n</div>\n\n          </div>"}, "last_serial": 663295, "releases": {"0.0.1": [], "0.0.2": [], "0.0.3": [{"comment_text": "", "digests": {"md5": "bf61d5c553d16c9b87ef9d2b035a3015", "sha256": "813fc8725567e0e7fffe1554b33d856bd75f7c86995f1253e1a10688a6a40d5c"}, "downloads": -1, "filename": "drainers-0.0.3.tar.gz", "has_sig": false, "md5_digest": "bf61d5c553d16c9b87ef9d2b035a3015", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8987, "upload_time": "2010-06-04T16:27:28", "upload_time_iso_8601": "2010-06-04T16:27:28.471650Z", "url": "https://files.pythonhosted.org/packages/22/da/c6d10618a9b5baf6c466b0def4b3b3d79203c6075ad38fef4d33087ccb53/drainers-0.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bf61d5c553d16c9b87ef9d2b035a3015", "sha256": "813fc8725567e0e7fffe1554b33d856bd75f7c86995f1253e1a10688a6a40d5c"}, "downloads": -1, "filename": "drainers-0.0.3.tar.gz", "has_sig": false, "md5_digest": "bf61d5c553d16c9b87ef9d2b035a3015", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8987, "upload_time": "2010-06-04T16:27:28", "upload_time_iso_8601": "2010-06-04T16:27:28.471650Z", "url": "https://files.pythonhosted.org/packages/22/da/c6d10618a9b5baf6c466b0def4b3b3d79203c6075ad38fef4d33087ccb53/drainers-0.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:49:53 2020"}