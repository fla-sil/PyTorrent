{"info": {"author": "Bogdan Opanchuk", "author_email": "bg@bk.ru", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License (GPL)", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Database :: Front-Ends"], "description": "==========================================\nBrain - DDB-like front-end for SQL engines\n==========================================\n\n.. contents::\n\nIntroduction\n------------\n\nDocument databases may prove out to be more convenient than relational ones for programs\nthat operate with a large set of objects with different parameters. With document database\nyou do not need to develop the database scheme, just toss objects with complex structure\nto the database and retreive them by any search criteria. For example, this approach may\nbe useful for music players (store tracks/albums/artists as objects with cross-references\nand references to real files), project management software, bug tracking systems and so on.\n\nThis package is, in effect, a wrapper, which makes the relational database engine look\nlike DDB. Of course, this approach has its drawbacks - noticeable overhead and slow store/retreive\noperations. But it gives fast search, transaction support and all features of chosen relational\nDB engine (like DB server, secure access, replication and other stuff) for free. Plus, all DB engines\nare constantly improving without my attention - isn't it cool?\n\nThis package is in beta state now. You can find all planned tasks in todo.rst (not included in\ndistribution, get it from master branch). I will appreciate any comments and bug reports,\nfrom grammar and spelling errors in documentation to flaws in module architecture.\n\nQuick start\n-----------\n\nThis section will show only the simple usage examples. For exhaustive information please consult\nthe `Reference`_ entries for corresponding functions.\n\nBasic functions\n~~~~~~~~~~~~~~~\n\nFirst, import the module:\n\n >>> import brain\n\nThen we will need to connect to existing database or create the new one.\nIn this example we will use the default DB engine (sqlite3) and in-memory database.\nFirst None stands for so called \"engine tag\" (which identifies DB engine to use),\nand the second one stands for DB name (which is mandatory for sqlite3 engine).\n\n >>> conn = brain.connect(None, None)\n\nNow we can create some objects. Objects are identified by their IDs, which are\nintended to be opaque. The only thing that the end user should know is that they\ncan be stored in database too.\n\n >>> id1 = conn.create({'a': 1, 'b': 1.345})\n >>> id2 = conn.create({'id1': id1, 'list': [1, 2, 'some_value']})\n\nThese objects can be read from database:\n\n >>> data1 = conn.read(id1)\n >>> print(data1)\n {'a': 1, 'b': 1.345}\n >>> data2 = conn.read(id2)\n >>> print(data2)\n {'list': [1, 2, 'some_value'], 'id1': 1}\n\nYou can see that the object ID is, in fact, a simple integer. It is true for sqlite3 engine,\nbut each engine can use its own ID format.\n\nThe next function is `Connection.modify()`_; it allows us to change the contents of the object.\n\n >>> conn.modify(id1, ['a'], 2)\n >>> data1 = conn.read(id1)\n >>> print(data1)\n {'a': 2, 'b': 1.345}\n\nIts first argument is object ID, second one is is the `path`_ to some place inside object and\nthe third one is the value to store (can be either some simple type or data structure). Path\nis a list, whose elements can be strings, integers or Nones. String element corresponds to key\nin dictionary, integer to list index, and None to list mask.\n\nYou may have noticed that the second object contains a list. New elements can be added\nto list in two ways - either using `Connection.modify()`_ with path, specifying list index to create,\nor inserting new element to some place in list:\n\n >>> conn.modify(id2, ['list', 3], 3)\n >>> print(conn.read(id2))\n {'list': [1, 2, 'some_value', 3], 'id1': 1}\n >>> conn.insert(id2, ['list', 0], 4)\n >>> print(conn.read(id2))\n {'list': [4, 1, 2, 'some_value', 3], 'id1': 1}\n >>> conn.insert(id2, ['list', None], 5)\n >>> print(conn.read(id2))\n {'list': [4, 1, 2, 'some_value', 3, 5], 'id1': 1}\n\nFirst action creates the element with index 3 in list; note that it is expanded automatically.\nSecond action inserts the new element to the beginning of the list. Third action inserts\nthe new element to the end of the list.\n\nWe can now search for objects in database. For example, we want to find the object, which\nhas list under 'list' key in dictionary, which, in turn has the first element equal to 4.\n\n >>> import brain.op as op\n >>> objs = conn.search(['list', 0], op.EQ, 4)\n >>> print(objs == [id2])\n True\n\nSearch request supports nested conditions and several types of comparisons (including regexps).\nSee its reference page for more information.\n\nThe last basic function is `Connection.delete()`_. It can delete the whole objects, or its parts\n(dictionary keys or list elements).\n\n >>> print(conn.objectExists(id1))\n True\n >>> conn.delete(id1)\n >>> print(conn.objectExists(id1))\n False\n >>> conn.delete(id2, ['list'])\n >>> print(conn.read(id2))\n {'id1': 1}\n >>> conn.close()\n\nConnection should be closed using `Connection.close()`_ after it is not longer needed. In case of\nin-memory database, of course, all data will be lost after call to `Connection.close()`_.\n\nTransaction support\n~~~~~~~~~~~~~~~~~~~\n\nOne of the main advantages of using the developed SQL engine as a back-end is the\nACID compatibility. As a result, brain front-end has full transaction support too.\n\nIf transaction was not started explicitly, the new one is created and committed for\neach request (create, modify, insert and so on) implicitly. In case of some underlying\nerror, this transaction is rolled back, so the request cannot be completed partially.\n\nThere are two types of transactions - synchronous and asynchronous. During the\nsynchronous transaction you get request results instantly; during the asynchronous one\nrequests do not return any results - all results are returned by `Connection.commit()`_ as a list.\n\nLet's illustrate this by several simple examples. First, connect to database and\ncreate some objects.\n\n >>> import brain\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create({'a': 1, 'b': 2})\n >>> id2 = conn.create({'c': 3, 'd': 4})\n\nFor each of two `Connection.create()`_'s above transactions were started and committed implicitly\n(because there were not any active transactions at the moment). Now we will create synchronous\ntransaction explicitly:\n\n >>> conn.beginSync()\n >>> conn.modify(id1, ['a'], 10)\n >>> print(conn.read(id1))\n {'a': 10, 'b': 2}\n >>> conn.commit()\n >>> print(conn.read(id1))\n {'a': 10, 'b': 2}\n\nNote that during synchronous transaction modifications become visible instantly. Now\nconsider the similar operation inside a transaction, but this time we will roll it back:\n\n >>> conn.beginSync()\n >>> conn.modify(id1, ['a'], 20)\n >>> print(conn.read(id1))\n {'a': 20, 'b': 2}\n >>> conn.rollback()\n >>> print(conn.read(id1))\n {'a': 10, 'b': 2}\n\nLike in the previous example, modification instantly becomes visible, but after the rollback\nit is gone.\n\nAsynchronous transactions are slightly different. During the transaction requests will not\nreturn values, because they are not, in fact, executed - they are stored inside the connection\nobject and passed to DB engine in one single package when `Connection.commit()`_ is called. If the user\nchanges his mind and calls `Connection.rollback()`_, all this package is simply discarded.\n\n >>> conn.beginAsync()\n >>> conn.modify(id1, ['a'], 0)\n >>> conn.read(id1)\n >>> print(conn.commit())\n [None, {'a': 0, 'b': 2}]\n >>> conn.close()\n\nIn the example above there were two requests inside a transaction; first one, `Connection.modify()`_\ndoes not return anything, and the second one, `Connection.read()`_, returned object contents.\nTherefore `Connection.commit()`_ returned both their results as a list.\n\nXML RPC layer\n~~~~~~~~~~~~~\n\nBrain has embedded XML RPC server and client. First, we will create and start server:\n\n >>> import brain\n >>> srv = brain.Server()\n >>> srv.start()\n\nNow server is active on localhost, port 8000 (by default). It is executed in its own thread,\nso `start()`_ returns immediately. If you enter http://localhost:8000 in your browser, you\nwill get a page with list of functions the server supports.\n\nThen we should create the client - either in this session, in other process or even on\nthe other computer:\n\n >>> cl = brain.Client('http://localhost:8000')\n\nAnd client object gives us the ability to create connections. The format of its ``connect()``\nmethod is the same as for `brain.connect()`_:\n\n >>> conn = cl.connect(None, None)\n\nThis object behaves exactly the same as the `Connection`_ object returned by `brain.connect()`_.\nYou can try all examples from previous sections - they all should work. In the end you\nshould close the connection and stop server:\n\n >>> conn.close()\n >>> srv.stop()\n\nUnlike `start()`_, `stop()`_ waits for server to shut down.\n\nReference\n---------\n\nKnown limitations\n~~~~~~~~~~~~~~~~~\n\nValue limitations:\n * Currently the following Python types are supported: ``None``, ``int``, ``float``, ``str`` and ``bytes``.\n * Integers are limited to 8 bytes (by DB engines) and to 4 bytes by XML RPC protocol.\n\nStructure limitations:\n * Each object can contain arbitrarily combined values, lists and dictionaries.\n * Structure depth is not limited theoretically, but in practice it is - by DB engine.\n * Lists and dictionaries can be empty.\n * Dictionary keys should have string type.\n\n.. _paths:\n\nPath\n~~~~\n\nPath to some value in object is a list, which can contain only strings, integers and Nones.\nEmpty list means the root level of an object; string stands for dictionary key and integer\nstands for position in list. None is used in several special cases: to specify that\n`Connection.insert()`_ should perform insertion at the end of the list or as a mask for\n`Connection.delete()`_ and `Connection.read()`_.\n\nString elements must not contain uppercase symbols. This is done because each field name\ncorrespond to table name in underlying SQL engine, and some engines ignore case in table names.\nSo, in order to avoid later search errors, uppercase symbols in field names are simply not allowed -\n`FormatError`_ is thrown.\n\nIf path does not contain Nones, it is called *determined*.\n\n**Example**:\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create({'tracks': [{'name': 'track 1', 'length': 240},\n ... {'name': 'track 2', 'length': 300}]})\n >>> print(conn.read(id1, ['tracks', 0, 'name']))\n track 1\n >>> print(conn.readByMask(id1, ['tracks', None, 'length']))\n {'tracks': [{'length': 240}, {'length': 300}]}\n >>> conn.close()\n\n.. _FacadeError:\n\n.. _EngineError:\n\n.. _StructureError:\n\n.. _FormatError:\n\nExceptions\n~~~~~~~~~~\n\nFollowing exceptions can be thrown by API:\n\n ``brain.FacadeError``:\n   Signals about the error in high-level wrappers. Can be caused by incorrect\n   calls to `Connection.begin()`_ \\\\ `Connection.commit()`_ \\\\ `Connection.rollback()`_,\n   incorrect engine tag and so on.\n\n ``brain.EngineError``:\n   Signals about an error in DB engine wrapper.\n\n ``brain.StructureError``:\n   Signals about error in object/database structure - for example, conflicting fields.\n\n ``brain.FormatError``:\n   Wrong format of supplied data: path is not a list, or have elements of wrong type,\n   data has values of wrong type and so on.\n\nEngines\n~~~~~~~\n\nCurrently two engines are supported:\n\n**sqlite3**:\n  SQLite 3 engine, built in Python 3.\n\n  **Arguments**: ``(name, open_existing=None, db_path=None)``\n\n  ``name``:\n    Database file name. If equal to ``None``, in-memory database is created.\n\n  ``open_existing``:\n    Ignored if ``name`` is equal to None.\n\n    If equal to True, existing database file will be opened or `EngineError`_\n    will be raised if it does not exist.\n\n    If equal to False, new database file will be created (in place of the existing one, if\n    necessary)\n\n    If equal to None, existing database will be opened or the new one will be created, if\n    the database file does not exist.\n\n  ``db_path``:\n    If is not None, will be concatenated (using platform-specific path join) with ``name``\n\n**postgre**:\n  Postgre 8 engine. Will be used if `py-postgresql <http://python.projects.postgresql.org>`_\n  is installed.\n\n  **Arguments**: ``(name, open_existing=None, host='localhost', port=5432, user='postgres',\n  password='', connection_limit=-1)``\n\n  ``name``:\n    Database name.\n\n  ``open_existing``:\n    Same logic as for SQLite3 engine\n\n  ``host``:\n    Postgre server name\n\n  ``port``:\n    Postgre server port\n\n  ``user``, ``password``:\n    Credentials for connecting to Postgre server\n\n  ``connection_limit``:\n    Connection limit for newly created database. Unlimited by default.\n\nTests\n~~~~~\n\nThe package is supplied with a set of functionality tests which I use for debugging purposes.\nThey can be found in ``test`` subfolder of module main folder. Tests are executed using ``run.py``,\nwhich has the following parameters:\n\n``run.py <func|fuzz|doc|perf> [options]``\n\n``func``:\n  Functionality tests. They are based on Python's ``unittest`` module, with some minor extensions.\n  Currently they provide almost 100% coverage of package code.\n\n``fuzz``:\n  Several objects with random data are created and random actions (`Connection.modify()`_,\n  `Connection.insert()`_, `Connection.read()`_, `Connection.delete()`_) are performed on them.\n  After each action result is compared to   the result of ``FakeConnection``, which uses Python\n  data structures to emulate package behavior.\n\n``doc``:\n  Test examples in this documentation using Python's ``doctest`` module.\n\n``perf``:\n  Simple non-atomic performance tests (measuring times of ``func`` tests plus combining\n  results of ``fuzz`` tests with several predefined seeds).\n\n**global parameters**:\n  ``-v LEVEL``, ``--verbosity=LEVEL``:\n    Integer from 0 (less verbose) to 3 (more verbose), specifying the amount of information\n    which is displayed during tests. Default is 2.\n\n    For ``doc`` tests verbosity level 3 and above enables ``verbose=True`` mode (which means\n    that all tests will be shown); otherwise only errors will be shown.\n\n``func`` **parameters**:\n  ``--ae``, ``--all-engines``:\n    If specified, all available DB engines will be tested. If not specified, only the default\n    engine (see `getDefaultEngineTag()`_) will be tested.\n\n  ``--ac``, ``--all-connections``:\n    If specified, all available connections will be tested (local, XML RPC and so on). If\n    not specified, only local connection will be tested.\n\n  ``--as``, ``--all-storages``:\n    If specified, all storage types for each engine will be tested (for example, for sqlite3\n    available types are in-memory and file). If not specified, only the default storage for\n    each engine will be tested.\n\n``fuzz`` **parameters**:\n  ``-o NUM``, ``--objects=NUM``:\n    Number of object to be tested simultaneously. Default is 1.\n\n  ``-a NUM``, ``--actions=NUM``\n    Number of actions to be performed for one object. Default is 100.\n\n  ``-s SEED``, ``--seed=SEED``\n    Integer which will be used as starting seed for random number generator. This wil allow\n    to get reproduceable results. By default, random seed is generated.\n\n.. _connect():\n\nbrain.connect()\n~~~~~~~~~~~~~~~\n\nConnect to the database (or create the new one).\n\n**Arguments**: ``connect(engine_tag, *args, remove_conflicts=False, **kwds)``\n\n``engine_tag``:\n  String, specifying the DB engine to use. Can be obtained by `getEngineTags()`_.\n  If equal to ``None``, the default tag is used; its value can be obtained using `getDefaultEngineTag()`_.\n\n``remove_conflicts``:\n  Default value of this parameter for `Connection.modify()`_ and `Connection.insert()`_.\n\n``args``, ``kwds``:\n  Engine-specific parameters. See `Engines`_ section for further information.\n\n**Returns**: `Connection`_ object.\n\n.. _getDefaultEngineTag():\n\nbrain.getDefaultEngineTag()\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nGet engine tag, which will be used if ``None`` is specified as engine tag in `connect()`_.\n\n**Arguments**: ``getDefaultEngineTag()``\n\n**Returns**: default engine tag.\n\n.. _getEngineTags():\n\nbrain.getEngineTags()\n~~~~~~~~~~~~~~~~~~~~~\n\nGet available engine tags.\n\n**Arguments**: ``getEngineTags()``\n\n**Returns**: list of engine tags.\n\n.. _operators:\n\n.. _op:\n\nbrain.op\n~~~~~~~~\n\nThis submodule contains operator definitions for `Connection.search()`_ request:\n\n* inversion operator ``NOT`` - can be used in all conditions.\n\n* logical operators ``OR`` and ``AND`` - can be used to link simple conditions.\n\n* comparison operators ``EQ`` (equal to), ``REGEXP``, ``LT`` (lower than), ``LTE`` (lower than or equal to),\n  ``GT`` (greater than) and ``GTE`` (greater than or equal to) - can be used in simple conditions.\n\n  * ``EQ`` can be used for all value types.\n\n  * ``REGEXP`` can be used only for strings. It should support POSIX regexps.\n\n  * ``LT``, ``LTE``, ``GT`` and ``GTE`` can be used for integers and floats.\n\n.. _Connection:\n\n.. _RemoteConnection:\n\nConnection, RemoteConnection\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThese objects represent the connection to the database. They have exactly the same public interface,\nso only Connection methods will be described.\n\nCurrently the following connection methods are available:\n\n * `Connection.begin()`_\n * `Connection.beginAsync()`_\n * `Connection.beginSync()`_\n * `Connection.close()`_\n * `Connection.commit()`_\n * `Connection.create()`_\n * `Connection.delete()`_\n * `Connection.deleteMany()`_\n * `Connection.dump()`_\n * `Connection.getRemoveConflicts()`_\n * `Connection.insert()`_\n * `Connection.insertMany()`_\n * `Connection.modify()`_\n * `Connection.objectExists()`_\n * `Connection.read()`_\n * `Connection.readByMask()`_\n * `Connection.readByMasks()`_\n * `Connection.repair()`_\n * `Connection.rollback()`_\n * `Connection.search()`_\n\nConnection.begin()\n==================\n\nStart database transaction. If transaction is already in progress, `FacadeError`_\nwill be raised.\n\n**Arguments**: ``begin(sync)``\n\n``sync``:\n  Boolean value, specifying whether transaction should be synchronous or not\n  (see `Connection.beginSync()`_ or `Connection.beginAsync()`_ correspondingly for details)\n\n**Example**:\n\n* Start new transaction\n\n >>> conn = brain.connect(None, None)\n >>> conn.begin(sync=True)\n\n* Failed attempt to start transaction when another one is in progress\n\n >>> conn.begin(sync=True)\n Traceback (most recent call last):\n ...\n brain.interface.FacadeError: Transaction is already in progress\n >>> conn.close()\n\nConnection.beginAsync()\n=======================\n\nThis function is an alias for `Connection.begin()`_ (equals to ``begin(sync=False)``)\n\nStart asynchronous transaction. During the asynchronous transaction requests to database\nare not processed, just stored inside the connection. Correspondingly, actual database\ntransaction is not started. When `Connection.commit()`_ is called, database transaction is created,\nand all of requests are being processed at once, and their results are returned from\n`Connection.commit()`_ as a list.\n\nThis decreases the time database is locked by the transaction and increases the speed\nof remote operations (one XML RPC multicall is faster than several single calls).\nBut, of course, this method is less convenient than the synchronous\nor implicit transaction.\n\n**Arguments**: ``beginAsync()``\n\n**Example**:\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create({'name': 'Bob'})\n >>> conn.beginAsync()\n >>> conn.modify(id1, ['name'], 'Carl')\n >>> print(conn.read(id1))\n None\n >>> print(conn.commit())\n [None, {'name': 'Carl'}]\n >>> conn.close()\n\nConnection.beginSync()\n======================\n\nThis function is an alias for `Connection.begin()`_ (equals to ``begin(sync=True)``)\n\nStart synchronous transaction. During the synchronous transaction request results are available\ninstantly (for the same connection object), so one can perform complex actions inside\none transaction. On the downside, actual database transaction is opened all the time,\nprobably locking the database (depends on the engine). In case of remote connection,\nsynchronous transaction means that there will be several requests/responses performed,\nslowing down transaction processing.\n\n**Arguments**: ``beginSync()``\n\n**Example**:\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create({'name': 'Bob'})\n >>> conn.beginSync()\n >>> conn.modify(id1, ['name'], 'Carl')\n >>> print(conn.read(id1))\n {'name': 'Carl'}\n >>> conn.commit()\n >>> conn.close()\n\nConnection.close()\n==================\n\nClose connection to the database. All uncommitted changes will be lost.\n\n**Arguments**: ``close()``\n\nConnection.commit()\n===================\n\nCommit current transaction. If transaction is not in progress, `FacadeError`_ will be raised.\n\n**Arguments**: ``commit()``\n\n**Example**:\n\n* Create and commit transaction\n\n >>> conn = brain.connect(None, None)\n >>> conn.beginSync()\n >>> conn.commit()\n\n* Try to commit non-existent transaction\n\n >>> conn.commit()\n Traceback (most recent call last):\n ...\n brain.interface.FacadeError: Transaction is not in progress\n >>> conn.close()\n\nConnection.create()\n===================\n\nCreate new object in database.\n\n**Arguments**: ``create(self, data, path=None)``\n\n``data``:\n  Initial object contents. Can be either a value of allowed type, list or dictionary.\n\n``path``:\n  If defined, specifies the `path`_ where ``data`` will be stored (if equal to ``None``,\n  data is stored in root). Should be determined.\n\n**Returns**: object ID\n\n**Example**:\n\n* Creation without path\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create([1, 2, 3])\n >>> print(conn.read(id1))\n [1, 2, 3]\n\n* Creation with path\n\n >>> id2 = conn.create([1, 2, 3], ['key'])\n >>> print(conn.read(id2))\n {'key': [1, 2, 3]}\n >>> conn.close()\n\n.. _Connection.delete():\n\n.. _Connection.deleteMany():\n\nConnection.delete(), Connection.deleteMany()\n============================================\n\nDelete the whole object or some of its fields. If an element of list is deleted,\nother list elements are shifted correspondingly.\n\n**Arguments**:\n  ``delete(id, path=None)``\n\n  ``deleteMany(id, paths=None)``\n\n**Note**: ``delete(id, path)`` is an alias for ``deleteMany(id, [path])``\n\n``id``:\n  Target object ID.\n\n``paths``:\n  List of `paths`_. If given, is used as the set of masks, specifying fields to delete.\n  If ``None``, the whole object will be deleted.\n\n**Example**:\n\n* Deletion of the whole object\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create([1, 2, 3])\n >>> conn.delete(id1)\n >>> print(conn.objectExists(id1))\n False\n\n* Deletion of specific field\n\n >>> id1 = conn.create([1, 2, 3])\n >>> conn.delete(id1, [1])\n >>> print(conn.read(id1))\n [1, 3]\n\n* Deletion by mask\n\n >>> id1 = conn.create({'tracks': [{'name': 'track 1', 'length': 240},\n ... {'name': 'track 2', 'length': 300}]})\n >>> conn.delete(id1, ['tracks', None, 'length'])\n >>> print(conn.read(id1))\n {'tracks': [{'name': 'track 1'}, {'name': 'track 2'}]}\n >>> conn.close()\n\nConnection.dump()\n=================\n\nGet all database contents.\n\n**Arguments**: ``dump()``\n\n**Returns**: list [object 1 ID, object 1 contents, object 2 ID, object 2 contents, ...]\n\n**Example**:\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create([1, 2, 3])\n >>> id2 = conn.create({'key': 'val'})\n >>> print(conn.dump())\n [1, [1, 2, 3], 2, {'key': 'val'}]\n >>> conn.close()\n\nConnection.getRemoveConflicts()\n===============================\n\nGet current default value of ``remove_conflicts`` keyword (the one which was set\nwhen connection was created, in `connect()`_).\n\n**Arguments**: ``getRemoveConflicts()``\n\n**Returns**: True or False\n\n.. _Connection.insert():\n\n.. _Connection.insertMany():\n\nConnection.insert(), Connection.insertMany()\n============================================\n\nInsert given data to list in object.\n\n**Arguments**:\n  ``insert(id, path, value, remove_conflicts=None)``\n\n  ``insertMany(id, path, values, remove_conflicts=None)``\n\n**Note**: ``insert(id, path, value, remove_conflicts)`` is an alias for\n``insert(id, path, [value], remove_conflicts)``\n\n``id``:\n  Target object ID.\n\n``path``:\n  `Path`_ to insert to. Should point to list element (i.e., end with integer or ``None``) and\n  be determined (except for, probably, the last element). If the last element is ``None``,\n  insertion will be performed to the end of the list.\n\n``value``:\n  Data to insert - should be a supported data structure.\n\n``remove_conflicts``\n  See the description of this parameter for `Connection.modify()`_. ``insert()`` tries to perform\n  ``modify(id, path, [], remove_conflicts)`` before doing any actions.\n\n**Remarks**:\n  * If target object does not have the field, which ``path`` is pointing to, it will be created.\n\n  * If ``path`` points to dictionary key, `FormatError`_ will be raised.\n\n  * If dictionary already exists at the place which ``path`` is pointing to, `StructureError`_\n    will be raised.\n\n**Example**:\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create({'key': [1, 2, 3]})\n\n* Insertion to the beginning\n\n >>> conn.insert(id1, ['key', 0], 0)\n >>> print(conn.read(id1))\n {'key': [0, 1, 2, 3]}\n\n* Insertion to the end\n\n >>> conn.insert(id1, ['key', None], 4)\n >>> print(conn.read(id1))\n {'key': [0, 1, 2, 3, 4]}\n\n* Autovivification, no conflicts\n\n >>> conn.insert(id1, ['key2', None], 50)\n >>> print(conn.read(id1))\n {'key2': [50], 'key': [0, 1, 2, 3, 4]}\n\n* Autovivification raises error on existing conflicts\n\n >>> conn.insert(id1, ['key2', 'key3', None], 50)\n Traceback (most recent call last):\n ...\n brain.interface.StructureError: Path ['key2', 'key3'] conflicts with existing structure\n\n* Autovivification, remove conflicts\n\n >>> conn.insert(id1, ['key2', 'key3', None], 50, remove_conflicts=True)\n >>> print(conn.read(id1))\n {'key2': {'key3': [50]}, 'key': [0, 1, 2, 3, 4]}\n\n* Insert several values at once\n\n >>> conn.insertMany(id1, ['key2', 'key3', None], [51, 52, 53])\n >>> print(conn.read(id1))\n {'key2': {'key3': [50, 51, 52, 53]}, 'key': [0, 1, 2, 3, 4]}\n\n* Insert data structure\n\n >>> conn.insert(id1, ['key2', 'key3', None], {'subkey': 'val'})\n >>> print(conn.read(id1))\n {'key2': {'key3': [50, 51, 52, 53, {'subkey': 'val'}]}, 'key': [0, 1, 2, 3, 4]}\n\n* Try to pass wrong path to insert()\n\n >>> conn.insert(id1, ['key2', 'key3'], 'val')\n Traceback (most recent call last):\n ...\n brain.interface.FormatError: Last element of target field name should be None or integer\n >>> conn.close()\n\nConnection.modify()\n===================\n\nModify or create field in object.\n\n**Arguments**: ``modify(id, path, value, remove_conflicts=None)``\n\n``id``:\n  Target object ID.\n\n``path``:\n  Path where to store data.\n\n``value``:\n  Data to save at target path.\n\n``remove_conflicts``:\n  Determines the way conflicts of ``path`` with existing data structure are handled. Possible conflicts are:\n\n  * ``path`` points to dictionary, when list already exists on the same level\n\n  * ``path`` points to list, when dictionary already exists on the same level\n\n  * ``path`` points to list or dictionary, when scalar value already exists on the same level\n\n  If ``remove_conflicts`` equals ``True``, all conflicting fields are deleted. In other words,\n  ``modify()`` is guaranteed to finish successfully and the result of ``read(id, path)`` is\n  guaranteed to be equal to ``value``.\n\n  If ``remove_conflicts`` equals ``False``, `StructureError` is raised if conflict is found.\n\n  If ``remove_conflicts`` equals None (default), the value given to `brain.connect()`_ is used.\n\n**Example**:\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create({'key': 'val'})\n\n* Simple modification\n\n >>> conn.modify(id1, ['key'], 'new_val')\n >>> print(conn.read(id1))\n {'key': 'new_val'}\n\n* Save data structure in place of value\n\n >>> conn.modify(id1, ['key'], [1, 2])\n >>> print(conn.read(id1))\n {'key': [1, 2]}\n\n* Try to autovivify conflicting path without ``remove_conflicts`` set\n\n >>> conn.modify(id1, ['key', 'key2'], 'val')\n Traceback (most recent call last):\n ...\n brain.interface.StructureError: Path ['key', 'key2'] conflicts with existing structure\n\n* Implicitly transform list remove ``[1, 2]`` using ``remove_conflicts``\n\n >>> conn.modify(id1, ['key', 'key2'], 'val', remove_conflicts=True)\n >>> print(conn.read(id1))\n {'key': {'key2': 'val'}}\n >>> conn.close()\n\nConnection.objectExists()\n=========================\n\nCheck if object with given ID exists.\n\n**Arguments**: ``objectExists(id)``\n\n``id``:\n  Object ID.\n\n**Returns**: True if object with given ID exists, False otherwise.\n\n.. _Connection.read():\n\n.. _Connection.readByMask():\n\n.. _Connection.readByMasks():\n\nConnection.read(), Connection.readByMask, Connection.readByMasks()\n==================================================================\n\nRead contents of given object.\n\n**Arguments**:\n  ``read(id, path=None, masks=None)``\n\n  ``readByMask(id, mask=None)``\n\n  ``readByMasks(id, masks=None)``\n\n**Note**: ``readByMask(id, mask)`` is an alias for ``readByMasks(id, [mask])`` and\n``readByMasks(id, masks)``, in turn, is an alias for ``read(id, None, masks)``.\n\n``id``:\n  Target object ID.\n\n``path``:\n  `Path`_ to read from. Read from root by default.\n\n``masks``:\n  List of `paths`_; all results which do not have one of them in the beginning, will be filtered out.\n  Masks are relative to ``path``.\n\n**Returns**: resulting data structure.\n\n**Example**:\n\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create({'tracks': [{'name': 'track 1', 'length': 240}, {'name': 'track 2', 'length': 300}]})\n\n* Read the whole object\n\n >>> print(conn.read(id1))\n {'tracks': [{'length': 240, 'name': 'track 1'}, {'length': 300, 'name': 'track 2'}]}\n\n* Read from given path\n\n >>> print(conn.read(id1, ['tracks', 0]))\n {'length': 240, 'name': 'track 1'}\n\n* Read by mask\n\n >>> print(conn.readByMask(id1, ['tracks', None, 'length']))\n {'tracks': [{'length': 240}, {'length': 300}]}\n\n* Read from path, filter by mask. Note that mask is relative.\n\n >>> print(conn.read(id1, ['tracks'], [[None, 'length']]))\n [{'length': 240}, {'length': 300}]\n >>> conn.close()\n\nConnection.repair()\n===================\n\nInternal database structure includes some redundant tables, which are used to increase\ndatabase performance. This function can restore them based on actual field data stored in\ndatabase. It can be used when database requests (even `Connection.read()`_) are returning strange\nerrors with long call stack. These internal tables can be spoiled either by errors in logic\nor because of some errors in underlying SQL engine.\n\n**Arguments**: ``repair()``\n\nConnection.rollback()\n=====================\n\nRoll current transaction back. If transaction is not in progress, `FacadeError`_ will be raised.\n\n**Arguments**: ``rollback()``\n\n**Example**:\n\n* Create and rollback transaction\n\n >>> conn = brain.connect(None, None)\n >>> conn.beginSync()\n >>> conn.rollback()\n\n* Try to rollback non-existent transaction\n\n >>> conn.rollback()\n Traceback (most recent call last):\n ...\n brain.interface.FacadeError: Transaction is not in progress\n >>> conn.close()\n\nConnection.search()\n===================\n\nSearch for objects in database which satisfy given conditions.\n\n**Arguments**: ``search(condition)``\n\n``condition``:\n  One of three possibilities:\n\n  * List ``condition``\n\n  * Tuple ``condition``\n\n  * Empty list (only at root level, cannot be a part of condition)\n\n  Simple ``condition`` is a list [``brain.op.NOT``, ] `path`_, comparison_operator, value; complex\n  ``condition`` is a list [``brain.op.NOT``, ] ``condition``, [[logical_operator,\n  [``brain.op.NOT``, ] ``condition``, ] ... ], where each ``condition`` can be either simple or complex.\n\n  On the root level, you may not wrap condition in a list, but rather just pass\n  it as a tuple of arguments to function.\n\n  Logical_operator and comparison_operator - any `operators`_. Value should be a\n  scalar of supported type. Note that different values support different type of\n  comparisons; see `brain.op`_ reference for details.\n\n  If ``condition`` is an empty list, it matches all existing object IDs in database.\n\n  If condition uses path, not existing in some object, condition is considered\n  to be false for this object if it does not contain ``brain.op.NOT`` and true\n  otherwise.\n\n  Compound conditions are evaluated successively: ``[cond1, op1, cond2, op2, cond3]`` is evaluated\n  as ``[[cond1, op1, cond2], op2, cond3]``.\n\n  In compound conditions ``NOT`` applies to the condition next to it:\n  ``[NOT, cond1, op1, cond2, op2, NOT, cond3]`` is evaluated as\n  ``[[[NOT cond1], op1, cond2], op2, [NOT, cond3]]``.\n\n**Returns**: list of object IDs, satisfying given conditions (note that order can\ndepend on DB engine).\n\n**Example**:\n\n >>> import brain.op as op\n >>> conn = brain.connect(None, None)\n >>> id1 = conn.create({'name': 'Alex', 'age': 22})\n >>> id2 = conn.create({'name': 'Bob', 'height': 180, 'age': 25})\n >>> id3 = conn.create({'name': 'Carl', 'height': 170, 'age': 26})\n\n* Empty condition\n\n >>> print(set(conn.search()) == set([id1, id2, id3]))\n True\n\n* Simple condition\n\n >>> print(conn.search(['name'], op.EQ, 'Alex') == [id1])\n True\n\n* Compound condition\n\n >>> print(set(conn.search([['name'], op.EQ, 'Alex'], op.OR,\n ... [['name'], op.EQ, 'Carl'])) == set([id1, id3]))\n True\n\n* Compound condition with negative\n\n >>> print(set(conn.search([['name'], op.EQ, 'Alex'], op.OR,\n ... [op.NOT, ['name'], op.EQ, 'Carl'])) == set([id1, id2]))\n True\n\n* Condition with non-equality\n\n >>> print(conn.search(['age'], op.GT, 25) == [id3])\n True\n\n* Condition with non-existent field\n\n >>> print(conn.search([['name'], op.EQ, 'Alex'], op.AND,\n ... [['height'], op.EQ, 180]) == [])\n True\n\n* Condition with non-existent field and negative\n\n >>> print(conn.search([['name'], op.EQ, 'Alex'], op.AND,\n ... [op.NOT, ['height'], op.EQ, 180]) == [id1])\n True\n\n* Long compound condition\n\n >>> print(conn.search([['name'], op.EQ, 'Alex'], op.OR,\n ... [['age'], op.EQ, 25], op.AND,\n ... [['height'], op.GT, 175]) == [id2])\n True\n >>> conn.close()\n\nCachedConnection\n~~~~~~~~~~~~~~~~\n\nThis class wraps anything with `Connection`_-like interface and adds object caching.\nThe caching algorithm is rather simple, it speeds up only read operations (by keeping\ncopies of objects in memory).\n\n**Warning**: This class can work incorrectly if more than one connection to database is opened.\nFor example, if the second connection changes something in database, the cache will not change\nand, therefore, read operation from the first connection will return the old value.\n\n**Arguments**: ``CachedConnection(conn, size_threshold=0)``\n\n``conn``:\n  Object with `Connection`_ interface.\n\n``size_threshold``:\n  How many objects the cache must keep in memory. If zero, all accessed objects are kept.\n  If non-zero, specifies the number of most recently accessed object kept.\n\nClient\n~~~~~~\n\nXML RPC client for brain DB. Based on Python's built-in ``xmlrpc.client.ServerProxy`` and has the\nfollowing extensions:\n\n* Supports keyword arguments to calls (adds dictionary with keyword argument to each method call)\n\n* Unmarshalls known `exceptions`_ from ``Faults`` returned by server\n\n**Arguments**: ``Client(addr)``\n\n``addr``:\n  Address to connect to.\n\nClient.connect()\n================\n\nConnect to DB or create a new one.\n\n**Arguments**: same as for `brain.connect()`_.\n\n**Returns**: `RemoteConnection`_ object.\n\nClient.getDefaultEngineTag()\n============================\n\nSame as `brain.getDefaultEngineTag()`_.\n\nClient.getEngineTags()\n======================\n\nSame as `brain.getEngineTags()`_.\n\nServer\n~~~~~~\n\nXML RPC server for database. Based on Python's built-in ``xmlrpc.server.DocXMLRPCServer``\nand extends standard XML RPC slightly: it supports keyword arguments to calls.\nThey are passed as the dictionary in additional argument to each function.\nIf function does not have any keyword arguments, empty dictionary is passed.\n\n**Arguments**: ``Server(port=8000, name=None, db_path=None)``\n\n``port``:\n  Port where server will wait for requests.\n\n``name``:\n  Server thread name.\n\n``db_path``:\n  Will be used with DB engines, which store information in files - ``db_path`` will serve as\n  a prefix to each created DB file.\n\n.. _start():\n\nServer.start()\n==============\n\nStart server in a separate thread. Returns instantly.\n\n**Arguments**: ``start()``\n\n.. _stop():\n\nServer.stop()\n=============\n\nShutdown server and wait for its thread to stop.\n\n**Arguments**: ``stop()``", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/Manticore/brain", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "brain", "package_url": "https://pypi.org/project/brain/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/brain/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/Manticore/brain"}, "release_url": "https://pypi.org/project/brain/0.1.6/", "requires_dist": null, "requires_python": null, "summary": "DDB front-end for SQL engines", "version": "0.1.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#introduction\" id=\"id1\" rel=\"nofollow\">Introduction</a></li>\n<li><a href=\"#quick-start\" id=\"id2\" rel=\"nofollow\">Quick start</a><ul>\n<li><a href=\"#basic-functions\" id=\"id3\" rel=\"nofollow\">Basic functions</a></li>\n<li><a href=\"#transaction-support\" id=\"id4\" rel=\"nofollow\">Transaction support</a></li>\n<li><a href=\"#xml-rpc-layer\" id=\"id5\" rel=\"nofollow\">XML RPC layer</a></li>\n</ul>\n</li>\n<li><a href=\"#reference\" id=\"id6\" rel=\"nofollow\">Reference</a><ul>\n<li><a href=\"#known-limitations\" id=\"id7\" rel=\"nofollow\">Known limitations</a></li>\n<li><a href=\"#path\" id=\"id8\" rel=\"nofollow\">Path</a></li>\n<li><a href=\"#exceptions\" id=\"id9\" rel=\"nofollow\">Exceptions</a></li>\n<li><a href=\"#engines\" id=\"id10\" rel=\"nofollow\">Engines</a></li>\n<li><a href=\"#tests\" id=\"id11\" rel=\"nofollow\">Tests</a></li>\n<li><a href=\"#brain-connect\" id=\"id12\" rel=\"nofollow\">brain.connect()</a></li>\n<li><a href=\"#brain-getdefaultenginetag\" id=\"id13\" rel=\"nofollow\">brain.getDefaultEngineTag()</a></li>\n<li><a href=\"#brain-getenginetags\" id=\"id14\" rel=\"nofollow\">brain.getEngineTags()</a></li>\n<li><a href=\"#brain-op\" id=\"id15\" rel=\"nofollow\">brain.op</a></li>\n<li><a href=\"#connection-remoteconnection\" id=\"id16\" rel=\"nofollow\">Connection, RemoteConnection</a><ul>\n<li><a href=\"#connection-begin\" id=\"id17\" rel=\"nofollow\">Connection.begin()</a></li>\n<li><a href=\"#connection-beginasync\" id=\"id18\" rel=\"nofollow\">Connection.beginAsync()</a></li>\n<li><a href=\"#connection-beginsync\" id=\"id19\" rel=\"nofollow\">Connection.beginSync()</a></li>\n<li><a href=\"#connection-close\" id=\"id20\" rel=\"nofollow\">Connection.close()</a></li>\n<li><a href=\"#connection-commit\" id=\"id21\" rel=\"nofollow\">Connection.commit()</a></li>\n<li><a href=\"#connection-create\" id=\"id22\" rel=\"nofollow\">Connection.create()</a></li>\n<li><a href=\"#connection-delete-connection-deletemany\" id=\"id23\" rel=\"nofollow\">Connection.delete(), Connection.deleteMany()</a></li>\n<li><a href=\"#connection-dump\" id=\"id24\" rel=\"nofollow\">Connection.dump()</a></li>\n<li><a href=\"#connection-getremoveconflicts\" id=\"id25\" rel=\"nofollow\">Connection.getRemoveConflicts()</a></li>\n<li><a href=\"#connection-insert-connection-insertmany\" id=\"id26\" rel=\"nofollow\">Connection.insert(), Connection.insertMany()</a></li>\n<li><a href=\"#connection-modify\" id=\"id27\" rel=\"nofollow\">Connection.modify()</a></li>\n<li><a href=\"#connection-objectexists\" id=\"id28\" rel=\"nofollow\">Connection.objectExists()</a></li>\n<li><a href=\"#connection-read-connection-readbymask-connection-readbymasks\" id=\"id29\" rel=\"nofollow\">Connection.read(), Connection.readByMask, Connection.readByMasks()</a></li>\n<li><a href=\"#connection-repair\" id=\"id30\" rel=\"nofollow\">Connection.repair()</a></li>\n<li><a href=\"#connection-rollback\" id=\"id31\" rel=\"nofollow\">Connection.rollback()</a></li>\n<li><a href=\"#connection-search\" id=\"id32\" rel=\"nofollow\">Connection.search()</a></li>\n</ul>\n</li>\n<li><a href=\"#cachedconnection\" id=\"id33\" rel=\"nofollow\">CachedConnection</a></li>\n<li><a href=\"#client\" id=\"id34\" rel=\"nofollow\">Client</a><ul>\n<li><a href=\"#client-connect\" id=\"id35\" rel=\"nofollow\">Client.connect()</a></li>\n<li><a href=\"#client-getdefaultenginetag\" id=\"id36\" rel=\"nofollow\">Client.getDefaultEngineTag()</a></li>\n<li><a href=\"#client-getenginetags\" id=\"id37\" rel=\"nofollow\">Client.getEngineTags()</a></li>\n</ul>\n</li>\n<li><a href=\"#server\" id=\"id38\" rel=\"nofollow\">Server</a><ul>\n<li><a href=\"#server-start\" id=\"id39\" rel=\"nofollow\">Server.start()</a></li>\n<li><a href=\"#server-stop\" id=\"id40\" rel=\"nofollow\">Server.stop()</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"introduction\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Introduction</a></h2>\n<p>Document databases may prove out to be more convenient than relational ones for programs\nthat operate with a large set of objects with different parameters. With document database\nyou do not need to develop the database scheme, just toss objects with complex structure\nto the database and retreive them by any search criteria. For example, this approach may\nbe useful for music players (store tracks/albums/artists as objects with cross-references\nand references to real files), project management software, bug tracking systems and so on.</p>\n<p>This package is, in effect, a wrapper, which makes the relational database engine look\nlike DDB. Of course, this approach has its drawbacks - noticeable overhead and slow store/retreive\noperations. But it gives fast search, transaction support and all features of chosen relational\nDB engine (like DB server, secure access, replication and other stuff) for free. Plus, all DB engines\nare constantly improving without my attention - isn\u2019t it cool?</p>\n<p>This package is in beta state now. You can find all planned tasks in todo.rst (not included in\ndistribution, get it from master branch). I will appreciate any comments and bug reports,\nfrom grammar and spelling errors in documentation to flaws in module architecture.</p>\n</div>\n<div id=\"quick-start\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Quick start</a></h2>\n<p>This section will show only the simple usage examples. For exhaustive information please consult\nthe <a href=\"#reference\" rel=\"nofollow\">Reference</a> entries for corresponding functions.</p>\n<div id=\"basic-functions\">\n<h3><a href=\"#id3\" rel=\"nofollow\">Basic functions</a></h3>\n<p>First, import the module:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import brain\n</pre>\n</blockquote>\n<p>Then we will need to connect to existing database or create the new one.\nIn this example we will use the default DB engine (sqlite3) and in-memory database.\nFirst None stands for so called \u201cengine tag\u201d (which identifies DB engine to use),\nand the second one stands for DB name (which is mandatory for sqlite3 engine).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n</pre>\n</blockquote>\n<p>Now we can create some objects. Objects are identified by their IDs, which are\nintended to be opaque. The only thing that the end user should know is that they\ncan be stored in database too.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; id1 = conn.create({'a': 1, 'b': 1.345})\n&gt;&gt;&gt; id2 = conn.create({'id1': id1, 'list': [1, 2, 'some_value']})\n</pre>\n</blockquote>\n<p>These objects can be read from database:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data1 = conn.read(id1)\n&gt;&gt;&gt; print(data1)\n{'a': 1, 'b': 1.345}\n&gt;&gt;&gt; data2 = conn.read(id2)\n&gt;&gt;&gt; print(data2)\n{'list': [1, 2, 'some_value'], 'id1': 1}\n</pre>\n</blockquote>\n<p>You can see that the object ID is, in fact, a simple integer. It is true for sqlite3 engine,\nbut each engine can use its own ID format.</p>\n<p>The next function is <a href=\"#connection-modify\" rel=\"nofollow\">Connection.modify()</a>; it allows us to change the contents of the object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.modify(id1, ['a'], 2)\n&gt;&gt;&gt; data1 = conn.read(id1)\n&gt;&gt;&gt; print(data1)\n{'a': 2, 'b': 1.345}\n</pre>\n</blockquote>\n<p>Its first argument is object ID, second one is is the <a href=\"#path\" rel=\"nofollow\">path</a> to some place inside object and\nthe third one is the value to store (can be either some simple type or data structure). Path\nis a list, whose elements can be strings, integers or Nones. String element corresponds to key\nin dictionary, integer to list index, and None to list mask.</p>\n<p>You may have noticed that the second object contains a list. New elements can be added\nto list in two ways - either using <a href=\"#connection-modify\" rel=\"nofollow\">Connection.modify()</a> with path, specifying list index to create,\nor inserting new element to some place in list:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.modify(id2, ['list', 3], 3)\n&gt;&gt;&gt; print(conn.read(id2))\n{'list': [1, 2, 'some_value', 3], 'id1': 1}\n&gt;&gt;&gt; conn.insert(id2, ['list', 0], 4)\n&gt;&gt;&gt; print(conn.read(id2))\n{'list': [4, 1, 2, 'some_value', 3], 'id1': 1}\n&gt;&gt;&gt; conn.insert(id2, ['list', None], 5)\n&gt;&gt;&gt; print(conn.read(id2))\n{'list': [4, 1, 2, 'some_value', 3, 5], 'id1': 1}\n</pre>\n</blockquote>\n<p>First action creates the element with index 3 in list; note that it is expanded automatically.\nSecond action inserts the new element to the beginning of the list. Third action inserts\nthe new element to the end of the list.</p>\n<p>We can now search for objects in database. For example, we want to find the object, which\nhas list under \u2018list\u2019 key in dictionary, which, in turn has the first element equal to 4.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import brain.op as op\n&gt;&gt;&gt; objs = conn.search(['list', 0], op.EQ, 4)\n&gt;&gt;&gt; print(objs == [id2])\nTrue\n</pre>\n</blockquote>\n<p>Search request supports nested conditions and several types of comparisons (including regexps).\nSee its reference page for more information.</p>\n<p>The last basic function is <a href=\"#connection-delete\" rel=\"nofollow\">Connection.delete()</a>. It can delete the whole objects, or its parts\n(dictionary keys or list elements).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.objectExists(id1))\nTrue\n&gt;&gt;&gt; conn.delete(id1)\n&gt;&gt;&gt; print(conn.objectExists(id1))\nFalse\n&gt;&gt;&gt; conn.delete(id2, ['list'])\n&gt;&gt;&gt; print(conn.read(id2))\n{'id1': 1}\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n<p>Connection should be closed using <a href=\"#connection-close\" rel=\"nofollow\">Connection.close()</a> after it is not longer needed. In case of\nin-memory database, of course, all data will be lost after call to <a href=\"#connection-close\" rel=\"nofollow\">Connection.close()</a>.</p>\n</div>\n<div id=\"transaction-support\">\n<h3><a href=\"#id4\" rel=\"nofollow\">Transaction support</a></h3>\n<p>One of the main advantages of using the developed SQL engine as a back-end is the\nACID compatibility. As a result, brain front-end has full transaction support too.</p>\n<p>If transaction was not started explicitly, the new one is created and committed for\neach request (create, modify, insert and so on) implicitly. In case of some underlying\nerror, this transaction is rolled back, so the request cannot be completed partially.</p>\n<p>There are two types of transactions - synchronous and asynchronous. During the\nsynchronous transaction you get request results instantly; during the asynchronous one\nrequests do not return any results - all results are returned by <a href=\"#connection-commit\" rel=\"nofollow\">Connection.commit()</a> as a list.</p>\n<p>Let\u2019s illustrate this by several simple examples. First, connect to database and\ncreate some objects.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import brain\n&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create({'a': 1, 'b': 2})\n&gt;&gt;&gt; id2 = conn.create({'c': 3, 'd': 4})\n</pre>\n</blockquote>\n<p>For each of two <a href=\"#connection-create\" rel=\"nofollow\">Connection.create()</a>\u2019s above transactions were started and committed implicitly\n(because there were not any active transactions at the moment). Now we will create synchronous\ntransaction explicitly:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.beginSync()\n&gt;&gt;&gt; conn.modify(id1, ['a'], 10)\n&gt;&gt;&gt; print(conn.read(id1))\n{'a': 10, 'b': 2}\n&gt;&gt;&gt; conn.commit()\n&gt;&gt;&gt; print(conn.read(id1))\n{'a': 10, 'b': 2}\n</pre>\n</blockquote>\n<p>Note that during synchronous transaction modifications become visible instantly. Now\nconsider the similar operation inside a transaction, but this time we will roll it back:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.beginSync()\n&gt;&gt;&gt; conn.modify(id1, ['a'], 20)\n&gt;&gt;&gt; print(conn.read(id1))\n{'a': 20, 'b': 2}\n&gt;&gt;&gt; conn.rollback()\n&gt;&gt;&gt; print(conn.read(id1))\n{'a': 10, 'b': 2}\n</pre>\n</blockquote>\n<p>Like in the previous example, modification instantly becomes visible, but after the rollback\nit is gone.</p>\n<p>Asynchronous transactions are slightly different. During the transaction requests will not\nreturn values, because they are not, in fact, executed - they are stored inside the connection\nobject and passed to DB engine in one single package when <a href=\"#connection-commit\" rel=\"nofollow\">Connection.commit()</a> is called. If the user\nchanges his mind and calls <a href=\"#connection-rollback\" rel=\"nofollow\">Connection.rollback()</a>, all this package is simply discarded.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.beginAsync()\n&gt;&gt;&gt; conn.modify(id1, ['a'], 0)\n&gt;&gt;&gt; conn.read(id1)\n&gt;&gt;&gt; print(conn.commit())\n[None, {'a': 0, 'b': 2}]\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n<p>In the example above there were two requests inside a transaction; first one, <a href=\"#connection-modify\" rel=\"nofollow\">Connection.modify()</a>\ndoes not return anything, and the second one, <a href=\"#connection-read\" rel=\"nofollow\">Connection.read()</a>, returned object contents.\nTherefore <a href=\"#connection-commit\" rel=\"nofollow\">Connection.commit()</a> returned both their results as a list.</p>\n</div>\n<div id=\"xml-rpc-layer\">\n<h3><a href=\"#id5\" rel=\"nofollow\">XML RPC layer</a></h3>\n<p>Brain has embedded XML RPC server and client. First, we will create and start server:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import brain\n&gt;&gt;&gt; srv = brain.Server()\n&gt;&gt;&gt; srv.start()\n</pre>\n</blockquote>\n<p>Now server is active on localhost, port 8000 (by default). It is executed in its own thread,\nso <a href=\"#start\" rel=\"nofollow\">start()</a> returns immediately. If you enter <a href=\"http://localhost:8000\" rel=\"nofollow\">http://localhost:8000</a> in your browser, you\nwill get a page with list of functions the server supports.</p>\n<p>Then we should create the client - either in this session, in other process or even on\nthe other computer:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cl = brain.Client('http://localhost:8000')\n</pre>\n</blockquote>\n<p>And client object gives us the ability to create connections. The format of its <tt>connect()</tt>\nmethod is the same as for <a href=\"#brain-connect\" rel=\"nofollow\">brain.connect()</a>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = cl.connect(None, None)\n</pre>\n</blockquote>\n<p>This object behaves exactly the same as the <a href=\"#connection\" rel=\"nofollow\">Connection</a> object returned by <a href=\"#brain-connect\" rel=\"nofollow\">brain.connect()</a>.\nYou can try all examples from previous sections - they all should work. In the end you\nshould close the connection and stop server:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.close()\n&gt;&gt;&gt; srv.stop()\n</pre>\n</blockquote>\n<p>Unlike <a href=\"#start\" rel=\"nofollow\">start()</a>, <a href=\"#stop\" rel=\"nofollow\">stop()</a> waits for server to shut down.</p>\n</div>\n</div>\n<div id=\"reference\">\n<h2><a href=\"#id6\" rel=\"nofollow\">Reference</a></h2>\n<div id=\"known-limitations\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Known limitations</a></h3>\n<dl>\n<dt>Value limitations:</dt>\n<dd><ul>\n<li>Currently the following Python types are supported: <tt>None</tt>, <tt>int</tt>, <tt>float</tt>, <tt>str</tt> and <tt>bytes</tt>.</li>\n<li>Integers are limited to 8 bytes (by DB engines) and to 4 bytes by XML RPC protocol.</li>\n</ul>\n</dd>\n<dt>Structure limitations:</dt>\n<dd><ul>\n<li>Each object can contain arbitrarily combined values, lists and dictionaries.</li>\n<li>Structure depth is not limited theoretically, but in practice it is - by DB engine.</li>\n<li>Lists and dictionaries can be empty.</li>\n<li>Dictionary keys should have string type.</li>\n</ul>\n</dd>\n</dl>\n</div>\n<div id=\"path\">\n<span id=\"paths\"></span><h3><a href=\"#id8\" rel=\"nofollow\">Path</a></h3>\n<p>Path to some value in object is a list, which can contain only strings, integers and Nones.\nEmpty list means the root level of an object; string stands for dictionary key and integer\nstands for position in list. None is used in several special cases: to specify that\n<a href=\"#connection-insert\" rel=\"nofollow\">Connection.insert()</a> should perform insertion at the end of the list or as a mask for\n<a href=\"#connection-delete\" rel=\"nofollow\">Connection.delete()</a> and <a href=\"#connection-read\" rel=\"nofollow\">Connection.read()</a>.</p>\n<p>String elements must not contain uppercase symbols. This is done because each field name\ncorrespond to table name in underlying SQL engine, and some engines ignore case in table names.\nSo, in order to avoid later search errors, uppercase symbols in field names are simply not allowed -\n<a href=\"#formaterror\" rel=\"nofollow\">FormatError</a> is thrown.</p>\n<p>If path does not contain Nones, it is called <em>determined</em>.</p>\n<p><strong>Example</strong>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create({'tracks': [{'name': 'track 1', 'length': 240},\n... {'name': 'track 2', 'length': 300}]})\n&gt;&gt;&gt; print(conn.read(id1, ['tracks', 0, 'name']))\ntrack 1\n&gt;&gt;&gt; print(conn.readByMask(id1, ['tracks', None, 'length']))\n{'tracks': [{'length': 240}, {'length': 300}]}\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"exceptions\">\n<span id=\"formaterror\"></span><span id=\"structureerror\"></span><span id=\"engineerror\"></span><span id=\"facadeerror\"></span><h3><a href=\"#id9\" rel=\"nofollow\">Exceptions</a></h3>\n<p>Following exceptions can be thrown by API:</p>\n<blockquote>\n<dl>\n<dt><tt>brain.FacadeError</tt>:</dt>\n<dd>Signals about the error in high-level wrappers. Can be caused by incorrect\ncalls to <a href=\"#connection-begin\" rel=\"nofollow\">Connection.begin()</a> \\ <a href=\"#connection-commit\" rel=\"nofollow\">Connection.commit()</a> \\ <a href=\"#connection-rollback\" rel=\"nofollow\">Connection.rollback()</a>,\nincorrect engine tag and so on.</dd>\n<dt><tt>brain.EngineError</tt>:</dt>\n<dd>Signals about an error in DB engine wrapper.</dd>\n<dt><tt>brain.StructureError</tt>:</dt>\n<dd>Signals about error in object/database structure - for example, conflicting fields.</dd>\n<dt><tt>brain.FormatError</tt>:</dt>\n<dd>Wrong format of supplied data: path is not a list, or have elements of wrong type,\ndata has values of wrong type and so on.</dd>\n</dl>\n</blockquote>\n</div>\n<div id=\"engines\">\n<h3><a href=\"#id10\" rel=\"nofollow\">Engines</a></h3>\n<p>Currently two engines are supported:</p>\n<dl>\n<dt><strong>sqlite3</strong>:</dt>\n<dd><p>SQLite 3 engine, built in Python 3.</p>\n<p><strong>Arguments</strong>: <tt>(name, open_existing=None, db_path=None)</tt></p>\n<dl>\n<dt><tt>name</tt>:</dt>\n<dd>Database file name. If equal to <tt>None</tt>, in-memory database is created.</dd>\n<dt><tt>open_existing</tt>:</dt>\n<dd><p>Ignored if <tt>name</tt> is equal to None.</p>\n<p>If equal to True, existing database file will be opened or <a href=\"#engineerror\" rel=\"nofollow\">EngineError</a>\nwill be raised if it does not exist.</p>\n<p>If equal to False, new database file will be created (in place of the existing one, if\nnecessary)</p>\n<p>If equal to None, existing database will be opened or the new one will be created, if\nthe database file does not exist.</p>\n</dd>\n<dt><tt>db_path</tt>:</dt>\n<dd>If is not None, will be concatenated (using platform-specific path join) with <tt>name</tt></dd>\n</dl>\n</dd>\n<dt><strong>postgre</strong>:</dt>\n<dd><p>Postgre 8 engine. Will be used if <a href=\"http://python.projects.postgresql.org\" rel=\"nofollow\">py-postgresql</a>\nis installed.</p>\n<p><strong>Arguments</strong>: <tt>(name, open_existing=None, <span class=\"pre\">host='localhost',</span> port=5432, <span class=\"pre\">user='postgres',</span>\n<span class=\"pre\">password='',</span> <span class=\"pre\">connection_limit=-1)</span></tt></p>\n<dl>\n<dt><tt>name</tt>:</dt>\n<dd>Database name.</dd>\n<dt><tt>open_existing</tt>:</dt>\n<dd>Same logic as for SQLite3 engine</dd>\n<dt><tt>host</tt>:</dt>\n<dd>Postgre server name</dd>\n<dt><tt>port</tt>:</dt>\n<dd>Postgre server port</dd>\n<dt><tt>user</tt>, <tt>password</tt>:</dt>\n<dd>Credentials for connecting to Postgre server</dd>\n<dt><tt>connection_limit</tt>:</dt>\n<dd>Connection limit for newly created database. Unlimited by default.</dd>\n</dl>\n</dd>\n</dl>\n</div>\n<div id=\"tests\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Tests</a></h3>\n<p>The package is supplied with a set of functionality tests which I use for debugging purposes.\nThey can be found in <tt>test</tt> subfolder of module main folder. Tests are executed using <tt>run.py</tt>,\nwhich has the following parameters:</p>\n<p><tt>run.py &lt;func|fuzz|doc|perf&gt; [options]</tt></p>\n<dl>\n<dt><tt>func</tt>:</dt>\n<dd>Functionality tests. They are based on Python\u2019s <tt>unittest</tt> module, with some minor extensions.\nCurrently they provide almost 100% coverage of package code.</dd>\n<dt><tt>fuzz</tt>:</dt>\n<dd>Several objects with random data are created and random actions (<a href=\"#connection-modify\" rel=\"nofollow\">Connection.modify()</a>,\n<a href=\"#connection-insert\" rel=\"nofollow\">Connection.insert()</a>, <a href=\"#connection-read\" rel=\"nofollow\">Connection.read()</a>, <a href=\"#connection-delete\" rel=\"nofollow\">Connection.delete()</a>) are performed on them.\nAfter each action result is compared to   the result of <tt>FakeConnection</tt>, which uses Python\ndata structures to emulate package behavior.</dd>\n<dt><tt>doc</tt>:</dt>\n<dd>Test examples in this documentation using Python\u2019s <tt>doctest</tt> module.</dd>\n<dt><tt>perf</tt>:</dt>\n<dd>Simple non-atomic performance tests (measuring times of <tt>func</tt> tests plus combining\nresults of <tt>fuzz</tt> tests with several predefined seeds).</dd>\n<dt><strong>global parameters</strong>:</dt>\n<dd><dl>\n<dt><tt><span class=\"pre\">-v</span> LEVEL</tt>, <tt><span class=\"pre\">--verbosity=LEVEL</span></tt>:</dt>\n<dd><p>Integer from 0 (less verbose) to 3 (more verbose), specifying the amount of information\nwhich is displayed during tests. Default is 2.</p>\n<p>For <tt>doc</tt> tests verbosity level 3 and above enables <tt>verbose=True</tt> mode (which means\nthat all tests will be shown); otherwise only errors will be shown.</p>\n</dd>\n</dl>\n</dd>\n<dt><tt>func</tt> <strong>parameters</strong>:</dt>\n<dd><dl>\n<dt><tt><span class=\"pre\">--ae</span></tt>, <tt><span class=\"pre\">--all-engines</span></tt>:</dt>\n<dd>If specified, all available DB engines will be tested. If not specified, only the default\nengine (see <a href=\"#getdefaultenginetag\" rel=\"nofollow\">getDefaultEngineTag()</a>) will be tested.</dd>\n<dt><tt><span class=\"pre\">--ac</span></tt>, <tt><span class=\"pre\">--all-connections</span></tt>:</dt>\n<dd>If specified, all available connections will be tested (local, XML RPC and so on). If\nnot specified, only local connection will be tested.</dd>\n<dt><tt><span class=\"pre\">--as</span></tt>, <tt><span class=\"pre\">--all-storages</span></tt>:</dt>\n<dd>If specified, all storage types for each engine will be tested (for example, for sqlite3\navailable types are in-memory and file). If not specified, only the default storage for\neach engine will be tested.</dd>\n</dl>\n</dd>\n<dt><tt>fuzz</tt> <strong>parameters</strong>:</dt>\n<dd><dl>\n<dt><tt><span class=\"pre\">-o</span> NUM</tt>, <tt><span class=\"pre\">--objects=NUM</span></tt>:</dt>\n<dd>Number of object to be tested simultaneously. Default is 1.</dd>\n<dt><tt><span class=\"pre\">-a</span> NUM</tt>, <tt><span class=\"pre\">--actions=NUM</span></tt></dt>\n<dd>Number of actions to be performed for one object. Default is 100.</dd>\n<dt><tt><span class=\"pre\">-s</span> SEED</tt>, <tt><span class=\"pre\">--seed=SEED</span></tt></dt>\n<dd>Integer which will be used as starting seed for random number generator. This wil allow\nto get reproduceable results. By default, random seed is generated.</dd>\n</dl>\n</dd>\n</dl>\n</div>\n<div id=\"brain-connect\">\n<span id=\"connect\"></span><h3><a href=\"#id12\" rel=\"nofollow\">brain.connect()</a></h3>\n<p>Connect to the database (or create the new one).</p>\n<p><strong>Arguments</strong>: <tt>connect(engine_tag, *args, remove_conflicts=False, **kwds)</tt></p>\n<dl>\n<dt><tt>engine_tag</tt>:</dt>\n<dd>String, specifying the DB engine to use. Can be obtained by <a href=\"#getenginetags\" rel=\"nofollow\">getEngineTags()</a>.\nIf equal to <tt>None</tt>, the default tag is used; its value can be obtained using <a href=\"#getdefaultenginetag\" rel=\"nofollow\">getDefaultEngineTag()</a>.</dd>\n<dt><tt>remove_conflicts</tt>:</dt>\n<dd>Default value of this parameter for <a href=\"#connection-modify\" rel=\"nofollow\">Connection.modify()</a> and <a href=\"#connection-insert\" rel=\"nofollow\">Connection.insert()</a>.</dd>\n<dt><tt>args</tt>, <tt>kwds</tt>:</dt>\n<dd>Engine-specific parameters. See <a href=\"#engines\" rel=\"nofollow\">Engines</a> section for further information.</dd>\n</dl>\n<p><strong>Returns</strong>: <a href=\"#connection\" rel=\"nofollow\">Connection</a> object.</p>\n</div>\n<div id=\"brain-getdefaultenginetag\">\n<span id=\"getdefaultenginetag\"></span><h3><a href=\"#id13\" rel=\"nofollow\">brain.getDefaultEngineTag()</a></h3>\n<p>Get engine tag, which will be used if <tt>None</tt> is specified as engine tag in <a href=\"#connect\" rel=\"nofollow\">connect()</a>.</p>\n<p><strong>Arguments</strong>: <tt>getDefaultEngineTag()</tt></p>\n<p><strong>Returns</strong>: default engine tag.</p>\n</div>\n<div id=\"brain-getenginetags\">\n<span id=\"getenginetags\"></span><h3><a href=\"#id14\" rel=\"nofollow\">brain.getEngineTags()</a></h3>\n<p>Get available engine tags.</p>\n<p><strong>Arguments</strong>: <tt>getEngineTags()</tt></p>\n<p><strong>Returns</strong>: list of engine tags.</p>\n</div>\n<div id=\"brain-op\">\n<span id=\"op\"></span><span id=\"operators\"></span><h3><a href=\"#id15\" rel=\"nofollow\">brain.op</a></h3>\n<p>This submodule contains operator definitions for <a href=\"#connection-search\" rel=\"nofollow\">Connection.search()</a> request:</p>\n<ul>\n<li>inversion operator <tt>NOT</tt> - can be used in all conditions.</li>\n<li>logical operators <tt>OR</tt> and <tt>AND</tt> - can be used to link simple conditions.</li>\n<li>comparison operators <tt>EQ</tt> (equal to), <tt>REGEXP</tt>, <tt>LT</tt> (lower than), <tt>LTE</tt> (lower than or equal to),\n<tt>GT</tt> (greater than) and <tt>GTE</tt> (greater than or equal to) - can be used in simple conditions.<ul>\n<li><tt>EQ</tt> can be used for all value types.</li>\n<li><tt>REGEXP</tt> can be used only for strings. It should support POSIX regexps.</li>\n<li><tt>LT</tt>, <tt>LTE</tt>, <tt>GT</tt> and <tt>GTE</tt> can be used for integers and floats.</li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"connection-remoteconnection\">\n<span id=\"remoteconnection\"></span><span id=\"connection\"></span><h3><a href=\"#id16\" rel=\"nofollow\">Connection, RemoteConnection</a></h3>\n<p>These objects represent the connection to the database. They have exactly the same public interface,\nso only Connection methods will be described.</p>\n<p>Currently the following connection methods are available:</p>\n<blockquote>\n<ul>\n<li><a href=\"#connection-begin\" rel=\"nofollow\">Connection.begin()</a></li>\n<li><a href=\"#connection-beginasync\" rel=\"nofollow\">Connection.beginAsync()</a></li>\n<li><a href=\"#connection-beginsync\" rel=\"nofollow\">Connection.beginSync()</a></li>\n<li><a href=\"#connection-close\" rel=\"nofollow\">Connection.close()</a></li>\n<li><a href=\"#connection-commit\" rel=\"nofollow\">Connection.commit()</a></li>\n<li><a href=\"#connection-create\" rel=\"nofollow\">Connection.create()</a></li>\n<li><a href=\"#connection-delete\" rel=\"nofollow\">Connection.delete()</a></li>\n<li><a href=\"#connection-deletemany\" rel=\"nofollow\">Connection.deleteMany()</a></li>\n<li><a href=\"#connection-dump\" rel=\"nofollow\">Connection.dump()</a></li>\n<li><a href=\"#connection-getremoveconflicts\" rel=\"nofollow\">Connection.getRemoveConflicts()</a></li>\n<li><a href=\"#connection-insert\" rel=\"nofollow\">Connection.insert()</a></li>\n<li><a href=\"#connection-insertmany\" rel=\"nofollow\">Connection.insertMany()</a></li>\n<li><a href=\"#connection-modify\" rel=\"nofollow\">Connection.modify()</a></li>\n<li><a href=\"#connection-objectexists\" rel=\"nofollow\">Connection.objectExists()</a></li>\n<li><a href=\"#connection-read\" rel=\"nofollow\">Connection.read()</a></li>\n<li><a href=\"#connection-readbymask\" rel=\"nofollow\">Connection.readByMask()</a></li>\n<li><a href=\"#connection-readbymasks\" rel=\"nofollow\">Connection.readByMasks()</a></li>\n<li><a href=\"#connection-repair\" rel=\"nofollow\">Connection.repair()</a></li>\n<li><a href=\"#connection-rollback\" rel=\"nofollow\">Connection.rollback()</a></li>\n<li><a href=\"#connection-search\" rel=\"nofollow\">Connection.search()</a></li>\n</ul>\n</blockquote>\n<div id=\"connection-begin\">\n<h4><a href=\"#id17\" rel=\"nofollow\">Connection.begin()</a></h4>\n<p>Start database transaction. If transaction is already in progress, <a href=\"#facadeerror\" rel=\"nofollow\">FacadeError</a>\nwill be raised.</p>\n<p><strong>Arguments</strong>: <tt>begin(sync)</tt></p>\n<dl>\n<dt><tt>sync</tt>:</dt>\n<dd>Boolean value, specifying whether transaction should be synchronous or not\n(see <a href=\"#connection-beginsync\" rel=\"nofollow\">Connection.beginSync()</a> or <a href=\"#connection-beginasync\" rel=\"nofollow\">Connection.beginAsync()</a> correspondingly for details)</dd>\n</dl>\n<p><strong>Example</strong>:</p>\n<ul>\n<li>Start new transaction</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; conn.begin(sync=True)\n</pre>\n</blockquote>\n<ul>\n<li>Failed attempt to start transaction when another one is in progress</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.begin(sync=True)\nTraceback (most recent call last):\n...\nbrain.interface.FacadeError: Transaction is already in progress\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-beginasync\">\n<h4><a href=\"#id18\" rel=\"nofollow\">Connection.beginAsync()</a></h4>\n<p>This function is an alias for <a href=\"#connection-begin\" rel=\"nofollow\">Connection.begin()</a> (equals to <tt>begin(sync=False)</tt>)</p>\n<p>Start asynchronous transaction. During the asynchronous transaction requests to database\nare not processed, just stored inside the connection. Correspondingly, actual database\ntransaction is not started. When <a href=\"#connection-commit\" rel=\"nofollow\">Connection.commit()</a> is called, database transaction is created,\nand all of requests are being processed at once, and their results are returned from\n<a href=\"#connection-commit\" rel=\"nofollow\">Connection.commit()</a> as a list.</p>\n<p>This decreases the time database is locked by the transaction and increases the speed\nof remote operations (one XML RPC multicall is faster than several single calls).\nBut, of course, this method is less convenient than the synchronous\nor implicit transaction.</p>\n<p><strong>Arguments</strong>: <tt>beginAsync()</tt></p>\n<p><strong>Example</strong>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create({'name': 'Bob'})\n&gt;&gt;&gt; conn.beginAsync()\n&gt;&gt;&gt; conn.modify(id1, ['name'], 'Carl')\n&gt;&gt;&gt; print(conn.read(id1))\nNone\n&gt;&gt;&gt; print(conn.commit())\n[None, {'name': 'Carl'}]\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-beginsync\">\n<h4><a href=\"#id19\" rel=\"nofollow\">Connection.beginSync()</a></h4>\n<p>This function is an alias for <a href=\"#connection-begin\" rel=\"nofollow\">Connection.begin()</a> (equals to <tt>begin(sync=True)</tt>)</p>\n<p>Start synchronous transaction. During the synchronous transaction request results are available\ninstantly (for the same connection object), so one can perform complex actions inside\none transaction. On the downside, actual database transaction is opened all the time,\nprobably locking the database (depends on the engine). In case of remote connection,\nsynchronous transaction means that there will be several requests/responses performed,\nslowing down transaction processing.</p>\n<p><strong>Arguments</strong>: <tt>beginSync()</tt></p>\n<p><strong>Example</strong>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create({'name': 'Bob'})\n&gt;&gt;&gt; conn.beginSync()\n&gt;&gt;&gt; conn.modify(id1, ['name'], 'Carl')\n&gt;&gt;&gt; print(conn.read(id1))\n{'name': 'Carl'}\n&gt;&gt;&gt; conn.commit()\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-close\">\n<h4><a href=\"#id20\" rel=\"nofollow\">Connection.close()</a></h4>\n<p>Close connection to the database. All uncommitted changes will be lost.</p>\n<p><strong>Arguments</strong>: <tt>close()</tt></p>\n</div>\n<div id=\"connection-commit\">\n<h4><a href=\"#id21\" rel=\"nofollow\">Connection.commit()</a></h4>\n<p>Commit current transaction. If transaction is not in progress, <a href=\"#facadeerror\" rel=\"nofollow\">FacadeError</a> will be raised.</p>\n<p><strong>Arguments</strong>: <tt>commit()</tt></p>\n<p><strong>Example</strong>:</p>\n<ul>\n<li>Create and commit transaction</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; conn.beginSync()\n&gt;&gt;&gt; conn.commit()\n</pre>\n</blockquote>\n<ul>\n<li>Try to commit non-existent transaction</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.commit()\nTraceback (most recent call last):\n...\nbrain.interface.FacadeError: Transaction is not in progress\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-create\">\n<h4><a href=\"#id22\" rel=\"nofollow\">Connection.create()</a></h4>\n<p>Create new object in database.</p>\n<p><strong>Arguments</strong>: <tt>create(self, data, path=None)</tt></p>\n<dl>\n<dt><tt>data</tt>:</dt>\n<dd>Initial object contents. Can be either a value of allowed type, list or dictionary.</dd>\n<dt><tt>path</tt>:</dt>\n<dd>If defined, specifies the <a href=\"#path\" rel=\"nofollow\">path</a> where <tt>data</tt> will be stored (if equal to <tt>None</tt>,\ndata is stored in root). Should be determined.</dd>\n</dl>\n<p><strong>Returns</strong>: object ID</p>\n<p><strong>Example</strong>:</p>\n<ul>\n<li>Creation without path</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create([1, 2, 3])\n&gt;&gt;&gt; print(conn.read(id1))\n[1, 2, 3]\n</pre>\n</blockquote>\n<ul>\n<li>Creation with path</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; id2 = conn.create([1, 2, 3], ['key'])\n&gt;&gt;&gt; print(conn.read(id2))\n{'key': [1, 2, 3]}\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-delete-connection-deletemany\">\n<span id=\"connection-deletemany\"></span><span id=\"connection-delete\"></span><h4><a href=\"#id23\" rel=\"nofollow\">Connection.delete(), Connection.deleteMany()</a></h4>\n<p>Delete the whole object or some of its fields. If an element of list is deleted,\nother list elements are shifted correspondingly.</p>\n<dl>\n<dt><strong>Arguments</strong>:</dt>\n<dd><p><tt>delete(id, path=None)</tt></p>\n<p><tt>deleteMany(id, paths=None)</tt></p>\n</dd>\n</dl>\n<p><strong>Note</strong>: <tt>delete(id, path)</tt> is an alias for <tt>deleteMany(id, [path])</tt></p>\n<dl>\n<dt><tt>id</tt>:</dt>\n<dd>Target object ID.</dd>\n<dt><tt>paths</tt>:</dt>\n<dd>List of <a href=\"#paths\" rel=\"nofollow\">paths</a>. If given, is used as the set of masks, specifying fields to delete.\nIf <tt>None</tt>, the whole object will be deleted.</dd>\n</dl>\n<p><strong>Example</strong>:</p>\n<ul>\n<li>Deletion of the whole object</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create([1, 2, 3])\n&gt;&gt;&gt; conn.delete(id1)\n&gt;&gt;&gt; print(conn.objectExists(id1))\nFalse\n</pre>\n</blockquote>\n<ul>\n<li>Deletion of specific field</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; id1 = conn.create([1, 2, 3])\n&gt;&gt;&gt; conn.delete(id1, [1])\n&gt;&gt;&gt; print(conn.read(id1))\n[1, 3]\n</pre>\n</blockquote>\n<ul>\n<li>Deletion by mask</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; id1 = conn.create({'tracks': [{'name': 'track 1', 'length': 240},\n... {'name': 'track 2', 'length': 300}]})\n&gt;&gt;&gt; conn.delete(id1, ['tracks', None, 'length'])\n&gt;&gt;&gt; print(conn.read(id1))\n{'tracks': [{'name': 'track 1'}, {'name': 'track 2'}]}\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-dump\">\n<h4><a href=\"#id24\" rel=\"nofollow\">Connection.dump()</a></h4>\n<p>Get all database contents.</p>\n<p><strong>Arguments</strong>: <tt>dump()</tt></p>\n<p><strong>Returns</strong>: list [object 1 ID, object 1 contents, object 2 ID, object 2 contents, \u2026]</p>\n<p><strong>Example</strong>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create([1, 2, 3])\n&gt;&gt;&gt; id2 = conn.create({'key': 'val'})\n&gt;&gt;&gt; print(conn.dump())\n[1, [1, 2, 3], 2, {'key': 'val'}]\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-getremoveconflicts\">\n<h4><a href=\"#id25\" rel=\"nofollow\">Connection.getRemoveConflicts()</a></h4>\n<p>Get current default value of <tt>remove_conflicts</tt> keyword (the one which was set\nwhen connection was created, in <a href=\"#connect\" rel=\"nofollow\">connect()</a>).</p>\n<p><strong>Arguments</strong>: <tt>getRemoveConflicts()</tt></p>\n<p><strong>Returns</strong>: True or False</p>\n</div>\n<div id=\"connection-insert-connection-insertmany\">\n<span id=\"connection-insertmany\"></span><span id=\"connection-insert\"></span><h4><a href=\"#id26\" rel=\"nofollow\">Connection.insert(), Connection.insertMany()</a></h4>\n<p>Insert given data to list in object.</p>\n<dl>\n<dt><strong>Arguments</strong>:</dt>\n<dd><p><tt>insert(id, path, value, remove_conflicts=None)</tt></p>\n<p><tt>insertMany(id, path, values, remove_conflicts=None)</tt></p>\n</dd>\n</dl>\n<p><strong>Note</strong>: <tt>insert(id, path, value, remove_conflicts)</tt> is an alias for\n<tt>insert(id, path, [value], remove_conflicts)</tt></p>\n<dl>\n<dt><tt>id</tt>:</dt>\n<dd>Target object ID.</dd>\n<dt><tt>path</tt>:</dt>\n<dd><a href=\"#path\" rel=\"nofollow\">Path</a> to insert to. Should point to list element (i.e., end with integer or <tt>None</tt>) and\nbe determined (except for, probably, the last element). If the last element is <tt>None</tt>,\ninsertion will be performed to the end of the list.</dd>\n<dt><tt>value</tt>:</dt>\n<dd>Data to insert - should be a supported data structure.</dd>\n<dt><tt>remove_conflicts</tt></dt>\n<dd>See the description of this parameter for <a href=\"#connection-modify\" rel=\"nofollow\">Connection.modify()</a>. <tt>insert()</tt> tries to perform\n<tt>modify(id, path, [], remove_conflicts)</tt> before doing any actions.</dd>\n<dt><strong>Remarks</strong>:</dt>\n<dd><ul>\n<li>If target object does not have the field, which <tt>path</tt> is pointing to, it will be created.</li>\n<li>If <tt>path</tt> points to dictionary key, <a href=\"#formaterror\" rel=\"nofollow\">FormatError</a> will be raised.</li>\n<li>If dictionary already exists at the place which <tt>path</tt> is pointing to, <a href=\"#structureerror\" rel=\"nofollow\">StructureError</a>\nwill be raised.</li>\n</ul>\n</dd>\n</dl>\n<p><strong>Example</strong>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create({'key': [1, 2, 3]})\n</pre>\n</blockquote>\n<ul>\n<li>Insertion to the beginning</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.insert(id1, ['key', 0], 0)\n&gt;&gt;&gt; print(conn.read(id1))\n{'key': [0, 1, 2, 3]}\n</pre>\n</blockquote>\n<ul>\n<li>Insertion to the end</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.insert(id1, ['key', None], 4)\n&gt;&gt;&gt; print(conn.read(id1))\n{'key': [0, 1, 2, 3, 4]}\n</pre>\n</blockquote>\n<ul>\n<li>Autovivification, no conflicts</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.insert(id1, ['key2', None], 50)\n&gt;&gt;&gt; print(conn.read(id1))\n{'key2': [50], 'key': [0, 1, 2, 3, 4]}\n</pre>\n</blockquote>\n<ul>\n<li>Autovivification raises error on existing conflicts</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.insert(id1, ['key2', 'key3', None], 50)\nTraceback (most recent call last):\n...\nbrain.interface.StructureError: Path ['key2', 'key3'] conflicts with existing structure\n</pre>\n</blockquote>\n<ul>\n<li>Autovivification, remove conflicts</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.insert(id1, ['key2', 'key3', None], 50, remove_conflicts=True)\n&gt;&gt;&gt; print(conn.read(id1))\n{'key2': {'key3': [50]}, 'key': [0, 1, 2, 3, 4]}\n</pre>\n</blockquote>\n<ul>\n<li>Insert several values at once</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.insertMany(id1, ['key2', 'key3', None], [51, 52, 53])\n&gt;&gt;&gt; print(conn.read(id1))\n{'key2': {'key3': [50, 51, 52, 53]}, 'key': [0, 1, 2, 3, 4]}\n</pre>\n</blockquote>\n<ul>\n<li>Insert data structure</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.insert(id1, ['key2', 'key3', None], {'subkey': 'val'})\n&gt;&gt;&gt; print(conn.read(id1))\n{'key2': {'key3': [50, 51, 52, 53, {'subkey': 'val'}]}, 'key': [0, 1, 2, 3, 4]}\n</pre>\n</blockquote>\n<ul>\n<li>Try to pass wrong path to insert()</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.insert(id1, ['key2', 'key3'], 'val')\nTraceback (most recent call last):\n...\nbrain.interface.FormatError: Last element of target field name should be None or integer\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-modify\">\n<h4><a href=\"#id27\" rel=\"nofollow\">Connection.modify()</a></h4>\n<p>Modify or create field in object.</p>\n<p><strong>Arguments</strong>: <tt>modify(id, path, value, remove_conflicts=None)</tt></p>\n<dl>\n<dt><tt>id</tt>:</dt>\n<dd>Target object ID.</dd>\n<dt><tt>path</tt>:</dt>\n<dd>Path where to store data.</dd>\n<dt><tt>value</tt>:</dt>\n<dd>Data to save at target path.</dd>\n<dt><tt>remove_conflicts</tt>:</dt>\n<dd><p>Determines the way conflicts of <tt>path</tt> with existing data structure are handled. Possible conflicts are:</p>\n<ul>\n<li><tt>path</tt> points to dictionary, when list already exists on the same level</li>\n<li><tt>path</tt> points to list, when dictionary already exists on the same level</li>\n<li><tt>path</tt> points to list or dictionary, when scalar value already exists on the same level</li>\n</ul>\n<p>If <tt>remove_conflicts</tt> equals <tt>True</tt>, all conflicting fields are deleted. In other words,\n<tt>modify()</tt> is guaranteed to finish successfully and the result of <tt>read(id, path)</tt> is\nguaranteed to be equal to <tt>value</tt>.</p>\n<p>If <tt>remove_conflicts</tt> equals <tt>False</tt>, <cite>StructureError</cite> is raised if conflict is found.</p>\n<p>If <tt>remove_conflicts</tt> equals None (default), the value given to <a href=\"#brain-connect\" rel=\"nofollow\">brain.connect()</a> is used.</p>\n</dd>\n</dl>\n<p><strong>Example</strong>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create({'key': 'val'})\n</pre>\n</blockquote>\n<ul>\n<li>Simple modification</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.modify(id1, ['key'], 'new_val')\n&gt;&gt;&gt; print(conn.read(id1))\n{'key': 'new_val'}\n</pre>\n</blockquote>\n<ul>\n<li>Save data structure in place of value</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.modify(id1, ['key'], [1, 2])\n&gt;&gt;&gt; print(conn.read(id1))\n{'key': [1, 2]}\n</pre>\n</blockquote>\n<ul>\n<li>Try to autovivify conflicting path without <tt>remove_conflicts</tt> set</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.modify(id1, ['key', 'key2'], 'val')\nTraceback (most recent call last):\n...\nbrain.interface.StructureError: Path ['key', 'key2'] conflicts with existing structure\n</pre>\n</blockquote>\n<ul>\n<li>Implicitly transform list remove <tt>[1, 2]</tt> using <tt>remove_conflicts</tt></li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.modify(id1, ['key', 'key2'], 'val', remove_conflicts=True)\n&gt;&gt;&gt; print(conn.read(id1))\n{'key': {'key2': 'val'}}\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-objectexists\">\n<h4><a href=\"#id28\" rel=\"nofollow\">Connection.objectExists()</a></h4>\n<p>Check if object with given ID exists.</p>\n<p><strong>Arguments</strong>: <tt>objectExists(id)</tt></p>\n<dl>\n<dt><tt>id</tt>:</dt>\n<dd>Object ID.</dd>\n</dl>\n<p><strong>Returns</strong>: True if object with given ID exists, False otherwise.</p>\n</div>\n<div id=\"connection-read-connection-readbymask-connection-readbymasks\">\n<span id=\"connection-readbymasks\"></span><span id=\"connection-readbymask\"></span><span id=\"connection-read\"></span><h4><a href=\"#id29\" rel=\"nofollow\">Connection.read(), Connection.readByMask, Connection.readByMasks()</a></h4>\n<p>Read contents of given object.</p>\n<dl>\n<dt><strong>Arguments</strong>:</dt>\n<dd><p><tt>read(id, path=None, masks=None)</tt></p>\n<p><tt>readByMask(id, mask=None)</tt></p>\n<p><tt>readByMasks(id, masks=None)</tt></p>\n</dd>\n</dl>\n<p><strong>Note</strong>: <tt>readByMask(id, mask)</tt> is an alias for <tt>readByMasks(id, [mask])</tt> and\n<tt>readByMasks(id, masks)</tt>, in turn, is an alias for <tt>read(id, None, masks)</tt>.</p>\n<dl>\n<dt><tt>id</tt>:</dt>\n<dd>Target object ID.</dd>\n<dt><tt>path</tt>:</dt>\n<dd><a href=\"#path\" rel=\"nofollow\">Path</a> to read from. Read from root by default.</dd>\n<dt><tt>masks</tt>:</dt>\n<dd>List of <a href=\"#paths\" rel=\"nofollow\">paths</a>; all results which do not have one of them in the beginning, will be filtered out.\nMasks are relative to <tt>path</tt>.</dd>\n</dl>\n<p><strong>Returns</strong>: resulting data structure.</p>\n<p><strong>Example</strong>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create({'tracks': [{'name': 'track 1', 'length': 240}, {'name': 'track 2', 'length': 300}]})\n</pre>\n</blockquote>\n<ul>\n<li>Read the whole object</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.read(id1))\n{'tracks': [{'length': 240, 'name': 'track 1'}, {'length': 300, 'name': 'track 2'}]}\n</pre>\n</blockquote>\n<ul>\n<li>Read from given path</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.read(id1, ['tracks', 0]))\n{'length': 240, 'name': 'track 1'}\n</pre>\n</blockquote>\n<ul>\n<li>Read by mask</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.readByMask(id1, ['tracks', None, 'length']))\n{'tracks': [{'length': 240}, {'length': 300}]}\n</pre>\n</blockquote>\n<ul>\n<li>Read from path, filter by mask. Note that mask is relative.</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.read(id1, ['tracks'], [[None, 'length']]))\n[{'length': 240}, {'length': 300}]\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-repair\">\n<h4><a href=\"#id30\" rel=\"nofollow\">Connection.repair()</a></h4>\n<p>Internal database structure includes some redundant tables, which are used to increase\ndatabase performance. This function can restore them based on actual field data stored in\ndatabase. It can be used when database requests (even <a href=\"#connection-read\" rel=\"nofollow\">Connection.read()</a>) are returning strange\nerrors with long call stack. These internal tables can be spoiled either by errors in logic\nor because of some errors in underlying SQL engine.</p>\n<p><strong>Arguments</strong>: <tt>repair()</tt></p>\n</div>\n<div id=\"connection-rollback\">\n<h4><a href=\"#id31\" rel=\"nofollow\">Connection.rollback()</a></h4>\n<p>Roll current transaction back. If transaction is not in progress, <a href=\"#facadeerror\" rel=\"nofollow\">FacadeError</a> will be raised.</p>\n<p><strong>Arguments</strong>: <tt>rollback()</tt></p>\n<p><strong>Example</strong>:</p>\n<ul>\n<li>Create and rollback transaction</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; conn.beginSync()\n&gt;&gt;&gt; conn.rollback()\n</pre>\n</blockquote>\n<ul>\n<li>Try to rollback non-existent transaction</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; conn.rollback()\nTraceback (most recent call last):\n...\nbrain.interface.FacadeError: Transaction is not in progress\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n<div id=\"connection-search\">\n<h4><a href=\"#id32\" rel=\"nofollow\">Connection.search()</a></h4>\n<p>Search for objects in database which satisfy given conditions.</p>\n<p><strong>Arguments</strong>: <tt>search(condition)</tt></p>\n<dl>\n<dt><tt>condition</tt>:</dt>\n<dd><p>One of three possibilities:</p>\n<ul>\n<li>List <tt>condition</tt></li>\n<li>Tuple <tt>condition</tt></li>\n<li>Empty list (only at root level, cannot be a part of condition)</li>\n</ul>\n<p>Simple <tt>condition</tt> is a list [<tt>brain.op.NOT</tt>, ] <a href=\"#path\" rel=\"nofollow\">path</a>, comparison_operator, value; complex\n<tt>condition</tt> is a list [<tt>brain.op.NOT</tt>, ] <tt>condition</tt>, [[logical_operator,\n[<tt>brain.op.NOT</tt>, ] <tt>condition</tt>, ] \u2026 ], where each <tt>condition</tt> can be either simple or complex.</p>\n<p>On the root level, you may not wrap condition in a list, but rather just pass\nit as a tuple of arguments to function.</p>\n<p>Logical_operator and comparison_operator - any <a href=\"#operators\" rel=\"nofollow\">operators</a>. Value should be a\nscalar of supported type. Note that different values support different type of\ncomparisons; see <a href=\"#brain-op\" rel=\"nofollow\">brain.op</a> reference for details.</p>\n<p>If <tt>condition</tt> is an empty list, it matches all existing object IDs in database.</p>\n<p>If condition uses path, not existing in some object, condition is considered\nto be false for this object if it does not contain <tt>brain.op.NOT</tt> and true\notherwise.</p>\n<p>Compound conditions are evaluated successively: <tt>[cond1, op1, cond2, op2, cond3]</tt> is evaluated\nas <tt>[[cond1, op1, cond2], op2, cond3]</tt>.</p>\n<p>In compound conditions <tt>NOT</tt> applies to the condition next to it:\n<tt>[NOT, cond1, op1, cond2, op2, NOT, cond3]</tt> is evaluated as\n<tt><span class=\"pre\">[[[NOT</span> cond1], op1, cond2], op2, [NOT, cond3]]</tt>.</p>\n</dd>\n</dl>\n<p><strong>Returns</strong>: list of object IDs, satisfying given conditions (note that order can\ndepend on DB engine).</p>\n<p><strong>Example</strong>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import brain.op as op\n&gt;&gt;&gt; conn = brain.connect(None, None)\n&gt;&gt;&gt; id1 = conn.create({'name': 'Alex', 'age': 22})\n&gt;&gt;&gt; id2 = conn.create({'name': 'Bob', 'height': 180, 'age': 25})\n&gt;&gt;&gt; id3 = conn.create({'name': 'Carl', 'height': 170, 'age': 26})\n</pre>\n</blockquote>\n<ul>\n<li>Empty condition</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(set(conn.search()) == set([id1, id2, id3]))\nTrue\n</pre>\n</blockquote>\n<ul>\n<li>Simple condition</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.search(['name'], op.EQ, 'Alex') == [id1])\nTrue\n</pre>\n</blockquote>\n<ul>\n<li>Compound condition</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(set(conn.search([['name'], op.EQ, 'Alex'], op.OR,\n... [['name'], op.EQ, 'Carl'])) == set([id1, id3]))\nTrue\n</pre>\n</blockquote>\n<ul>\n<li>Compound condition with negative</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(set(conn.search([['name'], op.EQ, 'Alex'], op.OR,\n... [op.NOT, ['name'], op.EQ, 'Carl'])) == set([id1, id2]))\nTrue\n</pre>\n</blockquote>\n<ul>\n<li>Condition with non-equality</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.search(['age'], op.GT, 25) == [id3])\nTrue\n</pre>\n</blockquote>\n<ul>\n<li>Condition with non-existent field</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.search([['name'], op.EQ, 'Alex'], op.AND,\n... [['height'], op.EQ, 180]) == [])\nTrue\n</pre>\n</blockquote>\n<ul>\n<li>Condition with non-existent field and negative</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.search([['name'], op.EQ, 'Alex'], op.AND,\n... [op.NOT, ['height'], op.EQ, 180]) == [id1])\nTrue\n</pre>\n</blockquote>\n<ul>\n<li>Long compound condition</li>\n</ul>\n<blockquote>\n<pre>&gt;&gt;&gt; print(conn.search([['name'], op.EQ, 'Alex'], op.OR,\n... [['age'], op.EQ, 25], op.AND,\n... [['height'], op.GT, 175]) == [id2])\nTrue\n&gt;&gt;&gt; conn.close()\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"cachedconnection\">\n<h3><a href=\"#id33\" rel=\"nofollow\">CachedConnection</a></h3>\n<p>This class wraps anything with <a href=\"#connection\" rel=\"nofollow\">Connection</a>-like interface and adds object caching.\nThe caching algorithm is rather simple, it speeds up only read operations (by keeping\ncopies of objects in memory).</p>\n<p><strong>Warning</strong>: This class can work incorrectly if more than one connection to database is opened.\nFor example, if the second connection changes something in database, the cache will not change\nand, therefore, read operation from the first connection will return the old value.</p>\n<p><strong>Arguments</strong>: <tt>CachedConnection(conn, size_threshold=0)</tt></p>\n<dl>\n<dt><tt>conn</tt>:</dt>\n<dd>Object with <a href=\"#connection\" rel=\"nofollow\">Connection</a> interface.</dd>\n<dt><tt>size_threshold</tt>:</dt>\n<dd>How many objects the cache must keep in memory. If zero, all accessed objects are kept.\nIf non-zero, specifies the number of most recently accessed object kept.</dd>\n</dl>\n</div>\n<div id=\"client\">\n<h3><a href=\"#id34\" rel=\"nofollow\">Client</a></h3>\n<p>XML RPC client for brain DB. Based on Python\u2019s built-in <tt>xmlrpc.client.ServerProxy</tt> and has the\nfollowing extensions:</p>\n<ul>\n<li>Supports keyword arguments to calls (adds dictionary with keyword argument to each method call)</li>\n<li>Unmarshalls known <a href=\"#exceptions\" rel=\"nofollow\">exceptions</a> from <tt>Faults</tt> returned by server</li>\n</ul>\n<p><strong>Arguments</strong>: <tt>Client(addr)</tt></p>\n<dl>\n<dt><tt>addr</tt>:</dt>\n<dd>Address to connect to.</dd>\n</dl>\n<div id=\"client-connect\">\n<h4><a href=\"#id35\" rel=\"nofollow\">Client.connect()</a></h4>\n<p>Connect to DB or create a new one.</p>\n<p><strong>Arguments</strong>: same as for <a href=\"#brain-connect\" rel=\"nofollow\">brain.connect()</a>.</p>\n<p><strong>Returns</strong>: <a href=\"#remoteconnection\" rel=\"nofollow\">RemoteConnection</a> object.</p>\n</div>\n<div id=\"client-getdefaultenginetag\">\n<h4><a href=\"#id36\" rel=\"nofollow\">Client.getDefaultEngineTag()</a></h4>\n<p>Same as <a href=\"#brain-getdefaultenginetag\" rel=\"nofollow\">brain.getDefaultEngineTag()</a>.</p>\n</div>\n<div id=\"client-getenginetags\">\n<h4><a href=\"#id37\" rel=\"nofollow\">Client.getEngineTags()</a></h4>\n<p>Same as <a href=\"#brain-getenginetags\" rel=\"nofollow\">brain.getEngineTags()</a>.</p>\n</div>\n</div>\n<div id=\"server\">\n<h3><a href=\"#id38\" rel=\"nofollow\">Server</a></h3>\n<p>XML RPC server for database. Based on Python\u2019s built-in <tt>xmlrpc.server.DocXMLRPCServer</tt>\nand extends standard XML RPC slightly: it supports keyword arguments to calls.\nThey are passed as the dictionary in additional argument to each function.\nIf function does not have any keyword arguments, empty dictionary is passed.</p>\n<p><strong>Arguments</strong>: <tt>Server(port=8000, name=None, db_path=None)</tt></p>\n<dl>\n<dt><tt>port</tt>:</dt>\n<dd>Port where server will wait for requests.</dd>\n<dt><tt>name</tt>:</dt>\n<dd>Server thread name.</dd>\n<dt><tt>db_path</tt>:</dt>\n<dd>Will be used with DB engines, which store information in files - <tt>db_path</tt> will serve as\na prefix to each created DB file.</dd>\n</dl>\n<div id=\"server-start\">\n<span id=\"start\"></span><h4><a href=\"#id39\" rel=\"nofollow\">Server.start()</a></h4>\n<p>Start server in a separate thread. Returns instantly.</p>\n<p><strong>Arguments</strong>: <tt>start()</tt></p>\n</div>\n<div id=\"server-stop\">\n<span id=\"stop\"></span><h4><a href=\"#id40\" rel=\"nofollow\">Server.stop()</a></h4>\n<p>Shutdown server and wait for its thread to stop.</p>\n<p><strong>Arguments</strong>: <tt>stop()</tt></p>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 721837, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "59e80911237be8a2f4b11c0a537e55df", "sha256": "4b3ec7be60d247efdbc20d1956eb9cc25795eaedeee185307b8e40d927893779"}, "downloads": -1, "filename": "brain-0.1.0.tar.gz", "has_sig": false, "md5_digest": "59e80911237be8a2f4b11c0a537e55df", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58368, "upload_time": "2009-08-23T13:28:22", "upload_time_iso_8601": "2009-08-23T13:28:22.112462Z", "url": "https://files.pythonhosted.org/packages/51/c1/8bb683fb0dcbb6a1a267bd61555f2b106bd2d0e6e0e14b2d7ebba53bf4a4/brain-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "d1b8e1d74932a8593ca478eed421ab3b", "sha256": "81df35addfcd9a6295e22ea23d495e3888824b0669ec2b90033c8359dad5d82e"}, "downloads": -1, "filename": "brain-0.1.1.tar.gz", "has_sig": false, "md5_digest": "d1b8e1d74932a8593ca478eed421ab3b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 70883, "upload_time": "2009-08-24T22:28:17", "upload_time_iso_8601": "2009-08-24T22:28:17.543612Z", "url": "https://files.pythonhosted.org/packages/38/9b/7d659f53aa2d69431b58fceff03f3320acdc686055ca50e392fc9960e653/brain-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "c8c04fb48acab94c39e09690156e7359", "sha256": "7eb406889b4daf1633114dd22813d4f079cd28759590ee135fb04c012f8952c9"}, "downloads": -1, "filename": "brain-0.1.2.tar.gz", "has_sig": false, "md5_digest": "c8c04fb48acab94c39e09690156e7359", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 71458, "upload_time": "2009-08-28T21:18:37", "upload_time_iso_8601": "2009-08-28T21:18:37.754536Z", "url": "https://files.pythonhosted.org/packages/7b/45/e28b968770a5b04e9f8d3c7d1ef9749ffa3205d6dee633b5a2c210b6537c/brain-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "3a8324c9413fc5cf173a06cc10e8472d", "sha256": "e168790d1c915233a9979600123bedaea1991e08b7cf1b163da9f94cd0dc6c12"}, "downloads": -1, "filename": "brain-0.1.3.tar.gz", "has_sig": false, "md5_digest": "3a8324c9413fc5cf173a06cc10e8472d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 74371, "upload_time": "2009-09-07T21:34:43", "upload_time_iso_8601": "2009-09-07T21:34:43.693659Z", "url": "https://files.pythonhosted.org/packages/d4/5c/ca4a1dd300eb099f663f4b3de1c78eb78c2cb2c71d1e9f09492f7a3a29fd/brain-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "a20a730edc2359ac4b31d316f96ad33a", "sha256": "6d08dce4e9fa53601def27032f11aed84b8b5a41256264efa046e097e585cdb8"}, "downloads": -1, "filename": "brain-0.1.4.tar.gz", "has_sig": false, "md5_digest": "a20a730edc2359ac4b31d316f96ad33a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 87880, "upload_time": "2009-11-06T11:11:19", "upload_time_iso_8601": "2009-11-06T11:11:19.383854Z", "url": "https://files.pythonhosted.org/packages/19/7a/4867a6cc5083769f45451582c3b8c70c4e88bd03fbe42519630bde4de0b5/brain-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "acf10636d8c5de591adc4605778c8f5a", "sha256": "56fc40edb7a5dbde87aa31d30eaacbb90febd90e45ef4c911e2e339aa6f825c0"}, "downloads": -1, "filename": "brain-0.1.5.tar.gz", "has_sig": false, "md5_digest": "acf10636d8c5de591adc4605778c8f5a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 92102, "upload_time": "2009-11-06T11:06:36", "upload_time_iso_8601": "2009-11-06T11:06:36.209567Z", "url": "https://files.pythonhosted.org/packages/58/0b/115e580fff9d89bf9e28a50028b13bbfa87eefa0efeefb38b97b6923e2f8/brain-0.1.5.tar.gz", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "0d2aba74f36f19007a192d4569858f29", "sha256": "989755a28a8b1382dee5466d7d404a1611cb59a90f7d8b4d64f8c8849c9c53bf"}, "downloads": -1, "filename": "brain-0.1.6.tar.gz", "has_sig": false, "md5_digest": "0d2aba74f36f19007a192d4569858f29", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 81654, "upload_time": "2009-12-01T12:37:46", "upload_time_iso_8601": "2009-12-01T12:37:46.360739Z", "url": "https://files.pythonhosted.org/packages/09/55/cf895bd5a04469973ed9e5f166018019ad29d68498c85770fe52afadb096/brain-0.1.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0d2aba74f36f19007a192d4569858f29", "sha256": "989755a28a8b1382dee5466d7d404a1611cb59a90f7d8b4d64f8c8849c9c53bf"}, "downloads": -1, "filename": "brain-0.1.6.tar.gz", "has_sig": false, "md5_digest": "0d2aba74f36f19007a192d4569858f29", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 81654, "upload_time": "2009-12-01T12:37:46", "upload_time_iso_8601": "2009-12-01T12:37:46.360739Z", "url": "https://files.pythonhosted.org/packages/09/55/cf895bd5a04469973ed9e5f166018019ad29d68498c85770fe52afadb096/brain-0.1.6.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:36:25 2020"}