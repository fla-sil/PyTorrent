{"info": {"author": "Gary Poster", "author_email": "gary@zope.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Zope Public License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython"], "description": "================\nRelation Catalog\n================\n\n.. contents::\n\nOverview\n========\n\nThe relation catalog can be used to optimize intransitive and transitive\nsearches for N-ary relations of finite, preset dimensions.\n\nFor example, you can index simple two-way relations, like employee to\nsupervisor; RDF-style triples of subject-predicate-object; and more complex\nrelations such as subject-predicate-object with context and state.  These\ncan be searched with variable definitions of transitive behavior.\n\nThe catalog can be used in the ZODB or standalone. It is a generic, relatively\npolicy-free tool.\n\nIt is expected to be used usually as an engine for more specialized and\nconstrained tools and APIs. Three such tools are zc.relationship containers,\nplone.relations containers, and zc.vault. The documents in the package,\nincluding this one, describe other possible uses.\n\nHistory\n=======\n\nThis is a refactoring of the ZODB-only parts of the zc.relationship package.\nSpecifically, the zc.relation catalog is largely equivalent to the\nzc.relationship index. The index in the zc.relationship 2.x line is an\nalmost-completely backwards-compatible wrapper of the zc.relation catalog.\nzc.relationship will continue to be maintained, though active development is\nexpected to go into zc.relation.\n\nMany of the ideas come from discussions with and code from Casey Duncan, Tres\nSeaver, Ken Manheimer, and more.\n\nSetting Up a Relation Catalog\n=============================\n\nIn this section, we will be introducing the following ideas.\n\n- Relations are objects with indexed values.\n\n- You add value indexes to relation catalogs to be able to search.  Values\n  can be identified to the catalog with callables or interface elements. The\n  indexed value must be specified to the catalog as a single value or a\n  collection.\n\n- Relations and their values are stored in the catalog as tokens: unique\n  identifiers that you can resolve back to the original value. Integers are the\n  most efficient tokens, but others can work fine too.\n\n- Token type determines the BTree module needed.\n\n- You must define your own functions for tokenizing and resolving tokens. These\n  functions are registered with the catalog for the relations and for each of\n  their value indexes.\n\n- Relations are indexed with ``index``.\n\nWe will use a simple two way relation as our example here. A brief introduction\nto a more complex RDF-style subject-predicate-object set up can be found later\nin the document.\n\nCreating the Catalog\n--------------------\n\nImagine a two way relation from one value to another.  Let's say that we\nare modeling a relation of people to their supervisors: an employee may\nhave a single supervisor.  For this first example, the relation between\nemployee and supervisor will be intrinsic: the employee has a pointer to\nthe supervisor, and the employee object itself represents the relation.\n\nLet's say further, for simplicity, that employee names are unique and\ncan be used to represent employees.  We can use names as our \"tokens\".\n\nTokens are similar to the primary key in a relational database. A token is a\nway to identify an object. It must sort reliably and you must be able to write\na callable that reliably resolves to the object given the right context. In\nZope 3, intids (zope.app.intid) and keyreferences (zope.app.keyreference) are\ngood examples of reasonable tokens.\n\nAs we'll see below, you provide a way to convert objects to tokens, and resolve\ntokens to objects, for the relations, and for each value index individually.\nThey can be the all the same functions or completely different, depending on\nyour needs.\n\nFor speed, integers make the best tokens; followed by other\nimmutables like strings; followed by non-persistent objects; followed by\npersistent objects.  The choice also determines a choice of BTree module, as\nwe'll see below.\n\nHere is our toy ``Employee`` example class.  Again, we will use the employee\nname as the tokens.\n\n    >>> employees = {} # we'll use this to resolve the \"name\" tokens\n    >>> from functools import total_ordering\n    >>> @total_ordering\n    ... class Employee(object):\n    ...     def __init__(self, name, supervisor=None):\n    ...         if name in employees:\n    ...             raise ValueError('employee with same name already exists')\n    ...         self.name = name # expect this to be readonly\n    ...         self.supervisor = supervisor\n    ...         employees[name] = self\n    ...     # the next parts just make the tests prettier\n    ...     def __repr__(self):\n    ...         return '<Employee instance \"' + self.name + '\">'\n    ...     def __lt__(self, other):\n    ...         return self.name < other.name\n    ...     def __eq__(self, other):\n    ...         return self is other\n    ...     def __hash__(self):\n    ...         ''' Dummy method needed because we defined __eq__\n    ...         '''\n    ...         return 1\n    ...\n\nSo, we need to define how to turn employees into their tokens.  We call the\ntokenization a \"dump\" function. Conversely, the function to resolve tokens into\nobjects is called a \"load\".\n\nFunctions to dump relations and values get several arguments. The first\nargument is the object to be tokenized. Next, because it helps sometimes to\nprovide context, is the catalog. The last argument is a dictionary that will be\nshared for a given search. The dictionary can be ignored, or used as a cache\nfor optimizations (for instance, to stash a utility that you looked up).\n\nFor this example, our function is trivial: we said the token would be\nthe employee's name.\n\n    >>> def dumpEmployees(emp, catalog, cache):\n    ...     return emp.name\n    ...\n\nIf you store the relation catalog persistently (e.g., in the ZODB) be aware\nthat the callables you provide must be picklable--a module-level function,\nfor instance.\n\nWe also need a way to turn tokens into employees, or \"load\".\n\nThe \"load\" functions get the token to be resolved; the catalog, for\ncontext; and a dict cache, for optimizations of subsequent calls.\n\nYou might have noticed in our ``Employee.__init__`` that we keep a mapping\nof name to object in the ``employees`` global dict (defined right above\nthe class definition).  We'll use that for resolving the tokens.\n\n    >>> def loadEmployees(token, catalog, cache):\n    ...     return employees[token]\n    ...\n\nNow we know enough to get started with a catalog.  We'll instantiate it\nby specifying how to tokenize relations, and what kind of BTree modules\nshould be used to hold the tokens.\n\nHow do you pick BTree modules?\n\n- If the tokens are 32-bit ints, choose ``BTrees.family32.II``,\n  ``BTrees.family32.IF`` or ``BTrees.family32.IO``.\n\n- If the tokens are 64 bit ints, choose ``BTrees.family64.II``,\n  ``BTrees.family64.IF`` or ``BTrees.family64.IO``.\n\n- If they are anything else, choose ``BTrees.family32.OI``,\n  ``BTrees.family64.OI``, or ``BTrees.family32.OO`` (or\n  ``BTrees.family64.OO``--they are the same).\n\nWithin these rules, the choice is somewhat arbitrary unless you plan to merge\nthese results with that of another source that is using a particular BTree\nmodule. BTree set operations only work within the same module, so you must\nmatch module to module. The catalog defaults to IF trees, because that's what\nstandard zope catalogs use. That's as reasonable a choice as any, and will\npotentially come in handy if your tokens are in fact the same as those used by\nthe zope catalog and you want to do some set operations.\n\nIn this example, our tokens are strings, so we want OO or an OI variant.  We'll\nchoose BTrees.family32.OI, arbitrarily.\n\n    >>> import zc.relation.catalog\n    >>> import BTrees\n    >>> catalog = zc.relation.catalog.Catalog(dumpEmployees, loadEmployees,\n    ...                                       btree=BTrees.family32.OI)\n\n[#verifyObjectICatalog]_\n\n.. [#verifyObjectICatalog] The catalog provides ICatalog.\n\n    >>> from zope.interface.verify import verifyObject\n    >>> import zc.relation.interfaces\n    >>> verifyObject(zc.relation.interfaces.ICatalog, catalog)\n    True\n\n[#legacy]_\n\n\n.. [#legacy] Old instances of zc.relationship indexes, which in the newest\n    version subclass a zc.relation Catalog, used to have a dict in an\n    internal data structure.  We specify that here so that the code that\n    converts the dict to an OOBTree can have a chance to run.\n\n    >>> catalog._attrs = dict(catalog._attrs)\n\nLook! A relation catalog! We can't do very\nmuch searching with it so far though, because the catalog doesn't have any\nindexes.\n\nIn this example, the relation itself represents the employee, so we won't need\nto index that separately.\n\nBut we do need a way to tell the catalog how to find the other end of the\nrelation, the supervisor. You can specify this to the catalog with an attribute\nor method specified from ``zope.interface Interface``, or with a callable.\nWe'll use a callable for now. The callable will receive the indexed relation\nand the catalog for context.\n\n    >>> def supervisor(emp, catalog):\n    ...     return emp.supervisor # None or another employee\n    ...\n\nWe'll also need to specify how to tokenize (dump and load) those values. In\nthis case, we're able to use the same functions as the relations themselves.\nHowever, do note that we can specify a completely different way to dump and\nload for each \"value index,\" or relation element.\n\nWe could also specify the name to call the index, but it will default to the\n``__name__`` of the function (or interface element), which will work just fine\nfor us now.\n\nNow we can add the \"supervisor\" value index.\n\n    >>> catalog.addValueIndex(supervisor, dumpEmployees, loadEmployees,\n    ...                       btree=BTrees.family32.OI)\n\nNow we have an index [#addValueIndexExceptions]_.\n\n.. [#addValueIndexExceptions] Adding a value index can generate several\n    exceptions.\n\n    You must supply both of dump and load or neither.\n\n    >>> catalog.addValueIndex(supervisor, dumpEmployees, None,\n    ...                       btree=BTrees.family32.OI, name='supervisor2')\n    Traceback (most recent call last):\n    ...\n    ValueError: either both of 'dump' and 'load' must be None, or neither\n\n    In this example, even if we fix it, we'll get an error, because we have\n    already indexed the supervisor function.\n\n    >>> catalog.addValueIndex(supervisor, dumpEmployees, loadEmployees,\n    ...                       btree=BTrees.family32.OI, name='supervisor2')\n    ... # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    ValueError: ('element already indexed', <function supervisor at ...>)\n\n    You also can't add a different function under the same name.\n\n    >>> def supervisor2(emp, catalog):\n    ...     return emp.supervisor # None or another employee\n    ...\n    >>> catalog.addValueIndex(supervisor2, dumpEmployees, loadEmployees,\n    ...                       btree=BTrees.family32.OI, name='supervisor')\n    ... # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    ValueError: ('name already used', 'supervisor')\n\n    Finally, if your function does not have a ``__name__`` and you do not\n    provide one, you may not add an index.\n\n    >>> class Supervisor3(object):\n    ...     __name__ = None\n    ...     def __call__(klass, emp, catalog):\n    ...         return emp.supervisor\n    ...\n    >>> supervisor3 = Supervisor3()\n    >>> supervisor3.__name__\n    >>> catalog.addValueIndex(supervisor3, dumpEmployees, loadEmployees,\n    ...                       btree=BTrees.family32.OI)\n    ... # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    ValueError: no name specified\n\n    >>> [info['name'] for info in catalog.iterValueIndexInfo()]\n    ['supervisor']\n\nAdding Relations\n----------------\n\nNow let's create a few employees.  All but one will have supervisors.\nIf you recall our toy ``Employee`` class, the first argument to the\nconstructor is the employee name (and therefore the token), and the\noptional second argument is the supervisor.\n\n    >>> a = Employee('Alice')\n    >>> b = Employee('Betty', a)\n    >>> c = Employee('Chuck', a)\n    >>> d = Employee('Diane', b)\n    >>> e = Employee('Edgar', b)\n    >>> f = Employee('Frank', c)\n    >>> g = Employee('Galyn', c)\n    >>> h = Employee('Howie', d)\n\nHere is a diagram of the hierarchy.\n\n::\n\n                Alice\n             __/     \\__\n        Betty           Chuck\n        /   \\           /   \\\n    Diane   Edgar   Frank   Galyn\n      |\n    Howie\n\nLet's tell the catalog about the relations, using the ``index`` method.\n\n    >>> for emp in (a,b,c,d,e,f,g,h):\n    ...     catalog.index(emp)\n    ...\n\nWe've now created the relation catalog and added relations to it. We're ready\nto search!\n\nSearching\n=========\n\nIn this section, we will introduce the following ideas.\n\n- Queries to the relation catalog are formed with dicts.\n\n- Query keys are the names of the indexes you want to search, or, for the\n  special case of precise relations, the ``zc.relation.RELATION`` constant.\n\n- Query values are the tokens of the results you want to match; or ``None``,\n  indicating relations that have ``None`` as a value (or an empty collection,\n  if it is a multiple). Search values can use\n  ``zc.relation.catalog.any(args)`` or ``zc.relation.catalog.Any(args)`` to\n  specify multiple (non-``None``) results to match for a given key.\n\n- The index has a variety of methods to help you work with tokens.\n  ``tokenizeQuery`` is typically the most used, though others are available.\n\n- To find relations that match a query, use ``findRelations`` or\n  ``findRelationTokens``.\n\n- To find values that match a query, use ``findValues`` or ``findValueTokens``.\n\n- You search transitively by using a query factory. The\n  ``zc.relation.queryfactory.TransposingTransitive`` is a good common case\n  factory that lets you walk up and down a hierarchy. A query factory can be\n  passed in as an argument to search methods as a ``queryFactory``, or\n  installed as a default behavior using ``addDefaultQueryFactory``.\n\n- To find how a query is related, use ``findRelationChains`` or\n  ``findRelationTokenChains``.\n\n- To find out if a query is related, use ``canFind``.\n\n- Circular transitive relations are handled to prevent infinite loops. They\n  are identified in ``findRelationChains`` and ``findRelationTokenChains`` with\n  a ``zc.relation.interfaces.ICircularRelationPath`` marker interface.\n\n- search methods share the following arguments:\n\n  * ``maxDepth``, limiting the transitive depth for searches;\n\n  * ``filter``, allowing code to filter transitive paths;\n\n  * ``targetQuery``, allowing a query to filter transitive paths on the basis\n    of the endpoint;\n\n  * ``targetFilter``, allowing code to filter transitive paths on the basis of\n    the endpoint; and\n\n  * ``queryFactory``, mentioned above.\n\n- You can set up search indexes to speed up specific transitive searches.\n\nQueries, ``findRelations``, and special query values\n----------------------------------------------------\n\nSo who works for Alice?  That means we want to get the relations--the\nemployees--with a ``supervisor`` of Alice.\n\nThe heart of a question to the catalog is a query.  A query is spelled\nas a dictionary.  The main idea is simply that keys in a dictionary\nspecify index names, and the values specify the constraints.\n\nThe values in a query are always expressed with tokens.  The catalog has\nseveral helpers to make this less onerous, but for now let's take\nadvantage of the fact that our tokens are easily comprehensible.\n\n    >>> sorted(catalog.findRelations({'supervisor': 'Alice'}))\n    [<Employee instance \"Betty\">, <Employee instance \"Chuck\">]\n\nAlice is the direct (intransitive) boss of Betty and Chuck.\n\nWhat if you want to ask \"who doesn't report to anyone?\"  Then you want to\nask for a relation in which the supervisor is None.\n\n    >>> list(catalog.findRelations({'supervisor': None}))\n    [<Employee instance \"Alice\">]\n\nAlice is the only employee who doesn't report to anyone.\n\nWhat if you want to ask \"who reports to Diane or Chuck?\"  Then you use the\nzc.relation ``Any`` class or ``any`` function to pass the multiple values.\n\n    >>> sorted(catalog.findRelations(\n    ...     {'supervisor': zc.relation.catalog.any('Diane', 'Chuck')}))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [<Employee instance \"Frank\">, <Employee instance \"Galyn\">,\n     <Employee instance \"Howie\">]\n\nFrank, Galyn, and Howie each report to either Diane or Chuck. [#any]_\n\n.. [#any] ``Any`` can be compared.\n\n    >>> zc.relation.catalog.any('foo', 'bar', 'baz')\n    <zc.relation.catalog.Any instance ('bar', 'baz', 'foo')>\n    >>> (zc.relation.catalog.any('foo', 'bar', 'baz') ==\n    ...  zc.relation.catalog.any('bar', 'foo', 'baz'))\n    True\n    >>> (zc.relation.catalog.any('foo', 'bar', 'baz') !=\n    ...  zc.relation.catalog.any('bar', 'foo', 'baz'))\n    False\n    >>> (zc.relation.catalog.any('foo', 'bar', 'baz') ==\n    ...  zc.relation.catalog.any('foo', 'baz'))\n    False\n    >>> (zc.relation.catalog.any('foo', 'bar', 'baz') !=\n    ...  zc.relation.catalog.any('foo', 'baz'))\n    True\n\n\n\n``findValues`` and the ``RELATION`` query key\n---------------------------------------------\n\nSo how do we find who an employee's supervisor is?  Well, in this case,\nlook at the attribute on the employee!  If you can use an attribute that\nwill usually be a win in the ZODB.\n\n    >>> h.supervisor\n    <Employee instance \"Diane\">\n\nAgain, as we mentioned at the start of this first example, the knowledge\nof a supervisor is \"intrinsic\" to the employee instance.  It is\npossible, and even easy, to ask the catalog this kind of question, but\nthe catalog syntax is more geared to \"extrinsic\" relations, such as the\none from the supervisor to the employee: the connection between a\nsupervisor object and its employees is extrinsic to the supervisor, so\nyou actually might want a catalog to find it!\n\nHowever, we will explore the syntax very briefly, because it introduces an\nimportant pair of search methods, and because it is a stepping stone\nto our first transitive search.\n\nSo, o relation catalog, who is Howie's supervisor?\n\nTo ask this question we want to get the indexed values off of the relations:\n``findValues``. In its simplest form, the arguments are the index name of the\nvalues you want, and a query to find the relations that have the desired\nvalues.\n\nWhat about the query? Above, we noted that the keys in a query are the names of\nthe indexes to search. However, in this case, we don't want to search one or\nmore indexes for matching relations, as usual, but actually specify a relation:\nHowie.\n\nWe do not have a value index name: we are looking for a relation. The query\nkey, then, should be the constant ``zc.relation.RELATION``. For our current\nexample, that would mean the query is ``{zc.relation.RELATION: 'Howie'}``.\n\n    >>> import zc.relation\n    >>> list(catalog.findValues(\n    ...     'supervisor', {zc.relation.RELATION: 'Howie'}))[0]\n    <Employee instance \"Diane\">\n\nCongratulations, you just found an obfuscated and comparitively\ninefficient way to write ``howie.supervisor``! [#intrinsic_search]_\n\n.. [#intrinsic_search] Here's the same with token results.\n\n    >>> list(catalog.findValueTokens('supervisor',\n    ...                              {zc.relation.RELATION: 'Howie'}))\n    ['Diane']\n\n    While we're down here in the footnotes, I'll mention that you can\n    search for relations that haven't been indexed.\n\n    >>> list(catalog.findRelationTokens({zc.relation.RELATION: 'Ygritte'}))\n    []\n    >>> list(catalog.findRelations({zc.relation.RELATION: 'Ygritte'}))\n    []\n\n[#findValuesExceptions]_\n\n\n.. [#findValuesExceptions] If you use ``findValues`` or ``findValueTokens`` and\n    try to specify a value name that is not indexed, you get a ValueError.\n\n    >>> catalog.findValues('foo')\n    Traceback (most recent call last):\n    ...\n    ValueError: ('name not indexed', 'foo')\n\n\nSlightly more usefully, you can use other query keys along with\nzc.relation.RELATION. This asks, \"Of Betty, Alice, and Frank, who are\nsupervised by Alice?\"\n\n    >>> sorted(catalog.findRelations(\n    ...     {zc.relation.RELATION: zc.relation.catalog.any(\n    ...         'Betty', 'Alice', 'Frank'),\n    ...      'supervisor': 'Alice'}))\n    [<Employee instance \"Betty\">]\n\nOnly Betty is.\n\nTokens\n------\n\nAs mentioned above, the catalog provides several helpers to work with tokens.\nThe most frequently used is ``tokenizeQuery``, which takes a query with object\nvalues and converts them to tokens using the \"dump\" functions registered for\nthe relations and indexed values. Here are alternate spellings of some of the\nqueries we've encountered above.\n\n    >>> catalog.tokenizeQuery({'supervisor': a})\n    {'supervisor': 'Alice'}\n    >>> catalog.tokenizeQuery({'supervisor': None})\n    {'supervisor': None}\n    >>> import pprint\n    >>> result = catalog.tokenizeQuery(\n    ...     {zc.relation.RELATION: zc.relation.catalog.any(a, b, f),\n    ...     'supervisor': a}) # doctest: +NORMALIZE_WHITESPACE\n    >>> pprint.pprint(result)\n    {None: <zc.relation.catalog.Any instance ('Alice', 'Betty', 'Frank')>,\n     'supervisor': 'Alice'}\n\n(If you are wondering about that ``None`` in the last result, yes,\n``zc.relation.RELATION`` is just readability sugar for ``None``.)\n\nSo, here's a real search using ``tokenizeQuery``.  We'll make an alias for\n``catalog.tokenizeQuery`` just to shorten things up a bit.\n\n    >>> query = catalog.tokenizeQuery\n    >>> sorted(catalog.findRelations(query(\n    ...     {zc.relation.RELATION: zc.relation.catalog.any(a, b, f),\n    ...      'supervisor': a})))\n    [<Employee instance \"Betty\">]\n\nThe catalog always has parallel search methods, one for finding objects, as\nseen above, and one for finding tokens (the only exception is ``canFind``,\ndescribed below). Finding tokens can be much more efficient, especially if the\nresult from the relation catalog is just one step along the path of finding\nyour desired result. But finding objects is simpler for some common cases.\nHere's a quick example of some queries above, getting tokens rather than\nobjects.\n\nYou can also spell a query in ``tokenizeQuery`` with keyword arguments. This\nwon't work if your key is ``zc.relation.RELATION``, but otherwise it can\nimprove readability. We'll see some examples of this below as well.\n\n    >>> sorted(catalog.findRelationTokens(query(supervisor=a)))\n    ['Betty', 'Chuck']\n\n    >>> sorted(catalog.findRelationTokens({'supervisor': None}))\n    ['Alice']\n\n    >>> sorted(catalog.findRelationTokens(\n    ...     query(supervisor=zc.relation.catalog.any(c, d))))\n    ['Frank', 'Galyn', 'Howie']\n\n    >>> sorted(catalog.findRelationTokens(\n    ...     query({zc.relation.RELATION: zc.relation.catalog.any(a, b, f),\n    ...            'supervisor': a})))\n    ['Betty']\n\nThe catalog provides several other methods just for working with tokens.\n\n- ``resolveQuery``: the inverse of ``tokenizeQuery``, converting a\n  tokenizedquery to a query with objects.\n\n- ``tokenizeValues``: returns an iterable of tokens for the values of the given\n  index name.\n\n- ``resolveValueTokens``: returns an iterable of values for the tokens of the\n  given index name.\n\n- ``tokenizeRelation``: returns a token for the given relation.\n\n- ``resolveRelationToken``: returns a relation for the given token.\n\n- ``tokenizeRelations``: returns an iterable of tokens for the relations given.\n\n- ``resolveRelationTokens``: returns an iterable of relations for the tokens\n  given.\n\nThese methods are lesser used, and described in more technical documents in\nthis package.\n\nTransitive Searching, Query Factories, and ``maxDepth``\n-------------------------------------------------------\n\nSo, we've seen a lot of one-level, intransitive searching. What about\ntransitive searching? Well, you need to tell the catalog how to walk the tree.\nIn simple (and very common) cases like this, the\n``zc.relation.queryfactory.TransposingTransitive`` will do the trick.\n\nA transitive query factory is just a callable that the catalog uses to\nask \"I got this query, and here are the results I found. I'm supposed to\nwalk another step transitively, so what query should I search for next?\"\nWriting a factory is more complex than we want to talk about right now,\nbut using the ``TransposingTransitiveQueryFactory`` is easy. You just tell\nit the two query names it should transpose for walking in either\ndirection.\n\nFor instance, here we just want to tell the factory to transpose the two keys\nwe've used, ``zc.relation.RELATION`` and 'supervisor'. Let's make a factory,\nuse it in a query for a couple of transitive searches, and then, if you want,\nyou can read through a footnote to talk through what is happening.\n\nHere's the factory.\n\n    >>> import zc.relation.queryfactory\n    >>> factory = zc.relation.queryfactory.TransposingTransitive(\n    ...     zc.relation.RELATION, 'supervisor')\n\nNow ``factory`` is just a callable.  Let's let it help answer a couple of\nquestions.\n\nWho are all of Howie's supervisors transitively (this looks up in the\ndiagram)?\n\n    >>> list(catalog.findValues('supervisor', {zc.relation.RELATION: 'Howie'},\n    ...      queryFactory=factory))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [<Employee instance \"Diane\">, <Employee instance \"Betty\">,\n     <Employee instance \"Alice\">]\n\nWho are all of the people Betty supervises transitively, breadth first (this\nlooks down in the diagram)?\n\n    >>> people = list(catalog.findRelations(\n    ...     {'supervisor': 'Betty'}, queryFactory=factory))\n    >>> sorted(people[:2])\n    [<Employee instance \"Diane\">, <Employee instance \"Edgar\">]\n    >>> people[2]\n    <Employee instance \"Howie\">\n\nYup, that looks right.  So how did that work?  If you care, read this\nfootnote. [#I_care]_\n\nThis transitive factory is really the only transitive factory you would\nwant for this particular catalog, so it probably is safe to wire it in\nas a default.  You can add multiple query factories to match different\nqueries using ``addDefaultQueryFactory``.\n\n    >>> catalog.addDefaultQueryFactory(factory)\n\nNow all searches are transitive by default.\n\n    >>> list(catalog.findValues('supervisor', {zc.relation.RELATION: 'Howie'}))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [<Employee instance \"Diane\">, <Employee instance \"Betty\">,\n     <Employee instance \"Alice\">]\n    >>> people = list(catalog.findRelations({'supervisor': 'Betty'}))\n    >>> sorted(people[:2])\n    [<Employee instance \"Diane\">, <Employee instance \"Edgar\">]\n    >>> people[2]\n    <Employee instance \"Howie\">\n\nWe can force a non-transitive search, or a specific search depth, with\n``maxDepth`` [#needs_a_transitive_queries_factory]_.\n\n\n.. [#needs_a_transitive_queries_factory] A search with a ``maxDepth`` > 1 but\n    no ``queryFactory`` raises an error.\n\n    >>> catalog.removeDefaultQueryFactory(factory)\n    >>> catalog.findRelationTokens({'supervisor': 'Diane'}, maxDepth=3)\n    Traceback (most recent call last):\n    ...\n    ValueError: if maxDepth not in (None, 1), queryFactory must be available\n\n    >>> catalog.addDefaultQueryFactory(factory)\n\n    >>> list(catalog.findValues(\n    ...     'supervisor', {zc.relation.RELATION: 'Howie'}, maxDepth=1))\n    [<Employee instance \"Diane\">]\n    >>> sorted(catalog.findRelations({'supervisor': 'Betty'}, maxDepth=1))\n    [<Employee instance \"Diane\">, <Employee instance \"Edgar\">]\n\n[#maxDepthExceptions]_\n\n\n.. [#maxDepthExceptions] ``maxDepth`` must be None or a positive integer, or\n    else you'll get a value error.\n\n    >>> catalog.findRelations({'supervisor': 'Betty'}, maxDepth=0)\n    Traceback (most recent call last):\n    ...\n    ValueError: maxDepth must be None or a positive integer\n\n    >>> catalog.findRelations({'supervisor': 'Betty'}, maxDepth=-1)\n    Traceback (most recent call last):\n    ...\n    ValueError: maxDepth must be None or a positive integer\n\nWe'll introduce some other available search\narguments later in this document and in other documents.  It's important\nto note that *all search methods share the same arguments as\n``findRelations``*.  ``findValues`` and ``findValueTokens`` only add the\ninitial argument of specifying the desired value.\n\nWe've looked at two search methods so far: the ``findValues`` and\n``findRelations`` methods help you ask what is related.  But what if you\nwant to know *how* things are transitively related?\n\n``findRelationChains`` and ``targetQuery``\n------------------------------------------\n\nAnother search method, ``findRelationChains``, helps you discover how\nthings are transitively related.\n\nThe method name says \"find relation chains\".  But what is a \"relation\nchain\"?  In this API, it is a transitive path of relations.  For\ninstance, what's the chain of command above Howie?  ``findRelationChains``\nwill return each unique path.\n\n    >>> list(catalog.findRelationChains({zc.relation.RELATION: 'Howie'}))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [(<Employee instance \"Howie\">,),\n     (<Employee instance \"Howie\">, <Employee instance \"Diane\">),\n     (<Employee instance \"Howie\">, <Employee instance \"Diane\">,\n      <Employee instance \"Betty\">),\n     (<Employee instance \"Howie\">, <Employee instance \"Diane\">,\n     <Employee instance \"Betty\">, <Employee instance \"Alice\">)]\n\nLook at that result carefully.  Notice that the result is an iterable of\ntuples.  Each tuple is a unique chain, which may be a part of a\nsubsequent chain.  In this case, the last chain is the longest and the\nmost comprehensive.\n\nWhat if we wanted to see all the paths from Alice?  That will be one\nchain for each supervised employee, because it shows all possible paths.\n\n    >>> sorted(catalog.findRelationChains(\n    ...     {'supervisor': 'Alice'}))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [(<Employee instance \"Betty\">,),\n     (<Employee instance \"Betty\">, <Employee instance \"Diane\">),\n     (<Employee instance \"Betty\">, <Employee instance \"Diane\">,\n      <Employee instance \"Howie\">),\n     (<Employee instance \"Betty\">, <Employee instance \"Edgar\">),\n     (<Employee instance \"Chuck\">,),\n     (<Employee instance \"Chuck\">, <Employee instance \"Frank\">),\n     (<Employee instance \"Chuck\">, <Employee instance \"Galyn\">)]\n\nThat's all the paths--all the chains--from Alice.  We sorted the results,\nbut normally they would be breadth first.\n\nBut what if we wanted to just find the paths from one query result to\nanother query result--say, we wanted to know the chain of command from Alice\ndown to Howie?  Then we can specify a ``targetQuery`` that specifies the\ncharacteristics of our desired end point (or points).\n\n    >>> list(catalog.findRelationChains(\n    ...     {'supervisor': 'Alice'},\n    ...     targetQuery={zc.relation.RELATION: 'Howie'}))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [(<Employee instance \"Betty\">, <Employee instance \"Diane\">,\n      <Employee instance \"Howie\">)]\n\nSo, Betty supervises Diane, who supervises Howie.\n\nNote that ``targetQuery`` now joins ``maxDepth`` in our collection of shared\nsearch arguments that we have introduced.\n\n``filter`` and ``targetFilter``\n-------------------------------\n\nWe can take a quick look now at the last of the two shared search arguments:\n``filter`` and ``targetFilter``.  These two are similar in that they both are\ncallables that can approve or reject given relations in a search based on\nwhatever logic you can code.  They differ in that ``filter`` stops any further\ntransitive searches from the relation, while ``targetFilter`` merely omits the\ngiven result but allows further search from it.  Like ``targetQuery``, then,\n``targetFilter`` is good when you want to specify the other end of a path.\n\nAs an example, let's say we only want to return female employees.\n\n    >>> female_employees = ('Alice', 'Betty', 'Diane', 'Galyn')\n    >>> def female_filter(relchain, query, catalog, cache):\n    ...     return relchain[-1] in female_employees\n    ...\n\nHere are all the female employees supervised by Alice transitively, using\n``targetFilter``.\n\n    >>> list(catalog.findRelations({'supervisor': 'Alice'},\n    ...                            targetFilter=female_filter))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [<Employee instance \"Betty\">, <Employee instance \"Diane\">,\n     <Employee instance \"Galyn\">]\n\nHere are all the female employees supervised by Chuck.\n\n    >>> list(catalog.findRelations({'supervisor': 'Chuck'},\n    ...                            targetFilter=female_filter))\n    [<Employee instance \"Galyn\">]\n\nThe same method used as a filter will only return females directly\nsupervised by other females--not Galyn, in this case.\n\n    >>> list(catalog.findRelations({'supervisor': 'Alice'},\n    ...                            filter=female_filter))\n    [<Employee instance \"Betty\">, <Employee instance \"Diane\">]\n\nThese can be combined with one another, and with the other search\narguments [#filter]_.\n\n.. [#filter] For instance:\n\n    >>> list(catalog.findRelationTokens(\n    ...     {'supervisor': 'Alice'}, targetFilter=female_filter,\n    ...     targetQuery={zc.relation.RELATION: 'Galyn'}))\n    ['Galyn']\n    >>> list(catalog.findRelationTokens(\n    ...     {'supervisor': 'Alice'}, targetFilter=female_filter,\n    ...     targetQuery={zc.relation.RELATION: 'Not known'}))\n    []\n    >>> arbitrary = ['Alice', 'Chuck', 'Betty', 'Galyn']\n    >>> def arbitrary_filter(relchain, query, catalog, cache):\n    ...     return relchain[-1] in arbitrary\n    >>> list(catalog.findRelationTokens({'supervisor': 'Alice'},\n    ...                                 filter=arbitrary_filter,\n    ...                                 targetFilter=female_filter))\n    ['Betty', 'Galyn']\n\nSearch indexes\n--------------\n\nWithout setting up any additional indexes, the transitive behavior of\nthe ``findRelations`` and ``findValues`` methods essentially relies on the\nbrute force searches of ``findRelationChains``.  Results are iterables\nthat are gradually computed.  For instance, let's repeat the question\n\"Whom does Betty supervise?\".  Notice that ``res`` first populates a list\nwith three members, but then does not populate a second list.  The\niterator has been exhausted.\n\n    >>> res = catalog.findRelationTokens({'supervisor': 'Betty'})\n    >>> unindexed = sorted(res)\n    >>> len(unindexed)\n    3\n    >>> len(list(res)) # iterator is exhausted\n    0\n\nThe brute force of this approach can be sufficient in many cases, but\nsometimes speed for these searches is critical.  In these cases, you can\nadd a \"search index\".  A search index speeds up the result of one or\nmore precise searches by indexing the results.  Search indexes can\naffect the results of searches with a ``queryFactory`` in ``findRelations``,\n``findValues``, and the soon-to-be-introduced ``canFind``, but they do not\naffect ``findRelationChains``.\n\nThe zc.relation package currently includes two kinds of search indexes, one for\nindexing transitive membership searches in a hierarchy and one for intransitive\nsearches explored in tokens.rst in this package, which can optimize frequent\nsearches on complex queries or can effectively change the meaning of an\nintransitive search. Other search index implementations and approaches may be\nadded in the future.\n\nHere's a very brief example of adding a search index for the transitive\nsearches seen above that specify a 'supervisor'.\n\n    >>> import zc.relation.searchindex\n    >>> catalog.addSearchIndex(\n    ...     zc.relation.searchindex.TransposingTransitiveMembership(\n    ...         'supervisor', zc.relation.RELATION))\n\nThe ``zc.relation.RELATION`` describes how to walk back up the chain. Search\nindexes are explained in reasonable detail in searchindex.rst.\n\nNow that we have added the index, we can search again.  The result this\ntime is already computed, so, at least when you ask for tokens, it\nis repeatable.\n\n    >>> res = catalog.findRelationTokens({'supervisor': 'Betty'})\n    >>> len(list(res))\n    3\n    >>> len(list(res))\n    3\n    >>> sorted(res) == unindexed\n    True\n\nNote that the breadth-first sorting is lost when an index is used [#updates]_.\n\n.. [#updates] The scenario we are looking at in this document shows a case\n    in which special logic in the search index needs to address updates.\n    For example, if we move Howie from Diane\n\n    ::\n\n                 Alice\n              __/     \\__\n         Betty           Chuck\n         /   \\           /   \\\n     Diane   Edgar   Frank   Galyn\n       |\n     Howie\n\n    to Galyn\n\n    ::\n\n                 Alice\n              __/     \\__\n         Betty           Chuck\n         /   \\           /   \\\n     Diane   Edgar   Frank   Galyn\n                               |\n                             Howie\n\n    then the search index is correct both for the new location and the old.\n\n    >>> h.supervisor = g\n    >>> catalog.index(h)\n    >>> list(catalog.findRelationTokens({'supervisor': 'Diane'}))\n    []\n    >>> list(catalog.findRelationTokens({'supervisor': 'Betty'}))\n    ['Diane', 'Edgar']\n    >>> list(catalog.findRelationTokens({'supervisor': 'Chuck'}))\n    ['Frank', 'Galyn', 'Howie']\n    >>> list(catalog.findRelationTokens({'supervisor': 'Galyn'}))\n    ['Howie']\n    >>> h.supervisor = d\n    >>> catalog.index(h) # move him back\n    >>> list(catalog.findRelationTokens({'supervisor': 'Galyn'}))\n    []\n    >>> list(catalog.findRelationTokens({'supervisor': 'Diane'}))\n    ['Howie']\n\nTransitive cycles (and updating and removing relations)\n-------------------------------------------------------\n\nThe transitive searches and the provided search indexes can handle\ncycles.  Cycles are less likely in the current example than some others,\nbut we can stretch the case a bit: imagine a \"king in disguise\", in\nwhich someone at the top works lower in the hierarchy.  Perhaps Alice\nworks for Zane, who works for Betty, who works for Alice.  Artificial,\nbut easy enough to draw::\n\n            ______\n           /      \\\n          /     Zane\n         /        |\n        /       Alice\n       /     __/     \\__\n      / Betty__         Chuck\n      \\-/  /   \\         /   \\\n         Diane Edgar Frank   Galyn\n          |\n        Howie\n\nEasy to create too.\n\n    >>> z = Employee('Zane', b)\n    >>> a.supervisor = z\n\nNow we have a cycle.  Of course, we have not yet told the catalog about it.\n``index`` can be used both to reindex Alice and index Zane.\n\n    >>> catalog.index(a)\n    >>> catalog.index(z)\n\nNow, if we ask who works for Betty, we get the entire tree.  (We'll ask\nfor tokens, just so that the result is smaller to look at.) [#same_set]_\n\n.. [#same_set] The result of the query for Betty, Alice, and Zane are all the\n    same.\n\n    >>> res1 = catalog.findRelationTokens({'supervisor': 'Betty'})\n    >>> res2 = catalog.findRelationTokens({'supervisor': 'Alice'})\n    >>> res3 = catalog.findRelationTokens({'supervisor': 'Zane'})\n    >>> list(res1) == list(res2) == list(res3)\n    True\n\n    The cycle doesn't pollute the index outside of the cycle.\n\n    >>> res = catalog.findRelationTokens({'supervisor': 'Diane'})\n    >>> list(res)\n    ['Howie']\n    >>> list(res) # it isn't lazy, it is precalculated\n    ['Howie']\n\n    >>> sorted(catalog.findRelationTokens({'supervisor': 'Betty'}))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    ['Alice', 'Betty', 'Chuck', 'Diane', 'Edgar', 'Frank', 'Galyn', 'Howie',\n     'Zane']\n\nIf we ask for the supervisors of Frank, it will include Betty.\n\n    >>> list(catalog.findValueTokens(\n    ...     'supervisor', {zc.relation.RELATION: 'Frank'}))\n    ['Chuck', 'Alice', 'Zane', 'Betty']\n\nPaths returned by ``findRelationChains`` are marked with special interfaces,\nand special metadata, to show the chain.\n\n    >>> res = list(catalog.findRelationChains({zc.relation.RELATION: 'Frank'}))\n    >>> len(res)\n    5\n    >>> import zc.relation.interfaces\n    >>> [zc.relation.interfaces.ICircularRelationPath.providedBy(r)\n    ...  for r in res]\n    [False, False, False, False, True]\n\nHere's the last chain:\n\n    >>> res[-1] # doctest: +NORMALIZE_WHITESPACE\n    cycle(<Employee instance \"Frank\">, <Employee instance \"Chuck\">,\n          <Employee instance \"Alice\">, <Employee instance \"Zane\">,\n          <Employee instance \"Betty\">)\n\nThe chain's 'cycled' attribute has a list of queries that create a cycle.\nIf you run the query, or queries, you see where the cycle would\nrestart--where the path would have started to overlap.  Sometimes the query\nresults will include multiple cycles, and some paths that are not cycles.\nIn this case, there's only a single cycled query, which results in a single\ncycled relation.\n\n    >>> len(res[4].cycled)\n    1\n\n    >>> list(catalog.findRelations(res[4].cycled[0], maxDepth=1))\n    [<Employee instance \"Alice\">]\n\nTo remove this craziness [#reverse_lookup]_, we can unindex Zane, and change\nand reindex Alice.\n\n.. [#reverse_lookup] If you want to, look what happens when you go the\n    other way:\n\n    >>> res = list(catalog.findRelationChains({'supervisor': 'Zane'}))\n    >>> def sortEqualLenByName(one):\n    ...     return len(one), one\n    ...\n    >>> res.sort(key=sortEqualLenByName)  # normalizes for test stability\n    >>> from __future__ import print_function\n    >>> print(res) # doctest: +NORMALIZE_WHITESPACE\n    [(<Employee instance \"Alice\">,),\n     (<Employee instance \"Alice\">, <Employee instance \"Betty\">),\n     (<Employee instance \"Alice\">, <Employee instance \"Chuck\">),\n     (<Employee instance \"Alice\">, <Employee instance \"Betty\">,\n      <Employee instance \"Diane\">),\n     (<Employee instance \"Alice\">, <Employee instance \"Betty\">,\n      <Employee instance \"Edgar\">),\n     cycle(<Employee instance \"Alice\">, <Employee instance \"Betty\">,\n           <Employee instance \"Zane\">),\n     (<Employee instance \"Alice\">, <Employee instance \"Chuck\">,\n      <Employee instance \"Frank\">),\n     (<Employee instance \"Alice\">, <Employee instance \"Chuck\">,\n      <Employee instance \"Galyn\">),\n     (<Employee instance \"Alice\">, <Employee instance \"Betty\">,\n      <Employee instance \"Diane\">, <Employee instance \"Howie\">)]\n\n    >>> [zc.relation.interfaces.ICircularRelationPath.providedBy(r)\n    ...  for r in res]\n    [False, False, False, False, False, True, False, False, False]\n    >>> len(res[5].cycled)\n    1\n    >>> list(catalog.findRelations(res[5].cycled[0], maxDepth=1))\n    [<Employee instance \"Alice\">]\n\n    >>> a.supervisor = None\n    >>> catalog.index(a)\n\n    >>> list(catalog.findValueTokens(\n    ...     'supervisor', {zc.relation.RELATION: 'Frank'}))\n    ['Chuck', 'Alice']\n\n    >>> catalog.unindex(z)\n\n    >>> sorted(catalog.findRelationTokens({'supervisor': 'Betty'}))\n    ['Diane', 'Edgar', 'Howie']\n\n``canFind``\n-----------\n\nWe're to the last search method: ``canFind``.  We've gotten values and\nrelations, but what if you simply want to know if there is any\nconnection at all?  For instance, is Alice a supervisor of Howie? Is\nChuck?  To answer these questions, you can use the ``canFind`` method\ncombined with the ``targetQuery`` search argument.\n\nThe ``canFind`` method takes the same arguments as findRelations.  However,\nit simply returns a boolean about whether the search has any results.  This\nis a convenience that also allows some extra optimizations.\n\nDoes Betty supervise anyone?\n\n    >>> catalog.canFind({'supervisor': 'Betty'})\n    True\n\nWhat about Howie?\n\n    >>> catalog.canFind({'supervisor': 'Howie'})\n    False\n\nWhat about...Zane (no longer an employee)?\n\n    >>> catalog.canFind({'supervisor': 'Zane'})\n    False\n\nIf we want to know if Alice or Chuck supervise Howie, then we want to specify\ncharacteristics of two points on a path.  To ask a question about the other\nend of a path, use ``targetQuery``.\n\nIs Alice a supervisor of Howie?\n\n    >>> catalog.canFind({'supervisor': 'Alice'},\n    ...                 targetQuery={zc.relation.RELATION: 'Howie'})\n    True\n\nIs Chuck a supervisor of Howie?\n\n    >>> catalog.canFind({'supervisor': 'Chuck'},\n    ...                 targetQuery={zc.relation.RELATION: 'Howie'})\n    False\n\nIs Howie Alice's employee?\n\n    >>> catalog.canFind({zc.relation.RELATION: 'Howie'},\n    ...                 targetQuery={'supervisor': 'Alice'})\n    True\n\nIs Howie Chuck's employee?\n\n    >>> catalog.canFind({zc.relation.RELATION: 'Howie'},\n    ...                 targetQuery={'supervisor': 'Chuck'})\n    False\n\n(Note that, if your relations describe a hierarchy, searching up a hierarchy is\nusually more efficient than searching down, so the second pair of questions is\ngenerally preferable to the first in that case.)\n\nWorking with More Complex Relations\n===================================\n\nSo far, our examples have used a simple relation, in which the indexed object\nis one end of the relation, and the indexed value on the object is the other.\nThis example has let us look at all of the basic zc.relation catalog\nfunctionality.\n\nAs mentioned in the introduction, though, the catalog supports, and was\ndesigned for, more complex relations.  This section will quickly examine a\nfew examples of other uses.\n\nIn this section, we will see several examples of ideas mentioned above but not\nyet demonstrated.\n\n- We can use interface attributes (values or callables) to define value\n  indexes.\n\n- Using interface attributes will cause an attempt to adapt the relation if it\n  does not already provide the interface.\n\n- We can use the ``multiple`` argument when defining a value index to indicate\n  that the indexed value is a collection.\n\n- We can use the ``name`` argument when defining a value index to specify the\n  name to be used in queries, rather than relying on the name of the interface\n  attribute or callable.\n\n- The ``family`` argument in instantiating the catalog lets you change the\n  default btree family for relations and value indexes from\n  ``BTrees.family32.IF`` to ``BTrees.family64.IF``.\n\nExtrinsic Two-Way Relations\n---------------------------\n\nA simple variation of our current story is this: what if the indexed relation\nwere between two other objects--that is, what if the relation were extrinsic to\nboth participants?\n\nLet's imagine we have relations that show biological parentage. We'll want a\n\"Person\" and a \"Parentage\" relation. We'll define an interface for\n``IParentage`` so we can see how using an interface to define a value index\nworks.\n\n    >>> class Person(object):\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...     def __repr__(self):\n    ...         return '<Person %r>' % (self.name,)\n    ...\n    >>> import zope.interface\n    >>> class IParentage(zope.interface.Interface):\n    ...     child = zope.interface.Attribute('the child')\n    ...     parents = zope.interface.Attribute('the parents')\n    ...\n    >>> @zope.interface.implementer(IParentage)\n    ... class Parentage(object):\n    ...\n    ...     def __init__(self, child, parent1, parent2):\n    ...         self.child = child\n    ...         self.parents = (parent1, parent2)\n    ...\n\nNow we'll define the dumpers and loaders and then the catalog.  Notice that\nwe are relying on a pattern: the dump must be called before the load.\n\n    >>> _people = {}\n    >>> _relations = {}\n    >>> def dumpPeople(obj, catalog, cache):\n    ...     if _people.setdefault(obj.name, obj) is not obj:\n    ...         raise ValueError('we are assuming names are unique')\n    ...     return obj.name\n    ...\n    >>> def loadPeople(token, catalog, cache):\n    ...     return _people[token]\n    ...\n    >>> def dumpRelations(obj, catalog, cache):\n    ...     if _relations.setdefault(id(obj), obj) is not obj:\n    ...         raise ValueError('huh?')\n    ...     return id(obj)\n    ...\n    >>> def loadRelations(token, catalog, cache):\n    ...     return _relations[token]\n    ...\n    >>> catalog = zc.relation.catalog.Catalog(dumpRelations, loadRelations, family=BTrees.family64)\n    >>> catalog.addValueIndex(IParentage['child'], dumpPeople, loadPeople,\n    ...                       btree=BTrees.family32.OO)\n    >>> catalog.addValueIndex(IParentage['parents'], dumpPeople, loadPeople,\n    ...                       btree=BTrees.family32.OO, multiple=True,\n    ...                       name='parent')\n    >>> catalog.addDefaultQueryFactory(\n    ...     zc.relation.queryfactory.TransposingTransitive(\n    ...         'child', 'parent'))\n\nNow we have a catalog fully set up.  Let's add some relations.\n\n    >>> a = Person('Alice')\n    >>> b = Person('Betty')\n    >>> c = Person('Charles')\n    >>> d = Person('Donald')\n    >>> e = Person('Eugenia')\n    >>> f = Person('Fred')\n    >>> g = Person('Gertrude')\n    >>> h = Person('Harry')\n    >>> i = Person('Iphigenia')\n    >>> j = Person('Jacob')\n    >>> k = Person('Karyn')\n    >>> l = Person('Lee')\n\n    >>> r1 = Parentage(child=j, parent1=k, parent2=l)\n    >>> r2 = Parentage(child=g, parent1=i, parent2=j)\n    >>> r3 = Parentage(child=f, parent1=g, parent2=h)\n    >>> r4 = Parentage(child=e, parent1=g, parent2=h)\n    >>> r5 = Parentage(child=b, parent1=e, parent2=d)\n    >>> r6 = Parentage(child=a, parent1=e, parent2=c)\n\nHere's that in one of our hierarchy diagrams.\n\n::\n\n    Karyn   Lee\n         \\ /\n        Jacob   Iphigenia\n             \\ /\n            Gertrude    Harry\n                    \\  /\n                 /-------\\\n             Fred        Eugenia\n               Donald   /     \\    Charles\n                     \\ /       \\  /\n                    Betty      Alice\n\nNow we can index the relations, and ask some questions.\n\n    >>> for r in (r1, r2, r3, r4, r5, r6):\n    ...     catalog.index(r)\n    >>> query = catalog.tokenizeQuery\n    >>> sorted(catalog.findValueTokens(\n    ...     'parent', query(child=a), maxDepth=1))\n    ['Charles', 'Eugenia']\n    >>> sorted(catalog.findValueTokens('parent', query(child=g)))\n    ['Iphigenia', 'Jacob', 'Karyn', 'Lee']\n    >>> sorted(catalog.findValueTokens(\n    ...     'child', query(parent=h), maxDepth=1))\n    ['Eugenia', 'Fred']\n    >>> sorted(catalog.findValueTokens('child', query(parent=h)))\n    ['Alice', 'Betty', 'Eugenia', 'Fred']\n    >>> catalog.canFind(query(parent=h), targetQuery=query(child=d))\n    False\n    >>> catalog.canFind(query(parent=l), targetQuery=query(child=b))\n    True\n\nMulti-Way Relations\n-------------------\n\nThe previous example quickly showed how to set the catalog up for a completely\nextrinsic two-way relation.  The same pattern can be extended for N-way\nrelations.  For example, consider a four way relation in the form of\nSUBJECTS PREDICATE OBJECTS [in CONTEXT].  For instance, we might\nwant to say \"(joe,) SELLS (doughnuts, coffee) in corner_store\", where \"(joe,)\"\nis the collection of subjects, \"SELLS\" is the predicate, \"(doughnuts, coffee)\"\nis the collection of objects, and \"corner_store\" is the optional context.\n\nFor this last example, we'll integrate two components we haven't seen examples\nof here before: the ZODB and adaptation.\n\nOur example ZODB approach uses OIDs as the tokens. this might be OK in some\ncases, if you will never support multiple databases and you don't need an\nabstraction layer so that a different object can have the same identifier.\n\n    >>> import persistent\n    >>> import struct\n    >>> class Demo(persistent.Persistent):\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...     def __repr__(self):\n    ...         return '<Demo instance %r>' % (self.name,)\n    ...\n    >>> class IRelation(zope.interface.Interface):\n    ...     subjects = zope.interface.Attribute('subjects')\n    ...     predicate = zope.interface.Attribute('predicate')\n    ...     objects = zope.interface.Attribute('objects')\n    ...\n    >>> class IContextual(zope.interface.Interface):\n    ...     def getContext():\n    ...         'return context'\n    ...     def setContext(value):\n    ...         'set context'\n    ...\n    >>> @zope.interface.implementer(IContextual)\n    ... class Contextual(object):\n    ...\n    ...     _context = None\n    ...     def getContext(self):\n    ...         return self._context\n    ...     def setContext(self, value):\n    ...         self._context = value\n    ...\n    >>> @zope.interface.implementer(IRelation)\n    ... class Relation(persistent.Persistent):\n    ...\n    ...     def __init__(self, subjects, predicate, objects):\n    ...         self.subjects = subjects\n    ...         self.predicate = predicate\n    ...         self.objects = objects\n    ...         self._contextual = Contextual()\n    ...\n    ...     def __conform__(self, iface):\n    ...         if iface is IContextual:\n    ...             return self._contextual\n    ...\n\n(When using zope.component, the ``__conform__`` would normally be unnecessary;\nhowever, this package does not depend on zope.component.)\n\n    >>> def dumpPersistent(obj, catalog, cache):\n    ...     if obj._p_jar is None:\n    ...         catalog._p_jar.add(obj) # assumes something else places it\n    ...     return struct.unpack('<q', obj._p_oid)[0]\n    ...\n    >>> def loadPersistent(token, catalog, cache):\n    ...     return catalog._p_jar.get(struct.pack('<q', token))\n    ...\n\n    >>> from ZODB.tests.util import DB\n    >>> db = DB()\n    >>> conn = db.open()\n    >>> root = conn.root()\n    >>> catalog = root['catalog'] = zc.relation.catalog.Catalog(\n    ...     dumpPersistent, loadPersistent, family=BTrees.family64)\n    >>> catalog.addValueIndex(IRelation['subjects'],\n    ...     dumpPersistent, loadPersistent, multiple=True, name='subject')\n    >>> catalog.addValueIndex(IRelation['objects'],\n    ...     dumpPersistent, loadPersistent, multiple=True, name='object')\n    >>> catalog.addValueIndex(IRelation['predicate'], btree=BTrees.family32.OO)\n    >>> catalog.addValueIndex(IContextual['getContext'],\n    ...     dumpPersistent, loadPersistent, name='context')\n    >>> import transaction\n    >>> transaction.commit()\n\nThe ``dumpPersistent`` and ``loadPersistent`` is a bit of a toy, as warned\nabove. Also, while our predicate will be stored as a string, some programmers\nmay prefer to have a dump in such a case verify that the string has been\nexplicitly registered in some way, to prevent typos. Obviously, we are not\nbothering with this for our example.\n\nWe make some objects, and then we make some relations with those objects and\nindex them.\n\n    >>> joe = root['joe'] = Demo('joe')\n    >>> sara = root['sara'] = Demo('sara')\n    >>> jack = root['jack'] = Demo('jack')\n    >>> ann = root['ann'] = Demo('ann')\n    >>> doughnuts = root['doughnuts'] = Demo('doughnuts')\n    >>> coffee = root['coffee'] = Demo('coffee')\n    >>> muffins = root['muffins'] = Demo('muffins')\n    >>> cookies = root['cookies'] = Demo('cookies')\n    >>> newspaper = root['newspaper'] = Demo('newspaper')\n    >>> corner_store = root['corner_store'] = Demo('corner_store')\n    >>> bistro = root['bistro'] = Demo('bistro')\n    >>> bakery = root['bakery'] = Demo('bakery')\n\n    >>> SELLS = 'SELLS'\n    >>> BUYS = 'BUYS'\n    >>> OBSERVES = 'OBSERVES'\n\n    >>> rel1 = root['rel1'] = Relation((joe,), SELLS, (doughnuts, coffee))\n    >>> IContextual(rel1).setContext(corner_store)\n    >>> rel2 = root['rel2'] = Relation((sara, jack), SELLS,\n    ...                                (muffins, doughnuts, cookies))\n    >>> IContextual(rel2).setContext(bakery)\n    >>> rel3 = root['rel3'] = Relation((ann,), BUYS, (doughnuts,))\n    >>> rel4 = root['rel4'] = Relation((sara,), BUYS, (bistro,))\n\n    >>> for r in (rel1, rel2, rel3, rel4):\n    ...     catalog.index(r)\n    ...\n\nNow we can ask a simple question.  Where do they sell doughnuts?\n\n    >>> query = catalog.tokenizeQuery\n    >>> sorted(catalog.findValues(\n    ...     'context',\n    ...     (query(predicate=SELLS, object=doughnuts))),\n    ...     key=lambda ob: ob.name)\n    [<Demo instance 'bakery'>, <Demo instance 'corner_store'>]\n\nHopefully these examples give you further ideas on how you can use this tool.\n\nAdditional Functionality\n========================\n\nThis section introduces peripheral functionality.  We will learn the following.\n\n- Listeners can be registered in the catalog.  They are alerted when a relation\n  is added, modified, or removed; and when the catalog is cleared and copied\n  (see below).\n\n- The ``clear`` method clears the relations in the catalog.\n\n- The ``copy`` method makes a copy of the current catalog by copying internal\n  data structures, rather than reindexing the relations, which can be a\n  significant optimization opportunity.  This copies value indexes and search\n  indexes; and gives listeners an opportunity to specify what, if anything,\n  should be included in the new copy.\n\n- The ``ignoreSearchIndex`` argument to the five pertinent search methods\n  causes the search to ignore search indexes, even if there is an appropriate\n  one.\n\n- ``findRelationTokens()`` (without arguments) returns the BTree set of all\n  relation tokens in the catalog.\n\n- ``findValueTokens(INDEX_NAME)`` (where \"INDEX_NAME\" should be replaced with\n  an index name) returns the BTree set of all value tokens in the catalog for\n  the given index name.\n\nListeners\n---------\n\nA variety of potential clients may want to be alerted when the catalog changes.\nzc.relation does not depend on zope.event, so listeners may be registered for\nvarious changes.  Let's make a quick demo listener.  The ``additions`` and\n``removals`` arguments are dictionaries of {value name: iterable of added or\nremoved value tokens}.\n\n    >>> def pchange(d):\n    ...     pprint.pprint(dict(\n    ...         (k, v is not None and sorted(set(v)) or v) for k, v in d.items()))\n    >>> @zope.interface.implementer(zc.relation.interfaces.IListener)\n    ... class DemoListener(persistent.Persistent):\n    ...\n    ...     def relationAdded(self, token, catalog, additions):\n    ...         print('a relation (token %r) was added to %r '\n    ...                'with these values:' % (token, catalog))\n    ...         pchange(additions)\n    ...     def relationModified(self, token, catalog, additions, removals):\n    ...         print('a relation (token %r) in %r was modified '\n    ...                'with these additions:' % (token, catalog))\n    ...         pchange(additions)\n    ...         print('and these removals:')\n    ...         pchange(removals)\n    ...     def relationRemoved(self, token, catalog, removals):\n    ...         print('a relation (token %r) was removed from %r '\n    ...                'with these values:' % (token, catalog))\n    ...         pchange(removals)\n    ...     def sourceCleared(self, catalog):\n    ...         print('catalog %r had all relations unindexed' % (catalog,))\n    ...     def sourceAdded(self, catalog):\n    ...         print('now listening to catalog %r' % (catalog,))\n    ...     def sourceRemoved(self, catalog):\n    ...         print('no longer listening to catalog %r' % (catalog,))\n    ...     def sourceCopied(self, original, copy):\n    ...         print('catalog %r made a copy %r' % (catalog, copy))\n    ...         copy.addListener(self)\n    ...\n\nListeners can be installed multiple times.\n\nListeners can be added as persistent weak references, so that, if they are\ndeleted elsewhere, a ZODB pack will not consider the reference in the catalog\nto be something preventing garbage collection.\n\nWe'll install one of these demo listeners into our new catalog as a\nnormal reference, the default behavior.  Then we'll show some example messages\nsent to the demo listener.\n\n    >>> listener = DemoListener()\n    >>> catalog.addListener(listener) # doctest: +ELLIPSIS\n    now listening to catalog <zc.relation.catalog.Catalog object at ...>\n    >>> rel5 = root['rel5'] = Relation((ann,), OBSERVES, (newspaper,))\n    >>> catalog.index(rel5) # doctest: +ELLIPSIS\n    a relation (token ...) was added to <...Catalog...> with these values:\n    {'context': None,\n     'object': [...],\n     'predicate': ['OBSERVES'],\n     'subject': [...]}\n    >>> rel5.subjects = (jack,)\n    >>> IContextual(rel5).setContext(bistro)\n    >>> catalog.index(rel5) # doctest: +ELLIPSIS\n    a relation (token ...) in ...Catalog... was modified with these additions:\n    {'context': [...], 'subject': [...]}\n    and these removals:\n    {'subject': [...]}\n    >>> catalog.unindex(rel5) # doctest: +ELLIPSIS\n    a relation (token ...) was removed from <...Catalog...> with these values:\n    {'context': [...],\n     'object': [...],\n     'predicate': ['OBSERVES'],\n     'subject': [...]}\n\n    >>> catalog.removeListener(listener) # doctest: +ELLIPSIS\n    no longer listening to catalog <...Catalog...>\n    >>> catalog.index(rel5) # doctest: +ELLIPSIS\n\nThe only two methods not shown by those examples are ``sourceCleared`` and\n``sourceCopied``.  We'll get to those very soon below.\n\nThe ``clear`` Method\n--------------------\n\nThe ``clear`` method simply indexes all relations from a catalog.  Installed\nlisteners have ``sourceCleared`` called.\n\n    >>> len(catalog)\n    5\n\n    >>> catalog.addListener(listener) # doctest: +ELLIPSIS\n    now listening to catalog <zc.relation.catalog.Catalog object at ...>\n\n    >>> catalog.clear() # doctest: +ELLIPSIS\n    catalog <...Catalog...> had all relations unindexed\n\n    >>> len(catalog)\n    0\n    >>> sorted(catalog.findValues(\n    ...     'context',\n    ...     (query(predicate=SELLS, object=doughnuts))),\n    ...     key=lambda ob: ob.name)\n    []\n\nThe ``copy`` Method\n-------------------\n\nSometimes you may want to copy a relation catalog.  One way of doing this is\nto create a new catalog, set it up like the current one, and then reindex\nall the same relations.  This is unnecessarily slow for programmer and\ncomputer.  The ``copy`` method makes a new catalog with the same corpus of\nindexed relations by copying internal data structures.\n\nSearch indexes are requested to make new copies of themselves for the new\ncatalog; and listeners are given an opportunity to react as desired to the new\ncopy, including installing themselves, and/or another object of their choosing\nas a listener.\n\nLet's make a copy of a populated index with a search index and a listener.\nNotice in our listener that ``sourceCopied`` adds itself as a listener to the\nnew copy. This is done at the very end of the ``copy`` process.\n\n    >>> for r in (rel1, rel2, rel3, rel4, rel5):\n    ...     catalog.index(r)\n    ... # doctest: +ELLIPSIS\n    a relation ... was added...\n    a relation ... was added...\n    a relation ... was added...\n    a relation ... was added...\n    a relation ... was added...\n    >>> BEGAT = 'BEGAT'\n    >>> rel6 = root['rel6'] = Relation((jack, ann), BEGAT, (sara,))\n    >>> henry = root['henry'] = Demo('henry')\n    >>> rel7 = root['rel7'] = Relation((sara, joe), BEGAT, (henry,))\n    >>> catalog.index(rel6) # doctest: +ELLIPSIS\n    a relation (token ...) was added to <...Catalog...> with these values:\n    {'context': None,\n     'object': [...],\n     'predicate': ['BEGAT'],\n     'subject': [..., ...]}\n    >>> catalog.index(rel7) # doctest: +ELLIPSIS\n    a relation (token ...) was added to <...Catalog...> with these values:\n    {'context': None,\n     'object': [...],\n     'predicate': ['BEGAT'],\n     'subject': [..., ...]}\n    >>> catalog.addDefaultQueryFactory(\n    ...     zc.relation.queryfactory.TransposingTransitive(\n    ...         'subject', 'object', {'predicate': BEGAT}))\n    ...\n    >>> list(catalog.findValues(\n    ...     'object', query(subject=jack, predicate=BEGAT)))\n    [<Demo instance 'sara'>, <Demo instance 'henry'>]\n    >>> catalog.addSearchIndex(\n    ...     zc.relation.searchindex.TransposingTransitiveMembership(\n    ...         'subject', 'object', static={'predicate': BEGAT}))\n    >>> sorted(\n    ...     catalog.findValues(\n    ...         'object', query(subject=jack, predicate=BEGAT)),\n    ...     key=lambda o: o.name)\n    [<Demo instance 'henry'>, <Demo instance 'sara'>]\n\n    >>> newcat = root['newcat'] = catalog.copy() # doctest: +ELLIPSIS\n    catalog <...Catalog...> made a copy <...Catalog...>\n    now listening to catalog <...Catalog...>\n    >>> transaction.commit()\n\nNow the copy has its own copies of internal data structures and of the\nsearchindex.  For example, let's modify the relations and add a new one to the\ncopy.\n\n    >>> mary = root['mary'] = Demo('mary')\n    >>> buffy = root['buffy'] = Demo('buffy')\n    >>> zack = root['zack'] = Demo('zack')\n    >>> rel7.objects += (mary,)\n    >>> rel8 = root['rel8'] = Relation((henry, buffy), BEGAT, (zack,))\n    >>> newcat.index(rel7) # doctest: +ELLIPSIS\n    a relation (token ...) in ...Catalog... was modified with these additions:\n    {'object': [...]}\n    and these removals:\n    {}\n    >>> newcat.index(rel8) # doctest: +ELLIPSIS\n    a relation (token ...) was added to ...Catalog... with these values:\n    {'context': None,\n     'object': [...],\n     'predicate': ['BEGAT'],\n     'subject': [..., ...]}\n    >>> len(newcat)\n    8\n    >>> sorted(\n    ...     newcat.findValues(\n    ...         'object', query(subject=jack, predicate=BEGAT)),\n    ...     key=lambda o: o.name) # doctest: +NORMALIZE_WHITESPACE\n    [<Demo instance 'henry'>, <Demo instance 'mary'>, <Demo instance 'sara'>,\n     <Demo instance 'zack'>]\n    >>> sorted(\n    ...     newcat.findValues(\n    ...         'object', query(subject=sara)),\n    ...     key=lambda o: o.name) # doctest: +NORMALIZE_WHITESPACE\n    [<Demo instance 'bistro'>, <Demo instance 'cookies'>,\n    <Demo instance 'doughnuts'>, <Demo instance 'henry'>,\n    <Demo instance 'mary'>, <Demo instance 'muffins'>]\n\nThe original catalog is not modified.\n\n    >>> len(catalog)\n    7\n    >>> sorted(\n    ...     catalog.findValues(\n    ...         'object', query(subject=jack, predicate=BEGAT)),\n    ...     key=lambda o: o.name)\n    [<Demo instance 'henry'>, <Demo instance 'sara'>]\n    >>> sorted(\n    ...     catalog.findValues(\n    ...         'object', query(subject=sara)),\n    ...     key=lambda o: o.name) # doctest: +NORMALIZE_WHITESPACE\n    [<Demo instance 'bistro'>, <Demo instance 'cookies'>,\n     <Demo instance 'doughnuts'>, <Demo instance 'henry'>,\n     <Demo instance 'muffins'>]\n\nThe ``ignoreSearchIndex`` argument\n----------------------------------\n\nThe five methods that can use search indexes, ``findValues``,\n``findValueTokens``, ``findRelations``, ``findRelationTokens``, and\n``canFind``, can be explicitly requested to ignore any pertinent search index\nusing the ``ignoreSearchIndex`` argument.\n\nWe can see this easily with the token-related methods: the search index result\nwill be a BTree set, while without the search index the result will be a\ngenerator.\n\n    >>> res1 = newcat.findValueTokens(\n    ...     'object', query(subject=jack, predicate=BEGAT))\n    >>> res1 # doctest: +ELLIPSIS\n    LFSet([..., ..., ..., ...])\n    >>> res2 = newcat.findValueTokens(\n    ...     'object', query(subject=jack, predicate=BEGAT),\n    ...     ignoreSearchIndex=True)\n    >>> res2 # doctest: +ELLIPSIS\n    <generator object ... at 0x...>\n    >>> sorted(res2) == list(res1)\n    True\n\n    >>> res1 = newcat.findRelationTokens(\n    ...     query(subject=jack, predicate=BEGAT))\n    >>> res1 # doctest: +ELLIPSIS\n    LFSet([..., ..., ...])\n    >>> res2 = newcat.findRelationTokens(\n    ...     query(subject=jack, predicate=BEGAT), ignoreSearchIndex=True)\n    >>> res2 # doctest: +ELLIPSIS\n    <generator object ... at 0x...>\n    >>> sorted(res2) == list(res1)\n    True\n\nWe can see that the other methods take the argument, but the results look the\nsame as usual.\n\n    >>> res = newcat.findValues(\n    ...     'object', query(subject=jack, predicate=BEGAT),\n    ...     ignoreSearchIndex=True)\n    >>> res # doctest: +ELLIPSIS\n    <generator object ... at 0x...>\n    >>> list(res) == list(newcat.resolveValueTokens(newcat.findValueTokens(\n    ...     'object', query(subject=jack, predicate=BEGAT),\n    ...     ignoreSearchIndex=True), 'object'))\n    True\n\n    >>> res = newcat.findRelations(\n    ...     query(subject=jack, predicate=BEGAT),\n    ...     ignoreSearchIndex=True)\n    >>> res # doctest: +ELLIPSIS\n    <generator object ... at 0x...>\n    >>> list(res) == list(newcat.resolveRelationTokens(\n    ...     newcat.findRelationTokens(\n    ...         query(subject=jack, predicate=BEGAT),\n    ...         ignoreSearchIndex=True)))\n    True\n\n    >>> newcat.canFind(\n    ...     query(subject=jack, predicate=BEGAT), ignoreSearchIndex=True)\n    True\n\n``findRelationTokens()``\n------------------------\n\nIf you call ``findRelationTokens`` without any arguments, you will get the\nBTree set of all relation tokens in the catalog.  This can be handy for tests\nand for advanced uses of the catalog.\n\n    >>> newcat.findRelationTokens() # doctest: +ELLIPSIS\n    <BTrees.LFBTree.LFTreeSet object at ...>\n    >>> len(newcat.findRelationTokens())\n    8\n    >>> set(newcat.resolveRelationTokens(newcat.findRelationTokens())) == set(\n    ...     (rel1, rel2, rel3, rel4, rel5, rel6, rel7, rel8))\n    True\n\n``findValueTokens(INDEX_NAME)``\n-------------------------------\n\nIf you call ``findValueTokens`` with only an index name, you will get the BTree\nstructure of all tokens for that value in the index. This can be handy for\ntests and for advanced uses of the catalog.\n\n    >>> newcat.findValueTokens('predicate') # doctest: +ELLIPSIS\n    <BTrees.OOBTree.OOBTree object at ...>\n    >>> list(newcat.findValueTokens('predicate'))\n    ['BEGAT', 'BUYS', 'OBSERVES', 'SELLS']\n\nConclusion\n==========\n\nReview\n------\n\nThat brings us to the end of our introductory examples.  Let's review, and\nthen look at where you can go from here.\n\n* Relations are objects with indexed values.\n\n* The relation catalog indexes relations. The relations can be one-way,\n  two-way, three-way, or N-way, as long as you tell the catalog to index the\n  different values.\n\n* Creating a catalog:\n\n    - Relations and their values are stored in the catalog as tokens: unique\n      identifiers that you can resolve back to the original value. Integers are\n      the most efficient tokens, but others can work fine too.\n\n    - Token type determines the BTree module needed.\n\n        - If the tokens are 32-bit ints, choose ``BTrees.family32.II``,\n          ``BTrees.family32.IF`` or ``BTrees.family32.IO``.\n\n        - If the tokens are 64 bit ints, choose ``BTrees.family64.II``,\n          ``BTrees.family64.IF`` or ``BTrees.family64.IO``.\n\n        - If they are anything else, choose ``BTrees.family32.OI``,\n          ``BTrees.family64.OI``, or ``BTrees.family32.OO`` (or\n          BTrees.family64.OO--they are the same).\n\n      Within these rules, the choice is somewhat arbitrary unless you plan to\n      merge these results with that of another source that is using a\n      particular BTree module. BTree set operations only work within the same\n      module, so you must match module to module.\n\n    - The ``family`` argument in instantiating the catalog lets you change the\n      default btree family for relations and value indexes from\n      ``BTrees.family32.IF`` to ``BTrees.family64.IF``.\n\n    - You must define your own functions for tokenizing and resolving tokens.\n      These functions are registered with the catalog for the relations and for\n      each of their value indexes.\n\n    - You add value indexes to relation catalogs to be able to search.  Values\n      can be identified to the catalog with callables or interface elements.\n\n        - Using interface attributes will cause an attempt to adapt the\n          relation if it does not already provide the interface.\n\n        - We can use the ``multiple`` argument when defining a value index to\n          indicate that the indexed value is a collection.  This defaults to\n          False.\n\n        - We can use the ``name`` argument when defining a value index to\n          specify the name to be used in queries, rather than relying on the\n          name of the interface attribute or callable.\n\n    - You can set up search indexes to speed up specific searches, usually\n      transitive.\n\n    - Listeners can be registered in the catalog. They are alerted when a\n      relation is added, modified, or removed; and when the catalog is cleared\n      and copied.\n\n* Catalog Management:\n\n    - Relations are indexed with ``index(relation)``, and removed from the\n      catalog with ``unindex(relation)``. ``index_doc(relation_token,\n      relation)`` and ``unindex_doc(relation_token)`` also work.\n\n    - The ``clear`` method clears the relations in the catalog.\n\n    - The ``copy`` method makes a copy of the current catalog by copying\n      internal data structures, rather than reindexing the relations, which can\n      be a significant optimization opportunity. This copies value indexes and\n      search indexes; and gives listeners an opportunity to specify what, if\n      anything, should be included in the new copy.\n\n* Searching a catalog:\n\n    - Queries to the relation catalog are formed with dicts.\n\n    - Query keys are the names of the indexes you want to search, or, for the\n      special case of precise relations, the ``zc.relation.RELATION`` constant.\n\n    - Query values are the tokens of the results you want to match; or\n      ``None``, indicating relations that have ``None`` as a value (or an empty\n      collection, if it is a multiple). Search values can use\n      ``zc.relation.catalog.any(args)`` or ``zc.relation.catalog.Any(args)`` to\n      specify multiple (non-``None``) results to match for a given key.\n\n    - The index has a variety of methods to help you work with tokens.\n      ``tokenizeQuery`` is typically the most used, though others are\n      available.\n\n    - To find relations that match a query, use ``findRelations`` or\n      ``findRelationTokens``.  Calling ``findRelationTokens`` without any\n      arguments returns the BTree set of all relation tokens in the catalog.\n\n    - To find values that match a query, use ``findValues`` or\n      ``findValueTokens``.  Calling ``findValueTokens`` with only the name\n      of a value index returns the BTree set of all tokens in the catalog for\n      that value index.\n\n    - You search transitively by using a query factory. The\n      ``zc.relation.queryfactory.TransposingTransitive`` is a good common case\n      factory that lets you walk up and down a hierarchy. A query factory can\n      be passed in as an argument to search methods as a ``queryFactory``, or\n      installed as a default behavior using ``addDefaultQueryFactory``.\n\n    - To find how a query is related, use ``findRelationChains`` or\n      ``findRelationTokenChains``.\n\n    - To find out if a query is related, use ``canFind``.\n\n    - Circular transitive relations are handled to prevent infinite loops. They\n      are identified in ``findRelationChains`` and ``findRelationTokenChains``\n      with a ``zc.relation.interfaces.ICircularRelationPath`` marker interface.\n\n    - search methods share the following arguments:\n\n      * ``maxDepth``, limiting the transitive depth for searches;\n\n      * ``filter``, allowing code to filter transitive paths;\n\n      * ``targetQuery``, allowing a query to filter transitive paths on the\n        basis of the endpoint;\n\n      * ``targetFilter``, allowing code to filter transitive paths on the basis\n        of the endpoint; and\n\n      * ``queryFactory``, mentioned above.\n\n      In addition, the ``ignoreSearchIndex`` argument to ``findRelations``,\n      ``findRelationTokens``, ``findValues``, ``findValueTokens``, and\n      ``canFind`` causes the search to ignore search indexes, even if there is\n      an appropriate one.\n\nNext Steps\n----------\n\nIf you want to read more, next steps depend on how you like to learn.  Here\nare some of the other documents in the zc.relation package.\n\n:optimization.rst:\n    Best practices for optimizing your use of the relation catalog.\n\n:searchindex.rst:\n    Queries factories and search indexes: from basics to nitty gritty details.\n\n:tokens.rst:\n    This document explores the details of tokens.  All God's chillun\n    love tokens, at least if God's chillun are writing non-toy apps\n    using zc.relation.  It includes discussion of the token helpers that\n    the catalog provides, how to use zope.app.intid-like registries with\n    zc.relation, how to use tokens to \"join\" query results reasonably\n    efficiently, and how to index joins.  It also is unnecessarily\n    mind-blowing because of the examples used.\n\n:interfaces.py:\n    The contract, for nuts and bolts.\n\nFinally, the truly die-hard might also be interested in the timeit\ndirectory, which holds scripts used to test assumptions and learn.\n\n.. ......... ..\n.. FOOTNOTES ..\n.. ......... ..\n\n.. [#I_care] OK, you care about how that query factory worked, so\n    we will look into it a bit.  Let's talk through two steps of the\n    transitive search in the second question.  The catalog initially\n    performs the initial intransitive search requested: find relations\n    for which Betty is the supervisor.  That's Diane and Edgar.\n\n    Now, for each of the results, the catalog asks the query factory for\n    next steps.  Let's take Diane.  The catalog says to the factory,\n    \"Given this query for relations where Betty is supervisor, I got\n    this result of Diane.  Do you have any other queries I should try to\n    look further?\".  The factory also gets the catalog instance so it\n    can use it to answer the question if it needs to.\n\n    OK, the next part is where your brain hurts.  Hang on.\n\n    In our case, the factory sees that the query was for supervisor. Its\n    other key, the one it transposes with, is ``zc.relation.RELATION``. *The\n    factory gets the transposing key's result for the current token.* So, for\n    us, a key of ``zc.relation.RELATION`` is actually a no-op: the result *is*\n    the current token, Diane. Then, the factory has its answer: replace the old\n    value of supervisor in the query, Betty, with the result, Diane. The next\n    transitive query should be {'supervisor', 'Diane'}. Ta-da.\n\n\n======================================================\nTokens and Joins: zc.relation Catalog Extended Example\n======================================================\n\nIntroduction and Set Up\n=======================\n\nThis document assumes you have read the introductory README.rst and want\nto learn a bit more by example. In it, we will explore a more\ncomplicated set of relations that demonstrates most of the aspects of\nworking with tokens.  In particular, we will look at joins, which will\nalso give us a chance to look more in depth at query factories and\nsearch indexes, and introduce the idea of listeners. It will not explain\nthe basics that the README already addressed.\n\nImagine we are indexing security assertions in a system.  In this\nsystem, users may have roles within an organization.  Each organization\nmay have multiple child organizations and may have a single parent\norganization.  A user with a role in a parent organization will have the\nsame role in all transitively connected child relations.\n\nWe have two kinds of relations, then.  One kind of relation will model\nthe hierarchy of organizations.  We'll do it with an intrinsic relation\nof organizations to their children: that reflects the fact that parent\norganizations choose and are comprised of their children; children do\nnot choose their parents.\n\nThe other relation will model the (multiple) roles a (single) user has\nin a (single) organization.  This relation will be entirely extrinsic.\n\nWe could create two catalogs, one for each type.  Or we could put them\nboth in the same catalog.  Initially, we'll go with the single-catalog\napproach for our examples.  This single catalog, then, will be indexing\na heterogeneous collection of relations.\n\nLet's define the two relations with interfaces.  We'll include one\naccessor, getOrganization, largely to show how to handle methods.\n\n    >>> import zope.interface\n    >>> class IOrganization(zope.interface.Interface):\n    ...     title = zope.interface.Attribute('the title')\n    ...     parts = zope.interface.Attribute(\n    ...         'the organizations that make up this one')\n    ...\n    >>> class IRoles(zope.interface.Interface):\n    ...     def getOrganization():\n    ...         'return the organization in which this relation operates'\n    ...     principal_id = zope.interface.Attribute(\n    ...         'the pricipal id whose roles this relation lists')\n    ...     role_ids = zope.interface.Attribute(\n    ...         'the role ids that the principal explicitly has in the '\n    ...         'organization.  The principal may have other roles via '\n    ...         'roles in parent organizations.')\n    ...\n\nNow we can create some classes.  In the README example, the setup was a bit\nof a toy.  This time we will be just a bit more practical.  We'll also expect\nto be operating within the ZODB, with a root and transactions. [#ZODB]_\n\n.. [#ZODB] Here we will set up a ZODB instance for us to use.\n\n    >>> from ZODB.tests.util import DB\n    >>> db = DB()\n    >>> conn = db.open()\n    >>> root = conn.root()\n\nHere's how we will dump and load our relations: use a \"registry\"\nobject, similar to an intid utility. [#faux_intid]_\n\n.. [#faux_intid] Here's a simple persistent keyreference.  Notice that it is\n    not persistent itself: this is important for conflict resolution to be\n    able to work (which we don't show here, but we're trying to lean more\n    towards real usage for this example).\n\n    >>> from functools import total_ordering\n    >>> @total_ordering\n    ... class Reference(object): # see zope.app.keyreference\n    ...     def __init__(self, obj):\n    ...         self.object = obj\n    ...     def _get_sorting_key(self):\n    ...         # this doesn't work during conflict resolution.  See\n    ...         # zope.app.keyreference.persistent, 3.5 release, for current\n    ...         # best practice.\n    ...         if self.object._p_jar is None:\n    ...             raise ValueError(\n    ...                 'can only compare when both objects have connections')\n    ...         return self.object._p_oid or ''\n    ...     def __lt__(self, other):\n    ...         # this doesn't work during conflict resolution.  See\n    ...         # zope.app.keyreference.persistent, 3.5 release, for current\n    ...         # best practice.\n    ...         if not isinstance(other, Reference):\n    ...             raise ValueError('can only compare with Reference objects')\n    ...         return self._get_sorting_key() < other._get_sorting_key()\n    ...     def __eq__(self, other):\n    ...         # this doesn't work during conflict resolution.  See\n    ...         # zope.app.keyreference.persistent, 3.5 release, for current\n    ...         # best practice.\n    ...         if not isinstance(other, Reference):\n    ...             raise ValueError('can only compare with Reference objects')\n    ...         return self._get_sorting_key() == other._get_sorting_key()\n\n    Here's a simple integer identifier tool.\n\n    >>> import persistent\n    >>> import BTrees\n    >>> import six\n    >>> class Registry(persistent.Persistent): # see zope.app.intid\n    ...     def __init__(self, family=BTrees.family32):\n    ...         self.family = family\n    ...         self.ids = self.family.IO.BTree()\n    ...         self.refs = self.family.OI.BTree()\n    ...     def getId(self, obj):\n    ...         if not isinstance(obj, persistent.Persistent):\n    ...             raise ValueError('not a persistent object', obj)\n    ...         if obj._p_jar is None:\n    ...             self._p_jar.add(obj)\n    ...         ref = Reference(obj)\n    ...         id = self.refs.get(ref)\n    ...         if id is None:\n    ...             # naive for conflict resolution; see zope.app.intid\n    ...             if self.ids:\n    ...                 id = self.ids.maxKey() + 1\n    ...             else:\n    ...                  id = self.family.minint\n    ...             self.ids[id] = ref\n    ...             self.refs[ref] = id\n    ...         return id\n    ...     def __contains__(self, obj):\n    ...         if (not isinstance(obj, persistent.Persistent) or\n    ...             obj._p_oid is None):\n    ...             return False\n    ...         return Reference(obj) in self.refs\n    ...     def getObject(self, id, default=None):\n    ...         res = self.ids.get(id, None)\n    ...         if res is None:\n    ...             return default\n    ...         else:\n    ...             return res.object\n    ...     def remove(self, r):\n    ...         if isinstance(r, six.integer_types):\n    ...             self.refs.pop(self.ids.pop(r))\n    ...         elif (not isinstance(r, persistent.Persistent) or\n    ...               r._p_oid is None):\n    ...             raise LookupError(r)\n    ...         else:\n    ...             self.ids.pop(self.refs.pop(Reference(r)))\n    ...\n    >>> registry = root['registry'] = Registry()\n\n    >>> import transaction\n    >>> transaction.commit()\n\nIn this implementation of the \"dump\" method, we use the cache just to\nshow you how you might use it.  It probably is overkill for this job,\nand maybe even a speed loss, but you can see the idea.\n\n    >>> def dump(obj, catalog, cache):\n    ...     reg = cache.get('registry')\n    ...     if reg is None:\n    ...         reg = cache['registry'] = catalog._p_jar.root()['registry']\n    ...     return reg.getId(obj)\n    ...\n    >>> def load(token, catalog, cache):\n    ...     reg = cache.get('registry')\n    ...     if reg is None:\n    ...         reg = cache['registry'] = catalog._p_jar.root()['registry']\n    ...     return reg.getObject(token)\n    ...\n\nNow we can create a relation catalog to hold these items.\n\n    >>> import zc.relation.catalog\n    >>> catalog = root['catalog'] = zc.relation.catalog.Catalog(dump, load)\n    >>> transaction.commit()\n\nNow we set up our indexes.  We'll start with just the organizations, and\nset up the catalog with them. This part will be similar to the example\nin README.rst, but will introduce more discussions of optimizations and\ntokens.  Then we'll add in the part about roles, and explore queries and\ntoken-based \"joins\".\n\nOrganizations\n=============\n\nThe organization will hold a set of organizations.  This is actually not\ninherently easy in the ZODB because this means that we need to compare\nor hash persistent objects, which does not work reliably over time and\nacross machines out-of-the-box.  To side-step the issue for this example,\nand still do something a bit interesting and real-world, we'll use the\nregistry tokens introduced above.  This will also give us a chance to\ntalk a bit more about optimizations and tokens.  (If you would like\nto sanely and transparently hold a set of persistent objects, try the\nzc.set package XXX not yet.)\n\n    >>> import BTrees\n    >>> import persistent\n    >>> @zope.interface.implementer(IOrganization)\n    ... @total_ordering\n    ... class Organization(persistent.Persistent):\n    ...\n    ...     def __init__(self, title):\n    ...         self.title = title\n    ...         self.parts = BTrees.family32.IF.TreeSet()\n    ...     # the next parts just make the tests prettier\n    ...     def __repr__(self):\n    ...         return '<Organization instance \"' + self.title + '\">'\n    ...     def __lt__(self, other):\n    ...         # pukes if other doesn't have name\n    ...         return self.title < other.title\n    ...     def __eq__(self, other):\n    ...         return self is other\n    ...     def __hash__(self):\n    ...         return 1  # dummy\n    ...\n\nOK, now we know how organizations will work.  Now we can add the `parts`\nindex to the catalog.  This will do a few new things from how we added\nindexes in the README.\n\n\n    >>> catalog.addValueIndex(IOrganization['parts'], multiple=True,\n    ...                       name=\"part\")\n\nSo, what's different from the README examples?\n\nFirst, we are using an interface element to define the value to be indexed.\nIt provides an interface to which objects will be adapted, a default name\nfor the index, and information as to whether the attribute should be used\ndirectly or called.\n\nSecond, we are not specifying a dump or load.  They are None.  This\nmeans that the indexed value can already be treated as a token.  This\ncan allow a very significant optimization for reindexing if the indexed\nvalue is a large collection using the same BTree family as the\nindex--which leads us to the next difference.\n\nThird, we are specifying that `multiple=True`.  This means that the value\non a given relation that provides or can be adapted to IOrganization will\nhave a collection of `parts`.  These will always be regarded as a set,\nwhether the actual colection is a BTrees set or the keys of a BTree.\n\nLast, we are specifying a name to be used for queries.  I find that queries\nread more easily when the query keys are singular, so I often rename plurals.\n\nAs in the README, We can add another simple transposing transitive query\nfactory, switching between 'part' and `None`.\n\n    >>> import zc.relation.queryfactory\n    >>> factory1 = zc.relation.queryfactory.TransposingTransitive(\n    ...     'part', None)\n    >>> catalog.addDefaultQueryFactory(factory1)\n\nLet's add a couple of search indexes in too, of the hierarchy looking up...\n\n    >>> import zc.relation.searchindex\n    >>> catalog.addSearchIndex(\n    ...     zc.relation.searchindex.TransposingTransitiveMembership(\n    ...         'part', None))\n\n...and down.\n\n    >>> catalog.addSearchIndex(\n    ...     zc.relation.searchindex.TransposingTransitiveMembership(\n    ...         None, 'part'))\n\nPLEASE NOTE: the search index looking up is not a good idea practically.  The\nindex is designed for looking down [#verifyObjectTransitive]_.\n\n.. [#verifyObjectTransitive] The TransposingTransitiveMembership indexes\n    provide ISearchIndex.\n\n    >>> from zope.interface.verify import verifyObject\n    >>> import zc.relation.interfaces\n    >>> index = list(catalog.iterSearchIndexes())[0]\n    >>> verifyObject(zc.relation.interfaces.ISearchIndex, index)\n    True\n\nLet's create and add a few organizations.\n\nWe'll make a structure like this [#silliness]_::\n\n         Ynod Corp Mangement                 Zookd Corp Management\n          /      |      \\                       /      |      \\\n   Ynod Devs  Ynod SAs  Ynod Admins  Zookd Admins   Zookd SAs  Zookd Devs\n     /      \\              \\                 /                /         \\\n Y3L4 Proj  Bet Proj      Ynod Zookd Task Force      Zookd hOgnmd     Zookd Nbd\n\nHere's the Python.\n\n\n    >>> orgs = root['organizations'] = BTrees.family32.OO.BTree()\n    >>> for nm, parts in (\n    ...     ('Y3L4 Proj', ()),\n    ...     ('Bet Proj', ()),\n    ...     ('Ynod Zookd Task Force', ()),\n    ...     ('Zookd hOgnmd', ()),\n    ...     ('Zookd Nbd', ()),\n    ...     ('Ynod Devs', ('Y3L4 Proj', 'Bet Proj')),\n    ...     ('Ynod SAs', ()),\n    ...     ('Ynod Admins', ('Ynod Zookd Task Force',)),\n    ...     ('Zookd Admins', ('Ynod Zookd Task Force',)),\n    ...     ('Zookd SAs', ()),\n    ...     ('Zookd Devs', ('Zookd hOgnmd', 'Zookd Nbd')),\n    ...     ('Ynod Corp Management', ('Ynod Devs', 'Ynod SAs', 'Ynod Admins')),\n    ...     ('Zookd Corp Management', ('Zookd Devs', 'Zookd SAs',\n    ...                                'Zookd Admins'))):\n    ...     org = Organization(nm)\n    ...     for part in parts:\n    ...         ignore = org.parts.insert(registry.getId(orgs[part]))\n    ...     orgs[nm] = org\n    ...     catalog.index(org)\n    ...\n\nNow the catalog knows about the relations.\n\n    >>> len(catalog)\n    13\n    >>> root['dummy'] = Organization('Foo')\n    >>> root['dummy'] in catalog\n    False\n    >>> orgs['Y3L4 Proj'] in catalog\n    True\n\nAlso, now we can search.  To do this, we can use some of the token methods that\nthe catalog provides.  The most commonly used is `tokenizeQuery`.  It takes a\nquery with values that are not tokenized and converts them to values that are\ntokenized.\n\n    >>> Ynod_SAs_id = registry.getId(orgs['Ynod SAs'])\n    >>> catalog.tokenizeQuery({None: orgs['Ynod SAs']}) == {\n    ...     None: Ynod_SAs_id}\n    True\n    >>> Zookd_SAs_id = registry.getId(orgs['Zookd SAs'])\n    >>> Zookd_Devs_id = registry.getId(orgs['Zookd Devs'])\n    >>> catalog.tokenizeQuery(\n    ...     {None: zc.relation.catalog.any(\n    ...         orgs['Zookd SAs'], orgs['Zookd Devs'])}) == {\n    ...     None: zc.relation.catalog.any(Zookd_SAs_id, Zookd_Devs_id)}\n    True\n\nOf course, right now doing this with 'part' alone is kind of silly, since it\ndoes not change within the relation catalog (because we said that dump and\nload were `None`, as discussed above).\n\n    >>> catalog.tokenizeQuery({'part': Ynod_SAs_id}) == {\n    ...     'part': Ynod_SAs_id}\n    True\n    >>> catalog.tokenizeQuery(\n    ...     {'part': zc.relation.catalog.any(Zookd_SAs_id, Zookd_Devs_id)}\n    ...     ) == {'part': zc.relation.catalog.any(Zookd_SAs_id, Zookd_Devs_id)}\n    True\n\nThe `tokenizeQuery` method is so common that we're going to assign it to\na variable in our example. Then we'll do a search or two.\n\nSo...find the relations that Ynod Devs supervise.\n\n    >>> t = catalog.tokenizeQuery\n    >>> res = list(catalog.findRelationTokens(t({None: orgs['Ynod Devs']})))\n\nOK...we used `findRelationTokens`, as opposed to `findRelations`, so res\nis a couple of numbers now.  How do we convert them back?\n`resolveRelationTokens` will do the trick.\n\n    >>> len(res)\n    3\n    >>> sorted(catalog.resolveRelationTokens(res))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [<Organization instance \"Bet Proj\">, <Organization instance \"Y3L4 Proj\">,\n     <Organization instance \"Ynod Devs\">]\n\n`resolveQuery` is the mirror image of `tokenizeQuery`: it converts\ntokenized queries to queries with \"loaded\" values.\n\n    >>> original = {'part': zc.relation.catalog.any(\n    ...                 Zookd_SAs_id, Zookd_Devs_id),\n    ...             None: orgs['Zookd Devs']}\n    >>> tokenized = catalog.tokenizeQuery(original)\n    >>> original == catalog.resolveQuery(tokenized)\n    True\n\n    >>> original = {None: zc.relation.catalog.any(\n    ...                 orgs['Zookd SAs'], orgs['Zookd Devs']),\n    ...             'part': Zookd_Devs_id}\n    >>> tokenized = catalog.tokenizeQuery(original)\n    >>> original == catalog.resolveQuery(tokenized)\n    True\n\nLikewise, `tokenizeRelations` is the mirror image of `resolveRelationTokens`.\n\n    >>> sorted(catalog.tokenizeRelations(\n    ...     [orgs[\"Bet Proj\"], orgs[\"Y3L4 Proj\"]])) == sorted(\n    ...     registry.getId(o) for o in\n    ...     [orgs[\"Bet Proj\"], orgs[\"Y3L4 Proj\"]])\n    True\n\nThe other token-related methods are as follows\n[#show_remaining_token_methods]_:\n\n.. [#show_remaining_token_methods] For what it's worth, here are some small\n    examples of the remaining token-related methods.\n\n    These two are the singular versions of `tokenizeRelations` and\n    `resolveRelationTokens`.\n\n    `tokenizeRelation` returns a token for the given relation.\n\n    >>> catalog.tokenizeRelation(orgs['Zookd Corp Management']) == (\n    ...     registry.getId(orgs['Zookd Corp Management']))\n    True\n\n    `resolveRelationToken` returns a relation for the given token.\n\n    >>> catalog.resolveRelationToken(registry.getId(\n    ...     orgs['Zookd Corp Management'])) is orgs['Zookd Corp Management']\n    True\n\n    The \"values\" ones are a bit lame to show now, since the only value\n    we have right now is not tokenized but used straight up.  But here\n    goes, showing some fascinating no-ops.\n\n    `tokenizeValues`, returns an iterable of tokens for the values of\n    the given index name.\n\n    >>> list(catalog.tokenizeValues((1,2,3), 'part'))\n    [1, 2, 3]\n\n    `resolveValueTokens` returns an iterable of values for the tokens of\n    the given index name.\n\n    >>> list(catalog.resolveValueTokens((1,2,3), 'part'))\n    [1, 2, 3]\n\n\n- `tokenizeValues`, which returns an iterable of tokens for the values\n  of the given index name;\n- `resolveValueTokens`, which returns an iterable of values for the tokens of\n  the given index name;\n- `tokenizeRelation`, which returns a token for the given relation; and\n- `resolveRelationToken`, which returns a relation for the given token.\n\nWhy do we bother with these tokens, instead of hiding them away and\nmaking the API prettier?  By exposing them, we enable efficient joining,\nand efficient use in other contexts.  For instance, if you use the same\nintid utility to tokenize in other catalogs, our results can be merged\nwith the results of other catalogs.  Similarly, you can use the results\nof queries to other catalogs--or even \"joins\" from earlier results of\nquerying this catalog--as query values here.  We'll explore this in the\nnext section.\n\nRoles\n=====\n\nWe have set up the Organization relations.  Now let's set up the roles, and\nactually be able to answer the questions that we described at the beginning\nof the document.\n\nIn our Roles object, roles and principals will simply be strings--ids, if\nthis were a real system.  The organization will be a direct object reference.\n\n    >>> @zope.interface.implementer(IRoles)\n    ... @total_ordering\n    ... class Roles(persistent.Persistent):\n    ...\n    ...     def __init__(self, principal_id, role_ids, organization):\n    ...         self.principal_id = principal_id\n    ...         self.role_ids = BTrees.family32.OI.TreeSet(role_ids)\n    ...         self._organization = organization\n    ...     def getOrganization(self):\n    ...         return self._organization\n    ...     # the rest is for prettier/easier tests\n    ...     def __repr__(self):\n    ...         return \"<Roles instance (%s has %s in %s)>\" % (\n    ...             self.principal_id, ', '.join(self.role_ids),\n    ...             self._organization.title)\n    ...     def __lt__(self, other):\n    ...         _self = (\n    ...             self.principal_id,\n    ...             tuple(self.role_ids),\n    ...             self._organization.title,\n    ...         )\n    ...         _other = (\n    ...             other.principal_id,\n    ...             tuple(other.role_ids),\n    ...             other._organization.title,\n    ...         )\n    ...         return _self <_other\n    ...     def __eq__(self, other):\n    ...         return self is other\n    ...     def __hash__(self):\n    ...         return 1  # dummy\n    ...\n\nNow let's add add the value indexes to the relation catalog.\n\n    >>> catalog.addValueIndex(IRoles['principal_id'], btree=BTrees.family32.OI)\n    >>> catalog.addValueIndex(IRoles['role_ids'], btree=BTrees.family32.OI,\n    ...                       multiple=True, name='role_id')\n    >>> catalog.addValueIndex(IRoles['getOrganization'], dump, load,\n    ...                       name='organization')\n\nThose are some slightly new variations of what we've seen in `addValueIndex`\nbefore, but all mixing and matching on the same ingredients.\n\nAs a reminder, here is our organization structure::\n\n         Ynod Corp Mangement                 Zookd Corp Management\n          /      |      \\                       /      |      \\\n   Ynod Devs  Ynod SAs  Ynod Admins  Zookd Admins   Zookd SAs  Zookd Devs\n     /      \\              \\                 /                /         \\\n Y3L4 Proj  Bet Proj      Ynod Zookd Task Force      Zookd hOgnmd     Zookd Nbd\n\nNow let's create and add some roles.\n\n    >>> principal_ids = [\n    ...     'abe', 'bran', 'cathy', 'david', 'edgar', 'frank', 'gertrude',\n    ...     'harriet', 'ignas', 'jacob', 'karyn', 'lettie', 'molly', 'nancy',\n    ...     'ophelia', 'pat']\n    >>> role_ids = ['user manager', 'writer', 'reviewer', 'publisher']\n    >>> get_role = dict((v[0], v) for v in role_ids).__getitem__\n    >>> roles = root['roles'] = BTrees.family32.IO.BTree()\n    >>> next = 0\n    >>> for prin, org, role_ids in (\n    ...     ('abe', orgs['Zookd Corp Management'], 'uwrp'),\n    ...     ('bran', orgs['Ynod Corp Management'], 'uwrp'),\n    ...     ('cathy', orgs['Ynod Devs'], 'w'),\n    ...     ('cathy', orgs['Y3L4 Proj'], 'r'),\n    ...     ('david', orgs['Bet Proj'], 'wrp'),\n    ...     ('edgar', orgs['Ynod Devs'], 'up'),\n    ...     ('frank', orgs['Ynod SAs'], 'uwrp'),\n    ...     ('frank', orgs['Ynod Admins'], 'w'),\n    ...     ('gertrude', orgs['Ynod Zookd Task Force'], 'uwrp'),\n    ...     ('harriet', orgs['Ynod Zookd Task Force'], 'w'),\n    ...     ('harriet', orgs['Ynod Admins'], 'r'),\n    ...     ('ignas', orgs['Zookd Admins'], 'r'),\n    ...     ('ignas', orgs['Zookd Corp Management'], 'w'),\n    ...     ('karyn', orgs['Zookd Corp Management'], 'uwrp'),\n    ...     ('karyn', orgs['Ynod Corp Management'], 'uwrp'),\n    ...     ('lettie', orgs['Zookd Corp Management'], 'u'),\n    ...     ('lettie', orgs['Ynod Zookd Task Force'], 'w'),\n    ...     ('lettie', orgs['Zookd SAs'], 'w'),\n    ...     ('molly', orgs['Zookd SAs'], 'uwrp'),\n    ...     ('nancy', orgs['Zookd Devs'], 'wrp'),\n    ...     ('nancy', orgs['Zookd hOgnmd'], 'u'),\n    ...     ('ophelia', orgs['Zookd Corp Management'], 'w'),\n    ...     ('ophelia', orgs['Zookd Devs'], 'r'),\n    ...     ('ophelia', orgs['Zookd Nbd'], 'p'),\n    ...     ('pat', orgs['Zookd Nbd'], 'wrp')):\n    ...     assert prin in principal_ids\n    ...     role_ids = [get_role(l) for l in role_ids]\n    ...     role = roles[next] = Roles(prin, role_ids, org)\n    ...     role.key = next\n    ...     next += 1\n    ...     catalog.index(role)\n    ...\n\nNow we can begin to do searches [#real_value_tokens]_.\n\n\n.. [#real_value_tokens] We can also show the values token methods more\n    sanely now.\n\n    >>> original = sorted((orgs['Zookd Devs'], orgs['Ynod SAs']))\n    >>> tokens = list(catalog.tokenizeValues(original, 'organization'))\n    >>> original == sorted(catalog.resolveValueTokens(tokens, 'organization'))\n    True\n\nWhat are all the role settings for ophelia?\n\n    >>> sorted(catalog.findRelations({'principal_id': 'ophelia'}))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [<Roles instance (ophelia has publisher in Zookd Nbd)>,\n     <Roles instance (ophelia has reviewer in Zookd Devs)>,\n     <Roles instance (ophelia has writer in Zookd Corp Management)>]\n\nThat answer does not need to be transitive: we're done.\n\nNext question.  Where does ophelia have the 'writer' role?\n\n    >>> list(catalog.findValues(\n    ...     'organization', {'principal_id': 'ophelia',\n    ...                        'role_id': 'writer'}))\n    [<Organization instance \"Zookd Corp Management\">]\n\nWell, that's correct intransitively.  Do we need a transitive queries\nfactory?  No! This is a great chance to look at the token join we talked\nabout in the previous section.  This should actually be a two-step\noperation: find all of the organizations in which ophelia has writer,\nand then find all of the transitive parts to that organization.\n\n    >>> sorted(catalog.findRelations({None: zc.relation.catalog.Any(\n    ...     catalog.findValueTokens('organization',\n    ...                             {'principal_id': 'ophelia',\n    ...                              'role_id': 'writer'}))}))\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [<Organization instance \"Ynod Zookd Task Force\">,\n     <Organization instance \"Zookd Admins\">,\n     <Organization instance \"Zookd Corp Management\">,\n     <Organization instance \"Zookd Devs\">,\n     <Organization instance \"Zookd Nbd\">,\n     <Organization instance \"Zookd SAs\">,\n     <Organization instance \"Zookd hOgnmd\">]\n\nThat's more like it.\n\nNext question.  What users have roles in the 'Zookd Devs' organization?\nIntransitively, that's pretty easy.\n\n    >>> sorted(catalog.findValueTokens(\n    ...     'principal_id', t({'organization': orgs['Zookd Devs']})))\n    ['nancy', 'ophelia']\n\nTransitively, we should do another join.\n\n    >>> org_id = registry.getId(orgs['Zookd Devs'])\n    >>> sorted(catalog.findValueTokens(\n    ...     'principal_id', {\n    ...         'organization': zc.relation.catalog.any(\n    ...             org_id, *catalog.findRelationTokens({'part': org_id}))}))\n    ['abe', 'ignas', 'karyn', 'lettie', 'nancy', 'ophelia']\n\nThat's a little awkward, but it does the trick.\n\nLast question, and the kind of question that started the entire example.\n What roles does ophelia have in the \"Zookd Nbd\" organization?\n\n    >>> list(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'ophelia'})))\n    ['publisher']\n\nIntransitively, that's correct.  But, transitively, ophelia also has\nreviewer and writer, and that's the answer we want to be able to get quickly.\n\nWe could ask the question a different way, then, again leveraging a join.\nWe'll set it up as a function, because we will want to use it a little later\nwithout repeating the code.\n\n    >>> def getRolesInOrganization(principal_id, org):\n    ...     org_id = registry.getId(org)\n    ...     return sorted(catalog.findValueTokens(\n    ...         'role_id', {\n    ...             'organization': zc.relation.catalog.any(\n    ...                 org_id,\n    ...                 *catalog.findRelationTokens({'part': org_id})),\n    ...             'principal_id': principal_id}))\n    ...\n    >>> getRolesInOrganization('ophelia', orgs['Zookd Nbd'])\n    ['publisher', 'reviewer', 'writer']\n\nAs you can see, then, working with tokens makes interesting joins possible,\nas long as the tokens are the same across the two queries.\n\nWe have examined tokens methods and token techniques like joins.  The example\nstory we have told can let us get into a few more advanced topics, such as\nquery factory joins and search indexes that can increase their read speed.\n\nQuery Factory Joins\n===================\n\nWe can build a query factory that makes the join automatic.  A query\nfactory is a callable that takes two arguments: a query (the one that\nstarts the search) and the catalog.  The factory either returns None,\nindicating that the query factory cannot be used for this query, or it\nreturns another callable that takes a chain of relations.  The last\ntoken in the relation chain is the most recent.  The output of this\ninner callable is expected to be an iterable of\nBTrees.family32.OO.Bucket queries to search further from the given chain\nof relations.\n\nHere's a flawed approach to this problem.\n\n    >>> def flawed_factory(query, catalog):\n    ...     if (len(query) == 2 and\n    ...         'organization' in query and\n    ...         'principal_id' in query):\n    ...         def getQueries(relchain):\n    ...             if not relchain:\n    ...                 yield query\n    ...                 return\n    ...             current = catalog.getValueTokens(\n    ...                 'organization', relchain[-1])\n    ...             if current:\n    ...                 organizations = catalog.getRelationTokens(\n    ...                     {'part': zc.relation.catalog.Any(current)})\n    ...                 if organizations:\n    ...                     res = BTrees.family32.OO.Bucket(query)\n    ...                     res['organization'] = zc.relation.catalog.Any(\n    ...                         organizations)\n    ...                     yield res\n    ...         return getQueries\n    ...\n\nThat works for our current example.\n\n    >>> sorted(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'ophelia'}),\n    ...     queryFactory=flawed_factory))\n    ['publisher', 'reviewer', 'writer']\n\nHowever, it won't work for other similar queries.\n\n    >>> getRolesInOrganization('abe', orgs['Zookd Nbd'])\n    ['publisher', 'reviewer', 'user manager', 'writer']\n    >>> sorted(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'abe'}),\n    ...     queryFactory=flawed_factory))\n    []\n\noops.\n\nThe flawed_factory is actually a useful pattern for more typical relation\ntraversal.  It goes from relation to relation to relation, and ophelia has\nconnected relations all the way to the top.  However, abe only has them at\nthe top, so nothing is traversed.\n\nInstead, we can make a query factory that modifies the initial query.\n\n    >>> def factory2(query, catalog):\n    ...     if (len(query) == 2 and\n    ...         'organization' in query and\n    ...         'principal_id' in query):\n    ...         def getQueries(relchain):\n    ...             if not relchain:\n    ...                 res = BTrees.family32.OO.Bucket(query)\n    ...                 org_id = query['organization']\n    ...                 if org_id is not None:\n    ...                     res['organization'] = zc.relation.catalog.any(\n    ...                         org_id,\n    ...                         *catalog.findRelationTokens({'part': org_id}))\n    ...                 yield res\n    ...         return getQueries\n    ...\n\n    >>> sorted(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'ophelia'}),\n    ...     queryFactory=factory2))\n    ['publisher', 'reviewer', 'writer']\n\n    >>> sorted(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'abe'}),\n    ...     queryFactory=factory2))\n    ['publisher', 'reviewer', 'user manager', 'writer']\n\nA difference between this and the other approach is that it is essentially\nintransitive: this query factory modifies the initial query, and then does\nnot give further queries.  The catalog currently always stops calling the\nquery factory if the queries do not return any results, so an approach like\nthe flawed_factory simply won't work for this kind of problem.\n\nWe could add this query factory as another default.\n\n    >>> catalog.addDefaultQueryFactory(factory2)\n\n    >>> sorted(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'ophelia'})))\n    ['publisher', 'reviewer', 'writer']\n\n    >>> sorted(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'abe'})))\n    ['publisher', 'reviewer', 'user manager', 'writer']\n\nThe previously installed query factory is still available.\n\n    >>> list(catalog.iterDefaultQueryFactories()) == [factory1, factory2]\n    True\n\n    >>> list(catalog.findRelations(\n    ...     {'part': registry.getId(orgs['Y3L4 Proj'])}))\n    ...     # doctest: +NORMALIZE_WHITESPACE\n    [<Organization instance \"Ynod Devs\">,\n     <Organization instance \"Ynod Corp Management\">]\n\n    >>> sorted(catalog.findRelations(\n    ...     {None: registry.getId(orgs['Ynod Corp Management'])}))\n    ...     # doctest: +NORMALIZE_WHITESPACE\n    [<Organization instance \"Bet Proj\">, <Organization instance \"Y3L4 Proj\">,\n     <Organization instance \"Ynod Admins\">,\n     <Organization instance \"Ynod Corp Management\">,\n     <Organization instance \"Ynod Devs\">, <Organization instance \"Ynod SAs\">,\n     <Organization instance \"Ynod Zookd Task Force\">]\n\nSearch Index for Query Factory Joins\n====================================\n\nNow that we have written a query factory that encapsulates the join, we can\nuse a search index that speeds it up.  We've only used transitive search\nindexes so far.  Now we will add an intransitive search index.\n\nThe intransitive search index generally just needs the search value\nnames it should be indexing, optionally the result name (defaulting to\nrelations), and optionally the query factory to be used.\n\nWe need to use two additional options because of the odd join trick we're\ndoing.  We need to specify what organization and principal_id values need\nto be changed when an object is indexed, and we need to indicate that we\nshould update when organization, principal_id, *or* parts changes.\n\n`getValueTokens` specifies the values that need to be indexed.  It gets\nthe index, the name for the tokens desired, the token, the catalog that\ngenerated the token change (it may not be the same as the index's\ncatalog, the source dictionary that contains a dictionary of the values\nthat will be used for tokens if you do not override them, a dict of the\nadded values for this token (keys are value names), a dict of the\nremoved values for this token, and whether the token has been removed.\nThe method can return None, which will leave the index to its default\nbehavior that should work if no query factory is used; or an iterable of\nvalues.\n\n    >>> def getValueTokens(index, name, token, catalog, source,\n    ...                    additions, removals, removed):\n    ...     if name == 'organization':\n    ...         orgs = source.get('organization')\n    ...         if not removed or not orgs:\n    ...             orgs = index.catalog.getValueTokens(\n    ...                 'organization', token)\n    ...             if not orgs:\n    ...                 orgs = [token]\n    ...                 orgs.extend(removals.get('part', ()))\n    ...         orgs = set(orgs)\n    ...         orgs.update(index.catalog.findValueTokens(\n    ...             'part',\n    ...             {None: zc.relation.catalog.Any(\n    ...                 t for t in orgs if t is not None)}))\n    ...         return orgs\n    ...     elif name == 'principal_id':\n    ...         # we only want custom behavior if this is an organization\n    ...         if 'principal_id' in source or index.catalog.getValueTokens(\n    ...             'principal_id', token):\n    ...             return ''\n    ...         orgs = set((token,))\n    ...         orgs.update(index.catalog.findRelationTokens(\n    ...             {'part': token}))\n    ...         return set(index.catalog.findValueTokens(\n    ...             'principal_id', {\n    ...                 'organization': zc.relation.catalog.Any(orgs)}))\n    ...\n\n    >>> index = zc.relation.searchindex.Intransitive(\n    ...     ('organization', 'principal_id'), 'role_id', factory2,\n    ...     getValueTokens,\n    ...     ('organization', 'principal_id', 'part', 'role_id'),\n    ...     unlimitedDepth=True)\n    >>> catalog.addSearchIndex(index)\n\n    >>> res = catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'ophelia'}))\n    >>> list(res)\n    ['publisher', 'reviewer', 'writer']\n    >>> list(res)\n    ['publisher', 'reviewer', 'writer']\n\n    >>> res = catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'abe'}))\n    >>> list(res)\n    ['publisher', 'reviewer', 'user manager', 'writer']\n    >>> list(res)\n    ['publisher', 'reviewer', 'user manager', 'writer']\n\n[#verifyObjectIntransitive]_\n\n.. [#verifyObjectIntransitive] The Intransitive search index provides\n    ISearchIndex and IListener.\n\n    >>> from zope.interface.verify import verifyObject\n    >>> import zc.relation.interfaces\n    >>> verifyObject(zc.relation.interfaces.ISearchIndex, index)\n    True\n    >>> verifyObject(zc.relation.interfaces.IListener, index)\n    True\n\nNow we can change and remove relations--both organizations and roles--and\nhave the index maintain correct state.  Given the current state of\norganizations--\n\n::\n\n         Ynod Corp Mangement                 Zookd Corp Management\n          /      |      \\                       /      |      \\\n   Ynod Devs  Ynod SAs  Ynod Admins  Zookd Admins   Zookd SAs  Zookd Devs\n     /      \\              \\                 /                /         \\\n Y3L4 Proj  Bet Proj      Ynod Zookd Task Force      Zookd hOgnmd     Zookd Nbd\n\n--first we will move Ynod Devs to beneath Zookd Devs, and back out.  This will\nbriefly give abe full privileges to Y3L4 Proj., among others.\n\n    >>> list(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n    ...                   'principal_id': 'abe'})))\n    []\n    >>> orgs['Zookd Devs'].parts.insert(registry.getId(orgs['Ynod Devs']))\n    1\n    >>> catalog.index(orgs['Zookd Devs'])\n    >>> res = catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n    ...                   'principal_id': 'abe'}))\n    >>> list(res)\n    ['publisher', 'reviewer', 'user manager', 'writer']\n    >>> list(res)\n    ['publisher', 'reviewer', 'user manager', 'writer']\n    >>> orgs['Zookd Devs'].parts.remove(registry.getId(orgs['Ynod Devs']))\n    >>> catalog.index(orgs['Zookd Devs'])\n    >>> list(catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n    ...                   'principal_id': 'abe'})))\n    []\n\nAs another example, we will change the roles abe has, and see that it is\npropagated down to Zookd Nbd.\n\n    >>> rels = list(catalog.findRelations(t(\n    ...     {'principal_id': 'abe',\n    ...      'organization': orgs['Zookd Corp Management']})))\n    >>> len(rels)\n    1\n    >>> rels[0].role_ids.remove('reviewer')\n    >>> catalog.index(rels[0])\n\n    >>> res = catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'abe'}))\n    >>> list(res)\n    ['publisher', 'user manager', 'writer']\n    >>> list(res)\n    ['publisher', 'user manager', 'writer']\n\nNote that search index order matters.  In our case, our intransitive search\nindex is relying on our transitive index, so the transitive index needs to\ncome first.  You want transitive relation indexes before name.  Right now,\nyou are in charge of this order: it will be difficult to come up with a\nreliable algorithm for guessing this.\n\nListeners, Catalog Administration, and Joining Across Relation Catalogs\n=======================================================================\n\nWe've done all of our examples so far with a single catalog that indexes\nboth kinds of relations.  What if we want to have two catalogs with\nhomogenous collections of relations?  That can feel cleaner, but it also\nintroduces some new wrinkles.\n\nLet's use our current catalog for organizations, removing the extra\ninformation; and create a new one for roles.\n\n    >>> role_catalog = root['role_catalog'] = catalog.copy()\n    >>> transaction.commit()\n    >>> org_catalog = catalog\n    >>> del catalog\n\nWe'll need a slightly different query factory and a slightly different\nsearch index `getValueTokens` function.  We'll write those, then modify the\nconfiguration of our two catalogs for the new world.\n\nThe transitive factory we write here is for the role catalog.  It needs\naccess to the organzation catalog.  We could do this a variety of\nways--relying on a utility, or finding the catalog from context.  We will\nmake the role_catalog have a .org_catalog attribute, and rely on that.\n\n    >>> role_catalog.org_catalog = org_catalog\n    >>> def factory3(query, catalog):\n    ...     if (len(query) == 2 and\n    ...         'organization' in query and\n    ...         'principal_id' in query):\n    ...         def getQueries(relchain):\n    ...             if not relchain:\n    ...                 res = BTrees.family32.OO.Bucket(query)\n    ...                 org_id = query['organization']\n    ...                 if org_id is not None:\n    ...                     res['organization'] = zc.relation.catalog.any(\n    ...                         org_id,\n    ...                         *catalog.org_catalog.findRelationTokens(\n    ...                             {'part': org_id}))\n    ...                 yield res\n    ...         return getQueries\n    ...\n\n    >>> def getValueTokens2(index, name, token, catalog, source,\n    ...                    additions, removals, removed):\n    ...     is_role_catalog = catalog is index.catalog # role_catalog\n    ...     if name == 'organization':\n    ...         if is_role_catalog:\n    ...             orgs = set(source.get('organization') or\n    ...                        index.catalog.getValueTokens(\n    ...                         'organization', token) or ())\n    ...         else:\n    ...             orgs = set((token,))\n    ...             orgs.update(removals.get('part', ()))\n    ...         orgs.update(index.catalog.org_catalog.findValueTokens(\n    ...             'part',\n    ...             {None: zc.relation.catalog.Any(\n    ...                 t for t in orgs if t is not None)}))\n    ...         return orgs\n    ...     elif name == 'principal_id':\n    ...         # we only want custom behavior if this is an organization\n    ...         if not is_role_catalog:\n    ...             orgs = set((token,))\n    ...             orgs.update(index.catalog.org_catalog.findRelationTokens(\n    ...                 {'part': token}))\n    ...             return set(index.catalog.findValueTokens(\n    ...                 'principal_id', {\n    ...                     'organization': zc.relation.catalog.Any(orgs)}))\n    ...     return ''\n\nIf you are following along in the code and comparing to the originals, you may\nsee that this approach is a bit cleaner than the one when the relations were\nin the same catalog.\n\nNow we will fix up the the organization catalog [#compare_copy]_.\n\n.. [#compare_copy] Before we modify them, let's look at the copy we made.\n    The copy should currently behave identically to the original.\n\n    >>> len(org_catalog)\n    38\n    >>> len(role_catalog)\n    38\n    >>> indexed = list(org_catalog)\n    >>> len(indexed)\n    38\n    >>> orgs['Zookd Devs'] in indexed\n    True\n    >>> for r in indexed:\n    ...     if r not in role_catalog:\n    ...         print('bad')\n    ...         break\n    ... else:\n    ...     print('good')\n    ...\n    good\n    >>> org_names = set(dir(org_catalog))\n    >>> role_names = set(dir(role_catalog))\n    >>> sorted(org_names - role_names)\n    []\n    >>> sorted(role_names - org_names)\n    ['org_catalog']\n\n    >>> def checkYnodDevsParts(catalog):\n    ...     res = sorted(catalog.findRelations(t({None: orgs['Ynod Devs']})))\n    ...     if res != [\n    ...         orgs[\"Bet Proj\"], orgs[\"Y3L4 Proj\"], orgs[\"Ynod Devs\"]]:\n    ...         print(\"bad\", res)\n    ...\n    >>> checkYnodDevsParts(org_catalog)\n    >>> checkYnodDevsParts(role_catalog)\n\n    >>> def checkOpheliaRoles(catalog):\n    ...     res = sorted(catalog.findRelations({'principal_id': 'ophelia'}))\n    ...     if repr(res) != (\n    ...         \"[<Roles instance (ophelia has publisher in Zookd Nbd)>, \" +\n    ...         \"<Roles instance (ophelia has reviewer in Zookd Devs)>, \" +\n    ...         \"<Roles instance (ophelia has writer in \" +\n    ...         \"Zookd Corp Management)>]\"):\n    ...         print(\"bad\", res)\n    ...\n    >>> checkOpheliaRoles(org_catalog)\n    >>> checkOpheliaRoles(role_catalog)\n\n    >>> def checkOpheliaWriterOrganizations(catalog):\n    ...     res = sorted(catalog.findRelations({None: zc.relation.catalog.Any(\n    ...         catalog.findValueTokens(\n    ...             'organization', {'principal_id': 'ophelia',\n    ...                              'role_id': 'writer'}))}))\n    ...     if repr(res) != (\n    ...         '[<Organization instance \"Ynod Zookd Task Force\">, ' +\n    ...         '<Organization instance \"Zookd Admins\">, ' +\n    ...         '<Organization instance \"Zookd Corp Management\">, ' +\n    ...         '<Organization instance \"Zookd Devs\">, ' +\n    ...         '<Organization instance \"Zookd Nbd\">, ' +\n    ...         '<Organization instance \"Zookd SAs\">, ' +\n    ...         '<Organization instance \"Zookd hOgnmd\">]'):\n    ...         print(\"bad\", res)\n    ...\n    >>> checkOpheliaWriterOrganizations(org_catalog)\n    >>> checkOpheliaWriterOrganizations(role_catalog)\n\n    >>> def checkPrincipalsWithRolesInZookdDevs(catalog):\n    ...     org_id = registry.getId(orgs['Zookd Devs'])\n    ...     res = sorted(catalog.findValueTokens(\n    ...         'principal_id',\n    ...         {'organization': zc.relation.catalog.any(\n    ...             org_id, *catalog.findRelationTokens({'part': org_id}))}))\n    ...     if res != ['abe', 'ignas', 'karyn', 'lettie', 'nancy', 'ophelia']:\n    ...         print(\"bad\", res)\n    ...\n    >>> checkPrincipalsWithRolesInZookdDevs(org_catalog)\n    >>> checkPrincipalsWithRolesInZookdDevs(role_catalog)\n\n    >>> def checkOpheliaRolesInZookdNbd(catalog):\n    ...     res = sorted(catalog.findValueTokens(\n    ...         'role_id', {\n    ...             'organization': registry.getId(orgs['Zookd Nbd']),\n    ...             'principal_id': 'ophelia'}))\n    ...     if res != ['publisher', 'reviewer', 'writer']:\n    ...         print(\"bad\", res)\n    ...\n    >>> checkOpheliaRolesInZookdNbd(org_catalog)\n    >>> checkOpheliaRolesInZookdNbd(role_catalog)\n\n    >>> def checkAbeRolesInZookdNbd(catalog):\n    ...     res = sorted(catalog.findValueTokens(\n    ...         'role_id', {\n    ...             'organization': registry.getId(orgs['Zookd Nbd']),\n    ...             'principal_id': 'abe'}))\n    ...     if res != ['publisher', 'user manager', 'writer']:\n    ...         print(\"bad\", res)\n    ...\n    >>> checkAbeRolesInZookdNbd(org_catalog)\n    >>> checkAbeRolesInZookdNbd(role_catalog)\n    >>> org_catalog.removeDefaultQueryFactory(None) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    LookupError: ('factory not found', None)\n\n    >>> org_catalog.removeValueIndex('organization')\n    >>> org_catalog.removeValueIndex('role_id')\n    >>> org_catalog.removeValueIndex('principal_id')\n    >>> org_catalog.removeDefaultQueryFactory(factory2)\n    >>> org_catalog.removeSearchIndex(index)\n    >>> org_catalog.clear()\n    >>> len(org_catalog)\n    0\n    >>> for v in orgs.values():\n    ...     org_catalog.index(v)\n\nThis also shows using the `removeDefaultQueryFactory` and `removeSearchIndex`\nmethods [#removeDefaultQueryFactoryExceptions]_.\n\n.. [#removeDefaultQueryFactoryExceptions] You get errors by removing query\n    factories that are not registered.\n\n    >>> org_catalog.removeDefaultQueryFactory(factory2) # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    ...\n    LookupError: ('factory not found', <function factory2 at ...>)\n\nNow we will set up the role catalog [#copy_unchanged]_.\n\n\n.. [#copy_unchanged] Changes to one copy should not affect the other.  That\n    means the role_catalog should still work as before.\n\n    >>> len(org_catalog)\n    13\n    >>> len(list(org_catalog))\n    13\n\n    >>> len(role_catalog)\n    38\n    >>> indexed = list(role_catalog)\n    >>> len(indexed)\n    38\n    >>> orgs['Zookd Devs'] in indexed\n    True\n    >>> orgs['Zookd Devs'] in role_catalog\n    True\n\n    >>> checkYnodDevsParts(role_catalog)\n    >>> checkOpheliaRoles(role_catalog)\n    >>> checkOpheliaWriterOrganizations(role_catalog)\n    >>> checkPrincipalsWithRolesInZookdDevs(role_catalog)\n    >>> checkOpheliaRolesInZookdNbd(role_catalog)\n    >>> checkAbeRolesInZookdNbd(role_catalog)\n\n    >>> role_catalog.removeValueIndex('part')\n    >>> for ix in list(role_catalog.iterSearchIndexes()):\n    ...     role_catalog.removeSearchIndex(ix)\n    ...\n    >>> role_catalog.removeDefaultQueryFactory(factory1)\n    >>> role_catalog.removeDefaultQueryFactory(factory2)\n    >>> role_catalog.addDefaultQueryFactory(factory3)\n    >>> root['index2'] = index2 = zc.relation.searchindex.Intransitive(\n    ...     ('organization', 'principal_id'), 'role_id', factory3,\n    ...     getValueTokens2,\n    ...     ('organization', 'principal_id', 'part', 'role_id'),\n    ...     unlimitedDepth=True)\n    >>> role_catalog.addSearchIndex(index2)\n\nThe new role_catalog index needs to be updated from the org_catalog.\nWe'll set that up using listeners, a new concept.\n\n    >>> org_catalog.addListener(index2)\n    >>> list(org_catalog.iterListeners()) == [index2]\n    True\n\nNow the role_catalog should be able to answer the same questions as the old\nsingle catalog approach.\n\n    >>> t = role_catalog.tokenizeQuery\n    >>> list(role_catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'abe'})))\n    ['publisher', 'user manager', 'writer']\n\n    >>> list(role_catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'ophelia'})))\n    ['publisher', 'reviewer', 'writer']\n\nWe can also make changes to both catalogs and the search indexes are\nmaintained.\n\n    >>> list(role_catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n    ...                   'principal_id': 'abe'})))\n    []\n    >>> orgs['Zookd Devs'].parts.insert(registry.getId(orgs['Ynod Devs']))\n    1\n    >>> org_catalog.index(orgs['Zookd Devs'])\n    >>> list(role_catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n    ...                   'principal_id': 'abe'})))\n    ['publisher', 'user manager', 'writer']\n    >>> orgs['Zookd Devs'].parts.remove(registry.getId(orgs['Ynod Devs']))\n    >>> org_catalog.index(orgs['Zookd Devs'])\n    >>> list(role_catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n    ...                   'principal_id': 'abe'})))\n    []\n\n    >>> rels = list(role_catalog.findRelations(t(\n    ...     {'principal_id': 'abe',\n    ...      'organization': orgs['Zookd Corp Management']})))\n    >>> len(rels)\n    1\n    >>> rels[0].role_ids.insert('reviewer')\n    1\n    >>> role_catalog.index(rels[0])\n\n    >>> res = role_catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd Nbd'],\n    ...                   'principal_id': 'abe'}))\n    >>> list(res)\n    ['publisher', 'reviewer', 'user manager', 'writer']\n\nHere we add a new organization.\n\n    >>> orgs['Zookd hOnc'] = org = Organization('Zookd hOnc')\n    >>> orgs['Zookd Devs'].parts.insert(registry.getId(org))\n    1\n    >>> org_catalog.index(orgs['Zookd hOnc'])\n    >>> org_catalog.index(orgs['Zookd Devs'])\n\n    >>> list(role_catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd hOnc'],\n    ...                   'principal_id': 'abe'})))\n    ['publisher', 'reviewer', 'user manager', 'writer']\n\n    >>> list(role_catalog.findValueTokens(\n    ...     'role_id', t({'organization': orgs['Zookd hOnc'],\n    ...                   'principal_id': 'ophelia'})))\n    ['reviewer', 'writer']\n\nNow we'll remove it.\n\n    >>> orgs['Zookd Devs'].parts.remove(registry.getId(org))\n    >>> org_catalog.index(orgs['Zookd Devs'])\n    >>> org_catalog.unindex(orgs['Zookd hOnc'])\n\nTODO make sure that intransitive copy looks the way we expect\n\n[#administrivia]_\n\n.. [#administrivia]\n\n    You can add listeners multiple times.\n\n    >>> org_catalog.addListener(index2)\n    >>> list(org_catalog.iterListeners()) == [index2, index2]\n    True\n\n    Now we will remove the listeners, to show we can.\n\n    >>> org_catalog.removeListener(index2)\n    >>> org_catalog.removeListener(index2)\n    >>> org_catalog.removeListener(index2)\n    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    LookupError: ('listener not found',\n                  <zc.relation.searchindex.Intransitive object at ...>)\n    >>> org_catalog.removeListener(None)\n    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    LookupError: ('listener not found', None)\n\n    Here's the same for removing a search index we don't have\n\n    >>> org_catalog.removeSearchIndex(index2)\n    ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    LookupError: ('index not found',\n                  <zc.relation.searchindex.Intransitive object at ...>)\n\n.. ......... ..\n.. Footnotes ..\n.. ......... ..\n\n\n.. [#silliness] In \"2001: A Space Odyssey\", many people believe the name HAL\n    was chosen because it was ROT25 of IBM....  I cheat a bit sometimes and\n    use ROT1 because the result sounds better.\n\n\n=================================================================\nWorking with Search Indexes: zc.relation Catalog Extended Example\n=================================================================\n\nIntroduction\n============\n\nThis document assumes you have read the README.rst document, and want to learn\na bit more by example. In it, we will explore a set of relations that\ndemonstrates most of the aspects of working with search indexes and listeners.\nIt will not explain the topics that the other documents already addressed. It\nalso describes an advanced use case.\n\nAs we have seen in the other documents, the relation catalog supports\nsearch indexes.  These can return the results of any search, as desired.\nOf course, the intent is that you supply an index that optimizes the\nparticular searches it claims.\n\nThe searchindex module supplies a few search indexes, optimizing\nspecified transitive and intransitive searches.  We have seen them working\nin other documents.  We will examine them more in depth in this document.\n\nSearch indexes update themselves by receiving messages via a \"listener\"\ninterface.  We will also look at how this works.\n\nThe example described in this file examines a use case similar to that in\nthe zc.revision or zc.vault packages: a relation describes a graph of\nother objects.  Therefore, this is our first concrete example of purely\nextrinsic relations.\n\nLet's build the example story a bit.  Imagine we have a graph, often a\nhierarchy, of tokens--integers.  Relations specify that a given integer\ntoken relates to other integer tokens, with a containment denotation or\nother meaning.\n\nThe integers may also have relations that specify that they represent an\nobject or objects.\n\nThis allows us to have a graph of objects in which changing one part of the\ngraph does not require changing the rest.  zc.revision and zc.vault thus\nare able to model graphs that can have multiple revisions efficiently and\nwith quite a bit of metadata to support merges.\n\nLet's imagine a simple hierarchy.  The relation has a `token` attribute\nand a `children` attribute; children point to tokens. Relations will\nidentify themselves with ids.\n\n    >>> import BTrees\n    >>> relations = BTrees.family64.IO.BTree()\n    >>> relations[99] = None # just to give us a start\n\n    >>> class Relation(object):\n    ...     def __init__(self, token, children=()):\n    ...         self.token = token\n    ...         self.children = BTrees.family64.IF.TreeSet(children)\n    ...         self.id = relations.maxKey() + 1\n    ...         relations[self.id] = self\n    ...\n\n    >>> def token(rel, self):\n    ...     return rel.token\n    ...\n    >>> def children(rel, self):\n    ...     return rel.children\n    ...\n    >>> def dumpRelation(obj, index, cache):\n    ...     return obj.id\n    ...\n    >>> def loadRelation(token, index, cache):\n    ...     return relations[token]\n    ...\n\nThe standard TransposingTransitiveQueriesFactory will be able to handle this\nquite well, so we'll use that for our index.\n\n    >>> import zc.relation.queryfactory\n    >>> factory = zc.relation.queryfactory.TransposingTransitive(\n    ...     'token', 'children')\n    >>> import zc.relation.catalog\n    >>> catalog = zc.relation.catalog.Catalog(\n    ...     dumpRelation, loadRelation, BTrees.family64.IO, BTrees.family64)\n    >>> catalog.addValueIndex(token)\n    >>> catalog.addValueIndex(children, multiple=True)\n    >>> catalog.addDefaultQueryFactory(factory)\n\nNow let's quickly create a hierarchy and index it.\n\n    >>> for token, children in (\n    ...     (0, (1, 2)), (1, (3, 4)), (2, (10, 11, 12)), (3, (5, 6)),\n    ...     (4, (13, 14)), (5, (7, 8, 9)), (6, (15, 16)), (7, (17, 18, 19)),\n    ...     (8, (20, 21, 22)), (9, (23, 24)), (10, (25, 26)),\n    ...     (11, (27, 28, 29, 30, 31, 32))):\n    ...     catalog.index(Relation(token, children))\n    ...\n\n[#queryFactory]_ That hierarchy is arbitrary.  Here's what we have, in terms of tokens\npointing to children::\n\n                                  _____________0_____________\n                                 /                           \\\n                        ________1_______                ______2____________\n                       /                \\              /          |        \\\n                ______3_____            _4_          10       ____11_____   12\n               /            \\          /   \\         / \\     / /  |  \\ \\ \\\n       _______5_______       6       13     14     25  26  27 28 29 30 31 32\n      /       |       \\     / \\\n    _7_      _8_       9   15 16\n   / | \\    / | \\     / \\\n 17 18 19  20 21 22  23 24\n\nTwelve relations, with tokens 0 through 11, and a total of 33 tokens,\nincluding children.  The ids for the 12 relations are 100 through 111,\ncorresponding with the tokens of 0 through 11.\n\nWithout a transitive search index, we can get all transitive results.\nThe results are iterators.\n\n    >>> res = catalog.findRelationTokens({'token': 0})\n    >>> import six\n    >>> next_attr = '__next__' if six.PY3 else 'next'\n    >>> getattr(res, next_attr) is None\n    False\n    >>> getattr(res, '__len__', None) is None\n    True\n    >>> sorted(res)\n    [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]\n    >>> list(res)\n    []\n\n    >>> res = catalog.findValueTokens('children', {'token': 0})\n    >>> sorted(res) == list(range(1, 33))\n    True\n    >>> list(res)\n    []\n\n[#findValuesUnindexed]_ `canFind` also can work transitively, and will\nuse transitive search indexes, as we'll see below.\n\n    >>> catalog.canFind({'token': 1}, targetQuery={'children': 23})\n    True\n    >>> catalog.canFind({'token': 2}, targetQuery={'children': 23})\n    False\n    >>> catalog.canFind({'children': 23}, targetQuery={'token': 1})\n    True\n    >>> catalog.canFind({'children': 23}, targetQuery={'token': 2})\n    False\n\n`findRelationTokenChains` won't change, but we'll include it in the\ndiscussion and examples to show that.\n\n    >>> res = catalog.findRelationTokenChains({'token': 2})\n    >>> chains = list(res)\n    >>> len(chains)\n    3\n    >>> len(list(res))\n    0\n\nTransitive Search Indexes\n=========================\n\nNow we can add a couple of transitive search index.  We'll talk about\nthem a bit first.\n\nThere is currently one variety of transitive index, which indexes\nrelation and value searches for the transposing transitive query\nfactory.\n\nThe index can only be used under certain conditions.\n\n    - The search is not a request for a relation chain.\n\n    - It does not specify a maximum depth.\n\n    - Filters are not used.\n\nIf it is a value search, then specific value indexes cannot be used if a\ntarget filter or target query are used, but the basic relation index can\nstill be used in that case.\n\nThe usage of the search indexes is largely transparent: set them up, and\nthe relation catalog will use them for the same API calls that used more\nbrute force previously.  The only difference from external uses is that\nresults that use an index will usually be a BTree structure, rather than\nan iterator.\n\nWhen you add a transitive index for a relation, you must specify the\ntransitive name (or names) of the query, and the same for the reverse.\nThat's all we'll do now.\n\n    >>> import zc.relation.searchindex\n    >>> catalog.addSearchIndex(\n    ...     zc.relation.searchindex.TransposingTransitiveMembership(\n    ...         'token', 'children', names=('children',)))\n\nNow we should have a search index installed.\n\nNotice that we went from parent (token) to child: this index is primarily\ndesigned for helping transitive membership searches in a hierarchy. Using it to\nindex parents would incur a lot of write expense for not much win.\n\nThere's just a bit more you can specify here: static fields for a query\nto do a bit of filtering.  We don't need any of that for this example.\n\nNow how does the catalog use this index for searches?  Three basic ways,\ndepending on the kind of search, relations, values, or `canFind`.\nBefore we start looking into the internals, let's verify that we're getting\nwhat we expect: correct answers, and not iterators, but BTree structures.\n\n    >>> res = catalog.findRelationTokens({'token': 0})\n    >>> list(res)\n    [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]\n    >>> list(res)\n    [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]\n\n    >>> res = catalog.findValueTokens('children', {'token': 0})\n    >>> list(res) == list(range(1, 33))\n    True\n    >>> list(res) == list(range(1, 33))\n    True\n\n    >>> catalog.canFind({'token': 1}, targetQuery={'children': 23})\n    True\n    >>> catalog.canFind({'token': 2}, targetQuery={'children': 23})\n    False\n\n[#findValuesIndexed]_ Note that the last two `canFind` examples from\nwhen we went through these examples without an index do not use the\nindex, so we don't show them here: they look the wrong direction for\nthis index.\n\nSo how do these results happen?\n\nThe first, `findRelationTokens`, and the last, `canFind`, are the most\nstraightforward.  The index finds all relations that match the given\nquery, intransitively. Then for each relation, it looks up the indexed\ntransitive results for that token.  The end result is the union of all\nindexed results found from the intransitive search.  `canFind` simply\ncasts the result into a boolean.\n\n`findValueTokens` is the same story as above with only one more step.  After\nthe union of relations is calculated, the method returns the union of the\nsets of the requested value for all found relations.\n\nIt will maintain itself when relations are reindexed.\n\n    >>> rel = list(catalog.findRelations({'token': 11}))[0]\n    >>> for t in (27, 28, 29, 30, 31):\n    ...     rel.children.remove(t)\n    ...\n    >>> catalog.index(rel)\n\n    >>> catalog.findValueTokens('children', {'token': 0})\n    ... # doctest: +NORMALIZE_WHITESPACE\n    LFSet([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n           20, 21, 22, 23, 24, 25, 26, 32])\n    >>> catalog.findValueTokens('children', {'token': 2})\n    LFSet([10, 11, 12, 25, 26, 32])\n    >>> catalog.findValueTokens('children', {'token': 11})\n    LFSet([32])\n\n    >>> rel.children.remove(32)\n    >>> catalog.index(rel)\n\n    >>> catalog.findValueTokens('children', {'token': 0})\n    ... # doctest: +NORMALIZE_WHITESPACE\n    LFSet([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n           20, 21, 22, 23, 24, 25, 26])\n    >>> catalog.findValueTokens('children', {'token': 2})\n    LFSet([10, 11, 12, 25, 26])\n    >>> catalog.findValueTokens('children', {'token': 11})\n    LFSet([])\n\n    >>> rel.children.insert(27)\n    1\n    >>> catalog.index(rel)\n\n    >>> catalog.findValueTokens('children', {'token': 0})\n    ... # doctest: +NORMALIZE_WHITESPACE\n    LFSet([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n           20, 21, 22, 23, 24, 25, 26, 27])\n    >>> catalog.findValueTokens('children', {'token': 2})\n    LFSet([10, 11, 12, 25, 26, 27])\n    >>> catalog.findValueTokens('children', {'token': 11})\n    LFSet([27])\n\nWhen the index is copied, the search index is copied.\n\n    >>> new = catalog.copy()\n    >>> res = list(new.iterSearchIndexes())\n    >>> len(res)\n    1\n    >>> new_index = res[0]\n    >>> res = list(catalog.iterSearchIndexes())\n    >>> len(res)\n    1\n    >>> old_index = res[0]\n    >>> new_index is old_index\n    False\n    >>> old_index.index is new_index.index\n    False\n    >>> list(old_index.index.keys()) == list(new_index.index.keys())\n    True\n    >>> from __future__ import print_function\n    >>> for key, value in old_index.index.items():\n    ...     v = new_index.index[key]\n    ...     if v is value or list(v) != list(value):\n    ...         print('oops', key, value, v)\n    ...         break\n    ... else:\n    ...     print('good')\n    ...\n    good\n    >>> old_index.names is not new_index.names\n    True\n    >>> list(old_index.names) == list(new_index.names)\n    True\n    >>> for name, old_ix in old_index.names.items():\n    ...     new_ix = new_index.names[name]\n    ...     if new_ix is old_ix or list(new_ix.keys()) != list(old_ix.keys()):\n    ...         print('oops')\n    ...         break\n    ...     for key, value in old_ix.items():\n    ...         v = new_ix[key]\n    ...         if v is value or list(v) != list(value):\n    ...             print('oops', name, key, value, v)\n    ...             break\n    ...     else:\n    ...         continue\n    ...     break\n    ... else:\n    ...     print('good')\n    ...\n    good\n\nHelpers\n=======\n\nWhen writing search indexes and query factories, you often want complete\naccess to relation catalog data.  We've seen a number of these tools already:\n\n- `getRelationModuleTools` gets a dictionary of the BTree tools needed to\n  work with relations.\n\n    >>> sorted(catalog.getRelationModuleTools().keys())\n    ... # doctest: +NORMALIZE_WHITESPACE\n    ['BTree', 'Bucket', 'Set', 'TreeSet', 'difference', 'dump',\n     'intersection', 'load', 'multiunion', 'union']\n\n    'multiunion' is only there if the BTree is an I* or L* module.\n    Use the zc.relation.catalog.multiunion helper function to do the\n    best union you can for a given set of tools.\n\n- `getValueModuleTools` does the same for indexed values.\n\n    >>> tools = set(('BTree', 'Bucket', 'Set', 'TreeSet', 'difference',\n    ...              'dump', 'intersection', 'load', 'multiunion', 'union'))\n    >>> tools.difference(catalog.getValueModuleTools('children').keys()) == set()\n    True\n\n    >>> tools.difference(catalog.getValueModuleTools('token').keys()) == set()\n    True\n\n- `getRelationTokens` can return all of the tokens in the catalog.\n\n    >>> len(catalog.getRelationTokens()) == len(catalog)\n    True\n\n    This also happens to be equivalent to `findRelationTokens` with an empty\n    query.\n\n    >>> catalog.getRelationTokens() is catalog.findRelationTokens({})\n    True\n\n    It also can return all the tokens that match a given query, or None if\n    there are no matches.\n\n    >>> catalog.getRelationTokens({'token': 0}) # doctest: +ELLIPSIS\n    <BTrees.LOBTree.LOTreeSet object at ...>\n    >>> list(catalog.getRelationTokens({'token': 0}))\n    [100]\n\n    This also happens to be equivalent to `findRelationTokens` with a query,\n    a maxDepth of 1, and no other arguments.\n\n    >>> catalog.findRelationTokens({'token': 0}, maxDepth=1) is (\n    ...     catalog.getRelationTokens({'token': 0}))\n    True\n\n    Except that if there are no matches, `findRelationTokens` returns an empty\n    set (so it *always* returns an iterable).\n\n    >>> catalog.findRelationTokens({'token': 50}, maxDepth=1)\n    LOSet([])\n    >>> print(catalog.getRelationTokens({'token': 50}))\n    None\n\n- `getValueTokens` can return all of the tokens for a given value name in\n    the catalog.\n\n    >>> list(catalog.getValueTokens('token')) == list(range(12))\n    True\n\n    This is identical to catalog.findValueTokens with a name only (or with\n    an empty query, and a maxDepth of 1).\n\n    >>> list(catalog.findValueTokens('token')) == list(range(12))\n    True\n    >>> catalog.findValueTokens('token') is catalog.getValueTokens('token')\n    True\n\n    It can also return the values for a given token.\n\n    >>> list(catalog.getValueTokens('children', 100))\n    [1, 2]\n\n    This is identical to catalog.findValueTokens with a name and a query of\n    {None: token}.\n\n    >>> list(catalog.findValueTokens('children', {None: 100}))\n    [1, 2]\n    >>> catalog.getValueTokens('children', 100) is (\n    ...     catalog.findValueTokens('children', {None: 100}))\n    True\n\n    Except that if there are no matches, `findValueTokens` returns an empty\n    set (so it *always* returns an iterable); while getValueTokens will\n    return None if the relation has no values (or the relation is unknown).\n\n    >>> catalog.findValueTokens('children', {None: 50}, maxDepth=1)\n    LFSet([])\n    >>> print(catalog.getValueTokens('children', 50))\n    None\n\n    >>> rel.children.remove(27)\n    >>> catalog.index(rel)\n    >>> catalog.findValueTokens('children', {None: rel.id}, maxDepth=1)\n    LFSet([])\n    >>> print(catalog.getValueTokens('children', rel.id))\n    None\n\n- `yieldRelationTokenChains` is a search workhorse for searches that use a\n    query factory.  TODO: describe.\n\n.. ......... ..\n.. Footnotes ..\n.. ......... ..\n\n.. [#queryFactory] The query factory knows when it is not needed--not only\n    when neither of its names are used, but also when both of its names are\n    used.\n\n    >>> list(catalog.findRelationTokens({'token': 0, 'children': 1}))\n    [100]\n\n.. [#findValuesUnindexed] When values are the same as their tokens,\n    `findValues` returns the same result as `findValueTokens`.  Here\n    we see this without indexes.\n\n    >>> list(catalog.findValueTokens('children', {'token': 0})) == list(\n    ...     catalog.findValues('children', {'token': 0}))\n    True\n\n.. [#findValuesIndexed] Again, when values are the same as their tokens,\n    `findValues` returns the same result as `findValueTokens`.  Here\n    we see this with indexes.\n\n    >>> list(catalog.findValueTokens('children', {'token': 0})) == list(\n    ...     catalog.findValues('children', {'token': 0}))\n    True\n\n\nOptimizing Relation Catalog Use\n===============================\n\nThere are several best practices and optimization opportunities in regards to\nthe catalog.\n\n- Use integer-keyed BTree sets when possible.  They can use the BTrees'\n  `multiunion` for a speed boost.  Integers' __cmp__ is reliable, and in C.\n\n- Never use persistent objects as keys.  They will cause a database load every\n  time you need to look at them, they take up memory and object caches, and\n  they (as of this writing) disable conflict resolution.  Intids (or similar)\n  are your best bet for representing objects, and some other immutable such as\n  strings are the next-best bet, and zope.app.keyreferences (or similar) are\n  after that.\n\n- Use multiple-token values in your queries when possible, especially in your\n  transitive query factories.\n\n- Use the cache when you are loading and dumping tokens, and in your\n  transitive query factories.\n\n- When possible, don't load or dump tokens (the values themselves may be used\n  as tokens).  This is especially important when you have multiple tokens:\n  store them in a BTree structure in the same module as the zc.relation module\n  for the value.\n\nFor some operations, particularly with hundreds or thousands of members in a\nsingle relation value, some of these optimizations can speed up some\ncommon-case reindexing work by around 100 times.\n\nThe easiest (and perhaps least useful) optimization is that all dump\ncalls and all load calls generated by a single operation share a cache\ndictionary per call type (dump/load), per indexed relation value.\nTherefore, for instance, we could stash an intids utility, so that we\nonly had to do a utility lookup once, and thereafter it was only a\nsingle dictionary lookup. This is what the default `generateToken` and\n`resolveToken` functions in zc.relationship's index.py do: look at them\nfor an example.\n\nA further optimization is to not load or dump tokens at all, but use values\nthat may be tokens.  This will be particularly useful if the tokens have\n__cmp__ (or equivalent) in C, such as built-in types like ints.  To specify\nthis behavior, you create an index with the 'load' and 'dump' values for the\nindexed attribute descriptions explicitly set to None.\n\n\n    >>> import zope.interface\n    >>> class IRelation(zope.interface.Interface):\n    ...     subjects = zope.interface.Attribute(\n    ...         'The sources of the relation; the subject of the sentence')\n    ...     relationtype = zope.interface.Attribute(\n    ...         '''unicode: the single relation type of this relation;\n    ...         usually contains the verb of the sentence.''')\n    ...     objects = zope.interface.Attribute(\n    ...         '''the targets of the relation; usually a direct or\n    ...         indirect object in the sentence''')\n    ...\n\n    >>> import BTrees\n    >>> relations = BTrees.family32.IO.BTree()\n    >>> relations[99] = None # just to give us a start\n\n    >>> @zope.interface.implementer(IRelation)\n    ... class Relation(object):\n    ...\n    ...     def __init__(self, subjects, relationtype, objects):\n    ...         self.subjects = subjects\n    ...         assert relationtype in relTypes\n    ...         self.relationtype = relationtype\n    ...         self.objects = objects\n    ...         self.id = relations.maxKey() + 1\n    ...         relations[self.id] = self\n    ...     def __repr__(self):\n    ...         return '<%r %s %r>' % (\n    ...             self.subjects, self.relationtype, self.objects)\n\n    >>> def token(rel, self):\n    ...     return rel.token\n    ...\n    >>> def children(rel, self):\n    ...     return rel.children\n    ...\n    >>> def dumpRelation(obj, index, cache):\n    ...     return obj.id\n    ...\n    >>> def loadRelation(token, index, cache):\n    ...     return relations[token]\n    ...\n\n    >>> relTypes = ['has the role of']\n    >>> def relTypeDump(obj, index, cache):\n    ...     assert obj in relTypes, 'unknown relationtype'\n    ...     return obj\n    ...\n    >>> def relTypeLoad(token, index, cache):\n    ...     assert token in relTypes, 'unknown relationtype'\n    ...     return token\n    ...\n\n    >>> import zc.relation.catalog\n    >>> catalog = zc.relation.catalog.Catalog(\n    ...     dumpRelation, loadRelation)\n    >>> catalog.addValueIndex(IRelation['subjects'], multiple=True)\n    >>> catalog.addValueIndex(\n    ...     IRelation['relationtype'], relTypeDump, relTypeLoad,\n    ...     BTrees.family32.OI, name='reltype')\n    >>> catalog.addValueIndex(IRelation['objects'], multiple=True)\n    >>> import zc.relation.queryfactory\n    >>> factory = zc.relation.queryfactory.TransposingTransitive(\n    ...     'subjects', 'objects')\n    >>> catalog.addDefaultQueryFactory(factory)\n\n    >>> rel = Relation((1,), 'has the role of', (2,))\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 1}))\n    [2]\n\nIf you have single relations that relate hundreds or thousands of\nobjects, it can be a huge win if the value is a 'multiple' of the same\ntype as the stored BTree for the given attribute.  The default BTree\nfamily for attributes is IFBTree; IOBTree is also a good choice, and may\nbe preferrable for some applications.\n\n    >>> catalog.unindex(rel)\n    >>> rel = Relation(\n    ...     BTrees.family32.IF.TreeSet((1,)), 'has the role of',\n    ...     BTrees.family32.IF.TreeSet())\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 1}))\n    []\n    >>> list(catalog.findValueTokens('subjects', {'objects': None}))\n    [1]\n\nReindexing is where some of the big improvements can happen.  The following\ngyrations exercise the optimization code.\n\n    >>> rel.objects.insert(2)\n    1\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 1}))\n    [2]\n    >>> rel.subjects = BTrees.family32.IF.TreeSet((3,4,5))\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 3}))\n    [2]\n\n    >>> rel.subjects.insert(6)\n    1\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 6}))\n    [2]\n\n    >>> rel.subjects.update(range(100, 200))\n    100\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 100}))\n    [2]\n\n    >>> rel.subjects = BTrees.family32.IF.TreeSet((3,4,5,6))\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 3}))\n    [2]\n\n    >>> rel.subjects = BTrees.family32.IF.TreeSet(())\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 3}))\n    []\n\n    >>> rel.subjects = BTrees.family32.IF.TreeSet((3,4,5))\n    >>> catalog.index(rel)\n    >>> list(catalog.findValueTokens('objects', {'subjects': 3}))\n    [2]\n\ntokenizeValues and resolveValueTokens work correctly without loaders and\ndumpers--that is, they do nothing.\n\n    >>> catalog.tokenizeValues((3,4,5), 'subjects')\n    (3, 4, 5)\n    >>> catalog.resolveValueTokens((3,4,5), 'subjects')\n    (3, 4, 5)\n\n\n=======\nChanges\n=======\n\n\n1.1.post2 (2018-06-18)\n======================\n\n- Another attempt to fix PyPI page by using correct expected metadata syntax.\n\n\n1.1.post1 (2018-06-18)\n======================\n\n- Fix PyPI page by using correct ReST syntax.\n\n\n1.1 (2018-06-15)\n================\n\n- Add support for Python 3.5 and 3.6.\n\n\n1.0 (2008-04-23)\n================\n\nThis is the initial release of the zc.relation package.  However, it\nrepresents a refactoring of another package, zc.relationship.  This\npackage contains only a modified version of the relation(ship) index,\nnow called a catalog. The refactored version of zc.relationship index\nrelies on (subclasses) this catalog. zc.relationship also maintains a\nbackwards-compatible subclass.\n\nThis package only relies on the ZODB, zope.interface, and zope.testing\nsoftware, and can be used inside or outside of a standard ZODB database.\nThe software does have to be there, though (the package relies heavily\non the ZODB BTrees package).\n\nIf you would like to switch a legacy zc.relationship index to a\nzc.relation catalog, try this trick in your generations script.\nAssuming the old index is ``old``, the following line should create\na new zc.relation catalog with your legacy data:\n\n    >>> new = old.copy(zc.relation.Catalog)\n\nWhy is the same basic data structure called a catalog now?  Because we\nexposed the ability to mutate the data structure, and what you are really\nadding and removing are indexes.  It didn't make sense to put an index in\nan index, but it does make sense to put an index in a catalog.  Thus, a\nname change was born.\n\nThe catalog in this package has several incompatibilities from the earlier\nzc.relationship index, and many new features.  The zc.relationship package\nmaintains a backwards-compatible subclass.  The following discussion\ncompares the zc.relation catalog with the zc.relationship 1.x index.\n\nIncompatibilities with zc.relationship 1.x index\n------------------------------------------------\n\nThe two big changes are that method names now refer to ``Relation`` rather\nthan ``Relationship``; and the catalog is instantiated slightly differently\nfrom the index.  A few other changes are worth your attention.  The\nfollowing list attempts to highlight all incompatibilities.\n\n:Big incompatibilities:\n\n    - ``findRelationshipTokenSet`` and ``findValueTokenSet`` are renamed, with\n      some slightly different semantics, as ``getRelationTokens`` and\n      ``getValueTokens``.  The exact same result as\n      ``findRelationTokenSet(query)`` can be obtained with\n      ``findRelationTokens(query, 1)`` (where 1 is maxDepth).  The same\n      result as ``findValueTokenSet(reltoken, name)`` can be obtained with\n      ``findValueTokens(name, {zc.relation.RELATION: reltoken}, 1)``.\n\n    - ``findRelations`` replaces ``findRelatonships``.  The new method will use\n      the defaultTransitiveQueriesFactory if it is set and maxDepth is not 1.\n      It shares the call signature of ``findRelationChains``.\n\n    - ``isLinked`` is now ``canFind``.\n\n    - The catalog instantiation arguments have changed from the old index.\n\n      * ``load`` and ``dump`` (formerly ``loadRel`` and ``dumpRel``,\n        respectively) are now required arguments for instantiation.\n\n      * The only other optional arguments are ``btree`` (was ``relFamily``) and\n        ``family``. You now specify what elements to index with\n        ``addValueIndex``\n\n      * Note also that ``addValueIndex`` defaults to no load and dump function,\n        unlike the old instantiation options.\n\n    - query factories are different.  See ``IQueryFactory`` in the interfaces.\n\n      * they first get (query, catalog, cache) and then return a getQueries\n        callable that gets relchains and yields queries; OR None if they\n        don't match.\n\n      * They must also handle an empty relchain.  Typically this should\n        return the original query, but may also be used to mutate the\n        original query.\n\n      * They are no longer thought of as transitive query factories, but as\n        general query mutators.\n\n:Medium:\n\n    - The catalog no longer inherits from\n      zope.app.container.contained.Contained.\n\n    - The index requires ZODB 3.8 or higher.\n\n:Small:\n\n    - ``deactivateSets`` is no longer an instantiation option (it was broken\n      because of a ZODB bug anyway, as had been described in the\n      documentation).\n\nChanges and new features\n------------------------\n\n- The catalog now offers the ability to index certain\n  searches.  The indexes must be explicitly instantiated and registered\n  you want to optimize. This can be used when searching for values, when\n  searching for relations, or when determining if two objects are\n  linked.  It cannot be used for relation chains. Requesting an index\n  has the usual trade-offs of greater storage space and slower write\n  speed for faster search speed.  Registering a search index is done\n  after instantiation time; you can iteratate over the current settings\n  used, and remove them.  (The code path expects to support legacy\n  zc.relationship index instances for all of these APIs.)\n\n- You can now specify new values after the catalog has been created, iterate\n  over the settings used, and remove values.\n\n- The catalog has a copy method, to quickly make new copies without actually\n  having to reindex the relations.\n\n- query arguments can now specify multiple values for a given name by\n  using zc.relation.catalog.any(1, 2, 3, 4) or\n  zc.relation.catalog.Any((1, 2, 3, 4)).\n\n- The catalog supports specifying indexed values by passing callables rather\n  than interface elements (which are also still supported).\n\n- ``findRelations`` and new method ``findRelationTokens`` can find\n  relations transitively and intransitively.  ``findRelationTokens``\n  when used intransitively repeats the legacy zc.relationship index\n  behavior of ``findRelationTokenSet``.\n  (``findRelationTokenSet`` remains in the API, not deprecated, a companion\n  to ``findValueTokenSet``.)\n\n- in findValues and findValueTokens, ``query`` argument is now optional.  If\n  the query evaluates to False in a boolean context, all values, or value\n  tokens, are returned.  Value tokens are explicitly returned using the\n  underlying BTree storage.  This can then be used directly for other BTree\n  operations.\n\n- Completely new docs.  Unfortunately, still really not good enough.\n\n- The package has drastically reduced direct dependecies from zc.relationship:\n  it is now more clearly a ZODB tool, with no other Zope dependencies than\n  zope.testing and zope.interface.\n\n- Listeners allow objects to listen to messages from the catalog (which can\n  be used directly or, for instance, to fire off events).\n\n- You can search for relations, using a key of zc.relation.RELATION...which is\n  really an alias for None. Sorry. But hey, use the constant! I think it is\n  more readable.\n\n- tokenizeQuery (and resolveQuery) now accept keyword arguments as an\n  alternative to a normal dict query.  This can make constructing the query\n  a bit more attractive (i.e., ``query = catalog.tokenizeQuery;\n  res = catalog.findValues('object', query(subject=joe, predicate=OWNS))``).\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/zopefoundation/zc.relation", "keywords": "zope zope3 relation", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "zc.relation", "package_url": "https://pypi.org/project/zc.relation/", "platform": "", "project_url": "https://pypi.org/project/zc.relation/", "project_urls": {"Homepage": "https://github.com/zopefoundation/zc.relation"}, "release_url": "https://pypi.org/project/zc.relation/1.1.post2/", "requires_dist": ["ZODB3 (>=3.8dev)", "setuptools", "six", "zope.interface", "zope.testing", "zc.relationship (>=2.0c1); extra == 'test'"], "requires_python": "", "summary": "Index intransitive and transitive n-ary relationships.", "version": "1.1.post2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"relation-catalog\">\n<h2><a href=\"#id30\" rel=\"nofollow\">Relation Catalog</a></h2>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#relation-catalog\" id=\"id30\" rel=\"nofollow\">Relation Catalog</a><ul>\n<li><a href=\"#overview\" id=\"id31\" rel=\"nofollow\">Overview</a></li>\n<li><a href=\"#history\" id=\"id32\" rel=\"nofollow\">History</a></li>\n<li><a href=\"#setting-up-a-relation-catalog\" id=\"id33\" rel=\"nofollow\">Setting Up a Relation Catalog</a><ul>\n<li><a href=\"#creating-the-catalog\" id=\"id34\" rel=\"nofollow\">Creating the Catalog</a></li>\n<li><a href=\"#adding-relations\" id=\"id35\" rel=\"nofollow\">Adding Relations</a></li>\n</ul>\n</li>\n<li><a href=\"#searching\" id=\"id36\" rel=\"nofollow\">Searching</a><ul>\n<li><a href=\"#queries-findrelations-and-special-query-values\" id=\"id37\" rel=\"nofollow\">Queries, <tt>findRelations</tt>, and special query values</a></li>\n<li><a href=\"#findvalues-and-the-relation-query-key\" id=\"id38\" rel=\"nofollow\"><tt>findValues</tt> and the <tt>RELATION</tt> query key</a></li>\n<li><a href=\"#tokens\" id=\"id39\" rel=\"nofollow\">Tokens</a></li>\n<li><a href=\"#transitive-searching-query-factories-and-maxdepth\" id=\"id40\" rel=\"nofollow\">Transitive Searching, Query Factories, and <tt>maxDepth</tt></a></li>\n<li><a href=\"#findrelationchains-and-targetquery\" id=\"id41\" rel=\"nofollow\"><tt>findRelationChains</tt> and <tt>targetQuery</tt></a></li>\n<li><a href=\"#filter-and-targetfilter\" id=\"id42\" rel=\"nofollow\"><tt>filter</tt> and <tt>targetFilter</tt></a></li>\n<li><a href=\"#search-indexes\" id=\"id43\" rel=\"nofollow\">Search indexes</a></li>\n<li><a href=\"#transitive-cycles-and-updating-and-removing-relations\" id=\"id44\" rel=\"nofollow\">Transitive cycles (and updating and removing relations)</a></li>\n<li><a href=\"#canfind\" id=\"id45\" rel=\"nofollow\"><tt>canFind</tt></a></li>\n</ul>\n</li>\n<li><a href=\"#working-with-more-complex-relations\" id=\"id46\" rel=\"nofollow\">Working with More Complex Relations</a><ul>\n<li><a href=\"#extrinsic-two-way-relations\" id=\"id47\" rel=\"nofollow\">Extrinsic Two-Way Relations</a></li>\n<li><a href=\"#multi-way-relations\" id=\"id48\" rel=\"nofollow\">Multi-Way Relations</a></li>\n</ul>\n</li>\n<li><a href=\"#additional-functionality\" id=\"id49\" rel=\"nofollow\">Additional Functionality</a><ul>\n<li><a href=\"#listeners\" id=\"id50\" rel=\"nofollow\">Listeners</a></li>\n<li><a href=\"#the-clear-method\" id=\"id51\" rel=\"nofollow\">The <tt>clear</tt> Method</a></li>\n<li><a href=\"#the-copy-method\" id=\"id52\" rel=\"nofollow\">The <tt>copy</tt> Method</a></li>\n<li><a href=\"#the-ignoresearchindex-argument\" id=\"id53\" rel=\"nofollow\">The <tt>ignoreSearchIndex</tt> argument</a></li>\n<li><a href=\"#findrelationtokens\" id=\"id54\" rel=\"nofollow\"><tt>findRelationTokens()</tt></a></li>\n<li><a href=\"#findvaluetokens-index-name\" id=\"id55\" rel=\"nofollow\"><tt>findValueTokens(INDEX_NAME)</tt></a></li>\n</ul>\n</li>\n<li><a href=\"#conclusion\" id=\"id56\" rel=\"nofollow\">Conclusion</a><ul>\n<li><a href=\"#review\" id=\"id57\" rel=\"nofollow\">Review</a></li>\n<li><a href=\"#next-steps\" id=\"id58\" rel=\"nofollow\">Next Steps</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#tokens-and-joins-zc-relation-catalog-extended-example\" id=\"id59\" rel=\"nofollow\">Tokens and Joins: zc.relation Catalog Extended Example</a><ul>\n<li><a href=\"#introduction-and-set-up\" id=\"id60\" rel=\"nofollow\">Introduction and Set Up</a></li>\n<li><a href=\"#organizations\" id=\"id61\" rel=\"nofollow\">Organizations</a></li>\n<li><a href=\"#roles\" id=\"id62\" rel=\"nofollow\">Roles</a></li>\n<li><a href=\"#query-factory-joins\" id=\"id63\" rel=\"nofollow\">Query Factory Joins</a></li>\n<li><a href=\"#search-index-for-query-factory-joins\" id=\"id64\" rel=\"nofollow\">Search Index for Query Factory Joins</a></li>\n<li><a href=\"#listeners-catalog-administration-and-joining-across-relation-catalogs\" id=\"id65\" rel=\"nofollow\">Listeners, Catalog Administration, and Joining Across Relation Catalogs</a></li>\n</ul>\n</li>\n<li><a href=\"#working-with-search-indexes-zc-relation-catalog-extended-example\" id=\"id66\" rel=\"nofollow\">Working with Search Indexes: zc.relation Catalog Extended Example</a><ul>\n<li><a href=\"#introduction\" id=\"id67\" rel=\"nofollow\">Introduction</a></li>\n<li><a href=\"#transitive-search-indexes\" id=\"id68\" rel=\"nofollow\">Transitive Search Indexes</a></li>\n<li><a href=\"#helpers\" id=\"id69\" rel=\"nofollow\">Helpers</a></li>\n<li><a href=\"#optimizing-relation-catalog-use\" id=\"id70\" rel=\"nofollow\">Optimizing Relation Catalog Use</a></li>\n</ul>\n</li>\n<li><a href=\"#changes\" id=\"id71\" rel=\"nofollow\">Changes</a><ul>\n<li><a href=\"#post2-2018-06-18\" id=\"id72\" rel=\"nofollow\">1.1.post2 (2018-06-18)</a></li>\n<li><a href=\"#post1-2018-06-18\" id=\"id73\" rel=\"nofollow\">1.1.post1 (2018-06-18)</a></li>\n<li><a href=\"#id28\" id=\"id74\" rel=\"nofollow\">1.1 (2018-06-15)</a></li>\n<li><a href=\"#id29\" id=\"id75\" rel=\"nofollow\">1.0 (2008-04-23)</a><ul>\n<li><a href=\"#incompatibilities-with-zc-relationship-1-x-index\" id=\"id76\" rel=\"nofollow\">Incompatibilities with zc.relationship 1.x index</a></li>\n<li><a href=\"#changes-and-new-features\" id=\"id77\" rel=\"nofollow\">Changes and new features</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"overview\">\n<h3><a href=\"#id31\" rel=\"nofollow\">Overview</a></h3>\n<p>The relation catalog can be used to optimize intransitive and transitive\nsearches for N-ary relations of finite, preset dimensions.</p>\n<p>For example, you can index simple two-way relations, like employee to\nsupervisor; RDF-style triples of subject-predicate-object; and more complex\nrelations such as subject-predicate-object with context and state.  These\ncan be searched with variable definitions of transitive behavior.</p>\n<p>The catalog can be used in the ZODB or standalone. It is a generic, relatively\npolicy-free tool.</p>\n<p>It is expected to be used usually as an engine for more specialized and\nconstrained tools and APIs. Three such tools are zc.relationship containers,\nplone.relations containers, and zc.vault. The documents in the package,\nincluding this one, describe other possible uses.</p>\n</div>\n<div id=\"history\">\n<h3><a href=\"#id32\" rel=\"nofollow\">History</a></h3>\n<p>This is a refactoring of the ZODB-only parts of the zc.relationship package.\nSpecifically, the zc.relation catalog is largely equivalent to the\nzc.relationship index. The index in the zc.relationship 2.x line is an\nalmost-completely backwards-compatible wrapper of the zc.relation catalog.\nzc.relationship will continue to be maintained, though active development is\nexpected to go into zc.relation.</p>\n<p>Many of the ideas come from discussions with and code from Casey Duncan, Tres\nSeaver, Ken Manheimer, and more.</p>\n</div>\n<div id=\"setting-up-a-relation-catalog\">\n<h3><a href=\"#id33\" rel=\"nofollow\">Setting Up a Relation Catalog</a></h3>\n<p>In this section, we will be introducing the following ideas.</p>\n<ul>\n<li>Relations are objects with indexed values.</li>\n<li>You add value indexes to relation catalogs to be able to search.  Values\ncan be identified to the catalog with callables or interface elements. The\nindexed value must be specified to the catalog as a single value or a\ncollection.</li>\n<li>Relations and their values are stored in the catalog as tokens: unique\nidentifiers that you can resolve back to the original value. Integers are the\nmost efficient tokens, but others can work fine too.</li>\n<li>Token type determines the BTree module needed.</li>\n<li>You must define your own functions for tokenizing and resolving tokens. These\nfunctions are registered with the catalog for the relations and for each of\ntheir value indexes.</li>\n<li>Relations are indexed with <tt>index</tt>.</li>\n</ul>\n<p>We will use a simple two way relation as our example here. A brief introduction\nto a more complex RDF-style subject-predicate-object set up can be found later\nin the document.</p>\n<div id=\"creating-the-catalog\">\n<h4><a href=\"#id34\" rel=\"nofollow\">Creating the Catalog</a></h4>\n<p>Imagine a two way relation from one value to another.  Let\u2019s say that we\nare modeling a relation of people to their supervisors: an employee may\nhave a single supervisor.  For this first example, the relation between\nemployee and supervisor will be intrinsic: the employee has a pointer to\nthe supervisor, and the employee object itself represents the relation.</p>\n<p>Let\u2019s say further, for simplicity, that employee names are unique and\ncan be used to represent employees.  We can use names as our \u201ctokens\u201d.</p>\n<p>Tokens are similar to the primary key in a relational database. A token is a\nway to identify an object. It must sort reliably and you must be able to write\na callable that reliably resolves to the object given the right context. In\nZope 3, intids (zope.app.intid) and keyreferences (zope.app.keyreference) are\ngood examples of reasonable tokens.</p>\n<p>As we\u2019ll see below, you provide a way to convert objects to tokens, and resolve\ntokens to objects, for the relations, and for each value index individually.\nThey can be the all the same functions or completely different, depending on\nyour needs.</p>\n<p>For speed, integers make the best tokens; followed by other\nimmutables like strings; followed by non-persistent objects; followed by\npersistent objects.  The choice also determines a choice of BTree module, as\nwe\u2019ll see below.</p>\n<p>Here is our toy <tt>Employee</tt> example class.  Again, we will use the employee\nname as the tokens.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; employees = {} # we'll use this to resolve the \"name\" tokens\n&gt;&gt;&gt; from functools import total_ordering\n&gt;&gt;&gt; @total_ordering\n... class Employee(object):\n...     def __init__(self, name, supervisor=None):\n...         if name in employees:\n...             raise ValueError('employee with same name already exists')\n...         self.name = name # expect this to be readonly\n...         self.supervisor = supervisor\n...         employees[name] = self\n...     # the next parts just make the tests prettier\n...     def __repr__(self):\n...         return '&lt;Employee instance \"' + self.name + '\"&gt;'\n...     def __lt__(self, other):\n...         return self.name &lt; other.name\n...     def __eq__(self, other):\n...         return self is other\n...     def __hash__(self):\n...         ''' Dummy method needed because we defined __eq__\n...         '''\n...         return 1\n...\n</pre>\n</blockquote>\n<p>So, we need to define how to turn employees into their tokens.  We call the\ntokenization a \u201cdump\u201d function. Conversely, the function to resolve tokens into\nobjects is called a \u201cload\u201d.</p>\n<p>Functions to dump relations and values get several arguments. The first\nargument is the object to be tokenized. Next, because it helps sometimes to\nprovide context, is the catalog. The last argument is a dictionary that will be\nshared for a given search. The dictionary can be ignored, or used as a cache\nfor optimizations (for instance, to stash a utility that you looked up).</p>\n<p>For this example, our function is trivial: we said the token would be\nthe employee\u2019s name.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def dumpEmployees(emp, catalog, cache):\n...     return emp.name\n...\n</pre>\n</blockquote>\n<p>If you store the relation catalog persistently (e.g., in the ZODB) be aware\nthat the callables you provide must be picklable\u2013a module-level function,\nfor instance.</p>\n<p>We also need a way to turn tokens into employees, or \u201cload\u201d.</p>\n<p>The \u201cload\u201d functions get the token to be resolved; the catalog, for\ncontext; and a dict cache, for optimizations of subsequent calls.</p>\n<p>You might have noticed in our <tt>Employee.__init__</tt> that we keep a mapping\nof name to object in the <tt>employees</tt> global dict (defined right above\nthe class definition).  We\u2019ll use that for resolving the tokens.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def loadEmployees(token, catalog, cache):\n...     return employees[token]\n...\n</pre>\n</blockquote>\n<p>Now we know enough to get started with a catalog.  We\u2019ll instantiate it\nby specifying how to tokenize relations, and what kind of BTree modules\nshould be used to hold the tokens.</p>\n<p>How do you pick BTree modules?</p>\n<ul>\n<li>If the tokens are 32-bit ints, choose <tt>BTrees.family32.II</tt>,\n<tt>BTrees.family32.IF</tt> or <tt>BTrees.family32.IO</tt>.</li>\n<li>If the tokens are 64 bit ints, choose <tt>BTrees.family64.II</tt>,\n<tt>BTrees.family64.IF</tt> or <tt>BTrees.family64.IO</tt>.</li>\n<li>If they are anything else, choose <tt>BTrees.family32.OI</tt>,\n<tt>BTrees.family64.OI</tt>, or <tt>BTrees.family32.OO</tt> (or\n<tt>BTrees.family64.OO</tt>\u2013they are the same).</li>\n</ul>\n<p>Within these rules, the choice is somewhat arbitrary unless you plan to merge\nthese results with that of another source that is using a particular BTree\nmodule. BTree set operations only work within the same module, so you must\nmatch module to module. The catalog defaults to IF trees, because that\u2019s what\nstandard zope catalogs use. That\u2019s as reasonable a choice as any, and will\npotentially come in handy if your tokens are in fact the same as those used by\nthe zope catalog and you want to do some set operations.</p>\n<p>In this example, our tokens are strings, so we want OO or an OI variant.  We\u2019ll\nchoose BTrees.family32.OI, arbitrarily.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation.catalog\n&gt;&gt;&gt; import BTrees\n&gt;&gt;&gt; catalog = zc.relation.catalog.Catalog(dumpEmployees, loadEmployees,\n...                                       btree=BTrees.family32.OI)\n</pre>\n</blockquote>\n<p><a href=\"#verifyobjecticatalog\" id=\"id1\" rel=\"nofollow\">[1]</a></p>\n<table id=\"verifyobjecticatalog\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id1\" rel=\"nofollow\">[1]</a></td><td><p>The catalog provides ICatalog.</p>\n<pre>\n&gt;&gt;&gt; from zope.interface.verify import verifyObject\n&gt;&gt;&gt; import zc.relation.interfaces\n&gt;&gt;&gt; verifyObject(zc.relation.interfaces.ICatalog, catalog)\nTrue\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p><a href=\"#legacy\" id=\"id2\" rel=\"nofollow\">[2]</a></p>\n<table id=\"legacy\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id2\" rel=\"nofollow\">[2]</a></td><td><p>Old instances of zc.relationship indexes, which in the newest\nversion subclass a zc.relation Catalog, used to have a dict in an\ninternal data structure.  We specify that here so that the code that\nconverts the dict to an OOBTree can have a chance to run.</p>\n<pre>\n&gt;&gt;&gt; catalog._attrs = dict(catalog._attrs)\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>Look! A relation catalog! We can\u2019t do very\nmuch searching with it so far though, because the catalog doesn\u2019t have any\nindexes.</p>\n<p>In this example, the relation itself represents the employee, so we won\u2019t need\nto index that separately.</p>\n<p>But we do need a way to tell the catalog how to find the other end of the\nrelation, the supervisor. You can specify this to the catalog with an attribute\nor method specified from <tt>zope.interface Interface</tt>, or with a callable.\nWe\u2019ll use a callable for now. The callable will receive the indexed relation\nand the catalog for context.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def supervisor(emp, catalog):\n...     return emp.supervisor # None or another employee\n...\n</pre>\n</blockquote>\n<p>We\u2019ll also need to specify how to tokenize (dump and load) those values. In\nthis case, we\u2019re able to use the same functions as the relations themselves.\nHowever, do note that we can specify a completely different way to dump and\nload for each \u201cvalue index,\u201d or relation element.</p>\n<p>We could also specify the name to call the index, but it will default to the\n<tt>__name__</tt> of the function (or interface element), which will work just fine\nfor us now.</p>\n<p>Now we can add the \u201csupervisor\u201d value index.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.addValueIndex(supervisor, dumpEmployees, loadEmployees,\n...                       btree=BTrees.family32.OI)\n</pre>\n</blockquote>\n<p>Now we have an index <a href=\"#addvalueindexexceptions\" id=\"id3\" rel=\"nofollow\">[3]</a>.</p>\n<table id=\"addvalueindexexceptions\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id3\" rel=\"nofollow\">[3]</a></td><td><p>Adding a value index can generate several\nexceptions.</p>\n<p>You must supply both of dump and load or neither.</p>\n<pre>\n&gt;&gt;&gt; catalog.addValueIndex(supervisor, dumpEmployees, None,\n...                       btree=BTrees.family32.OI, name='supervisor2')\nTraceback (most recent call last):\n...\nValueError: either both of 'dump' and 'load' must be None, or neither\n</pre>\n<p>In this example, even if we fix it, we\u2019ll get an error, because we have\nalready indexed the supervisor function.</p>\n<pre>\n&gt;&gt;&gt; catalog.addValueIndex(supervisor, dumpEmployees, loadEmployees,\n...                       btree=BTrees.family32.OI, name='supervisor2')\n... # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: ('element already indexed', &lt;function supervisor at ...&gt;)\n</pre>\n<p>You also can\u2019t add a different function under the same name.</p>\n<pre>\n&gt;&gt;&gt; def supervisor2(emp, catalog):\n...     return emp.supervisor # None or another employee\n...\n&gt;&gt;&gt; catalog.addValueIndex(supervisor2, dumpEmployees, loadEmployees,\n...                       btree=BTrees.family32.OI, name='supervisor')\n... # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: ('name already used', 'supervisor')\n</pre>\n<p>Finally, if your function does not have a <tt>__name__</tt> and you do not\nprovide one, you may not add an index.</p>\n<pre>\n&gt;&gt;&gt; class Supervisor3(object):\n...     __name__ = None\n...     def __call__(klass, emp, catalog):\n...         return emp.supervisor\n...\n&gt;&gt;&gt; supervisor3 = Supervisor3()\n&gt;&gt;&gt; supervisor3.__name__\n&gt;&gt;&gt; catalog.addValueIndex(supervisor3, dumpEmployees, loadEmployees,\n...                       btree=BTrees.family32.OI)\n... # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: no name specified\n</pre>\n<pre>\n&gt;&gt;&gt; [info['name'] for info in catalog.iterValueIndexInfo()]\n['supervisor']\n</pre>\n</td></tr>\n</tbody>\n</table>\n</div>\n<div id=\"adding-relations\">\n<h4><a href=\"#id35\" rel=\"nofollow\">Adding Relations</a></h4>\n<p>Now let\u2019s create a few employees.  All but one will have supervisors.\nIf you recall our toy <tt>Employee</tt> class, the first argument to the\nconstructor is the employee name (and therefore the token), and the\noptional second argument is the supervisor.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = Employee('Alice')\n&gt;&gt;&gt; b = Employee('Betty', a)\n&gt;&gt;&gt; c = Employee('Chuck', a)\n&gt;&gt;&gt; d = Employee('Diane', b)\n&gt;&gt;&gt; e = Employee('Edgar', b)\n&gt;&gt;&gt; f = Employee('Frank', c)\n&gt;&gt;&gt; g = Employee('Galyn', c)\n&gt;&gt;&gt; h = Employee('Howie', d)\n</pre>\n</blockquote>\n<p>Here is a diagram of the hierarchy.</p>\n<pre>            Alice\n         __/     \\__\n    Betty           Chuck\n    /   \\           /   \\\nDiane   Edgar   Frank   Galyn\n  |\nHowie\n</pre>\n<p>Let\u2019s tell the catalog about the relations, using the <tt>index</tt> method.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; for emp in (a,b,c,d,e,f,g,h):\n...     catalog.index(emp)\n...\n</pre>\n</blockquote>\n<p>We\u2019ve now created the relation catalog and added relations to it. We\u2019re ready\nto search!</p>\n</div>\n</div>\n<div id=\"searching\">\n<h3><a href=\"#id36\" rel=\"nofollow\">Searching</a></h3>\n<p>In this section, we will introduce the following ideas.</p>\n<ul>\n<li>Queries to the relation catalog are formed with dicts.</li>\n<li>Query keys are the names of the indexes you want to search, or, for the\nspecial case of precise relations, the <tt>zc.relation.RELATION</tt> constant.</li>\n<li>Query values are the tokens of the results you want to match; or <tt>None</tt>,\nindicating relations that have <tt>None</tt> as a value (or an empty collection,\nif it is a multiple). Search values can use\n<tt>zc.relation.catalog.any(args)</tt> or <tt>zc.relation.catalog.Any(args)</tt> to\nspecify multiple (non-<tt>None</tt>) results to match for a given key.</li>\n<li>The index has a variety of methods to help you work with tokens.\n<tt>tokenizeQuery</tt> is typically the most used, though others are available.</li>\n<li>To find relations that match a query, use <tt>findRelations</tt> or\n<tt>findRelationTokens</tt>.</li>\n<li>To find values that match a query, use <tt>findValues</tt> or <tt>findValueTokens</tt>.</li>\n<li>You search transitively by using a query factory. The\n<tt>zc.relation.queryfactory.TransposingTransitive</tt> is a good common case\nfactory that lets you walk up and down a hierarchy. A query factory can be\npassed in as an argument to search methods as a <tt>queryFactory</tt>, or\ninstalled as a default behavior using <tt>addDefaultQueryFactory</tt>.</li>\n<li>To find how a query is related, use <tt>findRelationChains</tt> or\n<tt>findRelationTokenChains</tt>.</li>\n<li>To find out if a query is related, use <tt>canFind</tt>.</li>\n<li>Circular transitive relations are handled to prevent infinite loops. They\nare identified in <tt>findRelationChains</tt> and <tt>findRelationTokenChains</tt> with\na <tt>zc.relation.interfaces.ICircularRelationPath</tt> marker interface.</li>\n<li>search methods share the following arguments:<ul>\n<li><tt>maxDepth</tt>, limiting the transitive depth for searches;</li>\n<li><tt>filter</tt>, allowing code to filter transitive paths;</li>\n<li><tt>targetQuery</tt>, allowing a query to filter transitive paths on the basis\nof the endpoint;</li>\n<li><tt>targetFilter</tt>, allowing code to filter transitive paths on the basis of\nthe endpoint; and</li>\n<li><tt>queryFactory</tt>, mentioned above.</li>\n</ul>\n</li>\n<li>You can set up search indexes to speed up specific transitive searches.</li>\n</ul>\n<div id=\"queries-findrelations-and-special-query-values\">\n<h4><a href=\"#id37\" rel=\"nofollow\">Queries, <tt>findRelations</tt>, and special query values</a></h4>\n<p>So who works for Alice?  That means we want to get the relations\u2013the\nemployees\u2013with a <tt>supervisor</tt> of Alice.</p>\n<p>The heart of a question to the catalog is a query.  A query is spelled\nas a dictionary.  The main idea is simply that keys in a dictionary\nspecify index names, and the values specify the constraints.</p>\n<p>The values in a query are always expressed with tokens.  The catalog has\nseveral helpers to make this less onerous, but for now let\u2019s take\nadvantage of the fact that our tokens are easily comprehensible.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelations({'supervisor': 'Alice'}))\n[&lt;Employee instance \"Betty\"&gt;, &lt;Employee instance \"Chuck\"&gt;]\n</pre>\n</blockquote>\n<p>Alice is the direct (intransitive) boss of Betty and Chuck.</p>\n<p>What if you want to ask \u201cwho doesn\u2019t report to anyone?\u201d  Then you want to\nask for a relation in which the supervisor is None.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findRelations({'supervisor': None}))\n[&lt;Employee instance \"Alice\"&gt;]\n</pre>\n</blockquote>\n<p>Alice is the only employee who doesn\u2019t report to anyone.</p>\n<p>What if you want to ask \u201cwho reports to Diane or Chuck?\u201d  Then you use the\nzc.relation <tt>Any</tt> class or <tt>any</tt> function to pass the multiple values.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelations(\n...     {'supervisor': zc.relation.catalog.any('Diane', 'Chuck')}))\n... # doctest: +NORMALIZE_WHITESPACE\n[&lt;Employee instance \"Frank\"&gt;, &lt;Employee instance \"Galyn\"&gt;,\n &lt;Employee instance \"Howie\"&gt;]\n</pre>\n</blockquote>\n<p>Frank, Galyn, and Howie each report to either Diane or Chuck. <a href=\"#any\" id=\"id4\" rel=\"nofollow\">[4]</a></p>\n<table id=\"any\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id4\" rel=\"nofollow\">[4]</a></td><td><p><tt>Any</tt> can be compared.</p>\n<pre>\n&gt;&gt;&gt; zc.relation.catalog.any('foo', 'bar', 'baz')\n&lt;zc.relation.catalog.Any instance ('bar', 'baz', 'foo')&gt;\n&gt;&gt;&gt; (zc.relation.catalog.any('foo', 'bar', 'baz') ==\n...  zc.relation.catalog.any('bar', 'foo', 'baz'))\nTrue\n&gt;&gt;&gt; (zc.relation.catalog.any('foo', 'bar', 'baz') !=\n...  zc.relation.catalog.any('bar', 'foo', 'baz'))\nFalse\n&gt;&gt;&gt; (zc.relation.catalog.any('foo', 'bar', 'baz') ==\n...  zc.relation.catalog.any('foo', 'baz'))\nFalse\n&gt;&gt;&gt; (zc.relation.catalog.any('foo', 'bar', 'baz') !=\n...  zc.relation.catalog.any('foo', 'baz'))\nTrue\n</pre>\n</td></tr>\n</tbody>\n</table>\n</div>\n<div id=\"findvalues-and-the-relation-query-key\">\n<h4><a href=\"#id38\" rel=\"nofollow\"><tt>findValues</tt> and the <tt>RELATION</tt> query key</a></h4>\n<p>So how do we find who an employee\u2019s supervisor is?  Well, in this case,\nlook at the attribute on the employee!  If you can use an attribute that\nwill usually be a win in the ZODB.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; h.supervisor\n&lt;Employee instance \"Diane\"&gt;\n</pre>\n</blockquote>\n<p>Again, as we mentioned at the start of this first example, the knowledge\nof a supervisor is \u201cintrinsic\u201d to the employee instance.  It is\npossible, and even easy, to ask the catalog this kind of question, but\nthe catalog syntax is more geared to \u201cextrinsic\u201d relations, such as the\none from the supervisor to the employee: the connection between a\nsupervisor object and its employees is extrinsic to the supervisor, so\nyou actually might want a catalog to find it!</p>\n<p>However, we will explore the syntax very briefly, because it introduces an\nimportant pair of search methods, and because it is a stepping stone\nto our first transitive search.</p>\n<p>So, o relation catalog, who is Howie\u2019s supervisor?</p>\n<p>To ask this question we want to get the indexed values off of the relations:\n<tt>findValues</tt>. In its simplest form, the arguments are the index name of the\nvalues you want, and a query to find the relations that have the desired\nvalues.</p>\n<p>What about the query? Above, we noted that the keys in a query are the names of\nthe indexes to search. However, in this case, we don\u2019t want to search one or\nmore indexes for matching relations, as usual, but actually specify a relation:\nHowie.</p>\n<p>We do not have a value index name: we are looking for a relation. The query\nkey, then, should be the constant <tt>zc.relation.RELATION</tt>. For our current\nexample, that would mean the query is <tt>{zc.relation.RELATION: 'Howie'}</tt>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation\n&gt;&gt;&gt; list(catalog.findValues(\n...     'supervisor', {zc.relation.RELATION: 'Howie'}))[0]\n&lt;Employee instance \"Diane\"&gt;\n</pre>\n</blockquote>\n<p>Congratulations, you just found an obfuscated and comparitively\ninefficient way to write <tt>howie.supervisor</tt>! <a href=\"#intrinsic-search\" id=\"id5\" rel=\"nofollow\">[5]</a></p>\n<table id=\"intrinsic-search\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id5\" rel=\"nofollow\">[5]</a></td><td><p>Here\u2019s the same with token results.</p>\n<pre>\n&gt;&gt;&gt; list(catalog.findValueTokens('supervisor',\n...                              {zc.relation.RELATION: 'Howie'}))\n['Diane']\n</pre>\n<p>While we\u2019re down here in the footnotes, I\u2019ll mention that you can\nsearch for relations that haven\u2019t been indexed.</p>\n<pre>\n&gt;&gt;&gt; list(catalog.findRelationTokens({zc.relation.RELATION: 'Ygritte'}))\n[]\n&gt;&gt;&gt; list(catalog.findRelations({zc.relation.RELATION: 'Ygritte'}))\n[]\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p><a href=\"#findvaluesexceptions\" id=\"id6\" rel=\"nofollow\">[6]</a></p>\n<table id=\"findvaluesexceptions\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id6\" rel=\"nofollow\">[6]</a></td><td><p>If you use <tt>findValues</tt> or <tt>findValueTokens</tt> and\ntry to specify a value name that is not indexed, you get a ValueError.</p>\n<pre>\n&gt;&gt;&gt; catalog.findValues('foo')\nTraceback (most recent call last):\n...\nValueError: ('name not indexed', 'foo')\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>Slightly more usefully, you can use other query keys along with\nzc.relation.RELATION. This asks, \u201cOf Betty, Alice, and Frank, who are\nsupervised by Alice?\u201d</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelations(\n...     {zc.relation.RELATION: zc.relation.catalog.any(\n...         'Betty', 'Alice', 'Frank'),\n...      'supervisor': 'Alice'}))\n[&lt;Employee instance \"Betty\"&gt;]\n</pre>\n</blockquote>\n<p>Only Betty is.</p>\n</div>\n<div id=\"tokens\">\n<h4><a href=\"#id39\" rel=\"nofollow\">Tokens</a></h4>\n<p>As mentioned above, the catalog provides several helpers to work with tokens.\nThe most frequently used is <tt>tokenizeQuery</tt>, which takes a query with object\nvalues and converts them to tokens using the \u201cdump\u201d functions registered for\nthe relations and indexed values. Here are alternate spellings of some of the\nqueries we\u2019ve encountered above.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.tokenizeQuery({'supervisor': a})\n{'supervisor': 'Alice'}\n&gt;&gt;&gt; catalog.tokenizeQuery({'supervisor': None})\n{'supervisor': None}\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; result = catalog.tokenizeQuery(\n...     {zc.relation.RELATION: zc.relation.catalog.any(a, b, f),\n...     'supervisor': a}) # doctest: +NORMALIZE_WHITESPACE\n&gt;&gt;&gt; pprint.pprint(result)\n{None: &lt;zc.relation.catalog.Any instance ('Alice', 'Betty', 'Frank')&gt;,\n 'supervisor': 'Alice'}\n</pre>\n</blockquote>\n<p>(If you are wondering about that <tt>None</tt> in the last result, yes,\n<tt>zc.relation.RELATION</tt> is just readability sugar for <tt>None</tt>.)</p>\n<p>So, here\u2019s a real search using <tt>tokenizeQuery</tt>.  We\u2019ll make an alias for\n<tt>catalog.tokenizeQuery</tt> just to shorten things up a bit.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; query = catalog.tokenizeQuery\n&gt;&gt;&gt; sorted(catalog.findRelations(query(\n...     {zc.relation.RELATION: zc.relation.catalog.any(a, b, f),\n...      'supervisor': a})))\n[&lt;Employee instance \"Betty\"&gt;]\n</pre>\n</blockquote>\n<p>The catalog always has parallel search methods, one for finding objects, as\nseen above, and one for finding tokens (the only exception is <tt>canFind</tt>,\ndescribed below). Finding tokens can be much more efficient, especially if the\nresult from the relation catalog is just one step along the path of finding\nyour desired result. But finding objects is simpler for some common cases.\nHere\u2019s a quick example of some queries above, getting tokens rather than\nobjects.</p>\n<p>You can also spell a query in <tt>tokenizeQuery</tt> with keyword arguments. This\nwon\u2019t work if your key is <tt>zc.relation.RELATION</tt>, but otherwise it can\nimprove readability. We\u2019ll see some examples of this below as well.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelationTokens(query(supervisor=a)))\n['Betty', 'Chuck']\n</pre>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelationTokens({'supervisor': None}))\n['Alice']\n</pre>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelationTokens(\n...     query(supervisor=zc.relation.catalog.any(c, d))))\n['Frank', 'Galyn', 'Howie']\n</pre>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelationTokens(\n...     query({zc.relation.RELATION: zc.relation.catalog.any(a, b, f),\n...            'supervisor': a})))\n['Betty']\n</pre>\n</blockquote>\n<p>The catalog provides several other methods just for working with tokens.</p>\n<ul>\n<li><tt>resolveQuery</tt>: the inverse of <tt>tokenizeQuery</tt>, converting a\ntokenizedquery to a query with objects.</li>\n<li><tt>tokenizeValues</tt>: returns an iterable of tokens for the values of the given\nindex name.</li>\n<li><tt>resolveValueTokens</tt>: returns an iterable of values for the tokens of the\ngiven index name.</li>\n<li><tt>tokenizeRelation</tt>: returns a token for the given relation.</li>\n<li><tt>resolveRelationToken</tt>: returns a relation for the given token.</li>\n<li><tt>tokenizeRelations</tt>: returns an iterable of tokens for the relations given.</li>\n<li><tt>resolveRelationTokens</tt>: returns an iterable of relations for the tokens\ngiven.</li>\n</ul>\n<p>These methods are lesser used, and described in more technical documents in\nthis package.</p>\n</div>\n<div id=\"transitive-searching-query-factories-and-maxdepth\">\n<h4><a href=\"#id40\" rel=\"nofollow\">Transitive Searching, Query Factories, and <tt>maxDepth</tt></a></h4>\n<p>So, we\u2019ve seen a lot of one-level, intransitive searching. What about\ntransitive searching? Well, you need to tell the catalog how to walk the tree.\nIn simple (and very common) cases like this, the\n<tt>zc.relation.queryfactory.TransposingTransitive</tt> will do the trick.</p>\n<p>A transitive query factory is just a callable that the catalog uses to\nask \u201cI got this query, and here are the results I found. I\u2019m supposed to\nwalk another step transitively, so what query should I search for next?\u201d\nWriting a factory is more complex than we want to talk about right now,\nbut using the <tt>TransposingTransitiveQueryFactory</tt> is easy. You just tell\nit the two query names it should transpose for walking in either\ndirection.</p>\n<p>For instance, here we just want to tell the factory to transpose the two keys\nwe\u2019ve used, <tt>zc.relation.RELATION</tt> and \u2018supervisor\u2019. Let\u2019s make a factory,\nuse it in a query for a couple of transitive searches, and then, if you want,\nyou can read through a footnote to talk through what is happening.</p>\n<p>Here\u2019s the factory.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation.queryfactory\n&gt;&gt;&gt; factory = zc.relation.queryfactory.TransposingTransitive(\n...     zc.relation.RELATION, 'supervisor')\n</pre>\n</blockquote>\n<p>Now <tt>factory</tt> is just a callable.  Let\u2019s let it help answer a couple of\nquestions.</p>\n<p>Who are all of Howie\u2019s supervisors transitively (this looks up in the\ndiagram)?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findValues('supervisor', {zc.relation.RELATION: 'Howie'},\n...      queryFactory=factory))\n... # doctest: +NORMALIZE_WHITESPACE\n[&lt;Employee instance \"Diane\"&gt;, &lt;Employee instance \"Betty\"&gt;,\n &lt;Employee instance \"Alice\"&gt;]\n</pre>\n</blockquote>\n<p>Who are all of the people Betty supervises transitively, breadth first (this\nlooks down in the diagram)?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; people = list(catalog.findRelations(\n...     {'supervisor': 'Betty'}, queryFactory=factory))\n&gt;&gt;&gt; sorted(people[:2])\n[&lt;Employee instance \"Diane\"&gt;, &lt;Employee instance \"Edgar\"&gt;]\n&gt;&gt;&gt; people[2]\n&lt;Employee instance \"Howie\"&gt;\n</pre>\n</blockquote>\n<p>Yup, that looks right.  So how did that work?  If you care, read this\nfootnote. <a href=\"#i-care\" id=\"id7\" rel=\"nofollow\">[13]</a></p>\n<p>This transitive factory is really the only transitive factory you would\nwant for this particular catalog, so it probably is safe to wire it in\nas a default.  You can add multiple query factories to match different\nqueries using <tt>addDefaultQueryFactory</tt>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.addDefaultQueryFactory(factory)\n</pre>\n</blockquote>\n<p>Now all searches are transitive by default.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findValues('supervisor', {zc.relation.RELATION: 'Howie'}))\n... # doctest: +NORMALIZE_WHITESPACE\n[&lt;Employee instance \"Diane\"&gt;, &lt;Employee instance \"Betty\"&gt;,\n &lt;Employee instance \"Alice\"&gt;]\n&gt;&gt;&gt; people = list(catalog.findRelations({'supervisor': 'Betty'}))\n&gt;&gt;&gt; sorted(people[:2])\n[&lt;Employee instance \"Diane\"&gt;, &lt;Employee instance \"Edgar\"&gt;]\n&gt;&gt;&gt; people[2]\n&lt;Employee instance \"Howie\"&gt;\n</pre>\n</blockquote>\n<p>We can force a non-transitive search, or a specific search depth, with\n<tt>maxDepth</tt> <a href=\"#needs-a-transitive-queries-factory\" id=\"id8\" rel=\"nofollow\">[7]</a>.</p>\n<table id=\"needs-a-transitive-queries-factory\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id8\" rel=\"nofollow\">[7]</a></td><td><p>A search with a <tt>maxDepth</tt> &gt; 1 but\nno <tt>queryFactory</tt> raises an error.</p>\n<pre>\n&gt;&gt;&gt; catalog.removeDefaultQueryFactory(factory)\n&gt;&gt;&gt; catalog.findRelationTokens({'supervisor': 'Diane'}, maxDepth=3)\nTraceback (most recent call last):\n...\nValueError: if maxDepth not in (None, 1), queryFactory must be available\n</pre>\n<pre>\n&gt;&gt;&gt; catalog.addDefaultQueryFactory(factory)\n</pre>\n<pre>\n&gt;&gt;&gt; list(catalog.findValues(\n...     'supervisor', {zc.relation.RELATION: 'Howie'}, maxDepth=1))\n[&lt;Employee instance \"Diane\"&gt;]\n&gt;&gt;&gt; sorted(catalog.findRelations({'supervisor': 'Betty'}, maxDepth=1))\n[&lt;Employee instance \"Diane\"&gt;, &lt;Employee instance \"Edgar\"&gt;]\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p><a href=\"#maxdepthexceptions\" id=\"id9\" rel=\"nofollow\">[8]</a></p>\n<table id=\"maxdepthexceptions\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id9\" rel=\"nofollow\">[8]</a></td><td><p><tt>maxDepth</tt> must be None or a positive integer, or\nelse you\u2019ll get a value error.</p>\n<pre>\n&gt;&gt;&gt; catalog.findRelations({'supervisor': 'Betty'}, maxDepth=0)\nTraceback (most recent call last):\n...\nValueError: maxDepth must be None or a positive integer\n</pre>\n<pre>\n&gt;&gt;&gt; catalog.findRelations({'supervisor': 'Betty'}, maxDepth=-1)\nTraceback (most recent call last):\n...\nValueError: maxDepth must be None or a positive integer\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>We\u2019ll introduce some other available search\narguments later in this document and in other documents.  It\u2019s important\nto note that <em>all search methods share the same arguments as\n``findRelations``</em>.  <tt>findValues</tt> and <tt>findValueTokens</tt> only add the\ninitial argument of specifying the desired value.</p>\n<p>We\u2019ve looked at two search methods so far: the <tt>findValues</tt> and\n<tt>findRelations</tt> methods help you ask what is related.  But what if you\nwant to know <em>how</em> things are transitively related?</p>\n</div>\n<div id=\"findrelationchains-and-targetquery\">\n<h4><a href=\"#id41\" rel=\"nofollow\"><tt>findRelationChains</tt> and <tt>targetQuery</tt></a></h4>\n<p>Another search method, <tt>findRelationChains</tt>, helps you discover how\nthings are transitively related.</p>\n<p>The method name says \u201cfind relation chains\u201d.  But what is a \u201crelation\nchain\u201d?  In this API, it is a transitive path of relations.  For\ninstance, what\u2019s the chain of command above Howie?  <tt>findRelationChains</tt>\nwill return each unique path.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findRelationChains({zc.relation.RELATION: 'Howie'}))\n... # doctest: +NORMALIZE_WHITESPACE\n[(&lt;Employee instance \"Howie\"&gt;,),\n (&lt;Employee instance \"Howie\"&gt;, &lt;Employee instance \"Diane\"&gt;),\n (&lt;Employee instance \"Howie\"&gt;, &lt;Employee instance \"Diane\"&gt;,\n  &lt;Employee instance \"Betty\"&gt;),\n (&lt;Employee instance \"Howie\"&gt;, &lt;Employee instance \"Diane\"&gt;,\n &lt;Employee instance \"Betty\"&gt;, &lt;Employee instance \"Alice\"&gt;)]\n</pre>\n</blockquote>\n<p>Look at that result carefully.  Notice that the result is an iterable of\ntuples.  Each tuple is a unique chain, which may be a part of a\nsubsequent chain.  In this case, the last chain is the longest and the\nmost comprehensive.</p>\n<p>What if we wanted to see all the paths from Alice?  That will be one\nchain for each supervised employee, because it shows all possible paths.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelationChains(\n...     {'supervisor': 'Alice'}))\n... # doctest: +NORMALIZE_WHITESPACE\n[(&lt;Employee instance \"Betty\"&gt;,),\n (&lt;Employee instance \"Betty\"&gt;, &lt;Employee instance \"Diane\"&gt;),\n (&lt;Employee instance \"Betty\"&gt;, &lt;Employee instance \"Diane\"&gt;,\n  &lt;Employee instance \"Howie\"&gt;),\n (&lt;Employee instance \"Betty\"&gt;, &lt;Employee instance \"Edgar\"&gt;),\n (&lt;Employee instance \"Chuck\"&gt;,),\n (&lt;Employee instance \"Chuck\"&gt;, &lt;Employee instance \"Frank\"&gt;),\n (&lt;Employee instance \"Chuck\"&gt;, &lt;Employee instance \"Galyn\"&gt;)]\n</pre>\n</blockquote>\n<p>That\u2019s all the paths\u2013all the chains\u2013from Alice.  We sorted the results,\nbut normally they would be breadth first.</p>\n<p>But what if we wanted to just find the paths from one query result to\nanother query result\u2013say, we wanted to know the chain of command from Alice\ndown to Howie?  Then we can specify a <tt>targetQuery</tt> that specifies the\ncharacteristics of our desired end point (or points).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findRelationChains(\n...     {'supervisor': 'Alice'},\n...     targetQuery={zc.relation.RELATION: 'Howie'}))\n... # doctest: +NORMALIZE_WHITESPACE\n[(&lt;Employee instance \"Betty\"&gt;, &lt;Employee instance \"Diane\"&gt;,\n  &lt;Employee instance \"Howie\"&gt;)]\n</pre>\n</blockquote>\n<p>So, Betty supervises Diane, who supervises Howie.</p>\n<p>Note that <tt>targetQuery</tt> now joins <tt>maxDepth</tt> in our collection of shared\nsearch arguments that we have introduced.</p>\n</div>\n<div id=\"filter-and-targetfilter\">\n<h4><a href=\"#id42\" rel=\"nofollow\"><tt>filter</tt> and <tt>targetFilter</tt></a></h4>\n<p>We can take a quick look now at the last of the two shared search arguments:\n<tt>filter</tt> and <tt>targetFilter</tt>.  These two are similar in that they both are\ncallables that can approve or reject given relations in a search based on\nwhatever logic you can code.  They differ in that <tt>filter</tt> stops any further\ntransitive searches from the relation, while <tt>targetFilter</tt> merely omits the\ngiven result but allows further search from it.  Like <tt>targetQuery</tt>, then,\n<tt>targetFilter</tt> is good when you want to specify the other end of a path.</p>\n<p>As an example, let\u2019s say we only want to return female employees.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; female_employees = ('Alice', 'Betty', 'Diane', 'Galyn')\n&gt;&gt;&gt; def female_filter(relchain, query, catalog, cache):\n...     return relchain[-1] in female_employees\n...\n</pre>\n</blockquote>\n<p>Here are all the female employees supervised by Alice transitively, using\n<tt>targetFilter</tt>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findRelations({'supervisor': 'Alice'},\n...                            targetFilter=female_filter))\n... # doctest: +NORMALIZE_WHITESPACE\n[&lt;Employee instance \"Betty\"&gt;, &lt;Employee instance \"Diane\"&gt;,\n &lt;Employee instance \"Galyn\"&gt;]\n</pre>\n</blockquote>\n<p>Here are all the female employees supervised by Chuck.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findRelations({'supervisor': 'Chuck'},\n...                            targetFilter=female_filter))\n[&lt;Employee instance \"Galyn\"&gt;]\n</pre>\n</blockquote>\n<p>The same method used as a filter will only return females directly\nsupervised by other females\u2013not Galyn, in this case.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findRelations({'supervisor': 'Alice'},\n...                            filter=female_filter))\n[&lt;Employee instance \"Betty\"&gt;, &lt;Employee instance \"Diane\"&gt;]\n</pre>\n</blockquote>\n<p>These can be combined with one another, and with the other search\narguments <a href=\"#filter\" id=\"id10\" rel=\"nofollow\">[9]</a>.</p>\n<table id=\"filter\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id10\" rel=\"nofollow\">[9]</a></td><td><p>For instance:</p>\n<pre>\n&gt;&gt;&gt; list(catalog.findRelationTokens(\n...     {'supervisor': 'Alice'}, targetFilter=female_filter,\n...     targetQuery={zc.relation.RELATION: 'Galyn'}))\n['Galyn']\n&gt;&gt;&gt; list(catalog.findRelationTokens(\n...     {'supervisor': 'Alice'}, targetFilter=female_filter,\n...     targetQuery={zc.relation.RELATION: 'Not known'}))\n[]\n&gt;&gt;&gt; arbitrary = ['Alice', 'Chuck', 'Betty', 'Galyn']\n&gt;&gt;&gt; def arbitrary_filter(relchain, query, catalog, cache):\n...     return relchain[-1] in arbitrary\n&gt;&gt;&gt; list(catalog.findRelationTokens({'supervisor': 'Alice'},\n...                                 filter=arbitrary_filter,\n...                                 targetFilter=female_filter))\n['Betty', 'Galyn']\n</pre>\n</td></tr>\n</tbody>\n</table>\n</div>\n<div id=\"search-indexes\">\n<h4><a href=\"#id43\" rel=\"nofollow\">Search indexes</a></h4>\n<p>Without setting up any additional indexes, the transitive behavior of\nthe <tt>findRelations</tt> and <tt>findValues</tt> methods essentially relies on the\nbrute force searches of <tt>findRelationChains</tt>.  Results are iterables\nthat are gradually computed.  For instance, let\u2019s repeat the question\n\u201cWhom does Betty supervise?\u201d.  Notice that <tt>res</tt> first populates a list\nwith three members, but then does not populate a second list.  The\niterator has been exhausted.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = catalog.findRelationTokens({'supervisor': 'Betty'})\n&gt;&gt;&gt; unindexed = sorted(res)\n&gt;&gt;&gt; len(unindexed)\n3\n&gt;&gt;&gt; len(list(res)) # iterator is exhausted\n0\n</pre>\n</blockquote>\n<p>The brute force of this approach can be sufficient in many cases, but\nsometimes speed for these searches is critical.  In these cases, you can\nadd a \u201csearch index\u201d.  A search index speeds up the result of one or\nmore precise searches by indexing the results.  Search indexes can\naffect the results of searches with a <tt>queryFactory</tt> in <tt>findRelations</tt>,\n<tt>findValues</tt>, and the soon-to-be-introduced <tt>canFind</tt>, but they do not\naffect <tt>findRelationChains</tt>.</p>\n<p>The zc.relation package currently includes two kinds of search indexes, one for\nindexing transitive membership searches in a hierarchy and one for intransitive\nsearches explored in tokens.rst in this package, which can optimize frequent\nsearches on complex queries or can effectively change the meaning of an\nintransitive search. Other search index implementations and approaches may be\nadded in the future.</p>\n<p>Here\u2019s a very brief example of adding a search index for the transitive\nsearches seen above that specify a \u2018supervisor\u2019.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation.searchindex\n&gt;&gt;&gt; catalog.addSearchIndex(\n...     zc.relation.searchindex.TransposingTransitiveMembership(\n...         'supervisor', zc.relation.RELATION))\n</pre>\n</blockquote>\n<p>The <tt>zc.relation.RELATION</tt> describes how to walk back up the chain. Search\nindexes are explained in reasonable detail in searchindex.rst.</p>\n<p>Now that we have added the index, we can search again.  The result this\ntime is already computed, so, at least when you ask for tokens, it\nis repeatable.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = catalog.findRelationTokens({'supervisor': 'Betty'})\n&gt;&gt;&gt; len(list(res))\n3\n&gt;&gt;&gt; len(list(res))\n3\n&gt;&gt;&gt; sorted(res) == unindexed\nTrue\n</pre>\n</blockquote>\n<p>Note that the breadth-first sorting is lost when an index is used <a href=\"#updates\" id=\"id11\" rel=\"nofollow\">[10]</a>.</p>\n<table id=\"updates\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id11\" rel=\"nofollow\">[10]</a></td><td><p>The scenario we are looking at in this document shows a case\nin which special logic in the search index needs to address updates.\nFor example, if we move Howie from Diane</p>\n<pre>\n            Alice\n         __/     \\__\n    Betty           Chuck\n    /   \\           /   \\\nDiane   Edgar   Frank   Galyn\n  |\nHowie\n</pre>\n<p>to Galyn</p>\n<pre>\n            Alice\n         __/     \\__\n    Betty           Chuck\n    /   \\           /   \\\nDiane   Edgar   Frank   Galyn\n                          |\n                        Howie\n</pre>\n<p>then the search index is correct both for the new location and the old.</p>\n<pre>\n&gt;&gt;&gt; h.supervisor = g\n&gt;&gt;&gt; catalog.index(h)\n&gt;&gt;&gt; list(catalog.findRelationTokens({'supervisor': 'Diane'}))\n[]\n&gt;&gt;&gt; list(catalog.findRelationTokens({'supervisor': 'Betty'}))\n['Diane', 'Edgar']\n&gt;&gt;&gt; list(catalog.findRelationTokens({'supervisor': 'Chuck'}))\n['Frank', 'Galyn', 'Howie']\n&gt;&gt;&gt; list(catalog.findRelationTokens({'supervisor': 'Galyn'}))\n['Howie']\n&gt;&gt;&gt; h.supervisor = d\n&gt;&gt;&gt; catalog.index(h) # move him back\n&gt;&gt;&gt; list(catalog.findRelationTokens({'supervisor': 'Galyn'}))\n[]\n&gt;&gt;&gt; list(catalog.findRelationTokens({'supervisor': 'Diane'}))\n['Howie']\n</pre>\n</td></tr>\n</tbody>\n</table>\n</div>\n<div id=\"transitive-cycles-and-updating-and-removing-relations\">\n<h4><a href=\"#id44\" rel=\"nofollow\">Transitive cycles (and updating and removing relations)</a></h4>\n<p>The transitive searches and the provided search indexes can handle\ncycles.  Cycles are less likely in the current example than some others,\nbut we can stretch the case a bit: imagine a \u201cking in disguise\u201d, in\nwhich someone at the top works lower in the hierarchy.  Perhaps Alice\nworks for Zane, who works for Betty, who works for Alice.  Artificial,\nbut easy enough to draw:</p>\n<pre>      ______\n     /      \\\n    /     Zane\n   /        |\n  /       Alice\n /     __/     \\__\n/ Betty__         Chuck\n\\-/  /   \\         /   \\\n   Diane Edgar Frank   Galyn\n    |\n  Howie\n</pre>\n<p>Easy to create too.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; z = Employee('Zane', b)\n&gt;&gt;&gt; a.supervisor = z\n</pre>\n</blockquote>\n<p>Now we have a cycle.  Of course, we have not yet told the catalog about it.\n<tt>index</tt> can be used both to reindex Alice and index Zane.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.index(a)\n&gt;&gt;&gt; catalog.index(z)\n</pre>\n</blockquote>\n<p>Now, if we ask who works for Betty, we get the entire tree.  (We\u2019ll ask\nfor tokens, just so that the result is smaller to look at.) <a href=\"#same-set\" id=\"id12\" rel=\"nofollow\">[11]</a></p>\n<table id=\"same-set\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id12\" rel=\"nofollow\">[11]</a></td><td><p>The result of the query for Betty, Alice, and Zane are all the\nsame.</p>\n<pre>\n&gt;&gt;&gt; res1 = catalog.findRelationTokens({'supervisor': 'Betty'})\n&gt;&gt;&gt; res2 = catalog.findRelationTokens({'supervisor': 'Alice'})\n&gt;&gt;&gt; res3 = catalog.findRelationTokens({'supervisor': 'Zane'})\n&gt;&gt;&gt; list(res1) == list(res2) == list(res3)\nTrue\n</pre>\n<p>The cycle doesn\u2019t pollute the index outside of the cycle.</p>\n<pre>\n&gt;&gt;&gt; res = catalog.findRelationTokens({'supervisor': 'Diane'})\n&gt;&gt;&gt; list(res)\n['Howie']\n&gt;&gt;&gt; list(res) # it isn't lazy, it is precalculated\n['Howie']\n</pre>\n<pre>\n&gt;&gt;&gt; sorted(catalog.findRelationTokens({'supervisor': 'Betty'}))\n... # doctest: +NORMALIZE_WHITESPACE\n['Alice', 'Betty', 'Chuck', 'Diane', 'Edgar', 'Frank', 'Galyn', 'Howie',\n 'Zane']\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>If we ask for the supervisors of Frank, it will include Betty.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findValueTokens(\n...     'supervisor', {zc.relation.RELATION: 'Frank'}))\n['Chuck', 'Alice', 'Zane', 'Betty']\n</pre>\n</blockquote>\n<p>Paths returned by <tt>findRelationChains</tt> are marked with special interfaces,\nand special metadata, to show the chain.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = list(catalog.findRelationChains({zc.relation.RELATION: 'Frank'}))\n&gt;&gt;&gt; len(res)\n5\n&gt;&gt;&gt; import zc.relation.interfaces\n&gt;&gt;&gt; [zc.relation.interfaces.ICircularRelationPath.providedBy(r)\n...  for r in res]\n[False, False, False, False, True]\n</pre>\n</blockquote>\n<p>Here\u2019s the last chain:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res[-1] # doctest: +NORMALIZE_WHITESPACE\ncycle(&lt;Employee instance \"Frank\"&gt;, &lt;Employee instance \"Chuck\"&gt;,\n      &lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Zane\"&gt;,\n      &lt;Employee instance \"Betty\"&gt;)\n</pre>\n</blockquote>\n<p>The chain\u2019s \u2018cycled\u2019 attribute has a list of queries that create a cycle.\nIf you run the query, or queries, you see where the cycle would\nrestart\u2013where the path would have started to overlap.  Sometimes the query\nresults will include multiple cycles, and some paths that are not cycles.\nIn this case, there\u2019s only a single cycled query, which results in a single\ncycled relation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(res[4].cycled)\n1\n</pre>\n<pre>&gt;&gt;&gt; list(catalog.findRelations(res[4].cycled[0], maxDepth=1))\n[&lt;Employee instance \"Alice\"&gt;]\n</pre>\n</blockquote>\n<p>To remove this craziness <a href=\"#reverse-lookup\" id=\"id13\" rel=\"nofollow\">[12]</a>, we can unindex Zane, and change\nand reindex Alice.</p>\n<table id=\"reverse-lookup\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id13\" rel=\"nofollow\">[12]</a></td><td><p>If you want to, look what happens when you go the\nother way:</p>\n<pre>\n&gt;&gt;&gt; res = list(catalog.findRelationChains({'supervisor': 'Zane'}))\n&gt;&gt;&gt; def sortEqualLenByName(one):\n...     return len(one), one\n...\n&gt;&gt;&gt; res.sort(key=sortEqualLenByName)  # normalizes for test stability\n&gt;&gt;&gt; from __future__ import print_function\n&gt;&gt;&gt; print(res) # doctest: +NORMALIZE_WHITESPACE\n[(&lt;Employee instance \"Alice\"&gt;,),\n (&lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Betty\"&gt;),\n (&lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Chuck\"&gt;),\n (&lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Betty\"&gt;,\n  &lt;Employee instance \"Diane\"&gt;),\n (&lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Betty\"&gt;,\n  &lt;Employee instance \"Edgar\"&gt;),\n cycle(&lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Betty\"&gt;,\n       &lt;Employee instance \"Zane\"&gt;),\n (&lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Chuck\"&gt;,\n  &lt;Employee instance \"Frank\"&gt;),\n (&lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Chuck\"&gt;,\n  &lt;Employee instance \"Galyn\"&gt;),\n (&lt;Employee instance \"Alice\"&gt;, &lt;Employee instance \"Betty\"&gt;,\n  &lt;Employee instance \"Diane\"&gt;, &lt;Employee instance \"Howie\"&gt;)]\n</pre>\n<pre>\n&gt;&gt;&gt; [zc.relation.interfaces.ICircularRelationPath.providedBy(r)\n...  for r in res]\n[False, False, False, False, False, True, False, False, False]\n&gt;&gt;&gt; len(res[5].cycled)\n1\n&gt;&gt;&gt; list(catalog.findRelations(res[5].cycled[0], maxDepth=1))\n[&lt;Employee instance \"Alice\"&gt;]\n</pre>\n<pre>\n&gt;&gt;&gt; a.supervisor = None\n&gt;&gt;&gt; catalog.index(a)\n</pre>\n<pre>\n&gt;&gt;&gt; list(catalog.findValueTokens(\n...     'supervisor', {zc.relation.RELATION: 'Frank'}))\n['Chuck', 'Alice']\n</pre>\n<pre>\n&gt;&gt;&gt; catalog.unindex(z)\n</pre>\n<pre>\n&gt;&gt;&gt; sorted(catalog.findRelationTokens({'supervisor': 'Betty'}))\n['Diane', 'Edgar', 'Howie']\n</pre>\n</td></tr>\n</tbody>\n</table>\n</div>\n<div id=\"canfind\">\n<h4><a href=\"#id45\" rel=\"nofollow\"><tt>canFind</tt></a></h4>\n<p>We\u2019re to the last search method: <tt>canFind</tt>.  We\u2019ve gotten values and\nrelations, but what if you simply want to know if there is any\nconnection at all?  For instance, is Alice a supervisor of Howie? Is\nChuck?  To answer these questions, you can use the <tt>canFind</tt> method\ncombined with the <tt>targetQuery</tt> search argument.</p>\n<p>The <tt>canFind</tt> method takes the same arguments as findRelations.  However,\nit simply returns a boolean about whether the search has any results.  This\nis a convenience that also allows some extra optimizations.</p>\n<p>Does Betty supervise anyone?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.canFind({'supervisor': 'Betty'})\nTrue\n</pre>\n</blockquote>\n<p>What about Howie?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.canFind({'supervisor': 'Howie'})\nFalse\n</pre>\n</blockquote>\n<p>What about\u2026Zane (no longer an employee)?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.canFind({'supervisor': 'Zane'})\nFalse\n</pre>\n</blockquote>\n<p>If we want to know if Alice or Chuck supervise Howie, then we want to specify\ncharacteristics of two points on a path.  To ask a question about the other\nend of a path, use <tt>targetQuery</tt>.</p>\n<p>Is Alice a supervisor of Howie?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.canFind({'supervisor': 'Alice'},\n...                 targetQuery={zc.relation.RELATION: 'Howie'})\nTrue\n</pre>\n</blockquote>\n<p>Is Chuck a supervisor of Howie?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.canFind({'supervisor': 'Chuck'},\n...                 targetQuery={zc.relation.RELATION: 'Howie'})\nFalse\n</pre>\n</blockquote>\n<p>Is Howie Alice\u2019s employee?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.canFind({zc.relation.RELATION: 'Howie'},\n...                 targetQuery={'supervisor': 'Alice'})\nTrue\n</pre>\n</blockquote>\n<p>Is Howie Chuck\u2019s employee?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.canFind({zc.relation.RELATION: 'Howie'},\n...                 targetQuery={'supervisor': 'Chuck'})\nFalse\n</pre>\n</blockquote>\n<p>(Note that, if your relations describe a hierarchy, searching up a hierarchy is\nusually more efficient than searching down, so the second pair of questions is\ngenerally preferable to the first in that case.)</p>\n</div>\n</div>\n<div id=\"working-with-more-complex-relations\">\n<h3><a href=\"#id46\" rel=\"nofollow\">Working with More Complex Relations</a></h3>\n<p>So far, our examples have used a simple relation, in which the indexed object\nis one end of the relation, and the indexed value on the object is the other.\nThis example has let us look at all of the basic zc.relation catalog\nfunctionality.</p>\n<p>As mentioned in the introduction, though, the catalog supports, and was\ndesigned for, more complex relations.  This section will quickly examine a\nfew examples of other uses.</p>\n<p>In this section, we will see several examples of ideas mentioned above but not\nyet demonstrated.</p>\n<ul>\n<li>We can use interface attributes (values or callables) to define value\nindexes.</li>\n<li>Using interface attributes will cause an attempt to adapt the relation if it\ndoes not already provide the interface.</li>\n<li>We can use the <tt>multiple</tt> argument when defining a value index to indicate\nthat the indexed value is a collection.</li>\n<li>We can use the <tt>name</tt> argument when defining a value index to specify the\nname to be used in queries, rather than relying on the name of the interface\nattribute or callable.</li>\n<li>The <tt>family</tt> argument in instantiating the catalog lets you change the\ndefault btree family for relations and value indexes from\n<tt>BTrees.family32.IF</tt> to <tt>BTrees.family64.IF</tt>.</li>\n</ul>\n<div id=\"extrinsic-two-way-relations\">\n<h4><a href=\"#id47\" rel=\"nofollow\">Extrinsic Two-Way Relations</a></h4>\n<p>A simple variation of our current story is this: what if the indexed relation\nwere between two other objects\u2013that is, what if the relation were extrinsic to\nboth participants?</p>\n<p>Let\u2019s imagine we have relations that show biological parentage. We\u2019ll want a\n\u201cPerson\u201d and a \u201cParentage\u201d relation. We\u2019ll define an interface for\n<tt>IParentage</tt> so we can see how using an interface to define a value index\nworks.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Person(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __repr__(self):\n...         return '&lt;Person %r&gt;' % (self.name,)\n...\n&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; class IParentage(zope.interface.Interface):\n...     child = zope.interface.Attribute('the child')\n...     parents = zope.interface.Attribute('the parents')\n...\n&gt;&gt;&gt; @zope.interface.implementer(IParentage)\n... class Parentage(object):\n...\n...     def __init__(self, child, parent1, parent2):\n...         self.child = child\n...         self.parents = (parent1, parent2)\n...\n</pre>\n</blockquote>\n<p>Now we\u2019ll define the dumpers and loaders and then the catalog.  Notice that\nwe are relying on a pattern: the dump must be called before the load.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; _people = {}\n&gt;&gt;&gt; _relations = {}\n&gt;&gt;&gt; def dumpPeople(obj, catalog, cache):\n...     if _people.setdefault(obj.name, obj) is not obj:\n...         raise ValueError('we are assuming names are unique')\n...     return obj.name\n...\n&gt;&gt;&gt; def loadPeople(token, catalog, cache):\n...     return _people[token]\n...\n&gt;&gt;&gt; def dumpRelations(obj, catalog, cache):\n...     if _relations.setdefault(id(obj), obj) is not obj:\n...         raise ValueError('huh?')\n...     return id(obj)\n...\n&gt;&gt;&gt; def loadRelations(token, catalog, cache):\n...     return _relations[token]\n...\n&gt;&gt;&gt; catalog = zc.relation.catalog.Catalog(dumpRelations, loadRelations, family=BTrees.family64)\n&gt;&gt;&gt; catalog.addValueIndex(IParentage['child'], dumpPeople, loadPeople,\n...                       btree=BTrees.family32.OO)\n&gt;&gt;&gt; catalog.addValueIndex(IParentage['parents'], dumpPeople, loadPeople,\n...                       btree=BTrees.family32.OO, multiple=True,\n...                       name='parent')\n&gt;&gt;&gt; catalog.addDefaultQueryFactory(\n...     zc.relation.queryfactory.TransposingTransitive(\n...         'child', 'parent'))\n</pre>\n</blockquote>\n<p>Now we have a catalog fully set up.  Let\u2019s add some relations.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a = Person('Alice')\n&gt;&gt;&gt; b = Person('Betty')\n&gt;&gt;&gt; c = Person('Charles')\n&gt;&gt;&gt; d = Person('Donald')\n&gt;&gt;&gt; e = Person('Eugenia')\n&gt;&gt;&gt; f = Person('Fred')\n&gt;&gt;&gt; g = Person('Gertrude')\n&gt;&gt;&gt; h = Person('Harry')\n&gt;&gt;&gt; i = Person('Iphigenia')\n&gt;&gt;&gt; j = Person('Jacob')\n&gt;&gt;&gt; k = Person('Karyn')\n&gt;&gt;&gt; l = Person('Lee')\n</pre>\n<pre>&gt;&gt;&gt; r1 = Parentage(child=j, parent1=k, parent2=l)\n&gt;&gt;&gt; r2 = Parentage(child=g, parent1=i, parent2=j)\n&gt;&gt;&gt; r3 = Parentage(child=f, parent1=g, parent2=h)\n&gt;&gt;&gt; r4 = Parentage(child=e, parent1=g, parent2=h)\n&gt;&gt;&gt; r5 = Parentage(child=b, parent1=e, parent2=d)\n&gt;&gt;&gt; r6 = Parentage(child=a, parent1=e, parent2=c)\n</pre>\n</blockquote>\n<p>Here\u2019s that in one of our hierarchy diagrams.</p>\n<pre>Karyn   Lee\n     \\ /\n    Jacob   Iphigenia\n         \\ /\n        Gertrude    Harry\n                \\  /\n             /-------\\\n         Fred        Eugenia\n           Donald   /     \\    Charles\n                 \\ /       \\  /\n                Betty      Alice\n</pre>\n<p>Now we can index the relations, and ask some questions.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; for r in (r1, r2, r3, r4, r5, r6):\n...     catalog.index(r)\n&gt;&gt;&gt; query = catalog.tokenizeQuery\n&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'parent', query(child=a), maxDepth=1))\n['Charles', 'Eugenia']\n&gt;&gt;&gt; sorted(catalog.findValueTokens('parent', query(child=g)))\n['Iphigenia', 'Jacob', 'Karyn', 'Lee']\n&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'child', query(parent=h), maxDepth=1))\n['Eugenia', 'Fred']\n&gt;&gt;&gt; sorted(catalog.findValueTokens('child', query(parent=h)))\n['Alice', 'Betty', 'Eugenia', 'Fred']\n&gt;&gt;&gt; catalog.canFind(query(parent=h), targetQuery=query(child=d))\nFalse\n&gt;&gt;&gt; catalog.canFind(query(parent=l), targetQuery=query(child=b))\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"multi-way-relations\">\n<h4><a href=\"#id48\" rel=\"nofollow\">Multi-Way Relations</a></h4>\n<p>The previous example quickly showed how to set the catalog up for a completely\nextrinsic two-way relation.  The same pattern can be extended for N-way\nrelations.  For example, consider a four way relation in the form of\nSUBJECTS PREDICATE OBJECTS [in CONTEXT].  For instance, we might\nwant to say \u201c(joe,) SELLS (doughnuts, coffee) in corner_store\u201d, where \u201c(joe,)\u201d\nis the collection of subjects, \u201cSELLS\u201d is the predicate, \u201c(doughnuts, coffee)\u201d\nis the collection of objects, and \u201ccorner_store\u201d is the optional context.</p>\n<p>For this last example, we\u2019ll integrate two components we haven\u2019t seen examples\nof here before: the ZODB and adaptation.</p>\n<p>Our example ZODB approach uses OIDs as the tokens. this might be OK in some\ncases, if you will never support multiple databases and you don\u2019t need an\nabstraction layer so that a different object can have the same identifier.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import persistent\n&gt;&gt;&gt; import struct\n&gt;&gt;&gt; class Demo(persistent.Persistent):\n...     def __init__(self, name):\n...         self.name = name\n...     def __repr__(self):\n...         return '&lt;Demo instance %r&gt;' % (self.name,)\n...\n&gt;&gt;&gt; class IRelation(zope.interface.Interface):\n...     subjects = zope.interface.Attribute('subjects')\n...     predicate = zope.interface.Attribute('predicate')\n...     objects = zope.interface.Attribute('objects')\n...\n&gt;&gt;&gt; class IContextual(zope.interface.Interface):\n...     def getContext():\n...         'return context'\n...     def setContext(value):\n...         'set context'\n...\n&gt;&gt;&gt; @zope.interface.implementer(IContextual)\n... class Contextual(object):\n...\n...     _context = None\n...     def getContext(self):\n...         return self._context\n...     def setContext(self, value):\n...         self._context = value\n...\n&gt;&gt;&gt; @zope.interface.implementer(IRelation)\n... class Relation(persistent.Persistent):\n...\n...     def __init__(self, subjects, predicate, objects):\n...         self.subjects = subjects\n...         self.predicate = predicate\n...         self.objects = objects\n...         self._contextual = Contextual()\n...\n...     def __conform__(self, iface):\n...         if iface is IContextual:\n...             return self._contextual\n...\n</pre>\n</blockquote>\n<p>(When using zope.component, the <tt>__conform__</tt> would normally be unnecessary;\nhowever, this package does not depend on zope.component.)</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def dumpPersistent(obj, catalog, cache):\n...     if obj._p_jar is None:\n...         catalog._p_jar.add(obj) # assumes something else places it\n...     return struct.unpack('&lt;q', obj._p_oid)[0]\n...\n&gt;&gt;&gt; def loadPersistent(token, catalog, cache):\n...     return catalog._p_jar.get(struct.pack('&lt;q', token))\n...\n</pre>\n<pre>&gt;&gt;&gt; from ZODB.tests.util import DB\n&gt;&gt;&gt; db = DB()\n&gt;&gt;&gt; conn = db.open()\n&gt;&gt;&gt; root = conn.root()\n&gt;&gt;&gt; catalog = root['catalog'] = zc.relation.catalog.Catalog(\n...     dumpPersistent, loadPersistent, family=BTrees.family64)\n&gt;&gt;&gt; catalog.addValueIndex(IRelation['subjects'],\n...     dumpPersistent, loadPersistent, multiple=True, name='subject')\n&gt;&gt;&gt; catalog.addValueIndex(IRelation['objects'],\n...     dumpPersistent, loadPersistent, multiple=True, name='object')\n&gt;&gt;&gt; catalog.addValueIndex(IRelation['predicate'], btree=BTrees.family32.OO)\n&gt;&gt;&gt; catalog.addValueIndex(IContextual['getContext'],\n...     dumpPersistent, loadPersistent, name='context')\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>The <tt>dumpPersistent</tt> and <tt>loadPersistent</tt> is a bit of a toy, as warned\nabove. Also, while our predicate will be stored as a string, some programmers\nmay prefer to have a dump in such a case verify that the string has been\nexplicitly registered in some way, to prevent typos. Obviously, we are not\nbothering with this for our example.</p>\n<p>We make some objects, and then we make some relations with those objects and\nindex them.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; joe = root['joe'] = Demo('joe')\n&gt;&gt;&gt; sara = root['sara'] = Demo('sara')\n&gt;&gt;&gt; jack = root['jack'] = Demo('jack')\n&gt;&gt;&gt; ann = root['ann'] = Demo('ann')\n&gt;&gt;&gt; doughnuts = root['doughnuts'] = Demo('doughnuts')\n&gt;&gt;&gt; coffee = root['coffee'] = Demo('coffee')\n&gt;&gt;&gt; muffins = root['muffins'] = Demo('muffins')\n&gt;&gt;&gt; cookies = root['cookies'] = Demo('cookies')\n&gt;&gt;&gt; newspaper = root['newspaper'] = Demo('newspaper')\n&gt;&gt;&gt; corner_store = root['corner_store'] = Demo('corner_store')\n&gt;&gt;&gt; bistro = root['bistro'] = Demo('bistro')\n&gt;&gt;&gt; bakery = root['bakery'] = Demo('bakery')\n</pre>\n<pre>&gt;&gt;&gt; SELLS = 'SELLS'\n&gt;&gt;&gt; BUYS = 'BUYS'\n&gt;&gt;&gt; OBSERVES = 'OBSERVES'\n</pre>\n<pre>&gt;&gt;&gt; rel1 = root['rel1'] = Relation((joe,), SELLS, (doughnuts, coffee))\n&gt;&gt;&gt; IContextual(rel1).setContext(corner_store)\n&gt;&gt;&gt; rel2 = root['rel2'] = Relation((sara, jack), SELLS,\n...                                (muffins, doughnuts, cookies))\n&gt;&gt;&gt; IContextual(rel2).setContext(bakery)\n&gt;&gt;&gt; rel3 = root['rel3'] = Relation((ann,), BUYS, (doughnuts,))\n&gt;&gt;&gt; rel4 = root['rel4'] = Relation((sara,), BUYS, (bistro,))\n</pre>\n<pre>&gt;&gt;&gt; for r in (rel1, rel2, rel3, rel4):\n...     catalog.index(r)\n...\n</pre>\n</blockquote>\n<p>Now we can ask a simple question.  Where do they sell doughnuts?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; query = catalog.tokenizeQuery\n&gt;&gt;&gt; sorted(catalog.findValues(\n...     'context',\n...     (query(predicate=SELLS, object=doughnuts))),\n...     key=lambda ob: ob.name)\n[&lt;Demo instance 'bakery'&gt;, &lt;Demo instance 'corner_store'&gt;]\n</pre>\n</blockquote>\n<p>Hopefully these examples give you further ideas on how you can use this tool.</p>\n</div>\n</div>\n<div id=\"additional-functionality\">\n<h3><a href=\"#id49\" rel=\"nofollow\">Additional Functionality</a></h3>\n<p>This section introduces peripheral functionality.  We will learn the following.</p>\n<ul>\n<li>Listeners can be registered in the catalog.  They are alerted when a relation\nis added, modified, or removed; and when the catalog is cleared and copied\n(see below).</li>\n<li>The <tt>clear</tt> method clears the relations in the catalog.</li>\n<li>The <tt>copy</tt> method makes a copy of the current catalog by copying internal\ndata structures, rather than reindexing the relations, which can be a\nsignificant optimization opportunity.  This copies value indexes and search\nindexes; and gives listeners an opportunity to specify what, if anything,\nshould be included in the new copy.</li>\n<li>The <tt>ignoreSearchIndex</tt> argument to the five pertinent search methods\ncauses the search to ignore search indexes, even if there is an appropriate\none.</li>\n<li><tt>findRelationTokens()</tt> (without arguments) returns the BTree set of all\nrelation tokens in the catalog.</li>\n<li><tt>findValueTokens(INDEX_NAME)</tt> (where \u201cINDEX_NAME\u201d should be replaced with\nan index name) returns the BTree set of all value tokens in the catalog for\nthe given index name.</li>\n</ul>\n<div id=\"listeners\">\n<h4><a href=\"#id50\" rel=\"nofollow\">Listeners</a></h4>\n<p>A variety of potential clients may want to be alerted when the catalog changes.\nzc.relation does not depend on zope.event, so listeners may be registered for\nvarious changes.  Let\u2019s make a quick demo listener.  The <tt>additions</tt> and\n<tt>removals</tt> arguments are dictionaries of {value name: iterable of added or\nremoved value tokens}.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def pchange(d):\n...     pprint.pprint(dict(\n...         (k, v is not None and sorted(set(v)) or v) for k, v in d.items()))\n&gt;&gt;&gt; @zope.interface.implementer(zc.relation.interfaces.IListener)\n... class DemoListener(persistent.Persistent):\n...\n...     def relationAdded(self, token, catalog, additions):\n...         print('a relation (token %r) was added to %r '\n...                'with these values:' % (token, catalog))\n...         pchange(additions)\n...     def relationModified(self, token, catalog, additions, removals):\n...         print('a relation (token %r) in %r was modified '\n...                'with these additions:' % (token, catalog))\n...         pchange(additions)\n...         print('and these removals:')\n...         pchange(removals)\n...     def relationRemoved(self, token, catalog, removals):\n...         print('a relation (token %r) was removed from %r '\n...                'with these values:' % (token, catalog))\n...         pchange(removals)\n...     def sourceCleared(self, catalog):\n...         print('catalog %r had all relations unindexed' % (catalog,))\n...     def sourceAdded(self, catalog):\n...         print('now listening to catalog %r' % (catalog,))\n...     def sourceRemoved(self, catalog):\n...         print('no longer listening to catalog %r' % (catalog,))\n...     def sourceCopied(self, original, copy):\n...         print('catalog %r made a copy %r' % (catalog, copy))\n...         copy.addListener(self)\n...\n</pre>\n</blockquote>\n<p>Listeners can be installed multiple times.</p>\n<p>Listeners can be added as persistent weak references, so that, if they are\ndeleted elsewhere, a ZODB pack will not consider the reference in the catalog\nto be something preventing garbage collection.</p>\n<p>We\u2019ll install one of these demo listeners into our new catalog as a\nnormal reference, the default behavior.  Then we\u2019ll show some example messages\nsent to the demo listener.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; listener = DemoListener()\n&gt;&gt;&gt; catalog.addListener(listener) # doctest: +ELLIPSIS\nnow listening to catalog &lt;zc.relation.catalog.Catalog object at ...&gt;\n&gt;&gt;&gt; rel5 = root['rel5'] = Relation((ann,), OBSERVES, (newspaper,))\n&gt;&gt;&gt; catalog.index(rel5) # doctest: +ELLIPSIS\na relation (token ...) was added to &lt;...Catalog...&gt; with these values:\n{'context': None,\n 'object': [...],\n 'predicate': ['OBSERVES'],\n 'subject': [...]}\n&gt;&gt;&gt; rel5.subjects = (jack,)\n&gt;&gt;&gt; IContextual(rel5).setContext(bistro)\n&gt;&gt;&gt; catalog.index(rel5) # doctest: +ELLIPSIS\na relation (token ...) in ...Catalog... was modified with these additions:\n{'context': [...], 'subject': [...]}\nand these removals:\n{'subject': [...]}\n&gt;&gt;&gt; catalog.unindex(rel5) # doctest: +ELLIPSIS\na relation (token ...) was removed from &lt;...Catalog...&gt; with these values:\n{'context': [...],\n 'object': [...],\n 'predicate': ['OBSERVES'],\n 'subject': [...]}\n</pre>\n<pre>&gt;&gt;&gt; catalog.removeListener(listener) # doctest: +ELLIPSIS\nno longer listening to catalog &lt;...Catalog...&gt;\n&gt;&gt;&gt; catalog.index(rel5) # doctest: +ELLIPSIS\n</pre>\n</blockquote>\n<p>The only two methods not shown by those examples are <tt>sourceCleared</tt> and\n<tt>sourceCopied</tt>.  We\u2019ll get to those very soon below.</p>\n</div>\n<div id=\"the-clear-method\">\n<h4><a href=\"#id51\" rel=\"nofollow\">The <tt>clear</tt> Method</a></h4>\n<p>The <tt>clear</tt> method simply indexes all relations from a catalog.  Installed\nlisteners have <tt>sourceCleared</tt> called.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(catalog)\n5\n</pre>\n<pre>&gt;&gt;&gt; catalog.addListener(listener) # doctest: +ELLIPSIS\nnow listening to catalog &lt;zc.relation.catalog.Catalog object at ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; catalog.clear() # doctest: +ELLIPSIS\ncatalog &lt;...Catalog...&gt; had all relations unindexed\n</pre>\n<pre>&gt;&gt;&gt; len(catalog)\n0\n&gt;&gt;&gt; sorted(catalog.findValues(\n...     'context',\n...     (query(predicate=SELLS, object=doughnuts))),\n...     key=lambda ob: ob.name)\n[]\n</pre>\n</blockquote>\n</div>\n<div id=\"the-copy-method\">\n<h4><a href=\"#id52\" rel=\"nofollow\">The <tt>copy</tt> Method</a></h4>\n<p>Sometimes you may want to copy a relation catalog.  One way of doing this is\nto create a new catalog, set it up like the current one, and then reindex\nall the same relations.  This is unnecessarily slow for programmer and\ncomputer.  The <tt>copy</tt> method makes a new catalog with the same corpus of\nindexed relations by copying internal data structures.</p>\n<p>Search indexes are requested to make new copies of themselves for the new\ncatalog; and listeners are given an opportunity to react as desired to the new\ncopy, including installing themselves, and/or another object of their choosing\nas a listener.</p>\n<p>Let\u2019s make a copy of a populated index with a search index and a listener.\nNotice in our listener that <tt>sourceCopied</tt> adds itself as a listener to the\nnew copy. This is done at the very end of the <tt>copy</tt> process.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; for r in (rel1, rel2, rel3, rel4, rel5):\n...     catalog.index(r)\n... # doctest: +ELLIPSIS\na relation ... was added...\na relation ... was added...\na relation ... was added...\na relation ... was added...\na relation ... was added...\n&gt;&gt;&gt; BEGAT = 'BEGAT'\n&gt;&gt;&gt; rel6 = root['rel6'] = Relation((jack, ann), BEGAT, (sara,))\n&gt;&gt;&gt; henry = root['henry'] = Demo('henry')\n&gt;&gt;&gt; rel7 = root['rel7'] = Relation((sara, joe), BEGAT, (henry,))\n&gt;&gt;&gt; catalog.index(rel6) # doctest: +ELLIPSIS\na relation (token ...) was added to &lt;...Catalog...&gt; with these values:\n{'context': None,\n 'object': [...],\n 'predicate': ['BEGAT'],\n 'subject': [..., ...]}\n&gt;&gt;&gt; catalog.index(rel7) # doctest: +ELLIPSIS\na relation (token ...) was added to &lt;...Catalog...&gt; with these values:\n{'context': None,\n 'object': [...],\n 'predicate': ['BEGAT'],\n 'subject': [..., ...]}\n&gt;&gt;&gt; catalog.addDefaultQueryFactory(\n...     zc.relation.queryfactory.TransposingTransitive(\n...         'subject', 'object', {'predicate': BEGAT}))\n...\n&gt;&gt;&gt; list(catalog.findValues(\n...     'object', query(subject=jack, predicate=BEGAT)))\n[&lt;Demo instance 'sara'&gt;, &lt;Demo instance 'henry'&gt;]\n&gt;&gt;&gt; catalog.addSearchIndex(\n...     zc.relation.searchindex.TransposingTransitiveMembership(\n...         'subject', 'object', static={'predicate': BEGAT}))\n&gt;&gt;&gt; sorted(\n...     catalog.findValues(\n...         'object', query(subject=jack, predicate=BEGAT)),\n...     key=lambda o: o.name)\n[&lt;Demo instance 'henry'&gt;, &lt;Demo instance 'sara'&gt;]\n</pre>\n<pre>&gt;&gt;&gt; newcat = root['newcat'] = catalog.copy() # doctest: +ELLIPSIS\ncatalog &lt;...Catalog...&gt; made a copy &lt;...Catalog...&gt;\nnow listening to catalog &lt;...Catalog...&gt;\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Now the copy has its own copies of internal data structures and of the\nsearchindex.  For example, let\u2019s modify the relations and add a new one to the\ncopy.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; mary = root['mary'] = Demo('mary')\n&gt;&gt;&gt; buffy = root['buffy'] = Demo('buffy')\n&gt;&gt;&gt; zack = root['zack'] = Demo('zack')\n&gt;&gt;&gt; rel7.objects += (mary,)\n&gt;&gt;&gt; rel8 = root['rel8'] = Relation((henry, buffy), BEGAT, (zack,))\n&gt;&gt;&gt; newcat.index(rel7) # doctest: +ELLIPSIS\na relation (token ...) in ...Catalog... was modified with these additions:\n{'object': [...]}\nand these removals:\n{}\n&gt;&gt;&gt; newcat.index(rel8) # doctest: +ELLIPSIS\na relation (token ...) was added to ...Catalog... with these values:\n{'context': None,\n 'object': [...],\n 'predicate': ['BEGAT'],\n 'subject': [..., ...]}\n&gt;&gt;&gt; len(newcat)\n8\n&gt;&gt;&gt; sorted(\n...     newcat.findValues(\n...         'object', query(subject=jack, predicate=BEGAT)),\n...     key=lambda o: o.name) # doctest: +NORMALIZE_WHITESPACE\n[&lt;Demo instance 'henry'&gt;, &lt;Demo instance 'mary'&gt;, &lt;Demo instance 'sara'&gt;,\n &lt;Demo instance 'zack'&gt;]\n&gt;&gt;&gt; sorted(\n...     newcat.findValues(\n...         'object', query(subject=sara)),\n...     key=lambda o: o.name) # doctest: +NORMALIZE_WHITESPACE\n[&lt;Demo instance 'bistro'&gt;, &lt;Demo instance 'cookies'&gt;,\n&lt;Demo instance 'doughnuts'&gt;, &lt;Demo instance 'henry'&gt;,\n&lt;Demo instance 'mary'&gt;, &lt;Demo instance 'muffins'&gt;]\n</pre>\n</blockquote>\n<p>The original catalog is not modified.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(catalog)\n7\n&gt;&gt;&gt; sorted(\n...     catalog.findValues(\n...         'object', query(subject=jack, predicate=BEGAT)),\n...     key=lambda o: o.name)\n[&lt;Demo instance 'henry'&gt;, &lt;Demo instance 'sara'&gt;]\n&gt;&gt;&gt; sorted(\n...     catalog.findValues(\n...         'object', query(subject=sara)),\n...     key=lambda o: o.name) # doctest: +NORMALIZE_WHITESPACE\n[&lt;Demo instance 'bistro'&gt;, &lt;Demo instance 'cookies'&gt;,\n &lt;Demo instance 'doughnuts'&gt;, &lt;Demo instance 'henry'&gt;,\n &lt;Demo instance 'muffins'&gt;]\n</pre>\n</blockquote>\n</div>\n<div id=\"the-ignoresearchindex-argument\">\n<h4><a href=\"#id53\" rel=\"nofollow\">The <tt>ignoreSearchIndex</tt> argument</a></h4>\n<p>The five methods that can use search indexes, <tt>findValues</tt>,\n<tt>findValueTokens</tt>, <tt>findRelations</tt>, <tt>findRelationTokens</tt>, and\n<tt>canFind</tt>, can be explicitly requested to ignore any pertinent search index\nusing the <tt>ignoreSearchIndex</tt> argument.</p>\n<p>We can see this easily with the token-related methods: the search index result\nwill be a BTree set, while without the search index the result will be a\ngenerator.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res1 = newcat.findValueTokens(\n...     'object', query(subject=jack, predicate=BEGAT))\n&gt;&gt;&gt; res1 # doctest: +ELLIPSIS\nLFSet([..., ..., ..., ...])\n&gt;&gt;&gt; res2 = newcat.findValueTokens(\n...     'object', query(subject=jack, predicate=BEGAT),\n...     ignoreSearchIndex=True)\n&gt;&gt;&gt; res2 # doctest: +ELLIPSIS\n&lt;generator object ... at 0x...&gt;\n&gt;&gt;&gt; sorted(res2) == list(res1)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; res1 = newcat.findRelationTokens(\n...     query(subject=jack, predicate=BEGAT))\n&gt;&gt;&gt; res1 # doctest: +ELLIPSIS\nLFSet([..., ..., ...])\n&gt;&gt;&gt; res2 = newcat.findRelationTokens(\n...     query(subject=jack, predicate=BEGAT), ignoreSearchIndex=True)\n&gt;&gt;&gt; res2 # doctest: +ELLIPSIS\n&lt;generator object ... at 0x...&gt;\n&gt;&gt;&gt; sorted(res2) == list(res1)\nTrue\n</pre>\n</blockquote>\n<p>We can see that the other methods take the argument, but the results look the\nsame as usual.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = newcat.findValues(\n...     'object', query(subject=jack, predicate=BEGAT),\n...     ignoreSearchIndex=True)\n&gt;&gt;&gt; res # doctest: +ELLIPSIS\n&lt;generator object ... at 0x...&gt;\n&gt;&gt;&gt; list(res) == list(newcat.resolveValueTokens(newcat.findValueTokens(\n...     'object', query(subject=jack, predicate=BEGAT),\n...     ignoreSearchIndex=True), 'object'))\nTrue\n</pre>\n<pre>&gt;&gt;&gt; res = newcat.findRelations(\n...     query(subject=jack, predicate=BEGAT),\n...     ignoreSearchIndex=True)\n&gt;&gt;&gt; res # doctest: +ELLIPSIS\n&lt;generator object ... at 0x...&gt;\n&gt;&gt;&gt; list(res) == list(newcat.resolveRelationTokens(\n...     newcat.findRelationTokens(\n...         query(subject=jack, predicate=BEGAT),\n...         ignoreSearchIndex=True)))\nTrue\n</pre>\n<pre>&gt;&gt;&gt; newcat.canFind(\n...     query(subject=jack, predicate=BEGAT), ignoreSearchIndex=True)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"findrelationtokens\">\n<h4><a href=\"#id54\" rel=\"nofollow\"><tt>findRelationTokens()</tt></a></h4>\n<p>If you call <tt>findRelationTokens</tt> without any arguments, you will get the\nBTree set of all relation tokens in the catalog.  This can be handy for tests\nand for advanced uses of the catalog.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; newcat.findRelationTokens() # doctest: +ELLIPSIS\n&lt;BTrees.LFBTree.LFTreeSet object at ...&gt;\n&gt;&gt;&gt; len(newcat.findRelationTokens())\n8\n&gt;&gt;&gt; set(newcat.resolveRelationTokens(newcat.findRelationTokens())) == set(\n...     (rel1, rel2, rel3, rel4, rel5, rel6, rel7, rel8))\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"findvaluetokens-index-name\">\n<h4><a href=\"#id55\" rel=\"nofollow\"><tt>findValueTokens(INDEX_NAME)</tt></a></h4>\n<p>If you call <tt>findValueTokens</tt> with only an index name, you will get the BTree\nstructure of all tokens for that value in the index. This can be handy for\ntests and for advanced uses of the catalog.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; newcat.findValueTokens('predicate') # doctest: +ELLIPSIS\n&lt;BTrees.OOBTree.OOBTree object at ...&gt;\n&gt;&gt;&gt; list(newcat.findValueTokens('predicate'))\n['BEGAT', 'BUYS', 'OBSERVES', 'SELLS']\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"conclusion\">\n<h3><a href=\"#id56\" rel=\"nofollow\">Conclusion</a></h3>\n<div id=\"review\">\n<h4><a href=\"#id57\" rel=\"nofollow\">Review</a></h4>\n<p>That brings us to the end of our introductory examples.  Let\u2019s review, and\nthen look at where you can go from here.</p>\n<ul>\n<li><p>Relations are objects with indexed values.</p>\n</li>\n<li><p>The relation catalog indexes relations. The relations can be one-way,\ntwo-way, three-way, or N-way, as long as you tell the catalog to index the\ndifferent values.</p>\n</li>\n<li><p>Creating a catalog:</p>\n<blockquote>\n<ul>\n<li><p>Relations and their values are stored in the catalog as tokens: unique\nidentifiers that you can resolve back to the original value. Integers are\nthe most efficient tokens, but others can work fine too.</p>\n</li>\n<li><p>Token type determines the BTree module needed.</p>\n<blockquote>\n<ul>\n<li>If the tokens are 32-bit ints, choose <tt>BTrees.family32.II</tt>,\n<tt>BTrees.family32.IF</tt> or <tt>BTrees.family32.IO</tt>.</li>\n<li>If the tokens are 64 bit ints, choose <tt>BTrees.family64.II</tt>,\n<tt>BTrees.family64.IF</tt> or <tt>BTrees.family64.IO</tt>.</li>\n<li>If they are anything else, choose <tt>BTrees.family32.OI</tt>,\n<tt>BTrees.family64.OI</tt>, or <tt>BTrees.family32.OO</tt> (or\nBTrees.family64.OO\u2013they are the same).</li>\n</ul>\n</blockquote>\n<p>Within these rules, the choice is somewhat arbitrary unless you plan to\nmerge these results with that of another source that is using a\nparticular BTree module. BTree set operations only work within the same\nmodule, so you must match module to module.</p>\n</li>\n<li><p>The <tt>family</tt> argument in instantiating the catalog lets you change the\ndefault btree family for relations and value indexes from\n<tt>BTrees.family32.IF</tt> to <tt>BTrees.family64.IF</tt>.</p>\n</li>\n<li><p>You must define your own functions for tokenizing and resolving tokens.\nThese functions are registered with the catalog for the relations and for\neach of their value indexes.</p>\n</li>\n<li><p>You add value indexes to relation catalogs to be able to search.  Values\ncan be identified to the catalog with callables or interface elements.</p>\n<blockquote>\n<ul>\n<li>Using interface attributes will cause an attempt to adapt the\nrelation if it does not already provide the interface.</li>\n<li>We can use the <tt>multiple</tt> argument when defining a value index to\nindicate that the indexed value is a collection.  This defaults to\nFalse.</li>\n<li>We can use the <tt>name</tt> argument when defining a value index to\nspecify the name to be used in queries, rather than relying on the\nname of the interface attribute or callable.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>You can set up search indexes to speed up specific searches, usually\ntransitive.</p>\n</li>\n<li><p>Listeners can be registered in the catalog. They are alerted when a\nrelation is added, modified, or removed; and when the catalog is cleared\nand copied.</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>Catalog Management:</p>\n<blockquote>\n<ul>\n<li>Relations are indexed with <tt>index(relation)</tt>, and removed from the\ncatalog with <tt>unindex(relation)</tt>. <tt>index_doc(relation_token,\nrelation)</tt> and <tt>unindex_doc(relation_token)</tt> also work.</li>\n<li>The <tt>clear</tt> method clears the relations in the catalog.</li>\n<li>The <tt>copy</tt> method makes a copy of the current catalog by copying\ninternal data structures, rather than reindexing the relations, which can\nbe a significant optimization opportunity. This copies value indexes and\nsearch indexes; and gives listeners an opportunity to specify what, if\nanything, should be included in the new copy.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>Searching a catalog:</p>\n<blockquote>\n<ul>\n<li><p>Queries to the relation catalog are formed with dicts.</p>\n</li>\n<li><p>Query keys are the names of the indexes you want to search, or, for the\nspecial case of precise relations, the <tt>zc.relation.RELATION</tt> constant.</p>\n</li>\n<li><p>Query values are the tokens of the results you want to match; or\n<tt>None</tt>, indicating relations that have <tt>None</tt> as a value (or an empty\ncollection, if it is a multiple). Search values can use\n<tt>zc.relation.catalog.any(args)</tt> or <tt>zc.relation.catalog.Any(args)</tt> to\nspecify multiple (non-<tt>None</tt>) results to match for a given key.</p>\n</li>\n<li><p>The index has a variety of methods to help you work with tokens.\n<tt>tokenizeQuery</tt> is typically the most used, though others are\navailable.</p>\n</li>\n<li><p>To find relations that match a query, use <tt>findRelations</tt> or\n<tt>findRelationTokens</tt>.  Calling <tt>findRelationTokens</tt> without any\narguments returns the BTree set of all relation tokens in the catalog.</p>\n</li>\n<li><p>To find values that match a query, use <tt>findValues</tt> or\n<tt>findValueTokens</tt>.  Calling <tt>findValueTokens</tt> with only the name\nof a value index returns the BTree set of all tokens in the catalog for\nthat value index.</p>\n</li>\n<li><p>You search transitively by using a query factory. The\n<tt>zc.relation.queryfactory.TransposingTransitive</tt> is a good common case\nfactory that lets you walk up and down a hierarchy. A query factory can\nbe passed in as an argument to search methods as a <tt>queryFactory</tt>, or\ninstalled as a default behavior using <tt>addDefaultQueryFactory</tt>.</p>\n</li>\n<li><p>To find how a query is related, use <tt>findRelationChains</tt> or\n<tt>findRelationTokenChains</tt>.</p>\n</li>\n<li><p>To find out if a query is related, use <tt>canFind</tt>.</p>\n</li>\n<li><p>Circular transitive relations are handled to prevent infinite loops. They\nare identified in <tt>findRelationChains</tt> and <tt>findRelationTokenChains</tt>\nwith a <tt>zc.relation.interfaces.ICircularRelationPath</tt> marker interface.</p>\n</li>\n<li><p>search methods share the following arguments:</p>\n<ul>\n<li><tt>maxDepth</tt>, limiting the transitive depth for searches;</li>\n<li><tt>filter</tt>, allowing code to filter transitive paths;</li>\n<li><tt>targetQuery</tt>, allowing a query to filter transitive paths on the\nbasis of the endpoint;</li>\n<li><tt>targetFilter</tt>, allowing code to filter transitive paths on the basis\nof the endpoint; and</li>\n<li><tt>queryFactory</tt>, mentioned above.</li>\n</ul>\n<p>In addition, the <tt>ignoreSearchIndex</tt> argument to <tt>findRelations</tt>,\n<tt>findRelationTokens</tt>, <tt>findValues</tt>, <tt>findValueTokens</tt>, and\n<tt>canFind</tt> causes the search to ignore search indexes, even if there is\nan appropriate one.</p>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</div>\n<div id=\"next-steps\">\n<h4><a href=\"#id58\" rel=\"nofollow\">Next Steps</a></h4>\n<p>If you want to read more, next steps depend on how you like to learn.  Here\nare some of the other documents in the zc.relation package.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>optimization.rst:</th></tr>\n<tr><td>\u00a0</td><td>Best practices for optimizing your use of the relation catalog.</td>\n</tr>\n<tr><th>searchindex.rst:</th></tr>\n<tr><td>\u00a0</td><td>Queries factories and search indexes: from basics to nitty gritty details.</td>\n</tr>\n<tr><th>tokens.rst:</th><td>This document explores the details of tokens.  All God\u2019s chillun\nlove tokens, at least if God\u2019s chillun are writing non-toy apps\nusing zc.relation.  It includes discussion of the token helpers that\nthe catalog provides, how to use zope.app.intid-like registries with\nzc.relation, how to use tokens to \u201cjoin\u201d query results reasonably\nefficiently, and how to index joins.  It also is unnecessarily\nmind-blowing because of the examples used.</td>\n</tr>\n<tr><th>interfaces.py:</th><td>The contract, for nuts and bolts.</td>\n</tr>\n</tbody>\n</table>\n<p>Finally, the truly die-hard might also be interested in the timeit\ndirectory, which holds scripts used to test assumptions and learn.</p>\n<table id=\"i-care\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id7\" rel=\"nofollow\">[13]</a></td><td><p>OK, you care about how that query factory worked, so\nwe will look into it a bit.  Let\u2019s talk through two steps of the\ntransitive search in the second question.  The catalog initially\nperforms the initial intransitive search requested: find relations\nfor which Betty is the supervisor.  That\u2019s Diane and Edgar.</p>\n<p>Now, for each of the results, the catalog asks the query factory for\nnext steps.  Let\u2019s take Diane.  The catalog says to the factory,\n\u201cGiven this query for relations where Betty is supervisor, I got\nthis result of Diane.  Do you have any other queries I should try to\nlook further?\u201d.  The factory also gets the catalog instance so it\ncan use it to answer the question if it needs to.</p>\n<p>OK, the next part is where your brain hurts.  Hang on.</p>\n<p>In our case, the factory sees that the query was for supervisor. Its\nother key, the one it transposes with, is <tt>zc.relation.RELATION</tt>. <em>The\nfactory gets the transposing key\u2019s result for the current token.</em> So, for\nus, a key of <tt>zc.relation.RELATION</tt> is actually a no-op: the result <em>is</em>\nthe current token, Diane. Then, the factory has its answer: replace the old\nvalue of supervisor in the query, Betty, with the result, Diane. The next\ntransitive query should be {\u2018supervisor\u2019, \u2018Diane\u2019}. Ta-da.</p>\n</td></tr>\n</tbody>\n</table>\n</div>\n</div>\n</div>\n<div id=\"tokens-and-joins-zc-relation-catalog-extended-example\">\n<h2><a href=\"#id59\" rel=\"nofollow\">Tokens and Joins: zc.relation Catalog Extended Example</a></h2>\n<div id=\"introduction-and-set-up\">\n<h3><a href=\"#id60\" rel=\"nofollow\">Introduction and Set Up</a></h3>\n<p>This document assumes you have read the introductory README.rst and want\nto learn a bit more by example. In it, we will explore a more\ncomplicated set of relations that demonstrates most of the aspects of\nworking with tokens.  In particular, we will look at joins, which will\nalso give us a chance to look more in depth at query factories and\nsearch indexes, and introduce the idea of listeners. It will not explain\nthe basics that the README already addressed.</p>\n<p>Imagine we are indexing security assertions in a system.  In this\nsystem, users may have roles within an organization.  Each organization\nmay have multiple child organizations and may have a single parent\norganization.  A user with a role in a parent organization will have the\nsame role in all transitively connected child relations.</p>\n<p>We have two kinds of relations, then.  One kind of relation will model\nthe hierarchy of organizations.  We\u2019ll do it with an intrinsic relation\nof organizations to their children: that reflects the fact that parent\norganizations choose and are comprised of their children; children do\nnot choose their parents.</p>\n<p>The other relation will model the (multiple) roles a (single) user has\nin a (single) organization.  This relation will be entirely extrinsic.</p>\n<p>We could create two catalogs, one for each type.  Or we could put them\nboth in the same catalog.  Initially, we\u2019ll go with the single-catalog\napproach for our examples.  This single catalog, then, will be indexing\na heterogeneous collection of relations.</p>\n<p>Let\u2019s define the two relations with interfaces.  We\u2019ll include one\naccessor, getOrganization, largely to show how to handle methods.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; class IOrganization(zope.interface.Interface):\n...     title = zope.interface.Attribute('the title')\n...     parts = zope.interface.Attribute(\n...         'the organizations that make up this one')\n...\n&gt;&gt;&gt; class IRoles(zope.interface.Interface):\n...     def getOrganization():\n...         'return the organization in which this relation operates'\n...     principal_id = zope.interface.Attribute(\n...         'the pricipal id whose roles this relation lists')\n...     role_ids = zope.interface.Attribute(\n...         'the role ids that the principal explicitly has in the '\n...         'organization.  The principal may have other roles via '\n...         'roles in parent organizations.')\n...\n</pre>\n</blockquote>\n<p>Now we can create some classes.  In the README example, the setup was a bit\nof a toy.  This time we will be just a bit more practical.  We\u2019ll also expect\nto be operating within the ZODB, with a root and transactions. <a href=\"#zodb\" id=\"id14\" rel=\"nofollow\">[14]</a></p>\n<table id=\"zodb\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id14\" rel=\"nofollow\">[14]</a></td><td><p>Here we will set up a ZODB instance for us to use.</p>\n<pre>\n&gt;&gt;&gt; from ZODB.tests.util import DB\n&gt;&gt;&gt; db = DB()\n&gt;&gt;&gt; conn = db.open()\n&gt;&gt;&gt; root = conn.root()\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>Here\u2019s how we will dump and load our relations: use a \u201cregistry\u201d\nobject, similar to an intid utility. <a href=\"#faux-intid\" id=\"id15\" rel=\"nofollow\">[15]</a></p>\n<table id=\"faux-intid\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id15\" rel=\"nofollow\">[15]</a></td><td><p>Here\u2019s a simple persistent keyreference.  Notice that it is\nnot persistent itself: this is important for conflict resolution to be\nable to work (which we don\u2019t show here, but we\u2019re trying to lean more\ntowards real usage for this example).</p>\n<pre>\n&gt;&gt;&gt; from functools import total_ordering\n&gt;&gt;&gt; @total_ordering\n... class Reference(object): # see zope.app.keyreference\n...     def __init__(self, obj):\n...         self.object = obj\n...     def _get_sorting_key(self):\n...         # this doesn't work during conflict resolution.  See\n...         # zope.app.keyreference.persistent, 3.5 release, for current\n...         # best practice.\n...         if self.object._p_jar is None:\n...             raise ValueError(\n...                 'can only compare when both objects have connections')\n...         return self.object._p_oid or ''\n...     def __lt__(self, other):\n...         # this doesn't work during conflict resolution.  See\n...         # zope.app.keyreference.persistent, 3.5 release, for current\n...         # best practice.\n...         if not isinstance(other, Reference):\n...             raise ValueError('can only compare with Reference objects')\n...         return self._get_sorting_key() &lt; other._get_sorting_key()\n...     def __eq__(self, other):\n...         # this doesn't work during conflict resolution.  See\n...         # zope.app.keyreference.persistent, 3.5 release, for current\n...         # best practice.\n...         if not isinstance(other, Reference):\n...             raise ValueError('can only compare with Reference objects')\n...         return self._get_sorting_key() == other._get_sorting_key()\n</pre>\n<p>Here\u2019s a simple integer identifier tool.</p>\n<pre>\n&gt;&gt;&gt; import persistent\n&gt;&gt;&gt; import BTrees\n&gt;&gt;&gt; import six\n&gt;&gt;&gt; class Registry(persistent.Persistent): # see zope.app.intid\n...     def __init__(self, family=BTrees.family32):\n...         self.family = family\n...         self.ids = self.family.IO.BTree()\n...         self.refs = self.family.OI.BTree()\n...     def getId(self, obj):\n...         if not isinstance(obj, persistent.Persistent):\n...             raise ValueError('not a persistent object', obj)\n...         if obj._p_jar is None:\n...             self._p_jar.add(obj)\n...         ref = Reference(obj)\n...         id = self.refs.get(ref)\n...         if id is None:\n...             # naive for conflict resolution; see zope.app.intid\n...             if self.ids:\n...                 id = self.ids.maxKey() + 1\n...             else:\n...                  id = self.family.minint\n...             self.ids[id] = ref\n...             self.refs[ref] = id\n...         return id\n...     def __contains__(self, obj):\n...         if (not isinstance(obj, persistent.Persistent) or\n...             obj._p_oid is None):\n...             return False\n...         return Reference(obj) in self.refs\n...     def getObject(self, id, default=None):\n...         res = self.ids.get(id, None)\n...         if res is None:\n...             return default\n...         else:\n...             return res.object\n...     def remove(self, r):\n...         if isinstance(r, six.integer_types):\n...             self.refs.pop(self.ids.pop(r))\n...         elif (not isinstance(r, persistent.Persistent) or\n...               r._p_oid is None):\n...             raise LookupError(r)\n...         else:\n...             self.ids.pop(self.refs.pop(Reference(r)))\n...\n&gt;&gt;&gt; registry = root['registry'] = Registry()\n</pre>\n<pre>\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>In this implementation of the \u201cdump\u201d method, we use the cache just to\nshow you how you might use it.  It probably is overkill for this job,\nand maybe even a speed loss, but you can see the idea.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def dump(obj, catalog, cache):\n...     reg = cache.get('registry')\n...     if reg is None:\n...         reg = cache['registry'] = catalog._p_jar.root()['registry']\n...     return reg.getId(obj)\n...\n&gt;&gt;&gt; def load(token, catalog, cache):\n...     reg = cache.get('registry')\n...     if reg is None:\n...         reg = cache['registry'] = catalog._p_jar.root()['registry']\n...     return reg.getObject(token)\n...\n</pre>\n</blockquote>\n<p>Now we can create a relation catalog to hold these items.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation.catalog\n&gt;&gt;&gt; catalog = root['catalog'] = zc.relation.catalog.Catalog(dump, load)\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Now we set up our indexes.  We\u2019ll start with just the organizations, and\nset up the catalog with them. This part will be similar to the example\nin README.rst, but will introduce more discussions of optimizations and\ntokens.  Then we\u2019ll add in the part about roles, and explore queries and\ntoken-based \u201cjoins\u201d.</p>\n</div>\n<div id=\"organizations\">\n<h3><a href=\"#id61\" rel=\"nofollow\">Organizations</a></h3>\n<p>The organization will hold a set of organizations.  This is actually not\ninherently easy in the ZODB because this means that we need to compare\nor hash persistent objects, which does not work reliably over time and\nacross machines out-of-the-box.  To side-step the issue for this example,\nand still do something a bit interesting and real-world, we\u2019ll use the\nregistry tokens introduced above.  This will also give us a chance to\ntalk a bit more about optimizations and tokens.  (If you would like\nto sanely and transparently hold a set of persistent objects, try the\nzc.set package XXX not yet.)</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import BTrees\n&gt;&gt;&gt; import persistent\n&gt;&gt;&gt; @zope.interface.implementer(IOrganization)\n... @total_ordering\n... class Organization(persistent.Persistent):\n...\n...     def __init__(self, title):\n...         self.title = title\n...         self.parts = BTrees.family32.IF.TreeSet()\n...     # the next parts just make the tests prettier\n...     def __repr__(self):\n...         return '&lt;Organization instance \"' + self.title + '\"&gt;'\n...     def __lt__(self, other):\n...         # pukes if other doesn't have name\n...         return self.title &lt; other.title\n...     def __eq__(self, other):\n...         return self is other\n...     def __hash__(self):\n...         return 1  # dummy\n...\n</pre>\n</blockquote>\n<p>OK, now we know how organizations will work.  Now we can add the <cite>parts</cite>\nindex to the catalog.  This will do a few new things from how we added\nindexes in the README.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.addValueIndex(IOrganization['parts'], multiple=True,\n...                       name=\"part\")\n</pre>\n</blockquote>\n<p>So, what\u2019s different from the README examples?</p>\n<p>First, we are using an interface element to define the value to be indexed.\nIt provides an interface to which objects will be adapted, a default name\nfor the index, and information as to whether the attribute should be used\ndirectly or called.</p>\n<p>Second, we are not specifying a dump or load.  They are None.  This\nmeans that the indexed value can already be treated as a token.  This\ncan allow a very significant optimization for reindexing if the indexed\nvalue is a large collection using the same BTree family as the\nindex\u2013which leads us to the next difference.</p>\n<p>Third, we are specifying that <cite>multiple=True</cite>.  This means that the value\non a given relation that provides or can be adapted to IOrganization will\nhave a collection of <cite>parts</cite>.  These will always be regarded as a set,\nwhether the actual colection is a BTrees set or the keys of a BTree.</p>\n<p>Last, we are specifying a name to be used for queries.  I find that queries\nread more easily when the query keys are singular, so I often rename plurals.</p>\n<p>As in the README, We can add another simple transposing transitive query\nfactory, switching between \u2018part\u2019 and <cite>None</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation.queryfactory\n&gt;&gt;&gt; factory1 = zc.relation.queryfactory.TransposingTransitive(\n...     'part', None)\n&gt;&gt;&gt; catalog.addDefaultQueryFactory(factory1)\n</pre>\n</blockquote>\n<p>Let\u2019s add a couple of search indexes in too, of the hierarchy looking up\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation.searchindex\n&gt;&gt;&gt; catalog.addSearchIndex(\n...     zc.relation.searchindex.TransposingTransitiveMembership(\n...         'part', None))\n</pre>\n</blockquote>\n<p>\u2026and down.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.addSearchIndex(\n...     zc.relation.searchindex.TransposingTransitiveMembership(\n...         None, 'part'))\n</pre>\n</blockquote>\n<p>PLEASE NOTE: the search index looking up is not a good idea practically.  The\nindex is designed for looking down <a href=\"#verifyobjecttransitive\" id=\"id16\" rel=\"nofollow\">[16]</a>.</p>\n<table id=\"verifyobjecttransitive\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id16\" rel=\"nofollow\">[16]</a></td><td><p>The TransposingTransitiveMembership indexes\nprovide ISearchIndex.</p>\n<pre>\n&gt;&gt;&gt; from zope.interface.verify import verifyObject\n&gt;&gt;&gt; import zc.relation.interfaces\n&gt;&gt;&gt; index = list(catalog.iterSearchIndexes())[0]\n&gt;&gt;&gt; verifyObject(zc.relation.interfaces.ISearchIndex, index)\nTrue\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>Let\u2019s create and add a few organizations.</p>\n<p>We\u2019ll make a structure like this <a href=\"#silliness\" id=\"id17\" rel=\"nofollow\">[24]</a>:</p>\n<pre>        Ynod Corp Mangement                 Zookd Corp Management\n         /      |      \\                       /      |      \\\n  Ynod Devs  Ynod SAs  Ynod Admins  Zookd Admins   Zookd SAs  Zookd Devs\n    /      \\              \\                 /                /         \\\nY3L4 Proj  Bet Proj      Ynod Zookd Task Force      Zookd hOgnmd     Zookd Nbd\n</pre>\n<p>Here\u2019s the Python.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; orgs = root['organizations'] = BTrees.family32.OO.BTree()\n&gt;&gt;&gt; for nm, parts in (\n...     ('Y3L4 Proj', ()),\n...     ('Bet Proj', ()),\n...     ('Ynod Zookd Task Force', ()),\n...     ('Zookd hOgnmd', ()),\n...     ('Zookd Nbd', ()),\n...     ('Ynod Devs', ('Y3L4 Proj', 'Bet Proj')),\n...     ('Ynod SAs', ()),\n...     ('Ynod Admins', ('Ynod Zookd Task Force',)),\n...     ('Zookd Admins', ('Ynod Zookd Task Force',)),\n...     ('Zookd SAs', ()),\n...     ('Zookd Devs', ('Zookd hOgnmd', 'Zookd Nbd')),\n...     ('Ynod Corp Management', ('Ynod Devs', 'Ynod SAs', 'Ynod Admins')),\n...     ('Zookd Corp Management', ('Zookd Devs', 'Zookd SAs',\n...                                'Zookd Admins'))):\n...     org = Organization(nm)\n...     for part in parts:\n...         ignore = org.parts.insert(registry.getId(orgs[part]))\n...     orgs[nm] = org\n...     catalog.index(org)\n...\n</pre>\n</blockquote>\n<p>Now the catalog knows about the relations.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(catalog)\n13\n&gt;&gt;&gt; root['dummy'] = Organization('Foo')\n&gt;&gt;&gt; root['dummy'] in catalog\nFalse\n&gt;&gt;&gt; orgs['Y3L4 Proj'] in catalog\nTrue\n</pre>\n</blockquote>\n<p>Also, now we can search.  To do this, we can use some of the token methods that\nthe catalog provides.  The most commonly used is <cite>tokenizeQuery</cite>.  It takes a\nquery with values that are not tokenized and converts them to values that are\ntokenized.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; Ynod_SAs_id = registry.getId(orgs['Ynod SAs'])\n&gt;&gt;&gt; catalog.tokenizeQuery({None: orgs['Ynod SAs']}) == {\n...     None: Ynod_SAs_id}\nTrue\n&gt;&gt;&gt; Zookd_SAs_id = registry.getId(orgs['Zookd SAs'])\n&gt;&gt;&gt; Zookd_Devs_id = registry.getId(orgs['Zookd Devs'])\n&gt;&gt;&gt; catalog.tokenizeQuery(\n...     {None: zc.relation.catalog.any(\n...         orgs['Zookd SAs'], orgs['Zookd Devs'])}) == {\n...     None: zc.relation.catalog.any(Zookd_SAs_id, Zookd_Devs_id)}\nTrue\n</pre>\n</blockquote>\n<p>Of course, right now doing this with \u2018part\u2019 alone is kind of silly, since it\ndoes not change within the relation catalog (because we said that dump and\nload were <cite>None</cite>, as discussed above).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.tokenizeQuery({'part': Ynod_SAs_id}) == {\n...     'part': Ynod_SAs_id}\nTrue\n&gt;&gt;&gt; catalog.tokenizeQuery(\n...     {'part': zc.relation.catalog.any(Zookd_SAs_id, Zookd_Devs_id)}\n...     ) == {'part': zc.relation.catalog.any(Zookd_SAs_id, Zookd_Devs_id)}\nTrue\n</pre>\n</blockquote>\n<p>The <cite>tokenizeQuery</cite> method is so common that we\u2019re going to assign it to\na variable in our example. Then we\u2019ll do a search or two.</p>\n<p>So\u2026find the relations that Ynod Devs supervise.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; t = catalog.tokenizeQuery\n&gt;&gt;&gt; res = list(catalog.findRelationTokens(t({None: orgs['Ynod Devs']})))\n</pre>\n</blockquote>\n<p>OK\u2026we used <cite>findRelationTokens</cite>, as opposed to <cite>findRelations</cite>, so res\nis a couple of numbers now.  How do we convert them back?\n<cite>resolveRelationTokens</cite> will do the trick.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(res)\n3\n&gt;&gt;&gt; sorted(catalog.resolveRelationTokens(res))\n... # doctest: +NORMALIZE_WHITESPACE\n[&lt;Organization instance \"Bet Proj\"&gt;, &lt;Organization instance \"Y3L4 Proj\"&gt;,\n &lt;Organization instance \"Ynod Devs\"&gt;]\n</pre>\n</blockquote>\n<p><cite>resolveQuery</cite> is the mirror image of <cite>tokenizeQuery</cite>: it converts\ntokenized queries to queries with \u201cloaded\u201d values.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; original = {'part': zc.relation.catalog.any(\n...                 Zookd_SAs_id, Zookd_Devs_id),\n...             None: orgs['Zookd Devs']}\n&gt;&gt;&gt; tokenized = catalog.tokenizeQuery(original)\n&gt;&gt;&gt; original == catalog.resolveQuery(tokenized)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; original = {None: zc.relation.catalog.any(\n...                 orgs['Zookd SAs'], orgs['Zookd Devs']),\n...             'part': Zookd_Devs_id}\n&gt;&gt;&gt; tokenized = catalog.tokenizeQuery(original)\n&gt;&gt;&gt; original == catalog.resolveQuery(tokenized)\nTrue\n</pre>\n</blockquote>\n<p>Likewise, <cite>tokenizeRelations</cite> is the mirror image of <cite>resolveRelationTokens</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.tokenizeRelations(\n...     [orgs[\"Bet Proj\"], orgs[\"Y3L4 Proj\"]])) == sorted(\n...     registry.getId(o) for o in\n...     [orgs[\"Bet Proj\"], orgs[\"Y3L4 Proj\"]])\nTrue\n</pre>\n</blockquote>\n<p>The other token-related methods are as follows\n<a href=\"#show-remaining-token-methods\" id=\"id18\" rel=\"nofollow\">[17]</a>:</p>\n<table id=\"show-remaining-token-methods\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id18\" rel=\"nofollow\">[17]</a></td><td><p>For what it\u2019s worth, here are some small\nexamples of the remaining token-related methods.</p>\n<p>These two are the singular versions of <cite>tokenizeRelations</cite> and\n<cite>resolveRelationTokens</cite>.</p>\n<p><cite>tokenizeRelation</cite> returns a token for the given relation.</p>\n<pre>\n&gt;&gt;&gt; catalog.tokenizeRelation(orgs['Zookd Corp Management']) == (\n...     registry.getId(orgs['Zookd Corp Management']))\nTrue\n</pre>\n<p><cite>resolveRelationToken</cite> returns a relation for the given token.</p>\n<pre>\n&gt;&gt;&gt; catalog.resolveRelationToken(registry.getId(\n...     orgs['Zookd Corp Management'])) is orgs['Zookd Corp Management']\nTrue\n</pre>\n<p>The \u201cvalues\u201d ones are a bit lame to show now, since the only value\nwe have right now is not tokenized but used straight up.  But here\ngoes, showing some fascinating no-ops.</p>\n<p><cite>tokenizeValues</cite>, returns an iterable of tokens for the values of\nthe given index name.</p>\n<pre>\n&gt;&gt;&gt; list(catalog.tokenizeValues((1,2,3), 'part'))\n[1, 2, 3]\n</pre>\n<p><cite>resolveValueTokens</cite> returns an iterable of values for the tokens of\nthe given index name.</p>\n<pre>\n&gt;&gt;&gt; list(catalog.resolveValueTokens((1,2,3), 'part'))\n[1, 2, 3]\n</pre>\n</td></tr>\n</tbody>\n</table>\n<ul>\n<li><cite>tokenizeValues</cite>, which returns an iterable of tokens for the values\nof the given index name;</li>\n<li><cite>resolveValueTokens</cite>, which returns an iterable of values for the tokens of\nthe given index name;</li>\n<li><cite>tokenizeRelation</cite>, which returns a token for the given relation; and</li>\n<li><cite>resolveRelationToken</cite>, which returns a relation for the given token.</li>\n</ul>\n<p>Why do we bother with these tokens, instead of hiding them away and\nmaking the API prettier?  By exposing them, we enable efficient joining,\nand efficient use in other contexts.  For instance, if you use the same\nintid utility to tokenize in other catalogs, our results can be merged\nwith the results of other catalogs.  Similarly, you can use the results\nof queries to other catalogs\u2013or even \u201cjoins\u201d from earlier results of\nquerying this catalog\u2013as query values here.  We\u2019ll explore this in the\nnext section.</p>\n</div>\n<div id=\"roles\">\n<h3><a href=\"#id62\" rel=\"nofollow\">Roles</a></h3>\n<p>We have set up the Organization relations.  Now let\u2019s set up the roles, and\nactually be able to answer the questions that we described at the beginning\nof the document.</p>\n<p>In our Roles object, roles and principals will simply be strings\u2013ids, if\nthis were a real system.  The organization will be a direct object reference.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IRoles)\n... @total_ordering\n... class Roles(persistent.Persistent):\n...\n...     def __init__(self, principal_id, role_ids, organization):\n...         self.principal_id = principal_id\n...         self.role_ids = BTrees.family32.OI.TreeSet(role_ids)\n...         self._organization = organization\n...     def getOrganization(self):\n...         return self._organization\n...     # the rest is for prettier/easier tests\n...     def __repr__(self):\n...         return \"&lt;Roles instance (%s has %s in %s)&gt;\" % (\n...             self.principal_id, ', '.join(self.role_ids),\n...             self._organization.title)\n...     def __lt__(self, other):\n...         _self = (\n...             self.principal_id,\n...             tuple(self.role_ids),\n...             self._organization.title,\n...         )\n...         _other = (\n...             other.principal_id,\n...             tuple(other.role_ids),\n...             other._organization.title,\n...         )\n...         return _self &lt;_other\n...     def __eq__(self, other):\n...         return self is other\n...     def __hash__(self):\n...         return 1  # dummy\n...\n</pre>\n</blockquote>\n<p>Now let\u2019s add add the value indexes to the relation catalog.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.addValueIndex(IRoles['principal_id'], btree=BTrees.family32.OI)\n&gt;&gt;&gt; catalog.addValueIndex(IRoles['role_ids'], btree=BTrees.family32.OI,\n...                       multiple=True, name='role_id')\n&gt;&gt;&gt; catalog.addValueIndex(IRoles['getOrganization'], dump, load,\n...                       name='organization')\n</pre>\n</blockquote>\n<p>Those are some slightly new variations of what we\u2019ve seen in <cite>addValueIndex</cite>\nbefore, but all mixing and matching on the same ingredients.</p>\n<p>As a reminder, here is our organization structure:</p>\n<pre>        Ynod Corp Mangement                 Zookd Corp Management\n         /      |      \\                       /      |      \\\n  Ynod Devs  Ynod SAs  Ynod Admins  Zookd Admins   Zookd SAs  Zookd Devs\n    /      \\              \\                 /                /         \\\nY3L4 Proj  Bet Proj      Ynod Zookd Task Force      Zookd hOgnmd     Zookd Nbd\n</pre>\n<p>Now let\u2019s create and add some roles.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principal_ids = [\n...     'abe', 'bran', 'cathy', 'david', 'edgar', 'frank', 'gertrude',\n...     'harriet', 'ignas', 'jacob', 'karyn', 'lettie', 'molly', 'nancy',\n...     'ophelia', 'pat']\n&gt;&gt;&gt; role_ids = ['user manager', 'writer', 'reviewer', 'publisher']\n&gt;&gt;&gt; get_role = dict((v[0], v) for v in role_ids).__getitem__\n&gt;&gt;&gt; roles = root['roles'] = BTrees.family32.IO.BTree()\n&gt;&gt;&gt; next = 0\n&gt;&gt;&gt; for prin, org, role_ids in (\n...     ('abe', orgs['Zookd Corp Management'], 'uwrp'),\n...     ('bran', orgs['Ynod Corp Management'], 'uwrp'),\n...     ('cathy', orgs['Ynod Devs'], 'w'),\n...     ('cathy', orgs['Y3L4 Proj'], 'r'),\n...     ('david', orgs['Bet Proj'], 'wrp'),\n...     ('edgar', orgs['Ynod Devs'], 'up'),\n...     ('frank', orgs['Ynod SAs'], 'uwrp'),\n...     ('frank', orgs['Ynod Admins'], 'w'),\n...     ('gertrude', orgs['Ynod Zookd Task Force'], 'uwrp'),\n...     ('harriet', orgs['Ynod Zookd Task Force'], 'w'),\n...     ('harriet', orgs['Ynod Admins'], 'r'),\n...     ('ignas', orgs['Zookd Admins'], 'r'),\n...     ('ignas', orgs['Zookd Corp Management'], 'w'),\n...     ('karyn', orgs['Zookd Corp Management'], 'uwrp'),\n...     ('karyn', orgs['Ynod Corp Management'], 'uwrp'),\n...     ('lettie', orgs['Zookd Corp Management'], 'u'),\n...     ('lettie', orgs['Ynod Zookd Task Force'], 'w'),\n...     ('lettie', orgs['Zookd SAs'], 'w'),\n...     ('molly', orgs['Zookd SAs'], 'uwrp'),\n...     ('nancy', orgs['Zookd Devs'], 'wrp'),\n...     ('nancy', orgs['Zookd hOgnmd'], 'u'),\n...     ('ophelia', orgs['Zookd Corp Management'], 'w'),\n...     ('ophelia', orgs['Zookd Devs'], 'r'),\n...     ('ophelia', orgs['Zookd Nbd'], 'p'),\n...     ('pat', orgs['Zookd Nbd'], 'wrp')):\n...     assert prin in principal_ids\n...     role_ids = [get_role(l) for l in role_ids]\n...     role = roles[next] = Roles(prin, role_ids, org)\n...     role.key = next\n...     next += 1\n...     catalog.index(role)\n...\n</pre>\n</blockquote>\n<p>Now we can begin to do searches <a href=\"#real-value-tokens\" id=\"id19\" rel=\"nofollow\">[18]</a>.</p>\n<table id=\"real-value-tokens\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id19\" rel=\"nofollow\">[18]</a></td><td><p>We can also show the values token methods more\nsanely now.</p>\n<pre>\n&gt;&gt;&gt; original = sorted((orgs['Zookd Devs'], orgs['Ynod SAs']))\n&gt;&gt;&gt; tokens = list(catalog.tokenizeValues(original, 'organization'))\n&gt;&gt;&gt; original == sorted(catalog.resolveValueTokens(tokens, 'organization'))\nTrue\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>What are all the role settings for ophelia?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelations({'principal_id': 'ophelia'}))\n... # doctest: +NORMALIZE_WHITESPACE\n[&lt;Roles instance (ophelia has publisher in Zookd Nbd)&gt;,\n &lt;Roles instance (ophelia has reviewer in Zookd Devs)&gt;,\n &lt;Roles instance (ophelia has writer in Zookd Corp Management)&gt;]\n</pre>\n</blockquote>\n<p>That answer does not need to be transitive: we\u2019re done.</p>\n<p>Next question.  Where does ophelia have the \u2018writer\u2019 role?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findValues(\n...     'organization', {'principal_id': 'ophelia',\n...                        'role_id': 'writer'}))\n[&lt;Organization instance \"Zookd Corp Management\"&gt;]\n</pre>\n</blockquote>\n<p>Well, that\u2019s correct intransitively.  Do we need a transitive queries\nfactory?  No! This is a great chance to look at the token join we talked\nabout in the previous section.  This should actually be a two-step\noperation: find all of the organizations in which ophelia has writer,\nand then find all of the transitive parts to that organization.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelations({None: zc.relation.catalog.Any(\n...     catalog.findValueTokens('organization',\n...                             {'principal_id': 'ophelia',\n...                              'role_id': 'writer'}))}))\n... # doctest: +NORMALIZE_WHITESPACE\n[&lt;Organization instance \"Ynod Zookd Task Force\"&gt;,\n &lt;Organization instance \"Zookd Admins\"&gt;,\n &lt;Organization instance \"Zookd Corp Management\"&gt;,\n &lt;Organization instance \"Zookd Devs\"&gt;,\n &lt;Organization instance \"Zookd Nbd\"&gt;,\n &lt;Organization instance \"Zookd SAs\"&gt;,\n &lt;Organization instance \"Zookd hOgnmd\"&gt;]\n</pre>\n</blockquote>\n<p>That\u2019s more like it.</p>\n<p>Next question.  What users have roles in the \u2018Zookd Devs\u2019 organization?\nIntransitively, that\u2019s pretty easy.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'principal_id', t({'organization': orgs['Zookd Devs']})))\n['nancy', 'ophelia']\n</pre>\n</blockquote>\n<p>Transitively, we should do another join.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; org_id = registry.getId(orgs['Zookd Devs'])\n&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'principal_id', {\n...         'organization': zc.relation.catalog.any(\n...             org_id, *catalog.findRelationTokens({'part': org_id}))}))\n['abe', 'ignas', 'karyn', 'lettie', 'nancy', 'ophelia']\n</pre>\n</blockquote>\n<p>That\u2019s a little awkward, but it does the trick.</p>\n<dl>\n<dt>Last question, and the kind of question that started the entire example.</dt>\n<dd><p>What roles does ophelia have in the \u201cZookd Nbd\u201d organization?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'ophelia'})))\n['publisher']\n</pre>\n</blockquote>\n</dd>\n</dl>\n<p>Intransitively, that\u2019s correct.  But, transitively, ophelia also has\nreviewer and writer, and that\u2019s the answer we want to be able to get quickly.</p>\n<p>We could ask the question a different way, then, again leveraging a join.\nWe\u2019ll set it up as a function, because we will want to use it a little later\nwithout repeating the code.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def getRolesInOrganization(principal_id, org):\n...     org_id = registry.getId(org)\n...     return sorted(catalog.findValueTokens(\n...         'role_id', {\n...             'organization': zc.relation.catalog.any(\n...                 org_id,\n...                 *catalog.findRelationTokens({'part': org_id})),\n...             'principal_id': principal_id}))\n...\n&gt;&gt;&gt; getRolesInOrganization('ophelia', orgs['Zookd Nbd'])\n['publisher', 'reviewer', 'writer']\n</pre>\n</blockquote>\n<p>As you can see, then, working with tokens makes interesting joins possible,\nas long as the tokens are the same across the two queries.</p>\n<p>We have examined tokens methods and token techniques like joins.  The example\nstory we have told can let us get into a few more advanced topics, such as\nquery factory joins and search indexes that can increase their read speed.</p>\n</div>\n<div id=\"query-factory-joins\">\n<h3><a href=\"#id63\" rel=\"nofollow\">Query Factory Joins</a></h3>\n<p>We can build a query factory that makes the join automatic.  A query\nfactory is a callable that takes two arguments: a query (the one that\nstarts the search) and the catalog.  The factory either returns None,\nindicating that the query factory cannot be used for this query, or it\nreturns another callable that takes a chain of relations.  The last\ntoken in the relation chain is the most recent.  The output of this\ninner callable is expected to be an iterable of\nBTrees.family32.OO.Bucket queries to search further from the given chain\nof relations.</p>\n<p>Here\u2019s a flawed approach to this problem.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def flawed_factory(query, catalog):\n...     if (len(query) == 2 and\n...         'organization' in query and\n...         'principal_id' in query):\n...         def getQueries(relchain):\n...             if not relchain:\n...                 yield query\n...                 return\n...             current = catalog.getValueTokens(\n...                 'organization', relchain[-1])\n...             if current:\n...                 organizations = catalog.getRelationTokens(\n...                     {'part': zc.relation.catalog.Any(current)})\n...                 if organizations:\n...                     res = BTrees.family32.OO.Bucket(query)\n...                     res['organization'] = zc.relation.catalog.Any(\n...                         organizations)\n...                     yield res\n...         return getQueries\n...\n</pre>\n</blockquote>\n<p>That works for our current example.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'ophelia'}),\n...     queryFactory=flawed_factory))\n['publisher', 'reviewer', 'writer']\n</pre>\n</blockquote>\n<p>However, it won\u2019t work for other similar queries.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getRolesInOrganization('abe', orgs['Zookd Nbd'])\n['publisher', 'reviewer', 'user manager', 'writer']\n&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'abe'}),\n...     queryFactory=flawed_factory))\n[]\n</pre>\n</blockquote>\n<p>oops.</p>\n<p>The flawed_factory is actually a useful pattern for more typical relation\ntraversal.  It goes from relation to relation to relation, and ophelia has\nconnected relations all the way to the top.  However, abe only has them at\nthe top, so nothing is traversed.</p>\n<p>Instead, we can make a query factory that modifies the initial query.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def factory2(query, catalog):\n...     if (len(query) == 2 and\n...         'organization' in query and\n...         'principal_id' in query):\n...         def getQueries(relchain):\n...             if not relchain:\n...                 res = BTrees.family32.OO.Bucket(query)\n...                 org_id = query['organization']\n...                 if org_id is not None:\n...                     res['organization'] = zc.relation.catalog.any(\n...                         org_id,\n...                         *catalog.findRelationTokens({'part': org_id}))\n...                 yield res\n...         return getQueries\n...\n</pre>\n<pre>&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'ophelia'}),\n...     queryFactory=factory2))\n['publisher', 'reviewer', 'writer']\n</pre>\n<pre>&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'abe'}),\n...     queryFactory=factory2))\n['publisher', 'reviewer', 'user manager', 'writer']\n</pre>\n</blockquote>\n<p>A difference between this and the other approach is that it is essentially\nintransitive: this query factory modifies the initial query, and then does\nnot give further queries.  The catalog currently always stops calling the\nquery factory if the queries do not return any results, so an approach like\nthe flawed_factory simply won\u2019t work for this kind of problem.</p>\n<p>We could add this query factory as another default.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.addDefaultQueryFactory(factory2)\n</pre>\n<pre>&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'ophelia'})))\n['publisher', 'reviewer', 'writer']\n</pre>\n<pre>&gt;&gt;&gt; sorted(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'abe'})))\n['publisher', 'reviewer', 'user manager', 'writer']\n</pre>\n</blockquote>\n<p>The previously installed query factory is still available.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.iterDefaultQueryFactories()) == [factory1, factory2]\nTrue\n</pre>\n<pre>&gt;&gt;&gt; list(catalog.findRelations(\n...     {'part': registry.getId(orgs['Y3L4 Proj'])}))\n...     # doctest: +NORMALIZE_WHITESPACE\n[&lt;Organization instance \"Ynod Devs\"&gt;,\n &lt;Organization instance \"Ynod Corp Management\"&gt;]\n</pre>\n<pre>&gt;&gt;&gt; sorted(catalog.findRelations(\n...     {None: registry.getId(orgs['Ynod Corp Management'])}))\n...     # doctest: +NORMALIZE_WHITESPACE\n[&lt;Organization instance \"Bet Proj\"&gt;, &lt;Organization instance \"Y3L4 Proj\"&gt;,\n &lt;Organization instance \"Ynod Admins\"&gt;,\n &lt;Organization instance \"Ynod Corp Management\"&gt;,\n &lt;Organization instance \"Ynod Devs\"&gt;, &lt;Organization instance \"Ynod SAs\"&gt;,\n &lt;Organization instance \"Ynod Zookd Task Force\"&gt;]\n</pre>\n</blockquote>\n</div>\n<div id=\"search-index-for-query-factory-joins\">\n<h3><a href=\"#id64\" rel=\"nofollow\">Search Index for Query Factory Joins</a></h3>\n<p>Now that we have written a query factory that encapsulates the join, we can\nuse a search index that speeds it up.  We\u2019ve only used transitive search\nindexes so far.  Now we will add an intransitive search index.</p>\n<p>The intransitive search index generally just needs the search value\nnames it should be indexing, optionally the result name (defaulting to\nrelations), and optionally the query factory to be used.</p>\n<p>We need to use two additional options because of the odd join trick we\u2019re\ndoing.  We need to specify what organization and principal_id values need\nto be changed when an object is indexed, and we need to indicate that we\nshould update when organization, principal_id, <em>or</em> parts changes.</p>\n<p><cite>getValueTokens</cite> specifies the values that need to be indexed.  It gets\nthe index, the name for the tokens desired, the token, the catalog that\ngenerated the token change (it may not be the same as the index\u2019s\ncatalog, the source dictionary that contains a dictionary of the values\nthat will be used for tokens if you do not override them, a dict of the\nadded values for this token (keys are value names), a dict of the\nremoved values for this token, and whether the token has been removed.\nThe method can return None, which will leave the index to its default\nbehavior that should work if no query factory is used; or an iterable of\nvalues.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def getValueTokens(index, name, token, catalog, source,\n...                    additions, removals, removed):\n...     if name == 'organization':\n...         orgs = source.get('organization')\n...         if not removed or not orgs:\n...             orgs = index.catalog.getValueTokens(\n...                 'organization', token)\n...             if not orgs:\n...                 orgs = [token]\n...                 orgs.extend(removals.get('part', ()))\n...         orgs = set(orgs)\n...         orgs.update(index.catalog.findValueTokens(\n...             'part',\n...             {None: zc.relation.catalog.Any(\n...                 t for t in orgs if t is not None)}))\n...         return orgs\n...     elif name == 'principal_id':\n...         # we only want custom behavior if this is an organization\n...         if 'principal_id' in source or index.catalog.getValueTokens(\n...             'principal_id', token):\n...             return ''\n...         orgs = set((token,))\n...         orgs.update(index.catalog.findRelationTokens(\n...             {'part': token}))\n...         return set(index.catalog.findValueTokens(\n...             'principal_id', {\n...                 'organization': zc.relation.catalog.Any(orgs)}))\n...\n</pre>\n<pre>&gt;&gt;&gt; index = zc.relation.searchindex.Intransitive(\n...     ('organization', 'principal_id'), 'role_id', factory2,\n...     getValueTokens,\n...     ('organization', 'principal_id', 'part', 'role_id'),\n...     unlimitedDepth=True)\n&gt;&gt;&gt; catalog.addSearchIndex(index)\n</pre>\n<pre>&gt;&gt;&gt; res = catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'ophelia'}))\n&gt;&gt;&gt; list(res)\n['publisher', 'reviewer', 'writer']\n&gt;&gt;&gt; list(res)\n['publisher', 'reviewer', 'writer']\n</pre>\n<pre>&gt;&gt;&gt; res = catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'abe'}))\n&gt;&gt;&gt; list(res)\n['publisher', 'reviewer', 'user manager', 'writer']\n&gt;&gt;&gt; list(res)\n['publisher', 'reviewer', 'user manager', 'writer']\n</pre>\n</blockquote>\n<p><a href=\"#verifyobjectintransitive\" id=\"id20\" rel=\"nofollow\">[19]</a></p>\n<table id=\"verifyobjectintransitive\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id20\" rel=\"nofollow\">[19]</a></td><td><p>The Intransitive search index provides\nISearchIndex and IListener.</p>\n<pre>\n&gt;&gt;&gt; from zope.interface.verify import verifyObject\n&gt;&gt;&gt; import zc.relation.interfaces\n&gt;&gt;&gt; verifyObject(zc.relation.interfaces.ISearchIndex, index)\nTrue\n&gt;&gt;&gt; verifyObject(zc.relation.interfaces.IListener, index)\nTrue\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>Now we can change and remove relations\u2013both organizations and roles\u2013and\nhave the index maintain correct state.  Given the current state of\norganizations\u2013</p>\n<pre>        Ynod Corp Mangement                 Zookd Corp Management\n         /      |      \\                       /      |      \\\n  Ynod Devs  Ynod SAs  Ynod Admins  Zookd Admins   Zookd SAs  Zookd Devs\n    /      \\              \\                 /                /         \\\nY3L4 Proj  Bet Proj      Ynod Zookd Task Force      Zookd hOgnmd     Zookd Nbd\n</pre>\n<p>\u2013first we will move Ynod Devs to beneath Zookd Devs, and back out.  This will\nbriefly give abe full privileges to Y3L4 Proj., among others.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n...                   'principal_id': 'abe'})))\n[]\n&gt;&gt;&gt; orgs['Zookd Devs'].parts.insert(registry.getId(orgs['Ynod Devs']))\n1\n&gt;&gt;&gt; catalog.index(orgs['Zookd Devs'])\n&gt;&gt;&gt; res = catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n...                   'principal_id': 'abe'}))\n&gt;&gt;&gt; list(res)\n['publisher', 'reviewer', 'user manager', 'writer']\n&gt;&gt;&gt; list(res)\n['publisher', 'reviewer', 'user manager', 'writer']\n&gt;&gt;&gt; orgs['Zookd Devs'].parts.remove(registry.getId(orgs['Ynod Devs']))\n&gt;&gt;&gt; catalog.index(orgs['Zookd Devs'])\n&gt;&gt;&gt; list(catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n...                   'principal_id': 'abe'})))\n[]\n</pre>\n</blockquote>\n<p>As another example, we will change the roles abe has, and see that it is\npropagated down to Zookd Nbd.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; rels = list(catalog.findRelations(t(\n...     {'principal_id': 'abe',\n...      'organization': orgs['Zookd Corp Management']})))\n&gt;&gt;&gt; len(rels)\n1\n&gt;&gt;&gt; rels[0].role_ids.remove('reviewer')\n&gt;&gt;&gt; catalog.index(rels[0])\n</pre>\n<pre>&gt;&gt;&gt; res = catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'abe'}))\n&gt;&gt;&gt; list(res)\n['publisher', 'user manager', 'writer']\n&gt;&gt;&gt; list(res)\n['publisher', 'user manager', 'writer']\n</pre>\n</blockquote>\n<p>Note that search index order matters.  In our case, our intransitive search\nindex is relying on our transitive index, so the transitive index needs to\ncome first.  You want transitive relation indexes before name.  Right now,\nyou are in charge of this order: it will be difficult to come up with a\nreliable algorithm for guessing this.</p>\n</div>\n<div id=\"listeners-catalog-administration-and-joining-across-relation-catalogs\">\n<h3><a href=\"#id65\" rel=\"nofollow\">Listeners, Catalog Administration, and Joining Across Relation Catalogs</a></h3>\n<p>We\u2019ve done all of our examples so far with a single catalog that indexes\nboth kinds of relations.  What if we want to have two catalogs with\nhomogenous collections of relations?  That can feel cleaner, but it also\nintroduces some new wrinkles.</p>\n<p>Let\u2019s use our current catalog for organizations, removing the extra\ninformation; and create a new one for roles.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; role_catalog = root['role_catalog'] = catalog.copy()\n&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; org_catalog = catalog\n&gt;&gt;&gt; del catalog\n</pre>\n</blockquote>\n<p>We\u2019ll need a slightly different query factory and a slightly different\nsearch index <cite>getValueTokens</cite> function.  We\u2019ll write those, then modify the\nconfiguration of our two catalogs for the new world.</p>\n<p>The transitive factory we write here is for the role catalog.  It needs\naccess to the organzation catalog.  We could do this a variety of\nways\u2013relying on a utility, or finding the catalog from context.  We will\nmake the role_catalog have a .org_catalog attribute, and rely on that.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; role_catalog.org_catalog = org_catalog\n&gt;&gt;&gt; def factory3(query, catalog):\n...     if (len(query) == 2 and\n...         'organization' in query and\n...         'principal_id' in query):\n...         def getQueries(relchain):\n...             if not relchain:\n...                 res = BTrees.family32.OO.Bucket(query)\n...                 org_id = query['organization']\n...                 if org_id is not None:\n...                     res['organization'] = zc.relation.catalog.any(\n...                         org_id,\n...                         *catalog.org_catalog.findRelationTokens(\n...                             {'part': org_id}))\n...                 yield res\n...         return getQueries\n...\n</pre>\n<pre>&gt;&gt;&gt; def getValueTokens2(index, name, token, catalog, source,\n...                    additions, removals, removed):\n...     is_role_catalog = catalog is index.catalog # role_catalog\n...     if name == 'organization':\n...         if is_role_catalog:\n...             orgs = set(source.get('organization') or\n...                        index.catalog.getValueTokens(\n...                         'organization', token) or ())\n...         else:\n...             orgs = set((token,))\n...             orgs.update(removals.get('part', ()))\n...         orgs.update(index.catalog.org_catalog.findValueTokens(\n...             'part',\n...             {None: zc.relation.catalog.Any(\n...                 t for t in orgs if t is not None)}))\n...         return orgs\n...     elif name == 'principal_id':\n...         # we only want custom behavior if this is an organization\n...         if not is_role_catalog:\n...             orgs = set((token,))\n...             orgs.update(index.catalog.org_catalog.findRelationTokens(\n...                 {'part': token}))\n...             return set(index.catalog.findValueTokens(\n...                 'principal_id', {\n...                     'organization': zc.relation.catalog.Any(orgs)}))\n...     return ''\n</pre>\n</blockquote>\n<p>If you are following along in the code and comparing to the originals, you may\nsee that this approach is a bit cleaner than the one when the relations were\nin the same catalog.</p>\n<p>Now we will fix up the the organization catalog <a href=\"#compare-copy\" id=\"id21\" rel=\"nofollow\">[20]</a>.</p>\n<table id=\"compare-copy\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id21\" rel=\"nofollow\">[20]</a></td><td><p>Before we modify them, let\u2019s look at the copy we made.\nThe copy should currently behave identically to the original.</p>\n<pre>\n&gt;&gt;&gt; len(org_catalog)\n38\n&gt;&gt;&gt; len(role_catalog)\n38\n&gt;&gt;&gt; indexed = list(org_catalog)\n&gt;&gt;&gt; len(indexed)\n38\n&gt;&gt;&gt; orgs['Zookd Devs'] in indexed\nTrue\n&gt;&gt;&gt; for r in indexed:\n...     if r not in role_catalog:\n...         print('bad')\n...         break\n... else:\n...     print('good')\n...\ngood\n&gt;&gt;&gt; org_names = set(dir(org_catalog))\n&gt;&gt;&gt; role_names = set(dir(role_catalog))\n&gt;&gt;&gt; sorted(org_names - role_names)\n[]\n&gt;&gt;&gt; sorted(role_names - org_names)\n['org_catalog']\n</pre>\n<pre>\n&gt;&gt;&gt; def checkYnodDevsParts(catalog):\n...     res = sorted(catalog.findRelations(t({None: orgs['Ynod Devs']})))\n...     if res != [\n...         orgs[\"Bet Proj\"], orgs[\"Y3L4 Proj\"], orgs[\"Ynod Devs\"]]:\n...         print(\"bad\", res)\n...\n&gt;&gt;&gt; checkYnodDevsParts(org_catalog)\n&gt;&gt;&gt; checkYnodDevsParts(role_catalog)\n</pre>\n<pre>\n&gt;&gt;&gt; def checkOpheliaRoles(catalog):\n...     res = sorted(catalog.findRelations({'principal_id': 'ophelia'}))\n...     if repr(res) != (\n...         \"[&lt;Roles instance (ophelia has publisher in Zookd Nbd)&gt;, \" +\n...         \"&lt;Roles instance (ophelia has reviewer in Zookd Devs)&gt;, \" +\n...         \"&lt;Roles instance (ophelia has writer in \" +\n...         \"Zookd Corp Management)&gt;]\"):\n...         print(\"bad\", res)\n...\n&gt;&gt;&gt; checkOpheliaRoles(org_catalog)\n&gt;&gt;&gt; checkOpheliaRoles(role_catalog)\n</pre>\n<pre>\n&gt;&gt;&gt; def checkOpheliaWriterOrganizations(catalog):\n...     res = sorted(catalog.findRelations({None: zc.relation.catalog.Any(\n...         catalog.findValueTokens(\n...             'organization', {'principal_id': 'ophelia',\n...                              'role_id': 'writer'}))}))\n...     if repr(res) != (\n...         '[&lt;Organization instance \"Ynod Zookd Task Force\"&gt;, ' +\n...         '&lt;Organization instance \"Zookd Admins\"&gt;, ' +\n...         '&lt;Organization instance \"Zookd Corp Management\"&gt;, ' +\n...         '&lt;Organization instance \"Zookd Devs\"&gt;, ' +\n...         '&lt;Organization instance \"Zookd Nbd\"&gt;, ' +\n...         '&lt;Organization instance \"Zookd SAs\"&gt;, ' +\n...         '&lt;Organization instance \"Zookd hOgnmd\"&gt;]'):\n...         print(\"bad\", res)\n...\n&gt;&gt;&gt; checkOpheliaWriterOrganizations(org_catalog)\n&gt;&gt;&gt; checkOpheliaWriterOrganizations(role_catalog)\n</pre>\n<pre>\n&gt;&gt;&gt; def checkPrincipalsWithRolesInZookdDevs(catalog):\n...     org_id = registry.getId(orgs['Zookd Devs'])\n...     res = sorted(catalog.findValueTokens(\n...         'principal_id',\n...         {'organization': zc.relation.catalog.any(\n...             org_id, *catalog.findRelationTokens({'part': org_id}))}))\n...     if res != ['abe', 'ignas', 'karyn', 'lettie', 'nancy', 'ophelia']:\n...         print(\"bad\", res)\n...\n&gt;&gt;&gt; checkPrincipalsWithRolesInZookdDevs(org_catalog)\n&gt;&gt;&gt; checkPrincipalsWithRolesInZookdDevs(role_catalog)\n</pre>\n<pre>\n&gt;&gt;&gt; def checkOpheliaRolesInZookdNbd(catalog):\n...     res = sorted(catalog.findValueTokens(\n...         'role_id', {\n...             'organization': registry.getId(orgs['Zookd Nbd']),\n...             'principal_id': 'ophelia'}))\n...     if res != ['publisher', 'reviewer', 'writer']:\n...         print(\"bad\", res)\n...\n&gt;&gt;&gt; checkOpheliaRolesInZookdNbd(org_catalog)\n&gt;&gt;&gt; checkOpheliaRolesInZookdNbd(role_catalog)\n</pre>\n<pre>\n&gt;&gt;&gt; def checkAbeRolesInZookdNbd(catalog):\n...     res = sorted(catalog.findValueTokens(\n...         'role_id', {\n...             'organization': registry.getId(orgs['Zookd Nbd']),\n...             'principal_id': 'abe'}))\n...     if res != ['publisher', 'user manager', 'writer']:\n...         print(\"bad\", res)\n...\n&gt;&gt;&gt; checkAbeRolesInZookdNbd(org_catalog)\n&gt;&gt;&gt; checkAbeRolesInZookdNbd(role_catalog)\n&gt;&gt;&gt; org_catalog.removeDefaultQueryFactory(None) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nLookupError: ('factory not found', None)\n</pre>\n<pre>\n&gt;&gt;&gt; org_catalog.removeValueIndex('organization')\n&gt;&gt;&gt; org_catalog.removeValueIndex('role_id')\n&gt;&gt;&gt; org_catalog.removeValueIndex('principal_id')\n&gt;&gt;&gt; org_catalog.removeDefaultQueryFactory(factory2)\n&gt;&gt;&gt; org_catalog.removeSearchIndex(index)\n&gt;&gt;&gt; org_catalog.clear()\n&gt;&gt;&gt; len(org_catalog)\n0\n&gt;&gt;&gt; for v in orgs.values():\n...     org_catalog.index(v)\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>This also shows using the <cite>removeDefaultQueryFactory</cite> and <cite>removeSearchIndex</cite>\nmethods <a href=\"#removedefaultqueryfactoryexceptions\" id=\"id22\" rel=\"nofollow\">[21]</a>.</p>\n<table id=\"removedefaultqueryfactoryexceptions\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id22\" rel=\"nofollow\">[21]</a></td><td><p>You get errors by removing query\nfactories that are not registered.</p>\n<pre>\n&gt;&gt;&gt; org_catalog.removeDefaultQueryFactory(factory2) # doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nLookupError: ('factory not found', &lt;function factory2 at ...&gt;)\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>Now we will set up the role catalog <a href=\"#copy-unchanged\" id=\"id23\" rel=\"nofollow\">[22]</a>.</p>\n<table id=\"copy-unchanged\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id23\" rel=\"nofollow\">[22]</a></td><td><p>Changes to one copy should not affect the other.  That\nmeans the role_catalog should still work as before.</p>\n<pre>\n&gt;&gt;&gt; len(org_catalog)\n13\n&gt;&gt;&gt; len(list(org_catalog))\n13\n</pre>\n<pre>\n&gt;&gt;&gt; len(role_catalog)\n38\n&gt;&gt;&gt; indexed = list(role_catalog)\n&gt;&gt;&gt; len(indexed)\n38\n&gt;&gt;&gt; orgs['Zookd Devs'] in indexed\nTrue\n&gt;&gt;&gt; orgs['Zookd Devs'] in role_catalog\nTrue\n</pre>\n<pre>\n&gt;&gt;&gt; checkYnodDevsParts(role_catalog)\n&gt;&gt;&gt; checkOpheliaRoles(role_catalog)\n&gt;&gt;&gt; checkOpheliaWriterOrganizations(role_catalog)\n&gt;&gt;&gt; checkPrincipalsWithRolesInZookdDevs(role_catalog)\n&gt;&gt;&gt; checkOpheliaRolesInZookdNbd(role_catalog)\n&gt;&gt;&gt; checkAbeRolesInZookdNbd(role_catalog)\n</pre>\n<pre>\n&gt;&gt;&gt; role_catalog.removeValueIndex('part')\n&gt;&gt;&gt; for ix in list(role_catalog.iterSearchIndexes()):\n...     role_catalog.removeSearchIndex(ix)\n...\n&gt;&gt;&gt; role_catalog.removeDefaultQueryFactory(factory1)\n&gt;&gt;&gt; role_catalog.removeDefaultQueryFactory(factory2)\n&gt;&gt;&gt; role_catalog.addDefaultQueryFactory(factory3)\n&gt;&gt;&gt; root['index2'] = index2 = zc.relation.searchindex.Intransitive(\n...     ('organization', 'principal_id'), 'role_id', factory3,\n...     getValueTokens2,\n...     ('organization', 'principal_id', 'part', 'role_id'),\n...     unlimitedDepth=True)\n&gt;&gt;&gt; role_catalog.addSearchIndex(index2)\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>The new role_catalog index needs to be updated from the org_catalog.\nWe\u2019ll set that up using listeners, a new concept.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; org_catalog.addListener(index2)\n&gt;&gt;&gt; list(org_catalog.iterListeners()) == [index2]\nTrue\n</pre>\n</blockquote>\n<p>Now the role_catalog should be able to answer the same questions as the old\nsingle catalog approach.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; t = role_catalog.tokenizeQuery\n&gt;&gt;&gt; list(role_catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'abe'})))\n['publisher', 'user manager', 'writer']\n</pre>\n<pre>&gt;&gt;&gt; list(role_catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'ophelia'})))\n['publisher', 'reviewer', 'writer']\n</pre>\n</blockquote>\n<p>We can also make changes to both catalogs and the search indexes are\nmaintained.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(role_catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n...                   'principal_id': 'abe'})))\n[]\n&gt;&gt;&gt; orgs['Zookd Devs'].parts.insert(registry.getId(orgs['Ynod Devs']))\n1\n&gt;&gt;&gt; org_catalog.index(orgs['Zookd Devs'])\n&gt;&gt;&gt; list(role_catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n...                   'principal_id': 'abe'})))\n['publisher', 'user manager', 'writer']\n&gt;&gt;&gt; orgs['Zookd Devs'].parts.remove(registry.getId(orgs['Ynod Devs']))\n&gt;&gt;&gt; org_catalog.index(orgs['Zookd Devs'])\n&gt;&gt;&gt; list(role_catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Y3L4 Proj'],\n...                   'principal_id': 'abe'})))\n[]\n</pre>\n<pre>&gt;&gt;&gt; rels = list(role_catalog.findRelations(t(\n...     {'principal_id': 'abe',\n...      'organization': orgs['Zookd Corp Management']})))\n&gt;&gt;&gt; len(rels)\n1\n&gt;&gt;&gt; rels[0].role_ids.insert('reviewer')\n1\n&gt;&gt;&gt; role_catalog.index(rels[0])\n</pre>\n<pre>&gt;&gt;&gt; res = role_catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd Nbd'],\n...                   'principal_id': 'abe'}))\n&gt;&gt;&gt; list(res)\n['publisher', 'reviewer', 'user manager', 'writer']\n</pre>\n</blockquote>\n<p>Here we add a new organization.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; orgs['Zookd hOnc'] = org = Organization('Zookd hOnc')\n&gt;&gt;&gt; orgs['Zookd Devs'].parts.insert(registry.getId(org))\n1\n&gt;&gt;&gt; org_catalog.index(orgs['Zookd hOnc'])\n&gt;&gt;&gt; org_catalog.index(orgs['Zookd Devs'])\n</pre>\n<pre>&gt;&gt;&gt; list(role_catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd hOnc'],\n...                   'principal_id': 'abe'})))\n['publisher', 'reviewer', 'user manager', 'writer']\n</pre>\n<pre>&gt;&gt;&gt; list(role_catalog.findValueTokens(\n...     'role_id', t({'organization': orgs['Zookd hOnc'],\n...                   'principal_id': 'ophelia'})))\n['reviewer', 'writer']\n</pre>\n</blockquote>\n<p>Now we\u2019ll remove it.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; orgs['Zookd Devs'].parts.remove(registry.getId(org))\n&gt;&gt;&gt; org_catalog.index(orgs['Zookd Devs'])\n&gt;&gt;&gt; org_catalog.unindex(orgs['Zookd hOnc'])\n</pre>\n</blockquote>\n<p>TODO make sure that intransitive copy looks the way we expect</p>\n<p><a href=\"#administrivia\" id=\"id24\" rel=\"nofollow\">[23]</a></p>\n<table id=\"administrivia\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id24\" rel=\"nofollow\">[23]</a></td><td><p>You can add listeners multiple times.</p>\n<pre>\n&gt;&gt;&gt; org_catalog.addListener(index2)\n&gt;&gt;&gt; list(org_catalog.iterListeners()) == [index2, index2]\nTrue\n</pre>\n<p>Now we will remove the listeners, to show we can.</p>\n<pre>\n&gt;&gt;&gt; org_catalog.removeListener(index2)\n&gt;&gt;&gt; org_catalog.removeListener(index2)\n&gt;&gt;&gt; org_catalog.removeListener(index2)\n... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nLookupError: ('listener not found',\n              &lt;zc.relation.searchindex.Intransitive object at ...&gt;)\n&gt;&gt;&gt; org_catalog.removeListener(None)\n... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nLookupError: ('listener not found', None)\n</pre>\n<p>Here\u2019s the same for removing a search index we don\u2019t have</p>\n<pre>\n&gt;&gt;&gt; org_catalog.removeSearchIndex(index2)\n... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nLookupError: ('index not found',\n              &lt;zc.relation.searchindex.Intransitive object at ...&gt;)\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"silliness\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id17\" rel=\"nofollow\">[24]</a></td><td>In \u201c2001: A Space Odyssey\u201d, many people believe the name HAL\nwas chosen because it was ROT25 of IBM\u2026.  I cheat a bit sometimes and\nuse ROT1 because the result sounds better.</td></tr>\n</tbody>\n</table>\n</div>\n</div>\n<div id=\"working-with-search-indexes-zc-relation-catalog-extended-example\">\n<h2><a href=\"#id66\" rel=\"nofollow\">Working with Search Indexes: zc.relation Catalog Extended Example</a></h2>\n<div id=\"introduction\">\n<h3><a href=\"#id67\" rel=\"nofollow\">Introduction</a></h3>\n<p>This document assumes you have read the README.rst document, and want to learn\na bit more by example. In it, we will explore a set of relations that\ndemonstrates most of the aspects of working with search indexes and listeners.\nIt will not explain the topics that the other documents already addressed. It\nalso describes an advanced use case.</p>\n<p>As we have seen in the other documents, the relation catalog supports\nsearch indexes.  These can return the results of any search, as desired.\nOf course, the intent is that you supply an index that optimizes the\nparticular searches it claims.</p>\n<p>The searchindex module supplies a few search indexes, optimizing\nspecified transitive and intransitive searches.  We have seen them working\nin other documents.  We will examine them more in depth in this document.</p>\n<p>Search indexes update themselves by receiving messages via a \u201clistener\u201d\ninterface.  We will also look at how this works.</p>\n<p>The example described in this file examines a use case similar to that in\nthe zc.revision or zc.vault packages: a relation describes a graph of\nother objects.  Therefore, this is our first concrete example of purely\nextrinsic relations.</p>\n<p>Let\u2019s build the example story a bit.  Imagine we have a graph, often a\nhierarchy, of tokens\u2013integers.  Relations specify that a given integer\ntoken relates to other integer tokens, with a containment denotation or\nother meaning.</p>\n<p>The integers may also have relations that specify that they represent an\nobject or objects.</p>\n<p>This allows us to have a graph of objects in which changing one part of the\ngraph does not require changing the rest.  zc.revision and zc.vault thus\nare able to model graphs that can have multiple revisions efficiently and\nwith quite a bit of metadata to support merges.</p>\n<p>Let\u2019s imagine a simple hierarchy.  The relation has a <cite>token</cite> attribute\nand a <cite>children</cite> attribute; children point to tokens. Relations will\nidentify themselves with ids.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import BTrees\n&gt;&gt;&gt; relations = BTrees.family64.IO.BTree()\n&gt;&gt;&gt; relations[99] = None # just to give us a start\n</pre>\n<pre>&gt;&gt;&gt; class Relation(object):\n...     def __init__(self, token, children=()):\n...         self.token = token\n...         self.children = BTrees.family64.IF.TreeSet(children)\n...         self.id = relations.maxKey() + 1\n...         relations[self.id] = self\n...\n</pre>\n<pre>&gt;&gt;&gt; def token(rel, self):\n...     return rel.token\n...\n&gt;&gt;&gt; def children(rel, self):\n...     return rel.children\n...\n&gt;&gt;&gt; def dumpRelation(obj, index, cache):\n...     return obj.id\n...\n&gt;&gt;&gt; def loadRelation(token, index, cache):\n...     return relations[token]\n...\n</pre>\n</blockquote>\n<p>The standard TransposingTransitiveQueriesFactory will be able to handle this\nquite well, so we\u2019ll use that for our index.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation.queryfactory\n&gt;&gt;&gt; factory = zc.relation.queryfactory.TransposingTransitive(\n...     'token', 'children')\n&gt;&gt;&gt; import zc.relation.catalog\n&gt;&gt;&gt; catalog = zc.relation.catalog.Catalog(\n...     dumpRelation, loadRelation, BTrees.family64.IO, BTrees.family64)\n&gt;&gt;&gt; catalog.addValueIndex(token)\n&gt;&gt;&gt; catalog.addValueIndex(children, multiple=True)\n&gt;&gt;&gt; catalog.addDefaultQueryFactory(factory)\n</pre>\n</blockquote>\n<p>Now let\u2019s quickly create a hierarchy and index it.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; for token, children in (\n...     (0, (1, 2)), (1, (3, 4)), (2, (10, 11, 12)), (3, (5, 6)),\n...     (4, (13, 14)), (5, (7, 8, 9)), (6, (15, 16)), (7, (17, 18, 19)),\n...     (8, (20, 21, 22)), (9, (23, 24)), (10, (25, 26)),\n...     (11, (27, 28, 29, 30, 31, 32))):\n...     catalog.index(Relation(token, children))\n...\n</pre>\n</blockquote>\n<p><a href=\"#queryfactory\" id=\"id25\" rel=\"nofollow\">[25]</a> That hierarchy is arbitrary.  Here\u2019s what we have, in terms of tokens\npointing to children:</p>\n<pre>                                 _____________0_____________\n                                /                           \\\n                       ________1_______                ______2____________\n                      /                \\              /          |        \\\n               ______3_____            _4_          10       ____11_____   12\n              /            \\          /   \\         / \\     / /  |  \\ \\ \\\n      _______5_______       6       13     14     25  26  27 28 29 30 31 32\n     /       |       \\     / \\\n   _7_      _8_       9   15 16\n  / | \\    / | \\     / \\\n17 18 19  20 21 22  23 24\n</pre>\n<p>Twelve relations, with tokens 0 through 11, and a total of 33 tokens,\nincluding children.  The ids for the 12 relations are 100 through 111,\ncorresponding with the tokens of 0 through 11.</p>\n<p>Without a transitive search index, we can get all transitive results.\nThe results are iterators.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = catalog.findRelationTokens({'token': 0})\n&gt;&gt;&gt; import six\n&gt;&gt;&gt; next_attr = '__next__' if six.PY3 else 'next'\n&gt;&gt;&gt; getattr(res, next_attr) is None\nFalse\n&gt;&gt;&gt; getattr(res, '__len__', None) is None\nTrue\n&gt;&gt;&gt; sorted(res)\n[100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]\n&gt;&gt;&gt; list(res)\n[]\n</pre>\n<pre>&gt;&gt;&gt; res = catalog.findValueTokens('children', {'token': 0})\n&gt;&gt;&gt; sorted(res) == list(range(1, 33))\nTrue\n&gt;&gt;&gt; list(res)\n[]\n</pre>\n</blockquote>\n<p><a href=\"#findvaluesunindexed\" id=\"id26\" rel=\"nofollow\">[26]</a> <cite>canFind</cite> also can work transitively, and will\nuse transitive search indexes, as we\u2019ll see below.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.canFind({'token': 1}, targetQuery={'children': 23})\nTrue\n&gt;&gt;&gt; catalog.canFind({'token': 2}, targetQuery={'children': 23})\nFalse\n&gt;&gt;&gt; catalog.canFind({'children': 23}, targetQuery={'token': 1})\nTrue\n&gt;&gt;&gt; catalog.canFind({'children': 23}, targetQuery={'token': 2})\nFalse\n</pre>\n</blockquote>\n<p><cite>findRelationTokenChains</cite> won\u2019t change, but we\u2019ll include it in the\ndiscussion and examples to show that.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = catalog.findRelationTokenChains({'token': 2})\n&gt;&gt;&gt; chains = list(res)\n&gt;&gt;&gt; len(chains)\n3\n&gt;&gt;&gt; len(list(res))\n0\n</pre>\n</blockquote>\n</div>\n<div id=\"transitive-search-indexes\">\n<h3><a href=\"#id68\" rel=\"nofollow\">Transitive Search Indexes</a></h3>\n<p>Now we can add a couple of transitive search index.  We\u2019ll talk about\nthem a bit first.</p>\n<p>There is currently one variety of transitive index, which indexes\nrelation and value searches for the transposing transitive query\nfactory.</p>\n<p>The index can only be used under certain conditions.</p>\n<blockquote>\n<ul>\n<li>The search is not a request for a relation chain.</li>\n<li>It does not specify a maximum depth.</li>\n<li>Filters are not used.</li>\n</ul>\n</blockquote>\n<p>If it is a value search, then specific value indexes cannot be used if a\ntarget filter or target query are used, but the basic relation index can\nstill be used in that case.</p>\n<p>The usage of the search indexes is largely transparent: set them up, and\nthe relation catalog will use them for the same API calls that used more\nbrute force previously.  The only difference from external uses is that\nresults that use an index will usually be a BTree structure, rather than\nan iterator.</p>\n<p>When you add a transitive index for a relation, you must specify the\ntransitive name (or names) of the query, and the same for the reverse.\nThat\u2019s all we\u2019ll do now.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zc.relation.searchindex\n&gt;&gt;&gt; catalog.addSearchIndex(\n...     zc.relation.searchindex.TransposingTransitiveMembership(\n...         'token', 'children', names=('children',)))\n</pre>\n</blockquote>\n<p>Now we should have a search index installed.</p>\n<p>Notice that we went from parent (token) to child: this index is primarily\ndesigned for helping transitive membership searches in a hierarchy. Using it to\nindex parents would incur a lot of write expense for not much win.</p>\n<p>There\u2019s just a bit more you can specify here: static fields for a query\nto do a bit of filtering.  We don\u2019t need any of that for this example.</p>\n<p>Now how does the catalog use this index for searches?  Three basic ways,\ndepending on the kind of search, relations, values, or <cite>canFind</cite>.\nBefore we start looking into the internals, let\u2019s verify that we\u2019re getting\nwhat we expect: correct answers, and not iterators, but BTree structures.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = catalog.findRelationTokens({'token': 0})\n&gt;&gt;&gt; list(res)\n[100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]\n&gt;&gt;&gt; list(res)\n[100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111]\n</pre>\n<pre>&gt;&gt;&gt; res = catalog.findValueTokens('children', {'token': 0})\n&gt;&gt;&gt; list(res) == list(range(1, 33))\nTrue\n&gt;&gt;&gt; list(res) == list(range(1, 33))\nTrue\n</pre>\n<pre>&gt;&gt;&gt; catalog.canFind({'token': 1}, targetQuery={'children': 23})\nTrue\n&gt;&gt;&gt; catalog.canFind({'token': 2}, targetQuery={'children': 23})\nFalse\n</pre>\n</blockquote>\n<p><a href=\"#findvaluesindexed\" id=\"id27\" rel=\"nofollow\">[27]</a> Note that the last two <cite>canFind</cite> examples from\nwhen we went through these examples without an index do not use the\nindex, so we don\u2019t show them here: they look the wrong direction for\nthis index.</p>\n<p>So how do these results happen?</p>\n<p>The first, <cite>findRelationTokens</cite>, and the last, <cite>canFind</cite>, are the most\nstraightforward.  The index finds all relations that match the given\nquery, intransitively. Then for each relation, it looks up the indexed\ntransitive results for that token.  The end result is the union of all\nindexed results found from the intransitive search.  <cite>canFind</cite> simply\ncasts the result into a boolean.</p>\n<p><cite>findValueTokens</cite> is the same story as above with only one more step.  After\nthe union of relations is calculated, the method returns the union of the\nsets of the requested value for all found relations.</p>\n<p>It will maintain itself when relations are reindexed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; rel = list(catalog.findRelations({'token': 11}))[0]\n&gt;&gt;&gt; for t in (27, 28, 29, 30, 31):\n...     rel.children.remove(t)\n...\n&gt;&gt;&gt; catalog.index(rel)\n</pre>\n<pre>&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 0})\n... # doctest: +NORMALIZE_WHITESPACE\nLFSet([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n       20, 21, 22, 23, 24, 25, 26, 32])\n&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 2})\nLFSet([10, 11, 12, 25, 26, 32])\n&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 11})\nLFSet([32])\n</pre>\n<pre>&gt;&gt;&gt; rel.children.remove(32)\n&gt;&gt;&gt; catalog.index(rel)\n</pre>\n<pre>&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 0})\n... # doctest: +NORMALIZE_WHITESPACE\nLFSet([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n       20, 21, 22, 23, 24, 25, 26])\n&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 2})\nLFSet([10, 11, 12, 25, 26])\n&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 11})\nLFSet([])\n</pre>\n<pre>&gt;&gt;&gt; rel.children.insert(27)\n1\n&gt;&gt;&gt; catalog.index(rel)\n</pre>\n<pre>&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 0})\n... # doctest: +NORMALIZE_WHITESPACE\nLFSet([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n       20, 21, 22, 23, 24, 25, 26, 27])\n&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 2})\nLFSet([10, 11, 12, 25, 26, 27])\n&gt;&gt;&gt; catalog.findValueTokens('children', {'token': 11})\nLFSet([27])\n</pre>\n</blockquote>\n<p>When the index is copied, the search index is copied.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; new = catalog.copy()\n&gt;&gt;&gt; res = list(new.iterSearchIndexes())\n&gt;&gt;&gt; len(res)\n1\n&gt;&gt;&gt; new_index = res[0]\n&gt;&gt;&gt; res = list(catalog.iterSearchIndexes())\n&gt;&gt;&gt; len(res)\n1\n&gt;&gt;&gt; old_index = res[0]\n&gt;&gt;&gt; new_index is old_index\nFalse\n&gt;&gt;&gt; old_index.index is new_index.index\nFalse\n&gt;&gt;&gt; list(old_index.index.keys()) == list(new_index.index.keys())\nTrue\n&gt;&gt;&gt; from __future__ import print_function\n&gt;&gt;&gt; for key, value in old_index.index.items():\n...     v = new_index.index[key]\n...     if v is value or list(v) != list(value):\n...         print('oops', key, value, v)\n...         break\n... else:\n...     print('good')\n...\ngood\n&gt;&gt;&gt; old_index.names is not new_index.names\nTrue\n&gt;&gt;&gt; list(old_index.names) == list(new_index.names)\nTrue\n&gt;&gt;&gt; for name, old_ix in old_index.names.items():\n...     new_ix = new_index.names[name]\n...     if new_ix is old_ix or list(new_ix.keys()) != list(old_ix.keys()):\n...         print('oops')\n...         break\n...     for key, value in old_ix.items():\n...         v = new_ix[key]\n...         if v is value or list(v) != list(value):\n...             print('oops', name, key, value, v)\n...             break\n...     else:\n...         continue\n...     break\n... else:\n...     print('good')\n...\ngood\n</pre>\n</blockquote>\n</div>\n<div id=\"helpers\">\n<h3><a href=\"#id69\" rel=\"nofollow\">Helpers</a></h3>\n<p>When writing search indexes and query factories, you often want complete\naccess to relation catalog data.  We\u2019ve seen a number of these tools already:</p>\n<ul>\n<li><p><cite>getRelationModuleTools</cite> gets a dictionary of the BTree tools needed to\nwork with relations.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(catalog.getRelationModuleTools().keys())\n... # doctest: +NORMALIZE_WHITESPACE\n['BTree', 'Bucket', 'Set', 'TreeSet', 'difference', 'dump',\n 'intersection', 'load', 'multiunion', 'union']\n</pre>\n<p>\u2018multiunion\u2019 is only there if the BTree is an I* or L* module.\nUse the zc.relation.catalog.multiunion helper function to do the\nbest union you can for a given set of tools.</p>\n</blockquote>\n</li>\n<li><p><cite>getValueModuleTools</cite> does the same for indexed values.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tools = set(('BTree', 'Bucket', 'Set', 'TreeSet', 'difference',\n...              'dump', 'intersection', 'load', 'multiunion', 'union'))\n&gt;&gt;&gt; tools.difference(catalog.getValueModuleTools('children').keys()) == set()\nTrue\n</pre>\n<pre>&gt;&gt;&gt; tools.difference(catalog.getValueModuleTools('token').keys()) == set()\nTrue\n</pre>\n</blockquote>\n</li>\n<li><p><cite>getRelationTokens</cite> can return all of the tokens in the catalog.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(catalog.getRelationTokens()) == len(catalog)\nTrue\n</pre>\n<p>This also happens to be equivalent to <cite>findRelationTokens</cite> with an empty\nquery.</p>\n<pre>&gt;&gt;&gt; catalog.getRelationTokens() is catalog.findRelationTokens({})\nTrue\n</pre>\n<p>It also can return all the tokens that match a given query, or None if\nthere are no matches.</p>\n<pre>&gt;&gt;&gt; catalog.getRelationTokens({'token': 0}) # doctest: +ELLIPSIS\n&lt;BTrees.LOBTree.LOTreeSet object at ...&gt;\n&gt;&gt;&gt; list(catalog.getRelationTokens({'token': 0}))\n[100]\n</pre>\n<p>This also happens to be equivalent to <cite>findRelationTokens</cite> with a query,\na maxDepth of 1, and no other arguments.</p>\n<pre>&gt;&gt;&gt; catalog.findRelationTokens({'token': 0}, maxDepth=1) is (\n...     catalog.getRelationTokens({'token': 0}))\nTrue\n</pre>\n<p>Except that if there are no matches, <cite>findRelationTokens</cite> returns an empty\nset (so it <em>always</em> returns an iterable).</p>\n<pre>&gt;&gt;&gt; catalog.findRelationTokens({'token': 50}, maxDepth=1)\nLOSet([])\n&gt;&gt;&gt; print(catalog.getRelationTokens({'token': 50}))\nNone\n</pre>\n</blockquote>\n</li>\n<li><dl>\n<dt><cite>getValueTokens</cite> can return all of the tokens for a given value name in</dt>\n<dd><p>the catalog.</p>\n<pre>&gt;&gt;&gt; list(catalog.getValueTokens('token')) == list(range(12))\nTrue\n</pre>\n<p>This is identical to catalog.findValueTokens with a name only (or with\nan empty query, and a maxDepth of 1).</p>\n<pre>&gt;&gt;&gt; list(catalog.findValueTokens('token')) == list(range(12))\nTrue\n&gt;&gt;&gt; catalog.findValueTokens('token') is catalog.getValueTokens('token')\nTrue\n</pre>\n<p>It can also return the values for a given token.</p>\n<pre>&gt;&gt;&gt; list(catalog.getValueTokens('children', 100))\n[1, 2]\n</pre>\n<p>This is identical to catalog.findValueTokens with a name and a query of\n{None: token}.</p>\n<pre>&gt;&gt;&gt; list(catalog.findValueTokens('children', {None: 100}))\n[1, 2]\n&gt;&gt;&gt; catalog.getValueTokens('children', 100) is (\n...     catalog.findValueTokens('children', {None: 100}))\nTrue\n</pre>\n<p>Except that if there are no matches, <cite>findValueTokens</cite> returns an empty\nset (so it <em>always</em> returns an iterable); while getValueTokens will\nreturn None if the relation has no values (or the relation is unknown).</p>\n<pre>&gt;&gt;&gt; catalog.findValueTokens('children', {None: 50}, maxDepth=1)\nLFSet([])\n&gt;&gt;&gt; print(catalog.getValueTokens('children', 50))\nNone\n</pre>\n<pre>&gt;&gt;&gt; rel.children.remove(27)\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; catalog.findValueTokens('children', {None: rel.id}, maxDepth=1)\nLFSet([])\n&gt;&gt;&gt; print(catalog.getValueTokens('children', rel.id))\nNone\n</pre>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><cite>yieldRelationTokenChains</cite> is a search workhorse for searches that use a</dt>\n<dd><p>query factory.  TODO: describe.</p>\n</dd>\n</dl>\n</li>\n</ul>\n<table id=\"queryfactory\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id25\" rel=\"nofollow\">[25]</a></td><td><p>The query factory knows when it is not needed\u2013not only\nwhen neither of its names are used, but also when both of its names are\nused.</p>\n<pre>\n&gt;&gt;&gt; list(catalog.findRelationTokens({'token': 0, 'children': 1}))\n[100]\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"findvaluesunindexed\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id26\" rel=\"nofollow\">[26]</a></td><td><p>When values are the same as their tokens,\n<cite>findValues</cite> returns the same result as <cite>findValueTokens</cite>.  Here\nwe see this without indexes.</p>\n<pre>\n&gt;&gt;&gt; list(catalog.findValueTokens('children', {'token': 0})) == list(\n...     catalog.findValues('children', {'token': 0}))\nTrue\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"findvaluesindexed\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id27\" rel=\"nofollow\">[27]</a></td><td><p>Again, when values are the same as their tokens,\n<cite>findValues</cite> returns the same result as <cite>findValueTokens</cite>.  Here\nwe see this with indexes.</p>\n<pre>\n&gt;&gt;&gt; list(catalog.findValueTokens('children', {'token': 0})) == list(\n...     catalog.findValues('children', {'token': 0}))\nTrue\n</pre>\n</td></tr>\n</tbody>\n</table>\n</div>\n<div id=\"optimizing-relation-catalog-use\">\n<h3><a href=\"#id70\" rel=\"nofollow\">Optimizing Relation Catalog Use</a></h3>\n<p>There are several best practices and optimization opportunities in regards to\nthe catalog.</p>\n<ul>\n<li>Use integer-keyed BTree sets when possible.  They can use the BTrees\u2019\n<cite>multiunion</cite> for a speed boost.  Integers\u2019 __cmp__ is reliable, and in C.</li>\n<li>Never use persistent objects as keys.  They will cause a database load every\ntime you need to look at them, they take up memory and object caches, and\nthey (as of this writing) disable conflict resolution.  Intids (or similar)\nare your best bet for representing objects, and some other immutable such as\nstrings are the next-best bet, and zope.app.keyreferences (or similar) are\nafter that.</li>\n<li>Use multiple-token values in your queries when possible, especially in your\ntransitive query factories.</li>\n<li>Use the cache when you are loading and dumping tokens, and in your\ntransitive query factories.</li>\n<li>When possible, don\u2019t load or dump tokens (the values themselves may be used\nas tokens).  This is especially important when you have multiple tokens:\nstore them in a BTree structure in the same module as the zc.relation module\nfor the value.</li>\n</ul>\n<p>For some operations, particularly with hundreds or thousands of members in a\nsingle relation value, some of these optimizations can speed up some\ncommon-case reindexing work by around 100 times.</p>\n<p>The easiest (and perhaps least useful) optimization is that all dump\ncalls and all load calls generated by a single operation share a cache\ndictionary per call type (dump/load), per indexed relation value.\nTherefore, for instance, we could stash an intids utility, so that we\nonly had to do a utility lookup once, and thereafter it was only a\nsingle dictionary lookup. This is what the default <cite>generateToken</cite> and\n<cite>resolveToken</cite> functions in zc.relationship\u2019s index.py do: look at them\nfor an example.</p>\n<p>A further optimization is to not load or dump tokens at all, but use values\nthat may be tokens.  This will be particularly useful if the tokens have\n__cmp__ (or equivalent) in C, such as built-in types like ints.  To specify\nthis behavior, you create an index with the \u2018load\u2019 and \u2018dump\u2019 values for the\nindexed attribute descriptions explicitly set to None.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; class IRelation(zope.interface.Interface):\n...     subjects = zope.interface.Attribute(\n...         'The sources of the relation; the subject of the sentence')\n...     relationtype = zope.interface.Attribute(\n...         '''unicode: the single relation type of this relation;\n...         usually contains the verb of the sentence.''')\n...     objects = zope.interface.Attribute(\n...         '''the targets of the relation; usually a direct or\n...         indirect object in the sentence''')\n...\n</pre>\n<pre>&gt;&gt;&gt; import BTrees\n&gt;&gt;&gt; relations = BTrees.family32.IO.BTree()\n&gt;&gt;&gt; relations[99] = None # just to give us a start\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IRelation)\n... class Relation(object):\n...\n...     def __init__(self, subjects, relationtype, objects):\n...         self.subjects = subjects\n...         assert relationtype in relTypes\n...         self.relationtype = relationtype\n...         self.objects = objects\n...         self.id = relations.maxKey() + 1\n...         relations[self.id] = self\n...     def __repr__(self):\n...         return '&lt;%r %s %r&gt;' % (\n...             self.subjects, self.relationtype, self.objects)\n</pre>\n<pre>&gt;&gt;&gt; def token(rel, self):\n...     return rel.token\n...\n&gt;&gt;&gt; def children(rel, self):\n...     return rel.children\n...\n&gt;&gt;&gt; def dumpRelation(obj, index, cache):\n...     return obj.id\n...\n&gt;&gt;&gt; def loadRelation(token, index, cache):\n...     return relations[token]\n...\n</pre>\n<pre>&gt;&gt;&gt; relTypes = ['has the role of']\n&gt;&gt;&gt; def relTypeDump(obj, index, cache):\n...     assert obj in relTypes, 'unknown relationtype'\n...     return obj\n...\n&gt;&gt;&gt; def relTypeLoad(token, index, cache):\n...     assert token in relTypes, 'unknown relationtype'\n...     return token\n...\n</pre>\n<pre>&gt;&gt;&gt; import zc.relation.catalog\n&gt;&gt;&gt; catalog = zc.relation.catalog.Catalog(\n...     dumpRelation, loadRelation)\n&gt;&gt;&gt; catalog.addValueIndex(IRelation['subjects'], multiple=True)\n&gt;&gt;&gt; catalog.addValueIndex(\n...     IRelation['relationtype'], relTypeDump, relTypeLoad,\n...     BTrees.family32.OI, name='reltype')\n&gt;&gt;&gt; catalog.addValueIndex(IRelation['objects'], multiple=True)\n&gt;&gt;&gt; import zc.relation.queryfactory\n&gt;&gt;&gt; factory = zc.relation.queryfactory.TransposingTransitive(\n...     'subjects', 'objects')\n&gt;&gt;&gt; catalog.addDefaultQueryFactory(factory)\n</pre>\n<pre>&gt;&gt;&gt; rel = Relation((1,), 'has the role of', (2,))\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 1}))\n[2]\n</pre>\n</blockquote>\n<p>If you have single relations that relate hundreds or thousands of\nobjects, it can be a huge win if the value is a \u2018multiple\u2019 of the same\ntype as the stored BTree for the given attribute.  The default BTree\nfamily for attributes is IFBTree; IOBTree is also a good choice, and may\nbe preferrable for some applications.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.unindex(rel)\n&gt;&gt;&gt; rel = Relation(\n...     BTrees.family32.IF.TreeSet((1,)), 'has the role of',\n...     BTrees.family32.IF.TreeSet())\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 1}))\n[]\n&gt;&gt;&gt; list(catalog.findValueTokens('subjects', {'objects': None}))\n[1]\n</pre>\n</blockquote>\n<p>Reindexing is where some of the big improvements can happen.  The following\ngyrations exercise the optimization code.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; rel.objects.insert(2)\n1\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 1}))\n[2]\n&gt;&gt;&gt; rel.subjects = BTrees.family32.IF.TreeSet((3,4,5))\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 3}))\n[2]\n</pre>\n<pre>&gt;&gt;&gt; rel.subjects.insert(6)\n1\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 6}))\n[2]\n</pre>\n<pre>&gt;&gt;&gt; rel.subjects.update(range(100, 200))\n100\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 100}))\n[2]\n</pre>\n<pre>&gt;&gt;&gt; rel.subjects = BTrees.family32.IF.TreeSet((3,4,5,6))\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 3}))\n[2]\n</pre>\n<pre>&gt;&gt;&gt; rel.subjects = BTrees.family32.IF.TreeSet(())\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 3}))\n[]\n</pre>\n<pre>&gt;&gt;&gt; rel.subjects = BTrees.family32.IF.TreeSet((3,4,5))\n&gt;&gt;&gt; catalog.index(rel)\n&gt;&gt;&gt; list(catalog.findValueTokens('objects', {'subjects': 3}))\n[2]\n</pre>\n</blockquote>\n<p>tokenizeValues and resolveValueTokens work correctly without loaders and\ndumpers\u2013that is, they do nothing.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; catalog.tokenizeValues((3,4,5), 'subjects')\n(3, 4, 5)\n&gt;&gt;&gt; catalog.resolveValueTokens((3,4,5), 'subjects')\n(3, 4, 5)\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id71\" rel=\"nofollow\">Changes</a></h2>\n<div id=\"post2-2018-06-18\">\n<h3><a href=\"#id72\" rel=\"nofollow\">1.1.post2 (2018-06-18)</a></h3>\n<ul>\n<li>Another attempt to fix PyPI page by using correct expected metadata syntax.</li>\n</ul>\n</div>\n<div id=\"post1-2018-06-18\">\n<h3><a href=\"#id73\" rel=\"nofollow\">1.1.post1 (2018-06-18)</a></h3>\n<ul>\n<li>Fix PyPI page by using correct ReST syntax.</li>\n</ul>\n</div>\n<div id=\"id28\">\n<h3><a href=\"#id74\" rel=\"nofollow\">1.1 (2018-06-15)</a></h3>\n<ul>\n<li>Add support for Python 3.5 and 3.6.</li>\n</ul>\n</div>\n<div id=\"id29\">\n<h3><a href=\"#id75\" rel=\"nofollow\">1.0 (2008-04-23)</a></h3>\n<p>This is the initial release of the zc.relation package.  However, it\nrepresents a refactoring of another package, zc.relationship.  This\npackage contains only a modified version of the relation(ship) index,\nnow called a catalog. The refactored version of zc.relationship index\nrelies on (subclasses) this catalog. zc.relationship also maintains a\nbackwards-compatible subclass.</p>\n<p>This package only relies on the ZODB, zope.interface, and zope.testing\nsoftware, and can be used inside or outside of a standard ZODB database.\nThe software does have to be there, though (the package relies heavily\non the ZODB BTrees package).</p>\n<p>If you would like to switch a legacy zc.relationship index to a\nzc.relation catalog, try this trick in your generations script.\nAssuming the old index is <tt>old</tt>, the following line should create\na new zc.relation catalog with your legacy data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; new = old.copy(zc.relation.Catalog)\n</pre>\n</blockquote>\n<p>Why is the same basic data structure called a catalog now?  Because we\nexposed the ability to mutate the data structure, and what you are really\nadding and removing are indexes.  It didn\u2019t make sense to put an index in\nan index, but it does make sense to put an index in a catalog.  Thus, a\nname change was born.</p>\n<p>The catalog in this package has several incompatibilities from the earlier\nzc.relationship index, and many new features.  The zc.relationship package\nmaintains a backwards-compatible subclass.  The following discussion\ncompares the zc.relation catalog with the zc.relationship 1.x index.</p>\n<div id=\"incompatibilities-with-zc-relationship-1-x-index\">\n<h4><a href=\"#id76\" rel=\"nofollow\">Incompatibilities with zc.relationship 1.x index</a></h4>\n<p>The two big changes are that method names now refer to <tt>Relation</tt> rather\nthan <tt>Relationship</tt>; and the catalog is instantiated slightly differently\nfrom the index.  A few other changes are worth your attention.  The\nfollowing list attempts to highlight all incompatibilities.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Big incompatibilities:</th></tr>\n<tr><td>\u00a0</td><td><ul>\n<li><tt>findRelationshipTokenSet</tt> and <tt>findValueTokenSet</tt> are renamed, with\nsome slightly different semantics, as <tt>getRelationTokens</tt> and\n<tt>getValueTokens</tt>.  The exact same result as\n<tt>findRelationTokenSet(query)</tt> can be obtained with\n<tt>findRelationTokens(query, 1)</tt> (where 1 is maxDepth).  The same\nresult as <tt>findValueTokenSet(reltoken, name)</tt> can be obtained with\n<tt>findValueTokens(name, {zc.relation.RELATION: reltoken}, 1)</tt>.</li>\n<li><tt>findRelations</tt> replaces <tt>findRelatonships</tt>.  The new method will use\nthe defaultTransitiveQueriesFactory if it is set and maxDepth is not 1.\nIt shares the call signature of <tt>findRelationChains</tt>.</li>\n<li><tt>isLinked</tt> is now <tt>canFind</tt>.</li>\n<li>The catalog instantiation arguments have changed from the old index.<ul>\n<li><tt>load</tt> and <tt>dump</tt> (formerly <tt>loadRel</tt> and <tt>dumpRel</tt>,\nrespectively) are now required arguments for instantiation.</li>\n<li>The only other optional arguments are <tt>btree</tt> (was <tt>relFamily</tt>) and\n<tt>family</tt>. You now specify what elements to index with\n<tt>addValueIndex</tt></li>\n<li>Note also that <tt>addValueIndex</tt> defaults to no load and dump function,\nunlike the old instantiation options.</li>\n</ul>\n</li>\n<li>query factories are different.  See <tt>IQueryFactory</tt> in the interfaces.<ul>\n<li>they first get (query, catalog, cache) and then return a getQueries\ncallable that gets relchains and yields queries; OR None if they\ndon\u2019t match.</li>\n<li>They must also handle an empty relchain.  Typically this should\nreturn the original query, but may also be used to mutate the\noriginal query.</li>\n<li>They are no longer thought of as transitive query factories, but as\ngeneral query mutators.</li>\n</ul>\n</li>\n</ul>\n</td>\n</tr>\n<tr><th>Medium:</th><td><ul>\n<li>The catalog no longer inherits from\nzope.app.container.contained.Contained.</li>\n<li>The index requires ZODB 3.8 or higher.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Small:</th><td><ul>\n<li><tt>deactivateSets</tt> is no longer an instantiation option (it was broken\nbecause of a ZODB bug anyway, as had been described in the\ndocumentation).</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"changes-and-new-features\">\n<h4><a href=\"#id77\" rel=\"nofollow\">Changes and new features</a></h4>\n<ul>\n<li>The catalog now offers the ability to index certain\nsearches.  The indexes must be explicitly instantiated and registered\nyou want to optimize. This can be used when searching for values, when\nsearching for relations, or when determining if two objects are\nlinked.  It cannot be used for relation chains. Requesting an index\nhas the usual trade-offs of greater storage space and slower write\nspeed for faster search speed.  Registering a search index is done\nafter instantiation time; you can iteratate over the current settings\nused, and remove them.  (The code path expects to support legacy\nzc.relationship index instances for all of these APIs.)</li>\n<li>You can now specify new values after the catalog has been created, iterate\nover the settings used, and remove values.</li>\n<li>The catalog has a copy method, to quickly make new copies without actually\nhaving to reindex the relations.</li>\n<li>query arguments can now specify multiple values for a given name by\nusing zc.relation.catalog.any(1, 2, 3, 4) or\nzc.relation.catalog.Any((1, 2, 3, 4)).</li>\n<li>The catalog supports specifying indexed values by passing callables rather\nthan interface elements (which are also still supported).</li>\n<li><tt>findRelations</tt> and new method <tt>findRelationTokens</tt> can find\nrelations transitively and intransitively.  <tt>findRelationTokens</tt>\nwhen used intransitively repeats the legacy zc.relationship index\nbehavior of <tt>findRelationTokenSet</tt>.\n(<tt>findRelationTokenSet</tt> remains in the API, not deprecated, a companion\nto <tt>findValueTokenSet</tt>.)</li>\n<li>in findValues and findValueTokens, <tt>query</tt> argument is now optional.  If\nthe query evaluates to False in a boolean context, all values, or value\ntokens, are returned.  Value tokens are explicitly returned using the\nunderlying BTree storage.  This can then be used directly for other BTree\noperations.</li>\n<li>Completely new docs.  Unfortunately, still really not good enough.</li>\n<li>The package has drastically reduced direct dependecies from zc.relationship:\nit is now more clearly a ZODB tool, with no other Zope dependencies than\nzope.testing and zope.interface.</li>\n<li>Listeners allow objects to listen to messages from the catalog (which can\nbe used directly or, for instance, to fire off events).</li>\n<li>You can search for relations, using a key of zc.relation.RELATION\u2026which is\nreally an alias for None. Sorry. But hey, use the constant! I think it is\nmore readable.</li>\n<li>tokenizeQuery (and resolveQuery) now accept keyword arguments as an\nalternative to a normal dict query.  This can make constructing the query\na bit more attractive (i.e., <tt>query = catalog.tokenizeQuery;\nres = <span class=\"pre\">catalog.findValues('object',</span> query(subject=joe, predicate=OWNS))</tt>).</li>\n</ul>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3972511, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "7e479095954fc6d8f648951434695837", "sha256": "771ee928bce412f4eaeb6ebebb6dbf12ca2ba9dc4d60ad0a0dae0b608b57cdc5"}, "downloads": -1, "filename": "zc.relation-1.0.tar.gz", "has_sig": false, "md5_digest": "7e479095954fc6d8f648951434695837", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 114754, "upload_time": "2008-04-24T01:12:56", "upload_time_iso_8601": "2008-04-24T01:12:56Z", "url": "https://files.pythonhosted.org/packages/bf/31/76b2c1e408136b3e61b5508d254b6ccc26c79b14dc440abe17aae05e3695/zc.relation-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "f3b581153acda8fe4058e626deb1ae98", "sha256": "1d2de09eb5642fed4fd8df89391c2dcb378891fd64c0f1d7477eeb053d6e1757"}, "downloads": -1, "filename": "zc.relation-1.1.tar.gz", "has_sig": false, "md5_digest": "f3b581153acda8fe4058e626deb1ae98", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 154289, "upload_time": "2018-06-15T06:38:19", "upload_time_iso_8601": "2018-06-15T06:38:19.527486Z", "url": "https://files.pythonhosted.org/packages/ec/7e/956002bf9f288a32ec77c9133ccdbb35607e4605d4d137d97072668bbd67/zc.relation-1.1.tar.gz", "yanked": false}], "1.1.post1": [{"comment_text": "", "digests": {"md5": "52f4af8848f45693acf5c66ca9d73f80", "sha256": "77f9fb3d60c6728604042a10a266acdf97e9c1fbe831a5e0d8ba4384b6053bf7"}, "downloads": -1, "filename": "zc.relation-1.1.post1.tar.gz", "has_sig": false, "md5_digest": "52f4af8848f45693acf5c66ca9d73f80", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 153856, "upload_time": "2018-06-18T05:55:03", "upload_time_iso_8601": "2018-06-18T05:55:03.405845Z", "url": "https://files.pythonhosted.org/packages/a4/6c/fe9067c5e43d408f6d94e2b12d62999419e3f55509a03912481191f021c1/zc.relation-1.1.post1.tar.gz", "yanked": false}], "1.1.post2": [{"comment_text": "", "digests": {"md5": "15d3554fb077b5bc0d15ff9e732bf771", "sha256": "57218b4d18e1842eba33b96b53a13004fa2e187bc849887c3150be299e6fc261"}, "downloads": -1, "filename": "zc.relation-1.1.post2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "15d3554fb077b5bc0d15ff9e732bf771", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 154716, "upload_time": "2018-06-18T06:05:31", "upload_time_iso_8601": "2018-06-18T06:05:31.191880Z", "url": "https://files.pythonhosted.org/packages/10/ad/120f09e34e439f3340cc793d3a6f947ffdb06d88c38d2faf17a7b177d2f4/zc.relation-1.1.post2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "deafd867bc219144118e96e3cffc64a4", "sha256": "b1aeb9e97ead0206a210e7f1fe32ae60f43630109e46e2ff40e99294fb892add"}, "downloads": -1, "filename": "zc.relation-1.1.post2.tar.gz", "has_sig": false, "md5_digest": "deafd867bc219144118e96e3cffc64a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 153926, "upload_time": "2018-06-18T06:05:32", "upload_time_iso_8601": "2018-06-18T06:05:32.791942Z", "url": "https://files.pythonhosted.org/packages/96/cd/0eab777ddfa4326d05bd24883ad469488345041b90fd849efa858e14184a/zc.relation-1.1.post2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "15d3554fb077b5bc0d15ff9e732bf771", "sha256": "57218b4d18e1842eba33b96b53a13004fa2e187bc849887c3150be299e6fc261"}, "downloads": -1, "filename": "zc.relation-1.1.post2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "15d3554fb077b5bc0d15ff9e732bf771", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 154716, "upload_time": "2018-06-18T06:05:31", "upload_time_iso_8601": "2018-06-18T06:05:31.191880Z", "url": "https://files.pythonhosted.org/packages/10/ad/120f09e34e439f3340cc793d3a6f947ffdb06d88c38d2faf17a7b177d2f4/zc.relation-1.1.post2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "deafd867bc219144118e96e3cffc64a4", "sha256": "b1aeb9e97ead0206a210e7f1fe32ae60f43630109e46e2ff40e99294fb892add"}, "downloads": -1, "filename": "zc.relation-1.1.post2.tar.gz", "has_sig": false, "md5_digest": "deafd867bc219144118e96e3cffc64a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 153926, "upload_time": "2018-06-18T06:05:32", "upload_time_iso_8601": "2018-06-18T06:05:32.791942Z", "url": "https://files.pythonhosted.org/packages/96/cd/0eab777ddfa4326d05bd24883ad469488345041b90fd849efa858e14184a/zc.relation-1.1.post2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:19:04 2020"}