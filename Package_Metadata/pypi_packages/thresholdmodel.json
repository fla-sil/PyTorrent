{"info": {"author": "Benjamin F. Maier", "author_email": "bfmaier@physik.hu-berlin.de", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 3"], "description": "thresholdmodel\n==============\n\nSimulate the continuous-time threshold model on static networks using\nGillespie's SSA. The networks can be directed and weighted.\n\nInstall\n-------\n\n.. code:: bash\n\n   git clone https://github.com/benmaier/thresholdmodel.git\n   pip install ./thresholdmodel\n\nExample\n-------\n\nSimulate on an ER random graph.\n\n.. code:: python\n\n   import numpy as np\n   import networkx as nx\n   import matplotlib.pyplot as plt\n\n   from thresholdmodel import ThreshModel\n\n   N = 1000\n   k = 10\n\n   thresholds = 0.1\n   initially_activated = np.arange(100)\n\n   G = nx.fast_gnp_random_graph(N, k/(N-1.0))\n\n   Thresh = ThreshModel(G,initially_activated,thresholds)\n   t, a = Thresh.simulate()\n\n   plt.plot(t,a)\n   plt.show()\n\n|trajectory|\n\nAPI\n---\n\nSimulate\n~~~~~~~~\n\nGiven a networkx-Graph object ``G`` (can be a ``networkx.DiGraph``,\ntoo), and values for ``initially_activated`` and ``thresholds``,\nsimulate like this\n\n.. code:: python\n\n   Thresh = ThreshModel(G,initially_activated,thresholds)\n   t, a = Thresh.simulate()\n\n``t`` is a ``numpy.ndarray`` containing the times at which node\nactivations happened. ``a`` is a ``numpy.ndarray`` containing the\nrelative cascade size at the corresponding time in ``t``. Note that the\nwhole process is modeled as a Poisson process such that the time ``t``\nwill be given in units of the node activation rate ``gamma = 1.0``. If\nyou want to simulate for another node activation rate, simply rescale\ntime as ``t /= gamma``.\n\nWhen the simulation is started with the ``save_activated_nodes=True``\nflag, a list of activated nodes per time leap is saved in\n``ThreshModel.activated_nodes``.\n\n.. code:: python\n\n   t, a = Thresh.simulate(save_activated_nodes=True)\n   print(Thresh.activated_nodes)\n\nYou can repeat a simulation with the same initial conditions by simply\ncalling ``Thresh.simulate()`` again, all the necessary things will be\nreset automatically.\n\nSet initially activated nodes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSet nodes 3, 5, and 8 to be activated initially.\n\n.. code:: python\n\n   initially_activated = [3, 5, 8] # this could also be a numpy array\n\nChoose 20% of all nodes randomly to be activated initially. When the\nsimulation is restarted, the same nodes will be chosen as initial\nconditions.\n\n.. code:: python\n\n   initially_activated = 0.2\n\nChoose 35 randomly selected nodes to be activated initially. When the\nsimulation is restarted, the same nodes will be chosen as initial\nconditions.\n\n.. code:: python\n\n   initially_activated = 35\n\nSet thresholds\n~~~~~~~~~~~~~~\n\nActivation thresholds can be set for all nodes\n\n.. code:: python\n\n   thresholds = np.random.rand(G.number_of_nodes()) \n\nNote that thresholds need to lie in the domain ``[0,1]``.\n\nYou can also set a universal threshold\n\n.. code:: python\n\n   thresholds = 0.1\n\nHere, 10% of a node's neighbor's need to be activated in order for the\nnode to become active, too.\n\nDirected networks\n~~~~~~~~~~~~~~~~~\n\nA node will become active if the sufficient number of nodes pointing\n*towards* the node are active. This means that the in-degree will be the\nimportant measure to determine wether a node will become active.\n\nWeighted networks\n~~~~~~~~~~~~~~~~~\n\nIf you want to simulate on a weighted network, provide the ``weight``\nkeyword\n\n.. code:: python\n\n   Thresh = ThreshModel(G,initially_activated,thresholds,weight='weight')\n\nSimilar to the networkx-documentation: *``weight``* (string, optional\n(default=``None``)) - The attribute name to obtain the edge weights.\nE.g.: ``G.edges[0,1]['weight']``.\n\nA focal node will become active when the cumulative edge weights of all\nactivated nodes pointing towards the focal node will reach\n``> threshold*in_degree``.\n\n.. |trajectory| image:: https://github.com/benmaier/thresholdmodel/raw/master/sandbox/cascade_trajectory.png", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/benmaier/thresholdmodel", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "thresholdmodel", "package_url": "https://pypi.org/project/thresholdmodel/", "platform": "", "project_url": "https://pypi.org/project/thresholdmodel/", "project_urls": {"Homepage": "https://github.com/benmaier/thresholdmodel"}, "release_url": "https://pypi.org/project/thresholdmodel/0.0.0/", "requires_dist": null, "requires_python": "", "summary": "Simulate the continuous-time threshold model on static networks.", "version": "0.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Simulate the continuous-time threshold model on static networks using\nGillespie\u2019s SSA. The networks can be directed and weighted.</p>\n<div id=\"install\">\n<h2>Install</h2>\n<pre>git clone https://github.com/benmaier/thresholdmodel.git\npip install ./thresholdmodel\n</pre>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<p>Simulate on an ER random graph.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">networkx</span> <span class=\"k\">as</span> <span class=\"nn\">nx</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">thresholdmodel</span> <span class=\"kn\">import</span> <span class=\"n\">ThreshModel</span>\n\n<span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span>\n<span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n\n<span class=\"n\">thresholds</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>\n<span class=\"n\">initially_activated</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">fast_gnp_random_graph</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">))</span>\n\n<span class=\"n\">Thresh</span> <span class=\"o\">=</span> <span class=\"n\">ThreshModel</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span><span class=\"n\">initially_activated</span><span class=\"p\">,</span><span class=\"n\">thresholds</span><span class=\"p\">)</span>\n<span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">Thresh</span><span class=\"o\">.</span><span class=\"n\">simulate</span><span class=\"p\">()</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"trajectory\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2369183f3beb567e3668e8d78962aaf533939a56/68747470733a2f2f6769746875622e636f6d2f62656e6d616965722f7468726573686f6c646d6f64656c2f7261772f6d61737465722f73616e64626f782f636173636164655f7472616a6563746f72792e706e67\"></p>\n</div>\n<div id=\"api\">\n<h2>API</h2>\n<div id=\"simulate\">\n<h3>Simulate</h3>\n<p>Given a networkx-Graph object <tt>G</tt> (can be a <tt>networkx.DiGraph</tt>,\ntoo), and values for <tt>initially_activated</tt> and <tt>thresholds</tt>,\nsimulate like this</p>\n<pre><span class=\"n\">Thresh</span> <span class=\"o\">=</span> <span class=\"n\">ThreshModel</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span><span class=\"n\">initially_activated</span><span class=\"p\">,</span><span class=\"n\">thresholds</span><span class=\"p\">)</span>\n<span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">Thresh</span><span class=\"o\">.</span><span class=\"n\">simulate</span><span class=\"p\">()</span>\n</pre>\n<p><tt>t</tt> is a <tt>numpy.ndarray</tt> containing the times at which node\nactivations happened. <tt>a</tt> is a <tt>numpy.ndarray</tt> containing the\nrelative cascade size at the corresponding time in <tt>t</tt>. Note that the\nwhole process is modeled as a Poisson process such that the time <tt>t</tt>\nwill be given in units of the node activation rate <tt>gamma = 1.0</tt>. If\nyou want to simulate for another node activation rate, simply rescale\ntime as <tt>t /= gamma</tt>.</p>\n<p>When the simulation is started with the <tt>save_activated_nodes=True</tt>\nflag, a list of activated nodes per time leap is saved in\n<tt>ThreshModel.activated_nodes</tt>.</p>\n<pre><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">Thresh</span><span class=\"o\">.</span><span class=\"n\">simulate</span><span class=\"p\">(</span><span class=\"n\">save_activated_nodes</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">Thresh</span><span class=\"o\">.</span><span class=\"n\">activated_nodes</span><span class=\"p\">)</span>\n</pre>\n<p>You can repeat a simulation with the same initial conditions by simply\ncalling <tt>Thresh.simulate()</tt> again, all the necessary things will be\nreset automatically.</p>\n</div>\n<div id=\"set-initially-activated-nodes\">\n<h3>Set initially activated nodes</h3>\n<p>Set nodes 3, 5, and 8 to be activated initially.</p>\n<pre><span class=\"n\">initially_activated</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">]</span> <span class=\"c1\"># this could also be a numpy array</span>\n</pre>\n<p>Choose 20% of all nodes randomly to be activated initially. When the\nsimulation is restarted, the same nodes will be chosen as initial\nconditions.</p>\n<pre><span class=\"n\">initially_activated</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>\n</pre>\n<p>Choose 35 randomly selected nodes to be activated initially. When the\nsimulation is restarted, the same nodes will be chosen as initial\nconditions.</p>\n<pre><span class=\"n\">initially_activated</span> <span class=\"o\">=</span> <span class=\"mi\">35</span>\n</pre>\n</div>\n<div id=\"set-thresholds\">\n<h3>Set thresholds</h3>\n<p>Activation thresholds can be set for all nodes</p>\n<pre><span class=\"n\">thresholds</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">number_of_nodes</span><span class=\"p\">())</span>\n</pre>\n<p>Note that thresholds need to lie in the domain <tt>[0,1]</tt>.</p>\n<p>You can also set a universal threshold</p>\n<pre><span class=\"n\">thresholds</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>\n</pre>\n<p>Here, 10% of a node\u2019s neighbor\u2019s need to be activated in order for the\nnode to become active, too.</p>\n</div>\n<div id=\"directed-networks\">\n<h3>Directed networks</h3>\n<p>A node will become active if the sufficient number of nodes pointing\n<em>towards</em> the node are active. This means that the in-degree will be the\nimportant measure to determine wether a node will become active.</p>\n</div>\n<div id=\"weighted-networks\">\n<h3>Weighted networks</h3>\n<p>If you want to simulate on a weighted network, provide the <tt>weight</tt>\nkeyword</p>\n<pre><span class=\"n\">Thresh</span> <span class=\"o\">=</span> <span class=\"n\">ThreshModel</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span><span class=\"n\">initially_activated</span><span class=\"p\">,</span><span class=\"n\">thresholds</span><span class=\"p\">,</span><span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"s1\">'weight'</span><span class=\"p\">)</span>\n</pre>\n<p>Similar to the networkx-documentation: <em>``weight``</em> (string, optional\n(default=``None``)) - The attribute name to obtain the edge weights.\nE.g.: <tt><span class=\"pre\">G.edges[0,1]['weight']</span></tt>.</p>\n<p>A focal node will become active when the cumulative edge weights of all\nactivated nodes pointing towards the focal node will reach\n<tt>&gt; threshold*in_degree</tt>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6019832, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "4147578474a335572500c1ce4016ab40", "sha256": "535834a241c78ddc9b9b1fe3acfba68281a30b0fa86f7ca1de68e1d2a9fe5938"}, "downloads": -1, "filename": "thresholdmodel-0.0.0.tar.gz", "has_sig": false, "md5_digest": "4147578474a335572500c1ce4016ab40", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5126, "upload_time": "2019-10-23T18:04:05", "upload_time_iso_8601": "2019-10-23T18:04:05.585512Z", "url": "https://files.pythonhosted.org/packages/01/2c/bb81acc8a32bb8e36d8c15dc6d89b1cfa8346a5077a025608e0d1f604b8f/thresholdmodel-0.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4147578474a335572500c1ce4016ab40", "sha256": "535834a241c78ddc9b9b1fe3acfba68281a30b0fa86f7ca1de68e1d2a9fe5938"}, "downloads": -1, "filename": "thresholdmodel-0.0.0.tar.gz", "has_sig": false, "md5_digest": "4147578474a335572500c1ce4016ab40", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5126, "upload_time": "2019-10-23T18:04:05", "upload_time_iso_8601": "2019-10-23T18:04:05.585512Z", "url": "https://files.pythonhosted.org/packages/01/2c/bb81acc8a32bb8e36d8c15dc6d89b1cfa8346a5077a025608e0d1f604b8f/thresholdmodel-0.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:53:41 2020"}