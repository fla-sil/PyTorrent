{"info": {"author": "Stendec", "author_email": "me@stendec.me", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet", "Topic :: Software Development"], "description": "NetStruct\n=========\n\nNetStruct is a `struct <http://docs.python.org/library/struct.html>`_-like\nmodule for Python designed to make it a bit easier to send and received packed\nbinary data.\n\nNetStruct is available under the `Apache License, Version 2.0\n<http://www.apache.org/licenses/LICENSE-2.0.html>`_.\n\n\nInstall\n=======\n\nNetStruct can be installed using `pip <http://http://pypi.python.org/pypi/pip>`_:\n\n    pip install netstruct\n\nYou can also grab the latest code from the `git <http://git-scm.com/>`_)\nrepository:\n\n    git clone git://github.com/stendec/netstruct\n\nNetStruct runs on `Python 2.6+ <http://python.org>`_, PyPy, and Python 3\n(though only Python 3.3 has been tested).\n\n\nDifferences from ``struct``\n===========================\n\nNetStruct has two differences from ``struct``.\n\nFirst, it defaults to using network byte-order, rather than native byte-order,\non the assumption that you'll be using it to send data over the network and,\nthus, it's saving you time.\n\nAdditionally, the generated strings don't have any padding when using\nnon-native byte-order.\n\nSecond, NetStruct supports a new formatting character, the dollar sign (``$``).\nThe dollar sign represents a variable-length string, encoded with its length\npreceeding the string itself. To accomplish this, the formatting character\ndirectly before the dollar sign is assumed to represent the string's length.\n\n\nExamples\n========\n\nThis is as basic as it gets::\n\n    >>> import netstruct\n    >>> netstruct.pack(b\"b$\", b\"Hello World!\")\n    b'\\x0cHello World!'\n\nAlternatively::\n\n    >>> netstruct.unpack(b\"b$\", b\"\\x0cHello World!\")\n    [b'Hello World!']\n\nYou can get a bit more complex, if you'd like::\n\n    >>> netstruct.pack(b\"ih$5b\", 1298, b\"largeBiomes\", 0, 0, 1, 0, 8)\n    b'\\x00\\x00\\x05\\x12\\x00\\x0blargeBiomes\\x00\\x00\\x01\\x00\\x08'\n\nAnd, of course, you can unpack complex data too::\n\n    >>> netstruct.unpack(b\"bh$h$i\", b\"'\\x00\\x07stendec\\x00\\tlocalhost\\x00\\x00c\\xdd\")\n    [39, b'stendec', b'localhost', 25565]\n\nYou just have to be sure to use a long enough string::\n\n    >>> netstruct.unpack(b\"bh$h$i\", b\"'\\x00\\x07stendec\\x00\\tlocalhost\\x00\")\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      File \"site-packages/netstruct.py\", line 275, in unpack\n        return NetStruct(format).unpack(data)\n      File \"site-packages/netstruct.py\", line 165, in unpack\n        raise error(\"unpack requires a string argument of length %d\" % (len(data) + out))\n    struct.error: unpack requires a string argument of length 25\n\nBut wait, you say. How am I supposed to provide a long enough string to\nunpack the data when I can't possibly know the length ahead of time?\nSimply put, you *can* know the length::\n\n    >>> it = netstruct.iter_unpack(b\"ih$5b\")\n    >>> next(it)\n    11\n\nThe ``iter_unpack`` function returns an iterator. Each time you call that\niterator with ``next()``, or call its ``.send()`` method, it can return one of\ntwo values. Either it'll return the number of bytes it wants you to read next,\nor it'll return the completed object.\n\nLet's continue from above::\n\n    >>> it.send(b\"\\x00\\x00\\x05\\x12\\x00\\x0b\")\n    16\n    >>> it.send(b\"largeBiomes\")\n    5\n    >>> it.send(b\"\\x00\\x00\\x01\\x00\\x08   more\")\n    [1298, b'largeBiomes', 0, 0, 1, 0, 8]\n\nThere. I've sent enough data, so it returned the completed list of the\nunpacked data. At this point, I can take my data, and do whatever it is I want\nwith it.\n\nBut wait! I just sent too much data to that iterator, and now I've lost some\nof my string, haven't I? That's not a problem either. You can call the iterator\none final time and it will return the unconsumed remainder of the data::\n\n    >>> next(it)\n    b'   more'\n\nIt's just that simple. Of course, not everyone likes iterators, even if they\n*are* quicker and less memory intensive than a class instance. NetStruct is\nprepared, with its ``Unpacker`` class and ``obj_unpack``. Let's try that last\nexample one more time::\n\n    >>> obj = netstruct.obj_unpack(b\"ih$5b\")\n    >>> obj.remaining\n    11\n    >>> obj.feed(b\"\\x00\\x00\\x05\\x12\\x00\\x0b\")\n    16\n    >>> obj.feed(b\"largeBiomes\")\n    5\n    >>> obj.feed(b\"\\x00\\x00\\x01\\x00\\x08   more\")\n    0\n    >>> obj.result\n    [1298, b'largeBiomes', 0, 0, 1, 0, 8]\n    >>> obj.unused_data\n    b'   more'\n\nEnjoy.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/stendec/netstruct", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "netstruct", "package_url": "https://pypi.org/project/netstruct/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/netstruct/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/stendec/netstruct"}, "release_url": "https://pypi.org/project/netstruct/1.1.2/", "requires_dist": null, "requires_python": null, "summary": "Packed binary data for networking.", "version": "1.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"netstruct\">\n<h2>NetStruct</h2>\n<p>NetStruct is a <a href=\"http://docs.python.org/library/struct.html\" rel=\"nofollow\">struct</a>-like\nmodule for Python designed to make it a bit easier to send and received packed\nbinary data.</p>\n<p>NetStruct is available under the <a href=\"http://www.apache.org/licenses/LICENSE-2.0.html\" rel=\"nofollow\">Apache License, Version 2.0</a>.</p>\n</div>\n<div id=\"install\">\n<h2>Install</h2>\n<p>NetStruct can be installed using <a href=\"http://http://pypi.python.org/pypi/pip\" rel=\"nofollow\">pip</a>:</p>\n<blockquote>\npip install netstruct</blockquote>\n<p>You can also grab the latest code from the <a href=\"http://git-scm.com/\" rel=\"nofollow\">git</a>)\nrepository:</p>\n<blockquote>\ngit clone git://github.com/stendec/netstruct</blockquote>\n<p>NetStruct runs on <a href=\"http://python.org\" rel=\"nofollow\">Python 2.6+</a>, PyPy, and Python 3\n(though only Python 3.3 has been tested).</p>\n</div>\n<div id=\"differences-from-struct\">\n<h2>Differences from <tt>struct</tt></h2>\n<p>NetStruct has two differences from <tt>struct</tt>.</p>\n<p>First, it defaults to using network byte-order, rather than native byte-order,\non the assumption that you\u2019ll be using it to send data over the network and,\nthus, it\u2019s saving you time.</p>\n<p>Additionally, the generated strings don\u2019t have any padding when using\nnon-native byte-order.</p>\n<p>Second, NetStruct supports a new formatting character, the dollar sign (<tt>$</tt>).\nThe dollar sign represents a variable-length string, encoded with its length\npreceeding the string itself. To accomplish this, the formatting character\ndirectly before the dollar sign is assumed to represent the string\u2019s length.</p>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>This is as basic as it gets:</p>\n<pre>&gt;&gt;&gt; import netstruct\n&gt;&gt;&gt; netstruct.pack(b\"b$\", b\"Hello World!\")\nb'\\x0cHello World!'\n</pre>\n<p>Alternatively:</p>\n<pre>&gt;&gt;&gt; netstruct.unpack(b\"b$\", b\"\\x0cHello World!\")\n[b'Hello World!']\n</pre>\n<p>You can get a bit more complex, if you\u2019d like:</p>\n<pre>&gt;&gt;&gt; netstruct.pack(b\"ih$5b\", 1298, b\"largeBiomes\", 0, 0, 1, 0, 8)\nb'\\x00\\x00\\x05\\x12\\x00\\x0blargeBiomes\\x00\\x00\\x01\\x00\\x08'\n</pre>\n<p>And, of course, you can unpack complex data too:</p>\n<pre>&gt;&gt;&gt; netstruct.unpack(b\"bh$h$i\", b\"'\\x00\\x07stendec\\x00\\tlocalhost\\x00\\x00c\\xdd\")\n[39, b'stendec', b'localhost', 25565]\n</pre>\n<p>You just have to be sure to use a long enough string:</p>\n<pre>&gt;&gt;&gt; netstruct.unpack(b\"bh$h$i\", b\"'\\x00\\x07stendec\\x00\\tlocalhost\\x00\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"site-packages/netstruct.py\", line 275, in unpack\n    return NetStruct(format).unpack(data)\n  File \"site-packages/netstruct.py\", line 165, in unpack\n    raise error(\"unpack requires a string argument of length %d\" % (len(data) + out))\nstruct.error: unpack requires a string argument of length 25\n</pre>\n<p>But wait, you say. How am I supposed to provide a long enough string to\nunpack the data when I can\u2019t possibly know the length ahead of time?\nSimply put, you <em>can</em> know the length:</p>\n<pre>&gt;&gt;&gt; it = netstruct.iter_unpack(b\"ih$5b\")\n&gt;&gt;&gt; next(it)\n11\n</pre>\n<p>The <tt>iter_unpack</tt> function returns an iterator. Each time you call that\niterator with <tt>next()</tt>, or call its <tt>.send()</tt> method, it can return one of\ntwo values. Either it\u2019ll return the number of bytes it wants you to read next,\nor it\u2019ll return the completed object.</p>\n<p>Let\u2019s continue from above:</p>\n<pre>&gt;&gt;&gt; it.send(b\"\\x00\\x00\\x05\\x12\\x00\\x0b\")\n16\n&gt;&gt;&gt; it.send(b\"largeBiomes\")\n5\n&gt;&gt;&gt; it.send(b\"\\x00\\x00\\x01\\x00\\x08   more\")\n[1298, b'largeBiomes', 0, 0, 1, 0, 8]\n</pre>\n<p>There. I\u2019ve sent enough data, so it returned the completed list of the\nunpacked data. At this point, I can take my data, and do whatever it is I want\nwith it.</p>\n<p>But wait! I just sent too much data to that iterator, and now I\u2019ve lost some\nof my string, haven\u2019t I? That\u2019s not a problem either. You can call the iterator\none final time and it will return the unconsumed remainder of the data:</p>\n<pre>&gt;&gt;&gt; next(it)\nb'   more'\n</pre>\n<p>It\u2019s just that simple. Of course, not everyone likes iterators, even if they\n<em>are</em> quicker and less memory intensive than a class instance. NetStruct is\nprepared, with its <tt>Unpacker</tt> class and <tt>obj_unpack</tt>. Let\u2019s try that last\nexample one more time:</p>\n<pre>&gt;&gt;&gt; obj = netstruct.obj_unpack(b\"ih$5b\")\n&gt;&gt;&gt; obj.remaining\n11\n&gt;&gt;&gt; obj.feed(b\"\\x00\\x00\\x05\\x12\\x00\\x0b\")\n16\n&gt;&gt;&gt; obj.feed(b\"largeBiomes\")\n5\n&gt;&gt;&gt; obj.feed(b\"\\x00\\x00\\x01\\x00\\x08   more\")\n0\n&gt;&gt;&gt; obj.result\n[1298, b'largeBiomes', 0, 0, 1, 0, 8]\n&gt;&gt;&gt; obj.unused_data\nb'   more'\n</pre>\n<p>Enjoy.</p>\n</div>\n\n          </div>"}, "last_serial": 876213, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "e0f34bcf086e1e9310142b02d24ce6c9", "sha256": "543c7fe8dcee44097b1a15fddd27fa679de8eb489880c95d0c910d3a103da91f"}, "downloads": -1, "filename": "netstruct-1.0.zip", "has_sig": false, "md5_digest": "e0f34bcf086e1e9310142b02d24ce6c9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4098, "upload_time": "2012-10-26T06:44:50", "upload_time_iso_8601": "2012-10-26T06:44:50.174771Z", "url": "https://files.pythonhosted.org/packages/5d/50/44966896291710549e7bbf43c91c2e9099f07572dd6c31f5d8d3d5e04b07/netstruct-1.0.zip", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "8966c63ee5d282610d8eb83e703f0a6f", "sha256": "371a4de6deda123fff79a8ead59401b6ef7cd7ef8f0b4cf7599682d75124c9e7"}, "downloads": -1, "filename": "netstruct-1.1.zip", "has_sig": false, "md5_digest": "8966c63ee5d282610d8eb83e703f0a6f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5119, "upload_time": "2012-10-27T22:27:53", "upload_time_iso_8601": "2012-10-27T22:27:53.454354Z", "url": "https://files.pythonhosted.org/packages/63/08/fbd995f3b829994545f97099bed0777c4aa7f09b730a8bc96c8a2f5ea0cd/netstruct-1.1.zip", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "b170364f58404a64acd3b5572d927a04", "sha256": "fa6dada72960f4c73d220309564822e51e2f4af7b3c5798d4d57ca21874c8c94"}, "downloads": -1, "filename": "netstruct-1.1.1.zip", "has_sig": false, "md5_digest": "b170364f58404a64acd3b5572d927a04", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7187, "upload_time": "2012-10-27T23:35:52", "upload_time_iso_8601": "2012-10-27T23:35:52.940104Z", "url": "https://files.pythonhosted.org/packages/ee/0c/328052f330de01f1de13b372bd711f12e6d41b79b8549495305b770da4df/netstruct-1.1.1.zip", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "38b894eaa05cb35f6e7397277c01a8bf", "sha256": "70b6a5c73f5bbc7ab57b019369642adfb34dd8af41b948c400ce95f952b7df9a"}, "downloads": -1, "filename": "netstruct-1.1.2.zip", "has_sig": false, "md5_digest": "38b894eaa05cb35f6e7397277c01a8bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7215, "upload_time": "2013-09-29T07:59:47", "upload_time_iso_8601": "2013-09-29T07:59:47.910345Z", "url": "https://files.pythonhosted.org/packages/b8/eb/460b09c71d65ea3ea7ff89271207935c44e30aa558b64f5102441f129191/netstruct-1.1.2.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "38b894eaa05cb35f6e7397277c01a8bf", "sha256": "70b6a5c73f5bbc7ab57b019369642adfb34dd8af41b948c400ce95f952b7df9a"}, "downloads": -1, "filename": "netstruct-1.1.2.zip", "has_sig": false, "md5_digest": "38b894eaa05cb35f6e7397277c01a8bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7215, "upload_time": "2013-09-29T07:59:47", "upload_time_iso_8601": "2013-09-29T07:59:47.910345Z", "url": "https://files.pythonhosted.org/packages/b8/eb/460b09c71d65ea3ea7ff89271207935c44e30aa558b64f5102441f129191/netstruct-1.1.2.zip", "yanked": false}], "timestamp": "Fri May  8 00:45:55 2020"}