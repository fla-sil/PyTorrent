{"info": {"author": "David Danier", "author_email": "david.danier@team23.de", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Utilities"], "description": "================\ndjango_url_alias\n================\n\nAbout\n-----\n\ndjango_url_alias allows you to completely rewrite certain URLs, if you need to. This is done for incoming URL handling\n(URL resolving) and outgoing URLs (via `{% url \u2026 %}` or `resolve`). URL rewrites are modular, so you may have static\nrewrites (like a dict in settings) and database based rewrites. You may even mix both types by having multiple URL\nrewriters.\n\nHow it works\n------------\n\ndjango_url_alias provides a special ROOT_URLCONF which intercepts URL resolving on the lowest level. This way it can\nrewrite all incoming URLs, so other views will be resolved.\n\nFor outgoing URLs (to clarify: \"outgoing\" does only mean URLs generated by the system, these URLs still may be\ninternal) The process is a little bit more complex. django_url_alias provides a special `{% url %}` template tag and\nits own version of `reverse`. If you use these, everything will just work fine. Sadly there is no sane way to just\nreplace Django's default behaviour.\n\nUsecase\n-------\n\nAlthough Django's URL handling is really great there may be scanarios it just cannot handle. The flatpage app is one\nof the examples URL handling get weird if you need a catchall pattern. As this still works for flatpages you run\ninto trouble when more then one app needs a similar mechanism (catchall pattern), as only the first one will be handled\ncorrectly (URL matches, further urlconf entries will be ignored).\n\nOther frameworks / CMS / \u2026 often use a completely different way to accomplish great URL structure. Instead of having\neasy to read system / internal URLs they just put an abstraction layer above all URL handling. This means your\nblog entry (for example) may still have an ugly (internal) URL like \"blog/entry/15\". Now the new URL layer will\ntake that ugly URL and allow the user or system to define aliases. An alias could for example rewrite \"blog/entry/15\"\nto just \"my-trip-to-paris.html\". On input URL handling this needs to be reversed, so the requested URL\n\"my-trip-to-paris.html\" will resolve to \"blog/entry/15\" again.\n\ndjango_url_alias allows you to just do exactly this. As it does not provide any predefined rules / mechanisms for\nrewriting the URL you are free to use whatever rule you want. In theory you could even reuse the good old `SlugField`\nand regular expressions. Of course you may use a DB based mapping like so many systems use, too. Below you will find\nan example for flatpages, without the need for an catchall pattern.\n\nUsage\n-----\n\nInstallation\n~~~~~~~~~~~~\n\n#. Get django_url_alias into your python `sys.path` (`pip install django_url_alias`)\n#. Replace `settings.ROOT_URLCONF` with `\"django_url_alias.urls\"`\n#. Put your old root urlconf into `settings.URL_ALIAS_ROOT_URLCONF`\n#. Define your URL rewriting modules using `settings.URL_ALIAS_MODULES`\n   (see https://github.com/ddanier/django_url_alias/blob/master/example/example/url_aliases.py\n   and example below)\n#. Put `{% load url_alias %}` into your templates, so `{% url %}` gets replaced\n#. Use `django_url_alias.resolver.reverse` in your Python code\n\nAbout URL_ALIAS_MODULES\n~~~~~~~~~~~~~~~~~~~~~~~\n\nURL_ALIAS_MODULES is just a list of simple classes to rewrite the URLs Django handles or generates.\n\n.. code:: python\n\n    URL_ALIAS_MODULES = (\n        'path.to.module.aliases.ExampleAliasModule',\n    )\n\nEach class will be instantiated without any parameters and should provide two methods:\n\n* resolve(self, path): Change incoming URLs\n* reverse(self, path): Change outgoing URLs\n\nA simple example may look like this::\n\n    class ExampleURLAliasModule(object):\n        def resolve(self, path):\n            if path == 'foo/':\n                return 'bar/'\n\n        def reverse(self, path):\n            if path == 'bar/':\n                return 'foo/'\n\nBoth methods must return nothing (/None) when no rewrite is done. The defined classes will be called in order for\nincoming and outgoing URLs. The first module which returns a replacement URL will shortcut further processing, thus\nwill define the final URL.\n\nFlatpage example\n----------------\n\nThe flatpages app is in core, so it just gives an nice example. We don't want to use the catchall pattern any more.\nFor this example to work you will need to go through installation first.\n\nFirst of all we need to define our internal URL structure. This will not be visible to your visitors, although\nthe internal URLs are still accessible.\n\nurls.py:: python\n\n    urlpatterns = patterns('',\n        url(r'^flatpage/(?P<pk>[0-9]+)/$', 'example.views.flatpage', name='flatpage'),\n    )\n\nThen the rewrite needs to be done, so `flatpage.url` will be used to present the external URL structure, while\nthe internal ID-based URL gets used internally.\n\nURL Rewrite module:: python\n\n    from django.contrib.flatpages.models import FlatPage\n    import re\n\n    class FlatpagesURLAliasModule(object):\n        FLATPAGE_RE = re.compile('^/flatpage/(?P<pk>[0-9]+)/$')\n\n        def resolve(self, path):\n            path = '/' + path  # we need a trailing slash for flatpages\n            try:\n                flatpage = FlatPage.objects.get(url=path)\n                return '/flatpage/%d/' % flatpage.pk\n            except FlatPage.DoesNotExist:\n                pass  # just return nothing\n\n        def reverse(self, path):\n            match = self.FLATPAGE_RE.match(path)\n            if match:\n                try:\n                    flatpage = FlatPage.objects.get(pk=match.group('pk'))\n                    return flatpage.url\n                except FlatPage.DoesNotExist:\n                    pass  # just return nothing\n\n*Note:* This is just an example. In an production envirionment you would need to a) check the sites relation and more\nimportantly b) use some caching. The above code is very inefficient and should NEVER BE USED IN A PRODUCTION\nENVIRIONMENT.\n\n\nAdvantages of implementation\n----------------------------\n\n* `request` objects stay clean. You could rewrite URLs using middleware classes which fiddle with `request.path_info`,\n  but this way you will loose information (or even worse: rewrite information).\n* Least obtrusive way of implementation.\n\nNotes\n-----\n\n* You should define canonical tags, so internal URLs will not get indexed by search engines.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ddanier/django_url_alias", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "django_url_alias", "package_url": "https://pypi.org/project/django_url_alias/", "platform": "", "project_url": "https://pypi.org/project/django_url_alias/", "project_urls": {"Homepage": "https://github.com/ddanier/django_url_alias"}, "release_url": "https://pypi.org/project/django_url_alias/0.3.0/", "requires_dist": null, "requires_python": "", "summary": "Allow Django URLS to be completely rewritten (alias names for system URLs)", "version": "0.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            ================<br>django_url_alias<br>================<br><br>About<br>-----<br><br>django_url_alias allows you to completely rewrite certain URLs, if you need to. This is done for incoming URL handling<br>(URL resolving) and outgoing URLs (via `{% url \u2026 %}` or `resolve`). URL rewrites are modular, so you may have static<br>rewrites (like a dict in settings) and database based rewrites. You may even mix both types by having multiple URL<br>rewriters.<br><br>How it works<br>------------<br><br>django_url_alias provides a special ROOT_URLCONF which intercepts URL resolving on the lowest level. This way it can<br>rewrite all incoming URLs, so other views will be resolved.<br><br>For outgoing URLs (to clarify: \"outgoing\" does only mean URLs generated by the system, these URLs still may be<br>internal) The process is a little bit more complex. django_url_alias provides a special `{% url %}` template tag and<br>its own version of `reverse`. If you use these, everything will just work fine. Sadly there is no sane way to just<br>replace Django's default behaviour.<br><br>Usecase<br>-------<br><br>Although Django's URL handling is really great there may be scanarios it just cannot handle. The flatpage app is one<br>of the examples URL handling get weird if you need a catchall pattern. As this still works for flatpages you run<br>into trouble when more then one app needs a similar mechanism (catchall pattern), as only the first one will be handled<br>correctly (URL matches, further urlconf entries will be ignored).<br><br>Other frameworks / CMS / \u2026 often use a completely different way to accomplish great URL structure. Instead of having<br>easy to read system / internal URLs they just put an abstraction layer above all URL handling. This means your<br>blog entry (for example) may still have an ugly (internal) URL like \"blog/entry/15\". Now the new URL layer will<br>take that ugly URL and allow the user or system to define aliases. An alias could for example rewrite \"blog/entry/15\"<br>to just \"my-trip-to-paris.html\". On input URL handling this needs to be reversed, so the requested URL<br>\"my-trip-to-paris.html\" will resolve to \"blog/entry/15\" again.<br><br>django_url_alias allows you to just do exactly this. As it does not provide any predefined rules / mechanisms for<br>rewriting the URL you are free to use whatever rule you want. In theory you could even reuse the good old `SlugField`<br>and regular expressions. Of course you may use a DB based mapping like so many systems use, too. Below you will find<br>an example for flatpages, without the need for an catchall pattern.<br><br>Usage<br>-----<br><br>Installation<br>~~~~~~~~~~~~<br><br>#. Get django_url_alias into your python `sys.path` (`pip install django_url_alias`)<br>#. Replace `settings.ROOT_URLCONF` with `\"django_url_alias.urls\"`<br>#. Put your old root urlconf into `settings.URL_ALIAS_ROOT_URLCONF`<br>#. Define your URL rewriting modules using `settings.URL_ALIAS_MODULES`<br>   (see https://github.com/ddanier/django_url_alias/blob/master/example/example/url_aliases.py<br>   and example below)<br>#. Put `{% load url_alias %}` into your templates, so `{% url %}` gets replaced<br>#. Use `django_url_alias.resolver.reverse` in your Python code<br><br>About URL_ALIAS_MODULES<br>~~~~~~~~~~~~~~~~~~~~~~~<br><br>URL_ALIAS_MODULES is just a list of simple classes to rewrite the URLs Django handles or generates.<br><br>.. code:: python<br><br>    URL_ALIAS_MODULES = (<br>        'path.to.module.aliases.ExampleAliasModule',<br>    )<br><br>Each class will be instantiated without any parameters and should provide two methods:<br><br>* resolve(self, path): Change incoming URLs<br>* reverse(self, path): Change outgoing URLs<br><br>A simple example may look like this::<br><br>    class ExampleURLAliasModule(object):<br>        def resolve(self, path):<br>            if path == 'foo/':<br>                return 'bar/'<br><br>        def reverse(self, path):<br>            if path == 'bar/':<br>                return 'foo/'<br><br>Both methods must return nothing (/None) when no rewrite is done. The defined classes will be called in order for<br>incoming and outgoing URLs. The first module which returns a replacement URL will shortcut further processing, thus<br>will define the final URL.<br><br>Flatpage example<br>----------------<br><br>The flatpages app is in core, so it just gives an nice example. We don't want to use the catchall pattern any more.<br>For this example to work you will need to go through installation first.<br><br>First of all we need to define our internal URL structure. This will not be visible to your visitors, although<br>the internal URLs are still accessible.<br><br>urls.py:: python<br><br>    urlpatterns = patterns('',<br>        url(r'^flatpage/(?P&lt;pk&gt;[0-9]+)/$', 'example.views.flatpage', name='flatpage'),<br>    )<br><br>Then the rewrite needs to be done, so `flatpage.url` will be used to present the external URL structure, while<br>the internal ID-based URL gets used internally.<br><br>URL Rewrite module:: python<br><br>    from django.contrib.flatpages.models import FlatPage<br>    import re<br><br>    class FlatpagesURLAliasModule(object):<br>        FLATPAGE_RE = re.compile('^/flatpage/(?P&lt;pk&gt;[0-9]+)/$')<br><br>        def resolve(self, path):<br>            path = '/' + path  # we need a trailing slash for flatpages<br>            try:<br>                flatpage = FlatPage.objects.get(url=path)<br>                return '/flatpage/%d/' % flatpage.pk<br>            except FlatPage.DoesNotExist:<br>                pass  # just return nothing<br><br>        def reverse(self, path):<br>            match = self.FLATPAGE_RE.match(path)<br>            if match:<br>                try:<br>                    flatpage = FlatPage.objects.get(pk=match.group('pk'))<br>                    return flatpage.url<br>                except FlatPage.DoesNotExist:<br>                    pass  # just return nothing<br><br>*Note:* This is just an example. In an production envirionment you would need to a) check the sites relation and more<br>importantly b) use some caching. The above code is very inefficient and should NEVER BE USED IN A PRODUCTION<br>ENVIRIONMENT.<br><br><br>Advantages of implementation<br>----------------------------<br><br>* `request` objects stay clean. You could rewrite URLs using middleware classes which fiddle with `request.path_info`,<br>  but this way you will loose information (or even worse: rewrite information).<br>* Least obtrusive way of implementation.<br><br>Notes<br>-----<br><br>* You should define canonical tags, so internal URLs will not get indexed by search engines.\n          </div>"}, "last_serial": 4502225, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "e9e3592f68df3bdc95c489d15af241bb", "sha256": "a6a0fc7cb6e407dcf7eb7c248c539b8af6c2aa6dd292d00e6d5cb3e75c8093fb"}, "downloads": -1, "filename": "django_url_alias-0.1.0.tar.gz", "has_sig": false, "md5_digest": "e9e3592f68df3bdc95c489d15af241bb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5786, "upload_time": "2014-02-20T08:56:00", "upload_time_iso_8601": "2014-02-20T08:56:00.518972Z", "url": "https://files.pythonhosted.org/packages/a3/88/42b519dd84bcb2d327a30239c09557ffe2206e5f6536dab3e779d8fb0419/django_url_alias-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "82e59681fbdc58f857099c89b34e278f", "sha256": "d3da3d1bd562f37371b285bca42239808e6cf5d723b1d924d1cca850ce671f87"}, "downloads": -1, "filename": "django_url_alias-0.1.1.tar.gz", "has_sig": false, "md5_digest": "82e59681fbdc58f857099c89b34e278f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5781, "upload_time": "2014-02-20T09:10:31", "upload_time_iso_8601": "2014-02-20T09:10:31.354644Z", "url": "https://files.pythonhosted.org/packages/4b/6a/c771b62008ce53547169f2fb6d4b3c43060eb0ffeb134f25c234d5c551a5/django_url_alias-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "364c8bd7ec94a35a90f7c03adce22e6c", "sha256": "3941f89749e058036881b5ef59af0644c5df0c316a29a74cb21792b96ccac2ec"}, "downloads": -1, "filename": "django_url_alias-0.2.0.tar.gz", "has_sig": false, "md5_digest": "364c8bd7ec94a35a90f7c03adce22e6c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5956, "upload_time": "2014-06-05T14:14:52", "upload_time_iso_8601": "2014-06-05T14:14:52.213791Z", "url": "https://files.pythonhosted.org/packages/5d/5c/7983003107af391ee337e7ec5910a11d260be859edc31a4d0878b440161c/django_url_alias-0.2.0.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "310cff6a6be144832ad8215c18b14f4e", "sha256": "dd047f826501b57ce67b9c2a3177108f5b92f5923c612387cc5a4705d92dd2f2"}, "downloads": -1, "filename": "django_url_alias-0.3.0.tar.gz", "has_sig": false, "md5_digest": "310cff6a6be144832ad8215c18b14f4e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5908, "upload_time": "2018-11-19T10:02:04", "upload_time_iso_8601": "2018-11-19T10:02:04.101592Z", "url": "https://files.pythonhosted.org/packages/c0/f2/2baf63b5c940b3346f140460078640067ab29bca713c437626aea84110bc/django_url_alias-0.3.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "310cff6a6be144832ad8215c18b14f4e", "sha256": "dd047f826501b57ce67b9c2a3177108f5b92f5923c612387cc5a4705d92dd2f2"}, "downloads": -1, "filename": "django_url_alias-0.3.0.tar.gz", "has_sig": false, "md5_digest": "310cff6a6be144832ad8215c18b14f4e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5908, "upload_time": "2018-11-19T10:02:04", "upload_time_iso_8601": "2018-11-19T10:02:04.101592Z", "url": "https://files.pythonhosted.org/packages/c0/f2/2baf63b5c940b3346f140460078640067ab29bca713c437626aea84110bc/django_url_alias-0.3.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:12 2020"}