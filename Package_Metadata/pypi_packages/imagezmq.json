{"info": {"author": "Jeff Bass", "author_email": "jeff@yin-yang-ranch.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: CPython"], "description": "====================================\nimagezmq: Transporting OpenCV images\n====================================\n\n**imagezmq** is a set of Python classes that transport OpenCV images from one\ncomputer to another using PyZMQ messaging. For example, here is a screen on a\nMac computer showing simultaneous video streams from 8 Raspberry Pi cameras:\n\n.. image:: https://raw.githubusercontent.com/jeffbass/imagezmq/master/docs/images/screenshottest.png\n\nUsing **imagezmq**, this is possible with 11 lines of Python on each Raspberry\nPi and with 8 lines of Python on the Mac.\n\nFirst, run this code on the Mac (or other display computer):\n\n.. code-block:: python\n  :number-lines:\n\n    # run this program on the Mac to display image streams from multiple RPis\n    import cv2\n    import imagezmq\n    image_hub = imagezmq.ImageHub()\n    while True:  # show streamed images until Ctrl-C\n        rpi_name, image = image_hub.recv_image()\n        cv2.imshow(rpi_name, image) # 1 window for each RPi\n        cv2.waitKey(1)\n        image_hub.send_reply(b'OK')\n\n\nThen, on each Raspberry Pi, run:\n\n.. code-block:: python\n  :number-lines:\n\n    # run this program on each RPi to send a labelled image stream\n    import socket\n    import time\n    from imutils.video import VideoStream\n    import imagezmq\n\n    sender = imagezmq.ImageSender(connect_to='tcp://jeff-macbook:5555')\n\n    rpi_name = socket.gethostname() # send RPi hostname with each image\n    picam = VideoStream(usePiCamera=True).start()\n    time.sleep(2.0)  # allow camera sensor to warm up\n    while True:  # send images as stream until Ctrl-C\n        image = picam.read()\n        sender.send_image(rpi_name, image)\n\n\nWow! A video surveillance system with 8 (or more!) Raspberry Pi cameras in\n19 lines of Python.\n\nWhy use imagezmq?\n=================\n\n**imagezmq** is an easy to use image transport mechanism for a distributed image\nprocessing network. For example, a network of a dozen Raspberry Pis with cameras\ncan send images to a more powerful central computer. The Raspberry Pis perform\nimage capture and simple image processing like flipping, blurring and motion\ndetection. Then the images are passed via **imagezmq** to the central computer for\nmore complex image processing like image tagging, text extraction, feature\nrecognition, etc.\n\nFeatures\n========\n\n- Sends OpenCV images from one computer to another using ZMQ.\n- Can send jpeg compressed OpenCV images, to lighten network loads.\n- Uses the powerful ZMQ messaging library through PyZMQ bindings.\n- Allows a choice of 2 different ZMQ messaging patterns (REQ/REP or PUB/SUB).\n- Enables the image hub to receive and process images from multiple image senders\n  simultaneously.\n\nWhy ZMQ? Why not some other messaging protocol?\n===============================================\n\nThere are a number of high quality and well maintained messaging protocols for\npassing messages between computers. I looked at MQTT, RabbitMQ, AMQP and ROS as\nalternatives. I chose ZMQ and its Python PyZMQ bindings for several reasons:\n\n- ZMQ does not require a message broker. It is a peer to peer protocol that does\n  not need to pass an image first to a message broker and then to the imagehub.\n  This means fewer running processes and less \u201cdouble handling\u201d of images.\n  OpenCV images are large compared to simple text messages, so the absence of a\n  message broker is important.\n- ZMQ is very fast for passing OpenCV images. It enables high throughput between\n  image senders and image hubs.\n- ZMQ and its PyZMQ bindings are easy to install.\n\n**imagezmq** has been transporting images from a dozen Raspberry Pi computers\nscattered around my farm to 2 linux image hub servers for over 2\nyears. The RPi's capture and send dozens to thousands of frames frames a day.\n**imagezmq** has worked very reliably and is very fast. You can learn more about\nmy \"science experiment urban permaculture farm\" project at\n`Yin Yang Ranch project overview <https://github.com/jeffbass/yin-yang-ranch>`_.\n\nMessaging Patterns: REQ/REP versus PUB/SUB\n==========================================\n\nZMQ allows many different messaging patterns. Two are implemented in **imagezmq**:\n\n- REQ/REP: Each RPi sends an image and waits for a REPLY from the central image\n  hub. The RPi sends a new image only when the REPLY is received. In the REQ/REP\n  messaging pattern, each image sender must await a REPLY before continuing. It is a\n  \"blocking\" pattern for the sender.\n- PUB/SUB: Each RPi sends an image, but does not expect a REPLY from the central\n  image hub. It can continue sending images without awaiting any acknowledgement\n  from the image hub. The image hub provides no REPLY. It is a \"non-blocking\"\n  pattern for the sender.\n\nThere are advantages and disadvantages for each pattern.\n**REQ/REP is the default.** See the documentation (link below) for more details.\n\nDependencies and Installation\n=============================\n\n**imagezmq** has been tested with:\n\n- Python 3.5, 3.6, 3.7 and 3.8\n- PyZMQ 16.0 and 17.1\n- Numpy 1.13 and 1.16\n- OpenCV 3.3 and 4.0\n- Raspbian Buster, Raspbian Stretch and Raspbian Jessie\n- picamera 1.13 (used to capture images for the tests)\n- imutils 0.4.6 and 0.5.2 (used to capture images from PiCamera)\n\nInstall OpenCV, including Numpy, into a Python Virtual Environment. Then be sure\nto install **imagezmq** into the **same** virtual environment. For example, if\nthe virtual environment is named **py3cv3**, you would install **imagezmq**\nusing pip like this:\n\n.. code-block:: bash\n\n    workon py3cv3  # use your virtual environment name\n    pip install imagezmq\n\n**imagezmq** has a directory of tests organized into sender and receiver pairs.\nYou will get all the source code for **imagezmq** including all the test\nprograms by cloning the GitHub repository:\n\n.. code-block:: bash\n\n    git clone https://github.com/jeffbass/imagezmq.git\n\nSource Code and Full Documentation\n==================================\n\n**imagezmq** is open source. The source code, tests and\ndocumentation are at `Imagezmq on GitHub <https://github.com/jeffbass/imagezmq>`_.\nThe documentation, including links to application examples,\nstarts from the table of contents in the README.\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jeffbass/imagezmq", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "imagezmq", "package_url": "https://pypi.org/project/imagezmq/", "platform": "", "project_url": "https://pypi.org/project/imagezmq/", "project_urls": {"Homepage": "https://github.com/jeffbass/imagezmq"}, "release_url": "https://pypi.org/project/imagezmq/1.0.1/", "requires_dist": ["pyzmq (>=16.0)", "numpy (>=1.13)"], "requires_python": ">=3.5", "summary": "Transporting OpenCV images via ZMQ", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><strong>imagezmq</strong> is a set of Python classes that transport OpenCV images from one\ncomputer to another using PyZMQ messaging. For example, here is a screen on a\nMac computer showing simultaneous video streams from 8 Raspberry Pi cameras:</p>\n<img alt=\"https://raw.githubusercontent.com/jeffbass/imagezmq/master/docs/images/screenshottest.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5a6c1f4222159a0f275890eff0a19cac316be41a/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6a656666626173732f696d6167657a6d712f6d61737465722f646f63732f696d616765732f73637265656e73686f74746573742e706e67\">\n<p>Using <strong>imagezmq</strong>, this is possible with 11 lines of Python on each Raspberry\nPi and with 8 lines of Python on the Mac.</p>\n<p>First, run this code on the Mac (or other display computer):</p>\n<pre><span class=\"ln\"> 1 </span>  <span class=\"c1\"># run this program on the Mac to display image streams from multiple RPis</span>\n<span class=\"ln\"> 2 </span>  <span class=\"kn\">import</span> <span class=\"nn\">cv2</span>\n<span class=\"ln\"> 3 </span>  <span class=\"kn\">import</span> <span class=\"nn\">imagezmq</span>\n<span class=\"ln\"> 4 </span>  <span class=\"n\">image_hub</span> <span class=\"o\">=</span> <span class=\"n\">imagezmq</span><span class=\"o\">.</span><span class=\"n\">ImageHub</span><span class=\"p\">()</span>\n<span class=\"ln\"> 5 </span>  <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>  <span class=\"c1\"># show streamed images until Ctrl-C</span>\n<span class=\"ln\"> 6 </span>      <span class=\"n\">rpi_name</span><span class=\"p\">,</span> <span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">image_hub</span><span class=\"o\">.</span><span class=\"n\">recv_image</span><span class=\"p\">()</span>\n<span class=\"ln\"> 7 </span>      <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"n\">rpi_name</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">)</span> <span class=\"c1\"># 1 window for each RPi</span>\n<span class=\"ln\"> 8 </span>      <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">waitKey</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"ln\"> 9 </span>      <span class=\"n\">image_hub</span><span class=\"o\">.</span><span class=\"n\">send_reply</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'OK'</span><span class=\"p\">)</span>\n</pre>\n<p>Then, on each Raspberry Pi, run:</p>\n<pre><span class=\"ln\"> 1 </span>  <span class=\"c1\"># run this program on each RPi to send a labelled image stream</span>\n<span class=\"ln\"> 2 </span>  <span class=\"kn\">import</span> <span class=\"nn\">socket</span>\n<span class=\"ln\"> 3 </span>  <span class=\"kn\">import</span> <span class=\"nn\">time</span>\n<span class=\"ln\"> 4 </span>  <span class=\"kn\">from</span> <span class=\"nn\">imutils.video</span> <span class=\"kn\">import</span> <span class=\"n\">VideoStream</span>\n<span class=\"ln\"> 5 </span>  <span class=\"kn\">import</span> <span class=\"nn\">imagezmq</span>\n<span class=\"ln\"> 6 </span>\n<span class=\"ln\"> 7 </span>  <span class=\"n\">sender</span> <span class=\"o\">=</span> <span class=\"n\">imagezmq</span><span class=\"o\">.</span><span class=\"n\">ImageSender</span><span class=\"p\">(</span><span class=\"n\">connect_to</span><span class=\"o\">=</span><span class=\"s1\">'tcp://jeff-macbook:5555'</span><span class=\"p\">)</span>\n<span class=\"ln\"> 8 </span>\n<span class=\"ln\"> 9 </span>  <span class=\"n\">rpi_name</span> <span class=\"o\">=</span> <span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">gethostname</span><span class=\"p\">()</span> <span class=\"c1\"># send RPi hostname with each image</span>\n<span class=\"ln\">10 </span>  <span class=\"n\">picam</span> <span class=\"o\">=</span> <span class=\"n\">VideoStream</span><span class=\"p\">(</span><span class=\"n\">usePiCamera</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"ln\">11 </span>  <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">2.0</span><span class=\"p\">)</span>  <span class=\"c1\"># allow camera sensor to warm up</span>\n<span class=\"ln\">12 </span>  <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>  <span class=\"c1\"># send images as stream until Ctrl-C</span>\n<span class=\"ln\">13 </span>      <span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">picam</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n<span class=\"ln\">14 </span>      <span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">send_image</span><span class=\"p\">(</span><span class=\"n\">rpi_name</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">)</span>\n</pre>\n<p>Wow! A video surveillance system with 8 (or more!) Raspberry Pi cameras in\n19 lines of Python.</p>\n<div id=\"why-use-imagezmq\">\n<h2>Why use imagezmq?</h2>\n<p><strong>imagezmq</strong> is an easy to use image transport mechanism for a distributed image\nprocessing network. For example, a network of a dozen Raspberry Pis with cameras\ncan send images to a more powerful central computer. The Raspberry Pis perform\nimage capture and simple image processing like flipping, blurring and motion\ndetection. Then the images are passed via <strong>imagezmq</strong> to the central computer for\nmore complex image processing like image tagging, text extraction, feature\nrecognition, etc.</p>\n</div>\n<div id=\"features\">\n<h2>Features</h2>\n<ul>\n<li>Sends OpenCV images from one computer to another using ZMQ.</li>\n<li>Can send jpeg compressed OpenCV images, to lighten network loads.</li>\n<li>Uses the powerful ZMQ messaging library through PyZMQ bindings.</li>\n<li>Allows a choice of 2 different ZMQ messaging patterns (REQ/REP or PUB/SUB).</li>\n<li>Enables the image hub to receive and process images from multiple image senders\nsimultaneously.</li>\n</ul>\n</div>\n<div id=\"why-zmq-why-not-some-other-messaging-protocol\">\n<h2>Why ZMQ? Why not some other messaging protocol?</h2>\n<p>There are a number of high quality and well maintained messaging protocols for\npassing messages between computers. I looked at MQTT, RabbitMQ, AMQP and ROS as\nalternatives. I chose ZMQ and its Python PyZMQ bindings for several reasons:</p>\n<ul>\n<li>ZMQ does not require a message broker. It is a peer to peer protocol that does\nnot need to pass an image first to a message broker and then to the imagehub.\nThis means fewer running processes and less \u201cdouble handling\u201d of images.\nOpenCV images are large compared to simple text messages, so the absence of a\nmessage broker is important.</li>\n<li>ZMQ is very fast for passing OpenCV images. It enables high throughput between\nimage senders and image hubs.</li>\n<li>ZMQ and its PyZMQ bindings are easy to install.</li>\n</ul>\n<p><strong>imagezmq</strong> has been transporting images from a dozen Raspberry Pi computers\nscattered around my farm to 2 linux image hub servers for over 2\nyears. The RPi\u2019s capture and send dozens to thousands of frames frames a day.\n<strong>imagezmq</strong> has worked very reliably and is very fast. You can learn more about\nmy \u201cscience experiment urban permaculture farm\u201d project at\n<a href=\"https://github.com/jeffbass/yin-yang-ranch\" rel=\"nofollow\">Yin Yang Ranch project overview</a>.</p>\n</div>\n<div id=\"messaging-patterns-req-rep-versus-pub-sub\">\n<h2>Messaging Patterns: REQ/REP versus PUB/SUB</h2>\n<p>ZMQ allows many different messaging patterns. Two are implemented in <strong>imagezmq</strong>:</p>\n<ul>\n<li>REQ/REP: Each RPi sends an image and waits for a REPLY from the central image\nhub. The RPi sends a new image only when the REPLY is received. In the REQ/REP\nmessaging pattern, each image sender must await a REPLY before continuing. It is a\n\u201cblocking\u201d pattern for the sender.</li>\n<li>PUB/SUB: Each RPi sends an image, but does not expect a REPLY from the central\nimage hub. It can continue sending images without awaiting any acknowledgement\nfrom the image hub. The image hub provides no REPLY. It is a \u201cnon-blocking\u201d\npattern for the sender.</li>\n</ul>\n<p>There are advantages and disadvantages for each pattern.\n<strong>REQ/REP is the default.</strong> See the documentation (link below) for more details.</p>\n</div>\n<div id=\"dependencies-and-installation\">\n<h2>Dependencies and Installation</h2>\n<p><strong>imagezmq</strong> has been tested with:</p>\n<ul>\n<li>Python 3.5, 3.6, 3.7 and 3.8</li>\n<li>PyZMQ 16.0 and 17.1</li>\n<li>Numpy 1.13 and 1.16</li>\n<li>OpenCV 3.3 and 4.0</li>\n<li>Raspbian Buster, Raspbian Stretch and Raspbian Jessie</li>\n<li>picamera 1.13 (used to capture images for the tests)</li>\n<li>imutils 0.4.6 and 0.5.2 (used to capture images from PiCamera)</li>\n</ul>\n<p>Install OpenCV, including Numpy, into a Python Virtual Environment. Then be sure\nto install <strong>imagezmq</strong> into the <strong>same</strong> virtual environment. For example, if\nthe virtual environment is named <strong>py3cv3</strong>, you would install <strong>imagezmq</strong>\nusing pip like this:</p>\n<pre>workon py3cv3  <span class=\"c1\"># use your virtual environment name\n</span>pip install imagezmq\n</pre>\n<p><strong>imagezmq</strong> has a directory of tests organized into sender and receiver pairs.\nYou will get all the source code for <strong>imagezmq</strong> including all the test\nprograms by cloning the GitHub repository:</p>\n<pre>git clone https://github.com/jeffbass/imagezmq.git\n</pre>\n</div>\n<div id=\"source-code-and-full-documentation\">\n<h2>Source Code and Full Documentation</h2>\n<p><strong>imagezmq</strong> is open source. The source code, tests and\ndocumentation are at <a href=\"https://github.com/jeffbass/imagezmq\" rel=\"nofollow\">Imagezmq on GitHub</a>.\nThe documentation, including links to application examples,\nstarts from the table of contents in the README.</p>\n</div>\n\n          </div>"}, "last_serial": 6580527, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "5d516c265a6a08cd3ed41d9a560cb909", "sha256": "3d277bb52bcacf9a3c4aa5f3d0cb9eb83b1ec71d0afd10a02265c5c90a5c315a"}, "downloads": -1, "filename": "imagezmq-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "5d516c265a6a08cd3ed41d9a560cb909", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 8487, "upload_time": "2020-02-06T07:25:57", "upload_time_iso_8601": "2020-02-06T07:25:57.970849Z", "url": "https://files.pythonhosted.org/packages/f3/51/21d29d05135c03dea60bde7c0983f5c2250ff71c57f5ed3cdc4013b1637b/imagezmq-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "88e299e514b2cf00d5e0570f2b589ed3", "sha256": "97e3368e445993b219992863fb6b0f9add8fb4fb306ac6db88416a81937be327"}, "downloads": -1, "filename": "imagezmq-1.0.1.tar.gz", "has_sig": false, "md5_digest": "88e299e514b2cf00d5e0570f2b589ed3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 14460, "upload_time": "2020-02-06T07:26:00", "upload_time_iso_8601": "2020-02-06T07:26:00.446898Z", "url": "https://files.pythonhosted.org/packages/f2/50/f171ad9e2e019d5674feb73abb643c5961f3c8d926ee5a1949ee46c1cd4d/imagezmq-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5d516c265a6a08cd3ed41d9a560cb909", "sha256": "3d277bb52bcacf9a3c4aa5f3d0cb9eb83b1ec71d0afd10a02265c5c90a5c315a"}, "downloads": -1, "filename": "imagezmq-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "5d516c265a6a08cd3ed41d9a560cb909", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 8487, "upload_time": "2020-02-06T07:25:57", "upload_time_iso_8601": "2020-02-06T07:25:57.970849Z", "url": "https://files.pythonhosted.org/packages/f3/51/21d29d05135c03dea60bde7c0983f5c2250ff71c57f5ed3cdc4013b1637b/imagezmq-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "88e299e514b2cf00d5e0570f2b589ed3", "sha256": "97e3368e445993b219992863fb6b0f9add8fb4fb306ac6db88416a81937be327"}, "downloads": -1, "filename": "imagezmq-1.0.1.tar.gz", "has_sig": false, "md5_digest": "88e299e514b2cf00d5e0570f2b589ed3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 14460, "upload_time": "2020-02-06T07:26:00", "upload_time_iso_8601": "2020-02-06T07:26:00.446898Z", "url": "https://files.pythonhosted.org/packages/f2/50/f171ad9e2e019d5674feb73abb643c5961f3c8d926ee5a1949ee46c1cd4d/imagezmq-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:48 2020"}