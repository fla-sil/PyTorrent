{"info": {"author": "Andrew Pashkin", "author_email": "andrew.pashkin@gmx.co.uk", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Topic :: Database", "Topic :: Software Development :: Libraries", "Topic :: Utilities"], "description": "=====\nTempo\n=====\n\n.. image:: https://travis-ci.org/AndrewPashkin/python-tempo.svg?branch=master\n   :alt: Build Status\n   :target: https://travis-ci.org/AndrewPashkin/python-tempo\n\n.. image:: https://coveralls.io/repos/AndrewPashkin/python-tempo/badge.svg?branch=master&service=github\n   :alt: Coverage\n   :target: https://coveralls.io/github/AndrewPashkin/python-tempo?branch=master\n\nThis project provides a generic way to compose and query schedules of\nrecurrent continuous events, such as working time of organizations, meetings,\nmovie shows, etc.\n\nIt contains a Python implementation and bindings for PostgreSQL,\nDjango and Django REST Framework.\n\nLinks\n=====\n:PyPI: https://pypi.python.org/pypi/python-tempo\n:Documentation: https://python-tempo.readthedocs.org/\n:Issues: https://github.com/AndrewPashkin/python-tempo/issues/\n:Code: https://github.com/AndrewPashkin/python-tempo/\n\nFeatures\n========\n- Flexible schedule model, that can express shcedules, that other libraries\n  can't.\n- Queries: containment of a single timestamp, future occurences.\n- Bindings:\n\n  * PostgreSQL\n\n    + Domain type for storing schedules\n    + Procedures for performing tests on them\n      (timestamp containment, future occurences).\n\n  * Django\n\n    + Model field\n    + Custom lookups\n      (timestamp containment,\n      intersection with interval between two timestamps,\n      test if scheduled event occurs within given interval\n      between two timestamps).\n\n  * Django-REST-Framework\n\n    + Serializer field for serializing and deserializing schedules.\n\nQuick example\n=============\nJust a short example, which shows, how to construct and query a schedule.\n::\n\n   >>> import datetime as dt\n   >>> from itertools import islice\n   >>> from tempo.recurrenteventset import RecurrentEventSet\n   >>> recurrenteventset = RecurrentEventSet.from_json(\n   ...     ('OR',\n   ...         ('AND', [1, 5, 'day', 'week'], [10, 19, 'hour', 'day']),\n   ...         ('AND', [5, 6, 'day', 'week'], [10, 16, 'hour', 'day']))\n   ... )  # 10-19 from Monday to Thursday and 10-16 in Friday\n   >>> d1 = dt.datetime(year=2000, month=10, day=5, hour=18)\n   >>> d1.weekday()  # Thursday\n   3\n   >>> d1 in recurrenteventset\n   True\n   >>> d2 = dt.datetime(year=2000, month=10, day=6, hour=18)\n   >>> d2.weekday()  # Friday\n   4\n   >>> d2 in recurrenteventset\n   False\n   >>> d = dt.datetime(year=2000, month=1, day=1)\n   >>> list(islice(recurrenteventset.forward(start=d), 3))\n   [(datetime.datetime(2000, 1, 3, 10, 0),\n     datetime.datetime(2000, 1, 3, 19, 0)),\n    (datetime.datetime(2000, 1, 4, 10, 0),\n     datetime.datetime(2000, 1, 4, 19, 0)),\n    (datetime.datetime(2000, 1, 5, 10, 0),\n     datetime.datetime(2000, 1, 5, 19, 0))]\n\n.. _readme-schedule-model:\n\nSchedule model\n==============\n\nExample\n-------\n\nHere is an example of how Tempo represents schedules::\n\n    ('OR',\n            ('AND', [1, 5, 'day', 'week'], [10, 19, 'hour', 'day']),\n            ('AND', [5, 6, 'day', 'week'], [10, 16, 'hour', 'day'])))\n\nIt means \"from monday to thursday between 10am and 7pm and\nin friday between 10am and 4pm\".\n\nInformal definition\n-------------------\n\nBasic building block of schedule is a recurrent event,\nwhich is defined is such way::\n\n    [<start time>, <end time>, <time unit>, <recurrence unit>]\n\n`<start time>` and `<end time>` are numbers, that defines interval in\nwhich event takes it`s place. `<time unit>` defines a unit of measurement of\ntime for values of the interval. And `<recurrence unit>` defines how often\nthe interval repeats. `<time unit>` and `<recurrence unit>` values are time\nmeasurement units, such as 'second', 'hour', 'day', 'week', 'year', etc.\n`<recurrence unit>` also can be 'null', which means, that the interval doesn't\nrepeats in time, it just defines two points in time, that corresponds to\nstart and end points of the event.\n\nRecurrent events can be composed, using operators: union - `or`,\nintersection - `and` and negation - `not`.\n\nAlternatives\n============\n\n    - python-dateutil_\n    - croniter_\n\n.. _python-dateutil: https://labix.org/python-dateutil\n.. _croniter: https://github.com/kiorky/croniter\n\nTODO\n====\n\n1. More tests for ``RecurrentEventSet``.\n2. Implement negative indexing for schedules - indexing from an end of a day\n   or month, etc. It will make library able to model schedules like\n   \"last friday of the month\".", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/AndrewPashkin/python-tempo/", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "python-tempo", "package_url": "https://pypi.org/project/python-tempo/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/python-tempo/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/AndrewPashkin/python-tempo/"}, "release_url": "https://pypi.org/project/python-tempo/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "Scheduling library, that provides a generic way to compose and query schedules of recurrent continuous events, such as working time of organizations, meetings, movie shows, etc.", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/AndrewPashkin/python-tempo\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/679c162860e6c81ea025c523493fb3e93085f2f5/68747470733a2f2f7472617669732d63692e6f72672f416e64726577506173686b696e2f707974686f6e2d74656d706f2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/AndrewPashkin/python-tempo?branch=master\" rel=\"nofollow\"><img alt=\"Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0606d4fb437d039234b40cb12cd0f59193424aab/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f416e64726577506173686b696e2f707974686f6e2d74656d706f2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562\"></a>\n<p>This project provides a generic way to compose and query schedules of\nrecurrent continuous events, such as working time of organizations, meetings,\nmovie shows, etc.</p>\n<p>It contains a Python implementation and bindings for PostgreSQL,\nDjango and Django REST Framework.</p>\n<div id=\"links\">\n<h2>Links</h2>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>PyPI:</th><td><a href=\"https://pypi.python.org/pypi/python-tempo\" rel=\"nofollow\">https://pypi.python.org/pypi/python-tempo</a></td>\n</tr>\n<tr><th>Documentation:</th><td><a href=\"https://python-tempo.readthedocs.org/\" rel=\"nofollow\">https://python-tempo.readthedocs.org/</a></td>\n</tr>\n<tr><th>Issues:</th><td><a href=\"https://github.com/AndrewPashkin/python-tempo/issues/\" rel=\"nofollow\">https://github.com/AndrewPashkin/python-tempo/issues/</a></td>\n</tr>\n<tr><th>Code:</th><td><a href=\"https://github.com/AndrewPashkin/python-tempo/\" rel=\"nofollow\">https://github.com/AndrewPashkin/python-tempo/</a></td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"features\">\n<h2>Features</h2>\n<ul>\n<li>Flexible schedule model, that can express shcedules, that other libraries\ncan\u2019t.</li>\n<li>Queries: containment of a single timestamp, future occurences.</li>\n<li>Bindings:<ul>\n<li>PostgreSQL<ul>\n<li>Domain type for storing schedules</li>\n<li>Procedures for performing tests on them\n(timestamp containment, future occurences).</li>\n</ul>\n</li>\n<li>Django<ul>\n<li>Model field</li>\n<li>Custom lookups\n(timestamp containment,\nintersection with interval between two timestamps,\ntest if scheduled event occurs within given interval\nbetween two timestamps).</li>\n</ul>\n</li>\n<li>Django-REST-Framework<ul>\n<li>Serializer field for serializing and deserializing schedules.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"quick-example\">\n<h2>Quick example</h2>\n<p>Just a short example, which shows, how to construct and query a schedule.</p>\n<pre>&gt;&gt;&gt; import datetime as dt\n&gt;&gt;&gt; from itertools import islice\n&gt;&gt;&gt; from tempo.recurrenteventset import RecurrentEventSet\n&gt;&gt;&gt; recurrenteventset = RecurrentEventSet.from_json(\n...     ('OR',\n...         ('AND', [1, 5, 'day', 'week'], [10, 19, 'hour', 'day']),\n...         ('AND', [5, 6, 'day', 'week'], [10, 16, 'hour', 'day']))\n... )  # 10-19 from Monday to Thursday and 10-16 in Friday\n&gt;&gt;&gt; d1 = dt.datetime(year=2000, month=10, day=5, hour=18)\n&gt;&gt;&gt; d1.weekday()  # Thursday\n3\n&gt;&gt;&gt; d1 in recurrenteventset\nTrue\n&gt;&gt;&gt; d2 = dt.datetime(year=2000, month=10, day=6, hour=18)\n&gt;&gt;&gt; d2.weekday()  # Friday\n4\n&gt;&gt;&gt; d2 in recurrenteventset\nFalse\n&gt;&gt;&gt; d = dt.datetime(year=2000, month=1, day=1)\n&gt;&gt;&gt; list(islice(recurrenteventset.forward(start=d), 3))\n[(datetime.datetime(2000, 1, 3, 10, 0),\n  datetime.datetime(2000, 1, 3, 19, 0)),\n (datetime.datetime(2000, 1, 4, 10, 0),\n  datetime.datetime(2000, 1, 4, 19, 0)),\n (datetime.datetime(2000, 1, 5, 10, 0),\n  datetime.datetime(2000, 1, 5, 19, 0))]\n</pre>\n</div>\n<div id=\"schedule-model\">\n<span id=\"readme-schedule-model\"></span><h2>Schedule model</h2>\n<div id=\"example\">\n<h3>Example</h3>\n<p>Here is an example of how Tempo represents schedules:</p>\n<pre>('OR',\n        ('AND', [1, 5, 'day', 'week'], [10, 19, 'hour', 'day']),\n        ('AND', [5, 6, 'day', 'week'], [10, 16, 'hour', 'day'])))\n</pre>\n<p>It means \u201cfrom monday to thursday between 10am and 7pm and\nin friday between 10am and 4pm\u201d.</p>\n</div>\n<div id=\"informal-definition\">\n<h3>Informal definition</h3>\n<p>Basic building block of schedule is a recurrent event,\nwhich is defined is such way:</p>\n<pre>[&lt;start time&gt;, &lt;end time&gt;, &lt;time unit&gt;, &lt;recurrence unit&gt;]\n</pre>\n<p><cite>&lt;start time&gt;</cite> and <cite>&lt;end time&gt;</cite> are numbers, that defines interval in\nwhich event takes it`s place. <cite>&lt;time unit&gt;</cite> defines a unit of measurement of\ntime for values of the interval. And <cite>&lt;recurrence unit&gt;</cite> defines how often\nthe interval repeats. <cite>&lt;time unit&gt;</cite> and <cite>&lt;recurrence unit&gt;</cite> values are time\nmeasurement units, such as \u2018second\u2019, \u2018hour\u2019, \u2018day\u2019, \u2018week\u2019, \u2018year\u2019, etc.\n<cite>&lt;recurrence unit&gt;</cite> also can be \u2018null\u2019, which means, that the interval doesn\u2019t\nrepeats in time, it just defines two points in time, that corresponds to\nstart and end points of the event.</p>\n<p>Recurrent events can be composed, using operators: union - <cite>or</cite>,\nintersection - <cite>and</cite> and negation - <cite>not</cite>.</p>\n</div>\n</div>\n<div id=\"alternatives\">\n<h2>Alternatives</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://labix.org/python-dateutil\" rel=\"nofollow\">python-dateutil</a></li>\n<li><a href=\"https://github.com/kiorky/croniter\" rel=\"nofollow\">croniter</a></li>\n</ul>\n</blockquote>\n</div>\n<div id=\"todo\">\n<h2>TODO</h2>\n<ol>\n<li>More tests for <tt>RecurrentEventSet</tt>.</li>\n<li>Implement negative indexing for schedules - indexing from an end of a day\nor month, etc. It will make library able to model schedules like\n\u201clast friday of the month\u201d.</li>\n</ol>\n</div>\n\n          </div>"}, "last_serial": 1784512, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "3598d9ef1c228505164f73e69964782b", "sha256": "620911043a366f7b81c9679261ada25177de6a3fa20b447721a730ac67213a1e"}, "downloads": -1, "filename": "python-tempo-0.1.0.tar.gz", "has_sig": false, "md5_digest": "3598d9ef1c228505164f73e69964782b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18321, "upload_time": "2015-10-24T19:11:56", "upload_time_iso_8601": "2015-10-24T19:11:56.022951Z", "url": "https://files.pythonhosted.org/packages/63/5b/de8c0e879fa47e69c35d38be1967c005e3061265f528b7a515cd74c84790/python-tempo-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3598d9ef1c228505164f73e69964782b", "sha256": "620911043a366f7b81c9679261ada25177de6a3fa20b447721a730ac67213a1e"}, "downloads": -1, "filename": "python-tempo-0.1.0.tar.gz", "has_sig": false, "md5_digest": "3598d9ef1c228505164f73e69964782b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18321, "upload_time": "2015-10-24T19:11:56", "upload_time_iso_8601": "2015-10-24T19:11:56.022951Z", "url": "https://files.pythonhosted.org/packages/63/5b/de8c0e879fa47e69c35d38be1967c005e3061265f528b7a515cd74c84790/python-tempo-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:02 2020"}