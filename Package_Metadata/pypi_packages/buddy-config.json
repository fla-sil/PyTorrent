{"info": {"author": "Ilya 'I159' Pekelny", "author_email": "pekelny@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7"], "description": "# buddy_config\nDecoupled and lazy library to get settings from an environment variables.\n\n## Motivation\nEnvironment variables are the most common way to configure projects, based on Docker,\nhosted on clouds e.t.c. In the end it is secure and simple way. So grab variables from\nan environment is the only feature of the package.\n\nFirst issue which becomes obvious at the simplest approach for getting environment\nvariables is that attempt to get the environment variables too early. For example an app\nis initialized by tests and you need different values for the settings at different\ntests. But if the values obtained in this way:\n\n__init__.py\n```\nimport os\n\nVAR_A = os.environ['VAR_A']\n```\n\nmodule_a.py\n\n```\nfrom . import *\n\ndef a():\n    b(VAR_A)\n```\n\ntest.py\n```\nfrom . import module_a\n\nclass Test(unittest.TestCase):\n    @mock.patch('os', 'environ', {\"VAR_A\": 1})\n    def test_a(self, env):\n        ...\n```\n\nthe values already loaded to the memory. Therefor mock will not work. And the most sad\npart that this issue is not solved in the most of advanced configuration libraries. So\nthis is the first issue which solved here by Buddy Config.\n\n## Getting started\n\nBuddy Config aims to be as declarative as possible.\n\n    import buddy_config\n\n\n    class MyConf(metaclass=buddy_config.Config):\n        NAME_OF_A_SETTING_A = \"NAME_OF_AN_ENVIRONMENT_VARIABLE_A\", str\n\nThis is minimum of declaration that you need to have a setting. Let's pale it out. The\nname of a class attribute is the name of the setting, exactly how you suppose to call it.\nA string at position 0 of the fallowing tuple is a name of an environment variable that\nyou are going to retrieve from the environment. And the type class at the position 1\nof the tuple is the type value after it retrieved from the environment. Both values are\nrequired.\n\nTo use the config you need to instantiate it:\n\n    my_conf = MyConfig()\n\n*The value is not going to be retrieved until you actually get the attribute from the \nconfig.*\n\n    print(my_config.NAME_OF_A_SETTING_A)\n\nAlso it is not cached.\n\n    os.environ[\"NAME_OF_AN_ENVIRONMENT_VARIABLE_A\"] = \"3\"\n    print(my_config.NAME_OF_A_SETTING_A)\n\nDefaults are flexible and could be different per instance of the config.\n\n    my_conf_a = MyConfig(NAME_OF_A_SETTING_A=1)\n    my_conf_b = MyConfig(NAME_OF_A_SETTING_A=2)\n\n    print(my_conf_a.NAME_OF_A_SETTING_A)\n    print(my_conf_b.NAME_OF_A_SETTING_A)\n\nMoreover, you can add pre-processing of retrieved values.\n\n\n    class MyConf(metaclass=Config):\n        NAME_OF_A_SETTING_C = \"NAME_OF_AN_ENVIRONMENT_VARIABLE_C\", int, lambda x: x ** 2\n\nThe optional items of the tuple are pre-processors. Pre-processor is a callable which\nmust return a value of int, float, string or bytes value.\n\nIf you need to create a combined setting using values from environment variables, no\nproblem, buddy config can do that:\n\n\n    class MyConf(metaclass=Config):\n        NAME_OF_A_SETTING_A = \"NAME_OF_AN_ENVIRONMENT_VARIABLE_A\", str\n        NAME_OF_A_SETTING_B = \"NAME_OF_AN_ENVIRONMENT_VARIABLE_B\", int\n        COMBINED_SETTING = (\n            lambda self: int(self.NAME_OF_A_SETTING_A) + self.NAME_OF_A_SETTING_B\n        )\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/I159/buddy_config", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "buddy-config", "package_url": "https://pypi.org/project/buddy-config/", "platform": "", "project_url": "https://pypi.org/project/buddy-config/", "project_urls": {"Homepage": "https://github.com/I159/buddy_config"}, "release_url": "https://pypi.org/project/buddy-config/0.1.0/", "requires_dist": null, "requires_python": "", "summary": "Lazy environment variable configuration of declarative style.", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>buddy_config</h1>\n<p>Decoupled and lazy library to get settings from an environment variables.</p>\n<h2>Motivation</h2>\n<p>Environment variables are the most common way to configure projects, based on Docker,\nhosted on clouds e.t.c. In the end it is secure and simple way. So grab variables from\nan environment is the only feature of the package.</p>\n<p>First issue which becomes obvious at the simplest approach for getting environment\nvariables is that attempt to get the environment variables too early. For example an app\nis initialized by tests and you need different values for the settings at different\ntests. But if the values obtained in this way:</p>\n<p><strong>init</strong>.py</p>\n<pre><code>import os\n\nVAR_A = os.environ['VAR_A']\n</code></pre>\n<p>module_a.py</p>\n<pre><code>from . import *\n\ndef a():\n    b(VAR_A)\n</code></pre>\n<p>test.py</p>\n<pre><code>from . import module_a\n\nclass Test(unittest.TestCase):\n    @mock.patch('os', 'environ', {\"VAR_A\": 1})\n    def test_a(self, env):\n        ...\n</code></pre>\n<p>the values already loaded to the memory. Therefor mock will not work. And the most sad\npart that this issue is not solved in the most of advanced configuration libraries. So\nthis is the first issue which solved here by Buddy Config.</p>\n<h2>Getting started</h2>\n<p>Buddy Config aims to be as declarative as possible.</p>\n<pre><code>import buddy_config\n\n\nclass MyConf(metaclass=buddy_config.Config):\n    NAME_OF_A_SETTING_A = \"NAME_OF_AN_ENVIRONMENT_VARIABLE_A\", str\n</code></pre>\n<p>This is minimum of declaration that you need to have a setting. Let's pale it out. The\nname of a class attribute is the name of the setting, exactly how you suppose to call it.\nA string at position 0 of the fallowing tuple is a name of an environment variable that\nyou are going to retrieve from the environment. And the type class at the position 1\nof the tuple is the type value after it retrieved from the environment. Both values are\nrequired.</p>\n<p>To use the config you need to instantiate it:</p>\n<pre><code>my_conf = MyConfig()\n</code></pre>\n<p><em>The value is not going to be retrieved until you actually get the attribute from the\nconfig.</em></p>\n<pre><code>print(my_config.NAME_OF_A_SETTING_A)\n</code></pre>\n<p>Also it is not cached.</p>\n<pre><code>os.environ[\"NAME_OF_AN_ENVIRONMENT_VARIABLE_A\"] = \"3\"\nprint(my_config.NAME_OF_A_SETTING_A)\n</code></pre>\n<p>Defaults are flexible and could be different per instance of the config.</p>\n<pre><code>my_conf_a = MyConfig(NAME_OF_A_SETTING_A=1)\nmy_conf_b = MyConfig(NAME_OF_A_SETTING_A=2)\n\nprint(my_conf_a.NAME_OF_A_SETTING_A)\nprint(my_conf_b.NAME_OF_A_SETTING_A)\n</code></pre>\n<p>Moreover, you can add pre-processing of retrieved values.</p>\n<pre><code>class MyConf(metaclass=Config):\n    NAME_OF_A_SETTING_C = \"NAME_OF_AN_ENVIRONMENT_VARIABLE_C\", int, lambda x: x ** 2\n</code></pre>\n<p>The optional items of the tuple are pre-processors. Pre-processor is a callable which\nmust return a value of int, float, string or bytes value.</p>\n<p>If you need to create a combined setting using values from environment variables, no\nproblem, buddy config can do that:</p>\n<pre><code>class MyConf(metaclass=Config):\n    NAME_OF_A_SETTING_A = \"NAME_OF_AN_ENVIRONMENT_VARIABLE_A\", str\n    NAME_OF_A_SETTING_B = \"NAME_OF_AN_ENVIRONMENT_VARIABLE_B\", int\n    COMBINED_SETTING = (\n        lambda self: int(self.NAME_OF_A_SETTING_A) + self.NAME_OF_A_SETTING_B\n    )\n</code></pre>\n\n          </div>"}, "last_serial": 5498195, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "3dd88baa9aa53103ed00d5d7244ddd07", "sha256": "90b93e0df85e39512a47a4a9230436da0fbc8183d05b149b00e162ef9201520d"}, "downloads": -1, "filename": "buddy_config-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "3dd88baa9aa53103ed00d5d7244ddd07", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16536, "upload_time": "2019-07-07T21:52:31", "upload_time_iso_8601": "2019-07-07T21:52:31.244817Z", "url": "https://files.pythonhosted.org/packages/a7/b4/75d397247a797c15436563576f05b15019a20f2dd402cfc79d6967b0811b/buddy_config-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "99501105ee9e49fb871aed6e526cc200", "sha256": "54cac2238922538ff82a0a6b5e9db8803c0e66e6aa0181198824c4e373573cc3"}, "downloads": -1, "filename": "buddy-config-0.1.0.tar.gz", "has_sig": false, "md5_digest": "99501105ee9e49fb871aed6e526cc200", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4019, "upload_time": "2019-07-07T21:52:33", "upload_time_iso_8601": "2019-07-07T21:52:33.364522Z", "url": "https://files.pythonhosted.org/packages/42/b7/cc3539bdefba025d269e686c0c87012458746b63cafbbcf69586cd86a96f/buddy-config-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3dd88baa9aa53103ed00d5d7244ddd07", "sha256": "90b93e0df85e39512a47a4a9230436da0fbc8183d05b149b00e162ef9201520d"}, "downloads": -1, "filename": "buddy_config-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "3dd88baa9aa53103ed00d5d7244ddd07", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16536, "upload_time": "2019-07-07T21:52:31", "upload_time_iso_8601": "2019-07-07T21:52:31.244817Z", "url": "https://files.pythonhosted.org/packages/a7/b4/75d397247a797c15436563576f05b15019a20f2dd402cfc79d6967b0811b/buddy_config-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "99501105ee9e49fb871aed6e526cc200", "sha256": "54cac2238922538ff82a0a6b5e9db8803c0e66e6aa0181198824c4e373573cc3"}, "downloads": -1, "filename": "buddy-config-0.1.0.tar.gz", "has_sig": false, "md5_digest": "99501105ee9e49fb871aed6e526cc200", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4019, "upload_time": "2019-07-07T21:52:33", "upload_time_iso_8601": "2019-07-07T21:52:33.364522Z", "url": "https://files.pythonhosted.org/packages/42/b7/cc3539bdefba025d269e686c0c87012458746b63cafbbcf69586cd86a96f/buddy-config-0.1.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:36:07 2020"}