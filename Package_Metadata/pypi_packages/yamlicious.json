{"info": {"author": "UNKNOWN", "author_email": "UNKNOWN", "bugtrack_url": null, "classifiers": [], "description": "\n.. image:: https://api.travis-ci.org/derrley/yamlicious.png\n  :target: https://travis-ci.org/derrley/yamlicious\n\nYamlicious is a (work-in-progress) lightweight configuration library built on\ntop of YAML. It's for folks who love to write their configuration files in\nYAML, but who find themselves writing additional boilerplate each time they\nwant to use YAML to encode a configuration file.\n\nIn addition to a parser, yamlicious provides code that:\n\n- Validates the correctness of a file and prints an understandable failure\n  message when the file doesn't quite match\n\n- Understands your environemnt, and allows you to configure different properties\n  for different environment dimensions without unnecessary DRY-violation\n\n- Reads configuration from multiple files\n\n- Provides a cascading set of configuration sources, including environment\n  variables\n\n- Lazily loads certain parts of a large configuration. (read: when your\n  \"configuration\" really starts to feel more like \"data.\")\n\n- Is generically extensible to new behavior, just in case you need to add\n  something we haven't thought of\n\nYamlicious does all this by being like any other YAML parser, but by treating a\nhandful of specific keys in a special way. It can be configured to recognize\nand evaluate any subset of these *feature keys*, allowing a developer to bake\nin as much (or as little!) of the crazy capabilities as seems reasonable for\nthe situation. (The craziest stuff is turned off by default.)\n\nSkip to `Feature Key Definitions`_ if you want the formality without the\nEnglish verbiage.\n\n.. contents::\n\n\nThe Yamlicious File\n====================\n\nA configuration file specified in Yamlicious *is just YAML*. In fact, nothing stops\nyou from parsing a Yamlicious file with any YAML library. This can be useful for\nsearching, cleaning, or editing (with syntax highlighting) the file.\n\nEnvironment Variable Subtitution\n---------------------------------\n\nYamlicious gives your configuration file automatic access to the environment. \n\n.. code-block:: yaml\n\n  some:\n    key:\n      user_$(USER): not cool\n      user_kyle: cool\n\nDon't worry. The Yamlicious API gives you (the developer) the ability to both\nlimit the environment variables your configuration file is allowed to access\nand provide overriding values for anything in the environment. You're neither\nforced to use environment variables nor doomed to a free for all.\n\nYamlicious supports list values in the environment, and splits environment variables\non the comma character. If a Yamlicious file substitutes a list variable into a\nstring, that string renders into multiple strings (one for each value in the\nlist variable).\n\nIf a string references a variable that's not in the environment, yamlicious\ndoes not modify the string. It will leave the variable reference alone, ``$()``\ncharacters included. This makes string substitution have a neat property -- it\ncan be applied to the same document iteratively as the environment grows.\n\nList substitution behavior varies subtly by situation.\n\n\nWhen substituting into a single value string\n````````````````````````````````````````````\n\n.. code-block:: yaml\n\n  some_list: $(MY_LIST)\n\nrenders to the following, if ``MY_LIST=one,two,three`` is in the environment.\n\n.. code-block:: yaml\n\n  some_list:\n    - one\n    - two\n    - three\n\n\nWhen substituting into a value list\n```````````````````````````````````\n\n.. code-block:: yaml\n\n  some_list:\n    - first\n    - $(LIST)\n\nbecomes\n\n.. code-block:: yaml\n\n  some_list:\n    - first\n    - one\n    - two\n    - three\n\n\nWhen substituting into a key string\n```````````````````````````````````\n\nKey strings are special, because you almost certainly don't intend to make a\nlist into the key of a dictionary. Instead, you likely mean to define a key in\nthe dictionary for each item in the list. Yamlicious provides a special\nvariable in the environment, ``_KEY``, to help you out in this situation.\n\n.. code-block:: yaml\n\n  $(LIST): $(_KEY) is in the list!\n\nbecomes\n\n.. code-block:: yaml\n\n  one: one is in the list\n  two: two is in the list\n  three: three is in the list\n\n``_KEY`` is set to the first-level key in the document, regardless of whether\nthe key was derived from string substitution. To get the second-level key, use\n``__KEY``, and so forth:\n\n.. code-block:: yaml\n\n  $(LIST):\n    second_level_key: $(_KEY) on top and $(__KEY) on bottom\n\nbecomes\n\n.. code-block:: yaml\n\n  one:\n    second_level_key: one on top and second_level_key on bottom\n  two:\n    second_level_key: two on top and second_level_key on bottom\n  three:\n    second_level_key: three on top and second_level_key on bottom\n\n\nWhen substituting multiple list values into the same string\n````````````````````````````````````````````````````````````\n\nThis is interpreted as a dot product. Yamlicious will substitute every\ncombination of variables between the two lists.\n\nIf ``BOYS=joey,johnny,bobby`` and ``GIRLS=sally,mary`` then:\n\n.. code-block:: yaml\n\n  \"$(BOYS) likes $(GIRLS)\"\n\nbecomes:\n\n.. code-block:: yaml\n\n  - joey likes sally\n  - joey likes mary\n  - johnny likes sally\n  - johnny likes mary\n  - bobby likes sally\n  - bobby likes mary\n\nNote -- the rest of the \"positional\" list substitution rules (defined in the\nimmediately previous sections) apply to dot product substitutions.\n\n\nLoad Another File\n----------------------\n\nSometimes, it makes sense to define sub-configuration somewhere outside the\nmain configuration file. (e.g., secrets go somewhere special.) Yamlicious gives\nyou the `insert`_ key to accomplish this.\n\nNote: `insert_` is a *functional feature key*. (Defined more in the `Functional\nFeature Keys`_ section.) These are keys that participate in something like a\nfunction call -- the entire map that contains a functional key evaluates to\nfunctional behavior applied to the key's value. (No project is complete without\na smidge of functional programming.) You can only use one of these keys in a\nmap at a time because yamlicious replaces the key-containing map with a\ndocument -- the result of the function applied to the key's value. Multiple\nkeys is an abiguous definition.\n\n.. code-block:: yaml\n\n  some_place:\n    placed_here:\n      _insert: other/file.yaml\n\nIn this case, the rendered YAML output of ``other/file.yaml`` is placed under\nthe ``placed_here`` key.\n\n.. code-block:: yaml\n\n  some_place:\n    placed_here:\n      contents of:\n        - that other file\n        - which can be arbitrary YAML\n\nYou can use variable substitution with the `insert`_ feature to get conditional\nconfiguration.\n\n.. code-block:: yaml\n\n  user_settings:\n    _insert: $(USER)/conf.yaml\n\n\nMerge\n---------------\n\nYamlicious allows you to *merge* an external file into a bit of config.\n\n.. code-block:: yaml\n\n  merged_settings:\n    _merge:\n      - some_list: ['thing']\n        some_thing: 'thing'\n\n      - _insert: some_other_place.yaml\n\nWhen you ask Yamlicious to do this, it will use a strategy I call *safe deep merge\nwith list append*. Yamlicious merges dictionaries recursively by combining their\nkey-value pairs. It merges lists by list addition. It refuses, however, to\nmerge anything else. (Anything else would be shoot-self-in-foot territory, and\nI'd rather not encourage it.)\n\nif ``some_other_place.yaml`` looked like this:\n\n.. code-block:: yaml\n\n  some_list: ['second_thing']\n  some_other_thing: 'thing'\n\n\nThe above configuration would render as follows:\n\n.. code-block:: yaml\n\n  merged_settings:\n    some_list: ['thing', 'second_thing']\n    some_thing: 'thing'\n    some_other_thing: 'thing'\n\nIf you're looking to implement the common *default override* pattern, specify\n`The Default Document`_ as part of the Yamlicious API. That feature is specifically\nbuilt to help you not have to allow arbitrary overrides when including files.\nIf you absolutely must allow overrides, use the `merge_override`_ keyword,\nbut note that it is turned off by default.\n\nInsert and Merge\n------------------\n\nLoading several files and merging them is a common pattern, and it would be\nnice if folks didn't have to be verbose if that's the behavior they're looking\nfor. This is what the `insert_merge`_ key is for.\n\n.. code-block:: yaml\n\n  merged_stuff:\n    _insert_merge:\n      - first/place.yaml\n      - second/place.yaml\n      - third/place.yaml\n\nThis key will load each file in order and merge that file into the previous\nfile.\n\n\n\nMerging Entire Documents\n-------------------------\n\nIf you'd like to merge an entire document with your own, use the `include`_\nfeature key.\n\nNote: `include`_ is a *document feature key*. (Defined more in the `Document\nFeature Keys`_ section.) Unlike functional feature keys, which apply behavior\nto any map embedded anywhere in the document hierarchy, document feature keys\napply behavior to the entire document, and therefore must exist at the top of\nthe YAML document.\n\n\nChanging the Environment\n-------------------------\n\nYou can also use the `env`_ document key to place new variables into the\nenvironment.\n\n.. code-block:: yaml\n\n  _env:\n    COOLEST_PERSON: kyle\n\nThese variables can be used either in *the same document* (although the utility\nof that is not immediately obvious, other than for mitigating DRY violation)\nor, more importantly, *in documents that include it*. Yamlicious supports this\nby taking special care to re-run string substitution each time it changes a\ndocument's environment. (Remember, string substitution is idempotent.)\n\nThis behavior is somewhat dangerous if the included document defines a variable\nthat's already defined in the including document. If the including document\nuses string subtitution to define included document paths, those substitutions\ncan happen using only the *initial* version of the environment (before it is\nmutated by the act of inclusion). If the included document then changes any key\nthat's used in the process of inclusion, things get hard to reason about.\n\nRather than allow such craziness, Yamlicious bans it. That is, it does not\nallow multiple documents included in the same parent document to define\ndiffering versions of the same environment variable. It does allow actual\nenvironment variables to coexist with (and override) those defined in `env`_.\nNot allowing this would be brittle and would remove a very common use case,\nwhere setting an environment variable changes some sort of important behavior.\n\n\nThe Default Document\n---------------------\n\nYamlicious merge-overrides the configuration document it renders with a\n*default document* that it is configured to use.\n\nThis is the only place that, by default, uses the merge-override (rather than\nsafe merge) behavior. For that reason, it's best to use the default document\nfeature to specify override behavior. If you're wanting override behavior that\ncan't be done by using the default document, chances are you're doing something\nthat's either too complex or wrong. If you insist, there's always\n`merge_override`_.\n\n\nFunctional Conditional Keys\n---------------------------------\n\nTo specify a condition in-line, you can use the *functional conditional*\nfeature keys (`case`_ and `cond`_), each inspired by Lisp. This adds a bit too\nmuch Turing completeness to the project for the taste of most, so these are\ndisabled by default.\n\n.. code-block:: yaml\n\n  case_configuration:\n    '_case':\n      - '$(USER)'\n      - {'kyle': 'is awesome'}\n      - {'_otherwise': 'is not awesome'}\n  cond_configuration:\n    '_cond':\n      - {\"$(ENV) in ['test', 'prod']\": 'go!'}\n      - {true: 'undefined'}\n\nNote the use of the python expression. This is mostly for convenience and\nterseness. Nobody wants to write a boolean expression in YAML, and I don't\nparticularly want to implement it, either, so Yamlicious ``eval()`` s every single\nstring that it finds below either functional conditional key.\n\n\nList substitution works in both kinds of functional conditional. For example,\nif ``GOOD_USERS=kyle,anthony``, then the following expression\n\n.. code-block:: yaml\n\n  access_configuration:\n    '_case':\n      - {'$(GOOD_USERS)': 'go!'}\n      - {'_otherwise':  'stay. :('}\n\nevaluates to\n\n.. code-block:: yaml\n\n  access_configuration:\n    '_case':\n      - {'kyle': 'go!',\n         'anthony': 'go!'}\n      - ['_otherwise',  'stay. :(']\n\nYamlicious is careful to \"do the right thing\" here. While there is no defined\norder in how it matches either the key ``'anthony'`` or ``'kyle'``, it will try\nto match both before falling back to the `otherwise`_ key.\n\nBe careful to not do something like this unless you really mean it:\n\n.. code-block:: yaml\n\n  access_configuration:\n    '_case':\n      - {'$(GOOD_USERS)': '$(_KEY)'}\n      - {'_otherwise':  'stay. :('}\n\nWhile it will technically work, Yamlicious offers no definition for what the\nabove expression evaluates to -- the order of iteration for a map/dictionary is\nan implementation detail.\n\n\nLazy Loading\n--------------\n\nIf you notice an explosion in the number of Yamlicious files that your program\nincludes, and you also notice that only a few of them ever get used, you'll\nlikely want to conditionally load said files only when they're needed. Yamlicious\nprovides two lazy loading keys to help you with this.\n\nThe `lazy`_ key changes nothing about the semantic meaning of the document it\npoints to. It does change the time when functional key evaluation happens.\nYamlicious evaluates embedded functional keys at *lookup time*, rather than\nduring the depth-first functional key evaluation of the entire document.\n\nIn this example\n\n.. code-block:: yaml\n\n  _lazy:\n    one:\n      _insert: some/other/file.yaml\n\nThe `insert`_ evaluation happens only when someone tries to look at the\n``one`` key.\n\nThe `lazy_lookup`_ key delays functional key evaluation just like `lazy`_, and\nit also allows you to use string substitution of the special variable\n``$(_KEY)`` to define how every key in the document is looked up. Rather than\ndefining a document for *every key* in the map, you define *one expression*\nthat, after string subtitution, can evaluate to *any key*.\n\nTo get the most power, pair lazy lookup with file inclusion. Here's an example\ninspired by YAML configuration of SQL tables.\n\n.. code-block:: yaml\n\n  tables:\n    _lazy_lookup:\n      _insert_merge:\n        - generic/schema/$(_KEY).table.yaml\n        - $(SYSTEM)/schema/$(_KEY).table.yaml\n        - $(INSTITUTION)/schema/$(_KEY).table.yaml\n\nNote that there's nothing that prevents lazy-loaded documents from merging with\none another. If you're feeling particularly masochistic, you can define this\nconfusing yet equivalent thing.\n\n.. code-block:: yaml\n\n  tables:\n    _merge:\n      - _lazy_lookup:\n          _insert_merge:\n            - generic/schema/$(_KEY).table.yaml\n            - $(SYSTEM)/schema/$(_KEY).table.yaml\n      - _lazy_lookup:\n          _insert_merge:\n            - $(INSTITUTION)/schema/$(_KEY).table.yaml\n\nOrder Of Operations\n====================\n\nYamlicious goes through the following phases when processing a document:\n\n1. String substitution.\n2. Document key evaluation.\n3. String substitution.\n4. Functional key evaluation (depth-first).\n\n\nFeature Key Definitions\n========================\n\nEnough with your words. Let's define this stuff explicitly.\n\nDocument Feature Keys\n------------------------\n\nThese keys must be placed at the *top* level of a document, and affect the\nentire document that they're placed inside. They disappear when rendered.\n\n\nenv \n````````````````````````````````\n\n.. code-block:: yaml\n\n  _env:\n    <variable>: <value>\n    ...\n\nSets document environment variables to given values.\n\ninclude\n`````````````````\n\n.. code-block:: yaml\n\n  _include:\n    - <file-path>\n    - <file-path>\n    - ...\n\nLoads and safe-merges several files into the document.\n\n\nFunctional Feature Keys\n------------------------\n\nThe key must exist by itself in its containing dictionary. The feature key,\nitself, describes a transformation operation on the given document. \n\n.. code-block:: yaml\n\n  _<feature-key>: <document>\n\n\n\ninsert\n````````````````````````````````\n\n.. code-block:: yaml\n\n  _insert <file-path>\n\nEvaluates to the loaded and processed configuration document found at\n``file_path``.\n\n\nmerge\n````````````````````````````````\n\n.. code-block:: yaml\n\n  _merge: [ <document>, <document>, ... ]\n\nUses safe-merge-with-list-append to merge given documents together. Can safely\nmerge dictionaries and lists, but nothing else.\n\n\nmerge_override\n````````````````````````````````\n\n.. code-block:: yaml\n\n  _merge_override: [ <document>, <document>, ... ]\n\nUses deep-merge to merge given documents together. Can safely merge anything.\nFor scalar values, documents further down the list override documents earlier\nin the list.\n\n\ninsert_merge\n````````````````````````````````\n\n.. code-block:: yaml\n\n  _insert_merge [ <file-path>, <file-path>, ... ]\n\nLoads files and then merges them with safe-merge-with-list-append.\n\n\ncase\n````````````````````````````````\n(NOT IMPLEMENTED)\n\n.. code-block:: yaml\n\n  '_case':\n    - <key-python-expression>\n    - {<match-python-expression>, <outcome-python-expression>}\n    ...\n\nFunctional case. Evaluates to the first outcome expression whose match\nexpression is python-equal to the key expression.\n\n\notherwise\n````````````````````````````````\n(NOT IMPLEMENTED)\n\n.. code-block:: yaml\n\n    '_otherwise': <expression>\n\nEvaluates to a case condition that always matches.\n\n\ncond\n````````````````````````````````\n(NOT IMPLEMENTED)\n\n.. code-block:: yaml\n\n    '_cond':\n      - {<boolean-python-expression>, <outcome-python-expression>}\n      ...\n\nFunctional cond. Evaluates to the first outcome expression whose boolean\nexpression is true.\n\n\nlazy\n````````````````````````````````\n(NOT IMPLEMENTED)\n\n.. code-block:: yaml\n\n    '_lazy': <document>\n\nEvaluates to document, but where each of the keys in document is lazy-loaded.\n\n\nlazy_lookup\n````````````````````````````````\n(NOT IMPLEMENTED)\n\n.. code-block:: yaml\n\n    '_lazy_lookup': <value-expression>\n\nEvaluates to a lazy-loaded dictionary, where every key is evaluated at lookup\ntime by evaluating the value-expression, which is allowed to use the ``_KEY``\nenvironment variable\n\n\nThe Validator\n==============\n\nTBD\n\nThe Command\n====================\n\nYamlicious comes with a convenient command, ``yamlicious``, that reads input\nfrom stdin and writes to stdout. It uses a default configuration, along with\nall environment variables, in order to process the yaml document fed to it on\nstandard in::\n\n  [10:49:46][kderr@Kyles-MacBook-Pro][~/Repositories/derrley/yamlicious]\n  $ cat /tmp/test\n  Hello: \"$(PWD) is the current wd\"\n\n\n  [10:49:52][kderr@Kyles-MacBook-Pro][~/Repositories/derrley/yamlicious]\n  $ cat /tmp/test | yamlicious\n  {Hello: /Users/kderr/Repositories/derrley/yamlicious is the current wd}\n\n\nThe API\n=================\n\nTBD\n\nCustom Feature Keys\n====================\n\nTBD\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "yamlicious", "package_url": "https://pypi.org/project/yamlicious/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/yamlicious/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/yamlicious/0.0.0/", "requires_dist": null, "requires_python": null, "summary": "UNKNOWN", "version": "0.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/derrley/yamlicious\" rel=\"nofollow\"><img alt=\"https://api.travis-ci.org/derrley/yamlicious.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b165e65cde8dde22486555e9850c234d2701e271/68747470733a2f2f6170692e7472617669732d63692e6f72672f646572726c65792f79616d6c6963696f75732e706e67\"></a>\n<p>Yamlicious is a (work-in-progress) lightweight configuration library built on\ntop of YAML. It\u2019s for folks who love to write their configuration files in\nYAML, but who find themselves writing additional boilerplate each time they\nwant to use YAML to encode a configuration file.</p>\n<p>In addition to a parser, yamlicious provides code that:</p>\n<ul>\n<li>Validates the correctness of a file and prints an understandable failure\nmessage when the file doesn\u2019t quite match</li>\n<li>Understands your environemnt, and allows you to configure different properties\nfor different environment dimensions without unnecessary DRY-violation</li>\n<li>Reads configuration from multiple files</li>\n<li>Provides a cascading set of configuration sources, including environment\nvariables</li>\n<li>Lazily loads certain parts of a large configuration. (read: when your\n\u201cconfiguration\u201d really starts to feel more like \u201cdata.\u201d)</li>\n<li>Is generically extensible to new behavior, just in case you need to add\nsomething we haven\u2019t thought of</li>\n</ul>\n<p>Yamlicious does all this by being like any other YAML parser, but by treating a\nhandful of specific keys in a special way. It can be configured to recognize\nand evaluate any subset of these <em>feature keys</em>, allowing a developer to bake\nin as much (or as little!) of the crazy capabilities as seems reasonable for\nthe situation. (The craziest stuff is turned off by default.)</p>\n<p>Skip to <a href=\"#feature-key-definitions\" rel=\"nofollow\">Feature Key Definitions</a> if you want the formality without the\nEnglish verbiage.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#the-yamlicious-file\" id=\"id2\" rel=\"nofollow\">The Yamlicious File</a><ul>\n<li><a href=\"#environment-variable-subtitution\" id=\"id3\" rel=\"nofollow\">Environment Variable Subtitution</a><ul>\n<li><a href=\"#when-substituting-into-a-single-value-string\" id=\"id4\" rel=\"nofollow\">When substituting into a single value string</a></li>\n<li><a href=\"#when-substituting-into-a-value-list\" id=\"id5\" rel=\"nofollow\">When substituting into a value list</a></li>\n<li><a href=\"#when-substituting-into-a-key-string\" id=\"id6\" rel=\"nofollow\">When substituting into a key string</a></li>\n<li><a href=\"#when-substituting-multiple-list-values-into-the-same-string\" id=\"id7\" rel=\"nofollow\">When substituting multiple list values into the same string</a></li>\n</ul>\n</li>\n<li><a href=\"#load-another-file\" id=\"id8\" rel=\"nofollow\">Load Another File</a></li>\n<li><a href=\"#merge\" id=\"id9\" rel=\"nofollow\">Merge</a></li>\n<li><a href=\"#insert-and-merge\" id=\"id10\" rel=\"nofollow\">Insert and Merge</a></li>\n<li><a href=\"#merging-entire-documents\" id=\"id11\" rel=\"nofollow\">Merging Entire Documents</a></li>\n<li><a href=\"#changing-the-environment\" id=\"id12\" rel=\"nofollow\">Changing the Environment</a></li>\n<li><a href=\"#the-default-document\" id=\"id13\" rel=\"nofollow\">The Default Document</a></li>\n<li><a href=\"#functional-conditional-keys\" id=\"id14\" rel=\"nofollow\">Functional Conditional Keys</a></li>\n<li><a href=\"#lazy-loading\" id=\"id15\" rel=\"nofollow\">Lazy Loading</a></li>\n</ul>\n</li>\n<li><a href=\"#order-of-operations\" id=\"id16\" rel=\"nofollow\">Order Of Operations</a></li>\n<li><a href=\"#feature-key-definitions\" id=\"id17\" rel=\"nofollow\">Feature Key Definitions</a><ul>\n<li><a href=\"#document-feature-keys\" id=\"id18\" rel=\"nofollow\">Document Feature Keys</a><ul>\n<li><a href=\"#env\" id=\"id19\" rel=\"nofollow\">env</a></li>\n<li><a href=\"#include\" id=\"id20\" rel=\"nofollow\">include</a></li>\n</ul>\n</li>\n<li><a href=\"#functional-feature-keys\" id=\"id21\" rel=\"nofollow\">Functional Feature Keys</a><ul>\n<li><a href=\"#insert\" id=\"id22\" rel=\"nofollow\">insert</a></li>\n<li><a href=\"#id1\" id=\"id23\" rel=\"nofollow\">merge</a></li>\n<li><a href=\"#merge-override\" id=\"id24\" rel=\"nofollow\">merge_override</a></li>\n<li><a href=\"#insert-merge\" id=\"id25\" rel=\"nofollow\">insert_merge</a></li>\n<li><a href=\"#case\" id=\"id26\" rel=\"nofollow\">case</a></li>\n<li><a href=\"#otherwise\" id=\"id27\" rel=\"nofollow\">otherwise</a></li>\n<li><a href=\"#cond\" id=\"id28\" rel=\"nofollow\">cond</a></li>\n<li><a href=\"#lazy\" id=\"id29\" rel=\"nofollow\">lazy</a></li>\n<li><a href=\"#lazy-lookup\" id=\"id30\" rel=\"nofollow\">lazy_lookup</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#the-validator\" id=\"id31\" rel=\"nofollow\">The Validator</a></li>\n<li><a href=\"#the-command\" id=\"id32\" rel=\"nofollow\">The Command</a></li>\n<li><a href=\"#the-api\" id=\"id33\" rel=\"nofollow\">The API</a></li>\n<li><a href=\"#custom-feature-keys\" id=\"id34\" rel=\"nofollow\">Custom Feature Keys</a></li>\n</ul>\n</div>\n<div id=\"the-yamlicious-file\">\n<h2><a href=\"#id2\" rel=\"nofollow\">The Yamlicious File</a></h2>\n<p>A configuration file specified in Yamlicious <em>is just YAML</em>. In fact, nothing stops\nyou from parsing a Yamlicious file with any YAML library. This can be useful for\nsearching, cleaning, or editing (with syntax highlighting) the file.</p>\n<div id=\"environment-variable-subtitution\">\n<h3><a href=\"#id3\" rel=\"nofollow\">Environment Variable Subtitution</a></h3>\n<p>Yamlicious gives your configuration file automatic access to the environment.</p>\n<pre><span class=\"nt\">some</span><span class=\"p\">:</span>\n  <span class=\"nt\">key</span><span class=\"p\">:</span>\n    <span class=\"nt\">user_$(USER)</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">not cool</span>\n    <span class=\"nt\">user_kyle</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">cool</span>\n</pre>\n<p>Don\u2019t worry. The Yamlicious API gives you (the developer) the ability to both\nlimit the environment variables your configuration file is allowed to access\nand provide overriding values for anything in the environment. You\u2019re neither\nforced to use environment variables nor doomed to a free for all.</p>\n<p>Yamlicious supports list values in the environment, and splits environment variables\non the comma character. If a Yamlicious file substitutes a list variable into a\nstring, that string renders into multiple strings (one for each value in the\nlist variable).</p>\n<p>If a string references a variable that\u2019s not in the environment, yamlicious\ndoes not modify the string. It will leave the variable reference alone, <tt>$()</tt>\ncharacters included. This makes string substitution have a neat property \u2013 it\ncan be applied to the same document iteratively as the environment grows.</p>\n<p>List substitution behavior varies subtly by situation.</p>\n<div id=\"when-substituting-into-a-single-value-string\">\n<h4><a href=\"#id4\" rel=\"nofollow\">When substituting into a single value string</a></h4>\n<pre><span class=\"nt\">some_list</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">$(MY_LIST)</span>\n</pre>\n<p>renders to the following, if <tt>MY_LIST=one,two,three</tt> is in the environment.</p>\n<pre><span class=\"nt\">some_list</span><span class=\"p\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">one</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">two</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">three</span>\n</pre>\n</div>\n<div id=\"when-substituting-into-a-value-list\">\n<h4><a href=\"#id5\" rel=\"nofollow\">When substituting into a value list</a></h4>\n<pre><span class=\"nt\">some_list</span><span class=\"p\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">first</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">$(LIST)</span>\n</pre>\n<p>becomes</p>\n<pre><span class=\"nt\">some_list</span><span class=\"p\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">first</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">one</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">two</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">three</span>\n</pre>\n</div>\n<div id=\"when-substituting-into-a-key-string\">\n<h4><a href=\"#id6\" rel=\"nofollow\">When substituting into a key string</a></h4>\n<p>Key strings are special, because you almost certainly don\u2019t intend to make a\nlist into the key of a dictionary. Instead, you likely mean to define a key in\nthe dictionary for each item in the list. Yamlicious provides a special\nvariable in the environment, <tt>_KEY</tt>, to help you out in this situation.</p>\n<pre><span class=\"nt\">$(LIST)</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">$(_KEY) is in the list!</span>\n</pre>\n<p>becomes</p>\n<pre><span class=\"nt\">one</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">one is in the list</span>\n<span class=\"nt\">two</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">two is in the list</span>\n<span class=\"nt\">three</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">three is in the list</span>\n</pre>\n<p><tt>_KEY</tt> is set to the first-level key in the document, regardless of whether\nthe key was derived from string substitution. To get the second-level key, use\n<tt>__KEY</tt>, and so forth:</p>\n<pre><span class=\"nt\">$(LIST)</span><span class=\"p\">:</span>\n  <span class=\"nt\">second_level_key</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">$(_KEY) on top and $(__KEY) on bottom</span>\n</pre>\n<p>becomes</p>\n<pre><span class=\"nt\">one</span><span class=\"p\">:</span>\n  <span class=\"nt\">second_level_key</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">one on top and second_level_key on bottom</span>\n<span class=\"nt\">two</span><span class=\"p\">:</span>\n  <span class=\"nt\">second_level_key</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">two on top and second_level_key on bottom</span>\n<span class=\"nt\">three</span><span class=\"p\">:</span>\n  <span class=\"nt\">second_level_key</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">three on top and second_level_key on bottom</span>\n</pre>\n</div>\n<div id=\"when-substituting-multiple-list-values-into-the-same-string\">\n<h4><a href=\"#id7\" rel=\"nofollow\">When substituting multiple list values into the same string</a></h4>\n<p>This is interpreted as a dot product. Yamlicious will substitute every\ncombination of variables between the two lists.</p>\n<p>If <tt>BOYS=joey,johnny,bobby</tt> and <tt>GIRLS=sally,mary</tt> then:</p>\n<pre><span class=\"s\">\"$(BOYS)</span><span class=\"nv\"> </span><span class=\"s\">likes</span><span class=\"nv\"> </span><span class=\"s\">$(GIRLS)\"</span>\n</pre>\n<p>becomes:</p>\n<pre><span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">joey likes sally</span>\n<span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">joey likes mary</span>\n<span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">johnny likes sally</span>\n<span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">johnny likes mary</span>\n<span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">bobby likes sally</span>\n<span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">bobby likes mary</span>\n</pre>\n<p>Note \u2013 the rest of the \u201cpositional\u201d list substitution rules (defined in the\nimmediately previous sections) apply to dot product substitutions.</p>\n</div>\n</div>\n<div id=\"load-another-file\">\n<h3><a href=\"#id8\" rel=\"nofollow\">Load Another File</a></h3>\n<p>Sometimes, it makes sense to define sub-configuration somewhere outside the\nmain configuration file. (e.g., secrets go somewhere special.) Yamlicious gives\nyou the <a href=\"#insert\" rel=\"nofollow\">insert</a> key to accomplish this.</p>\n<p>Note: <cite>insert_</cite> is a <em>functional feature key</em>. (Defined more in the <a href=\"#functional-feature-keys\" rel=\"nofollow\">Functional\nFeature Keys</a> section.) These are keys that participate in something like a\nfunction call \u2013 the entire map that contains a functional key evaluates to\nfunctional behavior applied to the key\u2019s value. (No project is complete without\na smidge of functional programming.) You can only use one of these keys in a\nmap at a time because yamlicious replaces the key-containing map with a\ndocument \u2013 the result of the function applied to the key\u2019s value. Multiple\nkeys is an abiguous definition.</p>\n<pre><span class=\"nt\">some_place</span><span class=\"p\">:</span>\n  <span class=\"nt\">placed_here</span><span class=\"p\">:</span>\n    <span class=\"nt\">_insert</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">other/file.yaml</span>\n</pre>\n<p>In this case, the rendered YAML output of <tt>other/file.yaml</tt> is placed under\nthe <tt>placed_here</tt> key.</p>\n<pre><span class=\"nt\">some_place</span><span class=\"p\">:</span>\n  <span class=\"nt\">placed_here</span><span class=\"p\">:</span>\n    <span class=\"nt\">contents of</span><span class=\"p\">:</span>\n      <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">that other file</span>\n      <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">which can be arbitrary YAML</span>\n</pre>\n<p>You can use variable substitution with the <a href=\"#insert\" rel=\"nofollow\">insert</a> feature to get conditional\nconfiguration.</p>\n<pre><span class=\"nt\">user_settings</span><span class=\"p\">:</span>\n  <span class=\"nt\">_insert</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">$(USER)/conf.yaml</span>\n</pre>\n</div>\n<div id=\"merge\">\n<h3><a href=\"#id9\" rel=\"nofollow\">Merge</a></h3>\n<p>Yamlicious allows you to <em>merge</em> an external file into a bit of config.</p>\n<pre><span class=\"nt\">merged_settings</span><span class=\"p\">:</span>\n  <span class=\"nt\">_merge</span><span class=\"p\">:</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"nt\">some_list</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span><span class=\"s\">'thing'</span><span class=\"p-Indicator\">]</span>\n      <span class=\"nt\">some_thing</span><span class=\"p\">:</span> <span class=\"s\">'thing'</span>\n\n    <span class=\"p-Indicator\">-</span> <span class=\"nt\">_insert</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">some_other_place.yaml</span>\n</pre>\n<p>When you ask Yamlicious to do this, it will use a strategy I call <em>safe deep merge\nwith list append</em>. Yamlicious merges dictionaries recursively by combining their\nkey-value pairs. It merges lists by list addition. It refuses, however, to\nmerge anything else. (Anything else would be shoot-self-in-foot territory, and\nI\u2019d rather not encourage it.)</p>\n<p>if <tt>some_other_place.yaml</tt> looked like this:</p>\n<pre><span class=\"nt\">some_list</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span><span class=\"s\">'second_thing'</span><span class=\"p-Indicator\">]</span>\n<span class=\"nt\">some_other_thing</span><span class=\"p\">:</span> <span class=\"s\">'thing'</span>\n</pre>\n<p>The above configuration would render as follows:</p>\n<pre><span class=\"nt\">merged_settings</span><span class=\"p\">:</span>\n  <span class=\"nt\">some_list</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span><span class=\"s\">'thing'</span><span class=\"p-Indicator\">,</span> <span class=\"s\">'second_thing'</span><span class=\"p-Indicator\">]</span>\n  <span class=\"nt\">some_thing</span><span class=\"p\">:</span> <span class=\"s\">'thing'</span>\n  <span class=\"nt\">some_other_thing</span><span class=\"p\">:</span> <span class=\"s\">'thing'</span>\n</pre>\n<p>If you\u2019re looking to implement the common <em>default override</em> pattern, specify\n<a href=\"#the-default-document\" rel=\"nofollow\">The Default Document</a> as part of the Yamlicious API. That feature is specifically\nbuilt to help you not have to allow arbitrary overrides when including files.\nIf you absolutely must allow overrides, use the <a href=\"#merge-override\" rel=\"nofollow\">merge_override</a> keyword,\nbut note that it is turned off by default.</p>\n</div>\n<div id=\"insert-and-merge\">\n<h3><a href=\"#id10\" rel=\"nofollow\">Insert and Merge</a></h3>\n<p>Loading several files and merging them is a common pattern, and it would be\nnice if folks didn\u2019t have to be verbose if that\u2019s the behavior they\u2019re looking\nfor. This is what the <a href=\"#insert-merge\" rel=\"nofollow\">insert_merge</a> key is for.</p>\n<pre><span class=\"nt\">merged_stuff</span><span class=\"p\">:</span>\n  <span class=\"nt\">_insert_merge</span><span class=\"p\">:</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">first/place.yaml</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">second/place.yaml</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">third/place.yaml</span>\n</pre>\n<p>This key will load each file in order and merge that file into the previous\nfile.</p>\n</div>\n<div id=\"merging-entire-documents\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Merging Entire Documents</a></h3>\n<p>If you\u2019d like to merge an entire document with your own, use the <a href=\"#include\" rel=\"nofollow\">include</a>\nfeature key.</p>\n<p>Note: <a href=\"#include\" rel=\"nofollow\">include</a> is a <em>document feature key</em>. (Defined more in the <a href=\"#document-feature-keys\" rel=\"nofollow\">Document\nFeature Keys</a> section.) Unlike functional feature keys, which apply behavior\nto any map embedded anywhere in the document hierarchy, document feature keys\napply behavior to the entire document, and therefore must exist at the top of\nthe YAML document.</p>\n</div>\n<div id=\"changing-the-environment\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Changing the Environment</a></h3>\n<p>You can also use the <a href=\"#env\" rel=\"nofollow\">env</a> document key to place new variables into the\nenvironment.</p>\n<pre><span class=\"nt\">_env</span><span class=\"p\">:</span>\n  <span class=\"nt\">COOLEST_PERSON</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">kyle</span>\n</pre>\n<p>These variables can be used either in <em>the same document</em> (although the utility\nof that is not immediately obvious, other than for mitigating DRY violation)\nor, more importantly, <em>in documents that include it</em>. Yamlicious supports this\nby taking special care to re-run string substitution each time it changes a\ndocument\u2019s environment. (Remember, string substitution is idempotent.)</p>\n<p>This behavior is somewhat dangerous if the included document defines a variable\nthat\u2019s already defined in the including document. If the including document\nuses string subtitution to define included document paths, those substitutions\ncan happen using only the <em>initial</em> version of the environment (before it is\nmutated by the act of inclusion). If the included document then changes any key\nthat\u2019s used in the process of inclusion, things get hard to reason about.</p>\n<p>Rather than allow such craziness, Yamlicious bans it. That is, it does not\nallow multiple documents included in the same parent document to define\ndiffering versions of the same environment variable. It does allow actual\nenvironment variables to coexist with (and override) those defined in <a href=\"#env\" rel=\"nofollow\">env</a>.\nNot allowing this would be brittle and would remove a very common use case,\nwhere setting an environment variable changes some sort of important behavior.</p>\n</div>\n<div id=\"the-default-document\">\n<h3><a href=\"#id13\" rel=\"nofollow\">The Default Document</a></h3>\n<p>Yamlicious merge-overrides the configuration document it renders with a\n<em>default document</em> that it is configured to use.</p>\n<p>This is the only place that, by default, uses the merge-override (rather than\nsafe merge) behavior. For that reason, it\u2019s best to use the default document\nfeature to specify override behavior. If you\u2019re wanting override behavior that\ncan\u2019t be done by using the default document, chances are you\u2019re doing something\nthat\u2019s either too complex or wrong. If you insist, there\u2019s always\n<a href=\"#merge-override\" rel=\"nofollow\">merge_override</a>.</p>\n</div>\n<div id=\"functional-conditional-keys\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Functional Conditional Keys</a></h3>\n<p>To specify a condition in-line, you can use the <em>functional conditional</em>\nfeature keys (<a href=\"#case\" rel=\"nofollow\">case</a> and <a href=\"#cond\" rel=\"nofollow\">cond</a>), each inspired by Lisp. This adds a bit too\nmuch Turing completeness to the project for the taste of most, so these are\ndisabled by default.</p>\n<pre><span class=\"nt\">case_configuration</span><span class=\"p\">:</span>\n  <span class=\"s\">'_case'</span><span class=\"p-Indicator\">:</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"s\">'$(USER)'</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"s\">'kyle'</span><span class=\"p-Indicator\">:</span> <span class=\"s\">'is</span><span class=\"nv\"> </span><span class=\"s\">awesome'</span><span class=\"p-Indicator\">}</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"s\">'_otherwise'</span><span class=\"p-Indicator\">:</span> <span class=\"s\">'is</span><span class=\"nv\"> </span><span class=\"s\">not</span><span class=\"nv\"> </span><span class=\"s\">awesome'</span><span class=\"p-Indicator\">}</span>\n<span class=\"nt\">cond_configuration</span><span class=\"p\">:</span>\n  <span class=\"s\">'_cond'</span><span class=\"p-Indicator\">:</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"s\">\"$(ENV)</span><span class=\"nv\"> </span><span class=\"s\">in</span><span class=\"nv\"> </span><span class=\"s\">['test',</span><span class=\"nv\"> </span><span class=\"s\">'prod']\"</span><span class=\"p-Indicator\">:</span> <span class=\"s\">'go!'</span><span class=\"p-Indicator\">}</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"nt\">true</span><span class=\"p\">:</span> <span class=\"s\">'undefined'</span><span class=\"p-Indicator\">}</span>\n</pre>\n<p>Note the use of the python expression. This is mostly for convenience and\nterseness. Nobody wants to write a boolean expression in YAML, and I don\u2019t\nparticularly want to implement it, either, so Yamlicious <tt>eval()</tt> s every single\nstring that it finds below either functional conditional key.</p>\n<p>List substitution works in both kinds of functional conditional. For example,\nif <tt>GOOD_USERS=kyle,anthony</tt>, then the following expression</p>\n<pre><span class=\"nt\">access_configuration</span><span class=\"p\">:</span>\n  <span class=\"s\">'_case'</span><span class=\"p-Indicator\">:</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"s\">'$(GOOD_USERS)'</span><span class=\"p-Indicator\">:</span> <span class=\"s\">'go!'</span><span class=\"p-Indicator\">}</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"s\">'_otherwise'</span><span class=\"p-Indicator\">:</span>  <span class=\"s\">'stay.</span><span class=\"nv\"> </span><span class=\"s\">:('</span><span class=\"p-Indicator\">}</span>\n</pre>\n<p>evaluates to</p>\n<pre><span class=\"nt\">access_configuration</span><span class=\"p\">:</span>\n  <span class=\"s\">'_case'</span><span class=\"p-Indicator\">:</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"s\">'kyle'</span><span class=\"p-Indicator\">:</span> <span class=\"s\">'go!'</span><span class=\"p-Indicator\">,</span>\n       <span class=\"s\">'anthony'</span><span class=\"p-Indicator\">:</span> <span class=\"s\">'go!'</span><span class=\"p-Indicator\">}</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">[</span><span class=\"s\">'_otherwise'</span><span class=\"p-Indicator\">,</span>  <span class=\"s\">'stay.</span><span class=\"nv\"> </span><span class=\"s\">:('</span><span class=\"p-Indicator\">]</span>\n</pre>\n<p>Yamlicious is careful to \u201cdo the right thing\u201d here. While there is no defined\norder in how it matches either the key <tt>'anthony'</tt> or <tt>'kyle'</tt>, it will try\nto match both before falling back to the <a href=\"#otherwise\" rel=\"nofollow\">otherwise</a> key.</p>\n<p>Be careful to not do something like this unless you really mean it:</p>\n<pre><span class=\"nt\">access_configuration</span><span class=\"p\">:</span>\n  <span class=\"s\">'_case'</span><span class=\"p-Indicator\">:</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"s\">'$(GOOD_USERS)'</span><span class=\"p-Indicator\">:</span> <span class=\"s\">'$(_KEY)'</span><span class=\"p-Indicator\">}</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"s\">'_otherwise'</span><span class=\"p-Indicator\">:</span>  <span class=\"s\">'stay.</span><span class=\"nv\"> </span><span class=\"s\">:('</span><span class=\"p-Indicator\">}</span>\n</pre>\n<p>While it will technically work, Yamlicious offers no definition for what the\nabove expression evaluates to \u2013 the order of iteration for a map/dictionary is\nan implementation detail.</p>\n</div>\n<div id=\"lazy-loading\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Lazy Loading</a></h3>\n<p>If you notice an explosion in the number of Yamlicious files that your program\nincludes, and you also notice that only a few of them ever get used, you\u2019ll\nlikely want to conditionally load said files only when they\u2019re needed. Yamlicious\nprovides two lazy loading keys to help you with this.</p>\n<p>The <a href=\"#lazy\" rel=\"nofollow\">lazy</a> key changes nothing about the semantic meaning of the document it\npoints to. It does change the time when functional key evaluation happens.\nYamlicious evaluates embedded functional keys at <em>lookup time</em>, rather than\nduring the depth-first functional key evaluation of the entire document.</p>\n<p>In this example</p>\n<pre><span class=\"nt\">_lazy</span><span class=\"p\">:</span>\n  <span class=\"nt\">one</span><span class=\"p\">:</span>\n    <span class=\"nt\">_insert</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">some/other/file.yaml</span>\n</pre>\n<p>The <a href=\"#insert\" rel=\"nofollow\">insert</a> evaluation happens only when someone tries to look at the\n<tt>one</tt> key.</p>\n<p>The <a href=\"#lazy-lookup\" rel=\"nofollow\">lazy_lookup</a> key delays functional key evaluation just like <a href=\"#lazy\" rel=\"nofollow\">lazy</a>, and\nit also allows you to use string substitution of the special variable\n<tt>$(_KEY)</tt> to define how every key in the document is looked up. Rather than\ndefining a document for <em>every key</em> in the map, you define <em>one expression</em>\nthat, after string subtitution, can evaluate to <em>any key</em>.</p>\n<p>To get the most power, pair lazy lookup with file inclusion. Here\u2019s an example\ninspired by YAML configuration of SQL tables.</p>\n<pre><span class=\"nt\">tables</span><span class=\"p\">:</span>\n  <span class=\"nt\">_lazy_lookup</span><span class=\"p\">:</span>\n    <span class=\"nt\">_insert_merge</span><span class=\"p\">:</span>\n      <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">generic/schema/$(_KEY).table.yaml</span>\n      <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">$(SYSTEM)/schema/$(_KEY).table.yaml</span>\n      <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">$(INSTITUTION)/schema/$(_KEY).table.yaml</span>\n</pre>\n<p>Note that there\u2019s nothing that prevents lazy-loaded documents from merging with\none another. If you\u2019re feeling particularly masochistic, you can define this\nconfusing yet equivalent thing.</p>\n<pre><span class=\"nt\">tables</span><span class=\"p\">:</span>\n  <span class=\"nt\">_merge</span><span class=\"p\">:</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"nt\">_lazy_lookup</span><span class=\"p\">:</span>\n        <span class=\"nt\">_insert_merge</span><span class=\"p\">:</span>\n          <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">generic/schema/$(_KEY).table.yaml</span>\n          <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">$(SYSTEM)/schema/$(_KEY).table.yaml</span>\n    <span class=\"p-Indicator\">-</span> <span class=\"nt\">_lazy_lookup</span><span class=\"p\">:</span>\n        <span class=\"nt\">_insert_merge</span><span class=\"p\">:</span>\n          <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">$(INSTITUTION)/schema/$(_KEY).table.yaml</span>\n</pre>\n</div>\n</div>\n<div id=\"order-of-operations\">\n<h2><a href=\"#id16\" rel=\"nofollow\">Order Of Operations</a></h2>\n<p>Yamlicious goes through the following phases when processing a document:</p>\n<ol>\n<li>String substitution.</li>\n<li>Document key evaluation.</li>\n<li>String substitution.</li>\n<li>Functional key evaluation (depth-first).</li>\n</ol>\n</div>\n<div id=\"feature-key-definitions\">\n<h2><a href=\"#id17\" rel=\"nofollow\">Feature Key Definitions</a></h2>\n<p>Enough with your words. Let\u2019s define this stuff explicitly.</p>\n<div id=\"document-feature-keys\">\n<h3><a href=\"#id18\" rel=\"nofollow\">Document Feature Keys</a></h3>\n<p>These keys must be placed at the <em>top</em> level of a document, and affect the\nentire document that they\u2019re placed inside. They disappear when rendered.</p>\n<div id=\"env\">\n<h4><a href=\"#id19\" rel=\"nofollow\">env</a></h4>\n<pre><span class=\"nt\">_env</span><span class=\"p\">:</span>\n  <span class=\"nt\">&lt;variable&gt;</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">&lt;value&gt;</span>\n  <span class=\"l-Scalar-Plain\">...</span>\n</pre>\n<p>Sets document environment variables to given values.</p>\n</div>\n<div id=\"include\">\n<h4><a href=\"#id20\" rel=\"nofollow\">include</a></h4>\n<pre><span class=\"nt\">_include</span><span class=\"p\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">&lt;file-path&gt;</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">&lt;file-path&gt;</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">...</span>\n</pre>\n<p>Loads and safe-merges several files into the document.</p>\n</div>\n</div>\n<div id=\"functional-feature-keys\">\n<h3><a href=\"#id21\" rel=\"nofollow\">Functional Feature Keys</a></h3>\n<p>The key must exist by itself in its containing dictionary. The feature key,\nitself, describes a transformation operation on the given document.</p>\n<pre><span class=\"nt\">_&lt;feature-key&gt;</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">&lt;document&gt;</span>\n</pre>\n<div id=\"insert\">\n<h4><a href=\"#id22\" rel=\"nofollow\">insert</a></h4>\n<pre><span class=\"l-Scalar-Plain\">_insert &lt;file-path&gt;</span>\n</pre>\n<p>Evaluates to the loaded and processed configuration document found at\n<tt>file_path</tt>.</p>\n</div>\n<div id=\"id1\">\n<h4><a href=\"#id23\" rel=\"nofollow\">merge</a></h4>\n<pre><span class=\"nt\">_merge</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span> <span class=\"nv\">&lt;document&gt;</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">&lt;document&gt;</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">...</span> <span class=\"p-Indicator\">]</span>\n</pre>\n<p>Uses safe-merge-with-list-append to merge given documents together. Can safely\nmerge dictionaries and lists, but nothing else.</p>\n</div>\n<div id=\"merge-override\">\n<h4><a href=\"#id24\" rel=\"nofollow\">merge_override</a></h4>\n<pre><span class=\"nt\">_merge_override</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span> <span class=\"nv\">&lt;document&gt;</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">&lt;document&gt;</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">...</span> <span class=\"p-Indicator\">]</span>\n</pre>\n<p>Uses deep-merge to merge given documents together. Can safely merge anything.\nFor scalar values, documents further down the list override documents earlier\nin the list.</p>\n</div>\n<div id=\"insert-merge\">\n<h4><a href=\"#id25\" rel=\"nofollow\">insert_merge</a></h4>\n<pre><span class=\"l-Scalar-Plain\">_insert_merge [ &lt;file-path&gt;, &lt;file-path&gt;, ... ]</span>\n</pre>\n<p>Loads files and then merges them with safe-merge-with-list-append.</p>\n</div>\n<div id=\"case\">\n<h4><a href=\"#id26\" rel=\"nofollow\">case</a></h4>\n<p>(NOT IMPLEMENTED)</p>\n<pre><span class=\"s\">'_case'</span><span class=\"p-Indicator\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">&lt;key-python-expression&gt;</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"nv\">&lt;match-python-expression&gt;</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">&lt;outcome-python-expression&gt;</span><span class=\"p-Indicator\">}</span>\n  <span class=\"l-Scalar-Plain\">...</span>\n</pre>\n<p>Functional case. Evaluates to the first outcome expression whose match\nexpression is python-equal to the key expression.</p>\n</div>\n<div id=\"otherwise\">\n<h4><a href=\"#id27\" rel=\"nofollow\">otherwise</a></h4>\n<p>(NOT IMPLEMENTED)</p>\n<pre><span class=\"s\">'_otherwise'</span><span class=\"p-Indicator\">:</span> <span class=\"l-Scalar-Plain\">&lt;expression&gt;</span>\n</pre>\n<p>Evaluates to a case condition that always matches.</p>\n</div>\n<div id=\"cond\">\n<h4><a href=\"#id28\" rel=\"nofollow\">cond</a></h4>\n<p>(NOT IMPLEMENTED)</p>\n<pre><span class=\"s\">'_cond'</span><span class=\"p-Indicator\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"p-Indicator\">{</span><span class=\"nv\">&lt;boolean-python-expression&gt;</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">&lt;outcome-python-expression&gt;</span><span class=\"p-Indicator\">}</span>\n  <span class=\"l-Scalar-Plain\">...</span>\n</pre>\n<p>Functional cond. Evaluates to the first outcome expression whose boolean\nexpression is true.</p>\n</div>\n<div id=\"lazy\">\n<h4><a href=\"#id29\" rel=\"nofollow\">lazy</a></h4>\n<p>(NOT IMPLEMENTED)</p>\n<pre><span class=\"s\">'_lazy'</span><span class=\"p-Indicator\">:</span> <span class=\"l-Scalar-Plain\">&lt;document&gt;</span>\n</pre>\n<p>Evaluates to document, but where each of the keys in document is lazy-loaded.</p>\n</div>\n<div id=\"lazy-lookup\">\n<h4><a href=\"#id30\" rel=\"nofollow\">lazy_lookup</a></h4>\n<p>(NOT IMPLEMENTED)</p>\n<pre><span class=\"s\">'_lazy_lookup'</span><span class=\"p-Indicator\">:</span> <span class=\"l-Scalar-Plain\">&lt;value-expression&gt;</span>\n</pre>\n<p>Evaluates to a lazy-loaded dictionary, where every key is evaluated at lookup\ntime by evaluating the value-expression, which is allowed to use the <tt>_KEY</tt>\nenvironment variable</p>\n</div>\n</div>\n</div>\n<div id=\"the-validator\">\n<h2><a href=\"#id31\" rel=\"nofollow\">The Validator</a></h2>\n<p>TBD</p>\n</div>\n<div id=\"the-command\">\n<h2><a href=\"#id32\" rel=\"nofollow\">The Command</a></h2>\n<p>Yamlicious comes with a convenient command, <tt>yamlicious</tt>, that reads input\nfrom stdin and writes to stdout. It uses a default configuration, along with\nall environment variables, in order to process the yaml document fed to it on\nstandard in:</p>\n<pre>[10:49:46][kderr@Kyles-MacBook-Pro][~/Repositories/derrley/yamlicious]\n$ cat /tmp/test\nHello: \"$(PWD) is the current wd\"\n\n\n[10:49:52][kderr@Kyles-MacBook-Pro][~/Repositories/derrley/yamlicious]\n$ cat /tmp/test | yamlicious\n{Hello: /Users/kderr/Repositories/derrley/yamlicious is the current wd}\n</pre>\n</div>\n<div id=\"the-api\">\n<h2><a href=\"#id33\" rel=\"nofollow\">The API</a></h2>\n<p>TBD</p>\n</div>\n<div id=\"custom-feature-keys\">\n<h2><a href=\"#id34\" rel=\"nofollow\">Custom Feature Keys</a></h2>\n<p>TBD</p>\n</div>\n\n          </div>"}, "last_serial": 1356422, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "3fca28c084c7ec03f521a1dd573506db", "sha256": "ec27e3f9f51d1de6bf22f2effa808838840ca0af68a20b2d62945ba2190cf588"}, "downloads": -1, "filename": "yamlicious-0.0.0.tar.gz", "has_sig": false, "md5_digest": "3fca28c084c7ec03f521a1dd573506db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14818, "upload_time": "2014-12-21T17:47:08", "upload_time_iso_8601": "2014-12-21T17:47:08.262207Z", "url": "https://files.pythonhosted.org/packages/ea/20/06c01344462d823e9a46d8d0953a331d928f1481db19d6680c9a45c64356/yamlicious-0.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3fca28c084c7ec03f521a1dd573506db", "sha256": "ec27e3f9f51d1de6bf22f2effa808838840ca0af68a20b2d62945ba2190cf588"}, "downloads": -1, "filename": "yamlicious-0.0.0.tar.gz", "has_sig": false, "md5_digest": "3fca28c084c7ec03f521a1dd573506db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14818, "upload_time": "2014-12-21T17:47:08", "upload_time_iso_8601": "2014-12-21T17:47:08.262207Z", "url": "https://files.pythonhosted.org/packages/ea/20/06c01344462d823e9a46d8d0953a331d928f1481db19d6680c9a45c64356/yamlicious-0.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:23:19 2020"}