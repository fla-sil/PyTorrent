{"info": {"author": "Michael J. Pedersen", "author_email": "m.pedersen@icelus.org", "bugtrack_url": null, "classifiers": [], "description": "== Welcome to the TurboGears XMLRPC Extension ==\n\ntgext.xmlrpc provides an easy method to allow XMLRPC calls to be\nperformed by your TurboGears application.\n\n== Installation ==\n\n1. Add it to your project. This is accomplished by modifying your\nsetup.py. Add \"tgext.xmlrpc\" to your **install_requires** list.\n\n2. Run {{{python setup.py develop}}} in your project to get it\ninstalled.\n\n== Usage ==\n\nUsage is quite simple. Create a controller, decorate the XMLRPC\nmethods, and mount your controller somewhere. This can be done as\nfollows:\n\n{{{\nfrom tgext.xmlrpc import XmlRpcController, xmlrpc\n\nclass MyXmlRpcCenter(XmlRpcController):\n    @xmlrpc([['int', 'int', 'int'], ['int', 'array']], helpstr=\"Adds numbers together\")\n    def addit(self, *p, **kw):\n        return sum(p)\n}}}\n\nAnd then, in your controller, add the following line:\n\n{{{\n      xmlrpc = MyXmlRpcCenter()\n}}}\n\nThat's it, you now have a working XMLRPC interface on your system. If\nyou added it to your RootController, you may visit\nhttp://localhost:8080/xmlrpc and get the help page. You may send an\nXMLRPC request to the method 'addit', and get the result.\n\n== The Details ==\n\n=== xmlrpc Decorator  ===\n\nThe xmlrpc decorator takes two parameters:\n\n * A list of lists of signatures\n * A help string that will be displayed on the index page, or when\n   system.methodHelp is called for that method\n\nNote that it matters that the signatures are a list of lists. The\nelements of the list are nothing but strings identifying valid XMLRPC\ndata types. You can view a list of acceptable data types at\nhttp://en.wikipedia.org/wiki/XML-RPC\n\nSo, examples of valid/invalid signatures:\n\n * {{{[['string', 'int']]}}} <-- valid, takes int, returns string\n * {{{['string', 'int']}}} <-- invalid, a list of two strings, not a list of lists\n\n=== xmlrpc methods ===\n\nYou may write up your methods so that they function just like any other\nTurboGears method. In fact, you can even be more strict, as a common idiom for\nTurboGears methods is to use something like this:\n\n{{{\n    class MyXml(XmlRpcController):\n        @xmlrpc([['string', 'string']])\n\tdef mymethod(self, *p, **kw):\n\t    pass\n}}}\n\nNotice the {{{*p, **kw}}} in the method signature. This is to prevent an ugly\nerror page being sent to users if they get the URL wrong. Since we are dealing\nwith programmatic interfaces, where the other end should be coded to expect\nerrors when data is not sent properly, we can make things much easier on the\ndeveloper:\n\n{{{\n    class MyXml(XmlRpcController):\n        @xmlrpc([['string', 'string']])\n\tdef mymethod(self, instr, **kw):\n\t    pass\n}}}\n\n=== XMLRPC Hierarchies ===\n\nYou may set up a hierarchy of XmlRpcControllers. When you do, the\nmethod names get separated by \".\". This results in situations like the\nfollowing:\n\n{{{\nclass SubXmlRpc(XmlRpcController):\n      @xmlrpc([['string', 'array']])\n      def joinit(self, *p, **kw):\n      \t  return \" \".join(p)\n\nclass MyXmlRpc(XmlRpcController):\n      subproc = SubXmlRpc()\n\n      @xmlrpc([['int', 'array']])\n      def addit(self, *p, **kw):\n      \t  return sum(p)\n}}}\n\nWhen you mount MyXmlRpc somewhere, you will have the following two\nmethod names available to you:\n\n * addit\n * subproc.joinit\n\nWhen a call is made for \"subproc.joinit\", the XmlRpcController will\ndescend looking for the sub-controller, and then call the appropriate\nmethod there.\n\n=== To Do List ===\n\n * Add xmlrpcstruct decorator to allow xmlrpcsruct docs to be shown on\n   system.methodHelp pages.\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://bitbucker.org/pedersen/tgext.xmlrpc", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "tgext.xmlrpc", "package_url": "https://pypi.org/project/tgext.xmlrpc/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/tgext.xmlrpc/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://bitbucker.org/pedersen/tgext.xmlrpc"}, "release_url": "https://pypi.org/project/tgext.xmlrpc/1.0/", "requires_dist": null, "requires_python": null, "summary": "TurboGears XMLRPC Controller", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            == Welcome to the TurboGears XMLRPC Extension ==<br><br>tgext.xmlrpc provides an easy method to allow XMLRPC calls to be<br>performed by your TurboGears application.<br><br>== Installation ==<br><br>1. Add it to your project. This is accomplished by modifying your<br>setup.py. Add \"tgext.xmlrpc\" to your **install_requires** list.<br><br>2. Run {{{python setup.py develop}}} in your project to get it<br>installed.<br><br>== Usage ==<br><br>Usage is quite simple. Create a controller, decorate the XMLRPC<br>methods, and mount your controller somewhere. This can be done as<br>follows:<br><br>{{{<br>from tgext.xmlrpc import XmlRpcController, xmlrpc<br><br>class MyXmlRpcCenter(XmlRpcController):<br>    @xmlrpc([['int', 'int', 'int'], ['int', 'array']], helpstr=\"Adds numbers together\")<br>    def addit(self, *p, **kw):<br>        return sum(p)<br>}}}<br><br>And then, in your controller, add the following line:<br><br>{{{<br>      xmlrpc = MyXmlRpcCenter()<br>}}}<br><br>That's it, you now have a working XMLRPC interface on your system. If<br>you added it to your RootController, you may visit<br>http://localhost:8080/xmlrpc and get the help page. You may send an<br>XMLRPC request to the method 'addit', and get the result.<br><br>== The Details ==<br><br>=== xmlrpc Decorator  ===<br><br>The xmlrpc decorator takes two parameters:<br><br> * A list of lists of signatures<br> * A help string that will be displayed on the index page, or when<br>   system.methodHelp is called for that method<br><br>Note that it matters that the signatures are a list of lists. The<br>elements of the list are nothing but strings identifying valid XMLRPC<br>data types. You can view a list of acceptable data types at<br>http://en.wikipedia.org/wiki/XML-RPC<br><br>So, examples of valid/invalid signatures:<br><br> * {{{[['string', 'int']]}}} &lt;-- valid, takes int, returns string<br> * {{{['string', 'int']}}} &lt;-- invalid, a list of two strings, not a list of lists<br><br>=== xmlrpc methods ===<br><br>You may write up your methods so that they function just like any other<br>TurboGears method. In fact, you can even be more strict, as a common idiom for<br>TurboGears methods is to use something like this:<br><br>{{{<br>    class MyXml(XmlRpcController):<br>        @xmlrpc([['string', 'string']])<br>\tdef mymethod(self, *p, **kw):<br>\t    pass<br>}}}<br><br>Notice the {{{*p, **kw}}} in the method signature. This is to prevent an ugly<br>error page being sent to users if they get the URL wrong. Since we are dealing<br>with programmatic interfaces, where the other end should be coded to expect<br>errors when data is not sent properly, we can make things much easier on the<br>developer:<br><br>{{{<br>    class MyXml(XmlRpcController):<br>        @xmlrpc([['string', 'string']])<br>\tdef mymethod(self, instr, **kw):<br>\t    pass<br>}}}<br><br>=== XMLRPC Hierarchies ===<br><br>You may set up a hierarchy of XmlRpcControllers. When you do, the<br>method names get separated by \".\". This results in situations like the<br>following:<br><br>{{{<br>class SubXmlRpc(XmlRpcController):<br>      @xmlrpc([['string', 'array']])<br>      def joinit(self, *p, **kw):<br>      \t  return \" \".join(p)<br><br>class MyXmlRpc(XmlRpcController):<br>      subproc = SubXmlRpc()<br><br>      @xmlrpc([['int', 'array']])<br>      def addit(self, *p, **kw):<br>      \t  return sum(p)<br>}}}<br><br>When you mount MyXmlRpc somewhere, you will have the following two<br>method names available to you:<br><br> * addit<br> * subproc.joinit<br><br>When a call is made for \"subproc.joinit\", the XmlRpcController will<br>descend looking for the sub-controller, and then call the appropriate<br>method there.<br><br>=== To Do List ===<br><br> * Add xmlrpcstruct decorator to allow xmlrpcsruct docs to be shown on<br>   system.methodHelp pages.<br>\n          </div>"}, "last_serial": 910973, "releases": {"0.6": [{"comment_text": "", "digests": {"md5": "c6bb97ce87b0e4aa56795c25690408d1", "sha256": "e5b0fea54b44489991c6998379295320f82bafe2855db0ae455297786c8f028b"}, "downloads": -1, "filename": "tgext.xmlrpc-0.6.tar.gz", "has_sig": false, "md5_digest": "c6bb97ce87b0e4aa56795c25690408d1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6024, "upload_time": "2010-05-06T19:42:59", "upload_time_iso_8601": "2010-05-06T19:42:59.428995Z", "url": "https://files.pythonhosted.org/packages/2b/0f/06c8c39a2a66b2ff7b9777d19d196f23c415a638e017a2e918a5a015f73a/tgext.xmlrpc-0.6.tar.gz", "yanked": false}], "0.8": [{"comment_text": "", "digests": {"md5": "885aa6e7e526b745884064355df213a6", "sha256": "3e87d97860267581cc54359f0be9f16651e3cab191e689e3853e0ad0c56d56e3"}, "downloads": -1, "filename": "tgext.xmlrpc-0.8.tar.gz", "has_sig": false, "md5_digest": "885aa6e7e526b745884064355df213a6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6033, "upload_time": "2010-06-16T04:02:01", "upload_time_iso_8601": "2010-06-16T04:02:01.844000Z", "url": "https://files.pythonhosted.org/packages/ad/4b/0fb5ddbc3828db2bff81f1b7f5df9f2025f4b74e797f33f7e7702f436fb6/tgext.xmlrpc-0.8.tar.gz", "yanked": false}], "1.0": [{"comment_text": "", "digests": {"md5": "17ddb8dc07558424fdd6ce64ef9bce55", "sha256": "8d701d7717beb90639e822c35c24d549021cf4c842f5af72cfc8bdb8073ce376"}, "downloads": -1, "filename": "tgext.xmlrpc-1.0.tar.gz", "has_sig": false, "md5_digest": "17ddb8dc07558424fdd6ce64ef9bce55", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6521, "upload_time": "2012-04-26T06:44:46", "upload_time_iso_8601": "2012-04-26T06:44:46.940365Z", "url": "https://files.pythonhosted.org/packages/e7/ca/e4a7b100c52edbc6c56b2cca008d3b263dc7edfde7bae5769573f53d2835/tgext.xmlrpc-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "17ddb8dc07558424fdd6ce64ef9bce55", "sha256": "8d701d7717beb90639e822c35c24d549021cf4c842f5af72cfc8bdb8073ce376"}, "downloads": -1, "filename": "tgext.xmlrpc-1.0.tar.gz", "has_sig": false, "md5_digest": "17ddb8dc07558424fdd6ce64ef9bce55", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6521, "upload_time": "2012-04-26T06:44:46", "upload_time_iso_8601": "2012-04-26T06:44:46.940365Z", "url": "https://files.pythonhosted.org/packages/e7/ca/e4a7b100c52edbc6c56b2cca008d3b263dc7edfde7bae5769573f53d2835/tgext.xmlrpc-1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:54:13 2020"}