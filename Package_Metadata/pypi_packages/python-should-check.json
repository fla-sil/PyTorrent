{"info": {"author": "Pauli Rikula", "author_email": "", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.6"], "description": "# python-should-check\n\nCheck parameters and raise comprehensible exceptions.\n\n    >>> from should_check import (\n    ...    Check,\n    ...    be_callable,\n    ...    be_py_enum_str,\n    ...    be_instance_of,\n    ...    be_subclass_of,\n    ...    not_be_none,\n    ...    not_contain,\n    ...    contain,\n    ...    not_be_empty,\n    ...    be_shorter_than,\n    ...    be_length_of,\n    ...    not_be_negative,\n    ...    be_greater_than,\n    ...    be_less_than,\n    ...    be_equal_with,\n    ...    be,\n    ...    be_in)\n\n\n## Check if a function is a callable and not None\n\n    >>> function = Check(function=print).should(not_be_none, be_callable)\n    >>> function(\"Hello world\")\n    Hello world\n\n    >>> function = Check(function=None).should(not_be_none, be_callable)\n    Traceback (most recent call last):\n    ...\n    ValueError: 'function' should not be None\n\n    >>> function = Check(function=\"boo\").should(not_be_none, be_callable)\n    Traceback (most recent call last):\n    ...\n    ValueError: 'function' should be callable\n\n\nIf the 'None' would not go through some of these checks, it would be cumbersome to\ncheck optional parameters on your functions. This for example works:\n\n\n    >>> function = Check(function=None).should(be_callable)\n\n\nBut these wont:\n\n\n    >>> checked = Check(value=None).should(be(1))\n    Traceback (most recent call last):\n    ...\n    ValueError: value 'None' should (reference equally) be '1'\n\n    >>> checked = Check(value=None).should(be_in([1,2]))\n    Traceback (most recent call last):\n    ...\n    ValueError: value 'None' should be in '[1, 2]'\n\n    >>> checked = Check(value=None).should(be_equal_with(1))\n    Traceback (most recent call last):\n    ...\n    ValueError: value 'None' should be equal with '1'\n\n\nSo be carefull with None and add the check everywhere like you should anyway.\n\n## Check if a string is a member of an enum definition\n\n\n    >>> import enum\n    >>> class MyEnum(enum.IntEnum):\n    ...   GOOD_ENUM = 0\n    ...   MEH_ENUM = 1\n    ...\n    >>> enum_str = Check(enum_str=\"GOOD_ENUM\").should(not_be_none, be_py_enum_str(MyEnum))\n    >>> enum_str = Check(enum_str=\"BAD_ENUM\").should(not_be_none, be_py_enum_str(MyEnum))\n    Traceback (most recent call last):\n    ...\n    TypeError: enum_str 'BAD_ENUM' should be one of '['GOOD_ENUM', 'MEH_ENUM']'\n\n\n## Check if an object is an instance of a class\n\n\n    >>> my_enum = MyEnum(0)\n    >>> second_enum = Check(my_enum=my_enum).should(not_be_none, be_instance_of(MyEnum))\n    >>> second_enum =  Check(my_enum=my_enum).should(not_be_none, be_instance_of(int))\n    >>> second_enum =  Check(my_enum=my_enum).should(not_be_none, be_instance_of(str))\n    Traceback (most recent call last):\n    ...\n    TypeError: my_enum '0' should be instance of '<class 'str'>'\n\n## Check if a class is a subclass another\n\n\n    >>> CheckedClass = Check(subclass=MyEnum).should(\n    ...    not_be_none,\n    ...    be_subclass_of(enum.IntEnum),\n    ...    be_subclass_of(int),\n    ...    be_subclass_of(str))\n    Traceback (most recent call last):\n    ...\n    TypeError: subclass '<enum 'MyEnum'>' should be subclass of '<class 'str'>'\n\n\n## Check that an item is not in container\n\n\n    >>> checked_item = Check(item=[1,2,3]).should(not_be_none, not_contain(51))\n    >>> checked_item = Check(item=[1,2,3]).should(not_be_none, not_contain(1))\n    Traceback (most recent call last):\n    ...\n    ValueError: 'item' should not contain '1'\n\n\n## Check that an item is in a container\n\n\n    >>> checked_item = Check(item=[1,2,3]).should(not_be_none, contain(1))\n    >>> checked_item = Check(item=[1,2,3]).should(not_be_none, contain(51))\n    Traceback (most recent call last):\n    ...\n    ValueError: 'item' should contain '51'\n\n\n## Check that a collection is not empty\n\n\n    >>> not_empty = Check(collection=[1,2,3]).should(not_be_none, not_be_empty)\n    >>> not_empty = Check(collection=set()).should(not_be_none, not_be_empty)\n    Traceback (most recent call last):\n    ...\n    ValueError: 'collection' should not be empty\n\n\n## Length checks for containers (strings)\n\n\n    >>> capped = Check(number=\"a\").should(not_be_none, be_shorter_than(2))\n    >>> capped = Check(number=\"aaa\").should(not_be_none, be_shorter_than(2))\n    Traceback (most recent call last):\n    ...\n    ValueError: number length '3' should be equal or less than '2'\n\n    >>> fixed = Check(number=\"aa\").should(not_be_none, be_length_of(2))\n    >>> fixed = Check(number=\"aaa\").should(not_be_none, be_length_of(2))\n    Traceback (most recent call last):\n    ...\n    ValueError: number length '3' should be equal with '2'\n\n\n## Range checks for numbers:\n\n    >>> positive = Check(number=-1).should(not_be_none, not_be_negative)\n    Traceback (most recent call last):\n    ...\n    ValueError: 'number' should not be negative\n\n    >>> positive = Check(number=-1).should(not_be_none, be_greater_than(0))\n    Traceback (most recent call last):\n    ...\n    ValueError: number '-1' should be greater than '0'\n\n    >>> positive = Check(number=4).should(not_be_none, be_less_than(1))\n    Traceback (most recent call last):\n    ...\n    ValueError: number '4' should be less than '1'\n\n\n## Equality checks\n\n\n    >>> equals_one = Check(number=\"1\").should(not_be_none, be_equal_with(\"1\"))\n    >>> equals_one = Check(number=\"2\").should(not_be_none, be_equal_with(\"1\"))\n    Traceback (most recent call last):\n    ...\n    ValueError: number '2' should be equal with '1'\n\n    >>> reference = object()\n    >>> equals_one = Check(object=reference).should(not_be_none, be(reference))\n    >>> equals_one = Check(object=\"another\").should(be(None))\n    Traceback (most recent call last):\n    ...\n    ValueError: object 'another' should (reference equally) be 'None'\n\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/SSHcom/python-should-check", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "python-should-check", "package_url": "https://pypi.org/project/python-should-check/", "platform": "", "project_url": "https://pypi.org/project/python-should-check/", "project_urls": {"Homepage": "https://github.com/SSHcom/python-should-check"}, "release_url": "https://pypi.org/project/python-should-check/0.0.3/", "requires_dist": null, "requires_python": "~=3.6", "summary": "Exception factory", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p># python-should-check</p>\n<p>Check parameters and raise comprehensible exceptions.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from should_check import (\n...    Check,\n...    be_callable,\n...    be_py_enum_str,\n...    be_instance_of,\n...    be_subclass_of,\n...    not_be_none,\n...    not_contain,\n...    contain,\n...    not_be_empty,\n...    be_shorter_than,\n...    be_length_of,\n...    not_be_negative,\n...    be_greater_than,\n...    be_less_than,\n...    be_equal_with,\n...    be,\n...    be_in)\n</pre>\n</blockquote>\n<p>## Check if a function is a callable and not None</p>\n<blockquote>\n<pre>&gt;&gt;&gt; function = Check(function=print).should(not_be_none, be_callable)\n&gt;&gt;&gt; function(\"Hello world\")\nHello world\n</pre>\n<pre>&gt;&gt;&gt; function = Check(function=None).should(not_be_none, be_callable)\nTraceback (most recent call last):\n...\nValueError: 'function' should not be None\n</pre>\n<pre>&gt;&gt;&gt; function = Check(function=\"boo\").should(not_be_none, be_callable)\nTraceback (most recent call last):\n...\nValueError: 'function' should be callable\n</pre>\n</blockquote>\n<p>If the \u2018None\u2019 would not go through some of these checks, it would be cumbersome to\ncheck optional parameters on your functions. This for example works:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; function = Check(function=None).should(be_callable)\n</pre>\n</blockquote>\n<p>But these wont:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; checked = Check(value=None).should(be(1))\nTraceback (most recent call last):\n...\nValueError: value 'None' should (reference equally) be '1'\n</pre>\n<pre>&gt;&gt;&gt; checked = Check(value=None).should(be_in([1,2]))\nTraceback (most recent call last):\n...\nValueError: value 'None' should be in '[1, 2]'\n</pre>\n<pre>&gt;&gt;&gt; checked = Check(value=None).should(be_equal_with(1))\nTraceback (most recent call last):\n...\nValueError: value 'None' should be equal with '1'\n</pre>\n</blockquote>\n<p>So be carefull with None and add the check everywhere like you should anyway.</p>\n<p>## Check if a string is a member of an enum definition</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import enum\n&gt;&gt;&gt; class MyEnum(enum.IntEnum):\n...   GOOD_ENUM = 0\n...   MEH_ENUM = 1\n...\n&gt;&gt;&gt; enum_str = Check(enum_str=\"GOOD_ENUM\").should(not_be_none, be_py_enum_str(MyEnum))\n&gt;&gt;&gt; enum_str = Check(enum_str=\"BAD_ENUM\").should(not_be_none, be_py_enum_str(MyEnum))\nTraceback (most recent call last):\n...\nTypeError: enum_str 'BAD_ENUM' should be one of '['GOOD_ENUM', 'MEH_ENUM']'\n</pre>\n</blockquote>\n<p>## Check if an object is an instance of a class</p>\n<blockquote>\n<pre>&gt;&gt;&gt; my_enum = MyEnum(0)\n&gt;&gt;&gt; second_enum = Check(my_enum=my_enum).should(not_be_none, be_instance_of(MyEnum))\n&gt;&gt;&gt; second_enum =  Check(my_enum=my_enum).should(not_be_none, be_instance_of(int))\n&gt;&gt;&gt; second_enum =  Check(my_enum=my_enum).should(not_be_none, be_instance_of(str))\nTraceback (most recent call last):\n...\nTypeError: my_enum '0' should be instance of '&lt;class 'str'&gt;'\n</pre>\n</blockquote>\n<p>## Check if a class is a subclass another</p>\n<blockquote>\n<pre>&gt;&gt;&gt; CheckedClass = Check(subclass=MyEnum).should(\n...    not_be_none,\n...    be_subclass_of(enum.IntEnum),\n...    be_subclass_of(int),\n...    be_subclass_of(str))\nTraceback (most recent call last):\n...\nTypeError: subclass '&lt;enum 'MyEnum'&gt;' should be subclass of '&lt;class 'str'&gt;'\n</pre>\n</blockquote>\n<p>## Check that an item is not in container</p>\n<blockquote>\n<pre>&gt;&gt;&gt; checked_item = Check(item=[1,2,3]).should(not_be_none, not_contain(51))\n&gt;&gt;&gt; checked_item = Check(item=[1,2,3]).should(not_be_none, not_contain(1))\nTraceback (most recent call last):\n...\nValueError: 'item' should not contain '1'\n</pre>\n</blockquote>\n<p>## Check that an item is in a container</p>\n<blockquote>\n<pre>&gt;&gt;&gt; checked_item = Check(item=[1,2,3]).should(not_be_none, contain(1))\n&gt;&gt;&gt; checked_item = Check(item=[1,2,3]).should(not_be_none, contain(51))\nTraceback (most recent call last):\n...\nValueError: 'item' should contain '51'\n</pre>\n</blockquote>\n<p>## Check that a collection is not empty</p>\n<blockquote>\n<pre>&gt;&gt;&gt; not_empty = Check(collection=[1,2,3]).should(not_be_none, not_be_empty)\n&gt;&gt;&gt; not_empty = Check(collection=set()).should(not_be_none, not_be_empty)\nTraceback (most recent call last):\n...\nValueError: 'collection' should not be empty\n</pre>\n</blockquote>\n<p>## Length checks for containers (strings)</p>\n<blockquote>\n<pre>&gt;&gt;&gt; capped = Check(number=\"a\").should(not_be_none, be_shorter_than(2))\n&gt;&gt;&gt; capped = Check(number=\"aaa\").should(not_be_none, be_shorter_than(2))\nTraceback (most recent call last):\n...\nValueError: number length '3' should be equal or less than '2'\n</pre>\n<pre>&gt;&gt;&gt; fixed = Check(number=\"aa\").should(not_be_none, be_length_of(2))\n&gt;&gt;&gt; fixed = Check(number=\"aaa\").should(not_be_none, be_length_of(2))\nTraceback (most recent call last):\n...\nValueError: number length '3' should be equal with '2'\n</pre>\n</blockquote>\n<p>## Range checks for numbers:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; positive = Check(number=-1).should(not_be_none, not_be_negative)\nTraceback (most recent call last):\n...\nValueError: 'number' should not be negative\n</pre>\n<pre>&gt;&gt;&gt; positive = Check(number=-1).should(not_be_none, be_greater_than(0))\nTraceback (most recent call last):\n...\nValueError: number '-1' should be greater than '0'\n</pre>\n<pre>&gt;&gt;&gt; positive = Check(number=4).should(not_be_none, be_less_than(1))\nTraceback (most recent call last):\n...\nValueError: number '4' should be less than '1'\n</pre>\n</blockquote>\n<p>## Equality checks</p>\n<blockquote>\n<pre>&gt;&gt;&gt; equals_one = Check(number=\"1\").should(not_be_none, be_equal_with(\"1\"))\n&gt;&gt;&gt; equals_one = Check(number=\"2\").should(not_be_none, be_equal_with(\"1\"))\nTraceback (most recent call last):\n...\nValueError: number '2' should be equal with '1'\n</pre>\n<pre>&gt;&gt;&gt; reference = object()\n&gt;&gt;&gt; equals_one = Check(object=reference).should(not_be_none, be(reference))\n&gt;&gt;&gt; equals_one = Check(object=\"another\").should(be(None))\nTraceback (most recent call last):\n...\nValueError: object 'another' should (reference equally) be 'None'\n</pre>\n</blockquote>\n\n          </div>"}, "last_serial": 4058261, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "939b1719bb94e6ecd2ecc03a566eab82", "sha256": "acdfa0a335f3ed30b3a771d678a89573abd7b24a3aeb3d98ecae304d2e07aafb"}, "downloads": -1, "filename": "python_should_check-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "939b1719bb94e6ecd2ecc03a566eab82", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": "~=3.6", "size": 5650, "upload_time": "2018-07-12T16:41:25", "upload_time_iso_8601": "2018-07-12T16:41:25.396641Z", "url": "https://files.pythonhosted.org/packages/65/aa/59d56965373be31a522da7a9a0543ef0b8092eb25af616b726d68926f4b8/python_should_check-0.0.2-py3-none-any.whl", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "f2381c0cb40e14eda1b619c449ffe9ba", "sha256": "9e09eecf03a4e4f07818ebd17705b59ef57afee494b3fda4dbd6e79548182fe8"}, "downloads": -1, "filename": "python_should_check-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "f2381c0cb40e14eda1b619c449ffe9ba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": "~=3.6", "size": 5644, "upload_time": "2018-07-13T15:05:05", "upload_time_iso_8601": "2018-07-13T15:05:05.940235Z", "url": "https://files.pythonhosted.org/packages/8f/5e/0ce554253099554ab528bb8e05e439472cc4faeff0ae3a29646c56fe499f/python_should_check-0.0.3-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f2381c0cb40e14eda1b619c449ffe9ba", "sha256": "9e09eecf03a4e4f07818ebd17705b59ef57afee494b3fda4dbd6e79548182fe8"}, "downloads": -1, "filename": "python_should_check-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "f2381c0cb40e14eda1b619c449ffe9ba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": "~=3.6", "size": 5644, "upload_time": "2018-07-13T15:05:05", "upload_time_iso_8601": "2018-07-13T15:05:05.940235Z", "url": "https://files.pythonhosted.org/packages/8f/5e/0ce554253099554ab528bb8e05e439472cc4faeff0ae3a29646c56fe499f/python_should_check-0.0.3-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:15:24 2020"}