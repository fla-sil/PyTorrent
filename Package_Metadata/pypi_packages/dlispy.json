{"info": {"author": "", "author_email": "", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6"], "description": "# Introduction\nParser for DLIS-files (Digital Log Interchange Standard), a binary format for Well Log Data, described by [RP66 Version 1](http://w3.energistics.org/rp66/v1/Toc/main.html)\n\n# Scope\nThis parser can handle the both the visiable envolope and logical format of RP66 version 1 which means as long as it is a DLIS file end up on a computer/server, this parser should be able to read and parse it. However, it is in a disk tape, this parser will Not be able to parse it.\nMost of format defined in standard has been coverred, for example\n-   Logical file and multiple logical files in a single DLIS file\n-   EFLR (both public EFLR and private EFLR) and IFLR (FData, EoF and NOFORM IFLR)\n-   Multiple dimension FData\n-   This parser has limited support for encrypted DLIS files. For example, it is only able to read Producer's Company Code from the Logical Record Segment. Also can't read the encrypted FData\n-   Currently this parser only support RP66 version 1, version 2 is out of scope since it is NOT actively used.\n-   So far, only reading of DLIS file is supported, writing or updating is not supported\n\n# Installation\nRight now we have not hosted this parser at https://pypi.org, but still you can install it as local package via `pip install`:\n-   Make sure you have python 3.5+\n-   (Optional) Create a virtualenv with python 3.5+\n-   Go to parental folder of this repository, then install the package `pip install -e dlispy`\n\n# How to use\nHere is a code snippet demonstrating how to use its API:\n\n## Use it as command line tool\nAfter install it as package, you can transform single DLIS file or a folder which includes DLIS files with following command:\n    `python -m dlispy.core --input=<path to single dlis file or a folder> --output=<output path> --eflronly=<if True only dump EFPRs, otherwise dump everything>`\n\n### Output\nWhen uses this parser to parse some dlis file and generate output, in the specified output directory, you can expect one folder for each logical file from original dlis file. In each logical file folder, following parts are included:\n-   A directory named `UnformattedDataLogicalRecords` which includes all the Unformatted Data Logical Records. For each records, there are two part, the binary data file and a json file describes its `CONSUMER-NAME` and `DESCRIPTION`\n-   A json file which represents all the EFLRs in the logical file\n-   A set of CSV files, each represents all the FData for one frame. Note: the value for a channel could be a single integer, a list of integer of float, or a multiple dimension volume.\n The parse always squeeze the high dimension volumen to 1 dimension list, for example a channel value with dimension [320, 6] will be squeezed to a list with length 1920 (320x6). After get such list, you can look back the csv file to figure out the dimension and restore to its high dimension representation.\n\n## How to parse a dlis file and iterate through logical records:\n```python\n\nfrom dlispy import LogicalFile, Object, Attribute, FrameData, PrivateEncryptedEFLR, parse\n# you can also set eflrOnly as True to only load EFLRs\n_, logical_file_list = parse('../data/206_05a-_3_DWL_DWL_WIRE_258276498.DLIS', eflr_only= False) \nfor lf  in logical_file_list: # type:LogicalFile\n    print(\"LogicalFile with ID:{}, SequenceNumber:{}\".format(lf.id, lf.seqNum))\n    for eflr in lf.eflrList:\n        if type(eflr) is PrivateEncryptedEFLR:              # PrivateEncryptedEFLR needs to handle separately.\n            continue\n        print(\"     Set with Type:{}, Name:{}\".format(eflr.setType, eflr.setName))\n        for obj in eflr.objects: # type:Object\n            print(\"             Object with Name:{}\".format(obj.name))\n            for attribute in obj.attributes:    #type:Attribute\n                print(\"                     Attribute with Label:{}, Value:{}, Count:{}, RepCode:{}, Units:{} \".\n                      format(attribute.label, ' '.join(map(str, attribute.value)) \n                      if type(attribute.value) is list else attribute.value, \n                      attribute.count, attribute.repCode, attribute.units))\n\n    for frameName, fDataList in lf.frameDataDict.items():\n        print(\"     Frame:{}\".format(frameName))\n        for fdata in fDataList: # type:FrameData\n            print(\"             FrameData with FrameNumber:{} and {} of slots\".\n            format(fdata.frameNumber, len(fdata.slots)))\n\n```\n\n## How to dump a dlis file to a readable format\n\nIn this sample code, you can see How to dump a dlis file to a read format including. Since each dlis file could include one or more logical files,\nthere is no dependency between logical record cross logical files, so it means treat each logical file seperately, thus we create\nseparate folder for each logical file in the given output path, we use `id` of the logical file as folder name. In each folder, there are following content:\n- a json file which includes all EFLRs (public and private oens) in this logical file\n- a set of csv files each represents one frame. The naming convension of the file is `<origin of ObjectName>_<copy of ObjectName>_<identifier of ObjectName>.csv`.\nIn the csv file, each column represents one channel and each row represents one FrameData. For high dimension channel, the value is squeezed into single\ndimension array and user can use channel dimension attribute in the json file to convert it back.\n- a folder named `UnformattedDataLogicalRecords`, all the `Unformatted Data LogicalRecords` are stored in this folder in binary format.\n\n```python\n\nfrom dlispy import dump\n# you can also set eflrOnly as True to only dump the EFLRs as json file load EFLRs\ndump('../data/206_05a-_3_DWL_DWL_WIRE_258276498.DLIS', output_path='output', eflr_only= False)\n\n```\n\n### Advance usage\nIn this sample code, you will see how to find information about specific object in specific type of EFLR.\n\n```python\n\nfrom dlispy import LogicalFile, Object, Attribute, FrameData, PrivateEncryptedEFLR, parse\nfrom dlispy import OlrEFLR, FrameEFLR\nfrom dlispy import Frame, FrameData, Origin\n# you can also set eflrOnly as True to only load EFLRs\n_, logical_file_list = parse('../../data/206_05a-_3_DWL_DWL_WIRE_258276498.DLIS')\nfor lf  in logical_file_list: # type:LogicalFile\n    for eflr in lf.eflrList:\n        if type(eflr) is OlrEFLR:\n            for obj in eflr.objects: #type:Origin\n                print(\"File {} created by company {} at {}\".format(\n                    obj.getAttrValue(Origin.FILE_ID),obj.getAttrValue(Origin.COMPANY),obj.getAttrValue(Origin.CREATION_TIME)))\n\n        if type(eflr) is FrameEFLR:\n            for obj in eflr.objects: #type:Frame\n                chanel_names = ', '.join(map(str, obj.getAttrValue(Frame.CHANNELS)))\n                print(\"Frame {} with channel list {}\".format(obj.name, chanel_names))\n\n```\n\n# Additional tips:\n## Compability test for different Python versions:\n -  Install tool: `pip install tox pytest pyenv`\n -  Then make sure you have python 3.5, 3.6 install\n -  `tox`\n## Generate coverage report:\n`py.test --cov-report html --cov=dlis_parser  dlis_parser/tests/test_basic.py`\n## Generate docs:\n-   Install sphinx: `brew install sphinx-doc`\n-   Delete old `.rst` files except `index.rst` in docs folder\n-   Re-generate `.rst` file source code:\n`cd docs;sphinx-apidoc -o .  ../dlis_parser ../dlis_parser/tests/*; cd ..`\n-   Generate HTML docs: `cd docs;make clean html`\n-   Then you can find documentation at `docs/_build/html` directory\n\n# License\nThis project is licenced under [BSD-3-Clause](https://spdx.org/licenses/BSD-3-Clause.html)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/teradata/dlispy", "keywords": "", "license": "BSD-3-Clause", "maintainer": "", "maintainer_email": "", "name": "dlispy", "package_url": "https://pypi.org/project/dlispy/", "platform": "any", "project_url": "https://pypi.org/project/dlispy/", "project_urls": {"Homepage": "https://github.com/teradata/dlispy"}, "release_url": "https://pypi.org/project/dlispy/0.0.2/", "requires_dist": ["atomicwrites (==1.1.5)", "attrs (==18.1.0)", "click (==6.7)", "more-itertools (==4.3.0)", "pluggy (==0.7.1)", "py (==1.5.4)", "pytest (==3.7.1)", "six (==1.11.0)"], "requires_python": ">=3.5", "summary": "A python library to parse DLIS file", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Introduction</h1>\n<p>Parser for DLIS-files (Digital Log Interchange Standard), a binary format for Well Log Data, described by <a href=\"http://w3.energistics.org/rp66/v1/Toc/main.html\" rel=\"nofollow\">RP66 Version 1</a></p>\n<h1>Scope</h1>\n<p>This parser can handle the both the visiable envolope and logical format of RP66 version 1 which means as long as it is a DLIS file end up on a computer/server, this parser should be able to read and parse it. However, it is in a disk tape, this parser will Not be able to parse it.\nMost of format defined in standard has been coverred, for example</p>\n<ul>\n<li>Logical file and multiple logical files in a single DLIS file</li>\n<li>EFLR (both public EFLR and private EFLR) and IFLR (FData, EoF and NOFORM IFLR)</li>\n<li>Multiple dimension FData</li>\n<li>This parser has limited support for encrypted DLIS files. For example, it is only able to read Producer's Company Code from the Logical Record Segment. Also can't read the encrypted FData</li>\n<li>Currently this parser only support RP66 version 1, version 2 is out of scope since it is NOT actively used.</li>\n<li>So far, only reading of DLIS file is supported, writing or updating is not supported</li>\n</ul>\n<h1>Installation</h1>\n<p>Right now we have not hosted this parser at <a href=\"https://pypi.org\" rel=\"nofollow\">https://pypi.org</a>, but still you can install it as local package via <code>pip install</code>:</p>\n<ul>\n<li>Make sure you have python 3.5+</li>\n<li>(Optional) Create a virtualenv with python 3.5+</li>\n<li>Go to parental folder of this repository, then install the package <code>pip install -e dlispy</code></li>\n</ul>\n<h1>How to use</h1>\n<p>Here is a code snippet demonstrating how to use its API:</p>\n<h2>Use it as command line tool</h2>\n<p>After install it as package, you can transform single DLIS file or a folder which includes DLIS files with following command:\n<code>python -m dlispy.core --input=&lt;path to single dlis file or a folder&gt; --output=&lt;output path&gt; --eflronly=&lt;if True only dump EFPRs, otherwise dump everything&gt;</code></p>\n<h3>Output</h3>\n<p>When uses this parser to parse some dlis file and generate output, in the specified output directory, you can expect one folder for each logical file from original dlis file. In each logical file folder, following parts are included:</p>\n<ul>\n<li>A directory named <code>UnformattedDataLogicalRecords</code> which includes all the Unformatted Data Logical Records. For each records, there are two part, the binary data file and a json file describes its <code>CONSUMER-NAME</code> and <code>DESCRIPTION</code></li>\n<li>A json file which represents all the EFLRs in the logical file</li>\n<li>A set of CSV files, each represents all the FData for one frame. Note: the value for a channel could be a single integer, a list of integer of float, or a multiple dimension volume.\nThe parse always squeeze the high dimension volumen to 1 dimension list, for example a channel value with dimension [320, 6] will be squeezed to a list with length 1920 (320x6). After get such list, you can look back the csv file to figure out the dimension and restore to its high dimension representation.</li>\n</ul>\n<h2>How to parse a dlis file and iterate through logical records:</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">dlispy</span> <span class=\"kn\">import</span> <span class=\"n\">LogicalFile</span><span class=\"p\">,</span> <span class=\"n\">Object</span><span class=\"p\">,</span> <span class=\"n\">Attribute</span><span class=\"p\">,</span> <span class=\"n\">FrameData</span><span class=\"p\">,</span> <span class=\"n\">PrivateEncryptedEFLR</span><span class=\"p\">,</span> <span class=\"n\">parse</span>\n<span class=\"c1\"># you can also set eflrOnly as True to only load EFLRs</span>\n<span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">logical_file_list</span> <span class=\"o\">=</span> <span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'../data/206_05a-_3_DWL_DWL_WIRE_258276498.DLIS'</span><span class=\"p\">,</span> <span class=\"n\">eflr_only</span><span class=\"o\">=</span> <span class=\"kc\">False</span><span class=\"p\">)</span> \n<span class=\"k\">for</span> <span class=\"n\">lf</span>  <span class=\"ow\">in</span> <span class=\"n\">logical_file_list</span><span class=\"p\">:</span> <span class=\"c1\"># type:LogicalFile</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"LogicalFile with ID:</span><span class=\"si\">{}</span><span class=\"s2\">, SequenceNumber:</span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">lf</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">lf</span><span class=\"o\">.</span><span class=\"n\">seqNum</span><span class=\"p\">))</span>\n    <span class=\"k\">for</span> <span class=\"n\">eflr</span> <span class=\"ow\">in</span> <span class=\"n\">lf</span><span class=\"o\">.</span><span class=\"n\">eflrList</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">eflr</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"n\">PrivateEncryptedEFLR</span><span class=\"p\">:</span>              <span class=\"c1\"># PrivateEncryptedEFLR needs to handle separately.</span>\n            <span class=\"k\">continue</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"     Set with Type:</span><span class=\"si\">{}</span><span class=\"s2\">, Name:</span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">eflr</span><span class=\"o\">.</span><span class=\"n\">setType</span><span class=\"p\">,</span> <span class=\"n\">eflr</span><span class=\"o\">.</span><span class=\"n\">setName</span><span class=\"p\">))</span>\n        <span class=\"k\">for</span> <span class=\"n\">obj</span> <span class=\"ow\">in</span> <span class=\"n\">eflr</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"p\">:</span> <span class=\"c1\"># type:Object</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"             Object with Name:</span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">))</span>\n            <span class=\"k\">for</span> <span class=\"n\">attribute</span> <span class=\"ow\">in</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">attributes</span><span class=\"p\">:</span>    <span class=\"c1\">#type:Attribute</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"                     Attribute with Label:</span><span class=\"si\">{}</span><span class=\"s2\">, Value:</span><span class=\"si\">{}</span><span class=\"s2\">, Count:</span><span class=\"si\">{}</span><span class=\"s2\">, RepCode:</span><span class=\"si\">{}</span><span class=\"s2\">, Units:</span><span class=\"si\">{}</span><span class=\"s2\"> \"</span><span class=\"o\">.</span>\n                      <span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"n\">attribute</span><span class=\"o\">.</span><span class=\"n\">label</span><span class=\"p\">,</span> <span class=\"s1\">' '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">attribute</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">))</span> \n                      <span class=\"k\">if</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">attribute</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"nb\">list</span> <span class=\"k\">else</span> <span class=\"n\">attribute</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">,</span> \n                      <span class=\"n\">attribute</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">,</span> <span class=\"n\">attribute</span><span class=\"o\">.</span><span class=\"n\">repCode</span><span class=\"p\">,</span> <span class=\"n\">attribute</span><span class=\"o\">.</span><span class=\"n\">units</span><span class=\"p\">))</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">frameName</span><span class=\"p\">,</span> <span class=\"n\">fDataList</span> <span class=\"ow\">in</span> <span class=\"n\">lf</span><span class=\"o\">.</span><span class=\"n\">frameDataDict</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"     Frame:</span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">frameName</span><span class=\"p\">))</span>\n        <span class=\"k\">for</span> <span class=\"n\">fdata</span> <span class=\"ow\">in</span> <span class=\"n\">fDataList</span><span class=\"p\">:</span> <span class=\"c1\"># type:FrameData</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"             FrameData with FrameNumber:</span><span class=\"si\">{}</span><span class=\"s2\"> and </span><span class=\"si\">{}</span><span class=\"s2\"> of slots\"</span><span class=\"o\">.</span>\n            <span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"n\">fdata</span><span class=\"o\">.</span><span class=\"n\">frameNumber</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">fdata</span><span class=\"o\">.</span><span class=\"n\">slots</span><span class=\"p\">)))</span>\n</pre>\n<h2>How to dump a dlis file to a readable format</h2>\n<p>In this sample code, you can see How to dump a dlis file to a read format including. Since each dlis file could include one or more logical files,\nthere is no dependency between logical record cross logical files, so it means treat each logical file seperately, thus we create\nseparate folder for each logical file in the given output path, we use <code>id</code> of the logical file as folder name. In each folder, there are following content:</p>\n<ul>\n<li>a json file which includes all EFLRs (public and private oens) in this logical file</li>\n<li>a set of csv files each represents one frame. The naming convension of the file is <code>&lt;origin of ObjectName&gt;_&lt;copy of ObjectName&gt;_&lt;identifier of ObjectName&gt;.csv</code>.\nIn the csv file, each column represents one channel and each row represents one FrameData. For high dimension channel, the value is squeezed into single\ndimension array and user can use channel dimension attribute in the json file to convert it back.</li>\n<li>a folder named <code>UnformattedDataLogicalRecords</code>, all the <code>Unformatted Data LogicalRecords</code> are stored in this folder in binary format.</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">dlispy</span> <span class=\"kn\">import</span> <span class=\"n\">dump</span>\n<span class=\"c1\"># you can also set eflrOnly as True to only dump the EFLRs as json file load EFLRs</span>\n<span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"s1\">'../data/206_05a-_3_DWL_DWL_WIRE_258276498.DLIS'</span><span class=\"p\">,</span> <span class=\"n\">output_path</span><span class=\"o\">=</span><span class=\"s1\">'output'</span><span class=\"p\">,</span> <span class=\"n\">eflr_only</span><span class=\"o\">=</span> <span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<h3>Advance usage</h3>\n<p>In this sample code, you will see how to find information about specific object in specific type of EFLR.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">dlispy</span> <span class=\"kn\">import</span> <span class=\"n\">LogicalFile</span><span class=\"p\">,</span> <span class=\"n\">Object</span><span class=\"p\">,</span> <span class=\"n\">Attribute</span><span class=\"p\">,</span> <span class=\"n\">FrameData</span><span class=\"p\">,</span> <span class=\"n\">PrivateEncryptedEFLR</span><span class=\"p\">,</span> <span class=\"n\">parse</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dlispy</span> <span class=\"kn\">import</span> <span class=\"n\">OlrEFLR</span><span class=\"p\">,</span> <span class=\"n\">FrameEFLR</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dlispy</span> <span class=\"kn\">import</span> <span class=\"n\">Frame</span><span class=\"p\">,</span> <span class=\"n\">FrameData</span><span class=\"p\">,</span> <span class=\"n\">Origin</span>\n<span class=\"c1\"># you can also set eflrOnly as True to only load EFLRs</span>\n<span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">logical_file_list</span> <span class=\"o\">=</span> <span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'../../data/206_05a-_3_DWL_DWL_WIRE_258276498.DLIS'</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">lf</span>  <span class=\"ow\">in</span> <span class=\"n\">logical_file_list</span><span class=\"p\">:</span> <span class=\"c1\"># type:LogicalFile</span>\n    <span class=\"k\">for</span> <span class=\"n\">eflr</span> <span class=\"ow\">in</span> <span class=\"n\">lf</span><span class=\"o\">.</span><span class=\"n\">eflrList</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">eflr</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"n\">OlrEFLR</span><span class=\"p\">:</span>\n            <span class=\"k\">for</span> <span class=\"n\">obj</span> <span class=\"ow\">in</span> <span class=\"n\">eflr</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"p\">:</span> <span class=\"c1\">#type:Origin</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"File </span><span class=\"si\">{}</span><span class=\"s2\"> created by company </span><span class=\"si\">{}</span><span class=\"s2\"> at </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span>\n                    <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">getAttrValue</span><span class=\"p\">(</span><span class=\"n\">Origin</span><span class=\"o\">.</span><span class=\"n\">FILE_ID</span><span class=\"p\">),</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">getAttrValue</span><span class=\"p\">(</span><span class=\"n\">Origin</span><span class=\"o\">.</span><span class=\"n\">COMPANY</span><span class=\"p\">),</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">getAttrValue</span><span class=\"p\">(</span><span class=\"n\">Origin</span><span class=\"o\">.</span><span class=\"n\">CREATION_TIME</span><span class=\"p\">)))</span>\n\n        <span class=\"k\">if</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">eflr</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"n\">FrameEFLR</span><span class=\"p\">:</span>\n            <span class=\"k\">for</span> <span class=\"n\">obj</span> <span class=\"ow\">in</span> <span class=\"n\">eflr</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"p\">:</span> <span class=\"c1\">#type:Frame</span>\n                <span class=\"n\">chanel_names</span> <span class=\"o\">=</span> <span class=\"s1\">', '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">getAttrValue</span><span class=\"p\">(</span><span class=\"n\">Frame</span><span class=\"o\">.</span><span class=\"n\">CHANNELS</span><span class=\"p\">)))</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Frame </span><span class=\"si\">{}</span><span class=\"s2\"> with channel list </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">chanel_names</span><span class=\"p\">))</span>\n</pre>\n<h1>Additional tips:</h1>\n<h2>Compability test for different Python versions:</h2>\n<ul>\n<li>Install tool: <code>pip install tox pytest pyenv</code></li>\n<li>Then make sure you have python 3.5, 3.6 install</li>\n<li><code>tox</code></li>\n</ul>\n<h2>Generate coverage report:</h2>\n<p><code>py.test --cov-report html --cov=dlis_parser dlis_parser/tests/test_basic.py</code></p>\n<h2>Generate docs:</h2>\n<ul>\n<li>Install sphinx: <code>brew install sphinx-doc</code></li>\n<li>Delete old <code>.rst</code> files except <code>index.rst</code> in docs folder</li>\n<li>Re-generate <code>.rst</code> file source code:\n<code>cd docs;sphinx-apidoc -o . ../dlis_parser ../dlis_parser/tests/*; cd ..</code></li>\n<li>Generate HTML docs: <code>cd docs;make clean html</code></li>\n<li>Then you can find documentation at <code>docs/_build/html</code> directory</li>\n</ul>\n<h1>License</h1>\n<p>This project is licenced under <a href=\"https://spdx.org/licenses/BSD-3-Clause.html\" rel=\"nofollow\">BSD-3-Clause</a></p>\n\n          </div>"}, "last_serial": 4572329, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "86c22c601c34eeb6768eb965584ed279", "sha256": "989ec4e0386b2e65247ddb22b4e00891565827e99c3bde4d9833c17b5c19746e"}, "downloads": -1, "filename": "dlispy-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "86c22c601c34eeb6768eb965584ed279", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 32088, "upload_time": "2018-12-07T15:12:35", "upload_time_iso_8601": "2018-12-07T15:12:35.542390Z", "url": "https://files.pythonhosted.org/packages/18/40/9552af17f318e72e28982b541bf8193db731b5d586fe00183918492c101d/dlispy-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bae988a6b04c2f7b1e9d004a0ee3d679", "sha256": "169ec9a9e3f395593e304024eb68bf2b22a6c2d177e6c3191d5166d7bbe2c819"}, "downloads": -1, "filename": "dlispy-0.0.1.tar.gz", "has_sig": false, "md5_digest": "bae988a6b04c2f7b1e9d004a0ee3d679", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 23790, "upload_time": "2018-12-07T15:12:38", "upload_time_iso_8601": "2018-12-07T15:12:38.030332Z", "url": "https://files.pythonhosted.org/packages/9a/94/729d1d596567f91e6ff4072ded01229048579c01f55a0998479f9e1d83d9/dlispy-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "4fce41fcef6917d9e39295415e4f8a9c", "sha256": "35c9facde28adbc4b3da464de7681b1cbc2da63efd5f79ee7afb011a8d32078f"}, "downloads": -1, "filename": "dlispy-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "4fce41fcef6917d9e39295415e4f8a9c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 32084, "upload_time": "2018-12-07T15:17:21", "upload_time_iso_8601": "2018-12-07T15:17:21.609223Z", "url": "https://files.pythonhosted.org/packages/fd/50/346b560854991b3fe84a74be6ed1ebfe948d4f97a49ec213fce68932de28/dlispy-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "67de42452ace1821c87a3fe014cc7e4f", "sha256": "cd6ea3b90de47b1d6b561c91f19864d3d9dad5367ecd059b85763fb58aa49c30"}, "downloads": -1, "filename": "dlispy-0.0.2.tar.gz", "has_sig": false, "md5_digest": "67de42452ace1821c87a3fe014cc7e4f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 23786, "upload_time": "2018-12-07T15:17:22", "upload_time_iso_8601": "2018-12-07T15:17:22.821577Z", "url": "https://files.pythonhosted.org/packages/85/fd/fd9e105385163168bbeb91461f73806f98bf584283378642499f0e26d019/dlispy-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4fce41fcef6917d9e39295415e4f8a9c", "sha256": "35c9facde28adbc4b3da464de7681b1cbc2da63efd5f79ee7afb011a8d32078f"}, "downloads": -1, "filename": "dlispy-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "4fce41fcef6917d9e39295415e4f8a9c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 32084, "upload_time": "2018-12-07T15:17:21", "upload_time_iso_8601": "2018-12-07T15:17:21.609223Z", "url": "https://files.pythonhosted.org/packages/fd/50/346b560854991b3fe84a74be6ed1ebfe948d4f97a49ec213fce68932de28/dlispy-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "67de42452ace1821c87a3fe014cc7e4f", "sha256": "cd6ea3b90de47b1d6b561c91f19864d3d9dad5367ecd059b85763fb58aa49c30"}, "downloads": -1, "filename": "dlispy-0.0.2.tar.gz", "has_sig": false, "md5_digest": "67de42452ace1821c87a3fe014cc7e4f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 23786, "upload_time": "2018-12-07T15:17:22", "upload_time_iso_8601": "2018-12-07T15:17:22.821577Z", "url": "https://files.pythonhosted.org/packages/85/fd/fd9e105385163168bbeb91461f73806f98bf584283378642499f0e26d019/dlispy-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:19 2020"}