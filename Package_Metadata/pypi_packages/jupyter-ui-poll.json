{"info": {"author": "Kirill Kouzoubov", "author_email": "kirill888@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Framework :: Jupyter", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "===============\njupyter-ui-poll\n===============\n\n.. image:: https://mybinder.org/badge_logo.svg\n :target: `run it`_\n\nBlock Jupyter cell execution while interacting with widgets.\n\nThis library is for people familiar with ``ipywidgets`` who want to solve the\nfollowing problem:\n\n1. Display User Interface in Jupyter [#]_ using ``ipywidgets`` [#]_ or similar\n2. Wait for data to be entered (this step is surprisingly non-trivial to implement)\n3. Use entered data in cells below\n\nYou want to implement a notebook like the one below\n\n.. code-block:: python\n\n   # cell 1\n   ui = make_ui()\n   display(ui)\n   data = ui.wait_for_data()\n\n   # cell 2\n   do_things_with(data)\n\n   # cell 3.\n   do_more_tings()\n\nAnd you want to be able to execute ``Cells -> Run All`` menu option and still get correct output.\n\nThis library assists in implementing your custom ``ui.wait_for_data()`` poll loop.\nIf you have tried implementing such workflow in the past you'll know that it is\nnot that simple. If you haven't, see `Technical Details`_ section below for an\nexplanation on why it's hard and how ``jupyter-ui-poll`` solves it.\n\nQuick, self contained example:\n\n.. code-block:: python\n\n   import time\n   from ipywidgets import Button\n   from jupyter_ui_poll import ui_events\n\n   # Set up simple GUI, button with on_click callback\n   # that sets ui_done=True and changes button text\n   ui_done = False\n   def on_click(btn):\n       global ui_done\n       ui_done = True\n       btn.description = '\ud83d\udc4d'\n\n   btn = Button(description='Click Me')\n   btn.on_click(on_click)\n   display(btn)\n\n   # Wait for user to press the button\n   with ui_events() as poll:\n       while ui_done is False:\n           poll(10)                # React to UI events (upto 10 at a time)\n           print('.', end='')\n           time.sleep(0.1)\n   print('done')\n\nFor a more detailed tutorial see `Example notebook`_, you can also `run it`_ right now using awesome `Binder`_ service.\n\nInstallation\n============\n\nThis library requires Python 3.5 or greater\n\n::\n\n  pip install jupyter-ui-poll\n\n\nTechnical Details\n=================\n\nJupyter widgets (``ipywidgets``) provide an excellent foundation to develop\ninteractive data investigation apps directly inside Jupyter notebook or Jupyter\nlab environment. Jupyter is great at displaying data and ``ipywidgets`` provide\na mechanism to get input from the user in a more convenient way than entering or\nchanging Python code inside a Jupyter cell. Developer can construct an\ninteractive user interface often used to parameterise information display or\nother kinds of computation.\n\nInteractivity is handled with callbacks, ``ipywidget`` GUI is HTML based, user\nactions, like clicking a button, trigger JavaScript events that are then\ntranslated in to calls to Python code developer registered with the library. It\nis a significantly different, asynchronous, paradigm than your basic Jupyter\nnotebook which operates in a straightforward blocking, linear fashion. It is not\npossible to display a Modal UI that would block execution of other Jupyter cells\nuntil needed information is supplied by the user.\n\n``jupyter-ui-poll`` allows one to implement a \"blocking GUI\" inside a Jupyter\nenvironment. It is a common requirement to query user for some non-trivial input\nparameters that are easier to enter via GUI rather than code. User input happens\nat the top of the notebook, then that data is used in cells below. While this is\npossible to achieve directly with ``ipywidgets`` it requires teaching the user\nto enter all the needed data before moving on to execute the cells below. This\nis bound to cause some confusion and also breaks ``Cells -> Run All`` functionality.\n\nAn obvious solution is to keep running in a loop until all the needed data was\nentered by the user.\n\n.. code-block:: python\n\n   display(app.make_ui())\n   while not app.have_all_the_data():\n       time.sleep(0.1)\n\nA naive version of the code above does not work. This is because no widget\nevents are being processed while executing code inside a Jupyter cell. Callbacks\nyou have registered with the widget library won't get a chance to run and so\nstate of ``app.have_all_the_data()`` won't ever change. \"Execute code inside\nJupyter cell\" is just another event being processed by the IPython kernel, and\nonly one event is executed at a time. One could ask IPython kernel to process\nmore events by calling ``kernel.do_one_iteration()`` in the poll loop. This\nkinda works, callbacks will be called as input is entered, but IPython will also\nprocess \"execute cell\" events, so ``Cells -> Run All`` scenario will still be\nbroken, as code in lower cells will be executed before the data it operates on\nbecomes available.\n\nThis library hooks into IPython internal machinery to selectively execute events\nin a polling fashion, delaying code cell execution events until after\ninteractive part is over.\n\nBasic idea was copied from ``ipython_blocking`` [#]_ project:\n\n1. Overwrite ``execute_request`` handler in IPython kernel temporarily\n2. Call ``kernel.do_one_iteration()`` in a polling fashion until exit conditions are met\n3. Reinstate default handler for ``execute_request``\n4. Replay code cell execution events cached by custom handler taking care of\n   where output goes, and being careful about exception handling\n\n\n.. [#] https://jupyter.org/\n.. [#] https://github.com/jupyter-widgets/ipywidgets\n.. [#] https://github.com/kafonek/ipython_blocking\n\n.. _Example notebook : notebooks/Examples.ipynb\n.. _run it : https://mybinder.org/v2/gh/kirill888/jupyter-ui-poll/master?filepath=notebooks%2FExamples.ipynb\n.. _Binder : https://mybinder.org/\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kirill888/jupyter-ui-poll", "keywords": "jupyter,ipywidgets", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "jupyter-ui-poll", "package_url": "https://pypi.org/project/jupyter-ui-poll/", "platform": "", "project_url": "https://pypi.org/project/jupyter-ui-poll/", "project_urls": {"Homepage": "https://github.com/kirill888/jupyter-ui-poll"}, "release_url": "https://pypi.org/project/jupyter-ui-poll/0.1.2/", "requires_dist": ["ipython", "wheel ; extra == 'dev'", "jupyter ; extra == 'dev'"], "requires_python": ">= 3.5", "summary": "Block jupyter cell execution while interacting with widgets", "version": "0.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://mybinder.org/v2/gh/kirill888/jupyter-ui-poll/master?filepath=notebooks%2FExamples.ipynb\" rel=\"nofollow\"><img alt=\"https://mybinder.org/badge_logo.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/85e91bbb928104e4ce317951541520c6b9c170e1/68747470733a2f2f6d7962696e6465722e6f72672f62616467655f6c6f676f2e737667\"></a>\n<p>Block Jupyter cell execution while interacting with widgets.</p>\n<p>This library is for people familiar with <tt>ipywidgets</tt> who want to solve the\nfollowing problem:</p>\n<ol>\n<li>Display User Interface in Jupyter <a href=\"#id4\" id=\"id1\" rel=\"nofollow\">[1]</a> using <tt>ipywidgets</tt> <a href=\"#id5\" id=\"id2\" rel=\"nofollow\">[2]</a> or similar</li>\n<li>Wait for data to be entered (this step is surprisingly non-trivial to implement)</li>\n<li>Use entered data in cells below</li>\n</ol>\n<p>You want to implement a notebook like the one below</p>\n<pre><span class=\"c1\"># cell 1</span>\n<span class=\"n\">ui</span> <span class=\"o\">=</span> <span class=\"n\">make_ui</span><span class=\"p\">()</span>\n<span class=\"n\">display</span><span class=\"p\">(</span><span class=\"n\">ui</span><span class=\"p\">)</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">ui</span><span class=\"o\">.</span><span class=\"n\">wait_for_data</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># cell 2</span>\n<span class=\"n\">do_things_with</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># cell 3.</span>\n<span class=\"n\">do_more_tings</span><span class=\"p\">()</span>\n</pre>\n<p>And you want to be able to execute <tt>Cells <span class=\"pre\">-&gt;</span> Run All</tt> menu option and still get correct output.</p>\n<p>This library assists in implementing your custom <tt>ui.wait_for_data()</tt> poll loop.\nIf you have tried implementing such workflow in the past you\u2019ll know that it is\nnot that simple. If you haven\u2019t, see <a href=\"#technical-details\" rel=\"nofollow\">Technical Details</a> section below for an\nexplanation on why it\u2019s hard and how <tt><span class=\"pre\">jupyter-ui-poll</span></tt> solves it.</p>\n<p>Quick, self contained example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">time</span>\n<span class=\"kn\">from</span> <span class=\"nn\">ipywidgets</span> <span class=\"kn\">import</span> <span class=\"n\">Button</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jupyter_ui_poll</span> <span class=\"kn\">import</span> <span class=\"n\">ui_events</span>\n\n<span class=\"c1\"># Set up simple GUI, button with on_click callback</span>\n<span class=\"c1\"># that sets ui_done=True and changes button text</span>\n<span class=\"n\">ui_done</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"k\">def</span> <span class=\"nf\">on_click</span><span class=\"p\">(</span><span class=\"n\">btn</span><span class=\"p\">):</span>\n    <span class=\"k\">global</span> <span class=\"n\">ui_done</span>\n    <span class=\"n\">ui_done</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"n\">btn</span><span class=\"o\">.</span><span class=\"n\">description</span> <span class=\"o\">=</span> <span class=\"s1\">'\ud83d\udc4d'</span>\n\n<span class=\"n\">btn</span> <span class=\"o\">=</span> <span class=\"n\">Button</span><span class=\"p\">(</span><span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'Click Me'</span><span class=\"p\">)</span>\n<span class=\"n\">btn</span><span class=\"o\">.</span><span class=\"n\">on_click</span><span class=\"p\">(</span><span class=\"n\">on_click</span><span class=\"p\">)</span>\n<span class=\"n\">display</span><span class=\"p\">(</span><span class=\"n\">btn</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Wait for user to press the button</span>\n<span class=\"k\">with</span> <span class=\"n\">ui_events</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">poll</span><span class=\"p\">:</span>\n    <span class=\"k\">while</span> <span class=\"n\">ui_done</span> <span class=\"ow\">is</span> <span class=\"kc\">False</span><span class=\"p\">:</span>\n        <span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>                <span class=\"c1\"># React to UI events (upto 10 at a time)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'.'</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"o\">=</span><span class=\"s1\">''</span><span class=\"p\">)</span>\n        <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'done'</span><span class=\"p\">)</span>\n</pre>\n<p>For a more detailed tutorial see <a href=\"notebooks/Examples.ipynb\" rel=\"nofollow\">Example notebook</a>, you can also <a href=\"https://mybinder.org/v2/gh/kirill888/jupyter-ui-poll/master?filepath=notebooks%2FExamples.ipynb\" rel=\"nofollow\">run it</a> right now using awesome <a href=\"https://mybinder.org/\" rel=\"nofollow\">Binder</a> service.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>This library requires Python 3.5 or greater</p>\n<pre>pip install jupyter-ui-poll\n</pre>\n</div>\n<div id=\"technical-details\">\n<h2>Technical Details</h2>\n<p>Jupyter widgets (<tt>ipywidgets</tt>) provide an excellent foundation to develop\ninteractive data investigation apps directly inside Jupyter notebook or Jupyter\nlab environment. Jupyter is great at displaying data and <tt>ipywidgets</tt> provide\na mechanism to get input from the user in a more convenient way than entering or\nchanging Python code inside a Jupyter cell. Developer can construct an\ninteractive user interface often used to parameterise information display or\nother kinds of computation.</p>\n<p>Interactivity is handled with callbacks, <tt>ipywidget</tt> GUI is HTML based, user\nactions, like clicking a button, trigger JavaScript events that are then\ntranslated in to calls to Python code developer registered with the library. It\nis a significantly different, asynchronous, paradigm than your basic Jupyter\nnotebook which operates in a straightforward blocking, linear fashion. It is not\npossible to display a Modal UI that would block execution of other Jupyter cells\nuntil needed information is supplied by the user.</p>\n<p><tt><span class=\"pre\">jupyter-ui-poll</span></tt> allows one to implement a \u201cblocking GUI\u201d inside a Jupyter\nenvironment. It is a common requirement to query user for some non-trivial input\nparameters that are easier to enter via GUI rather than code. User input happens\nat the top of the notebook, then that data is used in cells below. While this is\npossible to achieve directly with <tt>ipywidgets</tt> it requires teaching the user\nto enter all the needed data before moving on to execute the cells below. This\nis bound to cause some confusion and also breaks <tt>Cells <span class=\"pre\">-&gt;</span> Run All</tt> functionality.</p>\n<p>An obvious solution is to keep running in a loop until all the needed data was\nentered by the user.</p>\n<pre><span class=\"n\">display</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">make_ui</span><span class=\"p\">())</span>\n<span class=\"k\">while</span> <span class=\"ow\">not</span> <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">have_all_the_data</span><span class=\"p\">():</span>\n    <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p>A naive version of the code above does not work. This is because no widget\nevents are being processed while executing code inside a Jupyter cell. Callbacks\nyou have registered with the widget library won\u2019t get a chance to run and so\nstate of <tt>app.have_all_the_data()</tt> won\u2019t ever change. \u201cExecute code inside\nJupyter cell\u201d is just another event being processed by the IPython kernel, and\nonly one event is executed at a time. One could ask IPython kernel to process\nmore events by calling <tt>kernel.do_one_iteration()</tt> in the poll loop. This\nkinda works, callbacks will be called as input is entered, but IPython will also\nprocess \u201cexecute cell\u201d events, so <tt>Cells <span class=\"pre\">-&gt;</span> Run All</tt> scenario will still be\nbroken, as code in lower cells will be executed before the data it operates on\nbecomes available.</p>\n<p>This library hooks into IPython internal machinery to selectively execute events\nin a polling fashion, delaying code cell execution events until after\ninteractive part is over.</p>\n<p>Basic idea was copied from <tt>ipython_blocking</tt> <a href=\"#id6\" id=\"id3\" rel=\"nofollow\">[3]</a> project:</p>\n<ol>\n<li>Overwrite <tt>execute_request</tt> handler in IPython kernel temporarily</li>\n<li>Call <tt>kernel.do_one_iteration()</tt> in a polling fashion until exit conditions are met</li>\n<li>Reinstate default handler for <tt>execute_request</tt></li>\n<li>Replay code cell execution events cached by custom handler taking care of\nwhere output goes, and being careful about exception handling</li>\n</ol>\n<table id=\"id4\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id1\" rel=\"nofollow\">[1]</a></td><td><a href=\"https://jupyter.org/\" rel=\"nofollow\">https://jupyter.org/</a></td></tr>\n</tbody>\n</table>\n<table id=\"id5\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id2\" rel=\"nofollow\">[2]</a></td><td><a href=\"https://github.com/jupyter-widgets/ipywidgets\" rel=\"nofollow\">https://github.com/jupyter-widgets/ipywidgets</a></td></tr>\n</tbody>\n</table>\n<table id=\"id6\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id3\" rel=\"nofollow\">[3]</a></td><td><a href=\"https://github.com/kafonek/ipython_blocking\" rel=\"nofollow\">https://github.com/kafonek/ipython_blocking</a></td></tr>\n</tbody>\n</table>\n</div>\n\n          </div>"}, "last_serial": 6397418, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "a740d4741a5726559b6359765760c505", "sha256": "eea5c5376c38e2d6e62c32f0e077832cf1f7f72e0df9bb64db4e45de5a1e5cc1"}, "downloads": -1, "filename": "jupyter_ui_poll-0.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a740d4741a5726559b6359765760c505", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">= 3.6", "size": 3609, "upload_time": "2019-09-22T11:23:30", "upload_time_iso_8601": "2019-09-22T11:23:30.226044Z", "url": "https://files.pythonhosted.org/packages/b3/c0/3922a8899a54904071964688613e5affa4274e9e6a445dc86f1c1a8c6692/jupyter_ui_poll-0.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bf4d19118d4329edde308766e32cd801", "sha256": "4ac9ff5e3ac644d2f1300a85174dc3ac27b26961f554eae22725020aa0e5eb06"}, "downloads": -1, "filename": "jupyter-ui-poll-0.0.1.tar.gz", "has_sig": false, "md5_digest": "bf4d19118d4329edde308766e32cd801", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.6", "size": 2161, "upload_time": "2019-09-22T11:23:32", "upload_time_iso_8601": "2019-09-22T11:23:32.751952Z", "url": "https://files.pythonhosted.org/packages/d0/2e/cdd500fdfeff01dc3bc0dac20a3bdc91653ce1d328c19c2e1596a9cc748c/jupyter-ui-poll-0.0.1.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "4d610e6d377f33eebfc0a717f5571454", "sha256": "297c49af1b6f76b197623073681f1a5f99e4848fafd246b3e0b1d8806f38bd95"}, "downloads": -1, "filename": "jupyter_ui_poll-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4d610e6d377f33eebfc0a717f5571454", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">= 3.5", "size": 6420, "upload_time": "2019-10-19T13:47:39", "upload_time_iso_8601": "2019-10-19T13:47:39.500586Z", "url": "https://files.pythonhosted.org/packages/9d/aa/c13150815960b2f00bdb91eb187528b621e620ab7753fe4faf838f8a9971/jupyter_ui_poll-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e8f1e0de9a4139ceb306203bd7478a23", "sha256": "9b663585230a9f3952c204ab1fd415e31b5d32771f08bc9845b00674a2f66168"}, "downloads": -1, "filename": "jupyter-ui-poll-0.1.0.tar.gz", "has_sig": false, "md5_digest": "e8f1e0de9a4139ceb306203bd7478a23", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 5400, "upload_time": "2019-10-19T13:47:41", "upload_time_iso_8601": "2019-10-19T13:47:41.553895Z", "url": "https://files.pythonhosted.org/packages/0f/08/2985cb15b0f6024e3b39388bc71b67f689fc0ea61a0d42e1ef908023d212/jupyter-ui-poll-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "7241e918bc2f06f8e94decb373cda7c9", "sha256": "a9bad0ca13c51f62cb573c38c8bb8f6bacd5b4b7d3c9663a2160c173d97b8507"}, "downloads": -1, "filename": "jupyter_ui_poll-0.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "7241e918bc2f06f8e94decb373cda7c9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">= 3.5", "size": 6581, "upload_time": "2019-10-26T10:53:43", "upload_time_iso_8601": "2019-10-26T10:53:43.406211Z", "url": "https://files.pythonhosted.org/packages/40/33/7ee27623a8ddba7135d2b7ed47effa82cca90956837ef7f5ed3ca9c0c6ff/jupyter_ui_poll-0.1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bc32a71d3afd9e94e2c7f4c9a17d5fe6", "sha256": "2224c1e130afcb6cc1e9ef57e8ced79ee8dc057761ad6474829f9ddb06cf4c12"}, "downloads": -1, "filename": "jupyter-ui-poll-0.1.1.tar.gz", "has_sig": false, "md5_digest": "bc32a71d3afd9e94e2c7f4c9a17d5fe6", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 5560, "upload_time": "2019-10-26T10:53:45", "upload_time_iso_8601": "2019-10-26T10:53:45.401130Z", "url": "https://files.pythonhosted.org/packages/1b/76/d98fd38bee7db70900de52e1105458b1e1f2b3dfca2c5a98a9c7ae1261b8/jupyter-ui-poll-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "42794791f7113efa72ce52d535da22a0", "sha256": "1c0a22149ef8893706abce3d8d43e5cbd9a9590573649f6ad13b8555f3f98925"}, "downloads": -1, "filename": "jupyter_ui_poll-0.1.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "42794791f7113efa72ce52d535da22a0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">= 3.5", "size": 6591, "upload_time": "2020-01-05T06:40:33", "upload_time_iso_8601": "2020-01-05T06:40:33.523490Z", "url": "https://files.pythonhosted.org/packages/fc/4d/f7cb8ea5bad31fa68dfb689c9fa51e0ffa8ed08f4e07c3d3acac005f3506/jupyter_ui_poll-0.1.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f52345bc11e43ad0e9a45182c1268c43", "sha256": "191cddaf82ec5b8e466528f0c654fbc178ddeb58d396f0dd826a5801a5f0f16b"}, "downloads": -1, "filename": "jupyter-ui-poll-0.1.2.tar.gz", "has_sig": false, "md5_digest": "f52345bc11e43ad0e9a45182c1268c43", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 5566, "upload_time": "2020-01-05T06:40:34", "upload_time_iso_8601": "2020-01-05T06:40:34.885630Z", "url": "https://files.pythonhosted.org/packages/50/33/8a9f0e3da0dcba9b737039cf3808ebdeee4770e6e0c80ee41352bf1a75a0/jupyter-ui-poll-0.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "42794791f7113efa72ce52d535da22a0", "sha256": "1c0a22149ef8893706abce3d8d43e5cbd9a9590573649f6ad13b8555f3f98925"}, "downloads": -1, "filename": "jupyter_ui_poll-0.1.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "42794791f7113efa72ce52d535da22a0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">= 3.5", "size": 6591, "upload_time": "2020-01-05T06:40:33", "upload_time_iso_8601": "2020-01-05T06:40:33.523490Z", "url": "https://files.pythonhosted.org/packages/fc/4d/f7cb8ea5bad31fa68dfb689c9fa51e0ffa8ed08f4e07c3d3acac005f3506/jupyter_ui_poll-0.1.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f52345bc11e43ad0e9a45182c1268c43", "sha256": "191cddaf82ec5b8e466528f0c654fbc178ddeb58d396f0dd826a5801a5f0f16b"}, "downloads": -1, "filename": "jupyter-ui-poll-0.1.2.tar.gz", "has_sig": false, "md5_digest": "f52345bc11e43ad0e9a45182c1268c43", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 5566, "upload_time": "2020-01-05T06:40:34", "upload_time_iso_8601": "2020-01-05T06:40:34.885630Z", "url": "https://files.pythonhosted.org/packages/50/33/8a9f0e3da0dcba9b737039cf3808ebdeee4770e6e0c80ee41352bf1a75a0/jupyter-ui-poll-0.1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:07 2020"}