{"info": {"author": "Tidues Wei", "author_email": "tidues@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# What is Generalized Map Function (generalmap)\nThis is a generalized map function in python, which can lift basic function over various data structures and user defined objects. It implements the idea borrowed from functional programming language, that is to define a simple function first to tackle a small piece of problem, then reuse this function to apply to complicated data structures (sometimes called function lifting).\n\nAn simple example, given `lst=[1, 2, 3]` and function `f = lambda x: x+1`, this functin only focuses on solving the problem for one element in the list, but `map(f, lst)` will apply `f` to a list, which is a more complicated structure. In a nutshell, the map function let you focus on the atom part or essential part of the problem, then reuse the function in a very smart and cheap way.\n\nHowever, the default map function provided by python is very restrictive:\n* it can only apply to iteratable\n* it can cross only **one level** of the structure\n* it is not easy to apply to user defined objects\n\nand these are what generalmap package can do.\n\n# Basic Usage\nSome examples below like applying function to nonhomogeneous data structure are **not good coding styles**, they are simply used to demonstrate what this pacakge can do.\n\n## Lift function automatically\nThis is the default behavior, the gMap function will cross all predefined structures then apply `f` to the **basic types** like `int, float, string` (defaultly) or `int, float` (if set `intoStr=True`). One caveat is that `f` will always apply to the same level of structure.\n\nAn one level example:\n```python\n# define different structures\nsList = [1, 2, 3]\nsTuple = (1, 2, 3)\nsDict = {1: 2, 2: 3, 3: 4}\n\n# create function\nfoo = lambda x: x+1\n\n# create default gMap object\nmp = GMap()\n\n# apply f and print the results\nprint(mp.gMap(foo, sList))\nprint(mp.gMap(foo, sTuple))\nprint(mp.gMap(foo, sDict))\n```\nwith output as:\n```python\n[2, 3, 4]\n(2, 3, 4)\n{1: 3, 2: 4, 3: 5}\n```\n\nExample for two level mixed nonhomogeneous structure:\n```python\nsMixed = [(1, 2), [3, 4, 5], {6: 6, 7: 7}, range(3), slice(None, 10, 2)]\n\ndef foo x:\n    return x+1\n\nmp = GMap()\n\nprint(mp.gMap(foo, sMixed))\n```\nwith output as:\n```python\n[(2, 3), [4, 5, 6], {6: 7, 7: 8}, range(1, 4), slice(1, 11, 2)]\n```\nnotice different structures have their own unique lifting behaviors predefined.\n\n\nIn defualt, the gMap will not crossing string to apply function on each character, but this can be changed:\n```python\nsStr1 = '123'\n\nfoo = lambda x: str(int(x)+1)\n\nmp = GMap(intoStr=True)  # change default behavior\n\nprint(mp.gMap(foo, sStr1))\n```\nwith output:\n```python\n234\n```\n\n## Lift function by specifying depth\nWith depth specified, gMap will apply `f` to the desinged level without caring whether the type is basic or not. Depth 1 as one level structure (behavior of map function in python).\n\nA example:\n```python\nsMixed = [[(1, 2, 4), (4, 5)], [(6, 7, 8), '91011']]\n\nfoo = lambda x: x[0]\n\nmp = GMap(recDepth=2)  #  specify depth\n\nprint(mp.gMap(foo, sMixed))\n```\nwith output:\n```python\n[[1, 4], [6, '9']]\n```\nThe `sMixed` has a three-level strucure, but we force gMap only apply to the second level, so the function will take tuples and string as input. Notice we don't need to specify the `intoStr` here, for we don't lift function into the string structure.\n\n## Current supported strucutres\nThe basic (bottom) types including:\n\n`int, float, string`\n\nthe structure types including:\n\n`list, tuple, map, range, slice`\n\nif with `intoStr` set as `True`, then `string` is a structure type instead of basic.\n\n# Advanced Usage: Apply to User Defined Objects\n**This section is not necessary if the basic usage is enough for you!!**\n\nThere are two more things user can achieve with this package:\n1. Register new basic types.\n1. Register new structure types \n\n## Register new basic types\n\nThis can be accomplished by the method `mp.regBasicType(cls)` where `cls` is the class. For instance, suppose there is a new data type `double` defined, and we want it to be a bottom type, so that when we apply gMap automatically, it'll stop and apply `f` on the data of this type. \n\nNotice, if register a new basic type that is already in the structure types, it will be **removed from** the structure type.\n\n## Register new structure types\n\nThe method `mp.regStructType(cls, clsRule)` can register a new structure type, where `cls` is a class and `clsRule` is a rule description function. Same as before, registering an existing basic type to structure type will remove it from the basic type list. \n\nWith new structure type defined, it can be mixed with other structure types to build complicated data structure. And gMap can be used on these objects the way same as before.\n\nBelow is a new data type called MSet (multiset).\n```python\n# a self defined container (multiset)\nclass MSet:\n    def __init__(self, lst):\n        self.elems = lst\n\n    def __repr__(self):\n        return('MSet' + str(self.elems) + '')\n\n    def __getitem__(self, idx):\n        if type(idx) is int:\n            return self.elems[idx]\n        else:\n            return MSet(self.elems[idx])\n\n    def toList(self):\n        return self.elems\n```\n\nthen we need to define a map rule function for this class, all the rules will be explained in the next section.\n\n```python\n# define the function that describe the map rule\n# each term will be explained in the next section\ndef msetMapRule(mset):\n    isBottom = False\n    const = MSet\n    paramList = mset.toList()\n    paramMapIdx = range(len(paramList))\n    ifExpand = False\n    projFunc = lambda x: x\n    liftFunc = lambda x, res: res\n    return (isBottom, const, paramList, paramMapIdx, ifExpand, projFunc, liftFunc)\n```\n\nwith both class and rules are defined, we can apply gMap as same as before:\n\n```python\nmp = gMap()  # create gMap object\nmp.regStructType(MSet, msetMapRule) # register new structure type with rule\n\n# define functions and data\n# a two level MSet\nmset0 = MSet([1,2])\nmset1 = MSet([3,4])\nmset = MSet([mset0, mset1])\n\n# a tuple of MSets\nmtuple = (MSet([1,2]), MSet([3,4]))\n\n# function to apply\nfoo = lambda x: x+1\n\n# apply and show results\nprint(mp.gMap(foo, mset))\nprint(mp.gMap(foo, mtuple))\n```\nthe output is\n```python\nMSet[MSet[2, 3], MSet[4, 5]]\n(MSet[2, 3], MSet[4, 5])\n```\n\n## The map rule function\nNow suppose we are defining a map rule function `mcMapRule` for the class `MyCls`, then `mcMapRule(myObj)` is a function accepting objects of `MyCls` and ouput a tuple of rules. Each term in the rules are defined as:\n\n1. `isBottom`: a function from the input object `myObj` to bool, to sift extra bottom cases that is input dependent, such as length 1 string is a bottom case for string structure. In most cases, `isBottom = False`.\n\n1. `const`: a construct function that given a list of parameters can construct an object of `MyCls`, not necessary to be the constructor of the class.\n\n1. `paramList`: the list of parameters that used as input for the construct function `const` to produce the input object `myObj`.\n\n1. `paramMapIdx`: the list of indexes of elements in `paramList` that needs to be apply by `f`. In most cases, all parameters needs to be applied by `f`, then `paramMapIdx = range(len(paramList))`.\n\n1. `ifExpand`: means when we apply `const` onto the `paramList`, do we need to expand the list or not. If `const(a,b,c)`, then `ifExpand=True`, if `const([a, b, c])`, then `ifExpand=False`.\n\n1. `projFunc`: define a function that transform the input `myObj` to the next level. **In most cases, there is nothing to transform, so `projFunc = lambda x: x`**. In the dictionary case, we only map `f` on the value instead of the key, so we need to extract the second value to pass to `f`, hence `projFunc = lambda x: x[1]` (in my implementation, the parameter list for dictionary is a list of length 2 tuples, so `x[1]` is extracting the value).\n\n1. `liftFunc`: the reverse process of `projFunc`. After applying `f` on the transformed value we get `res`, then how to merge `res` with current input object `myObj`. **In most cases, there is nothing to merge, so `liftFunc = lambda x, res: res`**. In the dictionary case, we need to combine with key into a tuple, so `liftFunc = lambda x, res: (x[0], res)`.\n\nAn rule of thumb is, if we apply `f` to all the parameters of the construct function, like `list, tuple` or the example `MSet` above, then we always set\n```python\nparaMapIdx = range(len(paramList))\nprojFunc = lambda x: x\nliftFunc = lambda x, res: res\n```\nAnd in most cases `isBottom = False`, so the only things to specify are the construct function, the construct list of parameters and whether or not expand the list when we apply construct function on the parameter list.\n\nAll the rules for the predefined structure types can be found in the source file, can be used as examples for designing rules.\n\n# How to Install\nUse pip\n```python\npip install generalmap\n```\n\n# Future Plan\nAdd more predefined basic and strcutre types.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tidues/GeneralizedMapFunction", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "generalmap", "package_url": "https://pypi.org/project/generalmap/", "platform": "", "project_url": "https://pypi.org/project/generalmap/", "project_urls": {"Homepage": "https://github.com/tidues/GeneralizedMapFunction"}, "release_url": "https://pypi.org/project/generalmap/1.0.2/", "requires_dist": null, "requires_python": "", "summary": "A generalized map function for lift function over structures", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>What is Generalized Map Function (generalmap)</h1>\n<p>This is a generalized map function in python, which can lift basic function over various data structures and user defined objects. It implements the idea borrowed from functional programming language, that is to define a simple function first to tackle a small piece of problem, then reuse this function to apply to complicated data structures (sometimes called function lifting).</p>\n<p>An simple example, given <code>lst=[1, 2, 3]</code> and function <code>f = lambda x: x+1</code>, this functin only focuses on solving the problem for one element in the list, but <code>map(f, lst)</code> will apply <code>f</code> to a list, which is a more complicated structure. In a nutshell, the map function let you focus on the atom part or essential part of the problem, then reuse the function in a very smart and cheap way.</p>\n<p>However, the default map function provided by python is very restrictive:</p>\n<ul>\n<li>it can only apply to iteratable</li>\n<li>it can cross only <strong>one level</strong> of the structure</li>\n<li>it is not easy to apply to user defined objects</li>\n</ul>\n<p>and these are what generalmap package can do.</p>\n<h1>Basic Usage</h1>\n<p>Some examples below like applying function to nonhomogeneous data structure are <strong>not good coding styles</strong>, they are simply used to demonstrate what this pacakge can do.</p>\n<h2>Lift function automatically</h2>\n<p>This is the default behavior, the gMap function will cross all predefined structures then apply <code>f</code> to the <strong>basic types</strong> like <code>int, float, string</code> (defaultly) or <code>int, float</code> (if set <code>intoStr=True</code>). One caveat is that <code>f</code> will always apply to the same level of structure.</p>\n<p>An one level example:</p>\n<pre><span class=\"c1\"># define different structures</span>\n<span class=\"n\">sList</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"n\">sTuple</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">sDict</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">}</span>\n\n<span class=\"c1\"># create function</span>\n<span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n\n<span class=\"c1\"># create default gMap object</span>\n<span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">GMap</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># apply f and print the results</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">gMap</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">sList</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">gMap</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">sTuple</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">gMap</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">sDict</span><span class=\"p\">))</span>\n</pre>\n<p>with output as:</p>\n<pre><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]</span>\n<span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">}</span>\n</pre>\n<p>Example for two level mixed nonhomogeneous structure:</p>\n<pre><span class=\"n\">sMixed</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">],</span> <span class=\"p\">{</span><span class=\"mi\">6</span><span class=\"p\">:</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">:</span> <span class=\"mi\">7</span><span class=\"p\">},</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">),</span> <span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)]</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">foo</span> <span class=\"n\">x</span><span class=\"p\">:</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n\n<span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">GMap</span><span class=\"p\">()</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">gMap</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">sMixed</span><span class=\"p\">))</span>\n</pre>\n<p>with output as:</p>\n<pre><span class=\"p\">[(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">),</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">],</span> <span class=\"p\">{</span><span class=\"mi\">6</span><span class=\"p\">:</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">:</span> <span class=\"mi\">8</span><span class=\"p\">},</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">),</span> <span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)]</span>\n</pre>\n<p>notice different structures have their own unique lifting behaviors predefined.</p>\n<p>In defualt, the gMap will not crossing string to apply function on each character, but this can be changed:</p>\n<pre><span class=\"n\">sStr1</span> <span class=\"o\">=</span> <span class=\"s1\">'123'</span>\n\n<span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">GMap</span><span class=\"p\">(</span><span class=\"n\">intoStr</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># change default behavior</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">gMap</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">sStr1</span><span class=\"p\">))</span>\n</pre>\n<p>with output:</p>\n<pre><span class=\"mi\">234</span>\n</pre>\n<h2>Lift function by specifying depth</h2>\n<p>With depth specified, gMap will apply <code>f</code> to the desinged level without caring whether the type is basic or not. Depth 1 as one level structure (behavior of map function in python).</p>\n<p>A example:</p>\n<pre><span class=\"n\">sMixed</span> <span class=\"o\">=</span> <span class=\"p\">[[(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)],</span> <span class=\"p\">[(</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">),</span> <span class=\"s1\">'91011'</span><span class=\"p\">]]</span>\n\n<span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n\n<span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">GMap</span><span class=\"p\">(</span><span class=\"n\">recDepth</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>  <span class=\"c1\">#  specify depth</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">gMap</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">sMixed</span><span class=\"p\">))</span>\n</pre>\n<p>with output:</p>\n<pre><span class=\"p\">[[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"s1\">'9'</span><span class=\"p\">]]</span>\n</pre>\n<p>The <code>sMixed</code> has a three-level strucure, but we force gMap only apply to the second level, so the function will take tuples and string as input. Notice we don't need to specify the <code>intoStr</code> here, for we don't lift function into the string structure.</p>\n<h2>Current supported strucutres</h2>\n<p>The basic (bottom) types including:</p>\n<p><code>int, float, string</code></p>\n<p>the structure types including:</p>\n<p><code>list, tuple, map, range, slice</code></p>\n<p>if with <code>intoStr</code> set as <code>True</code>, then <code>string</code> is a structure type instead of basic.</p>\n<h1>Advanced Usage: Apply to User Defined Objects</h1>\n<p><strong>This section is not necessary if the basic usage is enough for you!!</strong></p>\n<p>There are two more things user can achieve with this package:</p>\n<ol>\n<li>Register new basic types.</li>\n<li>Register new structure types</li>\n</ol>\n<h2>Register new basic types</h2>\n<p>This can be accomplished by the method <code>mp.regBasicType(cls)</code> where <code>cls</code> is the class. For instance, suppose there is a new data type <code>double</code> defined, and we want it to be a bottom type, so that when we apply gMap automatically, it'll stop and apply <code>f</code> on the data of this type.</p>\n<p>Notice, if register a new basic type that is already in the structure types, it will be <strong>removed from</strong> the structure type.</p>\n<h2>Register new structure types</h2>\n<p>The method <code>mp.regStructType(cls, clsRule)</code> can register a new structure type, where <code>cls</code> is a class and <code>clsRule</code> is a rule description function. Same as before, registering an existing basic type to structure type will remove it from the basic type list.</p>\n<p>With new structure type defined, it can be mixed with other structure types to build complicated data structure. And gMap can be used on these objects the way same as before.</p>\n<p>Below is a new data type called MSet (multiset).</p>\n<pre><span class=\"c1\"># a self defined container (multiset)</span>\n<span class=\"k\">class</span> <span class=\"nc\">MSet</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lst</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">elems</span> <span class=\"o\">=</span> <span class=\"n\">lst</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span><span class=\"p\">(</span><span class=\"s1\">'MSet'</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">elems</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s1\">''</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">idx</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">elems</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">MSet</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">elems</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">])</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">toList</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">elems</span>\n</pre>\n<p>then we need to define a map rule function for this class, all the rules will be explained in the next section.</p>\n<pre><span class=\"c1\"># define the function that describe the map rule</span>\n<span class=\"c1\"># each term will be explained in the next section</span>\n<span class=\"k\">def</span> <span class=\"nf\">msetMapRule</span><span class=\"p\">(</span><span class=\"n\">mset</span><span class=\"p\">):</span>\n    <span class=\"n\">isBottom</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n    <span class=\"n\">const</span> <span class=\"o\">=</span> <span class=\"n\">MSet</span>\n    <span class=\"n\">paramList</span> <span class=\"o\">=</span> <span class=\"n\">mset</span><span class=\"o\">.</span><span class=\"n\">toList</span><span class=\"p\">()</span>\n    <span class=\"n\">paramMapIdx</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">paramList</span><span class=\"p\">))</span>\n    <span class=\"n\">ifExpand</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n    <span class=\"n\">projFunc</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span>\n    <span class=\"n\">liftFunc</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">res</span><span class=\"p\">:</span> <span class=\"n\">res</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">isBottom</span><span class=\"p\">,</span> <span class=\"n\">const</span><span class=\"p\">,</span> <span class=\"n\">paramList</span><span class=\"p\">,</span> <span class=\"n\">paramMapIdx</span><span class=\"p\">,</span> <span class=\"n\">ifExpand</span><span class=\"p\">,</span> <span class=\"n\">projFunc</span><span class=\"p\">,</span> <span class=\"n\">liftFunc</span><span class=\"p\">)</span>\n</pre>\n<p>with both class and rules are defined, we can apply gMap as same as before:</p>\n<pre><span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">gMap</span><span class=\"p\">()</span>  <span class=\"c1\"># create gMap object</span>\n<span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">regStructType</span><span class=\"p\">(</span><span class=\"n\">MSet</span><span class=\"p\">,</span> <span class=\"n\">msetMapRule</span><span class=\"p\">)</span> <span class=\"c1\"># register new structure type with rule</span>\n\n<span class=\"c1\"># define functions and data</span>\n<span class=\"c1\"># a two level MSet</span>\n<span class=\"n\">mset0</span> <span class=\"o\">=</span> <span class=\"n\">MSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">])</span>\n<span class=\"n\">mset1</span> <span class=\"o\">=</span> <span class=\"n\">MSet</span><span class=\"p\">([</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">])</span>\n<span class=\"n\">mset</span> <span class=\"o\">=</span> <span class=\"n\">MSet</span><span class=\"p\">([</span><span class=\"n\">mset0</span><span class=\"p\">,</span> <span class=\"n\">mset1</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># a tuple of MSets</span>\n<span class=\"n\">mtuple</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">MSet</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">]),</span> <span class=\"n\">MSet</span><span class=\"p\">([</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">]))</span>\n\n<span class=\"c1\"># function to apply</span>\n<span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n\n<span class=\"c1\"># apply and show results</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">gMap</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">mset</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">gMap</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">mtuple</span><span class=\"p\">))</span>\n</pre>\n<p>the output is</p>\n<pre><span class=\"n\">MSet</span><span class=\"p\">[</span><span class=\"n\">MSet</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">],</span> <span class=\"n\">MSet</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">]]</span>\n<span class=\"p\">(</span><span class=\"n\">MSet</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">],</span> <span class=\"n\">MSet</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n</pre>\n<h2>The map rule function</h2>\n<p>Now suppose we are defining a map rule function <code>mcMapRule</code> for the class <code>MyCls</code>, then <code>mcMapRule(myObj)</code> is a function accepting objects of <code>MyCls</code> and ouput a tuple of rules. Each term in the rules are defined as:</p>\n<ol>\n<li>\n<p><code>isBottom</code>: a function from the input object <code>myObj</code> to bool, to sift extra bottom cases that is input dependent, such as length 1 string is a bottom case for string structure. In most cases, <code>isBottom = False</code>.</p>\n</li>\n<li>\n<p><code>const</code>: a construct function that given a list of parameters can construct an object of <code>MyCls</code>, not necessary to be the constructor of the class.</p>\n</li>\n<li>\n<p><code>paramList</code>: the list of parameters that used as input for the construct function <code>const</code> to produce the input object <code>myObj</code>.</p>\n</li>\n<li>\n<p><code>paramMapIdx</code>: the list of indexes of elements in <code>paramList</code> that needs to be apply by <code>f</code>. In most cases, all parameters needs to be applied by <code>f</code>, then <code>paramMapIdx = range(len(paramList))</code>.</p>\n</li>\n<li>\n<p><code>ifExpand</code>: means when we apply <code>const</code> onto the <code>paramList</code>, do we need to expand the list or not. If <code>const(a,b,c)</code>, then <code>ifExpand=True</code>, if <code>const([a, b, c])</code>, then <code>ifExpand=False</code>.</p>\n</li>\n<li>\n<p><code>projFunc</code>: define a function that transform the input <code>myObj</code> to the next level. <strong>In most cases, there is nothing to transform, so <code>projFunc = lambda x: x</code></strong>. In the dictionary case, we only map <code>f</code> on the value instead of the key, so we need to extract the second value to pass to <code>f</code>, hence <code>projFunc = lambda x: x[1]</code> (in my implementation, the parameter list for dictionary is a list of length 2 tuples, so <code>x[1]</code> is extracting the value).</p>\n</li>\n<li>\n<p><code>liftFunc</code>: the reverse process of <code>projFunc</code>. After applying <code>f</code> on the transformed value we get <code>res</code>, then how to merge <code>res</code> with current input object <code>myObj</code>. <strong>In most cases, there is nothing to merge, so <code>liftFunc = lambda x, res: res</code></strong>. In the dictionary case, we need to combine with key into a tuple, so <code>liftFunc = lambda x, res: (x[0], res)</code>.</p>\n</li>\n</ol>\n<p>An rule of thumb is, if we apply <code>f</code> to all the parameters of the construct function, like <code>list, tuple</code> or the example <code>MSet</code> above, then we always set</p>\n<pre><span class=\"n\">paraMapIdx</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">paramList</span><span class=\"p\">))</span>\n<span class=\"n\">projFunc</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span>\n<span class=\"n\">liftFunc</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">res</span><span class=\"p\">:</span> <span class=\"n\">res</span>\n</pre>\n<p>And in most cases <code>isBottom = False</code>, so the only things to specify are the construct function, the construct list of parameters and whether or not expand the list when we apply construct function on the parameter list.</p>\n<p>All the rules for the predefined structure types can be found in the source file, can be used as examples for designing rules.</p>\n<h1>How to Install</h1>\n<p>Use pip</p>\n<pre><span class=\"n\">pip</span> <span class=\"n\">install</span> <span class=\"n\">generalmap</span>\n</pre>\n<h1>Future Plan</h1>\n<p>Add more predefined basic and strcutre types.</p>\n\n          </div>"}, "last_serial": 4078441, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "dbe05f0da3a14525b2ac6cd3eec51712", "sha256": "ce16c27d92dddc08ee2c7e11db68577c005edc4e3d0884903d9c11c5266be816"}, "downloads": -1, "filename": "generalmap-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "dbe05f0da3a14525b2ac6cd3eec51712", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 3723, "upload_time": "2018-07-18T04:02:03", "upload_time_iso_8601": "2018-07-18T04:02:03.976508Z", "url": "https://files.pythonhosted.org/packages/9d/62/0a8c1a25404ece5ae8e7e0463e86cd466655f5e551f7877fe3b26aa8a0de/generalmap-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c7a5486677f8ef09fe4b5c4710abd155", "sha256": "07ca2385316bca766d7fa01f20e73d27350db5ab2ffa4720ae5eb723b9655926"}, "downloads": -1, "filename": "generalmap-1.0.0.tar.gz", "has_sig": false, "md5_digest": "c7a5486677f8ef09fe4b5c4710abd155", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3208, "upload_time": "2018-07-18T04:02:05", "upload_time_iso_8601": "2018-07-18T04:02:05.188675Z", "url": "https://files.pythonhosted.org/packages/4b/f9/ce33712f916a46fd6ca6b049f5d161031c250a14d171582c36d88c9b8948/generalmap-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "0ade3d57f0193f839b361597a41a4027", "sha256": "52e110bdfbfdaf8106b8ad6213340403e34e7b01aeaacdaf29f543fe5cba99e4"}, "downloads": -1, "filename": "generalmap-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "0ade3d57f0193f839b361597a41a4027", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 3727, "upload_time": "2018-07-18T04:27:43", "upload_time_iso_8601": "2018-07-18T04:27:43.917665Z", "url": "https://files.pythonhosted.org/packages/8f/be/6c3a247c4722f2d1249e540dd2e20c8ecf92ac8bd5dad7f9ad764b143b84/generalmap-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b8785e2b5622cf1660bf0fc384c21f51", "sha256": "b43a0ad13be991f54060fc7e816c1b82d4fb80b78fad4b21c9b014ef860a73e4"}, "downloads": -1, "filename": "generalmap-1.0.1.tar.gz", "has_sig": false, "md5_digest": "b8785e2b5622cf1660bf0fc384c21f51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3215, "upload_time": "2018-07-18T04:27:45", "upload_time_iso_8601": "2018-07-18T04:27:45.761903Z", "url": "https://files.pythonhosted.org/packages/1e/63/0ac1b16f0c9eef33b5d8ff53309fa61f42cd59b94571b8bf76e8a27278eb/generalmap-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "2a90f61cf6458064d103c503a1c074d9", "sha256": "9dd976b065a7439995e08aa690691fe09da92acc9f28f7207168eba8ac6b0efd"}, "downloads": -1, "filename": "generalmap-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "2a90f61cf6458064d103c503a1c074d9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7062, "upload_time": "2018-07-18T15:06:12", "upload_time_iso_8601": "2018-07-18T15:06:12.662074Z", "url": "https://files.pythonhosted.org/packages/d9/97/0a2836944556142d26fb1143face8245704350e0736cb818ca4431ac3cd3/generalmap-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2c6000bca84aefabe0df5a93c588a72e", "sha256": "ea2f01510ec8f377afd501b29902f7541c2c0f3ab6267e36850c13823c875257"}, "downloads": -1, "filename": "generalmap-1.0.2.tar.gz", "has_sig": false, "md5_digest": "2c6000bca84aefabe0df5a93c588a72e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7058, "upload_time": "2018-07-18T15:06:13", "upload_time_iso_8601": "2018-07-18T15:06:13.681311Z", "url": "https://files.pythonhosted.org/packages/df/d7/02a0eca45bccf0fc6152b8e214e86dbfec4ccb8817edbe49872d3c6ee9c2/generalmap-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2a90f61cf6458064d103c503a1c074d9", "sha256": "9dd976b065a7439995e08aa690691fe09da92acc9f28f7207168eba8ac6b0efd"}, "downloads": -1, "filename": "generalmap-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "2a90f61cf6458064d103c503a1c074d9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7062, "upload_time": "2018-07-18T15:06:12", "upload_time_iso_8601": "2018-07-18T15:06:12.662074Z", "url": "https://files.pythonhosted.org/packages/d9/97/0a2836944556142d26fb1143face8245704350e0736cb818ca4431ac3cd3/generalmap-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2c6000bca84aefabe0df5a93c588a72e", "sha256": "ea2f01510ec8f377afd501b29902f7541c2c0f3ab6267e36850c13823c875257"}, "downloads": -1, "filename": "generalmap-1.0.2.tar.gz", "has_sig": false, "md5_digest": "2c6000bca84aefabe0df5a93c588a72e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7058, "upload_time": "2018-07-18T15:06:13", "upload_time_iso_8601": "2018-07-18T15:06:13.681311Z", "url": "https://files.pythonhosted.org/packages/df/d7/02a0eca45bccf0fc6152b8e214e86dbfec4ccb8817edbe49872d3c6ee9c2/generalmap-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:58:26 2020"}