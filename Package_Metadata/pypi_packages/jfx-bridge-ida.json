{"info": {"author": "justfoxing", "author_email": "justfoxingprojects@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python"], "description": "JFX Bridge for IDA (IDABridge)\n=====================\nIDA's a great reverse engineering tool, and I like scripting my RE as much as possible.\n\nLike [Ghidra Bridge](https://github.com/justfoxing/ghidra_bridge/), IDABridge is a Python RPC bridge that aims to break you out of the IDA Python environment, so you can more easily integrate with tools like IPython and Jupyter, while being as transparent as possible so you don't have to rewrite all of your scripts.\n\nHow to use for IDA\n======================\n\n## Install the IDABridge package and server scripts\n1. Install the jfx_bridge_ida package (packaged at https://pypi.org/project/jfx-bridge-ida/):\n```\npip install jfx_bridge_ida\n```\n\n2. Install the server scripts to a directory you'll load in IDA.\n```\npython -m jfx_bridge_ida.install_server ~/.ida_scripts\n```\n\n3. If you're using IDA with a different python environment (e.g., using python2), install the jfx-bridge package into that python environment. That'll look something like the following:\n```\npython2 -m pip install jfx-bridge\n```\n\n## Start Server\n### IDA Context\n\n1. Open File->Script file... <Alt-F7>\n2. Navigate to where you installed the server scripts\n3. Run jfx_bridge_ida_server.py\n\n\n## Setup Client\nFrom the client python environment:\n```python\nimport jfx_bridge_ida\n\nb = jfx_bridge_ida.IDABridge()\n\nidaapi = b.get_idaapi()\nidc = b.get_idc()\nidautils = b.get_idautils()\n\nprint(idc.ScreenEA())\n\n# or use the sark module for easier scripting! Remember to install sark in the IDA python environment\nsark = b.get_sark()\nprint(sark.Line())\n```\n\nSecurity warning\n=====================\nBe aware that when running, an IDABridge server effectively provides code execution as a service. If an attacker is able to talk to the port IDABridge is running on, they can trivially gain execution with the privileges IDA is run with. \n\nAlso be aware that the protocol used for sending and receiving IDABridge messages is unencrypted and unverified - a person-in-the-middle attack would allow complete control of the commands and responses, again providing trivial code execution on the server (and with a little more work, on the client). \n\nBy default, the IDABridge server only listens on localhost to slightly reduce the attack surface. Only listen on external network addresses if you're confident you're on a network where it is safe to do so. Additionally, it is still possible for attackers to send messages to localhost (e.g., via malicious javascript in the browser, or by exploiting a different process and attacking IDABridge to elevate privileges). You can mitigate this risk by running IDABridge from a IDA server with reduced permissions (a non-admin user, or inside a container), by only running it when needed, or by running on non-network connected systems.\n\nRemote eval\n=====================\nIDABridge is designed to be transparent, to allow easy porting of non-bridged scripts without too many changes. However, if you're happy to make changes, and you run into slowdowns caused by running lots of remote queries (e.g., something like `for f in sark.functions(): doSomething()` can be quite slow with a large number of functions as each function will result in a message across the bridge), you can make use of the bridge.remote_eval() function to ask for the result to be evaluated on the bridge server all at once, which will require only a single message roundtrip.\n\nThe following example demonstrates getting a list of all the names of all the functions in a binary:\n```python\nimport jfx_bridge_ida \nb = jfx_bridge_ida.IDABridge(namespace=globals())\nname_list = b.bridge.remote_eval(\"[ f.name for f in sark.functions()]\")\n```\n\nIf your evaluation is going to take some time, you might need to use the timeout_override argument to increase how long the bridge will wait before deciding things have gone wrong.\n\nIf you need to supply an argument for the remote evaluation, you can provide arbitrary keyword arguments to the remote_eval function which will be passed into the evaluation context as local variables. The following argument passes in a function:\n```python\nimport jfx_bridge_ida \nb = jfx_bridge_ida.IDABridge(namespace=globals())\nfunc = b.get_sark().Function()\ncalls_list = b.bridge.remote_eval(\"[ sark.Function(x.to).name for x in f.xrefs_from ]\", f=func)\n```\nAs a simplification, note also that the evaluation context has the same globals loaded into the \\_\\_main\\_\\_ of the script that started the server - in the case of the IDABridge server, these include the idaapi, idautils and idc module, and sark if it was installed when the server was started.\n\nHow it works\n=====================\nThe actual bridge RPC code is implemented in [jfx-bridge](https://github.com/justfoxing/jfx_bridge/). Check it out there and file non-IDA specific issues related to the bridge there.\n\nTested\n=====================\n* IDA 6.9/Windows/Python 2.7.17->Python 3.7.2\n* IDA 7.2/Linux/2.7.17->Python 3.7.2\n\nContributors\n=====================\n* Thx @fmagin for better iPython support, and much more useful reprs!\n* Thanks also to @fmagin for remote_eval, allowing faster remote processing for batch queries!\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/justfoxing/jfx_bridge_ida", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "jfx-bridge-ida", "package_url": "https://pypi.org/project/jfx-bridge-ida/", "platform": "", "project_url": "https://pypi.org/project/jfx-bridge-ida/", "project_urls": {"Homepage": "https://github.com/justfoxing/jfx_bridge_ida"}, "release_url": "https://pypi.org/project/jfx-bridge-ida/0.0.1/", "requires_dist": ["jfx-bridge"], "requires_python": "", "summary": "RPC bridge from Python to IDA Python interpreter", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>JFX Bridge for IDA (IDABridge)</h1>\n<p>IDA's a great reverse engineering tool, and I like scripting my RE as much as possible.</p>\n<p>Like <a href=\"https://github.com/justfoxing/ghidra_bridge/\" rel=\"nofollow\">Ghidra Bridge</a>, IDABridge is a Python RPC bridge that aims to break you out of the IDA Python environment, so you can more easily integrate with tools like IPython and Jupyter, while being as transparent as possible so you don't have to rewrite all of your scripts.</p>\n<h1>How to use for IDA</h1>\n<h2>Install the IDABridge package and server scripts</h2>\n<ol>\n<li>Install the jfx_bridge_ida package (packaged at <a href=\"https://pypi.org/project/jfx-bridge-ida/\" rel=\"nofollow\">https://pypi.org/project/jfx-bridge-ida/</a>):</li>\n</ol>\n<pre><code>pip install jfx_bridge_ida\n</code></pre>\n<ol>\n<li>Install the server scripts to a directory you'll load in IDA.</li>\n</ol>\n<pre><code>python -m jfx_bridge_ida.install_server ~/.ida_scripts\n</code></pre>\n<ol>\n<li>If you're using IDA with a different python environment (e.g., using python2), install the jfx-bridge package into that python environment. That'll look something like the following:</li>\n</ol>\n<pre><code>python2 -m pip install jfx-bridge\n</code></pre>\n<h2>Start Server</h2>\n<h3>IDA Context</h3>\n<ol>\n<li>Open File-&gt;Script file... &lt;Alt-F7&gt;</li>\n<li>Navigate to where you installed the server scripts</li>\n<li>Run jfx_bridge_ida_server.py</li>\n</ol>\n<h2>Setup Client</h2>\n<p>From the client python environment:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">jfx_bridge_ida</span>\n\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">jfx_bridge_ida</span><span class=\"o\">.</span><span class=\"n\">IDABridge</span><span class=\"p\">()</span>\n\n<span class=\"n\">idaapi</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">get_idaapi</span><span class=\"p\">()</span>\n<span class=\"n\">idc</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">get_idc</span><span class=\"p\">()</span>\n<span class=\"n\">idautils</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">get_idautils</span><span class=\"p\">()</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">idc</span><span class=\"o\">.</span><span class=\"n\">ScreenEA</span><span class=\"p\">())</span>\n\n<span class=\"c1\"># or use the sark module for easier scripting! Remember to install sark in the IDA python environment</span>\n<span class=\"n\">sark</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">get_sark</span><span class=\"p\">()</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">sark</span><span class=\"o\">.</span><span class=\"n\">Line</span><span class=\"p\">())</span>\n</pre>\n<h1>Security warning</h1>\n<p>Be aware that when running, an IDABridge server effectively provides code execution as a service. If an attacker is able to talk to the port IDABridge is running on, they can trivially gain execution with the privileges IDA is run with.</p>\n<p>Also be aware that the protocol used for sending and receiving IDABridge messages is unencrypted and unverified - a person-in-the-middle attack would allow complete control of the commands and responses, again providing trivial code execution on the server (and with a little more work, on the client).</p>\n<p>By default, the IDABridge server only listens on localhost to slightly reduce the attack surface. Only listen on external network addresses if you're confident you're on a network where it is safe to do so. Additionally, it is still possible for attackers to send messages to localhost (e.g., via malicious javascript in the browser, or by exploiting a different process and attacking IDABridge to elevate privileges). You can mitigate this risk by running IDABridge from a IDA server with reduced permissions (a non-admin user, or inside a container), by only running it when needed, or by running on non-network connected systems.</p>\n<h1>Remote eval</h1>\n<p>IDABridge is designed to be transparent, to allow easy porting of non-bridged scripts without too many changes. However, if you're happy to make changes, and you run into slowdowns caused by running lots of remote queries (e.g., something like <code>for f in sark.functions(): doSomething()</code> can be quite slow with a large number of functions as each function will result in a message across the bridge), you can make use of the bridge.remote_eval() function to ask for the result to be evaluated on the bridge server all at once, which will require only a single message roundtrip.</p>\n<p>The following example demonstrates getting a list of all the names of all the functions in a binary:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">jfx_bridge_ida</span> \n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">jfx_bridge_ida</span><span class=\"o\">.</span><span class=\"n\">IDABridge</span><span class=\"p\">(</span><span class=\"n\">namespace</span><span class=\"o\">=</span><span class=\"nb\">globals</span><span class=\"p\">())</span>\n<span class=\"n\">name_list</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">bridge</span><span class=\"o\">.</span><span class=\"n\">remote_eval</span><span class=\"p\">(</span><span class=\"s2\">\"[ f.name for f in sark.functions()]\"</span><span class=\"p\">)</span>\n</pre>\n<p>If your evaluation is going to take some time, you might need to use the timeout_override argument to increase how long the bridge will wait before deciding things have gone wrong.</p>\n<p>If you need to supply an argument for the remote evaluation, you can provide arbitrary keyword arguments to the remote_eval function which will be passed into the evaluation context as local variables. The following argument passes in a function:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">jfx_bridge_ida</span> \n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">jfx_bridge_ida</span><span class=\"o\">.</span><span class=\"n\">IDABridge</span><span class=\"p\">(</span><span class=\"n\">namespace</span><span class=\"o\">=</span><span class=\"nb\">globals</span><span class=\"p\">())</span>\n<span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">get_sark</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">Function</span><span class=\"p\">()</span>\n<span class=\"n\">calls_list</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">bridge</span><span class=\"o\">.</span><span class=\"n\">remote_eval</span><span class=\"p\">(</span><span class=\"s2\">\"[ sark.Function(x.to).name for x in f.xrefs_from ]\"</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">=</span><span class=\"n\">func</span><span class=\"p\">)</span>\n</pre>\n<p>As a simplification, note also that the evaluation context has the same globals loaded into the __main__ of the script that started the server - in the case of the IDABridge server, these include the idaapi, idautils and idc module, and sark if it was installed when the server was started.</p>\n<h1>How it works</h1>\n<p>The actual bridge RPC code is implemented in <a href=\"https://github.com/justfoxing/jfx_bridge/\" rel=\"nofollow\">jfx-bridge</a>. Check it out there and file non-IDA specific issues related to the bridge there.</p>\n<h1>Tested</h1>\n<ul>\n<li>IDA 6.9/Windows/Python 2.7.17-&gt;Python 3.7.2</li>\n<li>IDA 7.2/Linux/2.7.17-&gt;Python 3.7.2</li>\n</ul>\n<h1>Contributors</h1>\n<ul>\n<li>Thx @fmagin for better iPython support, and much more useful reprs!</li>\n<li>Thanks also to @fmagin for remote_eval, allowing faster remote processing for batch queries!</li>\n</ul>\n\n          </div>"}, "last_serial": 6810121, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "c10ad25d833ea2418c96b6f07efb0e73", "sha256": "75a7936b33fef86550076fd21d627600fdf8e6bf93d923a546a7c6e42a980768"}, "downloads": -1, "filename": "jfx_bridge_ida-0.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "c10ad25d833ea2418c96b6f07efb0e73", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 9292, "upload_time": "2020-03-14T04:13:05", "upload_time_iso_8601": "2020-03-14T04:13:05.375015Z", "url": "https://files.pythonhosted.org/packages/eb/33/101d900e8090f5bfaa07498d7463aaa9941ae44ce01d3f327bf9fa9640b9/jfx_bridge_ida-0.0.1-py2.py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c10ad25d833ea2418c96b6f07efb0e73", "sha256": "75a7936b33fef86550076fd21d627600fdf8e6bf93d923a546a7c6e42a980768"}, "downloads": -1, "filename": "jfx_bridge_ida-0.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "c10ad25d833ea2418c96b6f07efb0e73", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 9292, "upload_time": "2020-03-14T04:13:05", "upload_time_iso_8601": "2020-03-14T04:13:05.375015Z", "url": "https://files.pythonhosted.org/packages/eb/33/101d900e8090f5bfaa07498d7463aaa9941ae44ce01d3f327bf9fa9640b9/jfx_bridge_ida-0.0.1-py2.py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 00:52:46 2020"}