{"info": {"author": "David Dale", "author_email": "dale.david@mail.ru", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# word-mover-grammar\nThis package implements a context-free grammar parser with rather flexible\n matching of terminals. The supported matching modes are:\n* standard exact matching (like e.g. in [NLTK](https://www.nltk.org/book/ch08.html)); \n* regex matching (like e.g. in [Lark](https://github.com/lark-parser/lark));\n* lemma matching (like e.g. in [Yandex Alice](https://yandex.ru/dev/dialogs/alice/doc/nlu-docpage/));\n* word embedding matching (no known Python implementation).\n\nThe mission of this package is to enable easy creation of custom\ngrammars for various NLU problems, such as sentence classification\nor extraction of semantic slots.\n\nIt is called \"word mover grammar\", because, just like word-mover-distance,\nit applies word embeddings to sentence templates, \nbut in a more structured way.\n\n#### Table of Contents\n1. [Installation](#installation)\n1. [Basic parsing](#basic-parsing)\n1. [Ambiguous phrases](#ambiguous-phrases)\n1. [Inexact matcing](#inexact-matching)\n1. [Forms and slots](#forms-and-slots)\n1. [Future plans](#future-plans)\n\n## Installation\n\n`pip install word-mover-grammar`\n\n## Basic parsing\nWMG production rules can be described in a text file with the following syntax:\n\n- Lowercase tokens represent terminals, and capitalized tokens - terminals. \nYou can also prepend non-terminals with `$` symbol\nand/or put terminals into single brackets. \n- Left- and right-hand sides of productions can be separated \nwith `:` or `->` tokens.\n- Different right-hand-sides of the same production can be separated \nwith `|` symbol or with newline followed by several whitespaces.\nIn the latter case, each RHS can be prepended with `-`, which makes\nthe format YAML-compatible.\n- One-line comments can start with `#` symbol.\n\nThe snippet below shows how to create a simple grammar and parser:\n```python\nimport word_mover_grammar as wmg\nrules = \"\"\"\nS : NP VP\nNP: N | A NP\nVP: V | VP NP | VP PP\nPP: P NP\nN: fruit | flies | bananas\nA: fruit\nV: like | flies | are\nP: like\n\"\"\"\ngrammar = wmg.text_to_grammar.load_granet(rules)\nparser = wmg.earley.EarleyParser(grammar, root_symbol='S')\n```\nThe main inference method is `parser.parse(tokens)`, where `tokens` \nis a list of strings. This method returns a `ParseResult` object, \nthat stores the parse trees.\n```python\nresult = parser.parse('bananas are fruit'.split())\nprint(result.success)\nfor tree in result.iter_trees():\n    wmg.earley.print_tree(tree, result.final_state)\n    print('=======')\n```\nThe output of the code above is given below. \nThe parser has correctly inferred that the sentence \"bananas are fruit\"\nconsists of the noun phrase \"bananas\" and the verb phrase \"are fruit\",\nwhich in turn consists of the verb \"are\" and the noun \"fruit\".\n```\nTrue\n|                     .                      |\n|                     S                      |\n|      NP      |             VP              |\n|      N       |      VP      |      NP      |\n|   bananas    |      V       |      N       |\n|              |     are      |    fruit     |\n|   bananas    |     are      |    fruit     |\n=======\n```\nIf the phrase cannot be parsed, `result.success` will be \n`False` - e.g. here:\n```python\nresult = parser.parse('bananas bananas bananas'.split())\nprint(result.success)  # False\n```\n\n## Ambiguous phrases\nSome phrases can be parsed in more that one way. In this case, \n`result.success` will still be `True`, but the number of trees will be\nmore than one. \n```python\nresult = parser.parse('fruit flies like bananas'.split())\nprint(result.success)\nfor tree in result.iter_trees():\n    wmg.earley.print_tree(tree, result.final_state)\n    print('=======')\n```\nThe phrase above can be understood in two ways: \n* that particular insects are fond of bananas;\n* that the style of flying of some fruit resembles that of bananas.\nThe parsing result has trees for both interpretations:\n```\n|                             .                             |\n|                             S                             |\n|      NP      |                     VP                     |\n|      N       |      VP      |             PP              |\n|    fruit     |      V       |      P       |      NP      |\n|              |    flies     |     like     |      N       |\n|              |              |              |   bananas    |\n|    fruit     |    flies     |     like     |   bananas    |\n=======\n|                             .                             |\n|                             S                             |\n|             NP              |             VP              |\n|      A       |      NP      |      VP      |      NP      |\n|    fruit     |      N       |      V       |      N       |\n|              |    flies     |     like     |   bananas    |\n|    fruit     |    flies     |     like     |   bananas    |\n=======\n```\n\n## Inexact matching\nBy default, WMG uses only exact matching of tokens.\nHowever, several more matching ways can be activated by special directives:\n* `%w2v`: words are considered equal, \nif the dot product of their embeddings is above the threshold \n(default one is `0.5`). If this mode is used, parser constructor\nrequires one more argument `w2v` - a callable that transforms a word\ninto a vector.\n* `%lemma`: words are considered equal, if at least some of their\nnormal forms coincide. If this mode is used, parser constructor\nrequires one more argument `lemmer` - a callable that transforms a word\ninto a list of normal forms.\n* `%regex`: a word is matched, if it can be parsed by the regular expression.\n* `%exact`: words are considered equal, only if they are the same word.\n\nIf a directive is inserted within a non-terminal, it is active\nuntil the end of this non-terminal. \nIf a directive is inserted outside of non-terminals, it is active until \nthe next directive outside of non-terminals, but can be temporarily \noverridden within non-terminals.\n\nThe code below shows an example of inexact matching \nfor a simple Russian grammar.\n```python\ngrammar = wmg.text_to_grammar.load_granet(\"\"\"\nroot:\n    \u0432\u043a\u043b\u044e\u0447\u0438 $What $Where\n$What:\n    %w2v\n    \u0441\u0432\u0435\u0442 | \u043a\u043e\u043d\u0434\u0438\u0446\u0438\u043e\u043d\u0435\u0440\n    %regex\n    .+[\u0430\u0435\u0438\u044e\u044f]\u0442[\u043e\u0435]\u0440\n$Where:\n    \u0432 $Room\n    \u043d\u0430 $Room\n$Room:\n    %lemma\n    \u0432\u0430\u043d\u043d\u0430 | \u043a\u0443\u0445\u043d\u044f | \u0441\u043f\u0430\u043b\u044c\u043d\u044f\n\"\"\")\n```\n\nAs a lemmer, we can use pymorphy2\n```python\nfrom pymorphy2 import MorphAnalyzer\n\nanalyzer = MorphAnalyzer()\n\ndef lemmer(text):\n    return [p.normal_form for p in analyzer.parse(text)]\n```\n\nFor embeddings, we can use a compressed FastText model\n```python\nimport compress_fasttext\n\nsmall_model = compress_fasttext.models.CompressedFastTextKeyedVectors.load(\n    'https://github.com/avidale/compress-fasttext/releases/download/v0.0.1/ft_freqprune_100K_20K_pq_100.bin'\n)\nsmall_model.init_sims()\n\ndef w2v(text):\n    return small_model.word_vec(text, use_norm=True)\n```\n\nThe parser combines all the objects from above:\n```python\nparser = wmg.earley.EarleyParser(grammar, w2v=w2v, w2v_threshold=0.5, lemmer=lemmer)\n```\nThe phrase below contains an OOV word `\u043f\u044b\u043b\u0435\u0441\u043e\u0441`, but its embedding is\n close to that of `\u0432\u0435\u043d\u0442\u0438\u043b\u044f\u0442\u043e\u0440`, so the match succeeds. \nAnother problem\nis that `\u0441\u043f\u0430\u043b\u044c\u043d\u0435` is not equal to `\u0441\u043f\u0430\u043b\u044c\u043d\u044f`, but their normal forms\ncoinside and therefore match is possible.\n```python\ntokens = '\u0432\u043a\u043b\u044e\u0447\u0438 \u043f\u044b\u043b\u0435\u0441\u043e\u0441 \u0432 \u0441\u043f\u0430\u043b\u044c\u043d\u0435'.split()\nresult = parser.parse(tokens)\nprint(result.success)\nfor tree in result.iter_trees():\n    wmg.earley.print_tree(tree, result.final_state, w=16)\n    print('=======')\n```\nThe output is following:\n```\nTrue\n|                               .                               |\n|                             root                              |\n|    \u0432\u043a\u043b\u044e\u0447\u0438     |     $What     |            $Where             |\n|               |  \u043a\u043e\u043d\u0434\u0438\u0446\u0438\u043e\u043d\u0435\u0440  |       \u0432       |     $Room     |\n|               |               |               |    \u0441\u043f\u0430\u043b\u044c\u043d\u044f    |\n|    \u0432\u043a\u043b\u044e\u0447\u0438     |    \u043f\u044b\u043b\u0435\u0441\u043e\u0441    |       \u0432       |    \u0441\u043f\u0430\u043b\u044c\u043d\u0435    |\n=======\n```\n\n## Forms and slots\nIn dialogue systems, phrases are often viewed as *forms* - containers of information.\nEach meaningful piece of information can be stored in a typed *slot*. \nYou can think of them as of \n[named groups](https://www.regular-expressions.info/refext.html)\nin regular expressions, or as extended \n[named entities](https://en.wikipedia.org/wiki/Named-entity_recognition).\n\nIn WMG, each slot is associated with some non-terminal symbol. \nThis association can be configured in the same file as the production rules.\n\n```python\nimport word_mover_grammar as wmg\ncfg = \"\"\"\nroot:\n    turn the $What $Where on\n    turn on the $What $Where\n$What: light | conditioner\n$Where: in the $Room\n$Room: bathroom | kitchen | bedroom | living room\nslots:\n    what:\n        source: $What                   \n    room:\n        source: $Room\n\"\"\"\ngrammar = wmg.text_to_grammar.load_granet(cfg)\nparser = wmg.earley.EarleyParser(grammar)\nresult = parser.parse('turn on the light in the living room'.split())\nprint(result.slots)\n```\nThe result will be a \n[yandex-compatible](https://yandex.ru/dev/dialogs/alice/doc/nlu-docpage/#data_to_skill) \nmap of slot names to the slots found in the phrase.\n```\n{'what': {'type': 'string', 'value': 'light', 'text': 'light', 'tokens': {'start': 3, 'end': 4}},\n 'room': {'type': 'string', 'value': 'living room', 'text': 'living room', 'tokens': {'start': 6, 'end': 8}}}\n```\nA few caveats:\n- currently, in ambiguous prhases the slots are taken just from the first parse tree.\nIf you want to extract slots from an arbitrary tree, \nyou can call `result.extract_slots(tree)`.\n- each slot is filled only once. If the non-terminal occurs several times in the phrase,\nthe corresponding slot will be filled with the first occurrence.\n\n\n## Future plans\nIn the future, we plan to enhance the library in the following ways:\n* Conversion to and from NLTK grammars\n* Support of quantifiers and brackets\n* Probabilistic parsing\n* Extraction of intents and slots from parse trees\n* Full compatibility with Yandex Alice syntax\n* You name it!", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/avidale/word-mover-grammar", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "word-mover-grammar", "package_url": "https://pypi.org/project/word-mover-grammar/", "platform": "", "project_url": "https://pypi.org/project/word-mover-grammar/", "project_urls": {"Homepage": "https://github.com/avidale/word-mover-grammar"}, "release_url": "https://pypi.org/project/word-mover-grammar/0.0.2/", "requires_dist": null, "requires_python": "", "summary": "A constituency grammar parser with support of morphology and word embeddings", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>word-mover-grammar</h1>\n<p>This package implements a context-free grammar parser with rather flexible\nmatching of terminals. The supported matching modes are:</p>\n<ul>\n<li>standard exact matching (like e.g. in <a href=\"https://www.nltk.org/book/ch08.html\" rel=\"nofollow\">NLTK</a>);</li>\n<li>regex matching (like e.g. in <a href=\"https://github.com/lark-parser/lark\" rel=\"nofollow\">Lark</a>);</li>\n<li>lemma matching (like e.g. in <a href=\"https://yandex.ru/dev/dialogs/alice/doc/nlu-docpage/\" rel=\"nofollow\">Yandex Alice</a>);</li>\n<li>word embedding matching (no known Python implementation).</li>\n</ul>\n<p>The mission of this package is to enable easy creation of custom\ngrammars for various NLU problems, such as sentence classification\nor extraction of semantic slots.</p>\n<p>It is called \"word mover grammar\", because, just like word-mover-distance,\nit applies word embeddings to sentence templates,\nbut in a more structured way.</p>\n<h4>Table of Contents</h4>\n<ol>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#basic-parsing\" rel=\"nofollow\">Basic parsing</a></li>\n<li><a href=\"#ambiguous-phrases\" rel=\"nofollow\">Ambiguous phrases</a></li>\n<li><a href=\"#inexact-matching\" rel=\"nofollow\">Inexact matcing</a></li>\n<li><a href=\"#forms-and-slots\" rel=\"nofollow\">Forms and slots</a></li>\n<li><a href=\"#future-plans\" rel=\"nofollow\">Future plans</a></li>\n</ol>\n<h2>Installation</h2>\n<p><code>pip install word-mover-grammar</code></p>\n<h2>Basic parsing</h2>\n<p>WMG production rules can be described in a text file with the following syntax:</p>\n<ul>\n<li>Lowercase tokens represent terminals, and capitalized tokens - terminals.\nYou can also prepend non-terminals with <code>$</code> symbol\nand/or put terminals into single brackets.</li>\n<li>Left- and right-hand sides of productions can be separated\nwith <code>:</code> or <code>-&gt;</code> tokens.</li>\n<li>Different right-hand-sides of the same production can be separated\nwith <code>|</code> symbol or with newline followed by several whitespaces.\nIn the latter case, each RHS can be prepended with <code>-</code>, which makes\nthe format YAML-compatible.</li>\n<li>One-line comments can start with <code>#</code> symbol.</li>\n</ul>\n<p>The snippet below shows how to create a simple grammar and parser:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">word_mover_grammar</span> <span class=\"k\">as</span> <span class=\"nn\">wmg</span>\n<span class=\"n\">rules</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">S : NP VP</span>\n<span class=\"s2\">NP: N | A NP</span>\n<span class=\"s2\">VP: V | VP NP | VP PP</span>\n<span class=\"s2\">PP: P NP</span>\n<span class=\"s2\">N: fruit | flies | bananas</span>\n<span class=\"s2\">A: fruit</span>\n<span class=\"s2\">V: like | flies | are</span>\n<span class=\"s2\">P: like</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"n\">grammar</span> <span class=\"o\">=</span> <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">text_to_grammar</span><span class=\"o\">.</span><span class=\"n\">load_granet</span><span class=\"p\">(</span><span class=\"n\">rules</span><span class=\"p\">)</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">earley</span><span class=\"o\">.</span><span class=\"n\">EarleyParser</span><span class=\"p\">(</span><span class=\"n\">grammar</span><span class=\"p\">,</span> <span class=\"n\">root_symbol</span><span class=\"o\">=</span><span class=\"s1\">'S'</span><span class=\"p\">)</span>\n</pre>\n<p>The main inference method is <code>parser.parse(tokens)</code>, where <code>tokens</code>\nis a list of strings. This method returns a <code>ParseResult</code> object,\nthat stores the parse trees.</p>\n<pre><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'bananas are fruit'</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">())</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">success</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">tree</span> <span class=\"ow\">in</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">iter_trees</span><span class=\"p\">():</span>\n    <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">earley</span><span class=\"o\">.</span><span class=\"n\">print_tree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">final_state</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'======='</span><span class=\"p\">)</span>\n</pre>\n<p>The output of the code above is given below.\nThe parser has correctly inferred that the sentence \"bananas are fruit\"\nconsists of the noun phrase \"bananas\" and the verb phrase \"are fruit\",\nwhich in turn consists of the verb \"are\" and the noun \"fruit\".</p>\n<pre><code>True\n|                     .                      |\n|                     S                      |\n|      NP      |             VP              |\n|      N       |      VP      |      NP      |\n|   bananas    |      V       |      N       |\n|              |     are      |    fruit     |\n|   bananas    |     are      |    fruit     |\n=======\n</code></pre>\n<p>If the phrase cannot be parsed, <code>result.success</code> will be\n<code>False</code> - e.g. here:</p>\n<pre><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'bananas bananas bananas'</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">())</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">success</span><span class=\"p\">)</span>  <span class=\"c1\"># False</span>\n</pre>\n<h2>Ambiguous phrases</h2>\n<p>Some phrases can be parsed in more that one way. In this case,\n<code>result.success</code> will still be <code>True</code>, but the number of trees will be\nmore than one.</p>\n<pre><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'fruit flies like bananas'</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">())</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">success</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">tree</span> <span class=\"ow\">in</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">iter_trees</span><span class=\"p\">():</span>\n    <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">earley</span><span class=\"o\">.</span><span class=\"n\">print_tree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">final_state</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'======='</span><span class=\"p\">)</span>\n</pre>\n<p>The phrase above can be understood in two ways:</p>\n<ul>\n<li>that particular insects are fond of bananas;</li>\n<li>that the style of flying of some fruit resembles that of bananas.\nThe parsing result has trees for both interpretations:</li>\n</ul>\n<pre><code>|                             .                             |\n|                             S                             |\n|      NP      |                     VP                     |\n|      N       |      VP      |             PP              |\n|    fruit     |      V       |      P       |      NP      |\n|              |    flies     |     like     |      N       |\n|              |              |              |   bananas    |\n|    fruit     |    flies     |     like     |   bananas    |\n=======\n|                             .                             |\n|                             S                             |\n|             NP              |             VP              |\n|      A       |      NP      |      VP      |      NP      |\n|    fruit     |      N       |      V       |      N       |\n|              |    flies     |     like     |   bananas    |\n|    fruit     |    flies     |     like     |   bananas    |\n=======\n</code></pre>\n<h2>Inexact matching</h2>\n<p>By default, WMG uses only exact matching of tokens.\nHowever, several more matching ways can be activated by special directives:</p>\n<ul>\n<li><code>%w2v</code>: words are considered equal,\nif the dot product of their embeddings is above the threshold\n(default one is <code>0.5</code>). If this mode is used, parser constructor\nrequires one more argument <code>w2v</code> - a callable that transforms a word\ninto a vector.</li>\n<li><code>%lemma</code>: words are considered equal, if at least some of their\nnormal forms coincide. If this mode is used, parser constructor\nrequires one more argument <code>lemmer</code> - a callable that transforms a word\ninto a list of normal forms.</li>\n<li><code>%regex</code>: a word is matched, if it can be parsed by the regular expression.</li>\n<li><code>%exact</code>: words are considered equal, only if they are the same word.</li>\n</ul>\n<p>If a directive is inserted within a non-terminal, it is active\nuntil the end of this non-terminal.\nIf a directive is inserted outside of non-terminals, it is active until\nthe next directive outside of non-terminals, but can be temporarily\noverridden within non-terminals.</p>\n<p>The code below shows an example of inexact matching\nfor a simple Russian grammar.</p>\n<pre><span class=\"n\">grammar</span> <span class=\"o\">=</span> <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">text_to_grammar</span><span class=\"o\">.</span><span class=\"n\">load_granet</span><span class=\"p\">(</span><span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">root:</span>\n<span class=\"s2\">    \u0432\u043a\u043b\u044e\u0447\u0438 $What $Where</span>\n<span class=\"s2\">$What:</span>\n<span class=\"s2\">    %w2v</span>\n<span class=\"s2\">    \u0441\u0432\u0435\u0442 | \u043a\u043e\u043d\u0434\u0438\u0446\u0438\u043e\u043d\u0435\u0440</span>\n<span class=\"s2\">    </span><span class=\"si\">%r</span><span class=\"s2\">egex</span>\n<span class=\"s2\">    .+[\u0430\u0435\u0438\u044e\u044f]\u0442[\u043e\u0435]\u0440</span>\n<span class=\"s2\">$Where:</span>\n<span class=\"s2\">    \u0432 $Room</span>\n<span class=\"s2\">    \u043d\u0430 $Room</span>\n<span class=\"s2\">$Room:</span>\n<span class=\"s2\">    </span><span class=\"si\">%le</span><span class=\"s2\">mma</span>\n<span class=\"s2\">    \u0432\u0430\u043d\u043d\u0430 | \u043a\u0443\u0445\u043d\u044f | \u0441\u043f\u0430\u043b\u044c\u043d\u044f</span>\n<span class=\"s2\">\"\"\"</span><span class=\"p\">)</span>\n</pre>\n<p>As a lemmer, we can use pymorphy2</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pymorphy2</span> <span class=\"kn\">import</span> <span class=\"n\">MorphAnalyzer</span>\n\n<span class=\"n\">analyzer</span> <span class=\"o\">=</span> <span class=\"n\">MorphAnalyzer</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">lemmer</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">normal_form</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">analyzer</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)]</span>\n</pre>\n<p>For embeddings, we can use a compressed FastText model</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">compress_fasttext</span>\n\n<span class=\"n\">small_model</span> <span class=\"o\">=</span> <span class=\"n\">compress_fasttext</span><span class=\"o\">.</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CompressedFastTextKeyedVectors</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span>\n    <span class=\"s1\">'https://github.com/avidale/compress-fasttext/releases/download/v0.0.1/ft_freqprune_100K_20K_pq_100.bin'</span>\n<span class=\"p\">)</span>\n<span class=\"n\">small_model</span><span class=\"o\">.</span><span class=\"n\">init_sims</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">w2v</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">small_model</span><span class=\"o\">.</span><span class=\"n\">word_vec</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">use_norm</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>The parser combines all the objects from above:</p>\n<pre><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">earley</span><span class=\"o\">.</span><span class=\"n\">EarleyParser</span><span class=\"p\">(</span><span class=\"n\">grammar</span><span class=\"p\">,</span> <span class=\"n\">w2v</span><span class=\"o\">=</span><span class=\"n\">w2v</span><span class=\"p\">,</span> <span class=\"n\">w2v_threshold</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">lemmer</span><span class=\"o\">=</span><span class=\"n\">lemmer</span><span class=\"p\">)</span>\n</pre>\n<p>The phrase below contains an OOV word <code>\u043f\u044b\u043b\u0435\u0441\u043e\u0441</code>, but its embedding is\nclose to that of <code>\u0432\u0435\u043d\u0442\u0438\u043b\u044f\u0442\u043e\u0440</code>, so the match succeeds.\nAnother problem\nis that <code>\u0441\u043f\u0430\u043b\u044c\u043d\u0435</code> is not equal to <code>\u0441\u043f\u0430\u043b\u044c\u043d\u044f</code>, but their normal forms\ncoinside and therefore match is possible.</p>\n<pre><span class=\"n\">tokens</span> <span class=\"o\">=</span> <span class=\"s1\">'\u0432\u043a\u043b\u044e\u0447\u0438 \u043f\u044b\u043b\u0435\u0441\u043e\u0441 \u0432 \u0441\u043f\u0430\u043b\u044c\u043d\u0435'</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">()</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">tokens</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">success</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">tree</span> <span class=\"ow\">in</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">iter_trees</span><span class=\"p\">():</span>\n    <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">earley</span><span class=\"o\">.</span><span class=\"n\">print_tree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">final_state</span><span class=\"p\">,</span> <span class=\"n\">w</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'======='</span><span class=\"p\">)</span>\n</pre>\n<p>The output is following:</p>\n<pre><code>True\n|                               .                               |\n|                             root                              |\n|    \u0432\u043a\u043b\u044e\u0447\u0438     |     $What     |            $Where             |\n|               |  \u043a\u043e\u043d\u0434\u0438\u0446\u0438\u043e\u043d\u0435\u0440  |       \u0432       |     $Room     |\n|               |               |               |    \u0441\u043f\u0430\u043b\u044c\u043d\u044f    |\n|    \u0432\u043a\u043b\u044e\u0447\u0438     |    \u043f\u044b\u043b\u0435\u0441\u043e\u0441    |       \u0432       |    \u0441\u043f\u0430\u043b\u044c\u043d\u0435    |\n=======\n</code></pre>\n<h2>Forms and slots</h2>\n<p>In dialogue systems, phrases are often viewed as <em>forms</em> - containers of information.\nEach meaningful piece of information can be stored in a typed <em>slot</em>.\nYou can think of them as of\n<a href=\"https://www.regular-expressions.info/refext.html\" rel=\"nofollow\">named groups</a>\nin regular expressions, or as extended\n<a href=\"https://en.wikipedia.org/wiki/Named-entity_recognition\" rel=\"nofollow\">named entities</a>.</p>\n<p>In WMG, each slot is associated with some non-terminal symbol.\nThis association can be configured in the same file as the production rules.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">word_mover_grammar</span> <span class=\"k\">as</span> <span class=\"nn\">wmg</span>\n<span class=\"n\">cfg</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">root:</span>\n<span class=\"s2\">    turn the $What $Where on</span>\n<span class=\"s2\">    turn on the $What $Where</span>\n<span class=\"s2\">$What: light | conditioner</span>\n<span class=\"s2\">$Where: in the $Room</span>\n<span class=\"s2\">$Room: bathroom | kitchen | bedroom | living room</span>\n<span class=\"s2\">slots:</span>\n<span class=\"s2\">    what:</span>\n<span class=\"s2\">        source: $What                   </span>\n<span class=\"s2\">    room:</span>\n<span class=\"s2\">        source: $Room</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"n\">grammar</span> <span class=\"o\">=</span> <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">text_to_grammar</span><span class=\"o\">.</span><span class=\"n\">load_granet</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"p\">)</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">wmg</span><span class=\"o\">.</span><span class=\"n\">earley</span><span class=\"o\">.</span><span class=\"n\">EarleyParser</span><span class=\"p\">(</span><span class=\"n\">grammar</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'turn on the light in the living room'</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">())</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">slots</span><span class=\"p\">)</span>\n</pre>\n<p>The result will be a\n<a href=\"https://yandex.ru/dev/dialogs/alice/doc/nlu-docpage/#data_to_skill\" rel=\"nofollow\">yandex-compatible</a>\nmap of slot names to the slots found in the phrase.</p>\n<pre><code>{'what': {'type': 'string', 'value': 'light', 'text': 'light', 'tokens': {'start': 3, 'end': 4}},\n 'room': {'type': 'string', 'value': 'living room', 'text': 'living room', 'tokens': {'start': 6, 'end': 8}}}\n</code></pre>\n<p>A few caveats:</p>\n<ul>\n<li>currently, in ambiguous prhases the slots are taken just from the first parse tree.\nIf you want to extract slots from an arbitrary tree,\nyou can call <code>result.extract_slots(tree)</code>.</li>\n<li>each slot is filled only once. If the non-terminal occurs several times in the phrase,\nthe corresponding slot will be filled with the first occurrence.</li>\n</ul>\n<h2>Future plans</h2>\n<p>In the future, we plan to enhance the library in the following ways:</p>\n<ul>\n<li>Conversion to and from NLTK grammars</li>\n<li>Support of quantifiers and brackets</li>\n<li>Probabilistic parsing</li>\n<li>Extraction of intents and slots from parse trees</li>\n<li>Full compatibility with Yandex Alice syntax</li>\n<li>You name it!</li>\n</ul>\n\n          </div>"}, "last_serial": 7150722, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "a3a4acb9ddf617520ad43b1890f7bb3e", "sha256": "26e5f4040979c1a5ad015d147db008c3757b34570e7a65bfbb3ef748df94b1f2"}, "downloads": -1, "filename": "word-mover-grammar-0.0.1.tar.gz", "has_sig": false, "md5_digest": "a3a4acb9ddf617520ad43b1890f7bb3e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11464, "upload_time": "2020-04-28T12:40:48", "upload_time_iso_8601": "2020-04-28T12:40:48.447495Z", "url": "https://files.pythonhosted.org/packages/3d/8e/46645449353f9c6fc0570870593ab9d21bdce74282171af5e8a8957ef46f/word-mover-grammar-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "339414b3ad8fd77ee3c2c4b19c3d88d7", "sha256": "848719c22b319e71af5d5dd24ae4fadc11d911e7966b1d66d6b6f127c353d37a"}, "downloads": -1, "filename": "word-mover-grammar-0.0.2.tar.gz", "has_sig": false, "md5_digest": "339414b3ad8fd77ee3c2c4b19c3d88d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14475, "upload_time": "2020-05-02T10:21:39", "upload_time_iso_8601": "2020-05-02T10:21:39.609558Z", "url": "https://files.pythonhosted.org/packages/a6/9d/d8984587acef7c85a90c04fb24a51a356384404f950164bfc4e8f1d03dd2/word-mover-grammar-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "339414b3ad8fd77ee3c2c4b19c3d88d7", "sha256": "848719c22b319e71af5d5dd24ae4fadc11d911e7966b1d66d6b6f127c353d37a"}, "downloads": -1, "filename": "word-mover-grammar-0.0.2.tar.gz", "has_sig": false, "md5_digest": "339414b3ad8fd77ee3c2c4b19c3d88d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14475, "upload_time": "2020-05-02T10:21:39", "upload_time_iso_8601": "2020-05-02T10:21:39.609558Z", "url": "https://files.pythonhosted.org/packages/a6/9d/d8984587acef7c85a90c04fb24a51a356384404f950164bfc4e8f1d03dd2/word-mover-grammar-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:28:01 2020"}