{"info": {"author": "Carl Montanari", "author_email": "carl.r.montanari@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: MacOS", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "![](https://github.com/carlmontanari/nssh/workflows/Weekly%20Build/badge.svg)\n[![PyPI version](https://badge.fury.io/py/nssh.svg)](https://badge.fury.io/py/nssh)\n[![Python 3.7](https://img.shields.io/badge/python-3.7-blue.svg)](https://www.python.org/downloads/release/python-370/)\n[![Python 3.8](https://img.shields.io/badge/python-3.8-blue.svg)](https://www.python.org/downloads/release/python-380/)\n[![Code Style](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)\n\n\nnssh\n=======\n\nnssh is a python library focused on connecting to devices, specifically network devices (routers/switches/firewalls\n/etc.) via SSH. nssh's goal is to be as fast and flexible as possible, while providing a well typed, well documented\n, simple API.\n\nnssh is built primarily in two parts: transport and channel. The transport layer is responsible for providing a file\n-like interface to the target SSH server. The channel layer is responsible for reading and writing to the provided\n file-like interface.\n\nThere are three available \"drivers\" for the transport layer -- all of which inherit from a base transport class and\n provide the same file-like interface to the upstream channel. The transport drivers are:\n\n- [paramiko]()\n- [ssh2-python]()\n- OpenSSH/System available SSH\n\nA good question to ask at this point is probably \"why?\". Why multiple transport options? Why not just use paramiko\n like most folks do? Historically the reason for moving away from paramiko was simply speed. ssh2-python is a wrapper\n  around the libssh2 C library, and as such is very very fast. In a prior project ([ssh2net]()), of which nssh is the\n   successor/evolution, ssh2-python was used with great success, however, it is a bit feature-limited, and devlopment\n    seems to have stalled.\n\nThis led to moving back to paramiko, which of course is a fantastic project with tons and tons of feature support\n. Paramiko, however, does not \"direct\" OpenSSH support, and I don't believe it provides 100% full OpenSSH support\n either (ex: ControlPersist). Fully supporting an OpenSSH config file would be an ideal end goal for nssh, something\n  that may not be possible with Paramiko - ControlPersist in particular is very interesting to me.\n\nWith the goal of supporting all of the OpenSSH configuration options the final transport driver option is simply\n native system local SSH (almost certainly this won't work on Windows, but I don't have a Windows box to test on, or\n  any particular interest in doing so). The implementation of using system SSH is of course a little bit messy\n  , however nssh takes care of that for you so you don't need to care about it! The payoff of using system SSH is of\n   course that OpenSSH config files simply \"work\" -- no passing it to nssh, no selective support, no need to set\n    username or ports or any of the other config items that may reside in your SSH config file. The \"system\"\n     transport driver is still a bit of a work in progress, but in testing has been reliable thus far.\n\nThe final piece of nssh is the actual \"driver\" -- or the component that binds the transport and channel together and\n deals with instantiation of an nssh object. There is a \"base\" driver object -- `NSSH` -- which provides essentially\n  a \"raw\" SSH connection with read and write methods (provided by the channel object), and not much else. More\n   specific \"drivers\" can inherit from this class to extend functionality of the driver to make it more friendly for\n    network devices.\n\n\n# Table of Contents\n\n- [Documentation](#documentation)\n- [Supported Platforms](#supported-platforms)\n- [Installation](#installation)\n- [Examples Links](#examples-links)\n- [Basic Usage](#basic-usage)\n  - [Native and Platform Drivers Examples](#native-and-platform-drivers-examples)\n  - [Platform Regex](#platform-regex)\n  - [Basic Operations -- Sending and Receiving](#basic-operations----sending-and-receiving)\n  - [Result Objects](#result-objects)\n  - [Handling Prompts](#handling-prompts)\n  - [Driver Privilege Levels](#driver-privilege-levels)\n  - [Sending Configurations](#sending-configurations)\n  - [TextFSM/NTC-Templates Integration](#textfsmntc-templates-integration)\n  - [Timeouts](#timeouts)\n  - [Disabling Paging](#disabling-paging)\n  - [Login Handlers](#login-handlers)\n  - [SSH Config Support](#ssh-config-support)\n- [FAQ](#faq)\n- [Known Issues](#known-issues)\n- [Linting and Testing](#linting-and-testing)\n\n\n# Documentation\n\nDocumentation is auto-generated [using pdoc3](https://github.com/pdoc3/pdoc). Documentation is linted (see Linting and\n Testing section) via [pydocstyle](https://github.com/PyCQA/pydocstyle/) and [darglint](https://github.com/terrencepreilly/darglint).\n\nDocumentation is hosted via GitHub Pages and can be found [here.](https://carlmontanari.github.io/nssh/docs/nssh/index.html). \n You can also view the readme as a web page [here.](https://carlmontanari.github.io/nssh/)\n\nTo regenerate documentation locally, use the following make command:\n\n```\nmake docs\n```\n\n\n# Supported Platforms\n\nnssh \"core\" drivers cover basically the [NAPALM](https://github.com/napalm-automation/napalm) platforms -- Cisco IOS-XE,\n IOS-XR, NX-OS, Arista EOS, and Juniper JunOS. These drivers provide an interface tailored to network device \"screen\n -scraping\" rather than just a generic SSH connection/channel.\n\nAt the moment there are five \"core\" drivers representing the most common networking platforms (outlined below)\n, however in the future it would be possible for folks to contribute additional \"community\" drivers. It is unlikely\n that any additional \"core\" platforms would be added at the moment.\n\n- Cisco IOS-XE (tested on: 16.04.01)\n- Cisco NX-OS (tested on: 9.2.4)\n- Juniper JunOS (tested on: 17.3R2.10)\n- Cisco IOS-XR (tested on: 6.5.3)\n- Arista EOS (tested on: 4.22.1F)\n\nThis \"driver\" pattern is pretty much exactly like the implementation in NAPALM. The driver extends the base class/base\n  networking driver class with device specific functionality such as privilege escalation/de-escalation, setting\n   appropriate prompts to search for, and picking out appropriate [ntc templates](https://github.com/napalm-automation/napalm)\n    for use with TextFSM. \n\nAll of this is focused on network device type SSH cli interfaces, but should work on pretty much any SSH connection\n (though there are almost certainly better options for non-network type devices!). This \"base\" (`NSSH`) connection does\n  not handle any kind of device-specific operations such as privilege escalation or saving configurations, it is simply\n   intended to be a bare bones connection that can interact with nearly any device/platform if you are willing to\n    send/parse inputs/outputs manually.\n\nThe goal for all \"core\" devices will be to include functional tests that can run against [vrnetlab](https://github.com/plajjan/vrnetlab)\n containers to ensure that the \"core\" devices are as thoroughly tested as is practical. \n\n\n# Installation\n\nYou should be able to pip install it \"normally\":\n\n```\npip install nssh\n```\n\nTo install from this repositories master branch:\n\n```\npip install git+https://github.com/carlmontanari/nssh\n```\n\nTo install from source:\n\n```\ngit clone https://github.com/carlmontanari/nssh\ncd nssh\npython setup.py install\n```\n\nAs for platforms to *run* nssh on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any\n POSIX system.\n\n\n# Examples Links\n\n- [Basic \"native\" NSSH operations](/examples/basic_usage/nssh_driver.py)\n- [Basic \"driver\" NSSH operations](/examples/basic_usage/iosxe_driver.py)\n- [Setting up basic logging](/examples/logging/basic_logging.py)\n- [Using SSH Key for authentication](/examples/ssh_keys/ssh_keys.py)\n- [Using SSH config file](/)\n\n\n# Basic Usage\n\n## Native and Platform Drivers Examples\n\nExample NSSH \"native/base\" connection:\n\n```python\nfrom nssh import NSSH\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\nconn = NSSH(**my_device)\nconn.open()\n# do stuff!\n```\n\nExample IOS-XE driver setup. This also shows using context manager which is also supported on \"native\" mode -- when\n using the context manager there is no need to call the \"open_shell\" method:\n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\nwith IOSXEDriver(**my_device) as conn:\n    print(conn)\n    # do stuff!\n```\n\n## Platform Regex\n\nDue to the nature of SSH there is no good way to know when a command has completed execution. Put another way, when\n sending any command, data is returned over a socket, that socket doesn't ever tell us when it is \"done\" sending the\n  output from the command that was executed. In order to know when the session is \"back at the base prompt/starting\n   point\" nssh uses a regular expression pattern to find that base prompt.\n\nThis pattern is contained in the `comms_prompt_pattern` setting, and is perhaps the most important argument to getting\n nssh working.\n\nThe \"base\" (default, but changeable) pattern is:\n\n`\"^[a-z0-9.\\-@()/:]{1,20}[#>$]$\"`\n\n*NOTE* all `comms_prompt_pattern` should use the start and end of line anchors as all regex searches in nssh are\n multline (this is an important piece to making this all work!). While you don't *need* to use the line anchors its\n  probably a really good idea!\n\nThe above pattern works on all \"core\" platforms listed above for at the very least basic usage. Custom prompts or\n hostnames could in theory break this, so be careful!\n\nIf you do not wish to match Cisco \"config\" level prompts you could use a `comms_prompt_pattern` such as:\n\n`\"^[a-z0-9.-@]{1,20}[#>$]$\"`\n\nIf you use a platform driver, the base prompt is set in the driver so you don't really need to worry about this!\n\nThe `comms_prompt_pattern` pattern can be changed at any time at or after instantiation of an nssh object. Changing\n this *can* break things though, so be careful!\n\n\n## Basic Operations -- Sending and Receiving\n\nSending inputs and receiving outputs is done through the base NSSH object or your selected driver object. The inputs\n /outputs all are processed (sent/read) via the channel object. If using the base `NSSH` object you must use the\n  `channel.send_inputs` method -- the `NetworkDriver` and platform specific drivers have a `send_commands` method as\n   outlined below. The following example shows sending a \"show version\" command as a string. Also shown: `send_inputs\n   ` accepts a list/tuple of commands.\n\n```python\nfrom nssh import NSSH\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\nwith NSSH(**my_device) as conn:\n    results = conn.channel.send_inputs(\"show version\")\n    results = conn.channel.send_inputs((\"show version\", \"show run\"))\n```\n\nWhen using a network \"driver\", it is more desirable to use the `send_commands` method to send commands (commands that\n would be ran at privilege exec in Cisco terms, or similar privilege level for the other platforms). `send_commands` is\n  just a thin wrapper around `send_inputs`, however it ensures that the device is at the appropriate prompt\n   (`default_desired_priv` attribute of the specific driver, see [Driver Privilege Levels](#driver-privilege-levels)).\n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\nwith IOSXEDriver(**my_device) as conn:\n    results = conn.send_commands(\"show version\")\n    results = conn.send_commands((\"show version\", \"show run\"))\n```\n\n\n## Result Objects\n\nAll read operations result in a `Result` object being created. The `Result` object contains attributes for the command\n sent (`channel_input`), start/end/elapsed time, and of course the result of the command sent.\n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\nwith IOSXEDriver(**my_device) as conn:\n    results = conn.send_commands(\"show version\")\n    print(results[0].elapsed_time)\n    print(results[0].result)\n```\n\n\n## Handling Prompts\n\nIn some cases you may need to run an \"interactive\" command on your device. The `send_inputs_interact` method can be\n used to handle these situations. This method accepts a tuple containing the initial input (command) to send, the\n  expected prompt after the initial send, the response to that prompt, and the final expected prompt -- basically\n   telling nssh when it is done with the interactive command. In the below example the expectation is that the\n    current/base prompt is the final expected prompt, so we can simply call the `get_prompt` method to snag that\n     directly off the router.\n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\ninteract = [\"clear logging\", \"Clear logging buffer [confirm]\", \"\\n\"]\n\nwith IOSXEDriver(**my_device) as conn:\n    interactive = conn.channel.send_inputs_interact(\n                (\"clear logging\", \"Clear logging buffer [confirm]\", \"\\n\", conn.get_prompt())\n            )\n```\n\n\n## Driver Privilege Levels\n\nThe \"core\" drivers understand the basic privilege levels of their respective device types. As mentioned previously\n, the drivers will automatically attain the \"privilege_exec\" (or equivalent) privilege level prior to executing \"show\n\" commands. If you don't want this \"auto-magic\" you can use the base driver (nssh). The privileges for each device\n are outlined in named tuples in the platforms `driver.py` file. \n\nAs an example, the following privilege levels are supported by the IOSXEDriver:\n\n1. \"exec\"\n2. \"privilege_exec\"\n3. \"configuration\"\n4. \"special_configuration\"\n\nEach privilege level has the following attributes:\n\n- pattern: regex pattern to associate prompt to privilege level with\n- name: name of the priv level, i.e. \"exec\"\n- deescalate_priv: name of next lower privilege or None\n- deescalate: command to deescalate to next lower privilege or None\n- escalate: name of next higher privilege or None\n- escalate_auth: command to escalate to next higher privilege or None\n- escalate_prompt: False or pattern to expect for escalation -- i.e. \"Password:\"\n- requestable: True/False if the privilege level is requestable\n- level: integer value of level i.e. 1\n\nIf you wish to manually enter a privilege level you can use the `acquire_priv` method, passing in the name of the\n privilege level you would like to enter. In general you probably won't need this too often though as the driver\n  should handle much of this for you.\n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\n\nwith IOSXEDriver(**my_device) as conn:\n    conn.acquire_priv(\"configuration\")\n```\n\n\n## Sending Configurations\n\nWhen using the native mode (`NSSH` object), sending configurations is no different than sending commands and is done via\n the `send_inputs` method. You must manually ensure you are in the correct privilege/mode.\n\nWhen using any of the core drivers or the base `NetworkDriver`, you can send configurations via the `send_configs` method\n which will handle privilege escalation for you. As with the `send_commands` and `send_inputs` methods -- you can\n  send a single string or a list/tuple of strings.\n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\n\nwith IOSXEDriver(**my_device) as conn:\n    conn.send_configs((\"interface loopback123\", \"description configured by nssh\"))\n```\n\n\n## TextFSM/NTC-Templates Integration\n\nnssh supports parsing output with TextFSM. This of course requires installing TextFSM and having ntc-templates\n somewhere on your system. When using a driver you can pass `textfsm=True` to the `send_commands` method to\n  automatically try to parse all output. Parsed/structured output is stored in the `Result` object in the\n   `structured_result` attribute. Alternatively you can use the `textfsm_parse_output` method of the driver to parse\n    output in a more manual fashion. This method accepts the string command (channel_input) and the text result and\n     returns structured data; the driver is already configured with the ntc-templates device type to find the correct\n      template. \n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\n\nwith IOSXEDriver(**my_device) as conn:\n    results = conn.send_commands(\"show version\", textfsm=True)\n    print(results[0].structured_result)\n    # or parse manually...\n    results = conn.send_commands(\"show version\")\n    structured_output = conn.textfsm_parse_output(\"show version\", results[0].result)\n```\n\nnssh also supports passing in templates manually (meaning not using the pip installed ntc-templates directory to\n find templates) if desired. The `nssh.helper.textfsm_parse` function accepts a string or loaded (TextIOWrapper\n ) template and output to parse. This can be useful if you have custom or one off templates or don't want to pip\n  install ntc-templates.\n\n```python\nfrom nssh.driver.core import IOSXEDriver\nfrom nssh.helper import textfsm_parse\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\"}\n\nwith IOSXEDriver(**my_device) as conn:\n    results = conn.send_commands(\"show version\")\n    structured_result = textfsm_parse(\"/path/to/my/template\", results[0].result)\n```\n\n*NOTE*: If a template does not return structured data an empty dict will be returned!\n\n\n## Timeouts\n\nnssh supports several timeout options. The simplest is the `timeout_socket` which controls the timeout for... setting\n up the underlying socket in seconds. Value should be a positive, non-zero number, however ssh2 and paramiko\n  transport options support floats.\n\n`timeout_ssh` sets the timeout for the actual SSH session when using ssh2 or paramiko transport options. When using\n system SSH, this is currently only used as the timeout timer for authentication.\n\nFinally, `timeout_ops` sets a timeout value for individual operations -- or put another way, the timeout for each\n send_input operation.\n\n\n## Disabling Paging\n\nnssh native driver attempts to send `terminal length 0` to disable paging by default. In the future this will\n likely be removed and relegated to the device drivers only. For all drivers, there is a standard disable paging\n  string already configured for you, however this is of course user configurable. In addition to passing a string to\n   send to disable paging, nssh supports passing a callable. This callable should accept the drivers reference to\n    self as the only argument. This allows for users to create a custom function to disable paging however they like\n    . This callable option is supported on the native driver as well. In general it is probably a better idea to\n     handle this by simply passing a string, but the goal is to be flexible so the callable is supported.\n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\ndef iosxe_disable_paging(cls):\n    cls.send_commands(\"term length 0\")\n\nmy_device = {\"host\": \"172.18.0.11\", \"auth_username\": \"vrnetlab\", \"auth_password\": \"VR-netlab9\", \"session_disable_paging\": iosxe_disable_paging}\n\nwith IOSXEDriver(**my_device) as conn:\n    print(conn.get_prompt())\n```\n\n\n## Login Handlers\n\nSome devices have additional prompts or banners at login. This generally causes issues for SSH screen scraping\n automation. nssh supports -- just like disable paging -- passing a string to send or a callable to execute after\n  successful SSH connection but before disabling paging occurs. By default this is an empty string which does nothing.\n\n\n## SSH Config Support\n\nnssh supports using OpenSSH configuration files in a few ways. For \"system\" SSH driver, passing a path to a config\n file will simply make nssh \"point\" to that file, and therefore use that configuration files attributes (because it\n  is just exec'ing system SSH!). Soon SSH support that exists in ssh2net will be ported over to nssh for ssh2-python\n   and paramiko transport drivers.\n\n*NOTE* -- when using the system (default) SSH transport driver nssh does NOT disable strict host checking by default\n. Obviously this is the \"smart\" behavior, but it can be overridden on a per host basis in your SSH config file, or by\n passing `False` to the \"auth_strict_key\" argument on object instantiation.\n\n```python\nfrom nssh.driver.core import IOSXEDriver\n\nmy_device = {\"host\": \"172.18.0.11\", \"ssh_config_file\": \"~/mysshconfig\", \"auth_strict_key\": False, \"auth_password\": \"VR-netlab9\"}\n\nwith IOSXEDriver(**my_device) as conn:\n    print(conn.get_prompt())\n```\n\n\n# FAQ\n\n- Question: Why build this? Netmiko exists, Paramiko exists, Ansible exists, etc...?\n  - Answer: I built ssh2net to learn -- to have a goal/target for writing some code. nssh is an evolution of the\n   lessons learned building ssh2net. About mid-way through building ssh2net I realized it may actually be kinda good\n    at doing... stuff. So, sure there are other tools out there, but I think nssh its pretty snazzy and fills in some\n     of the gaps in other tools. For example nssh is 100% compliant with strict mypy type checking, very uniformly\n      documented/linted, contains a results object for every operation, is very very fast, is very flexible, and in\n       general pretty awesome! Finally, while I think in general that SSH \"screen scraping\" is not \"sexy\" or even\n        \"good\", it is the lowest common denominator for automation in the networking world. So I figured I could try\n         to make the fastest, most flexible library around for SSH network automation! \n- Question: Is this better than Netmiko/Paramiko/Ansible?\n  - Answer: Nope! It is different though! The main focus is just to be stupid fast. It is very much that. It *should* be\n  super reliable too as the timeouts are very easy/obvious to control, and it should also be very very very easy to\n   adapt to any other network-y type CLI.\n- Question: Is this easy to use?\n  - Answer: Yep! The \"native\" usage is pretty straight forward -- the thing to remember is that it doesn't do \"things\n  \" for you like Netmiko does for example, so its a lot more like Paramiko in that regard. That said you can use one\n   of the available drivers to have a more Netmiko-like experience -OR- write your own driver as this has been built\n    with the thought of being easily extended.\n- Why do I get a \"conn (or your object name here) has no attribute channel\" exception when using the base `NSSH` or\n `NetworkDriver` objects?\n  - Answer: Those objects do not \"auto open\", and the channel attribute is not assigned until opening the connection\n  . Call `conn.open()` (or your object name in place of conn) to open the session and assign the channel attribute.\n- Other questions? Ask away!\n\n\n# Known Issues\n\n## SSH2-Python\n\n- Arista EOS uses keyboard interactive authentication which is currently broken in the pip-installable version\n of ssh2-python (as of January 2020). GitHub user [Red-M](https://github.com/Red-M) has contributed to and fixed this\n  particular issue but the fix has not been merged. If you would like to use ssh2-python with EOS I suggest cloning\n   and installing via Red-M's repository or my fork of Red-M's fork!\n\n- Use the context manager where possible! More testing needs to be done to confirm/troubleshoot, but limited testing\n seems to indicate that without properly closing the connection there appears to be a bug that causes Python to crash\n  on MacOS at least. More to come on this as I have time to poke it more! I believe this is only occurring on the\n   latest branch/update (i.e. not on the pip installable version).\n\n\n# Linting and Testing\n\n*NOTE* Currently there are no unit/functional tests for IOSXR/NXOS/EOS/Junos, however as this part of nssh is largely\n a port of ssh2net, they should work :) \n\n## Linting\n\nThis project uses [black](https://github.com/psf/black) for auto-formatting. In addition to black, tox will execute\n [pylama](https://github.com/klen/pylama), and [pydocstyle](https://github.com/PyCQA/pydocstyle) for linting purposes\n . Tox will also run  [mypy](https://github.com/python/mypy), with strict type checking. Docstring linting with\n  [darglint](https://github.com/terrencepreilly/darglint) which has been quite handy!\n\nAll commits to this repository will trigger a GitHub action which runs tox, but of course its nicer to just run that\n before making a commit to ensure that it will pass all tests!\n\n\n### Typing\n\nAs stated, this project is 100% type checked and will remain that way. The value this adds for IDE auto-completion\n and just general sanity checking/forcing writing of more type-check-able code is worth the small overhead in effort.\n\n## Testing\n\nI broke testing into two main categories -- unit and functional. Unit is what you would expect -- unit testing the code.\n Functional testing connects to virtual devices in order to more accurately test the code. Unit tests cover quite a\n  bit of the code base due to mocking the FileIO that the channel reads/writes to. This gives a pretty high level of\n   confidence that at least object instantiation and channel read/writes will generally work... Functional tests\n    against virtual devices helps reinforce that and gets coverage for the transport classes.\n\n### Unit Tests\n\nUnit tests can be executed via pytest:\n\n```\npython -m pytest tests/unit/\n```\n\nOr using the following make command:\n\n```\nmake test_unit\n```\n\nIf you would like to see the coverage report and generate the html coverage report:\n\n```\nmake cov_unit\n```\n\n\n### Setting up Functional Test Environment\n\n\nExecuting the functional tests is a bit more complicated! First, thank you to Kristian Larsson for his great tool [vrnetlab](https://github.com/plajjan/vrnetlab)! All functional tests are built on this awesome platform that allows for easy creation of containerized network devices.\n\nBasic functional tests exist for all \"core\" platform types (IOSXE, NXOS, IOSXR, EOS, Junos). Vrnetlab currently only supports the older emulation style NX-OS devices, and *not* the newer VM image n9kv. I have made some very minor tweaks to vrnetlab locally in order to get the n9kv image running -- I have raised a PR to add this to vrnetlab proper. Minus the n9kv tweaks, getting going with vrnetlab is fairly straightforward -- simply follow Kristian's great readme docs. For the Arista EOS image -- prior to creating the container you should boot the device and enter the `zerotouch disable` command. This allows for the config to actually be saved and prevents the interfaces from cycling through interface types in the container (I'm not clear why it does that but executing this command before building the container \"fixes\" this!). After creating the image(s) that you wish to test, rename the image to the following format:\n\n```\nnssh[PLATFORM]\n```\n\nThe docker-compose file here will be looking for the container images matching this pattern, so this is an important bit! The container image names should be:\n\n```\nnsshciscoiosxe\nnsshcisconxos\nnsshciscoiosxr\nnsshciscojunos\n```\n\nYou can tag the image names on creation (following the vrnetlab readme docs), or create a new tag once the image is built:\n\n```\ndocker tag [TAG OF IMAGE CREATED] nssh[VENDOR][OS]\n```\n\n*NOTE* I have added vty lines 5-98 on the CSR image -- I think the connections opening/closing so quickly during\n testing caused them to get hung. Testing things more slowly (adding time.sleep after closing connections) fixed this\n  but that obviously made the testing time longer, so this seemed like a better fix. This change will be in my fork\n   of vrnetlab or you can simply modify the `line vty 0 5` --> `line vty 0 98` in the `luanch.py` for the CSR in your\n    vrnetlab clone.\n\n\n### Functional Tests\n\nOnce you have created the images, you can start the containers with a make command:\n\n```\nmake start_dev_env\n```\n\nConversely you can terminate the containers:\n\n```\nmake stop_dev_env\n```\n\nTo start a specific platform container:\n\n```\nmake start_dev_env_iosxe\n```\n\nSubstitute \"iosxe\" for the platform type you want to start.\n\nMost of the containers don't take too long to fire up, maybe a few minutes (running on my old macmini with Ubuntu, so not exactly a powerhouse!). That said, the IOS-XR device takes about 15 minutes to go to \"healthy\" status. Once booted up you can connect to their console or via SSH:\n\n| Device        | Local IP      |\n| --------------|---------------|\n| iosxe         | 172.18.0.11   |\n| nxos          | 172.18.0.12   |\n| iosxr         | 172.18.0.13   |\n| eos           | 172.18.0.14   |\n| junos         | 172.18.0.15   |\n\nThe console port for all devices is 5000, so to connect to the console of the iosxe device you can simply telnet to that port locally:\n\n```\ntelnet 172.18.0.11 5000\n```\n\nCredentials for all devices use the default vrnetlab credentials:\n\nUsername: `vrnetlab`\n\nPassword: `VR-netlab9`\n\nOnce the container(s) are ready, you can use the make commands to execute tests as needed:\n\n- `test` will execute all currently implemented functional tests as well as the unit tests\n- `test_functional` will execute all currently implemented functional tests\n- `test_iosxe` will execute all unit tests and iosxe functional tests\n- `test_nxos` will execute all unit tests and nxos functional tests\n- `test_iosxr` will execute all unit tests and iosxr functional tests\n- `test_eos` will execute all unit tests and eos functional tests\n- `test_junos` will execute all unit tests and junos functional tests\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/carlmontanari/nssh", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "nssh", "package_url": "https://pypi.org/project/nssh/", "platform": "", "project_url": "https://pypi.org/project/nssh/", "project_urls": {"Homepage": "https://github.com/carlmontanari/nssh"}, "release_url": "https://pypi.org/project/nssh/2020.2.2/", "requires_dist": ["paramiko (>=2.6.0) ; extra == 'paramiko'", "ssh2-python (>=0.18.0-1) ; extra == 'ssh2'", "textfsm (>=1.1.0) ; extra == 'textfsm'", "ntc-templates (>=1.1.0) ; extra == 'textfsm'"], "requires_python": ">=3.7", "summary": "SSH client focused on network devices", "version": "2020.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/41b81c29a5525f149fb84fd3568c3f45d6afa385/68747470733a2f2f6769746875622e636f6d2f6361726c6d6f6e74616e6172692f6e7373682f776f726b666c6f77732f5765656b6c792532304275696c642f62616467652e737667\">\n<a href=\"https://badge.fury.io/py/nssh\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f70cbb67c0fd1243c01576f3f1266a2e3aa54093/68747470733a2f2f62616467652e667572792e696f2f70792f6e7373682e737667\"></a>\n<a href=\"https://www.python.org/downloads/release/python-370/\" rel=\"nofollow\"><img alt=\"Python 3.7\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/99a5180f32db379110e9948c7de1aaf8f77bf2e8/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e372d626c75652e737667\"></a>\n<a href=\"https://www.python.org/downloads/release/python-380/\" rel=\"nofollow\"><img alt=\"Python 3.8\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7f8a5f68d8d76185564998e2d4814ac79bc72a7c/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e382d626c75652e737667\"></a>\n<a href=\"https://github.com/ambv/black\" rel=\"nofollow\"><img alt=\"Code Style\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a></p>\n<h1>nssh</h1>\n<p>nssh is a python library focused on connecting to devices, specifically network devices (routers/switches/firewalls\n/etc.) via SSH. nssh's goal is to be as fast and flexible as possible, while providing a well typed, well documented\n, simple API.</p>\n<p>nssh is built primarily in two parts: transport and channel. The transport layer is responsible for providing a file\n-like interface to the target SSH server. The channel layer is responsible for reading and writing to the provided\nfile-like interface.</p>\n<p>There are three available \"drivers\" for the transport layer -- all of which inherit from a base transport class and\nprovide the same file-like interface to the upstream channel. The transport drivers are:</p>\n<ul>\n<li><a href=\"\" rel=\"nofollow\">paramiko</a></li>\n<li><a href=\"\" rel=\"nofollow\">ssh2-python</a></li>\n<li>OpenSSH/System available SSH</li>\n</ul>\n<p>A good question to ask at this point is probably \"why?\". Why multiple transport options? Why not just use paramiko\nlike most folks do? Historically the reason for moving away from paramiko was simply speed. ssh2-python is a wrapper\naround the libssh2 C library, and as such is very very fast. In a prior project (<a href=\"\" rel=\"nofollow\">ssh2net</a>), of which nssh is the\nsuccessor/evolution, ssh2-python was used with great success, however, it is a bit feature-limited, and devlopment\nseems to have stalled.</p>\n<p>This led to moving back to paramiko, which of course is a fantastic project with tons and tons of feature support\n. Paramiko, however, does not \"direct\" OpenSSH support, and I don't believe it provides 100% full OpenSSH support\neither (ex: ControlPersist). Fully supporting an OpenSSH config file would be an ideal end goal for nssh, something\nthat may not be possible with Paramiko - ControlPersist in particular is very interesting to me.</p>\n<p>With the goal of supporting all of the OpenSSH configuration options the final transport driver option is simply\nnative system local SSH (almost certainly this won't work on Windows, but I don't have a Windows box to test on, or\nany particular interest in doing so). The implementation of using system SSH is of course a little bit messy\n, however nssh takes care of that for you so you don't need to care about it! The payoff of using system SSH is of\ncourse that OpenSSH config files simply \"work\" -- no passing it to nssh, no selective support, no need to set\nusername or ports or any of the other config items that may reside in your SSH config file. The \"system\"\ntransport driver is still a bit of a work in progress, but in testing has been reliable thus far.</p>\n<p>The final piece of nssh is the actual \"driver\" -- or the component that binds the transport and channel together and\ndeals with instantiation of an nssh object. There is a \"base\" driver object -- <code>NSSH</code> -- which provides essentially\na \"raw\" SSH connection with read and write methods (provided by the channel object), and not much else. More\nspecific \"drivers\" can inherit from this class to extend functionality of the driver to make it more friendly for\nnetwork devices.</p>\n<h1>Table of Contents</h1>\n<ul>\n<li><a href=\"#documentation\" rel=\"nofollow\">Documentation</a></li>\n<li><a href=\"#supported-platforms\" rel=\"nofollow\">Supported Platforms</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#examples-links\" rel=\"nofollow\">Examples Links</a></li>\n<li><a href=\"#basic-usage\" rel=\"nofollow\">Basic Usage</a>\n<ul>\n<li><a href=\"#native-and-platform-drivers-examples\" rel=\"nofollow\">Native and Platform Drivers Examples</a></li>\n<li><a href=\"#platform-regex\" rel=\"nofollow\">Platform Regex</a></li>\n<li><a href=\"#basic-operations----sending-and-receiving\" rel=\"nofollow\">Basic Operations -- Sending and Receiving</a></li>\n<li><a href=\"#result-objects\" rel=\"nofollow\">Result Objects</a></li>\n<li><a href=\"#handling-prompts\" rel=\"nofollow\">Handling Prompts</a></li>\n<li><a href=\"#driver-privilege-levels\" rel=\"nofollow\">Driver Privilege Levels</a></li>\n<li><a href=\"#sending-configurations\" rel=\"nofollow\">Sending Configurations</a></li>\n<li><a href=\"#textfsmntc-templates-integration\" rel=\"nofollow\">TextFSM/NTC-Templates Integration</a></li>\n<li><a href=\"#timeouts\" rel=\"nofollow\">Timeouts</a></li>\n<li><a href=\"#disabling-paging\" rel=\"nofollow\">Disabling Paging</a></li>\n<li><a href=\"#login-handlers\" rel=\"nofollow\">Login Handlers</a></li>\n<li><a href=\"#ssh-config-support\" rel=\"nofollow\">SSH Config Support</a></li>\n</ul>\n</li>\n<li><a href=\"#faq\" rel=\"nofollow\">FAQ</a></li>\n<li><a href=\"#known-issues\" rel=\"nofollow\">Known Issues</a></li>\n<li><a href=\"#linting-and-testing\" rel=\"nofollow\">Linting and Testing</a></li>\n</ul>\n<h1>Documentation</h1>\n<p>Documentation is auto-generated <a href=\"https://github.com/pdoc3/pdoc\" rel=\"nofollow\">using pdoc3</a>. Documentation is linted (see Linting and\nTesting section) via <a href=\"https://github.com/PyCQA/pydocstyle/\" rel=\"nofollow\">pydocstyle</a> and <a href=\"https://github.com/terrencepreilly/darglint\" rel=\"nofollow\">darglint</a>.</p>\n<p>Documentation is hosted via GitHub Pages and can be found <a href=\"https://carlmontanari.github.io/nssh/docs/nssh/index.html\" rel=\"nofollow\">here.</a>.\nYou can also view the readme as a web page <a href=\"https://carlmontanari.github.io/nssh/\" rel=\"nofollow\">here.</a></p>\n<p>To regenerate documentation locally, use the following make command:</p>\n<pre><code>make docs\n</code></pre>\n<h1>Supported Platforms</h1>\n<p>nssh \"core\" drivers cover basically the <a href=\"https://github.com/napalm-automation/napalm\" rel=\"nofollow\">NAPALM</a> platforms -- Cisco IOS-XE,\nIOS-XR, NX-OS, Arista EOS, and Juniper JunOS. These drivers provide an interface tailored to network device \"screen\n-scraping\" rather than just a generic SSH connection/channel.</p>\n<p>At the moment there are five \"core\" drivers representing the most common networking platforms (outlined below)\n, however in the future it would be possible for folks to contribute additional \"community\" drivers. It is unlikely\nthat any additional \"core\" platforms would be added at the moment.</p>\n<ul>\n<li>Cisco IOS-XE (tested on: 16.04.01)</li>\n<li>Cisco NX-OS (tested on: 9.2.4)</li>\n<li>Juniper JunOS (tested on: 17.3R2.10)</li>\n<li>Cisco IOS-XR (tested on: 6.5.3)</li>\n<li>Arista EOS (tested on: 4.22.1F)</li>\n</ul>\n<p>This \"driver\" pattern is pretty much exactly like the implementation in NAPALM. The driver extends the base class/base\nnetworking driver class with device specific functionality such as privilege escalation/de-escalation, setting\nappropriate prompts to search for, and picking out appropriate <a href=\"https://github.com/napalm-automation/napalm\" rel=\"nofollow\">ntc templates</a>\nfor use with TextFSM.</p>\n<p>All of this is focused on network device type SSH cli interfaces, but should work on pretty much any SSH connection\n(though there are almost certainly better options for non-network type devices!). This \"base\" (<code>NSSH</code>) connection does\nnot handle any kind of device-specific operations such as privilege escalation or saving configurations, it is simply\nintended to be a bare bones connection that can interact with nearly any device/platform if you are willing to\nsend/parse inputs/outputs manually.</p>\n<p>The goal for all \"core\" devices will be to include functional tests that can run against <a href=\"https://github.com/plajjan/vrnetlab\" rel=\"nofollow\">vrnetlab</a>\ncontainers to ensure that the \"core\" devices are as thoroughly tested as is practical.</p>\n<h1>Installation</h1>\n<p>You should be able to pip install it \"normally\":</p>\n<pre><code>pip install nssh\n</code></pre>\n<p>To install from this repositories master branch:</p>\n<pre><code>pip install git+https://github.com/carlmontanari/nssh\n</code></pre>\n<p>To install from source:</p>\n<pre><code>git clone https://github.com/carlmontanari/nssh\ncd nssh\npython setup.py install\n</code></pre>\n<p>As for platforms to <em>run</em> nssh on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any\nPOSIX system.</p>\n<h1>Examples Links</h1>\n<ul>\n<li><a href=\"/examples/basic_usage/nssh_driver.py\" rel=\"nofollow\">Basic \"native\" NSSH operations</a></li>\n<li><a href=\"/examples/basic_usage/iosxe_driver.py\" rel=\"nofollow\">Basic \"driver\" NSSH operations</a></li>\n<li><a href=\"/examples/logging/basic_logging.py\" rel=\"nofollow\">Setting up basic logging</a></li>\n<li><a href=\"/examples/ssh_keys/ssh_keys.py\" rel=\"nofollow\">Using SSH Key for authentication</a></li>\n<li><a href=\"/\" rel=\"nofollow\">Using SSH config file</a></li>\n</ul>\n<h1>Basic Usage</h1>\n<h2>Native and Platform Drivers Examples</h2>\n<p>Example NSSH \"native/base\" connection:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh</span> <span class=\"kn\">import</span> <span class=\"n\">NSSH</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">NSSH</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">()</span>\n<span class=\"c1\"># do stuff!</span>\n</pre>\n<p>Example IOS-XE driver setup. This also shows using context manager which is also supported on \"native\" mode -- when\nusing the context manager there is no need to call the \"open_shell\" method:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">conn</span><span class=\"p\">)</span>\n    <span class=\"c1\"># do stuff!</span>\n</pre>\n<h2>Platform Regex</h2>\n<p>Due to the nature of SSH there is no good way to know when a command has completed execution. Put another way, when\nsending any command, data is returned over a socket, that socket doesn't ever tell us when it is \"done\" sending the\noutput from the command that was executed. In order to know when the session is \"back at the base prompt/starting\npoint\" nssh uses a regular expression pattern to find that base prompt.</p>\n<p>This pattern is contained in the <code>comms_prompt_pattern</code> setting, and is perhaps the most important argument to getting\nnssh working.</p>\n<p>The \"base\" (default, but changeable) pattern is:</p>\n<p><code>\"^[a-z0-9.\\-@()/:]{1,20}[#&gt;$]$\"</code></p>\n<p><em>NOTE</em> all <code>comms_prompt_pattern</code> should use the start and end of line anchors as all regex searches in nssh are\nmultline (this is an important piece to making this all work!). While you don't <em>need</em> to use the line anchors its\nprobably a really good idea!</p>\n<p>The above pattern works on all \"core\" platforms listed above for at the very least basic usage. Custom prompts or\nhostnames could in theory break this, so be careful!</p>\n<p>If you do not wish to match Cisco \"config\" level prompts you could use a <code>comms_prompt_pattern</code> such as:</p>\n<p><code>\"^[a-z0-9.-@]{1,20}[#&gt;$]$\"</code></p>\n<p>If you use a platform driver, the base prompt is set in the driver so you don't really need to worry about this!</p>\n<p>The <code>comms_prompt_pattern</code> pattern can be changed at any time at or after instantiation of an nssh object. Changing\nthis <em>can</em> break things though, so be careful!</p>\n<h2>Basic Operations -- Sending and Receiving</h2>\n<p>Sending inputs and receiving outputs is done through the base NSSH object or your selected driver object. The inputs\n/outputs all are processed (sent/read) via the channel object. If using the base <code>NSSH</code> object you must use the\n<code>channel.send_inputs</code> method -- the <code>NetworkDriver</code> and platform specific drivers have a <code>send_commands</code> method as\noutlined below. The following example shows sending a \"show version\" command as a string. Also shown: <code>send_inputs</code> accepts a list/tuple of commands.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh</span> <span class=\"kn\">import</span> <span class=\"n\">NSSH</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n<span class=\"k\">with</span> <span class=\"n\">NSSH</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">send_inputs</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">send_inputs</span><span class=\"p\">((</span><span class=\"s2\">\"show version\"</span><span class=\"p\">,</span> <span class=\"s2\">\"show run\"</span><span class=\"p\">))</span>\n</pre>\n<p>When using a network \"driver\", it is more desirable to use the <code>send_commands</code> method to send commands (commands that\nwould be ran at privilege exec in Cisco terms, or similar privilege level for the other platforms). <code>send_commands</code> is\njust a thin wrapper around <code>send_inputs</code>, however it ensures that the device is at the appropriate prompt\n(<code>default_desired_priv</code> attribute of the specific driver, see <a href=\"#driver-privilege-levels\" rel=\"nofollow\">Driver Privilege Levels</a>).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">((</span><span class=\"s2\">\"show version\"</span><span class=\"p\">,</span> <span class=\"s2\">\"show run\"</span><span class=\"p\">))</span>\n</pre>\n<h2>Result Objects</h2>\n<p>All read operations result in a <code>Result</code> object being created. The <code>Result</code> object contains attributes for the command\nsent (<code>channel_input</code>), start/end/elapsed time, and of course the result of the command sent.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">elapsed_time</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<h2>Handling Prompts</h2>\n<p>In some cases you may need to run an \"interactive\" command on your device. The <code>send_inputs_interact</code> method can be\nused to handle these situations. This method accepts a tuple containing the initial input (command) to send, the\nexpected prompt after the initial send, the response to that prompt, and the final expected prompt -- basically\ntelling nssh when it is done with the interactive command. In the below example the expectation is that the\ncurrent/base prompt is the final expected prompt, so we can simply call the <code>get_prompt</code> method to snag that\ndirectly off the router.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n<span class=\"n\">interact</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"clear logging\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Clear logging buffer [confirm]\"</span><span class=\"p\">,</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">]</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">interactive</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">send_inputs_interact</span><span class=\"p\">(</span>\n                <span class=\"p\">(</span><span class=\"s2\">\"clear logging\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Clear logging buffer [confirm]\"</span><span class=\"p\">,</span> <span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">,</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">get_prompt</span><span class=\"p\">())</span>\n            <span class=\"p\">)</span>\n</pre>\n<h2>Driver Privilege Levels</h2>\n<p>The \"core\" drivers understand the basic privilege levels of their respective device types. As mentioned previously\n, the drivers will automatically attain the \"privilege_exec\" (or equivalent) privilege level prior to executing \"show\n\" commands. If you don't want this \"auto-magic\" you can use the base driver (nssh). The privileges for each device\nare outlined in named tuples in the platforms <code>driver.py</code> file.</p>\n<p>As an example, the following privilege levels are supported by the IOSXEDriver:</p>\n<ol>\n<li>\"exec\"</li>\n<li>\"privilege_exec\"</li>\n<li>\"configuration\"</li>\n<li>\"special_configuration\"</li>\n</ol>\n<p>Each privilege level has the following attributes:</p>\n<ul>\n<li>pattern: regex pattern to associate prompt to privilege level with</li>\n<li>name: name of the priv level, i.e. \"exec\"</li>\n<li>deescalate_priv: name of next lower privilege or None</li>\n<li>deescalate: command to deescalate to next lower privilege or None</li>\n<li>escalate: name of next higher privilege or None</li>\n<li>escalate_auth: command to escalate to next higher privilege or None</li>\n<li>escalate_prompt: False or pattern to expect for escalation -- i.e. \"Password:\"</li>\n<li>requestable: True/False if the privilege level is requestable</li>\n<li>level: integer value of level i.e. 1</li>\n</ul>\n<p>If you wish to manually enter a privilege level you can use the <code>acquire_priv</code> method, passing in the name of the\nprivilege level you would like to enter. In general you probably won't need this too often though as the driver\nshould handle much of this for you.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">acquire_priv</span><span class=\"p\">(</span><span class=\"s2\">\"configuration\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Sending Configurations</h2>\n<p>When using the native mode (<code>NSSH</code> object), sending configurations is no different than sending commands and is done via\nthe <code>send_inputs</code> method. You must manually ensure you are in the correct privilege/mode.</p>\n<p>When using any of the core drivers or the base <code>NetworkDriver</code>, you can send configurations via the <code>send_configs</code> method\nwhich will handle privilege escalation for you. As with the <code>send_commands</code> and <code>send_inputs</code> methods -- you can\nsend a single string or a list/tuple of strings.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_configs</span><span class=\"p\">((</span><span class=\"s2\">\"interface loopback123\"</span><span class=\"p\">,</span> <span class=\"s2\">\"description configured by nssh\"</span><span class=\"p\">))</span>\n</pre>\n<h2>TextFSM/NTC-Templates Integration</h2>\n<p>nssh supports parsing output with TextFSM. This of course requires installing TextFSM and having ntc-templates\nsomewhere on your system. When using a driver you can pass <code>textfsm=True</code> to the <code>send_commands</code> method to\nautomatically try to parse all output. Parsed/structured output is stored in the <code>Result</code> object in the\n<code>structured_result</code> attribute. Alternatively you can use the <code>textfsm_parse_output</code> method of the driver to parse\noutput in a more manual fashion. This method accepts the string command (channel_input) and the text result and\nreturns structured data; the driver is already configured with the ntc-templates device type to find the correct\ntemplate.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">,</span> <span class=\"n\">textfsm</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">structured_result</span><span class=\"p\">)</span>\n    <span class=\"c1\"># or parse manually...</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">structured_output</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">textfsm_parse_output</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">,</span> <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>nssh also supports passing in templates manually (meaning not using the pip installed ntc-templates directory to\nfind templates) if desired. The <code>nssh.helper.textfsm_parse</code> function accepts a string or loaded (TextIOWrapper\n) template and output to parse. This can be useful if you have custom or one off templates or don't want to pip\ninstall ntc-templates.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n<span class=\"kn\">from</span> <span class=\"nn\">nssh.helper</span> <span class=\"kn\">import</span> <span class=\"n\">textfsm_parse</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">structured_result</span> <span class=\"o\">=</span> <span class=\"n\">textfsm_parse</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/my/template\"</span><span class=\"p\">,</span> <span class=\"n\">results</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p><em>NOTE</em>: If a template does not return structured data an empty dict will be returned!</p>\n<h2>Timeouts</h2>\n<p>nssh supports several timeout options. The simplest is the <code>timeout_socket</code> which controls the timeout for... setting\nup the underlying socket in seconds. Value should be a positive, non-zero number, however ssh2 and paramiko\ntransport options support floats.</p>\n<p><code>timeout_ssh</code> sets the timeout for the actual SSH session when using ssh2 or paramiko transport options. When using\nsystem SSH, this is currently only used as the timeout timer for authentication.</p>\n<p>Finally, <code>timeout_ops</code> sets a timeout value for individual operations -- or put another way, the timeout for each\nsend_input operation.</p>\n<h2>Disabling Paging</h2>\n<p>nssh native driver attempts to send <code>terminal length 0</code> to disable paging by default. In the future this will\nlikely be removed and relegated to the device drivers only. For all drivers, there is a standard disable paging\nstring already configured for you, however this is of course user configurable. In addition to passing a string to\nsend to disable paging, nssh supports passing a callable. This callable should accept the drivers reference to\nself as the only argument. This allows for users to create a custom function to disable paging however they like\n. This callable option is supported on the native driver as well. In general it is probably a better idea to\nhandle this by simply passing a string, but the goal is to be flexible so the callable is supported.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">iosxe_disable_paging</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n    <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">(</span><span class=\"s2\">\"term length 0\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span> <span class=\"s2\">\"session_disable_paging\"</span><span class=\"p\">:</span> <span class=\"n\">iosxe_disable_paging</span><span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">get_prompt</span><span class=\"p\">())</span>\n</pre>\n<h2>Login Handlers</h2>\n<p>Some devices have additional prompts or banners at login. This generally causes issues for SSH screen scraping\nautomation. nssh supports -- just like disable paging -- passing a string to send or a callable to execute after\nsuccessful SSH connection but before disabling paging occurs. By default this is an empty string which does nothing.</p>\n<h2>SSH Config Support</h2>\n<p>nssh supports using OpenSSH configuration files in a few ways. For \"system\" SSH driver, passing a path to a config\nfile will simply make nssh \"point\" to that file, and therefore use that configuration files attributes (because it\nis just exec'ing system SSH!). Soon SSH support that exists in ssh2net will be ported over to nssh for ssh2-python\nand paramiko transport drivers.</p>\n<p><em>NOTE</em> -- when using the system (default) SSH transport driver nssh does NOT disable strict host checking by default\n. Obviously this is the \"smart\" behavior, but it can be overridden on a per host basis in your SSH config file, or by\npassing <code>False</code> to the \"auth_strict_key\" argument on object instantiation.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nssh.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span> <span class=\"s2\">\"ssh_config_file\"</span><span class=\"p\">:</span> <span class=\"s2\">\"~/mysshconfig\"</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">get_prompt</span><span class=\"p\">())</span>\n</pre>\n<h1>FAQ</h1>\n<ul>\n<li>Question: Why build this? Netmiko exists, Paramiko exists, Ansible exists, etc...?\n<ul>\n<li>Answer: I built ssh2net to learn -- to have a goal/target for writing some code. nssh is an evolution of the\nlessons learned building ssh2net. About mid-way through building ssh2net I realized it may actually be kinda good\nat doing... stuff. So, sure there are other tools out there, but I think nssh its pretty snazzy and fills in some\nof the gaps in other tools. For example nssh is 100% compliant with strict mypy type checking, very uniformly\ndocumented/linted, contains a results object for every operation, is very very fast, is very flexible, and in\ngeneral pretty awesome! Finally, while I think in general that SSH \"screen scraping\" is not \"sexy\" or even\n\"good\", it is the lowest common denominator for automation in the networking world. So I figured I could try\nto make the fastest, most flexible library around for SSH network automation!</li>\n</ul>\n</li>\n<li>Question: Is this better than Netmiko/Paramiko/Ansible?\n<ul>\n<li>Answer: Nope! It is different though! The main focus is just to be stupid fast. It is very much that. It <em>should</em> be\nsuper reliable too as the timeouts are very easy/obvious to control, and it should also be very very very easy to\nadapt to any other network-y type CLI.</li>\n</ul>\n</li>\n<li>Question: Is this easy to use?\n<ul>\n<li>Answer: Yep! The \"native\" usage is pretty straight forward -- the thing to remember is that it doesn't do \"things\n\" for you like Netmiko does for example, so its a lot more like Paramiko in that regard. That said you can use one\nof the available drivers to have a more Netmiko-like experience -OR- write your own driver as this has been built\nwith the thought of being easily extended.</li>\n</ul>\n</li>\n<li>Why do I get a \"conn (or your object name here) has no attribute channel\" exception when using the base <code>NSSH</code> or\n<code>NetworkDriver</code> objects?\n<ul>\n<li>Answer: Those objects do not \"auto open\", and the channel attribute is not assigned until opening the connection\n. Call <code>conn.open()</code> (or your object name in place of conn) to open the session and assign the channel attribute.</li>\n</ul>\n</li>\n<li>Other questions? Ask away!</li>\n</ul>\n<h1>Known Issues</h1>\n<h2>SSH2-Python</h2>\n<ul>\n<li>\n<p>Arista EOS uses keyboard interactive authentication which is currently broken in the pip-installable version\nof ssh2-python (as of January 2020). GitHub user <a href=\"https://github.com/Red-M\" rel=\"nofollow\">Red-M</a> has contributed to and fixed this\nparticular issue but the fix has not been merged. If you would like to use ssh2-python with EOS I suggest cloning\nand installing via Red-M's repository or my fork of Red-M's fork!</p>\n</li>\n<li>\n<p>Use the context manager where possible! More testing needs to be done to confirm/troubleshoot, but limited testing\nseems to indicate that without properly closing the connection there appears to be a bug that causes Python to crash\non MacOS at least. More to come on this as I have time to poke it more! I believe this is only occurring on the\nlatest branch/update (i.e. not on the pip installable version).</p>\n</li>\n</ul>\n<h1>Linting and Testing</h1>\n<p><em>NOTE</em> Currently there are no unit/functional tests for IOSXR/NXOS/EOS/Junos, however as this part of nssh is largely\na port of ssh2net, they should work :)</p>\n<h2>Linting</h2>\n<p>This project uses <a href=\"https://github.com/psf/black\" rel=\"nofollow\">black</a> for auto-formatting. In addition to black, tox will execute\n<a href=\"https://github.com/klen/pylama\" rel=\"nofollow\">pylama</a>, and <a href=\"https://github.com/PyCQA/pydocstyle\" rel=\"nofollow\">pydocstyle</a> for linting purposes\n. Tox will also run  <a href=\"https://github.com/python/mypy\" rel=\"nofollow\">mypy</a>, with strict type checking. Docstring linting with\n<a href=\"https://github.com/terrencepreilly/darglint\" rel=\"nofollow\">darglint</a> which has been quite handy!</p>\n<p>All commits to this repository will trigger a GitHub action which runs tox, but of course its nicer to just run that\nbefore making a commit to ensure that it will pass all tests!</p>\n<h3>Typing</h3>\n<p>As stated, this project is 100% type checked and will remain that way. The value this adds for IDE auto-completion\nand just general sanity checking/forcing writing of more type-check-able code is worth the small overhead in effort.</p>\n<h2>Testing</h2>\n<p>I broke testing into two main categories -- unit and functional. Unit is what you would expect -- unit testing the code.\nFunctional testing connects to virtual devices in order to more accurately test the code. Unit tests cover quite a\nbit of the code base due to mocking the FileIO that the channel reads/writes to. This gives a pretty high level of\nconfidence that at least object instantiation and channel read/writes will generally work... Functional tests\nagainst virtual devices helps reinforce that and gets coverage for the transport classes.</p>\n<h3>Unit Tests</h3>\n<p>Unit tests can be executed via pytest:</p>\n<pre><code>python -m pytest tests/unit/\n</code></pre>\n<p>Or using the following make command:</p>\n<pre><code>make test_unit\n</code></pre>\n<p>If you would like to see the coverage report and generate the html coverage report:</p>\n<pre><code>make cov_unit\n</code></pre>\n<h3>Setting up Functional Test Environment</h3>\n<p>Executing the functional tests is a bit more complicated! First, thank you to Kristian Larsson for his great tool <a href=\"https://github.com/plajjan/vrnetlab\" rel=\"nofollow\">vrnetlab</a>! All functional tests are built on this awesome platform that allows for easy creation of containerized network devices.</p>\n<p>Basic functional tests exist for all \"core\" platform types (IOSXE, NXOS, IOSXR, EOS, Junos). Vrnetlab currently only supports the older emulation style NX-OS devices, and <em>not</em> the newer VM image n9kv. I have made some very minor tweaks to vrnetlab locally in order to get the n9kv image running -- I have raised a PR to add this to vrnetlab proper. Minus the n9kv tweaks, getting going with vrnetlab is fairly straightforward -- simply follow Kristian's great readme docs. For the Arista EOS image -- prior to creating the container you should boot the device and enter the <code>zerotouch disable</code> command. This allows for the config to actually be saved and prevents the interfaces from cycling through interface types in the container (I'm not clear why it does that but executing this command before building the container \"fixes\" this!). After creating the image(s) that you wish to test, rename the image to the following format:</p>\n<pre><code>nssh[PLATFORM]\n</code></pre>\n<p>The docker-compose file here will be looking for the container images matching this pattern, so this is an important bit! The container image names should be:</p>\n<pre><code>nsshciscoiosxe\nnsshcisconxos\nnsshciscoiosxr\nnsshciscojunos\n</code></pre>\n<p>You can tag the image names on creation (following the vrnetlab readme docs), or create a new tag once the image is built:</p>\n<pre><code>docker tag [TAG OF IMAGE CREATED] nssh[VENDOR][OS]\n</code></pre>\n<p><em>NOTE</em> I have added vty lines 5-98 on the CSR image -- I think the connections opening/closing so quickly during\ntesting caused them to get hung. Testing things more slowly (adding time.sleep after closing connections) fixed this\nbut that obviously made the testing time longer, so this seemed like a better fix. This change will be in my fork\nof vrnetlab or you can simply modify the <code>line vty 0 5</code> --&gt; <code>line vty 0 98</code> in the <code>luanch.py</code> for the CSR in your\nvrnetlab clone.</p>\n<h3>Functional Tests</h3>\n<p>Once you have created the images, you can start the containers with a make command:</p>\n<pre><code>make start_dev_env\n</code></pre>\n<p>Conversely you can terminate the containers:</p>\n<pre><code>make stop_dev_env\n</code></pre>\n<p>To start a specific platform container:</p>\n<pre><code>make start_dev_env_iosxe\n</code></pre>\n<p>Substitute \"iosxe\" for the platform type you want to start.</p>\n<p>Most of the containers don't take too long to fire up, maybe a few minutes (running on my old macmini with Ubuntu, so not exactly a powerhouse!). That said, the IOS-XR device takes about 15 minutes to go to \"healthy\" status. Once booted up you can connect to their console or via SSH:</p>\n<table>\n<thead>\n<tr>\n<th>Device</th>\n<th>Local IP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>iosxe</td>\n<td>172.18.0.11</td>\n</tr>\n<tr>\n<td>nxos</td>\n<td>172.18.0.12</td>\n</tr>\n<tr>\n<td>iosxr</td>\n<td>172.18.0.13</td>\n</tr>\n<tr>\n<td>eos</td>\n<td>172.18.0.14</td>\n</tr>\n<tr>\n<td>junos</td>\n<td>172.18.0.15</td>\n</tr></tbody></table>\n<p>The console port for all devices is 5000, so to connect to the console of the iosxe device you can simply telnet to that port locally:</p>\n<pre><code>telnet 172.18.0.11 5000\n</code></pre>\n<p>Credentials for all devices use the default vrnetlab credentials:</p>\n<p>Username: <code>vrnetlab</code></p>\n<p>Password: <code>VR-netlab9</code></p>\n<p>Once the container(s) are ready, you can use the make commands to execute tests as needed:</p>\n<ul>\n<li><code>test</code> will execute all currently implemented functional tests as well as the unit tests</li>\n<li><code>test_functional</code> will execute all currently implemented functional tests</li>\n<li><code>test_iosxe</code> will execute all unit tests and iosxe functional tests</li>\n<li><code>test_nxos</code> will execute all unit tests and nxos functional tests</li>\n<li><code>test_iosxr</code> will execute all unit tests and iosxr functional tests</li>\n<li><code>test_eos</code> will execute all unit tests and eos functional tests</li>\n<li><code>test_junos</code> will execute all unit tests and junos functional tests</li>\n</ul>\n\n          </div>"}, "last_serial": 6560219, "releases": {"2020.2.1": [{"comment_text": "", "digests": {"md5": "7bcf2e81f58c9c85c99fcc959746780e", "sha256": "d73bf075d60756b95d92cefc215261aa8186f5c93bdb856fbd7300dcb17bf24c"}, "downloads": -1, "filename": "nssh-2020.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "7bcf2e81f58c9c85c99fcc959746780e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 63555, "upload_time": "2020-02-02T01:45:05", "upload_time_iso_8601": "2020-02-02T01:45:05.497044Z", "url": "https://files.pythonhosted.org/packages/c8/74/ac0f3913bd73aa63d00a61e7bc71edfe08ed908cb5c4b05a4d323ff6f481/nssh-2020.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e963e4e42447ca9d77bd9bbb703f4148", "sha256": "5a78d09cfae0c3f2bc2fba7f963d6a72815464588a808059cb204742565bbc7d"}, "downloads": -1, "filename": "nssh-2020.2.1.tar.gz", "has_sig": false, "md5_digest": "e963e4e42447ca9d77bd9bbb703f4148", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 65346, "upload_time": "2020-02-02T01:45:08", "upload_time_iso_8601": "2020-02-02T01:45:08.373736Z", "url": "https://files.pythonhosted.org/packages/94/c4/f363817c910dfee440a43d5cac0535d0f5721fb710515b3ce4daca23ad97/nssh-2020.2.1.tar.gz", "yanked": false}], "2020.2.2": [{"comment_text": "", "digests": {"md5": "fdea1fada8cc9cd6659a4e3296931847", "sha256": "e69ba4c1d8e3c6a78f25d2726bfead34eed376cff5c16ecb95d4781324adbdf5"}, "downloads": -1, "filename": "nssh-2020.2.2-py3-none-any.whl", "has_sig": false, "md5_digest": "fdea1fada8cc9cd6659a4e3296931847", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 77762, "upload_time": "2020-02-02T23:16:50", "upload_time_iso_8601": "2020-02-02T23:16:50.588453Z", "url": "https://files.pythonhosted.org/packages/f2/68/cae17de424268728346a40a8d36b08fdd011bda1598e9bf905f928ddce39/nssh-2020.2.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9972c90fd82d78a30a40dfda37872959", "sha256": "ed6f92ec68ea792f5ad35d7947f52c9dbb88b6a491405026523f465454730758"}, "downloads": -1, "filename": "nssh-2020.2.2.tar.gz", "has_sig": false, "md5_digest": "9972c90fd82d78a30a40dfda37872959", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 75252, "upload_time": "2020-02-02T23:16:52", "upload_time_iso_8601": "2020-02-02T23:16:52.003991Z", "url": "https://files.pythonhosted.org/packages/50/7d/3cc7624549332159a2ad2c3958223d1f097efaf8fe5ec70ef7d88cb6597b/nssh-2020.2.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fdea1fada8cc9cd6659a4e3296931847", "sha256": "e69ba4c1d8e3c6a78f25d2726bfead34eed376cff5c16ecb95d4781324adbdf5"}, "downloads": -1, "filename": "nssh-2020.2.2-py3-none-any.whl", "has_sig": false, "md5_digest": "fdea1fada8cc9cd6659a4e3296931847", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 77762, "upload_time": "2020-02-02T23:16:50", "upload_time_iso_8601": "2020-02-02T23:16:50.588453Z", "url": "https://files.pythonhosted.org/packages/f2/68/cae17de424268728346a40a8d36b08fdd011bda1598e9bf905f928ddce39/nssh-2020.2.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9972c90fd82d78a30a40dfda37872959", "sha256": "ed6f92ec68ea792f5ad35d7947f52c9dbb88b6a491405026523f465454730758"}, "downloads": -1, "filename": "nssh-2020.2.2.tar.gz", "has_sig": false, "md5_digest": "9972c90fd82d78a30a40dfda37872959", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 75252, "upload_time": "2020-02-02T23:16:52", "upload_time_iso_8601": "2020-02-02T23:16:52.003991Z", "url": "https://files.pythonhosted.org/packages/50/7d/3cc7624549332159a2ad2c3958223d1f097efaf8fe5ec70ef7d88cb6597b/nssh-2020.2.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:24 2020"}