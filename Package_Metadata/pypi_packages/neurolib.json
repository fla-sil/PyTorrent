{"info": {"author": "Caglar Cakan", "author_email": "cakan@ni.tu-berlin.de", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "<p align=\"center\">\n  <a href=\"https://travis-ci.org/neurolib-dev/neurolib\">\n  \t<img alt=\"Build\" src=\"https://travis-ci.org/neurolib-dev/neurolib.svg?branch=master\"></a>\n\n  <a href=\"https://www.python.org/downloads/release\">\n  \t<img alt=\"Python 3.6+\" src=\"https://img.shields.io/badge/python-3.6+-blue.svg\"></a>\n\n   <br> \n  <a href=\"https://github.com/neurolib-dev/neurolib/releases\">\n  \t<img alt=\"Release\" src=\"https://img.shields.io/github/v/release/neurolib-dev/neurolib\"></a>\n\n  <a href=\"https://pypi.org/project/neurolib/\">\n  \t<img alt=\"PyPI\" src=\"https://img.shields.io/pypi/v/neurolib\"></a>\n\n <a href=\"https://github.com/neurolib-dev/neurolib/commits/master\">\n  <img alt=\"GitHub commits since latest release (by date)\" src=\"https://img.shields.io/github/commits-since/neurolib-dev/neurolib/latest\"></a>\n\n  <a href=\"https://codecov.io/gh/neurolib-dev/neurolib\">\n  \t<img alt=\"codecov\" src=\"https://codecov.io/gh/neurolib-dev/neurolib/branch/master/graph/badge.svg\"></a>\n\n  <a href=\"https://pepy.tech/project/neurolib\">\n  \t<img alt=\"Downloads\" src=\"https://pepy.tech/badge/neurolib\"></a>\n\n  <a href=\"https://github.com/psf/black\">\n  \t<img alt=\"Code style: black\" src=\"https://img.shields.io/badge/code%20style-black-000000.svg\"></a>\n\n</p>\n\n# neurolib\n*Easy whole-brain neural mass modeling* \ud83d\udc69\u200d\ud83d\udd2c\ud83d\udcbb\ud83e\udde0\n\n`neurolib` allows you to build, simulate, and optimize your own state-of-the-art whole-brain models. To simulate the neural activity of each brain area, the main implementation provides an advanced neural mass mean-field model of spiking adaptive exponential integrate-and-fire neurons (AdEx) called `aln`. Each brain area is represented by two populations of excitatory and inhibitory neurons. An extensive analysis and validation of the `aln` model can be found in our [paper](https://arxiv.org/abs/1906.00676) and its associated [github page](https://github.com/caglarcakan/stimulus_neural_populations).\n\n`neurolib` provides a simulation and optimization framework which allows you to easily implement your own neural mass model, simulate fMRI BOLD activity, analyse the results and fit your model to empirical data.\n\nPlease reference the following paper if you use `neurolib` for your own research:\n\n**Reference:** Cakan, C., Obermayer, K. (2020). Biophysically grounded mean-field models of neural populations under electrical stimulation ([ArXiv](https://arxiv.org/abs/1906.00676)).\n\nThe figure below shows a schematic of how a brain network can be constructed:\n\n<p align=\"center\">\n  <img src=\"https://github.com/neurolib-dev/neurolib/raw/master/resources/pipeline.png\" width=\"700\">\n</p>\n\n<p align=\"center\">\nExamples:\n<a href=\"#single-node\">Single node simulation</a> \u00b7\n<a href=\"#whole-brain-network\">Whole-brain network</a> \u00b7\n<a href=\"#parameter-exploration\">Parameter exploration</a> \u00b7\n<a href=\"#evolutionary-optimization\">Evolutionary optimization</a>\n<br><br>    \n\n</p>\n\n## Whole-brain modeling\n\nTypically, in whole-brain modeling, diffusion tensor imaging (DTI) is used to infer the structural connectivity (the connection strength) between different brain areas. In a DTI scan, the direction of the diffusion of molecules is measured across the whole brain. Using [tractography](https://en.wikipedia.org/wiki/Tractography), this information can yield the distribution of axonal fibers in the brain that connect distant brain areas, called the connectome. Together with an atlas that divides the brain into distinct areas, a matrix can be computed that encodes how many fibers go from one area to another, the so-called structural connectivity (SC) matrix. This matrix defines the coupling strengths between brain areas and acts as an adjacency matrix of the brain network. The length of the fibers determine the signal transmission delay between all brain areas. When the structural data is combined with a computational model of the neuronal activity of the cortex, we can create a dynamical model of the whole brain.\n\nThe resulting whole-brain model consists of interconnected brain areas, with each brain area having their internal neural dynamics. The neural activity is used to simulate hemodynamic [BOLD](https://en.wikipedia.org/wiki/Blood-oxygen-level-dependent_imaging) activity using the Balloon-Windkessel model, which can be compared to empirical fMRI data. The simulated BOLD activity is used to compute correlations of activity between all brain areas, the so called [resting state functional connectivity](https://en.wikipedia.org/wiki/Resting_state_fMRI#Functional), which can then be fitted to empirical fMRI resting-state data.\n\n\nBelow is an animation of the neuronal activity of a whole-brain model plotted on a brain.\n\n<p align=\"center\">\n  <img src=\"https://github.com/neurolib-dev/neurolib/raw/master/resources/brain_slow_waves_small.gif\">\n</p>\n\n# Installation\nThe easiest way to get going is to install the pypi package using `pip`:\n\n```\npip install neurolib\n```\nAlternatively, you can also clone this repository and install all dependencies with\n\n```\ngit clone https://github.com/neurolib-dev/neurolib.git\ncd neurolib/\npip install -r requirements.txt\npip install .\n```\n\n# Examples\nExample [IPython Notebooks](examples/) on how to use the library can be found in the `./examples/` directory, don't forget to check them out! \n\nYou can run the examples hosted on [Binder](https://mybinder.org/) by clicking the links below:\n\n- [Example 0.0](https://mybinder.org/v2/gh/neurolib-dev/neurolib/master?filepath=examples%2Fexample-0-aln-minimal.ipynb) - Basic use of the `aln` model\n- [Example 0.3](https://mybinder.org/v2/gh/neurolib-dev/neurolib/master?filepath=examples%2Fexample-0.3-fhn-minimal.ipynb) - Fitz-Hugh Nagumo model `fhn` on a brain network\n- [Example 1.2](https://mybinder.org/v2/gh/neurolib-dev/neurolib/master?filepath=examples%2Fexample-1.2-brain-network-exploration.ipynb) - Parameter exploration of a brain network and fitting to BOLD data\n- [Example 2.0](https://mybinder.org/v2/gh/neurolib-dev/neurolib/master?filepath=examples%2Fexample-2-evolutionary-optimization-minimal.ipynb) - A simple example of the evolutionary optimization framework \n\nA basic overview of the functionality that `neurolib` provides is also given here. \n\n## Single node\n\nThis example is available in detail as a [IPython Notebook](examples/example-0-aln-minimal.ipynb). \n\nTo create a single `aln` model with the default parameters, simply run\n\n```python\nfrom neurolib.models.aln import ALNModel\n\naln = ALNModel()\naln.params['sigma_ou'] = 0.1 # add some noise\n\naln.run()\n```\n\nThe results from this small simulation can be plotted easily:\n\n```python\nimport matplotlib.pyplot as plt\nplt.plot(aln.t, aln.rates_exc.T)\n\n```\n<p align=\"left\">\n  <img src=\"https://github.com/neurolib-dev/neurolib/raw/master/resources/single_timeseries.png\">\n</p>\n\n## Whole-brain network\n\nA detailed example is available as a [IPython Notebook](examples/example-0-aln-minimal.ipynb). \n\nTo simulate a whole-brain network model, first we need to load a DTI and a resting-state fMRI dataset. `neurolib` already provides some example data for you:\n\n```python\nfrom neurolib.utils.loadData import Dataset\n\nds = Dataset(\"gw\")\n```\nThe dataset that we just loaded, looks like this:\n\n<p align=\"center\">\n  <img src=\"https://github.com/neurolib-dev/neurolib/raw/master/resources/gw_data.png\">\n</p>\n\nWe initialize a model with the dataset and run it:\n\n```python\naln = ALNModel(Cmat = ds.Cmat, Dmat = ds.Dmat)\naln.params['duration'] = 5*60*1000 # in ms, simulates for 5 minutes\n\naln.run(bold=True)\n```\nThis can take several minutes to compute, since we are simulating 82 nodes for 5 minutes realtime. Note that we specified `bold=True` which simulates the BOLD model in parallel to the neuronal model. The resulting firing rates and BOLD functional connectivity looks like this:\n<p align=\"center\">\n  <img src=\"https://github.com/neurolib-dev/neurolib/raw/master/resources/gw_simulated.png\">\n</p>\n\nThe quality of the fit of this simulation can be computed by correlating the simulated functional connectivity matrix above to the empirical resting-state functional connectivity for each subject of the dataset. This gives us an estimate of how well the model reproduces inter-areal BOLD correlations. As a rule of thumb, a value above 0.5 is considered good. \n\nWe can compute the quality of the fit of the simulated data using `func.fc()` which calculates a functional connectivity matrix of `N` (`N` = number of brain regions) time series. We use `func.matrix_correlation()` to compare this matrix to empirical data.\n\n```python\nscores = [func.matrix_correlation(func.fc(aln.BOLD.BOLD[:, 5:]), fcemp) for fcemp in ds.FCs]\n\nprint(\"Correlation per subject:\", [f\"{s:.2}\" for s in scores])\nprint(f\"Mean FC/FC correlation: {np.mean(scores):.2}\")\n```\n```\nCorrelation per subject: ['0.34', '0.61', '0.54', '0.7', '0.54', '0.64', '0.69', '0.47', '0.59', '0.72', '0.58']\nMean FC/FC correlation: 0.58\n```\n## Parameter exploration\nA detailed example of a single-node exploration is available as a [IPython Notebook](examples/example-1-aln-parameter-exploration.ipynb). For an example of a brain network exploration, see [this Notebook](examples/example-1.2-brain-network-exploration.ipynb).\n\nWhenever you work with a model, it is of great importance to know what kind of dynamics it exhibits given a certain set of parameters. It is often useful to get an overview of the state space of a given model of interest. For example in the case of `aln`, the dynamics depends a lot on the mean inputs to the excitatory and the inhibitory population. `neurolib` makes it very easy to quickly explore parameter spaces of a given model:\n\n```python\n# create model\naln = ALNModel()\n# define the parameter space to explore\nparameters = ParameterSpace({\"mue_ext_mean\": np.linspace(0, 3, 21),  # input to E\n\t\t\"mui_ext_mean\": np.linspace(0, 3, 21)}) # input to I\n\n# define exploration              \nsearch = BoxSearch(aln, parameters)\n\nsearch.run()                \n```\nThat's it!. You can now use the builtin functions to load the simulation results from disk and perform your analysis:\n\n```python\nsearch.loadResults()\n\n# calculate maximum firing rate for each parameter\nfor i in search.dfResults.index:\n    search.dfResults.loc[i, 'max_r'] = np.max(search.results[i]['rates_exc'][:, -int(1000/aln.params['dt']):])\n```\nWe can plot the results to get something close to a bifurcation diagram!\n\n<p align=\"center\">\n  <img src=\"https://github.com/neurolib-dev/neurolib/raw/master/resources/exploration_aln.png\">\n</p>\n\n## Evolutionary optimization\n\nA detailed example is available as a [IPython Notebook](examples/example-2-evolutionary-optimization-minimal.ipynb). \n\n`neurolib` also implements evolutionary parameter optimization, which works particularly well with brain networks. In an evolutionary algorithm, each simulation is represented as an individual and the parameters of the simulation, for example coupling strengths or noise level values, are represented as the genes of each individual. An individual is a part of a population. In each generation, individuals are evaluated and ranked according to a fitness criterion. For whole-brain network simulations, this could be the fit of the simulated activity to empirical data. Then, individuals with a high fitness value are `selected` as parents and `mate` to create offspring. These offspring undergo random `mutations` of their genes. After all offspring are evaluated, the best individuals of the population are selected to transition into the next generation. This process goes on for a given amount generations until a stopping criterion is reached. This could be a predefined maximum number of generations or when a large enough population with high fitness values is found.\n\n<p align=\"center\">\n  <img src=\"https://github.com/neurolib-dev/neurolib/raw/master/resources/evolutionary-algorithm.png\", width=\"600\">\n</p>\n\n`neurolib` makes it very easy to set up your own evolutionary optimization and everything else is handled under the hood. Of course, if you like, you can dig deeper, define your own selection, mutation and mating operators. In the following demonstration, we will simply evaluate the fitness of each individual as the distance to the unit circle. After a couple of generations of mating, mutating and selecting, only individuals who are close to the circle should survive:\n\n```python\nfrom neurolib.utils.parameterSpace import ParameterSpace\nfrom neurolib.optimize.evolution import Evolution\n\ndef optimize_me(traj):\n    ind = evolution.getIndividualFromTraj(traj)\n\n    # let's make a circle\n    fitness_result = abs((ind.x**2 + ind.y**2) - 1)\n\n    # gather results\n    fitness_tuple = (fitness_result ,)\n    result_dict = {\"result\" : [fitness_result]}\n\n    return fitness_tuple, result_dict\n\n# we define a parameter space and its boundaries\npars = ParameterSpace(['x', 'y'], [[-5.0, 5.0], [-5.0, 5.0]])\n\n# initialize the evolution and go\nevolution = Evolution(optimize_me, pars, weightList = [-1.0], POP_INIT_SIZE= 100, POP_SIZE = 50, NGEN=10)\nevolution.run()    \n```\n\nThat's it! Now we can check the results:\n\n```python\nevolution.loadResults()\nevolution.info(plot=True)\n```\n\nThis will gives us a summary of the last generation and plots a distribution of the individuals (and their parameters). Below is an animation of 10 generations of the evolutionary process. As you can see, after a couple of generations, all remaining individuals lie very close to the unit circle.\n\n<p align=\"center\">\n  <img src=\"https://github.com/neurolib-dev/neurolib/raw/master/resources/evolution_animated.gif\">\n</p>\n\n## More information\n\n### Built With\n\n`neurolib` is built on other amazing open source projects:\n\n* [pypet](https://github.com/SmokinCaterpillar/pypet) - Python parameter exploration toolbox\n* [deap](https://github.com/DEAP/deap) - Distributed Evolutionary Algorithms in Python\n* [numpy](https://github.com/numpy/numpy) - The fundamental package for scientific computing with Python\n* [numba](https://github.com/numba/numba) - NumPy aware dynamic Python compiler using LLVM\n* [Jupyter](https://github.com/jupyter/notebook) - Jupyter Interactive Notebook\n\n### Get in touch\n\nCaglar Cakan (cakan@ni.tu-berlin.de)  \nDepartment of Software Engineering and Theoretical Computer Science, Technische Universit\u00e4t Berlin, Germany  \nBernstein Center for Computational Neuroscience Berlin, Germany  \n\n### Acknowledgments\nThis work was supported by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) with the project number 327654276 (SFB 1315) and the Research Training Group GRK1589/2.\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/neurolib-dev/neurolib", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "neurolib", "package_url": "https://pypi.org/project/neurolib/", "platform": "", "project_url": "https://pypi.org/project/neurolib/", "project_urls": {"Homepage": "https://github.com/neurolib-dev/neurolib"}, "release_url": "https://pypi.org/project/neurolib/0.5/", "requires_dist": ["h5py", "numba", "numpy", "scipy", "glob3", "xarray", "pandas", "tqdm", "pypet", "deap"], "requires_python": ">=3.6", "summary": "Easy whole-brain neural mass modeling", "version": "0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p align=\"center\">\n  <a href=\"https://travis-ci.org/neurolib-dev/neurolib\" rel=\"nofollow\">\n  \t<img alt=\"Build\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f22af6d43ca8316144e4c013b4aad47b382de709/68747470733a2f2f7472617669732d63692e6f72672f6e6575726f6c69622d6465762f6e6575726f6c69622e7376673f6272616e63683d6d6173746572\"></a>\n  <a href=\"https://www.python.org/downloads/release\" rel=\"nofollow\">\n  \t<img alt=\"Python 3.6+\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6a042d910c74fbce532a01da853019c164ef42a8/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e362b2d626c75652e737667\"></a>\n   <br> \n  <a href=\"https://github.com/neurolib-dev/neurolib/releases\" rel=\"nofollow\">\n  \t<img alt=\"Release\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8b495f34f36cc90897df1905c702bd53aef2b1b1/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f6e6575726f6c69622d6465762f6e6575726f6c6962\"></a>\n  <a href=\"https://pypi.org/project/neurolib/\" rel=\"nofollow\">\n  \t<img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2fb5ae06ff6ff75c8a25fd596a6677505f831e9d/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6e6575726f6c6962\"></a>\n <a href=\"https://github.com/neurolib-dev/neurolib/commits/master\" rel=\"nofollow\">\n  <img alt=\"GitHub commits since latest release (by date)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3ebb0da2e1f46d2fb5f5581a2e022177fa22bcad/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f636f6d6d6974732d73696e63652f6e6575726f6c69622d6465762f6e6575726f6c69622f6c6174657374\"></a>\n  <a href=\"https://codecov.io/gh/neurolib-dev/neurolib\" rel=\"nofollow\">\n  \t<img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5312f8838a84745a1557f5cf3ba83eb8da5d7b65/68747470733a2f2f636f6465636f762e696f2f67682f6e6575726f6c69622d6465762f6e6575726f6c69622f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n  <a href=\"https://pepy.tech/project/neurolib\" rel=\"nofollow\">\n  \t<img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/79e0aa68111b4945274a219dffa123a865b9e5b5/68747470733a2f2f706570792e746563682f62616467652f6e6575726f6c6962\"></a>\n  <a href=\"https://github.com/psf/black\" rel=\"nofollow\">\n  \t<img alt=\"Code style: black\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a>\n</p>\n<h1>neurolib</h1>\n<p><em>Easy whole-brain neural mass modeling</em> \ud83d\udc69\u200d\ud83d\udd2c\ud83d\udcbb\ud83e\udde0</p>\n<p><code>neurolib</code> allows you to build, simulate, and optimize your own state-of-the-art whole-brain models. To simulate the neural activity of each brain area, the main implementation provides an advanced neural mass mean-field model of spiking adaptive exponential integrate-and-fire neurons (AdEx) called <code>aln</code>. Each brain area is represented by two populations of excitatory and inhibitory neurons. An extensive analysis and validation of the <code>aln</code> model can be found in our <a href=\"https://arxiv.org/abs/1906.00676\" rel=\"nofollow\">paper</a> and its associated <a href=\"https://github.com/caglarcakan/stimulus_neural_populations\" rel=\"nofollow\">github page</a>.</p>\n<p><code>neurolib</code> provides a simulation and optimization framework which allows you to easily implement your own neural mass model, simulate fMRI BOLD activity, analyse the results and fit your model to empirical data.</p>\n<p>Please reference the following paper if you use <code>neurolib</code> for your own research:</p>\n<p><strong>Reference:</strong> Cakan, C., Obermayer, K. (2020). Biophysically grounded mean-field models of neural populations under electrical stimulation (<a href=\"https://arxiv.org/abs/1906.00676\" rel=\"nofollow\">ArXiv</a>).</p>\n<p>The figure below shows a schematic of how a brain network can be constructed:</p>\n<p align=\"center\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/70074a8de3ce54be2249e955c41b49c2001468f6/68747470733a2f2f6769746875622e636f6d2f6e6575726f6c69622d6465762f6e6575726f6c69622f7261772f6d61737465722f7265736f75726365732f706970656c696e652e706e67\" width=\"700\">\n</p>\n<p align=\"center\">\nExamples:\n<a href=\"#single-node\" rel=\"nofollow\">Single node simulation</a> \u00b7\n<a href=\"#whole-brain-network\" rel=\"nofollow\">Whole-brain network</a> \u00b7\n<a href=\"#parameter-exploration\" rel=\"nofollow\">Parameter exploration</a> \u00b7\n<a href=\"#evolutionary-optimization\" rel=\"nofollow\">Evolutionary optimization</a>\n<br><br>    \n</p>\n<h2>Whole-brain modeling</h2>\n<p>Typically, in whole-brain modeling, diffusion tensor imaging (DTI) is used to infer the structural connectivity (the connection strength) between different brain areas. In a DTI scan, the direction of the diffusion of molecules is measured across the whole brain. Using <a href=\"https://en.wikipedia.org/wiki/Tractography\" rel=\"nofollow\">tractography</a>, this information can yield the distribution of axonal fibers in the brain that connect distant brain areas, called the connectome. Together with an atlas that divides the brain into distinct areas, a matrix can be computed that encodes how many fibers go from one area to another, the so-called structural connectivity (SC) matrix. This matrix defines the coupling strengths between brain areas and acts as an adjacency matrix of the brain network. The length of the fibers determine the signal transmission delay between all brain areas. When the structural data is combined with a computational model of the neuronal activity of the cortex, we can create a dynamical model of the whole brain.</p>\n<p>The resulting whole-brain model consists of interconnected brain areas, with each brain area having their internal neural dynamics. The neural activity is used to simulate hemodynamic <a href=\"https://en.wikipedia.org/wiki/Blood-oxygen-level-dependent_imaging\" rel=\"nofollow\">BOLD</a> activity using the Balloon-Windkessel model, which can be compared to empirical fMRI data. The simulated BOLD activity is used to compute correlations of activity between all brain areas, the so called <a href=\"https://en.wikipedia.org/wiki/Resting_state_fMRI#Functional\" rel=\"nofollow\">resting state functional connectivity</a>, which can then be fitted to empirical fMRI resting-state data.</p>\n<p>Below is an animation of the neuronal activity of a whole-brain model plotted on a brain.</p>\n<p align=\"center\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a0bf2bb48064a7062d101fe8d3f9cf0af655cc7b/68747470733a2f2f6769746875622e636f6d2f6e6575726f6c69622d6465762f6e6575726f6c69622f7261772f6d61737465722f7265736f75726365732f627261696e5f736c6f775f77617665735f736d616c6c2e676966\">\n</p>\n<h1>Installation</h1>\n<p>The easiest way to get going is to install the pypi package using <code>pip</code>:</p>\n<pre><code>pip install neurolib\n</code></pre>\n<p>Alternatively, you can also clone this repository and install all dependencies with</p>\n<pre><code>git clone https://github.com/neurolib-dev/neurolib.git\ncd neurolib/\npip install -r requirements.txt\npip install .\n</code></pre>\n<h1>Examples</h1>\n<p>Example <a href=\"examples/\" rel=\"nofollow\">IPython Notebooks</a> on how to use the library can be found in the <code>./examples/</code> directory, don't forget to check them out!</p>\n<p>You can run the examples hosted on <a href=\"https://mybinder.org/\" rel=\"nofollow\">Binder</a> by clicking the links below:</p>\n<ul>\n<li><a href=\"https://mybinder.org/v2/gh/neurolib-dev/neurolib/master?filepath=examples%2Fexample-0-aln-minimal.ipynb\" rel=\"nofollow\">Example 0.0</a> - Basic use of the <code>aln</code> model</li>\n<li><a href=\"https://mybinder.org/v2/gh/neurolib-dev/neurolib/master?filepath=examples%2Fexample-0.3-fhn-minimal.ipynb\" rel=\"nofollow\">Example 0.3</a> - Fitz-Hugh Nagumo model <code>fhn</code> on a brain network</li>\n<li><a href=\"https://mybinder.org/v2/gh/neurolib-dev/neurolib/master?filepath=examples%2Fexample-1.2-brain-network-exploration.ipynb\" rel=\"nofollow\">Example 1.2</a> - Parameter exploration of a brain network and fitting to BOLD data</li>\n<li><a href=\"https://mybinder.org/v2/gh/neurolib-dev/neurolib/master?filepath=examples%2Fexample-2-evolutionary-optimization-minimal.ipynb\" rel=\"nofollow\">Example 2.0</a> - A simple example of the evolutionary optimization framework</li>\n</ul>\n<p>A basic overview of the functionality that <code>neurolib</code> provides is also given here.</p>\n<h2>Single node</h2>\n<p>This example is available in detail as a <a href=\"examples/example-0-aln-minimal.ipynb\" rel=\"nofollow\">IPython Notebook</a>.</p>\n<p>To create a single <code>aln</code> model with the default parameters, simply run</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">neurolib.models.aln</span> <span class=\"kn\">import</span> <span class=\"n\">ALNModel</span>\n\n<span class=\"n\">aln</span> <span class=\"o\">=</span> <span class=\"n\">ALNModel</span><span class=\"p\">()</span>\n<span class=\"n\">aln</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s1\">'sigma_ou'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span> <span class=\"c1\"># add some noise</span>\n\n<span class=\"n\">aln</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<p>The results from this small simulation can be plotted easily:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">aln</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">aln</span><span class=\"o\">.</span><span class=\"n\">rates_exc</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span>\n</pre>\n<p align=\"left\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/07da31b7ea1ed9ee569c5ba2a2bfa081921f50bb/68747470733a2f2f6769746875622e636f6d2f6e6575726f6c69622d6465762f6e6575726f6c69622f7261772f6d61737465722f7265736f75726365732f73696e676c655f74696d657365726965732e706e67\">\n</p>\n<h2>Whole-brain network</h2>\n<p>A detailed example is available as a <a href=\"examples/example-0-aln-minimal.ipynb\" rel=\"nofollow\">IPython Notebook</a>.</p>\n<p>To simulate a whole-brain network model, first we need to load a DTI and a resting-state fMRI dataset. <code>neurolib</code> already provides some example data for you:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">neurolib.utils.loadData</span> <span class=\"kn\">import</span> <span class=\"n\">Dataset</span>\n\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">Dataset</span><span class=\"p\">(</span><span class=\"s2\">\"gw\"</span><span class=\"p\">)</span>\n</pre>\n<p>The dataset that we just loaded, looks like this:</p>\n<p align=\"center\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/327cb40b706c677d1535b2b24c4033e7adbc0cb3/68747470733a2f2f6769746875622e636f6d2f6e6575726f6c69622d6465762f6e6575726f6c69622f7261772f6d61737465722f7265736f75726365732f67775f646174612e706e67\">\n</p>\n<p>We initialize a model with the dataset and run it:</p>\n<pre><span class=\"n\">aln</span> <span class=\"o\">=</span> <span class=\"n\">ALNModel</span><span class=\"p\">(</span><span class=\"n\">Cmat</span> <span class=\"o\">=</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">Cmat</span><span class=\"p\">,</span> <span class=\"n\">Dmat</span> <span class=\"o\">=</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">Dmat</span><span class=\"p\">)</span>\n<span class=\"n\">aln</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s1\">'duration'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"o\">*</span><span class=\"mi\">60</span><span class=\"o\">*</span><span class=\"mi\">1000</span> <span class=\"c1\"># in ms, simulates for 5 minutes</span>\n\n<span class=\"n\">aln</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">bold</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>This can take several minutes to compute, since we are simulating 82 nodes for 5 minutes realtime. Note that we specified <code>bold=True</code> which simulates the BOLD model in parallel to the neuronal model. The resulting firing rates and BOLD functional connectivity looks like this:</p>\n<p align=\"center\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/221cec0b98f7a40a1317d15d43c746fd2489d1c3/68747470733a2f2f6769746875622e636f6d2f6e6575726f6c69622d6465762f6e6575726f6c69622f7261772f6d61737465722f7265736f75726365732f67775f73696d756c617465642e706e67\">\n</p>\n<p>The quality of the fit of this simulation can be computed by correlating the simulated functional connectivity matrix above to the empirical resting-state functional connectivity for each subject of the dataset. This gives us an estimate of how well the model reproduces inter-areal BOLD correlations. As a rule of thumb, a value above 0.5 is considered good.</p>\n<p>We can compute the quality of the fit of the simulated data using <code>func.fc()</code> which calculates a functional connectivity matrix of <code>N</code> (<code>N</code> = number of brain regions) time series. We use <code>func.matrix_correlation()</code> to compare this matrix to empirical data.</p>\n<pre><span class=\"n\">scores</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">func</span><span class=\"o\">.</span><span class=\"n\">matrix_correlation</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"o\">.</span><span class=\"n\">fc</span><span class=\"p\">(</span><span class=\"n\">aln</span><span class=\"o\">.</span><span class=\"n\">BOLD</span><span class=\"o\">.</span><span class=\"n\">BOLD</span><span class=\"p\">[:,</span> <span class=\"mi\">5</span><span class=\"p\">:]),</span> <span class=\"n\">fcemp</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">fcemp</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">FCs</span><span class=\"p\">]</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Correlation per subject:\"</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"sa\">f</span><span class=\"s2\">\"</span><span class=\"si\">{</span><span class=\"n\">s</span><span class=\"si\">:</span><span class=\"s2\">.2</span><span class=\"si\">}</span><span class=\"s2\">\"</span> <span class=\"k\">for</span> <span class=\"n\">s</span> <span class=\"ow\">in</span> <span class=\"n\">scores</span><span class=\"p\">])</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Mean FC/FC correlation: </span><span class=\"si\">{</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">scores</span><span class=\"p\">)</span><span class=\"si\">:</span><span class=\"s2\">.2</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n</pre>\n<pre><code>Correlation per subject: ['0.34', '0.61', '0.54', '0.7', '0.54', '0.64', '0.69', '0.47', '0.59', '0.72', '0.58']\nMean FC/FC correlation: 0.58\n</code></pre>\n<h2>Parameter exploration</h2>\n<p>A detailed example of a single-node exploration is available as a <a href=\"examples/example-1-aln-parameter-exploration.ipynb\" rel=\"nofollow\">IPython Notebook</a>. For an example of a brain network exploration, see <a href=\"examples/example-1.2-brain-network-exploration.ipynb\" rel=\"nofollow\">this Notebook</a>.</p>\n<p>Whenever you work with a model, it is of great importance to know what kind of dynamics it exhibits given a certain set of parameters. It is often useful to get an overview of the state space of a given model of interest. For example in the case of <code>aln</code>, the dynamics depends a lot on the mean inputs to the excitatory and the inhibitory population. <code>neurolib</code> makes it very easy to quickly explore parameter spaces of a given model:</p>\n<pre><span class=\"c1\"># create model</span>\n<span class=\"n\">aln</span> <span class=\"o\">=</span> <span class=\"n\">ALNModel</span><span class=\"p\">()</span>\n<span class=\"c1\"># define the parameter space to explore</span>\n<span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"n\">ParameterSpace</span><span class=\"p\">({</span><span class=\"s2\">\"mue_ext_mean\"</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">21</span><span class=\"p\">),</span>  <span class=\"c1\"># input to E</span>\n\t\t<span class=\"s2\">\"mui_ext_mean\"</span><span class=\"p\">:</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">21</span><span class=\"p\">)})</span> <span class=\"c1\"># input to I</span>\n\n<span class=\"c1\"># define exploration              </span>\n<span class=\"n\">search</span> <span class=\"o\">=</span> <span class=\"n\">BoxSearch</span><span class=\"p\">(</span><span class=\"n\">aln</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n\n<span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>                \n</pre>\n<p>That's it!. You can now use the builtin functions to load the simulation results from disk and perform your analysis:</p>\n<pre><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">loadResults</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># calculate maximum firing rate for each parameter</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">dfResults</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">:</span>\n    <span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">dfResults</span><span class=\"o\">.</span><span class=\"n\">loc</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"s1\">'max_r'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">results</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"s1\">'rates_exc'</span><span class=\"p\">][:,</span> <span class=\"o\">-</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"o\">/</span><span class=\"n\">aln</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s1\">'dt'</span><span class=\"p\">]):])</span>\n</pre>\n<p>We can plot the results to get something close to a bifurcation diagram!</p>\n<p align=\"center\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7adaeaa8f4a6b03f7e66f2ac328aeb41c6d2eb1b/68747470733a2f2f6769746875622e636f6d2f6e6575726f6c69622d6465762f6e6575726f6c69622f7261772f6d61737465722f7265736f75726365732f6578706c6f726174696f6e5f616c6e2e706e67\">\n</p>\n<h2>Evolutionary optimization</h2>\n<p>A detailed example is available as a <a href=\"examples/example-2-evolutionary-optimization-minimal.ipynb\" rel=\"nofollow\">IPython Notebook</a>.</p>\n<p><code>neurolib</code> also implements evolutionary parameter optimization, which works particularly well with brain networks. In an evolutionary algorithm, each simulation is represented as an individual and the parameters of the simulation, for example coupling strengths or noise level values, are represented as the genes of each individual. An individual is a part of a population. In each generation, individuals are evaluated and ranked according to a fitness criterion. For whole-brain network simulations, this could be the fit of the simulated activity to empirical data. Then, individuals with a high fitness value are <code>selected</code> as parents and <code>mate</code> to create offspring. These offspring undergo random <code>mutations</code> of their genes. After all offspring are evaluated, the best individuals of the population are selected to transition into the next generation. This process goes on for a given amount generations until a stopping criterion is reached. This could be a predefined maximum number of generations or when a large enough population with high fitness values is found.</p>\n<p align=\"center\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ba79d9733f81b0343e88c909b44553dba9498992/68747470733a2f2f6769746875622e636f6d2f6e6575726f6c69622d6465762f6e6575726f6c69622f7261772f6d61737465722f7265736f75726365732f65766f6c7574696f6e6172792d616c676f726974686d2e706e67\" width=\"600\">\n</p>\n<p><code>neurolib</code> makes it very easy to set up your own evolutionary optimization and everything else is handled under the hood. Of course, if you like, you can dig deeper, define your own selection, mutation and mating operators. In the following demonstration, we will simply evaluate the fitness of each individual as the distance to the unit circle. After a couple of generations of mating, mutating and selecting, only individuals who are close to the circle should survive:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">neurolib.utils.parameterSpace</span> <span class=\"kn\">import</span> <span class=\"n\">ParameterSpace</span>\n<span class=\"kn\">from</span> <span class=\"nn\">neurolib.optimize.evolution</span> <span class=\"kn\">import</span> <span class=\"n\">Evolution</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">optimize_me</span><span class=\"p\">(</span><span class=\"n\">traj</span><span class=\"p\">):</span>\n    <span class=\"n\">ind</span> <span class=\"o\">=</span> <span class=\"n\">evolution</span><span class=\"o\">.</span><span class=\"n\">getIndividualFromTraj</span><span class=\"p\">(</span><span class=\"n\">traj</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># let's make a circle</span>\n    <span class=\"n\">fitness_result</span> <span class=\"o\">=</span> <span class=\"nb\">abs</span><span class=\"p\">((</span><span class=\"n\">ind</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">ind</span><span class=\"o\">.</span><span class=\"n\">y</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># gather results</span>\n    <span class=\"n\">fitness_tuple</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">fitness_result</span> <span class=\"p\">,)</span>\n    <span class=\"n\">result_dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"result\"</span> <span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">fitness_result</span><span class=\"p\">]}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">fitness_tuple</span><span class=\"p\">,</span> <span class=\"n\">result_dict</span>\n\n<span class=\"c1\"># we define a parameter space and its boundaries</span>\n<span class=\"n\">pars</span> <span class=\"o\">=</span> <span class=\"n\">ParameterSpace</span><span class=\"p\">([</span><span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">],</span> <span class=\"p\">[[</span><span class=\"o\">-</span><span class=\"mf\">5.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">5.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">]])</span>\n\n<span class=\"c1\"># initialize the evolution and go</span>\n<span class=\"n\">evolution</span> <span class=\"o\">=</span> <span class=\"n\">Evolution</span><span class=\"p\">(</span><span class=\"n\">optimize_me</span><span class=\"p\">,</span> <span class=\"n\">pars</span><span class=\"p\">,</span> <span class=\"n\">weightList</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">],</span> <span class=\"n\">POP_INIT_SIZE</span><span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">POP_SIZE</span> <span class=\"o\">=</span> <span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"n\">NGEN</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">evolution</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>    \n</pre>\n<p>That's it! Now we can check the results:</p>\n<pre><span class=\"n\">evolution</span><span class=\"o\">.</span><span class=\"n\">loadResults</span><span class=\"p\">()</span>\n<span class=\"n\">evolution</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"n\">plot</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>This will gives us a summary of the last generation and plots a distribution of the individuals (and their parameters). Below is an animation of 10 generations of the evolutionary process. As you can see, after a couple of generations, all remaining individuals lie very close to the unit circle.</p>\n<p align=\"center\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7b157b810696612919b11c2e321446ffb5a95547/68747470733a2f2f6769746875622e636f6d2f6e6575726f6c69622d6465762f6e6575726f6c69622f7261772f6d61737465722f7265736f75726365732f65766f6c7574696f6e5f616e696d617465642e676966\">\n</p>\n<h2>More information</h2>\n<h3>Built With</h3>\n<p><code>neurolib</code> is built on other amazing open source projects:</p>\n<ul>\n<li><a href=\"https://github.com/SmokinCaterpillar/pypet\" rel=\"nofollow\">pypet</a> - Python parameter exploration toolbox</li>\n<li><a href=\"https://github.com/DEAP/deap\" rel=\"nofollow\">deap</a> - Distributed Evolutionary Algorithms in Python</li>\n<li><a href=\"https://github.com/numpy/numpy\" rel=\"nofollow\">numpy</a> - The fundamental package for scientific computing with Python</li>\n<li><a href=\"https://github.com/numba/numba\" rel=\"nofollow\">numba</a> - NumPy aware dynamic Python compiler using LLVM</li>\n<li><a href=\"https://github.com/jupyter/notebook\" rel=\"nofollow\">Jupyter</a> - Jupyter Interactive Notebook</li>\n</ul>\n<h3>Get in touch</h3>\n<p>Caglar Cakan (<a href=\"mailto:cakan@ni.tu-berlin.de\">cakan@ni.tu-berlin.de</a>)<br>\nDepartment of Software Engineering and Theoretical Computer Science, Technische Universit\u00e4t Berlin, Germany<br>\nBernstein Center for Computational Neuroscience Berlin, Germany</p>\n<h3>Acknowledgments</h3>\n<p>This work was supported by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) with the project number 327654276 (SFB 1315) and the Research Training Group GRK1589/2.</p>\n\n          </div>"}, "last_serial": 6980303, "releases": {"0.1.2": [{"comment_text": "", "digests": {"md5": "2620d3f5829ab0a380f322e6e55d63e2", "sha256": "c7d4765c649da64838b4cbe334186d0c3518340f31b0ce090f1cfd749893545d"}, "downloads": -1, "filename": "neurolib-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "2620d3f5829ab0a380f322e6e55d63e2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 3345846, "upload_time": "2020-01-26T12:26:56", "upload_time_iso_8601": "2020-01-26T12:26:56.254023Z", "url": "https://files.pythonhosted.org/packages/6e/a2/98ab43de37159767ace51122f48d5b113de2214912af5f47575ee4003d49/neurolib-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5fa59ca0f25ef62e84a09b9ddee8e3ac", "sha256": "0115b5e918348e79cdc7e8547d4d0b180295fdb283ac586591f009bf0f2466bf"}, "downloads": -1, "filename": "neurolib-0.1.2.tar.gz", "has_sig": false, "md5_digest": "5fa59ca0f25ef62e84a09b9ddee8e3ac", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 3328694, "upload_time": "2020-01-26T12:27:03", "upload_time_iso_8601": "2020-01-26T12:27:03.954017Z", "url": "https://files.pythonhosted.org/packages/1b/3f/eaee066cd635ee0de4d35f447c195ee6ac7fdc337d6f36c41da2a006a47a/neurolib-0.1.2.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "6cc05e6f58c03c2117b25de27fb0ec7a", "sha256": "8d1d45023b4b86cf56225d8a9075bec3215c7f4e4973799c45f60774cb553b34"}, "downloads": -1, "filename": "neurolib-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "6cc05e6f58c03c2117b25de27fb0ec7a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4924524, "upload_time": "2020-02-03T02:57:40", "upload_time_iso_8601": "2020-02-03T02:57:40.225250Z", "url": "https://files.pythonhosted.org/packages/3e/28/6263903dbe4f7b2b6d17d0c95ea2c84ffba56ffd1dc28f7cd9cfe13b0e2f/neurolib-0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8edee5f4fbfb9ccc887fbddf1b8c1473", "sha256": "fa5b080226e7cb4205a070d7a4496aef50d00e170a0d4d658ed3d3f7cb292756"}, "downloads": -1, "filename": "neurolib-0.2.tar.gz", "has_sig": false, "md5_digest": "8edee5f4fbfb9ccc887fbddf1b8c1473", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4916154, "upload_time": "2020-02-03T02:57:51", "upload_time_iso_8601": "2020-02-03T02:57:51.172295Z", "url": "https://files.pythonhosted.org/packages/c9/da/03175b3ef7542e19ff51d843597e769ff08e90ab42c127b8b510a0e38b3e/neurolib-0.2.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "6c29302fe0b71b39591910e3c007eff9", "sha256": "3e4962581fa4ae63c02306095c6971a8c2e66ff4d271e61536ccec80012050fb"}, "downloads": -1, "filename": "neurolib-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "6c29302fe0b71b39591910e3c007eff9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4922412, "upload_time": "2020-02-04T08:13:34", "upload_time_iso_8601": "2020-02-04T08:13:34.755641Z", "url": "https://files.pythonhosted.org/packages/4f/b5/22e3a71e5cd492158a7a4fa541a28acbaf43954322d7784738c5ce329afc/neurolib-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "be89615c3da7465130447b354f3bc493", "sha256": "a9a8bfccdec753e0663b25ed0d0f0c013ac2f63be05bdd0580256b95fb7a05c4"}, "downloads": -1, "filename": "neurolib-0.2.1.tar.gz", "has_sig": false, "md5_digest": "be89615c3da7465130447b354f3bc493", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4917235, "upload_time": "2020-02-04T08:13:47", "upload_time_iso_8601": "2020-02-04T08:13:47.174777Z", "url": "https://files.pythonhosted.org/packages/9b/f7/1e72cd8006949697d3efc77e3c935d91e31302ff703c9fe7abb912209c20/neurolib-0.2.1.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "54c2933446411196725a5b1dd4d7ad72", "sha256": "13e73084bc2ea51335f38c1265929684f65c32c7a48e5134276bc232b69932f1"}, "downloads": -1, "filename": "neurolib-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "54c2933446411196725a5b1dd4d7ad72", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4936374, "upload_time": "2020-02-13T12:54:12", "upload_time_iso_8601": "2020-02-13T12:54:12.717352Z", "url": "https://files.pythonhosted.org/packages/82/2d/e05d6530b302c8d923b4d7d60c910adc40a9b24ebee485f04c777f453337/neurolib-0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "421a7db47c093998dae277664983e1b9", "sha256": "fc0d542941181c64f8aee9fc38db833f6cb4b1176868d6e7d00f67e69cad28dc"}, "downloads": -1, "filename": "neurolib-0.3.tar.gz", "has_sig": false, "md5_digest": "421a7db47c093998dae277664983e1b9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4930885, "upload_time": "2020-02-13T12:54:15", "upload_time_iso_8601": "2020-02-13T12:54:15.699166Z", "url": "https://files.pythonhosted.org/packages/4a/ca/404c0ec5e0a31cfab2d5978c159b11fe70b17c37e99ae60cd3953b13698c/neurolib-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "6338b0dbd946080da81aa2c268f1bde8", "sha256": "925349769aa4f695dab45057fa0dbe9e433f031c7783f2519c9ffa443735edf8"}, "downloads": -1, "filename": "neurolib-0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "6338b0dbd946080da81aa2c268f1bde8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 8219180, "upload_time": "2020-02-26T14:03:41", "upload_time_iso_8601": "2020-02-26T14:03:41.076157Z", "url": "https://files.pythonhosted.org/packages/e0/79/b510734d815dfb8b695374b07f36fe8f60a064b830a0b215c032840316ae/neurolib-0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a517048ac2d3847137de85e6e8a7149e", "sha256": "1d095564a62fb38ab5c45b0cd3282b9bb46b48f741ea5d3a2cf388cf483ed566"}, "downloads": -1, "filename": "neurolib-0.4.tar.gz", "has_sig": false, "md5_digest": "a517048ac2d3847137de85e6e8a7149e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 8209427, "upload_time": "2020-02-26T14:03:44", "upload_time_iso_8601": "2020-02-26T14:03:44.582779Z", "url": "https://files.pythonhosted.org/packages/2e/9c/60dc16a83e52bae7aa252259926f000d0e9fb77ed1265cb46b028a726464/neurolib-0.4.tar.gz", "yanked": false}], "0.4.1": [{"comment_text": "", "digests": {"md5": "9647628debe2b514eae80f99136ea126", "sha256": "e8ff0b6fe518c457eff600fd82c30768a1fb603740487880ed1936494b65f3c2"}, "downloads": -1, "filename": "neurolib-0.4.1-py3-none-any.whl", "has_sig": false, "md5_digest": "9647628debe2b514eae80f99136ea126", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 8225865, "upload_time": "2020-03-11T10:46:16", "upload_time_iso_8601": "2020-03-11T10:46:16.402204Z", "url": "https://files.pythonhosted.org/packages/0f/c8/d1f6e47c289b838ef6fa64bd2272c967354827d1269c7864a7ea193ede92/neurolib-0.4.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "247d4c86f08089fbb4f2be1eb69b67d0", "sha256": "d42bbfec359818878386fbf8edce8f311a9770fb94cc9078662039f6291ded6a"}, "downloads": -1, "filename": "neurolib-0.4.1.tar.gz", "has_sig": false, "md5_digest": "247d4c86f08089fbb4f2be1eb69b67d0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 8214878, "upload_time": "2020-03-11T10:46:19", "upload_time_iso_8601": "2020-03-11T10:46:19.844430Z", "url": "https://files.pythonhosted.org/packages/74/b1/464a1639010b501ecd162fd1349184ae5e99d4343e75d91e6b54cd85641e/neurolib-0.4.1.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "abe6de30d65e7dd0a013f2009570225e", "sha256": "a41cb689e18c74efd3d88a9bb44be8f1bfa65ffc13f559586b03f0f4c9ec5421"}, "downloads": -1, "filename": "neurolib-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "abe6de30d65e7dd0a013f2009570225e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 8234429, "upload_time": "2020-04-08T20:00:12", "upload_time_iso_8601": "2020-04-08T20:00:12.810288Z", "url": "https://files.pythonhosted.org/packages/18/3d/f17a8eb922bdfb84b2a506da9275afe4567b83d4aa6d7f7d8170e5e872ff/neurolib-0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a68baaeb65884b66e5020b2eca7951aa", "sha256": "8ae7a44266b3baa55dc75721c935dd4d6eafc75251143fd186bb7f46d0b13cbf"}, "downloads": -1, "filename": "neurolib-0.5.tar.gz", "has_sig": false, "md5_digest": "a68baaeb65884b66e5020b2eca7951aa", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 8221441, "upload_time": "2020-04-08T20:00:27", "upload_time_iso_8601": "2020-04-08T20:00:27.365575Z", "url": "https://files.pythonhosted.org/packages/bb/f2/aad695e3287adfe581ee709e809c9df6ffc3e2cf730b53d444fae35c5bd0/neurolib-0.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "abe6de30d65e7dd0a013f2009570225e", "sha256": "a41cb689e18c74efd3d88a9bb44be8f1bfa65ffc13f559586b03f0f4c9ec5421"}, "downloads": -1, "filename": "neurolib-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "abe6de30d65e7dd0a013f2009570225e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 8234429, "upload_time": "2020-04-08T20:00:12", "upload_time_iso_8601": "2020-04-08T20:00:12.810288Z", "url": "https://files.pythonhosted.org/packages/18/3d/f17a8eb922bdfb84b2a506da9275afe4567b83d4aa6d7f7d8170e5e872ff/neurolib-0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a68baaeb65884b66e5020b2eca7951aa", "sha256": "8ae7a44266b3baa55dc75721c935dd4d6eafc75251143fd186bb7f46d0b13cbf"}, "downloads": -1, "filename": "neurolib-0.5.tar.gz", "has_sig": false, "md5_digest": "a68baaeb65884b66e5020b2eca7951aa", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 8221441, "upload_time": "2020-04-08T20:00:27", "upload_time_iso_8601": "2020-04-08T20:00:27.365575Z", "url": "https://files.pythonhosted.org/packages/bb/f2/aad695e3287adfe581ee709e809c9df6ffc3e2cf730b53d444fae35c5bd0/neurolib-0.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:45:46 2020"}