{"info": {"author": "Allen Short", "author_email": "washort42@gmail.com", "bugtrack_url": null, "classifiers": [], "description": ".. -*- mode: rst -*-\n\n===============================================================\nParsley: A Pattern-Matching Language Based on OMeta and Python\n===============================================================\n\nYou can read further docs at: http://parsley.readthedocs.org/en/latest/\n\nSummary\n-------\n\nParsley is a parsing library for people who find parsers scary or\nannoying. I wrote it because I wanted to parse a programming language,\nand tools like PLY or ANTLR or Bison were very hard to understand and\nintegrate into my Python code. Most parser generators are based on LL\nor LR parsing algorithms that compile to big state machine\ntables. It was like I had to wake up a different section of my brain\nto understand or work on grammar rules.\n\nParsley, like pyparsing and ZestyParser, uses the PEG algorithm, so\neach expression in the grammar rules works like a Python\nexpression. In particular, alternatives are evaluated in order, unlike\ntable-driven parsers such as yacc, bison or PLY.\n\nParsley is an implementation of OMeta, an object-oriented\npattern-matching language developed by Alessandro Warth at\nhttp://tinlizzie.org/ometa/ . For further reading, see Warth's PhD\nthesis, which provides a detailed description of OMeta:\nhttp://www.vpri.org/pdf/tr2008003_experimenting.pdf\n\nHow It Works\n------------\n\nParsley compiles a grammar to a Python class, with the rules as methods. The\nrules specify parsing expressions, which consume input and return values if\nthey succeed in matching.\n\nBasic syntax\n~~~~~~~~~~~~\n``foo = ....``:\n   Define a rule named foo.\n\n``expr1 expr2``:\n   Match expr1, and then match expr2 if it succeeds, returning the value of\n   expr2. Like Python's ``and``.\n\n``expr1 | expr2``:\n  Try to match ``expr1`` --- if it fails, match ``expr2`` instead. Like Python's\n  ``or``.\n\n``expr*``:\n  Match ``expr`` zero or more times, returning a list of matches.\n\n``expr+``:\n  Match ``expr`` one or more times, returning a list of matches.\n\n``expr?``:\n  Try to match ``expr``. Returns ``None`` if it fails to match.\n\n``expr{n, m}``:\n  Match ``expr`` at least ``n`` times, and no more than ``m`` times.\n\n``expr{n}``:\n  Match ``expr`` ``n`` times exactly.\n\n``~expr``:\n  Negative lookahead. Fails if the next item in the input matches\n  ``expr``. Consumes no input.\n\n``~~expr``:\n  Positive lookahead. Fails if the next item in the input does *not*\n  match ``expr``. Consumes no input.\n\n``ruleName`` or ``ruleName(arg1 arg2 etc)``:\n  Call the rule ``ruleName``, possibly with args.\n\n``'x'``:\n  Match the literal character 'x'.\n\n``<expr>``:\n  Returns the string consumed by matching ``expr``. Good for tokenizing rules.\n\n``expr:name``:\n  Bind the result of expr to the local variable ``name``.\n\n``-> pythonExpression``:\n  Evaluate the given Python expression and return its result. Can be\n  used inside parentheses too!\n\n``!(pythonExpression)``:\n  Invoke a Python expression as an action.\n\n``?(pythonExpression)``:\n  Fail if the Python expression is false, Returns True otherwise.\n\nComments like Python comments are supported as well, starting with #\nand extending to the end of the line.\n\nInterface\n---------\n\nThe starting point for defining a new grammar is\n``parsley.makeGrammar(grammarSource, bindings)``, which takes a grammar\ndefinition and a dict of variable bindings for its embedded\nexpressions and produces a Python class. Grammars can be subclassed as\nusual, and makeGrammar can be called on these classes to override\nrules and provide new ones. Grammar rules are exposed as methods.\n\nExample Usage\n-------------\n\n::\n\n    from parsley import makeGrammar\n    exampleGrammar = \"\"\"\n    ones = '1' '1' -> 1\n    twos = '2' '2' -> 2\n    stuff = (ones | twos)+\n    \"\"\"\n    Example = makeGrammar(exampleGrammar, {})\n    g = Example(\"11221111\")\n    result = g.stuff()\n    print result\n\n\u2192  ``[1, 2, 1, 1]``", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://launchpad.net/parsley", "keywords": null, "license": "MIT License", "maintainer": null, "maintainer_email": null, "name": "Parsley", "package_url": "https://pypi.org/project/Parsley/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/Parsley/", "project_urls": {"Homepage": "http://launchpad.net/parsley"}, "release_url": "https://pypi.org/project/Parsley/1.3/", "requires_dist": null, "requires_python": null, "summary": "Parsing and pattern matching made easy.", "version": "1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>You can read further docs at: <a href=\"http://parsley.readthedocs.org/en/latest/\" rel=\"nofollow\">http://parsley.readthedocs.org/en/latest/</a></p>\n<div id=\"summary\">\n<h2>Summary</h2>\n<p>Parsley is a parsing library for people who find parsers scary or\nannoying. I wrote it because I wanted to parse a programming language,\nand tools like PLY or ANTLR or Bison were very hard to understand and\nintegrate into my Python code. Most parser generators are based on LL\nor LR parsing algorithms that compile to big state machine\ntables. It was like I had to wake up a different section of my brain\nto understand or work on grammar rules.</p>\n<p>Parsley, like pyparsing and ZestyParser, uses the PEG algorithm, so\neach expression in the grammar rules works like a Python\nexpression. In particular, alternatives are evaluated in order, unlike\ntable-driven parsers such as yacc, bison or PLY.</p>\n<p>Parsley is an implementation of OMeta, an object-oriented\npattern-matching language developed by Alessandro Warth at\n<a href=\"http://tinlizzie.org/ometa/\" rel=\"nofollow\">http://tinlizzie.org/ometa/</a> . For further reading, see Warth\u2019s PhD\nthesis, which provides a detailed description of OMeta:\n<a href=\"http://www.vpri.org/pdf/tr2008003_experimenting.pdf\" rel=\"nofollow\">http://www.vpri.org/pdf/tr2008003_experimenting.pdf</a></p>\n</div>\n<div id=\"how-it-works\">\n<h2>How It Works</h2>\n<p>Parsley compiles a grammar to a Python class, with the rules as methods. The\nrules specify parsing expressions, which consume input and return values if\nthey succeed in matching.</p>\n<div id=\"basic-syntax\">\n<h3>Basic syntax</h3>\n<dl>\n<dt><tt>foo = <span class=\"pre\">....</span></tt>:</dt>\n<dd>Define a rule named foo.</dd>\n<dt><tt>expr1 expr2</tt>:</dt>\n<dd>Match expr1, and then match expr2 if it succeeds, returning the value of\nexpr2. Like Python\u2019s <tt>and</tt>.</dd>\n<dt><tt>expr1 | expr2</tt>:</dt>\n<dd>Try to match <tt>expr1</tt> \u2014 if it fails, match <tt>expr2</tt> instead. Like Python\u2019s\n<tt>or</tt>.</dd>\n<dt><tt>expr*</tt>:</dt>\n<dd>Match <tt>expr</tt> zero or more times, returning a list of matches.</dd>\n<dt><tt>expr+</tt>:</dt>\n<dd>Match <tt>expr</tt> one or more times, returning a list of matches.</dd>\n<dt><tt>expr?</tt>:</dt>\n<dd>Try to match <tt>expr</tt>. Returns <tt>None</tt> if it fails to match.</dd>\n<dt><tt>expr{n, m}</tt>:</dt>\n<dd>Match <tt>expr</tt> at least <tt>n</tt> times, and no more than <tt>m</tt> times.</dd>\n<dt><tt>expr{n}</tt>:</dt>\n<dd>Match <tt>expr</tt> <tt>n</tt> times exactly.</dd>\n<dt><tt>~expr</tt>:</dt>\n<dd>Negative lookahead. Fails if the next item in the input matches\n<tt>expr</tt>. Consumes no input.</dd>\n<dt><tt>~~expr</tt>:</dt>\n<dd>Positive lookahead. Fails if the next item in the input does <em>not</em>\nmatch <tt>expr</tt>. Consumes no input.</dd>\n<dt><tt>ruleName</tt> or <tt>ruleName(arg1 arg2 etc)</tt>:</dt>\n<dd>Call the rule <tt>ruleName</tt>, possibly with args.</dd>\n<dt><tt>'x'</tt>:</dt>\n<dd>Match the literal character \u2018x\u2019.</dd>\n<dt><tt>&lt;expr&gt;</tt>:</dt>\n<dd>Returns the string consumed by matching <tt>expr</tt>. Good for tokenizing rules.</dd>\n<dt><tt>expr:name</tt>:</dt>\n<dd>Bind the result of expr to the local variable <tt>name</tt>.</dd>\n<dt><tt><span class=\"pre\">-&gt;</span> pythonExpression</tt>:</dt>\n<dd>Evaluate the given Python expression and return its result. Can be\nused inside parentheses too!</dd>\n<dt><tt>!(pythonExpression)</tt>:</dt>\n<dd>Invoke a Python expression as an action.</dd>\n<dt><tt><span class=\"pre\">?(pythonExpression)</span></tt>:</dt>\n<dd>Fail if the Python expression is false, Returns True otherwise.</dd>\n</dl>\n<p>Comments like Python comments are supported as well, starting with #\nand extending to the end of the line.</p>\n</div>\n</div>\n<div id=\"interface\">\n<h2>Interface</h2>\n<p>The starting point for defining a new grammar is\n<tt>parsley.makeGrammar(grammarSource, bindings)</tt>, which takes a grammar\ndefinition and a dict of variable bindings for its embedded\nexpressions and produces a Python class. Grammars can be subclassed as\nusual, and makeGrammar can be called on these classes to override\nrules and provide new ones. Grammar rules are exposed as methods.</p>\n</div>\n<div id=\"example-usage\">\n<h2>Example Usage</h2>\n<pre>from parsley import makeGrammar\nexampleGrammar = \"\"\"\nones = '1' '1' -&gt; 1\ntwos = '2' '2' -&gt; 2\nstuff = (ones | twos)+\n\"\"\"\nExample = makeGrammar(exampleGrammar, {})\ng = Example(\"11221111\")\nresult = g.stuff()\nprint result\n</pre>\n<p>\u2192  <tt>[1, 2, 1, 1]</tt></p>\n</div>\n\n          </div>"}, "last_serial": 2759147, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "b73e0d6b5f9f510ca2e544cbd1970e51", "sha256": "9e2fc5988dd2dde00a66708d99420ef5d53ba9868ed32a6c8de772618cf66ec6"}, "downloads": -1, "filename": "Parsley-1.0.tar.gz", "has_sig": true, "md5_digest": "b73e0d6b5f9f510ca2e544cbd1970e51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 197303, "upload_time": "2012-10-02T05:09:04", "upload_time_iso_8601": "2012-10-02T05:09:04.990720Z", "url": "https://files.pythonhosted.org/packages/44/81/ffed5d0e208af3adb7dfb0dbc16e3db06a9b6075233ece831fe0986742b1/Parsley-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "7b060cacc85d9cd0a3eee9d26f11fa94", "sha256": "2c1e51ae248d23f2ceb8ae44cc38f125731dd09c31f25267a50b33c8f7359e99"}, "downloads": -1, "filename": "Parsley-1.1.tar.gz", "has_sig": false, "md5_digest": "7b060cacc85d9cd0a3eee9d26f11fa94", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 70835, "upload_time": "2013-03-08T05:34:12", "upload_time_iso_8601": "2013-03-08T05:34:12.730225Z", "url": "https://files.pythonhosted.org/packages/35/8c/a8980db1ccde5cc460215441d2c038ae0299bf7584c9d66961aaac108025/Parsley-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "9905aa78f3256604f56e7bdd6aaf6123", "sha256": "50d30cee70770fd44db7cea421cb2fb75af247c3a1cd54885c06b30a7c85dd23"}, "downloads": -1, "filename": "Parsley-1.2.tar.gz", "has_sig": false, "md5_digest": "9905aa78f3256604f56e7bdd6aaf6123", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 275181, "upload_time": "2013-08-02T06:19:57", "upload_time_iso_8601": "2013-08-02T06:19:57.387415Z", "url": "https://files.pythonhosted.org/packages/3b/0f/322ffa0e84d53b337c09502eee3ee26cdc333f0d7fd4f1f0c563c577d425/Parsley-1.2.tar.gz", "yanked": false}], "1.3": [{"comment_text": "", "digests": {"md5": "d1caebe2e580d91cc153d50327c2bef7", "sha256": "c3bc417b8c7e3a96c87c0f2f751bfd784ed5156ffccebe2f84330df5685f8dc3"}, "downloads": -1, "filename": "Parsley-1.3-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "d1caebe2e580d91cc153d50327c2bef7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 88932, "upload_time": "2015-09-09T02:53:09", "upload_time_iso_8601": "2015-09-09T02:53:09.977884Z", "url": "https://files.pythonhosted.org/packages/2b/d6/4fed8d65e28a970e1c5cb33ce9c7e22e3de745e1b2ae37af051ef16aea3b/Parsley-1.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "92bc256e5f73810a609dc7874637ad31", "sha256": "9444278d47161d5f2be76a767809a3cbe6db4db822f46a4fd7481d4057208d41"}, "downloads": -1, "filename": "Parsley-1.3.tar.gz", "has_sig": true, "md5_digest": "92bc256e5f73810a609dc7874637ad31", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 99616, "upload_time": "2015-09-09T02:53:04", "upload_time_iso_8601": "2015-09-09T02:53:04.899903Z", "url": "https://files.pythonhosted.org/packages/06/52/cac2f9e78c26cff8bb518bdb4f2b5a0c7058dec7a62087ed48fe87478ef0/Parsley-1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d1caebe2e580d91cc153d50327c2bef7", "sha256": "c3bc417b8c7e3a96c87c0f2f751bfd784ed5156ffccebe2f84330df5685f8dc3"}, "downloads": -1, "filename": "Parsley-1.3-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "d1caebe2e580d91cc153d50327c2bef7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 88932, "upload_time": "2015-09-09T02:53:09", "upload_time_iso_8601": "2015-09-09T02:53:09.977884Z", "url": "https://files.pythonhosted.org/packages/2b/d6/4fed8d65e28a970e1c5cb33ce9c7e22e3de745e1b2ae37af051ef16aea3b/Parsley-1.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "92bc256e5f73810a609dc7874637ad31", "sha256": "9444278d47161d5f2be76a767809a3cbe6db4db822f46a4fd7481d4057208d41"}, "downloads": -1, "filename": "Parsley-1.3.tar.gz", "has_sig": true, "md5_digest": "92bc256e5f73810a609dc7874637ad31", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 99616, "upload_time": "2015-09-09T02:53:04", "upload_time_iso_8601": "2015-09-09T02:53:04.899903Z", "url": "https://files.pythonhosted.org/packages/06/52/cac2f9e78c26cff8bb518bdb4f2b5a0c7058dec7a62087ed48fe87478ef0/Parsley-1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:15 2020"}