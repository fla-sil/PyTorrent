{"info": {"author": "BlueDynamics Alliance", "author_email": "dev@bluedynamics.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: Python Software Foundation License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development"], "description": "Plumber\n=======\n\nPlumbing is an alternative to mixin-based extension of classes.  In motivation\nan incomplete list of limitations and/or design choices of python's subclassing\nare given along with plumber's solutions for them. The plumbing system is\ndescribed in detail with code examples. Some design choices and ongoing\ndiscussions are explained. Finally, in miscellanea you find nomenclature,\ncoverage report, list of contributors, changes and some todos.  All\nnon-experimental features are fully test covered.\n\n.. contents::\n    :depth: 2\n\n\nMotivation: limitations of subclassing\n--------------------------------------\n\nPlumbing is an alternative to mixin-based extension of classes, motivated by\nlimitations and/or design choice of python's subclassing:\n\n.. contents::\n    :local:\n\n\nControl of precedence only through order of mixins\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nMixins are commonly used to extend classes with pre-defined behaviours: an\nattribute on the first mixin overwrites attributes with the same name on all\nfollowing mixins and the base class being extended.\n\n.. code-block:: pycon\n\n    >>> class Mixin1(object):\n    ...     a = 1\n\n    >>> class Mixin2(object):\n    ...     a = 2\n    ...     b = 2\n\n    >>> Base = dict\n    >>> class MixedClass(Mixin1, Mixin2, Base):\n    ...     pass\n\n    >>> MixedClass.a\n    1\n    >>> MixedClass.b\n    2\n    >>> MixedClass.keys\n    <method 'keys' of 'dict' objects>\n\nThere is no way for a mixin later in the chain to take precedence over an\nearlier one.\n\n**Solution**: plumber provides 3 decorators to enable finer control of\nprecedence (``default``, ``override``, ``finalize``).\n\n\nImpossible to provide default values to fill gaps on a base class\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA dictionary-like storage at least needs to provide ``__getitem__``,\n``__setitem__``, ``__delitem__`` and ``__iter__``, all other methods of a\ndictionary can be build upon these. A mixin that turns storages into full\ndictionaries needs to be able to provide default methods, taken if the base\nclass does not provide a (more efficient) implementation.\n\n**Solution**: plumber provides the ``default`` decorator to enable such\ndefaults.\n\n\n``super``-chains are not verified during class creation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIt is possible to build a chain of methods using ``super``: ``Mixin1`` turns\nthe key lowercase before passing it on, ``Mixin2`` multiplies the result by 2\nbefore returning it and both are chatty about start/stop.\n\n.. code-block:: pycon\n\n    >>> class Mixin1(object):\n    ...     def __getitem__(self, key):\n    ...         print \"Mixin1 start\"\n    ...         key = key.lower()\n    ...         ret = super(Mixin1, self).__getitem__(key)\n    ...         print \"Mixin1 stop\"\n    ...         return ret\n\n    >>> class Mixin2(object):\n    ...     def __getitem__(self, key):\n    ...         print \"Mixin2 start\"\n    ...         ret = super(Mixin2, self).__getitem__(key)\n    ...         ret = 2 * ret\n    ...         print \"Mixin2 stop\"\n    ...         return ret\n\n    >>> Base = dict\n    >>> class MixedClass(Mixin1, Mixin2, Base):\n    ...     pass\n\n    >>> mc = MixedClass()\n    >>> mc['abc'] = 6\n    >>> mc['ABC']\n    Mixin1 start\n    Mixin2 start\n    Mixin2 stop\n    Mixin1 stop\n    12\n\n``dict.__getitem__`` forms the endpoint of the chain as it returns a value\nwithout delegating to a method later in the chain (using ``super``). If there\nis no endpoint an ``AttributeError`` is raised during runtime, not during class\ncreation.\n\n.. code-block:: pycon\n\n    >>> class Mixin1(object):\n    ...     def foo(self):\n    ...         super(Mixin1, self).foo()\n\n    >>> class MixedClass(Mixin1, Base):\n    ...     pass\n\n    >>> mc = MixedClass()\n    >>> mc.foo()\n    Traceback (most recent call last):\n      ...\n    AttributeError: 'super' object has no attribute 'foo'\n\n**Solution**: Plumber provides the ``plumb`` decorator to build similar chains\nusing nested closures. These are create and verified during class creation.\n\n\nNo conditional ``super``-chains\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA mixin with subclassing needs to fit exactly the base class, there is no way\nto conditionally hook into method calls depending on whether the base class\nprovides a method.\n\n**Solution**: Plumber provides the ``plumbifexists`` decorator that behaves\nlike ``plumb``, if there is an endpoint available.\n\n\nDocstrings are not accumulated\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA class' docstring that uses mixins is not build from the docstrings of the\nmixins.\n\n**Solution**: Plumber enables plumbing of docstrings using a special marker\n``__plbnext__``, which is replaced with the docstring of the next \"mixin\"\nWithout the marker, docstrings are concatenated.\n\n\nThe plumbing system\n-------------------\n\nThe ``plumber`` metaclass creates plumbing classes according to instructions\nfound on plumbing behaviors. First, all instructions are gathered, then they are\napplied in two stages: stage1: extension and stage2: pipelines, docstrings and\noptional ``zope.interfaces``. There exists a class decorator ``plumbing`` which\nshould be used in favor of setting metaclass directly as of plumber 1.3.\n\n.. contents::\n    :local:\n\n\nPlumbing behaviors provide instructions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPlumbing behaviors correspond to mixins, but are more powerful and flexible. A\nplumbing behavior needs to inherit from ``plumber.Behavior`` and declares \nattributes with instructions on how to use them, here by example of the \n``default`` instruction (more later).\n\n.. code-block:: pycon\n\n    >>> from plumber import Behavior\n    >>> from plumber import default\n\n    >>> class Behavior1(Behavior):\n    ...     a = default(True)\n    ...\n    ...     @default\n    ...     def foo(self):\n    ...         return 42\n\n    >>> class Behavior2(Behavior):\n    ...     @default\n    ...     @property\n    ...     def bar(self):\n    ...         return 17\n\nThe instructions are given as behavior of assignments (``a = default(None)``) \nor as decorators (``@default``).\n\nA plumbing declaration defines the ``plumber`` as metaclass and one or more\nplumbing behaviors to be processed from left to right. Further it may declare\nattributes like every normal class, they will be treated as implicit\n``finalize`` instructions (see Stage 1: Extension).\n\n.. code-block:: pycon\n\n    >>> from plumber import plumbing\n\n    >>> Base = dict\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(Base):\n    ...\n    ...     def foobar(self):\n    ...         return 5\n\nThe result is a plumbing class created according to the plumbing declaration.\n\n.. code-block:: pycon\n\n    >>> plb = Plumbing()\n    >>> plb.a\n    True\n    >>> plb.foo()\n    42\n    >>> plb.bar\n    17\n    >>> plb.foobar()\n    5\n    >>> plb['a'] = 1\n    >>> plb['a']\n    1\n\nA plumbing class can be subclassed like normal classes.\n\n.. code-block:: pycon\n\n    >>> class Sub(Plumbing):\n    ...     a = 'Sub'\n\n    >>> Sub.a\n    'Sub'\n    >>> Sub().foo()\n    42\n    >>> Sub().bar\n    17\n    >>> Sub().foobar()\n    5\n\n\nThe plumber gathers instructions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA plumbing declaration provides a list of behaviors via the ``plumbing``\ndecorator. Behaviors provide instructions to be applied in two stages:\n\nstage1\n  - extension via ``default``, ``override`` and ``finalize``, the result of this\n    stage is the base for stage2.\n\nstage2\n  - creation of pipelines via ``plumb`` and ``plumbifexists``\n  - plumbing of docstrings\n  - implemented interfaces from ``zope.interface``, iff available\n\nThe plumber walks the Behavior list from left to right (behavior order). On its\nway it gathers instructions onto stacks, sorted by stage and attribute name. A \nhistory of all instructions is kept.\n\n.. code-block:: pycon\n\n    >>> pprint(Plumbing.__plumbing_stacks__)\n    {'history':\n      [<_implements '__interfaces__' of None payload=()>,\n       <default 'a' of <class 'Behavior1'> payload=True>,\n       <default 'foo' of <class 'Behavior1'> payload=<function foo at 0x...>>,\n       <_implements '__interfaces__' of None payload=()>,\n       <default 'bar' of <class 'Behavior2'> payload=<property object at 0x...>>],\n     'stages':\n       {'stage1':\n         {'a': [<default 'a' of <class 'Behavior1'> payload=True>],\n          'bar': [<default 'bar' of <class 'Behavior2'> payload=<property ...\n          'foo': [<default 'foo' of <class 'Behavior1'> payload=<function foo ...\n        'stage2':\n         {'__interfaces__': [<_implements '__interfaces__' of None payload=()...\n\nBefore putting a new instruction onto a stack, it is compared with the latest\ninstruction on the stack. It is either taken as is, discarded, merged or a\n``PlumbingCollision`` is raised. This is detailed in the following sections.\n\nAfter all instructions are gathered onto the stacks, they are applied in two\nstages taking declarations on the plumbing class and base classes into account.\n\nThe result of the first stage is the base for the application of the second\nstage.\n\n.. note:: The payload of an instruction is the attribute value passed to the\n  instruction via function call or decoration. An instruction knows the\n  behavior it is declared on.\n\n.. note:: Behaviors are created by ``behaviormetaclass``. If ``zope.interface``\n  is available, it will generate ``_implements`` instructions for each behavior.\n  During behavior creation the interfaces are not yet implemented, they are\n  checked at a later stage. Therefore the ``_implements`` instructions are \n  generated even if the behaviors do not implement interfaces, which results in\n  the empty tuple as payload (see also ``zope.interface support``.\n\n.. warning:: Do not rely on this structure within your programs it might change\n  at any time. If you need information from the ``__plumbing_stacks__`` or lack\n  information in there, e.g. to create a plumbing inspector and earn yourself\n  a box of your favorite beverage, please let us know.\n\n\nStage 1: Extension\n^^^^^^^^^^^^^^^^^^\n\nThe extension stage creates endpoints for the pipelines created in stage 2. If\nno pipeline uses the endpoint, it will just live on as a normal attribute in\nthe plumbing class' dictionary.\n\nThe extension decorators:\n\n``finalize``\n    ``finalize`` is the strongest extension instruction. It will override\n    declarations on base classes and all other extension instructions\n    (``override`` and ``default``). Attributes declared as behavior of the\n    plumbing declaration are implicit ``finalize`` declarations. Two \n    ``finalize`` for one attribute name will collide and raise a \n    ``PlumbingCollision`` during class creation.\n\n``override``\n    ``override`` is weaker than ``finalize`` and overrides declarations on base\n    classes and ``default`` declarations. Two ``override`` instructions for the\n    same attribute name do not collide, instead the first one will be used.\n\n``default``\n    ``default`` is the weakest extension instruction. It will not even override\n    declarations of base classes. The first default takes precendence over\n    later defaults.\n\n.. contents::\n    :local:\n\n\nInteraction: ``finalize``, plumbing declaration and base classes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn code.\n\n.. code-block:: pycon\n\n    >>> from plumber import finalize\n\n    >>> class Behavior1(Behavior):\n    ...     N = finalize('Behavior1')\n    ...\n\n    >>> class Behavior2(Behavior):\n    ...     M = finalize('Behavior2')\n\n    >>> class Base(object):\n    ...     K = 'Base'\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(Base):\n    ...     L = 'Plumbing'\n\n    >>> for x in ['K', 'L', 'M', 'N']:\n    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))\n    K from Base\n    L from Plumbing\n    M from Behavior2\n    N from Behavior1\n\nsummary:\n\n- K-Q: attributes defined by behaviors, plumbing class and base classes\n- f: ``finalize`` declaration\n- x: declaration on plumbing class or base class\n- ?: base class declaration is irrelevant\n- **Y**: chosen end point\n- collision: indicates an invalid combination, that raises a ``PlumbingCollision``\n\n+------+-----------+-----------+----------+-------+-----------+\n| Attr | Behavior1 | Behavior2 | Plumbing | Base  | ok?       |\n+======+===========+===========+==========+=======+===========+\n| K    |           |           |          | **x** |           |\n+------+-----------+-----------+----------+-------+-----------+\n| L    |           |           | **x**    | ?     |           |\n+------+-----------+-----------+----------+-------+-----------+\n| M    |           | **f**     |          | ?     |           |\n+------+-----------+-----------+----------+-------+-----------+\n| N    | **f**     |           |          | ?     |           |\n+------+-----------+-----------+----------+-------+-----------+\n| O    | f         |           | x        | ?     | collision |\n+------+-----------+-----------+----------+-------+-----------+\n| P    |           | f         | x        | ?     | collision |\n+------+-----------+-----------+----------+-------+-----------+\n| Q    | f         | f         |          | ?     | collision |\n+------+-----------+-----------+----------+-------+-----------+\n\ncollisions.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     O = finalize(False)\n\n    >>> @plumbing(Behavior1)\n    ... class Plumbing(object):\n    ...     O = True\n    Traceback (most recent call last):\n      ...\n    PlumbingCollision:\n        Plumbing class\n      with:\n        <finalize 'O' of <class 'Behavior1'> payload=False>\n\n    >>> class Behavior2(Behavior):\n    ...     P = finalize(False)\n\n    >>> @plumbing(Behavior2)\n    ... class Plumbing(object):\n    ...     P = True\n    Traceback (most recent call last):\n      ...\n    PlumbingCollision:\n        Plumbing class\n      with:\n        <finalize 'P' of <class 'Behavior2'> payload=False>\n\n    >>> class Behavior1(Behavior):\n    ...     Q = finalize(False)\n\n    >>> class Behavior2(Behavior):\n    ...     Q = finalize(True)\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(object):\n    ...     pass\n    Traceback (most recent call last):\n      ...\n    PlumbingCollision:\n        <finalize 'Q' of <class 'Behavior1'> payload=False>\n      with:\n        <finalize 'Q' of <class 'Behavior2'> payload=True>\n\n\nInteraction: ``override``, plumbing declaration and base classes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin code.\n\n.. code-block:: pycon\n\n    >>> from plumber import override\n\n    >>> class Behavior1(Behavior):\n    ...     K = override('Behavior1')\n    ...     M = override('Behavior1')\n\n    >>> class Behavior2(Behavior):\n    ...     K = override('Behavior2')\n    ...     L = override('Behavior2')\n    ...     M = override('Behavior2')\n\n    >>> class Base(object):\n    ...     K = 'Base'\n    ...     L = 'Base'\n    ...     M = 'Base'\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(Base):\n    ...     K = 'Plumbing'\n\n    >>> for x in ['K', 'L', 'M']:\n    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))\n    K from Plumbing\n    L from Behavior2\n    M from Behavior1\n\nsummary:\n\n- K-M: attributes defined by behaviors, plumbing class and base classes\n- e: ``override`` declaration\n- x: declaration on plumbing class or base class\n- ?: base class declaration is irrelevant\n- **Y**: chosen end point\n\n+------+-----------+-----------+----------+------+\n| Attr | Behavior1 | Behavior2 | Plumbing | Base |\n+======+===========+===========+==========+======+\n| K    | e         | e         | **x**    | ?    |\n+------+-----------+-----------+----------+------+\n| L    |           | **e**     |          | ?    |\n+------+-----------+-----------+----------+------+\n| M    | **e**     | e         |          | ?    |\n+------+-----------+-----------+----------+------+\n\n\nInteraction: ``default``, plumbing declaration and base class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin code.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     N = default('Behavior1')\n\n    >>> class Behavior2(Behavior):\n    ...     K = default('Behavior2')\n    ...     L = default('Behavior2')\n    ...     M = default('Behavior2')\n    ...     N = default('Behavior2')\n\n    >>> class Base(object):\n    ...     K = 'Base'\n    ...     L = 'Base'\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(Base):\n    ...     L = 'Plumbing'\n\n    >>> for x in ['K', 'L', 'M', 'N']:\n    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))\n    K from Base\n    L from Plumbing\n    M from Behavior2\n    N from Behavior1\n\nsummary:\n\n- K-N: attributes defined by behaviors, plumbing class and base classes\n- d = ``default`` declaration\n- x = declaration on plumbing class or base class\n- ? = base class declaration is irrelevant\n- **Y** = chosen end point\n\n+------+-----------+-----------+----------+-------+\n| Attr | Behavior1 | Behavior2 | Plumbing | Base  |\n+======+===========+===========+==========+=======+\n| K    |           | d         |          | **x** |\n+------+-----------+-----------+----------+-------+\n| L    |           | d         | **x**    | ?     |\n+------+-----------+-----------+----------+-------+\n| M    |           | **d**     |          |       |\n+------+-----------+-----------+----------+-------+\n| N    | **d**     | d         |          |       |\n+------+-----------+-----------+----------+-------+\n\n\nInteraction: ``finalize`` wins over ``override``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin code.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     K = override('Behavior1')\n    ...     L = finalize('Behavior1')\n\n    >>> class Behavior2(Behavior):\n    ...     K = finalize('Behavior2')\n    ...     L = override('Behavior2')\n\n    >>> class Base(object):\n    ...     K = 'Base'\n    ...     L = 'Base'\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(Base):\n    ...     pass\n\n    >>> for x in ['K', 'L']:\n    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))\n    K from Behavior2\n    L from Behavior1\n\nsummary:\n\n- K-L: attributes defined by behaviors, plumbing class and base classes\n- e = ``override`` declaration\n- f = ``finalize`` declaration\n- ? = base class declaration is irrelevant\n- **Y** = chosen end point\n\n+------+-----------+-----------+----------+------+\n| Attr | Behavior1 | Behavior2 | Plumbing | Base |\n+======+===========+===========+==========+======+\n| K    | e         | **f**     |          | ?    |\n+------+-----------+-----------+----------+------+\n| L    | **f**     | e         |          | ?    |\n+------+-----------+-----------+----------+------+\n\n\nInteraction: ``finalize`` wins over ``default``:\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin code.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     K = default('Behavior1')\n    ...     L = finalize('Behavior1')\n\n    >>> class Behavior2(Behavior):\n    ...     K = finalize('Behavior2')\n    ...     L = default('Behavior2')\n\n    >>> class Base(object):\n    ...     K = 'Base'\n    ...     L = 'Base'\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(Base):\n    ...     pass\n\n    >>> for x in ['K', 'L']:\n    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))\n    K from Behavior2\n    L from Behavior1\n\nsummary:\n\n- K-L: attributes defined by behaviors, plumbing class and base classes\n- d = ``default`` declaration\n- f = ``finalize`` declaration\n- ? = base class declaration is irrelevant\n- **Y** = chosen end point\n\n+------+-----------+-----------+----------+------+\n| Attr | Behavior1 | Behavior2 | Plumbing | Base |\n+======+===========+===========+==========+======+\n| K    | d         | **f**     |          | ?    |\n+------+-----------+-----------+----------+------+\n| L    | **f**     | d         |          | ?    |\n+------+-----------+-----------+----------+------+\n\n\nInteraction: ``override`` wins over ``default``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin code.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     K = default('Behavior1')\n    ...     L = override('Behavior1')\n\n    >>> class Behavior2(Behavior):\n    ...     K = override('Behavior2')\n    ...     L = default('Behavior2')\n\n    >>> class Base(object):\n    ...     K = 'Base'\n    ...     L = 'Base'\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(Base):\n    ...     pass\n\n    >>> for x in ['K', 'L']:\n    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))\n    K from Behavior2\n    L from Behavior1\n\nsummary:\n\n- K-L: attributes defined by behaviors, plumbing class and base classes\n- d = ``default`` declaration\n- e = ``override`` declaration\n- ? = base class declaration is irrelevant\n- **Y** = chosen end point\n\n+------+-----------+-----------+----------+------+\n| Attr | Behavior1 | Behavior2 | Plumbing | Base |\n+======+===========+===========+==========+======+\n| K    | d         | **e**     |          | ?    |\n+------+-----------+-----------+----------+------+\n| L    | **e**     | d         |          | ?    |\n+------+-----------+-----------+----------+------+\n\n\nSubclassing Behaviors\n~~~~~~~~~~~~~~~~~~~~~\n\nin code.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     J = default('Behavior1')\n    ...     K = default('Behavior1')\n    ...     M = override('Behavior1')\n\n    >>> class Behavior2(Behavior1):\n    ...     J = default('Behavior2') # overrides ``J`` of ``Behavior1``\n    ...     L = default('Behavior2')\n    ...     M = default('Behavior2') # this one wins, even if ``M`` on\n    ...                              # superclass is ``override`` instruction.\n    ...                              # due to ordinary inheritance behavior.\n\n    >>> @plumbing(Behavior2)\n    ... class Plumbing(object):\n    ...     pass\n\n    >>> plb = Plumbing()\n    >>> plb.J\n    'Behavior2'\n\n    >>> plb.K\n    'Behavior1'\n\n    >>> plb.L\n    'Behavior2'\n\n    >>> plb.M\n    'Behavior2'\n\n\nStage 2: Pipeline, docstrings and ``zope.interface`` instructions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn stage1 plumbing class attributes were set, which can serve as endpoints for\nplumbing pipelines that are build in stage2. Plumbing pipelines correspond to\n``super``-chains. Docstrings of behaviors, methods in a pipeline and properties\nin a pipeline are accumulated. Plumber is ``zope.interface`` aware and takes\nimplemeneted interfaces from behaviors, if it can be imported.\n\n.. contents::\n    :local:\n\n\nPlumbing Pipelines in general\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nElements for plumbing pipelines are declared with the ``plumb`` and\n``plumbifexists`` decorators:\n\n``plumb``\n    Marks a method to be used as behavior of a plumbing pipeline.  The signature of\n    such a plumbing method is ``def foo(_next, self, *args, **kw)``.  Via\n    ``_next`` it is passed the next plumbing method to be called. ``self`` is\n    an instance of the plumbing class, not the behavior.\n\n``plumbifexists``\n    Like ``plumb``, but only used if an endpoint exists.\n\nThe user of a plumbing class does not know which ``_next`` to pass. Therefore,\nafter the pipelines are built, an entrance method is generated for each pipe,\nthat wraps the first plumbing method passing it the correct ``_next``. Each\n``_next`` method is an entrance to the rest of the pipeline.\n\nThe pipelines are build in behavior order, skipping behaviors that do not\ndefine a pipeline element with the same attribute name::\n\n    +---+-----------+-----------+-----------+----------+\n    |   | Behavior1 | Behavior2 | Behavior3 | ENDPOINT |\n    +---+-----------+-----------+-----------+----------+\n    |   |      --------------------------------->      |\n    | E |     x     |           |           |    x     |\n    | N |      <---------------------------------      |\n    + T +-----------+-----------+-----------+----------+\n    | R |      ----------> --------------------->      |\n    | A |     y     |     y     |           |    y     |\n    | N |      <---------- <---------------------      |\n    + C +-----------+-----------+-----------+----------+\n    | E |           |           |      --------->      |\n    | S |           |           |     z     |    z     |\n    |   |           |           |      <---------      |\n    +---+-----------+-----------+-----------+----------+\n\n\nMethod pipelines\n~~~~~~~~~~~~~~~~\n\nTwo plumbing behaviors and a ``dict`` as base class. ``Behavior1`` lowercases\nkeys before passing them on, ``Behavior2`` multiplies results before returning\nthem.\n\n.. code-block:: pycon\n\n    >>> from plumber import plumb\n\n    >>> class Behavior1(Behavior):\n    ...     @plumb\n    ...     def __getitem__(_next, self, key):\n    ...         print \"Behavior1 start\"\n    ...         key = key.lower()\n    ...         ret = _next(self, key)\n    ...         print \"Behavior1 stop\"\n    ...         return ret\n\n    >>> class Behavior2(Behavior):\n    ...     @plumb\n    ...     def __getitem__(_next, self, key):\n    ...         print \"Behavior2 start\"\n    ...         ret = 2 * _next(self, key)\n    ...         print \"Behavior2 stop\"\n    ...         return ret\n\n    >>> Base = dict\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(Base):\n    ...     pass\n\n    >>> plb = Plumbing()\n    >>> plb['abc'] = 6\n    >>> plb['AbC']\n    Behavior1 start\n    Behavior2 start\n    Behavior2 stop\n    Behavior1 stop\n    12\n\nPlumbing pipelines need endpoints. If no endpoint is available an\n``AttributeError`` is raised.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     @plumb\n    ...     def foo(_next, self):\n    ...         pass\n\n    >>> @plumbing(Behavior1)\n    ... class Plumbing(object):\n    ...     pass\n    Traceback (most recent call last):\n      ...\n    AttributeError: type object 'Plumbing' has no attribute 'foo'\n\nIf no endpoint is available and a behavior does not care about that,\n``plumbifexists`` can be used to only plumb if an endpoint is available.\n\n.. code-block:: pycon\n\n    >>> from plumber import plumbifexists\n\n    >>> class Behavior1(Behavior):\n    ...     @plumbifexists\n    ...     def foo(_next, self):\n    ...         pass\n    ...\n    ...     @plumbifexists\n    ...     def bar(_next, self):\n    ...         return 2 * _next(self)\n\n    >>> @plumbing(Behavior1)\n    ... class Plumbing(object):\n    ...\n    ...     def bar(self):\n    ...         return 6\n\n    >>> hasattr(Plumbing, 'foo')\n    False\n    >>> Plumbing().bar()\n    12\n\nThis enables one implementation of a certain behaviour, e.g. sending events for\ndictionaries, to be used for readwrite dictionaries that implement\n``__getitem__`` and ``__setitem__`` and readonly dictionaries, that only\nimplement ``__getitem__`` but no ``__setitem__``.\n\n\nProperty pipelines\n~~~~~~~~~~~~~~~~~~\n\nPlumbing of read only properties.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     @plumb\n    ...     @property\n    ...     def foo(_next, self):\n    ...         return 2 * _next(self)\n\n    >>> @plumbing(Behavior1)\n    ... class Plumbing(object):\n    ...\n    ...     @property\n    ...     def foo(self):\n    ...         return 3\n\n    >>> plb = Plumbing()\n    >>> plb.foo\n    6\n\nIt is possible to extend a property with so far unset getter/setter/deleter.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     @plumb\n    ...     @property\n    ...     def foo(_next, self):\n    ...         return 2 * _next(self)\n\n    >>> class Behavior2(Behavior):\n    ...     def set_foo(self, value):\n    ...         self._foo = value\n    ...     foo = plumb(property(\n    ...         None,\n    ...         override(set_foo),\n    ...         ))\n\n    >>> @plumbing(Behavior1, Behavior2)\n    ... class Plumbing(object):\n    ...\n    ...     @property\n    ...     def foo(self):\n    ...         return self._foo\n\n    >>> plb = Plumbing()\n    >>> plb.foo = 4\n    >>> plb.foo\n    8\n\n\nSubclassing Behaviors\n~~~~~~~~~~~~~~~~~~~~~\n\nOther than stage 1 instructions, which extend a class with properties\nand functions and thus override each other by the rules of ordinary\nsubclassing, pipeline instructions are aggregated.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ... \n    ...     @plumb\n    ...     def foo(_next, self):\n    ...         return 'Behavior1 ' + _next(self)\n    ... \n    ...     @plumb\n    ...     def bar(_next, self):\n    ...         return 'Behavior1 ' + _next(self)\n\n    >>> class Behavior2(Behavior1):\n    ... \n    ...     @plumb\n    ...     def foo(_next, self):\n    ...         return 'Behavior2 ' + _next(self)\n\n    >>> @plumbing(Behavior2)\n    ... class Plumbing(object):\n    ... \n    ...     def foo(self):\n    ...         return 'foo'\n    ... \n    ...     def bar(self):\n    ...         return 'bar'\n\n    >>> plb = Plumbing()\n    >>> plb.foo()\n    'Behavior2 Behavior1 foo'\n    \n    >>> plb.bar()\n    'Behavior1 bar'\n\n\nMixing methods and properties within the same pipeline is not possible\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWithin a pipeline all elements need to be of the same type, it is not possible\nto mix properties with methods.\n\n.. code-block:: pycon\n\n    >>> class Behavior1(Behavior):\n    ...     @plumb\n    ...     def foo(_next, self):\n    ...         return _next(self)\n\n    >>> @plumbing(Behavior1)\n    ... class Plumbing(object):\n    ...\n    ...     @property\n    ...     def foo(self):\n    ...         return 5\n    Traceback (most recent call last):\n      ...\n    PlumbingCollision:\n        <plumb 'foo' of <class 'Behavior1'> payload=<function foo at 0x...>>\n      with:\n        <class 'Plumbing'>\n\n\ndocstrings of classes, methods and properties\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNormal docstrings of the plumbing declaration and the behavior classes, plumbed\nmethods and plumbed properties are joined by newlines starting with the\nplumbing declaration and followed by the behaviors in reverse order.\n\n.. code-block:: pycon\n\n    >>> class P1(Behavior):\n    ...     \"\"\"P1\n    ...     \"\"\"\n    ...     @plumb\n    ...     def foo(self):\n    ...         \"\"\"P1.foo\n    ...         \"\"\"\n    ...     bar = plumb(property(None, None, None, \"P1.bar\"))\n\n    >>> class P2(Behavior):\n    ...     @override\n    ...     def foo(self):\n    ...         \"\"\"P2.foo\n    ...         \"\"\"\n    ...     bar = plumb(property(None, None, None, \"P2.bar\"))\n\n    >>> @plumbing(P1, P2)\n    ... class Plumbing(object):\n    ...     \"\"\"Plumbing\n    ...     \"\"\"\n    ...     bar = property(None, None, None, \"Plumbing.bar\")\n\n    >>> print Plumbing.__doc__\n    Plumbing\n    <BLANKLINE>\n    P1\n    <BLANKLINE>\n\n    >>> print Plumbing.foo.__doc__\n    P2.foo\n    <BLANKLINE>\n    P1.foo\n    <BLANKLINE>\n\n    >>> print Plumbing.bar.__doc__\n    Plumbing.bar\n    <BLANKLINE>\n    P2.bar\n    <BLANKLINE>\n    P1.bar\n\nThe accumulation of docstrings is an experimental feature and will probably\nchange.\n\n\nSlots and plumbings\n~~~~~~~~~~~~~~~~~~~\n\nA plumbing class can have __slots__ like normal classes.\n\n.. code-block:: pycon\n\n    >>> class P1(Behavior):\n    ...     @default\n    ...     def somewhing_which_writes_to_foo(self, foo_val):\n    ...         self.foo = foo_val\n\n    >>> @plumbing(P1)\n    ... class WithSlots(object):\n    ...     __slots__ = 'foo'\n\n    >>> WithSlots.__dict__['foo']\n    <member 'foo' of 'WithSlots' objects>\n\n    >>> ob = WithSlots()\n    >>> ob.somewhing_which_writes_to_foo('foo')\n    >>> assert(ob.foo == 'foo')\n\n\n``zope.interface`` (if available)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe plumber does not depend on ``zope.interface`` but is aware of it. That\nmeans it will try to import it and if available will check plumbing behaviors\nfor implemented interfaces and will make the plumbing implement them, too.\n\n.. code-block:: pycon\n\n    >>> from zope.interface import Interface\n    >>> from zope.interface import implementer\n\nA class with an interface that will serve as base class of a plumbing.\n\n.. code-block:: pycon\n\n    >>> class IBase(Interface):\n    ...     pass\n\n    >>> @implementer(IBase)\n    ... class Base(object):\n    ...     pass\n\n    >>> IBase.implementedBy(Base)\n    True\n\nTwo behaviors with corresponding interfaces, one with a base class that also\nimplements an interface.\n\n.. code-block:: pycon\n\n    >>> class IBehavior1(Interface):\n    ...     pass\n\n    >>> @implementer(IBehavior1)\n    ... class Behavior1(Behavior):\n    ...     blub = 1\n\n    >>> class IBehavior2Base(Interface):\n    ...     pass\n\n    >>> @implementer(IBehavior2Base)\n    ... class Behavior2Base(Behavior):\n    ...     pass\n\n    >>> class IBehavior2(Interface):\n    ...     pass\n\n    >>> @implementer(IBehavior2)\n    ... class Behavior2(Behavior2Base):\n    ...     pass\n\n    >>> IBehavior1.implementedBy(Behavior1)\n    True\n\n    >>> IBehavior2Base.implementedBy(Behavior2Base)\n    True\n\n    >>> IBehavior2Base.implementedBy(Behavior2)\n    True\n\n    >>> IBehavior2.implementedBy(Behavior2)\n    True\n\nA plumbing based on ``Base`` using ``Behavior1`` and ``Behavior2`` and\nimplementing ``IPlumbingClass``.\n\n.. code-block:: pycon\n\n    >>> class IPlumbingClass(Interface):\n    ...     pass\n\n    >>> @implementer(IPlumbingClass)\n    ... @plumbing(Behavior1, Behavior2)\n    ... class PlumbingClass(Base):\n    ...     pass\n\nThe directly declared and inherited interfaces are implemented.\n\n.. code-block:: pycon\n\n    >>> IPlumbingClass.implementedBy(PlumbingClass)\n    True\n\n    >>> IBase.implementedBy(PlumbingClass)\n    True\n\nThe interfaces implemented by the Behaviors are also implemented.\n\n.. code-block:: pycon\n\n    >>> IBehavior1.implementedBy(PlumbingClass)\n    True\n\n    >>> IBehavior2.implementedBy(PlumbingClass)\n    True\n\n    >>> IBehavior2Base.implementedBy(PlumbingClass)\n    True\n\nAn instance of the class provides the interfaces.\n\n.. code-block:: pycon\n\n    >>> plumbing = PlumbingClass()\n\n    >>> IPlumbingClass.providedBy(plumbing)\n    True\n\n    >>> IBase.providedBy(plumbing)\n    True\n\n    >>> IBehavior1.providedBy(plumbing)\n    True\n\n    >>> IBehavior2.providedBy(plumbing)\n    True\n\n    >>> IBehavior2Base.providedBy(plumbing)\n    True\n\n\nplumber metaclass hooks\n~~~~~~~~~~~~~~~~~~~~~~~\n\nIn case one writes a plumbing behavior requiring class manipulation at plumber\nmetaclass execution time a decorator is provided for registering callbacks\nwhich are executed at the end of the plumber metaclass ``__init__`` function.\nExecuting at last task ensures stage 1 and stage 2 instructions already have\nbeen executed and we're working on a complete plumbing class.\n\n.. code-block:: pycon\n\n    >>> class IBehaviorInterface(Interface):\n    ...     pass\n\n    >>> @plumber.metaclasshook\n    ... def test_metclass_hook(cls, name, bases, dct):\n    ...     if not IBehaviorInterface.implementedBy(cls):\n    ...         return\n    ...     cls.hooked = True\n\n    >>> @implementer(IBehaviorInterface)\n    ... class MetaclassConsideredBehavior(Behavior):\n    ...     pass\n\n    >>> @plumbing(MetaclassConsideredBehavior)\n    ... class Plumbing(object):\n    ...     pass\n\n    >>> Plumbing.hooked\n    True\n\n\nMiscellanea\n-----------\n\nNomenclature\n^^^^^^^^^^^^\n\n**``plumber``**\n    Metaclass that creates a plumbing according to the instructions declared on\n    plumbing behaviors. Instructions are given by decorators: ``default``,\n    ``override``, ``finalize``, ``plumb`` and ``plumbifexists``.\n\n**plumbing**\n    A plumbing is a class decorated by ``plumbing`` decorator which gets passed\n    the behviors to apply, e.g. ``@plumbing(Behavior1, Behavior2)``. Apart from\n    the behaviors, declarations on base classes and the class asking for the\n    plumber are taken into account. Once created, a plumbing looks like any\n    other class and can be subclassed as usual.\n\n**plumbing behavior**\n    A plumbing behavior provides attributes (functions, properties and plain\n    values) along with instructions for how to use them. Instructions are given\n    via decorators: ``default``, ``override``, ``finalize``, ``plumb`` and\n    ``plumbifexists`` (see Stage 1:... and Stage 2:...).\n\n**plumbing pipeline**\n    Plumbing methods/properties with the same name form a pipeline. The\n    entrance and end-point have the signature of normal methods: ``def\n    foo(self, *args, **kw)``. The plumbing pipelines is a series of nested\n    closures (see ``_next``).\n\n**entrance (method)**\n    A method with a normal signature. i.e. expecting ``self`` as first\n    argument, that is used to enter a pipeline. It is a ``_next`` function. A\n    method declared on the class with the same name, will be overwritten, but\n    referenced in the pipelines as the innermost method, the endpoint.\n\n**``_next`` function**\n    The ``_next`` function is used to call the next method in a pipelines: in\n    case of a plumbing method, it is a wrapper of it that passes the correct\n    next ``_next`` as first argument and in case of an end-point, just the\n    end-point method itself.\n\n**end-point (method)**\n    Method retrieved from the plumbing class with ``getattr()``, before setting\n    the entrance method on the class.\n\nIf you feel something is missing, please let us now or write a short\ncorresponding text.\n\n\nTest Coverage\n^^^^^^^^^^^^^\n\n.. image:: https://travis-ci.org/bluedynamics/plumber.svg?branch=master\n    :target: https://travis-ci.org/bluedynamics/plumber\n\nCoverage report::\n\n    Name                                      Stmts   Miss  Cover\n    -------------------------------------------------------------\n    src/plumber/__init__.py                      10      0   100%\n    src/plumber/behavior.py                      49      0   100%\n    src/plumber/compat.py                         9      0   100%\n    src/plumber/exceptions.py                     6      0   100%\n    src/plumber/instructions.py                 172      0   100%\n    src/plumber/plumber.py                       71      0   100%\n    src/plumber/tests/__init__.py               574      0   100%\n    src/plumber/tests/globalmetaclass.py         15      0   100%\n    -------------------------------------------------------------\n    TOTAL                                      1882      0   100%\n\n\nPython Versions\n^^^^^^^^^^^^^^^\n\n- Python 2.6+, 3.3+, pypy\n\n- May work with other versions (untested)\n\n\nContributors\n^^^^^^^^^^^^\n\n- Florian Friesdorf\n\n- Robert Niederreiter\n\n- Jens W. Klein\n\n- Marco Lempen\n\n- Attila Ol\u00e1h\n\n\nChanges\n-------\n\n1.5 (unreleased)\n~~~~~~~~~~~~~~~~\n\n- Introduce ``plumber.metaclasshook`` decorator.\n  [rnix, 2017-06-16]\n\n\n1.4\n~~~\n\n- No more \"private\" module names.\n  [rnix, 2017-05-21]\n\n- Python 3 support.\n  [rnix, 2017-05-18]\n\n\n1.3.1\n~~~~~\n\n- Avoid use of deprecated ``dict.has_key``.\n  [rnix, 2015-10-05]\n\n\n1.3\n~~~\n\n- Introduce ``plumbing`` decorator.\n  [rnix, 2014-07-31]\n\n- Remove deprecated ``plumber.extend`` and ``plumber.Part``.\n  [rnix, 2014-07-31]\n\n\n1.2\n~~~\n\n- Deprecate ``plumber.extend``. Use ``plumber.override`` instead.\n  [rnix, 2012-07-28]\n\n- Deprecate ``plumber.Part``. Use ``plumber.Behavior`` instead.\n  [rnix, 2012-07-28]\n\n\n1.1\n~~~\n\n- Use ``zope.interface.implementer`` instead of ``zope.interface.implements``.\n  [rnix, 2012-05-18]\n\n\n1.0\n~~~\n\n- ``.. plbnext::`` instead of ``.. plb_next::``\n  [chaoflow 2011-02-02]\n\n- stage1 in __new__, stage2 in __init__, setting of __name__ now works\n  [chaoflow 2011-01-25]\n\n- instructions recognize equal instructions\n  [chaoflow 2011-01-24]\n\n- instructions from base classes now like subclass inheritance [chaoflow 2011\n  [chaoflow 2011-01-24]\n\n- doctest order now plumbing order: P1, P2, PlumbingClass, was PlumbingClass,\n  P1, P2\n  [chaoflow 2011-01-24]\n\n- merged docstring instruction into plumb\n  [chaoflow 2011-01-24]\n\n- plumber instead of Plumber\n  [chaoflow 2011-01-24]\n\n- plumbing methods are not classmethods of part anymore\n  [chaoflow 2011-01-24]\n\n- complete rewrite\n  [chaoflow 2011-01-22]\n\n- prt instead of cls\n  [chaoflow, rnix 2011-01-19\n\n- default, extend, plumb\n  [chaoflow, rnix 2011-01-19]\n\n- initial\n  [chaoflow, 2011-01-04]\n\n\nLicense / Disclaimer\n--------------------\n\nCopyright (c) 2011-2017, BlueDynamics Alliance, Austria, Germany, Switzerland\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n* Neither the name of the BlueDynamics Alliance nor the names of its\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY BlueDynamics Alliance ``AS IS`` AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL BlueDynamics Alliance BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/bluedynamics/plumber", "keywords": "", "license": "Python Software Foundation License", "maintainer": "", "maintainer_email": "", "name": "plumber", "package_url": "https://pypi.org/project/plumber/", "platform": "", "project_url": "https://pypi.org/project/plumber/", "project_urls": {"Homepage": "http://github.com/bluedynamics/plumber"}, "release_url": "https://pypi.org/project/plumber/1.5/", "requires_dist": null, "requires_python": "", "summary": "An alternative to mixin-based extension of classes.", "version": "1.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            Plumber<br>=======<br><br>Plumbing is an alternative to mixin-based extension of classes.  In motivation<br>an incomplete list of limitations and/or design choices of python's subclassing<br>are given along with plumber's solutions for them. The plumbing system is<br>described in detail with code examples. Some design choices and ongoing<br>discussions are explained. Finally, in miscellanea you find nomenclature,<br>coverage report, list of contributors, changes and some todos.  All<br>non-experimental features are fully test covered.<br><br>.. contents::<br>    :depth: 2<br><br><br>Motivation: limitations of subclassing<br>--------------------------------------<br><br>Plumbing is an alternative to mixin-based extension of classes, motivated by<br>limitations and/or design choice of python's subclassing:<br><br>.. contents::<br>    :local:<br><br><br>Control of precedence only through order of mixins<br>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br><br>Mixins are commonly used to extend classes with pre-defined behaviours: an<br>attribute on the first mixin overwrites attributes with the same name on all<br>following mixins and the base class being extended.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Mixin1(object):<br>    ...     a = 1<br><br>    &gt;&gt;&gt; class Mixin2(object):<br>    ...     a = 2<br>    ...     b = 2<br><br>    &gt;&gt;&gt; Base = dict<br>    &gt;&gt;&gt; class MixedClass(Mixin1, Mixin2, Base):<br>    ...     pass<br><br>    &gt;&gt;&gt; MixedClass.a<br>    1<br>    &gt;&gt;&gt; MixedClass.b<br>    2<br>    &gt;&gt;&gt; MixedClass.keys<br>    &lt;method 'keys' of 'dict' objects&gt;<br><br>There is no way for a mixin later in the chain to take precedence over an<br>earlier one.<br><br>**Solution**: plumber provides 3 decorators to enable finer control of<br>precedence (``default``, ``override``, ``finalize``).<br><br><br>Impossible to provide default values to fill gaps on a base class<br>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br><br>A dictionary-like storage at least needs to provide ``__getitem__``,<br>``__setitem__``, ``__delitem__`` and ``__iter__``, all other methods of a<br>dictionary can be build upon these. A mixin that turns storages into full<br>dictionaries needs to be able to provide default methods, taken if the base<br>class does not provide a (more efficient) implementation.<br><br>**Solution**: plumber provides the ``default`` decorator to enable such<br>defaults.<br><br><br>``super``-chains are not verified during class creation<br>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br><br>It is possible to build a chain of methods using ``super``: ``Mixin1`` turns<br>the key lowercase before passing it on, ``Mixin2`` multiplies the result by 2<br>before returning it and both are chatty about start/stop.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Mixin1(object):<br>    ...     def __getitem__(self, key):<br>    ...         print \"Mixin1 start\"<br>    ...         key = key.lower()<br>    ...         ret = super(Mixin1, self).__getitem__(key)<br>    ...         print \"Mixin1 stop\"<br>    ...         return ret<br><br>    &gt;&gt;&gt; class Mixin2(object):<br>    ...     def __getitem__(self, key):<br>    ...         print \"Mixin2 start\"<br>    ...         ret = super(Mixin2, self).__getitem__(key)<br>    ...         ret = 2 * ret<br>    ...         print \"Mixin2 stop\"<br>    ...         return ret<br><br>    &gt;&gt;&gt; Base = dict<br>    &gt;&gt;&gt; class MixedClass(Mixin1, Mixin2, Base):<br>    ...     pass<br><br>    &gt;&gt;&gt; mc = MixedClass()<br>    &gt;&gt;&gt; mc['abc'] = 6<br>    &gt;&gt;&gt; mc['ABC']<br>    Mixin1 start<br>    Mixin2 start<br>    Mixin2 stop<br>    Mixin1 stop<br>    12<br><br>``dict.__getitem__`` forms the endpoint of the chain as it returns a value<br>without delegating to a method later in the chain (using ``super``). If there<br>is no endpoint an ``AttributeError`` is raised during runtime, not during class<br>creation.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Mixin1(object):<br>    ...     def foo(self):<br>    ...         super(Mixin1, self).foo()<br><br>    &gt;&gt;&gt; class MixedClass(Mixin1, Base):<br>    ...     pass<br><br>    &gt;&gt;&gt; mc = MixedClass()<br>    &gt;&gt;&gt; mc.foo()<br>    Traceback (most recent call last):<br>      ...<br>    AttributeError: 'super' object has no attribute 'foo'<br><br>**Solution**: Plumber provides the ``plumb`` decorator to build similar chains<br>using nested closures. These are create and verified during class creation.<br><br><br>No conditional ``super``-chains<br>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br><br>A mixin with subclassing needs to fit exactly the base class, there is no way<br>to conditionally hook into method calls depending on whether the base class<br>provides a method.<br><br>**Solution**: Plumber provides the ``plumbifexists`` decorator that behaves<br>like ``plumb``, if there is an endpoint available.<br><br><br>Docstrings are not accumulated<br>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br><br>A class' docstring that uses mixins is not build from the docstrings of the<br>mixins.<br><br>**Solution**: Plumber enables plumbing of docstrings using a special marker<br>``__plbnext__``, which is replaced with the docstring of the next \"mixin\"<br>Without the marker, docstrings are concatenated.<br><br><br>The plumbing system<br>-------------------<br><br>The ``plumber`` metaclass creates plumbing classes according to instructions<br>found on plumbing behaviors. First, all instructions are gathered, then they are<br>applied in two stages: stage1: extension and stage2: pipelines, docstrings and<br>optional ``zope.interfaces``. There exists a class decorator ``plumbing`` which<br>should be used in favor of setting metaclass directly as of plumber 1.3.<br><br>.. contents::<br>    :local:<br><br><br>Plumbing behaviors provide instructions<br>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br><br>Plumbing behaviors correspond to mixins, but are more powerful and flexible. A<br>plumbing behavior needs to inherit from ``plumber.Behavior`` and declares <br>attributes with instructions on how to use them, here by example of the <br>``default`` instruction (more later).<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; from plumber import Behavior<br>    &gt;&gt;&gt; from plumber import default<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     a = default(True)<br>    ...<br>    ...     @default<br>    ...     def foo(self):<br>    ...         return 42<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     @default<br>    ...     @property<br>    ...     def bar(self):<br>    ...         return 17<br><br>The instructions are given as behavior of assignments (``a = default(None)``) <br>or as decorators (``@default``).<br><br>A plumbing declaration defines the ``plumber`` as metaclass and one or more<br>plumbing behaviors to be processed from left to right. Further it may declare<br>attributes like every normal class, they will be treated as implicit<br>``finalize`` instructions (see Stage 1: Extension).<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; from plumber import plumbing<br><br>    &gt;&gt;&gt; Base = dict<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(Base):<br>    ...<br>    ...     def foobar(self):<br>    ...         return 5<br><br>The result is a plumbing class created according to the plumbing declaration.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; plb = Plumbing()<br>    &gt;&gt;&gt; plb.a<br>    True<br>    &gt;&gt;&gt; plb.foo()<br>    42<br>    &gt;&gt;&gt; plb.bar<br>    17<br>    &gt;&gt;&gt; plb.foobar()<br>    5<br>    &gt;&gt;&gt; plb['a'] = 1<br>    &gt;&gt;&gt; plb['a']<br>    1<br><br>A plumbing class can be subclassed like normal classes.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Sub(Plumbing):<br>    ...     a = 'Sub'<br><br>    &gt;&gt;&gt; Sub.a<br>    'Sub'<br>    &gt;&gt;&gt; Sub().foo()<br>    42<br>    &gt;&gt;&gt; Sub().bar<br>    17<br>    &gt;&gt;&gt; Sub().foobar()<br>    5<br><br><br>The plumber gathers instructions<br>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br><br>A plumbing declaration provides a list of behaviors via the ``plumbing``<br>decorator. Behaviors provide instructions to be applied in two stages:<br><br>stage1<br>  - extension via ``default``, ``override`` and ``finalize``, the result of this<br>    stage is the base for stage2.<br><br>stage2<br>  - creation of pipelines via ``plumb`` and ``plumbifexists``<br>  - plumbing of docstrings<br>  - implemented interfaces from ``zope.interface``, iff available<br><br>The plumber walks the Behavior list from left to right (behavior order). On its<br>way it gathers instructions onto stacks, sorted by stage and attribute name. A <br>history of all instructions is kept.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; pprint(Plumbing.__plumbing_stacks__)<br>    {'history':<br>      [&lt;_implements '__interfaces__' of None payload=()&gt;,<br>       &lt;default 'a' of &lt;class 'Behavior1'&gt; payload=True&gt;,<br>       &lt;default 'foo' of &lt;class 'Behavior1'&gt; payload=&lt;function foo at 0x...&gt;&gt;,<br>       &lt;_implements '__interfaces__' of None payload=()&gt;,<br>       &lt;default 'bar' of &lt;class 'Behavior2'&gt; payload=&lt;property object at 0x...&gt;&gt;],<br>     'stages':<br>       {'stage1':<br>         {'a': [&lt;default 'a' of &lt;class 'Behavior1'&gt; payload=True&gt;],<br>          'bar': [&lt;default 'bar' of &lt;class 'Behavior2'&gt; payload=&lt;property ...<br>          'foo': [&lt;default 'foo' of &lt;class 'Behavior1'&gt; payload=&lt;function foo ...<br>        'stage2':<br>         {'__interfaces__': [&lt;_implements '__interfaces__' of None payload=()...<br><br>Before putting a new instruction onto a stack, it is compared with the latest<br>instruction on the stack. It is either taken as is, discarded, merged or a<br>``PlumbingCollision`` is raised. This is detailed in the following sections.<br><br>After all instructions are gathered onto the stacks, they are applied in two<br>stages taking declarations on the plumbing class and base classes into account.<br><br>The result of the first stage is the base for the application of the second<br>stage.<br><br>.. note:: The payload of an instruction is the attribute value passed to the<br>  instruction via function call or decoration. An instruction knows the<br>  behavior it is declared on.<br><br>.. note:: Behaviors are created by ``behaviormetaclass``. If ``zope.interface``<br>  is available, it will generate ``_implements`` instructions for each behavior.<br>  During behavior creation the interfaces are not yet implemented, they are<br>  checked at a later stage. Therefore the ``_implements`` instructions are <br>  generated even if the behaviors do not implement interfaces, which results in<br>  the empty tuple as payload (see also ``zope.interface support``.<br><br>.. warning:: Do not rely on this structure within your programs it might change<br>  at any time. If you need information from the ``__plumbing_stacks__`` or lack<br>  information in there, e.g. to create a plumbing inspector and earn yourself<br>  a box of your favorite beverage, please let us know.<br><br><br>Stage 1: Extension<br>^^^^^^^^^^^^^^^^^^<br><br>The extension stage creates endpoints for the pipelines created in stage 2. If<br>no pipeline uses the endpoint, it will just live on as a normal attribute in<br>the plumbing class' dictionary.<br><br>The extension decorators:<br><br>``finalize``<br>    ``finalize`` is the strongest extension instruction. It will override<br>    declarations on base classes and all other extension instructions<br>    (``override`` and ``default``). Attributes declared as behavior of the<br>    plumbing declaration are implicit ``finalize`` declarations. Two <br>    ``finalize`` for one attribute name will collide and raise a <br>    ``PlumbingCollision`` during class creation.<br><br>``override``<br>    ``override`` is weaker than ``finalize`` and overrides declarations on base<br>    classes and ``default`` declarations. Two ``override`` instructions for the<br>    same attribute name do not collide, instead the first one will be used.<br><br>``default``<br>    ``default`` is the weakest extension instruction. It will not even override<br>    declarations of base classes. The first default takes precendence over<br>    later defaults.<br><br>.. contents::<br>    :local:<br><br><br>Interaction: ``finalize``, plumbing declaration and base classes<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>In code.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; from plumber import finalize<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     N = finalize('Behavior1')<br>    ...<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     M = finalize('Behavior2')<br><br>    &gt;&gt;&gt; class Base(object):<br>    ...     K = 'Base'<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(Base):<br>    ...     L = 'Plumbing'<br><br>    &gt;&gt;&gt; for x in ['K', 'L', 'M', 'N']:<br>    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))<br>    K from Base<br>    L from Plumbing<br>    M from Behavior2<br>    N from Behavior1<br><br>summary:<br><br>- K-Q: attributes defined by behaviors, plumbing class and base classes<br>- f: ``finalize`` declaration<br>- x: declaration on plumbing class or base class<br>- ?: base class declaration is irrelevant<br>- **Y**: chosen end point<br>- collision: indicates an invalid combination, that raises a ``PlumbingCollision``<br><br>+------+-----------+-----------+----------+-------+-----------+<br>| Attr | Behavior1 | Behavior2 | Plumbing | Base  | ok?       |<br>+======+===========+===========+==========+=======+===========+<br>| K    |           |           |          | **x** |           |<br>+------+-----------+-----------+----------+-------+-----------+<br>| L    |           |           | **x**    | ?     |           |<br>+------+-----------+-----------+----------+-------+-----------+<br>| M    |           | **f**     |          | ?     |           |<br>+------+-----------+-----------+----------+-------+-----------+<br>| N    | **f**     |           |          | ?     |           |<br>+------+-----------+-----------+----------+-------+-----------+<br>| O    | f         |           | x        | ?     | collision |<br>+------+-----------+-----------+----------+-------+-----------+<br>| P    |           | f         | x        | ?     | collision |<br>+------+-----------+-----------+----------+-------+-----------+<br>| Q    | f         | f         |          | ?     | collision |<br>+------+-----------+-----------+----------+-------+-----------+<br><br>collisions.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     O = finalize(False)<br><br>    &gt;&gt;&gt; @plumbing(Behavior1)<br>    ... class Plumbing(object):<br>    ...     O = True<br>    Traceback (most recent call last):<br>      ...<br>    PlumbingCollision:<br>        Plumbing class<br>      with:<br>        &lt;finalize 'O' of &lt;class 'Behavior1'&gt; payload=False&gt;<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     P = finalize(False)<br><br>    &gt;&gt;&gt; @plumbing(Behavior2)<br>    ... class Plumbing(object):<br>    ...     P = True<br>    Traceback (most recent call last):<br>      ...<br>    PlumbingCollision:<br>        Plumbing class<br>      with:<br>        &lt;finalize 'P' of &lt;class 'Behavior2'&gt; payload=False&gt;<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     Q = finalize(False)<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     Q = finalize(True)<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(object):<br>    ...     pass<br>    Traceback (most recent call last):<br>      ...<br>    PlumbingCollision:<br>        &lt;finalize 'Q' of &lt;class 'Behavior1'&gt; payload=False&gt;<br>      with:<br>        &lt;finalize 'Q' of &lt;class 'Behavior2'&gt; payload=True&gt;<br><br><br>Interaction: ``override``, plumbing declaration and base classes<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>in code.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; from plumber import override<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     K = override('Behavior1')<br>    ...     M = override('Behavior1')<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     K = override('Behavior2')<br>    ...     L = override('Behavior2')<br>    ...     M = override('Behavior2')<br><br>    &gt;&gt;&gt; class Base(object):<br>    ...     K = 'Base'<br>    ...     L = 'Base'<br>    ...     M = 'Base'<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(Base):<br>    ...     K = 'Plumbing'<br><br>    &gt;&gt;&gt; for x in ['K', 'L', 'M']:<br>    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))<br>    K from Plumbing<br>    L from Behavior2<br>    M from Behavior1<br><br>summary:<br><br>- K-M: attributes defined by behaviors, plumbing class and base classes<br>- e: ``override`` declaration<br>- x: declaration on plumbing class or base class<br>- ?: base class declaration is irrelevant<br>- **Y**: chosen end point<br><br>+------+-----------+-----------+----------+------+<br>| Attr | Behavior1 | Behavior2 | Plumbing | Base |<br>+======+===========+===========+==========+======+<br>| K    | e         | e         | **x**    | ?    |<br>+------+-----------+-----------+----------+------+<br>| L    |           | **e**     |          | ?    |<br>+------+-----------+-----------+----------+------+<br>| M    | **e**     | e         |          | ?    |<br>+------+-----------+-----------+----------+------+<br><br><br>Interaction: ``default``, plumbing declaration and base class<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>in code.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     N = default('Behavior1')<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     K = default('Behavior2')<br>    ...     L = default('Behavior2')<br>    ...     M = default('Behavior2')<br>    ...     N = default('Behavior2')<br><br>    &gt;&gt;&gt; class Base(object):<br>    ...     K = 'Base'<br>    ...     L = 'Base'<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(Base):<br>    ...     L = 'Plumbing'<br><br>    &gt;&gt;&gt; for x in ['K', 'L', 'M', 'N']:<br>    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))<br>    K from Base<br>    L from Plumbing<br>    M from Behavior2<br>    N from Behavior1<br><br>summary:<br><br>- K-N: attributes defined by behaviors, plumbing class and base classes<br>- d = ``default`` declaration<br>- x = declaration on plumbing class or base class<br>- ? = base class declaration is irrelevant<br>- **Y** = chosen end point<br><br>+------+-----------+-----------+----------+-------+<br>| Attr | Behavior1 | Behavior2 | Plumbing | Base  |<br>+======+===========+===========+==========+=======+<br>| K    |           | d         |          | **x** |<br>+------+-----------+-----------+----------+-------+<br>| L    |           | d         | **x**    | ?     |<br>+------+-----------+-----------+----------+-------+<br>| M    |           | **d**     |          |       |<br>+------+-----------+-----------+----------+-------+<br>| N    | **d**     | d         |          |       |<br>+------+-----------+-----------+----------+-------+<br><br><br>Interaction: ``finalize`` wins over ``override``<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>in code.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     K = override('Behavior1')<br>    ...     L = finalize('Behavior1')<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     K = finalize('Behavior2')<br>    ...     L = override('Behavior2')<br><br>    &gt;&gt;&gt; class Base(object):<br>    ...     K = 'Base'<br>    ...     L = 'Base'<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(Base):<br>    ...     pass<br><br>    &gt;&gt;&gt; for x in ['K', 'L']:<br>    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))<br>    K from Behavior2<br>    L from Behavior1<br><br>summary:<br><br>- K-L: attributes defined by behaviors, plumbing class and base classes<br>- e = ``override`` declaration<br>- f = ``finalize`` declaration<br>- ? = base class declaration is irrelevant<br>- **Y** = chosen end point<br><br>+------+-----------+-----------+----------+------+<br>| Attr | Behavior1 | Behavior2 | Plumbing | Base |<br>+======+===========+===========+==========+======+<br>| K    | e         | **f**     |          | ?    |<br>+------+-----------+-----------+----------+------+<br>| L    | **f**     | e         |          | ?    |<br>+------+-----------+-----------+----------+------+<br><br><br>Interaction: ``finalize`` wins over ``default``:<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>in code.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     K = default('Behavior1')<br>    ...     L = finalize('Behavior1')<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     K = finalize('Behavior2')<br>    ...     L = default('Behavior2')<br><br>    &gt;&gt;&gt; class Base(object):<br>    ...     K = 'Base'<br>    ...     L = 'Base'<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(Base):<br>    ...     pass<br><br>    &gt;&gt;&gt; for x in ['K', 'L']:<br>    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))<br>    K from Behavior2<br>    L from Behavior1<br><br>summary:<br><br>- K-L: attributes defined by behaviors, plumbing class and base classes<br>- d = ``default`` declaration<br>- f = ``finalize`` declaration<br>- ? = base class declaration is irrelevant<br>- **Y** = chosen end point<br><br>+------+-----------+-----------+----------+------+<br>| Attr | Behavior1 | Behavior2 | Plumbing | Base |<br>+======+===========+===========+==========+======+<br>| K    | d         | **f**     |          | ?    |<br>+------+-----------+-----------+----------+------+<br>| L    | **f**     | d         |          | ?    |<br>+------+-----------+-----------+----------+------+<br><br><br>Interaction: ``override`` wins over ``default``<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>in code.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     K = default('Behavior1')<br>    ...     L = override('Behavior1')<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     K = override('Behavior2')<br>    ...     L = default('Behavior2')<br><br>    &gt;&gt;&gt; class Base(object):<br>    ...     K = 'Base'<br>    ...     L = 'Base'<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(Base):<br>    ...     pass<br><br>    &gt;&gt;&gt; for x in ['K', 'L']:<br>    ...     print \"%s from %s\" % (x, getattr(Plumbing, x))<br>    K from Behavior2<br>    L from Behavior1<br><br>summary:<br><br>- K-L: attributes defined by behaviors, plumbing class and base classes<br>- d = ``default`` declaration<br>- e = ``override`` declaration<br>- ? = base class declaration is irrelevant<br>- **Y** = chosen end point<br><br>+------+-----------+-----------+----------+------+<br>| Attr | Behavior1 | Behavior2 | Plumbing | Base |<br>+======+===========+===========+==========+======+<br>| K    | d         | **e**     |          | ?    |<br>+------+-----------+-----------+----------+------+<br>| L    | **e**     | d         |          | ?    |<br>+------+-----------+-----------+----------+------+<br><br><br>Subclassing Behaviors<br>~~~~~~~~~~~~~~~~~~~~~<br><br>in code.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     J = default('Behavior1')<br>    ...     K = default('Behavior1')<br>    ...     M = override('Behavior1')<br><br>    &gt;&gt;&gt; class Behavior2(Behavior1):<br>    ...     J = default('Behavior2') # overrides ``J`` of ``Behavior1``<br>    ...     L = default('Behavior2')<br>    ...     M = default('Behavior2') # this one wins, even if ``M`` on<br>    ...                              # superclass is ``override`` instruction.<br>    ...                              # due to ordinary inheritance behavior.<br><br>    &gt;&gt;&gt; @plumbing(Behavior2)<br>    ... class Plumbing(object):<br>    ...     pass<br><br>    &gt;&gt;&gt; plb = Plumbing()<br>    &gt;&gt;&gt; plb.J<br>    'Behavior2'<br><br>    &gt;&gt;&gt; plb.K<br>    'Behavior1'<br><br>    &gt;&gt;&gt; plb.L<br>    'Behavior2'<br><br>    &gt;&gt;&gt; plb.M<br>    'Behavior2'<br><br><br>Stage 2: Pipeline, docstrings and ``zope.interface`` instructions<br>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br><br>In stage1 plumbing class attributes were set, which can serve as endpoints for<br>plumbing pipelines that are build in stage2. Plumbing pipelines correspond to<br>``super``-chains. Docstrings of behaviors, methods in a pipeline and properties<br>in a pipeline are accumulated. Plumber is ``zope.interface`` aware and takes<br>implemeneted interfaces from behaviors, if it can be imported.<br><br>.. contents::<br>    :local:<br><br><br>Plumbing Pipelines in general<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>Elements for plumbing pipelines are declared with the ``plumb`` and<br>``plumbifexists`` decorators:<br><br>``plumb``<br>    Marks a method to be used as behavior of a plumbing pipeline.  The signature of<br>    such a plumbing method is ``def foo(_next, self, *args, **kw)``.  Via<br>    ``_next`` it is passed the next plumbing method to be called. ``self`` is<br>    an instance of the plumbing class, not the behavior.<br><br>``plumbifexists``<br>    Like ``plumb``, but only used if an endpoint exists.<br><br>The user of a plumbing class does not know which ``_next`` to pass. Therefore,<br>after the pipelines are built, an entrance method is generated for each pipe,<br>that wraps the first plumbing method passing it the correct ``_next``. Each<br>``_next`` method is an entrance to the rest of the pipeline.<br><br>The pipelines are build in behavior order, skipping behaviors that do not<br>define a pipeline element with the same attribute name::<br><br>    +---+-----------+-----------+-----------+----------+<br>    |   | Behavior1 | Behavior2 | Behavior3 | ENDPOINT |<br>    +---+-----------+-----------+-----------+----------+<br>    |   |      ---------------------------------&gt;      |<br>    | E |     x     |           |           |    x     |<br>    | N |      &lt;---------------------------------      |<br>    + T +-----------+-----------+-----------+----------+<br>    | R |      ----------&gt; ---------------------&gt;      |<br>    | A |     y     |     y     |           |    y     |<br>    | N |      &lt;---------- &lt;---------------------      |<br>    + C +-----------+-----------+-----------+----------+<br>    | E |           |           |      ---------&gt;      |<br>    | S |           |           |     z     |    z     |<br>    |   |           |           |      &lt;---------      |<br>    +---+-----------+-----------+-----------+----------+<br><br><br>Method pipelines<br>~~~~~~~~~~~~~~~~<br><br>Two plumbing behaviors and a ``dict`` as base class. ``Behavior1`` lowercases<br>keys before passing them on, ``Behavior2`` multiplies results before returning<br>them.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; from plumber import plumb<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     @plumb<br>    ...     def __getitem__(_next, self, key):<br>    ...         print \"Behavior1 start\"<br>    ...         key = key.lower()<br>    ...         ret = _next(self, key)<br>    ...         print \"Behavior1 stop\"<br>    ...         return ret<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     @plumb<br>    ...     def __getitem__(_next, self, key):<br>    ...         print \"Behavior2 start\"<br>    ...         ret = 2 * _next(self, key)<br>    ...         print \"Behavior2 stop\"<br>    ...         return ret<br><br>    &gt;&gt;&gt; Base = dict<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(Base):<br>    ...     pass<br><br>    &gt;&gt;&gt; plb = Plumbing()<br>    &gt;&gt;&gt; plb['abc'] = 6<br>    &gt;&gt;&gt; plb['AbC']<br>    Behavior1 start<br>    Behavior2 start<br>    Behavior2 stop<br>    Behavior1 stop<br>    12<br><br>Plumbing pipelines need endpoints. If no endpoint is available an<br>``AttributeError`` is raised.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     @plumb<br>    ...     def foo(_next, self):<br>    ...         pass<br><br>    &gt;&gt;&gt; @plumbing(Behavior1)<br>    ... class Plumbing(object):<br>    ...     pass<br>    Traceback (most recent call last):<br>      ...<br>    AttributeError: type object 'Plumbing' has no attribute 'foo'<br><br>If no endpoint is available and a behavior does not care about that,<br>``plumbifexists`` can be used to only plumb if an endpoint is available.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; from plumber import plumbifexists<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     @plumbifexists<br>    ...     def foo(_next, self):<br>    ...         pass<br>    ...<br>    ...     @plumbifexists<br>    ...     def bar(_next, self):<br>    ...         return 2 * _next(self)<br><br>    &gt;&gt;&gt; @plumbing(Behavior1)<br>    ... class Plumbing(object):<br>    ...<br>    ...     def bar(self):<br>    ...         return 6<br><br>    &gt;&gt;&gt; hasattr(Plumbing, 'foo')<br>    False<br>    &gt;&gt;&gt; Plumbing().bar()<br>    12<br><br>This enables one implementation of a certain behaviour, e.g. sending events for<br>dictionaries, to be used for readwrite dictionaries that implement<br>``__getitem__`` and ``__setitem__`` and readonly dictionaries, that only<br>implement ``__getitem__`` but no ``__setitem__``.<br><br><br>Property pipelines<br>~~~~~~~~~~~~~~~~~~<br><br>Plumbing of read only properties.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     @plumb<br>    ...     @property<br>    ...     def foo(_next, self):<br>    ...         return 2 * _next(self)<br><br>    &gt;&gt;&gt; @plumbing(Behavior1)<br>    ... class Plumbing(object):<br>    ...<br>    ...     @property<br>    ...     def foo(self):<br>    ...         return 3<br><br>    &gt;&gt;&gt; plb = Plumbing()<br>    &gt;&gt;&gt; plb.foo<br>    6<br><br>It is possible to extend a property with so far unset getter/setter/deleter.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     @plumb<br>    ...     @property<br>    ...     def foo(_next, self):<br>    ...         return 2 * _next(self)<br><br>    &gt;&gt;&gt; class Behavior2(Behavior):<br>    ...     def set_foo(self, value):<br>    ...         self._foo = value<br>    ...     foo = plumb(property(<br>    ...         None,<br>    ...         override(set_foo),<br>    ...         ))<br><br>    &gt;&gt;&gt; @plumbing(Behavior1, Behavior2)<br>    ... class Plumbing(object):<br>    ...<br>    ...     @property<br>    ...     def foo(self):<br>    ...         return self._foo<br><br>    &gt;&gt;&gt; plb = Plumbing()<br>    &gt;&gt;&gt; plb.foo = 4<br>    &gt;&gt;&gt; plb.foo<br>    8<br><br><br>Subclassing Behaviors<br>~~~~~~~~~~~~~~~~~~~~~<br><br>Other than stage 1 instructions, which extend a class with properties<br>and functions and thus override each other by the rules of ordinary<br>subclassing, pipeline instructions are aggregated.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ... <br>    ...     @plumb<br>    ...     def foo(_next, self):<br>    ...         return 'Behavior1 ' + _next(self)<br>    ... <br>    ...     @plumb<br>    ...     def bar(_next, self):<br>    ...         return 'Behavior1 ' + _next(self)<br><br>    &gt;&gt;&gt; class Behavior2(Behavior1):<br>    ... <br>    ...     @plumb<br>    ...     def foo(_next, self):<br>    ...         return 'Behavior2 ' + _next(self)<br><br>    &gt;&gt;&gt; @plumbing(Behavior2)<br>    ... class Plumbing(object):<br>    ... <br>    ...     def foo(self):<br>    ...         return 'foo'<br>    ... <br>    ...     def bar(self):<br>    ...         return 'bar'<br><br>    &gt;&gt;&gt; plb = Plumbing()<br>    &gt;&gt;&gt; plb.foo()<br>    'Behavior2 Behavior1 foo'<br>    <br>    &gt;&gt;&gt; plb.bar()<br>    'Behavior1 bar'<br><br><br>Mixing methods and properties within the same pipeline is not possible<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>Within a pipeline all elements need to be of the same type, it is not possible<br>to mix properties with methods.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class Behavior1(Behavior):<br>    ...     @plumb<br>    ...     def foo(_next, self):<br>    ...         return _next(self)<br><br>    &gt;&gt;&gt; @plumbing(Behavior1)<br>    ... class Plumbing(object):<br>    ...<br>    ...     @property<br>    ...     def foo(self):<br>    ...         return 5<br>    Traceback (most recent call last):<br>      ...<br>    PlumbingCollision:<br>        &lt;plumb 'foo' of &lt;class 'Behavior1'&gt; payload=&lt;function foo at 0x...&gt;&gt;<br>      with:<br>        &lt;class 'Plumbing'&gt;<br><br><br>docstrings of classes, methods and properties<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>Normal docstrings of the plumbing declaration and the behavior classes, plumbed<br>methods and plumbed properties are joined by newlines starting with the<br>plumbing declaration and followed by the behaviors in reverse order.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class P1(Behavior):<br>    ...     \"\"\"P1<br>    ...     \"\"\"<br>    ...     @plumb<br>    ...     def foo(self):<br>    ...         \"\"\"P1.foo<br>    ...         \"\"\"<br>    ...     bar = plumb(property(None, None, None, \"P1.bar\"))<br><br>    &gt;&gt;&gt; class P2(Behavior):<br>    ...     @override<br>    ...     def foo(self):<br>    ...         \"\"\"P2.foo<br>    ...         \"\"\"<br>    ...     bar = plumb(property(None, None, None, \"P2.bar\"))<br><br>    &gt;&gt;&gt; @plumbing(P1, P2)<br>    ... class Plumbing(object):<br>    ...     \"\"\"Plumbing<br>    ...     \"\"\"<br>    ...     bar = property(None, None, None, \"Plumbing.bar\")<br><br>    &gt;&gt;&gt; print Plumbing.__doc__<br>    Plumbing<br>    &lt;BLANKLINE&gt;<br>    P1<br>    &lt;BLANKLINE&gt;<br><br>    &gt;&gt;&gt; print Plumbing.foo.__doc__<br>    P2.foo<br>    &lt;BLANKLINE&gt;<br>    P1.foo<br>    &lt;BLANKLINE&gt;<br><br>    &gt;&gt;&gt; print Plumbing.bar.__doc__<br>    Plumbing.bar<br>    &lt;BLANKLINE&gt;<br>    P2.bar<br>    &lt;BLANKLINE&gt;<br>    P1.bar<br><br>The accumulation of docstrings is an experimental feature and will probably<br>change.<br><br><br>Slots and plumbings<br>~~~~~~~~~~~~~~~~~~~<br><br>A plumbing class can have __slots__ like normal classes.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class P1(Behavior):<br>    ...     @default<br>    ...     def somewhing_which_writes_to_foo(self, foo_val):<br>    ...         self.foo = foo_val<br><br>    &gt;&gt;&gt; @plumbing(P1)<br>    ... class WithSlots(object):<br>    ...     __slots__ = 'foo'<br><br>    &gt;&gt;&gt; WithSlots.__dict__['foo']<br>    &lt;member 'foo' of 'WithSlots' objects&gt;<br><br>    &gt;&gt;&gt; ob = WithSlots()<br>    &gt;&gt;&gt; ob.somewhing_which_writes_to_foo('foo')<br>    &gt;&gt;&gt; assert(ob.foo == 'foo')<br><br><br>``zope.interface`` (if available)<br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>The plumber does not depend on ``zope.interface`` but is aware of it. That<br>means it will try to import it and if available will check plumbing behaviors<br>for implemented interfaces and will make the plumbing implement them, too.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; from zope.interface import Interface<br>    &gt;&gt;&gt; from zope.interface import implementer<br><br>A class with an interface that will serve as base class of a plumbing.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class IBase(Interface):<br>    ...     pass<br><br>    &gt;&gt;&gt; @implementer(IBase)<br>    ... class Base(object):<br>    ...     pass<br><br>    &gt;&gt;&gt; IBase.implementedBy(Base)<br>    True<br><br>Two behaviors with corresponding interfaces, one with a base class that also<br>implements an interface.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class IBehavior1(Interface):<br>    ...     pass<br><br>    &gt;&gt;&gt; @implementer(IBehavior1)<br>    ... class Behavior1(Behavior):<br>    ...     blub = 1<br><br>    &gt;&gt;&gt; class IBehavior2Base(Interface):<br>    ...     pass<br><br>    &gt;&gt;&gt; @implementer(IBehavior2Base)<br>    ... class Behavior2Base(Behavior):<br>    ...     pass<br><br>    &gt;&gt;&gt; class IBehavior2(Interface):<br>    ...     pass<br><br>    &gt;&gt;&gt; @implementer(IBehavior2)<br>    ... class Behavior2(Behavior2Base):<br>    ...     pass<br><br>    &gt;&gt;&gt; IBehavior1.implementedBy(Behavior1)<br>    True<br><br>    &gt;&gt;&gt; IBehavior2Base.implementedBy(Behavior2Base)<br>    True<br><br>    &gt;&gt;&gt; IBehavior2Base.implementedBy(Behavior2)<br>    True<br><br>    &gt;&gt;&gt; IBehavior2.implementedBy(Behavior2)<br>    True<br><br>A plumbing based on ``Base`` using ``Behavior1`` and ``Behavior2`` and<br>implementing ``IPlumbingClass``.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class IPlumbingClass(Interface):<br>    ...     pass<br><br>    &gt;&gt;&gt; @implementer(IPlumbingClass)<br>    ... @plumbing(Behavior1, Behavior2)<br>    ... class PlumbingClass(Base):<br>    ...     pass<br><br>The directly declared and inherited interfaces are implemented.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; IPlumbingClass.implementedBy(PlumbingClass)<br>    True<br><br>    &gt;&gt;&gt; IBase.implementedBy(PlumbingClass)<br>    True<br><br>The interfaces implemented by the Behaviors are also implemented.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; IBehavior1.implementedBy(PlumbingClass)<br>    True<br><br>    &gt;&gt;&gt; IBehavior2.implementedBy(PlumbingClass)<br>    True<br><br>    &gt;&gt;&gt; IBehavior2Base.implementedBy(PlumbingClass)<br>    True<br><br>An instance of the class provides the interfaces.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; plumbing = PlumbingClass()<br><br>    &gt;&gt;&gt; IPlumbingClass.providedBy(plumbing)<br>    True<br><br>    &gt;&gt;&gt; IBase.providedBy(plumbing)<br>    True<br><br>    &gt;&gt;&gt; IBehavior1.providedBy(plumbing)<br>    True<br><br>    &gt;&gt;&gt; IBehavior2.providedBy(plumbing)<br>    True<br><br>    &gt;&gt;&gt; IBehavior2Base.providedBy(plumbing)<br>    True<br><br><br>plumber metaclass hooks<br>~~~~~~~~~~~~~~~~~~~~~~~<br><br>In case one writes a plumbing behavior requiring class manipulation at plumber<br>metaclass execution time a decorator is provided for registering callbacks<br>which are executed at the end of the plumber metaclass ``__init__`` function.<br>Executing at last task ensures stage 1 and stage 2 instructions already have<br>been executed and we're working on a complete plumbing class.<br><br>.. code-block:: pycon<br><br>    &gt;&gt;&gt; class IBehaviorInterface(Interface):<br>    ...     pass<br><br>    &gt;&gt;&gt; @plumber.metaclasshook<br>    ... def test_metclass_hook(cls, name, bases, dct):<br>    ...     if not IBehaviorInterface.implementedBy(cls):<br>    ...         return<br>    ...     cls.hooked = True<br><br>    &gt;&gt;&gt; @implementer(IBehaviorInterface)<br>    ... class MetaclassConsideredBehavior(Behavior):<br>    ...     pass<br><br>    &gt;&gt;&gt; @plumbing(MetaclassConsideredBehavior)<br>    ... class Plumbing(object):<br>    ...     pass<br><br>    &gt;&gt;&gt; Plumbing.hooked<br>    True<br><br><br>Miscellanea<br>-----------<br><br>Nomenclature<br>^^^^^^^^^^^^<br><br>**``plumber``**<br>    Metaclass that creates a plumbing according to the instructions declared on<br>    plumbing behaviors. Instructions are given by decorators: ``default``,<br>    ``override``, ``finalize``, ``plumb`` and ``plumbifexists``.<br><br>**plumbing**<br>    A plumbing is a class decorated by ``plumbing`` decorator which gets passed<br>    the behviors to apply, e.g. ``@plumbing(Behavior1, Behavior2)``. Apart from<br>    the behaviors, declarations on base classes and the class asking for the<br>    plumber are taken into account. Once created, a plumbing looks like any<br>    other class and can be subclassed as usual.<br><br>**plumbing behavior**<br>    A plumbing behavior provides attributes (functions, properties and plain<br>    values) along with instructions for how to use them. Instructions are given<br>    via decorators: ``default``, ``override``, ``finalize``, ``plumb`` and<br>    ``plumbifexists`` (see Stage 1:... and Stage 2:...).<br><br>**plumbing pipeline**<br>    Plumbing methods/properties with the same name form a pipeline. The<br>    entrance and end-point have the signature of normal methods: ``def<br>    foo(self, *args, **kw)``. The plumbing pipelines is a series of nested<br>    closures (see ``_next``).<br><br>**entrance (method)**<br>    A method with a normal signature. i.e. expecting ``self`` as first<br>    argument, that is used to enter a pipeline. It is a ``_next`` function. A<br>    method declared on the class with the same name, will be overwritten, but<br>    referenced in the pipelines as the innermost method, the endpoint.<br><br>**``_next`` function**<br>    The ``_next`` function is used to call the next method in a pipelines: in<br>    case of a plumbing method, it is a wrapper of it that passes the correct<br>    next ``_next`` as first argument and in case of an end-point, just the<br>    end-point method itself.<br><br>**end-point (method)**<br>    Method retrieved from the plumbing class with ``getattr()``, before setting<br>    the entrance method on the class.<br><br>If you feel something is missing, please let us now or write a short<br>corresponding text.<br><br><br>Test Coverage<br>^^^^^^^^^^^^^<br><br>.. image:: https://travis-ci.org/bluedynamics/plumber.svg?branch=master<br>    :target: https://travis-ci.org/bluedynamics/plumber<br><br>Coverage report::<br><br>    Name                                      Stmts   Miss  Cover<br>    -------------------------------------------------------------<br>    src/plumber/__init__.py                      10      0   100%<br>    src/plumber/behavior.py                      49      0   100%<br>    src/plumber/compat.py                         9      0   100%<br>    src/plumber/exceptions.py                     6      0   100%<br>    src/plumber/instructions.py                 172      0   100%<br>    src/plumber/plumber.py                       71      0   100%<br>    src/plumber/tests/__init__.py               574      0   100%<br>    src/plumber/tests/globalmetaclass.py         15      0   100%<br>    -------------------------------------------------------------<br>    TOTAL                                      1882      0   100%<br><br><br>Python Versions<br>^^^^^^^^^^^^^^^<br><br>- Python 2.6+, 3.3+, pypy<br><br>- May work with other versions (untested)<br><br><br>Contributors<br>^^^^^^^^^^^^<br><br>- Florian Friesdorf<br><br>- Robert Niederreiter<br><br>- Jens W. Klein<br><br>- Marco Lempen<br><br>- Attila Ol\u00e1h<br><br><br>Changes<br>-------<br><br>1.5 (unreleased)<br>~~~~~~~~~~~~~~~~<br><br>- Introduce ``plumber.metaclasshook`` decorator.<br>  [rnix, 2017-06-16]<br><br><br>1.4<br>~~~<br><br>- No more \"private\" module names.<br>  [rnix, 2017-05-21]<br><br>- Python 3 support.<br>  [rnix, 2017-05-18]<br><br><br>1.3.1<br>~~~~~<br><br>- Avoid use of deprecated ``dict.has_key``.<br>  [rnix, 2015-10-05]<br><br><br>1.3<br>~~~<br><br>- Introduce ``plumbing`` decorator.<br>  [rnix, 2014-07-31]<br><br>- Remove deprecated ``plumber.extend`` and ``plumber.Part``.<br>  [rnix, 2014-07-31]<br><br><br>1.2<br>~~~<br><br>- Deprecate ``plumber.extend``. Use ``plumber.override`` instead.<br>  [rnix, 2012-07-28]<br><br>- Deprecate ``plumber.Part``. Use ``plumber.Behavior`` instead.<br>  [rnix, 2012-07-28]<br><br><br>1.1<br>~~~<br><br>- Use ``zope.interface.implementer`` instead of ``zope.interface.implements``.<br>  [rnix, 2012-05-18]<br><br><br>1.0<br>~~~<br><br>- ``.. plbnext::`` instead of ``.. plb_next::``<br>  [chaoflow 2011-02-02]<br><br>- stage1 in __new__, stage2 in __init__, setting of __name__ now works<br>  [chaoflow 2011-01-25]<br><br>- instructions recognize equal instructions<br>  [chaoflow 2011-01-24]<br><br>- instructions from base classes now like subclass inheritance [chaoflow 2011<br>  [chaoflow 2011-01-24]<br><br>- doctest order now plumbing order: P1, P2, PlumbingClass, was PlumbingClass,<br>  P1, P2<br>  [chaoflow 2011-01-24]<br><br>- merged docstring instruction into plumb<br>  [chaoflow 2011-01-24]<br><br>- plumber instead of Plumber<br>  [chaoflow 2011-01-24]<br><br>- plumbing methods are not classmethods of part anymore<br>  [chaoflow 2011-01-24]<br><br>- complete rewrite<br>  [chaoflow 2011-01-22]<br><br>- prt instead of cls<br>  [chaoflow, rnix 2011-01-19<br><br>- default, extend, plumb<br>  [chaoflow, rnix 2011-01-19]<br><br>- initial<br>  [chaoflow, 2011-01-04]<br><br><br>License / Disclaimer<br>--------------------<br><br>Copyright (c) 2011-2017, BlueDynamics Alliance, Austria, Germany, Switzerland<br>All rights reserved.<br><br>Redistribution and use in source and binary forms, with or without<br>modification, are permitted provided that the following conditions are met:<br><br>* Redistributions of source code must retain the above copyright notice, this<br>  list of conditions and the following disclaimer.<br>* Redistributions in binary form must reproduce the above copyright notice, this<br>  list of conditions and the following disclaimer in the documentation and/or<br>  other materials provided with the distribution.<br>* Neither the name of the BlueDynamics Alliance nor the names of its<br>  contributors may be used to endorse or promote products derived from this<br>  software without specific prior written permission.<br><br>THIS SOFTWARE IS PROVIDED BY BlueDynamics Alliance ``AS IS`` AND ANY<br>EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED<br>WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE<br>DISCLAIMED. IN NO EVENT SHALL BlueDynamics Alliance BE LIABLE FOR ANY<br>DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES<br>(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<br>LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<br>ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT<br>(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS<br>SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n          </div>"}, "last_serial": 3030725, "releases": {"0": [], "1.0": [{"comment_text": "", "digests": {"md5": "1223521e9baff4619038c630b130cef5", "sha256": "2803c1fb21e910c6caa404044d0c0230b917956ca0f43e42d5b08ec821fcad11"}, "downloads": -1, "filename": "plumber-1.0.tar.gz", "has_sig": false, "md5_digest": "1223521e9baff4619038c630b130cef5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43168, "upload_time": "2011-02-04T23:23:10", "upload_time_iso_8601": "2011-02-04T23:23:10.430776Z", "url": "https://files.pythonhosted.org/packages/52/c8/620a649ffac8899cb81c0cd7a3aeab9fe3fd7a0264f306fe57921ffb966c/plumber-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "8206685946474c84440164553e6be73b", "sha256": "11d01d7712c10ecc192a7b3d7bd1845cb6fa5e574b884ad524ba7d4ec5ce0248"}, "downloads": -1, "filename": "plumber-1.1.tar.gz", "has_sig": false, "md5_digest": "8206685946474c84440164553e6be73b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36248, "upload_time": "2012-05-29T17:24:05", "upload_time_iso_8601": "2012-05-29T17:24:05.329599Z", "url": "https://files.pythonhosted.org/packages/88/76/f8eccd598cee2e2061fa006cedc8a7390e4e7557f350ba9d9bc9ce333acd/plumber-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "79c1c5374c15e3f10eefbb898fef6665", "sha256": "2279cad4177fc27b9af8d29d6a7ef2e643af9d8d60216698d8275cc9d3d66fb9"}, "downloads": -1, "filename": "plumber-1.2.tar.gz", "has_sig": false, "md5_digest": "79c1c5374c15e3f10eefbb898fef6665", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34093, "upload_time": "2012-08-01T11:00:14", "upload_time_iso_8601": "2012-08-01T11:00:14.400811Z", "url": "https://files.pythonhosted.org/packages/23/71/aaff51f5c7e2717a76e623a1c1e22d1dac94730fe75e13e5cf42363917bf/plumber-1.2.tar.gz", "yanked": false}], "1.3": [{"comment_text": "", "digests": {"md5": "f7d13c5fd742a9b96b7c4a5d2b7acc30", "sha256": "efd85ecb834caa1e903d7ba1c689dff7f72e8547a580a4ca1edff2b889374c4c"}, "downloads": -1, "filename": "plumber-1.3.tar.gz", "has_sig": false, "md5_digest": "f7d13c5fd742a9b96b7c4a5d2b7acc30", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36104, "upload_time": "2014-08-06T18:07:16", "upload_time_iso_8601": "2014-08-06T18:07:16.562764Z", "url": "https://files.pythonhosted.org/packages/cd/b4/f190d0cc0421f9629737cfada55487145a41eb77d3d525f3e91417e14f5b/plumber-1.3.tar.gz", "yanked": false}], "1.3.1": [{"comment_text": "", "digests": {"md5": "e95c207e79d5c6d9afe2f9a58b2dc578", "sha256": "83201696b04e07cf5f53759f39756a6d3e93e78242de4d9b27c129a888a41e4d"}, "downloads": -1, "filename": "plumber-1.3.1.tar.gz", "has_sig": false, "md5_digest": "e95c207e79d5c6d9afe2f9a58b2dc578", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36352, "upload_time": "2015-10-08T08:54:33", "upload_time_iso_8601": "2015-10-08T08:54:33.546628Z", "url": "https://files.pythonhosted.org/packages/b6/66/f409c66b025fec583ae3af7a39aa4c529f8638c3207c39d658b43d03737e/plumber-1.3.1.tar.gz", "yanked": false}], "1.4": [{"comment_text": "", "digests": {"md5": "5aa8d31110b957e4d0a206e1df0a5b24", "sha256": "9629f8cf7d0eef98aa9fa652f7bf577f1a35aeeb4db508049dfa4945fe05b286"}, "downloads": -1, "filename": "plumber-1.4.tar.gz", "has_sig": false, "md5_digest": "5aa8d31110b957e4d0a206e1df0a5b24", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40266, "upload_time": "2017-06-07T10:13:32", "upload_time_iso_8601": "2017-06-07T10:13:32.532676Z", "url": "https://files.pythonhosted.org/packages/d8/32/a5d646f582e17635b77d8f96a9d541de6ccc2ed6d1c3b00aa8c13c3e7130/plumber-1.4.tar.gz", "yanked": false}], "1.5": [{"comment_text": "", "digests": {"md5": "219c87d8b80fe5f0c6c0801611a60fc6", "sha256": "229d1cb754fdc07c62d831f62eb32c7a71727738d4a6b3a298e587156eea4093"}, "downloads": -1, "filename": "plumber-1.5.tar.gz", "has_sig": false, "md5_digest": "219c87d8b80fe5f0c6c0801611a60fc6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41313, "upload_time": "2017-07-18T08:25:51", "upload_time_iso_8601": "2017-07-18T08:25:51.680619Z", "url": "https://files.pythonhosted.org/packages/a0/55/cad009be81ca45a748a8f3e435171b0e43f276c04a5d5f871ca0b1603511/plumber-1.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "219c87d8b80fe5f0c6c0801611a60fc6", "sha256": "229d1cb754fdc07c62d831f62eb32c7a71727738d4a6b3a298e587156eea4093"}, "downloads": -1, "filename": "plumber-1.5.tar.gz", "has_sig": false, "md5_digest": "219c87d8b80fe5f0c6c0801611a60fc6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41313, "upload_time": "2017-07-18T08:25:51", "upload_time_iso_8601": "2017-07-18T08:25:51.680619Z", "url": "https://files.pythonhosted.org/packages/a0/55/cad009be81ca45a748a8f3e435171b0e43f276c04a5d5f871ca0b1603511/plumber-1.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:52:26 2020"}