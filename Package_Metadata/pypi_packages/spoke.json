{"info": {"author": "Ben Holzman", "author_email": "ben.holzman@axial.net", "bugtrack_url": null, "classifiers": [], "description": "=====\nSpoke\n=====\n\nSpoke provides a framework for building reusable front-end components.\n\nInstalling\n==========\n\nThe spoke project lives on github_, and is available via pip_.\n\n.. _github: https://github.com/axialmarket/spoke\n.. _pip: https://pypi.python.org/pypi/spoke/0.2\n\nInstalling v0.2 From Pip\n------------------------\n\n::\n\n    sudo pip install spoke==0.2\n\nInstalling v0.2 From Source\n---------------------------\n\n::\n\n    curl https://github.com/axialmarket/spoke/archive/version_0.2.tar.gz | tar vzxf -\n    cd spoke\n    sudo python setup.py install\n\n\nWhat is a Spoke?\n================\n\nA spoke is an executable javascript file that can contain javascript, CSS and HTML templates. In addition, a spoke can have dependencies on other spokes, which allows us to partition front-end components into small discrete chunks and at build time create a single loadable javascript file for a page that includes just the functionality we need. Now, you may be wondering how we embed CSS and HTML templates into an executable javascript file. We're using a somewhat unsophisticated approach; we URI-encode the CSS or HTML content into a string and embed it in some simple javascript that decodes the content and dynamically adds it to the DOM.\n\nA simple example\n================\n\nLet's create a spoke for rendering a user's name. This perhaps sounds like it's too simple a task, but there could be some complexity to the logic required:\n\n- To save space, if the user's full name would be more than 20 characters, we will render just their first initial followed by their last name.\n- If the user is an internal user, we want to annotate their name with (internal).\n- If the user is an internal user masquerading as a regular user, we want to annotate their name with (masq).\n\nFor this example, we will use a Backbone model and view, and an Underscore template, but these are implementation choices and not imposed on us just because we are creating a spoke.\n\nHere is the Backbone model we will use:\n\n::\n\n    var UsernameModel = Backbone.Model.extend({\n        defaults: { first_name: \"\",\n         last_name: \"\",\n         is_internal: false,\n                        is_masq: false }\n    });\n\nThe view is pretty straightforward:\n\n::\n\n    var UsernameView = Backbone.View.extend({\n        className: 'username',\n        render: function() {\n            this.$el.html(this.template(this.model.attributes));\n            return this;\n        },\n        template: _.template($('#username-template').html())\n    });\n\n\nWe will store the Underscore template in a <script> tag with type \"text/template\":\n\n::\n\n    <script id=\"username-template\" type=\"text/template\">\n        <% if (first_name.length + last_name.length >= 20) { %>\n            <%= first_name.substr(0,1) %>.\n        <% } else { %>\n            <%= first_name %>\n        <% } >\n        <%= last_name %>\n        <% if (is_internal) { %>(internal)<% } %>\n    <% else if (is_masq) { %>(masq)<% } %> \n    </script>\n\nIn addition, we have a CSS file to control the styling of the username:\n\n::\n\n    .username {\n        font-size: 18px;\n        color: #333;\n            white-space: nowrap;\n    }\n\nTo turn this into a spoke, all we have to do is store these source files in the spoke source tree, which is in /var/spoke/:\n\n::\n\n    js/models/Username.js\n    js/views/Username.js\n    html/username.html.tpl\n    css/username.css\n\nThen we add a definition for this spoke (which we will call, surprise, surprise, \"username\") to a spoke config, which we add to /etc/spoke/:\n\n::\n\n    # /etc/spoke/username.cfg\n    [username]\n    js     = [ 'models/Username.js', 'views/Username.js' ]\n    html   = 'username.html.tpl'\n    css    = 'username.css'\n    spokes = 'backbone'\n\nSpokes do not need to have all of these types of files; a spoke might contain only CSS or only javascript content. Note, also, that we have made the \"username\" spoke dependent on the \"backbone\" spoke. The definition of the \"backbone\" spoke in turn references the \"underscore\" spoke. When we use spokec to generate a spoke, these dependencies are followed and included in the output. As you probably anticipate, if a spoke is referenced multiple times, it only gets included in the output once.\n\nNow that we've defined this spoke, here's how we would call spokec to generate it:\n\n::\n\n    spokec username [add'l spokes] -o path/to/output.js\n\nEach invocation of spokec generates a single executable javascript file containing all of the specified spokes and their dependencies. So typically a service will create a single spoke file for all of its pages, or sometimes a few different spoke files if the pages that service provides are significantly different.\n\nFor More Help\n=============\n\n::\n\n    spokec --help\n\nLicense\n=======\n\nBSD 3-Clause, see LICENSE.txt_.\n\n.. _LICENSE.txt: https://github.com/axialmarket/spoke/LICENSE.txt\n\nAuthors\n=======\n\n| Ben Holzman <ben.holzman@axial.net>\n| Matthew Story <matt.story@axial.net>", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/axialmarket/spoke", "keywords": null, "license": "3-BSD", "maintainer": null, "maintainer_email": null, "name": "spoke", "package_url": "https://pypi.org/project/spoke/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/spoke/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/axialmarket/spoke"}, "release_url": "https://pypi.org/project/spoke/0.2/", "requires_dist": null, "requires_python": null, "summary": "Spoke -- Reusable Front-End Components", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Spoke provides a framework for building reusable front-end components.</p>\n<div id=\"installing\">\n<h2>Installing</h2>\n<p>The spoke project lives on <a href=\"https://github.com/axialmarket/spoke\" rel=\"nofollow\">github</a>, and is available via <a href=\"https://pypi.python.org/pypi/spoke/0.2\" rel=\"nofollow\">pip</a>.</p>\n<div id=\"installing-v0-2-from-pip\">\n<h3>Installing v0.2 From Pip</h3>\n<pre>sudo pip install spoke==0.2\n</pre>\n</div>\n<div id=\"installing-v0-2-from-source\">\n<h3>Installing v0.2 From Source</h3>\n<pre>curl https://github.com/axialmarket/spoke/archive/version_0.2.tar.gz | tar vzxf -\ncd spoke\nsudo python setup.py install\n</pre>\n</div>\n</div>\n<div id=\"what-is-a-spoke\">\n<h2>What is a Spoke?</h2>\n<p>A spoke is an executable javascript file that can contain javascript, CSS and HTML templates. In addition, a spoke can have dependencies on other spokes, which allows us to partition front-end components into small discrete chunks and at build time create a single loadable javascript file for a page that includes just the functionality we need. Now, you may be wondering how we embed CSS and HTML templates into an executable javascript file. We\u2019re using a somewhat unsophisticated approach; we URI-encode the CSS or HTML content into a string and embed it in some simple javascript that decodes the content and dynamically adds it to the DOM.</p>\n</div>\n<div id=\"a-simple-example\">\n<h2>A simple example</h2>\n<p>Let\u2019s create a spoke for rendering a user\u2019s name. This perhaps sounds like it\u2019s too simple a task, but there could be some complexity to the logic required:</p>\n<ul>\n<li>To save space, if the user\u2019s full name would be more than 20 characters, we will render just their first initial followed by their last name.</li>\n<li>If the user is an internal user, we want to annotate their name with (internal).</li>\n<li>If the user is an internal user masquerading as a regular user, we want to annotate their name with (masq).</li>\n</ul>\n<p>For this example, we will use a Backbone model and view, and an Underscore template, but these are implementation choices and not imposed on us just because we are creating a spoke.</p>\n<p>Here is the Backbone model we will use:</p>\n<pre>var UsernameModel = Backbone.Model.extend({\n    defaults: { first_name: \"\",\n     last_name: \"\",\n     is_internal: false,\n                    is_masq: false }\n});\n</pre>\n<p>The view is pretty straightforward:</p>\n<pre>var UsernameView = Backbone.View.extend({\n    className: 'username',\n    render: function() {\n        this.$el.html(this.template(this.model.attributes));\n        return this;\n    },\n    template: _.template($('#username-template').html())\n});\n</pre>\n<p>We will store the Underscore template in a &lt;script&gt; tag with type \u201ctext/template\u201d:</p>\n<pre>&lt;script id=\"username-template\" type=\"text/template\"&gt;\n    &lt;% if (first_name.length + last_name.length &gt;= 20) { %&gt;\n        &lt;%= first_name.substr(0,1) %&gt;.\n    &lt;% } else { %&gt;\n        &lt;%= first_name %&gt;\n    &lt;% } &gt;\n    &lt;%= last_name %&gt;\n    &lt;% if (is_internal) { %&gt;(internal)&lt;% } %&gt;\n&lt;% else if (is_masq) { %&gt;(masq)&lt;% } %&gt;\n&lt;/script&gt;\n</pre>\n<p>In addition, we have a CSS file to control the styling of the username:</p>\n<pre>.username {\n    font-size: 18px;\n    color: #333;\n        white-space: nowrap;\n}\n</pre>\n<p>To turn this into a spoke, all we have to do is store these source files in the spoke source tree, which is in /var/spoke/:</p>\n<pre>js/models/Username.js\njs/views/Username.js\nhtml/username.html.tpl\ncss/username.css\n</pre>\n<p>Then we add a definition for this spoke (which we will call, surprise, surprise, \u201cusername\u201d) to a spoke config, which we add to /etc/spoke/:</p>\n<pre># /etc/spoke/username.cfg\n[username]\njs     = [ 'models/Username.js', 'views/Username.js' ]\nhtml   = 'username.html.tpl'\ncss    = 'username.css'\nspokes = 'backbone'\n</pre>\n<p>Spokes do not need to have all of these types of files; a spoke might contain only CSS or only javascript content. Note, also, that we have made the \u201cusername\u201d spoke dependent on the \u201cbackbone\u201d spoke. The definition of the \u201cbackbone\u201d spoke in turn references the \u201cunderscore\u201d spoke. When we use spokec to generate a spoke, these dependencies are followed and included in the output. As you probably anticipate, if a spoke is referenced multiple times, it only gets included in the output once.</p>\n<p>Now that we\u2019ve defined this spoke, here\u2019s how we would call spokec to generate it:</p>\n<pre>spokec username [add'l spokes] -o path/to/output.js\n</pre>\n<p>Each invocation of spokec generates a single executable javascript file containing all of the specified spokes and their dependencies. So typically a service will create a single spoke file for all of its pages, or sometimes a few different spoke files if the pages that service provides are significantly different.</p>\n</div>\n<div id=\"for-more-help\">\n<h2>For More Help</h2>\n<pre>spokec --help\n</pre>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>BSD 3-Clause, see <a href=\"https://github.com/axialmarket/spoke/LICENSE.txt\" rel=\"nofollow\">LICENSE.txt</a>.</p>\n</div>\n<div id=\"authors\">\n<h2>Authors</h2>\n<div>\n<div>Ben Holzman &lt;<a href=\"mailto:ben.holzman%40axial.net\">ben<span>.</span>holzman<span>@</span>axial<span>.</span>net</a>&gt;</div>\n<div>Matthew Story &lt;<a href=\"mailto:matt.story%40axial.net\">matt<span>.</span>story<span>@</span>axial<span>.</span>net</a>&gt;</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 991722, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "5afd4f432a97ea82abca9b44aaee8b7b", "sha256": "da97e06a54d047cebff1bec029d39de616bab666c4c9f3b9b33bb13b801ffe0e"}, "downloads": -1, "filename": "spoke-0.1.tar.gz", "has_sig": false, "md5_digest": "5afd4f432a97ea82abca9b44aaee8b7b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7291, "upload_time": "2014-01-28T00:44:27", "upload_time_iso_8601": "2014-01-28T00:44:27.594328Z", "url": "https://files.pythonhosted.org/packages/9a/da/1c90342204b7de62ad253e3ea1ba160e3367b247d6a2c228ab12b9dedcea/spoke-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "9b602bf9ebb42a74fb20fc146428a7e7", "sha256": "8d70779cf2f492d681822f0031d54f9922aa52cfc549af4ae85eb658b73a1bb7"}, "downloads": -1, "filename": "spoke-0.2.tar.gz", "has_sig": false, "md5_digest": "9b602bf9ebb42a74fb20fc146428a7e7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6958, "upload_time": "2014-02-05T21:36:50", "upload_time_iso_8601": "2014-02-05T21:36:50.641581Z", "url": "https://files.pythonhosted.org/packages/1d/db/d3de28690cf67aa7487f5f66aaafcb93fc5faecbaf05a85e1cfb1c93b9a5/spoke-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9b602bf9ebb42a74fb20fc146428a7e7", "sha256": "8d70779cf2f492d681822f0031d54f9922aa52cfc549af4ae85eb658b73a1bb7"}, "downloads": -1, "filename": "spoke-0.2.tar.gz", "has_sig": false, "md5_digest": "9b602bf9ebb42a74fb20fc146428a7e7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6958, "upload_time": "2014-02-05T21:36:50", "upload_time_iso_8601": "2014-02-05T21:36:50.641581Z", "url": "https://files.pythonhosted.org/packages/1d/db/d3de28690cf67aa7487f5f66aaafcb93fc5faecbaf05a85e1cfb1c93b9a5/spoke-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:04:37 2020"}