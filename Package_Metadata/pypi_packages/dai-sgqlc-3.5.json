{"info": {"author": "D", "author_email": "d@example.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: ISC License (ISCL)", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Utilities"], "description": "`sgqlc` - Simple GraphQL Client\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. image:: https://travis-ci.com/profusion/sgqlc.svg?branch=master\n    :target: https://travis-ci.com/profusion/sgqlc\n\n.. image:: https://coveralls.io/repos/github/profusion/sgqlc/badge.svg?branch=master\n    :target: https://coveralls.io/github/profusion/sgqlc?branch=master\n\nIntroduction\n------------\n\nThis package offers an easy to use `GraphQL <http://graphql.org>`_\nclient. It's composed of the following modules:\n\n- :literal:`sgqlc.types`: declare GraphQL in Python, base to generate and\n  interpret queries. Submodule :literal:`sgqlc.types.datetime` will\n  provide bindings for :literal:`datetime` and ISO 8601, while\n  :literal:`sgqlc.types.relay` will expose ``Node``, ``PageInfo`` and\n  ``Connection``.\n\n- :literal:`sgqlc.operation`: use declared types to generate and\n  interpret queries.\n\n- :literal:`sgqlc.endpoint`: provide access to GraphQL endpoints, notably\n  :literal:`sgqlc.endpoint.http` provides :literal:`HTTPEndpoint` using\n  :literal:`urllib.request.urlopen()`.\n\n\nWhat's GraphQL?\n===============\n\nStraight from http://graphql.org:\n\n   **A query language for your API**\n\n   GraphQL is a query language for APIs and a runtime for fulfilling\n   those queries with your existing data. GraphQL provides a complete\n   and understandable description of the data in your API, gives\n   clients the power to ask for exactly what they need and nothing\n   more, makes it easier to evolve APIs over time, and enables\n   powerful developer tools.\n\nIt was created by Facebook based on their problems and solutions using\n`REST <https://en.wikipedia.org/wiki/Representational_state_transfer>`_\nto develop applications to consume their APIs. It was publicly\nannounced at\n`React.js Conf 2015 <https://reactjs.org/blog/2015/02/20/introducing-relay-and-graphql.html>`_\nand started to gain traction since then. Right now there are big names\ntransitioning from REST to GraphQL:\n`Yelp <https://www.yelp.com/developers/graphql/guides/intro>`_\n`Shopify <https://help.shopify.com/api/storefront-api/graphql>`_\nand `GitHub <https://developer.github.com/v4/>`_, that did an\nexcellent\n`post <https://githubengineering.com/the-github-graphql-api/>`_\nto explain why they changed.\n\nA short list of advantages over REST:\n\n- Built-in schema, with documentation, strong typing and\n  introspection. There is no need to use\n  `Swagger <https://swagger.io>`_ or any other external tools to play\n  with it. Actually GraphQL provides a standard in-browser IDE for\n  exploring GraphQL endpoints: https://github.com/graphql/graphiql;\n\n- Only the fields that you want. The queries must explicitly select which\n  fields are required, and that's all you're getting. If more fields\n  are added to the type, they **won't break** the API, since the new\n  fields won't be returned to old clients, as they didn't ask for such\n  fields. This makes much easier to keep APIs stable and **avoids\n  versioning**. Standard REST usually delivers all available fields in\n  the results, and when new fields are to be included, a new API\n  version is added (reflected in the URL path, or in an HTTP header);\n\n- All data in one request. Instead of navigating hypermedia-driven\n  RESTful services, like  discovering new ``\"_links\": {\"href\"...`` and\n  executing a new HTTP request, with GraphQL you specify nested\n  queries and let the whole navigation be done by the server. This\n  reduces latency **a lot**;\n\n- The resulting JSON object matches the given query exactly; if\n  you requested ``{ parent { child { info } } }``, you're going to\n  receive the JSON object ``{\"parent\": {\"child\": {\"info\": value }}}``.\n\nFrom GitHub's\n`Migrating from REST to GraphQL <https://developer.github.com/v4/guides/migrating-from-rest/>`_\none can see these in real life::\n\n   $ curl -v https://api.github.com/orgs/github/members\n   [\n     {\n       \"login\": \"...\",\n       \"id\": 1234,\n       \"avatar_url\": \"https://avatars3.githubusercontent.com/u/...\",\n       \"gravatar_id\": \"\",\n       \"url\": \"https://api.github.com/users/...\",\n       \"html_url\": \"https://github.com/...\",\n       \"followers_url\": \"https://api.github.com/users/.../followers\",\n       \"following_url\": \"https://api.github.com/users/.../following{/other_user}\",\n       \"gists_url\": \"https://api.github.com/users/.../gists{/gist_id}\",\n       \"starred_url\": \"https://api.github.com/users/.../starred{/owner}{/repo}\",\n       \"subscriptions_url\": \"https://api.github.com/users/.../subscriptions\",\n       \"organizations_url\": \"https://api.github.com/users/.../orgs\",\n       \"repos_url\": \"https://api.github.com/users/.../repos\",\n       \"events_url\": \"https://api.github.com/users/.../events{/privacy}\",\n       \"received_events_url\": \"https://api.github.com/users/.../received_events\",\n       \"type\": \"User\",\n       \"site_admin\": true\n     },\n     ...\n   ]\n\nbrings the whole set of member information, however you just want name\nand avatar URL::\n\n   query {\n     organization(login:\"github\") { # select the organization\n       members(first: 100) {        # then select the organization's members\n         edges {  # edges + node: convention for paginated queries\n           node {\n             name\n             avatarUrl\n           }\n         }\n       }\n     }\n   }\n\nLikewise, instead of 4 HTTP requests::\n\n   curl -v https://api.github.com/repos/profusion/sgqlc/pulls/9\n   curl -v https://api.github.com/repos/profusion/sgqlc/pulls/9/commits\n   curl -v https://api.github.com/repos/profusion/sgqlc/issues/9/comments\n   curl -v https://api.github.com/repos/profusion/sgqlc/pulls/9/reviews\n\nA single GraphQL query brings all the needed information, and just the\nneeded information::\n\n   query {\n     repository(owner: \"profusion\", name: \"sgqlc\") {\n       pullRequest(number: 9) {\n         commits(first: 10) { # commits of profusion/sgqlc PR #9\n           edges {\n             node { commit { oid, message } }\n           }\n         }\n         comments(first: 10) { # comments of profusion/sgqlc PR #9\n           edges {\n             node {\n               body\n               author { login }\n             }\n           }\n         }\n         reviews(first: 10) { # reviews of profusion/sgqlc/ PR #9\n           edges { node { state } }\n         }\n       }\n     }\n   }\n\n\nMotivation to create `sgqlc`\n============================\n\nAs seen above, writing GraphQL queries is very easy, and it is equally easy to\ninterpret the results. So **what was the rationale to create sgqlc?**\n\n- GraphQL has its domain-specific language (DSL), and mixing two\n  languages is always painful, as seen with SQL + Python, HTML +\n  Python... Being able to write just Python in Python is much\n  better. Not to say that GraphQL naming convention is closer to\n  Java/JavaScript, using ``aNameFormat`` instead of Python's\n  ``a_name_format``.\n\n- Navigating dict-of-stuff is a bit painful:\n  ``d[\"repository\"][\"pullRequest\"][\"commits\"][\"edges\"][\"node\"]``,\n  since these are valid Python identifiers, we better write:\n  ``repository.pull_request.commits.edges.node``.\n\n- Handling new ``scalar`` types. GraphQL allows one to define new scalar\n  types, such as ``Date``, ``Time`` and ``DateTime``. Often these are\n  serialized as ISO 8601 strings and the user must parse them in their\n  application. We offer ``sgqlc.types.datetime`` to automatically\n  generate :literal:`datetime.date`, :literal:`datetime.time` and\n  :literal:`datetime.datetime`.\n\n- Make it easy to write dynamic queries, including nested. As seen,\n  GraphQL can be used to fetch lots of information in one go; however\n  if what you need (arguments and fields) changes based on some\n  variable, such as user input or cached data, then you need to\n  concatenate strings to compose the final query. This can be error\n  prone and servers may block you due to invalid queries. Some tools\n  \"solve\" this by parsing the query locally before sending it to\n  server. However usually the indentation is screwed and reviewing it\n  is painful. We change that approach: use\n  :literal:`sgqlc.operation.Operation` and it will always generate valid\n  queries, which can be printed out and properly indented. Bonus point\n  is that it can be used to later interpret the JSON results into native\n  Python objects.\n\n- Usability improvements whenever needed. For instance\n  `Relay <https://facebook.github.io/relay/>`_ published their\n  `Cursor Connections Specification <https://facebook.github.io/relay/graphql/connections.htm>`_\n  and its widely used. To load more data, you need to extend the\n  previous data with newly fetched information, updating not only the\n  nodes and edges, but also page information. This is done\n  automatically by :literal:`sgqlc.types.relay.Connection`.\n\nFuture plans include generating the Python classes from the GraphQL\nschema, which can be automatically fetched from an endpoint using\nthe introspection query.\n\nInstallation\n------------\n\nAutomatic::\n\n    pip install sgqlc\n\nFrom source using ``pip``::\n\n    pip install .\n\n\nUsage\n-----\n\nTo reach a GraphQL endpoint using synchronous `HTTPEndpoint` with a\nhand-written query (see more at ``examples/basic/01_http_endpoint.py``):\n\n.. code-block:: python\n\n   from sgqlc.endpoint.http import HTTPEndpoint\n\n   url = 'http://server.com/graphql'\n   headers = {'Authorization': 'bearer TOKEN'}\n\n   query = 'query { ... }'\n   variables = {'varName': 'value'}\n\n   endpoint = HTTPEndpoint(url, headers)\n   data = endpoint(query, variables)\n\n\nHowever, writing GraphQL queries and later interpreting the results\nmay be cumbersome. That's solved by our ``sgqlc.types``, which is\nusually paired with ``sgqlc.operation`` to generate queries and then\ninterpret results (see more at ``examples/basic/02_schema_types.py``). The\nexample below matches a subset of \n`GitHub API v4 <https://developer.github.com/v4/query/>`_.\nIn GraphQL syntax it would be::\n\n   query {\n     repository(owner: \"profusion\", name: \"sgqlc\") {\n       issues(first: 100) {\n         nodes {\n           number\n           title\n         }\n         pageInfo {\n           hasNextPage\n           endCursor\n         }\n       }\n     }\n   }\n\nThe output JSON object is:\n\n.. code-block:: json\n\n   {\n     \"data\": {\n       \"repository\": {\n         \"issues\": {\n           \"nodes\": [\n             {\"number\": 1, \"title\": \"...\"},\n             {\"number\": 2, \"title\": \"...\"}\n           ]\n         },\n         \"pageInfo\": {\n            \"hasNextPage\": false,\n            \"endCursor\": \"...\"\n         }\n       }\n     }\n   }\n\n.. code-block:: python\n\n   from sgqlc.endpoint.http import HTTPEndpoint\n   from sgqlc.types import Type, Field, list_of\n   from sgqlc.types.relay import Connection, connection_args\n   from sgqlc.operation import Operation\n\n   # Declare types matching GitHub GraphQL schema:\n   class Issue(Type):\n       number = int\n       title = str\n\n   class IssueConnection(Connection):  # Connection provides page_info!\n       nodes = list_of(Issue)\n\n   class Repository(Type):\n       issues = Field(IssueConnection, args=connection_args())\n\n   class Query(Type):  # GraphQL's root\n       repository = Field(Repository, args={'owner': str, 'name': str})\n\n   # Generate an operation on Query, selecting fields:\n   op = Operation(Query)\n   # select a field, here with selection arguments, then another field:\n   issues = op.repository(owner=owner, name=name).issues(first=100)\n   # select sub-fields explicitly: { nodes { number title } }\n   issues.nodes.number()\n   issues.nodes.title()\n   # here uses __fields__() to select by name (*args)\n   issues.page_info.__fields__('has_next_page')\n   # here uses __fields__() to select by name (**kwargs)\n   issues.page_info.__fields__(end_cursor=True)\n\n   # you can print the resulting GraphQL\n   print(op)\n\n   # Call the endpoint:\n   data = endpoint(op)\n\n   # Interpret results into native objects\n   repo = (op + data).repository\n   for issue in repo.issues.nodes:\n       print(issue)\n\n\nWhy double-underscore and overloaded arithmetic methods?\n========================================================\n\nSince we don't want to clobber GraphQL fields, we cannot provide\nnicely named methods. Therefore we use overloaded methods such as\n``__iadd__``, ``__add__``, ``__bytes__`` (compressed GraphQL\nrepresentation) and ``__str__`` (indented GraphQL representation).\n\nTo select fields by name, use ``__fields__(*names, **names_and_args)``.\nThis helps with repetitive situations and can be used to \"include all\nfields\", or \"include all except...\":\n\n.. code-block:: python\n\n  # just 'a' and 'b'\n  type_selection.__fields__('a', 'b')\n  type_selection.__fields__(a=True, b=True) # equivalent\n\n  # a(arg1: value1), b(arg2: value2):\n  type_selection.__fields__(\n      a={'arg1': value1},\n      b={'arg2': value2})\n\n  # selects all possible fields\n  type_selection.__fields__()\n\n  # all but 'a' and 'b'\n  type_selection.__fields__(__exclude__=('a', 'b'))\n  type_selection.__fields__(a=False, b=False)\n\n\nCode Generator\n--------------\n\nManually converting an existing GraphQL schema to ``sgqlc.types``\nsubclasses is boring and error prone. To aid such task we offer a code\ngenerator that outputs a Python module straight from JSON of an\nintrospection call:\n\n.. code-block:: console\n\n   user@host$ python3 -m sgqlc.introspection \\\n        --exclude-deprecated \\\n        --exclude-description \\\n        -H \"Authorization: bearer ${GH_TOKEN}\" \\\n        https://api.github.com/graphql \\\n        github_schema.json\n   user@host$ sgqlc-codegen github_schema.json github_schema.py\n\nThis generates ``github_schema`` that provides the\n:literal:`sgqlc.types.Schema` instance of the same name ``github_schema``.\nThen it's a matter of using that in your Python code, as in the example below\nfrom ``examples/github/github-agile-dashboard.py``:\n\n.. code-block:: python\n\n   from sgqlc.operation import Operation\n   from github_schema import github_schema as schema\n\n   op = Operation(schema.Query)  # note 'schema.'\n\n   # -- code below follows as the original usage example:\n\n   # select a field, here with selection arguments, then another field:\n   issues = op.repository(owner=owner, name=name).issues(first=100)\n   # select sub-fields explicitly: { nodes { number title } }\n   issues.nodes.number()\n   issues.nodes.title()\n   # here uses __fields__() to select by name (*args)\n   issues.page_info.__fields__('has_next_page')\n   # here uses __fields__() to select by name (**kwargs)\n   issues.page_info.__fields__(end_cursor=True)\n\n   # you can print the resulting GraphQL\n   print(op)\n\n   # Call the endpoint:\n   data = endpoint(op)\n\n   # Interpret results into native objects\n   repo = (op + data).repository\n   for issue in repo.issues.nodes:\n       print(issue)\n\n\nAuthors\n-------\n\n- `Gustavo Sverzut Barbieri <barbieri@profusion.mobi>`_\n\n\nLicense\n-------\n`sgqlc` is licensed under the `ISC <https://opensource.org/licenses/ISC>`_.\n\n\nGetting started developing\n--------------------------\n\nYou need to use `pipenv <https://pipenv.readthedocs.io/en/latest>`_.\n\n::\n\n    pipenv install --dev\n    pipenv shell\n\nInstall the git hooks:\n\n::\n\n   ./utils/git/install-git-hooks.sh\n\nRun the tests (one of the below):\n\n::\n\n    ./utils/git/pre-commit       # flake8 and nose\n\n    ./setup.py nosetests         # only nose (unit/doc tests)\n    flake8 --config setup.cfg .  # style checks\n\nKeep 100% coverage. You can look at the coverage report at\n``cover/index.html``.  To do that, prefer \n`doctest <https://docs.python.org/3.7/library/doctest.html>`_\nso it serves as\nboth documentation and test. However we use \n`nose <https://nose.readthedocs.io>`_ to write explicit tests that would be\nhard to express using ``doctest``.\n\nBuild and review the generated Sphinx documentation, and validate if your\nchanges look right:\n\n::\n\n    ./setup.py build_sphinx\n    open doc/build/html/index.html\n\n\nTo integrate changes from another branch, please **rebase** instead of\ncreating merge commits (\n`read more <https://git-scm.com/book/en/v2/Git-Branching-Rebasing>`_).\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "graphql client http endpoint", "license": "ISCL", "maintainer": "", "maintainer_email": "", "name": "dai-sgqlc-3.5", "package_url": "https://pypi.org/project/dai-sgqlc-3.5/", "platform": "any", "project_url": "https://pypi.org/project/dai-sgqlc-3.5/", "project_urls": null, "release_url": "https://pypi.org/project/dai-sgqlc-3.5/0.0.1.dev20200211/", "requires_dist": ["graphql-core", "requests ; extra == 'requests'", "sphinx ; extra == 'sphinx'", "websocket-client ; extra == 'websocket'"], "requires_python": ">=3.5", "summary": "Simple GraphQL Client (temporary fork with 3.5 support)", "version": "0.0.1.dev20200211", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.com/profusion/sgqlc\" rel=\"nofollow\"><img alt=\"https://travis-ci.com/profusion/sgqlc.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cae57cf94215b02a5427a857135cc12d0cc44ce9/68747470733a2f2f7472617669732d63692e636f6d2f70726f667573696f6e2f7367716c632e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/profusion/sgqlc?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/profusion/sgqlc/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5715c16d5255d1fde5cf7f8df4d19be3731fe897/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f70726f667573696f6e2f7367716c632f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<div id=\"introduction\">\n<h2>Introduction</h2>\n<p>This package offers an easy to use <a href=\"http://graphql.org\" rel=\"nofollow\">GraphQL</a>\nclient. It\u2019s composed of the following modules:</p>\n<ul>\n<li><tt>sgqlc.types</tt>: declare GraphQL in Python, base to generate and\ninterpret queries. Submodule <tt>sgqlc.types.datetime</tt> will\nprovide bindings for <tt>datetime</tt> and ISO 8601, while\n<tt>sgqlc.types.relay</tt> will expose <tt>Node</tt>, <tt>PageInfo</tt> and\n<tt>Connection</tt>.</li>\n<li><tt>sgqlc.operation</tt>: use declared types to generate and\ninterpret queries.</li>\n<li><tt>sgqlc.endpoint</tt>: provide access to GraphQL endpoints, notably\n<tt>sgqlc.endpoint.http</tt> provides <tt>HTTPEndpoint</tt> using\n<tt>urllib.request.urlopen()</tt>.</li>\n</ul>\n<div id=\"what-s-graphql\">\n<h3>What\u2019s GraphQL?</h3>\n<p>Straight from <a href=\"http://graphql.org\" rel=\"nofollow\">http://graphql.org</a>:</p>\n<blockquote>\n<p><strong>A query language for your API</strong></p>\n<p>GraphQL is a query language for APIs and a runtime for fulfilling\nthose queries with your existing data. GraphQL provides a complete\nand understandable description of the data in your API, gives\nclients the power to ask for exactly what they need and nothing\nmore, makes it easier to evolve APIs over time, and enables\npowerful developer tools.</p>\n</blockquote>\n<p>It was created by Facebook based on their problems and solutions using\n<a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" rel=\"nofollow\">REST</a>\nto develop applications to consume their APIs. It was publicly\nannounced at\n<a href=\"https://reactjs.org/blog/2015/02/20/introducing-relay-and-graphql.html\" rel=\"nofollow\">React.js Conf 2015</a>\nand started to gain traction since then. Right now there are big names\ntransitioning from REST to GraphQL:\n<a href=\"https://www.yelp.com/developers/graphql/guides/intro\" rel=\"nofollow\">Yelp</a>\n<a href=\"https://help.shopify.com/api/storefront-api/graphql\" rel=\"nofollow\">Shopify</a>\nand <a href=\"https://developer.github.com/v4/\" rel=\"nofollow\">GitHub</a>, that did an\nexcellent\n<a href=\"https://githubengineering.com/the-github-graphql-api/\" rel=\"nofollow\">post</a>\nto explain why they changed.</p>\n<p>A short list of advantages over REST:</p>\n<ul>\n<li>Built-in schema, with documentation, strong typing and\nintrospection. There is no need to use\n<a href=\"https://swagger.io\" rel=\"nofollow\">Swagger</a> or any other external tools to play\nwith it. Actually GraphQL provides a standard in-browser IDE for\nexploring GraphQL endpoints: <a href=\"https://github.com/graphql/graphiql\" rel=\"nofollow\">https://github.com/graphql/graphiql</a>;</li>\n<li>Only the fields that you want. The queries must explicitly select which\nfields are required, and that\u2019s all you\u2019re getting. If more fields\nare added to the type, they <strong>won\u2019t break</strong> the API, since the new\nfields won\u2019t be returned to old clients, as they didn\u2019t ask for such\nfields. This makes much easier to keep APIs stable and <strong>avoids\nversioning</strong>. Standard REST usually delivers all available fields in\nthe results, and when new fields are to be included, a new API\nversion is added (reflected in the URL path, or in an HTTP header);</li>\n<li>All data in one request. Instead of navigating hypermedia-driven\nRESTful services, like  discovering new <tt>\"_links\": <span class=\"pre\">{\"href\"...</span></tt> and\nexecuting a new HTTP request, with GraphQL you specify nested\nqueries and let the whole navigation be done by the server. This\nreduces latency <strong>a lot</strong>;</li>\n<li>The resulting JSON object matches the given query exactly; if\nyou requested <tt>{ parent { child { info } } }</tt>, you\u2019re going to\nreceive the JSON object <tt>{\"parent\": {\"child\": {\"info\": value }}}</tt>.</li>\n</ul>\n<p>From GitHub\u2019s\n<a href=\"https://developer.github.com/v4/guides/migrating-from-rest/\" rel=\"nofollow\">Migrating from REST to GraphQL</a>\none can see these in real life:</p>\n<pre>$ curl -v https://api.github.com/orgs/github/members\n[\n  {\n    \"login\": \"...\",\n    \"id\": 1234,\n    \"avatar_url\": \"https://avatars3.githubusercontent.com/u/...\",\n    \"gravatar_id\": \"\",\n    \"url\": \"https://api.github.com/users/...\",\n    \"html_url\": \"https://github.com/...\",\n    \"followers_url\": \"https://api.github.com/users/.../followers\",\n    \"following_url\": \"https://api.github.com/users/.../following{/other_user}\",\n    \"gists_url\": \"https://api.github.com/users/.../gists{/gist_id}\",\n    \"starred_url\": \"https://api.github.com/users/.../starred{/owner}{/repo}\",\n    \"subscriptions_url\": \"https://api.github.com/users/.../subscriptions\",\n    \"organizations_url\": \"https://api.github.com/users/.../orgs\",\n    \"repos_url\": \"https://api.github.com/users/.../repos\",\n    \"events_url\": \"https://api.github.com/users/.../events{/privacy}\",\n    \"received_events_url\": \"https://api.github.com/users/.../received_events\",\n    \"type\": \"User\",\n    \"site_admin\": true\n  },\n  ...\n]\n</pre>\n<p>brings the whole set of member information, however you just want name\nand avatar URL:</p>\n<pre>query {\n  organization(login:\"github\") { # select the organization\n    members(first: 100) {        # then select the organization's members\n      edges {  # edges + node: convention for paginated queries\n        node {\n          name\n          avatarUrl\n        }\n      }\n    }\n  }\n}\n</pre>\n<p>Likewise, instead of 4 HTTP requests:</p>\n<pre>curl -v https://api.github.com/repos/profusion/sgqlc/pulls/9\ncurl -v https://api.github.com/repos/profusion/sgqlc/pulls/9/commits\ncurl -v https://api.github.com/repos/profusion/sgqlc/issues/9/comments\ncurl -v https://api.github.com/repos/profusion/sgqlc/pulls/9/reviews\n</pre>\n<p>A single GraphQL query brings all the needed information, and just the\nneeded information:</p>\n<pre>query {\n  repository(owner: \"profusion\", name: \"sgqlc\") {\n    pullRequest(number: 9) {\n      commits(first: 10) { # commits of profusion/sgqlc PR #9\n        edges {\n          node { commit { oid, message } }\n        }\n      }\n      comments(first: 10) { # comments of profusion/sgqlc PR #9\n        edges {\n          node {\n            body\n            author { login }\n          }\n        }\n      }\n      reviews(first: 10) { # reviews of profusion/sgqlc/ PR #9\n        edges { node { state } }\n      }\n    }\n  }\n}\n</pre>\n</div>\n<div id=\"motivation-to-create-sgqlc\">\n<h3>Motivation to create <cite>sgqlc</cite></h3>\n<p>As seen above, writing GraphQL queries is very easy, and it is equally easy to\ninterpret the results. So <strong>what was the rationale to create sgqlc?</strong></p>\n<ul>\n<li>GraphQL has its domain-specific language (DSL), and mixing two\nlanguages is always painful, as seen with SQL + Python, HTML +\nPython\u2026 Being able to write just Python in Python is much\nbetter. Not to say that GraphQL naming convention is closer to\nJava/JavaScript, using <tt>aNameFormat</tt> instead of Python\u2019s\n<tt>a_name_format</tt>.</li>\n<li>Navigating dict-of-stuff is a bit painful:\n<tt><span class=\"pre\">d[\"repository\"][\"pullRequest\"][\"commits\"][\"edges\"][\"node\"]</span></tt>,\nsince these are valid Python identifiers, we better write:\n<tt>repository.pull_request.commits.edges.node</tt>.</li>\n<li>Handling new <tt>scalar</tt> types. GraphQL allows one to define new scalar\ntypes, such as <tt>Date</tt>, <tt>Time</tt> and <tt>DateTime</tt>. Often these are\nserialized as ISO 8601 strings and the user must parse them in their\napplication. We offer <tt>sgqlc.types.datetime</tt> to automatically\ngenerate <tt>datetime.date</tt>, <tt>datetime.time</tt> and\n<tt>datetime.datetime</tt>.</li>\n<li>Make it easy to write dynamic queries, including nested. As seen,\nGraphQL can be used to fetch lots of information in one go; however\nif what you need (arguments and fields) changes based on some\nvariable, such as user input or cached data, then you need to\nconcatenate strings to compose the final query. This can be error\nprone and servers may block you due to invalid queries. Some tools\n\u201csolve\u201d this by parsing the query locally before sending it to\nserver. However usually the indentation is screwed and reviewing it\nis painful. We change that approach: use\n<tt>sgqlc.operation.Operation</tt> and it will always generate valid\nqueries, which can be printed out and properly indented. Bonus point\nis that it can be used to later interpret the JSON results into native\nPython objects.</li>\n<li>Usability improvements whenever needed. For instance\n<a href=\"https://facebook.github.io/relay/\" rel=\"nofollow\">Relay</a> published their\n<a href=\"https://facebook.github.io/relay/graphql/connections.htm\" rel=\"nofollow\">Cursor Connections Specification</a>\nand its widely used. To load more data, you need to extend the\nprevious data with newly fetched information, updating not only the\nnodes and edges, but also page information. This is done\nautomatically by <tt>sgqlc.types.relay.Connection</tt>.</li>\n</ul>\n<p>Future plans include generating the Python classes from the GraphQL\nschema, which can be automatically fetched from an endpoint using\nthe introspection query.</p>\n</div>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Automatic:</p>\n<pre>pip install sgqlc\n</pre>\n<p>From source using <tt>pip</tt>:</p>\n<pre>pip install .\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>To reach a GraphQL endpoint using synchronous <cite>HTTPEndpoint</cite> with a\nhand-written query (see more at <tt>examples/basic/01_http_endpoint.py</tt>):</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">sgqlc.endpoint.http</span> <span class=\"kn\">import</span> <span class=\"n\">HTTPEndpoint</span>\n\n<span class=\"n\">url</span> <span class=\"o\">=</span> <span class=\"s1\">'http://server.com/graphql'</span>\n<span class=\"n\">headers</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'Authorization'</span><span class=\"p\">:</span> <span class=\"s1\">'bearer TOKEN'</span><span class=\"p\">}</span>\n\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"s1\">'query { ... }'</span>\n<span class=\"n\">variables</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'varName'</span><span class=\"p\">:</span> <span class=\"s1\">'value'</span><span class=\"p\">}</span>\n\n<span class=\"n\">endpoint</span> <span class=\"o\">=</span> <span class=\"n\">HTTPEndpoint</span><span class=\"p\">(</span><span class=\"n\">url</span><span class=\"p\">,</span> <span class=\"n\">headers</span><span class=\"p\">)</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">endpoint</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">variables</span><span class=\"p\">)</span>\n</pre>\n<p>However, writing GraphQL queries and later interpreting the results\nmay be cumbersome. That\u2019s solved by our <tt>sgqlc.types</tt>, which is\nusually paired with <tt>sgqlc.operation</tt> to generate queries and then\ninterpret results (see more at <tt>examples/basic/02_schema_types.py</tt>). The\nexample below matches a subset of\n<a href=\"https://developer.github.com/v4/query/\" rel=\"nofollow\">GitHub API v4</a>.\nIn GraphQL syntax it would be:</p>\n<pre>query {\n  repository(owner: \"profusion\", name: \"sgqlc\") {\n    issues(first: 100) {\n      nodes {\n        number\n        title\n      }\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n    }\n  }\n}\n</pre>\n<p>The output JSON object is:</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"nt\">\"data\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"repository\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"nt\">\"issues\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">\"nodes\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n          <span class=\"p\">{</span><span class=\"nt\">\"number\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nt\">\"title\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span><span class=\"p\">},</span>\n          <span class=\"p\">{</span><span class=\"nt\">\"number\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nt\">\"title\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span><span class=\"p\">}</span>\n        <span class=\"p\">]</span>\n      <span class=\"p\">},</span>\n      <span class=\"nt\">\"pageInfo\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n         <span class=\"nt\">\"hasNextPage\"</span><span class=\"p\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n         <span class=\"nt\">\"endCursor\"</span><span class=\"p\">:</span> <span class=\"s2\">\"...\"</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">sgqlc.endpoint.http</span> <span class=\"kn\">import</span> <span class=\"n\">HTTPEndpoint</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sgqlc.types</span> <span class=\"kn\">import</span> <span class=\"n\">Type</span><span class=\"p\">,</span> <span class=\"n\">Field</span><span class=\"p\">,</span> <span class=\"n\">list_of</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sgqlc.types.relay</span> <span class=\"kn\">import</span> <span class=\"n\">Connection</span><span class=\"p\">,</span> <span class=\"n\">connection_args</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sgqlc.operation</span> <span class=\"kn\">import</span> <span class=\"n\">Operation</span>\n\n<span class=\"c1\"># Declare types matching GitHub GraphQL schema:</span>\n<span class=\"k\">class</span> <span class=\"nc\">Issue</span><span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">):</span>\n    <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"nb\">int</span>\n    <span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"nb\">str</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">IssueConnection</span><span class=\"p\">(</span><span class=\"n\">Connection</span><span class=\"p\">):</span>  <span class=\"c1\"># Connection provides page_info!</span>\n    <span class=\"n\">nodes</span> <span class=\"o\">=</span> <span class=\"n\">list_of</span><span class=\"p\">(</span><span class=\"n\">Issue</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Repository</span><span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">):</span>\n    <span class=\"n\">issues</span> <span class=\"o\">=</span> <span class=\"n\">Field</span><span class=\"p\">(</span><span class=\"n\">IssueConnection</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"n\">connection_args</span><span class=\"p\">())</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Query</span><span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">):</span>  <span class=\"c1\"># GraphQL's root</span>\n    <span class=\"n\">repository</span> <span class=\"o\">=</span> <span class=\"n\">Field</span><span class=\"p\">(</span><span class=\"n\">Repository</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'owner'</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">})</span>\n\n<span class=\"c1\"># Generate an operation on Query, selecting fields:</span>\n<span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operation</span><span class=\"p\">(</span><span class=\"n\">Query</span><span class=\"p\">)</span>\n<span class=\"c1\"># select a field, here with selection arguments, then another field:</span>\n<span class=\"n\">issues</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">repository</span><span class=\"p\">(</span><span class=\"n\">owner</span><span class=\"o\">=</span><span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"n\">name</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">issues</span><span class=\"p\">(</span><span class=\"n\">first</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"c1\"># select sub-fields explicitly: { nodes { number title } }</span>\n<span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"o\">.</span><span class=\"n\">number</span><span class=\"p\">()</span>\n<span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"p\">()</span>\n<span class=\"c1\"># here uses __fields__() to select by name (*args)</span>\n<span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">page_info</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span><span class=\"s1\">'has_next_page'</span><span class=\"p\">)</span>\n<span class=\"c1\"># here uses __fields__() to select by name (**kwargs)</span>\n<span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">page_info</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span><span class=\"n\">end_cursor</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># you can print the resulting GraphQL</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Call the endpoint:</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">endpoint</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Interpret results into native objects</span>\n<span class=\"n\">repo</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">op</span> <span class=\"o\">+</span> <span class=\"n\">data</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">repository</span>\n<span class=\"k\">for</span> <span class=\"n\">issue</span> <span class=\"ow\">in</span> <span class=\"n\">repo</span><span class=\"o\">.</span><span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">issue</span><span class=\"p\">)</span>\n</pre>\n<div id=\"why-double-underscore-and-overloaded-arithmetic-methods\">\n<h3>Why double-underscore and overloaded arithmetic methods?</h3>\n<p>Since we don\u2019t want to clobber GraphQL fields, we cannot provide\nnicely named methods. Therefore we use overloaded methods such as\n<tt>__iadd__</tt>, <tt>__add__</tt>, <tt>__bytes__</tt> (compressed GraphQL\nrepresentation) and <tt>__str__</tt> (indented GraphQL representation).</p>\n<p>To select fields by name, use <tt><span class=\"pre\">__fields__(*names,</span> **names_and_args)</tt>.\nThis helps with repetitive situations and can be used to \u201cinclude all\nfields\u201d, or \u201cinclude all except\u2026\u201d:</p>\n<pre><span class=\"c1\"># just 'a' and 'b'</span>\n<span class=\"n\">type_selection</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">)</span>\n<span class=\"n\">type_selection</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># equivalent</span>\n\n<span class=\"c1\"># a(arg1: value1), b(arg2: value2):</span>\n<span class=\"n\">type_selection</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span>\n    <span class=\"n\">a</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'arg1'</span><span class=\"p\">:</span> <span class=\"n\">value1</span><span class=\"p\">},</span>\n    <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'arg2'</span><span class=\"p\">:</span> <span class=\"n\">value2</span><span class=\"p\">})</span>\n\n<span class=\"c1\"># selects all possible fields</span>\n<span class=\"n\">type_selection</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># all but 'a' and 'b'</span>\n<span class=\"n\">type_selection</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span><span class=\"n\">__exclude__</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">))</span>\n<span class=\"n\">type_selection</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"code-generator\">\n<h2>Code Generator</h2>\n<p>Manually converting an existing GraphQL schema to <tt>sgqlc.types</tt>\nsubclasses is boring and error prone. To aid such task we offer a code\ngenerator that outputs a Python module straight from JSON of an\nintrospection call:</p>\n<pre><span class=\"gp\">user@host$</span> python3 -m sgqlc.introspection <span class=\"se\">\\\n</span>     --exclude-deprecated <span class=\"se\">\\\n</span>     --exclude-description <span class=\"se\">\\\n</span>     -H <span class=\"s2\">\"Authorization: bearer </span><span class=\"si\">${</span><span class=\"nv\">GH_TOKEN</span><span class=\"si\">}</span><span class=\"s2\">\"</span> <span class=\"se\">\\\n</span>     https://api.github.com/graphql <span class=\"se\">\\\n</span>     github_schema.json\n<span class=\"gp\">user@host$</span> sgqlc-codegen github_schema.json github_schema.py\n</pre>\n<p>This generates <tt>github_schema</tt> that provides the\n<tt>sgqlc.types.Schema</tt> instance of the same name <tt>github_schema</tt>.\nThen it\u2019s a matter of using that in your Python code, as in the example below\nfrom <tt><span class=\"pre\">examples/github/github-agile-dashboard.py</span></tt>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">sgqlc.operation</span> <span class=\"kn\">import</span> <span class=\"n\">Operation</span>\n<span class=\"kn\">from</span> <span class=\"nn\">github_schema</span> <span class=\"kn\">import</span> <span class=\"n\">github_schema</span> <span class=\"k\">as</span> <span class=\"n\">schema</span>\n\n<span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">Operation</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">Query</span><span class=\"p\">)</span>  <span class=\"c1\"># note 'schema.'</span>\n\n<span class=\"c1\"># -- code below follows as the original usage example:</span>\n\n<span class=\"c1\"># select a field, here with selection arguments, then another field:</span>\n<span class=\"n\">issues</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"o\">.</span><span class=\"n\">repository</span><span class=\"p\">(</span><span class=\"n\">owner</span><span class=\"o\">=</span><span class=\"n\">owner</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"n\">name</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">issues</span><span class=\"p\">(</span><span class=\"n\">first</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"c1\"># select sub-fields explicitly: { nodes { number title } }</span>\n<span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"o\">.</span><span class=\"n\">number</span><span class=\"p\">()</span>\n<span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"p\">()</span>\n<span class=\"c1\"># here uses __fields__() to select by name (*args)</span>\n<span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">page_info</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span><span class=\"s1\">'has_next_page'</span><span class=\"p\">)</span>\n<span class=\"c1\"># here uses __fields__() to select by name (**kwargs)</span>\n<span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">page_info</span><span class=\"o\">.</span><span class=\"n\">__fields__</span><span class=\"p\">(</span><span class=\"n\">end_cursor</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># you can print the resulting GraphQL</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Call the endpoint:</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">endpoint</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Interpret results into native objects</span>\n<span class=\"n\">repo</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">op</span> <span class=\"o\">+</span> <span class=\"n\">data</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">repository</span>\n<span class=\"k\">for</span> <span class=\"n\">issue</span> <span class=\"ow\">in</span> <span class=\"n\">repo</span><span class=\"o\">.</span><span class=\"n\">issues</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">issue</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"authors\">\n<h2>Authors</h2>\n<ul>\n<li><a href=\"mailto:barbieri%40profusion.mobi\">Gustavo Sverzut Barbieri</a></li>\n</ul>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p><cite>sgqlc</cite> is licensed under the <a href=\"https://opensource.org/licenses/ISC\" rel=\"nofollow\">ISC</a>.</p>\n</div>\n<div id=\"getting-started-developing\">\n<h2>Getting started developing</h2>\n<p>You need to use <a href=\"https://pipenv.readthedocs.io/en/latest\" rel=\"nofollow\">pipenv</a>.</p>\n<pre>pipenv install --dev\npipenv shell\n</pre>\n<p>Install the git hooks:</p>\n<pre>./utils/git/install-git-hooks.sh\n</pre>\n<p>Run the tests (one of the below):</p>\n<pre>./utils/git/pre-commit       # flake8 and nose\n\n./setup.py nosetests         # only nose (unit/doc tests)\nflake8 --config setup.cfg .  # style checks\n</pre>\n<p>Keep 100% coverage. You can look at the coverage report at\n<tt>cover/index.html</tt>.  To do that, prefer\n<a href=\"https://docs.python.org/3.7/library/doctest.html\" rel=\"nofollow\">doctest</a>\nso it serves as\nboth documentation and test. However we use\n<a href=\"https://nose.readthedocs.io\" rel=\"nofollow\">nose</a> to write explicit tests that would be\nhard to express using <tt>doctest</tt>.</p>\n<p>Build and review the generated Sphinx documentation, and validate if your\nchanges look right:</p>\n<pre>./setup.py build_sphinx\nopen doc/build/html/index.html\n</pre>\n<p>To integrate changes from another branch, please <strong>rebase</strong> instead of\ncreating merge commits (\n<a href=\"https://git-scm.com/book/en/v2/Git-Branching-Rebasing\" rel=\"nofollow\">read more</a>).</p>\n</div>\n\n          </div>"}, "last_serial": 6612039, "releases": {"0.0.1.dev20200211": [{"comment_text": "", "digests": {"md5": "bdb6b7f199004f08f757c9c3e83eac10", "sha256": "4c93ba72e53252cb12d39289e190fd2af1d6366e73b978554eaddce964b90d0f"}, "downloads": -1, "filename": "dai_sgqlc_3.5-0.0.1.dev20200211-py3-none-any.whl", "has_sig": false, "md5_digest": "bdb6b7f199004f08f757c9c3e83eac10", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 61960, "upload_time": "2020-02-11T20:53:08", "upload_time_iso_8601": "2020-02-11T20:53:08.137506Z", "url": "https://files.pythonhosted.org/packages/64/b9/938656170b0d951298659ccfc45a7b8097f67007dcbbaf316a4028b47b34/dai_sgqlc_3.5-0.0.1.dev20200211-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8e89e103a51ad15202e680aa7dac615d", "sha256": "2272fbe3ad6402ee68847ff1148b95e353507c1fcd2de4b895ded182f0b38938"}, "downloads": -1, "filename": "dai-sgqlc-3.5-0.0.1.dev20200211.tar.gz", "has_sig": false, "md5_digest": "8e89e103a51ad15202e680aa7dac615d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 221311, "upload_time": "2020-02-11T20:53:11", "upload_time_iso_8601": "2020-02-11T20:53:11.033938Z", "url": "https://files.pythonhosted.org/packages/0c/0e/12b24ca7340b9e9d0839de01acf1538ace6d8ad096493f8e2250ea05ed85/dai-sgqlc-3.5-0.0.1.dev20200211.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bdb6b7f199004f08f757c9c3e83eac10", "sha256": "4c93ba72e53252cb12d39289e190fd2af1d6366e73b978554eaddce964b90d0f"}, "downloads": -1, "filename": "dai_sgqlc_3.5-0.0.1.dev20200211-py3-none-any.whl", "has_sig": false, "md5_digest": "bdb6b7f199004f08f757c9c3e83eac10", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 61960, "upload_time": "2020-02-11T20:53:08", "upload_time_iso_8601": "2020-02-11T20:53:08.137506Z", "url": "https://files.pythonhosted.org/packages/64/b9/938656170b0d951298659ccfc45a7b8097f67007dcbbaf316a4028b47b34/dai_sgqlc_3.5-0.0.1.dev20200211-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8e89e103a51ad15202e680aa7dac615d", "sha256": "2272fbe3ad6402ee68847ff1148b95e353507c1fcd2de4b895ded182f0b38938"}, "downloads": -1, "filename": "dai-sgqlc-3.5-0.0.1.dev20200211.tar.gz", "has_sig": false, "md5_digest": "8e89e103a51ad15202e680aa7dac615d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 221311, "upload_time": "2020-02-11T20:53:11", "upload_time_iso_8601": "2020-02-11T20:53:11.033938Z", "url": "https://files.pythonhosted.org/packages/0c/0e/12b24ca7340b9e9d0839de01acf1538ace6d8ad096493f8e2250ea05ed85/dai-sgqlc-3.5-0.0.1.dev20200211.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:40:47 2020"}