{"info": {"author": "Max Byrde", "author_email": "max.byrde@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# Pyjak\n\nA Python library for reading and writing binary sources. The standard library\npackage `struct` has many caveats and is not very user friendly. We wrap it for\nyou and present a slick api with sane exception handling.\n\n[![Build Status](https://travis-ci.org/miniwa/pyjak.svg?branch=master)](https://travis-ci.org/miniwa/pyjak)\n\n## Installation\n\nThe easiest way to install is through pip:\n\n`pip3 install pyjak`\n\n## Examples\n\nHeres how you would serialize a common integer:\n\n```python\nfrom pyjak import dump_int32\n_bytes = dump_int32(1)\nprint(_bytes)\n```\n\nResult: (On little endian systems)\n\n```python\nb'\\x01\\x00\\x00\\x00'\n```\n\nAnd to turn it back into an integer:\n\n```python\nfrom pyjak import parse_int32\n_int = parse_int32(b'\\x01\\x00\\x00\\x00')\nprint(_int)\n```\n\nResult: (On little endian systems)\n\n```python\n1\n```\n\n### Unsigned integers\n\nAll integer functions have unsigned versions as well. Lets say you want to fit\nthe number 4000000000 into a 4 byte integer. You would need the\nunsigned version:\n\n```python\nfrom pyjak import dump_uint32\n_bytes = dump_uint32(4000000000)\nprint(_bytes)\n```\n\nResult: (On little endian systems)\n\n```python\nb'\\x00(k\\xee'\n```\n\nAnd to turn it back into an integer:\n\n```python\nfrom pyjak import parse_uint32\n_int = parse_uint32(b'\\x00(k\\xee')\nprint(_int)\n```\n\nResult: (On little endian systems)\n\n```python\n4000000000\n```\n\n### Byte order\n\nAs you may have noticed, we didn't need to specify the byte order\n(or endianness) of the byte array. This is because all functions in\npyjak defaults to the native byte order of your system.\n\nBut you can also specify which byte order you want by using the `ByteOrder`\nenumeration (except when calling int8 or uint8 functions).\nThe available orders are:\n\n```python\nfrom pyjak import ByteOrder\nByteOrder.LITTLE\nByteOrder.BIG\nByteOrder.NATIVE\nprint(ByteOrder.NATIVE == ByteOrder.LITTLE)\n```\n\nResult: (On little endian systems)\n\n```python\nTrue\n```\n\nYou can specify what byte order the serialized output should have:\n\n```python\nfrom pyjak import dump_int32, ByteOrder\n_bytes = dump_int32(1, ByteOrder.BIG)\nprint(_bytes)\n```\n\nResult:\n\n```python\nb'\\x00\\x00\\x00\\x01'\n```\n\nOr when parsing:\n\n```python\nfrom pyjak import parse_int32, ByteOrder\n_int = parse_int32(b'\\x00\\x00\\x00\\x01', ByteOrder.BIG)\nprint(_int)\n```\n\nResult:\n\n```python\n1\n```\n\n### Booleans\n\nYou can also serialize booleans. Booleans are assumed to represented as an\nunsigned 1 byte integer, where 0 means False and any other value means True.\n\n## Supported data types\n\n* int8 (Signed 1 byte integer)\n* uint8 (Unsigned 1 byte integer)\n* int16 (Signed 2 byte integer)\n* uint16 (Unsigned 2 byte integer)\n* int32 (Signed 4 byte integer)\n* uint32 (Unsigned 4 byte integer)\n* int64 (Signed 8 byte integer)\n* uint64 (Unsigned 8 byte integer)\n* float32 (4 byte single precision float)\n* float64 (8 byte double precision float)\n* bool (unsigned 1 byte integer)\n\n## Supported versions\n\n* Python 3.4\n* Python 3.5\n* Python 3.6\n* Python 3.7\n\n## Issues\n\nReport issues using the [issue tracker](https://github.com/miniwa/pyjak/issues) on the github repo.\n\n## Changelog\n\n### v0.1.0\n\n* Initial release.\n\n## Authors\n\n* Max Byrde (miniwa)\n\n## License\n\nMIT (see LICENSE)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/miniwa/pyjak", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pyjak", "package_url": "https://pypi.org/project/pyjak/", "platform": "", "project_url": "https://pypi.org/project/pyjak/", "project_urls": {"Homepage": "https://github.com/miniwa/pyjak"}, "release_url": "https://pypi.org/project/pyjak/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "A Python library for reading and writing binary sources.", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Pyjak</h1>\n<p>A Python library for reading and writing binary sources. The standard library\npackage <code>struct</code> has many caveats and is not very user friendly. We wrap it for\nyou and present a slick api with sane exception handling.</p>\n<p><a href=\"https://travis-ci.org/miniwa/pyjak\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d6f63589e2f7d28b6dff13d34c42fe06f630290b/68747470733a2f2f7472617669732d63692e6f72672f6d696e6977612f70796a616b2e7376673f6272616e63683d6d6173746572\"></a></p>\n<h2>Installation</h2>\n<p>The easiest way to install is through pip:</p>\n<p><code>pip3 install pyjak</code></p>\n<h2>Examples</h2>\n<p>Heres how you would serialize a common integer:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyjak</span> <span class=\"kn\">import</span> <span class=\"n\">dump_int32</span>\n<span class=\"n\">_bytes</span> <span class=\"o\">=</span> <span class=\"n\">dump_int32</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">_bytes</span><span class=\"p\">)</span>\n</pre>\n<p>Result: (On little endian systems)</p>\n<pre><span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x01\\x00\\x00\\x00</span><span class=\"s1\">'</span>\n</pre>\n<p>And to turn it back into an integer:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyjak</span> <span class=\"kn\">import</span> <span class=\"n\">parse_int32</span>\n<span class=\"n\">_int</span> <span class=\"o\">=</span> <span class=\"n\">parse_int32</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x01\\x00\\x00\\x00</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">_int</span><span class=\"p\">)</span>\n</pre>\n<p>Result: (On little endian systems)</p>\n<pre><span class=\"mi\">1</span>\n</pre>\n<h3>Unsigned integers</h3>\n<p>All integer functions have unsigned versions as well. Lets say you want to fit\nthe number 4000000000 into a 4 byte integer. You would need the\nunsigned version:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyjak</span> <span class=\"kn\">import</span> <span class=\"n\">dump_uint32</span>\n<span class=\"n\">_bytes</span> <span class=\"o\">=</span> <span class=\"n\">dump_uint32</span><span class=\"p\">(</span><span class=\"mi\">4000000000</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">_bytes</span><span class=\"p\">)</span>\n</pre>\n<p>Result: (On little endian systems)</p>\n<pre><span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x00</span><span class=\"s1\">(k</span><span class=\"se\">\\xee</span><span class=\"s1\">'</span>\n</pre>\n<p>And to turn it back into an integer:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyjak</span> <span class=\"kn\">import</span> <span class=\"n\">parse_uint32</span>\n<span class=\"n\">_int</span> <span class=\"o\">=</span> <span class=\"n\">parse_uint32</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x00</span><span class=\"s1\">(k</span><span class=\"se\">\\xee</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">_int</span><span class=\"p\">)</span>\n</pre>\n<p>Result: (On little endian systems)</p>\n<pre><span class=\"mi\">4000000000</span>\n</pre>\n<h3>Byte order</h3>\n<p>As you may have noticed, we didn't need to specify the byte order\n(or endianness) of the byte array. This is because all functions in\npyjak defaults to the native byte order of your system.</p>\n<p>But you can also specify which byte order you want by using the <code>ByteOrder</code>\nenumeration (except when calling int8 or uint8 functions).\nThe available orders are:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyjak</span> <span class=\"kn\">import</span> <span class=\"n\">ByteOrder</span>\n<span class=\"n\">ByteOrder</span><span class=\"o\">.</span><span class=\"n\">LITTLE</span>\n<span class=\"n\">ByteOrder</span><span class=\"o\">.</span><span class=\"n\">BIG</span>\n<span class=\"n\">ByteOrder</span><span class=\"o\">.</span><span class=\"n\">NATIVE</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">ByteOrder</span><span class=\"o\">.</span><span class=\"n\">NATIVE</span> <span class=\"o\">==</span> <span class=\"n\">ByteOrder</span><span class=\"o\">.</span><span class=\"n\">LITTLE</span><span class=\"p\">)</span>\n</pre>\n<p>Result: (On little endian systems)</p>\n<pre><span class=\"kc\">True</span>\n</pre>\n<p>You can specify what byte order the serialized output should have:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyjak</span> <span class=\"kn\">import</span> <span class=\"n\">dump_int32</span><span class=\"p\">,</span> <span class=\"n\">ByteOrder</span>\n<span class=\"n\">_bytes</span> <span class=\"o\">=</span> <span class=\"n\">dump_int32</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ByteOrder</span><span class=\"o\">.</span><span class=\"n\">BIG</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">_bytes</span><span class=\"p\">)</span>\n</pre>\n<p>Result:</p>\n<pre><span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x00\\x00\\x00\\x01</span><span class=\"s1\">'</span>\n</pre>\n<p>Or when parsing:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyjak</span> <span class=\"kn\">import</span> <span class=\"n\">parse_int32</span><span class=\"p\">,</span> <span class=\"n\">ByteOrder</span>\n<span class=\"n\">_int</span> <span class=\"o\">=</span> <span class=\"n\">parse_int32</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x00\\x00\\x00\\x01</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">ByteOrder</span><span class=\"o\">.</span><span class=\"n\">BIG</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">_int</span><span class=\"p\">)</span>\n</pre>\n<p>Result:</p>\n<pre><span class=\"mi\">1</span>\n</pre>\n<h3>Booleans</h3>\n<p>You can also serialize booleans. Booleans are assumed to represented as an\nunsigned 1 byte integer, where 0 means False and any other value means True.</p>\n<h2>Supported data types</h2>\n<ul>\n<li>int8 (Signed 1 byte integer)</li>\n<li>uint8 (Unsigned 1 byte integer)</li>\n<li>int16 (Signed 2 byte integer)</li>\n<li>uint16 (Unsigned 2 byte integer)</li>\n<li>int32 (Signed 4 byte integer)</li>\n<li>uint32 (Unsigned 4 byte integer)</li>\n<li>int64 (Signed 8 byte integer)</li>\n<li>uint64 (Unsigned 8 byte integer)</li>\n<li>float32 (4 byte single precision float)</li>\n<li>float64 (8 byte double precision float)</li>\n<li>bool (unsigned 1 byte integer)</li>\n</ul>\n<h2>Supported versions</h2>\n<ul>\n<li>Python 3.4</li>\n<li>Python 3.5</li>\n<li>Python 3.6</li>\n<li>Python 3.7</li>\n</ul>\n<h2>Issues</h2>\n<p>Report issues using the <a href=\"https://github.com/miniwa/pyjak/issues\" rel=\"nofollow\">issue tracker</a> on the github repo.</p>\n<h2>Changelog</h2>\n<h3>v0.1.0</h3>\n<ul>\n<li>Initial release.</li>\n</ul>\n<h2>Authors</h2>\n<ul>\n<li>Max Byrde (miniwa)</li>\n</ul>\n<h2>License</h2>\n<p>MIT (see LICENSE)</p>\n\n          </div>"}, "last_serial": 4699273, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "8ba295b37e52d2e11cf5df498c06baed", "sha256": "6fd5d07c104f2d5d253bc8842980c546f71b9c2aedde7bd730e31ec69c2a0d00"}, "downloads": -1, "filename": "pyjak-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "8ba295b37e52d2e11cf5df498c06baed", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5840, "upload_time": "2019-01-15T15:05:28", "upload_time_iso_8601": "2019-01-15T15:05:28.943322Z", "url": "https://files.pythonhosted.org/packages/fd/86/26400b7adc83b5a35eecff09f97614bf309afead5b4b065a36e6c7cd13b2/pyjak-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4a529d681a8b895fb1a6987d29cfa95a", "sha256": "293c8ad343843fb3851d58d68b58ab003297490561ed30364e121386f09bec23"}, "downloads": -1, "filename": "pyjak-0.1.0.tar.gz", "has_sig": false, "md5_digest": "4a529d681a8b895fb1a6987d29cfa95a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6724, "upload_time": "2019-01-15T15:05:31", "upload_time_iso_8601": "2019-01-15T15:05:31.165215Z", "url": "https://files.pythonhosted.org/packages/2f/30/8472671be2b2d260a1587987fb717e1daa062f42a2610e1fa83140832271/pyjak-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "8922cd5b137a5b260ac4101b2f2c74e8", "sha256": "5669e5aa2b8527f841087561af94c201ec1044f073c676ff845e024eeea75762"}, "downloads": -1, "filename": "pyjak-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "8922cd5b137a5b260ac4101b2f2c74e8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5883, "upload_time": "2019-01-15T15:13:13", "upload_time_iso_8601": "2019-01-15T15:13:13.126385Z", "url": "https://files.pythonhosted.org/packages/4c/35/75e74c1963ba0d5358c0b15a3f6cdddc4deea6cb1dabb906f03e675c6707/pyjak-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "772a1eeb0c2f2bb6d6ee11cb995b92b2", "sha256": "72b2a82c589eaf4969b1d106644918cec7d65b9c3bef6a53d4dca0cca8100fd6"}, "downloads": -1, "filename": "pyjak-0.1.1.tar.gz", "has_sig": false, "md5_digest": "772a1eeb0c2f2bb6d6ee11cb995b92b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6794, "upload_time": "2019-01-15T15:13:15", "upload_time_iso_8601": "2019-01-15T15:13:15.474636Z", "url": "https://files.pythonhosted.org/packages/ab/e3/94eb1c9105a6fb28c70809df9f3059619e8568c7110e3afd43e9feba4450/pyjak-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8922cd5b137a5b260ac4101b2f2c74e8", "sha256": "5669e5aa2b8527f841087561af94c201ec1044f073c676ff845e024eeea75762"}, "downloads": -1, "filename": "pyjak-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "8922cd5b137a5b260ac4101b2f2c74e8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5883, "upload_time": "2019-01-15T15:13:13", "upload_time_iso_8601": "2019-01-15T15:13:13.126385Z", "url": "https://files.pythonhosted.org/packages/4c/35/75e74c1963ba0d5358c0b15a3f6cdddc4deea6cb1dabb906f03e675c6707/pyjak-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "772a1eeb0c2f2bb6d6ee11cb995b92b2", "sha256": "72b2a82c589eaf4969b1d106644918cec7d65b9c3bef6a53d4dca0cca8100fd6"}, "downloads": -1, "filename": "pyjak-0.1.1.tar.gz", "has_sig": false, "md5_digest": "772a1eeb0c2f2bb6d6ee11cb995b92b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6794, "upload_time": "2019-01-15T15:13:15", "upload_time_iso_8601": "2019-01-15T15:13:15.474636Z", "url": "https://files.pythonhosted.org/packages/ab/e3/94eb1c9105a6fb28c70809df9f3059619e8568c7110e3afd43e9feba4450/pyjak-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:50 2020"}