{"info": {"author": "YuanGan Zhou, Zhen Qi, Nanxin Ning", "author_email": "zqi@che300.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Intended Audience :: Science/Research", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# \u6587\u6863\u7684\u81ea\u7136\u98ce\u683c\u589e\u5f3a\u5305\n# DouG: Document image auGmentation.\n\n* \u5c0f\u89d2\u5ea6\u65cb\u8f6c\uff08\u00b145\u00b0\u4ee5\u5185\uff09  \nSmall angle rotate (within 45 degrees)  \n[`doug.small_angle_rotate(data: dict, angle: int or tuple, prob=0.5, use_bbox=False):`](#1)\n\n* \u6a2a\u5411\u7eb5\u5411\u5149\u7167\u6e10\u53d8\u52a0\u6743   \nHorizontal and vertical light gradient weighting      \n[`horizontal_light_gradient(image: np.ndarray, prob=0.5, light_scale=None, space_type=LIGHT_LINEAR):`](#2)  \n[`vertical_light_gradient(image: np.ndarray, prob=0.5, light_scale=None, space_type=LIGHT_LINEAR):`](#3)\n\n* \u56fe\u50cf\u533a\u57df\u590d\u5236\u7c98\u8d34   \nCopy a image patch then paste on current one under mask  \n[`copy_paste_under(data:dict, prob=0.5, cover_position=COPY_INTER, fit_method=FIT_NORMAL, image_source=None, bg_mask=0, size_ratio=(5.0 / 32, 27.0 / 32)):`](#4)\n\n* \u5220\u9664\u6807\u7b7e\u4e2d\u7684\u67d0\u4e00\u7c7b\u6216\u82e5\u5e72\u7c7b\nDelete one or several labels  \n[`delete_one_class(imgs, class_num=None, bg_mask=0, prob=1.0, fill_type=DELETED_FILL_MEAN):`](#5)  \n[`delete_classes(data: dict, class_num=None, bg_mask=0, prob=1.0, fill_type=DELETED_FILL_MEAN):`](#6)\n\n* \u67d0\u4e00\u7c7b\u6216\u82e5\u5e72\u7c7b\u76ee\u6807\u653e\u5927\nZoom in one or serval class in labels, with edges slightly extended.\n[`zoom_one_class(imgs, bg_mask=0, prob=1.0, class_num=None, padding=None, constant_size=False):`](#7)  \n[`zoom_classes(imgs, bg_mask=0, prob=1.0, class_num=None, padding=None, constant_size=False):`](#8)\n\n* \u56fe\u50cf\u6dfb\u52a0\u6c34\u5370  \nAdd watermark to the current image.  \n[`add_watermark(image: np.ndarray,  watermark:str or numpy.array or tuple or list of str, watermark_position=WATERMARK_RANDOM_ANCHOR, fit_method=FIT_PASTE, prob=1.0, size_ratio=(1 / 8, 1 / 2), thresh=None):`](#9)\n\n* \u6a21\u62df\u79fb\u52a8\u8bbe\u5907\u62cd\u7167\u8f7b\u5fae\u6296\u52a8\uff0c\u9020\u6210\u56fe\u50cf\u7684\u6a21\u7cca\u6548\u679c  \nSimulate a blurry photo taken by a hand shake and return a new image  \n[`tremor_image(image: np.ndarray, x=None, y=None):`](#10)\n\n* \u591c\u95f4\u62cd\u7167\u95ea\u5149\u706f\u6548\u679c(\u5c40\u90e8\u9ad8\u4eae)\nSimulation to generate a night flash effect on an image(Local highlighting)  \n[`generate_noisy(image: np.ndarray, noise_typ: str):`](#11)\n\n* \u591c\u95f4\u62cd\u6444\u56fe\u50cf\u9ed1\u6697\u7cfb\u566a\u70b9\u98ce\u683c  \nSimulates the effect of night noise when taking photos with mobile devices at night\n[`doug.night_noise_transform(image, init_delta=12):`](#12)  \n\n* hsv\u989c\u8272\u589e\u5f3a  \nGiven a numpy ndarray image, change it's HSV color space with fraction.  \n[`hsv_transform(image, fraction=0.50):`](#13)\n\n* \u6dfb\u52a0\u76ee\u6807\u4e0a\u65b9\u7684\u906e\u6321\nGenerate occlusion by fit another image patch onto current one\n[`occlusion_paste_above(data:dict, prob=0.5, cover_position=OCCLUSION_EDGDE, fit_method=FIT_NORMAL, image_source=None, bg_mask=0, size_ratio=(1.0 / 32, 5.0 / 32)):`](#14)\n\n* \u4fee\u6b63\u56fe\u50cf\u6807\u7b7e\u4e2d\u7684\u566a\u58f0\nFix mask pixel contamination caused by image compression or cv2/PIL interpolation.  \n[`fix_jpgmask(mask: np.ndarray, class_list=None, bg_mask=0, delete_thresh=None):`](#15)\n\n* \u56fe\u50cf\u53d8\u5f62\u7b97\u6cd5 \n\n<h2 id=\"1\">small_angle_rotate(imgs, angle, prob=0.5, use_bbox=False):</h2>\n\n    \"\"\"\n    Rotate the given image as well as labels(mask or keypoints) with\n    a fixed or random small angle (within 45\u00b0). Auto generating new\n    bounding boxes based on mask and keypoints is supported.\n\n    Parameters\n    ----------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels(mask or keypoints) to be rotated.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n        label array with shape of (height, width). Keypoints contain\n        points of polygon labels with shape of (n_labels, n_coordinates).\n        Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\n    angle : int or tuple of int\n        Randomly rotate target by angle (int angle) or within\n        [angle[0], angle[1]] (tuple angle).\n    prob : float, optional\n        Probability of this augmentation.\n    bg_mask : int or float, optional\n        Background pixel value in mask. Only used when rotating mask and\n        use_bbox is True.\n    use_bbox : bool, optional\n        If True, adding a new 'bbox' key in data as the bounding box\n        of rotated mask or keypoint coordinates.\n\n    Returns\n    -------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels after this modification.\n        if use_bbox is True, the dict contains 2 extra values:\n        \"bbox\": bounding box\n        \"bbox_index\": bounding box index corresponding to labels' class\n\n    Notes\n    -----\n    To avoid coordinates disorder and generating too much space, the\n    angle should be in range of [-45, 45]. Above or below the range\n    will be clipped.\n    This function supports converting rotated mask to bounding box by\n    separating class from mask images and finding connected components.\n    The procedure may miss small objects and split obscured instances.\n    Using keypoints to generate new bounding boxes is highly recommended.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> mask = cv2.imread('img_mask.jpg')\n    >>> keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n    >>> imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n    >>> imgs_after = doug.small_angle_rotate(imgs, (-10, 15), 0.8, True)\n    \"\"\"\n<h2 id=\"2\">horizontal_light_gradient(image: np.ndarray, prob=0.5, light_scale=None, space_type=LIGHT_LINEAR):</h2>  \n\n    \"\"\"\n    Add a horizontal light gradient to the given image.  \n\n    Parameters\n    ----------\n    image : numpy.ndarray,\n        Image to be modified.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY.\n    prob : float, optional\n        Probability of this augmentation.\n    light_scale : int or float or tuple of int or tuple of float or None, optional\n        Light gradient range.\n        If the type is int, the range will be calculated by light_scale\n        and -1*light_scale. If tuple, the range will be calculated by\n        light_scale[0] and light_scale[1]. If None, this function will\n        randomly choose an int value related to the mean value of image\n        pixels, then calculate the range.\n    space_type : int, optional\n        :parameter from doug.core.DouG\n        If doug.LIGHT_LINEAR, the gradient range will be\n        [-light_scale, light_scale].\n        If doug.LIGHT_LOG, the gradient range will be\n        [log(1/light_scale), log(light_scale)].\n\n    Returns\n    -------\n    image : numpy.ndarray\n        Image after this modification.\n\n    Notes\n    -----\n    LIGHT_LINEAR and LIGHT_LOG generate different kinds of light gradient.\n    The former one is more smooth while another is more sharp at one end.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> imgs_after = doug.horizontal_light_gradient(image, 0.8, 0.1, doug.LIGHT_LOG)\n\t\"\"\"\n<h2 id=\"3\">vertical_light_gradient(image: np.ndarray, prob=0.5, light_scale=None, space_type=LIGHT_LINEAR):</h2>  \n\n    \"\"\"\n    Add a vertical light gradient to the given image.\n\n    Parameters\n    ----------\n    image : numpy.ndarray,\n        Image to be modified.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY.\n    prob : float, optional\n        Probability of this augmentation.\n    light_scale : int or float or tuple of int or tuple of float or None, optional\n        Light gradient range.\n        If the type is int or float, the range will be calculated by\n        light_scale and -1*light_scale. If tuple, the range will be\n        calculated by light_scale[0] and light_scale[1]. If None, this\n        function will randomly choose an int value related to the mean\n        value of image pixels, then calculate the range.\n    space_type : int, optional\n        :parameter from doug.core.DouG\n        If doug.LIGHT_LINEAR, the gradient range will be\n        [-light_scale, light_scale].\n        If doug.LIGHT_LOG, the gradient range will be\n        [log(1/light_scale), log(light_scale)].\n\n    Returns\n    -------\n    image : numpy.ndarray\n        Image after this modification.\n\n    Notes\n    -----\n    LIGHT_LINEAR and LIGHT_LOG generate different kinds of light gradient.\n    The former one is more smooth while another is more sharp at one end.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> imgs_after = doug.vertical_light_gradient(image, 0.8, (-100,50), doug.LIGHT_LINEAR)\n    \"\"\"  \n<h2 id=\"4\">copy_paste_under(data:dict, prob=0.5, cover_position=COPY_INTER, fit_method=FIT_NORMAL, image_source=None, bg_mask=0, size_ratio=(5.0 / 32, 27.0 / 32)):</h2>  \n\n    \"\"\"\n    Randomly copy an image patch from the original image or another given one,\n    then paste it on the original image. Support PNG alpha channel.\n    ATTENTION: The patch pixels will be slightly adjusted and when the patch\n    comes across the label, it will always be pasted UNDER.\n\n    Parameters\n    ----------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels(mask or keypoints) to be rotated.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n        label array with shape of (height, width). Keypoints contain\n        points of polygon labels with shape of (n_labels, n_coordinates).\n        Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\n    prob : float, optional\n        Probability of this augmentation.\n    cover_position: int, optional\n        Occlusion position. See from doug.core.DouG, there are 4 settings:\n        doug.COPY_INTER: the patch must intersect the mask area,\n        doug.COPY_MASK_EDGE: the patch must intersect the mask edge,\n        doug.COPY_IMAGE_EDGE: the patch must intersect the image edge,\n        doug.COPY_RANDOM: whole image random cover.\n    fit_method: int, optional\n        Image fitting algorithm. See from doug.core.DouG, there are 5 options:\n        doug.FIT_PASTE: just paste, no special move,\n        doug.FIT_NORMAL: using opencv seamlessClone: cv2.NORMAL_CLONE,\n        doug.FIT_MIX: using opencv seamlessClone: cv2.MIXED_CLONE,\n        doug.FIT_MONO: using opencv seamlessClone: cv2.MONOCHROME_TRANSFER,\n        doug.FIT_RANDOM: randomly choose from above.\n    image_source : None or str or numpy.array or tuple or list of str, optional\n        Another image source. The parameter could be a numpy.array image, a\n        string image path, a list of image paths or a string image folder\n        path that ended by '*.extension'. If None, copy from the origin.\n    bg_mask : int or float, optional\n        Background pixel value in mask.\n    size_ratio: tuple of float, optional\n        The minimum and maximum size ratio of the copied patch's longest size to \n        the original image.\n\n    Returns\n    -------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels after this modification.\n\n    Notes\n    -----\n    This function is used to generate more background texture feature in one\n    image, and man-made edge feature if cover_target is True.\n    If there are multiple labels on one image, the region would be a\n    common area generated by minimum and maximum coordinates of the\n    labels.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> mask = cv2.imread('img_mask.jpg')\n    >>> data = {\"image\":image, \"mask\":mask}\n    >>> data_after = doug.copy_paste_under(data, 0.5, image_source='./*.jpg',fit_method=doug.FIT_MIX,)\n    \"\"\"\n<h2 id=\"5\">delete_one_class(data, class_num=None, bg_mask=0, prob=1.0, fill_type=DELETED_FILL_MEAN):</h2>  \n\n    \"\"\"\n    Delete one class in labels, then fill the region using certain methods.\n\n    Parameters\n    ----------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels(mask or keypoints) to be rotated.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n        label array with shape of (height, width). Keypoints contain\n        points of polygon labels with shape of (n_labels, n_coordinates).\n        Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\n    class_num : None or int or tuple or list, optional\n        The class to be deleted. It could be an integer class number, a\n        tuple or list to be randomly chosen from or None to randomly choose\n        from all classes beside background.\n    bg_mask : int or float, optional\n        Background pixel value in mask\n    prob : float, optional\n        Probability of this augmentation.\n    fill_type : str or int, optional\n        The deleted area fill-in method or value. It could be 2 string\n        value: doug.DELETED_FILL_MEAN: fill the area with its mean value,\n        doug.DELETED_FILL_RANDOM: fill with random gaussian noise or a\n        fixed integer value to fill with.\n\n    Returns\n    -------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels after this modification.\n\n    Notes\n    -----\n    Pay attention to the background color.\n    Let us know if there are more fill-in methods.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> mask = cv2.imread('img_mask.jpg')\n    >>> keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n    >>> imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n    >>> imgs_after = doug.delete_one_class(imgs, [1,], 0, 0.8, random.choice([doug.DELETED_FILL_RANDOM,doug.DELETED_FILL_MEAN]))\n    \"\"\"\n<h2 id=\"6\">delete_classes(data: dict, class_num=None, bg_mask=0, prob=1.0, fill_type=DELETED_FILL_MEAN):</h2>  \n\n    \"\"\"\n      Delete several classes in labels, then fill the regions using certain methods.\n\n      Parameters\n      ----------\n      data : dict of str, numpy.ndarray\n          {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n          Image and labels(mask or keypoints) to be rotated.\n          The shape of image can be (height, width, chanel) if data format\n          is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n          label array with shape of (height, width). Keypoints contain\n          points of polygon labels with shape of (n_labels, n_coordinates).\n          Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\n      class_num : int or tuple or list or None, optional\n          The classes to be deleted. It could be an integer class count, a\n          tuple or list of classes to be deleted or None to randomly choose\n          random classes beside background.\n      bg_mask : int or float, optional\n          Background pixel value in mask.        \n      prob : float, optional\n          Probability of this augmentation.\n      fill_type : str or int, optional\n          The deleted area fill-in method or value. It could be 2 string \n          value: doug.DELETED_FILL_MEAN: fill the area with its mean value,\n          doug.DELETED_FILL_RANDOM: fill with random gaussian noise or a\n          fixed integer value to fill with.\n\n      Returns\n      -------\n      data : dict of str, numpy.ndarray\n          {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n          Image and labels after this modification.\n\n      Notes\n      -----\n      Pay attention to the background color.\n      Let us know if there are more fill-in methods.\n\n      Examples\n      --------\n      >>> import doug\n      >>> import cv2\n      >>> image = cv2.imread('img.jpg')\n      >>> mask = cv2.imread('img_mask.jpg')\n      >>> keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n      >>> imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n      >>> imgs_after = doug.delete_classes(imgs, [1,2], 0, 0.8, random.choice([doug.DELETED_FILL_RANDOM,doug.DELETED_FILL_MEAN]))\n      \"\"\"\n<h2 id=\"7\">zoom_one_class(data, bg_mask=0, prob=1.0, class_num=None, padding=None, constant_size=False):</h2>\n\n    \"\"\"\n    Zoom in one class in labels, with edges slightly extended.\n\n    Parameters\n    ----------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels(mask or keypoints) to be rotated.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n        label array with shape of (height, width). Keypoints contain\n        points of polygon labels with shape of (n_labels, n_coordinates).\n        Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\n    bg_mask : int or float, optional\n        Background pixel value in mask\n    prob : float, optional\n        Probability of this augmentation.\n    class_num : None or int or tuple or list, optional\n        The class to be zoomed in. It could be an integer class number, a\n        tuple or list to be randomly chosen from or None to randomly choose\n        from all classes beside background.\n    padding : None or int or tuple or list, optional\n        Padding value after zooming.\n    constant_size : bool, optional\n        Whether resize the zoomed region to the original image size.\n\n    Returns\n    -------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels after this modification.\n\n    Notes\n    -----\n    Pay attention to the background color.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> mask = cv2.imread('img_mask.jpg')\n    >>> keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n    >>> imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n    >>> imgs_after = doug.zoom_one_class(imgs, 1, 0, 0.8, 10, False)\n    \"\"\"\n\n<h2 id=\"8\">zoom_classes(data, bg_mask=0, prob=1.0, class_num=None, padding=None, constant_size=False):</h2>\n\n    \"\"\"\n    Zoom in several classes in labels, with edges slightly extended.\n\n    Parameters\n    ----------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels(mask or keypoints) to be rotated.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n        label array with shape of (height, width). Keypoints contain\n        points of polygon labels with shape of (n_labels, n_coordinates).\n        Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\n    bg_mask : int or float, optional\n        Background pixel value in mask\n    prob : float, optional\n        Probability of this augmentation.\n    class_num : None or int or tuple or list, optional\n        The classes to be zoomed in. It could be an integer class count, a\n        tuple or list of classes to be zoomed in or None to randomly choose\n        random classes beside background.\n    padding : None or int or tuple or list, optional\n        Padding value after zooming.\n    constant_size : bool, optional\n        Whether resize the zoomed region to the original image size.\n\n    Returns\n    -------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels after this modification.\n\n    Notes\n    -----\n    Pay attention to the background color.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> mask = cv2.imread('img_mask.jpg')\n    >>> keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n    >>> imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n    >>> imgs_after = doug.zoom_classes(imgs, 2, 0, 0.8, 10, False)\n    \"\"\"\n<h2 id=\"9\">add_watermark(image,  watermark, watermark_position=WATERMARK_RANDOM_ANCHOR, fit_method=FIT_PASTE, prob=1.0, size_ratio=(1 / 8, 1 / 2), thresh=None):</h2>\n\n    \"\"\"\n    Add watermark to the current image. Support PNG alpha channel.\n\n    Parameters\n    ----------\n    image : numpy.ndarray,\n        Image to be modified.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY.\n    watermark : str or numpy.array or tuple or list of str\n        Watermark image source. The parameter could be a numpy.array image,\n        a string image path, a list of image paths or a string image folder\n        path that ended by '*.extension'.\n    prob : float, optional\n        Probability of this augmentation.\n    watermark_position : int, optional\n        Watermark watermark_positionition. See from doug.core.DouG, there are 7 anchors:\n        doug.WATERMARK_UPLEFT,\n        doug.WATERMARK_UP,\n        doug.WATERMARK_UPRIGHT,\n        doug.WATERMARK_CENTER,\n        doug.WATERMARK_DOWNLEFT,\n        doug.WATERMARK_DOWN,\n        doug.WATERMARK_DOWNRIGHT,\n        1 random anchor: doug.WATERMARK_RANDOM_ANCHOR,\n        1 random watermark_positionition:doug.WATERMARK_RANDOM_ALL.\n    fit_method: int, optional\n        Image fitting algorithm. See from doug.core.DouG, there are 5 options:\n        doug.FIT_PASTE: just paste, no special move,\n        doug.FIT_NORMAL: using opencv seamlessClone: cv2.NORMAL_CLONE,\n        doug.FIT_MIX: using opencv seamlessClone: cv2.MIXED_CLONE,\n        doug.FIT_MONO: using opencv seamlessClone: cv2.MONOCHROME_TRANSFER,\n        doug.FIT_RANDOM: randomly choose from above.\n    size_ratio : tuple, optional\n        The minimum and maximum size ratio of the watermark to the original\n        image.\n    thresh : int or float or None, optional\n        Watermark threshold, regions in watermark image will be transparent\n        if their pixel value are smaller than this threshold .\n\n    Returns\n    -------\n    image : numpy.ndarray\n        Image after this modification.\n\n    Notes\n    -----\n    If both alpha channel and thresh are found, this function will calculate\n    transparent mask matrix by thresh.\n    Be advised that the thresh parameter only provides a minimum pixel value\n    threshold, only pixels have smaller values will be considered transparent.\n    Using PNG images with alpha channel is a more flexible approach.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> imgs_after = doug.add_watermark(image, './watermark.png', 0.8, doug.WATERMARK_UP, doug.FIT_NORMAL)\n    \"\"\"\n\n<h2 id=\"10\">tremor_image(image, x=None, y=None):</h2>\n\n    \"\"\"\n    Simulate a blurry photo taken by a hand shake and return a new image.\n\n    Parameters\n    ----------\n    image: numpy.ndarray.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY.\n    You have better use open_cv to read image.\n    x: int\n    The pixels that you want to move on x-axis\n    y: int\n    The pixels that you want to move on y-axis\n\n    Returns\n    -------\n    new: numpy.ndarray\n        Processed image\n\n    Notes\n    ------\n        If you don't give a x value and an y value, this function will\n        automatically choose an x value and a y value.\n        Boundary blur cannot avoid, but it doesn't have a great impact\n        on recognition. Only a few pixels are not close to the real image.\n        If you have better methods, please contact us\n\n    Examples\n    ---------\n        >>> import cv2\n        >>> import doug\n        >>> image = cv2.imread('filename')\n        >>> new = doug.tremor_image(image, x=1, y=1)\n<h2 id=\"11\">generate_noisy(image: np.ndarray, noise_typ: str):</h2>\n\n    \"\"\"Add noise data to the image\n    reference to:\n    https://stackoverflow.com/questions/22937589/how-to-add-noise-gaussian-salt-and-pepper-etc-to-image-in-python-with-opencv#\n\n    Arguments:\n        image {np.ndarray} -- Input image data. Will be converted to float.\n        noise_typ {str} -- gauss, poisson, s&p, speckle\n            'gauss'     Gaussian-distributed additive noise.\n            'poisson'   Poisson-distributed noise generated from the data.\n            's&p'       Replaces random pixels with 0 or 1.\n            'speckle'   Multiplicative noise using out = image + n*image,where\n                        n is uniform noise with specified mean & variance.\n    \"\"\"\n\n<h2 id=\"12\">doug.night_noise_transform(image, init_delta=12):</h2>\n\n    \"\"\"\n    Simulates the effect of night noise when taking photos with mobile devices at night\n\n    Parameters\n    ----------\n    image : numpy.ndarray,\n        Input Image array which data format should be (H,W,C).\n\n    init_delta : int,\n        The factor that controls brightness enhancement.\n\n    Returns\n    -------\n    image : numpy.ndarray,\n        Transformed image array.\n\n    Notes\n    -----\n    Image array data format should be (H,W,C),and C=3\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('demo.jpg')\n    >>> image = doug.night_noise_transform(image, init_delta=12)\n    \"\"\"\n<h2 id=\"13\">hsv_transform(image, fraction=0.50):</h2>\n\n    \"\"\"\n    Given a numpy ndarray image, change it's HSV color space with fraction.\n\n    Parameters\n    ----------\n    image : numpy.ndarray,\n        Input Image array which data format should be (H,W,C).\n\n    fraction : float,\n        Control the weight used in HSV transformation (default: {0.50}).\n\n    Returns\n    -------\n    image : numpy.ndarray,\n        Transformed image array.\n\n    Notes\n    -----\n    Image array data format should be (H,W,C),and C=3\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('demo.jpg')\n    >>> image = doug.image(image, fraction=0.8)\n    \"\"\"\n<h2 id=\"14\">`doug.occlusion_paste_above(data:dict, prob=0.5, cover_position=OCCLUSION_EDGDE, fit_method=FIT_NORMAL, image_source=None, bg_mask=0, size_ratio=(1.0 / 32, 5.0 / 32)):`(image, init_delta=12):</h2>\n\n    \"\"\"\n    Randomly copy an image patch from the original image or another given one,\n    then paste it on the original image. Support PNG alpha channel.\n    ATTENTION: The patch pixels will be slightly adjusted and when the patch\n    comes across the label, it will always be pasted ABOVE.\n\n    Parameters\n    ----------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels(mask or keypoints) to be rotated.\n        The shape of image can be (height, width, chanel) if data format\n        is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n        label array with shape of (height, width). Keypoints contain\n        points of polygon labels with shape of (n_labels, n_coordinates).\n        Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\n    prob : float, optional\n        Probability of this augmentation.\n    cover_position: int, optional\n        Occlusion position. See from doug.core.DouG, there are 3 settings:\n        doug.OCCLUSION_INTER: the patch must intersect the mask area,\n        doug.OCCLUSION_EDGDE: the patch must intersect the mask edge,\n        doug.OCCLUSION_RANDOM: whole image random cover.\n    fit_method: int, optional\n        Image fitting algorithm. See from doug.core.DouG, there are 5 options:\n        doug.FIT_PASTE: just paste, no special move,\n        doug.FIT_NORMAL: using opencv seamlessClone: cv2.NORMAL_CLONE,\n        doug.FIT_MIX: using opencv seamlessClone: cv2.MIXED_CLONE,\n        doug.FIT_MONO: using opencv seamlessClone: cv2.MONOCHROME_TRANSFER,\n        doug.FIT_RANDOM: randomly choose from above.\n    image_source : None or str or numpy.array or tuple or list of str, optional\n        Another image source. The parameter could be a numpy.array image, a\n        string image path, a list of image paths or a string image folder\n        path that ended by '*.extension'. If None, copy from the origin.\n    bg_mask : int or float, optional\n        Background pixel value in mask.\n    size_ratio: tuple of float, optional\n        The minimum and maximum size ratio of the copied patch's longest size to \n        the original image.\n\n    Returns\n    -------\n    data : dict of str, numpy.ndarray\n        {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n        Image and labels after this modification.\n\n    Notes\n    -----\n    This function is used to generate synthetic occlusion influence.\n    If there are multiple labels on one image, the region would be a\n    common area generated by minimum and maximum coordinates of the\n    labels.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> image = cv2.imread('img.jpg')\n    >>> mask = cv2.imread('img_mask.jpg')\n    >>> data = {\"image\":image, \"mask\":mask}\n    >>> data_after = doug.occlusion_paste_above(data,0.5, image_source='./*.jpg',cover_position=doug.OCCLUSION_EDGDE)\n    \"\"\"\n<h2 id=\"15\">doug.fix_jpgmask(mask, class_list=None, bg_mask=0, delete_thresh=None):</h2>\n\n    \"\"\"\n    Fix mask pixel contamination caused by image compression or cv2/PIL\n    interpolation.\n\n    Parameters\n    ----------\n    mask : dict of str, numpy.ndarray\n        Mask to be fixed.\n        The mask should be a (height, width) grayscale image and every pixel\n        value indicates certain class.\n    class_list : tuple or list or None, optional\n        Legitimate class numbers in mask. Any excepting value in mask will\n        be deleted\n    bg_mask : int or float, optional\n        Background pixel value in mask.\n    delete_thresh: float or None, optional\n        Minimum pixel count (width * delete_thresh * height * delete_thresh)\n        to be regarded as noise.\n\n    Returns\n    -------\n    mask : numpy.ndarray,\n        Mask after this modification.\n\n    Notes\n    -----\n    This function is used to fix pixel contamination in mask, specifically\n    deleting redundant dots and lines, and deleting unexpected pixel value.\n\n    Examples\n    --------\n    >>> import doug\n    >>> import cv2\n    >>> mask = cv2.imread('img_mask.jpg')\n    >>> mask_after = doug.occlusion_paste_above(mask, [1,2], 0, None)\n    \"\"\"\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "doug", "package_url": "https://pypi.org/project/doug/", "platform": "", "project_url": "https://pypi.org/project/doug/", "project_urls": null, "release_url": "https://pypi.org/project/doug/0.1.0/", "requires_dist": ["numpy (>=1.11.1)", "opencv-python (>=3.4.2)"], "requires_python": ">=3.5", "summary": "Document image aUGmentation.", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>\u6587\u6863\u7684\u81ea\u7136\u98ce\u683c\u589e\u5f3a\u5305</h1>\n<h1>DouG: Document image auGmentation.</h1>\n<ul>\n<li>\n<p>\u5c0f\u89d2\u5ea6\u65cb\u8f6c\uff08\u00b145\u00b0\u4ee5\u5185\uff09<br>\nSmall angle rotate (within 45 degrees)<br>\n<a href=\"#1\" rel=\"nofollow\"><code>doug.small_angle_rotate(data: dict, angle: int or tuple, prob=0.5, use_bbox=False):</code></a></p>\n</li>\n<li>\n<p>\u6a2a\u5411\u7eb5\u5411\u5149\u7167\u6e10\u53d8\u52a0\u6743<br>\nHorizontal and vertical light gradient weighting<br>\n<a href=\"#2\" rel=\"nofollow\"><code>horizontal_light_gradient(image: np.ndarray, prob=0.5, light_scale=None, space_type=LIGHT_LINEAR):</code></a><br>\n<a href=\"#3\" rel=\"nofollow\"><code>vertical_light_gradient(image: np.ndarray, prob=0.5, light_scale=None, space_type=LIGHT_LINEAR):</code></a></p>\n</li>\n<li>\n<p>\u56fe\u50cf\u533a\u57df\u590d\u5236\u7c98\u8d34<br>\nCopy a image patch then paste on current one under mask<br>\n<a href=\"#4\" rel=\"nofollow\"><code>copy_paste_under(data:dict, prob=0.5, cover_position=COPY_INTER, fit_method=FIT_NORMAL, image_source=None, bg_mask=0, size_ratio=(5.0 / 32, 27.0 / 32)):</code></a></p>\n</li>\n<li>\n<p>\u5220\u9664\u6807\u7b7e\u4e2d\u7684\u67d0\u4e00\u7c7b\u6216\u82e5\u5e72\u7c7b\nDelete one or several labels<br>\n<a href=\"#5\" rel=\"nofollow\"><code>delete_one_class(imgs, class_num=None, bg_mask=0, prob=1.0, fill_type=DELETED_FILL_MEAN):</code></a><br>\n<a href=\"#6\" rel=\"nofollow\"><code>delete_classes(data: dict, class_num=None, bg_mask=0, prob=1.0, fill_type=DELETED_FILL_MEAN):</code></a></p>\n</li>\n<li>\n<p>\u67d0\u4e00\u7c7b\u6216\u82e5\u5e72\u7c7b\u76ee\u6807\u653e\u5927\nZoom in one or serval class in labels, with edges slightly extended.\n<a href=\"#7\" rel=\"nofollow\"><code>zoom_one_class(imgs, bg_mask=0, prob=1.0, class_num=None, padding=None, constant_size=False):</code></a><br>\n<a href=\"#8\" rel=\"nofollow\"><code>zoom_classes(imgs, bg_mask=0, prob=1.0, class_num=None, padding=None, constant_size=False):</code></a></p>\n</li>\n<li>\n<p>\u56fe\u50cf\u6dfb\u52a0\u6c34\u5370<br>\nAdd watermark to the current image.<br>\n<a href=\"#9\" rel=\"nofollow\"><code>add_watermark(image: np.ndarray, watermark:str or numpy.array or tuple or list of str, watermark_position=WATERMARK_RANDOM_ANCHOR, fit_method=FIT_PASTE, prob=1.0, size_ratio=(1 / 8, 1 / 2), thresh=None):</code></a></p>\n</li>\n<li>\n<p>\u6a21\u62df\u79fb\u52a8\u8bbe\u5907\u62cd\u7167\u8f7b\u5fae\u6296\u52a8\uff0c\u9020\u6210\u56fe\u50cf\u7684\u6a21\u7cca\u6548\u679c<br>\nSimulate a blurry photo taken by a hand shake and return a new image<br>\n<a href=\"#10\" rel=\"nofollow\"><code>tremor_image(image: np.ndarray, x=None, y=None):</code></a></p>\n</li>\n<li>\n<p>\u591c\u95f4\u62cd\u7167\u95ea\u5149\u706f\u6548\u679c(\u5c40\u90e8\u9ad8\u4eae)\nSimulation to generate a night flash effect on an image(Local highlighting)<br>\n<a href=\"#11\" rel=\"nofollow\"><code>generate_noisy(image: np.ndarray, noise_typ: str):</code></a></p>\n</li>\n<li>\n<p>\u591c\u95f4\u62cd\u6444\u56fe\u50cf\u9ed1\u6697\u7cfb\u566a\u70b9\u98ce\u683c<br>\nSimulates the effect of night noise when taking photos with mobile devices at night\n<a href=\"#12\" rel=\"nofollow\"><code>doug.night_noise_transform(image, init_delta=12):</code></a></p>\n</li>\n<li>\n<p>hsv\u989c\u8272\u589e\u5f3a<br>\nGiven a numpy ndarray image, change it's HSV color space with fraction.<br>\n<a href=\"#13\" rel=\"nofollow\"><code>hsv_transform(image, fraction=0.50):</code></a></p>\n</li>\n<li>\n<p>\u6dfb\u52a0\u76ee\u6807\u4e0a\u65b9\u7684\u906e\u6321\nGenerate occlusion by fit another image patch onto current one\n<a href=\"#14\" rel=\"nofollow\"><code>occlusion_paste_above(data:dict, prob=0.5, cover_position=OCCLUSION_EDGDE, fit_method=FIT_NORMAL, image_source=None, bg_mask=0, size_ratio=(1.0 / 32, 5.0 / 32)):</code></a></p>\n</li>\n<li>\n<p>\u4fee\u6b63\u56fe\u50cf\u6807\u7b7e\u4e2d\u7684\u566a\u58f0\nFix mask pixel contamination caused by image compression or cv2/PIL interpolation.<br>\n<a href=\"#15\" rel=\"nofollow\"><code>fix_jpgmask(mask: np.ndarray, class_list=None, bg_mask=0, delete_thresh=None):</code></a></p>\n</li>\n<li>\n<p>\u56fe\u50cf\u53d8\u5f62\u7b97\u6cd5</p>\n</li>\n</ul>\n<h2 id=\"1\">small_angle_rotate(imgs, angle, prob=0.5, use_bbox=False):</h2>\n<pre><code>\"\"\"\nRotate the given image as well as labels(mask or keypoints) with\na fixed or random small angle (within 45\u00b0). Auto generating new\nbounding boxes based on mask and keypoints is supported.\n\nParameters\n----------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels(mask or keypoints) to be rotated.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n    label array with shape of (height, width). Keypoints contain\n    points of polygon labels with shape of (n_labels, n_coordinates).\n    Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\nangle : int or tuple of int\n    Randomly rotate target by angle (int angle) or within\n    [angle[0], angle[1]] (tuple angle).\nprob : float, optional\n    Probability of this augmentation.\nbg_mask : int or float, optional\n    Background pixel value in mask. Only used when rotating mask and\n    use_bbox is True.\nuse_bbox : bool, optional\n    If True, adding a new 'bbox' key in data as the bounding box\n    of rotated mask or keypoint coordinates.\n\nReturns\n-------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels after this modification.\n    if use_bbox is True, the dict contains 2 extra values:\n    \"bbox\": bounding box\n    \"bbox_index\": bounding box index corresponding to labels' class\n\nNotes\n-----\nTo avoid coordinates disorder and generating too much space, the\nangle should be in range of [-45, 45]. Above or below the range\nwill be clipped.\nThis function supports converting rotated mask to bounding box by\nseparating class from mask images and finding connected components.\nThe procedure may miss small objects and split obscured instances.\nUsing keypoints to generate new bounding boxes is highly recommended.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; mask = cv2.imread('img_mask.jpg')\n&gt;&gt;&gt; keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n&gt;&gt;&gt; imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n&gt;&gt;&gt; imgs_after = doug.small_angle_rotate(imgs, (-10, 15), 0.8, True)\n\"\"\"\n</code></pre>\n<h2 id=\"2\">horizontal_light_gradient(image: np.ndarray, prob=0.5, light_scale=None, space_type=LIGHT_LINEAR):</h2>  \n<pre><code>\"\"\"\nAdd a horizontal light gradient to the given image.  \n\nParameters\n----------\nimage : numpy.ndarray,\n    Image to be modified.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY.\nprob : float, optional\n    Probability of this augmentation.\nlight_scale : int or float or tuple of int or tuple of float or None, optional\n    Light gradient range.\n    If the type is int, the range will be calculated by light_scale\n    and -1*light_scale. If tuple, the range will be calculated by\n    light_scale[0] and light_scale[1]. If None, this function will\n    randomly choose an int value related to the mean value of image\n    pixels, then calculate the range.\nspace_type : int, optional\n    :parameter from doug.core.DouG\n    If doug.LIGHT_LINEAR, the gradient range will be\n    [-light_scale, light_scale].\n    If doug.LIGHT_LOG, the gradient range will be\n    [log(1/light_scale), log(light_scale)].\n\nReturns\n-------\nimage : numpy.ndarray\n    Image after this modification.\n\nNotes\n-----\nLIGHT_LINEAR and LIGHT_LOG generate different kinds of light gradient.\nThe former one is more smooth while another is more sharp at one end.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; imgs_after = doug.horizontal_light_gradient(image, 0.8, 0.1, doug.LIGHT_LOG)\n\"\"\"\n</code></pre>\n<h2 id=\"3\">vertical_light_gradient(image: np.ndarray, prob=0.5, light_scale=None, space_type=LIGHT_LINEAR):</h2>  \n<pre><code>\"\"\"\nAdd a vertical light gradient to the given image.\n\nParameters\n----------\nimage : numpy.ndarray,\n    Image to be modified.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY.\nprob : float, optional\n    Probability of this augmentation.\nlight_scale : int or float or tuple of int or tuple of float or None, optional\n    Light gradient range.\n    If the type is int or float, the range will be calculated by\n    light_scale and -1*light_scale. If tuple, the range will be\n    calculated by light_scale[0] and light_scale[1]. If None, this\n    function will randomly choose an int value related to the mean\n    value of image pixels, then calculate the range.\nspace_type : int, optional\n    :parameter from doug.core.DouG\n    If doug.LIGHT_LINEAR, the gradient range will be\n    [-light_scale, light_scale].\n    If doug.LIGHT_LOG, the gradient range will be\n    [log(1/light_scale), log(light_scale)].\n\nReturns\n-------\nimage : numpy.ndarray\n    Image after this modification.\n\nNotes\n-----\nLIGHT_LINEAR and LIGHT_LOG generate different kinds of light gradient.\nThe former one is more smooth while another is more sharp at one end.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; imgs_after = doug.vertical_light_gradient(image, 0.8, (-100,50), doug.LIGHT_LINEAR)\n\"\"\"  \n</code></pre>\n<h2 id=\"4\">copy_paste_under(data:dict, prob=0.5, cover_position=COPY_INTER, fit_method=FIT_NORMAL, image_source=None, bg_mask=0, size_ratio=(5.0 / 32, 27.0 / 32)):</h2>  \n<pre><code>\"\"\"\nRandomly copy an image patch from the original image or another given one,\nthen paste it on the original image. Support PNG alpha channel.\nATTENTION: The patch pixels will be slightly adjusted and when the patch\ncomes across the label, it will always be pasted UNDER.\n\nParameters\n----------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels(mask or keypoints) to be rotated.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n    label array with shape of (height, width). Keypoints contain\n    points of polygon labels with shape of (n_labels, n_coordinates).\n    Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\nprob : float, optional\n    Probability of this augmentation.\ncover_position: int, optional\n    Occlusion position. See from doug.core.DouG, there are 4 settings:\n    doug.COPY_INTER: the patch must intersect the mask area,\n    doug.COPY_MASK_EDGE: the patch must intersect the mask edge,\n    doug.COPY_IMAGE_EDGE: the patch must intersect the image edge,\n    doug.COPY_RANDOM: whole image random cover.\nfit_method: int, optional\n    Image fitting algorithm. See from doug.core.DouG, there are 5 options:\n    doug.FIT_PASTE: just paste, no special move,\n    doug.FIT_NORMAL: using opencv seamlessClone: cv2.NORMAL_CLONE,\n    doug.FIT_MIX: using opencv seamlessClone: cv2.MIXED_CLONE,\n    doug.FIT_MONO: using opencv seamlessClone: cv2.MONOCHROME_TRANSFER,\n    doug.FIT_RANDOM: randomly choose from above.\nimage_source : None or str or numpy.array or tuple or list of str, optional\n    Another image source. The parameter could be a numpy.array image, a\n    string image path, a list of image paths or a string image folder\n    path that ended by '*.extension'. If None, copy from the origin.\nbg_mask : int or float, optional\n    Background pixel value in mask.\nsize_ratio: tuple of float, optional\n    The minimum and maximum size ratio of the copied patch's longest size to \n    the original image.\n\nReturns\n-------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels after this modification.\n\nNotes\n-----\nThis function is used to generate more background texture feature in one\nimage, and man-made edge feature if cover_target is True.\nIf there are multiple labels on one image, the region would be a\ncommon area generated by minimum and maximum coordinates of the\nlabels.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; mask = cv2.imread('img_mask.jpg')\n&gt;&gt;&gt; data = {\"image\":image, \"mask\":mask}\n&gt;&gt;&gt; data_after = doug.copy_paste_under(data, 0.5, image_source='./*.jpg',fit_method=doug.FIT_MIX,)\n\"\"\"\n</code></pre>\n<h2 id=\"5\">delete_one_class(data, class_num=None, bg_mask=0, prob=1.0, fill_type=DELETED_FILL_MEAN):</h2>  \n<pre><code>\"\"\"\nDelete one class in labels, then fill the region using certain methods.\n\nParameters\n----------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels(mask or keypoints) to be rotated.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n    label array with shape of (height, width). Keypoints contain\n    points of polygon labels with shape of (n_labels, n_coordinates).\n    Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\nclass_num : None or int or tuple or list, optional\n    The class to be deleted. It could be an integer class number, a\n    tuple or list to be randomly chosen from or None to randomly choose\n    from all classes beside background.\nbg_mask : int or float, optional\n    Background pixel value in mask\nprob : float, optional\n    Probability of this augmentation.\nfill_type : str or int, optional\n    The deleted area fill-in method or value. It could be 2 string\n    value: doug.DELETED_FILL_MEAN: fill the area with its mean value,\n    doug.DELETED_FILL_RANDOM: fill with random gaussian noise or a\n    fixed integer value to fill with.\n\nReturns\n-------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels after this modification.\n\nNotes\n-----\nPay attention to the background color.\nLet us know if there are more fill-in methods.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; mask = cv2.imread('img_mask.jpg')\n&gt;&gt;&gt; keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n&gt;&gt;&gt; imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n&gt;&gt;&gt; imgs_after = doug.delete_one_class(imgs, [1,], 0, 0.8, random.choice([doug.DELETED_FILL_RANDOM,doug.DELETED_FILL_MEAN]))\n\"\"\"\n</code></pre>\n<h2 id=\"6\">delete_classes(data: dict, class_num=None, bg_mask=0, prob=1.0, fill_type=DELETED_FILL_MEAN):</h2>  \n<pre><code>\"\"\"\n  Delete several classes in labels, then fill the regions using certain methods.\n\n  Parameters\n  ----------\n  data : dict of str, numpy.ndarray\n      {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n      Image and labels(mask or keypoints) to be rotated.\n      The shape of image can be (height, width, chanel) if data format\n      is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n      label array with shape of (height, width). Keypoints contain\n      points of polygon labels with shape of (n_labels, n_coordinates).\n      Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\n  class_num : int or tuple or list or None, optional\n      The classes to be deleted. It could be an integer class count, a\n      tuple or list of classes to be deleted or None to randomly choose\n      random classes beside background.\n  bg_mask : int or float, optional\n      Background pixel value in mask.        \n  prob : float, optional\n      Probability of this augmentation.\n  fill_type : str or int, optional\n      The deleted area fill-in method or value. It could be 2 string \n      value: doug.DELETED_FILL_MEAN: fill the area with its mean value,\n      doug.DELETED_FILL_RANDOM: fill with random gaussian noise or a\n      fixed integer value to fill with.\n\n  Returns\n  -------\n  data : dict of str, numpy.ndarray\n      {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n      Image and labels after this modification.\n\n  Notes\n  -----\n  Pay attention to the background color.\n  Let us know if there are more fill-in methods.\n\n  Examples\n  --------\n  &gt;&gt;&gt; import doug\n  &gt;&gt;&gt; import cv2\n  &gt;&gt;&gt; image = cv2.imread('img.jpg')\n  &gt;&gt;&gt; mask = cv2.imread('img_mask.jpg')\n  &gt;&gt;&gt; keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n  &gt;&gt;&gt; imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n  &gt;&gt;&gt; imgs_after = doug.delete_classes(imgs, [1,2], 0, 0.8, random.choice([doug.DELETED_FILL_RANDOM,doug.DELETED_FILL_MEAN]))\n  \"\"\"\n</code></pre>\n<h2 id=\"7\">zoom_one_class(data, bg_mask=0, prob=1.0, class_num=None, padding=None, constant_size=False):</h2>\n<pre><code>\"\"\"\nZoom in one class in labels, with edges slightly extended.\n\nParameters\n----------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels(mask or keypoints) to be rotated.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n    label array with shape of (height, width). Keypoints contain\n    points of polygon labels with shape of (n_labels, n_coordinates).\n    Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\nbg_mask : int or float, optional\n    Background pixel value in mask\nprob : float, optional\n    Probability of this augmentation.\nclass_num : None or int or tuple or list, optional\n    The class to be zoomed in. It could be an integer class number, a\n    tuple or list to be randomly chosen from or None to randomly choose\n    from all classes beside background.\npadding : None or int or tuple or list, optional\n    Padding value after zooming.\nconstant_size : bool, optional\n    Whether resize the zoomed region to the original image size.\n\nReturns\n-------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels after this modification.\n\nNotes\n-----\nPay attention to the background color.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; mask = cv2.imread('img_mask.jpg')\n&gt;&gt;&gt; keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n&gt;&gt;&gt; imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n&gt;&gt;&gt; imgs_after = doug.zoom_one_class(imgs, 1, 0, 0.8, 10, False)\n\"\"\"\n</code></pre>\n<h2 id=\"8\">zoom_classes(data, bg_mask=0, prob=1.0, class_num=None, padding=None, constant_size=False):</h2>\n<pre><code>\"\"\"\nZoom in several classes in labels, with edges slightly extended.\n\nParameters\n----------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels(mask or keypoints) to be rotated.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n    label array with shape of (height, width). Keypoints contain\n    points of polygon labels with shape of (n_labels, n_coordinates).\n    Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\nbg_mask : int or float, optional\n    Background pixel value in mask\nprob : float, optional\n    Probability of this augmentation.\nclass_num : None or int or tuple or list, optional\n    The classes to be zoomed in. It could be an integer class count, a\n    tuple or list of classes to be zoomed in or None to randomly choose\n    random classes beside background.\npadding : None or int or tuple or list, optional\n    Padding value after zooming.\nconstant_size : bool, optional\n    Whether resize the zoomed region to the original image size.\n\nReturns\n-------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels after this modification.\n\nNotes\n-----\nPay attention to the background color.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; mask = cv2.imread('img_mask.jpg')\n&gt;&gt;&gt; keypoints = np.array([[100, 100, 100, 200, 200, 200, 200, 100]])\n&gt;&gt;&gt; imgs = {\"image\":image, \"mask\":mask, \"keypoints\":keypoints}\n&gt;&gt;&gt; imgs_after = doug.zoom_classes(imgs, 2, 0, 0.8, 10, False)\n\"\"\"\n</code></pre>\n<h2 id=\"9\">add_watermark(image,  watermark, watermark_position=WATERMARK_RANDOM_ANCHOR, fit_method=FIT_PASTE, prob=1.0, size_ratio=(1 / 8, 1 / 2), thresh=None):</h2>\n<pre><code>\"\"\"\nAdd watermark to the current image. Support PNG alpha channel.\n\nParameters\n----------\nimage : numpy.ndarray,\n    Image to be modified.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY.\nwatermark : str or numpy.array or tuple or list of str\n    Watermark image source. The parameter could be a numpy.array image,\n    a string image path, a list of image paths or a string image folder\n    path that ended by '*.extension'.\nprob : float, optional\n    Probability of this augmentation.\nwatermark_position : int, optional\n    Watermark watermark_positionition. See from doug.core.DouG, there are 7 anchors:\n    doug.WATERMARK_UPLEFT,\n    doug.WATERMARK_UP,\n    doug.WATERMARK_UPRIGHT,\n    doug.WATERMARK_CENTER,\n    doug.WATERMARK_DOWNLEFT,\n    doug.WATERMARK_DOWN,\n    doug.WATERMARK_DOWNRIGHT,\n    1 random anchor: doug.WATERMARK_RANDOM_ANCHOR,\n    1 random watermark_positionition:doug.WATERMARK_RANDOM_ALL.\nfit_method: int, optional\n    Image fitting algorithm. See from doug.core.DouG, there are 5 options:\n    doug.FIT_PASTE: just paste, no special move,\n    doug.FIT_NORMAL: using opencv seamlessClone: cv2.NORMAL_CLONE,\n    doug.FIT_MIX: using opencv seamlessClone: cv2.MIXED_CLONE,\n    doug.FIT_MONO: using opencv seamlessClone: cv2.MONOCHROME_TRANSFER,\n    doug.FIT_RANDOM: randomly choose from above.\nsize_ratio : tuple, optional\n    The minimum and maximum size ratio of the watermark to the original\n    image.\nthresh : int or float or None, optional\n    Watermark threshold, regions in watermark image will be transparent\n    if their pixel value are smaller than this threshold .\n\nReturns\n-------\nimage : numpy.ndarray\n    Image after this modification.\n\nNotes\n-----\nIf both alpha channel and thresh are found, this function will calculate\ntransparent mask matrix by thresh.\nBe advised that the thresh parameter only provides a minimum pixel value\nthreshold, only pixels have smaller values will be considered transparent.\nUsing PNG images with alpha channel is a more flexible approach.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; imgs_after = doug.add_watermark(image, './watermark.png', 0.8, doug.WATERMARK_UP, doug.FIT_NORMAL)\n\"\"\"\n</code></pre>\n<h2 id=\"10\">tremor_image(image, x=None, y=None):</h2>\n<pre><code>\"\"\"\nSimulate a blurry photo taken by a hand shake and return a new image.\n\nParameters\n----------\nimage: numpy.ndarray.\nThe shape of image can be (height, width, chanel) if data format\nis RGB/RGBA or (height, width) if GRAY.\nYou have better use open_cv to read image.\nx: int\nThe pixels that you want to move on x-axis\ny: int\nThe pixels that you want to move on y-axis\n\nReturns\n-------\nnew: numpy.ndarray\n    Processed image\n\nNotes\n------\n    If you don't give a x value and an y value, this function will\n    automatically choose an x value and a y value.\n    Boundary blur cannot avoid, but it doesn't have a great impact\n    on recognition. Only a few pixels are not close to the real image.\n    If you have better methods, please contact us\n\nExamples\n---------\n    &gt;&gt;&gt; import cv2\n    &gt;&gt;&gt; import doug\n    &gt;&gt;&gt; image = cv2.imread('filename')\n    &gt;&gt;&gt; new = doug.tremor_image(image, x=1, y=1)\n</code></pre>\n<h2 id=\"11\">generate_noisy(image: np.ndarray, noise_typ: str):</h2>\n<pre><code>\"\"\"Add noise data to the image\nreference to:\nhttps://stackoverflow.com/questions/22937589/how-to-add-noise-gaussian-salt-and-pepper-etc-to-image-in-python-with-opencv#\n\nArguments:\n    image {np.ndarray} -- Input image data. Will be converted to float.\n    noise_typ {str} -- gauss, poisson, s&amp;p, speckle\n        'gauss'     Gaussian-distributed additive noise.\n        'poisson'   Poisson-distributed noise generated from the data.\n        's&amp;p'       Replaces random pixels with 0 or 1.\n        'speckle'   Multiplicative noise using out = image + n*image,where\n                    n is uniform noise with specified mean &amp; variance.\n\"\"\"\n</code></pre>\n<h2 id=\"12\">doug.night_noise_transform(image, init_delta=12):</h2>\n<pre><code>\"\"\"\nSimulates the effect of night noise when taking photos with mobile devices at night\n\nParameters\n----------\nimage : numpy.ndarray,\n    Input Image array which data format should be (H,W,C).\n\ninit_delta : int,\n    The factor that controls brightness enhancement.\n\nReturns\n-------\nimage : numpy.ndarray,\n    Transformed image array.\n\nNotes\n-----\nImage array data format should be (H,W,C),and C=3\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('demo.jpg')\n&gt;&gt;&gt; image = doug.night_noise_transform(image, init_delta=12)\n\"\"\"\n</code></pre>\n<h2 id=\"13\">hsv_transform(image, fraction=0.50):</h2>\n<pre><code>\"\"\"\nGiven a numpy ndarray image, change it's HSV color space with fraction.\n\nParameters\n----------\nimage : numpy.ndarray,\n    Input Image array which data format should be (H,W,C).\n\nfraction : float,\n    Control the weight used in HSV transformation (default: {0.50}).\n\nReturns\n-------\nimage : numpy.ndarray,\n    Transformed image array.\n\nNotes\n-----\nImage array data format should be (H,W,C),and C=3\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('demo.jpg')\n&gt;&gt;&gt; image = doug.image(image, fraction=0.8)\n\"\"\"\n</code></pre>\n<h2 id=\"14\">`doug.occlusion_paste_above(data:dict, prob=0.5, cover_position=OCCLUSION_EDGDE, fit_method=FIT_NORMAL, image_source=None, bg_mask=0, size_ratio=(1.0 / 32, 5.0 / 32)):`(image, init_delta=12):</h2>\n<pre><code>\"\"\"\nRandomly copy an image patch from the original image or another given one,\nthen paste it on the original image. Support PNG alpha channel.\nATTENTION: The patch pixels will be slightly adjusted and when the patch\ncomes across the label, it will always be pasted ABOVE.\n\nParameters\n----------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels(mask or keypoints) to be rotated.\n    The shape of image can be (height, width, chanel) if data format\n    is RGB/RGBA or (height, width) if GRAY. Mask is a pixel-level\n    label array with shape of (height, width). Keypoints contain\n    points of polygon labels with shape of (n_labels, n_coordinates).\n    Coordinates should be in order of [x1, y1, x2, y2 ...], clockwise.\nprob : float, optional\n    Probability of this augmentation.\ncover_position: int, optional\n    Occlusion position. See from doug.core.DouG, there are 3 settings:\n    doug.OCCLUSION_INTER: the patch must intersect the mask area,\n    doug.OCCLUSION_EDGDE: the patch must intersect the mask edge,\n    doug.OCCLUSION_RANDOM: whole image random cover.\nfit_method: int, optional\n    Image fitting algorithm. See from doug.core.DouG, there are 5 options:\n    doug.FIT_PASTE: just paste, no special move,\n    doug.FIT_NORMAL: using opencv seamlessClone: cv2.NORMAL_CLONE,\n    doug.FIT_MIX: using opencv seamlessClone: cv2.MIXED_CLONE,\n    doug.FIT_MONO: using opencv seamlessClone: cv2.MONOCHROME_TRANSFER,\n    doug.FIT_RANDOM: randomly choose from above.\nimage_source : None or str or numpy.array or tuple or list of str, optional\n    Another image source. The parameter could be a numpy.array image, a\n    string image path, a list of image paths or a string image folder\n    path that ended by '*.extension'. If None, copy from the origin.\nbg_mask : int or float, optional\n    Background pixel value in mask.\nsize_ratio: tuple of float, optional\n    The minimum and maximum size ratio of the copied patch's longest size to \n    the original image.\n\nReturns\n-------\ndata : dict of str, numpy.ndarray\n    {\"image\": image, \"mask\": mask/None, \"keypoints\": points/None}\n    Image and labels after this modification.\n\nNotes\n-----\nThis function is used to generate synthetic occlusion influence.\nIf there are multiple labels on one image, the region would be a\ncommon area generated by minimum and maximum coordinates of the\nlabels.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; image = cv2.imread('img.jpg')\n&gt;&gt;&gt; mask = cv2.imread('img_mask.jpg')\n&gt;&gt;&gt; data = {\"image\":image, \"mask\":mask}\n&gt;&gt;&gt; data_after = doug.occlusion_paste_above(data,0.5, image_source='./*.jpg',cover_position=doug.OCCLUSION_EDGDE)\n\"\"\"\n</code></pre>\n<h2 id=\"15\">doug.fix_jpgmask(mask, class_list=None, bg_mask=0, delete_thresh=None):</h2>\n<pre><code>\"\"\"\nFix mask pixel contamination caused by image compression or cv2/PIL\ninterpolation.\n\nParameters\n----------\nmask : dict of str, numpy.ndarray\n    Mask to be fixed.\n    The mask should be a (height, width) grayscale image and every pixel\n    value indicates certain class.\nclass_list : tuple or list or None, optional\n    Legitimate class numbers in mask. Any excepting value in mask will\n    be deleted\nbg_mask : int or float, optional\n    Background pixel value in mask.\ndelete_thresh: float or None, optional\n    Minimum pixel count (width * delete_thresh * height * delete_thresh)\n    to be regarded as noise.\n\nReturns\n-------\nmask : numpy.ndarray,\n    Mask after this modification.\n\nNotes\n-----\nThis function is used to fix pixel contamination in mask, specifically\ndeleting redundant dots and lines, and deleting unexpected pixel value.\n\nExamples\n--------\n&gt;&gt;&gt; import doug\n&gt;&gt;&gt; import cv2\n&gt;&gt;&gt; mask = cv2.imread('img_mask.jpg')\n&gt;&gt;&gt; mask_after = doug.occlusion_paste_above(mask, [1,2], 0, None)\n\"\"\"\n</code></pre>\n\n          </div>"}, "last_serial": 6782106, "releases": {"0.0.3": [{"comment_text": "", "digests": {"md5": "06f62302ea3a1863705573dcb0bf440e", "sha256": "96d39c687c2446700c5d2220d777bd14bfaecb3a846d5f71c950513dfdd5a075"}, "downloads": -1, "filename": "doug-0.0.3-cp35-cp35m-win_amd64.whl", "has_sig": false, "md5_digest": "06f62302ea3a1863705573dcb0bf440e", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": ">=3.5", "size": 730577, "upload_time": "2020-03-05T08:36:39", "upload_time_iso_8601": "2020-03-05T08:36:39.090888Z", "url": "https://files.pythonhosted.org/packages/26/24/7c6cb7b6e82dc68ee46038e2f447f3d4e8b14bd4b737489b0adbfe30546f/doug-0.0.3-cp35-cp35m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "50b5cdea946ddf407ed925a34df1eeea", "sha256": "6ed82c4fa4e2714f62630cc1d81cb2eff99b9a29d8bbe9e6670954f299959b55"}, "downloads": -1, "filename": "doug-0.0.3-cp36-cp36m-win_amd64.whl", "has_sig": false, "md5_digest": "50b5cdea946ddf407ed925a34df1eeea", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.5", "size": 799680, "upload_time": "2020-03-05T08:37:45", "upload_time_iso_8601": "2020-03-05T08:37:45.353315Z", "url": "https://files.pythonhosted.org/packages/a1/c1/de5e243098c0d0547bd9729b86d1f4a59b958fb342ef750d492164336a8a/doug-0.0.3-cp36-cp36m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f0a8253df7f5484ca26dc4b04eebe189", "sha256": "cd1292b5721d69e3a95ccd60472be02d1a2cdd52ec493d1b83fb3b7ed8028a7b"}, "downloads": -1, "filename": "doug-0.0.3-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "f0a8253df7f5484ca26dc4b04eebe189", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": ">=3.5", "size": 3939364, "upload_time": "2020-03-09T08:37:08", "upload_time_iso_8601": "2020-03-09T08:37:08.099275Z", "url": "https://files.pythonhosted.org/packages/7c/6b/709499e711f4839ee3e750c2c70136b54b226cb49beb36a0d4c643522f93/doug-0.0.3-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a4f388ed53b26f602c2aaa13a10f6400", "sha256": "99f7c5bb42a32abb6a040b51655708cfe97cfb289d8c400a03def914386ce1fd"}, "downloads": -1, "filename": "doug-0.0.3-cp37-cp37m-win_amd64.whl", "has_sig": false, "md5_digest": "a4f388ed53b26f602c2aaa13a10f6400", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": ">=3.5", "size": 783417, "upload_time": "2020-03-05T08:38:07", "upload_time_iso_8601": "2020-03-05T08:38:07.684808Z", "url": "https://files.pythonhosted.org/packages/50/b7/59754f216eb3976aafb964ec8a5254f1b56e82a2981a03cbdc4399a436fa/doug-0.0.3-cp37-cp37m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "446e993c4b0b6c4a9a6de4d8644f7f42", "sha256": "b3732b31d4e52aabb97a3141d733fd51d8eff11e74ab45e992ce78426b975b42"}, "downloads": -1, "filename": "doug-0.0.3-cp38-cp38-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "446e993c4b0b6c4a9a6de4d8644f7f42", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": ">=3.5", "size": 5167223, "upload_time": "2020-03-09T08:36:45", "upload_time_iso_8601": "2020-03-09T08:36:45.775756Z", "url": "https://files.pythonhosted.org/packages/ab/65/4f62f54d744e95293229bd23a1d8099888253bc38c2565d346e103152425/doug-0.0.3-cp38-cp38-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a510490657de28303263d036608abf62", "sha256": "4b0160b2a70e9e4850c2b64a8b52c73ebd8171031737a7622e45478e77838bf0"}, "downloads": -1, "filename": "doug-0.0.3-cp38-cp38-win_amd64.whl", "has_sig": false, "md5_digest": "a510490657de28303263d036608abf62", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": ">=3.5", "size": 810964, "upload_time": "2020-03-09T06:32:04", "upload_time_iso_8601": "2020-03-09T06:32:04.029496Z", "url": "https://files.pythonhosted.org/packages/02/77/f0fbb3bd3c71712937cf9baac1acc4c5cb2696e3c77ca035d7a0f5fb31b6/doug-0.0.3-cp38-cp38-win_amd64.whl", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "2a2b31ed9e61060765e0a5960651cfb4", "sha256": "91717b9908716919d4882d6a5cbbfd74472c276c36525b48cb62a57ec20b4360"}, "downloads": -1, "filename": "doug-0.1.0-cp35-cp35m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "2a2b31ed9e61060765e0a5960651cfb4", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": ">=3.5", "size": 3698759, "upload_time": "2020-03-10T02:00:15", "upload_time_iso_8601": "2020-03-10T02:00:15.767273Z", "url": "https://files.pythonhosted.org/packages/7c/f9/874b910a8420a2ecafdc085a1cb6e182074dee4475bc772abf9e04c313c0/doug-0.1.0-cp35-cp35m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ef006327d6f2f3642b376710542e526e", "sha256": "2f8daa937190a297d90d1f49d92802056a77e9c2f404dd659ea260833e942979"}, "downloads": -1, "filename": "doug-0.1.0-cp35-cp35m-win_amd64.whl", "has_sig": false, "md5_digest": "ef006327d6f2f3642b376710542e526e", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": ">=3.5", "size": 731558, "upload_time": "2020-03-09T09:12:32", "upload_time_iso_8601": "2020-03-09T09:12:32.757068Z", "url": "https://files.pythonhosted.org/packages/61/62/c4ec8cd01fc63b6f783fc99e4ec5564d0512b15ac251ecb5653174e2cd27/doug-0.1.0-cp35-cp35m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e2d63191af94f320dbc78c37a1aa5c09", "sha256": "0b0fef4095fd44281a4710632810a350e27448f9b5a957ad564f2cd31697f71b"}, "downloads": -1, "filename": "doug-0.1.0-cp36-cp36m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "e2d63191af94f320dbc78c37a1aa5c09", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.5", "size": 3926350, "upload_time": "2020-03-10T02:00:18", "upload_time_iso_8601": "2020-03-10T02:00:18.486337Z", "url": "https://files.pythonhosted.org/packages/e8/3e/e518a13c37c1ddc64e7492a9ee98e6ecda402c86a2cd1e3771e1a9e723f4/doug-0.1.0-cp36-cp36m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fa1819e6ba29bee4b5a90039d3938b50", "sha256": "4582b1f25f64b45c695b07864cfe973e9af61185cfd37f4e0dd72ecac0948519"}, "downloads": -1, "filename": "doug-0.1.0-cp36-cp36m-win_amd64.whl", "has_sig": false, "md5_digest": "fa1819e6ba29bee4b5a90039d3938b50", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.5", "size": 782023, "upload_time": "2020-03-09T09:10:19", "upload_time_iso_8601": "2020-03-09T09:10:19.514617Z", "url": "https://files.pythonhosted.org/packages/51/ed/a3ad7df105359ba9e782f3ec482ac616f5218ba1f12a89d9e5498bc9d88a/doug-0.1.0-cp36-cp36m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a537f7b944cf3a23889ebaee0c2e9291", "sha256": "0a808aeab80664398ba416336163572282bf7002dba6eb5d13e16633c0de5b5e"}, "downloads": -1, "filename": "doug-0.1.0-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "a537f7b944cf3a23889ebaee0c2e9291", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": ">=3.5", "size": 3939364, "upload_time": "2020-03-10T02:00:20", "upload_time_iso_8601": "2020-03-10T02:00:20.529008Z", "url": "https://files.pythonhosted.org/packages/99/38/d40e1caaab896ae311b804684a0c4192ad19e0f67f13c0b20274c1c76977/doug-0.1.0-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5d3ed67203242a31b32a3577a83ab381", "sha256": "562680bbdcbf81c13e2216ffc2d008551c1df4643bdfc8fcd8c3965e41d62810"}, "downloads": -1, "filename": "doug-0.1.0-cp37-cp37m-win_amd64.whl", "has_sig": false, "md5_digest": "5d3ed67203242a31b32a3577a83ab381", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": ">=3.5", "size": 784528, "upload_time": "2020-03-09T09:10:20", "upload_time_iso_8601": "2020-03-09T09:10:20.937684Z", "url": "https://files.pythonhosted.org/packages/a1/22/3b0257a1f42e859af66046ab18911131986917d50ee84116dac7a5354a10/doug-0.1.0-cp37-cp37m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d59de94e9f709ee0ddf167a32b9d8a86", "sha256": "fd5ec941c0686b5411f3543c8a6f7fdb5f95bc574316a6a1c665593627c37804"}, "downloads": -1, "filename": "doug-0.1.0-cp38-cp38-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "d59de94e9f709ee0ddf167a32b9d8a86", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": ">=3.5", "size": 5167223, "upload_time": "2020-03-10T02:00:22", "upload_time_iso_8601": "2020-03-10T02:00:22.755865Z", "url": "https://files.pythonhosted.org/packages/46/63/f0d61f0a4c49777ff2fb064da118d9d93f0b0fc1a63847a597c07dc79756/doug-0.1.0-cp38-cp38-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4a4295401a5d3bd3da9389b4b907b3a6", "sha256": "23315b0bf458319861844f6cb7c2974987a82dec8f0fbeaa007a0e61ddb533cf"}, "downloads": -1, "filename": "doug-0.1.0-cp38-cp38-win_amd64.whl", "has_sig": false, "md5_digest": "4a4295401a5d3bd3da9389b4b907b3a6", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": ">=3.5", "size": 810963, "upload_time": "2020-03-09T09:10:22", "upload_time_iso_8601": "2020-03-09T09:10:22.542060Z", "url": "https://files.pythonhosted.org/packages/7b/7a/49fe0e5420392aa0d11f11b7a36ae0f5cbdace3bae4016b475c3ea1d19a1/doug-0.1.0-cp38-cp38-win_amd64.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2a2b31ed9e61060765e0a5960651cfb4", "sha256": "91717b9908716919d4882d6a5cbbfd74472c276c36525b48cb62a57ec20b4360"}, "downloads": -1, "filename": "doug-0.1.0-cp35-cp35m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "2a2b31ed9e61060765e0a5960651cfb4", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": ">=3.5", "size": 3698759, "upload_time": "2020-03-10T02:00:15", "upload_time_iso_8601": "2020-03-10T02:00:15.767273Z", "url": "https://files.pythonhosted.org/packages/7c/f9/874b910a8420a2ecafdc085a1cb6e182074dee4475bc772abf9e04c313c0/doug-0.1.0-cp35-cp35m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ef006327d6f2f3642b376710542e526e", "sha256": "2f8daa937190a297d90d1f49d92802056a77e9c2f404dd659ea260833e942979"}, "downloads": -1, "filename": "doug-0.1.0-cp35-cp35m-win_amd64.whl", "has_sig": false, "md5_digest": "ef006327d6f2f3642b376710542e526e", "packagetype": "bdist_wheel", "python_version": "cp35", "requires_python": ">=3.5", "size": 731558, "upload_time": "2020-03-09T09:12:32", "upload_time_iso_8601": "2020-03-09T09:12:32.757068Z", "url": "https://files.pythonhosted.org/packages/61/62/c4ec8cd01fc63b6f783fc99e4ec5564d0512b15ac251ecb5653174e2cd27/doug-0.1.0-cp35-cp35m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e2d63191af94f320dbc78c37a1aa5c09", "sha256": "0b0fef4095fd44281a4710632810a350e27448f9b5a957ad564f2cd31697f71b"}, "downloads": -1, "filename": "doug-0.1.0-cp36-cp36m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "e2d63191af94f320dbc78c37a1aa5c09", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.5", "size": 3926350, "upload_time": "2020-03-10T02:00:18", "upload_time_iso_8601": "2020-03-10T02:00:18.486337Z", "url": "https://files.pythonhosted.org/packages/e8/3e/e518a13c37c1ddc64e7492a9ee98e6ecda402c86a2cd1e3771e1a9e723f4/doug-0.1.0-cp36-cp36m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fa1819e6ba29bee4b5a90039d3938b50", "sha256": "4582b1f25f64b45c695b07864cfe973e9af61185cfd37f4e0dd72ecac0948519"}, "downloads": -1, "filename": "doug-0.1.0-cp36-cp36m-win_amd64.whl", "has_sig": false, "md5_digest": "fa1819e6ba29bee4b5a90039d3938b50", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.5", "size": 782023, "upload_time": "2020-03-09T09:10:19", "upload_time_iso_8601": "2020-03-09T09:10:19.514617Z", "url": "https://files.pythonhosted.org/packages/51/ed/a3ad7df105359ba9e782f3ec482ac616f5218ba1f12a89d9e5498bc9d88a/doug-0.1.0-cp36-cp36m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a537f7b944cf3a23889ebaee0c2e9291", "sha256": "0a808aeab80664398ba416336163572282bf7002dba6eb5d13e16633c0de5b5e"}, "downloads": -1, "filename": "doug-0.1.0-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "a537f7b944cf3a23889ebaee0c2e9291", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": ">=3.5", "size": 3939364, "upload_time": "2020-03-10T02:00:20", "upload_time_iso_8601": "2020-03-10T02:00:20.529008Z", "url": "https://files.pythonhosted.org/packages/99/38/d40e1caaab896ae311b804684a0c4192ad19e0f67f13c0b20274c1c76977/doug-0.1.0-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5d3ed67203242a31b32a3577a83ab381", "sha256": "562680bbdcbf81c13e2216ffc2d008551c1df4643bdfc8fcd8c3965e41d62810"}, "downloads": -1, "filename": "doug-0.1.0-cp37-cp37m-win_amd64.whl", "has_sig": false, "md5_digest": "5d3ed67203242a31b32a3577a83ab381", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": ">=3.5", "size": 784528, "upload_time": "2020-03-09T09:10:20", "upload_time_iso_8601": "2020-03-09T09:10:20.937684Z", "url": "https://files.pythonhosted.org/packages/a1/22/3b0257a1f42e859af66046ab18911131986917d50ee84116dac7a5354a10/doug-0.1.0-cp37-cp37m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d59de94e9f709ee0ddf167a32b9d8a86", "sha256": "fd5ec941c0686b5411f3543c8a6f7fdb5f95bc574316a6a1c665593627c37804"}, "downloads": -1, "filename": "doug-0.1.0-cp38-cp38-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "d59de94e9f709ee0ddf167a32b9d8a86", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": ">=3.5", "size": 5167223, "upload_time": "2020-03-10T02:00:22", "upload_time_iso_8601": "2020-03-10T02:00:22.755865Z", "url": "https://files.pythonhosted.org/packages/46/63/f0d61f0a4c49777ff2fb064da118d9d93f0b0fc1a63847a597c07dc79756/doug-0.1.0-cp38-cp38-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4a4295401a5d3bd3da9389b4b907b3a6", "sha256": "23315b0bf458319861844f6cb7c2974987a82dec8f0fbeaa007a0e61ddb533cf"}, "downloads": -1, "filename": "doug-0.1.0-cp38-cp38-win_amd64.whl", "has_sig": false, "md5_digest": "4a4295401a5d3bd3da9389b4b907b3a6", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": ">=3.5", "size": 810963, "upload_time": "2020-03-09T09:10:22", "upload_time_iso_8601": "2020-03-09T09:10:22.542060Z", "url": "https://files.pythonhosted.org/packages/7b/7a/49fe0e5420392aa0d11f11b7a36ae0f5cbdace3bae4016b475c3ea1d19a1/doug-0.1.0-cp38-cp38-win_amd64.whl", "yanked": false}], "timestamp": "Fri May  8 00:50:08 2020"}