{"info": {"author": "Radek Kysely", "author_email": "kyselyradek@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "AtomicLoop\n^^^^^^^^^^\n\n`show example <#getting-started>`_ | `jump to docs <#documentation>`_\n\nCreate atomic loop iterations (let the current iteration finish even when interrupted).\n\nA simple context manager that asynchronously listens to potential\n``SIGINT`` and ``SIGTERM`` and provides you with **plain boolean flag** that can be\nused to control the iteration flow of a ``while`` loop based on whether or not\nan interrupt/terminate signal was received.\n\nThis was formerly built for reinforcement learning library that trains its agents\nin iterations and has to gracefully finish the current running episode every time\nthe training is interrupted.\n\nIt will be most useful in similar use cases, but can be actually used for anything\nelse. Technically, any block of code that needs to run without an interruption.\n\nNote that you will still be able to kill the running process using ``SIGKILL``.\n\nGetting Started\n###############\n\n.. code-block:: shell\n\n\tpip3 install atomicloop\n\n\nThe following example loop runs 3 iterations, each lasting three seconds.\nYou can try interrupting one of the steps by pressing ``Ctrl+C`` (which sends\n``SIGINT`` to the process). You will see the signal feedback but the program\nwill wait for the current iteration to finish and exits **after** the loop\niteration is done.\n\nMoreover, you can see the context manager is aware whether or not it finished\ndue to an interruption.\n\n.. code-block:: python\n\n\timport time\n\tfrom atomicloop import AtomicLoop\n\n\n\t# Optional callback handlers ----------------------------------------\n\tdef on_signal(signal, frame):\n\tprint(f'  Received signal: {signal}')\n\tprint('  Finishing current step before terminating')\n\n\n\tdef on_exit(was_interrupted):\n\tprint('  Ended training')\n\tprint(f'  Interrupted? {was_interrupted}')\n\n\n\t# Running the loop --------------------------------------------------\n\tgoal_steps = 3\n\n\twith AtomicLoop(on_signal, on_exit) as loop:\n\t\tstep_no = 0\n\t\twhile loop.run and step_no < goal_steps:\n\t\t\tprint(f'Starting training step #{step_no}')\n\t\t\ttime.sleep(3) # simulating some code execution\n\t\t\tprint(f'Finished training step #{step_no}')\n\t\t\tprint('----------------------------------\\n')\n\t\t\tstep_no += 1\n\n\nDocumentation\n#############\n\n``atomicloop.AtomicLoop(on_signal=None, on_end=None)``\n======================================================\n\nThe main and only class that creates the desired context manager.\n\n*on_signal* is a callable that gets invoked on incoming\n``SIGINT`` or ``SIGTERM``. It is called with 2 arguments:\nthe signal number and the current stack frame. For details\non the arguments, please consult *handler* part in\n`official signal.signal documentation\n<https://docs.python.org/3/library/signal.html#signal.signal>`_.\n\n\n*on_end* is a callable that gets invoked *after* exiting\nthe context (after ``with`` block). It is called with\na single boolean argument stating whether or not the\nexecution was interrupted.\n\n``AtomicLoop()`` returns a new instance. To access the boolean\nflag for flow control, you have to read the flag as the instance's\nattribute.\n\nThe ``.run`` boolean flag states whether or not the program should\ncontinue its execution. It is ``True`` by default and switches to\n``False`` when an interruption signal was received.\n\nYou can also use one of many synonymous attributes:\n\n* ``loop.run``\n\n* ``loop.loop``\n\n* ``loop.move``\n\n* ``loop.cont``\n\n* ``loop.keep``\n\n* ``loop.keep_going``\n\n* ``loop.uninterrupted``\n\n", "description_content_type": "", "docs_url": null, "download_url": "https://pypi.org/project/atomicloop/", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kysely/atomicloop", "keywords": "atomic,linearizable,undivisible,uninterruptible,atomic loop,atomic block,atomic operation,delayed interrupt,delayed keyboardinterrupt,keyboardinterrupt,SIGINT,SIGTERM", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "atomicloop", "package_url": "https://pypi.org/project/atomicloop/", "platform": "", "project_url": "https://pypi.org/project/atomicloop/", "project_urls": {"Download": "https://pypi.org/project/atomicloop/", "Homepage": "https://github.com/kysely/atomicloop"}, "release_url": "https://pypi.org/project/atomicloop/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "Create atomic loop iterations (let the iteration finish even when interrupted)", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"#getting-started\" rel=\"nofollow\">show example</a> | <a href=\"#documentation\" rel=\"nofollow\">jump to docs</a></p>\n<p>Create atomic loop iterations (let the current iteration finish even when interrupted).</p>\n<p>A simple context manager that asynchronously listens to potential\n<tt>SIGINT</tt> and <tt>SIGTERM</tt> and provides you with <strong>plain boolean flag</strong> that can be\nused to control the iteration flow of a <tt>while</tt> loop based on whether or not\nan interrupt/terminate signal was received.</p>\n<p>This was formerly built for reinforcement learning library that trains its agents\nin iterations and has to gracefully finish the current running episode every time\nthe training is interrupted.</p>\n<p>It will be most useful in similar use cases, but can be actually used for anything\nelse. Technically, any block of code that needs to run without an interruption.</p>\n<p>Note that you will still be able to kill the running process using <tt>SIGKILL</tt>.</p>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<pre>pip3 install atomicloop\n</pre>\n<p>The following example loop runs 3 iterations, each lasting three seconds.\nYou can try interrupting one of the steps by pressing <tt>Ctrl+C</tt> (which sends\n<tt>SIGINT</tt> to the process). You will see the signal feedback but the program\nwill wait for the current iteration to finish and exits <strong>after</strong> the loop\niteration is done.</p>\n<p>Moreover, you can see the context manager is aware whether or not it finished\ndue to an interruption.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">time</span>\n<span class=\"kn\">from</span> <span class=\"nn\">atomicloop</span> <span class=\"kn\">import</span> <span class=\"n\">AtomicLoop</span>\n\n\n<span class=\"c1\"># Optional callback handlers ----------------------------------------</span>\n<span class=\"k\">def</span> <span class=\"nf\">on_signal</span><span class=\"p\">(</span><span class=\"n\">signal</span><span class=\"p\">,</span> <span class=\"n\">frame</span><span class=\"p\">):</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'  Received signal: </span><span class=\"si\">{</span><span class=\"n\">signal</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'  Finishing current step before terminating'</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">on_exit</span><span class=\"p\">(</span><span class=\"n\">was_interrupted</span><span class=\"p\">):</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'  Ended training'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'  Interrupted? </span><span class=\"si\">{</span><span class=\"n\">was_interrupted</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Running the loop --------------------------------------------------</span>\n<span class=\"n\">goal_steps</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"k\">with</span> <span class=\"n\">AtomicLoop</span><span class=\"p\">(</span><span class=\"n\">on_signal</span><span class=\"p\">,</span> <span class=\"n\">on_exit</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">loop</span><span class=\"p\">:</span>\n        <span class=\"n\">step_no</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">while</span> <span class=\"n\">loop</span><span class=\"o\">.</span><span class=\"n\">run</span> <span class=\"ow\">and</span> <span class=\"n\">step_no</span> <span class=\"o\">&lt;</span> <span class=\"n\">goal_steps</span><span class=\"p\">:</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'Starting training step #</span><span class=\"si\">{</span><span class=\"n\">step_no</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n                <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"c1\"># simulating some code execution</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'Finished training step #</span><span class=\"si\">{</span><span class=\"n\">step_no</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'----------------------------------</span><span class=\"se\">\\n</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n                <span class=\"n\">step_no</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n</pre>\n</div>\n<div id=\"documentation\">\n<h2>Documentation</h2>\n<h2 id=\"atomicloop-atomicloop-on-signal-none-on-end-none\"><span class=\"section-subtitle\"><tt>atomicloop.AtomicLoop(on_signal=None, on_end=None)</tt></span></h2>\n<p>The main and only class that creates the desired context manager.</p>\n<p><em>on_signal</em> is a callable that gets invoked on incoming\n<tt>SIGINT</tt> or <tt>SIGTERM</tt>. It is called with 2 arguments:\nthe signal number and the current stack frame. For details\non the arguments, please consult <em>handler</em> part in\n<a href=\"https://docs.python.org/3/library/signal.html#signal.signal\" rel=\"nofollow\">official signal.signal documentation</a>.</p>\n<p><em>on_end</em> is a callable that gets invoked <em>after</em> exiting\nthe context (after <tt>with</tt> block). It is called with\na single boolean argument stating whether or not the\nexecution was interrupted.</p>\n<p><tt>AtomicLoop()</tt> returns a new instance. To access the boolean\nflag for flow control, you have to read the flag as the instance\u2019s\nattribute.</p>\n<p>The <tt>.run</tt> boolean flag states whether or not the program should\ncontinue its execution. It is <tt>True</tt> by default and switches to\n<tt>False</tt> when an interruption signal was received.</p>\n<p>You can also use one of many synonymous attributes:</p>\n<ul>\n<li><tt>loop.run</tt></li>\n<li><tt>loop.loop</tt></li>\n<li><tt>loop.move</tt></li>\n<li><tt>loop.cont</tt></li>\n<li><tt>loop.keep</tt></li>\n<li><tt>loop.keep_going</tt></li>\n<li><tt>loop.uninterrupted</tt></li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 4039032, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "0149a05df00d006f07c8e90317e50dc5", "sha256": "383f2456a501643e73d771b8cf314f0c49e95057f07ab3d6ea7e74d7a3891bc8"}, "downloads": -1, "filename": "atomicloop-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0149a05df00d006f07c8e90317e50dc5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 4065, "upload_time": "2018-07-07T14:05:00", "upload_time_iso_8601": "2018-07-07T14:05:00.925780Z", "url": "https://files.pythonhosted.org/packages/2d/6e/1a7982ebfaabe0ccc74a042b4cdd35f904484b8c3bb7d61bf97bf9e88067/atomicloop-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d8eb83935ac9111de280d447c77a7694", "sha256": "0ffd5f45a3576440f083e67f02b15cf9152c16bbdbc53d34f094b800b699ca69"}, "downloads": -1, "filename": "atomicloop-0.1.0.tar.gz", "has_sig": false, "md5_digest": "d8eb83935ac9111de280d447c77a7694", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4160, "upload_time": "2018-07-07T14:05:02", "upload_time_iso_8601": "2018-07-07T14:05:02.142536Z", "url": "https://files.pythonhosted.org/packages/23/b2/6f70841db3a89ceaaa6a6c90229b8b12468bef81a32b97261d17da0926f6/atomicloop-0.1.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "66abb895b395b850f36a132cc98f570d", "sha256": "370bd80775bc072d06f4505b80c0096417654136fd46c3722b263bcca9777ac5"}, "downloads": -1, "filename": "atomicloop-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "66abb895b395b850f36a132cc98f570d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 4064, "upload_time": "2018-07-07T14:07:06", "upload_time_iso_8601": "2018-07-07T14:07:06.458517Z", "url": "https://files.pythonhosted.org/packages/24/ca/d9fc4bd21de35633963dcdeb6efbb30ab5de740a4fa0c4157f2a9f3350b3/atomicloop-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "954c6ec0c627a922209d9b4ebf7b6ed7", "sha256": "5bc0934ac2b36f25b53f8fab692d94ce387c4fc548cd08de9e3cef5f64acb2c7"}, "downloads": -1, "filename": "atomicloop-1.0.0.tar.gz", "has_sig": false, "md5_digest": "954c6ec0c627a922209d9b4ebf7b6ed7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4157, "upload_time": "2018-07-07T14:07:07", "upload_time_iso_8601": "2018-07-07T14:07:07.735460Z", "url": "https://files.pythonhosted.org/packages/0d/ef/3877b173ab2b5349bd95d05d5451a7aeefd6de3b64b7cc9c2bc08b88f4e6/atomicloop-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "66abb895b395b850f36a132cc98f570d", "sha256": "370bd80775bc072d06f4505b80c0096417654136fd46c3722b263bcca9777ac5"}, "downloads": -1, "filename": "atomicloop-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "66abb895b395b850f36a132cc98f570d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 4064, "upload_time": "2018-07-07T14:07:06", "upload_time_iso_8601": "2018-07-07T14:07:06.458517Z", "url": "https://files.pythonhosted.org/packages/24/ca/d9fc4bd21de35633963dcdeb6efbb30ab5de740a4fa0c4157f2a9f3350b3/atomicloop-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "954c6ec0c627a922209d9b4ebf7b6ed7", "sha256": "5bc0934ac2b36f25b53f8fab692d94ce387c4fc548cd08de9e3cef5f64acb2c7"}, "downloads": -1, "filename": "atomicloop-1.0.0.tar.gz", "has_sig": false, "md5_digest": "954c6ec0c627a922209d9b4ebf7b6ed7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4157, "upload_time": "2018-07-07T14:07:07", "upload_time_iso_8601": "2018-07-07T14:07:07.735460Z", "url": "https://files.pythonhosted.org/packages/0d/ef/3877b173ab2b5349bd95d05d5451a7aeefd6de3b64b7cc9c2bc08b88f4e6/atomicloop-1.0.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:33 2020"}