{"info": {"author": "Eugeniu Costetchi", "author_email": "costezki.eugen@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "# rdf2gremlin\n[![Build Status](https://travis-ci.org/costezki/rdf2gremlin.svg?branch=master)](https://travis-ci.org/costezki/rdf2gremlin)\n[![Coverage Status](https://coveralls.io/repos/github/costezki/rdf2gremlin/badge.svg?branch=master)](https://coveralls.io/github/costezki/rdf2gremlin?branch=master)\n[![PyPI](https://img.shields.io/pypi/v/rdf2gremlin.svg)](https://pypi.python.org/pypi/rdf2gremlin)\n[![PyPI](https://img.shields.io/pypi/pyversions/rdf2gremlin.svg)](https://pypi.python.org/pypi/rdf2gremlin)\n\nIt has never been easier to transform your RDF data into a property graph based on TinkerPop-Gremlin.\n\n\n\n# Introduction\n[Apache TinkerPop](<http://tinkerpop.apache.org>) is a graph computing framework for both graph databases (OLTP) and graph analytic systems (OLAP). [Gremlin](<http://tinkerpop.apache.org/gremlin.html>) is the graph traversal language of TinkerPop.\n\nThe [Resource Description Framework (RDF)]() is a standard model for data interchange on the Web originally designed as a metadata data model. It has come to be used as a general method for conceptual description or modeling of information that is implemented in web resources, using a variety of syntax notations and data serialization formats. This linking structure forms a *directed labeled graph*, where the *edges* represent the named link between two resources, represented by the *graph nodes*. This graph view is the easiest possible mental model for RDF and is often used in easy-to-understand visual explanations. Resources are denoted by IRIs. The general convention is to use *http* URIs. \n\nRDF graphs are queries using SPARQL language. [SPARQL 1.1](https://www.w3.org/TR/sparql11-query/) is a set of specifications that provide languages and protocols to query and manipulate RDF graph content on the Web or in an RDF store.    \n\nThis library, [rdf2gremlin](https://github.com/costezki/rdf2gremlin), provides an easy way to load the RDF data-sets into a property graph in order to benefit from the features of traversal language, which are not available in SPARQL pattern matching language. \n\n# Installation\n\n```shell script\n# switch to your local virtual environment \n. ./venv/activate\n\npip install rdf2gremlin\n# ... enjoy ...\n```\n\nNote: The library `tornado` shall satisfy `tornado>=4.4.1,<5.0` version restriction inherited from the python_gremlin library. \n\n\n# Prerequisites\n\nGremlin-Python is designed to connect to a \"server\" that is hosting a TinkerPop-enabled graph system. That \"server\"\ncould be [Gremlin Server](http://tinkerpop.apache.org/docs/current/reference/#gremlin-server) or a [remote Gremlin provider](http://tinkerpop.apache.org/docs/current/reference/#connecting-rgp) that exposes protocols by which Gremlin-Python can connect. This requirement is inherited by the current library as well. \n\nIn order to use this library it is necessary to have a Gremlin service available locally or on a remote location. The easiest way is to run a TinkerProp server locally. This can be done by either: \n(a) downloading and running TinkerPop \n ```shell script\nwget https://www-eu.apache.org/dist/tinkerpop/3.4.3/apache-tinkerpop-gremlin-server-3.4.3-bin.zip\nunzip apache-tinkerpop-gremlin-server-3.4.3-bin.zip\ncd apache-tinkerpop-gremlin-server-3.4.3/\n./bin/gremlin-server.sh start\n \n# ... to stop the server ...\n\n./bin/gremlin-server.sh stop\n```\nor (b) running it as a Docker container.\n```shell script\ndocker pull tinkerpop/gremlin-server\ndocker run --name gremlin-server -p 8182:8182 tinkerpop/gremlin-server\n\n# ... to stop the server ...\n\ndocker stop gremlin-server\n```\n\n# Getting started\n\n### Connect to a property graph service.\nA typical connection to a server running on \"localhost\" that supports the Gremlin Server protocol using websockets from the Python shell looks like this:\n\n```python\nfrom rdf2g import setup_graph\n\nDEFAULT_LOCAL_CONNECTION_STRING = \"ws://localhost:8182/gremlin\"\ng = setup_graph(DEFAULT_LOCAL_CONNECTION_STRING)\n```\nOnce `g` has been created using a connection, it is then possible to start writing Gremlin traversals to query the remote graph. \n\n### Load a graph\n\nRead an RDF graph.\n\n```python\nimport rdflib\nimport pathlib\n\nOUTPUT_FILE_LAM_PROPERTIES = pathlib.Path(\"../resource/celex_project_properties_v2.ttl\").resolve()\n\nrdf_graph = rdflib.Graph()\nrdf_graph.parse(str(OUTPUT_FILE_LAM_PROPERTIES), format=\"ttl\")\n``` \n\nLoad the RDF graph into a property graph.\n\n```python\nfrom rdf2g import load_rdf2g\nload_rdf2g(g, rdf_graph)\n```\n\nThe created property graph follows the following set of **conventions**.\n\n* URIs and Blank nodes are transformed into property graph nodes.\n* Predicates connecting an URI to another URI or a blank node are transformed into property graph edges. Edge labels correspond to qualified IRIs generated using the prefix definitions available in the RDF data-set.\n* Node labels correspond to qualified IRIs generated using the prefix definitions available in the RDF data-set.  \n* RDF Litarals are transformed into values of the node properties, while the preceding predicates into keys of the node properties. In other words\n* Predicates connecting an URI to a RDF Literal are transformed into {key:value} pairs and added as node properties.  \n* Nodes have a special property 'iri' that is equivalent to the absolute URI of the RDF resource.\n \n### Get a node\n\nGet a node referring to it either by label, iri or id\n```python\nskos_concept_iri = rdflib.URIRef(\"http://www.w3.org/2004/02/skos/core#Concept\")\nv1 = rdf2g.get_node(g, skos_concept_iri)\n\nskos_concept_label = \"skos:Concept\"\nv2 = rdf2g.get_node(g, skos_concept_label)\n\nhypothetical_node_id = 880\nv3 = rdf2g.get_node(g, hypothetical_node_id)\n\nprint (v1 == v2 == v3) # should be true\n```\n\nGet nodes by their supposed rdf:type. This concept is inherited, of course, from RDF world.\n```python\nskos_concept_label = \"skos:Concept\"\n\nlist_of_concept = rdf2g.get_nodes_of_type(g, skos_concept_label)\n\n# print the list of concepts in the graph\nprint (list_of_concept)\n```\n \n### Generate a traversal tree \n\nIt is possible to traverse the property graph and then generate the traversal tree from it. This is especially useful when the graph serves as structured document content say JSON or XML serialisation.      \n\nTo do that first, get two levels deep traversal tree and the edges between them for all the nodes in the graph that have `iri == known_iri`. Further please see the [Gremlin reference documentation](http://tinkerpop.apache.org/docs/current/reference/#gremlin-python) at Apache TinkerPop for more information on usage.\n\n```python\nknown_iri = 'http://publications.europa.eu/resources/authority/celex/md_CODE' \ns = g.V().has('iri', known_iri).outE().inV().tree().next()\n```\n\nAltenatively use the function `rdf2g.generate_traversal_tree`\n\n```python\nnode = rdf2g.get_node(self.g, known_iri)\ns = rdf2g.generate_traversal_tree(self.g, node)\n```\n\nThen expand and simplify that tree. First, simplify the dict structure to simple Python types, removing the Gremlin objects. Second, expand by providing the properties for each visited node, while the edges are considered as special properties leading to a another node dictionary.\n\n```python\nfrom pprint import pprint\nresult = rdf2g.expand_tree(g, s)\npprint (result)\n```\n\nThe traversal tree nodes contain, in addition to original RDF content, two special properties `@id` and `@label` which correspond to the standard Gremlin `id` and `label` properties. The `@` sign is used to distinguish the original RDF from the Gremlin features. Property graph edges, are reduced to keys in the final dict and for this reason they have no additional descriptions just like in the original RDF graph.\n\n\n# Contributing\nYou are more than welcome to help expand and mature this project. \n\nWhen contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change.\n\nPlease note we have a code of conduct, please follow it in all your interactions with the project.\n\n# License\n\nThis project is Licensed under the GPL v3 License - see [LICENSE](LICENSE) file", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/costezki/rdf2gremlin", "keywords": "RDF,Gremlin,load,tinkerpop,tinkerpop3,rdf-gremlin,serialisation,", "license": "", "maintainer": "Eugeniu Costetchi", "maintainer_email": "costezki.eugen@gmail.com", "name": "rdf2gremlin", "package_url": "https://pypi.org/project/rdf2gremlin/", "platform": "any", "project_url": "https://pypi.org/project/rdf2gremlin/", "project_urls": {"Homepage": "https://github.com/costezki/rdf2gremlin"}, "release_url": "https://pypi.org/project/rdf2gremlin/0.1.36/", "requires_dist": null, "requires_python": ">=3.5", "summary": "It has never been easier to transform your RDF data into a property graph based on TinkerPop-Gremlin.", "version": "0.1.36", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>rdf2gremlin</h1>\n<p><a href=\"https://travis-ci.org/costezki/rdf2gremlin\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c67657903bc25ea1b3226a85bf4734d55bdd6595/68747470733a2f2f7472617669732d63692e6f72672f636f7374657a6b692f726466326772656d6c696e2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/costezki/rdf2gremlin?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6f83822c8e34dc23d2eb151e2e4c1602e06ed2c8/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f636f7374657a6b692f726466326772656d6c696e2f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.python.org/pypi/rdf2gremlin\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c7d7c8c21e738e1edc790acdab3043d7846ca19e/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f726466326772656d6c696e2e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/rdf2gremlin\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e319e8999f378eb6d56cd0122396c03222e3815a/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f726466326772656d6c696e2e737667\"></a></p>\n<p>It has never been easier to transform your RDF data into a property graph based on TinkerPop-Gremlin.</p>\n<h1>Introduction</h1>\n<p><a href=\"http://tinkerpop.apache.org\" rel=\"nofollow\">Apache TinkerPop</a> is a graph computing framework for both graph databases (OLTP) and graph analytic systems (OLAP). <a href=\"http://tinkerpop.apache.org/gremlin.html\" rel=\"nofollow\">Gremlin</a> is the graph traversal language of TinkerPop.</p>\n<p>The <a href=\"\" rel=\"nofollow\">Resource Description Framework (RDF)</a> is a standard model for data interchange on the Web originally designed as a metadata data model. It has come to be used as a general method for conceptual description or modeling of information that is implemented in web resources, using a variety of syntax notations and data serialization formats. This linking structure forms a <em>directed labeled graph</em>, where the <em>edges</em> represent the named link between two resources, represented by the <em>graph nodes</em>. This graph view is the easiest possible mental model for RDF and is often used in easy-to-understand visual explanations. Resources are denoted by IRIs. The general convention is to use <em>http</em> URIs.</p>\n<p>RDF graphs are queries using SPARQL language. <a href=\"https://www.w3.org/TR/sparql11-query/\" rel=\"nofollow\">SPARQL 1.1</a> is a set of specifications that provide languages and protocols to query and manipulate RDF graph content on the Web or in an RDF store.</p>\n<p>This library, <a href=\"https://github.com/costezki/rdf2gremlin\" rel=\"nofollow\">rdf2gremlin</a>, provides an easy way to load the RDF data-sets into a property graph in order to benefit from the features of traversal language, which are not available in SPARQL pattern matching language.</p>\n<h1>Installation</h1>\n<pre><span class=\"c1\"># switch to your local virtual environment </span>\n. ./venv/activate\n\npip install rdf2gremlin\n<span class=\"c1\"># ... enjoy ...</span>\n</pre>\n<p>Note: The library <code>tornado</code> shall satisfy <code>tornado&gt;=4.4.1,&lt;5.0</code> version restriction inherited from the python_gremlin library.</p>\n<h1>Prerequisites</h1>\n<p>Gremlin-Python is designed to connect to a \"server\" that is hosting a TinkerPop-enabled graph system. That \"server\"\ncould be <a href=\"http://tinkerpop.apache.org/docs/current/reference/#gremlin-server\" rel=\"nofollow\">Gremlin Server</a> or a <a href=\"http://tinkerpop.apache.org/docs/current/reference/#connecting-rgp\" rel=\"nofollow\">remote Gremlin provider</a> that exposes protocols by which Gremlin-Python can connect. This requirement is inherited by the current library as well.</p>\n<p>In order to use this library it is necessary to have a Gremlin service available locally or on a remote location. The easiest way is to run a TinkerProp server locally. This can be done by either:\n(a) downloading and running TinkerPop</p>\n<pre>wget https://www-eu.apache.org/dist/tinkerpop/3.4.3/apache-tinkerpop-gremlin-server-3.4.3-bin.zip\nunzip apache-tinkerpop-gremlin-server-3.4.3-bin.zip\n<span class=\"nb\">cd</span> apache-tinkerpop-gremlin-server-3.4.3/\n./bin/gremlin-server.sh start\n\n<span class=\"c1\"># ... to stop the server ...</span>\n\n./bin/gremlin-server.sh stop\n</pre>\n<p>or (b) running it as a Docker container.</p>\n<pre>docker pull tinkerpop/gremlin-server\ndocker run --name gremlin-server -p <span class=\"m\">8182</span>:8182 tinkerpop/gremlin-server\n\n<span class=\"c1\"># ... to stop the server ...</span>\n\ndocker stop gremlin-server\n</pre>\n<h1>Getting started</h1>\n<h3>Connect to a property graph service.</h3>\n<p>A typical connection to a server running on \"localhost\" that supports the Gremlin Server protocol using websockets from the Python shell looks like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">rdf2g</span> <span class=\"kn\">import</span> <span class=\"n\">setup_graph</span>\n\n<span class=\"n\">DEFAULT_LOCAL_CONNECTION_STRING</span> <span class=\"o\">=</span> <span class=\"s2\">\"ws://localhost:8182/gremlin\"</span>\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">setup_graph</span><span class=\"p\">(</span><span class=\"n\">DEFAULT_LOCAL_CONNECTION_STRING</span><span class=\"p\">)</span>\n</pre>\n<p>Once <code>g</code> has been created using a connection, it is then possible to start writing Gremlin traversals to query the remote graph.</p>\n<h3>Load a graph</h3>\n<p>Read an RDF graph.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rdflib</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pathlib</span>\n\n<span class=\"n\">OUTPUT_FILE_LAM_PROPERTIES</span> <span class=\"o\">=</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"../resource/celex_project_properties_v2.ttl\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">resolve</span><span class=\"p\">()</span>\n\n<span class=\"n\">rdf_graph</span> <span class=\"o\">=</span> <span class=\"n\">rdflib</span><span class=\"o\">.</span><span class=\"n\">Graph</span><span class=\"p\">()</span>\n<span class=\"n\">rdf_graph</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">OUTPUT_FILE_LAM_PROPERTIES</span><span class=\"p\">),</span> <span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s2\">\"ttl\"</span><span class=\"p\">)</span>\n</pre>\n<p>Load the RDF graph into a property graph.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">rdf2g</span> <span class=\"kn\">import</span> <span class=\"n\">load_rdf2g</span>\n<span class=\"n\">load_rdf2g</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">rdf_graph</span><span class=\"p\">)</span>\n</pre>\n<p>The created property graph follows the following set of <strong>conventions</strong>.</p>\n<ul>\n<li>URIs and Blank nodes are transformed into property graph nodes.</li>\n<li>Predicates connecting an URI to another URI or a blank node are transformed into property graph edges. Edge labels correspond to qualified IRIs generated using the prefix definitions available in the RDF data-set.</li>\n<li>Node labels correspond to qualified IRIs generated using the prefix definitions available in the RDF data-set.</li>\n<li>RDF Litarals are transformed into values of the node properties, while the preceding predicates into keys of the node properties. In other words</li>\n<li>Predicates connecting an URI to a RDF Literal are transformed into {key:value} pairs and added as node properties.</li>\n<li>Nodes have a special property 'iri' that is equivalent to the absolute URI of the RDF resource.</li>\n</ul>\n<h3>Get a node</h3>\n<p>Get a node referring to it either by label, iri or id</p>\n<pre><span class=\"n\">skos_concept_iri</span> <span class=\"o\">=</span> <span class=\"n\">rdflib</span><span class=\"o\">.</span><span class=\"n\">URIRef</span><span class=\"p\">(</span><span class=\"s2\">\"http://www.w3.org/2004/02/skos/core#Concept\"</span><span class=\"p\">)</span>\n<span class=\"n\">v1</span> <span class=\"o\">=</span> <span class=\"n\">rdf2g</span><span class=\"o\">.</span><span class=\"n\">get_node</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">skos_concept_iri</span><span class=\"p\">)</span>\n\n<span class=\"n\">skos_concept_label</span> <span class=\"o\">=</span> <span class=\"s2\">\"skos:Concept\"</span>\n<span class=\"n\">v2</span> <span class=\"o\">=</span> <span class=\"n\">rdf2g</span><span class=\"o\">.</span><span class=\"n\">get_node</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">skos_concept_label</span><span class=\"p\">)</span>\n\n<span class=\"n\">hypothetical_node_id</span> <span class=\"o\">=</span> <span class=\"mi\">880</span>\n<span class=\"n\">v3</span> <span class=\"o\">=</span> <span class=\"n\">rdf2g</span><span class=\"o\">.</span><span class=\"n\">get_node</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">hypothetical_node_id</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span> <span class=\"p\">(</span><span class=\"n\">v1</span> <span class=\"o\">==</span> <span class=\"n\">v2</span> <span class=\"o\">==</span> <span class=\"n\">v3</span><span class=\"p\">)</span> <span class=\"c1\"># should be true</span>\n</pre>\n<p>Get nodes by their supposed rdf:type. This concept is inherited, of course, from RDF world.</p>\n<pre><span class=\"n\">skos_concept_label</span> <span class=\"o\">=</span> <span class=\"s2\">\"skos:Concept\"</span>\n\n<span class=\"n\">list_of_concept</span> <span class=\"o\">=</span> <span class=\"n\">rdf2g</span><span class=\"o\">.</span><span class=\"n\">get_nodes_of_type</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">skos_concept_label</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># print the list of concepts in the graph</span>\n<span class=\"nb\">print</span> <span class=\"p\">(</span><span class=\"n\">list_of_concept</span><span class=\"p\">)</span>\n</pre>\n<h3>Generate a traversal tree</h3>\n<p>It is possible to traverse the property graph and then generate the traversal tree from it. This is especially useful when the graph serves as structured document content say JSON or XML serialisation.</p>\n<p>To do that first, get two levels deep traversal tree and the edges between them for all the nodes in the graph that have <code>iri == known_iri</code>. Further please see the <a href=\"http://tinkerpop.apache.org/docs/current/reference/#gremlin-python\" rel=\"nofollow\">Gremlin reference documentation</a> at Apache TinkerPop for more information on usage.</p>\n<pre><span class=\"n\">known_iri</span> <span class=\"o\">=</span> <span class=\"s1\">'http://publications.europa.eu/resources/authority/celex/md_CODE'</span> \n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">V</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">has</span><span class=\"p\">(</span><span class=\"s1\">'iri'</span><span class=\"p\">,</span> <span class=\"n\">known_iri</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">outE</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">inV</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">next</span><span class=\"p\">()</span>\n</pre>\n<p>Altenatively use the function <code>rdf2g.generate_traversal_tree</code></p>\n<pre><span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">rdf2g</span><span class=\"o\">.</span><span class=\"n\">get_node</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">known_iri</span><span class=\"p\">)</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">rdf2g</span><span class=\"o\">.</span><span class=\"n\">generate_traversal_tree</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">)</span>\n</pre>\n<p>Then expand and simplify that tree. First, simplify the dict structure to simple Python types, removing the Gremlin objects. Second, expand by providing the properties for each visited node, while the edges are considered as special properties leading to a another node dictionary.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pprint</span> <span class=\"kn\">import</span> <span class=\"n\">pprint</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">rdf2g</span><span class=\"o\">.</span><span class=\"n\">expand_tree</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">)</span>\n<span class=\"n\">pprint</span> <span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>The traversal tree nodes contain, in addition to original RDF content, two special properties <code>@id</code> and <code>@label</code> which correspond to the standard Gremlin <code>id</code> and <code>label</code> properties. The <code>@</code> sign is used to distinguish the original RDF from the Gremlin features. Property graph edges, are reduced to keys in the final dict and for this reason they have no additional descriptions just like in the original RDF graph.</p>\n<h1>Contributing</h1>\n<p>You are more than welcome to help expand and mature this project.</p>\n<p>When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change.</p>\n<p>Please note we have a code of conduct, please follow it in all your interactions with the project.</p>\n<h1>License</h1>\n<p>This project is Licensed under the GPL v3 License - see <a href=\"LICENSE\" rel=\"nofollow\">LICENSE</a> file</p>\n\n          </div>"}, "last_serial": 6044266, "releases": {"0.1.32": [{"comment_text": "", "digests": {"md5": "4d38a4c0a0c1ac3b2dc65edc2f54182a", "sha256": "c8db4db0b16f781efacfe0a7d7ef674fddf309e691a098e04344811a566a0186"}, "downloads": -1, "filename": "rdf2gremlin-0.1.32.tar.gz", "has_sig": false, "md5_digest": "4d38a4c0a0c1ac3b2dc65edc2f54182a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 8446, "upload_time": "2019-10-15T21:30:18", "upload_time_iso_8601": "2019-10-15T21:30:18.456012Z", "url": "https://files.pythonhosted.org/packages/40/48/a37a872d451e5b06aba2edad720c8bffa77a3ff15484e8f4518633c80cfe/rdf2gremlin-0.1.32.tar.gz", "yanked": false}], "0.1.33": [{"comment_text": "", "digests": {"md5": "b8c3f489541aad18035928a8a282c9de", "sha256": "9704d7e4928420967a977b93aa8a136fed2e1278fb632d9231896a57d7c41af3"}, "downloads": -1, "filename": "rdf2gremlin-0.1.33.tar.gz", "has_sig": false, "md5_digest": "b8c3f489541aad18035928a8a282c9de", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 8547, "upload_time": "2019-10-15T21:35:22", "upload_time_iso_8601": "2019-10-15T21:35:22.500252Z", "url": "https://files.pythonhosted.org/packages/1b/5d/4c09a70d384e13c33037e9e5f3e26fca10b0ef98c2159ed4f700f4012bcb/rdf2gremlin-0.1.33.tar.gz", "yanked": false}], "0.1.34": [{"comment_text": "", "digests": {"md5": "f0d5d9c5bf38d0eb68f2a37fcb1afc6d", "sha256": "c7e9f936a83fab214cf616f68aee992663138ce09b40a58eeb5d9d7328093799"}, "downloads": -1, "filename": "rdf2gremlin-0.1.34.tar.gz", "has_sig": false, "md5_digest": "f0d5d9c5bf38d0eb68f2a37fcb1afc6d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11658, "upload_time": "2019-10-20T00:40:10", "upload_time_iso_8601": "2019-10-20T00:40:10.834782Z", "url": "https://files.pythonhosted.org/packages/10/33/5d501fc015e32c101ed7687bd924a4566e580a7a034293117462da14844c/rdf2gremlin-0.1.34.tar.gz", "yanked": false}], "0.1.35": [{"comment_text": "", "digests": {"md5": "65894088c47d5ad4bd8690b5455068ea", "sha256": "d4ae0d7f61a02b35679cbae4a49fdf5975a20810c10bd65628f4d13ee5ea8e4d"}, "downloads": -1, "filename": "rdf2gremlin-0.1.35.tar.gz", "has_sig": false, "md5_digest": "65894088c47d5ad4bd8690b5455068ea", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 12421, "upload_time": "2019-10-26T21:54:53", "upload_time_iso_8601": "2019-10-26T21:54:53.602464Z", "url": "https://files.pythonhosted.org/packages/aa/48/2a979ec4ffd99a2691e70c478e5d8cbebca766cf4c4a03308cd81b5f8af2/rdf2gremlin-0.1.35.tar.gz", "yanked": false}], "0.1.36": [{"comment_text": "", "digests": {"md5": "273c55716c286d2070523aad7861fafa", "sha256": "d42e5d9d4dd26a06bb4896183a3ce920e79311cc07a67cbdcdc1f6bc9dc0c348"}, "downloads": -1, "filename": "rdf2gremlin-0.1.36.tar.gz", "has_sig": false, "md5_digest": "273c55716c286d2070523aad7861fafa", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11743, "upload_time": "2019-10-28T22:24:55", "upload_time_iso_8601": "2019-10-28T22:24:55.715110Z", "url": "https://files.pythonhosted.org/packages/95/60/3554b82091aa2731a24fb81c53319044b2694da6a6ae38c37bf502d0c19f/rdf2gremlin-0.1.36.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "273c55716c286d2070523aad7861fafa", "sha256": "d42e5d9d4dd26a06bb4896183a3ce920e79311cc07a67cbdcdc1f6bc9dc0c348"}, "downloads": -1, "filename": "rdf2gremlin-0.1.36.tar.gz", "has_sig": false, "md5_digest": "273c55716c286d2070523aad7861fafa", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11743, "upload_time": "2019-10-28T22:24:55", "upload_time_iso_8601": "2019-10-28T22:24:55.715110Z", "url": "https://files.pythonhosted.org/packages/95/60/3554b82091aa2731a24fb81c53319044b2694da6a6ae38c37bf502d0c19f/rdf2gremlin-0.1.36.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:06:39 2020"}