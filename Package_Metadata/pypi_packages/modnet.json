{"info": {"author": "Pierre-Paul De Breuck", "author_email": "pierre-paul.debreuck@uclouvain.be", "bugtrack_url": null, "classifiers": ["Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Chemistry", "Topic :: Scientific/Engineering :: Information Analysis", "Topic :: Scientific/Engineering :: Physics", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# MODNet: Material Optimal Descriptor Network\n\n## Table of contents\n- [Introduction](#introduction)\n- [How to install](#install)\n- [Usage](#usage)\n- [Pretrained models](#pretrained)\n- [Stored MODData](#stored-moddata)\n- [Documentation](#documentation)\n  - [MODData](#moddata)\n  - [MODNetModel](#modnetmodel)\n- [Author](#author)\n- [License](#license)\n\n\n\n\n<a name=\"introduction\"></a>\n## Introduction\nThis repository contains the python package implementing the Material Optimal Descriptor Network (MODNet). It is a supervised machine learning framework for **learning material properties** from the **crystal structure**. The framework is well suited for **limited datasets** and can be used for learning *multiple* properties together by using **joint transfer learning**.\n\nThis repository also contains two pretrained models that can be used for predicting the refractive index and vibrational thermodynamics for any crystal structure.\n\nSee paper for more details: [Machine learning materials properties for small datasets](https://arxiv.org/abs/2004.14766)\n\n![MODNet schematic](img/MODNet_schematic.PNG)\n<div align='center'><strong>Figure 1. Schematic representation of the MODNet.</strong></div>\n\n\n<a name=\"install\"></a>\n## How to install\n\nMODNet can be installed via pip:\n\n```bash\npip install modnet\n```\n\n\n<a name=\"usage\"></a>\n## Usage\n\nThe MODNet package is built around two classes: `MODData` and `MODNetModel`.\n\nThe usal workflow is as follows:\n```python\nfrom modnet.preprocessing import MODData\nfrom modnet.models import MODNetModel\n\n# Creating MODData\ndata = MODData(structures,targets)\ndata.featurize()\ndata.feature_selection(self,n=1000)\n\n# Creating MODNetModel\nmodel = MODNetModel(target_hierarchy,weights,num_neurons=[[256],[64,64],[32]])\nmodel.fit(data)\n\n# Predicting on unlabeled data\ndata_to_predict = MODData(new_structures)\ndata_to_predict.featurize()\ndf_predictions = model.predict(md) # dataframe containing the prediction on new_structures\n\n\n\n```\nExample notebooks can be found in *example_notebooks* directory.\n\n\n<a name=\"pretrained\"></a>\n## Pretrained models\nTwo pretrained models are provided in *pretrained/*:\n - Refractive index\n - Vibrational thermodynamics\n\nDownload this directory localy to *path/to/pretrained/*.\nThese can then be used as follows:\n\n```python\nfrom modnet.models import MODNetModel\n\nmodel = MODNetModel.load('path/to/pretrained/refractive_index')\n# or MODNetModel.load(path/to/pretrained/vib_thermo)\n```\n\n<a name=\"stored-moddata\"></a>\n## Stored MODData\n\nThree `MODData` are provided in *moddata/*:\n- Refractive index\n- Vibrational thermodynamics\n- Formation energy on Materials Project (June 2018)\n\nDownload this directory localy to *path/to/moddata/*. These can then be used as follows:\n\n```python\nfrom modnet.preprocessing import MODData\n\ndata_MP = MODData.load('path/to/moddata/MP_2018.6')\n\n```\n\nThe latter MODData (MP_2018.6) is very usefull for predicting on all structures in the Materials Project:\n\n```python\npredictions_on_MP = model.predict(data_MP)\n```\n\n<a name=\"documentation\"></a>\n## Documentation\nThe MODNet package is built around two classes: `MODData` and `MODNetModel`. \n\n<a name=\"moddata\"></a>\n### MODData\n\nA `MODData` instance is used for represtening a particular dataset. It contains a list of structures and corresponding properties:\n\n```python\nfrom modnet.preprocessing import MODData\n\ndata = MODData(structures,targets,names=[],mpids=[])\n```\n\n**Arguments:**\n- `structures (List)`: List of pymatgen Structures.\n- `targets (List)`: List of targets corresponding to each structure. When learning on multiple properties this is a list of lists, where each inner list is the ensemble of properties for a given structure.\n- `names (List)` *(optional)*: List of names corresponding to the properties. E.g. ['S_300K','S_800K',...] or ['refractive_index'] for single target learning. These names are used when building the model.\n- `mpids (List)`*(optional)*: If the list of structures (`structures`) are from the Materials Project, you can specify the corresponding mpids by providing a list of mpids: ['mp-149','mp-166',...]. This will enable fast featurization (see further).\n\n\nThe next step is to create the features:\n\n```python\ndata.featurize(self,fast=False,db_file='feature_database.pkl')\n```\n**Arguments:**\n- `fast (Boolean)` *(optional)*: If set to True, the algorithm will use the pre-computed features from a database instead of computing them again from scratch. This is recommended (and only possible) when using structures from the Materials Project. Note that the mpids should be provided in the MODData.\n- `db_file (Boolean)` *(optional)*: When setting fast to True, you need to download the file at *modnet/data/feature_database.pkl*. Then set the local path to this file in this argument.\n\nFinally, the optimal features are computed:\n\n```python\ndata.feature_selection(self,n=300)\n```\n\n**Arguments:**\n- `n`*(optional)*: Number of optimal features to compute, i.e. the n first ranked features are computed. When set to -1, all features are ranked (recommended, but can take time).\n\nThe MODData can be saved,\n\n```python\ndata.save('path/dataname')\n```\n\nand loaded for later usage:\n\n```python\nfrom modnet.preprocessing import MODData\n\ndata = MODData.load('path/dataname')\n```\n\nFeatures, targets and other data can be accesed trough the following methods:\n\n\n```python\n\n# dataframe containing the structures\ndata.get_structure_df():\n\n# dataframe containing the targets\ndata.get_target_df():\n\n# dataframe containing the features\ndata.get_featurized_df():\n\n# List of the optimal features, in ranked order\ndata.get_optimal_descriptors():\n    \n# get_featurized_df limited to the best features\ndata.get_optimal_df():\n```\n\n\n<a name=\"modnetmodel\"></a>\n### MODNetModel\n\n![MODNet schematic](img/MODNet_architecture.PNG)\n<div align='center'><strong>Figure 2. Example architecture of the MODNet.</strong></div>\n\nThe model is created by a MODNetModel instance:\n\n```python\nfrom modnet.models import MODNetModel\n\nmodel = MODNetModel(targets,weights,num_neurons=[[64],[32],[16],[16]], n_feat=300, loss='mse',act='relu')\n```\n\n**Arguments:**\n- `targets (List)`: Specifies how the different targets are organized in the architecture. It is a list of lists of lists, representing the three modular last levels: block 2, 3 and 4 (see Figure 2). Each block gathers properties, which are put inside the same list. For exmaple, in Figure 2, this is [[['S_5,...,S_800'],['U_5,...,U_800'],['C_v_5,...,C_v_800'],['H_5,...,H_800']],[['formation_energy']]]. The same names as given in `MODData` should be used.\n\n- `weights (Dictionary)`: A dictionary where each key is a property name and the value the corresponding weight to be used in the loss function. The weights are used to scale the different outputs such that the balance between the properties is conserved when training. For example, {'S_5':0.01, 'formation_energy:1'}.\n\n\n- `num_neurons (List)` *(optional)*: Number of neurons as well as the number of layers to be used in the neural network. List of three lists. Each inner list gives respectively the succesive number of neurons of the blocks 2, 3 and 4. For example, in Figure 2, this is given by [[128,128],[64,64],[8]].\n- `n_feat (int)` *(optional)*: Number of optimal features to be used in the model. In Figure 2, this is 330.\n- `loss (String)`*(optional)*: Loss function of the neural network, see Keras API.\n- `act (String)` *(optional)*: Activation function used in the neural network, see Keras API.\n\n\nThe model is then fitted on the data:\n\n\n```python\nmodel.fit(data, val_fraction = 0.0, val_key = None, lr=0.001, epochs = 200, batch_size = 128, xscale='minmax'):\n```\n\n**Arguments:**\n- `val_fraction (float)` *(optional)*: Validation fraction to be used while training.\n- `val_key (String)` *(optional)*: The name of the property used for printing validation MAE. When multiple properties are learned (e.g. ['formation energy','refractive_index','entropy']), setting the key_val (e.g. key_val = 'entropy') will only print the MAE of this property for each epoch.\n- `lr (float)` *(optional)*: Learning rate.\n- `epochs (int)` *(optional)*: Number of epochs.\n- `batch_size (int)` *(optional)*: Batch size.\n- `xscale (String)` *(optional)*: Scaling of the features. Possible values: 'minmax' or'standard'.\n\n\nYou can save and load the model for later usage:\n\n```python\nmodel.save('path/modelname')\n```\n\n```python\nfrom modnet.models import MODNetModel\nMODNetModel.load('path/modelname')\n```\n\nPrediction is done by first creating a MODData instance on the new data:\n\n```python\ndata_to_predict = MODData(structures, mpids = df.index) # Adding mpids is a good idea for fast featurization, but not necessary.\ndata_to_predict.featurize(fast=True)\n```\n\nand then using the predict method:\n\n```python\ndf_predictions = model.predict(md)\n```\nA dataframe containing the predictions is returned.\n\n\n\n<a name=\"author\"></a>\n## Author\nThis software is written by [Pierre-Paul De Breuck](mailto:pierre-paul.debreuck@uclouvain.be)\n\n<a name=\"License\"></a>\n## License\nMODNet is released under the MIT License.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ppdebreuck/modnet", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "modnet", "package_url": "https://pypi.org/project/modnet/", "platform": "", "project_url": "https://pypi.org/project/modnet/", "project_urls": {"Homepage": "https://github.com/ppdebreuck/modnet"}, "release_url": "https://pypi.org/project/modnet/0.1.1/", "requires_dist": null, "requires_python": ">=3.6", "summary": "MODNet, the Material Optimal Descriptor Network for materials properties prediction.", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>MODNet: Material Optimal Descriptor Network</h1>\n<h2>Table of contents</h2>\n<ul>\n<li><a href=\"#introduction\" rel=\"nofollow\">Introduction</a></li>\n<li><a href=\"#install\" rel=\"nofollow\">How to install</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a></li>\n<li><a href=\"#pretrained\" rel=\"nofollow\">Pretrained models</a></li>\n<li><a href=\"#stored-moddata\" rel=\"nofollow\">Stored MODData</a></li>\n<li><a href=\"#documentation\" rel=\"nofollow\">Documentation</a>\n<ul>\n<li><a href=\"#moddata\" rel=\"nofollow\">MODData</a></li>\n<li><a href=\"#modnetmodel\" rel=\"nofollow\">MODNetModel</a></li>\n</ul>\n</li>\n<li><a href=\"#author\" rel=\"nofollow\">Author</a></li>\n<li><a href=\"#license\" rel=\"nofollow\">License</a></li>\n</ul>\n<p><a></a></p>\n<h2>Introduction</h2>\n<p>This repository contains the python package implementing the Material Optimal Descriptor Network (MODNet). It is a supervised machine learning framework for <strong>learning material properties</strong> from the <strong>crystal structure</strong>. The framework is well suited for <strong>limited datasets</strong> and can be used for learning <em>multiple</em> properties together by using <strong>joint transfer learning</strong>.</p>\n<p>This repository also contains two pretrained models that can be used for predicting the refractive index and vibrational thermodynamics for any crystal structure.</p>\n<p>See paper for more details: <a href=\"https://arxiv.org/abs/2004.14766\" rel=\"nofollow\">Machine learning materials properties for small datasets</a></p>\n<p><img alt=\"MODNet schematic\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8393eaa966fc8862c22357facd52b8562acd7b5e/696d672f4d4f444e65745f736368656d617469632e504e47\"></p>\n<div><strong>Figure 1. Schematic representation of the MODNet.</strong></div>\n<p><a></a></p>\n<h2>How to install</h2>\n<p>MODNet can be installed via pip:</p>\n<pre>pip install modnet\n</pre>\n<p><a></a></p>\n<h2>Usage</h2>\n<p>The MODNet package is built around two classes: <code>MODData</code> and <code>MODNetModel</code>.</p>\n<p>The usal workflow is as follows:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">modnet.preprocessing</span> <span class=\"kn\">import</span> <span class=\"n\">MODData</span>\n<span class=\"kn\">from</span> <span class=\"nn\">modnet.models</span> <span class=\"kn\">import</span> <span class=\"n\">MODNetModel</span>\n\n<span class=\"c1\"># Creating MODData</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">MODData</span><span class=\"p\">(</span><span class=\"n\">structures</span><span class=\"p\">,</span><span class=\"n\">targets</span><span class=\"p\">)</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">featurize</span><span class=\"p\">()</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">feature_selection</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Creating MODNetModel</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">MODNetModel</span><span class=\"p\">(</span><span class=\"n\">target_hierarchy</span><span class=\"p\">,</span><span class=\"n\">weights</span><span class=\"p\">,</span><span class=\"n\">num_neurons</span><span class=\"o\">=</span><span class=\"p\">[[</span><span class=\"mi\">256</span><span class=\"p\">],[</span><span class=\"mi\">64</span><span class=\"p\">,</span><span class=\"mi\">64</span><span class=\"p\">],[</span><span class=\"mi\">32</span><span class=\"p\">]])</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Predicting on unlabeled data</span>\n<span class=\"n\">data_to_predict</span> <span class=\"o\">=</span> <span class=\"n\">MODData</span><span class=\"p\">(</span><span class=\"n\">new_structures</span><span class=\"p\">)</span>\n<span class=\"n\">data_to_predict</span><span class=\"o\">.</span><span class=\"n\">featurize</span><span class=\"p\">()</span>\n<span class=\"n\">df_predictions</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">md</span><span class=\"p\">)</span> <span class=\"c1\"># dataframe containing the prediction on new_structures</span>\n</pre>\n<p>Example notebooks can be found in <em>example_notebooks</em> directory.</p>\n<p><a></a></p>\n<h2>Pretrained models</h2>\n<p>Two pretrained models are provided in <em>pretrained/</em>:</p>\n<ul>\n<li>Refractive index</li>\n<li>Vibrational thermodynamics</li>\n</ul>\n<p>Download this directory localy to <em>path/to/pretrained/</em>.\nThese can then be used as follows:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">modnet.models</span> <span class=\"kn\">import</span> <span class=\"n\">MODNetModel</span>\n\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">MODNetModel</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'path/to/pretrained/refractive_index'</span><span class=\"p\">)</span>\n<span class=\"c1\"># or MODNetModel.load(path/to/pretrained/vib_thermo)</span>\n</pre>\n<p><a></a></p>\n<h2>Stored MODData</h2>\n<p>Three <code>MODData</code> are provided in <em>moddata/</em>:</p>\n<ul>\n<li>Refractive index</li>\n<li>Vibrational thermodynamics</li>\n<li>Formation energy on Materials Project (June 2018)</li>\n</ul>\n<p>Download this directory localy to <em>path/to/moddata/</em>. These can then be used as follows:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">modnet.preprocessing</span> <span class=\"kn\">import</span> <span class=\"n\">MODData</span>\n\n<span class=\"n\">data_MP</span> <span class=\"o\">=</span> <span class=\"n\">MODData</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'path/to/moddata/MP_2018.6'</span><span class=\"p\">)</span>\n</pre>\n<p>The latter MODData (MP_2018.6) is very usefull for predicting on all structures in the Materials Project:</p>\n<pre><span class=\"n\">predictions_on_MP</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">data_MP</span><span class=\"p\">)</span>\n</pre>\n<p><a></a></p>\n<h2>Documentation</h2>\n<p>The MODNet package is built around two classes: <code>MODData</code> and <code>MODNetModel</code>.</p>\n<p><a></a></p>\n<h3>MODData</h3>\n<p>A <code>MODData</code> instance is used for represtening a particular dataset. It contains a list of structures and corresponding properties:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">modnet.preprocessing</span> <span class=\"kn\">import</span> <span class=\"n\">MODData</span>\n\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">MODData</span><span class=\"p\">(</span><span class=\"n\">structures</span><span class=\"p\">,</span><span class=\"n\">targets</span><span class=\"p\">,</span><span class=\"n\">names</span><span class=\"o\">=</span><span class=\"p\">[],</span><span class=\"n\">mpids</span><span class=\"o\">=</span><span class=\"p\">[])</span>\n</pre>\n<p><strong>Arguments:</strong></p>\n<ul>\n<li><code>structures (List)</code>: List of pymatgen Structures.</li>\n<li><code>targets (List)</code>: List of targets corresponding to each structure. When learning on multiple properties this is a list of lists, where each inner list is the ensemble of properties for a given structure.</li>\n<li><code>names (List)</code> <em>(optional)</em>: List of names corresponding to the properties. E.g. ['S_300K','S_800K',...] or ['refractive_index'] for single target learning. These names are used when building the model.</li>\n<li><code>mpids (List)</code><em>(optional)</em>: If the list of structures (<code>structures</code>) are from the Materials Project, you can specify the corresponding mpids by providing a list of mpids: ['mp-149','mp-166',...]. This will enable fast featurization (see further).</li>\n</ul>\n<p>The next step is to create the features:</p>\n<pre><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">featurize</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span><span class=\"n\">db_file</span><span class=\"o\">=</span><span class=\"s1\">'feature_database.pkl'</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Arguments:</strong></p>\n<ul>\n<li><code>fast (Boolean)</code> <em>(optional)</em>: If set to True, the algorithm will use the pre-computed features from a database instead of computing them again from scratch. This is recommended (and only possible) when using structures from the Materials Project. Note that the mpids should be provided in the MODData.</li>\n<li><code>db_file (Boolean)</code> <em>(optional)</em>: When setting fast to True, you need to download the file at <em>modnet/data/feature_database.pkl</em>. Then set the local path to this file in this argument.</li>\n</ul>\n<p>Finally, the optimal features are computed:</p>\n<pre><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">feature_selection</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">300</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Arguments:</strong></p>\n<ul>\n<li><code>n</code><em>(optional)</em>: Number of optimal features to compute, i.e. the n first ranked features are computed. When set to -1, all features are ranked (recommended, but can take time).</li>\n</ul>\n<p>The MODData can be saved,</p>\n<pre><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"s1\">'path/dataname'</span><span class=\"p\">)</span>\n</pre>\n<p>and loaded for later usage:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">modnet.preprocessing</span> <span class=\"kn\">import</span> <span class=\"n\">MODData</span>\n\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">MODData</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'path/dataname'</span><span class=\"p\">)</span>\n</pre>\n<p>Features, targets and other data can be accesed trough the following methods:</p>\n<pre><span class=\"c1\"># dataframe containing the structures</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">get_structure_df</span><span class=\"p\">():</span>\n\n<span class=\"c1\"># dataframe containing the targets</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">get_target_df</span><span class=\"p\">():</span>\n\n<span class=\"c1\"># dataframe containing the features</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">get_featurized_df</span><span class=\"p\">():</span>\n\n<span class=\"c1\"># List of the optimal features, in ranked order</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">get_optimal_descriptors</span><span class=\"p\">():</span>\n    \n<span class=\"c1\"># get_featurized_df limited to the best features</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">get_optimal_df</span><span class=\"p\">():</span>\n</pre>\n<p><a></a></p>\n<h3>MODNetModel</h3>\n<p><img alt=\"MODNet schematic\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/94ca0fcfc0b6ac6d9971d86d54b925c61c37bcb6/696d672f4d4f444e65745f6172636869746563747572652e504e47\"></p>\n<div><strong>Figure 2. Example architecture of the MODNet.</strong></div>\n<p>The model is created by a MODNetModel instance:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">modnet.models</span> <span class=\"kn\">import</span> <span class=\"n\">MODNetModel</span>\n\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">MODNetModel</span><span class=\"p\">(</span><span class=\"n\">targets</span><span class=\"p\">,</span><span class=\"n\">weights</span><span class=\"p\">,</span><span class=\"n\">num_neurons</span><span class=\"o\">=</span><span class=\"p\">[[</span><span class=\"mi\">64</span><span class=\"p\">],[</span><span class=\"mi\">32</span><span class=\"p\">],[</span><span class=\"mi\">16</span><span class=\"p\">],[</span><span class=\"mi\">16</span><span class=\"p\">]],</span> <span class=\"n\">n_feat</span><span class=\"o\">=</span><span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"n\">loss</span><span class=\"o\">=</span><span class=\"s1\">'mse'</span><span class=\"p\">,</span><span class=\"n\">act</span><span class=\"o\">=</span><span class=\"s1\">'relu'</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Arguments:</strong></p>\n<ul>\n<li>\n<p><code>targets (List)</code>: Specifies how the different targets are organized in the architecture. It is a list of lists of lists, representing the three modular last levels: block 2, 3 and 4 (see Figure 2). Each block gathers properties, which are put inside the same list. For exmaple, in Figure 2, this is [[['S_5,...,S_800'],['U_5,...,U_800'],['C_v_5,...,C_v_800'],['H_5,...,H_800']],[['formation_energy']]]. The same names as given in <code>MODData</code> should be used.</p>\n</li>\n<li>\n<p><code>weights (Dictionary)</code>: A dictionary where each key is a property name and the value the corresponding weight to be used in the loss function. The weights are used to scale the different outputs such that the balance between the properties is conserved when training. For example, {'S_5':0.01, 'formation_energy:1'}.</p>\n</li>\n<li>\n<p><code>num_neurons (List)</code> <em>(optional)</em>: Number of neurons as well as the number of layers to be used in the neural network. List of three lists. Each inner list gives respectively the succesive number of neurons of the blocks 2, 3 and 4. For example, in Figure 2, this is given by [[128,128],[64,64],[8]].</p>\n</li>\n<li>\n<p><code>n_feat (int)</code> <em>(optional)</em>: Number of optimal features to be used in the model. In Figure 2, this is 330.</p>\n</li>\n<li>\n<p><code>loss (String)</code><em>(optional)</em>: Loss function of the neural network, see Keras API.</p>\n</li>\n<li>\n<p><code>act (String)</code> <em>(optional)</em>: Activation function used in the neural network, see Keras API.</p>\n</li>\n</ul>\n<p>The model is then fitted on the data:</p>\n<pre><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">val_fraction</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"n\">val_key</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">lr</span><span class=\"o\">=</span><span class=\"mf\">0.001</span><span class=\"p\">,</span> <span class=\"n\">epochs</span> <span class=\"o\">=</span> <span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span> <span class=\"o\">=</span> <span class=\"mi\">128</span><span class=\"p\">,</span> <span class=\"n\">xscale</span><span class=\"o\">=</span><span class=\"s1\">'minmax'</span><span class=\"p\">):</span>\n</pre>\n<p><strong>Arguments:</strong></p>\n<ul>\n<li><code>val_fraction (float)</code> <em>(optional)</em>: Validation fraction to be used while training.</li>\n<li><code>val_key (String)</code> <em>(optional)</em>: The name of the property used for printing validation MAE. When multiple properties are learned (e.g. ['formation energy','refractive_index','entropy']), setting the key_val (e.g. key_val = 'entropy') will only print the MAE of this property for each epoch.</li>\n<li><code>lr (float)</code> <em>(optional)</em>: Learning rate.</li>\n<li><code>epochs (int)</code> <em>(optional)</em>: Number of epochs.</li>\n<li><code>batch_size (int)</code> <em>(optional)</em>: Batch size.</li>\n<li><code>xscale (String)</code> <em>(optional)</em>: Scaling of the features. Possible values: 'minmax' or'standard'.</li>\n</ul>\n<p>You can save and load the model for later usage:</p>\n<pre><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"s1\">'path/modelname'</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">modnet.models</span> <span class=\"kn\">import</span> <span class=\"n\">MODNetModel</span>\n<span class=\"n\">MODNetModel</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'path/modelname'</span><span class=\"p\">)</span>\n</pre>\n<p>Prediction is done by first creating a MODData instance on the new data:</p>\n<pre><span class=\"n\">data_to_predict</span> <span class=\"o\">=</span> <span class=\"n\">MODData</span><span class=\"p\">(</span><span class=\"n\">structures</span><span class=\"p\">,</span> <span class=\"n\">mpids</span> <span class=\"o\">=</span> <span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"c1\"># Adding mpids is a good idea for fast featurization, but not necessary.</span>\n<span class=\"n\">data_to_predict</span><span class=\"o\">.</span><span class=\"n\">featurize</span><span class=\"p\">(</span><span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>and then using the predict method:</p>\n<pre><span class=\"n\">df_predictions</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">md</span><span class=\"p\">)</span>\n</pre>\n<p>A dataframe containing the predictions is returned.</p>\n<p><a></a></p>\n<h2>Author</h2>\n<p>This software is written by <a href=\"mailto:pierre-paul.debreuck@uclouvain.be\">Pierre-Paul De Breuck</a></p>\n<p><a></a></p>\n<h2>License</h2>\n<p>MODNet is released under the MIT License.</p>\n\n          </div>"}, "last_serial": 7175786, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "c15f944b5739835f7f517d21db54c2cc", "sha256": "38b18f39b617a09fb88244f57e33783a8f036bbbfbca264b973ee3f55903e643"}, "downloads": -1, "filename": "modnet-0.1.1.tar.gz", "has_sig": false, "md5_digest": "c15f944b5739835f7f517d21db54c2cc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 10237144, "upload_time": "2020-05-05T20:57:00", "upload_time_iso_8601": "2020-05-05T20:57:00.507304Z", "url": "https://files.pythonhosted.org/packages/da/c6/b67b7be50c032b4756fdfbfa2b7fa3c8642416a65d5fb4999b1930f43b83/modnet-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c15f944b5739835f7f517d21db54c2cc", "sha256": "38b18f39b617a09fb88244f57e33783a8f036bbbfbca264b973ee3f55903e643"}, "downloads": -1, "filename": "modnet-0.1.1.tar.gz", "has_sig": false, "md5_digest": "c15f944b5739835f7f517d21db54c2cc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 10237144, "upload_time": "2020-05-05T20:57:00", "upload_time_iso_8601": "2020-05-05T20:57:00.507304Z", "url": "https://files.pythonhosted.org/packages/da/c6/b67b7be50c032b4756fdfbfa2b7fa3c8642416a65d5fb4999b1930f43b83/modnet-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:47 2020"}