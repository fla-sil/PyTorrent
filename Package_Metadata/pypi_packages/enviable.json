{"info": {"author": "Keryn Knight", "author_email": "python-enviable@kerynknight.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3"], "description": "enviable\n========\n\n:author: Keryn Knight\n:version: 0.2.2\n\nA small module for wrapping over environment variables (pulled from ``os.environ``)\nwhich provides convenience methods to fetch and check various data types\n(including iterables) in what I'd charitably hope is a sensible way.\n\nExplicitly doesn't attempt to read from any ``.env`` or ``.envrc`` file, because that\ndoesn't describe valid examples or which things may/should be set into the\nenvironment. It becomes an absolute pot-luck.\n\nTracks requested environment variables and their default/fallback/example values, and\nwhether or not the fallback was used. Never tracks the actual environment value.\n\nIf this package isn't to your liking, there's **plenty** of others, and I'm\nlargely suffering from *Not-Invented-Here syndrome*.\n\nAll methods exposed by the Environment accept a key and a default.\n\n- The key is the environment variable to search for.\n- The default **MUST** be a string, as it is subject to the same parsing as if it had\n  been found in the environment, and thus serves as a documented example of a valid\n  value to export as an environment variable. Enforced value documentation!\n\nA series of examples\n--------------------\n\nA short overview of all of the available check/cast methods on an ``Environment`` follows\n\nAssume all examples are prefixed with::\n\n    from enviable import env\n\nwhich is roughly equivalent to::\n\n    from enviable import Environment\n    import os\n    env = Environment(os.environ)\n\nRemember, the **second** argument (``default``) is always a string, and always\ngets parsed the same as a real value, so treat it as an example value in the following...\n\nConversions and validations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nTo trim any accidental quotes or whitespace from the beginning and end of the value::\n\n    env.text(\"VAR_NAME\", \"'   test '\") == \"test\"\n\nTo convert an incoming string to an integer::\n\n    env.int(\"VAR_NAME\", \"3\") == 3\n\nTo convert an incoming string to real boolean (``True`` or ``False``), note\nthat upper or lower case doesn't matter::\n\n    env.bool(\"VAR_NAME\", \"true\") is True\n    env.bool(\"VAR_NAME\", \"on\") is True\n    env.bool(\"VAR_NAME\", \"1\") is True\n    env.bool(\"VAR_NAME\", \"yes\") is True\n    env.bool(\"VAR_NAME\", \"y\") is True\n\n    env.bool(\"VAR_NAME\", \"false\") is False\n    env.bool(\"VAR_NAME\", \"off\") is False\n    env.bool(\"VAR_NAME\", \"0\") is False\n    env.bool(\"VAR_NAME\", \"no\") is False\n    env.bool(\"VAR_NAME\", \"n\") is False\n\nTo make a ``uuid.UUID`` from an optionally hyphenated string::\n\n    env.uuid(\"VAR_NAME\", \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\") == UUID('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa')\n    env.uuid(\"VAR_NAME\", \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == UUID('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa')\n\nTo *check* if an email *looks* valid::\n\n    env.email(\"VAR_NAME\", \"a@b.com\") == \"a@b.com\"\n\nTo verify if a string is all hexi characters::\n\n    env.hex(\"VAR_NAME\", \"abcdef12345ABCDEF\") == \"abcdef12345ABCDEF\"\n\nConfirm that a string can be decoded from a base64 encoded value::\n\n    env.b64(\"VAR_NAME\", \"d29vZg==\") == 'd29vZg=='\n\nThere's no support for ``float`` because it's lossy, but you can have decimals::\n\n    env.decimal(\"VAR_NAME\", \"1.25\") == Decimal(\"1.25\")\n\nTo confirm that a string looks like it might be an importable python thing::\n\n    env.importable(\"VAR_NAME\", \"path.to.my.module\") == \"path.to.my.module\"\n\nTo make sure a string represents an existing, *readable* file on disk::\n\n    env.filepath(\"VAR_NAME\", \"/path/to/my/valid_file.json\") == \"/path/to/my/valid_file.json\"\n\nTo make sure a string is a directory which exists::\n\n    env.directory(\"VAR_NAME\", \"/path/to/my\") == \"/path/to/my\"\n\nTo *vaguely* sanity-check URLs (must start with ``http://`` or ``https://`` or ``//`` or ``/...``)::\n\n    env.web_address(\"VAR_NAME\", \"http://example.com/\")\n\nTo constrain a value to one of a few valid options (where ``choices`` is parsed the same way as `Iterables`_)::\n\n    env.one_of(\"VAR_NAME\", \"3\", choices=\"1,2,3,4\")\n\nand to go off-reservation, you can get JSON out, or the raw environment string::\n\n    env.json(\"VAR_NAME\", \"{}\") == {}\n    env.raw(\"VAR_NAME\", \"'   ...  '\") == \"'   ...  '\"\n\nTemporal values (datetimes, dates, times)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf you have `Django`_ installed (because that's my main use case and I'm lazy)\nyou can also get datetimes if you provide a value in ISO 8601 format::\n\n    env.datetime(\"VAR_NAME\", \"2019-11-21 16:12:56.002344\")\n    env.datetime(\"VAR_NAME\", \"2019-11-21 16:12:56.002344+20:00\")\n    env.datetime(\"VAR_NAME\", \"2019-11-21\")\n\nSimilarly you can ask for dates::\n\n    env.date(\"VAR_NAME\", \"2019-11-21\")\n    env.date(\"VAR_NAME\", \"2019-11-2\")\n    env.date(\"VAR_NAME\", \"2019-3-2\")\n\nor times::\n\n    env.time(\"VAR_NAME\", \"13:13:13.000123\")\n    env.time(\"VAR_NAME\", \"13:13:13.123\")\n    env.time(\"VAR_NAME\", \"13:13:13\")\n    env.time(\"VAR_NAME\", \"13:13\")\n\nIterables\n^^^^^^^^^\n\nIt's additionally possible to consume a string and cast it to a sequence etc::\n\n    env.tuple(\"VAR_NAME\", \"123,4356,235\") == (\"123\", \"4356\", \"235\")\n    env.list(\"VAR_NAME\", \"123,4356,235\") == [\"123\", \"4356\", \"235\"]\n    env.set(\"VAR_NAME\", \"123,4356,235\") == {\"123\", \"4356\", \"235\"}\n    env.frozenset(\"VAR_NAME\", \"123,4356,235\") == {\"123\", \"4356\", \"235\"}\n    env.dict(\"VAR_NAME\", \"a=1, b=2, c=3\") == {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\"}\n\nCommas are treated as delimiters, and may optionally have a single space after each one.\n\nLeading python-iterable characters are dropped if they are present from both sides,\nand their python type is ignored::\n\n    env.tuple(\"VAR_NAME\", \"[123, 4356, 235]\") == (\"123\", \"4356\", \"235\")\n    env.tuple(\"VAR_NAME\", \"(123, 4356, 235)\") == (\"123\", \"4356\", \"235\")\n    env.tuple(\"VAR_NAME\", \"{123, 4356, 235}\") == (\"123\", \"4356\", \"235\")\n\nCasting on iterables\n^^^^^^^^^^^^^^^^^^^^\n\nUsing any of ``env.tuple``, ``env.list``, ``env.set``, ``env.frozenset``,\nor ``env.dict`` allows each parsed value to be validated and optionally cast,\nwith the caveat that the *iterable is homogenous* (that is, everything can be\nconverted to an ``int`` or a ``uuid`` or whatever)\n\nEach value may be cast to any of the non-iterable methods documented above, by using\n``env.ensure.methodname`` instead of ``env.methodname``, for example::\n\n    env.tuple(\"VAR_NAME\", \"123,4356,235\", converter=env.ensure.int) == (123, 4356, 235)\n    env.set(\"VAR_NAME\", \"123,4356,235\", converter=env.ensure.hex) == {\"123\", \"4356\", \"235\"}\n    env.list(\"VAR_NAME\", \"a@b.com, b@c.com, def@ghi\", env.ensure.email) == ['a@b.com', 'b@c.com', 'def@ghi']\n\n``env.dict`` is slightly special in that it has arguments for ``key_converter`` and ``value_converter``\nso that keys can have a different type to values. Both must still be homogenous::\n\n    env.dict(\"VAR_NAME\", \"a=1, b=2, c=3\", key_converter=env.ensure.hex, value_converter=env.ensure.int) == {'a': 1, 'c': 3, 'b': 2}\n\nHandling errors\n---------------\n\nFailing to successfully convert (or just validate) the value (whether from\nthe environment or from the fallback) immediately halts execution by raising\n``EnvironmentCastError`` which is a subclass of ``ValueError``.\n\nFailing to provide a **string** for a default/fallback value will\nraise ``EnvironmentDefaultError`` which is *also* a subclass of ``ValueError``.\n\nTo catch any *anticipated* error then, is to::\n\n    try:\n        ...\n    except (EnvironmentCastError, EnvironmentDefaultError) as e:\n        ...\n\nChecking for existence\n----------------------\n\nTo find out if an environment variable is set, *regardless of it's value*, you can\nuse normal ``in`` testing::\n\n    if \"MY_KEY\" in env:\n        do_something_special()\n\nwhich allows you to change behaviour based on seeing certain variables in the\nrunning environment.\n\nTracking the requests\n---------------------\n\nEvery access of an ``Environment`` (eg: the default ``env``) keeps an internal\nlog of the key requested + whether or not it was found and used in the environment.\n\nThese are available under ``env.used`` and ``env.fallbacks`` but may be accessed\ntogether by iterating over the ``Environment`` in question, where each iteration\nwill yield a ``3-tuple`` of:\n\n- environment variable name requested\n- the ``default`` or *fallback* value\n- a ``bool`` of whether or not the environment variable was used or whether the fallback was. ``True`` if found in the environment, ``False`` if the fallback was used.\n\nFor example, to output everything, you might do::\n\n    from enviable import env, Environment\n    import sys\n    env.int(\"TEST\", \"4\")\n    myenv = Environment({\"TESTING\": \"1\"})\n    myenv.bool(\"TESTING\", \"0\")\n    if __name__ == \"__main__\":\n        for env_var_name, env_var_example, was_read_from_env in env:\n            if was_read_from_env is True:\n                sys.stdout.write(\"{} was in the environment\\n\".format(env_var_name))\n            else:\n                sys.stdout.write(\"{} was NOT in the environment, used default value of {}\\n\".format(env_var_name, env_var_example))\n\nNote that in the above scenario, because ``env`` and ``myenv`` are different\ninstances with their own individual tracking, the request for ``TESTING`` will\nnot output, but ``TEST`` will.\n\nRunning the tests\n-----------------\n\nGiven a copy of the file ``enviable.py`` you ought to be able to do either of the following::\n\n    $ python enviable.py\n    $ python -m enviable\n\nand see the output of the various tests I've bothered with. If mypy is installed,\nit will also type-check the file.\n\nTODO\n----\n\n- More tests\n\nThe license\n-----------\n\nIt's `FreeBSD`_. There's should be a ``LICENSE`` file in the root of the repository, and in any archives.\n\n.. _FreeBSD: http://en.wikipedia.org/wiki/BSD_licenses#2-clause_license_.28.22Simplified_BSD_License.22_or_.22FreeBSD_License.22.29\n.. _Django: https://www.djangoproject.com/\n\n\n----\n\nCopyright (c) 2019, Keryn Knight\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n----\n\nChange history for enviable\n---------------------------\n0.2.2\n^^^^^^\n* Bugfix: the ``typing`` module is no longer a hard-dependency, because whilst you have it on py3, you only *might* have it in a py2 environment. See `GitHub issue 2`_\n\n0.2.1\n^^^^^^\n* Feature: Testing if a key exists in the environment can now be done using ``\"KEYNAME\" in env``\n* Bugfix: using ``env.one_of(key, default=\"\", choices=\"\")`` without providing a custom converter no longer throws a ``TypeError``\n* Misc: Updated type hints across the module to keep `mypy`_ happy, and me deeply unhappy.\n* Misc: Before executing tests when doing ``python -m enviable``, try and run `mypy`_\n\n0.2.0\n^^^^^^\n* Bugfix: Resolved issue where by default it wasn't stripping leading/trailing whitespace from incoming strings\n* Feature: Added new convienience method ``env.one_of(key, default=\"\", choices=\"\", converter=None)`` for providing a constrainted list of options which are valid.\n* Misc: Updated the default converter for iterables to be a ``partial``\n* Bugfix: Resolved issue where ``str()`` and ``repr()`` for an ``Environment`` would leave duplicate values in if the same variable is searched for multiple times with different example/default values.\n\n0.1.0\n^^^^^\n* Initial export\n\n.. _mypy: https://mypy.readthedocs.io/en/latest/\n.. _GitHub issue 2: https://github.com/kezabelle/python-enviable/issues/2\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kezabelle/python-enviable", "keywords": "environment variables", "license": "BSD License", "maintainer": "Keryn Knight", "maintainer_email": "python-enviable@kerynknight.com", "name": "enviable", "package_url": "https://pypi.org/project/enviable/", "platform": "", "project_url": "https://pypi.org/project/enviable/", "project_urls": {"Homepage": "https://github.com/kezabelle/python-enviable"}, "release_url": "https://pypi.org/project/enviable/0.2.2/", "requires_dist": null, "requires_python": "", "summary": "Yet another wrapper object for environment variables. Does only the things I care about.", "version": "0.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <table>\n<col>\n<col>\n<tbody>\n<tr><th>Author:</th>\n<td>Keryn Knight</td></tr>\n<tr><th>Version:</th>\n<td>0.2.2</td></tr>\n</tbody>\n</table>\n<p>A small module for wrapping over environment variables (pulled from <tt>os.environ</tt>)\nwhich provides convenience methods to fetch and check various data types\n(including iterables) in what I\u2019d charitably hope is a sensible way.</p>\n<p>Explicitly doesn\u2019t attempt to read from any <tt>.env</tt> or <tt>.envrc</tt> file, because that\ndoesn\u2019t describe valid examples or which things may/should be set into the\nenvironment. It becomes an absolute pot-luck.</p>\n<p>Tracks requested environment variables and their default/fallback/example values, and\nwhether or not the fallback was used. Never tracks the actual environment value.</p>\n<p>If this package isn\u2019t to your liking, there\u2019s <strong>plenty</strong> of others, and I\u2019m\nlargely suffering from <em>Not-Invented-Here syndrome</em>.</p>\n<p>All methods exposed by the Environment accept a key and a default.</p>\n<ul>\n<li>The key is the environment variable to search for.</li>\n<li>The default <strong>MUST</strong> be a string, as it is subject to the same parsing as if it had\nbeen found in the environment, and thus serves as a documented example of a valid\nvalue to export as an environment variable. Enforced value documentation!</li>\n</ul>\n<div id=\"a-series-of-examples\">\n<h2>A series of examples</h2>\n<p>A short overview of all of the available check/cast methods on an <tt>Environment</tt> follows</p>\n<p>Assume all examples are prefixed with:</p>\n<pre>from enviable import env\n</pre>\n<p>which is roughly equivalent to:</p>\n<pre>from enviable import Environment\nimport os\nenv = Environment(os.environ)\n</pre>\n<p>Remember, the <strong>second</strong> argument (<tt>default</tt>) is always a string, and always\ngets parsed the same as a real value, so treat it as an example value in the following\u2026</p>\n<div id=\"conversions-and-validations\">\n<h3>Conversions and validations</h3>\n<p>To trim any accidental quotes or whitespace from the beginning and end of the value:</p>\n<pre>env.text(\"VAR_NAME\", \"'   test '\") == \"test\"\n</pre>\n<p>To convert an incoming string to an integer:</p>\n<pre>env.int(\"VAR_NAME\", \"3\") == 3\n</pre>\n<p>To convert an incoming string to real boolean (<tt>True</tt> or <tt>False</tt>), note\nthat upper or lower case doesn\u2019t matter:</p>\n<pre>env.bool(\"VAR_NAME\", \"true\") is True\nenv.bool(\"VAR_NAME\", \"on\") is True\nenv.bool(\"VAR_NAME\", \"1\") is True\nenv.bool(\"VAR_NAME\", \"yes\") is True\nenv.bool(\"VAR_NAME\", \"y\") is True\n\nenv.bool(\"VAR_NAME\", \"false\") is False\nenv.bool(\"VAR_NAME\", \"off\") is False\nenv.bool(\"VAR_NAME\", \"0\") is False\nenv.bool(\"VAR_NAME\", \"no\") is False\nenv.bool(\"VAR_NAME\", \"n\") is False\n</pre>\n<p>To make a <tt>uuid.UUID</tt> from an optionally hyphenated string:</p>\n<pre>env.uuid(\"VAR_NAME\", \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\") == UUID('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa')\nenv.uuid(\"VAR_NAME\", \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == UUID('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa')\n</pre>\n<p>To <em>check</em> if an email <em>looks</em> valid:</p>\n<pre>env.email(\"VAR_NAME\", \"a@b.com\") == \"a@b.com\"\n</pre>\n<p>To verify if a string is all hexi characters:</p>\n<pre>env.hex(\"VAR_NAME\", \"abcdef12345ABCDEF\") == \"abcdef12345ABCDEF\"\n</pre>\n<p>Confirm that a string can be decoded from a base64 encoded value:</p>\n<pre>env.b64(\"VAR_NAME\", \"d29vZg==\") == 'd29vZg=='\n</pre>\n<p>There\u2019s no support for <tt>float</tt> because it\u2019s lossy, but you can have decimals:</p>\n<pre>env.decimal(\"VAR_NAME\", \"1.25\") == Decimal(\"1.25\")\n</pre>\n<p>To confirm that a string looks like it might be an importable python thing:</p>\n<pre>env.importable(\"VAR_NAME\", \"path.to.my.module\") == \"path.to.my.module\"\n</pre>\n<p>To make sure a string represents an existing, <em>readable</em> file on disk:</p>\n<pre>env.filepath(\"VAR_NAME\", \"/path/to/my/valid_file.json\") == \"/path/to/my/valid_file.json\"\n</pre>\n<p>To make sure a string is a directory which exists:</p>\n<pre>env.directory(\"VAR_NAME\", \"/path/to/my\") == \"/path/to/my\"\n</pre>\n<p>To <em>vaguely</em> sanity-check URLs (must start with <tt><span class=\"pre\">http://</span></tt> or <tt><span class=\"pre\">https://</span></tt> or <tt>//</tt> or <tt><span class=\"pre\">/...</span></tt>):</p>\n<pre>env.web_address(\"VAR_NAME\", \"http://example.com/\")\n</pre>\n<p>To constrain a value to one of a few valid options (where <tt>choices</tt> is parsed the same way as <a href=\"#iterables\" rel=\"nofollow\">Iterables</a>):</p>\n<pre>env.one_of(\"VAR_NAME\", \"3\", choices=\"1,2,3,4\")\n</pre>\n<p>and to go off-reservation, you can get JSON out, or the raw environment string:</p>\n<pre>env.json(\"VAR_NAME\", \"{}\") == {}\nenv.raw(\"VAR_NAME\", \"'   ...  '\") == \"'   ...  '\"\n</pre>\n</div>\n<div id=\"temporal-values-datetimes-dates-times\">\n<h3>Temporal values (datetimes, dates, times)</h3>\n<p>If you have <a href=\"https://www.djangoproject.com/\" rel=\"nofollow\">Django</a> installed (because that\u2019s my main use case and I\u2019m lazy)\nyou can also get datetimes if you provide a value in ISO 8601 format:</p>\n<pre>env.datetime(\"VAR_NAME\", \"2019-11-21 16:12:56.002344\")\nenv.datetime(\"VAR_NAME\", \"2019-11-21 16:12:56.002344+20:00\")\nenv.datetime(\"VAR_NAME\", \"2019-11-21\")\n</pre>\n<p>Similarly you can ask for dates:</p>\n<pre>env.date(\"VAR_NAME\", \"2019-11-21\")\nenv.date(\"VAR_NAME\", \"2019-11-2\")\nenv.date(\"VAR_NAME\", \"2019-3-2\")\n</pre>\n<p>or times:</p>\n<pre>env.time(\"VAR_NAME\", \"13:13:13.000123\")\nenv.time(\"VAR_NAME\", \"13:13:13.123\")\nenv.time(\"VAR_NAME\", \"13:13:13\")\nenv.time(\"VAR_NAME\", \"13:13\")\n</pre>\n</div>\n<div id=\"iterables\">\n<h3>Iterables</h3>\n<p>It\u2019s additionally possible to consume a string and cast it to a sequence etc:</p>\n<pre>env.tuple(\"VAR_NAME\", \"123,4356,235\") == (\"123\", \"4356\", \"235\")\nenv.list(\"VAR_NAME\", \"123,4356,235\") == [\"123\", \"4356\", \"235\"]\nenv.set(\"VAR_NAME\", \"123,4356,235\") == {\"123\", \"4356\", \"235\"}\nenv.frozenset(\"VAR_NAME\", \"123,4356,235\") == {\"123\", \"4356\", \"235\"}\nenv.dict(\"VAR_NAME\", \"a=1, b=2, c=3\") == {\"a\": \"1\", \"b\": \"2\", \"c\": \"3\"}\n</pre>\n<p>Commas are treated as delimiters, and may optionally have a single space after each one.</p>\n<p>Leading python-iterable characters are dropped if they are present from both sides,\nand their python type is ignored:</p>\n<pre>env.tuple(\"VAR_NAME\", \"[123, 4356, 235]\") == (\"123\", \"4356\", \"235\")\nenv.tuple(\"VAR_NAME\", \"(123, 4356, 235)\") == (\"123\", \"4356\", \"235\")\nenv.tuple(\"VAR_NAME\", \"{123, 4356, 235}\") == (\"123\", \"4356\", \"235\")\n</pre>\n</div>\n<div id=\"casting-on-iterables\">\n<h3>Casting on iterables</h3>\n<p>Using any of <tt>env.tuple</tt>, <tt>env.list</tt>, <tt>env.set</tt>, <tt>env.frozenset</tt>,\nor <tt>env.dict</tt> allows each parsed value to be validated and optionally cast,\nwith the caveat that the <em>iterable is homogenous</em> (that is, everything can be\nconverted to an <tt>int</tt> or a <tt>uuid</tt> or whatever)</p>\n<p>Each value may be cast to any of the non-iterable methods documented above, by using\n<tt>env.ensure.methodname</tt> instead of <tt>env.methodname</tt>, for example:</p>\n<pre>env.tuple(\"VAR_NAME\", \"123,4356,235\", converter=env.ensure.int) == (123, 4356, 235)\nenv.set(\"VAR_NAME\", \"123,4356,235\", converter=env.ensure.hex) == {\"123\", \"4356\", \"235\"}\nenv.list(\"VAR_NAME\", \"a@b.com, b@c.com, def@ghi\", env.ensure.email) == ['a@b.com', 'b@c.com', 'def@ghi']\n</pre>\n<p><tt>env.dict</tt> is slightly special in that it has arguments for <tt>key_converter</tt> and <tt>value_converter</tt>\nso that keys can have a different type to values. Both must still be homogenous:</p>\n<pre>env.dict(\"VAR_NAME\", \"a=1, b=2, c=3\", key_converter=env.ensure.hex, value_converter=env.ensure.int) == {'a': 1, 'c': 3, 'b': 2}\n</pre>\n</div>\n</div>\n<div id=\"handling-errors\">\n<h2>Handling errors</h2>\n<p>Failing to successfully convert (or just validate) the value (whether from\nthe environment or from the fallback) immediately halts execution by raising\n<tt>EnvironmentCastError</tt> which is a subclass of <tt>ValueError</tt>.</p>\n<p>Failing to provide a <strong>string</strong> for a default/fallback value will\nraise <tt>EnvironmentDefaultError</tt> which is <em>also</em> a subclass of <tt>ValueError</tt>.</p>\n<p>To catch any <em>anticipated</em> error then, is to:</p>\n<pre>try:\n    ...\nexcept (EnvironmentCastError, EnvironmentDefaultError) as e:\n    ...\n</pre>\n</div>\n<div id=\"checking-for-existence\">\n<h2>Checking for existence</h2>\n<p>To find out if an environment variable is set, <em>regardless of it\u2019s value</em>, you can\nuse normal <tt>in</tt> testing:</p>\n<pre>if \"MY_KEY\" in env:\n    do_something_special()\n</pre>\n<p>which allows you to change behaviour based on seeing certain variables in the\nrunning environment.</p>\n</div>\n<div id=\"tracking-the-requests\">\n<h2>Tracking the requests</h2>\n<p>Every access of an <tt>Environment</tt> (eg: the default <tt>env</tt>) keeps an internal\nlog of the key requested + whether or not it was found and used in the environment.</p>\n<p>These are available under <tt>env.used</tt> and <tt>env.fallbacks</tt> but may be accessed\ntogether by iterating over the <tt>Environment</tt> in question, where each iteration\nwill yield a <tt><span class=\"pre\">3-tuple</span></tt> of:</p>\n<ul>\n<li>environment variable name requested</li>\n<li>the <tt>default</tt> or <em>fallback</em> value</li>\n<li>a <tt>bool</tt> of whether or not the environment variable was used or whether the fallback was. <tt>True</tt> if found in the environment, <tt>False</tt> if the fallback was used.</li>\n</ul>\n<p>For example, to output everything, you might do:</p>\n<pre>from enviable import env, Environment\nimport sys\nenv.int(\"TEST\", \"4\")\nmyenv = Environment({\"TESTING\": \"1\"})\nmyenv.bool(\"TESTING\", \"0\")\nif __name__ == \"__main__\":\n    for env_var_name, env_var_example, was_read_from_env in env:\n        if was_read_from_env is True:\n            sys.stdout.write(\"{} was in the environment\\n\".format(env_var_name))\n        else:\n            sys.stdout.write(\"{} was NOT in the environment, used default value of {}\\n\".format(env_var_name, env_var_example))\n</pre>\n<p>Note that in the above scenario, because <tt>env</tt> and <tt>myenv</tt> are different\ninstances with their own individual tracking, the request for <tt>TESTING</tt> will\nnot output, but <tt>TEST</tt> will.</p>\n</div>\n<div id=\"running-the-tests\">\n<h2>Running the tests</h2>\n<p>Given a copy of the file <tt>enviable.py</tt> you ought to be able to do either of the following:</p>\n<pre>$ python enviable.py\n$ python -m enviable\n</pre>\n<p>and see the output of the various tests I\u2019ve bothered with. If mypy is installed,\nit will also type-check the file.</p>\n</div>\n<div id=\"todo\">\n<h2>TODO</h2>\n<ul>\n<li>More tests</li>\n</ul>\n</div>\n<div id=\"the-license\">\n<h2>The license</h2>\n<p>It\u2019s <a href=\"http://en.wikipedia.org/wiki/BSD_licenses#2-clause_license_.28.22Simplified_BSD_License.22_or_.22FreeBSD_License.22.29\" rel=\"nofollow\">FreeBSD</a>. There\u2019s should be a <tt>LICENSE</tt> file in the root of the repository, and in any archives.</p>\n<hr class=\"docutils\">\n<p>Copyright (c) 2019, Keryn Knight\nAll rights reserved.</p>\n<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>\n<ol>\n<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>\n<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>\n</ol>\n<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>\n</div>\n<hr class=\"docutils\">\n<div id=\"change-history-for-enviable\">\n<h2>Change history for enviable</h2>\n<div id=\"id1\">\n<h3>0.2.2</h3>\n<ul>\n<li>Bugfix: the <tt>typing</tt> module is no longer a hard-dependency, because whilst you have it on py3, you only <em>might</em> have it in a py2 environment. See <a href=\"https://github.com/kezabelle/python-enviable/issues/2\" rel=\"nofollow\">GitHub issue 2</a></li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>0.2.1</h3>\n<ul>\n<li>Feature: Testing if a key exists in the environment can now be done using <tt>\"KEYNAME\" in env</tt></li>\n<li>Bugfix: using <tt>env.one_of(key, <span class=\"pre\">default=\"\",</span> <span class=\"pre\">choices=\"\")</span></tt> without providing a custom converter no longer throws a <tt>TypeError</tt></li>\n<li>Misc: Updated type hints across the module to keep <a href=\"https://mypy.readthedocs.io/en/latest/\" rel=\"nofollow\">mypy</a> happy, and me deeply unhappy.</li>\n<li>Misc: Before executing tests when doing <tt>python <span class=\"pre\">-m</span> enviable</tt>, try and run <a href=\"https://mypy.readthedocs.io/en/latest/\" rel=\"nofollow\">mypy</a></li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.2.0</h3>\n<ul>\n<li>Bugfix: Resolved issue where by default it wasn\u2019t stripping leading/trailing whitespace from incoming strings</li>\n<li>Feature: Added new convienience method <tt>env.one_of(key, <span class=\"pre\">default=\"\",</span> <span class=\"pre\">choices=\"\",</span> converter=None)</tt> for providing a constrainted list of options which are valid.</li>\n<li>Misc: Updated the default converter for iterables to be a <tt>partial</tt></li>\n<li>Bugfix: Resolved issue where <tt>str()</tt> and <tt>repr()</tt> for an <tt>Environment</tt> would leave duplicate values in if the same variable is searched for multiple times with different example/default values.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>0.1.0</h3>\n<ul>\n<li>Initial export</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6872608, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "5acaa68d9dade0731b8acab707dafab0", "sha256": "2d938b1a9cd88297a5efe7251e4aafe0bc4ab68656ae5fb36c4ff16020b57786"}, "downloads": -1, "filename": "enviable-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5acaa68d9dade0731b8acab707dafab0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12044, "upload_time": "2019-12-11T13:10:42", "upload_time_iso_8601": "2019-12-11T13:10:42.634911Z", "url": "https://files.pythonhosted.org/packages/b0/18/376c726d0729e7932fc9abe985686a764a8e6bf9206365305ff82cfc1e38/enviable-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ca97a0538657bfaae235b459c5cfdd24", "sha256": "48bfd7b0eeecf4713065d3b355247ff846e14f7f15f187f6034fcb96465964eb"}, "downloads": -1, "filename": "enviable-0.1.0.tar.gz", "has_sig": false, "md5_digest": "ca97a0538657bfaae235b459c5cfdd24", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14336, "upload_time": "2019-12-11T13:10:45", "upload_time_iso_8601": "2019-12-11T13:10:45.100140Z", "url": "https://files.pythonhosted.org/packages/d9/a6/aa856c6591baf133c6f74d0a9e64b2338a15a11cc84081f2cfdec690dec7/enviable-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "f21669340695d2a7c61f6358b536ec2b", "sha256": "de1e0f27065fbf8a6343b070d4c926bbb323d2c7137fbf49db5d0c589db9552b"}, "downloads": -1, "filename": "enviable-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f21669340695d2a7c61f6358b536ec2b", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 13926, "upload_time": "2019-12-12T12:09:01", "upload_time_iso_8601": "2019-12-12T12:09:01.467884Z", "url": "https://files.pythonhosted.org/packages/7d/8f/fa1a77deff9a8149949ac94b7667d9c6f67da17628a59b69c53035b4bd55/enviable-0.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3b4e1c050a5e6c1108c3d88366665572", "sha256": "cc3a7af9d9fa3442076d1e16d0d38f580cb80428cb450d7eb5ed34b24416d5c2"}, "downloads": -1, "filename": "enviable-0.2.0.tar.gz", "has_sig": false, "md5_digest": "3b4e1c050a5e6c1108c3d88366665572", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18419, "upload_time": "2019-12-12T12:09:03", "upload_time_iso_8601": "2019-12-12T12:09:03.718441Z", "url": "https://files.pythonhosted.org/packages/2d/89/75aceb3c1888e8066580d8b474670a4ae0f78119e6d057bce6d8f454fc28/enviable-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "9dd83b475fd2f2027bd4dedc66a02de4", "sha256": "79386f0d2c8b511c1f371ca2e78deb15c60946fd971fd0522032e4f6f22e2568"}, "downloads": -1, "filename": "enviable-0.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9dd83b475fd2f2027bd4dedc66a02de4", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 14732, "upload_time": "2020-03-16T22:20:30", "upload_time_iso_8601": "2020-03-16T22:20:30.915782Z", "url": "https://files.pythonhosted.org/packages/cc/92/f355c1f8bce9911a2548df0784edcb18f0ba18a10f9802af293854dfbd38/enviable-0.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7bdb934646e0ddd935523beb04306eef", "sha256": "684748637a2377576b26eb41b6775dbbcd3d8c0e0ee15426384a83a26b6d669f"}, "downloads": -1, "filename": "enviable-0.2.1.tar.gz", "has_sig": false, "md5_digest": "7bdb934646e0ddd935523beb04306eef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17588, "upload_time": "2020-03-16T22:20:32", "upload_time_iso_8601": "2020-03-16T22:20:32.500456Z", "url": "https://files.pythonhosted.org/packages/d9/f7/6969313df1ed9c6bdaa06d8b94c567fa80a6c54fcc26e5abb4df85b3f640/enviable-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "2e575ff12ca338ce0487efb8d0e9e18f", "sha256": "dbbb9e42d4cc6cca21da50677519cbc09bc6a789430aa4efd992a97d5f7bbc46"}, "downloads": -1, "filename": "enviable-0.2.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2e575ff12ca338ce0487efb8d0e9e18f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 14838, "upload_time": "2020-03-24T12:19:17", "upload_time_iso_8601": "2020-03-24T12:19:17.333570Z", "url": "https://files.pythonhosted.org/packages/27/f4/46ce009ea90b3baf92c60c3619c635f8c180bc826187f7206cb202340cb3/enviable-0.2.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "aefd1dd8ad203b8c795ba7d938284e65", "sha256": "9d497d78a7629cb69fb2b84a515a74a7eaf95b679ae943c81a51bc621228eae2"}, "downloads": -1, "filename": "enviable-0.2.2.tar.gz", "has_sig": false, "md5_digest": "aefd1dd8ad203b8c795ba7d938284e65", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19900, "upload_time": "2020-03-24T12:19:19", "upload_time_iso_8601": "2020-03-24T12:19:19.002544Z", "url": "https://files.pythonhosted.org/packages/16/2d/798a0f7ae6aa8c602e74422803da3868f93f4d6c722b6ace1f4a4b529634/enviable-0.2.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2e575ff12ca338ce0487efb8d0e9e18f", "sha256": "dbbb9e42d4cc6cca21da50677519cbc09bc6a789430aa4efd992a97d5f7bbc46"}, "downloads": -1, "filename": "enviable-0.2.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2e575ff12ca338ce0487efb8d0e9e18f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 14838, "upload_time": "2020-03-24T12:19:17", "upload_time_iso_8601": "2020-03-24T12:19:17.333570Z", "url": "https://files.pythonhosted.org/packages/27/f4/46ce009ea90b3baf92c60c3619c635f8c180bc826187f7206cb202340cb3/enviable-0.2.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "aefd1dd8ad203b8c795ba7d938284e65", "sha256": "9d497d78a7629cb69fb2b84a515a74a7eaf95b679ae943c81a51bc621228eae2"}, "downloads": -1, "filename": "enviable-0.2.2.tar.gz", "has_sig": false, "md5_digest": "aefd1dd8ad203b8c795ba7d938284e65", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19900, "upload_time": "2020-03-24T12:19:19", "upload_time_iso_8601": "2020-03-24T12:19:19.002544Z", "url": "https://files.pythonhosted.org/packages/16/2d/798a0f7ae6aa8c602e74422803da3868f93f4d6c722b6ace1f4a4b529634/enviable-0.2.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:10 2020"}