{"info": {"author": "Malthe Borch", "author_email": "repoze-dev@lists.repoze.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Programming Language :: Python", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: WSGI", "Topic :: Internet :: WWW/HTTP :: WSGI :: Application"], "description": "Overview\n========\n\nThis package provides a wrapper for ``lxml`` trees which serializes to\nstring on iteration, but otherwise makes the tree available in an\nattribute.\n\nThe primary for this is WSGI middleware which may avoid\nneedless XML parsing and serialization.\n\nUsage\n-----\n\nIt's recommend to use the `lazy` decorator on your application method. This\nallows you to return an lxml tree object, which is then automatically turned\ninto an XMLSerializer.\n\n  >>> from repoze.xmliter import lazy\n  \n  >>> @lazy\n  ... def application(environ, start_response)\n  ...     return some_lxml_tree\n\nYou may provide a serializer function, which will be used when the\nXMLSerializer is eventually iterated over (i.e. when the response is rendered):\n\n  >>> @lazy(serializer=lxml.html.tostring)\n  ... def application(environ, start_response)\n  ...     return some_lxml_tree\n\nMiddleware can use `isinstance` to test if the result is an XML\niterable:\n\n  >>> from repoze.xmliter.serializer import XMLSerializer\n  >>> isinstance(result, XMLSerializer)\n\nIn this case, the middleware can simply access the `tree` attribute of\nthe result.\n\nThere are two convenience methods which can be used to parse a WSGI iterable\nof strings and build an XMLSerializer object, but avoids re-building the\nserializer if the input iterable is already an instance of XMLSerializer:\n\n  >>> from repoze.xmliter.utils import getXMLSerializer\n  >>> result = getXMLSerializer(result)\n\nOr, if you are parsing HTML:\n\n  >>> from repoze.xmliter.utils import getHTMLSerializer\n  >>> result = getHTMLSerializer(result)\n\nIf `result` is not an XMLSerializer, it will be parsed using a feed parser,\nturned into an lxml tree, and wrapped up in an XMLSerializer, which is\nreturned.\n\n\nChangelog\n---------\n\n0.6 - 2014-09-21\n----------------\n\n* Python 3 compatibility\n  [Lennart Regebro]\n\n0.5 - 2012-01-25\n----------------\n\n* Add __len__ to serializer to help WSGI servers.\n  [Laurence]\n\n* Serializer should iter the entire string in one go.\n  [Laurence]\n\n0.4 - 2011-06-16\n----------------\n\n* Ensure trailing space is removed when replacing doctype with empty string.\n  [Laurence]\n\n0.3 - 2011-06-03\n----------------\n\n* Add doctype option to replace doctype on serialization.\n  [Laurence]\n\n0.2 - 2010-09-11\n----------------\n\n* Use document encoding by default. (This fixes test failure on Ubuntu 10.04.)\n  [Laurence]\n\n* Defer to xsl:output settings when serializing an XSLResultTree.\n  [Laurence]\n\n* Turn off pretty printing by default for HTML to avoid affecting rendering on\n  the browser.\n  [Laurence]\n\n0.1 - 2010-04-21 \n----------------\n\n* Initial release", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://www.repoze.org", "keywords": "web middleware xml serialization", "license": "BSD-derived (http://www.repoze.org/LICENSE.txt)", "maintainer": null, "maintainer_email": null, "name": "repoze.xmliter", "package_url": "https://pypi.org/project/repoze.xmliter/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/repoze.xmliter/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://www.repoze.org"}, "release_url": "https://pypi.org/project/repoze.xmliter/0.6/", "requires_dist": null, "requires_python": null, "summary": "Wrapper for ``lxml`` trees which serializes to string upon iteration.", "version": "0.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides a wrapper for <tt>lxml</tt> trees which serializes to\nstring on iteration, but otherwise makes the tree available in an\nattribute.</p>\n<p>The primary for this is WSGI middleware which may avoid\nneedless XML parsing and serialization.</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>It\u2019s recommend to use the <cite>lazy</cite> decorator on your application method. This\nallows you to return an lxml tree object, which is then automatically turned\ninto an XMLSerializer.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from repoze.xmliter import lazy\n</pre>\n<pre>&gt;&gt;&gt; @lazy\n... def application(environ, start_response)\n...     return some_lxml_tree\n</pre>\n</blockquote>\n<p>You may provide a serializer function, which will be used when the\nXMLSerializer is eventually iterated over (i.e. when the response is rendered):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @lazy(serializer=lxml.html.tostring)\n... def application(environ, start_response)\n...     return some_lxml_tree\n</pre>\n</blockquote>\n<p>Middleware can use <cite>isinstance</cite> to test if the result is an XML\niterable:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from repoze.xmliter.serializer import XMLSerializer\n&gt;&gt;&gt; isinstance(result, XMLSerializer)\n</pre>\n</blockquote>\n<p>In this case, the middleware can simply access the <cite>tree</cite> attribute of\nthe result.</p>\n<p>There are two convenience methods which can be used to parse a WSGI iterable\nof strings and build an XMLSerializer object, but avoids re-building the\nserializer if the input iterable is already an instance of XMLSerializer:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from repoze.xmliter.utils import getXMLSerializer\n&gt;&gt;&gt; result = getXMLSerializer(result)\n</pre>\n</blockquote>\n<p>Or, if you are parsing HTML:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from repoze.xmliter.utils import getHTMLSerializer\n&gt;&gt;&gt; result = getHTMLSerializer(result)\n</pre>\n</blockquote>\n<p>If <cite>result</cite> is not an XMLSerializer, it will be parsed using a feed parser,\nturned into an lxml tree, and wrapped up in an XMLSerializer, which is\nreturned.</p>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n</div>\n<div id=\"id1\">\n<h2>0.6 - 2014-09-21</h2>\n<ul>\n<li>Python 3 compatibility\n[Lennart Regebro]</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h2>0.5 - 2012-01-25</h2>\n<ul>\n<li>Add __len__ to serializer to help WSGI servers.\n[Laurence]</li>\n<li>Serializer should iter the entire string in one go.\n[Laurence]</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h2>0.4 - 2011-06-16</h2>\n<ul>\n<li>Ensure trailing space is removed when replacing doctype with empty string.\n[Laurence]</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h2>0.3 - 2011-06-03</h2>\n<ul>\n<li>Add doctype option to replace doctype on serialization.\n[Laurence]</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h2>0.2 - 2010-09-11</h2>\n<ul>\n<li>Use document encoding by default. (This fixes test failure on Ubuntu 10.04.)\n[Laurence]</li>\n<li>Defer to xsl:output settings when serializing an XSLResultTree.\n[Laurence]</li>\n<li>Turn off pretty printing by default for HTML to avoid affecting rendering on\nthe browser.\n[Laurence]</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h2>0.1 - 2010-04-21</h2>\n<ul>\n<li>Initial release</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 1470323, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "93c25dd5cbada2f657387db541fa887e", "sha256": "d4612c0a257aecc21c681999b6780121aaced0bf22d3853ccb28558fc90f2d7f"}, "downloads": -1, "filename": "repoze.xmliter-0.1.zip", "has_sig": false, "md5_digest": "93c25dd5cbada2f657387db541fa887e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13977, "upload_time": "2010-04-21T18:59:00", "upload_time_iso_8601": "2010-04-21T18:59:00.437289Z", "url": "https://files.pythonhosted.org/packages/51/42/4d1c9b92d37c080ecc51c9c6c96cc666e513673851245bff4dc1a7ada9aa/repoze.xmliter-0.1.zip", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "d1cb4c4719b0a70427651105b4975b81", "sha256": "b1b2aa2bb847832b9b9d47201aa7de62ea68aa6e3159e9b024b646198dc398b2"}, "downloads": -1, "filename": "repoze.xmliter-0.2.tar.gz", "has_sig": false, "md5_digest": "d1cb4c4719b0a70427651105b4975b81", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13464, "upload_time": "2010-09-11T19:52:26", "upload_time_iso_8601": "2010-09-11T19:52:26.281126Z", "url": "https://files.pythonhosted.org/packages/09/0c/c8151f9fc5b5a86d15500c34200f0dae68243bcef75b12061261b9a18d6a/repoze.xmliter-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "a337b7e931c8c4a69743bcf7cd677bd9", "sha256": "c8af9515c337fc09cd90466223a16f782b569cdcd5c6bf2c5d07ee0aaa954595"}, "downloads": -1, "filename": "repoze.xmliter-0.3.zip", "has_sig": false, "md5_digest": "a337b7e931c8c4a69743bcf7cd677bd9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21560, "upload_time": "2011-06-03T16:38:01", "upload_time_iso_8601": "2011-06-03T16:38:01.463935Z", "url": "https://files.pythonhosted.org/packages/e4/ff/a798fb9942beb686f3076f7a1283e4237838ddbfdeada1e2811f63d11214/repoze.xmliter-0.3.zip", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "368bb3b82531f04140249c9981697953", "sha256": "5aa391ca9dbd92fd3be2472df2942c13c6d85b382fc7c9f162df47c250571bbb"}, "downloads": -1, "filename": "repoze.xmliter-0.4.zip", "has_sig": false, "md5_digest": "368bb3b82531f04140249c9981697953", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21765, "upload_time": "2011-06-16T16:31:17", "upload_time_iso_8601": "2011-06-16T16:31:17.966877Z", "url": "https://files.pythonhosted.org/packages/52/e5/0896e3ca26642d84f0a2a37177dcac8e045dc2df3c06ddf8db2ce2ec6be4/repoze.xmliter-0.4.zip", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "99da76bcbad6fbaced4a273bde29b10e", "sha256": "f39e15b2bb8f22b04c7ff3670651adf6f53ffa5628deaca83cafaa4b4e135d56"}, "downloads": -1, "filename": "repoze.xmliter-0.5.zip", "has_sig": false, "md5_digest": "99da76bcbad6fbaced4a273bde29b10e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21987, "upload_time": "2012-01-25T19:47:32", "upload_time_iso_8601": "2012-01-25T19:47:32.032355Z", "url": "https://files.pythonhosted.org/packages/6a/e9/e0cf54c33e1edb1327c2158aa0474abc648513a9983dddbd082bd1ba6416/repoze.xmliter-0.5.zip", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "b9e88ad35754f5813870d13dbe89a10b", "sha256": "f139a3ac13ec5c47528d0df5ecf2a1e6344976bb6fc22b302ebb981c2d50eadd"}, "downloads": -1, "filename": "repoze.xmliter-0.6.zip", "has_sig": false, "md5_digest": "b9e88ad35754f5813870d13dbe89a10b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18947, "upload_time": "2014-09-22T02:41:35", "upload_time_iso_8601": "2014-09-22T02:41:35.534996Z", "url": "https://files.pythonhosted.org/packages/bd/e4/9ce7f507d0b765b12b4407b7ae339c1534b43058f714cc4ae8bd6a7eb403/repoze.xmliter-0.6.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b9e88ad35754f5813870d13dbe89a10b", "sha256": "f139a3ac13ec5c47528d0df5ecf2a1e6344976bb6fc22b302ebb981c2d50eadd"}, "downloads": -1, "filename": "repoze.xmliter-0.6.zip", "has_sig": false, "md5_digest": "b9e88ad35754f5813870d13dbe89a10b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18947, "upload_time": "2014-09-22T02:41:35", "upload_time_iso_8601": "2014-09-22T02:41:35.534996Z", "url": "https://files.pythonhosted.org/packages/bd/e4/9ce7f507d0b765b12b4407b7ae339c1534b43058f714cc4ae8bd6a7eb403/repoze.xmliter-0.6.zip", "yanked": false}], "timestamp": "Fri May  8 03:04:22 2020"}