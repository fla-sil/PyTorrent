{"info": {"author": "Virgile Daug\u00e9", "author_email": "virgile.dauge@loria.fr", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License (GPL)", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX", "Programming Language :: Python :: 3.6"], "description": "#+title: Utility lib for naps\n#+author: Virgile Daug\u00e9\n#+EMAIL:virgile.dauge@loria.fr\n\nParam\u00e8tre d'export de code :\n#+begin_src emacs-lisp :tangle no :results silent\n(setq org-src-preserve-indentation t)\n#+end_src\n\n\n* Construction du Module\n\n#+begin_src python :tangle setup.py\n# -*- coding: utf-8 -*-\n\nfrom setuptools import setup, find_packages\n\nwith open('readme.org', 'r') as fh:\n    long_description = fh.read()\n\nsetup(\n    name='naps_utilities',\n    packages=find_packages(exclude=[\"examples/*\"]),\n    version='0.2.0',\n    description='Lib to handle ease of use of pointclouds ',\n    author=u'Virgile Daug\u00e9',\n    author_email='virgile.dauge@loria.fr',\n    url='https://github.com/virgileTN/naps_utilities',\n    keywords=['pointclouds', 'filtering'],\n    install_requires=['numpy',\n                      'numpy-quaternion'],\n    long_description=long_description,\n    long_description_content_type='text/plain',\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Environment :: Console',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: GNU General Public License (GPL)',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: POSIX',\n        'Programming Language :: Python :: 3.6',\n        ],\n)\n#+end_src\n\n#+begin_src bash :results value verbatim :exports both\nmkdir naps_utilities\ntouch naps_utilities/__init__.py\n#+end_src\n\n* Classe transform\n\n** Mise \u00e0 dispo de la classe\n\n#+begin_src python :tangle naps_utilities/__init__.py\nfrom .transform import Transform\n#+end_src\n\n** Imports\n\n#+begin_src python :tangle naps_utilities/pointcloud.py\nclass MultipleInputData(Exception):\n   \"\"\"Raised when data used to populate is not valid\"\"\"\n   pass\n#+end_src\n\n#+begin_src python :tangle naps_utilities/transform.py\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport numpy as np\nimport quaternion\nimport math\n\nfrom geometry_msgs.msg import TransformStamped\n\n#+end_src\n\n** Corps de la fonction\n#+begin_src python :tangle naps_utilities/transform.py\nclass Transform:\n    # self.matrix = None  # matrix de transfo\n\n    # Constructeur\n    def __init__(self, mat=None, quat=None, pos=None, ros_msg=None):\n        u\"\"\" Constructeur depuis une matrice OU un quaternion et une position.\"\"\"\n\n        # Ensure that only one populate method is selected:\n        conditions = [mat is not None, quat is not None and pos is not None, ros_msg is not None]\n        if sum(conditions) > 1:\n            raise MultipleInputData\n\n        if mat is not None:\n            self.matrix = np.copy(mat)\n\n        elif quat is not None and pos is not None:\n            self.from_quatpos(quat, pos)\n\n        elif ros_msg is not None:\n            self.from_msg(ros_msg)\n\n        else:\n            self.matrix = np.identity(4)\n\n#+end_src\n\n** Fonction de peuplement\n#+begin_src python :tangle naps_utilities/transform.py\n    def from_quatpos(self, quat, pos):\n        self.matrix = np.identity(4)\n        # (w, x, y, z)\n        quat = np.asarray(quat)\n        npquat = quaternion.quaternion(quat[0], quat[1],\n                                       quat[2], quat[3])\n        self.matrix[:3, :3] = quaternion.as_rotation_matrix(npquat)\n        self.matrix[:3, 3] = pos\n#+end_src\n\n#+begin_src python :tangle naps_utilities/transform.py\n    def from_msg(self, msg):\n        self.from_quatpos(pos=[\n            msg.transform.translation.x,\n            msg.transform.translation.y,\n            msg.transform.translation.z,\n        ], quat=[\n            msg.transform.rotation.w,\n            msg.transform.rotation.x,\n            msg.transform.rotation.y,\n            msg.transform.rotation.z,\n        ])\n#+end_src\n\n** Vers ROS msg\n#+begin_src python :tangle naps_utilities/transform.py\n    def to_msg(self, child_frame_id, frame_id='map'):\n        msg = TransformStamped()\n        quaternion = self.quaternion()\n        position = self.position()\n        msg.header.frame_id = frame_id\n        msg.child_frame_id = child_frame_id\n        msg.transform.translation.x = position[0]\n        msg.transform.translation.y = position[1]\n        msg.transform.translation.z = position[2]\n        msg.transform.rotation.x = quaternion.x\n        msg.transform.rotation.y = quaternion.y\n        msg.transform.rotation.z = quaternion.z\n        msg.transform.rotation.w = quaternion.w\n        return msg\n#+end_src\n\n** Fcontions internes\nFonctions d'affichage\n#+begin_src python :tangle naps_utilities/transform.py\n    def __str__(self):\n        u\"\"\"Affichage de la transformation.\"\"\"\n        return self.matrix.__str__()\n\n    def __repr__(self):\n        u\"\"\"Repr\u00e9sentation interne de la classe.\"\"\"\n        return self.matrix.__repr__()\n\n#+end_src\n\nConversion quaternion vers matrice de rotation, ici on utilise le\nmodule numpy-quaternion.\n#+begin_src python :tangle naps_utilities/transform.py\n    def quat_2_mat(self, quat, pos):\n        u\"\"\"Conversion quaternion vers matrix.\"\"\"\n        self.matrix[:3, :3] = quaternion.as_rotation_matrix(quat)\n        self.matrix[:3, 3] = pos\n#+end_src\n\nOp\u00e9rations sur la matrice de tranformation :\n#+begin_src python :tangle naps_utilities/transform.py\n    def inverse(self):\n        u\"\"\"Inverse de la transformation.\"\"\"\n        return Transform(np.linalg.inv(self.matrix))\n\n    def __invert__(self):\n        u\"\"\"Inverse de la transformation inplace.\"\"\"\n        return Transform(np.linalg.inv(self.matrix))\n\n    def __sub__(self, other):\n        u\"\"\"Renvoie la transformation dans self du rep\u00e8re \u00e0 l'origine de la transformation other.\"\"\"\n        return self.composition(~other)\n\n    def __isub__(self, other):\n        u\"\"\"Version 'inplace' de sub.\"\"\"\n        self = self.composition(~other)\n        return self\n\n    def composition(self, tr):\n        u\"\"\"Composition de transformations.\"\"\"\n        return Transform(mat=np.dot(self.matrix, tr.matrix))\n\n    def __mul__(self, other):\n        u\"\"\"Composition de la transformation de other dans self.\"\"\"\n        return self.composition(other)\n\n    def __imul__(self, other):\n        u\"\"\"\"Version 'inplace' de mul.\"\"\"\n        self.matrix = self.matrix.dot(other.matrix)\n        return self\n\n    def relative_transform(self, other):\n        u\"\"\"Transformation de self dans le rep\u00e8re other.\"\"\"\n        return ~other.composition(self)\n\n    def projection(self, pt):\n        u\"\"\"Transformation d'un point.\"\"\"\n        if (len(pt) == 3):\n            return self.matrix.dot(pt + [1])\n        else:\n            return self.matrix.dot(pt)\n\n#+end_src\n\nAcc\u00e8s \u00e0 la position et au quaternion ind\u00e9pendamment :\n#+begin_src python :tangle naps_utilities/transform.py\n    def position(self):\n        u\"\"\"Extraction de la position depuis matrix.\"\"\"\n        return self.matrix[:3, 3]\n\n    def quaternion(self):\n        u\"\"\"Extraction du quaternion depuis matrix.\"\"\"\n        return quaternion.from_rotation_matrix(self.matrix)\n#+end_src\n\n** Tests\n\n#+begin_src ipython :session testTransform :file  :exports both\nfrom naps_utilities import Transform\nt = Transform(pos=[1,2,3], quat=[1,0,0,0])\nt\n#+end_src\n\n#+RESULTS:\n: # Out[3]:\n: #+BEGIN_EXAMPLE\n:   array([[1., 0., 0., 1.],\n:   [0., 1., 0., 2.],\n:   [0., 0., 1., 3.],\n:   [0., 0., 0., 1.]])\n: #+END_EXAMPLE\n\n#+begin_src ipython :session testTransform :file  :exports both\nt.to_msg('truc')\n#+end_src\n\n#+RESULTS:\n: # Out[5]:\n: : geometry_msgs.msg.TransformStamped(header=std_msgs.msg.Header(stamp=builtin_interfaces.msg.Time(sec=0, nanosec=0), frame_id='map'), child_frame_id='truc', transform=geometry_msgs.msg.Transform(translation=geometry_msgs.msg.Vector3(x=1.0, y=2.0, z=3.0), rotation=geometry_msgs.msg.Quaternion(x=-0.0, y=-0.0, z=-0.0, w=1.0)))\n\n* Classe Pointcloud\n** Mise \u00e0 dispo de la classe\n\n#+begin_src python :tangle naps_utilities/__init__.py\nfrom .pointcloud import Pointcloud\n#+end_src\n** Dependences\n\n#+begin_src python :tangle naps_utilities/pointcloud.py\n# N\u00e9cessaires pour la lecture/\u00e9criture de fichiers\nimport os\nimport json\nimport pickle\n\n#Les donn\u00e9es sont stock\u00e9es sous forme de numpy ndarray\nimport numpy as np\n\n#N\u00e9cessaire pour la conversion vers/depuis ROS2\nfrom builtin_interfaces.msg import Time\nfrom sensor_msgs.msg import PointCloud2\nfrom sensor_msgs.msg import PointField\nfrom std_msgs.msg import Header\nfrom array import array\n#+end_src\n\n#+begin_src python :tangle naps_utilities/pointcloud.py\nclass TransformWhileEmpty(Exception):\n   \"\"\"Raised when transform method is called and the poincloud is not yet\n   populated\"\"\"\n   pass\n#+end_src\n\n#+begin_src python :tangle naps_utilities/pointcloud.py\nclass InvalidInputData(Exception):\n   \"\"\"Raised when data used to populate is not valid\"\"\"\n   pass\n#+end_src\n\n#+begin_src python :tangle naps_utilities/pointcloud.py\nclass MultipleInputData(Exception):\n   \"\"\"Raised when data used to populate is not valid\"\"\"\n   pass\n#+end_src\n** Corps de la classe\n#+begin_src python :tangle naps_utilities/pointcloud.py\nclass Pointcloud():\n    def __init__(self, ros_msg=None, points=None, keep_ring=True,\n               matrix=None, procrastinate=False, inpath=None):\n        # PoinCloud Metadata\n        self.metadata = {'header': None,\n                         'height': None,\n                         'width': None,\n                         'fields': None,\n                         'is_bigendian': None,\n                         'point_step': None,\n                         'row_step': None,\n                         'is_dense': None,\n                         'keep_ring': None,\n                         'is_populated': False,\n                         'procrastinated': True,}\n        # Pointcloud DATA\n        self.points = None\n        self.rings = None\n        self.matrix = matrix\n\n        # Ensure that only one populate method is selected:\n        conditions = [ros_msg is not None, points is not None, inpath is not None]\n\n        if sum(conditions) > 1:\n            raise MultipleInputData\n\n        else:\n            if ros_msg is not None:\n                self.from_msg(ros_msg)\n\n            elif points is not None:\n                self.from_list(points)\n\n            elif inpath is not None:\n                self.load(inpath)\n\n            if self.metadata['is_populated']:\n                if not procrastinate:\n                    self.filter()\n                    if matrix is None:\n                        self.matrix = np.identity(4)\n                        self.metadata['procrastinated'] = False\n                    else:\n                        self.transform(matrix)\n#+end_src\n** Populate from list\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def from_list(self, data):\n        self.metadata['keep_ring'] = False\n\n        self.points = np.ascontiguousarray(data, dtype=np.float32)\n        if self.points.shape[1] != 3 and self.points.shape[1] != 4:\n            raise InvalidInputData\n\n        self.metadata['nb_points'] = len(self.points)\n        self.metadata['height'] = 1\n        self.metadata['width'] = self.metadata['nb_points']\n\n        self.metadata['is_bigendian'] = False\n        self.metadata['point_step'] = 3 * 4\n        self.metadata['row_step'] = self.metadata['point_step']\n\n        self.metadata['is_dense'] = False\n\n        self.metadata['is_populated'] = True\n#+end_src\n** populate from ROS msg\nUn certain nombre de donn\u00e9es ne n\u00e9cessitent pas de conversion :\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def from_msg(self, msg):\n        #Donn\u00e9es conserv\u00e9es \"telles quelles\"\n\n        self.metadata['height'] = msg.height\n        self.metadata['width'] = msg.width\n\n        self.metadata['is_bigendian'] = msg.is_bigendian\n        self.metadata['point_step'] = msg.point_step\n        self.metadata['row_step'] = msg.row_step\n\n        self.metadata['is_dense'] = msg.is_dense\n#+end_src\nL'atribut Header est du type std_msgs/Header:\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        def from_header(header):\n            return {'time': {'sec': header.stamp.sec, 'nanosec': header.stamp.nanosec},\n               'frame_id': header.frame_id}\n        self.metadata['header'] = from_header(msg.header)\n#+end_src\nL'attribut fields du msg ROS est une liste d'objets PointFields.  Il\nconvient \u00e9galement de supprimer le fields ring, si l'on choisit de ne\npas les garder.\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        def from_pointfields(fields):\n            return [{'name': field.name,\n                'offset': field.offset,\n                'datatype': field.datatype,\n                'count': field.count}\n               for field in fields]\n\n        self.metadata['fields'] = from_pointfields(msg.fields)\n#+end_src\nAfin de pr\u00e9parer l'extraction, on initialise des numpy ndarray afin\nque tous les points soient dans un espace contigu de la m\u00e9moire. Ici\non s\u00e9pare les points en un tableau de float32 (x, y, z) et un tableau\nde (ring). Cela pour faciliter l'encodage d\u00e9codage (c'est plus\ndifficile avec des types diff\u00e9rents imbriqu\u00e9s)\n\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        # Donn\u00e9es converties\n        self.metadata['nb_points'] = msg.height * msg.width\n\n        data = np.reshape(msg.data, (-1, self.metadata['point_step']))\n\n        self.points = np.ndarray(\n            (self.metadata['nb_points'], 4), dtype=np.float32,\n            buffer=np.ascontiguousarray(data[:, :16]))\n\n        if self.metadata['keep_ring']:\n            self.metadata['rings'] = np.zeros(\n                self.metadata['nb_points'], dtype=np.uint16)\n\n            pointcloud['rings'] = np.ndarray(\n                (self.metadata['nb_points']), dtype=np.uint16,\n                buffer=np.ascontiguousarray(data[:, 16:]))\n#+end_src\nMise \u00e0 jour d\u00e9 m\u00e9tadonn\u00e9es si n\u00e9cessaire :\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        if not self.metadata['keep_ring']:\n            self.metadata['fields'] = [field for field in self.metadata['fields'] if field['name'] != 'ring']\n            self.metadata['point_step'] = 16\n            self.metadata['row_step'] = self.metadata['point_step'] * len(self.metadata['fields'])\n            self.metadata['is_populated'] = True\n#+end_src\n** convert to msg\nBeaucoup de sym\u00e9trie avec la fonction pr\u00e9cedante.\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def to_msg(self):\n        msg = PointCloud2()\n        #Donn\u00e9es conserv\u00e9es \"telles quelles\"\n\n        msg.height = self.metadata['height']\n        msg.width = self.metadata['width']\n\n        msg.is_bigendian = self.metadata['is_bigendian']\n        msg.point_step = self.metadata['point_step']\n        msg.row_step = self.metadata['row_step']\n\n        msg.is_dense = self.metadata['is_dense']\n#+end_src\n\nConversion vers Header ROS:\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        def to_header(header_data):\n            return Header(stamp=Time(\n                sec=header_data['time']['sec'],\n                nanosec=header_data['time']['nanosec']),\n                     frame_id=header_data['frame_id'])\n        msg.header = to_header(self.metadata['header'])\n#+end_src\nConversion vers Pointfield:\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        def to_pointfields(pointfields_data):\n            return [PointField(name=field['name'],\n                          offset=field['offset'],\n                          datatype=field['datatype'],\n                          count=field['count']) for field in pointfields_data]\n        msg.fields = to_pointfields(self.metadata['fields'])\n#+end_src\nDeux cas, selon la valeur de 'keep_ring':\n\nSi on garde les rings, il faut concatener les deux tableaux et en\nfaire un array de uint8.\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        if self.metadata['keep_ring']:\n            msg.data = array('B', np.concatenate(\n            (self.points.view(dtype=np.uint8),\n             self.rings.reshape((self.metadata['nb_points'], -1)).view(dtype=np.uint8)),\n            axis=1).ravel().tolist())\n#+end_src\nSinon, il suffi de cr\u00e9er une liste de uint8 \u00e0 partir des points au\nniveau des donn\u00e9es.\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        else:\n            msg.data = array('B', self.points.view(dtype=np.uint8).ravel().tolist())\n        return msg\n#+end_src\n** filter pointcloud\n\nIl y a deux cas a traiter, si l'on garde les rings auquel cas il faut\nles filter aussi.\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def filter(self, threshold=10):\n        if self.metadata['keep_ring']:\n            concat = np.concatenate((self.points, self.rings.reshape((len(points), 1))), axis=1)\n            concat = concat[np.logical_and(\n                np.logical_not(np.isnan(concat).any(axis=1)),\n                concat[:,3]>=threshold)]\n            self.points = np.ascontiguousarray(concat[:,:4], dtype=np.float32)\n            self.rings = np.ascontiguousarray(concat[:,4:], dtype=np.uint16)\n#+end_src\nApr\u00e8s avoir \u00e9t\u00e9 filtr\u00e9, le poincloud ne peut plus \u00eatre structur\u00e9 dans\nun tableau 2D.\n#+begin_src python :tangle naps_utilities/pointcloud.py\n        else:\n            self.points = self.points[np.logical_and(\n                np.logical_not(np.isnan(self.points).any(axis=1)),\n                self.points[:,3]>=threshold)]\n        self.metadata['nb_points'] = len(self.points)\n        self.metadata['height'] = 1\n        self.metadata['width'] = self.metadata['nb_points']\n#+end_src\n\n** transform pointcloud\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def transform(self, matrix):\n        if self.metadata['is_populated']:\n            self.points[:,:3] = np.transpose(\n                matrix @ np.concatenate((self.points[:,:3].transpose(),\n                                         np.ones((1, self.metadata['nb_points'])))))[:,:3]\n            self.matrix = matrix\n            self.metadata['procrastinated'] = False\n        else:\n            raise TransformWhileEmpty(\"Populate pointcloud before applying transform to it\")\n#+end_src\n** add points\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def update(self, pointcloud):\n        if self.metadata['keep_ring']:\n            if pointcloud.metadata['keep_ring']:\n                self.rings = np.ascontiguousarray(np.concatenate((self.rings, pointcloud.rings)))\n            else:\n                return False\n        self.points = np.ascontiguousarray(np.concatenate((self.points, pointcloud.points)))\n        self.metadata['nb_points'] = len(self.points)\n        self.metadata['height'] = 1\n        self.metadata['width'] = self.metadata['nb_points']\n        return True\n#+end_src\n\n** Export/Import\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def save(self, path):\n        self.save_npz(path)\n#+end_src\n*** npz\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def save_npz(self, path):\n        save_path = os.path.expanduser(path)\n        # with open('{}_meta.json'.format(save_path), 'w') as outfile:\n        #     json.dump(self.metadata, outfile, indent=4)\n\n        np.savez_compressed('{}'.format(save_path), meta=[self.metadata], points=self.points, rings=self.rings, matrix=self.matrix)\n#+end_src\n\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def load(self, path):\n        load_path = os.path.expanduser(path)\n        # with open('{}_meta.json'.format(load_path), 'r') as infile:\n        #     self.metadata = json.load(infile)\n\n        with np.load(load_path, allow_pickle=True) as data:\n            self.metadata = data['meta'][0]\n            if 'matrix' in data:\n                self.matrix = data['matrix']\n            if 'points' in data:\n                self.points = data['points']\n            if 'rings' in data:\n                self.rings = data['rings']\n#+end_src\n*** xyz\n#+begin_src python :tangle naps_utilities/pointcloud.py\n    def save_xyz(self, path):\n        save_path = os.path.expanduser(path)\n        np.savetxt('{}.xyz'.format(save_path), self.points)\n        #with open('{}.xyz'.format(save_path), 'w') as outfile:\n        #     json.dump(self.metadata, outfile, indent=4)\n#+end_src\n\n* Tests\n#+begin_src ipython :session session01 :file  :exports both\nimport numpy as np\nfrom naps_utilities import Pointcloud\npoints = [[0, 0, 0, 4],\n          [1, 0, 0, 5],\n          [0, 1, 0, 105],\n          [0, 0, 1, 452],]\np = Pointcloud(points=points)\n#+end_src\n\n#+RESULTS:\n: # Out[9]:\n\n#+begin_src ipython :session session01 :file  :exports both\np = Pointcloud(points=points)\n#+end_src\n* Build et distribution\n#+begin_src bash :results value verbatim :exports both\npython setup.py bdist_wheel sdist\n#+end_src\n\n#+RESULTS:\n#+begin_example\nrunning bdist_wheel\nrunning build\nrunning build_py\ninstalling to build/bdist.linux-x86_64/wheel\nrunning install\nrunning install_lib\ncreating build/bdist.linux-x86_64/wheel\ncreating build/bdist.linux-x86_64/wheel/naps_utilities\ncopying build/lib/naps_utilities/pointcloud.py -> build/bdist.linux-x86_64/wheel/naps_utilities\ncopying build/lib/naps_utilities/__init__.py -> build/bdist.linux-x86_64/wheel/naps_utilities\nrunning install_egg_info\nrunning egg_info\nwriting naps_utilities.egg-info/PKG-INFO\nwriting dependency_links to naps_utilities.egg-info/dependency_links.txt\nwriting requirements to naps_utilities.egg-info/requires.txt\nwriting top-level names to naps_utilities.egg-info/top_level.txt\nreading manifest file 'naps_utilities.egg-info/SOURCES.txt'\nwriting manifest file 'naps_utilities.egg-info/SOURCES.txt'\nCopying naps_utilities.egg-info to build/bdist.linux-x86_64/wheel/naps_utilities-0.1.1-py3.7.egg-info\nrunning install_scripts\ncreating build/bdist.linux-x86_64/wheel/naps_utilities-0.1.1.dist-info/WHEEL\ncreating 'dist/naps_utilities-0.1.1-py3-none-any.whl' and adding 'build/bdist.linux-x86_64/wheel' to it\nadding 'naps_utilities/__init__.py'\nadding 'naps_utilities/pointcloud.py'\nadding 'naps_utilities-0.1.1.dist-info/METADATA'\nadding 'naps_utilities-0.1.1.dist-info/WHEEL'\nadding 'naps_utilities-0.1.1.dist-info/top_level.txt'\nadding 'naps_utilities-0.1.1.dist-info/RECORD'\nremoving build/bdist.linux-x86_64/wheel\nrunning sdist\nrunning check\ncreating naps_utilities-0.1.1\ncreating naps_utilities-0.1.1/naps_utilities\ncreating naps_utilities-0.1.1/naps_utilities.egg-info\ncopying files to naps_utilities-0.1.1...\ncopying setup.py -> naps_utilities-0.1.1\ncopying naps_utilities/__init__.py -> naps_utilities-0.1.1/naps_utilities\ncopying naps_utilities/pointcloud.py -> naps_utilities-0.1.1/naps_utilities\ncopying naps_utilities.egg-info/PKG-INFO -> naps_utilities-0.1.1/naps_utilities.egg-info\ncopying naps_utilities.egg-info/SOURCES.txt -> naps_utilities-0.1.1/naps_utilities.egg-info\ncopying naps_utilities.egg-info/dependency_links.txt -> naps_utilities-0.1.1/naps_utilities.egg-info\ncopying naps_utilities.egg-info/requires.txt -> naps_utilities-0.1.1/naps_utilities.egg-info\ncopying naps_utilities.egg-info/top_level.txt -> naps_utilities-0.1.1/naps_utilities.egg-info\nWriting naps_utilities-0.1.1/setup.cfg\nCreating tar archive\nremoving 'naps_utilities-0.1.1' (and everything under it)\n#+end_example\n\n\n#+begin_src bash :results value verbatim :exports both\ntwine upload dist/*\n#+end_src\n\n#+RESULTS:\n\n\n", "description_content_type": "text/plain", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/virgileTN/naps_utilities", "keywords": "pointclouds,filtering", "license": "", "maintainer": "", "maintainer_email": "", "name": "naps-utilities", "package_url": "https://pypi.org/project/naps-utilities/", "platform": "", "project_url": "https://pypi.org/project/naps-utilities/", "project_urls": {"Homepage": "https://github.com/virgileTN/naps_utilities"}, "release_url": "https://pypi.org/project/naps-utilities/0.2.0/", "requires_dist": ["numpy", "numpy-quaternion"], "requires_python": "", "summary": "Lib to handle ease of use of pointclouds", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            #+title: Utility lib for naps<br>#+author: Virgile Daug\u00e9<br>#+EMAIL:virgile.dauge@loria.fr<br><br>Param\u00e8tre d'export de code :<br>#+begin_src emacs-lisp :tangle no :results silent<br>(setq org-src-preserve-indentation t)<br>#+end_src<br><br><br>* Construction du Module<br><br>#+begin_src python :tangle setup.py<br># -*- coding: utf-8 -*-<br><br>from setuptools import setup, find_packages<br><br>with open('readme.org', 'r') as fh:<br>    long_description = fh.read()<br><br>setup(<br>    name='naps_utilities',<br>    packages=find_packages(exclude=[\"examples/*\"]),<br>    version='0.2.0',<br>    description='Lib to handle ease of use of pointclouds ',<br>    author=u'Virgile Daug\u00e9',<br>    author_email='virgile.dauge@loria.fr',<br>    url='https://github.com/virgileTN/naps_utilities',<br>    keywords=['pointclouds', 'filtering'],<br>    install_requires=['numpy',<br>                      'numpy-quaternion'],<br>    long_description=long_description,<br>    long_description_content_type='text/plain',<br>    classifiers=[<br>        'Development Status :: 4 - Beta',<br>        'Environment :: Console',<br>        'Intended Audience :: Developers',<br>        'License :: OSI Approved :: GNU General Public License (GPL)',<br>        'Operating System :: MacOS :: MacOS X',<br>        'Operating System :: POSIX',<br>        'Programming Language :: Python :: 3.6',<br>        ],<br>)<br>#+end_src<br><br>#+begin_src bash :results value verbatim :exports both<br>mkdir naps_utilities<br>touch naps_utilities/__init__.py<br>#+end_src<br><br>* Classe transform<br><br>** Mise \u00e0 dispo de la classe<br><br>#+begin_src python :tangle naps_utilities/__init__.py<br>from .transform import Transform<br>#+end_src<br><br>** Imports<br><br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>class MultipleInputData(Exception):<br>   \"\"\"Raised when data used to populate is not valid\"\"\"<br>   pass<br>#+end_src<br><br>#+begin_src python :tangle naps_utilities/transform.py<br>#!/usr/bin/python<br># -*- coding: utf-8 -*-<br><br>import numpy as np<br>import quaternion<br>import math<br><br>from geometry_msgs.msg import TransformStamped<br><br>#+end_src<br><br>** Corps de la fonction<br>#+begin_src python :tangle naps_utilities/transform.py<br>class Transform:<br>    # self.matrix = None  # matrix de transfo<br><br>    # Constructeur<br>    def __init__(self, mat=None, quat=None, pos=None, ros_msg=None):<br>        u\"\"\" Constructeur depuis une matrice OU un quaternion et une position.\"\"\"<br><br>        # Ensure that only one populate method is selected:<br>        conditions = [mat is not None, quat is not None and pos is not None, ros_msg is not None]<br>        if sum(conditions) &gt; 1:<br>            raise MultipleInputData<br><br>        if mat is not None:<br>            self.matrix = np.copy(mat)<br><br>        elif quat is not None and pos is not None:<br>            self.from_quatpos(quat, pos)<br><br>        elif ros_msg is not None:<br>            self.from_msg(ros_msg)<br><br>        else:<br>            self.matrix = np.identity(4)<br><br>#+end_src<br><br>** Fonction de peuplement<br>#+begin_src python :tangle naps_utilities/transform.py<br>    def from_quatpos(self, quat, pos):<br>        self.matrix = np.identity(4)<br>        # (w, x, y, z)<br>        quat = np.asarray(quat)<br>        npquat = quaternion.quaternion(quat[0], quat[1],<br>                                       quat[2], quat[3])<br>        self.matrix[:3, :3] = quaternion.as_rotation_matrix(npquat)<br>        self.matrix[:3, 3] = pos<br>#+end_src<br><br>#+begin_src python :tangle naps_utilities/transform.py<br>    def from_msg(self, msg):<br>        self.from_quatpos(pos=[<br>            msg.transform.translation.x,<br>            msg.transform.translation.y,<br>            msg.transform.translation.z,<br>        ], quat=[<br>            msg.transform.rotation.w,<br>            msg.transform.rotation.x,<br>            msg.transform.rotation.y,<br>            msg.transform.rotation.z,<br>        ])<br>#+end_src<br><br>** Vers ROS msg<br>#+begin_src python :tangle naps_utilities/transform.py<br>    def to_msg(self, child_frame_id, frame_id='map'):<br>        msg = TransformStamped()<br>        quaternion = self.quaternion()<br>        position = self.position()<br>        msg.header.frame_id = frame_id<br>        msg.child_frame_id = child_frame_id<br>        msg.transform.translation.x = position[0]<br>        msg.transform.translation.y = position[1]<br>        msg.transform.translation.z = position[2]<br>        msg.transform.rotation.x = quaternion.x<br>        msg.transform.rotation.y = quaternion.y<br>        msg.transform.rotation.z = quaternion.z<br>        msg.transform.rotation.w = quaternion.w<br>        return msg<br>#+end_src<br><br>** Fcontions internes<br>Fonctions d'affichage<br>#+begin_src python :tangle naps_utilities/transform.py<br>    def __str__(self):<br>        u\"\"\"Affichage de la transformation.\"\"\"<br>        return self.matrix.__str__()<br><br>    def __repr__(self):<br>        u\"\"\"Repr\u00e9sentation interne de la classe.\"\"\"<br>        return self.matrix.__repr__()<br><br>#+end_src<br><br>Conversion quaternion vers matrice de rotation, ici on utilise le<br>module numpy-quaternion.<br>#+begin_src python :tangle naps_utilities/transform.py<br>    def quat_2_mat(self, quat, pos):<br>        u\"\"\"Conversion quaternion vers matrix.\"\"\"<br>        self.matrix[:3, :3] = quaternion.as_rotation_matrix(quat)<br>        self.matrix[:3, 3] = pos<br>#+end_src<br><br>Op\u00e9rations sur la matrice de tranformation :<br>#+begin_src python :tangle naps_utilities/transform.py<br>    def inverse(self):<br>        u\"\"\"Inverse de la transformation.\"\"\"<br>        return Transform(np.linalg.inv(self.matrix))<br><br>    def __invert__(self):<br>        u\"\"\"Inverse de la transformation inplace.\"\"\"<br>        return Transform(np.linalg.inv(self.matrix))<br><br>    def __sub__(self, other):<br>        u\"\"\"Renvoie la transformation dans self du rep\u00e8re \u00e0 l'origine de la transformation other.\"\"\"<br>        return self.composition(~other)<br><br>    def __isub__(self, other):<br>        u\"\"\"Version 'inplace' de sub.\"\"\"<br>        self = self.composition(~other)<br>        return self<br><br>    def composition(self, tr):<br>        u\"\"\"Composition de transformations.\"\"\"<br>        return Transform(mat=np.dot(self.matrix, tr.matrix))<br><br>    def __mul__(self, other):<br>        u\"\"\"Composition de la transformation de other dans self.\"\"\"<br>        return self.composition(other)<br><br>    def __imul__(self, other):<br>        u\"\"\"\"Version 'inplace' de mul.\"\"\"<br>        self.matrix = self.matrix.dot(other.matrix)<br>        return self<br><br>    def relative_transform(self, other):<br>        u\"\"\"Transformation de self dans le rep\u00e8re other.\"\"\"<br>        return ~other.composition(self)<br><br>    def projection(self, pt):<br>        u\"\"\"Transformation d'un point.\"\"\"<br>        if (len(pt) == 3):<br>            return self.matrix.dot(pt + [1])<br>        else:<br>            return self.matrix.dot(pt)<br><br>#+end_src<br><br>Acc\u00e8s \u00e0 la position et au quaternion ind\u00e9pendamment :<br>#+begin_src python :tangle naps_utilities/transform.py<br>    def position(self):<br>        u\"\"\"Extraction de la position depuis matrix.\"\"\"<br>        return self.matrix[:3, 3]<br><br>    def quaternion(self):<br>        u\"\"\"Extraction du quaternion depuis matrix.\"\"\"<br>        return quaternion.from_rotation_matrix(self.matrix)<br>#+end_src<br><br>** Tests<br><br>#+begin_src ipython :session testTransform :file  :exports both<br>from naps_utilities import Transform<br>t = Transform(pos=[1,2,3], quat=[1,0,0,0])<br>t<br>#+end_src<br><br>#+RESULTS:<br>: # Out[3]:<br>: #+BEGIN_EXAMPLE<br>:   array([[1., 0., 0., 1.],<br>:   [0., 1., 0., 2.],<br>:   [0., 0., 1., 3.],<br>:   [0., 0., 0., 1.]])<br>: #+END_EXAMPLE<br><br>#+begin_src ipython :session testTransform :file  :exports both<br>t.to_msg('truc')<br>#+end_src<br><br>#+RESULTS:<br>: # Out[5]:<br>: : geometry_msgs.msg.TransformStamped(header=std_msgs.msg.Header(stamp=builtin_interfaces.msg.Time(sec=0, nanosec=0), frame_id='map'), child_frame_id='truc', transform=geometry_msgs.msg.Transform(translation=geometry_msgs.msg.Vector3(x=1.0, y=2.0, z=3.0), rotation=geometry_msgs.msg.Quaternion(x=-0.0, y=-0.0, z=-0.0, w=1.0)))<br><br>* Classe Pointcloud<br>** Mise \u00e0 dispo de la classe<br><br>#+begin_src python :tangle naps_utilities/__init__.py<br>from .pointcloud import Pointcloud<br>#+end_src<br>** Dependences<br><br>#+begin_src python :tangle naps_utilities/pointcloud.py<br># N\u00e9cessaires pour la lecture/\u00e9criture de fichiers<br>import os<br>import json<br>import pickle<br><br>#Les donn\u00e9es sont stock\u00e9es sous forme de numpy ndarray<br>import numpy as np<br><br>#N\u00e9cessaire pour la conversion vers/depuis ROS2<br>from builtin_interfaces.msg import Time<br>from sensor_msgs.msg import PointCloud2<br>from sensor_msgs.msg import PointField<br>from std_msgs.msg import Header<br>from array import array<br>#+end_src<br><br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>class TransformWhileEmpty(Exception):<br>   \"\"\"Raised when transform method is called and the poincloud is not yet<br>   populated\"\"\"<br>   pass<br>#+end_src<br><br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>class InvalidInputData(Exception):<br>   \"\"\"Raised when data used to populate is not valid\"\"\"<br>   pass<br>#+end_src<br><br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>class MultipleInputData(Exception):<br>   \"\"\"Raised when data used to populate is not valid\"\"\"<br>   pass<br>#+end_src<br>** Corps de la classe<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>class Pointcloud():<br>    def __init__(self, ros_msg=None, points=None, keep_ring=True,<br>               matrix=None, procrastinate=False, inpath=None):<br>        # PoinCloud Metadata<br>        self.metadata = {'header': None,<br>                         'height': None,<br>                         'width': None,<br>                         'fields': None,<br>                         'is_bigendian': None,<br>                         'point_step': None,<br>                         'row_step': None,<br>                         'is_dense': None,<br>                         'keep_ring': None,<br>                         'is_populated': False,<br>                         'procrastinated': True,}<br>        # Pointcloud DATA<br>        self.points = None<br>        self.rings = None<br>        self.matrix = matrix<br><br>        # Ensure that only one populate method is selected:<br>        conditions = [ros_msg is not None, points is not None, inpath is not None]<br><br>        if sum(conditions) &gt; 1:<br>            raise MultipleInputData<br><br>        else:<br>            if ros_msg is not None:<br>                self.from_msg(ros_msg)<br><br>            elif points is not None:<br>                self.from_list(points)<br><br>            elif inpath is not None:<br>                self.load(inpath)<br><br>            if self.metadata['is_populated']:<br>                if not procrastinate:<br>                    self.filter()<br>                    if matrix is None:<br>                        self.matrix = np.identity(4)<br>                        self.metadata['procrastinated'] = False<br>                    else:<br>                        self.transform(matrix)<br>#+end_src<br>** Populate from list<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def from_list(self, data):<br>        self.metadata['keep_ring'] = False<br><br>        self.points = np.ascontiguousarray(data, dtype=np.float32)<br>        if self.points.shape[1] != 3 and self.points.shape[1] != 4:<br>            raise InvalidInputData<br><br>        self.metadata['nb_points'] = len(self.points)<br>        self.metadata['height'] = 1<br>        self.metadata['width'] = self.metadata['nb_points']<br><br>        self.metadata['is_bigendian'] = False<br>        self.metadata['point_step'] = 3 * 4<br>        self.metadata['row_step'] = self.metadata['point_step']<br><br>        self.metadata['is_dense'] = False<br><br>        self.metadata['is_populated'] = True<br>#+end_src<br>** populate from ROS msg<br>Un certain nombre de donn\u00e9es ne n\u00e9cessitent pas de conversion :<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def from_msg(self, msg):<br>        #Donn\u00e9es conserv\u00e9es \"telles quelles\"<br><br>        self.metadata['height'] = msg.height<br>        self.metadata['width'] = msg.width<br><br>        self.metadata['is_bigendian'] = msg.is_bigendian<br>        self.metadata['point_step'] = msg.point_step<br>        self.metadata['row_step'] = msg.row_step<br><br>        self.metadata['is_dense'] = msg.is_dense<br>#+end_src<br>L'atribut Header est du type std_msgs/Header:<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        def from_header(header):<br>            return {'time': {'sec': header.stamp.sec, 'nanosec': header.stamp.nanosec},<br>               'frame_id': header.frame_id}<br>        self.metadata['header'] = from_header(msg.header)<br>#+end_src<br>L'attribut fields du msg ROS est une liste d'objets PointFields.  Il<br>convient \u00e9galement de supprimer le fields ring, si l'on choisit de ne<br>pas les garder.<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        def from_pointfields(fields):<br>            return [{'name': field.name,<br>                'offset': field.offset,<br>                'datatype': field.datatype,<br>                'count': field.count}<br>               for field in fields]<br><br>        self.metadata['fields'] = from_pointfields(msg.fields)<br>#+end_src<br>Afin de pr\u00e9parer l'extraction, on initialise des numpy ndarray afin<br>que tous les points soient dans un espace contigu de la m\u00e9moire. Ici<br>on s\u00e9pare les points en un tableau de float32 (x, y, z) et un tableau<br>de (ring). Cela pour faciliter l'encodage d\u00e9codage (c'est plus<br>difficile avec des types diff\u00e9rents imbriqu\u00e9s)<br><br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        # Donn\u00e9es converties<br>        self.metadata['nb_points'] = msg.height * msg.width<br><br>        data = np.reshape(msg.data, (-1, self.metadata['point_step']))<br><br>        self.points = np.ndarray(<br>            (self.metadata['nb_points'], 4), dtype=np.float32,<br>            buffer=np.ascontiguousarray(data[:, :16]))<br><br>        if self.metadata['keep_ring']:<br>            self.metadata['rings'] = np.zeros(<br>                self.metadata['nb_points'], dtype=np.uint16)<br><br>            pointcloud['rings'] = np.ndarray(<br>                (self.metadata['nb_points']), dtype=np.uint16,<br>                buffer=np.ascontiguousarray(data[:, 16:]))<br>#+end_src<br>Mise \u00e0 jour d\u00e9 m\u00e9tadonn\u00e9es si n\u00e9cessaire :<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        if not self.metadata['keep_ring']:<br>            self.metadata['fields'] = [field for field in self.metadata['fields'] if field['name'] != 'ring']<br>            self.metadata['point_step'] = 16<br>            self.metadata['row_step'] = self.metadata['point_step'] * len(self.metadata['fields'])<br>            self.metadata['is_populated'] = True<br>#+end_src<br>** convert to msg<br>Beaucoup de sym\u00e9trie avec la fonction pr\u00e9cedante.<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def to_msg(self):<br>        msg = PointCloud2()<br>        #Donn\u00e9es conserv\u00e9es \"telles quelles\"<br><br>        msg.height = self.metadata['height']<br>        msg.width = self.metadata['width']<br><br>        msg.is_bigendian = self.metadata['is_bigendian']<br>        msg.point_step = self.metadata['point_step']<br>        msg.row_step = self.metadata['row_step']<br><br>        msg.is_dense = self.metadata['is_dense']<br>#+end_src<br><br>Conversion vers Header ROS:<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        def to_header(header_data):<br>            return Header(stamp=Time(<br>                sec=header_data['time']['sec'],<br>                nanosec=header_data['time']['nanosec']),<br>                     frame_id=header_data['frame_id'])<br>        msg.header = to_header(self.metadata['header'])<br>#+end_src<br>Conversion vers Pointfield:<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        def to_pointfields(pointfields_data):<br>            return [PointField(name=field['name'],<br>                          offset=field['offset'],<br>                          datatype=field['datatype'],<br>                          count=field['count']) for field in pointfields_data]<br>        msg.fields = to_pointfields(self.metadata['fields'])<br>#+end_src<br>Deux cas, selon la valeur de 'keep_ring':<br><br>Si on garde les rings, il faut concatener les deux tableaux et en<br>faire un array de uint8.<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        if self.metadata['keep_ring']:<br>            msg.data = array('B', np.concatenate(<br>            (self.points.view(dtype=np.uint8),<br>             self.rings.reshape((self.metadata['nb_points'], -1)).view(dtype=np.uint8)),<br>            axis=1).ravel().tolist())<br>#+end_src<br>Sinon, il suffi de cr\u00e9er une liste de uint8 \u00e0 partir des points au<br>niveau des donn\u00e9es.<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        else:<br>            msg.data = array('B', self.points.view(dtype=np.uint8).ravel().tolist())<br>        return msg<br>#+end_src<br>** filter pointcloud<br><br>Il y a deux cas a traiter, si l'on garde les rings auquel cas il faut<br>les filter aussi.<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def filter(self, threshold=10):<br>        if self.metadata['keep_ring']:<br>            concat = np.concatenate((self.points, self.rings.reshape((len(points), 1))), axis=1)<br>            concat = concat[np.logical_and(<br>                np.logical_not(np.isnan(concat).any(axis=1)),<br>                concat[:,3]&gt;=threshold)]<br>            self.points = np.ascontiguousarray(concat[:,:4], dtype=np.float32)<br>            self.rings = np.ascontiguousarray(concat[:,4:], dtype=np.uint16)<br>#+end_src<br>Apr\u00e8s avoir \u00e9t\u00e9 filtr\u00e9, le poincloud ne peut plus \u00eatre structur\u00e9 dans<br>un tableau 2D.<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>        else:<br>            self.points = self.points[np.logical_and(<br>                np.logical_not(np.isnan(self.points).any(axis=1)),<br>                self.points[:,3]&gt;=threshold)]<br>        self.metadata['nb_points'] = len(self.points)<br>        self.metadata['height'] = 1<br>        self.metadata['width'] = self.metadata['nb_points']<br>#+end_src<br><br>** transform pointcloud<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def transform(self, matrix):<br>        if self.metadata['is_populated']:<br>            self.points[:,:3] = np.transpose(<br>                matrix @ np.concatenate((self.points[:,:3].transpose(),<br>                                         np.ones((1, self.metadata['nb_points'])))))[:,:3]<br>            self.matrix = matrix<br>            self.metadata['procrastinated'] = False<br>        else:<br>            raise TransformWhileEmpty(\"Populate pointcloud before applying transform to it\")<br>#+end_src<br>** add points<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def update(self, pointcloud):<br>        if self.metadata['keep_ring']:<br>            if pointcloud.metadata['keep_ring']:<br>                self.rings = np.ascontiguousarray(np.concatenate((self.rings, pointcloud.rings)))<br>            else:<br>                return False<br>        self.points = np.ascontiguousarray(np.concatenate((self.points, pointcloud.points)))<br>        self.metadata['nb_points'] = len(self.points)<br>        self.metadata['height'] = 1<br>        self.metadata['width'] = self.metadata['nb_points']<br>        return True<br>#+end_src<br><br>** Export/Import<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def save(self, path):<br>        self.save_npz(path)<br>#+end_src<br>*** npz<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def save_npz(self, path):<br>        save_path = os.path.expanduser(path)<br>        # with open('{}_meta.json'.format(save_path), 'w') as outfile:<br>        #     json.dump(self.metadata, outfile, indent=4)<br><br>        np.savez_compressed('{}'.format(save_path), meta=[self.metadata], points=self.points, rings=self.rings, matrix=self.matrix)<br>#+end_src<br><br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def load(self, path):<br>        load_path = os.path.expanduser(path)<br>        # with open('{}_meta.json'.format(load_path), 'r') as infile:<br>        #     self.metadata = json.load(infile)<br><br>        with np.load(load_path, allow_pickle=True) as data:<br>            self.metadata = data['meta'][0]<br>            if 'matrix' in data:<br>                self.matrix = data['matrix']<br>            if 'points' in data:<br>                self.points = data['points']<br>            if 'rings' in data:<br>                self.rings = data['rings']<br>#+end_src<br>*** xyz<br>#+begin_src python :tangle naps_utilities/pointcloud.py<br>    def save_xyz(self, path):<br>        save_path = os.path.expanduser(path)<br>        np.savetxt('{}.xyz'.format(save_path), self.points)<br>        #with open('{}.xyz'.format(save_path), 'w') as outfile:<br>        #     json.dump(self.metadata, outfile, indent=4)<br>#+end_src<br><br>* Tests<br>#+begin_src ipython :session session01 :file  :exports both<br>import numpy as np<br>from naps_utilities import Pointcloud<br>points = [[0, 0, 0, 4],<br>          [1, 0, 0, 5],<br>          [0, 1, 0, 105],<br>          [0, 0, 1, 452],]<br>p = Pointcloud(points=points)<br>#+end_src<br><br>#+RESULTS:<br>: # Out[9]:<br><br>#+begin_src ipython :session session01 :file  :exports both<br>p = Pointcloud(points=points)<br>#+end_src<br>* Build et distribution<br>#+begin_src bash :results value verbatim :exports both<br>python setup.py bdist_wheel sdist<br>#+end_src<br><br>#+RESULTS:<br>#+begin_example<br>running bdist_wheel<br>running build<br>running build_py<br>installing to build/bdist.linux-x86_64/wheel<br>running install<br>running install_lib<br>creating build/bdist.linux-x86_64/wheel<br>creating build/bdist.linux-x86_64/wheel/naps_utilities<br>copying build/lib/naps_utilities/pointcloud.py -&gt; build/bdist.linux-x86_64/wheel/naps_utilities<br>copying build/lib/naps_utilities/__init__.py -&gt; build/bdist.linux-x86_64/wheel/naps_utilities<br>running install_egg_info<br>running egg_info<br>writing naps_utilities.egg-info/PKG-INFO<br>writing dependency_links to naps_utilities.egg-info/dependency_links.txt<br>writing requirements to naps_utilities.egg-info/requires.txt<br>writing top-level names to naps_utilities.egg-info/top_level.txt<br>reading manifest file 'naps_utilities.egg-info/SOURCES.txt'<br>writing manifest file 'naps_utilities.egg-info/SOURCES.txt'<br>Copying naps_utilities.egg-info to build/bdist.linux-x86_64/wheel/naps_utilities-0.1.1-py3.7.egg-info<br>running install_scripts<br>creating build/bdist.linux-x86_64/wheel/naps_utilities-0.1.1.dist-info/WHEEL<br>creating 'dist/naps_utilities-0.1.1-py3-none-any.whl' and adding 'build/bdist.linux-x86_64/wheel' to it<br>adding 'naps_utilities/__init__.py'<br>adding 'naps_utilities/pointcloud.py'<br>adding 'naps_utilities-0.1.1.dist-info/METADATA'<br>adding 'naps_utilities-0.1.1.dist-info/WHEEL'<br>adding 'naps_utilities-0.1.1.dist-info/top_level.txt'<br>adding 'naps_utilities-0.1.1.dist-info/RECORD'<br>removing build/bdist.linux-x86_64/wheel<br>running sdist<br>running check<br>creating naps_utilities-0.1.1<br>creating naps_utilities-0.1.1/naps_utilities<br>creating naps_utilities-0.1.1/naps_utilities.egg-info<br>copying files to naps_utilities-0.1.1...<br>copying setup.py -&gt; naps_utilities-0.1.1<br>copying naps_utilities/__init__.py -&gt; naps_utilities-0.1.1/naps_utilities<br>copying naps_utilities/pointcloud.py -&gt; naps_utilities-0.1.1/naps_utilities<br>copying naps_utilities.egg-info/PKG-INFO -&gt; naps_utilities-0.1.1/naps_utilities.egg-info<br>copying naps_utilities.egg-info/SOURCES.txt -&gt; naps_utilities-0.1.1/naps_utilities.egg-info<br>copying naps_utilities.egg-info/dependency_links.txt -&gt; naps_utilities-0.1.1/naps_utilities.egg-info<br>copying naps_utilities.egg-info/requires.txt -&gt; naps_utilities-0.1.1/naps_utilities.egg-info<br>copying naps_utilities.egg-info/top_level.txt -&gt; naps_utilities-0.1.1/naps_utilities.egg-info<br>Writing naps_utilities-0.1.1/setup.cfg<br>Creating tar archive<br>removing 'naps_utilities-0.1.1' (and everything under it)<br>#+end_example<br><br><br>#+begin_src bash :results value verbatim :exports both<br>twine upload dist/*<br>#+end_src<br><br>#+RESULTS:<br><br><br>\n          </div>"}, "last_serial": 6711050, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "1bbcaf1ac1e300090ad36c46d9f8ab84", "sha256": "7780e39d80ec0390906fb3ba2672f789605f7bbd114adf069650e304c8c83212"}, "downloads": -1, "filename": "naps_utilities-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1bbcaf1ac1e300090ad36c46d9f8ab84", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6736, "upload_time": "2020-02-26T10:35:45", "upload_time_iso_8601": "2020-02-26T10:35:45.355720Z", "url": "https://files.pythonhosted.org/packages/50/88/95da8769a4949b684b3e61f70b30be3b1f4aaec8faee1faf6f267d0e2175/naps_utilities-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "40ca0e61333d44aa10df0549610c2264", "sha256": "c815021ddafeb2232c403c97065c1606608d57cc76fd1c4dad41912ecc4dde28"}, "downloads": -1, "filename": "naps_utilities-0.1.0.tar.gz", "has_sig": false, "md5_digest": "40ca0e61333d44aa10df0549610c2264", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5201, "upload_time": "2020-02-26T10:35:47", "upload_time_iso_8601": "2020-02-26T10:35:47.429948Z", "url": "https://files.pythonhosted.org/packages/f9/ae/00f4151bc4ea2876401d03409067b6f4a0f7f5c3428a50940c35b5f205fd/naps_utilities-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "f86bf4227dcc43a0ebb37bf549ea0f4e", "sha256": "5ccbbaf3f94473311339ebfa65670d03352bdb5c92c037758b73c65f9f29fc5b"}, "downloads": -1, "filename": "naps_utilities-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f86bf4227dcc43a0ebb37bf549ea0f4e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7951, "upload_time": "2020-02-26T15:24:18", "upload_time_iso_8601": "2020-02-26T15:24:18.587911Z", "url": "https://files.pythonhosted.org/packages/e1/ff/e258757385d0816c6c769524e1394411aa1ce80b4da3791541bd1ea5c9e3/naps_utilities-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e1aa5e01072a7fe0e84b41f6a119d4df", "sha256": "2d31ed940049df87e42a4c567a1a5b9bf9900f2491d576be7ae01e43d2b58ec0"}, "downloads": -1, "filename": "naps_utilities-0.1.1.tar.gz", "has_sig": false, "md5_digest": "e1aa5e01072a7fe0e84b41f6a119d4df", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8448, "upload_time": "2020-02-26T15:24:19", "upload_time_iso_8601": "2020-02-26T15:24:19.894851Z", "url": "https://files.pythonhosted.org/packages/83/93/b7796beb23d84a259235aa6263241152ef4e6b9a0a7750a1cdeec8d52ea0/naps_utilities-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "7cf4f63c57c7998c1d297b010989e066", "sha256": "f6ef813999e8d0cf754cdc964669c5dbbbe5bc163d0958e038c155fb69f3b398"}, "downloads": -1, "filename": "naps_utilities-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "7cf4f63c57c7998c1d297b010989e066", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10630, "upload_time": "2020-02-27T13:39:56", "upload_time_iso_8601": "2020-02-27T13:39:56.375338Z", "url": "https://files.pythonhosted.org/packages/f2/31/6fb54a7649a5f3eca574f7edb4c0073f92b54f44076cb9df86a2f0968bb6/naps_utilities-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0d6570db001cec6f2de96e5f418bcf3c", "sha256": "db0ae96ebc81d757a6f622b43e6a03bfc418a20ca4990eb5f6971fd78f9b9904"}, "downloads": -1, "filename": "naps_utilities-0.2.0.tar.gz", "has_sig": false, "md5_digest": "0d6570db001cec6f2de96e5f418bcf3c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12079, "upload_time": "2020-02-27T13:39:58", "upload_time_iso_8601": "2020-02-27T13:39:58.028669Z", "url": "https://files.pythonhosted.org/packages/b5/96/885f3b4ea7556356eaff96cca83a6c76aee0f0c1a08219965d6a5c490366/naps_utilities-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7cf4f63c57c7998c1d297b010989e066", "sha256": "f6ef813999e8d0cf754cdc964669c5dbbbe5bc163d0958e038c155fb69f3b398"}, "downloads": -1, "filename": "naps_utilities-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "7cf4f63c57c7998c1d297b010989e066", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10630, "upload_time": "2020-02-27T13:39:56", "upload_time_iso_8601": "2020-02-27T13:39:56.375338Z", "url": "https://files.pythonhosted.org/packages/f2/31/6fb54a7649a5f3eca574f7edb4c0073f92b54f44076cb9df86a2f0968bb6/naps_utilities-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0d6570db001cec6f2de96e5f418bcf3c", "sha256": "db0ae96ebc81d757a6f622b43e6a03bfc418a20ca4990eb5f6971fd78f9b9904"}, "downloads": -1, "filename": "naps_utilities-0.2.0.tar.gz", "has_sig": false, "md5_digest": "0d6570db001cec6f2de96e5f418bcf3c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12079, "upload_time": "2020-02-27T13:39:58", "upload_time_iso_8601": "2020-02-27T13:39:58.028669Z", "url": "https://files.pythonhosted.org/packages/b5/96/885f3b4ea7556356eaff96cca83a6c76aee0f0c1a08219965d6a5c490366/naps_utilities-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:29 2020"}