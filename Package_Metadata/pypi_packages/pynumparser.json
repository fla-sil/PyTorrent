{"info": {"author": "NVRAM", "author_email": "nvram@users.sourceforge.net", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Text Processing :: Filters", "Topic :: Utilities"], "description": "pynumparser 1.4.1\n=================\n\nSummary\n-------\n\nThis library provides two classes for parsing simple integer or floating piont numbers and numeric\nsequences, optionally enforcing value limits. These can be used as explicit objects or as the\n*type* parameter of an argument within an *argparse.ArgumentParser*.\n\n- **NumberSequence** parses an input string and yields a sequence of numbers, optionally ensuring\n  they are within the given limits. It will also convert a sequence of numbers into the string form\n  *[as of version 1.2]*.\n- **Number** parses an input string and returns a single number; ensuring they are within the given\n  limits.\n- Both classes take a **numtype** parameter (*int* or *float*), and a **limits** parameter which\n  can be *None* or a 2-tuple; the 2-tuple imposes limits on the parsed values.\n\n.. contents:: **Index**\n   :depth: 2\n   :local:\n\n----------\n\nInstallation\n------------\nInstall the package using **pip**, eg:\n\n     sudo pip install pynumparser\n\nOr for a specific version:\n\n     sudo python3 -m pip install pynumparser\n\n*NumberSequence* Syntax\n-----------------------\n\nAllowed inputs are comprised of one (1) or more subsequences separated by a comma (\",\").\nSubsequences can be simple numbers or number ranges with or without a **stride** value.\n\n- Simple number values yield a single value.\n\n- A range is expressed as two (2) number values separated by either a dash/hyphen (\"-\") or a plus\n  sign (\"+\") *[as of version 1.3]*, optionally followed by a slash (\"/\") and a **stride** value.\n\n  - A range will usually yield multiple values *including both bounds*.  This is in contrast to\n    the builtin Python *range()* behaviour.\n\n    - A **lower bound** and **upper bound** may be separated by a single dash/hyphen (\"-\").  Note\n      that it is legal for the upper bound be negative (eg: \"-5--3\").\n\n    - A **lower bound** and **range size** may be separated by a single plus sign (\"+\").  Note that\n      it is legal for the range size be start with a plus sign (eg: \"8++5\" is equivalent to \"8+5\").\n      *[As of version 1.3]* \n\n  - Only monotonically increasing ranges are allowed:\n\n    - An **upper range** value must not be less than the lower range value (eg: \"5-4\" is illegal).\n\n    - The **stride** must be positive (eg: \"5-8/0\" and \"8-1/-2\" are illegal).\n\n    - A **range size** must not be negative (eg: \"8+-4\" is illegal) *[as of version 1.3]*.\n\n- By default numbers are of *int* type. But if *numtype=float* is passed to the constructor, the\n  inputs are parsed as floating point numbers *with a dot/peroid for a decimial mark*.  In other\n  words, the representation of *5/4* must be \"*1.2*\" and not \"*1,2*\" since the comma is used as the\n  subsequence separator.\n\n- If the difference between the limits is not an even mulitiple of the *stride* value, then the\n  second range will *not* be included in the result.\n\n- The parser has a *contains* method, which can be used to check if a number is in the range.\n  *[as of version 1.1]*.\n\n- The *Number* class has a *contains* method, which can be check if a number is in the range.\n  *[as of version 1.4.1]*.\n\n- **NumberSequence** has a classmethod *encode* that will convert a sequence into a simplified text\n  representation. *[as of version 1.2]*.\n\n  .. code:: python\n\n      >>> import pynumparser\n      >>> pynumparser.NumberSequence.encode([1, 2, 3, 7, 13, 19, 25])\n      '1-3,7-25/6'\n      >>> pynumparser.NumberSequence.encode([1.00, 1.25, 1.5, 1.75, 2, 2.25])\n      '1.0-2.25/0.25'\n      >>> pynumparser.NumberSequence.encode(range(10, 100, 5))\n      '10-95/5'\n\n\n**Exceptions**\n^^^^^^^^^^^^^^\n\nThese apply to both the **NumberSequence** and **Number** classes:\n\n- If the optional constructor **limits** parameter is provided, then a *ValueError* will be raised\n  in the constructor if any of the following are violated.\n\n  - The **limits** parameter must be either *None* or else a tuple with two (2) values, a *lower\n    limit* then an *upper limit*.\n\n  - Both of the *limit* values may be either *None* or a valid value of the **numtype**.\n\n  - If *lower limit* and *upper limit* are numbers, then the *lower limit* must be less than the\n    *upper limit*.\n\n- If **limits** parameter was provided to the constructor, then a *ValueError* will be raised\n  during parsing if any of the following are violated.\n\n  - If the *lower limit* is a number, then parsed values must not be less than the *lower limit*.\n\n  - If the *upper limit* is a number, then parsed values must not be greater than the *upper limit*.\n\n- If any input cannot be parsed as a valid number of given the **numtype** a *ValueError* is raised.\n\n- If any floating point number equates to positive or negative infinity (eg: *\"1e9999\"*) a\n  *ValueError* is raised.\n\nThese apply only to the **NumberSequence** class, during parsing:\n\n- If the *upper bound* is less than the *lower bound* (eg: \"*8-5*\") or *[as of version 1.3]* if the\n  *range size* is negative (eg: \"*8+-3*\"), then a *ValueError* is raised.\n\n- If the **stride** value is zero or negative, *ValueError* is raised, even if the upper and lower\n  limit values are equal (eg: \"*8-8/0*\").\n\n\nIf used within an **argparse.ArgumentParser**, invalid input will raise a *ValueError* and result in\nan error message indicating the specific problem, such as:\n\n.. code:: bash\n\n    $ demo.py --fnum 1e20\n    usage: demo.py [-h] [-i ISEQ] [-f FSEQ] [-I INUM] [-F FNUM]\n    demo.py: error: argument -F/--fnum: invalid Float (from -100 to 1000), ERROR: \"Too High\" value: '1e20'\n\n    $ demo.py -i 200-100\n    usage: demo.py [-h] [-i ISEQ] [-f FSEQ] [-I INUM] [-F FNUM]\n    demo.py: error: argument -i/--iseq: invalid IntSequence (at least -1000), ERROR: \"UPPER<LOWER\" value: '200-100'\n\nNote that a deficiency in the **argparse.ArgumentParser** package can cause problems with legal\nvalues that start with a dash, even for flags with mandatory arguments.  Although not always true,\nfor some values (eg: \"*-1e5*\") the **argparser** package will incorrectly abort with an error\nmessage of \"*expected on argument*\".\n\nTo demonstrate (using code from *Example* section saved as \"demo.py\") for a short flag with a valid\nargument and a long flag with an invalid one:\n\n.. code:: bash\n\n    $ demo.py -f -1e2+2\n    usage: demo.py [-h] [-i ISEQ] [-f FSEQ] [-I INUM] [-F FNUM]\n    demo.py: error: argument -f/--fseq: expected one argument\n\n    $ demo.py -f-1e2+2\n    Namespace(fnum=[], fseq=(-100.0, -99.0, -98.0), inum=[], iseq=[])\n\n.. code:: bash\n\n    $ demo.py --fnum -1..5\n    usage: demo.py [-h] [-i ISEQ] [-f FSEQ] [-I INUM] [-F FNUM]\n    demo.py: error: argument -F/--fnum: expected one argument\n\n    $ demo.py --fnum=-1..5\n    usage: demo.py [-h] [-i ISEQ] [-f FSEQ] [-I INUM] [-F FNUM]\n    demo.py: error: argument -F/--fnum: invalid Float (from -100 to 1000), ERROR: \"Parse Error\" value: '-1..5'\n\n\nExample with *argparse.ArgumentParser*\n--------------------------------------\n\n.. code::\n\n    import argparse\n    import pynumparser\n\n    # Note:  Typical values would likely include 'help' and  'default' parameters.\n    parser = argparse.ArgumentParser(description=\"Number printer\")\n\n    # Add a simple int parameter, requiring it be between -40 and 130, inclusive:\n    parser.add_argument('-a', '--age', type=pynumparser.Number(limits=(-40, 130)))\n\n    # Add int sequence, requiring values to be non-negative:\n    parser.add_argument('-i', '--ints', type=pynumparser.NumberSequence(limits=(0, None)))\n\n    # Add a simple float parameter, requiring it be a positive value less than 1000:\n    parser.add_argument('-s', '--seconds', type=pynumparser.Number(numtype=float, limits=(1e-230, 1000)))\n\n    # Add a float sequence, requiring the numbers be between 0 and 365.25 inclusive:\n    parser.add_argument('-d', '--days', type=pynumparser.NumberSequence(numtype=float, limits=(0, 365.25)))\n\n    print(parser.parse_args())\n\nExamples *NumberSequence* Results\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nWith the default parameters (*numtype=int, limits=None*):\n\n- **\"5\"** yields a result of *(5)*.\n\n- **\"5-8\"** is equivalent to **\"5-8/1\"** and both yield a result of *(5, 6, 7, 8)*.\n\n- **\"3-9/3\"** would give a result of *(3, 6, 9)*.\n\n- **\"-3-2\"** would yield a result of *(-3, -2, -1, 0, 1, 2)*.\n\n- **\"-3--2\"** would yield a result of *(-3, -2)*.\n\n- **\"-5-5/5\"** would yield a result of *(-5, 0, 5)*.\n\n- **\"-8,-9-9/6,12-30/12,5,2,3\"** would yield *(-8, -9, -3, 3, 9, 12, 24, 5, 2, 3)*.\n\nWith parameters (*numtype=float*, *limits=None*) the results are floating point numbers:\n\n- **\"5.125\"** yields a result of *(5.125)*.\n\n- **\"5,125\"** yields a result of *(5.0, 125.0)* since the comma is a subsequence separator.\n\n- **\"5-7\"** is equivalent to **\"5-7/1\"** and both yield a result of *(5.0, 6.0, 7.0)*.\n\n- **\"0-1/.25\"** would give a result of *(0.0, 0.25, 0.5, 0.75, 1.0)*.\n\n\nReleases\n^^^^^^^^\n   +-------------+----------------------------------------------------------------------------+\n   | **Version** | **Description**                                                            |\n   +-------------+----------------------------------------------------------------------------+\n   |    1.0.1    | Initial release                                                            |\n   +-------------+----------------------------------------------------------------------------+\n   |     1.1     | Added the **NumberSequence.contains()** method.                            |\n   +-------------+----------------------------------------------------------------------------+\n   |     1.2     | Added the **NumberSequence.encode()** method, fixed documentation on PyPi. |\n   +-------------+----------------------------------------------------------------------------+\n   |     1.3     | Added the **NumberSequence** format \"+\" to specify a *range size*.         |\n   +-------------+----------------------------------------------------------------------------+\n   |     1.4     | Added the **Number.contains()** method and Travis CI test integration.     |\n   +-------------+----------------------------------------------------------------------------+\n   |   1.4.1     | Moved project to host at Gitlab.                                           |\n   +-------------+----------------------------------------------------------------------------+\n\nBuild Status\n^^^^^^^^^^^^\n\n.. image:: https://gitlab.com/n2vram/pynumparser/badges/master/build.svg\n    :alt: Build Status\n    :target: https://gitlab.com/n2vram/pynumparser/\n\nKnown Issues\n^^^^^^^^^^^^\n\n- Under some circumstances, floating point representation errors cause the upper range to be\n  (unexpectedly) omitted.  This happens due to the internal representation of floating point\n  numbers, and is not limited to this package, or even to Python.  For more information, see:\n  `Floating Point Arithmetic: Issues and Limitations\n  <https://docs.python.org/2/tutorial/floatingpoint.html#representation-error>`_.\n\n  - In the first example (**\"0-13/1.3\"**), the value of **13** is not included since the previous\n    value was larger than **11.7**.\n  - In the second example (**\"1.2-2.0/0.2\"**) the final value is slightly less than\n    **2.0** due to representation error.\n\n  .. code:: python\n\n      >>> import pynumparser\n      >>> parser = pynumparser.NumberSequence(float)\n      >>> parser.parse(\"0-13/1.3\")\n      (0.0, 1.3, 2.6, 3.9000000000000004, 5.2, 6.5, 7.8, 9.1, 10.4, 11.700000000000001)\n      >>> parser.parse(\"1.2-2.0/0.2\")\n      (1.2, 1.4, 1.5999999999999999, 1.7999999999999998, 1.9999999999999998)", "description_content_type": "", "docs_url": null, "download_url": "https://gitlab.com/n2vram/pynumparser/archive/1.4.1.zip", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://gitlab.com/n2vram/pynumparser", "keywords": "argparse,numparser,parser,numbers,parsing,ArgumentParser,command-line,sequences", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pynumparser", "package_url": "https://pypi.org/project/pynumparser/", "platform": "any", "project_url": "https://pypi.org/project/pynumparser/", "project_urls": {"Download": "https://gitlab.com/n2vram/pynumparser/archive/1.4.1.zip", "Homepage": "https://gitlab.com/n2vram/pynumparser"}, "release_url": "https://pypi.org/project/pynumparser/1.4.1/", "requires_dist": null, "requires_python": "", "summary": "A library to parse arguments of numbers and number sequences, usable directly or with argparse. Allows concise representation of contiguous or non-contiguous sequences. Example: 1,5-10,40-50/5,200+100/25", "version": "1.4.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"summary\">\n<h2>Summary</h2>\n<p>This library provides two classes for parsing simple integer or floating piont numbers and numeric\nsequences, optionally enforcing value limits. These can be used as explicit objects or as the\n<em>type</em> parameter of an argument within an <em>argparse.ArgumentParser</em>.</p>\n<ul>\n<li><strong>NumberSequence</strong> parses an input string and yields a sequence of numbers, optionally ensuring\nthey are within the given limits. It will also convert a sequence of numbers into the string form\n<em>[as of version 1.2]</em>.</li>\n<li><strong>Number</strong> parses an input string and returns a single number; ensuring they are within the given\nlimits.</li>\n<li>Both classes take a <strong>numtype</strong> parameter (<em>int</em> or <em>float</em>), and a <strong>limits</strong> parameter which\ncan be <em>None</em> or a 2-tuple; the 2-tuple imposes limits on the parsed values.</li>\n</ul>\n</div>\n<hr class=\"docutils\">\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Install the package using <strong>pip</strong>, eg:</p>\n<blockquote>\nsudo pip install pynumparser</blockquote>\n<p>Or for a specific version:</p>\n<blockquote>\nsudo python3 -m pip install pynumparser</blockquote>\n</div>\n<div id=\"numbersequence-syntax\">\n<h2><em>NumberSequence</em> Syntax</h2>\n<p>Allowed inputs are comprised of one (1) or more subsequences separated by a comma (\u201c,\u201d).\nSubsequences can be simple numbers or number ranges with or without a <strong>stride</strong> value.</p>\n<ul>\n<li><p>Simple number values yield a single value.</p>\n</li>\n<li><p>A range is expressed as two (2) number values separated by either a dash/hyphen (\u201c-\u201c) or a plus\nsign (\u201c+\u201d) <em>[as of version 1.3]</em>, optionally followed by a slash (\u201c/\u201d) and a <strong>stride</strong> value.</p>\n<ul>\n<li>A range will usually yield multiple values <em>including both bounds</em>.  This is in contrast to\nthe builtin Python <em>range()</em> behaviour.<ul>\n<li>A <strong>lower bound</strong> and <strong>upper bound</strong> may be separated by a single dash/hyphen (\u201c-\u201c).  Note\nthat it is legal for the upper bound be negative (eg: \u201c-5\u20133\u201d).</li>\n<li>A <strong>lower bound</strong> and <strong>range size</strong> may be separated by a single plus sign (\u201c+\u201d).  Note that\nit is legal for the range size be start with a plus sign (eg: \u201c8++5\u201d is equivalent to \u201c8+5\u201d).\n<em>[As of version 1.3]</em></li>\n</ul>\n</li>\n<li>Only monotonically increasing ranges are allowed:<ul>\n<li>An <strong>upper range</strong> value must not be less than the lower range value (eg: \u201c5-4\u201d is illegal).</li>\n<li>The <strong>stride</strong> must be positive (eg: \u201c5-8/0\u201d and \u201c8-1/-2\u201d are illegal).</li>\n<li>A <strong>range size</strong> must not be negative (eg: \u201c8+-4\u201d is illegal) <em>[as of version 1.3]</em>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>By default numbers are of <em>int</em> type. But if <em>numtype=float</em> is passed to the constructor, the\ninputs are parsed as floating point numbers <em>with a dot/peroid for a decimial mark</em>.  In other\nwords, the representation of <em>5/4</em> must be \u201c<em>1.2</em>\u201d and not \u201c<em>1,2</em>\u201d since the comma is used as the\nsubsequence separator.</p>\n</li>\n<li><p>If the difference between the limits is not an even mulitiple of the <em>stride</em> value, then the\nsecond range will <em>not</em> be included in the result.</p>\n</li>\n<li><p>The parser has a <em>contains</em> method, which can be used to check if a number is in the range.\n<em>[as of version 1.1]</em>.</p>\n</li>\n<li><p>The <em>Number</em> class has a <em>contains</em> method, which can be check if a number is in the range.\n<em>[as of version 1.4.1]</em>.</p>\n</li>\n<li><p><strong>NumberSequence</strong> has a classmethod <em>encode</em> that will convert a sequence into a simplified text\nrepresentation. <em>[as of version 1.2]</em>.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">pynumparser</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pynumparser</span><span class=\"o\">.</span><span class=\"n\">NumberSequence</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"mi\">19</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">])</span>\n<span class=\"s1\">'1-3,7-25/6'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pynumparser</span><span class=\"o\">.</span><span class=\"n\">NumberSequence</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">([</span><span class=\"mf\">1.00</span><span class=\"p\">,</span> <span class=\"mf\">1.25</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"mf\">1.75</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mf\">2.25</span><span class=\"p\">])</span>\n<span class=\"s1\">'1.0-2.25/0.25'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pynumparser</span><span class=\"o\">.</span><span class=\"n\">NumberSequence</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"s1\">'10-95/5'</span>\n</pre>\n</li>\n</ul>\n<div id=\"exceptions\">\n<h3><strong>Exceptions</strong></h3>\n<p>These apply to both the <strong>NumberSequence</strong> and <strong>Number</strong> classes:</p>\n<ul>\n<li>If the optional constructor <strong>limits</strong> parameter is provided, then a <em>ValueError</em> will be raised\nin the constructor if any of the following are violated.<ul>\n<li>The <strong>limits</strong> parameter must be either <em>None</em> or else a tuple with two (2) values, a <em>lower\nlimit</em> then an <em>upper limit</em>.</li>\n<li>Both of the <em>limit</em> values may be either <em>None</em> or a valid value of the <strong>numtype</strong>.</li>\n<li>If <em>lower limit</em> and <em>upper limit</em> are numbers, then the <em>lower limit</em> must be less than the\n<em>upper limit</em>.</li>\n</ul>\n</li>\n<li>If <strong>limits</strong> parameter was provided to the constructor, then a <em>ValueError</em> will be raised\nduring parsing if any of the following are violated.<ul>\n<li>If the <em>lower limit</em> is a number, then parsed values must not be less than the <em>lower limit</em>.</li>\n<li>If the <em>upper limit</em> is a number, then parsed values must not be greater than the <em>upper limit</em>.</li>\n</ul>\n</li>\n<li>If any input cannot be parsed as a valid number of given the <strong>numtype</strong> a <em>ValueError</em> is raised.</li>\n<li>If any floating point number equates to positive or negative infinity (eg: <em>\u201c1e9999\u201d</em>) a\n<em>ValueError</em> is raised.</li>\n</ul>\n<p>These apply only to the <strong>NumberSequence</strong> class, during parsing:</p>\n<ul>\n<li>If the <em>upper bound</em> is less than the <em>lower bound</em> (eg: \u201c<em>8-5</em>\u201d) or <em>[as of version 1.3]</em> if the\n<em>range size</em> is negative (eg: \u201c<em>8+-3</em>\u201d), then a <em>ValueError</em> is raised.</li>\n<li>If the <strong>stride</strong> value is zero or negative, <em>ValueError</em> is raised, even if the upper and lower\nlimit values are equal (eg: \u201c<em>8-8/0</em>\u201d).</li>\n</ul>\n<p>If used within an <strong>argparse.ArgumentParser</strong>, invalid input will raise a <em>ValueError</em> and result in\nan error message indicating the specific problem, such as:</p>\n<pre>$ demo.py --fnum 1e20\nusage: demo.py <span class=\"o\">[</span>-h<span class=\"o\">]</span> <span class=\"o\">[</span>-i ISEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-f FSEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-I INUM<span class=\"o\">]</span> <span class=\"o\">[</span>-F FNUM<span class=\"o\">]</span>\ndemo.py: error: argument -F/--fnum: invalid Float <span class=\"o\">(</span>from -100 to <span class=\"m\">1000</span><span class=\"o\">)</span>, ERROR: <span class=\"s2\">\"Too High\"</span> value: <span class=\"s1\">'1e20'</span>\n\n$ demo.py -i <span class=\"m\">200</span>-100\nusage: demo.py <span class=\"o\">[</span>-h<span class=\"o\">]</span> <span class=\"o\">[</span>-i ISEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-f FSEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-I INUM<span class=\"o\">]</span> <span class=\"o\">[</span>-F FNUM<span class=\"o\">]</span>\ndemo.py: error: argument -i/--iseq: invalid IntSequence <span class=\"o\">(</span>at least -1000<span class=\"o\">)</span>, ERROR: <span class=\"s2\">\"UPPER&lt;LOWER\"</span> value: <span class=\"s1\">'200-100'</span>\n</pre>\n<p>Note that a deficiency in the <strong>argparse.ArgumentParser</strong> package can cause problems with legal\nvalues that start with a dash, even for flags with mandatory arguments.  Although not always true,\nfor some values (eg: \u201c<em>-1e5</em>\u201d) the <strong>argparser</strong> package will incorrectly abort with an error\nmessage of \u201c<em>expected on argument</em>\u201d.</p>\n<p>To demonstrate (using code from <em>Example</em> section saved as \u201cdemo.py\u201d) for a short flag with a valid\nargument and a long flag with an invalid one:</p>\n<pre>$ demo.py -f -1e2+2\nusage: demo.py <span class=\"o\">[</span>-h<span class=\"o\">]</span> <span class=\"o\">[</span>-i ISEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-f FSEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-I INUM<span class=\"o\">]</span> <span class=\"o\">[</span>-F FNUM<span class=\"o\">]</span>\ndemo.py: error: argument -f/--fseq: expected one argument\n\n$ demo.py -f-1e2+2\nNamespace<span class=\"o\">(</span><span class=\"nv\">fnum</span><span class=\"o\">=[]</span>, <span class=\"nv\">fseq</span><span class=\"o\">=(</span>-100.0, -99.0, -98.0<span class=\"o\">)</span>, <span class=\"nv\">inum</span><span class=\"o\">=[]</span>, <span class=\"nv\">iseq</span><span class=\"o\">=[])</span>\n</pre>\n<pre>$ demo.py --fnum -1..5\nusage: demo.py <span class=\"o\">[</span>-h<span class=\"o\">]</span> <span class=\"o\">[</span>-i ISEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-f FSEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-I INUM<span class=\"o\">]</span> <span class=\"o\">[</span>-F FNUM<span class=\"o\">]</span>\ndemo.py: error: argument -F/--fnum: expected one argument\n\n$ demo.py --fnum<span class=\"o\">=</span>-1..5\nusage: demo.py <span class=\"o\">[</span>-h<span class=\"o\">]</span> <span class=\"o\">[</span>-i ISEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-f FSEQ<span class=\"o\">]</span> <span class=\"o\">[</span>-I INUM<span class=\"o\">]</span> <span class=\"o\">[</span>-F FNUM<span class=\"o\">]</span>\ndemo.py: error: argument -F/--fnum: invalid Float <span class=\"o\">(</span>from -100 to <span class=\"m\">1000</span><span class=\"o\">)</span>, ERROR: <span class=\"s2\">\"Parse Error\"</span> value: <span class=\"s1\">'-1..5'</span>\n</pre>\n</div>\n</div>\n<div id=\"example-with-argparse-argumentparser\">\n<h2>Example with <em>argparse.ArgumentParser</em></h2>\n<pre>import argparse\nimport pynumparser\n\n# Note:  Typical values would likely include 'help' and  'default' parameters.\nparser = argparse.ArgumentParser(description=\"Number printer\")\n\n# Add a simple int parameter, requiring it be between -40 and 130, inclusive:\nparser.add_argument('-a', '--age', type=pynumparser.Number(limits=(-40, 130)))\n\n# Add int sequence, requiring values to be non-negative:\nparser.add_argument('-i', '--ints', type=pynumparser.NumberSequence(limits=(0, None)))\n\n# Add a simple float parameter, requiring it be a positive value less than 1000:\nparser.add_argument('-s', '--seconds', type=pynumparser.Number(numtype=float, limits=(1e-230, 1000)))\n\n# Add a float sequence, requiring the numbers be between 0 and 365.25 inclusive:\nparser.add_argument('-d', '--days', type=pynumparser.NumberSequence(numtype=float, limits=(0, 365.25)))\n\nprint(parser.parse_args())\n</pre>\n<div id=\"examples-numbersequence-results\">\n<h3>Examples <em>NumberSequence</em> Results</h3>\n<p>With the default parameters (<em>numtype=int, limits=None</em>):</p>\n<ul>\n<li><strong>\u201c5\u201d</strong> yields a result of <em>(5)</em>.</li>\n<li><strong>\u201c5-8\u201d</strong> is equivalent to <strong>\u201c5-8/1\u201d</strong> and both yield a result of <em>(5, 6, 7, 8)</em>.</li>\n<li><strong>\u201c3-9/3\u201d</strong> would give a result of <em>(3, 6, 9)</em>.</li>\n<li><strong>\u201c-3-2\u201d</strong> would yield a result of <em>(-3, -2, -1, 0, 1, 2)</em>.</li>\n<li><strong>\u201c-3\u20132\u201d</strong> would yield a result of <em>(-3, -2)</em>.</li>\n<li><strong>\u201c-5-5/5\u201d</strong> would yield a result of <em>(-5, 0, 5)</em>.</li>\n<li><strong>\u201c-8,-9-9/6,12-30/12,5,2,3\u201d</strong> would yield <em>(-8, -9, -3, 3, 9, 12, 24, 5, 2, 3)</em>.</li>\n</ul>\n<p>With parameters (<em>numtype=float</em>, <em>limits=None</em>) the results are floating point numbers:</p>\n<ul>\n<li><strong>\u201c5.125\u201d</strong> yields a result of <em>(5.125)</em>.</li>\n<li><strong>\u201c5,125\u201d</strong> yields a result of <em>(5.0, 125.0)</em> since the comma is a subsequence separator.</li>\n<li><strong>\u201c5-7\u201d</strong> is equivalent to <strong>\u201c5-7/1\u201d</strong> and both yield a result of <em>(5.0, 6.0, 7.0)</em>.</li>\n<li><strong>\u201c0-1/.25\u201d</strong> would give a result of <em>(0.0, 0.25, 0.5, 0.75, 1.0)</em>.</li>\n</ul>\n</div>\n<div id=\"releases\">\n<h3>Releases</h3>\n<blockquote>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td><strong>Version</strong></td>\n<td><strong>Description</strong></td>\n</tr>\n<tr><td>1.0.1</td>\n<td>Initial release</td>\n</tr>\n<tr><td>1.1</td>\n<td>Added the <strong>NumberSequence.contains()</strong> method.</td>\n</tr>\n<tr><td>1.2</td>\n<td>Added the <strong>NumberSequence.encode()</strong> method, fixed documentation on PyPi.</td>\n</tr>\n<tr><td>1.3</td>\n<td>Added the <strong>NumberSequence</strong> format \u201c+\u201d to specify a <em>range size</em>.</td>\n</tr>\n<tr><td>1.4</td>\n<td>Added the <strong>Number.contains()</strong> method and Travis CI test integration.</td>\n</tr>\n<tr><td>1.4.1</td>\n<td>Moved project to host at Gitlab.</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"build-status\">\n<h3>Build Status</h3>\n<a href=\"https://gitlab.com/n2vram/pynumparser/\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7c011ba17486152b5f062a5affba3a7c06e6f4d7/68747470733a2f2f6769746c61622e636f6d2f6e327672616d2f70796e756d7061727365722f6261646765732f6d61737465722f6275696c642e737667\"></a>\n</div>\n<div id=\"known-issues\">\n<h3>Known Issues</h3>\n<ul>\n<li><p>Under some circumstances, floating point representation errors cause the upper range to be\n(unexpectedly) omitted.  This happens due to the internal representation of floating point\nnumbers, and is not limited to this package, or even to Python.  For more information, see:\n<a href=\"https://docs.python.org/2/tutorial/floatingpoint.html#representation-error\" rel=\"nofollow\">Floating Point Arithmetic: Issues and Limitations</a>.</p>\n<ul>\n<li>In the first example (<strong>\u201c0-13/1.3\u201d</strong>), the value of <strong>13</strong> is not included since the previous\nvalue was larger than <strong>11.7</strong>.</li>\n<li>In the second example (<strong>\u201c1.2-2.0/0.2\u201d</strong>) the final value is slightly less than\n<strong>2.0</strong> due to representation error.</li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">pynumparser</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">pynumparser</span><span class=\"o\">.</span><span class=\"n\">NumberSequence</span><span class=\"p\">(</span><span class=\"nb\">float</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"0-13/1.3\"</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">2.6</span><span class=\"p\">,</span> <span class=\"mf\">3.9000000000000004</span><span class=\"p\">,</span> <span class=\"mf\">5.2</span><span class=\"p\">,</span> <span class=\"mf\">6.5</span><span class=\"p\">,</span> <span class=\"mf\">7.8</span><span class=\"p\">,</span> <span class=\"mf\">9.1</span><span class=\"p\">,</span> <span class=\"mf\">10.4</span><span class=\"p\">,</span> <span class=\"mf\">11.700000000000001</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"1.2-2.0/0.2\"</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"mf\">1.2</span><span class=\"p\">,</span> <span class=\"mf\">1.4</span><span class=\"p\">,</span> <span class=\"mf\">1.5999999999999999</span><span class=\"p\">,</span> <span class=\"mf\">1.7999999999999998</span><span class=\"p\">,</span> <span class=\"mf\">1.9999999999999998</span><span class=\"p\">)</span>\n</pre>\n</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4209089, "releases": {"1.4": [{"comment_text": "", "digests": {"md5": "fa6b6d2bae2eb95cdc71caeca2336a70", "sha256": "0f0c2772f10a1f8a62caafd11817d887547f8c09db73c68b921695bee51ac464"}, "downloads": -1, "filename": "pynumparser-1.4.tar.gz", "has_sig": false, "md5_digest": "fa6b6d2bae2eb95cdc71caeca2336a70", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9424, "upload_time": "2018-03-29T22:32:30", "upload_time_iso_8601": "2018-03-29T22:32:30.414514Z", "url": "https://files.pythonhosted.org/packages/3d/6b/41c50baf4bd12a4dc69da7563e4fdd6524aac116f696c52a05a0ae125562/pynumparser-1.4.tar.gz", "yanked": false}], "1.4.1": [{"comment_text": "", "digests": {"md5": "4c304e382fb9b2d65612d55048a1acf5", "sha256": "8fbd5280490ef89fb46e817d63067f6e4542a66b0051c0eaa70afb4961f0aa67"}, "downloads": -1, "filename": "pynumparser-1.4.1.tar.gz", "has_sig": false, "md5_digest": "4c304e382fb9b2d65612d55048a1acf5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9520, "upload_time": "2018-08-26T19:45:26", "upload_time_iso_8601": "2018-08-26T19:45:26.865053Z", "url": "https://files.pythonhosted.org/packages/8e/04/cf25994a95759a6763ae76e0f0d53d602afaf460acae232b472f1f80a952/pynumparser-1.4.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4c304e382fb9b2d65612d55048a1acf5", "sha256": "8fbd5280490ef89fb46e817d63067f6e4542a66b0051c0eaa70afb4961f0aa67"}, "downloads": -1, "filename": "pynumparser-1.4.1.tar.gz", "has_sig": false, "md5_digest": "4c304e382fb9b2d65612d55048a1acf5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9520, "upload_time": "2018-08-26T19:45:26", "upload_time_iso_8601": "2018-08-26T19:45:26.865053Z", "url": "https://files.pythonhosted.org/packages/8e/04/cf25994a95759a6763ae76e0f0d53d602afaf460acae232b472f1f80a952/pynumparser-1.4.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:58 2020"}