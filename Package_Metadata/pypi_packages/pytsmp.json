{"info": {"author": "Kit-Ho Mak", "author_email": "kithomak23@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "License :: OSI Approved :: MIT License", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "pytsmp\n======\n\n\n.. image:: https://img.shields.io/pypi/v/pytsmp.svg\n   :target: https://pypi.python.org/pypi/pytsmp\n   :alt: Latest PyPI version\n\n.. image:: https://codecov.io/gh/kithomak/pytsmp/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/kithomak/pytsmp/branch/master\n   :alt: Latest Codecov status\n\n\n.. image:: https://travis-ci.org/kithomak/pytsmp.png\n   :target: https://travis-ci.org/kithomak/pytsmp\n   :alt: Latest Travis CI build status\n\n\n``pytsmp`` is a Python implementation of the matrix profile. More details about matrix profile can be\nfound in the `UCR Matrix Profile Page <http://www.cs.ucr.edu/~eamonn/MatrixProfile.html>`_\nby the paper authors.\n\nCurrently support MASS and the matrix profile algorithms STAMP, STOMP, SCRIMP++ (no multi-core or GPU support yet),\nand some convenience functions such as discords and motifs finding. I plan to implement the parallelized version\nof the matrix profile algorithms later.\n\nThe original implementation (in R) of the paper authors from the UCR group can be found\n`here <https://github.com/franzbischoff/tsmp>`_.\n\n\nInstallation\n------------\n\n``pytsmp`` is available via pip.\n\n.. code:: bash\n\n   pip install pytsmp\n\n\nUsage\n-----\n\nTo compute the matrix profile using STAMP, use the following code.\n\n.. code:: python\n\n   import numpy as np\n   from pytsmp import STAMP\n\n   # create a 1000 step random walk and a random query\n   ts = np.cumsum(np.random.randint(2, size=(1000,)) * 2 - 1)\n   query = np.random.rand(200)\n\n   # Create the STAMP object. Note that computation starts immediately.\n   mp = STAMP(ts, query, window_size=50)  # window_size must be specified as a named argument\n\n   # get the matrix profile and the profile indexes\n   mat_profile, ind_profile = mp.get_profiles()\n\nIncremental of the time series and the query is supported.\n\n.. code:: python\n\n   import numpy as np\n   from pytsmp import STAMP\n\n   # create a 1000 step random walk and its matrix profile\n   ts = np.cumsum(np.random.randint(2, size=(1000,)) * 2 - 1)\n   mp = STAMP(ts, window_size=50)\n   mat_profile, _ = mp.get_profiles()\n\n   # create the matrix profile of the first 999 steps and increment the last step later\n   mp_inc = STAMP(ts[:-1], window_size=50)\n   mp_inc.update_ts1(ts[-1])  # similarly, you can update the query by update_ts2()\n   mat_profile_inc, _ = mp_inc.get_profiles()\n\n   print(np.allclose(mat_profile, mat_profile_inc))  # True\n\n\nBenchmark\n---------\n\nPerform a simple trial run on a random walk with 40000 data points.\n\n.. code:: python\n\n   import numpy as np\n   from pytsmp import STAMP\n\n   np.random.seed(42)  # fix a seed to control randomness\n   ts = np.cumsum(np.random.randint(2, size=(40000,)) * 2 - 1)\n\n   # ipython magic command\n   %timeit mp = STAMP(ts, window_size=1000, verbose=False, seed=42)\n\n   # and similarly for STOMP and SCRIMP\n\nOn my MacBook Pro with 2.2 GHz Intel Core i7, the results are (all over 7 runs, 1 loop each):\n\n.. list-table::\n   :widths: 25 25 25 25\n   :header-rows: 1\n   :align: center\n\n   * - Algorithm\n     - Data Size\n     - Window Size\n     - Elapsed Time\n   * - STAMP\n     - 40000\n     - 1000\n     - 2min 14s \u00b1 392ms\n   * - STOMP\n     - 40000\n     - 1000\n     - 22.1s \u00b1 52.8ms\n   * - SCRIMP (without PreSCRIMP)\n     - 40000\n     - 1000\n     - 23.6s \u00b1 402ms\n   * - PreSCRIMP (Approximate algorithm)\n     - 40000\n     - 1000\n     - 606ms \u00b1 9.5ms\n\n\n\n.. comment\n   License\n   -------\n\n\nReference\n---------\n\nC.C.M. Yeh, Y. Zhu, L. Ulanova, N. Begum, Y. Ding, H.A. Dau, D. Silva, A. Mueen and E. Keogh.\n\"Matrix profile I: All pairs similarity joins for time series: A unifying view that includes\nmotifs, discords and shapelets\". IEEE ICDM 2016.\n\nY. Zhu, Z. Zimmerman, N.S. Senobari, C.C.M. Yeh, G. Funning, A. Mueen, P. Berisk and E. Keogh.\n\"Matrix Profile II: Exploiting a Novel Algorithm and GPUs to Break the One Hundred Million\nBarrier for Time Series Motifs and Joins\". IEEE ICDM 2016.\n\nY. Zhu, C.C.M. Yeh, Z. Zimmerman, K. Kamgar and E. Keogh.\n\"Matrix Pro\ufb01le XI: SCRIMP++: Time Series Motif Discovery at Interactive Speed\". IEEE ICDM 2018.\n\n\nDisclaimer\n----------\nThis project is for my own learning and understanding purpose, and I may not be able to\nactively develop it from time to time. If you need a Python implementation of the matrix\nprofile, you may try `matrixprofile-ts <https://github.com/target/matrixprofile-ts>`_.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kithomak/pytsmp", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pytsmp", "package_url": "https://pypi.org/project/pytsmp/", "platform": "", "project_url": "https://pypi.org/project/pytsmp/", "project_urls": {"Homepage": "https://github.com/kithomak/pytsmp"}, "release_url": "https://pypi.org/project/pytsmp/0.3.0/", "requires_dist": null, "requires_python": "", "summary": "A Python implementation of the matrix profile", "version": "0.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.python.org/pypi/pytsmp\" rel=\"nofollow\"><img alt=\"Latest PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b2f3b9c87f88bd57b27b65181d80faefb078b762/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f707974736d702e737667\"></a>\n<a href=\"https://codecov.io/gh/kithomak/pytsmp/branch/master\" rel=\"nofollow\"><img alt=\"Latest Codecov status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2572390791c802ae94151869e7148adb3d03d0f3/68747470733a2f2f636f6465636f762e696f2f67682f6b6974686f6d616b2f707974736d702f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://travis-ci.org/kithomak/pytsmp\" rel=\"nofollow\"><img alt=\"Latest Travis CI build status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/aade74fd2279ef87dab8140f4a05caf8ab547c7b/68747470733a2f2f7472617669732d63692e6f72672f6b6974686f6d616b2f707974736d702e706e67\"></a>\n<p><tt>pytsmp</tt> is a Python implementation of the matrix profile. More details about matrix profile can be\nfound in the <a href=\"http://www.cs.ucr.edu/~eamonn/MatrixProfile.html\" rel=\"nofollow\">UCR Matrix Profile Page</a>\nby the paper authors.</p>\n<p>Currently support MASS and the matrix profile algorithms STAMP, STOMP, SCRIMP++ (no multi-core or GPU support yet),\nand some convenience functions such as discords and motifs finding. I plan to implement the parallelized version\nof the matrix profile algorithms later.</p>\n<p>The original implementation (in R) of the paper authors from the UCR group can be found\n<a href=\"https://github.com/franzbischoff/tsmp\" rel=\"nofollow\">here</a>.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p><tt>pytsmp</tt> is available via pip.</p>\n<pre>pip install pytsmp\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>To compute the matrix profile using STAMP, use the following code.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pytsmp</span> <span class=\"kn\">import</span> <span class=\"n\">STAMP</span>\n\n<span class=\"c1\"># create a 1000 step random walk and a random query</span>\n<span class=\"n\">ts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">,))</span> <span class=\"o\">*</span> <span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create the STAMP object. Note that computation starts immediately.</span>\n<span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">STAMP</span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span> <span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">)</span>  <span class=\"c1\"># window_size must be specified as a named argument</span>\n\n<span class=\"c1\"># get the matrix profile and the profile indexes</span>\n<span class=\"n\">mat_profile</span><span class=\"p\">,</span> <span class=\"n\">ind_profile</span> <span class=\"o\">=</span> <span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">get_profiles</span><span class=\"p\">()</span>\n</pre>\n<p>Incremental of the time series and the query is supported.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pytsmp</span> <span class=\"kn\">import</span> <span class=\"n\">STAMP</span>\n\n<span class=\"c1\"># create a 1000 step random walk and its matrix profile</span>\n<span class=\"n\">ts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">,))</span> <span class=\"o\">*</span> <span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">STAMP</span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">)</span>\n<span class=\"n\">mat_profile</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">get_profiles</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># create the matrix profile of the first 999 steps and increment the last step later</span>\n<span class=\"n\">mp_inc</span> <span class=\"o\">=</span> <span class=\"n\">STAMP</span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">window_size</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">)</span>\n<span class=\"n\">mp_inc</span><span class=\"o\">.</span><span class=\"n\">update_ts1</span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>  <span class=\"c1\"># similarly, you can update the query by update_ts2()</span>\n<span class=\"n\">mat_profile_inc</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">mp_inc</span><span class=\"o\">.</span><span class=\"n\">get_profiles</span><span class=\"p\">()</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">allclose</span><span class=\"p\">(</span><span class=\"n\">mat_profile</span><span class=\"p\">,</span> <span class=\"n\">mat_profile_inc</span><span class=\"p\">))</span>  <span class=\"c1\"># True</span>\n</pre>\n</div>\n<div id=\"benchmark\">\n<h2>Benchmark</h2>\n<p>Perform a simple trial run on a random walk with 40000 data points.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pytsmp</span> <span class=\"kn\">import</span> <span class=\"n\">STAMP</span>\n\n<span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">seed</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">)</span>  <span class=\"c1\"># fix a seed to control randomness</span>\n<span class=\"n\">ts</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">40000</span><span class=\"p\">,))</span> <span class=\"o\">*</span> <span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># ipython magic command</span>\n<span class=\"o\">%</span><span class=\"n\">timeit</span> <span class=\"n\">mp</span> <span class=\"o\">=</span> <span class=\"n\">STAMP</span><span class=\"p\">(</span><span class=\"n\">ts</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># and similarly for STOMP and SCRIMP</span>\n</pre>\n<p>On my MacBook Pro with 2.2 GHz Intel Core i7, the results are (all over 7 runs, 1 loop each):</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Algorithm</th>\n<th>Data Size</th>\n<th>Window Size</th>\n<th>Elapsed Time</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>STAMP</td>\n<td>40000</td>\n<td>1000</td>\n<td>2min 14s \u00b1 392ms</td>\n</tr>\n<tr><td>STOMP</td>\n<td>40000</td>\n<td>1000</td>\n<td>22.1s \u00b1 52.8ms</td>\n</tr>\n<tr><td>SCRIMP (without PreSCRIMP)</td>\n<td>40000</td>\n<td>1000</td>\n<td>23.6s \u00b1 402ms</td>\n</tr>\n<tr><td>PreSCRIMP (Approximate algorithm)</td>\n<td>40000</td>\n<td>1000</td>\n<td>606ms \u00b1 9.5ms</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"reference\">\n<h2>Reference</h2>\n<p>C.C.M. Yeh, Y. Zhu, L. Ulanova, N. Begum, Y. Ding, H.A. Dau, D. Silva, A. Mueen and E. Keogh.\n\u201cMatrix profile I: All pairs similarity joins for time series: A unifying view that includes\nmotifs, discords and shapelets\u201d. IEEE ICDM 2016.</p>\n<p>Y. Zhu, Z. Zimmerman, N.S. Senobari, C.C.M. Yeh, G. Funning, A. Mueen, P. Berisk and E. Keogh.\n\u201cMatrix Profile II: Exploiting a Novel Algorithm and GPUs to Break the One Hundred Million\nBarrier for Time Series Motifs and Joins\u201d. IEEE ICDM 2016.</p>\n<p>Y. Zhu, C.C.M. Yeh, Z. Zimmerman, K. Kamgar and E. Keogh.\n\u201cMatrix Pro\ufb01le XI: SCRIMP++: Time Series Motif Discovery at Interactive Speed\u201d. IEEE ICDM 2018.</p>\n</div>\n<div id=\"disclaimer\">\n<h2>Disclaimer</h2>\n<p>This project is for my own learning and understanding purpose, and I may not be able to\nactively develop it from time to time. If you need a Python implementation of the matrix\nprofile, you may try <a href=\"https://github.com/target/matrixprofile-ts\" rel=\"nofollow\">matrixprofile-ts</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 5801452, "releases": {"0.3.0": [{"comment_text": "", "digests": {"md5": "082b98006367cc89f59828a8a00bd695", "sha256": "a923c1aed2f4eaa46b5c8aa70c1432b0e14fe7762cc1555b9d0d2c03270c0b90"}, "downloads": -1, "filename": "pytsmp-0.3.0.tar.gz", "has_sig": false, "md5_digest": "082b98006367cc89f59828a8a00bd695", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11129, "upload_time": "2019-09-09T03:04:36", "upload_time_iso_8601": "2019-09-09T03:04:36.562064Z", "url": "https://files.pythonhosted.org/packages/ff/95/cdde3543951d3b2ba34a161b54628603a191561f2bc88589e3247800e2a3/pytsmp-0.3.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "082b98006367cc89f59828a8a00bd695", "sha256": "a923c1aed2f4eaa46b5c8aa70c1432b0e14fe7762cc1555b9d0d2c03270c0b90"}, "downloads": -1, "filename": "pytsmp-0.3.0.tar.gz", "has_sig": false, "md5_digest": "082b98006367cc89f59828a8a00bd695", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11129, "upload_time": "2019-09-09T03:04:36", "upload_time_iso_8601": "2019-09-09T03:04:36.562064Z", "url": "https://files.pythonhosted.org/packages/ff/95/cdde3543951d3b2ba34a161b54628603a191561f2bc88589e3247800e2a3/pytsmp-0.3.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:13:00 2020"}