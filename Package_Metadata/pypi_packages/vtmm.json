{"info": {"author": "Ian Williamson", "author_email": "ian.williamson@ieee.org", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# vtmm (vectorized transfer matrix method)\n\n`vtmm` is a vectorized implementation of the [transfer matrix method](https://arxiv.org/abs/1603.02720) for computing the optical reflection and transmission of multilayer planar stacks. This package is in **beta**.\n\n![](../master/img/spectrum_pcolor.png)\n\nThe `vtmm` package supports some of the same functionality as the [tmm](https://github.com/sbyrnes321/tmm) Python package developed by Steven Byrnes. However, in `vtmm` all operations are vectorized over angles / wavevectors as well as frequencies. Due to the small size of the matrices involved in the transfer matrix method (2 x 2), such vectorization results in significant performance gains, especially for large structures and many frequencies / wavevectors. \n\nIn some cases we have observed approximately two orders of magnitude difference in execution time between the two implementations (see below). The much lower execution time in `vtmm` may be useful for applications which require many evaluations of the reflection and transmission coefficients, such as in fitting or optimization.\n\n## Gradients\n\nCurrently `vtmm` uses Tensor Flow as its backend. This means that gradients of scalar loss / objective functions of the transmission and reflection can be taken for free. At a later time a numpy backend may be implemented for users that do not need gradient functionality and/or do not want Tensor Flow as a requirement.\n\n## Example\n\nThe entry point to `vtmm` is the function `tmm_rt(pol, omega, kx, n, d)`. See the example below for a basic illustration of how to use the package.\n\n```python\nimport tensorflow as tf\nfrom vtmm import tmm_rt\n\npol = 's'\nn = tf.constant([1.0, 3.5, 1.0]) # Layer refractive indices \nd = tf.constant([2e-6]) # Layer thicknesses \nkx = tf.linspace(0.0, 2*np.pi*220e12/299792458, 1000) # Parallel wavevectors\nomega = tf.linspace(150e12, 220e12, 1000) * 2 * np.pi # Angular frequencies\n\n# t and r will be 2D tensors of shape [ num kx, num omega ]\nt, r = tmm_rt(pol, omega, kx, n, d)\n```\n\n## Benchmarks\n\nSee `tests/test_benchmark.py` for a comparison between `vtmm` and the non-vectorized `tmm` package. The benchmarks shown below are for `len(omega) == len(kx) == 50` and 75 timeit evaluations.\n\n```\npython -W ignore ./tests/test_benchmark.py\n```\n\n```\nSingle omega / kx benchmark\nvtmm: 0.2432 s\ntmm:  0.0401 s\n\nLarge stack benchmark\nvtmm: 0.7811 s\ntmm:  79.8765 s\n\nMedium stack benchmark\nvtmm: 0.4607 s\ntmm:  52.2255 s\n\nSmall stack benchmark\nvtmm: 0.3367 s\ntmm:  41.0926 s\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/fancompute/vtmm", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "vtmm", "package_url": "https://pypi.org/project/vtmm/", "platform": "", "project_url": "https://pypi.org/project/vtmm/", "project_urls": {"Homepage": "https://github.com/fancompute/vtmm"}, "release_url": "https://pypi.org/project/vtmm/0.1/", "requires_dist": ["tensorflow (>2.0)", "numpy (>=1.16)"], "requires_python": "", "summary": "Vectorized transfer matrix method (TMM) for computing the optical reflection and transmission of multilayer planar stacks", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>vtmm (vectorized transfer matrix method)</h1>\n<p><code>vtmm</code> is a vectorized implementation of the <a href=\"https://arxiv.org/abs/1603.02720\" rel=\"nofollow\">transfer matrix method</a> for computing the optical reflection and transmission of multilayer planar stacks. This package is in <strong>beta</strong>.</p>\n<p><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e44803c2c13efd01aae22cc325d428d03399fa13/2e2e2f6d61737465722f696d672f737065637472756d5f70636f6c6f722e706e67\"></p>\n<p>The <code>vtmm</code> package supports some of the same functionality as the <a href=\"https://github.com/sbyrnes321/tmm\" rel=\"nofollow\">tmm</a> Python package developed by Steven Byrnes. However, in <code>vtmm</code> all operations are vectorized over angles / wavevectors as well as frequencies. Due to the small size of the matrices involved in the transfer matrix method (2 x 2), such vectorization results in significant performance gains, especially for large structures and many frequencies / wavevectors.</p>\n<p>In some cases we have observed approximately two orders of magnitude difference in execution time between the two implementations (see below). The much lower execution time in <code>vtmm</code> may be useful for applications which require many evaluations of the reflection and transmission coefficients, such as in fitting or optimization.</p>\n<h2>Gradients</h2>\n<p>Currently <code>vtmm</code> uses Tensor Flow as its backend. This means that gradients of scalar loss / objective functions of the transmission and reflection can be taken for free. At a later time a numpy backend may be implemented for users that do not need gradient functionality and/or do not want Tensor Flow as a requirement.</p>\n<h2>Example</h2>\n<p>The entry point to <code>vtmm</code> is the function <code>tmm_rt(pol, omega, kx, n, d)</code>. See the example below for a basic illustration of how to use the package.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"k\">as</span> <span class=\"nn\">tf</span>\n<span class=\"kn\">from</span> <span class=\"nn\">vtmm</span> <span class=\"kn\">import</span> <span class=\"n\">tmm_rt</span>\n\n<span class=\"n\">pol</span> <span class=\"o\">=</span> <span class=\"s1\">'s'</span>\n<span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">([</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">3.5</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">])</span> <span class=\"c1\"># Layer refractive indices </span>\n<span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">([</span><span class=\"mf\">2e-6</span><span class=\"p\">])</span> <span class=\"c1\"># Layer thicknesses </span>\n<span class=\"n\">kx</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"mf\">220e12</span><span class=\"o\">/</span><span class=\"mi\">299792458</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">)</span> <span class=\"c1\"># Parallel wavevectors</span>\n<span class=\"n\">omega</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mf\">150e12</span><span class=\"p\">,</span> <span class=\"mf\">220e12</span><span class=\"p\">,</span> <span class=\"mi\">1000</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"c1\"># Angular frequencies</span>\n\n<span class=\"c1\"># t and r will be 2D tensors of shape [ num kx, num omega ]</span>\n<span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">tmm_rt</span><span class=\"p\">(</span><span class=\"n\">pol</span><span class=\"p\">,</span> <span class=\"n\">omega</span><span class=\"p\">,</span> <span class=\"n\">kx</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n</pre>\n<h2>Benchmarks</h2>\n<p>See <code>tests/test_benchmark.py</code> for a comparison between <code>vtmm</code> and the non-vectorized <code>tmm</code> package. The benchmarks shown below are for <code>len(omega) == len(kx) == 50</code> and 75 timeit evaluations.</p>\n<pre><code>python -W ignore ./tests/test_benchmark.py\n</code></pre>\n<pre><code>Single omega / kx benchmark\nvtmm: 0.2432 s\ntmm:  0.0401 s\n\nLarge stack benchmark\nvtmm: 0.7811 s\ntmm:  79.8765 s\n\nMedium stack benchmark\nvtmm: 0.4607 s\ntmm:  52.2255 s\n\nSmall stack benchmark\nvtmm: 0.3367 s\ntmm:  41.0926 s\n</code></pre>\n\n          </div>"}, "last_serial": 6490271, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "a9d6ce8051c2693d141cbd34da3968ca", "sha256": "3b1ad674681b071022dab9867c5894fb8b0e1eacb7585951998ca694cc1433aa"}, "downloads": -1, "filename": "vtmm-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a9d6ce8051c2693d141cbd34da3968ca", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5141, "upload_time": "2020-01-20T21:11:46", "upload_time_iso_8601": "2020-01-20T21:11:46.327806Z", "url": "https://files.pythonhosted.org/packages/57/61/0ebfd6cc1de9e6c760214dfac6eba3eaf26b487676405136160aa7fa7265/vtmm-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f4cb36bc398888349e7ed9f7730cc2ce", "sha256": "adfe2994ca57d68849669e78954a7fe01c20aafbc61b5dc2256ae9a19ba3bd81"}, "downloads": -1, "filename": "vtmm-0.1.tar.gz", "has_sig": false, "md5_digest": "f4cb36bc398888349e7ed9f7730cc2ce", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3729, "upload_time": "2020-01-20T21:11:48", "upload_time_iso_8601": "2020-01-20T21:11:48.527652Z", "url": "https://files.pythonhosted.org/packages/7f/75/4cc6eaec651b1b199ee7d535ba1ed201de18b9a7061dca1084df8335f3c5/vtmm-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a9d6ce8051c2693d141cbd34da3968ca", "sha256": "3b1ad674681b071022dab9867c5894fb8b0e1eacb7585951998ca694cc1433aa"}, "downloads": -1, "filename": "vtmm-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a9d6ce8051c2693d141cbd34da3968ca", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5141, "upload_time": "2020-01-20T21:11:46", "upload_time_iso_8601": "2020-01-20T21:11:46.327806Z", "url": "https://files.pythonhosted.org/packages/57/61/0ebfd6cc1de9e6c760214dfac6eba3eaf26b487676405136160aa7fa7265/vtmm-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f4cb36bc398888349e7ed9f7730cc2ce", "sha256": "adfe2994ca57d68849669e78954a7fe01c20aafbc61b5dc2256ae9a19ba3bd81"}, "downloads": -1, "filename": "vtmm-0.1.tar.gz", "has_sig": false, "md5_digest": "f4cb36bc398888349e7ed9f7730cc2ce", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3729, "upload_time": "2020-01-20T21:11:48", "upload_time_iso_8601": "2020-01-20T21:11:48.527652Z", "url": "https://files.pythonhosted.org/packages/7f/75/4cc6eaec651b1b199ee7d535ba1ed201de18b9a7061dca1084df8335f3c5/vtmm-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:33:44 2020"}