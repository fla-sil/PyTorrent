{"info": {"author": "Martijn Faassen, Jan-Wijbrand Kolman", "author_email": "faassen@startifact.com", "bugtrack_url": null, "classifiers": [], "description": "Schema To XML\n*************\n\nIntroduction\n============\n\nThis package can convert objects described by Zope 3 schema to simple\nXML structures. It's also able to convert this XML back into objects.\nThe export and import processes are completely schema-driven; any\nattribute not described in the schema is not seen by this system at\nall.\n\nThis system can be used to create export and import systems for Zope 3\napplications. It could also be used to provide XML representations of\nobjects for other purposes, such as XSLT transformations, or even just\nto get a full-text representation for index purposes.\n\nThe package lies on ``lxml`` for the serialization to XML. \n\nSerialization\n=============\n\nLet's first define a simple Zope 3 schema::\n\n    >>> from zope import interface, schema\n    >>> class IName(interface.Interface):\n    ...     first_name = schema.TextLine(title=u'First name')\n    ...     last_name = schema.TextLine(title=u'Last name')\n\nLet's now make a class that implements this schema::\n\n    >>> from zope.interface import implements\n    >>> class Name(object):\n    ...     implements(IName)\n    ...     def __init__(self, first_name, last_name):\n    ...         self.first_name = first_name\n    ...         self.last_name = last_name\n\nLet's make an instance of the class::\n\n    >>> name = Name('Karel', 'Titulaer')\n\nNow let's serialize it to XML:\n\n    >>> from z3c.schema2xml import serialize\n    >>> print serialize('container', IName, name)\n    <container>\n      <first_name>Karel</first_name>\n      <last_name>Titulaer</last_name>\n    </container>\n\nThis also works for other kinds of fields::\n\n    >>> from zope import interface, schema\n    >>> class IAddress(interface.Interface):\n    ...     street_name = schema.TextLine(title=u'Street name')\n    ...     number = schema.Int(title=u'House number')\n    >>> class Address(object):\n    ...     implements(IAddress)\n    ...     def __init__(self, street_name, number):\n    ...         self.street_name = street_name\n    ...         self.number = number\n    >>> address = Address('Hofplein', 42)\n    >>> print serialize('container', IAddress, address)\n    <container>\n      <street_name>Hofplein</street_name>\n      <number>42</number>\n    </container>\n\nIf a field is not filled in, the serialization will result in an empty\nelement::\n\n    >>> address2 = Address(None, None)\n    >>> print serialize('container', IAddress, address2)\n    <container>\n      <street_name/>\n      <number/>\n    </container>\n\nIf a schema defines an Object field with its own schema, the serialization\ncan also handle this::\n\n    >>> class IPerson(interface.Interface):\n    ...     name = schema.Object(title=u\"Name\", schema=IName)\n    ...     address = schema.Object(title=u\"Address\", schema=IAddress)\n\n    >>> class Person(object):\n    ...     implements(IPerson)\n    ...     def __init__(self, name, address):\n    ...         self.name = name\n    ...         self.address = address\n\n    >>> person = Person(name, address)\n    >>> print serialize('person', IPerson, person)\n    <person>\n      <name>\n        <first_name>Karel</first_name>\n        <last_name>Titulaer</last_name>\n      </name>\n      <address>\n        <street_name>Hofplein</street_name>\n        <number>42</number>\n      </address>\n    </person>\n\nA schema can also define a List field with elements with their own\nschema. Let's make an object and serialize it::\n\n    >>> class ICommission(interface.Interface):\n    ...     members = schema.List(\n    ...         title=u\"Commission\",\n    ...         value_type=schema.Object(__name__='person',\n    ...         schema=IPerson))\n\nNote that we have to explicitly specify __name__ for the field that's\nused for value_type here, otherwise we have no name to serialize to\nXML with.\n\n    >>> class Commission(object):\n    ...     implements(ICommission)\n    ...     def __init__(self, members):\n    ...         self.members = members\n\n    >>> commission = Commission(\n    ...     [person, Person(Name('Chriet', 'Titulaer'), Address('Ruimteweg', 3))])\n    >>> print serialize('commission', ICommission, commission)\n    <commission>\n      <members>\n        <person>\n          <name>\n            <first_name>Karel</first_name>\n            <last_name>Titulaer</last_name>\n          </name>\n          <address>\n            <street_name>Hofplein</street_name>\n            <number>42</number>\n          </address>\n        </person>\n        <person>\n          <name>\n            <first_name>Chriet</first_name>\n            <last_name>Titulaer</last_name>\n          </name>\n          <address>\n            <street_name>Ruimteweg</street_name>\n            <number>3</number>\n          </address>\n        </person>\n      </members>\n    </commission>\n\nWe get an adapter lookop failure whenever we try to serialize a field type for\nwhich there's no an serializer::\n\n    >>> class IWithNonSerializableField(interface.Interface):\n    ...     field = schema.Field(title=u\"Commission\")\n    >>> class NotSerializable(object):\n    ...     implements(IWithNonSerializableField)\n    ...     def __init__(self, value):\n    ...         self.field = value\n    >>> not_serializable = NotSerializable(None)\n    >>> serialize('noway', IWithNonSerializableField, not_serializable)\n    Traceback (most recent call last):\n     ...\n    TypeError: ('Could not adapt', <zope.schema._bootstrapfields.Field object at ...>, <InterfaceClass z3c.schema2xml._schema2xml.IXMLGenerator>)\n\nDeserialization\n===============\n\nNow we want to deserialize XML according to a schema to an object that\nprovides this schema.\n\n    >>> from z3c.schema2xml import deserialize\n    >>> xml = '''\n    ...  <container>\n    ...    <first_name>Karel</first_name>\n    ...    <last_name>Titulaer</last_name>\n    ...  </container>\n    ...  '''\n    >>> name = Name('', '')\n    >>> deserialize(xml, IName, name)\n    >>> name.first_name\n    u'Karel'\n    >>> name.last_name\n    u'Titulaer'\n\nThe order of the fields in XML does not matter::\n\n    >>> xml = '''\n    ...  <container>\n    ...    <last_name>Titulaer</last_name>\n    ...    <first_name>Karel</first_name>\n    ...  </container>\n    ...  '''\n    >>> name = Name('', '')\n    >>> deserialize(xml, IName, name)\n    >>> name.first_name\n    u'Karel'\n    >>> name.last_name\n    u'Titulaer'\n\nAfter deserialization, the object alsoProvides the schema interface::\n\n    >>> IName.providedBy(name)\n    True\n\nThis also works for other kinds of fields::\n\n    >>> xml = '''\n    ...  <container>\n    ...    <street_name>Hofplein</street_name>\n    ...    <number>42</number>\n    ...  </container>\n    ...  '''\n    >>> address = Address('', 0)\n    >>> deserialize(xml, IAddress, address)\n    >>> address.street_name\n    u'Hofplein'\n    >>> address.number\n    42\n\nIf a schema defines an Object field with its own schema, the serialization\ncan also handle this::\n\n    >>> xml = '''\n    ...  <person>\n    ...    <name>\n    ...      <first_name>Karel</first_name>\n    ...      <last_name>Titulaer</last_name>\n    ...    </name>\n    ...    <address>\n    ...      <street_name>Hofplein</street_name>\n    ...      <number>42</number>\n    ...    </address>\n    ...  </person>\n    ...  '''\n    >>> person = Person(Name('', ''), Address('', 0))\n    >>> deserialize(xml, IPerson, person)\n    >>> person.name.first_name\n    u'Karel'\n    >>> person.name.last_name\n    u'Titulaer'\n    >>> person.address.street_name\n    u'Hofplein'\n    >>> person.address.number\n    42\n    >>> IPerson.providedBy(person)\n    True\n    >>> IName.providedBy(person.name)\n    True\n    >>> IAddress.providedBy(person.address)\n    True\n\nAgain the order in which the fields come in XML shouldn't matter::\n\n    >>> xml = '''\n    ...  <person>\n    ...    <address>\n    ...      <number>42</number>\n    ...      <street_name>Hofplein</street_name>\n    ...    </address>\n    ...    <name>\n    ...      <last_name>Titulaer</last_name>\n    ...      <first_name>Karel</first_name>\n    ...    </name>\n    ...  </person>\n    ...  '''\n    >>> person = Person(Name('', ''), Address('', 0))\n    >>> deserialize(xml, IPerson, person)\n    >>> person.name.first_name\n    u'Karel'\n    >>> person.name.last_name\n    u'Titulaer'\n    >>> person.address.street_name\n    u'Hofplein'\n    >>> person.address.number\n    42\n    >>> IPerson.providedBy(person)\n    True\n    >>> IName.providedBy(person.name)\n    True\n    >>> IAddress.providedBy(person.address)\n    True\n\n    >>> xml = '''\n    ... <commission>\n    ...  <members>\n    ...    <person>\n    ...      <name>\n    ...        <first_name>Karel</first_name>\n    ...        <last_name>Titulaer</last_name>\n    ...      </name>\n    ...      <address>\n    ...        <street_name>Hofplein</street_name>\n    ...        <number>42</number>\n    ...      </address>\n    ...    </person>\n    ...    <person>\n    ...      <name>\n    ...        <first_name>Chriet</first_name>\n    ...        <last_name>Titulaer</last_name>\n    ...     </name>\n    ...      <address>\n    ...        <street_name>Ruimteweg</street_name>\n    ...        <number>3</number>\n    ...      </address>\n    ...    </person>\n    ...  </members>\n    ... </commission>\n    ... '''\n\n    >>> commission = Commission([])\n    >>> deserialize(xml, ICommission, commission)\n    >>> len(commission.members)\n    2\n    >>> member = commission.members[0]\n    >>> member.name.first_name\n    u'Karel'\n    >>> member.address.street_name\n    u'Hofplein'\n    >>> member = commission.members[1]\n    >>> member.name.first_name\n    u'Chriet'\n    >>> member.address.street_name\n    u'Ruimteweg'\n\nWhenever the XML element is empty, the resulting value should be None:\n\n    >>> from z3c.schema2xml import deserialize\n    >>> xml = '''\n    ...  <container>\n    ...    <first_name></first_name>\n    ...    <last_name/>\n    ...  </container>\n    ...  '''\n    >>> name = Name('', '')\n    >>> deserialize(xml, IName, name)\n    >>> name.first_name is None\n    True\n    >>> name.last_name is None\n    True\n\nFor all kinds of fields, like strings and ints...::\n\n    >>> xml = '''\n    ...  <container>\n    ...    <street_name/>\n    ...    <number/>\n    ...  </container>\n    ...  '''\n    >>> address = Address('', 0)\n    >>> deserialize(xml, IAddress, address)\n    >>> address.street_name is None\n    True\n    >>> address.number is None\n    True\n\n...and the fields of subobjects (but not the subobject themselves!)::\n\n    >>> xml = '''\n    ...  <person>\n    ...    <name>\n    ...      <first_name/>\n    ...      <last_name/>\n    ...    </name>\n    ...    <address>\n    ...      <street_name/>\n    ...      <number/>\n    ...    </address>\n    ...  </person>\n    ...  '''\n    >>> person = Person(Name('', ''), Address('', 0))\n    >>> deserialize(xml, IPerson, person)\n    >>> person.name.first_name is None\n    True\n    >>> person.name.last_name is None\n    True\n    >>> IPerson.providedBy(person)\n    True\n    >>> IName.providedBy(person.name)\n    True\n    >>> person.address is None\n    False\n    >>> person.address.street_name is None\n    True\n    >>> person.address.number is None\n    True\n    >>> IAddress.providedBy(person.address)\n    True\n\nSimilarly, where a sequence is expected the value should be an empty sequence:\n\n    >>> xml = '''\n    ... <commission>\n    ...   <members/>\n    ... </commission>\n    ... '''\n    >>> commission = Commission([])\n    >>> deserialize(xml, ICommission, commission)\n    >>> len(commission.members)\n    0\n\nTextLine, Int, Object and List have just been tested. Now follow tests\nfor the other field types that have a serializer.\n\nDatetime\n========\n\nDatetime objects::\n\n    >>> from datetime import datetime\n    >>> class IWithDatetime(interface.Interface):\n    ...     datetime = schema.Datetime(title=u'Date and time')\n    >>> class WithDatetime(object):\n    ...     implements(IWithDatetime)\n    ...     def __init__(self, datetime):\n    ...         self.datetime = datetime\n    >>> with_datetime = WithDatetime(datetime(2006, 12, 31))\n    >>> xml = serialize('container', IWithDatetime, with_datetime)\n    >>> print xml\n    <container>\n      <datetime>2006-12-31T00:00:00</datetime>\n    </container>\n    >>> new_datetime = WithDatetime(None)\n    >>> deserialize(xml, IWithDatetime, new_datetime)\n    >>> new_datetime.datetime.year\n    2006\n    >>> new_datetime.datetime.month\n    12\n    >>> new_datetime.datetime.day\n    31\n\nLet's try it with the field not filled in::\n\n    >>> with_datetime = WithDatetime(None)\n    >>> xml = serialize('container', IWithDatetime, with_datetime)\n    >>> print xml\n    <container>\n      <datetime/>\n    </container>\n    >>> new_datetime= WithDatetime(None)\n    >>> deserialize(xml, IWithDatetime, new_datetime)\n    >>> new_datetime.datetime is None\n    True\n\nChoice\n======\n\nChoice fields. For now, we only work with Choice fields that have \ntext values::\n\n\n    >>> from zc.sourcefactory.basic import BasicSourceFactory\n    >>> class ChoiceSource(BasicSourceFactory):\n    ...     def getValues(self):\n    ...         return [u'alpha', u'beta']\n    >>> class IWithChoice(interface.Interface):\n    ...     choice = schema.Choice(title=u'Choice', required=False,\n    ...                            source=ChoiceSource())\n    >>> class WithChoice(object):\n    ...     implements(IWithChoice)\n    ...     def __init__(self, choice):\n    ...         self.choice = choice\n    >>> with_choice = WithChoice('alpha')\n    >>> xml = serialize('container', IWithChoice, with_choice)\n    >>> print xml\n    <container>\n      <choice>alpha</choice>\n    </container>\n    >>> new_choice = WithChoice(None)\n    >>> deserialize(xml, IWithChoice, new_choice)\n    >>> new_choice.choice\n    'alpha'\n    >>> with_choice = WithChoice(None)\n    >>> xml = serialize('container', IWithChoice, with_choice)\n    >>> print xml\n    <container>\n      <choice/>\n    </container>\n    >>> deserialize(xml, IWithChoice, new_choice)\n    >>> new_choice.choice is None\n    True\n\nSet\n===\n\nSet fields are very similar to List fields::\n\n    >>> class IWithSet(interface.Interface):\n    ...     set = schema.Set(title=u'Set', required=False,\n    ...                      value_type=schema.Choice(__name__='choice',\n    ...                                               source=ChoiceSource()))\n    >>> class WithSet(object):\n    ...     implements(IWithSet)\n    ...     def __init__(self, set):\n    ...         self.set = set\n    >>> with_set = WithSet(set(['alpha']))\n    >>> xml = serialize('container', IWithSet, with_set)\n    >>> print xml\n    <container>\n      <set>\n        <choice>alpha</choice>\n      </set>\n    </container>\n    >>> with_set = WithSet(set(['alpha', 'beta']))\n    >>> xml = serialize('container', IWithSet, with_set)\n    >>> print xml\n    <container>\n      <set>\n        <choice>alpha</choice>\n        <choice>beta</choice>\n      </set>\n    </container>\n    >>> new_set = WithSet(None)\n    >>> deserialize(xml, IWithSet, new_set)\n    >>> new_set.set\n    set(['alpha', 'beta'])\n\nCHANGES\n*******\n\n1.0 (2008-12-05)\n================\n\n* Changed dependency on ``grokcore.component`` so that this becomes\n  useful in straight Zope 3 applications as well.\n\n* Run tests against lxml 2.0.9.\n\n0.10 (2008-03-10)\n=================\n\n* First checkin in svn.zope.org.\n\nDownload\n********", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": "", "license": "ZPL", "maintainer": null, "maintainer_email": null, "name": "z3c.schema2xml", "package_url": "https://pypi.org/project/z3c.schema2xml/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/z3c.schema2xml/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/z3c.schema2xml/1.0/", "requires_dist": null, "requires_python": null, "summary": "Convert schema-described Zope 3 objects to XML and back", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"schema-to-xml\">\n<h2>Schema To XML</h2>\n<div id=\"introduction\">\n<h3>Introduction</h3>\n<p>This package can convert objects described by Zope 3 schema to simple\nXML structures. It\u2019s also able to convert this XML back into objects.\nThe export and import processes are completely schema-driven; any\nattribute not described in the schema is not seen by this system at\nall.</p>\n<p>This system can be used to create export and import systems for Zope 3\napplications. It could also be used to provide XML representations of\nobjects for other purposes, such as XSLT transformations, or even just\nto get a full-text representation for index purposes.</p>\n<p>The package lies on <tt>lxml</tt> for the serialization to XML.</p>\n</div>\n<div id=\"serialization\">\n<h3>Serialization</h3>\n<p>Let\u2019s first define a simple Zope 3 schema:</p>\n<pre>&gt;&gt;&gt; from zope import interface, schema\n&gt;&gt;&gt; class IName(interface.Interface):\n...     first_name = schema.TextLine(title=u'First name')\n...     last_name = schema.TextLine(title=u'Last name')\n</pre>\n<p>Let\u2019s now make a class that implements this schema:</p>\n<pre>&gt;&gt;&gt; from zope.interface import implements\n&gt;&gt;&gt; class Name(object):\n...     implements(IName)\n...     def __init__(self, first_name, last_name):\n...         self.first_name = first_name\n...         self.last_name = last_name\n</pre>\n<p>Let\u2019s make an instance of the class:</p>\n<pre>&gt;&gt;&gt; name = Name('Karel', 'Titulaer')\n</pre>\n<p>Now let\u2019s serialize it to XML:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.schema2xml import serialize\n&gt;&gt;&gt; print serialize('container', IName, name)\n&lt;container&gt;\n  &lt;first_name&gt;Karel&lt;/first_name&gt;\n  &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n&lt;/container&gt;\n</pre>\n</blockquote>\n<p>This also works for other kinds of fields:</p>\n<pre>&gt;&gt;&gt; from zope import interface, schema\n&gt;&gt;&gt; class IAddress(interface.Interface):\n...     street_name = schema.TextLine(title=u'Street name')\n...     number = schema.Int(title=u'House number')\n&gt;&gt;&gt; class Address(object):\n...     implements(IAddress)\n...     def __init__(self, street_name, number):\n...         self.street_name = street_name\n...         self.number = number\n&gt;&gt;&gt; address = Address('Hofplein', 42)\n&gt;&gt;&gt; print serialize('container', IAddress, address)\n&lt;container&gt;\n  &lt;street_name&gt;Hofplein&lt;/street_name&gt;\n  &lt;number&gt;42&lt;/number&gt;\n&lt;/container&gt;\n</pre>\n<p>If a field is not filled in, the serialization will result in an empty\nelement:</p>\n<pre>&gt;&gt;&gt; address2 = Address(None, None)\n&gt;&gt;&gt; print serialize('container', IAddress, address2)\n&lt;container&gt;\n  &lt;street_name/&gt;\n  &lt;number/&gt;\n&lt;/container&gt;\n</pre>\n<p>If a schema defines an Object field with its own schema, the serialization\ncan also handle this:</p>\n<pre>&gt;&gt;&gt; class IPerson(interface.Interface):\n...     name = schema.Object(title=u\"Name\", schema=IName)\n...     address = schema.Object(title=u\"Address\", schema=IAddress)\n\n&gt;&gt;&gt; class Person(object):\n...     implements(IPerson)\n...     def __init__(self, name, address):\n...         self.name = name\n...         self.address = address\n\n&gt;&gt;&gt; person = Person(name, address)\n&gt;&gt;&gt; print serialize('person', IPerson, person)\n&lt;person&gt;\n  &lt;name&gt;\n    &lt;first_name&gt;Karel&lt;/first_name&gt;\n    &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n  &lt;/name&gt;\n  &lt;address&gt;\n    &lt;street_name&gt;Hofplein&lt;/street_name&gt;\n    &lt;number&gt;42&lt;/number&gt;\n  &lt;/address&gt;\n&lt;/person&gt;\n</pre>\n<p>A schema can also define a List field with elements with their own\nschema. Let\u2019s make an object and serialize it:</p>\n<pre>&gt;&gt;&gt; class ICommission(interface.Interface):\n...     members = schema.List(\n...         title=u\"Commission\",\n...         value_type=schema.Object(__name__='person',\n...         schema=IPerson))\n</pre>\n<p>Note that we have to explicitly specify __name__ for the field that\u2019s\nused for value_type here, otherwise we have no name to serialize to\nXML with.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Commission(object):\n...     implements(ICommission)\n...     def __init__(self, members):\n...         self.members = members\n</pre>\n<pre>&gt;&gt;&gt; commission = Commission(\n...     [person, Person(Name('Chriet', 'Titulaer'), Address('Ruimteweg', 3))])\n&gt;&gt;&gt; print serialize('commission', ICommission, commission)\n&lt;commission&gt;\n  &lt;members&gt;\n    &lt;person&gt;\n      &lt;name&gt;\n        &lt;first_name&gt;Karel&lt;/first_name&gt;\n        &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n      &lt;/name&gt;\n      &lt;address&gt;\n        &lt;street_name&gt;Hofplein&lt;/street_name&gt;\n        &lt;number&gt;42&lt;/number&gt;\n      &lt;/address&gt;\n    &lt;/person&gt;\n    &lt;person&gt;\n      &lt;name&gt;\n        &lt;first_name&gt;Chriet&lt;/first_name&gt;\n        &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n      &lt;/name&gt;\n      &lt;address&gt;\n        &lt;street_name&gt;Ruimteweg&lt;/street_name&gt;\n        &lt;number&gt;3&lt;/number&gt;\n      &lt;/address&gt;\n    &lt;/person&gt;\n  &lt;/members&gt;\n&lt;/commission&gt;\n</pre>\n</blockquote>\n<p>We get an adapter lookop failure whenever we try to serialize a field type for\nwhich there\u2019s no an serializer:</p>\n<pre>&gt;&gt;&gt; class IWithNonSerializableField(interface.Interface):\n...     field = schema.Field(title=u\"Commission\")\n&gt;&gt;&gt; class NotSerializable(object):\n...     implements(IWithNonSerializableField)\n...     def __init__(self, value):\n...         self.field = value\n&gt;&gt;&gt; not_serializable = NotSerializable(None)\n&gt;&gt;&gt; serialize('noway', IWithNonSerializableField, not_serializable)\nTraceback (most recent call last):\n ...\nTypeError: ('Could not adapt', &lt;zope.schema._bootstrapfields.Field object at ...&gt;, &lt;InterfaceClass z3c.schema2xml._schema2xml.IXMLGenerator&gt;)\n</pre>\n</div>\n<div id=\"deserialization\">\n<h3>Deserialization</h3>\n<p>Now we want to deserialize XML according to a schema to an object that\nprovides this schema.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.schema2xml import deserialize\n&gt;&gt;&gt; xml = '''\n...  &lt;container&gt;\n...    &lt;first_name&gt;Karel&lt;/first_name&gt;\n...    &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n...  &lt;/container&gt;\n...  '''\n&gt;&gt;&gt; name = Name('', '')\n&gt;&gt;&gt; deserialize(xml, IName, name)\n&gt;&gt;&gt; name.first_name\nu'Karel'\n&gt;&gt;&gt; name.last_name\nu'Titulaer'\n</pre>\n</blockquote>\n<p>The order of the fields in XML does not matter:</p>\n<pre>&gt;&gt;&gt; xml = '''\n...  &lt;container&gt;\n...    &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n...    &lt;first_name&gt;Karel&lt;/first_name&gt;\n...  &lt;/container&gt;\n...  '''\n&gt;&gt;&gt; name = Name('', '')\n&gt;&gt;&gt; deserialize(xml, IName, name)\n&gt;&gt;&gt; name.first_name\nu'Karel'\n&gt;&gt;&gt; name.last_name\nu'Titulaer'\n</pre>\n<p>After deserialization, the object alsoProvides the schema interface:</p>\n<pre>&gt;&gt;&gt; IName.providedBy(name)\nTrue\n</pre>\n<p>This also works for other kinds of fields:</p>\n<pre>&gt;&gt;&gt; xml = '''\n...  &lt;container&gt;\n...    &lt;street_name&gt;Hofplein&lt;/street_name&gt;\n...    &lt;number&gt;42&lt;/number&gt;\n...  &lt;/container&gt;\n...  '''\n&gt;&gt;&gt; address = Address('', 0)\n&gt;&gt;&gt; deserialize(xml, IAddress, address)\n&gt;&gt;&gt; address.street_name\nu'Hofplein'\n&gt;&gt;&gt; address.number\n42\n</pre>\n<p>If a schema defines an Object field with its own schema, the serialization\ncan also handle this:</p>\n<pre>&gt;&gt;&gt; xml = '''\n...  &lt;person&gt;\n...    &lt;name&gt;\n...      &lt;first_name&gt;Karel&lt;/first_name&gt;\n...      &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n...    &lt;/name&gt;\n...    &lt;address&gt;\n...      &lt;street_name&gt;Hofplein&lt;/street_name&gt;\n...      &lt;number&gt;42&lt;/number&gt;\n...    &lt;/address&gt;\n...  &lt;/person&gt;\n...  '''\n&gt;&gt;&gt; person = Person(Name('', ''), Address('', 0))\n&gt;&gt;&gt; deserialize(xml, IPerson, person)\n&gt;&gt;&gt; person.name.first_name\nu'Karel'\n&gt;&gt;&gt; person.name.last_name\nu'Titulaer'\n&gt;&gt;&gt; person.address.street_name\nu'Hofplein'\n&gt;&gt;&gt; person.address.number\n42\n&gt;&gt;&gt; IPerson.providedBy(person)\nTrue\n&gt;&gt;&gt; IName.providedBy(person.name)\nTrue\n&gt;&gt;&gt; IAddress.providedBy(person.address)\nTrue\n</pre>\n<p>Again the order in which the fields come in XML shouldn\u2019t matter:</p>\n<pre>&gt;&gt;&gt; xml = '''\n...  &lt;person&gt;\n...    &lt;address&gt;\n...      &lt;number&gt;42&lt;/number&gt;\n...      &lt;street_name&gt;Hofplein&lt;/street_name&gt;\n...    &lt;/address&gt;\n...    &lt;name&gt;\n...      &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n...      &lt;first_name&gt;Karel&lt;/first_name&gt;\n...    &lt;/name&gt;\n...  &lt;/person&gt;\n...  '''\n&gt;&gt;&gt; person = Person(Name('', ''), Address('', 0))\n&gt;&gt;&gt; deserialize(xml, IPerson, person)\n&gt;&gt;&gt; person.name.first_name\nu'Karel'\n&gt;&gt;&gt; person.name.last_name\nu'Titulaer'\n&gt;&gt;&gt; person.address.street_name\nu'Hofplein'\n&gt;&gt;&gt; person.address.number\n42\n&gt;&gt;&gt; IPerson.providedBy(person)\nTrue\n&gt;&gt;&gt; IName.providedBy(person.name)\nTrue\n&gt;&gt;&gt; IAddress.providedBy(person.address)\nTrue\n\n&gt;&gt;&gt; xml = '''\n... &lt;commission&gt;\n...  &lt;members&gt;\n...    &lt;person&gt;\n...      &lt;name&gt;\n...        &lt;first_name&gt;Karel&lt;/first_name&gt;\n...        &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n...      &lt;/name&gt;\n...      &lt;address&gt;\n...        &lt;street_name&gt;Hofplein&lt;/street_name&gt;\n...        &lt;number&gt;42&lt;/number&gt;\n...      &lt;/address&gt;\n...    &lt;/person&gt;\n...    &lt;person&gt;\n...      &lt;name&gt;\n...        &lt;first_name&gt;Chriet&lt;/first_name&gt;\n...        &lt;last_name&gt;Titulaer&lt;/last_name&gt;\n...     &lt;/name&gt;\n...      &lt;address&gt;\n...        &lt;street_name&gt;Ruimteweg&lt;/street_name&gt;\n...        &lt;number&gt;3&lt;/number&gt;\n...      &lt;/address&gt;\n...    &lt;/person&gt;\n...  &lt;/members&gt;\n... &lt;/commission&gt;\n... '''\n\n&gt;&gt;&gt; commission = Commission([])\n&gt;&gt;&gt; deserialize(xml, ICommission, commission)\n&gt;&gt;&gt; len(commission.members)\n2\n&gt;&gt;&gt; member = commission.members[0]\n&gt;&gt;&gt; member.name.first_name\nu'Karel'\n&gt;&gt;&gt; member.address.street_name\nu'Hofplein'\n&gt;&gt;&gt; member = commission.members[1]\n&gt;&gt;&gt; member.name.first_name\nu'Chriet'\n&gt;&gt;&gt; member.address.street_name\nu'Ruimteweg'\n</pre>\n<p>Whenever the XML element is empty, the resulting value should be None:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.schema2xml import deserialize\n&gt;&gt;&gt; xml = '''\n...  &lt;container&gt;\n...    &lt;first_name&gt;&lt;/first_name&gt;\n...    &lt;last_name/&gt;\n...  &lt;/container&gt;\n...  '''\n&gt;&gt;&gt; name = Name('', '')\n&gt;&gt;&gt; deserialize(xml, IName, name)\n&gt;&gt;&gt; name.first_name is None\nTrue\n&gt;&gt;&gt; name.last_name is None\nTrue\n</pre>\n</blockquote>\n<p>For all kinds of fields, like strings and ints\u2026:</p>\n<pre>&gt;&gt;&gt; xml = '''\n...  &lt;container&gt;\n...    &lt;street_name/&gt;\n...    &lt;number/&gt;\n...  &lt;/container&gt;\n...  '''\n&gt;&gt;&gt; address = Address('', 0)\n&gt;&gt;&gt; deserialize(xml, IAddress, address)\n&gt;&gt;&gt; address.street_name is None\nTrue\n&gt;&gt;&gt; address.number is None\nTrue\n</pre>\n<p>\u2026and the fields of subobjects (but not the subobject themselves!):</p>\n<pre>&gt;&gt;&gt; xml = '''\n...  &lt;person&gt;\n...    &lt;name&gt;\n...      &lt;first_name/&gt;\n...      &lt;last_name/&gt;\n...    &lt;/name&gt;\n...    &lt;address&gt;\n...      &lt;street_name/&gt;\n...      &lt;number/&gt;\n...    &lt;/address&gt;\n...  &lt;/person&gt;\n...  '''\n&gt;&gt;&gt; person = Person(Name('', ''), Address('', 0))\n&gt;&gt;&gt; deserialize(xml, IPerson, person)\n&gt;&gt;&gt; person.name.first_name is None\nTrue\n&gt;&gt;&gt; person.name.last_name is None\nTrue\n&gt;&gt;&gt; IPerson.providedBy(person)\nTrue\n&gt;&gt;&gt; IName.providedBy(person.name)\nTrue\n&gt;&gt;&gt; person.address is None\nFalse\n&gt;&gt;&gt; person.address.street_name is None\nTrue\n&gt;&gt;&gt; person.address.number is None\nTrue\n&gt;&gt;&gt; IAddress.providedBy(person.address)\nTrue\n</pre>\n<p>Similarly, where a sequence is expected the value should be an empty sequence:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; xml = '''\n... &lt;commission&gt;\n...   &lt;members/&gt;\n... &lt;/commission&gt;\n... '''\n&gt;&gt;&gt; commission = Commission([])\n&gt;&gt;&gt; deserialize(xml, ICommission, commission)\n&gt;&gt;&gt; len(commission.members)\n0\n</pre>\n</blockquote>\n<p>TextLine, Int, Object and List have just been tested. Now follow tests\nfor the other field types that have a serializer.</p>\n</div>\n<div id=\"datetime\">\n<h3>Datetime</h3>\n<p>Datetime objects:</p>\n<pre>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; class IWithDatetime(interface.Interface):\n...     datetime = schema.Datetime(title=u'Date and time')\n&gt;&gt;&gt; class WithDatetime(object):\n...     implements(IWithDatetime)\n...     def __init__(self, datetime):\n...         self.datetime = datetime\n&gt;&gt;&gt; with_datetime = WithDatetime(datetime(2006, 12, 31))\n&gt;&gt;&gt; xml = serialize('container', IWithDatetime, with_datetime)\n&gt;&gt;&gt; print xml\n&lt;container&gt;\n  &lt;datetime&gt;2006-12-31T00:00:00&lt;/datetime&gt;\n&lt;/container&gt;\n&gt;&gt;&gt; new_datetime = WithDatetime(None)\n&gt;&gt;&gt; deserialize(xml, IWithDatetime, new_datetime)\n&gt;&gt;&gt; new_datetime.datetime.year\n2006\n&gt;&gt;&gt; new_datetime.datetime.month\n12\n&gt;&gt;&gt; new_datetime.datetime.day\n31\n</pre>\n<p>Let\u2019s try it with the field not filled in:</p>\n<pre>&gt;&gt;&gt; with_datetime = WithDatetime(None)\n&gt;&gt;&gt; xml = serialize('container', IWithDatetime, with_datetime)\n&gt;&gt;&gt; print xml\n&lt;container&gt;\n  &lt;datetime/&gt;\n&lt;/container&gt;\n&gt;&gt;&gt; new_datetime= WithDatetime(None)\n&gt;&gt;&gt; deserialize(xml, IWithDatetime, new_datetime)\n&gt;&gt;&gt; new_datetime.datetime is None\nTrue\n</pre>\n</div>\n<div id=\"choice\">\n<h3>Choice</h3>\n<p>Choice fields. For now, we only work with Choice fields that have\ntext values:</p>\n<pre>&gt;&gt;&gt; from zc.sourcefactory.basic import BasicSourceFactory\n&gt;&gt;&gt; class ChoiceSource(BasicSourceFactory):\n...     def getValues(self):\n...         return [u'alpha', u'beta']\n&gt;&gt;&gt; class IWithChoice(interface.Interface):\n...     choice = schema.Choice(title=u'Choice', required=False,\n...                            source=ChoiceSource())\n&gt;&gt;&gt; class WithChoice(object):\n...     implements(IWithChoice)\n...     def __init__(self, choice):\n...         self.choice = choice\n&gt;&gt;&gt; with_choice = WithChoice('alpha')\n&gt;&gt;&gt; xml = serialize('container', IWithChoice, with_choice)\n&gt;&gt;&gt; print xml\n&lt;container&gt;\n  &lt;choice&gt;alpha&lt;/choice&gt;\n&lt;/container&gt;\n&gt;&gt;&gt; new_choice = WithChoice(None)\n&gt;&gt;&gt; deserialize(xml, IWithChoice, new_choice)\n&gt;&gt;&gt; new_choice.choice\n'alpha'\n&gt;&gt;&gt; with_choice = WithChoice(None)\n&gt;&gt;&gt; xml = serialize('container', IWithChoice, with_choice)\n&gt;&gt;&gt; print xml\n&lt;container&gt;\n  &lt;choice/&gt;\n&lt;/container&gt;\n&gt;&gt;&gt; deserialize(xml, IWithChoice, new_choice)\n&gt;&gt;&gt; new_choice.choice is None\nTrue\n</pre>\n</div>\n<div id=\"set\">\n<h3>Set</h3>\n<p>Set fields are very similar to List fields:</p>\n<pre>&gt;&gt;&gt; class IWithSet(interface.Interface):\n...     set = schema.Set(title=u'Set', required=False,\n...                      value_type=schema.Choice(__name__='choice',\n...                                               source=ChoiceSource()))\n&gt;&gt;&gt; class WithSet(object):\n...     implements(IWithSet)\n...     def __init__(self, set):\n...         self.set = set\n&gt;&gt;&gt; with_set = WithSet(set(['alpha']))\n&gt;&gt;&gt; xml = serialize('container', IWithSet, with_set)\n&gt;&gt;&gt; print xml\n&lt;container&gt;\n  &lt;set&gt;\n    &lt;choice&gt;alpha&lt;/choice&gt;\n  &lt;/set&gt;\n&lt;/container&gt;\n&gt;&gt;&gt; with_set = WithSet(set(['alpha', 'beta']))\n&gt;&gt;&gt; xml = serialize('container', IWithSet, with_set)\n&gt;&gt;&gt; print xml\n&lt;container&gt;\n  &lt;set&gt;\n    &lt;choice&gt;alpha&lt;/choice&gt;\n    &lt;choice&gt;beta&lt;/choice&gt;\n  &lt;/set&gt;\n&lt;/container&gt;\n&gt;&gt;&gt; new_set = WithSet(None)\n&gt;&gt;&gt; deserialize(xml, IWithSet, new_set)\n&gt;&gt;&gt; new_set.set\nset(['alpha', 'beta'])\n</pre>\n</div>\n</div>\n<div id=\"changes\">\n<h2>CHANGES</h2>\n<div id=\"id1\">\n<h3>1.0 (2008-12-05)</h3>\n<ul>\n<li>Changed dependency on <tt>grokcore.component</tt> so that this becomes\nuseful in straight Zope 3 applications as well.</li>\n<li>Run tests against lxml 2.0.9.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>0.10 (2008-03-10)</h3>\n<ul>\n<li>First checkin in svn.zope.org.</li>\n</ul>\n</div>\n</div>\n<div id=\"download\">\n<h2>Download</h2>\n</div>\n\n          </div>"}, "last_serial": 802105, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "469f4340539445b8028f1fb04030a3f3", "sha256": "2fb6f8703db1a78a317eb8822cd6769750107219212e7c1e0fa2effd74ec6bb5"}, "downloads": -1, "filename": "z3c.schema2xml-1.0.tar.gz", "has_sig": false, "md5_digest": "469f4340539445b8028f1fb04030a3f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12537, "upload_time": "2008-12-05T18:52:54", "upload_time_iso_8601": "2008-12-05T18:52:54Z", "url": "https://files.pythonhosted.org/packages/3a/87/93f10ec0ca060127412d03dd0ec1d351dccd3267fcbf59d23940adea5800/z3c.schema2xml-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "469f4340539445b8028f1fb04030a3f3", "sha256": "2fb6f8703db1a78a317eb8822cd6769750107219212e7c1e0fa2effd74ec6bb5"}, "downloads": -1, "filename": "z3c.schema2xml-1.0.tar.gz", "has_sig": false, "md5_digest": "469f4340539445b8028f1fb04030a3f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12537, "upload_time": "2008-12-05T18:52:54", "upload_time_iso_8601": "2008-12-05T18:52:54Z", "url": "https://files.pythonhosted.org/packages/3a/87/93f10ec0ca060127412d03dd0ec1d351dccd3267fcbf59d23940adea5800/z3c.schema2xml-1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:31 2020"}