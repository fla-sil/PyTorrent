{"info": {"author": "T. Zoerner", "author_email": "tomzo@users.sourceforge.net", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: System Administrators", "License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)", "Operating System :: POSIX :: AIX", "Operating System :: POSIX :: BSD", "Operating System :: POSIX :: HP-UX", "Operating System :: POSIX :: IRIX", "Operating System :: POSIX :: Linux", "Operating System :: POSIX :: SunOS/Solaris", "Programming Language :: C", "Programming Language :: Python :: 3", "Topic :: System :: Filesystems", "Topic :: System :: Systems Administration"], "description": "===============================\nPython File-system Quota module\n===============================\n\nThe Python file-system quota module allows accessing file system quotas on\nUNIX platforms from Python scripts. The module is intended mainly for\nsystem administrators who have to manage quotas for all the users on their\nsystem.\n\nThe following operating systems and file systems are supported\ntransparently through a common API.\n\nSupported operating systems:\n\n* Linux - kernel 2.0.30 - 4.15\n* FreeBSD 3 - 12.1, OpenBSD 2.2 - 6.6 & NetBSD 5 - 9\n* SunOS 4.1.3 (aka Solaris 1)\n* Solaris 2.4 - 2.10\n* HP-UX 9.0x & 10.10 & 10.20 & 11.00\n* IRIX 5.2 & 5.3 & 6.2 - 6.5\n* OSF/1 & Digital Unix 4\n* AIX 4.1, 4.2 and 5.3\n\nSupported file systems:\n\n* Standard file systems of the platforms listed above\n* NFS (Network file system) on all of the above\n  (i.e. using an integrated RPC client)\n* XFS on Linux and IRIX 6\n* AFS (Andrew File System) on many of the above (see INSTALL)\n* VxFS (Veritas File System) on Solaris 2\n\nHistorical note: The C implementation of this module is derived from the\n`Quota module for Perl`_ (also at `CPAN`_). Since its beginnings in 1995,\nthe module was continuously extended by porting to more UNIX platforms and\nfile-systems. Numerous people have contributed to this process; for a\ncomplete list of names please see the CHANGES document in the package. In\ncase of build issues, please refer to the INSTALL document within the\npackage.\n\n.. _Quota module for Perl: https://github.com/tomzox/Perl-Quota\n.. _CPAN: https://metacpan.org/pod/Quota\n\nThe following is a copy of the API documentation in file doc/FsQuota.rst\n\n\nSYNOPSIS\n========\n\n::\n\n    import FsQuota\n\n    qObj = FsQuota.Quota(path [,rpc_host=hostname])\n\n    (bcount, bsoft, bhard, btime,\n     icount, isoft, ihard, itime) =\n        qObj.query(uid [,grpquota=1] [,prjquota=1])\n\n    qObj.setqlim(uid, bsoft, bhard, isoft, ihard\n                 [,timereset=1]\n                 [,grpquota=1] [,prjquota=1])\n\n    qObj.sync()\n\n    qObj.rpc_opt([option keywords])\n\n    for dev, path, type, opts in FsQuota.MntTab(): ...\n\nFsQuota Module\n==============\n\nThe **FsQuota** module provides two classes that allow accessing file\nsystem quotas from Python scripts:\n\nInstances of the **Quota** class take as main init parameter a path of a\nmount point (or any path below the mount point). The instance can then be\nused to query or modify quota of users or groups within that file system.\nThe class is designed portably, so that the same interfaces work across\nall file system types and UNIX platforms. (Although there are some extra\noptions during initialization for certain file systems.)\n\nInstances of the **MntTab** class allow iterating across the mount\ntable.  For each entry in the table, it provides the file system type,\nmount  point and options. (Note this class is usually not required to work\nwith the Quota class.  It is provided here just for convenience, as the\nfunctionality is actually used internally by the Quota class.)\n\nClass FsQuota.Quota\n===================\n\n::\n\n    qObj = FsQuota.Quota(path)\n    qObj = FsQuota.Quota(remote_path, rpc_host=remote_host)\n\nCreates a Quota object that then is used for querying or modifying\nquotas. In case of special file systems which are known not to suport\nquota, the creation may raise exception **FsQuota.error**. However note\nthe absence of an exception is not a guarantee that the file system\nactually supports quota limits.\n\nInternal behavior: Most importantly, the initialization determines the\nfile system type and thus the access method to be used in following\nquota operations. Many platforms use the **quotactl** syscall, but even\nthen the type of device parameter to be passed varies from system to\nsystem. It may be the path of a device file (e.g. `/dev/sda1`) or the\npath of the mount point or the quotas file at the top of the file system\n(e.g. `/home/quotas`). For the rare cases you need this information,\nit can be queried via the **Quota.dev** attribute.\n\nThe given mount point may also be on a remote file system (e.g. mounted\nvia Network File System, NFS), which has the class transparently query\nthe given host via a remote procedure call (RPC).  Note: RPC queries\nrequire *rquotad(1m)* to be running on the target system. If the daemon\nor host are down, the operations time out after a configurable delay.\n\nWhen parameter **rpc_host** is specified, the automatic detection of file\nsystem type is omitted. In this case the following operations will\naddress the file system containing the given path on the given remote host\nusing RPC. This mode should normally not be needed, but could for example\nbe used for accessing file systems that are not mounted locally. See also\nthe **rpc_opt()** method for additional RPC configuration options.\n\nQuota.query()\n-------------\n\n::\n\n    (bcount,bsoft,bhard,btime, icount,isoft,ihard,itime)\n        = qObj.query(uid, [keyword_options...])\n\nGet current usage and quota limits for blocks and files respectively,\nowned by the given user. The user is specified by a numeric UID.\nThe result is a named tuple of type **FsQuota.QueryResult**, so that\nmembers can be accessed via name as well as via indices:\n\n0. **bcount**: Number of 1 kB blocks currently used by inodes owned by the user.\n1. **bsoft**: Soft limit for block count (or 0 if none)\n2. **bhard**: Hard limit for block count (or 0 if none)\n3. **btime**: Time when an exceeded soft block limit turns into a hard limit.\n   This value is meaningless when the soft limit is not exceeded.\n4. **icount**: Number of inodes (i.e. files) currently owned by the user.\n5. **isoft**: Soft limit for inode count (or 0 if none)\n6. **ihard**: Hard limit for inode count (or 0 if none)\n7. **itime**: Time when an exceeded soft inode limit turns into a hard limit.\n   This value is meaningless when the soft limit is not exceeded.\n\nWhen a hard limit is reached, the OS will reject any further write with\nerrno *EDQUOT* (or *ENOSPC* on older systems).  If the soft limit is\nexceeded, but hard limit not exceeded, writes by this user will fail only\nafter the time indicated by *btime* or *itime* respectively is\nreached.  The time is usually set to 7 days after exceeding the soft limit\nfor the first time. These times are expressed as elapsed seconds since\n00:00 1/Jan/1970 GMT.\n\nNote when hard and soft limits are both zero, this means there is no limit\nfor that user. (On some platforms the query may fail with error code\n*ESRCH* in that case; most however still report valid usage values.)\n\nOptional keyword-only parameters:\n\n:grpquota:\n    When parameter **grpquota** is present and set to a value that evaluates to\n    *True*, the value in *uid* is taken as GID and group quotas are queried.\n    Group quotas may not be supported across all platforms (e.g. Linux and\n    other BSD based Unix variants, OSF/1 and  AIX - check the quotactl(2) man\n    page on your systems).\n\n:prjquota:\n    When parameter **prjquota** is present and set to a value that evaluates to\n    *True*, project quotas are queried; this is currently only supported for\n    XFS. Exception **FsQuota.error(ENOTSUP)** is raised for unsupported\n    file-systems.\n\nIt is an error to select both group and project quota in the same query.\n\nMethod Quota.setqlim()\n----------------------\n\n::\n\n    qObj.setqlim(uid, bsoft, bhard, isoft, ihard [,keyword options...])\n\nSets quota limits for the given user. Meanings of parameters *uid*,\n*bsoft*, *bhard*, *isoft* and *ihard* are the same as for the **query()**\nmethod.\n\nNote all the limit values are optional and default to zero. The parameters\ncan also be passed in form of keyword parameters. For example\n`qObj.setqlim(uid, isoft=10,ihard=20)` would limit inode counts to 10\nsoft, 20 hard, but remove limits for block count. (Note it's not possible\nto set only block or inode limits repsectively; to do so query current\nlimits first and then pass those values to setqlim if you want to keep\nthem unchanged.)\n\nNote: if you want to set the quota of a particular user to zero, i.e.\nno write permission, you must not set all limits to zero, since that\nis equivalent to unlimited access. Instead set only the hard limit\nto 0 and the soft limit to a non-zero value.\n\nOptional keyword-only parameters:\n\n:timereset:\n    Optional parameter **timereset** defines how time limits are\n    initialized: When the assigned value is *False*, time limits are set to\n    `NOT STARTED` (i.e. the time limits are not initialized until the first\n    write attempt by this user). This is the default when the parameter is\n    omitted. When assigned *True*, the time limits are set to `7.0 days`.\n    More alternatives (i.e. setting a specific time) aren't available in most\n    implementations.\n\n:grpquota:\n    When parameter **grpquota** is present and set to True, parameter *uid* is\n    interpreted as GID and the the limit of the corresponding group is\n    modified. This is not supported on all platforms.\n\n:prjquota:\n    When parameter **prjquota** is present and set to True, project quotas are\n    modified; this is currently only supported for XFS.  Exception\n    **FsQuota.error(ENOTSUP)** is raised for unsupported file-systems.\n\nIt is an error to select both group and project quota in the same query.\n\nNote that the class does not support setting quotas via RPC (even\nthough some implementations of *rpc.rquotad(8)* allow optionally\nenabling this, but it seems a bad idea for security.)\n\nMethod Quota.sync()\n-------------------\n\n::\n\n    qObj.sync()\n\nHave the kernel update the quota file on disk, in particular after\nmodifying quota limits.\n\nA secondary purpose of this method is checking if quota support is\nenabled in the kernel (and on some platforms, for a particular file\nsystem; on others however the call succeeds even if quota is not enabled\nin the given file system.) Read the **quotaon(1m)** man page on how to\nenable quotas on a file system.\n\nMethod Quota.rpc_opt()\n----------------------\n\n::\n\n    qObj.rpc_opt([keyword options...])\n\nThis method allows configuring networking and authentication parameters\nfor queries of network file system quotas via RPC. The options have no\neffect when targeting other file system types. The following keyword-only\nparameters are available:\n\n:rpc_port:\n    Sets the port used by *rpc.rquotad(8)*; default value is zero, which\n    which means the remote host's portmapper (aka rpcbind) is used. (Note\n    in case of the latter you can find out the port using *rpcinfo -p host*)\n\n:rpc_use_tcp:\n    If *True*, use TCP; if *False* use UDP (default).\n\n:rpc_timeout:\n    Timeout value in milliseconds in case the remote host does not respond.\n\n:auth_uid:\n    UID value (i.e. user identifier) to provide for authentication.\n    If not specified, this defaults to the UID of the current process.\n    For example, you could set the UID here that you later want to\n    query, for circumventing a permission error.\n\n:auth_gid:\n    GID value (i.e. group identifier) to provide for authentication.\n    If not specified, this defaults to the GID of the current process.\n\n:auth_hostname:\n    Hostname to provide for authentication.\n    If not specified or empty, this defaults to the name of the local machine.\n\nNote for resetting to default authentication, set both **auth_uid** and\n**auth_gid** to value -1 (even if you previously changed only one, as the\nopposite is filled in automatically if missing).\n\nAttribute Quota.dev\n-------------------\n\nThis attribute provides the device argument used internally by **query()**\nand **setqlim()** methods for the selected file system.\n\nAttribute Quota.is_nfs\n----------------------\n\nThis attribute indicates 1 is the file system is NFS, else 0.\n\nClass FsQuota.MntTab()\n======================\n\nThis class defines objects that can be used as an iterator which lists all\nentries in the mount table. Each object returned by iteration is a named\ntuple of type **FsQuota.MntEnt** with the following entries of type\nstring:\n\n0. **mnt_fsname**: Name of the filesystem (e.g. device name)\n1. **mnt_dir**: Filesystem path prefix (aka mount point)\n2. **mnt_type**: Mount type (aka file system type)\n3. **mnt_opts**: Mount options, separated by colon.\n\nNote the mount table contains information about all currently mounted\n(local or remote) file systems.  The format and location of this table\nvaries from system to system (e.g. it may be in file `/etc/mtab`).\nThis iterator provides a portable way to read it. (On some systems,\nlike **OSF/1**, this table isn't accessible as a file at all, i.e. only\nvia C library interfaces). Internally, the iterator will call\n*setmntent(3)* or the equivalent of your platform upon initialization,\ncall *getmntent(3)* during iteration, and call *endmntent(3)* upon\ndeallocation.\n\nHint: For finding the mount table entry corresponding to a given path\n(e.g. to determine the file system type), you can compare the device ID\nindicated by *os.stat(path).st_dev* of the mount points returned from\niteration with that of the path in question.\n\nERROR HANDLING\n==============\n\nAll methods raise exception **FsQuota.error** upon errors. The exception\nclass is derived from exception **OSError** and thus contains firstly a\nnumerical error code in attribute **errno** (copied from *errno* in most\ncases), secondly a derived error message in attribute **strerror**, and\nwhen applicable, thirdly a file name in attribute **filename**.\n\nNote the error string is adapted to the context of quota operations and\ntherefore not always identical to the text returned by\n**strerror(ex.errno)**.  This is necessary as normal error descriptions\ndon't always make sense for quota errors (e.g. *ESRCH*: *No such process*,\nhere: *No quota for this user*)\n\nAUTHORS\n=======\n\nThis module is derived from an equivalent extension module for Perl,\ncreated 1995 by T. Zoerner (email: tomzo AT users.sourceforge.net)\nand since then continuously improved and ported to many more\noperating systems and file systems - and now ported to Python.\nNumerous people have contributed to this process in the past;\nfor a complete list of names please see the CHANGES document.\n\nLICENSE\n=======\n\nCopyright (C) 1995-2020 T. Zoerner\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by the\nFree Software Foundation. (Either version 2 of the GPL, or any later\nversion, see http://www.opensource.org/licenses/).\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\n\nSEE ALSO\n========\n\npython3(1), edquota(8),\nquotactl(2) or quotactl(7I),\nmount(8), mtab(4) or mnttab(4), quotaon(8),\nsetmntent(3), getmntent(3) or getmntinfo(3), endmntent(3),\nrpc(3), rquotad(8) or rpc.rquotad(8), rpcinfo(7).", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tomzox/Python-Quota", "keywords": "file-system,quota,quotactl,mtab,getmntent", "license": "GNU GPLv2+", "maintainer": "", "maintainer_email": "", "name": "FsQuota", "package_url": "https://pypi.org/project/FsQuota/", "platform": "posix", "project_url": "https://pypi.org/project/FsQuota/", "project_urls": {"Homepage": "https://github.com/tomzox/Python-Quota"}, "release_url": "https://pypi.org/project/FsQuota/0.1.0/", "requires_dist": null, "requires_python": ">=3.2", "summary": "Interface to file system quotas on UNIX platforms", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>The Python file-system quota module allows accessing file system quotas on\nUNIX platforms from Python scripts. The module is intended mainly for\nsystem administrators who have to manage quotas for all the users on their\nsystem.</p>\n<p>The following operating systems and file systems are supported\ntransparently through a common API.</p>\n<p>Supported operating systems:</p>\n<ul>\n<li>Linux - kernel 2.0.30 - 4.15</li>\n<li>FreeBSD 3 - 12.1, OpenBSD 2.2 - 6.6 &amp; NetBSD 5 - 9</li>\n<li>SunOS 4.1.3 (aka Solaris 1)</li>\n<li>Solaris 2.4 - 2.10</li>\n<li>HP-UX 9.0x &amp; 10.10 &amp; 10.20 &amp; 11.00</li>\n<li>IRIX 5.2 &amp; 5.3 &amp; 6.2 - 6.5</li>\n<li>OSF/1 &amp; Digital Unix 4</li>\n<li>AIX 4.1, 4.2 and 5.3</li>\n</ul>\n<p>Supported file systems:</p>\n<ul>\n<li>Standard file systems of the platforms listed above</li>\n<li>NFS (Network file system) on all of the above\n(i.e. using an integrated RPC client)</li>\n<li>XFS on Linux and IRIX 6</li>\n<li>AFS (Andrew File System) on many of the above (see INSTALL)</li>\n<li>VxFS (Veritas File System) on Solaris 2</li>\n</ul>\n<p>Historical note: The C implementation of this module is derived from the\n<a href=\"https://github.com/tomzox/Perl-Quota\" rel=\"nofollow\">Quota module for Perl</a> (also at <a href=\"https://metacpan.org/pod/Quota\" rel=\"nofollow\">CPAN</a>). Since its beginnings in 1995,\nthe module was continuously extended by porting to more UNIX platforms and\nfile-systems. Numerous people have contributed to this process; for a\ncomplete list of names please see the CHANGES document in the package. In\ncase of build issues, please refer to the INSTALL document within the\npackage.</p>\n<p>The following is a copy of the API documentation in file doc/FsQuota.rst</p>\n<div id=\"synopsis\">\n<h2>SYNOPSIS</h2>\n<pre>import FsQuota\n\nqObj = FsQuota.Quota(path [,rpc_host=hostname])\n\n(bcount, bsoft, bhard, btime,\n icount, isoft, ihard, itime) =\n    qObj.query(uid [,grpquota=1] [,prjquota=1])\n\nqObj.setqlim(uid, bsoft, bhard, isoft, ihard\n             [,timereset=1]\n             [,grpquota=1] [,prjquota=1])\n\nqObj.sync()\n\nqObj.rpc_opt([option keywords])\n\nfor dev, path, type, opts in FsQuota.MntTab(): ...\n</pre>\n</div>\n<div id=\"fsquota-module\">\n<h2>FsQuota Module</h2>\n<p>The <strong>FsQuota</strong> module provides two classes that allow accessing file\nsystem quotas from Python scripts:</p>\n<p>Instances of the <strong>Quota</strong> class take as main init parameter a path of a\nmount point (or any path below the mount point). The instance can then be\nused to query or modify quota of users or groups within that file system.\nThe class is designed portably, so that the same interfaces work across\nall file system types and UNIX platforms. (Although there are some extra\noptions during initialization for certain file systems.)</p>\n<p>Instances of the <strong>MntTab</strong> class allow iterating across the mount\ntable.  For each entry in the table, it provides the file system type,\nmount  point and options. (Note this class is usually not required to work\nwith the Quota class.  It is provided here just for convenience, as the\nfunctionality is actually used internally by the Quota class.)</p>\n</div>\n<div id=\"class-fsquota-quota\">\n<h2>Class FsQuota.Quota</h2>\n<pre>qObj = FsQuota.Quota(path)\nqObj = FsQuota.Quota(remote_path, rpc_host=remote_host)\n</pre>\n<p>Creates a Quota object that then is used for querying or modifying\nquotas. In case of special file systems which are known not to suport\nquota, the creation may raise exception <strong>FsQuota.error</strong>. However note\nthe absence of an exception is not a guarantee that the file system\nactually supports quota limits.</p>\n<p>Internal behavior: Most importantly, the initialization determines the\nfile system type and thus the access method to be used in following\nquota operations. Many platforms use the <strong>quotactl</strong> syscall, but even\nthen the type of device parameter to be passed varies from system to\nsystem. It may be the path of a device file (e.g. <cite>/dev/sda1</cite>) or the\npath of the mount point or the quotas file at the top of the file system\n(e.g. <cite>/home/quotas</cite>). For the rare cases you need this information,\nit can be queried via the <strong>Quota.dev</strong> attribute.</p>\n<p>The given mount point may also be on a remote file system (e.g. mounted\nvia Network File System, NFS), which has the class transparently query\nthe given host via a remote procedure call (RPC).  Note: RPC queries\nrequire <em>rquotad(1m)</em> to be running on the target system. If the daemon\nor host are down, the operations time out after a configurable delay.</p>\n<p>When parameter <strong>rpc_host</strong> is specified, the automatic detection of file\nsystem type is omitted. In this case the following operations will\naddress the file system containing the given path on the given remote host\nusing RPC. This mode should normally not be needed, but could for example\nbe used for accessing file systems that are not mounted locally. See also\nthe <strong>rpc_opt()</strong> method for additional RPC configuration options.</p>\n<div id=\"quota-query\">\n<h3>Quota.query()</h3>\n<pre>(bcount,bsoft,bhard,btime, icount,isoft,ihard,itime)\n    = qObj.query(uid, [keyword_options...])\n</pre>\n<p>Get current usage and quota limits for blocks and files respectively,\nowned by the given user. The user is specified by a numeric UID.\nThe result is a named tuple of type <strong>FsQuota.QueryResult</strong>, so that\nmembers can be accessed via name as well as via indices:</p>\n<ol>\n<li><strong>bcount</strong>: Number of 1 kB blocks currently used by inodes owned by the user.</li>\n<li><strong>bsoft</strong>: Soft limit for block count (or 0 if none)</li>\n<li><strong>bhard</strong>: Hard limit for block count (or 0 if none)</li>\n<li><strong>btime</strong>: Time when an exceeded soft block limit turns into a hard limit.\nThis value is meaningless when the soft limit is not exceeded.</li>\n<li><strong>icount</strong>: Number of inodes (i.e. files) currently owned by the user.</li>\n<li><strong>isoft</strong>: Soft limit for inode count (or 0 if none)</li>\n<li><strong>ihard</strong>: Hard limit for inode count (or 0 if none)</li>\n<li><strong>itime</strong>: Time when an exceeded soft inode limit turns into a hard limit.\nThis value is meaningless when the soft limit is not exceeded.</li>\n</ol>\n<p>When a hard limit is reached, the OS will reject any further write with\nerrno <em>EDQUOT</em> (or <em>ENOSPC</em> on older systems).  If the soft limit is\nexceeded, but hard limit not exceeded, writes by this user will fail only\nafter the time indicated by <em>btime</em> or <em>itime</em> respectively is\nreached.  The time is usually set to 7 days after exceeding the soft limit\nfor the first time. These times are expressed as elapsed seconds since\n00:00 1/Jan/1970 GMT.</p>\n<p>Note when hard and soft limits are both zero, this means there is no limit\nfor that user. (On some platforms the query may fail with error code\n<em>ESRCH</em> in that case; most however still report valid usage values.)</p>\n<p>Optional keyword-only parameters:</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>grpquota:</th><td>When parameter <strong>grpquota</strong> is present and set to a value that evaluates to\n<em>True</em>, the value in <em>uid</em> is taken as GID and group quotas are queried.\nGroup quotas may not be supported across all platforms (e.g. Linux and\nother BSD based Unix variants, OSF/1 and  AIX - check the quotactl(2) man\npage on your systems).</td>\n</tr>\n<tr><th>prjquota:</th><td>When parameter <strong>prjquota</strong> is present and set to a value that evaluates to\n<em>True</em>, project quotas are queried; this is currently only supported for\nXFS. Exception <strong>FsQuota.error(ENOTSUP)</strong> is raised for unsupported\nfile-systems.</td>\n</tr>\n</tbody>\n</table>\n<p>It is an error to select both group and project quota in the same query.</p>\n</div>\n<div id=\"method-quota-setqlim\">\n<h3>Method Quota.setqlim()</h3>\n<pre>qObj.setqlim(uid, bsoft, bhard, isoft, ihard [,keyword options...])\n</pre>\n<p>Sets quota limits for the given user. Meanings of parameters <em>uid</em>,\n<em>bsoft</em>, <em>bhard</em>, <em>isoft</em> and <em>ihard</em> are the same as for the <strong>query()</strong>\nmethod.</p>\n<p>Note all the limit values are optional and default to zero. The parameters\ncan also be passed in form of keyword parameters. For example\n<cite>qObj.setqlim(uid, isoft=10,ihard=20)</cite> would limit inode counts to 10\nsoft, 20 hard, but remove limits for block count. (Note it\u2019s not possible\nto set only block or inode limits repsectively; to do so query current\nlimits first and then pass those values to setqlim if you want to keep\nthem unchanged.)</p>\n<p>Note: if you want to set the quota of a particular user to zero, i.e.\nno write permission, you must not set all limits to zero, since that\nis equivalent to unlimited access. Instead set only the hard limit\nto 0 and the soft limit to a non-zero value.</p>\n<p>Optional keyword-only parameters:</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>timereset:</th><td>Optional parameter <strong>timereset</strong> defines how time limits are\ninitialized: When the assigned value is <em>False</em>, time limits are set to\n<cite>NOT STARTED</cite> (i.e. the time limits are not initialized until the first\nwrite attempt by this user). This is the default when the parameter is\nomitted. When assigned <em>True</em>, the time limits are set to <cite>7.0 days</cite>.\nMore alternatives (i.e. setting a specific time) aren\u2019t available in most\nimplementations.</td>\n</tr>\n<tr><th>grpquota:</th><td>When parameter <strong>grpquota</strong> is present and set to True, parameter <em>uid</em> is\ninterpreted as GID and the the limit of the corresponding group is\nmodified. This is not supported on all platforms.</td>\n</tr>\n<tr><th>prjquota:</th><td>When parameter <strong>prjquota</strong> is present and set to True, project quotas are\nmodified; this is currently only supported for XFS.  Exception\n<strong>FsQuota.error(ENOTSUP)</strong> is raised for unsupported file-systems.</td>\n</tr>\n</tbody>\n</table>\n<p>It is an error to select both group and project quota in the same query.</p>\n<p>Note that the class does not support setting quotas via RPC (even\nthough some implementations of <em>rpc.rquotad(8)</em> allow optionally\nenabling this, but it seems a bad idea for security.)</p>\n</div>\n<div id=\"method-quota-sync\">\n<h3>Method Quota.sync()</h3>\n<pre>qObj.sync()\n</pre>\n<p>Have the kernel update the quota file on disk, in particular after\nmodifying quota limits.</p>\n<p>A secondary purpose of this method is checking if quota support is\nenabled in the kernel (and on some platforms, for a particular file\nsystem; on others however the call succeeds even if quota is not enabled\nin the given file system.) Read the <strong>quotaon(1m)</strong> man page on how to\nenable quotas on a file system.</p>\n</div>\n<div id=\"method-quota-rpc-opt\">\n<h3>Method Quota.rpc_opt()</h3>\n<pre>qObj.rpc_opt([keyword options...])\n</pre>\n<p>This method allows configuring networking and authentication parameters\nfor queries of network file system quotas via RPC. The options have no\neffect when targeting other file system types. The following keyword-only\nparameters are available:</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>rpc_port:</th><td>Sets the port used by <em>rpc.rquotad(8)</em>; default value is zero, which\nwhich means the remote host\u2019s portmapper (aka rpcbind) is used. (Note\nin case of the latter you can find out the port using <em>rpcinfo -p host</em>)</td>\n</tr>\n<tr><th>rpc_use_tcp:</th><td>If <em>True</em>, use TCP; if <em>False</em> use UDP (default).</td>\n</tr>\n<tr><th>rpc_timeout:</th><td>Timeout value in milliseconds in case the remote host does not respond.</td>\n</tr>\n<tr><th>auth_uid:</th><td>UID value (i.e. user identifier) to provide for authentication.\nIf not specified, this defaults to the UID of the current process.\nFor example, you could set the UID here that you later want to\nquery, for circumventing a permission error.</td>\n</tr>\n<tr><th>auth_gid:</th><td>GID value (i.e. group identifier) to provide for authentication.\nIf not specified, this defaults to the GID of the current process.</td>\n</tr>\n<tr><th>auth_hostname:</th><td>Hostname to provide for authentication.\nIf not specified or empty, this defaults to the name of the local machine.</td>\n</tr>\n</tbody>\n</table>\n<p>Note for resetting to default authentication, set both <strong>auth_uid</strong> and\n<strong>auth_gid</strong> to value -1 (even if you previously changed only one, as the\nopposite is filled in automatically if missing).</p>\n</div>\n<div id=\"attribute-quota-dev\">\n<h3>Attribute Quota.dev</h3>\n<p>This attribute provides the device argument used internally by <strong>query()</strong>\nand <strong>setqlim()</strong> methods for the selected file system.</p>\n</div>\n<div id=\"attribute-quota-is-nfs\">\n<h3>Attribute Quota.is_nfs</h3>\n<p>This attribute indicates 1 is the file system is NFS, else 0.</p>\n</div>\n</div>\n<div id=\"class-fsquota-mnttab\">\n<h2>Class FsQuota.MntTab()</h2>\n<p>This class defines objects that can be used as an iterator which lists all\nentries in the mount table. Each object returned by iteration is a named\ntuple of type <strong>FsQuota.MntEnt</strong> with the following entries of type\nstring:</p>\n<ol>\n<li><strong>mnt_fsname</strong>: Name of the filesystem (e.g. device name)</li>\n<li><strong>mnt_dir</strong>: Filesystem path prefix (aka mount point)</li>\n<li><strong>mnt_type</strong>: Mount type (aka file system type)</li>\n<li><strong>mnt_opts</strong>: Mount options, separated by colon.</li>\n</ol>\n<p>Note the mount table contains information about all currently mounted\n(local or remote) file systems.  The format and location of this table\nvaries from system to system (e.g. it may be in file <cite>/etc/mtab</cite>).\nThis iterator provides a portable way to read it. (On some systems,\nlike <strong>OSF/1</strong>, this table isn\u2019t accessible as a file at all, i.e. only\nvia C library interfaces). Internally, the iterator will call\n<em>setmntent(3)</em> or the equivalent of your platform upon initialization,\ncall <em>getmntent(3)</em> during iteration, and call <em>endmntent(3)</em> upon\ndeallocation.</p>\n<p>Hint: For finding the mount table entry corresponding to a given path\n(e.g. to determine the file system type), you can compare the device ID\nindicated by <em>os.stat(path).st_dev</em> of the mount points returned from\niteration with that of the path in question.</p>\n</div>\n<div id=\"error-handling\">\n<h2>ERROR HANDLING</h2>\n<p>All methods raise exception <strong>FsQuota.error</strong> upon errors. The exception\nclass is derived from exception <strong>OSError</strong> and thus contains firstly a\nnumerical error code in attribute <strong>errno</strong> (copied from <em>errno</em> in most\ncases), secondly a derived error message in attribute <strong>strerror</strong>, and\nwhen applicable, thirdly a file name in attribute <strong>filename</strong>.</p>\n<p>Note the error string is adapted to the context of quota operations and\ntherefore not always identical to the text returned by\n<strong>strerror(ex.errno)</strong>.  This is necessary as normal error descriptions\ndon\u2019t always make sense for quota errors (e.g. <em>ESRCH</em>: <em>No such process</em>,\nhere: <em>No quota for this user</em>)</p>\n</div>\n<div id=\"authors\">\n<h2>AUTHORS</h2>\n<p>This module is derived from an equivalent extension module for Perl,\ncreated 1995 by T. Zoerner (email: tomzo AT users.sourceforge.net)\nand since then continuously improved and ported to many more\noperating systems and file systems - and now ported to Python.\nNumerous people have contributed to this process in the past;\nfor a complete list of names please see the CHANGES document.</p>\n</div>\n<div id=\"license\">\n<h2>LICENSE</h2>\n<p>Copyright (C) 1995-2020 T. Zoerner</p>\n<p>This program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by the\nFree Software Foundation. (Either version 2 of the GPL, or any later\nversion, see <a href=\"http://www.opensource.org/licenses/\" rel=\"nofollow\">http://www.opensource.org/licenses/</a>).</p>\n<p>This program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.</p>\n</div>\n<div id=\"see-also\">\n<h2>SEE ALSO</h2>\n<p>python3(1), edquota(8),\nquotactl(2) or quotactl(7I),\nmount(8), mtab(4) or mnttab(4), quotaon(8),\nsetmntent(3), getmntent(3) or getmntinfo(3), endmntent(3),\nrpc(3), rquotad(8) or rpc.rquotad(8), rpcinfo(7).</p>\n</div>\n\n          </div>"}, "last_serial": 7061859, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "acf4b81907d08f6a4520f4eb11ad1c8f", "sha256": "5295daa3138f1d5cff0da0da50252ddb37e19178aa58a94bdc6909e4ee132c94"}, "downloads": -1, "filename": "FsQuota-0.0.2.tar.gz", "has_sig": false, "md5_digest": "acf4b81907d08f6a4520f4eb11ad1c8f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.2", "size": 61012, "upload_time": "2020-04-14T10:23:08", "upload_time_iso_8601": "2020-04-14T10:23:08.693007Z", "url": "https://files.pythonhosted.org/packages/ba/7b/19914f0f1ca7de4e650666e90e5d995e3bd3da85daee756a1a7ef745d1a7/FsQuota-0.0.2.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "d741877a2247dd85e6f2daa29dedc111", "sha256": "dd9cdcf3b3fc91d524e17cbb74288ce3dbed86ca24132aecad335be2c7c21402"}, "downloads": -1, "filename": "FsQuota-0.1.0.tar.gz", "has_sig": false, "md5_digest": "d741877a2247dd85e6f2daa29dedc111", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.2", "size": 64093, "upload_time": "2020-04-20T18:23:36", "upload_time_iso_8601": "2020-04-20T18:23:36.295018Z", "url": "https://files.pythonhosted.org/packages/fc/d4/52905d47509e2bd2399597f2c976aa1ba6e7a3780469c2f01adf7016fc8c/FsQuota-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d741877a2247dd85e6f2daa29dedc111", "sha256": "dd9cdcf3b3fc91d524e17cbb74288ce3dbed86ca24132aecad335be2c7c21402"}, "downloads": -1, "filename": "FsQuota-0.1.0.tar.gz", "has_sig": false, "md5_digest": "d741877a2247dd85e6f2daa29dedc111", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.2", "size": 64093, "upload_time": "2020-04-20T18:23:36", "upload_time_iso_8601": "2020-04-20T18:23:36.295018Z", "url": "https://files.pythonhosted.org/packages/fc/d4/52905d47509e2bd2399597f2c976aa1ba6e7a3780469c2f01adf7016fc8c/FsQuota-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:00:02 2020"}