{"info": {"author": "Bernhard Bauer-Marschallinger", "author_email": "bbm@geo.tuwien.ac.at", "bugtrack_url": null, "classifiers": [], "description": "=============\ngeopathfinder\n=============\n\n\nA package for creating, quering, and searching in data structures holding geo data sets.\n\n\nDescription\n===========\n\nThis packages aims to provide a rich toolbox for efficient, quick, and precise handling of filenames and folder structures for geo-data, most conviniently when combined with grid objects as e.g. the https://github.com/TUW-GEO/Equi7Grid.\n\nWith pre-defined sets comprising string-definitions, folder path logics, and filename en-/decoders, a variety of file/folder naming conventions can be implemented.\n\nThe base classes SmartPath() and SmartTree() comprise also functions for file search and folder(-tree) volume determination.\n\n\nAdding a new filenaming convention\n----------------------------------\nIn general, please follow the code and test guidelines of existing naming conventions.\nThe following description aims to show how to implement a new naming convention:\n\n- Create a new .py file in the folder \"geopathfinder/naming_conventions/\". The filename should be an abbreviation of the new naming convention separated from \"naming\" with an underscore, e.g., \"sgrt_naming.py\" ot \"eodr_naming.py\".\n\n- Inside this file, write a new class, which inherits from *SmartFilename*. In this class you can define how the filename structure should look like. For each field you can define the length of the field ('len', integer), if a delimiter should be in between the current and the previous part of the filename ('delim', boolean) and finally, if desired, a decoding and encoding function ('decoder', 'encoder'). The latter parameters should point via a lambda function to a decoding or encoding method defined in the same class.\n\n- Finally, the parent class *SmartFilename* can be initiated with the given fields, fields definitions, a padding, a delimiter and a boolean value if en-/decoding should be applied or not.\n\n- Sometimes one needs information from the filename, which can be directly derived from one or multiple filename entries. An example would be a mean date derived from the start and end date specified in the filename.\n  To allow this, one can define methods tagged with *property* in the current class. *SmartFilename* then handles the properties of the inherited class equally to a common filename entry given in the field definition.\n  \n- The second important part is the functionality of parsing a string following the new filenaming convention. To do so,\n  create a new function below the class definition. It should be named \"create_[]_filename\", where \"[]\" should be replaced by the abbreviation of the new naming convention.\n  This function should split the filename string into parts needed for initialising a fields dictionary. As a result, the function returns a class instance of the class defined before.\n  \n- Add tests to \"tests\" and name the test file \"test_[]_naming.py\", where \"[]\" should be replaced by the abbreviation of the new naming convention.\n\n\nNote\n====\n\nThis project has been set up using PyScaffold 2.5.11. For details and usage\ninformation on PyScaffold see http://pyscaffold.readthedocs.org/.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://...", "keywords": "", "license": "mit", "maintainer": "", "maintainer_email": "", "name": "geopathfinder", "package_url": "https://pypi.org/project/geopathfinder/", "platform": "", "project_url": "https://pypi.org/project/geopathfinder/", "project_urls": {"Homepage": "http://..."}, "release_url": "https://pypi.org/project/geopathfinder/0.0.5/", "requires_dist": null, "requires_python": "", "summary": "Add a short description here!", "version": "0.0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>=============\ngeopathfinder</h1>\n<p>A package for creating, quering, and searching in data structures holding geo data sets.</p>\n<h1>Description</h1>\n<p>This packages aims to provide a rich toolbox for efficient, quick, and precise handling of filenames and folder structures for geo-data, most conviniently when combined with grid objects as e.g. the <a href=\"https://github.com/TUW-GEO/Equi7Grid\" rel=\"nofollow\">https://github.com/TUW-GEO/Equi7Grid</a>.</p>\n<p>With pre-defined sets comprising string-definitions, folder path logics, and filename en-/decoders, a variety of file/folder naming conventions can be implemented.</p>\n<p>The base classes SmartPath() and SmartTree() comprise also functions for file search and folder(-tree) volume determination.</p>\n<h2>Adding a new filenaming convention</h2>\n<p>In general, please follow the code and test guidelines of existing naming conventions.\nThe following description aims to show how to implement a new naming convention:</p>\n<ul>\n<li>\n<p>Create a new .py file in the folder \"geopathfinder/naming_conventions/\". The filename should be an abbreviation of the new naming convention separated from \"naming\" with an underscore, e.g., \"sgrt_naming.py\" ot \"eodr_naming.py\".</p>\n</li>\n<li>\n<p>Inside this file, write a new class, which inherits from <em>SmartFilename</em>. In this class you can define how the filename structure should look like. For each field you can define the length of the field ('len', integer), if a delimiter should be in between the current and the previous part of the filename ('delim', boolean) and finally, if desired, a decoding and encoding function ('decoder', 'encoder'). The latter parameters should point via a lambda function to a decoding or encoding method defined in the same class.</p>\n</li>\n<li>\n<p>Finally, the parent class <em>SmartFilename</em> can be initiated with the given fields, fields definitions, a padding, a delimiter and a boolean value if en-/decoding should be applied or not.</p>\n</li>\n<li>\n<p>Sometimes one needs information from the filename, which can be directly derived from one or multiple filename entries. An example would be a mean date derived from the start and end date specified in the filename.\nTo allow this, one can define methods tagged with <em>property</em> in the current class. <em>SmartFilename</em> then handles the properties of the inherited class equally to a common filename entry given in the field definition.</p>\n</li>\n<li>\n<p>The second important part is the functionality of parsing a string following the new filenaming convention. To do so,\ncreate a new function below the class definition. It should be named \"create_[]_filename\", where \"[]\" should be replaced by the abbreviation of the new naming convention.\nThis function should split the filename string into parts needed for initialising a fields dictionary. As a result, the function returns a class instance of the class defined before.</p>\n</li>\n<li>\n<p>Add tests to \"tests\" and name the test file \"test_[]_naming.py\", where \"[]\" should be replaced by the abbreviation of the new naming convention.</p>\n</li>\n</ul>\n<h1>Note</h1>\n<p>This project has been set up using PyScaffold 2.5.11. For details and usage\ninformation on PyScaffold see <a href=\"http://pyscaffold.readthedocs.org/\" rel=\"nofollow\">http://pyscaffold.readthedocs.org/</a>.</p>\n\n          </div>"}, "last_serial": 5571740, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "d4975a328e4d8fa0ff7a0cb014efd793", "sha256": "fb7dfc04b113bfcab4d1b2f0088937d192f0d037dc818ab8d3a6c1b6898fcdc7"}, "downloads": -1, "filename": "geopathfinder-0.0.1.tar.gz", "has_sig": false, "md5_digest": "d4975a328e4d8fa0ff7a0cb014efd793", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 996528, "upload_time": "2018-02-07T11:22:28", "upload_time_iso_8601": "2018-02-07T11:22:28.247449Z", "url": "https://files.pythonhosted.org/packages/66/51/4eb1596b78e247d52469d4be3927faae4362d570f01aa09c6ea87f85664a/geopathfinder-0.0.1.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "a96a083dc332cdd3c21c88e04cdc562c", "sha256": "61a89cd1c4bbc453bd1c133becf8b50bf962f078a15dc262732313a5719b5ac2"}, "downloads": -1, "filename": "geopathfinder-0.0.4.tar.gz", "has_sig": false, "md5_digest": "a96a083dc332cdd3c21c88e04cdc562c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1036098, "upload_time": "2018-11-28T09:03:21", "upload_time_iso_8601": "2018-11-28T09:03:21.017684Z", "url": "https://files.pythonhosted.org/packages/52/3f/9bf00108b5e1f8244e96f331d0ac64e4fc9eed3723a6a53ed48f6dbdc14f/geopathfinder-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "d7b02f35e41f589788b9cdfc860cb77a", "sha256": "18bc8151afd22390bfe8d19df1de0cc69277f39a4d48c3fef2d91ff0109c9acf"}, "downloads": -1, "filename": "geopathfinder-0.0.5.tar.gz", "has_sig": false, "md5_digest": "d7b02f35e41f589788b9cdfc860cb77a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1040106, "upload_time": "2019-07-23T10:27:20", "upload_time_iso_8601": "2019-07-23T10:27:20.912983Z", "url": "https://files.pythonhosted.org/packages/f9/2b/cba68bd0ee8ff80573a50a5a27886b18cb3d8ea62ddf8661d624e0f909d6/geopathfinder-0.0.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d7b02f35e41f589788b9cdfc860cb77a", "sha256": "18bc8151afd22390bfe8d19df1de0cc69277f39a4d48c3fef2d91ff0109c9acf"}, "downloads": -1, "filename": "geopathfinder-0.0.5.tar.gz", "has_sig": false, "md5_digest": "d7b02f35e41f589788b9cdfc860cb77a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1040106, "upload_time": "2019-07-23T10:27:20", "upload_time_iso_8601": "2019-07-23T10:27:20.912983Z", "url": "https://files.pythonhosted.org/packages/f9/2b/cba68bd0ee8ff80573a50a5a27886b18cb3d8ea62ddf8661d624e0f909d6/geopathfinder-0.0.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:57:59 2020"}