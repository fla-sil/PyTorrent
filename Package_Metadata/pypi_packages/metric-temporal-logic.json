{"info": {"author": "Marcell Vazquez-Chanlatte", "author_email": "mvc@linux.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "<figure>\n  <img src=\"assets/logo.png\" alt=\"py-metric-temporal logic logo\" width=300px>\n  <figcaption>\n  A library for manipulating and evaluating metric temporal logic.\n  </figcaption>\n</figure>\n\n\n\n[![Build Status](https://cloud.drone.io/api/badges/mvcisback/py-metric-temporal-logic/status.svg)](https://cloud.drone.io/mvcisback/py-metric-temporal-logic)\n[![codecov](https://codecov.io/gh/mvcisback/py-metric-temporal-logic/branch/master/graph/badge.svg)](https://codecov.io/gh/mvcisback/py-metric-temporal-logic)\n[![PyPI version](https://badge.fury.io/py/metric-temporal-logic.svg)](https://badge.fury.io/py/metric-temporal-logic)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![DOI](https://zenodo.org/badge/72686883.svg)](https://zenodo.org/badge/latestdoi/72686883)\n\n<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->\n**Table of Contents**\n\n- [About](#about)\n- [Installation](#installation)\n- [Usage](#usage)\n    - [Python Operator API](#python-operator-api)\n        - [Propositional logic (using python syntax)](#propositional-logic-using-python-syntax)\n        - [Modal Logic (using python syntax)](#modal-logic-using-python-syntax)\n    - [String based API](#string-based-api)\n        - [Propositional logic (parse api)](#propositional-logic-parse-api)\n        - [Modal Logic (parser api)](#modal-logic-parser-api)\n    - [Boolean Evaluation](#boolean-evaluation)\n    - [Quantitative Evaluate (Signal Temporal Logic)](#quantitative-evaluate-signal-temporal-logic)\n    - [Utilities](#utilities)\n- [Similar Projects](#similar-projects)\n- [Citing](#citing)\n\n<!-- markdown-toc end -->\n\n# About\n\nPython library for working with Metric Temporal Logic (MTL). Metric\nTemporal Logic is an extension of Linear Temporal Logic (LTL) for\nspecifying properties over time series (See [Alur][1]). Some practical examples are\ngiven in the usage.\n\n# Installation\n\nIf you just need to use `metric-temporal-logic`, you can just run:\n\n`$ pip install metric-temporal-logic`\n\nFor developers, note that this project uses the\n[poetry](https://poetry.eustace.io/) python package/dependency\nmanagement tool. Please familarize yourself with it and then\nrun:\n\n`$ poetry install`\n\n\n# Usage\n\nTo begin, we import `mtl`.\n\n```python\nimport mtl\n```\n\nThere are **two** APIs for interacting with the `mtl` module. Namely, one can specify the MTL expression using:\n1. [Python Operators](#python-operator-api).\n2. [Strings + The parse API](#string-based-api).\n\nWe begin with the Python Operator API:\n\n## Python Operator API\n\n### Propositional logic (using python syntax)\n```python\na, b = mtl.parse('a'), mtl.parse('b')\nphi0 = ~a\nphi1 = a & b\nphi2 = a | b\nphi3 = a ^ b\nphi4 = a.iff(b)\nphi5 = a.implies(b)\n```\n\n\n### Modal Logic (using python syntax)\n\n```python\na, b = mtl.parse('a'), mtl.parse('b')\n\n# Eventually `a` will hold.\nphi1 = a.eventually()\n\n# `a & b` will always hold.\nphi2 = (a & b).always()\n\n# `a` until `b`\nphi3 = a.until()\n\n# `a` weak until `b`\nphi4 = a.weak_until(b)\n\n# Whenever `a` holds, then `b` holds in the next two time units.\nphi5 = (a.implies(b.eventually(lo=0, hi=2))).always()\n\n# We also support timed until.\nphi6 = a.timed_until(b, lo=0, hi=2)\n\n# `a` holds in two time steps.\nphi7 = a >> 2\n```\n\n## String based API\n\n### Propositional logic (parse api)\n```python\n# - Lowercase strings denote atomic predicates.\nphi0 = mtl.parse('atomicpred')\n\n# - infix operators need to be surrounded by parens.\nphi1 = mtl.parse('((a & b & c) | d | e)')\nphi2 = mtl.parse('(a -> b) & (~a -> c)')\nphi3 = mtl.parse('(a -> b -> c)')\nphi4 = mtl.parse('(a <-> b <-> c)')\nphi5 = mtl.parse('(x ^ y ^ z)')\n\n# - Unary operators (negation)\nphi6 = mtl.parse('~a')\nphi7 = mtl.parse('~(a)')\n```\n\n### Modal Logic (parser api)\n\n```python\n# Eventually `x` will hold.\nphi1 = mtl.parse('F x')\n\n# `x & y` will always hold.\nphi2 = mtl.parse('G(x & y)')\n\n# `x` holds until `y` holds. \n# Note that since `U` is binary, it requires parens.\nphi3 = mtl.parse('(x U y)')\n\n# Weak until (`y` never has to hold).\nphi4 = mtl.parse('(x W y)')\n\n# Whenever `x` holds, then `y` holds in the next two time units.\nphi5 = mtl.parse('G(x -> F[0, 2] y)')\n\n# We also support timed until.\nphi6 = mtl.parse('(a U[0, 2] b)')\n\n# Finally, if time is discretized, we also support the next operator.\n# Thus, LTL can also be modeled.\n# `a` holds in two time steps.\nphi7 = mtl.parse('XX a')\n```\n\n## Quantitative Evaluate (Signal Temporal Logic)\n\nGiven a property `phi`, one can evaluate is a timeseries satisifies\n`phi`. Time Series can either be defined using a dictionary mapping\natomic predicate names to lists of (`time`, `val`) pairs **or** using\nthe [DiscreteSignals](https://github.com/mvcisback/DiscreteSignals)\nAPI (used internally).\n\nThere are two types of evaluation. One uses the boolean semantics of\nMTL and the other uses Signal Temporal Logic like semantics.\n\n\n```python\n# Assumes piece wise constant interpolation.\ndata = {\n    'a': [(0, 100), (1, -1), (3, -2)],\n    'b': [(0, 20), (0.2, 2), (4, -10)]\n}\n\nphi = mtl.parse('F(a | b)')\nprint(phi(data))\n# output: 100\n\n# Evaluate at t=3\nprint(phi(data, time=3))\n# output: 2\n\n# Evaluate with discrete time\nphi = mtl.parse('X b')\nprint(phi(data, dt=0.2))\n# output: 2\n```\n\n## Boolean Evaluation\n\nTo Boolean semantics can be thought of as a special case of the\nquantitative semantics where `True \u21a6 1` and `False \u21a6 -1`.  This\nconversion happens automatically using using the `quantitative=False`\nflag.\n\n\n```python\n# Assumes piece wise constant interpolation.\ndata = {\n    'a': [(0, True), (1, False), (3, False)],\n    'b': [(0, False), (0.2, True), (4, False)]\n}\n\nphi = mtl.parse('F(a | b)')\nprint(phi(data, quantitative=False))\n# output: True\n\nphi = mtl.parse('F(a | b)')\nprint(phi(data))\n# output: True\n\n# Note, quantitative parameter defaults to False\n\n# Evaluate at t=3. \nprint(phi(data, time=3, quantitative=False))\n# output: False\n\n# Compute sliding satisifaction.\nprint(phi(data, time=None, quantitative=False))\n# output: [(0, True), (0.2, True), (4, False)]\n\n# Evaluate with discrete time\nphi = mtl.parse('X b')\nprint(phi(data, dt=0.2, quantitative=False))\n# output: True\n```\n\n## Utilities\n```python\nimport mtl\nfrom mtl import utils\n\nprint(utils.scope(mtl.parse('XX a'), dt=0.1))\n# output: 0.2\n\nprint(utils.discretize(mtl.parse('F[0, 0.2] a'), dt=0.1))\n# output: (a | X a | XX a)\n```\n\n# Similar Projects\nFeel free to open up a pull-request to add other similar projects. This library was written to meet some of my unique needs, for example I wanted the AST to be immutable and wanted the library to **just** handle manipulating MTL. Many other similar projects exist with different goals.\n\n1. https://github.com/doganulus/python-monitors\n1. https://github.com/STLInspector/STLInspector\n\n# Citing\n\n    @misc{pyMTL,\n      author       = {Marcell Vazquez-Chanlatte},\n      title        = {mvcisback/py-metric-temporal-logic: v0.1.1},\n      month        = jan,\n      year         = 2019,\n      doi          = {10.5281/zenodo.2548862},\n      url          = {https://doi.org/10.5281/zenodo.2548862}\n    }\n\n[1]: https://link.springer.com/chapter/10.1007/BFb0031988\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mvcisback/py-metric-temporal-logic", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "metric-temporal-logic", "package_url": "https://pypi.org/project/metric-temporal-logic/", "platform": "", "project_url": "https://pypi.org/project/metric-temporal-logic/", "project_urls": {"Homepage": "https://github.com/mvcisback/py-metric-temporal-logic", "Repository": "https://github.com/mvcisback/py-metric-temporal-logic"}, "release_url": "https://pypi.org/project/metric-temporal-logic/0.1.7/", "requires_dist": ["attrs (>=19.3.0,<20.0.0)", "lenses (>=0.5.0,<0.6.0)", "discrete-signals (>=0.7.3,<0.8.0)", "parsimonious (>=0.8.1,<0.9.0)"], "requires_python": ">=3.6,<4.0", "summary": "A library for manipulating and evaluating metric temporal logic.", "version": "0.1.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            &lt;figure&gt;\n  <img alt=\"py-metric-temporal logic logo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/37f5a425c43c2608df4d5582347570ee5ba3b445/6173736574732f6c6f676f2e706e67\" width=\"300px\">\n  &lt;figcaption&gt;\n  A library for manipulating and evaluating metric temporal logic.\n  &lt;/figcaption&gt;\n&lt;/figure&gt;\n<p><a href=\"https://cloud.drone.io/mvcisback/py-metric-temporal-logic\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a2f5acc282a766e85677703fc32ef0bb8cf76a9b/68747470733a2f2f636c6f75642e64726f6e652e696f2f6170692f6261646765732f6d766369736261636b2f70792d6d65747269632d74656d706f72616c2d6c6f6769632f7374617475732e737667\"></a>\n<a href=\"https://codecov.io/gh/mvcisback/py-metric-temporal-logic\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/22d96e2f97bcf6a17a8f087e8887944f5c710212/68747470733a2f2f636f6465636f762e696f2f67682f6d766369736261636b2f70792d6d65747269632d74656d706f72616c2d6c6f6769632f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://badge.fury.io/py/metric-temporal-logic\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/63c65abcad2c84732498c528d37ca7ac5e5498cb/68747470733a2f2f62616467652e667572792e696f2f70792f6d65747269632d74656d706f72616c2d6c6f6769632e737667\"></a>\n<a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img alt=\"License: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8645b002dd7ec1b54275a80574942e7a318e03c6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d79656c6c6f772e737667\"></a>\n<a href=\"https://zenodo.org/badge/latestdoi/72686883\" rel=\"nofollow\"><img alt=\"DOI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fca59618270d13b829abcc679ce4e04885b01746/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f37323638363838332e737667\"></a></p>\n\n<p><strong>Table of Contents</strong></p>\n<ul>\n<li><a href=\"#about\" rel=\"nofollow\">About</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a>\n<ul>\n<li><a href=\"#python-operator-api\" rel=\"nofollow\">Python Operator API</a>\n<ul>\n<li><a href=\"#propositional-logic-using-python-syntax\" rel=\"nofollow\">Propositional logic (using python syntax)</a></li>\n<li><a href=\"#modal-logic-using-python-syntax\" rel=\"nofollow\">Modal Logic (using python syntax)</a></li>\n</ul>\n</li>\n<li><a href=\"#string-based-api\" rel=\"nofollow\">String based API</a>\n<ul>\n<li><a href=\"#propositional-logic-parse-api\" rel=\"nofollow\">Propositional logic (parse api)</a></li>\n<li><a href=\"#modal-logic-parser-api\" rel=\"nofollow\">Modal Logic (parser api)</a></li>\n</ul>\n</li>\n<li><a href=\"#boolean-evaluation\" rel=\"nofollow\">Boolean Evaluation</a></li>\n<li><a href=\"#quantitative-evaluate-signal-temporal-logic\" rel=\"nofollow\">Quantitative Evaluate (Signal Temporal Logic)</a></li>\n<li><a href=\"#utilities\" rel=\"nofollow\">Utilities</a></li>\n</ul>\n</li>\n<li><a href=\"#similar-projects\" rel=\"nofollow\">Similar Projects</a></li>\n<li><a href=\"#citing\" rel=\"nofollow\">Citing</a></li>\n</ul>\n\n<h1>About</h1>\n<p>Python library for working with Metric Temporal Logic (MTL). Metric\nTemporal Logic is an extension of Linear Temporal Logic (LTL) for\nspecifying properties over time series (See <a href=\"https://link.springer.com/chapter/10.1007/BFb0031988\" rel=\"nofollow\">Alur</a>). Some practical examples are\ngiven in the usage.</p>\n<h1>Installation</h1>\n<p>If you just need to use <code>metric-temporal-logic</code>, you can just run:</p>\n<p><code>$ pip install metric-temporal-logic</code></p>\n<p>For developers, note that this project uses the\n<a href=\"https://poetry.eustace.io/\" rel=\"nofollow\">poetry</a> python package/dependency\nmanagement tool. Please familarize yourself with it and then\nrun:</p>\n<p><code>$ poetry install</code></p>\n<h1>Usage</h1>\n<p>To begin, we import <code>mtl</code>.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">mtl</span>\n</pre>\n<p>There are <strong>two</strong> APIs for interacting with the <code>mtl</code> module. Namely, one can specify the MTL expression using:</p>\n<ol>\n<li><a href=\"#python-operator-api\" rel=\"nofollow\">Python Operators</a>.</li>\n<li><a href=\"#string-based-api\" rel=\"nofollow\">Strings + The parse API</a>.</li>\n</ol>\n<p>We begin with the Python Operator API:</p>\n<h2>Python Operator API</h2>\n<h3>Propositional logic (using python syntax)</h3>\n<pre><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'a'</span><span class=\"p\">),</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'b'</span><span class=\"p\">)</span>\n<span class=\"n\">phi0</span> <span class=\"o\">=</span> <span class=\"o\">~</span><span class=\"n\">a</span>\n<span class=\"n\">phi1</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">&amp;</span> <span class=\"n\">b</span>\n<span class=\"n\">phi2</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">|</span> <span class=\"n\">b</span>\n<span class=\"n\">phi3</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">^</span> <span class=\"n\">b</span>\n<span class=\"n\">phi4</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">iff</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"n\">phi5</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">implies</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<h3>Modal Logic (using python syntax)</h3>\n<pre><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'a'</span><span class=\"p\">),</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'b'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Eventually `a` will hold.</span>\n<span class=\"n\">phi1</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">eventually</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># `a &amp; b` will always hold.</span>\n<span class=\"n\">phi2</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"o\">&amp;</span> <span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">always</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># `a` until `b`</span>\n<span class=\"n\">phi3</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">until</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># `a` weak until `b`</span>\n<span class=\"n\">phi4</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">weak_until</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Whenever `a` holds, then `b` holds in the next two time units.</span>\n<span class=\"n\">phi5</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">implies</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">eventually</span><span class=\"p\">(</span><span class=\"n\">lo</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">hi</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)))</span><span class=\"o\">.</span><span class=\"n\">always</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># We also support timed until.</span>\n<span class=\"n\">phi6</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">timed_until</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">lo</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">hi</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># `a` holds in two time steps.</span>\n<span class=\"n\">phi7</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">2</span>\n</pre>\n<h2>String based API</h2>\n<h3>Propositional logic (parse api)</h3>\n<pre><span class=\"c1\"># - Lowercase strings denote atomic predicates.</span>\n<span class=\"n\">phi0</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'atomicpred'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># - infix operators need to be surrounded by parens.</span>\n<span class=\"n\">phi1</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'((a &amp; b &amp; c) | d | e)'</span><span class=\"p\">)</span>\n<span class=\"n\">phi2</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(a -&gt; b) &amp; (~a -&gt; c)'</span><span class=\"p\">)</span>\n<span class=\"n\">phi3</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(a -&gt; b -&gt; c)'</span><span class=\"p\">)</span>\n<span class=\"n\">phi4</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(a &lt;-&gt; b &lt;-&gt; c)'</span><span class=\"p\">)</span>\n<span class=\"n\">phi5</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(x ^ y ^ z)'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># - Unary operators (negation)</span>\n<span class=\"n\">phi6</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'~a'</span><span class=\"p\">)</span>\n<span class=\"n\">phi7</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'~(a)'</span><span class=\"p\">)</span>\n</pre>\n<h3>Modal Logic (parser api)</h3>\n<pre><span class=\"c1\"># Eventually `x` will hold.</span>\n<span class=\"n\">phi1</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'F x'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># `x &amp; y` will always hold.</span>\n<span class=\"n\">phi2</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'G(x &amp; y)'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># `x` holds until `y` holds. </span>\n<span class=\"c1\"># Note that since `U` is binary, it requires parens.</span>\n<span class=\"n\">phi3</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(x U y)'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Weak until (`y` never has to hold).</span>\n<span class=\"n\">phi4</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(x W y)'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Whenever `x` holds, then `y` holds in the next two time units.</span>\n<span class=\"n\">phi5</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'G(x -&gt; F[0, 2] y)'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># We also support timed until.</span>\n<span class=\"n\">phi6</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(a U[0, 2] b)'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Finally, if time is discretized, we also support the next operator.</span>\n<span class=\"c1\"># Thus, LTL can also be modeled.</span>\n<span class=\"c1\"># `a` holds in two time steps.</span>\n<span class=\"n\">phi7</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'XX a'</span><span class=\"p\">)</span>\n</pre>\n<h2>Quantitative Evaluate (Signal Temporal Logic)</h2>\n<p>Given a property <code>phi</code>, one can evaluate is a timeseries satisifies\n<code>phi</code>. Time Series can either be defined using a dictionary mapping\natomic predicate names to lists of (<code>time</code>, <code>val</code>) pairs <strong>or</strong> using\nthe <a href=\"https://github.com/mvcisback/DiscreteSignals\" rel=\"nofollow\">DiscreteSignals</a>\nAPI (used internally).</p>\n<p>There are two types of evaluation. One uses the boolean semantics of\nMTL and the other uses Signal Temporal Logic like semantics.</p>\n<pre><span class=\"c1\"># Assumes piece wise constant interpolation.</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">)],</span>\n    <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">)]</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">phi</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'F(a | b)'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: 100</span>\n\n<span class=\"c1\"># Evaluate at t=3</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: 2</span>\n\n<span class=\"c1\"># Evaluate with discrete time</span>\n<span class=\"n\">phi</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'X b'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: 2</span>\n</pre>\n<h2>Boolean Evaluation</h2>\n<p>To Boolean semantics can be thought of as a special case of the\nquantitative semantics where <code>True \u21a6 1</code> and <code>False \u21a6 -1</code>.  This\nconversion happens automatically using using the <code>quantitative=False</code>\nflag.</p>\n<pre><span class=\"c1\"># Assumes piece wise constant interpolation.</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">)],</span>\n    <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">)]</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">phi</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'F(a | b)'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">quantitative</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: True</span>\n\n<span class=\"n\">phi</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'F(a | b)'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: True</span>\n\n<span class=\"c1\"># Note, quantitative parameter defaults to False</span>\n\n<span class=\"c1\"># Evaluate at t=3. </span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">quantitative</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: False</span>\n\n<span class=\"c1\"># Compute sliding satisifaction.</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">quantitative</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: [(0, True), (0.2, True), (4, False)]</span>\n\n<span class=\"c1\"># Evaluate with discrete time</span>\n<span class=\"n\">phi</span> <span class=\"o\">=</span> <span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'X b'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">phi</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"n\">quantitative</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: True</span>\n</pre>\n<h2>Utilities</h2>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">mtl</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mtl</span> <span class=\"kn\">import</span> <span class=\"n\">utils</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">scope</span><span class=\"p\">(</span><span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'XX a'</span><span class=\"p\">),</span> <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: 0.2</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">discretize</span><span class=\"p\">(</span><span class=\"n\">mtl</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'F[0, 0.2] a'</span><span class=\"p\">),</span> <span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">))</span>\n<span class=\"c1\"># output: (a | X a | XX a)</span>\n</pre>\n<h1>Similar Projects</h1>\n<p>Feel free to open up a pull-request to add other similar projects. This library was written to meet some of my unique needs, for example I wanted the AST to be immutable and wanted the library to <strong>just</strong> handle manipulating MTL. Many other similar projects exist with different goals.</p>\n<ol>\n<li><a href=\"https://github.com/doganulus/python-monitors\" rel=\"nofollow\">https://github.com/doganulus/python-monitors</a></li>\n<li><a href=\"https://github.com/STLInspector/STLInspector\" rel=\"nofollow\">https://github.com/STLInspector/STLInspector</a></li>\n</ol>\n<h1>Citing</h1>\n<pre><code>@misc{pyMTL,\n  author       = {Marcell Vazquez-Chanlatte},\n  title        = {mvcisback/py-metric-temporal-logic: v0.1.1},\n  month        = jan,\n  year         = 2019,\n  doi          = {10.5281/zenodo.2548862},\n  url          = {https://doi.org/10.5281/zenodo.2548862}\n}\n</code></pre>\n\n          </div>"}, "last_serial": 6964112, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "a8aa5f98bf0d967385489a24f8b36e45", "sha256": "00734cb19012cae6f66ef3d9d692c513f021867dcef06605c98d698ab4df356b"}, "downloads": -1, "filename": "metric-temporal-logic-0.0.1.tar.gz", "has_sig": false, "md5_digest": "a8aa5f98bf0d967385489a24f8b36e45", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7695, "upload_time": "2018-09-24T08:18:26", "upload_time_iso_8601": "2018-09-24T08:18:26.904035Z", "url": "https://files.pythonhosted.org/packages/33/1f/7b1c8bb68455fc11362f6c17b31a0c003d1d8c28e8f7bca72562611c8acf/metric-temporal-logic-0.0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "bdc5f826e8e90d1a46c240ee3f5831c1", "sha256": "c01025ec643569685640a588583e68fb2dd8302f6470b0f7bc05147c0b099721"}, "downloads": -1, "filename": "metric-temporal-logic-0.1.1.tar.gz", "has_sig": false, "md5_digest": "bdc5f826e8e90d1a46c240ee3f5831c1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8950, "upload_time": "2018-09-25T01:07:17", "upload_time_iso_8601": "2018-09-25T01:07:17.851314Z", "url": "https://files.pythonhosted.org/packages/6f/eb/4a8158cf59246db840c7db35a95e0c2727b60327bf1e1cfa61f007b3290c/metric-temporal-logic-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "508b8ca27f20ed94024348909377ee2d", "sha256": "7e882b006cc7c9175809d9f2fc72600e60f66fbd1fa0e50625cf695d5f2008e5"}, "downloads": -1, "filename": "metric_temporal_logic-0.1.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "508b8ca27f20ed94024348909377ee2d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 11815, "upload_time": "2019-02-12T01:08:52", "upload_time_iso_8601": "2019-02-12T01:08:52.457390Z", "url": "https://files.pythonhosted.org/packages/ff/ff/662be91d8abea5e151ccff1e1e87ef3381b2fe98b17885de1c6eb279d910/metric_temporal_logic-0.1.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8b48d62cd9d196f0f1d4fb1e87d3b191", "sha256": "1fb9b2a3eec7eb58065190b0ab29c102fb09601c420a86bba40572654c57feea"}, "downloads": -1, "filename": "metric-temporal-logic-0.1.2.tar.gz", "has_sig": false, "md5_digest": "8b48d62cd9d196f0f1d4fb1e87d3b191", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9683, "upload_time": "2019-02-12T01:08:28", "upload_time_iso_8601": "2019-02-12T01:08:28.235529Z", "url": "https://files.pythonhosted.org/packages/20/23/7b38c4320558a6ed9f0f79b32b72814b98d05e5f7001f1f91302f9de3b94/metric-temporal-logic-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "a960aad8cea6d921cfead48d167f93e0", "sha256": "8053ac8a1bc68b7e01b85ac5b15f45f5301415e73c6a6b38114d49fa074c0429"}, "downloads": -1, "filename": "metric_temporal_logic-0.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "a960aad8cea6d921cfead48d167f93e0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11850, "upload_time": "2019-09-09T22:24:06", "upload_time_iso_8601": "2019-09-09T22:24:06.991433Z", "url": "https://files.pythonhosted.org/packages/ed/3e/ef96e15e1a0f51012faeb8850fd125a7bc96441652a07a4106d4783daba9/metric_temporal_logic-0.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1e8cbbef24f1184c3219aecd0c653f03", "sha256": "4bacf2036c9a477ca3f2ef9d9ed7a128d66bd1352ed6ac7a15c71703a7e23b17"}, "downloads": -1, "filename": "metric-temporal-logic-0.1.3.tar.gz", "has_sig": false, "md5_digest": "1e8cbbef24f1184c3219aecd0c653f03", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10009, "upload_time": "2019-09-09T22:24:24", "upload_time_iso_8601": "2019-09-09T22:24:24.943704Z", "url": "https://files.pythonhosted.org/packages/fe/1f/b7b01e64bff0052c8305e308b91fd697c59e5fcccd6f6adf908567c2b6a7/metric-temporal-logic-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "9269ec9fafd65d3cbc0cfb6b7bc051ff", "sha256": "b27a5dc737307f2a9f67f9fb1819960178180b2858e301c001b4e232865e5dec"}, "downloads": -1, "filename": "metric_temporal_logic-0.1.4-py3-none-any.whl", "has_sig": false, "md5_digest": "9269ec9fafd65d3cbc0cfb6b7bc051ff", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11850, "upload_time": "2019-10-09T02:19:10", "upload_time_iso_8601": "2019-10-09T02:19:10.798318Z", "url": "https://files.pythonhosted.org/packages/22/11/7ea9fedf6ac86f297f561a5c58d0669c759b848634c09e378d8462c1f5f9/metric_temporal_logic-0.1.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "834a3fb832b5bbce6572650fb8444352", "sha256": "84945bb2017fc00315c2f84a57419db7cd6e3a8bfbdc251a9257cf2ae81978cd"}, "downloads": -1, "filename": "metric-temporal-logic-0.1.4.tar.gz", "has_sig": false, "md5_digest": "834a3fb832b5bbce6572650fb8444352", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10021, "upload_time": "2019-10-09T02:18:55", "upload_time_iso_8601": "2019-10-09T02:18:55.595983Z", "url": "https://files.pythonhosted.org/packages/7a/f9/a5d395fa87d8ef87f1a3c31adb25096fb1a6c17e9e15c68275449a2e22b2/metric-temporal-logic-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "e8cac6d74340381161dcc3dac585b5fe", "sha256": "92347e0adebcccf8f2c1d295be5b8bd9bf2c225ff85d5a047ea1a1a357470ebe"}, "downloads": -1, "filename": "metric_temporal_logic-0.1.5-py3-none-any.whl", "has_sig": false, "md5_digest": "e8cac6d74340381161dcc3dac585b5fe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 14226, "upload_time": "2020-03-02T17:55:25", "upload_time_iso_8601": "2020-03-02T17:55:25.425209Z", "url": "https://files.pythonhosted.org/packages/c9/7d/8d8e852bc0eccd6b002668554abf5abe1c12915c834d6dbf3cd5e92166c0/metric_temporal_logic-0.1.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7689137c6870000eedc124265e8680e0", "sha256": "a253975c546ee22cb7efda21ff1dd7a2ecbe4ea0c87d0a8cee96bce41549850a"}, "downloads": -1, "filename": "metric-temporal-logic-0.1.5.tar.gz", "has_sig": false, "md5_digest": "7689137c6870000eedc124265e8680e0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 14689, "upload_time": "2020-03-02T17:55:24", "upload_time_iso_8601": "2020-03-02T17:55:24.060943Z", "url": "https://files.pythonhosted.org/packages/7f/ea/89350d07c74f086dcd45dba0630025a009a4c7069b99df4abc77fb85e02e/metric-temporal-logic-0.1.5.tar.gz", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "29ddc1425549a46924a534d27780bd03", "sha256": "f797c09fe2a2124f4d9de32c27b2a70c3efe02c78f072066cae5e9343ec5ba92"}, "downloads": -1, "filename": "metric_temporal_logic-0.1.6-py3-none-any.whl", "has_sig": false, "md5_digest": "29ddc1425549a46924a534d27780bd03", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 14329, "upload_time": "2020-04-06T17:58:00", "upload_time_iso_8601": "2020-04-06T17:58:00.029353Z", "url": "https://files.pythonhosted.org/packages/8d/60/a542dd490dc5fc9dda4d8362e360cf9a993c10702ea8bb1e16556f7c13da/metric_temporal_logic-0.1.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d40652a6a917d114cc9813ac2c5520be", "sha256": "fb146ba66b07236878dfd0cce655cc2c201eaef87cc8432347990de8aeaa8010"}, "downloads": -1, "filename": "metric-temporal-logic-0.1.6.tar.gz", "has_sig": false, "md5_digest": "d40652a6a917d114cc9813ac2c5520be", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 14958, "upload_time": "2020-04-06T17:57:58", "upload_time_iso_8601": "2020-04-06T17:57:58.304949Z", "url": "https://files.pythonhosted.org/packages/5d/f7/782b276f6770a36468303495da5c8ed2e851b588402d40dd638b61fb0469/metric-temporal-logic-0.1.6.tar.gz", "yanked": false}], "0.1.7": [{"comment_text": "", "digests": {"md5": "79b912ea608dc33e8109a83b0f344b39", "sha256": "e9da4a14581dd1ed60fbbfb677efc435687f57298a6238bc4e8428b73f077e75"}, "downloads": -1, "filename": "metric_temporal_logic-0.1.7-py3-none-any.whl", "has_sig": false, "md5_digest": "79b912ea608dc33e8109a83b0f344b39", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 14734, "upload_time": "2020-04-06T20:05:22", "upload_time_iso_8601": "2020-04-06T20:05:22.845443Z", "url": "https://files.pythonhosted.org/packages/41/5b/77373a1eab5f4feacd769e4363bd5b26c5da20cc16f5f15d61938594997e/metric_temporal_logic-0.1.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a8c1c19b4489ec733a37eeb92b1bb2c6", "sha256": "ac94c6399f3a2ee7fd8f23545bd4b6ea243126ea5f26a336e79c834976c6fa4f"}, "downloads": -1, "filename": "metric-temporal-logic-0.1.7.tar.gz", "has_sig": false, "md5_digest": "a8c1c19b4489ec733a37eeb92b1bb2c6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 15320, "upload_time": "2020-04-06T20:05:20", "upload_time_iso_8601": "2020-04-06T20:05:20.114724Z", "url": "https://files.pythonhosted.org/packages/1d/f2/77bdd0e0932d9741b42f4896011d3981c8ec0302b9af9b1786a44d91093e/metric-temporal-logic-0.1.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "79b912ea608dc33e8109a83b0f344b39", "sha256": "e9da4a14581dd1ed60fbbfb677efc435687f57298a6238bc4e8428b73f077e75"}, "downloads": -1, "filename": "metric_temporal_logic-0.1.7-py3-none-any.whl", "has_sig": false, "md5_digest": "79b912ea608dc33e8109a83b0f344b39", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 14734, "upload_time": "2020-04-06T20:05:22", "upload_time_iso_8601": "2020-04-06T20:05:22.845443Z", "url": "https://files.pythonhosted.org/packages/41/5b/77373a1eab5f4feacd769e4363bd5b26c5da20cc16f5f15d61938594997e/metric_temporal_logic-0.1.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a8c1c19b4489ec733a37eeb92b1bb2c6", "sha256": "ac94c6399f3a2ee7fd8f23545bd4b6ea243126ea5f26a336e79c834976c6fa4f"}, "downloads": -1, "filename": "metric-temporal-logic-0.1.7.tar.gz", "has_sig": false, "md5_digest": "a8c1c19b4489ec733a37eeb92b1bb2c6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 15320, "upload_time": "2020-04-06T20:05:20", "upload_time_iso_8601": "2020-04-06T20:05:20.114724Z", "url": "https://files.pythonhosted.org/packages/1d/f2/77bdd0e0932d9741b42f4896011d3981c8ec0302b9af9b1786a44d91093e/metric-temporal-logic-0.1.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:38 2020"}