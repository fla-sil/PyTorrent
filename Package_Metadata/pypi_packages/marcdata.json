{"info": {"author": "Sean Redmond", "author_email": "github-smr@sneakemail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python"], "description": "# Marcdata\n\n[![PyPi Version](https://badge.fury.io/py/marcdata.svg)][pypi]\n[![Build Status](http://img.shields.io/travis/seanredmond/py-marc-data.svg)][travis]\n\n[travis]: http://travis-ci.org/seanredmond/py-marc-data\n[pypi]: https://pypi.org/project/marcdata/\n\nLoad binary MARC files into a simple nested tuples (or nested dicts) data structure.\n\n## Installation\n\n    pip install marcdata\n    \n## Usage\n\nPersonally, I often have to parse MARC files just to get one piece of data. Marcdata parses binary MARC files into nested tuples and provides some methods to extract data.\n\nImport the package:\n\n    import marcdata\n    \nRead a file:\n\n    marcdata.from_file(\"data.marc)\n    \n`from_file()` returns an iterator, so you probably want to do something like:\n\n    for record in marcdata.from_file(\"data.marc\"):\n        # Do something with record...\n        \nThe tuple for one record has two elements: the leader, and the fields. The leader consists of the [MARC leader values](https://www.loc.gov/marc/bibliographic/bdleader.html) unpacked into a tuple (excluding the first field, Record length). The fields are a tuple of tuples, one tuple for each field contained in the record.\n\nField tuples have the structure:\n\n    (tag, ind1, ind2, subfield1 [,subfield2...])\n    \nSubfield tuples have the structure:\n\n    (code, value)\n    \nA typical field tuple looks like:\n\n    ('245', '1', '0', \n    ('a', 'Botanical materia medica and pharmacology;'), \n    ('b', 'drugs considered from a botanical, pharmaceutical, physiological, therapeutical and toxicological standpoint.'), \n    ('c', 'By S. H. Aurand.'))\n    \nThat is, the tag is \"245\" (Title Statement), first indicator is \"1\" (Added entry), second indicator \"0\" (No nonfiling characters). There are three subfields, \"a\", \"b\", and \"c\" (Title, Remainder of title, and Statement of responsibility)\n\nFor [control fields](https://www.loc.gov/marc/bibliographic/bd00x.html), each indicator is `None` and the subfield tuple will have only one element with `None` as the code:\n\n    ('003', None, None, (None, 'DLC'))\n    \nYou can find a particular field by tag (and optionally also indicators):\n\t\n    >>> marcdata.find(record, \"245\")\n    >>> marcdata.find(record, \"245\", ind1=\"0\")\n    >>> marcdata.find(record, \"245\", ind2=\"1\")\n    >>> marcdata.find(record, \"245\", ind1=\"0\", ind2=\"0\")\n\n`find()` will return a tuple of matching fields. \n\nTo find subfields matching a field from a field:\n\n    >>> title = marcdata.find(record, \"245\")[0]\n    >>> marc_data.find_subf(title, \"a\")\n    (('a', 'Botanical materia medica and pharmacology;'),)\n    \nLeave out the subfield code to get all subfields:\n\n    marc_data.find_subf(title)\n    \nTo retrieve the value of a control field:\n\n    >>> identifier = marcdata.find(record, \"003\")[0]\n    >>> marcdata.control_value(indentifier)\n    'DLC'\n    \n`repr()` returns a text representation of the record in the traditional format, with empty indicators represented by \"#\" and subfields delimited with \"\\$\":\n\n    >>> print(marcdata.repr(marcdata.marc_tuple(REC1)))\n    001         00000002\n    003      DLC\n    005      20040505165105.0\n    008      800108s1899    ilu           000 0 eng\n    010    ##$a   00000002\n    035    ##$a(OCoLC)5853149\n    040    ##$aDLC$cDSI$dDLC\n    050    00$aRX671$b.A92\n    100    1#$aAurand, Samuel Herbert,$d1854-\n    245    10$aBotanical materia medica and pharmacology;$bdrugs considered from a botanical, pharmaceutical, physiological, therapeutical and toxicological standpoint.$cBy S. H. Aurand.\n    260    ##$aChicago,$bP. H. Mallen Company,$c1899.\n    300    ##$a406 p.$c24 cm.\n    500    ##$aHomeopathic formulae.\n    650    #0$aBotany, Medical.\n    650    #0$aHomeopathy$xMateria medica and therapeutics.\n    \n### Utils\n\nThe `marcdata.utils` package provides some additional convenience methods.\n\n    import marcdata.utils\n    \nGet the material type:\n\n    >>> marcdata.utils.material_type(record)\n    'BK'\n\nThis will return one of: \"BK\" (books), \"CF\" (computer files), \"MP\"\n    (maps), \"MU\" (music), \"CR\" (continuing resource), \"VM\" (visual\n    materials), \"MX\" (mixed materials)\n\nYou can get the [Fixed-Length Data Elements (008)](https://www.loc.gov/marc/bibliographic/bd008.html) unpacked as a tuple\n\n    >>> marcdata.utils.fixed_length_tuple(record)\n    ('800108', 's', '1899', '    ', 'ilu', ('    ', ' ', ' ', '    ', ' ', '0', '0', '0', ' ', '0', ' '), 'eng', ' ', ' ')\n    \nThe sixth element of this tuple is a tuple specific to the material type of the record (positions 18-34 in the value of the 008 field)\n\nThe Fixed-Length Data Elements can also be retrieved as a dict:\n\n    >>> marcdata.utils.fixed_length_dict(record)\n    {'date_entered': '800108', 'type_of_date': 's', 'date1': '1899', \n    'date2': '    ', 'place_of_publication': 'ilu', \n    'illustrations': '    ', 'target_audience': ' ', \n    'form_of_item': ' ', 'nature_of_contents': '    ', \n    'government_publication': ' ', 'conference_publication': '0', \n    'festschrift': '0', 'index': '0', 'undefined': ' ', \n    'literary form': '0', 'biography': ' ', 'language': 'eng', \n    'modified_record': ' ', 'cataloging_source': ' '}\n\nNote that rhe material-type-specific fields are simply part of the dict, so the dicts for different material types will have different keys.\n\nFinally, you can retrieve the record as a dict:\n\n    >>> marcdata.utils.marc_dict(record)\n    \nIn the dict version, the keys are \"leader\" and the field tags present in the record\n\n    >>> marcdata.utils.marc_dict(record).keys()\n    dict_keys(['leader', '001', '003', '005', '008', '010', '035', '040', '050', '100', '245', '260', '300', '500', '650'])\n\nThe leader and Fixed-Length Data Elements are themselves unpacked into dicts.\n\nFor fields, the values from each pair is a tuple of dicts, with the multiple values of repeated fields grouped. In control fields the tuple will have a single member with the structure:\n\n    '003': ({'type': 'control', 'value': 'DLC'},)\n    \nFor variable fields the structure will be:\n    \n    '650': (\n      {'type': 'variable', 'ind1': ' ', 'ind2': '0', 'subfields': {'a': 'Botany, Medical.'}}, \n      {'type': 'variable', 'ind1': ' ', 'ind2': '0', 'subfields': {'a': 'Homeopathy', 'x': 'Materia medica and therapeutics.'}}\n    )  \n    \n## Contributing\n\nBug reports and pull requests are welcome on GitHub at https://github.com/seanredmond/py-marc-data.\n\n## License\n\nThe package is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT).", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/seanredmond/py-marc-data", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "marcdata", "package_url": "https://pypi.org/project/marcdata/", "platform": "", "project_url": "https://pypi.org/project/marcdata/", "project_urls": {"Homepage": "https://github.com/seanredmond/py-marc-data"}, "release_url": "https://pypi.org/project/marcdata/1.1.0/", "requires_dist": null, "requires_python": ">=3.5.0", "summary": "Parse MARC files into simple data structures", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Marcdata</h1>\n<p><a href=\"https://pypi.org/project/marcdata/\" rel=\"nofollow\"><img alt=\"PyPi Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/92b9bce645409283b5c70e8e07176f666d8747a8/68747470733a2f2f62616467652e667572792e696f2f70792f6d617263646174612e737667\"></a>\n<a href=\"http://travis-ci.org/seanredmond/py-marc-data\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6e6987b0a68eee1b83f0e01bfc175a5fad4c8764/687474703a2f2f696d672e736869656c64732e696f2f7472617669732f7365616e7265646d6f6e642f70792d6d6172632d646174612e737667\"></a></p>\n<p>Load binary MARC files into a simple nested tuples (or nested dicts) data structure.</p>\n<h2>Installation</h2>\n<pre><code>pip install marcdata\n</code></pre>\n<h2>Usage</h2>\n<p>Personally, I often have to parse MARC files just to get one piece of data. Marcdata parses binary MARC files into nested tuples and provides some methods to extract data.</p>\n<p>Import the package:</p>\n<pre><code>import marcdata\n</code></pre>\n<p>Read a file:</p>\n<pre><code>marcdata.from_file(\"data.marc)\n</code></pre>\n<p><code>from_file()</code> returns an iterator, so you probably want to do something like:</p>\n<pre><code>for record in marcdata.from_file(\"data.marc\"):\n    # Do something with record...\n</code></pre>\n<p>The tuple for one record has two elements: the leader, and the fields. The leader consists of the <a href=\"https://www.loc.gov/marc/bibliographic/bdleader.html\" rel=\"nofollow\">MARC leader values</a> unpacked into a tuple (excluding the first field, Record length). The fields are a tuple of tuples, one tuple for each field contained in the record.</p>\n<p>Field tuples have the structure:</p>\n<pre><code>(tag, ind1, ind2, subfield1 [,subfield2...])\n</code></pre>\n<p>Subfield tuples have the structure:</p>\n<pre><code>(code, value)\n</code></pre>\n<p>A typical field tuple looks like:</p>\n<pre><code>('245', '1', '0', \n('a', 'Botanical materia medica and pharmacology;'), \n('b', 'drugs considered from a botanical, pharmaceutical, physiological, therapeutical and toxicological standpoint.'), \n('c', 'By S. H. Aurand.'))\n</code></pre>\n<p>That is, the tag is \"245\" (Title Statement), first indicator is \"1\" (Added entry), second indicator \"0\" (No nonfiling characters). There are three subfields, \"a\", \"b\", and \"c\" (Title, Remainder of title, and Statement of responsibility)</p>\n<p>For <a href=\"https://www.loc.gov/marc/bibliographic/bd00x.html\" rel=\"nofollow\">control fields</a>, each indicator is <code>None</code> and the subfield tuple will have only one element with <code>None</code> as the code:</p>\n<pre><code>('003', None, None, (None, 'DLC'))\n</code></pre>\n<p>You can find a particular field by tag (and optionally also indicators):</p>\n<pre><code>&gt;&gt;&gt; marcdata.find(record, \"245\")\n&gt;&gt;&gt; marcdata.find(record, \"245\", ind1=\"0\")\n&gt;&gt;&gt; marcdata.find(record, \"245\", ind2=\"1\")\n&gt;&gt;&gt; marcdata.find(record, \"245\", ind1=\"0\", ind2=\"0\")\n</code></pre>\n<p><code>find()</code> will return a tuple of matching fields.</p>\n<p>To find subfields matching a field from a field:</p>\n<pre><code>&gt;&gt;&gt; title = marcdata.find(record, \"245\")[0]\n&gt;&gt;&gt; marc_data.find_subf(title, \"a\")\n(('a', 'Botanical materia medica and pharmacology;'),)\n</code></pre>\n<p>Leave out the subfield code to get all subfields:</p>\n<pre><code>marc_data.find_subf(title)\n</code></pre>\n<p>To retrieve the value of a control field:</p>\n<pre><code>&gt;&gt;&gt; identifier = marcdata.find(record, \"003\")[0]\n&gt;&gt;&gt; marcdata.control_value(indentifier)\n'DLC'\n</code></pre>\n<p><code>repr()</code> returns a text representation of the record in the traditional format, with empty indicators represented by \"#\" and subfields delimited with \"$\":</p>\n<pre><code>&gt;&gt;&gt; print(marcdata.repr(marcdata.marc_tuple(REC1)))\n001         00000002\n003      DLC\n005      20040505165105.0\n008      800108s1899    ilu           000 0 eng\n010    ##$a   00000002\n035    ##$a(OCoLC)5853149\n040    ##$aDLC$cDSI$dDLC\n050    00$aRX671$b.A92\n100    1#$aAurand, Samuel Herbert,$d1854-\n245    10$aBotanical materia medica and pharmacology;$bdrugs considered from a botanical, pharmaceutical, physiological, therapeutical and toxicological standpoint.$cBy S. H. Aurand.\n260    ##$aChicago,$bP. H. Mallen Company,$c1899.\n300    ##$a406 p.$c24 cm.\n500    ##$aHomeopathic formulae.\n650    #0$aBotany, Medical.\n650    #0$aHomeopathy$xMateria medica and therapeutics.\n</code></pre>\n<h3>Utils</h3>\n<p>The <code>marcdata.utils</code> package provides some additional convenience methods.</p>\n<pre><code>import marcdata.utils\n</code></pre>\n<p>Get the material type:</p>\n<pre><code>&gt;&gt;&gt; marcdata.utils.material_type(record)\n'BK'\n</code></pre>\n<p>This will return one of: \"BK\" (books), \"CF\" (computer files), \"MP\"\n(maps), \"MU\" (music), \"CR\" (continuing resource), \"VM\" (visual\nmaterials), \"MX\" (mixed materials)</p>\n<p>You can get the <a href=\"https://www.loc.gov/marc/bibliographic/bd008.html\" rel=\"nofollow\">Fixed-Length Data Elements (008)</a> unpacked as a tuple</p>\n<pre><code>&gt;&gt;&gt; marcdata.utils.fixed_length_tuple(record)\n('800108', 's', '1899', '    ', 'ilu', ('    ', ' ', ' ', '    ', ' ', '0', '0', '0', ' ', '0', ' '), 'eng', ' ', ' ')\n</code></pre>\n<p>The sixth element of this tuple is a tuple specific to the material type of the record (positions 18-34 in the value of the 008 field)</p>\n<p>The Fixed-Length Data Elements can also be retrieved as a dict:</p>\n<pre><code>&gt;&gt;&gt; marcdata.utils.fixed_length_dict(record)\n{'date_entered': '800108', 'type_of_date': 's', 'date1': '1899', \n'date2': '    ', 'place_of_publication': 'ilu', \n'illustrations': '    ', 'target_audience': ' ', \n'form_of_item': ' ', 'nature_of_contents': '    ', \n'government_publication': ' ', 'conference_publication': '0', \n'festschrift': '0', 'index': '0', 'undefined': ' ', \n'literary form': '0', 'biography': ' ', 'language': 'eng', \n'modified_record': ' ', 'cataloging_source': ' '}\n</code></pre>\n<p>Note that rhe material-type-specific fields are simply part of the dict, so the dicts for different material types will have different keys.</p>\n<p>Finally, you can retrieve the record as a dict:</p>\n<pre><code>&gt;&gt;&gt; marcdata.utils.marc_dict(record)\n</code></pre>\n<p>In the dict version, the keys are \"leader\" and the field tags present in the record</p>\n<pre><code>&gt;&gt;&gt; marcdata.utils.marc_dict(record).keys()\ndict_keys(['leader', '001', '003', '005', '008', '010', '035', '040', '050', '100', '245', '260', '300', '500', '650'])\n</code></pre>\n<p>The leader and Fixed-Length Data Elements are themselves unpacked into dicts.</p>\n<p>For fields, the values from each pair is a tuple of dicts, with the multiple values of repeated fields grouped. In control fields the tuple will have a single member with the structure:</p>\n<pre><code>'003': ({'type': 'control', 'value': 'DLC'},)\n</code></pre>\n<p>For variable fields the structure will be:</p>\n<pre><code>'650': (\n  {'type': 'variable', 'ind1': ' ', 'ind2': '0', 'subfields': {'a': 'Botany, Medical.'}}, \n  {'type': 'variable', 'ind1': ' ', 'ind2': '0', 'subfields': {'a': 'Homeopathy', 'x': 'Materia medica and therapeutics.'}}\n)  \n</code></pre>\n<h2>Contributing</h2>\n<p>Bug reports and pull requests are welcome on GitHub at <a href=\"https://github.com/seanredmond/py-marc-data\" rel=\"nofollow\">https://github.com/seanredmond/py-marc-data</a>.</p>\n<h2>License</h2>\n<p>The package is available as open source under the terms of the <a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\">MIT License</a>.</p>\n\n          </div>"}, "last_serial": 6306839, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "f9e492d7821be3251d7d9f9e91ba9e3d", "sha256": "8c791c12bdb0e78ed14978c319ab4209b7ab517aada3cc34a639e71ad61cbc2d"}, "downloads": -1, "filename": "marcdata-1.0.0.tar.gz", "has_sig": false, "md5_digest": "f9e492d7821be3251d7d9f9e91ba9e3d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5.0", "size": 10502, "upload_time": "2019-12-15T04:54:06", "upload_time_iso_8601": "2019-12-15T04:54:06.641950Z", "url": "https://files.pythonhosted.org/packages/fc/ae/3b81f9ec938f21d0cd30ef4668971b4a9faffd4ef356ea3ea0595c23ab93/marcdata-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "528d5214bec2b961f94251821c3645c0", "sha256": "75312d40ab3d9281026d58e9479ab4d16425dda9a6e004fd51bd42ce733f9d65"}, "downloads": -1, "filename": "marcdata-1.1.0.tar.gz", "has_sig": false, "md5_digest": "528d5214bec2b961f94251821c3645c0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5.0", "size": 10600, "upload_time": "2019-12-15T15:20:17", "upload_time_iso_8601": "2019-12-15T15:20:17.678220Z", "url": "https://files.pythonhosted.org/packages/91/38/66f133ff693c7c7566a057d5481f659c632d6ef6f4e8b9849857f1483b52/marcdata-1.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "528d5214bec2b961f94251821c3645c0", "sha256": "75312d40ab3d9281026d58e9479ab4d16425dda9a6e004fd51bd42ce733f9d65"}, "downloads": -1, "filename": "marcdata-1.1.0.tar.gz", "has_sig": false, "md5_digest": "528d5214bec2b961f94251821c3645c0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5.0", "size": 10600, "upload_time": "2019-12-15T15:20:17", "upload_time_iso_8601": "2019-12-15T15:20:17.678220Z", "url": "https://files.pythonhosted.org/packages/91/38/66f133ff693c7c7566a057d5481f659c632d6ef6f4e8b9849857f1483b52/marcdata-1.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:57:50 2020"}