{"info": {"author": "Plone Foundation", "author_email": "plone-developers@lists.sourceforge.net", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Plone", "Framework :: Plone :: 5.2", "Framework :: Plone :: Core", "Framework :: Zope :: 4", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3.9", "Programming Language :: Python :: Implementation :: CPython", "Topic :: Internet :: WWW/HTTP :: Dynamic Content", "Topic :: Software Development :: Testing"], "description": "Introduction\n============\n\n.. contents:: Table of contents\n\n``plone.testing`` provides tools for writing unit and integration tests in a Zope and Plone environment.\nIt is not tied to Plone, and it does not depend on Zope (although it has some optional Zope-only features).\n\n``plone.testing`` builds on `zope.testing`_, in particular its layers concept.\nThis package also aims to promote some \"good practice\" for writing tests of various types.\n\n.. note::\n\n   If you are working with Plone, there is a complementary package `plone.app.testing`_, which builds on ``plone.testing`` to provide additional layers useful for testing Plone add-ons.\n\nIf you are new to automated testing and test driven development, you should spend some time learning about those concepts.\nSome useful references include:\n\n* `The Wikipedia article on unit testing <https://en.wikipedia.org/wiki/Unit_testing>`_\n* `The Dive Into Python chapter on testing <https://diveintopython3.problemsolving.io/unit-testing.html>`_\n\nBear in mind that different Python frameworks have slightly different takes on how to approach testing.\nTherefore, you may find examples that are different to those shown below.\nThe core concepts should be consistent, however.\n\nCompatibility\n-------------\n\n``plone.testing`` 7.x has been tested with Python 2.7 and 3.6.\nIf you're using the optional Zope layers, you must use Zope version 4 or later.\nLook at older ``plone.testing`` versions for supporting older Zope versions.\n\nDefinitions\n-----------\n\nIn this documentation, we will use a number of testing-related terms.\nThe following definitions apply:\n\nUnit test\n    An automated test (i.e. one written in code) that tests a single unit (normally a function) in isolation.\n    A unit test attempts to prove that the given function works as expected and gives the correct output given a particular input.\n    It is common to have a number of unit tests for a single function, testing different inputs, including boundary cases and errors.\n    Unit tests are typically quick to write and run.\n\nIntegration test\n    An automated test that tests how a number of units interact.\n    In a Zope context, this often pertains to how a particular object or view interacts with the Zope framework, the ZODB persistence engine, and so on.\n    Integration tests usually require some setup and can be slower to run than unit tests.\n    It is common to have fewer integration tests than unit test.\n\nFunctional test\n    An automated test that tests a feature in an \"end-to-end\" fashion.\n    In a Zope context, that normally means that it invokes an action in the same way that a user would, i.e. through a web request.\n    Functional tests are normally slower to run than either unit or integration tests, and can be significantly slower to run.\n    It is therefore common to have only a few functional tests for each major feature, relying on unit and integration tests for the bulk of testing.\n\nBlack box testing\n    Testing which only considers the system's defined inputs and outputs.\n    For example, a functional test is normally a black box test that provides inputs only through the defined interface (e.g. URLs published in a web application), and makes assertions only on end outputs (e.g. the response returned for requests to those URLs).\n\nWhite box testing\n    Testing which examines the internal state of a system to make assertions.\n    Authors of unit and integration tests normally have significant knowledge of the implementation of the code under test, and can examine such things as data in a database or changes to the system's environment to determine if the test succeeded or failed.\n\nAssertion\n    A check that determines whether a test succeeds or fails.\n    For example, if a unit test for the function ``foo()`` expects it to return the value 1, an assertion could be written to verify this fact.\n    A test is said to *fail* if any of its assertions fail.\n    A test always contains one or more assertions.\n\nTest case\n    A single unit, integration or functional test.\n    Often shortened to just *test*.\n    A test case sets up, executes and makes assertions against a single scenario that bears testing.\n\nTest fixture\n    The state used as a baseline for one or more tests.\n    The test fixture is *set up* before each test is executed, and *torn down* afterwards.\n    This is a pre-requisite for *test isolation* - the principle that tests should be independent of one another.\n\nLayer\n    The configuration of a test fixture shared by a number of tests.\n    All test cases that belong to a particular layer will be executed together.\n    The layer is *set up* once before the tests are executed, and *torn down* once after.\n    Layers may depend on one another.\n    Any *base layers* are set up before and torn down after a particular *child layer* is used.\n    The test runner will order test execution to minimise layer setup and tear-down.\n\nTest suite\n    A collection of test cases (and layers) that are executed together.\n\nTest runner\n    The program which executes tests.\n    This is responsible for calling layer and test fixture set-up and tear-down methods.\n    It also reports on the test run, usually by printing output to the console.\n\nCoverage\n    To have confidence in your code, you should ensure it is adequately covered by tests.\n    That is, each line of code, and each possible branching point (loops, ``if`` statements) should be executed by a test.\n    This is known as *coverage*, and is normally measured as a percentage of lines of non-test code covered by tests.\n    Coverage can be measured by the test runner, which keeps track of which lines of code were executed in a given test run.\n\nDoctest\n    A style of testing where tests are written as examples that could be typed into the interactive Python interpreter.\n    The test runner executes each example and checks the actual output against the expected output.\n    Doctests can either be placed in the docstring of a method, or in a separate file.\n    The use of doctests is largely a personal preference.\n    Some developers like to write documentation as doctests, which has the advantage that code samples can be automatically tested for correctness.\n    You can read more about doctests on `Wikipedia <http://en.wikipedia.org/wiki/Doctest>`_.\n\nInstallation and usage\n======================\n\nTo use ``plone.testing`` in your own package, you need to add it as a dependency.\nMost people prefer to keep test-only dependencies separate, so that they do not need to be installed in scenarios (such as on a production server) where the tests will not be run.\nThis can be achieved using a ``test`` extra.\n\nIn ``setup.py``, add or modify the ``extras_require`` option, like so:::\n\n    extras_require = {\n        'test': [\n                'plone.testing',\n            ]\n    },\n\nYou can add other test-only dependencies to that list as well, of course.\n\nTo run tests, you need a test runner.\nIf you are using ``zc.buildout``, you can install a test runner using the `zc.recipe.testrunner`_ recipe.\nFor example, you could add the following to your ``buildout.cfg``:::\n\n    [test]\n    recipe = zc.recipe.testrunner\n    eggs =\n        my.package [test]\n    defaults = ['--auto-color', '--auto-progress']\n\nYou'll also need to add this part to the ``parts`` list, of course:::\n\n    [buildout]\n    parts =\n        ...\n        test\n\nIn this example, have listed a single package to test, called ``my.package``, and asked for it to be installed with the ``[test]`` extra.\nThis will install any regular dependencies (listed in the ``install_requires`` option in ``setup.py``), as well as those in the list associated with the ``test`` key in the ``extras_require`` option.\n\nNote that it becomes important to properly list your dependencies here, because the test runner will only be aware of the packages explicitly listed, and their dependencies.\nFor example, if your package depends on Zope, you need to list ``Zope`` in the ``install_requires`` list in ``setup.py``;\nditto for ``Plone``, or indeed any other package you import from.\n\nOnce you have re-run buildout, the test runner will be installed as ``bin/test`` (the executable name is taken from the name of the buildout part).\nYou can execute it without arguments to run all tests of each egg listed in the ``eggs`` list::\n\n    $ bin/test\n\nIf you have listed several eggs, and you want to run the tests for a particular one, you can do::\n\n    $ bin/test -s my.package\n\nIf you want to run only a particular test within this package, use the ``-t`` option.\nThis can be passed a regular expression matching either a doctest file name or a test method name.::\n\n    $ bin/test -s my.package -t test_spaceship\n\nThere are other command line options, which you can find by running::\n\n    $ bin/test --help\n\nAlso note the ``defaults`` option in the buildout configuration.\nThis can be used to set default command line options.\nSome commonly useful options are shown above.\n\nCoverage reporting\n------------------\n\nWhen writing tests, it is useful to know how well your tests cover your code.\nYou can create coverage reports via the excellent `coverage`_ library.\nIn order to use it, we need to install it and a reporting script::\n\n    [buildout]\n    parts =\n        ...\n        test\n        coverage\n        report\n\n    [coverage]\n    recipe = zc.recipe.egg\n    eggs = coverage\n    initialization =\n        include = '--source=${buildout:directory}/src'\n        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all']\n\n    [report]\n    recipe = zc.recipe.egg\n    eggs = coverage\n    scripts = coverage=report\n    initialization =\n        sys.argv = sys.argv[:] + ['html', '-i']\n\nThis will run the ``bin/test`` script with arguments like `--all` to run all layers.\nYou can also specify no or some other arguments.\nIt will place coverage reporting information in a ``.coverage`` file inside your buildout root.\nVia the ``--source`` argument you specify the directories containing code you want to cover.\nThe coverage script would otherwise generate coverage information for all executed code, including other packages and even the standard library.\n\nRunning the ``bin/report`` script will generate a human readable HTML representation of the run in the `htmlcov` directory.\nOpen the contained `index.html` in a browser to see the result.\n\nIf you want to generate an XML representation suitable for the `Cobertura`_ plugin of `Jenkins`_, you can add another part::\n\n    [buildout]\n    parts =\n        ...\n        report-xml\n\n    [report-xml]\n    recipe = zc.recipe.egg\n    eggs = coverage\n    scripts = coverage=report-xml\n    initialization =\n        sys.argv = sys.argv[:] + ['xml', '-i']\n\nThis will generate a ``coverage.xml`` file in the buildout root.\n\nOptional dependencies\n---------------------\n\n``plone.testing`` comes with a core set of tools for managing layers, which depends only on `zope.testing`_.\nIn addition, there are several layers and helper functions which can be used in your own tests (or as bases for your own layers).\nSome of these have deeper dependencies.\nHowever, these dependencies are optional and not installed by default.\nIf you don't use the relevant layers, you can safely ignore them.\n\n``plone.testing`` does specify these dependencies, however, using the ``setuptools`` \"extras\" feature.\nYou can depend on one or more extras in your own ``setup.py`` ``install_requires`` or ``extras_require`` option using the same square bracket notation shown for the ``[test]`` buildout part above.\nFor example, if you need both the ``zca`` and ``publisher`` extras, you can have the following in your ``setup.py``::\n\n    extras_require = {\n        'test': [\n                'plone.testing [zca, publisher]',\n            ]\n    },\n\nThe available extras are:\n\n``zodb``\n    ZODB testing.\n    Depends on ``ZODB``.\n    The relevant layers and helpers are in the module ``plone.testing.zodb``.\n\n``zca``\n    Zope Component Architecture testing.\n    Depends on core Zope Component Architecture packages such as ``zope.component`` and ``zope.event``.\n    The relevant layers and helpers are in the module ``plone.testing.zca``.\n\n``security``\n    Security testing.\n    Depends on ``zope.security``.\n    The relevant layers and helpers are in the module ``plone.testing.security``.\n\n``publisher``\n    Zope Publisher testing.\n    Depends on ``zope.publisher``, ``zope.browsermenu``, ``zope.browserpage``, ``zope.browserresource`` and ``zope.security`` and sets up ZCML directives.\n    The relevant layers and helpers are in the module ``plone.testing.publisher``.\n\n``zope`` (For backwards compatibility there is also ``z2``.)\n\n    Zope testing.\n    Depends on the ``Zope`` egg, which includes all the dependencies of the Zope application server.\n    The relevant layers and helpers are in the module ``plone.testing.zope``.\n\n``zserver``\n\n    Tests against the ``ZServer``. (Python 2 only!) Requires additionally to use the ``zope`` extra.\n    The relevant layers and helpers are in the module ``plone.testing.zserver``\n\n\nAdding a test buildout to your package\n--------------------------------------\n\nWhen creating re-usable, mostly stand-alone packages, it is often useful to be able to include a buildout with the package sources itself that can be used to create a test runner.\nThis is a popular approach for many Zope packages, for example.\nIn fact, ``plone.testing`` itself uses this kind of layout.\n\nTo have a self-contained buildout in your package, the following is required:\n\n* You need a ``buildout.cfg`` at the root of the package.\n\n* In most cases, you always want a ``bootstrap.py`` file to make it easier for people to set up a fresh buildout.\n\n* Your package sources need to be inside a ``src`` directory.\n  If you're using namespace packages, that means the top level package should be in the ``src`` directory.\n\n* The ``src`` directory must be referenced in ``setup.py``.\n\nFor example, ``plone.testing`` has the following layout::\n\n    plone.testing/\n    plone.testing/setup.py\n    plone.testing/bootstrap.py\n    plone.testing/buildout.cfg\n    plone.testing/README.rst\n    plone.testing/src/\n    plone.testing/src/plone\n    plone.testing/src/plone/__init__.py\n    plone.testing/src/plone/testing/\n    plone.testing/src/plone/testing/*\n\nIn ``setup.py``, the following arguments are required::\n\n        packages=find_packages('src'),\n        package_dir={'': 'src'},\n\nThis tells ``setuptools`` where to find the source code.\n\nThe ``buildout.cfg`` for ``plone.testing`` looks like this::\n\n    [buildout]\n    extends =\n        http://download.zope.org/Zope2/index/2.12.12/versions.cfg\n    parts = coverage test report report-xml\n    develop = .\n\n    [test]\n    recipe = collective.xmltestreport\n    eggs =\n        plone.testing [test]\n    defaults = ['--auto-color', '--auto-progress']\n\n    [coverage]\n    recipe = zc.recipe.egg\n    eggs = coverage\n    initialization =\n        include = '--source=${buildout:directory}/src'\n        sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all', '--xml']\n\n    [report]\n    recipe = zc.recipe.egg\n    eggs = coverage\n    scripts = coverage=report\n    initialization =\n        sys.argv = sys.argv[:] + ['html', '-i']\n\n    [report-xml]\n    recipe = zc.recipe.egg\n    eggs = coverage\n    scripts = coverage=report-xml\n    initialization =\n        sys.argv = sys.argv[:] + ['xml', '-i']\n\nObviously, you should adjust the package name in the ``eggs`` list and the version set in the ``extends`` line as appropriate.\n\nYou can of course also add additional buildout parts, for example to include some development/debugging tools, or even a running application server for testing purposes.\n\n    *Hint:* If you use this package layout, you should avoid checking any files or directories generated by buildout into your version control repository.\n    You want to ignore:\n\n    * ``.coverage``\n    * ``.installed.cfg``\n    * ``bin``\n    * ``coverage.xml``\n    * ``develop-eggs``\n    * ``htmlcov``\n    * ``parts``\n    * ``src/*.egg-info``\n\nLayers\n======\n\nIn large part, ``plone.testing`` is about layers.\nIt provides:\n\n* A set of layers (outlined below), which you can use or extend.\n\n* A set of tools for working with layers\n\n* A mini-framework to make it easy to write layers and manage shared resources associated with layers.\n\nWe'll discuss the last two items here, before showing how to write tests that use layers.\n\nLayer basics\n------------\n\nLayers are used to create test fixtures that are shared by multiple test cases.\nFor example, if you are writing a set of integration tests, you may need to set up a database and configure various components to access that database.\nThis type of test fixture setup can be resource-intensive and time-consuming.\nIf it is possible to only perform the setup and tear-down once for a set of tests without losing isolation between those tests, test runs can often be sped up significantly.\n\nLayers also allow re-use of test fixtures and set-up/tear-down code.\n``plone.testing`` provides a number of useful (but optional) layers that manage test fixtures for common Zope testing scenarios, letting you focus on the actual test authoring.\n\nAt the most basic, a layer is an object with the following methods and attributes:\n\n``setUp()``\n    Called by the test runner when the layer is to be set up.\n    This is called exactly once for each layer used during a test run.\n\n``tearDown()``\n    Called by the test runner when the layer is to be torn down.\n    As with ``setUp()``, this is called exactly once for each layer.\n\n``testSetUp()``\n    Called immediately before each test case that uses the layer is executed.\n    This is useful for setting up aspects of the fixture that are managed on a per-test basis, as opposed to fixture shared among all tests.\n\n``testTearDown()``\n    Called immediately after each test case that uses the layer is executed.\n    This is a chance to perform any post-test cleanup to ensure the fixture is ready for the next test.\n\n``__bases__``\n    A tuple of base layers.\n\nEach test case is associated with zero or one layer.\n(The syntax for specifying the layer is shown in the section \"Writing tests\" below.) All the tests associated with a given layer will be executed together.\n\nLayers can depend on one another (as indicated in the ``__bases__`` tuple), allowing one layer to build on the fixture created by another.\nBase layers are set up before and torn down after their dependants.\n\nFor example, if the test runner is executing some tests that belong to layer A, and some other tests that belong to layer B, both of which depend on layer C, the order of execution might be::\n\n    1. C.setUp()\n    1.1. A.setUp()\n\n    1.1.1. C.testSetUp()\n    1.1.2. A.testSetUp()\n    1.1.3. [One test using layer A]\n    1.1.4. A.testTearDown()\n    1.1.5. C.testTearDown()\n\n    1.1.6. C.testSetUp()\n    1.1.7. A.testSetUp()\n    1.1.8. [Another test using layer A]\n    1.1.9. A.testTearDown()\n    1.1.10. C.testTearDown()\n\n    1.2. A.tearDown()\n    1.3. B.setUp()\n\n    1.3.1. C.testSetUp()\n    1.3.2. B.testSetUp()\n    1.3.3. [One test using layer B]\n    1.3.4. B.testTearDown()\n    1.3.5. C.testTearDown()\n\n    1.3.6. C.testSetUp()\n    1.3.7. B.testSetUp()\n    1.3.8. [Another test using layer B]\n    1.3.9. B.testTearDown()\n    1.3.10. C.testTearDown()\n\n    1.4. B.tearDown()\n    2. C.tearDown()\n\nA base layer may of course depend on other base layers.\nIn the case of nested dependencies like this, the order of set up and tear-down as calculated by the test runner is similar to the way in which Python searches for the method to invoke in the case of multiple inheritance.\n\nWriting layers\n--------------\n\nThe easiest way to create a new layer is to use the ``Layer`` base class and implement the ``setUp()``, ``tearDown()``, ``testSetUp()`` and ``testTearDown()`` methods as needed.\nAll four are optional.\nThe default implementation of each does nothing.\n\nBy convention, layers are created in a module called ``testing.py`` at the top level of your package.\nThe idea is that other packages that extend your package can re-use your layers for their own testing.\n\nA simple layer may look like this::\n\n    >>> from plone.testing import Layer\n    >>> class SpaceShip(Layer):\n    ...\n    ...     def setUp(self):\n    ...         print(\"Assembling space ship\")\n    ...\n    ...     def tearDown(self):\n    ...         print(\"Disasembling space ship\")\n    ...\n    ...     def testSetUp(self):\n    ...         print(\"Fuelling space ship in preparation for test\")\n    ...\n    ...     def testTearDown(self):\n    ...         print(\"Emptying the fuel tank\")\n\nBefore this layer can be used, it must be instantiated.\nLayers are normally instantiated exactly once, since by nature they are shared between tests.\nThis becomes important when you start to manage resources (such as persistent data, database connections, or other shared resources) in layers.\n\nThe layer instance is conventionally also found in ``testing.py``, just after the layer class definition.::\n\n    >>> SPACE_SHIP = SpaceShip()\n\n.. note::\n\n    Since the layer is instantiated in module scope, it will be created as soon as the ``testing`` module is imported.\n    It is therefore very important that the layer class is inexpensive and safe to create.\n    In general, you should avoid doing anything non-trivial in the ``__init__()`` method of your layer class.\n    All setup should happen in the ``setUp()`` method.\n    If you *do* implement ``__init__()``, be sure to call the ``super`` version as well.\n\nThe layer shown above did not have any base layers (dependencies).\nHere is an example of another layer that depends on it:::\n\n    >>> class ZIGSpaceShip(Layer):\n    ...     defaultBases = (SPACE_SHIP,)\n    ...\n    ...     def setUp(self):\n    ...         print(\"Installing main canon\")\n\n    >>> ZIG = ZIGSpaceShip()\n\nHere, we have explicitly listed the base layers on which ``ZIGSpaceShip`` depends, in the ``defaultBases`` attribute.\nThis is used by the ``Layer`` base class to set the layer bases in a way that can also be overridden: see below.\n\nNote that we use the layer *instance* in the ``defaultBases`` tuple, not the class.\nLayer dependencies always pertain to specific layer instances.\nAbove, we are really saying that *instances* of ``ZIGSpaceShip`` will, by default, require the ``SPACE_SHIP`` layer to be set up first.\n\n.. note::\n\n    You may find it useful to create other layer base/mix-in classes that extend ``plone.testing.Layer`` and provide helper methods for use in your own layers.\n    This is perfectly acceptable, but please do not confuse a layer base class used in this manner with the concept of a *base layer* as described above:\n\n    * A class deriving from ``plone.testing.Layer`` is known as a *layer class*.\n      It defines the behaviour of the layer by implementing the lifecycle methods ``setUp()``, ``tearDown()``, ``testSetUp()`` and/or ``testTearDown()``.\n\n    * A layer class can be instantiated into an actual layer.\n      When a layer is associated with a test, it is the layer *instance* that is used.\n\n    * The instance is usually a shared, module-global object, although in some cases it is useful to create copies of layers by instantiating the class more than once.\n\n    * Subclassing an existing layer class is just straightforward OOP re-use: the test runner is not aware of the subclassing relationship.\n\n    * A layer *instance* can be associated with any number of layer *bases*, via its ``__bases__`` property (which is usually via the ``defaultBases`` variable in the class body and/or overridden using the ``bases`` argument to the ``Layer`` constructor).\n      These bases are layer *instances*, not classes.\n      The test runner will inspect the ``__bases__`` attribute of each layer instance it sets up to calculate layer pre-requisites and dependencies.\n\n    Also note that the `zope.testing`_ documentation contains examples of layers that are \"old-style\" classes where the ``setUp()`` and ``tearDown()`` methods are ``classmethod`` methods and class inheritance syntax is used to specify base layers.\n    Whilst this pattern works, we discourage its use, because the classes created using this pattern are not really used as classes.\n    The concept of layer bases is slightly different from class inheritance, and using the ``class`` keyword to create layers with base layers leads to a number of \"gotchas\" that are best avoided.\n\nAdvanced - overriding bases\n---------------------------\n\nIn some cases, it may be useful to create a copy of a layer, but change its bases.\nOne reason to do this may if you are re-using a layer from another module, and you need to change the order in which layers are set up and torn down.\n\nNormally, of course, you would just re-use the layer instance, either directly in a test, or in the ``defaultBases`` tuple of another layer, but if you need to change the bases, you can pass a new list of bases to the layer instance constructor:::\n\n    >>> class CATSMessage(Layer):\n    ...\n    ...     def setUp(self):\n    ...         print(\"All your base are belong to us\")\n    ...\n    ...     def tearDown(self):\n    ...         print(\"For great justice\")\n\n    >>> CATS_MESSAGE = CATSMessage()\n\n    >>> ZERO_WING = ZIGSpaceShip(bases=(SPACE_SHIP, CATS_MESSAGE,), name=\"ZIGSpaceShip:CATSMessage\")\n\nPlease note that when overriding bases like this, the ``name`` argument is required.\nThis is because each layer (using in a given test run) must have a unique name.\nThe default is to use the layer class name, but this obviously only works for one instantiation.\nTherefore, ``plone.testing`` requires a name when setting ``bases`` explicitly.\n\nPlease take great care when changing layer bases like this.\nThe layer implementation may make assumptions about the test fixture that was set up by its bases.\nIf you change the order in which the bases are listed, or remove a base altogether, the layer may fail to set up correctly.\n\nAlso, bear in mind that the new layer instance is independent of the original layer instance, so any resources defined in the layer are likely to be duplicated.\n\nLayer combinations\n------------------\n\nSometimes, it is useful to be able to combine several layers into one, without adding any new fixture.\nOne way to do this is to use the ``Layer`` class directly and instantiate it with new bases:::\n\n    >>> COMBI_LAYER = Layer(bases=(CATS_MESSAGE, SPACE_SHIP,), name=\"Combi\")\n\nHere, we have created a \"no-op\" layer with two bases: ``CATS_MESSAGE`` and ``SPACE_SHIP``, named ``Combi``.\n\nPlease note that when using ``Layer`` directly like this, the ``name`` argument is required.\nThis is to allow the test runner to identify the layer correctly.\nNormally, the class name of the layer is used as a basis for the name, but when using the ``Layer`` base class directly, this is unlikely to be unique or descriptive.\n\nLayer resources\n---------------\n\nMany layers will manage one or more resources that are used either by other layers, or by tests themselves.\nExamples may include database connections, thread-local objects, or configuration data.\n\n``plone.testing`` contains a simple resource storage abstraction that makes it easy to access resources from dependant layers or tests.\nThe resource storage uses dictionary notation:::\n\n    >>> class WarpDrive(object):\n    ...     \"\"\"A shared resource\"\"\"\n    ...\n    ...     def __init__(self, maxSpeed):\n    ...         self.maxSpeed = maxSpeed\n    ...         self.running = False\n    ...\n    ...     def start(self, speed):\n    ...         if speed > self.maxSpeed:\n    ...             print(\"We need more power!\")\n    ...         else:\n    ...             print(\"Going to warp at speed\", speed)\n    ...             self.running = True\n    ...\n    ...     def stop(self):\n    ...         self.running = False\n\n    >>> class ConstitutionClassSpaceShip(Layer):\n    ...     defaultBases = (SPACE_SHIP,)\n    ...\n    ...     def setUp(self):\n    ...         self['warpDrive'] = WarpDrive(8.0)\n    ...\n    ...     def tearDown(self):\n    ...         del self['warpDrive']\n\n    >>> CONSTITUTION_CLASS_SPACE_SHIP = ConstitutionClassSpaceShip()\n\n    >>> class GalaxyClassSpaceShip(Layer):\n    ...     defaultBases = (CONSTITUTION_CLASS_SPACE_SHIP,)\n    ...\n    ...     def setUp(self):\n    ...         # Upgrade the warp drive\n    ...         self.previousMaxSpeed = self['warpDrive'].maxSpeed\n    ...         self['warpDrive'].maxSpeed = 9.5\n    ...\n    ...     def tearDown(self):\n    ...         # Restore warp drive to its previous speed\n    ...         self['warpDrive'].maxSpeed = self.previousMaxSpeed\n\n    >>> GALAXY_CLASS_SPACE_SHIP = GalaxyClassSpaceShip()\n\nAs shown, layers (that derive from ``plone.testing.Layer``) support item (dict-like) assignment, access and deletion of arbitrary resources under string keys.\n\n    **Important:** If a layer creates a resource (by assigning an object to a key on ``self`` as shown above) during fixture setup-up, it must also delete the resource on tear-down.\n    Set-up and deletion should be symmetric: if the resource is assigned during ``setUp()`` it should be deleted in ``tearDown()``;\n    if it's created in ``testSetUp()`` it should be deleted in ``testTearDown()``.\n\nA resource defined in a base layer is accessible from and through a child layer.\nIf a resource is set on a child using a key that also exists in a base layer, the child version will shadow the base version until the child layer is torn down (presuming it deletes the resource, which it should), but the base layer version remains intact.\n\n.. note::\n\n    Accessing a resource is analogous to accessing an instance variable.\n    For example, if a base layer assigns a resource to a given key in its ``setUp()`` method, a child layer shadows that resource with another object under the same key, the shadowed resource will by used during the ``testSetUp()`` and ``testTearDown()`` lifecycle methods if implemented by the *base* layer as well.\n    This will be the case until the child layer \"pops\" the resource by deleting it, normally in its ``tearDown()``.\n\nConversely, if (as shown above) the child layer accesses and modifies the object, it will modify the original.\n\n.. note::\n\n   It is sometimes necessary (or desirable) to modify a shared resource in a child layer, as shown in the example above.  In this case, however, it is very important to restore the original state when the layer is torn down.  Otherwise, other layers or tests using the base layer directly may be affected in difficult-to-debug ways.\n\nIf the same key is used in multiple base layers, the rules for choosing which version to use are similar to those that apply when choosing an attribute or method to use in the case of multiple inheritance.\n\nIn the example above, we used the resource manager for the ``warpDrive`` object, but we assigned the ``previousMaxSpeed`` variable to ``self``.\nThis is because ``previousMaxSpeed`` is internal to the layer and should not be shared with any other layers that happen to use this layer as a base.\nNor should it be used by any test cases.\nConversely, ``warpDrive`` is a shared resource that is exposed to other layers and test cases.\n\nThe distinction becomes even more important when you consider how a test case may access the shared resource.\nWe'll discuss how to write test cases that use layers shortly, but consider the following test:::\n\n    >>> import unittest\n    >>> class TestFasterThanLightTravel(unittest.TestCase):\n    ...     layer = GALAXY_CLASS_SPACE_SHIP\n    ...\n    ...     def test_hyperdrive(self):\n    ...         warpDrive = self.layer['warpDrive']\n    ...         warpDrive.start(8)\n\nThis test needs access to the shared resource.\nIt knows that its layer defines one called ``warpDrive``.\nIt does not know or care that the warp drive was actually initiated by the ``ConstitutionClassSpaceShip`` base layer.\n\nIf, however, the base layer had assigned the resource as an instance variable, it would not inherit to child layers (remember: layer bases are not base classes!).\nThe syntax to access it would be:::\n\n    self.layer.__bases__[0].warpDrive\n\nwhich is not only ugly, but brittle: if the list of bases is changed, the expression above may lead to an attribute error.\n\nWriting tests\n=============\n\nTests are usually written in one of two ways: As methods on a class that derives from ``unittest.TestCase`` (this is sometimes known as \"Python tests\" or \"JUnit-style tests\"), or using doctest syntax.\n\nYou should realise that although the relevant frameworks (``unittest`` and ``doctest``) often talk about unit testing, these tools are also used to write integration and functional tests.\nThe distinction between unit, integration and functional tests is largely practical: you use the same techniques to set up a fixture or write assertions for an integration test as you would for a unit test.\nThe difference lies in what that fixture contains, and how you invoke the code under test.\nIn general, a true unit test will have a minimal or no test fixture, whereas an integration test will have a fixture that contains the components your code is integrating with.\nA functional test will have a fixture that contains enough of the full system to execute and test an \"end-to-end\" scenario.\n\nPython tests\n------------\n\nPython tests use the Python `unittest`_ module.\nThey should be placed in a module or package called ``tests`` for the test runner to pick them up.\n\nFor small packages, a single module called ``tests.py`` will normally contain all tests.\nFor larger packages, it is common to have a ``tests`` package that contains a number of modules with tests.\nThese need to start with the word ``test``, e.g.\n``tests/test_foo.py`` or ``tests/test_bar.py``.\nDon't forget the ``__init__.py`` in the ``tests`` package, too!\n\nunittest\n~~~~~~~~\n\nPlease note that the `zope.testing`_ test runner at the time of writing (version 4.6.2) does not (yet) support the new ``setUpClass()``, ``tearDownClass()``, ``setUpModule()`` and ``tearDownModule()`` hooks from ``unittest``.\nThis is not normally a problem, since we tend to use layers to manage complex fixtures, but it is important to be aware of nonetheless.\n\nTest modules, classes and functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPython tests are written with classes that derive from the base class ``TestCase``.\nEach test is written as a method that takes no arguments and has a name starting with ``test``.\nOther methods can be added and called from test methods as appropriate, e.g.\nto share some test logic.\n\nTwo special methods, ``setUp()`` and ``tearDown()``, can also be added.\nThese will be called before or after each test, respectively, and provide a useful place to construct and clean up test fixtures without writing a custom layer.\nThey are obviously not as re-usable as layers, though.\n\n   *Hint:* Somewhat confusingly, the ``setUp()`` and ``tearDown()`` methods in a test case class are the equivalent of the ``testSetUp()`` and ``testTearDown()`` methods of a layer class.\n\nA layer can be specified by setting the ``layer`` class attribute to a layer instance.\nIf layers are used in conjunction with ``setUp()`` and ``tearDown()`` methods in the test class itself, the class' ``setUp()`` method will be called after the layer's ``testSetUp()`` method, and the class' ``tearDown()`` method will be called before the layer's ``testTearDown()`` method.\n\nThe ``TestCase`` base class contains a number of methods which can be used to write assertions.\nThey all take the form ``self.assertSomething()``, e.g.\n``self.assertEqual(result, expectedValue)``.\nSee the `unittest`_ documentation for details.\n\nPutting this together, let's expand on our previous example unit test:::\n\n    >>> import unittest\n\n    >>> class TestFasterThanLightTravel(unittest.TestCase):\n    ...     layer = GALAXY_CLASS_SPACE_SHIP\n    ...\n    ...     def setUp(self):\n    ...         self.warpDrive = self.layer['warpDrive']\n    ...         self.warpDrive.stop()\n    ...\n    ...     def tearDown(self):\n    ...         self.warpDrive.stop()\n    ...\n    ...     def test_warp8(self):\n    ...         self.warpDrive.start(8)\n    ...         self.assertEqual(self.warpDrive.running, True)\n    ...\n    ...     def test_max_speed(self):\n    ...         tooFast = self.warpDrive.maxSpeed + 0.1\n    ...         self.warpDrive.start(tooFast)\n    ...         self.assertEqual(self.warpDrive.running, False)\n\nA few things to note:\n\n* The class derives from ``unittest.TestCase``.\n\n* The ``layer`` class attribute is set to a layer instance (not a layer class!) defined previously.\n  This would typically be imported from a ``testing`` module.\n\n* There are two tests here: ``test_warp8()`` and ``test_max_speed()``.\n\n* We have used the ``self.assertEqual()`` assertion in both tests to check the result of executing the ``start()`` method on the warp drive.\n\n* We have used the ``setUp()`` method to fetch the ``warpDrive`` resource and ensure that it is stopped before each test is executed.\n  Assigning a variable to ``self`` is a useful way to provide some state to each test method, though be careful about data leaking between tests: in general, you cannot predict the order in which tests will run, and tests should always be independent.\n\n* We have used the ``tearDown()`` method to make sure the warp drive is really stopped after each test.\n\nTest suites\n~~~~~~~~~~~\n\nA class like the one above is all you need: any class deriving from ``TestCase`` in a module with a name starting with ``test`` will be examined for test methods.\nThose tests are then collected into a test suite and executed.\n\nSee the `unittest`_ documentation for other options.\n\nDoctests\n--------\n\nDoctests can be written in two ways: as the contents of a docstring (usually, but not always, as a means of illustrating and testing the functionality of the method or class where the docstring appears), or as a separate text file.\nIn both cases, the standard `doctest`_ module is used.\nSee its documentation for details about doctest syntax and conventions.\n\nDoctests are used in two different ways:\n\n* To test documentation.\n  That is, to ensure that code examples contained in documentation are valid and continue to work as the software is updated.\n\n* As a convenient syntax for writing tests.\n\nThese two approaches use the same testing APIs and techniques.\nThe difference is mostly about mindset.\nHowever, it is important to avoid falling into the trap that tests can substitute for good documentation or vice-a-versa.\nTests usually need to systematically go through inputs and outputs and cover off a number of corner cases.\nDocumentation should tell a compelling narrative and usually focus on the main usage scenarios.\nTrying to kill these two birds with one stone normally leaves you with an unappealing pile of stones and feathers.\n\nDocstring doctests\n~~~~~~~~~~~~~~~~~~\n\nDoctests can be added to any module, class or function docstring:::\n\n    def canOutrunKlingons(warpDrive):\n        \"\"\"Find out of the given warp drive can outrun Klingons.\n\n        Klingons travel at warp 8\n\n        >>> drive = WarpDrive(5)\n        >>> canOutrunKlingons(drive)\n        False\n\n        We have to be faster than that to outrun them.\n\n        >>> drive = WarpDrive(8.1)\n        >>> canOutrunKlingons(drive)\n        True\n\n        We can't outrun them if we're travelling exactly the same speed\n\n        >>> drive = WarpDrive(8.0)\n        >>> canOutrunKlingons(drive)\n        False\n\n        \"\"\"\n        return warpDrive.maxSpeed > 8.0\n\nTo add the doctests from a particular module to a test suite, you need to use the ``test_suite()`` function hook:::\n\n    >>> import doctest\n    >>> def test_suite():\n    ...     suite = unittest.TestSuite()\n    ...     suite.addTests([\n    ...         unittest.makeSuite(TestFasterThanLightTravel), # our previous test\n    ...         doctest.DocTestSuite('spaceship.utils'),\n    ...     ])\n    ...     return suite\n\nHere, we have given the name of the module to check as a string dotted name.\nIt is also possible to import a module and pass it as an object.\nThe code above passes a list to ``addTests()``, making it easy to add several sets of tests to the suite: the list can be constructed from calls to ``DocTestSuite()``, ``DocFileSuite()`` (shown below) and ``makeSuite()`` (shown above).\n\n    Remember that if you add a ``test_suite()`` function to a module that also has ``TestCase``-derived python tests, those tests will no longer be automatically picked up by ``zope.testing``, so you need to add them to the test suite explicitly.\n\nThe example above illustrates a documentation-oriented doctest, where the doctest forms part of the docstring of a public module.\nThe same syntax can be used for more systematic unit tests.\nFor example, we could have a module ``spaceship.tests.test_spaceship`` with a set of methods like::\n\n    # It's often better to put the import into each method, but here we've\n    # imported the code under test at module level\n    from spaceship.utils import WarpDrive, canOutrunKlingons\n\n    def test_canOutrunKlingons_too_small():\n        \"\"\"Klingons travel at warp 8.0\n\n        >>> drive = WarpDrive(7.9)\n        >>> canOutrunKlingons(drive)\n        False\n\n        \"\"\"\n\n    def test_canOutrunKlingons_big():\n        \"\"\"Klingons travel at warp 8.0\n\n        >>> drive = WarpDrive(8.1)\n        >>> canOutrunKlingons(drive)\n        True\n\n        \"\"\"\n\n    def test_canOutrunKlingons_must_be_greater():\n        \"\"\"Klingons travel at warp 8.0\n\n        >>> drive = WarpDrive(8.0)\n        >>> canOutrunKlingons(drive)\n        False\n\n        \"\"\"\n\nHere, we have created a number of small methods that have no body.\nThey merely serve as a container for docstrings with doctests.\nSince the module has no globals, each test must import the code under test, which helps make import errors more explicit.\n\nFile doctests\n~~~~~~~~~~~~~\n\nDoctests contained in a file are similar to those contained in docstrings.\nFile doctests are better suited to narrative documentation covering the usage of an entire module or package.\n\nFor example, if we had a file called ``spaceship.txt`` with doctests, we could add it to the test suite above with:::\n\n    >>> def test_suite():\n    ...     suite = unittest.TestSuite()\n    ...     suite.addTests([\n    ...         unittest.makeSuite(TestFasterThanLightTravel),\n    ...         doctest.DocTestSuite('spaceship.utils'),\n    ...         doctest.DocFileSuite('spaceship.txt'),\n    ...     ])\n    ...     return suite\n\nBy default, the file is located relative to the module where the test suite is defined.\nYou can use ``../`` (even on Windows) to reference the parent directory, which is sometimes useful if the doctest is inside a module in a ``tests`` package.\n\n.. note::\n\n    If you put the doctest ``test_suite()`` method in a module inside a ``tests`` package, that module must have a name starting with ``test``.\n    It is common to have ``tests/test_doctests.py`` that contains a single ``test_suite()`` method that returns a suite of multiple doctests.\n\nIt is possible to pass several tests to the suite, e.g.::\n\n    >>> def test_suite():\n    ...     suite = unittest.TestSuite()\n    ...     suite.addTests([\n    ...         unittest.makeSuite(TestFasterThanLightTravel),\n    ...         doctest.DocTestSuite('spaceship.utils'),\n    ...         doctest.DocFileSuite('spaceship.txt', 'warpdrive.txt',),\n    ...     ])\n    ...     return suite\n\nThe test runner will report each file as a separate test, i.e.\nthe ``DocFileSuite()`` above would add two tests to the overall suite.\nConversely, a ``DocTestSuite()`` using a module with more than one docstring containing doctests will report one test for each eligible docstring.\n\nDoctest fixtures and layers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA docstring doctest will by default have access to any global symbol available in the module where the docstring is found (e.g.\nanything defined or imported in the module).\nThe global namespace can be overridden by passing a ``globs`` keyword argument to the ``DocTestSuite()`` constructor, or augmented by passing an ``extraglobs`` argument.\nBoth should be given dictionaries.\n\nA file doctest has an empty globals namespace by default.\nGlobals may be provided via the ``globs`` argument to ``DocFileSuite()``.\n\nTo manage a simple test fixture for a doctest, you can define set-up and tear-down functions and pass them as the ``setUp`` and ``tearDown`` arguments respectively.\nThese are both passed a single argument, a ``DocTest`` object.\nThe most useful attribute of this object is ``globs``, which is a mutable dictionary of globals available in the test.\n\nFor example:::\n\n    >>> def setUpKlingons(doctest):\n    ...     doctest.globs['oldStyleKlingons'] = True\n\n    >>> def tearDownKlingons(doctest):\n    ...     doctest.globs['oldStyleKlingons'] = False\n\n    >>> def test_suite():\n    ...     suite = unittest.TestSuite()\n    ...     suite.addTests([\n    ...         doctest.DocTestSuite('spaceship.utils', setUp=setUpKlingons, tearDown=tearDownKlingons),\n    ...     ])\n    ...     return suite\n\nThe same arguments are available on the ``DocFileSuite()`` constructor.\nThe set up method is called before each docstring in the given module for a ``DocTestSuite``, and before each file given in a ``DocFileSuite``.\n\nOf course, we often want to use layers with doctests too.\nUnfortunately, the ``unittest`` API is not aware of layers, so you can't just pass a layer to the ``DocTestSuite()`` and ``DocFileSuite()`` constructors.\nInstead, you have to set a ``layer`` attribute on the suite after it has been constructed.\n\nFurthermore, to use layer resources in a doctest, we need access to the layer instance.\nThe easiest way to do this is to pass it as a glob, conventionally called 'layer'.\nThis makes a global name 'layer' available in the doctest itself, giving access to the test's layer instance.\n\nTo make it easier to do this, ``plone.testing`` comes with a helper function called ``layered()``.\nIts first argument is a test suite.\nThe second argument is the layer.\n\nFor example:::\n\n    >>> from plone.testing import layered\n    >>> def test_suite():\n    ...     suite = unittest.TestSuite()\n    ...     suite.addTests([\n    ...         layered(doctest.DocTestSuite('spaceship.utils'), layer=CONSTITUTION_CLASS_SPACE_SHIP),\n    ...     ])\n    ...     return suite\n\nThis is equivalent to:::\n\n    >>> def test_suite():\n    ...     suite = unittest.TestSuite()\n    ...\n    ...     spaceshipUtilTests = doctest.DocTestSuite('spaceship.utils', globs={'layer': CONSTITUTION_CLASS_SPACE_SHIP})\n    ...     spaceshipUtilTests.layer = CONSTITUTION_CLASS_SPACE_SHIP\n    ...     suite.addTest(spaceshipUtilTests)\n    ...\n    ...     return suite\n\n(In this example, we've opted to use ``addTest()`` to add a single suite, instead of using ``addTests()`` to add multiple suites in one go).\n\nZope testing tools\n==================\n\nEverything described so far in this document relies only on the standard `unittest`_ and `doctest`_ modules and `zope.testing`_, and you can use this package without any other dependencies.\n\nHowever, there are also some tools (and layers) available in this package, as well as in other packages, that are specifically useful for testing applications that use various Zope-related frameworks.\n\nTest cleanup\n------------\n\nIf a test uses a global registry, it may be necessary to clean that registry on set up and tear down of each test fixture.\n``zope.testing`` provides a mechanism to register cleanup handlers - methods that are called to clean up global state.\nThis can then be invoked in the ``setUp()`` and ``tearDown()`` fixture lifecycle methods of a test case.::\n\n    >>> from zope.testing import cleanup\n\nLet's say we had a global registry, implemented as a dictionary:::\n\n    >>> SOME_GLOBAL_REGISTRY = {}\n\nIf we wanted to clean this up on each test run, we could call ``clear()`` on the dict.\nSince that's a no-argument method, it is perfect as a cleanup handler.::\n\n    >>> cleanup.addCleanUp(SOME_GLOBAL_REGISTRY.clear)\n\nWe can now use the ``cleanUp()`` method to execute all registered cleanups:::\n\n    >>> cleanup.cleanUp()\n\nThis call could be placed in a ``setUp()`` and/or ``tearDown()`` method in a test class, for example.\n\nEvent testing\n-------------\n\nYou may wish to test some code that uses ``zope.event`` to fire specific events.\n`zope.component`_ provides some helpers to capture and analyse events.::\n\n    >>> from zope.component import eventtesting\n\nTo use this, you first need to set up event testing.\nSome of the layers shown below will do this for you, but you can do it yourself by calling the ``eventtesting.setUp()`` method, e.g.\nfrom your own ``setUp()`` method:::\n\n    >>> eventtesting.setUp()\n\nThis simply registers a few catch-all event handlers.\nOnce you have executed the code that is expected to fire events, you can use the ``getEvents()`` helper function to obtain a list of the event instances caught:::\n\n    >>> events = eventtesting.getEvents()\n\nYou can now examine ``events`` to see what events have been caught since the last cleanup.\n\n``getEvents()`` takes two optional arguments that can be used to filter the returned list of events.\nThe first (``event_type``) is an interface.\nIf given, only events providing this interface are returned.\nThe second (``filter``) is a callable taking one argument.\nIf given, it will be called with each captured event.\nOnly those events where the filter function returns ``True`` will be included.\n\nThe ``eventtesting`` module registers a cleanup action as outlined above.\nWhen you call ``cleanup.cleanUp()`` (or ``eventtesting.clearEvents()``, which is the handler it registers), the events list will be cleared, ready for the next test.\nHere, we'll do it manually:::\n\n    >>> eventtesting.clearEvents()\n\nMock requests\n-------------\n\nMany tests require a request object, often with particular request/form variables set.\n`zope.publisher`_ contains a useful class for this purpose.::\n\n    >>> from zope.publisher.browser import TestRequest\n\nA simple test request can be constructed with no arguments:::\n\n    >>> request = TestRequest()\n\nTo add a body input stream, pass a ``StringIO`` or file as the first parameter.\nTo set the environment (request headers), use the ``environ`` keyword argument.\nTo simulate a submitted form, use the ``form`` keyword argument:::\n\n    >>> request = TestRequest(form=dict(field1='foo', field2=1))\n\nNote that the ``form`` dict contains marshalled form fields, so modifiers like ``:int`` or ``:boolean`` should not be included in the field names, and values should be converted to the appropriate type.\n\nRegistering components\n----------------------\n\nMany test fixtures will depend on having a minimum of Zope Component Architecture (ZCA) components registered.\nIn normal operation, these would probably be registered via ZCML, but in a unit test, you should avoid loading the full ZCML configuration of your package (and its dependencies).\n\nInstead, you can use the Python API in `zope.component`_ to register global components instantly.\nThe three most commonly used functions are:::\n\n    >>> from zope.component import provideAdapter\n    >>> from zope.component import provideUtility\n    >>> from zope.component import provideHandler\n\nSee the `zope.component`_ documentation for details about how to use these.\n\nWhen registering global components like this, it is important to avoid test leakage.\nThe ``cleanup`` mechanism outlined above can be used to tear down the component registry between each test.\nSee also the ``plone.testing.zca.UNIT_TESTING`` layer, described below, which performs this cleanup automatically via the ``testSetUp()``/``testTearDown()`` mechanism.\n\nAlternatively, you can \"stack\" a new global component registry using the ``plone.testing.zca.pushGlobalRegistry()`` and ``plone.testing.zca.popGlobalRegistry()`` helpers.\nThis makes it possible to set up and tear down components that are specific to a given layer, and even allow tests to safely call the global component API (or load ZCML - see below) with proper tear-down.\nSee the layer reference below for details.\n\nLoading ZCML\n------------\n\nIntegration tests often need to load ZCML configuration.\nThis can be achieved using the ``zope.configuration`` API.::\n\n    >>> from zope.configuration import xmlconfig\n\nThe ``xmlconfig`` module contains two methods for loading ZCML.\n\n``xmlconfig.string()`` can be used to load a literal string of ZCML:::\n\n    >>> xmlconfig.string(\"\"\"\\\n    ... <configure xmlns=\"http://namespaces.zope.org/zope\" package=\"plone.testing\">\n    ...     <include package=\"zope.component\" file=\"meta.zcml\" />\n    ... </configure>\n    ... \"\"\")\n    <zope.configuration.config.ConfigurationMachine object at ...>\n\nNote that we need to set a package (used for relative imports and file locations) explicitly here, using the ``package`` attribute of the ``<configure />`` element.\n\nAlso note that unless the optional second argument (``context``) is passed, a new configuration machine will be created every time ``string()`` is called.\nIt therefore becomes necessary to explicitly ``<include />`` the files that contain the directives you want to use (the one in ``zope.component`` is a common example).\nLayers that set up ZCML configuration may expose a resource which can be passed as the ``context`` parameter, usually called ``configurationContext`` - see below.\n\nTo load the configuration for a particular package, use ``xmlconfig.file()``:::\n\n    >>> import zope.component\n    >>> context = xmlconfig.file('meta.zcml', zope.component)\n    >>> xmlconfig.file('configure.zcml', zope.component, context=context)\n    <zope.configuration.config.ConfigurationMachine object at ...>\n\nThis takes two required arguments: the file name and the module relative to which it is to be found.\nHere, we have loaded two files: ``meta.zcml`` and ``configure.zcml``.\nThe first call to ``xmlconfig.file()`` creates and returns a configuration context.\nWe re-use that for the subsequent invocation, so that the directives configured are available.\n\nInstalling a Zope product\n-------------------------\n\nSome packages (including all those in the ``Products.*`` namespace) have the special status of being Zope \"products\".\nThese are recorded in a special registry, and may have an ``initialize()`` hook in their top-level ``__init__.py`` that needs to be called for the package to be fully configured.\n\nZope 2 will find and execute any products during startup.\nFor testing, we need to explicitly list the products to install.\nProvided you are using ``plone.testing`` with Zope, you can use the following:::\n\n    from plone.testing import zope\n\n    with zope.zopeApp() as app:\n        zope.installProduct(app, 'Products.ZCatalog')\n\nThis would normally be used during layer ``setUp()``.\nNote that the basic Zope application context must have been set up before doing this.\nThe usual way to ensure this, is to use a layer that is based on ``zope.STARTUP`` - see below.\n\nTo tear down such a layer, you should do:::\n\n    from plone.testing import zope\n\n    with zope.zopeApp() as app:\n        zope.uninstallProduct(app, 'Products.ZCatalog')\n\nNote:\n\n* Unlike the similarly-named function from ``ZopeTestCase``, these helpers will work with any type of product.\n  There is no distinction between a \"product\" and a \"package\" (and no ``installPackage()``).\n  However, you must use the full name (``Products.*``) when registering a product.\n\n* Installing a product in this manner is independent of ZCML configuration.\n  However, it is almost always necessary to install the package's ZCML configuration first.\n\nFunctional testing\n------------------\n\nFor functional tests that aim to simulate the browser, you can use `zope.testbrowser`_ in a Python test or doctest:::\n\n    >>> from zope.testbrowser.browser import Browser\n    >>> browser = Browser()\n\nThis provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as Selenium_ do).\nThe downside is that it is not possible to test JavaScript- dependent behaviour.\n\nIf you are testing a Zope application, you need to change the import location slightly, and pass the application root to the method:::\n\n    from plone.testing.zope import Browser\n    browser = Browser(app)\n\nYou can get the application root from the ``app`` resource in any of the Zope layers in this package.\n\nBeyond that, the `zope.testbrowser`_ documentation should cover how to use the test browser.\n\n    **Hint:** The test browser will usually commit at the end of a request.\n    To avoid test fixture contamination, you should use a layer that fully isolates each test, such as the ``zope.INTEGRATION_TESTING`` layer described below.\n\nLayer reference\n===============\n\n``plone.testing`` comes with several layers that are available to use directly or extend.\nThese are outlined below.\n\nZope Component Architecture\n---------------------------\n\nThe Zope Component Architecture layers are found in the module ``plone.testing.zca``.\nIf you depend on this, you can use the ``[zca]`` extra when depending on ``plone.testing``.\n\nUnit testing\n~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zca.UNIT_TESTING``               |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zca.UnitTesting``                |\n+------------+--------------------------------------------------+\n| Bases:     | None                                             |\n+------------+--------------------------------------------------+\n| Resources: | None                                             |\n+------------+--------------------------------------------------+\n\nThis layer does not set up a fixture per se, but cleans up global state before and after each test, using ``zope.testing.cleanup`` as described above.\n\nThe net result is that each test has a clean global component registry.\nThus, it is safe to use the `zope.component`_ Python API (``provideAdapter()``, ``provideUtility()``, ``provideHandler()`` and so on) to register components.\n\nBe careful with using this layer in combination with other layers.\nBecause it tears down the component registry between each test, it will clobber any layer that sets up more permanent test fixture in the component registry.\n\nEvent testing\n~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zca.EVENT_TESTING``              |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zca.EventTesting``               |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zca.UNIT_TESTING``               |\n+------------+--------------------------------------------------+\n| Resources: | None                                             |\n+------------+--------------------------------------------------+\n\nThis layer extends the ``zca.UNIT_TESTING`` layer to enable the ``eventtesting`` support from ``zope.component``.\nUsing this layer, you can import and use ``zope.component.eventtesting.getEvent`` to inspect events fired by the code under test.\n\nSee above for details.\n\nLayer cleanup\n~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zca.LAYER_CLEANUP``              |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zca.LayerCleanup``               |\n+------------+--------------------------------------------------+\n| Bases:     | None                                             |\n+------------+--------------------------------------------------+\n| Resources: | None                                             |\n+------------+--------------------------------------------------+\n\nThis layer calls the cleanup functions from ``zope.testing.cleanup`` on setup and tear-down (but not between each test).\nIt is useful as a base layer for other layers that need an environment as pristine as possible.\n\nBasic ZCML directives\n~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zca.ZCMLDirectives``             |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |\n+------------+--------------------------------------------------+\n| Resources: | ``configurationContext``                         |\n+------------+--------------------------------------------------+\n\nThis registers a minimal set of ZCML directives, principally those found in the ``zope.component`` package, and makes available a configuration context.\nThis allows custom ZCML to be loaded as described above.\n\nThe ``configurationContext`` resource should be used when loading custom ZCML.\nTo ensure isolation, you should stack this using the ``stackConfigurationContext()`` helper.\nFor example, if you were writing a ``setUp()`` method in a layer that had ``zca.ZCML_DIRECTIVES`` as a base, you could do:::\n\n    self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))\n    xmlconfig.string(someZCMLString, context=context)\n\nThis will create a new configuration context with the state of the base layer's context.\nOn tear-down, you should delete the layer-specific resource:::\n\n    del self['configurationContext']\n\n.. note::\n\n   If you fail to do this, you may get problems if your layer is torn down and then needs to be set up again later.\n\nSee above for more details about loading custom ZCML in a layer or test.\n\nZCML files helper class\n~~~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zca.ZCMLSandbox``                |\n+------------+--------------------------------------------------+\n| Resources: | ``configurationContext``                         |\n+------------+--------------------------------------------------+\n\nThe ``ZCMLSandbox`` can be instantiated with a ``filename`` and ``package`` arguments::\n\n    ZCML_SANDBOX = zca.ZCMLSandbox(filename=\"configure.zcml\",\n        package=my.package)\n\n\nThat layer ``setUp`` loads the ZCML file.\nIt avoids the need to using (and understand) ``configurationContext`` and ``globalRegistry`` until you need more flexibility or modularity for your layer and tests.\n\nSee above for more details about loading custom ZCML in a layer or test.\n\nHelper functions\n~~~~~~~~~~~~~~~~\n\nThe following helper functions are available in the ``plone.testing.zca`` module.\n\n``stackConfigurationContext(context=None)``\n\n    Create and return a copy of the passed-in ZCML configuration context, or a brand new context if it is ``None``.\n\n    The purpose of this is to ensure that if a layer loads some ZCML files (using the ``zope.configuration`` API during) during its ``setUp()``, the state of the configuration registry (which includes registered directives as well as a list of already imported files, which will not be loaded again even if explicitly included) can be torn down during ``tearDown()``.\n\n    The usual pattern is to keep the configuration context in a layer resource called ``configurationContext``.\n    In ``setUp()``, you would then use::\n\n        self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))\n\n        # use 'context' to load some ZCML\n\n    In ``tearDown()``, you can then simply do::\n\n        del self['configurationContext']\n\n``pushGlobalRegistry(new=None)``\n\n    Create or obtain a stack of global component registries, and push a new registry to the top of the stack.\n    The net result is that ``zope.component.getGlobalSiteManager()`` and (an un-hooked) ``getSiteManager()`` will return the new registry instead of the default, module-scope one.\n    From this point onwards, calls to ``provideAdapter()``, ``provideUtility()`` and other functions that modify the global registry will use the new registry.\n\n    If ``new`` is not given, a new registry is created that has the previous global registry (site manager) as its sole base.\n    This has the effect that registrations in the previous default global registry are still available, but new registrations are confined to the new registry.\n\n    **Warning**: If you call this function, you *must* reciprocally call ``popGlobalRegistry()``.\n    That is, if you \"push\" a registry during layer ``setUp()``, you must \"pop\" it during ``tearDown()``.\n    If you \"push\" during ``testSetUp()``, you must \"pop\" during ``testTearDown()``.\n    If the calls to push and pop are not balanced, you will leave your global registry in a mess, which is not pretty.\n\n    Returns the new default global site manager.\n    Also causes the site manager hook from ``zope.component.hooks`` to be reset, clearing any local site managers as appropriate.\n\n``popGlobalRegistry()``\n\n    Pop the global site registry, restoring the previous registry to be the default.\n\n    Please heed the warning above: push and pop must be balanced.\n\n    Returns the new default global site manager.\n    Also causes the site manager hook from ``zope.component.hooks`` to be reset, clearing any local site managers as appropriate.\n\nZope Security\n-------------\n\nThe Zope Security layers build can be found in the module ``plone.testing.security``.\n\nIf you depend on this, you can use the ``[security]`` extra when depending on ``plone.testing``.\n\nSecurity checker isolation\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.security.CHECKERS``              |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.security.Checkers``              |\n+------------+--------------------------------------------------+\n| Bases:     | None                                             |\n+------------+--------------------------------------------------+\n| Resources: | None                                             |\n+------------+--------------------------------------------------+\n\nThis layer ensures that security checkers used by ``zope.security`` are isolated.\nAny checkers set up in a child layer will be removed cleanly during tear-down.\n\nHelper functions\n~~~~~~~~~~~~~~~~\n\nThe security checker isolation outlined above is managed using two helper functions found in the module ``plone.testing.security``:\n\n``pushCheckers()``\n\n    Copy the current set of security checkers for later tear-down.\n\n``popCheckers()``\n\n    Restore the set of security checkers to the state of the most recent call to ``pushCheckers()``.\n\nYou *must* keep calls to ``pushCheckers()`` and ``popCheckers()`` in balance.\nThat usually means that if you call the former during layer setup, you should call the latter during layer tear-down.\nDitto for calls during test setup/tear-down or within tests themselves.\n\nZope Publisher\n--------------\n\nThe Zope Publisher layers build on the Zope Component Architecture layers.\nThey can be found in the module ``plone.testing.publisher``.\n\nIf you depend on this, you can use the ``[publisher]`` extra when depending on ``plone.testing``.\n\nPublisher directives\n~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.publisher.PUBLISHER_DIRECTIVES`` |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.publisher.PublisherDirectives``  |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zca.ZCML_DIRECTIVES``            |\n+------------+--------------------------------------------------+\n| Resources: | None                                             |\n+------------+--------------------------------------------------+\n\nThis layer extends the ``zca.ZCML_DIRECTIVES`` layer to install additional ZCML directives in the ``browser`` namespace (from ``zope.app.publisher.browser``) as well as those from ``zope.security``.\nThis allows browser views, browser pages and other UI components to be registered, as well as the definition of new permissions.\n\nAs with ``zca.ZCML_DIRECTIVES``, you should use the ``configurationContext`` resource when loading ZCML strings or files, and the ``stackConfigurationRegistry()`` helper to create a layer-specific version of this resource resource.\nSee above.\n\nZODB\n----\n\nThe ZODB layers set up a test fixture with a persistent ZODB.\nThe ZODB instance uses ``DemoStorage``, so it will not interfere with any \"live\" data.\n\nZODB layers can be found in the module ``plone.testing.zodb``.\nIf you depend on this, you can use the ``[zodb]`` extra when depending on ``plone.testing``.\n\nEmpty ZODB sandbox\n~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zodb.EMPTY_ZODB``                |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zodb.EmptyZODB``                 |\n+------------+--------------------------------------------------+\n| Bases:     |  None                                            |\n+------------+--------------------------------------------------+\n| Resources: | ``zodbRoot``                                     |\n|            +--------------------------------------------------+\n|            | ``zodbDB`` (test set-up only)                    |\n|            +--------------------------------------------------+\n|            | ``zodbConnection`` (test set-up only)            |\n+------------+--------------------------------------------------+\n\nThis layer sets up a simple ZODB sandbox using ``DemoStorage``.\nThe ZODB root object is a simple persistent mapping, available as the resource ``zodbRoot``.\nThe ZODB database object is available as the resource ``zodbDB``.\nThe connection used in the test is available as ``zodbConnection``.\n\nNote that the ``zodbConnection`` and ``zodbRoot`` resources are created and destroyed for each test.\nYou can use ``zodbDB`` (and the ``open()`` method) if you are writing a layer based on this one and need to set up a fixture during layer set up.\nDon't forget to close the connection before concluding the test setup!\n\nA new transaction is begun for each test, and rolled back (aborted) on test tear-down.\nThis means that so long as you don't use ``transaction.commit()`` explicitly in your code, it should be safe to add or modify items in the ZODB root.\n\nIf you want to create a test fixture with persistent data in your own layer based on ``EMPTY_ZODB``, you can use the following pattern::\n\n    from plone.layer import Layer\n    from plone.layer import zodb\n\n    class MyLayer(Layer):\n        defaultBases = (zodb.EMPTY_ZODB,)\n\n        def setUp(self):\n\n            import transaction\n            self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')\n\n            conn = db.open()\n            root = conn.root()\n\n            # modify the root object here\n\n            transaction.commit()\n            conn.close()\n\n        def tearDown(self):\n\n            self['zodbDB'].close()\n            del self['zodbDB']\n\nThis shadows the ``zodbDB`` resource with a new database that uses a new ``DemoStorage`` stacked on top of the underlying database storage.\nThe fixture is added to this storage and committed during layer setup.\n(The base layer test set-up/tear-down will still begin and abort a new transaction for each *test*).\nOn layer tear-down, the database is closed and the resource popped, leaving the original ``zodbDB`` database with the original, pristine storage.\n\nHelper functions\n~~~~~~~~~~~~~~~~\n\nOne helper function is available in the ``plone.testing.zodb`` module.\n\n``stackDemoStorage(db=None, name=None)``\n\nCreate a new ``DemoStorage`` using the storage from the passed-in database as a base.\nIf ``db`` is None, a brand new storage is created.\n\nA ``name`` can be given to uniquely identify the storage.\nIt is optional, but it is often useful for debugging purposes to pass the name of the layer.\n\nThe usual pattern is::\n\n    def setUp(self):\n        self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')\n\n    def tearDown(self):\n        self['zodbDB'].close()\n        del self['zodbDB']\n\nThis will shadow the ``zodbDB`` resource with an isolated ``DemoStorage``, creating a new one if that resource does not already exist.\nAll existing data continues to be available, but new changes are written to the stacked storage.\nOn tear-down, the stacked database is closed and the resource removed, leaving the original data.\n\nZope\n----\n\nThe Zope layers provide test fixtures suitable for testing Zope applications.\nThey set up a Zope application root, install core Zope products, and manage security.\n\nZope layers can be found in the module ``plone.testing.zope``.\nIf you depend on this, you can use the ``[zope]`` extra when depending on ``plone.testing``.\n\nStartup\n~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zope.STARTUP``                   |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zope.Startup``                   |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |\n+------------+--------------------------------------------------+\n| Resources: | ``zodbDB``                                       |\n|            +--------------------------------------------------+\n|            | ``configurationContext``                         |\n|            +--------------------------------------------------+\n|            | ``host``                                         |\n|            +--------------------------------------------------+\n|            | ``port``                                         |\n+------------+--------------------------------------------------+\n\nThis layer sets up a Zope environment, and is a required base for all other Zope layers.\nYou cannot run two instances of this layer in parallel, since Zope depends on some module-global state to run, which is managed by this layer.\n\nOn set-up, the layer will configure a Zope environment with:\n\n.. note::\n\n    The ``STARTUP`` layer is a useful base layer for your own fixtures, but should not be used directly, since it provides no test lifecycle or transaction management.\n    See the \"Integration test\" and \"Functional\" test sections below for examples of how to create your own layers.\n\n* Debug mode enabled.\n\n* ZEO client cache disabled.\n\n* Some patches installed, which speed up Zope startup by disabling some superfluous aspects of Zope.\n\n* One thread (this only really affects the ``WSGI_SERVER``, ``ZSERVER`` and ``FTP_SERVER`` layers).\n\n* A pristine database using ``DemoStorage``, exposed as the resource ``zodbDB``.\n  Zope is configured to use this database in a way that will also work if the ``zodbDB`` resource is shadowed using the pattern shown above in the description of the ``zodb.EMPTY_ZODB`` layer.\n\n* A fake hostname and port, exposed as the ``host`` and ``port`` resource, respectively.\n\n* A minimal set of products installed (``Products.OFSP`` and ``Products.PluginIndexes``, both required for Zope to start up).\n\n* A stacked ZCML configuration context, exposed as the resource ``configurationContext``.\n  As illustrated above, you should use the ``zca.stackConfigurationContext()`` helper to stack your own configuration context if you use this.\n\n* A minimal set of global Zope components configured.\n\nNote that unlike a \"real\" Zope site, products in the ``Products.*`` namespace are not automatically loaded, nor is any ZCML.\n\nIntegration test\n~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zope.INTEGRATION_TESTING``       |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zope.IntegrationTesting``        |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zope.STARTUP``                   |\n+------------+--------------------------------------------------+\n| Resources: | ``app``                                          |\n|            +--------------------------------------------------+\n|            | ``request``                                      |\n+------------+--------------------------------------------------+\n\nThis layer is intended for integration testing against the simple ``STARTUP`` fixture.\nIf you want to create your own layer with a more advanced, shared fixture, see \"Integration and functional testing with custom fixtures\" below.\n\nFor each test, it exposes the Zope application root as the resource ``app``.\nThis is wrapped in the request container, so you can do ``app.REQUEST`` to acquire a fake request, but the request is also available as the resource ``request``.\n\nA new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.\n\n    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``zope.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.\n\n    Once you've shadowed the ``zodbDB`` resource, you can do (e.g. in your layer's ``setUp()`` method)::\n\n        ...\n        with zope.zopeApp() as app:\n            # modify the Zope application root\n\n    The ``zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.\n    Provided the code within the ``with`` block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.\n\nFunctional testing\n~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zope.FUNCTIONAL_TESTING``        |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zope.FunctionalTesting``         |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zope.STARTUP``                   |\n+------------+--------------------------------------------------+\n| Resources: | ``app``                                          |\n|            +--------------------------------------------------+\n|            | ``request``                                      |\n+------------+--------------------------------------------------+\n\nThis layer is intended for functional testing against the simple ``STARTUP`` fixture.\nIf you want to create your own layer with a more advanced, shared fixture, see \"Integration and functional testing with custom fixtures\" below.\n\nAs its name implies, this layer is intended mainly for functional end-to-end testing using tools like `zope.testbrowser`_.\nSee also the ``Browser`` object as described under \"Helper functions\" below.\n\nThis layer is very similar to ``INTEGRATION_TESTING``, but is not based on it.\nIt sets up the same fixture and exposes the same resources.\nHowever, instead of using a simple transaction abort to isolate the ZODB between tests, it uses a stacked ``DemoStorage`` for each test.\nThis is slower, but allows test code to perform and explicit commit, as will usually happen in a functional test.\n\nIntegration and functional testing with custom fixtures\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:\n\n* Create a layer class and a \"fixture\" base layer instance that has ``zope.STARTUP`` (or some intermediary layer, such as ``zope.WSGI_SERVER_FIXTURE``, shown below) as a base.\n\n* Create \"end user\" layers by instantiating the ``zope.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new \"fixture\" layer as a base.\n\nThis allows the same fixture to be used regardless of the \"style\" of testing, minimising the amount of set-up and tear-down.\nThe \"fixture\" layers manage the fixture as part of the *layer* lifecycle.\nThe layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *test* lifecycle, and the test lifecycle only.\n\nFor example::\n\n    from plone.testing import Layer, zope, zodb\n\n    class MyLayer(Layer):\n        defaultBases = (zope.STARTUP,)\n\n        def setUp(self):\n            # Set up the fixture here\n            ...\n\n        def tearDown(self):\n            # Tear down the fixture here\n            ...\n\n    MY_FIXTURE = MyLayer()\n\n    MY_INTEGRATION_TESTING = zope.IntegrationTesting(bases=(MY_FIXTURE,), name=\"MyFixture:Integration\")\n    MY_FUNCTIONAL_TESTING = zope.FunctionalTesting(bases=(MY_FIXTURE,), name=\"MyFixture:Functional\")\n\n(Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)\n\nIn this example, other layers could extend the \"MyLayer\" fixture by using ``MY_FIXTURE`` as a base.\nTests would use either ``MY_INTEGRATION_TESTING`` or ``MY_FUNCTIONAL_TESTING`` as appropriate.\nHowever, even if both these two layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.\n\n.. note::\n\n    If you implement the ``testSetUp()`` and ``testTearDown()`` test lifecycle methods in your \"fixture\" layer (e.g. in the the ``MyLayer`` class above), they will execute before the corresponding methods from ``IntegrationTesting`` and ``FunctionalTesting``.\n    Hence, they cannot use those layers' resources (``app`` and ``request``).\n\nIt may be preferable, therefore, to have your own \"test lifecycle\" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.\n``plone.app.testing`` takes this approach, for example.\n\nHTTP WSGI server thread (fixture only)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zope.WSGI_SERVER_FIXTURE``       |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zope.WSGIServer``                |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zope.STARTUP``                   |\n+------------+--------------------------------------------------+\n| Resources: | ``host``                                         |\n|            +--------------------------------------------------+\n|            | ``port``                                         |\n+------------+--------------------------------------------------+\n\nThis layer extends the ``zope.STARTUP`` layer to start the Zope HTTP WSGI server in a separate thread.\nThis means the test site can be accessed through a web browser, and can thus be used with tools like `Selenium`_.\n\n.. note::\n\n    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n    Use the ``WSGI_SERVER`` layer if you want to execute functional tests against this fixture.\n\nThe WSGI server's hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.\n\n  *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.\n  The default URL will be ``http://localhost:55001``.\n\nHTTP WSGI server functional testing\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zope.WSGI_SERVER``               |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zope.FunctionalTesting``         |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zope.WSGI_SERVER_FIXTURE``       |\n+------------+--------------------------------------------------+\n| Resources: |                                                  |\n+------------+--------------------------------------------------+\n\nThis layer provides the functional testing lifecycle against the fixture set up by the ``zope.WSGI_SERVER_FIXTURE`` layer.\n\nYou can use this to run \"live\" functional tests against a basic Zope site.\nYou should **not** use it as a base.\nInstead, create your own \"fixture\" layer that extends ``zope.WSGI_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n\nHelper functions\n~~~~~~~~~~~~~~~~\n\nSeveral helper functions are available in the ``plone.testing.zope`` module.\n\n``zopeApp(db=None, conn=Non, environ=None)``\n\n    This function can be used as a context manager for any code that requires access to the Zope application root.\n    By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.\n    When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::\n\n        with zope.zopeApp() as app:\n            # do something with app\n\n    If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.\n    If the context manager opened a new connection, it will close it, but it will not close a connection passed with ``conn``.\n\n    To set keys in the (fake) request environment, pass a dictionary of environment values as ``environ``.\n\n    Note that ``zopeApp()`` should *not* normally be used in tests or test set-up/tear-down, because the ``INTEGRATOIN_TEST`` and ``FUNCTIONAL_TESTING`` layers both manage the application root (as the ``app`` resource) and close it for you.\n    It is very useful in layer setup, however.\n\n``installProduct(app, product, quiet=False)``\n\n    Install a Zope 2 style product, ensuring that its ``initialize()`` function is called.\n    The product name must be the full dotted name, e.g. ``plone.app.portlets`` or ``Products.CMFCore``.\n    If ``quiet`` is true, duplicate registrations will be ignored silently, otherwise a message is logged.\n\n    To get hold of the application root, passed as the ``app`` argument, you would normally use the ``zopeApp()`` context manager outlined above.\n\n``uninstallProduct(app, product, quiet=False)``\n\n    This is the reciprocal of ``installProduct()``, normally used during layer tear-down.\n    Again, you should use ``zopeApp()`` to obtain the application root.\n\n``login(userFolder, userName)``\n\n    Create a new security manager that simulates being logged in as the given user.\n    ``userFolder`` is an ``acl_users`` object, e.g. ``app['acl_users']`` for the root user folder.\n\n``logout()``\n\n    Simulate being the anonymous user by unsetting the security manager.\n\n``setRoles(userFolder, userName, roles)``\n\n    Set the roles of the given user in the given user folder to the given list of roles.\n\n``makeTestRequest()``\n\n    Create a fake Zope request.\n\n``addRequestContainer(app, environ=None)``\n\n    Create a fake request and wrap the given object (normally an application root) in a ``RequestContainer`` with this request.\n    This makes acquisition of ``app.REQUEST`` possible.\n    To initialise the request environment with non-default values, pass a dictionary as ``environ``.\n\n    .. note::\n\n       This method is rarely used, because both the ``zopeApp()``\n       context manager and the layer set-up/tear-down for\n       ``zope.INTEGRATION_TESTING`` and ``zope.FUNCTIONAL_TESTING`` will wrap the\n       ``app`` object before exposing it.\n\n``Browser(app)``\n\n    Obtain a test browser client, for use with `zope.testbrowser`_.\n    You should use this in conjunction with the ``zope.FUNCTIONAL_TESTING`` layer or a derivative.\n    You must pass the app root, usually obtained from the ``app`` resource of the layer, e.g.::\n\n        app = self.layer['app']\n        browser = zope.Browser(app)\n\n    You can then use ``browser`` as described in the `zope.testbrowser`_ documentation.\n\n    Bear in mind that the test browser runs separately from the test fixture.\n    In particular, calls to helpers such as ``login()`` or ``logout()`` do not affect the state that the test browser sees.\n    If you want to set up a persistent fixture (e.g. test content), you can do so before creating the test browser, but you will need to explicitly commit your changes, with::\n\n        import transaction\n        transaction.commit()\n\n\nZServer\n-------\n\nThe ZServer layers provide test fixtures suitable for testing Zope applications while using ZServer instead of a WSGI server.\nThey set up a Zope application root, install core Zope products, and manage security.\n\nZServer layers can be found in the module ``plone.testing.zserver``.\nIf you depend on this, you can use the ``[zope,zserver]`` extra when depending on ``plone.testing``.\n\nStartup\n~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zserver.STARTUP``                |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zserver.Startup``                |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zca.LAYER_CLEANUP``              |\n+------------+--------------------------------------------------+\n| Resources: | ``zodbDB``                                       |\n|            +--------------------------------------------------+\n|            | ``configurationContext``                         |\n|            +--------------------------------------------------+\n|            | ``host``                                         |\n|            +--------------------------------------------------+\n|            | ``port``                                         |\n+------------+--------------------------------------------------+\n\nThis layer sets up a Zope environment for ZServer, and is a required base for all other ZServer layers.\nYou cannot run two instances of this layer in parallel, since Zope depends on some module-global state to run, which is managed by this layer.\n\nOn set-up, the layer will configure a Zope environment with the same options as ``zope.Startup``, see there.\n\nIntegration test\n~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zserver.INTEGRATION_TESTING``    |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zserver.IntegrationTesting``     |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zserver.STARTUP``                |\n+------------+--------------------------------------------------+\n| Resources: | ``app``                                          |\n|            +--------------------------------------------------+\n|            | ``request``                                      |\n+------------+--------------------------------------------------+\n\nThis layer is intended for integration testing against the simple ``STARTUP`` fixture.\nIf you want to create your own layer with a more advanced, shared fixture, see \"Integration and functional testing with custom fixtures\" below.\n\nFor each test, it exposes the Zope application root as the resource ``app``.\nThis is wrapped in the request container, so you can do ``app.REQUEST`` to acquire a fake request, but the request is also available as the resource ``request``.\n\nA new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.\n\n    *Hint:* If you want to set up a persistent test fixture in a layer based on this one (or ``zserver.FUNCTIONAL_TESTING``), you can stack a new ``DemoStorage`` in a shadowing ``zodbDB`` resource, using the pattern described above for the ``zodb.EMPTY_ZODB`` layer.\n\n    Once you've shadowed the ``zodbDB`` resource, you can do (e.g. in your layer's ``setUp()`` method)::\n\n        ...\n        with zserver.zopeApp() as app:\n            # modify the Zope application root\n\n    The ``zserver.zopeApp()`` context manager will open a new connection to the Zope application root, accessible here as ``app``.\n    Provided the code within the ``with`` block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.\n\nFunctional testing\n~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zserver.FUNCTIONAL_TESTING``     |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zserver.FunctionalTesting``      |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zserver.STARTUP``                |\n+------------+--------------------------------------------------+\n| Resources: | ``app``                                          |\n|            +--------------------------------------------------+\n|            | ``request``                                      |\n+------------+--------------------------------------------------+\n\nIt behaves the same as ``zope.FunctionalTesting``, see there.\n\n\nIntegration and functional testing with custom fixtures\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you want to extend the ``STARTUP`` fixture for use with integration or functional testing, you should use the following pattern:\n\n* Create a layer class and a \"fixture\" base layer instance that has ``zserver.STARTUP`` (or some intermediary layer, such as ``zserver.ZSERVER_FIXTURE`` or ``zserver.FTP_SERVER_FIXTURE``, shown below) as a base.\n\n* Create \"end user\" layers by instantiating the ``zserver.IntegrationTesting`` and/or ``FunctionalTesting`` classes with this new \"fixture\" layer as a base.\n\nThis allows the same fixture to be used regardless of the \"style\" of testing, minimising the amount of set-up and tear-down.\nThe \"fixture\" layers manage the fixture as part of the *layer* lifecycle.\nThe layer class (``IntegrationTesting`` or ``FunctionalTesting``), manages the *test* lifecycle, and the test lifecycle only.\n\nFor example::\n\n    from plone.testing import Layer, zserver, zodb\n\n    class MyLayer(Layer):\n        defaultBases = (zserver.STARTUP,)\n\n        def setUp(self):\n            # Set up the fixture here\n            ...\n\n        def tearDown(self):\n            # Tear down the fixture here\n            ...\n\n    MY_FIXTURE = MyLayer()\n\n    MY_INTEGRATION_TESTING = zserver.IntegrationTesting(bases=(MY_FIXTURE,), name=\"MyFixture:Integration\")\n    MY_FUNCTIONAL_TESTING = zserver.FunctionalTesting(bases=(MY_FIXTURE,), name=\"MyFixture:Functional\")\n\n(Note that we need to give an explicit, unique name to the two layers that re-use the ``IntegrationTesting`` and ``FunctionalTesting`` classes.)\n\nIn this example, other layers could extend the \"MyLayer\" fixture by using ``MY_FIXTURE`` as a base.\nTests would use either ``MY_INTEGRATION_TESTING`` or ``MY_FUNCTIONAL_TESTING`` as appropriate.\nHowever, even if both these two layers were used, the fixture in ``MY_FIXTURE`` would only be set up once.\n\n.. note::\n\n    If you implement the ``testSetUp()`` and ``testTearDown()`` test lifecycle methods in your \"fixture\" layer (e.g. in the the ``MyLayer`` class above), they will execute before the corresponding methods from ``IntegrationTesting`` and ``FunctionalTesting``.\n    Hence, they cannot use those layers' resources (``app`` and ``request``).\n\nIt may be preferable, therefore, to have your own \"test lifecycle\" layer classes that subclass ``IntegrationTesting`` and/or ``FunctionalTesting`` and call base class methods as appropriate.\n``plone.app.testing`` takes this approach, for example.\n\n\nHTTP ZServer thread (fixture only)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zserver.ZSERVER_FIXTURE``        |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zserver.ZServer``                |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zserver.STARTUP``                |\n+------------+--------------------------------------------------+\n| Resources: | ``host``                                         |\n|            +--------------------------------------------------+\n|            | ``port``                                         |\n+------------+--------------------------------------------------+\n\nThis layer extends the ``zserver.STARTUP`` layer to start the Zope HTTP server (ZServer) in a separate thread.\nThis means the test site can be accessed through a web browser, and can thus be used with tools like `Selenium`_.\n\n.. note::\n\n    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n    Use the ``ZSERVER`` layer if you want to execute functional tests against this fixture.\n\nThe ZServer's hostname (normally ``localhost``) is available through the resource ``host``, whilst the port it is running on is available through the resource ``port``.\n\n  *Hint:* Whilst the layer is set up, you can actually access the test Zope site through a web browser.\n  The default URL will be ``http://localhost:55001``.\n\nHTTP ZServer functional testing\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zserver.ZSERVER``                |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zserver.FunctionalTesting``      |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zserver.ZSERVER_FIXTURE``        |\n+------------+--------------------------------------------------+\n| Resources: |                                                  |\n+------------+--------------------------------------------------+\n\nThis layer provides the functional testing lifecycle against the fixture set up by the ``zserver.ZSERVER_FIXTURE`` layer.\n\nYou can use this to run \"live\" functional tests against a basic Zope site.\nYou should **not** use it as a base.\nInstead, create your own \"fixture\" layer that extends ``zserver.ZSERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n\n\nFTP server thread (fixture only)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zserver.FTP_SERVER_FIXTURE``     |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zserver.FTPServer``              |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zserver.STARTUP``                |\n+------------+--------------------------------------------------+\n| Resources: | ``host``                                         |\n|            +--------------------------------------------------+\n|            | ``port``                                         |\n+------------+--------------------------------------------------+\n\nThis layer is the FTP server equivalent of the ``zserver.ZSERVER_FIXTURE`` layer.\nIt can be used to functionally test Zope FTP servers.\n\n.. note::\n\n    This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\n    Use the ``FTP_SERVER`` layer if you want to execute functional tests against this fixture.\n\n    *Hint:* Whilst the layer is set up, you can actually access the test Zope site through an FTP client.\n    The default URL will be ``ftp://localhost:55002``.\n\n.. warning::\n\n    Do not run the ``FTP_SERVER`` and ``ZSERVER`` layers concurrently in the same process.\n\nIf you need both ZServer and FTPServer running together, you can subclass the ``ZServer`` layer class (like the ``FTPServer`` layer class does) and implement the ``setUpServer()`` and ``tearDownServer()`` methods to set up and close down two servers on different ports.\nThey will then share a main loop.\n\nFTP server functional testing\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n+------------+--------------------------------------------------+\n| Layer:     | ``plone.testing.zserver.FTP_SERVER``             |\n+------------+--------------------------------------------------+\n| Class:     | ``plone.testing.zserver.FunctionalTesting``      |\n+------------+--------------------------------------------------+\n| Bases:     | ``plone.testing.zserver.FTP_SERVER_FIXTURE``     |\n+------------+--------------------------------------------------+\n| Resources: |                                                  |\n+------------+--------------------------------------------------+\n\nThis layer provides the functional testing lifecycle against the fixture set up by the ``zserver.FTP_SERVER_FIXTURE`` layer.\n\nYou can use this to run \"live\" functional tests against a basic Zope site.\nYou should **not** use it as a base.\nInstead, create your own \"fixture\" layer that extends ``zserver.FTP_SERVER_FIXTURE``, and then instantiate the ``FunctionalTesting`` class with this extended fixture layer as a base, as outlined above.\n\nHelper functions\n~~~~~~~~~~~~~~~~\n\nSeveral helper functions are available in the ``plone.testing.zserver`` module.\n\n``zopeApp(db=None, conn=Non, environ=None)``\n\n    This function can be used as a context manager for any code that requires access to the Zope application root.\n    By using it in a ``with`` block, the database will be opened, and the application root will be obtained and request-wrapped.\n    When exiting the ``with`` block, the transaction will be committed and the database properly closed, unless an exception was raised::\n\n        with zserver.zopeApp() as app:\n            # do something with app\n\n    If you want to use a specific database or database connection, pass either the ``db`` or ``conn`` arguments.\n    If the context manager opened a new connection, it will close it, but it will not close a connection passed with ``conn``.\n\n    To set keys in the (fake) request environment, pass a dictionary of environment values as ``environ``.\n\n    Note that ``zopeApp()`` should *not* normally be used in tests or test set-up/tear-down, because the ``INTEGRATOIN_TEST`` and ``FUNCTIONAL_TESTING`` layers both manage the application root (as the ``app`` resource) and close it for you.\n    It is very useful in layer setup, however.\n\nThe other helper functions defined in ``plone.testing.zope`` can also be used in a ZServer context but together with the ZServer layers.\n\n.. _zope.testing: https://pypi.org/project/zope.testing/\n.. _zope.testbrowser: https://pypi.org/project/zope.testbrowser\n.. _zope.component: https://pypi.org/project/zope.component\n.. _zope.publisher: https://pypi.org/project/zope.publisher\n.. _plone.app.testing: https://pypi.org/project/plone.app.testing\n.. _zc.recipe.testrunner: https://pypi.org/project/zc.recipe.testrunner\n.. _coverage: https://pypi.org/project/coverage\n.. _Cobertura: https://wiki.jenkins.io/display/JENKINS/Cobertura+Plugin\n.. _Jenkins: https://jenkins.io\n.. _unittest: http://doc.python.org/library/unittest.html\n.. _doctest: http://docs.python.org/dev/library/doctest.html\n.. _Selenium: http://seleniumhq.org/\n\n\nChangelog\n=========\n\n.. You should *NOT* be adding new change log entries to this file.\n   You should create a file in the news directory instead.\n   For helpful instructions, please see:\n   https://github.com/plone/plone.releaser/blob/master/ADD-A-NEWS-ITEM.rst\n\n.. towncrier release notes start\n\n8.0.0 (2020-04-21)\n------------------\n\nBreaking changes:\n\n\n- Drop support for Python 3.4 and 3.5.\n  Remove \"z2\" extra.\n  [jensens] (#72)\n\n\nNew features:\n\n\n- Update links for further information about `testing`.\n  [jugmac00] (#71)\n\n\nBug fixes:\n\n\n- Fix tests when using zope.testrunner internals since its version 5.1.\n  [jensens] (#72)\n\n\n7.0.3 (2019-12-10)\n------------------\n\nBug fixes:\n\n\n- Fix issue with test-setup when using ZServer 4.0.2.\n  [pbauer] (#69)\n\n\n7.0.2 (2019-07-06)\n------------------\n\nBug fixes:\n\n\n- Remove the ``ZOPETESTCASEALERT`` as it imports from ZopeTestCase and has side effects.\n  Fixes #64.\n  [thet] (#67)\n\n\n7.0.1 (2019-03-03)\n------------------\n\nBug fixes:\n\n\n- Fixed test for 'Connection refused' which could be 'Connection reset'.\n  [maurits] (#59)\n\n\n7.0.0 (2018-10-17)\n------------------\n\nBreaking changes:\n\n- ``plone.testing.z2`` is now a BBB shim for ``plone.testing.zope``,\n  thus it switches the tests to use WSGI.\n  If you absolutely want to keep using ZServer please import from ``plone.testing.zserver``.\n\n- ``plone.testing.z2`` now only contains a no-op FTPServer layer because FTP is not supported by WSGI.\n  If you really need it, import it from ``plone.testing.zserver`` but this will not work on Python 3.\n\n- Default to picking a dynamical port for ZServer layers instead of a static\n  default port.\n  [Rotonen]\n\nNew features:\n\n- Make ``ZServer`` an optional dependency.\n\n- Add support for Python 3.6.\n  [rudaporto, icemac]\n\nBug fixes:\n\n- Explicitly depend on ZServer on the z2 extra.\n  [Rotonen]\n\n\n6.1.0 (2018-10-05)\n------------------\n\nBreaking changes:\n\n- Default to picking a dynamical port for ZServer layers instead of a static\n  default port.\n  [Rotonen]\n\nBug fixes:\n\n- Pinned ZODB to < 5.4.0 for testing to avoid flaky doctest layer teardowns.\n  [Rotonen]\n\n- Loosened doctest assertions to keep up with Zope-side changes.\n  [Rotonen]\n\n- Fix most of the code smells Jenkins complains about.\n\n- Fix the Zope exception hook when using the ZServer layer.\n\n- Fix teardown of the ``plone.testing.security.Checkers`` layer.\n  It was not properly restoring zope.security's ``_checkers`` dict.\n\n\n6.0.0 (2018-02-05)\n------------------\n\n- Breaking changes:\n\n  + Only support ``Zope >= 4``, no longer support ``Zope2``.\n  + Drop support for Python 2.6.\n\n- No longer use deprecated import for getSite/setSite.\n  [jensens]\n\n- Update code to follow Plone styleguide.\n  [gforcada]\n\n\n5.1.1 (2017-04-19)\n------------------\n\n- Do not break on import of ``plone.testing.z2`` when using `zope.testbrowser` >= 5.0 which no longer depends on `mechanize`.\n\n\n5.1 (2017-04-13)\n----------------\n\n- Fix for ZODB 5: Abort transaction before DB close.\n  [jensens, jimfulton]\n\n- Remove BBB code and imports for Zope < 2.13.\n  [thet]\n\n- Fix issue, which prevented using layered-helper on Python 3.\n  [datakurre]\n\n- Fix ``.z2.Startup.setUpZCML()`` to be compatible with Zope >= 4.0a2.\n  [icemac]\n\n- Fix version pins on the package itself to be able to run the tests.\n  [gforcada]\n\n5.0.0 (2016-02-19)\n------------------\n\nRerelease of 4.2.0 as 5.0.0.\n\nThe version 4.2.0 had changed error handling in the public api, causing exceptions where before everything continued to work.\n\n\n4.2.0 (2016-02-18)\n------------------\n\nNew:\n\n- Refuse to work if user breaks test isolation.\n  [do3cc]\n- Check that tests don't run together with ZopeTestCase\n  [do3cc]\n\nFixes:\n\n- Fix tests for Zope 4, where the app root Control_Panel is not available anymore.\n  [thet]\n\n\n4.1.0 (2016-01-08)\n------------------\n\nFixes:\n\n- Rename all txt doctest files to rst. Reformat doctests.\n  [thet]\n\n- PEP 8.\n  [thet]\n\n- Depend on zope.testrunner, which was moved out from zope.testing.testrunner.\n  [thet]\n\n- Add support for Zope 4.\n  [thet]\n\n\n4.0.15 (2015-08-14)\n-------------------\n\n- Prevent exception masking in finally clause of zopeApp context.\n  [do3cc]\n\n\n4.0.14 (2015-07-29)\n-------------------\n\n- Rerelease for clarity due to double release of 4.0.13.\n  [maurits]\n\n- Added ``multiinit``-parameter to z2.installProduct to allow multiple initialize methods for a package\n  [tomgross]\n\n\n4.0.13 (2015-03-13)\n-------------------\n\n- Really fix not to depend on unittest2.\n  [icemac]\n\n- Add tox.ini\n  [icemac]\n\n\n4.0.12 (2014-09-07)\n-------------------\n\n- Fixed AttributeError when importing ``plone.testing.z2`` if ``zope.testbrowser`` 4.x is used but not ``zope.app.testing``.\n  [icemac]\n\n- Broke dependency on `unittest2` for Python 2.7+ as all features of `unittest2` are integrated in `unittest` there.\n  [icemac]\n\n\n4.0.11 (2014-02-22)\n-------------------\n\n- Fix z2.txt doctest for FTP_SERVER.\n  [timo]\n\n\n4.0.10 (2014-02-11)\n-------------------\n\n- Read 'FTPSERVER_HOST' and 'FTPSERVER_PORT' from the environment variables if possible.\n  This allows us to run tests in parallel on CI servers.\n  [timo]\n\n\n4.0.9 (2014-01-28)\n------------------\n\n- Replace deprecated Zope2VocabularyRegistry import.\n  [timo]\n\n\n4.0.8 (2013-03-05)\n------------------\n\n- Factor test request creation out of addRequestContainer into makeTestRequest.\n  [davisagli]\n\n\n4.0.7 (2012-12-09)\n------------------\n\n- Fix quoting of urls by the testbrowser.\n  [do3cc]\n\n\n4.0.6 (2012-10-15)\n------------------\n\n- Update manifest.in to include content in src directory.\n  [esteele]\n\n\n4.0.5 (2012-10-15)\n------------------\n\n- Fixed an issue where a query string would be unquoted twice;\n  once while setting up the HTTP request and once in the handler (the publisher).\n  [malthe]\n\n\n4.0.4 (2012-08-04)\n------------------\n\n- Fixed the cache reset code.\n  In some situations the function does not have any defaults,\n  so we shouldn't try to clear out the app reference.\n  [malthe]\n\n\n4.0.3 (2011-11-24)\n------------------\n\n- Fixed class names in documentation to match code.\n  [icemac]\n\n\n4.0.2 (2011-08-31)\n------------------\n\n- The defaults of the ``ZPublisher.Publish.get_module_info`` function cache\n  a reference to the app, so make sure that gets reset when tearing down the\n  app. This fixes a problem where the testbrowser in the second functional\n  layer to be set up accessed the database from the first functional layer.\n  [davisagli]\n\n\n4.0.1 - 2011-05-20\n------------------\n\n- Moved readme file containing tests into the package, so tests can be run from\n  released source distributions. Closes http://dev.plone.org/plone/ticket/11821.\n  [hannosch]\n\n- Relicense under BSD license.\n  See http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy\n  [davisagli]\n\n\n4.0 - 2011-05-13\n----------------\n\n- Release 4.0 Final.\n  [esteele]\n\n- Add MANIFEST.in.\n  [WouterVH]\n\n\n4.0a6 - 2011-04-06\n------------------\n\n- Fixed Browser cookies retrieval with Zope 2.13.\n  [vincentfretin]\n\n- Add ``ZCMLSandbox`` layer to load a ZCML file; replaces ``setUpZcmlFiles`` and\n  ``tearDownZcmlFiles`` helper functions.\n  [gotcha]\n\n\n4.0a5 - 2011-03-02\n------------------\n\n- Handle test failures due to userFolderAddUser returning the user object in\n  newer versions of Zope.\n  [esteele]\n\n- Add ``setUpZcmlFiles`` and ``tearDownZcmlFiles`` helpers to enable loading\n  of ZCML files without too much boilerplate.\n  [gotcha]\n\n- Add some logging.\n  [gotcha]\n\n- Add the ``[security]`` extra, to provide tear-down of security checkers.\n  [optilude]\n\n- Let the ``IntegrationTesting`` and ``FunctionalTesting`` lifecycle layers\n  set up request ``PARENTS`` and, if present, wire up\n  ``zope.globalrequest``.\n  [optilude]\n\n- Make the test browser support IStreamIterators\n  [optilude]\n\n\n4.0a4 - 2011-01-11\n------------------\n\n- Make sure ZCML doesn't load during App startup in Zope 2.13.\n  [davisagli]\n\n\n4.0a3 - 2010-12-14\n------------------\n\n- Ignore the `testinghome` configuration setting if present.\n  [stefan]\n\n- Use the new API for getting the packages_to_initialize list in Zope 2.13.\n  [davisagli]\n\n- De-duplicate _register_monkies and _meta_type_regs in the correct module on\n  teardown of the Startup layer in Zope 2.13.\n  [davisagli]\n\n- Allow doctest suites from `zope.testing` to work with `plone.testing.layer.layered`.\n  Previously, only doctest suites from the stdlib would see the `layer` global.\n  [nouri]\n\n- Changed documentation to advertise the `coverage` library for running\n  coverage tests instead of the built-in `zope.testing` support. This also\n  avoids using `z3c.coverage`. The coverage tests now run at the same speed\n  as a normal test run, making it more likely to get executed frequently.\n  [hannosch]\n\n- Correct license to GPL version 2 only.\n  [hannosch]\n\n- Fix some user id vs name confusion.\n  [rossp]\n\n- Add the option to specify ZServer host and port through environment\n  variables - ZSERVER_HOST and ZSERVER_PORT).\n  [esteele]\n\n\n1.0a2 - 2010-09-05\n------------------\n\n- Fix a problem that would cause ``<meta:redefinePermission />`` to break.\n  In particular fixes the use of the ``zope2.Public`` permission.\n  [optilude]\n\n- Set the security implementation to \"Python\" for easier debugging during\n  the z2.STARTUP layer.\n  [optilude]\n\n- Initialize Five in the z2.Startup layer, pushing a Zope2VocabularyRegistry on\n  layer set-up and restoring the previous one upon tear-down.\n  [dukebody]\n\n\n1.0a1 - 2010-08-01\n------------------\n\n- Initial release\n\n\nDetailed documentation\n======================\n\nLayer base class\n----------------\n\nThis package provides a layer base class which can be used by the test runner.\nIt is available as a convenience import from the package root.::\n\n    >>> from plone.testing import Layer\n\nA layer may be instantiated directly, though in this case the ``name`` argument is required (see below).::\n\n    >>> NULL_LAYER = Layer(name=\"Null layer\")\n\nThis is not very useful on its own.\nIt has an empty list of bases, and each of the layer lifecycle methods does nothing.::\n\n    >>> NULL_LAYER.__bases__\n    ()\n    >>> NULL_LAYER.__name__\n    'Null layer'\n    >>> NULL_LAYER.__module__\n    'plone.testing.layer'\n\n    >>> NULL_LAYER.setUp()\n    >>> NULL_LAYER.testSetUp()\n    >>> NULL_LAYER.tearDown()\n    >>> NULL_LAYER.testTearDown()\n\nJust about the only reason to use this directly (i.e. not as a base class) is to group together other layers.::\n\n    >>> SIMPLE_LAYER = Layer(bases=(NULL_LAYER,), name=\"Simple layer\", module='plone.testing.tests')\n\nHere, we've also set the module name directly.\nThe default for all layers is to take the module name from the stack frame where the layer was instantiated.\nIn doctests, that doesn't work, though, so we fall back on the module name of the layer class.\nThe two are often the same, of course.\n\nThis layer now has the bases, name and module we set:::\n\n    >>> SIMPLE_LAYER.__bases__\n    (<Layer 'plone.testing.layer.Null layer'>,)\n\n    >>> SIMPLE_LAYER.__name__\n    'Simple layer'\n\n    >>> SIMPLE_LAYER.__module__\n    'plone.testing.tests'\n\nThe ``name`` argument is required when using ``Layer`` directly (but not when using a subclass):::\n\n    >>> Layer((SIMPLE_LAYER,))\n    Traceback (most recent call last):\n    ...\n    ValueError: The `name` argument is required when instantiating `Layer` directly\n\n    >>> class NullLayer(Layer):\n    ...     pass\n    >>> NullLayer()\n    <Layer 'builtins.NullLayer'>\n\nUsing ``Layer`` as a base class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe usual pattern is to use ``Layer`` as a base class for a custom layer.\nThis can then override the lifecycle methods as appropriate, as well as set a default list of bases.::\n\n    >>> class BaseLayer(Layer):\n    ...\n    ...     def setUp(self):\n    ...         print(\"Setting up base layer\")\n    ...\n    ...     def tearDown(self):\n    ...         print(\"Tearing down base layer\")\n\n    >>> BASE_LAYER = BaseLayer()\n\nThe layer name and module are taken from the class.::\n\n    >>> BASE_LAYER.__bases__\n    ()\n    >>> BASE_LAYER.__name__\n    'BaseLayer'\n    >>> BASE_LAYER.__module__\n    'builtins'\n\nWe can now create a new layer that has this one as a base.\nWe can do this in the instance constructor, as shown above, but the most common pattern is to set the default bases in the class body, using the variable ``defaultBases``.\n\nWe'll also set the default name explicitly here by passing a name to the the super-constructor.\nThis is mostly cosmetic, but may be desirable if the class name would be misleading in the test runner output.::\n\n    >>> class ChildLayer(Layer):\n    ...     defaultBases = (BASE_LAYER,)\n    ...\n    ...     def __init__(self, bases=None, name='Child layer', module=None):\n    ...         super(ChildLayer, self).__init__(bases, name, module)\n    ...\n    ...     def setUp(self):\n    ...         print(\"Setting up child layer\")\n    ...\n    ...     def tearDown(self):\n    ...         print(\"Tearing down child layer\")\n\n    >>> CHILD_LAYER = ChildLayer()\n\nNotice how the bases have now been set using the value in ``defaultBases``.::\n\n    >>> CHILD_LAYER.__bases__\n    (<Layer 'builtins.BaseLayer'>,)\n    >>> CHILD_LAYER.__name__\n    'Child layer'\n    >>> CHILD_LAYER.__module__\n    'builtins'\n\nOverriding the default list of bases\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWe can override the list of bases on a per-instance basis.\nThis may be dangerous, i.e.\nthe layer is likely to expect that its bases are set up.\nSometimes, it may be useful to inject a new base, however, especially when re-using layers from other packages.\n\nThe new list of bases is passed to the constructor.\nWhen creating a second instance of a layer (most layers are global singletons created only once), it's useful to give the new instance a unique name, too.::\n\n    >>> NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name='New child')\n\n    >>> NEW_CHILD_LAYER.__bases__\n    (<Layer 'plone.testing.tests.Simple layer'>, <Layer 'builtins.BaseLayer'>)\n    >>> NEW_CHILD_LAYER.__name__\n    'New child'\n    >>> NEW_CHILD_LAYER.__module__\n    'builtins'\n\nInconsistent bases\n~~~~~~~~~~~~~~~~~~\n\nLayer bases are maintained in an order that is semantically equivalent to the \"method resolution order\" Python maintains for base classes.\nWe can get this from the ``baseResolutionOrder`` attribute:::\n\n    >>> CHILD_LAYER.baseResolutionOrder\n    (<Layer 'builtins.Child layer'>, <Layer 'builtins.BaseLayer'>)\n\n    >>> NEW_CHILD_LAYER.baseResolutionOrder\n    (<Layer 'builtins.New child'>, <Layer 'plone.testing.tests.Simple layer'>,\n     <Layer 'plone.testing.layer.Null layer'>,\n     <Layer 'builtins.BaseLayer'>)\n\nAs with Python classes, it is possible to construct an invalid set of bases.\nIn this case, layer instantiation will fail.::\n\n    >>> INCONSISTENT_BASE1 = Layer(name=\"Inconsistent 1\")\n    >>> INCONSISTENT_BASE2 = Layer((INCONSISTENT_BASE1,), name=\"Inconsistent 1\")\n    >>> INCONSISTENT_BASE3 = Layer((INCONSISTENT_BASE1, INCONSISTENT_BASE2,), name=\"Inconsistent 1\")\n    Traceback (most recent call last):\n    ...\n    TypeError: Inconsistent layer hierarchy!\n\nUsing the resource manager\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nLayers are also resource managers.\nResources can be set, retrieved and deleted using dictionary syntax.\nResources in base layers are available in child layers.\nWhen an item is set on a child layer, it shadows any items with the same key in any base layer (until it is deleted), but the original item still exists.\n\nLet's create a somewhat complex hierarchy of layers that all set resources under a key ``'foo'`` in their ``setUp()`` methods.::\n\n    >>> class Layer1(Layer):\n    ...     def setUp(self):\n    ...         self['foo'] = 1\n    ...     def tearDown(self):\n    ...         del self['foo']\n    >>> LAYER1 = Layer1()\n\n    >>> class Layer2(Layer):\n    ...     defaultBases = (LAYER1,)\n    ...     def setUp(self):\n    ...         self['foo'] = 2\n    ...     def tearDown(self):\n    ...         del self['foo']\n    >>> LAYER2 = Layer2()\n\n    >>> class Layer3(Layer):\n    ...     def setUp(self):\n    ...         self['foo'] = 3\n    ...     def tearDown(self):\n    ...         del self['foo']\n    >>> LAYER3 = Layer3()\n\n    >>> class Layer4(Layer):\n    ...     defaultBases = (LAYER2, LAYER3,)\n    ...     def setUp(self):\n    ...         self['foo'] = 4\n    ...     def tearDown(self):\n    ...         del self['foo']\n    >>> LAYER4 = Layer4()\n\n    **Important:** Resources that are created in ``setUp()`` must be deleted in ``tearDown()``.\n    Similarly, resources created in ``testSetUp()`` must be deleted in ``testTearDown()``.\n    This ensures resources are properly stacked and do not leak between layers.\n\nIf a test was using ``LAYER4``, the test runner would call each setup step in turn, starting with the \"deepest\" layer.\nWe'll simulate that here, so that each of the resources is created.::\n\n    >>> LAYER1.setUp()\n    >>> LAYER2.setUp()\n    >>> LAYER3.setUp()\n    >>> LAYER4.setUp()\n\nThe layers are ordered in a known \"resource resolution order\", which is used to determine in which order the layers shadow one another.\nThis is based on the same algorithm as Python's method resolution order.::\n\n    >>> LAYER4.baseResolutionOrder\n    (<Layer 'builtins.Layer4'>,\n     <Layer 'builtins.Layer2'>,\n     <Layer 'builtins.Layer1'>,\n     <Layer 'builtins.Layer3'>)\n\nWhen fetching and item from a layer, it will be obtained according to the resource resolution order.::\n\n    >>> LAYER4['foo']\n    4\n\nThis is not terribly interesting, since ``LAYER4`` has the resource ``'foo'`` set directly.\nLet's tear down the layer (which deletes the resource) and see what happens.::\n\n    >>> LAYER4.tearDown()\n    >>> LAYER4['foo']\n    2\n\nWe can continue up the chain:::\n\n    >>> LAYER2.tearDown()\n    >>> LAYER4['foo']\n    1\n\n    >>> LAYER1.tearDown()\n    >>> LAYER4['foo']\n    3\n\nOnce we've deleted the last key, we'll get a ``KeyError``:::\n\n    >>> LAYER3.tearDown()\n    >>> LAYER4['foo']\n    Traceback (most recent call last):\n    ...\n    KeyError: 'foo'\n\nTo guard against this, we can use the ``get()`` method.::\n\n    >>> LAYER4.get('foo', -1)\n    -1\n\nWe can also test with 'in':::\n\n    >>> 'foo' in LAYER4\n    False\n\nTo illustrate that this indeed works, let's set the resource back on one of the bases.::\n\n    >>> LAYER3['foo'] = 10\n    >>> LAYER4.get('foo', -1)\n    10\n\nLet's now consider a special case: a base layer sets up a resource in layer setup, and uses it in test setup.\nA child layer then shadows this resource in its own layer setup method.\nIn this case, we want the base layer's ``testSetUp()`` to use the shadowed version that the child provided.\n\n(This is similar to how instance variables work: a base class may set an attribute on ``self`` and use it in a method.\nIf a subclass then sets the same attribute to a different value and the base class method is called on an instance of the subclass, the base class attribute is used).\n\n    *Hint:* If you definitely need to access the \"original\" resource in your ``testSetUp()``/``testTearDown()`` methods, you can store a reference to the resource as a layer instance variable::\n\n        self.someResource = self['someResource'] = SomeResource()\n\n    ``self.someResource`` will now be the exact resource created here, whereas ``self['someResource']`` will retain the layer shadowing semantics.\n    In most cases, you probably *don't* want to do this, allowing child layers to supply overridden versions of resources as appropriate.\n\nFirst, we'll create some base layers.\nWe want to demonstrate having two \"branches\" of bases that both happen to define the same resource.::\n\n    >>> class ResourceBaseLayer1(Layer):\n    ...     def setUp(self):\n    ...         self['resource'] = \"Base 1\"\n    ...     def testSetUp(self):\n    ...         print(self['resource'])\n    ...     def tearDown(self):\n    ...         del self['resource']\n\n    >>> RESOURCE_BASE_LAYER1 = ResourceBaseLayer1()\n\n    >>> class ResourceBaseLayer2(Layer):\n    ...     defaultBases = (RESOURCE_BASE_LAYER1,)\n    ...     def testSetUp(self):\n    ...         print(self['resource'])\n\n    >>> RESOURCE_BASE_LAYER2 = ResourceBaseLayer2()\n\n    >>> class ResourceBaseLayer3(Layer):\n    ...     def setUp(self):\n    ...         self['resource'] = \"Base 3\"\n    ...     def testSetUp(self):\n    ...         print(self['resource'])\n    ...     def tearDown(self):\n    ...         del self['resource']\n\n    >>> RESOURCE_BASE_LAYER3 = ResourceBaseLayer3()\n\nWe'll then create the child layer that overrides this resource.::\n\n    >>> class ResourceChildLayer(Layer):\n    ...     defaultBases = (RESOURCE_BASE_LAYER2, RESOURCE_BASE_LAYER3)\n    ...     def setUp(self):\n    ...         self['resource'] = \"Child\"\n    ...     def testSetUp(self):\n    ...         print(self['resource'])\n    ...     def tearDown(self):\n    ...         del self['resource']\n\n    >>> RESOURCE_CHILD_LAYER = ResourceChildLayer()\n\nWe'll first set up the base layers on their own and simulate two tests.\n\nA test with RESOURCE_BASE_LAYER1 only would look like this:::\n\n    >>> RESOURCE_BASE_LAYER1.setUp()\n\n    >>> RESOURCE_BASE_LAYER1.testSetUp()\n    Base 1\n    >>> RESOURCE_BASE_LAYER1.testTearDown()\n\n    >>> RESOURCE_BASE_LAYER1.tearDown()\n\nA test with RESOURCE_BASE_LAYER2 would look like this:::\n\n    >>> RESOURCE_BASE_LAYER1.setUp()\n    >>> RESOURCE_BASE_LAYER2.setUp()\n\n    >>> RESOURCE_BASE_LAYER1.testSetUp()\n    Base 1\n    >>> RESOURCE_BASE_LAYER2.testSetUp()\n    Base 1\n    >>> RESOURCE_BASE_LAYER2.testTearDown()\n    >>> RESOURCE_BASE_LAYER1.testTearDown()\n\n    >>> RESOURCE_BASE_LAYER2.tearDown()\n    >>> RESOURCE_BASE_LAYER1.tearDown()\n\nA test with RESOURCE_BASE_LAYER3 only would look like this:::\n\n    >>> RESOURCE_BASE_LAYER3.setUp()\n\n    >>> RESOURCE_BASE_LAYER3.testSetUp()\n    Base 3\n    >>> RESOURCE_BASE_LAYER3.testTearDown()\n\n    >>> RESOURCE_BASE_LAYER3.tearDown()\n\nNow let's set up the child layer and simulate another test.\nWe should now be using the shadowed resource.::\n\n    >>> RESOURCE_BASE_LAYER1.setUp()\n    >>> RESOURCE_BASE_LAYER2.setUp()\n    >>> RESOURCE_BASE_LAYER3.setUp()\n    >>> RESOURCE_CHILD_LAYER.setUp()\n\n    >>> RESOURCE_BASE_LAYER1.testSetUp()\n    Child\n    >>> RESOURCE_BASE_LAYER2.testSetUp()\n    Child\n    >>> RESOURCE_BASE_LAYER3.testSetUp()\n    Child\n    >>> RESOURCE_CHILD_LAYER.testSetUp()\n    Child\n\n    >>> RESOURCE_CHILD_LAYER.testTearDown()\n    >>> RESOURCE_BASE_LAYER3.testTearDown()\n    >>> RESOURCE_BASE_LAYER2.testTearDown()\n    >>> RESOURCE_BASE_LAYER1.testTearDown()\n\nFinally, we'll tear down the child layer again and simulate another test.\nwe should have the original resources back.\nNote that the first and third layers no longer share a resource, since they don't have a common ancestor.::\n\n    >>> RESOURCE_CHILD_LAYER.tearDown()\n\n    >>> RESOURCE_BASE_LAYER1.testSetUp()\n    Base 1\n    >>> RESOURCE_BASE_LAYER2.testSetUp()\n    Base 1\n    >>> RESOURCE_BASE_LAYER2.testTearDown()\n    >>> RESOURCE_BASE_LAYER1.testTearDown()\n\n    >>> RESOURCE_BASE_LAYER3.testSetUp()\n    Base 3\n    >>> RESOURCE_BASE_LAYER3.testTearDown()\n\nFinally, we'll tear down the remaining layers..::\n\n    >>> RESOURCE_BASE_LAYER3.tearDown()\n    >>> RESOURCE_BASE_LAYER2.tearDown()\n    >>> RESOURCE_BASE_LAYER1.tearDown()\n\nAsymmetric deletion\n+++++++++++++++++++\n\nIt is an error to create or shadow a resource in a set-up lifecycle method and not delete it again in the tear-down.\nIt is also an error to delete a resource that was not explicitly created.\nThese two layers break those roles:::\n\n    >>> class BadLayer1(Layer):\n    ...     def setUp(self):\n    ...         pass\n    ...     def tearDown(self):\n    ...         del self['foo']\n    >>> BAD_LAYER1 = BadLayer1()\n\n    >>> class BadLayer2(Layer):\n    ...     defaultBases = (BAD_LAYER1,)\n    ...     def setUp(self):\n    ...         self['foo'] = 1\n    ...         self['bar'] = 2\n    >>> BAD_LAYER2 = BadLayer2()\n\nLet's simulate a test that uses ``BAD_LAYER2``:::\n\n    >>> BAD_LAYER1.setUp()\n    >>> BAD_LAYER2.setUp()\n\n    >>> BAD_LAYER1.testSetUp()\n    >>> BAD_LAYER2.testSetUp()\n\n    >>> BAD_LAYER2.testTearDown()\n    >>> BAD_LAYER1.testTearDown()\n\n    >>> BAD_LAYER2.tearDown()\n    >>> BAD_LAYER1.tearDown()\n    Traceback (most recent call last):\n    ...\n    KeyError: 'foo'\n\nHere, we've got an error in the base layer.\nThis is because the resource is actually associated with the layer that first created it, in this case ``BASE_LAYER2``.\nThis one remains intact and orphaned:::\n\n    >>> 'foo' in BAD_LAYER2._resources\n    True\n    >>> 'bar' in BAD_LAYER2._resources\n    True\n\nDoctest layer helper\n~~~~~~~~~~~~~~~~~~~~\n\nThe ``doctest`` module is not aware of ``zope.testing``'s layers concept.\nTherefore, the syntax for creating a doctest with a layer and adding it to a test suite is somewhat contrived: the test suite has to be created first, and then the layer attribute set on it:::\n\n    >>> class DoctestLayer(Layer):\n    ...     pass\n    >>> DOCTEST_LAYER = DoctestLayer()\n\n    >>> import unittest\n    >>> import doctest\n\n    >>> def test_suite():\n    ...     suite = unittest.TestSuite()\n    ...     layerDoctest = doctest.DocFileSuite('layer.rst', package='plone.testing')\n    ...     layerDoctest.layer = DOCTEST_LAYER\n    ...     suite.addTest(layerDoctest)\n    ...     return suite\n\n    >>> suite = test_suite()\n    >>> tests = list(suite)\n    >>> len(tests)\n    1\n    >>> tests[0].layer is DOCTEST_LAYER\n    True\n\n\nTo make this a little easier - especially when setting up multiple tests - a helper function called ``layered`` is provided:::\n\n    >>> from plone.testing import layered\n\n    >>> def test_suite():\n    ...     suite = unittest.TestSuite()\n    ...     suite.addTests([\n    ...         layered(doctest.DocFileSuite('layer.rst', package='plone.testing'), layer=DOCTEST_LAYER),\n    ...         # repeat with more suites if necessary\n    ...     ])\n    ...     return suite\n\nThis does the same as the sample above.::\n\n    >>> suite = test_suite()\n    >>> tests = list(suite)\n    >>> len(tests)\n    1\n    >>> tests[0].layer is DOCTEST_LAYER\n    True\n\nIn addition, a 'layer' glob is added to each test in the suite.\nThis allows the test to access layer resources.::\n\n    >>> len(list(tests[0]))\n    1\n    >>> list(tests[0])[0]._dt_test.globs['layer'] is DOCTEST_LAYER\n    True\n\n\nZope Component Architecture layers\n----------------------------------\n\nThe ZCA layers are found in the module ``plone.testing.zca``:::\n\n    >>> from plone.testing import zca\n\nFor testing, we need a testrunner:::\n\n    >>> from zope.testrunner import runner\n\nUnit testing\n~~~~~~~~~~~~\n\nThe ``UNIT_TESTING`` layer is used to set up a clean component registry between each test.\nIt uses ``zope.testing.cleanup`` to clean up all global state.\n\nIt has no bases:::\n\n    >>> \"%s.%s\" % (zca.UNIT_TESTING.__module__, zca.UNIT_TESTING.__name__,)\n    'plone.testing.zca.UnitTesting'\n\n    >>> zca.UNIT_TESTING.__bases__\n    ()\n\nThe component registry is cleaned up between each test.::\n\n    >>> from zope.interface import Interface\n    >>> from zope.component import provideUtility\n\n    >>> class DummyUtility(object):\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...     def __repr__(self):\n    ...         return \"<%s>\" % self.name\n\n    >>> provideUtility(DummyUtility(\"Dummy\"), provides=Interface, name=\"test-dummy\")\n\n    >>> from zope.component import queryUtility\n    >>> queryUtility(Interface, name=\"test-dummy\")\n    <Dummy>\n\nLayer setup does nothing.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zca.UNIT_TESTING, setupLayers)\n    Set up plone.testing.zca.UnitTesting in ... seconds.\n\nLet's now simulate a test.\nBefore any test setup has happened, our previously registered utility is still there.::\n\n    >>> queryUtility(Interface, name=\"test-dummy\")\n    <Dummy>\n\nOn test setup, it disappears.::\n\n    >>> zca.UNIT_TESTING.testSetUp()\n\n    >>> queryUtility(Interface, name=\"test-dummy\") is None\n    True\n\nThe test would now execute. It may register some components.::\n\n    >>> provideUtility(DummyUtility(\"Dummy2\"), provides=Interface, name=\"test-dummy\")\n    >>> queryUtility(Interface, name=\"test-dummy\")\n    <Dummy2>\n\nOn test tear-down, this disappears.::\n\n    >>> zca.UNIT_TESTING.testTearDown()\n\n    >>> queryUtility(Interface, name=\"test-dummy\") is None\n    True\n\nLayer tear-down does nothing.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zca.UnitTesting in ... seconds.\n\nEvent testing\n~~~~~~~~~~~~~\n\nThe ``EVENT_TESTING`` layer extends the ``UNIT_TESTING`` layer to add the necessary registrations for ``zope.component.eventtesting`` to work.::\n\n    >>> \"%s.%s\" % (zca.EVENT_TESTING.__module__, zca.EVENT_TESTING.__name__,)\n    'plone.testing.zca.EventTesting'\n\n    >>> zca.EVENT_TESTING.__bases__\n    (<Layer 'plone.testing.zca.UnitTesting'>,)\n\nBefore the test, the component registry is empty and ``getEvents()`` returns nothing, even if an event is fired.::\n\n    >>> from zope.component.eventtesting import getEvents\n\n    >>> class DummyEvent(object):\n    ...     def __repr__(self):\n    ...         return \"<Dummy event>\"\n\n    >>> from zope.event import notify\n    >>> notify(DummyEvent())\n\n    >>> getEvents()\n    []\n\nLayer setup does nothing.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zca.EVENT_TESTING, setupLayers)\n    Set up plone.testing.zca.UnitTesting in ... seconds.\n    Set up plone.testing.zca.EventTesting in ... seconds.\n\nLet's now simulate a test. On test setup, the event testing list is emptied.::\n\n    >>> zca.UNIT_TESTING.testSetUp()\n    >>> zca.EVENT_TESTING.testSetUp()\n\n    >>> getEvents()\n    []\n\nThe test would now execute.\nIt may fire some events, which would show up in the event testing list.::\n\n    >>> notify(DummyEvent())\n    >>> getEvents()\n    [<Dummy event>]\n\nOn test tear-down, the list is emptied again:::\n\n    >>> zca.EVENT_TESTING.testTearDown()\n    >>> zca.UNIT_TESTING.testTearDown()\n\n    >>> getEvents()\n    []\n\nLayer tear-down does nothing.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zca.EventTesting in ... seconds.\n    Tear down plone.testing.zca.UnitTesting in ... seconds.\n\nLayer cleanup\n~~~~~~~~~~~~~\n\nThe ``LAYER_CLEANUP`` layer is used to set up a clean component registry at the set-up and tear-down of a layer.\nIt uses ``zope.testing.cleanup`` to clean up all global state.\n\nIt has no bases:::\n\n    >>> \"%s.%s\" % (zca.LAYER_CLEANUP.__module__, zca.LAYER_CLEANUP.__name__,)\n    'plone.testing.zca.LayerCleanup'\n\n    >>> zca.LAYER_CLEANUP.__bases__\n    ()\n\nThe component registry is cleaned up on layer set-up and tear-down (but not between tests).::\n\n    >>> from zope.interface import Interface\n    >>> from zope.component import provideUtility\n\n    >>> class DummyUtility(object):\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...     def __repr__(self):\n    ...         return \"<%s>\" % self.name\n\n    >>> provideUtility(DummyUtility(\"Dummy\"), provides=Interface, name=\"test-dummy\")\n\n    >>> from zope.component import queryUtility\n    >>> queryUtility(Interface, name=\"test-dummy\")\n    <Dummy>\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zca.LAYER_CLEANUP, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n\n    >>> queryUtility(Interface, name=\"test-dummy\") is None\n    True\n\nA sub-layer may register additional components:::\n\n    >>> provideUtility(DummyUtility(\"Dummy2\"), provides=Interface, name=\"test-dummy2\")\n\nLet's now simulate a test. Test setup and tear-down does nothing.::\n\n    >>> zca.LAYER_CLEANUP.testSetUp()\n\n    >>> queryUtility(Interface, name=\"test-dummy\") is None\n    True\n    >>> queryUtility(Interface, name=\"test-dummy2\")\n    <Dummy2>\n\n    >>> zca.LAYER_CLEANUP.testTearDown()\n\n    >>> queryUtility(Interface, name=\"test-dummy\") is None\n    True\n    >>> queryUtility(Interface, name=\"test-dummy2\")\n    <Dummy2>\n\nOn tear-down, the registry is cleaned again.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\n    >>> queryUtility(Interface, name=\"test-dummy\") is None\n    True\n    >>> queryUtility(Interface, name=\"test-dummy2\") is None\n    True\n\nBasic ZCML directives\n~~~~~~~~~~~~~~~~~~~~~\n\nThe ``ZCML_DIRECTIVES`` layer creates a ZCML configuration context with the basic ``zope.component`` directives available.\nIt extends the ``LAYER_CLEANUP`` layer.::\n\n    >>> \"%s.%s\" % (zca.ZCML_DIRECTIVES.__module__, zca.ZCML_DIRECTIVES.__name__,)\n    'plone.testing.zca.ZCMLDirectives'\n\n    >>> zca.ZCML_DIRECTIVES.__bases__\n    (<Layer 'plone.testing.zca.LayerCleanup'>,)\n\nBefore the test, we cannot use e.g. a ``<utility />`` directive without loading the necessary ``meta.zcml`` files.::\n\n    >>> from zope.configuration import xmlconfig\n    >>> from zope.configuration.exceptions import ConfigurationError\n    >>> try:\n    ...     xmlconfig.string(\"\"\"\\\n    ...     <configure package=\"plone.testing\" xmlns=\"http://namespaces.zope.org/zope\">\n    ...         <utility factory=\".tests.DummyUtility\" provides=\"zope.interface.Interface\" name=\"test-dummy\" />\n    ...     </configure>\"\"\")\n    ... except ConfigurationError as e:\n    ...     True\n    True\n\nLayer setup creates a configuration context we can use to load further configuration.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zca.ZCML_DIRECTIVES, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zca.ZCMLDirectives in ... seconds.\n\nLet's now simulate a test that uses this configuration context to load the same ZCML string.::\n\n    >>> zca.ZCML_DIRECTIVES.testSetUp()\n\n    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']\n    >>> xmlconfig.string(\"\"\"\\\n    ... <configure package=\"plone.testing\" xmlns=\"http://namespaces.zope.org/zope\">\n    ...     <utility factory=\".tests.DummyUtility\" provides=\"zope.interface.Interface\" name=\"test-dummy\" />\n    ... </configure>\"\"\", context=context) is context\n    True\n\nThe utility is now registered:::\n\n    >>> queryUtility(Interface, name=\"test-dummy\")\n    <Dummy utility>\n\n    >>> zca.UNIT_TESTING.testTearDown()\n\nNote that normally, we'd combine this with the ``UNIT_TESTING`` layer to tear down the component architecture as well.\n\nLayer tear-down deletes the configuration context.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.\n\n    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None\n    True\n\nConfiguration registry sandboxing\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor simple unit tests, the full cleanup performed between each test using the ``UNIT_TESTING`` layer is undoubtedly the safest and most convenient way to ensure proper isolation of tests using the global component architecture.\nHowever, if you are writing a complex layer that sets up a lot of components, you may wish to keep some components registered at the layer level, whilst still allowing tests and sub-layers to register their own components in isolation.\n\nThis is a tricky problem, because the default ZCML directives and APIs (``provideAdapter()``, ``provideUtility()`` and so on) explicitly work on a single global adapter registry object.\nTo get around this, you can use two helper methods in the ``zca`` module to push a new global component registry before registering components, and pop the registry after.\nRegistries are stacked, so the components registered in a \"lower\" registry are automatically available in a \"higher\" registry.\n\nLet's illustrate this with a layer that stacks two new global registries.\nThe first registry is specific to the layer, and is used to house the components registered at the layer level.\nThe second registry is set up and torn down for each test, allowing tests to register their own components freely.\n\nFirst, we'll create a simple dummy utility to illustrate registrations.::\n\n    >>> from zope.interface import Interface, implementer\n\n    >>> class IDummyUtility(Interface):\n    ...     pass\n    >>> @implementer(IDummyUtility)\n    ... class DummyUtility(object):\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...     def __repr__(self):\n    ...         return \"<DummyUtility %s>\" % self.name\n\nThe two key methods are:\n\n* ``zca.pushGlobalRegistry()``, which creates a new global registry.\n* ``zca.popGlobalRegistry()``, which restores the previous global registry.\n\n  **Warning:** You *must* balance your calls to these methods.\n  If you call ``pushGlobalRegistry()`` in ``setUp()``, call ``popGlobalRegistry()`` in ``tearDown()``.\n  Ditto for ``testSetUp()`` and ``testTearDown()``.\n\nLet's now create our layer.::\n\n    >>> from zope.component import provideUtility\n    >>> from plone.testing import Layer\n    >>> from plone.testing import zca\n\n    >>> class ComponentSandbox(Layer):\n    ...     def setUp(self):\n    ...         zca.pushGlobalRegistry()\n    ...         provideUtility(DummyUtility(\"layer\"), name=\"layer\")\n    ...     def tearDown(self):\n    ...         zca.popGlobalRegistry()\n    ...     def testSetUp(self):\n    ...         zca.pushGlobalRegistry()\n    ...     def testTearDown(self):\n    ...         zca.popGlobalRegistry()\n    >>> COMPONENT_SANDBOX = ComponentSandbox()\n\nLet's now simulate a test using this layer.\n\nTo begin with, we have the default registry.::\n\n    >>> from zope.component import getGlobalSiteManager, getSiteManager\n    >>> getSiteManager() is getGlobalSiteManager()\n    True\n\n    >>> defaultGlobalSiteManager = getGlobalSiteManager()\n\n    >>> from zope.component import queryUtility\n    >>> queryUtility(IDummyUtility, name=\"layer\") is None\n    True\n\nWe'll now simulate layer setup. This will push a new registry onto the stack:::\n\n    >>> COMPONENT_SANDBOX.setUp()\n\n    >>> getSiteManager() is getGlobalSiteManager()\n    True\n    >>> getGlobalSiteManager() is defaultGlobalSiteManager\n    False\n    >>> layerGlobalSiteManager = getGlobalSiteManager()\n\n    >>> queryUtility(IDummyUtility, name=\"layer\")\n    <DummyUtility layer>\n\nWe'll then simulate a test that registers a global component:::\n\n    >>> COMPONENT_SANDBOX.testSetUp()\n\n    >>> getSiteManager() is getGlobalSiteManager()\n    True\n    >>> getGlobalSiteManager() is defaultGlobalSiteManager\n    False\n    >>> getGlobalSiteManager() is layerGlobalSiteManager\n    False\n\nOur previously registered component is still here.::\n\n    >>> queryUtility(IDummyUtility, name=\"layer\")\n    <DummyUtility layer>\n\nWe can also register a new one.::\n\n    >>> provideUtility(DummyUtility(\"test\"), name=\"test\")\n    >>> queryUtility(IDummyUtility, name=\"layer\")\n    <DummyUtility layer>\n    >>> queryUtility(IDummyUtility, name=\"test\")\n    <DummyUtility test>\n\nOn test tear-down, only the second utility disappears:::\n\n    >>> COMPONENT_SANDBOX.testTearDown()\n\n    >>> getSiteManager() is getGlobalSiteManager()\n    True\n    >>> getGlobalSiteManager() is defaultGlobalSiteManager\n    False\n    >>> getGlobalSiteManager() is layerGlobalSiteManager\n    True\n\n    >>> queryUtility(IDummyUtility, name=\"layer\")\n    <DummyUtility layer>\n    >>> queryUtility(IDummyUtility, name=\"test\") is None\n    True\n\nIf we tear down the layer too, we're back where we started:::\n\n    >>> COMPONENT_SANDBOX.tearDown()\n\n    >>> getSiteManager() is getGlobalSiteManager()\n    True\n    >>> getGlobalSiteManager() is defaultGlobalSiteManager\n    True\n\n    >>> queryUtility(IDummyUtility, name=\"layer\") is None\n    True\n    >>> queryUtility(IDummyUtility, name=\"test\") is None\n    True\n\nZCML files helper class\n~~~~~~~~~~~~~~~~~~~~~~~\n\nOne of the frequent use cases is a layer that loads a ZCML file and sandbox the resulting registry.\n\nThe ``ZCMLSandbox`` can be instantiated with a `filename`` and ``package`` arguments.::\n\n    >>> import plone.testing\n    >>> ZCML_SANDBOX = zca.ZCMLSandbox(filename=\"testing_zca.zcml\",\n    ...     package=plone.testing)\n\nBefore layer setup, the utility is not registered.::\n\n    >>> queryUtility(Interface, name=\"layer\") is None\n    True\n\nWe'll now simulate layer setup.\nThis pushes a new registry onto the stack:::\n\n    >>> ZCML_SANDBOX.setUp()\n\n    >>> getSiteManager() is getGlobalSiteManager()\n    True\n    >>> getGlobalSiteManager() is defaultGlobalSiteManager\n    False\n    >>> queryUtility(Interface, name=\"layer\")\n    <Dummy utility>\n\nThe ``ZCMLSandbox`` class can also be used as ancestor for your own classes when you need to load more than a single ZCML file.\n\nYour class then needs to override the ``setUpZCMLFiles()`` method.\nIt is in charge of calling ``loadZCMLFile()``, once for each ZCML file that the class needs to load.::\n\n    >>> class OtherZCML(zca.ZCMLSandbox):\n    ...     def setUpZCMLFiles(self):\n    ...         self.loadZCMLFile(\"testing_zca.zcml\", package=plone.testing)\n    ...         self.loadZCMLFile(\"testing_zca_more_specific.zcml\",\n    ...             package=plone.testing)\n    >>> OTHER_ZCML_SANDBOX = OtherZCML()\n\nBefore layer setup, a second utility is not registered.::\n\n    >>> queryUtility(Interface, name=\"more_specific_layer\") is None\n    True\n\nWe'll now simulate the setup of the more specific layer.::\n\n    >>> OTHER_ZCML_SANDBOX.setUp()\n\nAfter setUp, the second utility is registered:::\n\n    >>> queryUtility(Interface, name=\"more_specific_layer\")\n    <Dummy utility>\n\nAfter layer teardown, the second utility is not registered anymore.::\n\n    >>> OTHER_ZCML_SANDBOX.tearDown()\n    >>> queryUtility(Interface, name=\"more_specific_layer\") is None\n    True\n\nAfter teardown of the first layer, the first utility is not registered anymore.::\n\n    >>> ZCML_SANDBOX.tearDown()\n    >>> queryUtility(Interface, name=\"layer\") is None\n    True\n\n\nSecurity\n--------\n\nThe Zope Security layers are found in the module ``plone.testing.security``:::\n\n    >>> from plone.testing import security\n\nFor testing, we need a testrunner:::\n\n    >>> from zope.testrunner import runner\n\nLayers\n~~~~~~\n\nThe ``security.CHECKERS`` layer makes sure that ``zope.security`` checkers are correctly set up and torn down.::\n\n    >>> \"%s.%s\" % (security.CHECKERS.__module__, security.CHECKERS.__name__,)\n    'plone.testing.security.Checkers'\n\n    >>> security.CHECKERS.__bases__\n    ()\n\nBefore the test, our custom checker is not in the registry.::\n\n    >>> class DummyObject(object):\n    ...     pass\n\n    >>> from zope.security.interfaces import IChecker\n    >>> from zope.interface import implementer\n    >>> @implementer(IChecker)\n    ... class FauxChecker(object):\n    ...     # we should really implement the interface here, but oh well\n    ...     pass\n\n    >>> from zope.security.checker import getCheckerForInstancesOf\n    >>> getCheckerForInstancesOf(DummyObject) is None\n    True\n\nLayer setup stacks the current checkers.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, security.CHECKERS, setupLayers)\n    Set up plone.testing.security.Checkers in ... seconds.\n\nWe can now set up a checker.\nIn real life, this may happen during ZCML configuration, but here will just call the API directlyMost likely, we'd do this in a child layer:::\n\n    >>> from zope.security.checker import defineChecker\n    >>> fauxChecker = FauxChecker()\n    >>> defineChecker(DummyObject, fauxChecker)\n\n    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker\n    True\n\nLet's now simulate a test that may use the checker.::\n\n    >>> security.CHECKERS.testSetUp()\n    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker\n    True\n    >>> security.CHECKERS.testTearDown()\n\nWe still have the checker after test tear-down:::\n\n    >>> getCheckerForInstancesOf(DummyObject) is fauxChecker\n    True\n\nHowever, when we tear down the layer, the checker is gone:::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.security.Checkers in ... seconds.\n\n    >>> getCheckerForInstancesOf(DummyObject) is None\n    True\n\n\nZope Publisher layers\n---------------------\n\nThe Zope Publisher layers are found in the module ``plone.testing.publisher``::\n\n    >>> from plone.testing import publisher\n\nFor testing, we need a testrunner:::\n\n    >>> from zope.testrunner import runner\n\nZCML directives\n~~~~~~~~~~~~~~~\n\nThe ``publisher.PUBLISHER_DIRECTIVES`` layer extends the ``zca.ZCML_DIRECTIVES`` layer to extend its ZCML configuration context with the ``zope.app.publisher`` and ``zope.security`` directives available.\nIt also extends ``security.CHECKERS``.::\n\n    >>> from plone.testing import zca, security\n\n    >>> \"%s.%s\" % (publisher.PUBLISHER_DIRECTIVES.__module__, publisher.PUBLISHER_DIRECTIVES.__name__,)\n    'plone.testing.publisher.PublisherDirectives'\n\n    >>> publisher.PUBLISHER_DIRECTIVES.__bases__\n    (<Layer 'plone.testing.zca.ZCMLDirectives'>, <Layer 'plone.testing.security.Checkers'>)\n\nBefore the test, we cannot use e.g.\nthe ``<permission />`` or ``<browser:view />`` directives without loading the necessary ``meta.zcml`` files.::\n\n    >>> from zope.configuration import xmlconfig\n    >>> from zope.configuration.exceptions import ConfigurationError\n    >>> try:\n    ...     xmlconfig.string(\"\"\"\\\n    ...     <configure package=\"plone.testing\"\n    ...         xmlns=\"http://namespaces.zope.org/zope\"\n    ...         xmlns:browser=\"http://namespaces.zope.org/browser\"\n    ...         i18n_domain=\"plone.testing.tests\">\n    ...         <permission id=\"plone.testing.Test\" title=\"plone.testing: Test\" />\n    ...         <browser:view\n    ...             for=\"*\"\n    ...             name=\"plone.testing-test\"\n    ...             class=\"plone.testing.tests.DummyView\"\n    ...             permission=\"zope.Public\"\n    ...             />\n    ...     </configure>\"\"\")\n    ... except ConfigurationError as e:\n    ...     True\n    True\n\nLayer setup creates a configuration context we can use to load further configuration.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, publisher.PUBLISHER_DIRECTIVES, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zca.ZCMLDirectives in ... seconds.\n    Set up plone.testing.security.Checkers in ... seconds.\n    Set up plone.testing.publisher.PublisherDirectives in ... seconds.\n\n\nLet's now simulate a test that uses this configuration context to load the same ZCML string.::\n\n    >>> zca.ZCML_DIRECTIVES.testSetUp()\n    >>> security.CHECKERS.testSetUp()\n    >>> publisher.PUBLISHER_DIRECTIVES.testSetUp()\n\n    >>> context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']\n    >>> xmlconfig.string(\"\"\"\\\n    ... <configure package=\"plone.testing\"\n    ...     xmlns=\"http://namespaces.zope.org/zope\"\n    ...     xmlns:browser=\"http://namespaces.zope.org/browser\"\n    ...     i18n_domain=\"plone.testing.tests\">\n    ...     <permission id=\"plone.testing.Test\" title=\"plone.testing: Test\" />\n    ...     <browser:view\n    ...         for=\"*\"\n    ...         name=\"plone.testing-test\"\n    ...         class=\"plone.testing.tests.DummyView\"\n    ...         permission=\"zope.Public\"\n    ...         />\n    ... </configure>\"\"\", context=context) is context\n    True\n\nThe permission and view are now registered:::\n\n    >>> from zope.component import queryUtility\n    >>> from zope.security.interfaces import IPermission\n\n    >>> queryUtility(IPermission, name=u\"plone.testing.Test\")\n    <zope.security.permission.Permission object at ...>\n\n    >>> from zope.interface import Interface\n    >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n    >>> from zope.component import getSiteManager\n    >>> siteManager = getSiteManager()\n\n    >>> [x.factory for x in siteManager.registeredAdapters()\n    ...  if x.provided==Interface and x.required==(Interface, IDefaultBrowserLayer)\n    ...   and x.name==u\"plone.testing-test\"]\n    [<class '....plone.testing-test'>]\n\nWe can then simulate test tear-down:::\n\n    >>> publisher.PUBLISHER_DIRECTIVES.testTearDown()\n    >>> security.CHECKERS.testTearDown()\n    >>> zca.ZCML_DIRECTIVES.testTearDown()\n\nNote that you'd normally combine this layer with the ``zca.UNIT_TESTING`` or a similar layer to automatically tear down the component architecture between each test.\nHere, we need to do it manually.::\n\n    >>> from zope.component.testing import tearDown\n    >>> tearDown()\n\nLayer tear-down does nothing.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.publisher.PublisherDirectives in ... seconds.\n    Tear down plone.testing.zca.ZCMLDirectives in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n    Tear down plone.testing.security.Checkers in ... seconds.\n\n    >>> zca.ZCML_DIRECTIVES.get('configurationContext', None) is None\n    True\n\n\nZope Object Database layers\n---------------------------\n\nThe ZODB layers are found in the module ``plone.testing.zodb``:::\n\n    >>> from plone.testing import zodb\n\nFor testing, we need a testrunner:::\n\n    >>> from zope.testrunner import runner\n\nEmpty ZODB layer\n~~~~~~~~~~~~~~~~\n\nThe ``EMPTY_ZODB`` layer is used to set up an empty ZODB using ``DemoStorage``.\n\nThe storage and database are set up as layer fixtures.\nThe database is exposed as the resource ``zodbDB``.\n\nA connection is opened for each test and exposed as ``zodbConnection``.\nThe ZODB root is also exposed, as ``zodbRoot``.\nA new transaction is begun for each test.\nOn test tear-down, the transaction is aborted, the connection is closed, and the two test-specific resources are deleted.\n\nThe layer has no bases.::\n\n    >>> \"%s.%s\" % (zodb.EMPTY_ZODB.__module__, zodb.EMPTY_ZODB.__name__,)\n    'plone.testing.zodb.EmptyZODB'\n\n    >>> zodb.EMPTY_ZODB.__bases__\n    ()\n\nLayer setup creates the database, but not a connection.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zodb.EMPTY_ZODB, setupLayers)\n    Set up plone.testing.zodb.EmptyZODB in ... seconds.\n\n    >>> db = zodb.EMPTY_ZODB['zodbDB']\n    >>> db.storage\n    EmptyZODB\n\n    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None\n    True\n    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None\n    True\n\nLet's now simulate a test.::\n\n    >>> zodb.EMPTY_ZODB.testSetUp()\n\nThe test would then execute. It may use the ZODB root.::\n\n    >>> zodb.EMPTY_ZODB['zodbConnection']\n    <Connection at ...>\n\n    >>> zodb.EMPTY_ZODB['zodbRoot']\n    {}\n\n    >>> zodb.EMPTY_ZODB['zodbRoot']['foo'] = 'bar'\n\nOn test tear-down, the transaction is aborted and the connection is closed.::\n\n    >>> zodb.EMPTY_ZODB.testTearDown()\n\n    >>> zodb.EMPTY_ZODB.get('zodbConnection', None) is None\n    True\n\n    >>> zodb.EMPTY_ZODB.get('zodbRoot', None) is None\n    True\n\nThe transaction has been rolled back.::\n\n    >>> conn = zodb.EMPTY_ZODB['zodbDB'].open()\n    >>> conn.root()\n    {}\n    >>> conn.close()\n\nLayer tear-down closes and deletes the database.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zodb.EmptyZODB in ... seconds.\n\n    >>> zodb.EMPTY_ZODB.get('zodbDB', None) is None\n    True\n\nExtending the ZODB layer\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen creating a test fixture, it is often desirable to add some initial data to the database.\nIf you want to do that once on layer setup, you can create your own layer class based on ``EmptyZODB`` and override its ``createStorage()`` and/or ``createDatabase()`` methods to return a pre-populated database.::\n\n    >>> import transaction\n    >>> from ZODB.DemoStorage import DemoStorage\n    >>> from ZODB.DB import DB\n\n    >>> class PopulatedZODB(zodb.EmptyZODB):\n    ...\n    ...     def createStorage(self):\n    ...         return DemoStorage(\"My storage\")\n    ...\n    ...     def createDatabase(self, storage):\n    ...         db = DB(storage)\n    ...         conn = db.open()\n    ...\n    ...         conn.root()['someData'] = 'a string'\n    ...\n    ...         transaction.commit()\n    ...         conn.close()\n    ...\n    ...         return db\n\n    >>> POPULATED_ZODB = PopulatedZODB()\n\nWe'll use this new layer in a similar manner to the test above, showing that the data is there for each test, but that other changes are rolled back.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, POPULATED_ZODB, setupLayers)\n    Set up PopulatedZODB in ... seconds.\n\n    >>> db = POPULATED_ZODB['zodbDB']\n    >>> db.storage\n    My storage\n\n    >>> POPULATED_ZODB.get('zodbConnection', None) is None\n    True\n    >>> POPULATED_ZODB.get('zodbRoot', None) is None\n    True\n\nLet's now simulate a test.::\n\n    >>> POPULATED_ZODB.testSetUp()\n\nThe test would then execute. It may use the ZODB root.::\n\n    >>> POPULATED_ZODB['zodbConnection']\n    <Connection at ...>\n\n    >>> POPULATED_ZODB['zodbRoot']\n    {'someData': 'a string'}\n\n    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'\n\nOn test tear-down, the transaction is aborted and the connection is closed.::\n\n    >>> POPULATED_ZODB.testTearDown()\n\n    >>> POPULATED_ZODB.get('zodbConnection', None) is None\n    True\n\n    >>> POPULATED_ZODB.get('zodbRoot', None) is None\n    True\n\nThe transaction has been rolled back.::\n\n    >>> conn = POPULATED_ZODB['zodbDB'].open()\n    >>> conn.root()\n    {'someData': 'a string'}\n    >>> conn.close()\n\nLayer tear-down closes and deletes the database.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down PopulatedZODB in ... seconds.\n\n    >>> POPULATED_ZODB.get('zodbDB', None) is None\n    True\n\nStacking ``DemoStorage`` storages\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe example above shows how to create a simple test fixture with a custom database.\nIt is sometimes useful to be able to stack these fixtures, so that a base layer sets up some data for one set of tests, and a child layer extends this, temporarily, with more data.\n\nThis can be achieved using layer bases and resource shadowing, combined with ZODB's stackable DemoStorage.\nThere is even a helper function available:::\n\n    >>> from plone.testing import Layer\n    >>> from plone.testing import zodb\n    >>> import transaction\n\n    >>> class ExpandedZODB(Layer):\n    ...     defaultBases = (POPULATED_ZODB,)\n    ...\n    ...     def setUp(self):\n    ...         # Get the database from the base layer\n    ...\n    ...         self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='ExpandedZODB')\n    ...\n    ...         conn = db.open()\n    ...         conn.root()['additionalData'] = \"Some new data\"\n    ...         transaction.commit()\n    ...         conn.close()\n    ...\n    ...     def tearDown(self):\n    ...         # Close the database and delete the shadowed copy\n    ...\n    ...         self['zodbDB'].close()\n    ...         del self['zodbDB']\n\n    >>> EXPANDED_ZODB = ExpandedZODB()\n\nNotice that we are using plain ``Layer`` as a base class here.\nWe obtain the underlying database from our bases using the resource manager, and then create a shadow copy using a stacked storage.\nStacked storages contain the data of the original storage, but save changes in a separate (and, in this case, temporary) storage.\n\nLet's simulate a test run again to show how this would work.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, EXPANDED_ZODB, setupLayers)\n    Set up PopulatedZODB in ... seconds.\n    Set up ExpandedZODB in ... seconds.\n\n    >>> db = EXPANDED_ZODB['zodbDB']\n    >>> db.storage\n    ExpandedZODB\n\n    >>> EXPANDED_ZODB.get('zodbConnection', None) is None\n    True\n    >>> EXPANDED_ZODB.get('zodbRoot', None) is None\n    True\n\nLet's now simulate a test.::\n\n    >>> POPULATED_ZODB.testSetUp()\n    >>> EXPANDED_ZODB.testSetUp()\n\nThe test would then execute. It may use the ZODB root.::\n\n    >>> EXPANDED_ZODB['zodbConnection']\n    <Connection at ...>\n\n    >>> EXPANDED_ZODB['zodbRoot'] == dict(someData='a string', additionalData='Some new data')\n    True\n\n    >>> POPULATED_ZODB['zodbRoot']['foo'] = 'bar'\n\nOn test tear-down, the transaction is aborted and the connection is closed.::\n\n    >>> EXPANDED_ZODB.testTearDown()\n    >>> POPULATED_ZODB.testTearDown()\n\n    >>> EXPANDED_ZODB.get('zodbConnection', None) is None\n    True\n\n    >>> EXPANDED_ZODB.get('zodbRoot', None) is None\n    True\n\nThe transaction has been rolled back.::\n\n    >>> conn = EXPANDED_ZODB['zodbDB'].open()\n    >>> conn.root() == dict(someData='a string', additionalData='Some new data')\n    True\n    >>> conn.close()\n\nWe'll now tear down the expanded layer and inspect the database again.::\n\n    >>> runner.tear_down_unneeded(options, [POPULATED_ZODB], setupLayers, [])\n    Tear down ExpandedZODB in ... seconds.\n\n    >>> conn = EXPANDED_ZODB['zodbDB'].open()\n    >>> conn.root()\n    {'someData': 'a string'}\n\n    >>> conn.close()\n\nFinally, we'll tear down the rest of the layers.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down PopulatedZODB in ... seconds.\n\n    >>> EXPANDED_ZODB.get('zodbDB', None) is None\n    True\n    >>> POPULATED_ZODB.get('zodbDB', None) is None\n    True\n\n\nZope WSGI layers\n----------------\n\nThe Zope WSGI layers are found in the module ``plone.testing.zope``:::\n\n    >>> from plone.testing import zope\n\nFor testing, we need a testrunner:::\n\n    >>> from zope.testrunner import runner\n\nStartup\n~~~~~~~\n\n``STARTUP`` is the base layer for all Zope WSGI testing.\nIt sets up a Zope WSGI sandbox environment that is suitable for testing.\nIt extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a pristine environment.\n\n**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.\nSee the description of ``INTEGRATION_TESTING`` below.::\n\n    >>> \"%s.%s\" % (zope.STARTUP.__module__, zope.STARTUP.__name__,)\n    'plone.testing.zope.Startup'\n\n    >>> zope.STARTUP.__bases__\n    (<Layer 'plone.testing.zca.LayerCleanup'>,)\n\nOn layer setup, Zope is initialised in a lightweight manner.\nThis involves certain patches to global modules that Zope manages, to reduce setup time, a database based on ``DemoStorage``, and a minimal set of products that must be installed for Zope 2 to work.\nA minimal set of ZCML is loaded, but packages in the ``Products`` namespace are not automatically configured.\n\nLet's just verify that we have an empty component registry before the test:::\n\n    >>> from zope.component import getSiteManager\n    >>> list(getSiteManager().registeredAdapters())\n    []\n\nFive sets a special vocabulary registry upon the layer setup, but there's a default one set before:::\n\n    >>> from zope.schema.vocabulary import getVocabularyRegistry\n    >>> getVocabularyRegistry()\n    <zope.schema.vocabulary.VocabularyRegistry object ...>\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zope.STARTUP, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zope.Startup in ... seconds.\n\nAfter layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::\n\n    >>> zope.STARTUP['zodbDB']\n    <ZODB.DB.DB object at ...>\n\n    >>> zope.STARTUP['zodbDB'].storage\n    Startup\n\nIn addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.\nThese are hardcoded, but shadowed by layers that provide actual running Zope instances.::\n\n    >>> zope.STARTUP['host']\n    'nohost'\n    >>> zope.STARTUP['port']\n    80\n\nAt this point, it is also possible to get hold of a Zope application root.\nIf you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::\n\n    >>> with zope.zopeApp() as app:\n    ...     'acl_users' in app.objectIds()\n    True\n\nIf you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.\nA new connection will be opened and closed.::\n\n    >>> with zope.zopeApp(db=zope.STARTUP['zodbDB']) as app:\n    ...     'acl_users' in app.objectIds()\n    True\n\nIf you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.\nIn this case, you will need to close the connection yourself.::\n\n    >>> conn = zope.STARTUP['zodbDB'].open()\n    >>> with zope.zopeApp(connection=conn) as app:\n    ...     'acl_users' in app.objectIds()\n    True\n\n    >>> conn.opened is not None\n    True\n\n    >>> conn.close()\n\nIf an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::\n\n    >>> with zope.zopeApp() as app:\n    ...     raise Exception(\"Test error\")\n    Traceback (most recent call last):\n    ...\n    Exception: Test error\n\nIt is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.\nAs a sketch:::\n\n    from plone.testing import Layer, zope, zodb\n\n    class MyLayer(Layer):\n        defaultBases = (zope.STARTUP,)\n\n        def setUp(self):\n            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')\n            with zope.zopeApp() as app:\n\n                # Set up a fixture, e.g.:\n                app.manage_addFolder('folder1')\n                folder = app['folder1']\n                folder._addRole('role1')\n                folder.manage_addUserFolder()\n\n                userFolder = folder['acl_users']\n                ignore = userFolder.userFolderAddUser('user1', 'secret', ['role1'], [])\n                folder.manage_role('role1', ('Access contents information',))\n\n        def tearDown(self):\n            self['zodbDB'].close()\n            del self['zodbDB']\n\nNote that you would normally *not* use the ``zope.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\nThe ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).\n\nAfter layer setup, the global component registry contains a number of components needed by Zope.::\n\n    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot\n    True\n\nAnd Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::\n\n    >>> getVocabularyRegistry()\n    <....Zope2VocabularyRegistry object at ...>\n\nTo load additional ZCML, you can use the ``configurationContext`` resource:::\n\n    >>> zope.STARTUP['configurationContext']\n    <zope.configuration.config.ConfigurationMachine object ...>\n\nSee ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.\n\nThe ``STARTUP`` layer does not perform any specific test setup or tear-down.\nThat is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::\n\n    >>> zope.STARTUP.testSetUp()\n    >>> zope.STARTUP.testTearDown()\n\nLayer tear-down resets the environment.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zope.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\n    >>> import Zope2\n    >>> Zope2._began_startup\n    0\n    >>> Zope2.DB is None\n    True\n    >>> Zope2.bobo_application is None\n    True\n\n    >>> list(getSiteManager().registeredAdapters())\n    []\n\n    >>> getVocabularyRegistry()\n    <zope.schema.vocabulary.VocabularyRegistry object at ...>\n\nIntegration test\n~~~~~~~~~~~~~~~~\n\n``INTEGRATION_TESTING`` is intended for simple Zope WSGI integration testing.\nIt extends ``STARTUP`` to ensure that a transaction is begun before and rolled back after each test.\nTwo resources, ``app`` and ``request``, are available during testing as well.\nIt does not manage any layer state - it implements the test lifecycle methods only.\n\n**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base layer.\nInstead, you'd use the ``IntegrationTesting`` class to create your own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.\nSee the ``plone.testing`` ``README`` file for an example.\n\n``app`` is the application root.\nIn a test, you should use this instead of the ``zopeApp`` context manager (which remains the weapon of choice for setting up persistent fixtures), because the ``app`` resource is part of the transaction managed by the layer.\n\n``request`` is a test request. It is the same as ``app.REQUEST``.::\n\n    >>> \"%s.%s\" % (zope.INTEGRATION_TESTING.__module__, zope.INTEGRATION_TESTING.__name__,)\n    'plone.testing.zope.IntegrationTesting'\n\n    >>> zope.INTEGRATION_TESTING.__bases__\n    (<Layer 'plone.testing.zope.Startup'>,)\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zope.INTEGRATION_TESTING, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zope.Startup in ... seconds.\n    Set up plone.testing.zope.IntegrationTesting in ... seconds.\n\nLet's now simulate a test.\nOn test setup, the ``app`` resource is made available.\nIn a test, you should always use this to access the application root.::\n\n    >>> zope.STARTUP.testSetUp()\n    >>> zope.INTEGRATION_TESTING.testSetUp()\n\nThe test may now inspect and modify the environment.::\n\n    >>> app = zope.INTEGRATION_TESTING['app'] # would normally be self.layer['app']\n    >>> app.manage_addFolder('folder1')\n    >>> 'acl_users' in app.objectIds() and 'folder1' in app.objectIds()\n    True\n\nThe request is also available:::\n\n    >>> zope.INTEGRATION_TESTING['request'] # would normally be self.layer['request']\n    <HTTPRequest, URL=http://nohost>\n\nWe can create a user and simulate logging in as that user, using the ``zope.login()`` helper:::\n\n    >>> app._addRole('role1')\n    >>> ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])\n    >>> zope.login(app['acl_users'], 'user1')\n\nThe first argument to ``zope.login()`` is the user folder that contains the relevant user.\nThe second argument is the user's name.\nThere is no need to give the password.::\n\n    >>> from AccessControl import getSecurityManager\n    >>> getSecurityManager().getUser()\n    <User 'user1'>\n\nYou can change the roles of a user using the ``zope.setRoles()`` helper:::\n\n    >>> sorted(getSecurityManager().getUser().getRolesInContext(app))\n    ['Authenticated', 'role1']\n\n    >>> zope.setRoles(app['acl_users'], 'user1', [])\n    >>> getSecurityManager().getUser().getRolesInContext(app)\n    ['Authenticated']\n\nTo become the anonymous user again, use ``zope.logout()``:::\n\n    >>> zope.logout()\n    >>> getSecurityManager().getUser()\n    <SpecialUser 'Anonymous User'>\n\nOn tear-down, the transaction is rolled back:::\n\n    >>> zope.INTEGRATION_TESTING.testTearDown()\n    >>> zope.STARTUP.testTearDown()\n\n    >>> 'app' in zope.INTEGRATION_TESTING\n    False\n\n    >>> 'request' in zope.INTEGRATION_TESTING\n    False\n\n    >>> with zope.zopeApp() as app:\n    ...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\n    True\n\n\nLet's tear down the layers:::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zope.IntegrationTesting in ... seconds.\n    Tear down plone.testing.zope.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\nFunctional testing\n~~~~~~~~~~~~~~~~~~\n\nThe ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``, and exposes the same fixture and resources.\nHowever, it has different transaction semantics.\n``INTEGRATION_TESTING`` creates a single database storage, and rolls back the transaction after each test.\n``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of the basic fixture) for each test.\nThis allows testing of code that performs an explicit commit, which is usually required for end-to-end testing.\nThe downside is that the set-up and tear-down of each test takes longer.\n\n**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base layer.\nInstead, you'd use the ``FunctionalTesting`` class to create your own layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``.\nSee the ``plone.testing`` ``README`` file for an example.\n\nLike ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::\n\n    >>> \"%s.%s\" % (zope.FUNCTIONAL_TESTING.__module__, zope.FUNCTIONAL_TESTING.__name__,)\n    'plone.testing.zope.FunctionalTesting'\n\n    >>> zope.FUNCTIONAL_TESTING.__bases__\n    (<Layer 'plone.testing.zope.Startup'>,)\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zope.FUNCTIONAL_TESTING, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zope.Startup in ... seconds.\n    Set up plone.testing.zope.FunctionalTesting in ... seconds.\n\nLet's now simulate a test.\nOn test setup, the ``app`` resource is made available.\nIn a test, you should always use this to access the application root.\nThe ``request`` resource can be used to access the test request.::\n\n    >>> zope.STARTUP.testSetUp()\n    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n\nThe test may now inspect and modify the environment.\nIt may also commit things.::\n\n    >>> app = zope.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']\n    >>> app.manage_addFolder('folder1')\n    >>> 'acl_users' in app.objectIds() and 'folder1' in app.objectIds()\n    True\n\n    >>> import transaction\n    >>> transaction.commit()\n\nOn tear-down, the database is torn down.::\n\n    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n    >>> zope.STARTUP.testTearDown()\n\n    >>> 'app' in zope.FUNCTIONAL_TESTING\n    False\n\n    >>> 'request' in zope.FUNCTIONAL_TESTING\n    False\n\n    >>> with zope.zopeApp() as app:\n    ...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\n    True\n\nLet's tear down the layer:::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zope.FunctionalTesting in ... seconds.\n    Tear down plone.testing.zope.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\nThe test browser\n~~~~~~~~~~~~~~~~\n\nThe ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are the basis for functional testing using ``zope.testbrowser``.\nThis simulates a web browser, allowing an application to be tested \"end-to-end\" via its user-facing interface.\n\nTo use the test browser with a ``FunctionalTesting`` layer (such as the default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom browser client, which ensures that the test browser uses the correct ZODB and is appropriately isolated from the test code.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zope.FUNCTIONAL_TESTING, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zope.Startup in ... seconds.\n    Set up plone.testing.zope.FunctionalTesting in ... seconds.\n\nLet's simulate a test:::\n\n    >>> zope.STARTUP.testSetUp()\n    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n\nIn the test, we can create a test browser client like so:::\n\n    >>> app = zope.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']\n    >>> browser = zope.Browser(app)\n\nIt is usually best to let Zope errors be shown with full tracebacks:::\n\n    >>> browser.handleErrors = False\n\nWe can add to the test fixture in the test.\nFor those changes to be visible to the test browser, however, we need to commit the transaction.::\n\n    >>> _ = app.manage_addDTMLDocument('dtml-doc-1')\n    >>> import transaction; transaction.commit()\n\nWe can now view this via the test browser:::\n\n    >>> browser.open(app.absolute_url() + '/dtml-doc-1')\n    >>> 'This is the dtml-doc-1 Document.' in browser.contents\n    True\n\nThe test browser integration converts the URL into a request and passes control to Zope's publisher.\nLet's check that query strings are available for input processing:::\n\n    >>> from six.moves.urllib.parse import urlencode\n    >>> _ = app.manage_addDTMLDocument('dtml-doc-2', file='<dtml-var foo>')\n    >>> import transaction; transaction.commit()\n    >>> qs = urlencode({'foo': 'boo, bar & baz'})  # sic: the ampersand.\n    >>> browser.open(app.absolute_url() + '/dtml-doc-2?' + qs)\n    >>> browser.contents\n    'boo, bar & baz'\n\nThe test browser also works with iterators.\nLet's test that with a simple file implementation that uses an iterator.::\n\n    >>> from plone.testing.tests import DummyFile\n    >>> app._setObject('file1', DummyFile('file1'))\n    'file1'\n\n    >>> import transaction; transaction.commit()\n\n    >>> browser.open(app.absolute_url() + '/file1')\n    >>> 'The test browser also works with iterators' in browser.contents\n    True\n\nSee the ``zope.testbrowser`` documentation for more information about how to use the browser client.\n\nOn tear-down, the database is torn down.::\n\n    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n    >>> zope.STARTUP.testTearDown()\n\n    >>> 'app' in zope.FUNCTIONAL_TESTING\n    False\n\n    >>> 'request' in zope.FUNCTIONAL_TESTING\n    False\n\n    >>> with zope.zopeApp() as app:\n    ...     'acl_users' in app.objectIds()\\\n    ...         and 'folder1' not in app.objectIds()\\\n    ...         and 'file1' not in app.objectIds()\n    True\n\nLet's tear down the layer:::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zope.FunctionalTesting in ... seconds.\n    Tear down plone.testing.zope.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\nHTTP server\n~~~~~~~~~~~\n\nThe ``WSGI_SERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded Zope server in a separate thread.\nThis makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.\n\nThe ``WSGI_SERVER`` layer provides a ``FunctionalTesting`` layer that has ``WSGI_SERVER_FIXTURE`` as its base.::\n\n    >>> \"%s.%s\" % (zope.WSGI_SERVER_FIXTURE.__module__, zope.WSGI_SERVER_FIXTURE.__name__,)\n    'plone.testing.zope.WSGIServer'\n\n    >>> zope.WSGI_SERVER_FIXTURE.__bases__\n    (<Layer 'plone.testing.zope.Startup'>,)\n\n\n    >>> \"%s.%s\" % (zope.WSGI_SERVER.__module__, zope.WSGI_SERVER.__name__,)\n    'plone.testing.zope.WSGIServer:Functional'\n\n    >>> zope.WSGI_SERVER.__bases__\n    (<Layer 'plone.testing.zope.WSGIServer'>,)\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zope.WSGI_SERVER, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zope.Startup in ... seconds.\n    Set up plone.testing.zope.WSGIServer in ... seconds.\n    Set up plone.testing.zope.WSGIServer:Functional in ... seconds.\n\nAfter layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n\n    >>> host = zope.WSGI_SERVER['host']\n    >>> host\n    'localhost'\n\n    >>> port = zope.WSGI_SERVER['port']\n\nLet's now simulate a test.\nTest setup does nothing beyond what the base layers do.::\n\n    >>> zope.STARTUP.testSetUp()\n    >>> zope.FUNCTIONAL_TESTING.testSetUp()\n    >>> zope.WSGI_SERVER.testSetUp()\n\nIt is common in a test to use the Python API to change the state of the server (e.g.\ncreate some content or change a setting) and then use the HTTP protocol to look at the results.\nBear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``zope.login()`` and ``zope.logout()``, for instance, do not affect the server thread.::\n\n    >>> app = zope.WSGI_SERVER['app'] # would normally be self.layer['app']\n    >>> _ = app.manage_addDTMLDocument('dtml-doc-3')\n\nNote that we need to commit the transaction before it will show up in the other thread.::\n\n    >>> import transaction; transaction.commit()\n\nWe can now look for this new object through the server.::\n\n    >>> app_url = app.absolute_url()\n    >>> app_url.split(':')[:-1]\n    ['http', '//localhost']\n\n    >>> from six.moves.urllib.request import urlopen\n    >>> conn = urlopen(app_url + '/dtml-doc-3', timeout=5)\n    >>> b'This is the dtml-doc-3 Document.' in conn.read()\n    True\n    >>> conn.close()\n\nTest tear-down does nothing beyond what the base layers do.::\n\n    >>> zope.WSGI_SERVER.testTearDown()\n    >>> zope.FUNCTIONAL_TESTING.testTearDown()\n    >>> zope.STARTUP.testTearDown()\n\n    >>> 'app' in zope.WSGI_SERVER\n    False\n\n    >>> 'request' in zope.WSGI_SERVER\n    False\n\n    >>> with zope.zopeApp() as app:\n    ...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\n    True\n\nWhen the server is torn down, the WSGIServer thread is stopped.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zope.WSGIServer:Functional in ... seconds.\n    Tear down plone.testing.zope.WSGIServer in ... seconds.\n    Tear down plone.testing.zope.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\nWe can expect one of these exceptions:\n- URLError: <urlopen error [Errno ...] Connection refused>\n- error: [Errno 104] Connection reset by peer\n\n    >>> try:\n    ...     conn = urlopen(app_url + '/folder1', timeout=5)\n    ... except Exception as exc:\n    ...     if 'Connection refused' not in str(exc) and 'Connection reset' not in str(exc):\n    ...         raise exc\n    ... else:\n    ...     print('urlopen should have raised exception')\n\n\nZope 2 layers\n-------------\n\nThe Zope 2 layers are found in the module ``plone.testing.zserver``:::\n\n    >>> from plone.testing import zserver\n\nFor testing, we need a testrunner:::\n\n    >>> from zope.testrunner import runner\n\nStartup\n~~~~~~~\n\n``STARTUP`` is the base layer for all Zope 2 testing.\nIt sets up a Zope 2 sandbox environment that is suitable for testing.\nIt extends the ``zca.LAYER_CLEANUP`` layer to maximise the chances of having and leaving a pristine environment.\n\n**Note**: You should probably use at least ``INTEGRATION_TESTING`` for any real test, although ``STARTUP`` is a useful base layer if you are setting up your own fixture.\nSee the description of ``INTEGRATION_TESTING`` below.::\n\n    >>> \"%s.%s\" % (zserver.STARTUP.__module__, zserver.STARTUP.__name__,)\n    'plone.testing.zserver.Startup'\n\n    >>> zserver.STARTUP.__bases__\n    (<Layer 'plone.testing.zca.LayerCleanup'>,)\n\nOn layer setup, Zope is initialised in a lightweight manner.\nThis involves certain patches to global modules that Zope manages, to reduce setup time, a database based on ``DemoStorage``, and a minimal set of products that must be installed for Zope 2 to work.\nA minimal set of ZCML is loaded, but packages in the ``Products`` namespace are not automatically configured.\n\nLet's just verify that we have an empty component registry before the test:::\n\n    >>> from zope.component import getSiteManager\n    >>> list(getSiteManager().registeredAdapters())\n    []\n\nFive sets a special vocabulary registry upon the layer setup, but there's a default one set before:::\n\n    >>> from zope.schema.vocabulary import getVocabularyRegistry\n    >>> getVocabularyRegistry()\n    <zope.schema.vocabulary.VocabularyRegistry object ...>\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zserver.STARTUP, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zserver.Startup in ... seconds.\n\nAfter layer setup, the ``zodbDB`` resource is available, pointing to the default ZODB.::\n\n    >>> zserver.STARTUP['zodbDB']\n    <ZODB.DB.DB object at ...>\n\n    >>> zserver.STARTUP['zodbDB'].storage\n    Startup\n\nIn addition, the resources ``host`` and ``port`` are set to the default hostname and port that are used for URLs generated from Zope.\nThese are hardcoded, but shadowed by layers that provide actual running Zope instances.::\n\n    >>> zserver.STARTUP['host']\n    'nohost'\n    >>> zserver.STARTUP['port']\n    80\n\nAt this point, it is also possible to get hold of a Zope application root.\nIf you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the ``zopeApp()`` context manager.::\n\n    >>> with zserver.zopeApp() as app:\n    ...     'acl_users' in app.objectIds()\n    True\n\nIf you want to use a specific database, you can pass that to ``zopeApp()`` as the ``db`` parameter.\nA new connection will be opened and closed.::\n\n    >>> with zserver.zopeApp(db=zserver.STARTUP['zodbDB']) as app:\n    ...     'acl_users' in app.objectIds()\n    True\n\nIf you want to re-use an existing connection, you can pass one to ``zopeApp()`` as the ``connection`` argument.\nIn this case, you will need to close the connection yourself.::\n\n    >>> conn = zserver.STARTUP['zodbDB'].open()\n    >>> with zserver.zopeApp(connection=conn) as app:\n    ...     'acl_users' in app.objectIds()\n    True\n\n    >>> conn.opened is not None\n    True\n\n    >>> conn.close()\n\nIf an exception is raised within the ``with`` block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager):::\n\n    >>> with zserver.zopeApp() as app:\n    ...     raise Exception(\"Test error\")\n    Traceback (most recent call last):\n    ...\n    Exception: Test error\n\nIt is common to combine the ``zopeApp()`` context manager with a stacked ``DemoStorage`` to set up a layer-specific fixture.\nAs a sketch:::\n\n    from plone.testing import Layer, zserver, zodb\n\n    class MyLayer(Layer):\n        defaultBases = (zserver.STARTUP,)\n\n        def setUp(self):\n            self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')\n            with zserver.zopeApp() as app:\n\n                # Set up a fixture, e.g.:\n                app.manage_addFolder('folder1')\n                folder = app['folder1']\n                folder._addRole('role1')\n                folder.manage_addUserFolder()\n\n                userFolder = folder['acl_users']\n                ignore = userFolder.userFolderAddUser('user1', 'secret', ['role1'], [])\n                folder.manage_role('role1', ('Access contents information',))\n\n        def tearDown(self):\n            self['zodbDB'].close()\n            del self['zodbDB']\n\nNote that you would normally *not* use the ``zserver.zopeApp()`` in a test or in a ``testSetUp()`` or ``testTearDown()`` method.\nThe ``IntegrationTesting`` and ``FunctionalTesting`` layer classes manage the application object for you, exposing them as the resource ``app`` (see below).\n\nAfter layer setup, the global component registry contains a number of components needed by Zope.::\n\n    >>> len(list(getSiteManager().registeredAdapters())) > 1 # in fact, > a lot\n    True\n\nAnd Five has set a ``Zope2VocabularyRegistry`` vocabulary registry:::\n\n    >>> getVocabularyRegistry()\n    <....Zope2VocabularyRegistry object at ...>\n\nTo load additional ZCML, you can use the ``configurationContext`` resource:::\n\n    >>> zserver.STARTUP['configurationContext']\n    <zope.configuration.config.ConfigurationMachine object ...>\n\nSee ``zca.rst`` for details about how to use ``zope.configuration`` for this purpose.\n\nThe ``STARTUP`` layer does not perform any specific test setup or tear-down.\nThat is left up to the ``INTEGRATION_TESTING`` and ``FUNCTIONAL_TESTING`` layers, or other layers using their layer classes - ``IntegrationTesting`` and ``FunctionalTesting``.::\n\n    >>> zserver.STARTUP.testSetUp()\n    >>> zserver.STARTUP.testTearDown()\n\nLayer tear-down resets the environment.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zserver.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\n    >>> import ZServer.Zope2\n    >>> ZServer.Zope2._began_startup\n    0\n    >>> import Zope2\n    >>> Zope2.DB is None\n    True\n    >>> Zope2.bobo_application is None\n    True\n\n    >>> list(getSiteManager().registeredAdapters())\n    []\n\n    >>> getVocabularyRegistry()\n    <zope.schema.vocabulary.VocabularyRegistry object at ...>\n\nIntegration test\n~~~~~~~~~~~~~~~~\n\n``INTEGRATION_TESTING`` is intended for simple Zope 2 integration testing.\nIt extends ``STARTUP`` to ensure that a transaction is begun before and rolled back after each test.\nTwo resources, ``app`` and ``request``, are available during testing as well.\nIt does not manage any layer state - it implements the test lifecycle methods only.\n\n**Note:** You would normally *not* use ``INTEGRATION_TESTING`` as a base layer.\nInstead, you'd use the ``IntegrationTesting`` class to create your own layer with the testing lifecycle semantics of ``INTEGRATION_TESTING``.\nSee the ``plone.testing`` ``README`` file for an example.\n\n``app`` is the application root.\nIn a test, you should use this instead of the ``zopeApp`` context manager (which remains the weapon of choice for setting up persistent fixtures), because the ``app`` resource is part of the transaction managed by the layer.\n\n``request`` is a test request. It is the same as ``app.REQUEST``.::\n\n    >>> \"%s.%s\" % (zserver.INTEGRATION_TESTING.__module__, zserver.INTEGRATION_TESTING.__name__,)\n    'plone.testing.zserver.IntegrationTesting'\n\n    >>> zserver.INTEGRATION_TESTING.__bases__\n    (<Layer 'plone.testing.zserver.Startup'>,)\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zserver.INTEGRATION_TESTING, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zserver.Startup in ... seconds.\n    Set up plone.testing.zserver.IntegrationTesting in ... seconds.\n\nLet's now simulate a test.\nOn test setup, the ``app`` resource is made available.\nIn a test, you should always use this to access the application root.::\n\n    >>> zserver.STARTUP.testSetUp()\n    >>> zserver.INTEGRATION_TESTING.testSetUp()\n\nThe test may now inspect and modify the environment.::\n\n    >>> app = zserver.INTEGRATION_TESTING['app'] # would normally be self.layer['app']\n    >>> app.manage_addFolder('folder1')\n    >>> 'acl_users' in app.objectIds() and 'folder1' in app.objectIds()\n    True\n\nThe request is also available:::\n\n    >>> zserver.INTEGRATION_TESTING['request'] # would normally be self.layer['request']\n    <HTTPRequest, URL=http://nohost>\n\nWe can create a user and simulate logging in as that user, using the ``zserver.login()`` helper:::\n\n    >>> app._addRole('role1')\n    >>> ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])\n    >>> zserver.login(app['acl_users'], 'user1')\n\nThe first argument to ``zserver.login()`` is the user folder that contains the relevant user.\nThe second argument is the user's name.\nThere is no need to give the password.::\n\n    >>> from AccessControl import getSecurityManager\n    >>> getSecurityManager().getUser()\n    <User 'user1'>\n\nYou can change the roles of a user using the ``zserver.setRoles()`` helper:::\n\n    >>> sorted(getSecurityManager().getUser().getRolesInContext(app))\n    ['Authenticated', 'role1']\n\n    >>> zserver.setRoles(app['acl_users'], 'user1', [])\n    >>> getSecurityManager().getUser().getRolesInContext(app)\n    ['Authenticated']\n\nTo become the anonymous user again, use ``zserver.logout()``:::\n\n    >>> zserver.logout()\n    >>> getSecurityManager().getUser()\n    <SpecialUser 'Anonymous User'>\n\nOn tear-down, the transaction is rolled back:::\n\n    >>> zserver.INTEGRATION_TESTING.testTearDown()\n    >>> zserver.STARTUP.testTearDown()\n\n    >>> 'app' in zserver.INTEGRATION_TESTING\n    False\n\n    >>> 'request' in zserver.INTEGRATION_TESTING\n    False\n\n    >>> with zserver.zopeApp() as app:\n    ...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\n    True\n\n\nLet's tear down the layers:::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zserver.IntegrationTesting in ... seconds.\n    Tear down plone.testing.zserver.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\nFunctional testing\n~~~~~~~~~~~~~~~~~~\n\nThe ``FUNCTIONAL_TESTING`` layer is very similar to ``INTEGRATION_TESTING``, and exposes the same fixture and resources.\nHowever, it has different transaction semantics.\n``INTEGRATION_TESTING`` creates a single database storage, and rolls back the transaction after each test.\n``FUNCTIONAL_TESTING`` creates a whole new database storage (stacked on top of the basic fixture) for each test.\nThis allows testing of code that performs an explicit commit, which is usually required for end-to-end testing.\nThe downside is that the set-up and tear-down of each test takes longer.\n\n**Note:** Again, you would normally *not* use ``FUNCTIONAL_TESTING`` as a base layer.\nInstead, you'd use the ``FunctionalTesting`` class to create your own layer with the testing lifecycle semantics of ``FUNCTIONAL_TESTING``.\nSee the ``plone.testing`` ``README`` file for an example.\n\nLike ``INTEGRATION_TESTING``, ``FUNCTIONAL_TESTING`` is based on ``STARTUP``.::\n\n    >>> \"%s.%s\" % (zserver.FUNCTIONAL_TESTING.__module__, zserver.FUNCTIONAL_TESTING.__name__,)\n    'plone.testing.zserver.FunctionalTesting'\n\n    >>> zserver.FUNCTIONAL_TESTING.__bases__\n    (<Layer 'plone.testing.zserver.Startup'>,)\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zserver.FUNCTIONAL_TESTING, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zserver.Startup in ... seconds.\n    Set up plone.testing.zserver.FunctionalTesting in ... seconds.\n\nLet's now simulate a test.\nOn test setup, the ``app`` resource is made available.\nIn a test, you should always use this to access the application root.\nThe ``request`` resource can be used to access the test request.::\n\n    >>> zserver.STARTUP.testSetUp()\n    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n\nThe test may now inspect and modify the environment.\nIt may also commit things.::\n\n    >>> app = zserver.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']\n    >>> app.manage_addFolder('folder1')\n    >>> 'acl_users' in app.objectIds() and 'folder1' in app.objectIds()\n    True\n\n    >>> import transaction\n    >>> transaction.commit()\n\nOn tear-down, the database is torn down.::\n\n    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n    >>> zserver.STARTUP.testTearDown()\n\n    >>> 'app' in zserver.FUNCTIONAL_TESTING\n    False\n\n    >>> 'request' in zserver.FUNCTIONAL_TESTING\n    False\n\n    >>> with zserver.zopeApp() as app:\n    ...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\n    True\n\nLet's tear down the layer:::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zserver.FunctionalTesting in ... seconds.\n    Tear down plone.testing.zserver.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\nThe test browser\n~~~~~~~~~~~~~~~~\n\nThe ``FUNCTIONAL_TESTING`` layer and ``FunctionalTesting`` layer class are the basis for functional testing using ``zope.testbrowser``.\nThis simulates a web browser, allowing an application to be tested \"end-to-end\" via its user-facing interface.\n\nTo use the test browser with a ``FunctionalTesting`` layer (such as the default ``FUNCTIONAL_TESTING`` layer instance), we need to use a custom browser client, which ensures that the test browser uses the correct ZODB and is appropriately isolated from the test code.::\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zserver.FUNCTIONAL_TESTING, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zserver.Startup in ... seconds.\n    Set up plone.testing.zserver.FunctionalTesting in ... seconds.\n\nLet's simulate a test:::\n\n    >>> zserver.STARTUP.testSetUp()\n    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n\nIn the test, we can create a test browser client like so:::\n\n    >>> app = zserver.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']\n    >>> browser = zserver.Browser(app)\n\nIt is usually best to let Zope errors be shown with full tracebacks:::\n\n    >>> browser.handleErrors = False\n\nWe can add to the test fixture in the test.\nFor those changes to be visible to the test browser, however, we need to commit the transaction.::\n\n    >>> app.manage_addFolder('folder1')\n    >>> import transaction; transaction.commit()\n\nWe can now view this via the test browser:::\n\n    >>> browser.open(app.absolute_url() + '/folder1')\n\n    >>> browser.contents.replace('\"', '').replace(\"'\", \"\")\n    '<Folder ...'\n\nThe __repr__ of Zope objects is not stable anymore.\n\nThe test browser integration converts the URL into a request and passes control to Zope's publisher.\nLet's check that query strings are available for input processing:::\n\n    >>> import urllib\n    >>> qs = urllib.urlencode({'foo': 'boo, bar & baz'})  # sic: the ampersand.\n    >>> _ = app['folder1'].addDTMLMethod('index_html', file='<dtml-var foo>')\n    >>> import transaction; transaction.commit()\n    >>> browser.open(app.absolute_url() + '/folder1?' + qs)\n    >>> browser.contents\n    'boo, bar & baz'\n\nThe test browser also works with iterators.\nLet's test that with a simple file implementation that uses an iterator.::\n\n    >>> from plone.testing.tests import DummyFile\n    >>> app._setObject('file1', DummyFile('file1'))\n    'file1'\n\n    >>> import transaction; transaction.commit()\n\n    >>> browser.open(app.absolute_url() + '/file1')\n    >>> 'The test browser also works with iterators' in browser.contents\n    True\n\nSee the ``zope.testbrowser`` documentation for more information about how to use the browser client.\n\nOn tear-down, the database is torn down.::\n\n    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n    >>> zserver.STARTUP.testTearDown()\n\n    >>> 'app' in zserver.FUNCTIONAL_TESTING\n    False\n\n    >>> 'request' in zserver.FUNCTIONAL_TESTING\n    False\n\n    >>> with zserver.zopeApp() as app:\n    ...     'acl_users' in app.objectIds()\\\n    ...         and 'folder1' not in app.objectIds()\\\n    ...         and 'file1' not in app.objectIds()\n    True\n\nLet's tear down the layer:::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zserver.FunctionalTesting in ... seconds.\n    Tear down plone.testing.zserver.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\nHTTP server\n~~~~~~~~~~~\n\nThe ``ZSERVER_FIXTURE`` layer extends ``STARTUP`` to start a single-threaded Zope server in a separate thread.\nThis makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.\n\nThe ``ZSERVER`` layer provides a ``FunctionalTesting`` layer that has ``ZSERVER_FIXTURE`` as its base.::\n\n    >>> \"%s.%s\" % (zserver.ZSERVER_FIXTURE.__module__, zserver.ZSERVER_FIXTURE.__name__,)\n    'plone.testing.zserver.ZServer'\n\n    >>> zserver.ZSERVER_FIXTURE.__bases__\n    (<Layer 'plone.testing.zserver.Startup'>,)\n\n\n    >>> \"%s.%s\" % (zserver.ZSERVER.__module__, zserver.ZSERVER.__name__,)\n    'plone.testing.zserver.ZServer:Functional'\n\n    >>> zserver.ZSERVER.__bases__\n    (<Layer 'plone.testing.zserver.ZServer'>,)\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zserver.ZSERVER, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zserver.Startup in ... seconds.\n    Set up plone.testing.zserver.ZServer in ... seconds.\n    Set up plone.testing.zserver.ZServer:Functional in ... seconds.\n\nAfter layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n\n    >>> host = zserver.ZSERVER['host']\n    >>> port = zserver.ZSERVER['port']\n\nLet's now simulate a test.\nTest setup does nothing beyond what the base layers do.::\n\n    >>> zserver.STARTUP.testSetUp()\n    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n    >>> zserver.ZSERVER.testSetUp()\n\nIt is common in a test to use the Python API to change the state of the server (e.g.\ncreate some content or change a setting) and then use the HTTP protocol to look at the results.\nBear in mind that the server is running in a separate thread, with a separate security manager, so calls to ``zserver.login()`` and ``zserver.logout()``, for instance, do not affect the server thread.::\n\n    >>> app = zserver.ZSERVER['app'] # would normally be self.layer['app']\n    >>> app.manage_addFolder('folder1')\n\nNote that we need to commit the transaction before it will show up in the other thread.::\n\n    >>> import transaction; transaction.commit()\n\nWe can now look for this new object through the server.::\n\n    >>> app_url = app.absolute_url()\n    >>> app_url.split(':')[:-1]\n    ['http', '//localhost']\n\n    >>> import urllib2\n    >>> conn = urllib2.urlopen(app_url + '/folder1', timeout=5)\n    >>> conn.read().replace('\"', '').replace(\"'\", \"\")\n    '<Folder ...'\n    >>> conn.close()\n\nThe __repr__ of Zope objects is not stable anymore.\n\nTest tear-down does nothing beyond what the base layers do.::\n\n    >>> zserver.ZSERVER.testTearDown()\n    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n    >>> zserver.STARTUP.testTearDown()\n\n    >>> 'app' in zserver.ZSERVER\n    False\n\n    >>> 'request' in zserver.ZSERVER\n    False\n\n    >>> with zserver.zopeApp() as app:\n    ...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\n    True\n\nWhen the server is torn down, the ZServer thread is stopped.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zserver.ZServer:Functional in ... seconds.\n    Tear down plone.testing.zserver.ZServer in ... seconds.\n    Tear down plone.testing.zserver.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\nWe can expect one of these exceptions:\n- URLError: <urlopen error [Errno ...] Connection refused>\n- error: [Errno 104] Connection reset by peer\n\n    >>> try:\n    ...     conn = urllib2.urlopen(app_url + '/folder1', timeout=5)\n    ... except Exception as exc:\n    ...     if 'Connection refused' not in str(exc) and 'Connection reset' not in str(exc):\n    ...         raise exc\n    ... else:\n    ...     print('urllib2.urlopen should have raised exception')\n\n\nFTP server\n~~~~~~~~~~\n\nThe ``FTP_SERVER`` layer is identical similar to ``ZSERVER``, except that it starts an FTP server instead of an HTTP server.\nThe fixture is contained in the ``FTP_SERVER_FIXTURE`` layer.\n\n    **Warning:** It is generally not safe to run the ``ZSERVER`` and ``FTP_SERVER`` layers concurrently, because they both start up the same ``asyncore`` loop.\n    If you need concurrent HTTP and FTP servers in a test, you can create your own layer by subclassing the ``ZServer`` layer class, and overriding the ``setUpServer()`` and ``tearDownServer()`` hooks to set up and close both servers.\n    See the code for an example.\n\nThe ``FTP_SERVER_FIXTURE`` layer is based on the ``STARTUP`` layer.::\n\n    >>> \"%s.%s\" % (zserver.FTP_SERVER_FIXTURE.__module__, zserver.FTP_SERVER_FIXTURE.__name__,)\n    'plone.testing.zserver.FTPServer'\n\n    >>> zserver.FTP_SERVER_FIXTURE.__bases__\n    (<Layer 'plone.testing.zserver.Startup'>,)\n\nThe ``FTP_SERVER`` layer is based on ``FTP_SERVER_FIXTURE``, using the ``FunctionalTesting`` layer class.::\n\n    >>> \"%s.%s\" % (zserver.FTP_SERVER.__module__, zserver.FTP_SERVER.__name__,)\n    'plone.testing.zserver.FTPServer:Functional'\n\n    >>> zserver.FTP_SERVER.__bases__\n    (<Layer 'plone.testing.zserver.FTPServer'>,)\n\n    >>> options = runner.get_options([], [])\n    >>> setupLayers = {}\n    >>> runner.setup_layer(options, zserver.FTP_SERVER, setupLayers)\n    Set up plone.testing.zca.LayerCleanup in ... seconds.\n    Set up plone.testing.zserver.Startup in ... seconds.\n    Set up plone.testing.zserver.FTPServer in ... seconds.\n    Set up plone.testing.zserver.FTPServer:Functional in ... seconds.\n\nAfter layer setup, the resources ``host`` and ``port`` are available, and indicate where Zope is running.::\n\n    >>> host = zserver.FTP_SERVER['host']\n    >>> port = zserver.FTP_SERVER['port']\n\nLet's now simulate a test.\nTest setup does nothing beyond what the base layers do.::\n\n    >>> zserver.STARTUP.testSetUp()\n    >>> zserver.FUNCTIONAL_TESTING.testSetUp()\n    >>> zserver.FTP_SERVER.testSetUp()\n\nAs with ``ZSERVER``, we will set up some content for the test and then access it over the FTP port.::\n\n    >>> app = zserver.FTP_SERVER['app'] # would normally be self.layer['app']\n    >>> app.manage_addFolder('folder1')\n\nWe'll also create a user in the root user folder to make FTP access easier.::\n\n    >>> ignore = app['acl_users'].userFolderAddUser('admin', 'secret', ['Manager'], ())\n\nNote that we need to commit the transaction before it will show up in the other thread.::\n\n    >>> import transaction; transaction.commit()\n\nWe can now look for this new object through the server.::\n\n    >>> app_path = app.absolute_url_path()\n\n    >>> import ftplib\n    >>> ftpClient = ftplib.FTP()\n    >>> ftpClient.connect(host, port, timeout=5)\n    '220 ... FTP server (...) ready.'\n\n    >>> ftpClient.login('admin', 'secret')\n    '230 Login successful.'\n\n    >>> ftpClient.cwd(app_path)\n    '250 CWD command successful.'\n\n    >>> ftpClient.retrlines('LIST')\n    drwxrwx---   1 Zope     Zope            0 ... .\n    ...--w--w----   1 Zope     Zope            0 ... acl_users\n    drwxrwx---   1 Zope     Zope            0 ... folder1\n    '226 Transfer complete'\n\n    >>> ftpClient.quit()\n    '221 Goodbye.'\n\nTest tear-down does nothing beyond what the base layers do.::\n\n    >>> zserver.FTP_SERVER.testTearDown()\n    >>> zserver.FUNCTIONAL_TESTING.testTearDown()\n    >>> zserver.STARTUP.testTearDown()\n\n    >>> 'app' in zserver.ZSERVER\n    False\n\n    >>> 'request' in zserver.ZSERVER\n    False\n\n    >>> with zserver.zopeApp() as app:\n    ...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\n    True\n\nWhen the server is torn down, the FTP thread is stopped.::\n\n    >>> runner.tear_down_unneeded(options, [], setupLayers, [])\n    Tear down plone.testing.zserver.FTPServer:Functional in ... seconds.\n    Tear down plone.testing.zserver.FTPServer in ... seconds.\n    Tear down plone.testing.zserver.Startup in ... seconds.\n    Tear down plone.testing.zca.LayerCleanup in ... seconds.\n\n    >>> ftpClient.connect(host, port, timeout=5)\n    Traceback (most recent call last):\n    ...\n    error: [Errno ...] Connection refused\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/plone/plone.testing", "keywords": "plone zope testing", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "plone.testing", "package_url": "https://pypi.org/project/plone.testing/", "platform": "", "project_url": "https://pypi.org/project/plone.testing/", "project_urls": {"Homepage": "https://github.com/plone/plone.testing"}, "release_url": "https://pypi.org/project/plone.testing/8.0.0/", "requires_dist": ["setuptools", "six", "zope.testing (>=3.8)", "zope.browsermenu ; extra == 'publisher'", "zope.browserpage ; extra == 'publisher'", "zope.browserresource ; extra == 'publisher'", "zope.configuration ; extra == 'publisher'", "zope.publisher ; extra == 'publisher'", "zope.security ; extra == 'publisher'", "zope.security ; extra == 'security'", "WebTest ; extra == 'test'", "ZODB ; extra == 'test'", "Zope ; extra == 'test'", "zope.browsermenu ; extra == 'test'", "zope.browserpage ; extra == 'test'", "zope.browserresource ; extra == 'test'", "zope.component ; extra == 'test'", "zope.configuration ; extra == 'test'", "zope.event ; extra == 'test'", "zope.interface ; extra == 'test'", "zope.publisher ; extra == 'test'", "zope.security ; extra == 'test'", "zope.testbrowser ; extra == 'test'", "zope.testrunner ; extra == 'test'", "zope.component ; extra == 'zca'", "zope.configuration ; extra == 'zca'", "zope.event ; extra == 'zca'", "ZODB ; extra == 'zodb'", "WebTest ; extra == 'zope'", "Zope ; extra == 'zope'", "zope.component ; extra == 'zope'", "zope.publisher ; extra == 'zope'", "zope.testbrowser ; extra == 'zope'", "ZServer ; extra == 'zserver'"], "requires_python": "", "summary": "Testing infrastructure for Zope and Plone projects.", "version": "8.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2><a href=\"#id55\" rel=\"nofollow\">Introduction</a></h2>\n<div id=\"table-of-contents\">\n<p>Table of contents</p>\n<ul>\n<li><a href=\"#introduction\" id=\"id55\" rel=\"nofollow\">Introduction</a><ul>\n<li><a href=\"#compatibility\" id=\"id56\" rel=\"nofollow\">Compatibility</a></li>\n<li><a href=\"#definitions\" id=\"id57\" rel=\"nofollow\">Definitions</a></li>\n</ul>\n</li>\n<li><a href=\"#installation-and-usage\" id=\"id58\" rel=\"nofollow\">Installation and usage</a><ul>\n<li><a href=\"#coverage-reporting\" id=\"id59\" rel=\"nofollow\">Coverage reporting</a></li>\n<li><a href=\"#optional-dependencies\" id=\"id60\" rel=\"nofollow\">Optional dependencies</a></li>\n<li><a href=\"#adding-a-test-buildout-to-your-package\" id=\"id61\" rel=\"nofollow\">Adding a test buildout to your package</a></li>\n</ul>\n</li>\n<li><a href=\"#layers\" id=\"id62\" rel=\"nofollow\">Layers</a><ul>\n<li><a href=\"#layer-basics\" id=\"id63\" rel=\"nofollow\">Layer basics</a></li>\n<li><a href=\"#writing-layers\" id=\"id64\" rel=\"nofollow\">Writing layers</a></li>\n<li><a href=\"#advanced-overriding-bases\" id=\"id65\" rel=\"nofollow\">Advanced - overriding bases</a></li>\n<li><a href=\"#layer-combinations\" id=\"id66\" rel=\"nofollow\">Layer combinations</a></li>\n<li><a href=\"#layer-resources\" id=\"id67\" rel=\"nofollow\">Layer resources</a></li>\n</ul>\n</li>\n<li><a href=\"#writing-tests\" id=\"id68\" rel=\"nofollow\">Writing tests</a><ul>\n<li><a href=\"#python-tests\" id=\"id69\" rel=\"nofollow\">Python tests</a><ul>\n<li><a href=\"#unittest\" id=\"id70\" rel=\"nofollow\">unittest</a></li>\n<li><a href=\"#test-modules-classes-and-functions\" id=\"id71\" rel=\"nofollow\">Test modules, classes and functions</a></li>\n<li><a href=\"#test-suites\" id=\"id72\" rel=\"nofollow\">Test suites</a></li>\n</ul>\n</li>\n<li><a href=\"#doctests\" id=\"id73\" rel=\"nofollow\">Doctests</a><ul>\n<li><a href=\"#docstring-doctests\" id=\"id74\" rel=\"nofollow\">Docstring doctests</a></li>\n<li><a href=\"#file-doctests\" id=\"id75\" rel=\"nofollow\">File doctests</a></li>\n<li><a href=\"#doctest-fixtures-and-layers\" id=\"id76\" rel=\"nofollow\">Doctest fixtures and layers</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#zope-testing-tools\" id=\"id77\" rel=\"nofollow\">Zope testing tools</a><ul>\n<li><a href=\"#test-cleanup\" id=\"id78\" rel=\"nofollow\">Test cleanup</a></li>\n<li><a href=\"#event-testing\" id=\"id79\" rel=\"nofollow\">Event testing</a></li>\n<li><a href=\"#mock-requests\" id=\"id80\" rel=\"nofollow\">Mock requests</a></li>\n<li><a href=\"#registering-components\" id=\"id81\" rel=\"nofollow\">Registering components</a></li>\n<li><a href=\"#loading-zcml\" id=\"id82\" rel=\"nofollow\">Loading ZCML</a></li>\n<li><a href=\"#installing-a-zope-product\" id=\"id83\" rel=\"nofollow\">Installing a Zope product</a></li>\n<li><a href=\"#functional-testing\" id=\"id84\" rel=\"nofollow\">Functional testing</a></li>\n</ul>\n</li>\n<li><a href=\"#layer-reference\" id=\"id85\" rel=\"nofollow\">Layer reference</a><ul>\n<li><a href=\"#zope-component-architecture\" id=\"id86\" rel=\"nofollow\">Zope Component Architecture</a><ul>\n<li><a href=\"#unit-testing\" id=\"id87\" rel=\"nofollow\">Unit testing</a></li>\n<li><a href=\"#id1\" id=\"id88\" rel=\"nofollow\">Event testing</a></li>\n<li><a href=\"#layer-cleanup\" id=\"id89\" rel=\"nofollow\">Layer cleanup</a></li>\n<li><a href=\"#basic-zcml-directives\" id=\"id90\" rel=\"nofollow\">Basic ZCML directives</a></li>\n<li><a href=\"#zcml-files-helper-class\" id=\"id91\" rel=\"nofollow\">ZCML files helper class</a></li>\n<li><a href=\"#helper-functions\" id=\"id92\" rel=\"nofollow\">Helper functions</a></li>\n</ul>\n</li>\n<li><a href=\"#zope-security\" id=\"id93\" rel=\"nofollow\">Zope Security</a><ul>\n<li><a href=\"#security-checker-isolation\" id=\"id94\" rel=\"nofollow\">Security checker isolation</a></li>\n<li><a href=\"#id2\" id=\"id95\" rel=\"nofollow\">Helper functions</a></li>\n</ul>\n</li>\n<li><a href=\"#zope-publisher\" id=\"id96\" rel=\"nofollow\">Zope Publisher</a><ul>\n<li><a href=\"#publisher-directives\" id=\"id97\" rel=\"nofollow\">Publisher directives</a></li>\n</ul>\n</li>\n<li><a href=\"#zodb\" id=\"id98\" rel=\"nofollow\">ZODB</a><ul>\n<li><a href=\"#empty-zodb-sandbox\" id=\"id99\" rel=\"nofollow\">Empty ZODB sandbox</a></li>\n<li><a href=\"#id3\" id=\"id100\" rel=\"nofollow\">Helper functions</a></li>\n</ul>\n</li>\n<li><a href=\"#zope\" id=\"id101\" rel=\"nofollow\">Zope</a><ul>\n<li><a href=\"#startup\" id=\"id102\" rel=\"nofollow\">Startup</a></li>\n<li><a href=\"#integration-test\" id=\"id103\" rel=\"nofollow\">Integration test</a></li>\n<li><a href=\"#id4\" id=\"id104\" rel=\"nofollow\">Functional testing</a></li>\n<li><a href=\"#integration-and-functional-testing-with-custom-fixtures\" id=\"id105\" rel=\"nofollow\">Integration and functional testing with custom fixtures</a></li>\n<li><a href=\"#http-wsgi-server-thread-fixture-only\" id=\"id106\" rel=\"nofollow\">HTTP WSGI server thread (fixture only)</a></li>\n<li><a href=\"#http-wsgi-server-functional-testing\" id=\"id107\" rel=\"nofollow\">HTTP WSGI server functional testing</a></li>\n<li><a href=\"#id5\" id=\"id108\" rel=\"nofollow\">Helper functions</a></li>\n</ul>\n</li>\n<li><a href=\"#zserver\" id=\"id109\" rel=\"nofollow\">ZServer</a><ul>\n<li><a href=\"#id6\" id=\"id110\" rel=\"nofollow\">Startup</a></li>\n<li><a href=\"#id7\" id=\"id111\" rel=\"nofollow\">Integration test</a></li>\n<li><a href=\"#id8\" id=\"id112\" rel=\"nofollow\">Functional testing</a></li>\n<li><a href=\"#id9\" id=\"id113\" rel=\"nofollow\">Integration and functional testing with custom fixtures</a></li>\n<li><a href=\"#http-zserver-thread-fixture-only\" id=\"id114\" rel=\"nofollow\">HTTP ZServer thread (fixture only)</a></li>\n<li><a href=\"#http-zserver-functional-testing\" id=\"id115\" rel=\"nofollow\">HTTP ZServer functional testing</a></li>\n<li><a href=\"#ftp-server-thread-fixture-only\" id=\"id116\" rel=\"nofollow\">FTP server thread (fixture only)</a></li>\n<li><a href=\"#ftp-server-functional-testing\" id=\"id117\" rel=\"nofollow\">FTP server functional testing</a></li>\n<li><a href=\"#id10\" id=\"id118\" rel=\"nofollow\">Helper functions</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#changelog\" id=\"id119\" rel=\"nofollow\">Changelog</a><ul>\n<li><a href=\"#id13\" id=\"id120\" rel=\"nofollow\">8.0.0 (2020-04-21)</a></li>\n<li><a href=\"#id14\" id=\"id121\" rel=\"nofollow\">7.0.3 (2019-12-10)</a></li>\n<li><a href=\"#id15\" id=\"id122\" rel=\"nofollow\">7.0.2 (2019-07-06)</a></li>\n<li><a href=\"#id16\" id=\"id123\" rel=\"nofollow\">7.0.1 (2019-03-03)</a></li>\n<li><a href=\"#id17\" id=\"id124\" rel=\"nofollow\">7.0.0 (2018-10-17)</a></li>\n<li><a href=\"#id18\" id=\"id125\" rel=\"nofollow\">6.1.0 (2018-10-05)</a></li>\n<li><a href=\"#id19\" id=\"id126\" rel=\"nofollow\">6.0.0 (2018-02-05)</a></li>\n<li><a href=\"#id20\" id=\"id127\" rel=\"nofollow\">5.1.1 (2017-04-19)</a></li>\n<li><a href=\"#id21\" id=\"id128\" rel=\"nofollow\">5.1 (2017-04-13)</a></li>\n<li><a href=\"#id22\" id=\"id129\" rel=\"nofollow\">5.0.0 (2016-02-19)</a></li>\n<li><a href=\"#id23\" id=\"id130\" rel=\"nofollow\">4.2.0 (2016-02-18)</a></li>\n<li><a href=\"#id24\" id=\"id131\" rel=\"nofollow\">4.1.0 (2016-01-08)</a></li>\n<li><a href=\"#id25\" id=\"id132\" rel=\"nofollow\">4.0.15 (2015-08-14)</a></li>\n<li><a href=\"#id26\" id=\"id133\" rel=\"nofollow\">4.0.14 (2015-07-29)</a></li>\n<li><a href=\"#id27\" id=\"id134\" rel=\"nofollow\">4.0.13 (2015-03-13)</a></li>\n<li><a href=\"#id28\" id=\"id135\" rel=\"nofollow\">4.0.12 (2014-09-07)</a></li>\n<li><a href=\"#id29\" id=\"id136\" rel=\"nofollow\">4.0.11 (2014-02-22)</a></li>\n<li><a href=\"#id30\" id=\"id137\" rel=\"nofollow\">4.0.10 (2014-02-11)</a></li>\n<li><a href=\"#id31\" id=\"id138\" rel=\"nofollow\">4.0.9 (2014-01-28)</a></li>\n<li><a href=\"#id32\" id=\"id139\" rel=\"nofollow\">4.0.8 (2013-03-05)</a></li>\n<li><a href=\"#id33\" id=\"id140\" rel=\"nofollow\">4.0.7 (2012-12-09)</a></li>\n<li><a href=\"#id34\" id=\"id141\" rel=\"nofollow\">4.0.6 (2012-10-15)</a></li>\n<li><a href=\"#id35\" id=\"id142\" rel=\"nofollow\">4.0.5 (2012-10-15)</a></li>\n<li><a href=\"#id36\" id=\"id143\" rel=\"nofollow\">4.0.4 (2012-08-04)</a></li>\n<li><a href=\"#id37\" id=\"id144\" rel=\"nofollow\">4.0.3 (2011-11-24)</a></li>\n<li><a href=\"#id38\" id=\"id145\" rel=\"nofollow\">4.0.2 (2011-08-31)</a></li>\n<li><a href=\"#id39\" id=\"id146\" rel=\"nofollow\">4.0.1 - 2011-05-20</a></li>\n<li><a href=\"#id40\" id=\"id147\" rel=\"nofollow\">4.0 - 2011-05-13</a></li>\n<li><a href=\"#a6-2011-04-06\" id=\"id148\" rel=\"nofollow\">4.0a6 - 2011-04-06</a></li>\n<li><a href=\"#a5-2011-03-02\" id=\"id149\" rel=\"nofollow\">4.0a5 - 2011-03-02</a></li>\n<li><a href=\"#a4-2011-01-11\" id=\"id150\" rel=\"nofollow\">4.0a4 - 2011-01-11</a></li>\n<li><a href=\"#a3-2010-12-14\" id=\"id151\" rel=\"nofollow\">4.0a3 - 2010-12-14</a></li>\n<li><a href=\"#a2-2010-09-05\" id=\"id152\" rel=\"nofollow\">1.0a2 - 2010-09-05</a></li>\n<li><a href=\"#a1-2010-08-01\" id=\"id153\" rel=\"nofollow\">1.0a1 - 2010-08-01</a></li>\n</ul>\n</li>\n<li><a href=\"#detailed-documentation\" id=\"id154\" rel=\"nofollow\">Detailed documentation</a><ul>\n<li><a href=\"#layer-base-class\" id=\"id155\" rel=\"nofollow\">Layer base class</a><ul>\n<li><a href=\"#using-layer-as-a-base-class\" id=\"id156\" rel=\"nofollow\">Using <tt>Layer</tt> as a base class</a></li>\n<li><a href=\"#overriding-the-default-list-of-bases\" id=\"id157\" rel=\"nofollow\">Overriding the default list of bases</a></li>\n<li><a href=\"#inconsistent-bases\" id=\"id158\" rel=\"nofollow\">Inconsistent bases</a></li>\n<li><a href=\"#using-the-resource-manager\" id=\"id159\" rel=\"nofollow\">Using the resource manager</a><ul>\n<li><a href=\"#asymmetric-deletion\" id=\"id160\" rel=\"nofollow\">Asymmetric deletion</a></li>\n</ul>\n</li>\n<li><a href=\"#doctest-layer-helper\" id=\"id161\" rel=\"nofollow\">Doctest layer helper</a></li>\n</ul>\n</li>\n<li><a href=\"#zope-component-architecture-layers\" id=\"id162\" rel=\"nofollow\">Zope Component Architecture layers</a><ul>\n<li><a href=\"#id41\" id=\"id163\" rel=\"nofollow\">Unit testing</a></li>\n<li><a href=\"#id42\" id=\"id164\" rel=\"nofollow\">Event testing</a></li>\n<li><a href=\"#id43\" id=\"id165\" rel=\"nofollow\">Layer cleanup</a></li>\n<li><a href=\"#id44\" id=\"id166\" rel=\"nofollow\">Basic ZCML directives</a></li>\n<li><a href=\"#configuration-registry-sandboxing\" id=\"id167\" rel=\"nofollow\">Configuration registry sandboxing</a></li>\n<li><a href=\"#id45\" id=\"id168\" rel=\"nofollow\">ZCML files helper class</a></li>\n</ul>\n</li>\n<li><a href=\"#security\" id=\"id169\" rel=\"nofollow\">Security</a><ul>\n<li><a href=\"#id46\" id=\"id170\" rel=\"nofollow\">Layers</a></li>\n</ul>\n</li>\n<li><a href=\"#zope-publisher-layers\" id=\"id171\" rel=\"nofollow\">Zope Publisher layers</a><ul>\n<li><a href=\"#zcml-directives\" id=\"id172\" rel=\"nofollow\">ZCML directives</a></li>\n</ul>\n</li>\n<li><a href=\"#zope-object-database-layers\" id=\"id173\" rel=\"nofollow\">Zope Object Database layers</a><ul>\n<li><a href=\"#empty-zodb-layer\" id=\"id174\" rel=\"nofollow\">Empty ZODB layer</a></li>\n<li><a href=\"#extending-the-zodb-layer\" id=\"id175\" rel=\"nofollow\">Extending the ZODB layer</a></li>\n<li><a href=\"#stacking-demostorage-storages\" id=\"id176\" rel=\"nofollow\">Stacking <tt>DemoStorage</tt> storages</a></li>\n</ul>\n</li>\n<li><a href=\"#zope-wsgi-layers\" id=\"id177\" rel=\"nofollow\">Zope WSGI layers</a><ul>\n<li><a href=\"#id47\" id=\"id178\" rel=\"nofollow\">Startup</a></li>\n<li><a href=\"#id48\" id=\"id179\" rel=\"nofollow\">Integration test</a></li>\n<li><a href=\"#id49\" id=\"id180\" rel=\"nofollow\">Functional testing</a></li>\n<li><a href=\"#the-test-browser\" id=\"id181\" rel=\"nofollow\">The test browser</a></li>\n<li><a href=\"#http-server\" id=\"id182\" rel=\"nofollow\">HTTP server</a></li>\n</ul>\n</li>\n<li><a href=\"#zope-2-layers\" id=\"id183\" rel=\"nofollow\">Zope 2 layers</a><ul>\n<li><a href=\"#id50\" id=\"id184\" rel=\"nofollow\">Startup</a></li>\n<li><a href=\"#id51\" id=\"id185\" rel=\"nofollow\">Integration test</a></li>\n<li><a href=\"#id52\" id=\"id186\" rel=\"nofollow\">Functional testing</a></li>\n<li><a href=\"#id53\" id=\"id187\" rel=\"nofollow\">The test browser</a></li>\n<li><a href=\"#id54\" id=\"id188\" rel=\"nofollow\">HTTP server</a></li>\n<li><a href=\"#ftp-server\" id=\"id189\" rel=\"nofollow\">FTP server</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<p><tt>plone.testing</tt> provides tools for writing unit and integration tests in a Zope and Plone environment.\nIt is not tied to Plone, and it does not depend on Zope (although it has some optional Zope-only features).</p>\n<p><tt>plone.testing</tt> builds on <a href=\"https://pypi.org/project/zope.testing/\" rel=\"nofollow\">zope.testing</a>, in particular its layers concept.\nThis package also aims to promote some \u201cgood practice\u201d for writing tests of various types.</p>\n<div>\n<p>Note</p>\n<p>If you are working with Plone, there is a complementary package <a href=\"https://pypi.org/project/plone.app.testing\" rel=\"nofollow\">plone.app.testing</a>, which builds on <tt>plone.testing</tt> to provide additional layers useful for testing Plone add-ons.</p>\n</div>\n<p>If you are new to automated testing and test driven development, you should spend some time learning about those concepts.\nSome useful references include:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Unit_testing\" rel=\"nofollow\">The Wikipedia article on unit testing</a></li>\n<li><a href=\"https://diveintopython3.problemsolving.io/unit-testing.html\" rel=\"nofollow\">The Dive Into Python chapter on testing</a></li>\n</ul>\n<p>Bear in mind that different Python frameworks have slightly different takes on how to approach testing.\nTherefore, you may find examples that are different to those shown below.\nThe core concepts should be consistent, however.</p>\n<div id=\"compatibility\">\n<h3><a href=\"#id56\" rel=\"nofollow\">Compatibility</a></h3>\n<p><tt>plone.testing</tt> 7.x has been tested with Python 2.7 and 3.6.\nIf you\u2019re using the optional Zope layers, you must use Zope version 4 or later.\nLook at older <tt>plone.testing</tt> versions for supporting older Zope versions.</p>\n</div>\n<div id=\"definitions\">\n<h3><a href=\"#id57\" rel=\"nofollow\">Definitions</a></h3>\n<p>In this documentation, we will use a number of testing-related terms.\nThe following definitions apply:</p>\n<dl>\n<dt>Unit test</dt>\n<dd>An automated test (i.e. one written in code) that tests a single unit (normally a function) in isolation.\nA unit test attempts to prove that the given function works as expected and gives the correct output given a particular input.\nIt is common to have a number of unit tests for a single function, testing different inputs, including boundary cases and errors.\nUnit tests are typically quick to write and run.</dd>\n<dt>Integration test</dt>\n<dd>An automated test that tests how a number of units interact.\nIn a Zope context, this often pertains to how a particular object or view interacts with the Zope framework, the ZODB persistence engine, and so on.\nIntegration tests usually require some setup and can be slower to run than unit tests.\nIt is common to have fewer integration tests than unit test.</dd>\n<dt>Functional test</dt>\n<dd>An automated test that tests a feature in an \u201cend-to-end\u201d fashion.\nIn a Zope context, that normally means that it invokes an action in the same way that a user would, i.e. through a web request.\nFunctional tests are normally slower to run than either unit or integration tests, and can be significantly slower to run.\nIt is therefore common to have only a few functional tests for each major feature, relying on unit and integration tests for the bulk of testing.</dd>\n<dt>Black box testing</dt>\n<dd>Testing which only considers the system\u2019s defined inputs and outputs.\nFor example, a functional test is normally a black box test that provides inputs only through the defined interface (e.g. URLs published in a web application), and makes assertions only on end outputs (e.g. the response returned for requests to those URLs).</dd>\n<dt>White box testing</dt>\n<dd>Testing which examines the internal state of a system to make assertions.\nAuthors of unit and integration tests normally have significant knowledge of the implementation of the code under test, and can examine such things as data in a database or changes to the system\u2019s environment to determine if the test succeeded or failed.</dd>\n<dt>Assertion</dt>\n<dd>A check that determines whether a test succeeds or fails.\nFor example, if a unit test for the function <tt>foo()</tt> expects it to return the value 1, an assertion could be written to verify this fact.\nA test is said to <em>fail</em> if any of its assertions fail.\nA test always contains one or more assertions.</dd>\n<dt>Test case</dt>\n<dd>A single unit, integration or functional test.\nOften shortened to just <em>test</em>.\nA test case sets up, executes and makes assertions against a single scenario that bears testing.</dd>\n<dt>Test fixture</dt>\n<dd>The state used as a baseline for one or more tests.\nThe test fixture is <em>set up</em> before each test is executed, and <em>torn down</em> afterwards.\nThis is a pre-requisite for <em>test isolation</em> - the principle that tests should be independent of one another.</dd>\n<dt>Layer</dt>\n<dd>The configuration of a test fixture shared by a number of tests.\nAll test cases that belong to a particular layer will be executed together.\nThe layer is <em>set up</em> once before the tests are executed, and <em>torn down</em> once after.\nLayers may depend on one another.\nAny <em>base layers</em> are set up before and torn down after a particular <em>child layer</em> is used.\nThe test runner will order test execution to minimise layer setup and tear-down.</dd>\n<dt>Test suite</dt>\n<dd>A collection of test cases (and layers) that are executed together.</dd>\n<dt>Test runner</dt>\n<dd>The program which executes tests.\nThis is responsible for calling layer and test fixture set-up and tear-down methods.\nIt also reports on the test run, usually by printing output to the console.</dd>\n<dt>Coverage</dt>\n<dd>To have confidence in your code, you should ensure it is adequately covered by tests.\nThat is, each line of code, and each possible branching point (loops, <tt>if</tt> statements) should be executed by a test.\nThis is known as <em>coverage</em>, and is normally measured as a percentage of lines of non-test code covered by tests.\nCoverage can be measured by the test runner, which keeps track of which lines of code were executed in a given test run.</dd>\n<dt>Doctest</dt>\n<dd>A style of testing where tests are written as examples that could be typed into the interactive Python interpreter.\nThe test runner executes each example and checks the actual output against the expected output.\nDoctests can either be placed in the docstring of a method, or in a separate file.\nThe use of doctests is largely a personal preference.\nSome developers like to write documentation as doctests, which has the advantage that code samples can be automatically tested for correctness.\nYou can read more about doctests on <a href=\"http://en.wikipedia.org/wiki/Doctest\" rel=\"nofollow\">Wikipedia</a>.</dd>\n</dl>\n</div>\n</div>\n<div id=\"installation-and-usage\">\n<h2><a href=\"#id58\" rel=\"nofollow\">Installation and usage</a></h2>\n<p>To use <tt>plone.testing</tt> in your own package, you need to add it as a dependency.\nMost people prefer to keep test-only dependencies separate, so that they do not need to be installed in scenarios (such as on a production server) where the tests will not be run.\nThis can be achieved using a <tt>test</tt> extra.</p>\n<p>In <tt>setup.py</tt>, add or modify the <tt>extras_require</tt> option, like so::</p>\n<pre>extras_require = {\n    'test': [\n            'plone.testing',\n        ]\n},\n</pre>\n<p>You can add other test-only dependencies to that list as well, of course.</p>\n<p>To run tests, you need a test runner.\nIf you are using <tt>zc.buildout</tt>, you can install a test runner using the <a href=\"https://pypi.org/project/zc.recipe.testrunner\" rel=\"nofollow\">zc.recipe.testrunner</a> recipe.\nFor example, you could add the following to your <tt>buildout.cfg</tt>::</p>\n<pre>[test]\nrecipe = zc.recipe.testrunner\neggs =\n    my.package [test]\ndefaults = ['--auto-color', '--auto-progress']\n</pre>\n<p>You\u2019ll also need to add this part to the <tt>parts</tt> list, of course::</p>\n<pre>[buildout]\nparts =\n    ...\n    test\n</pre>\n<p>In this example, have listed a single package to test, called <tt>my.package</tt>, and asked for it to be installed with the <tt>[test]</tt> extra.\nThis will install any regular dependencies (listed in the <tt>install_requires</tt> option in <tt>setup.py</tt>), as well as those in the list associated with the <tt>test</tt> key in the <tt>extras_require</tt> option.</p>\n<p>Note that it becomes important to properly list your dependencies here, because the test runner will only be aware of the packages explicitly listed, and their dependencies.\nFor example, if your package depends on Zope, you need to list <tt>Zope</tt> in the <tt>install_requires</tt> list in <tt>setup.py</tt>;\nditto for <tt>Plone</tt>, or indeed any other package you import from.</p>\n<p>Once you have re-run buildout, the test runner will be installed as <tt>bin/test</tt> (the executable name is taken from the name of the buildout part).\nYou can execute it without arguments to run all tests of each egg listed in the <tt>eggs</tt> list:</p>\n<pre>$ bin/test\n</pre>\n<p>If you have listed several eggs, and you want to run the tests for a particular one, you can do:</p>\n<pre>$ bin/test -s my.package\n</pre>\n<p>If you want to run only a particular test within this package, use the <tt><span class=\"pre\">-t</span></tt> option.\nThis can be passed a regular expression matching either a doctest file name or a test method name.:</p>\n<pre>$ bin/test -s my.package -t test_spaceship\n</pre>\n<p>There are other command line options, which you can find by running:</p>\n<pre>$ bin/test --help\n</pre>\n<p>Also note the <tt>defaults</tt> option in the buildout configuration.\nThis can be used to set default command line options.\nSome commonly useful options are shown above.</p>\n<div id=\"coverage-reporting\">\n<h3><a href=\"#id59\" rel=\"nofollow\">Coverage reporting</a></h3>\n<p>When writing tests, it is useful to know how well your tests cover your code.\nYou can create coverage reports via the excellent <a href=\"https://pypi.org/project/coverage\" rel=\"nofollow\">coverage</a> library.\nIn order to use it, we need to install it and a reporting script:</p>\n<pre>[buildout]\nparts =\n    ...\n    test\n    coverage\n    report\n\n[coverage]\nrecipe = zc.recipe.egg\neggs = coverage\ninitialization =\n    include = '--source=${buildout:directory}/src'\n    sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all']\n\n[report]\nrecipe = zc.recipe.egg\neggs = coverage\nscripts = coverage=report\ninitialization =\n    sys.argv = sys.argv[:] + ['html', '-i']\n</pre>\n<p>This will run the <tt>bin/test</tt> script with arguments like <cite>\u2013all</cite> to run all layers.\nYou can also specify no or some other arguments.\nIt will place coverage reporting information in a <tt>.coverage</tt> file inside your buildout root.\nVia the <tt><span class=\"pre\">--source</span></tt> argument you specify the directories containing code you want to cover.\nThe coverage script would otherwise generate coverage information for all executed code, including other packages and even the standard library.</p>\n<p>Running the <tt>bin/report</tt> script will generate a human readable HTML representation of the run in the <cite>htmlcov</cite> directory.\nOpen the contained <cite>index.html</cite> in a browser to see the result.</p>\n<p>If you want to generate an XML representation suitable for the <a href=\"https://wiki.jenkins.io/display/JENKINS/Cobertura+Plugin\" rel=\"nofollow\">Cobertura</a> plugin of <a href=\"https://jenkins.io\" rel=\"nofollow\">Jenkins</a>, you can add another part:</p>\n<pre>[buildout]\nparts =\n    ...\n    report-xml\n\n[report-xml]\nrecipe = zc.recipe.egg\neggs = coverage\nscripts = coverage=report-xml\ninitialization =\n    sys.argv = sys.argv[:] + ['xml', '-i']\n</pre>\n<p>This will generate a <tt>coverage.xml</tt> file in the buildout root.</p>\n</div>\n<div id=\"optional-dependencies\">\n<h3><a href=\"#id60\" rel=\"nofollow\">Optional dependencies</a></h3>\n<p><tt>plone.testing</tt> comes with a core set of tools for managing layers, which depends only on <a href=\"https://pypi.org/project/zope.testing/\" rel=\"nofollow\">zope.testing</a>.\nIn addition, there are several layers and helper functions which can be used in your own tests (or as bases for your own layers).\nSome of these have deeper dependencies.\nHowever, these dependencies are optional and not installed by default.\nIf you don\u2019t use the relevant layers, you can safely ignore them.</p>\n<p><tt>plone.testing</tt> does specify these dependencies, however, using the <tt>setuptools</tt> \u201cextras\u201d feature.\nYou can depend on one or more extras in your own <tt>setup.py</tt> <tt>install_requires</tt> or <tt>extras_require</tt> option using the same square bracket notation shown for the <tt>[test]</tt> buildout part above.\nFor example, if you need both the <tt>zca</tt> and <tt>publisher</tt> extras, you can have the following in your <tt>setup.py</tt>:</p>\n<pre>extras_require = {\n    'test': [\n            'plone.testing [zca, publisher]',\n        ]\n},\n</pre>\n<p>The available extras are:</p>\n<dl>\n<dt><tt>zodb</tt></dt>\n<dd>ZODB testing.\nDepends on <tt>ZODB</tt>.\nThe relevant layers and helpers are in the module <tt>plone.testing.zodb</tt>.</dd>\n<dt><tt>zca</tt></dt>\n<dd>Zope Component Architecture testing.\nDepends on core Zope Component Architecture packages such as <tt>zope.component</tt> and <tt>zope.event</tt>.\nThe relevant layers and helpers are in the module <tt>plone.testing.zca</tt>.</dd>\n<dt><tt>security</tt></dt>\n<dd>Security testing.\nDepends on <tt>zope.security</tt>.\nThe relevant layers and helpers are in the module <tt>plone.testing.security</tt>.</dd>\n<dt><tt>publisher</tt></dt>\n<dd>Zope Publisher testing.\nDepends on <tt>zope.publisher</tt>, <tt>zope.browsermenu</tt>, <tt>zope.browserpage</tt>, <tt>zope.browserresource</tt> and <tt>zope.security</tt> and sets up ZCML directives.\nThe relevant layers and helpers are in the module <tt>plone.testing.publisher</tt>.</dd>\n</dl>\n<p><tt>zope</tt> (For backwards compatibility there is also <tt>z2</tt>.)</p>\n<blockquote>\nZope testing.\nDepends on the <tt>Zope</tt> egg, which includes all the dependencies of the Zope application server.\nThe relevant layers and helpers are in the module <tt>plone.testing.zope</tt>.</blockquote>\n<p><tt>zserver</tt></p>\n<blockquote>\nTests against the <tt>ZServer</tt>. (Python 2 only!) Requires additionally to use the <tt>zope</tt> extra.\nThe relevant layers and helpers are in the module <tt>plone.testing.zserver</tt></blockquote>\n</div>\n<div id=\"adding-a-test-buildout-to-your-package\">\n<h3><a href=\"#id61\" rel=\"nofollow\">Adding a test buildout to your package</a></h3>\n<p>When creating re-usable, mostly stand-alone packages, it is often useful to be able to include a buildout with the package sources itself that can be used to create a test runner.\nThis is a popular approach for many Zope packages, for example.\nIn fact, <tt>plone.testing</tt> itself uses this kind of layout.</p>\n<p>To have a self-contained buildout in your package, the following is required:</p>\n<ul>\n<li>You need a <tt>buildout.cfg</tt> at the root of the package.</li>\n<li>In most cases, you always want a <tt>bootstrap.py</tt> file to make it easier for people to set up a fresh buildout.</li>\n<li>Your package sources need to be inside a <tt>src</tt> directory.\nIf you\u2019re using namespace packages, that means the top level package should be in the <tt>src</tt> directory.</li>\n<li>The <tt>src</tt> directory must be referenced in <tt>setup.py</tt>.</li>\n</ul>\n<p>For example, <tt>plone.testing</tt> has the following layout:</p>\n<pre>plone.testing/\nplone.testing/setup.py\nplone.testing/bootstrap.py\nplone.testing/buildout.cfg\nplone.testing/README.rst\nplone.testing/src/\nplone.testing/src/plone\nplone.testing/src/plone/__init__.py\nplone.testing/src/plone/testing/\nplone.testing/src/plone/testing/*\n</pre>\n<p>In <tt>setup.py</tt>, the following arguments are required:</p>\n<pre>packages=find_packages('src'),\npackage_dir={'': 'src'},\n</pre>\n<p>This tells <tt>setuptools</tt> where to find the source code.</p>\n<p>The <tt>buildout.cfg</tt> for <tt>plone.testing</tt> looks like this:</p>\n<pre>[buildout]\nextends =\n    http://download.zope.org/Zope2/index/2.12.12/versions.cfg\nparts = coverage test report report-xml\ndevelop = .\n\n[test]\nrecipe = collective.xmltestreport\neggs =\n    plone.testing [test]\ndefaults = ['--auto-color', '--auto-progress']\n\n[coverage]\nrecipe = zc.recipe.egg\neggs = coverage\ninitialization =\n    include = '--source=${buildout:directory}/src'\n    sys.argv = sys.argv[:] + ['run', include, 'bin/test', '--all', '--xml']\n\n[report]\nrecipe = zc.recipe.egg\neggs = coverage\nscripts = coverage=report\ninitialization =\n    sys.argv = sys.argv[:] + ['html', '-i']\n\n[report-xml]\nrecipe = zc.recipe.egg\neggs = coverage\nscripts = coverage=report-xml\ninitialization =\n    sys.argv = sys.argv[:] + ['xml', '-i']\n</pre>\n<p>Obviously, you should adjust the package name in the <tt>eggs</tt> list and the version set in the <tt>extends</tt> line as appropriate.</p>\n<p>You can of course also add additional buildout parts, for example to include some development/debugging tools, or even a running application server for testing purposes.</p>\n<blockquote>\n<p><em>Hint:</em> If you use this package layout, you should avoid checking any files or directories generated by buildout into your version control repository.\nYou want to ignore:</p>\n<ul>\n<li><tt>.coverage</tt></li>\n<li><tt>.installed.cfg</tt></li>\n<li><tt>bin</tt></li>\n<li><tt>coverage.xml</tt></li>\n<li><tt><span class=\"pre\">develop-eggs</span></tt></li>\n<li><tt>htmlcov</tt></li>\n<li><tt>parts</tt></li>\n<li><tt><span class=\"pre\">src/*.egg-info</span></tt></li>\n</ul>\n</blockquote>\n</div>\n</div>\n<div id=\"layers\">\n<h2><a href=\"#id62\" rel=\"nofollow\">Layers</a></h2>\n<p>In large part, <tt>plone.testing</tt> is about layers.\nIt provides:</p>\n<ul>\n<li>A set of layers (outlined below), which you can use or extend.</li>\n<li>A set of tools for working with layers</li>\n<li>A mini-framework to make it easy to write layers and manage shared resources associated with layers.</li>\n</ul>\n<p>We\u2019ll discuss the last two items here, before showing how to write tests that use layers.</p>\n<div id=\"layer-basics\">\n<h3><a href=\"#id63\" rel=\"nofollow\">Layer basics</a></h3>\n<p>Layers are used to create test fixtures that are shared by multiple test cases.\nFor example, if you are writing a set of integration tests, you may need to set up a database and configure various components to access that database.\nThis type of test fixture setup can be resource-intensive and time-consuming.\nIf it is possible to only perform the setup and tear-down once for a set of tests without losing isolation between those tests, test runs can often be sped up significantly.</p>\n<p>Layers also allow re-use of test fixtures and set-up/tear-down code.\n<tt>plone.testing</tt> provides a number of useful (but optional) layers that manage test fixtures for common Zope testing scenarios, letting you focus on the actual test authoring.</p>\n<p>At the most basic, a layer is an object with the following methods and attributes:</p>\n<dl>\n<dt><tt>setUp()</tt></dt>\n<dd>Called by the test runner when the layer is to be set up.\nThis is called exactly once for each layer used during a test run.</dd>\n<dt><tt>tearDown()</tt></dt>\n<dd>Called by the test runner when the layer is to be torn down.\nAs with <tt>setUp()</tt>, this is called exactly once for each layer.</dd>\n<dt><tt>testSetUp()</tt></dt>\n<dd>Called immediately before each test case that uses the layer is executed.\nThis is useful for setting up aspects of the fixture that are managed on a per-test basis, as opposed to fixture shared among all tests.</dd>\n<dt><tt>testTearDown()</tt></dt>\n<dd>Called immediately after each test case that uses the layer is executed.\nThis is a chance to perform any post-test cleanup to ensure the fixture is ready for the next test.</dd>\n<dt><tt>__bases__</tt></dt>\n<dd>A tuple of base layers.</dd>\n</dl>\n<p>Each test case is associated with zero or one layer.\n(The syntax for specifying the layer is shown in the section \u201cWriting tests\u201d below.) All the tests associated with a given layer will be executed together.</p>\n<p>Layers can depend on one another (as indicated in the <tt>__bases__</tt> tuple), allowing one layer to build on the fixture created by another.\nBase layers are set up before and torn down after their dependants.</p>\n<p>For example, if the test runner is executing some tests that belong to layer A, and some other tests that belong to layer B, both of which depend on layer C, the order of execution might be:</p>\n<pre>1. C.setUp()\n1.1. A.setUp()\n\n1.1.1. C.testSetUp()\n1.1.2. A.testSetUp()\n1.1.3. [One test using layer A]\n1.1.4. A.testTearDown()\n1.1.5. C.testTearDown()\n\n1.1.6. C.testSetUp()\n1.1.7. A.testSetUp()\n1.1.8. [Another test using layer A]\n1.1.9. A.testTearDown()\n1.1.10. C.testTearDown()\n\n1.2. A.tearDown()\n1.3. B.setUp()\n\n1.3.1. C.testSetUp()\n1.3.2. B.testSetUp()\n1.3.3. [One test using layer B]\n1.3.4. B.testTearDown()\n1.3.5. C.testTearDown()\n\n1.3.6. C.testSetUp()\n1.3.7. B.testSetUp()\n1.3.8. [Another test using layer B]\n1.3.9. B.testTearDown()\n1.3.10. C.testTearDown()\n\n1.4. B.tearDown()\n2. C.tearDown()\n</pre>\n<p>A base layer may of course depend on other base layers.\nIn the case of nested dependencies like this, the order of set up and tear-down as calculated by the test runner is similar to the way in which Python searches for the method to invoke in the case of multiple inheritance.</p>\n</div>\n<div id=\"writing-layers\">\n<h3><a href=\"#id64\" rel=\"nofollow\">Writing layers</a></h3>\n<p>The easiest way to create a new layer is to use the <tt>Layer</tt> base class and implement the <tt>setUp()</tt>, <tt>tearDown()</tt>, <tt>testSetUp()</tt> and <tt>testTearDown()</tt> methods as needed.\nAll four are optional.\nThe default implementation of each does nothing.</p>\n<p>By convention, layers are created in a module called <tt>testing.py</tt> at the top level of your package.\nThe idea is that other packages that extend your package can re-use your layers for their own testing.</p>\n<p>A simple layer may look like this:</p>\n<pre>&gt;&gt;&gt; from plone.testing import Layer\n&gt;&gt;&gt; class SpaceShip(Layer):\n...\n...     def setUp(self):\n...         print(\"Assembling space ship\")\n...\n...     def tearDown(self):\n...         print(\"Disasembling space ship\")\n...\n...     def testSetUp(self):\n...         print(\"Fuelling space ship in preparation for test\")\n...\n...     def testTearDown(self):\n...         print(\"Emptying the fuel tank\")\n</pre>\n<p>Before this layer can be used, it must be instantiated.\nLayers are normally instantiated exactly once, since by nature they are shared between tests.\nThis becomes important when you start to manage resources (such as persistent data, database connections, or other shared resources) in layers.</p>\n<p>The layer instance is conventionally also found in <tt>testing.py</tt>, just after the layer class definition.:</p>\n<pre>&gt;&gt;&gt; SPACE_SHIP = SpaceShip()\n</pre>\n<div>\n<p>Note</p>\n<p>Since the layer is instantiated in module scope, it will be created as soon as the <tt>testing</tt> module is imported.\nIt is therefore very important that the layer class is inexpensive and safe to create.\nIn general, you should avoid doing anything non-trivial in the <tt>__init__()</tt> method of your layer class.\nAll setup should happen in the <tt>setUp()</tt> method.\nIf you <em>do</em> implement <tt>__init__()</tt>, be sure to call the <tt>super</tt> version as well.</p>\n</div>\n<p>The layer shown above did not have any base layers (dependencies).\nHere is an example of another layer that depends on it::</p>\n<pre>&gt;&gt;&gt; class ZIGSpaceShip(Layer):\n...     defaultBases = (SPACE_SHIP,)\n...\n...     def setUp(self):\n...         print(\"Installing main canon\")\n\n&gt;&gt;&gt; ZIG = ZIGSpaceShip()\n</pre>\n<p>Here, we have explicitly listed the base layers on which <tt>ZIGSpaceShip</tt> depends, in the <tt>defaultBases</tt> attribute.\nThis is used by the <tt>Layer</tt> base class to set the layer bases in a way that can also be overridden: see below.</p>\n<p>Note that we use the layer <em>instance</em> in the <tt>defaultBases</tt> tuple, not the class.\nLayer dependencies always pertain to specific layer instances.\nAbove, we are really saying that <em>instances</em> of <tt>ZIGSpaceShip</tt> will, by default, require the <tt>SPACE_SHIP</tt> layer to be set up first.</p>\n<div>\n<p>Note</p>\n<p>You may find it useful to create other layer base/mix-in classes that extend <tt>plone.testing.Layer</tt> and provide helper methods for use in your own layers.\nThis is perfectly acceptable, but please do not confuse a layer base class used in this manner with the concept of a <em>base layer</em> as described above:</p>\n<ul>\n<li>A class deriving from <tt>plone.testing.Layer</tt> is known as a <em>layer class</em>.\nIt defines the behaviour of the layer by implementing the lifecycle methods <tt>setUp()</tt>, <tt>tearDown()</tt>, <tt>testSetUp()</tt> and/or <tt>testTearDown()</tt>.</li>\n<li>A layer class can be instantiated into an actual layer.\nWhen a layer is associated with a test, it is the layer <em>instance</em> that is used.</li>\n<li>The instance is usually a shared, module-global object, although in some cases it is useful to create copies of layers by instantiating the class more than once.</li>\n<li>Subclassing an existing layer class is just straightforward OOP re-use: the test runner is not aware of the subclassing relationship.</li>\n<li>A layer <em>instance</em> can be associated with any number of layer <em>bases</em>, via its <tt>__bases__</tt> property (which is usually via the <tt>defaultBases</tt> variable in the class body and/or overridden using the <tt>bases</tt> argument to the <tt>Layer</tt> constructor).\nThese bases are layer <em>instances</em>, not classes.\nThe test runner will inspect the <tt>__bases__</tt> attribute of each layer instance it sets up to calculate layer pre-requisites and dependencies.</li>\n</ul>\n<p>Also note that the <a href=\"https://pypi.org/project/zope.testing/\" rel=\"nofollow\">zope.testing</a> documentation contains examples of layers that are \u201cold-style\u201d classes where the <tt>setUp()</tt> and <tt>tearDown()</tt> methods are <tt>classmethod</tt> methods and class inheritance syntax is used to specify base layers.\nWhilst this pattern works, we discourage its use, because the classes created using this pattern are not really used as classes.\nThe concept of layer bases is slightly different from class inheritance, and using the <tt>class</tt> keyword to create layers with base layers leads to a number of \u201cgotchas\u201d that are best avoided.</p>\n</div>\n</div>\n<div id=\"advanced-overriding-bases\">\n<h3><a href=\"#id65\" rel=\"nofollow\">Advanced - overriding bases</a></h3>\n<p>In some cases, it may be useful to create a copy of a layer, but change its bases.\nOne reason to do this may if you are re-using a layer from another module, and you need to change the order in which layers are set up and torn down.</p>\n<p>Normally, of course, you would just re-use the layer instance, either directly in a test, or in the <tt>defaultBases</tt> tuple of another layer, but if you need to change the bases, you can pass a new list of bases to the layer instance constructor::</p>\n<pre>&gt;&gt;&gt; class CATSMessage(Layer):\n...\n...     def setUp(self):\n...         print(\"All your base are belong to us\")\n...\n...     def tearDown(self):\n...         print(\"For great justice\")\n\n&gt;&gt;&gt; CATS_MESSAGE = CATSMessage()\n\n&gt;&gt;&gt; ZERO_WING = ZIGSpaceShip(bases=(SPACE_SHIP, CATS_MESSAGE,), name=\"ZIGSpaceShip:CATSMessage\")\n</pre>\n<p>Please note that when overriding bases like this, the <tt>name</tt> argument is required.\nThis is because each layer (using in a given test run) must have a unique name.\nThe default is to use the layer class name, but this obviously only works for one instantiation.\nTherefore, <tt>plone.testing</tt> requires a name when setting <tt>bases</tt> explicitly.</p>\n<p>Please take great care when changing layer bases like this.\nThe layer implementation may make assumptions about the test fixture that was set up by its bases.\nIf you change the order in which the bases are listed, or remove a base altogether, the layer may fail to set up correctly.</p>\n<p>Also, bear in mind that the new layer instance is independent of the original layer instance, so any resources defined in the layer are likely to be duplicated.</p>\n</div>\n<div id=\"layer-combinations\">\n<h3><a href=\"#id66\" rel=\"nofollow\">Layer combinations</a></h3>\n<p>Sometimes, it is useful to be able to combine several layers into one, without adding any new fixture.\nOne way to do this is to use the <tt>Layer</tt> class directly and instantiate it with new bases::</p>\n<pre>&gt;&gt;&gt; COMBI_LAYER = Layer(bases=(CATS_MESSAGE, SPACE_SHIP,), name=\"Combi\")\n</pre>\n<p>Here, we have created a \u201cno-op\u201d layer with two bases: <tt>CATS_MESSAGE</tt> and <tt>SPACE_SHIP</tt>, named <tt>Combi</tt>.</p>\n<p>Please note that when using <tt>Layer</tt> directly like this, the <tt>name</tt> argument is required.\nThis is to allow the test runner to identify the layer correctly.\nNormally, the class name of the layer is used as a basis for the name, but when using the <tt>Layer</tt> base class directly, this is unlikely to be unique or descriptive.</p>\n</div>\n<div id=\"layer-resources\">\n<h3><a href=\"#id67\" rel=\"nofollow\">Layer resources</a></h3>\n<p>Many layers will manage one or more resources that are used either by other layers, or by tests themselves.\nExamples may include database connections, thread-local objects, or configuration data.</p>\n<p><tt>plone.testing</tt> contains a simple resource storage abstraction that makes it easy to access resources from dependant layers or tests.\nThe resource storage uses dictionary notation::</p>\n<pre>&gt;&gt;&gt; class WarpDrive(object):\n...     \"\"\"A shared resource\"\"\"\n...\n...     def __init__(self, maxSpeed):\n...         self.maxSpeed = maxSpeed\n...         self.running = False\n...\n...     def start(self, speed):\n...         if speed &gt; self.maxSpeed:\n...             print(\"We need more power!\")\n...         else:\n...             print(\"Going to warp at speed\", speed)\n...             self.running = True\n...\n...     def stop(self):\n...         self.running = False\n\n&gt;&gt;&gt; class ConstitutionClassSpaceShip(Layer):\n...     defaultBases = (SPACE_SHIP,)\n...\n...     def setUp(self):\n...         self['warpDrive'] = WarpDrive(8.0)\n...\n...     def tearDown(self):\n...         del self['warpDrive']\n\n&gt;&gt;&gt; CONSTITUTION_CLASS_SPACE_SHIP = ConstitutionClassSpaceShip()\n\n&gt;&gt;&gt; class GalaxyClassSpaceShip(Layer):\n...     defaultBases = (CONSTITUTION_CLASS_SPACE_SHIP,)\n...\n...     def setUp(self):\n...         # Upgrade the warp drive\n...         self.previousMaxSpeed = self['warpDrive'].maxSpeed\n...         self['warpDrive'].maxSpeed = 9.5\n...\n...     def tearDown(self):\n...         # Restore warp drive to its previous speed\n...         self['warpDrive'].maxSpeed = self.previousMaxSpeed\n\n&gt;&gt;&gt; GALAXY_CLASS_SPACE_SHIP = GalaxyClassSpaceShip()\n</pre>\n<p>As shown, layers (that derive from <tt>plone.testing.Layer</tt>) support item (dict-like) assignment, access and deletion of arbitrary resources under string keys.</p>\n<blockquote>\n<strong>Important:</strong> If a layer creates a resource (by assigning an object to a key on <tt>self</tt> as shown above) during fixture setup-up, it must also delete the resource on tear-down.\nSet-up and deletion should be symmetric: if the resource is assigned during <tt>setUp()</tt> it should be deleted in <tt>tearDown()</tt>;\nif it\u2019s created in <tt>testSetUp()</tt> it should be deleted in <tt>testTearDown()</tt>.</blockquote>\n<p>A resource defined in a base layer is accessible from and through a child layer.\nIf a resource is set on a child using a key that also exists in a base layer, the child version will shadow the base version until the child layer is torn down (presuming it deletes the resource, which it should), but the base layer version remains intact.</p>\n<div>\n<p>Note</p>\n<p>Accessing a resource is analogous to accessing an instance variable.\nFor example, if a base layer assigns a resource to a given key in its <tt>setUp()</tt> method, a child layer shadows that resource with another object under the same key, the shadowed resource will by used during the <tt>testSetUp()</tt> and <tt>testTearDown()</tt> lifecycle methods if implemented by the <em>base</em> layer as well.\nThis will be the case until the child layer \u201cpops\u201d the resource by deleting it, normally in its <tt>tearDown()</tt>.</p>\n</div>\n<p>Conversely, if (as shown above) the child layer accesses and modifies the object, it will modify the original.</p>\n<div>\n<p>Note</p>\n<p>It is sometimes necessary (or desirable) to modify a shared resource in a child layer, as shown in the example above.  In this case, however, it is very important to restore the original state when the layer is torn down.  Otherwise, other layers or tests using the base layer directly may be affected in difficult-to-debug ways.</p>\n</div>\n<p>If the same key is used in multiple base layers, the rules for choosing which version to use are similar to those that apply when choosing an attribute or method to use in the case of multiple inheritance.</p>\n<p>In the example above, we used the resource manager for the <tt>warpDrive</tt> object, but we assigned the <tt>previousMaxSpeed</tt> variable to <tt>self</tt>.\nThis is because <tt>previousMaxSpeed</tt> is internal to the layer and should not be shared with any other layers that happen to use this layer as a base.\nNor should it be used by any test cases.\nConversely, <tt>warpDrive</tt> is a shared resource that is exposed to other layers and test cases.</p>\n<p>The distinction becomes even more important when you consider how a test case may access the shared resource.\nWe\u2019ll discuss how to write test cases that use layers shortly, but consider the following test::</p>\n<pre>&gt;&gt;&gt; import unittest\n&gt;&gt;&gt; class TestFasterThanLightTravel(unittest.TestCase):\n...     layer = GALAXY_CLASS_SPACE_SHIP\n...\n...     def test_hyperdrive(self):\n...         warpDrive = self.layer['warpDrive']\n...         warpDrive.start(8)\n</pre>\n<p>This test needs access to the shared resource.\nIt knows that its layer defines one called <tt>warpDrive</tt>.\nIt does not know or care that the warp drive was actually initiated by the <tt>ConstitutionClassSpaceShip</tt> base layer.</p>\n<p>If, however, the base layer had assigned the resource as an instance variable, it would not inherit to child layers (remember: layer bases are not base classes!).\nThe syntax to access it would be::</p>\n<pre>self.layer.__bases__[0].warpDrive\n</pre>\n<p>which is not only ugly, but brittle: if the list of bases is changed, the expression above may lead to an attribute error.</p>\n</div>\n</div>\n<div id=\"writing-tests\">\n<h2><a href=\"#id68\" rel=\"nofollow\">Writing tests</a></h2>\n<p>Tests are usually written in one of two ways: As methods on a class that derives from <tt>unittest.TestCase</tt> (this is sometimes known as \u201cPython tests\u201d or \u201cJUnit-style tests\u201d), or using doctest syntax.</p>\n<p>You should realise that although the relevant frameworks (<tt>unittest</tt> and <tt>doctest</tt>) often talk about unit testing, these tools are also used to write integration and functional tests.\nThe distinction between unit, integration and functional tests is largely practical: you use the same techniques to set up a fixture or write assertions for an integration test as you would for a unit test.\nThe difference lies in what that fixture contains, and how you invoke the code under test.\nIn general, a true unit test will have a minimal or no test fixture, whereas an integration test will have a fixture that contains the components your code is integrating with.\nA functional test will have a fixture that contains enough of the full system to execute and test an \u201cend-to-end\u201d scenario.</p>\n<div id=\"python-tests\">\n<h3><a href=\"#id69\" rel=\"nofollow\">Python tests</a></h3>\n<p>Python tests use the Python <a href=\"http://doc.python.org/library/unittest.html\" rel=\"nofollow\">unittest</a> module.\nThey should be placed in a module or package called <tt>tests</tt> for the test runner to pick them up.</p>\n<p>For small packages, a single module called <tt>tests.py</tt> will normally contain all tests.\nFor larger packages, it is common to have a <tt>tests</tt> package that contains a number of modules with tests.\nThese need to start with the word <tt>test</tt>, e.g.\n<tt>tests/test_foo.py</tt> or <tt>tests/test_bar.py</tt>.\nDon\u2019t forget the <tt>__init__.py</tt> in the <tt>tests</tt> package, too!</p>\n<div id=\"unittest\">\n<h4><a href=\"#id70\" rel=\"nofollow\">unittest</a></h4>\n<p>Please note that the <a href=\"https://pypi.org/project/zope.testing/\" rel=\"nofollow\">zope.testing</a> test runner at the time of writing (version 4.6.2) does not (yet) support the new <tt>setUpClass()</tt>, <tt>tearDownClass()</tt>, <tt>setUpModule()</tt> and <tt>tearDownModule()</tt> hooks from <tt>unittest</tt>.\nThis is not normally a problem, since we tend to use layers to manage complex fixtures, but it is important to be aware of nonetheless.</p>\n</div>\n<div id=\"test-modules-classes-and-functions\">\n<h4><a href=\"#id71\" rel=\"nofollow\">Test modules, classes and functions</a></h4>\n<p>Python tests are written with classes that derive from the base class <tt>TestCase</tt>.\nEach test is written as a method that takes no arguments and has a name starting with <tt>test</tt>.\nOther methods can be added and called from test methods as appropriate, e.g.\nto share some test logic.</p>\n<p>Two special methods, <tt>setUp()</tt> and <tt>tearDown()</tt>, can also be added.\nThese will be called before or after each test, respectively, and provide a useful place to construct and clean up test fixtures without writing a custom layer.\nThey are obviously not as re-usable as layers, though.</p>\n<blockquote>\n<em>Hint:</em> Somewhat confusingly, the <tt>setUp()</tt> and <tt>tearDown()</tt> methods in a test case class are the equivalent of the <tt>testSetUp()</tt> and <tt>testTearDown()</tt> methods of a layer class.</blockquote>\n<p>A layer can be specified by setting the <tt>layer</tt> class attribute to a layer instance.\nIf layers are used in conjunction with <tt>setUp()</tt> and <tt>tearDown()</tt> methods in the test class itself, the class\u2019 <tt>setUp()</tt> method will be called after the layer\u2019s <tt>testSetUp()</tt> method, and the class\u2019 <tt>tearDown()</tt> method will be called before the layer\u2019s <tt>testTearDown()</tt> method.</p>\n<p>The <tt>TestCase</tt> base class contains a number of methods which can be used to write assertions.\nThey all take the form <tt>self.assertSomething()</tt>, e.g.\n<tt>self.assertEqual(result, expectedValue)</tt>.\nSee the <a href=\"http://doc.python.org/library/unittest.html\" rel=\"nofollow\">unittest</a> documentation for details.</p>\n<p>Putting this together, let\u2019s expand on our previous example unit test::</p>\n<pre>&gt;&gt;&gt; import unittest\n\n&gt;&gt;&gt; class TestFasterThanLightTravel(unittest.TestCase):\n...     layer = GALAXY_CLASS_SPACE_SHIP\n...\n...     def setUp(self):\n...         self.warpDrive = self.layer['warpDrive']\n...         self.warpDrive.stop()\n...\n...     def tearDown(self):\n...         self.warpDrive.stop()\n...\n...     def test_warp8(self):\n...         self.warpDrive.start(8)\n...         self.assertEqual(self.warpDrive.running, True)\n...\n...     def test_max_speed(self):\n...         tooFast = self.warpDrive.maxSpeed + 0.1\n...         self.warpDrive.start(tooFast)\n...         self.assertEqual(self.warpDrive.running, False)\n</pre>\n<p>A few things to note:</p>\n<ul>\n<li>The class derives from <tt>unittest.TestCase</tt>.</li>\n<li>The <tt>layer</tt> class attribute is set to a layer instance (not a layer class!) defined previously.\nThis would typically be imported from a <tt>testing</tt> module.</li>\n<li>There are two tests here: <tt>test_warp8()</tt> and <tt>test_max_speed()</tt>.</li>\n<li>We have used the <tt>self.assertEqual()</tt> assertion in both tests to check the result of executing the <tt>start()</tt> method on the warp drive.</li>\n<li>We have used the <tt>setUp()</tt> method to fetch the <tt>warpDrive</tt> resource and ensure that it is stopped before each test is executed.\nAssigning a variable to <tt>self</tt> is a useful way to provide some state to each test method, though be careful about data leaking between tests: in general, you cannot predict the order in which tests will run, and tests should always be independent.</li>\n<li>We have used the <tt>tearDown()</tt> method to make sure the warp drive is really stopped after each test.</li>\n</ul>\n</div>\n<div id=\"test-suites\">\n<h4><a href=\"#id72\" rel=\"nofollow\">Test suites</a></h4>\n<p>A class like the one above is all you need: any class deriving from <tt>TestCase</tt> in a module with a name starting with <tt>test</tt> will be examined for test methods.\nThose tests are then collected into a test suite and executed.</p>\n<p>See the <a href=\"http://doc.python.org/library/unittest.html\" rel=\"nofollow\">unittest</a> documentation for other options.</p>\n</div>\n</div>\n<div id=\"doctests\">\n<h3><a href=\"#id73\" rel=\"nofollow\">Doctests</a></h3>\n<p>Doctests can be written in two ways: as the contents of a docstring (usually, but not always, as a means of illustrating and testing the functionality of the method or class where the docstring appears), or as a separate text file.\nIn both cases, the standard <a href=\"http://docs.python.org/dev/library/doctest.html\" rel=\"nofollow\">doctest</a> module is used.\nSee its documentation for details about doctest syntax and conventions.</p>\n<p>Doctests are used in two different ways:</p>\n<ul>\n<li>To test documentation.\nThat is, to ensure that code examples contained in documentation are valid and continue to work as the software is updated.</li>\n<li>As a convenient syntax for writing tests.</li>\n</ul>\n<p>These two approaches use the same testing APIs and techniques.\nThe difference is mostly about mindset.\nHowever, it is important to avoid falling into the trap that tests can substitute for good documentation or vice-a-versa.\nTests usually need to systematically go through inputs and outputs and cover off a number of corner cases.\nDocumentation should tell a compelling narrative and usually focus on the main usage scenarios.\nTrying to kill these two birds with one stone normally leaves you with an unappealing pile of stones and feathers.</p>\n<div id=\"docstring-doctests\">\n<h4><a href=\"#id74\" rel=\"nofollow\">Docstring doctests</a></h4>\n<p>Doctests can be added to any module, class or function docstring::</p>\n<pre>def canOutrunKlingons(warpDrive):\n    \"\"\"Find out of the given warp drive can outrun Klingons.\n\n    Klingons travel at warp 8\n\n    &gt;&gt;&gt; drive = WarpDrive(5)\n    &gt;&gt;&gt; canOutrunKlingons(drive)\n    False\n\n    We have to be faster than that to outrun them.\n\n    &gt;&gt;&gt; drive = WarpDrive(8.1)\n    &gt;&gt;&gt; canOutrunKlingons(drive)\n    True\n\n    We can't outrun them if we're travelling exactly the same speed\n\n    &gt;&gt;&gt; drive = WarpDrive(8.0)\n    &gt;&gt;&gt; canOutrunKlingons(drive)\n    False\n\n    \"\"\"\n    return warpDrive.maxSpeed &gt; 8.0\n</pre>\n<p>To add the doctests from a particular module to a test suite, you need to use the <tt>test_suite()</tt> function hook::</p>\n<pre>&gt;&gt;&gt; import doctest\n&gt;&gt;&gt; def test_suite():\n...     suite = unittest.TestSuite()\n...     suite.addTests([\n...         unittest.makeSuite(TestFasterThanLightTravel), # our previous test\n...         doctest.DocTestSuite('spaceship.utils'),\n...     ])\n...     return suite\n</pre>\n<p>Here, we have given the name of the module to check as a string dotted name.\nIt is also possible to import a module and pass it as an object.\nThe code above passes a list to <tt>addTests()</tt>, making it easy to add several sets of tests to the suite: the list can be constructed from calls to <tt>DocTestSuite()</tt>, <tt>DocFileSuite()</tt> (shown below) and <tt>makeSuite()</tt> (shown above).</p>\n<blockquote>\nRemember that if you add a <tt>test_suite()</tt> function to a module that also has <tt>TestCase</tt>-derived python tests, those tests will no longer be automatically picked up by <tt>zope.testing</tt>, so you need to add them to the test suite explicitly.</blockquote>\n<p>The example above illustrates a documentation-oriented doctest, where the doctest forms part of the docstring of a public module.\nThe same syntax can be used for more systematic unit tests.\nFor example, we could have a module <tt>spaceship.tests.test_spaceship</tt> with a set of methods like:</p>\n<pre># It's often better to put the import into each method, but here we've\n# imported the code under test at module level\nfrom spaceship.utils import WarpDrive, canOutrunKlingons\n\ndef test_canOutrunKlingons_too_small():\n    \"\"\"Klingons travel at warp 8.0\n\n    &gt;&gt;&gt; drive = WarpDrive(7.9)\n    &gt;&gt;&gt; canOutrunKlingons(drive)\n    False\n\n    \"\"\"\n\ndef test_canOutrunKlingons_big():\n    \"\"\"Klingons travel at warp 8.0\n\n    &gt;&gt;&gt; drive = WarpDrive(8.1)\n    &gt;&gt;&gt; canOutrunKlingons(drive)\n    True\n\n    \"\"\"\n\ndef test_canOutrunKlingons_must_be_greater():\n    \"\"\"Klingons travel at warp 8.0\n\n    &gt;&gt;&gt; drive = WarpDrive(8.0)\n    &gt;&gt;&gt; canOutrunKlingons(drive)\n    False\n\n    \"\"\"\n</pre>\n<p>Here, we have created a number of small methods that have no body.\nThey merely serve as a container for docstrings with doctests.\nSince the module has no globals, each test must import the code under test, which helps make import errors more explicit.</p>\n</div>\n<div id=\"file-doctests\">\n<h4><a href=\"#id75\" rel=\"nofollow\">File doctests</a></h4>\n<p>Doctests contained in a file are similar to those contained in docstrings.\nFile doctests are better suited to narrative documentation covering the usage of an entire module or package.</p>\n<p>For example, if we had a file called <tt>spaceship.txt</tt> with doctests, we could add it to the test suite above with::</p>\n<pre>&gt;&gt;&gt; def test_suite():\n...     suite = unittest.TestSuite()\n...     suite.addTests([\n...         unittest.makeSuite(TestFasterThanLightTravel),\n...         doctest.DocTestSuite('spaceship.utils'),\n...         doctest.DocFileSuite('spaceship.txt'),\n...     ])\n...     return suite\n</pre>\n<p>By default, the file is located relative to the module where the test suite is defined.\nYou can use <tt>../</tt> (even on Windows) to reference the parent directory, which is sometimes useful if the doctest is inside a module in a <tt>tests</tt> package.</p>\n<div>\n<p>Note</p>\n<p>If you put the doctest <tt>test_suite()</tt> method in a module inside a <tt>tests</tt> package, that module must have a name starting with <tt>test</tt>.\nIt is common to have <tt>tests/test_doctests.py</tt> that contains a single <tt>test_suite()</tt> method that returns a suite of multiple doctests.</p>\n</div>\n<p>It is possible to pass several tests to the suite, e.g.:</p>\n<pre>&gt;&gt;&gt; def test_suite():\n...     suite = unittest.TestSuite()\n...     suite.addTests([\n...         unittest.makeSuite(TestFasterThanLightTravel),\n...         doctest.DocTestSuite('spaceship.utils'),\n...         doctest.DocFileSuite('spaceship.txt', 'warpdrive.txt',),\n...     ])\n...     return suite\n</pre>\n<p>The test runner will report each file as a separate test, i.e.\nthe <tt>DocFileSuite()</tt> above would add two tests to the overall suite.\nConversely, a <tt>DocTestSuite()</tt> using a module with more than one docstring containing doctests will report one test for each eligible docstring.</p>\n</div>\n<div id=\"doctest-fixtures-and-layers\">\n<h4><a href=\"#id76\" rel=\"nofollow\">Doctest fixtures and layers</a></h4>\n<p>A docstring doctest will by default have access to any global symbol available in the module where the docstring is found (e.g.\nanything defined or imported in the module).\nThe global namespace can be overridden by passing a <tt>globs</tt> keyword argument to the <tt>DocTestSuite()</tt> constructor, or augmented by passing an <tt>extraglobs</tt> argument.\nBoth should be given dictionaries.</p>\n<p>A file doctest has an empty globals namespace by default.\nGlobals may be provided via the <tt>globs</tt> argument to <tt>DocFileSuite()</tt>.</p>\n<p>To manage a simple test fixture for a doctest, you can define set-up and tear-down functions and pass them as the <tt>setUp</tt> and <tt>tearDown</tt> arguments respectively.\nThese are both passed a single argument, a <tt>DocTest</tt> object.\nThe most useful attribute of this object is <tt>globs</tt>, which is a mutable dictionary of globals available in the test.</p>\n<p>For example::</p>\n<pre>&gt;&gt;&gt; def setUpKlingons(doctest):\n...     doctest.globs['oldStyleKlingons'] = True\n\n&gt;&gt;&gt; def tearDownKlingons(doctest):\n...     doctest.globs['oldStyleKlingons'] = False\n\n&gt;&gt;&gt; def test_suite():\n...     suite = unittest.TestSuite()\n...     suite.addTests([\n...         doctest.DocTestSuite('spaceship.utils', setUp=setUpKlingons, tearDown=tearDownKlingons),\n...     ])\n...     return suite\n</pre>\n<p>The same arguments are available on the <tt>DocFileSuite()</tt> constructor.\nThe set up method is called before each docstring in the given module for a <tt>DocTestSuite</tt>, and before each file given in a <tt>DocFileSuite</tt>.</p>\n<p>Of course, we often want to use layers with doctests too.\nUnfortunately, the <tt>unittest</tt> API is not aware of layers, so you can\u2019t just pass a layer to the <tt>DocTestSuite()</tt> and <tt>DocFileSuite()</tt> constructors.\nInstead, you have to set a <tt>layer</tt> attribute on the suite after it has been constructed.</p>\n<p>Furthermore, to use layer resources in a doctest, we need access to the layer instance.\nThe easiest way to do this is to pass it as a glob, conventionally called \u2018layer\u2019.\nThis makes a global name \u2018layer\u2019 available in the doctest itself, giving access to the test\u2019s layer instance.</p>\n<p>To make it easier to do this, <tt>plone.testing</tt> comes with a helper function called <tt>layered()</tt>.\nIts first argument is a test suite.\nThe second argument is the layer.</p>\n<p>For example::</p>\n<pre>&gt;&gt;&gt; from plone.testing import layered\n&gt;&gt;&gt; def test_suite():\n...     suite = unittest.TestSuite()\n...     suite.addTests([\n...         layered(doctest.DocTestSuite('spaceship.utils'), layer=CONSTITUTION_CLASS_SPACE_SHIP),\n...     ])\n...     return suite\n</pre>\n<p>This is equivalent to::</p>\n<pre>&gt;&gt;&gt; def test_suite():\n...     suite = unittest.TestSuite()\n...\n...     spaceshipUtilTests = doctest.DocTestSuite('spaceship.utils', globs={'layer': CONSTITUTION_CLASS_SPACE_SHIP})\n...     spaceshipUtilTests.layer = CONSTITUTION_CLASS_SPACE_SHIP\n...     suite.addTest(spaceshipUtilTests)\n...\n...     return suite\n</pre>\n<p>(In this example, we\u2019ve opted to use <tt>addTest()</tt> to add a single suite, instead of using <tt>addTests()</tt> to add multiple suites in one go).</p>\n</div>\n</div>\n</div>\n<div id=\"zope-testing-tools\">\n<h2><a href=\"#id77\" rel=\"nofollow\">Zope testing tools</a></h2>\n<p>Everything described so far in this document relies only on the standard <a href=\"http://doc.python.org/library/unittest.html\" rel=\"nofollow\">unittest</a> and <a href=\"http://docs.python.org/dev/library/doctest.html\" rel=\"nofollow\">doctest</a> modules and <a href=\"https://pypi.org/project/zope.testing/\" rel=\"nofollow\">zope.testing</a>, and you can use this package without any other dependencies.</p>\n<p>However, there are also some tools (and layers) available in this package, as well as in other packages, that are specifically useful for testing applications that use various Zope-related frameworks.</p>\n<div id=\"test-cleanup\">\n<h3><a href=\"#id78\" rel=\"nofollow\">Test cleanup</a></h3>\n<p>If a test uses a global registry, it may be necessary to clean that registry on set up and tear down of each test fixture.\n<tt>zope.testing</tt> provides a mechanism to register cleanup handlers - methods that are called to clean up global state.\nThis can then be invoked in the <tt>setUp()</tt> and <tt>tearDown()</tt> fixture lifecycle methods of a test case.:</p>\n<pre>&gt;&gt;&gt; from zope.testing import cleanup\n</pre>\n<p>Let\u2019s say we had a global registry, implemented as a dictionary::</p>\n<pre>&gt;&gt;&gt; SOME_GLOBAL_REGISTRY = {}\n</pre>\n<p>If we wanted to clean this up on each test run, we could call <tt>clear()</tt> on the dict.\nSince that\u2019s a no-argument method, it is perfect as a cleanup handler.:</p>\n<pre>&gt;&gt;&gt; cleanup.addCleanUp(SOME_GLOBAL_REGISTRY.clear)\n</pre>\n<p>We can now use the <tt>cleanUp()</tt> method to execute all registered cleanups::</p>\n<pre>&gt;&gt;&gt; cleanup.cleanUp()\n</pre>\n<p>This call could be placed in a <tt>setUp()</tt> and/or <tt>tearDown()</tt> method in a test class, for example.</p>\n</div>\n<div id=\"event-testing\">\n<h3><a href=\"#id79\" rel=\"nofollow\">Event testing</a></h3>\n<p>You may wish to test some code that uses <tt>zope.event</tt> to fire specific events.\n<a href=\"https://pypi.org/project/zope.component\" rel=\"nofollow\">zope.component</a> provides some helpers to capture and analyse events.:</p>\n<pre>&gt;&gt;&gt; from zope.component import eventtesting\n</pre>\n<p>To use this, you first need to set up event testing.\nSome of the layers shown below will do this for you, but you can do it yourself by calling the <tt>eventtesting.setUp()</tt> method, e.g.\nfrom your own <tt>setUp()</tt> method::</p>\n<pre>&gt;&gt;&gt; eventtesting.setUp()\n</pre>\n<p>This simply registers a few catch-all event handlers.\nOnce you have executed the code that is expected to fire events, you can use the <tt>getEvents()</tt> helper function to obtain a list of the event instances caught::</p>\n<pre>&gt;&gt;&gt; events = eventtesting.getEvents()\n</pre>\n<p>You can now examine <tt>events</tt> to see what events have been caught since the last cleanup.</p>\n<p><tt>getEvents()</tt> takes two optional arguments that can be used to filter the returned list of events.\nThe first (<tt>event_type</tt>) is an interface.\nIf given, only events providing this interface are returned.\nThe second (<tt>filter</tt>) is a callable taking one argument.\nIf given, it will be called with each captured event.\nOnly those events where the filter function returns <tt>True</tt> will be included.</p>\n<p>The <tt>eventtesting</tt> module registers a cleanup action as outlined above.\nWhen you call <tt>cleanup.cleanUp()</tt> (or <tt>eventtesting.clearEvents()</tt>, which is the handler it registers), the events list will be cleared, ready for the next test.\nHere, we\u2019ll do it manually::</p>\n<pre>&gt;&gt;&gt; eventtesting.clearEvents()\n</pre>\n</div>\n<div id=\"mock-requests\">\n<h3><a href=\"#id80\" rel=\"nofollow\">Mock requests</a></h3>\n<p>Many tests require a request object, often with particular request/form variables set.\n<a href=\"https://pypi.org/project/zope.publisher\" rel=\"nofollow\">zope.publisher</a> contains a useful class for this purpose.:</p>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n</pre>\n<p>A simple test request can be constructed with no arguments::</p>\n<pre>&gt;&gt;&gt; request = TestRequest()\n</pre>\n<p>To add a body input stream, pass a <tt>StringIO</tt> or file as the first parameter.\nTo set the environment (request headers), use the <tt>environ</tt> keyword argument.\nTo simulate a submitted form, use the <tt>form</tt> keyword argument::</p>\n<pre>&gt;&gt;&gt; request = TestRequest(form=dict(field1='foo', field2=1))\n</pre>\n<p>Note that the <tt>form</tt> dict contains marshalled form fields, so modifiers like <tt>:int</tt> or <tt>:boolean</tt> should not be included in the field names, and values should be converted to the appropriate type.</p>\n</div>\n<div id=\"registering-components\">\n<h3><a href=\"#id81\" rel=\"nofollow\">Registering components</a></h3>\n<p>Many test fixtures will depend on having a minimum of Zope Component Architecture (ZCA) components registered.\nIn normal operation, these would probably be registered via ZCML, but in a unit test, you should avoid loading the full ZCML configuration of your package (and its dependencies).</p>\n<p>Instead, you can use the Python API in <a href=\"https://pypi.org/project/zope.component\" rel=\"nofollow\">zope.component</a> to register global components instantly.\nThe three most commonly used functions are::</p>\n<pre>&gt;&gt;&gt; from zope.component import provideAdapter\n&gt;&gt;&gt; from zope.component import provideUtility\n&gt;&gt;&gt; from zope.component import provideHandler\n</pre>\n<p>See the <a href=\"https://pypi.org/project/zope.component\" rel=\"nofollow\">zope.component</a> documentation for details about how to use these.</p>\n<p>When registering global components like this, it is important to avoid test leakage.\nThe <tt>cleanup</tt> mechanism outlined above can be used to tear down the component registry between each test.\nSee also the <tt>plone.testing.zca.UNIT_TESTING</tt> layer, described below, which performs this cleanup automatically via the <tt>testSetUp()</tt>/<tt>testTearDown()</tt> mechanism.</p>\n<p>Alternatively, you can \u201cstack\u201d a new global component registry using the <tt>plone.testing.zca.pushGlobalRegistry()</tt> and <tt>plone.testing.zca.popGlobalRegistry()</tt> helpers.\nThis makes it possible to set up and tear down components that are specific to a given layer, and even allow tests to safely call the global component API (or load ZCML - see below) with proper tear-down.\nSee the layer reference below for details.</p>\n</div>\n<div id=\"loading-zcml\">\n<h3><a href=\"#id82\" rel=\"nofollow\">Loading ZCML</a></h3>\n<p>Integration tests often need to load ZCML configuration.\nThis can be achieved using the <tt>zope.configuration</tt> API.:</p>\n<pre>&gt;&gt;&gt; from zope.configuration import xmlconfig\n</pre>\n<p>The <tt>xmlconfig</tt> module contains two methods for loading ZCML.</p>\n<p><tt>xmlconfig.string()</tt> can be used to load a literal string of ZCML::</p>\n<pre>&gt;&gt;&gt; xmlconfig.string(\"\"\"\\\n... &lt;configure xmlns=\"http://namespaces.zope.org/zope\" package=\"plone.testing\"&gt;\n...     &lt;include package=\"zope.component\" file=\"meta.zcml\" /&gt;\n... &lt;/configure&gt;\n... \"\"\")\n&lt;zope.configuration.config.ConfigurationMachine object at ...&gt;\n</pre>\n<p>Note that we need to set a package (used for relative imports and file locations) explicitly here, using the <tt>package</tt> attribute of the <tt>&lt;configure /&gt;</tt> element.</p>\n<p>Also note that unless the optional second argument (<tt>context</tt>) is passed, a new configuration machine will be created every time <tt>string()</tt> is called.\nIt therefore becomes necessary to explicitly <tt>&lt;include /&gt;</tt> the files that contain the directives you want to use (the one in <tt>zope.component</tt> is a common example).\nLayers that set up ZCML configuration may expose a resource which can be passed as the <tt>context</tt> parameter, usually called <tt>configurationContext</tt> - see below.</p>\n<p>To load the configuration for a particular package, use <tt>xmlconfig.file()</tt>::</p>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; context = xmlconfig.file('meta.zcml', zope.component)\n&gt;&gt;&gt; xmlconfig.file('configure.zcml', zope.component, context=context)\n&lt;zope.configuration.config.ConfigurationMachine object at ...&gt;\n</pre>\n<p>This takes two required arguments: the file name and the module relative to which it is to be found.\nHere, we have loaded two files: <tt>meta.zcml</tt> and <tt>configure.zcml</tt>.\nThe first call to <tt>xmlconfig.file()</tt> creates and returns a configuration context.\nWe re-use that for the subsequent invocation, so that the directives configured are available.</p>\n</div>\n<div id=\"installing-a-zope-product\">\n<h3><a href=\"#id83\" rel=\"nofollow\">Installing a Zope product</a></h3>\n<p>Some packages (including all those in the <tt>Products.*</tt> namespace) have the special status of being Zope \u201cproducts\u201d.\nThese are recorded in a special registry, and may have an <tt>initialize()</tt> hook in their top-level <tt>__init__.py</tt> that needs to be called for the package to be fully configured.</p>\n<p>Zope 2 will find and execute any products during startup.\nFor testing, we need to explicitly list the products to install.\nProvided you are using <tt>plone.testing</tt> with Zope, you can use the following::</p>\n<pre>from plone.testing import zope\n\nwith zope.zopeApp() as app:\n    zope.installProduct(app, 'Products.ZCatalog')\n</pre>\n<p>This would normally be used during layer <tt>setUp()</tt>.\nNote that the basic Zope application context must have been set up before doing this.\nThe usual way to ensure this, is to use a layer that is based on <tt>zope.STARTUP</tt> - see below.</p>\n<p>To tear down such a layer, you should do::</p>\n<pre>from plone.testing import zope\n\nwith zope.zopeApp() as app:\n    zope.uninstallProduct(app, 'Products.ZCatalog')\n</pre>\n<p>Note:</p>\n<ul>\n<li>Unlike the similarly-named function from <tt>ZopeTestCase</tt>, these helpers will work with any type of product.\nThere is no distinction between a \u201cproduct\u201d and a \u201cpackage\u201d (and no <tt>installPackage()</tt>).\nHowever, you must use the full name (<tt>Products.*</tt>) when registering a product.</li>\n<li>Installing a product in this manner is independent of ZCML configuration.\nHowever, it is almost always necessary to install the package\u2019s ZCML configuration first.</li>\n</ul>\n</div>\n<div id=\"functional-testing\">\n<h3><a href=\"#id84\" rel=\"nofollow\">Functional testing</a></h3>\n<p>For functional tests that aim to simulate the browser, you can use <a href=\"https://pypi.org/project/zope.testbrowser\" rel=\"nofollow\">zope.testbrowser</a> in a Python test or doctest::</p>\n<pre>&gt;&gt;&gt; from zope.testbrowser.browser import Browser\n&gt;&gt;&gt; browser = Browser()\n</pre>\n<p>This provides a simple API to simulate browser input, without actually running a web server thread or scripting a live browser (as tools such as <a href=\"http://seleniumhq.org/\" rel=\"nofollow\">Selenium</a> do).\nThe downside is that it is not possible to test JavaScript- dependent behaviour.</p>\n<p>If you are testing a Zope application, you need to change the import location slightly, and pass the application root to the method::</p>\n<pre>from plone.testing.zope import Browser\nbrowser = Browser(app)\n</pre>\n<p>You can get the application root from the <tt>app</tt> resource in any of the Zope layers in this package.</p>\n<p>Beyond that, the <a href=\"https://pypi.org/project/zope.testbrowser\" rel=\"nofollow\">zope.testbrowser</a> documentation should cover how to use the test browser.</p>\n<blockquote>\n<strong>Hint:</strong> The test browser will usually commit at the end of a request.\nTo avoid test fixture contamination, you should use a layer that fully isolates each test, such as the <tt>zope.INTEGRATION_TESTING</tt> layer described below.</blockquote>\n</div>\n</div>\n<div id=\"layer-reference\">\n<h2><a href=\"#id85\" rel=\"nofollow\">Layer reference</a></h2>\n<p><tt>plone.testing</tt> comes with several layers that are available to use directly or extend.\nThese are outlined below.</p>\n<div id=\"zope-component-architecture\">\n<h3><a href=\"#id86\" rel=\"nofollow\">Zope Component Architecture</a></h3>\n<p>The Zope Component Architecture layers are found in the module <tt>plone.testing.zca</tt>.\nIf you depend on this, you can use the <tt>[zca]</tt> extra when depending on <tt>plone.testing</tt>.</p>\n<div id=\"unit-testing\">\n<h4><a href=\"#id87\" rel=\"nofollow\">Unit testing</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zca.UNIT_TESTING</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zca.UnitTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td>None</td>\n</tr>\n<tr><td>Resources:</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<p>This layer does not set up a fixture per se, but cleans up global state before and after each test, using <tt>zope.testing.cleanup</tt> as described above.</p>\n<p>The net result is that each test has a clean global component registry.\nThus, it is safe to use the <a href=\"https://pypi.org/project/zope.component\" rel=\"nofollow\">zope.component</a> Python API (<tt>provideAdapter()</tt>, <tt>provideUtility()</tt>, <tt>provideHandler()</tt> and so on) to register components.</p>\n<p>Be careful with using this layer in combination with other layers.\nBecause it tears down the component registry between each test, it will clobber any layer that sets up more permanent test fixture in the component registry.</p>\n</div>\n<div id=\"id1\">\n<h4><a href=\"#id88\" rel=\"nofollow\">Event testing</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zca.EVENT_TESTING</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zca.EventTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zca.UNIT_TESTING</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<p>This layer extends the <tt>zca.UNIT_TESTING</tt> layer to enable the <tt>eventtesting</tt> support from <tt>zope.component</tt>.\nUsing this layer, you can import and use <tt>zope.component.eventtesting.getEvent</tt> to inspect events fired by the code under test.</p>\n<p>See above for details.</p>\n</div>\n<div id=\"layer-cleanup\">\n<h4><a href=\"#id89\" rel=\"nofollow\">Layer cleanup</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zca.LAYER_CLEANUP</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zca.LayerCleanup</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td>None</td>\n</tr>\n<tr><td>Resources:</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<p>This layer calls the cleanup functions from <tt>zope.testing.cleanup</tt> on setup and tear-down (but not between each test).\nIt is useful as a base layer for other layers that need an environment as pristine as possible.</p>\n</div>\n<div id=\"basic-zcml-directives\">\n<h4><a href=\"#id90\" rel=\"nofollow\">Basic ZCML directives</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zca.ZCML_DIRECTIVES</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zca.ZCMLDirectives</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zca.LAYER_CLEANUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>configurationContext</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This registers a minimal set of ZCML directives, principally those found in the <tt>zope.component</tt> package, and makes available a configuration context.\nThis allows custom ZCML to be loaded as described above.</p>\n<p>The <tt>configurationContext</tt> resource should be used when loading custom ZCML.\nTo ensure isolation, you should stack this using the <tt>stackConfigurationContext()</tt> helper.\nFor example, if you were writing a <tt>setUp()</tt> method in a layer that had <tt>zca.ZCML_DIRECTIVES</tt> as a base, you could do::</p>\n<pre>self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))\nxmlconfig.string(someZCMLString, context=context)\n</pre>\n<p>This will create a new configuration context with the state of the base layer\u2019s context.\nOn tear-down, you should delete the layer-specific resource::</p>\n<pre>del self['configurationContext']\n</pre>\n<div>\n<p>Note</p>\n<p>If you fail to do this, you may get problems if your layer is torn down and then needs to be set up again later.</p>\n</div>\n<p>See above for more details about loading custom ZCML in a layer or test.</p>\n</div>\n<div id=\"zcml-files-helper-class\">\n<h4><a href=\"#id91\" rel=\"nofollow\">ZCML files helper class</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zca.ZCMLSandbox</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>configurationContext</tt></td>\n</tr>\n</tbody>\n</table>\n<p>The <tt>ZCMLSandbox</tt> can be instantiated with a <tt>filename</tt> and <tt>package</tt> arguments:</p>\n<pre>ZCML_SANDBOX = zca.ZCMLSandbox(filename=\"configure.zcml\",\n    package=my.package)\n</pre>\n<p>That layer <tt>setUp</tt> loads the ZCML file.\nIt avoids the need to using (and understand) <tt>configurationContext</tt> and <tt>globalRegistry</tt> until you need more flexibility or modularity for your layer and tests.</p>\n<p>See above for more details about loading custom ZCML in a layer or test.</p>\n</div>\n<div id=\"helper-functions\">\n<h4><a href=\"#id92\" rel=\"nofollow\">Helper functions</a></h4>\n<p>The following helper functions are available in the <tt>plone.testing.zca</tt> module.</p>\n<p><tt>stackConfigurationContext(context=None)</tt></p>\n<blockquote>\n<p>Create and return a copy of the passed-in ZCML configuration context, or a brand new context if it is <tt>None</tt>.</p>\n<p>The purpose of this is to ensure that if a layer loads some ZCML files (using the <tt>zope.configuration</tt> API during) during its <tt>setUp()</tt>, the state of the configuration registry (which includes registered directives as well as a list of already imported files, which will not be loaded again even if explicitly included) can be torn down during <tt>tearDown()</tt>.</p>\n<p>The usual pattern is to keep the configuration context in a layer resource called <tt>configurationContext</tt>.\nIn <tt>setUp()</tt>, you would then use:</p>\n<pre>self['configurationContext'] = context = zca.stackConfigurationContext(self.get('configurationContext'))\n\n# use 'context' to load some ZCML\n</pre>\n<p>In <tt>tearDown()</tt>, you can then simply do:</p>\n<pre>del self['configurationContext']\n</pre>\n</blockquote>\n<p><tt>pushGlobalRegistry(new=None)</tt></p>\n<blockquote>\n<p>Create or obtain a stack of global component registries, and push a new registry to the top of the stack.\nThe net result is that <tt>zope.component.getGlobalSiteManager()</tt> and (an un-hooked) <tt>getSiteManager()</tt> will return the new registry instead of the default, module-scope one.\nFrom this point onwards, calls to <tt>provideAdapter()</tt>, <tt>provideUtility()</tt> and other functions that modify the global registry will use the new registry.</p>\n<p>If <tt>new</tt> is not given, a new registry is created that has the previous global registry (site manager) as its sole base.\nThis has the effect that registrations in the previous default global registry are still available, but new registrations are confined to the new registry.</p>\n<p><strong>Warning</strong>: If you call this function, you <em>must</em> reciprocally call <tt>popGlobalRegistry()</tt>.\nThat is, if you \u201cpush\u201d a registry during layer <tt>setUp()</tt>, you must \u201cpop\u201d it during <tt>tearDown()</tt>.\nIf you \u201cpush\u201d during <tt>testSetUp()</tt>, you must \u201cpop\u201d during <tt>testTearDown()</tt>.\nIf the calls to push and pop are not balanced, you will leave your global registry in a mess, which is not pretty.</p>\n<p>Returns the new default global site manager.\nAlso causes the site manager hook from <tt>zope.component.hooks</tt> to be reset, clearing any local site managers as appropriate.</p>\n</blockquote>\n<p><tt>popGlobalRegistry()</tt></p>\n<blockquote>\n<p>Pop the global site registry, restoring the previous registry to be the default.</p>\n<p>Please heed the warning above: push and pop must be balanced.</p>\n<p>Returns the new default global site manager.\nAlso causes the site manager hook from <tt>zope.component.hooks</tt> to be reset, clearing any local site managers as appropriate.</p>\n</blockquote>\n</div>\n</div>\n<div id=\"zope-security\">\n<h3><a href=\"#id93\" rel=\"nofollow\">Zope Security</a></h3>\n<p>The Zope Security layers build can be found in the module <tt>plone.testing.security</tt>.</p>\n<p>If you depend on this, you can use the <tt>[security]</tt> extra when depending on <tt>plone.testing</tt>.</p>\n<div id=\"security-checker-isolation\">\n<h4><a href=\"#id94\" rel=\"nofollow\">Security checker isolation</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.security.CHECKERS</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.security.Checkers</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td>None</td>\n</tr>\n<tr><td>Resources:</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<p>This layer ensures that security checkers used by <tt>zope.security</tt> are isolated.\nAny checkers set up in a child layer will be removed cleanly during tear-down.</p>\n</div>\n<div id=\"id2\">\n<h4><a href=\"#id95\" rel=\"nofollow\">Helper functions</a></h4>\n<p>The security checker isolation outlined above is managed using two helper functions found in the module <tt>plone.testing.security</tt>:</p>\n<p><tt>pushCheckers()</tt></p>\n<blockquote>\nCopy the current set of security checkers for later tear-down.</blockquote>\n<p><tt>popCheckers()</tt></p>\n<blockquote>\nRestore the set of security checkers to the state of the most recent call to <tt>pushCheckers()</tt>.</blockquote>\n<p>You <em>must</em> keep calls to <tt>pushCheckers()</tt> and <tt>popCheckers()</tt> in balance.\nThat usually means that if you call the former during layer setup, you should call the latter during layer tear-down.\nDitto for calls during test setup/tear-down or within tests themselves.</p>\n</div>\n</div>\n<div id=\"zope-publisher\">\n<h3><a href=\"#id96\" rel=\"nofollow\">Zope Publisher</a></h3>\n<p>The Zope Publisher layers build on the Zope Component Architecture layers.\nThey can be found in the module <tt>plone.testing.publisher</tt>.</p>\n<p>If you depend on this, you can use the <tt>[publisher]</tt> extra when depending on <tt>plone.testing</tt>.</p>\n<div id=\"publisher-directives\">\n<h4><a href=\"#id97\" rel=\"nofollow\">Publisher directives</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.publisher.PUBLISHER_DIRECTIVES</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.publisher.PublisherDirectives</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zca.ZCML_DIRECTIVES</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td>None</td>\n</tr>\n</tbody>\n</table>\n<p>This layer extends the <tt>zca.ZCML_DIRECTIVES</tt> layer to install additional ZCML directives in the <tt>browser</tt> namespace (from <tt>zope.app.publisher.browser</tt>) as well as those from <tt>zope.security</tt>.\nThis allows browser views, browser pages and other UI components to be registered, as well as the definition of new permissions.</p>\n<p>As with <tt>zca.ZCML_DIRECTIVES</tt>, you should use the <tt>configurationContext</tt> resource when loading ZCML strings or files, and the <tt>stackConfigurationRegistry()</tt> helper to create a layer-specific version of this resource resource.\nSee above.</p>\n</div>\n</div>\n<div id=\"zodb\">\n<h3><a href=\"#id98\" rel=\"nofollow\">ZODB</a></h3>\n<p>The ZODB layers set up a test fixture with a persistent ZODB.\nThe ZODB instance uses <tt>DemoStorage</tt>, so it will not interfere with any \u201clive\u201d data.</p>\n<p>ZODB layers can be found in the module <tt>plone.testing.zodb</tt>.\nIf you depend on this, you can use the <tt>[zodb]</tt> extra when depending on <tt>plone.testing</tt>.</p>\n<div id=\"empty-zodb-sandbox\">\n<h4><a href=\"#id99\" rel=\"nofollow\">Empty ZODB sandbox</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zodb.EMPTY_ZODB</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zodb.EmptyZODB</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td>None</td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>zodbRoot</tt></td>\n</tr>\n<tr><td><tt>zodbDB</tt> (test set-up only)</td>\n</tr>\n<tr><td><tt>zodbConnection</tt> (test set-up only)</td>\n</tr>\n</tbody>\n</table>\n<p>This layer sets up a simple ZODB sandbox using <tt>DemoStorage</tt>.\nThe ZODB root object is a simple persistent mapping, available as the resource <tt>zodbRoot</tt>.\nThe ZODB database object is available as the resource <tt>zodbDB</tt>.\nThe connection used in the test is available as <tt>zodbConnection</tt>.</p>\n<p>Note that the <tt>zodbConnection</tt> and <tt>zodbRoot</tt> resources are created and destroyed for each test.\nYou can use <tt>zodbDB</tt> (and the <tt>open()</tt> method) if you are writing a layer based on this one and need to set up a fixture during layer set up.\nDon\u2019t forget to close the connection before concluding the test setup!</p>\n<p>A new transaction is begun for each test, and rolled back (aborted) on test tear-down.\nThis means that so long as you don\u2019t use <tt>transaction.commit()</tt> explicitly in your code, it should be safe to add or modify items in the ZODB root.</p>\n<p>If you want to create a test fixture with persistent data in your own layer based on <tt>EMPTY_ZODB</tt>, you can use the following pattern:</p>\n<pre>from plone.layer import Layer\nfrom plone.layer import zodb\n\nclass MyLayer(Layer):\n    defaultBases = (zodb.EMPTY_ZODB,)\n\n    def setUp(self):\n\n        import transaction\n        self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')\n\n        conn = db.open()\n        root = conn.root()\n\n        # modify the root object here\n\n        transaction.commit()\n        conn.close()\n\n    def tearDown(self):\n\n        self['zodbDB'].close()\n        del self['zodbDB']\n</pre>\n<p>This shadows the <tt>zodbDB</tt> resource with a new database that uses a new <tt>DemoStorage</tt> stacked on top of the underlying database storage.\nThe fixture is added to this storage and committed during layer setup.\n(The base layer test set-up/tear-down will still begin and abort a new transaction for each <em>test</em>).\nOn layer tear-down, the database is closed and the resource popped, leaving the original <tt>zodbDB</tt> database with the original, pristine storage.</p>\n</div>\n<div id=\"id3\">\n<h4><a href=\"#id100\" rel=\"nofollow\">Helper functions</a></h4>\n<p>One helper function is available in the <tt>plone.testing.zodb</tt> module.</p>\n<p><tt>stackDemoStorage(db=None, name=None)</tt></p>\n<p>Create a new <tt>DemoStorage</tt> using the storage from the passed-in database as a base.\nIf <tt>db</tt> is None, a brand new storage is created.</p>\n<p>A <tt>name</tt> can be given to uniquely identify the storage.\nIt is optional, but it is often useful for debugging purposes to pass the name of the layer.</p>\n<p>The usual pattern is:</p>\n<pre>def setUp(self):\n    self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')\n\ndef tearDown(self):\n    self['zodbDB'].close()\n    del self['zodbDB']\n</pre>\n<p>This will shadow the <tt>zodbDB</tt> resource with an isolated <tt>DemoStorage</tt>, creating a new one if that resource does not already exist.\nAll existing data continues to be available, but new changes are written to the stacked storage.\nOn tear-down, the stacked database is closed and the resource removed, leaving the original data.</p>\n</div>\n</div>\n<div id=\"zope\">\n<h3><a href=\"#id101\" rel=\"nofollow\">Zope</a></h3>\n<p>The Zope layers provide test fixtures suitable for testing Zope applications.\nThey set up a Zope application root, install core Zope products, and manage security.</p>\n<p>Zope layers can be found in the module <tt>plone.testing.zope</tt>.\nIf you depend on this, you can use the <tt>[zope]</tt> extra when depending on <tt>plone.testing</tt>.</p>\n<div id=\"startup\">\n<h4><a href=\"#id102\" rel=\"nofollow\">Startup</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zope.STARTUP</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zope.Startup</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zca.LAYER_CLEANUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>zodbDB</tt></td>\n</tr>\n<tr><td><tt>configurationContext</tt></td>\n</tr>\n<tr><td><tt>host</tt></td>\n</tr>\n<tr><td><tt>port</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This layer sets up a Zope environment, and is a required base for all other Zope layers.\nYou cannot run two instances of this layer in parallel, since Zope depends on some module-global state to run, which is managed by this layer.</p>\n<p>On set-up, the layer will configure a Zope environment with:</p>\n<div>\n<p>Note</p>\n<p>The <tt>STARTUP</tt> layer is a useful base layer for your own fixtures, but should not be used directly, since it provides no test lifecycle or transaction management.\nSee the \u201cIntegration test\u201d and \u201cFunctional\u201d test sections below for examples of how to create your own layers.</p>\n</div>\n<ul>\n<li>Debug mode enabled.</li>\n<li>ZEO client cache disabled.</li>\n<li>Some patches installed, which speed up Zope startup by disabling some superfluous aspects of Zope.</li>\n<li>One thread (this only really affects the <tt>WSGI_SERVER</tt>, <tt>ZSERVER</tt> and <tt>FTP_SERVER</tt> layers).</li>\n<li>A pristine database using <tt>DemoStorage</tt>, exposed as the resource <tt>zodbDB</tt>.\nZope is configured to use this database in a way that will also work if the <tt>zodbDB</tt> resource is shadowed using the pattern shown above in the description of the <tt>zodb.EMPTY_ZODB</tt> layer.</li>\n<li>A fake hostname and port, exposed as the <tt>host</tt> and <tt>port</tt> resource, respectively.</li>\n<li>A minimal set of products installed (<tt>Products.OFSP</tt> and <tt>Products.PluginIndexes</tt>, both required for Zope to start up).</li>\n<li>A stacked ZCML configuration context, exposed as the resource <tt>configurationContext</tt>.\nAs illustrated above, you should use the <tt>zca.stackConfigurationContext()</tt> helper to stack your own configuration context if you use this.</li>\n<li>A minimal set of global Zope components configured.</li>\n</ul>\n<p>Note that unlike a \u201creal\u201d Zope site, products in the <tt>Products.*</tt> namespace are not automatically loaded, nor is any ZCML.</p>\n</div>\n<div id=\"integration-test\">\n<h4><a href=\"#id103\" rel=\"nofollow\">Integration test</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zope.INTEGRATION_TESTING</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zope.IntegrationTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zope.STARTUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>app</tt></td>\n</tr>\n<tr><td><tt>request</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This layer is intended for integration testing against the simple <tt>STARTUP</tt> fixture.\nIf you want to create your own layer with a more advanced, shared fixture, see \u201cIntegration and functional testing with custom fixtures\u201d below.</p>\n<p>For each test, it exposes the Zope application root as the resource <tt>app</tt>.\nThis is wrapped in the request container, so you can do <tt>app.REQUEST</tt> to acquire a fake request, but the request is also available as the resource <tt>request</tt>.</p>\n<p>A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.</p>\n<blockquote>\n<p><em>Hint:</em> If you want to set up a persistent test fixture in a layer based on this one (or <tt>zope.FUNCTIONAL_TESTING</tt>), you can stack a new <tt>DemoStorage</tt> in a shadowing <tt>zodbDB</tt> resource, using the pattern described above for the <tt>zodb.EMPTY_ZODB</tt> layer.</p>\n<p>Once you\u2019ve shadowed the <tt>zodbDB</tt> resource, you can do (e.g. in your layer\u2019s <tt>setUp()</tt> method):</p>\n<pre>...\nwith zope.zopeApp() as app:\n    # modify the Zope application root\n</pre>\n<p>The <tt>zopeApp()</tt> context manager will open a new connection to the Zope application root, accessible here as <tt>app</tt>.\nProvided the code within the <tt>with</tt> block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.</p>\n</blockquote>\n</div>\n<div id=\"id4\">\n<h4><a href=\"#id104\" rel=\"nofollow\">Functional testing</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zope.FUNCTIONAL_TESTING</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zope.FunctionalTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zope.STARTUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>app</tt></td>\n</tr>\n<tr><td><tt>request</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This layer is intended for functional testing against the simple <tt>STARTUP</tt> fixture.\nIf you want to create your own layer with a more advanced, shared fixture, see \u201cIntegration and functional testing with custom fixtures\u201d below.</p>\n<p>As its name implies, this layer is intended mainly for functional end-to-end testing using tools like <a href=\"https://pypi.org/project/zope.testbrowser\" rel=\"nofollow\">zope.testbrowser</a>.\nSee also the <tt>Browser</tt> object as described under \u201cHelper functions\u201d below.</p>\n<p>This layer is very similar to <tt>INTEGRATION_TESTING</tt>, but is not based on it.\nIt sets up the same fixture and exposes the same resources.\nHowever, instead of using a simple transaction abort to isolate the ZODB between tests, it uses a stacked <tt>DemoStorage</tt> for each test.\nThis is slower, but allows test code to perform and explicit commit, as will usually happen in a functional test.</p>\n</div>\n<div id=\"integration-and-functional-testing-with-custom-fixtures\">\n<h4><a href=\"#id105\" rel=\"nofollow\">Integration and functional testing with custom fixtures</a></h4>\n<p>If you want to extend the <tt>STARTUP</tt> fixture for use with integration or functional testing, you should use the following pattern:</p>\n<ul>\n<li>Create a layer class and a \u201cfixture\u201d base layer instance that has <tt>zope.STARTUP</tt> (or some intermediary layer, such as <tt>zope.WSGI_SERVER_FIXTURE</tt>, shown below) as a base.</li>\n<li>Create \u201cend user\u201d layers by instantiating the <tt>zope.IntegrationTesting</tt> and/or <tt>FunctionalTesting</tt> classes with this new \u201cfixture\u201d layer as a base.</li>\n</ul>\n<p>This allows the same fixture to be used regardless of the \u201cstyle\u201d of testing, minimising the amount of set-up and tear-down.\nThe \u201cfixture\u201d layers manage the fixture as part of the <em>layer</em> lifecycle.\nThe layer class (<tt>IntegrationTesting</tt> or <tt>FunctionalTesting</tt>), manages the <em>test</em> lifecycle, and the test lifecycle only.</p>\n<p>For example:</p>\n<pre>from plone.testing import Layer, zope, zodb\n\nclass MyLayer(Layer):\n    defaultBases = (zope.STARTUP,)\n\n    def setUp(self):\n        # Set up the fixture here\n        ...\n\n    def tearDown(self):\n        # Tear down the fixture here\n        ...\n\nMY_FIXTURE = MyLayer()\n\nMY_INTEGRATION_TESTING = zope.IntegrationTesting(bases=(MY_FIXTURE,), name=\"MyFixture:Integration\")\nMY_FUNCTIONAL_TESTING = zope.FunctionalTesting(bases=(MY_FIXTURE,), name=\"MyFixture:Functional\")\n</pre>\n<p>(Note that we need to give an explicit, unique name to the two layers that re-use the <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt> classes.)</p>\n<p>In this example, other layers could extend the \u201cMyLayer\u201d fixture by using <tt>MY_FIXTURE</tt> as a base.\nTests would use either <tt>MY_INTEGRATION_TESTING</tt> or <tt>MY_FUNCTIONAL_TESTING</tt> as appropriate.\nHowever, even if both these two layers were used, the fixture in <tt>MY_FIXTURE</tt> would only be set up once.</p>\n<div>\n<p>Note</p>\n<p>If you implement the <tt>testSetUp()</tt> and <tt>testTearDown()</tt> test lifecycle methods in your \u201cfixture\u201d layer (e.g. in the the <tt>MyLayer</tt> class above), they will execute before the corresponding methods from <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt>.\nHence, they cannot use those layers\u2019 resources (<tt>app</tt> and <tt>request</tt>).</p>\n</div>\n<p>It may be preferable, therefore, to have your own \u201ctest lifecycle\u201d layer classes that subclass <tt>IntegrationTesting</tt> and/or <tt>FunctionalTesting</tt> and call base class methods as appropriate.\n<tt>plone.app.testing</tt> takes this approach, for example.</p>\n</div>\n<div id=\"http-wsgi-server-thread-fixture-only\">\n<h4><a href=\"#id106\" rel=\"nofollow\">HTTP WSGI server thread (fixture only)</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zope.WSGI_SERVER_FIXTURE</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zope.WSGIServer</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zope.STARTUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>host</tt></td>\n</tr>\n<tr><td><tt>port</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This layer extends the <tt>zope.STARTUP</tt> layer to start the Zope HTTP WSGI server in a separate thread.\nThis means the test site can be accessed through a web browser, and can thus be used with tools like <a href=\"http://seleniumhq.org/\" rel=\"nofollow\">Selenium</a>.</p>\n<div>\n<p>Note</p>\n<p>This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\nUse the <tt>WSGI_SERVER</tt> layer if you want to execute functional tests against this fixture.</p>\n</div>\n<p>The WSGI server\u2019s hostname (normally <tt>localhost</tt>) is available through the resource <tt>host</tt>, whilst the port it is running on is available through the resource <tt>port</tt>.</p>\n<blockquote>\n<em>Hint:</em> Whilst the layer is set up, you can actually access the test Zope site through a web browser.\nThe default URL will be <tt><span class=\"pre\">http://localhost:55001</span></tt>.</blockquote>\n</div>\n<div id=\"http-wsgi-server-functional-testing\">\n<h4><a href=\"#id107\" rel=\"nofollow\">HTTP WSGI server functional testing</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zope.WSGI_SERVER</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zope.FunctionalTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zope.WSGI_SERVER_FIXTURE</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td>\u00a0</td>\n</tr>\n</tbody>\n</table>\n<p>This layer provides the functional testing lifecycle against the fixture set up by the <tt>zope.WSGI_SERVER_FIXTURE</tt> layer.</p>\n<p>You can use this to run \u201clive\u201d functional tests against a basic Zope site.\nYou should <strong>not</strong> use it as a base.\nInstead, create your own \u201cfixture\u201d layer that extends <tt>zope.WSGI_SERVER_FIXTURE</tt>, and then instantiate the <tt>FunctionalTesting</tt> class with this extended fixture layer as a base, as outlined above.</p>\n</div>\n<div id=\"id5\">\n<h4><a href=\"#id108\" rel=\"nofollow\">Helper functions</a></h4>\n<p>Several helper functions are available in the <tt>plone.testing.zope</tt> module.</p>\n<p><tt>zopeApp(db=None, conn=Non, environ=None)</tt></p>\n<blockquote>\n<p>This function can be used as a context manager for any code that requires access to the Zope application root.\nBy using it in a <tt>with</tt> block, the database will be opened, and the application root will be obtained and request-wrapped.\nWhen exiting the <tt>with</tt> block, the transaction will be committed and the database properly closed, unless an exception was raised:</p>\n<pre>with zope.zopeApp() as app:\n    # do something with app\n</pre>\n<p>If you want to use a specific database or database connection, pass either the <tt>db</tt> or <tt>conn</tt> arguments.\nIf the context manager opened a new connection, it will close it, but it will not close a connection passed with <tt>conn</tt>.</p>\n<p>To set keys in the (fake) request environment, pass a dictionary of environment values as <tt>environ</tt>.</p>\n<p>Note that <tt>zopeApp()</tt> should <em>not</em> normally be used in tests or test set-up/tear-down, because the <tt>INTEGRATOIN_TEST</tt> and <tt>FUNCTIONAL_TESTING</tt> layers both manage the application root (as the <tt>app</tt> resource) and close it for you.\nIt is very useful in layer setup, however.</p>\n</blockquote>\n<p><tt>installProduct(app, product, quiet=False)</tt></p>\n<blockquote>\n<p>Install a Zope 2 style product, ensuring that its <tt>initialize()</tt> function is called.\nThe product name must be the full dotted name, e.g. <tt>plone.app.portlets</tt> or <tt>Products.CMFCore</tt>.\nIf <tt>quiet</tt> is true, duplicate registrations will be ignored silently, otherwise a message is logged.</p>\n<p>To get hold of the application root, passed as the <tt>app</tt> argument, you would normally use the <tt>zopeApp()</tt> context manager outlined above.</p>\n</blockquote>\n<p><tt>uninstallProduct(app, product, quiet=False)</tt></p>\n<blockquote>\nThis is the reciprocal of <tt>installProduct()</tt>, normally used during layer tear-down.\nAgain, you should use <tt>zopeApp()</tt> to obtain the application root.</blockquote>\n<p><tt>login(userFolder, userName)</tt></p>\n<blockquote>\nCreate a new security manager that simulates being logged in as the given user.\n<tt>userFolder</tt> is an <tt>acl_users</tt> object, e.g. <tt><span class=\"pre\">app['acl_users']</span></tt> for the root user folder.</blockquote>\n<p><tt>logout()</tt></p>\n<blockquote>\nSimulate being the anonymous user by unsetting the security manager.</blockquote>\n<p><tt>setRoles(userFolder, userName, roles)</tt></p>\n<blockquote>\nSet the roles of the given user in the given user folder to the given list of roles.</blockquote>\n<p><tt>makeTestRequest()</tt></p>\n<blockquote>\nCreate a fake Zope request.</blockquote>\n<p><tt>addRequestContainer(app, environ=None)</tt></p>\n<blockquote>\n<p>Create a fake request and wrap the given object (normally an application root) in a <tt>RequestContainer</tt> with this request.\nThis makes acquisition of <tt>app.REQUEST</tt> possible.\nTo initialise the request environment with non-default values, pass a dictionary as <tt>environ</tt>.</p>\n<div>\n<p>Note</p>\n<p>This method is rarely used, because both the <tt>zopeApp()</tt>\ncontext manager and the layer set-up/tear-down for\n<tt>zope.INTEGRATION_TESTING</tt> and <tt>zope.FUNCTIONAL_TESTING</tt> will wrap the\n<tt>app</tt> object before exposing it.</p>\n</div>\n</blockquote>\n<p><tt>Browser(app)</tt></p>\n<blockquote>\n<p>Obtain a test browser client, for use with <a href=\"https://pypi.org/project/zope.testbrowser\" rel=\"nofollow\">zope.testbrowser</a>.\nYou should use this in conjunction with the <tt>zope.FUNCTIONAL_TESTING</tt> layer or a derivative.\nYou must pass the app root, usually obtained from the <tt>app</tt> resource of the layer, e.g.:</p>\n<pre>app = self.layer['app']\nbrowser = zope.Browser(app)\n</pre>\n<p>You can then use <tt>browser</tt> as described in the <a href=\"https://pypi.org/project/zope.testbrowser\" rel=\"nofollow\">zope.testbrowser</a> documentation.</p>\n<p>Bear in mind that the test browser runs separately from the test fixture.\nIn particular, calls to helpers such as <tt>login()</tt> or <tt>logout()</tt> do not affect the state that the test browser sees.\nIf you want to set up a persistent fixture (e.g. test content), you can do so before creating the test browser, but you will need to explicitly commit your changes, with:</p>\n<pre>import transaction\ntransaction.commit()\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"zserver\">\n<h3><a href=\"#id109\" rel=\"nofollow\">ZServer</a></h3>\n<p>The ZServer layers provide test fixtures suitable for testing Zope applications while using ZServer instead of a WSGI server.\nThey set up a Zope application root, install core Zope products, and manage security.</p>\n<p>ZServer layers can be found in the module <tt>plone.testing.zserver</tt>.\nIf you depend on this, you can use the <tt>[zope,zserver]</tt> extra when depending on <tt>plone.testing</tt>.</p>\n<div id=\"id6\">\n<h4><a href=\"#id110\" rel=\"nofollow\">Startup</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zserver.STARTUP</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zserver.Startup</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zca.LAYER_CLEANUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>zodbDB</tt></td>\n</tr>\n<tr><td><tt>configurationContext</tt></td>\n</tr>\n<tr><td><tt>host</tt></td>\n</tr>\n<tr><td><tt>port</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This layer sets up a Zope environment for ZServer, and is a required base for all other ZServer layers.\nYou cannot run two instances of this layer in parallel, since Zope depends on some module-global state to run, which is managed by this layer.</p>\n<p>On set-up, the layer will configure a Zope environment with the same options as <tt>zope.Startup</tt>, see there.</p>\n</div>\n<div id=\"id7\">\n<h4><a href=\"#id111\" rel=\"nofollow\">Integration test</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zserver.INTEGRATION_TESTING</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zserver.IntegrationTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zserver.STARTUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>app</tt></td>\n</tr>\n<tr><td><tt>request</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This layer is intended for integration testing against the simple <tt>STARTUP</tt> fixture.\nIf you want to create your own layer with a more advanced, shared fixture, see \u201cIntegration and functional testing with custom fixtures\u201d below.</p>\n<p>For each test, it exposes the Zope application root as the resource <tt>app</tt>.\nThis is wrapped in the request container, so you can do <tt>app.REQUEST</tt> to acquire a fake request, but the request is also available as the resource <tt>request</tt>.</p>\n<p>A new transaction is begun for each test and rolled back on test tear-down, meaning that so long as the code under test does not explicitly commit any changes, the test may modify the ZODB.</p>\n<blockquote>\n<p><em>Hint:</em> If you want to set up a persistent test fixture in a layer based on this one (or <tt>zserver.FUNCTIONAL_TESTING</tt>), you can stack a new <tt>DemoStorage</tt> in a shadowing <tt>zodbDB</tt> resource, using the pattern described above for the <tt>zodb.EMPTY_ZODB</tt> layer.</p>\n<p>Once you\u2019ve shadowed the <tt>zodbDB</tt> resource, you can do (e.g. in your layer\u2019s <tt>setUp()</tt> method):</p>\n<pre>...\nwith zserver.zopeApp() as app:\n    # modify the Zope application root\n</pre>\n<p>The <tt>zserver.zopeApp()</tt> context manager will open a new connection to the Zope application root, accessible here as <tt>app</tt>.\nProvided the code within the <tt>with</tt> block does not raise an exception, the transaction will be committed and the database closed properly upon exiting the block.</p>\n</blockquote>\n</div>\n<div id=\"id8\">\n<h4><a href=\"#id112\" rel=\"nofollow\">Functional testing</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zserver.FUNCTIONAL_TESTING</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zserver.FunctionalTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zserver.STARTUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>app</tt></td>\n</tr>\n<tr><td><tt>request</tt></td>\n</tr>\n</tbody>\n</table>\n<p>It behaves the same as <tt>zope.FunctionalTesting</tt>, see there.</p>\n</div>\n<div id=\"id9\">\n<h4><a href=\"#id113\" rel=\"nofollow\">Integration and functional testing with custom fixtures</a></h4>\n<p>If you want to extend the <tt>STARTUP</tt> fixture for use with integration or functional testing, you should use the following pattern:</p>\n<ul>\n<li>Create a layer class and a \u201cfixture\u201d base layer instance that has <tt>zserver.STARTUP</tt> (or some intermediary layer, such as <tt>zserver.ZSERVER_FIXTURE</tt> or <tt>zserver.FTP_SERVER_FIXTURE</tt>, shown below) as a base.</li>\n<li>Create \u201cend user\u201d layers by instantiating the <tt>zserver.IntegrationTesting</tt> and/or <tt>FunctionalTesting</tt> classes with this new \u201cfixture\u201d layer as a base.</li>\n</ul>\n<p>This allows the same fixture to be used regardless of the \u201cstyle\u201d of testing, minimising the amount of set-up and tear-down.\nThe \u201cfixture\u201d layers manage the fixture as part of the <em>layer</em> lifecycle.\nThe layer class (<tt>IntegrationTesting</tt> or <tt>FunctionalTesting</tt>), manages the <em>test</em> lifecycle, and the test lifecycle only.</p>\n<p>For example:</p>\n<pre>from plone.testing import Layer, zserver, zodb\n\nclass MyLayer(Layer):\n    defaultBases = (zserver.STARTUP,)\n\n    def setUp(self):\n        # Set up the fixture here\n        ...\n\n    def tearDown(self):\n        # Tear down the fixture here\n        ...\n\nMY_FIXTURE = MyLayer()\n\nMY_INTEGRATION_TESTING = zserver.IntegrationTesting(bases=(MY_FIXTURE,), name=\"MyFixture:Integration\")\nMY_FUNCTIONAL_TESTING = zserver.FunctionalTesting(bases=(MY_FIXTURE,), name=\"MyFixture:Functional\")\n</pre>\n<p>(Note that we need to give an explicit, unique name to the two layers that re-use the <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt> classes.)</p>\n<p>In this example, other layers could extend the \u201cMyLayer\u201d fixture by using <tt>MY_FIXTURE</tt> as a base.\nTests would use either <tt>MY_INTEGRATION_TESTING</tt> or <tt>MY_FUNCTIONAL_TESTING</tt> as appropriate.\nHowever, even if both these two layers were used, the fixture in <tt>MY_FIXTURE</tt> would only be set up once.</p>\n<div>\n<p>Note</p>\n<p>If you implement the <tt>testSetUp()</tt> and <tt>testTearDown()</tt> test lifecycle methods in your \u201cfixture\u201d layer (e.g. in the the <tt>MyLayer</tt> class above), they will execute before the corresponding methods from <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt>.\nHence, they cannot use those layers\u2019 resources (<tt>app</tt> and <tt>request</tt>).</p>\n</div>\n<p>It may be preferable, therefore, to have your own \u201ctest lifecycle\u201d layer classes that subclass <tt>IntegrationTesting</tt> and/or <tt>FunctionalTesting</tt> and call base class methods as appropriate.\n<tt>plone.app.testing</tt> takes this approach, for example.</p>\n</div>\n<div id=\"http-zserver-thread-fixture-only\">\n<h4><a href=\"#id114\" rel=\"nofollow\">HTTP ZServer thread (fixture only)</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zserver.ZSERVER_FIXTURE</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zserver.ZServer</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zserver.STARTUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>host</tt></td>\n</tr>\n<tr><td><tt>port</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This layer extends the <tt>zserver.STARTUP</tt> layer to start the Zope HTTP server (ZServer) in a separate thread.\nThis means the test site can be accessed through a web browser, and can thus be used with tools like <a href=\"http://seleniumhq.org/\" rel=\"nofollow\">Selenium</a>.</p>\n<div>\n<p>Note</p>\n<p>This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\nUse the <tt>ZSERVER</tt> layer if you want to execute functional tests against this fixture.</p>\n</div>\n<p>The ZServer\u2019s hostname (normally <tt>localhost</tt>) is available through the resource <tt>host</tt>, whilst the port it is running on is available through the resource <tt>port</tt>.</p>\n<blockquote>\n<em>Hint:</em> Whilst the layer is set up, you can actually access the test Zope site through a web browser.\nThe default URL will be <tt><span class=\"pre\">http://localhost:55001</span></tt>.</blockquote>\n</div>\n<div id=\"http-zserver-functional-testing\">\n<h4><a href=\"#id115\" rel=\"nofollow\">HTTP ZServer functional testing</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zserver.ZSERVER</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zserver.FunctionalTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zserver.ZSERVER_FIXTURE</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td>\u00a0</td>\n</tr>\n</tbody>\n</table>\n<p>This layer provides the functional testing lifecycle against the fixture set up by the <tt>zserver.ZSERVER_FIXTURE</tt> layer.</p>\n<p>You can use this to run \u201clive\u201d functional tests against a basic Zope site.\nYou should <strong>not</strong> use it as a base.\nInstead, create your own \u201cfixture\u201d layer that extends <tt>zserver.ZSERVER_FIXTURE</tt>, and then instantiate the <tt>FunctionalTesting</tt> class with this extended fixture layer as a base, as outlined above.</p>\n</div>\n<div id=\"ftp-server-thread-fixture-only\">\n<h4><a href=\"#id116\" rel=\"nofollow\">FTP server thread (fixture only)</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zserver.FTP_SERVER_FIXTURE</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zserver.FTPServer</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zserver.STARTUP</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td><tt>host</tt></td>\n</tr>\n<tr><td><tt>port</tt></td>\n</tr>\n</tbody>\n</table>\n<p>This layer is the FTP server equivalent of the <tt>zserver.ZSERVER_FIXTURE</tt> layer.\nIt can be used to functionally test Zope FTP servers.</p>\n<div>\n<p>Note</p>\n<p>This layer is useful as a fixture base layer only, because it does not manage the test lifecycle.\nUse the <tt>FTP_SERVER</tt> layer if you want to execute functional tests against this fixture.</p>\n<p><em>Hint:</em> Whilst the layer is set up, you can actually access the test Zope site through an FTP client.\nThe default URL will be <tt><span class=\"pre\">ftp://localhost:55002</span></tt>.</p>\n</div>\n<div>\n<p>Warning</p>\n<p>Do not run the <tt>FTP_SERVER</tt> and <tt>ZSERVER</tt> layers concurrently in the same process.</p>\n</div>\n<p>If you need both ZServer and FTPServer running together, you can subclass the <tt>ZServer</tt> layer class (like the <tt>FTPServer</tt> layer class does) and implement the <tt>setUpServer()</tt> and <tt>tearDownServer()</tt> methods to set up and close down two servers on different ports.\nThey will then share a main loop.</p>\n</div>\n<div id=\"ftp-server-functional-testing\">\n<h4><a href=\"#id117\" rel=\"nofollow\">FTP server functional testing</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Layer:</td>\n<td><tt>plone.testing.zserver.FTP_SERVER</tt></td>\n</tr>\n<tr><td>Class:</td>\n<td><tt>plone.testing.zserver.FunctionalTesting</tt></td>\n</tr>\n<tr><td>Bases:</td>\n<td><tt>plone.testing.zserver.FTP_SERVER_FIXTURE</tt></td>\n</tr>\n<tr><td>Resources:</td>\n<td>\u00a0</td>\n</tr>\n</tbody>\n</table>\n<p>This layer provides the functional testing lifecycle against the fixture set up by the <tt>zserver.FTP_SERVER_FIXTURE</tt> layer.</p>\n<p>You can use this to run \u201clive\u201d functional tests against a basic Zope site.\nYou should <strong>not</strong> use it as a base.\nInstead, create your own \u201cfixture\u201d layer that extends <tt>zserver.FTP_SERVER_FIXTURE</tt>, and then instantiate the <tt>FunctionalTesting</tt> class with this extended fixture layer as a base, as outlined above.</p>\n</div>\n<div id=\"id10\">\n<h4><a href=\"#id118\" rel=\"nofollow\">Helper functions</a></h4>\n<p>Several helper functions are available in the <tt>plone.testing.zserver</tt> module.</p>\n<p><tt>zopeApp(db=None, conn=Non, environ=None)</tt></p>\n<blockquote>\n<p>This function can be used as a context manager for any code that requires access to the Zope application root.\nBy using it in a <tt>with</tt> block, the database will be opened, and the application root will be obtained and request-wrapped.\nWhen exiting the <tt>with</tt> block, the transaction will be committed and the database properly closed, unless an exception was raised:</p>\n<pre>with zserver.zopeApp() as app:\n    # do something with app\n</pre>\n<p>If you want to use a specific database or database connection, pass either the <tt>db</tt> or <tt>conn</tt> arguments.\nIf the context manager opened a new connection, it will close it, but it will not close a connection passed with <tt>conn</tt>.</p>\n<p>To set keys in the (fake) request environment, pass a dictionary of environment values as <tt>environ</tt>.</p>\n<p>Note that <tt>zopeApp()</tt> should <em>not</em> normally be used in tests or test set-up/tear-down, because the <tt>INTEGRATOIN_TEST</tt> and <tt>FUNCTIONAL_TESTING</tt> layers both manage the application root (as the <tt>app</tt> resource) and close it for you.\nIt is very useful in layer setup, however.</p>\n</blockquote>\n<p>The other helper functions defined in <tt>plone.testing.zope</tt> can also be used in a ZServer context but together with the ZServer layers.</p>\n</div>\n</div>\n</div>\n<div id=\"changelog\">\n<h2><a href=\"#id119\" rel=\"nofollow\">Changelog</a></h2>\n<div id=\"id13\">\n<h3><a href=\"#id120\" rel=\"nofollow\">8.0.0 (2020-04-21)</a></h3>\n<p>Breaking changes:</p>\n<ul>\n<li>Drop support for Python 3.4 and 3.5.\nRemove \u201cz2\u201d extra.\n[jensens] (#72)</li>\n</ul>\n<p>New features:</p>\n<ul>\n<li>Update links for further information about <cite>testing</cite>.\n[jugmac00] (#71)</li>\n</ul>\n<p>Bug fixes:</p>\n<ul>\n<li>Fix tests when using zope.testrunner internals since its version 5.1.\n[jensens] (#72)</li>\n</ul>\n</div>\n<div id=\"id14\">\n<h3><a href=\"#id121\" rel=\"nofollow\">7.0.3 (2019-12-10)</a></h3>\n<p>Bug fixes:</p>\n<ul>\n<li>Fix issue with test-setup when using ZServer 4.0.2.\n[pbauer] (#69)</li>\n</ul>\n</div>\n<div id=\"id15\">\n<h3><a href=\"#id122\" rel=\"nofollow\">7.0.2 (2019-07-06)</a></h3>\n<p>Bug fixes:</p>\n<ul>\n<li>Remove the <tt>ZOPETESTCASEALERT</tt> as it imports from ZopeTestCase and has side effects.\nFixes #64.\n[thet] (#67)</li>\n</ul>\n</div>\n<div id=\"id16\">\n<h3><a href=\"#id123\" rel=\"nofollow\">7.0.1 (2019-03-03)</a></h3>\n<p>Bug fixes:</p>\n<ul>\n<li>Fixed test for \u2018Connection refused\u2019 which could be \u2018Connection reset\u2019.\n[maurits] (#59)</li>\n</ul>\n</div>\n<div id=\"id17\">\n<h3><a href=\"#id124\" rel=\"nofollow\">7.0.0 (2018-10-17)</a></h3>\n<p>Breaking changes:</p>\n<ul>\n<li><tt>plone.testing.z2</tt> is now a BBB shim for <tt>plone.testing.zope</tt>,\nthus it switches the tests to use WSGI.\nIf you absolutely want to keep using ZServer please import from <tt>plone.testing.zserver</tt>.</li>\n<li><tt>plone.testing.z2</tt> now only contains a no-op FTPServer layer because FTP is not supported by WSGI.\nIf you really need it, import it from <tt>plone.testing.zserver</tt> but this will not work on Python 3.</li>\n<li>Default to picking a dynamical port for ZServer layers instead of a static\ndefault port.\n[Rotonen]</li>\n</ul>\n<p>New features:</p>\n<ul>\n<li>Make <tt>ZServer</tt> an optional dependency.</li>\n<li>Add support for Python 3.6.\n[rudaporto, icemac]</li>\n</ul>\n<p>Bug fixes:</p>\n<ul>\n<li>Explicitly depend on ZServer on the z2 extra.\n[Rotonen]</li>\n</ul>\n</div>\n<div id=\"id18\">\n<h3><a href=\"#id125\" rel=\"nofollow\">6.1.0 (2018-10-05)</a></h3>\n<p>Breaking changes:</p>\n<ul>\n<li>Default to picking a dynamical port for ZServer layers instead of a static\ndefault port.\n[Rotonen]</li>\n</ul>\n<p>Bug fixes:</p>\n<ul>\n<li>Pinned ZODB to &lt; 5.4.0 for testing to avoid flaky doctest layer teardowns.\n[Rotonen]</li>\n<li>Loosened doctest assertions to keep up with Zope-side changes.\n[Rotonen]</li>\n<li>Fix most of the code smells Jenkins complains about.</li>\n<li>Fix the Zope exception hook when using the ZServer layer.</li>\n<li>Fix teardown of the <tt>plone.testing.security.Checkers</tt> layer.\nIt was not properly restoring zope.security\u2019s <tt>_checkers</tt> dict.</li>\n</ul>\n</div>\n<div id=\"id19\">\n<h3><a href=\"#id126\" rel=\"nofollow\">6.0.0 (2018-02-05)</a></h3>\n<ul>\n<li>Breaking changes:<ul>\n<li>Only support <tt>Zope &gt;= 4</tt>, no longer support <tt>Zope2</tt>.</li>\n<li>Drop support for Python 2.6.</li>\n</ul>\n</li>\n<li>No longer use deprecated import for getSite/setSite.\n[jensens]</li>\n<li>Update code to follow Plone styleguide.\n[gforcada]</li>\n</ul>\n</div>\n<div id=\"id20\">\n<h3><a href=\"#id127\" rel=\"nofollow\">5.1.1 (2017-04-19)</a></h3>\n<ul>\n<li>Do not break on import of <tt>plone.testing.z2</tt> when using <cite>zope.testbrowser</cite> &gt;= 5.0 which no longer depends on <cite>mechanize</cite>.</li>\n</ul>\n</div>\n<div id=\"id21\">\n<h3><a href=\"#id128\" rel=\"nofollow\">5.1 (2017-04-13)</a></h3>\n<ul>\n<li>Fix for ZODB 5: Abort transaction before DB close.\n[jensens, jimfulton]</li>\n<li>Remove BBB code and imports for Zope &lt; 2.13.\n[thet]</li>\n<li>Fix issue, which prevented using layered-helper on Python 3.\n[datakurre]</li>\n<li>Fix <tt>.z2.Startup.setUpZCML()</tt> to be compatible with Zope &gt;= 4.0a2.\n[icemac]</li>\n<li>Fix version pins on the package itself to be able to run the tests.\n[gforcada]</li>\n</ul>\n</div>\n<div id=\"id22\">\n<h3><a href=\"#id129\" rel=\"nofollow\">5.0.0 (2016-02-19)</a></h3>\n<p>Rerelease of 4.2.0 as 5.0.0.</p>\n<p>The version 4.2.0 had changed error handling in the public api, causing exceptions where before everything continued to work.</p>\n</div>\n<div id=\"id23\">\n<h3><a href=\"#id130\" rel=\"nofollow\">4.2.0 (2016-02-18)</a></h3>\n<p>New:</p>\n<ul>\n<li>Refuse to work if user breaks test isolation.\n[do3cc]</li>\n<li>Check that tests don\u2019t run together with ZopeTestCase\n[do3cc]</li>\n</ul>\n<p>Fixes:</p>\n<ul>\n<li>Fix tests for Zope 4, where the app root Control_Panel is not available anymore.\n[thet]</li>\n</ul>\n</div>\n<div id=\"id24\">\n<h3><a href=\"#id131\" rel=\"nofollow\">4.1.0 (2016-01-08)</a></h3>\n<p>Fixes:</p>\n<ul>\n<li>Rename all txt doctest files to rst. Reformat doctests.\n[thet]</li>\n<li>PEP 8.\n[thet]</li>\n<li>Depend on zope.testrunner, which was moved out from zope.testing.testrunner.\n[thet]</li>\n<li>Add support for Zope 4.\n[thet]</li>\n</ul>\n</div>\n<div id=\"id25\">\n<h3><a href=\"#id132\" rel=\"nofollow\">4.0.15 (2015-08-14)</a></h3>\n<ul>\n<li>Prevent exception masking in finally clause of zopeApp context.\n[do3cc]</li>\n</ul>\n</div>\n<div id=\"id26\">\n<h3><a href=\"#id133\" rel=\"nofollow\">4.0.14 (2015-07-29)</a></h3>\n<ul>\n<li>Rerelease for clarity due to double release of 4.0.13.\n[maurits]</li>\n<li>Added <tt>multiinit</tt>-parameter to z2.installProduct to allow multiple initialize methods for a package\n[tomgross]</li>\n</ul>\n</div>\n<div id=\"id27\">\n<h3><a href=\"#id134\" rel=\"nofollow\">4.0.13 (2015-03-13)</a></h3>\n<ul>\n<li>Really fix not to depend on unittest2.\n[icemac]</li>\n<li>Add tox.ini\n[icemac]</li>\n</ul>\n</div>\n<div id=\"id28\">\n<h3><a href=\"#id135\" rel=\"nofollow\">4.0.12 (2014-09-07)</a></h3>\n<ul>\n<li>Fixed AttributeError when importing <tt>plone.testing.z2</tt> if <tt>zope.testbrowser</tt> 4.x is used but not <tt>zope.app.testing</tt>.\n[icemac]</li>\n<li>Broke dependency on <cite>unittest2</cite> for Python 2.7+ as all features of <cite>unittest2</cite> are integrated in <cite>unittest</cite> there.\n[icemac]</li>\n</ul>\n</div>\n<div id=\"id29\">\n<h3><a href=\"#id136\" rel=\"nofollow\">4.0.11 (2014-02-22)</a></h3>\n<ul>\n<li>Fix z2.txt doctest for FTP_SERVER.\n[timo]</li>\n</ul>\n</div>\n<div id=\"id30\">\n<h3><a href=\"#id137\" rel=\"nofollow\">4.0.10 (2014-02-11)</a></h3>\n<ul>\n<li>Read \u2018FTPSERVER_HOST\u2019 and \u2018FTPSERVER_PORT\u2019 from the environment variables if possible.\nThis allows us to run tests in parallel on CI servers.\n[timo]</li>\n</ul>\n</div>\n<div id=\"id31\">\n<h3><a href=\"#id138\" rel=\"nofollow\">4.0.9 (2014-01-28)</a></h3>\n<ul>\n<li>Replace deprecated Zope2VocabularyRegistry import.\n[timo]</li>\n</ul>\n</div>\n<div id=\"id32\">\n<h3><a href=\"#id139\" rel=\"nofollow\">4.0.8 (2013-03-05)</a></h3>\n<ul>\n<li>Factor test request creation out of addRequestContainer into makeTestRequest.\n[davisagli]</li>\n</ul>\n</div>\n<div id=\"id33\">\n<h3><a href=\"#id140\" rel=\"nofollow\">4.0.7 (2012-12-09)</a></h3>\n<ul>\n<li>Fix quoting of urls by the testbrowser.\n[do3cc]</li>\n</ul>\n</div>\n<div id=\"id34\">\n<h3><a href=\"#id141\" rel=\"nofollow\">4.0.6 (2012-10-15)</a></h3>\n<ul>\n<li>Update manifest.in to include content in src directory.\n[esteele]</li>\n</ul>\n</div>\n<div id=\"id35\">\n<h3><a href=\"#id142\" rel=\"nofollow\">4.0.5 (2012-10-15)</a></h3>\n<ul>\n<li>Fixed an issue where a query string would be unquoted twice;\nonce while setting up the HTTP request and once in the handler (the publisher).\n[malthe]</li>\n</ul>\n</div>\n<div id=\"id36\">\n<h3><a href=\"#id143\" rel=\"nofollow\">4.0.4 (2012-08-04)</a></h3>\n<ul>\n<li>Fixed the cache reset code.\nIn some situations the function does not have any defaults,\nso we shouldn\u2019t try to clear out the app reference.\n[malthe]</li>\n</ul>\n</div>\n<div id=\"id37\">\n<h3><a href=\"#id144\" rel=\"nofollow\">4.0.3 (2011-11-24)</a></h3>\n<ul>\n<li>Fixed class names in documentation to match code.\n[icemac]</li>\n</ul>\n</div>\n<div id=\"id38\">\n<h3><a href=\"#id145\" rel=\"nofollow\">4.0.2 (2011-08-31)</a></h3>\n<ul>\n<li>The defaults of the <tt>ZPublisher.Publish.get_module_info</tt> function cache\na reference to the app, so make sure that gets reset when tearing down the\napp. This fixes a problem where the testbrowser in the second functional\nlayer to be set up accessed the database from the first functional layer.\n[davisagli]</li>\n</ul>\n</div>\n<div id=\"id39\">\n<h3><a href=\"#id146\" rel=\"nofollow\">4.0.1 - 2011-05-20</a></h3>\n<ul>\n<li>Moved readme file containing tests into the package, so tests can be run from\nreleased source distributions. Closes <a href=\"http://dev.plone.org/plone/ticket/11821\" rel=\"nofollow\">http://dev.plone.org/plone/ticket/11821</a>.\n[hannosch]</li>\n<li>Relicense under BSD license.\nSee <a href=\"http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy\" rel=\"nofollow\">http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy</a>\n[davisagli]</li>\n</ul>\n</div>\n<div id=\"id40\">\n<h3><a href=\"#id147\" rel=\"nofollow\">4.0 - 2011-05-13</a></h3>\n<ul>\n<li>Release 4.0 Final.\n[esteele]</li>\n<li>Add MANIFEST.in.\n[WouterVH]</li>\n</ul>\n</div>\n<div id=\"a6-2011-04-06\">\n<h3><a href=\"#id148\" rel=\"nofollow\">4.0a6 - 2011-04-06</a></h3>\n<ul>\n<li>Fixed Browser cookies retrieval with Zope 2.13.\n[vincentfretin]</li>\n<li>Add <tt>ZCMLSandbox</tt> layer to load a ZCML file; replaces <tt>setUpZcmlFiles</tt> and\n<tt>tearDownZcmlFiles</tt> helper functions.\n[gotcha]</li>\n</ul>\n</div>\n<div id=\"a5-2011-03-02\">\n<h3><a href=\"#id149\" rel=\"nofollow\">4.0a5 - 2011-03-02</a></h3>\n<ul>\n<li>Handle test failures due to userFolderAddUser returning the user object in\nnewer versions of Zope.\n[esteele]</li>\n<li>Add <tt>setUpZcmlFiles</tt> and <tt>tearDownZcmlFiles</tt> helpers to enable loading\nof ZCML files without too much boilerplate.\n[gotcha]</li>\n<li>Add some logging.\n[gotcha]</li>\n<li>Add the <tt>[security]</tt> extra, to provide tear-down of security checkers.\n[optilude]</li>\n<li>Let the <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt> lifecycle layers\nset up request <tt>PARENTS</tt> and, if present, wire up\n<tt>zope.globalrequest</tt>.\n[optilude]</li>\n<li>Make the test browser support IStreamIterators\n[optilude]</li>\n</ul>\n</div>\n<div id=\"a4-2011-01-11\">\n<h3><a href=\"#id150\" rel=\"nofollow\">4.0a4 - 2011-01-11</a></h3>\n<ul>\n<li>Make sure ZCML doesn\u2019t load during App startup in Zope 2.13.\n[davisagli]</li>\n</ul>\n</div>\n<div id=\"a3-2010-12-14\">\n<h3><a href=\"#id151\" rel=\"nofollow\">4.0a3 - 2010-12-14</a></h3>\n<ul>\n<li>Ignore the <cite>testinghome</cite> configuration setting if present.\n[stefan]</li>\n<li>Use the new API for getting the packages_to_initialize list in Zope 2.13.\n[davisagli]</li>\n<li>De-duplicate _register_monkies and _meta_type_regs in the correct module on\nteardown of the Startup layer in Zope 2.13.\n[davisagli]</li>\n<li>Allow doctest suites from <cite>zope.testing</cite> to work with <cite>plone.testing.layer.layered</cite>.\nPreviously, only doctest suites from the stdlib would see the <cite>layer</cite> global.\n[nouri]</li>\n<li>Changed documentation to advertise the <cite>coverage</cite> library for running\ncoverage tests instead of the built-in <cite>zope.testing</cite> support. This also\navoids using <cite>z3c.coverage</cite>. The coverage tests now run at the same speed\nas a normal test run, making it more likely to get executed frequently.\n[hannosch]</li>\n<li>Correct license to GPL version 2 only.\n[hannosch]</li>\n<li>Fix some user id vs name confusion.\n[rossp]</li>\n<li>Add the option to specify ZServer host and port through environment\nvariables - ZSERVER_HOST and ZSERVER_PORT).\n[esteele]</li>\n</ul>\n</div>\n<div id=\"a2-2010-09-05\">\n<h3><a href=\"#id152\" rel=\"nofollow\">1.0a2 - 2010-09-05</a></h3>\n<ul>\n<li>Fix a problem that would cause <tt>&lt;meta:redefinePermission /&gt;</tt> to break.\nIn particular fixes the use of the <tt>zope2.Public</tt> permission.\n[optilude]</li>\n<li>Set the security implementation to \u201cPython\u201d for easier debugging during\nthe z2.STARTUP layer.\n[optilude]</li>\n<li>Initialize Five in the z2.Startup layer, pushing a Zope2VocabularyRegistry on\nlayer set-up and restoring the previous one upon tear-down.\n[dukebody]</li>\n</ul>\n</div>\n<div id=\"a1-2010-08-01\">\n<h3><a href=\"#id153\" rel=\"nofollow\">1.0a1 - 2010-08-01</a></h3>\n<ul>\n<li>Initial release</li>\n</ul>\n</div>\n</div>\n<div id=\"detailed-documentation\">\n<h2><a href=\"#id154\" rel=\"nofollow\">Detailed documentation</a></h2>\n<div id=\"layer-base-class\">\n<h3><a href=\"#id155\" rel=\"nofollow\">Layer base class</a></h3>\n<p>This package provides a layer base class which can be used by the test runner.\nIt is available as a convenience import from the package root.:</p>\n<pre>&gt;&gt;&gt; from plone.testing import Layer\n</pre>\n<p>A layer may be instantiated directly, though in this case the <tt>name</tt> argument is required (see below).:</p>\n<pre>&gt;&gt;&gt; NULL_LAYER = Layer(name=\"Null layer\")\n</pre>\n<p>This is not very useful on its own.\nIt has an empty list of bases, and each of the layer lifecycle methods does nothing.:</p>\n<pre>&gt;&gt;&gt; NULL_LAYER.__bases__\n()\n&gt;&gt;&gt; NULL_LAYER.__name__\n'Null layer'\n&gt;&gt;&gt; NULL_LAYER.__module__\n'plone.testing.layer'\n\n&gt;&gt;&gt; NULL_LAYER.setUp()\n&gt;&gt;&gt; NULL_LAYER.testSetUp()\n&gt;&gt;&gt; NULL_LAYER.tearDown()\n&gt;&gt;&gt; NULL_LAYER.testTearDown()\n</pre>\n<p>Just about the only reason to use this directly (i.e. not as a base class) is to group together other layers.:</p>\n<pre>&gt;&gt;&gt; SIMPLE_LAYER = Layer(bases=(NULL_LAYER,), name=\"Simple layer\", module='plone.testing.tests')\n</pre>\n<p>Here, we\u2019ve also set the module name directly.\nThe default for all layers is to take the module name from the stack frame where the layer was instantiated.\nIn doctests, that doesn\u2019t work, though, so we fall back on the module name of the layer class.\nThe two are often the same, of course.</p>\n<p>This layer now has the bases, name and module we set::</p>\n<pre>&gt;&gt;&gt; SIMPLE_LAYER.__bases__\n(&lt;Layer 'plone.testing.layer.Null layer'&gt;,)\n\n&gt;&gt;&gt; SIMPLE_LAYER.__name__\n'Simple layer'\n\n&gt;&gt;&gt; SIMPLE_LAYER.__module__\n'plone.testing.tests'\n</pre>\n<p>The <tt>name</tt> argument is required when using <tt>Layer</tt> directly (but not when using a subclass)::</p>\n<pre>&gt;&gt;&gt; Layer((SIMPLE_LAYER,))\nTraceback (most recent call last):\n...\nValueError: The `name` argument is required when instantiating `Layer` directly\n\n&gt;&gt;&gt; class NullLayer(Layer):\n...     pass\n&gt;&gt;&gt; NullLayer()\n&lt;Layer 'builtins.NullLayer'&gt;\n</pre>\n<div id=\"using-layer-as-a-base-class\">\n<h4><a href=\"#id156\" rel=\"nofollow\">Using <tt>Layer</tt> as a base class</a></h4>\n<p>The usual pattern is to use <tt>Layer</tt> as a base class for a custom layer.\nThis can then override the lifecycle methods as appropriate, as well as set a default list of bases.:</p>\n<pre>&gt;&gt;&gt; class BaseLayer(Layer):\n...\n...     def setUp(self):\n...         print(\"Setting up base layer\")\n...\n...     def tearDown(self):\n...         print(\"Tearing down base layer\")\n\n&gt;&gt;&gt; BASE_LAYER = BaseLayer()\n</pre>\n<p>The layer name and module are taken from the class.:</p>\n<pre>&gt;&gt;&gt; BASE_LAYER.__bases__\n()\n&gt;&gt;&gt; BASE_LAYER.__name__\n'BaseLayer'\n&gt;&gt;&gt; BASE_LAYER.__module__\n'builtins'\n</pre>\n<p>We can now create a new layer that has this one as a base.\nWe can do this in the instance constructor, as shown above, but the most common pattern is to set the default bases in the class body, using the variable <tt>defaultBases</tt>.</p>\n<p>We\u2019ll also set the default name explicitly here by passing a name to the the super-constructor.\nThis is mostly cosmetic, but may be desirable if the class name would be misleading in the test runner output.:</p>\n<pre>&gt;&gt;&gt; class ChildLayer(Layer):\n...     defaultBases = (BASE_LAYER,)\n...\n...     def __init__(self, bases=None, name='Child layer', module=None):\n...         super(ChildLayer, self).__init__(bases, name, module)\n...\n...     def setUp(self):\n...         print(\"Setting up child layer\")\n...\n...     def tearDown(self):\n...         print(\"Tearing down child layer\")\n\n&gt;&gt;&gt; CHILD_LAYER = ChildLayer()\n</pre>\n<p>Notice how the bases have now been set using the value in <tt>defaultBases</tt>.:</p>\n<pre>&gt;&gt;&gt; CHILD_LAYER.__bases__\n(&lt;Layer 'builtins.BaseLayer'&gt;,)\n&gt;&gt;&gt; CHILD_LAYER.__name__\n'Child layer'\n&gt;&gt;&gt; CHILD_LAYER.__module__\n'builtins'\n</pre>\n</div>\n<div id=\"overriding-the-default-list-of-bases\">\n<h4><a href=\"#id157\" rel=\"nofollow\">Overriding the default list of bases</a></h4>\n<p>We can override the list of bases on a per-instance basis.\nThis may be dangerous, i.e.\nthe layer is likely to expect that its bases are set up.\nSometimes, it may be useful to inject a new base, however, especially when re-using layers from other packages.</p>\n<p>The new list of bases is passed to the constructor.\nWhen creating a second instance of a layer (most layers are global singletons created only once), it\u2019s useful to give the new instance a unique name, too.:</p>\n<pre>&gt;&gt;&gt; NEW_CHILD_LAYER = ChildLayer(bases=(SIMPLE_LAYER, BASE_LAYER,), name='New child')\n\n&gt;&gt;&gt; NEW_CHILD_LAYER.__bases__\n(&lt;Layer 'plone.testing.tests.Simple layer'&gt;, &lt;Layer 'builtins.BaseLayer'&gt;)\n&gt;&gt;&gt; NEW_CHILD_LAYER.__name__\n'New child'\n&gt;&gt;&gt; NEW_CHILD_LAYER.__module__\n'builtins'\n</pre>\n</div>\n<div id=\"inconsistent-bases\">\n<h4><a href=\"#id158\" rel=\"nofollow\">Inconsistent bases</a></h4>\n<p>Layer bases are maintained in an order that is semantically equivalent to the \u201cmethod resolution order\u201d Python maintains for base classes.\nWe can get this from the <tt>baseResolutionOrder</tt> attribute::</p>\n<pre>&gt;&gt;&gt; CHILD_LAYER.baseResolutionOrder\n(&lt;Layer 'builtins.Child layer'&gt;, &lt;Layer 'builtins.BaseLayer'&gt;)\n\n&gt;&gt;&gt; NEW_CHILD_LAYER.baseResolutionOrder\n(&lt;Layer 'builtins.New child'&gt;, &lt;Layer 'plone.testing.tests.Simple layer'&gt;,\n &lt;Layer 'plone.testing.layer.Null layer'&gt;,\n &lt;Layer 'builtins.BaseLayer'&gt;)\n</pre>\n<p>As with Python classes, it is possible to construct an invalid set of bases.\nIn this case, layer instantiation will fail.:</p>\n<pre>&gt;&gt;&gt; INCONSISTENT_BASE1 = Layer(name=\"Inconsistent 1\")\n&gt;&gt;&gt; INCONSISTENT_BASE2 = Layer((INCONSISTENT_BASE1,), name=\"Inconsistent 1\")\n&gt;&gt;&gt; INCONSISTENT_BASE3 = Layer((INCONSISTENT_BASE1, INCONSISTENT_BASE2,), name=\"Inconsistent 1\")\nTraceback (most recent call last):\n...\nTypeError: Inconsistent layer hierarchy!\n</pre>\n</div>\n<div id=\"using-the-resource-manager\">\n<h4><a href=\"#id159\" rel=\"nofollow\">Using the resource manager</a></h4>\n<p>Layers are also resource managers.\nResources can be set, retrieved and deleted using dictionary syntax.\nResources in base layers are available in child layers.\nWhen an item is set on a child layer, it shadows any items with the same key in any base layer (until it is deleted), but the original item still exists.</p>\n<p>Let\u2019s create a somewhat complex hierarchy of layers that all set resources under a key <tt>'foo'</tt> in their <tt>setUp()</tt> methods.:</p>\n<pre>&gt;&gt;&gt; class Layer1(Layer):\n...     def setUp(self):\n...         self['foo'] = 1\n...     def tearDown(self):\n...         del self['foo']\n&gt;&gt;&gt; LAYER1 = Layer1()\n\n&gt;&gt;&gt; class Layer2(Layer):\n...     defaultBases = (LAYER1,)\n...     def setUp(self):\n...         self['foo'] = 2\n...     def tearDown(self):\n...         del self['foo']\n&gt;&gt;&gt; LAYER2 = Layer2()\n\n&gt;&gt;&gt; class Layer3(Layer):\n...     def setUp(self):\n...         self['foo'] = 3\n...     def tearDown(self):\n...         del self['foo']\n&gt;&gt;&gt; LAYER3 = Layer3()\n\n&gt;&gt;&gt; class Layer4(Layer):\n...     defaultBases = (LAYER2, LAYER3,)\n...     def setUp(self):\n...         self['foo'] = 4\n...     def tearDown(self):\n...         del self['foo']\n&gt;&gt;&gt; LAYER4 = Layer4()\n\n**Important:** Resources that are created in ``setUp()`` must be deleted in ``tearDown()``.\nSimilarly, resources created in ``testSetUp()`` must be deleted in ``testTearDown()``.\nThis ensures resources are properly stacked and do not leak between layers.\n</pre>\n<p>If a test was using <tt>LAYER4</tt>, the test runner would call each setup step in turn, starting with the \u201cdeepest\u201d layer.\nWe\u2019ll simulate that here, so that each of the resources is created.:</p>\n<pre>&gt;&gt;&gt; LAYER1.setUp()\n&gt;&gt;&gt; LAYER2.setUp()\n&gt;&gt;&gt; LAYER3.setUp()\n&gt;&gt;&gt; LAYER4.setUp()\n</pre>\n<p>The layers are ordered in a known \u201cresource resolution order\u201d, which is used to determine in which order the layers shadow one another.\nThis is based on the same algorithm as Python\u2019s method resolution order.:</p>\n<pre>&gt;&gt;&gt; LAYER4.baseResolutionOrder\n(&lt;Layer 'builtins.Layer4'&gt;,\n &lt;Layer 'builtins.Layer2'&gt;,\n &lt;Layer 'builtins.Layer1'&gt;,\n &lt;Layer 'builtins.Layer3'&gt;)\n</pre>\n<p>When fetching and item from a layer, it will be obtained according to the resource resolution order.:</p>\n<pre>&gt;&gt;&gt; LAYER4['foo']\n4\n</pre>\n<p>This is not terribly interesting, since <tt>LAYER4</tt> has the resource <tt>'foo'</tt> set directly.\nLet\u2019s tear down the layer (which deletes the resource) and see what happens.:</p>\n<pre>&gt;&gt;&gt; LAYER4.tearDown()\n&gt;&gt;&gt; LAYER4['foo']\n2\n</pre>\n<p>We can continue up the chain::</p>\n<pre>&gt;&gt;&gt; LAYER2.tearDown()\n&gt;&gt;&gt; LAYER4['foo']\n1\n\n&gt;&gt;&gt; LAYER1.tearDown()\n&gt;&gt;&gt; LAYER4['foo']\n3\n</pre>\n<p>Once we\u2019ve deleted the last key, we\u2019ll get a <tt>KeyError</tt>::</p>\n<pre>&gt;&gt;&gt; LAYER3.tearDown()\n&gt;&gt;&gt; LAYER4['foo']\nTraceback (most recent call last):\n...\nKeyError: 'foo'\n</pre>\n<p>To guard against this, we can use the <tt>get()</tt> method.:</p>\n<pre>&gt;&gt;&gt; LAYER4.get('foo', -1)\n-1\n</pre>\n<p>We can also test with \u2018in\u2019::</p>\n<pre>&gt;&gt;&gt; 'foo' in LAYER4\nFalse\n</pre>\n<p>To illustrate that this indeed works, let\u2019s set the resource back on one of the bases.:</p>\n<pre>&gt;&gt;&gt; LAYER3['foo'] = 10\n&gt;&gt;&gt; LAYER4.get('foo', -1)\n10\n</pre>\n<p>Let\u2019s now consider a special case: a base layer sets up a resource in layer setup, and uses it in test setup.\nA child layer then shadows this resource in its own layer setup method.\nIn this case, we want the base layer\u2019s <tt>testSetUp()</tt> to use the shadowed version that the child provided.</p>\n<p>(This is similar to how instance variables work: a base class may set an attribute on <tt>self</tt> and use it in a method.\nIf a subclass then sets the same attribute to a different value and the base class method is called on an instance of the subclass, the base class attribute is used).</p>\n<blockquote>\n<p><em>Hint:</em> If you definitely need to access the \u201coriginal\u201d resource in your <tt>testSetUp()</tt>/<tt>testTearDown()</tt> methods, you can store a reference to the resource as a layer instance variable:</p>\n<pre>self.someResource = self['someResource'] = SomeResource()\n</pre>\n<p><tt>self.someResource</tt> will now be the exact resource created here, whereas <tt><span class=\"pre\">self['someResource']</span></tt> will retain the layer shadowing semantics.\nIn most cases, you probably <em>don\u2019t</em> want to do this, allowing child layers to supply overridden versions of resources as appropriate.</p>\n</blockquote>\n<p>First, we\u2019ll create some base layers.\nWe want to demonstrate having two \u201cbranches\u201d of bases that both happen to define the same resource.:</p>\n<pre>&gt;&gt;&gt; class ResourceBaseLayer1(Layer):\n...     def setUp(self):\n...         self['resource'] = \"Base 1\"\n...     def testSetUp(self):\n...         print(self['resource'])\n...     def tearDown(self):\n...         del self['resource']\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1 = ResourceBaseLayer1()\n\n&gt;&gt;&gt; class ResourceBaseLayer2(Layer):\n...     defaultBases = (RESOURCE_BASE_LAYER1,)\n...     def testSetUp(self):\n...         print(self['resource'])\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2 = ResourceBaseLayer2()\n\n&gt;&gt;&gt; class ResourceBaseLayer3(Layer):\n...     def setUp(self):\n...         self['resource'] = \"Base 3\"\n...     def testSetUp(self):\n...         print(self['resource'])\n...     def tearDown(self):\n...         del self['resource']\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3 = ResourceBaseLayer3()\n</pre>\n<p>We\u2019ll then create the child layer that overrides this resource.:</p>\n<pre>&gt;&gt;&gt; class ResourceChildLayer(Layer):\n...     defaultBases = (RESOURCE_BASE_LAYER2, RESOURCE_BASE_LAYER3)\n...     def setUp(self):\n...         self['resource'] = \"Child\"\n...     def testSetUp(self):\n...         print(self['resource'])\n...     def tearDown(self):\n...         del self['resource']\n\n&gt;&gt;&gt; RESOURCE_CHILD_LAYER = ResourceChildLayer()\n</pre>\n<p>We\u2019ll first set up the base layers on their own and simulate two tests.</p>\n<p>A test with RESOURCE_BASE_LAYER1 only would look like this::</p>\n<pre>&gt;&gt;&gt; RESOURCE_BASE_LAYER1.setUp()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.testSetUp()\nBase 1\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.testTearDown()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.tearDown()\n</pre>\n<p>A test with RESOURCE_BASE_LAYER2 would look like this::</p>\n<pre>&gt;&gt;&gt; RESOURCE_BASE_LAYER1.setUp()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.setUp()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.testSetUp()\nBase 1\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.testSetUp()\nBase 1\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.testTearDown()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.testTearDown()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.tearDown()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.tearDown()\n</pre>\n<p>A test with RESOURCE_BASE_LAYER3 only would look like this::</p>\n<pre>&gt;&gt;&gt; RESOURCE_BASE_LAYER3.setUp()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3.testSetUp()\nBase 3\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3.testTearDown()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3.tearDown()\n</pre>\n<p>Now let\u2019s set up the child layer and simulate another test.\nWe should now be using the shadowed resource.:</p>\n<pre>&gt;&gt;&gt; RESOURCE_BASE_LAYER1.setUp()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.setUp()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3.setUp()\n&gt;&gt;&gt; RESOURCE_CHILD_LAYER.setUp()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.testSetUp()\nChild\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.testSetUp()\nChild\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3.testSetUp()\nChild\n&gt;&gt;&gt; RESOURCE_CHILD_LAYER.testSetUp()\nChild\n\n&gt;&gt;&gt; RESOURCE_CHILD_LAYER.testTearDown()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3.testTearDown()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.testTearDown()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.testTearDown()\n</pre>\n<p>Finally, we\u2019ll tear down the child layer again and simulate another test.\nwe should have the original resources back.\nNote that the first and third layers no longer share a resource, since they don\u2019t have a common ancestor.:</p>\n<pre>&gt;&gt;&gt; RESOURCE_CHILD_LAYER.tearDown()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.testSetUp()\nBase 1\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.testSetUp()\nBase 1\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.testTearDown()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.testTearDown()\n\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3.testSetUp()\nBase 3\n&gt;&gt;&gt; RESOURCE_BASE_LAYER3.testTearDown()\n</pre>\n<p>Finally, we\u2019ll tear down the remaining layers..:</p>\n<pre>&gt;&gt;&gt; RESOURCE_BASE_LAYER3.tearDown()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER2.tearDown()\n&gt;&gt;&gt; RESOURCE_BASE_LAYER1.tearDown()\n</pre>\n<div id=\"asymmetric-deletion\">\n<h5><a href=\"#id160\" rel=\"nofollow\">Asymmetric deletion</a></h5>\n<p>It is an error to create or shadow a resource in a set-up lifecycle method and not delete it again in the tear-down.\nIt is also an error to delete a resource that was not explicitly created.\nThese two layers break those roles::</p>\n<pre>&gt;&gt;&gt; class BadLayer1(Layer):\n...     def setUp(self):\n...         pass\n...     def tearDown(self):\n...         del self['foo']\n&gt;&gt;&gt; BAD_LAYER1 = BadLayer1()\n\n&gt;&gt;&gt; class BadLayer2(Layer):\n...     defaultBases = (BAD_LAYER1,)\n...     def setUp(self):\n...         self['foo'] = 1\n...         self['bar'] = 2\n&gt;&gt;&gt; BAD_LAYER2 = BadLayer2()\n</pre>\n<p>Let\u2019s simulate a test that uses <tt>BAD_LAYER2</tt>::</p>\n<pre>&gt;&gt;&gt; BAD_LAYER1.setUp()\n&gt;&gt;&gt; BAD_LAYER2.setUp()\n\n&gt;&gt;&gt; BAD_LAYER1.testSetUp()\n&gt;&gt;&gt; BAD_LAYER2.testSetUp()\n\n&gt;&gt;&gt; BAD_LAYER2.testTearDown()\n&gt;&gt;&gt; BAD_LAYER1.testTearDown()\n\n&gt;&gt;&gt; BAD_LAYER2.tearDown()\n&gt;&gt;&gt; BAD_LAYER1.tearDown()\nTraceback (most recent call last):\n...\nKeyError: 'foo'\n</pre>\n<p>Here, we\u2019ve got an error in the base layer.\nThis is because the resource is actually associated with the layer that first created it, in this case <tt>BASE_LAYER2</tt>.\nThis one remains intact and orphaned::</p>\n<pre>&gt;&gt;&gt; 'foo' in BAD_LAYER2._resources\nTrue\n&gt;&gt;&gt; 'bar' in BAD_LAYER2._resources\nTrue\n</pre>\n</div>\n</div>\n<div id=\"doctest-layer-helper\">\n<h4><a href=\"#id161\" rel=\"nofollow\">Doctest layer helper</a></h4>\n<p>The <tt>doctest</tt> module is not aware of <tt>zope.testing</tt>\u2019s layers concept.\nTherefore, the syntax for creating a doctest with a layer and adding it to a test suite is somewhat contrived: the test suite has to be created first, and then the layer attribute set on it::</p>\n<pre>&gt;&gt;&gt; class DoctestLayer(Layer):\n...     pass\n&gt;&gt;&gt; DOCTEST_LAYER = DoctestLayer()\n\n&gt;&gt;&gt; import unittest\n&gt;&gt;&gt; import doctest\n\n&gt;&gt;&gt; def test_suite():\n...     suite = unittest.TestSuite()\n...     layerDoctest = doctest.DocFileSuite('layer.rst', package='plone.testing')\n...     layerDoctest.layer = DOCTEST_LAYER\n...     suite.addTest(layerDoctest)\n...     return suite\n\n&gt;&gt;&gt; suite = test_suite()\n&gt;&gt;&gt; tests = list(suite)\n&gt;&gt;&gt; len(tests)\n1\n&gt;&gt;&gt; tests[0].layer is DOCTEST_LAYER\nTrue\n</pre>\n<p>To make this a little easier - especially when setting up multiple tests - a helper function called <tt>layered</tt> is provided::</p>\n<pre>&gt;&gt;&gt; from plone.testing import layered\n\n&gt;&gt;&gt; def test_suite():\n...     suite = unittest.TestSuite()\n...     suite.addTests([\n...         layered(doctest.DocFileSuite('layer.rst', package='plone.testing'), layer=DOCTEST_LAYER),\n...         # repeat with more suites if necessary\n...     ])\n...     return suite\n</pre>\n<p>This does the same as the sample above.:</p>\n<pre>&gt;&gt;&gt; suite = test_suite()\n&gt;&gt;&gt; tests = list(suite)\n&gt;&gt;&gt; len(tests)\n1\n&gt;&gt;&gt; tests[0].layer is DOCTEST_LAYER\nTrue\n</pre>\n<p>In addition, a \u2018layer\u2019 glob is added to each test in the suite.\nThis allows the test to access layer resources.:</p>\n<pre>&gt;&gt;&gt; len(list(tests[0]))\n1\n&gt;&gt;&gt; list(tests[0])[0]._dt_test.globs['layer'] is DOCTEST_LAYER\nTrue\n</pre>\n</div>\n</div>\n<div id=\"zope-component-architecture-layers\">\n<h3><a href=\"#id162\" rel=\"nofollow\">Zope Component Architecture layers</a></h3>\n<p>The ZCA layers are found in the module <tt>plone.testing.zca</tt>::</p>\n<pre>&gt;&gt;&gt; from plone.testing import zca\n</pre>\n<p>For testing, we need a testrunner::</p>\n<pre>&gt;&gt;&gt; from zope.testrunner import runner\n</pre>\n<div id=\"id41\">\n<h4><a href=\"#id163\" rel=\"nofollow\">Unit testing</a></h4>\n<p>The <tt>UNIT_TESTING</tt> layer is used to set up a clean component registry between each test.\nIt uses <tt>zope.testing.cleanup</tt> to clean up all global state.</p>\n<p>It has no bases::</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zca.UNIT_TESTING.__module__, zca.UNIT_TESTING.__name__,)\n'plone.testing.zca.UnitTesting'\n\n&gt;&gt;&gt; zca.UNIT_TESTING.__bases__\n()\n</pre>\n<p>The component registry is cleaned up between each test.:</p>\n<pre>&gt;&gt;&gt; from zope.interface import Interface\n&gt;&gt;&gt; from zope.component import provideUtility\n\n&gt;&gt;&gt; class DummyUtility(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __repr__(self):\n...         return \"&lt;%s&gt;\" % self.name\n\n&gt;&gt;&gt; provideUtility(DummyUtility(\"Dummy\"), provides=Interface, name=\"test-dummy\")\n\n&gt;&gt;&gt; from zope.component import queryUtility\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\")\n&lt;Dummy&gt;\n</pre>\n<p>Layer setup does nothing.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zca.UNIT_TESTING, setupLayers)\nSet up plone.testing.zca.UnitTesting in ... seconds.\n</pre>\n<p>Let\u2019s now simulate a test.\nBefore any test setup has happened, our previously registered utility is still there.:</p>\n<pre>&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\")\n&lt;Dummy&gt;\n</pre>\n<p>On test setup, it disappears.:</p>\n<pre>&gt;&gt;&gt; zca.UNIT_TESTING.testSetUp()\n\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\") is None\nTrue\n</pre>\n<p>The test would now execute. It may register some components.:</p>\n<pre>&gt;&gt;&gt; provideUtility(DummyUtility(\"Dummy2\"), provides=Interface, name=\"test-dummy\")\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\")\n&lt;Dummy2&gt;\n</pre>\n<p>On test tear-down, this disappears.:</p>\n<pre>&gt;&gt;&gt; zca.UNIT_TESTING.testTearDown()\n\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\") is None\nTrue\n</pre>\n<p>Layer tear-down does nothing.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zca.UnitTesting in ... seconds.\n</pre>\n</div>\n<div id=\"id42\">\n<h4><a href=\"#id164\" rel=\"nofollow\">Event testing</a></h4>\n<p>The <tt>EVENT_TESTING</tt> layer extends the <tt>UNIT_TESTING</tt> layer to add the necessary registrations for <tt>zope.component.eventtesting</tt> to work.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zca.EVENT_TESTING.__module__, zca.EVENT_TESTING.__name__,)\n'plone.testing.zca.EventTesting'\n\n&gt;&gt;&gt; zca.EVENT_TESTING.__bases__\n(&lt;Layer 'plone.testing.zca.UnitTesting'&gt;,)\n</pre>\n<p>Before the test, the component registry is empty and <tt>getEvents()</tt> returns nothing, even if an event is fired.:</p>\n<pre>&gt;&gt;&gt; from zope.component.eventtesting import getEvents\n\n&gt;&gt;&gt; class DummyEvent(object):\n...     def __repr__(self):\n...         return \"&lt;Dummy event&gt;\"\n\n&gt;&gt;&gt; from zope.event import notify\n&gt;&gt;&gt; notify(DummyEvent())\n\n&gt;&gt;&gt; getEvents()\n[]\n</pre>\n<p>Layer setup does nothing.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zca.EVENT_TESTING, setupLayers)\nSet up plone.testing.zca.UnitTesting in ... seconds.\nSet up plone.testing.zca.EventTesting in ... seconds.\n</pre>\n<p>Let\u2019s now simulate a test. On test setup, the event testing list is emptied.:</p>\n<pre>&gt;&gt;&gt; zca.UNIT_TESTING.testSetUp()\n&gt;&gt;&gt; zca.EVENT_TESTING.testSetUp()\n\n&gt;&gt;&gt; getEvents()\n[]\n</pre>\n<p>The test would now execute.\nIt may fire some events, which would show up in the event testing list.:</p>\n<pre>&gt;&gt;&gt; notify(DummyEvent())\n&gt;&gt;&gt; getEvents()\n[&lt;Dummy event&gt;]\n</pre>\n<p>On test tear-down, the list is emptied again::</p>\n<pre>&gt;&gt;&gt; zca.EVENT_TESTING.testTearDown()\n&gt;&gt;&gt; zca.UNIT_TESTING.testTearDown()\n\n&gt;&gt;&gt; getEvents()\n[]\n</pre>\n<p>Layer tear-down does nothing.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zca.EventTesting in ... seconds.\nTear down plone.testing.zca.UnitTesting in ... seconds.\n</pre>\n</div>\n<div id=\"id43\">\n<h4><a href=\"#id165\" rel=\"nofollow\">Layer cleanup</a></h4>\n<p>The <tt>LAYER_CLEANUP</tt> layer is used to set up a clean component registry at the set-up and tear-down of a layer.\nIt uses <tt>zope.testing.cleanup</tt> to clean up all global state.</p>\n<p>It has no bases::</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zca.LAYER_CLEANUP.__module__, zca.LAYER_CLEANUP.__name__,)\n'plone.testing.zca.LayerCleanup'\n\n&gt;&gt;&gt; zca.LAYER_CLEANUP.__bases__\n()\n</pre>\n<p>The component registry is cleaned up on layer set-up and tear-down (but not between tests).:</p>\n<pre>&gt;&gt;&gt; from zope.interface import Interface\n&gt;&gt;&gt; from zope.component import provideUtility\n\n&gt;&gt;&gt; class DummyUtility(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __repr__(self):\n...         return \"&lt;%s&gt;\" % self.name\n\n&gt;&gt;&gt; provideUtility(DummyUtility(\"Dummy\"), provides=Interface, name=\"test-dummy\")\n\n&gt;&gt;&gt; from zope.component import queryUtility\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\")\n&lt;Dummy&gt;\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zca.LAYER_CLEANUP, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\n\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\") is None\nTrue\n</pre>\n<p>A sub-layer may register additional components::</p>\n<pre>&gt;&gt;&gt; provideUtility(DummyUtility(\"Dummy2\"), provides=Interface, name=\"test-dummy2\")\n</pre>\n<p>Let\u2019s now simulate a test. Test setup and tear-down does nothing.:</p>\n<pre>&gt;&gt;&gt; zca.LAYER_CLEANUP.testSetUp()\n\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\") is None\nTrue\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy2\")\n&lt;Dummy2&gt;\n\n&gt;&gt;&gt; zca.LAYER_CLEANUP.testTearDown()\n\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\") is None\nTrue\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy2\")\n&lt;Dummy2&gt;\n</pre>\n<p>On tear-down, the registry is cleaned again.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\") is None\nTrue\n&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy2\") is None\nTrue\n</pre>\n</div>\n<div id=\"id44\">\n<h4><a href=\"#id166\" rel=\"nofollow\">Basic ZCML directives</a></h4>\n<p>The <tt>ZCML_DIRECTIVES</tt> layer creates a ZCML configuration context with the basic <tt>zope.component</tt> directives available.\nIt extends the <tt>LAYER_CLEANUP</tt> layer.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zca.ZCML_DIRECTIVES.__module__, zca.ZCML_DIRECTIVES.__name__,)\n'plone.testing.zca.ZCMLDirectives'\n\n&gt;&gt;&gt; zca.ZCML_DIRECTIVES.__bases__\n(&lt;Layer 'plone.testing.zca.LayerCleanup'&gt;,)\n</pre>\n<p>Before the test, we cannot use e.g. a <tt>&lt;utility /&gt;</tt> directive without loading the necessary <tt>meta.zcml</tt> files.:</p>\n<pre>&gt;&gt;&gt; from zope.configuration import xmlconfig\n&gt;&gt;&gt; from zope.configuration.exceptions import ConfigurationError\n&gt;&gt;&gt; try:\n...     xmlconfig.string(\"\"\"\\\n...     &lt;configure package=\"plone.testing\" xmlns=\"http://namespaces.zope.org/zope\"&gt;\n...         &lt;utility factory=\".tests.DummyUtility\" provides=\"zope.interface.Interface\" name=\"test-dummy\" /&gt;\n...     &lt;/configure&gt;\"\"\")\n... except ConfigurationError as e:\n...     True\nTrue\n</pre>\n<p>Layer setup creates a configuration context we can use to load further configuration.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zca.ZCML_DIRECTIVES, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zca.ZCMLDirectives in ... seconds.\n</pre>\n<p>Let\u2019s now simulate a test that uses this configuration context to load the same ZCML string.:</p>\n<pre>&gt;&gt;&gt; zca.ZCML_DIRECTIVES.testSetUp()\n\n&gt;&gt;&gt; context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']\n&gt;&gt;&gt; xmlconfig.string(\"\"\"\\\n... &lt;configure package=\"plone.testing\" xmlns=\"http://namespaces.zope.org/zope\"&gt;\n...     &lt;utility factory=\".tests.DummyUtility\" provides=\"zope.interface.Interface\" name=\"test-dummy\" /&gt;\n... &lt;/configure&gt;\"\"\", context=context) is context\nTrue\n</pre>\n<p>The utility is now registered::</p>\n<pre>&gt;&gt;&gt; queryUtility(Interface, name=\"test-dummy\")\n&lt;Dummy utility&gt;\n\n&gt;&gt;&gt; zca.UNIT_TESTING.testTearDown()\n</pre>\n<p>Note that normally, we\u2019d combine this with the <tt>UNIT_TESTING</tt> layer to tear down the component architecture as well.</p>\n<p>Layer tear-down deletes the configuration context.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zca.ZCMLDirectives in ... seconds.\n\n&gt;&gt;&gt; zca.ZCML_DIRECTIVES.get('configurationContext', None) is None\nTrue\n</pre>\n</div>\n<div id=\"configuration-registry-sandboxing\">\n<h4><a href=\"#id167\" rel=\"nofollow\">Configuration registry sandboxing</a></h4>\n<p>For simple unit tests, the full cleanup performed between each test using the <tt>UNIT_TESTING</tt> layer is undoubtedly the safest and most convenient way to ensure proper isolation of tests using the global component architecture.\nHowever, if you are writing a complex layer that sets up a lot of components, you may wish to keep some components registered at the layer level, whilst still allowing tests and sub-layers to register their own components in isolation.</p>\n<p>This is a tricky problem, because the default ZCML directives and APIs (<tt>provideAdapter()</tt>, <tt>provideUtility()</tt> and so on) explicitly work on a single global adapter registry object.\nTo get around this, you can use two helper methods in the <tt>zca</tt> module to push a new global component registry before registering components, and pop the registry after.\nRegistries are stacked, so the components registered in a \u201clower\u201d registry are automatically available in a \u201chigher\u201d registry.</p>\n<p>Let\u2019s illustrate this with a layer that stacks two new global registries.\nThe first registry is specific to the layer, and is used to house the components registered at the layer level.\nThe second registry is set up and torn down for each test, allowing tests to register their own components freely.</p>\n<p>First, we\u2019ll create a simple dummy utility to illustrate registrations.:</p>\n<pre>&gt;&gt;&gt; from zope.interface import Interface, implementer\n\n&gt;&gt;&gt; class IDummyUtility(Interface):\n...     pass\n&gt;&gt;&gt; @implementer(IDummyUtility)\n... class DummyUtility(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __repr__(self):\n...         return \"&lt;DummyUtility %s&gt;\" % self.name\n</pre>\n<p>The two key methods are:</p>\n<ul>\n<li><p><tt>zca.pushGlobalRegistry()</tt>, which creates a new global registry.</p>\n</li>\n<li><p><tt>zca.popGlobalRegistry()</tt>, which restores the previous global registry.</p>\n<p><strong>Warning:</strong> You <em>must</em> balance your calls to these methods.\nIf you call <tt>pushGlobalRegistry()</tt> in <tt>setUp()</tt>, call <tt>popGlobalRegistry()</tt> in <tt>tearDown()</tt>.\nDitto for <tt>testSetUp()</tt> and <tt>testTearDown()</tt>.</p>\n</li>\n</ul>\n<p>Let\u2019s now create our layer.:</p>\n<pre>&gt;&gt;&gt; from zope.component import provideUtility\n&gt;&gt;&gt; from plone.testing import Layer\n&gt;&gt;&gt; from plone.testing import zca\n\n&gt;&gt;&gt; class ComponentSandbox(Layer):\n...     def setUp(self):\n...         zca.pushGlobalRegistry()\n...         provideUtility(DummyUtility(\"layer\"), name=\"layer\")\n...     def tearDown(self):\n...         zca.popGlobalRegistry()\n...     def testSetUp(self):\n...         zca.pushGlobalRegistry()\n...     def testTearDown(self):\n...         zca.popGlobalRegistry()\n&gt;&gt;&gt; COMPONENT_SANDBOX = ComponentSandbox()\n</pre>\n<p>Let\u2019s now simulate a test using this layer.</p>\n<p>To begin with, we have the default registry.:</p>\n<pre>&gt;&gt;&gt; from zope.component import getGlobalSiteManager, getSiteManager\n&gt;&gt;&gt; getSiteManager() is getGlobalSiteManager()\nTrue\n\n&gt;&gt;&gt; defaultGlobalSiteManager = getGlobalSiteManager()\n\n&gt;&gt;&gt; from zope.component import queryUtility\n&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"layer\") is None\nTrue\n</pre>\n<p>We\u2019ll now simulate layer setup. This will push a new registry onto the stack::</p>\n<pre>&gt;&gt;&gt; COMPONENT_SANDBOX.setUp()\n\n&gt;&gt;&gt; getSiteManager() is getGlobalSiteManager()\nTrue\n&gt;&gt;&gt; getGlobalSiteManager() is defaultGlobalSiteManager\nFalse\n&gt;&gt;&gt; layerGlobalSiteManager = getGlobalSiteManager()\n\n&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"layer\")\n&lt;DummyUtility layer&gt;\n</pre>\n<p>We\u2019ll then simulate a test that registers a global component::</p>\n<pre>&gt;&gt;&gt; COMPONENT_SANDBOX.testSetUp()\n\n&gt;&gt;&gt; getSiteManager() is getGlobalSiteManager()\nTrue\n&gt;&gt;&gt; getGlobalSiteManager() is defaultGlobalSiteManager\nFalse\n&gt;&gt;&gt; getGlobalSiteManager() is layerGlobalSiteManager\nFalse\n</pre>\n<p>Our previously registered component is still here.:</p>\n<pre>&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"layer\")\n&lt;DummyUtility layer&gt;\n</pre>\n<p>We can also register a new one.:</p>\n<pre>&gt;&gt;&gt; provideUtility(DummyUtility(\"test\"), name=\"test\")\n&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"layer\")\n&lt;DummyUtility layer&gt;\n&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"test\")\n&lt;DummyUtility test&gt;\n</pre>\n<p>On test tear-down, only the second utility disappears::</p>\n<pre>&gt;&gt;&gt; COMPONENT_SANDBOX.testTearDown()\n\n&gt;&gt;&gt; getSiteManager() is getGlobalSiteManager()\nTrue\n&gt;&gt;&gt; getGlobalSiteManager() is defaultGlobalSiteManager\nFalse\n&gt;&gt;&gt; getGlobalSiteManager() is layerGlobalSiteManager\nTrue\n\n&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"layer\")\n&lt;DummyUtility layer&gt;\n&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"test\") is None\nTrue\n</pre>\n<p>If we tear down the layer too, we\u2019re back where we started::</p>\n<pre>&gt;&gt;&gt; COMPONENT_SANDBOX.tearDown()\n\n&gt;&gt;&gt; getSiteManager() is getGlobalSiteManager()\nTrue\n&gt;&gt;&gt; getGlobalSiteManager() is defaultGlobalSiteManager\nTrue\n\n&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"layer\") is None\nTrue\n&gt;&gt;&gt; queryUtility(IDummyUtility, name=\"test\") is None\nTrue\n</pre>\n</div>\n<div id=\"id45\">\n<h4><a href=\"#id168\" rel=\"nofollow\">ZCML files helper class</a></h4>\n<p>One of the frequent use cases is a layer that loads a ZCML file and sandbox the resulting registry.</p>\n<p>The <tt>ZCMLSandbox</tt> can be instantiated with a <cite>filename`</cite> and <tt>package</tt> arguments.:</p>\n<pre>&gt;&gt;&gt; import plone.testing\n&gt;&gt;&gt; ZCML_SANDBOX = zca.ZCMLSandbox(filename=\"testing_zca.zcml\",\n...     package=plone.testing)\n</pre>\n<p>Before layer setup, the utility is not registered.:</p>\n<pre>&gt;&gt;&gt; queryUtility(Interface, name=\"layer\") is None\nTrue\n</pre>\n<p>We\u2019ll now simulate layer setup.\nThis pushes a new registry onto the stack::</p>\n<pre>&gt;&gt;&gt; ZCML_SANDBOX.setUp()\n\n&gt;&gt;&gt; getSiteManager() is getGlobalSiteManager()\nTrue\n&gt;&gt;&gt; getGlobalSiteManager() is defaultGlobalSiteManager\nFalse\n&gt;&gt;&gt; queryUtility(Interface, name=\"layer\")\n&lt;Dummy utility&gt;\n</pre>\n<p>The <tt>ZCMLSandbox</tt> class can also be used as ancestor for your own classes when you need to load more than a single ZCML file.</p>\n<p>Your class then needs to override the <tt>setUpZCMLFiles()</tt> method.\nIt is in charge of calling <tt>loadZCMLFile()</tt>, once for each ZCML file that the class needs to load.:</p>\n<pre>&gt;&gt;&gt; class OtherZCML(zca.ZCMLSandbox):\n...     def setUpZCMLFiles(self):\n...         self.loadZCMLFile(\"testing_zca.zcml\", package=plone.testing)\n...         self.loadZCMLFile(\"testing_zca_more_specific.zcml\",\n...             package=plone.testing)\n&gt;&gt;&gt; OTHER_ZCML_SANDBOX = OtherZCML()\n</pre>\n<p>Before layer setup, a second utility is not registered.:</p>\n<pre>&gt;&gt;&gt; queryUtility(Interface, name=\"more_specific_layer\") is None\nTrue\n</pre>\n<p>We\u2019ll now simulate the setup of the more specific layer.:</p>\n<pre>&gt;&gt;&gt; OTHER_ZCML_SANDBOX.setUp()\n</pre>\n<p>After setUp, the second utility is registered::</p>\n<pre>&gt;&gt;&gt; queryUtility(Interface, name=\"more_specific_layer\")\n&lt;Dummy utility&gt;\n</pre>\n<p>After layer teardown, the second utility is not registered anymore.:</p>\n<pre>&gt;&gt;&gt; OTHER_ZCML_SANDBOX.tearDown()\n&gt;&gt;&gt; queryUtility(Interface, name=\"more_specific_layer\") is None\nTrue\n</pre>\n<p>After teardown of the first layer, the first utility is not registered anymore.:</p>\n<pre>&gt;&gt;&gt; ZCML_SANDBOX.tearDown()\n&gt;&gt;&gt; queryUtility(Interface, name=\"layer\") is None\nTrue\n</pre>\n</div>\n</div>\n<div id=\"security\">\n<h3><a href=\"#id169\" rel=\"nofollow\">Security</a></h3>\n<p>The Zope Security layers are found in the module <tt>plone.testing.security</tt>::</p>\n<pre>&gt;&gt;&gt; from plone.testing import security\n</pre>\n<p>For testing, we need a testrunner::</p>\n<pre>&gt;&gt;&gt; from zope.testrunner import runner\n</pre>\n<div id=\"id46\">\n<h4><a href=\"#id170\" rel=\"nofollow\">Layers</a></h4>\n<p>The <tt>security.CHECKERS</tt> layer makes sure that <tt>zope.security</tt> checkers are correctly set up and torn down.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (security.CHECKERS.__module__, security.CHECKERS.__name__,)\n'plone.testing.security.Checkers'\n\n&gt;&gt;&gt; security.CHECKERS.__bases__\n()\n</pre>\n<p>Before the test, our custom checker is not in the registry.:</p>\n<pre>&gt;&gt;&gt; class DummyObject(object):\n...     pass\n\n&gt;&gt;&gt; from zope.security.interfaces import IChecker\n&gt;&gt;&gt; from zope.interface import implementer\n&gt;&gt;&gt; @implementer(IChecker)\n... class FauxChecker(object):\n...     # we should really implement the interface here, but oh well\n...     pass\n\n&gt;&gt;&gt; from zope.security.checker import getCheckerForInstancesOf\n&gt;&gt;&gt; getCheckerForInstancesOf(DummyObject) is None\nTrue\n</pre>\n<p>Layer setup stacks the current checkers.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, security.CHECKERS, setupLayers)\nSet up plone.testing.security.Checkers in ... seconds.\n</pre>\n<p>We can now set up a checker.\nIn real life, this may happen during ZCML configuration, but here will just call the API directlyMost likely, we\u2019d do this in a child layer::</p>\n<pre>&gt;&gt;&gt; from zope.security.checker import defineChecker\n&gt;&gt;&gt; fauxChecker = FauxChecker()\n&gt;&gt;&gt; defineChecker(DummyObject, fauxChecker)\n\n&gt;&gt;&gt; getCheckerForInstancesOf(DummyObject) is fauxChecker\nTrue\n</pre>\n<p>Let\u2019s now simulate a test that may use the checker.:</p>\n<pre>&gt;&gt;&gt; security.CHECKERS.testSetUp()\n&gt;&gt;&gt; getCheckerForInstancesOf(DummyObject) is fauxChecker\nTrue\n&gt;&gt;&gt; security.CHECKERS.testTearDown()\n</pre>\n<p>We still have the checker after test tear-down::</p>\n<pre>&gt;&gt;&gt; getCheckerForInstancesOf(DummyObject) is fauxChecker\nTrue\n</pre>\n<p>However, when we tear down the layer, the checker is gone::</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.security.Checkers in ... seconds.\n\n&gt;&gt;&gt; getCheckerForInstancesOf(DummyObject) is None\nTrue\n</pre>\n</div>\n</div>\n<div id=\"zope-publisher-layers\">\n<h3><a href=\"#id171\" rel=\"nofollow\">Zope Publisher layers</a></h3>\n<p>The Zope Publisher layers are found in the module <tt>plone.testing.publisher</tt>:</p>\n<pre>&gt;&gt;&gt; from plone.testing import publisher\n</pre>\n<p>For testing, we need a testrunner::</p>\n<pre>&gt;&gt;&gt; from zope.testrunner import runner\n</pre>\n<div id=\"zcml-directives\">\n<h4><a href=\"#id172\" rel=\"nofollow\">ZCML directives</a></h4>\n<p>The <tt>publisher.PUBLISHER_DIRECTIVES</tt> layer extends the <tt>zca.ZCML_DIRECTIVES</tt> layer to extend its ZCML configuration context with the <tt>zope.app.publisher</tt> and <tt>zope.security</tt> directives available.\nIt also extends <tt>security.CHECKERS</tt>.:</p>\n<pre>&gt;&gt;&gt; from plone.testing import zca, security\n\n&gt;&gt;&gt; \"%s.%s\" % (publisher.PUBLISHER_DIRECTIVES.__module__, publisher.PUBLISHER_DIRECTIVES.__name__,)\n'plone.testing.publisher.PublisherDirectives'\n\n&gt;&gt;&gt; publisher.PUBLISHER_DIRECTIVES.__bases__\n(&lt;Layer 'plone.testing.zca.ZCMLDirectives'&gt;, &lt;Layer 'plone.testing.security.Checkers'&gt;)\n</pre>\n<p>Before the test, we cannot use e.g.\nthe <tt>&lt;permission /&gt;</tt> or <tt>&lt;browser:view /&gt;</tt> directives without loading the necessary <tt>meta.zcml</tt> files.:</p>\n<pre>&gt;&gt;&gt; from zope.configuration import xmlconfig\n&gt;&gt;&gt; from zope.configuration.exceptions import ConfigurationError\n&gt;&gt;&gt; try:\n...     xmlconfig.string(\"\"\"\\\n...     &lt;configure package=\"plone.testing\"\n...         xmlns=\"http://namespaces.zope.org/zope\"\n...         xmlns:browser=\"http://namespaces.zope.org/browser\"\n...         i18n_domain=\"plone.testing.tests\"&gt;\n...         &lt;permission id=\"plone.testing.Test\" title=\"plone.testing: Test\" /&gt;\n...         &lt;browser:view\n...             for=\"*\"\n...             name=\"plone.testing-test\"\n...             class=\"plone.testing.tests.DummyView\"\n...             permission=\"zope.Public\"\n...             /&gt;\n...     &lt;/configure&gt;\"\"\")\n... except ConfigurationError as e:\n...     True\nTrue\n</pre>\n<p>Layer setup creates a configuration context we can use to load further configuration.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, publisher.PUBLISHER_DIRECTIVES, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zca.ZCMLDirectives in ... seconds.\nSet up plone.testing.security.Checkers in ... seconds.\nSet up plone.testing.publisher.PublisherDirectives in ... seconds.\n</pre>\n<p>Let\u2019s now simulate a test that uses this configuration context to load the same ZCML string.:</p>\n<pre>&gt;&gt;&gt; zca.ZCML_DIRECTIVES.testSetUp()\n&gt;&gt;&gt; security.CHECKERS.testSetUp()\n&gt;&gt;&gt; publisher.PUBLISHER_DIRECTIVES.testSetUp()\n\n&gt;&gt;&gt; context = zca.ZCML_DIRECTIVES['configurationContext'] # would normally be self.layer['configurationContext']\n&gt;&gt;&gt; xmlconfig.string(\"\"\"\\\n... &lt;configure package=\"plone.testing\"\n...     xmlns=\"http://namespaces.zope.org/zope\"\n...     xmlns:browser=\"http://namespaces.zope.org/browser\"\n...     i18n_domain=\"plone.testing.tests\"&gt;\n...     &lt;permission id=\"plone.testing.Test\" title=\"plone.testing: Test\" /&gt;\n...     &lt;browser:view\n...         for=\"*\"\n...         name=\"plone.testing-test\"\n...         class=\"plone.testing.tests.DummyView\"\n...         permission=\"zope.Public\"\n...         /&gt;\n... &lt;/configure&gt;\"\"\", context=context) is context\nTrue\n</pre>\n<p>The permission and view are now registered::</p>\n<pre>&gt;&gt;&gt; from zope.component import queryUtility\n&gt;&gt;&gt; from zope.security.interfaces import IPermission\n\n&gt;&gt;&gt; queryUtility(IPermission, name=u\"plone.testing.Test\")\n&lt;zope.security.permission.Permission object at ...&gt;\n\n&gt;&gt;&gt; from zope.interface import Interface\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n&gt;&gt;&gt; from zope.component import getSiteManager\n&gt;&gt;&gt; siteManager = getSiteManager()\n\n&gt;&gt;&gt; [x.factory for x in siteManager.registeredAdapters()\n...  if x.provided==Interface and x.required==(Interface, IDefaultBrowserLayer)\n...   and x.name==u\"plone.testing-test\"]\n[&lt;class '....plone.testing-test'&gt;]\n</pre>\n<p>We can then simulate test tear-down::</p>\n<pre>&gt;&gt;&gt; publisher.PUBLISHER_DIRECTIVES.testTearDown()\n&gt;&gt;&gt; security.CHECKERS.testTearDown()\n&gt;&gt;&gt; zca.ZCML_DIRECTIVES.testTearDown()\n</pre>\n<p>Note that you\u2019d normally combine this layer with the <tt>zca.UNIT_TESTING</tt> or a similar layer to automatically tear down the component architecture between each test.\nHere, we need to do it manually.:</p>\n<pre>&gt;&gt;&gt; from zope.component.testing import tearDown\n&gt;&gt;&gt; tearDown()\n</pre>\n<p>Layer tear-down does nothing.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.publisher.PublisherDirectives in ... seconds.\nTear down plone.testing.zca.ZCMLDirectives in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\nTear down plone.testing.security.Checkers in ... seconds.\n\n&gt;&gt;&gt; zca.ZCML_DIRECTIVES.get('configurationContext', None) is None\nTrue\n</pre>\n</div>\n</div>\n<div id=\"zope-object-database-layers\">\n<h3><a href=\"#id173\" rel=\"nofollow\">Zope Object Database layers</a></h3>\n<p>The ZODB layers are found in the module <tt>plone.testing.zodb</tt>::</p>\n<pre>&gt;&gt;&gt; from plone.testing import zodb\n</pre>\n<p>For testing, we need a testrunner::</p>\n<pre>&gt;&gt;&gt; from zope.testrunner import runner\n</pre>\n<div id=\"empty-zodb-layer\">\n<h4><a href=\"#id174\" rel=\"nofollow\">Empty ZODB layer</a></h4>\n<p>The <tt>EMPTY_ZODB</tt> layer is used to set up an empty ZODB using <tt>DemoStorage</tt>.</p>\n<p>The storage and database are set up as layer fixtures.\nThe database is exposed as the resource <tt>zodbDB</tt>.</p>\n<p>A connection is opened for each test and exposed as <tt>zodbConnection</tt>.\nThe ZODB root is also exposed, as <tt>zodbRoot</tt>.\nA new transaction is begun for each test.\nOn test tear-down, the transaction is aborted, the connection is closed, and the two test-specific resources are deleted.</p>\n<p>The layer has no bases.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zodb.EMPTY_ZODB.__module__, zodb.EMPTY_ZODB.__name__,)\n'plone.testing.zodb.EmptyZODB'\n\n&gt;&gt;&gt; zodb.EMPTY_ZODB.__bases__\n()\n</pre>\n<p>Layer setup creates the database, but not a connection.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zodb.EMPTY_ZODB, setupLayers)\nSet up plone.testing.zodb.EmptyZODB in ... seconds.\n\n&gt;&gt;&gt; db = zodb.EMPTY_ZODB['zodbDB']\n&gt;&gt;&gt; db.storage\nEmptyZODB\n\n&gt;&gt;&gt; zodb.EMPTY_ZODB.get('zodbConnection', None) is None\nTrue\n&gt;&gt;&gt; zodb.EMPTY_ZODB.get('zodbRoot', None) is None\nTrue\n</pre>\n<p>Let\u2019s now simulate a test.:</p>\n<pre>&gt;&gt;&gt; zodb.EMPTY_ZODB.testSetUp()\n</pre>\n<p>The test would then execute. It may use the ZODB root.:</p>\n<pre>&gt;&gt;&gt; zodb.EMPTY_ZODB['zodbConnection']\n&lt;Connection at ...&gt;\n\n&gt;&gt;&gt; zodb.EMPTY_ZODB['zodbRoot']\n{}\n\n&gt;&gt;&gt; zodb.EMPTY_ZODB['zodbRoot']['foo'] = 'bar'\n</pre>\n<p>On test tear-down, the transaction is aborted and the connection is closed.:</p>\n<pre>&gt;&gt;&gt; zodb.EMPTY_ZODB.testTearDown()\n\n&gt;&gt;&gt; zodb.EMPTY_ZODB.get('zodbConnection', None) is None\nTrue\n\n&gt;&gt;&gt; zodb.EMPTY_ZODB.get('zodbRoot', None) is None\nTrue\n</pre>\n<p>The transaction has been rolled back.:</p>\n<pre>&gt;&gt;&gt; conn = zodb.EMPTY_ZODB['zodbDB'].open()\n&gt;&gt;&gt; conn.root()\n{}\n&gt;&gt;&gt; conn.close()\n</pre>\n<p>Layer tear-down closes and deletes the database.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zodb.EmptyZODB in ... seconds.\n\n&gt;&gt;&gt; zodb.EMPTY_ZODB.get('zodbDB', None) is None\nTrue\n</pre>\n</div>\n<div id=\"extending-the-zodb-layer\">\n<h4><a href=\"#id175\" rel=\"nofollow\">Extending the ZODB layer</a></h4>\n<p>When creating a test fixture, it is often desirable to add some initial data to the database.\nIf you want to do that once on layer setup, you can create your own layer class based on <tt>EmptyZODB</tt> and override its <tt>createStorage()</tt> and/or <tt>createDatabase()</tt> methods to return a pre-populated database.:</p>\n<pre>&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; from ZODB.DemoStorage import DemoStorage\n&gt;&gt;&gt; from ZODB.DB import DB\n\n&gt;&gt;&gt; class PopulatedZODB(zodb.EmptyZODB):\n...\n...     def createStorage(self):\n...         return DemoStorage(\"My storage\")\n...\n...     def createDatabase(self, storage):\n...         db = DB(storage)\n...         conn = db.open()\n...\n...         conn.root()['someData'] = 'a string'\n...\n...         transaction.commit()\n...         conn.close()\n...\n...         return db\n\n&gt;&gt;&gt; POPULATED_ZODB = PopulatedZODB()\n</pre>\n<p>We\u2019ll use this new layer in a similar manner to the test above, showing that the data is there for each test, but that other changes are rolled back.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, POPULATED_ZODB, setupLayers)\nSet up PopulatedZODB in ... seconds.\n\n&gt;&gt;&gt; db = POPULATED_ZODB['zodbDB']\n&gt;&gt;&gt; db.storage\nMy storage\n\n&gt;&gt;&gt; POPULATED_ZODB.get('zodbConnection', None) is None\nTrue\n&gt;&gt;&gt; POPULATED_ZODB.get('zodbRoot', None) is None\nTrue\n</pre>\n<p>Let\u2019s now simulate a test.:</p>\n<pre>&gt;&gt;&gt; POPULATED_ZODB.testSetUp()\n</pre>\n<p>The test would then execute. It may use the ZODB root.:</p>\n<pre>&gt;&gt;&gt; POPULATED_ZODB['zodbConnection']\n&lt;Connection at ...&gt;\n\n&gt;&gt;&gt; POPULATED_ZODB['zodbRoot']\n{'someData': 'a string'}\n\n&gt;&gt;&gt; POPULATED_ZODB['zodbRoot']['foo'] = 'bar'\n</pre>\n<p>On test tear-down, the transaction is aborted and the connection is closed.:</p>\n<pre>&gt;&gt;&gt; POPULATED_ZODB.testTearDown()\n\n&gt;&gt;&gt; POPULATED_ZODB.get('zodbConnection', None) is None\nTrue\n\n&gt;&gt;&gt; POPULATED_ZODB.get('zodbRoot', None) is None\nTrue\n</pre>\n<p>The transaction has been rolled back.:</p>\n<pre>&gt;&gt;&gt; conn = POPULATED_ZODB['zodbDB'].open()\n&gt;&gt;&gt; conn.root()\n{'someData': 'a string'}\n&gt;&gt;&gt; conn.close()\n</pre>\n<p>Layer tear-down closes and deletes the database.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down PopulatedZODB in ... seconds.\n\n&gt;&gt;&gt; POPULATED_ZODB.get('zodbDB', None) is None\nTrue\n</pre>\n</div>\n<div id=\"stacking-demostorage-storages\">\n<h4><a href=\"#id176\" rel=\"nofollow\">Stacking <tt>DemoStorage</tt> storages</a></h4>\n<p>The example above shows how to create a simple test fixture with a custom database.\nIt is sometimes useful to be able to stack these fixtures, so that a base layer sets up some data for one set of tests, and a child layer extends this, temporarily, with more data.</p>\n<p>This can be achieved using layer bases and resource shadowing, combined with ZODB\u2019s stackable DemoStorage.\nThere is even a helper function available::</p>\n<pre>&gt;&gt;&gt; from plone.testing import Layer\n&gt;&gt;&gt; from plone.testing import zodb\n&gt;&gt;&gt; import transaction\n\n&gt;&gt;&gt; class ExpandedZODB(Layer):\n...     defaultBases = (POPULATED_ZODB,)\n...\n...     def setUp(self):\n...         # Get the database from the base layer\n...\n...         self['zodbDB'] = db = zodb.stackDemoStorage(self.get('zodbDB'), name='ExpandedZODB')\n...\n...         conn = db.open()\n...         conn.root()['additionalData'] = \"Some new data\"\n...         transaction.commit()\n...         conn.close()\n...\n...     def tearDown(self):\n...         # Close the database and delete the shadowed copy\n...\n...         self['zodbDB'].close()\n...         del self['zodbDB']\n\n&gt;&gt;&gt; EXPANDED_ZODB = ExpandedZODB()\n</pre>\n<p>Notice that we are using plain <tt>Layer</tt> as a base class here.\nWe obtain the underlying database from our bases using the resource manager, and then create a shadow copy using a stacked storage.\nStacked storages contain the data of the original storage, but save changes in a separate (and, in this case, temporary) storage.</p>\n<p>Let\u2019s simulate a test run again to show how this would work.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, EXPANDED_ZODB, setupLayers)\nSet up PopulatedZODB in ... seconds.\nSet up ExpandedZODB in ... seconds.\n\n&gt;&gt;&gt; db = EXPANDED_ZODB['zodbDB']\n&gt;&gt;&gt; db.storage\nExpandedZODB\n\n&gt;&gt;&gt; EXPANDED_ZODB.get('zodbConnection', None) is None\nTrue\n&gt;&gt;&gt; EXPANDED_ZODB.get('zodbRoot', None) is None\nTrue\n</pre>\n<p>Let\u2019s now simulate a test.:</p>\n<pre>&gt;&gt;&gt; POPULATED_ZODB.testSetUp()\n&gt;&gt;&gt; EXPANDED_ZODB.testSetUp()\n</pre>\n<p>The test would then execute. It may use the ZODB root.:</p>\n<pre>&gt;&gt;&gt; EXPANDED_ZODB['zodbConnection']\n&lt;Connection at ...&gt;\n\n&gt;&gt;&gt; EXPANDED_ZODB['zodbRoot'] == dict(someData='a string', additionalData='Some new data')\nTrue\n\n&gt;&gt;&gt; POPULATED_ZODB['zodbRoot']['foo'] = 'bar'\n</pre>\n<p>On test tear-down, the transaction is aborted and the connection is closed.:</p>\n<pre>&gt;&gt;&gt; EXPANDED_ZODB.testTearDown()\n&gt;&gt;&gt; POPULATED_ZODB.testTearDown()\n\n&gt;&gt;&gt; EXPANDED_ZODB.get('zodbConnection', None) is None\nTrue\n\n&gt;&gt;&gt; EXPANDED_ZODB.get('zodbRoot', None) is None\nTrue\n</pre>\n<p>The transaction has been rolled back.:</p>\n<pre>&gt;&gt;&gt; conn = EXPANDED_ZODB['zodbDB'].open()\n&gt;&gt;&gt; conn.root() == dict(someData='a string', additionalData='Some new data')\nTrue\n&gt;&gt;&gt; conn.close()\n</pre>\n<p>We\u2019ll now tear down the expanded layer and inspect the database again.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [POPULATED_ZODB], setupLayers, [])\nTear down ExpandedZODB in ... seconds.\n\n&gt;&gt;&gt; conn = EXPANDED_ZODB['zodbDB'].open()\n&gt;&gt;&gt; conn.root()\n{'someData': 'a string'}\n\n&gt;&gt;&gt; conn.close()\n</pre>\n<p>Finally, we\u2019ll tear down the rest of the layers.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down PopulatedZODB in ... seconds.\n\n&gt;&gt;&gt; EXPANDED_ZODB.get('zodbDB', None) is None\nTrue\n&gt;&gt;&gt; POPULATED_ZODB.get('zodbDB', None) is None\nTrue\n</pre>\n</div>\n</div>\n<div id=\"zope-wsgi-layers\">\n<h3><a href=\"#id177\" rel=\"nofollow\">Zope WSGI layers</a></h3>\n<p>The Zope WSGI layers are found in the module <tt>plone.testing.zope</tt>::</p>\n<pre>&gt;&gt;&gt; from plone.testing import zope\n</pre>\n<p>For testing, we need a testrunner::</p>\n<pre>&gt;&gt;&gt; from zope.testrunner import runner\n</pre>\n<div id=\"id47\">\n<h4><a href=\"#id178\" rel=\"nofollow\">Startup</a></h4>\n<p><tt>STARTUP</tt> is the base layer for all Zope WSGI testing.\nIt sets up a Zope WSGI sandbox environment that is suitable for testing.\nIt extends the <tt>zca.LAYER_CLEANUP</tt> layer to maximise the chances of having and leaving a pristine environment.</p>\n<p><strong>Note</strong>: You should probably use at least <tt>INTEGRATION_TESTING</tt> for any real test, although <tt>STARTUP</tt> is a useful base layer if you are setting up your own fixture.\nSee the description of <tt>INTEGRATION_TESTING</tt> below.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zope.STARTUP.__module__, zope.STARTUP.__name__,)\n'plone.testing.zope.Startup'\n\n&gt;&gt;&gt; zope.STARTUP.__bases__\n(&lt;Layer 'plone.testing.zca.LayerCleanup'&gt;,)\n</pre>\n<p>On layer setup, Zope is initialised in a lightweight manner.\nThis involves certain patches to global modules that Zope manages, to reduce setup time, a database based on <tt>DemoStorage</tt>, and a minimal set of products that must be installed for Zope 2 to work.\nA minimal set of ZCML is loaded, but packages in the <tt>Products</tt> namespace are not automatically configured.</p>\n<p>Let\u2019s just verify that we have an empty component registry before the test::</p>\n<pre>&gt;&gt;&gt; from zope.component import getSiteManager\n&gt;&gt;&gt; list(getSiteManager().registeredAdapters())\n[]\n</pre>\n<p>Five sets a special vocabulary registry upon the layer setup, but there\u2019s a default one set before::</p>\n<pre>&gt;&gt;&gt; from zope.schema.vocabulary import getVocabularyRegistry\n&gt;&gt;&gt; getVocabularyRegistry()\n&lt;zope.schema.vocabulary.VocabularyRegistry object ...&gt;\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zope.STARTUP, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zope.Startup in ... seconds.\n</pre>\n<p>After layer setup, the <tt>zodbDB</tt> resource is available, pointing to the default ZODB.:</p>\n<pre>&gt;&gt;&gt; zope.STARTUP['zodbDB']\n&lt;ZODB.DB.DB object at ...&gt;\n\n&gt;&gt;&gt; zope.STARTUP['zodbDB'].storage\nStartup\n</pre>\n<p>In addition, the resources <tt>host</tt> and <tt>port</tt> are set to the default hostname and port that are used for URLs generated from Zope.\nThese are hardcoded, but shadowed by layers that provide actual running Zope instances.:</p>\n<pre>&gt;&gt;&gt; zope.STARTUP['host']\n'nohost'\n&gt;&gt;&gt; zope.STARTUP['port']\n80\n</pre>\n<p>At this point, it is also possible to get hold of a Zope application root.\nIf you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the <tt>zopeApp()</tt> context manager.:</p>\n<pre>&gt;&gt;&gt; with zope.zopeApp() as app:\n...     'acl_users' in app.objectIds()\nTrue\n</pre>\n<p>If you want to use a specific database, you can pass that to <tt>zopeApp()</tt> as the <tt>db</tt> parameter.\nA new connection will be opened and closed.:</p>\n<pre>&gt;&gt;&gt; with zope.zopeApp(db=zope.STARTUP['zodbDB']) as app:\n...     'acl_users' in app.objectIds()\nTrue\n</pre>\n<p>If you want to re-use an existing connection, you can pass one to <tt>zopeApp()</tt> as the <tt>connection</tt> argument.\nIn this case, you will need to close the connection yourself.:</p>\n<pre>&gt;&gt;&gt; conn = zope.STARTUP['zodbDB'].open()\n&gt;&gt;&gt; with zope.zopeApp(connection=conn) as app:\n...     'acl_users' in app.objectIds()\nTrue\n\n&gt;&gt;&gt; conn.opened is not None\nTrue\n\n&gt;&gt;&gt; conn.close()\n</pre>\n<p>If an exception is raised within the <tt>with</tt> block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager)::</p>\n<pre>&gt;&gt;&gt; with zope.zopeApp() as app:\n...     raise Exception(\"Test error\")\nTraceback (most recent call last):\n...\nException: Test error\n</pre>\n<p>It is common to combine the <tt>zopeApp()</tt> context manager with a stacked <tt>DemoStorage</tt> to set up a layer-specific fixture.\nAs a sketch::</p>\n<pre>from plone.testing import Layer, zope, zodb\n\nclass MyLayer(Layer):\n    defaultBases = (zope.STARTUP,)\n\n    def setUp(self):\n        self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')\n        with zope.zopeApp() as app:\n\n            # Set up a fixture, e.g.:\n            app.manage_addFolder('folder1')\n            folder = app['folder1']\n            folder._addRole('role1')\n            folder.manage_addUserFolder()\n\n            userFolder = folder['acl_users']\n            ignore = userFolder.userFolderAddUser('user1', 'secret', ['role1'], [])\n            folder.manage_role('role1', ('Access contents information',))\n\n    def tearDown(self):\n        self['zodbDB'].close()\n        del self['zodbDB']\n</pre>\n<p>Note that you would normally <em>not</em> use the <tt>zope.zopeApp()</tt> in a test or in a <tt>testSetUp()</tt> or <tt>testTearDown()</tt> method.\nThe <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt> layer classes manage the application object for you, exposing them as the resource <tt>app</tt> (see below).</p>\n<p>After layer setup, the global component registry contains a number of components needed by Zope.:</p>\n<pre>&gt;&gt;&gt; len(list(getSiteManager().registeredAdapters())) &gt; 1 # in fact, &gt; a lot\nTrue\n</pre>\n<p>And Five has set a <tt>Zope2VocabularyRegistry</tt> vocabulary registry::</p>\n<pre>&gt;&gt;&gt; getVocabularyRegistry()\n&lt;....Zope2VocabularyRegistry object at ...&gt;\n</pre>\n<p>To load additional ZCML, you can use the <tt>configurationContext</tt> resource::</p>\n<pre>&gt;&gt;&gt; zope.STARTUP['configurationContext']\n&lt;zope.configuration.config.ConfigurationMachine object ...&gt;\n</pre>\n<p>See <tt>zca.rst</tt> for details about how to use <tt>zope.configuration</tt> for this purpose.</p>\n<p>The <tt>STARTUP</tt> layer does not perform any specific test setup or tear-down.\nThat is left up to the <tt>INTEGRATION_TESTING</tt> and <tt>FUNCTIONAL_TESTING</tt> layers, or other layers using their layer classes - <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt>.:</p>\n<pre>&gt;&gt;&gt; zope.STARTUP.testSetUp()\n&gt;&gt;&gt; zope.STARTUP.testTearDown()\n</pre>\n<p>Layer tear-down resets the environment.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zope.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n\n&gt;&gt;&gt; import Zope2\n&gt;&gt;&gt; Zope2._began_startup\n0\n&gt;&gt;&gt; Zope2.DB is None\nTrue\n&gt;&gt;&gt; Zope2.bobo_application is None\nTrue\n\n&gt;&gt;&gt; list(getSiteManager().registeredAdapters())\n[]\n\n&gt;&gt;&gt; getVocabularyRegistry()\n&lt;zope.schema.vocabulary.VocabularyRegistry object at ...&gt;\n</pre>\n</div>\n<div id=\"id48\">\n<h4><a href=\"#id179\" rel=\"nofollow\">Integration test</a></h4>\n<p><tt>INTEGRATION_TESTING</tt> is intended for simple Zope WSGI integration testing.\nIt extends <tt>STARTUP</tt> to ensure that a transaction is begun before and rolled back after each test.\nTwo resources, <tt>app</tt> and <tt>request</tt>, are available during testing as well.\nIt does not manage any layer state - it implements the test lifecycle methods only.</p>\n<p><strong>Note:</strong> You would normally <em>not</em> use <tt>INTEGRATION_TESTING</tt> as a base layer.\nInstead, you\u2019d use the <tt>IntegrationTesting</tt> class to create your own layer with the testing lifecycle semantics of <tt>INTEGRATION_TESTING</tt>.\nSee the <tt>plone.testing</tt> <tt>README</tt> file for an example.</p>\n<p><tt>app</tt> is the application root.\nIn a test, you should use this instead of the <tt>zopeApp</tt> context manager (which remains the weapon of choice for setting up persistent fixtures), because the <tt>app</tt> resource is part of the transaction managed by the layer.</p>\n<p><tt>request</tt> is a test request. It is the same as <tt>app.REQUEST</tt>.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zope.INTEGRATION_TESTING.__module__, zope.INTEGRATION_TESTING.__name__,)\n'plone.testing.zope.IntegrationTesting'\n\n&gt;&gt;&gt; zope.INTEGRATION_TESTING.__bases__\n(&lt;Layer 'plone.testing.zope.Startup'&gt;,)\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zope.INTEGRATION_TESTING, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zope.Startup in ... seconds.\nSet up plone.testing.zope.IntegrationTesting in ... seconds.\n</pre>\n<p>Let\u2019s now simulate a test.\nOn test setup, the <tt>app</tt> resource is made available.\nIn a test, you should always use this to access the application root.:</p>\n<pre>&gt;&gt;&gt; zope.STARTUP.testSetUp()\n&gt;&gt;&gt; zope.INTEGRATION_TESTING.testSetUp()\n</pre>\n<p>The test may now inspect and modify the environment.:</p>\n<pre>&gt;&gt;&gt; app = zope.INTEGRATION_TESTING['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; app.manage_addFolder('folder1')\n&gt;&gt;&gt; 'acl_users' in app.objectIds() and 'folder1' in app.objectIds()\nTrue\n</pre>\n<p>The request is also available::</p>\n<pre>&gt;&gt;&gt; zope.INTEGRATION_TESTING['request'] # would normally be self.layer['request']\n&lt;HTTPRequest, URL=http://nohost&gt;\n</pre>\n<p>We can create a user and simulate logging in as that user, using the <tt>zope.login()</tt> helper::</p>\n<pre>&gt;&gt;&gt; app._addRole('role1')\n&gt;&gt;&gt; ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])\n&gt;&gt;&gt; zope.login(app['acl_users'], 'user1')\n</pre>\n<p>The first argument to <tt>zope.login()</tt> is the user folder that contains the relevant user.\nThe second argument is the user\u2019s name.\nThere is no need to give the password.:</p>\n<pre>&gt;&gt;&gt; from AccessControl import getSecurityManager\n&gt;&gt;&gt; getSecurityManager().getUser()\n&lt;User 'user1'&gt;\n</pre>\n<p>You can change the roles of a user using the <tt>zope.setRoles()</tt> helper::</p>\n<pre>&gt;&gt;&gt; sorted(getSecurityManager().getUser().getRolesInContext(app))\n['Authenticated', 'role1']\n\n&gt;&gt;&gt; zope.setRoles(app['acl_users'], 'user1', [])\n&gt;&gt;&gt; getSecurityManager().getUser().getRolesInContext(app)\n['Authenticated']\n</pre>\n<p>To become the anonymous user again, use <tt>zope.logout()</tt>::</p>\n<pre>&gt;&gt;&gt; zope.logout()\n&gt;&gt;&gt; getSecurityManager().getUser()\n&lt;SpecialUser 'Anonymous User'&gt;\n</pre>\n<p>On tear-down, the transaction is rolled back::</p>\n<pre>&gt;&gt;&gt; zope.INTEGRATION_TESTING.testTearDown()\n&gt;&gt;&gt; zope.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zope.INTEGRATION_TESTING\nFalse\n\n&gt;&gt;&gt; 'request' in zope.INTEGRATION_TESTING\nFalse\n\n&gt;&gt;&gt; with zope.zopeApp() as app:\n...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\nTrue\n</pre>\n<p>Let\u2019s tear down the layers::</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zope.IntegrationTesting in ... seconds.\nTear down plone.testing.zope.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n</pre>\n</div>\n<div id=\"id49\">\n<h4><a href=\"#id180\" rel=\"nofollow\">Functional testing</a></h4>\n<p>The <tt>FUNCTIONAL_TESTING</tt> layer is very similar to <tt>INTEGRATION_TESTING</tt>, and exposes the same fixture and resources.\nHowever, it has different transaction semantics.\n<tt>INTEGRATION_TESTING</tt> creates a single database storage, and rolls back the transaction after each test.\n<tt>FUNCTIONAL_TESTING</tt> creates a whole new database storage (stacked on top of the basic fixture) for each test.\nThis allows testing of code that performs an explicit commit, which is usually required for end-to-end testing.\nThe downside is that the set-up and tear-down of each test takes longer.</p>\n<p><strong>Note:</strong> Again, you would normally <em>not</em> use <tt>FUNCTIONAL_TESTING</tt> as a base layer.\nInstead, you\u2019d use the <tt>FunctionalTesting</tt> class to create your own layer with the testing lifecycle semantics of <tt>FUNCTIONAL_TESTING</tt>.\nSee the <tt>plone.testing</tt> <tt>README</tt> file for an example.</p>\n<p>Like <tt>INTEGRATION_TESTING</tt>, <tt>FUNCTIONAL_TESTING</tt> is based on <tt>STARTUP</tt>.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zope.FUNCTIONAL_TESTING.__module__, zope.FUNCTIONAL_TESTING.__name__,)\n'plone.testing.zope.FunctionalTesting'\n\n&gt;&gt;&gt; zope.FUNCTIONAL_TESTING.__bases__\n(&lt;Layer 'plone.testing.zope.Startup'&gt;,)\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zope.FUNCTIONAL_TESTING, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zope.Startup in ... seconds.\nSet up plone.testing.zope.FunctionalTesting in ... seconds.\n</pre>\n<p>Let\u2019s now simulate a test.\nOn test setup, the <tt>app</tt> resource is made available.\nIn a test, you should always use this to access the application root.\nThe <tt>request</tt> resource can be used to access the test request.:</p>\n<pre>&gt;&gt;&gt; zope.STARTUP.testSetUp()\n&gt;&gt;&gt; zope.FUNCTIONAL_TESTING.testSetUp()\n</pre>\n<p>The test may now inspect and modify the environment.\nIt may also commit things.:</p>\n<pre>&gt;&gt;&gt; app = zope.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; app.manage_addFolder('folder1')\n&gt;&gt;&gt; 'acl_users' in app.objectIds() and 'folder1' in app.objectIds()\nTrue\n\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; transaction.commit()\n</pre>\n<p>On tear-down, the database is torn down.:</p>\n<pre>&gt;&gt;&gt; zope.FUNCTIONAL_TESTING.testTearDown()\n&gt;&gt;&gt; zope.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zope.FUNCTIONAL_TESTING\nFalse\n\n&gt;&gt;&gt; 'request' in zope.FUNCTIONAL_TESTING\nFalse\n\n&gt;&gt;&gt; with zope.zopeApp() as app:\n...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\nTrue\n</pre>\n<p>Let\u2019s tear down the layer::</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zope.FunctionalTesting in ... seconds.\nTear down plone.testing.zope.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n</pre>\n</div>\n<div id=\"the-test-browser\">\n<h4><a href=\"#id181\" rel=\"nofollow\">The test browser</a></h4>\n<p>The <tt>FUNCTIONAL_TESTING</tt> layer and <tt>FunctionalTesting</tt> layer class are the basis for functional testing using <tt>zope.testbrowser</tt>.\nThis simulates a web browser, allowing an application to be tested \u201cend-to-end\u201d via its user-facing interface.</p>\n<p>To use the test browser with a <tt>FunctionalTesting</tt> layer (such as the default <tt>FUNCTIONAL_TESTING</tt> layer instance), we need to use a custom browser client, which ensures that the test browser uses the correct ZODB and is appropriately isolated from the test code.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zope.FUNCTIONAL_TESTING, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zope.Startup in ... seconds.\nSet up plone.testing.zope.FunctionalTesting in ... seconds.\n</pre>\n<p>Let\u2019s simulate a test::</p>\n<pre>&gt;&gt;&gt; zope.STARTUP.testSetUp()\n&gt;&gt;&gt; zope.FUNCTIONAL_TESTING.testSetUp()\n</pre>\n<p>In the test, we can create a test browser client like so::</p>\n<pre>&gt;&gt;&gt; app = zope.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; browser = zope.Browser(app)\n</pre>\n<p>It is usually best to let Zope errors be shown with full tracebacks::</p>\n<pre>&gt;&gt;&gt; browser.handleErrors = False\n</pre>\n<p>We can add to the test fixture in the test.\nFor those changes to be visible to the test browser, however, we need to commit the transaction.:</p>\n<pre>&gt;&gt;&gt; _ = app.manage_addDTMLDocument('dtml-doc-1')\n&gt;&gt;&gt; import transaction; transaction.commit()\n</pre>\n<p>We can now view this via the test browser::</p>\n<pre>&gt;&gt;&gt; browser.open(app.absolute_url() + '/dtml-doc-1')\n&gt;&gt;&gt; 'This is the dtml-doc-1 Document.' in browser.contents\nTrue\n</pre>\n<p>The test browser integration converts the URL into a request and passes control to Zope\u2019s publisher.\nLet\u2019s check that query strings are available for input processing::</p>\n<pre>&gt;&gt;&gt; from six.moves.urllib.parse import urlencode\n&gt;&gt;&gt; _ = app.manage_addDTMLDocument('dtml-doc-2', file='&lt;dtml-var foo&gt;')\n&gt;&gt;&gt; import transaction; transaction.commit()\n&gt;&gt;&gt; qs = urlencode({'foo': 'boo, bar &amp; baz'})  # sic: the ampersand.\n&gt;&gt;&gt; browser.open(app.absolute_url() + '/dtml-doc-2?' + qs)\n&gt;&gt;&gt; browser.contents\n'boo, bar &amp; baz'\n</pre>\n<p>The test browser also works with iterators.\nLet\u2019s test that with a simple file implementation that uses an iterator.:</p>\n<pre>&gt;&gt;&gt; from plone.testing.tests import DummyFile\n&gt;&gt;&gt; app._setObject('file1', DummyFile('file1'))\n'file1'\n\n&gt;&gt;&gt; import transaction; transaction.commit()\n\n&gt;&gt;&gt; browser.open(app.absolute_url() + '/file1')\n&gt;&gt;&gt; 'The test browser also works with iterators' in browser.contents\nTrue\n</pre>\n<p>See the <tt>zope.testbrowser</tt> documentation for more information about how to use the browser client.</p>\n<p>On tear-down, the database is torn down.:</p>\n<pre>&gt;&gt;&gt; zope.FUNCTIONAL_TESTING.testTearDown()\n&gt;&gt;&gt; zope.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zope.FUNCTIONAL_TESTING\nFalse\n\n&gt;&gt;&gt; 'request' in zope.FUNCTIONAL_TESTING\nFalse\n\n&gt;&gt;&gt; with zope.zopeApp() as app:\n...     'acl_users' in app.objectIds()\\\n...         and 'folder1' not in app.objectIds()\\\n...         and 'file1' not in app.objectIds()\nTrue\n</pre>\n<p>Let\u2019s tear down the layer::</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zope.FunctionalTesting in ... seconds.\nTear down plone.testing.zope.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n</pre>\n</div>\n<div id=\"http-server\">\n<h4><a href=\"#id182\" rel=\"nofollow\">HTTP server</a></h4>\n<p>The <tt>WSGI_SERVER_FIXTURE</tt> layer extends <tt>STARTUP</tt> to start a single-threaded Zope server in a separate thread.\nThis makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.</p>\n<p>The <tt>WSGI_SERVER</tt> layer provides a <tt>FunctionalTesting</tt> layer that has <tt>WSGI_SERVER_FIXTURE</tt> as its base.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zope.WSGI_SERVER_FIXTURE.__module__, zope.WSGI_SERVER_FIXTURE.__name__,)\n'plone.testing.zope.WSGIServer'\n\n&gt;&gt;&gt; zope.WSGI_SERVER_FIXTURE.__bases__\n(&lt;Layer 'plone.testing.zope.Startup'&gt;,)\n\n\n&gt;&gt;&gt; \"%s.%s\" % (zope.WSGI_SERVER.__module__, zope.WSGI_SERVER.__name__,)\n'plone.testing.zope.WSGIServer:Functional'\n\n&gt;&gt;&gt; zope.WSGI_SERVER.__bases__\n(&lt;Layer 'plone.testing.zope.WSGIServer'&gt;,)\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zope.WSGI_SERVER, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zope.Startup in ... seconds.\nSet up plone.testing.zope.WSGIServer in ... seconds.\nSet up plone.testing.zope.WSGIServer:Functional in ... seconds.\n</pre>\n<p>After layer setup, the resources <tt>host</tt> and <tt>port</tt> are available, and indicate where Zope is running.:</p>\n<pre>&gt;&gt;&gt; host = zope.WSGI_SERVER['host']\n&gt;&gt;&gt; host\n'localhost'\n\n&gt;&gt;&gt; port = zope.WSGI_SERVER['port']\n</pre>\n<p>Let\u2019s now simulate a test.\nTest setup does nothing beyond what the base layers do.:</p>\n<pre>&gt;&gt;&gt; zope.STARTUP.testSetUp()\n&gt;&gt;&gt; zope.FUNCTIONAL_TESTING.testSetUp()\n&gt;&gt;&gt; zope.WSGI_SERVER.testSetUp()\n</pre>\n<p>It is common in a test to use the Python API to change the state of the server (e.g.\ncreate some content or change a setting) and then use the HTTP protocol to look at the results.\nBear in mind that the server is running in a separate thread, with a separate security manager, so calls to <tt>zope.login()</tt> and <tt>zope.logout()</tt>, for instance, do not affect the server thread.:</p>\n<pre>&gt;&gt;&gt; app = zope.WSGI_SERVER['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; _ = app.manage_addDTMLDocument('dtml-doc-3')\n</pre>\n<p>Note that we need to commit the transaction before it will show up in the other thread.:</p>\n<pre>&gt;&gt;&gt; import transaction; transaction.commit()\n</pre>\n<p>We can now look for this new object through the server.:</p>\n<pre>&gt;&gt;&gt; app_url = app.absolute_url()\n&gt;&gt;&gt; app_url.split(':')[:-1]\n['http', '//localhost']\n\n&gt;&gt;&gt; from six.moves.urllib.request import urlopen\n&gt;&gt;&gt; conn = urlopen(app_url + '/dtml-doc-3', timeout=5)\n&gt;&gt;&gt; b'This is the dtml-doc-3 Document.' in conn.read()\nTrue\n&gt;&gt;&gt; conn.close()\n</pre>\n<p>Test tear-down does nothing beyond what the base layers do.:</p>\n<pre>&gt;&gt;&gt; zope.WSGI_SERVER.testTearDown()\n&gt;&gt;&gt; zope.FUNCTIONAL_TESTING.testTearDown()\n&gt;&gt;&gt; zope.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zope.WSGI_SERVER\nFalse\n\n&gt;&gt;&gt; 'request' in zope.WSGI_SERVER\nFalse\n\n&gt;&gt;&gt; with zope.zopeApp() as app:\n...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\nTrue\n</pre>\n<p>When the server is torn down, the WSGIServer thread is stopped.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zope.WSGIServer:Functional in ... seconds.\nTear down plone.testing.zope.WSGIServer in ... seconds.\nTear down plone.testing.zope.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n</pre>\n<p>We can expect one of these exceptions:\n- URLError: &lt;urlopen error [Errno \u2026] Connection refused&gt;\n- error: [Errno 104] Connection reset by peer</p>\n<blockquote>\n<pre>&gt;&gt;&gt; try:\n...     conn = urlopen(app_url + '/folder1', timeout=5)\n... except Exception as exc:\n...     if 'Connection refused' not in str(exc) and 'Connection reset' not in str(exc):\n...         raise exc\n... else:\n...     print('urlopen should have raised exception')\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"zope-2-layers\">\n<h3><a href=\"#id183\" rel=\"nofollow\">Zope 2 layers</a></h3>\n<p>The Zope 2 layers are found in the module <tt>plone.testing.zserver</tt>::</p>\n<pre>&gt;&gt;&gt; from plone.testing import zserver\n</pre>\n<p>For testing, we need a testrunner::</p>\n<pre>&gt;&gt;&gt; from zope.testrunner import runner\n</pre>\n<div id=\"id50\">\n<h4><a href=\"#id184\" rel=\"nofollow\">Startup</a></h4>\n<p><tt>STARTUP</tt> is the base layer for all Zope 2 testing.\nIt sets up a Zope 2 sandbox environment that is suitable for testing.\nIt extends the <tt>zca.LAYER_CLEANUP</tt> layer to maximise the chances of having and leaving a pristine environment.</p>\n<p><strong>Note</strong>: You should probably use at least <tt>INTEGRATION_TESTING</tt> for any real test, although <tt>STARTUP</tt> is a useful base layer if you are setting up your own fixture.\nSee the description of <tt>INTEGRATION_TESTING</tt> below.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zserver.STARTUP.__module__, zserver.STARTUP.__name__,)\n'plone.testing.zserver.Startup'\n\n&gt;&gt;&gt; zserver.STARTUP.__bases__\n(&lt;Layer 'plone.testing.zca.LayerCleanup'&gt;,)\n</pre>\n<p>On layer setup, Zope is initialised in a lightweight manner.\nThis involves certain patches to global modules that Zope manages, to reduce setup time, a database based on <tt>DemoStorage</tt>, and a minimal set of products that must be installed for Zope 2 to work.\nA minimal set of ZCML is loaded, but packages in the <tt>Products</tt> namespace are not automatically configured.</p>\n<p>Let\u2019s just verify that we have an empty component registry before the test::</p>\n<pre>&gt;&gt;&gt; from zope.component import getSiteManager\n&gt;&gt;&gt; list(getSiteManager().registeredAdapters())\n[]\n</pre>\n<p>Five sets a special vocabulary registry upon the layer setup, but there\u2019s a default one set before::</p>\n<pre>&gt;&gt;&gt; from zope.schema.vocabulary import getVocabularyRegistry\n&gt;&gt;&gt; getVocabularyRegistry()\n&lt;zope.schema.vocabulary.VocabularyRegistry object ...&gt;\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zserver.STARTUP, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zserver.Startup in ... seconds.\n</pre>\n<p>After layer setup, the <tt>zodbDB</tt> resource is available, pointing to the default ZODB.:</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP['zodbDB']\n&lt;ZODB.DB.DB object at ...&gt;\n\n&gt;&gt;&gt; zserver.STARTUP['zodbDB'].storage\nStartup\n</pre>\n<p>In addition, the resources <tt>host</tt> and <tt>port</tt> are set to the default hostname and port that are used for URLs generated from Zope.\nThese are hardcoded, but shadowed by layers that provide actual running Zope instances.:</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP['host']\n'nohost'\n&gt;&gt;&gt; zserver.STARTUP['port']\n80\n</pre>\n<p>At this point, it is also possible to get hold of a Zope application root.\nIf you are setting up a layer fixture, you can obtain an application root with the correct database that is properly closed by using the <tt>zopeApp()</tt> context manager.:</p>\n<pre>&gt;&gt;&gt; with zserver.zopeApp() as app:\n...     'acl_users' in app.objectIds()\nTrue\n</pre>\n<p>If you want to use a specific database, you can pass that to <tt>zopeApp()</tt> as the <tt>db</tt> parameter.\nA new connection will be opened and closed.:</p>\n<pre>&gt;&gt;&gt; with zserver.zopeApp(db=zserver.STARTUP['zodbDB']) as app:\n...     'acl_users' in app.objectIds()\nTrue\n</pre>\n<p>If you want to re-use an existing connection, you can pass one to <tt>zopeApp()</tt> as the <tt>connection</tt> argument.\nIn this case, you will need to close the connection yourself.:</p>\n<pre>&gt;&gt;&gt; conn = zserver.STARTUP['zodbDB'].open()\n&gt;&gt;&gt; with zserver.zopeApp(connection=conn) as app:\n...     'acl_users' in app.objectIds()\nTrue\n\n&gt;&gt;&gt; conn.opened is not None\nTrue\n\n&gt;&gt;&gt; conn.close()\n</pre>\n<p>If an exception is raised within the <tt>with</tt> block, the transaction is aborted, but the connection is still closed (if it was opened by the context manager)::</p>\n<pre>&gt;&gt;&gt; with zserver.zopeApp() as app:\n...     raise Exception(\"Test error\")\nTraceback (most recent call last):\n...\nException: Test error\n</pre>\n<p>It is common to combine the <tt>zopeApp()</tt> context manager with a stacked <tt>DemoStorage</tt> to set up a layer-specific fixture.\nAs a sketch::</p>\n<pre>from plone.testing import Layer, zserver, zodb\n\nclass MyLayer(Layer):\n    defaultBases = (zserver.STARTUP,)\n\n    def setUp(self):\n        self['zodbDB'] = zodb.stackDemoStorage(self.get('zodbDB'), name='MyLayer')\n        with zserver.zopeApp() as app:\n\n            # Set up a fixture, e.g.:\n            app.manage_addFolder('folder1')\n            folder = app['folder1']\n            folder._addRole('role1')\n            folder.manage_addUserFolder()\n\n            userFolder = folder['acl_users']\n            ignore = userFolder.userFolderAddUser('user1', 'secret', ['role1'], [])\n            folder.manage_role('role1', ('Access contents information',))\n\n    def tearDown(self):\n        self['zodbDB'].close()\n        del self['zodbDB']\n</pre>\n<p>Note that you would normally <em>not</em> use the <tt>zserver.zopeApp()</tt> in a test or in a <tt>testSetUp()</tt> or <tt>testTearDown()</tt> method.\nThe <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt> layer classes manage the application object for you, exposing them as the resource <tt>app</tt> (see below).</p>\n<p>After layer setup, the global component registry contains a number of components needed by Zope.:</p>\n<pre>&gt;&gt;&gt; len(list(getSiteManager().registeredAdapters())) &gt; 1 # in fact, &gt; a lot\nTrue\n</pre>\n<p>And Five has set a <tt>Zope2VocabularyRegistry</tt> vocabulary registry::</p>\n<pre>&gt;&gt;&gt; getVocabularyRegistry()\n&lt;....Zope2VocabularyRegistry object at ...&gt;\n</pre>\n<p>To load additional ZCML, you can use the <tt>configurationContext</tt> resource::</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP['configurationContext']\n&lt;zope.configuration.config.ConfigurationMachine object ...&gt;\n</pre>\n<p>See <tt>zca.rst</tt> for details about how to use <tt>zope.configuration</tt> for this purpose.</p>\n<p>The <tt>STARTUP</tt> layer does not perform any specific test setup or tear-down.\nThat is left up to the <tt>INTEGRATION_TESTING</tt> and <tt>FUNCTIONAL_TESTING</tt> layers, or other layers using their layer classes - <tt>IntegrationTesting</tt> and <tt>FunctionalTesting</tt>.:</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP.testSetUp()\n&gt;&gt;&gt; zserver.STARTUP.testTearDown()\n</pre>\n<p>Layer tear-down resets the environment.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zserver.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n\n&gt;&gt;&gt; import ZServer.Zope2\n&gt;&gt;&gt; ZServer.Zope2._began_startup\n0\n&gt;&gt;&gt; import Zope2\n&gt;&gt;&gt; Zope2.DB is None\nTrue\n&gt;&gt;&gt; Zope2.bobo_application is None\nTrue\n\n&gt;&gt;&gt; list(getSiteManager().registeredAdapters())\n[]\n\n&gt;&gt;&gt; getVocabularyRegistry()\n&lt;zope.schema.vocabulary.VocabularyRegistry object at ...&gt;\n</pre>\n</div>\n<div id=\"id51\">\n<h4><a href=\"#id185\" rel=\"nofollow\">Integration test</a></h4>\n<p><tt>INTEGRATION_TESTING</tt> is intended for simple Zope 2 integration testing.\nIt extends <tt>STARTUP</tt> to ensure that a transaction is begun before and rolled back after each test.\nTwo resources, <tt>app</tt> and <tt>request</tt>, are available during testing as well.\nIt does not manage any layer state - it implements the test lifecycle methods only.</p>\n<p><strong>Note:</strong> You would normally <em>not</em> use <tt>INTEGRATION_TESTING</tt> as a base layer.\nInstead, you\u2019d use the <tt>IntegrationTesting</tt> class to create your own layer with the testing lifecycle semantics of <tt>INTEGRATION_TESTING</tt>.\nSee the <tt>plone.testing</tt> <tt>README</tt> file for an example.</p>\n<p><tt>app</tt> is the application root.\nIn a test, you should use this instead of the <tt>zopeApp</tt> context manager (which remains the weapon of choice for setting up persistent fixtures), because the <tt>app</tt> resource is part of the transaction managed by the layer.</p>\n<p><tt>request</tt> is a test request. It is the same as <tt>app.REQUEST</tt>.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zserver.INTEGRATION_TESTING.__module__, zserver.INTEGRATION_TESTING.__name__,)\n'plone.testing.zserver.IntegrationTesting'\n\n&gt;&gt;&gt; zserver.INTEGRATION_TESTING.__bases__\n(&lt;Layer 'plone.testing.zserver.Startup'&gt;,)\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zserver.INTEGRATION_TESTING, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zserver.Startup in ... seconds.\nSet up plone.testing.zserver.IntegrationTesting in ... seconds.\n</pre>\n<p>Let\u2019s now simulate a test.\nOn test setup, the <tt>app</tt> resource is made available.\nIn a test, you should always use this to access the application root.:</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP.testSetUp()\n&gt;&gt;&gt; zserver.INTEGRATION_TESTING.testSetUp()\n</pre>\n<p>The test may now inspect and modify the environment.:</p>\n<pre>&gt;&gt;&gt; app = zserver.INTEGRATION_TESTING['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; app.manage_addFolder('folder1')\n&gt;&gt;&gt; 'acl_users' in app.objectIds() and 'folder1' in app.objectIds()\nTrue\n</pre>\n<p>The request is also available::</p>\n<pre>&gt;&gt;&gt; zserver.INTEGRATION_TESTING['request'] # would normally be self.layer['request']\n&lt;HTTPRequest, URL=http://nohost&gt;\n</pre>\n<p>We can create a user and simulate logging in as that user, using the <tt>zserver.login()</tt> helper::</p>\n<pre>&gt;&gt;&gt; app._addRole('role1')\n&gt;&gt;&gt; ignore = app['acl_users'].userFolderAddUser('user1', 'secret', ['role1'], [])\n&gt;&gt;&gt; zserver.login(app['acl_users'], 'user1')\n</pre>\n<p>The first argument to <tt>zserver.login()</tt> is the user folder that contains the relevant user.\nThe second argument is the user\u2019s name.\nThere is no need to give the password.:</p>\n<pre>&gt;&gt;&gt; from AccessControl import getSecurityManager\n&gt;&gt;&gt; getSecurityManager().getUser()\n&lt;User 'user1'&gt;\n</pre>\n<p>You can change the roles of a user using the <tt>zserver.setRoles()</tt> helper::</p>\n<pre>&gt;&gt;&gt; sorted(getSecurityManager().getUser().getRolesInContext(app))\n['Authenticated', 'role1']\n\n&gt;&gt;&gt; zserver.setRoles(app['acl_users'], 'user1', [])\n&gt;&gt;&gt; getSecurityManager().getUser().getRolesInContext(app)\n['Authenticated']\n</pre>\n<p>To become the anonymous user again, use <tt>zserver.logout()</tt>::</p>\n<pre>&gt;&gt;&gt; zserver.logout()\n&gt;&gt;&gt; getSecurityManager().getUser()\n&lt;SpecialUser 'Anonymous User'&gt;\n</pre>\n<p>On tear-down, the transaction is rolled back::</p>\n<pre>&gt;&gt;&gt; zserver.INTEGRATION_TESTING.testTearDown()\n&gt;&gt;&gt; zserver.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zserver.INTEGRATION_TESTING\nFalse\n\n&gt;&gt;&gt; 'request' in zserver.INTEGRATION_TESTING\nFalse\n\n&gt;&gt;&gt; with zserver.zopeApp() as app:\n...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\nTrue\n</pre>\n<p>Let\u2019s tear down the layers::</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zserver.IntegrationTesting in ... seconds.\nTear down plone.testing.zserver.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n</pre>\n</div>\n<div id=\"id52\">\n<h4><a href=\"#id186\" rel=\"nofollow\">Functional testing</a></h4>\n<p>The <tt>FUNCTIONAL_TESTING</tt> layer is very similar to <tt>INTEGRATION_TESTING</tt>, and exposes the same fixture and resources.\nHowever, it has different transaction semantics.\n<tt>INTEGRATION_TESTING</tt> creates a single database storage, and rolls back the transaction after each test.\n<tt>FUNCTIONAL_TESTING</tt> creates a whole new database storage (stacked on top of the basic fixture) for each test.\nThis allows testing of code that performs an explicit commit, which is usually required for end-to-end testing.\nThe downside is that the set-up and tear-down of each test takes longer.</p>\n<p><strong>Note:</strong> Again, you would normally <em>not</em> use <tt>FUNCTIONAL_TESTING</tt> as a base layer.\nInstead, you\u2019d use the <tt>FunctionalTesting</tt> class to create your own layer with the testing lifecycle semantics of <tt>FUNCTIONAL_TESTING</tt>.\nSee the <tt>plone.testing</tt> <tt>README</tt> file for an example.</p>\n<p>Like <tt>INTEGRATION_TESTING</tt>, <tt>FUNCTIONAL_TESTING</tt> is based on <tt>STARTUP</tt>.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zserver.FUNCTIONAL_TESTING.__module__, zserver.FUNCTIONAL_TESTING.__name__,)\n'plone.testing.zserver.FunctionalTesting'\n\n&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.__bases__\n(&lt;Layer 'plone.testing.zserver.Startup'&gt;,)\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zserver.FUNCTIONAL_TESTING, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zserver.Startup in ... seconds.\nSet up plone.testing.zserver.FunctionalTesting in ... seconds.\n</pre>\n<p>Let\u2019s now simulate a test.\nOn test setup, the <tt>app</tt> resource is made available.\nIn a test, you should always use this to access the application root.\nThe <tt>request</tt> resource can be used to access the test request.:</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP.testSetUp()\n&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.testSetUp()\n</pre>\n<p>The test may now inspect and modify the environment.\nIt may also commit things.:</p>\n<pre>&gt;&gt;&gt; app = zserver.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; app.manage_addFolder('folder1')\n&gt;&gt;&gt; 'acl_users' in app.objectIds() and 'folder1' in app.objectIds()\nTrue\n\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; transaction.commit()\n</pre>\n<p>On tear-down, the database is torn down.:</p>\n<pre>&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.testTearDown()\n&gt;&gt;&gt; zserver.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zserver.FUNCTIONAL_TESTING\nFalse\n\n&gt;&gt;&gt; 'request' in zserver.FUNCTIONAL_TESTING\nFalse\n\n&gt;&gt;&gt; with zserver.zopeApp() as app:\n...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\nTrue\n</pre>\n<p>Let\u2019s tear down the layer::</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zserver.FunctionalTesting in ... seconds.\nTear down plone.testing.zserver.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n</pre>\n</div>\n<div id=\"id53\">\n<h4><a href=\"#id187\" rel=\"nofollow\">The test browser</a></h4>\n<p>The <tt>FUNCTIONAL_TESTING</tt> layer and <tt>FunctionalTesting</tt> layer class are the basis for functional testing using <tt>zope.testbrowser</tt>.\nThis simulates a web browser, allowing an application to be tested \u201cend-to-end\u201d via its user-facing interface.</p>\n<p>To use the test browser with a <tt>FunctionalTesting</tt> layer (such as the default <tt>FUNCTIONAL_TESTING</tt> layer instance), we need to use a custom browser client, which ensures that the test browser uses the correct ZODB and is appropriately isolated from the test code.:</p>\n<pre>&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zserver.FUNCTIONAL_TESTING, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zserver.Startup in ... seconds.\nSet up plone.testing.zserver.FunctionalTesting in ... seconds.\n</pre>\n<p>Let\u2019s simulate a test::</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP.testSetUp()\n&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.testSetUp()\n</pre>\n<p>In the test, we can create a test browser client like so::</p>\n<pre>&gt;&gt;&gt; app = zserver.FUNCTIONAL_TESTING['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; browser = zserver.Browser(app)\n</pre>\n<p>It is usually best to let Zope errors be shown with full tracebacks::</p>\n<pre>&gt;&gt;&gt; browser.handleErrors = False\n</pre>\n<p>We can add to the test fixture in the test.\nFor those changes to be visible to the test browser, however, we need to commit the transaction.:</p>\n<pre>&gt;&gt;&gt; app.manage_addFolder('folder1')\n&gt;&gt;&gt; import transaction; transaction.commit()\n</pre>\n<p>We can now view this via the test browser::</p>\n<pre>&gt;&gt;&gt; browser.open(app.absolute_url() + '/folder1')\n\n&gt;&gt;&gt; browser.contents.replace('\"', '').replace(\"'\", \"\")\n'&lt;Folder ...'\n</pre>\n<p>The __repr__ of Zope objects is not stable anymore.</p>\n<p>The test browser integration converts the URL into a request and passes control to Zope\u2019s publisher.\nLet\u2019s check that query strings are available for input processing::</p>\n<pre>&gt;&gt;&gt; import urllib\n&gt;&gt;&gt; qs = urllib.urlencode({'foo': 'boo, bar &amp; baz'})  # sic: the ampersand.\n&gt;&gt;&gt; _ = app['folder1'].addDTMLMethod('index_html', file='&lt;dtml-var foo&gt;')\n&gt;&gt;&gt; import transaction; transaction.commit()\n&gt;&gt;&gt; browser.open(app.absolute_url() + '/folder1?' + qs)\n&gt;&gt;&gt; browser.contents\n'boo, bar &amp; baz'\n</pre>\n<p>The test browser also works with iterators.\nLet\u2019s test that with a simple file implementation that uses an iterator.:</p>\n<pre>&gt;&gt;&gt; from plone.testing.tests import DummyFile\n&gt;&gt;&gt; app._setObject('file1', DummyFile('file1'))\n'file1'\n\n&gt;&gt;&gt; import transaction; transaction.commit()\n\n&gt;&gt;&gt; browser.open(app.absolute_url() + '/file1')\n&gt;&gt;&gt; 'The test browser also works with iterators' in browser.contents\nTrue\n</pre>\n<p>See the <tt>zope.testbrowser</tt> documentation for more information about how to use the browser client.</p>\n<p>On tear-down, the database is torn down.:</p>\n<pre>&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.testTearDown()\n&gt;&gt;&gt; zserver.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zserver.FUNCTIONAL_TESTING\nFalse\n\n&gt;&gt;&gt; 'request' in zserver.FUNCTIONAL_TESTING\nFalse\n\n&gt;&gt;&gt; with zserver.zopeApp() as app:\n...     'acl_users' in app.objectIds()\\\n...         and 'folder1' not in app.objectIds()\\\n...         and 'file1' not in app.objectIds()\nTrue\n</pre>\n<p>Let\u2019s tear down the layer::</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zserver.FunctionalTesting in ... seconds.\nTear down plone.testing.zserver.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n</pre>\n</div>\n<div id=\"id54\">\n<h4><a href=\"#id188\" rel=\"nofollow\">HTTP server</a></h4>\n<p>The <tt>ZSERVER_FIXTURE</tt> layer extends <tt>STARTUP</tt> to start a single-threaded Zope server in a separate thread.\nThis makes it possible to connect to the test instance using a web browser or a testing tool like Selenium or Windmill.</p>\n<p>The <tt>ZSERVER</tt> layer provides a <tt>FunctionalTesting</tt> layer that has <tt>ZSERVER_FIXTURE</tt> as its base.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zserver.ZSERVER_FIXTURE.__module__, zserver.ZSERVER_FIXTURE.__name__,)\n'plone.testing.zserver.ZServer'\n\n&gt;&gt;&gt; zserver.ZSERVER_FIXTURE.__bases__\n(&lt;Layer 'plone.testing.zserver.Startup'&gt;,)\n\n\n&gt;&gt;&gt; \"%s.%s\" % (zserver.ZSERVER.__module__, zserver.ZSERVER.__name__,)\n'plone.testing.zserver.ZServer:Functional'\n\n&gt;&gt;&gt; zserver.ZSERVER.__bases__\n(&lt;Layer 'plone.testing.zserver.ZServer'&gt;,)\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zserver.ZSERVER, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zserver.Startup in ... seconds.\nSet up plone.testing.zserver.ZServer in ... seconds.\nSet up plone.testing.zserver.ZServer:Functional in ... seconds.\n</pre>\n<p>After layer setup, the resources <tt>host</tt> and <tt>port</tt> are available, and indicate where Zope is running.:</p>\n<pre>&gt;&gt;&gt; host = zserver.ZSERVER['host']\n&gt;&gt;&gt; port = zserver.ZSERVER['port']\n</pre>\n<p>Let\u2019s now simulate a test.\nTest setup does nothing beyond what the base layers do.:</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP.testSetUp()\n&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.testSetUp()\n&gt;&gt;&gt; zserver.ZSERVER.testSetUp()\n</pre>\n<p>It is common in a test to use the Python API to change the state of the server (e.g.\ncreate some content or change a setting) and then use the HTTP protocol to look at the results.\nBear in mind that the server is running in a separate thread, with a separate security manager, so calls to <tt>zserver.login()</tt> and <tt>zserver.logout()</tt>, for instance, do not affect the server thread.:</p>\n<pre>&gt;&gt;&gt; app = zserver.ZSERVER['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; app.manage_addFolder('folder1')\n</pre>\n<p>Note that we need to commit the transaction before it will show up in the other thread.:</p>\n<pre>&gt;&gt;&gt; import transaction; transaction.commit()\n</pre>\n<p>We can now look for this new object through the server.:</p>\n<pre>&gt;&gt;&gt; app_url = app.absolute_url()\n&gt;&gt;&gt; app_url.split(':')[:-1]\n['http', '//localhost']\n\n&gt;&gt;&gt; import urllib2\n&gt;&gt;&gt; conn = urllib2.urlopen(app_url + '/folder1', timeout=5)\n&gt;&gt;&gt; conn.read().replace('\"', '').replace(\"'\", \"\")\n'&lt;Folder ...'\n&gt;&gt;&gt; conn.close()\n</pre>\n<p>The __repr__ of Zope objects is not stable anymore.</p>\n<p>Test tear-down does nothing beyond what the base layers do.:</p>\n<pre>&gt;&gt;&gt; zserver.ZSERVER.testTearDown()\n&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.testTearDown()\n&gt;&gt;&gt; zserver.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zserver.ZSERVER\nFalse\n\n&gt;&gt;&gt; 'request' in zserver.ZSERVER\nFalse\n\n&gt;&gt;&gt; with zserver.zopeApp() as app:\n...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\nTrue\n</pre>\n<p>When the server is torn down, the ZServer thread is stopped.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zserver.ZServer:Functional in ... seconds.\nTear down plone.testing.zserver.ZServer in ... seconds.\nTear down plone.testing.zserver.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n</pre>\n<p>We can expect one of these exceptions:\n- URLError: &lt;urlopen error [Errno \u2026] Connection refused&gt;\n- error: [Errno 104] Connection reset by peer</p>\n<blockquote>\n<pre>&gt;&gt;&gt; try:\n...     conn = urllib2.urlopen(app_url + '/folder1', timeout=5)\n... except Exception as exc:\n...     if 'Connection refused' not in str(exc) and 'Connection reset' not in str(exc):\n...         raise exc\n... else:\n...     print('urllib2.urlopen should have raised exception')\n</pre>\n</blockquote>\n</div>\n<div id=\"ftp-server\">\n<h4><a href=\"#id189\" rel=\"nofollow\">FTP server</a></h4>\n<p>The <tt>FTP_SERVER</tt> layer is identical similar to <tt>ZSERVER</tt>, except that it starts an FTP server instead of an HTTP server.\nThe fixture is contained in the <tt>FTP_SERVER_FIXTURE</tt> layer.</p>\n<blockquote>\n<strong>Warning:</strong> It is generally not safe to run the <tt>ZSERVER</tt> and <tt>FTP_SERVER</tt> layers concurrently, because they both start up the same <tt>asyncore</tt> loop.\nIf you need concurrent HTTP and FTP servers in a test, you can create your own layer by subclassing the <tt>ZServer</tt> layer class, and overriding the <tt>setUpServer()</tt> and <tt>tearDownServer()</tt> hooks to set up and close both servers.\nSee the code for an example.</blockquote>\n<p>The <tt>FTP_SERVER_FIXTURE</tt> layer is based on the <tt>STARTUP</tt> layer.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zserver.FTP_SERVER_FIXTURE.__module__, zserver.FTP_SERVER_FIXTURE.__name__,)\n'plone.testing.zserver.FTPServer'\n\n&gt;&gt;&gt; zserver.FTP_SERVER_FIXTURE.__bases__\n(&lt;Layer 'plone.testing.zserver.Startup'&gt;,)\n</pre>\n<p>The <tt>FTP_SERVER</tt> layer is based on <tt>FTP_SERVER_FIXTURE</tt>, using the <tt>FunctionalTesting</tt> layer class.:</p>\n<pre>&gt;&gt;&gt; \"%s.%s\" % (zserver.FTP_SERVER.__module__, zserver.FTP_SERVER.__name__,)\n'plone.testing.zserver.FTPServer:Functional'\n\n&gt;&gt;&gt; zserver.FTP_SERVER.__bases__\n(&lt;Layer 'plone.testing.zserver.FTPServer'&gt;,)\n\n&gt;&gt;&gt; options = runner.get_options([], [])\n&gt;&gt;&gt; setupLayers = {}\n&gt;&gt;&gt; runner.setup_layer(options, zserver.FTP_SERVER, setupLayers)\nSet up plone.testing.zca.LayerCleanup in ... seconds.\nSet up plone.testing.zserver.Startup in ... seconds.\nSet up plone.testing.zserver.FTPServer in ... seconds.\nSet up plone.testing.zserver.FTPServer:Functional in ... seconds.\n</pre>\n<p>After layer setup, the resources <tt>host</tt> and <tt>port</tt> are available, and indicate where Zope is running.:</p>\n<pre>&gt;&gt;&gt; host = zserver.FTP_SERVER['host']\n&gt;&gt;&gt; port = zserver.FTP_SERVER['port']\n</pre>\n<p>Let\u2019s now simulate a test.\nTest setup does nothing beyond what the base layers do.:</p>\n<pre>&gt;&gt;&gt; zserver.STARTUP.testSetUp()\n&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.testSetUp()\n&gt;&gt;&gt; zserver.FTP_SERVER.testSetUp()\n</pre>\n<p>As with <tt>ZSERVER</tt>, we will set up some content for the test and then access it over the FTP port.:</p>\n<pre>&gt;&gt;&gt; app = zserver.FTP_SERVER['app'] # would normally be self.layer['app']\n&gt;&gt;&gt; app.manage_addFolder('folder1')\n</pre>\n<p>We\u2019ll also create a user in the root user folder to make FTP access easier.:</p>\n<pre>&gt;&gt;&gt; ignore = app['acl_users'].userFolderAddUser('admin', 'secret', ['Manager'], ())\n</pre>\n<p>Note that we need to commit the transaction before it will show up in the other thread.:</p>\n<pre>&gt;&gt;&gt; import transaction; transaction.commit()\n</pre>\n<p>We can now look for this new object through the server.:</p>\n<pre>&gt;&gt;&gt; app_path = app.absolute_url_path()\n\n&gt;&gt;&gt; import ftplib\n&gt;&gt;&gt; ftpClient = ftplib.FTP()\n&gt;&gt;&gt; ftpClient.connect(host, port, timeout=5)\n'220 ... FTP server (...) ready.'\n\n&gt;&gt;&gt; ftpClient.login('admin', 'secret')\n'230 Login successful.'\n\n&gt;&gt;&gt; ftpClient.cwd(app_path)\n'250 CWD command successful.'\n\n&gt;&gt;&gt; ftpClient.retrlines('LIST')\ndrwxrwx---   1 Zope     Zope            0 ... .\n...--w--w----   1 Zope     Zope            0 ... acl_users\ndrwxrwx---   1 Zope     Zope            0 ... folder1\n'226 Transfer complete'\n\n&gt;&gt;&gt; ftpClient.quit()\n'221 Goodbye.'\n</pre>\n<p>Test tear-down does nothing beyond what the base layers do.:</p>\n<pre>&gt;&gt;&gt; zserver.FTP_SERVER.testTearDown()\n&gt;&gt;&gt; zserver.FUNCTIONAL_TESTING.testTearDown()\n&gt;&gt;&gt; zserver.STARTUP.testTearDown()\n\n&gt;&gt;&gt; 'app' in zserver.ZSERVER\nFalse\n\n&gt;&gt;&gt; 'request' in zserver.ZSERVER\nFalse\n\n&gt;&gt;&gt; with zserver.zopeApp() as app:\n...     'acl_users' in app.objectIds() and 'folder1' not in app.objectIds()\nTrue\n</pre>\n<p>When the server is torn down, the FTP thread is stopped.:</p>\n<pre>&gt;&gt;&gt; runner.tear_down_unneeded(options, [], setupLayers, [])\nTear down plone.testing.zserver.FTPServer:Functional in ... seconds.\nTear down plone.testing.zserver.FTPServer in ... seconds.\nTear down plone.testing.zserver.Startup in ... seconds.\nTear down plone.testing.zca.LayerCleanup in ... seconds.\n\n&gt;&gt;&gt; ftpClient.connect(host, port, timeout=5)\nTraceback (most recent call last):\n...\nerror: [Errno ...] Connection refused\n</pre>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7063847, "releases": {"1.0a1": [{"comment_text": "", "digests": {"md5": "d643f26113388eef9bf04df9efea4343", "sha256": "8433d0627b678e120863c68d1ea11401beabc20efb4b2a90b2b6b2bc80265a71"}, "downloads": -1, "filename": "plone.testing-1.0a1.zip", "has_sig": false, "md5_digest": "d643f26113388eef9bf04df9efea4343", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 145107, "upload_time": "2010-08-01T16:54:55", "upload_time_iso_8601": "2010-08-01T16:54:55.670941Z", "url": "https://files.pythonhosted.org/packages/2d/43/6b4793ab7b31abc57debba094efed44d70f96acffdb4c86d99f48f5b4882/plone.testing-1.0a1.zip", "yanked": false}], "1.0a2": [{"comment_text": "", "digests": {"md5": "8df4d01b799411187f97a6a607d9343d", "sha256": "90398e9d79ea789cf431c38d55c482d8d3f7e2bc79b887d7933c027be313579f"}, "downloads": -1, "filename": "plone.testing-1.0a2.zip", "has_sig": false, "md5_digest": "8df4d01b799411187f97a6a607d9343d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 146208, "upload_time": "2010-09-05T20:52:29", "upload_time_iso_8601": "2010-09-05T20:52:29.931020Z", "url": "https://files.pythonhosted.org/packages/ec/eb/6eabe3c456ebacfb00dc64fdcc5895e774a31e3c21d799c6bab4ca1928ba/plone.testing-1.0a2.zip", "yanked": false}], "3.0a1": [{"comment_text": "", "digests": {"md5": "1bb0bf315b6a8f731e513c8def2797e3", "sha256": "b09f1b8a1e9cd0c9a0b1d45c1bdce17ebc9536fdef45fe6d60502d59505c4add"}, "downloads": -1, "filename": "plone.testing-3.0a1.tar.gz", "has_sig": false, "md5_digest": "1bb0bf315b6a8f731e513c8def2797e3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 136889, "upload_time": "2010-12-14T15:08:49", "upload_time_iso_8601": "2010-12-14T15:08:49.561140Z", "url": "https://files.pythonhosted.org/packages/a1/12/80f1ec431f8c3d4226b6dff0d073dad317c10d521a187ff72abe0fd7129d/plone.testing-3.0a1.tar.gz", "yanked": false}], "3.0a2": [{"comment_text": "", "digests": {"md5": "a6c8fe9fbde52774e9a0e4710a940b58", "sha256": "339b9513a1b093f33fc85178900772821ed2f8b41d5fd9b238a20badd854e6f6"}, "downloads": -1, "filename": "plone.testing-3.0a2.tar.gz", "has_sig": false, "md5_digest": "a6c8fe9fbde52774e9a0e4710a940b58", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 139735, "upload_time": "2011-05-24T16:05:17", "upload_time_iso_8601": "2011-05-24T16:05:17.986674Z", "url": "https://files.pythonhosted.org/packages/ce/62/853a79bb2860fdb1bdd6ee7afba82fa47c62f64bc93245b4fbf52ce9035c/plone.testing-3.0a2.tar.gz", "yanked": false}], "4.0": [{"comment_text": "", "digests": {"md5": "50dd6a70da2f284b3a070a7d2b29be7e", "sha256": "bf029e42dcbbc135f16c39d00ed4f10c71ac89de6e56f779a7e0ec8895ff3434"}, "downloads": -1, "filename": "plone.testing-4.0.zip", "has_sig": false, "md5_digest": "50dd6a70da2f284b3a070a7d2b29be7e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 157291, "upload_time": "2011-05-13T17:31:43", "upload_time_iso_8601": "2011-05-13T17:31:43.083378Z", "url": "https://files.pythonhosted.org/packages/10/7c/7b08b19dbd2116e84efbb24b7b8ecfaa61b9b50f03135ebc0a8b4f0038f7/plone.testing-4.0.zip", "yanked": false}], "4.0.1": [{"comment_text": "", "digests": {"md5": "e1da30369be13e8095848462dbb10c6e", "sha256": "a6862a67bfe0bc2746d074a6d1b635aba7c55b4abd08715dca99bee0feb2fefe"}, "downloads": -1, "filename": "plone.testing-4.0.1.zip", "has_sig": false, "md5_digest": "e1da30369be13e8095848462dbb10c6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 152551, "upload_time": "2011-05-20T18:56:19", "upload_time_iso_8601": "2011-05-20T18:56:19.478269Z", "url": "https://files.pythonhosted.org/packages/aa/7c/343a9b72fa66ff9892d42b9aa2cee585628e454ad54dfe75102621afb2e9/plone.testing-4.0.1.zip", "yanked": false}], "4.0.10": [{"comment_text": "", "digests": {"md5": "597202d862461bf766410c159b6e343a", "sha256": "5e81dfac0adc905222fa55309094e557663c36dc805e626948b58e888a1e02ef"}, "downloads": -1, "filename": "plone.testing-4.0.10.zip", "has_sig": false, "md5_digest": "597202d862461bf766410c159b6e343a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 152364, "upload_time": "2014-02-11T15:01:43", "upload_time_iso_8601": "2014-02-11T15:01:43.940583Z", "url": "https://files.pythonhosted.org/packages/99/a9/222c57f8edcef7301339de348bcf9ac9fcfb853236d20e465510337218e2/plone.testing-4.0.10.zip", "yanked": false}], "4.0.11": [{"comment_text": "", "digests": {"md5": "9e1018c18f5dc6593db12939966aab8d", "sha256": "25682c5275783895185167f983f7452ec608af9739ac203abd035e8cd7939655"}, "downloads": -1, "filename": "plone.testing-4.0.11.zip", "has_sig": false, "md5_digest": "9e1018c18f5dc6593db12939966aab8d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 152404, "upload_time": "2014-02-22T10:36:14", "upload_time_iso_8601": "2014-02-22T10:36:14.849641Z", "url": "https://files.pythonhosted.org/packages/95/82/f6c383fbd5141e87b6ce37f9c8b5ec9bc4a196e2e5e4466b8ac53ea2d871/plone.testing-4.0.11.zip", "yanked": false}], "4.0.12": [{"comment_text": "", "digests": {"md5": "683cac9446e231ded97a4ff91792b05d", "sha256": "47bc6782c2943460628e6d29484b93b0029d39e40cf5e8431a31213e53f15854"}, "downloads": -1, "filename": "plone.testing-4.0.12.zip", "has_sig": false, "md5_digest": "683cac9446e231ded97a4ff91792b05d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 155252, "upload_time": "2014-09-07T15:59:03", "upload_time_iso_8601": "2014-09-07T15:59:03.913020Z", "url": "https://files.pythonhosted.org/packages/d5/40/6d0e4825c1f4d2838bf639cf14be24250f055cbafd5eb59d1b0e0d966c33/plone.testing-4.0.12.zip", "yanked": false}], "4.0.13": [{"comment_text": "", "digests": {"md5": "af61d63ad20749d394f0d87d998369fd", "sha256": "d72c5ec04192ebe9f48da298651cbdc7621a4a3dca3cfc06753eb156fd2830eb"}, "downloads": -1, "filename": "plone.testing-4.0.13.zip", "has_sig": false, "md5_digest": "af61d63ad20749d394f0d87d998369fd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 152842, "upload_time": "2015-03-13T15:06:52", "upload_time_iso_8601": "2015-03-13T15:06:52.183434Z", "url": "https://files.pythonhosted.org/packages/c3/cd/d5e20e2065cefa5d3b89676d02a9a0a1ced7d39da052e3c72423908a5105/plone.testing-4.0.13.zip", "yanked": false}], "4.0.14": [{"comment_text": "", "digests": {"md5": "eaa94e8d27da10c2adf0238bf5e7ebbc", "sha256": "03b438a27eb424a672056bc0daf9f10ccf85adc56eb10deaa499d1d00ad80906"}, "downloads": -1, "filename": "plone.testing-4.0.14.tar.gz", "has_sig": false, "md5_digest": "eaa94e8d27da10c2adf0238bf5e7ebbc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 141104, "upload_time": "2015-07-29T21:47:18", "upload_time_iso_8601": "2015-07-29T21:47:18.364117Z", "url": "https://files.pythonhosted.org/packages/b7/02/d13af0e8ef4ec708a9a10f7e6313322ddbe11cb8bd192ee4a5634f2c0776/plone.testing-4.0.14.tar.gz", "yanked": false}], "4.0.15": [{"comment_text": "", "digests": {"md5": "e5efd839d33cd07e0370f5229a30a571", "sha256": "9010d12b79f0237f6c030f9e99f667f10e45cd86cb0ddffdd81e1db016d2c387"}, "downloads": -1, "filename": "plone.testing-4.0.15.tar.gz", "has_sig": false, "md5_digest": "e5efd839d33cd07e0370f5229a30a571", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 141456, "upload_time": "2015-08-14T15:42:27", "upload_time_iso_8601": "2015-08-14T15:42:27.905032Z", "url": "https://files.pythonhosted.org/packages/d5/5a/8014387d6b03d4af08f8adaa7149db5de3bb1f84a9d7e451c60323b1aea9/plone.testing-4.0.15.tar.gz", "yanked": false}], "4.0.2": [{"comment_text": "", "digests": {"md5": "7f61d141451c1135ac348aece1547732", "sha256": "330a36c0c713f7dd3d61be35f2e85616e30870558531166428032f3a87a03b26"}, "downloads": -1, "filename": "plone.testing-4.0.2.tar.gz", "has_sig": false, "md5_digest": "7f61d141451c1135ac348aece1547732", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 139948, "upload_time": "2011-09-01T03:45:00", "upload_time_iso_8601": "2011-09-01T03:45:00.426114Z", "url": "https://files.pythonhosted.org/packages/29/6a/b3536352676fc5dd695a1681190e96d956e5f5a79349839262407d5518e6/plone.testing-4.0.2.tar.gz", "yanked": false}], "4.0.3": [{"comment_text": "", "digests": {"md5": "33a08d9371b6eca83945b9ba90616649", "sha256": "48b89c9a3c79242b68a0174fdff0eb7298b09b262454995614965ad5c1befc6c"}, "downloads": -1, "filename": "plone.testing-4.0.3.tar.gz", "has_sig": false, "md5_digest": "33a08d9371b6eca83945b9ba90616649", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 139994, "upload_time": "2011-11-25T02:42:19", "upload_time_iso_8601": "2011-11-25T02:42:19.954702Z", "url": "https://files.pythonhosted.org/packages/80/8f/7dd085e947b297525e82cada2c8c2a9917939f4afaab76912c3d3106c7df/plone.testing-4.0.3.tar.gz", "yanked": false}], "4.0.4": [{"comment_text": "", "digests": {"md5": "896074b9f11cf89cf2ff7384b5309d20", "sha256": "6ae3563ab5bf1fe63c872346ffa68851e77cd1dbe6093dfd8c48db42d2cc8d8e"}, "downloads": -1, "filename": "plone.testing-4.0.4.zip", "has_sig": false, "md5_digest": "896074b9f11cf89cf2ff7384b5309d20", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 153499, "upload_time": "2012-08-04T20:52:23", "upload_time_iso_8601": "2012-08-04T20:52:23.838896Z", "url": "https://files.pythonhosted.org/packages/a7/7d/7c2322d72da1102e022a6b810367143b69ac1a7b60982b0915e224fccc48/plone.testing-4.0.4.zip", "yanked": false}], "4.0.5": [{"comment_text": "", "digests": {"md5": "d0887d7c9f183cab1ac38f5603a9de82", "sha256": "1993e997c47e0d880a8e1d35ba7da6cc02775c861b395fb800e1ee364c38d477"}, "downloads": -1, "filename": "plone.testing-4.0.5.zip", "has_sig": false, "md5_digest": "d0887d7c9f183cab1ac38f5603a9de82", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 105113, "upload_time": "2012-10-15T15:50:14", "upload_time_iso_8601": "2012-10-15T15:50:14.826805Z", "url": "https://files.pythonhosted.org/packages/e9/9a/24d5d783df1bfc3926b21ea2e7e3b45241db500e83456f124bd596729235/plone.testing-4.0.5.zip", "yanked": false}], "4.0.6": [{"comment_text": "", "digests": {"md5": "bcea99782870234e5495879fa8a912f8", "sha256": "7fbdb83289dc3d53d58b610793ed0066bbe9e66c4ac22d19947ee8532d11618b"}, "downloads": -1, "filename": "plone.testing-4.0.6.zip", "has_sig": false, "md5_digest": "bcea99782870234e5495879fa8a912f8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 151535, "upload_time": "2012-10-15T16:30:54", "upload_time_iso_8601": "2012-10-15T16:30:54.810918Z", "url": "https://files.pythonhosted.org/packages/79/c8/683d0f925b3e6ccd398eb5dda1fe3f5a2a1b737485d119d9ba1b5ccb41a2/plone.testing-4.0.6.zip", "yanked": false}], "4.0.7": [{"comment_text": "", "digests": {"md5": "fa40f6d3e3e254409c486c1c2c3e8804", "sha256": "cc7a51b51b5bc038cdc07bb29d68a7d4080049ce35e65709df02666835d75ee9"}, "downloads": -1, "filename": "plone.testing-4.0.7.zip", "has_sig": false, "md5_digest": "fa40f6d3e3e254409c486c1c2c3e8804", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 154129, "upload_time": "2012-12-10T06:03:28", "upload_time_iso_8601": "2012-12-10T06:03:28.367666Z", "url": "https://files.pythonhosted.org/packages/a1/9b/1971604cd00c59afa514d98531cb84ed02b6a449141b3c3e73607ce74d30/plone.testing-4.0.7.zip", "yanked": false}], "4.0.8": [{"comment_text": "", "digests": {"md5": "a49b0c9899466ae6aeb4ae97d8a0a33a", "sha256": "fc37e99b8b14083b516b32ca3b28a49ab1d9cbb907213f83551811e3c6e6ae39"}, "downloads": -1, "filename": "plone.testing-4.0.8.zip", "has_sig": false, "md5_digest": "a49b0c9899466ae6aeb4ae97d8a0a33a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 154572, "upload_time": "2013-03-05T19:13:24", "upload_time_iso_8601": "2013-03-05T19:13:24.440223Z", "url": "https://files.pythonhosted.org/packages/d4/bf/2ac9a6e9f3537e6dd3d7c1ec5467eae9dbee6ab8f576654044e3d28d842b/plone.testing-4.0.8.zip", "yanked": false}], "4.0.9": [{"comment_text": "", "digests": {"md5": "3819a4cdcd410a4e14f9d458ed5f5a74", "sha256": "7f4cf67005f57cacdf771d94a34f0a9e013a0f76477908cf5bc644ca84d1b787"}, "downloads": -1, "filename": "plone.testing-4.0.9.zip", "has_sig": false, "md5_digest": "3819a4cdcd410a4e14f9d458ed5f5a74", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 154685, "upload_time": "2014-01-28T13:46:49", "upload_time_iso_8601": "2014-01-28T13:46:49.811799Z", "url": "https://files.pythonhosted.org/packages/c5/8e/295ef01a538e69d831a88d5e011015d5a5bfd33424690a7324c5217d6b58/plone.testing-4.0.9.zip", "yanked": false}], "4.0a3": [{"comment_text": "", "digests": {"md5": "cadab7844ba420d996c47baea03a3b13", "sha256": "ac0764520741e8e61c9ab7eacbbda41d1df86de8f60ace624a20015805fc5f4c"}, "downloads": -1, "filename": "plone.testing-4.0a3.tar.gz", "has_sig": false, "md5_digest": "cadab7844ba420d996c47baea03a3b13", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 136373, "upload_time": "2010-12-14T15:00:05", "upload_time_iso_8601": "2010-12-14T15:00:05.492304Z", "url": "https://files.pythonhosted.org/packages/05/1f/cb524d5d7e2ce48c5814e099d607af14357a8fa7f638a7f97b9afeb281a1/plone.testing-4.0a3.tar.gz", "yanked": false}], "4.0a4": [{"comment_text": "", "digests": {"md5": "9d64f31742d8f6ab72830b28447e97b6", "sha256": "9eb33ca7fb97b779e75c369b620d444cdd3a1bdcdc355e846a1f8d0ca8d10603"}, "downloads": -1, "filename": "plone.testing-4.0a4.zip", "has_sig": false, "md5_digest": "9d64f31742d8f6ab72830b28447e97b6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148435, "upload_time": "2011-01-11T22:30:36", "upload_time_iso_8601": "2011-01-11T22:30:36.396908Z", "url": "https://files.pythonhosted.org/packages/eb/7a/f5d9e389ce0b23ff4d5de3b3dd652def93be085b3a3b425ab6ff31c7b296/plone.testing-4.0a4.zip", "yanked": false}], "4.0a5": [{"comment_text": "", "digests": {"md5": "4d2ae89dba97f2c776b33e968414a8e3", "sha256": "541ab6f60214f53ff6413d22b6a8239bfcacbd45d7ddd9de369d44749320ebec"}, "downloads": -1, "filename": "plone.testing-4.0a5.zip", "has_sig": false, "md5_digest": "4d2ae89dba97f2c776b33e968414a8e3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 157489, "upload_time": "2011-03-02T17:09:20", "upload_time_iso_8601": "2011-03-02T17:09:20.523063Z", "url": "https://files.pythonhosted.org/packages/75/d8/1860f7b3467741304bda0ce7eea5dce37bac5ff3eea00238811c980b5846/plone.testing-4.0a5.zip", "yanked": false}], "4.0a6": [{"comment_text": "", "digests": {"md5": "2bbb74f6a47bee22c8935360c9de9165", "sha256": "62fcca03d80969259bb018758f13f975c40e04c6a0e6dd5d4cad21bfce754465"}, "downloads": -1, "filename": "plone.testing-4.0a6.zip", "has_sig": false, "md5_digest": "2bbb74f6a47bee22c8935360c9de9165", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 157120, "upload_time": "2011-04-07T01:33:11", "upload_time_iso_8601": "2011-04-07T01:33:11.489930Z", "url": "https://files.pythonhosted.org/packages/62/93/d8bc089dbed92cec59061506d5643974550c9b30092f6dcb28a8df489630/plone.testing-4.0a6.zip", "yanked": false}], "4.1.0": [{"comment_text": "", "digests": {"md5": "2b16d84ab380a7b6adf7b4c1b47340be", "sha256": "58527237870126e96dcab9119c1b7892f88cd1511d7f71b86080aa0244cb19ec"}, "downloads": -1, "filename": "plone.testing-4.1.0.tar.gz", "has_sig": false, "md5_digest": "2b16d84ab380a7b6adf7b4c1b47340be", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148055, "upload_time": "2016-01-08T14:17:06", "upload_time_iso_8601": "2016-01-08T14:17:06.390618Z", "url": "https://files.pythonhosted.org/packages/ba/48/ea78e2ddffb1f1645f84854f5d6d9280c7a0d72cc8ba8d39d83c8d0fa287/plone.testing-4.1.0.tar.gz", "yanked": false}], "4.1.1": [{"comment_text": "", "digests": {"md5": "c703222b6183a8a4ce7e8ca0eef42a93", "sha256": "49973b5797b95425ba6c8940599418501a68d7a1434c1dd9b64cc5ab4b7a3c58"}, "downloads": -1, "filename": "plone.testing-4.1.1.tar.gz", "has_sig": false, "md5_digest": "c703222b6183a8a4ce7e8ca0eef42a93", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148237, "upload_time": "2016-02-21T17:46:29", "upload_time_iso_8601": "2016-02-21T17:46:29.485788Z", "url": "https://files.pythonhosted.org/packages/b3/65/ed33fae6af2bbe1421bbeebd411a3f35bd5e157fb6d1359c1ef10f773bb0/plone.testing-4.1.1.tar.gz", "yanked": false}], "4.1.2": [{"comment_text": "", "digests": {"md5": "7ec7eb8873aab562f4c928746833c768", "sha256": "5a8e60a150d3494e88e608c7cd11c7da5676e6595b7fd29346af5bf0b098b04e"}, "downloads": -1, "filename": "plone.testing-4.1.2.tar.gz", "has_sig": false, "md5_digest": "7ec7eb8873aab562f4c928746833c768", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148805, "upload_time": "2017-03-05T11:45:24", "upload_time_iso_8601": "2017-03-05T11:45:24.522354Z", "url": "https://files.pythonhosted.org/packages/ed/d3/3c2d0dbb4482e3465348375e9ea15b20a9411993f8e47b1b136d0b26025c/plone.testing-4.1.2.tar.gz", "yanked": false}], "4.1.3": [{"comment_text": "", "digests": {"md5": "7254eeb5af8568ec208b8b86e9d7cc04", "sha256": "5776e6ff053d172fbb93dc416ed52e4d45debc622ec0e767c571a65942c13b43"}, "downloads": -1, "filename": "plone.testing-4.1.3.tar.gz", "has_sig": false, "md5_digest": "7254eeb5af8568ec208b8b86e9d7cc04", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148707, "upload_time": "2018-10-05T15:16:39", "upload_time_iso_8601": "2018-10-05T15:16:39.631545Z", "url": "https://files.pythonhosted.org/packages/65/78/32de879d6dc6fa856ab7b6016ddf84759598d67a73ab9ca6d05d06767ad9/plone.testing-4.1.3.tar.gz", "yanked": false}], "4.2.0": [{"comment_text": "", "digests": {"md5": "b3308b2b832a3acfd4d39f841ff19710", "sha256": "2077726c243d3ea2bb84454bf8dfd0924e75e1137c7545ede7309c39a2104cc8"}, "downloads": -1, "filename": "plone.testing-4.2.0.tar.gz", "has_sig": false, "md5_digest": "b3308b2b832a3acfd4d39f841ff19710", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148722, "upload_time": "2016-02-18T09:32:40", "upload_time_iso_8601": "2016-02-18T09:32:40.291458Z", "url": "https://files.pythonhosted.org/packages/1a/6e/f14f8e88c447a814ffd0ccb7ccca05e42ed8db11c57c8aa6f24c1325c5e6/plone.testing-4.2.0.tar.gz", "yanked": false}], "4.2.1": [{"comment_text": "", "digests": {"md5": "f5015a1bbcb368d70cab7e18b7deca5a", "sha256": "5306a97a575ebcbf4c693e01462cd478c2c12171f5cb38419497fbc7d02d3641"}, "downloads": -1, "filename": "plone.testing-4.2.1.tar.gz", "has_sig": false, "md5_digest": "f5015a1bbcb368d70cab7e18b7deca5a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148567, "upload_time": "2016-02-19T09:29:07", "upload_time_iso_8601": "2016-02-19T09:29:07.379293Z", "url": "https://files.pythonhosted.org/packages/df/2c/8a5f2b7ca650b5bc3a85490890b8a2f722d8356a66f9d29c513707adac31/plone.testing-4.2.1.tar.gz", "yanked": false}], "4.3.0": [{"comment_text": "", "digests": {"md5": "3862b4e12625360eef171f0dec1cd822", "sha256": "30e7848bbfcfacee1072e33c51cc754b5c4e2d0aaa57235d3c6be317285d2a4d"}, "downloads": -1, "filename": "plone.testing-4.3.0.tar.gz", "has_sig": false, "md5_digest": "3862b4e12625360eef171f0dec1cd822", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149064, "upload_time": "2017-03-05T12:13:30", "upload_time_iso_8601": "2017-03-05T12:13:30.390982Z", "url": "https://files.pythonhosted.org/packages/30/9e/602ecd25767abe8dcb3cecd06a83bb759fe132c1237a160d4e957cea55af/plone.testing-4.3.0.tar.gz", "yanked": false}], "4.3.1": [{"comment_text": "", "digests": {"md5": "c5cf3fce1eab6d1daf136b8dffb544e5", "sha256": "bf3de1ad8df0e8295673cfc6092672c7d55d51f2ba07c604759b4d029df1b07c"}, "downloads": -1, "filename": "plone.testing-4.3.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "c5cf3fce1eab6d1daf136b8dffb544e5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 152991, "upload_time": "2017-05-29T13:45:10", "upload_time_iso_8601": "2017-05-29T13:45:10.661679Z", "url": "https://files.pythonhosted.org/packages/1f/ce/cb304aecd0c47c50f9ab18589d64c7f7bb9834241f151f7605e7c8b6fd05/plone.testing-4.3.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0524db1832bddf0978f763df151ccd9e", "sha256": "606251af541ea0f439df4bb38089aa7b6a9a2c1836ae19bec1b553f37704f3a0"}, "downloads": -1, "filename": "plone.testing-4.3.1.tar.gz", "has_sig": false, "md5_digest": "0524db1832bddf0978f763df151ccd9e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149286, "upload_time": "2017-05-29T13:45:12", "upload_time_iso_8601": "2017-05-29T13:45:12.573849Z", "url": "https://files.pythonhosted.org/packages/a8/55/f99e8a24ac3e451a09fab6f6dd4558dd2468a5ce87cbe7503a9c2e84bd34/plone.testing-4.3.1.tar.gz", "yanked": false}], "4.3.2": [{"comment_text": "", "digests": {"md5": "63704257b98dae782d534867424f0b85", "sha256": "6cab297c6184f536d01fa485630ae332faaa303f51a2db181a6c7c23fbcffbe0"}, "downloads": -1, "filename": "plone.testing-4.3.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "63704257b98dae782d534867424f0b85", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 110189, "upload_time": "2018-10-05T15:15:39", "upload_time_iso_8601": "2018-10-05T15:15:39.692463Z", "url": "https://files.pythonhosted.org/packages/a7/d8/2c7a3b71373192b66beb92a0b2597d10c9688434d24298b61b0918335cdc/plone.testing-4.3.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "06669438243143ac9d84d83f31cc4eba", "sha256": "6d3d77a22aa26466f8588c577a8988af316b5a6d1d3509a4135d3a0205086be1"}, "downloads": -1, "filename": "plone.testing-4.3.2.tar.gz", "has_sig": false, "md5_digest": "06669438243143ac9d84d83f31cc4eba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149213, "upload_time": "2018-10-05T15:15:41", "upload_time_iso_8601": "2018-10-05T15:15:41.710331Z", "url": "https://files.pythonhosted.org/packages/af/63/15db808ae75a6d3a61836e0aedc710a727ff07f7db7de7f1db82153aeb5e/plone.testing-4.3.2.tar.gz", "yanked": false}], "4.3.3": [{"comment_text": "", "digests": {"md5": "3c6a4cd5c45c80c5ac37b53f92584331", "sha256": "efbf50fee6c62e03cef1cc031c4822bc3f8bee83c5b148011aa3e704f5c808e8"}, "downloads": -1, "filename": "plone.testing-4.3.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "3c6a4cd5c45c80c5ac37b53f92584331", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 110420, "upload_time": "2019-03-27T11:18:05", "upload_time_iso_8601": "2019-03-27T11:18:05.748840Z", "url": "https://files.pythonhosted.org/packages/68/cb/59859595e1b0c60fb38209ee7f17bab95f85813488c3425649159fd36cd8/plone.testing-4.3.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ae683d902d8494677c5e9356d6b65e4c", "sha256": "a1526f5ce7492797cab9f5d6fb71d877c3b93e2df59fde5a36c8ba22897710e5"}, "downloads": -1, "filename": "plone.testing-4.3.3.tar.gz", "has_sig": false, "md5_digest": "ae683d902d8494677c5e9356d6b65e4c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149722, "upload_time": "2019-03-27T11:18:08", "upload_time_iso_8601": "2019-03-27T11:18:08.757047Z", "url": "https://files.pythonhosted.org/packages/53/52/7df045b572fd038bdd2a56f43278ea770da408769dd4dbdc4ea7276434b6/plone.testing-4.3.3.tar.gz", "yanked": false}], "5.0.0": [{"comment_text": "", "digests": {"md5": "ce470c9f607ecbcbc2b0f076c59ca6a4", "sha256": "74da816c3ee1e3902a28ee3e5a176bc8a49a46c8f639eec6cf297df4ddcff3a5"}, "downloads": -1, "filename": "plone.testing-5.0.0.tar.gz", "has_sig": false, "md5_digest": "ce470c9f607ecbcbc2b0f076c59ca6a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148968, "upload_time": "2016-02-19T09:32:34", "upload_time_iso_8601": "2016-02-19T09:32:34.002322Z", "url": "https://files.pythonhosted.org/packages/2a/18/aa353edcd7a0be45b5f0abd4aec06f7f4d826450919843c5562c83b6b37c/plone.testing-5.0.0.tar.gz", "yanked": false}], "5.1": [{"comment_text": "", "digests": {"md5": "a2fbad13ad57bc0f8d7b65ea188702b6", "sha256": "51f7f36c603b52e1c0ebb31013ccc5d90db8846a6e8b79f22e0afaef1ab27480"}, "downloads": -1, "filename": "plone.testing-5.1.tar.gz", "has_sig": false, "md5_digest": "a2fbad13ad57bc0f8d7b65ea188702b6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148880, "upload_time": "2017-04-13T14:31:47", "upload_time_iso_8601": "2017-04-13T14:31:47.549964Z", "url": "https://files.pythonhosted.org/packages/bd/bd/31c460049587d2e9a1e337bde009199087609125bb52916392b73b262aa7/plone.testing-5.1.tar.gz", "yanked": false}], "5.1.1": [{"comment_text": "", "digests": {"md5": "a6339c6efd55391803588f1446dad650", "sha256": "2ca558a910b93355b760535b233518be3a06c58e46160487bf802b6f7cb1e511"}, "downloads": -1, "filename": "plone.testing-5.1.1.tar.gz", "has_sig": false, "md5_digest": "a6339c6efd55391803588f1446dad650", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149206, "upload_time": "2017-04-19T13:43:06", "upload_time_iso_8601": "2017-04-19T13:43:06.938746Z", "url": "https://files.pythonhosted.org/packages/15/a2/bf593fbfdbe6c3e2e98f2fe703bc5ab769409d85a0740a3a475671cd98fd/plone.testing-5.1.1.tar.gz", "yanked": false}], "6.0.0": [{"comment_text": "", "digests": {"md5": "b621509a7f24d43756845c9c44505c8f", "sha256": "57050a3550056f562ed554b55cc1e3937405b19c2b490491e80344668a97b470"}, "downloads": -1, "filename": "plone.testing-6.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b621509a7f24d43756845c9c44505c8f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 150838, "upload_time": "2018-02-05T09:44:26", "upload_time_iso_8601": "2018-02-05T09:44:26.683405Z", "url": "https://files.pythonhosted.org/packages/33/b1/c503f107e63b4e4a79870693f9be1a7667e540b14c5a248197fefd2a76dd/plone.testing-6.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9cce984ef1b47ddb59e2259563369218", "sha256": "8aa7c45237b883ea1d1c28fb465322f69310b084b9f9b6a79af64401b649dc4c"}, "downloads": -1, "filename": "plone.testing-6.0.0.tar.gz", "has_sig": false, "md5_digest": "9cce984ef1b47ddb59e2259563369218", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 146997, "upload_time": "2018-02-05T09:44:28", "upload_time_iso_8601": "2018-02-05T09:44:28.990483Z", "url": "https://files.pythonhosted.org/packages/a6/d6/678e4b6d4a72f914f71339d6f28add407a9303e52f98926b8039369feadf/plone.testing-6.0.0.tar.gz", "yanked": false}], "6.1.0": [{"comment_text": "", "digests": {"md5": "e32388c3e9a338e75e1c628eb057c739", "sha256": "24dac595154582ed6d2e8c86b4711c5cfcfc64c1a9805310c3343a7c5286de3a"}, "downloads": -1, "filename": "plone.testing-6.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "e32388c3e9a338e75e1c628eb057c739", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 108549, "upload_time": "2018-10-05T15:13:15", "upload_time_iso_8601": "2018-10-05T15:13:15.335621Z", "url": "https://files.pythonhosted.org/packages/86/49/d00ac4fa3afd9262ca2b93e0eba66ad11dd961c7b5740882a9863a02ea95/plone.testing-6.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fb5c2a970edf514284f2dbe93f3df80d", "sha256": "83108c75e4bb6827b6a77297608aff81061974ce55c283d94f0d1d05ba765898"}, "downloads": -1, "filename": "plone.testing-6.1.0.tar.gz", "has_sig": false, "md5_digest": "fb5c2a970edf514284f2dbe93f3df80d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148093, "upload_time": "2018-10-05T15:13:18", "upload_time_iso_8601": "2018-10-05T15:13:18.409113Z", "url": "https://files.pythonhosted.org/packages/d4/4a/39b7f6a1320b30cc056b555064ceed8045bbfffa7940b9dfc786fb4e9489/plone.testing-6.1.0.tar.gz", "yanked": false}], "7.0.0": [{"comment_text": "", "digests": {"md5": "904da15c022d420a399b19d6851e284d", "sha256": "8b7b0e3fc2f951a6256581a0e9e812c001ea5c45d26e65d53024ec8a5caec066"}, "downloads": -1, "filename": "plone.testing-7.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "904da15c022d420a399b19d6851e284d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 120664, "upload_time": "2018-10-17T12:23:36", "upload_time_iso_8601": "2018-10-17T12:23:36.348777Z", "url": "https://files.pythonhosted.org/packages/5c/41/c51f7a936b0efe46d9ddef00cc3bd0fbb82c4579663aa35408e48d060555/plone.testing-7.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5eebac2844182c659c1a488fc1ddd47b", "sha256": "db71bde0d4d3c273dbba8c7a2ab259a42f038eca74184da36c5aab61e90e8dd7"}, "downloads": -1, "filename": "plone.testing-7.0.0.tar.gz", "has_sig": false, "md5_digest": "5eebac2844182c659c1a488fc1ddd47b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 156696, "upload_time": "2018-10-17T12:23:39", "upload_time_iso_8601": "2018-10-17T12:23:39.202457Z", "url": "https://files.pythonhosted.org/packages/10/97/2faef364197b1446466aed529f8b93535159a145142f41211c193bb695e4/plone.testing-7.0.0.tar.gz", "yanked": false}], "7.0.1": [{"comment_text": "", "digests": {"md5": "6eee4d5e77438cd5c2d1b7cc69720e36", "sha256": "1fd53b964499c8d2fcd4dfe424b27cd93f3415dc07203490ddc3ad09b3911452"}, "downloads": -1, "filename": "plone.testing-7.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6eee4d5e77438cd5c2d1b7cc69720e36", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 121155, "upload_time": "2019-03-04T02:45:33", "upload_time_iso_8601": "2019-03-04T02:45:33.712945Z", "url": "https://files.pythonhosted.org/packages/c1/77/0f6c647221d4d200600923881c3ce63c3ec0ed30885ccc759278a657b35f/plone.testing-7.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "866350bd2a7689f55ec42f01dd669bf7", "sha256": "98a6e9ce8df1fdd33876e2d8c3ca3d8291612c20bd7e0811dac83b6ce10e984b"}, "downloads": -1, "filename": "plone.testing-7.0.1.tar.gz", "has_sig": false, "md5_digest": "866350bd2a7689f55ec42f01dd669bf7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 160826, "upload_time": "2019-03-04T02:45:36", "upload_time_iso_8601": "2019-03-04T02:45:36.345340Z", "url": "https://files.pythonhosted.org/packages/7a/bf/baf5d713bca4978420a8bd52b1ad7386775f2668610298fa1b67f9248d9c/plone.testing-7.0.1.tar.gz", "yanked": false}], "7.0.2": [{"comment_text": "", "digests": {"md5": "0bd18a5260dd1caa64004b4908e2e11a", "sha256": "289fe6cc7626e09cd72ce4cca5212c5cbfd82533a1fd12fbd15c4ba469f6c6b8"}, "downloads": -1, "filename": "plone.testing-7.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0bd18a5260dd1caa64004b4908e2e11a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 121101, "upload_time": "2019-07-06T23:08:09", "upload_time_iso_8601": "2019-07-06T23:08:09.064645Z", "url": "https://files.pythonhosted.org/packages/57/d3/fc0bc66c9724e386fbd336127479218cd087b15d8523dd74c04f3a47bded/plone.testing-7.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9efe6bc71b482592abdd6e026bb68466", "sha256": "2533c48b7bd54ff19da2b4f0c3ccd0a8878c46f03fadbf5f933baaf749d17690"}, "downloads": -1, "filename": "plone.testing-7.0.2.tar.gz", "has_sig": false, "md5_digest": "9efe6bc71b482592abdd6e026bb68466", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 160932, "upload_time": "2019-07-06T23:08:13", "upload_time_iso_8601": "2019-07-06T23:08:13.447772Z", "url": "https://files.pythonhosted.org/packages/d4/0a/da2e117fa661a97e8d4d8ba3503d6c0be8ad823a1ef967f333414eef2f18/plone.testing-7.0.2.tar.gz", "yanked": false}], "7.0.3": [{"comment_text": "", "digests": {"md5": "dc7b18b6cdff4b607f2501634ec86284", "sha256": "1733511d53c455ecfb526bc03a4e3575a8ace1f68ddabca671757ac1cc7ca660"}, "downloads": -1, "filename": "plone.testing-7.0.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "dc7b18b6cdff4b607f2501634ec86284", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 121148, "upload_time": "2019-12-10T22:45:48", "upload_time_iso_8601": "2019-12-10T22:45:48.358791Z", "url": "https://files.pythonhosted.org/packages/28/9b/7a73b9ee3182d5464bc2accfa55822c93e6b09387f46f4e0abbc8d2697e9/plone.testing-7.0.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "73b50823beb6e62459cab93c0343ff1b", "sha256": "160f130f641578fbede2e47686f1b58179efa9ff98ccdd1ad198b5d0c7e02474"}, "downloads": -1, "filename": "plone.testing-7.0.3.tar.gz", "has_sig": false, "md5_digest": "73b50823beb6e62459cab93c0343ff1b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 161370, "upload_time": "2019-12-10T22:45:55", "upload_time_iso_8601": "2019-12-10T22:45:55.141282Z", "url": "https://files.pythonhosted.org/packages/77/84/0e488f167b7e72fa31530a431585916af412822c804483b2794ea422931a/plone.testing-7.0.3.tar.gz", "yanked": false}], "8.0.0": [{"comment_text": "", "digests": {"md5": "7c159e891030bf49c25865a61348b7ed", "sha256": "6f80360286a817cf95be38cb124460a28ac2724d56063d336895fb81f311bcee"}, "downloads": -1, "filename": "plone.testing-8.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "7c159e891030bf49c25865a61348b7ed", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 121255, "upload_time": "2020-04-20T22:23:30", "upload_time_iso_8601": "2020-04-20T22:23:30.217904Z", "url": "https://files.pythonhosted.org/packages/de/86/336cf7c97fe5376bc2902deff4c0c3fea27b896ddfd2a229b2dd5a4c9321/plone.testing-8.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1797398a1e1c2fb94cbdff2cd55c8962", "sha256": "71f22cb8cc169360786ec468a0ab5d403abe5bacc13754c251dd6b9eeedd1d83"}, "downloads": -1, "filename": "plone.testing-8.0.0.tar.gz", "has_sig": false, "md5_digest": "1797398a1e1c2fb94cbdff2cd55c8962", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 161670, "upload_time": "2020-04-20T22:23:33", "upload_time_iso_8601": "2020-04-20T22:23:33.746394Z", "url": "https://files.pythonhosted.org/packages/82/86/9d28ced9a20854a129ded453b80b41285149c13767bdd02c2677df6803f6/plone.testing-8.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7c159e891030bf49c25865a61348b7ed", "sha256": "6f80360286a817cf95be38cb124460a28ac2724d56063d336895fb81f311bcee"}, "downloads": -1, "filename": "plone.testing-8.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "7c159e891030bf49c25865a61348b7ed", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 121255, "upload_time": "2020-04-20T22:23:30", "upload_time_iso_8601": "2020-04-20T22:23:30.217904Z", "url": "https://files.pythonhosted.org/packages/de/86/336cf7c97fe5376bc2902deff4c0c3fea27b896ddfd2a229b2dd5a4c9321/plone.testing-8.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1797398a1e1c2fb94cbdff2cd55c8962", "sha256": "71f22cb8cc169360786ec468a0ab5d403abe5bacc13754c251dd6b9eeedd1d83"}, "downloads": -1, "filename": "plone.testing-8.0.0.tar.gz", "has_sig": false, "md5_digest": "1797398a1e1c2fb94cbdff2cd55c8962", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 161670, "upload_time": "2020-04-20T22:23:33", "upload_time_iso_8601": "2020-04-20T22:23:33.746394Z", "url": "https://files.pythonhosted.org/packages/82/86/9d28ced9a20854a129ded453b80b41285149c13767bdd02c2677df6803f6/plone.testing-8.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:52:45 2020"}