{"info": {"author": "Ivo van der Wijk", "author_email": "djangoprojects@in.m3r.nl", "bugtrack_url": null, "classifiers": ["Programming Language :: Python"], "description": "django layers\n=============\n\nThis package provides support for \"layers\" of templates and static resources\nthat can be selecting depending on the request context.\n\nWARNING: The API documented below may change significantly before version 1.0\n\nWhy?\n----\n\nUsing layers you can provide alternative sets of templates (\"skins\")\ndepending on different contexts. For example, using the same CMS you\ncan, from a single code base, host different frontend designs, have\na different visitor/admin frontend, do A/B testing, etc.\n\nAll of this within the same instance (so no separate instances each running\nwith their own settings.py configuration)\n\n\nHow?\n----\n\npip/easy_install this package, django_layers\n\nThen add 'layers.middleware.LayerLoaderMiddleware' to your\nMIDDLEWARE_CLASSES, e.g.\n\n    MIDDLEWARE_CLASSES = (\n        'layers.middleware.LayerLoaderMiddleware',\n        ...\n    )\n\nAlso, add 'layers.loader.LayerLoader' at the top of your TEMPLATE_LOADERS, prior\nto any other/django loaders. E.g.\n\n    TEMPLATE_LOADERS = (\n        'layers.loader.LayerLoader',\n        'django.template.loaders.filesystem.Loader',\n        'django.template.loaders.app_directories.Loader',\n    )\n\nOptionally, if you have separate collections of static resources for each layer,\nadd 'layers.finders.AppLayerFinder' as the first STATICFILE_FINDERS:\n\n    STATICFILES_FINDERS = (\n        'layers.finders.AppLayerFinder',\n        # ...\n        'django.contrib.staticfiles.finders.FileSystemFinder',\n        'django.contrib.staticfiles.finders.AppDirectoriesFinder',\n    )\n\nand define which layers you have and where they need to be collected to\n\n    LAYERS = {\n        'visitor-a':STATIC_ROOT + '/visitor-a',\n        'visitor-b':STATIC_ROOT + '/visitor-b'\n        }\n\n\nNow you can start using layers.\n\nCreate the same templates as before but in stead (or on top of) storing them\nin your package's templates folder, store them in a folder called \n'layers/**layername**/templates'.\n\nE.g. you could have\n\n    mypackage/templates/mypackage/foo.html\n    mypackage/layers/visitor-a/templates/mypackage/foo.html\n    mypackage/layers/visitor-b/templates/mypackage/foo.html\n\nThis creates two layers, \"visitor-a\" and \"visitor-b\" and a fallback if no\nlayer is selected.\n\nAdditionally, create a file \"layers.py\" with a function \"get_layers\" that\nwill return the layer to be used, e.g.\n\n    def get_layer(request):\n        if request.get_host().startswith(\"a.\"):\n            return \"visitor-a\"\n        if request.get_host().startswith(\"b.\"):\n            return \"visitor-b\"\n\n\nYou can do anything you like in the \"get_layer\" callable, as long as you return\na layer or nothing.\n\nWhen requesting Django to render the template \"mypackage/foo.html\", it will\nrender any of the three templates above depending on the request context (the\nhostname used).\n\nConfiguration per layer\n-----------------------\n\nYou can also provide some global shared configuration per layer. Since all\nlayers will share the same settings.py, it's not possible to use that for\nlayer specific configuration.\n\nYou can do this by defining a 'get_config' method in your package's layers.py\nfile. This will simply return a dict containing the layer specific data for\neach layer.\n\nE.g.\n\n    def get_config():\n        return {'visitor-a': dict(site_id=1, mailto='visitor-a@example.com'),\n                'visitor-b': dict(site_id=2, mailto='visitor-b@example.com')\n               }\n\nYou can then access the current layer's configuration using 'get_current_layer':\n\n    from layers.middleware import get_current_layer\n\n    def myview(request):\n        layer = get_current_layer()\n        return SomeModel.objects.filter(site_id=layer['site_id'])\n\ndjango_layers will scan all your packages for configuration and merge the\nconfiguration dictionaries together if necessary.\n\nStatic resources per layer\n--------------------------\n\nYou can store your per-layer statics in any app installed in your application\nin the layers/**layer**/**layername**/statics folder, e.g. you could have\n\n    mypackage/static/css/foo.css\n    mypackage/layers/visitor-a/static/css/foo.css\n    mypackage/layers/visitor-b/static/css/foo.css\n\nA request for /static/css/foo.css will result in visitor-a/static/css/foo.css\nif the visitor-a layer is active, it will result in visitor-b/static/css/foo.css\nif the visitor-b layer is active or in mypackage/static/css/foo.css otherwise.\n\n\nStatic resources are served by the django 'runserver' command or by a webserver\nrunning in front of your application.\n\ndjango_layers provides an upgraded `runserver` command that knows which static\nresources to serve depending on the active layer. It also comes with a \n`collectlayers` command that collects the layers into distinct staticfolders,\nsimilar to how 'collectstatic' works. Which layer is collected where is defined\nby the 'LAYERS' settings.py setting.\n\nE.g. given the previous LAYERS definition\n\n    python manage.py collectlayers\n\nwill collect the global static resources and visitor-a specific resources into\nSTATIC_ROOT + '/visitor-a' and another copy of the global static resources\nand visitor-b specific resources into STATIC_ROOT + '/visitor-b'", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/iivvoo/django_layers", "keywords": "", "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "django_layers", "package_url": "https://pypi.org/project/django_layers/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django_layers/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/iivvoo/django_layers"}, "release_url": "https://pypi.org/project/django_layers/0.9/", "requires_dist": null, "requires_python": null, "summary": "Support different frontend templates/statics on same instance", "version": "0.9", "yanked": false, "html_description": "<div class=\"project-description\">\n            django layers<br>=============<br><br>This package provides support for \"layers\" of templates and static resources<br>that can be selecting depending on the request context.<br><br>WARNING: The API documented below may change significantly before version 1.0<br><br>Why?<br>----<br><br>Using layers you can provide alternative sets of templates (\"skins\")<br>depending on different contexts. For example, using the same CMS you<br>can, from a single code base, host different frontend designs, have<br>a different visitor/admin frontend, do A/B testing, etc.<br><br>All of this within the same instance (so no separate instances each running<br>with their own settings.py configuration)<br><br><br>How?<br>----<br><br>pip/easy_install this package, django_layers<br><br>Then add 'layers.middleware.LayerLoaderMiddleware' to your<br>MIDDLEWARE_CLASSES, e.g.<br><br>    MIDDLEWARE_CLASSES = (<br>        'layers.middleware.LayerLoaderMiddleware',<br>        ...<br>    )<br><br>Also, add 'layers.loader.LayerLoader' at the top of your TEMPLATE_LOADERS, prior<br>to any other/django loaders. E.g.<br><br>    TEMPLATE_LOADERS = (<br>        'layers.loader.LayerLoader',<br>        'django.template.loaders.filesystem.Loader',<br>        'django.template.loaders.app_directories.Loader',<br>    )<br><br>Optionally, if you have separate collections of static resources for each layer,<br>add 'layers.finders.AppLayerFinder' as the first STATICFILE_FINDERS:<br><br>    STATICFILES_FINDERS = (<br>        'layers.finders.AppLayerFinder',<br>        # ...<br>        'django.contrib.staticfiles.finders.FileSystemFinder',<br>        'django.contrib.staticfiles.finders.AppDirectoriesFinder',<br>    )<br><br>and define which layers you have and where they need to be collected to<br><br>    LAYERS = {<br>        'visitor-a':STATIC_ROOT + '/visitor-a',<br>        'visitor-b':STATIC_ROOT + '/visitor-b'<br>        }<br><br><br>Now you can start using layers.<br><br>Create the same templates as before but in stead (or on top of) storing them<br>in your package's templates folder, store them in a folder called <br>'layers/**layername**/templates'.<br><br>E.g. you could have<br><br>    mypackage/templates/mypackage/foo.html<br>    mypackage/layers/visitor-a/templates/mypackage/foo.html<br>    mypackage/layers/visitor-b/templates/mypackage/foo.html<br><br>This creates two layers, \"visitor-a\" and \"visitor-b\" and a fallback if no<br>layer is selected.<br><br>Additionally, create a file \"layers.py\" with a function \"get_layers\" that<br>will return the layer to be used, e.g.<br><br>    def get_layer(request):<br>        if request.get_host().startswith(\"a.\"):<br>            return \"visitor-a\"<br>        if request.get_host().startswith(\"b.\"):<br>            return \"visitor-b\"<br><br><br>You can do anything you like in the \"get_layer\" callable, as long as you return<br>a layer or nothing.<br><br>When requesting Django to render the template \"mypackage/foo.html\", it will<br>render any of the three templates above depending on the request context (the<br>hostname used).<br><br>Configuration per layer<br>-----------------------<br><br>You can also provide some global shared configuration per layer. Since all<br>layers will share the same settings.py, it's not possible to use that for<br>layer specific configuration.<br><br>You can do this by defining a 'get_config' method in your package's layers.py<br>file. This will simply return a dict containing the layer specific data for<br>each layer.<br><br>E.g.<br><br>    def get_config():<br>        return {'visitor-a': dict(site_id=1, mailto='visitor-a@example.com'),<br>                'visitor-b': dict(site_id=2, mailto='visitor-b@example.com')<br>               }<br><br>You can then access the current layer's configuration using 'get_current_layer':<br><br>    from layers.middleware import get_current_layer<br><br>    def myview(request):<br>        layer = get_current_layer()<br>        return SomeModel.objects.filter(site_id=layer['site_id'])<br><br>django_layers will scan all your packages for configuration and merge the<br>configuration dictionaries together if necessary.<br><br>Static resources per layer<br>--------------------------<br><br>You can store your per-layer statics in any app installed in your application<br>in the layers/**layer**/**layername**/statics folder, e.g. you could have<br><br>    mypackage/static/css/foo.css<br>    mypackage/layers/visitor-a/static/css/foo.css<br>    mypackage/layers/visitor-b/static/css/foo.css<br><br>A request for /static/css/foo.css will result in visitor-a/static/css/foo.css<br>if the visitor-a layer is active, it will result in visitor-b/static/css/foo.css<br>if the visitor-b layer is active or in mypackage/static/css/foo.css otherwise.<br><br><br>Static resources are served by the django 'runserver' command or by a webserver<br>running in front of your application.<br><br>django_layers provides an upgraded `runserver` command that knows which static<br>resources to serve depending on the active layer. It also comes with a <br>`collectlayers` command that collects the layers into distinct staticfolders,<br>similar to how 'collectstatic' works. Which layer is collected where is defined<br>by the 'LAYERS' settings.py setting.<br><br>E.g. given the previous LAYERS definition<br><br>    python manage.py collectlayers<br><br>will collect the global static resources and visitor-a specific resources into<br>STATIC_ROOT + '/visitor-a' and another copy of the global static resources<br>and visitor-b specific resources into STATIC_ROOT + '/visitor-b'\n          </div>"}, "last_serial": 1088607, "releases": {"0.7.1": [{"comment_text": "", "digests": {"md5": "fbfaa6a95dd54785327034a50f6f0440", "sha256": "10a0e758fbb3fe04fca787feccde014e4fc590f34650cf9ccdaf36f86527c073"}, "downloads": -1, "filename": "django_layers-0.7.1.tar.gz", "has_sig": false, "md5_digest": "fbfaa6a95dd54785327034a50f6f0440", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4059, "upload_time": "2013-07-30T14:35:11", "upload_time_iso_8601": "2013-07-30T14:35:11.084439Z", "url": "https://files.pythonhosted.org/packages/11/6b/7767c65dce798e82d5cf7c5e2a50cb1166075d352a3fade7807c6bf4d4c1/django_layers-0.7.1.tar.gz", "yanked": false}], "0.7.2": [{"comment_text": "", "digests": {"md5": "839ecc27e6597b2d13993e6df2fa7e10", "sha256": "fc0667a2d5ece5bc72006498f39c78460a3a002e4d37d5815449160ea8926adc"}, "downloads": -1, "filename": "django_layers-0.7.2.tar.gz", "has_sig": false, "md5_digest": "839ecc27e6597b2d13993e6df2fa7e10", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4351, "upload_time": "2013-08-01T12:00:44", "upload_time_iso_8601": "2013-08-01T12:00:44.203873Z", "url": "https://files.pythonhosted.org/packages/01/ef/b909477a661709c926a2dae0051a1bded71c2516e28159f1b599e4d01076/django_layers-0.7.2.tar.gz", "yanked": false}], "0.8": [{"comment_text": "", "digests": {"md5": "817e2c96f175ff659ca5bca87a799692", "sha256": "41f97f1a1c58cbca09da24d6a699342af0daeaf322959b7712f7a01eb0487fc9"}, "downloads": -1, "filename": "django_layers-0.8.tar.gz", "has_sig": false, "md5_digest": "817e2c96f175ff659ca5bca87a799692", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10865, "upload_time": "2013-09-03T10:49:05", "upload_time_iso_8601": "2013-09-03T10:49:05.827469Z", "url": "https://files.pythonhosted.org/packages/41/6a/bae0a5061c5eab872c75fc9f53fcfc31884ff0cd9dc98a3543da0d1d36e9/django_layers-0.8.tar.gz", "yanked": false}], "0.9": [{"comment_text": "", "digests": {"md5": "a81fc6ef737aea58eb6cf73797f024d0", "sha256": "44f21aa119bee15ad10ceb6fad256b5167ccba1bc8e517fdf3dd271e8bdf006b"}, "downloads": -1, "filename": "django_layers-0.9.tar.gz", "has_sig": false, "md5_digest": "a81fc6ef737aea58eb6cf73797f024d0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9757, "upload_time": "2014-05-11T15:04:17", "upload_time_iso_8601": "2014-05-11T15:04:17.587295Z", "url": "https://files.pythonhosted.org/packages/56/b3/ab94372fdcc4086ac15d956dca391c224137bde933950a4ef752e0ec8bd5/django_layers-0.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a81fc6ef737aea58eb6cf73797f024d0", "sha256": "44f21aa119bee15ad10ceb6fad256b5167ccba1bc8e517fdf3dd271e8bdf006b"}, "downloads": -1, "filename": "django_layers-0.9.tar.gz", "has_sig": false, "md5_digest": "a81fc6ef737aea58eb6cf73797f024d0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9757, "upload_time": "2014-05-11T15:04:17", "upload_time_iso_8601": "2014-05-11T15:04:17.587295Z", "url": "https://files.pythonhosted.org/packages/56/b3/ab94372fdcc4086ac15d956dca391c224137bde933950a4ef752e0ec8bd5/django_layers-0.9.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:35:24 2020"}