{"info": {"author": "kiorky <kiorky@cryptelium.net>", "author_email": "kiorky@cryptelium.com", "bugtrack_url": null, "classifiers": ["Programming Language :: Python", "Topic :: Software Development"], "description": "Introduction\n============\n\n.. contents::\n\ncollective.cron is a cron-like asynchronous tasks system based on top of plone.app.async and plone.app.registry.\nThe implementation does not have for now all the bells and wistles of a nice UI.\nHowever the simple interface does all the stuff and the underlying job manager works reliably.\n\nFinaly, you can register your tasks easily.\n\n\nNote that at the moment, we have 100% test coverage. This do not prevent bugs altogether, but it keeps us from making big mistakes.\n\nThe design is modern and modular, imagine that you can even easily change from plone.app.async to another job system.\n\nThe buildout infrastructure\n===========================\n- base.cfg                -> base buildout informations\n- buildout.cfg            -> base buildout for the current plone version\n- test-4.0.x.cfg          -> test buildout for plone4.0\n- test-4.1.x.cfg          -> test buildout for plone4.1\n- test-4.2.x.cfg          -> test buildout for plone4.2\n\nThe most important things are in base.cfg.\nIf you plan to integrate collective.cron to your buildout, please refer to the plone.app.async documentation.\n\n- For now we use the unreleased version of plone.app.async : https://github.com/plone/plone.app.async\n\nNote for tests\n==============\n- Tests can unpredictibly crash because of monkey patchs to datetime.\n  This is a false positive. Just relaunch them if you see something similar ::\n\n      ConflictError: database conflict error (oid 0x2549d9dd3cf6b59b, serial this txn started with 0x0399e4b3adb993bb 2012-10-14 09:23:40.716776, serial currently committed 0x0399e4b3ae733c77 2012-10-14 09:23:40.886752)\n\ncollective.cron 1.0 => collective.cron 2.0\n==========================================\n- in 1.0, each cron task was a content.\n  This was then tedious to replicate and maintain accross multiple instances and plone versions.\n  One of the goal of collective.cron 2.0 is to avoid at most to have persistance, specially specialized contents to minimize all the common migration problems we have with an objects database.\n  Thus a choice has been made to heavily use plone.app.registry as a configuration backend.\n\n- Thus, there is no migration prepared from collective.cron 1.0 to 2.0\n  It is up to you to do it.\n  Specially, you will have to clean the database of all specific collective.cron 1.0 based & persistent content before upgrading.\n  Indeed, as the design of tasks is really different, we can't do any automatic migration.\n\n- First with collective.cron 1.x in your buildout\n\n        - Search, record settings then delete all IBackend content\n        - Delete all jobresults & persistent contents\n        - Cleanup all the zc.async queue\n\n- Next, deactivate collective.cron 1.x and activate collective.cron 2.x in your buildout\n\n    - Adapt your adapters and content types to work with collective.cron 2.0 (inputs/mark items to work on)\n    - add equivalent crons records to the crontab setting of the backends job\n\nCredits\n========\nCompanies\n---------\n|makinacom|_\n\n  * `Planet Makina Corpus <http://www.makina-corpus.org>`_\n  * `Contact us <mailto:python@makina-corpus.org>`_\n\n.. |makinacom| image:: http://depot.makina-corpus.org/public/logo.gif\n.. _makinacom:  http://www.makina-corpus.com\n\nAuthors\n-------\n\n- kiorky  <kiorky@cryptelium.net>\n\nContributors\n------------\n\n- djay <software@pretaweb.com>\n\nRepository\n==========\n\n- `github <https://github.com/collective/collective.cron>`_\n\n\nDesign\n======\n- collective.cron lets you register crons which run periodically in your system.\n- Each plone site has a crontab.\n- This crontab is used by many components to execute the cron jobs.\n- There is a central dashboard which will list all tasks registered on the site crontab.\n- The tasks configuration is based on plone.app.registry but is designed to be replaceable (component).\n- The tasks execution is based on plone.app.async but is designed to be also replaceable (component).\n\n- The cron manager will ensure to restore all cron jobs for all plone sites at zope restart.\n\nCrontab\n-------\nA crontab is the collection of all cron registered to a plone site.\nA crontab can be (de)activated globally.\nEach crontab sub element (the crontab, the crons & associated logs) defines a dump method which creates a JSON representation of the object.\n\nThe major attributes for a crontab are:\n\n    - crons: An ordered dict of crons. Key is the cron uid\n    - activated: globally power switch for the crontab\n    - manager: the manager is responsible for the crontab persistence\n    - save(): save the crontab\n    - save_cron(cron): save the cron\n\nWhen a crontab is saved, it emits a ``ModifiedCrontabEvent``.\n\nCron\n----\nThe major attributes for a cron are:\n\n    - **name**: will be the queried name to search jobs. Via adaption or traversal.\n    - **periodicity**: give the next time execution\n    - **environ**: An optionnal jsonencoded mapping of values which will be given to the task\n    - **logs_limit**: logs to keep (default : 5, limit : 25)\n    - uid: internal id for the crontab machinery\n    - user: the user the task will run as, its up to you to make the task run as this user\n    - activated: the activation status of the cron\n    - logs: give the last logs of the cron prior executions from most recent to older\n    - crontab: A possibly null reference to the parent crontab\n\nA note on the user which is only **a stocked value**. you can see ``collective.cron.utils.su_plone`` to help you switch to that user.\nIT IS UP TO YOU TO SWITCH TO THAT USER **IN YOUR JOBRUNNER**.\n\nLog\n---\nThe major attributes for a log are:\n\n    - date: date of logging\n    - status: status ::= NOTRUN | FAILURE | WARN | OK\n    - message: the logs\n\nCrontab registry manager\n------------------------\nBased on top of plone.app.registry, collective.cron record the crontab current status in the site registry.\nIt adapts a crontab.\n\n    - activated: boolean switch status of the crontab\n    - cronsettings: the raw manager settings (.crontab, .activated)\n    - crons: list of serialized strings representations of the crons\n    - read_only: if true, changes will be a NOOP\n\nWhen a record is touched (added, edited, removed), events are fired to syncronize the queue.\n\nCrontab manager\n---------------\nThis component is responsible when a CrontabSynchronisationEvent is fired to synchronise the crontab with the job queuing system.\nIt will remove unrelated jobs and schedule new jobs.\nIt adapts a plonesite and a crontab.\n\nWhen the crontab is saved emits a ``ModifiedCrontabEvent`` which in turns is redirected as a ``CrontabSynchronisationEvent`` to let the manager synchronize the queue.\n\nWhen the server restarts, a ``ServerRestartEvent`` is called to re-register any cron job that would have been wiped from the queue.\n\nCron manager\n------------\nThis component is responsible for the execution and presence in the queue of a particular cronjob. It can register or remove the job execution of a cron.\nThis is a friendly proxy to the \"Queue manager\".\n\nIt adapts a plonesite and a cron.\n\nWhen a cronjob is registered, the job queued is a cron jobrunner wrapper responsible for:\n\n    - Sending a ``StartedCronJobEvent``\n    - Running the relevant JobRunner (a named adapter adapting the plonesite, and the cron)\n    - Sending a ``FinishedCronJobEvent``\n    - logging the execution\n    - Scheduling the next execution\n\nJobRunner\n---------\nA cron jobrunner is either a named adapter which:\n    - adapts the plonesite and the current cron\n    - implements IJobRunbner, and specially defines a **run** method.\nor is a traversal script which takes no paramaters\n\nFor adapter based Runners a base class exists in collective cron, just inherit from it.\nThis is a complicated definition to have a class like this::\n\n    from collective.cron import crontab\n    class MyCronJob(crontab.Runner):\n        def run(self):\n            print \"foo\"\n\nRegistered in zcml like that::\n\n    <adapter factory=\".module.MyCronJob\" name=\"mycronjob\"/>\n\nAnd then, you will have to register a cron called ``mycronjob`` in your plonesite.\n\nFor PythonScript based runners give your cron a name which is the relative path of\nyour script to the portal base.\n\nQueue manager\n-------------\nThis component will manage the jobs inside the job queue.\nYou will have enough methods to know for a specific cron if a job is present, what is its status...\n\nYou can also register, or delete items from the running queue\nIt adapts a plonesite.\n\nCrontab Queue Marker (plone.app.async specific)\n-----------------------------------------------\nResponsible to mark infos in the async queue to make the reload of jobs at Zope restart possible.\n\nDetailed documentation\n======================\nThere are 3 ways to register tasks:\n\n    - via the API\n    - via the UI\n    - via Generic Setup (profile)\n\n\n\n\n\nManage (add, edit, remove, run) tasks via collective.cron API\n--------------------------------------------------------------\n\nsetup\n++++++++\n::\n\n    >>> import time\n    >>> from collective.cron import interfaces as i\n    >>> from collective.cron.testing import set_now\n    >>> from collective.cron import crontab as mcrontab\n    >>> from collective.cron import utils\n    >>> import datetime, pytz\n    >>> from zc.async.testing import wait_for_result\n    >>> layer['crontab'].save()\n    >>> import transaction\n    >>> get_jobs = lambda:[a for a in layer['queue']]\n\nCreation of a jobrunner\n+++++++++++++++++++++++++++\nWe will define a cronjob to execute on the next scheduled tasks behalf.\nHere we register global adapters, but you can of course register local adapters on a specific plonesite and they will be taken up::\n\n    >>> plone = layer['portal']\n    >>> purl = plone.absolute_url()\n    >>> from collective.cron import crontab\n    >>> class MyCronJob(crontab.Runner):\n    ...     runned = []\n    ...     environs = []\n    ...     def run(self):\n    ...         self.runned.append(1) # mutable list will be shared among all instances\n    ...         self.environs.append(self.cron.environ)\n    >>> from zope.component import getGlobalSiteManager\n    >>> gsm = getGlobalSiteManager()\n    >>> gsm.registerAdapter(MyCronJob, name=\"mycronjob\")\n    >>> gsm.registerAdapter(MyCronJob, name=\"myfoojob\")\n\nThe top object of the crontab, is ... the Crontab.\nCalling load make the Crontab object and reflect the registry configuration inside it.\nYou ll have to do that::\n\n    >>> bcrt = mcrontab.Crontab.load()\n    >>> bcrt.crons\n    OrderedDict([(u'...', cron: testcron/... [ON:...])])\n\nThink that you can configure tasks with a dict of simple values (they must be json encodable) for your jobs runners to parameterize the task.\n\n\nAdding crons to the crontab\n+++++++++++++++++++++++++++++\nWe will add the related crontab to the plone site in the cron dashboard::\n\n    >>> dstart = datetime.datetime(2008,1,1,1,3)\n    >>> set_now(dstart)\n    >>> crt = mcrontab.Crontab()\n    >>> cron = mcrontab.Cron(name=u'mycronjob',\n    ...         activated=True,\n    ...         periodicity = u'*/1 * * * *',\n    ...         environ={u'foo':u'bar'},\n    ...         crontab=crt)\n    >>> cron\n    cron: mycronjob/... [ON:2008-01-01 00:04:00] {u'foo': u'bar'}\n\nNever register a cron to two crontab, the cron and crontab have an internal link to each other.\nIf you want to replicate crons between crontab objects, dump them::\n\n    >>> crt2 = mcrontab.Crontab()\n    >>> crt2.add_cron(mcrontab.Cron.load(cron.dump()))\n\nSimilar check all the cron properties except crontab & logs::\n\n    >>> crt2.by_name('mycronjob')[0].similar(cron)\n    True\n\nYou have three methods to search crons in crontab:\n\n    - by( ``**`` kwargs) : find all cron matching the infos given in kwargs (see cron constructor)\n    - by_name(value) : give all cron matching name\n    - by_uid(value) : give the cron registered with uid\n\nRecord the craontab back into the site to register the jobs when you are done::\n\n    >>> crt.save()\n    >>> transaction.commit()\n\nAfter adding the job, it is queued::\n\n    >>> get_jobs()[0]\n    <zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'test_user_1_', collective.cron.crontab.runJob, cron: mycronjob/... [ON:2008-01-01 00:04:00]...)``>\n\nToggle the cron activation\n++++++++++++++++++++++++++++++++\nAt the cron level::\n\n    >>> cron.activated = False\n    >>> crt.save()\n    >>> cron.activated = True\n    >>> len(get_jobs()) > 0\n    False\n\nReactivate::\n\n    >>> cron.activated = True\n    >>> crt.save()\n    >>> len(get_jobs()) > 0\n    True\n\nGlobally, at the crontab level (for all crons)::\n\n    >>> crt.activated = False\n    >>> crt.save()\n    >>> len(get_jobs()) > 0\n    False\n\nReactivate::\n\n    >>> crt.activated = True\n    >>> crt.save()\n    >>> len(get_jobs()) > 0\n    True\n\nEdit a cron\n+++++++++++++\nWe can change the name and some other infos of a cron\n\n    >>> cron.name = u'myfoojob'\n    >>> cron.periodicity = u'*/10 * * * *'\n    >>> crt.save()\n\nOlder jobs have been removed, only the one for this renamed job is present::\n\n    >>> get_jobs()\n    [<zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'test_user_1_', collective.cron.crontab.runJob, cron: myfoojob/... [ON:2008-01-01 00:10:00]...)``>]\n\nTrigger a job execution\n++++++++++++++++++++++++++\nYou can force a job execution by using the  ``CronManager`` composant::\n\n    >>> set_now(datetime.datetime(2008,1,1,2,4))\n    >>> manager = getMultiAdapter((plone, cron), i.ICronManager)\n    >>> manager.register_job(force=True)\n    True\n    >>> transaction.commit()\n\nThe job return the status, the messages, the uid of the cron and the plone portal path (tuple)::\n\n    >>> wait_for_result(get_jobs()[0])\n    (1, [], u'...', ('', 'plone'))\n    >>> MyCronJob.runned\n    [1]\n    >>> MyCronJob.environs[-1]\n    {u'foo': u'bar'}\n\nAnd the job is rescheduled::\n\n    >>> get_jobs()\n    [<zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'test_user_1_', collective.cron.crontab.runJob, cron: myfoojob/... [ON:2008-01-01 01:10:00] (1 logs)...)``>]\n    >>> transaction.commit()\n\n\nView & delete a log\n++++++++++++++++++++\nSave the current state::\n\n    >>> runnedcron = get_jobs()[0].args[5]\n    >>> runnedcron.save()\n    >>> ncron = crontab.Crontab.load().by_uid(cron.uid)\n\nView::\n\n    >>> ncron.logs\n    [log: 2008-01-01 02:04:00/OK]\n\nDelete::\n\n    >>> noecho = ncron.logs.pop(0)\n    >>> ncron.save()\n\nDelete a cron from the crontab\n++++++++++++++++++++++++++++++++++\nSimply delete it from the crons indexed by uid::\n\n    >>> del crt.crons[cron.uid]\n    >>> crt.save()\n    >>> get_jobs()\n    []\n\n\nTeardown\n+++++++++\n::\n\n    >>> bcrt.save()\n    >>> noecho = gsm.unregisterAdapter(MyCronJob, name=\"myfoojob\")\n    >>> noecho = gsm.unregisterAdapter(MyCronJob, name=\"mycronjob\")\n    >>> transaction.commit()\n\n\n\n\nManage (add, edit, remove, run) tasks via the web interface\n-------------------------------------------------------------\n\nsetup\n++++++++\n::\n\n    >>> import lxml\n    >>> import time\n    >>> from collective.cron import interfaces as i\n    >>> from collective.cron.testing import set_now\n    >>> from collective.cron import crontab as mcrontab\n    >>> from collective.cron import utils\n    >>> import datetime, pytz\n    >>> layer['crontab'].save()\n    >>> from zc.async.testing import wait_for_result\n    >>> import transaction\n    >>> get_jobs = lambda:[a for a in layer['queue']]\n    >>> bcrt = mcrontab.Crontab.load()\n    >>> crt = mcrontab.Crontab()\n    >>> crt.save()\n    >>> transaction.commit()\n\nCreation of a jobrunner\n++++++++++++++++++++++++++\nWe will define a cronjob to execute on the next scheduled tasks behalf\nThink that you can make generic tasks which can be configured by the environ json mapping that you configure along with the cron task.\nWhen the job is runned you can access it by ``self.cron.environ``.\n::\n\n    >>> plone = layer['portal']\n    >>> purl = plone.absolute_url()\n    >>> from collective.cron import crontab\n    >>> class MyCronJob(crontab.Runner):\n    ...     runned = []\n    ...     environs = []\n    ...     def run(self):\n    ...         self.runned.append(1) # mutable list will be shared among all instances\n    ...         self.environs.append(self.cron.environ) # mutable list will be shared among all instances\n    >>> from zope.component import getGlobalSiteManager\n    >>> gsm = getGlobalSiteManager()\n    >>> gsm.registerAdapter(MyCronJob, name=\"mycronjob\")\n    >>> gsm.registerAdapter(MyCronJob, name=\"myfoojob\")\n\nRegistering a job through the interface\n++++++++++++++++++++++++++++++++++++++++++\n\nWe will add the related crontab to the plone site in the cron dashboard::\n\n    >>> dstart = datetime.datetime(2008,1,1,1,3)\n    >>> set_now(dstart)\n    >>> browser = Browser.new(purl, login=True)\n    >>> browser.handleErrors = False\n    >>> browser.getLink('Site Setup').click()\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> '@@cron-settings' in browser.contents\n    True\n    >>> browser.getLink('Add a task').click()\n    >>> browser.getControl(name='form.widgets.name').value = 'mycronjob'\n    >>> browser.getControl(name='form.widgets.periodicity').value = '*/1 * * * *'\n    >>> browser.getControl(name='form.widgets.logs_limit').value = '25'\n    >>> browser.getControl(name='form.widgets.senviron').value = '{\"foo\":\"bar\"}'\n    >>> browser.getControl('Add').click()\n\nAfter adding the job, it is queued, and we are back to the dashboard::\n\n    >>> 'Crontab Preferences' in browser.contents\n    True\n    >>> 'A new cron was added' in browser.contents\n    True\n    >>> get_jobs()[0]\n    <zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: mycronjob/... [ON:2008-01-01 00:04:00] {u'foo': u'bar'})``>\n\nWe see that as a safety belt the cron is registered two minutes layer.\nEffectivly, the cron reference date is NOW+1 minute when the job has never runned::\n\n    >>> transaction.commit()\n    >>> noecho = [wait_for_result(a, 1) for a in layer['queue']]\n    Traceback (most recent call last):\n    ...\n    AssertionError: job never completed\n\nRunning now the job ::\n\n    >>> set_now(datetime.datetime(2008,1,1,1,4))\n    >>> transaction.commit()\n    >>> noecho = [wait_for_result(a) for a in layer['queue']]\n    >>> MyCronJob.environs\n    [{u'foo': u'bar'}]\n    >>> MyCronJob.runned\n    [1]\n    >>> job = get_jobs()[0]\n    >>> job\n    <zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: mycronjob/... [ON:2008-01-01 00:05:00] (1 logs)...)``>\n\nNow on the behalf of our timemachine, we step forward in time and see that older\ncronjobs are rescheduled to execute now\n\n    >>> set_now(datetime.datetime(2008,1,1,2,0))\n    >>> job == get_jobs()[0]\n    True\n    >>> transaction.commit()\n    >>> job == get_jobs()[0]\n    True\n    >>> noecho = [wait_for_result(a) for a in layer['queue']]\n    >>> MyCronJob.runned\n    [1, 1]\n\nAfter execution the job is rescheduled, always !\n\n    >>> get_jobs()\n    [<zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: mycronjob/... [ON:2008-01-01 01:01:00] (2 logs)...)``>]\n\n\nToggle the cron activation\n++++++++++++++++++++++++++++++++\nDeactivate it::\n\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> browser.getLink('mycronjob').click()\n    >>> browser.getLink(id='edit-cron').click()\n    >>> browser.getControl(name='form.widgets.activated:list').value = []\n    >>> browser.getControl('Apply').click()\n    >>> len(get_jobs()) > 0\n    False\n    >>> transaction.commit()\n\nReactivate it::\n\n   >>> browser.getLink('Cron Dashboard').click()\n   >>> browser.getLink('mycronjob').click()\n   >>> browser.getLink(id='edit-cron').click()\n   >>> browser.getControl(name='form.widgets.activated:list').value = ['selected']\n   >>> browser.getControl('Apply').click()\n   >>> len(get_jobs()) > 0\n   True\n   >>> transaction.commit()\n\nToggle the crontab activation\n++++++++++++++++++++++++++++++++\nDeactivate it by clicking on the deactivate link (javascript link)::\n\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> browser.getForm('cron_toggle_form').submit()\n    >>> len(get_jobs()) > 0\n    False\n    >>> transaction.commit()\n\nReactivate it by clicking on the activate link (javascript link)::\n\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> browser.getForm('cron_toggle_form').submit()\n    >>> len(get_jobs()) > 0\n    True\n    >>> transaction.commit()\n\nEdit a cron\n++++++++++++++\nWe can change the name and some other infos of a cron\n\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> browser.getLink('mycronjob').click()\n    >>> browser.getLink(id='edit-cron').click()\n    >>> browser.getControl(name='form.widgets.name').value = 'myfoojob'\n    >>> browser.getControl(name='form.widgets.periodicity').value = '*/10 * * * *'\n    >>> browser.getControl(name='form.widgets.senviron').value = '{\"foo\":\"moo\"}'\n    >>> browser.getControl('Apply').click()\n    >>> transaction.commit()\n\nOlder jobs have been removed, only the one for this renamed job is present::\n\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> get_jobs()\n    [<zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: myfoojob/... [ON:2008-01-01 01:10:00] (2 logs)...)``>]\n\nTrigger a job execution\n+++++++++++++++++++++++++\nYou can force a job execution on the cron dashboard\n\nTransfert to **2:04**, next job is at **2:10**::\n\n    >>> set_now(datetime.datetime(2008,1,1,2,4))\n    >>> transaction.commit()\n    >>> noecho = [wait_for_result(a, 1) for a in layer['queue']]\n    Traceback (most recent call last):\n    ...\n    AssertionError: job never completed\n    >>> MyCronJob.runned\n    [1, 1]\n\nTo force the run of the job, just go to the cron and click on ``Run``.\nDoing a little hack to reproduce the JS executed by clicking on *\"Run*\"::\n\n    >>> browser.getLink('myfoojob').click()\n    >>> browser.getControl(name='cron_action').value = 'run-cron'\n    >>> browser.getForm('cron_action_form').submit()\n    >>> browser.contents.strip().replace('\\n', ' ')\n    '<!DOCTYPE html...Cron .../myfoojob was queued...\n\nJob has been runned (see the logs increment), and also rescheduled::\n\n    >>> time.sleep(1)\n    >>> transaction.commit()\n    >>> len(MyCronJob.runned) < 3 and wait_for_result(layer['queue'][0], 3) or None\n\n    >>> get_jobs()\n    [<zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: myfoojob/... [ON:2008-01-01 01:10:00] (3 logs)...)``>]\n    >>> MyCronJob.runned\n    [1, 1, 1]\n    >>> MyCronJob.environs[-1]\n    {u'foo': u'moo'}\n\nView & delete a log\n+++++++++++++++++++++\nRun the job 20 times for having a bunch of logs::\n\n    >>> def exec_job():\n    ...     set_now(datetime.datetime(2008,1,1,2,4))\n    ...     cron = get_jobs()[0].args[5]\n    ...     manager = getMultiAdapter((plone, cron), i.ICronManager)\n    ...     manager.register_job(force=True)\n    ...     transaction.commit()\n    ...     return wait_for_result(get_jobs()[0])\n    >>> runned = []\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> runned.append(exec_job())\n    >>> cron = get_jobs()[0].args[5]\n    >>> len(cron.logs)\n    24\n\nLogs are available directlythrought the cron dashboard\nWe see only the last five.\nThey are ordered in FIFO and not via date::\n\n    >>> browser.getLink('myfoojob').click()\n    >>> '10/24 last logs' in browser.contents\n    True\n    >>> browser.getControl(name='logs_to_delete').value = ['14']\n    >>> browser.getControl(name='logdelete').click()\n    >>> 'Selected logs have been deleted' in browser.contents\n    True\n    >>> '10/23 last logs' in browser.contents\n    True\n\nRemoving all logs::\n\n    >>> browser.getControl(name='alllogs_to_delete').value = True\n    >>> browser.getControl(name='logdeletetop').click()\n    >>> 'All logs have been deleted' in browser.contents\n    True\n    >>> 'last logs' in browser.contents\n    False\n\nDelete a cron from the crontab\n++++++++++++++++++++++++++++++++\n::\n\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> browser.getLink('Add a task').click()\n    >>> browser.getControl(name='form.widgets.name').value = 'foodeletecron'\n    >>> browser.getControl(name='form.widgets.periodicity').value = '*/1 * * * *'\n    >>> browser.getControl('Add').click()\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> browser.getLink('foodeletecron').click()\n\nDoing a little hack to reproduce the JS executed by clicking on \"Delete\".\n::\n\n    >>> browser.getControl(name='cron_action').value = 'delete-cron'\n    >>> browser.getForm('cron_action_form').submit()\n    >>> browser.contents.strip().replace('\\n', ' ')\n    '<!DOCTYPE html...Cron .../foodeletecron was deleted...\n\nAnd, we are back to the dashboard::\n\n    >>> browser.url\n    'http://localhost/plone/@@cron-settings'\n\nDelete a cron from the dasboard\n+++++++++++++++++++++++++++++++++++\n::\n    >>> browser.getLink('Cron Dashboard').click()\n    >>> browser.getLink('Add a task').click()\n    >>> browser.getControl(name='form.widgets.name').value = 'foodeletecron'\n    >>> browser.getControl(name='form.widgets.periodicity').value = '*/1 * * * *'\n    >>> browser.getControl('Add').click()\n    >>> browser.getLink('Cron Dashboard').click()\n\nDoing a little hack to reproduce the JS executed by clicking on \"Delete\".\n::\n\n    >>> cron = crontab.Crontab.load().by_name('foodeletecron')[0]\n    >>> browser.getControl(name='uids_to_delete').value = [cron.uid]\n    >>> browser.getControl('Send').click()\n    >>> browser.contents.strip().replace('\\n', ' ')\n    '<!DOCTYPE html...Cron .../foodeletecron was deleted...\n\nAnd, we are back to the dashboard::\n\n    >>> browser.url\n    'http://localhost/plone/@@cron-settings'\n\n\nTeardown\n+++++++++\n::\n\n    >>> bcrt.save()\n    >>> noecho = gsm.unregisterAdapter(MyCronJob, name=\"myfoojob\")\n    >>> noecho = gsm.unregisterAdapter(MyCronJob, name=\"mycronjob\")\n    >>> transaction.commit()\n\n\n\n\nManage (add, edit, remove, run) tasks via Generic Setup\n--------------------------------------------------------\n\n- The configuration file used to configure your crons is ``crons.xml``.\n- You can export crons presents in the site, this will result in a ``crons.xml`` in the output.\n- You can **add**, **edit** or **remove** crons referenced by their ``uid``.\n- If you are adding a cron the mandatory elements are ``uid``, ``name`` & ``periodicity``.\n- If you are editing the mandatory element is ``uid``.\n- You can set the following:\n\n    - uid: **Think to give meaningful & uniques uid, UID is unique identifier!**\n    - name\n    - periodicity\n    - environ (default: **'{}'**)\n    - activated (default: **False**)\n\n- You cannot add logs.\n- if a task is already there with the same uid -> this is an edit.\n\n\nIn the following documentation, we use the api.\nBut of course in the real life, you hust have to:\n\n    - write the crons.xml\n    - run the generisSetup step **collective.cron.setupCrons** on your profile.\n\nsetup\n++++++++\n::\n\n    >>> import time\n    >>> from collective.cron import interfaces as i\n    >>> from collective.cron.testing import set_now\n    >>> from collective.cron import crontab as mcrontab\n    >>> from collective.cron import utils\n    >>> from zope.component import getMultiAdapter\n    >>> import datetime, pytz\n    >>> from zc.async.testing import wait_for_result\n    >>> layer['crontab'].save()\n    >>> import transaction\n    >>> get_jobs = lambda:[a for a in layer['queue']]\n\n\nImport\n++++++++++\n::\n\n    >>> plone = layer['portal']\n    >>> purl = plone.absolute_url()\n    >>> crt = mcrontab.Crontab()\n    >>> exportimport = getMultiAdapter((plone, crt), i.IExportImporter)\n\n\nAdd\n~~~~~\nThe most complete declaration to add or edit is ::\n\n    >>> CRONS = \"\"\"<?xml version=\"1.0\"?>\n    ... <crons>\n    ...   <cron uid=\"foogsuid\" name=\"foo\" activated=\"true\"\n    ...         periodicity=\"*/1 * * * *\" >\n    ...       <environ> <![CDATA[ {\"foo\":\"bar\"} ]]> </environ>\n    ...   </cron>\n    ...   <!-- YOU CAN OMIT ENVIRON  & activated-->\n    ...   <cron uid=\"foogsuid2\" name=\"foo2\" periodicity=\"*/1 * * * *\" />\n    ...   <cron uid=\"foogsuid3\" name=\"foo3\" periodicity=\"*/1 * * * *\" />\n    ... </crons> \"\"\"\n    >>> TZ = pytz.timezone('Europe/Paris')\n    >>> set_now(datetime.datetime(2008,1,1,1,1, tzinfo=TZ))\n    >>> exportimport.do_import(CRONS)\n    >>> crt1 = mcrontab.Crontab.load()\n    >>> crt1.crons\n    OrderedDict([(u'foogsuid', cron: foo/foogsuid [ON:2008-01-01 00:02:00] {u'foo': u'bar'}), (u'foogsuid2', cron: foo2/foogsuid2 [OFF]), (u'foogsuid3', cron: foo3/foogsuid3 [OFF])])\n\nDelete & reregister\n~~~~~~~~~~~~~~~~~~~~~~\nAs always with generic setup to remove a cron, just add a ``remove=\"true\"`` inside the declaration.\nTo remove, just add ``remove=\"true\"`` to the attributes.\nThe order is import as you can re register jobs with same name after::\n\n    >>> CRONSD = \"\"\"<?xml version=\"1.0\"?>\n    ... <crons>\n    ...   <cron uid=\"foogsuid2\" name=\"foo2\" remove=\"true\" periodicity=\"*/1 * * * *\" />\n    ...   <cron uid=\"foogsuid2\" name=\"foo2changed\" periodicity=\"*/3 * * * *\"/>\n    ...   <cron uid=\"foogsuid3\" remove=\"true\"/>\n    ... </crons> \"\"\"\n    >>> exportimport.do_import(CRONSD)\n    >>> crt2 = mcrontab.Crontab.load()\n    >>> crt2.crons\n    OrderedDict([(u'foogsuid', cron: foo/foogsuid [ON:2008-01-01 00:02:00] {u'foo': u'bar'}), (u'foogsuid2', cron: foo2changed/foogsuid2 [OFF])])\n\nEdit\n~~~~~~~~~~\nYou can edit every part of a cron::\n\n    >>> CRONSE = \"\"\"<?xml version=\"1.0\"?>\n    ... <crons>\n    ...   <cron uid=\"foogsuid2\" name=\"foo2edite\u00e9\" activated=\"True\"  periodicity=\"*/4 * * * *\">\n    ...       <environ><![CDATA[ {\"foo\":\"bar\", \"miche\":\"muche\"} ]]></environ>\n    ...   </cron>\n    ... </crons> \"\"\"\n    >>> exportimport.do_import(CRONSE)\n    >>> crt3 = mcrontab.Crontab.load()\n    >>> crt3.crons\n    OrderedDict([(u'foogsuid', cron: foo/foogsuid [ON:2008-01-01 00:02:00] {u'foo': u'bar'}), (u'foogsuid2', cron: foo2edite\u00e9/foogsuid2 [ON:2008-01-01 00:04:00] {u'foo': u'bar', u'miche': u'muche'})])\n\nExport\n++++++\nYou can also export crons present in the site::\n\n    >>> ret = exportimport.do_export()\n    >>> waited = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    ... <crons>\n    ...   <cron uid=\"foogsuid\" name=\"foo\" activated=\"True\" periodicity=\"*/1 * * * *\">\n    ...     <environ><![CDATA[\n    ... {\"foo\": \"bar\"}\n    ... ]]>\n    ...     </environ>\n    ...   </cron>\n    ...   <cron uid=\"foogsuid2\" name=\"foo2edite\u00e9\" activated=\"True\" periodicity=\"*/4 * * * *\">\n    ...     <environ><![CDATA[\n    ... {\"miche\": \"muche\", \"foo\": \"bar\"}\n    ... ]]>\n    ...     </environ>\n    ...   </cron>\n    ... </crons>\"\"\"\n    >>> ret == waited\n    True\n\nTeardown\n+++++++++++\n::\n\n    >>> layer['crontab'].save()\n\n\n\nChangelog\n============\n\n\n2.8 (2018-04-05)\n----------------\n\n- Add a fake request so code called that expects a request will still work [dmarks]\n- Allow python scripts and other TTW code to be called from collective.cron [djay]\n\n\n2.7 (2013-02-18)\n----------------\n\n- Fix various github bugs (typos, install setup, dependencies) [kiorky, gforcada, khink]\n\n\n2.6 (2012-11-11)\n----------------\n\n- fix #1 & #2 [kiorky]\n\n\n2.5 (2012-10-28)\n----------------\n\n- optimize API to get job status infos [kiorky]\n- make better robust code [kiorky]\n\n\n2.4 (2012-10-14)\n----------------\n- Add a log limit property to logs to limit memory & other resources usage [kiorky]\n- Performance tweaks [kiorky]\n\n\n2.3 (2012-10-11)\n----------------\n- better registry handling [kiorky]\n- better jobrunner [kiorky]\n- better tests  [kiorky]\n- make install and restart code more robust, again [kiorky]\n\n2.2 (2012-10-11)\n----------------\n\n- make install and restart code more robust.\n  This is **release codename Wine**. A really thanks to Andreas Jung which helped me to find a difficult bug\n  with ZODB transactions. (call transaction.savepoint to make _p_jar which was None to appear).\n  [kiorky]\n\n\n2.1 (2012-10-10)\n----------------\n\n- better tests for addons consumers [kiorky]\n\n\n2.0 (2012-10-10)\n----------------\n- Rewrite collective.cron for better robustness, documentation & no extra dependencies on content types\n  [kiorky]\n\n\n\n1.0 (2011)\n----------------\n- First release\n\n\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/collective.cron", "keywords": "", "license": "GPL", "maintainer": "", "maintainer_email": "", "name": "collective.cron", "package_url": "https://pypi.org/project/collective.cron/", "platform": "", "project_url": "https://pypi.org/project/collective.cron/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/collective.cron"}, "release_url": "https://pypi.org/project/collective.cron/2.8/", "requires_dist": null, "requires_python": "", "summary": "Product that enable cron like jobs for plone", "version": "2.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            Introduction<br>============<br><br>.. contents::<br><br>collective.cron is a cron-like asynchronous tasks system based on top of plone.app.async and plone.app.registry.<br>The implementation does not have for now all the bells and wistles of a nice UI.<br>However the simple interface does all the stuff and the underlying job manager works reliably.<br><br>Finaly, you can register your tasks easily.<br><br><br>Note that at the moment, we have 100% test coverage. This do not prevent bugs altogether, but it keeps us from making big mistakes.<br><br>The design is modern and modular, imagine that you can even easily change from plone.app.async to another job system.<br><br>The buildout infrastructure<br>===========================<br>- base.cfg                -&gt; base buildout informations<br>- buildout.cfg            -&gt; base buildout for the current plone version<br>- test-4.0.x.cfg          -&gt; test buildout for plone4.0<br>- test-4.1.x.cfg          -&gt; test buildout for plone4.1<br>- test-4.2.x.cfg          -&gt; test buildout for plone4.2<br><br>The most important things are in base.cfg.<br>If you plan to integrate collective.cron to your buildout, please refer to the plone.app.async documentation.<br><br>- For now we use the unreleased version of plone.app.async : https://github.com/plone/plone.app.async<br><br>Note for tests<br>==============<br>- Tests can unpredictibly crash because of monkey patchs to datetime.<br>  This is a false positive. Just relaunch them if you see something similar ::<br><br>      ConflictError: database conflict error (oid 0x2549d9dd3cf6b59b, serial this txn started with 0x0399e4b3adb993bb 2012-10-14 09:23:40.716776, serial currently committed 0x0399e4b3ae733c77 2012-10-14 09:23:40.886752)<br><br>collective.cron 1.0 =&gt; collective.cron 2.0<br>==========================================<br>- in 1.0, each cron task was a content.<br>  This was then tedious to replicate and maintain accross multiple instances and plone versions.<br>  One of the goal of collective.cron 2.0 is to avoid at most to have persistance, specially specialized contents to minimize all the common migration problems we have with an objects database.<br>  Thus a choice has been made to heavily use plone.app.registry as a configuration backend.<br><br>- Thus, there is no migration prepared from collective.cron 1.0 to 2.0<br>  It is up to you to do it.<br>  Specially, you will have to clean the database of all specific collective.cron 1.0 based &amp; persistent content before upgrading.<br>  Indeed, as the design of tasks is really different, we can't do any automatic migration.<br><br>- First with collective.cron 1.x in your buildout<br><br>        - Search, record settings then delete all IBackend content<br>        - Delete all jobresults &amp; persistent contents<br>        - Cleanup all the zc.async queue<br><br>- Next, deactivate collective.cron 1.x and activate collective.cron 2.x in your buildout<br><br>    - Adapt your adapters and content types to work with collective.cron 2.0 (inputs/mark items to work on)<br>    - add equivalent crons records to the crontab setting of the backends job<br><br>Credits<br>========<br>Companies<br>---------<br>|makinacom|_<br><br>  * `Planet Makina Corpus &lt;http://www.makina-corpus.org&gt;`_<br>  * `Contact us &lt;mailto:python@makina-corpus.org&gt;`_<br><br>.. |makinacom| image:: http://depot.makina-corpus.org/public/logo.gif<br>.. _makinacom:  http://www.makina-corpus.com<br><br>Authors<br>-------<br><br>- kiorky  &lt;kiorky@cryptelium.net&gt;<br><br>Contributors<br>------------<br><br>- djay &lt;software@pretaweb.com&gt;<br><br>Repository<br>==========<br><br>- `github &lt;https://github.com/collective/collective.cron&gt;`_<br><br><br>Design<br>======<br>- collective.cron lets you register crons which run periodically in your system.<br>- Each plone site has a crontab.<br>- This crontab is used by many components to execute the cron jobs.<br>- There is a central dashboard which will list all tasks registered on the site crontab.<br>- The tasks configuration is based on plone.app.registry but is designed to be replaceable (component).<br>- The tasks execution is based on plone.app.async but is designed to be also replaceable (component).<br><br>- The cron manager will ensure to restore all cron jobs for all plone sites at zope restart.<br><br>Crontab<br>-------<br>A crontab is the collection of all cron registered to a plone site.<br>A crontab can be (de)activated globally.<br>Each crontab sub element (the crontab, the crons &amp; associated logs) defines a dump method which creates a JSON representation of the object.<br><br>The major attributes for a crontab are:<br><br>    - crons: An ordered dict of crons. Key is the cron uid<br>    - activated: globally power switch for the crontab<br>    - manager: the manager is responsible for the crontab persistence<br>    - save(): save the crontab<br>    - save_cron(cron): save the cron<br><br>When a crontab is saved, it emits a ``ModifiedCrontabEvent``.<br><br>Cron<br>----<br>The major attributes for a cron are:<br><br>    - **name**: will be the queried name to search jobs. Via adaption or traversal.<br>    - **periodicity**: give the next time execution<br>    - **environ**: An optionnal jsonencoded mapping of values which will be given to the task<br>    - **logs_limit**: logs to keep (default : 5, limit : 25)<br>    - uid: internal id for the crontab machinery<br>    - user: the user the task will run as, its up to you to make the task run as this user<br>    - activated: the activation status of the cron<br>    - logs: give the last logs of the cron prior executions from most recent to older<br>    - crontab: A possibly null reference to the parent crontab<br><br>A note on the user which is only **a stocked value**. you can see ``collective.cron.utils.su_plone`` to help you switch to that user.<br>IT IS UP TO YOU TO SWITCH TO THAT USER **IN YOUR JOBRUNNER**.<br><br>Log<br>---<br>The major attributes for a log are:<br><br>    - date: date of logging<br>    - status: status ::= NOTRUN | FAILURE | WARN | OK<br>    - message: the logs<br><br>Crontab registry manager<br>------------------------<br>Based on top of plone.app.registry, collective.cron record the crontab current status in the site registry.<br>It adapts a crontab.<br><br>    - activated: boolean switch status of the crontab<br>    - cronsettings: the raw manager settings (.crontab, .activated)<br>    - crons: list of serialized strings representations of the crons<br>    - read_only: if true, changes will be a NOOP<br><br>When a record is touched (added, edited, removed), events are fired to syncronize the queue.<br><br>Crontab manager<br>---------------<br>This component is responsible when a CrontabSynchronisationEvent is fired to synchronise the crontab with the job queuing system.<br>It will remove unrelated jobs and schedule new jobs.<br>It adapts a plonesite and a crontab.<br><br>When the crontab is saved emits a ``ModifiedCrontabEvent`` which in turns is redirected as a ``CrontabSynchronisationEvent`` to let the manager synchronize the queue.<br><br>When the server restarts, a ``ServerRestartEvent`` is called to re-register any cron job that would have been wiped from the queue.<br><br>Cron manager<br>------------<br>This component is responsible for the execution and presence in the queue of a particular cronjob. It can register or remove the job execution of a cron.<br>This is a friendly proxy to the \"Queue manager\".<br><br>It adapts a plonesite and a cron.<br><br>When a cronjob is registered, the job queued is a cron jobrunner wrapper responsible for:<br><br>    - Sending a ``StartedCronJobEvent``<br>    - Running the relevant JobRunner (a named adapter adapting the plonesite, and the cron)<br>    - Sending a ``FinishedCronJobEvent``<br>    - logging the execution<br>    - Scheduling the next execution<br><br>JobRunner<br>---------<br>A cron jobrunner is either a named adapter which:<br>    - adapts the plonesite and the current cron<br>    - implements IJobRunbner, and specially defines a **run** method.<br>or is a traversal script which takes no paramaters<br><br>For adapter based Runners a base class exists in collective cron, just inherit from it.<br>This is a complicated definition to have a class like this::<br><br>    from collective.cron import crontab<br>    class MyCronJob(crontab.Runner):<br>        def run(self):<br>            print \"foo\"<br><br>Registered in zcml like that::<br><br>    &lt;adapter factory=\".module.MyCronJob\" name=\"mycronjob\"/&gt;<br><br>And then, you will have to register a cron called ``mycronjob`` in your plonesite.<br><br>For PythonScript based runners give your cron a name which is the relative path of<br>your script to the portal base.<br><br>Queue manager<br>-------------<br>This component will manage the jobs inside the job queue.<br>You will have enough methods to know for a specific cron if a job is present, what is its status...<br><br>You can also register, or delete items from the running queue<br>It adapts a plonesite.<br><br>Crontab Queue Marker (plone.app.async specific)<br>-----------------------------------------------<br>Responsible to mark infos in the async queue to make the reload of jobs at Zope restart possible.<br><br>Detailed documentation<br>======================<br>There are 3 ways to register tasks:<br><br>    - via the API<br>    - via the UI<br>    - via Generic Setup (profile)<br><br><br><br><br><br>Manage (add, edit, remove, run) tasks via collective.cron API<br>--------------------------------------------------------------<br><br>setup<br>++++++++<br>::<br><br>    &gt;&gt;&gt; import time<br>    &gt;&gt;&gt; from collective.cron import interfaces as i<br>    &gt;&gt;&gt; from collective.cron.testing import set_now<br>    &gt;&gt;&gt; from collective.cron import crontab as mcrontab<br>    &gt;&gt;&gt; from collective.cron import utils<br>    &gt;&gt;&gt; import datetime, pytz<br>    &gt;&gt;&gt; from zc.async.testing import wait_for_result<br>    &gt;&gt;&gt; layer['crontab'].save()<br>    &gt;&gt;&gt; import transaction<br>    &gt;&gt;&gt; get_jobs = lambda:[a for a in layer['queue']]<br><br>Creation of a jobrunner<br>+++++++++++++++++++++++++++<br>We will define a cronjob to execute on the next scheduled tasks behalf.<br>Here we register global adapters, but you can of course register local adapters on a specific plonesite and they will be taken up::<br><br>    &gt;&gt;&gt; plone = layer['portal']<br>    &gt;&gt;&gt; purl = plone.absolute_url()<br>    &gt;&gt;&gt; from collective.cron import crontab<br>    &gt;&gt;&gt; class MyCronJob(crontab.Runner):<br>    ...     runned = []<br>    ...     environs = []<br>    ...     def run(self):<br>    ...         self.runned.append(1) # mutable list will be shared among all instances<br>    ...         self.environs.append(self.cron.environ)<br>    &gt;&gt;&gt; from zope.component import getGlobalSiteManager<br>    &gt;&gt;&gt; gsm = getGlobalSiteManager()<br>    &gt;&gt;&gt; gsm.registerAdapter(MyCronJob, name=\"mycronjob\")<br>    &gt;&gt;&gt; gsm.registerAdapter(MyCronJob, name=\"myfoojob\")<br><br>The top object of the crontab, is ... the Crontab.<br>Calling load make the Crontab object and reflect the registry configuration inside it.<br>You ll have to do that::<br><br>    &gt;&gt;&gt; bcrt = mcrontab.Crontab.load()<br>    &gt;&gt;&gt; bcrt.crons<br>    OrderedDict([(u'...', cron: testcron/... [ON:...])])<br><br>Think that you can configure tasks with a dict of simple values (they must be json encodable) for your jobs runners to parameterize the task.<br><br><br>Adding crons to the crontab<br>+++++++++++++++++++++++++++++<br>We will add the related crontab to the plone site in the cron dashboard::<br><br>    &gt;&gt;&gt; dstart = datetime.datetime(2008,1,1,1,3)<br>    &gt;&gt;&gt; set_now(dstart)<br>    &gt;&gt;&gt; crt = mcrontab.Crontab()<br>    &gt;&gt;&gt; cron = mcrontab.Cron(name=u'mycronjob',<br>    ...         activated=True,<br>    ...         periodicity = u'*/1 * * * *',<br>    ...         environ={u'foo':u'bar'},<br>    ...         crontab=crt)<br>    &gt;&gt;&gt; cron<br>    cron: mycronjob/... [ON:2008-01-01 00:04:00] {u'foo': u'bar'}<br><br>Never register a cron to two crontab, the cron and crontab have an internal link to each other.<br>If you want to replicate crons between crontab objects, dump them::<br><br>    &gt;&gt;&gt; crt2 = mcrontab.Crontab()<br>    &gt;&gt;&gt; crt2.add_cron(mcrontab.Cron.load(cron.dump()))<br><br>Similar check all the cron properties except crontab &amp; logs::<br><br>    &gt;&gt;&gt; crt2.by_name('mycronjob')[0].similar(cron)<br>    True<br><br>You have three methods to search crons in crontab:<br><br>    - by( ``**`` kwargs) : find all cron matching the infos given in kwargs (see cron constructor)<br>    - by_name(value) : give all cron matching name<br>    - by_uid(value) : give the cron registered with uid<br><br>Record the craontab back into the site to register the jobs when you are done::<br><br>    &gt;&gt;&gt; crt.save()<br>    &gt;&gt;&gt; transaction.commit()<br><br>After adding the job, it is queued::<br><br>    &gt;&gt;&gt; get_jobs()[0]<br>    &lt;zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'test_user_1_', collective.cron.crontab.runJob, cron: mycronjob/... [ON:2008-01-01 00:04:00]...)``&gt;<br><br>Toggle the cron activation<br>++++++++++++++++++++++++++++++++<br>At the cron level::<br><br>    &gt;&gt;&gt; cron.activated = False<br>    &gt;&gt;&gt; crt.save()<br>    &gt;&gt;&gt; cron.activated = True<br>    &gt;&gt;&gt; len(get_jobs()) &gt; 0<br>    False<br><br>Reactivate::<br><br>    &gt;&gt;&gt; cron.activated = True<br>    &gt;&gt;&gt; crt.save()<br>    &gt;&gt;&gt; len(get_jobs()) &gt; 0<br>    True<br><br>Globally, at the crontab level (for all crons)::<br><br>    &gt;&gt;&gt; crt.activated = False<br>    &gt;&gt;&gt; crt.save()<br>    &gt;&gt;&gt; len(get_jobs()) &gt; 0<br>    False<br><br>Reactivate::<br><br>    &gt;&gt;&gt; crt.activated = True<br>    &gt;&gt;&gt; crt.save()<br>    &gt;&gt;&gt; len(get_jobs()) &gt; 0<br>    True<br><br>Edit a cron<br>+++++++++++++<br>We can change the name and some other infos of a cron<br><br>    &gt;&gt;&gt; cron.name = u'myfoojob'<br>    &gt;&gt;&gt; cron.periodicity = u'*/10 * * * *'<br>    &gt;&gt;&gt; crt.save()<br><br>Older jobs have been removed, only the one for this renamed job is present::<br><br>    &gt;&gt;&gt; get_jobs()<br>    [&lt;zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'test_user_1_', collective.cron.crontab.runJob, cron: myfoojob/... [ON:2008-01-01 00:10:00]...)``&gt;]<br><br>Trigger a job execution<br>++++++++++++++++++++++++++<br>You can force a job execution by using the  ``CronManager`` composant::<br><br>    &gt;&gt;&gt; set_now(datetime.datetime(2008,1,1,2,4))<br>    &gt;&gt;&gt; manager = getMultiAdapter((plone, cron), i.ICronManager)<br>    &gt;&gt;&gt; manager.register_job(force=True)<br>    True<br>    &gt;&gt;&gt; transaction.commit()<br><br>The job return the status, the messages, the uid of the cron and the plone portal path (tuple)::<br><br>    &gt;&gt;&gt; wait_for_result(get_jobs()[0])<br>    (1, [], u'...', ('', 'plone'))<br>    &gt;&gt;&gt; MyCronJob.runned<br>    [1]<br>    &gt;&gt;&gt; MyCronJob.environs[-1]<br>    {u'foo': u'bar'}<br><br>And the job is rescheduled::<br><br>    &gt;&gt;&gt; get_jobs()<br>    [&lt;zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'test_user_1_', collective.cron.crontab.runJob, cron: myfoojob/... [ON:2008-01-01 01:10:00] (1 logs)...)``&gt;]<br>    &gt;&gt;&gt; transaction.commit()<br><br><br>View &amp; delete a log<br>++++++++++++++++++++<br>Save the current state::<br><br>    &gt;&gt;&gt; runnedcron = get_jobs()[0].args[5]<br>    &gt;&gt;&gt; runnedcron.save()<br>    &gt;&gt;&gt; ncron = crontab.Crontab.load().by_uid(cron.uid)<br><br>View::<br><br>    &gt;&gt;&gt; ncron.logs<br>    [log: 2008-01-01 02:04:00/OK]<br><br>Delete::<br><br>    &gt;&gt;&gt; noecho = ncron.logs.pop(0)<br>    &gt;&gt;&gt; ncron.save()<br><br>Delete a cron from the crontab<br>++++++++++++++++++++++++++++++++++<br>Simply delete it from the crons indexed by uid::<br><br>    &gt;&gt;&gt; del crt.crons[cron.uid]<br>    &gt;&gt;&gt; crt.save()<br>    &gt;&gt;&gt; get_jobs()<br>    []<br><br><br>Teardown<br>+++++++++<br>::<br><br>    &gt;&gt;&gt; bcrt.save()<br>    &gt;&gt;&gt; noecho = gsm.unregisterAdapter(MyCronJob, name=\"myfoojob\")<br>    &gt;&gt;&gt; noecho = gsm.unregisterAdapter(MyCronJob, name=\"mycronjob\")<br>    &gt;&gt;&gt; transaction.commit()<br><br><br><br><br>Manage (add, edit, remove, run) tasks via the web interface<br>-------------------------------------------------------------<br><br>setup<br>++++++++<br>::<br><br>    &gt;&gt;&gt; import lxml<br>    &gt;&gt;&gt; import time<br>    &gt;&gt;&gt; from collective.cron import interfaces as i<br>    &gt;&gt;&gt; from collective.cron.testing import set_now<br>    &gt;&gt;&gt; from collective.cron import crontab as mcrontab<br>    &gt;&gt;&gt; from collective.cron import utils<br>    &gt;&gt;&gt; import datetime, pytz<br>    &gt;&gt;&gt; layer['crontab'].save()<br>    &gt;&gt;&gt; from zc.async.testing import wait_for_result<br>    &gt;&gt;&gt; import transaction<br>    &gt;&gt;&gt; get_jobs = lambda:[a for a in layer['queue']]<br>    &gt;&gt;&gt; bcrt = mcrontab.Crontab.load()<br>    &gt;&gt;&gt; crt = mcrontab.Crontab()<br>    &gt;&gt;&gt; crt.save()<br>    &gt;&gt;&gt; transaction.commit()<br><br>Creation of a jobrunner<br>++++++++++++++++++++++++++<br>We will define a cronjob to execute on the next scheduled tasks behalf<br>Think that you can make generic tasks which can be configured by the environ json mapping that you configure along with the cron task.<br>When the job is runned you can access it by ``self.cron.environ``.<br>::<br><br>    &gt;&gt;&gt; plone = layer['portal']<br>    &gt;&gt;&gt; purl = plone.absolute_url()<br>    &gt;&gt;&gt; from collective.cron import crontab<br>    &gt;&gt;&gt; class MyCronJob(crontab.Runner):<br>    ...     runned = []<br>    ...     environs = []<br>    ...     def run(self):<br>    ...         self.runned.append(1) # mutable list will be shared among all instances<br>    ...         self.environs.append(self.cron.environ) # mutable list will be shared among all instances<br>    &gt;&gt;&gt; from zope.component import getGlobalSiteManager<br>    &gt;&gt;&gt; gsm = getGlobalSiteManager()<br>    &gt;&gt;&gt; gsm.registerAdapter(MyCronJob, name=\"mycronjob\")<br>    &gt;&gt;&gt; gsm.registerAdapter(MyCronJob, name=\"myfoojob\")<br><br>Registering a job through the interface<br>++++++++++++++++++++++++++++++++++++++++++<br><br>We will add the related crontab to the plone site in the cron dashboard::<br><br>    &gt;&gt;&gt; dstart = datetime.datetime(2008,1,1,1,3)<br>    &gt;&gt;&gt; set_now(dstart)<br>    &gt;&gt;&gt; browser = Browser.new(purl, login=True)<br>    &gt;&gt;&gt; browser.handleErrors = False<br>    &gt;&gt;&gt; browser.getLink('Site Setup').click()<br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; '@@cron-settings' in browser.contents<br>    True<br>    &gt;&gt;&gt; browser.getLink('Add a task').click()<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.name').value = 'mycronjob'<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.periodicity').value = '*/1 * * * *'<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.logs_limit').value = '25'<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.senviron').value = '{\"foo\":\"bar\"}'<br>    &gt;&gt;&gt; browser.getControl('Add').click()<br><br>After adding the job, it is queued, and we are back to the dashboard::<br><br>    &gt;&gt;&gt; 'Crontab Preferences' in browser.contents<br>    True<br>    &gt;&gt;&gt; 'A new cron was added' in browser.contents<br>    True<br>    &gt;&gt;&gt; get_jobs()[0]<br>    &lt;zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: mycronjob/... [ON:2008-01-01 00:04:00] {u'foo': u'bar'})``&gt;<br><br>We see that as a safety belt the cron is registered two minutes layer.<br>Effectivly, the cron reference date is NOW+1 minute when the job has never runned::<br><br>    &gt;&gt;&gt; transaction.commit()<br>    &gt;&gt;&gt; noecho = [wait_for_result(a, 1) for a in layer['queue']]<br>    Traceback (most recent call last):<br>    ...<br>    AssertionError: job never completed<br><br>Running now the job ::<br><br>    &gt;&gt;&gt; set_now(datetime.datetime(2008,1,1,1,4))<br>    &gt;&gt;&gt; transaction.commit()<br>    &gt;&gt;&gt; noecho = [wait_for_result(a) for a in layer['queue']]<br>    &gt;&gt;&gt; MyCronJob.environs<br>    [{u'foo': u'bar'}]<br>    &gt;&gt;&gt; MyCronJob.runned<br>    [1]<br>    &gt;&gt;&gt; job = get_jobs()[0]<br>    &gt;&gt;&gt; job<br>    &lt;zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: mycronjob/... [ON:2008-01-01 00:05:00] (1 logs)...)``&gt;<br><br>Now on the behalf of our timemachine, we step forward in time and see that older<br>cronjobs are rescheduled to execute now<br><br>    &gt;&gt;&gt; set_now(datetime.datetime(2008,1,1,2,0))<br>    &gt;&gt;&gt; job == get_jobs()[0]<br>    True<br>    &gt;&gt;&gt; transaction.commit()<br>    &gt;&gt;&gt; job == get_jobs()[0]<br>    True<br>    &gt;&gt;&gt; noecho = [wait_for_result(a) for a in layer['queue']]<br>    &gt;&gt;&gt; MyCronJob.runned<br>    [1, 1]<br><br>After execution the job is rescheduled, always !<br><br>    &gt;&gt;&gt; get_jobs()<br>    [&lt;zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: mycronjob/... [ON:2008-01-01 01:01:00] (2 logs)...)``&gt;]<br><br><br>Toggle the cron activation<br>++++++++++++++++++++++++++++++++<br>Deactivate it::<br><br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; browser.getLink('mycronjob').click()<br>    &gt;&gt;&gt; browser.getLink(id='edit-cron').click()<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.activated:list').value = []<br>    &gt;&gt;&gt; browser.getControl('Apply').click()<br>    &gt;&gt;&gt; len(get_jobs()) &gt; 0<br>    False<br>    &gt;&gt;&gt; transaction.commit()<br><br>Reactivate it::<br><br>   &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>   &gt;&gt;&gt; browser.getLink('mycronjob').click()<br>   &gt;&gt;&gt; browser.getLink(id='edit-cron').click()<br>   &gt;&gt;&gt; browser.getControl(name='form.widgets.activated:list').value = ['selected']<br>   &gt;&gt;&gt; browser.getControl('Apply').click()<br>   &gt;&gt;&gt; len(get_jobs()) &gt; 0<br>   True<br>   &gt;&gt;&gt; transaction.commit()<br><br>Toggle the crontab activation<br>++++++++++++++++++++++++++++++++<br>Deactivate it by clicking on the deactivate link (javascript link)::<br><br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; browser.getForm('cron_toggle_form').submit()<br>    &gt;&gt;&gt; len(get_jobs()) &gt; 0<br>    False<br>    &gt;&gt;&gt; transaction.commit()<br><br>Reactivate it by clicking on the activate link (javascript link)::<br><br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; browser.getForm('cron_toggle_form').submit()<br>    &gt;&gt;&gt; len(get_jobs()) &gt; 0<br>    True<br>    &gt;&gt;&gt; transaction.commit()<br><br>Edit a cron<br>++++++++++++++<br>We can change the name and some other infos of a cron<br><br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; browser.getLink('mycronjob').click()<br>    &gt;&gt;&gt; browser.getLink(id='edit-cron').click()<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.name').value = 'myfoojob'<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.periodicity').value = '*/10 * * * *'<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.senviron').value = '{\"foo\":\"moo\"}'<br>    &gt;&gt;&gt; browser.getControl('Apply').click()<br>    &gt;&gt;&gt; transaction.commit()<br><br>Older jobs have been removed, only the one for this renamed job is present::<br><br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; get_jobs()<br>    [&lt;zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: myfoojob/... [ON:2008-01-01 01:10:00] (2 logs)...)``&gt;]<br><br>Trigger a job execution<br>+++++++++++++++++++++++++<br>You can force a job execution on the cron dashboard<br><br>Transfert to **2:04**, next job is at **2:10**::<br><br>    &gt;&gt;&gt; set_now(datetime.datetime(2008,1,1,2,4))<br>    &gt;&gt;&gt; transaction.commit()<br>    &gt;&gt;&gt; noecho = [wait_for_result(a, 1) for a in layer['queue']]<br>    Traceback (most recent call last):<br>    ...<br>    AssertionError: job never completed<br>    &gt;&gt;&gt; MyCronJob.runned<br>    [1, 1]<br><br>To force the run of the job, just go to the cron and click on ``Run``.<br>Doing a little hack to reproduce the JS executed by clicking on *\"Run*\"::<br><br>    &gt;&gt;&gt; browser.getLink('myfoojob').click()<br>    &gt;&gt;&gt; browser.getControl(name='cron_action').value = 'run-cron'<br>    &gt;&gt;&gt; browser.getForm('cron_action_form').submit()<br>    &gt;&gt;&gt; browser.contents.strip().replace('\\n', ' ')<br>    '&lt;!DOCTYPE html...Cron .../myfoojob was queued...<br><br>Job has been runned (see the logs increment), and also rescheduled::<br><br>    &gt;&gt;&gt; time.sleep(1)<br>    &gt;&gt;&gt; transaction.commit()<br>    &gt;&gt;&gt; len(MyCronJob.runned) &lt; 3 and wait_for_result(layer['queue'][0], 3) or None<br><br>    &gt;&gt;&gt; get_jobs()<br>    [&lt;zc.async.job.Job (oid ..., db 'async') ``plone.app.async.service._executeAsUser(('', 'plone'), ('', 'plone'), ('', 'plone', 'acl_users'), 'plonemanager', collective.cron.crontab.runJob, cron: myfoojob/... [ON:2008-01-01 01:10:00] (3 logs)...)``&gt;]<br>    &gt;&gt;&gt; MyCronJob.runned<br>    [1, 1, 1]<br>    &gt;&gt;&gt; MyCronJob.environs[-1]<br>    {u'foo': u'moo'}<br><br>View &amp; delete a log<br>+++++++++++++++++++++<br>Run the job 20 times for having a bunch of logs::<br><br>    &gt;&gt;&gt; def exec_job():<br>    ...     set_now(datetime.datetime(2008,1,1,2,4))<br>    ...     cron = get_jobs()[0].args[5]<br>    ...     manager = getMultiAdapter((plone, cron), i.ICronManager)<br>    ...     manager.register_job(force=True)<br>    ...     transaction.commit()<br>    ...     return wait_for_result(get_jobs()[0])<br>    &gt;&gt;&gt; runned = []<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; runned.append(exec_job())<br>    &gt;&gt;&gt; cron = get_jobs()[0].args[5]<br>    &gt;&gt;&gt; len(cron.logs)<br>    24<br><br>Logs are available directlythrought the cron dashboard<br>We see only the last five.<br>They are ordered in FIFO and not via date::<br><br>    &gt;&gt;&gt; browser.getLink('myfoojob').click()<br>    &gt;&gt;&gt; '10/24 last logs' in browser.contents<br>    True<br>    &gt;&gt;&gt; browser.getControl(name='logs_to_delete').value = ['14']<br>    &gt;&gt;&gt; browser.getControl(name='logdelete').click()<br>    &gt;&gt;&gt; 'Selected logs have been deleted' in browser.contents<br>    True<br>    &gt;&gt;&gt; '10/23 last logs' in browser.contents<br>    True<br><br>Removing all logs::<br><br>    &gt;&gt;&gt; browser.getControl(name='alllogs_to_delete').value = True<br>    &gt;&gt;&gt; browser.getControl(name='logdeletetop').click()<br>    &gt;&gt;&gt; 'All logs have been deleted' in browser.contents<br>    True<br>    &gt;&gt;&gt; 'last logs' in browser.contents<br>    False<br><br>Delete a cron from the crontab<br>++++++++++++++++++++++++++++++++<br>::<br><br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; browser.getLink('Add a task').click()<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.name').value = 'foodeletecron'<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.periodicity').value = '*/1 * * * *'<br>    &gt;&gt;&gt; browser.getControl('Add').click()<br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; browser.getLink('foodeletecron').click()<br><br>Doing a little hack to reproduce the JS executed by clicking on \"Delete\".<br>::<br><br>    &gt;&gt;&gt; browser.getControl(name='cron_action').value = 'delete-cron'<br>    &gt;&gt;&gt; browser.getForm('cron_action_form').submit()<br>    &gt;&gt;&gt; browser.contents.strip().replace('\\n', ' ')<br>    '&lt;!DOCTYPE html...Cron .../foodeletecron was deleted...<br><br>And, we are back to the dashboard::<br><br>    &gt;&gt;&gt; browser.url<br>    'http://localhost/plone/@@cron-settings'<br><br>Delete a cron from the dasboard<br>+++++++++++++++++++++++++++++++++++<br>::<br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br>    &gt;&gt;&gt; browser.getLink('Add a task').click()<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.name').value = 'foodeletecron'<br>    &gt;&gt;&gt; browser.getControl(name='form.widgets.periodicity').value = '*/1 * * * *'<br>    &gt;&gt;&gt; browser.getControl('Add').click()<br>    &gt;&gt;&gt; browser.getLink('Cron Dashboard').click()<br><br>Doing a little hack to reproduce the JS executed by clicking on \"Delete\".<br>::<br><br>    &gt;&gt;&gt; cron = crontab.Crontab.load().by_name('foodeletecron')[0]<br>    &gt;&gt;&gt; browser.getControl(name='uids_to_delete').value = [cron.uid]<br>    &gt;&gt;&gt; browser.getControl('Send').click()<br>    &gt;&gt;&gt; browser.contents.strip().replace('\\n', ' ')<br>    '&lt;!DOCTYPE html...Cron .../foodeletecron was deleted...<br><br>And, we are back to the dashboard::<br><br>    &gt;&gt;&gt; browser.url<br>    'http://localhost/plone/@@cron-settings'<br><br><br>Teardown<br>+++++++++<br>::<br><br>    &gt;&gt;&gt; bcrt.save()<br>    &gt;&gt;&gt; noecho = gsm.unregisterAdapter(MyCronJob, name=\"myfoojob\")<br>    &gt;&gt;&gt; noecho = gsm.unregisterAdapter(MyCronJob, name=\"mycronjob\")<br>    &gt;&gt;&gt; transaction.commit()<br><br><br><br><br>Manage (add, edit, remove, run) tasks via Generic Setup<br>--------------------------------------------------------<br><br>- The configuration file used to configure your crons is ``crons.xml``.<br>- You can export crons presents in the site, this will result in a ``crons.xml`` in the output.<br>- You can **add**, **edit** or **remove** crons referenced by their ``uid``.<br>- If you are adding a cron the mandatory elements are ``uid``, ``name`` &amp; ``periodicity``.<br>- If you are editing the mandatory element is ``uid``.<br>- You can set the following:<br><br>    - uid: **Think to give meaningful &amp; uniques uid, UID is unique identifier!**<br>    - name<br>    - periodicity<br>    - environ (default: **'{}'**)<br>    - activated (default: **False**)<br><br>- You cannot add logs.<br>- if a task is already there with the same uid -&gt; this is an edit.<br><br><br>In the following documentation, we use the api.<br>But of course in the real life, you hust have to:<br><br>    - write the crons.xml<br>    - run the generisSetup step **collective.cron.setupCrons** on your profile.<br><br>setup<br>++++++++<br>::<br><br>    &gt;&gt;&gt; import time<br>    &gt;&gt;&gt; from collective.cron import interfaces as i<br>    &gt;&gt;&gt; from collective.cron.testing import set_now<br>    &gt;&gt;&gt; from collective.cron import crontab as mcrontab<br>    &gt;&gt;&gt; from collective.cron import utils<br>    &gt;&gt;&gt; from zope.component import getMultiAdapter<br>    &gt;&gt;&gt; import datetime, pytz<br>    &gt;&gt;&gt; from zc.async.testing import wait_for_result<br>    &gt;&gt;&gt; layer['crontab'].save()<br>    &gt;&gt;&gt; import transaction<br>    &gt;&gt;&gt; get_jobs = lambda:[a for a in layer['queue']]<br><br><br>Import<br>++++++++++<br>::<br><br>    &gt;&gt;&gt; plone = layer['portal']<br>    &gt;&gt;&gt; purl = plone.absolute_url()<br>    &gt;&gt;&gt; crt = mcrontab.Crontab()<br>    &gt;&gt;&gt; exportimport = getMultiAdapter((plone, crt), i.IExportImporter)<br><br><br>Add<br>~~~~~<br>The most complete declaration to add or edit is ::<br><br>    &gt;&gt;&gt; CRONS = \"\"\"&lt;?xml version=\"1.0\"?&gt;<br>    ... &lt;crons&gt;<br>    ...   &lt;cron uid=\"foogsuid\" name=\"foo\" activated=\"true\"<br>    ...         periodicity=\"*/1 * * * *\" &gt;<br>    ...       &lt;environ&gt; &lt;![CDATA[ {\"foo\":\"bar\"} ]]&gt; &lt;/environ&gt;<br>    ...   &lt;/cron&gt;<br>    ...   &lt;!-- YOU CAN OMIT ENVIRON  &amp; activated--&gt;<br>    ...   &lt;cron uid=\"foogsuid2\" name=\"foo2\" periodicity=\"*/1 * * * *\" /&gt;<br>    ...   &lt;cron uid=\"foogsuid3\" name=\"foo3\" periodicity=\"*/1 * * * *\" /&gt;<br>    ... &lt;/crons&gt; \"\"\"<br>    &gt;&gt;&gt; TZ = pytz.timezone('Europe/Paris')<br>    &gt;&gt;&gt; set_now(datetime.datetime(2008,1,1,1,1, tzinfo=TZ))<br>    &gt;&gt;&gt; exportimport.do_import(CRONS)<br>    &gt;&gt;&gt; crt1 = mcrontab.Crontab.load()<br>    &gt;&gt;&gt; crt1.crons<br>    OrderedDict([(u'foogsuid', cron: foo/foogsuid [ON:2008-01-01 00:02:00] {u'foo': u'bar'}), (u'foogsuid2', cron: foo2/foogsuid2 [OFF]), (u'foogsuid3', cron: foo3/foogsuid3 [OFF])])<br><br>Delete &amp; reregister<br>~~~~~~~~~~~~~~~~~~~~~~<br>As always with generic setup to remove a cron, just add a ``remove=\"true\"`` inside the declaration.<br>To remove, just add ``remove=\"true\"`` to the attributes.<br>The order is import as you can re register jobs with same name after::<br><br>    &gt;&gt;&gt; CRONSD = \"\"\"&lt;?xml version=\"1.0\"?&gt;<br>    ... &lt;crons&gt;<br>    ...   &lt;cron uid=\"foogsuid2\" name=\"foo2\" remove=\"true\" periodicity=\"*/1 * * * *\" /&gt;<br>    ...   &lt;cron uid=\"foogsuid2\" name=\"foo2changed\" periodicity=\"*/3 * * * *\"/&gt;<br>    ...   &lt;cron uid=\"foogsuid3\" remove=\"true\"/&gt;<br>    ... &lt;/crons&gt; \"\"\"<br>    &gt;&gt;&gt; exportimport.do_import(CRONSD)<br>    &gt;&gt;&gt; crt2 = mcrontab.Crontab.load()<br>    &gt;&gt;&gt; crt2.crons<br>    OrderedDict([(u'foogsuid', cron: foo/foogsuid [ON:2008-01-01 00:02:00] {u'foo': u'bar'}), (u'foogsuid2', cron: foo2changed/foogsuid2 [OFF])])<br><br>Edit<br>~~~~~~~~~~<br>You can edit every part of a cron::<br><br>    &gt;&gt;&gt; CRONSE = \"\"\"&lt;?xml version=\"1.0\"?&gt;<br>    ... &lt;crons&gt;<br>    ...   &lt;cron uid=\"foogsuid2\" name=\"foo2edite\u00e9\" activated=\"True\"  periodicity=\"*/4 * * * *\"&gt;<br>    ...       &lt;environ&gt;&lt;![CDATA[ {\"foo\":\"bar\", \"miche\":\"muche\"} ]]&gt;&lt;/environ&gt;<br>    ...   &lt;/cron&gt;<br>    ... &lt;/crons&gt; \"\"\"<br>    &gt;&gt;&gt; exportimport.do_import(CRONSE)<br>    &gt;&gt;&gt; crt3 = mcrontab.Crontab.load()<br>    &gt;&gt;&gt; crt3.crons<br>    OrderedDict([(u'foogsuid', cron: foo/foogsuid [ON:2008-01-01 00:02:00] {u'foo': u'bar'}), (u'foogsuid2', cron: foo2edite\u00e9/foogsuid2 [ON:2008-01-01 00:04:00] {u'foo': u'bar', u'miche': u'muche'})])<br><br>Export<br>++++++<br>You can also export crons present in the site::<br><br>    &gt;&gt;&gt; ret = exportimport.do_export()<br>    &gt;&gt;&gt; waited = \"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<br>    ... &lt;crons&gt;<br>    ...   &lt;cron uid=\"foogsuid\" name=\"foo\" activated=\"True\" periodicity=\"*/1 * * * *\"&gt;<br>    ...     &lt;environ&gt;&lt;![CDATA[<br>    ... {\"foo\": \"bar\"}<br>    ... ]]&gt;<br>    ...     &lt;/environ&gt;<br>    ...   &lt;/cron&gt;<br>    ...   &lt;cron uid=\"foogsuid2\" name=\"foo2edite\u00e9\" activated=\"True\" periodicity=\"*/4 * * * *\"&gt;<br>    ...     &lt;environ&gt;&lt;![CDATA[<br>    ... {\"miche\": \"muche\", \"foo\": \"bar\"}<br>    ... ]]&gt;<br>    ...     &lt;/environ&gt;<br>    ...   &lt;/cron&gt;<br>    ... &lt;/crons&gt;\"\"\"<br>    &gt;&gt;&gt; ret == waited<br>    True<br><br>Teardown<br>+++++++++++<br>::<br><br>    &gt;&gt;&gt; layer['crontab'].save()<br><br><br><br>Changelog<br>============<br><br><br>2.8 (2018-04-05)<br>----------------<br><br>- Add a fake request so code called that expects a request will still work [dmarks]<br>- Allow python scripts and other TTW code to be called from collective.cron [djay]<br><br><br>2.7 (2013-02-18)<br>----------------<br><br>- Fix various github bugs (typos, install setup, dependencies) [kiorky, gforcada, khink]<br><br><br>2.6 (2012-11-11)<br>----------------<br><br>- fix #1 &amp; #2 [kiorky]<br><br><br>2.5 (2012-10-28)<br>----------------<br><br>- optimize API to get job status infos [kiorky]<br>- make better robust code [kiorky]<br><br><br>2.4 (2012-10-14)<br>----------------<br>- Add a log limit property to logs to limit memory &amp; other resources usage [kiorky]<br>- Performance tweaks [kiorky]<br><br><br>2.3 (2012-10-11)<br>----------------<br>- better registry handling [kiorky]<br>- better jobrunner [kiorky]<br>- better tests  [kiorky]<br>- make install and restart code more robust, again [kiorky]<br><br>2.2 (2012-10-11)<br>----------------<br><br>- make install and restart code more robust.<br>  This is **release codename Wine**. A really thanks to Andreas Jung which helped me to find a difficult bug<br>  with ZODB transactions. (call transaction.savepoint to make _p_jar which was None to appear).<br>  [kiorky]<br><br><br>2.1 (2012-10-10)<br>----------------<br><br>- better tests for addons consumers [kiorky]<br><br><br>2.0 (2012-10-10)<br>----------------<br>- Rewrite collective.cron for better robustness, documentation &amp; no extra dependencies on content types<br>  [kiorky]<br><br><br><br>1.0 (2011)<br>----------------<br>- First release<br><br><br><br><br>\n          </div>"}, "last_serial": 3736840, "releases": {"1.0": [], "2.0": [{"comment_text": "", "digests": {"md5": "5a977b477d9137847b9b0f1a009b8cd0", "sha256": "c4a0528fa31f876cb463b7dcbd8f02e40d7d3bd3bdedf06630f2772e21f98afd"}, "downloads": -1, "filename": "collective.cron-2.0.zip", "has_sig": false, "md5_digest": "5a977b477d9137847b9b0f1a009b8cd0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 106631, "upload_time": "2012-10-10T14:46:31", "upload_time_iso_8601": "2012-10-10T14:46:31.114684Z", "url": "https://files.pythonhosted.org/packages/fd/e4/8229dc33ff8660f84451449818a8a44ef56e7ace99eb2bceff2b6960cb3b/collective.cron-2.0.zip", "yanked": false}], "2.1": [{"comment_text": "", "digests": {"md5": "9388cc6edca77cac13e842cc57be3cbb", "sha256": "2a8336d39080704c4f31f256294246e76ee7082bc38bf3c401a5febd6b9b43d4"}, "downloads": -1, "filename": "collective.cron-2.1.zip", "has_sig": false, "md5_digest": "9388cc6edca77cac13e842cc57be3cbb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 106714, "upload_time": "2012-10-10T17:38:22", "upload_time_iso_8601": "2012-10-10T17:38:22.301263Z", "url": "https://files.pythonhosted.org/packages/77/8e/7d808f62d8f128b5c4747724523015cd160fc36684ee96ca8d67be4883e7/collective.cron-2.1.zip", "yanked": false}], "2.2": [{"comment_text": "", "digests": {"md5": "b916fc5fc9fa912bfb105e3d6af0a6e6", "sha256": "2cc38c3ef20a4e886d503d6ebb2d4587d07552cd60a451e0a6d7490c13fba064"}, "downloads": -1, "filename": "collective.cron-2.2.zip", "has_sig": false, "md5_digest": "b916fc5fc9fa912bfb105e3d6af0a6e6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 107684, "upload_time": "2012-10-11T15:51:42", "upload_time_iso_8601": "2012-10-11T15:51:42.431089Z", "url": "https://files.pythonhosted.org/packages/a4/23/9965ae74f852359c0654578525986e6b81803b432a72fc13d7d90c974dd3/collective.cron-2.2.zip", "yanked": false}], "2.3": [{"comment_text": "", "digests": {"md5": "7a0adda88b8ba5bfb6b4f7986a54d63d", "sha256": "6c9bc922ac8d75d83106890f4c8d68f1f11f0264f41dbbbe3adcb6bfeae88afd"}, "downloads": -1, "filename": "collective.cron-2.3.zip", "has_sig": false, "md5_digest": "7a0adda88b8ba5bfb6b4f7986a54d63d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 108116, "upload_time": "2012-10-11T20:39:00", "upload_time_iso_8601": "2012-10-11T20:39:00.339080Z", "url": "https://files.pythonhosted.org/packages/72/e6/b9b55d47e93249c0144d49ba2da1db3bfdb3c0fecb35206630409d58ad8d/collective.cron-2.3.zip", "yanked": false}], "2.4": [{"comment_text": "", "digests": {"md5": "9848f107d278c91a84ce118a2bf2bb8a", "sha256": "ae160cdb3c849fb6f29d241010b38fdc031e861ba8eb39b40c374dd735b133f7"}, "downloads": -1, "filename": "collective.cron-2.4.zip", "has_sig": false, "md5_digest": "9848f107d278c91a84ce118a2bf2bb8a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 109404, "upload_time": "2012-10-14T09:27:35", "upload_time_iso_8601": "2012-10-14T09:27:35.043412Z", "url": "https://files.pythonhosted.org/packages/20/e1/d80fd29e72c658efc0b23a731a7602ca7a362199d98ae09e39a376e1f0e6/collective.cron-2.4.zip", "yanked": false}], "2.5": [{"comment_text": "", "digests": {"md5": "f30810a35399511bebae2453b8f081e7", "sha256": "b81e37b9a95894404ff9dbda1a42a8c973a280416a79f35c1fa63e984bce2d3a"}, "downloads": -1, "filename": "collective.cron-2.5.zip", "has_sig": false, "md5_digest": "f30810a35399511bebae2453b8f081e7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 109629, "upload_time": "2012-10-28T13:08:39", "upload_time_iso_8601": "2012-10-28T13:08:39.182016Z", "url": "https://files.pythonhosted.org/packages/f2/13/8d4b66dd010c7bed6308b1e60e6211f2175c862d7513e25b8de13493d156/collective.cron-2.5.zip", "yanked": false}], "2.6": [{"comment_text": "", "digests": {"md5": "0afb70f88e62bebfeb7e6d87d0e5107c", "sha256": "559fbd45b6a7111f192873e39b6755b5535bd0dec8ef8573602fb1b95877e043"}, "downloads": -1, "filename": "collective.cron-2.6.zip", "has_sig": false, "md5_digest": "0afb70f88e62bebfeb7e6d87d0e5107c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 109693, "upload_time": "2012-11-11T11:54:01", "upload_time_iso_8601": "2012-11-11T11:54:01.319634Z", "url": "https://files.pythonhosted.org/packages/9f/fb/6b19b8a212e49f6680d64e48decabc934771c79e506ad24e7ad5670df619/collective.cron-2.6.zip", "yanked": false}], "2.7": [{"comment_text": "", "digests": {"md5": "8b43dfe3fe4585e51baf66c74bf9c3bf", "sha256": "1f606b0c87bdf94a715300a96bc9899e65f652da06004824c4dff507c1e3ed75"}, "downloads": -1, "filename": "collective.cron-2.7.zip", "has_sig": false, "md5_digest": "8b43dfe3fe4585e51baf66c74bf9c3bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 109797, "upload_time": "2013-02-18T15:32:04", "upload_time_iso_8601": "2013-02-18T15:32:04.667890Z", "url": "https://files.pythonhosted.org/packages/f9/2f/32e45fb09c8dd27e421f83a4bd2ef365b39ca163bfa8ae2fee434071074d/collective.cron-2.7.zip", "yanked": false}], "2.8": [{"comment_text": "", "digests": {"md5": "bf96759008f88923757f898d2a5c1591", "sha256": "1b4daa9d2d8537e1ed81b88d8112517c217d446a6a043492f17e21bb95cc155b"}, "downloads": -1, "filename": "collective.cron-2.8.tar.gz", "has_sig": false, "md5_digest": "bf96759008f88923757f898d2a5c1591", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 81724, "upload_time": "2018-04-05T09:32:37", "upload_time_iso_8601": "2018-04-05T09:32:37.018679Z", "url": "https://files.pythonhosted.org/packages/f2/d1/48c85e2765adf4bc6266a1d651c7351f17725ec6caa5db7da0516b46e76b/collective.cron-2.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bf96759008f88923757f898d2a5c1591", "sha256": "1b4daa9d2d8537e1ed81b88d8112517c217d446a6a043492f17e21bb95cc155b"}, "downloads": -1, "filename": "collective.cron-2.8.tar.gz", "has_sig": false, "md5_digest": "bf96759008f88923757f898d2a5c1591", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 81724, "upload_time": "2018-04-05T09:32:37", "upload_time_iso_8601": "2018-04-05T09:32:37.018679Z", "url": "https://files.pythonhosted.org/packages/f2/d1/48c85e2765adf4bc6266a1d651c7351f17725ec6caa5db7da0516b46e76b/collective.cron-2.8.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:17:57 2020"}