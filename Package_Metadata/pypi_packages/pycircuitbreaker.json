{"info": {"author": "Evert Timberg", "author_email": "evert@everttimberg.io", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# PyCircuitBreaker\n\n[![PyPI Version](https://img.shields.io/pypi/v/pycircuitbreaker)](https://pypi.org/project/pycircuitbreaker/)\n[![Python Versions](https://img.shields.io/pypi/pyversions/pycircuitbreaker)](https://pypi.org/project/pycircuitbreaker/)\n[![MIT License](https://img.shields.io/pypi/l/pycircuitbreaker)](https://github.com/etimberg/pycircuitbreaker/blob/master/LICENSE)\n![CI Status](https://img.shields.io/github/workflow/status/etimberg/pycircuitbreaker/CI)\n[![Coverage Status](https://coveralls.io/repos/github/etimberg/pycircuitbreaker/badge.svg?branch=master)](https://coveralls.io/github/etimberg/pycircuitbreaker?branch=master)\n\nPython Implementation of the [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html). Inspired by [circuitbreaker](https://github.com/fabfuel/circuitbreaker) by Fabian Fuelling.\n\n## Installation\n\n```\npip install pycircuitbreaker\n```\n\n## Usage\n\nThe simplest usage of `pycircuitbreaker` is to wrap decorate a function that can fail using `circuit`.\n\n```python\nfrom pycircuitbreaker import circuit\n\n@circuit\ndef function_that_can_fail():\n    ...\n```\n\n### Reset Strategies\n\nBy default, pycircuitbreaker operates such that a single success resets the error state of a closed breaker. This makes sense for a service that rarely fails, but in certains cases this can pose a problem. If the `error_threshold` is set to `5`, but only 4/5 external requests fail, the breaker will never open. To get around this, the [strategy setting])(#strategy) may be used. By setting this to `pycircuitbreaker.CircuitBreakerStrategy.NET_ERROR`, the net error count (errors - successes) will be used to trigger the breaker.\n\n## Configuration\n\nA number of configuration options can be provided to the `CircuitBreaker` class or the `circuit` decorator to control the behaviour of the breaker. When using the decorator, options should be passed as keyword arguments.\n\n### breaker_id\n\nThe ID of the breaker used in exception reporting or for logging purposes. If not specified, a `uuid4()` is created.\n\n### detect_error\n\nType: `Optional[Callable[Any, bool]]`\n\nThis option can be used to detect errors that do not raise exceptions. For example, if you have a function that returns a response object with a status code, we can detect errors that have a status code of 500.\n\n```python\nfrom pycircuitbreaker import circuit\n\ndef detect_500(response) -> bool:\n    return response.status_code == 500\n\n@circuit(detect_error=detect_500)\ndef request():\n    response = external_call()\n    return response\n```\n\n### error_threshold\n\nType: `Optional[int]`\nDefault: `5`\n\nThe number of sequential errors that must occur before the breaker opens. If 4 errors occur a single success will reset the error count to 0.\n\n### exception_blacklist\n\nType: `Optional[Iterable[Exception]]`\n\nThere are cases where only certain errors should count as errors that can open the breaker. In the example below, we are using [requests](https://requests.readthedocs.io/en/master/) to call to an external service and then raise an exception on an error case. We only want the circuit breaker to open on timeouts to\nthe external service. \n\nNote that if this option is used, errors derived from those specified will also be included in the blacklist.\n\n```python\nimport requests\nfrom pycircuitbreaker import circuit\n\n@circuit(exception_blacklist=[requests.exceptions.Timeout])\ndef external_call():\n    response = requests.get(\"EXTERNAL_SERVICE\")\n    response.raise_for_status()\n```\n\n### exception_whitelist\n\nType: `Optional[Iterable[Exception]]`\n\nThis setting allows certain exceptions to not be counted as errors. Taking the same example as the exception_blacklist setting, we can ignore `request.exceptions.HTTPError` only using the whitelist.\n\nNote that if this option is used, errors derived from those specified will also be included in the whitelist.\n\n```python\nimport requests\nfrom pycircuitbreaker import circuit\n\n@circuit(exception_whitelist=[requests.exceptions.HTTPError])\ndef external_call():\n    response = requests.get(\"EXTERNAL_SERVICE\")\n    response.raise_for_status()\n```\n\n### on_close\n\nType: `Optional[Callable[[CircuitBreaker], None]]`\n\nIf specified, this function is called when the breaker fully closes. This can be useful for logging messages.\n\n### on_open\n\nType: `Optional[Callable[[CircuitBreaker, Union[Exception, Any]], None]]`\n\nIf specified, this function is called when the breaker opens. The 2nd parameter to the function will be the exception that triggered the opening if exception detection was used. If the `detect_error` method was used, the wrapped function return value is passed as the 2nd parameter.\n\n### recovery_threshold\n\nType: `Optional[int]`\nDefault: `1`\n\nThis is the number of successful calls that must occur before the circuit breaker transitions from `CircuitBreakerState.HALF_OPEN` to `CircuitBreakerState.CLOSED`.\n\n### recovery_timeout\n\nType: `Optional[int]`\nDefault: 30\n\nThe number of seconds the breaker stays fully open for before test requests are allowed through.\n\n### strategy\n\nType: `Optional[pycircuitbreaker.CircuitBreakerStrategy]`\nDefault: `pycircuitbreaker.CircuitBreakerStrategy.SINGLE_RESET`\n\nControls how successes change the error count when the breaker is closed. By default, a single success resets the number of errors in the breaker.\n\nPossible options:\n* `CircuitBreakerStrategy.SINGLE_RESET`\n* `CircuitBreakerStrategy.NET_ERROR`\n\n## CircuitBreaker API\n\nThe public API of the `CircuitBreaker` class is described below.\n\n### error_count\n\nType: `int`\n\nThe number of errors stored in the breaker.\n\n### id\n\nThe ID of the breaker. If not supplied via the configuration `breaker_id` setting, this is a `uuid4()`.\n\n### open_time\n\nType: `datetime`\n\nThe UTC time the breaker last opened.\n\n### recovery_start_time\n\nType: `datetime`\n\nThe UTC time that the breaker is open until (when recovery begins).\n\n### state\n\nType: `CircuitBreakerState`\n\nThe state of the breaker.\n\n### success_count\n\nType: `int`\n\nThe number of successes stored in the breaker during the recovery period.\n\n## Roadmap\n\n1. Back circuit breaker state with Redis to share state among processes (e.g. for gunicorn)\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/etimberg/pycircuitbreaker", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pycircuitbreaker", "package_url": "https://pypi.org/project/pycircuitbreaker/", "platform": "any", "project_url": "https://pypi.org/project/pycircuitbreaker/", "project_urls": {"Homepage": "https://github.com/etimberg/pycircuitbreaker"}, "release_url": "https://pypi.org/project/pycircuitbreaker/0.2.1/", "requires_dist": ["pytest (>=5.3) ; extra == 'test'", "pytest-cov ; extra == 'test'"], "requires_python": "", "summary": "Python implementation of the Circuit Breaker Pattern", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>PyCircuitBreaker</h1>\n<p><a href=\"https://pypi.org/project/pycircuitbreaker/\" rel=\"nofollow\"><img alt=\"PyPI Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/db7d098b1228abc7b94fe815ec32247133752ca9/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f707963697263756974627265616b6572\"></a>\n<a href=\"https://pypi.org/project/pycircuitbreaker/\" rel=\"nofollow\"><img alt=\"Python Versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/191fcaff1d924682033a05ff21003ea5df985f77/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f707963697263756974627265616b6572\"></a>\n<a href=\"https://github.com/etimberg/pycircuitbreaker/blob/master/LICENSE\" rel=\"nofollow\"><img alt=\"MIT License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c4b886a14c5146e96d729215dd06f17b1bfd5e30/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f707963697263756974627265616b6572\"></a>\n<img alt=\"CI Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/998144c1eb6d479a3285a96724bef59f265ea3f6/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f776f726b666c6f772f7374617475732f6574696d626572672f707963697263756974627265616b65722f4349\">\n<a href=\"https://coveralls.io/github/etimberg/pycircuitbreaker?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e0f9abfa172c138eaffa979ae2867e80ed0f6ee1/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6574696d626572672f707963697263756974627265616b65722f62616467652e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>Python Implementation of the <a href=\"https://martinfowler.com/bliki/CircuitBreaker.html\" rel=\"nofollow\">Circuit Breaker Pattern</a>. Inspired by <a href=\"https://github.com/fabfuel/circuitbreaker\" rel=\"nofollow\">circuitbreaker</a> by Fabian Fuelling.</p>\n<h2>Installation</h2>\n<pre><code>pip install pycircuitbreaker\n</code></pre>\n<h2>Usage</h2>\n<p>The simplest usage of <code>pycircuitbreaker</code> is to wrap decorate a function that can fail using <code>circuit</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pycircuitbreaker</span> <span class=\"kn\">import</span> <span class=\"n\">circuit</span>\n\n<span class=\"nd\">@circuit</span>\n<span class=\"k\">def</span> <span class=\"nf\">function_that_can_fail</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n</pre>\n<h3>Reset Strategies</h3>\n<p>By default, pycircuitbreaker operates such that a single success resets the error state of a closed breaker. This makes sense for a service that rarely fails, but in certains cases this can pose a problem. If the <code>error_threshold</code> is set to <code>5</code>, but only 4/5 external requests fail, the breaker will never open. To get around this, the [strategy setting])(#strategy) may be used. By setting this to <code>pycircuitbreaker.CircuitBreakerStrategy.NET_ERROR</code>, the net error count (errors - successes) will be used to trigger the breaker.</p>\n<h2>Configuration</h2>\n<p>A number of configuration options can be provided to the <code>CircuitBreaker</code> class or the <code>circuit</code> decorator to control the behaviour of the breaker. When using the decorator, options should be passed as keyword arguments.</p>\n<h3>breaker_id</h3>\n<p>The ID of the breaker used in exception reporting or for logging purposes. If not specified, a <code>uuid4()</code> is created.</p>\n<h3>detect_error</h3>\n<p>Type: <code>Optional[Callable[Any, bool]]</code></p>\n<p>This option can be used to detect errors that do not raise exceptions. For example, if you have a function that returns a response object with a status code, we can detect errors that have a status code of 500.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pycircuitbreaker</span> <span class=\"kn\">import</span> <span class=\"n\">circuit</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">detect_500</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n    <span class=\"k\">return</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">status_code</span> <span class=\"o\">==</span> <span class=\"mi\">500</span>\n\n<span class=\"nd\">@circuit</span><span class=\"p\">(</span><span class=\"n\">detect_error</span><span class=\"o\">=</span><span class=\"n\">detect_500</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">request</span><span class=\"p\">():</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">external_call</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"n\">response</span>\n</pre>\n<h3>error_threshold</h3>\n<p>Type: <code>Optional[int]</code>\nDefault: <code>5</code></p>\n<p>The number of sequential errors that must occur before the breaker opens. If 4 errors occur a single success will reset the error count to 0.</p>\n<h3>exception_blacklist</h3>\n<p>Type: <code>Optional[Iterable[Exception]]</code></p>\n<p>There are cases where only certain errors should count as errors that can open the breaker. In the example below, we are using <a href=\"https://requests.readthedocs.io/en/master/\" rel=\"nofollow\">requests</a> to call to an external service and then raise an exception on an error case. We only want the circuit breaker to open on timeouts to\nthe external service.</p>\n<p>Note that if this option is used, errors derived from those specified will also be included in the blacklist.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pycircuitbreaker</span> <span class=\"kn\">import</span> <span class=\"n\">circuit</span>\n\n<span class=\"nd\">@circuit</span><span class=\"p\">(</span><span class=\"n\">exception_blacklist</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">exceptions</span><span class=\"o\">.</span><span class=\"n\">Timeout</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">external_call</span><span class=\"p\">():</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"EXTERNAL_SERVICE\"</span><span class=\"p\">)</span>\n    <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">raise_for_status</span><span class=\"p\">()</span>\n</pre>\n<h3>exception_whitelist</h3>\n<p>Type: <code>Optional[Iterable[Exception]]</code></p>\n<p>This setting allows certain exceptions to not be counted as errors. Taking the same example as the exception_blacklist setting, we can ignore <code>request.exceptions.HTTPError</code> only using the whitelist.</p>\n<p>Note that if this option is used, errors derived from those specified will also be included in the whitelist.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pycircuitbreaker</span> <span class=\"kn\">import</span> <span class=\"n\">circuit</span>\n\n<span class=\"nd\">@circuit</span><span class=\"p\">(</span><span class=\"n\">exception_whitelist</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">exceptions</span><span class=\"o\">.</span><span class=\"n\">HTTPError</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">external_call</span><span class=\"p\">():</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"EXTERNAL_SERVICE\"</span><span class=\"p\">)</span>\n    <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">raise_for_status</span><span class=\"p\">()</span>\n</pre>\n<h3>on_close</h3>\n<p>Type: <code>Optional[Callable[[CircuitBreaker], None]]</code></p>\n<p>If specified, this function is called when the breaker fully closes. This can be useful for logging messages.</p>\n<h3>on_open</h3>\n<p>Type: <code>Optional[Callable[[CircuitBreaker, Union[Exception, Any]], None]]</code></p>\n<p>If specified, this function is called when the breaker opens. The 2nd parameter to the function will be the exception that triggered the opening if exception detection was used. If the <code>detect_error</code> method was used, the wrapped function return value is passed as the 2nd parameter.</p>\n<h3>recovery_threshold</h3>\n<p>Type: <code>Optional[int]</code>\nDefault: <code>1</code></p>\n<p>This is the number of successful calls that must occur before the circuit breaker transitions from <code>CircuitBreakerState.HALF_OPEN</code> to <code>CircuitBreakerState.CLOSED</code>.</p>\n<h3>recovery_timeout</h3>\n<p>Type: <code>Optional[int]</code>\nDefault: 30</p>\n<p>The number of seconds the breaker stays fully open for before test requests are allowed through.</p>\n<h3>strategy</h3>\n<p>Type: <code>Optional[pycircuitbreaker.CircuitBreakerStrategy]</code>\nDefault: <code>pycircuitbreaker.CircuitBreakerStrategy.SINGLE_RESET</code></p>\n<p>Controls how successes change the error count when the breaker is closed. By default, a single success resets the number of errors in the breaker.</p>\n<p>Possible options:</p>\n<ul>\n<li><code>CircuitBreakerStrategy.SINGLE_RESET</code></li>\n<li><code>CircuitBreakerStrategy.NET_ERROR</code></li>\n</ul>\n<h2>CircuitBreaker API</h2>\n<p>The public API of the <code>CircuitBreaker</code> class is described below.</p>\n<h3>error_count</h3>\n<p>Type: <code>int</code></p>\n<p>The number of errors stored in the breaker.</p>\n<h3>id</h3>\n<p>The ID of the breaker. If not supplied via the configuration <code>breaker_id</code> setting, this is a <code>uuid4()</code>.</p>\n<h3>open_time</h3>\n<p>Type: <code>datetime</code></p>\n<p>The UTC time the breaker last opened.</p>\n<h3>recovery_start_time</h3>\n<p>Type: <code>datetime</code></p>\n<p>The UTC time that the breaker is open until (when recovery begins).</p>\n<h3>state</h3>\n<p>Type: <code>CircuitBreakerState</code></p>\n<p>The state of the breaker.</p>\n<h3>success_count</h3>\n<p>Type: <code>int</code></p>\n<p>The number of successes stored in the breaker during the recovery period.</p>\n<h2>Roadmap</h2>\n<ol>\n<li>Back circuit breaker state with Redis to share state among processes (e.g. for gunicorn)</li>\n</ol>\n\n          </div>"}, "last_serial": 6997149, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "60398f4c6dddb1acfb110046aebf9549", "sha256": "814c7f601d6c1034788b0b092993606546f33ae6ebf09cd580b6c835f1330ef7"}, "downloads": -1, "filename": "pycircuitbreaker-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "60398f4c6dddb1acfb110046aebf9549", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6151, "upload_time": "2020-02-16T20:20:54", "upload_time_iso_8601": "2020-02-16T20:20:54.846253Z", "url": "https://files.pythonhosted.org/packages/d6/52/0c53fe939d0e8cbbb7ff6c72e3c20b8d8fd893b974b9c2832e2ca7e3d1f1/pycircuitbreaker-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6bcea2087c83dc62332b510f5b59be88", "sha256": "3c536571cac93f03e132fabf15af534d64b6f73ab843dcfe254ae4d1162f51cd"}, "downloads": -1, "filename": "pycircuitbreaker-0.1.1.tar.gz", "has_sig": false, "md5_digest": "6bcea2087c83dc62332b510f5b59be88", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5319, "upload_time": "2020-02-16T20:20:56", "upload_time_iso_8601": "2020-02-16T20:20:56.770857Z", "url": "https://files.pythonhosted.org/packages/37/87/88c104aab70e647a0096577337598558d98ab17e9cb304663887fd651f21/pycircuitbreaker-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "f8e1b68d388548b7624b1e7ccafe23aa", "sha256": "cde0dc16745a117c63910591c366284d94076313b8e9af4554ea902a8c84b2c6"}, "downloads": -1, "filename": "pycircuitbreaker-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "f8e1b68d388548b7624b1e7ccafe23aa", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7123, "upload_time": "2020-02-17T21:58:47", "upload_time_iso_8601": "2020-02-17T21:58:47.418441Z", "url": "https://files.pythonhosted.org/packages/84/c0/153c1efe6213c9aa4bec705d315bb9b6778728846f94adccfe9036776d97/pycircuitbreaker-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "802db424e905a99e747e942a3d03e926", "sha256": "0746d0f40ce32fd26d749add924c15cd22bce4030fa97c405ede95016b184080"}, "downloads": -1, "filename": "pycircuitbreaker-0.2.0.tar.gz", "has_sig": false, "md5_digest": "802db424e905a99e747e942a3d03e926", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6624, "upload_time": "2020-02-17T21:58:48", "upload_time_iso_8601": "2020-02-17T21:58:48.859421Z", "url": "https://files.pythonhosted.org/packages/6a/8d/4fa3581a2397e8fc0e2c7705230fe300e00b2999c0f9060fd4908ed4935c/pycircuitbreaker-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "e9d863095c2bc06a60646904dfd79b46", "sha256": "313ef58c93496c4c888b65a71c48c4ee0e2d91e3314fa68415dc89553dce73f8"}, "downloads": -1, "filename": "pycircuitbreaker-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "e9d863095c2bc06a60646904dfd79b46", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 8652, "upload_time": "2020-04-10T23:03:47", "upload_time_iso_8601": "2020-04-10T23:03:47.962070Z", "url": "https://files.pythonhosted.org/packages/a3/1a/f72a71d951eef54f07a072d4a0b5016260efd831361e24ff69f9dd559ae1/pycircuitbreaker-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "15169cb8f118e8d5b8f5d00b0c3b3395", "sha256": "f69610db3ca0fc110b72ea2d92309a2020a8b20b7dcc41de911164b7d129053e"}, "downloads": -1, "filename": "pycircuitbreaker-0.2.1.tar.gz", "has_sig": false, "md5_digest": "15169cb8f118e8d5b8f5d00b0c3b3395", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8697, "upload_time": "2020-04-10T23:03:49", "upload_time_iso_8601": "2020-04-10T23:03:49.070235Z", "url": "https://files.pythonhosted.org/packages/44/ad/ea8364e21f2d013e50c1d526753689a9e011739d2b516e6e674fa49e470e/pycircuitbreaker-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e9d863095c2bc06a60646904dfd79b46", "sha256": "313ef58c93496c4c888b65a71c48c4ee0e2d91e3314fa68415dc89553dce73f8"}, "downloads": -1, "filename": "pycircuitbreaker-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "e9d863095c2bc06a60646904dfd79b46", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 8652, "upload_time": "2020-04-10T23:03:47", "upload_time_iso_8601": "2020-04-10T23:03:47.962070Z", "url": "https://files.pythonhosted.org/packages/a3/1a/f72a71d951eef54f07a072d4a0b5016260efd831361e24ff69f9dd559ae1/pycircuitbreaker-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "15169cb8f118e8d5b8f5d00b0c3b3395", "sha256": "f69610db3ca0fc110b72ea2d92309a2020a8b20b7dcc41de911164b7d129053e"}, "downloads": -1, "filename": "pycircuitbreaker-0.2.1.tar.gz", "has_sig": false, "md5_digest": "15169cb8f118e8d5b8f5d00b0c3b3395", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8697, "upload_time": "2020-04-10T23:03:49", "upload_time_iso_8601": "2020-04-10T23:03:49.070235Z", "url": "https://files.pythonhosted.org/packages/44/ad/ea8364e21f2d013e50c1d526753689a9e011739d2b516e6e674fa49e470e/pycircuitbreaker-0.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:08:28 2020"}