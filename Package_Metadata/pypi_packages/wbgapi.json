{"info": {"author": "Tim Herzog", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "\n# WBGAPI #\n\nWBGAPI provides modern, pythonic access to the World Bank's data API.\nIt is designed both for data novices and data scientist types. \nWBGAPI tries to shield users from some of the confusing ideosyncrasies\nof the World Bank's API while remaining consistent and intuitive for\nthose who are familiar with its basic data structures. More on that later.\n\nWBGAPI differs from other modules in a few respects. The most significant\nis that it queries databases individually instead of collectively. To appreciate\nthe difference, consider this API request:\n\nhttps://api.worldbank.org/v2/indicator\n\nAs of this writing, this request returns 17,328 resulting indicators. But what\nthis obscures is that these indicators are stored in 57 separate databases,\nupdated on different schedules, and covering different time spans and country\ngroups. Many indicators appear in more than one database. While it's possible\nto use the API to get more precise results, it's not always easy to understand\nwhat you're requesting or where it's actually coming from.\n\nWBGAPI fixes this issue by only querying a single database at a time using a [relatively\nnew set of endpoints][beta-endpoints]. This gives users an accurate picture\nof both the data, dimensions and features of that database. The default database\nis the World Development Indicators (WDI) but you can switch databases at any time.\n\nOther key features:\n\n* Easily select multiple series, economies (countries) and time periods in a single request\n\n* Select individual years, ranges, and most recent values (MRVs)\n\n* Metadata queries\n\n* Very \"pythonic\": use of generators, ranges and sets make data access easy and elegant\n\n* Extensive [pandas][pandas] support (optional)\n\n* Multi-lingual support (sort of. See \"Limitations\" section below)\n\n## Installation ##\n\n    pip install wbgapi\n\n## Quick Start ##\n\nImport the module; my preferred namespace is `wb`:\n\n    import wbgapi as wb\n\nWBGAPI includes extenstive docstrings with lots of examples:\n\n    help(wb)  \n    help(wb.series)  \n    [etc]\n\nEvery element type is its own object: source, series, region, time,\netc. Note that \"countries\" and aggregates are accessed through the \"economy\"\nobject and the time dimension is always accessed through the time object.\nAll World Bank databases have a series, time, and economy dimension,\nalthough the API is not consistent in its concept scheme across databases.\nFor example, in some databases the economy dimension is called 'economy' or 'province'\ninstead of 'country' and the time dimension is sometimes called 'year.'\nThe WBGAPI module saves you most of that headache.\n\nObjects tend to use a common set of functions which you'll use heavily:\n\n* `list()` returns an interative list of basic data elements. Actually, it returns a python generator.\n  You can pass parameters to limit the list, but by default it returns all elements\n  in the database.\n\n* `get()` returns a single object.\n\n* `info()` prints a summary report of objects: all elements by default. These are great\n  if you just want to quickly see what's in a database.\n\n* `fetch()` functions return data and metadata. They usually involve more arguments\n  and return more complicated objects, but are otherwise similar to `list()`\n\nAlrighty then, let's fire it up:\n\n    import wbgapi as wb\n\n    # show the series list\n    wb.series.info()\n    id                         value\n    AG.AGR.TRAC.NO             Agricultural machinery, tractors\n    AG.CON.FERT.PT.ZS          Fertilizer consumption (% of fertilizer production)\n    AG.CON.FERT.ZS             Fertilizer consumption (kilograms per hectare of arable land)\n    AG.LND.AGRI.K2             Agricultural land (sq. km)\n    AG.LND.AGRI.ZS             Agricultural land (% of land area)\n    AG.LND.ARBL.HA             Arable land (hectares)\n    AG.LND.ARBL.HA.PC          Arable land (hectares per person)\n    AG.LND.ARBL.ZS             Arable land (% of land area)\n    ...\n                               1429 elements\n\n    wb.time.info()\n    id      value\n    YR1960  1960\n    YR1961  1961\n    YR1962  1962\n    YR1963  1963\n    YR1964  1964\n    ...\n            60 elements\n\nThat first command will take a while and run a very long report due to the size of the WDI.\n\nUse `get()` and `list()` to access the underlying objects:\n\n    wb.economy.get('COL')\n    {'id': 'COL', 'value': 'Colombia', 'aggregate': False, 'longitude': -74.082, 'latitude': 4.60987, 'region': 'LCN', 'adminregion': 'LAC', 'lendingType': 'IBD', 'incomeLevel': 'UMC', 'capitalCity': 'Bogota'}\n\n    stuff = {i['id']: i['value'] for i in wb.series.list(['SP.POP.TOTL', 'SI.POV.NAHC'])}\n    stuff\n    {'SP.POP.TOTL': 'Population, total', 'SI.POV.NAHC': 'Poverty headcount ratio at national poverty lines (% of population)'}\n\nAPI veterans might notice that the objects use `value` for element names instead of `name`. That's an artifact of the \"advanced\" queries\nmentioned previously.\n\nAny single identifier or iterable object can generally be passed as an argument to select series, economies, regions, and so forth.\nHere's an easy way to get a list of high-income countries:\n\n    for row in wb.economy.list(wb.region.members('HIC')):\n        print(row['value'])\n\n### Data Requests ###\n\nAgain, use `fetch()` for multiple rows of data, and `get()` for single rows. Python ranges are an easy way to\nindicate which time periods you want.\n\n    # this request fetches data for 3 countries from 2010-2015. Be careful with requests\n    # that omit constraints on economies and/or time as these can take a long time to run\n    # and return large numbers of rows\n    for row in wb.data.fetch('SP.POP.TOTL', economy=['BRA', 'ARG', 'URY'], time=range(2010,2015)):\n        print(row)\n\n    {'value': 3400434, 'series': 'SP.POP.TOTL', 'economy': 'URY', 'aggregate': False, 'time': 'YR2014'}\n    {'value': 3389439, 'series': 'SP.POP.TOTL', 'economy': 'URY', 'aggregate': False, 'time': 'YR2013'}\n    {'value': 3378974, 'series': 'SP.POP.TOTL', 'economy': 'URY', 'aggregate': False, 'time': 'YR2012'}\n    ...\n    {'value': 13082.664325572, 'series': 'NY.GDP.PCAP.CD', 'economy': 'ARG', 'aggregate': False, 'time': 'YR2012'}\n    {'value': 12848.8641969705, 'series': 'NY.GDP.PCAP.CD', 'economy': 'ARG', 'aggregate': False, 'time': 'YR2011'}\n    {'value': 10385.9644319555, 'series': 'NY.GDP.PCAP.CD', 'economy': 'ARG', 'aggregate': False, 'time': 'YR2010'}\n\nOr if you want the most recent value for every country (omitting aggregates), including both element codes and labels:\n\n    for row in wb.data.fetch('SP.POP.TOTL', mrnev=1, skipAggs=True, labels=True):\n        print(row['economy'], row['value'])\n\n    {'id': 'AFG', 'value': 'Afghanistan', 'aggregate': False} 37172386\n    {'id': 'ALB', 'value': 'Albania', 'aggregate': False} 2866376\n    {'id': 'DZA', 'value': 'Algeria', 'aggregate': False} 42228429\n    {'id': 'ASM', 'value': 'American Samoa', 'aggregate': False} 55465\n    ...\n\n### Pandas ###\n\nData and economy queries can be returned as pandas DataFrames. For example:\n\n    # data frame of population data for even-numbered years\n    wb.data.DataFrame('SP.POP.TOTL', time=range(2010,2020,2),labels=True)\n                Label      YR2010      YR2012      YR2014      YR2016      YR2018\n    ABW         Aruba    101669.0    102560.0    103774.0    104872.0    105845.0\n    AFG   Afghanistan  29185507.0  31161376.0  33370794.0  35383128.0  37172386.0\n    AGO        Angola  23356246.0  25107931.0  26941779.0  28842484.0  30809762.0\n    ALB       Albania   2913021.0   2900401.0   2889104.0   2876101.0   2866376.0\n    AND       Andorra     84449.0     82427.0     79213.0     77297.0     77006.0\n    ..            ...         ...         ...         ...         ...         ...\n    XKX        Kosovo   1775680.0   1805200.0   1821800.0   1816200.0   1845300.0\n    YEM   Yemen, Rep.  23154855.0  24473178.0  25823485.0  27168210.0  28498687.0\n    ZAF  South Africa  51216964.0  52834005.0  54545991.0  56203654.0  57779622.0\n    ZMB        Zambia  13605984.0  14465121.0  15399753.0  16363507.0  17351822.0\n    ZWE      Zimbabwe  12697723.0  13115131.0  13586681.0  14030390.0  14439018.0\n\n`economy`, `region`, `income`, and `lending` can also return Pandas objects. Here is how you might add the income group to the query above:\n\n    c = wb.economy.DataFrame()\n    df = wb.data.DataFrame('SP.POP.TOTL', time=range(2010,2020,2),labels=True,skipAggs=True).join(c['incomeLevel'])\n    df\n                Label      YR2010      YR2012      YR2014      YR2016      YR2018 incomeLevel\n    ABW         Aruba    101669.0    102560.0    103774.0    104872.0    105845.0         HIC\n    AFG   Afghanistan  29185507.0  31161376.0  33370794.0  35383128.0  37172386.0         LIC\n    AGO        Angola  23356246.0  25107931.0  26941779.0  28842484.0  30809762.0         LMC\n    ALB       Albania   2913021.0   2900401.0   2889104.0   2876101.0   2866376.0         UMC\n    AND       Andorra     84449.0     82427.0     79213.0     77297.0     77006.0         HIC\n    ..            ...         ...         ...         ...         ...         ...         ...\n\nAnd then aggregate (albeit unweighted):\n\n    df.groupby('incomeLevel').mean()\n                       YR2010        YR2012        YR2014        YR2016        YR2018\n    incomeLevel                                                                      \n    HIC          1.436314e+07  1.451850e+07  1.469533e+07  1.487142e+07  1.502200e+07\n    LIC          1.862174e+07  2.012211e+07  2.113464e+07  2.222469e+07  2.339882e+07\n    LMC          5.720078e+07  5.898364e+07  6.076860e+07  6.254959e+07  6.431713e+07\n    UMC          4.165684e+07  4.229376e+07  4.296426e+07  4.363008e+07  4.426060e+07\n\nOf course, these DataFrames can be used for any sort of analysis and operations that pandas supports,\nand can be used with lots of various visualization libraries. Time series can be easily plotted by transposing a DataFrame:\n\n    wb.data.DataFrame('NY.GDP.PCAP.CD', ['BRA', 'ARG'], time=range(2000,2020),numericTimeKeys=True).transpose().plot()\n\nUse pandas' `reset_index` option to fetch unindexed columns of indicators:\n\n    wb.data.DataFrame(['SP.POP.TOTL', 'NY.GDP.PCAP.CD', 'EN.ATM.CO2E.KT'],time=range(2000,2010), numericTimeKeys=True, columns='series').reset_index()\n          time economy  EN.ATM.CO2E.KT  NY.GDP.PCAP.CD  SP.POP.TOTL\n    0     2000     ABW        2379.883    20620.700626      90853.0\n    1     2000     AFG         773.737             NaN   20779953.0\n    2     2000     AGO        9541.534      556.836318   16395473.0\n    3     2000     ALB        3021.608     1126.683318    3089027.0\n    4     2000     AND         524.381    21936.530101      65390.0\n    ...    ...     ...             ...             ...          ...\n    2635  2009     XKX             NaN     3209.711460    1761474.0\n    2636  2009     YEM       24561.566     1116.084594   22516460.0\n    2637  2009     ZAF      503112.400     5862.797340   50477011.0\n    2638  2009     ZMB        2508.228     1159.907762   13215139.0\n    2639  2009     ZWE        5603.176      771.598786   12526968.0\n\n\n### Switching databases ###\n\nUse the `source` object to learn about other databases and the `db` variable to change the global database target:\n\n    wb.source.info()\n    id  name\n    1   Doing Business\n    2   World Development Indicators\n    3   Worldwide Governance Indicators\n    5   Subnational Malnutrition Database\n    ...\n\n    wb.db = 1   # change to Doing Business\n    wb.series.info()\n    id                                                 value\n    ENF.CONT.COEN.ATDR                                 Enforcing contracts: Alternative dispute resolution (0-3) (DB16-20 methodology)\n    ENF.CONT.COEN.ATFE.PR                              Enforcing contracts: Attorney fees (% of claim)\n    ENF.CONT.COEN.COST.ZS                              Enforcing contracts: Cost (% of claim)\n    ...\n\nMost functions also accept a `db` parameter to specify the database as an argument. This option will override the global option.\n\n\n### Custom Dimensions ###\n\nMost databases consist of 3 dimensional concepts: `series`, `country` and `time`. But this is not always the case: several databases use `economy`, `state`\nor something else in lieu of `country` and at least one uses `year` in lieu of `time`. To make programming more intuitive, wbgapi normalizes common\ndimensions as `economy` and `time` so that you don't have to guess (this includes subnational databases, since at this point all databases capture\nall administrative levels in the same dimension).\n\nYou can access a database's actual concept structure like this:\n\n    for k,v in wb.source.concepts().items():\n        print(k, v)\n\nSome databases have additional dimensions; for instance, WDI Archives (57) has a version dimension. Simply pass these as additional parameters,\nor omit them to return all features in the dimension. Python ranges work where where dimensions are numeric. For example, to retrieve population\ndata for all WDI versions in 2019, do this:\n\n    wb.db = 57\n    for row in wb.data.fetch('SP.POP.TOTL', ['BRA', 'COL', 'ARG'], time=range(2010,2015), version=range(201901,201912)):\n      ...\n\nor:\n\n    for row in wb.data.fetch('SP.POP.TOTL', ['BRA', 'COL', 'ARG'], time=range(2010,2015), version=range(201901,201912), db=57):\n      ...\n\nwbgapi will create multi-index DataFrames where necessary, although you may need to fiddle with the index and column parameters to get what you want.\nHere is how to run the same query arranged to more easily compare different versions of the same series:\n\n    wb.data.DataFrame('SP.POP.TOTL', ['BRA', 'COL', 'ARG'], time=range(2010,2015), version=range(201901,201912), index=['economy', 'time'], db=57)\n\n                     YR2010       YR2011       YR2012       YR2013       YR2014\n    ARG 201901   41223889.0   41656879.0   42096739.0   42539925.0   42981515.0\n        201903   41223889.0   41656879.0   42096739.0   42539925.0   42981515.0\n        201904   41223889.0   41656879.0   42096739.0   42539925.0   42981515.0\n        201906   40788453.0   41261490.0   41733271.0   42202935.0   42669500.0\n    ...\n    BRA 201901  196796269.0  198686688.0  200560983.0  202408632.0  204213133.0\n        201903  196796269.0  198686688.0  200560983.0  202408632.0  204213133.0\n        201904  196796269.0  198686688.0  200560983.0  202408632.0  204213133.0\n        201906  195713635.0  197514534.0  199287296.0  201035903.0  202763735.0\n    ...\n    COL 201901   45918097.0   46406646.0   46881475.0   47342981.0   47791911.0\n        201903   45918097.0   46406646.0   46881475.0   47342981.0   47791911.0\n        201904   45918097.0   46406646.0   46881475.0   47342981.0   47791911.0\n        201906   45222700.0   45663099.0   46076848.0   46497267.0   46969209.0\n    ...\n\n### Metadata ###\n\nwbgapi returns metadata for series, economies and combinations:\n\n    wb.series.metadata.get('SP.POP.TOTL', economies=['KEN', 'TZA'])\n\n    for i in wb.economy.metadata.get('all'):\n      print(i)\n\nor single footnotes:\n\n    print(wb.data.footnote('SP.POP.TOTL', 'FRA', 2015))\n\n### Resolving Country Names ###\n\nwbgapi includes utility function that resolves common spellings of country names to the ISO3 codes used by the API. The\nreturn from this function is a \"dict\" subclass that provides a nice report, but can still be processed programmatically:\n\n    wb.economy.coder(['Argentina', 'Swaziland', 'South Korea', 'England', 'Chicago'])\n    ORIGINAL NAME    WBG NAME        ISO_CODE\n    ---------------  --------------  ----------\n    Argentina        Argentina       ARG\n    Swaziland        Eswatini        SWZ\n    South Korea      Korea, Rep.     KOR\n    England          United Kingdom  GBR\n    Chicago\n\n---\n\nHopefully that gives you a taste and enough to get started. Use `help()` and read the docstrings for lots more examples, information, and ideas.\n\n## Customizing the Display ##\n\nwbgapi provides fairly good support for IPython, Jupyter Notebook, etc and will generally return HTML\noutput for things like tables in those environments. HTML output is wrapped in a `<div class=\"wbgapi\"/>`\ncontainer so that you can customize the CSS if you so desire (for instance, I like to left-align the columns).\nThe location of your custom.css varies depending on your environment. Note that this does not apply\nto DataFrame objects, which are formatted by pandas.\n\n## Proxy servers ##\n\n`wbgapi.proxies` can be configured to support proxy servers. This variable is passed\n[directly to the requests module](https://requests.readthedocs.io/en/master/user/advanced/#proxies).\n\n    wb.proxies = {\n      'http': 'http://10.10.1.10:3128',\n      'https': 'http://10.10.1.10:1080',\n    }\n\n## Limitations ##\n\n* WBGAPI requires Python 3.x (it's 2020, and the [sun has set on Python 2.x][sunset]). Time\n  to move on if you haven't already.\n\n* WBGAPI is fully multi-lingual. However, as of this writing, the API endpoints it depends\n  on are returning English-only, which means that in practice the module is English-only as well.\n  Short of some serious hacks which have their own negative consequences, it's not really possible\n  to fix this until the API itself sees some improvements.\n\n* WBGAPI has no built-in caching. However, it makes all its requests through [requests][requests], which\n  can be cached via [requests cache][req-cache]\n\n[beta-endpoints]: https://datahelpdesk.worldbank.org/knowledgebase/articles/1886686-advanced-data-api-queries\n[pandas]: https://pandas.pydata.org\n[sunset]: https://www.python.org/doc/sunset-python-2/\n[requests]: https://requests.readthedocs.io/en/master/\n[req-cache]: https://pypi.org/project/requests-cache/\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tgherzog/wbgapi", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "wbgapi", "package_url": "https://pypi.org/project/wbgapi/", "platform": "", "project_url": "https://pypi.org/project/wbgapi/", "project_urls": {"Homepage": "https://github.com/tgherzog/wbgapi"}, "release_url": "https://pypi.org/project/wbgapi/1.0.1/", "requires_dist": ["requests", "PyYAML", "tabulate"], "requires_python": ">=3.0", "summary": "wbgapi provides a comprehensive interface to the World Bank's data and metadata APIs", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>WBGAPI</h1>\n<p>WBGAPI provides modern, pythonic access to the World Bank's data API.\nIt is designed both for data novices and data scientist types.\nWBGAPI tries to shield users from some of the confusing ideosyncrasies\nof the World Bank's API while remaining consistent and intuitive for\nthose who are familiar with its basic data structures. More on that later.</p>\n<p>WBGAPI differs from other modules in a few respects. The most significant\nis that it queries databases individually instead of collectively. To appreciate\nthe difference, consider this API request:</p>\n<p><a href=\"https://api.worldbank.org/v2/indicator\" rel=\"nofollow\">https://api.worldbank.org/v2/indicator</a></p>\n<p>As of this writing, this request returns 17,328 resulting indicators. But what\nthis obscures is that these indicators are stored in 57 separate databases,\nupdated on different schedules, and covering different time spans and country\ngroups. Many indicators appear in more than one database. While it's possible\nto use the API to get more precise results, it's not always easy to understand\nwhat you're requesting or where it's actually coming from.</p>\n<p>WBGAPI fixes this issue by only querying a single database at a time using a <a href=\"https://datahelpdesk.worldbank.org/knowledgebase/articles/1886686-advanced-data-api-queries\" rel=\"nofollow\">relatively\nnew set of endpoints</a>. This gives users an accurate picture\nof both the data, dimensions and features of that database. The default database\nis the World Development Indicators (WDI) but you can switch databases at any time.</p>\n<p>Other key features:</p>\n<ul>\n<li>\n<p>Easily select multiple series, economies (countries) and time periods in a single request</p>\n</li>\n<li>\n<p>Select individual years, ranges, and most recent values (MRVs)</p>\n</li>\n<li>\n<p>Metadata queries</p>\n</li>\n<li>\n<p>Very \"pythonic\": use of generators, ranges and sets make data access easy and elegant</p>\n</li>\n<li>\n<p>Extensive <a href=\"https://pandas.pydata.org\" rel=\"nofollow\">pandas</a> support (optional)</p>\n</li>\n<li>\n<p>Multi-lingual support (sort of. See \"Limitations\" section below)</p>\n</li>\n</ul>\n<h2>Installation</h2>\n<pre><code>pip install wbgapi\n</code></pre>\n<h2>Quick Start</h2>\n<p>Import the module; my preferred namespace is <code>wb</code>:</p>\n<pre><code>import wbgapi as wb\n</code></pre>\n<p>WBGAPI includes extenstive docstrings with lots of examples:</p>\n<pre><code>help(wb)  \nhelp(wb.series)  \n[etc]\n</code></pre>\n<p>Every element type is its own object: source, series, region, time,\netc. Note that \"countries\" and aggregates are accessed through the \"economy\"\nobject and the time dimension is always accessed through the time object.\nAll World Bank databases have a series, time, and economy dimension,\nalthough the API is not consistent in its concept scheme across databases.\nFor example, in some databases the economy dimension is called 'economy' or 'province'\ninstead of 'country' and the time dimension is sometimes called 'year.'\nThe WBGAPI module saves you most of that headache.</p>\n<p>Objects tend to use a common set of functions which you'll use heavily:</p>\n<ul>\n<li>\n<p><code>list()</code> returns an interative list of basic data elements. Actually, it returns a python generator.\nYou can pass parameters to limit the list, but by default it returns all elements\nin the database.</p>\n</li>\n<li>\n<p><code>get()</code> returns a single object.</p>\n</li>\n<li>\n<p><code>info()</code> prints a summary report of objects: all elements by default. These are great\nif you just want to quickly see what's in a database.</p>\n</li>\n<li>\n<p><code>fetch()</code> functions return data and metadata. They usually involve more arguments\nand return more complicated objects, but are otherwise similar to <code>list()</code></p>\n</li>\n</ul>\n<p>Alrighty then, let's fire it up:</p>\n<pre><code>import wbgapi as wb\n\n# show the series list\nwb.series.info()\nid                         value\nAG.AGR.TRAC.NO             Agricultural machinery, tractors\nAG.CON.FERT.PT.ZS          Fertilizer consumption (% of fertilizer production)\nAG.CON.FERT.ZS             Fertilizer consumption (kilograms per hectare of arable land)\nAG.LND.AGRI.K2             Agricultural land (sq. km)\nAG.LND.AGRI.ZS             Agricultural land (% of land area)\nAG.LND.ARBL.HA             Arable land (hectares)\nAG.LND.ARBL.HA.PC          Arable land (hectares per person)\nAG.LND.ARBL.ZS             Arable land (% of land area)\n...\n                           1429 elements\n\nwb.time.info()\nid      value\nYR1960  1960\nYR1961  1961\nYR1962  1962\nYR1963  1963\nYR1964  1964\n...\n        60 elements\n</code></pre>\n<p>That first command will take a while and run a very long report due to the size of the WDI.</p>\n<p>Use <code>get()</code> and <code>list()</code> to access the underlying objects:</p>\n<pre><code>wb.economy.get('COL')\n{'id': 'COL', 'value': 'Colombia', 'aggregate': False, 'longitude': -74.082, 'latitude': 4.60987, 'region': 'LCN', 'adminregion': 'LAC', 'lendingType': 'IBD', 'incomeLevel': 'UMC', 'capitalCity': 'Bogota'}\n\nstuff = {i['id']: i['value'] for i in wb.series.list(['SP.POP.TOTL', 'SI.POV.NAHC'])}\nstuff\n{'SP.POP.TOTL': 'Population, total', 'SI.POV.NAHC': 'Poverty headcount ratio at national poverty lines (% of population)'}\n</code></pre>\n<p>API veterans might notice that the objects use <code>value</code> for element names instead of <code>name</code>. That's an artifact of the \"advanced\" queries\nmentioned previously.</p>\n<p>Any single identifier or iterable object can generally be passed as an argument to select series, economies, regions, and so forth.\nHere's an easy way to get a list of high-income countries:</p>\n<pre><code>for row in wb.economy.list(wb.region.members('HIC')):\n    print(row['value'])\n</code></pre>\n<h3>Data Requests</h3>\n<p>Again, use <code>fetch()</code> for multiple rows of data, and <code>get()</code> for single rows. Python ranges are an easy way to\nindicate which time periods you want.</p>\n<pre><code># this request fetches data for 3 countries from 2010-2015. Be careful with requests\n# that omit constraints on economies and/or time as these can take a long time to run\n# and return large numbers of rows\nfor row in wb.data.fetch('SP.POP.TOTL', economy=['BRA', 'ARG', 'URY'], time=range(2010,2015)):\n    print(row)\n\n{'value': 3400434, 'series': 'SP.POP.TOTL', 'economy': 'URY', 'aggregate': False, 'time': 'YR2014'}\n{'value': 3389439, 'series': 'SP.POP.TOTL', 'economy': 'URY', 'aggregate': False, 'time': 'YR2013'}\n{'value': 3378974, 'series': 'SP.POP.TOTL', 'economy': 'URY', 'aggregate': False, 'time': 'YR2012'}\n...\n{'value': 13082.664325572, 'series': 'NY.GDP.PCAP.CD', 'economy': 'ARG', 'aggregate': False, 'time': 'YR2012'}\n{'value': 12848.8641969705, 'series': 'NY.GDP.PCAP.CD', 'economy': 'ARG', 'aggregate': False, 'time': 'YR2011'}\n{'value': 10385.9644319555, 'series': 'NY.GDP.PCAP.CD', 'economy': 'ARG', 'aggregate': False, 'time': 'YR2010'}\n</code></pre>\n<p>Or if you want the most recent value for every country (omitting aggregates), including both element codes and labels:</p>\n<pre><code>for row in wb.data.fetch('SP.POP.TOTL', mrnev=1, skipAggs=True, labels=True):\n    print(row['economy'], row['value'])\n\n{'id': 'AFG', 'value': 'Afghanistan', 'aggregate': False} 37172386\n{'id': 'ALB', 'value': 'Albania', 'aggregate': False} 2866376\n{'id': 'DZA', 'value': 'Algeria', 'aggregate': False} 42228429\n{'id': 'ASM', 'value': 'American Samoa', 'aggregate': False} 55465\n...\n</code></pre>\n<h3>Pandas</h3>\n<p>Data and economy queries can be returned as pandas DataFrames. For example:</p>\n<pre><code># data frame of population data for even-numbered years\nwb.data.DataFrame('SP.POP.TOTL', time=range(2010,2020,2),labels=True)\n            Label      YR2010      YR2012      YR2014      YR2016      YR2018\nABW         Aruba    101669.0    102560.0    103774.0    104872.0    105845.0\nAFG   Afghanistan  29185507.0  31161376.0  33370794.0  35383128.0  37172386.0\nAGO        Angola  23356246.0  25107931.0  26941779.0  28842484.0  30809762.0\nALB       Albania   2913021.0   2900401.0   2889104.0   2876101.0   2866376.0\nAND       Andorra     84449.0     82427.0     79213.0     77297.0     77006.0\n..            ...         ...         ...         ...         ...         ...\nXKX        Kosovo   1775680.0   1805200.0   1821800.0   1816200.0   1845300.0\nYEM   Yemen, Rep.  23154855.0  24473178.0  25823485.0  27168210.0  28498687.0\nZAF  South Africa  51216964.0  52834005.0  54545991.0  56203654.0  57779622.0\nZMB        Zambia  13605984.0  14465121.0  15399753.0  16363507.0  17351822.0\nZWE      Zimbabwe  12697723.0  13115131.0  13586681.0  14030390.0  14439018.0\n</code></pre>\n<p><code>economy</code>, <code>region</code>, <code>income</code>, and <code>lending</code> can also return Pandas objects. Here is how you might add the income group to the query above:</p>\n<pre><code>c = wb.economy.DataFrame()\ndf = wb.data.DataFrame('SP.POP.TOTL', time=range(2010,2020,2),labels=True,skipAggs=True).join(c['incomeLevel'])\ndf\n            Label      YR2010      YR2012      YR2014      YR2016      YR2018 incomeLevel\nABW         Aruba    101669.0    102560.0    103774.0    104872.0    105845.0         HIC\nAFG   Afghanistan  29185507.0  31161376.0  33370794.0  35383128.0  37172386.0         LIC\nAGO        Angola  23356246.0  25107931.0  26941779.0  28842484.0  30809762.0         LMC\nALB       Albania   2913021.0   2900401.0   2889104.0   2876101.0   2866376.0         UMC\nAND       Andorra     84449.0     82427.0     79213.0     77297.0     77006.0         HIC\n..            ...         ...         ...         ...         ...         ...         ...\n</code></pre>\n<p>And then aggregate (albeit unweighted):</p>\n<pre><code>df.groupby('incomeLevel').mean()\n                   YR2010        YR2012        YR2014        YR2016        YR2018\nincomeLevel                                                                      \nHIC          1.436314e+07  1.451850e+07  1.469533e+07  1.487142e+07  1.502200e+07\nLIC          1.862174e+07  2.012211e+07  2.113464e+07  2.222469e+07  2.339882e+07\nLMC          5.720078e+07  5.898364e+07  6.076860e+07  6.254959e+07  6.431713e+07\nUMC          4.165684e+07  4.229376e+07  4.296426e+07  4.363008e+07  4.426060e+07\n</code></pre>\n<p>Of course, these DataFrames can be used for any sort of analysis and operations that pandas supports,\nand can be used with lots of various visualization libraries. Time series can be easily plotted by transposing a DataFrame:</p>\n<pre><code>wb.data.DataFrame('NY.GDP.PCAP.CD', ['BRA', 'ARG'], time=range(2000,2020),numericTimeKeys=True).transpose().plot()\n</code></pre>\n<p>Use pandas' <code>reset_index</code> option to fetch unindexed columns of indicators:</p>\n<pre><code>wb.data.DataFrame(['SP.POP.TOTL', 'NY.GDP.PCAP.CD', 'EN.ATM.CO2E.KT'],time=range(2000,2010), numericTimeKeys=True, columns='series').reset_index()\n      time economy  EN.ATM.CO2E.KT  NY.GDP.PCAP.CD  SP.POP.TOTL\n0     2000     ABW        2379.883    20620.700626      90853.0\n1     2000     AFG         773.737             NaN   20779953.0\n2     2000     AGO        9541.534      556.836318   16395473.0\n3     2000     ALB        3021.608     1126.683318    3089027.0\n4     2000     AND         524.381    21936.530101      65390.0\n...    ...     ...             ...             ...          ...\n2635  2009     XKX             NaN     3209.711460    1761474.0\n2636  2009     YEM       24561.566     1116.084594   22516460.0\n2637  2009     ZAF      503112.400     5862.797340   50477011.0\n2638  2009     ZMB        2508.228     1159.907762   13215139.0\n2639  2009     ZWE        5603.176      771.598786   12526968.0\n</code></pre>\n<h3>Switching databases</h3>\n<p>Use the <code>source</code> object to learn about other databases and the <code>db</code> variable to change the global database target:</p>\n<pre><code>wb.source.info()\nid  name\n1   Doing Business\n2   World Development Indicators\n3   Worldwide Governance Indicators\n5   Subnational Malnutrition Database\n...\n\nwb.db = 1   # change to Doing Business\nwb.series.info()\nid                                                 value\nENF.CONT.COEN.ATDR                                 Enforcing contracts: Alternative dispute resolution (0-3) (DB16-20 methodology)\nENF.CONT.COEN.ATFE.PR                              Enforcing contracts: Attorney fees (% of claim)\nENF.CONT.COEN.COST.ZS                              Enforcing contracts: Cost (% of claim)\n...\n</code></pre>\n<p>Most functions also accept a <code>db</code> parameter to specify the database as an argument. This option will override the global option.</p>\n<h3>Custom Dimensions</h3>\n<p>Most databases consist of 3 dimensional concepts: <code>series</code>, <code>country</code> and <code>time</code>. But this is not always the case: several databases use <code>economy</code>, <code>state</code>\nor something else in lieu of <code>country</code> and at least one uses <code>year</code> in lieu of <code>time</code>. To make programming more intuitive, wbgapi normalizes common\ndimensions as <code>economy</code> and <code>time</code> so that you don't have to guess (this includes subnational databases, since at this point all databases capture\nall administrative levels in the same dimension).</p>\n<p>You can access a database's actual concept structure like this:</p>\n<pre><code>for k,v in wb.source.concepts().items():\n    print(k, v)\n</code></pre>\n<p>Some databases have additional dimensions; for instance, WDI Archives (57) has a version dimension. Simply pass these as additional parameters,\nor omit them to return all features in the dimension. Python ranges work where where dimensions are numeric. For example, to retrieve population\ndata for all WDI versions in 2019, do this:</p>\n<pre><code>wb.db = 57\nfor row in wb.data.fetch('SP.POP.TOTL', ['BRA', 'COL', 'ARG'], time=range(2010,2015), version=range(201901,201912)):\n  ...\n</code></pre>\n<p>or:</p>\n<pre><code>for row in wb.data.fetch('SP.POP.TOTL', ['BRA', 'COL', 'ARG'], time=range(2010,2015), version=range(201901,201912), db=57):\n  ...\n</code></pre>\n<p>wbgapi will create multi-index DataFrames where necessary, although you may need to fiddle with the index and column parameters to get what you want.\nHere is how to run the same query arranged to more easily compare different versions of the same series:</p>\n<pre><code>wb.data.DataFrame('SP.POP.TOTL', ['BRA', 'COL', 'ARG'], time=range(2010,2015), version=range(201901,201912), index=['economy', 'time'], db=57)\n\n                 YR2010       YR2011       YR2012       YR2013       YR2014\nARG 201901   41223889.0   41656879.0   42096739.0   42539925.0   42981515.0\n    201903   41223889.0   41656879.0   42096739.0   42539925.0   42981515.0\n    201904   41223889.0   41656879.0   42096739.0   42539925.0   42981515.0\n    201906   40788453.0   41261490.0   41733271.0   42202935.0   42669500.0\n...\nBRA 201901  196796269.0  198686688.0  200560983.0  202408632.0  204213133.0\n    201903  196796269.0  198686688.0  200560983.0  202408632.0  204213133.0\n    201904  196796269.0  198686688.0  200560983.0  202408632.0  204213133.0\n    201906  195713635.0  197514534.0  199287296.0  201035903.0  202763735.0\n...\nCOL 201901   45918097.0   46406646.0   46881475.0   47342981.0   47791911.0\n    201903   45918097.0   46406646.0   46881475.0   47342981.0   47791911.0\n    201904   45918097.0   46406646.0   46881475.0   47342981.0   47791911.0\n    201906   45222700.0   45663099.0   46076848.0   46497267.0   46969209.0\n...\n</code></pre>\n<h3>Metadata</h3>\n<p>wbgapi returns metadata for series, economies and combinations:</p>\n<pre><code>wb.series.metadata.get('SP.POP.TOTL', economies=['KEN', 'TZA'])\n\nfor i in wb.economy.metadata.get('all'):\n  print(i)\n</code></pre>\n<p>or single footnotes:</p>\n<pre><code>print(wb.data.footnote('SP.POP.TOTL', 'FRA', 2015))\n</code></pre>\n<h3>Resolving Country Names</h3>\n<p>wbgapi includes utility function that resolves common spellings of country names to the ISO3 codes used by the API. The\nreturn from this function is a \"dict\" subclass that provides a nice report, but can still be processed programmatically:</p>\n<pre><code>wb.economy.coder(['Argentina', 'Swaziland', 'South Korea', 'England', 'Chicago'])\nORIGINAL NAME    WBG NAME        ISO_CODE\n---------------  --------------  ----------\nArgentina        Argentina       ARG\nSwaziland        Eswatini        SWZ\nSouth Korea      Korea, Rep.     KOR\nEngland          United Kingdom  GBR\nChicago\n</code></pre>\n<hr>\n<p>Hopefully that gives you a taste and enough to get started. Use <code>help()</code> and read the docstrings for lots more examples, information, and ideas.</p>\n<h2>Customizing the Display</h2>\n<p>wbgapi provides fairly good support for IPython, Jupyter Notebook, etc and will generally return HTML\noutput for things like tables in those environments. HTML output is wrapped in a <code>&lt;div class=\"wbgapi\"/&gt;</code>\ncontainer so that you can customize the CSS if you so desire (for instance, I like to left-align the columns).\nThe location of your custom.css varies depending on your environment. Note that this does not apply\nto DataFrame objects, which are formatted by pandas.</p>\n<h2>Proxy servers</h2>\n<p><code>wbgapi.proxies</code> can be configured to support proxy servers. This variable is passed\n<a href=\"https://requests.readthedocs.io/en/master/user/advanced/#proxies\" rel=\"nofollow\">directly to the requests module</a>.</p>\n<pre><code>wb.proxies = {\n  'http': 'http://10.10.1.10:3128',\n  'https': 'http://10.10.1.10:1080',\n}\n</code></pre>\n<h2>Limitations</h2>\n<ul>\n<li>\n<p>WBGAPI requires Python 3.x (it's 2020, and the <a href=\"https://www.python.org/doc/sunset-python-2/\" rel=\"nofollow\">sun has set on Python 2.x</a>). Time\nto move on if you haven't already.</p>\n</li>\n<li>\n<p>WBGAPI is fully multi-lingual. However, as of this writing, the API endpoints it depends\non are returning English-only, which means that in practice the module is English-only as well.\nShort of some serious hacks which have their own negative consequences, it's not really possible\nto fix this until the API itself sees some improvements.</p>\n</li>\n<li>\n<p>WBGAPI has no built-in caching. However, it makes all its requests through <a href=\"https://requests.readthedocs.io/en/master/\" rel=\"nofollow\">requests</a>, which\ncan be cached via <a href=\"https://pypi.org/project/requests-cache/\" rel=\"nofollow\">requests cache</a></p>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 7089423, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "d6f80d53d61c5ce696ab7ecef9a11cb2", "sha256": "9d467e2521010b9ec2e42d9a13201659f2c3701134a92367b5414dc2b4bfc1eb"}, "downloads": -1, "filename": "wbgapi-1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d6f80d53d61c5ce696ab7ecef9a11cb2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.0", "size": 34155, "upload_time": "2020-04-24T02:21:18", "upload_time_iso_8601": "2020-04-24T02:21:18.266253Z", "url": "https://files.pythonhosted.org/packages/b2/ae/50c82e02438fb3df98a0ec93f820fc02e7432b274666795b3820abda518f/wbgapi-1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "75897487be66df1f8f8c59a38ca8cb20", "sha256": "5c1a4ed6f5ba864cb32080f445042a97628c50c17f90b8def54e40870ad0f5ff"}, "downloads": -1, "filename": "wbgapi-1.0.tar.gz", "has_sig": false, "md5_digest": "75897487be66df1f8f8c59a38ca8cb20", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.0", "size": 34404, "upload_time": "2020-04-24T02:21:20", "upload_time_iso_8601": "2020-04-24T02:21:20.031910Z", "url": "https://files.pythonhosted.org/packages/61/39/d0631a28cf8b674246a0e8f0215aa3b62ff55ea114493373b32139429d4b/wbgapi-1.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "62c237b694efccff428f689c3f5da366", "sha256": "2f21022ef65ba3c181031cbc3cbdfd3d26e73cae4ae6f1a66b15b66ce3757a1d"}, "downloads": -1, "filename": "wbgapi-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "62c237b694efccff428f689c3f5da366", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.0", "size": 34018, "upload_time": "2020-04-24T02:45:24", "upload_time_iso_8601": "2020-04-24T02:45:24.700993Z", "url": "https://files.pythonhosted.org/packages/56/99/c7441c5584b8424244bbdd99becb56af6a2da77d2f75d5682779a85380cb/wbgapi-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fc7f6f4bdd205a8bf7bd64405b2f4f8b", "sha256": "2280f620890385bc64be1297beb167126a1e00ab8aeca5455df0e5d1d533fbc2"}, "downloads": -1, "filename": "wbgapi-1.0.1.tar.gz", "has_sig": false, "md5_digest": "fc7f6f4bdd205a8bf7bd64405b2f4f8b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.0", "size": 34089, "upload_time": "2020-04-24T02:45:25", "upload_time_iso_8601": "2020-04-24T02:45:25.678381Z", "url": "https://files.pythonhosted.org/packages/98/cb/428e97905aba8c8040bc6c447d691d5449dfeb0d035cb34dafc47f517514/wbgapi-1.0.1.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "a82ef3683041205d53499ee5665a32cd", "sha256": "365fc3f68b0f0ca695286c14255cf2dc431cd17eab59b650581b194fa2f9ddd7"}, "downloads": -1, "filename": "wbgapi-1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a82ef3683041205d53499ee5665a32cd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.0", "size": 34158, "upload_time": "2020-04-24T02:26:10", "upload_time_iso_8601": "2020-04-24T02:26:10.087622Z", "url": "https://files.pythonhosted.org/packages/83/45/cdc749befbe45e41f8d2a26dcd0b28a384657f6e79078f60be129ae3632c/wbgapi-1.1-py3-none-any.whl", "yanked": true}, {"comment_text": "", "digests": {"md5": "8b50ff76ed78b3f4f8a99eeb35c468df", "sha256": "14a642bdccf5f21e67fea36346c05d9ef91c3d0e4be45669a0d281ab9f1c479d"}, "downloads": -1, "filename": "wbgapi-1.1.tar.gz", "has_sig": false, "md5_digest": "8b50ff76ed78b3f4f8a99eeb35c468df", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.0", "size": 34411, "upload_time": "2020-04-24T02:26:11", "upload_time_iso_8601": "2020-04-24T02:26:11.083504Z", "url": "https://files.pythonhosted.org/packages/f2/ec/21f785103193942e9edc60120063f9b01e635b9fad33f2fbf29da8251c2a/wbgapi-1.1.tar.gz", "yanked": true}], "1.1.1": [{"comment_text": "", "digests": {"md5": "817240dac6bf8dd8a3b7ac0188450e2a", "sha256": "d5c33c8cf0e7a7064d196d1eb0157226acb5b3d9efe1850a7c86ad6ce6eea2b6"}, "downloads": -1, "filename": "wbgapi-1.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "817240dac6bf8dd8a3b7ac0188450e2a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.0", "size": 34022, "upload_time": "2020-04-24T02:39:30", "upload_time_iso_8601": "2020-04-24T02:39:30.600017Z", "url": "https://files.pythonhosted.org/packages/d0/fe/d2cc37180ee984e6711b93ffb8242dd85215d8c883003d433e3b5da3a784/wbgapi-1.1.1-py3-none-any.whl", "yanked": true}, {"comment_text": "", "digests": {"md5": "2e66469f63dc60091fefcde8aa53302c", "sha256": "d929e39a1e91b2c8992e4884712221989102d212aa4dd8da6fb1bff9b920a467"}, "downloads": -1, "filename": "wbgapi-1.1.1.tar.gz", "has_sig": false, "md5_digest": "2e66469f63dc60091fefcde8aa53302c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.0", "size": 34096, "upload_time": "2020-04-24T02:39:31", "upload_time_iso_8601": "2020-04-24T02:39:31.515957Z", "url": "https://files.pythonhosted.org/packages/97/0e/6d5c471fd32c799a01ee779c13e21edc96a5115644998d5dedb5a30a687f/wbgapi-1.1.1.tar.gz", "yanked": true}], "1.1.2": [{"comment_text": "", "digests": {"md5": "c8ed1e9b0034a29f4a7af86045f83db9", "sha256": "77f4807db012bb8e44708c3f003a467171e38647972ad76ec4b5a4981ff3d59b"}, "downloads": -1, "filename": "wbgapi-1.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "c8ed1e9b0034a29f4a7af86045f83db9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.0", "size": 34018, "upload_time": "2020-04-24T02:44:31", "upload_time_iso_8601": "2020-04-24T02:44:31.540068Z", "url": "https://files.pythonhosted.org/packages/6d/2e/797c98a1eaf099b9f9cc343892db860f3719c3cf8cd413384d8e426c2d76/wbgapi-1.1.2-py3-none-any.whl", "yanked": true}, {"comment_text": "", "digests": {"md5": "b73f65dd42315215d0f04ad2c9b496f5", "sha256": "f297bf7e903b8be6a6b31d596a7e290f55dd25000dc08bb50f0043efa6ec91da"}, "downloads": -1, "filename": "wbgapi-1.1.2.tar.gz", "has_sig": false, "md5_digest": "b73f65dd42315215d0f04ad2c9b496f5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.0", "size": 34087, "upload_time": "2020-04-24T02:44:32", "upload_time_iso_8601": "2020-04-24T02:44:32.638821Z", "url": "https://files.pythonhosted.org/packages/9d/cc/ba1879bb58822a6126f5f77c6dd0845e7275b2d43d323bcbe9ce1d517961/wbgapi-1.1.2.tar.gz", "yanked": true}]}, "urls": [{"comment_text": "", "digests": {"md5": "62c237b694efccff428f689c3f5da366", "sha256": "2f21022ef65ba3c181031cbc3cbdfd3d26e73cae4ae6f1a66b15b66ce3757a1d"}, "downloads": -1, "filename": "wbgapi-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "62c237b694efccff428f689c3f5da366", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.0", "size": 34018, "upload_time": "2020-04-24T02:45:24", "upload_time_iso_8601": "2020-04-24T02:45:24.700993Z", "url": "https://files.pythonhosted.org/packages/56/99/c7441c5584b8424244bbdd99becb56af6a2da77d2f75d5682779a85380cb/wbgapi-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fc7f6f4bdd205a8bf7bd64405b2f4f8b", "sha256": "2280f620890385bc64be1297beb167126a1e00ab8aeca5455df0e5d1d533fbc2"}, "downloads": -1, "filename": "wbgapi-1.0.1.tar.gz", "has_sig": false, "md5_digest": "fc7f6f4bdd205a8bf7bd64405b2f4f8b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.0", "size": 34089, "upload_time": "2020-04-24T02:45:25", "upload_time_iso_8601": "2020-04-24T02:45:25.678381Z", "url": "https://files.pythonhosted.org/packages/98/cb/428e97905aba8c8040bc6c447d691d5449dfeb0d035cb34dafc47f517514/wbgapi-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:31:49 2020"}