{"info": {"author": "Bjorn Madsen", "author_email": "bjorn.madsen@operationsresearchgroup.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "# graph-theory\n[![Build Status](https://travis-ci.org/root-11/graph-theory.svg?branch=master)](https://travis-ci.org/root-11/graph-theory)\n[![Code coverage](https://codecov.io/gh/root-11/graph-theory/branch/master/graph/badge.svg)](https://codecov.io/gh/root-11/graph-theory)\n\nA simple graph library...<br>\n*... A bit like networkx, just without the overhead...*<br> \n*... similar to graph-tool, without the Python 2.7 legacy...*<br>\n*... with code that you can explain to your boss...*<br>\n\n---------------------------\nInstall:\n\n    pip install graph-theory\n\n---------------------------\nImport:\n\n    import Graph\n    g = Graph()  \n\n    import Graph3d\n    g3d = Graph3D()\n\n---------------------------\n\nModules:\n\n| module | description |\n|:---|:---|\n| `from graph import Graph, Graph3D` | Elementary methods (see basic methods below) for Graph and Graph3D.|\n| `from graph import ...` | All methods available on Graph (see table below) |\n| `from graph.assignment_problem import ...` | solvers for assignment problem, the Weapons-Target Assignment Problem, ... |\n| `from graph.hash import ...` | graph hash functions: graph hash, merkle tree, flow graph hash | \n| `from graph.random import ...` | graph generators for random, 2D and 3D graphs. |\n| `from graph.transshipment_problem import ...` | solvers for the transshipment problem |\n| `from graph.visuals import ...` | methods for creating matplotlib plots |\n| `from graph.finite_state_machine import ...` | finite state machine |\n\n\nAll module functions are available from Graph and Graph3D (where applicable).\n\n| Graph | Graph3D | methods | returns |\n|:---:|:---:|:---|:---|\n| + | + | `a in g` | assert if g contains node a |\n| + | + | `g.add_node(n, [obj])` | adds a node (with a pointer to object `obj` if given) |\n| + | + | `g.copy()` | returns a shallow copy of `g` |\n| + | + | `g.node(node1)` | returns object attached to node 1 |\n| + | + | `g.del_node(node1)` | deletes node1 and all it's edges |\n| + | + | `g.nodes()` | returns a list of nodes |\n| + | + | `len(g.nodes())` | returns the number of nodes |\n| + | + | `g.nodes(from_node=1)` | returns nodes with edges from node 1 |\n| + | + | `g.nodes(to_node=2)` | returns nodes with edges to node 2 |\n| + | + | `g.nodes(in_degree=2)` | returns nodes with 2 incoming edges |\n| + | + | `g.nodes(out_degree=2)` | returns nodes with 2 outgoing edges |\n| + | + | `g.add_edge(1,2,3)` | adds edge to g for vector `(1,2)` with value `3` |\n| + | + | `g.edge(1,2)` | returns value of edge between nodes 1 and 2 |\n| + | + | `g.edge(1,2,default=3)` | returns `default=3` if `edge(1,2)` doesn't exist. <br>similar to `d.get(key, 3)`|\n| + | + | `g.del_edge(1,2)` | removes edge between nodes 1 and 2 |\n| + | + | `g.edges()` | returns a list of edges |\n| + | + | `len(g.edges())` | returns the number of edges |\n| + | + | `g.edges(path=[path])` | returns a list of edges (along a path if given). |\n| + | + | `same_path(p1,p2)` | compares two paths to determine if they contain same sequences <br>ex.: `[1,2,3] == [2,3,1]`  |\n| + | + | `g.edges(from_node=1)` | returns edges outgoing from node 1 |\n| + | + | `g.edges(to_node=2)` | returns edges incoming to node 2 |\n| + | + | `g.from_dict(d)` | updates the graph from a dictionary |\n| + | + | `g.to_dict()` | returns the graph as a dictionary |\n| + | + | `g.from_list(L)` | updates the graph from a list |\n| + | + | `g.to_list()` | return the graph as a list of edges |\n| + | + | `g.shortest_path(start,end)` | returns the distance and path for path with smallest edge sum |\n| + | + | `g.is_connected(start,end)` | determines if there is a path from start to end |\n| + | + | `g.breadth_first_search(start,end)` | returns the number of edges and path with fewest edges |\n| + | + | `g.degree_of_separation(n1,n2)` | returns the distance between two nodes using BFS |\n| + | + | `g.network_size(n1, degree_of_separation)` | returns the nodes within the range given by `degree_of_separation` |\n| + | + | `g.phase_lines()` | returns a dictionary with the phase_lines for a non-cyclic graph. |\n| + | + | `g.sources(n)` | returns the source_tree of node `n` |\n| + | + | `g.depth_first_search(start,end)` | returns path using DFS and backtracking  |\n| + | + | `g.depth_scan(start, criteria)` | returns set of nodes where criteria is True |\n| + | + | `g.distance_from_path(path)` | returns the distance for path. |\n| + | + | `g.maximum_flow(source,sink)` | finds the maximum flow between a source and a sink |\n| + | + | `g.solve_tsp()` | solves the traveling salesman problem for the graph |\n| + | + | `g.subgraph_from_nodes(nodes)` | returns the subgraph of `g` involving `nodes` |\n| + | + | `g.is_subgraph(g2)` | determines if graph `g2` is a subgraph in g |\n| + | + | `g.is_partite(n)` | determines if graph is n-partite |\n| + | + | `g.has_cycles()` | determines if there are any cycles in the graph |\n| + | + | `g.components()` | returns set of nodes in each component in `g` |\n| + | + | `g.same_path(p1,p2)` | compares two paths, returns True if they're the same |\n| + | + | `g.adjacency_matrix()` | returns the adjacency matrix for the graph |\n| + | + | `g.all_pairs_shortest_paths()` | finds the shortest path between all nodes |\n| + | + | `g.minsum()` | finds the node(s) with shortest total distance to all other nodes |\n| + | + | `g.minmax()` | finds the node(s) with shortest maximum distance to all other nodes |\n| + | + | `g.shortest_tree_all_pairs()` | finds the shortest tree for all pairs |\n| + | + | `g.has_path(p)` | asserts whether a path `p` exists in g |\n| + | + | `g.all_paths(start,end)` | finds all combinations of paths between 2 nodes|\n| - | + | `g3d.distance(n1,n2)` | returns the spatial distance between `n1` and `n2` |\n| - | + | `g3d.n_nearest_neighbour(n1, [n])` | returns the `n` nearest neighbours to node `n1` |\n| - | + | `g3d.plot()` | returns matplotlib plot of the graph. |\n\n\n## FAQ\n\n| want to... | doesn't work... | do instead... | ...but why? |\n|:---|:---|:---|:---|\n| have multiple edges between two nodes | `Graph(from_list=[(1,2,3), (1,2,4)]` | Add dummy nodes<br>`[(1,a,3), (a,2,0),`<br>` (1,b,4),(b,2,0)]` | Explicit is better than implicit. |\n| multiple values on an edge | `g.add_edge(1,2,{'a':3, 'b':4})` | Have two graphs<br>`g_a.add_edge(1,2,3)`<br>`g_b.add_edge(1,2,4)` | Most graph algorithms don't work with multiple values |   \n\n## Credits:\n\n- Arturo Soucase for packaging and testing. \n- Peter Norvig for inspiration on TSP from [pytudes](https://github.com/norvig/pytudes/blob/master/ipynb/TSP.ipynb).\n- Harry Darby for the mountain river map.\n- Kyle Downey for depth_scan algorithm.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/root-11/graph-theory", "keywords": "adjacency,all pairs shortest path,assignment problem,complex-networks,component,components,cycle,depth,dijkstra,discrete mathematics,facility-location-problem,finite state machine,flow-problem,fsm,graph,Graph Theory,graph-algorithms,graph-analysis,graph-generation,graph-hash,graph-theory,graph-visualization,graphs,hash,math,Mathematics,maths,matrix,minimum-spanning-trees,minmax,minsum,network,Networks,optimization,path,python,random graph,search,shortest-path,tsp,tsp-solver", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "graph-theory", "package_url": "https://pypi.org/project/graph-theory/", "platform": "any", "project_url": "https://pypi.org/project/graph-theory/", "project_urls": {"Homepage": "https://github.com/root-11/graph-theory"}, "release_url": "https://pypi.org/project/graph-theory/2020.5.6.39102/", "requires_dist": null, "requires_python": "", "summary": "A graph library", "version": "2020.5.6.39102", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>graph-theory</h1>\n<p><a href=\"https://travis-ci.org/root-11/graph-theory\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ae3b3b8b5a77880d0158e896753a2dc7fc9d9d0a/68747470733a2f2f7472617669732d63692e6f72672f726f6f742d31312f67726170682d7468656f72792e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/root-11/graph-theory\" rel=\"nofollow\"><img alt=\"Code coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bac792d55cb16c8197a3d951111fd4e6e88a6775/68747470733a2f2f636f6465636f762e696f2f67682f726f6f742d31312f67726170682d7468656f72792f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<p>A simple graph library...<br>\n<em>... A bit like networkx, just without the overhead...</em><br>\n<em>... similar to graph-tool, without the Python 2.7 legacy...</em><br>\n<em>... with code that you can explain to your boss...</em><br></p>\n<hr>\n<p>Install:</p>\n<pre><code>pip install graph-theory\n</code></pre>\n<hr>\n<p>Import:</p>\n<pre><code>import Graph\ng = Graph()  \n\nimport Graph3d\ng3d = Graph3D()\n</code></pre>\n<hr>\n<p>Modules:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">module</th>\n<th align=\"left\">description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>from graph import Graph, Graph3D</code></td>\n<td align=\"left\">Elementary methods (see basic methods below) for Graph and Graph3D.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>from graph import ...</code></td>\n<td align=\"left\">All methods available on Graph (see table below)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>from graph.assignment_problem import ...</code></td>\n<td align=\"left\">solvers for assignment problem, the Weapons-Target Assignment Problem, ...</td>\n</tr>\n<tr>\n<td align=\"left\"><code>from graph.hash import ...</code></td>\n<td align=\"left\">graph hash functions: graph hash, merkle tree, flow graph hash</td>\n</tr>\n<tr>\n<td align=\"left\"><code>from graph.random import ...</code></td>\n<td align=\"left\">graph generators for random, 2D and 3D graphs.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>from graph.transshipment_problem import ...</code></td>\n<td align=\"left\">solvers for the transshipment problem</td>\n</tr>\n<tr>\n<td align=\"left\"><code>from graph.visuals import ...</code></td>\n<td align=\"left\">methods for creating matplotlib plots</td>\n</tr>\n<tr>\n<td align=\"left\"><code>from graph.finite_state_machine import ...</code></td>\n<td align=\"left\">finite state machine</td>\n</tr></tbody></table>\n<p>All module functions are available from Graph and Graph3D (where applicable).</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Graph</th>\n<th align=\"center\">Graph3D</th>\n<th align=\"left\">methods</th>\n<th align=\"left\">returns</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>a in g</code></td>\n<td align=\"left\">assert if g contains node a</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.add_node(n, [obj])</code></td>\n<td align=\"left\">adds a node (with a pointer to object <code>obj</code> if given)</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.copy()</code></td>\n<td align=\"left\">returns a shallow copy of <code>g</code></td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.node(node1)</code></td>\n<td align=\"left\">returns object attached to node 1</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.del_node(node1)</code></td>\n<td align=\"left\">deletes node1 and all it's edges</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.nodes()</code></td>\n<td align=\"left\">returns a list of nodes</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>len(g.nodes())</code></td>\n<td align=\"left\">returns the number of nodes</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.nodes(from_node=1)</code></td>\n<td align=\"left\">returns nodes with edges from node 1</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.nodes(to_node=2)</code></td>\n<td align=\"left\">returns nodes with edges to node 2</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.nodes(in_degree=2)</code></td>\n<td align=\"left\">returns nodes with 2 incoming edges</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.nodes(out_degree=2)</code></td>\n<td align=\"left\">returns nodes with 2 outgoing edges</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.add_edge(1,2,3)</code></td>\n<td align=\"left\">adds edge to g for vector <code>(1,2)</code> with value <code>3</code></td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.edge(1,2)</code></td>\n<td align=\"left\">returns value of edge between nodes 1 and 2</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.edge(1,2,default=3)</code></td>\n<td align=\"left\">returns <code>default=3</code> if <code>edge(1,2)</code> doesn't exist. <br>similar to <code>d.get(key, 3)</code></td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.del_edge(1,2)</code></td>\n<td align=\"left\">removes edge between nodes 1 and 2</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.edges()</code></td>\n<td align=\"left\">returns a list of edges</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>len(g.edges())</code></td>\n<td align=\"left\">returns the number of edges</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.edges(path=[path])</code></td>\n<td align=\"left\">returns a list of edges (along a path if given).</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>same_path(p1,p2)</code></td>\n<td align=\"left\">compares two paths to determine if they contain same sequences <br>ex.: <code>[1,2,3] == [2,3,1]</code></td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.edges(from_node=1)</code></td>\n<td align=\"left\">returns edges outgoing from node 1</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.edges(to_node=2)</code></td>\n<td align=\"left\">returns edges incoming to node 2</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.from_dict(d)</code></td>\n<td align=\"left\">updates the graph from a dictionary</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.to_dict()</code></td>\n<td align=\"left\">returns the graph as a dictionary</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.from_list(L)</code></td>\n<td align=\"left\">updates the graph from a list</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.to_list()</code></td>\n<td align=\"left\">return the graph as a list of edges</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.shortest_path(start,end)</code></td>\n<td align=\"left\">returns the distance and path for path with smallest edge sum</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.is_connected(start,end)</code></td>\n<td align=\"left\">determines if there is a path from start to end</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.breadth_first_search(start,end)</code></td>\n<td align=\"left\">returns the number of edges and path with fewest edges</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.degree_of_separation(n1,n2)</code></td>\n<td align=\"left\">returns the distance between two nodes using BFS</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.network_size(n1, degree_of_separation)</code></td>\n<td align=\"left\">returns the nodes within the range given by <code>degree_of_separation</code></td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.phase_lines()</code></td>\n<td align=\"left\">returns a dictionary with the phase_lines for a non-cyclic graph.</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.sources(n)</code></td>\n<td align=\"left\">returns the source_tree of node <code>n</code></td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.depth_first_search(start,end)</code></td>\n<td align=\"left\">returns path using DFS and backtracking</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.depth_scan(start, criteria)</code></td>\n<td align=\"left\">returns set of nodes where criteria is True</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.distance_from_path(path)</code></td>\n<td align=\"left\">returns the distance for path.</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.maximum_flow(source,sink)</code></td>\n<td align=\"left\">finds the maximum flow between a source and a sink</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.solve_tsp()</code></td>\n<td align=\"left\">solves the traveling salesman problem for the graph</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.subgraph_from_nodes(nodes)</code></td>\n<td align=\"left\">returns the subgraph of <code>g</code> involving <code>nodes</code></td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.is_subgraph(g2)</code></td>\n<td align=\"left\">determines if graph <code>g2</code> is a subgraph in g</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.is_partite(n)</code></td>\n<td align=\"left\">determines if graph is n-partite</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.has_cycles()</code></td>\n<td align=\"left\">determines if there are any cycles in the graph</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.components()</code></td>\n<td align=\"left\">returns set of nodes in each component in <code>g</code></td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.same_path(p1,p2)</code></td>\n<td align=\"left\">compares two paths, returns True if they're the same</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.adjacency_matrix()</code></td>\n<td align=\"left\">returns the adjacency matrix for the graph</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.all_pairs_shortest_paths()</code></td>\n<td align=\"left\">finds the shortest path between all nodes</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.minsum()</code></td>\n<td align=\"left\">finds the node(s) with shortest total distance to all other nodes</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.minmax()</code></td>\n<td align=\"left\">finds the node(s) with shortest maximum distance to all other nodes</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.shortest_tree_all_pairs()</code></td>\n<td align=\"left\">finds the shortest tree for all pairs</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.has_path(p)</code></td>\n<td align=\"left\">asserts whether a path <code>p</code> exists in g</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g.all_paths(start,end)</code></td>\n<td align=\"left\">finds all combinations of paths between 2 nodes</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g3d.distance(n1,n2)</code></td>\n<td align=\"left\">returns the spatial distance between <code>n1</code> and <code>n2</code></td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g3d.n_nearest_neighbour(n1, [n])</code></td>\n<td align=\"left\">returns the <code>n</code> nearest neighbours to node <code>n1</code></td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">+</td>\n<td align=\"left\"><code>g3d.plot()</code></td>\n<td align=\"left\">returns matplotlib plot of the graph.</td>\n</tr></tbody></table>\n<h2>FAQ</h2>\n<table>\n<thead>\n<tr>\n<th align=\"left\">want to...</th>\n<th align=\"left\">doesn't work...</th>\n<th align=\"left\">do instead...</th>\n<th align=\"left\">...but why?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">have multiple edges between two nodes</td>\n<td align=\"left\"><code>Graph(from_list=[(1,2,3), (1,2,4)]</code></td>\n<td align=\"left\">Add dummy nodes<br><code>[(1,a,3), (a,2,0),</code><br><code>(1,b,4),(b,2,0)]</code></td>\n<td align=\"left\">Explicit is better than implicit.</td>\n</tr>\n<tr>\n<td align=\"left\">multiple values on an edge</td>\n<td align=\"left\"><code>g.add_edge(1,2,{'a':3, 'b':4})</code></td>\n<td align=\"left\">Have two graphs<br><code>g_a.add_edge(1,2,3)</code><br><code>g_b.add_edge(1,2,4)</code></td>\n<td align=\"left\">Most graph algorithms don't work with multiple values</td>\n</tr></tbody></table>\n<h2>Credits:</h2>\n<ul>\n<li>Arturo Soucase for packaging and testing.</li>\n<li>Peter Norvig for inspiration on TSP from <a href=\"https://github.com/norvig/pytudes/blob/master/ipynb/TSP.ipynb\" rel=\"nofollow\">pytudes</a>.</li>\n<li>Harry Darby for the mountain river map.</li>\n<li>Kyle Downey for depth_scan algorithm.</li>\n</ul>\n\n          </div>"}, "last_serial": 7179047, "releases": {"2019.10.14.42373": [{"comment_text": "", "digests": {"md5": "12e2427e60f38355588a71bb208f14b0", "sha256": "e28df26c99ef472c4d2e21fa2baa0eca58170aedd6f8b71bb714a573b7332b2d"}, "downloads": -1, "filename": "graph-theory-2019.10.14.42373.tar.gz", "has_sig": false, "md5_digest": "12e2427e60f38355588a71bb208f14b0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25497, "upload_time": "2019-10-14T10:49:48", "upload_time_iso_8601": "2019-10-14T10:49:48.149762Z", "url": "https://files.pythonhosted.org/packages/19/82/8c0e29067a1de15e3e426808bd7e2dd326bc37c50f03fc5faab3c8a08271/graph-theory-2019.10.14.42373.tar.gz", "yanked": false}], "2019.11.13.56955": [{"comment_text": "", "digests": {"md5": "90b65b0f9465c5aed513fb2053c02a57", "sha256": "e6527ba1c94123d0dc7db5695dc76ac137e2317857a574ba0b2a114a1889e047"}, "downloads": -1, "filename": "graph-theory-2019.11.13.56955.tar.gz", "has_sig": false, "md5_digest": "90b65b0f9465c5aed513fb2053c02a57", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26290, "upload_time": "2019-11-13T15:49:48", "upload_time_iso_8601": "2019-11-13T15:49:48.222708Z", "url": "https://files.pythonhosted.org/packages/fa/98/353e62bc56390103411b481e09ef694caeb408eec7f75bff61f133eb625f/graph-theory-2019.11.13.56955.tar.gz", "yanked": false}], "2019.11.4.44448": [{"comment_text": "", "digests": {"md5": "a0663c2395f9974e1232638bd1a39b2d", "sha256": "f9822cb2d373165e11aaedbf0d4cf71f504e1321a752b2da8a62d68751303dd0"}, "downloads": -1, "filename": "graph-theory-2019.11.4.44448.tar.gz", "has_sig": false, "md5_digest": "a0663c2395f9974e1232638bd1a39b2d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26175, "upload_time": "2019-11-04T12:32:57", "upload_time_iso_8601": "2019-11-04T12:32:57.315330Z", "url": "https://files.pythonhosted.org/packages/ad/ff/87dfcff69d79cfe3e3bc10912274537f255623998b808b75c40be6ba71e2/graph-theory-2019.11.4.44448.tar.gz", "yanked": false}], "2019.5.10.35639": [{"comment_text": "", "digests": {"md5": "6390168904753f822da7e376c3e052b4", "sha256": "0aa5601b3d6d8ba3a5fbbb1a27c2a99b962a8f967c264abe7f3e59df468756d2"}, "downloads": -1, "filename": "graph-theory-2019.5.10.35639.tar.gz", "has_sig": false, "md5_digest": "6390168904753f822da7e376c3e052b4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11368, "upload_time": "2019-05-10T08:57:30", "upload_time_iso_8601": "2019-05-10T08:57:30.845459Z", "url": "https://files.pythonhosted.org/packages/c7/92/30a0a4c642ad66c8142b4651bd3ce4c8d13cef80714ce2b85084bb79fb33/graph-theory-2019.5.10.35639.tar.gz", "yanked": false}], "2019.5.10.37010": [{"comment_text": "", "digests": {"md5": "7749b867caf6cda09a15730904e4bf60", "sha256": "f35d4d4df966078ffca9daf60d46da645a62ebc993c1b8d7c3a4a8afe9671f1c"}, "downloads": -1, "filename": "graph-theory-2019.5.10.37010.tar.gz", "has_sig": false, "md5_digest": "7749b867caf6cda09a15730904e4bf60", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19060, "upload_time": "2019-05-10T09:28:00", "upload_time_iso_8601": "2019-05-10T09:28:00.452408Z", "url": "https://files.pythonhosted.org/packages/66/2b/8920fc636d1589508c67e0ea5e275bea53a41326cbfbffedc5c11afab408/graph-theory-2019.5.10.37010.tar.gz", "yanked": false}], "2019.5.20.52321": [{"comment_text": "", "digests": {"md5": "d1e59f55011dbb38517c50da2018f555", "sha256": "948b65fdd06db08e232ec27d4192600f6ed5215667cd2098151375ad710e7479"}, "downloads": -1, "filename": "graph-theory-2019.5.20.52321.tar.gz", "has_sig": false, "md5_digest": "d1e59f55011dbb38517c50da2018f555", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19045, "upload_time": "2019-05-20T13:35:58", "upload_time_iso_8601": "2019-05-20T13:35:58.697555Z", "url": "https://files.pythonhosted.org/packages/f6/f2/d8ce5b82fe7645dab49614c3a1d2fc546a9f4ba78ca96faab9171ffeba86/graph-theory-2019.5.20.52321.tar.gz", "yanked": false}], "2020.1.14.58965": [{"comment_text": "", "digests": {"md5": "63cbaf19f7923c9fe5406932f9c169e5", "sha256": "273fdfb82820ea5d802b9c584f326ff6ef003a7ee22129cc8f62faee67ccc53f"}, "downloads": -1, "filename": "graph-theory-2020.1.14.58965.tar.gz", "has_sig": false, "md5_digest": "63cbaf19f7923c9fe5406932f9c169e5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28316, "upload_time": "2020-01-14T16:25:05", "upload_time_iso_8601": "2020-01-14T16:25:05.787791Z", "url": "https://files.pythonhosted.org/packages/30/39/84d42f83a7a08fca81183ec38e715cbccbc65c78a99fcafb83d941f76b2c/graph-theory-2020.1.14.58965.tar.gz", "yanked": false}], "2020.1.27.43405": [{"comment_text": "", "digests": {"md5": "0e7bba17ecdbadd012e5017d09b272ae", "sha256": "b0c7ef9720bb819f76131ff9427d5076a442b6ab6417f5ead50067efde568a35"}, "downloads": -1, "filename": "graph-theory-2020.1.27.43405.tar.gz", "has_sig": false, "md5_digest": "0e7bba17ecdbadd012e5017d09b272ae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29135, "upload_time": "2020-01-27T16:34:56", "upload_time_iso_8601": "2020-01-27T16:34:56.519250Z", "url": "https://files.pythonhosted.org/packages/e4/4e/499bbe306be88e3664738b6383a2a6294c9bd53fc8df7dc5e876610f54b5/graph-theory-2020.1.27.43405.tar.gz", "yanked": false}], "2020.1.30.50866": [{"comment_text": "", "digests": {"md5": "6dfdc7cbb60bb626bda8e7fb7a08e4bb", "sha256": "b1a0ad55100450e8678f3ad999d3fcbd2a5b021873784616f41369b39ee5e50e"}, "downloads": -1, "filename": "graph-theory-2020.1.30.50866.tar.gz", "has_sig": false, "md5_digest": "6dfdc7cbb60bb626bda8e7fb7a08e4bb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30415, "upload_time": "2020-01-30T14:08:32", "upload_time_iso_8601": "2020-01-30T14:08:32.899798Z", "url": "https://files.pythonhosted.org/packages/51/ba/d3ad3c3d913dbd01883192f5ff1d068725ef1b84cf74f7b5d170b3485254/graph-theory-2020.1.30.50866.tar.gz", "yanked": false}], "2020.2.13.54023": [{"comment_text": "", "digests": {"md5": "30578937c358d3c5ee066e0a77e89175", "sha256": "18f69025ac0066974a9aeef4f6dd7e51603689a9781adafcecd717f4ff2cfad7"}, "downloads": -1, "filename": "graph-theory-2020.2.13.54023.tar.gz", "has_sig": false, "md5_digest": "30578937c358d3c5ee066e0a77e89175", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30971, "upload_time": "2020-02-13T15:01:02", "upload_time_iso_8601": "2020-02-13T15:01:02.513096Z", "url": "https://files.pythonhosted.org/packages/e5/d5/0d774eada4140c49f1662c5c6f8d43c5bd9a3891723133f662d983b66d23/graph-theory-2020.2.13.54023.tar.gz", "yanked": false}], "2020.2.13.55534": [{"comment_text": "", "digests": {"md5": "5c83f717fa0c43ffb95746de9b5fd838", "sha256": "87d87a668db2a5e3a76b712699b3d372eda98a4330eeeb9ba910e071a9198925"}, "downloads": -1, "filename": "graph-theory-2020.2.13.55534.tar.gz", "has_sig": false, "md5_digest": "5c83f717fa0c43ffb95746de9b5fd838", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30961, "upload_time": "2020-02-13T15:26:18", "upload_time_iso_8601": "2020-02-13T15:26:18.054788Z", "url": "https://files.pythonhosted.org/packages/35/6f/c7805f59b3a0fab0fd0124dbbfdb88edbb5a743b7cd3f5eb15cb3cbeebad/graph-theory-2020.2.13.55534.tar.gz", "yanked": false}], "2020.2.14.44994": [{"comment_text": "", "digests": {"md5": "2fb28b6a0d54102d41d67987768e2115", "sha256": "727eb139b1f6882f50c3eac2df0533377bee8852caf7be7f43b32266c6d08913"}, "downloads": -1, "filename": "graph-theory-2020.2.14.44994.tar.gz", "has_sig": false, "md5_digest": "2fb28b6a0d54102d41d67987768e2115", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30471, "upload_time": "2020-02-14T12:30:30", "upload_time_iso_8601": "2020-02-14T12:30:30.307384Z", "url": "https://files.pythonhosted.org/packages/18/4e/da4a6baf284c0cac6b8d6af1ec4bd0576f7043b24939c8674a16559a70c4/graph-theory-2020.2.14.44994.tar.gz", "yanked": false}], "2020.2.3.45572": [{"comment_text": "", "digests": {"md5": "ef5163edbd6f806634e0205b40990042", "sha256": "8ac071481a231c5625df705f04e70444d30c2e4c02ec0e64f7b353f9cd46d32f"}, "downloads": -1, "filename": "graph-theory-2020.2.3.45572.tar.gz", "has_sig": false, "md5_digest": "ef5163edbd6f806634e0205b40990042", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30433, "upload_time": "2020-02-03T12:40:22", "upload_time_iso_8601": "2020-02-03T12:40:22.446777Z", "url": "https://files.pythonhosted.org/packages/f4/fe/0c26c091e21fb193ab10a5513e39521ad5cd1ec16380d1d822871daa17b3/graph-theory-2020.2.3.45572.tar.gz", "yanked": false}], "2020.2.3.48877": [{"comment_text": "", "digests": {"md5": "94c476422ecd0c3a9b79df28fcac172f", "sha256": "643b8c10716c6a6a27c2e0a5507aa45bda87a1863f4cbed7dcd7377eb1ab66c2"}, "downloads": -1, "filename": "graph-theory-2020.2.3.48877.tar.gz", "has_sig": false, "md5_digest": "94c476422ecd0c3a9b79df28fcac172f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30492, "upload_time": "2020-02-03T13:35:07", "upload_time_iso_8601": "2020-02-03T13:35:07.038142Z", "url": "https://files.pythonhosted.org/packages/85/e2/621f5b8937e55d828058a1a6f1bdd6e491de7263599a814865b3dd54a6cf/graph-theory-2020.2.3.48877.tar.gz", "yanked": false}], "2020.2.6.35531": [{"comment_text": "", "digests": {"md5": "0229db54495d25e94d7015d67f471a9e", "sha256": "eef6ee3db065cc0feee9860ac8a0a7129fdcede350a3e64fe4d1a0635b4d5013"}, "downloads": -1, "filename": "graph-theory-2020.2.6.35531.tar.gz", "has_sig": false, "md5_digest": "0229db54495d25e94d7015d67f471a9e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30531, "upload_time": "2020-02-06T09:52:46", "upload_time_iso_8601": "2020-02-06T09:52:46.342706Z", "url": "https://files.pythonhosted.org/packages/4a/52/5c9d6615f7d32279c32768e5d9d7c87b84cbcd1ddd299e1c28a6963519a8/graph-theory-2020.2.6.35531.tar.gz", "yanked": false}], "2020.3.12.46947": [{"comment_text": "", "digests": {"md5": "2e219132f1ac8749ec9c42b0ea082a31", "sha256": "145475eac336d8f7cab753ce9ff64565374187d6727469edc241cc29102f7bb6"}, "downloads": -1, "filename": "graph-theory-2020.3.12.46947.tar.gz", "has_sig": false, "md5_digest": "2e219132f1ac8749ec9c42b0ea082a31", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31336, "upload_time": "2020-03-12T13:03:12", "upload_time_iso_8601": "2020-03-12T13:03:12.230970Z", "url": "https://files.pythonhosted.org/packages/d4/fa/60ca215bed126ec71838d0e6c4b37580df2c904daef195fb9b5d1a5f19b2/graph-theory-2020.3.12.46947.tar.gz", "yanked": false}], "2020.3.13.48580": [{"comment_text": "", "digests": {"md5": "72f36a9b966d8b0650d3d49ca5dfd145", "sha256": "00fd6d8c0702e234f6a2d1f51910a7f82d3f51e67781fd2f5be4239af55a27f3"}, "downloads": -1, "filename": "graph-theory-2020.3.13.48580.tar.gz", "has_sig": false, "md5_digest": "72f36a9b966d8b0650d3d49ca5dfd145", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31438, "upload_time": "2020-03-13T13:30:09", "upload_time_iso_8601": "2020-03-13T13:30:09.773528Z", "url": "https://files.pythonhosted.org/packages/89/61/8b53c585a06cc7dbc94ba521ba3beded6cb7d9bee04e2f33da5e694245b6/graph-theory-2020.3.13.48580.tar.gz", "yanked": false}], "2020.4.30.58797": [{"comment_text": "", "digests": {"md5": "410afd2850cbe9b771a9417468bb9be2", "sha256": "aa8b1622a43a06e7fd045cf1612801c8e69d75fbd4b4e6b4109866feeac89dd5"}, "downloads": -1, "filename": "graph-theory-2020.4.30.58797.tar.gz", "has_sig": false, "md5_digest": "410afd2850cbe9b771a9417468bb9be2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31303, "upload_time": "2020-04-30T15:20:33", "upload_time_iso_8601": "2020-04-30T15:20:33.656344Z", "url": "https://files.pythonhosted.org/packages/49/e1/360c7da57494ef2a26d10d1c008d75071ed2375655db1c44ff539f0440eb/graph-theory-2020.4.30.58797.tar.gz", "yanked": false}], "2020.5.6.39102": [{"comment_text": "", "digests": {"md5": "6c0b52b72fff2a39df7c8c5ec26cdceb", "sha256": "7e95d96f635549edbbc34106dbbf891a6f5a044a7c9a65c91c9dacb4aca1584d"}, "downloads": -1, "filename": "graph-theory-2020.5.6.39102.tar.gz", "has_sig": false, "md5_digest": "6c0b52b72fff2a39df7c8c5ec26cdceb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31636, "upload_time": "2020-05-06T09:52:23", "upload_time_iso_8601": "2020-05-06T09:52:23.112945Z", "url": "https://files.pythonhosted.org/packages/d6/7f/35224d82b0c19b02aa9094c25136072c57abc287af2fdaf4ba8e8bdf56e6/graph-theory-2020.5.6.39102.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6c0b52b72fff2a39df7c8c5ec26cdceb", "sha256": "7e95d96f635549edbbc34106dbbf891a6f5a044a7c9a65c91c9dacb4aca1584d"}, "downloads": -1, "filename": "graph-theory-2020.5.6.39102.tar.gz", "has_sig": false, "md5_digest": "6c0b52b72fff2a39df7c8c5ec26cdceb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31636, "upload_time": "2020-05-06T09:52:23", "upload_time_iso_8601": "2020-05-06T09:52:23.112945Z", "url": "https://files.pythonhosted.org/packages/d6/7f/35224d82b0c19b02aa9094c25136072c57abc287af2fdaf4ba8e8bdf56e6/graph-theory-2020.5.6.39102.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:31 2020"}