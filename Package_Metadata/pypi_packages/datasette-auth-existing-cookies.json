{"info": {"author": "Simon Willison", "author_email": "", "bugtrack_url": null, "classifiers": [], "description": "# datasette-auth-existing-cookies\n\n[![PyPI](https://img.shields.io/pypi/v/datasette-auth-existing-cookies.svg)](https://pypi.org/project/datasette-auth-existing-cookies/)\n[![CircleCI](https://circleci.com/gh/simonw/datasette-auth-existing-cookies.svg?style=svg)](https://circleci.com/gh/simonw/datasette-auth-existing-cookies)\n[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](https://google.com/simonw/datasette-auth-existing-cookies/blob/master/LICENSE)\n\nDatasette plugin that authenticates users based on existing domain cookies.\n\n## When to use this\n\nThis plugin allows you to build custom authentication for Datasette when you are hosting a Datasette instance on the same domain as another, authenticated website.\n\nConsider a website on `www.example.com` which supports user authentication.\n\nYou could run Datasette on `data.example.com` in a way that lets it see cookies that were set for the `.example.com` domain.\n\nUsing this plugin, you could build an API endpoint at `www.example.com/user-for-cookies` which returns a JSON object representing the currently signed-in user, based on their cookies.\n\nThe plugin can protect any hits to any `data.example.com` pages by passing their cookies through to that API and seeing if the user should be logged in or not.\n\nYou can also use subclassing to decode existing cookies using some other mechanism.\n\n## Configuration\n\nThis plugin requires some configuration in the Datasette [metadata.json file](https://datasette.readthedocs.io/en/stable/plugins.html#plugin-configuration).\n\nIt needs to know the following:\n\n* Which domain cookies should it be paying attention to? If you are authenticating against Dango this is probably `[\"sessionid\"]`.\n* What's an API it can send the incoming cookies to that will decipher them into some user information?\n* Where should it redirect the user if they need to sign in?\n\nExample configuration setting all three of these values looks like this:\n\n```json\n{\n    \"plugins\": {\n        \"datasette-auth-existing-cookies\": {\n            \"api_url\": \"http://www.example.com/user-from-cookies\",\n            \"auth_redirect_url\": \"http://www.example.com/login\",\n            \"original_cookies\": [\"sessionid\"]\n        }\n    }\n}\n```\n\nWith this configuration the user's current `sessionid` cookie will be passed to the API URL, as a regular cookie header.\n\nYou can use the `\"headers_to_forward\"` configuration option to specify a list of additional headers from the request that should be forwarded on to the `api_url` as querystring parameters. For example, if you add this to the above configuration:\n\n```json\n            \"headers_to_forward\": [\"host\", \"x-forwarded-for\"]\n```\n\nThen a hit to `https://data.example.com/` would make the following API call:\n\n    http://www.example.com/user-from-cookies?host=data.example.com&x-forwarded-for=64.18.15.255\n\nThe API URL should then return either an empty JSON object if the user is not currently signed in:\n\n```json\n{}\n```\n\nOr a JSON object representing the user if they ARE signed in:\n\n```json\n{\n    \"id\": 123,\n    \"username\": \"simonw\"\n}\n```\n\nThis object can contain any keys that you like - the information will be stored in a new signed cookie and made available to Datasette code as the `\"auth\"` dictionary on the ASGI `scope`.\n\nI suggest including at least an `id` and a `username`.\n\n## Templates\n\nYou probably want your user's to be able to see that they are signed in. The plugin makes the `auth` data from above directly available within Datasette's templates. You could use a custom `base.html` template (see [template documentation](https://datasette.readthedocs.io/en/stable/custom_templates.html#custom-templates)) that looks like this:\n\n```html+django\n{% extends \"default:base.html\" %}\n\n{% block extra_head %}\n<style type=\"text/css\">\n.hd .logout {\n    float: right;\n    text-align: right;\n    padding-left: 1em;\n}\n</style>\n{% endblock %}\n\n{% block nav %}\n    {{ super() }}\n    {% if auth and auth.username %}\n        <p class=\"logout\">\n            <strong>{{ auth.username }}</strong> &middot; <a href=\"https://www.example.com/logout\">Log out</a>\n        </p>\n    {% endif %}\n{% endblock %}\n```\n\n## Other options\n\n- `require_auth`. This defaults to `True`. You can set it to `False` if you want unauthenticated users to be able to view the Datasette instance.\n- `cookie_secret`. You can use this to set the signing secret that will be used for the cookie set by this plugin (you should use [secret configuration values](https://datasette.readthedocs.io/en/stable/plugins.html#secret-configuration-values) for this). If you do not set a secret the plugin will create one on first run and store it in an appropriate state directory based on your operating system (the `user_state_dir` according to [appdirs](https://pypi.org/project/appdirs/)).\n- `cookie_ttl`. The plugin sets its own cookie to avoid hitting the backend API for every incoming request. By default it still hits the API at most every 10 seconds, in case the user has signed out on the main site. You can raise or lower the timeout using this setting.\n- `trust_x_forwarded_proto`. If you are running behind a proxy that adds HTTPS support for you, you may find that the plugin incorrectly constructs `?next=` URLs with the incorrect scheme. If you know your proxy sends the `x-forwarded-proto` header (you can investigate this with the [datasette-debug-asgi](https://github.com/simonw/datasette-debug-asgi) plugin) setting the `trust_x_forwarded_proto` option to True will cause the plugin to trust that header.\n- `next_secret`. See below.\n\n## Login redirect mechanism\n\nIf the user does not have a valid authentication cookie they will be redirected to an existing login page.\n\nThis page is specified using the `auth_redirect_url` setting.\n\nGiven the above example configuration, the URL that the user should be sent to after they log in will be specified as the `?next=` parameter to that page, for example:\n\n    http://www.example.com/login?next=http://foo.example.com/\n\nIt is up to you to program the login endpoint such that it is not vulnerable to an [Unvalidated redirect vulnerability](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).\n\nOne way to do this is by verifying that the URL passed to `?next=` is a URL that belongs to a trusted website. Django's own login view [does this](https://github.com/django/django/blob/50cf183d219face91822c75fa0a15fe2fe3cb32d/django/contrib/auth/views.py#L69-L80) by verifying that the URL hostname is on an approved list.\n\nAnother way to do this is to use the `next_secret` configuration parameter to set a signing secret for that URL. This signing secret will be used to construct a `?next_sig=` signed token using the Python [itsdangerous](https://pythonhosted.org/itsdangerous/) module, like this:\n\n    ?next_sig=Imh0dHBzOi8vZGVtby5leGFtcGxlLmNvbS9mb28vYmFyIg.7JdhRCoP7Ow1cRF1ZVengC-qk6c\n\nYou should use Datasette's [secret configuration values](https://datasette.readthedocs.io/en/stable/plugins.html#secret-configuration-values) mechanism to set this secret from an environment variable, like so:\n\n    {\n        \"plugins\": {\n            \"datasette-auth-existing-cookies\": {\n                \"api_url\": \"http://www.example.com/user-from-cookies\",\n                \"auth_redirect_url\": \"http://www.example.com/login\",\n                \"original_cookies\": [\"sessionid\"],\n                \"next_secret\":  {\n                    \"$env\": \"NEXT_SECRET\"\n                }\n            }\n        }\n    }\n\nYou can verify this secret in Python code for your own login form like so:\n\n```python\nfrom itsdangerous import URLSafeSerializer, BadSignature\n\ndef verify_next_sig(next_sig):\n    signer = URLSafeSerializer(next_secret)\n    try:\n        decoded = signer.loads(next_sig)\n        return True\n    except BadSignature:\n        return False\n```\n\nIf you want to roll your own signing mechanism here you can do so by subclassing `ExistingCookiesAuth` and over-riding the `build_auth_redirect(next_url)` method.\n\n## Permissions\n\nIf the current user is signed in but should not have permission to access the Datasette instance, you can indicate so by having the API return the following:\n\n```json\n{\n    \"forbidden\": \"You do not have permission to access this page.\"\n}\n```\n\nThe key must be `\"forbidden\"`. The value can be any string - it will be displayed to the user.\n\nThis is particularly useful when handling multiple different subdomains. You may get an API call to the following:\n\n    http://www.example.com/user-from-cookies?host=a-team.example.com\n\nYou can check if the authenticated user (based on their cookies) has permission to access to the `a-team` Datasette instance, and return a `\"forbidden\"` JSON object if they should not be able to view it.\n\nIf a user is allowed to access Datasette (because the API returned their user identity as JSON), the plugin will set a cookie on that subdomain granting them access.\n\nThis cookie defaults to expiring after ten seconds. This means that if a user has permission removed for any reason they will still have up to ten seconds in which they will be able to continue accessing Datasette. If this is not acceptable to you the `cookie_ttl` setting can be used to reduce this timeout, at the expense of incurring more frequent API calls to check user permissions.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/simonw/datasette-auth-existing-cookies", "keywords": "", "license": "Apache License, Version 2.0", "maintainer": "", "maintainer_email": "", "name": "datasette-auth-existing-cookies", "package_url": "https://pypi.org/project/datasette-auth-existing-cookies/", "platform": "", "project_url": "https://pypi.org/project/datasette-auth-existing-cookies/", "project_urls": {"Homepage": "https://github.com/simonw/datasette-auth-existing-cookies"}, "release_url": "https://pypi.org/project/datasette-auth-existing-cookies/0.7/", "requires_dist": ["appdirs", "httpx", "itsdangerous", "datasette ; extra == 'test'", "pytest ; extra == 'test'", "pytest-asyncio ; extra == 'test'", "asgiref (~=3.1.2) ; extra == 'test'"], "requires_python": ">=3.6", "summary": "Datasette plugin that authenticates users based on existing domain cookies", "version": "0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>datasette-auth-existing-cookies</h1>\n<p><a href=\"https://pypi.org/project/datasette-auth-existing-cookies/\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8686a528b15aeb873a15720f0407fd89c3d644ef/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6461746173657474652d617574682d6578697374696e672d636f6f6b6965732e737667\"></a>\n<a href=\"https://circleci.com/gh/simonw/datasette-auth-existing-cookies\" rel=\"nofollow\"><img alt=\"CircleCI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/faa179b7865b5e137dd8765338af29754ae2772f/68747470733a2f2f636972636c6563692e636f6d2f67682f73696d6f6e772f6461746173657474652d617574682d6578697374696e672d636f6f6b6965732e7376673f7374796c653d737667\"></a>\n<a href=\"https://google.com/simonw/datasette-auth-existing-cookies/blob/master/LICENSE\" rel=\"nofollow\"><img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bad0ad2a7195b40874e3a10488118122d89489fd/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d417061636865253230322e302d626c75652e737667\"></a></p>\n<p>Datasette plugin that authenticates users based on existing domain cookies.</p>\n<h2>When to use this</h2>\n<p>This plugin allows you to build custom authentication for Datasette when you are hosting a Datasette instance on the same domain as another, authenticated website.</p>\n<p>Consider a website on <code>www.example.com</code> which supports user authentication.</p>\n<p>You could run Datasette on <code>data.example.com</code> in a way that lets it see cookies that were set for the <code>.example.com</code> domain.</p>\n<p>Using this plugin, you could build an API endpoint at <code>www.example.com/user-for-cookies</code> which returns a JSON object representing the currently signed-in user, based on their cookies.</p>\n<p>The plugin can protect any hits to any <code>data.example.com</code> pages by passing their cookies through to that API and seeing if the user should be logged in or not.</p>\n<p>You can also use subclassing to decode existing cookies using some other mechanism.</p>\n<h2>Configuration</h2>\n<p>This plugin requires some configuration in the Datasette <a href=\"https://datasette.readthedocs.io/en/stable/plugins.html#plugin-configuration\" rel=\"nofollow\">metadata.json file</a>.</p>\n<p>It needs to know the following:</p>\n<ul>\n<li>Which domain cookies should it be paying attention to? If you are authenticating against Dango this is probably <code>[\"sessionid\"]</code>.</li>\n<li>What's an API it can send the incoming cookies to that will decipher them into some user information?</li>\n<li>Where should it redirect the user if they need to sign in?</li>\n</ul>\n<p>Example configuration setting all three of these values looks like this:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"nt\">\"plugins\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">\"datasette-auth-existing-cookies\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">\"api_url\"</span><span class=\"p\">:</span> <span class=\"s2\">\"http://www.example.com/user-from-cookies\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"auth_redirect_url\"</span><span class=\"p\">:</span> <span class=\"s2\">\"http://www.example.com/login\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"original_cookies\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"sessionid\"</span><span class=\"p\">]</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<p>With this configuration the user's current <code>sessionid</code> cookie will be passed to the API URL, as a regular cookie header.</p>\n<p>You can use the <code>\"headers_to_forward\"</code> configuration option to specify a list of additional headers from the request that should be forwarded on to the <code>api_url</code> as querystring parameters. For example, if you add this to the above configuration:</p>\n<pre>            <span class=\"s2\">\"headers_to_forward\"</span><span class=\"err\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"host\"</span><span class=\"p\">,</span> <span class=\"s2\">\"x-forwarded-for\"</span><span class=\"p\">]</span>\n</pre>\n<p>Then a hit to <code>https://data.example.com/</code> would make the following API call:</p>\n<pre><code>http://www.example.com/user-from-cookies?host=data.example.com&amp;x-forwarded-for=64.18.15.255\n</code></pre>\n<p>The API URL should then return either an empty JSON object if the user is not currently signed in:</p>\n<pre><span class=\"p\">{}</span>\n</pre>\n<p>Or a JSON object representing the user if they ARE signed in:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"nt\">\"id\"</span><span class=\"p\">:</span> <span class=\"mi\">123</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"simonw\"</span>\n<span class=\"p\">}</span>\n</pre>\n<p>This object can contain any keys that you like - the information will be stored in a new signed cookie and made available to Datasette code as the <code>\"auth\"</code> dictionary on the ASGI <code>scope</code>.</p>\n<p>I suggest including at least an <code>id</code> and a <code>username</code>.</p>\n<h2>Templates</h2>\n<p>You probably want your user's to be able to see that they are signed in. The plugin makes the <code>auth</code> data from above directly available within Datasette's templates. You could use a custom <code>base.html</code> template (see <a href=\"https://datasette.readthedocs.io/en/stable/custom_templates.html#custom-templates\" rel=\"nofollow\">template documentation</a>) that looks like this:</p>\n<pre><span class=\"cp\">{%</span> <span class=\"k\">extends</span> <span class=\"s2\">\"default:base.html\"</span> <span class=\"cp\">%}</span>\n\n<span class=\"cp\">{%</span> <span class=\"k\">block</span> <span class=\"nv\">extra_head</span> <span class=\"cp\">%}</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">style</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">\"text/css\"</span><span class=\"p\">&gt;</span>\n<span class=\"p\">.</span><span class=\"nc\">hd</span> <span class=\"p\">.</span><span class=\"nc\">logout</span> <span class=\"p\">{</span>\n    <span class=\"k\">float</span><span class=\"p\">:</span> <span class=\"kc\">right</span><span class=\"p\">;</span>\n    <span class=\"k\">text-align</span><span class=\"p\">:</span> <span class=\"kc\">right</span><span class=\"p\">;</span>\n    <span class=\"k\">padding-left</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"kt\">em</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">style</span><span class=\"p\">&gt;</span>\n<span class=\"cp\">{%</span> <span class=\"k\">endblock</span> <span class=\"cp\">%}</span>\n\n<span class=\"cp\">{%</span> <span class=\"k\">block</span> <span class=\"nv\">nav</span> <span class=\"cp\">%}</span>\n    <span class=\"cp\">{{</span> <span class=\"nb\">super</span><span class=\"o\">()</span> <span class=\"cp\">}}</span>\n    <span class=\"cp\">{%</span> <span class=\"k\">if</span> <span class=\"nv\">auth</span> <span class=\"k\">and</span> <span class=\"nv\">auth.username</span> <span class=\"cp\">%}</span>\n        <span class=\"p\">&lt;</span><span class=\"nt\">p</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"logout\"</span><span class=\"p\">&gt;</span>\n            <span class=\"p\">&lt;</span><span class=\"nt\">strong</span><span class=\"p\">&gt;</span><span class=\"cp\">{{</span> <span class=\"nv\">auth.username</span> <span class=\"cp\">}}</span><span class=\"p\">&lt;/</span><span class=\"nt\">strong</span><span class=\"p\">&gt;</span> <span class=\"ni\">&amp;middot;</span> <span class=\"p\">&lt;</span><span class=\"nt\">a</span> <span class=\"na\">href</span><span class=\"o\">=</span><span class=\"s\">\"https://www.example.com/logout\"</span><span class=\"p\">&gt;</span>Log out<span class=\"p\">&lt;/</span><span class=\"nt\">a</span><span class=\"p\">&gt;</span>\n        <span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>\n    <span class=\"cp\">{%</span> <span class=\"k\">endif</span> <span class=\"cp\">%}</span>\n<span class=\"cp\">{%</span> <span class=\"k\">endblock</span> <span class=\"cp\">%}</span>\n</pre>\n<h2>Other options</h2>\n<ul>\n<li><code>require_auth</code>. This defaults to <code>True</code>. You can set it to <code>False</code> if you want unauthenticated users to be able to view the Datasette instance.</li>\n<li><code>cookie_secret</code>. You can use this to set the signing secret that will be used for the cookie set by this plugin (you should use <a href=\"https://datasette.readthedocs.io/en/stable/plugins.html#secret-configuration-values\" rel=\"nofollow\">secret configuration values</a> for this). If you do not set a secret the plugin will create one on first run and store it in an appropriate state directory based on your operating system (the <code>user_state_dir</code> according to <a href=\"https://pypi.org/project/appdirs/\" rel=\"nofollow\">appdirs</a>).</li>\n<li><code>cookie_ttl</code>. The plugin sets its own cookie to avoid hitting the backend API for every incoming request. By default it still hits the API at most every 10 seconds, in case the user has signed out on the main site. You can raise or lower the timeout using this setting.</li>\n<li><code>trust_x_forwarded_proto</code>. If you are running behind a proxy that adds HTTPS support for you, you may find that the plugin incorrectly constructs <code>?next=</code> URLs with the incorrect scheme. If you know your proxy sends the <code>x-forwarded-proto</code> header (you can investigate this with the <a href=\"https://github.com/simonw/datasette-debug-asgi\" rel=\"nofollow\">datasette-debug-asgi</a> plugin) setting the <code>trust_x_forwarded_proto</code> option to True will cause the plugin to trust that header.</li>\n<li><code>next_secret</code>. See below.</li>\n</ul>\n<h2>Login redirect mechanism</h2>\n<p>If the user does not have a valid authentication cookie they will be redirected to an existing login page.</p>\n<p>This page is specified using the <code>auth_redirect_url</code> setting.</p>\n<p>Given the above example configuration, the URL that the user should be sent to after they log in will be specified as the <code>?next=</code> parameter to that page, for example:</p>\n<pre><code>http://www.example.com/login?next=http://foo.example.com/\n</code></pre>\n<p>It is up to you to program the login endpoint such that it is not vulnerable to an <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html\" rel=\"nofollow\">Unvalidated redirect vulnerability</a>.</p>\n<p>One way to do this is by verifying that the URL passed to <code>?next=</code> is a URL that belongs to a trusted website. Django's own login view <a href=\"https://github.com/django/django/blob/50cf183d219face91822c75fa0a15fe2fe3cb32d/django/contrib/auth/views.py#L69-L80\" rel=\"nofollow\">does this</a> by verifying that the URL hostname is on an approved list.</p>\n<p>Another way to do this is to use the <code>next_secret</code> configuration parameter to set a signing secret for that URL. This signing secret will be used to construct a <code>?next_sig=</code> signed token using the Python <a href=\"https://pythonhosted.org/itsdangerous/\" rel=\"nofollow\">itsdangerous</a> module, like this:</p>\n<pre><code>?next_sig=Imh0dHBzOi8vZGVtby5leGFtcGxlLmNvbS9mb28vYmFyIg.7JdhRCoP7Ow1cRF1ZVengC-qk6c\n</code></pre>\n<p>You should use Datasette's <a href=\"https://datasette.readthedocs.io/en/stable/plugins.html#secret-configuration-values\" rel=\"nofollow\">secret configuration values</a> mechanism to set this secret from an environment variable, like so:</p>\n<pre><code>{\n    \"plugins\": {\n        \"datasette-auth-existing-cookies\": {\n            \"api_url\": \"http://www.example.com/user-from-cookies\",\n            \"auth_redirect_url\": \"http://www.example.com/login\",\n            \"original_cookies\": [\"sessionid\"],\n            \"next_secret\":  {\n                \"$env\": \"NEXT_SECRET\"\n            }\n        }\n    }\n}\n</code></pre>\n<p>You can verify this secret in Python code for your own login form like so:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">itsdangerous</span> <span class=\"kn\">import</span> <span class=\"n\">URLSafeSerializer</span><span class=\"p\">,</span> <span class=\"n\">BadSignature</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">verify_next_sig</span><span class=\"p\">(</span><span class=\"n\">next_sig</span><span class=\"p\">):</span>\n    <span class=\"n\">signer</span> <span class=\"o\">=</span> <span class=\"n\">URLSafeSerializer</span><span class=\"p\">(</span><span class=\"n\">next_secret</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">decoded</span> <span class=\"o\">=</span> <span class=\"n\">signer</span><span class=\"o\">.</span><span class=\"n\">loads</span><span class=\"p\">(</span><span class=\"n\">next_sig</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">True</span>\n    <span class=\"k\">except</span> <span class=\"n\">BadSignature</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span>\n</pre>\n<p>If you want to roll your own signing mechanism here you can do so by subclassing <code>ExistingCookiesAuth</code> and over-riding the <code>build_auth_redirect(next_url)</code> method.</p>\n<h2>Permissions</h2>\n<p>If the current user is signed in but should not have permission to access the Datasette instance, you can indicate so by having the API return the following:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"nt\">\"forbidden\"</span><span class=\"p\">:</span> <span class=\"s2\">\"You do not have permission to access this page.\"</span>\n<span class=\"p\">}</span>\n</pre>\n<p>The key must be <code>\"forbidden\"</code>. The value can be any string - it will be displayed to the user.</p>\n<p>This is particularly useful when handling multiple different subdomains. You may get an API call to the following:</p>\n<pre><code>http://www.example.com/user-from-cookies?host=a-team.example.com\n</code></pre>\n<p>You can check if the authenticated user (based on their cookies) has permission to access to the <code>a-team</code> Datasette instance, and return a <code>\"forbidden\"</code> JSON object if they should not be able to view it.</p>\n<p>If a user is allowed to access Datasette (because the API returned their user identity as JSON), the plugin will set a cookie on that subdomain granting them access.</p>\n<p>This cookie defaults to expiring after ten seconds. This means that if a user has permission removed for any reason they will still have up to ten seconds in which they will be able to continue accessing Datasette. If this is not acceptable to you the <code>cookie_ttl</code> setting can be used to reduce this timeout, at the expense of incurring more frequent API calls to check user permissions.</p>\n\n          </div>"}, "last_serial": 7025393, "releases": {"0.2a0": [{"comment_text": "", "digests": {"md5": "1c5135ef9d7335d40b1d093be6e26a79", "sha256": "6a9c8c6be3001a3436c588295e5b7a284d56a6dfde6f24f681fe12ebc1e1bd96"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.2a0-py3-none-any.whl", "has_sig": false, "md5_digest": "1c5135ef9d7335d40b1d093be6e26a79", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 10010, "upload_time": "2020-01-27T20:41:12", "upload_time_iso_8601": "2020-01-27T20:41:12.108830Z", "url": "https://files.pythonhosted.org/packages/3e/e1/e0cecad46abffcd5d7b44709e5143da3601f4c34ee7a41d7f30f0ed57970/datasette_auth_existing_cookies-0.2a0-py3-none-any.whl", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "d11071e4028d10300cf7ddbb37e7757d", "sha256": "8b6ebd90a692e3ac795b823e3b07c1b52367d51af88857e92163eb65e145d378"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "d11071e4028d10300cf7ddbb37e7757d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12329, "upload_time": "2020-01-29T03:16:38", "upload_time_iso_8601": "2020-01-29T03:16:38.742284Z", "url": "https://files.pythonhosted.org/packages/d4/74/4fdd14ff157db3087f1d995822f245012081314eb1277c39307673cf7db2/datasette_auth_existing_cookies-0.3-py3-none-any.whl", "yanked": false}], "0.3b0": [{"comment_text": "", "digests": {"md5": "aa694e87b42b32ffdc7265811d236fe5", "sha256": "acf509ef75842e26d131ccf1882ecc0cd60b03bc032bf87dc00441b15b9ad071"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.3b0-py3-none-any.whl", "has_sig": false, "md5_digest": "aa694e87b42b32ffdc7265811d236fe5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 11208, "upload_time": "2020-01-28T22:31:09", "upload_time_iso_8601": "2020-01-28T22:31:09.405257Z", "url": "https://files.pythonhosted.org/packages/af/82/c57f70d22b710ea8f6b033bb8de254e884dc0e78fb5c54e65dcb34d3d6c4/datasette_auth_existing_cookies-0.3b0-py3-none-any.whl", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "50f6e1f6ed9085c1e59647cd74a5bafd", "sha256": "fbfdcbf41bea70b07d2eddb940c94cc235cdc38b6415426a750c8ba6b4e3bc30"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "50f6e1f6ed9085c1e59647cd74a5bafd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12453, "upload_time": "2020-02-04T05:11:14", "upload_time_iso_8601": "2020-02-04T05:11:14.606794Z", "url": "https://files.pythonhosted.org/packages/d8/c4/3118fa549a619fde52a6eacf927d038f8cb183c06a6befbea565140d7e0d/datasette_auth_existing_cookies-0.4-py3-none-any.whl", "yanked": false}], "0.4.1": [{"comment_text": "", "digests": {"md5": "4afc083e549f5a3d7a6c0b693b4fb77a", "sha256": "1c920f4f79a51b323e4859664ceeb21a81bfb4417f18c6ec7ff888875355133f"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.4.1-py3-none-any.whl", "has_sig": false, "md5_digest": "4afc083e549f5a3d7a6c0b693b4fb77a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12474, "upload_time": "2020-02-05T01:18:55", "upload_time_iso_8601": "2020-02-05T01:18:55.135386Z", "url": "https://files.pythonhosted.org/packages/ba/c4/945000a1772d174d1ff0bdda209008ec18e4d97da3a96e3c84430b56606d/datasette_auth_existing_cookies-0.4.1-py3-none-any.whl", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "8a36ca5c3be49c975b996db949ed1d9f", "sha256": "9a76ac33eb53322f763f291a7700c3836fb6d8858903febcdd16ab6faacc0114"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "8a36ca5c3be49c975b996db949ed1d9f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 13417, "upload_time": "2020-02-05T04:33:20", "upload_time_iso_8601": "2020-02-05T04:33:20.444133Z", "url": "https://files.pythonhosted.org/packages/77/a1/1b3d3a9f345ef735ced755541fdb81ab11e5bed583f84e2a3d2ea75efb4c/datasette_auth_existing_cookies-0.5-py3-none-any.whl", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "662f4fef1adedc82c0c341f4ba5efd93", "sha256": "8f4ce51d2087718bc00c47f817beeb886b2355881472089b7ef936317ec2a2cf"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.5.1-py3-none-any.whl", "has_sig": false, "md5_digest": "662f4fef1adedc82c0c341f4ba5efd93", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 13451, "upload_time": "2020-02-05T06:20:48", "upload_time_iso_8601": "2020-02-05T06:20:48.873537Z", "url": "https://files.pythonhosted.org/packages/bb/49/07c9066f984b1edcf3d84dccaa09b4dfb24734bdd78e3e9f2488b7ad4474/datasette_auth_existing_cookies-0.5.1-py3-none-any.whl", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "d064c49a101313349d204b1101b7b583", "sha256": "39ee93fd7ad812f7929619eb472fccce35f26b076977f05fae51253dd31c44d8"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "d064c49a101313349d204b1101b7b583", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 13608, "upload_time": "2020-02-06T06:11:28", "upload_time_iso_8601": "2020-02-06T06:11:28.180801Z", "url": "https://files.pythonhosted.org/packages/93/d4/b9c41af468224755c974a3dd423a25f92516e67cd6b78c5e83f4a10e65fe/datasette_auth_existing_cookies-0.6-py3-none-any.whl", "yanked": false}], "0.6.1": [{"comment_text": "", "digests": {"md5": "3a3dd8feac490e8f0a22141e2924caea", "sha256": "e66408f241f3163f34c99cd1ae3906d26f6dd973fb30ddeb13511770bc031919"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.6.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3a3dd8feac490e8f0a22141e2924caea", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 13646, "upload_time": "2020-02-06T07:03:27", "upload_time_iso_8601": "2020-02-06T07:03:27.628384Z", "url": "https://files.pythonhosted.org/packages/aa/91/caded1cf01e888d9f55cdbd784a05640f207579b1d43c949562e5a6474fa/datasette_auth_existing_cookies-0.6.1-py3-none-any.whl", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "ca57edcd12533616a01f8c76a04abe38", "sha256": "7482fa0bedc3e5602c44be39d7f7e671b99e3517380b95a0a74c79e9d8fc2961"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "ca57edcd12533616a01f8c76a04abe38", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 13639, "upload_time": "2020-04-15T15:25:40", "upload_time_iso_8601": "2020-04-15T15:25:40.909901Z", "url": "https://files.pythonhosted.org/packages/55/f7/9ef56d150af2d722ca2048f328bf8cc68615d9abe1936cc4f253f69cd55f/datasette_auth_existing_cookies-0.7-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ca57edcd12533616a01f8c76a04abe38", "sha256": "7482fa0bedc3e5602c44be39d7f7e671b99e3517380b95a0a74c79e9d8fc2961"}, "downloads": -1, "filename": "datasette_auth_existing_cookies-0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "ca57edcd12533616a01f8c76a04abe38", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 13639, "upload_time": "2020-04-15T15:25:40", "upload_time_iso_8601": "2020-04-15T15:25:40.909901Z", "url": "https://files.pythonhosted.org/packages/55/f7/9ef56d150af2d722ca2048f328bf8cc68615d9abe1936cc4f253f69cd55f/datasette_auth_existing_cookies-0.7-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 00:40:12 2020"}