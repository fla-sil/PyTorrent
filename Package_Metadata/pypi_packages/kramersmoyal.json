{"info": {"author": "Leonardo Rydin Gorjao and Francisco Meirinhos", "author_email": "leonardo.rydin@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "[![status](https://joss.theoj.org/papers/f8158e61d51e0a9822dcc69a4a3c1f4d/status.svg)](https://joss.theoj.org/papers/f8158e61d51e0a9822dcc69a4a3c1f4d) [![Build Status](https://travis-ci.org/LRydin/KramersMoyal.svg?branch=master)](https://travis-ci.org/LRydin/KramersMoyal) [![Documentation Status](https://readthedocs.org/projects/kramersmoyal/badge/?version=latest)](https://kramersmoyal.readthedocs.io/en/latest/?badge=latest)\n\n# KramersMoyal\n`kramersmoyal` is a python package designed to obtain the Kramers\u2013Moyal coefficients, or conditional moments, from stochastic data of any dimension. It employs kernel density estimations, instead of a histogram approach, to ensure better results for low number of points as well as allowing better fitting of the results\n\n# Installation\nFor the moment the library is available from TestPyPI, so you can use\n\n```\npip install -i https://test.pypi.org/simple/ kramersmoyal\n```\nThen on your favourite editor just use\n```python\nfrom kramersmoyal import km, kernels\n```\n\n## Dependencies\nThe library depends on `numpy` and `scipy`.\n\n# A one-dimensional stochastic process\n\nA Jupyter notebook with this example can be found [here](/examples/kmc.ipynb)\n\n## The theory\nTake, for example, the well-documented one-dimension Ornstein\u2013Uhlenbeck process, also known as Va&#353;&#237;&#269;ek process, see [here](https://en.wikipedia.org/wiki/Ornstein%E2%80%93Uhlenbeck_process). This process is governed by two main parameters: the mean-reverting parameter &theta; and the diffusion parameter &sigma;\n\n<img src=\"/other/OU_eq.png\" title=\"Ornstein\u2013Uhlenbeck process\" height=\"25\"/>\n\nwhich can be solved in various ways. For our purposes, recall that the drift coefficient, i.e., the first-order Kramers\u2013Moyal coefficient, is given by ![](/other/inline_KM_1.png) and the second-order Kramers\u2013Moyal coefficient is ![](/other/inline_KM_2.png), i.e., the diffusion.\n\nGenerate an exemplary Ornstein\u2013Uhlenbeck process with your favourite integrator, e.g., the [Euler\u2013Maruyama](https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method) or with a more powerful tool from [`JiTCSDE`](https://github.com/neurophysik/jitcsde) found on GitHub.\nFor this example let's take &theta;=.3 and &sigma;=.1, over a total time of 500 units, with a sampling of 1000 Hertz, and from the generated data series retrieve the two parameters, the drift -&theta;y(t) and diffusion &sigma;.\n\n## Integrating an Ornstein\u2013Uhlenbeck process\nHere is a short code on generating a Ornstein\u2013Uhlenbeck stochastic trajectory with a simple Euler\u2013Maruyama integration method\n\n```python\n# integration time and time sampling\nt_final = 500\ndelta_t = 0.001\n\n# The parameters theta and sigma\ntheta = 0.3\nsigma = 0.1\n\n# The time array of the trajectory\ntime = np.arange(0, t_final, delta_t)\n\n# Initialise the array y\ny = np.zeros(time.size)\n\n# Generate a Wiener process\ndw = np.random.normal(loc = 0, scale = np.sqrt(delta_t), size = time.size)\n\n# Integrate the process\nfor i in range(1,time.size):\n    y[i] = y[i-1] - theta*y[i-1]*delta_t + sigma*dw[i]\n```\n\nFrom here we have a plain example of an Ornstein\u2013Uhlenbeck process, always drifting back to zero, due to the mean-reverting drift &theta;. The effect of the noise can be seen across the whole trajectory.\n\n<img src=\"/other/fig1.png\" title=\"Ornstein\u2013Uhlenbeck process\" height=\"200\"/>\n\n## Using `kramersmoyal`\nTake the timeseries `y` and let's study the Kramers\u2013Moyal coefficients. For this let's look at the drift and diffusion coefficients of the process, i.e., the first and second Kramers\u2013Moyal coefficients, with an `epanechnikov` kernel\n```python\n# Choose number of points of you target space\nbins = np.array([5000])\n\n# Choose powers to calculate\npowers = np.array([[1], [2]])\n\n# Choose your desired bandwith\nbw = 0.15\n\n# The kmc holds the results, where edges holds the binning space\nkmc, edges = km(y, kernel = kernels.epanechnikov, bw = bw, bins = bins, powers = powers)\n```\n\nThis results in\n\n<img src=\"/other/fig2.png\" title=\"Drift and diffusion terms of an Ornstein\u2013Uhlenbeck process\" height=\"200\"/>\n\nNotice here that to obtain the Kramers\u2013Moyal coefficients you need to multiply `kmc` by the timestep `delta_t`. This normalisation stems from the Taylor-like approximation, i.e., the Kramers\u2013Moyal expansion (`delta t` &rarr; 0).\n\n# A two-dimensional diffusion process\n\nA Jupyter notebook with this example can be found [here](/examples/kmc.ipynb)\n\n## Theory\n\nA two-dimensional diffusion process is a stochastic process that comprises two ![](/other/inline_W.png) and allows for a mixing of these noise terms across its two dimensions.\n\n<img src=\"/other/2D-diffusion.png\" alt=\"2D-diffusion\" title=\"A 2-dimensional diffusion process\" height=\"60\" />\n\nwhere we will select a set of state-dependent parameters obeying\n\n<img src=\"/other/parameters_2D-diffusion.png\" alt=\"2D-diffusion\" title=\"Specific parameters for the diffusion process\" height=\"70\" />\n\nwith ![](/other/inline_parameters_2D-diffusion_1.png) and ![](/other/inline_parameters_2D-diffusion_2.png).\n\n## Choice of parameters\nAs an example, let's take the following set of parameters for the drift vector and diffusion matrix\n\n```python\n# integration time and time sampling\nt_final = 2000\ndelta_t = 0.001\n\n# Define the drift vector N\nN = np.array([2.0, 1.0])\n\n# Define the diffusion matrix g\ng = np.array([[0.5, 0.0], [0.0, 0.5]])\n\n# The time array of the trajectory\ntime = np.arange(0, t_final, delta_t)\n```\n\n## Integrating a 2-dimensional process\nIntegrating the previous stochastic trajectory with a simple Euler\u2013Maruyama integration method\n\n```python\n# Initialise the array y\ny = np.zeros([time.size, 2])\n\n# Generate two Wiener processes with a scale of np.sqrt(delta_t)\ndW = np.random.normal(loc = 0, scale = np.sqrt(delta_t), size = [time.size, 2])\n\n# Integrate the process (takes about 20 secs)\nfor i in range(1, time.size):\n    y[i,0] = y[i-1,0]  -  N[0] * y[i-1,0] * delta_t + g[0,0]/(1 + np.exp(y[i-1,0]**2)) * dW[i,0]  +  g[0,1] * dW[i,1]\n    y[i,1] = y[i-1,1]  -  N[1] * y[i-1,1] * delta_t + g[1,0] * dW[i,0]  +  g[1,1]/(1 + np.exp(y[i-1,1]**2)) * dW[i,1]\n```\n\nThe stochastic trajectory in 2 dimensions for 10 time units (10000 data points)\n\n<img src=\"/other/fig3.png\" alt=\"2D-diffusion\" title=\"2-dimensional trajectory\" height=\"280\" />\n\n## Back to `kramersmoyal` and the Kramers\u2013Moyal coefficients\nFirst notice that all the results now will be two-dimensional surfaces, so we will need to plot them as such\n\n```python\n# Choose the size of your target space in two dimensions\nbins = np.array([300, 300])\n\n# Introduce the desired orders to calculate, but in 2 dimensions\npowers = np.array([[0,0], [1,0], [0,1], [1,1], [2,0], [0,2], [2,2]])\n# insert into kmc:   0      1      2      3      4      5      6\n\n# Notice that the first entry in [,] is for the first dimension, the\n# second for the second dimension...\n\n# Choose a desired bandwidth bw\nbw = 0.1\n\n# Calculate the Kramers\u2212Moyal coefficients\nkmc, edges = km(y, bw = bw, bins = bins, powers = powers)\n\n# The K\u2212M coefficients are stacked along the first dim of the\n# kmc array, so kmc[1,...] is the first K\u2212M coefficient, kmc[2,...]\n# is the second. These will be 2-dimensional matrices\n```\n\nNow one can visualise the Kramers\u2013Moyal coefficients (surfaces) in green and the respective theoretical surfaces in black. (Don't forget to normalise: `kmc * delta_t`).\n\n<img src=\"/other/fig4.png\" alt=\"2D-diffusion\" title=\"2-dimensional Kramers\u2013Moyal surfaces (green) and the theoretical surfaces (black)\" height=\"480\" />\n\n# Contributions\nWe welcome reviews and ideas from everyone. If you want to share your ideas or report a bug, open an [issue](https://github.com/LRydin/KramersMoyal/issues) here on GitHub, or contact us directly.\nIf you need help with the code, the theory, or the implementation, do not hesitate to contact us, we are here to help.\nWe abide to a [Conduct of Fairness](contributions.md).\n\n# TODOs\nNext on the list is\n- Include more kernels\n- Work through the documentation carefully\n- Create a sub-routine to calculate the Kramers\u2013Moyal coefficients without a convolution\n\n# Changelog\n- Version 0.4 - Added the documentation, first testers, and the Conduct of Fairness\n- Version 0.32 - Adding 2 kernels: `triagular` and `quartic` and extenting the documentation and examples.\n- Version 0.31 - Corrections to the fft triming after convolution.\n- Version 0.3 - The major breakthrough: Calculates the Kramers\u2013Moyal coefficients for data of any dimension.\n- Version 0.2 - Introducing convolutions and `gaussian` and `uniform` kernels. Major speed up in the calculations.\n- Version 0.1 - One and two dimensional Kramers\u2013Moyal coefficients with an `epanechnikov` kernel.\n\n# Literature and Support\n\n### Literature\nThe study of stochastic processes from a data-driven approach is grounded in extensive mathematical work. From the applied perspective there are several references to understand stochastic processes, the Fokker\u2013Planck equations, and the Kramers\u2013Moyal expansion\n\n- Tabar, M. R. R. (2019). *Analysis and Data-Based Reconstruction of Complex Nonlinear Dynamical Systems.* Springer, International Publishing\n- Risken, H. (1989). *The Fokker\u2013Planck equation.* Springer, Berlin, Heidelberg.\n- Gardiner, C.W. (1985). *Handbook of Stochastic Methods.* Springer, Berlin.\n\nYou can find and extensive review on the subject [here](http://sharif.edu/~rahimitabar/pdfs/80.pdf)<sup>1</sup>\n\n### History\nThis project was started in 2017 at the [neurophysik](https://www.researchgate.net/lab/Klaus-Lehnertz-Lab-2) by Leonardo Rydin Gorj\u00e3o, Jan Heysel, Klaus Lehnertz, and M. Reza Rahimi Tabar. Francisco Meirinhos later devised the hard coding to python. The project is now supported by Dirk Witthaut and the [Institute of Energy and Climate Research Systems Analysis and Technology Evaluation](https://www.fz-juelich.de/iek/iek-ste/EN/Home/home_node.html).\n\n### Funding\nHelmholtz Association Initiative _Energy System 2050 - A Contribution of the Research Field Energy_ and the grant No. VH-NG-1025 and *STORM - Stochastics for Time-Space Risk Models* project of the Research Council of Norway (RCN) No. 274410.\n\n---\n\n<sup>1</sup> Friedrich, R., Peinke, J., Sahimi, M., Tabar, M. R. R. *Approaching complexity by stochastic methods: From biological systems to turbulence,* [Phys. Rep. 506, 87\u2013162 (2011)](https://doi.org/10.1016/j.physrep.2011.05.003).\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/LRydin/KramersMoyal", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "kramersmoyal", "package_url": "https://pypi.org/project/kramersmoyal/", "platform": "", "project_url": "https://pypi.org/project/kramersmoyal/", "project_urls": {"Homepage": "https://github.com/LRydin/KramersMoyal"}, "release_url": "https://pypi.org/project/kramersmoyal/0.4/", "requires_dist": null, "requires_python": ">=3", "summary": "Calculate Kramers-Moyal coefficients for stochastic process of any dimension, up to any order.", "version": "0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://joss.theoj.org/papers/f8158e61d51e0a9822dcc69a4a3c1f4d\" rel=\"nofollow\"><img alt=\"status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a2ec8391ff6b1e849e5921e5f81b0e16dcb1a632/68747470733a2f2f6a6f73732e7468656f6a2e6f72672f7061706572732f66383135386536316435316530613938323264636336396134613363316634642f7374617475732e737667\"></a> <a href=\"https://travis-ci.org/LRydin/KramersMoyal\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/71ca5cf9b8d324972d80aa89268bd56e06cc7cf9/68747470733a2f2f7472617669732d63692e6f72672f4c527964696e2f4b72616d6572734d6f79616c2e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://kramersmoyal.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3f72a6e0442fd57f749c3dc602b6b051585b9250/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6b72616d6572736d6f79616c2f62616467652f3f76657273696f6e3d6c6174657374\"></a></p>\n<h1>KramersMoyal</h1>\n<p><code>kramersmoyal</code> is a python package designed to obtain the Kramers\u2013Moyal coefficients, or conditional moments, from stochastic data of any dimension. It employs kernel density estimations, instead of a histogram approach, to ensure better results for low number of points as well as allowing better fitting of the results</p>\n<h1>Installation</h1>\n<p>For the moment the library is available from TestPyPI, so you can use</p>\n<pre><code>pip install -i https://test.pypi.org/simple/ kramersmoyal\n</code></pre>\n<p>Then on your favourite editor just use</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">kramersmoyal</span> <span class=\"kn\">import</span> <span class=\"n\">km</span><span class=\"p\">,</span> <span class=\"n\">kernels</span>\n</pre>\n<h2>Dependencies</h2>\n<p>The library depends on <code>numpy</code> and <code>scipy</code>.</p>\n<h1>A one-dimensional stochastic process</h1>\n<p>A Jupyter notebook with this example can be found <a href=\"/examples/kmc.ipynb\" rel=\"nofollow\">here</a></p>\n<h2>The theory</h2>\n<p>Take, for example, the well-documented one-dimension Ornstein\u2013Uhlenbeck process, also known as Va\u0161\u00ed\u010dek process, see <a href=\"https://en.wikipedia.org/wiki/Ornstein%E2%80%93Uhlenbeck_process\" rel=\"nofollow\">here</a>. This process is governed by two main parameters: the mean-reverting parameter \u03b8 and the diffusion parameter \u03c3</p>\n<img height=\"25\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c0119228378e35b268808d6d11155057cdb6f6c8/2f6f746865722f4f555f65712e706e67\">\n<p>which can be solved in various ways. For our purposes, recall that the drift coefficient, i.e., the first-order Kramers\u2013Moyal coefficient, is given by <img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/947440f3308673cbb921b8e0b161ecbb790251f6/2f6f746865722f696e6c696e655f4b4d5f312e706e67\"> and the second-order Kramers\u2013Moyal coefficient is <img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e766773269ba8d2dbe4a694676c5e6673f3fcd20/2f6f746865722f696e6c696e655f4b4d5f322e706e67\">, i.e., the diffusion.</p>\n<p>Generate an exemplary Ornstein\u2013Uhlenbeck process with your favourite integrator, e.g., the <a href=\"https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method\" rel=\"nofollow\">Euler\u2013Maruyama</a> or with a more powerful tool from <a href=\"https://github.com/neurophysik/jitcsde\" rel=\"nofollow\"><code>JiTCSDE</code></a> found on GitHub.\nFor this example let's take \u03b8=.3 and \u03c3=.1, over a total time of 500 units, with a sampling of 1000 Hertz, and from the generated data series retrieve the two parameters, the drift -\u03b8y(t) and diffusion \u03c3.</p>\n<h2>Integrating an Ornstein\u2013Uhlenbeck process</h2>\n<p>Here is a short code on generating a Ornstein\u2013Uhlenbeck stochastic trajectory with a simple Euler\u2013Maruyama integration method</p>\n<pre><span class=\"c1\"># integration time and time sampling</span>\n<span class=\"n\">t_final</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>\n<span class=\"n\">delta_t</span> <span class=\"o\">=</span> <span class=\"mf\">0.001</span>\n\n<span class=\"c1\"># The parameters theta and sigma</span>\n<span class=\"n\">theta</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span>\n<span class=\"n\">sigma</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>\n\n<span class=\"c1\"># The time array of the trajectory</span>\n<span class=\"n\">time</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">t_final</span><span class=\"p\">,</span> <span class=\"n\">delta_t</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Initialise the array y</span>\n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Generate a Wiener process</span>\n<span class=\"n\">dw</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"n\">loc</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">scale</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">delta_t</span><span class=\"p\">),</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Integrate the process</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">):</span>\n    <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">theta</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">delta_t</span> <span class=\"o\">+</span> <span class=\"n\">sigma</span><span class=\"o\">*</span><span class=\"n\">dw</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n</pre>\n<p>From here we have a plain example of an Ornstein\u2013Uhlenbeck process, always drifting back to zero, due to the mean-reverting drift \u03b8. The effect of the noise can be seen across the whole trajectory.</p>\n<img height=\"200\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/63c7b40052ab3b16f9315f830e469a7aeb0b85e3/2f6f746865722f666967312e706e67\">\n<h2>Using <code>kramersmoyal</code></h2>\n<p>Take the timeseries <code>y</code> and let's study the Kramers\u2013Moyal coefficients. For this let's look at the drift and diffusion coefficients of the process, i.e., the first and second Kramers\u2013Moyal coefficients, with an <code>epanechnikov</code> kernel</p>\n<pre><span class=\"c1\"># Choose number of points of you target space</span>\n<span class=\"n\">bins</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">5000</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Choose powers to calculate</span>\n<span class=\"n\">powers</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]])</span>\n\n<span class=\"c1\"># Choose your desired bandwith</span>\n<span class=\"n\">bw</span> <span class=\"o\">=</span> <span class=\"mf\">0.15</span>\n\n<span class=\"c1\"># The kmc holds the results, where edges holds the binning space</span>\n<span class=\"n\">kmc</span><span class=\"p\">,</span> <span class=\"n\">edges</span> <span class=\"o\">=</span> <span class=\"n\">km</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">kernel</span> <span class=\"o\">=</span> <span class=\"n\">kernels</span><span class=\"o\">.</span><span class=\"n\">epanechnikov</span><span class=\"p\">,</span> <span class=\"n\">bw</span> <span class=\"o\">=</span> <span class=\"n\">bw</span><span class=\"p\">,</span> <span class=\"n\">bins</span> <span class=\"o\">=</span> <span class=\"n\">bins</span><span class=\"p\">,</span> <span class=\"n\">powers</span> <span class=\"o\">=</span> <span class=\"n\">powers</span><span class=\"p\">)</span>\n</pre>\n<p>This results in</p>\n<img height=\"200\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/47f80ec4e7cdc97064b4f4189d5b407f121eecac/2f6f746865722f666967322e706e67\">\n<p>Notice here that to obtain the Kramers\u2013Moyal coefficients you need to multiply <code>kmc</code> by the timestep <code>delta_t</code>. This normalisation stems from the Taylor-like approximation, i.e., the Kramers\u2013Moyal expansion (<code>delta t</code> \u2192 0).</p>\n<h1>A two-dimensional diffusion process</h1>\n<p>A Jupyter notebook with this example can be found <a href=\"/examples/kmc.ipynb\" rel=\"nofollow\">here</a></p>\n<h2>Theory</h2>\n<p>A two-dimensional diffusion process is a stochastic process that comprises two <img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3b0a39c3693f4400c30ff302420675616e7068d5/2f6f746865722f696e6c696e655f572e706e67\"> and allows for a mixing of these noise terms across its two dimensions.</p>\n<img alt=\"2D-diffusion\" height=\"60\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/830be7a3473972e01fa3fd2a4587d0a57e28ed73/2f6f746865722f32442d646966667573696f6e2e706e67\">\n<p>where we will select a set of state-dependent parameters obeying</p>\n<img alt=\"2D-diffusion\" height=\"70\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/87e4e4d9212e4aff23192e5977bd6e00895542e3/2f6f746865722f706172616d65746572735f32442d646966667573696f6e2e706e67\">\n<p>with <img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1c4d080380e8808c8ec837ec136f48c41f0657f9/2f6f746865722f696e6c696e655f706172616d65746572735f32442d646966667573696f6e5f312e706e67\"> and <img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f895d3f1368595db2cb03a9dc4f7ebd7bee157a8/2f6f746865722f696e6c696e655f706172616d65746572735f32442d646966667573696f6e5f322e706e67\">.</p>\n<h2>Choice of parameters</h2>\n<p>As an example, let's take the following set of parameters for the drift vector and diffusion matrix</p>\n<pre><span class=\"c1\"># integration time and time sampling</span>\n<span class=\"n\">t_final</span> <span class=\"o\">=</span> <span class=\"mi\">2000</span>\n<span class=\"n\">delta_t</span> <span class=\"o\">=</span> <span class=\"mf\">0.001</span>\n\n<span class=\"c1\"># Define the drift vector N</span>\n<span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Define the diffusion matrix g</span>\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">]])</span>\n\n<span class=\"c1\"># The time array of the trajectory</span>\n<span class=\"n\">time</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">t_final</span><span class=\"p\">,</span> <span class=\"n\">delta_t</span><span class=\"p\">)</span>\n</pre>\n<h2>Integrating a 2-dimensional process</h2>\n<p>Integrating the previous stochastic trajectory with a simple Euler\u2013Maruyama integration method</p>\n<pre><span class=\"c1\"># Initialise the array y</span>\n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">([</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Generate two Wiener processes with a scale of np.sqrt(delta_t)</span>\n<span class=\"n\">dW</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"n\">loc</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">scale</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">delta_t</span><span class=\"p\">),</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Integrate the process (takes about 20 secs)</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">):</span>\n    <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"o\">-</span>  <span class=\"n\">N</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">delta_t</span> <span class=\"o\">+</span> <span class=\"n\">g</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"o\">*</span> <span class=\"n\">dW</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"o\">+</span>  <span class=\"n\">g</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">dW</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span>  <span class=\"o\">-</span>  <span class=\"n\">N</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">delta_t</span> <span class=\"o\">+</span> <span class=\"n\">g</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">dW</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"o\">+</span>  <span class=\"n\">g</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"o\">*</span> <span class=\"n\">dW</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre>\n<p>The stochastic trajectory in 2 dimensions for 10 time units (10000 data points)</p>\n<img alt=\"2D-diffusion\" height=\"280\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8d72a351ba45f61377bc4de3431936fe2071be8b/2f6f746865722f666967332e706e67\">\n<h2>Back to <code>kramersmoyal</code> and the Kramers\u2013Moyal coefficients</h2>\n<p>First notice that all the results now will be two-dimensional surfaces, so we will need to plot them as such</p>\n<pre><span class=\"c1\"># Choose the size of your target space in two dimensions</span>\n<span class=\"n\">bins</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Introduce the desired orders to calculate, but in 2 dimensions</span>\n<span class=\"n\">powers</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">]])</span>\n<span class=\"c1\"># insert into kmc:   0      1      2      3      4      5      6</span>\n\n<span class=\"c1\"># Notice that the first entry in [,] is for the first dimension, the</span>\n<span class=\"c1\"># second for the second dimension...</span>\n\n<span class=\"c1\"># Choose a desired bandwidth bw</span>\n<span class=\"n\">bw</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>\n\n<span class=\"c1\"># Calculate the Kramers\u2212Moyal coefficients</span>\n<span class=\"n\">kmc</span><span class=\"p\">,</span> <span class=\"n\">edges</span> <span class=\"o\">=</span> <span class=\"n\">km</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">bw</span> <span class=\"o\">=</span> <span class=\"n\">bw</span><span class=\"p\">,</span> <span class=\"n\">bins</span> <span class=\"o\">=</span> <span class=\"n\">bins</span><span class=\"p\">,</span> <span class=\"n\">powers</span> <span class=\"o\">=</span> <span class=\"n\">powers</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># The K\u2212M coefficients are stacked along the first dim of the</span>\n<span class=\"c1\"># kmc array, so kmc[1,...] is the first K\u2212M coefficient, kmc[2,...]</span>\n<span class=\"c1\"># is the second. These will be 2-dimensional matrices</span>\n</pre>\n<p>Now one can visualise the Kramers\u2013Moyal coefficients (surfaces) in green and the respective theoretical surfaces in black. (Don't forget to normalise: <code>kmc * delta_t</code>).</p>\n<img alt=\"2D-diffusion\" height=\"480\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c7521f82ec58d59725344de23962805d2f54dc09/2f6f746865722f666967342e706e67\">\n<h1>Contributions</h1>\n<p>We welcome reviews and ideas from everyone. If you want to share your ideas or report a bug, open an <a href=\"https://github.com/LRydin/KramersMoyal/issues\" rel=\"nofollow\">issue</a> here on GitHub, or contact us directly.\nIf you need help with the code, the theory, or the implementation, do not hesitate to contact us, we are here to help.\nWe abide to a <a href=\"contributions.md\" rel=\"nofollow\">Conduct of Fairness</a>.</p>\n<h1>TODOs</h1>\n<p>Next on the list is</p>\n<ul>\n<li>Include more kernels</li>\n<li>Work through the documentation carefully</li>\n<li>Create a sub-routine to calculate the Kramers\u2013Moyal coefficients without a convolution</li>\n</ul>\n<h1>Changelog</h1>\n<ul>\n<li>Version 0.4 - Added the documentation, first testers, and the Conduct of Fairness</li>\n<li>Version 0.32 - Adding 2 kernels: <code>triagular</code> and <code>quartic</code> and extenting the documentation and examples.</li>\n<li>Version 0.31 - Corrections to the fft triming after convolution.</li>\n<li>Version 0.3 - The major breakthrough: Calculates the Kramers\u2013Moyal coefficients for data of any dimension.</li>\n<li>Version 0.2 - Introducing convolutions and <code>gaussian</code> and <code>uniform</code> kernels. Major speed up in the calculations.</li>\n<li>Version 0.1 - One and two dimensional Kramers\u2013Moyal coefficients with an <code>epanechnikov</code> kernel.</li>\n</ul>\n<h1>Literature and Support</h1>\n<h3>Literature</h3>\n<p>The study of stochastic processes from a data-driven approach is grounded in extensive mathematical work. From the applied perspective there are several references to understand stochastic processes, the Fokker\u2013Planck equations, and the Kramers\u2013Moyal expansion</p>\n<ul>\n<li>Tabar, M. R. R. (2019). <em>Analysis and Data-Based Reconstruction of Complex Nonlinear Dynamical Systems.</em> Springer, International Publishing</li>\n<li>Risken, H. (1989). <em>The Fokker\u2013Planck equation.</em> Springer, Berlin, Heidelberg.</li>\n<li>Gardiner, C.W. (1985). <em>Handbook of Stochastic Methods.</em> Springer, Berlin.</li>\n</ul>\n<p>You can find and extensive review on the subject <a href=\"http://sharif.edu/%7Erahimitabar/pdfs/80.pdf\" rel=\"nofollow\">here</a><sup>1</sup></p>\n<h3>History</h3>\n<p>This project was started in 2017 at the <a href=\"https://www.researchgate.net/lab/Klaus-Lehnertz-Lab-2\" rel=\"nofollow\">neurophysik</a> by Leonardo Rydin Gorj\u00e3o, Jan Heysel, Klaus Lehnertz, and M. Reza Rahimi Tabar. Francisco Meirinhos later devised the hard coding to python. The project is now supported by Dirk Witthaut and the <a href=\"https://www.fz-juelich.de/iek/iek-ste/EN/Home/home_node.html\" rel=\"nofollow\">Institute of Energy and Climate Research Systems Analysis and Technology Evaluation</a>.</p>\n<h3>Funding</h3>\n<p>Helmholtz Association Initiative <em>Energy System 2050 - A Contribution of the Research Field Energy</em> and the grant No. VH-NG-1025 and <em>STORM - Stochastics for Time-Space Risk Models</em> project of the Research Council of Norway (RCN) No. 274410.</p>\n<hr>\n<p><sup>1</sup> Friedrich, R., Peinke, J., Sahimi, M., Tabar, M. R. R. <em>Approaching complexity by stochastic methods: From biological systems to turbulence,</em> <a href=\"https://doi.org/10.1016/j.physrep.2011.05.003\" rel=\"nofollow\">Phys. Rep. 506, 87\u2013162 (2011)</a>.</p>\n\n          </div>"}, "last_serial": 6291893, "releases": {"0.3.2": [{"comment_text": "", "digests": {"md5": "61df67a5456a61b46aa4144333f4b433", "sha256": "30a560ec9859950083217f373520cf53061ed2d6ffd349711d1278a1f293dc2e"}, "downloads": -1, "filename": "kramersmoyal-0.3.2-py3-none-any.whl", "has_sig": false, "md5_digest": "61df67a5456a61b46aa4144333f4b433", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 11345, "upload_time": "2019-12-13T09:43:06", "upload_time_iso_8601": "2019-12-13T09:43:06.230326Z", "url": "https://files.pythonhosted.org/packages/7e/f0/87f3af007556bb5cbb7fe37f955bb123ac7af3c74790b1feb3b650d6c180/kramersmoyal-0.3.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0c2ac711260eacb99d15a4675a8d3019", "sha256": "2d2dff5e309e9199a524078f0aa313daf5f11a73c440c8d07316360c610e85c5"}, "downloads": -1, "filename": "kramersmoyal-0.3.2.tar.gz", "has_sig": false, "md5_digest": "0c2ac711260eacb99d15a4675a8d3019", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 9812, "upload_time": "2019-12-13T09:43:10", "upload_time_iso_8601": "2019-12-13T09:43:10.750945Z", "url": "https://files.pythonhosted.org/packages/59/44/026a122c9b8918f68988442499b6992e5bdc4aac6df7cd6e220155dd9a37/kramersmoyal-0.3.2.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "28417452df59a91a4f7def4b69fe1e09", "sha256": "0827a1a8a898b984f06d360994b8576d04f1d3a326746bb9fca5d470a8e45781"}, "downloads": -1, "filename": "kramersmoyal-0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "28417452df59a91a4f7def4b69fe1e09", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 11966, "upload_time": "2019-12-13T09:43:08", "upload_time_iso_8601": "2019-12-13T09:43:08.873800Z", "url": "https://files.pythonhosted.org/packages/e7/6d/1c31eb0627fc3e58d0f877c34830a0b59303344f74934e22d413c8ddf2fe/kramersmoyal-0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "45d8a532d7216104a9a58ff48a051926", "sha256": "203f5856527ab80c00d9c73bdce598e05142b340d1cf27f12546ed68522f7a77"}, "downloads": -1, "filename": "kramersmoyal-0.4.tar.gz", "has_sig": false, "md5_digest": "45d8a532d7216104a9a58ff48a051926", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 11437, "upload_time": "2019-12-13T09:43:12", "upload_time_iso_8601": "2019-12-13T09:43:12.515415Z", "url": "https://files.pythonhosted.org/packages/71/8f/132b143715b74ddc7720608b38cd8568a6eafe0eba875632a6b75e692f4e/kramersmoyal-0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "28417452df59a91a4f7def4b69fe1e09", "sha256": "0827a1a8a898b984f06d360994b8576d04f1d3a326746bb9fca5d470a8e45781"}, "downloads": -1, "filename": "kramersmoyal-0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "28417452df59a91a4f7def4b69fe1e09", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 11966, "upload_time": "2019-12-13T09:43:08", "upload_time_iso_8601": "2019-12-13T09:43:08.873800Z", "url": "https://files.pythonhosted.org/packages/e7/6d/1c31eb0627fc3e58d0f877c34830a0b59303344f74934e22d413c8ddf2fe/kramersmoyal-0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "45d8a532d7216104a9a58ff48a051926", "sha256": "203f5856527ab80c00d9c73bdce598e05142b340d1cf27f12546ed68522f7a77"}, "downloads": -1, "filename": "kramersmoyal-0.4.tar.gz", "has_sig": false, "md5_digest": "45d8a532d7216104a9a58ff48a051926", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 11437, "upload_time": "2019-12-13T09:43:12", "upload_time_iso_8601": "2019-12-13T09:43:12.515415Z", "url": "https://files.pythonhosted.org/packages/71/8f/132b143715b74ddc7720608b38cd8568a6eafe0eba875632a6b75e692f4e/kramersmoyal-0.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:48:49 2020"}