{"info": {"author": "Matt Kimball", "author_email": "matt.kimball@gmail.com", "bugtrack_url": null, "classifiers": ["Framework :: AsyncIO", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Topic :: System :: Networking"], "description": "# mtrpacket\n\n### Asynchronous network probes for Python\n\n`mtrpacket` is a Python 3 package for sending IPv4 and IPv6 network probes ('pings') asynchronously from Python programs.  Python's `asyncio` library provides the event loop and mechanism for incorporating `mtrpacket`'s network probes with other concurrent operations.\n\n`mtrpacket` supports a variety of probe customization options. Time-to-live (TTL) may be explicitly used for `traceroute`-like functionality.  Probes can be sent using a variety of protocols:  ICMP, UDP, TCP and SCTP.  UDP, TCP and SCTP probes may be sent with specific source and destination ports.  Probes can be sent with a particular packet size and payload bit-pattern. On Linux, probes can be sent with a routing \"mark\".\n\n`mtrpacket` works on Linux, MacOS, Windows (under Cygwin) and various Unix systems.  Requirements are Python 3.5 (or newer) and `mtr`  0.88 (or newer).   `mtr` is distributed with many Linux distributions -- you may have it installed already.  For other operating systems, see [the mtr Github repository](https://github.com/traviscross/mtr).\n\n## Installation\n\nTo install mtrpacket, use the Python 3 version of pip:\n\n`pip3 install mtrpacket`\n\n## Getting started\n\nThe easiest way to get started with mtrpacket is to use `async with` to open an mtrpacket session, and then call probe on that session. This must be done in an `asyncio` coroutine.  `asyncio` manages the event loop.\n\n```python\nimport asyncio\nimport mtrpacket\n\n#  A simple coroutine which will start an mtrpacket session and\n#  ping localhost\nasync def probe():\n    async with mtrpacket.MtrPacket() as mtr:\n        return await mtr.probe('localhost')\n\n#  Use asyncio's event loop to start the coroutine and wait for the probe\nloop = asyncio.get_event_loop()\ntry:\n    result = loop.run_until_complete(probe())\nfinally:\n    loop.close()\n\n#  Print the probe result\nprint(result)\n```\n\nKeyword arguments may be used with `mtr.probe` to further customize the network probe.\n\n```python\n#  Send a probe to the HTTPS port of example.com and limit the probe\n#  to four network hops\nresult = await mtr.probe(\n    'example.com',\n    ttl=4,\n    protocol='tcp',\n    port=443)\n```\n\n## Further Examples\n\nFurther examples of usage are available in [the mtrpacket GitHub repository](https://github.com/matt-kimball/mtr-packet-python/tree/master/examples)\n\n## API Reference\n\n### MtrPacket\n#### *class* `MtrPacket()`\n\n`MtrPacket` is a channel for communicating with a subprocess running the `mtr-packet` executable.  Multiple simultaneous probe requests can be made through a single `MtrPacket` instance, with results processed asynchronously, as they arrive.\n\nThe `mtr-packet` executable is distributed with versions of `mtr` since version 0.88.\n\n#### *coroutine* `MtrPacket.open()`\n\n`open` start a subprocess for sending and receiving network probes.  The`'mtr-packet` executable found at a location in the environment `PATH` is used by default, however, the environment variable `MTR_PACKET` can be used to override this behavior, invoking an alternate subprocess executable.\n\nRather than calling `open` explicitly, the usual alternative is to use an `MtrPacket` instance in an `async with` block.  This will launch the subprocess for the duration of the block, and terminate the subprocess when the block is exited.\n\n`open` returns the `MtrPacket` object on which `open` has been invoked.  This can be safely ignored.\n\n`ProcessError` is raised if the subprocess fails to execute, or if the subprocess executable doesn't support the expected interface.\n\n`StateError` is raised if the `MtrPacket` object is already open.\n\n#### *coroutine* `MtrPacket.close()`\n\nIf `open` was explicitly called to start the subprocess, then `close` should be called to terminate the subprocess and clean up its resources.\n\n#### *coroutine* `MtrPacket.check_support(`*feature_name*`)`\n\n`check_support` can be used to check support for particular features in the `mtr-packet` subprocess.  A string is provided with the name of a feature to check, and `True` is returned if the feature is supported, `False` otherwise.\n\nThe strings `'udp'`, `'tcp'` and `'sctp'` can be used as feature names to check support for UDP probes, TCP probes, and SCTP probes, respectively.\n\nSee `check-support` in the `mtr-packet(8)` man page for more information.\n\n`ProcessError` is raised if the `mtr-packet` subprocess has unexpectedly terminated.\n\n`StateError` is raised if the `MtrPacket` session hasn't been opened.\n\n#### *coroutine* `MtrPacket.probe(`*hostname*, ...`)`\n\nSend a network probe to a particular hostname or IP address, and upon completion, return a `ProbeResult` containing the status of the probe, the address of the host responding to the probe and the round trip time of the probe.\n\n##### Keyword arguments\n\nA number of optional keyword arguments can be used with `MtrPacket.probe`:\n\n`ip_version`\n\nEither `4` or `6`, indicating that the IP protocol version to use should be either IPv4 or IPv6.  If unspecified, the appropriate IP protocol version will be determined using the network configuration of the local host and the DNS resolved IP addresses.\n\n`ttl`\n\nAn integer (0-255) for the \"time to live\" of the probe request.  This is used to limit the number of network hops the probe traverses before the probe result is returned to the origination point.  The default \"time to live\" for the probe is 255.\n\n`protocol`\n\nA string representing the protocol to use when sending the probe.  `'icmp'`, `'udp'`, `'tcp'` and `'sctp'` are recognized options.  Protocols other than `'icmp'` are not supported on all `mtr-packet` implementations.  If portability between `mtr-packet` implementations is desired, then`check_support` should be used to determine whether a particular protocol is supported before use.  The default protocol is `'icmp'`.\n\n`port`\n\nAn integer to use as the destination port for `'udp'`, `'tcp'` or `'sctp'` probes.\n\n`local_ip`\n\nAn IP address string used to set the source address of the probe to be a particular IP address.  This can be useful when sending from a host with multiple local IP addresses.  The default local address is determined using the network configuration.\n\n`local_port`\n\nAn integer to use to send the probe from a particular local port, when sending `'udp'`, `'tcp'` or `'sctp'` probes.\n\n`timeout`\n\nAn integer specifying the number of seconds to wait for a response before assuming the probe has been lost.  The default value is ten seconds.\n\n`size`\n\nAn integer specifying the size of the generated probe packet, in bytes.  The default value is the minimum size possible for a packet of the particular IP version and protocol in use.  The maximum size is the maximum transmission unit (\"MTU\") of the local network configuration.\n\n`bit_pattern`\n\nAn integer byte value used to fill the payload of the probe packet.  In some very rare cases, network performance can vary based on the contents of network packets.  This option can be used to measure such cases.\n\n`tos`\n\nAn integer value for the \"type of service\" field for IPv4 packets, or the \"traffic class\" field of IPv6 packets.\n\n`mark`\n\nAn integer value to use as the packet \"mark\" for the Linux routing subsystem.\n\n##### Exceptions\n\n`ProcessError` is raised if the mtr-packet subprocess has unexpectedly terminated.\n\n`HostResolveError` is raised if the hostname can't be resolved to an IP address.\n\n`StateError` is raised if the MtrPacket session hasn't been opened.\n\n### ProbeResult\n#### *namedtuple* `ProbeResult(`*success*, *result*, *time_ms*, *responder*, *mpls*`)`\n\nA call to `MtrPacket.probe` will result in an instance of the named tuple `ProbeResult`, which contains the following fields:\n\n#### `ProbeResult.success`\n\nA boolean which is `True` only if the probe arrived at the target host.\n\n#### `ProbeResult.result`\n\nThe command reply string from `mtr-packet`.  Common values are `'reply'` for a probe which arrives at the target host, `'ttl-expired'` for a probe which has its \"time to live\" counter reach zero before arriving at the target host, and `'no-reply'` for a probe which is unanswered before its timeout value.\n\nSee the `mtr-packet(8)` man page for error conditions which may result in other command reply strings.\n\n#### `ProbeResult.time_ms`\n\nA floating point value indicating the number of milliseconds the probe was in-transit, prior to receiving a result.  This value will be `None` in cases other than `'reply'` or `'ttl-expired'`.\n\n#### `ProbeResult.responder`\n\n A string with the IP address of the host responding to the probe.  Will be `None` in cases other than `'reply'` or `'ttl-expired'`.\n\n#### `ProbeResult.mpls`\n\nA list of `Mpls` named tuples representing the MPLS label stack present in a `'ttl-expired'` response, when Multiprotocol Label Switching (MPLS) is used to route the probe.\n\n### Mpls\n#### *namedtuple* `Mpls(`*label*, *traffic_class*, *bottom_of_stack*, *ttl*`)`\n\nMultiprotocol Label Switching (\"MPLS\") routes packets using explicit headers attach to the packet, rather than using the IP address for routing.  When a probe's time-to-live (\"TTL\") expires, and MPLS is used at the router where the expiration occurs, the MPLS headers attached to the packet may be returned with the TTL expiration notification.\n\nThe `Mpls` named tuple contains the fields of one of those headers, with:\n\n#### `Mpls.label`\n\nThe MPLS label as an integer.\n\n#### `Mpls.traffic_class`\n\nThe integer traffic class value (for quality of service).  In prior verisons of MPLS, this field was known as \"experimental use\".\n\n#### `Mpls.bottom_of_stack`\n\nA boolean indicating whether the label terminates the stack.\n\n#### `Mpls.ttl`\n\nAn integer with the \"time to live\" value of the MPLS header\n\n### Exceptions\n#### *exception* `StateError`\n\nStateError is raised when attempting to send a command to the mtr-packet subprocess without first opening the MtrPacket subprocess, or when attempting to open a subprocess which is already open.\n\n#### *exception* `HostResolveError`\n\nIf a hostname is passed to MtrPacket.probe, and that hostname fails to resolve to an IP address, `HostResolveError` is raised.\n\n#### *exception* `ProcessError`\n\nProcessError is raised by a call to `MtrPacket.probe` or `MtrPacket.check_support` when the `mtr-packet` subprocess has unexpectly terminated.  It is also raised by `MtrPacket.open` when the subprocess doesn't respond using the expected `mtr-packet` interface.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/matt-kimball/mtr-packet-python", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "mtrpacket", "package_url": "https://pypi.org/project/mtrpacket/", "platform": "", "project_url": "https://pypi.org/project/mtrpacket/", "project_urls": {"Homepage": "https://github.com/matt-kimball/mtr-packet-python"}, "release_url": "https://pypi.org/project/mtrpacket/0.2.0/", "requires_dist": null, "requires_python": "", "summary": "Asynchronous network probes for Python", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>mtrpacket</h1>\n<h3>Asynchronous network probes for Python</h3>\n<p><code>mtrpacket</code> is a Python 3 package for sending IPv4 and IPv6 network probes ('pings') asynchronously from Python programs.  Python's <code>asyncio</code> library provides the event loop and mechanism for incorporating <code>mtrpacket</code>'s network probes with other concurrent operations.</p>\n<p><code>mtrpacket</code> supports a variety of probe customization options. Time-to-live (TTL) may be explicitly used for <code>traceroute</code>-like functionality.  Probes can be sent using a variety of protocols:  ICMP, UDP, TCP and SCTP.  UDP, TCP and SCTP probes may be sent with specific source and destination ports.  Probes can be sent with a particular packet size and payload bit-pattern. On Linux, probes can be sent with a routing \"mark\".</p>\n<p><code>mtrpacket</code> works on Linux, MacOS, Windows (under Cygwin) and various Unix systems.  Requirements are Python 3.5 (or newer) and <code>mtr</code>  0.88 (or newer).   <code>mtr</code> is distributed with many Linux distributions -- you may have it installed already.  For other operating systems, see <a href=\"https://github.com/traviscross/mtr\" rel=\"nofollow\">the mtr Github repository</a>.</p>\n<h2>Installation</h2>\n<p>To install mtrpacket, use the Python 3 version of pip:</p>\n<p><code>pip3 install mtrpacket</code></p>\n<h2>Getting started</h2>\n<p>The easiest way to get started with mtrpacket is to use <code>async with</code> to open an mtrpacket session, and then call probe on that session. This must be done in an <code>asyncio</code> coroutine.  <code>asyncio</code> manages the event loop.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">import</span> <span class=\"nn\">mtrpacket</span>\n\n<span class=\"c1\">#  A simple coroutine which will start an mtrpacket session and</span>\n<span class=\"c1\">#  ping localhost</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">probe</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">mtrpacket</span><span class=\"o\">.</span><span class=\"n\">MtrPacket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">mtr</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"k\">await</span> <span class=\"n\">mtr</span><span class=\"o\">.</span><span class=\"n\">probe</span><span class=\"p\">(</span><span class=\"s1\">'localhost'</span><span class=\"p\">)</span>\n\n<span class=\"c1\">#  Use asyncio's event loop to start the coroutine and wait for the probe</span>\n<span class=\"n\">loop</span> <span class=\"o\">=</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">loop</span><span class=\"o\">.</span><span class=\"n\">run_until_complete</span><span class=\"p\">(</span><span class=\"n\">probe</span><span class=\"p\">())</span>\n<span class=\"k\">finally</span><span class=\"p\">:</span>\n    <span class=\"n\">loop</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n\n<span class=\"c1\">#  Print the probe result</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>Keyword arguments may be used with <code>mtr.probe</code> to further customize the network probe.</p>\n<pre><span class=\"c1\">#  Send a probe to the HTTPS port of example.com and limit the probe</span>\n<span class=\"c1\">#  to four network hops</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">mtr</span><span class=\"o\">.</span><span class=\"n\">probe</span><span class=\"p\">(</span>\n    <span class=\"s1\">'example.com'</span><span class=\"p\">,</span>\n    <span class=\"n\">ttl</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"n\">protocol</span><span class=\"o\">=</span><span class=\"s1\">'tcp'</span><span class=\"p\">,</span>\n    <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">443</span><span class=\"p\">)</span>\n</pre>\n<h2>Further Examples</h2>\n<p>Further examples of usage are available in <a href=\"https://github.com/matt-kimball/mtr-packet-python/tree/master/examples\" rel=\"nofollow\">the mtrpacket GitHub repository</a></p>\n<h2>API Reference</h2>\n<h3>MtrPacket</h3>\n<h4><em>class</em> <code>MtrPacket()</code></h4>\n<p><code>MtrPacket</code> is a channel for communicating with a subprocess running the <code>mtr-packet</code> executable.  Multiple simultaneous probe requests can be made through a single <code>MtrPacket</code> instance, with results processed asynchronously, as they arrive.</p>\n<p>The <code>mtr-packet</code> executable is distributed with versions of <code>mtr</code> since version 0.88.</p>\n<h4><em>coroutine</em> <code>MtrPacket.open()</code></h4>\n<p><code>open</code> start a subprocess for sending and receiving network probes.  The<code>'mtr-packet</code> executable found at a location in the environment <code>PATH</code> is used by default, however, the environment variable <code>MTR_PACKET</code> can be used to override this behavior, invoking an alternate subprocess executable.</p>\n<p>Rather than calling <code>open</code> explicitly, the usual alternative is to use an <code>MtrPacket</code> instance in an <code>async with</code> block.  This will launch the subprocess for the duration of the block, and terminate the subprocess when the block is exited.</p>\n<p><code>open</code> returns the <code>MtrPacket</code> object on which <code>open</code> has been invoked.  This can be safely ignored.</p>\n<p><code>ProcessError</code> is raised if the subprocess fails to execute, or if the subprocess executable doesn't support the expected interface.</p>\n<p><code>StateError</code> is raised if the <code>MtrPacket</code> object is already open.</p>\n<h4><em>coroutine</em> <code>MtrPacket.close()</code></h4>\n<p>If <code>open</code> was explicitly called to start the subprocess, then <code>close</code> should be called to terminate the subprocess and clean up its resources.</p>\n<h4><em>coroutine</em> <code>MtrPacket.check_support(</code><em>feature_name</em><code>)</code></h4>\n<p><code>check_support</code> can be used to check support for particular features in the <code>mtr-packet</code> subprocess.  A string is provided with the name of a feature to check, and <code>True</code> is returned if the feature is supported, <code>False</code> otherwise.</p>\n<p>The strings <code>'udp'</code>, <code>'tcp'</code> and <code>'sctp'</code> can be used as feature names to check support for UDP probes, TCP probes, and SCTP probes, respectively.</p>\n<p>See <code>check-support</code> in the <code>mtr-packet(8)</code> man page for more information.</p>\n<p><code>ProcessError</code> is raised if the <code>mtr-packet</code> subprocess has unexpectedly terminated.</p>\n<p><code>StateError</code> is raised if the <code>MtrPacket</code> session hasn't been opened.</p>\n<h4><em>coroutine</em> <code>MtrPacket.probe(</code><em>hostname</em>, ...<code>)</code></h4>\n<p>Send a network probe to a particular hostname or IP address, and upon completion, return a <code>ProbeResult</code> containing the status of the probe, the address of the host responding to the probe and the round trip time of the probe.</p>\n<h5>Keyword arguments</h5>\n<p>A number of optional keyword arguments can be used with <code>MtrPacket.probe</code>:</p>\n<p><code>ip_version</code></p>\n<p>Either <code>4</code> or <code>6</code>, indicating that the IP protocol version to use should be either IPv4 or IPv6.  If unspecified, the appropriate IP protocol version will be determined using the network configuration of the local host and the DNS resolved IP addresses.</p>\n<p><code>ttl</code></p>\n<p>An integer (0-255) for the \"time to live\" of the probe request.  This is used to limit the number of network hops the probe traverses before the probe result is returned to the origination point.  The default \"time to live\" for the probe is 255.</p>\n<p><code>protocol</code></p>\n<p>A string representing the protocol to use when sending the probe.  <code>'icmp'</code>, <code>'udp'</code>, <code>'tcp'</code> and <code>'sctp'</code> are recognized options.  Protocols other than <code>'icmp'</code> are not supported on all <code>mtr-packet</code> implementations.  If portability between <code>mtr-packet</code> implementations is desired, then<code>check_support</code> should be used to determine whether a particular protocol is supported before use.  The default protocol is <code>'icmp'</code>.</p>\n<p><code>port</code></p>\n<p>An integer to use as the destination port for <code>'udp'</code>, <code>'tcp'</code> or <code>'sctp'</code> probes.</p>\n<p><code>local_ip</code></p>\n<p>An IP address string used to set the source address of the probe to be a particular IP address.  This can be useful when sending from a host with multiple local IP addresses.  The default local address is determined using the network configuration.</p>\n<p><code>local_port</code></p>\n<p>An integer to use to send the probe from a particular local port, when sending <code>'udp'</code>, <code>'tcp'</code> or <code>'sctp'</code> probes.</p>\n<p><code>timeout</code></p>\n<p>An integer specifying the number of seconds to wait for a response before assuming the probe has been lost.  The default value is ten seconds.</p>\n<p><code>size</code></p>\n<p>An integer specifying the size of the generated probe packet, in bytes.  The default value is the minimum size possible for a packet of the particular IP version and protocol in use.  The maximum size is the maximum transmission unit (\"MTU\") of the local network configuration.</p>\n<p><code>bit_pattern</code></p>\n<p>An integer byte value used to fill the payload of the probe packet.  In some very rare cases, network performance can vary based on the contents of network packets.  This option can be used to measure such cases.</p>\n<p><code>tos</code></p>\n<p>An integer value for the \"type of service\" field for IPv4 packets, or the \"traffic class\" field of IPv6 packets.</p>\n<p><code>mark</code></p>\n<p>An integer value to use as the packet \"mark\" for the Linux routing subsystem.</p>\n<h5>Exceptions</h5>\n<p><code>ProcessError</code> is raised if the mtr-packet subprocess has unexpectedly terminated.</p>\n<p><code>HostResolveError</code> is raised if the hostname can't be resolved to an IP address.</p>\n<p><code>StateError</code> is raised if the MtrPacket session hasn't been opened.</p>\n<h3>ProbeResult</h3>\n<h4><em>namedtuple</em> <code>ProbeResult(</code><em>success</em>, <em>result</em>, <em>time_ms</em>, <em>responder</em>, <em>mpls</em><code>)</code></h4>\n<p>A call to <code>MtrPacket.probe</code> will result in an instance of the named tuple <code>ProbeResult</code>, which contains the following fields:</p>\n<h4><code>ProbeResult.success</code></h4>\n<p>A boolean which is <code>True</code> only if the probe arrived at the target host.</p>\n<h4><code>ProbeResult.result</code></h4>\n<p>The command reply string from <code>mtr-packet</code>.  Common values are <code>'reply'</code> for a probe which arrives at the target host, <code>'ttl-expired'</code> for a probe which has its \"time to live\" counter reach zero before arriving at the target host, and <code>'no-reply'</code> for a probe which is unanswered before its timeout value.</p>\n<p>See the <code>mtr-packet(8)</code> man page for error conditions which may result in other command reply strings.</p>\n<h4><code>ProbeResult.time_ms</code></h4>\n<p>A floating point value indicating the number of milliseconds the probe was in-transit, prior to receiving a result.  This value will be <code>None</code> in cases other than <code>'reply'</code> or <code>'ttl-expired'</code>.</p>\n<h4><code>ProbeResult.responder</code></h4>\n<p>A string with the IP address of the host responding to the probe.  Will be <code>None</code> in cases other than <code>'reply'</code> or <code>'ttl-expired'</code>.</p>\n<h4><code>ProbeResult.mpls</code></h4>\n<p>A list of <code>Mpls</code> named tuples representing the MPLS label stack present in a <code>'ttl-expired'</code> response, when Multiprotocol Label Switching (MPLS) is used to route the probe.</p>\n<h3>Mpls</h3>\n<h4><em>namedtuple</em> <code>Mpls(</code><em>label</em>, <em>traffic_class</em>, <em>bottom_of_stack</em>, <em>ttl</em><code>)</code></h4>\n<p>Multiprotocol Label Switching (\"MPLS\") routes packets using explicit headers attach to the packet, rather than using the IP address for routing.  When a probe's time-to-live (\"TTL\") expires, and MPLS is used at the router where the expiration occurs, the MPLS headers attached to the packet may be returned with the TTL expiration notification.</p>\n<p>The <code>Mpls</code> named tuple contains the fields of one of those headers, with:</p>\n<h4><code>Mpls.label</code></h4>\n<p>The MPLS label as an integer.</p>\n<h4><code>Mpls.traffic_class</code></h4>\n<p>The integer traffic class value (for quality of service).  In prior verisons of MPLS, this field was known as \"experimental use\".</p>\n<h4><code>Mpls.bottom_of_stack</code></h4>\n<p>A boolean indicating whether the label terminates the stack.</p>\n<h4><code>Mpls.ttl</code></h4>\n<p>An integer with the \"time to live\" value of the MPLS header</p>\n<h3>Exceptions</h3>\n<h4><em>exception</em> <code>StateError</code></h4>\n<p>StateError is raised when attempting to send a command to the mtr-packet subprocess without first opening the MtrPacket subprocess, or when attempting to open a subprocess which is already open.</p>\n<h4><em>exception</em> <code>HostResolveError</code></h4>\n<p>If a hostname is passed to MtrPacket.probe, and that hostname fails to resolve to an IP address, <code>HostResolveError</code> is raised.</p>\n<h4><em>exception</em> <code>ProcessError</code></h4>\n<p>ProcessError is raised by a call to <code>MtrPacket.probe</code> or <code>MtrPacket.check_support</code> when the <code>mtr-packet</code> subprocess has unexpectly terminated.  It is also raised by <code>MtrPacket.open</code> when the subprocess doesn't respond using the expected <code>mtr-packet</code> interface.</p>\n\n          </div>"}, "last_serial": 4950603, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "1d59f61f7b892174d58037bf89c30a9a", "sha256": "8ca0937b6971aacfc0d3cec8bd9d6494ffd8fa8320e56d6b2dc58374263bfdff"}, "downloads": -1, "filename": "mtrpacket-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1d59f61f7b892174d58037bf89c30a9a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11691, "upload_time": "2019-02-12T15:43:31", "upload_time_iso_8601": "2019-02-12T15:43:31.070211Z", "url": "https://files.pythonhosted.org/packages/88/b8/dd87cbf2fbccb19324205e9bcbc0399db51fb71fb697837986df0b78ccfc/mtrpacket-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1f764d6eaee7eaca9e01eb4dadb0268f", "sha256": "458f721e629c87b9e68479bea7890ef0199606af5cec6b26f5ff2e3dffdc5900"}, "downloads": -1, "filename": "mtrpacket-0.1.0.tar.gz", "has_sig": false, "md5_digest": "1f764d6eaee7eaca9e01eb4dadb0268f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11215, "upload_time": "2019-02-12T15:43:33", "upload_time_iso_8601": "2019-02-12T15:43:33.423570Z", "url": "https://files.pythonhosted.org/packages/10/0a/242606ba8ab592056877e29927c361c4b4be74d40719de32814835196aa7/mtrpacket-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "fdaa56a12c855d381a43d5c9ae124d21", "sha256": "9a2fef0c4019b2a7262ce6d968b5bebf8efd5169840951daadd3b982fdfc3601"}, "downloads": -1, "filename": "mtrpacket-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "fdaa56a12c855d381a43d5c9ae124d21", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12568, "upload_time": "2019-03-17T16:01:00", "upload_time_iso_8601": "2019-03-17T16:01:00.375810Z", "url": "https://files.pythonhosted.org/packages/e7/16/a6cbd9096dad4876b112b0d28d84f3ccb286a876bf1429cc070da440a9bb/mtrpacket-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7a1e41b4560f59535dbe2ba553e9e52c", "sha256": "4d8b6ec6ed0fc03ce5f979142a768d6f544df930fac54f57d2264b3af4c42e0c"}, "downloads": -1, "filename": "mtrpacket-0.2.0.tar.gz", "has_sig": false, "md5_digest": "7a1e41b4560f59535dbe2ba553e9e52c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14263, "upload_time": "2019-03-17T16:01:02", "upload_time_iso_8601": "2019-03-17T16:01:02.110855Z", "url": "https://files.pythonhosted.org/packages/e2/b6/195daea550913fee994fa7223bf0c789a937a4013212f69326a9a261226f/mtrpacket-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fdaa56a12c855d381a43d5c9ae124d21", "sha256": "9a2fef0c4019b2a7262ce6d968b5bebf8efd5169840951daadd3b982fdfc3601"}, "downloads": -1, "filename": "mtrpacket-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "fdaa56a12c855d381a43d5c9ae124d21", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12568, "upload_time": "2019-03-17T16:01:00", "upload_time_iso_8601": "2019-03-17T16:01:00.375810Z", "url": "https://files.pythonhosted.org/packages/e7/16/a6cbd9096dad4876b112b0d28d84f3ccb286a876bf1429cc070da440a9bb/mtrpacket-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7a1e41b4560f59535dbe2ba553e9e52c", "sha256": "4d8b6ec6ed0fc03ce5f979142a768d6f544df930fac54f57d2264b3af4c42e0c"}, "downloads": -1, "filename": "mtrpacket-0.2.0.tar.gz", "has_sig": false, "md5_digest": "7a1e41b4560f59535dbe2ba553e9e52c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14263, "upload_time": "2019-03-17T16:01:02", "upload_time_iso_8601": "2019-03-17T16:01:02.110855Z", "url": "https://files.pythonhosted.org/packages/e2/b6/195daea550913fee994fa7223bf0c789a937a4013212f69326a9a261226f/mtrpacket-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:50:40 2020"}