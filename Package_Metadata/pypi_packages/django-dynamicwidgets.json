{"info": {"author": "Piotr Husiaty\u0144ski", "author_email": "phusiatynski@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "======================\nDjango Dynamic Widgets\n======================\n\n\nDjango dynamic widgets is a library that allow you to define HTML and expose\nchunks, that will be load on page using XHR request.\n\nThere are few reasons why would you want to do this. The most obvious are:\n\n* caching the whole page while still displaying *hello **username** * in the\n  top right corner,\n* load content only on certain actions - user clicked or hovered on certain\n  element\n\n\nInstallation\n------------\n\nMake sure that `django.contrib.staticfiles` is set up properly and add\n`dynamicwidgets` to your `INSTALLED_APPS` setting::\n\n    INSTALLED_APPS = (\n        # ...\n        'django.contrib.staticfiles',\n        # ...\n        'dynamicwidgets',\n    )\n\n\nURL configuration\n~~~~~~~~~~~~~~~~~\n\nTo autodiscover your widget routing, you have to import all your handlers.\nThis can be done using `dynamicwidgets.handlers.default.autodiscover()`. After\nthat, you have to place handler view somewhere in the urls tree. Good place\nmight be applications `urls.py` file::\n\n    from dynamicwidgets import handlers\n\n    handlers.default.autodiscover()\n\n    urlpatterns = patterns('',\n        # ...\n        url(r'^dynamicwidget/', include('dynamicwidgets.urls')),\n    )\n\nJavascript setup\n~~~~~~~~~~~~~~~~\n\nDynamic widgets library is using javascript to dynamicly load HTML chunks and\ndepends on jQuery.\n\nOn page that you will use dynamic widges, include both jQuery and dynamic\nwidges libraries::\n\n\n    {# include jQuery #}\n    <script src=\"{% static \"dynamicwidgets/js/dynamicwidget.js\" %}\" type=\"text/javascript\"></script>\n\nIn addition, **before** including above libraries, preferably in `<head>` tag,\nspecify path to widgets view::\n\n    <script type=\"text/javascript\">window.DYNAMIC_WIDGETS_URL = '{% url \"dynamicwidgets.widgets\" %}';</script>\n\n\nUsage\n-----\n\nTo use a widget, you have to define handler that will build and return a\ncontent and a tag in the HTML document that content will be load into.\n\nWidget handler\n~~~~~~~~~~~~~~\n\nWidget handler is a function that always takes two parameters - `request` and\na list of `widgets`. To define a handler, decorate it with\n`dynamicwidgets.decorators.widget_handler`::\n\n\n    from articles.models import Article\n    from dynamicwidgets.decorators import widget_handler\n\n\n    @widget_handler(r'^user-name$')\n    def user_name(request, widgets):\n        if request.user.is_anonymous():\n            return {'user-name': {'html': 'anonymous'}}\n        return {'user-name': {'html': request.user.username}}\n\n\nEvery handler should return a dictionary, where keys are widget names and\nvalues are dictionaries. If value dictionary contains `html` key, it's value\nwill be rendered on page as widget content.\n\n\nFor performance reasons, all widget matches are aggregated and within single\nrequest and every widget handler is called not more than once. Because of\nthat, you can save some queries to the database::\n\n    @widget_handler(r'^article-details:(?P<art_id>\\d+)$')\n    def article_details(request, widgets):\n        articles = Article.objects.filter(\n            id__in=[w.params.art_id for w in widgets])\n        article_by_id = {art.id: art for art in articles}\n\n        response = {}\n        for widget in widgets:\n            article = article_by_id[int(widget.params.art_id)]\n            html = '<h1>article {}: {}</h1>'.format(article.id, article.title)\n            response[widget.wid] = {'html': html}\n        return response\n\n\nEvery `widget` object contains two attributes:\n\n* `wid` that holds the name of the widget, mached by regular expression which\n  view was decorated with\n* `params` holding zero or more parameters extracted from decorator's regular\n  expression\n\n\nHTML attributes\n~~~~~~~~~~~~~~~\n\nWhenever you want to use a widget, add `dw` attribute to an element. Those can\nbe:\n\n* `dw-load` for widgets that should be loaded once the document is ready,\n* `dw-click` for widgets that should be loaded on `click` event,\n* `dw-hover` for widgets that should be loaded on `mouseover` event.\n\nUsing them can be as simple as::\n\n    <div class=\"header\">\n        <span class=\"userinfo\" dw-load=\"user-name\"></span>\n    </div>\n    <div class=\"content\">\n        <span class=\"article\" dw-click=\"article:1\">click to show article<span>\n        <span class=\"article\" dw-hover=\"article:2\">hover to show article<span>\n    </div>\n\nIn addition, you can add `dw-once` attribute, to make sure widget content will\nbe fetched only once::\n\n        <span class=\"article\" dw-hover=\"article:2\" dw-once>hover to show article<span>\n\nBut simple replacing of the content might not be enough. That's why full\nformat of the attribute value can be build using multiple chunks, separated by\ncomma character::\n\n    dw-<action>=\"<widget name>,<insert method>,<destination selector>\"\n\n* `<widget name>` is used to match handler function. That's the only required\n  part of the value string,\n* `<insert method>` is any valid jQuery input method like `html`, `append`,\n  `prepend`. Default value is `html`,\n* `<destination selector>` is sizzle selector with one addition. Selector\n  starting with `@` character is always narrowed to element that `dw`\n  attribute was declarated. Default value is `@`.\n\nKnowing all above, it's easy to make dropdown menu with dynamic content load::\n\n\n    <style type=\"text/css\">\n        .dropdown-menu .menu-items       {display: none;}\n        .dropdown-menu:hover .menu-items {display: block;}\n    </style>\n\n    <div class=\"dropdown-menu\" dw-hover=\"article-attributes:3,html,@.menu-items\" dw-once>\n        Menu\n        <span class=\"menu-items\">\n            Loading...\n        </span>\n    </div>", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/husio/django-dynamicwidgets/", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "django-dynamicwidgets", "package_url": "https://pypi.org/project/django-dynamicwidgets/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-dynamicwidgets/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/husio/django-dynamicwidgets/"}, "release_url": "https://pypi.org/project/django-dynamicwidgets/1.0/", "requires_dist": null, "requires_python": null, "summary": "UNKNOWN", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Django dynamic widgets is a library that allow you to define HTML and expose\nchunks, that will be load on page using XHR request.</p>\n<p>There are few reasons why would you want to do this. The most obvious are:</p>\n<ul>\n<li>caching the whole page while still displaying <em>hello **username*</em> * in the\ntop right corner,</li>\n<li>load content only on certain actions - user clicked or hovered on certain\nelement</li>\n</ul>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Make sure that <cite>django.contrib.staticfiles</cite> is set up properly and add\n<cite>dynamicwidgets</cite> to your <cite>INSTALLED_APPS</cite> setting:</p>\n<pre>INSTALLED_APPS = (\n    # ...\n    'django.contrib.staticfiles',\n    # ...\n    'dynamicwidgets',\n)\n</pre>\n<div id=\"url-configuration\">\n<h3>URL configuration</h3>\n<p>To autodiscover your widget routing, you have to import all your handlers.\nThis can be done using <cite>dynamicwidgets.handlers.default.autodiscover()</cite>. After\nthat, you have to place handler view somewhere in the urls tree. Good place\nmight be applications <cite>urls.py</cite> file:</p>\n<pre>from dynamicwidgets import handlers\n\nhandlers.default.autodiscover()\n\nurlpatterns = patterns('',\n    # ...\n    url(r'^dynamicwidget/', include('dynamicwidgets.urls')),\n)\n</pre>\n</div>\n<div id=\"javascript-setup\">\n<h3>Javascript setup</h3>\n<p>Dynamic widgets library is using javascript to dynamicly load HTML chunks and\ndepends on jQuery.</p>\n<p>On page that you will use dynamic widges, include both jQuery and dynamic\nwidges libraries:</p>\n<pre>{# include jQuery #}\n&lt;script src=\"{% static \"dynamicwidgets/js/dynamicwidget.js\" %}\" type=\"text/javascript\"&gt;&lt;/script&gt;\n</pre>\n<p>In addition, <strong>before</strong> including above libraries, preferably in <cite>&lt;head&gt;</cite> tag,\nspecify path to widgets view:</p>\n<pre>&lt;script type=\"text/javascript\"&gt;window.DYNAMIC_WIDGETS_URL = '{% url \"dynamicwidgets.widgets\" %}';&lt;/script&gt;\n</pre>\n</div>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>To use a widget, you have to define handler that will build and return a\ncontent and a tag in the HTML document that content will be load into.</p>\n<div id=\"widget-handler\">\n<h3>Widget handler</h3>\n<p>Widget handler is a function that always takes two parameters - <cite>request</cite> and\na list of <cite>widgets</cite>. To define a handler, decorate it with\n<cite>dynamicwidgets.decorators.widget_handler</cite>:</p>\n<pre>from articles.models import Article\nfrom dynamicwidgets.decorators import widget_handler\n\n\n@widget_handler(r'^user-name$')\ndef user_name(request, widgets):\n    if request.user.is_anonymous():\n        return {'user-name': {'html': 'anonymous'}}\n    return {'user-name': {'html': request.user.username}}\n</pre>\n<p>Every handler should return a dictionary, where keys are widget names and\nvalues are dictionaries. If value dictionary contains <cite>html</cite> key, it\u2019s value\nwill be rendered on page as widget content.</p>\n<p>For performance reasons, all widget matches are aggregated and within single\nrequest and every widget handler is called not more than once. Because of\nthat, you can save some queries to the database:</p>\n<pre>@widget_handler(r'^article-details:(?P&lt;art_id&gt;\\d+)$')\ndef article_details(request, widgets):\n    articles = Article.objects.filter(\n        id__in=[w.params.art_id for w in widgets])\n    article_by_id = {art.id: art for art in articles}\n\n    response = {}\n    for widget in widgets:\n        article = article_by_id[int(widget.params.art_id)]\n        html = '&lt;h1&gt;article {}: {}&lt;/h1&gt;'.format(article.id, article.title)\n        response[widget.wid] = {'html': html}\n    return response\n</pre>\n<p>Every <cite>widget</cite> object contains two attributes:</p>\n<ul>\n<li><cite>wid</cite> that holds the name of the widget, mached by regular expression which\nview was decorated with</li>\n<li><cite>params</cite> holding zero or more parameters extracted from decorator\u2019s regular\nexpression</li>\n</ul>\n</div>\n<div id=\"html-attributes\">\n<h3>HTML attributes</h3>\n<p>Whenever you want to use a widget, add <cite>dw</cite> attribute to an element. Those can\nbe:</p>\n<ul>\n<li><cite>dw-load</cite> for widgets that should be loaded once the document is ready,</li>\n<li><cite>dw-click</cite> for widgets that should be loaded on <cite>click</cite> event,</li>\n<li><cite>dw-hover</cite> for widgets that should be loaded on <cite>mouseover</cite> event.</li>\n</ul>\n<p>Using them can be as simple as:</p>\n<pre>&lt;div class=\"header\"&gt;\n    &lt;span class=\"userinfo\" dw-load=\"user-name\"&gt;&lt;/span&gt;\n&lt;/div&gt;\n&lt;div class=\"content\"&gt;\n    &lt;span class=\"article\" dw-click=\"article:1\"&gt;click to show article&lt;span&gt;\n    &lt;span class=\"article\" dw-hover=\"article:2\"&gt;hover to show article&lt;span&gt;\n&lt;/div&gt;\n</pre>\n<p>In addition, you can add <cite>dw-once</cite> attribute, to make sure widget content will\nbe fetched only once:</p>\n<pre>&lt;span class=\"article\" dw-hover=\"article:2\" dw-once&gt;hover to show article&lt;span&gt;\n</pre>\n<p>But simple replacing of the content might not be enough. That\u2019s why full\nformat of the attribute value can be build using multiple chunks, separated by\ncomma character:</p>\n<pre>dw-&lt;action&gt;=\"&lt;widget name&gt;,&lt;insert method&gt;,&lt;destination selector&gt;\"\n</pre>\n<ul>\n<li><cite>&lt;widget name&gt;</cite> is used to match handler function. That\u2019s the only required\npart of the value string,</li>\n<li><cite>&lt;insert method&gt;</cite> is any valid jQuery input method like <cite>html</cite>, <cite>append</cite>,\n<cite>prepend</cite>. Default value is <cite>html</cite>,</li>\n<li><cite>&lt;destination selector&gt;</cite> is sizzle selector with one addition. Selector\nstarting with <cite>@</cite> character is always narrowed to element that <cite>dw</cite>\nattribute was declarated. Default value is <cite>@</cite>.</li>\n</ul>\n<p>Knowing all above, it\u2019s easy to make dropdown menu with dynamic content load:</p>\n<pre>&lt;style type=\"text/css\"&gt;\n    .dropdown-menu .menu-items       {display: none;}\n    .dropdown-menu:hover .menu-items {display: block;}\n&lt;/style&gt;\n\n&lt;div class=\"dropdown-menu\" dw-hover=\"article-attributes:3,html,@.menu-items\" dw-once&gt;\n    Menu\n    &lt;span class=\"menu-items\"&gt;\n        Loading...\n    &lt;/span&gt;\n&lt;/div&gt;\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 931360, "releases": {"1.0": []}, "urls": [], "timestamp": "Fri May  8 00:36:28 2020"}