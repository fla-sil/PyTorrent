{"info": {"author": "Zach Banks", "author_email": "zbanks@mit.edu", "bugtrack_url": null, "classifiers": [], "description": "#doitlive\r\n=========\r\n\r\n#doitlive - Tools for livecoding performances in Python.\r\n\r\n#doitlive allows you to \"refresh\" a class by reloading the source in an\r\n*almost*-sane and *almost*-safe way. It also provides facilities for\r\ncatching and handling common errors that come up with livecoding, such\r\nas undeclared variables.\r\n\r\nIt works under the philosophy that it's better to have weird behavior\r\nthan to crash.\r\n\r\nBesides livecoding, it can also be used as a tool for debugging or\r\nexperimenting -- you can tweak algorithms as they run.\r\n\r\nProjects\r\n--------\r\n\r\n-  https://github.com/zbanks/beetle\r\n-  https://github.com/ervanalb/beat-off/tree/live\r\n-  https://github.com/zbanks/aurora\r\n-  https://github.com/zbanks/peebles\r\n-  https://github.com/ervanalb/noise\r\n\r\nInstallation\r\n------------\r\n\r\nInstall from pip:\r\n\r\n::\r\n\r\n    pip install refreshable\r\n\r\nOr install the latest *(ha!)* from git:\r\n\r\n::\r\n\r\n    git clone https://github.com/zbanks/doitlive.git\r\n    cd doitlive\r\n    python setup.py install\r\n\r\nrefreshable.SafeRefreshableMixin\r\n--------------------------------\r\n\r\nProvides a ``.refresh()`` method to reload a class\r\n\r\nAdding the ``SafeRefreshMixin`` to a class allows you to \"refresh\" the\r\nclass using the ``.refresh()`` method. This method reloads the python\r\nfile the class came from and replaces all methods and *class* variables\r\n(*not* instance variables!) with the versions from the new file.\r\n\r\nThe refresh is \"safe\" because it tries very hard to keep the program\r\nrunning. On each refresh, a snapshot of the class is saved to form a\r\nhistory. If an error is encountered while performing the refresh, the\r\nstate is reverted.\r\n\r\nIn general, you can wrap calls to methods of your refreshed class in a\r\ntry block that catches all errors and call ``.revert()`` on failure.\r\n\r\nAdditionally, ``DEFAULTS`` and ``AUTO_NONE`` provide options for\r\nhandling missing attributes (preventing ``AttributeError``\\ s).\r\n\r\nUsage\r\n~~~~~\r\n\r\nYou can configure the behavior by setting the following class variables:\r\n\r\n-  ``STATICS`` : List of variable names (strings) that are not\r\n   refreshed.\r\n-  ``DEFAULTS`` : Dictionary of variable names -> values. If an\r\n   ``AttributeError`` is caught, and the attribute is in ``DEFAULTS``,\r\n   the attribute is populated from the dictionary. This can be useful if\r\n   you need to initialize a new state variable.\r\n-  ``AUTO_NONE``: If ``True``, catch ``AttributeErrors`` and set the\r\n   attribute to ``None`` if the attribute is not in ``DEFAULTS``.\r\n\r\nAdditionally, there are the ``.pre_refresh()`` and ``.post_refresh()``\r\nhooks which can be overridden.\r\n\r\nOnce initialized, instances have the following methods:\r\n\r\n-  ``.init_defaults()``: Initialize attributes from the ``DEFAULTS``\r\n   dict.\r\n-  ``.refresh()`` : Attempt to reload the class from disk.\r\n-  ``.revert()`` : Revert the changes from the previous ``.refresh()``.\r\n-  ``.purge()`` : Remove the state history. Each call to ``.refresh()``\r\n   takes a snapshot of the class. If you refresh often w/ a big class,\r\n   this can get large.\r\n\r\nLimitations\r\n~~~~~~~~~~~\r\n\r\n-  ``.refresh()`` assumes all methods are bound (take a ``self``\r\n   parameter). As a result, static/class methods (methods declared with\r\n   ``@staticmethod``, or ``@classmethod``) will not be refreshed\r\n   properly. These method names should be added to ``STATICS`` and they\r\n   will not be refreshed.\r\n\r\n-  This framework was designed around the singleton model with one\r\n   instance of the given refreshed class. It hasn't been extensively\r\n   tested with multiple instances, and may cause weird behavior around\r\n   class variables.\r\n\r\n-  The ``__main__`` module cannot be reloaded, so the class must exist\r\n   in an imported module.\r\n\r\nrefreshable.SafeRefreshableLoop\r\n-------------------------------\r\n\r\nRun a function in a loop while making the parent class refreshable.\r\n\r\nThe function ``.step()`` is called repeatedly while the loop is running.\r\nYou can start the loop in one of two ways:\r\n\r\n-  ``.start()``: Run the loop in a thread.\r\n-  ``.run()`` : (the target of the thread) Run the loop \"inline\".\r\n\r\nThe loop can also be paused with ``.stop()`` and unpaused with\r\n``.restart()``.\r\n\r\nIf you subclass, make sure you call ``threading.Thread.__init__``\r\n\r\nAs with the SafeRefreshMixin, you can set the following class variables:\r\n\r\n-  ``STATICS`` : List of variable names (strings) that are not\r\n   refreshed.\r\n-  ``DEFAULTS`` : Dictionary of variable names -> values. If an\r\n   ``AttributeError`` is caught, and the attribute is in ``DEFAULTS``,\r\n   the attribute is populated from the dictionary. This can be useful if\r\n   you need to initialize a new state variable.\r\n-  ``AUTO_NONE``: If ``True``, catch ``AttributeErrors`` and set the\r\n   attribute to ``None`` if the attribute is not in ``DEFAULTS``.\r\n\r\nAnd call the following methods:\r\n\r\n-  ``.refresh()``: Attempt to reload the class from disk.\r\n-  ``.revert()`` : Revert the changes from the previous ``.refresh()``.\r\n-  ``.purge()`` : Remove the state history. Each call to ``.refresh()``\r\n   takes a snapshot of the class. If you refresh often w/ a big class,\r\n   this can get large.\r\n\r\nAdditionally, there are the ``.pre_refresh()`` and ``.post_refresh()``\r\nhooks which can be overridden.\r\n\r\nTesting\r\n-------\r\n\r\n-  Test it out by running ``python run_test.py`` and modifying\r\n   ``test.py``.", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/zbanks/doitlive/tarball/1.0.2", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/zbanks/doitlive", "keywords": "", "license": "The MIT License (MIT)\r\n\r\nCopyright (c) 2014 Zach Banks\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\u23ce", "maintainer": "", "maintainer_email": "", "name": "refreshable", "package_url": "https://pypi.org/project/refreshable/", "platform": "", "project_url": "https://pypi.org/project/refreshable/", "project_urls": {"Download": "https://github.com/zbanks/doitlive/tarball/1.0.2", "Homepage": "https://github.com/zbanks/doitlive"}, "release_url": "https://pypi.org/project/refreshable/1.0.2/", "requires_dist": null, "requires_python": null, "summary": "Tools for livecoding performances", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>#doitlive - Tools for livecoding performances in Python.</p>\n<p>#doitlive allows you to \u201crefresh\u201d a class by reloading the source in an\n<em>almost</em>-sane and <em>almost</em>-safe way. It also provides facilities for\ncatching and handling common errors that come up with livecoding, such\nas undeclared variables.</p>\n<p>It works under the philosophy that it\u2019s better to have weird behavior\nthan to crash.</p>\n<p>Besides livecoding, it can also be used as a tool for debugging or\nexperimenting \u2013 you can tweak algorithms as they run.</p>\n<div id=\"projects\">\n<h2>Projects</h2>\n<ul>\n<li><a href=\"https://github.com/zbanks/beetle\" rel=\"nofollow\">https://github.com/zbanks/beetle</a></li>\n<li><a href=\"https://github.com/ervanalb/beat-off/tree/live\" rel=\"nofollow\">https://github.com/ervanalb/beat-off/tree/live</a></li>\n<li><a href=\"https://github.com/zbanks/aurora\" rel=\"nofollow\">https://github.com/zbanks/aurora</a></li>\n<li><a href=\"https://github.com/zbanks/peebles\" rel=\"nofollow\">https://github.com/zbanks/peebles</a></li>\n<li><a href=\"https://github.com/ervanalb/noise\" rel=\"nofollow\">https://github.com/ervanalb/noise</a></li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Install from pip:</p>\n<pre>pip install refreshable\n</pre>\n<p>Or install the latest <em>(ha!)</em> from git:</p>\n<pre>git clone https://github.com/zbanks/doitlive.git\ncd doitlive\npython setup.py install\n</pre>\n</div>\n<div id=\"refreshable-saferefreshablemixin\">\n<h2>refreshable.SafeRefreshableMixin</h2>\n<p>Provides a <tt>.refresh()</tt> method to reload a class</p>\n<p>Adding the <tt>SafeRefreshMixin</tt> to a class allows you to \u201crefresh\u201d the\nclass using the <tt>.refresh()</tt> method. This method reloads the python\nfile the class came from and replaces all methods and <em>class</em> variables\n(<em>not</em> instance variables!) with the versions from the new file.</p>\n<p>The refresh is \u201csafe\u201d because it tries very hard to keep the program\nrunning. On each refresh, a snapshot of the class is saved to form a\nhistory. If an error is encountered while performing the refresh, the\nstate is reverted.</p>\n<p>In general, you can wrap calls to methods of your refreshed class in a\ntry block that catches all errors and call <tt>.revert()</tt> on failure.</p>\n<p>Additionally, <tt>DEFAULTS</tt> and <tt>AUTO_NONE</tt> provide options for\nhandling missing attributes (preventing <tt>AttributeError</tt>s).</p>\n<div id=\"usage\">\n<h3>Usage</h3>\n<p>You can configure the behavior by setting the following class variables:</p>\n<ul>\n<li><tt>STATICS</tt> : List of variable names (strings) that are not\nrefreshed.</li>\n<li><tt>DEFAULTS</tt> : Dictionary of variable names -&gt; values. If an\n<tt>AttributeError</tt> is caught, and the attribute is in <tt>DEFAULTS</tt>,\nthe attribute is populated from the dictionary. This can be useful if\nyou need to initialize a new state variable.</li>\n<li><tt>AUTO_NONE</tt>: If <tt>True</tt>, catch <tt>AttributeErrors</tt> and set the\nattribute to <tt>None</tt> if the attribute is not in <tt>DEFAULTS</tt>.</li>\n</ul>\n<p>Additionally, there are the <tt>.pre_refresh()</tt> and <tt>.post_refresh()</tt>\nhooks which can be overridden.</p>\n<p>Once initialized, instances have the following methods:</p>\n<ul>\n<li><tt>.init_defaults()</tt>: Initialize attributes from the <tt>DEFAULTS</tt>\ndict.</li>\n<li><tt>.refresh()</tt> : Attempt to reload the class from disk.</li>\n<li><tt>.revert()</tt> : Revert the changes from the previous <tt>.refresh()</tt>.</li>\n<li><tt>.purge()</tt> : Remove the state history. Each call to <tt>.refresh()</tt>\ntakes a snapshot of the class. If you refresh often w/ a big class,\nthis can get large.</li>\n</ul>\n</div>\n<div id=\"limitations\">\n<h3>Limitations</h3>\n<ul>\n<li><tt>.refresh()</tt> assumes all methods are bound (take a <tt>self</tt>\nparameter). As a result, static/class methods (methods declared with\n<tt>@staticmethod</tt>, or <tt>@classmethod</tt>) will not be refreshed\nproperly. These method names should be added to <tt>STATICS</tt> and they\nwill not be refreshed.</li>\n<li>This framework was designed around the singleton model with one\ninstance of the given refreshed class. It hasn\u2019t been extensively\ntested with multiple instances, and may cause weird behavior around\nclass variables.</li>\n<li>The <tt>__main__</tt> module cannot be reloaded, so the class must exist\nin an imported module.</li>\n</ul>\n</div>\n</div>\n<div id=\"refreshable-saferefreshableloop\">\n<h2>refreshable.SafeRefreshableLoop</h2>\n<p>Run a function in a loop while making the parent class refreshable.</p>\n<p>The function <tt>.step()</tt> is called repeatedly while the loop is running.\nYou can start the loop in one of two ways:</p>\n<ul>\n<li><tt>.start()</tt>: Run the loop in a thread.</li>\n<li><tt>.run()</tt> : (the target of the thread) Run the loop \u201cinline\u201d.</li>\n</ul>\n<p>The loop can also be paused with <tt>.stop()</tt> and unpaused with\n<tt>.restart()</tt>.</p>\n<p>If you subclass, make sure you call <tt>threading.Thread.__init__</tt></p>\n<p>As with the SafeRefreshMixin, you can set the following class variables:</p>\n<ul>\n<li><tt>STATICS</tt> : List of variable names (strings) that are not\nrefreshed.</li>\n<li><tt>DEFAULTS</tt> : Dictionary of variable names -&gt; values. If an\n<tt>AttributeError</tt> is caught, and the attribute is in <tt>DEFAULTS</tt>,\nthe attribute is populated from the dictionary. This can be useful if\nyou need to initialize a new state variable.</li>\n<li><tt>AUTO_NONE</tt>: If <tt>True</tt>, catch <tt>AttributeErrors</tt> and set the\nattribute to <tt>None</tt> if the attribute is not in <tt>DEFAULTS</tt>.</li>\n</ul>\n<p>And call the following methods:</p>\n<ul>\n<li><tt>.refresh()</tt>: Attempt to reload the class from disk.</li>\n<li><tt>.revert()</tt> : Revert the changes from the previous <tt>.refresh()</tt>.</li>\n<li><tt>.purge()</tt> : Remove the state history. Each call to <tt>.refresh()</tt>\ntakes a snapshot of the class. If you refresh often w/ a big class,\nthis can get large.</li>\n</ul>\n<p>Additionally, there are the <tt>.pre_refresh()</tt> and <tt>.post_refresh()</tt>\nhooks which can be overridden.</p>\n</div>\n<div id=\"testing\">\n<h2>Testing</h2>\n<ul>\n<li>Test it out by running <tt>python run_test.py</tt> and modifying\n<tt>test.py</tt>.</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 1568857, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "de0a2b2ae053b03fb307c48cb48b53d9", "sha256": "8c3c78a9a876086c19cf5f2bdce36d91894ad0eaf252592a6d31931ead2f1211"}, "downloads": -1, "filename": "refreshable-1.0.1.tar.gz", "has_sig": false, "md5_digest": "de0a2b2ae053b03fb307c48cb48b53d9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5501, "upload_time": "2015-05-28T19:58:44", "upload_time_iso_8601": "2015-05-28T19:58:44.465277Z", "url": "https://files.pythonhosted.org/packages/09/a6/52cd1c5366e45062e1a97db02c66e6ac8272c0e5b2a8a0f3e04dba922843/refreshable-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "cd252796ccac0afdd6f7456093c53c31", "sha256": "5e1f7fa52fdd12fe0385b72254a24c9840b95afebcb335990637390f4da69b7f"}, "downloads": -1, "filename": "refreshable-1.0.2.tar.gz", "has_sig": false, "md5_digest": "cd252796ccac0afdd6f7456093c53c31", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5571, "upload_time": "2015-05-30T08:50:51", "upload_time_iso_8601": "2015-05-30T08:50:51.878826Z", "url": "https://files.pythonhosted.org/packages/ce/30/3a4c4ff1de2817ddbac528cffb54d9003e4dae5da225ce6f2463d265b4b5/refreshable-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "cd252796ccac0afdd6f7456093c53c31", "sha256": "5e1f7fa52fdd12fe0385b72254a24c9840b95afebcb335990637390f4da69b7f"}, "downloads": -1, "filename": "refreshable-1.0.2.tar.gz", "has_sig": false, "md5_digest": "cd252796ccac0afdd6f7456093c53c31", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5571, "upload_time": "2015-05-30T08:50:51", "upload_time_iso_8601": "2015-05-30T08:50:51.878826Z", "url": "https://files.pythonhosted.org/packages/ce/30/3a4c4ff1de2817ddbac528cffb54d9003e4dae5da225ce6f2463d265b4b5/refreshable-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:22 2020"}