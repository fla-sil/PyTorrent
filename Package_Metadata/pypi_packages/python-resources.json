{"info": {"author": "Roman Imankulov", "author_email": "roman.imankulov@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "Resources. A fixture lifecycle management for your tests\n========================================================\n\n.. image:: https://secure.travis-ci.org/Doist/resources.png?branch=master\n   :alt: Build Status\n   :target: https://secure.travis-ci.org/Doist/resources\n\nWhy do we need this library\n--------------------------------------------------\n\nWe are not satisfied with classical xUnit way of setup and teardown. We prefer\nconcise approach of py.test over the verbosity of standard unittest.\n\nWe found ourselves copying and pasting the same boilerplate code from one test\nto another or creating extensive structure of test class hierarchy.\n\npy.test fixtures, injected in test functions as parameter names, is\ndifferent approach for fixture management. It's neither worse nor better,\nbut we found it to be not as flexible as we need.\n\nSome questions, that we wanted to solve often, looked like:\n\n- I have a py.test fixture which creates a new user with default set of\n  properties. Is there a way I can create a user with different name by the same\n  fixture?\n- Is there a way to create two users in one test case with the same fixture?\n- Is there an easy recipe to create a user first, and then, say, a todo item for\n  this particular user in another, separate, fixture?\n\nSure enough, we can handle or work around all these issues somehow with xUnit\nsetups and teardowns or py.test fixtures, but we wanted something more flexible,\neasy and convenient to use. That's why we created ``resources`` library.\n\n\nHow do we use it\n----------------\n\nFirst, we define functions which we call \"resource makers\". These makers are\nresponsible for creating and destroying resources. It's like setup and teardown\nin one callable.\n\n.. code-block:: python\n\n    from resources import resources\n\n    @resources.register_func\n    def user(email='joe@example.com', password='password', username='Joe'):\n        user = User.objects.create(email=email, password=password, username=username)\n        try:\n            yield user\n        finally:\n            user.delete()\n\nThe flow is simple: we create, we yield, we destroy.\n\nWe get a number of resource makers, and we group them into modules, like\n`tests/resources_core.py`, `tests/resources_users.py`, etc.\n\nThen, in a test file, where we plan to use resources, we import the same global\nobject, load resource modules we need, and activate them in tests.\n\n.. code-block:: python\n\n    from resources import resources\n    resources.register_mod('tests.resources_core')\n    resources.register_mod('tests.resources_users')\n\n    def test_user_properties():\n        with resources.user_ctx() as user:\n            assert user.username == 'Joe'\n\nThis is where a little bit of magic happens. Once you define and register the\nresource maker with name ``foo``, a context manager ``foo_ctx`` is created for\nyour convenience. This context manager creates a new resource instance with the\ncorresponding maker function, and destroys the object the way you defined, once\nthe code flow abandons a wrapping \"with\"-context.\n\nWhen it shines\n---------------\n\nAt this point and maybe not so exciting. Yeah, everyone can write the code like\nthis,  the difference is that we actually *did it* :-). We also have a bunch\nof nifty features making the whole stuff more interesting.\n\nFeature 1. Customizeable resources\n----------------------------------\n\nContexts are better than py.test fixtures, because they are customizeable.\nProvide everything you need to context manager, and it will be passed to\nresource maker function as an arguments.\n\n.. code-block:: python\n\n    def test_user_properties():\n        with resources.user_ctx(name='Mary') as user:\n            assert user.username == 'Mary'\n\n\nFeature 2. Global object scope and dependent resources\n------------------------------------------------------\n\nWe need to have access to resources at different stages of our tests: to get\naccess to object's properties and methods, to initiate another, dependent\nfixture instance, and finally to tear down everything.\n\nAs soon as you enter the context with ``resources.foo_ctx()`` a variable\n``resources.foo`` will be created and will be available from everywhere,\nincluding your test function, and other resource makers.\n\nThe latter fact is especially important, because it's the way we manage\ndependent resources. Yet we need some conventions, which resource is created\nfirst, and so on.\n\n.. code-block:: python\n\n    @resources.register_func\n    def todo_item(content='Foo'):\n        item = TodoItem.objects.create(user=resources.user, content=content)\n\nWe agreed that we create user resource first, and todo item afterwards, and\ncreated a new resource maker, taking advantage of this convention.\n\nWe use it like this:\n\n.. code-block:: python\n\n    def test_todo_item_properties():\n        with resources.user_ctx(), resources.todo_item_ctx():\n            assert resources.todo_item.content == 'Foo'\n\nBy the way, if you are still stuck with python2.6, several context managers in\nthe same \"with\" expression aren't available for you yet. Use ``contextlib.nested``\nto avoid deep indentation.\n\n\nFeature 3. Several resources of the same class, and tuneable resource names\n---------------------------------------------------------------------------\n\nSometimes we need to create a couple of resources of the same type, instead of\njust one instance. It's not a problem, if you don't want to use global\nnamespace to get access to them. Otherwise you must create a unique identifier\nfor every resource.\n\nActually, it's trivial. All you should do is provide a special `_name` attribute\nto context manager constructor. This attribute won't be passed to your resource\nmaker function.\n\n.. code-block:: python\n\n    def test_a_couple_of_users():\n        with resources.user_ctx(username='Adam', _name='adam'), \\\n             resurces.user_ctx(username='Eve', _name='eve'):\n            assert resources.adam.username == 'Adam'\n            assert resources.eve.username == 'Eve'\n\n\nFeature 4. Function decorators\n------------------------------\n\nContext manager can work as a decorator too. When we use it like this, an extra\nargument will be passed to the function.\n\n.. code-block:: python\n\n    @resources.user_ctx()\n    def test_user_properties(user):\n        assert user.username == 'Joe'\n\nWe should say that usually it works, but to make it work along with py.test\nwhich performs deep introspection of function signatures, we made in with some\n\"dirty hacks\" inside, and you may find out that in some cases the chain of\ndecorators dies with a misleading exception. We'd recommend to use context\nmanagers instead of decorators, wherever possible.\n\nFeature 5. Resource managers\n----------------------------\n\nYes, we do use setup and teardown methods too. If every function in your test\nsuite uses the same set of resources, it would be counterproductive to write\nthe same chain of decorators or context managers over and over again.\n\nIn this case we use another concept: resource managers. Every resource maker\n``foo`` creates the ``resources.foo_mgr`` instance, having `start` and\n`stop` methods. The `start` method accepts all arguments which\nthe `foo_ctx` function does, including special `_name` argument.\nThe `stop` method has only one optional `_name` argument, and is used to\ndestroy previously created instance.\n\nHere is a py.test example\n\n.. code-block:: python\n\n    def setup_function(func):\n        resources.user_mgr.start(username='Mary')\n\n    def test_user_properties():\n        assert resources.user.username == 'Mary'\n\n    def teardown_function(func):\n        resources.user_mgr.stop()\n\n\nFeature 6. Built-in console and debugger\n----------------------------------------\n\nSometimes it's nice to take a look on what's going on within test function and\nget access at some point to python console or debugger.\n\nUsually you probably do something like\n\n.. code-block:: python\n\n    import pdb; pdb.set_trace()\n\nOr, if you need to get shell and have IPython installed\n\n.. code-block:: python\n\n    from IPython import embed; embed()\n\nAs it happens often, we added to resources two functions, launching either\ndebugger or python console inside your test function.\n\n.. code-block:: python\n\n    from resources import resources\n\n    def test_something():\n        resources.pdb()    # to launch debugger\n        resources.shell()  # to launch Python REPL\n\nIf you install IPython and ipdb (`pip install IPython ipdb`), you get more\nfriendly versions of consoles, otherwise resources fall back to built-in python\nconsole and debugger.\n\nLaunch `py.test` with `-s` switch to be able to fall into interactive console.\n\nIt's especially cool that resources object is autocomplete-friendly and it\nworks well in IPython\n\n.. code-block:: python\n\n\n    In [1]: resources.\n    resources.john            resources.pdb             resources.register_mod\n    resources.mary            resources.register_func   resources.shell\n\n    In [1]: resources.mary\n    Out[1]: {'name': 'Mary Moe'}\n\n    In [2]: resources.user_mgr.start()\n    Out[2]: {'name': 'John Doe'}\n\n    In [3]: resources.todo\n    resources.todo_item_ctx  resources.todo_item_mgr\n\n    In [3]: resources.todo_item_mgr.start()\n    Out[3]: {'text': 'Do something', 'user': {'name': 'John Doe'}}\n\n    In [4]: resources.todo\n    resources.todo_item      resources.todo_item_ctx  resources.todo_item_mgr\n\n    In [4]: resources.todo_item\n    Out[4]: {'text': 'Do something', 'user': {'name': 'John Doe'}}\n\n\n\nFeature 7. Globally accessible storage of constants\n---------------------------------------------------\n\nThis feature is not something unique to `resources` module. Pretty much every\nobject can act this way, but it is handy to have a convention about the\nway you store your test-related constants.\n\nIt may work like this.\n\n.. code-block::\n\n    resources.TEST_DIRECTORY = '/tmp/foo'\n    resources.DOMAIN_NAME = 'example.com'\n    resources.SECRET_KEY = 'foobar'\n\nAnd then, in the test file.\n\n.. code-block::\n\n    from resources import resources\n    resoures.register_mod('<a resource module name here>')\n\n    def test_constants():\n        assert resources.TEST_DIRECTORY == '/tmp/foo'\n        assert resources.DOMAIN_NAME == 'example.com'\n        assert resources.SECRET_KEY == 'foobar'\n\n\nConclusion\n----------\n\nThe `resources` library works for us in py.test environment. We don't see any\nreasons why it shouldn't work the same way with nose or classic unitttests.\nIt works for python versions 2.6, 2.7 and 3.3.\n\nPlease bear in mind that the library *is not thread safe*, as we are happy with\nsingle threaded tests at this time.\n\nAnd after all... Seven extra features to improve your test suites for free! What\nare you waiting for? It's already improved the quailty of our lives in\n`Doist Inc <http://doist.io>`_, and we do hope it will do the same for your\nprojects.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/doist/resources", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "python-resources", "package_url": "https://pypi.org/project/python-resources/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/python-resources/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/doist/resources"}, "release_url": "https://pypi.org/project/python-resources/0.3/", "requires_dist": null, "requires_python": null, "summary": "A fixture lifecycle management library for your tests", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://secure.travis-ci.org/Doist/resources\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5d8257e81c961a65129ea3d9dfa23e8c50c3e2d7/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f446f6973742f7265736f75726365732e706e673f6272616e63683d6d6173746572\"></a>\n<div id=\"why-do-we-need-this-library\">\n<h2>Why do we need this library</h2>\n<p>We are not satisfied with classical xUnit way of setup and teardown. We prefer\nconcise approach of py.test over the verbosity of standard unittest.</p>\n<p>We found ourselves copying and pasting the same boilerplate code from one test\nto another or creating extensive structure of test class hierarchy.</p>\n<p>py.test fixtures, injected in test functions as parameter names, is\ndifferent approach for fixture management. It\u2019s neither worse nor better,\nbut we found it to be not as flexible as we need.</p>\n<p>Some questions, that we wanted to solve often, looked like:</p>\n<ul>\n<li>I have a py.test fixture which creates a new user with default set of\nproperties. Is there a way I can create a user with different name by the same\nfixture?</li>\n<li>Is there a way to create two users in one test case with the same fixture?</li>\n<li>Is there an easy recipe to create a user first, and then, say, a todo item for\nthis particular user in another, separate, fixture?</li>\n</ul>\n<p>Sure enough, we can handle or work around all these issues somehow with xUnit\nsetups and teardowns or py.test fixtures, but we wanted something more flexible,\neasy and convenient to use. That\u2019s why we created <tt>resources</tt> library.</p>\n</div>\n<div id=\"how-do-we-use-it\">\n<h2>How do we use it</h2>\n<p>First, we define functions which we call \u201cresource makers\u201d. These makers are\nresponsible for creating and destroying resources. It\u2019s like setup and teardown\nin one callable.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">resources</span> <span class=\"kn\">import</span> <span class=\"n\">resources</span>\n\n<span class=\"nd\">@resources</span><span class=\"o\">.</span><span class=\"n\">register_func</span>\n<span class=\"k\">def</span> <span class=\"nf\">user</span><span class=\"p\">(</span><span class=\"n\">email</span><span class=\"o\">=</span><span class=\"s1\">'joe@example.com'</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s1\">'password'</span><span class=\"p\">,</span> <span class=\"n\">username</span><span class=\"o\">=</span><span class=\"s1\">'Joe'</span><span class=\"p\">):</span>\n    <span class=\"n\">user</span> <span class=\"o\">=</span> <span class=\"n\">User</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">email</span><span class=\"o\">=</span><span class=\"n\">email</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"n\">password</span><span class=\"p\">,</span> <span class=\"n\">username</span><span class=\"o\">=</span><span class=\"n\">username</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"k\">yield</span> <span class=\"n\">user</span>\n    <span class=\"k\">finally</span><span class=\"p\">:</span>\n        <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">delete</span><span class=\"p\">()</span>\n</pre>\n<p>The flow is simple: we create, we yield, we destroy.</p>\n<p>We get a number of resource makers, and we group them into modules, like\n<cite>tests/resources_core.py</cite>, <cite>tests/resources_users.py</cite>, etc.</p>\n<p>Then, in a test file, where we plan to use resources, we import the same global\nobject, load resource modules we need, and activate them in tests.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">resources</span> <span class=\"kn\">import</span> <span class=\"n\">resources</span>\n<span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">register_mod</span><span class=\"p\">(</span><span class=\"s1\">'tests.resources_core'</span><span class=\"p\">)</span>\n<span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">register_mod</span><span class=\"p\">(</span><span class=\"s1\">'tests.resources_users'</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_user_properties</span><span class=\"p\">():</span>\n    <span class=\"k\">with</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user_ctx</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">user</span><span class=\"p\">:</span>\n        <span class=\"k\">assert</span> <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">username</span> <span class=\"o\">==</span> <span class=\"s1\">'Joe'</span>\n</pre>\n<p>This is where a little bit of magic happens. Once you define and register the\nresource maker with name <tt>foo</tt>, a context manager <tt>foo_ctx</tt> is created for\nyour convenience. This context manager creates a new resource instance with the\ncorresponding maker function, and destroys the object the way you defined, once\nthe code flow abandons a wrapping \u201cwith\u201d-context.</p>\n</div>\n<div id=\"when-it-shines\">\n<h2>When it shines</h2>\n<p>At this point and maybe not so exciting. Yeah, everyone can write the code like\nthis,  the difference is that we actually <em>did it</em> :-). We also have a bunch\nof nifty features making the whole stuff more interesting.</p>\n</div>\n<div id=\"feature-1-customizeable-resources\">\n<h2>Feature 1. Customizeable resources</h2>\n<p>Contexts are better than py.test fixtures, because they are customizeable.\nProvide everything you need to context manager, and it will be passed to\nresource maker function as an arguments.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_user_properties</span><span class=\"p\">():</span>\n    <span class=\"k\">with</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user_ctx</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'Mary'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">user</span><span class=\"p\">:</span>\n        <span class=\"k\">assert</span> <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">username</span> <span class=\"o\">==</span> <span class=\"s1\">'Mary'</span>\n</pre>\n</div>\n<div id=\"feature-2-global-object-scope-and-dependent-resources\">\n<h2>Feature 2. Global object scope and dependent resources</h2>\n<p>We need to have access to resources at different stages of our tests: to get\naccess to object\u2019s properties and methods, to initiate another, dependent\nfixture instance, and finally to tear down everything.</p>\n<p>As soon as you enter the context with <tt>resources.foo_ctx()</tt> a variable\n<tt>resources.foo</tt> will be created and will be available from everywhere,\nincluding your test function, and other resource makers.</p>\n<p>The latter fact is especially important, because it\u2019s the way we manage\ndependent resources. Yet we need some conventions, which resource is created\nfirst, and so on.</p>\n<pre><span class=\"nd\">@resources</span><span class=\"o\">.</span><span class=\"n\">register_func</span>\n<span class=\"k\">def</span> <span class=\"nf\">todo_item</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"o\">=</span><span class=\"s1\">'Foo'</span><span class=\"p\">):</span>\n    <span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"n\">TodoItem</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"o\">=</span><span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"n\">content</span><span class=\"o\">=</span><span class=\"n\">content</span><span class=\"p\">)</span>\n</pre>\n<p>We agreed that we create user resource first, and todo item afterwards, and\ncreated a new resource maker, taking advantage of this convention.</p>\n<p>We use it like this:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_todo_item_properties</span><span class=\"p\">():</span>\n    <span class=\"k\">with</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user_ctx</span><span class=\"p\">(),</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item_ctx</span><span class=\"p\">():</span>\n        <span class=\"k\">assert</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item</span><span class=\"o\">.</span><span class=\"n\">content</span> <span class=\"o\">==</span> <span class=\"s1\">'Foo'</span>\n</pre>\n<p>By the way, if you are still stuck with python2.6, several context managers in\nthe same \u201cwith\u201d expression aren\u2019t available for you yet. Use <tt>contextlib.nested</tt>\nto avoid deep indentation.</p>\n</div>\n<div id=\"feature-3-several-resources-of-the-same-class-and-tuneable-resource-names\">\n<h2>Feature 3. Several resources of the same class, and tuneable resource names</h2>\n<p>Sometimes we need to create a couple of resources of the same type, instead of\njust one instance. It\u2019s not a problem, if you don\u2019t want to use global\nnamespace to get access to them. Otherwise you must create a unique identifier\nfor every resource.</p>\n<p>Actually, it\u2019s trivial. All you should do is provide a special <cite>_name</cite> attribute\nto context manager constructor. This attribute won\u2019t be passed to your resource\nmaker function.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_a_couple_of_users</span><span class=\"p\">():</span>\n    <span class=\"k\">with</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user_ctx</span><span class=\"p\">(</span><span class=\"n\">username</span><span class=\"o\">=</span><span class=\"s1\">'Adam'</span><span class=\"p\">,</span> <span class=\"n\">_name</span><span class=\"o\">=</span><span class=\"s1\">'adam'</span><span class=\"p\">),</span> \\\n         <span class=\"n\">resurces</span><span class=\"o\">.</span><span class=\"n\">user_ctx</span><span class=\"p\">(</span><span class=\"n\">username</span><span class=\"o\">=</span><span class=\"s1\">'Eve'</span><span class=\"p\">,</span> <span class=\"n\">_name</span><span class=\"o\">=</span><span class=\"s1\">'eve'</span><span class=\"p\">):</span>\n        <span class=\"k\">assert</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">adam</span><span class=\"o\">.</span><span class=\"n\">username</span> <span class=\"o\">==</span> <span class=\"s1\">'Adam'</span>\n        <span class=\"k\">assert</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">eve</span><span class=\"o\">.</span><span class=\"n\">username</span> <span class=\"o\">==</span> <span class=\"s1\">'Eve'</span>\n</pre>\n</div>\n<div id=\"feature-4-function-decorators\">\n<h2>Feature 4. Function decorators</h2>\n<p>Context manager can work as a decorator too. When we use it like this, an extra\nargument will be passed to the function.</p>\n<pre><span class=\"nd\">@resources</span><span class=\"o\">.</span><span class=\"n\">user_ctx</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">test_user_properties</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">):</span>\n    <span class=\"k\">assert</span> <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">username</span> <span class=\"o\">==</span> <span class=\"s1\">'Joe'</span>\n</pre>\n<p>We should say that usually it works, but to make it work along with py.test\nwhich performs deep introspection of function signatures, we made in with some\n\u201cdirty hacks\u201d inside, and you may find out that in some cases the chain of\ndecorators dies with a misleading exception. We\u2019d recommend to use context\nmanagers instead of decorators, wherever possible.</p>\n</div>\n<div id=\"feature-5-resource-managers\">\n<h2>Feature 5. Resource managers</h2>\n<p>Yes, we do use setup and teardown methods too. If every function in your test\nsuite uses the same set of resources, it would be counterproductive to write\nthe same chain of decorators or context managers over and over again.</p>\n<p>In this case we use another concept: resource managers. Every resource maker\n<tt>foo</tt> creates the <tt>resources.foo_mgr</tt> instance, having <cite>start</cite> and\n<cite>stop</cite> methods. The <cite>start</cite> method accepts all arguments which\nthe <cite>foo_ctx</cite> function does, including special <cite>_name</cite> argument.\nThe <cite>stop</cite> method has only one optional <cite>_name</cite> argument, and is used to\ndestroy previously created instance.</p>\n<p>Here is a py.test example</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">setup_function</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user_mgr</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">username</span><span class=\"o\">=</span><span class=\"s1\">'Mary'</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_user_properties</span><span class=\"p\">():</span>\n    <span class=\"k\">assert</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">username</span> <span class=\"o\">==</span> <span class=\"s1\">'Mary'</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">teardown_function</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user_mgr</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"feature-6-built-in-console-and-debugger\">\n<h2>Feature 6. Built-in console and debugger</h2>\n<p>Sometimes it\u2019s nice to take a look on what\u2019s going on within test function and\nget access at some point to python console or debugger.</p>\n<p>Usually you probably do something like</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pdb</span><span class=\"p\">;</span> <span class=\"n\">pdb</span><span class=\"o\">.</span><span class=\"n\">set_trace</span><span class=\"p\">()</span>\n</pre>\n<p>Or, if you need to get shell and have IPython installed</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">IPython</span> <span class=\"kn\">import</span> <span class=\"n\">embed</span><span class=\"p\">;</span> <span class=\"n\">embed</span><span class=\"p\">()</span>\n</pre>\n<p>As it happens often, we added to resources two functions, launching either\ndebugger or python console inside your test function.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">resources</span> <span class=\"kn\">import</span> <span class=\"n\">resources</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_something</span><span class=\"p\">():</span>\n    <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">pdb</span><span class=\"p\">()</span>    <span class=\"c1\"># to launch debugger</span>\n    <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">shell</span><span class=\"p\">()</span>  <span class=\"c1\"># to launch Python REPL</span>\n</pre>\n<p>If you install IPython and ipdb (<cite>pip install IPython ipdb</cite>), you get more\nfriendly versions of consoles, otherwise resources fall back to built-in python\nconsole and debugger.</p>\n<p>Launch <cite>py.test</cite> with <cite>-s</cite> switch to be able to fall into interactive console.</p>\n<p>It\u2019s especially cool that resources object is autocomplete-friendly and it\nworks well in IPython</p>\n<pre><span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span> <span class=\"n\">resources</span><span class=\"o\">.</span>\n<span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">john</span>            <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">pdb</span>             <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">register_mod</span>\n<span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">mary</span>            <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">register_func</span>   <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">shell</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">mary</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Mary Moe'</span><span class=\"p\">}</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]:</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">user_mgr</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]:</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'John Doe'</span><span class=\"p\">}</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]:</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo</span>\n<span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item_ctx</span>  <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item_mgr</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]:</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item_mgr</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]:</span> <span class=\"p\">{</span><span class=\"s1\">'text'</span><span class=\"p\">:</span> <span class=\"s1\">'Do something'</span><span class=\"p\">,</span> <span class=\"s1\">'user'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'John Doe'</span><span class=\"p\">}}</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]:</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo</span>\n<span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item</span>      <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item_ctx</span>  <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item_mgr</span>\n\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]:</span> <span class=\"n\">resources</span><span class=\"o\">.</span><span class=\"n\">todo_item</span>\n<span class=\"n\">Out</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">]:</span> <span class=\"p\">{</span><span class=\"s1\">'text'</span><span class=\"p\">:</span> <span class=\"s1\">'Do something'</span><span class=\"p\">,</span> <span class=\"s1\">'user'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'John Doe'</span><span class=\"p\">}}</span>\n</pre>\n</div>\n<div id=\"feature-7-globally-accessible-storage-of-constants\">\n<h2>Feature 7. Globally accessible storage of constants</h2>\n<p>This feature is not something unique to <cite>resources</cite> module. Pretty much every\nobject can act this way, but it is handy to have a convention about the\nway you store your test-related constants.</p>\n<p>It may work like this.</p>\n<pre>resources.TEST_DIRECTORY = '/tmp/foo'\nresources.DOMAIN_NAME = 'example.com'\nresources.SECRET_KEY = 'foobar'\n</pre>\n<p>And then, in the test file.</p>\n<pre>from resources import resources\nresoures.register_mod('&lt;a resource module name here&gt;')\n\ndef test_constants():\n    assert resources.TEST_DIRECTORY == '/tmp/foo'\n    assert resources.DOMAIN_NAME == 'example.com'\n    assert resources.SECRET_KEY == 'foobar'\n</pre>\n</div>\n<div id=\"conclusion\">\n<h2>Conclusion</h2>\n<p>The <cite>resources</cite> library works for us in py.test environment. We don\u2019t see any\nreasons why it shouldn\u2019t work the same way with nose or classic unitttests.\nIt works for python versions 2.6, 2.7 and 3.3.</p>\n<p>Please bear in mind that the library <em>is not thread safe</em>, as we are happy with\nsingle threaded tests at this time.</p>\n<p>And after all\u2026 Seven extra features to improve your test suites for free! What\nare you waiting for? It\u2019s already improved the quailty of our lives in\n<a href=\"http://doist.io\" rel=\"nofollow\">Doist Inc</a>, and we do hope it will do the same for your\nprojects.</p>\n</div>\n\n          </div>"}, "last_serial": 740583, "releases": {"0.2": [{"comment_text": "", "digests": {"md5": "daedcf32bb8e69e42273ba588fd46a37", "sha256": "0cd4918056892f8dd4d44f46cd4c208e44b47e3fee8a4b37f296cbf79cc7d684"}, "downloads": -1, "filename": "python-resources-0.2.tar.gz", "has_sig": false, "md5_digest": "daedcf32bb8e69e42273ba588fd46a37", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7371, "upload_time": "2013-02-25T07:44:32", "upload_time_iso_8601": "2013-02-25T07:44:32.386429Z", "url": "https://files.pythonhosted.org/packages/29/05/2fed01d2c0c62f2d8a55b8a92aae6eea4c02e0d5bec929286875d708b33b/python-resources-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "c91c18f0a3a42030de9850ef9377c936", "sha256": "727d0aadcf88e1af0eb5eb9ff03d92e244a8d08d9847c6b3efb87506276609a6"}, "downloads": -1, "filename": "python-resources-0.3.tar.gz", "has_sig": false, "md5_digest": "c91c18f0a3a42030de9850ef9377c936", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8286, "upload_time": "2013-03-22T18:52:52", "upload_time_iso_8601": "2013-03-22T18:52:52.000499Z", "url": "https://files.pythonhosted.org/packages/32/fb/9c7f74f74a02fbe820ac240df6be4a8e5f012931dfbb437330a34327f74d/python-resources-0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c91c18f0a3a42030de9850ef9377c936", "sha256": "727d0aadcf88e1af0eb5eb9ff03d92e244a8d08d9847c6b3efb87506276609a6"}, "downloads": -1, "filename": "python-resources-0.3.tar.gz", "has_sig": false, "md5_digest": "c91c18f0a3a42030de9850ef9377c936", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8286, "upload_time": "2013-03-22T18:52:52", "upload_time_iso_8601": "2013-03-22T18:52:52.000499Z", "url": "https://files.pythonhosted.org/packages/32/fb/9c7f74f74a02fbe820ac240df6be4a8e5f012931dfbb437330a34327f74d/python-resources-0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:39 2020"}