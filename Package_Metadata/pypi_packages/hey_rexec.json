{"info": {"author": "Paul Heymann", "author_email": "hey_rexec@heymann.be", "bugtrack_url": null, "classifiers": [], "description": "hey_rexec\n=========\nRExec is a simple interface for running R in bulk on .R files.\nIt is not intended to be a replacement for rpy or rpy2.\nIf you're the kind of person who does some analysis in R and just wants\nto mechanize running it (rather than a closer integration with Python),\nthis library might be for you.\n\n__doc__\n-------\nA chaining R executing object.\n\nRExec lets you run R code and get the results from Python.  For the\nmost part, the interface is pretty hacky.  The goal is to make it\neasy to automate the usage of existing R files, rather than make\nelegant programs integrating R and Python.  (For the latter, you\nmight consider rpy or rpy2.)\n\nAn RExec object takes a directory where it will be run.  You can then\nadd R code to the object in a variety of ways (append_string,\nappend_file and so on).  When you are done appending to the RExec\nobject, you can use the execute() method which will run an R slave\nprocess on all of the R that you have appended so far (concatenated\ntogether.  Finally, you can get access to results of your R script\nin a relatively unorthodox way.  Any files output with an \"``r_``\" prefix\nwill be available by calling get_text() or get_graphic() as appropriate.\n\nRExec has a chaining interface.  This means you can do things like:\n\n.. code:: python\n\n r_ex =(RExec(some_dir)\n        .append_file(\"some.R\")\n        .append_file(\"other.R\")\n        .execute())\n r_ex.get_graphic('foo.svg', path='absolute')", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://www.pybrid.com/", "keywords": null, "license": "LICENSE.txt", "maintainer": null, "maintainer_email": null, "name": "hey_rexec", "package_url": "https://pypi.org/project/hey_rexec/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/hey_rexec/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://www.pybrid.com/"}, "release_url": "https://pypi.org/project/hey_rexec/1.0.0/", "requires_dist": null, "requires_python": null, "summary": "Hey! R Executable Object", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>RExec is a simple interface for running R in bulk on .R files.\nIt is not intended to be a replacement for rpy or rpy2.\nIf you\u2019re the kind of person who does some analysis in R and just wants\nto mechanize running it (rather than a closer integration with Python),\nthis library might be for you.</p>\n<div id=\"doc\">\n<h2>__doc__</h2>\n<p>A chaining R executing object.</p>\n<p>RExec lets you run R code and get the results from Python.  For the\nmost part, the interface is pretty hacky.  The goal is to make it\neasy to automate the usage of existing R files, rather than make\nelegant programs integrating R and Python.  (For the latter, you\nmight consider rpy or rpy2.)</p>\n<p>An RExec object takes a directory where it will be run.  You can then\nadd R code to the object in a variety of ways (append_string,\nappend_file and so on).  When you are done appending to the RExec\nobject, you can use the execute() method which will run an R slave\nprocess on all of the R that you have appended so far (concatenated\ntogether.  Finally, you can get access to results of your R script\nin a relatively unorthodox way.  Any files output with an \u201c<tt>r_</tt>\u201d prefix\nwill be available by calling get_text() or get_graphic() as appropriate.</p>\n<p>RExec has a chaining interface.  This means you can do things like:</p>\n<pre><span class=\"n\">r_ex</span> <span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">RExec</span><span class=\"p\">(</span><span class=\"n\">some_dir</span><span class=\"p\">)</span>\n       <span class=\"o\">.</span><span class=\"n\">append_file</span><span class=\"p\">(</span><span class=\"s2\">\"some.R\"</span><span class=\"p\">)</span>\n       <span class=\"o\">.</span><span class=\"n\">append_file</span><span class=\"p\">(</span><span class=\"s2\">\"other.R\"</span><span class=\"p\">)</span>\n       <span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">())</span>\n<span class=\"n\">r_ex</span><span class=\"o\">.</span><span class=\"n\">get_graphic</span><span class=\"p\">(</span><span class=\"s1\">'foo.svg'</span><span class=\"p\">,</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s1\">'absolute'</span><span class=\"p\">)</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 792896, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "37102af85c56853b0c41f427376dcdca", "sha256": "188acf012800394431a54f8d9d8cadb8eb71e45223416b7628b06b7c53b25642"}, "downloads": -1, "filename": "hey_rexec-1.0.0.tar.gz", "has_sig": false, "md5_digest": "37102af85c56853b0c41f427376dcdca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3930, "upload_time": "2013-03-10T02:34:55", "upload_time_iso_8601": "2013-03-10T02:34:55.268013Z", "url": "https://files.pythonhosted.org/packages/cd/23/0034c795cee7dcfce710804caf7545648274a16d6fcf9bd16db92a09c2ca/hey_rexec-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "37102af85c56853b0c41f427376dcdca", "sha256": "188acf012800394431a54f8d9d8cadb8eb71e45223416b7628b06b7c53b25642"}, "downloads": -1, "filename": "hey_rexec-1.0.0.tar.gz", "has_sig": false, "md5_digest": "37102af85c56853b0c41f427376dcdca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3930, "upload_time": "2013-03-10T02:34:55", "upload_time_iso_8601": "2013-03-10T02:34:55.268013Z", "url": "https://files.pythonhosted.org/packages/cd/23/0034c795cee7dcfce710804caf7545648274a16d6fcf9bd16db92a09c2ca/hey_rexec-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:26 2020"}