{"info": {"author": "Adeel Ahmad Khan", "author_email": "adeel2@umbc.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: MIT License"], "description": "Berry is a minimal DSL for building a WSGI application.\n\nBasically, you map some routes to functions.  Berry takes this mapping and\ngenerates a WSGI app, which you can serve however you like.\n\nExample\n-------\n\n  Here is an example using the wsgiref server, included in Python's stdlib\n  and ideal for development use.\n\n    import berry\n    from wsgiref.simple_server import make_server\n  \n    @berry.get('^$')\n    def index(req):\n      return \"Welcome to the home page.\"\n  \n    @berry.get('^hello/(.+)/?$')\n    def hello(req, name):\n      return \"Hello, %s!\" % name\n  \n    # generate a WSGI app\n    wsgi_app = berry.app\n  \n    # start a WSGI server\n    make_server('127.0.0.1', 8000, wsgi_app).serve_forever()\n\nHow to use it\n-------------\n\n  Decorate a function with berry.get(route) or berry.post(route) to serve\n  GET/POST requests that match a route.  Routes must be regular expressions.\n  Your function will be passed a Request object as the first argument.\n  \n  Example:\n  \n    @berry.get('^$')\n    @berry.get('^home$')\n    def home(req):\n      return 'This is the home page.'\n    \n  As above, you can map multiple routes to the same function.\n  \n  Request objects\n  ---------------\n    \n    Useful attributes of Request objects are:\n    \n      - env: the WSGI environ variable.\n      - params: parameters passed through both GET and POST.\n      - path: the path requested, minus the initial '/' and the query string\n      - query: the query string, if any\n      - fullpath: the full path requested, including the initial '/' and the\n        query string\n      - method: the method (GET or POST)\n    \n    Example:\n    \n      @berry.post('^login$')\n      def login(req):\n        username = req.params.get('username')\n        password = req.params.get('password')\n        # ...\n\n    Note: if you have a field like 'a[b]' with value 'c', Berry will parse it\n    into a dictionary.  For example:\n\n      <input name=\"person[name]\" value=\"James\" />\n      <input name=\"person[age]\" value=\"20\" />\n\n    will result in req.params being:\n\n      {'person': {'name': 'James', 'age': '20'}}.\n    \n    Also,\n    \n      <input name=\"person[friends][]\" value=\"James\" />\n      <input name=\"person[friends][]\" value=\"John\" />\n\n    will result in req.params being:\n\n      {'person': {'friends': ['James', 'John']}}.\n\n  Handling errors\n  ---------------\n  \n    Using the berry.error(code) decorator, you can make custom error pages.\n    \n    Example:\n    \n      @berry.error(404)\n      def notfound(req):\n        return \"%s was not found.\" % req.fullpath\n      \n    Berry has Redirect, Forbidden, NotFound, and AppError classes, which\n    are exceptions that inherit berry.HTTPError.  Just raise one of them:\n    \n      if not user.is_logged_in():\n        raise berry.Forbidden()\n    \n    To add an exception for a new HTTP status code you can do something like:\n    \n      class Unauthorized(berry.HTTPError):\n        status = (401, 'Unauthorized')\n        content = \"<h1>401 Unauthorized</h1>\"\n      \n    Application errors\n    ------------------\n    \n      If you set berry.debug = True, tracebacks will be outputted when there\n      is an exception in your code.  Otherwise they will only be written to\n      stderr.\n    \n    Redirecting\n    -----------\n    \n      To redirect, raise the berry.Redirect exception:\n      \n        raise berry.Redirect(url)\n    \n        \n  Headers\n  -------\n  \n    To add HTTP headers, use the berry.header decorator:\n    \n      @berry.header('Content-Type', 'text/plain')\n      def download_as_txt(req, id):\n        # ...\n      \n    By default the Content-Type is set to 'text/html'.\n  \n\nHow to install\n--------------\n  \n  If you have setuptools just do:\n  \n    easy_install berry\n  \n  Otherwise, you can get the latest release from:\n  \n    http://pypi.python.org/pypi/berry\n  \n  Or get the latest development snapshot with git:\n  \n    git clone git://github.com/adeel/berry.git\n  \n  Then:\n  \n    python setup.py install\n  \n  If you try Berry, please write me at adeel2@umbc.edu and let me know what\n  you think.\n\nLatest changes\n--------------\n\n  - Not logging requests anymore (this should be done by a middleware).\n\n  - Berry simply generates a WSGI app for you to serve yourself, instead of\n    serving it for you.\n  \n  - The convenience function redirect() was removed.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://soundofemptiness.com/projects/berry", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "berry", "package_url": "https://pypi.org/project/berry/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/berry/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://soundofemptiness.com/projects/berry"}, "release_url": "https://pypi.org/project/berry/0.3.1/", "requires_dist": null, "requires_python": null, "summary": "a minimal DSL for building a WSGI app", "version": "0.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            Berry is a minimal DSL for building a WSGI application.<br><br>Basically, you map some routes to functions.  Berry takes this mapping and<br>generates a WSGI app, which you can serve however you like.<br><br>Example<br>-------<br><br>  Here is an example using the wsgiref server, included in Python's stdlib<br>  and ideal for development use.<br><br>    import berry<br>    from wsgiref.simple_server import make_server<br>  <br>    @berry.get('^$')<br>    def index(req):<br>      return \"Welcome to the home page.\"<br>  <br>    @berry.get('^hello/(.+)/?$')<br>    def hello(req, name):<br>      return \"Hello, %s!\" % name<br>  <br>    # generate a WSGI app<br>    wsgi_app = berry.app<br>  <br>    # start a WSGI server<br>    make_server('127.0.0.1', 8000, wsgi_app).serve_forever()<br><br>How to use it<br>-------------<br><br>  Decorate a function with berry.get(route) or berry.post(route) to serve<br>  GET/POST requests that match a route.  Routes must be regular expressions.<br>  Your function will be passed a Request object as the first argument.<br>  <br>  Example:<br>  <br>    @berry.get('^$')<br>    @berry.get('^home$')<br>    def home(req):<br>      return 'This is the home page.'<br>    <br>  As above, you can map multiple routes to the same function.<br>  <br>  Request objects<br>  ---------------<br>    <br>    Useful attributes of Request objects are:<br>    <br>      - env: the WSGI environ variable.<br>      - params: parameters passed through both GET and POST.<br>      - path: the path requested, minus the initial '/' and the query string<br>      - query: the query string, if any<br>      - fullpath: the full path requested, including the initial '/' and the<br>        query string<br>      - method: the method (GET or POST)<br>    <br>    Example:<br>    <br>      @berry.post('^login$')<br>      def login(req):<br>        username = req.params.get('username')<br>        password = req.params.get('password')<br>        # ...<br><br>    Note: if you have a field like 'a[b]' with value 'c', Berry will parse it<br>    into a dictionary.  For example:<br><br>      &lt;input name=\"person[name]\" value=\"James\" /&gt;<br>      &lt;input name=\"person[age]\" value=\"20\" /&gt;<br><br>    will result in req.params being:<br><br>      {'person': {'name': 'James', 'age': '20'}}.<br>    <br>    Also,<br>    <br>      &lt;input name=\"person[friends][]\" value=\"James\" /&gt;<br>      &lt;input name=\"person[friends][]\" value=\"John\" /&gt;<br><br>    will result in req.params being:<br><br>      {'person': {'friends': ['James', 'John']}}.<br><br>  Handling errors<br>  ---------------<br>  <br>    Using the berry.error(code) decorator, you can make custom error pages.<br>    <br>    Example:<br>    <br>      @berry.error(404)<br>      def notfound(req):<br>        return \"%s was not found.\" % req.fullpath<br>      <br>    Berry has Redirect, Forbidden, NotFound, and AppError classes, which<br>    are exceptions that inherit berry.HTTPError.  Just raise one of them:<br>    <br>      if not user.is_logged_in():<br>        raise berry.Forbidden()<br>    <br>    To add an exception for a new HTTP status code you can do something like:<br>    <br>      class Unauthorized(berry.HTTPError):<br>        status = (401, 'Unauthorized')<br>        content = \"&lt;h1&gt;401 Unauthorized&lt;/h1&gt;\"<br>      <br>    Application errors<br>    ------------------<br>    <br>      If you set berry.debug = True, tracebacks will be outputted when there<br>      is an exception in your code.  Otherwise they will only be written to<br>      stderr.<br>    <br>    Redirecting<br>    -----------<br>    <br>      To redirect, raise the berry.Redirect exception:<br>      <br>        raise berry.Redirect(url)<br>    <br>        <br>  Headers<br>  -------<br>  <br>    To add HTTP headers, use the berry.header decorator:<br>    <br>      @berry.header('Content-Type', 'text/plain')<br>      def download_as_txt(req, id):<br>        # ...<br>      <br>    By default the Content-Type is set to 'text/html'.<br>  <br><br>How to install<br>--------------<br>  <br>  If you have setuptools just do:<br>  <br>    easy_install berry<br>  <br>  Otherwise, you can get the latest release from:<br>  <br>    http://pypi.python.org/pypi/berry<br>  <br>  Or get the latest development snapshot with git:<br>  <br>    git clone git://github.com/adeel/berry.git<br>  <br>  Then:<br>  <br>    python setup.py install<br>  <br>  If you try Berry, please write me at adeel2@umbc.edu and let me know what<br>  you think.<br><br>Latest changes<br>--------------<br><br>  - Not logging requests anymore (this should be done by a middleware).<br><br>  - Berry simply generates a WSGI app for you to serve yourself, instead of<br>    serving it for you.<br>  <br>  - The convenience function redirect() was removed.\n          </div>"}, "last_serial": 786803, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "a9ba3408d00dd020afe40f7784dc7174", "sha256": "d4920dbb16f5d50107745ac08c4703ab1e0be37918c142fcba40435c534d3d82"}, "downloads": -1, "filename": "berry-0.1.tar.gz", "has_sig": false, "md5_digest": "a9ba3408d00dd020afe40f7784dc7174", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9238, "upload_time": "2009-08-06T07:16:37", "upload_time_iso_8601": "2009-08-06T07:16:37.571020Z", "url": "https://files.pythonhosted.org/packages/2c/a0/6d2a58591ee60eb8e0ea36190f193a34590f9bfae9a369e2356c927d52a8/berry-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "507c53abce3756c7b67939ce250c2c35", "sha256": "30455e0b3f94e5f3c45b1b4ab148f98967691dbd57c40363c98a2cd9dc2ae827"}, "downloads": -1, "filename": "berry-0.2.tar.gz", "has_sig": false, "md5_digest": "507c53abce3756c7b67939ce250c2c35", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8812, "upload_time": "2009-08-15T22:42:44", "upload_time_iso_8601": "2009-08-15T22:42:44.597455Z", "url": "https://files.pythonhosted.org/packages/86/fa/8536f013eaefae7e7b34c87444bfbd60cfc64e5b5effd7af594ccf382ab5/berry-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "39587c3b16deebbd724e8bca74cf15a9", "sha256": "7118b6a2cd1bda9c01eb1f223f347e2dd50b98cd2aa3cb5a4925ce025b2bb0e1"}, "downloads": -1, "filename": "berry-0.3.tar.gz", "has_sig": false, "md5_digest": "39587c3b16deebbd724e8bca74cf15a9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4754, "upload_time": "2010-12-25T06:15:52", "upload_time_iso_8601": "2010-12-25T06:15:52.170386Z", "url": "https://files.pythonhosted.org/packages/e8/9b/65965a5331b22229afd943c7cf2d0cfd000ca9bc98dd562c72395d6ce711/berry-0.3.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "841655fdd3c9c86cb6797942b2ce8924", "sha256": "08c440b5a2b29415fa3cef4e4efa6c0dc7205f96e0a7e3f22e8d72c561200064"}, "downloads": -1, "filename": "berry-0.3.1.tar.gz", "has_sig": false, "md5_digest": "841655fdd3c9c86cb6797942b2ce8924", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5026, "upload_time": "2011-01-22T19:15:07", "upload_time_iso_8601": "2011-01-22T19:15:07.247694Z", "url": "https://files.pythonhosted.org/packages/33/d9/7f6df089134f24727edc72b422fdce5cc99e31dba308eb9f38aedc235ec6/berry-0.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "841655fdd3c9c86cb6797942b2ce8924", "sha256": "08c440b5a2b29415fa3cef4e4efa6c0dc7205f96e0a7e3f22e8d72c561200064"}, "downloads": -1, "filename": "berry-0.3.1.tar.gz", "has_sig": false, "md5_digest": "841655fdd3c9c86cb6797942b2ce8924", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5026, "upload_time": "2011-01-22T19:15:07", "upload_time_iso_8601": "2011-01-22T19:15:07.247694Z", "url": "https://files.pythonhosted.org/packages/33/d9/7f6df089134f24727edc72b422fdce5cc99e31dba308eb9f38aedc235ec6/berry-0.3.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:37:46 2020"}