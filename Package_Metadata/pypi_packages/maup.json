{"info": {"author": "Max Hully", "author_email": "max@mggg.org", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# maup\n\n[![Build Status](https://api.travis-ci.com/mggg/maup.svg?branch=master)](https://travis-ci.com/mggg/maup)\n[![codecov](https://codecov.io/gh/mggg/maup/branch/master/graph/badge.svg)](https://codecov.io/gh/mggg/maup)\n[![PyPI](https://img.shields.io/pypi/v/maup.svg?color=%23)](https://pypi.org/project/maup/)\n[![conda-forge Package](https://img.shields.io/conda/vn/conda-forge/maup.svg?color=%230099cd)](https://anaconda.org/conda-forge/maup)\n\n`maup` is the geospatial toolkit for redistricting data. The package streamlines\nthe basic workflows that arise when working with blocks, precincts, and\ndistricts, such as\n\n-   [Assigning precincts to districts](#assigning-precincts-to-districts),\n-   [Aggregating block data to precincts](#aggregating-block-data-to-precincts),\n-   [Disaggregating data from precincts down to blocks](#disaggregating-data-from-precincts-down-to-blocks),\n-   [Prorating data when units do not nest neatly](#prorating-data-when-units-do-not-nest-neatly),\n    and\n-   [Fixing overlaps and gaps](#fixing-overlaps-and-gaps)\n\nThe project's priorities are to be efficient by using spatial indices whenever\npossible and to integrate well with the existing ecosystem around\n[pandas](https://pandas.pydata.org/), [geopandas](https://geopandas.org) and\n[shapely](https://shapely.readthedocs.io/en/latest/). The package is distributed\nunder the MIT License.\n\n## Installation\n\nWe recommend installing `maup` from [conda-forge](https://conda-forge.org/)\nusing [conda](https://docs.conda.io/en/latest/):\n\n```console\nconda install -c conda-forge maup\n```\n\nYou can get conda by installing\n[Miniconda](https://docs.conda.io/en/latest/miniconda.html), a free Python\ndistribution made especially for data science and scientific computing. You\nmight also consider [Anaconda](https://www.anaconda.com/distribution/), which\nincludes many data science packages that you might find useful.\n\nTo install `maup` from PyPI, run `pip install maup` from your terminal.\n\n## Examples\n\nHere are some basic situations where you might find `maup` helpful. For these\nexamples, we use test data from Providence, Rhode Island, which you can find in\nour\n[Rhode Island shapefiles repo](https://github.com/mggg-states/RI-shapefiles), or\nin the `examples` folder of this repo.\n\n```python\n>>> import geopandas\n>>> import pandas\n>>>\n>>> blocks = geopandas.read_file(\"zip://./examples/blocks.zip\")\n>>> precincts = geopandas.read_file(\"zip://./examples/precincts.zip\")\n>>> districts = geopandas.read_file(\"zip://./examples/districts.zip\")\n\n```\n\n### Assigning precincts to districts\n\nThe `assign` function in `maup` takes two sets of geometries called `sources`\nand `targets` and returns a pandas `Series`. The Series maps each geometry in\n`sources` to the geometry in `targets` that covers it. (Here, geometry _A_\n_covers_ geometry _B_ if every point of _A_ and its boundary lies in _B_ or its\nboundary.) If a source geometry is not covered by one single target geometry, it\nis assigned to the target geometry that covers the largest portion of its area.\n\n```python\n>>> import maup\n>>>\n>>> assignment = maup.assign(precincts, districts)\n>>> # Add the assigned districts as a column of the `precincts` GeoDataFrame:\n>>> precincts[\"DISTRICT\"] = assignment\n>>> assignment.head()\n0     7\n1     5\n2    13\n3     6\n4     1\ndtype: int64\n\n```\n\nAs an aside, you can use that `assignment` object to create a\n[gerrychain](https://gerrychain.readthedocs.io/en/latest/) `Partition`\nrepresenting this districting plan.\n\n### Aggregating block data to precincts\n\nPrecinct shapefiles usually come with election data, but not demographic data.\nIn order to study their demographics, we need to aggregate demographic data from\ncensus blocks up to the precinct level. We can do this by assigning blocks to\nprecincts and then aggregating the data with a Pandas\n[`groupby`](http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)\noperation:\n\n```python\n>>> variables = [\"TOTPOP\", \"NH_BLACK\", \"NH_WHITE\"]\n>>>\n>>> assignment = maup.assign(blocks, precincts)\n>>> precincts[variables] = blocks[variables].groupby(assignment).sum()\n>>> precincts[variables].head()\n   TOTPOP  NH_BLACK  NH_WHITE\n0    5907       886       380\n1    5636       924      1301\n2    6549       584      4699\n3    6009       435      1053\n4    4962       156      3713\n\n```\n\nIf you want to move data from one set of geometries to another but your source\nand target geometries do not nest neatly (i.e. have overlaps), see\n[Prorating data when units do not nest neatly](#prorating-data-when-units-do-not-nest-neatly).\n\n### Disaggregating data from precincts down to blocks\n\nIt's common to have data at a coarser scale that you want to attach to\nfiner-scaled geometries. Usually this happens when vote totals for a certain\nelection are only reported at the county level, and we want to attach that data\nto precinct geometries.\n\nLet's say we want to prorate the vote totals in the columns `\"PRES16D\"`,\n`\"PRES16R\"` from our `precincts` GeoDataFrame down to our `blocks` GeoDataFrame.\nThe first crucial step is to decide how we want to distribute a precinct's data\nto the blocks within it. Since we're prorating election data, it makes sense to\nuse a block's total population or voting-age population. Here's how we might\nprorate by population (`\"TOTPOP\"`):\n\n```python\n>>> election_columns = [\"PRES16D\", \"PRES16R\"]\n>>> assignment = maup.assign(blocks, precincts)\n>>>\n>>> # We prorate the vote totals according to each block's share of the overall\n>>> # precinct population:\n>>> weights = blocks.TOTPOP / assignment.map(precincts.TOTPOP)\n>>> prorated = maup.prorate(assignment, precincts[election_columns], weights)\n>>>\n>>> # Add the prorated vote totals as columns on the `blocks` GeoDataFrame:\n>>> blocks[election_columns] = prorated\n>>> # We'll call .round(2) to round the values for display purposes.\n>>> blocks[election_columns].round(2).head()\n   PRES16D  PRES16R\n0     0.00     0.00\n1    12.26     1.70\n2    15.20     2.62\n3    15.50     2.67\n4     3.28     0.45\n\n```\n\n#### Warning about areal interpolation\n\n**We strongly urge you _not_ to prorate by area!** The area of a census block is\n**not** a good predictor of its population. In fact, the correlation goes in the\nother direction: larger census blocks are _less_ populous than smaller ones.\n\n### Prorating data when units do not nest neatly\n\nSuppose you have a shapefile of precincts with some election results data and\nyou want to join that data onto a different, more recent precincts shapefile.\nThe two sets of precincts will have overlaps, and will not nest neatly like the\nblocks and precincts did in the above examples. (Not that blocks and precincts\nalways nest neatly...)\n\nWe can use `maup.intersections` to break the two sets of precincts into pieces\nthat nest neatly into both sets. Then we can disaggregate from the old precincts\nonto these pieces, and aggregate up from the pieces to the new precincts. This\nmove is a bit complicated, so `maup` provides a function called `prorate` that\ndoes just that.\n\nWe'll use our same `blocks` GeoDataFrame to estimate the populations of the\npieces for the purposes of proration.\n\nFor our \"new precincts\" shapefile, we'll use the VTD shapefile for Rhode Island\nthat the U.S. Census Bureau produced as part of their 2018 test run of for the\n2020 Census.\n\n```python\n>>> old_precincts = precincts\n>>> new_precincts = geopandas.read_file(\"zip://./examples/new_precincts.zip\")\n>>>\n>>> columns = [\"SEN18D\", \"SEN18R\"]\n>>>\n>>> # Include area_cutoff=0 to ignore any intersections with no area,\n>>> # like boundary intersections, which we do not want to include in\n>>> # our proration.\n>>> pieces = maup.intersections(old_precincts, new_precincts, area_cutoff=0)\n>>>\n>>> # Weight by prorated population from blocks\n>>> weights = blocks[\"TOTPOP\"].groupby(maup.assign(blocks, pieces)).sum()\n>>> # Normalize the weights so that votes are allocated according to their\n>>> # share of population in the old_precincts\n>>> weights = maup.normalize(weights, level=0)\n>>>\n>>> # Use blocks to estimate population of each piece\n>>> new_precincts[columns] = maup.prorate(\n...     pieces,\n...     old_precincts[columns],\n...     weights=weights\n... )\n>>> new_precincts[columns].head()\n   SEN18D  SEN18R\n0   752.0    51.0\n1   370.0    21.0\n2    97.0    17.0\n3   585.0    74.0\n4   246.0    20.0\n\n```\n\n### Progress bars\n\nFor long-running operations, the user might want to see a progress bar to\nestimate how much longer a task will take (and whether to abandon it altogether).\n\n`maup` provides an optional progress bar for this purpose. To temporarily activate\na progress bar for a certain operation, use `with maup.progress():`:\n\n```python\n>>> with maup.progress():\n...     assignment = maup.assign(precincts, districts)\n...\n\n```\n\nTo turn on progress bars for all applicable operations (e.g. for an entire script),\nset `maup.progress.enabled = True`:\n\n```python\n>>> maup.progress.enabled = True\n>>> # Now a progress bar will display while this function runs:\n>>> assignment = maup.assign(precincts, districts)\n>>> # And this one too:\n>>> pieces = maup.intersections(old_precincts, new_precincts, area_cutoff=0)\n\n```\n\n## Modifiable areal unit problem\n\nThe name of this package comes from the\n[modifiable areal unit problem (MAUP)](https://en.wikipedia.org/wiki/Modifiable_areal_unit_problem):\nthe same spatial data will look different depending on how you divide up the\nspace. Since `maup` is all about changing the way your data is aggregated and\npartitioned, we have named it after the MAUP to encourage users to use the\ntoolkit thoughtfully and responsibly.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mggg/maup", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "maup", "package_url": "https://pypi.org/project/maup/", "platform": "", "project_url": "https://pypi.org/project/maup/", "project_urls": {"Homepage": "https://github.com/mggg/maup"}, "release_url": "https://pypi.org/project/maup/0.7/", "requires_dist": ["numpy", "pandas", "geopandas", "shapely", "tqdm"], "requires_python": "", "summary": "The geospatial toolkit for redistricting data", "version": "0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>maup</h1>\n<p><a href=\"https://travis-ci.com/mggg/maup\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a78e26732785481d06d8204f4535a5bff3327ea7/68747470733a2f2f6170692e7472617669732d63692e636f6d2f6d6767672f6d6175702e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/mggg/maup\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f9d42aa6226ef416d67b80b03739fef237f2cc4b/68747470733a2f2f636f6465636f762e696f2f67682f6d6767672f6d6175702f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://pypi.org/project/maup/\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4cdaef0da0791626590ea2446460d7e485a18ab0/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6d6175702e7376673f636f6c6f723d253233\"></a>\n<a href=\"https://anaconda.org/conda-forge/maup\" rel=\"nofollow\"><img alt=\"conda-forge Package\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d35b192169244e4e56b9d580a4f7719522eff042/68747470733a2f2f696d672e736869656c64732e696f2f636f6e64612f766e2f636f6e64612d666f7267652f6d6175702e7376673f636f6c6f723d253233303039396364\"></a></p>\n<p><code>maup</code> is the geospatial toolkit for redistricting data. The package streamlines\nthe basic workflows that arise when working with blocks, precincts, and\ndistricts, such as</p>\n<ul>\n<li><a href=\"#assigning-precincts-to-districts\" rel=\"nofollow\">Assigning precincts to districts</a>,</li>\n<li><a href=\"#aggregating-block-data-to-precincts\" rel=\"nofollow\">Aggregating block data to precincts</a>,</li>\n<li><a href=\"#disaggregating-data-from-precincts-down-to-blocks\" rel=\"nofollow\">Disaggregating data from precincts down to blocks</a>,</li>\n<li><a href=\"#prorating-data-when-units-do-not-nest-neatly\" rel=\"nofollow\">Prorating data when units do not nest neatly</a>,\nand</li>\n<li><a href=\"#fixing-overlaps-and-gaps\" rel=\"nofollow\">Fixing overlaps and gaps</a></li>\n</ul>\n<p>The project's priorities are to be efficient by using spatial indices whenever\npossible and to integrate well with the existing ecosystem around\n<a href=\"https://pandas.pydata.org/\" rel=\"nofollow\">pandas</a>, <a href=\"https://geopandas.org\" rel=\"nofollow\">geopandas</a> and\n<a href=\"https://shapely.readthedocs.io/en/latest/\" rel=\"nofollow\">shapely</a>. The package is distributed\nunder the MIT License.</p>\n<h2>Installation</h2>\n<p>We recommend installing <code>maup</code> from <a href=\"https://conda-forge.org/\" rel=\"nofollow\">conda-forge</a>\nusing <a href=\"https://docs.conda.io/en/latest/\" rel=\"nofollow\">conda</a>:</p>\n<pre><span class=\"go\">conda install -c conda-forge maup</span>\n</pre>\n<p>You can get conda by installing\n<a href=\"https://docs.conda.io/en/latest/miniconda.html\" rel=\"nofollow\">Miniconda</a>, a free Python\ndistribution made especially for data science and scientific computing. You\nmight also consider <a href=\"https://www.anaconda.com/distribution/\" rel=\"nofollow\">Anaconda</a>, which\nincludes many data science packages that you might find useful.</p>\n<p>To install <code>maup</code> from PyPI, run <code>pip install maup</code> from your terminal.</p>\n<h2>Examples</h2>\n<p>Here are some basic situations where you might find <code>maup</code> helpful. For these\nexamples, we use test data from Providence, Rhode Island, which you can find in\nour\n<a href=\"https://github.com/mggg-states/RI-shapefiles\" rel=\"nofollow\">Rhode Island shapefiles repo</a>, or\nin the <code>examples</code> folder of this repo.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">geopandas</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">pandas</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">blocks</span> <span class=\"o\">=</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">read_file</span><span class=\"p\">(</span><span class=\"s2\">\"zip://./examples/blocks.zip\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">precincts</span> <span class=\"o\">=</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">read_file</span><span class=\"p\">(</span><span class=\"s2\">\"zip://./examples/precincts.zip\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">districts</span> <span class=\"o\">=</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">read_file</span><span class=\"p\">(</span><span class=\"s2\">\"zip://./examples/districts.zip\"</span><span class=\"p\">)</span>\n</pre>\n<h3>Assigning precincts to districts</h3>\n<p>The <code>assign</code> function in <code>maup</code> takes two sets of geometries called <code>sources</code>\nand <code>targets</code> and returns a pandas <code>Series</code>. The Series maps each geometry in\n<code>sources</code> to the geometry in <code>targets</code> that covers it. (Here, geometry <em>A</em>\n<em>covers</em> geometry <em>B</em> if every point of <em>A</em> and its boundary lies in <em>B</em> or its\nboundary.) If a source geometry is not covered by one single target geometry, it\nis assigned to the target geometry that covers the largest portion of its area.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">maup</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">assignment</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">precincts</span><span class=\"p\">,</span> <span class=\"n\">districts</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Add the assigned districts as a column of the `precincts` GeoDataFrame:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">precincts</span><span class=\"p\">[</span><span class=\"s2\">\"DISTRICT\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">assignment</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">assignment</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">()</span>\n<span class=\"mi\">0</span>     <span class=\"mi\">7</span>\n<span class=\"mi\">1</span>     <span class=\"mi\">5</span>\n<span class=\"mi\">2</span>    <span class=\"mi\">13</span>\n<span class=\"mi\">3</span>     <span class=\"mi\">6</span>\n<span class=\"mi\">4</span>     <span class=\"mi\">1</span>\n<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">int64</span>\n</pre>\n<p>As an aside, you can use that <code>assignment</code> object to create a\n<a href=\"https://gerrychain.readthedocs.io/en/latest/\" rel=\"nofollow\">gerrychain</a> <code>Partition</code>\nrepresenting this districting plan.</p>\n<h3>Aggregating block data to precincts</h3>\n<p>Precinct shapefiles usually come with election data, but not demographic data.\nIn order to study their demographics, we need to aggregate demographic data from\ncensus blocks up to the precinct level. We can do this by assigning blocks to\nprecincts and then aggregating the data with a Pandas\n<a href=\"http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html\" rel=\"nofollow\"><code>groupby</code></a>\noperation:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">variables</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"TOTPOP\"</span><span class=\"p\">,</span> <span class=\"s2\">\"NH_BLACK\"</span><span class=\"p\">,</span> <span class=\"s2\">\"NH_WHITE\"</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">assignment</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">blocks</span><span class=\"p\">,</span> <span class=\"n\">precincts</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">precincts</span><span class=\"p\">[</span><span class=\"n\">variables</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"n\">variables</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"n\">assignment</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">precincts</span><span class=\"p\">[</span><span class=\"n\">variables</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">()</span>\n   <span class=\"n\">TOTPOP</span>  <span class=\"n\">NH_BLACK</span>  <span class=\"n\">NH_WHITE</span>\n<span class=\"mi\">0</span>    <span class=\"mi\">5907</span>       <span class=\"mi\">886</span>       <span class=\"mi\">380</span>\n<span class=\"mi\">1</span>    <span class=\"mi\">5636</span>       <span class=\"mi\">924</span>      <span class=\"mi\">1301</span>\n<span class=\"mi\">2</span>    <span class=\"mi\">6549</span>       <span class=\"mi\">584</span>      <span class=\"mi\">4699</span>\n<span class=\"mi\">3</span>    <span class=\"mi\">6009</span>       <span class=\"mi\">435</span>      <span class=\"mi\">1053</span>\n<span class=\"mi\">4</span>    <span class=\"mi\">4962</span>       <span class=\"mi\">156</span>      <span class=\"mi\">3713</span>\n</pre>\n<p>If you want to move data from one set of geometries to another but your source\nand target geometries do not nest neatly (i.e. have overlaps), see\n<a href=\"#prorating-data-when-units-do-not-nest-neatly\" rel=\"nofollow\">Prorating data when units do not nest neatly</a>.</p>\n<h3>Disaggregating data from precincts down to blocks</h3>\n<p>It's common to have data at a coarser scale that you want to attach to\nfiner-scaled geometries. Usually this happens when vote totals for a certain\nelection are only reported at the county level, and we want to attach that data\nto precinct geometries.</p>\n<p>Let's say we want to prorate the vote totals in the columns <code>\"PRES16D\"</code>,\n<code>\"PRES16R\"</code> from our <code>precincts</code> GeoDataFrame down to our <code>blocks</code> GeoDataFrame.\nThe first crucial step is to decide how we want to distribute a precinct's data\nto the blocks within it. Since we're prorating election data, it makes sense to\nuse a block's total population or voting-age population. Here's how we might\nprorate by population (<code>\"TOTPOP\"</code>):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">election_columns</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"PRES16D\"</span><span class=\"p\">,</span> <span class=\"s2\">\"PRES16R\"</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">assignment</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">blocks</span><span class=\"p\">,</span> <span class=\"n\">precincts</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># We prorate the vote totals according to each block's share of the overall</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># precinct population:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">TOTPOP</span> <span class=\"o\">/</span> <span class=\"n\">assignment</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">precincts</span><span class=\"o\">.</span><span class=\"n\">TOTPOP</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">prorated</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">prorate</span><span class=\"p\">(</span><span class=\"n\">assignment</span><span class=\"p\">,</span> <span class=\"n\">precincts</span><span class=\"p\">[</span><span class=\"n\">election_columns</span><span class=\"p\">],</span> <span class=\"n\">weights</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Add the prorated vote totals as columns on the `blocks` GeoDataFrame:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"n\">election_columns</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">prorated</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># We'll call .round(2) to round the values for display purposes.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"n\">election_columns</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">()</span>\n   <span class=\"n\">PRES16D</span>  <span class=\"n\">PRES16R</span>\n<span class=\"mi\">0</span>     <span class=\"mf\">0.00</span>     <span class=\"mf\">0.00</span>\n<span class=\"mi\">1</span>    <span class=\"mf\">12.26</span>     <span class=\"mf\">1.70</span>\n<span class=\"mi\">2</span>    <span class=\"mf\">15.20</span>     <span class=\"mf\">2.62</span>\n<span class=\"mi\">3</span>    <span class=\"mf\">15.50</span>     <span class=\"mf\">2.67</span>\n<span class=\"mi\">4</span>     <span class=\"mf\">3.28</span>     <span class=\"mf\">0.45</span>\n</pre>\n<h4>Warning about areal interpolation</h4>\n<p><strong>We strongly urge you <em>not</em> to prorate by area!</strong> The area of a census block is\n<strong>not</strong> a good predictor of its population. In fact, the correlation goes in the\nother direction: larger census blocks are <em>less</em> populous than smaller ones.</p>\n<h3>Prorating data when units do not nest neatly</h3>\n<p>Suppose you have a shapefile of precincts with some election results data and\nyou want to join that data onto a different, more recent precincts shapefile.\nThe two sets of precincts will have overlaps, and will not nest neatly like the\nblocks and precincts did in the above examples. (Not that blocks and precincts\nalways nest neatly...)</p>\n<p>We can use <code>maup.intersections</code> to break the two sets of precincts into pieces\nthat nest neatly into both sets. Then we can disaggregate from the old precincts\nonto these pieces, and aggregate up from the pieces to the new precincts. This\nmove is a bit complicated, so <code>maup</code> provides a function called <code>prorate</code> that\ndoes just that.</p>\n<p>We'll use our same <code>blocks</code> GeoDataFrame to estimate the populations of the\npieces for the purposes of proration.</p>\n<p>For our \"new precincts\" shapefile, we'll use the VTD shapefile for Rhode Island\nthat the U.S. Census Bureau produced as part of their 2018 test run of for the\n2020 Census.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">old_precincts</span> <span class=\"o\">=</span> <span class=\"n\">precincts</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">new_precincts</span> <span class=\"o\">=</span> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">read_file</span><span class=\"p\">(</span><span class=\"s2\">\"zip://./examples/new_precincts.zip\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">columns</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"SEN18D\"</span><span class=\"p\">,</span> <span class=\"s2\">\"SEN18R\"</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Include area_cutoff=0 to ignore any intersections with no area,</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># like boundary intersections, which we do not want to include in</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># our proration.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pieces</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">intersections</span><span class=\"p\">(</span><span class=\"n\">old_precincts</span><span class=\"p\">,</span> <span class=\"n\">new_precincts</span><span class=\"p\">,</span> <span class=\"n\">area_cutoff</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Weight by prorated population from blocks</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">blocks</span><span class=\"p\">[</span><span class=\"s2\">\"TOTPOP\"</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">blocks</span><span class=\"p\">,</span> <span class=\"n\">pieces</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Normalize the weights so that votes are allocated according to their</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># share of population in the old_precincts</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">(</span><span class=\"n\">weights</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Use blocks to estimate population of each piece</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">new_precincts</span><span class=\"p\">[</span><span class=\"n\">columns</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">prorate</span><span class=\"p\">(</span>\n<span class=\"o\">...</span>     <span class=\"n\">pieces</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>     <span class=\"n\">old_precincts</span><span class=\"p\">[</span><span class=\"n\">columns</span><span class=\"p\">],</span>\n<span class=\"o\">...</span>     <span class=\"n\">weights</span><span class=\"o\">=</span><span class=\"n\">weights</span>\n<span class=\"o\">...</span> <span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">new_precincts</span><span class=\"p\">[</span><span class=\"n\">columns</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">()</span>\n   <span class=\"n\">SEN18D</span>  <span class=\"n\">SEN18R</span>\n<span class=\"mi\">0</span>   <span class=\"mf\">752.0</span>    <span class=\"mf\">51.0</span>\n<span class=\"mi\">1</span>   <span class=\"mf\">370.0</span>    <span class=\"mf\">21.0</span>\n<span class=\"mi\">2</span>    <span class=\"mf\">97.0</span>    <span class=\"mf\">17.0</span>\n<span class=\"mi\">3</span>   <span class=\"mf\">585.0</span>    <span class=\"mf\">74.0</span>\n<span class=\"mi\">4</span>   <span class=\"mf\">246.0</span>    <span class=\"mf\">20.0</span>\n</pre>\n<h3>Progress bars</h3>\n<p>For long-running operations, the user might want to see a progress bar to\nestimate how much longer a task will take (and whether to abandon it altogether).</p>\n<p><code>maup</code> provides an optional progress bar for this purpose. To temporarily activate\na progress bar for a certain operation, use <code>with maup.progress():</code>:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">with</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">progress</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>     <span class=\"n\">assignment</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">precincts</span><span class=\"p\">,</span> <span class=\"n\">districts</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n</pre>\n<p>To turn on progress bars for all applicable operations (e.g. for an entire script),\nset <code>maup.progress.enabled = True</code>:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">progress</span><span class=\"o\">.</span><span class=\"n\">enabled</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Now a progress bar will display while this function runs:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">assignment</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">precincts</span><span class=\"p\">,</span> <span class=\"n\">districts</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># And this one too:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pieces</span> <span class=\"o\">=</span> <span class=\"n\">maup</span><span class=\"o\">.</span><span class=\"n\">intersections</span><span class=\"p\">(</span><span class=\"n\">old_precincts</span><span class=\"p\">,</span> <span class=\"n\">new_precincts</span><span class=\"p\">,</span> <span class=\"n\">area_cutoff</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</pre>\n<h2>Modifiable areal unit problem</h2>\n<p>The name of this package comes from the\n<a href=\"https://en.wikipedia.org/wiki/Modifiable_areal_unit_problem\" rel=\"nofollow\">modifiable areal unit problem (MAUP)</a>:\nthe same spatial data will look different depending on how you divide up the\nspace. Since <code>maup</code> is all about changing the way your data is aggregated and\npartitioned, we have named it after the MAUP to encourage users to use the\ntoolkit thoughtfully and responsibly.</p>\n\n          </div>"}, "last_serial": 6807528, "releases": {"0.2": [{"comment_text": "", "digests": {"md5": "a2f764fc48e913cfb7d86c260cdc7a50", "sha256": "9770d832e09f300f098751d8d9d3fde8c0b6bc26453e7426ce9911d2c433ac18"}, "downloads": -1, "filename": "maup-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "a2f764fc48e913cfb7d86c260cdc7a50", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6138, "upload_time": "2019-03-22T21:45:53", "upload_time_iso_8601": "2019-03-22T21:45:53.166871Z", "url": "https://files.pythonhosted.org/packages/59/e9/d78268ffd9d20e83e908d0368d24acc6ef5ba8b5f04e9aefa6b28e63358a/maup-0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "db2f2a320f120cb5b866e892ef2942c5", "sha256": "ebb3394d998b80679e064f4111f39658272152986bd2c60e83a2842bd7ecd39c"}, "downloads": -1, "filename": "maup-0.2.tar.gz", "has_sig": false, "md5_digest": "db2f2a320f120cb5b866e892ef2942c5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4739, "upload_time": "2019-03-22T21:45:55", "upload_time_iso_8601": "2019-03-22T21:45:55.583460Z", "url": "https://files.pythonhosted.org/packages/9b/e3/7e3c25d4933e7e858d54886565f392c1e5c30325ed97de368a1a75514b83/maup-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "44704c99ef1041c80f2ff4ed661c8f76", "sha256": "563368a1b737225bbc1a7bd71cfd14f57fde765044c72df1bfd0381df574a5af"}, "downloads": -1, "filename": "maup-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "44704c99ef1041c80f2ff4ed661c8f76", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7719, "upload_time": "2019-03-25T18:32:45", "upload_time_iso_8601": "2019-03-25T18:32:45.986710Z", "url": "https://files.pythonhosted.org/packages/f6/14/9f6ecf8c4abbd3d82dd76488736807b7544cb25f6259b291c7f90d599c96/maup-0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d2988f2b20769a85e41e3c08fd42256c", "sha256": "694158463cd0b4dc2fe30508e1fcb6a1bbfb2940704bca7a8774cf11715a47a5"}, "downloads": -1, "filename": "maup-0.3.tar.gz", "has_sig": false, "md5_digest": "d2988f2b20769a85e41e3c08fd42256c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6232, "upload_time": "2019-03-25T18:32:47", "upload_time_iso_8601": "2019-03-25T18:32:47.084112Z", "url": "https://files.pythonhosted.org/packages/e7/57/255aad70aa1acfb628a8639f8c0a74a415764d24715bc47c54725a87b845/maup-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "86233f59a7b5cdcc47ba80af84c17fd6", "sha256": "26c2ba32f67d9723b239eba29490f58986f32c44a39c975a2efe568e6c9ced99"}, "downloads": -1, "filename": "maup-0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "86233f59a7b5cdcc47ba80af84c17fd6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7840, "upload_time": "2019-03-25T20:15:29", "upload_time_iso_8601": "2019-03-25T20:15:29.133151Z", "url": "https://files.pythonhosted.org/packages/2c/70/202392cf9169918d57d5012a2900c875cb01ce04f59d45653906a065e166/maup-0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "956528d8e0be5d431b393063120c0f74", "sha256": "45ab1fe508a779d1452812370608ba29f1c4f4295b6a3c1e27005c0028142287"}, "downloads": -1, "filename": "maup-0.4.tar.gz", "has_sig": false, "md5_digest": "956528d8e0be5d431b393063120c0f74", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6341, "upload_time": "2019-03-25T20:15:30", "upload_time_iso_8601": "2019-03-25T20:15:30.572887Z", "url": "https://files.pythonhosted.org/packages/9b/99/4c38b17718553c9451c605427365fbd56cd5ceadfe4f52e506afc9d5e04f/maup-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "d9ee524c7ba995c9891bbb93c68727e5", "sha256": "95245c0abfa4a6ab7fd87028a4c3a7d4e8cbd5b1b24266e04194691fa9383580"}, "downloads": -1, "filename": "maup-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "d9ee524c7ba995c9891bbb93c68727e5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10389, "upload_time": "2019-06-05T18:46:59", "upload_time_iso_8601": "2019-06-05T18:46:59.598505Z", "url": "https://files.pythonhosted.org/packages/cf/e7/ed50bf348395b65715b56fa8f724f0633848d3fe8a233be9fe742c1e482c/maup-0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1bb2d9a71afe67c0561e970cd3181f6c", "sha256": "861b9ada410bc115969f64b092ae6743e08e4d868e8daa2dc739517b20d4f296"}, "downloads": -1, "filename": "maup-0.5.tar.gz", "has_sig": false, "md5_digest": "1bb2d9a71afe67c0561e970cd3181f6c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9405, "upload_time": "2019-06-05T18:47:01", "upload_time_iso_8601": "2019-06-05T18:47:01.805893Z", "url": "https://files.pythonhosted.org/packages/e1/90/570f20a91a08dfab3dc470b0e68d3a4fa8f0d6e3436063665c5daf9a8a38/maup-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "5649db1803723c427d45cc63155403cb", "sha256": "93fbf97ccfd7570fbeba52bc5c25140d0c16dac10219f61c1a7815b22e0bd052"}, "downloads": -1, "filename": "maup-0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "5649db1803723c427d45cc63155403cb", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12876, "upload_time": "2019-06-20T14:00:43", "upload_time_iso_8601": "2019-06-20T14:00:43.813548Z", "url": "https://files.pythonhosted.org/packages/43/0e/670450b58696670ed1f9fd94e20295cab0e2b23fc867bb0677ca3f58b99d/maup-0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "14a8db6ae85832e0763b74da26acfb96", "sha256": "bc4e0c6e591a2d61ef52f4ebffc11ec0b762a703a535fb24d282d1ff799ad8a8"}, "downloads": -1, "filename": "maup-0.6.tar.gz", "has_sig": false, "md5_digest": "14a8db6ae85832e0763b74da26acfb96", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14998, "upload_time": "2019-06-20T14:00:45", "upload_time_iso_8601": "2019-06-20T14:00:45.273177Z", "url": "https://files.pythonhosted.org/packages/23/40/fefdc9594a169a78fd6a4b38c0125cb666aa45520df8747709974ab9e397/maup-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "fa43eaba0d60a2420e9bd8d52534bec1", "sha256": "33f342a480981632dbce6ad7716e4535d95fbb19b7a323cac578592b32ce88de"}, "downloads": -1, "filename": "maup-0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "fa43eaba0d60a2420e9bd8d52534bec1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12815, "upload_time": "2020-03-13T17:45:27", "upload_time_iso_8601": "2020-03-13T17:45:27.748623Z", "url": "https://files.pythonhosted.org/packages/6e/0c/3b1258a912d814c1d5fbfe734090adddc1dc474d72fdfc2c7b16e0b8f853/maup-0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1d8bfb2c895834af35c1b47a2c65896b", "sha256": "a8e45c71af8263ef7039fb747bfe9706cf4e6b1fc3393d21284416b426974cb1"}, "downloads": -1, "filename": "maup-0.7.tar.gz", "has_sig": false, "md5_digest": "1d8bfb2c895834af35c1b47a2c65896b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14473, "upload_time": "2020-03-13T17:45:29", "upload_time_iso_8601": "2020-03-13T17:45:29.290488Z", "url": "https://files.pythonhosted.org/packages/25/0a/7a627c6d154a1ab4f4013262341d6ad90dd1a25261e5e4a5c1a68769e1db/maup-0.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fa43eaba0d60a2420e9bd8d52534bec1", "sha256": "33f342a480981632dbce6ad7716e4535d95fbb19b7a323cac578592b32ce88de"}, "downloads": -1, "filename": "maup-0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "fa43eaba0d60a2420e9bd8d52534bec1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12815, "upload_time": "2020-03-13T17:45:27", "upload_time_iso_8601": "2020-03-13T17:45:27.748623Z", "url": "https://files.pythonhosted.org/packages/6e/0c/3b1258a912d814c1d5fbfe734090adddc1dc474d72fdfc2c7b16e0b8f853/maup-0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1d8bfb2c895834af35c1b47a2c65896b", "sha256": "a8e45c71af8263ef7039fb747bfe9706cf4e6b1fc3393d21284416b426974cb1"}, "downloads": -1, "filename": "maup-0.7.tar.gz", "has_sig": false, "md5_digest": "1d8bfb2c895834af35c1b47a2c65896b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14473, "upload_time": "2020-03-13T17:45:29", "upload_time_iso_8601": "2020-03-13T17:45:29.290488Z", "url": "https://files.pythonhosted.org/packages/25/0a/7a627c6d154a1ab4f4013262341d6ad90dd1a25261e5e4a5c1a68769e1db/maup-0.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:57:11 2020"}