{"info": {"author": "Hannes Preiss", "author_email": "sophie@sophieware.net", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: MIT License", "Operating System :: Unix", "Programming Language :: Python :: 3"], "description": "# FPGA I2C Bridge API\nA library for managing and remotely controlling devices connected to one or several bridges, which in turn are communicated with via a specialized I\u00b2C protocol. Intended for a Smart Home FPGA solution that was created as part of a Bachelor's thesis.\n\nIncludes a high-level API as well as a low-level debugging shell.\n\n## Installation\n```\npip install fpga-i2c-bridge\n```\n\n## Usage\n### Interactive shell\nOn a device with I2C support, run:\n```\npython -m fpga_i2c_bridge\n```\n\nUse the `--addr` and `--bus` switches to adjust I2C bus and address values, respectively.\n\nTo run with simulated dummy devices only, run instead:\n```\npython -m fpga_i2c_bridge --dummy\n```\nUse `--dummy-appliances` and `--dummy-sensors` to supply a comma-seperated list of device types to simulate. For example:\n```\npython -m fpga_i2c_bridge --dummy --dummy-appliances 1,2,3,4 --dummy-sensors 1,3,5\n``` \n\n### API Examples\n#### Reading and manipulating device states\n```python\nfrom fpga_i2c_bridge import I2CBridge, I2CGenericBinary, I2CDimmer, I2CRGBDimmer, I2CShutter\n\n# Appliance IDs\nLAMP_ID = 1\nDIMMER_ID = 2\nRGB_ID = 3\nSHUTTER_ID = 4\n\nif __name__ == '__main__':\n    # Create and initialize I2C Bridge\n    i2c = I2CBridge(i2c_bus=1, i2c_addr=0x3E)\n    \n    # Store device objects\n    lamp: I2CGenericBinary = i2c.appliances[LAMP_ID]\n    dimmer: I2CDimmer = i2c.appliances[DIMMER_ID]\n    rgb: I2CRGBDimmer = i2c.appliances[RGB_ID]\n    shutter: I2CShutter = i2c.appliances[SHUTTER_ID]\n    \n    # -- Read device states --\n    print(f\"Lamp is currently {'on' if lamp.state is True else 'off'}\")\n    print(f\"Dimmer brightness: {dimmer.state}\")\n    print(f\"RGB lamp color: {rgb.state}\")\n    print(f\"Shutter state: {shutter.state}\")\n    \n    # -- Manipulate devices --\n    # Turn on lamp\n    lamp.turn_on()\n    \n    # Set dimmer to 50% brightness\n    dimmer.set_brightness(0.5)\n    \n    # Set RGB lamp to orange-ish\n    rgb.set_color((1.0, 0.7, 0.0))\n    \n    # Move shutter up fully\n    shutter.move_up_full()\n```\n\n#### Using callback handlers\n```python\nfrom fpga_i2c_bridge import I2CBridge, I2CShutter, I2CShutterControlSensor\n\n# Assuming a shutter is found under appliance ID 4\nSHUTTER_ID = 4\n\n# Assuming a shutter is found under sensor ID 0\nSHUTTER_SENSOR_ID = 0\n\nif __name__ == '__main__':\n    # Create and initialize I2C Bridge\n    i2c = I2CBridge(i2c_bus=1, i2c_addr=0x3E)\n\n    # Store device objects\n    shutter_appliance: I2CShutter = i2c.appliances[SHUTTER_ID]\n    shutter_sensor: I2CShutterControlSensor = i2c.sensors[SHUTTER_SENSOR_ID]\n\n    # Register handlers for the shutter sensor\n    @shutter_sensor.register_full_down_handler()\n    def on_full_down():\n        print(\"Request to move down\")\n        shutter_appliance.move_down_full()\n\n    @shutter_sensor.register_full_up_handler()\n    def on_full_up():\n        print(\"Request to move up\")\n        shutter_appliance.move_up()\n\n    # Register handler for the shutter appliance\n    @shutter_appliance.register_update_handler()\n    def on_appliance_update():\n        print(f\"The shutter {shutter_appliance} updated its state to {shutter_appliance.state}\")\n\n    # Enable polling\n    i2c.start_polling()\n\n    # Loop and wait for input\n    print(\"Press CTRL-C to quit.\")\n    try:\n        while True:\n            pass\n    except KeyboardInterrupt:\n        pass\n```\n\n## Protocol specification\nThis section describes the protocol used for communications between the device using this library (hereafter referred to as the \"gateway\") and a connected I2C device (the \"bridge\").\n\nThe bridge operates as an I2C slave on any address (by default, the library assumes this address to be `0x3E`, but this can be changed via the `--addr` command line switch, as outlined above.)\n\n### Commands\n\nCommand messages sent to the I2C bridge consist of a command-dependent **opcode** byte as well as several **parameter** bytes. The amount of parameter data depends on the command used, and can range between 0 and 4 bytes in length.\n\nFinally, 2 bytes of **CRC** data are appended at the end of the message, calculated from the opcode and parameter bytes using the polynomial x^16 + x^13 + x^11 + x^10 + x^9 + x^8 + x^4 + x^2 + 1 (encoded as `0x2F15` when omitting the MSB).\n\nThe following table gives a brief overview over the different commands, their opcodes and parameters:\n\n| Command             | Opcode | Parameters              | Description                             |\n| ------------------- |:------:| ----------------------- | --------------------------------------- |\n| Get appliance state | `0x00` | Appliance ID            | Query an appliance's current state      |\n| Get appliance type  | `0x01` | Appliance ID            | Query an appliances' type               |\n| Get sensor type     | `0x02` | Sensor ID               | Query a sensor's type                   |\n| Set appliance state | `0x10` | Appliance ID, new state | Set state of an appliance               |\n| Get bridge status   | `0x20` | -                       | Queries bridge version and device count |\n| Reset bridge        | `0x2F` | -                       | Reset bridge hardware                   |\n| Poll events         | `0x30` | -                       | Poll for new input and update events    |\n| Repeat last message | `0x40` | -                       | Request last message to be sent again   |\n\nThe bridge prepares responses to each command, which do not necessarily have to be read by the gateway. Responses are always 8 bytes long and contain the following:\n\n| Byte | Meaning                                                    |\n| ----:| ---------------------------------------------------------- |\n|   1  | Status code: OK (`0xF0`), Error (`0xF1`), No data (`0xF2`) |\n| 2..6 | Response data (padded with `0x00` to 5 bytes)              |\n| 7..8 | CRC data                                                   |\n\nShould a command result in an error, the response data includes the error codes and some relevant parameters. (See appendix.)\n\n#### Get appliance state (`0x00`)\n\nRequests the current state of an appliance.\n\n- **Parameters:** Appliance ID (1 byte)\n- **Expected response:** Appliance ID repeated (1 byte), Appliance state (3 bytes)\n- **Error cases:**\n    - If an unknown appliance ID is supplied, responds with error code `0x20` (Unknown device) followed by the erroneous appliance ID\n\n##### Example\n\n| Command                       | Response                                 |\n| ----------------------------- | ---------------------------------------- |\n| `00 01 2F 15`                 | `F0 01 00 00 01 00 4F 38`                |\n| Get state of appliance `0x01` | OK, Appliance `0x01` state is `0x000001` |\n\n##### Example for error on unknown appliance\n\n| Command                       | Response                                 |\n| ----------------------------- | ---------------------------------------- |\n| `00 04 BC 54`                 | `F1 20 04 00 00 00 2C 57`                |\n| Get state of appliance `0x04` | Error: Unknown appliance `0x04`          |\n\n\n#### Get appliance type (`0x01`)\n\nRequests the type of an appliance.\n\n- **Parameters:** Appliance ID (1 byte)\n- **Expected response:** Appliance ID repeated (1 byte), Appliance type identifier (1 bytes, see appendix) or `0x00` if the given appliance ID is not present\n- **Error cases:**\n    - If an unknown appliance ID is supplied, responds with error code `0x20` (Unknown device) followed by the erroneous appliance ID\n\n##### Example\n\n| Command                       | Response                                  |\n| ----------------------------- | ----------------------------------------- |\n| `01 01 D1 22`                 | `F0 01 02 00 00 00 75 8B`                 |\n| Get type of appliance `0x01`  | OK, Appliance `0x01` is a Dimmer (`0x02`) |\n\n##### Example for error on unknown appliance\n\n| Command                      | Response                                 |\n| ---------------------------- | ---------------------------------------- |\n| `01 FF B1 29`                | `F1 20 FF 00 00 00 D4 71`                |\n| Get type of appliance `0xFF` | Error: Unknown appliance `0xFF`          |\n\n\n#### Get sensor type (`0x02`)\n\nRequests the type of a sensor.\n\n- **Parameters:** Sensor ID (1 byte)\n- **Expected response:** Sensor ID repeated (1 byte), Sensor type identifier (1 bytes, see appendix)\n- **Error cases:**\n    - If an unknown sensor ID is supplied, responds with error code `0x20` (Unknown device) followed by the erroneous sensor ID\n\n##### Example\n\n| Command                   | Response                               |\n| --------------------------| -------------------------------------- |\n| `02 00 D3 7B`             | `F0 00 01 00 00 00 F7 ED`              |\n| Get type of sensor `0x00` | OK, Sensor `0x00` is a Button (`0x01`) |\n\n##### Example for error on unknown sensor\n\n| Command                   | Response                     |\n| ------------------------- | ---------------------------- |\n| `02 FF 9C 65`             | `F1 20 FF 00 00 00 D4 71`    |\n| Get type of sensor `0xFF` | Error: Unknown sensor `0xFF` |\n\n\n#### Set appliance state (`0x10`)\n\nRequests to set the state of an appliance.\n\n- **Parameters:** Appliance ID (1 byte), new state (3 bytes)\n- **Expected response:** Empty response\n- **Error cases:**\n    - If an unknown appliance ID is supplied, responds with error code `0x20` (Unknown device) followed by the erroneous appliance ID\n\n##### Example\n\n| Command                                  | Response                  |\n| ---------------------------------------- | ------------------------- |\n| `10 02 FF 77 00 C7 6C`                   | `F0 00 00 00 00 00 7D 3E` |\n| Set appliance `0x02` to state `0xFF7700` | OK                        |\n\n##### Example for error on unknown appliance\n\n| Command                                  | Response                        |\n| ---------------------------------------- | ------------------------------- |\n| `10 49 12 34 56 4A 63`                   | `F1 20 49 00 00 00 A2 25`       |\n| Set appliance `0x49` to state `0x123456` | Error: Unknown appliance `0x49` |\n\n\n#### Get bridge status (`0x20`)\n\nRetrieves the bridge version as well as the highest valid appliance and sensor IDs each. Depending on the configuration, not all device IDs are necessarily assigned.\n\n- **Parameters:** None\n- **Expected response:** Bridge version (2 bytes), highest appliance ID (1 byte), highest sensor ID (1 byte)\n- **Error cases:** None\n\n##### Example\n\n| Command    | Response                                                                           |\n| ---------- | ---------------------------------------------------------------------------------- |\n| `20 71 E1` | `F0 DE AD 04 05 00 53 73`                                                          |\n| Get status | OK, version is 0xDEAD, highest appliance ID is `0x04`, highest sensor ID is `0x05` |\n\n\n#### Reset bridge (`0x2F`)\n\nRequests the bridge hardware to reinitialize. What this means is up to the bridge implementation, but usually should put the hardware into a sane state. Reinitialization should also not take more than a couple of cycles.\n\n- **Parameters:** None\n- **Expected response:** Empty\n- **Error cases:** None\n\n##### Example\n\n| Command      | Response                  |\n| ------------ | ------------------------- |\n| `2F EB 37`   | `F0 00 00 00 00 00 7D 3E` |\n| Reset bridge | OK                        |\n\n\n#### Poll events (`0x30`)\n\nReceives a single input or update event from the bridge, if there are any. An update event describes an intrinsic, spontaneous change of an appliance's state without user input, while input events are fired by a sensor that has been triggered.\n\nIf there are no pending events, the bridge is expected to send a \"No data\" (`0xF2`) status response. The API keeps repeatedly sending this command until it receives such a response, to clear any event buffers the bridge might have.\n\n- **Parameters:** None\n- **Expected response:** Event data (5 bytes, see appendix) or \"No data\"\n- **Error cases:** None\n\n\n##### Example: Receiving an input event\n\n| Command        | Response                                                              |\n| -------------- | --------------------------------------------------------------------- |\n| `30 DE 9B`     | `F0 00 01 00 00 01 D8 F8`                                             |\n| Poll for event | OK, Input event (`0x00`) for sensor ID `0x01`, data: `0x000001`       |\n\n##### Example: Receiving an update event\n\n| Command        | Response                                                                 |\n| -------------- | ------------------------------------------------------------------------ |\n| `30 DE 9B`     | `F0 01 03 00 00 00 FF 58`                                                |\n| Poll for event | OK, Update event (`0x01`) for appliance ID `0x03`, new state: `0x000000` |\n\n##### Example: No new events\n\n| Command        | Response                  |\n| -------------- | ------------------------- |\n| `30 DE 9B`     | `F2 00 00 00 00 00 5F 49` |\n| Poll for event | No data                   |\n\n\n#### Repeat last message (`0x40`)\n\nRequests the last response to be sent again. This is used by the API in case it encounters a CRC checksum mismatch in any response. The bridge should always keep track of the last response it sent (that was not a CRC error response) and repeat it.\n\nSending this command intentionally before any other command results in undefined behavior.\n\n- **Parameters:** none\n- **Expected response:** Depends on the previous command\n- **Error cases:** Depends on the previous command\n\n##### Example: Repeating a previous response in case of a CRC error\n\n| Command                                  | Response                  |\n| ---------------------------------------- | ------------------------- |\n| `10 00 00 00 01 7E 4A`                   | `F0 00 00 00 00 10 7D 3E` |\n| Set appliance `0x00` to state `0x000001` | OK (corrupted)            |\n| `40 E3 C2`                               | `F0 00 00 00 00 00 7D 3E` |\n| Repeat last message                      | OK (valid)                |\n\n\n### Appendix\n\n#### Error response codes\n\n| Code   | Error                      | Parameters                                        |\n|:------:| -------------------------- | ------------------------------------------------- |\n| `0x10` | Unknown command opcode     | Unrecognized opcode, repeated                     |\n| `0x20` | No such device             | Unrecognized appliance or sensor ID, repeated     |\n| `0x30` | CRC failure, please repeat | Calculated (nonzero) checksum of received message |\n| `0xFF` | Unknown failure            | -                                                 |\n\n\n#### Event data\n\n##### Input events\n\nAn input event gets fired by a sensor that has been triggered, e.g. when a button has been pressed, or similar. The event contains the ID of the sensor as well as the data it is reporting.\n\n| Byte | Content                       |\n| ----:| ----------------------------- |\n| 1    | `0x00`                        |\n| 2    | ID of sensor that fired event |\n| 3..5 | Sensor payload                |\n\n##### Update events\n\nAn update event gets fired when an appliance has changed its state by itself, thus notifying the API about its new state. The event contains the ID of the appliance as well as its new state.\n\n| Byte | Content                            |\n| ----:| ---------------------------------- |\n| 1    | `0x01`                             |\n| 2    | ID of appliance that changed state |\n| 3..5 | New state of appliance             |\n\n\n#### Appliance type identifiers\n\n| Code   | Appliance type |\n|:------:| -------------- |\n| `0x01` | Switch         |\n| `0x02` | Dimmer         |\n| `0x03` | RGB Dimmer     |\n| `0x04` | Shutter        |\n\n\n#### Sensor type identifiers\n\n| Code   | Sensor type     |\n|:------:| --------------- |\n| `0x01` | Button          |\n| `0x02` | Toggle          |\n| `0x03` | Dimmer cycle    |\n| `0x04` | RGB cycle       |\n| `0x05` | Shutter control |", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "fpga-i2c-bridge", "package_url": "https://pypi.org/project/fpga-i2c-bridge/", "platform": "", "project_url": "https://pypi.org/project/fpga-i2c-bridge/", "project_urls": null, "release_url": "https://pypi.org/project/fpga-i2c-bridge/0.2.5/", "requires_dist": null, "requires_python": ">=3.7", "summary": "A library for managing and remotely controlling devices connected to one or several bridges, which in turn are communicated with via a specialized I2C protocol. Intended for a Smart Home FPGA solution that was created as part of a Bachelor's thesis.", "version": "0.2.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>FPGA I2C Bridge API</h1>\n<p>A library for managing and remotely controlling devices connected to one or several bridges, which in turn are communicated with via a specialized I\u00b2C protocol. Intended for a Smart Home FPGA solution that was created as part of a Bachelor's thesis.</p>\n<p>Includes a high-level API as well as a low-level debugging shell.</p>\n<h2>Installation</h2>\n<pre><code>pip install fpga-i2c-bridge\n</code></pre>\n<h2>Usage</h2>\n<h3>Interactive shell</h3>\n<p>On a device with I2C support, run:</p>\n<pre><code>python -m fpga_i2c_bridge\n</code></pre>\n<p>Use the <code>--addr</code> and <code>--bus</code> switches to adjust I2C bus and address values, respectively.</p>\n<p>To run with simulated dummy devices only, run instead:</p>\n<pre><code>python -m fpga_i2c_bridge --dummy\n</code></pre>\n<p>Use <code>--dummy-appliances</code> and <code>--dummy-sensors</code> to supply a comma-seperated list of device types to simulate. For example:</p>\n<pre><code>python -m fpga_i2c_bridge --dummy --dummy-appliances 1,2,3,4 --dummy-sensors 1,3,5\n</code></pre>\n<h3>API Examples</h3>\n<h4>Reading and manipulating device states</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">fpga_i2c_bridge</span> <span class=\"kn\">import</span> <span class=\"n\">I2CBridge</span><span class=\"p\">,</span> <span class=\"n\">I2CGenericBinary</span><span class=\"p\">,</span> <span class=\"n\">I2CDimmer</span><span class=\"p\">,</span> <span class=\"n\">I2CRGBDimmer</span><span class=\"p\">,</span> <span class=\"n\">I2CShutter</span>\n\n<span class=\"c1\"># Appliance IDs</span>\n<span class=\"n\">LAMP_ID</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">DIMMER_ID</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">RGB_ID</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n<span class=\"n\">SHUTTER_ID</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Create and initialize I2C Bridge</span>\n    <span class=\"n\">i2c</span> <span class=\"o\">=</span> <span class=\"n\">I2CBridge</span><span class=\"p\">(</span><span class=\"n\">i2c_bus</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">i2c_addr</span><span class=\"o\">=</span><span class=\"mh\">0x3E</span><span class=\"p\">)</span>\n    \n    <span class=\"c1\"># Store device objects</span>\n    <span class=\"n\">lamp</span><span class=\"p\">:</span> <span class=\"n\">I2CGenericBinary</span> <span class=\"o\">=</span> <span class=\"n\">i2c</span><span class=\"o\">.</span><span class=\"n\">appliances</span><span class=\"p\">[</span><span class=\"n\">LAMP_ID</span><span class=\"p\">]</span>\n    <span class=\"n\">dimmer</span><span class=\"p\">:</span> <span class=\"n\">I2CDimmer</span> <span class=\"o\">=</span> <span class=\"n\">i2c</span><span class=\"o\">.</span><span class=\"n\">appliances</span><span class=\"p\">[</span><span class=\"n\">DIMMER_ID</span><span class=\"p\">]</span>\n    <span class=\"n\">rgb</span><span class=\"p\">:</span> <span class=\"n\">I2CRGBDimmer</span> <span class=\"o\">=</span> <span class=\"n\">i2c</span><span class=\"o\">.</span><span class=\"n\">appliances</span><span class=\"p\">[</span><span class=\"n\">RGB_ID</span><span class=\"p\">]</span>\n    <span class=\"n\">shutter</span><span class=\"p\">:</span> <span class=\"n\">I2CShutter</span> <span class=\"o\">=</span> <span class=\"n\">i2c</span><span class=\"o\">.</span><span class=\"n\">appliances</span><span class=\"p\">[</span><span class=\"n\">SHUTTER_ID</span><span class=\"p\">]</span>\n    \n    <span class=\"c1\"># -- Read device states --</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Lamp is currently </span><span class=\"si\">{</span><span class=\"s1\">'on'</span> <span class=\"k\">if</span> <span class=\"n\">lamp</span><span class=\"o\">.</span><span class=\"n\">state</span> <span class=\"ow\">is</span> <span class=\"kc\">True</span> <span class=\"k\">else</span> <span class=\"s1\">'off'</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Dimmer brightness: </span><span class=\"si\">{</span><span class=\"n\">dimmer</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"RGB lamp color: </span><span class=\"si\">{</span><span class=\"n\">rgb</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Shutter state: </span><span class=\"si\">{</span><span class=\"n\">shutter</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n    \n    <span class=\"c1\"># -- Manipulate devices --</span>\n    <span class=\"c1\"># Turn on lamp</span>\n    <span class=\"n\">lamp</span><span class=\"o\">.</span><span class=\"n\">turn_on</span><span class=\"p\">()</span>\n    \n    <span class=\"c1\"># Set dimmer to 50% brightness</span>\n    <span class=\"n\">dimmer</span><span class=\"o\">.</span><span class=\"n\">set_brightness</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n    \n    <span class=\"c1\"># Set RGB lamp to orange-ish</span>\n    <span class=\"n\">rgb</span><span class=\"o\">.</span><span class=\"n\">set_color</span><span class=\"p\">((</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">))</span>\n    \n    <span class=\"c1\"># Move shutter up fully</span>\n    <span class=\"n\">shutter</span><span class=\"o\">.</span><span class=\"n\">move_up_full</span><span class=\"p\">()</span>\n</pre>\n<h4>Using callback handlers</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">fpga_i2c_bridge</span> <span class=\"kn\">import</span> <span class=\"n\">I2CBridge</span><span class=\"p\">,</span> <span class=\"n\">I2CShutter</span><span class=\"p\">,</span> <span class=\"n\">I2CShutterControlSensor</span>\n\n<span class=\"c1\"># Assuming a shutter is found under appliance ID 4</span>\n<span class=\"n\">SHUTTER_ID</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n\n<span class=\"c1\"># Assuming a shutter is found under sensor ID 0</span>\n<span class=\"n\">SHUTTER_SENSOR_ID</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Create and initialize I2C Bridge</span>\n    <span class=\"n\">i2c</span> <span class=\"o\">=</span> <span class=\"n\">I2CBridge</span><span class=\"p\">(</span><span class=\"n\">i2c_bus</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">i2c_addr</span><span class=\"o\">=</span><span class=\"mh\">0x3E</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Store device objects</span>\n    <span class=\"n\">shutter_appliance</span><span class=\"p\">:</span> <span class=\"n\">I2CShutter</span> <span class=\"o\">=</span> <span class=\"n\">i2c</span><span class=\"o\">.</span><span class=\"n\">appliances</span><span class=\"p\">[</span><span class=\"n\">SHUTTER_ID</span><span class=\"p\">]</span>\n    <span class=\"n\">shutter_sensor</span><span class=\"p\">:</span> <span class=\"n\">I2CShutterControlSensor</span> <span class=\"o\">=</span> <span class=\"n\">i2c</span><span class=\"o\">.</span><span class=\"n\">sensors</span><span class=\"p\">[</span><span class=\"n\">SHUTTER_SENSOR_ID</span><span class=\"p\">]</span>\n\n    <span class=\"c1\"># Register handlers for the shutter sensor</span>\n    <span class=\"nd\">@shutter_sensor</span><span class=\"o\">.</span><span class=\"n\">register_full_down_handler</span><span class=\"p\">()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">on_full_down</span><span class=\"p\">():</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Request to move down\"</span><span class=\"p\">)</span>\n        <span class=\"n\">shutter_appliance</span><span class=\"o\">.</span><span class=\"n\">move_down_full</span><span class=\"p\">()</span>\n\n    <span class=\"nd\">@shutter_sensor</span><span class=\"o\">.</span><span class=\"n\">register_full_up_handler</span><span class=\"p\">()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">on_full_up</span><span class=\"p\">():</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Request to move up\"</span><span class=\"p\">)</span>\n        <span class=\"n\">shutter_appliance</span><span class=\"o\">.</span><span class=\"n\">move_up</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># Register handler for the shutter appliance</span>\n    <span class=\"nd\">@shutter_appliance</span><span class=\"o\">.</span><span class=\"n\">register_update_handler</span><span class=\"p\">()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">on_appliance_update</span><span class=\"p\">():</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"The shutter </span><span class=\"si\">{</span><span class=\"n\">shutter_appliance</span><span class=\"si\">}</span><span class=\"s2\"> updated its state to </span><span class=\"si\">{</span><span class=\"n\">shutter_appliance</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Enable polling</span>\n    <span class=\"n\">i2c</span><span class=\"o\">.</span><span class=\"n\">start_polling</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># Loop and wait for input</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Press CTRL-C to quit.\"</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>\n    <span class=\"k\">except</span> <span class=\"ne\">KeyboardInterrupt</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n</pre>\n<h2>Protocol specification</h2>\n<p>This section describes the protocol used for communications between the device using this library (hereafter referred to as the \"gateway\") and a connected I2C device (the \"bridge\").</p>\n<p>The bridge operates as an I2C slave on any address (by default, the library assumes this address to be <code>0x3E</code>, but this can be changed via the <code>--addr</code> command line switch, as outlined above.)</p>\n<h3>Commands</h3>\n<p>Command messages sent to the I2C bridge consist of a command-dependent <strong>opcode</strong> byte as well as several <strong>parameter</strong> bytes. The amount of parameter data depends on the command used, and can range between 0 and 4 bytes in length.</p>\n<p>Finally, 2 bytes of <strong>CRC</strong> data are appended at the end of the message, calculated from the opcode and parameter bytes using the polynomial x^16 + x^13 + x^11 + x^10 + x^9 + x^8 + x^4 + x^2 + 1 (encoded as <code>0x2F15</code> when omitting the MSB).</p>\n<p>The following table gives a brief overview over the different commands, their opcodes and parameters:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th align=\"center\">Opcode</th>\n<th>Parameters</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Get appliance state</td>\n<td align=\"center\"><code>0x00</code></td>\n<td>Appliance ID</td>\n<td>Query an appliance's current state</td>\n</tr>\n<tr>\n<td>Get appliance type</td>\n<td align=\"center\"><code>0x01</code></td>\n<td>Appliance ID</td>\n<td>Query an appliances' type</td>\n</tr>\n<tr>\n<td>Get sensor type</td>\n<td align=\"center\"><code>0x02</code></td>\n<td>Sensor ID</td>\n<td>Query a sensor's type</td>\n</tr>\n<tr>\n<td>Set appliance state</td>\n<td align=\"center\"><code>0x10</code></td>\n<td>Appliance ID, new state</td>\n<td>Set state of an appliance</td>\n</tr>\n<tr>\n<td>Get bridge status</td>\n<td align=\"center\"><code>0x20</code></td>\n<td>-</td>\n<td>Queries bridge version and device count</td>\n</tr>\n<tr>\n<td>Reset bridge</td>\n<td align=\"center\"><code>0x2F</code></td>\n<td>-</td>\n<td>Reset bridge hardware</td>\n</tr>\n<tr>\n<td>Poll events</td>\n<td align=\"center\"><code>0x30</code></td>\n<td>-</td>\n<td>Poll for new input and update events</td>\n</tr>\n<tr>\n<td>Repeat last message</td>\n<td align=\"center\"><code>0x40</code></td>\n<td>-</td>\n<td>Request last message to be sent again</td>\n</tr></tbody></table>\n<p>The bridge prepares responses to each command, which do not necessarily have to be read by the gateway. Responses are always 8 bytes long and contain the following:</p>\n<table>\n<thead>\n<tr>\n<th align=\"right\">Byte</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"right\">1</td>\n<td>Status code: OK (<code>0xF0</code>), Error (<code>0xF1</code>), No data (<code>0xF2</code>)</td>\n</tr>\n<tr>\n<td align=\"right\">2..6</td>\n<td>Response data (padded with <code>0x00</code> to 5 bytes)</td>\n</tr>\n<tr>\n<td align=\"right\">7..8</td>\n<td>CRC data</td>\n</tr></tbody></table>\n<p>Should a command result in an error, the response data includes the error codes and some relevant parameters. (See appendix.)</p>\n<h4>Get appliance state (<code>0x00</code>)</h4>\n<p>Requests the current state of an appliance.</p>\n<ul>\n<li><strong>Parameters:</strong> Appliance ID (1 byte)</li>\n<li><strong>Expected response:</strong> Appliance ID repeated (1 byte), Appliance state (3 bytes)</li>\n<li><strong>Error cases:</strong>\n<ul>\n<li>If an unknown appliance ID is supplied, responds with error code <code>0x20</code> (Unknown device) followed by the erroneous appliance ID</li>\n</ul>\n</li>\n</ul>\n<h5>Example</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>00 01 2F 15</code></td>\n<td><code>F0 01 00 00 01 00 4F 38</code></td>\n</tr>\n<tr>\n<td>Get state of appliance <code>0x01</code></td>\n<td>OK, Appliance <code>0x01</code> state is <code>0x000001</code></td>\n</tr></tbody></table>\n<h5>Example for error on unknown appliance</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>00 04 BC 54</code></td>\n<td><code>F1 20 04 00 00 00 2C 57</code></td>\n</tr>\n<tr>\n<td>Get state of appliance <code>0x04</code></td>\n<td>Error: Unknown appliance <code>0x04</code></td>\n</tr></tbody></table>\n<h4>Get appliance type (<code>0x01</code>)</h4>\n<p>Requests the type of an appliance.</p>\n<ul>\n<li><strong>Parameters:</strong> Appliance ID (1 byte)</li>\n<li><strong>Expected response:</strong> Appliance ID repeated (1 byte), Appliance type identifier (1 bytes, see appendix) or <code>0x00</code> if the given appliance ID is not present</li>\n<li><strong>Error cases:</strong>\n<ul>\n<li>If an unknown appliance ID is supplied, responds with error code <code>0x20</code> (Unknown device) followed by the erroneous appliance ID</li>\n</ul>\n</li>\n</ul>\n<h5>Example</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>01 01 D1 22</code></td>\n<td><code>F0 01 02 00 00 00 75 8B</code></td>\n</tr>\n<tr>\n<td>Get type of appliance <code>0x01</code></td>\n<td>OK, Appliance <code>0x01</code> is a Dimmer (<code>0x02</code>)</td>\n</tr></tbody></table>\n<h5>Example for error on unknown appliance</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>01 FF B1 29</code></td>\n<td><code>F1 20 FF 00 00 00 D4 71</code></td>\n</tr>\n<tr>\n<td>Get type of appliance <code>0xFF</code></td>\n<td>Error: Unknown appliance <code>0xFF</code></td>\n</tr></tbody></table>\n<h4>Get sensor type (<code>0x02</code>)</h4>\n<p>Requests the type of a sensor.</p>\n<ul>\n<li><strong>Parameters:</strong> Sensor ID (1 byte)</li>\n<li><strong>Expected response:</strong> Sensor ID repeated (1 byte), Sensor type identifier (1 bytes, see appendix)</li>\n<li><strong>Error cases:</strong>\n<ul>\n<li>If an unknown sensor ID is supplied, responds with error code <code>0x20</code> (Unknown device) followed by the erroneous sensor ID</li>\n</ul>\n</li>\n</ul>\n<h5>Example</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>02 00 D3 7B</code></td>\n<td><code>F0 00 01 00 00 00 F7 ED</code></td>\n</tr>\n<tr>\n<td>Get type of sensor <code>0x00</code></td>\n<td>OK, Sensor <code>0x00</code> is a Button (<code>0x01</code>)</td>\n</tr></tbody></table>\n<h5>Example for error on unknown sensor</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>02 FF 9C 65</code></td>\n<td><code>F1 20 FF 00 00 00 D4 71</code></td>\n</tr>\n<tr>\n<td>Get type of sensor <code>0xFF</code></td>\n<td>Error: Unknown sensor <code>0xFF</code></td>\n</tr></tbody></table>\n<h4>Set appliance state (<code>0x10</code>)</h4>\n<p>Requests to set the state of an appliance.</p>\n<ul>\n<li><strong>Parameters:</strong> Appliance ID (1 byte), new state (3 bytes)</li>\n<li><strong>Expected response:</strong> Empty response</li>\n<li><strong>Error cases:</strong>\n<ul>\n<li>If an unknown appliance ID is supplied, responds with error code <code>0x20</code> (Unknown device) followed by the erroneous appliance ID</li>\n</ul>\n</li>\n</ul>\n<h5>Example</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>10 02 FF 77 00 C7 6C</code></td>\n<td><code>F0 00 00 00 00 00 7D 3E</code></td>\n</tr>\n<tr>\n<td>Set appliance <code>0x02</code> to state <code>0xFF7700</code></td>\n<td>OK</td>\n</tr></tbody></table>\n<h5>Example for error on unknown appliance</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>10 49 12 34 56 4A 63</code></td>\n<td><code>F1 20 49 00 00 00 A2 25</code></td>\n</tr>\n<tr>\n<td>Set appliance <code>0x49</code> to state <code>0x123456</code></td>\n<td>Error: Unknown appliance <code>0x49</code></td>\n</tr></tbody></table>\n<h4>Get bridge status (<code>0x20</code>)</h4>\n<p>Retrieves the bridge version as well as the highest valid appliance and sensor IDs each. Depending on the configuration, not all device IDs are necessarily assigned.</p>\n<ul>\n<li><strong>Parameters:</strong> None</li>\n<li><strong>Expected response:</strong> Bridge version (2 bytes), highest appliance ID (1 byte), highest sensor ID (1 byte)</li>\n<li><strong>Error cases:</strong> None</li>\n</ul>\n<h5>Example</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>20 71 E1</code></td>\n<td><code>F0 DE AD 04 05 00 53 73</code></td>\n</tr>\n<tr>\n<td>Get status</td>\n<td>OK, version is 0xDEAD, highest appliance ID is <code>0x04</code>, highest sensor ID is <code>0x05</code></td>\n</tr></tbody></table>\n<h4>Reset bridge (<code>0x2F</code>)</h4>\n<p>Requests the bridge hardware to reinitialize. What this means is up to the bridge implementation, but usually should put the hardware into a sane state. Reinitialization should also not take more than a couple of cycles.</p>\n<ul>\n<li><strong>Parameters:</strong> None</li>\n<li><strong>Expected response:</strong> Empty</li>\n<li><strong>Error cases:</strong> None</li>\n</ul>\n<h5>Example</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>2F EB 37</code></td>\n<td><code>F0 00 00 00 00 00 7D 3E</code></td>\n</tr>\n<tr>\n<td>Reset bridge</td>\n<td>OK</td>\n</tr></tbody></table>\n<h4>Poll events (<code>0x30</code>)</h4>\n<p>Receives a single input or update event from the bridge, if there are any. An update event describes an intrinsic, spontaneous change of an appliance's state without user input, while input events are fired by a sensor that has been triggered.</p>\n<p>If there are no pending events, the bridge is expected to send a \"No data\" (<code>0xF2</code>) status response. The API keeps repeatedly sending this command until it receives such a response, to clear any event buffers the bridge might have.</p>\n<ul>\n<li><strong>Parameters:</strong> None</li>\n<li><strong>Expected response:</strong> Event data (5 bytes, see appendix) or \"No data\"</li>\n<li><strong>Error cases:</strong> None</li>\n</ul>\n<h5>Example: Receiving an input event</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>30 DE 9B</code></td>\n<td><code>F0 00 01 00 00 01 D8 F8</code></td>\n</tr>\n<tr>\n<td>Poll for event</td>\n<td>OK, Input event (<code>0x00</code>) for sensor ID <code>0x01</code>, data: <code>0x000001</code></td>\n</tr></tbody></table>\n<h5>Example: Receiving an update event</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>30 DE 9B</code></td>\n<td><code>F0 01 03 00 00 00 FF 58</code></td>\n</tr>\n<tr>\n<td>Poll for event</td>\n<td>OK, Update event (<code>0x01</code>) for appliance ID <code>0x03</code>, new state: <code>0x000000</code></td>\n</tr></tbody></table>\n<h5>Example: No new events</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>30 DE 9B</code></td>\n<td><code>F2 00 00 00 00 00 5F 49</code></td>\n</tr>\n<tr>\n<td>Poll for event</td>\n<td>No data</td>\n</tr></tbody></table>\n<h4>Repeat last message (<code>0x40</code>)</h4>\n<p>Requests the last response to be sent again. This is used by the API in case it encounters a CRC checksum mismatch in any response. The bridge should always keep track of the last response it sent (that was not a CRC error response) and repeat it.</p>\n<p>Sending this command intentionally before any other command results in undefined behavior.</p>\n<ul>\n<li><strong>Parameters:</strong> none</li>\n<li><strong>Expected response:</strong> Depends on the previous command</li>\n<li><strong>Error cases:</strong> Depends on the previous command</li>\n</ul>\n<h5>Example: Repeating a previous response in case of a CRC error</h5>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Response</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>10 00 00 00 01 7E 4A</code></td>\n<td><code>F0 00 00 00 00 10 7D 3E</code></td>\n</tr>\n<tr>\n<td>Set appliance <code>0x00</code> to state <code>0x000001</code></td>\n<td>OK (corrupted)</td>\n</tr>\n<tr>\n<td><code>40 E3 C2</code></td>\n<td><code>F0 00 00 00 00 00 7D 3E</code></td>\n</tr>\n<tr>\n<td>Repeat last message</td>\n<td>OK (valid)</td>\n</tr></tbody></table>\n<h3>Appendix</h3>\n<h4>Error response codes</h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Code</th>\n<th>Error</th>\n<th>Parameters</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code>0x10</code></td>\n<td>Unknown command opcode</td>\n<td>Unrecognized opcode, repeated</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x20</code></td>\n<td>No such device</td>\n<td>Unrecognized appliance or sensor ID, repeated</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x30</code></td>\n<td>CRC failure, please repeat</td>\n<td>Calculated (nonzero) checksum of received message</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0xFF</code></td>\n<td>Unknown failure</td>\n<td>-</td>\n</tr></tbody></table>\n<h4>Event data</h4>\n<h5>Input events</h5>\n<p>An input event gets fired by a sensor that has been triggered, e.g. when a button has been pressed, or similar. The event contains the ID of the sensor as well as the data it is reporting.</p>\n<table>\n<thead>\n<tr>\n<th align=\"right\">Byte</th>\n<th>Content</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"right\">1</td>\n<td><code>0x00</code></td>\n</tr>\n<tr>\n<td align=\"right\">2</td>\n<td>ID of sensor that fired event</td>\n</tr>\n<tr>\n<td align=\"right\">3..5</td>\n<td>Sensor payload</td>\n</tr></tbody></table>\n<h5>Update events</h5>\n<p>An update event gets fired when an appliance has changed its state by itself, thus notifying the API about its new state. The event contains the ID of the appliance as well as its new state.</p>\n<table>\n<thead>\n<tr>\n<th align=\"right\">Byte</th>\n<th>Content</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"right\">1</td>\n<td><code>0x01</code></td>\n</tr>\n<tr>\n<td align=\"right\">2</td>\n<td>ID of appliance that changed state</td>\n</tr>\n<tr>\n<td align=\"right\">3..5</td>\n<td>New state of appliance</td>\n</tr></tbody></table>\n<h4>Appliance type identifiers</h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Code</th>\n<th>Appliance type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code>0x01</code></td>\n<td>Switch</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x02</code></td>\n<td>Dimmer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x03</code></td>\n<td>RGB Dimmer</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x04</code></td>\n<td>Shutter</td>\n</tr></tbody></table>\n<h4>Sensor type identifiers</h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Code</th>\n<th>Sensor type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code>0x01</code></td>\n<td>Button</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x02</code></td>\n<td>Toggle</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x03</code></td>\n<td>Dimmer cycle</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x04</code></td>\n<td>RGB cycle</td>\n</tr>\n<tr>\n<td align=\"center\"><code>0x05</code></td>\n<td>Shutter control</td>\n</tr></tbody></table>\n\n          </div>"}, "last_serial": 7023967, "releases": {"0.2.4": [{"comment_text": "", "digests": {"md5": "8523080a0ca0a6d2d24fbdb5a86b5821", "sha256": "a84f697d06e66b8602f05acbc194ebf5157ea5525eca364b38d98598aa3b014f"}, "downloads": -1, "filename": "fpga_i2c_bridge-0.2.4-py3.8.egg", "has_sig": false, "md5_digest": "8523080a0ca0a6d2d24fbdb5a86b5821", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.7", "size": 19843, "upload_time": "2020-04-09T09:28:37", "upload_time_iso_8601": "2020-04-09T09:28:37.956260Z", "url": "https://files.pythonhosted.org/packages/02/25/eb4fb84f61551380889ce3c64ea98a1f89ce0aae06042f37d017f82f0f5f/fpga_i2c_bridge-0.2.4-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "39428984c0393f427a9d7cfb9f9bc54e", "sha256": "e074623c8dc09670d3dbb22d0f54645d35ab05ee9e598b2859c1784caf1d330f"}, "downloads": -1, "filename": "fpga_i2c_bridge-0.2.4-py3-none-any.whl", "has_sig": false, "md5_digest": "39428984c0393f427a9d7cfb9f9bc54e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 21285, "upload_time": "2020-04-09T09:28:36", "upload_time_iso_8601": "2020-04-09T09:28:36.815704Z", "url": "https://files.pythonhosted.org/packages/d1/8b/81de4294b3d075f73438c7212fc96e43cf5bba0a32362e4a4a981a3f8d19/fpga_i2c_bridge-0.2.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "45fe03ad6d7e7465cef413b777f08cd8", "sha256": "3d6d9c850bf29c883c9851eaa763af49cfe414e1438f565f9d69ed7426349b4a"}, "downloads": -1, "filename": "fpga-i2c-bridge-0.2.4.tar.gz", "has_sig": false, "md5_digest": "45fe03ad6d7e7465cef413b777f08cd8", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 16360, "upload_time": "2020-04-09T09:28:30", "upload_time_iso_8601": "2020-04-09T09:28:30.015826Z", "url": "https://files.pythonhosted.org/packages/4b/d6/c7c55cde09dca0f712920c77e32f2e749198734da3964abb3f7bc0b107d0/fpga-i2c-bridge-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "0a2ab78bd2b9c665ea3efa38a8ecb09b", "sha256": "e93e28804a200bfc262bce238dba49723348a6f6e7d6069c8733662dfdcc68a9"}, "downloads": -1, "filename": "fpga_i2c_bridge-0.2.5-py3.8.egg", "has_sig": false, "md5_digest": "0a2ab78bd2b9c665ea3efa38a8ecb09b", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.7", "size": 58368, "upload_time": "2020-04-15T11:14:05", "upload_time_iso_8601": "2020-04-15T11:14:05.929101Z", "url": "https://files.pythonhosted.org/packages/ea/d1/10b92d8c9ce08fc0b9bba96fe9341d15ada33bc719d33f7ac98026b39315/fpga_i2c_bridge-0.2.5-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "d00db41eeab8de32c8be24b3d3ed4f5b", "sha256": "6a8d6555d23d6fd6833d6d796566a7b6c810a7387ff2e7a5a60a5a733e129a97"}, "downloads": -1, "filename": "fpga-i2c-bridge-0.2.5.tar.gz", "has_sig": false, "md5_digest": "d00db41eeab8de32c8be24b3d3ed4f5b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 25472, "upload_time": "2020-04-15T11:14:16", "upload_time_iso_8601": "2020-04-15T11:14:16.917225Z", "url": "https://files.pythonhosted.org/packages/6d/a8/38b7d95c63097fb442f44a4e24e18d75bd497cbb3dd33c4bae37ce54e7cc/fpga-i2c-bridge-0.2.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0a2ab78bd2b9c665ea3efa38a8ecb09b", "sha256": "e93e28804a200bfc262bce238dba49723348a6f6e7d6069c8733662dfdcc68a9"}, "downloads": -1, "filename": "fpga_i2c_bridge-0.2.5-py3.8.egg", "has_sig": false, "md5_digest": "0a2ab78bd2b9c665ea3efa38a8ecb09b", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.7", "size": 58368, "upload_time": "2020-04-15T11:14:05", "upload_time_iso_8601": "2020-04-15T11:14:05.929101Z", "url": "https://files.pythonhosted.org/packages/ea/d1/10b92d8c9ce08fc0b9bba96fe9341d15ada33bc719d33f7ac98026b39315/fpga_i2c_bridge-0.2.5-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "d00db41eeab8de32c8be24b3d3ed4f5b", "sha256": "6a8d6555d23d6fd6833d6d796566a7b6c810a7387ff2e7a5a60a5a733e129a97"}, "downloads": -1, "filename": "fpga-i2c-bridge-0.2.5.tar.gz", "has_sig": false, "md5_digest": "d00db41eeab8de32c8be24b3d3ed4f5b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 25472, "upload_time": "2020-04-15T11:14:16", "upload_time_iso_8601": "2020-04-15T11:14:16.917225Z", "url": "https://files.pythonhosted.org/packages/6d/a8/38b7d95c63097fb442f44a4e24e18d75bd497cbb3dd33c4bae37ce54e7cc/fpga-i2c-bridge-0.2.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:00:38 2020"}