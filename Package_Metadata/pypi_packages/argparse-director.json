{"info": {"author": "Seth Neiman", "author_email": "seth@duckpapa.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "## ArgParseDirector\n#### **A simpler, more powerful way to configure complex python scripts and tools**\n\n**ArgParseDirector** is a drop-in replacement for python's ArgParse. It does everything ArgParse does and adds the following features:\n\n* Configuration files. Merges command line and configuration file argument values.\n* Supports configuration of argument values with code. ArgParseDirector configuration files are executable python.\n* Supports the creation of arguments that are only available from the configuration file - not from the command line.\n* Supports hierarchical arguments - multiple arguments passed as a group as a single entry in the parsed args.\n\nArgParseDirector is a simple extension of argparse that does all of the above with virtually no change to your current usage.\n\n#### Why ArgParseDirector\nThere are a number of good script configuration tools available - both drop-ins for argparse and more sophisticated tools. So why another one? In order to get more power than the simpler drop-ins and avoid the complexity of the sophisticated tools:\n\n* ArgParseDirector configuration files are just python. You already know how to write them. And you can generate a base file automatically.\n* Executable configuration files make it easy to handle complex relationships between argument values.\n* Having arguments not available from the command line allows flexibility without causing user confusion and error.\n* Hierachical/group arguments simplify startup code.\n\n#### Index\n[Installation](#install)  \n[Try it](#just-try-it)  \n[Quick Intro](#quick-and-dirty-intro)  \n[Summary](#summary)  \n* [The parser](#the-parser-class)\n* [Configuration files](#configuration-files)\n* [The command line](#command-line-usage)\n* [Matching and merging](#matching-and-merging-rules)\n* [Using groups](#using-groups)  \n* [Generating a config file](#generating-a-config-file)  \n\n[Extended Intro](#extended-intro)  \n\n#### Install\nThere are no dependencies outside of a standard python 3 installation. Type at the command line:\n\n`pip install argparse-director`\n\n#### Just try it\nThe easiest way to see how argparse_director works is to try it with some of your own argument configurations. Install argparse_director, grab one of your own scripts, and make the following changes:\n1. Change import, parser construction lines. And instead of starting your script, just print out the args:\n```\nfrom argparse_director import ArgParseDirector, Namespace, rec_print  # original: from argparse import ArgumentParser, Namespace\n...\nparser = ArgParseDirector()    # original: parser = ArgumentParser()\n...                            # same add_argument()\nargs = parser.parse_args()     # same parser_args()\n\n# dont run the script - just print out args - we ARE experimenting here!\nprint(args)                    # original: something like main(args) or start(args) - you know what to do\n```\n2. Now run it, and look at the what gets printed:\n```\n> ./yourscript\nNamespace(yourarg=value, yourarg2=value, ...)\n```\n3. Next generate a configuration file. After the line that prints your args add this:\n```\n# generate config file\nparser.gen_config_file('trial_config.py')\n\n```\nRun it, and then comment out the `parser.gen_config_file()` line - you don't want to keep remaking a base line config file!  \n\nTake a look at 'trial_config.py'. You will see that 3 python dictionaries have been created for you. Edit a few of the values in `config_args`, and run the script like this:\n```\n> ./yourscript --config_path trial_config.py\nNamespace(yourarg=value, yourarg2=value, ...)\n```\nYou'll see that Namespace has your defaults, but has picked up the values from 'trial_config.py' - because you told it to with `--config_path trial_config.py` on the command line.  \n\n4. Fool around  \nExperiment with this ... try some of your args from the command line, and edit some of them in 'trial_config.py'.  \nThe command line overrides the configuration file, and the configuration file overrides the defaults set in `add_argument()`.  \nAdd arguments to `config_args` to create args to your script that you can change in config, but users cannot change from the command line. Add python code to automatically set values, enforce related items or create args ... you will quickly see how this works.  \nTry `rec_print()` if you like. It pretty prints dictionaries and Namespaces - handy if you have a lot arguments.  \nThat's it - this isn't rocket science.\n\nBest to stay away from `config_groups` and `config_required` until you read a little more.\n\n\n#### Quick and Dirty Intro\nThis is a quick but less experimental way to get acquainted - there is an [extended intro](#extended-intro) below, as well.  \n\n* Change import and parser construction names.\n* Use same `parser.add_argument()` calls.\n```\nfrom argparse_director import ArgParseDirector\n\nparser = ArgParseDirector()\nparser.add_argument('--opt1',    default=25, type=int, arg_group='group1')\nparser.add_argument('positional',            type=int)\n```\nNotice new option `arg_group`. Each argument with this option is returned from `parse_args()` in the main Namespace, and in a separate Namespace with just that group's arguments. Arguments can be assigned to more than one group by sett `arg_group` with a tuple of name strings: `arg_group=('group1', 'group2')`.\n\nConfiguration files are straightforward: each has up to 3 python dictionaries: 1 each for arg configuration, group creation and required/positional args. None are mandatory - but if you have them they **MUST** be named `config_args`, `config_groups` and `config_required`, respectively. You can add any python code you like.\n```\n# use arbitrary python as needed\nvalue1 = 123\nvalue2 = 128 if value1<128 else 256\n\n# for setting command line arg options or creating new arguments only for config file ...\nconfig_args = {\n    'opt1' : value1,    # actual value and type not a string\n    'opt2' : value2,    # only usable from config file as there was no `add_argument()` for it\n}\n\n# for gathering args into groups\nconfig_groups = {\n    'group1' :  ['opt1', 'opt2'],\n    'group2' :  ['opt1']\n}\n\n# for positional args\nconfig_required = {\n    'positional' :    123456\n}\n```\nInvoke the configuration file from command line or in `parse_args()` call:\n```\n>./script.py 123456 --config_path config_file.py\nor\n>./script.py\nwith ...\nparser.parser_args(config_path='config_file.py')\n\ngenerates:\nNamespace(group1=Namespace(opt1=123, opt2=128), group2=Namespace(opt1=123), opt1=123, opt2=128, positional=123456))\n```\nRequired arguments are positional, as with argparse - they have to come immediately after script name.\n```\n>./script.py 54321 --config_path config_file.py\nNamespace(group1=Namespace(opt1=123, opt2=128), group2=Namespace(opt1=123), opt1=123, opt2=128, positional=54321)\n```\n* Use `add_argument()` as always, with additional `arg_group='group_name'` option to create groups. Create as many groups as you need. An argument can belong to more than one group - 'arg_group' can be a single group name or a tuple of group names.\n* Invoke from command line as always, with additonal `--config_path='config_file'`:\n    * `scriptname positional_args --config_path config_file optional_command_line_arguments`\n    * Positional arguments must immediately follow script name before '--config_path'.\n    * `--config_path` on the command line is optional - you can use `parser_args(config_path='config_file.py')` if you prefer.\n    * If you use neither, no config file will be used.\n* Command line overrides config file, config file overrides defaults. Use them all as needed.\n* Generate a baseline config file from parser with `parser.gen_config_file('file_name')`.\n* Config files are run with `exec()` - so use python code as you need in config file to enforce relationships, calculate values, even add arguments.\n\n### Summary\n##### The module:  \nInstall with `pip install argparse-director`  \nImport usually with `from argparse_director import ArgParseDirector, rec_print`  \nContains `ArgParseDirector` parser creation class, and function `rec_print()` for pretty printing Dictionaries and Namespaces\n\n##### The parser class\n**ArgParseDirector** is called just like **ArgumentParse**:\n* `parser = ArgParserDirector()`\n* It does not add or alter any arguments. It does create 2 additional functions, and adds arguments to 2:\n\n\n**`parser.add_argument()`** supports one additional argument `arg_group`, which takes a single group name string, or tuple of group name strings:  \n* `parser.add_argument('test', arg_group='work_group')`  \n* All arguments with the same group name are collected in their own Namespace which is included in the main argument Namespace returned by `parse_args()`\n\n\n**`parser.parse_args()`** supports one additional argument `config_path`, which takes a string with the full path and file name of the configuration file to use.\n* `config_path` is optional - if omitted, the config path and file should be set on the command line with `--config_path 'path/config_file'`\n\n\n**`parser.gen_config_file(fname, prefix='    ')`**\n* This is a new function which generates a configuration file.\n* `fname` is a full path and file name to write the configuration file.\n    * If `fname` already exists, the user is prompted before overwriting.\n* `prefix` is a string used to indent entries into each of the configuration dictionaries. The default is 4 spaces.\n\n**`parser.get_config_file_name()`**\n* This is a new function which returns the full path and name of the configuration file.\n* It will return None if no file was used: if one was not specified, or the specified file did not exist.\n\n\n#### Configuration files\n* Configuration files consist of up to 3 dictionaries. All are optional, but if present, they must have the names noted here.\n* **`config_args`** is the name of the optional dictionary used to configure typical argparse arguments: those that lead with a prefix, and have a default if no value is entered on the command line.\n    * Each **key** in the dictionary is the argument name, less any prefix.\n    * Each **value** is the value for that argument. Just use the actual python value for this - not a string representation\n    * You do NOT have to have a `config_args` entry for each argument added with `add_argument()`. If omitted, the default or command line value will be used.\n    * You CAN have `config_args` entries that have not been added with `add_argument()`. This allows flexibility, while not cluttering up the command line or confusing users.\n    ```\n    config_args = {\n        'opt1' : 52,\n        'opt2' : True\n    }\n    ```\n    * If no `config_args` dictionary is present, the value entered for the command line will be used if entered, or the default from `add_argument()`\n\n* **`config_groups`** is the name of the optional dictionary used to configure groups.  \n    * Each **key** in the dictionary is a group name.  \n    * Each **value** is a list of strings of the names of the arguments that are members of this group, one string per argument name.  \n    * You do NOT have to have a `config_groups` entry for all the groups created with `add_argument()`.  \n    * You CAN have `config_groups` entries that have not been added with `add_argument()`.  \n    ```\n    config_groups = {\n        'personal' : ['age', 'salary', 'bonus'],\n        'work'     : ['salary, 'bonus', 'job_title']\n    }\n    ```\n\n    * If no `config_groups` dictionary is present, the groups created with `add_argument()` remain unchanged.  \n\n * **`config_required`** is the name of the optional dictionary used to configure required/positional arguments.  \n    * Each **key** in the dictionary is the argument name.  \n    * Each **value** is the value for that argument. Just use the actual python value for this - not a string representation.  \n    * **Unlike the other dictionaries**, if you have a `config_required` dictionary, it MUST have all the positional arguments created with `add_argument()`, and may NOT have any additions.\n\n    ```    \n    config_required = {\n\n        'must1' : 52,\n        'must2' : True\n    }\n    ```\n    * If no `config_args` dictionary is present, the values entered on the command line will be used.  \n    * The order in this dictionary is not critical - though they are positional, argparse_director finds them by name if needed to fill missing command line values. This does NOT change the fact that they need to be in order on the command line.\n\n#### Command line usage\n* The command line with argparse_director operates essentially the same as with argparse:\n```\n> ./script_name.py posval1 posval2 --arg1 val1 --arg2 val2\n```\nSpecifying which configuration file to use works as if you had created an argument for it named `--config_path`:\n```\n> ./script_name.py --arg1 val1 --arg2 val2 --config_path path/to/config_file\n```\n`--config_path` can appear anywhere on the command line that optional arguments are legal. This is anywhere after any defined positional arguments.  \n`--config_path` is created by ArgParseDirector, and it does not appear in the args Namespace - like '--help'. If you need to get the file name, see `get_config_file_name()`\n\n#### Matching and merging rules\n* For typical options, command line overrides the configuration file, and the configuration file overrides the defaults.\n* For groups, they are merged. Whatever groups you define in `add_argument()` calls are added to whatever groups you defined in the configuration file. There is no way to delete a group member other than not adding it in the first place.\n* Positional arguments are a little tricker. Positional arguments must be in the command line immediately following the script name, in the order they were added to the parser. This doesn't change when using a configuration file. You can enter them on the command line, of course, or let the configuration file set them.\n    * If you enter some but not all positional args on the command line, the command line values are applied starting with the first position, and proceeding in order until there are no more. Any missing at the end are supplied from the configuration file.\n\n#### Using groups\nGrouping arguments allows the organization of arguments into simple subsets that can be passed as a single name. This makes it simpler to organize the initialization of a class or subsystem, to create a set of arguments for saving, to narrow the interface to a class or function, and to ensure that only the appropriate info is passed where needed.\n\nArguments can be in multiple Namespaces, and they always also remain in the main Namespace returned by `parse_args()`. At this time Namespaces can not be members of other Namespaces other than the main one.\n\nTo show an example, machine learning systems often separate the tunable parameters of a model into a set of hyperparameters. The search for the right combination of these values is a critical and difficult task. Being able to get, pass, and save these as a single entity saves a lot of time and confusion. Imagine a simplified model with the following return from `parse_args()`\n```\nprint(args)\nNamespace(ask_permission=True, back_end='ddp', batch_size=16, ckpt_path=None, config_path='confg_11p.py', debug=False, epochs=350, exit_to_python=False, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hparams=Namespace(back_end='ddp', batch_size=16, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, learn_class_parameters=False, learn_inst_parameters=True, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, p0=128, p1=128, p2=256, pct_data=1.0, skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10), hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, interactive=True, learn_class_parameters=False, learn_inst_parameters=True, log_flags='ebt', log_root='/home/seth/dev/pytorch_logs/', log_tag=-1, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, msg_level='v', net_desc='02: 10x10 ckpt:569 val_pre .649 test: rec 0.6472 pre 0.6445 acc 0.9866: 550e  \\n', net_history='00: lr .002, wd .0008, 9x9 lip t, lcp f ckpt: 298/pv .792: test rec 0.8584 pre 0.8514 acc 0.9767: 392e  BEST operationally \\n01: 9x9 to see if repeatable: ckpt: 334 vp .827  test: rec 0.8266 pre 0.8168 acc 0.9536: 350e  better numbers than 00 but not as good operationally  \\n', p0=128, p1=128, p2=256, pct_data=1.0, plot_conf=True, port=10000, print_model=False, report_flags='bt', skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10)\n```\nA lot of parameters, and this is not a particularly complex model. That's why a number are marked as members of group `hparams`.\n```\nprint(args.hparams)\n\nNamespace(back_end='ddp', batch_size=16, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, learn_class_parameters=False, learn_inst_parameters=True, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, p0=128, p1=128, p2=256, pct_data=1.0, skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10)\n```\nStill a lot, but much more managable.  \n\nBy using groups to collect all these arguments, we gain an easy way to initialize the model, save this training session's important information, and pass the parameters to a routine that will do a search of values to find the best combination.\n\nGroups are simply new argparse Namespaces. Because the keys and values are copied into each Namespace, changes to any arg values are limited to the Namespace they are in: changing `arg.back_end` will not change `arg.hparams.back_end`. It can be useful/tempting to change arg values as they are processed. Remember, when passing a Namespace as a function argument, python will pass it by reference - so changing a value in the passed Namespace will change that value in all references to that Namespace.\n\n#### Generating a config file\nYou can generate a initial configuration file from the parser you created with `add_arguments()` using `parser.gen_config_file(file_name)`. This will write a file named `file_name` with the appropriate dictionaries for your parser.\n\nA realistic example - here are the `add_argument()` calls to configure and train a machine learning model:\n\n```\n# type conversion function used below\ndef strToBool(s, d=['t', 'T', 'true',  'True', 'y', 'Y']):\n    return s in d\n\nparser = ArgParseDirector()\n\nparser.add_argument(\"--ckpt_path\",              default=None,                                                           type=str,       help=\"full path to checkpoint to load\")\n\nparser.add_argument(\"--epochs\",                 default=10,                                                             type=int,       help=\"number of epochs\")\nparser.add_argument(\"--batch_size\",             default=16,                                     group_arg=hparams,      type=int,       help=\"size of the batches per gpu\")\nparser.add_argument(\"--gpus\",                   default='0 1 2 3',                              group_arg=hparams,      type=str,       help=\"device numbers of gpus to use\")\nparser.add_argument(\"--back_end\",               default='ddp',                                  group_arg=hparams,      type=str,       help=\"distributed back end\",                                        choices=['dp', 'ddp'])\nparser.add_argument(\"--port\",                   default=10000,                                                          type=int,       help=\"port for ddp ipc: must be greater than 10000\")\nparser.add_argument(\"--log_root\",               default='/home/dev/pytorch_logs/',                                      type=str,       help=\"root path for logs\")\nparser.add_argument(\"--log_flags\",              default='ebt',                                                          type=str,       help=\"log control: e, b, t signal epoch, batch, test reporting\")\nparser.add_argument(\"--log_tag\",                default=-1,                                                             type=int,       help=\"reset log tag, must be >= 0\")\nparser.add_argument(\"--pct_data\",               default=1.0,                                    group_arg=hparams,      type=float,     help=\"set percentage of data to use - for quick testing\")\nparser.add_argument(\"--wx\",                     default=7,                                      group_arg=hparams,      type=int,       help=\"number of classes in w or x or dimension\")\nparser.add_argument(\"--hy\",                     default=7,                                      group_arg=hparams,      type=int,       help=\"number of classes in h or y or dimension\")\nparser.add_argument(\"--lr\",                     default=.001,                                   group_arg=hparams,      type=float,     help=\"learning rate\")\n\nparser.add_argument(\"--msg_level\",              default='v',                                                            type=str,       help=\"messaging level (v)erbose, (q)uiet, (d)ebug, (s)ilent\",       choices=['v', 'q', 's'])\nparser.add_argument(\"--report_flags\",           default='bt',                                                           type=str,       help=\"report control: e, b, t signal epoch, batch, test reporting\")\nparser.add_argument(\"--plot_conf\",              default='true',                                                         type=strToBool, help=\"plot confusion matrix\")\nparser.add_argument(\"--debug\",                  default='false',                                                        type=strToBool, help=\"enable debug() messaging\")\nparser.add_argument(\"--print_model\",            default='false',                                                        type=strToBool, help=\"print model summary during startup\")\n\n# added for ml data param learning\nparser.add_argument('--learn_class_parameters', default='true',                                 group_arg=hparams,      type=strToBool, help='Learn temperature per class')\nparser.add_argument('--learn_inst_parameters',  default='true',                                 group_arg=hparams,      type=strToBool, help='Learn temperature per instance')\nparser.add_argument('--skip_clamp_data_param',  default='false',                                group_arg=hparams,      type=strToBool, help='Do not clamp data parameters during optimization [f, F, false, False, t, T, true, True]')\nparser.add_argument('--lr_class_param',         default=0.1,                                    group_arg=hparams,      type=float,     help='Learning rate for class parameters')\nparser.add_argument('--lr_inst_param',          default=0.1,                                    group_arg=hparams,      type=float,     help='Learning rate for instance parameters')\nparser.add_argument('--wd_class_param',         default=0.0,                                    group_arg=hparams,      type=float,     help='Weight decay for class parameters')\nparser.add_argument('--wd_inst_param',          default=0.0,                                    group_arg=hparams,      type=float,     help='Weight decay for instance parameters')\nparser.add_argument('--init_class_param',       default=1.0,                                    group_arg=hparams,      type=float,     help='Initial value for class parameters')\nparser.add_argument('--init_inst_param',        default=1.0,                                    group_arg=hparams,      type=float,     help='Initial value for instance parameters')\n\nparser.add_argument(\"--exit_to_python\",         default='false',                                                        type=strToBool, help=\"exit to python\")\nparser.add_argument(\"--ask_permission\",         default='true',                                                         type=strToBool, help=\"ask user for permission to start, erase logs\")\nparser.add_argument(\"--interactive\",            default='true',                                                         type=strToBool, help=\"poll for input during training\")\n```\nThere are many more configurable arguments needed, so a config file is a good idea. Hand creating it is straightforward, but tedious. Let's use `parser.gen_config_file('ml_config.py')` to generate the following baseline file:\n\n```\n# ArgParseDirector configuration file 'ml_config.py': original generated 2020-04-13 09:32:31\n# 'ml_config.py may be edited to:\n#   add/change entries and values in config_args,\n#   add/change group names and keys in config_groups,\n#   change values for positional args in config_required\n#   or add python code as needed\n\n# config_args: original generated from all args added with add_argument()\n# change values to override defaults, add keys to create arguments that will be returned from parse_args() but not available from command line\n# do not change dictionary name 'config_args'\nconfig_args = {\n    'ckpt_path' :                None,\n    'epochs' :                   10,\n    'batch_size' :               16,\n    'gpus' :                     '0 1 2 3',\n    'back_end' :                 'ddp',\n    'port' :                     10000,\n    'log_root' :                 '/home/dev/pytorch_logs/',\n    'log_flags' :                'ebt',\n    'log_tag' :                  -1,\n    'pct_data' :                 1.0,\n    'wx' :                       7,\n    'hy' :                       7,\n    'lr' :                       0.001,\n    'msg_level' :                'v',\n    'report_flags' :             'bt',\n    'plot_conf' :                True,\n    'debug' :                    False,\n    'print_model' :              False,\n    'learn_class_parameters' :   True,\n    'learn_inst_parameters' :    True,\n    'skip_clamp_data_param' :    False,\n    'lr_class_param' :           0.1,\n    'lr_inst_param' :            0.1,\n    'wd_class_param' :           0.0,\n    'wd_inst_param' :            0.0,\n    'init_class_param' :         1.0,\n    'init_inst_param' :          1.0,\n    'exit_to_python' :           False,\n    'ask_permission' :           True,\n    'interactive' :              True,\n}\n\n# config_groups: from all args added with add_argument() call that includes 'arg_group = 'some_group_name' or ('group1', 'group2')\n# add names to lists, or create new groups\n# do not change dictionary name 'config_groups'\nconfig_groups = {\n    'hparams' : [\n        'batch_size',\n        'gpus',\n        'back_end',\n        'pct_data',\n        'wx',\n        'hy',\n        'lr',\n        'learn_class_parameters',\n        'learn_inst_parameters',\n        'skip_clamp_data_param',\n        'lr_class_param',\n        'lr_inst_param',\n        'wd_class_param',\n        'wd_inst_param',\n        'init_class_param',\n        'init_inst_param',\n    ],\n}\n\n# required arguments: from all args added as positional with add_argument()\n# change values, do NOT remove or add any entries\n# do not change dictionary name 'config_required'\nconfig_required = {\n}\n```\n\nThe file can be edited to support organization and usage: renaming, reformatting, recording history, enforcing model relationships, extending arguments needed:\n```\n# config file for gaze_llp\n# added: sn just after generation date/time above\n# values used to compute model sizes    # original values (pre 11l)\n_f1         = 32                        # 64\n_f3         = 16                        # 128\n_f5         = 32                        # 256\n_p0         = 128                       # 128\nfname       = '/home/dev/pytorch_work/config_11p.py'\n\n# command line plus additional args\nconfig_args = {\n\n    # history - at top for convenience\n    \"net_history\" :               \"00: lr .002, wd .0008, 9x9 lip t, lcp f ckpt: 298/pv .792: test rec 0.8584 pre 0.8514 acc 0.9767: 392e  BEST operationally \\n\" +\\\n                                  \"01: 9x9 to see if repeatable: ckpt: 334 vp .827  test: rec 0.8266 pre 0.8168 acc 0.9536: 350e  better numbers than 00 but not as good operationally  \\n\",\n\n    \"net_desc\" :                  \"02: 10x10 ckpt:569 val_pre .649 test: rec 0.6472 pre 0.6445 acc 0.9866: 550e  \\n\",\n\n    # hparams\n    # basic for trainer and data construction\n    'batch_size' :               16,\n    'lr' :                       0.002,\n    'wd' :                       0.0008,\n    'wx' :                       10,\n    'hy' :                       10,\n\n    # data param learning\n    'learn_class_parameters' :   False,\n    'learn_inst_parameters' :    True,\n    'skip_clamp_data_param' :    False,\n    'lr_class_param' :           0.1,\n    'lr_inst_param' :            0.1,\n    'wd_class_param' :           0.0,\n    'wd_inst_param' :            0.0,\n    'init_class_param' :         1.0,\n    'init_inst_param' :          1.0,\n\n    # model configuration parameters: cannot be changed from command line\n    # calculated from vars above           # original values (pre 11l)\n    'f0' :                        32,      # 64\n    'f1' :                        _f1,     # 64\n    'f2' :                        _f1*2,   # 128\n    'f3' :                        _f3,     # 128\n    'f4' :                        _f3*2,   # 256\n    'f5' :                        _f5,     # 256\n    'f6' :                        _f5*2,   # 512\n    'f7' :                        64,      # 256\n    'i0' :                        16,      # 16\n    'i1' :                        16,      # 32\n    'i2' :                        16,      # 32\n    'i3' :                        16,      # 32\n    'p0' :                        128,     # 128\n    'p1' :                        _p0,     # 64\n    'p2' :                        _p0*2,   # 512 \n\n    # required to construct trainer\n    'gpus' :                     '0 1 2 3 4',\n    'back_end' :                 'ddp',\n    'pct_data' :                 1.0,\n    # end hparams\n\n    # training basics\n    'epochs' :                   100,\n    'port' :                     10000,\n\n    # files: configuration, checkpoint to load\n    'config_path' :              'confg_11p.py',\n    'ckpt_path' :                None,\n\n    # logging: file, file tag, flags\n    'log_root' :                 '/home/seth/dev/pytorch_logs/',\n    'log_tag' :                  -1,\n    'log_flags' :                'ebt',\n\n    # reporting\n    'msg_level' :                'v',\n    'report_flags' :             'bt',\n    'plot_conf' :                True,\n    'debug' :                    False,\n    'print_model' :              False,\n\n    # interacting with end user\n    'exit_to_python' :           False, # exit to python at completion\n    'ask_permission' :           True,  # ask permission to delete files, etc\n    'interactive' :              True,  # interact during training through RunMonitor\n}\n```\nThis config file and the original parser it was generated from work together, as you already know\n```\n> ./realistic.py --config_path config_llp.py --epochs 350 --gpus '0 1 2 3 4 5'\nNamespace(ask_permission=True, back_end='ddp', batch_size=16, ckpt_path=None, config_path='confg_11p.py', debug=False, epochs=350, exit_to_python=False, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hparams=Namespace(back_end='ddp', batch_size=16, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, learn_class_parameters=False, learn_inst_parameters=True, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, p0=128, p1=128, p2=256, pct_data=1.0, skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10), hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, interactive=True, learn_class_parameters=False, learn_inst_parameters=True, log_flags='ebt', log_root='/home/seth/dev/pytorch_logs/', log_tag=-1, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, msg_level='v', net_desc='02: 10x10 ckpt:569 val_pre .649 test: rec 0.6472 pre 0.6445 acc 0.9866: 550e  \\n', net_history='00: lr .002, wd .0008, 9x9 lip t, lcp f ckpt: 298/pv .792: test rec 0.8584 pre 0.8514 acc 0.9767: 392e  BEST operationally \\n01: 9x9 to see if repeatable: ckpt: 334 vp .827  test: rec 0.8266 pre 0.8168 acc 0.9536: 350e  better numbers than 00 but not as good operationally  \\n', p0=128, p1=128, p2=256, pct_data=1.0, plot_conf=True, port=10000, print_model=False, report_flags='bt', skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10)\n```\nArgParseDirector includes a `rec_print()` function to cope with Namespaces like this:\n```\nrec_print(args)\n\nhparams :\n\n    gpus :                     '0 1 2 3 4 5'\n    p2 :                       256\n    learn_inst_parameters :    True\n    lr_inst_param :            0.1\n    p0 :                       128\n    wd_inst_param :            0.0\n    f5 :                       32\n    i0 :                       16\n    i1 :                       16\n    skip_clamp_data_param :    False\n    init_inst_param :          1.0\n    f2 :                       64\n    f3 :                       16\n    lr :                       0.002\n    wd :                       0.0008\n    hy :                       10\n    f0 :                       32\n    f6 :                       64\n    back_end :                 'ddp'\n    wd_class_param :           0.0\n    batch_size :               16\n    f4 :                       32\n    p1 :                       128\n    lr_class_param :           0.1\n    f1 :                       32\n    i2 :                       16\n    pct_data :                 1.0\n    init_class_param :         1.0\n    f7 :                       64\n    learn_class_parameters :   False\n    i3 :                       16\n    wx :                       10\n\ngpus :                         '0 1 2 3 4 5'\nmsg_level :                    'v'\np2 :                           256\nlearn_inst_parameters :        True\nlr_inst_param :                0.1\np0 :                           128\nwd_inst_param :                0.0\nf5 :                           32\ni0 :                           16\ni1 :                           16\nask_permission :               True\nskip_clamp_data_param :        False\ninit_inst_param :              1.0\ninteractive :                  True\nf2 :                           64\nf3 :                           16\nprint_model :                  False\ndebug :                        False\nlr :                           0.002\nwd :                           0.0008\nhy :                           10\nconfig_path :                  'confg_11p.py'\nepochs :                       350\nf0 :                           32\nf6 :                           64\nback_end :                     'ddp'\nwd_class_param :               0.0\nbatch_size :                   16\nplot_conf :                    True\nf4 :                           32\np1 :                           128\nlr_class_param :               0.1\nf1 :                           32\nnet_desc :                     '02: 10x10 ckpt:569 val_pre .649 test: rec 0.6472 pre 0.6445 acc 0.9866: 550e  \n'\nport :                         10000\nlog_root :                     '/home/seth/dev/pytorch_logs/'\ni2 :                           16\npct_data :                     1.0\nexit_to_python :               False\nckpt_path :                    None\ninit_class_param :             1.0\nnet_history :                  '00: lr .002, wd .0008, 9x9 lip t, lcp f ckpt: 298/pv .792: test rec 0.8584 pre 0.8514 acc 0.9767: 392e  BEST operationally \n01: 9x9 to see if repeatable: ckpt: 334 vp .827  test: rec 0.8266 pre 0.8168 acc 0.9536: 350e  better numbers than 00 but not as good operationally  \n'\nf7 :                           64\nreport_flags :                 'bt'\nlearn_class_parameters :       False\ni3 :                           16\nlog_tag :                      -1\nlog_flags :                    'ebt'\nwx :                           10\n```\n\n#### Extended Intro\nLet's start with a simple example.\n\n*By the way, this is not a tutorial about argparse - it assumes you are at least a little familiar with argparse.*\n\n#### Just like argparse\nImagine an example script named 'example.py'. Using argparse_director is just like argparse, with the obvious import and class name changes:\n```\n#!/bin/exe/python3\n# example.py - argparse_director example\n\n# import from argparse_director instead of argparse\nfrom argparse_director import ArgParseDirector\n\n# create parser and define 3 arguments: use ArgParseDirector() instead of ArgumentParser()\nparser = ArgParseDirector()\nparser.add_argument(\"--name\",       default='john doe',      type=str)\nparser.add_argument(\"--age\",        default=25,              type=int)\nparser.add_argument(\"--occupation\", default='web developer', type=str)\n\n# parse the command line and print the resulting args\nargs = parser.parse_args()\nprint(args)\n```\nFrom the command line:\n```\n> ./example.py\n> Namespace(age=25, name='john doe', occupation='web developer')\n```\nThe Namespace shows the defaults for each argument as expected.\n\n#### Configuration files contain python dictionaries\nA configuration file for these arguments is a python dictionary with one key for each argument. The key is a string without the command line prefix. The  value is the actual value - not  a string representation. You can simply write it as you would any python file. Later on, we'll see how to automatically generate a complete configuration files based on what has been added with `add_parser()`.\n```\n# config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\nconfig_args  = {\n    'name' :        'jane doe',\n    'age'  :        23,\n    'occupation' :  'vp, web development'\n}\n```\nThe file is normal python, defining a dictionary of keys as arguments and their values. The dictionary **must** be named `config_args`, and each entry configures one argument. Notice that each key/argument does not have the prefix required to enter it on the command line, and each value is the actual type of the argument value.\n\nUsing the configuration file is straightforward. Assume this one is called 'basic_config.py'. It can be named anything you want to, and it does not have to have '.py', or any extension. Invoke from the command line by specifying the configuration file like this:\n```\n> ./example.py --config_path basic_config.py\nNamespace(age=23, name='jane doe', occupation='vp, web development')\n```\nThe `--config_path` argument is added for you by argparse_director, like `--help` is by argparse. And like `--help`, you won't see it in the args returned to you.\nNotice that printed values are the values from the configuration file, **not** from defaults in the `add_argument()` calls. The configuration file values override the defaults.\n\nWe can use the command line along with configuration file:\n```\n> ./example.py --config_path basic_config.py --age 24\nNamespace(age=24, name='jane doe', occupation='vp, web development')\n```\n#### Defaults, configuration files and command line arguments work together\nCommand line values override the configuration file values and the defaults. The rules are simple:\n* Argument defaults are used if nothing changes them.\n* Any argument specified in the configuration file overrides it's default.\n* Any argument on the command line overrides the the configuration file and the default.\n\nThe configuration file does not have to have an entry for every command line argument:\n```\n# config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\nconfig_args  = {\n    'name' :        'jane doe',\n    'occupation' :  'vp, web development'\n}\n```\n```\n> ./example.py --config_path basic_config.py\nNamespace(age=25, name='jane doe', occupation='vp, web development')\n```\nThe 'name' and 'occupation' args came from the file, 'age' from the defaults. And of course, any of these could have been overridden from the command line.\n\nSimilarly, the config file can have arguments that are not available from the command line:\n```\n# config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\nconfig_args  = {\n    'name' :        'jane doe',\n    'occupation' :  'vp, web development',\n    'salary' :      125,000\n}\n```\n```\n> ./example.py --config_path basic_config.py\nNamespace(age=25, name='jane doe', occupation='vp, web development', salary=125,000)\n```\nTrying to use `--salary` from the command line fails ... it is only defined and set by the config file.\n\nThis is one of the many good reasons to use configuration files - to have configurable arguments that you do not have to hand enter with `add_argument()`, that do not clutter up the command line, and that cannot be altered by an end user.\n\n\n#### Configuration files are python\nThe config file is executed with `exec()` as standard python - so it can contain code to set values, create keys, etc:\n```\n# config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\n# set a conditional value\noccupation   = 'vp, marketing'\nconfig_args  = {\n    'name' :        'jane doe',\n    'occupation' :  occupation,\n    # set a conditional value\n    'salary' :      125000 if occupation=='vp, web development' else 95000\n}\n\n# create a conditional argument\nif occupation == 'vp, marketing':\n    config_args['bonus']    = 30000\n```\n```\n> ./example.py --config_path basic_config.py\nNamespace(age=25, bonus=30000, name='jane doe', occupation='vp, marketing', salary=95000)\n```\n\n#### Creating argument groups\nArgParseDirector can group any arguments you choose under any name you choose. Groups can be defined with `add_argument()` using the keyword `arg_group`:\n```\n#!/bin/exe/python3\n# example.py - argparse_director example\n\n# import from argparse_director instead of argparse\nfrom argparse_director import ArgParseDirector\n\n# create parser and define 3 arguments: use ArgParseDirector() instead of ArgumentParser()\nparser = ArgParseDirector()\nparser.add_argument(\"--name\",       default='john doe',      type=str, arg_group='personal')\nparser.add_argument(\"--age\",        default=25,              type=int)\nparser.add_argument(\"--occupation\", default='web developer', type=str, arg_group='personal')\nparser.add_argument(\"--bugs\",       default='wrong colors',  type=str, arg_group='work')\nparser.add_argument(\"--new module\", default='security',      type=str, arg_group='work')\n\n# parse them and print out args, and the arg_groups\nargs    = parser.parse_args()\nprint('args = ', args)\nprint()\nprint('personal = ', args.personal)\nprint('work     = ', args.work)\n```\n```\n> ./example.py --config_path basic_config.py\nargs =  Namespace(age=25, bonus=30000, bugs='wrong colors', name='jane doe', new_module='security', occupation='vp, marketing', personal=Namespace(name='jane doe', occupation='vp, marketing'), salary=95000, work=Namespace(bugs='wrong colors', new_module='security'))\n\npersonal =  Namespace(name='jane doe', occupation='vp, marketing')\nwork     =  Namespace(bugs='wrong colors', new_module='security')\n```\nThe returned args contains 2 additional arguments, both Namespaces: 'personal' and 'work'. The value for each is a Namespace that contains only the arguments and values for that arg_group, as defined in `add_argument()`. Note that the grouped args are available **in both the group and in args Namespaces**.\n\nGroups can also be created with a config file by adding a dictionary with the required name `config_groups`. For each entry in `config_groups`, the key is a string that names the group, and value is a list of of strings naming the arguments to be included in the group:\n```\n# config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\noccupation   = 'vp, marketing'\nconfig_args  = {\n    'name' :        'jane doe',\n    'occupation' :  occupation,\n    'salary' :      125000 if occupation=='vp, web development' else 95000\n}\nif occupation == 'vp, marketing':\n    config_args['bonus']    = 30000\n\n# create a dictionary named config_groups - if you configure groups this name is required\nconfig_groups = {\n    'personal' : ['age'],\n    'work' :     ['bugs', 'new_module', 'occupation']\n}\n```\n```\n> ./example.py --config_path basic_config.py\nargs =  Namespace(age=25, bonus=30000, bugs='wrong colors', name='jane doe', new_module='security', occupation='vp, marketing', personal=Namespace(age=25, name='jane doe', occupation='vp, marketing'), salary=95000, work=Namespace(bugs='wrong colors', new_module='security', occupation='vp, marketing'))\n\npersonal =  Namespace(age=25, name='jane doe', occupation='vp, marketing')\nwork     =  Namespace(bugs='wrong colors', new_module='security', occupation='vp, marketing')\n```\nThe groups defined by `add_argument()` and the config file are **merged**. The config file just adds 'age' to the 'personal' group, while 'work' has been completely restated in the config file. Both approaches work fine. Note that 'occupation' is a member of both groups: it was added to 'personal' in `add_argument()` and to 'work' in the config file.\n\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/sneiman/argparse_director", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "argparse-director", "package_url": "https://pypi.org/project/argparse-director/", "platform": "", "project_url": "https://pypi.org/project/argparse-director/", "project_urls": {"Homepage": "https://github.com/sneiman/argparse_director"}, "release_url": "https://pypi.org/project/argparse-director/0.4.1/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Simpler, more powerful drop-in replacement for argparser adding configuration files containing executable code, hidden and grouped arguments", "version": "0.4.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h2>ArgParseDirector</h2>\n<h4><strong>A simpler, more powerful way to configure complex python scripts and tools</strong></h4>\n<p><strong>ArgParseDirector</strong> is a drop-in replacement for python's ArgParse. It does everything ArgParse does and adds the following features:</p>\n<ul>\n<li>Configuration files. Merges command line and configuration file argument values.</li>\n<li>Supports configuration of argument values with code. ArgParseDirector configuration files are executable python.</li>\n<li>Supports the creation of arguments that are only available from the configuration file - not from the command line.</li>\n<li>Supports hierarchical arguments - multiple arguments passed as a group as a single entry in the parsed args.</li>\n</ul>\n<p>ArgParseDirector is a simple extension of argparse that does all of the above with virtually no change to your current usage.</p>\n<h4>Why ArgParseDirector</h4>\n<p>There are a number of good script configuration tools available - both drop-ins for argparse and more sophisticated tools. So why another one? In order to get more power than the simpler drop-ins and avoid the complexity of the sophisticated tools:</p>\n<ul>\n<li>ArgParseDirector configuration files are just python. You already know how to write them. And you can generate a base file automatically.</li>\n<li>Executable configuration files make it easy to handle complex relationships between argument values.</li>\n<li>Having arguments not available from the command line allows flexibility without causing user confusion and error.</li>\n<li>Hierachical/group arguments simplify startup code.</li>\n</ul>\n<h4>Index</h4>\n<p><a href=\"#install\" rel=\"nofollow\">Installation</a><br>\n<a href=\"#just-try-it\" rel=\"nofollow\">Try it</a><br>\n<a href=\"#quick-and-dirty-intro\" rel=\"nofollow\">Quick Intro</a><br>\n<a href=\"#summary\" rel=\"nofollow\">Summary</a></p>\n<ul>\n<li><a href=\"#the-parser-class\" rel=\"nofollow\">The parser</a></li>\n<li><a href=\"#configuration-files\" rel=\"nofollow\">Configuration files</a></li>\n<li><a href=\"#command-line-usage\" rel=\"nofollow\">The command line</a></li>\n<li><a href=\"#matching-and-merging-rules\" rel=\"nofollow\">Matching and merging</a></li>\n<li><a href=\"#using-groups\" rel=\"nofollow\">Using groups</a></li>\n<li><a href=\"#generating-a-config-file\" rel=\"nofollow\">Generating a config file</a></li>\n</ul>\n<p><a href=\"#extended-intro\" rel=\"nofollow\">Extended Intro</a></p>\n<h4>Install</h4>\n<p>There are no dependencies outside of a standard python 3 installation. Type at the command line:</p>\n<p><code>pip install argparse-director</code></p>\n<h4>Just try it</h4>\n<p>The easiest way to see how argparse_director works is to try it with some of your own argument configurations. Install argparse_director, grab one of your own scripts, and make the following changes:</p>\n<ol>\n<li>Change import, parser construction lines. And instead of starting your script, just print out the args:</li>\n</ol>\n<pre><code>from argparse_director import ArgParseDirector, Namespace, rec_print  # original: from argparse import ArgumentParser, Namespace\n...\nparser = ArgParseDirector()    # original: parser = ArgumentParser()\n...                            # same add_argument()\nargs = parser.parse_args()     # same parser_args()\n\n# dont run the script - just print out args - we ARE experimenting here!\nprint(args)                    # original: something like main(args) or start(args) - you know what to do\n</code></pre>\n<ol>\n<li>Now run it, and look at the what gets printed:</li>\n</ol>\n<pre><code>&gt; ./yourscript\nNamespace(yourarg=value, yourarg2=value, ...)\n</code></pre>\n<ol>\n<li>Next generate a configuration file. After the line that prints your args add this:</li>\n</ol>\n<pre><code># generate config file\nparser.gen_config_file('trial_config.py')\n\n</code></pre>\n<p>Run it, and then comment out the <code>parser.gen_config_file()</code> line - you don't want to keep remaking a base line config file!</p>\n<p>Take a look at 'trial_config.py'. You will see that 3 python dictionaries have been created for you. Edit a few of the values in <code>config_args</code>, and run the script like this:</p>\n<pre><code>&gt; ./yourscript --config_path trial_config.py\nNamespace(yourarg=value, yourarg2=value, ...)\n</code></pre>\n<p>You'll see that Namespace has your defaults, but has picked up the values from 'trial_config.py' - because you told it to with <code>--config_path trial_config.py</code> on the command line.</p>\n<ol>\n<li>Fool around<br>\nExperiment with this ... try some of your args from the command line, and edit some of them in 'trial_config.py'.<br>\nThe command line overrides the configuration file, and the configuration file overrides the defaults set in <code>add_argument()</code>.<br>\nAdd arguments to <code>config_args</code> to create args to your script that you can change in config, but users cannot change from the command line. Add python code to automatically set values, enforce related items or create args ... you will quickly see how this works.<br>\nTry <code>rec_print()</code> if you like. It pretty prints dictionaries and Namespaces - handy if you have a lot arguments.<br>\nThat's it - this isn't rocket science.</li>\n</ol>\n<p>Best to stay away from <code>config_groups</code> and <code>config_required</code> until you read a little more.</p>\n<h4>Quick and Dirty Intro</h4>\n<p>This is a quick but less experimental way to get acquainted - there is an <a href=\"#extended-intro\" rel=\"nofollow\">extended intro</a> below, as well.</p>\n<ul>\n<li>Change import and parser construction names.</li>\n<li>Use same <code>parser.add_argument()</code> calls.</li>\n</ul>\n<pre><code>from argparse_director import ArgParseDirector\n\nparser = ArgParseDirector()\nparser.add_argument('--opt1',    default=25, type=int, arg_group='group1')\nparser.add_argument('positional',            type=int)\n</code></pre>\n<p>Notice new option <code>arg_group</code>. Each argument with this option is returned from <code>parse_args()</code> in the main Namespace, and in a separate Namespace with just that group's arguments. Arguments can be assigned to more than one group by sett <code>arg_group</code> with a tuple of name strings: <code>arg_group=('group1', 'group2')</code>.</p>\n<p>Configuration files are straightforward: each has up to 3 python dictionaries: 1 each for arg configuration, group creation and required/positional args. None are mandatory - but if you have them they <strong>MUST</strong> be named <code>config_args</code>, <code>config_groups</code> and <code>config_required</code>, respectively. You can add any python code you like.</p>\n<pre><code># use arbitrary python as needed\nvalue1 = 123\nvalue2 = 128 if value1&lt;128 else 256\n\n# for setting command line arg options or creating new arguments only for config file ...\nconfig_args = {\n    'opt1' : value1,    # actual value and type not a string\n    'opt2' : value2,    # only usable from config file as there was no `add_argument()` for it\n}\n\n# for gathering args into groups\nconfig_groups = {\n    'group1' :  ['opt1', 'opt2'],\n    'group2' :  ['opt1']\n}\n\n# for positional args\nconfig_required = {\n    'positional' :    123456\n}\n</code></pre>\n<p>Invoke the configuration file from command line or in <code>parse_args()</code> call:</p>\n<pre><code>&gt;./script.py 123456 --config_path config_file.py\nor\n&gt;./script.py\nwith ...\nparser.parser_args(config_path='config_file.py')\n\ngenerates:\nNamespace(group1=Namespace(opt1=123, opt2=128), group2=Namespace(opt1=123), opt1=123, opt2=128, positional=123456))\n</code></pre>\n<p>Required arguments are positional, as with argparse - they have to come immediately after script name.</p>\n<pre><code>&gt;./script.py 54321 --config_path config_file.py\nNamespace(group1=Namespace(opt1=123, opt2=128), group2=Namespace(opt1=123), opt1=123, opt2=128, positional=54321)\n</code></pre>\n<ul>\n<li>Use <code>add_argument()</code> as always, with additional <code>arg_group='group_name'</code> option to create groups. Create as many groups as you need. An argument can belong to more than one group - 'arg_group' can be a single group name or a tuple of group names.</li>\n<li>Invoke from command line as always, with additonal <code>--config_path='config_file'</code>:\n<ul>\n<li><code>scriptname positional_args --config_path config_file optional_command_line_arguments</code></li>\n<li>Positional arguments must immediately follow script name before '--config_path'.</li>\n<li><code>--config_path</code> on the command line is optional - you can use <code>parser_args(config_path='config_file.py')</code> if you prefer.</li>\n<li>If you use neither, no config file will be used.</li>\n</ul>\n</li>\n<li>Command line overrides config file, config file overrides defaults. Use them all as needed.</li>\n<li>Generate a baseline config file from parser with <code>parser.gen_config_file('file_name')</code>.</li>\n<li>Config files are run with <code>exec()</code> - so use python code as you need in config file to enforce relationships, calculate values, even add arguments.</li>\n</ul>\n<h3>Summary</h3>\n<h5>The module:</h5>\n<p>Install with <code>pip install argparse-director</code><br>\nImport usually with <code>from argparse_director import ArgParseDirector, rec_print</code><br>\nContains <code>ArgParseDirector</code> parser creation class, and function <code>rec_print()</code> for pretty printing Dictionaries and Namespaces</p>\n<h5>The parser class</h5>\n<p><strong>ArgParseDirector</strong> is called just like <strong>ArgumentParse</strong>:</p>\n<ul>\n<li><code>parser = ArgParserDirector()</code></li>\n<li>It does not add or alter any arguments. It does create 2 additional functions, and adds arguments to 2:</li>\n</ul>\n<p><strong><code>parser.add_argument()</code></strong> supports one additional argument <code>arg_group</code>, which takes a single group name string, or tuple of group name strings:</p>\n<ul>\n<li><code>parser.add_argument('test', arg_group='work_group')</code></li>\n<li>All arguments with the same group name are collected in their own Namespace which is included in the main argument Namespace returned by <code>parse_args()</code></li>\n</ul>\n<p><strong><code>parser.parse_args()</code></strong> supports one additional argument <code>config_path</code>, which takes a string with the full path and file name of the configuration file to use.</p>\n<ul>\n<li><code>config_path</code> is optional - if omitted, the config path and file should be set on the command line with <code>--config_path 'path/config_file'</code></li>\n</ul>\n<p><strong><code>parser.gen_config_file(fname, prefix=' ')</code></strong></p>\n<ul>\n<li>This is a new function which generates a configuration file.</li>\n<li><code>fname</code> is a full path and file name to write the configuration file.\n<ul>\n<li>If <code>fname</code> already exists, the user is prompted before overwriting.</li>\n</ul>\n</li>\n<li><code>prefix</code> is a string used to indent entries into each of the configuration dictionaries. The default is 4 spaces.</li>\n</ul>\n<p><strong><code>parser.get_config_file_name()</code></strong></p>\n<ul>\n<li>This is a new function which returns the full path and name of the configuration file.</li>\n<li>It will return None if no file was used: if one was not specified, or the specified file did not exist.</li>\n</ul>\n<h4>Configuration files</h4>\n<ul>\n<li>\n<p>Configuration files consist of up to 3 dictionaries. All are optional, but if present, they must have the names noted here.</p>\n</li>\n<li>\n<p><strong><code>config_args</code></strong> is the name of the optional dictionary used to configure typical argparse arguments: those that lead with a prefix, and have a default if no value is entered on the command line.</p>\n<ul>\n<li>Each <strong>key</strong> in the dictionary is the argument name, less any prefix.</li>\n<li>Each <strong>value</strong> is the value for that argument. Just use the actual python value for this - not a string representation</li>\n<li>You do NOT have to have a <code>config_args</code> entry for each argument added with <code>add_argument()</code>. If omitted, the default or command line value will be used.</li>\n<li>You CAN have <code>config_args</code> entries that have not been added with <code>add_argument()</code>. This allows flexibility, while not cluttering up the command line or confusing users.</li>\n</ul>\n<pre><code>config_args = {\n    'opt1' : 52,\n    'opt2' : True\n}\n</code></pre>\n<ul>\n<li>If no <code>config_args</code> dictionary is present, the value entered for the command line will be used if entered, or the default from <code>add_argument()</code></li>\n</ul>\n</li>\n<li>\n<p><strong><code>config_groups</code></strong> is the name of the optional dictionary used to configure groups.</p>\n<ul>\n<li>Each <strong>key</strong> in the dictionary is a group name.</li>\n<li>Each <strong>value</strong> is a list of strings of the names of the arguments that are members of this group, one string per argument name.</li>\n<li>You do NOT have to have a <code>config_groups</code> entry for all the groups created with <code>add_argument()</code>.</li>\n<li>You CAN have <code>config_groups</code> entries that have not been added with <code>add_argument()</code>.</li>\n</ul>\n<pre><code>config_groups = {\n    'personal' : ['age', 'salary', 'bonus'],\n    'work'     : ['salary, 'bonus', 'job_title']\n}\n</code></pre>\n<ul>\n<li>If no <code>config_groups</code> dictionary is present, the groups created with <code>add_argument()</code> remain unchanged.</li>\n</ul>\n</li>\n<li>\n<p><strong><code>config_required</code></strong> is the name of the optional dictionary used to configure required/positional arguments.</p>\n<ul>\n<li>Each <strong>key</strong> in the dictionary is the argument name.</li>\n<li>Each <strong>value</strong> is the value for that argument. Just use the actual python value for this - not a string representation.</li>\n<li><strong>Unlike the other dictionaries</strong>, if you have a <code>config_required</code> dictionary, it MUST have all the positional arguments created with <code>add_argument()</code>, and may NOT have any additions.</li>\n</ul>\n<pre><code>config_required = {\n\n    'must1' : 52,\n    'must2' : True\n}\n</code></pre>\n<ul>\n<li>If no <code>config_args</code> dictionary is present, the values entered on the command line will be used.</li>\n<li>The order in this dictionary is not critical - though they are positional, argparse_director finds them by name if needed to fill missing command line values. This does NOT change the fact that they need to be in order on the command line.</li>\n</ul>\n</li>\n</ul>\n<h4>Command line usage</h4>\n<ul>\n<li>The command line with argparse_director operates essentially the same as with argparse:</li>\n</ul>\n<pre><code>&gt; ./script_name.py posval1 posval2 --arg1 val1 --arg2 val2\n</code></pre>\n<p>Specifying which configuration file to use works as if you had created an argument for it named <code>--config_path</code>:</p>\n<pre><code>&gt; ./script_name.py --arg1 val1 --arg2 val2 --config_path path/to/config_file\n</code></pre>\n<p><code>--config_path</code> can appear anywhere on the command line that optional arguments are legal. This is anywhere after any defined positional arguments.<br>\n<code>--config_path</code> is created by ArgParseDirector, and it does not appear in the args Namespace - like '--help'. If you need to get the file name, see <code>get_config_file_name()</code></p>\n<h4>Matching and merging rules</h4>\n<ul>\n<li>For typical options, command line overrides the configuration file, and the configuration file overrides the defaults.</li>\n<li>For groups, they are merged. Whatever groups you define in <code>add_argument()</code> calls are added to whatever groups you defined in the configuration file. There is no way to delete a group member other than not adding it in the first place.</li>\n<li>Positional arguments are a little tricker. Positional arguments must be in the command line immediately following the script name, in the order they were added to the parser. This doesn't change when using a configuration file. You can enter them on the command line, of course, or let the configuration file set them.\n<ul>\n<li>If you enter some but not all positional args on the command line, the command line values are applied starting with the first position, and proceeding in order until there are no more. Any missing at the end are supplied from the configuration file.</li>\n</ul>\n</li>\n</ul>\n<h4>Using groups</h4>\n<p>Grouping arguments allows the organization of arguments into simple subsets that can be passed as a single name. This makes it simpler to organize the initialization of a class or subsystem, to create a set of arguments for saving, to narrow the interface to a class or function, and to ensure that only the appropriate info is passed where needed.</p>\n<p>Arguments can be in multiple Namespaces, and they always also remain in the main Namespace returned by <code>parse_args()</code>. At this time Namespaces can not be members of other Namespaces other than the main one.</p>\n<p>To show an example, machine learning systems often separate the tunable parameters of a model into a set of hyperparameters. The search for the right combination of these values is a critical and difficult task. Being able to get, pass, and save these as a single entity saves a lot of time and confusion. Imagine a simplified model with the following return from <code>parse_args()</code></p>\n<pre><code>print(args)\nNamespace(ask_permission=True, back_end='ddp', batch_size=16, ckpt_path=None, config_path='confg_11p.py', debug=False, epochs=350, exit_to_python=False, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hparams=Namespace(back_end='ddp', batch_size=16, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, learn_class_parameters=False, learn_inst_parameters=True, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, p0=128, p1=128, p2=256, pct_data=1.0, skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10), hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, interactive=True, learn_class_parameters=False, learn_inst_parameters=True, log_flags='ebt', log_root='/home/seth/dev/pytorch_logs/', log_tag=-1, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, msg_level='v', net_desc='02: 10x10 ckpt:569 val_pre .649 test: rec 0.6472 pre 0.6445 acc 0.9866: 550e  \\n', net_history='00: lr .002, wd .0008, 9x9 lip t, lcp f ckpt: 298/pv .792: test rec 0.8584 pre 0.8514 acc 0.9767: 392e  BEST operationally \\n01: 9x9 to see if repeatable: ckpt: 334 vp .827  test: rec 0.8266 pre 0.8168 acc 0.9536: 350e  better numbers than 00 but not as good operationally  \\n', p0=128, p1=128, p2=256, pct_data=1.0, plot_conf=True, port=10000, print_model=False, report_flags='bt', skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10)\n</code></pre>\n<p>A lot of parameters, and this is not a particularly complex model. That's why a number are marked as members of group <code>hparams</code>.</p>\n<pre><code>print(args.hparams)\n\nNamespace(back_end='ddp', batch_size=16, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, learn_class_parameters=False, learn_inst_parameters=True, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, p0=128, p1=128, p2=256, pct_data=1.0, skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10)\n</code></pre>\n<p>Still a lot, but much more managable.</p>\n<p>By using groups to collect all these arguments, we gain an easy way to initialize the model, save this training session's important information, and pass the parameters to a routine that will do a search of values to find the best combination.</p>\n<p>Groups are simply new argparse Namespaces. Because the keys and values are copied into each Namespace, changes to any arg values are limited to the Namespace they are in: changing <code>arg.back_end</code> will not change <code>arg.hparams.back_end</code>. It can be useful/tempting to change arg values as they are processed. Remember, when passing a Namespace as a function argument, python will pass it by reference - so changing a value in the passed Namespace will change that value in all references to that Namespace.</p>\n<h4>Generating a config file</h4>\n<p>You can generate a initial configuration file from the parser you created with <code>add_arguments()</code> using <code>parser.gen_config_file(file_name)</code>. This will write a file named <code>file_name</code> with the appropriate dictionaries for your parser.</p>\n<p>A realistic example - here are the <code>add_argument()</code> calls to configure and train a machine learning model:</p>\n<pre><code># type conversion function used below\ndef strToBool(s, d=['t', 'T', 'true',  'True', 'y', 'Y']):\n    return s in d\n\nparser = ArgParseDirector()\n\nparser.add_argument(\"--ckpt_path\",              default=None,                                                           type=str,       help=\"full path to checkpoint to load\")\n\nparser.add_argument(\"--epochs\",                 default=10,                                                             type=int,       help=\"number of epochs\")\nparser.add_argument(\"--batch_size\",             default=16,                                     group_arg=hparams,      type=int,       help=\"size of the batches per gpu\")\nparser.add_argument(\"--gpus\",                   default='0 1 2 3',                              group_arg=hparams,      type=str,       help=\"device numbers of gpus to use\")\nparser.add_argument(\"--back_end\",               default='ddp',                                  group_arg=hparams,      type=str,       help=\"distributed back end\",                                        choices=['dp', 'ddp'])\nparser.add_argument(\"--port\",                   default=10000,                                                          type=int,       help=\"port for ddp ipc: must be greater than 10000\")\nparser.add_argument(\"--log_root\",               default='/home/dev/pytorch_logs/',                                      type=str,       help=\"root path for logs\")\nparser.add_argument(\"--log_flags\",              default='ebt',                                                          type=str,       help=\"log control: e, b, t signal epoch, batch, test reporting\")\nparser.add_argument(\"--log_tag\",                default=-1,                                                             type=int,       help=\"reset log tag, must be &gt;= 0\")\nparser.add_argument(\"--pct_data\",               default=1.0,                                    group_arg=hparams,      type=float,     help=\"set percentage of data to use - for quick testing\")\nparser.add_argument(\"--wx\",                     default=7,                                      group_arg=hparams,      type=int,       help=\"number of classes in w or x or dimension\")\nparser.add_argument(\"--hy\",                     default=7,                                      group_arg=hparams,      type=int,       help=\"number of classes in h or y or dimension\")\nparser.add_argument(\"--lr\",                     default=.001,                                   group_arg=hparams,      type=float,     help=\"learning rate\")\n\nparser.add_argument(\"--msg_level\",              default='v',                                                            type=str,       help=\"messaging level (v)erbose, (q)uiet, (d)ebug, (s)ilent\",       choices=['v', 'q', 's'])\nparser.add_argument(\"--report_flags\",           default='bt',                                                           type=str,       help=\"report control: e, b, t signal epoch, batch, test reporting\")\nparser.add_argument(\"--plot_conf\",              default='true',                                                         type=strToBool, help=\"plot confusion matrix\")\nparser.add_argument(\"--debug\",                  default='false',                                                        type=strToBool, help=\"enable debug() messaging\")\nparser.add_argument(\"--print_model\",            default='false',                                                        type=strToBool, help=\"print model summary during startup\")\n\n# added for ml data param learning\nparser.add_argument('--learn_class_parameters', default='true',                                 group_arg=hparams,      type=strToBool, help='Learn temperature per class')\nparser.add_argument('--learn_inst_parameters',  default='true',                                 group_arg=hparams,      type=strToBool, help='Learn temperature per instance')\nparser.add_argument('--skip_clamp_data_param',  default='false',                                group_arg=hparams,      type=strToBool, help='Do not clamp data parameters during optimization [f, F, false, False, t, T, true, True]')\nparser.add_argument('--lr_class_param',         default=0.1,                                    group_arg=hparams,      type=float,     help='Learning rate for class parameters')\nparser.add_argument('--lr_inst_param',          default=0.1,                                    group_arg=hparams,      type=float,     help='Learning rate for instance parameters')\nparser.add_argument('--wd_class_param',         default=0.0,                                    group_arg=hparams,      type=float,     help='Weight decay for class parameters')\nparser.add_argument('--wd_inst_param',          default=0.0,                                    group_arg=hparams,      type=float,     help='Weight decay for instance parameters')\nparser.add_argument('--init_class_param',       default=1.0,                                    group_arg=hparams,      type=float,     help='Initial value for class parameters')\nparser.add_argument('--init_inst_param',        default=1.0,                                    group_arg=hparams,      type=float,     help='Initial value for instance parameters')\n\nparser.add_argument(\"--exit_to_python\",         default='false',                                                        type=strToBool, help=\"exit to python\")\nparser.add_argument(\"--ask_permission\",         default='true',                                                         type=strToBool, help=\"ask user for permission to start, erase logs\")\nparser.add_argument(\"--interactive\",            default='true',                                                         type=strToBool, help=\"poll for input during training\")\n</code></pre>\n<p>There are many more configurable arguments needed, so a config file is a good idea. Hand creating it is straightforward, but tedious. Let's use <code>parser.gen_config_file('ml_config.py')</code> to generate the following baseline file:</p>\n<pre><code># ArgParseDirector configuration file 'ml_config.py': original generated 2020-04-13 09:32:31\n# 'ml_config.py may be edited to:\n#   add/change entries and values in config_args,\n#   add/change group names and keys in config_groups,\n#   change values for positional args in config_required\n#   or add python code as needed\n\n# config_args: original generated from all args added with add_argument()\n# change values to override defaults, add keys to create arguments that will be returned from parse_args() but not available from command line\n# do not change dictionary name 'config_args'\nconfig_args = {\n    'ckpt_path' :                None,\n    'epochs' :                   10,\n    'batch_size' :               16,\n    'gpus' :                     '0 1 2 3',\n    'back_end' :                 'ddp',\n    'port' :                     10000,\n    'log_root' :                 '/home/dev/pytorch_logs/',\n    'log_flags' :                'ebt',\n    'log_tag' :                  -1,\n    'pct_data' :                 1.0,\n    'wx' :                       7,\n    'hy' :                       7,\n    'lr' :                       0.001,\n    'msg_level' :                'v',\n    'report_flags' :             'bt',\n    'plot_conf' :                True,\n    'debug' :                    False,\n    'print_model' :              False,\n    'learn_class_parameters' :   True,\n    'learn_inst_parameters' :    True,\n    'skip_clamp_data_param' :    False,\n    'lr_class_param' :           0.1,\n    'lr_inst_param' :            0.1,\n    'wd_class_param' :           0.0,\n    'wd_inst_param' :            0.0,\n    'init_class_param' :         1.0,\n    'init_inst_param' :          1.0,\n    'exit_to_python' :           False,\n    'ask_permission' :           True,\n    'interactive' :              True,\n}\n\n# config_groups: from all args added with add_argument() call that includes 'arg_group = 'some_group_name' or ('group1', 'group2')\n# add names to lists, or create new groups\n# do not change dictionary name 'config_groups'\nconfig_groups = {\n    'hparams' : [\n        'batch_size',\n        'gpus',\n        'back_end',\n        'pct_data',\n        'wx',\n        'hy',\n        'lr',\n        'learn_class_parameters',\n        'learn_inst_parameters',\n        'skip_clamp_data_param',\n        'lr_class_param',\n        'lr_inst_param',\n        'wd_class_param',\n        'wd_inst_param',\n        'init_class_param',\n        'init_inst_param',\n    ],\n}\n\n# required arguments: from all args added as positional with add_argument()\n# change values, do NOT remove or add any entries\n# do not change dictionary name 'config_required'\nconfig_required = {\n}\n</code></pre>\n<p>The file can be edited to support organization and usage: renaming, reformatting, recording history, enforcing model relationships, extending arguments needed:</p>\n<pre><code># config file for gaze_llp\n# added: sn just after generation date/time above\n# values used to compute model sizes    # original values (pre 11l)\n_f1         = 32                        # 64\n_f3         = 16                        # 128\n_f5         = 32                        # 256\n_p0         = 128                       # 128\nfname       = '/home/dev/pytorch_work/config_11p.py'\n\n# command line plus additional args\nconfig_args = {\n\n    # history - at top for convenience\n    \"net_history\" :               \"00: lr .002, wd .0008, 9x9 lip t, lcp f ckpt: 298/pv .792: test rec 0.8584 pre 0.8514 acc 0.9767: 392e  BEST operationally \\n\" +\\\n                                  \"01: 9x9 to see if repeatable: ckpt: 334 vp .827  test: rec 0.8266 pre 0.8168 acc 0.9536: 350e  better numbers than 00 but not as good operationally  \\n\",\n\n    \"net_desc\" :                  \"02: 10x10 ckpt:569 val_pre .649 test: rec 0.6472 pre 0.6445 acc 0.9866: 550e  \\n\",\n\n    # hparams\n    # basic for trainer and data construction\n    'batch_size' :               16,\n    'lr' :                       0.002,\n    'wd' :                       0.0008,\n    'wx' :                       10,\n    'hy' :                       10,\n\n    # data param learning\n    'learn_class_parameters' :   False,\n    'learn_inst_parameters' :    True,\n    'skip_clamp_data_param' :    False,\n    'lr_class_param' :           0.1,\n    'lr_inst_param' :            0.1,\n    'wd_class_param' :           0.0,\n    'wd_inst_param' :            0.0,\n    'init_class_param' :         1.0,\n    'init_inst_param' :          1.0,\n\n    # model configuration parameters: cannot be changed from command line\n    # calculated from vars above           # original values (pre 11l)\n    'f0' :                        32,      # 64\n    'f1' :                        _f1,     # 64\n    'f2' :                        _f1*2,   # 128\n    'f3' :                        _f3,     # 128\n    'f4' :                        _f3*2,   # 256\n    'f5' :                        _f5,     # 256\n    'f6' :                        _f5*2,   # 512\n    'f7' :                        64,      # 256\n    'i0' :                        16,      # 16\n    'i1' :                        16,      # 32\n    'i2' :                        16,      # 32\n    'i3' :                        16,      # 32\n    'p0' :                        128,     # 128\n    'p1' :                        _p0,     # 64\n    'p2' :                        _p0*2,   # 512 \n\n    # required to construct trainer\n    'gpus' :                     '0 1 2 3 4',\n    'back_end' :                 'ddp',\n    'pct_data' :                 1.0,\n    # end hparams\n\n    # training basics\n    'epochs' :                   100,\n    'port' :                     10000,\n\n    # files: configuration, checkpoint to load\n    'config_path' :              'confg_11p.py',\n    'ckpt_path' :                None,\n\n    # logging: file, file tag, flags\n    'log_root' :                 '/home/seth/dev/pytorch_logs/',\n    'log_tag' :                  -1,\n    'log_flags' :                'ebt',\n\n    # reporting\n    'msg_level' :                'v',\n    'report_flags' :             'bt',\n    'plot_conf' :                True,\n    'debug' :                    False,\n    'print_model' :              False,\n\n    # interacting with end user\n    'exit_to_python' :           False, # exit to python at completion\n    'ask_permission' :           True,  # ask permission to delete files, etc\n    'interactive' :              True,  # interact during training through RunMonitor\n}\n</code></pre>\n<p>This config file and the original parser it was generated from work together, as you already know</p>\n<pre><code>&gt; ./realistic.py --config_path config_llp.py --epochs 350 --gpus '0 1 2 3 4 5'\nNamespace(ask_permission=True, back_end='ddp', batch_size=16, ckpt_path=None, config_path='confg_11p.py', debug=False, epochs=350, exit_to_python=False, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hparams=Namespace(back_end='ddp', batch_size=16, f0=32, f1=32, f2=64, f3=16, f4=32, f5=32, f6=64, f7=64, gpus='0 1 2 3 4 5', hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, learn_class_parameters=False, learn_inst_parameters=True, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, p0=128, p1=128, p2=256, pct_data=1.0, skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10), hy=10, i0=16, i1=16, i2=16, i3=16, init_class_param=1.0, init_inst_param=1.0, interactive=True, learn_class_parameters=False, learn_inst_parameters=True, log_flags='ebt', log_root='/home/seth/dev/pytorch_logs/', log_tag=-1, lr=0.002, lr_class_param=0.1, lr_inst_param=0.1, msg_level='v', net_desc='02: 10x10 ckpt:569 val_pre .649 test: rec 0.6472 pre 0.6445 acc 0.9866: 550e  \\n', net_history='00: lr .002, wd .0008, 9x9 lip t, lcp f ckpt: 298/pv .792: test rec 0.8584 pre 0.8514 acc 0.9767: 392e  BEST operationally \\n01: 9x9 to see if repeatable: ckpt: 334 vp .827  test: rec 0.8266 pre 0.8168 acc 0.9536: 350e  better numbers than 00 but not as good operationally  \\n', p0=128, p1=128, p2=256, pct_data=1.0, plot_conf=True, port=10000, print_model=False, report_flags='bt', skip_clamp_data_param=False, wd=0.0008, wd_class_param=0.0, wd_inst_param=0.0, wx=10)\n</code></pre>\n<p>ArgParseDirector includes a <code>rec_print()</code> function to cope with Namespaces like this:</p>\n<pre><code>rec_print(args)\n\nhparams :\n\n    gpus :                     '0 1 2 3 4 5'\n    p2 :                       256\n    learn_inst_parameters :    True\n    lr_inst_param :            0.1\n    p0 :                       128\n    wd_inst_param :            0.0\n    f5 :                       32\n    i0 :                       16\n    i1 :                       16\n    skip_clamp_data_param :    False\n    init_inst_param :          1.0\n    f2 :                       64\n    f3 :                       16\n    lr :                       0.002\n    wd :                       0.0008\n    hy :                       10\n    f0 :                       32\n    f6 :                       64\n    back_end :                 'ddp'\n    wd_class_param :           0.0\n    batch_size :               16\n    f4 :                       32\n    p1 :                       128\n    lr_class_param :           0.1\n    f1 :                       32\n    i2 :                       16\n    pct_data :                 1.0\n    init_class_param :         1.0\n    f7 :                       64\n    learn_class_parameters :   False\n    i3 :                       16\n    wx :                       10\n\ngpus :                         '0 1 2 3 4 5'\nmsg_level :                    'v'\np2 :                           256\nlearn_inst_parameters :        True\nlr_inst_param :                0.1\np0 :                           128\nwd_inst_param :                0.0\nf5 :                           32\ni0 :                           16\ni1 :                           16\nask_permission :               True\nskip_clamp_data_param :        False\ninit_inst_param :              1.0\ninteractive :                  True\nf2 :                           64\nf3 :                           16\nprint_model :                  False\ndebug :                        False\nlr :                           0.002\nwd :                           0.0008\nhy :                           10\nconfig_path :                  'confg_11p.py'\nepochs :                       350\nf0 :                           32\nf6 :                           64\nback_end :                     'ddp'\nwd_class_param :               0.0\nbatch_size :                   16\nplot_conf :                    True\nf4 :                           32\np1 :                           128\nlr_class_param :               0.1\nf1 :                           32\nnet_desc :                     '02: 10x10 ckpt:569 val_pre .649 test: rec 0.6472 pre 0.6445 acc 0.9866: 550e  \n'\nport :                         10000\nlog_root :                     '/home/seth/dev/pytorch_logs/'\ni2 :                           16\npct_data :                     1.0\nexit_to_python :               False\nckpt_path :                    None\ninit_class_param :             1.0\nnet_history :                  '00: lr .002, wd .0008, 9x9 lip t, lcp f ckpt: 298/pv .792: test rec 0.8584 pre 0.8514 acc 0.9767: 392e  BEST operationally \n01: 9x9 to see if repeatable: ckpt: 334 vp .827  test: rec 0.8266 pre 0.8168 acc 0.9536: 350e  better numbers than 00 but not as good operationally  \n'\nf7 :                           64\nreport_flags :                 'bt'\nlearn_class_parameters :       False\ni3 :                           16\nlog_tag :                      -1\nlog_flags :                    'ebt'\nwx :                           10\n</code></pre>\n<h4>Extended Intro</h4>\n<p>Let's start with a simple example.</p>\n<p><em>By the way, this is not a tutorial about argparse - it assumes you are at least a little familiar with argparse.</em></p>\n<h4>Just like argparse</h4>\n<p>Imagine an example script named 'example.py'. Using argparse_director is just like argparse, with the obvious import and class name changes:</p>\n<pre><code>#!/bin/exe/python3\n# example.py - argparse_director example\n\n# import from argparse_director instead of argparse\nfrom argparse_director import ArgParseDirector\n\n# create parser and define 3 arguments: use ArgParseDirector() instead of ArgumentParser()\nparser = ArgParseDirector()\nparser.add_argument(\"--name\",       default='john doe',      type=str)\nparser.add_argument(\"--age\",        default=25,              type=int)\nparser.add_argument(\"--occupation\", default='web developer', type=str)\n\n# parse the command line and print the resulting args\nargs = parser.parse_args()\nprint(args)\n</code></pre>\n<p>From the command line:</p>\n<pre><code>&gt; ./example.py\n&gt; Namespace(age=25, name='john doe', occupation='web developer')\n</code></pre>\n<p>The Namespace shows the defaults for each argument as expected.</p>\n<h4>Configuration files contain python dictionaries</h4>\n<p>A configuration file for these arguments is a python dictionary with one key for each argument. The key is a string without the command line prefix. The  value is the actual value - not  a string representation. You can simply write it as you would any python file. Later on, we'll see how to automatically generate a complete configuration files based on what has been added with <code>add_parser()</code>.</p>\n<pre><code># config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\nconfig_args  = {\n    'name' :        'jane doe',\n    'age'  :        23,\n    'occupation' :  'vp, web development'\n}\n</code></pre>\n<p>The file is normal python, defining a dictionary of keys as arguments and their values. The dictionary <strong>must</strong> be named <code>config_args</code>, and each entry configures one argument. Notice that each key/argument does not have the prefix required to enter it on the command line, and each value is the actual type of the argument value.</p>\n<p>Using the configuration file is straightforward. Assume this one is called 'basic_config.py'. It can be named anything you want to, and it does not have to have '.py', or any extension. Invoke from the command line by specifying the configuration file like this:</p>\n<pre><code>&gt; ./example.py --config_path basic_config.py\nNamespace(age=23, name='jane doe', occupation='vp, web development')\n</code></pre>\n<p>The <code>--config_path</code> argument is added for you by argparse_director, like <code>--help</code> is by argparse. And like <code>--help</code>, you won't see it in the args returned to you.\nNotice that printed values are the values from the configuration file, <strong>not</strong> from defaults in the <code>add_argument()</code> calls. The configuration file values override the defaults.</p>\n<p>We can use the command line along with configuration file:</p>\n<pre><code>&gt; ./example.py --config_path basic_config.py --age 24\nNamespace(age=24, name='jane doe', occupation='vp, web development')\n</code></pre>\n<h4>Defaults, configuration files and command line arguments work together</h4>\n<p>Command line values override the configuration file values and the defaults. The rules are simple:</p>\n<ul>\n<li>Argument defaults are used if nothing changes them.</li>\n<li>Any argument specified in the configuration file overrides it's default.</li>\n<li>Any argument on the command line overrides the the configuration file and the default.</li>\n</ul>\n<p>The configuration file does not have to have an entry for every command line argument:</p>\n<pre><code># config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\nconfig_args  = {\n    'name' :        'jane doe',\n    'occupation' :  'vp, web development'\n}\n</code></pre>\n<pre><code>&gt; ./example.py --config_path basic_config.py\nNamespace(age=25, name='jane doe', occupation='vp, web development')\n</code></pre>\n<p>The 'name' and 'occupation' args came from the file, 'age' from the defaults. And of course, any of these could have been overridden from the command line.</p>\n<p>Similarly, the config file can have arguments that are not available from the command line:</p>\n<pre><code># config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\nconfig_args  = {\n    'name' :        'jane doe',\n    'occupation' :  'vp, web development',\n    'salary' :      125,000\n}\n</code></pre>\n<pre><code>&gt; ./example.py --config_path basic_config.py\nNamespace(age=25, name='jane doe', occupation='vp, web development', salary=125,000)\n</code></pre>\n<p>Trying to use <code>--salary</code> from the command line fails ... it is only defined and set by the config file.</p>\n<p>This is one of the many good reasons to use configuration files - to have configurable arguments that you do not have to hand enter with <code>add_argument()</code>, that do not clutter up the command line, and that cannot be altered by an end user.</p>\n<h4>Configuration files are python</h4>\n<p>The config file is executed with <code>exec()</code> as standard python - so it can contain code to set values, create keys, etc:</p>\n<pre><code># config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\n# set a conditional value\noccupation   = 'vp, marketing'\nconfig_args  = {\n    'name' :        'jane doe',\n    'occupation' :  occupation,\n    # set a conditional value\n    'salary' :      125000 if occupation=='vp, web development' else 95000\n}\n\n# create a conditional argument\nif occupation == 'vp, marketing':\n    config_args['bonus']    = 30000\n</code></pre>\n<pre><code>&gt; ./example.py --config_path basic_config.py\nNamespace(age=25, bonus=30000, name='jane doe', occupation='vp, marketing', salary=95000)\n</code></pre>\n<h4>Creating argument groups</h4>\n<p>ArgParseDirector can group any arguments you choose under any name you choose. Groups can be defined with <code>add_argument()</code> using the keyword <code>arg_group</code>:</p>\n<pre><code>#!/bin/exe/python3\n# example.py - argparse_director example\n\n# import from argparse_director instead of argparse\nfrom argparse_director import ArgParseDirector\n\n# create parser and define 3 arguments: use ArgParseDirector() instead of ArgumentParser()\nparser = ArgParseDirector()\nparser.add_argument(\"--name\",       default='john doe',      type=str, arg_group='personal')\nparser.add_argument(\"--age\",        default=25,              type=int)\nparser.add_argument(\"--occupation\", default='web developer', type=str, arg_group='personal')\nparser.add_argument(\"--bugs\",       default='wrong colors',  type=str, arg_group='work')\nparser.add_argument(\"--new module\", default='security',      type=str, arg_group='work')\n\n# parse them and print out args, and the arg_groups\nargs    = parser.parse_args()\nprint('args = ', args)\nprint()\nprint('personal = ', args.personal)\nprint('work     = ', args.work)\n</code></pre>\n<pre><code>&gt; ./example.py --config_path basic_config.py\nargs =  Namespace(age=25, bonus=30000, bugs='wrong colors', name='jane doe', new_module='security', occupation='vp, marketing', personal=Namespace(name='jane doe', occupation='vp, marketing'), salary=95000, work=Namespace(bugs='wrong colors', new_module='security'))\n\npersonal =  Namespace(name='jane doe', occupation='vp, marketing')\nwork     =  Namespace(bugs='wrong colors', new_module='security')\n</code></pre>\n<p>The returned args contains 2 additional arguments, both Namespaces: 'personal' and 'work'. The value for each is a Namespace that contains only the arguments and values for that arg_group, as defined in <code>add_argument()</code>. Note that the grouped args are available <strong>in both the group and in args Namespaces</strong>.</p>\n<p>Groups can also be created with a config file by adding a dictionary with the required name <code>config_groups</code>. For each entry in <code>config_groups</code>, the key is a string that names the group, and value is a list of of strings naming the arguments to be included in the group:</p>\n<pre><code># config file basic_config.py\n# create a dictionary named 'config_args' - this name is required!\noccupation   = 'vp, marketing'\nconfig_args  = {\n    'name' :        'jane doe',\n    'occupation' :  occupation,\n    'salary' :      125000 if occupation=='vp, web development' else 95000\n}\nif occupation == 'vp, marketing':\n    config_args['bonus']    = 30000\n\n# create a dictionary named config_groups - if you configure groups this name is required\nconfig_groups = {\n    'personal' : ['age'],\n    'work' :     ['bugs', 'new_module', 'occupation']\n}\n</code></pre>\n<pre><code>&gt; ./example.py --config_path basic_config.py\nargs =  Namespace(age=25, bonus=30000, bugs='wrong colors', name='jane doe', new_module='security', occupation='vp, marketing', personal=Namespace(age=25, name='jane doe', occupation='vp, marketing'), salary=95000, work=Namespace(bugs='wrong colors', new_module='security', occupation='vp, marketing'))\n\npersonal =  Namespace(age=25, name='jane doe', occupation='vp, marketing')\nwork     =  Namespace(bugs='wrong colors', new_module='security', occupation='vp, marketing')\n</code></pre>\n<p>The groups defined by <code>add_argument()</code> and the config file are <strong>merged</strong>. The config file just adds 'age' to the 'personal' group, while 'work' has been completely restated in the config file. Both approaches work fine. Note that 'occupation' is a member of both groups: it was added to 'personal' in <code>add_argument()</code> and to 'work' in the config file.</p>\n\n          </div>"}, "last_serial": 7062652, "releases": {"0.4.1": [{"comment_text": "", "digests": {"md5": "0f1f23de036c41330c6dca9c1d6f4978", "sha256": "87de03d481e1449f0c06a532e832fe7de2d858393dcbb9152c073459e920d554"}, "downloads": -1, "filename": "argparse_director-0.4.1-py3-none-any.whl", "has_sig": false, "md5_digest": "0f1f23de036c41330c6dca9c1d6f4978", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17620, "upload_time": "2020-04-20T20:06:21", "upload_time_iso_8601": "2020-04-20T20:06:21.802812Z", "url": "https://files.pythonhosted.org/packages/6f/1a/8543a38f5b9946e52612f3c02cb1d5d12cc45b49a3b7501fe47388bd4999/argparse_director-0.4.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4a3384e83fb3a962e46744b960bc4f07", "sha256": "29dcc538993e825dc14afdaf200fdbbd0faa5f7f730548c873b6ba67d7b94781"}, "downloads": -1, "filename": "argparse-director-0.4.1.tar.gz", "has_sig": false, "md5_digest": "4a3384e83fb3a962e46744b960bc4f07", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 36899, "upload_time": "2020-04-20T20:06:24", "upload_time_iso_8601": "2020-04-20T20:06:24.018542Z", "url": "https://files.pythonhosted.org/packages/88/1c/b3c4cd2f79a8ca9f54ab3160cb4f9dcd8620b597ead6a53c5a246142e0ba/argparse-director-0.4.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0f1f23de036c41330c6dca9c1d6f4978", "sha256": "87de03d481e1449f0c06a532e832fe7de2d858393dcbb9152c073459e920d554"}, "downloads": -1, "filename": "argparse_director-0.4.1-py3-none-any.whl", "has_sig": false, "md5_digest": "0f1f23de036c41330c6dca9c1d6f4978", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17620, "upload_time": "2020-04-20T20:06:21", "upload_time_iso_8601": "2020-04-20T20:06:21.802812Z", "url": "https://files.pythonhosted.org/packages/6f/1a/8543a38f5b9946e52612f3c02cb1d5d12cc45b49a3b7501fe47388bd4999/argparse_director-0.4.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4a3384e83fb3a962e46744b960bc4f07", "sha256": "29dcc538993e825dc14afdaf200fdbbd0faa5f7f730548c873b6ba67d7b94781"}, "downloads": -1, "filename": "argparse-director-0.4.1.tar.gz", "has_sig": false, "md5_digest": "4a3384e83fb3a962e46744b960bc4f07", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 36899, "upload_time": "2020-04-20T20:06:24", "upload_time_iso_8601": "2020-04-20T20:06:24.018542Z", "url": "https://files.pythonhosted.org/packages/88/1c/b3c4cd2f79a8ca9f54ab3160cb4f9dcd8620b597ead6a53c5a246142e0ba/argparse-director-0.4.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:17 2020"}