{"info": {"author": "Zope Foundation and Contributors", "author_email": "pylons-discuss@googlegroups.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: Implementation :: CPython", "Topic :: Internet :: WWW/HTTP :: Indexing/Search"], "description": "Hypatia\n=======\n\nA Python indexing and searching system.\n\nSee http://github.com/Pylons/hypatia for more information while this package\nis in alpha development.\n\n\n0.3 (2014-06-12)\n----------------\n\n- Depend on the ``ZODB`` package rather than the ``ZODB3`` package.  The former\n  is a newer ZODB packaging, implying ZODB4.  If you actually require ZODB v3,\n  you will need to pin ``hypatia`` to an older release.  You should know that\n  the most recent release of ``ZODB3`` at this time (3.11) actually implies\n  ZODB v4 (I know it's not exactly obvious, but Jim ensures me it is), so if\n  you really require ZODB v3, you'll need to pin ``ZODB3`` to below 3.11 and\n  ``hypatia`` to below this release.\n\n- Keyword indices now have a ``unique_values`` method like Field indexes.\n\n- Calling ``hypatia.util.ResultSet.first()`` and\n  ``hypatia.util.ResultSet.one()`` is now idempotent.  Calling it a second time\n  will return the same value, and calling it will not effect the result set's\n  iterability (it will start from zero).\n\n0.2 (2014-05-16)\n----------------\n\n- Query objects are now consulted for intersect and union operations via\n  methods, instead of the intersection/union logic being embedded in And and Or\n  query objects.  This makes it possible to create query object types which\n  intersect and/or union differently when combined with other query results.\n\n0.1 (2014-02-09)\n----------------\n\n- Fix a typo in the Sphinx docs, which causes intersphinx references to\n  fail.\n\n0.1a7 (2013-10-08)\n------------------\n\n- Add a ``unique_values`` API to field index.\n\n- Sometimes an ``index`` attribute could not be found to resolve a result \n  set when deeply nesting boolean operations (like And and Or).  See \n  https://github.com/Pylons/hypatia/pull/5\n\n- Throw an Unsortable properly when a field index without any docids is used as\n  a sort index and ``raise_unsortable`` is ``True``.\n\n0.1a6 (2013-05-30)\n------------------\n\n- Add ``check_query`` method to text index to allow for checking if a search\n  term is parseable.\n\n0.1a5 (2013-05-06)\n------------------\n\n- Added support for Python 3.2 / 3.3.\n\n- Fix signature of TextIndex.sort (it would fail when e.g. raise_unsortable was\n  passed).\n\n- Add the a ``sort_type`` keyword argument to ``IIndexSort.sort`` and\n  ``IResultSet.sort`` methods.  This value can be passed by calling code to\n  control the type of sorting used.\n\n- Add two constants: ``hypatia.interfaces.STABLE`` and\n  ``hypatia.interfaces.OPTIMAL``.  These can be used as explicit arguments to\n  the ``IIndexSort.sort`` and ``IResultSet.sort`` ``sort_type`` parameter to\n  control the stability of sorting.\n\n- The constructor of ``IResultSet`` now accepts a ``sort_type`` keyword\n  argument.\n\n- The ResultSet constructed by ``IResultSet.sort`` will be passed the value\n  ``hypatia.interfaces.STABLE`` in its constructor to ensure that the second\n  and subsequent sorts of the result set will be done as a stable sort, unless\n  an explicit ``sort_type`` value is passed to that second sort.\n\n0.1a4 (2013-04-28)\n------------------\n\n- Add IResultSet interface definition.\n\n- Normalize keyword argument ordering of IIndexSort.sort and IResultSet.sort.\n\n- Add an argument ``raise_unsortable`` to IIndexSort.sort and IResultSet.sort\n  methods.  By default this is ``True``.  It means that iterating over the\n  results returned by one of these methods *may* raise a\n  ``hypatia.exc.Unsortable`` exception when a member of the docids passed in\n  cannot be sorted by the index used to do the sort (e.g. a value for the docid\n  is not present in the index).  It defaults to ``True``, which changes the\n  default behavior of indexes.  To get the old default behavior back, pass\n  ``False`` for this value.  Alternately, write code like this::\n\n     from hypatia.exc import Unsortable\n\n     ids = []\n     results = resultset.sort(someindex)\n     try:\n         for id in results:\n             ids.append(id)\n     except Unsortable as e:\n         unsorted = e.docids\n         ids.extend(unsorted)\n\n0.1a3 (2013-01-10)\n------------------\n\n- Optimize ``index_doc`` implementations of field and keyword index in cases\n  where the discriminator returns the default.\n\n- Remove code from ``hypatia.path``.  This package no longer supports\n  PathIndex.\n\n- Remove ``interfaces.IIndexQuery`` interface.  It was never relevant, as\n  indices cannot be expected to implement all of its methods, only the ones\n  which apply to each index.\n\n- ``BaseIndexMixin`` no longer supplies default implementation of applyFoo\n  methods which raise NotImplementedError.  Each index is now responsible for\n  implementing all of its own applyFoo methods.  This is in the interest of\n  fidelity with new query methods such as ``eq``, which are similarly not\n  implemented in the base.\n\n- Indexes are now compelled to implement a ``qname`` method for use by\n  queries.\n\n- ``DoesNotContain`` query renamed to ``NotContains`` for symmetry with other\n  negated query names.\n\n- New index methods: ``eq``, ``noteq``, ``ge``, ``le``, ``lt``, ``gt``,\n  ``any``, ``notany``, ``all``, ``notall``, ``inrange``, ``notinrange``,\n  ``contains``, ``notcontains``.  These methods return query objects.  Ex::\n\n      catalog['flavors'].eq('peach')\n\n- Query objects refactored internally to deal in index objects rather than\n  index names.\n\n- The ``query.parse_query`` function now requires a ``catalog`` argument.\n\n- Query objects now supply an .execute method which returns a ResultSet.\n\n- ResultSet objects are returned from .execute.  They represent a set of\n  docids; they are iterable and have various methods for obtaining single\n  objects (like ``one``, ``first``) and sorting (``sort``).\n\n- All Query objects now have a ``flush`` method which accepts arbitrary\n  positional and keyword arguments.  Calling the ``flush`` method of a query\n  object will cause the ``flush`` method of all indexes participating in the\n  query with the value passed to Query.flush with the same positional and\n  keyword arguments.  This is to support Substance D upstream, which may\n  require indexes to be flushed before a query happens.\n\n- Add a ``document_repr`` method to all indexes which accepts a docid and\n  returns a string represnting the index's knowledge about that docid.\n\n0.1a2 (2012-07-02)\n------------------\n\n- This version of the code is incompatible with indexes produced by 0.1a1.\n  There is no upgrade script.  Shame on you for using software with a 0.1a1\n  version number and expecting backwards compatibility.\n\n- Add `hypatia.catalog.CatalogQuery.sort` API for sorting external sets\n  of docids based on index values.\n\n- Add ``IIndexEnumeration`` interface, which all indexes must support.\n  This implied the following backwards incompatibilities:\n\n  - New interface methods: docids, docids_count, indexed, indexed_count,\n    not_indexed and not_indexed_count.\n\n  - documentCount method renamed to indexed_count.\n\n  - wordCount method renamed to word_count.\n\n- Remove unused INBest interface.\n\n- IIndexInjection interface ``clear`` method renamed to ``reset`` to prevent\n  confusion with dictionary ``clear`` (catalog is often dictionarylike).\n  Catalog ``clear_indexes`` method replaced with ``reset``.\n\n0.1a1\n-----\n\n- Initial release: fork of repoze.catalog and zope.index, combined.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pylonsproject.org", "keywords": "indexing catalog search", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "hypatia", "package_url": "https://pypi.org/project/hypatia/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/hypatia/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pylonsproject.org"}, "release_url": "https://pypi.org/project/hypatia/0.3/", "requires_dist": null, "requires_python": null, "summary": "Python package for searching and indexing", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A Python indexing and searching system.</p>\n<p>See <a href=\"http://github.com/Pylons/hypatia\" rel=\"nofollow\">http://github.com/Pylons/hypatia</a> for more information while this package\nis in alpha development.</p>\n<div id=\"id1\">\n<h2>0.3 (2014-06-12)</h2>\n<ul>\n<li>Depend on the <tt>ZODB</tt> package rather than the <tt>ZODB3</tt> package.  The former\nis a newer ZODB packaging, implying ZODB4.  If you actually require ZODB v3,\nyou will need to pin <tt>hypatia</tt> to an older release.  You should know that\nthe most recent release of <tt>ZODB3</tt> at this time (3.11) actually implies\nZODB v4 (I know it\u2019s not exactly obvious, but Jim ensures me it is), so if\nyou really require ZODB v3, you\u2019ll need to pin <tt>ZODB3</tt> to below 3.11 and\n<tt>hypatia</tt> to below this release.</li>\n<li>Keyword indices now have a <tt>unique_values</tt> method like Field indexes.</li>\n<li>Calling <tt>hypatia.util.ResultSet.first()</tt> and\n<tt>hypatia.util.ResultSet.one()</tt> is now idempotent.  Calling it a second time\nwill return the same value, and calling it will not effect the result set\u2019s\niterability (it will start from zero).</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h2>0.2 (2014-05-16)</h2>\n<ul>\n<li>Query objects are now consulted for intersect and union operations via\nmethods, instead of the intersection/union logic being embedded in And and Or\nquery objects.  This makes it possible to create query object types which\nintersect and/or union differently when combined with other query results.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h2>0.1 (2014-02-09)</h2>\n<ul>\n<li>Fix a typo in the Sphinx docs, which causes intersphinx references to\nfail.</li>\n</ul>\n</div>\n<div id=\"a7-2013-10-08\">\n<h2>0.1a7 (2013-10-08)</h2>\n<ul>\n<li>Add a <tt>unique_values</tt> API to field index.</li>\n<li>Sometimes an <tt>index</tt> attribute could not be found to resolve a result\nset when deeply nesting boolean operations (like And and Or).  See\n<a href=\"https://github.com/Pylons/hypatia/pull/5\" rel=\"nofollow\">https://github.com/Pylons/hypatia/pull/5</a></li>\n<li>Throw an Unsortable properly when a field index without any docids is used as\na sort index and <tt>raise_unsortable</tt> is <tt>True</tt>.</li>\n</ul>\n</div>\n<div id=\"a6-2013-05-30\">\n<h2>0.1a6 (2013-05-30)</h2>\n<ul>\n<li>Add <tt>check_query</tt> method to text index to allow for checking if a search\nterm is parseable.</li>\n</ul>\n</div>\n<div id=\"a5-2013-05-06\">\n<h2>0.1a5 (2013-05-06)</h2>\n<ul>\n<li>Added support for Python 3.2 / 3.3.</li>\n<li>Fix signature of TextIndex.sort (it would fail when e.g. raise_unsortable was\npassed).</li>\n<li>Add the a <tt>sort_type</tt> keyword argument to <tt>IIndexSort.sort</tt> and\n<tt>IResultSet.sort</tt> methods.  This value can be passed by calling code to\ncontrol the type of sorting used.</li>\n<li>Add two constants: <tt>hypatia.interfaces.STABLE</tt> and\n<tt>hypatia.interfaces.OPTIMAL</tt>.  These can be used as explicit arguments to\nthe <tt>IIndexSort.sort</tt> and <tt>IResultSet.sort</tt> <tt>sort_type</tt> parameter to\ncontrol the stability of sorting.</li>\n<li>The constructor of <tt>IResultSet</tt> now accepts a <tt>sort_type</tt> keyword\nargument.</li>\n<li>The ResultSet constructed by <tt>IResultSet.sort</tt> will be passed the value\n<tt>hypatia.interfaces.STABLE</tt> in its constructor to ensure that the second\nand subsequent sorts of the result set will be done as a stable sort, unless\nan explicit <tt>sort_type</tt> value is passed to that second sort.</li>\n</ul>\n</div>\n<div id=\"a4-2013-04-28\">\n<h2>0.1a4 (2013-04-28)</h2>\n<ul>\n<li><p>Add IResultSet interface definition.</p>\n</li>\n<li><p>Normalize keyword argument ordering of IIndexSort.sort and IResultSet.sort.</p>\n</li>\n<li><p>Add an argument <tt>raise_unsortable</tt> to IIndexSort.sort and IResultSet.sort\nmethods.  By default this is <tt>True</tt>.  It means that iterating over the\nresults returned by one of these methods <em>may</em> raise a\n<tt>hypatia.exc.Unsortable</tt> exception when a member of the docids passed in\ncannot be sorted by the index used to do the sort (e.g. a value for the docid\nis not present in the index).  It defaults to <tt>True</tt>, which changes the\ndefault behavior of indexes.  To get the old default behavior back, pass\n<tt>False</tt> for this value.  Alternately, write code like this:</p>\n<pre>from hypatia.exc import Unsortable\n\nids = []\nresults = resultset.sort(someindex)\ntry:\n    for id in results:\n        ids.append(id)\nexcept Unsortable as e:\n    unsorted = e.docids\n    ids.extend(unsorted)\n</pre>\n</li>\n</ul>\n</div>\n<div id=\"a3-2013-01-10\">\n<h2>0.1a3 (2013-01-10)</h2>\n<ul>\n<li><p>Optimize <tt>index_doc</tt> implementations of field and keyword index in cases\nwhere the discriminator returns the default.</p>\n</li>\n<li><p>Remove code from <tt>hypatia.path</tt>.  This package no longer supports\nPathIndex.</p>\n</li>\n<li><p>Remove <tt>interfaces.IIndexQuery</tt> interface.  It was never relevant, as\nindices cannot be expected to implement all of its methods, only the ones\nwhich apply to each index.</p>\n</li>\n<li><p><tt>BaseIndexMixin</tt> no longer supplies default implementation of applyFoo\nmethods which raise NotImplementedError.  Each index is now responsible for\nimplementing all of its own applyFoo methods.  This is in the interest of\nfidelity with new query methods such as <tt>eq</tt>, which are similarly not\nimplemented in the base.</p>\n</li>\n<li><p>Indexes are now compelled to implement a <tt>qname</tt> method for use by\nqueries.</p>\n</li>\n<li><p><tt>DoesNotContain</tt> query renamed to <tt>NotContains</tt> for symmetry with other\nnegated query names.</p>\n</li>\n<li><p>New index methods: <tt>eq</tt>, <tt>noteq</tt>, <tt>ge</tt>, <tt>le</tt>, <tt>lt</tt>, <tt>gt</tt>,\n<tt>any</tt>, <tt>notany</tt>, <tt>all</tt>, <tt>notall</tt>, <tt>inrange</tt>, <tt>notinrange</tt>,\n<tt>contains</tt>, <tt>notcontains</tt>.  These methods return query objects.  Ex:</p>\n<pre>catalog['flavors'].eq('peach')\n</pre>\n</li>\n<li><p>Query objects refactored internally to deal in index objects rather than\nindex names.</p>\n</li>\n<li><p>The <tt>query.parse_query</tt> function now requires a <tt>catalog</tt> argument.</p>\n</li>\n<li><p>Query objects now supply an .execute method which returns a ResultSet.</p>\n</li>\n<li><p>ResultSet objects are returned from .execute.  They represent a set of\ndocids; they are iterable and have various methods for obtaining single\nobjects (like <tt>one</tt>, <tt>first</tt>) and sorting (<tt>sort</tt>).</p>\n</li>\n<li><p>All Query objects now have a <tt>flush</tt> method which accepts arbitrary\npositional and keyword arguments.  Calling the <tt>flush</tt> method of a query\nobject will cause the <tt>flush</tt> method of all indexes participating in the\nquery with the value passed to Query.flush with the same positional and\nkeyword arguments.  This is to support Substance D upstream, which may\nrequire indexes to be flushed before a query happens.</p>\n</li>\n<li><p>Add a <tt>document_repr</tt> method to all indexes which accepts a docid and\nreturns a string represnting the index\u2019s knowledge about that docid.</p>\n</li>\n</ul>\n</div>\n<div id=\"a2-2012-07-02\">\n<h2>0.1a2 (2012-07-02)</h2>\n<ul>\n<li>This version of the code is incompatible with indexes produced by 0.1a1.\nThere is no upgrade script.  Shame on you for using software with a 0.1a1\nversion number and expecting backwards compatibility.</li>\n<li>Add <cite>hypatia.catalog.CatalogQuery.sort</cite> API for sorting external sets\nof docids based on index values.</li>\n<li>Add <tt>IIndexEnumeration</tt> interface, which all indexes must support.\nThis implied the following backwards incompatibilities:<ul>\n<li>New interface methods: docids, docids_count, indexed, indexed_count,\nnot_indexed and not_indexed_count.</li>\n<li>documentCount method renamed to indexed_count.</li>\n<li>wordCount method renamed to word_count.</li>\n</ul>\n</li>\n<li>Remove unused INBest interface.</li>\n<li>IIndexInjection interface <tt>clear</tt> method renamed to <tt>reset</tt> to prevent\nconfusion with dictionary <tt>clear</tt> (catalog is often dictionarylike).\nCatalog <tt>clear_indexes</tt> method replaced with <tt>reset</tt>.</li>\n</ul>\n</div>\n<div id=\"a1\">\n<h2>0.1a1</h2>\n<ul>\n<li>Initial release: fork of repoze.catalog and zope.index, combined.</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 1123549, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "bc4329ddf326d09da39a2634a62a78e1", "sha256": "6a5a774889487c6b0f24c5dda27e1d28b460892bea0ab7059f77da4cae4a3c3d"}, "downloads": -1, "filename": "hypatia-0.1.tar.gz", "has_sig": false, "md5_digest": "bc4329ddf326d09da39a2634a62a78e1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 134619, "upload_time": "2014-02-09T22:10:29", "upload_time_iso_8601": "2014-02-09T22:10:29.019946Z", "url": "https://files.pythonhosted.org/packages/a1/7b/c7297ba6d09f1dae29a4154bc8e6b45feea8cd6a1f7b7230b2626eb33de1/hypatia-0.1.tar.gz", "yanked": false}], "0.1a1": [{"comment_text": "", "digests": {"md5": "f87b83aaf04085fd4d630b40de146620", "sha256": "92e93ee0d60bd89e49f0285a7dc9b0b4ab5c4d905eb38d51a8223dc55fb5b288"}, "downloads": -1, "filename": "hypatia-0.1a1.tar.gz", "has_sig": false, "md5_digest": "f87b83aaf04085fd4d630b40de146620", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 124015, "upload_time": "2012-06-20T17:31:54", "upload_time_iso_8601": "2012-06-20T17:31:54.077311Z", "url": "https://files.pythonhosted.org/packages/d9/1b/10b9344294fc13e0dd1b8ae39c978517576f260bf116f0bba1702325a927/hypatia-0.1a1.tar.gz", "yanked": false}], "0.1a2": [{"comment_text": "", "digests": {"md5": "b4d86eba24e64cb42ee79678d495a0d5", "sha256": "b35f4edf2209c2082168a2c9eaa9109165025edbdbc7f4f8937e3c5d40676caf"}, "downloads": -1, "filename": "hypatia-0.1a2.tar.gz", "has_sig": false, "md5_digest": "b4d86eba24e64cb42ee79678d495a0d5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 124402, "upload_time": "2012-07-03T00:36:49", "upload_time_iso_8601": "2012-07-03T00:36:49.608702Z", "url": "https://files.pythonhosted.org/packages/74/8c/2e0083d537db7104e6b92c066bf0b53ff833d4f9b67157c149a4ec820dcb/hypatia-0.1a2.tar.gz", "yanked": false}], "0.1a3": [{"comment_text": "", "digests": {"md5": "1cce408d64d36d4f682c6eadb8b48094", "sha256": "76fa720a9033108d6cfc3477284e8420a3c2c8dcacd9520908a51c82a8235574"}, "downloads": -1, "filename": "hypatia-0.1a3.tar.gz", "has_sig": false, "md5_digest": "1cce408d64d36d4f682c6eadb8b48094", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 127927, "upload_time": "2013-01-11T02:45:40", "upload_time_iso_8601": "2013-01-11T02:45:40.609722Z", "url": "https://files.pythonhosted.org/packages/fa/cd/18b1708421c41187e794fdcd2ed2aad40cd7c75d930f34a7fdce38489c89/hypatia-0.1a3.tar.gz", "yanked": false}], "0.1a4": [{"comment_text": "", "digests": {"md5": "e837563672d295687bfb61ab4275a11d", "sha256": "f0f0fa20a70084102fe36c2435d147ad1caada6c9394734b3b3cdd217addbe45"}, "downloads": -1, "filename": "hypatia-0.1a4.tar.gz", "has_sig": false, "md5_digest": "e837563672d295687bfb61ab4275a11d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 132243, "upload_time": "2013-04-28T09:07:03", "upload_time_iso_8601": "2013-04-28T09:07:03.306621Z", "url": "https://files.pythonhosted.org/packages/f0/9c/a16d12846829762f85ed29de5155a9bfa60dce308102419dec0618f7d1d0/hypatia-0.1a4.tar.gz", "yanked": false}], "0.1a5": [{"comment_text": "", "digests": {"md5": "43934a72549d04abf7b43c2ace371b2e", "sha256": "258075e9a7eb3c9ee4f359a51f581da3de0d912744978d67e66a150098a763d4"}, "downloads": -1, "filename": "hypatia-0.1a5.tar.gz", "has_sig": false, "md5_digest": "43934a72549d04abf7b43c2ace371b2e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 135374, "upload_time": "2013-05-06T12:42:44", "upload_time_iso_8601": "2013-05-06T12:42:44.318270Z", "url": "https://files.pythonhosted.org/packages/73/37/2120a06c659b046ac3e97cd4709ca5a3071c3cbdbe2899baeae8e3095566/hypatia-0.1a5.tar.gz", "yanked": false}], "0.1a6": [{"comment_text": "", "digests": {"md5": "3a67683c578754cd8f23317db6d28ffd", "sha256": "66d0e32c342fd5e5009bfc207f943fbc47a210daf1f3694790f6a351f0eb70c0"}, "downloads": -1, "filename": "hypatia-0.1a6.tar.gz", "has_sig": false, "md5_digest": "3a67683c578754cd8f23317db6d28ffd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 135715, "upload_time": "2013-05-30T05:04:58", "upload_time_iso_8601": "2013-05-30T05:04:58.452112Z", "url": "https://files.pythonhosted.org/packages/a7/ee/4f7052c840039eef975f7ffea9e13dfcda24bebf6b9897887063e60ea9cf/hypatia-0.1a6.tar.gz", "yanked": false}], "0.1a7": [{"comment_text": "", "digests": {"md5": "e9a46f4722c042328d5c6eb2f4fc043a", "sha256": "7522c82f371c1fe5de8aabef01d29e5b9727045d750cb640418e8578bceb7c22"}, "downloads": -1, "filename": "hypatia-0.1a7.tar.gz", "has_sig": false, "md5_digest": "e9a46f4722c042328d5c6eb2f4fc043a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 136875, "upload_time": "2013-10-08T11:35:08", "upload_time_iso_8601": "2013-10-08T11:35:08.642183Z", "url": "https://files.pythonhosted.org/packages/59/a4/f4c5e3174c55be35e040292dcba1d8ba6ed405abb6abcdf192b7902f4562/hypatia-0.1a7.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "a17f01bc97fade9d09b3b519d0468185", "sha256": "2617763447306d01c90e9abf719a20befbd41ce8b41c087334cf4cbcdc028879"}, "downloads": -1, "filename": "hypatia-0.2.tar.gz", "has_sig": false, "md5_digest": "a17f01bc97fade9d09b3b519d0468185", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 137772, "upload_time": "2014-05-17T03:23:17", "upload_time_iso_8601": "2014-05-17T03:23:17.527201Z", "url": "https://files.pythonhosted.org/packages/d0/f8/d6f895732e3858e054ed885e754bdd4a93ddd377baaf939e19dd228b20ae/hypatia-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "d74c6dda31ff459a39fa5da9e98f2425", "sha256": "fb4d394eeac4b06ff2259cada6174aebbe77edd243ffd1deda320cb327f98bd9"}, "downloads": -1, "filename": "hypatia-0.3.tar.gz", "has_sig": false, "md5_digest": "d74c6dda31ff459a39fa5da9e98f2425", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 139163, "upload_time": "2014-06-13T03:56:51", "upload_time_iso_8601": "2014-06-13T03:56:51.159373Z", "url": "https://files.pythonhosted.org/packages/19/bc/4a0cccb3f35f5585f64257c0f07a378dc09150d94aa4e2d26536ef128e16/hypatia-0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d74c6dda31ff459a39fa5da9e98f2425", "sha256": "fb4d394eeac4b06ff2259cada6174aebbe77edd243ffd1deda320cb327f98bd9"}, "downloads": -1, "filename": "hypatia-0.3.tar.gz", "has_sig": false, "md5_digest": "d74c6dda31ff459a39fa5da9e98f2425", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 139163, "upload_time": "2014-06-13T03:56:51", "upload_time_iso_8601": "2014-06-13T03:56:51.159373Z", "url": "https://files.pythonhosted.org/packages/19/bc/4a0cccb3f35f5585f64257c0f07a378dc09150d94aa4e2d26536ef128e16/hypatia-0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:49:36 2020"}