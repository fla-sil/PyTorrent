{"info": {"author": "Jeremy Kenyon", "author_email": "jeremy@netki.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7"], "description": "TransactID Library Python Edition\n\nThis library is a wrapper for using [BIP70][1] and [BIP75][2]\n\nThere are three main method types that you'll use: create_\\*, verify_\\*, and get_\\*.\n\nThe options for each of these methods was pulled directly from the code and include type hints.  Things to keep \nin mind when going through this document:\n* Optional[] means a single item of the type of object inside the brackets is optional and not required.\n* List[type] means that you need to provide a list of items of the specified type.\n* type means the usual, provide a single item of that type.\n\n## General Usage\n\nWhen instantiating the class you'll need a private key PEM and optionally a certificate PEM.  Both as\nstandard str types.  Certificate will only be needed when creating signed objects.  If you aren't \nsigning or creating objects you won't need that but private key PEM is always required.\n\n    from transactid import TransactID\n    transact = TransactID(private_key_pem=private_pem, certificate_pem=cert_pem)\n\n## Invoice Request\n\nPlease refer to the [BIP75][2] documentation for detailed requirements for a InvoiceRequest.  When it comes \nto using this library to create one you'll need to provide the following:\n\n* amount: Optional[int]  # amount is integer-number-of-satoshis\n* pki_type: Optional[str]  # Currently only x509+sha256 and the string none are supported.\n* memo: Optional[str]\n* notification_url: Optional[str]\n\n*Note:* while everything is technically optional it's not recommended to leave everything blank.  See [BIP75][2] for \nfull details.\n\nCreate an object for sending like so:\n\n    serialized_invoice_request = transact.create_invoice_request(\n        amount=amount,\n        pki_type=pki_type,\n        memo=memo,\n        notification_url=notification_url\n    )\n\nThis will provide you with a serialized binary string that you can then send to someone you would like to send \nmoney to.\n\nWhen you are on the receiving end of one of those binary strings you can do the following to validate \nthe signature and parse one:\n\n    from transactid.exceptions import InvalidSignatureException\n    from transactid.exceptions import DecodeException\n\n    try:\n        transact.verify_invoice_request(serialized_invoice_request)\n    except InvalidSignatureException:\n        <let sender know the signature was invalid>\n    except DecodeException:\n        <let sendiner know there was a problem with the porotobuf object they sent over>\n    else:\n        <take data they sent you and respond appropriately>\n\nIf there are no exceptions then we were able to parse the protobuf object and validate the signature.\n\nTo access the data from the InvoiceRequest just do:\n\n    invoice_request = transact.get_verified_invoice_request()\n\nAnd that will return a dictionary with all of the fields of the InvoiceRequest and the values that were \nfilled in.\n\n## Payment Request\n\nPlease refer to the [BIP70][1] documentation for detailed requirements for a PaymentRequest. Please note we are combining\n the PaymentDetails and PaymentRequests objects for easy of use. When it comes to using this library to create \n one you'll need to provide the following:\n\n* time_stamp: datetime\n* outputs: List[(int, bytes)]  # int: amount, bytes: script (see [BIP70][1] details for more information on scripts)\n* memo: str\n* payment_url: str\n* merchant_data: bytes\n* expires: Optional[datetime]\n* pki_type: Optional[str]\n* network: str, defaults to \"main\"\n* payment_details_version: int, defaults to 1\n\nCreate an object for sending like so:\n\n    serialized_payment_request = transact.create_payment_request(\n        time_stamp=datetime.datetime.now(),\n        outputs=[(amount, script)],\n        memo=memo,\n        payment_url=payment_url,\n        merchant_data=merchant_data,\n        pki_type=pki_type\n    )\n\nThis will provide you with a serialized binary string that you can then send to someone whom you want to give you \nmoney.\n\nWhen you are on the receiving end of one of those binary strings you can do the following to validate \nthe signature and parse one:\n\n    from transactid.exceptions import InvalidSignatureException\n    from transactid.exceptions import DecodeException\n\n    try:\n        transact.verify_payment_request(serialized_invoice_request)\n    except InvalidSignatureException:\n        <let sender know the signature was invalid>\n    except DecodeException:\n        <let sendiner know there was a problem with the porotobuf object they sent over>\n    else:\n        <take data they sent you and respond appropriately>\n\nIf there are no exceptions then we were able to parse the protobuf object and validate the signature.\n\nTo access the data from the PaymentRequest just do:\n\n    payment_request = transact.get_verified_payment_request()\n\nAnd that will return a dictionary with all of the fields of the PaymentRequest and the values that were \nfilled in.\n\n## Payment\n\nPlease refer to the [BIP70][1] documentation for detailed requirements for a Payment. When it comes to using this \nlibrary to create one you'll need to provide the following:\n\n* transactions: List[bytes]\n* refund_to: List[(int, bytes)]  # int: amount, bytes: script (see BIP70 details for more information on scripts)\n* merchant_data: Optional[bytes]\n* memo: Optional[str]\n\nCreate an object for sending like so:\n\n    serialized_payment = transact.create_payment(\n        transactions=transactions,\n        refund_to=outputs,\n        memo=memo,\n        merchant_data=merchant_data,\n    )\n\nThis will provide you with a serialized binary string that you can then send to someone and let them know you gave \nthem money.\n\nWhen you are on the receiving end of one of those binary strings you can do the following to parse one.  \nPlease note that Payments aren't signed unlike the Invoice/PaymentRequest:\n\n    from transactid.exceptions import DecodeException\n\n    try:\n        transact.verify_payment_request(serialized_payment)\n    except DecodeException:\n        <let sendiner know there was a problem with the porotobuf object they sent over>\n    else:\n        <take data they sent you and respond appropriately>\n\nIf there are no exceptions then we were able to parse the protobuf object.\n\nTo access the data from the Payment just do:\n\n    payment_request = transact.get_verified_payment()\n\nAnd that will return a dictionary with all of the fields of the Payment and the values that were \nfilled in.\n\n## PaymentACK\n\nPlease refer to the [BIP70][1] documentation for detailed requirements for a PaymentACK. PaymentACKs are a bit different \nthan other things in the library.  Due to the fact that art of the PaymentACK is the Payment object you are \nacknowledging, it's not possible to create an ACK without first verifying a Payment.\n\n* memo: Optional[str]\n\nCreate an object for sending like so:\n\n    serialized_payment_ack = transact.create_payment_ack(memo=payment_ack_memo)\n\nThis will provide you with a serialized binary string that you can then send to someone to acknowledge that they \nsent you money.\n\nWhen you are on the receiving end of one of those binary strings you can do the following to parse one.  \nPlease note that Payments aren't signed unlike the Invoice/PaymentRequest:\n\n    from transactid.exceptions import DecodeException\n\n    try:\n        transact.verify_payment_ack(serialized_payment_ack)\n    except DecodeException:\n        <let sendiner know there was a problem with the porotobuf object they sent over>\n    else:\n        <take data they sent you and respond appropriately>\n\nIf there are no exceptions then we were able to parse the protobuf object.\n\nTo access the data from the PaymentACK just do:\n\n    payment_request = transact.get_verified_payment_ack()\n\nAnd that will return a dictionary with all of the fields of the PaymentACK and the values that were \nfilled in.\n\n\n[1]: https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\n[2]: https://github.com/bitcoin/bips/blob/master/bip-0075.mediawiki\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/netkicorp/transactid-library-python", "keywords": "transactid,BIP75,BIP70", "license": "BSD-3-Clause", "maintainer": "Jeremy Kenyon", "maintainer_email": "jeremy@netki.com", "name": "transactid", "package_url": "https://pypi.org/project/transactid/", "platform": "", "project_url": "https://pypi.org/project/transactid/", "project_urls": {"Homepage": "https://github.com/netkicorp/transactid-library-python", "Repository": "https://github.com/netkicorp/transactid-library-python"}, "release_url": "https://pypi.org/project/transactid/0.1.0a3/", "requires_dist": ["cryptography (==2.7)", "protobuf (==3.9.2)", "certvalidator (>=0.11.1,<0.12.0)"], "requires_python": ">=3.6.5,<4.0.0", "summary": "A package for working with BIP75 and BIP70 in a Python environment.", "version": "0.1.0a3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>TransactID Library Python Edition</p>\n<p>This library is a wrapper for using <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\" rel=\"nofollow\">BIP70</a> and <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0075.mediawiki\" rel=\"nofollow\">BIP75</a></p>\n<p>There are three main method types that you'll use: create_*, verify_*, and get_*.</p>\n<p>The options for each of these methods was pulled directly from the code and include type hints.  Things to keep\nin mind when going through this document:</p>\n<ul>\n<li>Optional[] means a single item of the type of object inside the brackets is optional and not required.</li>\n<li>List[type] means that you need to provide a list of items of the specified type.</li>\n<li>type means the usual, provide a single item of that type.</li>\n</ul>\n<h2>General Usage</h2>\n<p>When instantiating the class you'll need a private key PEM and optionally a certificate PEM.  Both as\nstandard str types.  Certificate will only be needed when creating signed objects.  If you aren't\nsigning or creating objects you won't need that but private key PEM is always required.</p>\n<pre><code>from transactid import TransactID\ntransact = TransactID(private_key_pem=private_pem, certificate_pem=cert_pem)\n</code></pre>\n<h2>Invoice Request</h2>\n<p>Please refer to the <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0075.mediawiki\" rel=\"nofollow\">BIP75</a> documentation for detailed requirements for a InvoiceRequest.  When it comes\nto using this library to create one you'll need to provide the following:</p>\n<ul>\n<li>amount: Optional[int]  # amount is integer-number-of-satoshis</li>\n<li>pki_type: Optional[str]  # Currently only x509+sha256 and the string none are supported.</li>\n<li>memo: Optional[str]</li>\n<li>notification_url: Optional[str]</li>\n</ul>\n<p><em>Note:</em> while everything is technically optional it's not recommended to leave everything blank.  See <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0075.mediawiki\" rel=\"nofollow\">BIP75</a> for\nfull details.</p>\n<p>Create an object for sending like so:</p>\n<pre><code>serialized_invoice_request = transact.create_invoice_request(\n    amount=amount,\n    pki_type=pki_type,\n    memo=memo,\n    notification_url=notification_url\n)\n</code></pre>\n<p>This will provide you with a serialized binary string that you can then send to someone you would like to send\nmoney to.</p>\n<p>When you are on the receiving end of one of those binary strings you can do the following to validate\nthe signature and parse one:</p>\n<pre><code>from transactid.exceptions import InvalidSignatureException\nfrom transactid.exceptions import DecodeException\n\ntry:\n    transact.verify_invoice_request(serialized_invoice_request)\nexcept InvalidSignatureException:\n    &lt;let sender know the signature was invalid&gt;\nexcept DecodeException:\n    &lt;let sendiner know there was a problem with the porotobuf object they sent over&gt;\nelse:\n    &lt;take data they sent you and respond appropriately&gt;\n</code></pre>\n<p>If there are no exceptions then we were able to parse the protobuf object and validate the signature.</p>\n<p>To access the data from the InvoiceRequest just do:</p>\n<pre><code>invoice_request = transact.get_verified_invoice_request()\n</code></pre>\n<p>And that will return a dictionary with all of the fields of the InvoiceRequest and the values that were\nfilled in.</p>\n<h2>Payment Request</h2>\n<p>Please refer to the <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\" rel=\"nofollow\">BIP70</a> documentation for detailed requirements for a PaymentRequest. Please note we are combining\nthe PaymentDetails and PaymentRequests objects for easy of use. When it comes to using this library to create\none you'll need to provide the following:</p>\n<ul>\n<li>time_stamp: datetime</li>\n<li>outputs: List[(int, bytes)]  # int: amount, bytes: script (see <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\" rel=\"nofollow\">BIP70</a> details for more information on scripts)</li>\n<li>memo: str</li>\n<li>payment_url: str</li>\n<li>merchant_data: bytes</li>\n<li>expires: Optional[datetime]</li>\n<li>pki_type: Optional[str]</li>\n<li>network: str, defaults to \"main\"</li>\n<li>payment_details_version: int, defaults to 1</li>\n</ul>\n<p>Create an object for sending like so:</p>\n<pre><code>serialized_payment_request = transact.create_payment_request(\n    time_stamp=datetime.datetime.now(),\n    outputs=[(amount, script)],\n    memo=memo,\n    payment_url=payment_url,\n    merchant_data=merchant_data,\n    pki_type=pki_type\n)\n</code></pre>\n<p>This will provide you with a serialized binary string that you can then send to someone whom you want to give you\nmoney.</p>\n<p>When you are on the receiving end of one of those binary strings you can do the following to validate\nthe signature and parse one:</p>\n<pre><code>from transactid.exceptions import InvalidSignatureException\nfrom transactid.exceptions import DecodeException\n\ntry:\n    transact.verify_payment_request(serialized_invoice_request)\nexcept InvalidSignatureException:\n    &lt;let sender know the signature was invalid&gt;\nexcept DecodeException:\n    &lt;let sendiner know there was a problem with the porotobuf object they sent over&gt;\nelse:\n    &lt;take data they sent you and respond appropriately&gt;\n</code></pre>\n<p>If there are no exceptions then we were able to parse the protobuf object and validate the signature.</p>\n<p>To access the data from the PaymentRequest just do:</p>\n<pre><code>payment_request = transact.get_verified_payment_request()\n</code></pre>\n<p>And that will return a dictionary with all of the fields of the PaymentRequest and the values that were\nfilled in.</p>\n<h2>Payment</h2>\n<p>Please refer to the <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\" rel=\"nofollow\">BIP70</a> documentation for detailed requirements for a Payment. When it comes to using this\nlibrary to create one you'll need to provide the following:</p>\n<ul>\n<li>transactions: List[bytes]</li>\n<li>refund_to: List[(int, bytes)]  # int: amount, bytes: script (see BIP70 details for more information on scripts)</li>\n<li>merchant_data: Optional[bytes]</li>\n<li>memo: Optional[str]</li>\n</ul>\n<p>Create an object for sending like so:</p>\n<pre><code>serialized_payment = transact.create_payment(\n    transactions=transactions,\n    refund_to=outputs,\n    memo=memo,\n    merchant_data=merchant_data,\n)\n</code></pre>\n<p>This will provide you with a serialized binary string that you can then send to someone and let them know you gave\nthem money.</p>\n<p>When you are on the receiving end of one of those binary strings you can do the following to parse one.<br>\nPlease note that Payments aren't signed unlike the Invoice/PaymentRequest:</p>\n<pre><code>from transactid.exceptions import DecodeException\n\ntry:\n    transact.verify_payment_request(serialized_payment)\nexcept DecodeException:\n    &lt;let sendiner know there was a problem with the porotobuf object they sent over&gt;\nelse:\n    &lt;take data they sent you and respond appropriately&gt;\n</code></pre>\n<p>If there are no exceptions then we were able to parse the protobuf object.</p>\n<p>To access the data from the Payment just do:</p>\n<pre><code>payment_request = transact.get_verified_payment()\n</code></pre>\n<p>And that will return a dictionary with all of the fields of the Payment and the values that were\nfilled in.</p>\n<h2>PaymentACK</h2>\n<p>Please refer to the <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki\" rel=\"nofollow\">BIP70</a> documentation for detailed requirements for a PaymentACK. PaymentACKs are a bit different\nthan other things in the library.  Due to the fact that art of the PaymentACK is the Payment object you are\nacknowledging, it's not possible to create an ACK without first verifying a Payment.</p>\n<ul>\n<li>memo: Optional[str]</li>\n</ul>\n<p>Create an object for sending like so:</p>\n<pre><code>serialized_payment_ack = transact.create_payment_ack(memo=payment_ack_memo)\n</code></pre>\n<p>This will provide you with a serialized binary string that you can then send to someone to acknowledge that they\nsent you money.</p>\n<p>When you are on the receiving end of one of those binary strings you can do the following to parse one.<br>\nPlease note that Payments aren't signed unlike the Invoice/PaymentRequest:</p>\n<pre><code>from transactid.exceptions import DecodeException\n\ntry:\n    transact.verify_payment_ack(serialized_payment_ack)\nexcept DecodeException:\n    &lt;let sendiner know there was a problem with the porotobuf object they sent over&gt;\nelse:\n    &lt;take data they sent you and respond appropriately&gt;\n</code></pre>\n<p>If there are no exceptions then we were able to parse the protobuf object.</p>\n<p>To access the data from the PaymentACK just do:</p>\n<pre><code>payment_request = transact.get_verified_payment_ack()\n</code></pre>\n<p>And that will return a dictionary with all of the fields of the PaymentACK and the values that were\nfilled in.</p>\n\n          </div>"}, "last_serial": 6566121, "releases": {"0.1.0a3": [{"comment_text": "", "digests": {"md5": "f9c42ce67e954cb2bae9bd5007201b75", "sha256": "3b3985acb30ea878ed098cf7215faf79044debe05cf446d4979a22cda7dc4c09"}, "downloads": -1, "filename": "transactid-0.1.0a3-py3-none-any.whl", "has_sig": false, "md5_digest": "f9c42ce67e954cb2bae9bd5007201b75", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.5,<4.0.0", "size": 23377, "upload_time": "2020-02-04T02:36:27", "upload_time_iso_8601": "2020-02-04T02:36:27.155957Z", "url": "https://files.pythonhosted.org/packages/0f/2d/ce0e22fe62cad9f8809b128577d90142c0a5564c28eb3c13459d6f81574f/transactid-0.1.0a3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "44c7ebd8c930e8a43b5478579d847b40", "sha256": "a6e340444d14ad5d32de8ccd19ba65997915e9c8accadf0a359781a4401de770"}, "downloads": -1, "filename": "transactid-0.1.0a3.tar.gz", "has_sig": false, "md5_digest": "44c7ebd8c930e8a43b5478579d847b40", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.5,<4.0.0", "size": 23167, "upload_time": "2020-02-04T02:36:29", "upload_time_iso_8601": "2020-02-04T02:36:29.686644Z", "url": "https://files.pythonhosted.org/packages/1d/66/74ba84a367c7e79e0381721a762acc38122de55ec8cb2eee85dad319b7a4/transactid-0.1.0a3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f9c42ce67e954cb2bae9bd5007201b75", "sha256": "3b3985acb30ea878ed098cf7215faf79044debe05cf446d4979a22cda7dc4c09"}, "downloads": -1, "filename": "transactid-0.1.0a3-py3-none-any.whl", "has_sig": false, "md5_digest": "f9c42ce67e954cb2bae9bd5007201b75", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.5,<4.0.0", "size": 23377, "upload_time": "2020-02-04T02:36:27", "upload_time_iso_8601": "2020-02-04T02:36:27.155957Z", "url": "https://files.pythonhosted.org/packages/0f/2d/ce0e22fe62cad9f8809b128577d90142c0a5564c28eb3c13459d6f81574f/transactid-0.1.0a3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "44c7ebd8c930e8a43b5478579d847b40", "sha256": "a6e340444d14ad5d32de8ccd19ba65997915e9c8accadf0a359781a4401de770"}, "downloads": -1, "filename": "transactid-0.1.0a3.tar.gz", "has_sig": false, "md5_digest": "44c7ebd8c930e8a43b5478579d847b40", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.5,<4.0.0", "size": 23167, "upload_time": "2020-02-04T02:36:29", "upload_time_iso_8601": "2020-02-04T02:36:29.686644Z", "url": "https://files.pythonhosted.org/packages/1d/66/74ba84a367c7e79e0381721a762acc38122de55ec8cb2eee85dad319b7a4/transactid-0.1.0a3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:48:23 2020"}