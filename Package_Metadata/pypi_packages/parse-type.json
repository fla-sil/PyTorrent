{"info": {"author": "Jens Engel", "author_email": "jenisys@noreply.github.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Code Generators", "Topic :: Software Development :: Libraries :: Python Modules"], "description": ".. image:: https://img.shields.io/travis/jenisys/parse_type/master.svg\n    :target: https://travis-ci.org/jenisys/parse_type\n    :alt: Travis CI Build Status\n\n.. image:: https://img.shields.io/pypi/v/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type\n    :alt: Latest Version\n\n.. image:: https://img.shields.io/pypi/dm/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type\n    :alt: Downloads\n\n.. image:: https://img.shields.io/pypi/l/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type/\n    :alt: License\n\n\n`parse_type`_ extends the `parse`_ module (opposite of `string.format()`_)\nwith the following features:\n\n* build type converters for common use cases (enum/mapping, choice)\n* build a type converter with a cardinality constraint (0..1, 0..*, 1..*)\n    from the type converter with cardinality=1.\n* compose a type converter from other type converters\n* an extended parser that supports the CardinalityField naming schema\n    and creates missing type variants (0..1, 0..*, 1..*) from the\n    primary type converter\n\n.. _parse_type: http://pypi.python.org/pypi/parse_type\n.. _parse:      http://pypi.python.org/pypi/parse\n.. _`string.format()`: http://docs.python.org/library/string.html#format-string-syntax\n\n\nDefinitions\n-------------------------------------------------------------------------------\n\n*type converter*\n    A type converter function that converts a textual representation\n    of a value type into instance of this value type.\n    In addition, a type converter function is often annotated with attributes\n    that allows the `parse`_ module to use it in a generic way.\n    A type converter is also called a *parse_type* (a definition used here).\n\n*cardinality field*\n    A naming convention for related types that differ in cardinality.\n    A cardinality field is a type name suffix in the format of a field.\n    It allows parse format expression, ala::\n\n        \"{person:Person}\"     #< Cardinality: 1    (one; the normal case)\n        \"{person:Person?}\"    #< Cardinality: 0..1 (zero or one  = optional)\n        \"{persons:Person*}\"   #< Cardinality: 0..* (zero or more = many0)\n        \"{persons:Person+}\"   #< Cardinality: 1..* (one  or more = many)\n\n    This naming convention mimics the relationship descriptions in UML diagrams.\n\n\nBasic Example\n-------------------------------------------------------------------------------\n\nDefine an own type converter for numbers (integers):\n\n.. code-block:: python\n\n    # -- USE CASE:\n    def parse_number(text):\n        return int(text)\n    parse_number.pattern = r\"\\d+\"  # -- REGULAR EXPRESSION pattern for type.\n\nThis is equivalent to:\n\n.. code-block:: python\n\n    import parse\n\n    @parse.with_pattern(r\"\\d+\")\n    def parse_number(text):\n         return int(text)\n    assert hasattr(parse_number, \"pattern\")\n    assert parse_number.pattern == r\"\\d+\"\n\n\n.. code-block:: python\n\n    # -- USE CASE: Use the type converter with the parse module.\n    schema = \"Hello {number:Number}\"\n    parser = parse.Parser(schema, dict(Number=parse_number))\n    result = parser.parse(\"Hello 42\")\n    assert result is not None, \"REQUIRE: text matches the schema.\"\n    assert result[\"number\"] == 42\n\n    result = parser.parse(\"Hello XXX\")\n    assert result is None, \"MISMATCH: text does not match the schema.\"\n\n.. hint::\n\n    The described functionality above is standard functionality\n    of the `parse`_ module. It serves as introduction for the remaining cases.\n\n\nCardinality\n-------------------------------------------------------------------------------\n\nCreate an type converter for \"ManyNumbers\" (List, separated with commas)\nwith cardinality \"1..* = 1+\" (many) from the type converter for a \"Number\".\n\n.. code-block:: python\n\n    # -- USE CASE: Create new type converter with a cardinality constraint.\n    # CARDINALITY: many := one or more (1..*)\n    from parse import Parser\n    from parse_type import TypeBuilder\n    parse_numbers = TypeBuilder.with_many(parse_number, listsep=\",\")\n\n    schema = \"List: {numbers:ManyNumbers}\"\n    parser = Parser(schema, dict(ManyNumbers=parse_numbers))\n    result = parser.parse(\"List: 1, 2, 3\")\n    assert result[\"numbers\"] == [1, 2, 3]\n\n\nCreate an type converter for an \"OptionalNumbers\" with cardinality \"0..1 = ?\"\n(optional) from the type converter for a \"Number\".\n\n.. code-block:: python\n\n    # -- USE CASE: Create new type converter with cardinality constraint.\n    # CARDINALITY: optional := zero or one (0..1)\n    from parse import Parser\n    from parse_type import TypeBuilder\n\n    parse_optional_number = TypeBuilder.with_optional(parse_number)\n    schema = \"Optional: {number:OptionalNumber}\"\n    parser = Parser(schema, dict(OptionalNumber=parse_optional_number))\n    result = parser.parse(\"Optional: 42\")\n    assert result[\"number\"] == 42\n    result = parser.parse(\"Optional: \")\n    assert result[\"number\"] == None\n\n\nEnumeration (Name-to-Value Mapping)\n-------------------------------------------------------------------------------\n\nCreate an type converter for an \"Enumeration\" from the description of\nthe mapping as dictionary.\n\n.. code-block:: python\n\n    # -- USE CASE: Create a type converter for an enumeration.\n    from parse import Parser\n    from parse_type import TypeBuilder\n\n    parse_enum_yesno = TypeBuilder.make_enum({\"yes\": True, \"no\": False})\n    parser = Parser(\"Answer: {answer:YesNo}\", dict(YesNo=parse_enum_yesno))\n    result = parser.parse(\"Answer: yes\")\n    assert result[\"answer\"] == True\n\n\nCreate an type converter for an \"Enumeration\" from the description of\nthe mapping as an enumeration class (`Python 3.4 enum`_ or the `enum34`_\nbackport; see also: `PEP-0435`_).\n\n.. code-block:: python\n\n    # -- USE CASE: Create a type converter for enum34 enumeration class.\n    # NOTE: Use Python 3.4 or enum34 backport.\n    from parse import Parser\n    from parse_type import TypeBuilder\n    from enum import Enum\n\n    class Color(Enum):\n        red   = 1\n        green = 2\n        blue  = 3\n\n    parse_enum_color = TypeBuilder.make_enum(Color)\n    parser = Parser(\"Select: {color:Color}\", dict(Color=parse_enum_color))\n    result = parser.parse(\"Select: red\")\n    assert result[\"color\"] is Color.red\n\n.. _`Python 3.4 enum`: http://docs.python.org/3.4/library/enum.html#module-enum\n.. _enum34:   http://pypi.python.org/pypi/enum34\n.. _PEP-0435: http://www.python.org/dev/peps/pep-0435\n\n\nChoice (Name Enumeration)\n-------------------------------------------------------------------------------\n\nA Choice data type allows to select one of several strings.\n\nCreate an type converter for an \"Choice\" list, a list of unique names\n(as string).\n\n.. code-block:: python\n\n    from parse import Parser\n    from parse_type import TypeBuilder\n\n    parse_choice_yesno = TypeBuilder.make_choice([\"yes\", \"no\"])\n    schema = \"Answer: {answer:ChoiceYesNo}\"\n    parser = Parser(schema, dict(ChoiceYesNo=parse_choice_yesno))\n    result = parser.parse(\"Answer: yes\")\n    assert result[\"answer\"] == \"yes\"\n\n\nVariant (Type Alternatives)\n-------------------------------------------------------------------------------\n\nSometimes you need a type converter that can accept text for multiple\ntype converter alternatives. This is normally called a \"variant\" (or: union).\n\nCreate an type converter for an \"Variant\" type that accepts:\n\n* Numbers (positive numbers, as integer)\n* Color enum values (by name)\n\n.. code-block:: python\n\n    from parse import Parser, with_pattern\n    from parse_type import TypeBuilder\n    from enum import Enum\n\n    class Color(Enum):\n        red   = 1\n        green = 2\n        blue  = 3\n\n    @with_pattern(r\"\\d+\")\n    def parse_number(text):\n        return int(text)\n\n    # -- MAKE VARIANT: Alternatives of different type converters.\n    parse_color = TypeBuilder.make_enum(Color)\n    parse_variant = TypeBuilder.make_variant([parse_number, parse_color])\n    schema = \"Variant: {variant:Number_or_Color}\"\n    parser = Parser(schema, dict(Number_or_Color=parse_variant))\n\n    # -- TEST VARIANT: With number, color and mismatch.\n    result = parser.parse(\"Variant: 42\")\n    assert result[\"variant\"] == 42\n    result = parser.parse(\"Variant: blue\")\n    assert result[\"variant\"] is Color.blue\n    result = parser.parse(\"Variant: __MISMATCH__\")\n    assert not result\n\n\n\nExtended Parser with CardinalityField support\n-------------------------------------------------------------------------------\n\nThe parser extends the ``parse.Parser`` and adds the following functionality:\n\n   * supports the CardinalityField naming scheme\n   * automatically creates missing type variants for types with\n     a CardinalityField by using the primary type converter for cardinality=1\n   * extends the provide type converter dictionary with new type variants.\n\nExample:\n\n.. code-block:: python\n\n    # -- USE CASE: Parser with CardinalityField support.\n    # NOTE: Automatically adds missing type variants with CardinalityField part.\n    # USE:  parse_number() type converter from above.\n    from parse_type.cfparse import Parser\n\n    # -- PREPARE: parser, adds missing type variant for cardinality 1..* (many)\n    type_dict = dict(Number=parse_number)\n    schema = \"List: {numbers:Number+}\"\n    parser = Parser(schema, type_dict)\n    assert \"Number+\" in type_dict, \"Created missing type variant based on: Number\"\n\n    # -- USE: parser.\n    result = parser.parse(\"List: 1, 2, 3\")\n    assert result[\"numbers\"] == [1, 2, 3]\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "http://pypi.python.org/pypi/parse_type", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jenisys/parse_type", "keywords": "parse,parsing", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "parse-type", "package_url": "https://pypi.org/project/parse-type/", "platform": "any", "project_url": "https://pypi.org/project/parse-type/", "project_urls": {"Download": "http://pypi.python.org/pypi/parse_type", "Homepage": "https://github.com/jenisys/parse_type"}, "release_url": "https://pypi.org/project/parse-type/0.5.2/", "requires_dist": ["parse (>=1.8.4)", "six (>=1.11)", "ordereddict ; python_version < \"2.7\"", "enum34 ; python_version < \"3.4\"", "coverage (>=4.4) ; extra == 'develop'", "pytest (>=3.2) ; extra == 'develop'", "pytest-cov ; extra == 'develop'", "tox (>=2.8) ; extra == 'develop'", "sphinx (>=1.2) ; extra == 'docs'"], "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "summary": "Simplifies to build parse types based on the parse module", "version": "0.5.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/jenisys/parse_type\" rel=\"nofollow\"><img alt=\"Travis CI Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c718bea5a9147a834f524385fc9bc785ea2358a7/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f6a656e697379732f70617273655f747970652f6d61737465722e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/parse_type\" rel=\"nofollow\"><img alt=\"Latest Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3eab0a857272f9139dc29e3307060647d3f95daf/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f70617273655f747970652e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/parse_type\" rel=\"nofollow\"><img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a6046dd79bc432ce67a69893535ee5a33cc0fc64/68747470733a2f2f696d672e736869656c64732e696f2f707970692f646d2f70617273655f747970652e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/parse_type/\" rel=\"nofollow\"><img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b648a680d86c11d4a5a5ccc2f5a9601f8dc61175/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f70617273655f747970652e737667\"></a>\n<p><a href=\"http://pypi.python.org/pypi/parse_type\" rel=\"nofollow\">parse_type</a> extends the <a href=\"http://pypi.python.org/pypi/parse\" rel=\"nofollow\">parse</a> module (opposite of <a href=\"http://docs.python.org/library/string.html#format-string-syntax\" rel=\"nofollow\">string.format()</a>)\nwith the following features:</p>\n<ul>\n<li>build type converters for common use cases (enum/mapping, choice)</li>\n<li><dl>\n<dt>build a type converter with a cardinality constraint (0..1, 0..*, 1..*)</dt>\n<dd>from the type converter with cardinality=1.</dd>\n</dl>\n</li>\n<li>compose a type converter from other type converters</li>\n<li><dl>\n<dt>an extended parser that supports the CardinalityField naming schema</dt>\n<dd>and creates missing type variants (0..1, 0..*, 1..*) from the\nprimary type converter</dd>\n</dl>\n</li>\n</ul>\n<div id=\"definitions\">\n<h2>Definitions</h2>\n<dl>\n<dt><em>type converter</em></dt>\n<dd>A type converter function that converts a textual representation\nof a value type into instance of this value type.\nIn addition, a type converter function is often annotated with attributes\nthat allows the <a href=\"http://pypi.python.org/pypi/parse\" rel=\"nofollow\">parse</a> module to use it in a generic way.\nA type converter is also called a <em>parse_type</em> (a definition used here).</dd>\n<dt><em>cardinality field</em></dt>\n<dd><p>A naming convention for related types that differ in cardinality.\nA cardinality field is a type name suffix in the format of a field.\nIt allows parse format expression, ala:</p>\n<pre>\"{person:Person}\"     #&lt; Cardinality: 1    (one; the normal case)\n\"{person:Person?}\"    #&lt; Cardinality: 0..1 (zero or one  = optional)\n\"{persons:Person*}\"   #&lt; Cardinality: 0..* (zero or more = many0)\n\"{persons:Person+}\"   #&lt; Cardinality: 1..* (one  or more = many)\n</pre>\n<p>This naming convention mimics the relationship descriptions in UML diagrams.</p>\n</dd>\n</dl>\n</div>\n<div id=\"basic-example\">\n<h2>Basic Example</h2>\n<p>Define an own type converter for numbers (integers):</p>\n<pre><span class=\"c1\"># -- USE CASE:</span>\n<span class=\"k\">def</span> <span class=\"nf\">parse_number</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"n\">parse_number</span><span class=\"o\">.</span><span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"sa\">r</span><span class=\"s2\">\"\\d+\"</span>  <span class=\"c1\"># -- REGULAR EXPRESSION pattern for type.</span>\n</pre>\n<p>This is equivalent to:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">parse</span>\n\n<span class=\"nd\">@parse</span><span class=\"o\">.</span><span class=\"n\">with_pattern</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">\"\\d+\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">parse_number</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n     <span class=\"k\">return</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">parse_number</span><span class=\"p\">,</span> <span class=\"s2\">\"pattern\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">parse_number</span><span class=\"o\">.</span><span class=\"n\">pattern</span> <span class=\"o\">==</span> <span class=\"sa\">r</span><span class=\"s2\">\"\\d+\"</span>\n</pre>\n<pre><span class=\"c1\"># -- USE CASE: Use the type converter with the parse module.</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"Hello {number:Number}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">parse</span><span class=\"o\">.</span><span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">Number</span><span class=\"o\">=</span><span class=\"n\">parse_number</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Hello 42\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"s2\">\"REQUIRE: text matches the schema.\"</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"number\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">42</span>\n\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Hello XXX\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"s2\">\"MISMATCH: text does not match the schema.\"</span>\n</pre>\n<div>\n<p>Hint</p>\n<p>The described functionality above is standard functionality\nof the <a href=\"http://pypi.python.org/pypi/parse\" rel=\"nofollow\">parse</a> module. It serves as introduction for the remaining cases.</p>\n</div>\n</div>\n<div id=\"cardinality\">\n<h2>Cardinality</h2>\n<p>Create an type converter for \u201cManyNumbers\u201d (List, separated with commas)\nwith cardinality \u201c1..* = 1+\u201d (many) from the type converter for a \u201cNumber\u201d.</p>\n<pre><span class=\"c1\"># -- USE CASE: Create new type converter with a cardinality constraint.</span>\n<span class=\"c1\"># CARDINALITY: many := one or more (1..*)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n<span class=\"n\">parse_numbers</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">with_many</span><span class=\"p\">(</span><span class=\"n\">parse_number</span><span class=\"p\">,</span> <span class=\"n\">listsep</span><span class=\"o\">=</span><span class=\"s2\">\",\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"List: {numbers:ManyNumbers}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">ManyNumbers</span><span class=\"o\">=</span><span class=\"n\">parse_numbers</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"List: 1, 2, 3\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"numbers\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]</span>\n</pre>\n<p>Create an type converter for an \u201cOptionalNumbers\u201d with cardinality \u201c0..1 = ?\u201d\n(optional) from the type converter for a \u201cNumber\u201d.</p>\n<pre><span class=\"c1\"># -- USE CASE: Create new type converter with cardinality constraint.</span>\n<span class=\"c1\"># CARDINALITY: optional := zero or one (0..1)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n\n<span class=\"n\">parse_optional_number</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">with_optional</span><span class=\"p\">(</span><span class=\"n\">parse_number</span><span class=\"p\">)</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"Optional: {number:OptionalNumber}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">OptionalNumber</span><span class=\"o\">=</span><span class=\"n\">parse_optional_number</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Optional: 42\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"number\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">42</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Optional: \"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"number\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"kc\">None</span>\n</pre>\n</div>\n<div id=\"enumeration-name-to-value-mapping\">\n<h2>Enumeration (Name-to-Value Mapping)</h2>\n<p>Create an type converter for an \u201cEnumeration\u201d from the description of\nthe mapping as dictionary.</p>\n<pre><span class=\"c1\"># -- USE CASE: Create a type converter for an enumeration.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n\n<span class=\"n\">parse_enum_yesno</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_enum</span><span class=\"p\">({</span><span class=\"s2\">\"yes\"</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"s2\">\"no\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">})</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"s2\">\"Answer: {answer:YesNo}\"</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">YesNo</span><span class=\"o\">=</span><span class=\"n\">parse_enum_yesno</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Answer: yes\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"answer\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<p>Create an type converter for an \u201cEnumeration\u201d from the description of\nthe mapping as an enumeration class (<a href=\"http://docs.python.org/3.4/library/enum.html#module-enum\" rel=\"nofollow\">Python 3.4 enum</a> or the <a href=\"http://pypi.python.org/pypi/enum34\" rel=\"nofollow\">enum34</a>\nbackport; see also: <a href=\"http://www.python.org/dev/peps/pep-0435\" rel=\"nofollow\">PEP-0435</a>).</p>\n<pre><span class=\"c1\"># -- USE CASE: Create a type converter for enum34 enumeration class.</span>\n<span class=\"c1\"># NOTE: Use Python 3.4 or enum34 backport.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">enum</span> <span class=\"kn\">import</span> <span class=\"n\">Enum</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Color</span><span class=\"p\">(</span><span class=\"n\">Enum</span><span class=\"p\">):</span>\n    <span class=\"n\">red</span>   <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">green</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n    <span class=\"n\">blue</span>  <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"n\">parse_enum_color</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_enum</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">)</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"s2\">\"Select: {color:Color}\"</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"o\">=</span><span class=\"n\">parse_enum_color</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Select: red\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"color\"</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"n\">Color</span><span class=\"o\">.</span><span class=\"n\">red</span>\n</pre>\n</div>\n<div id=\"choice-name-enumeration\">\n<h2>Choice (Name Enumeration)</h2>\n<p>A Choice data type allows to select one of several strings.</p>\n<p>Create an type converter for an \u201cChoice\u201d list, a list of unique names\n(as string).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n\n<span class=\"n\">parse_choice_yesno</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_choice</span><span class=\"p\">([</span><span class=\"s2\">\"yes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"no\"</span><span class=\"p\">])</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"Answer: {answer:ChoiceYesNo}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">ChoiceYesNo</span><span class=\"o\">=</span><span class=\"n\">parse_choice_yesno</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Answer: yes\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"answer\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s2\">\"yes\"</span>\n</pre>\n</div>\n<div id=\"variant-type-alternatives\">\n<h2>Variant (Type Alternatives)</h2>\n<p>Sometimes you need a type converter that can accept text for multiple\ntype converter alternatives. This is normally called a \u201cvariant\u201d (or: union).</p>\n<p>Create an type converter for an \u201cVariant\u201d type that accepts:</p>\n<ul>\n<li>Numbers (positive numbers, as integer)</li>\n<li>Color enum values (by name)</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span><span class=\"p\">,</span> <span class=\"n\">with_pattern</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">enum</span> <span class=\"kn\">import</span> <span class=\"n\">Enum</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Color</span><span class=\"p\">(</span><span class=\"n\">Enum</span><span class=\"p\">):</span>\n    <span class=\"n\">red</span>   <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">green</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n    <span class=\"n\">blue</span>  <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"nd\">@with_pattern</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">\"\\d+\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">parse_number</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># -- MAKE VARIANT: Alternatives of different type converters.</span>\n<span class=\"n\">parse_color</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_enum</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">)</span>\n<span class=\"n\">parse_variant</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_variant</span><span class=\"p\">([</span><span class=\"n\">parse_number</span><span class=\"p\">,</span> <span class=\"n\">parse_color</span><span class=\"p\">])</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"Variant: {variant:Number_or_Color}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">Number_or_Color</span><span class=\"o\">=</span><span class=\"n\">parse_variant</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># -- TEST VARIANT: With number, color and mismatch.</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Variant: 42\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"variant\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">42</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Variant: blue\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"variant\"</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"n\">Color</span><span class=\"o\">.</span><span class=\"n\">blue</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Variant: __MISMATCH__\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"ow\">not</span> <span class=\"n\">result</span>\n</pre>\n</div>\n<div id=\"extended-parser-with-cardinalityfield-support\">\n<h2>Extended Parser with CardinalityField support</h2>\n<p>The parser extends the <tt>parse.Parser</tt> and adds the following functionality:</p>\n<blockquote>\n<ul>\n<li>supports the CardinalityField naming scheme</li>\n<li>automatically creates missing type variants for types with\na CardinalityField by using the primary type converter for cardinality=1</li>\n<li>extends the provide type converter dictionary with new type variants.</li>\n</ul>\n</blockquote>\n<p>Example:</p>\n<pre><span class=\"c1\"># -- USE CASE: Parser with CardinalityField support.</span>\n<span class=\"c1\"># NOTE: Automatically adds missing type variants with CardinalityField part.</span>\n<span class=\"c1\"># USE:  parse_number() type converter from above.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type.cfparse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n\n<span class=\"c1\"># -- PREPARE: parser, adds missing type variant for cardinality 1..* (many)</span>\n<span class=\"n\">type_dict</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">Number</span><span class=\"o\">=</span><span class=\"n\">parse_number</span><span class=\"p\">)</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"List: {numbers:Number+}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"n\">type_dict</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"s2\">\"Number+\"</span> <span class=\"ow\">in</span> <span class=\"n\">type_dict</span><span class=\"p\">,</span> <span class=\"s2\">\"Created missing type variant based on: Number\"</span>\n\n<span class=\"c1\"># -- USE: parser.</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"List: 1, 2, 3\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"numbers\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 5530374, "releases": {"0.3.4": [{"comment_text": "", "digests": {"md5": "00ba70bc5ca67624207b0dfced01dc8a", "sha256": "3dd0b323bafcb8c25e000ce5589042a1c99cba9c3bec77b9f591e46bc9606147"}, "downloads": -1, "filename": "parse_type-0.3.4.tar.gz", "has_sig": false, "md5_digest": "00ba70bc5ca67624207b0dfced01dc8a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62199, "upload_time": "2013-11-04T23:20:11", "upload_time_iso_8601": "2013-11-04T23:20:11.248160Z", "url": "https://files.pythonhosted.org/packages/3e/d0/4edd333af8c085eb2420272e1dab2cfc643bac4767231c20d7f63c643822/parse_type-0.3.4.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "fb580e3a332ad35ecd071f91607a7d52", "sha256": "b2f1c9b7b8cd998d889f2e2d8cc52c98b05294181241f1365857bee9049c6126"}, "downloads": -1, "filename": "parse_type-0.4.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "fb580e3a332ad35ecd071f91607a7d52", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6, >=3.2", "size": 243623, "upload_time": "2017-09-24T13:39:03", "upload_time_iso_8601": "2017-09-24T13:39:03.196609Z", "url": "https://files.pythonhosted.org/packages/12/df/b52077529b3b4ae66d8dd2aa7a0d83b39f3d637708bf461afbe6528cc6e6/parse_type-0.4.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "db2567c9295528636d029eba3a24b826", "sha256": "9ac6014d9756c477b9d076068346ab0d06cf0adbab3b215a565173312a5028c0"}, "downloads": -1, "filename": "parse_type-0.4.0.tar.gz", "has_sig": false, "md5_digest": "db2567c9295528636d029eba3a24b826", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6, >=3.2", "size": 264339, "upload_time": "2017-09-24T13:39:09", "upload_time_iso_8601": "2017-09-24T13:39:09.360540Z", "url": "https://files.pythonhosted.org/packages/de/66/6f4af7306e83174d706b126787e5c6c438f310941c848d037c5c6c3eb528/parse_type-0.4.0.tar.gz", "yanked": false}], "0.4.1": [{"comment_text": "", "digests": {"md5": "aff1a21a0bc2725c70cb928ee6b57fe6", "sha256": "98a42b8374391ab0b810f0d40371feb8d3562fdf7092ef78c54a068d83c0190e"}, "downloads": -1, "filename": "parse_type-0.4.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "aff1a21a0bc2725c70cb928ee6b57fe6", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "size": 33269, "upload_time": "2017-09-24T15:01:56", "upload_time_iso_8601": "2017-09-24T15:01:56.905602Z", "url": "https://files.pythonhosted.org/packages/15/75/8781ce2ccda8872c72af6b5d19aec3335794b75e92ee76aa925119357152/parse_type-0.4.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3697afc1b29f2857f6c7dc9590f25ce1", "sha256": "9a624f3b51604423f5de5321da11b0ae73f368b2a3cb4b383a6cf84ca4e4d495"}, "downloads": -1, "filename": "parse_type-0.4.1.tar.gz", "has_sig": false, "md5_digest": "3697afc1b29f2857f6c7dc9590f25ce1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "size": 264490, "upload_time": "2017-09-24T15:02:02", "upload_time_iso_8601": "2017-09-24T15:02:02.589984Z", "url": "https://files.pythonhosted.org/packages/a1/b4/2d4928d79da272ff6e84fed5c21a828ee0772788a80162c6af5800987f9f/parse_type-0.4.1.tar.gz", "yanked": false}], "0.4.2": [{"comment_text": "", "digests": {"md5": "96bf1a8c289c7144579152db8a1e862c", "sha256": "6e906a66f340252e4c324914a60d417d33a4bea01292ea9bbf68b4fc123be8c9"}, "downloads": -1, "filename": "parse_type-0.4.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "96bf1a8c289c7144579152db8a1e862c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "size": 33237, "upload_time": "2017-09-25T23:26:51", "upload_time_iso_8601": "2017-09-25T23:26:51.389619Z", "url": "https://files.pythonhosted.org/packages/a2/c9/e6fd8092a5a06f2519ec434ca8e9e42238384f64c9b659456d98b0593b89/parse_type-0.4.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b5fa59e45965d1b2896023742df2e707", "sha256": "f596bdc75d3dd93036fbfe3d04127da9f6df0c26c36e01e76da85adef4336b3c"}, "downloads": -1, "filename": "parse_type-0.4.2.tar.gz", "has_sig": false, "md5_digest": "b5fa59e45965d1b2896023742df2e707", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "size": 264473, "upload_time": "2017-09-25T23:26:54", "upload_time_iso_8601": "2017-09-25T23:26:54.136506Z", "url": "https://files.pythonhosted.org/packages/2b/e5/312ce9f1bd209afcf4fc68235c8776a36270d24ad05bdfd2aaaf06647ea9/parse_type-0.4.2.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "327ab538c9c80a9b68d499d05a14231d", "sha256": "089a471b06327103865dfec2dd844230c3c658a4a1b5b4c8b6c16c8f77577f9e"}, "downloads": -1, "filename": "parse_type-0.5.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "327ab538c9c80a9b68d499d05a14231d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "size": 32236, "upload_time": "2019-07-14T08:36:54", "upload_time_iso_8601": "2019-07-14T08:36:54.644894Z", "url": "https://files.pythonhosted.org/packages/1b/81/2a168b41acb57f1ea8e1e09937f585a0b9105557b13562ff8655fea81c09/parse_type-0.5.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b954062f14ab723a91fe1e2be15e859d", "sha256": "7f690b18d35048c15438d6d0571f9045cffbec5907e0b1ccf006f889e3a38c0b"}, "downloads": -1, "filename": "parse_type-0.5.2.tar.gz", "has_sig": false, "md5_digest": "b954062f14ab723a91fe1e2be15e859d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "size": 272082, "upload_time": "2019-07-14T08:36:58", "upload_time_iso_8601": "2019-07-14T08:36:58.183075Z", "url": "https://files.pythonhosted.org/packages/2e/79/81bebd1b0446d46733db99d74543b4bb80646ef4c988584bae0862e706bc/parse_type-0.5.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "327ab538c9c80a9b68d499d05a14231d", "sha256": "089a471b06327103865dfec2dd844230c3c658a4a1b5b4c8b6c16c8f77577f9e"}, "downloads": -1, "filename": "parse_type-0.5.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "327ab538c9c80a9b68d499d05a14231d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "size": 32236, "upload_time": "2019-07-14T08:36:54", "upload_time_iso_8601": "2019-07-14T08:36:54.644894Z", "url": "https://files.pythonhosted.org/packages/1b/81/2a168b41acb57f1ea8e1e09937f585a0b9105557b13562ff8655fea81c09/parse_type-0.5.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b954062f14ab723a91fe1e2be15e859d", "sha256": "7f690b18d35048c15438d6d0571f9045cffbec5907e0b1ccf006f889e3a38c0b"}, "downloads": -1, "filename": "parse_type-0.5.2.tar.gz", "has_sig": false, "md5_digest": "b954062f14ab723a91fe1e2be15e859d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6, !=3.0.*, !=3.1.*", "size": 272082, "upload_time": "2019-07-14T08:36:58", "upload_time_iso_8601": "2019-07-14T08:36:58.183075Z", "url": "https://files.pythonhosted.org/packages/2e/79/81bebd1b0446d46733db99d74543b4bb80646ef4c988584bae0862e706bc/parse_type-0.5.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:17 2020"}