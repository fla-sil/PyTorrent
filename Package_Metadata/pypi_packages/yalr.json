{"info": {"author": "jan grant", "author_email": "jang@ioctl.org", "bugtrack_url": null, "classifiers": [], "description": "Yet Another LR Implementation\n=============================\n\nThis is another implementation of the classic LR(1) parsing\nalgorithm, along with Knuth's LR(1) table generation algorithm.\n\nRather than follow the model of tools like yacc and require\nexternal code generation, this library is driven dynamically\nfrom Python code.\n\nAn obvious question is, \"why?\"\n\nTwo reasons:\n\n- firstly, to experiment with surface syntax for expressing\n  grammars in Python code in as uninvasive a way as possible.\n\n  The package \"ptk\" takes a similar approach here.\n\n- secondly, to provide a playground to look at other\n  \"cutting-edge\" parsing algorithms, as a basis for improving\n  my own understanding of them.\n\nBy \"cutting-edge\" I'm largely referring to the late 1970s.\n\nThe current implementation is largely inspired by yacc,\nincluding yacc's various deficiencies:\n\n- there's a linearisation used for reduce/reduce conflict\n  resolution;\n\n- there's a linearisation used for token precedence.\n\nIn practice, it's easy to get bitten by both of these - as\nit is for the default shift/reduce resolution to mask\nerrors. A more flexible partial ordering is certainly feasible.\n\nCredits\n=======\n\nSome of the example grammars included in the tests are derived\nfrom the (Red) Dragon Book, which I've had since I was about 16;\nit's a book which definitely shaped my life.\n\nI've no idea how the reference numbers line up with later\nadditions.\n\n    Compilers: Principles, Techniques, and Tools (1986)\n    by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman\n\n", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jan-grant/python-yalr", "keywords": null, "license": "Copyright 2016 Jan Grant (jang@ioctl.org)", "maintainer": null, "maintainer_email": null, "name": "yalr", "package_url": "https://pypi.org/project/yalr/", "platform": null, "project_url": "https://pypi.org/project/yalr/", "project_urls": {"Homepage": "https://github.com/jan-grant/python-yalr"}, "release_url": "https://pypi.org/project/yalr/0.0.5/", "requires_dist": null, "requires_python": null, "summary": "Yet Another LR(1) implementation", "version": "0.0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"yet-another-lr-implementation\">\n<h2>Yet Another LR Implementation</h2>\n<p>This is another implementation of the classic LR(1) parsing\nalgorithm, along with Knuth\u2019s LR(1) table generation algorithm.</p>\n<p>Rather than follow the model of tools like yacc and require\nexternal code generation, this library is driven dynamically\nfrom Python code.</p>\n<p>An obvious question is, \u201cwhy?\u201d</p>\n<p>Two reasons:</p>\n<ul>\n<li><p>firstly, to experiment with surface syntax for expressing\ngrammars in Python code in as uninvasive a way as possible.</p>\n<p>The package \u201cptk\u201d takes a similar approach here.</p>\n</li>\n<li><p>secondly, to provide a playground to look at other\n\u201ccutting-edge\u201d parsing algorithms, as a basis for improving\nmy own understanding of them.</p>\n</li>\n</ul>\n<p>By \u201ccutting-edge\u201d I\u2019m largely referring to the late 1970s.</p>\n<p>The current implementation is largely inspired by yacc,\nincluding yacc\u2019s various deficiencies:</p>\n<ul>\n<li>there\u2019s a linearisation used for reduce/reduce conflict\nresolution;</li>\n<li>there\u2019s a linearisation used for token precedence.</li>\n</ul>\n<p>In practice, it\u2019s easy to get bitten by both of these - as\nit is for the default shift/reduce resolution to mask\nerrors. A more flexible partial ordering is certainly feasible.</p>\n</div>\n<div id=\"credits\">\n<h2>Credits</h2>\n<p>Some of the example grammars included in the tests are derived\nfrom the (Red) Dragon Book, which I\u2019ve had since I was about 16;\nit\u2019s a book which definitely shaped my life.</p>\n<p>I\u2019ve no idea how the reference numbers line up with later\nadditions.</p>\n<blockquote>\nCompilers: Principles, Techniques, and Tools (1986)\nby Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman</blockquote>\n</div>\n\n          </div>"}, "last_serial": 1927967, "releases": {"0.0.5": [{"comment_text": "", "digests": {"md5": "bf4061825dc24d8964620d1ba0611e9d", "sha256": "49d6b4f4f1f0da2e21b59955f9fa1e3968f8dee8a1f8c0d8a55df088cf90ccec"}, "downloads": -1, "filename": "yalr-0.0.5.tar.gz", "has_sig": false, "md5_digest": "bf4061825dc24d8964620d1ba0611e9d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9625, "upload_time": "2016-01-24T21:22:49", "upload_time_iso_8601": "2016-01-24T21:22:49.620979Z", "url": "https://files.pythonhosted.org/packages/1d/eb/365779a3e64904e15c3e3c088cd6198862d9430201fd884877b5455069dd/yalr-0.0.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bf4061825dc24d8964620d1ba0611e9d", "sha256": "49d6b4f4f1f0da2e21b59955f9fa1e3968f8dee8a1f8c0d8a55df088cf90ccec"}, "downloads": -1, "filename": "yalr-0.0.5.tar.gz", "has_sig": false, "md5_digest": "bf4061825dc24d8964620d1ba0611e9d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9625, "upload_time": "2016-01-24T21:22:49", "upload_time_iso_8601": "2016-01-24T21:22:49.620979Z", "url": "https://files.pythonhosted.org/packages/1d/eb/365779a3e64904e15c3e3c088cd6198862d9430201fd884877b5455069dd/yalr-0.0.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:23:29 2020"}