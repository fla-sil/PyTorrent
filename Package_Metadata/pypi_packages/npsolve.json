{"info": {"author": "Reuben Rusk", "author_email": "pythoro@mindquip.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# npsolve\n\nMany numerical solvers (like those in scipy) provide candidate solutions as a numpy array. They often also require a numpy array as a return value (e.g. an array of derivatives) during the solution. These requirements can make it difficult to use an object oriented approach to performing the calculations. \n\nThe *npsolve* package is a small, simple package built on *numpy* and *fastwire* to make it easy to use object-oriented code for the calculation step for numerical solvers.\n\n\n## Basic usage tutorial\n\nFirst, setup some classes that you want to do calculations with. We do this by using the *add_var* method to setup variables and their initial values.\n\n```python\n\nimport numpy as np\nimport npsolve\n\nclass Component1(npsolve.Partial):\n    def __init__(self):\n        super().__init__() # Don't forget to call this!\n        self.add_var('position', init=0.1)\n        self.add_var('velocity', init=0.3)\n    \nclass Component2(npsolve.Partial):\n    def __init__(self):\n        super().__init__() # Don't forget to call this!\n        self.add_var('force', init=-0.1)\n\n```\n\nNext override the *set_vectors* method to store views you might want. In this case, we'll just save the variables as attributes. Note that these are actually views, that are automatically updated by the solver. We'll do it differently with Component2.\n\n```python\n\n\nclass Component1(npsolve.Partial):\n    def __init__(self):\n        super().__init__() # Don't forget to call this!\n        self.add_var('position', init=0.1)\n        self.add_var('velocity', init=0.3)\n    \n    def set_vectors(self, state_dct, ret_dct):\n        ''' Set some state views for use during calculations '''\n        self.position = state_dct['position']\n        self.velocity = state_dct['velocity']\n        self.force = state_dct['force']\n    \n\nclass Component2(npsolve.Partial):\n    def __init__(self):\n        super().__init__() # Don't forget to call this!\n        self.add_var('force', init=-0.1)\n\n```\n\nNote that variables are made available to all Partial instances automatically.\n\nThen, we'll tell them how to do the calculations. The *step* method is called automatically and expects a dictionary of return values (e.g. derivatives). We'll use that one here. A dictionary of the current state values is provided (again), but we're going to use the views we set in the *set_vectors* method.\n\n```python\n\nclass Component1(npsolve.Partial):\n    def __init__(self):\n        super().__init__() # Don't forget to call this!\n        self.add_var('position', init=0.1)\n        self.add_var('velocity', init=0.3)\n    \n    def set_vectors(self, state_dct, ret_dct):\n        ''' Set some state views for use during calculations '''\n        self.position = state_dct['position']\n        self.velocity = state_dct['velocity']\n        self.force = state_dct['force']\n    \n    def step(self, state_dct, *args):\n        ''' Called by the solver at each time step \n        Calculate acceleration based on the \n        '''\n        acceleration = 1.0 * self.force\n        derivatives = {'position': self.velocity,\n                       'velocity': acceleration}\n        return derivatives\n\t\t\n\nclass Component2(npsolve.Partial):\n    def __init__(self):\n        super().__init__() # Don't forget to call this!\n        self.add_var('force', init=-0.1)\n\n    def calculate(self, state_dct, t):\n        ''' Some arbitrary calculations based on current time t\n        and the position at that time calculated in Component1.\n        This returns a derivative for variable 'c'\n        '''\n        dc = 1.0 * np.cos(2*t) * state_dct['position']\n        derivatives = {'force': dc}\n        return derivatives\n    \n    def step(self, state_dct, t, *args):\n        ''' Called by the solver at each time step '''\n        return self.calculate(state_dct, t)\n        \n\t\t\n```\n\n\nNow let's make a simple model that gathers together our Partials. \n\n```python\n\nclass Model():\n    def __init__(self):\n        self.elements = {}\n\t\t\n    def add_element(self, key, element):\n        self.elements[key] = element\n\n```\n\nNow, we'll set up the solver. For this example, we'll use the odeint solver from Scipy. Here's what it looks like:\n\n\n```python\n\nfrom scipy.integrate import odeint\n\nclass Solver(npsolve.Solver):\n    def solve(self):\n        self.t_vec = np.linspace(0, 10, 1001)\n        result = odeint(self.step, self.npsolve_initial_values, self.t_vec)\n        return result\n    \n    def set_model(self, model):\n        self.model = model\n        self.connect(model)\n\t\t\n    def connect(self, model):\n        self.remove_signals()\n        self.setup_signals()\n        for k, e in model.elements.items():\n            e.connect()\n        self.close_signals()\n\n```\n\nLet's look at what's going on, starting with the `solve` method. By default, Solvers have a *step* method that's ready to use. (They also have a *one_way_step* method that doesn't expect return values from the Partials, and a *tstep* method that has a time value as the first argument.) After initialisation, the initial values set by the Partial classes are captured in the *npsolve_initial_values* attribute. By default, the Solver's *step* method returns a vector of all the return values, the same size as the Solver's npsolve_initial_values array. So most of the work is done for us here already. Note here that we don't need to know anything about the model or the elements in the model.\n\n\nWe'll pass a model into our solver, and we need to connect the model elements to the solver. In the `connect` method above, we're using this typical sequence of calls:\n  * Solver.remove_signals: To clean up any signals from previous `connect` calls\n  * Solver.setup_signals: Create a new set of signals.\n  * Partial.connect: We call `connect` on each partial *after* calling `setup_signals` on the Solver.\n  * Solver.close_signals: Close the signals so they aren't accidentally used by anything else.\n\nThis allows us to decouple the model and Partials from the solver. We can pass in different models, or pass models to different solvers. We can make models with different components. It's flexible and easy to maintain!\n\nTo run, we just have to instantiate the Solver before the Partials that use it, then call the *npsolve_init* method. It doesn't matter where in the code we create the Solver and Partial instances - they'll link up automatically through *fastwire*.\n\n\n```python\n    \ndef make_model():\n    m = Model()\n    m.add_element('component 1', Component1())\n    m.add_element('component 2', Component2())\n    return m\n\t\n\ndef make_solver():\n    return Solver()\n\ndef run():\n    solver = make_solver()\n    model = make_model()\n    solver.set_model(model)\n\n    # Initialise the solver\n    solver.npsolve_init()\n\t\n    # Now we can run!\n    res = solver.solve()\n    return res, solver\n\n```\n\nLet's set up a plot to see the results. Use the *npsolve_slices* attribute of the Solver to get the right columns.\n\n```python\n\ndef plot(res, s):\n    slices = s.npsolve_slices\n    \n    plt.plot(s.t_vec, res[:,slices['position']], label='position')\n    plt.plot(s.t_vec, res[:,slices['velocity']], label='velocity')\n    plt.plot(s.t_vec, res[:,slices['force']], label='force')\n    plt.legend()\n\n```\n\nRun it and see what happens!\n\n```python\n\nres, s = run()\nplot(res, s)\n\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/pythoro/npsolve/archive/v0.0.7.zip", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pythoro/npsolve.git", "keywords": "NUMERICAL SOLVER,NUMPY,SCIPY,ODE,INTEGRATION", "license": "", "maintainer": "", "maintainer_email": "", "name": "npsolve", "package_url": "https://pypi.org/project/npsolve/", "platform": "", "project_url": "https://pypi.org/project/npsolve/", "project_urls": {"Download": "https://github.com/pythoro/npsolve/archive/v0.0.7.zip", "Homepage": "https://github.com/pythoro/npsolve.git"}, "release_url": "https://pypi.org/project/npsolve/0.0.7/", "requires_dist": null, "requires_python": "", "summary": "Easier object-oriented calculations for numerical solvers.", "version": "0.0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>npsolve</h1>\n<p>Many numerical solvers (like those in scipy) provide candidate solutions as a numpy array. They often also require a numpy array as a return value (e.g. an array of derivatives) during the solution. These requirements can make it difficult to use an object oriented approach to performing the calculations.</p>\n<p>The <em>npsolve</em> package is a small, simple package built on <em>numpy</em> and <em>fastwire</em> to make it easy to use object-oriented code for the calculation step for numerical solvers.</p>\n<h2>Basic usage tutorial</h2>\n<p>First, setup some classes that you want to do calculations with. We do this by using the <em>add_var</em> method to setup variables and their initial values.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">npsolve</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Component1</span><span class=\"p\">(</span><span class=\"n\">npsolve</span><span class=\"o\">.</span><span class=\"n\">Partial</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span> <span class=\"c1\"># Don't forget to call this!</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'position'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'velocity'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=</span><span class=\"mf\">0.3</span><span class=\"p\">)</span>\n    \n<span class=\"k\">class</span> <span class=\"nc\">Component2</span><span class=\"p\">(</span><span class=\"n\">npsolve</span><span class=\"o\">.</span><span class=\"n\">Partial</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span> <span class=\"c1\"># Don't forget to call this!</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'force'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=-</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p>Next override the <em>set_vectors</em> method to store views you might want. In this case, we'll just save the variables as attributes. Note that these are actually views, that are automatically updated by the solver. We'll do it differently with Component2.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Component1</span><span class=\"p\">(</span><span class=\"n\">npsolve</span><span class=\"o\">.</span><span class=\"n\">Partial</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span> <span class=\"c1\"># Don't forget to call this!</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'position'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'velocity'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=</span><span class=\"mf\">0.3</span><span class=\"p\">)</span>\n    \n    <span class=\"k\">def</span> <span class=\"nf\">set_vectors</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">state_dct</span><span class=\"p\">,</span> <span class=\"n\">ret_dct</span><span class=\"p\">):</span>\n        <span class=\"sd\">''' Set some state views for use during calculations '''</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">position</span> <span class=\"o\">=</span> <span class=\"n\">state_dct</span><span class=\"p\">[</span><span class=\"s1\">'position'</span><span class=\"p\">]</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">velocity</span> <span class=\"o\">=</span> <span class=\"n\">state_dct</span><span class=\"p\">[</span><span class=\"s1\">'velocity'</span><span class=\"p\">]</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">force</span> <span class=\"o\">=</span> <span class=\"n\">state_dct</span><span class=\"p\">[</span><span class=\"s1\">'force'</span><span class=\"p\">]</span>\n    \n\n<span class=\"k\">class</span> <span class=\"nc\">Component2</span><span class=\"p\">(</span><span class=\"n\">npsolve</span><span class=\"o\">.</span><span class=\"n\">Partial</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span> <span class=\"c1\"># Don't forget to call this!</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'force'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=-</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n</pre>\n<p>Note that variables are made available to all Partial instances automatically.</p>\n<p>Then, we'll tell them how to do the calculations. The <em>step</em> method is called automatically and expects a dictionary of return values (e.g. derivatives). We'll use that one here. A dictionary of the current state values is provided (again), but we're going to use the views we set in the <em>set_vectors</em> method.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Component1</span><span class=\"p\">(</span><span class=\"n\">npsolve</span><span class=\"o\">.</span><span class=\"n\">Partial</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span> <span class=\"c1\"># Don't forget to call this!</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'position'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'velocity'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=</span><span class=\"mf\">0.3</span><span class=\"p\">)</span>\n    \n    <span class=\"k\">def</span> <span class=\"nf\">set_vectors</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">state_dct</span><span class=\"p\">,</span> <span class=\"n\">ret_dct</span><span class=\"p\">):</span>\n        <span class=\"sd\">''' Set some state views for use during calculations '''</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">position</span> <span class=\"o\">=</span> <span class=\"n\">state_dct</span><span class=\"p\">[</span><span class=\"s1\">'position'</span><span class=\"p\">]</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">velocity</span> <span class=\"o\">=</span> <span class=\"n\">state_dct</span><span class=\"p\">[</span><span class=\"s1\">'velocity'</span><span class=\"p\">]</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">force</span> <span class=\"o\">=</span> <span class=\"n\">state_dct</span><span class=\"p\">[</span><span class=\"s1\">'force'</span><span class=\"p\">]</span>\n    \n    <span class=\"k\">def</span> <span class=\"nf\">step</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">state_dct</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">):</span>\n        <span class=\"sd\">''' Called by the solver at each time step </span>\n<span class=\"sd\">        Calculate acceleration based on the </span>\n<span class=\"sd\">        '''</span>\n        <span class=\"n\">acceleration</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">force</span>\n        <span class=\"n\">derivatives</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'position'</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">velocity</span><span class=\"p\">,</span>\n                       <span class=\"s1\">'velocity'</span><span class=\"p\">:</span> <span class=\"n\">acceleration</span><span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">derivatives</span>\n\t\t\n\n<span class=\"k\">class</span> <span class=\"nc\">Component2</span><span class=\"p\">(</span><span class=\"n\">npsolve</span><span class=\"o\">.</span><span class=\"n\">Partial</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span> <span class=\"c1\"># Don't forget to call this!</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">add_var</span><span class=\"p\">(</span><span class=\"s1\">'force'</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"o\">=-</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">calculate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">state_dct</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">):</span>\n        <span class=\"sd\">''' Some arbitrary calculations based on current time t</span>\n<span class=\"sd\">        and the position at that time calculated in Component1.</span>\n<span class=\"sd\">        This returns a derivative for variable 'c'</span>\n<span class=\"sd\">        '''</span>\n        <span class=\"n\">dc</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">state_dct</span><span class=\"p\">[</span><span class=\"s1\">'position'</span><span class=\"p\">]</span>\n        <span class=\"n\">derivatives</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'force'</span><span class=\"p\">:</span> <span class=\"n\">dc</span><span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">derivatives</span>\n    \n    <span class=\"k\">def</span> <span class=\"nf\">step</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">state_dct</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">):</span>\n        <span class=\"sd\">''' Called by the solver at each time step '''</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">calculate</span><span class=\"p\">(</span><span class=\"n\">state_dct</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n        \n\t\t\n</pre>\n<p>Now let's make a simple model that gathers together our Partials.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Model</span><span class=\"p\">():</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">elements</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n\t\t\n    <span class=\"k\">def</span> <span class=\"nf\">add_element</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">element</span>\n</pre>\n<p>Now, we'll set up the solver. For this example, we'll use the odeint solver from Scipy. Here's what it looks like:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scipy.integrate</span> <span class=\"kn\">import</span> <span class=\"n\">odeint</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Solver</span><span class=\"p\">(</span><span class=\"n\">npsolve</span><span class=\"o\">.</span><span class=\"n\">Solver</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">solve</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">t_vec</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">1001</span><span class=\"p\">)</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">odeint</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">npsolve_initial_values</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">t_vec</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span>\n    \n    <span class=\"k\">def</span> <span class=\"nf\">set_model</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">model</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span>\n\t\t\n    <span class=\"k\">def</span> <span class=\"nf\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">remove_signals</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">setup_signals</span><span class=\"p\">()</span>\n        <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">close_signals</span><span class=\"p\">()</span>\n</pre>\n<p>Let's look at what's going on, starting with the <code>solve</code> method. By default, Solvers have a <em>step</em> method that's ready to use. (They also have a <em>one_way_step</em> method that doesn't expect return values from the Partials, and a <em>tstep</em> method that has a time value as the first argument.) After initialisation, the initial values set by the Partial classes are captured in the <em>npsolve_initial_values</em> attribute. By default, the Solver's <em>step</em> method returns a vector of all the return values, the same size as the Solver's npsolve_initial_values array. So most of the work is done for us here already. Note here that we don't need to know anything about the model or the elements in the model.</p>\n<p>We'll pass a model into our solver, and we need to connect the model elements to the solver. In the <code>connect</code> method above, we're using this typical sequence of calls:</p>\n<ul>\n<li>Solver.remove_signals: To clean up any signals from previous <code>connect</code> calls</li>\n<li>Solver.setup_signals: Create a new set of signals.</li>\n<li>Partial.connect: We call <code>connect</code> on each partial <em>after</em> calling <code>setup_signals</code> on the Solver.</li>\n<li>Solver.close_signals: Close the signals so they aren't accidentally used by anything else.</li>\n</ul>\n<p>This allows us to decouple the model and Partials from the solver. We can pass in different models, or pass models to different solvers. We can make models with different components. It's flexible and easy to maintain!</p>\n<p>To run, we just have to instantiate the Solver before the Partials that use it, then call the <em>npsolve_init</em> method. It doesn't matter where in the code we create the Solver and Partial instances - they'll link up automatically through <em>fastwire</em>.</p>\n<pre>    \n<span class=\"k\">def</span> <span class=\"nf\">make_model</span><span class=\"p\">():</span>\n    <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">Model</span><span class=\"p\">()</span>\n    <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">add_element</span><span class=\"p\">(</span><span class=\"s1\">'component 1'</span><span class=\"p\">,</span> <span class=\"n\">Component1</span><span class=\"p\">())</span>\n    <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">add_element</span><span class=\"p\">(</span><span class=\"s1\">'component 2'</span><span class=\"p\">,</span> <span class=\"n\">Component2</span><span class=\"p\">())</span>\n    <span class=\"k\">return</span> <span class=\"n\">m</span>\n\t\n\n<span class=\"k\">def</span> <span class=\"nf\">make_solver</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"n\">Solver</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">run</span><span class=\"p\">():</span>\n    <span class=\"n\">solver</span> <span class=\"o\">=</span> <span class=\"n\">make_solver</span><span class=\"p\">()</span>\n    <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">make_model</span><span class=\"p\">()</span>\n    <span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">set_model</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Initialise the solver</span>\n    <span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">npsolve_init</span><span class=\"p\">()</span>\n\t\n    <span class=\"c1\"># Now we can run!</span>\n    <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">solver</span>\n</pre>\n<p>Let's set up a plot to see the results. Use the <em>npsolve_slices</em> attribute of the Solver to get the right columns.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">plot</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">):</span>\n    <span class=\"n\">slices</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">npsolve_slices</span>\n    \n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">t_vec</span><span class=\"p\">,</span> <span class=\"n\">res</span><span class=\"p\">[:,</span><span class=\"n\">slices</span><span class=\"p\">[</span><span class=\"s1\">'position'</span><span class=\"p\">]],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'position'</span><span class=\"p\">)</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">t_vec</span><span class=\"p\">,</span> <span class=\"n\">res</span><span class=\"p\">[:,</span><span class=\"n\">slices</span><span class=\"p\">[</span><span class=\"s1\">'velocity'</span><span class=\"p\">]],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'velocity'</span><span class=\"p\">)</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">t_vec</span><span class=\"p\">,</span> <span class=\"n\">res</span><span class=\"p\">[:,</span><span class=\"n\">slices</span><span class=\"p\">[</span><span class=\"s1\">'force'</span><span class=\"p\">]],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'force'</span><span class=\"p\">)</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">legend</span><span class=\"p\">()</span>\n</pre>\n<p>Run it and see what happens!</p>\n<pre><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">)</span>\n</pre>\n\n          </div>"}, "last_serial": 7124706, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "a14aee1f73819649c70b9263105e6251", "sha256": "7bfea301fb57f62a3f26764acfec5cee7429b0a6d754dfed7b2bc4704131a1e9"}, "downloads": -1, "filename": "npsolve-0.0.1.tar.gz", "has_sig": false, "md5_digest": "a14aee1f73819649c70b9263105e6251", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8118, "upload_time": "2019-09-02T06:43:43", "upload_time_iso_8601": "2019-09-02T06:43:43.032501Z", "url": "https://files.pythonhosted.org/packages/2e/30/0dc69d9c7b0cf1ead4e7aec7ef00c7e7d87f26a90e1765a157bc26ddf122/npsolve-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "ba07873f960ae091f405f0220abd0d07", "sha256": "1ff14a1b7a08fadbe27025db71ad5abaa783ccd023cd001828756383771840cc"}, "downloads": -1, "filename": "npsolve-0.0.2.tar.gz", "has_sig": false, "md5_digest": "ba07873f960ae091f405f0220abd0d07", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8326, "upload_time": "2019-09-02T07:14:29", "upload_time_iso_8601": "2019-09-02T07:14:29.971502Z", "url": "https://files.pythonhosted.org/packages/73/ec/37563fffe3530a83a84b9ed171e8ac4cd57c188db9f14ab1d60a7d792f71/npsolve-0.0.2.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "c78d0fb034dc1ad5dbd49d1206893d33", "sha256": "b9a41ad3bfdcbd88fb4f81a0db1fc793af5b7af87b189b7248446454930158cb"}, "downloads": -1, "filename": "npsolve-0.0.4.tar.gz", "has_sig": false, "md5_digest": "c78d0fb034dc1ad5dbd49d1206893d33", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14050, "upload_time": "2020-01-05T23:10:24", "upload_time_iso_8601": "2020-01-05T23:10:24.048698Z", "url": "https://files.pythonhosted.org/packages/23/29/82116d10708a9e69871cc5e7597d37b59fdc1653eaa79fe90df105f3f852/npsolve-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "62abe0bd92c8fa5be9ab2077fafc90a5", "sha256": "90ed987c2bd52be4c7ddfc9375f290c291c3fbb3b4dcdfbe4ea82ef4a1d957e6"}, "downloads": -1, "filename": "npsolve-0.0.5.tar.gz", "has_sig": false, "md5_digest": "62abe0bd92c8fa5be9ab2077fafc90a5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14029, "upload_time": "2020-01-05T23:15:46", "upload_time_iso_8601": "2020-01-05T23:15:46.934077Z", "url": "https://files.pythonhosted.org/packages/8f/62/7bbd840119a90299c36a7cff0eaac2b8a7165d54719c0926d4d44b137f0b/npsolve-0.0.5.tar.gz", "yanked": false}], "0.0.6": [{"comment_text": "", "digests": {"md5": "d777f1826df0c28f632689c8ec735a9a", "sha256": "a2cbcc8aad43416d98a4630118002b8e2c13c3ac7bf0b31e44d8f92addd2973f"}, "downloads": -1, "filename": "npsolve-0.0.6.tar.gz", "has_sig": false, "md5_digest": "d777f1826df0c28f632689c8ec735a9a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14056, "upload_time": "2020-03-30T01:03:15", "upload_time_iso_8601": "2020-03-30T01:03:15.933722Z", "url": "https://files.pythonhosted.org/packages/84/4f/1f27228e035eaaedd0bb3f61b73163c7353e59d48e11b8564aeac79fa3d9/npsolve-0.0.6.tar.gz", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "a83fdad7d5c9f486a86c5dba1a0bcb6c", "sha256": "f16ffee6f100fcbdd6b838ee007ce3b7bc7b4e96fcc5f72a935c94e433773bfc"}, "downloads": -1, "filename": "npsolve-0.0.7.tar.gz", "has_sig": false, "md5_digest": "a83fdad7d5c9f486a86c5dba1a0bcb6c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14141, "upload_time": "2020-04-29T01:01:24", "upload_time_iso_8601": "2020-04-29T01:01:24.547149Z", "url": "https://files.pythonhosted.org/packages/1e/7a/fd3d043b3a7921cf39ce2ed0f86c8ea8ae1d2efdb3dddbc81483d4af38d7/npsolve-0.0.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a83fdad7d5c9f486a86c5dba1a0bcb6c", "sha256": "f16ffee6f100fcbdd6b838ee007ce3b7bc7b4e96fcc5f72a935c94e433773bfc"}, "downloads": -1, "filename": "npsolve-0.0.7.tar.gz", "has_sig": false, "md5_digest": "a83fdad7d5c9f486a86c5dba1a0bcb6c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14141, "upload_time": "2020-04-29T01:01:24", "upload_time_iso_8601": "2020-04-29T01:01:24.547149Z", "url": "https://files.pythonhosted.org/packages/1e/7a/fd3d043b3a7921cf39ce2ed0f86c8ea8ae1d2efdb3dddbc81483d4af38d7/npsolve-0.0.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:31 2020"}