{"info": {"author": "operatorjen", "author_email": "python@0112358.io", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP", "Topic :: Software Development :: Libraries"], "description": "Auto Tagify2 is a simple auto tagging module that uses NLTK to generate tags out of a selection of text. Any\ntext that is less than 3 characters long or matches a particular POS (part-of-speech) will be ignored.\n\nThere are two operations Auto Tagify performs - one returns the selection of text with links embedded in the\nstring and the other returns a list of all the taggable words as the stem word (using lemmatization).\n\nFor the first operation, everything is optional, but it is most effective to enter some text. Optional\nparameters you can set are the paths for tag links and the css classes for link. For instance, if you set\nyour tag routing to a relative path such as /tags/<tagged_word> and want to use the css class named \"tagged\":\n\nfrom auto_tagify2 import AutoTagify\n\nt = AutoTagify()\n\nt.text = \"This is the text to display!\"\n\nt.link = \"/tags\"\n\nt.css = \"tagged\"\n\nt.generate()\n\nThe result will be: This is the <a href=\"/tags/text\" class=\"tagged\">text</a> to <a href=\"/tags/display\" class=\"tagged\">display!</a>\n\nIf no link is set, the default path is \"/<tagged word>\", such as \"/text\".\n\nFor the second operation, you will only receive a list of all your taggable words from the text. You can call it like so:\n\nt.text = \"This text is tagged kittens\"\n\nt.tag_list()\n\nThe result will be a list: ['text', 'tag', 'kitten']\n\nBy default, generate() and tag_list() will be in strict mode, which means all special characters will be stripped and\nlemmatization will be enforced. If generate(strict=False) or tag_list(strict=False) is set, then special characters will be url encoded\nand lemmatization will be ignored.\n\nThese two operations are sufficient for you to maintain tag counts and tag references to text in your application.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/operatorjen/auto-tagify", "keywords": "tagging tags html nltk english", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "auto-tagify2", "package_url": "https://pypi.org/project/auto-tagify2/", "platform": "", "project_url": "https://pypi.org/project/auto-tagify2/", "project_urls": {"Homepage": "https://github.com/operatorjen/auto-tagify"}, "release_url": "https://pypi.org/project/auto-tagify2/1.4.3/", "requires_dist": null, "requires_python": "", "summary": "Auto-tags a selection of text and generates links to the tagified versions of the words", "version": "1.4.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Auto Tagify2 is a simple auto tagging module that uses NLTK to generate tags out of a selection of text. Any\ntext that is less than 3 characters long or matches a particular POS (part-of-speech) will be ignored.</p>\n<p>There are two operations Auto Tagify performs - one returns the selection of text with links embedded in the\nstring and the other returns a list of all the taggable words as the stem word (using lemmatization).</p>\n<p>For the first operation, everything is optional, but it is most effective to enter some text. Optional\nparameters you can set are the paths for tag links and the css classes for link. For instance, if you set\nyour tag routing to a relative path such as /tags/&lt;tagged_word&gt; and want to use the css class named \u201ctagged\u201d:</p>\n<p>from auto_tagify2 import AutoTagify</p>\n<p>t = AutoTagify()</p>\n<p>t.text = \u201cThis is the text to display!\u201d</p>\n<p>t.link = \u201c/tags\u201d</p>\n<p>t.css = \u201ctagged\u201d</p>\n<p>t.generate()</p>\n<p>The result will be: This is the &lt;a href=\u201d/tags/text\u201d class=\u201dtagged\u201d&gt;text&lt;/a&gt; to &lt;a href=\u201d/tags/display\u201d class=\u201dtagged\u201d&gt;display!&lt;/a&gt;</p>\n<p>If no link is set, the default path is \u201c/&lt;tagged word&gt;\u201d, such as \u201c/text\u201d.</p>\n<p>For the second operation, you will only receive a list of all your taggable words from the text. You can call it like so:</p>\n<p>t.text = \u201cThis text is tagged kittens\u201d</p>\n<p>t.tag_list()</p>\n<p>The result will be a list: [\u2018text\u2019, \u2018tag\u2019, \u2018kitten\u2019]</p>\n<p>By default, generate() and tag_list() will be in strict mode, which means all special characters will be stripped and\nlemmatization will be enforced. If generate(strict=False) or tag_list(strict=False) is set, then special characters will be url encoded\nand lemmatization will be ignored.</p>\n<p>These two operations are sufficient for you to maintain tag counts and tag references to text in your application.</p>\n\n          </div>"}, "last_serial": 6583736, "releases": {"1.4.2": [{"comment_text": "", "digests": {"md5": "98efacb25a737baf8291e11abd7815e9", "sha256": "cc5ae0d57639db3f0d78fe0ecae5f67cdd5049a618ba9ba17a13716faecfc04f"}, "downloads": -1, "filename": "auto_tagify2-1.4.2.tar.gz", "has_sig": false, "md5_digest": "98efacb25a737baf8291e11abd7815e9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3110, "upload_time": "2020-02-04T14:40:27", "upload_time_iso_8601": "2020-02-04T14:40:27.210651Z", "url": "https://files.pythonhosted.org/packages/53/ad/79bc00ee384150d7d7b761c7b4dafa0433b80a740fd17a0e6b041c896ab3/auto_tagify2-1.4.2.tar.gz", "yanked": false}], "1.4.3": [{"comment_text": "", "digests": {"md5": "c1635c2643ed173b90809afd6a68eb08", "sha256": "511d999948231c22429dd0767450a08e6deccdd9e514967a417e568722e20701"}, "downloads": -1, "filename": "auto_tagify2-1.4.3.tar.gz", "has_sig": false, "md5_digest": "c1635c2643ed173b90809afd6a68eb08", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3108, "upload_time": "2020-02-06T18:35:36", "upload_time_iso_8601": "2020-02-06T18:35:36.091519Z", "url": "https://files.pythonhosted.org/packages/de/85/bdc15a586aef64935d4950d71cb53638d3b589b5b5f003074c91d445cf78/auto_tagify2-1.4.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c1635c2643ed173b90809afd6a68eb08", "sha256": "511d999948231c22429dd0767450a08e6deccdd9e514967a417e568722e20701"}, "downloads": -1, "filename": "auto_tagify2-1.4.3.tar.gz", "has_sig": false, "md5_digest": "c1635c2643ed173b90809afd6a68eb08", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3108, "upload_time": "2020-02-06T18:35:36", "upload_time_iso_8601": "2020-02-06T18:35:36.091519Z", "url": "https://files.pythonhosted.org/packages/de/85/bdc15a586aef64935d4950d71cb53638d3b589b5b5f003074c91d445cf78/auto_tagify2-1.4.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:08 2020"}