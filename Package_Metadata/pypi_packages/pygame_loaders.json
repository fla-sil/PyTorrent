{"info": {"author": "tshirtman", "author_email": "gabriel.pettier@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Other Environment", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License (GPL)", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Multimedia :: Graphics", "Topic :: Software Development :: Libraries :: pygame"], "description": "This module was originaly a simple syntaxic sugar for a pygame project,\n        for performances sake it quickly gained memoization, allowing you to\n        call for images, not carring if you already loaded them or not. As you\n        may need to do that for result of process on those images, the image\n        loader gained a lot of keywords, that allow to call images with a\n        zooms, blending, reversing, scaling, rotating, and all sort of\n        combinations, everytime doing only the required parts of those\n        processings, and using previous results of processings. Okay, it can\n        takes up big memory amounts, but well, i found it's most of the time\n        less of the problem than CPU, so if you agree, you will probably agree\n        that for games, it's an acceptable tradeoff.\n\n        Oh, for convenience sakes, it can load bunch of text and musics, too,\n        the processing part is less developped on these ones, but contributions\n        are welcomed, and memoization is done for them too.\n\n        Anyway, using it is quite simple, simply import the needed loaders from\n        loaders.py, and for an image filepath, image() will return a tupple\n        containing the image and it's size, no need to store it away, calling\n        the loader a second time or more is basically free, thanks to\n        memoization.\n\n       pygame must be loaded and display_mode set to perform most\n       image operations.\n\n        >>> from pygame_loaders import image\n        >>> image('myimage.png') # actual loading\n        (<Surface(491x546x32 SW)>, <rect(0, 0, 491, 546)>)\n\n        >>> image('myimage.png') # returning same result, without any loading\n        >>> image(\"myimage.png\", zoom=1.5) # only performing zoom\n        (<Surface(736x819x32 SW)>, <rect(0, 0, 736, 819)>)\n\n        >>> image(\"myimage.png\", zoom=1.5, alpha=0.4) # only changing alpha\n        (<Surface(736x819x32 SW)>, <rect(0, 0, 736, 819)>)", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/tshirtman/loaders.py", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "pygame_loaders", "package_url": "https://pypi.org/project/pygame_loaders/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pygame_loaders/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/tshirtman/loaders.py"}, "release_url": "https://pypi.org/project/pygame_loaders/1.0/", "requires_dist": null, "requires_python": null, "summary": "A set of class/functions to use to load data in pygame\n        applications, do memoization by default on data and on result of\n        processings it allows on those datas", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <dl>\n<dt>This module was originaly a simple syntaxic sugar for a pygame project,</dt>\n<dd><blockquote>\n<p>for performances sake it quickly gained memoization, allowing you to\ncall for images, not carring if you already loaded them or not. As you\nmay need to do that for result of process on those images, the image\nloader gained a lot of keywords, that allow to call images with a\nzooms, blending, reversing, scaling, rotating, and all sort of\ncombinations, everytime doing only the required parts of those\nprocessings, and using previous results of processings. Okay, it can\ntakes up big memory amounts, but well, i found it\u2019s most of the time\nless of the problem than CPU, so if you agree, you will probably agree\nthat for games, it\u2019s an acceptable tradeoff.</p>\n<p>Oh, for convenience sakes, it can load bunch of text and musics, too,\nthe processing part is less developped on these ones, but contributions\nare welcomed, and memoization is done for them too.</p>\n<p>Anyway, using it is quite simple, simply import the needed loaders from\nloaders.py, and for an image filepath, image() will return a tupple\ncontaining the image and it\u2019s size, no need to store it away, calling\nthe loader a second time or more is basically free, thanks to\nmemoization.</p>\n</blockquote>\n<p>pygame must be loaded and display_mode set to perform most\nimage operations.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from pygame_loaders import image\n&gt;&gt;&gt; image('myimage.png') # actual loading\n(&lt;Surface(491x546x32 SW)&gt;, &lt;rect(0, 0, 491, 546)&gt;)\n</pre>\n<pre>&gt;&gt;&gt; image('myimage.png') # returning same result, without any loading\n&gt;&gt;&gt; image(\"myimage.png\", zoom=1.5) # only performing zoom\n(&lt;Surface(736x819x32 SW)&gt;, &lt;rect(0, 0, 736, 819)&gt;)\n</pre>\n<pre>&gt;&gt;&gt; image(\"myimage.png\", zoom=1.5, alpha=0.4) # only changing alpha\n(&lt;Surface(736x819x32 SW)&gt;, &lt;rect(0, 0, 736, 819)&gt;)\n</pre>\n</blockquote>\n</dd>\n</dl>\n\n          </div>"}, "last_serial": 249302, "releases": {"1.0": []}, "urls": [], "timestamp": "Fri May  8 03:05:20 2020"}