{"info": {"author": "jaddison", "author_email": "addi00+github.com@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "Intended Audience :: Developers", "Intended Audience :: Information Technology", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Internet :: WWW/HTTP", "Topic :: Security"], "description": "certbot\\_py Documentation\n-------------------------\n\nCurrent Status: Very Alpha, Proof of Concept\n''''''''''''''''''''''''''''''''''''''''''''\n\nUse at your own peril, until there's some shakedown.\n\nOverview\n^^^^^^^^\n\nThis library is a wrapper around the ``certbot``/``certbot-auto``\ncommand line tool operating ``certonly`` in manual, non-interactive\nmode. It does this via Python's ``subprocess.Popen()``.\n\nThis allows Python developers to automate the creation of certificates\nin a web app (ie. Flask or Django). Let's Encrypt's certificate\ngeneration process, simplified:\n\n1. ``certbot`` sends a certificate request for a domain (or multiple\n   domains in the case of SAN/UCC)\n2. Let's Encrypt responds with validation instructions for each\n   requested domain\n3. For each set of validation instructions, << developer/operations team\n   member needs to manually perform some action - DNS record addition or\n   web server file creation >>\n4. Let's Encrypt attempts to validate each domain\n5. Upon successful validation, a certificate is provided (either single\n   domain or SAN/UCC)\n\nStep 3 is where this library allows the developer to customize and\n**automate** their process of setting up validation (see ``auth_script``\nbelow). This library currently only supports web server validation (ie\nhttp-01).\n\nAn example scenario where this library becomes useful: > You have a\nblogging platform (ie. blog-platform.io) where your customers can sign\nup and create their own blog (ie. customer1.blog-platform.io). > >The\nCustomer would like to host their new blog on their own sub-domain (ie.\nblog.customer-site.com) for SEO purposes - obviously they want to make\nsure it's HTTPS enabled. They can easily do this by adding a CNAME from\nblog.customer-site.com to customer1.blog-platform.io. > > So your\nblogging platform needs to automatically provision HTTPS certificates as\nyour customers create new blogs and set up CNAMEs for them.\n``certbot_py`` to the rescue.\n\nPlease note that there is **NO** mechanism for renewal included; `using\n``certbot renew`` via a cron job is the recommended\nway <https://certbot.eff.org/docs/using.html#renewing-certificates>`__.\n\nInstallation\n^^^^^^^^^^^^\n\n1. You must install ``certbot`` or ``certbot-auto`` as you will need to\n   specify the full path to it. It does all the heavy lifting.\n2. The user running your Python project code must have access to run\n   ``sudo certbot`` or ``sudo certbot-auto`` without a password, which\n   is largely dependent on how you configure your ``gunicorn``,\n   ``uwsgi``, etc to run (if in a web environment).\n\n   -  This likely means running ``sudo visudo`` or adding an entry to\n      ``/etc/sudoers.d/``.\n   -  **For security, it is highly recommended to only allow ``sudo``\n      access to just the one command (``certbot`` or\n      ``certbot-auto``).**\n\n3. Register an account with Let's Encrypt's servers (if you haven't\n   already). Note that ``certbot_py`` (this library) defaults to using\n   Let's Encrypt staging servers, while ``certbot`` and ``certbot-auto``\n   default to production servers. An example of registration for staging\n   servers:\n   ``certbot register --staging # OR    certbot-auto register --staging``\n4. In your Python project's virtual environment, install ``certbot_py``:\n   ``pip install certbot_py``\n\nUsage\n^^^^^\n\nEnsure you register an account with Let's Encrypt, as mentioned above.\n\nThere is a single ``generate_certificate`` method which requires 3\nparameters: ``domains``, ``certbot_command``, and ``auth_script``. There\nare many other optional parameters which mostly map to corresponding\n``certbot`` arguments.\n\n::\n\n    from certbot_py import client\n\n    command = '/my/path/to/certbot'\n    script = '/my/other/path/to/auth-hook-script.sh'\n    my_domains = ['example1.com', 'example2.com', 'example3.com']\n    results = client.generate_certificate(\n        domains=my_domains,\n        certbot_command=command,\n        auth_script=script\n    )\n\nIf you wanted to generate a SAN (ie. UCC) certificate instead, use\n``san_ucc=True``. As with ``certbot``, the first domain in ``domains``\nwill be the common name listed on the resulting cert.\n\n::\n\n    results = client.generate_certificate(\n        domains=my_domains,\n        certbot_command=command,\n        auth_script=script,\n        san_ucc=True\n    )\n\nThere are many more options, most of the pertinent ones are listed\nbelow. Skip further down for more information on ``auth_script``.\n\nOption List\n'''''''''''\n\nFull list of ``generate_certificate`` parameters (order is unimportant\nas they must be passed as keyword arguments):\n\n::\n\n    account = None\n    allow_domain_subset = False\n    allow_self_upgrade = False\n    auth_script = None\n    certbot_command = None\n    domains = None\n    hsts = False\n    must_staple = False\n    production = False\n    redirect = False\n    rsa_key_size = None\n    san_ucc = False\n    staple_ocsp = False\n    uir = False\n\nThese mostly map to `corresponding ``certbot``\narguments <https://certbot.eff.org/docs/using.html#certbot-command-line-options>`__,\nwith a few exceptions:\n\n-  ``production`` will enable the live generation of certificates from\n   Let's Encrypt's production servers. By default (and safely),\n   ``certbot_py`` uses staging servers.\n-  ``san_ucc`` indicates that a SAN/UCC certificate is wanted, otherwise\n   an individual cert will be requested for each domain passed in.\n-  ``certbot_command`` is the full path the the installed ``certbot`` or\n   ``certbot-auto`` command line executable.\n-  ``auth_script`` is the full path to a script which will use the\n   ``certbot``-provided ``$CERTBOT_DOMAIN``, ``$CERTBOT_VALIDATION``,\n   and ``$CERTBOT_TOKEN`` environment variables to perform some\n   developer-specific action (ie. add ``$CERTBOT_VALIDATION`` and\n   ``$CERTBOT_TOKEN`` to a database) so that the subsequent validation\n   request from Let's Encrypt's servers can succeed.\n-  ``allow_self_upgrade`` would allow auto-upgrading (``certbot-auto``\n   only), which has been disabled by default to prevent breakage due to\n   tool upgrades\n\nExample ``auth_script`` (Django example), just a single bash script:\n\n::\n\n    #~/bin/bash\n    /home/webuser/.virtualenvs/bin/python /home/webuser/my_project/manage.py set_domain_validation \"$CERTBOT_DOMAIN\" \"$CERTBOT_VALIDATION\" \"$CERTBOT_TOKEN\"\n\nCommand Line\n''''''''''''\n\nThere is a command line alias configured upon ``pip install`` that you\ncan use to test with. Simply use ``certbot_py`` on the command line,\nfull help is available.\n\nNotes\n^^^^^\n\n1. ``certbot`` version 0.10.0 is the first version to expose the\n   necessary command line arguments - prior versions will fail.\n2. This library should be updated for security and bug fixes (obviously)\n   but also may require updating if the underlying arguments to\n   ``certbot`` change or features are added.\n\nFuture\n^^^^^^\n\nGee, I should mock in some tests...\n\nLonger term, I look forward to having this library change (and improve!)\nso that it no longer needs Python's ``subprocess.Popen()`` or a\n``certbot`` installation. This is technically possible using Let's\nEncrypt's ```acme``\nlibrary <https://github.com/certbot/certbot/tree/master/acme>`__;\nhowever creating a client around ``acme`` involves much more than\nsomething simple like ``acme.generate_certificate(...)``. Much in this\nACME/Let's Encrypt world seems in flux at the moment, so implementing\nthis wrapper felt like the easiest path forward for the time being - and\nretains full compatibility with the standard Let's Encrypt command line\ntools.\n\nFeedback is encouraged and appreciated. `File issues on\nGithub <https://github.com/jaddison/certbot_py/issues>`__. Feel free to\nfork and suggest improvements.\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jaddison/certbot_py", "keywords": "certbot letsencrypt ssl certificate https secure encrypt encryption", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "certbot-py", "package_url": "https://pypi.org/project/certbot-py/", "platform": "", "project_url": "https://pypi.org/project/certbot-py/", "project_urls": {"Homepage": "https://github.com/jaddison/certbot_py"}, "release_url": "https://pypi.org/project/certbot-py/0.10.1/", "requires_dist": ["six"], "requires_python": "", "summary": "Python module to integrate automated Let's Encrypt `certbot certonly` certificate creation into Python projects.", "version": "0.10.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"current-status-very-alpha-proof-of-concept\">\n<h2>Current Status: Very Alpha, Proof of Concept</h2>\n<p>Use at your own peril, until there\u2019s some shakedown.</p>\n<div id=\"overview\">\n<h3>Overview</h3>\n<p>This library is a wrapper around the <tt>certbot</tt>/<tt><span class=\"pre\">certbot-auto</span></tt>\ncommand line tool operating <tt>certonly</tt> in manual, non-interactive\nmode. It does this via Python\u2019s <tt>subprocess.Popen()</tt>.</p>\n<p>This allows Python developers to automate the creation of certificates\nin a web app (ie. Flask or Django). Let\u2019s Encrypt\u2019s certificate\ngeneration process, simplified:</p>\n<ol>\n<li><tt>certbot</tt> sends a certificate request for a domain (or multiple\ndomains in the case of SAN/UCC)</li>\n<li>Let\u2019s Encrypt responds with validation instructions for each\nrequested domain</li>\n<li>For each set of validation instructions, &lt;&lt; developer/operations team\nmember needs to manually perform some action - DNS record addition or\nweb server file creation &gt;&gt;</li>\n<li>Let\u2019s Encrypt attempts to validate each domain</li>\n<li>Upon successful validation, a certificate is provided (either single\ndomain or SAN/UCC)</li>\n</ol>\n<p>Step 3 is where this library allows the developer to customize and\n<strong>automate</strong> their process of setting up validation (see <tt>auth_script</tt>\nbelow). This library currently only supports web server validation (ie\nhttp-01).</p>\n<p>An example scenario where this library becomes useful: &gt; You have a\nblogging platform (ie. blog-platform.io) where your customers can sign\nup and create their own blog (ie. customer1.blog-platform.io). &gt; &gt;The\nCustomer would like to host their new blog on their own sub-domain (ie.\nblog.customer-site.com) for SEO purposes - obviously they want to make\nsure it\u2019s HTTPS enabled. They can easily do this by adding a CNAME from\nblog.customer-site.com to customer1.blog-platform.io. &gt; &gt; So your\nblogging platform needs to automatically provision HTTPS certificates as\nyour customers create new blogs and set up CNAMEs for them.\n<tt>certbot_py</tt> to the rescue.</p>\n<p>Please note that there is <strong>NO</strong> mechanism for renewal included; <cite>using\n``certbot renew`</cite> via a cron job is the recommended\nway &lt;<a href=\"https://certbot.eff.org/docs/using.html#renewing-certificates\" rel=\"nofollow\">https://certbot.eff.org/docs/using.html#renewing-certificates</a>&gt;`__.</p>\n</div>\n<div id=\"installation\">\n<h3>Installation</h3>\n<ol>\n<li>You must install <tt>certbot</tt> or <tt><span class=\"pre\">certbot-auto</span></tt> as you will need to\nspecify the full path to it. It does all the heavy lifting.</li>\n<li>The user running your Python project code must have access to run\n<tt>sudo certbot</tt> or <tt>sudo <span class=\"pre\">certbot-auto</span></tt> without a password, which\nis largely dependent on how you configure your <tt>gunicorn</tt>,\n<tt>uwsgi</tt>, etc to run (if in a web environment).<ul>\n<li>This likely means running <tt>sudo visudo</tt> or adding an entry to\n<tt>/etc/sudoers.d/</tt>.</li>\n<li><strong>For security, it is highly recommended to only allow ``sudo``\naccess to just the one command (``certbot`` or\n``certbot-auto``).</strong></li>\n</ul>\n</li>\n<li>Register an account with Let\u2019s Encrypt\u2019s servers (if you haven\u2019t\nalready). Note that <tt>certbot_py</tt> (this library) defaults to using\nLet\u2019s Encrypt staging servers, while <tt>certbot</tt> and <tt><span class=\"pre\">certbot-auto</span></tt>\ndefault to production servers. An example of registration for staging\nservers:\n<tt>certbot register <span class=\"pre\">--staging</span> # OR\u00a0\u00a0\u00a0 <span class=\"pre\">certbot-auto</span> register <span class=\"pre\">--staging</span></tt></li>\n<li>In your Python project\u2019s virtual environment, install <tt>certbot_py</tt>:\n<tt>pip install certbot_py</tt></li>\n</ol>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<p>Ensure you register an account with Let\u2019s Encrypt, as mentioned above.</p>\n<p>There is a single <tt>generate_certificate</tt> method which requires 3\nparameters: <tt>domains</tt>, <tt>certbot_command</tt>, and <tt>auth_script</tt>. There\nare many other optional parameters which mostly map to corresponding\n<tt>certbot</tt> arguments.</p>\n<pre>from certbot_py import client\n\ncommand = '/my/path/to/certbot'\nscript = '/my/other/path/to/auth-hook-script.sh'\nmy_domains = ['example1.com', 'example2.com', 'example3.com']\nresults = client.generate_certificate(\n    domains=my_domains,\n    certbot_command=command,\n    auth_script=script\n)\n</pre>\n<p>If you wanted to generate a SAN (ie. UCC) certificate instead, use\n<tt>san_ucc=True</tt>. As with <tt>certbot</tt>, the first domain in <tt>domains</tt>\nwill be the common name listed on the resulting cert.</p>\n<pre>results = client.generate_certificate(\n    domains=my_domains,\n    certbot_command=command,\n    auth_script=script,\n    san_ucc=True\n)\n</pre>\n<p>There are many more options, most of the pertinent ones are listed\nbelow. Skip further down for more information on <tt>auth_script</tt>.</p>\n</div>\n</div>\n<div id=\"option-list\">\n<h2>Option List</h2>\n<p>Full list of <tt>generate_certificate</tt> parameters (order is unimportant\nas they must be passed as keyword arguments):</p>\n<pre>account = None\nallow_domain_subset = False\nallow_self_upgrade = False\nauth_script = None\ncertbot_command = None\ndomains = None\nhsts = False\nmust_staple = False\nproduction = False\nredirect = False\nrsa_key_size = None\nsan_ucc = False\nstaple_ocsp = False\nuir = False\n</pre>\n<p>These mostly map to <cite>corresponding ``certbot`</cite>\narguments &lt;<a href=\"https://certbot.eff.org/docs/using.html#certbot-command-line-options\" rel=\"nofollow\">https://certbot.eff.org/docs/using.html#certbot-command-line-options</a>&gt;`__,\nwith a few exceptions:</p>\n<ul>\n<li><tt>production</tt> will enable the live generation of certificates from\nLet\u2019s Encrypt\u2019s production servers. By default (and safely),\n<tt>certbot_py</tt> uses staging servers.</li>\n<li><tt>san_ucc</tt> indicates that a SAN/UCC certificate is wanted, otherwise\nan individual cert will be requested for each domain passed in.</li>\n<li><tt>certbot_command</tt> is the full path the the installed <tt>certbot</tt> or\n<tt><span class=\"pre\">certbot-auto</span></tt> command line executable.</li>\n<li><tt>auth_script</tt> is the full path to a script which will use the\n<tt>certbot</tt>-provided <tt>$CERTBOT_DOMAIN</tt>, <tt>$CERTBOT_VALIDATION</tt>,\nand <tt>$CERTBOT_TOKEN</tt> environment variables to perform some\ndeveloper-specific action (ie. add <tt>$CERTBOT_VALIDATION</tt> and\n<tt>$CERTBOT_TOKEN</tt> to a database) so that the subsequent validation\nrequest from Let\u2019s Encrypt\u2019s servers can succeed.</li>\n<li><tt>allow_self_upgrade</tt> would allow auto-upgrading (<tt><span class=\"pre\">certbot-auto</span></tt>\nonly), which has been disabled by default to prevent breakage due to\ntool upgrades</li>\n</ul>\n<p>Example <tt>auth_script</tt> (Django example), just a single bash script:</p>\n<pre>#~/bin/bash\n/home/webuser/.virtualenvs/bin/python /home/webuser/my_project/manage.py set_domain_validation \"$CERTBOT_DOMAIN\" \"$CERTBOT_VALIDATION\" \"$CERTBOT_TOKEN\"\n</pre>\n</div>\n<div id=\"command-line\">\n<h2>Command Line</h2>\n<p>There is a command line alias configured upon <tt>pip install</tt> that you\ncan use to test with. Simply use <tt>certbot_py</tt> on the command line,\nfull help is available.</p>\n<div id=\"notes\">\n<h3>Notes</h3>\n<ol>\n<li><tt>certbot</tt> version 0.10.0 is the first version to expose the\nnecessary command line arguments - prior versions will fail.</li>\n<li>This library should be updated for security and bug fixes (obviously)\nbut also may require updating if the underlying arguments to\n<tt>certbot</tt> change or features are added.</li>\n</ol>\n</div>\n<div id=\"future\">\n<h3>Future</h3>\n<p>Gee, I should mock in some tests\u2026</p>\n<p>Longer term, I look forward to having this library change (and improve!)\nso that it no longer needs Python\u2019s <tt>subprocess.Popen()</tt> or a\n<tt>certbot</tt> installation. This is technically possible using Let\u2019s\nEncrypt\u2019s <tt>`acme</tt>\nlibrary &lt;<a href=\"https://github.com/certbot/certbot/tree/master/acme\" rel=\"nofollow\">https://github.com/certbot/certbot/tree/master/acme</a>&gt;`__;\nhowever creating a client around <tt>acme</tt> involves much more than\nsomething simple like <tt><span class=\"pre\">acme.generate_certificate(...)</span></tt>. Much in this\nACME/Let\u2019s Encrypt world seems in flux at the moment, so implementing\nthis wrapper felt like the easiest path forward for the time being - and\nretains full compatibility with the standard Let\u2019s Encrypt command line\ntools.</p>\n<p>Feedback is encouraged and appreciated. <a href=\"https://github.com/jaddison/certbot_py/issues\" rel=\"nofollow\">File issues on\nGithub</a>. Feel free to\nfork and suggest improvements.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 2689337, "releases": {"0.10.0": [{"comment_text": "", "digests": {"md5": "4402c1f1d7c7ed4846fd09dbd5520916", "sha256": "19c209467b40de22a8bf095cd8e312db58a9bb23a636a4e89a6b9ee725847138"}, "downloads": -1, "filename": "certbot_py-0.10.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4402c1f1d7c7ed4846fd09dbd5520916", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12030, "upload_time": "2017-01-12T18:22:40", "upload_time_iso_8601": "2017-01-12T18:22:40.874834Z", "url": "https://files.pythonhosted.org/packages/ec/09/c5ef51e907640b5126c6a130a3b00ae9bb948f0c21196842bc37ba78bc0c/certbot_py-0.10.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fda9098853baef4ac96b481f0a521b16", "sha256": "cd4c88811b03e718474656ca1b24dc9b9116b1c90dadac41924b5dd57040245e"}, "downloads": -1, "filename": "certbot_py-0.10.0.tar.gz", "has_sig": false, "md5_digest": "fda9098853baef4ac96b481f0a521b16", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8449, "upload_time": "2017-01-12T18:22:42", "upload_time_iso_8601": "2017-01-12T18:22:42.505723Z", "url": "https://files.pythonhosted.org/packages/cc/83/20e013b9291e3dda3342b929cbbe75a91579a760588a19f30e69ceba3e01/certbot_py-0.10.0.tar.gz", "yanked": false}], "0.10.1": [{"comment_text": "", "digests": {"md5": "02ac8e14bca627cca630b56641090d84", "sha256": "e72e59da88e394098777b9767527217ace5e9fcc11af8926f6187eff7719870f"}, "downloads": -1, "filename": "certbot_py-0.10.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "02ac8e14bca627cca630b56641090d84", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12033, "upload_time": "2017-03-07T17:07:39", "upload_time_iso_8601": "2017-03-07T17:07:39.581726Z", "url": "https://files.pythonhosted.org/packages/59/9e/868bb97f0e9ed12bfb2cd9bba451ea703cb679c4da5e1fd1a8d4b2c2f15e/certbot_py-0.10.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c09b482804e4b9383a9b2120a353bbcf", "sha256": "9209e5a1cd161082e2a4d49e2f7ba8abec2d7f6695cfada279672fd7e87f2b69"}, "downloads": -1, "filename": "certbot_py-0.10.1.tar.gz", "has_sig": false, "md5_digest": "c09b482804e4b9383a9b2120a353bbcf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8459, "upload_time": "2017-03-07T17:07:41", "upload_time_iso_8601": "2017-03-07T17:07:41.792394Z", "url": "https://files.pythonhosted.org/packages/2c/b6/22166fe7f992c80617c9cd10e25d934540ec5df72384d7251889425775ec/certbot_py-0.10.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "02ac8e14bca627cca630b56641090d84", "sha256": "e72e59da88e394098777b9767527217ace5e9fcc11af8926f6187eff7719870f"}, "downloads": -1, "filename": "certbot_py-0.10.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "02ac8e14bca627cca630b56641090d84", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12033, "upload_time": "2017-03-07T17:07:39", "upload_time_iso_8601": "2017-03-07T17:07:39.581726Z", "url": "https://files.pythonhosted.org/packages/59/9e/868bb97f0e9ed12bfb2cd9bba451ea703cb679c4da5e1fd1a8d4b2c2f15e/certbot_py-0.10.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c09b482804e4b9383a9b2120a353bbcf", "sha256": "9209e5a1cd161082e2a4d49e2f7ba8abec2d7f6695cfada279672fd7e87f2b69"}, "downloads": -1, "filename": "certbot_py-0.10.1.tar.gz", "has_sig": false, "md5_digest": "c09b482804e4b9383a9b2120a353bbcf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8459, "upload_time": "2017-03-07T17:07:41", "upload_time_iso_8601": "2017-03-07T17:07:41.792394Z", "url": "https://files.pythonhosted.org/packages/2c/b6/22166fe7f992c80617c9cd10e25d934540ec5df72384d7251889425775ec/certbot_py-0.10.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:34:44 2020"}