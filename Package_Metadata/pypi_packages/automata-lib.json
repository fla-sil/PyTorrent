{"info": {"author": "Caleb Evans", "author_email": "caleb@calebevans.me", "bugtrack_url": null, "classifiers": [], "description": "Automata\n========\n\n| *Copyright 2016-2019 Caleb Evans*\n| *Released under the MIT license*\n\n|Build Status| |Coverage Status|\n\nAutomata is a Python 3 library which implements the structures and\nalgorithms for finite automata, pushdown automata, and Turing machines.\n\nAutomata requires Python 3.4 or newer.\n\nMigration to v2 or v3\n---------------------\n\nIf you are using Automata v1 and wish to migrate to v2 or v3, please\nfollow the `migration\nguide <https://github.com/caleb531/automata/blob/master/MIGRATION.md>`__.\n\nInstalling\n----------\n\nYou can install the latest version of Automata via pip:\n\n::\n\n   pip install automata-lib\n\nAPI\n---\n\n-  `class Automaton <#class-automatonmetaclassabcmeta>`__\n\n   -  `class FA <#class-faautomatonmetaclassabcmeta>`__\n\n      -  `class DFA <#class-dfafa>`__\n      -  `class NFA <#class-nfafa>`__\n\n   -  `class PDA <#class-pdaautomatonmetaclassabcmeta>`__\n\n      -  `class DPDA <#class-dpdapda>`__\n      -  `class NPDA <#class-npdapda>`__\n\n   -  `class TM <#class-tmautomatonmetaclassabcmeta>`__\n\n      -  `class DTM <#class-dtmtm>`__\n      -  `class NTM <#class-ntmtm>`__\n\n-  `Exception classes <#base-exception-classes>`__\n\n   -  `Turing machine exceptions <#turing-machine-exception-classes>`__\n\nclass Automaton(metaclass=ABCMeta)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``Automaton`` class is an abstract base class from which all\nautomata (including Turing machines) inherit. As such, it cannot be\ninstantiated on its own; you must use a defined subclasses instead (or\nyou may create your own subclass if you\u2019re feeling adventurous). The\n``Automaton`` class can be found under ``automata/base/automaton.py``.\n\nIf you wish to subclass ``Automaton``, you can import it like so:\n\n.. code:: python\n\n   from automata.base.automaton import Automaton\n\nThe following methods are common to all Automaton subtypes:\n\nAutomaton.read_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReads an input string into the automaton, returning the automaton\u2019s\nfinal configuration (according to its subtype). If the input is\nrejected, the method raises a ``RejectionException``.\n\nAutomaton.read_input_stepwise(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReads an input string like ``read_input()``, except instead of returning\nthe final configuration, the method returns a generator. The values\nyielded by this generator depend on the automaton\u2019s subtype.\n\nIf the string is rejected by the automaton, the method still raises a\n``RejectionException``.\n\nAutomaton.accepts_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReads an input string like ``read_input()``, except it returns a boolean\ninstead of returning the automaton\u2019s final configuration (or raising an\nexception). That is, the method always returns ``True`` if the input is\naccepted, and it always returns ``False`` if the input is rejected.\n\nAutomaton.validate(self)\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nChecks whether the automaton is actually a valid automaton (according to\nits subtype). It returns ``True`` if the automaton is valid; otherwise,\nit will raise the appropriate exception (*e.g.* the state transition is\nmissing for a particular symbol).\n\nThis method is automatically called when the automaton is initialized,\nso it\u2019s only really useful if a automaton object is modified after\ninstantiation.\n\nAutomaton.copy(self)\n^^^^^^^^^^^^^^^^^^^^\n\nReturns a deep copy of the automaton according to its subtype.\n\nclass FA(Automaton, metaclass=ABCMeta)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``FA`` class is an abstract base class from which all finite\nautomata inherit. The ``FA`` class can be found under\n``automata/fa/fa.py``.\n\nIf you wish to subclass ``FA``, you can import it like so:\n\n.. code:: python\n\n   from automata.fa.fa import FA\n\nclass DFA(FA)\n~~~~~~~~~~~~~\n\nThe ``DFA`` class is a subclass of ``FA`` and represents a deterministic\nfinite automaton. It can be found under ``automata/fa/dfa.py``.\n\nEvery DFA has the following (required) properties:\n\n1. ``states``: a ``set`` of the DFA\u2019s valid states, each of which must\n   be represented as a string\n\n2. ``input_symbols``: a ``set`` of the DFA\u2019s valid input symbols, each\n   of which must also be represented as a string\n\n3. ``transitions``: a ``dict`` consisting of the transitions for each\n   state. Each key is a state name and each value is a ``dict`` which\n   maps a symbol (the key) to a state (the value).\n\n4. ``initial_state``: the name of the initial state for this DFA\n\n5. ``final_states``: a ``set`` of final states for this DFA\n\n.. code:: python\n\n   from automata.fa.dfa import DFA\n   # DFA which matches all binary strings ending in an odd number of '1's\n   dfa = DFA(\n       states={'q0', 'q1', 'q2'},\n       input_symbols={'0', '1'},\n       transitions={\n           'q0': {'0': 'q0', '1': 'q1'},\n           'q1': {'0': 'q0', '1': 'q2'},\n           'q2': {'0': 'q2', '1': 'q1'}\n       },\n       initial_state='q0',\n       final_states={'q1'}\n   )\n\nDFA.read_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns the final state the DFA stopped on, if the input is accepted.\n\n.. code:: python\n\n   dfa.read_input('01')  # returns 'q1'\n\n.. code:: python\n\n   dfa.read_input('011')  # raises RejectionException\n\nDFA.read_input_stepwise(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYields each state reached as the DFA reads characters from the input\nstring, if the input is accepted.\n\n.. code:: python\n\n   dfa.read_input_stepwise('0111')\n   # yields:\n   # 'q0'\n   # 'q0'\n   # 'q1'\n   # 'q2'\n   # 'q1'\n\nDFA.accepts_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   if dfa.accepts_input(my_input_str):\n       print('accepted')\n   else:\n       print('rejected')\n\nDFA.validate(self)\n^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   dfa.validate()  # returns True\n\nDFA.copy(self)\n^^^^^^^^^^^^^^\n\n.. code:: python\n\n   dfa.copy()  # returns deep copy of dfa\n\nDFA.minify(self)\n^^^^^^^^^^^^^^^^\n\nCreates a minimal DFA which accepts the same inputs as the old one.\nUnreachable states are removed and equivalent states are merged.\n\n.. code:: python\n\n   minimal_dfa = dfa.minify()\n\nDFA.from_nfa(cls, nfa)\n^^^^^^^^^^^^^^^^^^^^^^\n\nCreates a DFA that is equivalent to the given NFA.\n\n.. code:: python\n\n   from automata.fa.dfa import DFA\n   from automata.fa.nfa import NFA\n   dfa = DFA.from_nfa(nfa)  # returns an equivalent DFA\n\nclass NFA(FA)\n~~~~~~~~~~~~~\n\nThe ``NFA`` class is a subclass of ``FA`` and represents a\nnondeterministic finite automaton. It can be found under\n``automata/fa/nfa.py``.\n\nEvery NFA has the same five DFA properties: ``state``,\n``input_symbols``, ``transitions``, ``initial_state``, and\n``final_states``. However, the structure of the ``transitions`` object\nhas been modified slightly to accommodate the fact that a single state\ncan have more than one transition for the same symbol. Therefore,\ninstead of mapping a symbol to *one* end state in each sub-dict, each\nsymbol is mapped to a *set* of end states.\n\n.. code:: python\n\n   from automata.fa.nfa import NFA\n   # NFA which matches strings beginning with 'a', ending with 'a', and containing\n   # no consecutive 'b's\n   nfa = NFA(\n       states={'q0', 'q1', 'q2'},\n       input_symbols={'a', 'b'},\n       transitions={\n           'q0': {'a': {'q1'}},\n           # Use '' as the key name for empty string (lambda/epsilon) transitions\n           'q1': {'a': {'q1'}, '': {'q2'}},\n           'q2': {'b': {'q0'}}\n       },\n       initial_state='q0',\n       final_states={'q1'}\n   )\n\nNFA.read_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns a set of final states the FA stopped on, if the input is\naccepted.\n\n.. code:: python\n\n   nfa.read_input('aba')  # returns {'q1', 'q2'}\n\n.. code:: python\n\n   nfa.read_input('abba')  # raises RejectionException\n\nNFA.read_input_stepwise(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYields each set of states reached as the NFA reads characters from the\ninput string, if the input is accepted.\n\n.. code:: python\n\n   nfa.read_input_stepwise('aba')\n   # yields:\n   # {'q0'}\n   # {'q1', 'q2'}\n   # {'q0'}\n   # {'q1', 'q2'}\n\nNFA.accepts_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   if nfa.accepts_input(my_input_str):\n       print('accepted')\n   else:\n       print('rejected')\n\nNFA.validate(self)\n^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   nfa.validate()  # returns True\n\nNFA.copy(self)\n^^^^^^^^^^^^^^\n\n.. code:: python\n\n   nfa.copy()  # returns deep copy of nfa\n\nNFA.from_dfa(cls, dfa)\n^^^^^^^^^^^^^^^^^^^^^^\n\nCreates an NFA that is equivalent to the given DFA.\n\n.. code:: python\n\n   from automata.fa.nfa import NFA\n   from automata.fa.dfa import DFA\n   nfa = NFA.from_dfa(dfa)  # returns an equivalent NFA\n\nclass PDA(Automaton, metaclass=ABCMeta)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe ``PDA`` class is an abstract base class from which all pushdown\nautomata inherit. It can be found under ``automata/pda/pda.py``.\n\nclass DPDA(PDA)\n~~~~~~~~~~~~~~~\n\nThe ``DPDA`` class is a subclass of ``PDA`` and represents a\ndeterministic finite automaton. It can be found under\n``automata/pda/dpda.py``.\n\nEvery DPDA has the following (required) properties:\n\n1. ``states``: a ``set`` of the DPDA\u2019s valid states, each of which must\n   be represented as a string\n\n2. ``input_symbols``: a ``set`` of the DPDA\u2019s valid input symbols, each\n   of which must also be represented as a string\n\n3. ``stack_symbols``: a ``set`` of the DPDA\u2019s valid stack symbols\n\n4. ``transitions``: a ``dict`` consisting of the transitions for each\n   state; see the example below for the exact syntax\n\n5. ``initial_state``: the name of the initial state for this DPDA\n\n6. ``initial_stack_symbol``: the name of the initial symbol on the stack\n   for this DPDA\n\n7. ``final_states``: a ``set`` of final states for this DPDA\n\n8. ``acceptance_mode``: a string defining whether this DPDA accepts by\n   ``'final_state'``, ``'empty_stack'``, or ``'both'``; the default is\n   ``'both'``\n\n.. code:: python\n\n   from automata.pda.dpda import DPDA\n   # DPDA which which matches zero or more 'a's, followed by the same\n   # number of 'b's (accepting by final state)\n   dpda = DPDA(\n       states={'q0', 'q1', 'q2', 'q3'},\n       input_symbols={'a', 'b'},\n       stack_symbols={'0', '1'},\n       transitions={\n           'q0': {\n               'a': {'0': ('q1', ('1', '0'))}  # transition pushes '1' to stack\n           },\n           'q1': {\n               'a': {'1': ('q1', ('1', '1'))},\n               'b': {'1': ('q2', '')}  # transition pops from stack\n           },\n           'q2': {\n               'b': {'1': ('q2', '')},\n               '': {'0': ('q3', ('0',))}  # transition does not change stack\n           }\n       },\n       initial_state='q0',\n       initial_stack_symbol='0',\n       final_states={'q3'},\n       acceptance_mode='final_state'\n   )\n\nDPDA.read_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns a ``PDAConfiguration`` object representing the DPDA\u2019s config.\nThis is basically a tuple containing the final state the DPDA stopped\non, the remaining input (an empty string) as well as a ``PDAStack``\nobject representing the DPDA\u2019s stack (if the input is accepted).\n\n.. code:: python\n\n   dpda.read_input('ab')  # returns PDAConfiguration('q3', '', PDAStack(('0')))\n\n.. code:: python\n\n   dpda.read_input('aab')  # raises RejectionException\n\nDPDA.read_input_stepwise(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYields ``PDAConfiguration`` objects. These are basically tuples\ncontaining the current state, the remaining input and the current stack\nas a ``PDAStack`` object, if the input is accepted.\n\n.. code:: python\n\n   dpda.read_input_stepwise('ab')\n   # yields:\n   # PDAConfiguration('q0', 'ab', PDAStack(('0')))\n   # PDAConfiguration('q1', 'a', PDAStack(('0', '1')))\n   # PDAConfiguration('q3', '', PDAStack(('0')))\n\nDPDA.accepts_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   if dpda.accepts_input(my_input_str):\n       print('accepted')\n   else:\n       print('rejected')\n\nDPDA.validate(self)\n^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   dpda.validate()  # returns True\n\nDPDA.copy(self)\n^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   dpda.copy()  # returns deep copy of dpda\n\nclass NPDA(PDA)\n~~~~~~~~~~~~~~~\n\nThe ``NPDA`` class is a subclass of ``PDA`` and represents a\nnondeterministic pushdown automaton. It can be found under\n``automata/pda/npda.py``.\n\nEvery NPDA has the following (required) properties:\n\n1. ``states``: a ``set`` of the NPDA\u2019s valid states, each of which must\n   be represented as a string\n\n2. ``input_symbols``: a ``set`` of the NPDA\u2019s valid input symbols, each\n   of which must also be represented as a string\n\n3. ``stack_symbols``: a ``set`` of the NPDA\u2019s valid stack symbols\n\n4. ``transitions``: a ``dict`` consisting of the transitions for each\n   state; see the example below for the exact syntax\n\n5. ``initial_state``: the name of the initial state for this NPDA\n\n6. ``initial_stack_symbol``: the name of the initial symbol on the stack\n   for this NPDA\n\n7. ``final_states``: a ``set`` of final states for this NPDA\n\n8. ``acceptance_mode``: a string defining whether this NPDA accepts by\n   ``'final_state'``, ``'empty_stack'``, or ``'both'``; the default is\n   ``'both'``\n\n.. code:: python\n\n   from automata.pda.npda import NPDA\n   # NPDA which matches palindromes consisting of 'a's and 'b's\n   # (accepting by final state)\n   # q0 reads the first half of the word, q1 the other half, q2 accepts.\n   # But we have to guess when to switch.\n   npda = NPDA(\n       states={'q0', 'q1', 'q2'},\n       input_symbols={'a', 'b'},\n       stack_symbols={'A', 'B', '#'},\n       transitions={\n           'q0': {\n               '': {\n                   '#': {('q2', '#')},\n               },\n               'a': {\n                   '#': {('q0', ('A', '#'))},\n                   'A': {\n                       ('q0', ('A', 'A')),\n                       ('q1', ''),\n                   },\n                   'B': {('q0', ('A', 'B'))},\n               },\n               'b': {\n                   '#': {('q0', ('B', '#'))},\n                   'A': {('q0', ('B', 'A'))},\n                   'B': {\n                       ('q0', ('B', 'B')),\n                       ('q1', ''),\n                   },\n               },\n           },\n           'q1': {\n               '': {'#': {('q2', '#')}},\n               'a': {'A': {('q1', '')}},\n               'b': {'B': {('q1', '')}},\n           },\n       },\n       initial_state='q0',\n       initial_stack_symbol='#',\n       final_states={'q2'},\n       acceptance_mode='final_state'\n   )\n\nNPDA.read_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns a ``set`` of ``PDAConfiguration``\\ s representing all of the\nNPDA\u2019s configurations. Each of these is basically a tuple containing the\nfinal state the NPDA stopped on, the remaining input (an empty string)\nas well as a ``PDAStack`` object representing the NPDA\u2019s stack (if the\ninput is accepted).\n\n.. code:: python\n\n   npda.read_input(\"aaaa\") # returns {PDAConfiguration('q2', '', PDAStack('#',))}\n\n.. code:: python\n\n   npda.read_input('ab')  # raises RejectionException\n\nNPDA.read_input_stepwise(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYields ``set``\\ s of ``PDAConfiguration`` object. Each of these is\nbasically a tuple containing the current state, the remaining input and\nthe current stack as a ``PDAStack`` object, if the input is accepted.\n\n.. code:: python\n\n   npda.read_input_stepwise('aa')\n   # yields:\n   # {PDAConfiguration('q0', 'aa', PDAStack('#',))}\n   # {PDAConfiguration('q0', 'a', PDAStack('#', 'A')), PDAConfiguration('q2', 'aa', PDAStack('#',))}\n   # {PDAConfiguration('q0', '', PDAStack('#', 'A', 'A')), PDAConfiguration('q1', '', PDAStack('#',))}\n   # {PDAConfiguration('q2', '', PDAStack('#',))}\n\nNPDA.accepts_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   if npda.accepts_input(my_input_str):\n       print('accepted')\n   else:\n       print('rejected')\n\nNPDA.validate(self)\n^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   npda.validate()  # returns True\n\nNPDA.copy(self)\n^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   npda.copy()  # returns deep copy of npda\n\nclass TM(Automaton, metaclass=ABCMeta)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``TM`` class is an abstract base class from which all Turing\nmachines inherit. It can be found under ``automata/tm/tm.py``.\n\nclass DTM(TM)\n~~~~~~~~~~~~~\n\nThe ``DTM`` class is a subclass of ``TM`` and represents a deterministic\nTuring machine. It can be found under ``automata/tm/dtm.py``.\n\nEvery DTM has the following (required) properties:\n\n1. ``states``: a ``set`` of the DTM\u2019s valid states, each of which must\n   be represented as a string\n\n2. ``input_symbols``: a ``set`` of the DTM\u2019s valid input symbols\n   represented as strings\n\n3. ``tape_symbols``: a ``set`` of the DTM\u2019s valid tape symbols\n   represented as strings\n\n4. ``transitions``: a ``dict`` consisting of the transitions for each\n   state; each key is a state name and each value is a ``dict`` which\n   maps a symbol (the key) to a state (the value)\n\n5. ``initial_state``: the name of the initial state for this DTM\n\n6. ``blank_symbol``: a symbol from ``tape_symbols`` to be used as the\n   blank symbol for this DTM\n\n7. ``final_states``: a ``set`` of final states for this DTM\n\n.. code:: python\n\n   from automata.tm.dtm import DTM\n   # DTM which matches all strings beginning with '0's, and followed by\n   # the same number of '1's\n   dtm = DTM(\n       states={'q0', 'q1', 'q2', 'q3', 'q4'},\n       input_symbols={'0', '1'},\n       tape_symbols={'0', '1', 'x', 'y', '.'},\n       transitions={\n           'q0': {\n               '0': ('q1', 'x', 'R'),\n               'y': ('q3', 'y', 'R')\n           },\n           'q1': {\n               '0': ('q1', '0', 'R'),\n               '1': ('q2', 'y', 'L'),\n               'y': ('q1', 'y', 'R')\n           },\n           'q2': {\n               '0': ('q2', '0', 'L'),\n               'x': ('q0', 'x', 'R'),\n               'y': ('q2', 'y', 'L')\n           },\n           'q3': {\n               'y': ('q3', 'y', 'R'),\n               '.': ('q4', '.', 'R')\n           }\n       },\n       initial_state='q0',\n       blank_symbol='.',\n       final_states={'q4'}\n   )\n\nThe direction ``N`` (for no movement) is also supported.\n\nDTM.read_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns a ``TMConfiguration``. This is basically a tuple containing the\nfinal state the machine stopped on, as well as a ``TMTape`` object\nrepresenting the DTM\u2019s internal tape (if the input is accepted).\n\n.. code:: python\n\n   dtm.read_input('01')  # returns TMConfiguration('q4', TMTape('xy..', 3))\n\nCalling ``config.print()`` will produce a more readable output:\n\n.. code:: python\n\n   dtm.read_input('01').print()\n   # q4: xy..\n   #        ^\n\n.. code:: python\n\n   dtm.read_input('011')  # raises RejectionException\n\nDTM.read_input_stepwise(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYields ``TMConfiguration``\\ s. Those are basically tuples containing the\ncurrent state and the current tape as a ``TMTape`` object.\n\n.. code:: python\n\n   dtm.read_input_stepwise('01')\n   # yields:\n   # TMConfiguration('q0', TMTape('01', 0))\n   # TMConfiguration('q1', TMTape('x1', 1))\n   # TMConfiguration('q2', TMTape('xy', 0))\n   # TMConfiguration('q0', TMTape('xy', 1))\n   # TMConfiguration('q3', TMTape('xy.', 2))\n   # TMConfiguration('q4', TMTape('xy..', 3))\n\nDTM.accepts_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   if dtm.accepts_input(my_input_str):\n       print('accepted')\n   else:\n       print('rejected')\n\nDTM.validate(self)\n^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   dtm.validate()  # returns True\n\nDTM.copy(self)\n^^^^^^^^^^^^^^\n\n.. code:: python\n\n   dtm.copy()  # returns deep copy of dtm\n\nclass NTM(TM)\n~~~~~~~~~~~~~\n\nThe ``NTM`` class is a subclass of ``TM`` and represents a\nnondeterministic Turing machine. It can be found under\n``automata/tm/ntm.py``.\n\nEvery NTM has the following (required) properties:\n\n1. ``states``: a ``set`` of the NTM\u2019s valid states, each of which must\n   be represented as a string\n\n2. ``input_symbols``: a ``set`` of the NTM\u2019s valid input symbols\n   represented as strings\n\n3. ``tape_symbols``: a ``set`` of the NTM\u2019s valid tape symbols\n   represented as strings\n\n4. ``transitions``: a ``dict`` consisting of the transitions for each\n   state; each key is a state name and each value is a ``dict`` which\n   maps a symbol (the key) to a set of states (the values)\n\n5. ``initial_state``: the name of the initial state for this NTM\n\n6. ``blank_symbol``: a symbol from ``tape_symbols`` to be used as the\n   blank symbol for this NTM\n\n7. ``final_states``: a ``set`` of final states for this NTM\n\n.. code:: python\n\n   from automata.tm.ntm import NTM\n   # NTM which matches all strings beginning with '0's, and followed by\n   # the same number of '1's\n   # Note that the nondeterminism is not really used here.\n   ntm = NTM(\n       states={'q0', 'q1', 'q2', 'q3', 'q4'},\n       input_symbols={'0', '1'},\n       tape_symbols={'0', '1', 'x', 'y', '.'},\n       transitions={\n           'q0': {\n               '0': {('q1', 'x', 'R')},\n               'y': {('q3', 'y', 'R')},\n           },\n           'q1': {\n               '0': {('q1', '0', 'R')},\n               '1': {('q2', 'y', 'L')},\n               'y': {('q1', 'y', 'R')},\n           },\n           'q2': {\n               '0': {('q2', '0', 'L')},\n               'x': {('q0', 'x', 'R')},\n               'y': {('q2', 'y', 'L')},\n           },\n           'q3': {\n               'y': {('q3', 'y', 'R')},\n               '.': {('q4', '.', 'R')},\n           }\n       },\n       initial_state='q0',\n       blank_symbol='.',\n       final_states={'q4'}\n   )\n\nThe direction ``N`` (for no movement) is also supported.\n\nNTM.read_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns a set of ``TMConfiguration``\\ s. These are basically tuples\ncontaining the final state the machine stopped on, as well as a\n``TMTape`` object representing the DTM\u2019s internal tape (if the input is\naccepted).\n\n.. code:: python\n\n   ntm.read_input('01')  # returns {TMConfiguration('q4', TMTape('xy..', 3))}\n\nCalling ``config.print()`` will produce a more readable output:\n\n.. code:: python\n\n   ntm.read_input('01').pop().print()\n   # q4: xy..\n   #        ^\n\n.. code:: python\n\n   ntm.read_input('011')  # raises RejectionException\n\nNTM.read_input_stepwise(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYields sets of ``TMConfiguration``\\ s. Those are basically tuples\ncontaining the current state and the current tape as a ``TMTape``\nobject.\n\n.. code:: python\n\n   ntm.read_input_stepwise('01')\n   # yields:\n   # {TMConfiguration('q0', TMTape('01', 0))}\n   # {TMConfiguration('q1', TMTape('x1', 1))}\n   # {TMConfiguration('q2', TMTape('xy', 0))}\n   # {TMConfiguration('q0', TMTape('xy', 1))}\n   # {TMConfiguration('q3', TMTape('xy.', 2))}\n   # {TMConfiguration('q4', TMTape('xy..', 3))}\n\nNTM.accepts_input(self, input_str)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   if ntm.accepts_input(my_input_str):\n       print('accepted')\n   else:\n       print('rejected')\n\nNTM.validate(self)\n^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n   ntm.validate()  # returns True\n\nNTM.copy(self)\n^^^^^^^^^^^^^^\n\n.. code:: python\n\n   ntm.copy()  # returns deep copy of ntm\n\nBase exception classes\n~~~~~~~~~~~~~~~~~~~~~~\n\nThe library also includes a number of exception classes to ensure that\nerrors never pass silently (unless explicitly silenced). See\n``automata/base/exceptions.py`` for these class definitions.\n\nTo reference these exceptions (so as to catch them in a ``try..except``\nblock or whatnot), simply import ``automata.base.exceptions`` however\nyou\u2019d like:\n\n.. code:: python\n\n   import automata.base.exceptions as exceptions\n\nclass AutomatonException\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nA base class from which all other automata exceptions inherit (including\nfinite automata and Turing machines).\n\nclass InvalidStateError\n^^^^^^^^^^^^^^^^^^^^^^^\n\nRaised if a state is not a valid state for this automaton.\n\nclass InvalidSymbolError\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nRaised if a symbol is not a valid symbol for this automaton.\n\nclass MissingStateError\n^^^^^^^^^^^^^^^^^^^^^^^\n\nRaised if a state is missing from the automaton definition.\n\nclass MissingSymbolError\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nRaised if a symbol is missing from the automaton definition.\n\nclass InitialStateError\n^^^^^^^^^^^^^^^^^^^^^^^\n\nRaised if the initial state fails to meet some required condition for\nthis type of automaton.\n\nclass FinalStateError\n^^^^^^^^^^^^^^^^^^^^^\n\nRaised if a final state fails to meet some required condition for this\ntype of automaton.\n\nclass RejectionException\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nRaised if the automaton stopped on a non-final state after validating\ninput.\n\nTuring machine exception classes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``automata.tm`` package also includes a module for exceptions\nspecific to Turing machines. You can reference these exception classes\nlike so:\n\n.. code:: python\n\n   import automata.tm.exceptions as tm_exceptions\n\nclass TMException\n^^^^^^^^^^^^^^^^^\n\nA base class from which all other Turing machine exceptions inherit.\n\nclass InvalidDirectionError\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRaised if a direction specified in this machine\u2019s transition map is not\na valid direction.\n\n.. |Build Status| image:: https://travis-ci.org/caleb531/automata.svg?branch=master\n   :target: https://travis-ci.org/caleb531/automata\n.. |Coverage Status| image:: https://coveralls.io/repos/caleb531/automata/badge.svg?branch=master\n   :target: https://coveralls.io/r/caleb531/automata?branch=master\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/caleb531/automata", "keywords": "automata turing machine", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "automata-lib", "package_url": "https://pypi.org/project/automata-lib/", "platform": "", "project_url": "https://pypi.org/project/automata-lib/", "project_urls": {"Homepage": "https://github.com/caleb531/automata"}, "release_url": "https://pypi.org/project/automata-lib/3.1.0.post1/", "requires_dist": null, "requires_python": "", "summary": "A Python library for simulating automata and Turing machines", "version": "3.1.0.post1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div>\n<div><em>Copyright 2016-2019 Caleb Evans</em></div>\n<div><em>Released under the MIT license</em></div>\n</div>\n<p><a href=\"https://travis-ci.org/caleb531/automata\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/02492055612c0782d8f2d7a3720d4ff78c6e87db/68747470733a2f2f7472617669732d63692e6f72672f63616c65623533312f6175746f6d6174612e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://coveralls.io/r/caleb531/automata?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6f2e03c2c7b8cd421465447108b22d77d397c72c/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f63616c65623533312f6175746f6d6174612f62616467652e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>Automata is a Python 3 library which implements the structures and\nalgorithms for finite automata, pushdown automata, and Turing machines.</p>\n<p>Automata requires Python 3.4 or newer.</p>\n<div id=\"migration-to-v2-or-v3\">\n<h2>Migration to v2 or v3</h2>\n<p>If you are using Automata v1 and wish to migrate to v2 or v3, please\nfollow the <a href=\"https://github.com/caleb531/automata/blob/master/MIGRATION.md\" rel=\"nofollow\">migration\nguide</a>.</p>\n</div>\n<div id=\"installing\">\n<h2>Installing</h2>\n<p>You can install the latest version of Automata via pip:</p>\n<pre>pip install automata-lib\n</pre>\n</div>\n<div id=\"api\">\n<h2>API</h2>\n<ul>\n<li><a href=\"#class-automatonmetaclassabcmeta\" rel=\"nofollow\">class Automaton</a><ul>\n<li><a href=\"#class-faautomatonmetaclassabcmeta\" rel=\"nofollow\">class FA</a><ul>\n<li><a href=\"#class-dfafa\" rel=\"nofollow\">class DFA</a></li>\n<li><a href=\"#class-nfafa\" rel=\"nofollow\">class NFA</a></li>\n</ul>\n</li>\n<li><a href=\"#class-pdaautomatonmetaclassabcmeta\" rel=\"nofollow\">class PDA</a><ul>\n<li><a href=\"#class-dpdapda\" rel=\"nofollow\">class DPDA</a></li>\n<li><a href=\"#class-npdapda\" rel=\"nofollow\">class NPDA</a></li>\n</ul>\n</li>\n<li><a href=\"#class-tmautomatonmetaclassabcmeta\" rel=\"nofollow\">class TM</a><ul>\n<li><a href=\"#class-dtmtm\" rel=\"nofollow\">class DTM</a></li>\n<li><a href=\"#class-ntmtm\" rel=\"nofollow\">class NTM</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#base-exception-classes\" rel=\"nofollow\">Exception classes</a><ul>\n<li><a href=\"#turing-machine-exception-classes\" rel=\"nofollow\">Turing machine exceptions</a></li>\n</ul>\n</li>\n</ul>\n<div id=\"class-automaton-metaclass-abcmeta\">\n<h3>class Automaton(metaclass=ABCMeta)</h3>\n<p>The <tt>Automaton</tt> class is an abstract base class from which all\nautomata (including Turing machines) inherit. As such, it cannot be\ninstantiated on its own; you must use a defined subclasses instead (or\nyou may create your own subclass if you\u2019re feeling adventurous). The\n<tt>Automaton</tt> class can be found under <tt>automata/base/automaton.py</tt>.</p>\n<p>If you wish to subclass <tt>Automaton</tt>, you can import it like so:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.base.automaton</span> <span class=\"kn\">import</span> <span class=\"n\">Automaton</span>\n</pre>\n<p>The following methods are common to all Automaton subtypes:</p>\n<div id=\"automaton-read-input-self-input-str\">\n<h4>Automaton.read_input(self, input_str)</h4>\n<p>Reads an input string into the automaton, returning the automaton\u2019s\nfinal configuration (according to its subtype). If the input is\nrejected, the method raises a <tt>RejectionException</tt>.</p>\n</div>\n<div id=\"automaton-read-input-stepwise-self-input-str\">\n<h4>Automaton.read_input_stepwise(self, input_str)</h4>\n<p>Reads an input string like <tt>read_input()</tt>, except instead of returning\nthe final configuration, the method returns a generator. The values\nyielded by this generator depend on the automaton\u2019s subtype.</p>\n<p>If the string is rejected by the automaton, the method still raises a\n<tt>RejectionException</tt>.</p>\n</div>\n<div id=\"automaton-accepts-input-self-input-str\">\n<h4>Automaton.accepts_input(self, input_str)</h4>\n<p>Reads an input string like <tt>read_input()</tt>, except it returns a boolean\ninstead of returning the automaton\u2019s final configuration (or raising an\nexception). That is, the method always returns <tt>True</tt> if the input is\naccepted, and it always returns <tt>False</tt> if the input is rejected.</p>\n</div>\n<div id=\"automaton-validate-self\">\n<h4>Automaton.validate(self)</h4>\n<p>Checks whether the automaton is actually a valid automaton (according to\nits subtype). It returns <tt>True</tt> if the automaton is valid; otherwise,\nit will raise the appropriate exception (<em>e.g.</em> the state transition is\nmissing for a particular symbol).</p>\n<p>This method is automatically called when the automaton is initialized,\nso it\u2019s only really useful if a automaton object is modified after\ninstantiation.</p>\n</div>\n<div id=\"automaton-copy-self\">\n<h4>Automaton.copy(self)</h4>\n<p>Returns a deep copy of the automaton according to its subtype.</p>\n</div>\n</div>\n<div id=\"class-fa-automaton-metaclass-abcmeta\">\n<h3>class FA(Automaton, metaclass=ABCMeta)</h3>\n<p>The <tt>FA</tt> class is an abstract base class from which all finite\nautomata inherit. The <tt>FA</tt> class can be found under\n<tt>automata/fa/fa.py</tt>.</p>\n<p>If you wish to subclass <tt>FA</tt>, you can import it like so:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.fa.fa</span> <span class=\"kn\">import</span> <span class=\"n\">FA</span>\n</pre>\n</div>\n<div id=\"class-dfa-fa\">\n<h3>class DFA(FA)</h3>\n<p>The <tt>DFA</tt> class is a subclass of <tt>FA</tt> and represents a deterministic\nfinite automaton. It can be found under <tt>automata/fa/dfa.py</tt>.</p>\n<p>Every DFA has the following (required) properties:</p>\n<ol>\n<li><tt>states</tt>: a <tt>set</tt> of the DFA\u2019s valid states, each of which must\nbe represented as a string</li>\n<li><tt>input_symbols</tt>: a <tt>set</tt> of the DFA\u2019s valid input symbols, each\nof which must also be represented as a string</li>\n<li><tt>transitions</tt>: a <tt>dict</tt> consisting of the transitions for each\nstate. Each key is a state name and each value is a <tt>dict</tt> which\nmaps a symbol (the key) to a state (the value).</li>\n<li><tt>initial_state</tt>: the name of the initial state for this DFA</li>\n<li><tt>final_states</tt>: a <tt>set</tt> of final states for this DFA</li>\n</ol>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.fa.dfa</span> <span class=\"kn\">import</span> <span class=\"n\">DFA</span>\n<span class=\"c1\"># DFA which matches all binary strings ending in an odd number of '1's</span>\n<span class=\"n\">dfa</span> <span class=\"o\">=</span> <span class=\"n\">DFA</span><span class=\"p\">(</span>\n    <span class=\"n\">states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'q2'</span><span class=\"p\">},</span>\n    <span class=\"n\">input_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">},</span>\n    <span class=\"n\">transitions</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s1\">'q0'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"s1\">'q1'</span><span class=\"p\">},</span>\n        <span class=\"s1\">'q1'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"s1\">'q2'</span><span class=\"p\">},</span>\n        <span class=\"s1\">'q2'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"s1\">'q1'</span><span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"n\">initial_state</span><span class=\"o\">=</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span>\n    <span class=\"n\">final_states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q1'</span><span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</pre>\n<div id=\"dfa-read-input-self-input-str\">\n<h4>DFA.read_input(self, input_str)</h4>\n<p>Returns the final state the DFA stopped on, if the input is accepted.</p>\n<pre><span class=\"n\">dfa</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'01'</span><span class=\"p\">)</span>  <span class=\"c1\"># returns 'q1'</span>\n</pre>\n<pre><span class=\"n\">dfa</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'011'</span><span class=\"p\">)</span>  <span class=\"c1\"># raises RejectionException</span>\n</pre>\n</div>\n<div id=\"dfa-read-input-stepwise-self-input-str\">\n<h4>DFA.read_input_stepwise(self, input_str)</h4>\n<p>Yields each state reached as the DFA reads characters from the input\nstring, if the input is accepted.</p>\n<pre><span class=\"n\">dfa</span><span class=\"o\">.</span><span class=\"n\">read_input_stepwise</span><span class=\"p\">(</span><span class=\"s1\">'0111'</span><span class=\"p\">)</span>\n<span class=\"c1\"># yields:</span>\n<span class=\"c1\"># 'q0'</span>\n<span class=\"c1\"># 'q0'</span>\n<span class=\"c1\"># 'q1'</span>\n<span class=\"c1\"># 'q2'</span>\n<span class=\"c1\"># 'q1'</span>\n</pre>\n</div>\n<div id=\"dfa-accepts-input-self-input-str\">\n<h4>DFA.accepts_input(self, input_str)</h4>\n<pre><span class=\"k\">if</span> <span class=\"n\">dfa</span><span class=\"o\">.</span><span class=\"n\">accepts_input</span><span class=\"p\">(</span><span class=\"n\">my_input_str</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'accepted'</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'rejected'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"dfa-validate-self\">\n<h4>DFA.validate(self)</h4>\n<pre><span class=\"n\">dfa</span><span class=\"o\">.</span><span class=\"n\">validate</span><span class=\"p\">()</span>  <span class=\"c1\"># returns True</span>\n</pre>\n</div>\n<div id=\"dfa-copy-self\">\n<h4>DFA.copy(self)</h4>\n<pre><span class=\"n\">dfa</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>  <span class=\"c1\"># returns deep copy of dfa</span>\n</pre>\n</div>\n<div id=\"dfa-minify-self\">\n<h4>DFA.minify(self)</h4>\n<p>Creates a minimal DFA which accepts the same inputs as the old one.\nUnreachable states are removed and equivalent states are merged.</p>\n<pre><span class=\"n\">minimal_dfa</span> <span class=\"o\">=</span> <span class=\"n\">dfa</span><span class=\"o\">.</span><span class=\"n\">minify</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"dfa-from-nfa-cls-nfa\">\n<h4>DFA.from_nfa(cls, nfa)</h4>\n<p>Creates a DFA that is equivalent to the given NFA.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.fa.dfa</span> <span class=\"kn\">import</span> <span class=\"n\">DFA</span>\n<span class=\"kn\">from</span> <span class=\"nn\">automata.fa.nfa</span> <span class=\"kn\">import</span> <span class=\"n\">NFA</span>\n<span class=\"n\">dfa</span> <span class=\"o\">=</span> <span class=\"n\">DFA</span><span class=\"o\">.</span><span class=\"n\">from_nfa</span><span class=\"p\">(</span><span class=\"n\">nfa</span><span class=\"p\">)</span>  <span class=\"c1\"># returns an equivalent DFA</span>\n</pre>\n</div>\n</div>\n<div id=\"class-nfa-fa\">\n<h3>class NFA(FA)</h3>\n<p>The <tt>NFA</tt> class is a subclass of <tt>FA</tt> and represents a\nnondeterministic finite automaton. It can be found under\n<tt>automata/fa/nfa.py</tt>.</p>\n<p>Every NFA has the same five DFA properties: <tt>state</tt>,\n<tt>input_symbols</tt>, <tt>transitions</tt>, <tt>initial_state</tt>, and\n<tt>final_states</tt>. However, the structure of the <tt>transitions</tt> object\nhas been modified slightly to accommodate the fact that a single state\ncan have more than one transition for the same symbol. Therefore,\ninstead of mapping a symbol to <em>one</em> end state in each sub-dict, each\nsymbol is mapped to a <em>set</em> of end states.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.fa.nfa</span> <span class=\"kn\">import</span> <span class=\"n\">NFA</span>\n<span class=\"c1\"># NFA which matches strings beginning with 'a', ending with 'a', and containing</span>\n<span class=\"c1\"># no consecutive 'b's</span>\n<span class=\"n\">nfa</span> <span class=\"o\">=</span> <span class=\"n\">NFA</span><span class=\"p\">(</span>\n    <span class=\"n\">states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'q2'</span><span class=\"p\">},</span>\n    <span class=\"n\">input_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">},</span>\n    <span class=\"n\">transitions</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s1\">'q0'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'q1'</span><span class=\"p\">}},</span>\n        <span class=\"c1\"># Use '' as the key name for empty string (lambda/epsilon) transitions</span>\n        <span class=\"s1\">'q1'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'q1'</span><span class=\"p\">},</span> <span class=\"s1\">''</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'q2'</span><span class=\"p\">}},</span>\n        <span class=\"s1\">'q2'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'q0'</span><span class=\"p\">}}</span>\n    <span class=\"p\">},</span>\n    <span class=\"n\">initial_state</span><span class=\"o\">=</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span>\n    <span class=\"n\">final_states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q1'</span><span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</pre>\n<div id=\"nfa-read-input-self-input-str\">\n<h4>NFA.read_input(self, input_str)</h4>\n<p>Returns a set of final states the FA stopped on, if the input is\naccepted.</p>\n<pre><span class=\"n\">nfa</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'aba'</span><span class=\"p\">)</span>  <span class=\"c1\"># returns {'q1', 'q2'}</span>\n</pre>\n<pre><span class=\"n\">nfa</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'abba'</span><span class=\"p\">)</span>  <span class=\"c1\"># raises RejectionException</span>\n</pre>\n</div>\n<div id=\"nfa-read-input-stepwise-self-input-str\">\n<h4>NFA.read_input_stepwise(self, input_str)</h4>\n<p>Yields each set of states reached as the NFA reads characters from the\ninput string, if the input is accepted.</p>\n<pre><span class=\"n\">nfa</span><span class=\"o\">.</span><span class=\"n\">read_input_stepwise</span><span class=\"p\">(</span><span class=\"s1\">'aba'</span><span class=\"p\">)</span>\n<span class=\"c1\"># yields:</span>\n<span class=\"c1\"># {'q0'}</span>\n<span class=\"c1\"># {'q1', 'q2'}</span>\n<span class=\"c1\"># {'q0'}</span>\n<span class=\"c1\"># {'q1', 'q2'}</span>\n</pre>\n</div>\n<div id=\"nfa-accepts-input-self-input-str\">\n<h4>NFA.accepts_input(self, input_str)</h4>\n<pre><span class=\"k\">if</span> <span class=\"n\">nfa</span><span class=\"o\">.</span><span class=\"n\">accepts_input</span><span class=\"p\">(</span><span class=\"n\">my_input_str</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'accepted'</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'rejected'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"nfa-validate-self\">\n<h4>NFA.validate(self)</h4>\n<pre><span class=\"n\">nfa</span><span class=\"o\">.</span><span class=\"n\">validate</span><span class=\"p\">()</span>  <span class=\"c1\"># returns True</span>\n</pre>\n</div>\n<div id=\"nfa-copy-self\">\n<h4>NFA.copy(self)</h4>\n<pre><span class=\"n\">nfa</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>  <span class=\"c1\"># returns deep copy of nfa</span>\n</pre>\n</div>\n<div id=\"nfa-from-dfa-cls-dfa\">\n<h4>NFA.from_dfa(cls, dfa)</h4>\n<p>Creates an NFA that is equivalent to the given DFA.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.fa.nfa</span> <span class=\"kn\">import</span> <span class=\"n\">NFA</span>\n<span class=\"kn\">from</span> <span class=\"nn\">automata.fa.dfa</span> <span class=\"kn\">import</span> <span class=\"n\">DFA</span>\n<span class=\"n\">nfa</span> <span class=\"o\">=</span> <span class=\"n\">NFA</span><span class=\"o\">.</span><span class=\"n\">from_dfa</span><span class=\"p\">(</span><span class=\"n\">dfa</span><span class=\"p\">)</span>  <span class=\"c1\"># returns an equivalent NFA</span>\n</pre>\n</div>\n<div id=\"class-pda-automaton-metaclass-abcmeta\">\n<h4>class PDA(Automaton, metaclass=ABCMeta)</h4>\n<p>The <tt>PDA</tt> class is an abstract base class from which all pushdown\nautomata inherit. It can be found under <tt>automata/pda/pda.py</tt>.</p>\n</div>\n</div>\n<div id=\"class-dpda-pda\">\n<h3>class DPDA(PDA)</h3>\n<p>The <tt>DPDA</tt> class is a subclass of <tt>PDA</tt> and represents a\ndeterministic finite automaton. It can be found under\n<tt>automata/pda/dpda.py</tt>.</p>\n<p>Every DPDA has the following (required) properties:</p>\n<ol>\n<li><tt>states</tt>: a <tt>set</tt> of the DPDA\u2019s valid states, each of which must\nbe represented as a string</li>\n<li><tt>input_symbols</tt>: a <tt>set</tt> of the DPDA\u2019s valid input symbols, each\nof which must also be represented as a string</li>\n<li><tt>stack_symbols</tt>: a <tt>set</tt> of the DPDA\u2019s valid stack symbols</li>\n<li><tt>transitions</tt>: a <tt>dict</tt> consisting of the transitions for each\nstate; see the example below for the exact syntax</li>\n<li><tt>initial_state</tt>: the name of the initial state for this DPDA</li>\n<li><tt>initial_stack_symbol</tt>: the name of the initial symbol on the stack\nfor this DPDA</li>\n<li><tt>final_states</tt>: a <tt>set</tt> of final states for this DPDA</li>\n<li><tt>acceptance_mode</tt>: a string defining whether this DPDA accepts by\n<tt>'final_state'</tt>, <tt>'empty_stack'</tt>, or <tt>'both'</tt>; the default is\n<tt>'both'</tt></li>\n</ol>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.pda.dpda</span> <span class=\"kn\">import</span> <span class=\"n\">DPDA</span>\n<span class=\"c1\"># DPDA which which matches zero or more 'a's, followed by the same</span>\n<span class=\"c1\"># number of 'b's (accepting by final state)</span>\n<span class=\"n\">dpda</span> <span class=\"o\">=</span> <span class=\"n\">DPDA</span><span class=\"p\">(</span>\n    <span class=\"n\">states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'q3'</span><span class=\"p\">},</span>\n    <span class=\"n\">input_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">},</span>\n    <span class=\"n\">stack_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">},</span>\n    <span class=\"n\">transitions</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s1\">'q0'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'1'</span><span class=\"p\">,</span> <span class=\"s1\">'0'</span><span class=\"p\">))}</span>  <span class=\"c1\"># transition pushes '1' to stack</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q1'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'1'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">))},</span>\n            <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">)}</span>  <span class=\"c1\"># transition pops from stack</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q2'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">)},</span>\n            <span class=\"s1\">''</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q3'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'0'</span><span class=\"p\">,))}</span>  <span class=\"c1\"># transition does not change stack</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"n\">initial_state</span><span class=\"o\">=</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span>\n    <span class=\"n\">initial_stack_symbol</span><span class=\"o\">=</span><span class=\"s1\">'0'</span><span class=\"p\">,</span>\n    <span class=\"n\">final_states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q3'</span><span class=\"p\">},</span>\n    <span class=\"n\">acceptance_mode</span><span class=\"o\">=</span><span class=\"s1\">'final_state'</span>\n<span class=\"p\">)</span>\n</pre>\n<div id=\"dpda-read-input-self-input-str\">\n<h4>DPDA.read_input(self, input_str)</h4>\n<p>Returns a <tt>PDAConfiguration</tt> object representing the DPDA\u2019s config.\nThis is basically a tuple containing the final state the DPDA stopped\non, the remaining input (an empty string) as well as a <tt>PDAStack</tt>\nobject representing the DPDA\u2019s stack (if the input is accepted).</p>\n<pre><span class=\"n\">dpda</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'ab'</span><span class=\"p\">)</span>  <span class=\"c1\"># returns PDAConfiguration('q3', '', PDAStack(('0')))</span>\n</pre>\n<pre><span class=\"n\">dpda</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'aab'</span><span class=\"p\">)</span>  <span class=\"c1\"># raises RejectionException</span>\n</pre>\n</div>\n<div id=\"dpda-read-input-stepwise-self-input-str\">\n<h4>DPDA.read_input_stepwise(self, input_str)</h4>\n<p>Yields <tt>PDAConfiguration</tt> objects. These are basically tuples\ncontaining the current state, the remaining input and the current stack\nas a <tt>PDAStack</tt> object, if the input is accepted.</p>\n<pre><span class=\"n\">dpda</span><span class=\"o\">.</span><span class=\"n\">read_input_stepwise</span><span class=\"p\">(</span><span class=\"s1\">'ab'</span><span class=\"p\">)</span>\n<span class=\"c1\"># yields:</span>\n<span class=\"c1\"># PDAConfiguration('q0', 'ab', PDAStack(('0')))</span>\n<span class=\"c1\"># PDAConfiguration('q1', 'a', PDAStack(('0', '1')))</span>\n<span class=\"c1\"># PDAConfiguration('q3', '', PDAStack(('0')))</span>\n</pre>\n</div>\n<div id=\"dpda-accepts-input-self-input-str\">\n<h4>DPDA.accepts_input(self, input_str)</h4>\n<pre><span class=\"k\">if</span> <span class=\"n\">dpda</span><span class=\"o\">.</span><span class=\"n\">accepts_input</span><span class=\"p\">(</span><span class=\"n\">my_input_str</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'accepted'</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'rejected'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"dpda-validate-self\">\n<h4>DPDA.validate(self)</h4>\n<pre><span class=\"n\">dpda</span><span class=\"o\">.</span><span class=\"n\">validate</span><span class=\"p\">()</span>  <span class=\"c1\"># returns True</span>\n</pre>\n</div>\n<div id=\"dpda-copy-self\">\n<h4>DPDA.copy(self)</h4>\n<pre><span class=\"n\">dpda</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>  <span class=\"c1\"># returns deep copy of dpda</span>\n</pre>\n</div>\n</div>\n<div id=\"class-npda-pda\">\n<h3>class NPDA(PDA)</h3>\n<p>The <tt>NPDA</tt> class is a subclass of <tt>PDA</tt> and represents a\nnondeterministic pushdown automaton. It can be found under\n<tt>automata/pda/npda.py</tt>.</p>\n<p>Every NPDA has the following (required) properties:</p>\n<ol>\n<li><tt>states</tt>: a <tt>set</tt> of the NPDA\u2019s valid states, each of which must\nbe represented as a string</li>\n<li><tt>input_symbols</tt>: a <tt>set</tt> of the NPDA\u2019s valid input symbols, each\nof which must also be represented as a string</li>\n<li><tt>stack_symbols</tt>: a <tt>set</tt> of the NPDA\u2019s valid stack symbols</li>\n<li><tt>transitions</tt>: a <tt>dict</tt> consisting of the transitions for each\nstate; see the example below for the exact syntax</li>\n<li><tt>initial_state</tt>: the name of the initial state for this NPDA</li>\n<li><tt>initial_stack_symbol</tt>: the name of the initial symbol on the stack\nfor this NPDA</li>\n<li><tt>final_states</tt>: a <tt>set</tt> of final states for this NPDA</li>\n<li><tt>acceptance_mode</tt>: a string defining whether this NPDA accepts by\n<tt>'final_state'</tt>, <tt>'empty_stack'</tt>, or <tt>'both'</tt>; the default is\n<tt>'both'</tt></li>\n</ol>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.pda.npda</span> <span class=\"kn\">import</span> <span class=\"n\">NPDA</span>\n<span class=\"c1\"># NPDA which matches palindromes consisting of 'a's and 'b's</span>\n<span class=\"c1\"># (accepting by final state)</span>\n<span class=\"c1\"># q0 reads the first half of the word, q1 the other half, q2 accepts.</span>\n<span class=\"c1\"># But we have to guess when to switch.</span>\n<span class=\"n\">npda</span> <span class=\"o\">=</span> <span class=\"n\">NPDA</span><span class=\"p\">(</span>\n    <span class=\"n\">states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'q2'</span><span class=\"p\">},</span>\n    <span class=\"n\">input_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">},</span>\n    <span class=\"n\">stack_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'A'</span><span class=\"p\">,</span> <span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"s1\">'#'</span><span class=\"p\">},</span>\n    <span class=\"n\">transitions</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s1\">'q0'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">''</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"s1\">'#'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'#'</span><span class=\"p\">)},</span>\n            <span class=\"p\">},</span>\n            <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"s1\">'#'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'A'</span><span class=\"p\">,</span> <span class=\"s1\">'#'</span><span class=\"p\">))},</span>\n                <span class=\"s1\">'A'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                    <span class=\"p\">(</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'A'</span><span class=\"p\">,</span> <span class=\"s1\">'A'</span><span class=\"p\">)),</span>\n                    <span class=\"p\">(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">),</span>\n                <span class=\"p\">},</span>\n                <span class=\"s1\">'B'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'A'</span><span class=\"p\">,</span> <span class=\"s1\">'B'</span><span class=\"p\">))},</span>\n            <span class=\"p\">},</span>\n            <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"s1\">'#'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"s1\">'#'</span><span class=\"p\">))},</span>\n                <span class=\"s1\">'A'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"s1\">'A'</span><span class=\"p\">))},</span>\n                <span class=\"s1\">'B'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                    <span class=\"p\">(</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"s1\">'B'</span><span class=\"p\">)),</span>\n                    <span class=\"p\">(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">),</span>\n                <span class=\"p\">},</span>\n            <span class=\"p\">},</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q1'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">''</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'#'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'#'</span><span class=\"p\">)}},</span>\n            <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'A'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">)}},</span>\n            <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'B'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">)}},</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">},</span>\n    <span class=\"n\">initial_state</span><span class=\"o\">=</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span>\n    <span class=\"n\">initial_stack_symbol</span><span class=\"o\">=</span><span class=\"s1\">'#'</span><span class=\"p\">,</span>\n    <span class=\"n\">final_states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q2'</span><span class=\"p\">},</span>\n    <span class=\"n\">acceptance_mode</span><span class=\"o\">=</span><span class=\"s1\">'final_state'</span>\n<span class=\"p\">)</span>\n</pre>\n<div id=\"npda-read-input-self-input-str\">\n<h4>NPDA.read_input(self, input_str)</h4>\n<p>Returns a <tt>set</tt> of <tt>PDAConfiguration</tt>s representing all of the\nNPDA\u2019s configurations. Each of these is basically a tuple containing the\nfinal state the NPDA stopped on, the remaining input (an empty string)\nas well as a <tt>PDAStack</tt> object representing the NPDA\u2019s stack (if the\ninput is accepted).</p>\n<pre><span class=\"n\">npda</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s2\">\"aaaa\"</span><span class=\"p\">)</span> <span class=\"c1\"># returns {PDAConfiguration('q2', '', PDAStack('#',))}</span>\n</pre>\n<pre><span class=\"n\">npda</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'ab'</span><span class=\"p\">)</span>  <span class=\"c1\"># raises RejectionException</span>\n</pre>\n</div>\n<div id=\"npda-read-input-stepwise-self-input-str\">\n<h4>NPDA.read_input_stepwise(self, input_str)</h4>\n<p>Yields <tt>set</tt>s of <tt>PDAConfiguration</tt> object. Each of these is\nbasically a tuple containing the current state, the remaining input and\nthe current stack as a <tt>PDAStack</tt> object, if the input is accepted.</p>\n<pre><span class=\"n\">npda</span><span class=\"o\">.</span><span class=\"n\">read_input_stepwise</span><span class=\"p\">(</span><span class=\"s1\">'aa'</span><span class=\"p\">)</span>\n<span class=\"c1\"># yields:</span>\n<span class=\"c1\"># {PDAConfiguration('q0', 'aa', PDAStack('#',))}</span>\n<span class=\"c1\"># {PDAConfiguration('q0', 'a', PDAStack('#', 'A')), PDAConfiguration('q2', 'aa', PDAStack('#',))}</span>\n<span class=\"c1\"># {PDAConfiguration('q0', '', PDAStack('#', 'A', 'A')), PDAConfiguration('q1', '', PDAStack('#',))}</span>\n<span class=\"c1\"># {PDAConfiguration('q2', '', PDAStack('#',))}</span>\n</pre>\n</div>\n<div id=\"npda-accepts-input-self-input-str\">\n<h4>NPDA.accepts_input(self, input_str)</h4>\n<pre><span class=\"k\">if</span> <span class=\"n\">npda</span><span class=\"o\">.</span><span class=\"n\">accepts_input</span><span class=\"p\">(</span><span class=\"n\">my_input_str</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'accepted'</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'rejected'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"npda-validate-self\">\n<h4>NPDA.validate(self)</h4>\n<pre><span class=\"n\">npda</span><span class=\"o\">.</span><span class=\"n\">validate</span><span class=\"p\">()</span>  <span class=\"c1\"># returns True</span>\n</pre>\n</div>\n<div id=\"npda-copy-self\">\n<h4>NPDA.copy(self)</h4>\n<pre><span class=\"n\">npda</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>  <span class=\"c1\"># returns deep copy of npda</span>\n</pre>\n</div>\n</div>\n<div id=\"class-tm-automaton-metaclass-abcmeta\">\n<h3>class TM(Automaton, metaclass=ABCMeta)</h3>\n<p>The <tt>TM</tt> class is an abstract base class from which all Turing\nmachines inherit. It can be found under <tt>automata/tm/tm.py</tt>.</p>\n</div>\n<div id=\"class-dtm-tm\">\n<h3>class DTM(TM)</h3>\n<p>The <tt>DTM</tt> class is a subclass of <tt>TM</tt> and represents a deterministic\nTuring machine. It can be found under <tt>automata/tm/dtm.py</tt>.</p>\n<p>Every DTM has the following (required) properties:</p>\n<ol>\n<li><tt>states</tt>: a <tt>set</tt> of the DTM\u2019s valid states, each of which must\nbe represented as a string</li>\n<li><tt>input_symbols</tt>: a <tt>set</tt> of the DTM\u2019s valid input symbols\nrepresented as strings</li>\n<li><tt>tape_symbols</tt>: a <tt>set</tt> of the DTM\u2019s valid tape symbols\nrepresented as strings</li>\n<li><tt>transitions</tt>: a <tt>dict</tt> consisting of the transitions for each\nstate; each key is a state name and each value is a <tt>dict</tt> which\nmaps a symbol (the key) to a state (the value)</li>\n<li><tt>initial_state</tt>: the name of the initial state for this DTM</li>\n<li><tt>blank_symbol</tt>: a symbol from <tt>tape_symbols</tt> to be used as the\nblank symbol for this DTM</li>\n<li><tt>final_states</tt>: a <tt>set</tt> of final states for this DTM</li>\n</ol>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.tm.dtm</span> <span class=\"kn\">import</span> <span class=\"n\">DTM</span>\n<span class=\"c1\"># DTM which matches all strings beginning with '0's, and followed by</span>\n<span class=\"c1\"># the same number of '1's</span>\n<span class=\"n\">dtm</span> <span class=\"o\">=</span> <span class=\"n\">DTM</span><span class=\"p\">(</span>\n    <span class=\"n\">states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'q3'</span><span class=\"p\">,</span> <span class=\"s1\">'q4'</span><span class=\"p\">},</span>\n    <span class=\"n\">input_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">},</span>\n    <span class=\"n\">tape_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">,</span> <span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'.'</span><span class=\"p\">},</span>\n    <span class=\"n\">transitions</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s1\">'q0'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">),</span>\n            <span class=\"s1\">'y'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q3'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q1'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">),</span>\n            <span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'L'</span><span class=\"p\">),</span>\n            <span class=\"s1\">'y'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q2'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'L'</span><span class=\"p\">),</span>\n            <span class=\"s1\">'x'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">),</span>\n            <span class=\"s1\">'y'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'L'</span><span class=\"p\">)</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q3'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'y'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q3'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">),</span>\n            <span class=\"s1\">'.'</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"s1\">'q4'</span><span class=\"p\">,</span> <span class=\"s1\">'.'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"n\">initial_state</span><span class=\"o\">=</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span>\n    <span class=\"n\">blank_symbol</span><span class=\"o\">=</span><span class=\"s1\">'.'</span><span class=\"p\">,</span>\n    <span class=\"n\">final_states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q4'</span><span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</pre>\n<p>The direction <tt>N</tt> (for no movement) is also supported.</p>\n<div id=\"dtm-read-input-self-input-str\">\n<h4>DTM.read_input(self, input_str)</h4>\n<p>Returns a <tt>TMConfiguration</tt>. This is basically a tuple containing the\nfinal state the machine stopped on, as well as a <tt>TMTape</tt> object\nrepresenting the DTM\u2019s internal tape (if the input is accepted).</p>\n<pre><span class=\"n\">dtm</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'01'</span><span class=\"p\">)</span>  <span class=\"c1\"># returns TMConfiguration('q4', TMTape('xy..', 3))</span>\n</pre>\n<p>Calling <tt>config.print()</tt> will produce a more readable output:</p>\n<pre><span class=\"n\">dtm</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'01'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">print</span><span class=\"p\">()</span>\n<span class=\"c1\"># q4: xy..</span>\n<span class=\"c1\">#        ^</span>\n</pre>\n<pre><span class=\"n\">dtm</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'011'</span><span class=\"p\">)</span>  <span class=\"c1\"># raises RejectionException</span>\n</pre>\n</div>\n<div id=\"dtm-read-input-stepwise-self-input-str\">\n<h4>DTM.read_input_stepwise(self, input_str)</h4>\n<p>Yields <tt>TMConfiguration</tt>s. Those are basically tuples containing the\ncurrent state and the current tape as a <tt>TMTape</tt> object.</p>\n<pre><span class=\"n\">dtm</span><span class=\"o\">.</span><span class=\"n\">read_input_stepwise</span><span class=\"p\">(</span><span class=\"s1\">'01'</span><span class=\"p\">)</span>\n<span class=\"c1\"># yields:</span>\n<span class=\"c1\"># TMConfiguration('q0', TMTape('01', 0))</span>\n<span class=\"c1\"># TMConfiguration('q1', TMTape('x1', 1))</span>\n<span class=\"c1\"># TMConfiguration('q2', TMTape('xy', 0))</span>\n<span class=\"c1\"># TMConfiguration('q0', TMTape('xy', 1))</span>\n<span class=\"c1\"># TMConfiguration('q3', TMTape('xy.', 2))</span>\n<span class=\"c1\"># TMConfiguration('q4', TMTape('xy..', 3))</span>\n</pre>\n</div>\n<div id=\"dtm-accepts-input-self-input-str\">\n<h4>DTM.accepts_input(self, input_str)</h4>\n<pre><span class=\"k\">if</span> <span class=\"n\">dtm</span><span class=\"o\">.</span><span class=\"n\">accepts_input</span><span class=\"p\">(</span><span class=\"n\">my_input_str</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'accepted'</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'rejected'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"dtm-validate-self\">\n<h4>DTM.validate(self)</h4>\n<pre><span class=\"n\">dtm</span><span class=\"o\">.</span><span class=\"n\">validate</span><span class=\"p\">()</span>  <span class=\"c1\"># returns True</span>\n</pre>\n</div>\n<div id=\"dtm-copy-self\">\n<h4>DTM.copy(self)</h4>\n<pre><span class=\"n\">dtm</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>  <span class=\"c1\"># returns deep copy of dtm</span>\n</pre>\n</div>\n</div>\n<div id=\"class-ntm-tm\">\n<h3>class NTM(TM)</h3>\n<p>The <tt>NTM</tt> class is a subclass of <tt>TM</tt> and represents a\nnondeterministic Turing machine. It can be found under\n<tt>automata/tm/ntm.py</tt>.</p>\n<p>Every NTM has the following (required) properties:</p>\n<ol>\n<li><tt>states</tt>: a <tt>set</tt> of the NTM\u2019s valid states, each of which must\nbe represented as a string</li>\n<li><tt>input_symbols</tt>: a <tt>set</tt> of the NTM\u2019s valid input symbols\nrepresented as strings</li>\n<li><tt>tape_symbols</tt>: a <tt>set</tt> of the NTM\u2019s valid tape symbols\nrepresented as strings</li>\n<li><tt>transitions</tt>: a <tt>dict</tt> consisting of the transitions for each\nstate; each key is a state name and each value is a <tt>dict</tt> which\nmaps a symbol (the key) to a set of states (the values)</li>\n<li><tt>initial_state</tt>: the name of the initial state for this NTM</li>\n<li><tt>blank_symbol</tt>: a symbol from <tt>tape_symbols</tt> to be used as the\nblank symbol for this NTM</li>\n<li><tt>final_states</tt>: a <tt>set</tt> of final states for this NTM</li>\n</ol>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automata.tm.ntm</span> <span class=\"kn\">import</span> <span class=\"n\">NTM</span>\n<span class=\"c1\"># NTM which matches all strings beginning with '0's, and followed by</span>\n<span class=\"c1\"># the same number of '1's</span>\n<span class=\"c1\"># Note that the nondeterminism is not really used here.</span>\n<span class=\"n\">ntm</span> <span class=\"o\">=</span> <span class=\"n\">NTM</span><span class=\"p\">(</span>\n    <span class=\"n\">states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'q3'</span><span class=\"p\">,</span> <span class=\"s1\">'q4'</span><span class=\"p\">},</span>\n    <span class=\"n\">input_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">},</span>\n    <span class=\"n\">tape_symbols</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'1'</span><span class=\"p\">,</span> <span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'.'</span><span class=\"p\">},</span>\n    <span class=\"n\">transitions</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s1\">'q0'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)},</span>\n            <span class=\"s1\">'y'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q3'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)},</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q1'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)},</span>\n            <span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'L'</span><span class=\"p\">)},</span>\n            <span class=\"s1\">'y'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q1'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)},</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q2'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'0'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'L'</span><span class=\"p\">)},</span>\n            <span class=\"s1\">'x'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span> <span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)},</span>\n            <span class=\"s1\">'y'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q2'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'L'</span><span class=\"p\">)},</span>\n        <span class=\"p\">},</span>\n        <span class=\"s1\">'q3'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'y'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q3'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)},</span>\n            <span class=\"s1\">'.'</span><span class=\"p\">:</span> <span class=\"p\">{(</span><span class=\"s1\">'q4'</span><span class=\"p\">,</span> <span class=\"s1\">'.'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">)},</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"n\">initial_state</span><span class=\"o\">=</span><span class=\"s1\">'q0'</span><span class=\"p\">,</span>\n    <span class=\"n\">blank_symbol</span><span class=\"o\">=</span><span class=\"s1\">'.'</span><span class=\"p\">,</span>\n    <span class=\"n\">final_states</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'q4'</span><span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</pre>\n<p>The direction <tt>N</tt> (for no movement) is also supported.</p>\n<div id=\"ntm-read-input-self-input-str\">\n<h4>NTM.read_input(self, input_str)</h4>\n<p>Returns a set of <tt>TMConfiguration</tt>s. These are basically tuples\ncontaining the final state the machine stopped on, as well as a\n<tt>TMTape</tt> object representing the DTM\u2019s internal tape (if the input is\naccepted).</p>\n<pre><span class=\"n\">ntm</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'01'</span><span class=\"p\">)</span>  <span class=\"c1\"># returns {TMConfiguration('q4', TMTape('xy..', 3))}</span>\n</pre>\n<p>Calling <tt>config.print()</tt> will produce a more readable output:</p>\n<pre><span class=\"n\">ntm</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'01'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">print</span><span class=\"p\">()</span>\n<span class=\"c1\"># q4: xy..</span>\n<span class=\"c1\">#        ^</span>\n</pre>\n<pre><span class=\"n\">ntm</span><span class=\"o\">.</span><span class=\"n\">read_input</span><span class=\"p\">(</span><span class=\"s1\">'011'</span><span class=\"p\">)</span>  <span class=\"c1\"># raises RejectionException</span>\n</pre>\n</div>\n<div id=\"ntm-read-input-stepwise-self-input-str\">\n<h4>NTM.read_input_stepwise(self, input_str)</h4>\n<p>Yields sets of <tt>TMConfiguration</tt>s. Those are basically tuples\ncontaining the current state and the current tape as a <tt>TMTape</tt>\nobject.</p>\n<pre><span class=\"n\">ntm</span><span class=\"o\">.</span><span class=\"n\">read_input_stepwise</span><span class=\"p\">(</span><span class=\"s1\">'01'</span><span class=\"p\">)</span>\n<span class=\"c1\"># yields:</span>\n<span class=\"c1\"># {TMConfiguration('q0', TMTape('01', 0))}</span>\n<span class=\"c1\"># {TMConfiguration('q1', TMTape('x1', 1))}</span>\n<span class=\"c1\"># {TMConfiguration('q2', TMTape('xy', 0))}</span>\n<span class=\"c1\"># {TMConfiguration('q0', TMTape('xy', 1))}</span>\n<span class=\"c1\"># {TMConfiguration('q3', TMTape('xy.', 2))}</span>\n<span class=\"c1\"># {TMConfiguration('q4', TMTape('xy..', 3))}</span>\n</pre>\n</div>\n<div id=\"ntm-accepts-input-self-input-str\">\n<h4>NTM.accepts_input(self, input_str)</h4>\n<pre><span class=\"k\">if</span> <span class=\"n\">ntm</span><span class=\"o\">.</span><span class=\"n\">accepts_input</span><span class=\"p\">(</span><span class=\"n\">my_input_str</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'accepted'</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'rejected'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"ntm-validate-self\">\n<h4>NTM.validate(self)</h4>\n<pre><span class=\"n\">ntm</span><span class=\"o\">.</span><span class=\"n\">validate</span><span class=\"p\">()</span>  <span class=\"c1\"># returns True</span>\n</pre>\n</div>\n<div id=\"ntm-copy-self\">\n<h4>NTM.copy(self)</h4>\n<pre><span class=\"n\">ntm</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>  <span class=\"c1\"># returns deep copy of ntm</span>\n</pre>\n</div>\n</div>\n<div id=\"base-exception-classes\">\n<h3>Base exception classes</h3>\n<p>The library also includes a number of exception classes to ensure that\nerrors never pass silently (unless explicitly silenced). See\n<tt>automata/base/exceptions.py</tt> for these class definitions.</p>\n<p>To reference these exceptions (so as to catch them in a <tt><span class=\"pre\">try..except</span></tt>\nblock or whatnot), simply import <tt>automata.base.exceptions</tt> however\nyou\u2019d like:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">automata.base.exceptions</span> <span class=\"k\">as</span> <span class=\"nn\">exceptions</span>\n</pre>\n<div id=\"class-automatonexception\">\n<h4>class AutomatonException</h4>\n<p>A base class from which all other automata exceptions inherit (including\nfinite automata and Turing machines).</p>\n</div>\n<div id=\"class-invalidstateerror\">\n<h4>class InvalidStateError</h4>\n<p>Raised if a state is not a valid state for this automaton.</p>\n</div>\n<div id=\"class-invalidsymbolerror\">\n<h4>class InvalidSymbolError</h4>\n<p>Raised if a symbol is not a valid symbol for this automaton.</p>\n</div>\n<div id=\"class-missingstateerror\">\n<h4>class MissingStateError</h4>\n<p>Raised if a state is missing from the automaton definition.</p>\n</div>\n<div id=\"class-missingsymbolerror\">\n<h4>class MissingSymbolError</h4>\n<p>Raised if a symbol is missing from the automaton definition.</p>\n</div>\n<div id=\"class-initialstateerror\">\n<h4>class InitialStateError</h4>\n<p>Raised if the initial state fails to meet some required condition for\nthis type of automaton.</p>\n</div>\n<div id=\"class-finalstateerror\">\n<h4>class FinalStateError</h4>\n<p>Raised if a final state fails to meet some required condition for this\ntype of automaton.</p>\n</div>\n<div id=\"class-rejectionexception\">\n<h4>class RejectionException</h4>\n<p>Raised if the automaton stopped on a non-final state after validating\ninput.</p>\n</div>\n</div>\n<div id=\"turing-machine-exception-classes\">\n<h3>Turing machine exception classes</h3>\n<p>The <tt>automata.tm</tt> package also includes a module for exceptions\nspecific to Turing machines. You can reference these exception classes\nlike so:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">automata.tm.exceptions</span> <span class=\"k\">as</span> <span class=\"nn\">tm_exceptions</span>\n</pre>\n<div id=\"class-tmexception\">\n<h4>class TMException</h4>\n<p>A base class from which all other Turing machine exceptions inherit.</p>\n</div>\n<div id=\"class-invaliddirectionerror\">\n<h4>class InvalidDirectionError</h4>\n<p>Raised if a direction specified in this machine\u2019s transition map is not\na valid direction.</p>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4798337, "releases": {"1.0.0": [], "1.0.0.post1": [{"comment_text": "", "digests": {"md5": "d51bf7a48e34593b22b38106a90f1770", "sha256": "459641308b939a2d250859e16195372174c1c54f9c639f0c4cc01a08a4285964"}, "downloads": -1, "filename": "automata-lib-1.0.0.post1.tar.gz", "has_sig": false, "md5_digest": "d51bf7a48e34593b22b38106a90f1770", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7191, "upload_time": "2016-07-07T17:19:40", "upload_time_iso_8601": "2016-07-07T17:19:40.451379Z", "url": "https://files.pythonhosted.org/packages/a5/1b/13008c82866fac6b18a77783aa8f0017634280c1aa2bc78a8f0aa2b2a13c/automata-lib-1.0.0.post1.tar.gz", "yanked": false}], "1.0.0.post2": [{"comment_text": "", "digests": {"md5": "a616a1077b0b88ed6c6ebd1a7aa003a9", "sha256": "02584e14b4a32cac43059123d8aa81cc99289f658d79804aa620c8e9cfce8a03"}, "downloads": -1, "filename": "automata-lib-1.0.0.post2.tar.gz", "has_sig": false, "md5_digest": "a616a1077b0b88ed6c6ebd1a7aa003a9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11662, "upload_time": "2016-07-07T20:18:51", "upload_time_iso_8601": "2016-07-07T20:18:51.522830Z", "url": "https://files.pythonhosted.org/packages/a2/d1/4a5910ac8b3e22711551c7f1f54c96ac75b2c9cbc77253b9578a9e8b6c08/automata-lib-1.0.0.post2.tar.gz", "yanked": false}], "1.0.0.post3": [{"comment_text": "", "digests": {"md5": "ce622a90e2c39c106c7a24a3e5a6d809", "sha256": "b96f3d1bdf6c0ec75a423649845199fdd221a4cfb840cdb83d0e5867a2de1d05"}, "downloads": -1, "filename": "automata-lib-1.0.0.post3.tar.gz", "has_sig": false, "md5_digest": "ce622a90e2c39c106c7a24a3e5a6d809", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11644, "upload_time": "2016-07-09T04:14:17", "upload_time_iso_8601": "2016-07-09T04:14:17.928285Z", "url": "https://files.pythonhosted.org/packages/70/45/72b4ed5662fec40c38f5f37827fac0e1d6968beea1331eb9a8be7b9d64d5/automata-lib-1.0.0.post3.tar.gz", "yanked": false}], "1.0.0.post4": [{"comment_text": "", "digests": {"md5": "33e4557f1662dcd938579551369bc0dd", "sha256": "d3851f9a6437a596af87f6353306d1ce7a6f75a79eacf7ef3909a225b0021984"}, "downloads": -1, "filename": "automata-lib-1.0.0.post4.tar.gz", "has_sig": false, "md5_digest": "33e4557f1662dcd938579551369bc0dd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11634, "upload_time": "2017-05-02T04:15:21", "upload_time_iso_8601": "2017-05-02T04:15:21.745267Z", "url": "https://files.pythonhosted.org/packages/85/a6/b33bb665852d62931130be77afd22f11b00b1e5e03faa2435a2367feeb16/automata-lib-1.0.0.post4.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "539535155b2055293d4b19c4cdbc5322", "sha256": "b46f612cf6470095cb6856747bbe3f97904ac34b9e9ec94e1f6bf1d76d7b24a6"}, "downloads": -1, "filename": "automata-lib-2.0.0.tar.gz", "has_sig": false, "md5_digest": "539535155b2055293d4b19c4cdbc5322", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10734, "upload_time": "2018-04-30T03:05:14", "upload_time_iso_8601": "2018-04-30T03:05:14.748601Z", "url": "https://files.pythonhosted.org/packages/f4/f0/e8258ca65413c1c665a03076309bcb4a4192ba60e713dd9107b3af9cf10a/automata-lib-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "1186105bf7b496b037946ddfbbe6d9c9", "sha256": "77c9775726e1e1ec8c20c5362f4be3d0baa8a148590923cd9630a1b5efcc9c27"}, "downloads": -1, "filename": "automata-lib-2.0.1.tar.gz", "has_sig": false, "md5_digest": "1186105bf7b496b037946ddfbbe6d9c9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10877, "upload_time": "2018-05-05T22:35:57", "upload_time_iso_8601": "2018-05-05T22:35:57.119121Z", "url": "https://files.pythonhosted.org/packages/96/35/858f76ca86800a56d9965e68b320232fb6744df3da3814eefafbdb8691b3/automata-lib-2.0.1.tar.gz", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "ad6294e18eca2e1099c9ff86f6be8fec", "sha256": "86e1bc896aa50189f23f1d851a6a8f028843b787a4a04e6912700843ca29b73e"}, "downloads": -1, "filename": "automata-lib-2.1.0.tar.gz", "has_sig": false, "md5_digest": "ad6294e18eca2e1099c9ff86f6be8fec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18305, "upload_time": "2018-05-29T02:46:38", "upload_time_iso_8601": "2018-05-29T02:46:38.126618Z", "url": "https://files.pythonhosted.org/packages/88/34/cd50f6cfcf2459a6cca518116a110caf08074e8a96a4808b48ef42836f7d/automata-lib-2.1.0.tar.gz", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "d1a8ca7abf97fe79eb6c9957f94a6a79", "sha256": "fdf62f0184ebe959b1f4a782d47852a86eccead8a9b45258bd86eecd161ecc17"}, "downloads": -1, "filename": "automata-lib-3.0.0.tar.gz", "has_sig": false, "md5_digest": "d1a8ca7abf97fe79eb6c9957f94a6a79", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22791, "upload_time": "2019-01-21T04:22:02", "upload_time_iso_8601": "2019-01-21T04:22:02.261845Z", "url": "https://files.pythonhosted.org/packages/4e/25/8bbe7fcabd0da99db9deb8c3378151aa649903dcdfa8bf9ce3219f25d15f/automata-lib-3.0.0.tar.gz", "yanked": false}], "3.1.0": [{"comment_text": "", "digests": {"md5": "973ab93a55de56320334e9f3bf056664", "sha256": "c00fd117f7adefa7db65ddd2e6361a5f8e7fe55950e0bfaf66d5ada148e8ed85"}, "downloads": -1, "filename": "automata-lib-3.1.0.tar.gz", "has_sig": false, "md5_digest": "973ab93a55de56320334e9f3bf056664", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23200, "upload_time": "2019-02-09T03:44:27", "upload_time_iso_8601": "2019-02-09T03:44:27.289930Z", "url": "https://files.pythonhosted.org/packages/25/46/68e7c2a91d02d26969e42ba752763a5520c842f865ea5151ee5d5ce1deb8/automata-lib-3.1.0.tar.gz", "yanked": false}], "3.1.0.post1": [{"comment_text": "", "digests": {"md5": "db0048fbe6e0749d2dc3832e6053a14d", "sha256": "b5673e92f88b16a9f0ea99b4c7e1048380077997480383bdd7db1346e4bd72f3"}, "downloads": -1, "filename": "automata-lib-3.1.0.post1.tar.gz", "has_sig": false, "md5_digest": "db0048fbe6e0749d2dc3832e6053a14d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23130, "upload_time": "2019-02-09T03:54:21", "upload_time_iso_8601": "2019-02-09T03:54:21.323279Z", "url": "https://files.pythonhosted.org/packages/2e/7e/6dcd9d009fa9ffb7fa36f934b04684d7e343c544d986255a8d2f5cd00b1a/automata-lib-3.1.0.post1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "db0048fbe6e0749d2dc3832e6053a14d", "sha256": "b5673e92f88b16a9f0ea99b4c7e1048380077997480383bdd7db1346e4bd72f3"}, "downloads": -1, "filename": "automata-lib-3.1.0.post1.tar.gz", "has_sig": false, "md5_digest": "db0048fbe6e0749d2dc3832e6053a14d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23130, "upload_time": "2019-02-09T03:54:21", "upload_time_iso_8601": "2019-02-09T03:54:21.323279Z", "url": "https://files.pythonhosted.org/packages/2e/7e/6dcd9d009fa9ffb7fa36f934b04684d7e343c544d986255a8d2f5cd00b1a/automata-lib-3.1.0.post1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:14 2020"}