{"info": {"author": "Robert Lechte", "author_email": "robert.lechte@dpc.vic.gov.au", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7"], "description": "# ratemate\n\nThere's a bunch of python rate limiting modules out there, but they all seem to suffer from similar problems:\n\n- Weird APIs, usually inflexible decorators that you need to wrap your calls in\n- Lack of `multiprocessing` support (eg, two processes will be unaware of each other, and thus double the intended rate)\n- Unnecessary coupling to other libraries\n\n`ratemate`, meanwhile, gives you a simple `RateLimit` object that avoids all these problems.\n\nIt works like this. Declare a `RateLimit` as follows:\n\n    from ratemate import RateLimit\n\n    rate_limit = RateLimit(max_count=2, per=5)  # 2 requests per 5 seconds\n\nThen call `.wait()` appropriately when you need to limit the rate.\n\nFor instance, here's an example when creating multiple threads with `concurrent.futures`. First the original rate-unlimited code:\n\n```python\n\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n\ndef task(n):\n    print(f\"  task {n} called\")\n    return n\n\nfutures = []\n\nwith ThreadPoolExecutor() as executor:\n    for i in range(20):\n        future = executor.submit(task, i)\n        futures.append(future)\n\n    for completed in as_completed(futures):\n        result = completed.result()\n        print('completed')\n```\n\nAdd rate-limiting simply by adding a wait at the appropriate time, either at task creation:\n\n```python\nfor i in range(20):\n    rate_limit.wait()  # wait before creating the task\n    future = executor.submit(task, i)\n    futures.append(future)\n```\n\nOr at the start of the task itself:\n\n```python\ndef task(n):\n    waited_time = rate_limit.wait()  # wait at start of task\n    print(f\"  task {n}: waited for {waited_time} secs\")\n    return n\n```\n\nBecause `ratemate` uses multi-process-aware shared memory to track its state, you can also use `ProcessPoolExecutor` and everything will still work nicely.\n\n\n## Greedy mode\n\nThe default (aka non-greedy aka patient) rate limiting mode spaces out calls evenly. First instance, max_count=10 and per=60 will result in one call every 6 seconds.\n\nYou may instead wish for calls to happen as fast as possible, only slowing down if the limit would be exceeded. Enable this with greedy=True, eg:\n\n```\nrate_limit = RateLimit(max_count=20, per=60, greedy=True)\n```\n\n## Further enhancements\n\nRate limit coordination between truly independent processes (not just subprocesses), possibly using Python 3.8's new shared memory or Redis or PostgreSQL or whatever.\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "Robert Lechte", "maintainer_email": "robert.lechte@dpc.vic.gov.au", "name": "ratemate", "package_url": "https://pypi.org/project/ratemate/", "platform": "", "project_url": "https://pypi.org/project/ratemate/", "project_urls": null, "release_url": "https://pypi.org/project/ratemate/0.1.0/", "requires_dist": null, "requires_python": ">=3.7", "summary": "A python rate limiter module with multi-process support and a simple, intuitive API", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>ratemate</h1>\n<p>There's a bunch of python rate limiting modules out there, but they all seem to suffer from similar problems:</p>\n<ul>\n<li>Weird APIs, usually inflexible decorators that you need to wrap your calls in</li>\n<li>Lack of <code>multiprocessing</code> support (eg, two processes will be unaware of each other, and thus double the intended rate)</li>\n<li>Unnecessary coupling to other libraries</li>\n</ul>\n<p><code>ratemate</code>, meanwhile, gives you a simple <code>RateLimit</code> object that avoids all these problems.</p>\n<p>It works like this. Declare a <code>RateLimit</code> as follows:</p>\n<pre><code>from ratemate import RateLimit\n\nrate_limit = RateLimit(max_count=2, per=5)  # 2 requests per 5 seconds\n</code></pre>\n<p>Then call <code>.wait()</code> appropriately when you need to limit the rate.</p>\n<p>For instance, here's an example when creating multiple threads with <code>concurrent.futures</code>. First the original rate-unlimited code:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">concurrent.futures</span> <span class=\"kn\">import</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"p\">,</span> <span class=\"n\">as_completed</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">task</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"  task </span><span class=\"si\">{</span><span class=\"n\">n</span><span class=\"si\">}</span><span class=\"s2\"> called\"</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">n</span>\n\n<span class=\"n\">futures</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n<span class=\"k\">with</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">executor</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">):</span>\n        <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n        <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">)</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">completed</span> <span class=\"ow\">in</span> <span class=\"n\">as_completed</span><span class=\"p\">(</span><span class=\"n\">futures</span><span class=\"p\">):</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">completed</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'completed'</span><span class=\"p\">)</span>\n</pre>\n<p>Add rate-limiting simply by adding a wait at the appropriate time, either at task creation:</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">):</span>\n    <span class=\"n\">rate_limit</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>  <span class=\"c1\"># wait before creating the task</span>\n    <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n    <span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">)</span>\n</pre>\n<p>Or at the start of the task itself:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">task</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"n\">waited_time</span> <span class=\"o\">=</span> <span class=\"n\">rate_limit</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>  <span class=\"c1\"># wait at start of task</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"  task </span><span class=\"si\">{</span><span class=\"n\">n</span><span class=\"si\">}</span><span class=\"s2\">: waited for </span><span class=\"si\">{</span><span class=\"n\">waited_time</span><span class=\"si\">}</span><span class=\"s2\"> secs\"</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">n</span>\n</pre>\n<p>Because <code>ratemate</code> uses multi-process-aware shared memory to track its state, you can also use <code>ProcessPoolExecutor</code> and everything will still work nicely.</p>\n<h2>Greedy mode</h2>\n<p>The default (aka non-greedy aka patient) rate limiting mode spaces out calls evenly. First instance, max_count=10 and per=60 will result in one call every 6 seconds.</p>\n<p>You may instead wish for calls to happen as fast as possible, only slowing down if the limit would be exceeded. Enable this with greedy=True, eg:</p>\n<pre><code>rate_limit = RateLimit(max_count=20, per=60, greedy=True)\n</code></pre>\n<h2>Further enhancements</h2>\n<p>Rate limit coordination between truly independent processes (not just subprocesses), possibly using Python 3.8's new shared memory or Redis or PostgreSQL or whatever.</p>\n\n          </div>"}, "last_serial": 5958054, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "d1a526379dce5686de960a5e939eebd9", "sha256": "5660bfced1a39682fa98103ed4103d46c237e4064256dfde2f29a9e58549d59e"}, "downloads": -1, "filename": "ratemate-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d1a526379dce5686de960a5e939eebd9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4143, "upload_time": "2019-10-09T03:42:39", "upload_time_iso_8601": "2019-10-09T03:42:39.303311Z", "url": "https://files.pythonhosted.org/packages/32/46/71693a0bf8eb4aa329d60e3c16c0add85872b8cdb853475a58134d61ff19/ratemate-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3c2621d544d876e2ad49c037279c4afe", "sha256": "681e36441152f100480ec5e3223ea1a18335094a55abe36e952fa067bfd63352"}, "downloads": -1, "filename": "ratemate-0.1.0.tar.gz", "has_sig": false, "md5_digest": "3c2621d544d876e2ad49c037279c4afe", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4097, "upload_time": "2019-10-09T03:42:42", "upload_time_iso_8601": "2019-10-09T03:42:42.028241Z", "url": "https://files.pythonhosted.org/packages/f1/a6/a639f4ba6432c7b56a0f0bf7528f20ef5e73ac4706475ba18f798d353fa2/ratemate-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d1a526379dce5686de960a5e939eebd9", "sha256": "5660bfced1a39682fa98103ed4103d46c237e4064256dfde2f29a9e58549d59e"}, "downloads": -1, "filename": "ratemate-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d1a526379dce5686de960a5e939eebd9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 4143, "upload_time": "2019-10-09T03:42:39", "upload_time_iso_8601": "2019-10-09T03:42:39.303311Z", "url": "https://files.pythonhosted.org/packages/32/46/71693a0bf8eb4aa329d60e3c16c0add85872b8cdb853475a58134d61ff19/ratemate-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3c2621d544d876e2ad49c037279c4afe", "sha256": "681e36441152f100480ec5e3223ea1a18335094a55abe36e952fa067bfd63352"}, "downloads": -1, "filename": "ratemate-0.1.0.tar.gz", "has_sig": false, "md5_digest": "3c2621d544d876e2ad49c037279c4afe", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 4097, "upload_time": "2019-10-09T03:42:42", "upload_time_iso_8601": "2019-10-09T03:42:42.028241Z", "url": "https://files.pythonhosted.org/packages/f1/a6/a639f4ba6432c7b56a0f0bf7528f20ef5e73ac4706475ba18f798d353fa2/ratemate-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:06 2020"}