{"info": {"author": "Outernet Inc", "author_email": "apps@outernet.is", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Topic :: Software Development :: Libraries :: Application Frameworks"], "description": "====\nconz\n====\n\nThis module contains a lightweight library for creating command line programs,\nconz.\n\nconz has following features:\n\n- Simplifies working with pipes\n- Provides methods for handling typical interactive scenarios\n- Supports output colorization\n- Provides tools for working with long-running tasks\n- Controls output in interactive and non-interactive scenarios\n- Manages signals (SIGINT and SIGPIPE)\n\n.. contents::\n\nInstalling\n==========\n\nYou can install conz from PyPI using pip or easy_install::\n\n    pip install conz\n\n    easy_install conz\n\nQuick tour\n==========\n\nA quick tour example can be found in ``examples/quicktour.py``::\n\n    import conz\n\n    someval = True\n\n    cn = conz.Console(verbose=True)\n\n    cn.pstd('This goes to STDOUT')\n    cn.perr('This goes to STDERR')\n    cn.pverr(someval, 'This message is related to somevar')\n\n    cn.pstd(cn.color.green('This message is green'))\n\n    with cn.progress('Some long operation'):\n        import time\n        time.sleep(2)\n\n    data = cn.read('Type something in:')\n    cn.pstd('You typed in {}'.format(cn.color.yellow(data, style='italic')))\n\nFormatting conventions\n======================\n\nBecause this library deals with terminal output a lot, we have to somehow tell\nwhen something is terminal output and when it is code. Because of this, we use\nlines to delimit console output. For example::\n\n    ----------------------------------------------\n    I'm a sample output\n    ----------------------------------------------\n\nWhen output is to the STDERR, 'E' will be shown in the right corner.::\n \n    ---------------------------------------------E\n    I'm a sample error\n    ----------------------------------------------\n\nWhen user enters data, the Entered data will be followed by ``<Enter>`` and the\nright corner will include the 'I' character (for 'interactive session')::\n\n    ---------------------------------------------I\n    Prompt: some data<Enter>\n    ----------------------------------------------\n\nWhen value is returned from user input, the value is printed right below the\noutput preceeded by ``==>``::\n\n    ---------------------------------------------I\n    Prompt: some data<Enter>\n    ----------------------------------------------\n    ==> 'some data'\n\nUsage\n=====\n\nThe ``conz`` package includes a class ``Console`` which is the only class you\nwill even need to work with. Simply import and instantiate it at the top of\nyour program. ::\n\n    import conz\n    cn = conz.Console()\n\nWorking with output\n-------------------\n\nThe ``Console()`` class is, for the most part, a wrapper around the ``print()``\nfunction (not print statement, so not compatible with versions of Python that\ndo not support this). It controls how ``print()`` is invoked and takes care of\nsome of the edge cases where it may malfunction.\n\nThe ``print()`` method on a ``Console`` object is a very simple wrapper around\nPython's ``print()`` whic does nothing except pass it's positional and keywrod\narguments to the ``print()`` function. We will never use it directly, though,\nas there are shortcuts for doing specific things with ``print()``.\n\nTo output to STDOUT, we use the ``pstd()`` method. It takes the same arguments\nas ``print()`` function, with the exception of ``file`` keyword argument which\nis set by this method and cannot be overridden. ::\n\n    cn.pstd('This always goes to STDOUT', end='...')\n    ----------------------------------------------\n    This always goes to STDOUT\n    ----------------------------------------------\n\nTo output to STDERR, we use the ``perr()`` method. As with ``pstd()``, it\noverrides the ``file`` argument for us. ::\n\n    cn.perr('Mayday, mayday!')\n    ---------------------------------------------E\n    Mayday, mayday!\n    ----------------------------------------------\n\nThe main difference between regular ``print()`` and ``pstd()``/``perr()``\nmethods is that the latter will flush the STDOUT/STDERR after writing to it.\nThis can prvent weird issues in some edge cases.\n\nThere is a variant of ``perr()`` which prints a more structured message to\nSTDERR. The ``pverr()`` method takes a value and a message, and prints then in\n``VALUE: Message`` format. ::\n\n    path = '/foo/bar/baz.txt'\n    cn.verr(path, 'not found')\n    ---------------------------------------------E\n    /foo/bar/baz.txt: not found\n    ----------------------------------------------\n\nA variant of ``pstd()`` is ``pverb()``. It is exactly the same as ``pstd()``,\nexcept that it only outputs when ``verbose`` flag on the ``Console`` object is\n``True``. This is useful for programs that need to differentiate between\ninteractive and non-interactive use (e.g., using in pipe vs invoking directly)\nor wish to have a ``--verbose`` switch, etc. ::\n\n    cn.verbose = True\n    cn.pverb(\"I'm a talkative program\")\n    ----------------------------------------------\n    I'm a talkative program\n    ----------------------------------------------\n\n    cn.verbose = False\n    cn.pverb(\"I'm a talkative program\")\n    ----------------------------------------------\n\n    ----------------------------------------------\n\nThe ``verbose`` flag can be set either as an argument during instantiation, or\nsimply by setting the attribute as in the previous example.\n\nThe ``Console`` object also provides a ``outterm`` property which is ``False``\nwhen program is outputting to a pipe rather than the terminal::\n\n    if cn.outterm:\n        # give full output to the user\n    else:\n        # give a short output that can be parsed by a machine, etc\n\nColorizing\n----------\n\nBefore we start, note that this implementation is **not cross-platform**. If\nyou need something with a bit more punch, you should look at colorama_.\n\nTo colorize the output, both the ``conz`` module and ``Console`` class have a \n``color`` attribute, which provides methods for output colorization. Each piece\nof text can have the following attributes:\n\n- foreground color\n- style\n- background color\n\nForeground and background colors can be:\n\n- black\n- red\n- green\n- yellow\n- blue\n- purple (magenta)\n- cyan\n- white\n\nStyles can be:\n\n- bold\n- italic\n- underline\n- blink\n- reverse (inverts foreground and background colors)\n\nEach of these colors have a method on the ``color`` attribute. Each color\nmethod takes ``style`` and ``bg`` keyword arguments which set the style and\nbackground color respectively. The ``color()`` method can be used to specify\ncolors dynamically. Here are some examples::\n\n    cn.color.red('This is red text')\n    cn.color.color('This is red text', color='red')\n    cn.color.blue('This is blue underlined text', style='underline')\n    cn.color.color('This is green on yellow', color='green', bg='yellow')\n\nYou can find an example script in ``examples/colors.py`` which prings all\npossible combinations of various colors, styles, and backgrounds.\n\nWorking with input\n------------------\n\nThere are two types of input you can work with: interactive user input, and \npipes.\n\nTo read the user input, use ``read()`` method. This method takes two optional \narguments. One is the ``prompt`` argument, which we use to set the prompt. It\nis an empty string by default. The other argument is a data-cleaning function.\nWhen you pass the ``clean`` argument, user input is passed through the function\nbefore it is retuned. For example::\n\n    cn.read('Exit? [y/N] ', clean=lambda x: x.lower()[:1] == 'y')\n    ---------------------------------------------I\n    Exit? [y/N] y<Enter>\n    ----------------------------------------------\n    ==> True\n\nNote that this method uses ``raw_input()`` on Python 2.7.x and ``input()`` on\nPython 3.x.\n\nTo work with pipes, we use the ``readpipe()`` method. This method reads from\nthe STDIN pipe one line at a time and returns an iterator that allows us to\niterate over the lines. ::\n\n    for l in cn.readpipe():\n        l = l.strip()\n        cn.pstd('Received: {}'.format())\n\nNote that line-feed characters are not stripped from the output so it is up to\nus to strip it away.\n\nWhen working with a large number of lines coming down the pipe, we may\nsometimes need to work in batches, rather than one line at a time. The\n``chunk`` argument can be set to an integer value that specifies the number of\nlines we want buffered before they are returned to us. When using chunks, the\nlines are returned as a list of strings, rather than strings. The following\nexample will return pipe input in groups of 500::\n\n    for lines in cn.readpipe(500):\n        # do something with 500 lines\n\nIf we need to know whether input will come from a pipe or not, we can use the\n``interm`` property. ::\n\n    if cn.interm:\n        # possibly interactive version\n    else:\n        # we are on the receiving end of a pipe\n\nAdvanced interactive input\n--------------------------\n\nSo far we have looked at simpe user input. However in most cases, input is not\nthe only thing we want. We normally also need to show notes, validate the\ninput, construct menus, etc. The ``Console`` class provides three methods that\nare useful for different scenarios.\n\nYou will find examples of code discussed here in ``examples/user_input.py`` and\n``examples/menu.py``.\n\nRVPL\n~~~~\n\nRVPL (pead validate print loop) is a loop in which some data is read from the\nuser, validated, and error message printed. This loop continues as long as data\nis invalid. The ``rvpl()`` method is used to start such a loop.\n\nAt bare minimum, ``rvpl()`` is called with a prompt that should be shown to the\nuser. ::\n\n    cn.rvpl('Please enter your name:')\n    ---------------------------------------------I\n    Please enter your name: My name<enter>\n    ----------------------------------------------\n    ==> 'My name'\n\nLike ``read()``, ``rvpl()`` also takes a ``clean`` argument, which is used to\ncontrol how the value is cleaned. In addition, it takes ``validator`` argument,\nwhich is a function that validates the cleaned data. The default validator\nsimply makes sure the input is not an empty string.\n\nFor invalid input, error message is displayed::\n\n    cn.rvpl('Please enter your name:')\n    ---------------------------------------------I\n    Please enter your name: <Enter>\n    Entered value is invalid\n    Please enter your name: Mike<Enter>\n    ----------------------------------------------\n    ==> 'Mike'\n\nError message can be customized using the ``error`` argument. If ``error``\nargument is is a callable, it will be called with entered value and it must \nreturn the message to be shown. ::\n\n    valid_input = ('a', 'b', 'c')\n    error = lambda x: '{} is not one of the {}'.format(\n        x, ', '.join(valid_input))\n    validator = lambda x: x in valid_input\n    cn.rvpl('Type one of the first 3 characters of English alphabet:')\n    ---------------------------------------------I\n    Type one of the first 3 characters of English alphabet: e<Enter>\n    e is not one of the a, b, c\n    Type one of the first 3 characters of English alphabet: b<Enter>\n    ----------------------------------------------\n    ==> 'b'\n\nAn intro message can be passed which is shown above the prompt. Unlinke the\nprompt itself, intro message is not repeated in the loop. ::\n\n    cn.rvpl('>', intro='Please enter your name:')\n    ---------------------------------------------I\n    Please enter your name: \n    > <Enter>\n    Entered value is invalid\n    > Mike<Enter>\n    ----------------------------------------------\n    ==> 'Mike'\n\nWhen requesting optional input, the strict validation can be turned off using\nthe ``strict`` argument. When this argument is ``False``, then the loop exists\neven when validation fails. The value returned when validation fails is\ncontrolled by ``default`` argument, which defaults to ``None``. ::\n\n    cn.rvpl('Please enter your name:', strict=False, default='Bob')\n    ---------------------------------------------I\n    Please enter your name: <Enter>\n    ----------------------------------------------\n    ==> 'Bob'\n\nYes/No input\n~~~~~~~~~~~~\n\nThe ``yesno()`` method provides a specialized version the RVPL limited to yes\nand no answer, and returnin ``True`` or ``False``. ::\n\n    cn.yesno('Are you all right?')\n    ---------------------------------------------I\n    Are you all right? (y/n): y<Enter>\n    ----------------------------------------------\n    ==> True\n\nThe prompt passed to ``yesno()`` is automatically appended the '(y/n):' string.\nThe appearance of this string depends on the default value discussed further\nbelow.\n\nSince it is a wrapper around ``rvpl()`` it takes the same ``error`` and\n``intro`` arguments which behave the same way.\n\nAlthough it takes the ``default`` argument like ``rvpl()``, the behavior is\ndifferent. When ``default`` is ``None`` it automatically turns on strict\nvalidation. The argument can also be either ``True`` or ``False``, in which\ncase the default value is respectively 'yes' and 'no'. ::\n\n    cn.yesno('Are you all right?', default=True)\n    ---------------------------------------------I\n    Are you all right? (Y/n): <Enter>\n    ----------------------------------------------\n    ==> True\n    \n    cn.yesno('Are you all right?', default=False\n    ---------------------------------------------I\n    Are you all right? (y/N): <Enter>\n    ----------------------------------------------\n    ==> False\n\nMenu\n~~~~\n\nMenu is another specialization of the RVPL, used for displaying menus. This is\nfacilitated by the ``menu()`` method. \n\nThis method has only one required argument, which is an iterable of menu\nchoices. Each member of the iterable must be a two-tuple which holds the actual\nvalue as first member and the value's label as second. For example::\n\n    choices = (('f', 'foo'), ('b', 'bar'))\n    cn.menu(choices)\n    ---------------------------------------------I\n      1) foo\n      2) bar\n    Please choose from the provided options: 1<Enter>\n    ----------------------------------------------\n    ==> 'f'\n\nAlmost all aspects of the menu can be customized. The ``prompt``, ``error``,\n``intro``, ``strict`` and ``default`` behave the same way as in regular RVPL so\nwe will not discuss them in detail here.\n\nDisplay of the menu items themselves is controlled by two arguments:\n``formatter`` and ``numerator``.\n\n``numerator`` argument controls how the enumeration of the menu items is done.\nIt takes the number of menu items as its only argument, and must return a list\nof strings to be used as options. For example::\n\n    choices = (('f', 'foo'), ('b', 'bar'))\n    numer = lambda n: ('abcd'[i] for i in range(n), numerator=numer)\n    cn.menu(choices)\n    ---------------------------------------------I\n      a) foo\n      b) bar\n    Please choose from the provided options: a<Enter>\n    ----------------------------------------------\n    ==> 'f'\n\n``formatter`` takes the number of the item and item's label and must return a\nformatted menu item. For example::\n\n    choices = (('f', 'foo'), ('b', 'bar'))\n    fmt = lambda n, lbl: '{} ({})'.format(lbl, n)\n    cn.menu(choices, formatter=fmt)\n    ---------------------------------------------I\n    foo (1)\n    bar (2)\n    Please choose from the provided options: 1<Enter>\n    ----------------------------------------------\n    ==> 'f'\n\nWorking with progress\n---------------------\n\nProgress is a more complex construct that we use to notify user of some\nactivity that may take a while. Each progress has a start banner, which is\nprinted before we begin, and two end banners, one for success and one for\nfailure.\n\nBefore we can use the progress context manager, we must enable verbose mode. ::\n\n    cn.verbose = True\n\nA progress is started using the ``progress()`` method, which is a context\nmanager. ::\n\n    with cn.progress(\"Let's get this show on the road\"):\n        # do something\n\nThis is the simplest form. When an exception of any kind is triggered inside\nthe context, it is trapped, the failure banner is printed, and the\n``conz.ProgressAbrt`` exception is raised. (This exception is also available as\nan attribute on ``Console`` objects for convenience.) If everything goes well,\nthen the success banner will be printed. With the previous code snippet, sucess\noutput may look like this::\n\n    ----------------------------------------------\n    Let's get this show on the road...DONE\n    ----------------------------------------------\n\nAnd failure would look like this::\n\n    ----------------------------------------------\n    Let's get this show on the road...FAIL\n    ----------------------------------------------\n\nThe end banners can be customized by using the ``end`` and ``abrt`` arguments::\n\n    with cn.progress('Almost there', end='finally!', abrt='awww, bummer'):\n        # do something\n\nThe outputs would look like this::\n\n    ----------------------------------------------\n    Almost there...finally!\n    ----------------------------------------------\n\nor::\n\n    ----------------------------------------------\n    Almost there...awww, bummer\n    ----------------------------------------------\n\nThe elipsis (three dots) can be customized using the ``sep`` argument::\n\n    with cn.progress('File check', sep=': '):\n        # do something\n\nThis results in::\n\n    ----------------------------------------------\n    File check: DONE\n    ----------------------------------------------\n\nor::\n\n    ----------------------------------------------\n    File check: FAIL\n    ----------------------------------------------\n\nBy default, the progress context manager will trap any exception. This may or\nmay not make sense for a particular situation. This behavior can therefore be\ncustomized using the ``excs`` argument, which takes a tuple of exception\nclasses that we are expecting. Passing exceptions explicitly like this allows\nthe context manager to propagate unhandled exceptions and reval subtle flaws in\nour logic.\n\nWe can also specify a callback that runs each time an exception (other than\n``ProgressAbrt`` and ``ProgressOK`` are raised inside the context. This\ncallback is specified using ``onerror`` argument, and defaults to an error\nhandler that prints 'Program error: ERROR MESSAGE' to STDERR. For convenience,\nthe ``Console`` object has a ``error()`` method which creates such handlers.\n\nBy default, the tracebacks raised during progress is suppressed. To see the\nfull traceback, ``Console`` constructor takes a ``debug`` argument, which can\nbe set to ``True`` to prevent traceback suppression.\n\nTo create a handler, we call the ``error()`` method like so::\n\n    handler = cn.error('Ouch!', exit=1)\n    with cn.progress('Ouch progress', onerror=handler):\n        raise RuntimeError()\n\nThe above results in::\n\n    ----------------------------------------------\n    Outch progress...FAIL\n    Ouch!\n    ----------------------------------------------\n\nThe message may have a ``{err}`` placeholder, which gets replaced by the string\nrepresentation of the exception that was raised in the block.\n\nTo completely suppress the error handler, simply pass it a function that does\nnothing. ::\n\n    with cn.progress('No ouch', onerror: lambda exc: None):\n        raise RuntimeError()\n    ----------------------------------------------\n    No ouch...FAIL\n    ----------------------------------------------\n\n.. note::\n    Note that passing ``None`` as ``onerror`` value simply causes the default\n    error handler to be used instead.\n\nThe progress context manager returns a ``Progress`` object, which provides\nmethods for explicitly terminating the progress, and printing the progress\nindicator. This object has ``end()`` and ``abrt()`` methods, which are called\nto terminate with success and error status respectively. For example::\n\n    with cn.progress('Something') as prg:\n        if not success:\n            prg.abrt()\n        prg.end()\n\nThe ``end()`` and ``abrt()`` methods raise ``ProgressOK`` and ``ProgressAbrt``\nexceptions repsectively. We can suppress raising of the exceptions using\n``noraise`` argument and setting it to ``True``. Both of the methods will use\nthe default end banners. We can also use any banner we want by passing it as\nthe first positional argument. This can be useful in cases where the end banner\nshould indicate different outcomes.\n\n.. note::\n    Default banners are colorized (green for success, red for failure). Any\n    custom banners passed directly to ``end()`` and ``abrt()`` will not be\n    colorized, though.\n\nThe ``ProgressOK`` exception is not meant to be\nhandled by us in any way, and it's simply there to facilitate flow control.\n``ProgressAbrt`` is, by default, reraised so that code outside the context\nmanager can handle it. Therefore, we normally wrap the context block in a\ntry-except::\n\n    try:\n        with cn.progress('Something'):\n            # do something\n    except cn.ProgressAbrt:\n        # something went wrong\n\nThis reraising of the ``ProgressAbrt`` exception can be suppressed by using the\n``reraise`` argument which can be ``True`` or ``False``. Setting this flag to\n``False`` silences the ``ProgressAbrt`` exception. At that point, we are still\nable to do error handling using the ``onerror`` callback.\n\nYou can find a script in ``examples/progress.py`` which demonstrates a few\ntypical cases.\n\nQuitting\n--------\n\nTo quit the program, we call the ``quit()`` method on the ``Console`` object.\nThis method works the same way as ``sys.exit()`` (except that it takes one less\n``import`` to use it).\n\nSignal handling\n---------------\n\nThe default implementation of ``Console`` class automatically takes care of\n``SIGINT`` (keyboard interrupt) and ``SIGPIPE`` (broken pipe) signals. You can\ncustomize the way those are handled by overloading the ``onint()`` and\n``onpipe()`` methods. You can also customize the registration of signals\nthemselves by overloading the ``register_signals()`` method.\n\n\nReporting bugs\n==============\n\nPlease report any bugs or feature requests to the `issue tracker`_.\n\n.. _colorama: https://pypi.python.org/pypi/colorama\n.. _issue tracker: https://github.com/Outernet-Project/conz/issues", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Outernet-Project/conz", "keywords": "console,terminal,signals,output,command line,colorizing", "license": "GPLv3", "maintainer": null, "maintainer_email": null, "name": "conz", "package_url": "https://pypi.org/project/conz/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/conz/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/Outernet-Project/conz"}, "release_url": "https://pypi.org/project/conz/0.5/", "requires_dist": null, "requires_python": null, "summary": "Library for writing command line programs", "version": "0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This module contains a lightweight library for creating command line programs,\nconz.</p>\n<p>conz has following features:</p>\n<ul>\n<li>Simplifies working with pipes</li>\n<li>Provides methods for handling typical interactive scenarios</li>\n<li>Supports output colorization</li>\n<li>Provides tools for working with long-running tasks</li>\n<li>Controls output in interactive and non-interactive scenarios</li>\n<li>Manages signals (SIGINT and SIGPIPE)</li>\n</ul>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#installing\" id=\"id1\" rel=\"nofollow\">Installing</a></li>\n<li><a href=\"#quick-tour\" id=\"id2\" rel=\"nofollow\">Quick tour</a></li>\n<li><a href=\"#formatting-conventions\" id=\"id3\" rel=\"nofollow\">Formatting conventions</a></li>\n<li><a href=\"#usage\" id=\"id4\" rel=\"nofollow\">Usage</a><ul>\n<li><a href=\"#working-with-output\" id=\"id5\" rel=\"nofollow\">Working with output</a></li>\n<li><a href=\"#colorizing\" id=\"id6\" rel=\"nofollow\">Colorizing</a></li>\n<li><a href=\"#working-with-input\" id=\"id7\" rel=\"nofollow\">Working with input</a></li>\n<li><a href=\"#advanced-interactive-input\" id=\"id8\" rel=\"nofollow\">Advanced interactive input</a><ul>\n<li><a href=\"#rvpl\" id=\"id9\" rel=\"nofollow\">RVPL</a></li>\n<li><a href=\"#yes-no-input\" id=\"id10\" rel=\"nofollow\">Yes/No input</a></li>\n<li><a href=\"#menu\" id=\"id11\" rel=\"nofollow\">Menu</a></li>\n</ul>\n</li>\n<li><a href=\"#working-with-progress\" id=\"id12\" rel=\"nofollow\">Working with progress</a></li>\n<li><a href=\"#quitting\" id=\"id13\" rel=\"nofollow\">Quitting</a></li>\n<li><a href=\"#signal-handling\" id=\"id14\" rel=\"nofollow\">Signal handling</a></li>\n</ul>\n</li>\n<li><a href=\"#reporting-bugs\" id=\"id15\" rel=\"nofollow\">Reporting bugs</a></li>\n</ul>\n</div>\n<div id=\"installing\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Installing</a></h2>\n<p>You can install conz from PyPI using pip or easy_install:</p>\n<pre>pip install conz\n\neasy_install conz\n</pre>\n</div>\n<div id=\"quick-tour\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Quick tour</a></h2>\n<p>A quick tour example can be found in <tt>examples/quicktour.py</tt>:</p>\n<pre>import conz\n\nsomeval = True\n\ncn = conz.Console(verbose=True)\n\ncn.pstd('This goes to STDOUT')\ncn.perr('This goes to STDERR')\ncn.pverr(someval, 'This message is related to somevar')\n\ncn.pstd(cn.color.green('This message is green'))\n\nwith cn.progress('Some long operation'):\n    import time\n    time.sleep(2)\n\ndata = cn.read('Type something in:')\ncn.pstd('You typed in {}'.format(cn.color.yellow(data, style='italic')))\n</pre>\n</div>\n<div id=\"formatting-conventions\">\n<h2><a href=\"#id3\" rel=\"nofollow\">Formatting conventions</a></h2>\n<p>Because this library deals with terminal output a lot, we have to somehow tell\nwhen something is terminal output and when it is code. Because of this, we use\nlines to delimit console output. For example:</p>\n<pre>----------------------------------------------\nI'm a sample output\n----------------------------------------------\n</pre>\n<p>When output is to the STDERR, \u2018E\u2019 will be shown in the right corner.:</p>\n<pre>---------------------------------------------E\nI'm a sample error\n----------------------------------------------\n</pre>\n<p>When user enters data, the Entered data will be followed by <tt>&lt;Enter&gt;</tt> and the\nright corner will include the \u2018I\u2019 character (for \u2018interactive session\u2019):</p>\n<pre>---------------------------------------------I\nPrompt: some data&lt;Enter&gt;\n----------------------------------------------\n</pre>\n<p>When value is returned from user input, the value is printed right below the\noutput preceeded by <tt>==&gt;</tt>:</p>\n<pre>---------------------------------------------I\nPrompt: some data&lt;Enter&gt;\n----------------------------------------------\n==&gt; 'some data'\n</pre>\n</div>\n<div id=\"usage\">\n<h2><a href=\"#id4\" rel=\"nofollow\">Usage</a></h2>\n<p>The <tt>conz</tt> package includes a class <tt>Console</tt> which is the only class you\nwill even need to work with. Simply import and instantiate it at the top of\nyour program.</p>\n<pre>import conz\ncn = conz.Console()\n</pre>\n<div id=\"working-with-output\">\n<h3><a href=\"#id5\" rel=\"nofollow\">Working with output</a></h3>\n<p>The <tt>Console()</tt> class is, for the most part, a wrapper around the <tt>print()</tt>\nfunction (not print statement, so not compatible with versions of Python that\ndo not support this). It controls how <tt>print()</tt> is invoked and takes care of\nsome of the edge cases where it may malfunction.</p>\n<p>The <tt>print()</tt> method on a <tt>Console</tt> object is a very simple wrapper around\nPython\u2019s <tt>print()</tt> whic does nothing except pass it\u2019s positional and keywrod\narguments to the <tt>print()</tt> function. We will never use it directly, though,\nas there are shortcuts for doing specific things with <tt>print()</tt>.</p>\n<p>To output to STDOUT, we use the <tt>pstd()</tt> method. It takes the same arguments\nas <tt>print()</tt> function, with the exception of <tt>file</tt> keyword argument which\nis set by this method and cannot be overridden.</p>\n<pre>cn.pstd('This always goes to STDOUT', end='...')\n----------------------------------------------\nThis always goes to STDOUT\n----------------------------------------------\n</pre>\n<p>To output to STDERR, we use the <tt>perr()</tt> method. As with <tt>pstd()</tt>, it\noverrides the <tt>file</tt> argument for us.</p>\n<pre>cn.perr('Mayday, mayday!')\n---------------------------------------------E\nMayday, mayday!\n----------------------------------------------\n</pre>\n<p>The main difference between regular <tt>print()</tt> and <tt>pstd()</tt>/<tt>perr()</tt>\nmethods is that the latter will flush the STDOUT/STDERR after writing to it.\nThis can prvent weird issues in some edge cases.</p>\n<p>There is a variant of <tt>perr()</tt> which prints a more structured message to\nSTDERR. The <tt>pverr()</tt> method takes a value and a message, and prints then in\n<tt>VALUE: Message</tt> format.</p>\n<pre>path = '/foo/bar/baz.txt'\ncn.verr(path, 'not found')\n---------------------------------------------E\n/foo/bar/baz.txt: not found\n----------------------------------------------\n</pre>\n<p>A variant of <tt>pstd()</tt> is <tt>pverb()</tt>. It is exactly the same as <tt>pstd()</tt>,\nexcept that it only outputs when <tt>verbose</tt> flag on the <tt>Console</tt> object is\n<tt>True</tt>. This is useful for programs that need to differentiate between\ninteractive and non-interactive use (e.g., using in pipe vs invoking directly)\nor wish to have a <tt><span class=\"pre\">--verbose</span></tt> switch, etc.</p>\n<pre>cn.verbose = True\ncn.pverb(\"I'm a talkative program\")\n----------------------------------------------\nI'm a talkative program\n----------------------------------------------\n\ncn.verbose = False\ncn.pverb(\"I'm a talkative program\")\n----------------------------------------------\n\n----------------------------------------------\n</pre>\n<p>The <tt>verbose</tt> flag can be set either as an argument during instantiation, or\nsimply by setting the attribute as in the previous example.</p>\n<p>The <tt>Console</tt> object also provides a <tt>outterm</tt> property which is <tt>False</tt>\nwhen program is outputting to a pipe rather than the terminal:</p>\n<pre>if cn.outterm:\n    # give full output to the user\nelse:\n    # give a short output that can be parsed by a machine, etc\n</pre>\n</div>\n<div id=\"colorizing\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Colorizing</a></h3>\n<p>Before we start, note that this implementation is <strong>not cross-platform</strong>. If\nyou need something with a bit more punch, you should look at <a href=\"https://pypi.python.org/pypi/colorama\" rel=\"nofollow\">colorama</a>.</p>\n<p>To colorize the output, both the <tt>conz</tt> module and <tt>Console</tt> class have a\n<tt>color</tt> attribute, which provides methods for output colorization. Each piece\nof text can have the following attributes:</p>\n<ul>\n<li>foreground color</li>\n<li>style</li>\n<li>background color</li>\n</ul>\n<p>Foreground and background colors can be:</p>\n<ul>\n<li>black</li>\n<li>red</li>\n<li>green</li>\n<li>yellow</li>\n<li>blue</li>\n<li>purple (magenta)</li>\n<li>cyan</li>\n<li>white</li>\n</ul>\n<p>Styles can be:</p>\n<ul>\n<li>bold</li>\n<li>italic</li>\n<li>underline</li>\n<li>blink</li>\n<li>reverse (inverts foreground and background colors)</li>\n</ul>\n<p>Each of these colors have a method on the <tt>color</tt> attribute. Each color\nmethod takes <tt>style</tt> and <tt>bg</tt> keyword arguments which set the style and\nbackground color respectively. The <tt>color()</tt> method can be used to specify\ncolors dynamically. Here are some examples:</p>\n<pre>cn.color.red('This is red text')\ncn.color.color('This is red text', color='red')\ncn.color.blue('This is blue underlined text', style='underline')\ncn.color.color('This is green on yellow', color='green', bg='yellow')\n</pre>\n<p>You can find an example script in <tt>examples/colors.py</tt> which prings all\npossible combinations of various colors, styles, and backgrounds.</p>\n</div>\n<div id=\"working-with-input\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Working with input</a></h3>\n<p>There are two types of input you can work with: interactive user input, and\npipes.</p>\n<p>To read the user input, use <tt>read()</tt> method. This method takes two optional\narguments. One is the <tt>prompt</tt> argument, which we use to set the prompt. It\nis an empty string by default. The other argument is a data-cleaning function.\nWhen you pass the <tt>clean</tt> argument, user input is passed through the function\nbefore it is retuned. For example:</p>\n<pre>cn.read('Exit? [y/N] ', clean=lambda x: x.lower()[:1] == 'y')\n---------------------------------------------I\nExit? [y/N] y&lt;Enter&gt;\n----------------------------------------------\n==&gt; True\n</pre>\n<p>Note that this method uses <tt>raw_input()</tt> on Python 2.7.x and <tt>input()</tt> on\nPython 3.x.</p>\n<p>To work with pipes, we use the <tt>readpipe()</tt> method. This method reads from\nthe STDIN pipe one line at a time and returns an iterator that allows us to\niterate over the lines.</p>\n<pre>for l in cn.readpipe():\n    l = l.strip()\n    cn.pstd('Received: {}'.format())\n</pre>\n<p>Note that line-feed characters are not stripped from the output so it is up to\nus to strip it away.</p>\n<p>When working with a large number of lines coming down the pipe, we may\nsometimes need to work in batches, rather than one line at a time. The\n<tt>chunk</tt> argument can be set to an integer value that specifies the number of\nlines we want buffered before they are returned to us. When using chunks, the\nlines are returned as a list of strings, rather than strings. The following\nexample will return pipe input in groups of 500:</p>\n<pre>for lines in cn.readpipe(500):\n    # do something with 500 lines\n</pre>\n<p>If we need to know whether input will come from a pipe or not, we can use the\n<tt>interm</tt> property.</p>\n<pre>if cn.interm:\n    # possibly interactive version\nelse:\n    # we are on the receiving end of a pipe\n</pre>\n</div>\n<div id=\"advanced-interactive-input\">\n<h3><a href=\"#id8\" rel=\"nofollow\">Advanced interactive input</a></h3>\n<p>So far we have looked at simpe user input. However in most cases, input is not\nthe only thing we want. We normally also need to show notes, validate the\ninput, construct menus, etc. The <tt>Console</tt> class provides three methods that\nare useful for different scenarios.</p>\n<p>You will find examples of code discussed here in <tt>examples/user_input.py</tt> and\n<tt>examples/menu.py</tt>.</p>\n<div id=\"rvpl\">\n<h4><a href=\"#id9\" rel=\"nofollow\">RVPL</a></h4>\n<p>RVPL (pead validate print loop) is a loop in which some data is read from the\nuser, validated, and error message printed. This loop continues as long as data\nis invalid. The <tt>rvpl()</tt> method is used to start such a loop.</p>\n<p>At bare minimum, <tt>rvpl()</tt> is called with a prompt that should be shown to the\nuser.</p>\n<pre>cn.rvpl('Please enter your name:')\n---------------------------------------------I\nPlease enter your name: My name&lt;enter&gt;\n----------------------------------------------\n==&gt; 'My name'\n</pre>\n<p>Like <tt>read()</tt>, <tt>rvpl()</tt> also takes a <tt>clean</tt> argument, which is used to\ncontrol how the value is cleaned. In addition, it takes <tt>validator</tt> argument,\nwhich is a function that validates the cleaned data. The default validator\nsimply makes sure the input is not an empty string.</p>\n<p>For invalid input, error message is displayed:</p>\n<pre>cn.rvpl('Please enter your name:')\n---------------------------------------------I\nPlease enter your name: &lt;Enter&gt;\nEntered value is invalid\nPlease enter your name: Mike&lt;Enter&gt;\n----------------------------------------------\n==&gt; 'Mike'\n</pre>\n<p>Error message can be customized using the <tt>error</tt> argument. If <tt>error</tt>\nargument is is a callable, it will be called with entered value and it must\nreturn the message to be shown.</p>\n<pre>valid_input = ('a', 'b', 'c')\nerror = lambda x: '{} is not one of the {}'.format(\n    x, ', '.join(valid_input))\nvalidator = lambda x: x in valid_input\ncn.rvpl('Type one of the first 3 characters of English alphabet:')\n---------------------------------------------I\nType one of the first 3 characters of English alphabet: e&lt;Enter&gt;\ne is not one of the a, b, c\nType one of the first 3 characters of English alphabet: b&lt;Enter&gt;\n----------------------------------------------\n==&gt; 'b'\n</pre>\n<p>An intro message can be passed which is shown above the prompt. Unlinke the\nprompt itself, intro message is not repeated in the loop.</p>\n<pre>cn.rvpl('&gt;', intro='Please enter your name:')\n---------------------------------------------I\nPlease enter your name:\n&gt; &lt;Enter&gt;\nEntered value is invalid\n&gt; Mike&lt;Enter&gt;\n----------------------------------------------\n==&gt; 'Mike'\n</pre>\n<p>When requesting optional input, the strict validation can be turned off using\nthe <tt>strict</tt> argument. When this argument is <tt>False</tt>, then the loop exists\neven when validation fails. The value returned when validation fails is\ncontrolled by <tt>default</tt> argument, which defaults to <tt>None</tt>.</p>\n<pre>cn.rvpl('Please enter your name:', strict=False, default='Bob')\n---------------------------------------------I\nPlease enter your name: &lt;Enter&gt;\n----------------------------------------------\n==&gt; 'Bob'\n</pre>\n</div>\n<div id=\"yes-no-input\">\n<h4><a href=\"#id10\" rel=\"nofollow\">Yes/No input</a></h4>\n<p>The <tt>yesno()</tt> method provides a specialized version the RVPL limited to yes\nand no answer, and returnin <tt>True</tt> or <tt>False</tt>.</p>\n<pre>cn.yesno('Are you all right?')\n---------------------------------------------I\nAre you all right? (y/n): y&lt;Enter&gt;\n----------------------------------------------\n==&gt; True\n</pre>\n<p>The prompt passed to <tt>yesno()</tt> is automatically appended the \u2018(y/n):\u2019 string.\nThe appearance of this string depends on the default value discussed further\nbelow.</p>\n<p>Since it is a wrapper around <tt>rvpl()</tt> it takes the same <tt>error</tt> and\n<tt>intro</tt> arguments which behave the same way.</p>\n<p>Although it takes the <tt>default</tt> argument like <tt>rvpl()</tt>, the behavior is\ndifferent. When <tt>default</tt> is <tt>None</tt> it automatically turns on strict\nvalidation. The argument can also be either <tt>True</tt> or <tt>False</tt>, in which\ncase the default value is respectively \u2018yes\u2019 and \u2018no\u2019.</p>\n<pre>cn.yesno('Are you all right?', default=True)\n---------------------------------------------I\nAre you all right? (Y/n): &lt;Enter&gt;\n----------------------------------------------\n==&gt; True\n\ncn.yesno('Are you all right?', default=False\n---------------------------------------------I\nAre you all right? (y/N): &lt;Enter&gt;\n----------------------------------------------\n==&gt; False\n</pre>\n</div>\n<div id=\"menu\">\n<h4><a href=\"#id11\" rel=\"nofollow\">Menu</a></h4>\n<p>Menu is another specialization of the RVPL, used for displaying menus. This is\nfacilitated by the <tt>menu()</tt> method.</p>\n<p>This method has only one required argument, which is an iterable of menu\nchoices. Each member of the iterable must be a two-tuple which holds the actual\nvalue as first member and the value\u2019s label as second. For example:</p>\n<pre>choices = (('f', 'foo'), ('b', 'bar'))\ncn.menu(choices)\n---------------------------------------------I\n  1) foo\n  2) bar\nPlease choose from the provided options: 1&lt;Enter&gt;\n----------------------------------------------\n==&gt; 'f'\n</pre>\n<p>Almost all aspects of the menu can be customized. The <tt>prompt</tt>, <tt>error</tt>,\n<tt>intro</tt>, <tt>strict</tt> and <tt>default</tt> behave the same way as in regular RVPL so\nwe will not discuss them in detail here.</p>\n<p>Display of the menu items themselves is controlled by two arguments:\n<tt>formatter</tt> and <tt>numerator</tt>.</p>\n<p><tt>numerator</tt> argument controls how the enumeration of the menu items is done.\nIt takes the number of menu items as its only argument, and must return a list\nof strings to be used as options. For example:</p>\n<pre>choices = (('f', 'foo'), ('b', 'bar'))\nnumer = lambda n: ('abcd'[i] for i in range(n), numerator=numer)\ncn.menu(choices)\n---------------------------------------------I\n  a) foo\n  b) bar\nPlease choose from the provided options: a&lt;Enter&gt;\n----------------------------------------------\n==&gt; 'f'\n</pre>\n<p><tt>formatter</tt> takes the number of the item and item\u2019s label and must return a\nformatted menu item. For example:</p>\n<pre>choices = (('f', 'foo'), ('b', 'bar'))\nfmt = lambda n, lbl: '{} ({})'.format(lbl, n)\ncn.menu(choices, formatter=fmt)\n---------------------------------------------I\nfoo (1)\nbar (2)\nPlease choose from the provided options: 1&lt;Enter&gt;\n----------------------------------------------\n==&gt; 'f'\n</pre>\n</div>\n</div>\n<div id=\"working-with-progress\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Working with progress</a></h3>\n<p>Progress is a more complex construct that we use to notify user of some\nactivity that may take a while. Each progress has a start banner, which is\nprinted before we begin, and two end banners, one for success and one for\nfailure.</p>\n<p>Before we can use the progress context manager, we must enable verbose mode.</p>\n<pre>cn.verbose = True\n</pre>\n<p>A progress is started using the <tt>progress()</tt> method, which is a context\nmanager.</p>\n<pre>with cn.progress(\"Let's get this show on the road\"):\n    # do something\n</pre>\n<p>This is the simplest form. When an exception of any kind is triggered inside\nthe context, it is trapped, the failure banner is printed, and the\n<tt>conz.ProgressAbrt</tt> exception is raised. (This exception is also available as\nan attribute on <tt>Console</tt> objects for convenience.) If everything goes well,\nthen the success banner will be printed. With the previous code snippet, sucess\noutput may look like this:</p>\n<pre>----------------------------------------------\nLet's get this show on the road...DONE\n----------------------------------------------\n</pre>\n<p>And failure would look like this:</p>\n<pre>----------------------------------------------\nLet's get this show on the road...FAIL\n----------------------------------------------\n</pre>\n<p>The end banners can be customized by using the <tt>end</tt> and <tt>abrt</tt> arguments:</p>\n<pre>with cn.progress('Almost there', end='finally!', abrt='awww, bummer'):\n    # do something\n</pre>\n<p>The outputs would look like this:</p>\n<pre>----------------------------------------------\nAlmost there...finally!\n----------------------------------------------\n</pre>\n<p>or:</p>\n<pre>----------------------------------------------\nAlmost there...awww, bummer\n----------------------------------------------\n</pre>\n<p>The elipsis (three dots) can be customized using the <tt>sep</tt> argument:</p>\n<pre>with cn.progress('File check', sep=': '):\n    # do something\n</pre>\n<p>This results in:</p>\n<pre>----------------------------------------------\nFile check: DONE\n----------------------------------------------\n</pre>\n<p>or:</p>\n<pre>----------------------------------------------\nFile check: FAIL\n----------------------------------------------\n</pre>\n<p>By default, the progress context manager will trap any exception. This may or\nmay not make sense for a particular situation. This behavior can therefore be\ncustomized using the <tt>excs</tt> argument, which takes a tuple of exception\nclasses that we are expecting. Passing exceptions explicitly like this allows\nthe context manager to propagate unhandled exceptions and reval subtle flaws in\nour logic.</p>\n<p>We can also specify a callback that runs each time an exception (other than\n<tt>ProgressAbrt</tt> and <tt>ProgressOK</tt> are raised inside the context. This\ncallback is specified using <tt>onerror</tt> argument, and defaults to an error\nhandler that prints \u2018Program error: ERROR MESSAGE\u2019 to STDERR. For convenience,\nthe <tt>Console</tt> object has a <tt>error()</tt> method which creates such handlers.</p>\n<p>By default, the tracebacks raised during progress is suppressed. To see the\nfull traceback, <tt>Console</tt> constructor takes a <tt>debug</tt> argument, which can\nbe set to <tt>True</tt> to prevent traceback suppression.</p>\n<p>To create a handler, we call the <tt>error()</tt> method like so:</p>\n<pre>handler = cn.error('Ouch!', exit=1)\nwith cn.progress('Ouch progress', onerror=handler):\n    raise RuntimeError()\n</pre>\n<p>The above results in:</p>\n<pre>----------------------------------------------\nOutch progress...FAIL\nOuch!\n----------------------------------------------\n</pre>\n<p>The message may have a <tt>{err}</tt> placeholder, which gets replaced by the string\nrepresentation of the exception that was raised in the block.</p>\n<p>To completely suppress the error handler, simply pass it a function that does\nnothing.</p>\n<pre>with cn.progress('No ouch', onerror: lambda exc: None):\n    raise RuntimeError()\n----------------------------------------------\nNo ouch...FAIL\n----------------------------------------------\n</pre>\n<div>\n<p>Note</p>\n<p>Note that passing <tt>None</tt> as <tt>onerror</tt> value simply causes the default\nerror handler to be used instead.</p>\n</div>\n<p>The progress context manager returns a <tt>Progress</tt> object, which provides\nmethods for explicitly terminating the progress, and printing the progress\nindicator. This object has <tt>end()</tt> and <tt>abrt()</tt> methods, which are called\nto terminate with success and error status respectively. For example:</p>\n<pre>with cn.progress('Something') as prg:\n    if not success:\n        prg.abrt()\n    prg.end()\n</pre>\n<p>The <tt>end()</tt> and <tt>abrt()</tt> methods raise <tt>ProgressOK</tt> and <tt>ProgressAbrt</tt>\nexceptions repsectively. We can suppress raising of the exceptions using\n<tt>noraise</tt> argument and setting it to <tt>True</tt>. Both of the methods will use\nthe default end banners. We can also use any banner we want by passing it as\nthe first positional argument. This can be useful in cases where the end banner\nshould indicate different outcomes.</p>\n<div>\n<p>Note</p>\n<p>Default banners are colorized (green for success, red for failure). Any\ncustom banners passed directly to <tt>end()</tt> and <tt>abrt()</tt> will not be\ncolorized, though.</p>\n</div>\n<p>The <tt>ProgressOK</tt> exception is not meant to be\nhandled by us in any way, and it\u2019s simply there to facilitate flow control.\n<tt>ProgressAbrt</tt> is, by default, reraised so that code outside the context\nmanager can handle it. Therefore, we normally wrap the context block in a\ntry-except:</p>\n<pre>try:\n    with cn.progress('Something'):\n        # do something\nexcept cn.ProgressAbrt:\n    # something went wrong\n</pre>\n<p>This reraising of the <tt>ProgressAbrt</tt> exception can be suppressed by using the\n<tt>reraise</tt> argument which can be <tt>True</tt> or <tt>False</tt>. Setting this flag to\n<tt>False</tt> silences the <tt>ProgressAbrt</tt> exception. At that point, we are still\nable to do error handling using the <tt>onerror</tt> callback.</p>\n<p>You can find a script in <tt>examples/progress.py</tt> which demonstrates a few\ntypical cases.</p>\n</div>\n<div id=\"quitting\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Quitting</a></h3>\n<p>To quit the program, we call the <tt>quit()</tt> method on the <tt>Console</tt> object.\nThis method works the same way as <tt>sys.exit()</tt> (except that it takes one less\n<tt>import</tt> to use it).</p>\n</div>\n<div id=\"signal-handling\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Signal handling</a></h3>\n<p>The default implementation of <tt>Console</tt> class automatically takes care of\n<tt>SIGINT</tt> (keyboard interrupt) and <tt>SIGPIPE</tt> (broken pipe) signals. You can\ncustomize the way those are handled by overloading the <tt>onint()</tt> and\n<tt>onpipe()</tt> methods. You can also customize the registration of signals\nthemselves by overloading the <tt>register_signals()</tt> method.</p>\n</div>\n</div>\n<div id=\"reporting-bugs\">\n<h2><a href=\"#id15\" rel=\"nofollow\">Reporting bugs</a></h2>\n<p>Please report any bugs or feature requests to the <a href=\"https://github.com/Outernet-Project/conz/issues\" rel=\"nofollow\">issue tracker</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 1543562, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "f52c11e4c2848397c160631b12d367bd", "sha256": "802083734f8ab220966dcdb67d717440510e17fc9c978667853868a206a9b4e7"}, "downloads": -1, "filename": "conz-0.1.tar.gz", "has_sig": false, "md5_digest": "f52c11e4c2848397c160631b12d367bd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22941, "upload_time": "2015-05-05T11:38:08", "upload_time_iso_8601": "2015-05-05T11:38:08.684398Z", "url": "https://files.pythonhosted.org/packages/6e/13/6a057f5dfe72f7cf2a0c5a0ce45d6f2f908a6fcc5080f71d31dcfa3aee05/conz-0.1.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "9f033520e8e2e7eab1073a4800504a5e", "sha256": "f3d3e817093b1e851e3530713a3c14051a33065a7db331374558425d29dccd08"}, "downloads": -1, "filename": "conz-0.1.zip", "has_sig": false, "md5_digest": "9f033520e8e2e7eab1073a4800504a5e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29641, "upload_time": "2015-05-05T11:38:12", "upload_time_iso_8601": "2015-05-05T11:38:12.064659Z", "url": "https://files.pythonhosted.org/packages/71/0b/21bdd7bd469effb4ec01091f0d15fedce2fb31c257e76528ba20bd1c3d89/conz-0.1.zip", "yanked": false}], "0.1.post1": [{"comment_text": "", "digests": {"md5": "a8b48df06722a036447c75a28cbcd212", "sha256": "7a4d384fe63b87167538832bec1044882148888a78693bc8c23852919ac10dfb"}, "downloads": -1, "filename": "conz-0.1.post1.tar.gz", "has_sig": false, "md5_digest": "a8b48df06722a036447c75a28cbcd212", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26142, "upload_time": "2015-05-05T11:51:10", "upload_time_iso_8601": "2015-05-05T11:51:10.038176Z", "url": "https://files.pythonhosted.org/packages/ea/c0/1c908dba92f1bb833cf9287ef9d90971a7efb298fbd094cdd5b299ee0830/conz-0.1.post1.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "991fe84e0fd1051a82d8e188a7f36d0b", "sha256": "26080893c1b92df6310b31c23676c137ef26a0365565cc64219a56b6a972c8f8"}, "downloads": -1, "filename": "conz-0.1.post1.zip", "has_sig": false, "md5_digest": "991fe84e0fd1051a82d8e188a7f36d0b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33571, "upload_time": "2015-05-05T11:51:13", "upload_time_iso_8601": "2015-05-05T11:51:13.203449Z", "url": "https://files.pythonhosted.org/packages/44/a8/68293e003fea667086f941f6242f4161f551bcf29334745d562c26178c2b/conz-0.1.post1.zip", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "f00e6da213a0044a0a7d9f3ad45390cf", "sha256": "61e1fb0f191d008ce11a24e824e051f5975018096159f57a245dfc4210758e10"}, "downloads": -1, "filename": "conz-0.2.tar.gz", "has_sig": false, "md5_digest": "f00e6da213a0044a0a7d9f3ad45390cf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26151, "upload_time": "2015-05-05T12:23:46", "upload_time_iso_8601": "2015-05-05T12:23:46.874913Z", "url": "https://files.pythonhosted.org/packages/70/a1/9dc537a1f87444042cf26e4fd9ef3bfeb1eb7102f48d0a33d2cccf5a67e0/conz-0.2.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "027911ed85096bdd9aa840a50354bcca", "sha256": "da37aee6c6ab69584a2398ddbd3bb8b80d3fe4eae6f25ebb95ca79f0344484bd"}, "downloads": -1, "filename": "conz-0.2.zip", "has_sig": false, "md5_digest": "027911ed85096bdd9aa840a50354bcca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33449, "upload_time": "2015-05-05T12:23:50", "upload_time_iso_8601": "2015-05-05T12:23:50.604838Z", "url": "https://files.pythonhosted.org/packages/47/6a/12891f863214ebe0ec8a8fd70b7f2e5d194e69a2fcd26de639f55dee251b/conz-0.2.zip", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "94c67980ddde115b20b967d2d0230a7e", "sha256": "313d8951872a48983c06762c1498719d09f32dbbef7704490091396f1f3a968a"}, "downloads": -1, "filename": "conz-0.3.tar.gz", "has_sig": false, "md5_digest": "94c67980ddde115b20b967d2d0230a7e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32395, "upload_time": "2015-05-06T09:51:28", "upload_time_iso_8601": "2015-05-06T09:51:28.141957Z", "url": "https://files.pythonhosted.org/packages/75/aa/588d7949a30e83fec8a63e9c3090501eba475123b9bedde40288d1ab7958/conz-0.3.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "4288080d9067a78a9dd773b21e9467da", "sha256": "2c12d2074403a10cba68b5c5bc6b497b6f31db84758a4c4dcdfcb498bbc721a8"}, "downloads": -1, "filename": "conz-0.3.zip", "has_sig": false, "md5_digest": "4288080d9067a78a9dd773b21e9467da", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43080, "upload_time": "2015-05-06T09:51:31", "upload_time_iso_8601": "2015-05-06T09:51:31.581524Z", "url": "https://files.pythonhosted.org/packages/db/9a/355ab8ab2d41e7324a6ea9d8270cc2cd4a156a4972af437fa35cf4b580b4/conz-0.3.zip", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "b99855de3cc6d38e62b6f0e57c59265a", "sha256": "bfcb73e96df7e4e0d03842f7b3b0c13b4d1324870e235abd7c9812588033333b"}, "downloads": -1, "filename": "conz-0.4.tar.gz", "has_sig": false, "md5_digest": "b99855de3cc6d38e62b6f0e57c59265a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32614, "upload_time": "2015-05-07T13:33:12", "upload_time_iso_8601": "2015-05-07T13:33:12.447013Z", "url": "https://files.pythonhosted.org/packages/4d/4a/43794e666b601c83e24236255d004b84609bfcfd39a1fa3ee5ae3f3870cc/conz-0.4.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "873311d1e2b4320621523d69cb0e55aa", "sha256": "8cfa1a38930e7bd91400d7ab29555367de1cdd97e199d5d0a83e90d64ee42db7"}, "downloads": -1, "filename": "conz-0.4.zip", "has_sig": false, "md5_digest": "873311d1e2b4320621523d69cb0e55aa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43376, "upload_time": "2015-05-07T13:33:16", "upload_time_iso_8601": "2015-05-07T13:33:16.182296Z", "url": "https://files.pythonhosted.org/packages/95/a5/ccf3b500cd1d50973596ce4e2dbcda919f822302fc28c761349e0e064482/conz-0.4.zip", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "61ca0c489348f33cf71158f97e241d85", "sha256": "ede5f89bfec00f43aff04ef97a8308fd0df99a0f7d848a0e8526b7162a2763c3"}, "downloads": -1, "filename": "conz-0.5.tar.gz", "has_sig": false, "md5_digest": "61ca0c489348f33cf71158f97e241d85", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32724, "upload_time": "2015-05-12T11:56:29", "upload_time_iso_8601": "2015-05-12T11:56:29.749460Z", "url": "https://files.pythonhosted.org/packages/61/9b/9bba56fc649c7828b0693a9f0d58f984e48164e945cb17318603d5243070/conz-0.5.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "f168058eac3ebb71f2baa9bc62af0dc2", "sha256": "e9520ee8a3caa0bf92532a52f4a07b454c2a48e4bbd40f5d66f5e9cf8dea723e"}, "downloads": -1, "filename": "conz-0.5.zip", "has_sig": false, "md5_digest": "f168058eac3ebb71f2baa9bc62af0dc2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43488, "upload_time": "2015-05-12T11:56:33", "upload_time_iso_8601": "2015-05-12T11:56:33.667477Z", "url": "https://files.pythonhosted.org/packages/dc/c4/5ac466369c40d12cec693e56626dd9adfc50d47c44634c1335bb424f0382/conz-0.5.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "61ca0c489348f33cf71158f97e241d85", "sha256": "ede5f89bfec00f43aff04ef97a8308fd0df99a0f7d848a0e8526b7162a2763c3"}, "downloads": -1, "filename": "conz-0.5.tar.gz", "has_sig": false, "md5_digest": "61ca0c489348f33cf71158f97e241d85", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32724, "upload_time": "2015-05-12T11:56:29", "upload_time_iso_8601": "2015-05-12T11:56:29.749460Z", "url": "https://files.pythonhosted.org/packages/61/9b/9bba56fc649c7828b0693a9f0d58f984e48164e945cb17318603d5243070/conz-0.5.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "f168058eac3ebb71f2baa9bc62af0dc2", "sha256": "e9520ee8a3caa0bf92532a52f4a07b454c2a48e4bbd40f5d66f5e9cf8dea723e"}, "downloads": -1, "filename": "conz-0.5.zip", "has_sig": false, "md5_digest": "f168058eac3ebb71f2baa9bc62af0dc2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43488, "upload_time": "2015-05-12T11:56:33", "upload_time_iso_8601": "2015-05-12T11:56:33.667477Z", "url": "https://files.pythonhosted.org/packages/dc/c4/5ac466369c40d12cec693e56626dd9adfc50d47c44634c1335bb424f0382/conz-0.5.zip", "yanked": false}], "timestamp": "Fri May  8 00:43:25 2020"}