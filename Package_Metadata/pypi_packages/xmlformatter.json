{"info": {"author": "P. Andreas Moeller", "author_email": "kontakt@pamoller.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Topic :: Text Processing :: Markup :: XML"], "description": "============\nxmlformatter\n============\n\n`xmlformatter <http://pamoller.com/xmlformatter.html>`_ is an Open Source Python package, which provides formatting of XML documents. *It is the replacement for the Python 2 package XmlFormatter, which has been removed from PyPi completely (see Notes)*. xmlformatter differs from others formatters by *handling whitespaces by a distinct set of formatting rules* - formatting element content by a object style and mixed content by a text style. You may find xmlformatter useful for corrections and presentations. In addition xmlformatter comes with a wrapper script named xmlformat.\n\n================\nFormatting Rules\n================\n\nxmlformatter treats the element content from the following example as a object. The elements are associated with containers, like complex, or properties names, like real and imaginary. Text nodes are associated with property values, like 4.4E+12. Leading and trailing whitespaces are meaningless in this scenario like sequences of whitespaces. Leading and trailing whitespaces will be remove, sequences of whitespaces will be collapsed.\n\n::\n\n    <complex>\n      <real>  4.4E+12</real>\n     <imaginary>5.4E-11\n       </imaginary>\n    </complex>\n\nThe element content from the example above can be formatted by xmlformat:\n\n::\n\n    $ xmlformat ele.xml\n\nThe following output shows the formatted XML document. xmlformatter has removed leading and trailing whitespaces from the text nodes and has indented the child elements equal. This formatting style is called object style.\n\n::\n\n    <complex>\n      <real>4.4E+12</real>\n      <imaginary>5.4E-11</imaginary>\n    </complex>\n\nxmlformatter treats the mixed content from the following example as a literal text with some markup. The outer element enclose poem encloses the text. The inline element em gives a text snippet a special meaning. Leading and trailing whitespaces enclosed by inline elements are misplaced. They will be adopted by the previous or following text node. Note: xmlformatter may insert a text node if necessary. Even sequences of whitespaces will be collapsed:\n\n::\n\n    <poem> Es<em>   war</em> einmal und <em>ist  </em>nicht mehr...</poem>\n\nThe following output shows the formatted XML document. xmlfromatter has removed leading and trailing whitespaces and has collapsed sequences of whitespaces. This formatting style is called text style.\n\n::\n\n    <poem>Es <em>war</em> einmal und <em>ist</em> nicht mehr...</poem>\n\nBoth styles are used while formatting a XML document. The formatting rules are:    \n\nA: Surrounding whitespaces are removed from element content.    \n\nB: Leading whitespaces are removed from element content.    \n\nC: Trailing whitespaces are removed from element content.    \n\nD: Leading whitespaces of inline elements are put to preceding text (or inserted) if necessary within mixed content.    \n\nE: Trailing whitespaces of inline elements are put to following text (or inserted) if necessary within mixed content.    \n\nF: Sequences of whitespaces (n>2) are replaced by a single blank \" \" within element and mixed content.    \n\nG: Linebreak and whitespace are used to indent elements within elements content.\n\nThe following example shows the described whitespaces by their labels within a XML document:\n\n::\n\n    <root>AAAA\n    AAAA<number>BBBB4.4E+12CCC</number>AAAA\n    AAAA<poem>BBBBEs<em>DDDDwar</em> einmal und <em>istEEEE</em>nicht mehrF\n    FFFFein <strong>riesengro\u00dfer</strong><em>DDDDTeddyb\u00e4r</em>,F \n    der a\u00dfFFFFdie <em>MilchEEEE</em>und trank das BrotFFFF\n    und als er starb da <strong>war erEEEE</strong><em>tot</em>.CCCC</poem>AAAA\n    </root>\n\nThe following output shows the formatted XML document:\n\n::\n\n    <root>\n        <number>4.4E+12</number>\n        <poem>Es <em>war</em> einmal und <em>ist</em> nicht mehr ein <strong>riesengro\u00dfer</strong> <em>Teddyb\u00e4r</em>, der a\u00df die <em>Milch</em>und trank das Brot und als er starb da <strong>war er</strong> <em>tot</em>.</poem>\n    </root>\n\n=====\nClass\n=====\n\n::\n\n    class xmlformatter.Formatter(compress ::= False, indent ::= 2, indent_char ::= \" \", inline ::= True, encoding_input ::= None, encoding_output ::= None, preserve ::= [ ])\n\nThe Formatter class can be used to format XML documents in scripts. By default all parts of the XML document will formatted. All descendants of elements listed by preserve are left unformatted. Setting the boolean property compress to True suppresses the indenting given by the indent and indent_char properties. Without a value given to encoding_input xmlformatter trys to determine the encoding from the XML document. On failure it use UTF-8 as default. encoding_output advises xmlformatter to encode the output explicit by the given value. Otherwise xmlformatter use the inpurt encoding. Setting the boolean property inline to False suppresses inline formatting. By default element content will be formatted everywhere - also within mixed content. The following example shows the usage of the xmlfromatter class:\n\n::\n\n    import xmlformatter\n    \n    formatter = xmlformatter.Formatter(indent=\"1\", indent_char=\"\\t\", encoding_output=\"ISO-8859-1\", preserve=[\"literal\"])\n    formatter.format_file(\"/home/pa/doc.xml\")\n\nThe example formats the XML document in /home/pa/doc.xml, preserving the element literal, indenting by the tab character and output in ISO-8859-1 encoding.\n\n=======\nMembers\n=======\n\n::\n\n    compress ::= False\n\nMinify the XML document.\n\n::\n\n    correct ::= True\n\nApply formatting rules to whitespaces.\n\n::\n\n    indent ::= 2\n\nIndent a child element in element content n-times by indent_char.\n\n::\n\n    indent_char ::= \" \"\n\nIndent a child element by this string.\n\n::\n\n    input_encoding ::= None\n\nAssume the XML document encoded by a not None value.\n\n::\n\n    output_encoding ::= None\n\nEncode the formatted XML document by a not None value.\n\n::\n\n    preserve ::= [ ]\n\nSkip formatting for all elements listed in preserve and all their descendants.\n\n=======\nMethods\n=======\n\n::\n\n     format_file(path)\n\nFormat a XML document given by a path.\n\n::\n\n     format_string(xmldoc)\n\nFormat a XML document given by a string.\n\n===\nCmd\n===\n\n::\n\n    xmlformat [--preserve \"pre,literal\"] [--compress] [--indent num] [--indent-char char]\n              [--outfile file] [--encoding enc] [--outencoding enc] [--disable-inlineformatting] \n              [--dispable-correction] [--help] < --infile file | file | - >\n\nxmlformat can read from STDIN, like:\n\n::\n\n    $ cat /home/pa/doc.xml | xmlformat -\n\n=====\nNotes\n=====\n\nRemove XmlFormatter before installing xmlformatter:\n\n::\n\n    $ pip uninstall XmlFormatter\n\nAfter reinstallation replace the string \"formatter.formatter\" by \"formatter\", \"preserving\" by \"preserve\" and \"indentChar\" by \"indent_char\" inside your scripts carefully. To reach compatibility with XmlFormatter call xmlformat with --disable-inlineformatting or use inline=False in your scripts.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pamoller.com/xmlformatter.html", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "xmlformatter", "package_url": "https://pypi.org/project/xmlformatter/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/xmlformatter/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pamoller.com/xmlformatter.html"}, "release_url": "https://pypi.org/project/xmlformatter/0.1.1/", "requires_dist": null, "requires_python": null, "summary": "Format and compress XML documents", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"xmlformatter\">\n<h2>xmlformatter</h2>\n<p><a href=\"http://pamoller.com/xmlformatter.html\" rel=\"nofollow\">xmlformatter</a> is an Open Source Python package, which provides formatting of XML documents. <em>It is the replacement for the Python 2 package XmlFormatter, which has been removed from PyPi completely (see Notes)</em>. xmlformatter differs from others formatters by <em>handling whitespaces by a distinct set of formatting rules</em> - formatting element content by a object style and mixed content by a text style. You may find xmlformatter useful for corrections and presentations. In addition xmlformatter comes with a wrapper script named xmlformat.</p>\n</div>\n<div id=\"formatting-rules\">\n<h2>Formatting Rules</h2>\n<p>xmlformatter treats the element content from the following example as a object. The elements are associated with containers, like complex, or properties names, like real and imaginary. Text nodes are associated with property values, like 4.4E+12. Leading and trailing whitespaces are meaningless in this scenario like sequences of whitespaces. Leading and trailing whitespaces will be remove, sequences of whitespaces will be collapsed.</p>\n<pre>&lt;complex&gt;\n  &lt;real&gt;  4.4E+12&lt;/real&gt;\n &lt;imaginary&gt;5.4E-11\n   &lt;/imaginary&gt;\n&lt;/complex&gt;\n</pre>\n<p>The element content from the example above can be formatted by xmlformat:</p>\n<pre>$ xmlformat ele.xml\n</pre>\n<p>The following output shows the formatted XML document. xmlformatter has removed leading and trailing whitespaces from the text nodes and has indented the child elements equal. This formatting style is called object style.</p>\n<pre>&lt;complex&gt;\n  &lt;real&gt;4.4E+12&lt;/real&gt;\n  &lt;imaginary&gt;5.4E-11&lt;/imaginary&gt;\n&lt;/complex&gt;\n</pre>\n<p>xmlformatter treats the mixed content from the following example as a literal text with some markup. The outer element enclose poem encloses the text. The inline element em gives a text snippet a special meaning. Leading and trailing whitespaces enclosed by inline elements are misplaced. They will be adopted by the previous or following text node. Note: xmlformatter may insert a text node if necessary. Even sequences of whitespaces will be collapsed:</p>\n<pre>&lt;poem&gt; Es&lt;em&gt;   war&lt;/em&gt; einmal und &lt;em&gt;ist  &lt;/em&gt;nicht mehr...&lt;/poem&gt;\n</pre>\n<p>The following output shows the formatted XML document. xmlfromatter has removed leading and trailing whitespaces and has collapsed sequences of whitespaces. This formatting style is called text style.</p>\n<pre>&lt;poem&gt;Es &lt;em&gt;war&lt;/em&gt; einmal und &lt;em&gt;ist&lt;/em&gt; nicht mehr...&lt;/poem&gt;\n</pre>\n<p>Both styles are used while formatting a XML document. The formatting rules are:</p>\n<p>A: Surrounding whitespaces are removed from element content.</p>\n<p>B: Leading whitespaces are removed from element content.</p>\n<p>C: Trailing whitespaces are removed from element content.</p>\n<p>D: Leading whitespaces of inline elements are put to preceding text (or inserted) if necessary within mixed content.</p>\n<p>E: Trailing whitespaces of inline elements are put to following text (or inserted) if necessary within mixed content.</p>\n<p>F: Sequences of whitespaces (n&gt;2) are replaced by a single blank \u201d \u201d within element and mixed content.</p>\n<p>G: Linebreak and whitespace are used to indent elements within elements content.</p>\n<p>The following example shows the described whitespaces by their labels within a XML document:</p>\n<pre>&lt;root&gt;AAAA\nAAAA&lt;number&gt;BBBB4.4E+12CCC&lt;/number&gt;AAAA\nAAAA&lt;poem&gt;BBBBEs&lt;em&gt;DDDDwar&lt;/em&gt; einmal und &lt;em&gt;istEEEE&lt;/em&gt;nicht mehrF\nFFFFein &lt;strong&gt;riesengro\u00dfer&lt;/strong&gt;&lt;em&gt;DDDDTeddyb\u00e4r&lt;/em&gt;,F\nder a\u00dfFFFFdie &lt;em&gt;MilchEEEE&lt;/em&gt;und trank das BrotFFFF\nund als er starb da &lt;strong&gt;war erEEEE&lt;/strong&gt;&lt;em&gt;tot&lt;/em&gt;.CCCC&lt;/poem&gt;AAAA\n&lt;/root&gt;\n</pre>\n<p>The following output shows the formatted XML document:</p>\n<pre>&lt;root&gt;\n    &lt;number&gt;4.4E+12&lt;/number&gt;\n    &lt;poem&gt;Es &lt;em&gt;war&lt;/em&gt; einmal und &lt;em&gt;ist&lt;/em&gt; nicht mehr ein &lt;strong&gt;riesengro\u00dfer&lt;/strong&gt; &lt;em&gt;Teddyb\u00e4r&lt;/em&gt;, der a\u00df die &lt;em&gt;Milch&lt;/em&gt;und trank das Brot und als er starb da &lt;strong&gt;war er&lt;/strong&gt; &lt;em&gt;tot&lt;/em&gt;.&lt;/poem&gt;\n&lt;/root&gt;\n</pre>\n</div>\n<div id=\"class\">\n<h2>Class</h2>\n<pre>class xmlformatter.Formatter(compress ::= False, indent ::= 2, indent_char ::= \" \", inline ::= True, encoding_input ::= None, encoding_output ::= None, preserve ::= [ ])\n</pre>\n<p>The Formatter class can be used to format XML documents in scripts. By default all parts of the XML document will formatted. All descendants of elements listed by preserve are left unformatted. Setting the boolean property compress to True suppresses the indenting given by the indent and indent_char properties. Without a value given to encoding_input xmlformatter trys to determine the encoding from the XML document. On failure it use UTF-8 as default. encoding_output advises xmlformatter to encode the output explicit by the given value. Otherwise xmlformatter use the inpurt encoding. Setting the boolean property inline to False suppresses inline formatting. By default element content will be formatted everywhere - also within mixed content. The following example shows the usage of the xmlfromatter class:</p>\n<pre>import xmlformatter\n\nformatter = xmlformatter.Formatter(indent=\"1\", indent_char=\"\\t\", encoding_output=\"ISO-8859-1\", preserve=[\"literal\"])\nformatter.format_file(\"/home/pa/doc.xml\")\n</pre>\n<p>The example formats the XML document in /home/pa/doc.xml, preserving the element literal, indenting by the tab character and output in ISO-8859-1 encoding.</p>\n</div>\n<div id=\"members\">\n<h2>Members</h2>\n<pre>compress ::= False\n</pre>\n<p>Minify the XML document.</p>\n<pre>correct ::= True\n</pre>\n<p>Apply formatting rules to whitespaces.</p>\n<pre>indent ::= 2\n</pre>\n<p>Indent a child element in element content n-times by indent_char.</p>\n<pre>indent_char ::= \" \"\n</pre>\n<p>Indent a child element by this string.</p>\n<pre>input_encoding ::= None\n</pre>\n<p>Assume the XML document encoded by a not None value.</p>\n<pre>output_encoding ::= None\n</pre>\n<p>Encode the formatted XML document by a not None value.</p>\n<pre>preserve ::= [ ]\n</pre>\n<p>Skip formatting for all elements listed in preserve and all their descendants.</p>\n</div>\n<div id=\"methods\">\n<h2>Methods</h2>\n<pre>format_file(path)\n</pre>\n<p>Format a XML document given by a path.</p>\n<pre>format_string(xmldoc)\n</pre>\n<p>Format a XML document given by a string.</p>\n</div>\n<div id=\"cmd\">\n<h2>Cmd</h2>\n<pre>xmlformat [--preserve \"pre,literal\"] [--compress] [--indent num] [--indent-char char]\n          [--outfile file] [--encoding enc] [--outencoding enc] [--disable-inlineformatting]\n          [--dispable-correction] [--help] &lt; --infile file | file | - &gt;\n</pre>\n<p>xmlformat can read from STDIN, like:</p>\n<pre>$ cat /home/pa/doc.xml | xmlformat -\n</pre>\n</div>\n<div id=\"notes\">\n<h2>Notes</h2>\n<p>Remove XmlFormatter before installing xmlformatter:</p>\n<pre>$ pip uninstall XmlFormatter\n</pre>\n<p>After reinstallation replace the string \u201cformatter.formatter\u201d by \u201cformatter\u201d, \u201cpreserving\u201d by \u201cpreserve\u201d and \u201cindentChar\u201d by \u201cindent_char\u201d inside your scripts carefully. To reach compatibility with XmlFormatter call xmlformat with \u2013disable-inlineformatting or use inline=False in your scripts.</p>\n</div>\n\n          </div>"}, "last_serial": 985315, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "a8d343583b543cdb20fb073d04184e14", "sha256": "3fa7ce1c43834ebaafb0a6d2f3df08a638bb85d32c15224fd9958296f1f95edd"}, "downloads": -1, "filename": "xmlformatter-0.1.0.tar.gz", "has_sig": false, "md5_digest": "a8d343583b543cdb20fb073d04184e14", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14133, "upload_time": "2014-01-28T18:58:25", "upload_time_iso_8601": "2014-01-28T18:58:25.081432Z", "url": "https://files.pythonhosted.org/packages/a3/f7/e54251d55ae1d742d8ecb10420ee91bbbf1b0d6c6fe867ea9a7385935ce2/xmlformatter-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "af5cd269580026a460105e532082975d", "sha256": "1897b8c7868860d4b02c450d2f208391cb6f18bf60102ab0d89703b3088280e2"}, "downloads": -1, "filename": "xmlformatter-0.1.1.tar.gz", "has_sig": false, "md5_digest": "af5cd269580026a460105e532082975d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14146, "upload_time": "2014-01-29T16:52:23", "upload_time_iso_8601": "2014-01-29T16:52:23.958779Z", "url": "https://files.pythonhosted.org/packages/ba/c6/6f958639e34957aa986041b4e474bbbf5135eeb59dcb788e41719175d48c/xmlformatter-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "af5cd269580026a460105e532082975d", "sha256": "1897b8c7868860d4b02c450d2f208391cb6f18bf60102ab0d89703b3088280e2"}, "downloads": -1, "filename": "xmlformatter-0.1.1.tar.gz", "has_sig": false, "md5_digest": "af5cd269580026a460105e532082975d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14146, "upload_time": "2014-01-29T16:52:23", "upload_time_iso_8601": "2014-01-29T16:52:23.958779Z", "url": "https://files.pythonhosted.org/packages/ba/c6/6f958639e34957aa986041b4e474bbbf5135eeb59dcb788e41719175d48c/xmlformatter-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:24:59 2020"}