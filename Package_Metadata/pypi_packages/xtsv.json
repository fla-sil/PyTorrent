{"info": {"author": "dlazesz", "author_email": "devel@oliphant.nytud.hu", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# xtsv \u2013 A generic TSV-style format based intermodular communication framework and REST API implemented in Python\n\n- inter-module communication via a TSV-style format\n  - processing can be started or stopped at any module\n  - module dependency checks before processing\n  - easy to add new modules\n  - multiple alternative modules for some tasks\n- easy to use command-line interface\n- convenient REST API with simple web frontend\n- Python library API\n- Can be turned into a docker image and runnable docker form\n\nIf a bug is found please leave feedback with the exact details.\n\n## Citing and License\n\n``xtsv`` is licensed under the LGPL 3.0 license. The submodules have their\nown license.\n\nWe are currently working on a paper which should be cited when `xtsv` is\nused.\n\n## Requirements\n\n- Python 3.5 <=\n- [Optional, if required by any module] PyJNIus and OpenJDK 11 JDK\n\n## API documentation\n\n- `ModuleError`: The exception thrown when something bad happened to the\n  modules (e.g. the module could not be found or the ordering of the modules is\n  not feasible because of the required and supplied fields)\n- `HeaderError`: The exception thrown when the input could not satisfy the\n  required fields in its header\n- `jnius_config`: Set JAVA VM options and CLASSPATH for the PyJNIus library\n- `build_pipeline(inp_data, used_tools, available_tools, presets, conll_comments=False) -> iterator_on_output_lines`:\n  Build the current pipeline from the input data (stream, iterable or string),\n  the list of the elements of the desired pipeline chosen from the available\n  tools and presets returning an output iterator\n- `pipeline_rest_api(name, available_tools, presets, conll_comments, singleton_store=None, form_title, doc_link) -> app`:\n  Create a Flask application with the REST API and web frontend on the\n  available initialised tools and presets with the desired name. Run with a\n  wsgi server or Flask's built-in server with with `app.run()` (see [REST API\n  section](#REST-API))\n- `singleton_store_factory() -> singleton`: Singletons can be used for\n  initialisation of modules (eg. when the application is restarted frequently\n  and not all modules are used between restarts)\n- `process(stream, initialised_app, conll_comments=False) -> iterator_on_output_lines`:\n  A low-level API to run a specific member of the pipeline on a specific\n  input stream, returning an output iterator\n- `parser_skeleton(...) -> argparse.ArgumentParser(...)`: A CLI argument\n  parser skeleton can be further customized when needed\n- `add_bool_arg(parser, name, help_text, default=False, has_negative_variant=True)`:\n  A helper function to easily add BOOL arguments to the ArgumentParser class\n- `download(available_models=None, required_models=None)`: Download all (or a\nsubset of) large model files specified in models.yaml (filename can be\nchanged in the first parameter)\n\nTo be defined by the actual pipeline:\n\n- `tools`: The list of tools (see\n  [configuration](#creating-a-module-that-can-be-used-with-xtsv) for details)\n- `presets`: The dictionary of shorthands for tasks which are defined as list\n  of tools to be run in a pipeline (see\n  [configuration](#creating-a-module-that-can-be-used-with-xtsv) for details)\n\n## Data format\n\nThe input and output can be one of the following:\n\n- Free form text file\n- TSV file with fixed column order and without header (like CoNLL-U)\n- TSV file with arbitrary column order where the columns are identified by\n  the TSV header (main format of `xtsv`)\n\nThe TSV files are formatted as follows (closely resembling the CoNLL-U,\nvertical format):\n\n- The first line is the __header__ (when the column order is not fixed,\n  therefore the next module identifies columns by their names)\n- Columns are separated by TAB characters\n- One token per line (one column), the other columns contain the information\n  (stem, POS-tag, etc.) of that individual token\n- Sentences are separated by emtpy lines\n- If allowed by settings, zero or more comment lines (e.g. lines starting\n  with hashtag and space) immediately precede the sentences\n\nThe fields (represented by TSV columns) are identified by the header in the\nfirst line of the input. Each module can (but does not necessarily have to)\ndefine:\n\n- A set of source fields which is required to present in the input\n- A list of target fields which are to be generated to the output in order\n  - Newly generated fields are started from the right of the rightmost\n    column, the existing columns _should_ not be modified at all\n\nThe following types of modules can be defined by their input and output\nformat requirements:\n\n- __Tokeniser__: No source fields, no header, has target fields, free-format\n  text as input, TSV+header output\n- __Internal module__: Has source fields, has header, has target fields,\n  TSV+header input, TSV+header output\n- __Finalizer__: Has source fields, no header, no target fields, TSV+header\n  input, free-format text as output\n- __Fixed-order TSV importer__: No source fields, no header, has target\n  fields, Fixed-order TSV w/o header as input, TSV+header output\n- __Fixed-order TSV processor__: No source fields, no header, no target\n  fields, Fixed-order TSV w/o header as input, Fixed-order TSV w/o header as\n  output\n\n## Creating a module that can be used with `xtsv`\n\nThe following requirements apply for a new module:\n\n1. It must provide (at least) the mandatory API (see\n[emDummy](https://github.com/dlt-rilmta/emdummy) for a well-documented\nexample)\n1. It must conform to the (to be defined) field-name conventions and the\nformat conventions\n1. It must have an LGPL 3.0 compatible license\n\nThe following steps are needed to insert the new module into the pipeline:\n\n1. Add the new module as submodule to the repository\n1. Insert the configuration in `config.py`:\n\n    ```python\n    # Setup the tuple:\n    #   module name (ending with the filename the class defined in),\n    #   class,\n    #   friendly name,\n    #   args (tuple),\n    #   kwargs (dict)\n    em_dummy = (\n        'emdummy.dummytagger',\n        'DummyTagger',\n        'EXAMPLE (The friendly name of DummyTagger used in REST API form)',\n        ('Params', 'goes', 'here'),\n        {\n            'source_fields': {'Source field names'},\n            'target_fields': ['Target field names']\n        }\n    )\n    ```\n\n1. Add the new module to `tools` list in `config.py`, optionally also to\n`presets` dictionary\n\n    ```python\n    tools = [\n        ...,\n        (em_dummy, ('dummy-tagger', 'emDummy')),\n    ]\n    ```\n\n1. Test, commit and push\n\n## Installation\n\n- Can be installed as pip package: `pip3 install xtsv`\n- Or by using the git repository as submodule for another git repository\n\n## Usage\n\nHere we present the usage scenarios.\n\nTo extend the toolchain with new modules, [just add new modules to\n`config.py`](#creating-a-module-that-can-be-used-with-xtsv).\n\nSome examples of the realised applications:\n\n- [`emtsv`](https://github.com/dlt-rilmta/emtsv)\n- [`emmorphpy`](https://github.com/ppke-nlpg/emmorphpy/)\n- [`HunTag3`](https://github.com/ppke-nlpg/HunTag3)\n\n### Command-line interface\n\n- Multiple modules at once (not necessarily starting with raw text):\n\n  ```bash\n  echo \"Input text.\" | python3 ./main.py modules,separated,by,comas\n  ```\n\n- Modules _glued together_ one by one with the _standard *nix pipelines_\n__where users can interact with the data__ between the modules:\n\n  ```bash\n  echo \"Input text.\" | \\\n      python3 main.py module | \\\n      python3 main.py separated | \\\n      python3 main.py by | \\\n      python3 main.py comas\n  ```\n\n- Independently from the other options, `xtsv` can also be used with input or\noutput streams redirected or with string input (this applies to the runnable\ndocker form as well):\n\n  ```bash\n  python3 ./main.py modules,separated,by,comas -i input.txt -o output.txt\n  python3 ./main.py modules,separated,by,comas --text \"Input text.\"\n  ```\n\n### __Docker image__\n\nWith the appropriate Dockerfile `xtsv` can be used as follows:\n\n- Runnable docker form (CLI usage of docker image):\n\n  ```bash\n  cat input.txt | docker run -i xtsv-docker task,separated,by,comas > output.txt\n  ```\n\n- As service through Rest API (docker container)\n\n  ```bash\n  docker run --rm -p5000:5000 -it xtsv-docker  # REST API listening on http://0.0.0.0:5000\n  ```\n\n### REST API\n\nServer:\n\n- Docker image ([see above](#docker-image))\n- Any wsgi server (`uwsgi`, `gunicorn`, `waitress`, etc.) can be configured\nto run with a prepared wsgi file .\n- Debug server (Flask) __only for development (single threaded, one request\n  at a time)__:\n\n  When the server outputs a message like `* Running on` then it is ready to\n  accept requests on <http://127.0.0.1:5000>. (__We do not recommend using\n  this method in production as it is built atop of Flask debug server! Please\n  consider using the Docker image for REST API in production!__)\n\n- Any wsgi server (`uwsgi`, `gunicorn`, `waitress`, etc.) can be configured\n  to run with a prepared wsgi file .\n- Docker image (see above)\n\nClient:\n\n- Web fronted provided by `xtsv`\n- From Python (the URL contains the tools to be run separated by `/`):\n\n  ```python\n  >>> import requests\n  >>> # With input file\n  >>> r = requests.post('http://127.0.0.1:5000/tools/separated/by/slashes', files={'file': open('input.file', encoding='UTF-8')})\n  >>> print(r.text)\n  ...\n  >>> # With input text\n  >>> r = requests.post('http://127.0.0.1:5000/tools/separated/by/slashes', data={'text': 'Input text.'})\n  >>> print(r.text)\n  ...\n  >>> # CoNLL style comments can be enabled per request (disabled by default):\n  >>> r = requests.post('http://127.0.0.1:5000/tools/separated/by/slashes', files={'file':open('input.file', encoding='UTF-8')}, data={'conll_comments': True})\n  >>> print(r.text)\n  ...\n  ```\n\n  The server checks whether the module order is feasible, and returns an\n  error message if there are any problems.\n\n### As Python Library\n\nTODO\n\n1. Install xtsv in `xtsv` directory or make sure the emtsv installation is in\nthe `PYTHONPATH` environment variable.\n1. `import xtsv`\n1. Example:\n\n    ```Python\n    import sys\n    from xtsv import build_pipeline, jnius_config, process, pipeline_rest_api, singleton_store_factory\n\n    jnius_config.classpath_show_warning = False  # To suppress warning\n\n    tools = ...\n    presets = ...\n\n    # Imports end here. Must do only once per Python session\n\n    # Set input from any stream or iterable and output stream...\n    input_data = sys.stdin\n    output_iterator = sys.stdout\n    # Raw, or processed TSV input list and output file...\n    # input_data = iter(['A kutya', 'elment s\u00e9t\u00e1lni.'])  # Raw text line by line\n    # Processed data: header and the token POS-tag pairs line by line\n    # input_data = iter([['form', 'xpostag'], ['A', '[/Det|Art.Def]'], ['kutya', '[/N][Nom]'], ['elment', '[/V][Pst.NDef.3Sg]'], ['s\u00e9t\u00e1lni', '[/V][Inf]'], ['.', '.']])\n    # output_iterator = open('output.txt', 'w', encoding='UTF-8')  # File\n    # input_data = 'A kutya elment s\u00e9t\u00e1lni.'  # Or raw string in any acceptable format.\n\n    # Select a predefined task to do or provide your own list of pipeline\n    # elements\n    used_tools = ['tools', 'in', 'a', 'list']\n\n    conll_comments = True  # Enable the usage of CoNLL comments\n\n    # Run the pipeline on input and write result to the output...\n    output_iterator.writelines(build_pipeline(input_data, used_tools, tools, presets, conll_comments))\n\n    # Alternative: Run specific tool for input streams (still in emtsv format).\n    # Useful for training a module (see Huntag3 for details):\n    output_iterator.writelines(process(sys.stdin, an_inited_tool))\n\n    # Or process individual tokens further... WARNING: The header will be the\n    # first item in the iterator!\n    for tok in build_pipeline(input_data, used_tools, tools, presets, conll_comments):\n        if len(tok) > 1:  # Empty line (='\\n') means end of sentence\n            form, xpostag, *rest = tok.strip().split('\\t')  # Split to the expected columns\n\n    # Alternative2: Flask application (REST API)\n    singleton_store = singleton_store_factory()\n    app = application = pipeline_rest_api(name='e-magyar-tsv', available_tools=tools, presets=presets,\n                                conll_comments=conll_comments, singleton_store=singleton_store,\n                                form_title='e-magyar text processing system',\n                                doc_link='https://github.com/dlt-rilmta/emtsv')\n    # And run the Flask debug server separately\n    app.run()\n    ```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dlt-rilmta/xtsv", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "xtsv", "package_url": "https://pypi.org/project/xtsv/", "platform": "", "project_url": "https://pypi.org/project/xtsv/", "project_urls": {"Homepage": "https://github.com/dlt-rilmta/xtsv"}, "release_url": "https://pypi.org/project/xtsv/1.0/", "requires_dist": ["werkzeug", "Flask", "flask-restful"], "requires_python": ">=3.6", "summary": "A generic TSV-style format based intermodular communication framework and REST API", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>xtsv \u2013 A generic TSV-style format based intermodular communication framework and REST API implemented in Python</h1>\n<ul>\n<li>inter-module communication via a TSV-style format\n<ul>\n<li>processing can be started or stopped at any module</li>\n<li>module dependency checks before processing</li>\n<li>easy to add new modules</li>\n<li>multiple alternative modules for some tasks</li>\n</ul>\n</li>\n<li>easy to use command-line interface</li>\n<li>convenient REST API with simple web frontend</li>\n<li>Python library API</li>\n<li>Can be turned into a docker image and runnable docker form</li>\n</ul>\n<p>If a bug is found please leave feedback with the exact details.</p>\n<h2>Citing and License</h2>\n<p><code>xtsv</code> is licensed under the LGPL 3.0 license. The submodules have their\nown license.</p>\n<p>We are currently working on a paper which should be cited when <code>xtsv</code> is\nused.</p>\n<h2>Requirements</h2>\n<ul>\n<li>Python 3.5 &lt;=</li>\n<li>[Optional, if required by any module] PyJNIus and OpenJDK 11 JDK</li>\n</ul>\n<h2>API documentation</h2>\n<ul>\n<li><code>ModuleError</code>: The exception thrown when something bad happened to the\nmodules (e.g. the module could not be found or the ordering of the modules is\nnot feasible because of the required and supplied fields)</li>\n<li><code>HeaderError</code>: The exception thrown when the input could not satisfy the\nrequired fields in its header</li>\n<li><code>jnius_config</code>: Set JAVA VM options and CLASSPATH for the PyJNIus library</li>\n<li><code>build_pipeline(inp_data, used_tools, available_tools, presets, conll_comments=False) -&gt; iterator_on_output_lines</code>:\nBuild the current pipeline from the input data (stream, iterable or string),\nthe list of the elements of the desired pipeline chosen from the available\ntools and presets returning an output iterator</li>\n<li><code>pipeline_rest_api(name, available_tools, presets, conll_comments, singleton_store=None, form_title, doc_link) -&gt; app</code>:\nCreate a Flask application with the REST API and web frontend on the\navailable initialised tools and presets with the desired name. Run with a\nwsgi server or Flask's built-in server with with <code>app.run()</code> (see <a href=\"#REST-API\" rel=\"nofollow\">REST API\nsection</a>)</li>\n<li><code>singleton_store_factory() -&gt; singleton</code>: Singletons can be used for\ninitialisation of modules (eg. when the application is restarted frequently\nand not all modules are used between restarts)</li>\n<li><code>process(stream, initialised_app, conll_comments=False) -&gt; iterator_on_output_lines</code>:\nA low-level API to run a specific member of the pipeline on a specific\ninput stream, returning an output iterator</li>\n<li><code>parser_skeleton(...) -&gt; argparse.ArgumentParser(...)</code>: A CLI argument\nparser skeleton can be further customized when needed</li>\n<li><code>add_bool_arg(parser, name, help_text, default=False, has_negative_variant=True)</code>:\nA helper function to easily add BOOL arguments to the ArgumentParser class</li>\n<li><code>download(available_models=None, required_models=None)</code>: Download all (or a\nsubset of) large model files specified in models.yaml (filename can be\nchanged in the first parameter)</li>\n</ul>\n<p>To be defined by the actual pipeline:</p>\n<ul>\n<li><code>tools</code>: The list of tools (see\n<a href=\"#creating-a-module-that-can-be-used-with-xtsv\" rel=\"nofollow\">configuration</a> for details)</li>\n<li><code>presets</code>: The dictionary of shorthands for tasks which are defined as list\nof tools to be run in a pipeline (see\n<a href=\"#creating-a-module-that-can-be-used-with-xtsv\" rel=\"nofollow\">configuration</a> for details)</li>\n</ul>\n<h2>Data format</h2>\n<p>The input and output can be one of the following:</p>\n<ul>\n<li>Free form text file</li>\n<li>TSV file with fixed column order and without header (like CoNLL-U)</li>\n<li>TSV file with arbitrary column order where the columns are identified by\nthe TSV header (main format of <code>xtsv</code>)</li>\n</ul>\n<p>The TSV files are formatted as follows (closely resembling the CoNLL-U,\nvertical format):</p>\n<ul>\n<li>The first line is the <strong>header</strong> (when the column order is not fixed,\ntherefore the next module identifies columns by their names)</li>\n<li>Columns are separated by TAB characters</li>\n<li>One token per line (one column), the other columns contain the information\n(stem, POS-tag, etc.) of that individual token</li>\n<li>Sentences are separated by emtpy lines</li>\n<li>If allowed by settings, zero or more comment lines (e.g. lines starting\nwith hashtag and space) immediately precede the sentences</li>\n</ul>\n<p>The fields (represented by TSV columns) are identified by the header in the\nfirst line of the input. Each module can (but does not necessarily have to)\ndefine:</p>\n<ul>\n<li>A set of source fields which is required to present in the input</li>\n<li>A list of target fields which are to be generated to the output in order\n<ul>\n<li>Newly generated fields are started from the right of the rightmost\ncolumn, the existing columns <em>should</em> not be modified at all</li>\n</ul>\n</li>\n</ul>\n<p>The following types of modules can be defined by their input and output\nformat requirements:</p>\n<ul>\n<li><strong>Tokeniser</strong>: No source fields, no header, has target fields, free-format\ntext as input, TSV+header output</li>\n<li><strong>Internal module</strong>: Has source fields, has header, has target fields,\nTSV+header input, TSV+header output</li>\n<li><strong>Finalizer</strong>: Has source fields, no header, no target fields, TSV+header\ninput, free-format text as output</li>\n<li><strong>Fixed-order TSV importer</strong>: No source fields, no header, has target\nfields, Fixed-order TSV w/o header as input, TSV+header output</li>\n<li><strong>Fixed-order TSV processor</strong>: No source fields, no header, no target\nfields, Fixed-order TSV w/o header as input, Fixed-order TSV w/o header as\noutput</li>\n</ul>\n<h2>Creating a module that can be used with <code>xtsv</code></h2>\n<p>The following requirements apply for a new module:</p>\n<ol>\n<li>It must provide (at least) the mandatory API (see\n<a href=\"https://github.com/dlt-rilmta/emdummy\" rel=\"nofollow\">emDummy</a> for a well-documented\nexample)</li>\n<li>It must conform to the (to be defined) field-name conventions and the\nformat conventions</li>\n<li>It must have an LGPL 3.0 compatible license</li>\n</ol>\n<p>The following steps are needed to insert the new module into the pipeline:</p>\n<ol>\n<li>\n<p>Add the new module as submodule to the repository</p>\n</li>\n<li>\n<p>Insert the configuration in <code>config.py</code>:</p>\n<pre><span class=\"c1\"># Setup the tuple:</span>\n<span class=\"c1\">#   module name (ending with the filename the class defined in),</span>\n<span class=\"c1\">#   class,</span>\n<span class=\"c1\">#   friendly name,</span>\n<span class=\"c1\">#   args (tuple),</span>\n<span class=\"c1\">#   kwargs (dict)</span>\n<span class=\"n\">em_dummy</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n    <span class=\"s1\">'emdummy.dummytagger'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'DummyTagger'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'EXAMPLE (The friendly name of DummyTagger used in REST API form)'</span><span class=\"p\">,</span>\n    <span class=\"p\">(</span><span class=\"s1\">'Params'</span><span class=\"p\">,</span> <span class=\"s1\">'goes'</span><span class=\"p\">,</span> <span class=\"s1\">'here'</span><span class=\"p\">),</span>\n    <span class=\"p\">{</span>\n        <span class=\"s1\">'source_fields'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'Source field names'</span><span class=\"p\">},</span>\n        <span class=\"s1\">'target_fields'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'Target field names'</span><span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</pre>\n</li>\n<li>\n<p>Add the new module to <code>tools</code> list in <code>config.py</code>, optionally also to\n<code>presets</code> dictionary</p>\n<pre><span class=\"n\">tools</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"o\">...</span><span class=\"p\">,</span>\n    <span class=\"p\">(</span><span class=\"n\">em_dummy</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'dummy-tagger'</span><span class=\"p\">,</span> <span class=\"s1\">'emDummy'</span><span class=\"p\">)),</span>\n<span class=\"p\">]</span>\n</pre>\n</li>\n<li>\n<p>Test, commit and push</p>\n</li>\n</ol>\n<h2>Installation</h2>\n<ul>\n<li>Can be installed as pip package: <code>pip3 install xtsv</code></li>\n<li>Or by using the git repository as submodule for another git repository</li>\n</ul>\n<h2>Usage</h2>\n<p>Here we present the usage scenarios.</p>\n<p>To extend the toolchain with new modules, <a href=\"#creating-a-module-that-can-be-used-with-xtsv\" rel=\"nofollow\">just add new modules to\n<code>config.py</code></a>.</p>\n<p>Some examples of the realised applications:</p>\n<ul>\n<li><a href=\"https://github.com/dlt-rilmta/emtsv\" rel=\"nofollow\"><code>emtsv</code></a></li>\n<li><a href=\"https://github.com/ppke-nlpg/emmorphpy/\" rel=\"nofollow\"><code>emmorphpy</code></a></li>\n<li><a href=\"https://github.com/ppke-nlpg/HunTag3\" rel=\"nofollow\"><code>HunTag3</code></a></li>\n</ul>\n<h3>Command-line interface</h3>\n<ul>\n<li>\n<p>Multiple modules at once (not necessarily starting with raw text):</p>\n<pre><span class=\"nb\">echo</span> <span class=\"s2\">\"Input text.\"</span> <span class=\"p\">|</span> python3 ./main.py modules,separated,by,comas\n</pre>\n</li>\n<li>\n<p>Modules <em>glued together</em> one by one with the <em>standard *nix pipelines</em>\n<strong>where users can interact with the data</strong> between the modules:</p>\n<pre><span class=\"nb\">echo</span> <span class=\"s2\">\"Input text.\"</span> <span class=\"p\">|</span> <span class=\"se\">\\</span>\n    python3 main.py module <span class=\"p\">|</span> <span class=\"se\">\\</span>\n    python3 main.py separated <span class=\"p\">|</span> <span class=\"se\">\\</span>\n    python3 main.py by <span class=\"p\">|</span> <span class=\"se\">\\</span>\n    python3 main.py comas\n</pre>\n</li>\n<li>\n<p>Independently from the other options, <code>xtsv</code> can also be used with input or\noutput streams redirected or with string input (this applies to the runnable\ndocker form as well):</p>\n<pre>python3 ./main.py modules,separated,by,comas -i input.txt -o output.txt\npython3 ./main.py modules,separated,by,comas --text <span class=\"s2\">\"Input text.\"</span>\n</pre>\n</li>\n</ul>\n<h3><strong>Docker image</strong></h3>\n<p>With the appropriate Dockerfile <code>xtsv</code> can be used as follows:</p>\n<ul>\n<li>\n<p>Runnable docker form (CLI usage of docker image):</p>\n<pre>cat input.txt <span class=\"p\">|</span> docker run -i xtsv-docker task,separated,by,comas &gt; output.txt\n</pre>\n</li>\n<li>\n<p>As service through Rest API (docker container)</p>\n<pre>docker run --rm -p5000:5000 -it xtsv-docker  <span class=\"c1\"># REST API listening on http://0.0.0.0:5000</span>\n</pre>\n</li>\n</ul>\n<h3>REST API</h3>\n<p>Server:</p>\n<ul>\n<li>\n<p>Docker image (<a href=\"#docker-image\" rel=\"nofollow\">see above</a>)</p>\n</li>\n<li>\n<p>Any wsgi server (<code>uwsgi</code>, <code>gunicorn</code>, <code>waitress</code>, etc.) can be configured\nto run with a prepared wsgi file .</p>\n</li>\n<li>\n<p>Debug server (Flask) <strong>only for development (single threaded, one request\nat a time)</strong>:</p>\n<p>When the server outputs a message like <code>* Running on</code> then it is ready to\naccept requests on <a href=\"http://127.0.0.1:5000\" rel=\"nofollow\">http://127.0.0.1:5000</a>. (<strong>We do not recommend using\nthis method in production as it is built atop of Flask debug server! Please\nconsider using the Docker image for REST API in production!</strong>)</p>\n</li>\n<li>\n<p>Any wsgi server (<code>uwsgi</code>, <code>gunicorn</code>, <code>waitress</code>, etc.) can be configured\nto run with a prepared wsgi file .</p>\n</li>\n<li>\n<p>Docker image (see above)</p>\n</li>\n</ul>\n<p>Client:</p>\n<ul>\n<li>\n<p>Web fronted provided by <code>xtsv</code></p>\n</li>\n<li>\n<p>From Python (the URL contains the tools to be run separated by <code>/</code>):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># With input file</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">post</span><span class=\"p\">(</span><span class=\"s1\">'http://127.0.0.1:5000/tools/separated/by/slashes'</span><span class=\"p\">,</span> <span class=\"n\">files</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'file'</span><span class=\"p\">:</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'input.file'</span><span class=\"p\">,</span> <span class=\"n\">encoding</span><span class=\"o\">=</span><span class=\"s1\">'UTF-8'</span><span class=\"p\">)})</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># With input text</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">post</span><span class=\"p\">(</span><span class=\"s1\">'http://127.0.0.1:5000/tools/separated/by/slashes'</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'text'</span><span class=\"p\">:</span> <span class=\"s1\">'Input text.'</span><span class=\"p\">})</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># CoNLL style comments can be enabled per request (disabled by default):</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">post</span><span class=\"p\">(</span><span class=\"s1\">'http://127.0.0.1:5000/tools/separated/by/slashes'</span><span class=\"p\">,</span> <span class=\"n\">files</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'file'</span><span class=\"p\">:</span><span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'input.file'</span><span class=\"p\">,</span> <span class=\"n\">encoding</span><span class=\"o\">=</span><span class=\"s1\">'UTF-8'</span><span class=\"p\">)},</span> <span class=\"n\">data</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'conll_comments'</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">})</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n</pre>\n<p>The server checks whether the module order is feasible, and returns an\nerror message if there are any problems.</p>\n</li>\n</ul>\n<h3>As Python Library</h3>\n<p>TODO</p>\n<ol>\n<li>\n<p>Install xtsv in <code>xtsv</code> directory or make sure the emtsv installation is in\nthe <code>PYTHONPATH</code> environment variable.</p>\n</li>\n<li>\n<p><code>import xtsv</code></p>\n</li>\n<li>\n<p>Example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">from</span> <span class=\"nn\">xtsv</span> <span class=\"kn\">import</span> <span class=\"n\">build_pipeline</span><span class=\"p\">,</span> <span class=\"n\">jnius_config</span><span class=\"p\">,</span> <span class=\"n\">process</span><span class=\"p\">,</span> <span class=\"n\">pipeline_rest_api</span><span class=\"p\">,</span> <span class=\"n\">singleton_store_factory</span>\n\n<span class=\"n\">jnius_config</span><span class=\"o\">.</span><span class=\"n\">classpath_show_warning</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>  <span class=\"c1\"># To suppress warning</span>\n\n<span class=\"n\">tools</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"n\">presets</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n\n<span class=\"c1\"># Imports end here. Must do only once per Python session</span>\n\n<span class=\"c1\"># Set input from any stream or iterable and output stream...</span>\n<span class=\"n\">input_data</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">stdin</span>\n<span class=\"n\">output_iterator</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">stdout</span>\n<span class=\"c1\"># Raw, or processed TSV input list and output file...</span>\n<span class=\"c1\"># input_data = iter(['A kutya', 'elment s\u00e9t\u00e1lni.'])  # Raw text line by line</span>\n<span class=\"c1\"># Processed data: header and the token POS-tag pairs line by line</span>\n<span class=\"c1\"># input_data = iter([['form', 'xpostag'], ['A', '[/Det|Art.Def]'], ['kutya', '[/N][Nom]'], ['elment', '[/V][Pst.NDef.3Sg]'], ['s\u00e9t\u00e1lni', '[/V][Inf]'], ['.', '.']])</span>\n<span class=\"c1\"># output_iterator = open('output.txt', 'w', encoding='UTF-8')  # File</span>\n<span class=\"c1\"># input_data = 'A kutya elment s\u00e9t\u00e1lni.'  # Or raw string in any acceptable format.</span>\n\n<span class=\"c1\"># Select a predefined task to do or provide your own list of pipeline</span>\n<span class=\"c1\"># elements</span>\n<span class=\"n\">used_tools</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'tools'</span><span class=\"p\">,</span> <span class=\"s1\">'in'</span><span class=\"p\">,</span> <span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'list'</span><span class=\"p\">]</span>\n\n<span class=\"n\">conll_comments</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>  <span class=\"c1\"># Enable the usage of CoNLL comments</span>\n\n<span class=\"c1\"># Run the pipeline on input and write result to the output...</span>\n<span class=\"n\">output_iterator</span><span class=\"o\">.</span><span class=\"n\">writelines</span><span class=\"p\">(</span><span class=\"n\">build_pipeline</span><span class=\"p\">(</span><span class=\"n\">input_data</span><span class=\"p\">,</span> <span class=\"n\">used_tools</span><span class=\"p\">,</span> <span class=\"n\">tools</span><span class=\"p\">,</span> <span class=\"n\">presets</span><span class=\"p\">,</span> <span class=\"n\">conll_comments</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Alternative: Run specific tool for input streams (still in emtsv format).</span>\n<span class=\"c1\"># Useful for training a module (see Huntag3 for details):</span>\n<span class=\"n\">output_iterator</span><span class=\"o\">.</span><span class=\"n\">writelines</span><span class=\"p\">(</span><span class=\"n\">process</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">stdin</span><span class=\"p\">,</span> <span class=\"n\">an_inited_tool</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Or process individual tokens further... WARNING: The header will be the</span>\n<span class=\"c1\"># first item in the iterator!</span>\n<span class=\"k\">for</span> <span class=\"n\">tok</span> <span class=\"ow\">in</span> <span class=\"n\">build_pipeline</span><span class=\"p\">(</span><span class=\"n\">input_data</span><span class=\"p\">,</span> <span class=\"n\">used_tools</span><span class=\"p\">,</span> <span class=\"n\">tools</span><span class=\"p\">,</span> <span class=\"n\">presets</span><span class=\"p\">,</span> <span class=\"n\">conll_comments</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">tok</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>  <span class=\"c1\"># Empty line (='\\n') means end of sentence</span>\n        <span class=\"n\">form</span><span class=\"p\">,</span> <span class=\"n\">xpostag</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"n\">tok</span><span class=\"o\">.</span><span class=\"n\">strip</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\t</span><span class=\"s1\">'</span><span class=\"p\">)</span>  <span class=\"c1\"># Split to the expected columns</span>\n\n<span class=\"c1\"># Alternative2: Flask application (REST API)</span>\n<span class=\"n\">singleton_store</span> <span class=\"o\">=</span> <span class=\"n\">singleton_store_factory</span><span class=\"p\">()</span>\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">application</span> <span class=\"o\">=</span> <span class=\"n\">pipeline_rest_api</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'e-magyar-tsv'</span><span class=\"p\">,</span> <span class=\"n\">available_tools</span><span class=\"o\">=</span><span class=\"n\">tools</span><span class=\"p\">,</span> <span class=\"n\">presets</span><span class=\"o\">=</span><span class=\"n\">presets</span><span class=\"p\">,</span>\n                            <span class=\"n\">conll_comments</span><span class=\"o\">=</span><span class=\"n\">conll_comments</span><span class=\"p\">,</span> <span class=\"n\">singleton_store</span><span class=\"o\">=</span><span class=\"n\">singleton_store</span><span class=\"p\">,</span>\n                            <span class=\"n\">form_title</span><span class=\"o\">=</span><span class=\"s1\">'e-magyar text processing system'</span><span class=\"p\">,</span>\n                            <span class=\"n\">doc_link</span><span class=\"o\">=</span><span class=\"s1\">'https://github.com/dlt-rilmta/emtsv'</span><span class=\"p\">)</span>\n<span class=\"c1\"># And run the Flask debug server separately</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n</li>\n</ol>\n\n          </div>"}, "last_serial": 6985383, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "fe59013ee2b35b48e2890f8151f9ae05", "sha256": "95bfefa29bfa2a9c3a44eab1e2daf6adcbae2c3e2d32ddf8590796e04afd391c"}, "downloads": -1, "filename": "xtsv-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "fe59013ee2b35b48e2890f8151f9ae05", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19946, "upload_time": "2019-11-21T17:28:11", "upload_time_iso_8601": "2019-11-21T17:28:11.878499Z", "url": "https://files.pythonhosted.org/packages/db/95/7b2193fce68dcdf453584fd9da645ef608d5e1ebbbbeea2f8ac7be0dceae/xtsv-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "45bc4718fb9ee43c8e1f245ab1285039", "sha256": "fe2b60ae8147567667cc5817bde0070122533961f03b33c413792643e941b2be"}, "downloads": -1, "filename": "xtsv-0.0.1.tar.gz", "has_sig": false, "md5_digest": "45bc4718fb9ee43c8e1f245ab1285039", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 20675, "upload_time": "2019-11-21T17:28:14", "upload_time_iso_8601": "2019-11-21T17:28:14.834325Z", "url": "https://files.pythonhosted.org/packages/af/42/b5cfff3640e94a3efa7a67407aea0454f50bd098bf3a22cc57de4a435cd9/xtsv-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "165bf9abccbcb6c80f4d74256606097e", "sha256": "88091949f961fe2adbf9129cdc477e4bbe7f7581fe05443b75d75e791d1e0f3a"}, "downloads": -1, "filename": "xtsv-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "165bf9abccbcb6c80f4d74256606097e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19974, "upload_time": "2019-11-27T16:34:33", "upload_time_iso_8601": "2019-11-27T16:34:33.775007Z", "url": "https://files.pythonhosted.org/packages/60/cb/1f834eb37f07d3acf2d2998b96d3d33cd22d774e591d377f221f8f4beaeb/xtsv-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "068dc993de0a75ddb0ffa375bc2d52f0", "sha256": "0c3806cca19cc633dbacf259b8eb5eb451788e36cad616a357a09d5135ac20bb"}, "downloads": -1, "filename": "xtsv-0.0.2.tar.gz", "has_sig": false, "md5_digest": "068dc993de0a75ddb0ffa375bc2d52f0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 20699, "upload_time": "2019-11-27T16:34:36", "upload_time_iso_8601": "2019-11-27T16:34:36.260428Z", "url": "https://files.pythonhosted.org/packages/6a/41/2a531503a0ab093c3b20cbf3af6f0a75a8377a3bfb20e2901acf48834617/xtsv-0.0.2.tar.gz", "yanked": false}], "1.0": [{"comment_text": "", "digests": {"md5": "8a78c19933ed94aefbf7dd5aee7c8781", "sha256": "fc1203c564ff67d3d18a96a3baf649d9552bdf36b5550590120c7918851ab020"}, "downloads": -1, "filename": "xtsv-1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "8a78c19933ed94aefbf7dd5aee7c8781", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19928, "upload_time": "2020-04-09T12:11:58", "upload_time_iso_8601": "2020-04-09T12:11:58.856863Z", "url": "https://files.pythonhosted.org/packages/3a/da/5e3336e50e66325c95cec3485dda011c78b14e2fbe2889173292b1edcd43/xtsv-1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "af7f49648ba6791d19ab36bc56c013fc", "sha256": "5efb4a97c6cf06a1d4fac175dc2fbd35ac31f327c640e3b006b427e4f5ff542f"}, "downloads": -1, "filename": "xtsv-1.0.tar.gz", "has_sig": false, "md5_digest": "af7f49648ba6791d19ab36bc56c013fc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 16167, "upload_time": "2020-04-09T12:12:00", "upload_time_iso_8601": "2020-04-09T12:12:00.855694Z", "url": "https://files.pythonhosted.org/packages/df/18/f469dd8eb01fa6e80d8cd1308cb0bc161811e4ea8560b0129d31c9a6b71f/xtsv-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8a78c19933ed94aefbf7dd5aee7c8781", "sha256": "fc1203c564ff67d3d18a96a3baf649d9552bdf36b5550590120c7918851ab020"}, "downloads": -1, "filename": "xtsv-1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "8a78c19933ed94aefbf7dd5aee7c8781", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19928, "upload_time": "2020-04-09T12:11:58", "upload_time_iso_8601": "2020-04-09T12:11:58.856863Z", "url": "https://files.pythonhosted.org/packages/3a/da/5e3336e50e66325c95cec3485dda011c78b14e2fbe2889173292b1edcd43/xtsv-1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "af7f49648ba6791d19ab36bc56c013fc", "sha256": "5efb4a97c6cf06a1d4fac175dc2fbd35ac31f327c640e3b006b427e4f5ff542f"}, "downloads": -1, "filename": "xtsv-1.0.tar.gz", "has_sig": false, "md5_digest": "af7f49648ba6791d19ab36bc56c013fc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 16167, "upload_time": "2020-04-09T12:12:00", "upload_time_iso_8601": "2020-04-09T12:12:00.855694Z", "url": "https://files.pythonhosted.org/packages/df/18/f469dd8eb01fa6e80d8cd1308cb0bc161811e4ea8560b0129d31c9a6b71f/xtsv-1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:24:09 2020"}