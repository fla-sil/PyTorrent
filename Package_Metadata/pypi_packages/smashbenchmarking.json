{"info": {"author": "AMPlab, UC Berkeley", "author_email": "smashbenchmarking@googlegroups.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Topic :: Scientific/Engineering :: Bio-Informatics"], "description": "SMaSH\n=====\n\nA benchmarking toolkit for variant calling. For a full description of the SMaSH toolkit, including our datasets, results, and instructions for running SMaSH on EC2, see our website at smash.cs.berkeley.edu.\n\nIf you have any questions, please visit our support forum at https://groups.google.com/forum/#!forum/smash-benchmarking.\n\nSMaSH Overview\n--------------\nThe simplest SMaSH use case is to compare the VCF output of a variant calling algorithm against a validated truth set.\nWe do this by calling the bench.py script with three main arguments: the ground truth VCF, the predicted VCF, and a reference FASTA.\n\n## Evaluation\n\nSMaSH evaluates three main types of variants: SNPs, indels, and structural variants. Indels are defined as a variant shorter than 50\nbase pairs; longer variants are considered structural variants. Indels are further subdivided into insertions, deletions, inversions, and other; structural variants are likewise broken into insertions, deletions, and others.\n\nFirst, SMaSH checks all locations where both the true VCF and predicted VCF have variants. SNPs and indels are considered matches if the reference allele and first alternative allele are the same. Structural variants are considered matches if they are the same type of variant (insertion, deletion, or many-to-many) and if their position is with a certain breakpoint tolerance of the ground truth variant. (SV tolerance can be specified when calling SMaSH; the default value is 50 base pairs).\n\nHowever, the same underlying variants can be represented in different ways in the VCF format. SMaSH addresses this ambiguity through its rescue algorithm: for each variant in the truth VCF not matched in the predicted VCF, SMaSH expands the sequence described by the true and predicted callsets to a defined window size (can be specified at runtime, defaults to 100bp). If the sequences match, the true callset variants are marked as true positives, and the predicted callset variants are removed from the set of false positives.\n\n## Error rates\nFor non-synthetic datasets, the SMaSH output should express the likelihood that a given call in the ground truth VCF is incorrect. For example, if we bound the rate of incorrect calls for indels at 1 in 500, we pass that information to the benchmarking script with the option --indel_err 0.002 (SNP and SV error rates are passed similarly with --snp_err and --sv_err.) These error rates will be used to calculate error bars on the precision and recall rates in SMaSH output.\n\n## Outputs\n\nAfter evaluation, SMaSH reports results as human-readable text (default) or as tab-delimited output. The results include \ncounts of true positives, false positives, and false negatives; as well as precision and recall calculations with bounded error based on the error rates passed in at runtime; and some genotyping accuracy metrics. SMaSH can also output a fully annotated VCF file containing all variants from both the true and predicted VCF input files, tagged as true positive, false positive, false negative, or rescued.\n\n## Known False Positive Mode\n\nFor cases in which we do not have validated truth calls for the entire genome, SMaSH may be called with an additional known true positive VCF. With this option, SMaSH will further mark predicted calls as conflicting with known false positives if they are at the same location, of the same variant type, and have the same ref sequence. Precision will also be calculated with this false positive count.\n\nIf the ground truth data is not comprehensive, but we do not have a set of known false positive variants in VCF format, we can hide false positive-related stats in the output with the --hide_fp flag.\n\n## Normalization\n\nSMaSH also includes a normalization script which first cleans the VCF by upper-casing all alleles, removing homozygous reference and monomorphic allelic calls, and so on. The script then left-normalizes all calls as much as possible as a step toward standardizing ambiguous calls in a repetitive sequence. Although left-normalization is not strictly necessary to run SMaSH, it improves accuracy and reduces runtime by reducing the number of times the rescue algorithm needs to be called. Normalization can be performed as part of the evaluation script call by adding the --normalize option.\n\n## Assumptions and Limitations\n\n* There is presently no way to limit parts of the genome evaluated (e.g. the exome, etc).\n* At present SMaSH does not evaluate phasing.\n* SMaSH does not handle compound heterozygous variants.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/amplab/smash/", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "smashbenchmarking", "package_url": "https://pypi.org/project/smashbenchmarking/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/smashbenchmarking/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/amplab/smash/"}, "release_url": "https://pypi.org/project/smashbenchmarking/1.0.1/", "requires_dist": null, "requires_python": null, "summary": "Check the accuracy of one VCF callset against another", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A benchmarking toolkit for variant calling. For a full description of the SMaSH toolkit, including our datasets, results, and instructions for running SMaSH on EC2, see our website at smash.cs.berkeley.edu.</p>\n<p>If you have any questions, please visit our support forum at <a href=\"https://groups.google.com/forum/#!forum/smash-benchmarking\" rel=\"nofollow\">https://groups.google.com/forum/#!forum/smash-benchmarking</a>.</p>\n<div id=\"smash-overview\">\n<h2>SMaSH Overview</h2>\n<p>The simplest SMaSH use case is to compare the VCF output of a variant calling algorithm against a validated truth set.\nWe do this by calling the bench.py script with three main arguments: the ground truth VCF, the predicted VCF, and a reference FASTA.</p>\n<p>## Evaluation</p>\n<p>SMaSH evaluates three main types of variants: SNPs, indels, and structural variants. Indels are defined as a variant shorter than 50\nbase pairs; longer variants are considered structural variants. Indels are further subdivided into insertions, deletions, inversions, and other; structural variants are likewise broken into insertions, deletions, and others.</p>\n<p>First, SMaSH checks all locations where both the true VCF and predicted VCF have variants. SNPs and indels are considered matches if the reference allele and first alternative allele are the same. Structural variants are considered matches if they are the same type of variant (insertion, deletion, or many-to-many) and if their position is with a certain breakpoint tolerance of the ground truth variant. (SV tolerance can be specified when calling SMaSH; the default value is 50 base pairs).</p>\n<p>However, the same underlying variants can be represented in different ways in the VCF format. SMaSH addresses this ambiguity through its rescue algorithm: for each variant in the truth VCF not matched in the predicted VCF, SMaSH expands the sequence described by the true and predicted callsets to a defined window size (can be specified at runtime, defaults to 100bp). If the sequences match, the true callset variants are marked as true positives, and the predicted callset variants are removed from the set of false positives.</p>\n<p>## Error rates\nFor non-synthetic datasets, the SMaSH output should express the likelihood that a given call in the ground truth VCF is incorrect. For example, if we bound the rate of incorrect calls for indels at 1 in 500, we pass that information to the benchmarking script with the option \u2013indel_err 0.002 (SNP and SV error rates are passed similarly with \u2013snp_err and \u2013sv_err.) These error rates will be used to calculate error bars on the precision and recall rates in SMaSH output.</p>\n<p>## Outputs</p>\n<p>After evaluation, SMaSH reports results as human-readable text (default) or as tab-delimited output. The results include\ncounts of true positives, false positives, and false negatives; as well as precision and recall calculations with bounded error based on the error rates passed in at runtime; and some genotyping accuracy metrics. SMaSH can also output a fully annotated VCF file containing all variants from both the true and predicted VCF input files, tagged as true positive, false positive, false negative, or rescued.</p>\n<p>## Known False Positive Mode</p>\n<p>For cases in which we do not have validated truth calls for the entire genome, SMaSH may be called with an additional known true positive VCF. With this option, SMaSH will further mark predicted calls as conflicting with known false positives if they are at the same location, of the same variant type, and have the same ref sequence. Precision will also be calculated with this false positive count.</p>\n<p>If the ground truth data is not comprehensive, but we do not have a set of known false positive variants in VCF format, we can hide false positive-related stats in the output with the \u2013hide_fp flag.</p>\n<p>## Normalization</p>\n<p>SMaSH also includes a normalization script which first cleans the VCF by upper-casing all alleles, removing homozygous reference and monomorphic allelic calls, and so on. The script then left-normalizes all calls as much as possible as a step toward standardizing ambiguous calls in a repetitive sequence. Although left-normalization is not strictly necessary to run SMaSH, it improves accuracy and reduces runtime by reducing the number of times the rescue algorithm needs to be called. Normalization can be performed as part of the evaluation script call by adding the \u2013normalize option.</p>\n<p>## Assumptions and Limitations</p>\n<ul>\n<li>There is presently no way to limit parts of the genome evaluated (e.g. the exome, etc).</li>\n<li>At present SMaSH does not evaluate phasing.</li>\n<li>SMaSH does not handle compound heterozygous variants.</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 1122415, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "302eaccf1d587d7e9dc8481aa5766ead", "sha256": "29a5f699568df98c9909ae02fda6ff22cecc001be38c0a56f0ef65aed6336c25"}, "downloads": -1, "filename": "smashbenchmarking-1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "302eaccf1d587d7e9dc8481aa5766ead", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 49748, "upload_time": "2014-06-12T04:38:47", "upload_time_iso_8601": "2014-06-12T04:38:47.104735Z", "url": "https://files.pythonhosted.org/packages/5b/d0/19198ebe302fc7dce455553aae7ac71cde68ccc83dd7fa93dde4fb44f005/smashbenchmarking-1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0b4a7d2a0d205f07463bc3c0f1e9a445", "sha256": "728a79abe08ff376bfeae7aaf547e8a7099b19b472acd35ae0e79315b1528ea1"}, "downloads": -1, "filename": "smashbenchmarking-1.0.tar.gz", "has_sig": false, "md5_digest": "0b4a7d2a0d205f07463bc3c0f1e9a445", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31021, "upload_time": "2014-06-12T04:38:31", "upload_time_iso_8601": "2014-06-12T04:38:31.858833Z", "url": "https://files.pythonhosted.org/packages/e6/b4/afb69f56a0ad466758a5a7f65db23e0d7c1808328382a6e7752ace006ae0/smashbenchmarking-1.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "1a28b675d53adf3f1c944c43dc61b0e0", "sha256": "5a9b697e9fc498bd703fc98174552ff5104ba08b87e18b736aab413d5f973809"}, "downloads": -1, "filename": "smashbenchmarking-1.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "1a28b675d53adf3f1c944c43dc61b0e0", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 49784, "upload_time": "2014-06-12T05:16:41", "upload_time_iso_8601": "2014-06-12T05:16:41.521108Z", "url": "https://files.pythonhosted.org/packages/25/5b/38d336c398fd9d2d72f036f5138de6a8b5c353c5cbc55cbfdb3c148d881c/smashbenchmarking-1.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "77f0c979549a645f849ec28ef8afcda4", "sha256": "b92a944a167f27e73e6c921881643981cd3d2721b4b0fef20e07fe6cdecdfe2f"}, "downloads": -1, "filename": "smashbenchmarking-1.0.1.tar.gz", "has_sig": false, "md5_digest": "77f0c979549a645f849ec28ef8afcda4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31024, "upload_time": "2014-06-12T05:16:26", "upload_time_iso_8601": "2014-06-12T05:16:26.645656Z", "url": "https://files.pythonhosted.org/packages/55/c4/721c82a57d3e6b7e3dead4a5d38f1ab04afa314ed8843b9b5b5e72a13e7a/smashbenchmarking-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1a28b675d53adf3f1c944c43dc61b0e0", "sha256": "5a9b697e9fc498bd703fc98174552ff5104ba08b87e18b736aab413d5f973809"}, "downloads": -1, "filename": "smashbenchmarking-1.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "1a28b675d53adf3f1c944c43dc61b0e0", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 49784, "upload_time": "2014-06-12T05:16:41", "upload_time_iso_8601": "2014-06-12T05:16:41.521108Z", "url": "https://files.pythonhosted.org/packages/25/5b/38d336c398fd9d2d72f036f5138de6a8b5c353c5cbc55cbfdb3c148d881c/smashbenchmarking-1.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "77f0c979549a645f849ec28ef8afcda4", "sha256": "b92a944a167f27e73e6c921881643981cd3d2721b4b0fef20e07fe6cdecdfe2f"}, "downloads": -1, "filename": "smashbenchmarking-1.0.1.tar.gz", "has_sig": false, "md5_digest": "77f0c979549a645f849ec28ef8afcda4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31024, "upload_time": "2014-06-12T05:16:26", "upload_time_iso_8601": "2014-06-12T05:16:26.645656Z", "url": "https://files.pythonhosted.org/packages/55/c4/721c82a57d3e6b7e3dead4a5d38f1ab04afa314ed8843b9b5b5e72a13e7a/smashbenchmarking-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:58 2020"}