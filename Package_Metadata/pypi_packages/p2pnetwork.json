{"info": {"author": "Maurice Snoeren", "author_email": "macsnoeren@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Python implementation of a peer-to-peer decentralized network\nThis project provides a basic and simple peer-to-peer decentralized network classes (framework) to build your own network. Basic functionality of the nodes and the connection to and from these  nodes have been implemented. Application specific functionality is up to you to implement yourself. The intention of the module is to provide a good basis, without specific  implementation, so everyone is really free to implement like they would like to do.\n\nYou can use the project to implement a peer-to-peer decentralized network application, like Bitcoin or file sharing applications. I have used this software to provide my students, during a technical introduction to Blockchain, basic functionality. So, they were able to focus on how they would like to implement the Blockchain functionality and protocols. Without some direction from my side. Some of the students have used the code base to implement their application in C# or C++ for example. That is the freedom I would like to give to everyone.\n\nTo install the package for you to use:\n````\npip install p2pnetwork\n````\n\n# Evolution of the software\nWhile I started this project in the year 2018, it was mainly focussed to provide my students some software to be able to implement a peer-to-peer decentralized network. Without the hassle to design and create everything by themselves. While I did not had any experience with Python yet and there was not much time, I put everything in place in a very large pace. One of my students was annoyed by the camelCase programming style, while the Python community uses PEP-8. So, Christian decided to help me out and structured the software to the PEP style. Two years later, Samuel decided to clean up the code and create a real module from it. From then, I decided to jump in again and made the proposed changes, while maintaining the intention of the software: basic peer-to-peer decentralized functionality without specific implementation of protocols, so the programmer is able to freely implement these on their own. I still think that the software is a good basis and already have a new goal to use this software for a decentralized security application.\n\nOn github I was wondering around and noticed that others contributed as well to the code. No pull request, but still nice things. Therefore, I have not transformed the python software to a package to be available on pypi.org. Anyway, thanks for all the collaboration and I hope your will still help me out and others will join as well. It is possible to develop more specific applications by other modules and classes. Adding these to the repository will create a nice overview about the possibilities of these kind of applications.\n\n# Design\nAt first glance, peer-to-peer decentralized network applications are complex and difficult. While you need to provide some networking functionality on application level, the architecture is really simple. You have a network of the \"same\" nodes. The \"same\" means the same application (or an application that implements the same protocol).\n\nNodes are connected with each other. This means that each node provides a TCP/IP server on a specific port to provide inbound nodes to connect. The same node is able to connect to other nodes; called outbound nodes. When a nodes has a lot of connections with nodes in the network, the node will get most likely the required messages. You are able to send a message over the TCP/IP channel to the connected (inbound and outbound) nodes. How they react on the messages, is in your hands. When you would like to implement discovery, meaning to see which nodes are connected within the network and see if you would like to connect to those, you need to relay this message to the other nodes connected to you. Note that you need to make sure that the messages will not echo around, but that you keep track which messages you have received.\n\nHow to optimize these node connections depend on what you would like to solve. When providing file sharing, you would like to have a lot of connections when nodes have a large bandwith. However, when you are running Bitcoin, you would like to have your connections spread over the world to minimize the single identity problem.\n\n## You have two options\nBecause of my lack of Python experience, I started of with an event scheme that is used within C. When an event occurred, a callback function is called with the necessary variables to be able to process the request and implement the network protocol you desire.\n\nHowever, having a class and being able to extend the class with your own implementation is much nicer. Therefore, I started to change the code towards this new scheme. While maintaining the callback functionality, while my students where already busy. I could not let them be victim from my changes.\n\nSo, you have therefore two options:\n1. Implement your p2p application with one callback function\n2. Implement your p2p application by extending Node and NodeConnection classes\n\nTwo examples have been provided to show how both could be implemented: my_own_p2p_application_callback.py and my_own_p2p_application.py. My preference is to extend the classes, so we could build on each other ideas in the future.\n\n## Option 1: callback\nWhile this is the least prefferable method, you are in the lead! You need to create a callback method and spin off the Node from the module p2pnet. All events that happen within the network, will be transferred to the callback function. All application specific functionality can be implemented within this callback and the methods provided by the classes Node and NodeConnection. See below an example of an implemenation.\n\n````python\nfrom p2pnetwork import Node\n\n# node_callback\n#  event         : event name\n#  node          : the node (Node) that holds the node connections\n#  connected_node: the node (NodeConnection) that is involved\n#  data          : data that is send by the node (could be empty)\ndef node_callback(event, node, connected_node, data):\n    try:\n        if event != 'node_request_to_stop': # node_request_to_stop does not have any connected_node, while it is the main_node that is stopping!\n            print('Event: {} from main node {}: connected node {}: {}'.format(event, main_node.id, connected_node.id, data))\n\n    except Exception as e:\n        print(e)\n\n# The main node that is able to make connections to other nodes\n# and accept connections from other nodes on port 8001.\nnode = Node(\"127.0.0.1\", 8001, node_callback)\n\n# Do not forget to start it, it spins off a new thread!\nnode.start()\ntime.sleep(1)\n\n# Connect to another node, otherwise you do not have any network.\nnode.connect_with_node('127.0.0.1', 8002)\ntime.sleep(2)\n\n# Send some message to the other nodes, json style is required!\nnode_1.send_to_nodes({\"message\": \"hoi from node 1\"})\n\ntime.sleep(5) # Replace this sleep with your main loop!\n\n# Gracefully stop the node.\nnode.stop()\n````\n\n## Events that can occur\n\n### outbound_node_connected\nThe node connects with another node - ````node.connect_with_node('127.0.0.1', 8002)```` - and the connection is successfull. While the basic functionality is to exchange the node id's, no user data is involved.\n\n### inbound_node_connected\nAnother node has made a connection with this node and the connection is successfull. While the basic functionality is to exchange the node id's, no user data is involved.\n\n### outbound_node_disconnected\nA node, to which we had made a connection in the past, is disconnected.\n\n### inbound_node_disconnected\nA node, that had made a connection with us in the past, is disconnected.\n\n### node_message\nA node - ```` connected_node ```` - send a message. At this moment the basic functionality expects JSON format. It tries to decode JSON when the message is received. If it is not possible the message is rejected.\n\n### node_disconnect_with_outbound_node\nThe application actively wants to disconnect the the outboud node, a node with which we had made a connection in the past. You could send some last message to the node, that you are planning to disconnection for example.\n\n### node_request_to_stop\nThe main node, also the application, is stopping itself. Note that the variable connected_node is empty, while there is no connected node involved.\n\n## Option 2: Extending Node and NodeConnection\nTo implement your p2p network application, you could also extend the classes Node and/or NodeConnection. At least you need to extend the class Node with your own implementation. To implement the application specific functionality, you override the methods that represent the events. You are able to create different classes and methods to provide the code to implement the application protocol and functionality. While more files are involved an example is given by the next sections. \n\n### Extending class Node\nExtending the class Node is easy. Make sure you override at least all the events. Whenever, you extend the class, it is not possible to use the callback function anymore. See the example below.\n\n````python\nfrom p2pnetwork import Node\n\nclass MyOwnPeer2PeerNode (Node):\n    # Python class constructor\n    def __init__(self, host, port):\n        super(MyOwnPeer2PeerNode, self).__init__(host, port, None)\n\n    def outbound_node_connected(self, connected_node):\n        print(\"outbound_node_connected: \" + connected_node.id)\n\n    def inbound_node_connected(self, connected_node):\n        print(\"inbound_node_connected: \" + connected_node.id)\n\n    def inbound_node_disconnected(self, connected_node):\n        print(\"inbound_node_disconnected: \" + connected_node.id)\n\n    def outbound_node_disconnected(self, connected_node):\n        print(\"outbound_node_disconnected: \" + connected_node.id)\n\n    def node_message(self, connected_node, data):\n        print(\"node_message from \" + connected_node.id + \": \" + str(data))\n\n    def node_disconnect_with_outbound_node(self, connected_node):\n        print(\"node wants to disconnect with oher outbound node: \" + connected_node.id)\n\n    def node_request_to_stop(self):\n        print(\"node is requested to stop!\")\n\n    # OPTIONAL\n    # If you need to override the NodeConection as well, you need to\n    # override this method as well! In this method, you can initiate\n    # you own NodeConnection class.\n    def create_new_connection(self, connection, id, host, port):\n        return MyOwnNodeConnection(self, connection, id, host, port)\n````\n### Extend class NodeConnection\nThe NodeConnection class only hold the TCP/IP connection with the other node, to manage the different connection to and from the main node. It does not implement application specific elements. Mostly, you will only need to extend the Node class. However, when you would like to create an own NodeConnection class you can do this. Make sure that you override ````create_new_connection(self, connection, id, host, port)```` in the class Node, to make sure you initiate your own NodeConnection class. The example below shows some example.\n\n````python\nfrom p2pnetwork import Node\n\nclass MyOwnPeer2PeerNode (Node):\n    # Python class constructor\n    def __init__(self, host, port):\n        super(MyOwnPeer2PeerNode, self).__init__(host, port, None)\n\n    # Override event functions...\n\n    # Override this method to initiate your own NodeConnection class.\n    def create_new_connection(self, connection, id, host, port):\n        return MyOwnNodeConnection(self, connection, id, host, port)\n````\n\n````python\nfrom p2pnet import Node\n\nclass MyOwnNodeConnection (NodeConnection):\n    # Python class constructor\n    def __init__(self, connection, id, host, port):\n        super(MyOwnNodeConnection, self).__init__(connection, id, host, port)\n\n    # Check yourself what you would like to change and override!\n````\n\n### Using your new classes\nYou have extended the Node class and maybe also the NodeConnection class. The next aspect it to use your new p2p network application by using these classes. You create a new python file and start using your classes. See the example below.\n\n````python\nimport sys\nimport time\n\nfrom MyOwnPeer2PeerNode import MyOwnPeer2PeerNode\n\nnode = MyOwnPeer2PeerNode(\"127.0.0.1\", 8001)\ntime.sleep(1)\n\n# Do not forget to start your node!\nnode.start()\ntime.sleep(1)\n\n# Connect with another node, otherwise you do not create any network!\nnode.connect_with_node('127.0.0.1', 8002)\ntime.sleep(2)\n\n# Example of sending a message to the nodes.\nnode.send_to_nodes({\"message\": \"Hi there!\"})\n\ntime.sleep(5) # Create here your main loop of the application\n\nnode.stop()\n````\n\n# Examples\n\nExamples are available in the github repository of this project: https://github.com/macsnoeren/python-p2p-network. \n\n# Node and NodeConnection class                                       \n\nSee the Python documentation for these classes.\n\n# Show case: SecureNode\nAs show case, I have created the SecureNode class that extends the Node class. This node uses JSON, hashing and signing to communicate between the nodes. My main thought with this secure node is to be able to exchange data securely with each other and give others permissions to read the data for example. You are the owner of your data! Anyway, some project that I am currently working on. See the documentation of this specific class file.\n\n````python\nimport sys\nimport time\n\nfrom p2pnetwork.securenode import SecureNode\n\nnode = SecureNode(\"127.0.0.1\", 8001)\ntime.sleep(1)\n\nnode.start()\n````\nAn example node that uses SecureNode class is found in the example directory on github: ````secure_node.py````.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/macsnoeren/python-p2p-network", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "p2pnetwork", "package_url": "https://pypi.org/project/p2pnetwork/", "platform": "", "project_url": "https://pypi.org/project/p2pnetwork/", "project_urls": {"Homepage": "https://github.com/macsnoeren/python-p2p-network"}, "release_url": "https://pypi.org/project/p2pnetwork/0.0.2/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Python decentralized peer-to-peer network application implementation.", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Python implementation of a peer-to-peer decentralized network</h1>\n<p>This project provides a basic and simple peer-to-peer decentralized network classes (framework) to build your own network. Basic functionality of the nodes and the connection to and from these  nodes have been implemented. Application specific functionality is up to you to implement yourself. The intention of the module is to provide a good basis, without specific  implementation, so everyone is really free to implement like they would like to do.</p>\n<p>You can use the project to implement a peer-to-peer decentralized network application, like Bitcoin or file sharing applications. I have used this software to provide my students, during a technical introduction to Blockchain, basic functionality. So, they were able to focus on how they would like to implement the Blockchain functionality and protocols. Without some direction from my side. Some of the students have used the code base to implement their application in C# or C++ for example. That is the freedom I would like to give to everyone.</p>\n<p>To install the package for you to use:</p>\n<pre><code>pip install p2pnetwork\n</code></pre>\n<h1>Evolution of the software</h1>\n<p>While I started this project in the year 2018, it was mainly focussed to provide my students some software to be able to implement a peer-to-peer decentralized network. Without the hassle to design and create everything by themselves. While I did not had any experience with Python yet and there was not much time, I put everything in place in a very large pace. One of my students was annoyed by the camelCase programming style, while the Python community uses PEP-8. So, Christian decided to help me out and structured the software to the PEP style. Two years later, Samuel decided to clean up the code and create a real module from it. From then, I decided to jump in again and made the proposed changes, while maintaining the intention of the software: basic peer-to-peer decentralized functionality without specific implementation of protocols, so the programmer is able to freely implement these on their own. I still think that the software is a good basis and already have a new goal to use this software for a decentralized security application.</p>\n<p>On github I was wondering around and noticed that others contributed as well to the code. No pull request, but still nice things. Therefore, I have not transformed the python software to a package to be available on pypi.org. Anyway, thanks for all the collaboration and I hope your will still help me out and others will join as well. It is possible to develop more specific applications by other modules and classes. Adding these to the repository will create a nice overview about the possibilities of these kind of applications.</p>\n<h1>Design</h1>\n<p>At first glance, peer-to-peer decentralized network applications are complex and difficult. While you need to provide some networking functionality on application level, the architecture is really simple. You have a network of the \"same\" nodes. The \"same\" means the same application (or an application that implements the same protocol).</p>\n<p>Nodes are connected with each other. This means that each node provides a TCP/IP server on a specific port to provide inbound nodes to connect. The same node is able to connect to other nodes; called outbound nodes. When a nodes has a lot of connections with nodes in the network, the node will get most likely the required messages. You are able to send a message over the TCP/IP channel to the connected (inbound and outbound) nodes. How they react on the messages, is in your hands. When you would like to implement discovery, meaning to see which nodes are connected within the network and see if you would like to connect to those, you need to relay this message to the other nodes connected to you. Note that you need to make sure that the messages will not echo around, but that you keep track which messages you have received.</p>\n<p>How to optimize these node connections depend on what you would like to solve. When providing file sharing, you would like to have a lot of connections when nodes have a large bandwith. However, when you are running Bitcoin, you would like to have your connections spread over the world to minimize the single identity problem.</p>\n<h2>You have two options</h2>\n<p>Because of my lack of Python experience, I started of with an event scheme that is used within C. When an event occurred, a callback function is called with the necessary variables to be able to process the request and implement the network protocol you desire.</p>\n<p>However, having a class and being able to extend the class with your own implementation is much nicer. Therefore, I started to change the code towards this new scheme. While maintaining the callback functionality, while my students where already busy. I could not let them be victim from my changes.</p>\n<p>So, you have therefore two options:</p>\n<ol>\n<li>Implement your p2p application with one callback function</li>\n<li>Implement your p2p application by extending Node and NodeConnection classes</li>\n</ol>\n<p>Two examples have been provided to show how both could be implemented: my_own_p2p_application_callback.py and my_own_p2p_application.py. My preference is to extend the classes, so we could build on each other ideas in the future.</p>\n<h2>Option 1: callback</h2>\n<p>While this is the least prefferable method, you are in the lead! You need to create a callback method and spin off the Node from the module p2pnet. All events that happen within the network, will be transferred to the callback function. All application specific functionality can be implemented within this callback and the methods provided by the classes Node and NodeConnection. See below an example of an implemenation.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">p2pnetwork</span> <span class=\"kn\">import</span> <span class=\"n\">Node</span>\n\n<span class=\"c1\"># node_callback</span>\n<span class=\"c1\">#  event         : event name</span>\n<span class=\"c1\">#  node          : the node (Node) that holds the node connections</span>\n<span class=\"c1\">#  connected_node: the node (NodeConnection) that is involved</span>\n<span class=\"c1\">#  data          : data that is send by the node (could be empty)</span>\n<span class=\"k\">def</span> <span class=\"nf\">node_callback</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">connected_node</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">event</span> <span class=\"o\">!=</span> <span class=\"s1\">'node_request_to_stop'</span><span class=\"p\">:</span> <span class=\"c1\"># node_request_to_stop does not have any connected_node, while it is the main_node that is stopping!</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Event: </span><span class=\"si\">{}</span><span class=\"s1\"> from main node </span><span class=\"si\">{}</span><span class=\"s1\">: connected node </span><span class=\"si\">{}</span><span class=\"s1\">: </span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">main_node</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">connected_node</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">))</span>\n\n    <span class=\"k\">except</span> <span class=\"ne\">Exception</span> <span class=\"k\">as</span> <span class=\"n\">e</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># The main node that is able to make connections to other nodes</span>\n<span class=\"c1\"># and accept connections from other nodes on port 8001.</span>\n<span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">Node</span><span class=\"p\">(</span><span class=\"s2\">\"127.0.0.1\"</span><span class=\"p\">,</span> <span class=\"mi\">8001</span><span class=\"p\">,</span> <span class=\"n\">node_callback</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Do not forget to start it, it spins off a new thread!</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Connect to another node, otherwise you do not have any network.</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">connect_with_node</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">8002</span><span class=\"p\">)</span>\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Send some message to the other nodes, json style is required!</span>\n<span class=\"n\">node_1</span><span class=\"o\">.</span><span class=\"n\">send_to_nodes</span><span class=\"p\">({</span><span class=\"s2\">\"message\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hoi from node 1\"</span><span class=\"p\">})</span>\n\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"c1\"># Replace this sleep with your main loop!</span>\n\n<span class=\"c1\"># Gracefully stop the node.</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span>\n</pre>\n<h2>Events that can occur</h2>\n<h3>outbound_node_connected</h3>\n<p>The node connects with another node - <code>node.connect_with_node('127.0.0.1', 8002)</code> - and the connection is successfull. While the basic functionality is to exchange the node id's, no user data is involved.</p>\n<h3>inbound_node_connected</h3>\n<p>Another node has made a connection with this node and the connection is successfull. While the basic functionality is to exchange the node id's, no user data is involved.</p>\n<h3>outbound_node_disconnected</h3>\n<p>A node, to which we had made a connection in the past, is disconnected.</p>\n<h3>inbound_node_disconnected</h3>\n<p>A node, that had made a connection with us in the past, is disconnected.</p>\n<h3>node_message</h3>\n<p>A node - <code>connected_node</code> - send a message. At this moment the basic functionality expects JSON format. It tries to decode JSON when the message is received. If it is not possible the message is rejected.</p>\n<h3>node_disconnect_with_outbound_node</h3>\n<p>The application actively wants to disconnect the the outboud node, a node with which we had made a connection in the past. You could send some last message to the node, that you are planning to disconnection for example.</p>\n<h3>node_request_to_stop</h3>\n<p>The main node, also the application, is stopping itself. Note that the variable connected_node is empty, while there is no connected node involved.</p>\n<h2>Option 2: Extending Node and NodeConnection</h2>\n<p>To implement your p2p network application, you could also extend the classes Node and/or NodeConnection. At least you need to extend the class Node with your own implementation. To implement the application specific functionality, you override the methods that represent the events. You are able to create different classes and methods to provide the code to implement the application protocol and functionality. While more files are involved an example is given by the next sections.</p>\n<h3>Extending class Node</h3>\n<p>Extending the class Node is easy. Make sure you override at least all the events. Whenever, you extend the class, it is not possible to use the callback function anymore. See the example below.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">p2pnetwork</span> <span class=\"kn\">import</span> <span class=\"n\">Node</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOwnPeer2PeerNode</span> <span class=\"p\">(</span><span class=\"n\">Node</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Python class constructor</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">MyOwnPeer2PeerNode</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">outbound_node_connected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connected_node</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"outbound_node_connected: \"</span> <span class=\"o\">+</span> <span class=\"n\">connected_node</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">inbound_node_connected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connected_node</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"inbound_node_connected: \"</span> <span class=\"o\">+</span> <span class=\"n\">connected_node</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">inbound_node_disconnected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connected_node</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"inbound_node_disconnected: \"</span> <span class=\"o\">+</span> <span class=\"n\">connected_node</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">outbound_node_disconnected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connected_node</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"outbound_node_disconnected: \"</span> <span class=\"o\">+</span> <span class=\"n\">connected_node</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">node_message</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connected_node</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"node_message from \"</span> <span class=\"o\">+</span> <span class=\"n\">connected_node</span><span class=\"o\">.</span><span class=\"n\">id</span> <span class=\"o\">+</span> <span class=\"s2\">\": \"</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">node_disconnect_with_outbound_node</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connected_node</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"node wants to disconnect with oher outbound node: \"</span> <span class=\"o\">+</span> <span class=\"n\">connected_node</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">node_request_to_stop</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"node is requested to stop!\"</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># OPTIONAL</span>\n    <span class=\"c1\"># If you need to override the NodeConection as well, you need to</span>\n    <span class=\"c1\"># override this method as well! In this method, you can initiate</span>\n    <span class=\"c1\"># you own NodeConnection class.</span>\n    <span class=\"k\">def</span> <span class=\"nf\">create_new_connection</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"nb\">id</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">MyOwnNodeConnection</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"nb\">id</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">)</span>\n</pre>\n<h3>Extend class NodeConnection</h3>\n<p>The NodeConnection class only hold the TCP/IP connection with the other node, to manage the different connection to and from the main node. It does not implement application specific elements. Mostly, you will only need to extend the Node class. However, when you would like to create an own NodeConnection class you can do this. Make sure that you override <code>create_new_connection(self, connection, id, host, port)</code> in the class Node, to make sure you initiate your own NodeConnection class. The example below shows some example.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">p2pnetwork</span> <span class=\"kn\">import</span> <span class=\"n\">Node</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOwnPeer2PeerNode</span> <span class=\"p\">(</span><span class=\"n\">Node</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Python class constructor</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">MyOwnPeer2PeerNode</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Override event functions...</span>\n\n    <span class=\"c1\"># Override this method to initiate your own NodeConnection class.</span>\n    <span class=\"k\">def</span> <span class=\"nf\">create_new_connection</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"nb\">id</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">MyOwnNodeConnection</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"nb\">id</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">p2pnet</span> <span class=\"kn\">import</span> <span class=\"n\">Node</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOwnNodeConnection</span> <span class=\"p\">(</span><span class=\"n\">NodeConnection</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Python class constructor</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"nb\">id</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">MyOwnNodeConnection</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"nb\">id</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Check yourself what you would like to change and override!</span>\n</pre>\n<h3>Using your new classes</h3>\n<p>You have extended the Node class and maybe also the NodeConnection class. The next aspect it to use your new p2p network application by using these classes. You create a new python file and start using your classes. See the example below.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">MyOwnPeer2PeerNode</span> <span class=\"kn\">import</span> <span class=\"n\">MyOwnPeer2PeerNode</span>\n\n<span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">MyOwnPeer2PeerNode</span><span class=\"p\">(</span><span class=\"s2\">\"127.0.0.1\"</span><span class=\"p\">,</span> <span class=\"mi\">8001</span><span class=\"p\">)</span>\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Do not forget to start your node!</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Connect with another node, otherwise you do not create any network!</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">connect_with_node</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">8002</span><span class=\"p\">)</span>\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Example of sending a message to the nodes.</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">send_to_nodes</span><span class=\"p\">({</span><span class=\"s2\">\"message\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Hi there!\"</span><span class=\"p\">})</span>\n\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"c1\"># Create here your main loop of the application</span>\n\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span>\n</pre>\n<h1>Examples</h1>\n<p>Examples are available in the github repository of this project: <a href=\"https://github.com/macsnoeren/python-p2p-network\" rel=\"nofollow\">https://github.com/macsnoeren/python-p2p-network</a>.</p>\n<h1>Node and NodeConnection class</h1>\n<p>See the Python documentation for these classes.</p>\n<h1>Show case: SecureNode</h1>\n<p>As show case, I have created the SecureNode class that extends the Node class. This node uses JSON, hashing and signing to communicate between the nodes. My main thought with this secure node is to be able to exchange data securely with each other and give others permissions to read the data for example. You are the owner of your data! Anyway, some project that I am currently working on. See the documentation of this specific class file.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">p2pnetwork.securenode</span> <span class=\"kn\">import</span> <span class=\"n\">SecureNode</span>\n\n<span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">SecureNode</span><span class=\"p\">(</span><span class=\"s2\">\"127.0.0.1\"</span><span class=\"p\">,</span> <span class=\"mi\">8001</span><span class=\"p\">)</span>\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n</pre>\n<p>An example node that uses SecureNode class is found in the example directory on github: <code>secure_node.py</code>.</p>\n\n          </div>"}, "last_serial": 7163491, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "5a80008c353bbfc936ee1f7443e49183", "sha256": "d3ff84a35ac04e4ec63478edee4284d31423ffcb8c3a2fe91df8b3740fb597ab"}, "downloads": -1, "filename": "p2pnetwork-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "5a80008c353bbfc936ee1f7443e49183", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 28533, "upload_time": "2020-05-03T19:15:30", "upload_time_iso_8601": "2020-05-03T19:15:30.290918Z", "url": "https://files.pythonhosted.org/packages/74/4f/d31f90b9897082a119265e9c6fc3505bc39601604708ec682c126ed0853f/p2pnetwork-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "65eaed989a4bc7b9a34a0cc285515536", "sha256": "b014d1dd6b452cdf96e3c096d7026dd15fcbbf2232622278aab08d18126b8158"}, "downloads": -1, "filename": "p2pnetwork-0.0.1.tar.gz", "has_sig": false, "md5_digest": "65eaed989a4bc7b9a34a0cc285515536", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 17977, "upload_time": "2020-05-03T19:15:32", "upload_time_iso_8601": "2020-05-03T19:15:32.416377Z", "url": "https://files.pythonhosted.org/packages/35/56/5639ab1f36fee9df77fe63fc051139a3703357880a7e4e1185ef3831f639/p2pnetwork-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "f14ef5415db0fa971742f17ec526e9dc", "sha256": "fa391d7ae46dd054b715d22d20cc4e115bd95f6fd45feb8afd7109fa31d291ff"}, "downloads": -1, "filename": "p2pnetwork-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "f14ef5415db0fa971742f17ec526e9dc", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 31245, "upload_time": "2020-05-04T11:01:45", "upload_time_iso_8601": "2020-05-04T11:01:45.437994Z", "url": "https://files.pythonhosted.org/packages/96/3d/23adbdffdc04d6fa43877f1dfdd4603ed4be03eb39a61845e12064692b8d/p2pnetwork-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ba2afb23722b40a5c4f781d7d7378e03", "sha256": "81183ac70af54319859e1cc2019392d63036caa3f9d31e556cbf64a041b69547"}, "downloads": -1, "filename": "p2pnetwork-0.0.2.tar.gz", "has_sig": false, "md5_digest": "ba2afb23722b40a5c4f781d7d7378e03", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 20385, "upload_time": "2020-05-04T11:01:46", "upload_time_iso_8601": "2020-05-04T11:01:46.397941Z", "url": "https://files.pythonhosted.org/packages/b1/cc/281a69cb18b0e40928b4bb2697760be29159c232313c750841fb1f55dd60/p2pnetwork-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f14ef5415db0fa971742f17ec526e9dc", "sha256": "fa391d7ae46dd054b715d22d20cc4e115bd95f6fd45feb8afd7109fa31d291ff"}, "downloads": -1, "filename": "p2pnetwork-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "f14ef5415db0fa971742f17ec526e9dc", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 31245, "upload_time": "2020-05-04T11:01:45", "upload_time_iso_8601": "2020-05-04T11:01:45.437994Z", "url": "https://files.pythonhosted.org/packages/96/3d/23adbdffdc04d6fa43877f1dfdd4603ed4be03eb39a61845e12064692b8d/p2pnetwork-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ba2afb23722b40a5c4f781d7d7378e03", "sha256": "81183ac70af54319859e1cc2019392d63036caa3f9d31e556cbf64a041b69547"}, "downloads": -1, "filename": "p2pnetwork-0.0.2.tar.gz", "has_sig": false, "md5_digest": "ba2afb23722b40a5c4f781d7d7378e03", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 20385, "upload_time": "2020-05-04T11:01:46", "upload_time_iso_8601": "2020-05-04T11:01:46.397941Z", "url": "https://files.pythonhosted.org/packages/b1/cc/281a69cb18b0e40928b4bb2697760be29159c232313c750841fb1f55dd60/p2pnetwork-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:22 2020"}