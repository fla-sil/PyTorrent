{"info": {"author": "Vincent Morello", "author_email": "vmorello@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: Unix", "Programming Language :: C", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Scientific/Engineering :: Astronomy"], "description": "[![arXiv](http://img.shields.io/badge/astro.ph-2004.03701-B31B1B.svg)](https://arxiv.org/abs/2004.03701)   ![License](https://img.shields.io/badge/License-MIT-green.svg)   ![Python versions](https://img.shields.io/pypi/pyversions/riptide-ffa.svg)   [![Build Status](https://travis-ci.com/v-morello/riptide.svg?branch=master)](https://travis-ci.com/v-morello/riptide)   [![codecov](https://codecov.io/gh/v-morello/riptide/branch/master/graph/badge.svg)](https://codecov.io/gh/v-morello/riptide)\n\n# riptide\n\n__riptide__ (\"sea**r**ch**i**ng for **p**ulsars in the **ti**me **d**omain\") is a pulsar searching package implementing the Fast Folding Algorithm (FFA), the theoretically optimal search method for periodic signals. Its interface is entirely in python while the core algorithms are implemented in C. riptide provides:  \n\n* A library of functions and classes to use interactively to process dedispersed time series  \n* A pipeline executable to process a set of DM trials and output a list of candidate files and other useful data products  \n\n## Citation\n\nIf using ``riptide`` contributes to a project that leads to a scientific publication, please cite the article:  \n[\"Optimal periodicity searching: Revisiting the Fast Folding Algorithm for large scale pulsar surveys\"](https://arxiv.org/abs/2004.03701)\n\n\n## Sensitivity of the FFA\n\nThe article covers the topic of the FFA's sensitivity in theory, here is a practical example on a faint source. Below is an L-band observation of [PSR J1932-3655](https://www.atnf.csiro.au/people/joh414/ppdata/1932-3655.html) from the [SUPERB survey](https://arxiv.org/abs/1706.04459), significantly offset from the true position of the source. The first plot was obtained by folding the observation using the known ephemeris of the pulsar with [PSRCHIVE](http://psrchive.sourceforge.net/). This is one of the faintest known pulsar instances identifiable in the survey.\n\n![psrchive_plot](images/J1932-3655_psrchive_small.png \"PSRCHIVE direct ephemeris folding\")  \n\nAnd below is a blind detection of the pulsar, running `riptide` on the same observation:  \n![riptide_plot](images/J1932-3655_blind_detection.png \"riptide blind detection\")\n\n\n## Installation\n\nThe easiest method is to use pip install, which pulls the latest release from the python package index and installs all required dependencies:\n```\npip install riptide-ffa\n```\n\nThe alternative is to clone the repository, especially if you want the absolute latest version:\n```bash\ngit clone https://github.com/v-morello/riptide\n```\n\nAnd then in the base directory of `riptide` run\n\n```bash\nmake install\n```\n\nThis simply runs ``pip install`` in [editable mode](https://pip.pypa.io/en/latest/reference/pip_install/#editable-installs), which means you can freely edit the code. It also installs any required dependencies with ``pip`` that are not present already. The installer also adds a link to the riptide pipeline executable `rffa` in your python environment using a [console_scripts entry point](https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html), check that it all works by typing:\n\n```\nrffa -h\n```\nAnd you should see the full help of the pipeline application, see below for details on how to use it.\n\n## Basic Usage: searching a single time series\n\nThe core functionality of riptide is to take a single time series as an input and calculate its *periodogram*: the S/N as a function of trial period and trial pulse width.\n\n#### Load a time series, or create a fake one\n\nTime series (or single DM trials) are encapsulated in the `TimeSeries` class. We can either create an artificial train of pulses (plus some white noise) for test purposes, or load some real data created with some popular pulsar software packages.\n\n```python\nfrom riptide import TimeSeries\n# Generate an artificial train of pulses with a white noise background\n# 600s of data, 256us sampling time, a period of pi seconds and a duty cycle of 2%\ntseries_fake = TimeSeries.generate(length=600.0, tsamp=256e-6, period=3.14159, ducy=0.02)\n\n# We can also load an existing time series created by PRESTO or SIGPROC\ntseries_presto = TimeSeries.from_presto_inf(\"~/work/pulsars/presto_time_series/J1855+0307/J1855+0307_DM400.00.inf\")\ntseries_sigproc = TimeSeries.from_sigproc(\"~/work/pulsars/sigproc_time_series/J0636-4549.sigproc.tim\")\n```\n\n\n#### Computing and manipulating periodograms\n\nPeriodograms are computed with the `ffa_search` function, which takes as input a `TimeSeries` and many keyword arguments. The search period range is specified via `period_min` and `period_max`. The duty cycle resolution of the search is set by `bins_min` and `bins_max`; due to how the search is performed under the hood, it is recommended to make `bins_max` approximately 10% larger than `bins_min`.\n\n```python\nfrom riptide import ffa_search\n\n# Compute periodogram\nts, plan, pgram = ffa_search(tseries_sigproc, rmed_width=4.0, period_min=1.0, period_max=10.0, bins_min=240, bins_max=260)\n\n# Plot S/N vs. trial period\npgram.display()\n```\n\n`ffa_search` returns three outputs:\n\n1. The de-reddened and normalised copy of the input time series that was actually searched  \n2. The search plan that was followed, specifying how the data was iteratively downsampled across the entire search period range  \n3. The output `Periodogram`  \n\nPeriodograms are actually two-dimensional: they represent a S/N as a function of both trial period and trial width, as shown below. The `display()` method only shows S/N for the best trial width.\n\n```python\n# Trial periods in seconds, trial widths in number of phase bins, output S/N\n# pgram.display() only shows pgram.snrs.max(axis=1)\nprint(pgram.periods.size, pgram.widths.size, pgram.snrs.shape)\n> 124778 10 (124778, 10)\n```\n\n#### Important detail: the metadata attribute\n\nAll `TimeSeries` objects and all derived data products (periodogram, pulsar search candidates, etc.) in riptide have a `metadata` dictionary carrying whatever information provided by the software package that created the input time series data. There is of course no header standardization for such data in pulsar astronomy, and the information contained in `metadata` will therefore vary across software packages and observatories. We do however attempt to guarantee some metadata uniformity in riptide, by always enforcing the presence of the following metadata keys and their associated data types:\n\n* `dm`: `float`, dispersion measure of the input data  \n* `fname`: `str`, original file name  \n* `mjd`: `float`, epoch of observation  \n* `source_name`: `str`  \n* `skycoord`: `astropy.SkyCoord`, source coordinates  \n* `tobs`: `float`, integration time in seconds  \n\nIf these required attributes were not provided by the original creator of the time series, they are set to the special value `None`. Here's for example the metadata for the SIGPROC time series loaded in code snippet above:\n\n```python\nprint(tseries_sigproc.metadata)\n\n{'az_start': 0.0,\n 'barycentric': 0,\n 'data_type': 2,\n 'dm': 26.31,\n 'fch1': 1581.8046875,\n 'fname': '/home/vince/work/pulsars/sigproc_time_series/J0636-4549.sigproc.tim',\n 'machine_id': 10,\n 'mjd': 56771.1303125,\n 'nbits': 32,\n 'nchans': 1,\n 'nifs': 1,\n 'refdm': 26.31,\n 'skycoord': <SkyCoord (ICRS): (ra, dec) in deg\n    (99.17595833, -45.73472222)>,\n 'source_name': 'G255.3-21.9_s',\n 'src_dej': -454405.0,\n 'src_raj': 63642.23,\n 'telescope_id': 4,\n 'tobs': 557.040896,\n 'tsamp': 6.4e-05,\n 'tstart': 56771.1303125,\n 'za_start': 0.0}\n```\n\n### FFA base functions\n\nThe python interface of `riptide` exposes some lower-level functions related to calculating the folding transform (interchangeably called FFA transform) of input data at some base integer period. See the documentation of these functions for more details. These are:  \n\n* `ffa2`: FFA transform of a two-dimensional input that represents a pulse stack. The `m` lines of the input represent pulses in chronological order, and the `p` columns represent the phase dimension  \n* `ffa1`: FFA transform of a one-dimensional input, that represents a time series. The function simply selects the largest number of entire pulses that fit in the data, reshapes them into a two-dimensional array, and calls `ffa2()`  \n* `ffafreq`: Returns the trial folding frequencies corresponding to every line in the output of an FFA transform  \n* `ffaprd`: Same as `ffafreq`, but returns trial periods instead  \n\n## Large scale survey usage: searching multiple DM trials\n\nMultiple DM trial searches are managed by the `Pipeline` class in the `riptide.pipeline` submodule. The pipeline executable needs at least two inputs:  \n\n* A configuration file in `YAML` format, of which a number of well-commented examples are provided in the `pipeline/config` directory. To get started, copy one of these files, read the comments carefully and start tweaking them to your needs. The pipeline is highly configurable. This is where the user must specify any required parameters of the observation (e.g. top and bottom bserving frequencies), the desired DM range, the desired search period range(s) and the duty cycle resolution, etc.  \n* A list of dedispersed time series files, obtained by dedispersing the same observation. If your files have been produced by [PRESTO](https://github.com/scottransom/presto), you need to pass a list of `.inf` header files (the associated `.dat` files are expected to be in the same directory). *The input data format must be specified in the configuration file.*  \n\nYou can optionally set an output directory as well, otherwise the current working directory is used. Here's an example:\n```\nrffa --config myConfig.yml --outdir search_output input_data/*.inf\n```\n\nType `rffa -h` for help on all arguments accepted by the pipeline application. Once the pipeline finishes, the following data products will be written in the specified output directory:  \n\n* A CSV table of all detected periodogram peaks across all DM trials  \n* A CSV table of clusters, obtained by grouping together peaks with frequencies close to each other  \n* A CSV table of candidates, which will have the same entries as the clusters table, unless you have enabled harmonic filtering in the config file. In this case any cluster that was flagged as a harmonic of another is removed from the final candidate list.  \n* One JSON file per candidate, which can be loaded using `riptide.load_json()` and plotted / manipulated. These contain header information, a table of peaks associated to the candidate, and a sub-integration plots obtained by folding the DM trial at which they were detected with the highest S/N.  \n* One PNG plot per candidate, if the associated option was enabled in the configuration file.  \n\n\n## Docker image\n\nThe riptide Dockerfile is located in the 'docker' subdirectory. To build the image, simply type:\n\n```bash\nmake docker\n```\n\nWhich builds an image named `riptide-ffa`. Both python and ipython are installed within the docker image. To start a container:\n\n```bash\ndocker run -it --rm riptide-ffa\n```\n\nRefer to your favourite docker cheat sheet for further information and advanced usage.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/v-morello/riptide", "keywords": "", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "riptide-ffa", "package_url": "https://pypi.org/project/riptide-ffa/", "platform": "", "project_url": "https://pypi.org/project/riptide-ffa/", "project_urls": {"Homepage": "https://github.com/v-morello/riptide"}, "release_url": "https://pypi.org/project/riptide-ffa/0.1.4/", "requires_dist": null, "requires_python": "", "summary": "Pulsar searching with the Fast Folding Algorithm (FFA)", "version": "0.1.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://arxiv.org/abs/2004.03701\" rel=\"nofollow\"><img alt=\"arXiv\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9d49885e123468639833586d496068b1064e209d/687474703a2f2f696d672e736869656c64732e696f2f62616467652f617374726f2e70682d323030342e30333730312d4233314231422e737667\"></a>   <img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5aab1d039acf22567ba072834df6bce204ac48ad/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d677265656e2e737667\">   <img alt=\"Python versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f64ba0712e290c6e5f93ea712eab97f838b9cfc6/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f726970746964652d6666612e737667\">   <a href=\"https://travis-ci.com/v-morello/riptide\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5aa79d329246abd584bbe7514c74f425a4a9b1cc/68747470733a2f2f7472617669732d63692e636f6d2f762d6d6f72656c6c6f2f726970746964652e7376673f6272616e63683d6d6173746572\"></a>   <a href=\"https://codecov.io/gh/v-morello/riptide\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3aa66dd6fc4cd78b6abbb4df2cafe47053100d42/68747470733a2f2f636f6465636f762e696f2f67682f762d6d6f72656c6c6f2f726970746964652f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<h1>riptide</h1>\n<p><strong>riptide</strong> (\"sea<strong>r</strong>ch<strong>i</strong>ng for <strong>p</strong>ulsars in the <strong>ti</strong>me <strong>d</strong>omain\") is a pulsar searching package implementing the Fast Folding Algorithm (FFA), the theoretically optimal search method for periodic signals. Its interface is entirely in python while the core algorithms are implemented in C. riptide provides:</p>\n<ul>\n<li>A library of functions and classes to use interactively to process dedispersed time series</li>\n<li>A pipeline executable to process a set of DM trials and output a list of candidate files and other useful data products</li>\n</ul>\n<h2>Citation</h2>\n<p>If using <code>riptide</code> contributes to a project that leads to a scientific publication, please cite the article:<br>\n<a href=\"https://arxiv.org/abs/2004.03701\" rel=\"nofollow\">\"Optimal periodicity searching: Revisiting the Fast Folding Algorithm for large scale pulsar surveys\"</a></p>\n<h2>Sensitivity of the FFA</h2>\n<p>The article covers the topic of the FFA's sensitivity in theory, here is a practical example on a faint source. Below is an L-band observation of <a href=\"https://www.atnf.csiro.au/people/joh414/ppdata/1932-3655.html\" rel=\"nofollow\">PSR J1932-3655</a> from the <a href=\"https://arxiv.org/abs/1706.04459\" rel=\"nofollow\">SUPERB survey</a>, significantly offset from the true position of the source. The first plot was obtained by folding the observation using the known ephemeris of the pulsar with <a href=\"http://psrchive.sourceforge.net/\" rel=\"nofollow\">PSRCHIVE</a>. This is one of the faintest known pulsar instances identifiable in the survey.</p>\n<p><img alt=\"psrchive_plot\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/245ce9bf92289edd8da88a385664af7326ad4881/696d616765732f4a313933322d333635355f70737263686976655f736d616c6c2e706e67\"></p>\n<p>And below is a blind detection of the pulsar, running <code>riptide</code> on the same observation:<br>\n<img alt=\"riptide_plot\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/91a351814d640347992a467ec37785eea0121994/696d616765732f4a313933322d333635355f626c696e645f646574656374696f6e2e706e67\"></p>\n<h2>Installation</h2>\n<p>The easiest method is to use pip install, which pulls the latest release from the python package index and installs all required dependencies:</p>\n<pre><code>pip install riptide-ffa\n</code></pre>\n<p>The alternative is to clone the repository, especially if you want the absolute latest version:</p>\n<pre>git clone https://github.com/v-morello/riptide\n</pre>\n<p>And then in the base directory of <code>riptide</code> run</p>\n<pre>make install\n</pre>\n<p>This simply runs <code>pip install</code> in <a href=\"https://pip.pypa.io/en/latest/reference/pip_install/#editable-installs\" rel=\"nofollow\">editable mode</a>, which means you can freely edit the code. It also installs any required dependencies with <code>pip</code> that are not present already. The installer also adds a link to the riptide pipeline executable <code>rffa</code> in your python environment using a <a href=\"https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html\" rel=\"nofollow\">console_scripts entry point</a>, check that it all works by typing:</p>\n<pre><code>rffa -h\n</code></pre>\n<p>And you should see the full help of the pipeline application, see below for details on how to use it.</p>\n<h2>Basic Usage: searching a single time series</h2>\n<p>The core functionality of riptide is to take a single time series as an input and calculate its <em>periodogram</em>: the S/N as a function of trial period and trial pulse width.</p>\n<h4>Load a time series, or create a fake one</h4>\n<p>Time series (or single DM trials) are encapsulated in the <code>TimeSeries</code> class. We can either create an artificial train of pulses (plus some white noise) for test purposes, or load some real data created with some popular pulsar software packages.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">riptide</span> <span class=\"kn\">import</span> <span class=\"n\">TimeSeries</span>\n<span class=\"c1\"># Generate an artificial train of pulses with a white noise background</span>\n<span class=\"c1\"># 600s of data, 256us sampling time, a period of pi seconds and a duty cycle of 2%</span>\n<span class=\"n\">tseries_fake</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"o\">.</span><span class=\"n\">generate</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"o\">=</span><span class=\"mf\">600.0</span><span class=\"p\">,</span> <span class=\"n\">tsamp</span><span class=\"o\">=</span><span class=\"mf\">256e-6</span><span class=\"p\">,</span> <span class=\"n\">period</span><span class=\"o\">=</span><span class=\"mf\">3.14159</span><span class=\"p\">,</span> <span class=\"n\">ducy</span><span class=\"o\">=</span><span class=\"mf\">0.02</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># We can also load an existing time series created by PRESTO or SIGPROC</span>\n<span class=\"n\">tseries_presto</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"o\">.</span><span class=\"n\">from_presto_inf</span><span class=\"p\">(</span><span class=\"s2\">\"~/work/pulsars/presto_time_series/J1855+0307/J1855+0307_DM400.00.inf\"</span><span class=\"p\">)</span>\n<span class=\"n\">tseries_sigproc</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"o\">.</span><span class=\"n\">from_sigproc</span><span class=\"p\">(</span><span class=\"s2\">\"~/work/pulsars/sigproc_time_series/J0636-4549.sigproc.tim\"</span><span class=\"p\">)</span>\n</pre>\n<h4>Computing and manipulating periodograms</h4>\n<p>Periodograms are computed with the <code>ffa_search</code> function, which takes as input a <code>TimeSeries</code> and many keyword arguments. The search period range is specified via <code>period_min</code> and <code>period_max</code>. The duty cycle resolution of the search is set by <code>bins_min</code> and <code>bins_max</code>; due to how the search is performed under the hood, it is recommended to make <code>bins_max</code> approximately 10% larger than <code>bins_min</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">riptide</span> <span class=\"kn\">import</span> <span class=\"n\">ffa_search</span>\n\n<span class=\"c1\"># Compute periodogram</span>\n<span class=\"n\">ts</span><span class=\"p\">,</span> <span class=\"n\">plan</span><span class=\"p\">,</span> <span class=\"n\">pgram</span> <span class=\"o\">=</span> <span class=\"n\">ffa_search</span><span class=\"p\">(</span><span class=\"n\">tseries_sigproc</span><span class=\"p\">,</span> <span class=\"n\">rmed_width</span><span class=\"o\">=</span><span class=\"mf\">4.0</span><span class=\"p\">,</span> <span class=\"n\">period_min</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">period_max</span><span class=\"o\">=</span><span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"n\">bins_min</span><span class=\"o\">=</span><span class=\"mi\">240</span><span class=\"p\">,</span> <span class=\"n\">bins_max</span><span class=\"o\">=</span><span class=\"mi\">260</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Plot S/N vs. trial period</span>\n<span class=\"n\">pgram</span><span class=\"o\">.</span><span class=\"n\">display</span><span class=\"p\">()</span>\n</pre>\n<p><code>ffa_search</code> returns three outputs:</p>\n<ol>\n<li>The de-reddened and normalised copy of the input time series that was actually searched</li>\n<li>The search plan that was followed, specifying how the data was iteratively downsampled across the entire search period range</li>\n<li>The output <code>Periodogram</code></li>\n</ol>\n<p>Periodograms are actually two-dimensional: they represent a S/N as a function of both trial period and trial width, as shown below. The <code>display()</code> method only shows S/N for the best trial width.</p>\n<pre><span class=\"c1\"># Trial periods in seconds, trial widths in number of phase bins, output S/N</span>\n<span class=\"c1\"># pgram.display() only shows pgram.snrs.max(axis=1)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">pgram</span><span class=\"o\">.</span><span class=\"n\">periods</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"n\">pgram</span><span class=\"o\">.</span><span class=\"n\">widths</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"n\">pgram</span><span class=\"o\">.</span><span class=\"n\">snrs</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;</span> <span class=\"mi\">124778</span> <span class=\"mi\">10</span> <span class=\"p\">(</span><span class=\"mi\">124778</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n</pre>\n<h4>Important detail: the metadata attribute</h4>\n<p>All <code>TimeSeries</code> objects and all derived data products (periodogram, pulsar search candidates, etc.) in riptide have a <code>metadata</code> dictionary carrying whatever information provided by the software package that created the input time series data. There is of course no header standardization for such data in pulsar astronomy, and the information contained in <code>metadata</code> will therefore vary across software packages and observatories. We do however attempt to guarantee some metadata uniformity in riptide, by always enforcing the presence of the following metadata keys and their associated data types:</p>\n<ul>\n<li><code>dm</code>: <code>float</code>, dispersion measure of the input data</li>\n<li><code>fname</code>: <code>str</code>, original file name</li>\n<li><code>mjd</code>: <code>float</code>, epoch of observation</li>\n<li><code>source_name</code>: <code>str</code></li>\n<li><code>skycoord</code>: <code>astropy.SkyCoord</code>, source coordinates</li>\n<li><code>tobs</code>: <code>float</code>, integration time in seconds</li>\n</ul>\n<p>If these required attributes were not provided by the original creator of the time series, they are set to the special value <code>None</code>. Here's for example the metadata for the SIGPROC time series loaded in code snippet above:</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">tseries_sigproc</span><span class=\"o\">.</span><span class=\"n\">metadata</span><span class=\"p\">)</span>\n\n<span class=\"p\">{</span><span class=\"s1\">'az_start'</span><span class=\"p\">:</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span>\n <span class=\"s1\">'barycentric'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n <span class=\"s1\">'data_type'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n <span class=\"s1\">'dm'</span><span class=\"p\">:</span> <span class=\"mf\">26.31</span><span class=\"p\">,</span>\n <span class=\"s1\">'fch1'</span><span class=\"p\">:</span> <span class=\"mf\">1581.8046875</span><span class=\"p\">,</span>\n <span class=\"s1\">'fname'</span><span class=\"p\">:</span> <span class=\"s1\">'/home/vince/work/pulsars/sigproc_time_series/J0636-4549.sigproc.tim'</span><span class=\"p\">,</span>\n <span class=\"s1\">'machine_id'</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>\n <span class=\"s1\">'mjd'</span><span class=\"p\">:</span> <span class=\"mf\">56771.1303125</span><span class=\"p\">,</span>\n <span class=\"s1\">'nbits'</span><span class=\"p\">:</span> <span class=\"mi\">32</span><span class=\"p\">,</span>\n <span class=\"s1\">'nchans'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n <span class=\"s1\">'nifs'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n <span class=\"s1\">'refdm'</span><span class=\"p\">:</span> <span class=\"mf\">26.31</span><span class=\"p\">,</span>\n <span class=\"s1\">'skycoord'</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">SkyCoord</span> <span class=\"p\">(</span><span class=\"n\">ICRS</span><span class=\"p\">):</span> <span class=\"p\">(</span><span class=\"n\">ra</span><span class=\"p\">,</span> <span class=\"n\">dec</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">deg</span>\n    <span class=\"p\">(</span><span class=\"mf\">99.17595833</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">45.73472222</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span>\n <span class=\"s1\">'source_name'</span><span class=\"p\">:</span> <span class=\"s1\">'G255.3-21.9_s'</span><span class=\"p\">,</span>\n <span class=\"s1\">'src_dej'</span><span class=\"p\">:</span> <span class=\"o\">-</span><span class=\"mf\">454405.0</span><span class=\"p\">,</span>\n <span class=\"s1\">'src_raj'</span><span class=\"p\">:</span> <span class=\"mf\">63642.23</span><span class=\"p\">,</span>\n <span class=\"s1\">'telescope_id'</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n <span class=\"s1\">'tobs'</span><span class=\"p\">:</span> <span class=\"mf\">557.040896</span><span class=\"p\">,</span>\n <span class=\"s1\">'tsamp'</span><span class=\"p\">:</span> <span class=\"mf\">6.4e-05</span><span class=\"p\">,</span>\n <span class=\"s1\">'tstart'</span><span class=\"p\">:</span> <span class=\"mf\">56771.1303125</span><span class=\"p\">,</span>\n <span class=\"s1\">'za_start'</span><span class=\"p\">:</span> <span class=\"mf\">0.0</span><span class=\"p\">}</span>\n</pre>\n<h3>FFA base functions</h3>\n<p>The python interface of <code>riptide</code> exposes some lower-level functions related to calculating the folding transform (interchangeably called FFA transform) of input data at some base integer period. See the documentation of these functions for more details. These are:</p>\n<ul>\n<li><code>ffa2</code>: FFA transform of a two-dimensional input that represents a pulse stack. The <code>m</code> lines of the input represent pulses in chronological order, and the <code>p</code> columns represent the phase dimension</li>\n<li><code>ffa1</code>: FFA transform of a one-dimensional input, that represents a time series. The function simply selects the largest number of entire pulses that fit in the data, reshapes them into a two-dimensional array, and calls <code>ffa2()</code></li>\n<li><code>ffafreq</code>: Returns the trial folding frequencies corresponding to every line in the output of an FFA transform</li>\n<li><code>ffaprd</code>: Same as <code>ffafreq</code>, but returns trial periods instead</li>\n</ul>\n<h2>Large scale survey usage: searching multiple DM trials</h2>\n<p>Multiple DM trial searches are managed by the <code>Pipeline</code> class in the <code>riptide.pipeline</code> submodule. The pipeline executable needs at least two inputs:</p>\n<ul>\n<li>A configuration file in <code>YAML</code> format, of which a number of well-commented examples are provided in the <code>pipeline/config</code> directory. To get started, copy one of these files, read the comments carefully and start tweaking them to your needs. The pipeline is highly configurable. This is where the user must specify any required parameters of the observation (e.g. top and bottom bserving frequencies), the desired DM range, the desired search period range(s) and the duty cycle resolution, etc.</li>\n<li>A list of dedispersed time series files, obtained by dedispersing the same observation. If your files have been produced by <a href=\"https://github.com/scottransom/presto\" rel=\"nofollow\">PRESTO</a>, you need to pass a list of <code>.inf</code> header files (the associated <code>.dat</code> files are expected to be in the same directory). <em>The input data format must be specified in the configuration file.</em></li>\n</ul>\n<p>You can optionally set an output directory as well, otherwise the current working directory is used. Here's an example:</p>\n<pre><code>rffa --config myConfig.yml --outdir search_output input_data/*.inf\n</code></pre>\n<p>Type <code>rffa -h</code> for help on all arguments accepted by the pipeline application. Once the pipeline finishes, the following data products will be written in the specified output directory:</p>\n<ul>\n<li>A CSV table of all detected periodogram peaks across all DM trials</li>\n<li>A CSV table of clusters, obtained by grouping together peaks with frequencies close to each other</li>\n<li>A CSV table of candidates, which will have the same entries as the clusters table, unless you have enabled harmonic filtering in the config file. In this case any cluster that was flagged as a harmonic of another is removed from the final candidate list.</li>\n<li>One JSON file per candidate, which can be loaded using <code>riptide.load_json()</code> and plotted / manipulated. These contain header information, a table of peaks associated to the candidate, and a sub-integration plots obtained by folding the DM trial at which they were detected with the highest S/N.</li>\n<li>One PNG plot per candidate, if the associated option was enabled in the configuration file.</li>\n</ul>\n<h2>Docker image</h2>\n<p>The riptide Dockerfile is located in the 'docker' subdirectory. To build the image, simply type:</p>\n<pre>make docker\n</pre>\n<p>Which builds an image named <code>riptide-ffa</code>. Both python and ipython are installed within the docker image. To start a container:</p>\n<pre>docker run -it --rm riptide-ffa\n</pre>\n<p>Refer to your favourite docker cheat sheet for further information and advanced usage.</p>\n\n          </div>"}, "last_serial": 7158905, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "6c2955c4e68d393d4e6f07666736f576", "sha256": "8feb6246d477c31ac28c0306e0f8be6d18779ab6d787eb7c2d41dad70934c879"}, "downloads": -1, "filename": "riptide-ffa-0.1.0.tar.gz", "has_sig": false, "md5_digest": "6c2955c4e68d393d4e6f07666736f576", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78097, "upload_time": "2020-04-08T08:48:17", "upload_time_iso_8601": "2020-04-08T08:48:17.294685Z", "url": "https://files.pythonhosted.org/packages/b0/b1/c97575dc8a3adf6dda6f9ff506cda1bc5f0db8e399e9d0b80074c8b2d7e1/riptide-ffa-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "b87b1b131d72dbab4d29ef768dc42a21", "sha256": "1c4656b2a9b0f10a930a8e9db4a4290e994730f197dde8974b30cb629264352f"}, "downloads": -1, "filename": "riptide-ffa-0.1.1.tar.gz", "has_sig": false, "md5_digest": "b87b1b131d72dbab4d29ef768dc42a21", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 80050, "upload_time": "2020-04-08T18:43:04", "upload_time_iso_8601": "2020-04-08T18:43:04.319853Z", "url": "https://files.pythonhosted.org/packages/8f/6a/3a18ed2c2e2171cf43603df336a90722a39e9761b1f1859c4e08e6864c3b/riptide-ffa-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "679b948f05ba82c83cff754e1bd9c621", "sha256": "e04843960c0c1dacfdd3446096bb92a358b343677a679b2265c3c5cc142363c5"}, "downloads": -1, "filename": "riptide-ffa-0.1.2.tar.gz", "has_sig": false, "md5_digest": "679b948f05ba82c83cff754e1bd9c621", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78963, "upload_time": "2020-04-15T11:53:31", "upload_time_iso_8601": "2020-04-15T11:53:31.212655Z", "url": "https://files.pythonhosted.org/packages/e8/c4/3fa7d704d7f0239a207cddbf9355c69f2ee30c4eac4205ab451469d44388/riptide-ffa-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "88e87e97ddc9cfe614551b9df52d9c0c", "sha256": "8aa78755da74698509e0f455ffd3ba3a5cfdbb4cf70363d163c30485007f0338"}, "downloads": -1, "filename": "riptide-ffa-0.1.3.tar.gz", "has_sig": false, "md5_digest": "88e87e97ddc9cfe614551b9df52d9c0c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 85903, "upload_time": "2020-04-27T15:00:43", "upload_time_iso_8601": "2020-04-27T15:00:43.824390Z", "url": "https://files.pythonhosted.org/packages/54/f5/2119e6a2fb28e2fa3f0d5412bfdd3212f4d589fe8c213347aa3b1d5bdad4/riptide-ffa-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "73c6060a8f93d9d0f432c635a311cc56", "sha256": "552dc0f3c6ee6c6108ae807af5211f4f525ecc7da0eb7fd9cd6e2220bc4b1d47"}, "downloads": -1, "filename": "riptide-ffa-0.1.4.tar.gz", "has_sig": false, "md5_digest": "73c6060a8f93d9d0f432c635a311cc56", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 874643, "upload_time": "2020-05-03T18:34:24", "upload_time_iso_8601": "2020-05-03T18:34:24.348716Z", "url": "https://files.pythonhosted.org/packages/09/56/cc6729a1b3be8f9c10cde65ddcf1e62a76dfbb11d342c474eb5bed171086/riptide-ffa-0.1.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "73c6060a8f93d9d0f432c635a311cc56", "sha256": "552dc0f3c6ee6c6108ae807af5211f4f525ecc7da0eb7fd9cd6e2220bc4b1d47"}, "downloads": -1, "filename": "riptide-ffa-0.1.4.tar.gz", "has_sig": false, "md5_digest": "73c6060a8f93d9d0f432c635a311cc56", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 874643, "upload_time": "2020-05-03T18:34:24", "upload_time_iso_8601": "2020-05-03T18:34:24.348716Z", "url": "https://files.pythonhosted.org/packages/09/56/cc6729a1b3be8f9c10cde65ddcf1e62a76dfbb11d342c474eb5bed171086/riptide-ffa-0.1.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:26 2020"}