{"info": {"author": "hirokiky", "author_email": "hirokiky@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.3", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: WSGI :: Application"], "description": "================\ngargant.dispatch\n================\n\nFlexible dispatcher for WSGI application.\n\nBasic usage\n===========\n\nWriting dispaching tree, and register wsgi apps to `case`::\n\n    from wsgiref.simple_server import make_server\n    from gargant.dispatch import Node, path_matching, make_wsgi_app\n\n    from path.to.yours import wsgi_app\n\n\n    tree = Node((path_matching(['']),),\n                case=wsgi_app,\n                name='first')\n\n    app = make_wsgi_app(tree)\n\n    httpd = make_server('', 8000, app)\n    httpb.serve_forever()\n\n\nRegistered app (wsgi_app) will be called when the path is '/'.\n\nNode\n====\ngargant.dispatch is not just for creating a WSGI application.\nIt can handle environ and return a value as you like.\n\nYou can apply anything to `case`::\n\n    >>> tree = Node((path_matching(['']),),\n    ...             case='dolls')\n    >>>\n    >>> node = tree({'PATH_INFO': '/'})\n    >>> node.case  # 'dolls'\n\n\nHierarchy\n---------\n\nNode class can take argument 'children' like this::\n\n    >>> tree = Node((path_matching(['']),),\n    ...             case='dolls',\n    ...             children=(\n    ...                 Node((path_matching['fifth']),\n    ...                      case='shinku'),\n    ...             ))\n    >>>\n    >>> node = tree({'PATH_INFO': '/fifth'})\n    >>> node.case  # 'shinku'\n\nThere is not any matched children, the parent will be matched::\n\n    >>> node = tree({'PATH_INFO': '/'})\n    >>> node.case  # 'dolls'\n\nMatching\n========\npath_matching is just one of matching patterns,\nyou can use method_matching too::\n\n    >>> tree = Node((path_matching(['']),\n                     method_matching('get')),\n    ...             case='dolls',\n    ...             )\n    >>>\n    >>> node = tree({'PATH_INFO': '/',\n    ...              'REQUEST_METHOD': 'GET'})\n    >>> node.case  # 'dolls'\n\nmethod patterns returns callables taking environ and return\nsome values.\nAll values returned from matchings can be handles as True.\nThe Node will be handles as 'matched'.\n\nReturned values from matchings will be store in\nnode.matched as list of these.\n\nURL args\n--------\n\nAnd using this behavior, path_matching can take args from URL::\n\n    >>> tree = Node((path_matching(['']),),\n    ...             case='doll_list',\n    ...             children=(\n    ...                 Node((path_matching(['{doll}']),),\n    ...                       case='doll_detail',\n    ...                 ),\n    ...             ))\n    >>>\n    >>> node = tree({'PATH_INFO': '/first'})\n    >>> node.case  # 'doll_detail'\n    >>> node.matched[0]['doll']  # 'first'\n\nAdapters\n=========\nNode can take keyword arg named `adapter_factory`.\nIt takes node.matched and return some callables you like::\n\n    >>> tree = Node((path_matching(['']),),\n    ...             case='dolls',\n    ...             children=(\n    ...                 Node((path_matching(['fifth']),),\n    ...                       case='shinku',\n    ...                       adapter_factory=lambda matched: lambda x: x + ' kawaii'\n    ...                 ),\n    ...             ),\n    ...             adapter_factory=lambda matched: lambda x: x + ' is'\n    ...             )\n    >>>\n    >>> node = tree({'PATH_INFO': '/fifth'})\n    >>> node.case  # 'shinku'\n    >>> doll = 'shinku'\n    >>> root_to_leaf = reversed(list(node))  # [dolls node, shinku node]\n    >>> for node in root_to_leaf:\n    ...     doll = node.adapter(doll)\n    ...\n    >>> doll  # 'shinku is kawaii'\n\nIn this case, these adapter_factory will return simple functions,\nbut gargant.dispatch is assuming you make it to return Adapter classes.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/hirokiky/gargant.dispatch", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "gargant.dispatch", "package_url": "https://pypi.org/project/gargant.dispatch/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/gargant.dispatch/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/hirokiky/gargant.dispatch"}, "release_url": "https://pypi.org/project/gargant.dispatch/0.1/", "requires_dist": null, "requires_python": null, "summary": "Flexible dispatcher for WSGI Applications", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Flexible dispatcher for WSGI application.</p>\n<div id=\"basic-usage\">\n<h2>Basic usage</h2>\n<p>Writing dispaching tree, and register wsgi apps to <cite>case</cite>:</p>\n<pre>from wsgiref.simple_server import make_server\nfrom gargant.dispatch import Node, path_matching, make_wsgi_app\n\nfrom path.to.yours import wsgi_app\n\n\ntree = Node((path_matching(['']),),\n            case=wsgi_app,\n            name='first')\n\napp = make_wsgi_app(tree)\n\nhttpd = make_server('', 8000, app)\nhttpb.serve_forever()\n</pre>\n<p>Registered app (wsgi_app) will be called when the path is \u2018/\u2019.</p>\n</div>\n<div id=\"node\">\n<h2>Node</h2>\n<p>gargant.dispatch is not just for creating a WSGI application.\nIt can handle environ and return a value as you like.</p>\n<p>You can apply anything to <cite>case</cite>:</p>\n<pre>&gt;&gt;&gt; tree = Node((path_matching(['']),),\n...             case='dolls')\n&gt;&gt;&gt;\n&gt;&gt;&gt; node = tree({'PATH_INFO': '/'})\n&gt;&gt;&gt; node.case  # 'dolls'\n</pre>\n<div id=\"hierarchy\">\n<h3>Hierarchy</h3>\n<p>Node class can take argument \u2018children\u2019 like this:</p>\n<pre>&gt;&gt;&gt; tree = Node((path_matching(['']),),\n...             case='dolls',\n...             children=(\n...                 Node((path_matching['fifth']),\n...                      case='shinku'),\n...             ))\n&gt;&gt;&gt;\n&gt;&gt;&gt; node = tree({'PATH_INFO': '/fifth'})\n&gt;&gt;&gt; node.case  # 'shinku'\n</pre>\n<p>There is not any matched children, the parent will be matched:</p>\n<pre>&gt;&gt;&gt; node = tree({'PATH_INFO': '/'})\n&gt;&gt;&gt; node.case  # 'dolls'\n</pre>\n</div>\n</div>\n<div id=\"matching\">\n<h2>Matching</h2>\n<p>path_matching is just one of matching patterns,\nyou can use method_matching too:</p>\n<pre>&gt;&gt;&gt; tree = Node((path_matching(['']),\n                 method_matching('get')),\n...             case='dolls',\n...             )\n&gt;&gt;&gt;\n&gt;&gt;&gt; node = tree({'PATH_INFO': '/',\n...              'REQUEST_METHOD': 'GET'})\n&gt;&gt;&gt; node.case  # 'dolls'\n</pre>\n<p>method patterns returns callables taking environ and return\nsome values.\nAll values returned from matchings can be handles as True.\nThe Node will be handles as \u2018matched\u2019.</p>\n<p>Returned values from matchings will be store in\nnode.matched as list of these.</p>\n<div id=\"url-args\">\n<h3>URL args</h3>\n<p>And using this behavior, path_matching can take args from URL:</p>\n<pre>&gt;&gt;&gt; tree = Node((path_matching(['']),),\n...             case='doll_list',\n...             children=(\n...                 Node((path_matching(['{doll}']),),\n...                       case='doll_detail',\n...                 ),\n...             ))\n&gt;&gt;&gt;\n&gt;&gt;&gt; node = tree({'PATH_INFO': '/first'})\n&gt;&gt;&gt; node.case  # 'doll_detail'\n&gt;&gt;&gt; node.matched[0]['doll']  # 'first'\n</pre>\n</div>\n</div>\n<div id=\"adapters\">\n<h2>Adapters</h2>\n<p>Node can take keyword arg named <cite>adapter_factory</cite>.\nIt takes node.matched and return some callables you like:</p>\n<pre>&gt;&gt;&gt; tree = Node((path_matching(['']),),\n...             case='dolls',\n...             children=(\n...                 Node((path_matching(['fifth']),),\n...                       case='shinku',\n...                       adapter_factory=lambda matched: lambda x: x + ' kawaii'\n...                 ),\n...             ),\n...             adapter_factory=lambda matched: lambda x: x + ' is'\n...             )\n&gt;&gt;&gt;\n&gt;&gt;&gt; node = tree({'PATH_INFO': '/fifth'})\n&gt;&gt;&gt; node.case  # 'shinku'\n&gt;&gt;&gt; doll = 'shinku'\n&gt;&gt;&gt; root_to_leaf = reversed(list(node))  # [dolls node, shinku node]\n&gt;&gt;&gt; for node in root_to_leaf:\n...     doll = node.adapter(doll)\n...\n&gt;&gt;&gt; doll  # 'shinku is kawaii'\n</pre>\n<p>In this case, these adapter_factory will return simple functions,\nbut gargant.dispatch is assuming you make it to return Adapter classes.</p>\n</div>\n\n          </div>"}, "last_serial": 863911, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "1738586d57e01637e86b21a71f1ae56d", "sha256": "086c3e6aaadd0ed3ede044d91ee02299b98af68778b3813619adb7fa67000e8c"}, "downloads": -1, "filename": "gargant.dispatch-0.1.tar.gz", "has_sig": false, "md5_digest": "1738586d57e01637e86b21a71f1ae56d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3648, "upload_time": "2013-09-12T16:01:11", "upload_time_iso_8601": "2013-09-12T16:01:11.106872Z", "url": "https://files.pythonhosted.org/packages/74/e7/a9e1aecd71914c6892935b3aeb084af95ece598cac688d0a27e3bdbd3520/gargant.dispatch-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1738586d57e01637e86b21a71f1ae56d", "sha256": "086c3e6aaadd0ed3ede044d91ee02299b98af68778b3813619adb7fa67000e8c"}, "downloads": -1, "filename": "gargant.dispatch-0.1.tar.gz", "has_sig": false, "md5_digest": "1738586d57e01637e86b21a71f1ae56d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3648, "upload_time": "2013-09-12T16:01:11", "upload_time_iso_8601": "2013-09-12T16:01:11.106872Z", "url": "https://files.pythonhosted.org/packages/74/e7/a9e1aecd71914c6892935b3aeb084af95ece598cac688d0a27e3bdbd3520/gargant.dispatch-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:59:03 2020"}