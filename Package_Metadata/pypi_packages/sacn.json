{"info": {"author": "Hundemeier", "author_email": "hundemeier99@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3 :: Only"], "description": "# sACN / E1.31 module\n\nThis module is a simple sACN library that support the standard DMX message of the protocol.\nIt is based on the [2016][e1.31] version of the official ANSI E1.31 standard.\nIt has support for sending out DMX data and receiving it. Multiple and multicast universes are supported.\nFor full blown DMX support use [OLA](http://opendmx.net/index.php/Open_Lighting_Architecture).\n\nCurrently missing features:\n * discovery messages (receiving)\n * E1.31 sync feature (on the receiver side)\n * custom ports (because this is not recommended)\n\nFeatures:\n * out-of-order packet detection like the [E1.31][e1.31] 6.7.2\n * multicast (on Windows this is a bit tricky though)\n * auto flow control (see [The Internals/Sending](#sending))\n * E1.31 sync feature (see manual_flush)\n\n## Setup\nThis Package is in the [pypi](https://pypi.org/project/sacn/). To install the package use `pip install sacn`. Python 3.6 or newer required!\nTo use the Libary `import sacn`.\nIf you want to install directly from source, download or clone the repository and execute `pip install .` where the setup.py is located.\nFor more information on pip installation see: https://packaging.python.org/tutorials/installing-packages/#installing-from-a-local-src-tree\n\n## The Internals\n### Sending\nYou can create a new `sACNsender` object and provide the necessary information. Then you have to use `start()`.\nThis creates a new thread that is responsible for sending out the data. Do not forget to `stop()` the thread when\nfinished! If the data is not changed, the same DMX data is send out every second.\n\nThe thread sends out the data every *1/fps* seconds. This reduces network traffic even if you give the sender new data\nmore often than the *fps*.\nA simple description would be to say that the data that you give the sACNsender is subsampled by the *fps*.\nYou can tweak this *fps* by simply change it when creating the `sACNsender` object.\n\nThis function works according to the [E1.31][e1.31]. See 6.6.1 for more information.\n\nNote: Since Version 1.4 there is a manual flush feature available. See Usage/Sending for more info.\nThis feature also uses the sync feature of the sACN protocol (see page 36 on [E1.31][e1.31]).\nCurrently this is not implemented like the recommended way (this does not wait before sending out the sync packet), but\nit should work on a normal local network without too many latency differences.\nWhen the `flush()` function is called, all data is send out at the same time and immediately a sync packet is send out.\n\n### Receiving\nA very simple solution, as you just create a `sACNreceiver` object and use `start()` a new thread that is running in\nthe background and calls the callbacks when new sACN data arrives.\n\n---\n## Usage\n### Sending\nTo use the sending functionality you have to use the `sACNsender`.\n\n```python\nimport sacn\nimport time\n\nsender = sacn.sACNsender()  # provide an IP-Address to bind to if you are using Windows and want to use multicast\nsender.start()  # start the sending thread\nsender.activate_output(1)  # start sending out data in the 1st universe\nsender[1].multicast = True  # set multicast to True\n# sender[1].destination = \"192.168.1.20\"  # or provide unicast information.\n# Keep in mind that if multicast is on, unicast is not used\nsender[1].dmx_data = (1, 2, 3, 4)  # some test DMX data\n\ntime.sleep(10)  # send the data for 10 seconds\nsender.stop()  # do not forget to stop the sender\n```\n\nYou can activate an output universe via `activate_output(<universe>)` and then change the attributes of this universe\nvia `sender[<universe>].<attribute>`. To deactivate an output use `deactivate_output(<universe>)`. The output is\nterminated like the [E1.31][e1.31] describes it on page 14.\n\nIf you want to flush manually and the sender thread should not send out automatic, use the\n`sACNsender.manual_flush` option. This is useful when you want to use a fixture that is using more than one universe\nand all the data on multiple universes should send out at the same time.\n\nTip: you can get the activated outputs with `get_active_outputs()` and you can move an output with all its settings\nfrom one universe to another with `move_universe(<from>, <to>)`.\n\nAvailable Attributes for `sender[<universe>].<attribute>` are:\n * `destination: str`: the unicast destination as string. (eg \"192.168.1.150\") Default: \"127.0.0.1\"\n * `multicast: bool`: set whether to send out via multicast or not. Default: False\n If True the data is send out via multicast and not unicast.\n * `ttl: int`: the time-to-live for the packets that are send out via mutlicast on this universe. Default: 8\n * `priority: int`: (must be between 0-200) the priority for this universe that is send out. If multiple sources in a\n network are sending to the same receiver the data with the highest priority wins. Default: 100\n * `preview_data: bool`: Flag to mark the data as preview data for visualization purposes. Default: False\n * `dmx_data: tuple`: the DMX data as a tuple. Max length is 512 and for legacy devices all data that is smaller than\n 512 is merged to a 512 length tuple with 0 as filler value. The values in the tuple have to be [0-255]!\n\n`sACNsender` Creates a sender object. A sender is used to manage multiple sACN universes and handles their output.\nDMX data is send out every second, when no data changes. Some changes may be not send out, because the fps\nsetting defines how often packets are send out to prevent network overuse. So if you change the DMX values too\noften in a second they may not all been send. Vary the fps parameter to your needs (Default=30).\nNote that a bind address is needed on Windows for sending out multicast packets.\n * `bind_address: str`: the IP-Address to bind to.\n For multicast and universe discovery on a Windows machine this must be set to a proper value otherwise omit.\n * `bind_port: int`: optionally bind to a specific port. Default=5568. It is not recommended to change the port.\n Change the port number if you have trouble with another program or the sACNreceiver blocking the port\n * `source_name: str`: the source name used in the sACN packets. See the [standard][e1.31] for more information.\n * `cid: tuple`: the cid. If not given, a random CID will be generated. See the [standard][e1.31] for more information.\n * `fps: int` the frames per second. See explanation above. Has to be >0. Default: 30\n * `universeDiscovery: bool` if true, universe discovery messages are send out via broadcast every 10s. For this\n feature to function properly on Windows, you have to provide a bind address. Default: True\n * `manual_flush: bool` if set to true, the output-thread will not automatically send out packets. Use the function\n  `flush()` to send out all universes. Default: False\n\nWhen manually flushed, the E1.31 sync feature is used. So all universe data is send out, and after all data was send out\na sync packet is send to all receivers and then they are allowed to display the received data. Note that not all\nreceiver implemented this feature of the sACN protocol.\n\nExample for the usage of the manual_flush:\n```python\nimport sacn\nimport time\n\nsender = sacn.sACNsender()\nsender.start()\nsender.activate_output(1)\nsender.activate_output(2)\nsender[1].multicast = True # keep in mind that multicast on windows is a bit different\nsender[2].multicast = True\n\nsender.manual_flush = True # turning off the automatic sending of packets\nsender[1].dmx_data = (1, 2, 3, 4)  # some test DMX data\nsender[2].dmx_data = (5, 6, 7, 8)  # by the time we are here, the above data would be already send out,\n# if manual_flush would be False. This could cause some jitter\n# so instead we are flushing manual\ntime.sleep(1) # let the sender initalize itself\nsender.flush()\nsender.manual_flush = False # keep maunal flush off as long as possible, because if it is on, the automatic\n# sending of packets is turned off and that is not recommended\nsender.stop() # stop sending out\n```\n\n### Receiving\nTo use the receiving functionality you have to use the `sACNreceiver`.\n\n```python\nimport sacn\nimport time\n\n# provide an IP-Address to bind to if you are using Windows and want to use multicast\nreceiver = sacn.sACNreceiver()\nreceiver.start()  # start the receiving thread\n\n# define a callback function\n@receiver.listen_on('universe', universe=1)  # listens on universe 1\ndef callback(packet):  # packet type: sacn.DataPacket\n    print(packet.dmxData)  # print the received DMX data\n\n# optional: if you want to use multicast use this function with the universe as parameter\nreceiver.join_multicast(1)\n\ntime.sleep(10)  # receive for 10 seconds\nreceiver.stop()\n```\n\nThe usage of the receiver is way more simple than the sender.\nThe `sACNreceiver` can be initialized with the following parameters:\n * `bind_address: str`: if you are on a Windows system and want to use multicast provide a valid interfaceIP-Address!\n Otherwise omit.\n * `bind_port: int`: Default: 5568. It is not recommended to change this value!\n Only use when you are know what you are doing!\n\nPlease keep in mind to not use the callbacks for time consuming tasks!\nIf you do this, then the receiver can not react fast enough on incoming messages!\n\nFunctions:\n * `join_multicast(<universe>)`: joins the multicast group for the specific universe. If you are on Windows you have to\n bind the receiver to a valid IP-Address. That is done in the constructor of a sACNreceiver.\n * `leave_multicast(<universe>)`: leave the multicast group specified by the universe.\n * `get_possible_universes()`: Returns a tuple with all universes that have sources that are sending out data and this\n data is received by this machine\n * `register_listener(<trigger>, <callback>, **kwargs)`: register a listener for the given trigger.\n You can also use the decorator `listen_on(<trigger>, **kwargs)`. Possible trigger so far:\n   * `availability`: gets called when there is no data for a universe anymore or there is now data\n   available. This gets also fired if a source terminates a stream via the stream_termination bit.\n   The callback should get two arguments: `callback(universe, changed)`\n     * `universe: int`: is the universe where the action happened\n     * `changed: str`: can be 'timeout' or 'available'\n   * `universe`: registers a listener for the given universe. The callback gets only one parameter, the DataPacket.\n   You can also use the decorator `@listen_on('universe', universe=<universe>)`.\n   The callback should have one argument: `callback(packet)`\n     * `packet: DataPacket`: the received DataPacket with all information\n\n### DataPacket\nThis is an abstract representation of an sACN Data packet that carries the DMX data. This class is used internally by\nthe module and is used in the callbacks of the receiver.\n\nThe DataPacket provides following attributes:\n * `sourceName: str`: a string that is used to identify the source. Only the first 64 bytes are used.\n * `priority: int`: the priority used to manage multiple DMX data on one receiver. [1-200] Default: 100\n * `universe: int`: the universe for the whole message and its DMX data. [1-63999]\n * `sequence: int`: the sequence number. Should increment for every new message and can be used to check for wrong\n order of arriving packets.\n * `option_StreamTerminated: bool`: True if this packet is the last one of the stream for the given universe.\n * `option_PreviewData: bool`: True if this data is for visualization purposes.\n * `dmxData: tuple`: the DMX data as tuple. Max length is 512 and shorter tuples getting normalized to a length of 512.\n Filled with 0 for empty spaces.\n\n### Changelog\n * 1.4: Added a manual flush feature for sending out all universes at the same time. Thanks to ahodges9 for the idea.\n\n\n[e1.31]: http://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://www.github.com/Hundemeier/sacn", "keywords": "sacn e131 e1.31 dmx", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "sacn", "package_url": "https://pypi.org/project/sacn/", "platform": "", "project_url": "https://pypi.org/project/sacn/", "project_urls": {"Homepage": "https://www.github.com/Hundemeier/sacn"}, "release_url": "https://pypi.org/project/sacn/1.4.2/", "requires_dist": null, "requires_python": ">=3.6", "summary": "sACN / E1.31 module for easy handling of DMX data over ethernet", "version": "1.4.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>sACN / E1.31 module</h1>\n<p>This module is a simple sACN library that support the standard DMX message of the protocol.\nIt is based on the <a href=\"http://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf\" rel=\"nofollow\">2016</a> version of the official ANSI E1.31 standard.\nIt has support for sending out DMX data and receiving it. Multiple and multicast universes are supported.\nFor full blown DMX support use <a href=\"http://opendmx.net/index.php/Open_Lighting_Architecture\" rel=\"nofollow\">OLA</a>.</p>\n<p>Currently missing features:</p>\n<ul>\n<li>discovery messages (receiving)</li>\n<li>E1.31 sync feature (on the receiver side)</li>\n<li>custom ports (because this is not recommended)</li>\n</ul>\n<p>Features:</p>\n<ul>\n<li>out-of-order packet detection like the <a href=\"http://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf\" rel=\"nofollow\">E1.31</a> 6.7.2</li>\n<li>multicast (on Windows this is a bit tricky though)</li>\n<li>auto flow control (see <a href=\"#sending\" rel=\"nofollow\">The Internals/Sending</a>)</li>\n<li>E1.31 sync feature (see manual_flush)</li>\n</ul>\n<h2>Setup</h2>\n<p>This Package is in the <a href=\"https://pypi.org/project/sacn/\" rel=\"nofollow\">pypi</a>. To install the package use <code>pip install sacn</code>. Python 3.6 or newer required!\nTo use the Libary <code>import sacn</code>.\nIf you want to install directly from source, download or clone the repository and execute <code>pip install .</code> where the setup.py is located.\nFor more information on pip installation see: <a href=\"https://packaging.python.org/tutorials/installing-packages/#installing-from-a-local-src-tree\" rel=\"nofollow\">https://packaging.python.org/tutorials/installing-packages/#installing-from-a-local-src-tree</a></p>\n<h2>The Internals</h2>\n<h3>Sending</h3>\n<p>You can create a new <code>sACNsender</code> object and provide the necessary information. Then you have to use <code>start()</code>.\nThis creates a new thread that is responsible for sending out the data. Do not forget to <code>stop()</code> the thread when\nfinished! If the data is not changed, the same DMX data is send out every second.</p>\n<p>The thread sends out the data every <em>1/fps</em> seconds. This reduces network traffic even if you give the sender new data\nmore often than the <em>fps</em>.\nA simple description would be to say that the data that you give the sACNsender is subsampled by the <em>fps</em>.\nYou can tweak this <em>fps</em> by simply change it when creating the <code>sACNsender</code> object.</p>\n<p>This function works according to the <a href=\"http://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf\" rel=\"nofollow\">E1.31</a>. See 6.6.1 for more information.</p>\n<p>Note: Since Version 1.4 there is a manual flush feature available. See Usage/Sending for more info.\nThis feature also uses the sync feature of the sACN protocol (see page 36 on <a href=\"http://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf\" rel=\"nofollow\">E1.31</a>).\nCurrently this is not implemented like the recommended way (this does not wait before sending out the sync packet), but\nit should work on a normal local network without too many latency differences.\nWhen the <code>flush()</code> function is called, all data is send out at the same time and immediately a sync packet is send out.</p>\n<h3>Receiving</h3>\n<p>A very simple solution, as you just create a <code>sACNreceiver</code> object and use <code>start()</code> a new thread that is running in\nthe background and calls the callbacks when new sACN data arrives.</p>\n<hr>\n<h2>Usage</h2>\n<h3>Sending</h3>\n<p>To use the sending functionality you have to use the <code>sACNsender</code>.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sacn</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"n\">sender</span> <span class=\"o\">=</span> <span class=\"n\">sacn</span><span class=\"o\">.</span><span class=\"n\">sACNsender</span><span class=\"p\">()</span>  <span class=\"c1\"># provide an IP-Address to bind to if you are using Windows and want to use multicast</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>  <span class=\"c1\"># start the sending thread</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">activate_output</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># start sending out data in the 1st universe</span>\n<span class=\"n\">sender</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">multicast</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>  <span class=\"c1\"># set multicast to True</span>\n<span class=\"c1\"># sender[1].destination = \"192.168.1.20\"  # or provide unicast information.</span>\n<span class=\"c1\"># Keep in mind that if multicast is on, unicast is not used</span>\n<span class=\"n\">sender</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">dmx_data</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>  <span class=\"c1\"># some test DMX data</span>\n\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>  <span class=\"c1\"># send the data for 10 seconds</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span>  <span class=\"c1\"># do not forget to stop the sender</span>\n</pre>\n<p>You can activate an output universe via <code>activate_output(&lt;universe&gt;)</code> and then change the attributes of this universe\nvia <code>sender[&lt;universe&gt;].&lt;attribute&gt;</code>. To deactivate an output use <code>deactivate_output(&lt;universe&gt;)</code>. The output is\nterminated like the <a href=\"http://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf\" rel=\"nofollow\">E1.31</a> describes it on page 14.</p>\n<p>If you want to flush manually and the sender thread should not send out automatic, use the\n<code>sACNsender.manual_flush</code> option. This is useful when you want to use a fixture that is using more than one universe\nand all the data on multiple universes should send out at the same time.</p>\n<p>Tip: you can get the activated outputs with <code>get_active_outputs()</code> and you can move an output with all its settings\nfrom one universe to another with <code>move_universe(&lt;from&gt;, &lt;to&gt;)</code>.</p>\n<p>Available Attributes for <code>sender[&lt;universe&gt;].&lt;attribute&gt;</code> are:</p>\n<ul>\n<li><code>destination: str</code>: the unicast destination as string. (eg \"192.168.1.150\") Default: \"127.0.0.1\"</li>\n<li><code>multicast: bool</code>: set whether to send out via multicast or not. Default: False\nIf True the data is send out via multicast and not unicast.</li>\n<li><code>ttl: int</code>: the time-to-live for the packets that are send out via mutlicast on this universe. Default: 8</li>\n<li><code>priority: int</code>: (must be between 0-200) the priority for this universe that is send out. If multiple sources in a\nnetwork are sending to the same receiver the data with the highest priority wins. Default: 100</li>\n<li><code>preview_data: bool</code>: Flag to mark the data as preview data for visualization purposes. Default: False</li>\n<li><code>dmx_data: tuple</code>: the DMX data as a tuple. Max length is 512 and for legacy devices all data that is smaller than\n512 is merged to a 512 length tuple with 0 as filler value. The values in the tuple have to be [0-255]!</li>\n</ul>\n<p><code>sACNsender</code> Creates a sender object. A sender is used to manage multiple sACN universes and handles their output.\nDMX data is send out every second, when no data changes. Some changes may be not send out, because the fps\nsetting defines how often packets are send out to prevent network overuse. So if you change the DMX values too\noften in a second they may not all been send. Vary the fps parameter to your needs (Default=30).\nNote that a bind address is needed on Windows for sending out multicast packets.</p>\n<ul>\n<li><code>bind_address: str</code>: the IP-Address to bind to.\nFor multicast and universe discovery on a Windows machine this must be set to a proper value otherwise omit.</li>\n<li><code>bind_port: int</code>: optionally bind to a specific port. Default=5568. It is not recommended to change the port.\nChange the port number if you have trouble with another program or the sACNreceiver blocking the port</li>\n<li><code>source_name: str</code>: the source name used in the sACN packets. See the <a href=\"http://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf\" rel=\"nofollow\">standard</a> for more information.</li>\n<li><code>cid: tuple</code>: the cid. If not given, a random CID will be generated. See the <a href=\"http://tsp.esta.org/tsp/documents/docs/E1-31-2016.pdf\" rel=\"nofollow\">standard</a> for more information.</li>\n<li><code>fps: int</code> the frames per second. See explanation above. Has to be &gt;0. Default: 30</li>\n<li><code>universeDiscovery: bool</code> if true, universe discovery messages are send out via broadcast every 10s. For this\nfeature to function properly on Windows, you have to provide a bind address. Default: True</li>\n<li><code>manual_flush: bool</code> if set to true, the output-thread will not automatically send out packets. Use the function\n<code>flush()</code> to send out all universes. Default: False</li>\n</ul>\n<p>When manually flushed, the E1.31 sync feature is used. So all universe data is send out, and after all data was send out\na sync packet is send to all receivers and then they are allowed to display the received data. Note that not all\nreceiver implemented this feature of the sACN protocol.</p>\n<p>Example for the usage of the manual_flush:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sacn</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"n\">sender</span> <span class=\"o\">=</span> <span class=\"n\">sacn</span><span class=\"o\">.</span><span class=\"n\">sACNsender</span><span class=\"p\">()</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">activate_output</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">activate_output</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">sender</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">multicast</span> <span class=\"o\">=</span> <span class=\"kc\">True</span> <span class=\"c1\"># keep in mind that multicast on windows is a bit different</span>\n<span class=\"n\">sender</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">multicast</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">manual_flush</span> <span class=\"o\">=</span> <span class=\"kc\">True</span> <span class=\"c1\"># turning off the automatic sending of packets</span>\n<span class=\"n\">sender</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">dmx_data</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>  <span class=\"c1\"># some test DMX data</span>\n<span class=\"n\">sender</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">dmx_data</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">)</span>  <span class=\"c1\"># by the time we are here, the above data would be already send out,</span>\n<span class=\"c1\"># if manual_flush would be False. This could cause some jitter</span>\n<span class=\"c1\"># so instead we are flushing manual</span>\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\"># let the sender initalize itself</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">flush</span><span class=\"p\">()</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">manual_flush</span> <span class=\"o\">=</span> <span class=\"kc\">False</span> <span class=\"c1\"># keep maunal flush off as long as possible, because if it is on, the automatic</span>\n<span class=\"c1\"># sending of packets is turned off and that is not recommended</span>\n<span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span> <span class=\"c1\"># stop sending out</span>\n</pre>\n<h3>Receiving</h3>\n<p>To use the receiving functionality you have to use the <code>sACNreceiver</code>.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sacn</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"c1\"># provide an IP-Address to bind to if you are using Windows and want to use multicast</span>\n<span class=\"n\">receiver</span> <span class=\"o\">=</span> <span class=\"n\">sacn</span><span class=\"o\">.</span><span class=\"n\">sACNreceiver</span><span class=\"p\">()</span>\n<span class=\"n\">receiver</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>  <span class=\"c1\"># start the receiving thread</span>\n\n<span class=\"c1\"># define a callback function</span>\n<span class=\"nd\">@receiver</span><span class=\"o\">.</span><span class=\"n\">listen_on</span><span class=\"p\">(</span><span class=\"s1\">'universe'</span><span class=\"p\">,</span> <span class=\"n\">universe</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># listens on universe 1</span>\n<span class=\"k\">def</span> <span class=\"nf\">callback</span><span class=\"p\">(</span><span class=\"n\">packet</span><span class=\"p\">):</span>  <span class=\"c1\"># packet type: sacn.DataPacket</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">packet</span><span class=\"o\">.</span><span class=\"n\">dmxData</span><span class=\"p\">)</span>  <span class=\"c1\"># print the received DMX data</span>\n\n<span class=\"c1\"># optional: if you want to use multicast use this function with the universe as parameter</span>\n<span class=\"n\">receiver</span><span class=\"o\">.</span><span class=\"n\">join_multicast</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>  <span class=\"c1\"># receive for 10 seconds</span>\n<span class=\"n\">receiver</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span>\n</pre>\n<p>The usage of the receiver is way more simple than the sender.\nThe <code>sACNreceiver</code> can be initialized with the following parameters:</p>\n<ul>\n<li><code>bind_address: str</code>: if you are on a Windows system and want to use multicast provide a valid interfaceIP-Address!\nOtherwise omit.</li>\n<li><code>bind_port: int</code>: Default: 5568. It is not recommended to change this value!\nOnly use when you are know what you are doing!</li>\n</ul>\n<p>Please keep in mind to not use the callbacks for time consuming tasks!\nIf you do this, then the receiver can not react fast enough on incoming messages!</p>\n<p>Functions:</p>\n<ul>\n<li><code>join_multicast(&lt;universe&gt;)</code>: joins the multicast group for the specific universe. If you are on Windows you have to\nbind the receiver to a valid IP-Address. That is done in the constructor of a sACNreceiver.</li>\n<li><code>leave_multicast(&lt;universe&gt;)</code>: leave the multicast group specified by the universe.</li>\n<li><code>get_possible_universes()</code>: Returns a tuple with all universes that have sources that are sending out data and this\ndata is received by this machine</li>\n<li><code>register_listener(&lt;trigger&gt;, &lt;callback&gt;, **kwargs)</code>: register a listener for the given trigger.\nYou can also use the decorator <code>listen_on(&lt;trigger&gt;, **kwargs)</code>. Possible trigger so far:\n<ul>\n<li><code>availability</code>: gets called when there is no data for a universe anymore or there is now data\navailable. This gets also fired if a source terminates a stream via the stream_termination bit.\nThe callback should get two arguments: <code>callback(universe, changed)</code>\n<ul>\n<li><code>universe: int</code>: is the universe where the action happened</li>\n<li><code>changed: str</code>: can be 'timeout' or 'available'</li>\n</ul>\n</li>\n<li><code>universe</code>: registers a listener for the given universe. The callback gets only one parameter, the DataPacket.\nYou can also use the decorator <code>@listen_on('universe', universe=&lt;universe&gt;)</code>.\nThe callback should have one argument: <code>callback(packet)</code>\n<ul>\n<li><code>packet: DataPacket</code>: the received DataPacket with all information</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>DataPacket</h3>\n<p>This is an abstract representation of an sACN Data packet that carries the DMX data. This class is used internally by\nthe module and is used in the callbacks of the receiver.</p>\n<p>The DataPacket provides following attributes:</p>\n<ul>\n<li><code>sourceName: str</code>: a string that is used to identify the source. Only the first 64 bytes are used.</li>\n<li><code>priority: int</code>: the priority used to manage multiple DMX data on one receiver. [1-200] Default: 100</li>\n<li><code>universe: int</code>: the universe for the whole message and its DMX data. [1-63999]</li>\n<li><code>sequence: int</code>: the sequence number. Should increment for every new message and can be used to check for wrong\norder of arriving packets.</li>\n<li><code>option_StreamTerminated: bool</code>: True if this packet is the last one of the stream for the given universe.</li>\n<li><code>option_PreviewData: bool</code>: True if this data is for visualization purposes.</li>\n<li><code>dmxData: tuple</code>: the DMX data as tuple. Max length is 512 and shorter tuples getting normalized to a length of 512.\nFilled with 0 for empty spaces.</li>\n</ul>\n<h3>Changelog</h3>\n<ul>\n<li>1.4: Added a manual flush feature for sending out all universes at the same time. Thanks to ahodges9 for the idea.</li>\n</ul>\n\n          </div>"}, "last_serial": 7104316, "releases": {"1.2": [{"comment_text": "", "digests": {"md5": "8299e3dbf810def5d85120e624580322", "sha256": "54a09d966258f763e6c54576c679ef108419624d50ee2ff079bbc2e5c19d9d72"}, "downloads": -1, "filename": "sacn-1.2.tar.gz", "has_sig": false, "md5_digest": "8299e3dbf810def5d85120e624580322", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 15620, "upload_time": "2017-12-17T13:22:16", "upload_time_iso_8601": "2017-12-17T13:22:16.222657Z", "url": "https://files.pythonhosted.org/packages/b7/50/18946b3a9f2a14251eb28ecd4eb35ad2f7c97930e905b9fba07a84860692/sacn-1.2.tar.gz", "yanked": false}], "1.3": [{"comment_text": "", "digests": {"md5": "30c0e56575486f66e27111d79e07171a", "sha256": "764d891e90fabf32161d636375558a57d9a830ec53f9e168f464dd5bd8564d51"}, "downloads": -1, "filename": "sacn-1.3.tar.gz", "has_sig": false, "md5_digest": "30c0e56575486f66e27111d79e07171a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15724, "upload_time": "2018-02-06T18:28:27", "upload_time_iso_8601": "2018-02-06T18:28:27.763110Z", "url": "https://files.pythonhosted.org/packages/ce/d8/81a29b2e418686e3ae0409ce65c34a341e896f0edad95f34e8a85f1e7324/sacn-1.3.tar.gz", "yanked": false}], "1.4": [{"comment_text": "", "digests": {"md5": "559fa4b1bbf238d7509b394b0eb5be62", "sha256": "c880e1f5150cc042c41d065557f41294a0a899216910e43657283f916fbcc8bf"}, "downloads": -1, "filename": "sacn-1.4-py3-none-any.whl", "has_sig": false, "md5_digest": "559fa4b1bbf238d7509b394b0eb5be62", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19834, "upload_time": "2019-12-07T10:04:38", "upload_time_iso_8601": "2019-12-07T10:04:38.164528Z", "url": "https://files.pythonhosted.org/packages/07/c5/3619fdb2e14c3abd158eff4a28b4c09eb3eed0b1af11459f22f597ff89c2/sacn-1.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "162ef067936c862ec136f56252bbd018", "sha256": "8c69999d4028738e6edd00e40440a85a78db8497e708390dcda3d4d22aea4bd9"}, "downloads": -1, "filename": "sacn-1.4.tar.gz", "has_sig": false, "md5_digest": "162ef067936c862ec136f56252bbd018", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 17172, "upload_time": "2019-12-07T10:04:39", "upload_time_iso_8601": "2019-12-07T10:04:39.130402Z", "url": "https://files.pythonhosted.org/packages/68/55/76277ab7a415e4cb0b66e5c9f3ceb4a18bf0e442f52422cd5b1a03f5cdbc/sacn-1.4.tar.gz", "yanked": false}], "1.4.1": [{"comment_text": "", "digests": {"md5": "66c4c815d7bbcf021cd3b308caf81713", "sha256": "709893427343cd77d035ccc5c3b72a2fdd700f79da127040344285cf42d34378"}, "downloads": -1, "filename": "sacn-1.4.1-py3-none-any.whl", "has_sig": false, "md5_digest": "66c4c815d7bbcf021cd3b308caf81713", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 24233, "upload_time": "2019-12-07T10:21:51", "upload_time_iso_8601": "2019-12-07T10:21:51.805768Z", "url": "https://files.pythonhosted.org/packages/9b/9d/857e2e15742fe80cac8d23c1cc8effeb5aaf3f215af3b6b34cf53d94ed66/sacn-1.4.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "344a6d1c6be100f20278b7c8f90b5279", "sha256": "057f7ed7130f0d52671c12d01169fb01b0571c8b9f818af60d1e4b613858273e"}, "downloads": -1, "filename": "sacn-1.4.1.tar.gz", "has_sig": false, "md5_digest": "344a6d1c6be100f20278b7c8f90b5279", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 21573, "upload_time": "2019-12-07T10:21:53", "upload_time_iso_8601": "2019-12-07T10:21:53.042791Z", "url": "https://files.pythonhosted.org/packages/af/e2/b6dbabe5b424d1cedfa019a0b4e2ae0bf223aa8cf4fabceb00d1ed3c780a/sacn-1.4.1.tar.gz", "yanked": false}], "1.4.2": [{"comment_text": "", "digests": {"md5": "d80b71a235e467410ed53f7ad5d07f89", "sha256": "aaf41668df5e8ec867d5b1f9a528a820508617b159ed5ad35c72554423fc9034"}, "downloads": -1, "filename": "sacn-1.4.2-py3-none-any.whl", "has_sig": false, "md5_digest": "d80b71a235e467410ed53f7ad5d07f89", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 24488, "upload_time": "2020-04-26T11:00:11", "upload_time_iso_8601": "2020-04-26T11:00:11.377099Z", "url": "https://files.pythonhosted.org/packages/74/38/35d97fdf86a22eceb21ec3388c5920253ec03d232a92f20ee05b674f1e92/sacn-1.4.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "47a43b52c1caf94da20b4b94bf4954a0", "sha256": "e8859a023c490b314cf2d8ffa6389c83aea22050eec7e3b076b35f0125c32fb5"}, "downloads": -1, "filename": "sacn-1.4.2.tar.gz", "has_sig": false, "md5_digest": "47a43b52c1caf94da20b4b94bf4954a0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 21669, "upload_time": "2020-04-26T11:00:13", "upload_time_iso_8601": "2020-04-26T11:00:13.230603Z", "url": "https://files.pythonhosted.org/packages/37/57/0296006229f6af498d53d1a332c2d37af130236ea33d25b9bbc75de2d031/sacn-1.4.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d80b71a235e467410ed53f7ad5d07f89", "sha256": "aaf41668df5e8ec867d5b1f9a528a820508617b159ed5ad35c72554423fc9034"}, "downloads": -1, "filename": "sacn-1.4.2-py3-none-any.whl", "has_sig": false, "md5_digest": "d80b71a235e467410ed53f7ad5d07f89", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 24488, "upload_time": "2020-04-26T11:00:11", "upload_time_iso_8601": "2020-04-26T11:00:11.377099Z", "url": "https://files.pythonhosted.org/packages/74/38/35d97fdf86a22eceb21ec3388c5920253ec03d232a92f20ee05b674f1e92/sacn-1.4.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "47a43b52c1caf94da20b4b94bf4954a0", "sha256": "e8859a023c490b314cf2d8ffa6389c83aea22050eec7e3b076b35f0125c32fb5"}, "downloads": -1, "filename": "sacn-1.4.2.tar.gz", "has_sig": false, "md5_digest": "47a43b52c1caf94da20b4b94bf4954a0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 21669, "upload_time": "2020-04-26T11:00:13", "upload_time_iso_8601": "2020-04-26T11:00:13.230603Z", "url": "https://files.pythonhosted.org/packages/37/57/0296006229f6af498d53d1a332c2d37af130236ea33d25b9bbc75de2d031/sacn-1.4.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:59:28 2020"}