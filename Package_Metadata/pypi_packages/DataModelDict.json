{"info": {"author": "Lucas Hale", "author_email": "lucas.hale@nist.gov", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Science/Research", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.6", "Topic :: Text Processing :: Markup :: XML"], "description": "\nDataModelDict\n*************\n\n\nIntroduction\n============\n\nThe DataModelDict class is used for handling data models that have\nequivalent representations in XML, JSON, and Python.  Constructing\ndata models in this way is convenient as it supports compatibility\nacross different software tools, such as different types of databases.\n\nThe DataModelDict class:\n\n* is a child of OrderedDict,\n\n* has methods for converting to/from XML and JSON,\n\n* has methods for searching through elements, and\n\n* has methods that help with constructing and interacting with\n  compliant data models.\n\n\nSetup\n=====\n\nThe code has no requirements that limit which systems it can be used\non, i.e. it should work on Linux, Mac and Windows computers.\n\nThe latest release can be installed using pip:\n\n::\n\n   pip install DataModelDict\n\nThe code and all documentation is hosted on GitHub and can be directly\ndownloaded at https://github.com/usnistgov/DataModelDict.\n\n\nConversions\n===========\n\nSome considerations need to be taken into account for designing data\nmodels that allow for exact reversible transformations between the\nthree formats:\n\n* Valid, full XML requires that there is exactly one root element.  In\n  other words, the top-level DataModelDict of a data model   can have\n  only one key.\n\n* Do not use lists of lists for representing data.  The XML\n  conversions are only reversible for lists of values or lists of\n  dictionaries.  Future updates may allow this.\n\n* Avoid using XML attributes if possible.  While the XML conversions\n  do reversibly handle attributes, it complicates the Python and JSON\n  representations.\n\n* Embedded XML content, i.e. \u201ctext with <embed>embedded</embed>\n  content\u201d, might not be reversible:\n\n  ..\n     * If this is in a Python/JSON value, converting to XML gives\n       \u201ctext with &amp;lt;embed&amp;gt;embedded&amp;lt;/embed&amp;gt;\n       content\u201d. This is reversible.\n\n     * If this is an XML text field, parsing to Python pulls the\n       embedded elements out of the text, which is not reversible!\n\n* XML subelements of the same name within an element should be given\n  consecutively.  When parsed, all values of subelements of the same\n  name are collected together in a list.  This will alter the original\n  order of subelements if matching names were not originally\n  consecutive.\n\n\nConversion from Python to JSON\n------------------------------\n\nThe Python-JSON conversions use the standard Python JSON library.  In\nconverting from Python to JSON, all elements of the DataModelDict must\nbe an instance of a supported data type (with unicode and long being\nspecific to Python 2).\n\n+------------------+-----------+\n| Python           | JSON      |\n+==================+===========+\n| dict             | object    |\n+------------------+-----------+\n| list, tuple      | array     |\n+------------------+-----------+\n| str, unicode     | string    |\n+------------------+-----------+\n| int, long, float | number    |\n+------------------+-----------+\n| True             | true      |\n+------------------+-----------+\n| False            | false     |\n+------------------+-----------+\n| None             | null      |\n+------------------+-----------+\n| np.nan           | NaN       |\n+------------------+-----------+\n| np.inf           | Infinity  |\n+------------------+-----------+\n| -np.inf          | -Infinity |\n+------------------+-----------+\n\nAs DataModelDict is a child of OrderedDict, it registers as being an\ninstance of dict. Any other objects would first need to be converted\nto one of these types, e.g. a numpy array would need to be converted\nto a list.\n\n\nConversion from Python to XML\n-----------------------------\n\nThe Python-XML conversions use the xmltodict Python package. The XML\ncontent is constructed based on the Python data types.\n\n+------------------+------------------+\n| Python           | XML              |\n+==================+==================+\n| dict             | subelement       |\n+------------------+------------------+\n| list, tuple      | repeated element |\n+------------------+------------------+\n| str, unicode     | text             |\n+------------------+------------------+\n| int, long, float | text (from repr) |\n+------------------+------------------+\n| True             | text = True      |\n+------------------+------------------+\n| False            | text = False     |\n+------------------+------------------+\n| None             | empty text field |\n+------------------+------------------+\n| np.nan           | text = NaN       |\n+------------------+------------------+\n| np.inf           | text = Infinity  |\n+------------------+------------------+\n| -np.inf          | text = -Infinity |\n+------------------+------------------+\n\nSome characters in the XML text fields will also be converted to avoid\nconflicts.\n\n* XML limited characters such as <, > and & are converted to their\n  HTML entities.\n\n* n, t, r are converted to \\n, \\t, and \\r\n\nAny dictionary keys starting with \u2018@\u2019 will be converted into XML\nattributes, and the dictionary key \u2018#text\u2019 is interpreted as the text\nvalue of the element.\n\n\nConversion from JSON to Python\n------------------------------\n\nThe Python-JSON conversions use the standard Python JSON library.  In\nconverting from JSON to Python, the conversions of types is\nstraight-forward.\n\n+---------------+---------------+---------------+\n| JSON          | Python 2      | Python 3      |\n+===============+===============+===============+\n| object        | DataModelDict | DataModelDict |\n+---------------+---------------+---------------+\n| array         | list          | list          |\n+---------------+---------------+---------------+\n| string        | unicode       | str           |\n+---------------+---------------+---------------+\n| number (int)  | long          | int           |\n+---------------+---------------+---------------+\n| number (real) | float         | float         |\n+---------------+---------------+---------------+\n| true          | True          | True          |\n+---------------+---------------+---------------+\n| false         | False         | False         |\n+---------------+---------------+---------------+\n| null          | None          | None          |\n+---------------+---------------+---------------+\n| NaN           | np.nan        | np.nan        |\n+---------------+---------------+---------------+\n| Infinity      | np.inf        | np.inf        |\n+---------------+---------------+---------------+\n| -Infinity     | -np.inf       | -np.inf       |\n+---------------+---------------+---------------+\n\n\nConversion from XML to Python\n-----------------------------\n\nThe Python-XML conversions use the xmltodict Python package.  The text\nfields will be interpreted based on the following sequential tests:\n\n+------------------+----------+----------+\n| XML text         | Python 2 | Python 3 |\n+==================+==========+==========+\n| == \u2018True\u2019        | True     | True     |\n+------------------+----------+----------+\n| == \u2018False\u2019       | False    | False    |\n+------------------+----------+----------+\n| == \u2018\u2019            | None     | None     |\n+------------------+----------+----------+\n| == \u2018NaN\u2019         | np.nan   | np.nan   |\n+------------------+----------+----------+\n| == \u2018Infinity\u2019    | np.inf   | np.inf   |\n+------------------+----------+----------+\n| == \u2018-Infinity\u2019   | -np.inf  | -np.inf  |\n+------------------+----------+----------+\n| try: int(text)   | long     | int      |\n+------------------+----------+----------+\n| try: float(text) | float    | float    |\n+------------------+----------+----------+\n| otherwise        | unicode  | str      |\n+------------------+----------+----------+\n\nThe reverse conversions are done for the special characters mentioned\nin the Conversion from Python to XML section above.\n\nAny \u2018attr\u2019 attribute fields are converted to elements named \u2018@attr\u2019\nand corresponding \u2018#text\u2019 elements are created if needed.\n\n\nClass Documentation\n===================\n\nDataModelDict class for representing data models equivalently in\nPython, JSON, and XML.\n\n**class DataModelDict.DataModelDict(*args, kwargs)**\n\n   Bases: ``collections.OrderedDict``, ``object``\n\n   Class for handling json/xml equivalent data structures.\n\n   **append(key, value)**\n\n      Adds a value for element key by either adding key to the\n      dictionary or appending the value as a list to any current\n      value.\n\n      :Parameters:\n         * **key** (*str*) \u2013 The dictionary key.\n\n         * **value** \u2013 The value to add to the dictionary key.  If key\n           exists, the element is converted to a list if needed and\n           value is appended.\n\n   **aslist(key)**\n\n      Gets the value of a dictionary key as a list.  Useful for\n      elements whose values may or may not be lists.\n\n      :Parameters:\n         **key** (*str*) \u2013 Dictionary key\n\n      :Returns:\n         The dictionary\u2019s element value or [value] depending on if it\n         already is a list.\n\n      :Return type:\n         list\n\n   **find(key, yes={}, no={})**\n\n      Return the value of a subelement at any level uniquely\n      identified by the specified conditions.\n\n      :Parameters:\n         * **key** (*str*) \u2013 Dictionary key to search for.\n\n         * **yes** (*dict*) \u2013 Key-value terms which the subelement\n           must have to be considered a match.\n\n         * **no** (*dict*) \u2013 Key-value terms which the subelement must\n           not have to be considered a match.\n\n      :Returns:\n         The value of the uniquely identified subelement.\n\n      :Return type:\n         any\n\n      :Raises:\n         ``ValueError`` \u2013 If exactly one matching subelement is not\n         identified.\n\n   **finds(key, yes={}, no={})**\n\n      Finds the values of all subelements at any level identified by\n      the specified conditions.\n\n      :Parameters:\n         * **key** (*str*) \u2013 Dictionary key to search for.\n\n         * **yes** (*dict*) \u2013 Key-value terms which the subelement\n           must have to be considered a match.\n\n         * **no** (*dict*) \u2013 Key-value terms which the subelement must\n           not have to be considered a match.\n\n      :Returns:\n         The values of any matching subelements.\n\n      :Return type:\n         list\n\n   **iteraslist(key)**\n\n      Iterates through the values of a dictionary key.  Useful for\n      elements whose values may or may not be lists.\n\n      :Parameters:\n         **key** (*str*) \u2013 Dictionary key\n\n      :Yields:\n         *any* \u2013 The dictionary\u2019s value or each element in value if\n         value is a list.\n\n   **iterfinds(key, yes={}, no={})**\n\n      Iterates over the values of all subelements at any level\n      identified by the specified conditions.\n\n      :Parameters:\n         * **key** (*str*) \u2013 Dictionary key to search for.\n\n         * **yes** (*dict*) \u2013 Key-value terms which the subelement\n           must have to be considered a match.\n\n         * **no** (*dict*) \u2013 Key-value terms which the subelement must\n           not have to be considered a match.\n\n      :Yields:\n         *any* \u2013 The values of any matching subelements.\n\n   **iterpaths(key, yes={}, no={})**\n\n      Iterates over the path lists to all elements at any level\n      identified by the specified conditions.\n\n      :Parameters:\n         * **key** (*str*) \u2013 Dictionary key to search for.\n\n         * **yes** (*dict*) \u2013 Key-value terms which the subelement\n           must have to be considered a match.\n\n         * **no** (*dict*) \u2013 Key-value terms which the subelement must\n           not have to be considered a match.\n\n      :Yields:\n         *list of str* \u2013 The path lists to any matching subelements.\n\n   **itervaluepaths()**\n\n      Iterates over path lists to all value elements at any level.\n\n      :Yields:\n         *list* \u2013 The path lists to all value subelements.\n\n   **json(fp=None, indent=None, separators=(', ', ': '))**\n\n      Converts the DataModelDict to JSON content.\n\n      :Parameters:\n         * **fp** (*file-like object or None, optional*) \u2013 An\n           open file to write the content to.  If None (default), then\n           the content is returned as a str.\n\n         * **indent** (*int or None, optional*) \u2013 Number of\n           spaces to indent lines.  If None (default), the content\n           will be inline.\n\n         * **separators** (*tuple of str, optional*) \u2013 Allows for\n           item_separator and dict_separator) to be changed. Default\n           is (\u2018, \u2018, \u2018: \u2018).\n\n      :Returns:\n         The JSON content (only returned if fp is None).\n\n      :Return type:\n         str, optional\n\n   **load(model, format=None)**\n\n      Read in values from a json/xml string or file-like object.\n\n      :Parameters:\n         * **model** (*str or file-like object*) \u2013 The XML or JSON\n           content to read.  This is allowed to be either a file path,\n           a string representation, or an open file-like object in\n           byte mode.\n\n         * **format** (*str or None, optional*) \u2013 Allows for\n           the format of the content to be explicitly stated (\u2018xml\u2019 or\n           \u2018json\u2019).  If None (default), will try to determine which\n           format based on if the first character of model is \u2018<\u2019 or\n           \u2018{\u2018.\n\n      :Raises:\n         ``ValueError`` \u2013 If format is None and unable to identify\n         XML/JON content, or if format is not equal to \u2018xml\u2019 or\n         \u2018json\u2019.\n\n   **path(key, yes={}, no={})**\n\n      Return the path list of a subelement at any level uniquely\n      identified by the specified conditions. Issues an error if\n      either no match, or multiple matches are found.\n\n      :Parameters:\n         * **key** (*str*) \u2013 Dictionary key to search for.\n\n         * **yes** (*dict*) \u2013 Key-value terms which the subelement\n           must have to be considered a match.\n\n         * **no** (*dict*) \u2013 Key-value terms which the subelement must\n           not have to be considered a match.\n\n      :Returns:\n         The subelement path list to the uniquely identified\n         subelement.\n\n      :Return type:\n         list of str\n\n      :Raises:\n         ``ValueError`` \u2013 If exactly one matching subelement is not\n         identified.\n\n   **paths(key, yes={}, no={})**\n\n      Return a list of all path lists of all elements at any level\n      identified by the specified conditions.\n\n      :Parameters:\n         * **key** (*str*) \u2013 Dictionary key to search for.\n\n         * **yes** (*dict*) \u2013 Key-value terms which the subelement\n           must have to be considered a match.\n\n         * **no** (*dict*) \u2013 Key-value terms which the subelement must\n           not have to be considered a match.\n\n      :Returns:\n         The path lists for any matching subelements.\n\n      :Return type:\n         list\n\n   **xml(fp=None, indent=None, full_document=True)**\n\n      Return the DataModelDict as XML content.\n\n      :Parameters:\n         * **fp** (*file-like object or None, optional*) \u2013 An\n           open file to write the content to.  If None (default), then\n           the content is returned as a str.\n\n         * **indent** (*int or None, optional*) \u2013 Number of\n           spaces to indent lines.  If None (default), the content\n           will be inline.\n\n         * **full_document** (*bool, optional*) \u2013 Indicates if the\n           output is associated with a full xml model.  If True\n           (default), the content can have only one root, and a header\n           is added.\n\n      :Returns:\n         The XML content (only returned if fp is None).\n\n      :Return type:\n         str, optional\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/usnistgov/DataModelDict/", "keywords": "json xml dictionary", "license": "", "maintainer": "", "maintainer_email": "", "name": "DataModelDict", "package_url": "https://pypi.org/project/DataModelDict/", "platform": "", "project_url": "https://pypi.org/project/DataModelDict/", "project_urls": {"Homepage": "https://github.com/usnistgov/DataModelDict/"}, "release_url": "https://pypi.org/project/DataModelDict/0.9.6/", "requires_dist": ["xmltodict"], "requires_python": "", "summary": "Class allowing for data models equivalently represented as Python dictionaries, JSON, and XML", "version": "0.9.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>The DataModelDict class is used for handling data models that have\nequivalent representations in XML, JSON, and Python.  Constructing\ndata models in this way is convenient as it supports compatibility\nacross different software tools, such as different types of databases.</p>\n<p>The DataModelDict class:</p>\n<ul>\n<li>is a child of OrderedDict,</li>\n<li>has methods for converting to/from XML and JSON,</li>\n<li>has methods for searching through elements, and</li>\n<li>has methods that help with constructing and interacting with\ncompliant data models.</li>\n</ul>\n</div>\n<div id=\"setup\">\n<h2>Setup</h2>\n<p>The code has no requirements that limit which systems it can be used\non, i.e. it should work on Linux, Mac and Windows computers.</p>\n<p>The latest release can be installed using pip:</p>\n<pre>pip install DataModelDict\n</pre>\n<p>The code and all documentation is hosted on GitHub and can be directly\ndownloaded at <a href=\"https://github.com/usnistgov/DataModelDict\" rel=\"nofollow\">https://github.com/usnistgov/DataModelDict</a>.</p>\n</div>\n<div id=\"conversions\">\n<h2>Conversions</h2>\n<p>Some considerations need to be taken into account for designing data\nmodels that allow for exact reversible transformations between the\nthree formats:</p>\n<ul>\n<li>Valid, full XML requires that there is exactly one root element.  In\nother words, the top-level DataModelDict of a data model   can have\nonly one key.</li>\n<li>Do not use lists of lists for representing data.  The XML\nconversions are only reversible for lists of values or lists of\ndictionaries.  Future updates may allow this.</li>\n<li>Avoid using XML attributes if possible.  While the XML conversions\ndo reversibly handle attributes, it complicates the Python and JSON\nrepresentations.</li>\n<li>Embedded XML content, i.e. \u201ctext with &lt;embed&gt;embedded&lt;/embed&gt;\ncontent\u201d, might not be reversible:</li>\n<li>XML subelements of the same name within an element should be given\nconsecutively.  When parsed, all values of subelements of the same\nname are collected together in a list.  This will alter the original\norder of subelements if matching names were not originally\nconsecutive.</li>\n</ul>\n<div id=\"conversion-from-python-to-json\">\n<h3>Conversion from Python to JSON</h3>\n<p>The Python-JSON conversions use the standard Python JSON library.  In\nconverting from Python to JSON, all elements of the DataModelDict must\nbe an instance of a supported data type (with unicode and long being\nspecific to Python 2).</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Python</th>\n<th>JSON</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>dict</td>\n<td>object</td>\n</tr>\n<tr><td>list, tuple</td>\n<td>array</td>\n</tr>\n<tr><td>str, unicode</td>\n<td>string</td>\n</tr>\n<tr><td>int, long, float</td>\n<td>number</td>\n</tr>\n<tr><td>True</td>\n<td>true</td>\n</tr>\n<tr><td>False</td>\n<td>false</td>\n</tr>\n<tr><td>None</td>\n<td>null</td>\n</tr>\n<tr><td>np.nan</td>\n<td>NaN</td>\n</tr>\n<tr><td>np.inf</td>\n<td>Infinity</td>\n</tr>\n<tr><td>-np.inf</td>\n<td>-Infinity</td>\n</tr>\n</tbody>\n</table>\n<p>As DataModelDict is a child of OrderedDict, it registers as being an\ninstance of dict. Any other objects would first need to be converted\nto one of these types, e.g. a numpy array would need to be converted\nto a list.</p>\n</div>\n<div id=\"conversion-from-python-to-xml\">\n<h3>Conversion from Python to XML</h3>\n<p>The Python-XML conversions use the xmltodict Python package. The XML\ncontent is constructed based on the Python data types.</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Python</th>\n<th>XML</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>dict</td>\n<td>subelement</td>\n</tr>\n<tr><td>list, tuple</td>\n<td>repeated element</td>\n</tr>\n<tr><td>str, unicode</td>\n<td>text</td>\n</tr>\n<tr><td>int, long, float</td>\n<td>text (from repr)</td>\n</tr>\n<tr><td>True</td>\n<td>text = True</td>\n</tr>\n<tr><td>False</td>\n<td>text = False</td>\n</tr>\n<tr><td>None</td>\n<td>empty text field</td>\n</tr>\n<tr><td>np.nan</td>\n<td>text = NaN</td>\n</tr>\n<tr><td>np.inf</td>\n<td>text = Infinity</td>\n</tr>\n<tr><td>-np.inf</td>\n<td>text = -Infinity</td>\n</tr>\n</tbody>\n</table>\n<p>Some characters in the XML text fields will also be converted to avoid\nconflicts.</p>\n<ul>\n<li>XML limited characters such as &lt;, &gt; and &amp; are converted to their\nHTML entities.</li>\n<li>n, t, r are converted to n, t, and r</li>\n</ul>\n<p>Any dictionary keys starting with \u2018@\u2019 will be converted into XML\nattributes, and the dictionary key \u2018#text\u2019 is interpreted as the text\nvalue of the element.</p>\n</div>\n<div id=\"conversion-from-json-to-python\">\n<h3>Conversion from JSON to Python</h3>\n<p>The Python-JSON conversions use the standard Python JSON library.  In\nconverting from JSON to Python, the conversions of types is\nstraight-forward.</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>JSON</th>\n<th>Python 2</th>\n<th>Python 3</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>object</td>\n<td>DataModelDict</td>\n<td>DataModelDict</td>\n</tr>\n<tr><td>array</td>\n<td>list</td>\n<td>list</td>\n</tr>\n<tr><td>string</td>\n<td>unicode</td>\n<td>str</td>\n</tr>\n<tr><td>number (int)</td>\n<td>long</td>\n<td>int</td>\n</tr>\n<tr><td>number (real)</td>\n<td>float</td>\n<td>float</td>\n</tr>\n<tr><td>true</td>\n<td>True</td>\n<td>True</td>\n</tr>\n<tr><td>false</td>\n<td>False</td>\n<td>False</td>\n</tr>\n<tr><td>null</td>\n<td>None</td>\n<td>None</td>\n</tr>\n<tr><td>NaN</td>\n<td>np.nan</td>\n<td>np.nan</td>\n</tr>\n<tr><td>Infinity</td>\n<td>np.inf</td>\n<td>np.inf</td>\n</tr>\n<tr><td>-Infinity</td>\n<td>-np.inf</td>\n<td>-np.inf</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"conversion-from-xml-to-python\">\n<h3>Conversion from XML to Python</h3>\n<p>The Python-XML conversions use the xmltodict Python package.  The text\nfields will be interpreted based on the following sequential tests:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>XML text</th>\n<th>Python 2</th>\n<th>Python 3</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>== \u2018True\u2019</td>\n<td>True</td>\n<td>True</td>\n</tr>\n<tr><td>== \u2018False\u2019</td>\n<td>False</td>\n<td>False</td>\n</tr>\n<tr><td>== \u2018\u2019</td>\n<td>None</td>\n<td>None</td>\n</tr>\n<tr><td>== \u2018NaN\u2019</td>\n<td>np.nan</td>\n<td>np.nan</td>\n</tr>\n<tr><td>== \u2018Infinity\u2019</td>\n<td>np.inf</td>\n<td>np.inf</td>\n</tr>\n<tr><td>== \u2018-Infinity\u2019</td>\n<td>-np.inf</td>\n<td>-np.inf</td>\n</tr>\n<tr><td>try: int(text)</td>\n<td>long</td>\n<td>int</td>\n</tr>\n<tr><td>try: float(text)</td>\n<td>float</td>\n<td>float</td>\n</tr>\n<tr><td>otherwise</td>\n<td>unicode</td>\n<td>str</td>\n</tr>\n</tbody>\n</table>\n<p>The reverse conversions are done for the special characters mentioned\nin the Conversion from Python to XML section above.</p>\n<p>Any \u2018attr\u2019 attribute fields are converted to elements named \u2018@attr\u2019\nand corresponding \u2018#text\u2019 elements are created if needed.</p>\n</div>\n</div>\n<div id=\"class-documentation\">\n<h2>Class Documentation</h2>\n<p>DataModelDict class for representing data models equivalently in\nPython, JSON, and XML.</p>\n<p><strong>class DataModelDict.DataModelDict(*args, kwargs)</strong></p>\n<blockquote>\n<p>Bases: <tt>collections.OrderedDict</tt>, <tt>object</tt></p>\n<p>Class for handling json/xml equivalent data structures.</p>\n<p><strong>append(key, value)</strong></p>\n<blockquote>\n<p>Adds a value for element key by either adding key to the\ndictionary or appending the value as a list to any current\nvalue.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>key</strong> (<em>str</em>) \u2013 The dictionary key.</li>\n<li><strong>value</strong> \u2013 The value to add to the dictionary key.  If key\nexists, the element is converted to a list if needed and\nvalue is appended.</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>aslist(key)</strong></p>\n<blockquote>\n<p>Gets the value of a dictionary key as a list.  Useful for\nelements whose values may or may not be lists.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><strong>key</strong> (<em>str</em>) \u2013 Dictionary key</td>\n</tr>\n<tr><th>Returns:</th><td>The dictionary\u2019s element value or [value] depending on if it\nalready is a list.</td>\n</tr>\n<tr><th>Return type:</th><td>list</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>find(key, yes={}, no={})</strong></p>\n<blockquote>\n<p>Return the value of a subelement at any level uniquely\nidentified by the specified conditions.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>key</strong> (<em>str</em>) \u2013 Dictionary key to search for.</li>\n<li><strong>yes</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement\nmust have to be considered a match.</li>\n<li><strong>no</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement must\nnot have to be considered a match.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Returns:</th><td><p>The value of the uniquely identified subelement.</p>\n</td>\n</tr>\n<tr><th>Return type:</th><td><p>any</p>\n</td>\n</tr>\n<tr><th>Raises:</th><td><p><tt>ValueError</tt> \u2013 If exactly one matching subelement is not\nidentified.</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>finds(key, yes={}, no={})</strong></p>\n<blockquote>\n<p>Finds the values of all subelements at any level identified by\nthe specified conditions.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>key</strong> (<em>str</em>) \u2013 Dictionary key to search for.</li>\n<li><strong>yes</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement\nmust have to be considered a match.</li>\n<li><strong>no</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement must\nnot have to be considered a match.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Returns:</th><td><p>The values of any matching subelements.</p>\n</td>\n</tr>\n<tr><th>Return type:</th><td><p>list</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>iteraslist(key)</strong></p>\n<blockquote>\n<p>Iterates through the values of a dictionary key.  Useful for\nelements whose values may or may not be lists.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><strong>key</strong> (<em>str</em>) \u2013 Dictionary key</td>\n</tr>\n<tr><th>Yields:</th><td><em>any</em> \u2013 The dictionary\u2019s value or each element in value if\nvalue is a list.</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>iterfinds(key, yes={}, no={})</strong></p>\n<blockquote>\n<p>Iterates over the values of all subelements at any level\nidentified by the specified conditions.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>key</strong> (<em>str</em>) \u2013 Dictionary key to search for.</li>\n<li><strong>yes</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement\nmust have to be considered a match.</li>\n<li><strong>no</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement must\nnot have to be considered a match.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Yields:</th><td><p><em>any</em> \u2013 The values of any matching subelements.</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>iterpaths(key, yes={}, no={})</strong></p>\n<blockquote>\n<p>Iterates over the path lists to all elements at any level\nidentified by the specified conditions.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>key</strong> (<em>str</em>) \u2013 Dictionary key to search for.</li>\n<li><strong>yes</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement\nmust have to be considered a match.</li>\n<li><strong>no</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement must\nnot have to be considered a match.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Yields:</th><td><p><em>list of str</em> \u2013 The path lists to any matching subelements.</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>itervaluepaths()</strong></p>\n<blockquote>\n<p>Iterates over path lists to all value elements at any level.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Yields:</th><td><em>list</em> \u2013 The path lists to all value subelements.</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>json(fp=None, indent=None, separators=(\u2018, \u2018, \u2018: \u2018))</strong></p>\n<blockquote>\n<p>Converts the DataModelDict to JSON content.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>fp</strong> (<em>file-like object or None, optional</em>) \u2013 An\nopen file to write the content to.  If None (default), then\nthe content is returned as a str.</li>\n<li><strong>indent</strong> (<em>int or None, optional</em>) \u2013 Number of\nspaces to indent lines.  If None (default), the content\nwill be inline.</li>\n<li><strong>separators</strong> (<em>tuple of str, optional</em>) \u2013 Allows for\nitem_separator and dict_separator) to be changed. Default\nis (\u2018, \u2018, \u2018: \u2018).</li>\n</ul>\n</td>\n</tr>\n<tr><th>Returns:</th><td><p>The JSON content (only returned if fp is None).</p>\n</td>\n</tr>\n<tr><th>Return type:</th><td><p>str, optional</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>load(model, format=None)</strong></p>\n<blockquote>\n<p>Read in values from a json/xml string or file-like object.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>model</strong> (<em>str or file-like object</em>) \u2013 The XML or JSON\ncontent to read.  This is allowed to be either a file path,\na string representation, or an open file-like object in\nbyte mode.</li>\n<li><strong>format</strong> (<em>str or None, optional</em>) \u2013 Allows for\nthe format of the content to be explicitly stated (\u2018xml\u2019 or\n\u2018json\u2019).  If None (default), will try to determine which\nformat based on if the first character of model is \u2018&lt;\u2019 or\n\u2018{\u2018.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Raises:</th><td><p><tt>ValueError</tt> \u2013 If format is None and unable to identify\nXML/JON content, or if format is not equal to \u2018xml\u2019 or\n\u2018json\u2019.</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>path(key, yes={}, no={})</strong></p>\n<blockquote>\n<p>Return the path list of a subelement at any level uniquely\nidentified by the specified conditions. Issues an error if\neither no match, or multiple matches are found.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>key</strong> (<em>str</em>) \u2013 Dictionary key to search for.</li>\n<li><strong>yes</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement\nmust have to be considered a match.</li>\n<li><strong>no</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement must\nnot have to be considered a match.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Returns:</th><td><p>The subelement path list to the uniquely identified\nsubelement.</p>\n</td>\n</tr>\n<tr><th>Return type:</th><td><p>list of str</p>\n</td>\n</tr>\n<tr><th>Raises:</th><td><p><tt>ValueError</tt> \u2013 If exactly one matching subelement is not\nidentified.</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>paths(key, yes={}, no={})</strong></p>\n<blockquote>\n<p>Return a list of all path lists of all elements at any level\nidentified by the specified conditions.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>key</strong> (<em>str</em>) \u2013 Dictionary key to search for.</li>\n<li><strong>yes</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement\nmust have to be considered a match.</li>\n<li><strong>no</strong> (<em>dict</em>) \u2013 Key-value terms which the subelement must\nnot have to be considered a match.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Returns:</th><td><p>The path lists for any matching subelements.</p>\n</td>\n</tr>\n<tr><th>Return type:</th><td><p>list</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><strong>xml(fp=None, indent=None, full_document=True)</strong></p>\n<blockquote>\n<p>Return the DataModelDict as XML content.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Parameters:</th><td><ul>\n<li><strong>fp</strong> (<em>file-like object or None, optional</em>) \u2013 An\nopen file to write the content to.  If None (default), then\nthe content is returned as a str.</li>\n<li><strong>indent</strong> (<em>int or None, optional</em>) \u2013 Number of\nspaces to indent lines.  If None (default), the content\nwill be inline.</li>\n<li><strong>full_document</strong> (<em>bool, optional</em>) \u2013 Indicates if the\noutput is associated with a full xml model.  If True\n(default), the content can have only one root, and a header\nis added.</li>\n</ul>\n</td>\n</tr>\n<tr><th>Returns:</th><td><p>The XML content (only returned if fp is None).</p>\n</td>\n</tr>\n<tr><th>Return type:</th><td><p>str, optional</p>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</blockquote>\n</div>\n\n          </div>"}, "last_serial": 5396279, "releases": {"0.8": [{"comment_text": "", "digests": {"md5": "7a0be97cd38f8d7846aa6044073a5a91", "sha256": "c497ee3c894f963d19365b9ceeb31b97f5b4caa67bdd6aeabf4d67fc2724eecc"}, "downloads": -1, "filename": "DataModelDict-0.8.zip", "has_sig": false, "md5_digest": "7a0be97cd38f8d7846aa6044073a5a91", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9700, "upload_time": "2016-03-15T21:03:16", "upload_time_iso_8601": "2016-03-15T21:03:16.291187Z", "url": "https://files.pythonhosted.org/packages/00/ee/65b8384dec214670e264ffd352552da437b15dc8f9b43c81367429bbb6d0/DataModelDict-0.8.zip", "yanked": false}], "0.8.1": [{"comment_text": "", "digests": {"md5": "eed4434cb433d6015190f11d7bf9ff23", "sha256": "07ae8cad9fbd1c5a71fee1462c0cdd40e985238a0ad6ede11c1e0cf4970b97f5"}, "downloads": -1, "filename": "DataModelDict-0.8.1-py2-none-any.whl", "has_sig": false, "md5_digest": "eed4434cb433d6015190f11d7bf9ff23", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 8373, "upload_time": "2017-07-12T20:42:40", "upload_time_iso_8601": "2017-07-12T20:42:40.118662Z", "url": "https://files.pythonhosted.org/packages/e1/ed/e7b7a675753a7900cc12468bf81279af75ab8baa5e53596f146d415f5dc9/DataModelDict-0.8.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0e5a85db8dc346ae47f02cb4947e8bf0", "sha256": "4515a79b64f0a67844d6f2c17d625db2d7f5d168545884eda1f28aa58bdf1b31"}, "downloads": -1, "filename": "DataModelDict-0.8.1.tar.gz", "has_sig": false, "md5_digest": "0e5a85db8dc346ae47f02cb4947e8bf0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6176, "upload_time": "2017-07-12T20:42:41", "upload_time_iso_8601": "2017-07-12T20:42:41.647389Z", "url": "https://files.pythonhosted.org/packages/d2/f0/e0492c7315d50d83371f17795c829b525e9b32bf030fdd5c974ef6389e61/DataModelDict-0.8.1.tar.gz", "yanked": false}], "0.9.0": [{"comment_text": "", "digests": {"md5": "c0ac776fabff64a5f6eeb137d6aacadd", "sha256": "e7b62a3986d2d33be172376833aa47af17440fff32d1635b21878ad6e8bdc805"}, "downloads": -1, "filename": "DataModelDict-0.9.0-py2-none-any.whl", "has_sig": false, "md5_digest": "c0ac776fabff64a5f6eeb137d6aacadd", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 14321, "upload_time": "2017-08-10T16:26:04", "upload_time_iso_8601": "2017-08-10T16:26:04.584926Z", "url": "https://files.pythonhosted.org/packages/1a/f2/9f23ab1107a056d12b8ec0fc597d0296c8c4b9248604d6f87db48389b633/DataModelDict-0.9.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2dfec6b1135961860e39add15fab2d67", "sha256": "2f9b407351be0322e899b40f8e339d18345163d0d3457a90357e68d7b17e3222"}, "downloads": -1, "filename": "DataModelDict-0.9.0.tar.gz", "has_sig": false, "md5_digest": "2dfec6b1135961860e39add15fab2d67", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13099, "upload_time": "2017-08-10T16:26:05", "upload_time_iso_8601": "2017-08-10T16:26:05.754485Z", "url": "https://files.pythonhosted.org/packages/68/2f/f05cb8a0d41456165e6b86211e7c19682b92f140122f55d0e997a87d2ec3/DataModelDict-0.9.0.tar.gz", "yanked": false}], "0.9.1": [{"comment_text": "", "digests": {"md5": "f037735f301354ea096b786e8bd582f0", "sha256": "19ac5283fdd74b416e758522bf7e0408a82dd0f9f177425ceecb2b8af80c7081"}, "downloads": -1, "filename": "DataModelDict-0.9.1-py2-none-any.whl", "has_sig": false, "md5_digest": "f037735f301354ea096b786e8bd582f0", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 14325, "upload_time": "2017-08-10T17:17:42", "upload_time_iso_8601": "2017-08-10T17:17:42.612178Z", "url": "https://files.pythonhosted.org/packages/b6/22/1b8f4d389590749c922f6ddcdd0e000eae68ecacc0b2efdbb539bdef90af/DataModelDict-0.9.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0f40df836df1da09bce71d64bb2edfea", "sha256": "ac777b0db579dc690046b360b61a20f9845dd5c8c9b0f4cf8e86b7efe26d8917"}, "downloads": -1, "filename": "DataModelDict-0.9.1.tar.gz", "has_sig": false, "md5_digest": "0f40df836df1da09bce71d64bb2edfea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13248, "upload_time": "2017-08-10T17:17:43", "upload_time_iso_8601": "2017-08-10T17:17:43.703926Z", "url": "https://files.pythonhosted.org/packages/1e/64/a98655bfded0d3a461e745e5008e8690a69703cc20f5dfd7c68494a0b60b/DataModelDict-0.9.1.tar.gz", "yanked": false}], "0.9.2": [{"comment_text": "", "digests": {"md5": "a82bfad09b251fa66c0d7945fa6fa4a0", "sha256": "18cd9fde0e2db701c80ccc00922d1b15e1f8eb36c6ff4c785b03c27c7982d546"}, "downloads": -1, "filename": "DataModelDict-0.9.2-py2-none-any.whl", "has_sig": false, "md5_digest": "a82bfad09b251fa66c0d7945fa6fa4a0", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 14198, "upload_time": "2017-08-10T17:52:21", "upload_time_iso_8601": "2017-08-10T17:52:21.928713Z", "url": "https://files.pythonhosted.org/packages/3b/99/dcc1ab717ae1809bca94acb37efab724bed04da2d8221413c0412a442939/DataModelDict-0.9.2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c155ce37f65d459f120ad1877c0088e6", "sha256": "3f388c6ade8553c72afb4be45672bfa214174df98acae226e307156d764be1d2"}, "downloads": -1, "filename": "DataModelDict-0.9.2.tar.gz", "has_sig": false, "md5_digest": "c155ce37f65d459f120ad1877c0088e6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13086, "upload_time": "2017-08-10T17:52:22", "upload_time_iso_8601": "2017-08-10T17:52:22.985994Z", "url": "https://files.pythonhosted.org/packages/15/a5/71420edfd2a142fe68857805e19614a1d03632b092d81173ab2b9a140434/DataModelDict-0.9.2.tar.gz", "yanked": false}], "0.9.3": [{"comment_text": "", "digests": {"md5": "402a6c3ea5228e32964be555a9eda0c6", "sha256": "21d6132bb7504b6555b346508d6b8505984583a11c3b1edcd94eedd1aa032eee"}, "downloads": -1, "filename": "DataModelDict-0.9.3-py3-none-any.whl", "has_sig": false, "md5_digest": "402a6c3ea5228e32964be555a9eda0c6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14217, "upload_time": "2018-05-07T13:38:23", "upload_time_iso_8601": "2018-05-07T13:38:23.089955Z", "url": "https://files.pythonhosted.org/packages/67/76/e6b4a6acadfde02d88df69f4b1d9e0e5a179e9d23e72f9d91bb084ed9ded/DataModelDict-0.9.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "afb01a0a42084888a213331003dcd366", "sha256": "aa802974a5380a280ee25bc68a3359beacfb3355c905be2bdc8c59081f778e9c"}, "downloads": -1, "filename": "DataModelDict-0.9.3.tar.gz", "has_sig": false, "md5_digest": "afb01a0a42084888a213331003dcd366", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13165, "upload_time": "2018-05-07T13:38:23", "upload_time_iso_8601": "2018-05-07T13:38:23.866354Z", "url": "https://files.pythonhosted.org/packages/34/68/268a106076ca20bdde3753537dea2c4db89888121176e501727455c3855b/DataModelDict-0.9.3.tar.gz", "yanked": false}], "0.9.4": [{"comment_text": "", "digests": {"md5": "978bd99d50c67b331203f8c18b664bc2", "sha256": "cfd996df544ea2f2a8b5fb51ba5a663fc2880a243619b730731498f7c8b7a8cc"}, "downloads": -1, "filename": "DataModelDict-0.9.4-py3-none-any.whl", "has_sig": false, "md5_digest": "978bd99d50c67b331203f8c18b664bc2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9636, "upload_time": "2018-05-30T15:46:28", "upload_time_iso_8601": "2018-05-30T15:46:28.819291Z", "url": "https://files.pythonhosted.org/packages/8d/fb/5fe241e68d79dc1225a671e48e4818a996c255bf65d94a53f5eea4c2f23e/DataModelDict-0.9.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f6c60efbd7b9ea68c0557df29265d827", "sha256": "97d8e999e000cf69c48e57b1a72eb45a27d83576a38c6cd8550c230b018be7af"}, "downloads": -1, "filename": "DataModelDict-0.9.4.tar.gz", "has_sig": false, "md5_digest": "f6c60efbd7b9ea68c0557df29265d827", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13174, "upload_time": "2018-05-30T15:46:30", "upload_time_iso_8601": "2018-05-30T15:46:30.225536Z", "url": "https://files.pythonhosted.org/packages/2d/58/ddcfc62fccd84f5224ebf41c2c6a5f847edb52917a7ef91819e8490c2405/DataModelDict-0.9.4.tar.gz", "yanked": false}], "0.9.5": [{"comment_text": "", "digests": {"md5": "c10f2d6964a2c5ea04e8dd386992abba", "sha256": "0382cfb6472a237bd1314f4de0b1eed68cd679562a23dc9b7cb24e85943dbd10"}, "downloads": -1, "filename": "DataModelDict-0.9.5-py3-none-any.whl", "has_sig": false, "md5_digest": "c10f2d6964a2c5ea04e8dd386992abba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9626, "upload_time": "2018-11-09T17:42:19", "upload_time_iso_8601": "2018-11-09T17:42:19.398521Z", "url": "https://files.pythonhosted.org/packages/43/10/70be6bf733f1d3b8c62a5ad8fc142b00717aa68a89553698378d171096a6/DataModelDict-0.9.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a509dec9bba6735b8d93f999bbe8c09a", "sha256": "afa15c137c09e7d937e31c8956fd8092be0251c9869a6b7c1d0f81c0901bc47d"}, "downloads": -1, "filename": "DataModelDict-0.9.5.tar.gz", "has_sig": false, "md5_digest": "a509dec9bba6735b8d93f999bbe8c09a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13170, "upload_time": "2018-11-09T17:42:21", "upload_time_iso_8601": "2018-11-09T17:42:21.026270Z", "url": "https://files.pythonhosted.org/packages/69/58/7cba23f7cad3dbaeea069e4d328ff4ea6825e271e39123434da00efc8643/DataModelDict-0.9.5.tar.gz", "yanked": false}], "0.9.6": [{"comment_text": "", "digests": {"md5": "40fc78235c54ce5a9a9a736c45d674f0", "sha256": "887e1d7551147ec440ae522e1d19bfa737f80a12efd214dfb648e0675cc6d0d3"}, "downloads": -1, "filename": "DataModelDict-0.9.6-py3-none-any.whl", "has_sig": false, "md5_digest": "40fc78235c54ce5a9a9a736c45d674f0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9784, "upload_time": "2019-06-13T15:03:20", "upload_time_iso_8601": "2019-06-13T15:03:20.438592Z", "url": "https://files.pythonhosted.org/packages/c8/9f/f7334927f9e6bc0cec478be0b76f37524e922d70626900e8d1643551338b/DataModelDict-0.9.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f6247ba362275f46719a232903d57f53", "sha256": "857d4bf33f0b26ca718bd821fda7502dd6fb15aa09201b1fbdfaf4dfc85b8f6c"}, "downloads": -1, "filename": "DataModelDict-0.9.6.tar.gz", "has_sig": false, "md5_digest": "f6247ba362275f46719a232903d57f53", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13430, "upload_time": "2019-06-13T15:03:22", "upload_time_iso_8601": "2019-06-13T15:03:22.134021Z", "url": "https://files.pythonhosted.org/packages/c8/84/6c9973cd9583631e385fe74d123470f05fd4aa3e0f23e824528fcb0c6fb5/DataModelDict-0.9.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "40fc78235c54ce5a9a9a736c45d674f0", "sha256": "887e1d7551147ec440ae522e1d19bfa737f80a12efd214dfb648e0675cc6d0d3"}, "downloads": -1, "filename": "DataModelDict-0.9.6-py3-none-any.whl", "has_sig": false, "md5_digest": "40fc78235c54ce5a9a9a736c45d674f0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9784, "upload_time": "2019-06-13T15:03:20", "upload_time_iso_8601": "2019-06-13T15:03:20.438592Z", "url": "https://files.pythonhosted.org/packages/c8/9f/f7334927f9e6bc0cec478be0b76f37524e922d70626900e8d1643551338b/DataModelDict-0.9.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f6247ba362275f46719a232903d57f53", "sha256": "857d4bf33f0b26ca718bd821fda7502dd6fb15aa09201b1fbdfaf4dfc85b8f6c"}, "downloads": -1, "filename": "DataModelDict-0.9.6.tar.gz", "has_sig": false, "md5_digest": "f6247ba362275f46719a232903d57f53", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13430, "upload_time": "2019-06-13T15:03:22", "upload_time_iso_8601": "2019-06-13T15:03:22.134021Z", "url": "https://files.pythonhosted.org/packages/c8/84/6c9973cd9583631e385fe74d123470f05fd4aa3e0f23e824528fcb0c6fb5/DataModelDict-0.9.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:40:19 2020"}