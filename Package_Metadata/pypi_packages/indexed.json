{"info": {"author": "Niklas Fiekas", "author_email": "niklas.fiekas@backscattering.de", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Python Software Foundation License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "indexed.IndexedOrderedDict: a dictionary that is indexed by insertion order\n===========================================================================\n\n.. image:: https://travis-ci.org/niklasf/indexed.py.png?branch=master\n    :target: https://travis-ci.org/niklasf/indexed.py\n    :alt: build\n\n.. image:: https://badge.fury.io/py/indexed.svg\n    :target: https://pypi.python.org/pypi/indexed\n    :alt: pypi package\n\nIntroduction\n------------\n\n``indexed.IndexedOrderedDict`` is fully compatible with\n``collections.OrderedDict`` and can be used as a drop in replacement.\nThe main difference is that key, value and item views support accessing\nelements by their index.\n\n::\n\n    d = indexed.IndexedOrderedDict()\n    d[\"first-key\"] = \"first-value\"\n    d[\"second-key\"] = \"second-value\"\n    d[\"third-key\"] = \"third-value\"\n\n    values = d.values()\n    assert values[2] == \"third-value\"\n\n    assert d.keys().index(\"second-key\") == 1\n\nFeatures\n--------\n\n* Access keys, values and items by index, e.g. ``d.keys()[5]``.\n\n* Find the index of a key, e.g. ``d.keys().index(\"key\")``.\n\nExcluding those additions the API is the same as the API of\n``collections.OrderedDict()``. Including:\n\n* Initializing, setting, getting and deleting items\n\n* Iterating forwards and in reverse\n\n* ``d.clear()``\n\n* ``d.popitem(last=True)``\n\n* ``d.move_to_end(key, last=True)``\n\n* ``d.keys()``, ``d.values()``, ``d.items()``\n\n* ``d.pop(key[, default])``\n\n* ``d.setdefault(key, default=None)``\n\n* String representation\n\n* Pickling\n\n* Copying\n\n* Creating from keys\n\n* Comparing order sensitively with other ordered dictionaries or order\n  insensitively with other mappings\n\nInstalling\n----------\n\n::\n\n    pip install indexed\n\n\nPerformance\n-----------\n\nPerformance is practically on the same order of magnitude as the built in\n``collections.OrderedDict``, with exceptions in bold:\n\n================= ========== ================== ======== ======================\nd                 ``collections.OrderedDict``   ``indexed.IndexedOrderedDict``\n----------------- ----------------------------- -------------------------------\nOperation         Avergage   Worst case         Average  Worst case\n================= ========== ================== ======== ======================\nd.copy()          O(n)       O(n)               O(n)     O(n)  \n----------------- ---------- ------------------ -------- ----------------------\nd[key]            O(1)       O(n)               O(1)     O(n)\n----------------- ---------- ------------------ -------- ----------------------\nd[key] = value    O(1)       O(n) [#a]_         O(1)     O(n) [#a]_\n----------------- ---------- ------------------ -------- ----------------------\ndel d[key]        **O(1)**   O(n)               O(n)     O(n)\n----------------- ---------- ------------------ -------- ----------------------\nd.keys()[i]       O(n) [#k]_ O(n) [#k]_         **O(1)** **O(1)**\n----------------- ---------- ------------------ -------- ----------------------\nd.values()[i]     O(n) [#v]_ O(n) [#v]_         **O(1)** O(n)\n----------------- ---------- ------------------ -------- ----------------------\nd.items()[i]      O(n) [#v]_ O(n) [#v]_         **O(1)** O(n)\n----------------- ---------- ------------------ -------- ----------------------\nd.keys().index(x) O(n) [#v]_ O(n) [#v]_         O(n)     O(n)\n================= ========== ================== ======== ======================\n\n.. [#a] These are amortized_ worst case runtimes.\n.. [#k] This does not work in Python 3 because ``colections.KeysView`` is not\n        indexable. One of the theoretically best work arounds is\n        ``next(itertools.islice(d.keys(), i, i + 1))``.\n.. [#v] Assuming the theoretically best possible workaround.\n\nLicense\n-------\n\nThis library is derived from CPython's ``collections.OrderedDict``\nand licensed under the PSFL.\nSee the LICENSE file for the full license text.\n\n.. _amortized: http://en.wikipedia.org/wiki/Amortized_analysis\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/niklasf/indexed.py", "keywords": "", "license": "PSFL", "maintainer": "", "maintainer_email": "", "name": "indexed", "package_url": "https://pypi.org/project/indexed/", "platform": "", "project_url": "https://pypi.org/project/indexed/", "project_urls": {"Homepage": "http://github.com/niklasf/indexed.py"}, "release_url": "https://pypi.org/project/indexed/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "A dictionary that is indexed by insertion order.", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/niklasf/indexed.py\" rel=\"nofollow\"><img alt=\"build\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3fb4c5a85c3b85e652aa7466fcead19afd9812c1/68747470733a2f2f7472617669732d63692e6f72672f6e696b6c6173662f696e64657865642e70792e706e673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.python.org/pypi/indexed\" rel=\"nofollow\"><img alt=\"pypi package\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cb46dab569f87066d43b627bc2dce9e9cc5919df/68747470733a2f2f62616467652e667572792e696f2f70792f696e64657865642e737667\"></a>\n<div id=\"introduction\">\n<h2>Introduction</h2>\n<p><tt>indexed.IndexedOrderedDict</tt> is fully compatible with\n<tt>collections.OrderedDict</tt> and can be used as a drop in replacement.\nThe main difference is that key, value and item views support accessing\nelements by their index.</p>\n<pre>d = indexed.IndexedOrderedDict()\nd[\"first-key\"] = \"first-value\"\nd[\"second-key\"] = \"second-value\"\nd[\"third-key\"] = \"third-value\"\n\nvalues = d.values()\nassert values[2] == \"third-value\"\n\nassert d.keys().index(\"second-key\") == 1\n</pre>\n</div>\n<div id=\"features\">\n<h2>Features</h2>\n<ul>\n<li>Access keys, values and items by index, e.g. <tt><span class=\"pre\">d.keys()[5]</span></tt>.</li>\n<li>Find the index of a key, e.g. <tt><span class=\"pre\">d.keys().index(\"key\")</span></tt>.</li>\n</ul>\n<p>Excluding those additions the API is the same as the API of\n<tt>collections.OrderedDict()</tt>. Including:</p>\n<ul>\n<li>Initializing, setting, getting and deleting items</li>\n<li>Iterating forwards and in reverse</li>\n<li><tt>d.clear()</tt></li>\n<li><tt>d.popitem(last=True)</tt></li>\n<li><tt>d.move_to_end(key, last=True)</tt></li>\n<li><tt>d.keys()</tt>, <tt>d.values()</tt>, <tt>d.items()</tt></li>\n<li><tt>d.pop(key[, default])</tt></li>\n<li><tt>d.setdefault(key, default=None)</tt></li>\n<li>String representation</li>\n<li>Pickling</li>\n<li>Copying</li>\n<li>Creating from keys</li>\n<li>Comparing order sensitively with other ordered dictionaries or order\ninsensitively with other mappings</li>\n</ul>\n</div>\n<div id=\"installing\">\n<h2>Installing</h2>\n<pre>pip install indexed\n</pre>\n</div>\n<div id=\"performance\">\n<h2>Performance</h2>\n<p>Performance is practically on the same order of magnitude as the built in\n<tt>collections.OrderedDict</tt>, with exceptions in bold:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>d</th>\n<th><tt>collections.OrderedDict</tt></th>\n<th><tt>indexed.IndexedOrderedDict</tt></th>\n</tr>\n<tr><th>Operation</th>\n<th>Avergage</th>\n<th>Worst case</th>\n<th>Average</th>\n<th>Worst case</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>d.copy()</td>\n<td>O(n)</td>\n<td>O(n)</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr><td>d[key]</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr><td>d[key] = value</td>\n<td>O(1)</td>\n<td>O(n) <a href=\"#a\" id=\"id1\" rel=\"nofollow\">[1]</a></td>\n<td>O(1)</td>\n<td>O(n) <a href=\"#a\" id=\"id2\" rel=\"nofollow\">[1]</a></td>\n</tr>\n<tr><td>del d[key]</td>\n<td><strong>O(1)</strong></td>\n<td>O(n)</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr><td>d.keys()[i]</td>\n<td>O(n) <a href=\"#k\" id=\"id3\" rel=\"nofollow\">[2]</a></td>\n<td>O(n) <a href=\"#k\" id=\"id4\" rel=\"nofollow\">[2]</a></td>\n<td><strong>O(1)</strong></td>\n<td><strong>O(1)</strong></td>\n</tr>\n<tr><td>d.values()[i]</td>\n<td>O(n) <a href=\"#v\" id=\"id5\" rel=\"nofollow\">[3]</a></td>\n<td>O(n) <a href=\"#v\" id=\"id6\" rel=\"nofollow\">[3]</a></td>\n<td><strong>O(1)</strong></td>\n<td>O(n)</td>\n</tr>\n<tr><td>d.items()[i]</td>\n<td>O(n) <a href=\"#v\" id=\"id7\" rel=\"nofollow\">[3]</a></td>\n<td>O(n) <a href=\"#v\" id=\"id8\" rel=\"nofollow\">[3]</a></td>\n<td><strong>O(1)</strong></td>\n<td>O(n)</td>\n</tr>\n<tr><td>d.keys().index(x)</td>\n<td>O(n) <a href=\"#v\" id=\"id9\" rel=\"nofollow\">[3]</a></td>\n<td>O(n) <a href=\"#v\" id=\"id10\" rel=\"nofollow\">[3]</a></td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n</tbody>\n</table>\n<table id=\"a\">\n<col><col>\n<tbody>\n<tr><td>[1]</td><td><em>(<a href=\"#id1\" rel=\"nofollow\">1</a>, <a href=\"#id2\" rel=\"nofollow\">2</a>)</em> These are <a href=\"http://en.wikipedia.org/wiki/Amortized_analysis\" rel=\"nofollow\">amortized</a> worst case runtimes.</td></tr>\n</tbody>\n</table>\n<table id=\"k\">\n<col><col>\n<tbody>\n<tr><td>[2]</td><td><em>(<a href=\"#id3\" rel=\"nofollow\">1</a>, <a href=\"#id4\" rel=\"nofollow\">2</a>)</em> This does not work in Python 3 because <tt>colections.KeysView</tt> is not\nindexable. One of the theoretically best work arounds is\n<tt><span class=\"pre\">next(itertools.islice(d.keys(),</span> i, i + 1))</tt>.</td></tr>\n</tbody>\n</table>\n<table id=\"v\">\n<col><col>\n<tbody>\n<tr><td>[3]</td><td><em>(<a href=\"#id5\" rel=\"nofollow\">1</a>, <a href=\"#id6\" rel=\"nofollow\">2</a>, <a href=\"#id7\" rel=\"nofollow\">3</a>, <a href=\"#id8\" rel=\"nofollow\">4</a>, <a href=\"#id9\" rel=\"nofollow\">5</a>, <a href=\"#id10\" rel=\"nofollow\">6</a>)</em> Assuming the theoretically best possible workaround.</td></tr>\n</tbody>\n</table>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>This library is derived from CPython\u2019s <tt>collections.OrderedDict</tt>\nand licensed under the PSFL.\nSee the LICENSE file for the full license text.</p>\n</div>\n\n          </div>"}, "last_serial": 7050461, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "73e9de9b6ecbb3d9c5999b9662719de9", "sha256": "8d0dd20c0e9e3c24ff4583a8fb9e8da7685635e6ed80df2e3bae1ef9ff56357a"}, "downloads": -1, "filename": "indexed-1.0.0-py3-none-any.whl", "has_sig": true, "md5_digest": "73e9de9b6ecbb3d9c5999b9662719de9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5649, "upload_time": "2020-04-18T22:22:43", "upload_time_iso_8601": "2020-04-18T22:22:43.314167Z", "url": "https://files.pythonhosted.org/packages/d3/79/2128e65e1c44d6b50b3476a7a68ed83bed2f42d900b518567be6ea8d9067/indexed-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2659fcfe5b6ee6f904af19323792bca6", "sha256": "b2ebce95ec1a3d5093bc82506635585f24c80cce6218081c0d35ed8affb1f6db"}, "downloads": -1, "filename": "indexed-1.0.0.tar.gz", "has_sig": true, "md5_digest": "2659fcfe5b6ee6f904af19323792bca6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5744, "upload_time": "2020-04-18T22:22:46", "upload_time_iso_8601": "2020-04-18T22:22:46.417522Z", "url": "https://files.pythonhosted.org/packages/0d/d5/55c36023e6504d91de4f46eaddd136f3bb0da1cfa0ac07ec6b680212b189/indexed-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "73e9de9b6ecbb3d9c5999b9662719de9", "sha256": "8d0dd20c0e9e3c24ff4583a8fb9e8da7685635e6ed80df2e3bae1ef9ff56357a"}, "downloads": -1, "filename": "indexed-1.0.0-py3-none-any.whl", "has_sig": true, "md5_digest": "73e9de9b6ecbb3d9c5999b9662719de9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5649, "upload_time": "2020-04-18T22:22:43", "upload_time_iso_8601": "2020-04-18T22:22:43.314167Z", "url": "https://files.pythonhosted.org/packages/d3/79/2128e65e1c44d6b50b3476a7a68ed83bed2f42d900b518567be6ea8d9067/indexed-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2659fcfe5b6ee6f904af19323792bca6", "sha256": "b2ebce95ec1a3d5093bc82506635585f24c80cce6218081c0d35ed8affb1f6db"}, "downloads": -1, "filename": "indexed-1.0.0.tar.gz", "has_sig": true, "md5_digest": "2659fcfe5b6ee6f904af19323792bca6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5744, "upload_time": "2020-04-18T22:22:46", "upload_time_iso_8601": "2020-04-18T22:22:46.417522Z", "url": "https://files.pythonhosted.org/packages/0d/d5/55c36023e6504d91de4f46eaddd136f3bb0da1cfa0ac07ec6b680212b189/indexed-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:22 2020"}