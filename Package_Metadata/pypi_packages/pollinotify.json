{"info": {"author": "Julian Porter", "author_email": "julian@jpembedded.solutions", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "Environment :: No Input/Output (Daemon)", "Environment :: Web Environment", "Environment :: X11 Applications", "Intended Audience :: Developers", "Intended Audience :: System Administrators", "License :: OSI Approved :: Python Software Foundation License", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Topic :: System :: Filesystems", "Topic :: System :: Monitoring"], "description": "1 Summary\n=========\n\n**pollinotify** is a simple extension module that wraps the Linux **inotify** service, providing a way to watch for \nspecific kinds of file events happening to specified files or in specified directories.  Its major selling points are\nthat:\n\n  1 It is *polled*, so instead of having to set up a background thread, or attach a   separate event-watching package, the programmer calls it with an optional timeout, so it reports event that have already occurred, or waits for at most the specified time, or until an event occurs;\n  \n  2 The polling can wait for specific kinds of event.\n\nAs the module depends on the **inotify** service, **it is only available on Linux**.\n \n\n2 Module Structure\n==================\n\n2.1 Constants\n-------------\n\nA number of constants representing common Linux file system event codes, with friendly names:\n\n=============    ================  =================================================================\nConstant Name    Linux Name        Interpretation\n=============    ================  =================================================================\nAccess           IN_ACCESS         Object accessed\nModify           IN_MODIFY         Object modified\nAttributes       IN_ATTRIB         Object attributes modified\nOpen             IN_OPEN\t\t   File opened\nCloseWrite       IN_CLOSE_WRITE    File closed after contents changed\nCloseOther       IN_CLOSE_NOWRITE  File closed without contents changed\nClose            IN_CLOSE          File closed\nMoveFrom         IN_MOVED_FROM     Object moved from location\nMoveTo           IN_MOVED_TO       Object moved to location\nMove             IN_MOVE           Object moved\nMoveSelf         IN_MOVE_SELF      Object being monitored is deleted\nCreate           IN_CREATE         Object created\nDelete           IN_DELETE         Object deleted\nDeleteSelf       IN_DELETE_SELF    Object being monitored is deleted\nIgnored          IN_IGNORED        Ignored\nDirEvent         IN_ISDIR          The monitored object to which the event occurred is a directory\nAllEvents        IN_ALL_EVENTS\t   Any event\n=============    ================  =================================================================\n\n\n\n2.2 Utility functions\n---------------------\n\n*maskAsString(mask)*\n\tTakes a value equal to one or more of the event constants *or*-ed together\n\tand returns a readable string representation, consisting of a space-separated\n\tlist of the names of the matching events\n\t\n2.3 *FileEvent* class\n---------------------\n\n*FileEvent* represents an event detected by the **inotify** service.  The event information is held\nin the attributes:\n\n*self.path*\n\tThe path to the file or directory suffering the event\n*self.mask*\n\tValue representing the event(s) it suffered, represented as an *or*-ed collection of event codes, one for\n\teach kind of event that was detected\n*self.decode()*\n\tReturns a list of the names of the event types to which the event corresponds\n*self.matches(mask)*\n\tReturns **True** if the argument is the code for one of the event types that the object represents, **False** \n\totherwise\n\t\n\t\nIn addition, if *e* is a *FileEvent* object then\n\n::\n\n\tstr(e) = maskAsString(e.mask)\n\tlen(e) = len(e.decode())\n\tx in e = e.matches(x)\n\t\n\n2.4 *Watcher* class\n-------------------\n\nThe fundamental class of the module.  It connects to the system **inotify** service and uses it to \npoll for events in one or more specified file system paths.  Polling is based on a timeout,\nand so can be non-blocking.  \n\nIt has the following methods:\n     \n\n*__init__()*\t\t\t\n\tNo-args constructor\n*addPath(path,mode=AllEvents)*\n\tAdds *path* to the list of directories to be polled for events; polling \n\twill collect only events that match the *or*-ed event code mask \n\tspecified in the optional argument *mode* (defaults to all events)\n*poll(timeout=0)*\n\tPolls for events occurring on the specified paths, returning\n\t**True** if any occur, **False** otherwise; times out\n\tafter *timeout* milliseconds, in which case it returns **False**\n*events(match=AllEvents)*\t\t\n\tReturns a list of *FileEvent* objects, one for\n\teach event detected during last polling session\n\tthat matches the specified optional *or*-ed event code mask\n*nPaths()*\t\t\t\n\tReturns the number of paths currently registered with the Watcher\n*nEvents()*\t\t\t\n\tReturns the number of events detected in the last polling session\n\n\nIf *w* is a *Watcher* instance then\n\n::\n\n\tlen(w)  = w.nEvents()\n\titer(w) = iter(w.events())\n\t\n\n3 EXAMPLE\n=========\n\nA simple example that polls with a timeout of 1 second and lists those events\ncorresponding to file creation or modification (including **touch**) in the\nuser's home directory.\n\n::\n\n    import pollinotify\n\n    n=pollinotify.Watcher()\n    n.addPath('~')\n    while True:\n        got=n.poll(timeout=1000)\n        if got:\n            events=n.events(match=notify.CloseWrite)\n            print('Got{} events'.format(len(events))\n            for event in events:\n                print('{} : {} : {}'.format(event.path,event.mask,str(event)))\n                \n", "description_content_type": null, "docs_url": "https://pythonhosted.org/pollinotify/", "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://jpembedded.solutions", "keywords": "inotify", "license": "", "maintainer": "", "maintainer_email": "", "name": "pollinotify", "package_url": "https://pypi.org/project/pollinotify/", "platform": "", "project_url": "https://pypi.org/project/pollinotify/", "project_urls": {"Homepage": "http://jpembedded.solutions"}, "release_url": "https://pypi.org/project/pollinotify/1.2/", "requires_dist": null, "requires_python": "", "summary": "inotify wrapper providing polling with timeout for specified filesystem events", "version": "1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"summary\">\n<h2>1 Summary</h2>\n<p><strong>pollinotify</strong> is a simple extension module that wraps the Linux <strong>inotify</strong> service, providing a way to watch for\nspecific kinds of file events happening to specified files or in specified directories.  Its major selling points are\nthat:</p>\n<blockquote>\n<p>1 It is <em>polled</em>, so instead of having to set up a background thread, or attach a   separate event-watching package, the programmer calls it with an optional timeout, so it reports event that have already occurred, or waits for at most the specified time, or until an event occurs;</p>\n<p>2 The polling can wait for specific kinds of event.</p>\n</blockquote>\n<p>As the module depends on the <strong>inotify</strong> service, <strong>it is only available on Linux</strong>.</p>\n</div>\n<div id=\"module-structure\">\n<h2>2 Module Structure</h2>\n<div id=\"constants\">\n<h3>2.1 Constants</h3>\n<p>A number of constants representing common Linux file system event codes, with friendly names:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Constant Name</th>\n<th>Linux Name</th>\n<th>Interpretation</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>Access</td>\n<td>IN_ACCESS</td>\n<td>Object accessed</td>\n</tr>\n<tr><td>Modify</td>\n<td>IN_MODIFY</td>\n<td>Object modified</td>\n</tr>\n<tr><td>Attributes</td>\n<td>IN_ATTRIB</td>\n<td>Object attributes modified</td>\n</tr>\n<tr><td>Open</td>\n<td>IN_OPEN</td>\n<td>File opened</td>\n</tr>\n<tr><td>CloseWrite</td>\n<td>IN_CLOSE_WRITE</td>\n<td>File closed after contents changed</td>\n</tr>\n<tr><td>CloseOther</td>\n<td>IN_CLOSE_NOWRITE</td>\n<td>File closed without contents changed</td>\n</tr>\n<tr><td>Close</td>\n<td>IN_CLOSE</td>\n<td>File closed</td>\n</tr>\n<tr><td>MoveFrom</td>\n<td>IN_MOVED_FROM</td>\n<td>Object moved from location</td>\n</tr>\n<tr><td>MoveTo</td>\n<td>IN_MOVED_TO</td>\n<td>Object moved to location</td>\n</tr>\n<tr><td>Move</td>\n<td>IN_MOVE</td>\n<td>Object moved</td>\n</tr>\n<tr><td>MoveSelf</td>\n<td>IN_MOVE_SELF</td>\n<td>Object being monitored is deleted</td>\n</tr>\n<tr><td>Create</td>\n<td>IN_CREATE</td>\n<td>Object created</td>\n</tr>\n<tr><td>Delete</td>\n<td>IN_DELETE</td>\n<td>Object deleted</td>\n</tr>\n<tr><td>DeleteSelf</td>\n<td>IN_DELETE_SELF</td>\n<td>Object being monitored is deleted</td>\n</tr>\n<tr><td>Ignored</td>\n<td>IN_IGNORED</td>\n<td>Ignored</td>\n</tr>\n<tr><td>DirEvent</td>\n<td>IN_ISDIR</td>\n<td>The monitored object to which the event occurred is a directory</td>\n</tr>\n<tr><td>AllEvents</td>\n<td>IN_ALL_EVENTS</td>\n<td>Any event</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"utility-functions\">\n<h3>2.2 Utility functions</h3>\n<dl>\n<dt><em>maskAsString(mask)</em></dt>\n<dd>Takes a value equal to one or more of the event constants <em>or</em>-ed together\nand returns a readable string representation, consisting of a space-separated\nlist of the names of the matching events</dd>\n</dl>\n</div>\n<div id=\"fileevent-class\">\n<h3>2.3 <em>FileEvent</em> class</h3>\n<p><em>FileEvent</em> represents an event detected by the <strong>inotify</strong> service.  The event information is held\nin the attributes:</p>\n<dl>\n<dt><em>self.path</em></dt>\n<dd>The path to the file or directory suffering the event</dd>\n<dt><em>self.mask</em></dt>\n<dd>Value representing the event(s) it suffered, represented as an <em>or</em>-ed collection of event codes, one for\neach kind of event that was detected</dd>\n<dt><em>self.decode()</em></dt>\n<dd>Returns a list of the names of the event types to which the event corresponds</dd>\n<dt><em>self.matches(mask)</em></dt>\n<dd>Returns <strong>True</strong> if the argument is the code for one of the event types that the object represents, <strong>False</strong>\notherwise</dd>\n</dl>\n<p>In addition, if <em>e</em> is a <em>FileEvent</em> object then</p>\n<pre>str(e) = maskAsString(e.mask)\nlen(e) = len(e.decode())\nx in e = e.matches(x)\n</pre>\n</div>\n<div id=\"watcher-class\">\n<h3>2.4 <em>Watcher</em> class</h3>\n<p>The fundamental class of the module.  It connects to the system <strong>inotify</strong> service and uses it to\npoll for events in one or more specified file system paths.  Polling is based on a timeout,\nand so can be non-blocking.</p>\n<p>It has the following methods:</p>\n<dl>\n<dt><em>__init__()</em></dt>\n<dd>No-args constructor</dd>\n<dt><em>addPath(path,mode=AllEvents)</em></dt>\n<dd>Adds <em>path</em> to the list of directories to be polled for events; polling\nwill collect only events that match the <em>or</em>-ed event code mask\nspecified in the optional argument <em>mode</em> (defaults to all events)</dd>\n<dt><em>poll(timeout=0)</em></dt>\n<dd>Polls for events occurring on the specified paths, returning\n<strong>True</strong> if any occur, <strong>False</strong> otherwise; times out\nafter <em>timeout</em> milliseconds, in which case it returns <strong>False</strong></dd>\n<dt><em>events(match=AllEvents)</em></dt>\n<dd>Returns a list of <em>FileEvent</em> objects, one for\neach event detected during last polling session\nthat matches the specified optional <em>or</em>-ed event code mask</dd>\n<dt><em>nPaths()</em></dt>\n<dd>Returns the number of paths currently registered with the Watcher</dd>\n<dt><em>nEvents()</em></dt>\n<dd>Returns the number of events detected in the last polling session</dd>\n</dl>\n<p>If <em>w</em> is a <em>Watcher</em> instance then</p>\n<pre>len(w)  = w.nEvents()\niter(w) = iter(w.events())\n</pre>\n</div>\n</div>\n<div id=\"example\">\n<h2>3 EXAMPLE</h2>\n<p>A simple example that polls with a timeout of 1 second and lists those events\ncorresponding to file creation or modification (including <strong>touch</strong>) in the\nuser\u2019s home directory.</p>\n<pre>import pollinotify\n\nn=pollinotify.Watcher()\nn.addPath('~')\nwhile True:\n    got=n.poll(timeout=1000)\n    if got:\n        events=n.events(match=notify.CloseWrite)\n        print('Got{} events'.format(len(events))\n        for event in events:\n            print('{} : {} : {}'.format(event.path,event.mask,str(event)))\n</pre>\n</div>\n\n          </div>"}, "last_serial": 3441382, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "e5743ac6af921dbf290ea0316168a78b", "sha256": "e70eaeca581f4d987df96fb0f886df5ab959d50822fb538a5792ef88d7e96623"}, "downloads": -1, "filename": "pollinotify-0.1.0.tar.gz", "has_sig": false, "md5_digest": "e5743ac6af921dbf290ea0316168a78b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12269, "upload_time": "2014-08-28T23:55:36", "upload_time_iso_8601": "2014-08-28T23:55:36.125184Z", "url": "https://files.pythonhosted.org/packages/71/1f/3586b935be7708b0014517e5a43bde06b470e2157379d1126b5627fb3f25/pollinotify-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "0d2f90a99f1434ccecd8ccec3bd87642", "sha256": "ea641e134101d1e0629b570a0acaeef0b5c3cd8dd664566016dc2f59486da8ac"}, "downloads": -1, "filename": "pollinotify-0.1.1.tar.gz", "has_sig": false, "md5_digest": "0d2f90a99f1434ccecd8ccec3bd87642", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12651, "upload_time": "2014-09-04T23:36:48", "upload_time_iso_8601": "2014-09-04T23:36:48.151173Z", "url": "https://files.pythonhosted.org/packages/3d/37/805be3136a01f1920a1ce5a81e5b842cdfa0f6c951c49fa5a55d38ba4fdd/pollinotify-0.1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "bb99627efbe86efd5631ed992995f102", "sha256": "e89ee19f32e74c1c0a0c49ee2aa148e29af85c35ce4df0dcd5253d4a23295a76"}, "downloads": -1, "filename": "pollinotify-1.2.tar.gz", "has_sig": false, "md5_digest": "bb99627efbe86efd5631ed992995f102", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13875, "upload_time": "2017-12-25T05:09:30", "upload_time_iso_8601": "2017-12-25T05:09:30.141020Z", "url": "https://files.pythonhosted.org/packages/29/23/72f42f32ff3865d6e7a45a17c93964acdd80d847b90ade5276b63f4d7b69/pollinotify-1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bb99627efbe86efd5631ed992995f102", "sha256": "e89ee19f32e74c1c0a0c49ee2aa148e29af85c35ce4df0dcd5253d4a23295a76"}, "downloads": -1, "filename": "pollinotify-1.2.tar.gz", "has_sig": false, "md5_digest": "bb99627efbe86efd5631ed992995f102", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13875, "upload_time": "2017-12-25T05:09:30", "upload_time_iso_8601": "2017-12-25T05:09:30.141020Z", "url": "https://files.pythonhosted.org/packages/29/23/72f42f32ff3865d6e7a45a17c93964acdd80d847b90ade5276b63f4d7b69/pollinotify-1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:51:51 2020"}