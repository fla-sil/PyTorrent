{"info": {"author": "Jacob Flanagan", "author_email": "flanagan.jacob@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Nested Dictionary\n**Version:** 1.2.1\n\nA wrapper for python dicts that allows you to search and navigate through nested dicts using **key paths**. Also works with mixed dictionaries (mixuture of nested lists and dicts). Derived from a need to search for keys in a nested dictionary; too much time was spent on building yet another full class for nested dictionaries, but it suited our needs.\n\n*Example:*\n```python\n>>> from nesteddictionary import NestedDict     #import the NestedDict class\n>>> d = {'path':{'to':{'key':'val'}}}           #normal way of doing nested dictionary\n>>> nested_dict = NestedDict( d )               #created a nested dictionary from a normal dictionary\n```\n\n**Features**:\n- Uses keypaths in subscripting to navigate nested dictionaries ( ex: ```nested_dict[ ['path','to','key'] ]``` which is the same as ```nested_dict['path']['to']['key']``` )\n- Adds functionality without violating any existing dict operations (that I know of); keypaths are in the form of a list which cannot be used as a key for a normal dict anyway. All other dict rules still apply.\n- findall method: Finds all nested keys within a nested dictionary.\n- get and set methods: Navigate using a keypath string with seperator ( ex: ```nested_dict.get('path.to.key')``` )\n- insert method: create a full path to a nested key and set a value, even if the parent keys leading to the destination key don't already exist ( i.e., ```nested_dict.insert( ['newpath','to','key'], 'newval'``` ) will add to the existing dictionay, resulting in: ```NestedDict({ 'path':{'to':{'key':'val'}}, 'newpath':{'to':{'key':'newval'}} })``` ).\n\nLimitations:\n- While fast, it adds some overhead and therefore cannot ever be as fast as accessing dicts the regular way.\n\nChanges (PEP 440: major.minor.patch):\n- v0.1: Developed methods for searching keys in nested dictionaries.\n- v1.0: Initial working version of the nesteddictionary class.\n- v1.2: Changed dictionary traversing from recursive to functools.reduce; This is less pythonic yet faster (however, still not nearly as fast as directly accessing dicts and list). For comparison, when doing (these are not included in tests, but are easy enough to write and test on your own):\n  ```python\n  >>> d = [{1:{2:'value'}}]   \n  >>> %timeit using_reduce(d,[0,1,2])     #reduce from functools\n  >>> %timeit using_recursion(d,[0,1,2])  #what was used in v1, more pythonic\n  >>> %timeit d[0][1][2]                  #direct access; fastest\n  ```\n  Yields:\n  ```python\n  >>> 648 ns \u00b1 3.17 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)    #reduce\n  >>> 1.77 \u00b5s \u00b1 4.05 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)   #recursion\n  >>> 89.3 ns \u00b1 0.448 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each) #direct\n  ```\n\nReferences:\n- [Scalpl](https://github.com/ducdetronquito/scalpl/): A similar implementation to nested dictionaries. Some good methodology here.\n- [Functools Reduce for dicts](https://stackoverflow.com/questions/14692690/access-nested-dictionary-items-via-a-list-of-keys): Speed up dictionary acces, but non-pythonic.\n- Others I'm sure I forgot to mention. Thank you.\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jacobflanagan/nesteddictionary", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "nesteddictionary", "package_url": "https://pypi.org/project/nesteddictionary/", "platform": "", "project_url": "https://pypi.org/project/nesteddictionary/", "project_urls": {"Homepage": "https://github.com/jacobflanagan/nesteddictionary"}, "release_url": "https://pypi.org/project/nesteddictionary/1.2.1/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Wrapper for the dict class that extends the functionality for nested dicts including navigating using keypaths and nested key searching. This includes mixed dicts and lists.", "version": "1.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Nested Dictionary</h1>\n<p><strong>Version:</strong> 1.2.1</p>\n<p>A wrapper for python dicts that allows you to search and navigate through nested dicts using <strong>key paths</strong>. Also works with mixed dictionaries (mixuture of nested lists and dicts). Derived from a need to search for keys in a nested dictionary; too much time was spent on building yet another full class for nested dictionaries, but it suited our needs.</p>\n<p><em>Example:</em></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">nesteddictionary</span> <span class=\"kn\">import</span> <span class=\"n\">NestedDict</span>     <span class=\"c1\">#import the NestedDict class</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'path'</span><span class=\"p\">:{</span><span class=\"s1\">'to'</span><span class=\"p\">:{</span><span class=\"s1\">'key'</span><span class=\"p\">:</span><span class=\"s1\">'val'</span><span class=\"p\">}}}</span>           <span class=\"c1\">#normal way of doing nested dictionary</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">nested_dict</span> <span class=\"o\">=</span> <span class=\"n\">NestedDict</span><span class=\"p\">(</span> <span class=\"n\">d</span> <span class=\"p\">)</span>               <span class=\"c1\">#created a nested dictionary from a normal dictionary</span>\n</pre>\n<p><strong>Features</strong>:</p>\n<ul>\n<li>Uses keypaths in subscripting to navigate nested dictionaries ( ex: <code>nested_dict[ ['path','to','key'] ]</code> which is the same as <code>nested_dict['path']['to']['key']</code> )</li>\n<li>Adds functionality without violating any existing dict operations (that I know of); keypaths are in the form of a list which cannot be used as a key for a normal dict anyway. All other dict rules still apply.</li>\n<li>findall method: Finds all nested keys within a nested dictionary.</li>\n<li>get and set methods: Navigate using a keypath string with seperator ( ex: <code>nested_dict.get('path.to.key')</code> )</li>\n<li>insert method: create a full path to a nested key and set a value, even if the parent keys leading to the destination key don't already exist ( i.e., <code>nested_dict.insert( ['newpath','to','key'], 'newval'</code> ) will add to the existing dictionay, resulting in: <code>NestedDict({ 'path':{'to':{'key':'val'}}, 'newpath':{'to':{'key':'newval'}} })</code> ).</li>\n</ul>\n<p>Limitations:</p>\n<ul>\n<li>While fast, it adds some overhead and therefore cannot ever be as fast as accessing dicts the regular way.</li>\n</ul>\n<p>Changes (PEP 440: major.minor.patch):</p>\n<ul>\n<li>v0.1: Developed methods for searching keys in nested dictionaries.</li>\n<li>v1.0: Initial working version of the nesteddictionary class.</li>\n<li>v1.2: Changed dictionary traversing from recursive to functools.reduce; This is less pythonic yet faster (however, still not nearly as fast as directly accessing dicts and list). For comparison, when doing (these are not included in tests, but are easy enough to write and test on your own):\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">[{</span><span class=\"mi\">1</span><span class=\"p\">:{</span><span class=\"mi\">2</span><span class=\"p\">:</span><span class=\"s1\">'value'</span><span class=\"p\">}}]</span>   \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">%</span><span class=\"n\">timeit</span> <span class=\"n\">using_reduce</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">])</span>     <span class=\"c1\">#reduce from functools</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">%</span><span class=\"n\">timeit</span> <span class=\"n\">using_recursion</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">])</span>  <span class=\"c1\">#what was used in v1, more pythonic</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"o\">%</span><span class=\"n\">timeit</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">]</span>                  <span class=\"c1\">#direct access; fastest</span>\n</pre>\nYields:\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"mi\">648</span> <span class=\"n\">ns</span> <span class=\"err\">\u00b1</span> <span class=\"mf\">3.17</span> <span class=\"n\">ns</span> <span class=\"n\">per</span> <span class=\"n\">loop</span> <span class=\"p\">(</span><span class=\"n\">mean</span> <span class=\"err\">\u00b1</span> <span class=\"n\">std</span><span class=\"o\">.</span> <span class=\"n\">dev</span><span class=\"o\">.</span> <span class=\"n\">of</span> <span class=\"mi\">7</span> <span class=\"n\">runs</span><span class=\"p\">,</span> <span class=\"mi\">1000000</span> <span class=\"n\">loops</span> <span class=\"n\">each</span><span class=\"p\">)</span>    <span class=\"c1\">#reduce</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"mf\">1.77</span> <span class=\"n\">\u00b5s</span> <span class=\"err\">\u00b1</span> <span class=\"mf\">4.05</span> <span class=\"n\">ns</span> <span class=\"n\">per</span> <span class=\"n\">loop</span> <span class=\"p\">(</span><span class=\"n\">mean</span> <span class=\"err\">\u00b1</span> <span class=\"n\">std</span><span class=\"o\">.</span> <span class=\"n\">dev</span><span class=\"o\">.</span> <span class=\"n\">of</span> <span class=\"mi\">7</span> <span class=\"n\">runs</span><span class=\"p\">,</span> <span class=\"mi\">1000000</span> <span class=\"n\">loops</span> <span class=\"n\">each</span><span class=\"p\">)</span>   <span class=\"c1\">#recursion</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"mf\">89.3</span> <span class=\"n\">ns</span> <span class=\"err\">\u00b1</span> <span class=\"mf\">0.448</span> <span class=\"n\">ns</span> <span class=\"n\">per</span> <span class=\"n\">loop</span> <span class=\"p\">(</span><span class=\"n\">mean</span> <span class=\"err\">\u00b1</span> <span class=\"n\">std</span><span class=\"o\">.</span> <span class=\"n\">dev</span><span class=\"o\">.</span> <span class=\"n\">of</span> <span class=\"mi\">7</span> <span class=\"n\">runs</span><span class=\"p\">,</span> <span class=\"mi\">10000000</span> <span class=\"n\">loops</span> <span class=\"n\">each</span><span class=\"p\">)</span> <span class=\"c1\">#direct</span>\n</pre>\n</li>\n</ul>\n<p>References:</p>\n<ul>\n<li><a href=\"https://github.com/ducdetronquito/scalpl/\" rel=\"nofollow\">Scalpl</a>: A similar implementation to nested dictionaries. Some good methodology here.</li>\n<li><a href=\"https://stackoverflow.com/questions/14692690/access-nested-dictionary-items-via-a-list-of-keys\" rel=\"nofollow\">Functools Reduce for dicts</a>: Speed up dictionary acces, but non-pythonic.</li>\n<li>Others I'm sure I forgot to mention. Thank you.</li>\n</ul>\n\n          </div>"}, "last_serial": 6127290, "releases": {"1.2.0": [{"comment_text": "", "digests": {"md5": "e62ea09c5e12228ef8abfe23f54169ef", "sha256": "b3904a6c7743365c346d7b435335beca7f77009ba3eae2e418d61136ceb1bc04"}, "downloads": -1, "filename": "nesteddictionary-1.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "e62ea09c5e12228ef8abfe23f54169ef", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 7471, "upload_time": "2019-11-12T18:07:30", "upload_time_iso_8601": "2019-11-12T18:07:30.222940Z", "url": "https://files.pythonhosted.org/packages/0b/f4/627924d561d2a021e0fb146fb6d4ea9f04539d3381a88ab2c5be34facc54/nesteddictionary-1.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "198da24b5a9d11c84cf3b7f799e992a7", "sha256": "1a2d6d5ac726fb94dc6a7d1cc882c34e42c9727a4509b651fb39ecd6e7f00b07"}, "downloads": -1, "filename": "nesteddictionary-1.2.0.tar.gz", "has_sig": false, "md5_digest": "198da24b5a9d11c84cf3b7f799e992a7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6150, "upload_time": "2019-11-12T18:07:32", "upload_time_iso_8601": "2019-11-12T18:07:32.439300Z", "url": "https://files.pythonhosted.org/packages/94/c4/81077f72b27cd240a42fad42f3e1b185cc4958597d34c760f15350b456cb/nesteddictionary-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "7a4d490b5f20e47e8c32f82f337f6a9d", "sha256": "3f1f9b57bfd921198a17315169d23ea78c40e11263c3a1bc889a66348153de4d"}, "downloads": -1, "filename": "nesteddictionary-1.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "7a4d490b5f20e47e8c32f82f337f6a9d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 7529, "upload_time": "2019-11-13T00:30:06", "upload_time_iso_8601": "2019-11-13T00:30:06.482781Z", "url": "https://files.pythonhosted.org/packages/82/c1/8f298fa301a8cdd1d88aa8bd1ef2399e6b55b2057b8f809f635ac02087cc/nesteddictionary-1.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "44518c72cadf924de92ca4bec59176e1", "sha256": "8ab6f11e5f89352d4993a99937d07a9c9004ff69f452041da75baa6b379edadd"}, "downloads": -1, "filename": "nesteddictionary-1.2.1.tar.gz", "has_sig": false, "md5_digest": "44518c72cadf924de92ca4bec59176e1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6230, "upload_time": "2019-11-13T00:30:07", "upload_time_iso_8601": "2019-11-13T00:30:07.878850Z", "url": "https://files.pythonhosted.org/packages/7a/5f/85bcaa536dbbfd2e3619ab0de92e8e323e6359af612e140b2805907f6194/nesteddictionary-1.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7a4d490b5f20e47e8c32f82f337f6a9d", "sha256": "3f1f9b57bfd921198a17315169d23ea78c40e11263c3a1bc889a66348153de4d"}, "downloads": -1, "filename": "nesteddictionary-1.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "7a4d490b5f20e47e8c32f82f337f6a9d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 7529, "upload_time": "2019-11-13T00:30:06", "upload_time_iso_8601": "2019-11-13T00:30:06.482781Z", "url": "https://files.pythonhosted.org/packages/82/c1/8f298fa301a8cdd1d88aa8bd1ef2399e6b55b2057b8f809f635ac02087cc/nesteddictionary-1.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "44518c72cadf924de92ca4bec59176e1", "sha256": "8ab6f11e5f89352d4993a99937d07a9c9004ff69f452041da75baa6b379edadd"}, "downloads": -1, "filename": "nesteddictionary-1.2.1.tar.gz", "has_sig": false, "md5_digest": "44518c72cadf924de92ca4bec59176e1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6230, "upload_time": "2019-11-13T00:30:07", "upload_time_iso_8601": "2019-11-13T00:30:07.878850Z", "url": "https://files.pythonhosted.org/packages/7a/5f/85bcaa536dbbfd2e3619ab0de92e8e323e6359af612e140b2805907f6194/nesteddictionary-1.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:23 2020"}