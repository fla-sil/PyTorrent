{"info": {"author": "Fabrizio Pollastri", "author_email": "f.pollastri@inrim.it", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License (GPL)", "Operating System :: POSIX :: Linux", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: System :: Hardware"], "description": "PortIO is a Python front end to the low level functions provided by the\nC library on Linux 386 platforms for the hardware input and output ports:\noutb, outw, outl, outsb, outsw, outsl, outb_p, outw_p, outl_p, inb, inw,\ninl, insb, insw, insl, inb_p, inw_p, inl_p, ioperm, iopl.\n\nBefore doing port I/O, it is mandatory to acquire proper privileges by\ncalling ioperm or iopl. Otherwise you will get a segmentation fault.\n\noutb (data,port)\n  Output the byte data to the I/O address port.\n\noutb_p (data,port)\n  The same as outb, but waits for I/O completion.\n\noutw (data,port)\n  Output the 16 bit word data to the I/O address port.\n\noutw_p (data,port)\n  The same as outw, but waits for I/O completion.\n\noutl (data,port)\n  Output the 32 bit word data to the I/O address port.\n\noutl_p (data,port)\n  The same as outl, but waits for I/O completion.\n\noutsb (port,data,count)\n  Repeat count times the output of a byte to the I/O address port,\n  reading it from buffer of bytes starting at data and with length\n  count.\n\noutsw (port,data,count)\n  Repeat count times the output of a 16 bit word to the I/O address\n  port, reading it from buffer of 16 bit words starting at data and\n  with length count x 2.\n\noutsl (port,data,count)\n  Repeat count times the output of a 32 bit word to the I/O address\n  port, reading it from buffer of 32 bit words starting at data and\n  with length count x 4.\n\ninb (port)\n  Input a byte from the I/O address port and return it as integer.\n\ninb_p (port)\n  The same as inb, but waits for I/O completion.\n\ninw (port)\n  Input a 16 bit word from the I/O address port and return it as integer.\n\ninw_p (port)\n  The same as inw, but waits for I/O completion.\n\ninl (port)\n  Input a 32 bit word from the I/O address port and return it as integer.\n\ninl_p (port)\n  The same as inl, but waits for I/O completion.\n\ninsb (port,data,count)\n  Repeat count times the input of a byte from the I/O address port\n  and write it to a buffer of bytes starting at data and with length\n  count bytes.\n\ninsw (port,data,count)\n  Repeat count times the input of a 16 bit word from the I/O address\n  port and write it to a buffer of 16 bit words starting at data\n  and with length count x 2 bytes.\n\ninsl (port,data,count)\n  Repeat count times the input of a 32 bit word from the I/O address\n  port and write it to a buffer of 32 bit words starting at data\n  and with length count x 4 bytes.\n\nioperm (from,extent,enable)\n  Set port access permission starting from address from for extent\n  bytes. If the enable is True, access is enabled, otherwise is disabled.\n  On success, zero is returned. On error, the errno code is returned.\n  The use of ioperm requires root privileges.\n\n  Only the first 0x3ff I/O ports can be specified in this manner. To gain\n  access to any I/O port in the whole (0x0000-0xffff) address range, use\n  the iopl function. \n\niopl (level)\n  Set the I/O privilege level of the current process. When level is 3\n  access is granted to any I/O port.\n  On success, zero is returned. On error, the errno code is returned.\n  The use of iopl requires root privileges.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://portio.inrim.it", "keywords": null, "license": "http://www.gnu.org/licenses/gpl.txt", "maintainer": null, "maintainer_email": null, "name": "portio", "package_url": "https://pypi.org/project/portio/", "platform": "Linux", "project_url": "https://pypi.org/project/portio/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://portio.inrim.it"}, "release_url": "https://pypi.org/project/portio/0.5/", "requires_dist": null, "requires_python": null, "summary": "PortIO, python low level port I/O for Linux x86", "version": "0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>PortIO is a Python front end to the low level functions provided by the\nC library on Linux 386 platforms for the hardware input and output ports:\noutb, outw, outl, outsb, outsw, outsl, outb_p, outw_p, outl_p, inb, inw,\ninl, insb, insw, insl, inb_p, inw_p, inl_p, ioperm, iopl.</p>\n<p>Before doing port I/O, it is mandatory to acquire proper privileges by\ncalling ioperm or iopl. Otherwise you will get a segmentation fault.</p>\n<dl>\n<dt>outb (data,port)</dt>\n<dd>Output the byte data to the I/O address port.</dd>\n<dt>outb_p (data,port)</dt>\n<dd>The same as outb, but waits for I/O completion.</dd>\n<dt>outw (data,port)</dt>\n<dd>Output the 16 bit word data to the I/O address port.</dd>\n<dt>outw_p (data,port)</dt>\n<dd>The same as outw, but waits for I/O completion.</dd>\n<dt>outl (data,port)</dt>\n<dd>Output the 32 bit word data to the I/O address port.</dd>\n<dt>outl_p (data,port)</dt>\n<dd>The same as outl, but waits for I/O completion.</dd>\n<dt>outsb (port,data,count)</dt>\n<dd>Repeat count times the output of a byte to the I/O address port,\nreading it from buffer of bytes starting at data and with length\ncount.</dd>\n<dt>outsw (port,data,count)</dt>\n<dd>Repeat count times the output of a 16 bit word to the I/O address\nport, reading it from buffer of 16 bit words starting at data and\nwith length count x 2.</dd>\n<dt>outsl (port,data,count)</dt>\n<dd>Repeat count times the output of a 32 bit word to the I/O address\nport, reading it from buffer of 32 bit words starting at data and\nwith length count x 4.</dd>\n<dt>inb (port)</dt>\n<dd>Input a byte from the I/O address port and return it as integer.</dd>\n<dt>inb_p (port)</dt>\n<dd>The same as inb, but waits for I/O completion.</dd>\n<dt>inw (port)</dt>\n<dd>Input a 16 bit word from the I/O address port and return it as integer.</dd>\n<dt>inw_p (port)</dt>\n<dd>The same as inw, but waits for I/O completion.</dd>\n<dt>inl (port)</dt>\n<dd>Input a 32 bit word from the I/O address port and return it as integer.</dd>\n<dt>inl_p (port)</dt>\n<dd>The same as inl, but waits for I/O completion.</dd>\n<dt>insb (port,data,count)</dt>\n<dd>Repeat count times the input of a byte from the I/O address port\nand write it to a buffer of bytes starting at data and with length\ncount bytes.</dd>\n<dt>insw (port,data,count)</dt>\n<dd>Repeat count times the input of a 16 bit word from the I/O address\nport and write it to a buffer of 16 bit words starting at data\nand with length count x 2 bytes.</dd>\n<dt>insl (port,data,count)</dt>\n<dd>Repeat count times the input of a 32 bit word from the I/O address\nport and write it to a buffer of 32 bit words starting at data\nand with length count x 4 bytes.</dd>\n<dt>ioperm (from,extent,enable)</dt>\n<dd><p>Set port access permission starting from address from for extent\nbytes. If the enable is True, access is enabled, otherwise is disabled.\nOn success, zero is returned. On error, the errno code is returned.\nThe use of ioperm requires root privileges.</p>\n<p>Only the first 0x3ff I/O ports can be specified in this manner. To gain\naccess to any I/O port in the whole (0x0000-0xffff) address range, use\nthe iopl function.</p>\n</dd>\n<dt>iopl (level)</dt>\n<dd>Set the I/O privilege level of the current process. When level is 3\naccess is granted to any I/O port.\nOn success, zero is returned. On error, the errno code is returned.\nThe use of iopl requires root privileges.</dd>\n</dl>\n\n          </div>"}, "last_serial": 1107055, "releases": {"0.5": [{"comment_text": "", "digests": {"md5": "93a2db558e0bc3bc7d844688a629deab", "sha256": "af612dc9c1513fbb349b80ae29b2ea6dcb61028fe92986d67e214d119376fe44"}, "downloads": -1, "filename": "portio-0.5.tar.gz", "has_sig": false, "md5_digest": "93a2db558e0bc3bc7d844688a629deab", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 134136, "upload_time": "2014-05-28T20:45:39", "upload_time_iso_8601": "2014-05-28T20:45:39.558066Z", "url": "https://files.pythonhosted.org/packages/6f/2c/ecd9ed70555b8dc08a1b24a448b13cb77ff2c19e39df25fe9d22816d192d/portio-0.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "93a2db558e0bc3bc7d844688a629deab", "sha256": "af612dc9c1513fbb349b80ae29b2ea6dcb61028fe92986d67e214d119376fe44"}, "downloads": -1, "filename": "portio-0.5.tar.gz", "has_sig": false, "md5_digest": "93a2db558e0bc3bc7d844688a629deab", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 134136, "upload_time": "2014-05-28T20:45:39", "upload_time_iso_8601": "2014-05-28T20:45:39.558066Z", "url": "https://files.pythonhosted.org/packages/6f/2c/ecd9ed70555b8dc08a1b24a448b13cb77ff2c19e39df25fe9d22816d192d/portio-0.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:51:26 2020"}