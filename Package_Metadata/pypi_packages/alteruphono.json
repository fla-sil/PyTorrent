{"info": {"author": "Tiago Tresoldi", "author_email": "tresoldi@shh.mpg.de", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries"], "description": "# alteruphono\n\n[![Build Status](https://travis-ci.org/tresoldi/alteruphono.svg?branch=master)](https://travis-ci.org/tresoldi/alteruphono)\n[![codecov](https://codecov.io/gh/tresoldi/alteruphono/branch/master/graph/badge.svg)](https://codecov.io/gh/tresoldi/alteruphono)\n\n`alteruphono` is a Python library for applying sound changes to phonetic and\nphonological representations, intended for use in simulations of language\nevolution.\n\n*Please remember that, while usable, `alteruphono` is a work-in-progress.\nThe best documentation is currently to check the tests, and the\nlibrary is not recommended for production usage.*\n\n## Installation\n\nIn any standard Python environment, `alteruphono` can be installed with:\n\n```\npip install alteruphono\n```\n\n## How to use\n\nDetailed documentation can be found in the library source code and will\nbe published along with the paper accompanying the library; terser\ntechnical description is available at the end of this document.\nConsultation of the\n[sound changes provided for testing purposes](https://github.com/tresoldi/alteruphono/blob/master/resources/sound_changes.tsv)\nis also recommended.\n\nFor basic usage as a library, the `.forward()` and `.backward()` functions\ncan be used as a wrapper for most common circumstances. In the\nexamples below, a rule `p > t / _ V` (that is, /p/ turns into /t/ when\nfollowed by a vowel) is applied both in forward and backward direction\nto the `/pate/` sound sequence; the `.backward()` function correctly\nreturns the two possible proto-forms:\n\n```python\n>>> import alteruphono\n>>> alteruphono.forward(\"# p a t e #\", \"p > t / _ V\")\n['#', 't', 'a', 't', 'e', '#']\n>>> alteruphono.backward(\"# p a t e #\", \"p > t / _ V\")\n[['#', 'p', 'a', 't', 'e', '#'], ['#', 'p', 'a', 'p', 'e', '#']]\n```\n\nA stand-alone command-line tool can be used to call these wrapper\nfunctions:\n\n```bash\n$ alteruphono forward \"# p a t e #\" \"p > t / _ V\"\n# t a t e #\n$ alteruphono backward \"# p a t e #\" \"p > t / _ V\"\n['# p a t e #', '# p a p e #']\n```\n\n## Elements\n\nWe are not exploring every detail of the formal grammar for annotating\nsound changes, such as the flexibility with spaces and tabulations or\nequivalent symbols for the arrows; for full information, interested parties\ncan consult the reference PEG grammar and the source code.\n\nAlteruPhono operates by applying ordered lists of sound changes to\ntextual representation of sound sequences.\n\nSound changes are annotated in the `A -> B / C` syntax,\nwhose constituents are\nfor reference\nreferred as \"source\" (A), \"target\" (B), and \"context\" (C), with the\nfirst two being mandatory; the other elements are named \"arrow\" and\n\"slash\". When applied to segment sequences, we refer to the original\none as \"ante\" and to the resulting one (which might have been modified\nor not) as \"post\". So, with a rule \"p -> b / _ a\" applied to \"pape\":\n\n- `p` is the \"source\"\n- `b` is the \"target\"\n- `_ a` is the \"context\"\n- \"pape\" is the \"ante (sequence)\"\n- \"bape\" is the \"post (sequence)\"\n\nNote that, if applied backwards, a rule will have a post sequence but\npotentially more than one ante sequence. If the rule above is applied\nbackwards to the post sequence \"bape\", as explained in the backwards\ndefinition and given that we have no complementary information, the\nresult is a set of ante sequences \"pape\" and \"bape\".\n\nAlteruPhono operates on sound sequences expressed in standard\n[CLDF](https://cldf.clld.org/)/[LingPy](http://lingpy.org) notation,\nderived for Cysouw work,\ni.e., as a string character string with tokens separated by single spaces.\nAs such, a word like the English \"chance\" is represented not as\n\"`/t\u0283\u00e6ns/`\" or `/t\u0361\u0283\u00e6ns/`, in proper IPA notation, but as \"`t\u0283 \u00e6 n s`\".\nWhile the notation might at first seem strange, it has proven its\nadvantages with extensive work on linguistic databases, as it not only\nfacilitates data entry and inspection, but also makes no assumptions about\nwhat constitutes a segment, no matter how obvious the segmentation might\nlook to a linguist. On one had, being agnostic in terms of the segmentation\nallows the program to operate as a \"dumb\" machine, and on the other allows\nresearchers to operate on different kinds of segmentation if suitable for\ntheir research, including treating whole syllables as segments. In order\nto facilitate the potentially tedious and error-prone task of manual\nsegmentation, orthographic profiles can be used as in Lexibank.\n\n\n## Catalogs\n\nWhile they are not enforced and in some cases are not needed, such as\nwhen the system operates as a glorified search&replace, alteruphono is\ndesigned to operate with three main catalogs: graphemes, features, and\nsegment classes.\n\nGraphemes are sequences of one or more textual characters where most\ncharacters are accepts (exceptions are...).\nWhile in most cases it will correspond\nto common transcription system such as the IPA, and in most case correspond\nto a single sound or phoneme, this is not enforced and sequence of\ncharacters (with the exception of a white-space, a tabulation, a forward\nslash, square and curly brackets, and an arrow) can be used to represent\nanything defined as\na segment in a corresponding catalog. Also note that the slash notation\nof Lexibank is supported. The default catalog distributed with alteruphono\nis based on the BIPA system of clts.\n\nFeatures are descriptors... Default is derived from BIPA descriptors,\nmostly articulatory, but we also incluse some distinctive feature\nsystems.\n\nIt is not necessary for a grapheme catalog to specify the features that\ncompose each grapheme, but this severly limits the kind of operations\npossible, particularly when modelling observed or plausible sound\nchanges.\n\nThe default catalogs are derived from BIPA... such as in examle\n\nSegment classes are just shorthards. The default distributed with AlteruPhono\nincludes a number of shorthands common in the literature and mostly\nunambiguous\n\n## Types\n\n- A **grapheme** is a sequence of one or more textual characters representing\na segment, such as \"`a`\", \"`k\u02b7\u02b0`\".\n\n- A **bundle** is an explicit listing of features and values, as defined\nin a reference, enclosed in square brackets, such as\n\"`[open,front,vowel]`\" or \"`[-vowel]`\". Features are separated by commas,\nwith optional spaces, and may carry a specific value in the format\n`feature=value` with `value` being either a logical boolean (\"true\" or\n\"false\") or a numeric value; shorthands for \"true\" and \"false\" are\ndefined as the operators \"+\" and \"-\"; if no \"value\" is provided, it defaults\nto \"true\" (so that `[open,front,vowel]` is internally translated to\n`[open=true,front=true,vowel=true]`). Note on back-references here\n(experimental)\n\n- A **modifier** is a bundle of feautes used to modify a basic value;\nfor example, if \"V\" defines a segment class (see item below) of vowels,\n\"V[long]\" would restrict the set of matched segments to long vowels.\n\n- A **segment-class** is a short-hand to a bundle of features, as defined\nin a reference, intended to match one or more segments are expressed with\none or more upper-case characters, such as \"C\" or\n\"VL\" (for [consonant] and [long,vowel], respectively, in the\ndefault). A segment class can have a modifier.\n\n- A **marker** is a single character non-segmental information. Defined\nmarkers are # for word-boundary, . for syllable break, + for morpheme\nboundary, stress marks and tone marks. Note that some markers,\nparticularly suprasegmental features as stress and tone, in most cases\nwill not be referred directly when writing rule, but by tiers. See\nsection on tiers.\n\n- A **focus** is a special marker, represented by underscore, and used in\ncontext to indicate the position of the source and target. See reference\nwhen discuss contexts.\n\n- An **alternative** is a list of one or more segments (which tzype?)\nseparated by a vertical bar, such \"b|p\". While in almost all cases of\nactual usage alternatives could be expressed by bundles (such\n\"b|p\" as \"[plosive,bilabial]\" in most inventories, using an alternative is\nin most cases preferable for legibility\n\n- A **set** is a list of alternative segments where the order is\nsignificant, expressed between curly brackets and separated by commas,\nsuch as `{a,e}`. The order is significant in the sense that, in the\ncase of a corresponding set, elements will be matched by their index:\nif `{a,e}` is matched with `{\u025b,i}`, all /a/ will become /\u025b/ and all\n/e/ will become /i/ (note how, with standard IPA descriptors, it would\nnot be possible to express such raising in a an unambiguos way)\n\n- A **back-reference** is a reference to a previously matched segment,\nexpressed by the symbol @ and the numeric index for the segment,\n(such as @2 for referring to the second element,\nthe vowel /a/, in the segment sequence \"b a\"). As such, back-references\nallow to carry identities: if \"V s V\" means any intervocalic \"s\" and\n\"a s a\" means only \"s\" between \"a\", \"V s @1\" means any \"s\" in\nintervocalic position where the two vowels are equal. Back-references\ncan take modifier.\n\n\n\n## TODO\n\nFor version 2.0:\n    - Implement mapper support in the automata (also with test cases)\n    - Implement parentheses support in the grammar and automata (also with\n      test cases)\n    - Consider moving to ANTLR\n    - For the grammar, consider removing direct sound match in `segment`,\n      only using `alternative` (potentially renamed to `expression` and dealt\n      with in an appropriate way)\n    - don't collect a `context`, but `left` and `right` already in the\n      AST (i.e., remove the `position` symbol)\n\n    - In Graphviz output\n        - Accept a strng with a description (could be the output of the\n          NLAutomata)\n        - Draw borders around `source`, `target`, and `context`\n        - Add indices to sequences, at least optionally\n        - Accept definitions of sound classes and IPA, at least in English\n\nOld version\n\n  - Use `logging` everywhere\n  - Implement automatic, semi-automatic, and requested syllabification\n    based on prosody strength\n  - Implement both PEG grammars from separate repository\n  - Add support for custom replacement functions (deciding on notation)\n\n## Manual\n\nThere are two basic elements: rules and sequences. A rule operates on\na sequence, resulting in a single, potentially different, sequence in\nforwards direction, and in at least one, potentially different, sequence\nin backwards direction.\n\nFollowing the conventions and practices of CLTS, CLDF, Lingpy,\nand orthographic profiles, the\nproposed notation operates on \"strings\", that is, text in Unicode\ncharacters representing a sequence of one or more segments separated\nby spaces. The most common segments are sounds as represented by Unicode\nglyphs, so that a transcription like /ha\u028as/ (\"house\" in English Received\nPronounciation) is represented as `\"h a \u028a s\"`, that is, not considering\nspaces, U+0068 (LATIN SMALL LETTER H),\nU+0061 (LATIN SMALL LETTER A),\nU+028A (LATIN SMALL LETTER UPSILON), and U+0073\n(LATIN SMALL LETTER S). The usage of spaces might seem inconventient and\neven odds at first, but the convention has proven useful with years of\nexperience of phonological transcription for computer-assisted treatment, as\nnot only it makes no automatic assumption of what constitutes a segment\n(for example, allowing user to work with fully atomic syllables), but\nfacilitates validation work.\n\nA `rule` is a statement expressed in the `A > B / C _ D` notation, where\nC and D, both optional, express the preceding and following context.\nIt is a shorthand to common notation, internally mapped to\n`C A D > B A D`. While A and B might expresses something different from\nhistorical evolution, such as correspondence, they are respectively named\n`ante` and `post`, and the rule can be real as \"the sequence of segments\nA changes into the sequence of sounds B when preceded by C and followed by\nD\".\nA, B, and C are referred as as \"sequences\", and are composed of one or\nmore \"segments\". A \"segment\" is the basic, fundamental, atomic unit of a\nsequence.\n\nSegments can be of X types:\n\n  - sound segments, such as phonemes (like `a` or `\u0292`) or whatever is\n    defined as an atomic segment by the used (for example, full-length\n    syllables such as `ba` or `\u0288\u0361\u0282\u02b0jou\u032f\u02e8\u02e9\u02e6`). In most cases, a phonetic or\n    phonological transcription system such IPA or NAPA will be used; by\n    default, the system operates on BIPA, which also facilitates\n    normalization in terms of homoglyphs, etc.\n  - A bundle of features, expressed as comma separated feature-values\n    enclosed by square brackets, such as `[consonant]`, referring to all\n    consonants, `[unrounded,open-mid,central,vowel]`, referring to all\n    sounds matching this bundle of features (that is, `\u025c` and the same\n    sound with modifiers), etc. Complex relationships and tiers allow to\n    expressed between segments, as described later. By default, the system\n    of descriptors used by BIPA is used.\n  - Sound-classes, which are common short-hands for bundles of features,\n    such as `K` for `[consonant,velar]` or `R` for \"resonants\" (defined\n    internally as `[consonant,-stop]`). A default system, expressed in\n    table X, is provided, and can be replaced, modified, or extended by the\n    user. Sound-classes are expressed in all upper-case.\n  - Back-references, used to refer to other segments in a sequence,\n    which are expressed by the at-symbol (`@`) and a\n    numeric index, such as `@1` or `@3` (1-based). These will are better\n    explored in X.\n  - Special segments related to sequences, which are\n    - `_` (underscore) for the \"focus\" in a context (from the name by\n      Hartman 2003), that is, the position where `ante` and `post` sequences\n      are found\n    - `#` (hash) for word boundaries\n    - `.` (dot) for syllable breaks\n\nSound segments, sound-classes, and back-references can carry a modifier,\nwhich is following bundle of features the modifies the value expressed or\nreferred to. For example `\u03b8[voiced]` is equivalent to `\u00f0`, `C[voiceless]`\nwould match only voiceless consonants, `C[voiceless] \u0259 @1[voiced]` would\nmatch sequences of voiceless consonants, followed by a schwa, followed by\nthe corresponding voiced consonant (thus matching sequences like `p \u0259 b`\nand `k \u0259 g`, but not `p \u0259 g`).\n\nOther non primitives include alternatives and sets.\n\n## How to cite\n\nIf you use `alteruphono`, please cite it as:\n\n> Tresoldi, Tiago (2020). Alteruphono, a tool for simulating sound changes.\nVersion 0.3. Jena. Available at: https://github.com/tresoldi/alteruphono\n\nIn BibTex:\n\n```\n@misc{Tresoldi202alteruphono,\n  author = {Tresoldi, Tiago},\n  title = {Alteruphono, a tool for simulating sound changes. Version 0.3.},\n  howpublished = {\\url{https://github.com/tresoldi/alteruphono}},\n  address = {Jena},\n  year = {2020},\n}\n```\n\n## Author\n\nTiago Tresoldi (tresoldi@shh.mpg.de)\n\nThe author was supported during development by the\n[ERC Grant #715618](https://cordis.europa.eu/project/rcn/206320/factsheet/en)\nfor the project [CALC](http://calc.digling.org)\n(Computer-Assisted Language Comparison: Reconciling Computational and Classical\nApproaches in Historical Linguistics), led by\n[Johann-Mattis List](http://www.lingulist.de).\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tresoldi/alteruphono", "keywords": "sound change,phonology,phonetics,Lautwandel", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "alteruphono", "package_url": "https://pypi.org/project/alteruphono/", "platform": "", "project_url": "https://pypi.org/project/alteruphono/", "project_urls": {"Homepage": "https://github.com/tresoldi/alteruphono"}, "release_url": "https://pypi.org/project/alteruphono/0.3/", "requires_dist": null, "requires_python": "", "summary": "Library for dealing with sound changes", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>alteruphono</h1>\n<p><a href=\"https://travis-ci.org/tresoldi/alteruphono\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e108fe5d3c144f5d0aaa7d3a4cdb7b9e477f7481/68747470733a2f2f7472617669732d63692e6f72672f747265736f6c64692f616c7465727570686f6e6f2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/tresoldi/alteruphono\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/44821c5f218102ba219616b0a18bce4795e0002f/68747470733a2f2f636f6465636f762e696f2f67682f747265736f6c64692f616c7465727570686f6e6f2f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<p><code>alteruphono</code> is a Python library for applying sound changes to phonetic and\nphonological representations, intended for use in simulations of language\nevolution.</p>\n<p><em>Please remember that, while usable, <code>alteruphono</code> is a work-in-progress.\nThe best documentation is currently to check the tests, and the\nlibrary is not recommended for production usage.</em></p>\n<h2>Installation</h2>\n<p>In any standard Python environment, <code>alteruphono</code> can be installed with:</p>\n<pre><code>pip install alteruphono\n</code></pre>\n<h2>How to use</h2>\n<p>Detailed documentation can be found in the library source code and will\nbe published along with the paper accompanying the library; terser\ntechnical description is available at the end of this document.\nConsultation of the\n<a href=\"https://github.com/tresoldi/alteruphono/blob/master/resources/sound_changes.tsv\" rel=\"nofollow\">sound changes provided for testing purposes</a>\nis also recommended.</p>\n<p>For basic usage as a library, the <code>.forward()</code> and <code>.backward()</code> functions\ncan be used as a wrapper for most common circumstances. In the\nexamples below, a rule <code>p &gt; t / _ V</code> (that is, /p/ turns into /t/ when\nfollowed by a vowel) is applied both in forward and backward direction\nto the <code>/pate/</code> sound sequence; the <code>.backward()</code> function correctly\nreturns the two possible proto-forms:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">alteruphono</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">alteruphono</span><span class=\"o\">.</span><span class=\"n\">forward</span><span class=\"p\">(</span><span class=\"s2\">\"# p a t e #\"</span><span class=\"p\">,</span> <span class=\"s2\">\"p &gt; t / _ V\"</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"s1\">'#'</span><span class=\"p\">,</span> <span class=\"s1\">'t'</span><span class=\"p\">,</span> <span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'t'</span><span class=\"p\">,</span> <span class=\"s1\">'e'</span><span class=\"p\">,</span> <span class=\"s1\">'#'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">alteruphono</span><span class=\"o\">.</span><span class=\"n\">backward</span><span class=\"p\">(</span><span class=\"s2\">\"# p a t e #\"</span><span class=\"p\">,</span> <span class=\"s2\">\"p &gt; t / _ V\"</span><span class=\"p\">)</span>\n<span class=\"p\">[[</span><span class=\"s1\">'#'</span><span class=\"p\">,</span> <span class=\"s1\">'p'</span><span class=\"p\">,</span> <span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'t'</span><span class=\"p\">,</span> <span class=\"s1\">'e'</span><span class=\"p\">,</span> <span class=\"s1\">'#'</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s1\">'#'</span><span class=\"p\">,</span> <span class=\"s1\">'p'</span><span class=\"p\">,</span> <span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'p'</span><span class=\"p\">,</span> <span class=\"s1\">'e'</span><span class=\"p\">,</span> <span class=\"s1\">'#'</span><span class=\"p\">]]</span>\n</pre>\n<p>A stand-alone command-line tool can be used to call these wrapper\nfunctions:</p>\n<pre>$ alteruphono forward <span class=\"s2\">\"# p a t e #\"</span> <span class=\"s2\">\"p &gt; t / _ V\"</span>\n<span class=\"c1\"># t a t e #</span>\n$ alteruphono backward <span class=\"s2\">\"# p a t e #\"</span> <span class=\"s2\">\"p &gt; t / _ V\"</span>\n<span class=\"o\">[</span><span class=\"s1\">'# p a t e #'</span>, <span class=\"s1\">'# p a p e #'</span><span class=\"o\">]</span>\n</pre>\n<h2>Elements</h2>\n<p>We are not exploring every detail of the formal grammar for annotating\nsound changes, such as the flexibility with spaces and tabulations or\nequivalent symbols for the arrows; for full information, interested parties\ncan consult the reference PEG grammar and the source code.</p>\n<p>AlteruPhono operates by applying ordered lists of sound changes to\ntextual representation of sound sequences.</p>\n<p>Sound changes are annotated in the <code>A -&gt; B / C</code> syntax,\nwhose constituents are\nfor reference\nreferred as \"source\" (A), \"target\" (B), and \"context\" (C), with the\nfirst two being mandatory; the other elements are named \"arrow\" and\n\"slash\". When applied to segment sequences, we refer to the original\none as \"ante\" and to the resulting one (which might have been modified\nor not) as \"post\". So, with a rule \"p -&gt; b / _ a\" applied to \"pape\":</p>\n<ul>\n<li><code>p</code> is the \"source\"</li>\n<li><code>b</code> is the \"target\"</li>\n<li><code>_ a</code> is the \"context\"</li>\n<li>\"pape\" is the \"ante (sequence)\"</li>\n<li>\"bape\" is the \"post (sequence)\"</li>\n</ul>\n<p>Note that, if applied backwards, a rule will have a post sequence but\npotentially more than one ante sequence. If the rule above is applied\nbackwards to the post sequence \"bape\", as explained in the backwards\ndefinition and given that we have no complementary information, the\nresult is a set of ante sequences \"pape\" and \"bape\".</p>\n<p>AlteruPhono operates on sound sequences expressed in standard\n<a href=\"https://cldf.clld.org/\" rel=\"nofollow\">CLDF</a>/<a href=\"http://lingpy.org\" rel=\"nofollow\">LingPy</a> notation,\nderived for Cysouw work,\ni.e., as a string character string with tokens separated by single spaces.\nAs such, a word like the English \"chance\" is represented not as\n\"<code>/t\u0283\u00e6ns/</code>\" or <code>/t\u0361\u0283\u00e6ns/</code>, in proper IPA notation, but as \"<code>t\u0283 \u00e6 n s</code>\".\nWhile the notation might at first seem strange, it has proven its\nadvantages with extensive work on linguistic databases, as it not only\nfacilitates data entry and inspection, but also makes no assumptions about\nwhat constitutes a segment, no matter how obvious the segmentation might\nlook to a linguist. On one had, being agnostic in terms of the segmentation\nallows the program to operate as a \"dumb\" machine, and on the other allows\nresearchers to operate on different kinds of segmentation if suitable for\ntheir research, including treating whole syllables as segments. In order\nto facilitate the potentially tedious and error-prone task of manual\nsegmentation, orthographic profiles can be used as in Lexibank.</p>\n<h2>Catalogs</h2>\n<p>While they are not enforced and in some cases are not needed, such as\nwhen the system operates as a glorified search&amp;replace, alteruphono is\ndesigned to operate with three main catalogs: graphemes, features, and\nsegment classes.</p>\n<p>Graphemes are sequences of one or more textual characters where most\ncharacters are accepts (exceptions are...).\nWhile in most cases it will correspond\nto common transcription system such as the IPA, and in most case correspond\nto a single sound or phoneme, this is not enforced and sequence of\ncharacters (with the exception of a white-space, a tabulation, a forward\nslash, square and curly brackets, and an arrow) can be used to represent\nanything defined as\na segment in a corresponding catalog. Also note that the slash notation\nof Lexibank is supported. The default catalog distributed with alteruphono\nis based on the BIPA system of clts.</p>\n<p>Features are descriptors... Default is derived from BIPA descriptors,\nmostly articulatory, but we also incluse some distinctive feature\nsystems.</p>\n<p>It is not necessary for a grapheme catalog to specify the features that\ncompose each grapheme, but this severly limits the kind of operations\npossible, particularly when modelling observed or plausible sound\nchanges.</p>\n<p>The default catalogs are derived from BIPA... such as in examle</p>\n<p>Segment classes are just shorthards. The default distributed with AlteruPhono\nincludes a number of shorthands common in the literature and mostly\nunambiguous</p>\n<h2>Types</h2>\n<ul>\n<li>\n<p>A <strong>grapheme</strong> is a sequence of one or more textual characters representing\na segment, such as \"<code>a</code>\", \"<code>k\u02b7\u02b0</code>\".</p>\n</li>\n<li>\n<p>A <strong>bundle</strong> is an explicit listing of features and values, as defined\nin a reference, enclosed in square brackets, such as\n\"<code>[open,front,vowel]</code>\" or \"<code>[-vowel]</code>\". Features are separated by commas,\nwith optional spaces, and may carry a specific value in the format\n<code>feature=value</code> with <code>value</code> being either a logical boolean (\"true\" or\n\"false\") or a numeric value; shorthands for \"true\" and \"false\" are\ndefined as the operators \"+\" and \"-\"; if no \"value\" is provided, it defaults\nto \"true\" (so that <code>[open,front,vowel]</code> is internally translated to\n<code>[open=true,front=true,vowel=true]</code>). Note on back-references here\n(experimental)</p>\n</li>\n<li>\n<p>A <strong>modifier</strong> is a bundle of feautes used to modify a basic value;\nfor example, if \"V\" defines a segment class (see item below) of vowels,\n\"V[long]\" would restrict the set of matched segments to long vowels.</p>\n</li>\n<li>\n<p>A <strong>segment-class</strong> is a short-hand to a bundle of features, as defined\nin a reference, intended to match one or more segments are expressed with\none or more upper-case characters, such as \"C\" or\n\"VL\" (for [consonant] and [long,vowel], respectively, in the\ndefault). A segment class can have a modifier.</p>\n</li>\n<li>\n<p>A <strong>marker</strong> is a single character non-segmental information. Defined\nmarkers are # for word-boundary, . for syllable break, + for morpheme\nboundary, stress marks and tone marks. Note that some markers,\nparticularly suprasegmental features as stress and tone, in most cases\nwill not be referred directly when writing rule, but by tiers. See\nsection on tiers.</p>\n</li>\n<li>\n<p>A <strong>focus</strong> is a special marker, represented by underscore, and used in\ncontext to indicate the position of the source and target. See reference\nwhen discuss contexts.</p>\n</li>\n<li>\n<p>An <strong>alternative</strong> is a list of one or more segments (which tzype?)\nseparated by a vertical bar, such \"b|p\". While in almost all cases of\nactual usage alternatives could be expressed by bundles (such\n\"b|p\" as \"[plosive,bilabial]\" in most inventories, using an alternative is\nin most cases preferable for legibility</p>\n</li>\n<li>\n<p>A <strong>set</strong> is a list of alternative segments where the order is\nsignificant, expressed between curly brackets and separated by commas,\nsuch as <code>{a,e}</code>. The order is significant in the sense that, in the\ncase of a corresponding set, elements will be matched by their index:\nif <code>{a,e}</code> is matched with <code>{\u025b,i}</code>, all /a/ will become /\u025b/ and all\n/e/ will become /i/ (note how, with standard IPA descriptors, it would\nnot be possible to express such raising in a an unambiguos way)</p>\n</li>\n<li>\n<p>A <strong>back-reference</strong> is a reference to a previously matched segment,\nexpressed by the symbol @ and the numeric index for the segment,\n(such as @2 for referring to the second element,\nthe vowel /a/, in the segment sequence \"b a\"). As such, back-references\nallow to carry identities: if \"V s V\" means any intervocalic \"s\" and\n\"a s a\" means only \"s\" between \"a\", \"V s @1\" means any \"s\" in\nintervocalic position where the two vowels are equal. Back-references\ncan take modifier.</p>\n</li>\n</ul>\n<h2>TODO</h2>\n<p>For version 2.0:\n- Implement mapper support in the automata (also with test cases)\n- Implement parentheses support in the grammar and automata (also with\ntest cases)\n- Consider moving to ANTLR\n- For the grammar, consider removing direct sound match in <code>segment</code>,\nonly using <code>alternative</code> (potentially renamed to <code>expression</code> and dealt\nwith in an appropriate way)\n- don't collect a <code>context</code>, but <code>left</code> and <code>right</code> already in the\nAST (i.e., remove the <code>position</code> symbol)</p>\n<pre><code>- In Graphviz output\n    - Accept a strng with a description (could be the output of the\n      NLAutomata)\n    - Draw borders around `source`, `target`, and `context`\n    - Add indices to sequences, at least optionally\n    - Accept definitions of sound classes and IPA, at least in English\n</code></pre>\n<p>Old version</p>\n<ul>\n<li>Use <code>logging</code> everywhere</li>\n<li>Implement automatic, semi-automatic, and requested syllabification\nbased on prosody strength</li>\n<li>Implement both PEG grammars from separate repository</li>\n<li>Add support for custom replacement functions (deciding on notation)</li>\n</ul>\n<h2>Manual</h2>\n<p>There are two basic elements: rules and sequences. A rule operates on\na sequence, resulting in a single, potentially different, sequence in\nforwards direction, and in at least one, potentially different, sequence\nin backwards direction.</p>\n<p>Following the conventions and practices of CLTS, CLDF, Lingpy,\nand orthographic profiles, the\nproposed notation operates on \"strings\", that is, text in Unicode\ncharacters representing a sequence of one or more segments separated\nby spaces. The most common segments are sounds as represented by Unicode\nglyphs, so that a transcription like /ha\u028as/ (\"house\" in English Received\nPronounciation) is represented as <code>\"h a \u028a s\"</code>, that is, not considering\nspaces, U+0068 (LATIN SMALL LETTER H),\nU+0061 (LATIN SMALL LETTER A),\nU+028A (LATIN SMALL LETTER UPSILON), and U+0073\n(LATIN SMALL LETTER S). The usage of spaces might seem inconventient and\neven odds at first, but the convention has proven useful with years of\nexperience of phonological transcription for computer-assisted treatment, as\nnot only it makes no automatic assumption of what constitutes a segment\n(for example, allowing user to work with fully atomic syllables), but\nfacilitates validation work.</p>\n<p>A <code>rule</code> is a statement expressed in the <code>A &gt; B / C _ D</code> notation, where\nC and D, both optional, express the preceding and following context.\nIt is a shorthand to common notation, internally mapped to\n<code>C A D &gt; B A D</code>. While A and B might expresses something different from\nhistorical evolution, such as correspondence, they are respectively named\n<code>ante</code> and <code>post</code>, and the rule can be real as \"the sequence of segments\nA changes into the sequence of sounds B when preceded by C and followed by\nD\".\nA, B, and C are referred as as \"sequences\", and are composed of one or\nmore \"segments\". A \"segment\" is the basic, fundamental, atomic unit of a\nsequence.</p>\n<p>Segments can be of X types:</p>\n<ul>\n<li>sound segments, such as phonemes (like <code>a</code> or <code>\u0292</code>) or whatever is\ndefined as an atomic segment by the used (for example, full-length\nsyllables such as <code>ba</code> or <code>\u0288\u0361\u0282\u02b0jou\u032f\u02e8\u02e9\u02e6</code>). In most cases, a phonetic or\nphonological transcription system such IPA or NAPA will be used; by\ndefault, the system operates on BIPA, which also facilitates\nnormalization in terms of homoglyphs, etc.</li>\n<li>A bundle of features, expressed as comma separated feature-values\nenclosed by square brackets, such as <code>[consonant]</code>, referring to all\nconsonants, <code>[unrounded,open-mid,central,vowel]</code>, referring to all\nsounds matching this bundle of features (that is, <code>\u025c</code> and the same\nsound with modifiers), etc. Complex relationships and tiers allow to\nexpressed between segments, as described later. By default, the system\nof descriptors used by BIPA is used.</li>\n<li>Sound-classes, which are common short-hands for bundles of features,\nsuch as <code>K</code> for <code>[consonant,velar]</code> or <code>R</code> for \"resonants\" (defined\ninternally as <code>[consonant,-stop]</code>). A default system, expressed in\ntable X, is provided, and can be replaced, modified, or extended by the\nuser. Sound-classes are expressed in all upper-case.</li>\n<li>Back-references, used to refer to other segments in a sequence,\nwhich are expressed by the at-symbol (<code>@</code>) and a\nnumeric index, such as <code>@1</code> or <code>@3</code> (1-based). These will are better\nexplored in X.</li>\n<li>Special segments related to sequences, which are\n<ul>\n<li><code>_</code> (underscore) for the \"focus\" in a context (from the name by\nHartman 2003), that is, the position where <code>ante</code> and <code>post</code> sequences\nare found</li>\n<li><code>#</code> (hash) for word boundaries</li>\n<li><code>.</code> (dot) for syllable breaks</li>\n</ul>\n</li>\n</ul>\n<p>Sound segments, sound-classes, and back-references can carry a modifier,\nwhich is following bundle of features the modifies the value expressed or\nreferred to. For example <code>\u03b8[voiced]</code> is equivalent to <code>\u00f0</code>, <code>C[voiceless]</code>\nwould match only voiceless consonants, <code>C[voiceless] \u0259 @1[voiced]</code> would\nmatch sequences of voiceless consonants, followed by a schwa, followed by\nthe corresponding voiced consonant (thus matching sequences like <code>p \u0259 b</code>\nand <code>k \u0259 g</code>, but not <code>p \u0259 g</code>).</p>\n<p>Other non primitives include alternatives and sets.</p>\n<h2>How to cite</h2>\n<p>If you use <code>alteruphono</code>, please cite it as:</p>\n<blockquote>\n<p>Tresoldi, Tiago (2020). Alteruphono, a tool for simulating sound changes.\nVersion 0.3. Jena. Available at: <a href=\"https://github.com/tresoldi/alteruphono\" rel=\"nofollow\">https://github.com/tresoldi/alteruphono</a></p>\n</blockquote>\n<p>In BibTex:</p>\n<pre><code>@misc{Tresoldi202alteruphono,\n  author = {Tresoldi, Tiago},\n  title = {Alteruphono, a tool for simulating sound changes. Version 0.3.},\n  howpublished = {\\url{https://github.com/tresoldi/alteruphono}},\n  address = {Jena},\n  year = {2020},\n}\n</code></pre>\n<h2>Author</h2>\n<p>Tiago Tresoldi (<a href=\"mailto:tresoldi@shh.mpg.de\">tresoldi@shh.mpg.de</a>)</p>\n<p>The author was supported during development by the\n<a href=\"https://cordis.europa.eu/project/rcn/206320/factsheet/en\" rel=\"nofollow\">ERC Grant #715618</a>\nfor the project <a href=\"http://calc.digling.org\" rel=\"nofollow\">CALC</a>\n(Computer-Assisted Language Comparison: Reconciling Computational and Classical\nApproaches in Historical Linguistics), led by\n<a href=\"http://www.lingulist.de\" rel=\"nofollow\">Johann-Mattis List</a>.</p>\n\n          </div>"}, "last_serial": 7165476, "releases": {"0.0.1.dev0": [{"comment_text": "", "digests": {"md5": "22180eafd927c9946231c9c94ca7f3e2", "sha256": "5a294fe42781f3f31b5c7a0ee2e0a2b14ffee498fd6f7c53db1521b8395cfedb"}, "downloads": -1, "filename": "alteruphono-0.0.1.dev0-py3-none-any.whl", "has_sig": false, "md5_digest": "22180eafd927c9946231c9c94ca7f3e2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22545, "upload_time": "2019-10-16T11:48:25", "upload_time_iso_8601": "2019-10-16T11:48:25.070796Z", "url": "https://files.pythonhosted.org/packages/41/a4/9b5a3e8fb4369f720b0ab9035df36fa53740344ac7b91d837586370b6d7a/alteruphono-0.0.1.dev0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "015a05d371bc44fe587170ba81192ebc", "sha256": "a003fa9bf18f5e7fc3891148d716e5cc741d033ac1168d46d33c3d6da389acf4"}, "downloads": -1, "filename": "alteruphono-0.0.1.dev0.tar.gz", "has_sig": false, "md5_digest": "015a05d371bc44fe587170ba81192ebc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22163, "upload_time": "2019-10-16T11:48:28", "upload_time_iso_8601": "2019-10-16T11:48:28.314883Z", "url": "https://files.pythonhosted.org/packages/99/c5/0750db614a9924ecd132f7ae070aef76bc768eb5b8ced77c7d4026c0375b/alteruphono-0.0.1.dev0.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "9050097384628643a526259db7084fd8", "sha256": "3a9e723050e2a30b7e86f07c5dbff7a243b273cc643768ab14de851e57466c35"}, "downloads": -1, "filename": "alteruphono-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "9050097384628643a526259db7084fd8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 110238, "upload_time": "2020-05-02T12:44:16", "upload_time_iso_8601": "2020-05-02T12:44:16.075604Z", "url": "https://files.pythonhosted.org/packages/6f/d2/3f5d775436401ba06e0eb184f1633367e0ee43e44b886debbce5ee163449/alteruphono-0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "68fc2f3fa0da089214019b8f9a48c5c4", "sha256": "72b4e89625ff17191af5d19fb4f00b2cf0b7f75f688ff48a4a0ed98f34df47a9"}, "downloads": -1, "filename": "alteruphono-0.2.tar.gz", "has_sig": false, "md5_digest": "68fc2f3fa0da089214019b8f9a48c5c4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 116387, "upload_time": "2020-05-02T12:44:17", "upload_time_iso_8601": "2020-05-02T12:44:17.816115Z", "url": "https://files.pythonhosted.org/packages/b3/f0/d8d527af574cafe269e9a604b1c59007f2294c9a8e5ff97ee7833b3b7936/alteruphono-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "d1501b4136a54c5a98a989ee32c80e6a", "sha256": "ada896ce784712da92023b80f54ec485c91333ca533f06491868a0ae079bf535"}, "downloads": -1, "filename": "alteruphono-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "d1501b4136a54c5a98a989ee32c80e6a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 161346, "upload_time": "2020-05-04T16:03:42", "upload_time_iso_8601": "2020-05-04T16:03:42.417145Z", "url": "https://files.pythonhosted.org/packages/d7/b5/b35bcc6ade0e31de84fbf6dc6274a904c6b7c9a41cefd71f2f156c82e521/alteruphono-0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d361f928f868faabf2d2ecd7fec75b47", "sha256": "828aedfff2705273f9c1413aad0358df959ff0759711661cdaaa3942f2875654"}, "downloads": -1, "filename": "alteruphono-0.3.tar.gz", "has_sig": false, "md5_digest": "d361f928f868faabf2d2ecd7fec75b47", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 118136, "upload_time": "2020-05-04T16:03:45", "upload_time_iso_8601": "2020-05-04T16:03:45.442427Z", "url": "https://files.pythonhosted.org/packages/d9/d0/c02a31e765b7b2ebfe9519a680997a925eca7edf600b66c417c6f3edc643/alteruphono-0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d1501b4136a54c5a98a989ee32c80e6a", "sha256": "ada896ce784712da92023b80f54ec485c91333ca533f06491868a0ae079bf535"}, "downloads": -1, "filename": "alteruphono-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "d1501b4136a54c5a98a989ee32c80e6a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 161346, "upload_time": "2020-05-04T16:03:42", "upload_time_iso_8601": "2020-05-04T16:03:42.417145Z", "url": "https://files.pythonhosted.org/packages/d7/b5/b35bcc6ade0e31de84fbf6dc6274a904c6b7c9a41cefd71f2f156c82e521/alteruphono-0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d361f928f868faabf2d2ecd7fec75b47", "sha256": "828aedfff2705273f9c1413aad0358df959ff0759711661cdaaa3942f2875654"}, "downloads": -1, "filename": "alteruphono-0.3.tar.gz", "has_sig": false, "md5_digest": "d361f928f868faabf2d2ecd7fec75b47", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 118136, "upload_time": "2020-05-04T16:03:45", "upload_time_iso_8601": "2020-05-04T16:03:45.442427Z", "url": "https://files.pythonhosted.org/packages/d9/d0/c02a31e765b7b2ebfe9519a680997a925eca7edf600b66c417c6f3edc643/alteruphono-0.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:18:27 2020"}