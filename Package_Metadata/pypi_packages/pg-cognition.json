{"info": {"author": "Mathew Moon", "author_email": "mmoon@quinovas.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3.7"], "description": "# A framework tying Aurora Serverless Postgres together with AWS Cognito and Appsync in a multi-tenant application.\nThe package includes utilities for creating a database schema with the needed tables for users and tenants, creating Necessary Cognito webooks, and resolving Appsync queries.\n\n## Athentication\nAuthentication in Aurora Serveless is done via AWS secrets that contain database credentials. pg-cognition creates users in the database that map to credentials in AWS Secrets Manager to provide authorization\non the database layer instead of requiring it in the application layer. This results in a high level of security due to the fact that an exploit in the application layer will not allow a user to access resources\nthat they are not granted in the database layer.\n\n## Database roles\nThe basis of authorization is achieved through a scaffolding of database roles and Row Level Security Policies. The following roles dictate what users can do in the users and tenants table in the pg-cognition schema,\nwhich controls authorization.\n\n  + **application_admins** - Have the keys to the kingdom. They can modify any attribute of any user or tenant\n  + **tenant_admins** - Can modify any attribute of a user (except their database username) that belongs to their tenant and change their tenant\u2019s display name\n  + **tenant_users** - Can modify their own basic info\n\n## Tenants and schemas\npg-cognition creates a multi-tenant system by segregating tenants into their own schemas. This creates a layer of isolation in data without having to create RLS policies for any piece of data that you want secregated.\nYou can of course create a single tenant and assign all users to that tenant if you wish for your application to behave differently. Users are \u201clocked into\u201d their tenants\u2019s schema through role inheritance.\n\nBefore creating a tenant you first create a template schema named \u201ctenant_template\u201d. This schema is used as the template for any user you create and contain any database objects that you want, including\n\n  + tables\n  + triggers\n  + functions\n  + RLS Policies\n  + etc\n\nWhen a tenant is created this schema is cloned, along with all of its child objects. There also an admin and a tenant role that are created with only permissions on that schema.\nThese roles inherit the tenant_admins and tenant_users roles (respectively). Fine tuning permissions can be done in three different ways:\n\n+ Modifying Grants for the tenant level roles to apply new permissions only to the users and/or admins in that tenant for only their schema\n+ Modifying Grants to the tenant_admins/tenant_users roles, which will grant these permissions to the users/admins of all tenants\n+ Applying RLS to a specific schema\n\n## Appsync\nThis package includes utilities for creating a Lambda function that can function as an Appsync datasource. This works by grabbing the Cognito identity or IAM arn of the entitiy\nwho made the call to appsync and then performing the query using their db credentials. Using this datasource makes creating resolvers simple. By default we handle single or batch\ninvocations, returning the data in the format that Appsync expects from our method. Resolvers simply define a query and a list of parameters that will be passed to the call to Aurora.\nNo authorization has to happen in the resolver itself and no parsing has to happen in the response template to organize the data into the format that Appsync expects.\n\nFeatures:\n\n  + Batch or single invocations work without any extra configuration\n  + Database credentials are fetched based on the Cognito user who made the Appsync call\n  + Additional overrides allow IAM roles and IAM Assumed roles to be mapped to specific database credentials\n  + Results are automatically formatted into a list of dictionaries with the column names as keys (or a list of lists in the case of a batch invoke) using aurora-prettyparser package\n\n## Cognito\nIntegration with Cognito is what glues the application layer to the database authorization layer. This starts with implementing Cognito hooks that tie users in the database users table to a cognito user.\nStandard user creation workflow:\n\n  + A user is invited to the application\n  + A row representing that user is created in the users table (with no database credentials and no way to access the app) and is set to an \u201cinvited\u201d state\n  + When a user attempts to create a cognito user in the application\u2019s user pool the Cognito hooks will prevent a signup if that email address does not exist in the user\u2019s table in the \u201cinvited\u201d state\n  + If the user successfully created in Cognito (eg: was invited and Cognito user creation is successful) then a function can be triggered that will\n    - Generate a random database username and role\n    - Assign that username to the new user\n    - Create the secret for that database user in Secrets Manager\n    - Grant the tenant user/admin role to the new user\n\n### Hooks for login\nWhen a user attempts to log into the application we can reject them with a PreAuthentication hook if they do not exist in the application or are not in the \u201cactive\u201d status. This allows us to to suspend users\nby simply changing their user status in the database. This also blocks attemps to guess/brute force Cognito credentials since the username would not only have to exist in Cognito, but also be active in the application.\nOnce a user is successfully logged in we can add claims to their JWT to be used in the application using the Cognito module in the PreTokenGeneration hook.\nThis separation of Cognito users and database users has several advantages.\n\n  + Getting a Cognito login doesn\u2019t guarantee access to the database\n  + A user can be removed in the application without removing their Cognito user\n  + Users can be suspended in the application without having to touch their Cognito user\n  + The use of Cognito hooks prevents unauthorized logins from existing Cognito users that have been disabled in the application\n\n[Read the full code Documentation HERE](./docs/index.html)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/QuiNovas/pg-cognition", "keywords": "", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "pg-cognition", "package_url": "https://pypi.org/project/pg-cognition/", "platform": "", "project_url": "https://pypi.org/project/pg-cognition/", "project_urls": {"Homepage": "https://github.com/QuiNovas/pg-cognition"}, "release_url": "https://pypi.org/project/pg-cognition/0.0.3/", "requires_dist": ["aurora-prettyparser", "boto3", "botocore"], "requires_python": "", "summary": "Building blocks for a Postgres + Appsync + Cognito framework", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>A framework tying Aurora Serverless Postgres together with AWS Cognito and Appsync in a multi-tenant application.</h1>\n<p>The package includes utilities for creating a database schema with the needed tables for users and tenants, creating Necessary Cognito webooks, and resolving Appsync queries.</p>\n<h2>Athentication</h2>\n<p>Authentication in Aurora Serveless is done via AWS secrets that contain database credentials. pg-cognition creates users in the database that map to credentials in AWS Secrets Manager to provide authorization\non the database layer instead of requiring it in the application layer. This results in a high level of security due to the fact that an exploit in the application layer will not allow a user to access resources\nthat they are not granted in the database layer.</p>\n<h2>Database roles</h2>\n<p>The basis of authorization is achieved through a scaffolding of database roles and Row Level Security Policies. The following roles dictate what users can do in the users and tenants table in the pg-cognition schema,\nwhich controls authorization.</p>\n<ul>\n<li><strong>application_admins</strong> - Have the keys to the kingdom. They can modify any attribute of any user or tenant</li>\n<li><strong>tenant_admins</strong> - Can modify any attribute of a user (except their database username) that belongs to their tenant and change their tenant\u2019s display name</li>\n<li><strong>tenant_users</strong> - Can modify their own basic info</li>\n</ul>\n<h2>Tenants and schemas</h2>\n<p>pg-cognition creates a multi-tenant system by segregating tenants into their own schemas. This creates a layer of isolation in data without having to create RLS policies for any piece of data that you want secregated.\nYou can of course create a single tenant and assign all users to that tenant if you wish for your application to behave differently. Users are \u201clocked into\u201d their tenants\u2019s schema through role inheritance.</p>\n<p>Before creating a tenant you first create a template schema named \u201ctenant_template\u201d. This schema is used as the template for any user you create and contain any database objects that you want, including</p>\n<ul>\n<li>tables</li>\n<li>triggers</li>\n<li>functions</li>\n<li>RLS Policies</li>\n<li>etc</li>\n</ul>\n<p>When a tenant is created this schema is cloned, along with all of its child objects. There also an admin and a tenant role that are created with only permissions on that schema.\nThese roles inherit the tenant_admins and tenant_users roles (respectively). Fine tuning permissions can be done in three different ways:</p>\n<ul>\n<li>Modifying Grants for the tenant level roles to apply new permissions only to the users and/or admins in that tenant for only their schema</li>\n<li>Modifying Grants to the tenant_admins/tenant_users roles, which will grant these permissions to the users/admins of all tenants</li>\n<li>Applying RLS to a specific schema</li>\n</ul>\n<h2>Appsync</h2>\n<p>This package includes utilities for creating a Lambda function that can function as an Appsync datasource. This works by grabbing the Cognito identity or IAM arn of the entitiy\nwho made the call to appsync and then performing the query using their db credentials. Using this datasource makes creating resolvers simple. By default we handle single or batch\ninvocations, returning the data in the format that Appsync expects from our method. Resolvers simply define a query and a list of parameters that will be passed to the call to Aurora.\nNo authorization has to happen in the resolver itself and no parsing has to happen in the response template to organize the data into the format that Appsync expects.</p>\n<p>Features:</p>\n<ul>\n<li>Batch or single invocations work without any extra configuration</li>\n<li>Database credentials are fetched based on the Cognito user who made the Appsync call</li>\n<li>Additional overrides allow IAM roles and IAM Assumed roles to be mapped to specific database credentials</li>\n<li>Results are automatically formatted into a list of dictionaries with the column names as keys (or a list of lists in the case of a batch invoke) using aurora-prettyparser package</li>\n</ul>\n<h2>Cognito</h2>\n<p>Integration with Cognito is what glues the application layer to the database authorization layer. This starts with implementing Cognito hooks that tie users in the database users table to a cognito user.\nStandard user creation workflow:</p>\n<ul>\n<li>A user is invited to the application</li>\n<li>A row representing that user is created in the users table (with no database credentials and no way to access the app) and is set to an \u201cinvited\u201d state</li>\n<li>When a user attempts to create a cognito user in the application\u2019s user pool the Cognito hooks will prevent a signup if that email address does not exist in the user\u2019s table in the \u201cinvited\u201d state</li>\n<li>If the user successfully created in Cognito (eg: was invited and Cognito user creation is successful) then a function can be triggered that will\n<ul>\n<li>Generate a random database username and role</li>\n<li>Assign that username to the new user</li>\n<li>Create the secret for that database user in Secrets Manager</li>\n<li>Grant the tenant user/admin role to the new user</li>\n</ul>\n</li>\n</ul>\n<h3>Hooks for login</h3>\n<p>When a user attempts to log into the application we can reject them with a PreAuthentication hook if they do not exist in the application or are not in the \u201cactive\u201d status. This allows us to to suspend users\nby simply changing their user status in the database. This also blocks attemps to guess/brute force Cognito credentials since the username would not only have to exist in Cognito, but also be active in the application.\nOnce a user is successfully logged in we can add claims to their JWT to be used in the application using the Cognito module in the PreTokenGeneration hook.\nThis separation of Cognito users and database users has several advantages.</p>\n<ul>\n<li>Getting a Cognito login doesn\u2019t guarantee access to the database</li>\n<li>A user can be removed in the application without removing their Cognito user</li>\n<li>Users can be suspended in the application without having to touch their Cognito user</li>\n<li>The use of Cognito hooks prevents unauthorized logins from existing Cognito users that have been disabled in the application</li>\n</ul>\n<p><a href=\"./docs/index.html\" rel=\"nofollow\">Read the full code Documentation HERE</a></p>\n\n          </div>"}, "last_serial": 7191784, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "21e0f5f504dd9404e3ce2c0a9b49a5c3", "sha256": "84b1e5b24c91dd65d1319c93edd47a0e7c85a6472748f662189abd5f73a30516"}, "downloads": -1, "filename": "pg_cognition-0.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "21e0f5f504dd9404e3ce2c0a9b49a5c3", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 27696, "upload_time": "2020-05-06T20:19:09", "upload_time_iso_8601": "2020-05-06T20:19:09.110976Z", "url": "https://files.pythonhosted.org/packages/da/c2/54169d89d04be5f474f361b7f5425bd549d1eeb79f00709dfbc67890bde4/pg_cognition-0.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "30ce043ce341e267a831311e8afb4817", "sha256": "aec19749a13eacabd42cdcafd232ac06016655fd52d6536da351ef3f30157dbc"}, "downloads": -1, "filename": "pg-cognition-0.0.2.tar.gz", "has_sig": false, "md5_digest": "30ce043ce341e267a831311e8afb4817", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25483, "upload_time": "2020-05-06T20:19:09", "upload_time_iso_8601": "2020-05-06T20:19:09.850549Z", "url": "https://files.pythonhosted.org/packages/d7/3f/db1ba23c9b4230b5397c77e8003e75ad4edd2460e0a507d35924cba083af/pg-cognition-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "0346e4358805e01e940648f200388480", "sha256": "91eb0d011ee5ff7918ca1016573def1056e7ff8d97a0571061aa69825631f78d"}, "downloads": -1, "filename": "pg_cognition-0.0.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0346e4358805e01e940648f200388480", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 29745, "upload_time": "2020-05-07T21:01:17", "upload_time_iso_8601": "2020-05-07T21:01:17.237594Z", "url": "https://files.pythonhosted.org/packages/d4/4c/4ab51e9921c136e072152e36bcd6b6448ff1380ea1a8d6bca82af75a12aa/pg_cognition-0.0.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "25b8db5cac0b4d9bc1c64b76c50dcb09", "sha256": "80c39f40a01ed2edca2e3ab8879e4beb342f85a927a33d6c2dd12f3b7e32187d"}, "downloads": -1, "filename": "pg-cognition-0.0.3.tar.gz", "has_sig": false, "md5_digest": "25b8db5cac0b4d9bc1c64b76c50dcb09", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27181, "upload_time": "2020-05-07T21:01:18", "upload_time_iso_8601": "2020-05-07T21:01:18.406352Z", "url": "https://files.pythonhosted.org/packages/94/ee/3bd4532f3dd96fc03eeb2c2ae33375e6e882aeb217e28414757f1b318956/pg-cognition-0.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0346e4358805e01e940648f200388480", "sha256": "91eb0d011ee5ff7918ca1016573def1056e7ff8d97a0571061aa69825631f78d"}, "downloads": -1, "filename": "pg_cognition-0.0.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0346e4358805e01e940648f200388480", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 29745, "upload_time": "2020-05-07T21:01:17", "upload_time_iso_8601": "2020-05-07T21:01:17.237594Z", "url": "https://files.pythonhosted.org/packages/d4/4c/4ab51e9921c136e072152e36bcd6b6448ff1380ea1a8d6bca82af75a12aa/pg_cognition-0.0.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "25b8db5cac0b4d9bc1c64b76c50dcb09", "sha256": "80c39f40a01ed2edca2e3ab8879e4beb342f85a927a33d6c2dd12f3b7e32187d"}, "downloads": -1, "filename": "pg-cognition-0.0.3.tar.gz", "has_sig": false, "md5_digest": "25b8db5cac0b4d9bc1c64b76c50dcb09", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27181, "upload_time": "2020-05-07T21:01:18", "upload_time_iso_8601": "2020-05-07T21:01:18.406352Z", "url": "https://files.pythonhosted.org/packages/94/ee/3bd4532f3dd96fc03eeb2c2ae33375e6e882aeb217e28414757f1b318956/pg-cognition-0.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:55:51 2020"}