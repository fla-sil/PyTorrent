{"info": {"author": "Timo Furrer", "author_email": "tuxtimo@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Code Generators", "Topic :: Software Development :: Libraries :: Python Modules"], "description": ".. image:: https://img.shields.io/travis/jenisys/parse_type/master.svg\n    :target: https://travis-ci.org/jenisys/parse_type\n    :alt: Travis CI Build Status\n\n.. image:: https://img.shields.io/pypi/v/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type\n    :alt: Latest Version\n\n.. image:: https://img.shields.io/pypi/dm/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type\n    :alt: Downloads\n\n.. image:: https://img.shields.io/pypi/l/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type/\n    :alt: License\n\n\n`parse_type`_ extends the `parse`_ module (opposite of `string.format()`_)\nwith the following features:\n\n    * build type converters for common use cases (enum/mapping, choice)\n    * build a type converter with a cardinality constraint (0..1, 0..*, 1..*)\n      from the type converter with cardinality=1.\n    * compose a type converter from other type converters\n    * an extended parser that supports the CardinalityField naming schema\n      and creates missing type variants (0..1, 0..*, 1..*) from the\n      primary type converter\n\n.. _parse_type: http://pypi.python.org/pypi/parse_type\n.. _parse:      http://pypi.python.org/pypi/parse\n.. _`string.format()`: http://docs.python.org/library/string.html#format-string-syntax\n\n\nDefinitions\n-------------------------------------------------------------------------------\n\n*type converter*\n    A type converter function that converts a textual representation\n    of a value type into instance of this value type.\n    In addition, a type converter function is often annotated with attributes\n    that allows the `parse`_ module to use it in a generic way.\n    A type converter is also called a *parse_type* (a definition used here).\n\n*cardinality field*\n    A naming convention for related types that differ in cardinality.\n    A cardinality field is a type name suffix in the format of a field.\n    It allows parse format expression, ala::\n\n        \"{person:Person}\"     #< Cardinality: 1    (one; the normal case)\n        \"{person:Person?}\"    #< Cardinality: 0..1 (zero or one  = optional)\n        \"{persons:Person*}\"   #< Cardinality: 0..* (zero or more = many0)\n        \"{persons:Person+}\"   #< Cardinality: 1..* (one  or more = many)\n\n    This naming convention mimics the relationship descriptions in UML diagrams.\n\n\nBasic Example\n-------------------------------------------------------------------------------\n\nDefine an own type converter for numbers (integers):\n\n.. code-block:: python\n\n    # -- USE CASE:\n    def parse_number(text):\n        return int(text)\n    parse_number.pattern = r\"\\d+\"  # -- REGULAR EXPRESSION pattern for type.\n\nThis is equivalent to:\n\n.. code-block:: python\n\n    import parse\n\n    @parse.with_pattern(r\"\\d+\")\n    def parse_number(text):\n         return int(text)\n    assert hasattr(parse_number, \"pattern\")\n    assert parse_number.pattern == r\"\\d+\"\n\n\n.. code-block:: python\n\n    # -- USE CASE: Use the type converter with the parse module.\n    schema = \"Hello {number:Number}\"\n    parser = parse.Parser(schema, dict(Number=parse_number))\n    result = parser.parse(\"Hello 42\")\n    assert result is not None, \"REQUIRE: text matches the schema.\"\n    assert result[\"number\"] == 42\n\n    result = parser.parse(\"Hello XXX\")\n    assert result is None, \"MISMATCH: text does not match the schema.\"\n\n.. hint::\n\n    The described functionality above is standard functionality\n    of the `parse`_ module. It serves as introduction for the remaining cases.\n\n\nCardinality\n-------------------------------------------------------------------------------\n\nCreate an type converter for \"ManyNumbers\" (List, separated with commas)\nwith cardinality \"1..* = 1+\" (many) from the type converter for a \"Number\".\n\n.. code-block:: python\n\n    # -- USE CASE: Create new type converter with a cardinality constraint.\n    # CARDINALITY: many := one or more (1..*)\n    from parse import Parser\n    from parse_type import TypeBuilder\n    parse_numbers = TypeBuilder.with_many(parse_number, listsep=\",\")\n\n    schema = \"List: {numbers:ManyNumbers}\"\n    parser = Parser(schema, dict(ManyNumbers=parse_numbers))\n    result = parser.parse(\"List: 1, 2, 3\")\n    assert result[\"numbers\"] == [1, 2, 3]\n\n\nCreate an type converter for an \"OptionalNumbers\" with cardinality \"0..1 = ?\"\n(optional) from the type converter for a \"Number\".\n\n.. code-block:: python\n\n    # -- USE CASE: Create new type converter with cardinality constraint.\n    # CARDINALITY: optional := zero or one (0..1)\n    from parse import Parser\n    from parse_type import TypeBuilder\n\n    parse_optional_number = TypeBuilder.with_optional(parse_number)\n    schema = \"Optional: {number:OptionalNumber}\"\n    parser = Parser(schema, dict(OptionalNumber=parse_optional_number))\n    result = parser.parse(\"Optional: 42\")\n    assert result[\"number\"] == 42\n    result = parser.parse(\"Optional: \")\n    assert result[\"number\"] == None\n\n\nEnumeration (Name-to-Value Mapping)\n-------------------------------------------------------------------------------\n\nCreate an type converter for an \"Enumeration\" from the description of\nthe mapping as dictionary.\n\n.. code-block:: python\n\n    # -- USE CASE: Create a type converter for an enumeration.\n    from parse import Parser\n    from parse_type import TypeBuilder\n\n    parse_enum_yesno = TypeBuilder.make_enum({\"yes\": True, \"no\": False})\n    parser = Parser(\"Answer: {answer:YesNo}\", dict(YesNo=parse_enum_yesno))\n    result = parser.parse(\"Answer: yes\")\n    assert result[\"answer\"] == True\n\n\nCreate an type converter for an \"Enumeration\" from the description of\nthe mapping as an enumeration class (`Python 3.4 enum`_ or the `enum34`_\nbackport; see also: `PEP-0435`_).\n\n.. code-block:: python\n\n    # -- USE CASE: Create a type converter for enum34 enumeration class.\n    # NOTE: Use Python 3.4 or enum34 backport.\n    from parse import Parser\n    from parse_type import TypeBuilder\n    from enum import Enum\n\n    class Color(Enum):\n        red   = 1\n        green = 2\n        blue  = 3\n\n    parse_enum_color = TypeBuilder.make_enum(Color)\n    parser = Parser(\"Select: {color:Color}\", dict(Color=parse_enum_color))\n    result = parser.parse(\"Select: red\")\n    assert result[\"color\"] is Color.red\n\n.. _`Python 3.4 enum`: http://docs.python.org/3.4/library/enum.html#module-enum\n.. _enum34:   http://pypi.python.org/pypi/enum34\n.. _PEP-0435: http://www.python.org/dev/peps/pep-0435\n\n\nChoice (Name Enumeration)\n-------------------------------------------------------------------------------\n\nA Choice data type allows to select one of several strings.\n\nCreate an type converter for an \"Choice\" list, a list of unique names\n(as string).\n\n.. code-block:: python\n\n    from parse import Parser\n    from parse_type import TypeBuilder\n\n    parse_choice_yesno = TypeBuilder.make_choice([\"yes\", \"no\"])\n    schema = \"Answer: {answer:ChoiceYesNo}\"\n    parser = Parser(schema, dict(ChoiceYesNo=parse_choice_yesno))\n    result = parser.parse(\"Answer: yes\")\n    assert result[\"answer\"] == \"yes\"\n\n\nVariant (Type Alternatives)\n-------------------------------------------------------------------------------\n\nSometimes you need a type converter that can accept text for multiple\ntype converter alternatives. This is normally called a \"variant\" (or: union).\n\nCreate an type converter for an \"Variant\" type that accepts:\n\n  * Numbers (positive numbers, as integer)\n  * Color enum values (by name)\n\n.. code-block:: python\n\n    from parse import Parser, with_pattern\n    from parse_type import TypeBuilder\n    from enum import Enum\n\n    class Color(Enum):\n        red   = 1\n        green = 2\n        blue  = 3\n\n    @with_pattern(r\"\\d+\")\n    def parse_number(text):\n        return int(text)\n\n    # -- MAKE VARIANT: Alternatives of different type converters.\n    parse_color = TypeBuilder.make_enum(Color)\n    parse_variant = TypeBuilder.make_variant([parse_number, parse_color])\n    schema = \"Variant: {variant:Number_or_Color}\"\n    parser = Parser(schema, dict(Number_or_Color=parse_variant))\n\n    # -- TEST VARIANT: With number, color and mismatch.\n    result = parser.parse(\"Variant: 42\")\n    assert result[\"variant\"] == 42\n    result = parser.parse(\"Variant: blue\")\n    assert result[\"variant\"] is Color.blue\n    result = parser.parse(\"Variant: __MISMATCH__\")\n    assert not result\n\n\n\nExtended Parser with CardinalityField support\n-------------------------------------------------------------------------------\n\nThe parser extends the ``parse.Parser`` and adds the following functionality:\n\n   * supports the CardinalityField naming scheme\n   * automatically creates missing type variants for types with\n     a CardinalityField by using the primary type converter for cardinality=1\n   * extends the provide type converter dictionary with new type variants.\n\nExample:\n\n.. code-block:: python\n\n    # -- USE CASE: Parser with CardinalityField support.\n    # NOTE: Automatically adds missing type variants with CardinalityField part.\n    # USE:  parse_number() type converter from above.\n    from parse_type.cfparse import Parser\n\n    # -- PREPARE: parser, adds missing type variant for cardinality 1..* (many)\n    type_dict = dict(Number=parse_number)\n    schema = \"List: {numbers:Number+}\"\n    parser = Parser(schema, type_dict)\n    assert \"Number+\" in type_dict, \"Created missing type variant based on: Number\"\n\n    # -- USE: parser.\n    result = parser.parse(\"List: 1, 2, 3\")\n    assert result[\"numbers\"] == [1, 2, 3]\n", "description_content_type": null, "docs_url": null, "download_url": "http://pypi.python.org/pypi/parse_type", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jenisys/parse_type", "keywords": "parse", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "radish-parse_type", "package_url": "https://pypi.org/project/radish-parse_type/", "platform": "any", "project_url": "https://pypi.org/project/radish-parse_type/", "project_urls": {"Download": "http://pypi.python.org/pypi/parse_type", "Homepage": "https://github.com/jenisys/parse_type"}, "release_url": "https://pypi.org/project/radish-parse_type/0.3.5/", "requires_dist": null, "requires_python": "", "summary": "Simplifies to build parse types based on the parse module", "version": "0.3.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/jenisys/parse_type\" rel=\"nofollow\"><img alt=\"Travis CI Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c718bea5a9147a834f524385fc9bc785ea2358a7/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f6a656e697379732f70617273655f747970652f6d61737465722e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/parse_type\" rel=\"nofollow\"><img alt=\"Latest Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3eab0a857272f9139dc29e3307060647d3f95daf/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f70617273655f747970652e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/parse_type\" rel=\"nofollow\"><img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a6046dd79bc432ce67a69893535ee5a33cc0fc64/68747470733a2f2f696d672e736869656c64732e696f2f707970692f646d2f70617273655f747970652e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/parse_type/\" rel=\"nofollow\"><img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b648a680d86c11d4a5a5ccc2f5a9601f8dc61175/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f70617273655f747970652e737667\"></a>\n<p><a href=\"http://pypi.python.org/pypi/parse_type\" rel=\"nofollow\">parse_type</a> extends the <a href=\"http://pypi.python.org/pypi/parse\" rel=\"nofollow\">parse</a> module (opposite of <a href=\"http://docs.python.org/library/string.html#format-string-syntax\" rel=\"nofollow\">string.format()</a>)\nwith the following features:</p>\n<blockquote>\n<ul>\n<li>build type converters for common use cases (enum/mapping, choice)</li>\n<li>build a type converter with a cardinality constraint (0..1, 0..*, 1..*)\nfrom the type converter with cardinality=1.</li>\n<li>compose a type converter from other type converters</li>\n<li>an extended parser that supports the CardinalityField naming schema\nand creates missing type variants (0..1, 0..*, 1..*) from the\nprimary type converter</li>\n</ul>\n</blockquote>\n<div id=\"definitions\">\n<h2>Definitions</h2>\n<dl>\n<dt><em>type converter</em></dt>\n<dd>A type converter function that converts a textual representation\nof a value type into instance of this value type.\nIn addition, a type converter function is often annotated with attributes\nthat allows the <a href=\"http://pypi.python.org/pypi/parse\" rel=\"nofollow\">parse</a> module to use it in a generic way.\nA type converter is also called a <em>parse_type</em> (a definition used here).</dd>\n<dt><em>cardinality field</em></dt>\n<dd><p>A naming convention for related types that differ in cardinality.\nA cardinality field is a type name suffix in the format of a field.\nIt allows parse format expression, ala:</p>\n<pre>\"{person:Person}\"     #&lt; Cardinality: 1    (one; the normal case)\n\"{person:Person?}\"    #&lt; Cardinality: 0..1 (zero or one  = optional)\n\"{persons:Person*}\"   #&lt; Cardinality: 0..* (zero or more = many0)\n\"{persons:Person+}\"   #&lt; Cardinality: 1..* (one  or more = many)\n</pre>\n<p>This naming convention mimics the relationship descriptions in UML diagrams.</p>\n</dd>\n</dl>\n</div>\n<div id=\"basic-example\">\n<h2>Basic Example</h2>\n<p>Define an own type converter for numbers (integers):</p>\n<pre><span class=\"c1\"># -- USE CASE:</span>\n<span class=\"k\">def</span> <span class=\"nf\">parse_number</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"n\">parse_number</span><span class=\"o\">.</span><span class=\"n\">pattern</span> <span class=\"o\">=</span> <span class=\"sa\">r</span><span class=\"s2\">\"\\d+\"</span>  <span class=\"c1\"># -- REGULAR EXPRESSION pattern for type.</span>\n</pre>\n<p>This is equivalent to:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">parse</span>\n\n<span class=\"nd\">@parse</span><span class=\"o\">.</span><span class=\"n\">with_pattern</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">\"\\d+\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">parse_number</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n     <span class=\"k\">return</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">parse_number</span><span class=\"p\">,</span> <span class=\"s2\">\"pattern\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">parse_number</span><span class=\"o\">.</span><span class=\"n\">pattern</span> <span class=\"o\">==</span> <span class=\"sa\">r</span><span class=\"s2\">\"\\d+\"</span>\n</pre>\n<pre><span class=\"c1\"># -- USE CASE: Use the type converter with the parse module.</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"Hello {number:Number}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">parse</span><span class=\"o\">.</span><span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">Number</span><span class=\"o\">=</span><span class=\"n\">parse_number</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Hello 42\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"s2\">\"REQUIRE: text matches the schema.\"</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"number\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">42</span>\n\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Hello XXX\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"s2\">\"MISMATCH: text does not match the schema.\"</span>\n</pre>\n<div>\n<p>Hint</p>\n<p>The described functionality above is standard functionality\nof the <a href=\"http://pypi.python.org/pypi/parse\" rel=\"nofollow\">parse</a> module. It serves as introduction for the remaining cases.</p>\n</div>\n</div>\n<div id=\"cardinality\">\n<h2>Cardinality</h2>\n<p>Create an type converter for \u201cManyNumbers\u201d (List, separated with commas)\nwith cardinality \u201c1..* = 1+\u201d (many) from the type converter for a \u201cNumber\u201d.</p>\n<pre><span class=\"c1\"># -- USE CASE: Create new type converter with a cardinality constraint.</span>\n<span class=\"c1\"># CARDINALITY: many := one or more (1..*)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n<span class=\"n\">parse_numbers</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">with_many</span><span class=\"p\">(</span><span class=\"n\">parse_number</span><span class=\"p\">,</span> <span class=\"n\">listsep</span><span class=\"o\">=</span><span class=\"s2\">\",\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"List: {numbers:ManyNumbers}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">ManyNumbers</span><span class=\"o\">=</span><span class=\"n\">parse_numbers</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"List: 1, 2, 3\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"numbers\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]</span>\n</pre>\n<p>Create an type converter for an \u201cOptionalNumbers\u201d with cardinality \u201c0..1 = ?\u201d\n(optional) from the type converter for a \u201cNumber\u201d.</p>\n<pre><span class=\"c1\"># -- USE CASE: Create new type converter with cardinality constraint.</span>\n<span class=\"c1\"># CARDINALITY: optional := zero or one (0..1)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n\n<span class=\"n\">parse_optional_number</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">with_optional</span><span class=\"p\">(</span><span class=\"n\">parse_number</span><span class=\"p\">)</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"Optional: {number:OptionalNumber}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">OptionalNumber</span><span class=\"o\">=</span><span class=\"n\">parse_optional_number</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Optional: 42\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"number\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">42</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Optional: \"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"number\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"kc\">None</span>\n</pre>\n</div>\n<div id=\"enumeration-name-to-value-mapping\">\n<h2>Enumeration (Name-to-Value Mapping)</h2>\n<p>Create an type converter for an \u201cEnumeration\u201d from the description of\nthe mapping as dictionary.</p>\n<pre><span class=\"c1\"># -- USE CASE: Create a type converter for an enumeration.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n\n<span class=\"n\">parse_enum_yesno</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_enum</span><span class=\"p\">({</span><span class=\"s2\">\"yes\"</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"s2\">\"no\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">})</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"s2\">\"Answer: {answer:YesNo}\"</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">YesNo</span><span class=\"o\">=</span><span class=\"n\">parse_enum_yesno</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Answer: yes\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"answer\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>\n</pre>\n<p>Create an type converter for an \u201cEnumeration\u201d from the description of\nthe mapping as an enumeration class (<a href=\"http://docs.python.org/3.4/library/enum.html#module-enum\" rel=\"nofollow\">Python 3.4 enum</a> or the <a href=\"http://pypi.python.org/pypi/enum34\" rel=\"nofollow\">enum34</a>\nbackport; see also: <a href=\"http://www.python.org/dev/peps/pep-0435\" rel=\"nofollow\">PEP-0435</a>).</p>\n<pre><span class=\"c1\"># -- USE CASE: Create a type converter for enum34 enumeration class.</span>\n<span class=\"c1\"># NOTE: Use Python 3.4 or enum34 backport.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">enum</span> <span class=\"kn\">import</span> <span class=\"n\">Enum</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Color</span><span class=\"p\">(</span><span class=\"n\">Enum</span><span class=\"p\">):</span>\n    <span class=\"n\">red</span>   <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">green</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n    <span class=\"n\">blue</span>  <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"n\">parse_enum_color</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_enum</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">)</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"s2\">\"Select: {color:Color}\"</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"o\">=</span><span class=\"n\">parse_enum_color</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Select: red\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"color\"</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"n\">Color</span><span class=\"o\">.</span><span class=\"n\">red</span>\n</pre>\n</div>\n<div id=\"choice-name-enumeration\">\n<h2>Choice (Name Enumeration)</h2>\n<p>A Choice data type allows to select one of several strings.</p>\n<p>Create an type converter for an \u201cChoice\u201d list, a list of unique names\n(as string).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n\n<span class=\"n\">parse_choice_yesno</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_choice</span><span class=\"p\">([</span><span class=\"s2\">\"yes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"no\"</span><span class=\"p\">])</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"Answer: {answer:ChoiceYesNo}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">ChoiceYesNo</span><span class=\"o\">=</span><span class=\"n\">parse_choice_yesno</span><span class=\"p\">))</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Answer: yes\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"answer\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s2\">\"yes\"</span>\n</pre>\n</div>\n<div id=\"variant-type-alternatives\">\n<h2>Variant (Type Alternatives)</h2>\n<p>Sometimes you need a type converter that can accept text for multiple\ntype converter alternatives. This is normally called a \u201cvariant\u201d (or: union).</p>\n<p>Create an type converter for an \u201cVariant\u201d type that accepts:</p>\n<blockquote>\n<ul>\n<li>Numbers (positive numbers, as integer)</li>\n<li>Color enum values (by name)</li>\n</ul>\n</blockquote>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">parse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span><span class=\"p\">,</span> <span class=\"n\">with_pattern</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type</span> <span class=\"kn\">import</span> <span class=\"n\">TypeBuilder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">enum</span> <span class=\"kn\">import</span> <span class=\"n\">Enum</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Color</span><span class=\"p\">(</span><span class=\"n\">Enum</span><span class=\"p\">):</span>\n    <span class=\"n\">red</span>   <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">green</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n    <span class=\"n\">blue</span>  <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"nd\">@with_pattern</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s2\">\"\\d+\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">parse_number</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># -- MAKE VARIANT: Alternatives of different type converters.</span>\n<span class=\"n\">parse_color</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_enum</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">)</span>\n<span class=\"n\">parse_variant</span> <span class=\"o\">=</span> <span class=\"n\">TypeBuilder</span><span class=\"o\">.</span><span class=\"n\">make_variant</span><span class=\"p\">([</span><span class=\"n\">parse_number</span><span class=\"p\">,</span> <span class=\"n\">parse_color</span><span class=\"p\">])</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"Variant: {variant:Number_or_Color}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">Number_or_Color</span><span class=\"o\">=</span><span class=\"n\">parse_variant</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># -- TEST VARIANT: With number, color and mismatch.</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Variant: 42\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"variant\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">42</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Variant: blue\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"variant\"</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"n\">Color</span><span class=\"o\">.</span><span class=\"n\">blue</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"Variant: __MISMATCH__\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"ow\">not</span> <span class=\"n\">result</span>\n</pre>\n</div>\n<div id=\"extended-parser-with-cardinalityfield-support\">\n<h2>Extended Parser with CardinalityField support</h2>\n<p>The parser extends the <tt>parse.Parser</tt> and adds the following functionality:</p>\n<blockquote>\n<ul>\n<li>supports the CardinalityField naming scheme</li>\n<li>automatically creates missing type variants for types with\na CardinalityField by using the primary type converter for cardinality=1</li>\n<li>extends the provide type converter dictionary with new type variants.</li>\n</ul>\n</blockquote>\n<p>Example:</p>\n<pre><span class=\"c1\"># -- USE CASE: Parser with CardinalityField support.</span>\n<span class=\"c1\"># NOTE: Automatically adds missing type variants with CardinalityField part.</span>\n<span class=\"c1\"># USE:  parse_number() type converter from above.</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parse_type.cfparse</span> <span class=\"kn\">import</span> <span class=\"n\">Parser</span>\n\n<span class=\"c1\"># -- PREPARE: parser, adds missing type variant for cardinality 1..* (many)</span>\n<span class=\"n\">type_dict</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">Number</span><span class=\"o\">=</span><span class=\"n\">parse_number</span><span class=\"p\">)</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"s2\">\"List: {numbers:Number+}\"</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"n\">type_dict</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"s2\">\"Number+\"</span> <span class=\"ow\">in</span> <span class=\"n\">type_dict</span><span class=\"p\">,</span> <span class=\"s2\">\"Created missing type variant based on: Number\"</span>\n\n<span class=\"c1\"># -- USE: parser.</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"List: 1, 2, 3\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"s2\">\"numbers\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 2904623, "releases": {"0.3.5": [{"comment_text": "", "digests": {"md5": "eaccbd2becc67313e80c9761e66b0045", "sha256": "85c2bf02868670d8dc4ac28f97c4f9a26c0939f30c2aff7d194423fc3fdb66c3"}, "downloads": -1, "filename": "radish_parse_type-0.3.5-py2-none-any.whl", "has_sig": false, "md5_digest": "eaccbd2becc67313e80c9761e66b0045", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 240030, "upload_time": "2017-05-28T13:42:45", "upload_time_iso_8601": "2017-05-28T13:42:45.839655Z", "url": "https://files.pythonhosted.org/packages/80/21/830503fc51e204b12af7f062bc8510ab1c32dd5ed237d1a2ade99e068c19/radish_parse_type-0.3.5-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "68cbae950748f4f08c1824ca670a7591", "sha256": "1029556ce9a0c76612183775b71a058403c9acc322ac1099ee5497f29ccc6fa5"}, "downloads": -1, "filename": "radish-parse_type-0.3.5.tar.gz", "has_sig": false, "md5_digest": "68cbae950748f4f08c1824ca670a7591", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 262964, "upload_time": "2017-05-28T13:42:41", "upload_time_iso_8601": "2017-05-28T13:42:41.427013Z", "url": "https://files.pythonhosted.org/packages/c3/a3/177e8715c995e011b7e6ff966b1408e8b5392d0ebb35ec16494c5a291f32/radish-parse_type-0.3.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "eaccbd2becc67313e80c9761e66b0045", "sha256": "85c2bf02868670d8dc4ac28f97c4f9a26c0939f30c2aff7d194423fc3fdb66c3"}, "downloads": -1, "filename": "radish_parse_type-0.3.5-py2-none-any.whl", "has_sig": false, "md5_digest": "eaccbd2becc67313e80c9761e66b0045", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 240030, "upload_time": "2017-05-28T13:42:45", "upload_time_iso_8601": "2017-05-28T13:42:45.839655Z", "url": "https://files.pythonhosted.org/packages/80/21/830503fc51e204b12af7f062bc8510ab1c32dd5ed237d1a2ade99e068c19/radish_parse_type-0.3.5-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "68cbae950748f4f08c1824ca670a7591", "sha256": "1029556ce9a0c76612183775b71a058403c9acc322ac1099ee5497f29ccc6fa5"}, "downloads": -1, "filename": "radish-parse_type-0.3.5.tar.gz", "has_sig": false, "md5_digest": "68cbae950748f4f08c1824ca670a7591", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 262964, "upload_time": "2017-05-28T13:42:41", "upload_time_iso_8601": "2017-05-28T13:42:41.427013Z", "url": "https://files.pythonhosted.org/packages/c3/a3/177e8715c995e011b7e6ff966b1408e8b5392d0ebb35ec16494c5a291f32/radish-parse_type-0.3.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:58 2020"}