{"info": {"author": "Tom Elliott", "author_email": "tom.elliott@nyu.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: GNU Affero General Public License v3", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only", "Topic :: Text Processing :: General"], "description": "# textnorm\n\nA simple package for normalizing whitespace and Unicode composition forms in Python 3 strings.\n\nThe package provides two functions, as follows. Extended use examples may be found in ```tests/tests.py```.\n\n## normalize_space\n\nThis function takes a Python 3 string argument (```v```) and returns a Python string in which each continuous sequence of one or more whitespace characters found in ```v``` has been collapsed into a single whitespace character. \n\nBasic usage is as simple as:\n\n```python\nfrom textnorm import normalize_space\ns = ' There        was an\\tOld \\tMan in a tree,\\t\\t'\nn = normalize_space(s)\nprint('\"{}\"'.format(n))\n```\n\nwhich produces output like:\n\n```\n\"There was an Old Man in a tree,\"\n```\n\nBy default, characters like newlines (```\\n```) are treated as any other whitespace character, such that use like this:\n\n```python\ns = \"\"\"I\u2019m now arrived\u2014thanks to the gods!\u2014  \n   Thro\u2019 pathways rough and muddy,  \n A certain sign that makin roads  \n   Is no this people\u2019s study:  \"\"\"\nprint('\"{}\"'.format(normalize_space(s)))\n```\n\nyields a result like this: \n\n```\n\"I\u2019m now arrived\u2014thanks to the gods!\u2014 Thro\u2019 pathways rough and muddy, A certain sign that makin roads Is no this people\u2019s study:\"\n```\n\nAn optional keyword argument (```preserve```) may be used to designate a list of one or more whitespace characters that are to be left untouched. So, it is possible to preserve the newlines in the string from the preceding example while normalizing the rest of the whitespace:\n\n```python\nprint('\"{}\"'.format(normalize_space(s, preserve = ['\\n'])))\n```\n\nwhich produces: \n\n```\n\"I\u2019m now arrived\u2014thanks to the gods!\u2014\nThro\u2019 pathways rough and muddy,\nA certain sign that makin roads\nIs no this people\u2019s study:\"\n```\n\nAnother optional keyword argument (```trim```) can be used to adjust handling of whitespace appearing at the beginning and end of the input string. Leading and trailing characters indicated in the ```preserve``` argument are always protected, but otherwise ```trim=True``` (the default) ensures a result with no leading or trailing whitespace. If the input string has leading or trailing whitespace and ```trim``` is set to ```False```, then the result string will have either a single space character corresponding to the original leading/trailing whitespace characters **or** a sequence of preserved whitespace characters copied from the original. For examples:\n\n```python\ns = '\\t\\n orange '\nprint('\"{}\"'.format(normalize_space(s, trim=False)))\n```\n\nproduces\n\n```python\n\" orange \"\n```\n\nand \n\n```python\ns = '\\t\\n orange '\nprint('\"{}\"'.format(normalize_space(s, preserve=['\\n'], trim=False)))\n```\n\nproduces \n\n```python\n\"\norange \"\n```\n\nbut\n\n```python\ns = '\\t\\n orange '\nprint('\"{}\"'.format(normalize_space(s, trim=True)))  # default\n```\n\nproduces\n\n```python\n\"orange\"\n```\n\n## normalize_unicode\n\nThe second function wraps ```unicodedata.normalize``` from the standard library, adding some minor additional functionality. Its primary purpose retains that of ```unicodedata.normalize```, i.e., to return the specified normal form ('NFC', 'NFD', 'NFKC', 'NFKD')  for the Unicode string provided to the function. \n\nExplaining Unicode normalization is beyond the scope of this readme file; however, I can recommend the following for additional reading:\n\n - [J.K. Tauber's article on \"Python, Unicode and Ancient Greek.\"](https://jktauber.com/articles/python-unicode-ancient-greek/)\n - [_The Python Standard Library_, Section 6.5 \"unicodedata \u2014 Unicode Database\"](https://docs.python.org/3.6/library/unicodedata.html)\n - [\"Unicode Equivalence\" in _Wikipedia_](https://en.wikipedia.org/wiki/Unicode_equivalence)\n\nBasic usage of ```textnorm.normalize_unicode``` looks like this:\n\n```python\nfrom textnorm import normalize_unicode\ns_nfc = '\u03bc\\u03ad\u03b3\u03b1 \u03b2\u03b9\u03b2\u03bb\\u03af\u03bf\u03bd \u03bc\\u03ad\u03b3\u03b1 \u03ba\u03b1\u03ba\\u03cc\u03bd'  # NB: \"composed\" forms of accented characters \nn_nfd = normalize_unicode(s_nfc, 'NFD')\nn_nfc = normalize_unicode(n_nfd, 'NFC')\nprint(s_nfc == n_nfd)\nprint(s_nfc == n_nfc)\nprint('original NFC: \"{}\"'.format(s_nfc))\nprint('normalized NFD: \"{}\"'.format(n_nfd))\nprint('round-tripped NFC: \"{}\"'.format(n_nfc))\n```\n\nwhich produces output like this:\n\n```\nFalse\nTrue\noriginal NFC: \"\u03bc\u03ad\u03b3\u03b1 \u03b2\u03b9\u03b2\u03bb\u03af\u03bf\u03bd \u03bc\u03ad\u03b3\u03b1 \u03ba\u03b1\u03ba\u03cc\u03bd\"\nnormalized NFD: \"\u03bc\u03b5\u0301\u03b3\u03b1 \u03b2\u03b9\u03b2\u03bb\u03b9\u0301\u03bf\u03bd \u03bc\u03b5\u0301\u03b3\u03b1 \u03ba\u03b1\u03ba\u03bf\u0301\u03bd\"\nround-tripped NFC: \"\u03bc\u03ad\u03b3\u03b1 \u03b2\u03b9\u03b2\u03bb\u03af\u03bf\u03bd \u03bc\u03ad\u03b3\u03b1 \u03ba\u03b1\u03ba\u03cc\u03bd\"\n```\n\nEven though modern software and fonts are pretty good and making the NFC and NFC forms appear identical, if you examine the underlying encoding you can see that the differences are real. \n\n### added functionality: compatibility checking\n\nOver and above the functionality provided by unicodedata.normalize, textnorm.normalize_unicode has a ```check_compatible``` argument that, if ```True```, triggers a comparison of the targeted normalization form with the corresponding \"compatibility\" form (i.e., it compares 'NFC' with 'NFKC' and 'NFD' with 'NFKD'). If the \"canonical\" and \"compatibility\" forms differ, the function raises ```ValueError``` with a diagnostic message. A calling program that traps for this exception can then implement double-checking or supervision.\n\nThe lunate sigma ('\u03f9' == '\\u03f9') provides a good way to demonstrate this behavior since the canonical forms (NFC and NFD) preserve the character, but the \"compatibility\" forms (NFKC and NFKD) convert it to conventional sigma ('\u03a3' == '\\u03a3'). First, we'll conduct the conversion without a test:\n\n```python\ns = '\\u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75'  # i.e. \u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75\nn = normalize_unicode(s, 'NFKC')\nprint(n)\n```\n\nand we get\n\n```\n\u03a3\u03c5\u03c1\u03b2\u03b1\u03bd\u03ae\n```\n\nBut, if we activate the test: \n\n```python\ns = '\\u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75'  # i.e. \u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75\nn = normalize_unicode(s, 'NFKC', check_compatible=True)\n```\n\nwe'll be treated to the informative traceback:\n\n```\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/Users/paregorios/Documents/files/T/textnorm/textnorm/__init__.py\", line 93, in normalize_unicode\n    raise ValueError(msg)\nValueError: Unicode normalization may have changed the string \"\u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75\" in an undesireable way or may have failed to do so in a manner desired. The NFKC normalized form \"\u03a3\u03c5\u03c1\u03b2\u03b1\u03bd\u03ae\" (b'\\\\N{GREEK CAPITAL LETTER SIGMA}\\\\N{GREEK SMALL LETTER UPSILON}\\\\N{GREEK SMALL LETTER RHO}\\\\N{GREEK SMALL LETTER BETA}\\\\N{GREEK SMALL LETTER ALPHA}\\\\N{GREEK SMALL LETTER NU}\\\\N{GREEK SMALL LETTER ETA WITH TONOS}') does not match the corresponding NFC form \"\u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u03ae\" (b'\\\\N{GREEK CAPITAL LUNATE SIGMA SYMBOL}\\\\N{GREEK SMALL LETTER UPSILON}\\\\N{GREEK SMALL LETTER RHO}\\\\N{GREEK SMALL LETTER BETA}\\\\N{GREEK SMALL LETTER ALPHA}\\\\N{GREEK SMALL LETTER NU}\\\\N{GREEK SMALL LETTER ETA WITH TONOS}').\n```\n\n## etc\n\nPull requests and new tickets on the issue tracker are welcome. \n\n*This README has been created with thanks and apologies to https://www.poets.org and to the ghosts of Robert Burns and Edward Lear.*\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/isawnyu/textnorm", "keywords": "\"text normalization\",\"whitespace normalization\",\"unicode normalization\"", "license": "LICENSE.txt", "maintainer": "", "maintainer_email": "", "name": "textnorm", "package_url": "https://pypi.org/project/textnorm/", "platform": "", "project_url": "https://pypi.org/project/textnorm/", "project_urls": {"Homepage": "https://github.com/isawnyu/textnorm"}, "release_url": "https://pypi.org/project/textnorm/1.2/", "requires_dist": null, "requires_python": "", "summary": "A simple package for normalizing whitespace and Unicode composition forms in Python 3 strings", "version": "1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>textnorm</h1>\n<p>A simple package for normalizing whitespace and Unicode composition forms in Python 3 strings.</p>\n<p>The package provides two functions, as follows. Extended use examples may be found in <code>tests/tests.py</code>.</p>\n<h2>normalize_space</h2>\n<p>This function takes a Python 3 string argument (<code>v</code>) and returns a Python string in which each continuous sequence of one or more whitespace characters found in <code>v</code> has been collapsed into a single whitespace character.</p>\n<p>Basic usage is as simple as:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">textnorm</span> <span class=\"kn\">import</span> <span class=\"n\">normalize_space</span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s1\">' There        was an</span><span class=\"se\">\\t</span><span class=\"s1\">Old </span><span class=\"se\">\\t</span><span class=\"s1\">Man in a tree,</span><span class=\"se\">\\t\\t</span><span class=\"s1\">'</span>\n<span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">normalize_space</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'\"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">))</span>\n</pre>\n<p>which produces output like:</p>\n<pre><code>\"There was an Old Man in a tree,\"\n</code></pre>\n<p>By default, characters like newlines (<code>\\n</code>) are treated as any other whitespace character, such that use like this:</p>\n<pre><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"I\u2019m now arrived\u2014thanks to the gods!\u2014  </span>\n<span class=\"s2\">   Thro\u2019 pathways rough and muddy,  </span>\n<span class=\"s2\"> A certain sign that makin roads  </span>\n<span class=\"s2\">   Is no this people\u2019s study:  \"\"\"</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'\"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">normalize_space</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)))</span>\n</pre>\n<p>yields a result like this:</p>\n<pre><code>\"I\u2019m now arrived\u2014thanks to the gods!\u2014 Thro\u2019 pathways rough and muddy, A certain sign that makin roads Is no this people\u2019s study:\"\n</code></pre>\n<p>An optional keyword argument (<code>preserve</code>) may be used to designate a list of one or more whitespace characters that are to be left untouched. So, it is possible to preserve the newlines in the string from the preceding example while normalizing the rest of the whitespace:</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'\"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">normalize_space</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">preserve</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'</span><span class=\"se\">\\n</span><span class=\"s1\">'</span><span class=\"p\">])))</span>\n</pre>\n<p>which produces:</p>\n<pre><code>\"I\u2019m now arrived\u2014thanks to the gods!\u2014\nThro\u2019 pathways rough and muddy,\nA certain sign that makin roads\nIs no this people\u2019s study:\"\n</code></pre>\n<p>Another optional keyword argument (<code>trim</code>) can be used to adjust handling of whitespace appearing at the beginning and end of the input string. Leading and trailing characters indicated in the <code>preserve</code> argument are always protected, but otherwise <code>trim=True</code> (the default) ensures a result with no leading or trailing whitespace. If the input string has leading or trailing whitespace and <code>trim</code> is set to <code>False</code>, then the result string will have either a single space character corresponding to the original leading/trailing whitespace characters <strong>or</strong> a sequence of preserved whitespace characters copied from the original. For examples:</p>\n<pre><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\t\\n</span><span class=\"s1\"> orange '</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'\"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">normalize_space</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">trim</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)))</span>\n</pre>\n<p>produces</p>\n<pre><span class=\"s2\">\" orange \"</span>\n</pre>\n<p>and</p>\n<pre><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\t\\n</span><span class=\"s1\"> orange '</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'\"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">normalize_space</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">preserve</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'</span><span class=\"se\">\\n</span><span class=\"s1\">'</span><span class=\"p\">],</span> <span class=\"n\">trim</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)))</span>\n</pre>\n<p>produces</p>\n<pre><span class=\"s2\">\"</span>\n<span class=\"n\">orange</span> <span class=\"s2\">\"</span>\n</pre>\n<p>but</p>\n<pre><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\t\\n</span><span class=\"s1\"> orange '</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'\"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">normalize_space</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">trim</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)))</span>  <span class=\"c1\"># default</span>\n</pre>\n<p>produces</p>\n<pre><span class=\"s2\">\"orange\"</span>\n</pre>\n<h2>normalize_unicode</h2>\n<p>The second function wraps <code>unicodedata.normalize</code> from the standard library, adding some minor additional functionality. Its primary purpose retains that of <code>unicodedata.normalize</code>, i.e., to return the specified normal form ('NFC', 'NFD', 'NFKC', 'NFKD')  for the Unicode string provided to the function.</p>\n<p>Explaining Unicode normalization is beyond the scope of this readme file; however, I can recommend the following for additional reading:</p>\n<ul>\n<li><a href=\"https://jktauber.com/articles/python-unicode-ancient-greek/\" rel=\"nofollow\">J.K. Tauber's article on \"Python, Unicode and Ancient Greek.\"</a></li>\n<li><a href=\"https://docs.python.org/3.6/library/unicodedata.html\" rel=\"nofollow\"><em>The Python Standard Library</em>, Section 6.5 \"unicodedata \u2014 Unicode Database\"</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Unicode_equivalence\" rel=\"nofollow\">\"Unicode Equivalence\" in <em>Wikipedia</em></a></li>\n</ul>\n<p>Basic usage of <code>textnorm.normalize_unicode</code> looks like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">textnorm</span> <span class=\"kn\">import</span> <span class=\"n\">normalize_unicode</span>\n<span class=\"n\">s_nfc</span> <span class=\"o\">=</span> <span class=\"s1\">'\u03bc</span><span class=\"se\">\\u03ad</span><span class=\"s1\">\u03b3\u03b1 \u03b2\u03b9\u03b2\u03bb</span><span class=\"se\">\\u03af</span><span class=\"s1\">\u03bf\u03bd \u03bc</span><span class=\"se\">\\u03ad</span><span class=\"s1\">\u03b3\u03b1 \u03ba\u03b1\u03ba</span><span class=\"se\">\\u03cc</span><span class=\"s1\">\u03bd'</span>  <span class=\"c1\"># NB: \"composed\" forms of accented characters </span>\n<span class=\"n\">n_nfd</span> <span class=\"o\">=</span> <span class=\"n\">normalize_unicode</span><span class=\"p\">(</span><span class=\"n\">s_nfc</span><span class=\"p\">,</span> <span class=\"s1\">'NFD'</span><span class=\"p\">)</span>\n<span class=\"n\">n_nfc</span> <span class=\"o\">=</span> <span class=\"n\">normalize_unicode</span><span class=\"p\">(</span><span class=\"n\">n_nfd</span><span class=\"p\">,</span> <span class=\"s1\">'NFC'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">s_nfc</span> <span class=\"o\">==</span> <span class=\"n\">n_nfd</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">s_nfc</span> <span class=\"o\">==</span> <span class=\"n\">n_nfc</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'original NFC: \"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">s_nfc</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'normalized NFD: \"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">n_nfd</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'round-tripped NFC: \"</span><span class=\"si\">{}</span><span class=\"s1\">\"'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">n_nfc</span><span class=\"p\">))</span>\n</pre>\n<p>which produces output like this:</p>\n<pre><code>False\nTrue\noriginal NFC: \"\u03bc\u03ad\u03b3\u03b1 \u03b2\u03b9\u03b2\u03bb\u03af\u03bf\u03bd \u03bc\u03ad\u03b3\u03b1 \u03ba\u03b1\u03ba\u03cc\u03bd\"\nnormalized NFD: \"\u03bc\u03b5\u0301\u03b3\u03b1 \u03b2\u03b9\u03b2\u03bb\u03b9\u0301\u03bf\u03bd \u03bc\u03b5\u0301\u03b3\u03b1 \u03ba\u03b1\u03ba\u03bf\u0301\u03bd\"\nround-tripped NFC: \"\u03bc\u03ad\u03b3\u03b1 \u03b2\u03b9\u03b2\u03bb\u03af\u03bf\u03bd \u03bc\u03ad\u03b3\u03b1 \u03ba\u03b1\u03ba\u03cc\u03bd\"\n</code></pre>\n<p>Even though modern software and fonts are pretty good and making the NFC and NFC forms appear identical, if you examine the underlying encoding you can see that the differences are real.</p>\n<h3>added functionality: compatibility checking</h3>\n<p>Over and above the functionality provided by unicodedata.normalize, textnorm.normalize_unicode has a <code>check_compatible</code> argument that, if <code>True</code>, triggers a comparison of the targeted normalization form with the corresponding \"compatibility\" form (i.e., it compares 'NFC' with 'NFKC' and 'NFD' with 'NFKD'). If the \"canonical\" and \"compatibility\" forms differ, the function raises <code>ValueError</code> with a diagnostic message. A calling program that traps for this exception can then implement double-checking or supervision.</p>\n<p>The lunate sigma ('\u03f9' == '\\u03f9') provides a good way to demonstrate this behavior since the canonical forms (NFC and NFD) preserve the character, but the \"compatibility\" forms (NFKC and NFKD) convert it to conventional sigma ('\u03a3' == '\\u03a3'). First, we'll conduct the conversion without a test:</p>\n<pre><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\u03f9</span><span class=\"s1\">\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75'</span>  <span class=\"c1\"># i.e. \u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75</span>\n<span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">normalize_unicode</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"s1\">'NFKC'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>and we get</p>\n<pre><code>\u03a3\u03c5\u03c1\u03b2\u03b1\u03bd\u03ae\n</code></pre>\n<p>But, if we activate the test:</p>\n<pre><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\u03f9</span><span class=\"s1\">\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75'</span>  <span class=\"c1\"># i.e. \u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75</span>\n<span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">normalize_unicode</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"s1\">'NFKC'</span><span class=\"p\">,</span> <span class=\"n\">check_compatible</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>we'll be treated to the informative traceback:</p>\n<pre><code>Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/Users/paregorios/Documents/files/T/textnorm/textnorm/__init__.py\", line 93, in normalize_unicode\n    raise ValueError(msg)\nValueError: Unicode normalization may have changed the string \"\u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u1f75\" in an undesireable way or may have failed to do so in a manner desired. The NFKC normalized form \"\u03a3\u03c5\u03c1\u03b2\u03b1\u03bd\u03ae\" (b'\\\\N{GREEK CAPITAL LETTER SIGMA}\\\\N{GREEK SMALL LETTER UPSILON}\\\\N{GREEK SMALL LETTER RHO}\\\\N{GREEK SMALL LETTER BETA}\\\\N{GREEK SMALL LETTER ALPHA}\\\\N{GREEK SMALL LETTER NU}\\\\N{GREEK SMALL LETTER ETA WITH TONOS}') does not match the corresponding NFC form \"\u03f9\u03c5\u03c1\u03b2\u03b1\u03bd\u03ae\" (b'\\\\N{GREEK CAPITAL LUNATE SIGMA SYMBOL}\\\\N{GREEK SMALL LETTER UPSILON}\\\\N{GREEK SMALL LETTER RHO}\\\\N{GREEK SMALL LETTER BETA}\\\\N{GREEK SMALL LETTER ALPHA}\\\\N{GREEK SMALL LETTER NU}\\\\N{GREEK SMALL LETTER ETA WITH TONOS}').\n</code></pre>\n<h2>etc</h2>\n<p>Pull requests and new tickets on the issue tracker are welcome.</p>\n<p><em>This README has been created with thanks and apologies to <a href=\"https://www.poets.org\" rel=\"nofollow\">https://www.poets.org</a> and to the ghosts of Robert Burns and Edward Lear.</em></p>\n\n          </div>"}, "last_serial": 7186884, "releases": {"1.1": [{"comment_text": "", "digests": {"md5": "84bdef04664e381ee9b34fc6d07c585d", "sha256": "47449c6f8048e5b47d2343a1bb46d10a15d3745f9041b531ba48098e42f785dd"}, "downloads": -1, "filename": "textnorm-1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "84bdef04664e381ee9b34fc6d07c585d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17471, "upload_time": "2020-05-05T08:43:04", "upload_time_iso_8601": "2020-05-05T08:43:04.622174Z", "url": "https://files.pythonhosted.org/packages/28/d5/68cea48fefe3d011d9f682ff22d5263c009324077f2b0967363262538026/textnorm-1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ed70f7f9c836c7db0fcc1840f2ed60c0", "sha256": "e0150820c9773f4aa269fa6419fc5c79c11e225bab365ae5c1f910b3e3981749"}, "downloads": -1, "filename": "textnorm-1.1.tar.gz", "has_sig": false, "md5_digest": "ed70f7f9c836c7db0fcc1840f2ed60c0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19013, "upload_time": "2020-05-05T08:43:06", "upload_time_iso_8601": "2020-05-05T08:43:06.658436Z", "url": "https://files.pythonhosted.org/packages/45/4c/96b94f9122276b4004e6d61921445d45c1f983aa9d92075331fec9ae4b78/textnorm-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "7f2fea6afb51b762f7c374d85a57934d", "sha256": "b826ef97e9f631158d71ef4e24ca25e3a85ac62043e1819f069adbfc68f15995"}, "downloads": -1, "filename": "textnorm-1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "7f2fea6afb51b762f7c374d85a57934d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17529, "upload_time": "2020-05-07T09:34:04", "upload_time_iso_8601": "2020-05-07T09:34:04.371482Z", "url": "https://files.pythonhosted.org/packages/b0/4e/0fc054e1e9c6d563fd72151427ee4dd37ed5913ca2deb9087f0978f6d472/textnorm-1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f05497c9acc35b0c914bc038c7f8bfb4", "sha256": "c04b398d137a6909e4d7f39ee6935d027927b40d083ef11d1f1209f2793662b1"}, "downloads": -1, "filename": "textnorm-1.2.tar.gz", "has_sig": false, "md5_digest": "f05497c9acc35b0c914bc038c7f8bfb4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19072, "upload_time": "2020-05-07T09:34:06", "upload_time_iso_8601": "2020-05-07T09:34:06.522935Z", "url": "https://files.pythonhosted.org/packages/b6/1b/0bd32ea2e1dbd6aae113ea7fb6a38454dbb0267d12b25316b241171b1141/textnorm-1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7f2fea6afb51b762f7c374d85a57934d", "sha256": "b826ef97e9f631158d71ef4e24ca25e3a85ac62043e1819f069adbfc68f15995"}, "downloads": -1, "filename": "textnorm-1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "7f2fea6afb51b762f7c374d85a57934d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17529, "upload_time": "2020-05-07T09:34:04", "upload_time_iso_8601": "2020-05-07T09:34:04.371482Z", "url": "https://files.pythonhosted.org/packages/b0/4e/0fc054e1e9c6d563fd72151427ee4dd37ed5913ca2deb9087f0978f6d472/textnorm-1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f05497c9acc35b0c914bc038c7f8bfb4", "sha256": "c04b398d137a6909e4d7f39ee6935d027927b40d083ef11d1f1209f2793662b1"}, "downloads": -1, "filename": "textnorm-1.2.tar.gz", "has_sig": false, "md5_digest": "f05497c9acc35b0c914bc038c7f8bfb4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19072, "upload_time": "2020-05-07T09:34:06", "upload_time_iso_8601": "2020-05-07T09:34:06.522935Z", "url": "https://files.pythonhosted.org/packages/b6/1b/0bd32ea2e1dbd6aae113ea7fb6a38454dbb0267d12b25316b241171b1141/textnorm-1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:55:00 2020"}