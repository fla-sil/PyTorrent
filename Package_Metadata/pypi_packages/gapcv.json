{"info": {"author": "Andrew Ferlitsch", "author_email": "aferlitsch@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: Apache Software License", "Operating System :: MacOS", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.0", "Programming Language :: Python :: 3.1", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Image Recognition"], "description": "# Gap CV\n\n  ![gap](docs/img/gap.png)\n\n## Intro\n\n**Gap** is a data engineering framework for machine learning. The **GapCV** is a component of **Gap** for computer vision (CV). The component manages data preparation of images, feeding and serving neural network models, and data management of persistent storage.\n\nThe module is written in a modern *object oriented programming (OOP)* abstraction with an *imperative programming* style that fits seamlessly into ML frameworks which are moving into imperative programming, such as **Keras** and **PyTorch**. The bottom layers of the module are written in a *bare metal* style for high performance.\n\n**Gap** was inspired by a meeting of data scientists and machine learning enthusiasts in Portland, OR in May 2018. The first version of **Gap** was available during the summer and the local software community was engaged through meetups, chats, Kaggle groups, and a conference at the Oxford Suites. During the Fall, a decision was made to refactor **Gap** into an industrial grade application, spearheaded by Gap's lead, David Molina, and overseen and assisted by Andrew Ferlitsch, Google AI. \n\n## Why and Why Now\n\nDuring the Spring of 2018, many of us had observed advancements in redesign of ML frameworks (such as **Keras** and **PyTorch**) to migrate into frameworks which would have broader adoption in the software engineering community. But, the focus was primarily on the model building and not on the data engineering. Across the Internet, between blogs, tutorials and online classes, the examples for data engineering was still a wild west. To us, we saw this as a gap, and hence the name **Gap**.\n\nML practitioners today recognize the substantial component that data engineering is within the machine learning ecosystem, and the need to modernize, streamline and standardize to meet the needs of the software development community at the same pace as framework advancements are being made on the modeling components.\n\n  ![MLEcoSystem](docs/img/MLEcoSystem.png)\n\n## Summary of Features\n\n### Image Types\n\nThe following image formats are supported: \n\n    * JPEG and JPEG2000\n    * PNG\n    * TIF\n    * GIF\n    * BMP\n    * 8 and 16 bits per pixel\n    * Grayscale (single channel), RGB (three channels) and RGBA (four channels)\n    \n### Image Set (Dataset) Layouts\n\nThe following image dataset layouts are supported (i.e., can be ingested by **Gap**):  \n\n    * On-Disk (directory, CSV and JSON)\n    * In-Memory (list, numpy)\n    * Remote (http)\n    \nFor CSV and JSON, the image data can be embedded (in-memory), local (on-disk) or URL paths (remote).\n\n### Image Transformations\n\nThe following image transformations are supported: \n\n    * Color -> Gray\n    * Resizing\n    * Flattening\n    * Normalization and Standardization\n    * Data Type Conversion: 8 and 16 bpp integer and 16, 32 and 64 bpp float\n    \nTransformations can be performed when processing an image dataset (ingestion) or performed dynamically in-place when feeding (training) a neural network.\n\n### Image Augmentation\n\nThe following image augmentations are supported:\n\n    * Rotation\n    * Horizontal and Vertical Flip\n    * Zoom\n    * Brightening\n    * Sharpening\n    \nImage augmentation can be performed dynamically in-place during feeding (training) of a neural network.\n\n### Image Feeding\n\nThe following image feeding mechanisms are supported:\n\n    * Splitting \n    * Shuffling\n    * Iterative\n    * Generative\n    * Mini-batch\n    * Stratification\n    * One-Hot Label Encoding\n    * Streaming\n\nWhen feeding, shuffling is handled using indirect indexing, maintaining the location of data in the heap. One-hot encoding of labels is performed\ndynamically when the feeder is instantiated.\n\n### In-Memory Management\n\nThe following are supported for in-memory management:\n\n    * Contiguous Memory (Numpy)\n    * Streaming\n    * Indirect Indexing (Shuffling w/o moving memory)\n    * Data Type Reduction\n    * Collection Merging\n    * Asynchronous and Concurrent Processing\n    \nCollections of image data, which are otherwise disjoint, can be merged efficiently and with label one-hot encoding performed dynamically for feeding neural networks from otherwise disparate sources.\n\n### Persistent Storage Management\n\nThe following are supported for on-disk management:\n\n    * HDF5 Storage and Indexing\n    * Metadata handling\n    * Distributed\n    \n## Installation\n\n### Pip Installation: \n\nThe **GapCV** framework is supported on Windows, MacOS, and Linux. It has been packaged for distribution via PyPi.\n\n  1. Install [miniconda](https://conda.io/miniconda.html).\n\n  2. Install conda virtual environment and required packages:\n      + Create an environment with: `conda create -n gap python==3.5 jupyter pip`  \n      + Activate: `source activate gap`  \n      + `pip install gapcv`\n\n  3. Exiting conda virtual environment:  \n      + Windows: `deactivate`  \n      + Linux/macOS: `source deactivate`\n\n### Setup.py Installation:\n\nTo install **GapCV** via setup.py:\n\n  1. Clone from the Github repo.  \n      + `git clone https://github.com/gapml/CV.git`\n\n  2. Install using the **GapCV** setup file.  \n      + access folder `cd CV`  \n      + `python setup.py install`\n      \n### Importing GapCV\n\nTo import GapCV into your python application, do:\n\n```python\nfrom gapcv.vision import Images\n```\n\n## Quick Start\n\nImage preparation, neural network feeding and management of image datasets is handled through the class object `Images`. We will provide here a brief discussion on the\nvarious ways of using the `Images` class.\n\nThe initializer has no required (positional) parameters. All the parameters are optional (keyword) parameters. The most frequently used parameters are:\n\n        Images( name, dataset, labels, config ) \n        \n            name   : the name of the dataset (e.g., 'cats_n_dogs')\n            dataset: the dataset of images\n            labels : the labels\n            config : configuration settings\n\n### Preparing Datasets\n\nThe first step is to transform the images in an image dataset into machine learning ready data. How the images are transformed is dependent on the image source and the configuration settings. By default, all images are transformed to:\n\n        1. RGB image format\n        2. Resized to (128, 128)\n        3. Float32 pixel data type\n        4. Normalization\n        \nIn this quick start section, we will briefly cover preparing datasets that are on-disk, or remotely stored, or in-memory.\n \n*Directory*\n\nA common format for image datasets is to stored them on disk in a directory layout. The layout consists of a root (parent) directory and one or more subdirectories. Each subdirectory is a\nclass (label), such as *cats*. Within the subdirectory are one or more images which belong to that class. Below is an example:\n\n                    cats_n_dogs\n                  /             \\  \n                cats            dogs\n                /                  \\\n            c1.jpg ...          d1.jpg ...\n            \nThe following instantiation of the `Images` class object will load the images from local disk into in-memory according to the default transformation settings.  Within memory, the set of transformed images will be grouped into two classes: cats, and dogs.      \n\n```python\nimages = Images(dataset='cats_n_dogs')\n```\n\nOnce loaded, you can get information on the transformed data as properties of the `Images` class. Below are a few frequently used properties.\n\n```python\nprint(images.name)      # will output the name of the dataset: cats_and_dogs\nprint(images.count)     # will output the total number of images in both cats and dogs\nprint(images.classes)   # will output the class to label mapping: { 'cats': 0, 'dogs': 1 }\nprint(images.images[0]) # will output the numpy arrays for each transformed image in the class with label 0 (cats).\nprint(images.labels[0]) # will output the label for each transformed image in the class with label 0 (cats).\n```\n\nSeveral of the builtin functions have been overridden for the `Images` class. Below are a few frequently used overridden builtin functions:\n\n```python\nprint(len(images))      # number of collections (classes)\nprint(images[0])        # same as images.images[0]\n```\n\n*List*\n\nAlternatively, local on-disk images may be specified as a list of paths, with corresponding list of labels. Below is an example where the `dataset` parameter is specified as a list of\npaths to images, and the `labels` parameter is a list of corresponding labels.\n\n```python\nimages = Images(name='cats_and_dogs', dataset=['cats/1.jpg', 'cats/2.jpg', ... 'dogs/1.jpg'], labels=[0, 0, ... 1])\n```\n\nAlternately, the image paths may be specified as remote locations using URL paths. In this case, a HTTP request will be made to fetch the contents of the image from the remote site.\n\n```python\nimages = Images(name='cats_and_dogs', dataset=['http://mysite.com/cats/1.jpg', 'http://mysite.com/cats/2.jpg', ... ], labels=[0, 0, ...])\n```\n\n*Memory*\n\nIf the dataset is already in memory, for example a curated dataset that is part of a framework (e.g., CIFAR-10 in **Keras**), the in-memory multi-dimensional numpy arrays for the curated images and labels are passed as the values to the `dataset` and `labels` parameter.\n\n```python\nfrom keras.datasets import cifar10\n\n(x_train, y_train), (x_test, y_test) = cifar10.load_data()\n\ntrain = Images('cifar10', dataset=x_train, labels=y_train)\ntest  = Images('cifar10', dataset=x_test,  labels=y_test)\n```\n\n*CSV*\n\nA dataset can be specified as a CSV (comma separated values) file. Both US (comma) and EU (semi-colon) standard for separators are supported. Each row in the CSV file corresponds to an image\nand corresponding label. The image may be local on-disk, remote or embedded. Below are some example CSV layouts:\n\n        *local on-disk*\n            label,image\n            'cat','cats/c1.jpg'\n            'dog','dogs/d1.jpg'\n            ...\n            \n        *remote*\n            label,image\n            'cat','http://mysite.com/c1.jpg'\n            'dog','http://mysite.com/d1.jpg'\n            ...\n            \n        *embedded pixel data*\n            label,name\n            'cat','[ embedded pixel data ]'\n            'dog','[ embedded pixel data ]'\n            \nFor CSV, the `config` parameter is specified when instantiating the `Images` class object, to set the settings for:\n\n        header      # if present, CSV file has a header; otherwise it does not.\n        image_col   # the column index (starting at 0) of the image field.\n        label_col   # the column index (starting at 0) of the label field.\n        \n```python\nimages = Images(dataset='cats_n_dogs.csv', config=['header', 'image_col=0', 'label_col=1'])\n```\n\nFor EU style (semi-colon) use the `sep` setting to specify the separator is a semi-colon:\n\n```python\nimages = Images(dataset='cats_n_dogs.csv', config=['header', 'image_col=0', 'label_col=1', 'sep=;'])\n```\n\n*JSON*\n\nA dataset can be specified as a JSON (Javascript Object Notation) file, where the file is laid out as an array of objects. Each object corresponds to an image and corresponding label. \nThe image may be local on-disk, remote or embedded. Below are some example JSON layouts:\n\n    *local on-disk*\n        [\n            {'label': 'cat', 'image': 'cats/c1.jpg'},\n            {'label': 'dog', 'image': 'dogs/d1.jpg'},\n            ...\n        ]\n        \n    *remote*\n        [\n            {'label': 'cat', 'image': 'http://mysite.com/c1.jpg'},\n            {'label': 'dog', 'image': 'http://mystire.com/d1.jpg'},\n            ...\n        ]\n            \n    *embedded pixel data*\n        [\n            {'label': 'cat', 'image': [ embedded pixel data ]},\n            {'label': 'dog', 'image': [ embedded pixel data ]},\n            ...\n        ]\n            \nFor JSON, the `config` parameter is specified when instantiating the `Images` class object, to set the settings for:\n\n        image_key   # the key name of the image field.\n        label_key   # the key name of the label field.\n        \n```python\nimages = Images(dataset='cats_n_dogs.json', config=['image_key=image', 'label_key=label'])\n```\n\n*Transformations*\n\nThe default settings of the image transformations can be overridden as `settings` to the `config` parameter:\n\n        gray            : process as 2D (single channel) gray scale images\n        flatten         : process as flatten 1D images (for DNN)\n        resize=(h,w)    : resize to a specific height x weight (e.g., (28,28))\n        norm=pos|neg|std: normalize between 0 and 1 (pos), normalize between -1 and 1 (neg), or standardize.\n        float16|float32 : pixel data type\n        uint8|uint16    : pixel data type\n        \nFor example, if the target neural network is a DNN and the input is a flattened gray scale 28x28 vector (e.g., mnist), one would specify:\n        \n```python\nimages = Images(name='mnist', ..., config=[resize=(28,28), 'gray', 'flatten'])\n```\n\nIf the pixel data is to be standardized instead of normalized, one would specify:\n\n```python\nimages = Images(..., config=['norm=std'])\n```\n\nIf your hardware supports half precision floats (16-bit float) and your neural network is designed to not be effected by a vanishing gradient, you can reduce the in-memory size of the\nthe transformed image data by 50% by setting the pixel data type to `float16`.\n\n```python\nimages = Images(..., config=['float16'])\n```\n\nIn another example, you can do a space vs. speed tradeoff. The pixel data type can be set to `uint8` (8-bit integer). In this case, pixel normalization is deferred and performed dynamically \neach time the image is feed to the neural network. The in-memory size of the image data will be 75% smaller than the corresponding `float32` version, or 50% smaller than the corresponding\n`float16` version.\n\n```python\nimages = Images(..., config=['uint8'])\n```\n\n### Feeding Datasets\n\nThe `Images` class provides severals setter/getter properties for feeding a neural network during training. By default, the transformed (machine learning ready) image data is split into\n80% training and 20% test. Prior to splitting, the image data is randomly shuffled. Alternately, one can specify a different percentage for test and a seed for the random shuffle with the\n`split` property used as a setter.\n\n```python\n# some instantiation of an image dataset\nimages = Images(...)\n\n# set 10% as test and shuffle with random seed set to 112\nimages.split = 0.1, 112\n```\n\n*Pre-split Dataset*\n\nThe `split` property when used as a getter will return a pre-split dataset (train and test) of images and corresponding labels (in a fashion familiar to sci-learn train_test_split()). \nThe training data will have been randomly shuffled prior to the split. The image portion (X_train and X_test) is a multi-dimensional numpy array, and the label portion (Y_train and Y_test)\nis a numpy matrix which has been one-hot encoded.\n\n```python\nX_train, X_test, Y_train, Y_test = images.split\n\nprint(X_train.shape)    # would output something like (10000, 128, 128, 3)\nprint(Y_train.shape)    # would output something like (10000, 10)\n```\n\nIf the pixel data type is uint8 (or uint16), the pixel data will be normalized prior to returning the training and test data.\n\n*Iterative*\n\nThe `next()` operator is overridden to act as a iterator for feeding a neural network. Each invocation of `next()` will return the next image and label in the training set. Once all\nthe image data has been enumerated (i.e., epoch), the` next()` operator will return `None` and randomly reshuffle the training data for the next epoch. The image and label data are returned\nas a multi-dimensional numpy array and one-hot encoded numpy vector, respectively.\n\n```python\nfor _ in range(epochs):\n    # pass thru all the training data for an epoch\n    while True:\n        image, label = next(images)\n        if not images:\n            break\n```\n\nIf the pixel data type is uint8 (or uint16), the pixel data will be normalized dynamically per invocation of the `next()` operator.\n\nIf the `config` setting `stream` is specified, the pixel data is streamed (memory-less) in from the HDF5 storage on each invocation of the `next()` operator.\n\n*Mini-batch (Generative)*\n\nThe `minibatch` property when used as a setter will set the mini-batch size for creating a generator for feeding the neural network in mini-batches. By default, the mini-batch size is 32.\n\n```python\n# set the mini-batch size to 64\nimages.minibatch = 64\n```\n\nThe `minibatch` property when used as a getter creates a generator on each invocation. The generator will return a sequence of images and labels, whose size is specified as the parameter\n(or default) to `minibatch` when specified as a setter. Each iteration of the generator will sequentially move through the training data. When the end of the training data is reached, the\ntraining data is randomly reshuffled and the `minibatch` getter is reset to start at the beginning of the training data. The image and label data are returned\nas a multi-dimensional numpy array and one-hot encoded numpy vector, respectively.\n\n```python\n# create the generator\ng = images.minibatch\n# feed in steps number of mini-batches\nfor _ in range(steps):\n    x_batch, y_batch = g\n```\n\nIf the pixel data type is uint8 (or uint16), the pixel data will be normalized dynamically per creation of a mini-batch generator.\n\nIf the `config` setting `stream` is specified, each batch of pixel data is streamed (memory-less) in from the HDF5 storage per invocation of the `minibatch` property when used as a getter.\n\n*Stratified mini-batch*\n\nThe `stratified` property when used as a setter will set the mini-batch size for creating a generator for feeding the neural network in stratified mini-batches. By default, the mini-batch size is 32. A min-batch is stratified when their is a even distribution of classes within the batch.\n\n```python\n# set the stratified mini-batch size to 64\nimages.stratify = 64\n```\n\nThe `stratify` property when used as a getter creates a generator on each invocation. The generator will return a sequence of images and labels, whose size is specified as the parameter\n(or default) to `stratify` when specified as a setter. Each creation of the generator will sequentially move through the training data. When the end of the training data is reached, the\ntraining data is randomly reshuffled and the 'stratify` getter is reset to start at the beginning of the training data. The image and label data are returned\nas a multi-dimensional numpy array and one-hot encoded numpy vector, respectively.\n\n```python\n# create the generator\ng = images.stratify\n# feed in steps number of stratified mini-batches\nfor _ in range(steps):\n    x_batch, y_batch = g\n```\n\nIf the pixel data type is uint8 (or uint16), the pixel data will be normalized dynamically per creation of a stratified mini-batch generator..\n\nIf the `config` setting `stream` is specified, each batch of pixel data is streamed (memory-less) in from the HDF5 storage per invocation of the `minibatch` property when used as a getter.\n\n\n### Image Augmentation\n\nImage augmentation (synthesis of new images) occurs dynamically in-place when feeding a neural network, and is initiated through the parameter `augment` when instantiating an\n`Images` class object. The settings for the `augment` parameter are:\n\n        rotate=min,max                  : random rotation of image within range min and max.\n        zoom=factor                     : zoom factor of n (i.e., 1.5 = 150%).\n        flip=horizontal|vertical|both   : flip image on horizontal, vertical or both axes.\n        brightness=factor               : brighten image by factor\n        contrast=factor                 : contrast image by factor\n        edge                            : sharpen the image\n        denoise                         : apply de-noising filter\n        \nBelow is an example of specifying image augmentation during feeding of a neural network:\n\n```python\nimages = Images(..., augment=['rotate=-90,90', 'flip=vertical'])\n```\n\nImage augmentation occurs dynamically during feeding. For each image feed, a second augmented image will follow. For example, if the training set is 1000 images, the next() operator will\nfeed 2000 images per epoch. If the mini-batch or stratify size is set to 32, the corresponding generators will feed 64 images. If multiple image augmentation settings are specified, a \nrandom selection is made of the type of augmentation per image. For example, if one specifies rotation, zoom and horizontal flip, then each time an image is augmented a random choice is\nmade between the three.\n\n### Managing Datasets (Persistent Storage)\n\nImage datasets which have been transformed into machine learning ready data can be stored and managed in persistent storage, using the HDF5 filesystem format. The following can be done:\n\n    1. Save transformed images into storage (bulk or streamed).\n    2. Load transformed images from storage (bulk or streamed).\n    3. Apply new transformations (e.g., convert to gray scale, flatten, change size, etc).\n    4. Combine collections (classes) of images.\n    \n*Save to Persistent Storage*\n\nA transformed image dataset (i.e., collection) can be saved to, and subsequently retrieved from, persistent storage with the `config` setting `store`. When specified, the transformed\n(machine learning ready data) image dataset, along with associated metadata, is stored to HDF5 storage. Within the HDF5 storage, each class (label) of data is compacted and indexed into a contiguous volume within the HDF5 storage for subsequent fast retrieval.\n\n```python\n# store the transformed image dataset into HDF5 storage\nimages = Images(..., config=['store'])\n```\n\nIf the image dataset is too large to hold the entire dataset in memory, the images can alternatively be processed one at a time and streamed into the HDF5 storage. In this mode, the\nprocess only consumes memory resources for a single image. The stream mode is invoked when the `config` setting `stream` is specified.\n\n```python\n# stream (store) the transformed image dataset into HDF5 storage\nimages = Images(..., config=['stream'])\n```\n\n*Load from Persistent Storage*\n\nThe `load()` method of the `Images` class will retrieve (load) a collection of transformed (machine learning ready data) images, and associated metadata, from persistent storage. Once loaded, the collection can then be feed to a neural network for training.\n\n```python\n# load a previously preprocessed collection of images entirely in-memory\nimages = Images()\nimages.load('cats_n_dogs')\n\n# feed into a neural network\nimages.split = 0.1, 112\nX_train, X_test, Y_train, Y_test = images.split\n\n# alternately, stream a previously preprocessed collection of images\nimages = Images(config=['stream'])\nimages.load('cats_n_dogs')\n\n# feed (streaming) into a neural network\nimages.minibatch = 32\ng = images.minibatch\nfor step in range(steps):\n    x_batch, y_batch = g\n```\n\n*Apply Transforms*\n\nAfter a transformed image dataset has been loaded from persistent storage, one can further re-transform the dataset to match the input requirements of another neural network, without reprocessing the original image data. The re-transforms are supported as setter properties of the `Images` class:\n\n    - `gray`   : Converting to Grayscale\n    - 'flatten`: Flattening\n    - 'resize` : Resizing\n    \n```python\n# load a previously preprocessed collection of images\nimages.load('cats_n_dogs')\n# resize the transformed images to 96 x 96 (height vs. width)\nimages.resize = (96, 96)\n```\n    \n*Combining Collections*\n\nExisting collections in persistent storage can be combined into a single new collection using the overridden `+=` operator. When combined, the label assignment is reassigned. For example,\nif both collections are a single class with both having the respective value 0 for the class, in the combined version, one class will be 0 and the other 1.\n\n```python\ncats = Images(name='cats', dataset=..., ...)\nprint(cats.class)   # will output: {'cats': 0}\n\ndogs = Images(name='dogs', dataset=..., ...)\nprint(dogs.class)   # will output: {'dogs': 0}\n\ncats += dogs\nprint(cats.class)   # will output: {'cats': 0, 'dogs': 1}\n```\n\n## Reference\n\n## Testing\n\nThe **Gap** framework is developed using Test Driven Development methodology. The automated unit tests for the framework use pytest, which is a xUnit style form of testing (e.g., jUnit, nUnit, jsUnit, etc).\n\n#### Installation and Documentation\n\nThe pytest application can be installed using pip:\n\n    pip install pytest\n\nOnline documentation for [pytest](https://docs.pytest.org)\n\n#### Execution\n\nThe following are the pre-built automated unit tests, which are located under the subdirectory tests:\n\n    image_test.py       # Tests the Image and Images Class in the Vision Module\n\nThe automated tests are executed as follows:\n  \n  1. From directory root enter `cd tests`\n\n  2. Tests can be run by:\n\n    pytest -v image_test.py\n\n#### Code Coverage\n\nInformation on the percent of code that is covered (and what source lines not covered) by the automated tests is obtained using pytest-cov. This version of pytest is installed using pip:\n\n    pip install pytest-cov\n\n  1. From directory root enter `cd tests`\n\n  2. To run tests with coverage: \n\n    pytest --cov=gapcv.vision image_test.py\n\n        Statements=1364, Missed=59, Percent Covered: 96%", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/gapml/CV", "keywords": "", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "gapcv", "package_url": "https://pypi.org/project/gapcv/", "platform": "", "project_url": "https://pypi.org/project/gapcv/", "project_urls": {"Documentation": "https://gapml.github.io/CV/", "Homepage": "https://github.com/gapml/CV", "Source Code": "https://github.com/gapml/CV"}, "release_url": "https://pypi.org/project/gapcv/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "CV Data Engineering Framework", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Gap CV</h1>\n<p><img alt=\"gap\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/01d34a1d629507ac962d83c69326df564e3b73c1/646f63732f696d672f6761702e706e67\"></p>\n<h2>Intro</h2>\n<p><strong>Gap</strong> is a data engineering framework for machine learning. The <strong>GapCV</strong> is a component of <strong>Gap</strong> for computer vision (CV). The component manages data preparation of images, feeding and serving neural network models, and data management of persistent storage.</p>\n<p>The module is written in a modern <em>object oriented programming (OOP)</em> abstraction with an <em>imperative programming</em> style that fits seamlessly into ML frameworks which are moving into imperative programming, such as <strong>Keras</strong> and <strong>PyTorch</strong>. The bottom layers of the module are written in a <em>bare metal</em> style for high performance.</p>\n<p><strong>Gap</strong> was inspired by a meeting of data scientists and machine learning enthusiasts in Portland, OR in May 2018. The first version of <strong>Gap</strong> was available during the summer and the local software community was engaged through meetups, chats, Kaggle groups, and a conference at the Oxford Suites. During the Fall, a decision was made to refactor <strong>Gap</strong> into an industrial grade application, spearheaded by Gap's lead, David Molina, and overseen and assisted by Andrew Ferlitsch, Google AI.</p>\n<h2>Why and Why Now</h2>\n<p>During the Spring of 2018, many of us had observed advancements in redesign of ML frameworks (such as <strong>Keras</strong> and <strong>PyTorch</strong>) to migrate into frameworks which would have broader adoption in the software engineering community. But, the focus was primarily on the model building and not on the data engineering. Across the Internet, between blogs, tutorials and online classes, the examples for data engineering was still a wild west. To us, we saw this as a gap, and hence the name <strong>Gap</strong>.</p>\n<p>ML practitioners today recognize the substantial component that data engineering is within the machine learning ecosystem, and the need to modernize, streamline and standardize to meet the needs of the software development community at the same pace as framework advancements are being made on the modeling components.</p>\n<p><img alt=\"MLEcoSystem\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/eaecd6f086a0f231976f03c4f2c28599501f1904/646f63732f696d672f4d4c45636f53797374656d2e706e67\"></p>\n<h2>Summary of Features</h2>\n<h3>Image Types</h3>\n<p>The following image formats are supported:</p>\n<pre><code>* JPEG and JPEG2000\n* PNG\n* TIF\n* GIF\n* BMP\n* 8 and 16 bits per pixel\n* Grayscale (single channel), RGB (three channels) and RGBA (four channels)\n</code></pre>\n<h3>Image Set (Dataset) Layouts</h3>\n<p>The following image dataset layouts are supported (i.e., can be ingested by <strong>Gap</strong>):</p>\n<pre><code>* On-Disk (directory, CSV and JSON)\n* In-Memory (list, numpy)\n* Remote (http)\n</code></pre>\n<p>For CSV and JSON, the image data can be embedded (in-memory), local (on-disk) or URL paths (remote).</p>\n<h3>Image Transformations</h3>\n<p>The following image transformations are supported:</p>\n<pre><code>* Color -&gt; Gray\n* Resizing\n* Flattening\n* Normalization and Standardization\n* Data Type Conversion: 8 and 16 bpp integer and 16, 32 and 64 bpp float\n</code></pre>\n<p>Transformations can be performed when processing an image dataset (ingestion) or performed dynamically in-place when feeding (training) a neural network.</p>\n<h3>Image Augmentation</h3>\n<p>The following image augmentations are supported:</p>\n<pre><code>* Rotation\n* Horizontal and Vertical Flip\n* Zoom\n* Brightening\n* Sharpening\n</code></pre>\n<p>Image augmentation can be performed dynamically in-place during feeding (training) of a neural network.</p>\n<h3>Image Feeding</h3>\n<p>The following image feeding mechanisms are supported:</p>\n<pre><code>* Splitting \n* Shuffling\n* Iterative\n* Generative\n* Mini-batch\n* Stratification\n* One-Hot Label Encoding\n* Streaming\n</code></pre>\n<p>When feeding, shuffling is handled using indirect indexing, maintaining the location of data in the heap. One-hot encoding of labels is performed\ndynamically when the feeder is instantiated.</p>\n<h3>In-Memory Management</h3>\n<p>The following are supported for in-memory management:</p>\n<pre><code>* Contiguous Memory (Numpy)\n* Streaming\n* Indirect Indexing (Shuffling w/o moving memory)\n* Data Type Reduction\n* Collection Merging\n* Asynchronous and Concurrent Processing\n</code></pre>\n<p>Collections of image data, which are otherwise disjoint, can be merged efficiently and with label one-hot encoding performed dynamically for feeding neural networks from otherwise disparate sources.</p>\n<h3>Persistent Storage Management</h3>\n<p>The following are supported for on-disk management:</p>\n<pre><code>* HDF5 Storage and Indexing\n* Metadata handling\n* Distributed\n</code></pre>\n<h2>Installation</h2>\n<h3>Pip Installation:</h3>\n<p>The <strong>GapCV</strong> framework is supported on Windows, MacOS, and Linux. It has been packaged for distribution via PyPi.</p>\n<ol>\n<li>\n<p>Install <a href=\"https://conda.io/miniconda.html\" rel=\"nofollow\">miniconda</a>.</p>\n</li>\n<li>\n<p>Install conda virtual environment and required packages:</p>\n<ul>\n<li>Create an environment with: <code>conda create -n gap python==3.5 jupyter pip</code></li>\n<li>Activate: <code>source activate gap</code></li>\n<li><code>pip install gapcv</code></li>\n</ul>\n</li>\n<li>\n<p>Exiting conda virtual environment:</p>\n<ul>\n<li>Windows: <code>deactivate</code></li>\n<li>Linux/macOS: <code>source deactivate</code></li>\n</ul>\n</li>\n</ol>\n<h3>Setup.py Installation:</h3>\n<p>To install <strong>GapCV</strong> via setup.py:</p>\n<ol>\n<li>\n<p>Clone from the Github repo.</p>\n<ul>\n<li><code>git clone https://github.com/gapml/CV.git</code></li>\n</ul>\n</li>\n<li>\n<p>Install using the <strong>GapCV</strong> setup file.</p>\n<ul>\n<li>access folder <code>cd CV</code></li>\n<li><code>python setup.py install</code></li>\n</ul>\n</li>\n</ol>\n<h3>Importing GapCV</h3>\n<p>To import GapCV into your python application, do:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">gapcv.vision</span> <span class=\"kn\">import</span> <span class=\"n\">Images</span>\n</pre>\n<h2>Quick Start</h2>\n<p>Image preparation, neural network feeding and management of image datasets is handled through the class object <code>Images</code>. We will provide here a brief discussion on the\nvarious ways of using the <code>Images</code> class.</p>\n<p>The initializer has no required (positional) parameters. All the parameters are optional (keyword) parameters. The most frequently used parameters are:</p>\n<pre><code>    Images( name, dataset, labels, config ) \n    \n        name   : the name of the dataset (e.g., 'cats_n_dogs')\n        dataset: the dataset of images\n        labels : the labels\n        config : configuration settings\n</code></pre>\n<h3>Preparing Datasets</h3>\n<p>The first step is to transform the images in an image dataset into machine learning ready data. How the images are transformed is dependent on the image source and the configuration settings. By default, all images are transformed to:</p>\n<pre><code>    1. RGB image format\n    2. Resized to (128, 128)\n    3. Float32 pixel data type\n    4. Normalization\n</code></pre>\n<p>In this quick start section, we will briefly cover preparing datasets that are on-disk, or remotely stored, or in-memory.</p>\n<p><em>Directory</em></p>\n<p>A common format for image datasets is to stored them on disk in a directory layout. The layout consists of a root (parent) directory and one or more subdirectories. Each subdirectory is a\nclass (label), such as <em>cats</em>. Within the subdirectory are one or more images which belong to that class. Below is an example:</p>\n<pre><code>                cats_n_dogs\n              /             \\  \n            cats            dogs\n            /                  \\\n        c1.jpg ...          d1.jpg ...\n</code></pre>\n<p>The following instantiation of the <code>Images</code> class object will load the images from local disk into in-memory according to the default transformation settings.  Within memory, the set of transformed images will be grouped into two classes: cats, and dogs.</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">dataset</span><span class=\"o\">=</span><span class=\"s1\">'cats_n_dogs'</span><span class=\"p\">)</span>\n</pre>\n<p>Once loaded, you can get information on the transformed data as properties of the <code>Images</code> class. Below are a few frequently used properties.</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">)</span>      <span class=\"c1\"># will output the name of the dataset: cats_and_dogs</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">)</span>     <span class=\"c1\"># will output the total number of images in both cats and dogs</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">classes</span><span class=\"p\">)</span>   <span class=\"c1\"># will output the class to label mapping: { 'cats': 0, 'dogs': 1 }</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">images</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"c1\"># will output the numpy arrays for each transformed image in the class with label 0 (cats).</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">labels</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"c1\"># will output the label for each transformed image in the class with label 0 (cats).</span>\n</pre>\n<p>Several of the builtin functions have been overridden for the <code>Images</code> class. Below are a few frequently used overridden builtin functions:</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">images</span><span class=\"p\">))</span>      <span class=\"c1\"># number of collections (classes)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">images</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>        <span class=\"c1\"># same as images.images[0]</span>\n</pre>\n<p><em>List</em></p>\n<p>Alternatively, local on-disk images may be specified as a list of paths, with corresponding list of labels. Below is an example where the <code>dataset</code> parameter is specified as a list of\npaths to images, and the <code>labels</code> parameter is a list of corresponding labels.</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'cats_and_dogs'</span><span class=\"p\">,</span> <span class=\"n\">dataset</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'cats/1.jpg'</span><span class=\"p\">,</span> <span class=\"s1\">'cats/2.jpg'</span><span class=\"p\">,</span> <span class=\"o\">...</span> <span class=\"s1\">'dogs/1.jpg'</span><span class=\"p\">],</span> <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">...</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n</pre>\n<p>Alternately, the image paths may be specified as remote locations using URL paths. In this case, a HTTP request will be made to fetch the contents of the image from the remote site.</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'cats_and_dogs'</span><span class=\"p\">,</span> <span class=\"n\">dataset</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'http://mysite.com/cats/1.jpg'</span><span class=\"p\">,</span> <span class=\"s1\">'http://mysite.com/cats/2.jpg'</span><span class=\"p\">,</span> <span class=\"o\">...</span> <span class=\"p\">],</span> <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">])</span>\n</pre>\n<p><em>Memory</em></p>\n<p>If the dataset is already in memory, for example a curated dataset that is part of a framework (e.g., CIFAR-10 in <strong>Keras</strong>), the in-memory multi-dimensional numpy arrays for the curated images and labels are passed as the values to the <code>dataset</code> and <code>labels</code> parameter.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">keras.datasets</span> <span class=\"kn\">import</span> <span class=\"n\">cifar10</span>\n\n<span class=\"p\">(</span><span class=\"n\">x_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">x_test</span><span class=\"p\">,</span> <span class=\"n\">y_test</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">cifar10</span><span class=\"o\">.</span><span class=\"n\">load_data</span><span class=\"p\">()</span>\n\n<span class=\"n\">train</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"s1\">'cifar10'</span><span class=\"p\">,</span> <span class=\"n\">dataset</span><span class=\"o\">=</span><span class=\"n\">x_train</span><span class=\"p\">,</span> <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"n\">y_train</span><span class=\"p\">)</span>\n<span class=\"n\">test</span>  <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"s1\">'cifar10'</span><span class=\"p\">,</span> <span class=\"n\">dataset</span><span class=\"o\">=</span><span class=\"n\">x_test</span><span class=\"p\">,</span>  <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"n\">y_test</span><span class=\"p\">)</span>\n</pre>\n<p><em>CSV</em></p>\n<p>A dataset can be specified as a CSV (comma separated values) file. Both US (comma) and EU (semi-colon) standard for separators are supported. Each row in the CSV file corresponds to an image\nand corresponding label. The image may be local on-disk, remote or embedded. Below are some example CSV layouts:</p>\n<pre><code>    *local on-disk*\n        label,image\n        'cat','cats/c1.jpg'\n        'dog','dogs/d1.jpg'\n        ...\n        \n    *remote*\n        label,image\n        'cat','http://mysite.com/c1.jpg'\n        'dog','http://mysite.com/d1.jpg'\n        ...\n        \n    *embedded pixel data*\n        label,name\n        'cat','[ embedded pixel data ]'\n        'dog','[ embedded pixel data ]'\n</code></pre>\n<p>For CSV, the <code>config</code> parameter is specified when instantiating the <code>Images</code> class object, to set the settings for:</p>\n<pre><code>    header      # if present, CSV file has a header; otherwise it does not.\n    image_col   # the column index (starting at 0) of the image field.\n    label_col   # the column index (starting at 0) of the label field.\n</code></pre>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">dataset</span><span class=\"o\">=</span><span class=\"s1\">'cats_n_dogs.csv'</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'header'</span><span class=\"p\">,</span> <span class=\"s1\">'image_col=0'</span><span class=\"p\">,</span> <span class=\"s1\">'label_col=1'</span><span class=\"p\">])</span>\n</pre>\n<p>For EU style (semi-colon) use the <code>sep</code> setting to specify the separator is a semi-colon:</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">dataset</span><span class=\"o\">=</span><span class=\"s1\">'cats_n_dogs.csv'</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'header'</span><span class=\"p\">,</span> <span class=\"s1\">'image_col=0'</span><span class=\"p\">,</span> <span class=\"s1\">'label_col=1'</span><span class=\"p\">,</span> <span class=\"s1\">'sep=;'</span><span class=\"p\">])</span>\n</pre>\n<p><em>JSON</em></p>\n<p>A dataset can be specified as a JSON (Javascript Object Notation) file, where the file is laid out as an array of objects. Each object corresponds to an image and corresponding label.\nThe image may be local on-disk, remote or embedded. Below are some example JSON layouts:</p>\n<pre><code>*local on-disk*\n    [\n        {'label': 'cat', 'image': 'cats/c1.jpg'},\n        {'label': 'dog', 'image': 'dogs/d1.jpg'},\n        ...\n    ]\n    \n*remote*\n    [\n        {'label': 'cat', 'image': 'http://mysite.com/c1.jpg'},\n        {'label': 'dog', 'image': 'http://mystire.com/d1.jpg'},\n        ...\n    ]\n        \n*embedded pixel data*\n    [\n        {'label': 'cat', 'image': [ embedded pixel data ]},\n        {'label': 'dog', 'image': [ embedded pixel data ]},\n        ...\n    ]\n</code></pre>\n<p>For JSON, the <code>config</code> parameter is specified when instantiating the <code>Images</code> class object, to set the settings for:</p>\n<pre><code>    image_key   # the key name of the image field.\n    label_key   # the key name of the label field.\n</code></pre>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">dataset</span><span class=\"o\">=</span><span class=\"s1\">'cats_n_dogs.json'</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'image_key=image'</span><span class=\"p\">,</span> <span class=\"s1\">'label_key=label'</span><span class=\"p\">])</span>\n</pre>\n<p><em>Transformations</em></p>\n<p>The default settings of the image transformations can be overridden as <code>settings</code> to the <code>config</code> parameter:</p>\n<pre><code>    gray            : process as 2D (single channel) gray scale images\n    flatten         : process as flatten 1D images (for DNN)\n    resize=(h,w)    : resize to a specific height x weight (e.g., (28,28))\n    norm=pos|neg|std: normalize between 0 and 1 (pos), normalize between -1 and 1 (neg), or standardize.\n    float16|float32 : pixel data type\n    uint8|uint16    : pixel data type\n</code></pre>\n<p>For example, if the target neural network is a DNN and the input is a flattened gray scale 28x28 vector (e.g., mnist), one would specify:</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'mnist'</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">resize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">28</span><span class=\"p\">,</span><span class=\"mi\">28</span><span class=\"p\">),</span> <span class=\"s1\">'gray'</span><span class=\"p\">,</span> <span class=\"s1\">'flatten'</span><span class=\"p\">])</span>\n</pre>\n<p>If the pixel data is to be standardized instead of normalized, one would specify:</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'norm=std'</span><span class=\"p\">])</span>\n</pre>\n<p>If your hardware supports half precision floats (16-bit float) and your neural network is designed to not be effected by a vanishing gradient, you can reduce the in-memory size of the\nthe transformed image data by 50% by setting the pixel data type to <code>float16</code>.</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'float16'</span><span class=\"p\">])</span>\n</pre>\n<p>In another example, you can do a space vs. speed tradeoff. The pixel data type can be set to <code>uint8</code> (8-bit integer). In this case, pixel normalization is deferred and performed dynamically\neach time the image is feed to the neural network. The in-memory size of the image data will be 75% smaller than the corresponding <code>float32</code> version, or 50% smaller than the corresponding\n<code>float16</code> version.</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'uint8'</span><span class=\"p\">])</span>\n</pre>\n<h3>Feeding Datasets</h3>\n<p>The <code>Images</code> class provides severals setter/getter properties for feeding a neural network during training. By default, the transformed (machine learning ready) image data is split into\n80% training and 20% test. Prior to splitting, the image data is randomly shuffled. Alternately, one can specify a different percentage for test and a seed for the random shuffle with the\n<code>split</code> property used as a setter.</p>\n<pre><span class=\"c1\"># some instantiation of an image dataset</span>\n<span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># set 10% as test and shuffle with random seed set to 112</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">split</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mi\">112</span>\n</pre>\n<p><em>Pre-split Dataset</em></p>\n<p>The <code>split</code> property when used as a getter will return a pre-split dataset (train and test) of images and corresponding labels (in a fashion familiar to sci-learn train_test_split()).\nThe training data will have been randomly shuffled prior to the split. The image portion (X_train and X_test) is a multi-dimensional numpy array, and the label portion (Y_train and Y_test)\nis a numpy matrix which has been one-hot encoded.</p>\n<pre><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">X_test</span><span class=\"p\">,</span> <span class=\"n\">Y_train</span><span class=\"p\">,</span> <span class=\"n\">Y_test</span> <span class=\"o\">=</span> <span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">split</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span>    <span class=\"c1\"># would output something like (10000, 128, 128, 3)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">Y_train</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span>    <span class=\"c1\"># would output something like (10000, 10)</span>\n</pre>\n<p>If the pixel data type is uint8 (or uint16), the pixel data will be normalized prior to returning the training and test data.</p>\n<p><em>Iterative</em></p>\n<p>The <code>next()</code> operator is overridden to act as a iterator for feeding a neural network. Each invocation of <code>next()</code> will return the next image and label in the training set. Once all\nthe image data has been enumerated (i.e., epoch), the<code>next()</code> operator will return <code>None</code> and randomly reshuffle the training data for the next epoch. The image and label data are returned\nas a multi-dimensional numpy array and one-hot encoded numpy vector, respectively.</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">epochs</span><span class=\"p\">):</span>\n    <span class=\"c1\"># pass thru all the training data for an epoch</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"n\">label</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">images</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">images</span><span class=\"p\">:</span>\n            <span class=\"k\">break</span>\n</pre>\n<p>If the pixel data type is uint8 (or uint16), the pixel data will be normalized dynamically per invocation of the <code>next()</code> operator.</p>\n<p>If the <code>config</code> setting <code>stream</code> is specified, the pixel data is streamed (memory-less) in from the HDF5 storage on each invocation of the <code>next()</code> operator.</p>\n<p><em>Mini-batch (Generative)</em></p>\n<p>The <code>minibatch</code> property when used as a setter will set the mini-batch size for creating a generator for feeding the neural network in mini-batches. By default, the mini-batch size is 32.</p>\n<pre><span class=\"c1\"># set the mini-batch size to 64</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">minibatch</span> <span class=\"o\">=</span> <span class=\"mi\">64</span>\n</pre>\n<p>The <code>minibatch</code> property when used as a getter creates a generator on each invocation. The generator will return a sequence of images and labels, whose size is specified as the parameter\n(or default) to <code>minibatch</code> when specified as a setter. Each iteration of the generator will sequentially move through the training data. When the end of the training data is reached, the\ntraining data is randomly reshuffled and the <code>minibatch</code> getter is reset to start at the beginning of the training data. The image and label data are returned\nas a multi-dimensional numpy array and one-hot encoded numpy vector, respectively.</p>\n<pre><span class=\"c1\"># create the generator</span>\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">minibatch</span>\n<span class=\"c1\"># feed in steps number of mini-batches</span>\n<span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">steps</span><span class=\"p\">):</span>\n    <span class=\"n\">x_batch</span><span class=\"p\">,</span> <span class=\"n\">y_batch</span> <span class=\"o\">=</span> <span class=\"n\">g</span>\n</pre>\n<p>If the pixel data type is uint8 (or uint16), the pixel data will be normalized dynamically per creation of a mini-batch generator.</p>\n<p>If the <code>config</code> setting <code>stream</code> is specified, each batch of pixel data is streamed (memory-less) in from the HDF5 storage per invocation of the <code>minibatch</code> property when used as a getter.</p>\n<p><em>Stratified mini-batch</em></p>\n<p>The <code>stratified</code> property when used as a setter will set the mini-batch size for creating a generator for feeding the neural network in stratified mini-batches. By default, the mini-batch size is 32. A min-batch is stratified when their is a even distribution of classes within the batch.</p>\n<pre><span class=\"c1\"># set the stratified mini-batch size to 64</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">stratify</span> <span class=\"o\">=</span> <span class=\"mi\">64</span>\n</pre>\n<p>The <code>stratify</code> property when used as a getter creates a generator on each invocation. The generator will return a sequence of images and labels, whose size is specified as the parameter\n(or default) to <code>stratify</code> when specified as a setter. Each creation of the generator will sequentially move through the training data. When the end of the training data is reached, the\ntraining data is randomly reshuffled and the 'stratify` getter is reset to start at the beginning of the training data. The image and label data are returned\nas a multi-dimensional numpy array and one-hot encoded numpy vector, respectively.</p>\n<pre><span class=\"c1\"># create the generator</span>\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">stratify</span>\n<span class=\"c1\"># feed in steps number of stratified mini-batches</span>\n<span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">steps</span><span class=\"p\">):</span>\n    <span class=\"n\">x_batch</span><span class=\"p\">,</span> <span class=\"n\">y_batch</span> <span class=\"o\">=</span> <span class=\"n\">g</span>\n</pre>\n<p>If the pixel data type is uint8 (or uint16), the pixel data will be normalized dynamically per creation of a stratified mini-batch generator..</p>\n<p>If the <code>config</code> setting <code>stream</code> is specified, each batch of pixel data is streamed (memory-less) in from the HDF5 storage per invocation of the <code>minibatch</code> property when used as a getter.</p>\n<h3>Image Augmentation</h3>\n<p>Image augmentation (synthesis of new images) occurs dynamically in-place when feeding a neural network, and is initiated through the parameter <code>augment</code> when instantiating an\n<code>Images</code> class object. The settings for the <code>augment</code> parameter are:</p>\n<pre><code>    rotate=min,max                  : random rotation of image within range min and max.\n    zoom=factor                     : zoom factor of n (i.e., 1.5 = 150%).\n    flip=horizontal|vertical|both   : flip image on horizontal, vertical or both axes.\n    brightness=factor               : brighten image by factor\n    contrast=factor                 : contrast image by factor\n    edge                            : sharpen the image\n    denoise                         : apply de-noising filter\n</code></pre>\n<p>Below is an example of specifying image augmentation during feeding of a neural network:</p>\n<pre><span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">augment</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'rotate=-90,90'</span><span class=\"p\">,</span> <span class=\"s1\">'flip=vertical'</span><span class=\"p\">])</span>\n</pre>\n<p>Image augmentation occurs dynamically during feeding. For each image feed, a second augmented image will follow. For example, if the training set is 1000 images, the next() operator will\nfeed 2000 images per epoch. If the mini-batch or stratify size is set to 32, the corresponding generators will feed 64 images. If multiple image augmentation settings are specified, a\nrandom selection is made of the type of augmentation per image. For example, if one specifies rotation, zoom and horizontal flip, then each time an image is augmented a random choice is\nmade between the three.</p>\n<h3>Managing Datasets (Persistent Storage)</h3>\n<p>Image datasets which have been transformed into machine learning ready data can be stored and managed in persistent storage, using the HDF5 filesystem format. The following can be done:</p>\n<pre><code>1. Save transformed images into storage (bulk or streamed).\n2. Load transformed images from storage (bulk or streamed).\n3. Apply new transformations (e.g., convert to gray scale, flatten, change size, etc).\n4. Combine collections (classes) of images.\n</code></pre>\n<p><em>Save to Persistent Storage</em></p>\n<p>A transformed image dataset (i.e., collection) can be saved to, and subsequently retrieved from, persistent storage with the <code>config</code> setting <code>store</code>. When specified, the transformed\n(machine learning ready data) image dataset, along with associated metadata, is stored to HDF5 storage. Within the HDF5 storage, each class (label) of data is compacted and indexed into a contiguous volume within the HDF5 storage for subsequent fast retrieval.</p>\n<pre><span class=\"c1\"># store the transformed image dataset into HDF5 storage</span>\n<span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'store'</span><span class=\"p\">])</span>\n</pre>\n<p>If the image dataset is too large to hold the entire dataset in memory, the images can alternatively be processed one at a time and streamed into the HDF5 storage. In this mode, the\nprocess only consumes memory resources for a single image. The stream mode is invoked when the <code>config</code> setting <code>stream</code> is specified.</p>\n<pre><span class=\"c1\"># stream (store) the transformed image dataset into HDF5 storage</span>\n<span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'stream'</span><span class=\"p\">])</span>\n</pre>\n<p><em>Load from Persistent Storage</em></p>\n<p>The <code>load()</code> method of the <code>Images</code> class will retrieve (load) a collection of transformed (machine learning ready data) images, and associated metadata, from persistent storage. Once loaded, the collection can then be feed to a neural network for training.</p>\n<pre><span class=\"c1\"># load a previously preprocessed collection of images entirely in-memory</span>\n<span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">()</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'cats_n_dogs'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># feed into a neural network</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">split</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mi\">112</span>\n<span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">X_test</span><span class=\"p\">,</span> <span class=\"n\">Y_train</span><span class=\"p\">,</span> <span class=\"n\">Y_test</span> <span class=\"o\">=</span> <span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">split</span>\n\n<span class=\"c1\"># alternately, stream a previously preprocessed collection of images</span>\n<span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'stream'</span><span class=\"p\">])</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'cats_n_dogs'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># feed (streaming) into a neural network</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">minibatch</span> <span class=\"o\">=</span> <span class=\"mi\">32</span>\n<span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">minibatch</span>\n<span class=\"k\">for</span> <span class=\"n\">step</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">steps</span><span class=\"p\">):</span>\n    <span class=\"n\">x_batch</span><span class=\"p\">,</span> <span class=\"n\">y_batch</span> <span class=\"o\">=</span> <span class=\"n\">g</span>\n</pre>\n<p><em>Apply Transforms</em></p>\n<p>After a transformed image dataset has been loaded from persistent storage, one can further re-transform the dataset to match the input requirements of another neural network, without reprocessing the original image data. The re-transforms are supported as setter properties of the <code>Images</code> class:</p>\n<pre><code>- `gray`   : Converting to Grayscale\n- 'flatten`: Flattening\n- 'resize` : Resizing\n</code></pre>\n<pre><span class=\"c1\"># load a previously preprocessed collection of images</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'cats_n_dogs'</span><span class=\"p\">)</span>\n<span class=\"c1\"># resize the transformed images to 96 x 96 (height vs. width)</span>\n<span class=\"n\">images</span><span class=\"o\">.</span><span class=\"n\">resize</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">96</span><span class=\"p\">,</span> <span class=\"mi\">96</span><span class=\"p\">)</span>\n</pre>\n<p><em>Combining Collections</em></p>\n<p>Existing collections in persistent storage can be combined into a single new collection using the overridden <code>+=</code> operator. When combined, the label assignment is reassigned. For example,\nif both collections are a single class with both having the respective value 0 for the class, in the combined version, one class will be 0 and the other 1.</p>\n<pre><span class=\"n\">cats</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'cats'</span><span class=\"p\">,</span> <span class=\"n\">dataset</span><span class=\"o\">=...</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">cats</span><span class=\"o\">.</span><span class=\"n\">class</span><span class=\"p\">)</span>   <span class=\"c1\"># will output: {'cats': 0}</span>\n\n<span class=\"n\">dogs</span> <span class=\"o\">=</span> <span class=\"n\">Images</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'dogs'</span><span class=\"p\">,</span> <span class=\"n\">dataset</span><span class=\"o\">=...</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">dogs</span><span class=\"o\">.</span><span class=\"n\">class</span><span class=\"p\">)</span>   <span class=\"c1\"># will output: {'dogs': 0}</span>\n\n<span class=\"n\">cats</span> <span class=\"o\">+=</span> <span class=\"n\">dogs</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">cats</span><span class=\"o\">.</span><span class=\"n\">class</span><span class=\"p\">)</span>   <span class=\"c1\"># will output: {'cats': 0, 'dogs': 1}</span>\n</pre>\n<h2>Reference</h2>\n<h2>Testing</h2>\n<p>The <strong>Gap</strong> framework is developed using Test Driven Development methodology. The automated unit tests for the framework use pytest, which is a xUnit style form of testing (e.g., jUnit, nUnit, jsUnit, etc).</p>\n<h4>Installation and Documentation</h4>\n<p>The pytest application can be installed using pip:</p>\n<pre><code>pip install pytest\n</code></pre>\n<p>Online documentation for <a href=\"https://docs.pytest.org\" rel=\"nofollow\">pytest</a></p>\n<h4>Execution</h4>\n<p>The following are the pre-built automated unit tests, which are located under the subdirectory tests:</p>\n<pre><code>image_test.py       # Tests the Image and Images Class in the Vision Module\n</code></pre>\n<p>The automated tests are executed as follows:</p>\n<ol>\n<li>\n<p>From directory root enter <code>cd tests</code></p>\n</li>\n<li>\n<p>Tests can be run by:</p>\n</li>\n</ol>\n<pre><code>pytest -v image_test.py\n</code></pre>\n<h4>Code Coverage</h4>\n<p>Information on the percent of code that is covered (and what source lines not covered) by the automated tests is obtained using pytest-cov. This version of pytest is installed using pip:</p>\n<pre><code>pip install pytest-cov\n</code></pre>\n<ol>\n<li>\n<p>From directory root enter <code>cd tests</code></p>\n</li>\n<li>\n<p>To run tests with coverage:</p>\n</li>\n</ol>\n<pre><code>pytest --cov=gapcv.vision image_test.py\n\n    Statements=1364, Missed=59, Percent Covered: 96%\n</code></pre>\n\n          </div>"}, "last_serial": 7061082, "releases": {"0.9.5": [{"comment_text": "", "digests": {"md5": "c0df1b36f8d57c972bab085ab9d0d8cd", "sha256": "d8c8a983f18cf965c4c4de6e2f9e81e79c3b72836486429963e553b427077633"}, "downloads": -1, "filename": "gapcv-0.9.5.tar.gz", "has_sig": false, "md5_digest": "c0df1b36f8d57c972bab085ab9d0d8cd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16407, "upload_time": "2018-10-24T00:27:58", "upload_time_iso_8601": "2018-10-24T00:27:58.918444Z", "url": "https://files.pythonhosted.org/packages/eb/3b/164f1505d3dd104fe02dac01cffaa07c8b1e96cefa450dabcf161a74fc58/gapcv-0.9.5.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "ee589ec3f60c6d6048f09632ffa05309", "sha256": "c96b50f208aa89833a5d8bd46dc99798621089b39837c31c96edd007bc4b1413"}, "downloads": -1, "filename": "gapcv-1.0.0.tar.gz", "has_sig": false, "md5_digest": "ee589ec3f60c6d6048f09632ffa05309", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37429, "upload_time": "2019-05-20T18:10:10", "upload_time_iso_8601": "2019-05-20T18:10:10.787874Z", "url": "https://files.pythonhosted.org/packages/4b/57/46b0539ace5d2b7f7c1ce2c24a37c8603ea9624462e815d26d191388eed1/gapcv-1.0.0.tar.gz", "yanked": false}], "1.0.1rc0": [{"comment_text": "", "digests": {"md5": "1ff2551b648bd877c67807c335a25444", "sha256": "7ac57fa9a7d59c747e3ad654fab371f7829734afd6743a42ccab5cf60f2f71cd"}, "downloads": -1, "filename": "gapcv-1.0.1rc0.tar.gz", "has_sig": false, "md5_digest": "1ff2551b648bd877c67807c335a25444", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37718, "upload_time": "2019-11-10T01:20:05", "upload_time_iso_8601": "2019-11-10T01:20:05.155615Z", "url": "https://files.pythonhosted.org/packages/19/ef/2a4d9bf1f363c1a9a012a6052d138bad548fe0b0ed6236258a62adcd2cc4/gapcv-1.0.1rc0.tar.gz", "yanked": false}], "1.0rc10": [{"comment_text": "", "digests": {"md5": "7b2efcd4a37f7f83a7131d1770c37170", "sha256": "59936ecef37c6460a92ff7f84d9d6d8b5d976ef1892674929d201208090112b8"}, "downloads": -1, "filename": "gapcv-1.0rc10.tar.gz", "has_sig": false, "md5_digest": "7b2efcd4a37f7f83a7131d1770c37170", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39616, "upload_time": "2020-04-20T02:05:07", "upload_time_iso_8601": "2020-04-20T02:05:07.348994Z", "url": "https://files.pythonhosted.org/packages/7d/d2/918de0f1bbbc52d221f75d04087b96d3962d190e8ccd6d47aedec64f2562/gapcv-1.0rc10.tar.gz", "yanked": false}], "1.0rc11": [{"comment_text": "", "digests": {"md5": "382b21c52d9acc6a520cd941dcfa57a2", "sha256": "2df9657b124e9223f8005bb24e620a2ca77cc7a010401bab94a40e8d5a831820"}, "downloads": -1, "filename": "gapcv-1.0rc11.tar.gz", "has_sig": false, "md5_digest": "382b21c52d9acc6a520cd941dcfa57a2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39642, "upload_time": "2020-04-20T14:55:47", "upload_time_iso_8601": "2020-04-20T14:55:47.290478Z", "url": "https://files.pythonhosted.org/packages/90/d4/f319a2a03c26f3e1d29478d56eff95a98e3b8206fd2acb5d58ded554ce65/gapcv-1.0rc11.tar.gz", "yanked": false}], "1.0rc12": [{"comment_text": "", "digests": {"md5": "d7307738cdd4a7209b095f79c0d92217", "sha256": "1f772978a525718251428678f76227cf8aa340c63e15677e5631a325740774eb"}, "downloads": -1, "filename": "gapcv-1.0rc12.tar.gz", "has_sig": false, "md5_digest": "d7307738cdd4a7209b095f79c0d92217", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39664, "upload_time": "2020-04-20T15:07:08", "upload_time_iso_8601": "2020-04-20T15:07:08.080105Z", "url": "https://files.pythonhosted.org/packages/8c/db/9fb4a9ddf56785924dbfe1079c644213ec6d69702efc4cd6ddddbc644b43/gapcv-1.0rc12.tar.gz", "yanked": false}], "1.0rc13": [{"comment_text": "", "digests": {"md5": "22e5836d39211b888b4feea9ea7fffd4", "sha256": "23fb8f5d6de2056f36843f8be4a3027e6e6c9bed7a00a6c062887239e3771217"}, "downloads": -1, "filename": "gapcv-1.0rc13.tar.gz", "has_sig": false, "md5_digest": "22e5836d39211b888b4feea9ea7fffd4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39653, "upload_time": "2020-04-20T15:47:54", "upload_time_iso_8601": "2020-04-20T15:47:54.641442Z", "url": "https://files.pythonhosted.org/packages/2d/46/b5b533fb704d0c94507a98a1ab576838bc5ebe78f70c9bd6e0da050decb2/gapcv-1.0rc13.tar.gz", "yanked": false}], "1.0rc4": [{"comment_text": "", "digests": {"md5": "81a7086bd2f24512df8559e0f53ddb1e", "sha256": "1c897660c0096825fef061730fbf0ff9717e95257d6674455c855d5055a133ae"}, "downloads": -1, "filename": "gapcv-1.0rc4.tar.gz", "has_sig": false, "md5_digest": "81a7086bd2f24512df8559e0f53ddb1e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39486, "upload_time": "2019-11-11T07:43:54", "upload_time_iso_8601": "2019-11-11T07:43:54.828512Z", "url": "https://files.pythonhosted.org/packages/b1/37/4866218a4c4b5c9183c49c2a6a668c74595be9a5232b2a1f6e1864aa4ed3/gapcv-1.0rc4.tar.gz", "yanked": false}], "1.0rc5": [{"comment_text": "", "digests": {"md5": "3e0fdbaf328f9ec690f934320f60a7eb", "sha256": "39d458cb4d4533850d3b2007c53ea915200af392437240d4270ccd22ea647d3f"}, "downloads": -1, "filename": "gapcv-1.0rc5.tar.gz", "has_sig": false, "md5_digest": "3e0fdbaf328f9ec690f934320f60a7eb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39592, "upload_time": "2020-04-19T23:11:18", "upload_time_iso_8601": "2020-04-19T23:11:18.570687Z", "url": "https://files.pythonhosted.org/packages/a1/95/d4adc181cb9462ed08c1f0568e33b9f06ac70bb63c3331a36bc1c5135e63/gapcv-1.0rc5.tar.gz", "yanked": false}], "1.0rc6": [{"comment_text": "", "digests": {"md5": "885fa7decc57c3fdad043d99fc653bf6", "sha256": "004c4cb174514c067aa99bbd5f9b2d2e33724b06e34686328389019891678a92"}, "downloads": -1, "filename": "gapcv-1.0rc6.tar.gz", "has_sig": false, "md5_digest": "885fa7decc57c3fdad043d99fc653bf6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39610, "upload_time": "2020-04-20T00:20:27", "upload_time_iso_8601": "2020-04-20T00:20:27.650910Z", "url": "https://files.pythonhosted.org/packages/1d/27/f2780166eddd7f64850ad605ec6fcf00fa8cea109618e9e4c8c3f12422cb/gapcv-1.0rc6.tar.gz", "yanked": false}], "1.0rc7": [{"comment_text": "", "digests": {"md5": "28e706dc135a2dfc2199b4caaca9ed1c", "sha256": "fabe294db6e1ebafb841ec383c32840aef8ac015032ed6d9fa12dead020c36f3"}, "downloads": -1, "filename": "gapcv-1.0rc7.tar.gz", "has_sig": false, "md5_digest": "28e706dc135a2dfc2199b4caaca9ed1c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39628, "upload_time": "2020-04-20T00:33:39", "upload_time_iso_8601": "2020-04-20T00:33:39.290269Z", "url": "https://files.pythonhosted.org/packages/f3/b2/6c8d6c47911c1934a9b14a8767afc5de908aae00f5154083ef1a2e3a51c6/gapcv-1.0rc7.tar.gz", "yanked": false}], "1.0rc8": [{"comment_text": "", "digests": {"md5": "d4c41f2b4f814a542ba40e589efc0b32", "sha256": "88c4a25ba259d5181b1a2ced4294ce412e759bfc54043d86a293e01dba2091e9"}, "downloads": -1, "filename": "gapcv-1.0rc8.tar.gz", "has_sig": false, "md5_digest": "d4c41f2b4f814a542ba40e589efc0b32", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39597, "upload_time": "2020-04-20T00:45:52", "upload_time_iso_8601": "2020-04-20T00:45:52.714589Z", "url": "https://files.pythonhosted.org/packages/db/73/a16095346aa68fb6a6f4ecddd1f8103347987ffcda0d66b3b7483b5afa5c/gapcv-1.0rc8.tar.gz", "yanked": false}], "1.0rc9": [{"comment_text": "", "digests": {"md5": "45ee4e8f674c6eae595c12139de30ae3", "sha256": "f4318cf3655490dbb9cbbbbb3450a4a1eeb1cb68ccc565a8765f817a13f289fa"}, "downloads": -1, "filename": "gapcv-1.0rc9.tar.gz", "has_sig": false, "md5_digest": "45ee4e8f674c6eae595c12139de30ae3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39624, "upload_time": "2020-04-20T01:54:34", "upload_time_iso_8601": "2020-04-20T01:54:34.732345Z", "url": "https://files.pythonhosted.org/packages/23/46/36bbb435388b58b680dc07473760d8d245d27023fe9ecffa25f62410e2e4/gapcv-1.0rc9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ee589ec3f60c6d6048f09632ffa05309", "sha256": "c96b50f208aa89833a5d8bd46dc99798621089b39837c31c96edd007bc4b1413"}, "downloads": -1, "filename": "gapcv-1.0.0.tar.gz", "has_sig": false, "md5_digest": "ee589ec3f60c6d6048f09632ffa05309", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37429, "upload_time": "2019-05-20T18:10:10", "upload_time_iso_8601": "2019-05-20T18:10:10.787874Z", "url": "https://files.pythonhosted.org/packages/4b/57/46b0539ace5d2b7f7c1ce2c24a37c8603ea9624462e815d26d191388eed1/gapcv-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:59:09 2020"}