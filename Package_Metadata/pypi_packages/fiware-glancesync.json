{"info": {"author": "Fernando Lopez Aguilar", "author_email": "fernando.lopezaguilar@telefonica.com, e.fiware.tid@telefonica.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Apache Software License"], "description": ".. _Top:\n\nGlanceSync - Glance Synchronization Component\n*********************************************\n\n| |License Badge| |Documentation Badge| |StackOverflow| |Build Status| |Coveralls| |Docker badge|\n\n.. contents:: :local:\n\nIntroduction\n============\n\nThis is the code repository for the GlanceSync component, the FIWARE Ops tool\nused to synchronise the glance images in the different Glance servers connected\nin the FIWARE Lab.\n\nThis project is part of `FIWARE`_.\n\nAlthough this component has been developed for FIWARE, the software is highly\nconfigurable, do not have special requirements beyond OpenStack libraries and\nmay be used with any other project or as a generic tool to synchronise images.\nMoreover, all the OpenStack interface is in a module and it is possible to\nadapt the code to support other platforms.\n\nThere is also the possibility to launch the application like a service which\nallows you synchronise the different regions using a specific FIWARE Lab\nadministrator account. It could be used with a specific token generated by the\nFIWARE Lab Keystone service.\n\nAny feedback on this documentation is highly welcome, including bugs, typos\nor things you think should be included but are not. You can use\n`github issues`_\nto provide feedback.\n\nTop_\n\n\nOverall description\n===================\n\nGlanceSync is a command line tool and a server with API to solve the problem\nof the images synchronisation between regions. It synchronises glance servers\nin different regions taking the base of a master region. It was designed for\nFIWARE project, but it has been expanded to be useful for other users or\nprojects.\n\nGlanceSync synchronises all the images with certain metadata owned by a tenant\nfrom a master region to each other region in a federation (or a subset of them).\nThis feature works out of the box without configuration. It requires only the\nsame set of environment variables, which are needed to contact the\nkeystone server, than the glance tool. It is also possible to set these\nparameters in a file instead of using environment variables. Furthermore, any\noption in the configuration file can be provided via command line, too.\n\nGlanceSync synchronisation algorithm (i.e. the method to determine if a master\nimage must be synchronised to the other regions) is configurable. By default\nall public images are synchronised, but it is enough with adding a line in the\nconfiguration file to synchronise only the public images with certain metadata\n(e.g. federated_image=True).\n\nGlanceSync supports also the synchronisation to regions which do not use the\nsame keystone server than the master region and therefore require their own set\nof credentials. The regions are grouped by *targets*: two regions may be in the\nsame *target* if they use the same credential (therefore, their glance servers\nare registered in the same keystone server). The only mandatory *target* is the\n``master`` target, where the master region is. Most of the GlanceSync\nconfiguration, including the criteria to select which images are synchronised,\nis defined at target level. It is okay to create several targets using the same\ncredential, for example if some regions only share a minimal set of images and\nothers have a broader list.\n\nGlanceSync by default does not replace existing images. If an\nimage checksum is different between the region to synchronise and the master\nregion, a warning is emitted. The user has the option of forcing the\noverwriting of a specific image (optionally renaming the old one) including the\nchecksums in a configuration file, using a whilelist or a blacklist.\n\nWhen the remote image has the same content than the master image, but the\nmetadata differs, GlanceSync updates the metadata, but only a limited set, to\navoid overwriting properties considered as local in that glance server. Also\nthe system property ``is_public`` is updated.\n\nGlanceSync has special support for *AMI* (Amazon Machine Image). Amazon images\ninclude a reference to a kernel image (*AKI*) and to a ramdisk image (*ARI*),\nbut they are named by UUID. Therefore GlanceSync has to update this fields to\nreflect the UUIDs in that particular region.\n\nGlanceSync supports marking an image as obsolete, adding the suffix *_obsolete*.\nAn obsolete image is not synchronisable, but it is managed in a special way:\nwhen an image is renamed, the change is propagated to the other regions. Also\nthe visibility of the image is propagated (i.e. if the master image is\nmarked as private, is made private in all the other regions).\n\nThe idea of marking the obsoleted images, is allow the administrator of the\nregions to make a decision about them. These images are not part of set of\nmandatory images in a federation anymore, but perhaps are in use by their local\nusers.\n\nAbout UUIDs and image names\n---------------------------\n\nThis tool does not synchronise using UUID but names (i.e. an image has the same\nname in all regions, but not the same UUID). Using a UUID to synchronise is\ngenerally a bad idea, because some problems may arise with the restriction that\na UUID must be unique. Be aware that it is not possible to replace\nthe content of a image, without creating a new one and the old UUID may not be\nreused.  If something similar to an UUID is required, it is better to use a\nmetadata field to simulate it.\n\nThe downside of using names, is that a region may have more than a image\nwith the same name. This is specially challenging, when there is more than one\nimage in a destination target, with the name of the image to synchronise. In\nthis situation, GlanceSync takes the first image that is found with the same checkum\n(or absolutely the first image that is found if there is not a checksum match)\nand prints a warning for each duplicated image detected. Master images\nwith duplicated names are not synchronised and a warning is printed.\n\nImage names with duplicated names are easy to avoid, with one serious\nexception: when ordinary users can publish their images as public (shared), the\nrisk of collision increases and escapes of the control of the user. To avoid\nthis, GlanceSync ignore the images of other tenants by default.\nAnyway, this is a general problem, not only a synchronisation\nproblem, due to more that one image with the same name is very confusing to users\nthat want to use them. Therefore it is better to restrict the publication of\nshared images.\n\nHow it works\n------------\n\nFirst GlanceSync gets a list of the images in the master region. Then runs the\nalgorithm with each specified region (or all the regions registered in the\nsame keystone server than the master region, if not specified). If an error\noccurs within a region synchronisation, GlanceSync does not run more operations\nin that region and jumps to the next one.\n\nFor each region, GlanceSync starts getting a list of its images. Then\ncalculates with images should be synchronised to this region (this is detailed\nin the next section).\n\nIt some images has metadata pending, it updates them. After updating the metadata,\nthe missing images are upload. The uploading is by size order, this way when\nthere is a problem in the glance server it will be detected earlier with the\nsmallest image (e.g. when there is not enough space). Another reason to start\nwith the smallest first, is because AMI images; the kernel and ramdisk are also\nimages and because they are smaller, are uploaded before the AMI image that\nneeds them.\n\nThe last step is to update the kernel/ramdisk fields in AMI\nimages when the kernel/ramdisk images has been uploaded during this synchronisation\nsession.\n\nWhen a image with the same name is already present in the destination region,\nGlancesycn checks it they are the same comparing the checksums. When they are\ndifferent, the following algorithm is applied:\n\n1) Is the checksum of the slave node in the ``dontupdate`` list? Print a warning only\n2) Is the checksum of the slave node in the ``rename`` list? Rename old image (adding\n   the *.old* suffix), change it to private, and upload the master region's image\n3) Is the checksum of the slave node in the ``replace`` list? Replace the old image\n   with the master region's image\n4) Does the parameter ``replace`` include the keyword *any*? Rename old image and\n   upload the  master region's image\n5) Does the parameter ``rename`` include the keyword *any*? Replace the old image\n   with the master region's image\n6) Otherwise: print a warning. The user should take an action and fill\n   ``dontupdate``, ``replace`` or ``rename`` parameters. In the meanwhile, the\n   image is considered *stalled* and it is not synchronised at all.\n\nNote: When we talk about the checksum of the slave node, we mean that we need to specify\nthe checksum not from the master node, in our case Spain2, but the checksum in the destination\nof the synchronization.\n\nHow the images to be synchronised are selected\n----------------------------------------------\n\nThere are three parameters in the configuration that affects which images are\nselected: *forcesync*, *metadata_condition* and *metadata_set*. All of them can be\ndifferent for each target; when most targets use the same selection criteria,\nan option is to put this options in the *DEFAULT* section.\n\nThis is the algorithm to determine if an image is synchronisable:\n\n1) images with the *_obsolete* suffix, are never synchronised\n2) images of other tenants are never synchronised\n3) images with duplicated names are never synchronised, to avoid ambiguity.\n4) if the UUID of the image is included in ``forcesync``, then it is synchronised\n   unconditionally, even if the image is not public.\n5) if ``metadata_condition`` is defined, it contains python code that is evaluated\n   to determine if the image is synchronised. The code can use two variables:\n   image, with the information about the image and ``metadata_set``, with the content\n   of that parameter. The more interesting field of image is ``user_properties``,\n   that is a dictionary with the metadata of the image. Other properties are *id*,\n   *name*, *owner*, *size*, *region*, *is_public*. The image may be synchronised\n   even if it is not public, to avoid this, check ``image.is_public`` in the condition.\n   If metadata_set is not defined and ``image.is_public``, then the image will be synchronised\n   with all ``user_properties``.\n6) if ``metadata_condition`` is not defined, the image is public, and\n   ``metadata_set`` is defined, the image is synchronised if some of the\n   properties of ``metadata_set`` is on ``image.user_properties``.\n7) if ``metadata_condition`` is not defined, the image is public, and\n   ``metadata_set`` is not defined, the image is synchronised\n8) otherwise, the image is not synchronised.\n\nFor example, to synchronise the images in FIWARE Lab, the best choice is\nsetting ``metadata_set=nid, sdc_aware, type, nid_version``, because all the images to be\nsynchronised has at least one of those properties.\n\nA trip to synchronise also the images specified in a white list is combine the\nparameter *forcesyncs* with ``metadata_condition=False``\n\nThe parameter ``metadata_set`` has another function. It is used to determine how\nthe metadata is updated in the remote image. If it is not defined, all the metadata\nis copied from the master image, otherwise, only the properties in ``metadata_set``\nare copied. Be aware that system property *is_public* must not be included in\n``metadata_set``, because it is not a user property but a system one. Anyway,\n*is_public* is unconditionally synchronised.\n\nHow the obsoleted images are managed\n------------------------------------\n\nAn obsolete image is an image with the *_obsolete* suffix. When an image is\nmarked as obsoleted is not synchronised anymore and therefore it is not upload to\nregions where it is not present. However, if an image exists in the remote region\nwith the same name but without the suffix, it is renamed and the visibility is\nupdated with the value on the master region. Also the properties specified\nin *obsolete_syncprops*, if any, are synchronised. The synchronisation of the\nproperties and the visibility is also managed when there is a image in the\nregion to synchronise that is already renamed but without the other changes\npropagated.\n\nThere are some checks to do before propagating the changes of an\nobsoleted image:\n\n* Are the two images the same? The checksums are compared and only if they are\n  the same the change is done.\n* Is the image in the region to synchronise a public image of another tenant?\n  in this case do not touch the image.\n* Is there an image with the same name but without the suffix also in the\n  master region and is synchronisable? In this case the image will be\n  synchronised normally without taking in consideration the obsolete image.\n\nUsually obsoleted images are made private, because are not supported anymore.\nIt is possible to restore an image as public for local use after renaming or changing\nthe tenant (to avoid that it is made private again automatically), but before this is\nimportant to look out more about the security status of the image.\n\nThe treatment of obsolete images can be disabled for a *target* with\n*support_obsolete_images=False*. This flag affects the image renaming and\nthe metadata updating, but anyway images with '_obsolete' suffix are never\nsynchronised.\n\nTop_\n\nBuild and Install\n=================\n\nRequirements\n------------\n\nGlanceSync is designed to run with a mounting point with the images, because it\nreads the images that are stored directly in the filesystem. Usually this\ndirectory is /var/lib/glance/images.\n\nThe following software must be installed (e.g. using apt-get on Debian and Ubuntu,\nor with yum in CentOS):\n\n- Python 2.7\n- pip\n- virtualenv\n\n\nInstallation\n------------\n\nThe recommend installation method is using a virtualenv. Actually, the installation\nprocess is only about the python dependencies, because the python code do not need\ninstallation.\n\n1) Create a virtualenv 'glancesyncENV' invoking *virtualenv glancesyncENV*\n2) Activate the virtualenv with *source glancesyncENV/bin/activate*\n3) Install the requirements running *pip install -r requirements.txt\n   --allow-all-external*\n\nNow the system is ready to use. For future sessions, only the step2 is required.\n\nTop_\n\nServer Configuration\n====================\n\nThere is the possibility to execute the glancesync like a service. You should\nlaunch the server by executing the ``run.py`` process. You can see in the\nRunning section how to launch the server. In this section we explain the configuration\nfile that have to be defined to work with the GlanceSync Service. Last but not least\nkeep in bear that you will need also configure the client component if you want to launch\nthe core module of synchronization component.\n\nGlanceSync server configuration file\n------------------------------------\n\nThe server have to be launched with a configuration file. By default, the service\nwill take the values either from environment variables or from files located in\n``/etc/fiware.d``. The name of the files MUST be ``fiware-glancesync.cfg`` and\n``fiware-glancesync-logging.cfg``. The options that we take are the following:\n\n1) In the first case, the application try to see if there is defined\nthe variables ``GLANCESYNC_SETTINGS_FILE``, ``GLANCESYNCAPP_DATABASE_PATH``,\n``GLANCESYNCAPP_CONFIG`` and ``GLANCESYNC_LOGGING_SETTINGS_FILE``.\nThis environment variables will have the location of the configuration files, you can\nspecify them using the following commands\n\n.. code::\n\n  $ export GLANCESYNC_SETTINGS_FILE=/Users/foo/fiware-glancesync/app/settings/fiware-glancesync.cfg\n  $ export GLANCESYNC_LOGGING_SETTINGS_FILE=/Users/foo/fiware-glancesync/app/settings/fiware-glancesync-logging.cfg\n  $ export GLANCESYNCAPP_DATABASE_PATH=/Users/foo/glancesyncENV/lib/python2.7/site-packages/\n                                       fiware_glancesync.egg/fiwareglancesync/\n  $ export GLANCESYNCAPP_CONFIG=/Users/foo/glancesyncENV/lib/python2.7/site-packages/\n                                       fiware_glancesync.egg/fiwareglancesync/app/config.py\n\n2) If the ``GLANCESYNC_SETTINGS_FILE`` and ``GLANCESYNC_LOGGING_SETTINGS_FILE``\nenvironment variables are not presented, the application will try to obtain the\nfiles from the directory ``/etc/fiware.d``\n\nIf no one of the previos option is accomplished the server will launch an error message\nlike the following:\n\n.. code::\n\n  ERROR: There is not defined GLANCESYNCAPP_CONFIG environment variable\n         pointing to config.py path file\n         Please correct at least one of them to execute the program.\n\n  ERROR: There is not defined GLANCESYNCAPP_DATABASE_PATH environment variable\n         pointing to database path file\n         Please correct at least one of them to execute the program.\n\n  ERROR: There is neither defined GLANCESYNC_LOGGING_SETTINGS_FILE environment variable pointing\n         to fiware-glancesync-logging.cfg nor /etc/fiware.d/etc/fiware-glancesync-logging.cfg\n         file. Please correct at least one of them to execute the program.\n\n  ERROR: There is neither defined GLANCESYNC_SETTINGS_FILE environment variable\n         pointing to fiware-glancesync.cfg nor /etc/fiware.d/etc/fiware-glancesync.cfg\n         file. Please correct at least one of them to execute the program.\n\nConfigure your own configuration files\n--------------------------------------\n\nThe GlanceSync server has two configuration files:\n\n* fiware-glancesync.cfg, this is the important one to configure the service and need some modifications\n* fiware-glancesync-logging.cfg, this file is used to configure the logging system, it is not needed to\nchange the content that we have defined by default in the publication of the component.\n\nRelated to the first file, how we have mentioned, there is some parameters that have to be configured in\norder to execute correctly the service. For obvious reason they are not included in the repository:\n\n- **KEYSTONE_URL**, service endpoint of the Keystone service in FIWARE Lab (it usually comes defined in\nthe installation of the component.\n\n- **ADM_USER**, admin user in Keystone.\n\n- **ADM_PASS**, password of the admin user\n\n- **ADM_TENANT_ID**, tenant id of the admin user.\n\n- **ADM_TENANT_NAME**, tenant name of the admin user (you have to provide either ADM_TENANT_ID or ADM_TENANT_NAME).\n\n- **USER_DOMAIN_NAME**, user domain name, by default for an administrator account you can use the value ``Default``.\n\nTop_\n\n\nClient Configuration\n====================\n\nWorking without a configuration file\n------------------------------------\n\nThe tool can work without a configuration file or with an empty one. In this\ncase, the following OpenStack environment variables must be filled with the\nadministrator's credential: ``OS_USERNAME``, ``OS_PASSWORD``, ``OS_AUTH_URL``,\n``OS_TENANT_NAME``, ``OS_REGION_NAME``. The value of ``OS_REGION_NAME`` will be\nthe master region (in FIWARE Lab this region is Spain2).\n\nIt is also possible to pass any configuration option using command line. For\nexample, the following invocation runs a synchronisation taking from command\nline the parameters *master_region* in the *main* section and *metadata_set* in\nthe *DEFAULT* section:\n\n.. code::\n\n ./sync.py --config main.master_region=Spain2 metadata_set=nid,type,sdc_aware,sdc_version\n\nIt is important to note that *--config* parameter expect any number of parameters\nseparated by spaces. This is a problem if the list of regions are specified\n *after* the *--config* parameter, because then the regions are parsed as part\nof the *--config* parameter. The solution is passing the regions *before* the\nparameter or using the standard separator *--*:\n\n.. code::\n\n  # Wrong: region1 and region2 are interpreted as part of --config param\n  ./sync.py --config main.master_region=Spain2 region1 region2\n  # Ok\n  ./sync.py --config main.master_region=Spain2 -- region1 region2\n  # Ok\n  ./sync.py region1 region2 --config main.master_region\n\nThe configuration file\n----------------------\n\nThe configuration used by the GlanceSync component is stored in the\n``/etc/fiware.d/glancesync.conf`` file. However, this path may be changed with the\nenvironment variable *GLANCESYNC_CONFIG*.\n\nThe configuration file has a ``main`` section with some global configuration\nparameters and one section for each target (regions are grouped by targets,\ntwo regions are in the same targets if they use the same credential). The\n``master`` section is the target where the master region is, that is, the region\nwhere are located the images to synchronise to the other regions.\n\nMost of the configuration is defined at target level. If the same values are\nused in most or all the targets, an option is to set them in the DEFAULT section.\n\nThe only mandatory settings in the target sections, is the credential. It may be\nprovided in two ways (in the case of ``master`` also it is possible to use\nthe environment variables as explained in the previous section, even it is\npossible to combine both methods, for example to set only the password via\nenvironment variable):\n\n* using the credential option. There are four values separated by commas: the\n  first is the user, the second is the password encoded with base64, the third\n  is the keystone URL and the fourth, the tenant name.\n* using the options *user*, *password*, *tenant*, *keystone_url*.\n\nIf credentials are stored in the configuration file, it is convenient to\nmake the file only readable by the user who invokes GlanceSync.\n\nExample of a configuration file\n_______________________________\n\nThe following is an example of a configuration file, with all the possible\noptions auto explained in the comments. A configuration file like this can be\ngenerated invoking *fiwareglancesync/script/generated_config_file.py*\n\n.. glancesync_conf_begin\n.. code::\n\n [main]\n\n # Region where are the images in the \"master\" target that are synchronised to\n # the other regions of \"master\" regions and/or to regions in other targets.\n master_region = Spain\n\n # A sorted list of regions. Regions that are not present are silently\n # ignored. Synchronization is done also to the other regions, but first this\n # list is revised and then the Regions are prefixed with \"target:\"\n # This parameter is only used when running synchronisation without parameters\n # or the region list includes a 'target' (e.g. 'master:' that is expanded to\n # the regions in master but the specified in ignore_regions). When the full region\n # list is provided explicitly via command line, the order of\n # the parameters is used instead.\n preferable_order = Trento, Lannion, Waterford, Berlin, Prague\n\n # The maximum number of simultaneous children to use to do the synchronisation.\n # Each region is synchronised using a children process, therefore, this\n # parameter sets how many regions can be synchronised simultaneously.\n # The default value, max_children = 1, implies that synchronisation is fully\n # sequential. Be aware that you need also to invoke the sync tool with the\n # --parallel parameter.\n #\n max_children = 1\n\n # The folder where the master images are (the filename is the UUID of the\n # image in the master region). The default value is the folder where the\n # Glance server stores the images.\n images_dir = /var/lib/glance/images\n\n [DEFAULT]\n\n # Values in this section are default values for the other sections.\n\n # the files with this checksum will be replaced with the master image\n # parameter may be any or a CSV list (or a CSV list with 'any' at the end),\n # the checksum is the value in the destination glance service.\n # replace = 9046fd22131a96502cb0d85b4a406a5a\n\n # the files with this checksum will be replaced with the master image,\n # but the old image will be preserved renamed (using same name, but with\n # .old extension) and made private. The checksum is the value in the\n # destination glance service.\n # parameter may be any or a CSV list (or a CSV list with 'any' at the end)\n # rename = any\n\n # If replace or rename is any, don't update nor rename images with some of\n # these checksums. The checksum is the value in the destination glance service.\n # dontupdate =\n\n # List of UUIDs that must be synchronised unconditionally.\n #\n # This is useful for example to pre-sync images marked as private\n\n forcesyncs = 6e240dd4-e304-4599-b7d8-e38e13cef058\n\n # condition to evaluate if the image is synchronised.\n # image is defined, as well as metadata_set (see next parameter).\n # Default condition is:\n #  image.is_public and (not metadata_set or metadata_set.intersection(image.user_properties))\n\n metadata_condition = image.is_public and\\\n  ('nid' in image.user_properties or 'type' in image.user_properties)\n\n # the list of userproperties to synchronise. If this variable is undefined, all\n # user variables are synchronised.\n metadata_set = nid , type, sdc_aware, nid_version\n\n # When the software asks for the list of images in a region, it gets both the\n # images owned by the tenant and the public images owned by other tenants.\n # If this parameter is true (the default and recommended value), only the\n # tenant's images are considered. This implies that it can exist after the\n # synchronisation a new image with the same name that a public one from other\n # user. It could be very confusing (actually, a warning is printed when it is\n # detected), but usually it is not recommend to work with images from other\n # tenants. To find out more about this, see 'About UUIDs and image names' in\n # the documentation.\n #\n # This parameter only affects to the list of images obtained from the regional\n # servers. From master region only the tenant's images are considered.\n only_tenant_images = True\n\n # When this option is true (the default), the renaming and metadata updating of\n # obsolete images is activate. See the documentation for details.\n support_obsolete_images = True\n\n # These are the properties that are synchronised (in addition to is_public\n # and the name) in obsolete images, when support_obsolete_images is True.\n obsolete_syncprops = sdc_aware\n\n # Timeout to get the image list from a glance server, in seconds. Default\n # value is 30 seconds.\n list_images_timeout = 30\n\n # API required to contact with the keystone server. If this parameter is True,\n # then version 3 of the API is used. Otherwise, the version 2 is used\n use_keystone_v3 = False\n\n [master]\n\n # This is the only mandatory target: it includes all the regions registered\n # in the same keystone server than the master region.\n #\n # credential set: user, base64(password), keystone_url, tenant_name\n # as alternative, options user, password, keystone_url and tenant can be used\n # only with master target, it is possible also to set the credential using\n # OS_USERNAME, OS_PASSWORD, OS_TENANT_NAME, OS_AUTH_URL (or even mixing this\n # environment variables with parameters user, password, etc.)\n credential = user,W91c2x5X2RpZF95b3VfdGhpbmtfdGhpc193YXNfdGhlX3JlYWxfcGFzc3dvcmQ/,http://server:4730/v2.0,tenantid1\n\n # This parameter is useful when invoking the tool without specifying which\n # images to synchronise or when the list includes a \"target\" without a region\n # (e.g. master:). In this case it is expanded with the list of regions in that\n # target except the included in ignore_regions\n ignore_regions = Spain1\n\n [experimental]\n\n # Another\n credential = user2,W91c2x5X2RpZF95b3VfdGhpbmtfdGhpc193YXNfdGhlX3JlYWxfcGFzc3dvcmQ/,http://server2:4730/v2.0,tenantid2\n metadata_condition = image.is_public and image.user_properties.get('type', None) == 'baseimages'\n\n.. glancesync_conf_end\n\nThis configuration file defines two *targets*: ``master`` and ``experimental``. The first one\nsynchronises all the public images with properties *nid* and/or *type* defined. The last one only\nsynchronises images with ``type=baseimages``\n\nSecurity consideration\n----------------------\n\nGlanceSync does not require *root* privileges. But at this version it requires\nread-only access to image directory ``/var/lib/glance/images`` (or making\navailable a copy of all these files, or at least the subset that may be\nsynchronised, in other path and then set the option *images_dir*)\n\nIt is strongly recommended:\n\n* creating an account to run GlanceSync only\n* creating a configuration file only readable by the GlanceSync account. This\n  is because the credentials should not be exposed to other users.\n\nTop_\n\n\nClient Running\n==============\n\nBasic use\n---------\n\nOnce installed all the dependencies, there is a way to run GlanceSync manually\nfrom the command line invoking the ``sync.py`` tool inside the GlanceSync\ndistribution.\n\nWhen ``./sync.py`` is invoked without parameters, it synchronises the images from\nthe master region to all the other regions with a glance endpoint registered in\nthe keystone server (except the ones, if any, specified as a comma separated list\nin the ``ignore_regions`` parameter, inside the ``master`` section). The command\ncan also receive as parameters the regions to synchronise. It is possible also\nto specify a target name and the suffix *:*; this way it is expanded to all the\nregions in that target (e.g. if there are two regions, *regionA* and *regionB* in\ntarget *target1*, then *target1:* is expanded with *target1:regionA target1:regionB*)\n\nAdvanced use\n------------\n\nBy default, GlanceSync synchronises regions one by one. When the command line\noption *--parallel* is passed, GlanceSync synchronised several regions in\nparallel. The number or regions synchronised at the same time is determined by the\nparameter max_children in the main section. Default value is 1 (no parallel).\nWhen synchronisation runs on parallel, a directory with the pattern\n*sync_<year><month>_<hour><minute>* is created. Inside this, it is a file for each\nregion with the log of the synchronisation process.\n\nThe option *--dry-run* shows the changes needed to synchronise the images,\nbut without doing the operations actually.\n\nThe option *--show-regions* shows all the regions available in all the targets\ndefined in the configuration file.\n\nThe option *--make-backups* creates a backup of the medatada of the images\nin the regional Glance servers, instead of running the synchronisation.\n\nIt is possible to override any parameter of the configuration file, using the\noption *--config*. Be aware that the way of setting several parameters is\nseparating them with spaces (e.g. *--config option1=value1 option2=value2*)\n\nFinally, the option *--show-status* is to obtain a report about the\nsynchronisation status of the regions. A more detailed information of this is\nprovided in the *Checking status* section.\n\nAs pointed, GlanceSync can synchronised also from the master region to regions\nthat do not use the same keystone server. A *target* is a namespace to refer to\nthe regions sharing a credential. The ``master`` target is the one\nwhere the master region is. Each target has a section with its name in the\nconfiguration file, to specify the credential and optionally other configuration\n(most of the parameters are local to each target).\n\nThe way to synchronise to regions that are in other *target*, is to specified\nthe region with the preffix ``<target_name>:``. For example, to synchronise to region\nTrento and Berlin2, both in the same keystone server than the master region,\nbut also to RegionOne and RegionTwo, registered in target *other* the\nfollowing command must be invoked:\n\n.. code::\n\n   ./sync.py Trento Berlin2 other:RegionOne other:RegionTwo\n\nNote that the *master:* prefix may be omitted.\n\nMaking a backup of metadata\n---------------------------\n\nThe option *--make-backups* create a backup of the metadata in the specified\nregions and in the master region. This is useful for example for\ndebugging or testing, because GlanceSync supports the use of a mock that reads\nfiles likes these as input instead of contacting to the real servers. The mock\nis also used for testing real scenarios.\n\nThe backup is created in a directory named *backup_glance_* with the date and\ntime as suffix. There is a file for each region (the name is backup_<region>.csv)\nand inside the file a line for each image. The following fields are included:\n\n* the region name\n* the image name\n* the UUID of the image in the region\n* the status of the image (the OK status is 'active')\n* the size in bytes\n* the checksum\n* the tenant id of the owner (a.k.a. project id)\n* a boolean indicating if the image is Public\n* a dictionary with the user properties\n\nOnly the information about public images/ the images owned by the tenant, can\nbe obtained. This is a limitation of the glance API: even the administrator\ndoes not get a list of private images of other users.\n\nUsing a mock with a backup\n__________________________\n\n.. _mock:\n\nIt is possible to use the result of a backup (optionally after changing the\ncontents) for testing different scenarios.\n\nSupposing the backup directory *backup_glance_2015-11-17T12:54:26.117838* is\nrenamed to *scenario1*. After invoking this line, instead of operating with\nthe real servers, a mock with metadata saved in *persistent_data* folder is\nused:\n\n.. code::\n\n  eval $(glancesync/glancesync_serverfacade_mock.py  --path persistent_data scenenario1)\n  export PYTHONPATH=glancesync\n\nThe created scenario is persistent, that is, is possible to invoke *sync.py --show-status*\nbefore and after running the synchronisation for checking that the state has\nchanged.\n\nThe mock uses as tenant_id (this is important to compare the owner of the files)\nthe paremeter *tenant_id* if defined in the configuration, otherwise *id* is\nadded to the tenant_name as suffix.\n\nTo make test results deterministic, when a new image is created in the mock, the\nUUID is not random. The UUID's pattern is *<seq>$<image_name>* where seq is a number\nstarting with 1 that guarantees the UUID uniqueness.\n\nChecking status\n---------------\n\nIn order to check the status of the synchronisation, use the following command:\n\n.. code::\n\n   ./sync.py --show-status\n\nThis print the status of all the regions in the *master* target, that is, the\nregion in the same keystone server than the master region. If ``ignore_regions``\nis defined in the *master* configuration section, the specified regions are\nignored.\n\nOf course is also possible to check the status of any group of regions, for\nexample, the call:\n\n.. code::\n\n   ./sync.py --show-status Trento Mexico Gent target2:Region1 target2:Region2\n\nIt will show the status of the regions Trento, Mexico, Gent both in the *master*\ntarget, and the regions Region1 in Region2 defined in the *target2* target.\n\nThe output of command is a line for each image to be synchronised for each\nregion. That is, in the last example, if 15 images are synchronised to the\nregions of *master* and 10 images to the regions of *target2*, then a total\nof 15*3 + 10*2 images are printed.\n\nEach line is a CSV. The first field is the synchronisation status, the\nseconds is the region's name, and the third is the image name. This is an\nexample:\n\n.. code::\n\n ok,Prague,base_centos_6\n ok,Prague,base_ubuntu_14.04\n ok,Prague,base_ubuntu_12.04\n ok,Prague,base_debian_7\n ok,Prague,base_centos_7\n pending_upload,experimental:Valladolid,base_centos_7\n\nThe synchronisation status can be classified in three categories: final status,\nerror status and pending synchronisation status.\n\nFinal status\n____________\n\nGlanceSync consider that there is no pending operations: the image is\nsynchronised or marked as 'dontupdate'.\n\n* ok: the image is fully synchronised\n* ok_stalled_checksum: the image has a different checksum than master,\n  but this checksum is included in parameter 'dontupdate'. Therefore the image\n  will not be updated (content nor metadata)\n\nError status\n____________\n\nThere is an error condition that requires user intervention before trying\nagain.\n\n* error_checksum: there is an image, but with a different checksum and\n  there is not a matching dontupdate, rename or replace directive. Action\n  required: fill the checksum (or use any) with *dontupdate* or *rename* or\n  *replace*.\n* error_ami: the image requires a kernel or ramdisk that is not in the\n  list of images to sync. Action required: ensure that the selection criteria\n  include the kernel/ramdisk images.\n\nPending synchronisation status\n______________________________\n\nThe image needs synchronisation. Be aware that perhaps the image is on a\npending status although GlanceSync execution has completed, because the glance\nserver responded with an error. However, this is yet considered a pending status\nand not an error status, because it is not a problem that users must resolve by\nthemselves.\n\n* pending_metadata: there is an image with the right content (checksum), but\n  metadata must be updated (this may include ramdisk_id and kernel_id)\n* pending_upload: the image is not synchronised; it must be upload\n* pending_replace: there is an image, but with different checksum. The\n  image will be replaced\n* pending_rename: there is an image, but with different checksum. The\n  image will be replaced, but before this the old image will be renamed\n* pending_ami: the image requires a kernel or ramdisk image that is in state\n  *pending_upload*, *pending_replace* or *pending_rename*.\n\nHow use glancesync without access to images files\n-------------------------------------------------\n\nAt the moment, GlanceSync is designed to run in the glance server of the master\nregion, because it reads the images that are stored directly in the filesystem.\n\nThis may be an inconvenience, but a real issue is when the Glance backed does not\nuse plain files (e.g. the Cepth backend) and therefore GlanceSync cannot read\nthe files even when it is running at the glance server.\n\nThe following script can be used to pre-download the images required to\nsynchronise the indicated regions to the folder specified by environment\nvariable *GLANCE_IMAGES* (by default, ``/var/lib/glance/images``) and then\nrun the synchronisation:\n\n.. code::\n\n #!/bin/bash\n\n print_required_images_names() {\n   ./sync.py --show-status $* | awk -v ORS=\" \" -F, \\\n    '/^pending_(upload|rename)/ {words[$3]++}\n    END { for (i in words) print substr(i,1, length(i)-1) }'\n }\n\n get_id_from_name() {\n  glance image-show $1 | awk -F\\| \\\n  ' $2 ~ /^[ ]*id/ { sub(/[ ]+/,\"\",$3) ; print $3}'\n }\n\n GLANCE_IMAGES=${GLANCE_IMAGES:-/var/lib/glance/images}\n\n # First, download the required images to $GLANCE_IMAGES\n for name in $(print_required_images_names $*) ;\n do\n   id=$(get_id_from_name $name)\n   echo $name $id\n   if [ ! -f $GLANCE_IMAGES/$id ] ; then\n     glance image-download --file $GLANCE_IMAGES/$id --progress $id\n   fi\n done\n\n # run synchronisation\n ./sync.py $* --config images_dir=$GLANCE_IMAGES\n\n\nTop_\n\nServer Running\n==============\n\nThere is several options to execute the GlanceSync server from the command line. You\ncan obtain information of the different options running form the command line the following\ncommand:\n\n.. code::\n\n    $ python run.py\n\n    usage: run.py [-h] {gunicornserver,shell,db,runserver} ...\n\n    positional arguments:\n      {gunicornserver,shell,db,runserver}\n        gunicornserver      Run the GlanceSync server application within Gunicorn.\n        shell               Runs a Python shell inside Flask application context.\n        db                  Perform database migrations\n        runserver           Runs the Flask development server i.e. app.run()\n\n    optional arguments:\n      -h, --help            show this help message and exit\n\nWe go into details about the db, runserver and gunicornserver options.\n\nDatabase configuration\n----------------------\n\nIf it is the first time that you use the component or if you need to make an upgrade of the database\nschemas, you will need to execute the commands related to the database management. You can obtain a\nhelp of the different operations just executing:\n\n.. code::\n\n    $ python run.py db -h\n    usage: Perform database migrations\n\n    Perform database migrations\n\n    positional arguments:\n      {upgrade,heads,merge,migrate,stamp,show,current,edit,init,downgrade,branches,history,revision}\n        upgrade             Upgrade to a later version\n        heads               Show current available heads in the script directory\n        merge               Merge two revisions together. Creates a new migration\n                            file\n        migrate             Alias for 'revision --autogenerate'\n        stamp               'stamp' the revision table with the given revision;\n                            don't run any migrations\n        show                Show the revision denoted by the given symbol.\n        current             Display the current revision for each database.\n        edit                Edit current revision.\n        init                Generates a new migration\n        downgrade           Revert to a previous version\n        branches            Show current branch points\n        history             List changeset scripts in chronological order.\n        revision            Create a new revision file.\n\n    optional arguments:\n      -h, --help            show this help message and exit\n\nThis allows you to keep a revision of the database that we are using. The first time that you use\nthe component you will need to create the database repository and initialize the revision of it. It\ncan be done with the following commands (in order):\n\n.. code::\n\n    $ python run.py db init\n    $ python run.py db migrate\n    $ python run.py db upgrade\n\n\nRun basic server\n----------------\n\nOnce that we have initialized the database, we can launch the application, there is two possibilities.\nIn this section, we see the easy way to launch the application running basically a python process.\nYou can obtain help of the operation just executing:\n\n.. code::\n\n    $ python run.py runserver -h\n    usage: run.py runserver [-h] [-t HOST] [-p PORT] [--threaded]\n                            [--processes PROCESSES] [--passthrough-errors] [-d]\n                            [-r]\n\n    Runs the Flask development server i.e. app.run()\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      -t HOST, --host HOST\n      -p PORT, --port PORT\n      --threaded\n      --processes PROCESSES\n      --passthrough-errors\n      -d, --no-debug\n      -r, --no-reload\n\nHow you can see almost all arguments are optionals, the HOST and PORT are defined in the ``fiware-glancesync.cfg``\nfile. You can execute the server just executing:\n\n.. code::\n\n    $ python run.py runserver\n\n\nRun Gunicorn server\n-------------------\n\nThere is the possiblity to launch the service behind a Gunicorn HTTP Server. `Gunicorn`_ 'Green Unicorn' is a\nPython WSGI HTTP Server for UNIX. You need to install this HTTP Server previously to execute the GlanceSync\nservice. Take a look to the Gunicorn site to see how to install it. Keep in bear that you should use a version\ngreater than 0.9.0.\n\nAfter the installation of the HTTP server, you can execute the component. If you execute the following command\nyou can obtain detailed information about the options that you have:\n\n.. code::\n\n    $ python run.py gunicornserver -h\n    usage: run.py gunicornserver [-h] [-H HOST] [-p PORT] [-w WORKERS]\n\n    Run the GlanceSync server application within Gunicorn.\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      -H HOST, --host HOST  IP address or hostname of the Glancesync server.\n      -p PORT, --port PORT  Port in which the GlanceSync server is running\n      -w WORKERS, --workers WORKERS\n                            Number of concurrent workers to be launched, usually\n                            2*core numbers+1.\n\nBy default, HOST, PORT and WORKERS are defined in the configuration file, it is not necessary to specify them\nagain here. So to run the service, just write the following line:\n\n.. code::\n\n    $ python run.py gunicornserver -h\n\n\nLogging files\n-------------\n\nThe current version of the GlanceSync service produce logging files that will be located in the sam directory\nof the application where you launch the application. It is defined with log rotate with allow to control the\nextension of the file. You can see details of the configuration of the log file in the ``fiware-glancesync-logging.cfg``\nfile. By default it will be named with **glancesync-api.log**. The sucessive rotate files will be numered adding\na string from '.1' to '.3' to the previous file name (e.g. glancesync-api.log.1).\n\nTop_\n\nAPI Overview\n============\nThe GlanceSync offers a REST API, which can be used for synchronizing images\nin different regions. Please have a look at the API Reference Documentation section\nbellow.\n\nAPI Reference Documentation\n---------------------------\n\n- `FIWARE GlanceSync v1 (Apiary) <http://docs.glancesync.apiary.io/>`_\n\nTop_\n\n\nTesting\n=======\n\nEnt-to-end tests\n----------------\n\nTo run the end-to-end tests, go to ``test/acceptance`` folder and run:\n\n.. code::\n\n    behave features/ --tags ~@skip\n\nPlease, be aware that this tests requires preparing a environment, including\nat least three glance servers and two keystone servers. Have a look to the\n``test/acceptance/README.rst`` in order to get more information about how to\nprepare the environment to run the functional_test target.\n\n\nEnt-to-end tests with Docker execution\n______________________________________\nGlancesync acceptance tests can be executed by Docker. To do that, firstly it is required to create the required docker images (fiware-glancesync and\nfiware-glancesync-acceptance).\nTo do that:\n\n.. code::\n\n    docker build -t fiware-glancesync -f docker/Dockerfile docker\n    docker build -t fiware-glancesync-acceptance -f docker/AcceptanceTests/Dockerfile docker/AcceptanceTests\n\nOnce the images have been created, we can run the acceptance tests it by using docker-compose (to include the environment variables). To export then is required:\n\n.. code::\n\n    export OS_AUTH_URL = {the auth uri of the testbed agains the tests are going to be execute}\n    export OS_USERNAME = {the user name}\n    export OS_TENANT_NAME = {the tenant name}\n    export OS_PASSWORD = {the password}\n    export OS_REGION_NAME = {the region}\n    export OS_PROJECT_DOMAIN_NAME = {the project domain name}\n    export OS_USER_DOMAIN_NAME = {the user domain name}\n    export KEYSTONE_IP = {The keystone ip where testbed is deployed}\n    export Region1 = {The region name 1 for tests}\n    export Region2 = {The region name 2 for tests}\n    export Region3 = {The region name 3 for tests}\n    docker-compose -f docker/docker-compose.yml up\n\nWhen docker has finished, you can obtain the tests results by\n.. code::\n\n   docker cp docker_fiwareglancesync-acceptance:/opt/fiware/glancesync/tests/acceptance/testreport .\n\n\nUnit tests\n----------\nTo run the unit tests, you need to create a virtualenv using the requirements\nboth contained in requirements.txt and test-requrirements.txt. You only need to\nexecute the nosetests program in the root dorectory of the fiware-glancesync\ncode. Keep in mind that it requires python2.7 or superior to execute the unit\ntests.\n\n.. code::\n\n     virtualenv -p <root to python v2.7> venv\n     source ./venv/bin/activate\n     pip install -r requirements.txt\n     pip install -r test-requirements.txt\n     nosetests --exe\n     deactivate\n\nEight tests are marked as skipped because they are more properly integration\ntest. They are in the file \u00b4\u00b4test_glancesync_serversfacade.py\u00b4\u00b4. The tested\nmodule contains all the code that interacts with Glance and the tests do some\nchecks against a real glance server. To activate this eight tests, edit the file and\nchange testingFacadeReal to True. It needs the usual OpenStack environment\nvariables (*OS_USERNAME*, *OS_PASSWORD*, *OS_TENANT_NAME*, *OS_REGION_NAME*,\n*OS_AUTH_URL*)\n\nUnit tests with Docker execution\n________________________________\nGlancesync unit tests can be executed by docker. To do that, firstly it is required to create the docker image,\nwith the following command:\n\n.. code::\n\n    docker build -t fiware-glancesync-build -f docker/UnitTests/Dockerfile docker\n\nOnce the fiware-glancesync-build image is created, we can run it by:\n\n.. code::\n\n    docker run --name fiware-glancesync-build fiware-glancesync-build\n\nFinally, it is possible to obtain tests results and coverage information by:\n\n.. code::\n\n    docker cp fiware-glancesync-build:/opt/fiware/glancesync/test_results .\n    docker cp fiware-glancesync-build:/opt/fiware/glancesync/coverage .\n\nContributing new tests\n----------------------\n\nIt is possible to contribute new tests defining a scenario in *tests/resources*\nFor a scenario 'new_scenario', the following folders must be created:\n\n* new_scenario: there are files for each region with the backup of the metadata\n                BEFORE invoking the synchronisation. These files can be generated\n                with *sync.py --make-backup*\n* new_scenario.result: there are files for each region with the backup of the\n                       metadata AFTER invoking the synchronisation\n* new_scenario.status_pre: there are files with the status of each region BEFORE invoking\n                           the synchronisation. These files can be generated with the\n                           output of *sync.py --show-status*\n* new_scenario.status_post: there are files with the status of each region AFTER invoking\n                            the synchronisation. These files can be generated with the\n                            output of *sync.py --show-status*\n\nInside the forlder *new_scenario*, optionally a *config* file may be included.\nIf this file is not found, then the default configuration defined in the variable\n*config1* of the test file \u00b4\u00b4tests/unit/test_glancesync.py\u00b4\u00b4 is used.\n\nThen, a test class must be defined extending *TestGlanceSync_Sync*, for example:\n\n.. code::\n\n    class TestGlanceSync_AMI(TestGlanceSync_Sync):\n        \"\"\"Test a environment with AMI images (kernel_id/ramdisk_id)\"\"\"\n        def config(self):\n            path = os.path.abspath(os.curdir)\n            self.path_test = path + '/tests/unit/resources/ami'\n            self.regions = ['master:Burgos']\n\nThis class is provided in \u00b4\u00b4tests/unit/test_glancesync.py\u00b4\u00b4.\n\nMore information about the mock: mock_\n\nTop_\n\n\nSupport\n=======\n\nAsk your thorough programming questions using `stackoverflow`_ and your general questions on `FIWARE Q&A`_.\nIn both cases please use the tag *fiware-health*\n\nTop_\n\n\nLicense\n=======\n\n\\(c) 2015 Telef\u00f3nica I+D, Apache License 2.0\n\nTop_\n\n\n.. IMAGES\n\n.. |Build Status| image:: https://travis-ci.org/telefonicaid/fiware-glancesync.svg?branch=develop\n   :target: https://travis-ci.org/telefonicaid/fiware-glancesync\n   :alt: Build status\n.. |StackOverflow| image:: https://img.shields.io/badge/support-sof-yellowgreen.svg\n   :target: https://stackoverflow.com/questions/tagged/fiware-glancesync\n   :alt: Help? Ask questions\n.. |Coveralls| image:: https://coveralls.io/repos/telefonicaid/fiware-glancesync/badge.svg?branch=develop&service=github\n   :target: https://coveralls.io/github/telefonicaid/fiware-glancesync?branch=develop\n   :alt: Unit Tests coverage\n.. |License Badge| image:: https://img.shields.io/badge/license-Apache_2.0-blue.svg\n   :target: LICENSE\n   :alt: Apache 2.0 License\n.. |Docker badge| image:: https://img.shields.io/docker/pulls/fiware/glancesync.svg\n   :target: https://hub.docker.com/r/fiware/glancesync/\n   :alt: Docker Pulls\n.. |Documentation Badge| image:: https://readthedocs.org/projects/fiware-glancesync/badge/?version=latest\n   :target: http://fiware-glancesync.readthedocs.org/en/latest/?badge=latest\n\n.. REFERENCES\n\n.. _FIWARE: http://www.fiware.org\n.. _github issues: https://github.com/telefonicaid/fiware-glancesync/issues/new\n.. _stackoverflow: http://stackoverflow.com/questions/ask\n.. _`FIWARE Q&A`: https://ask.fiware.org\n.. _`Gunicorn`: http://gunicorn.org/", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/telefonicaid/fiware-glancesync/tarball/v1.7.0", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/telefonicaid/fiware-glancesync", "keywords": "fiware,glancesync,glance,images,cloud", "license": "Apache 2.0", "maintainer": null, "maintainer_email": null, "name": "fiware-glancesync", "package_url": "https://pypi.org/project/fiware-glancesync/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/fiware-glancesync/", "project_urls": {"Download": "https://github.com/telefonicaid/fiware-glancesync/tarball/v1.7.0", "Homepage": "https://github.com/telefonicaid/fiware-glancesync"}, "release_url": "https://pypi.org/project/fiware-glancesync/1.7.0/", "requires_dist": null, "requires_python": null, "summary": "Tool to synchronise images from a master region to other regions", "version": "1.7.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            .. _Top:<br><br>GlanceSync - Glance Synchronization Component<br>*********************************************<br><br>| |License Badge| |Documentation Badge| |StackOverflow| |Build Status| |Coveralls| |Docker badge|<br><br>.. contents:: :local:<br><br>Introduction<br>============<br><br>This is the code repository for the GlanceSync component, the FIWARE Ops tool<br>used to synchronise the glance images in the different Glance servers connected<br>in the FIWARE Lab.<br><br>This project is part of `FIWARE`_.<br><br>Although this component has been developed for FIWARE, the software is highly<br>configurable, do not have special requirements beyond OpenStack libraries and<br>may be used with any other project or as a generic tool to synchronise images.<br>Moreover, all the OpenStack interface is in a module and it is possible to<br>adapt the code to support other platforms.<br><br>There is also the possibility to launch the application like a service which<br>allows you synchronise the different regions using a specific FIWARE Lab<br>administrator account. It could be used with a specific token generated by the<br>FIWARE Lab Keystone service.<br><br>Any feedback on this documentation is highly welcome, including bugs, typos<br>or things you think should be included but are not. You can use<br>`github issues`_<br>to provide feedback.<br><br>Top_<br><br><br>Overall description<br>===================<br><br>GlanceSync is a command line tool and a server with API to solve the problem<br>of the images synchronisation between regions. It synchronises glance servers<br>in different regions taking the base of a master region. It was designed for<br>FIWARE project, but it has been expanded to be useful for other users or<br>projects.<br><br>GlanceSync synchronises all the images with certain metadata owned by a tenant<br>from a master region to each other region in a federation (or a subset of them).<br>This feature works out of the box without configuration. It requires only the<br>same set of environment variables, which are needed to contact the<br>keystone server, than the glance tool. It is also possible to set these<br>parameters in a file instead of using environment variables. Furthermore, any<br>option in the configuration file can be provided via command line, too.<br><br>GlanceSync synchronisation algorithm (i.e. the method to determine if a master<br>image must be synchronised to the other regions) is configurable. By default<br>all public images are synchronised, but it is enough with adding a line in the<br>configuration file to synchronise only the public images with certain metadata<br>(e.g. federated_image=True).<br><br>GlanceSync supports also the synchronisation to regions which do not use the<br>same keystone server than the master region and therefore require their own set<br>of credentials. The regions are grouped by *targets*: two regions may be in the<br>same *target* if they use the same credential (therefore, their glance servers<br>are registered in the same keystone server). The only mandatory *target* is the<br>``master`` target, where the master region is. Most of the GlanceSync<br>configuration, including the criteria to select which images are synchronised,<br>is defined at target level. It is okay to create several targets using the same<br>credential, for example if some regions only share a minimal set of images and<br>others have a broader list.<br><br>GlanceSync by default does not replace existing images. If an<br>image checksum is different between the region to synchronise and the master<br>region, a warning is emitted. The user has the option of forcing the<br>overwriting of a specific image (optionally renaming the old one) including the<br>checksums in a configuration file, using a whilelist or a blacklist.<br><br>When the remote image has the same content than the master image, but the<br>metadata differs, GlanceSync updates the metadata, but only a limited set, to<br>avoid overwriting properties considered as local in that glance server. Also<br>the system property ``is_public`` is updated.<br><br>GlanceSync has special support for *AMI* (Amazon Machine Image). Amazon images<br>include a reference to a kernel image (*AKI*) and to a ramdisk image (*ARI*),<br>but they are named by UUID. Therefore GlanceSync has to update this fields to<br>reflect the UUIDs in that particular region.<br><br>GlanceSync supports marking an image as obsolete, adding the suffix *_obsolete*.<br>An obsolete image is not synchronisable, but it is managed in a special way:<br>when an image is renamed, the change is propagated to the other regions. Also<br>the visibility of the image is propagated (i.e. if the master image is<br>marked as private, is made private in all the other regions).<br><br>The idea of marking the obsoleted images, is allow the administrator of the<br>regions to make a decision about them. These images are not part of set of<br>mandatory images in a federation anymore, but perhaps are in use by their local<br>users.<br><br>About UUIDs and image names<br>---------------------------<br><br>This tool does not synchronise using UUID but names (i.e. an image has the same<br>name in all regions, but not the same UUID). Using a UUID to synchronise is<br>generally a bad idea, because some problems may arise with the restriction that<br>a UUID must be unique. Be aware that it is not possible to replace<br>the content of a image, without creating a new one and the old UUID may not be<br>reused.  If something similar to an UUID is required, it is better to use a<br>metadata field to simulate it.<br><br>The downside of using names, is that a region may have more than a image<br>with the same name. This is specially challenging, when there is more than one<br>image in a destination target, with the name of the image to synchronise. In<br>this situation, GlanceSync takes the first image that is found with the same checkum<br>(or absolutely the first image that is found if there is not a checksum match)<br>and prints a warning for each duplicated image detected. Master images<br>with duplicated names are not synchronised and a warning is printed.<br><br>Image names with duplicated names are easy to avoid, with one serious<br>exception: when ordinary users can publish their images as public (shared), the<br>risk of collision increases and escapes of the control of the user. To avoid<br>this, GlanceSync ignore the images of other tenants by default.<br>Anyway, this is a general problem, not only a synchronisation<br>problem, due to more that one image with the same name is very confusing to users<br>that want to use them. Therefore it is better to restrict the publication of<br>shared images.<br><br>How it works<br>------------<br><br>First GlanceSync gets a list of the images in the master region. Then runs the<br>algorithm with each specified region (or all the regions registered in the<br>same keystone server than the master region, if not specified). If an error<br>occurs within a region synchronisation, GlanceSync does not run more operations<br>in that region and jumps to the next one.<br><br>For each region, GlanceSync starts getting a list of its images. Then<br>calculates with images should be synchronised to this region (this is detailed<br>in the next section).<br><br>It some images has metadata pending, it updates them. After updating the metadata,<br>the missing images are upload. The uploading is by size order, this way when<br>there is a problem in the glance server it will be detected earlier with the<br>smallest image (e.g. when there is not enough space). Another reason to start<br>with the smallest first, is because AMI images; the kernel and ramdisk are also<br>images and because they are smaller, are uploaded before the AMI image that<br>needs them.<br><br>The last step is to update the kernel/ramdisk fields in AMI<br>images when the kernel/ramdisk images has been uploaded during this synchronisation<br>session.<br><br>When a image with the same name is already present in the destination region,<br>Glancesycn checks it they are the same comparing the checksums. When they are<br>different, the following algorithm is applied:<br><br>1) Is the checksum of the slave node in the ``dontupdate`` list? Print a warning only<br>2) Is the checksum of the slave node in the ``rename`` list? Rename old image (adding<br>   the *.old* suffix), change it to private, and upload the master region's image<br>3) Is the checksum of the slave node in the ``replace`` list? Replace the old image<br>   with the master region's image<br>4) Does the parameter ``replace`` include the keyword *any*? Rename old image and<br>   upload the  master region's image<br>5) Does the parameter ``rename`` include the keyword *any*? Replace the old image<br>   with the master region's image<br>6) Otherwise: print a warning. The user should take an action and fill<br>   ``dontupdate``, ``replace`` or ``rename`` parameters. In the meanwhile, the<br>   image is considered *stalled* and it is not synchronised at all.<br><br>Note: When we talk about the checksum of the slave node, we mean that we need to specify<br>the checksum not from the master node, in our case Spain2, but the checksum in the destination<br>of the synchronization.<br><br>How the images to be synchronised are selected<br>----------------------------------------------<br><br>There are three parameters in the configuration that affects which images are<br>selected: *forcesync*, *metadata_condition* and *metadata_set*. All of them can be<br>different for each target; when most targets use the same selection criteria,<br>an option is to put this options in the *DEFAULT* section.<br><br>This is the algorithm to determine if an image is synchronisable:<br><br>1) images with the *_obsolete* suffix, are never synchronised<br>2) images of other tenants are never synchronised<br>3) images with duplicated names are never synchronised, to avoid ambiguity.<br>4) if the UUID of the image is included in ``forcesync``, then it is synchronised<br>   unconditionally, even if the image is not public.<br>5) if ``metadata_condition`` is defined, it contains python code that is evaluated<br>   to determine if the image is synchronised. The code can use two variables:<br>   image, with the information about the image and ``metadata_set``, with the content<br>   of that parameter. The more interesting field of image is ``user_properties``,<br>   that is a dictionary with the metadata of the image. Other properties are *id*,<br>   *name*, *owner*, *size*, *region*, *is_public*. The image may be synchronised<br>   even if it is not public, to avoid this, check ``image.is_public`` in the condition.<br>   If metadata_set is not defined and ``image.is_public``, then the image will be synchronised<br>   with all ``user_properties``.<br>6) if ``metadata_condition`` is not defined, the image is public, and<br>   ``metadata_set`` is defined, the image is synchronised if some of the<br>   properties of ``metadata_set`` is on ``image.user_properties``.<br>7) if ``metadata_condition`` is not defined, the image is public, and<br>   ``metadata_set`` is not defined, the image is synchronised<br>8) otherwise, the image is not synchronised.<br><br>For example, to synchronise the images in FIWARE Lab, the best choice is<br>setting ``metadata_set=nid, sdc_aware, type, nid_version``, because all the images to be<br>synchronised has at least one of those properties.<br><br>A trip to synchronise also the images specified in a white list is combine the<br>parameter *forcesyncs* with ``metadata_condition=False``<br><br>The parameter ``metadata_set`` has another function. It is used to determine how<br>the metadata is updated in the remote image. If it is not defined, all the metadata<br>is copied from the master image, otherwise, only the properties in ``metadata_set``<br>are copied. Be aware that system property *is_public* must not be included in<br>``metadata_set``, because it is not a user property but a system one. Anyway,<br>*is_public* is unconditionally synchronised.<br><br>How the obsoleted images are managed<br>------------------------------------<br><br>An obsolete image is an image with the *_obsolete* suffix. When an image is<br>marked as obsoleted is not synchronised anymore and therefore it is not upload to<br>regions where it is not present. However, if an image exists in the remote region<br>with the same name but without the suffix, it is renamed and the visibility is<br>updated with the value on the master region. Also the properties specified<br>in *obsolete_syncprops*, if any, are synchronised. The synchronisation of the<br>properties and the visibility is also managed when there is a image in the<br>region to synchronise that is already renamed but without the other changes<br>propagated.<br><br>There are some checks to do before propagating the changes of an<br>obsoleted image:<br><br>* Are the two images the same? The checksums are compared and only if they are<br>  the same the change is done.<br>* Is the image in the region to synchronise a public image of another tenant?<br>  in this case do not touch the image.<br>* Is there an image with the same name but without the suffix also in the<br>  master region and is synchronisable? In this case the image will be<br>  synchronised normally without taking in consideration the obsolete image.<br><br>Usually obsoleted images are made private, because are not supported anymore.<br>It is possible to restore an image as public for local use after renaming or changing<br>the tenant (to avoid that it is made private again automatically), but before this is<br>important to look out more about the security status of the image.<br><br>The treatment of obsolete images can be disabled for a *target* with<br>*support_obsolete_images=False*. This flag affects the image renaming and<br>the metadata updating, but anyway images with '_obsolete' suffix are never<br>synchronised.<br><br>Top_<br><br>Build and Install<br>=================<br><br>Requirements<br>------------<br><br>GlanceSync is designed to run with a mounting point with the images, because it<br>reads the images that are stored directly in the filesystem. Usually this<br>directory is /var/lib/glance/images.<br><br>The following software must be installed (e.g. using apt-get on Debian and Ubuntu,<br>or with yum in CentOS):<br><br>- Python 2.7<br>- pip<br>- virtualenv<br><br><br>Installation<br>------------<br><br>The recommend installation method is using a virtualenv. Actually, the installation<br>process is only about the python dependencies, because the python code do not need<br>installation.<br><br>1) Create a virtualenv 'glancesyncENV' invoking *virtualenv glancesyncENV*<br>2) Activate the virtualenv with *source glancesyncENV/bin/activate*<br>3) Install the requirements running *pip install -r requirements.txt<br>   --allow-all-external*<br><br>Now the system is ready to use. For future sessions, only the step2 is required.<br><br>Top_<br><br>Server Configuration<br>====================<br><br>There is the possibility to execute the glancesync like a service. You should<br>launch the server by executing the ``run.py`` process. You can see in the<br>Running section how to launch the server. In this section we explain the configuration<br>file that have to be defined to work with the GlanceSync Service. Last but not least<br>keep in bear that you will need also configure the client component if you want to launch<br>the core module of synchronization component.<br><br>GlanceSync server configuration file<br>------------------------------------<br><br>The server have to be launched with a configuration file. By default, the service<br>will take the values either from environment variables or from files located in<br>``/etc/fiware.d``. The name of the files MUST be ``fiware-glancesync.cfg`` and<br>``fiware-glancesync-logging.cfg``. The options that we take are the following:<br><br>1) In the first case, the application try to see if there is defined<br>the variables ``GLANCESYNC_SETTINGS_FILE``, ``GLANCESYNCAPP_DATABASE_PATH``,<br>``GLANCESYNCAPP_CONFIG`` and ``GLANCESYNC_LOGGING_SETTINGS_FILE``.<br>This environment variables will have the location of the configuration files, you can<br>specify them using the following commands<br><br>.. code::<br><br>  $ export GLANCESYNC_SETTINGS_FILE=/Users/foo/fiware-glancesync/app/settings/fiware-glancesync.cfg<br>  $ export GLANCESYNC_LOGGING_SETTINGS_FILE=/Users/foo/fiware-glancesync/app/settings/fiware-glancesync-logging.cfg<br>  $ export GLANCESYNCAPP_DATABASE_PATH=/Users/foo/glancesyncENV/lib/python2.7/site-packages/<br>                                       fiware_glancesync.egg/fiwareglancesync/<br>  $ export GLANCESYNCAPP_CONFIG=/Users/foo/glancesyncENV/lib/python2.7/site-packages/<br>                                       fiware_glancesync.egg/fiwareglancesync/app/config.py<br><br>2) If the ``GLANCESYNC_SETTINGS_FILE`` and ``GLANCESYNC_LOGGING_SETTINGS_FILE``<br>environment variables are not presented, the application will try to obtain the<br>files from the directory ``/etc/fiware.d``<br><br>If no one of the previos option is accomplished the server will launch an error message<br>like the following:<br><br>.. code::<br><br>  ERROR: There is not defined GLANCESYNCAPP_CONFIG environment variable<br>         pointing to config.py path file<br>         Please correct at least one of them to execute the program.<br><br>  ERROR: There is not defined GLANCESYNCAPP_DATABASE_PATH environment variable<br>         pointing to database path file<br>         Please correct at least one of them to execute the program.<br><br>  ERROR: There is neither defined GLANCESYNC_LOGGING_SETTINGS_FILE environment variable pointing<br>         to fiware-glancesync-logging.cfg nor /etc/fiware.d/etc/fiware-glancesync-logging.cfg<br>         file. Please correct at least one of them to execute the program.<br><br>  ERROR: There is neither defined GLANCESYNC_SETTINGS_FILE environment variable<br>         pointing to fiware-glancesync.cfg nor /etc/fiware.d/etc/fiware-glancesync.cfg<br>         file. Please correct at least one of them to execute the program.<br><br>Configure your own configuration files<br>--------------------------------------<br><br>The GlanceSync server has two configuration files:<br><br>* fiware-glancesync.cfg, this is the important one to configure the service and need some modifications<br>* fiware-glancesync-logging.cfg, this file is used to configure the logging system, it is not needed to<br>change the content that we have defined by default in the publication of the component.<br><br>Related to the first file, how we have mentioned, there is some parameters that have to be configured in<br>order to execute correctly the service. For obvious reason they are not included in the repository:<br><br>- **KEYSTONE_URL**, service endpoint of the Keystone service in FIWARE Lab (it usually comes defined in<br>the installation of the component.<br><br>- **ADM_USER**, admin user in Keystone.<br><br>- **ADM_PASS**, password of the admin user<br><br>- **ADM_TENANT_ID**, tenant id of the admin user.<br><br>- **ADM_TENANT_NAME**, tenant name of the admin user (you have to provide either ADM_TENANT_ID or ADM_TENANT_NAME).<br><br>- **USER_DOMAIN_NAME**, user domain name, by default for an administrator account you can use the value ``Default``.<br><br>Top_<br><br><br>Client Configuration<br>====================<br><br>Working without a configuration file<br>------------------------------------<br><br>The tool can work without a configuration file or with an empty one. In this<br>case, the following OpenStack environment variables must be filled with the<br>administrator's credential: ``OS_USERNAME``, ``OS_PASSWORD``, ``OS_AUTH_URL``,<br>``OS_TENANT_NAME``, ``OS_REGION_NAME``. The value of ``OS_REGION_NAME`` will be<br>the master region (in FIWARE Lab this region is Spain2).<br><br>It is also possible to pass any configuration option using command line. For<br>example, the following invocation runs a synchronisation taking from command<br>line the parameters *master_region* in the *main* section and *metadata_set* in<br>the *DEFAULT* section:<br><br>.. code::<br><br> ./sync.py --config main.master_region=Spain2 metadata_set=nid,type,sdc_aware,sdc_version<br><br>It is important to note that *--config* parameter expect any number of parameters<br>separated by spaces. This is a problem if the list of regions are specified<br> *after* the *--config* parameter, because then the regions are parsed as part<br>of the *--config* parameter. The solution is passing the regions *before* the<br>parameter or using the standard separator *--*:<br><br>.. code::<br><br>  # Wrong: region1 and region2 are interpreted as part of --config param<br>  ./sync.py --config main.master_region=Spain2 region1 region2<br>  # Ok<br>  ./sync.py --config main.master_region=Spain2 -- region1 region2<br>  # Ok<br>  ./sync.py region1 region2 --config main.master_region<br><br>The configuration file<br>----------------------<br><br>The configuration used by the GlanceSync component is stored in the<br>``/etc/fiware.d/glancesync.conf`` file. However, this path may be changed with the<br>environment variable *GLANCESYNC_CONFIG*.<br><br>The configuration file has a ``main`` section with some global configuration<br>parameters and one section for each target (regions are grouped by targets,<br>two regions are in the same targets if they use the same credential). The<br>``master`` section is the target where the master region is, that is, the region<br>where are located the images to synchronise to the other regions.<br><br>Most of the configuration is defined at target level. If the same values are<br>used in most or all the targets, an option is to set them in the DEFAULT section.<br><br>The only mandatory settings in the target sections, is the credential. It may be<br>provided in two ways (in the case of ``master`` also it is possible to use<br>the environment variables as explained in the previous section, even it is<br>possible to combine both methods, for example to set only the password via<br>environment variable):<br><br>* using the credential option. There are four values separated by commas: the<br>  first is the user, the second is the password encoded with base64, the third<br>  is the keystone URL and the fourth, the tenant name.<br>* using the options *user*, *password*, *tenant*, *keystone_url*.<br><br>If credentials are stored in the configuration file, it is convenient to<br>make the file only readable by the user who invokes GlanceSync.<br><br>Example of a configuration file<br>_______________________________<br><br>The following is an example of a configuration file, with all the possible<br>options auto explained in the comments. A configuration file like this can be<br>generated invoking *fiwareglancesync/script/generated_config_file.py*<br><br>.. glancesync_conf_begin<br>.. code::<br><br> [main]<br><br> # Region where are the images in the \"master\" target that are synchronised to<br> # the other regions of \"master\" regions and/or to regions in other targets.<br> master_region = Spain<br><br> # A sorted list of regions. Regions that are not present are silently<br> # ignored. Synchronization is done also to the other regions, but first this<br> # list is revised and then the Regions are prefixed with \"target:\"<br> # This parameter is only used when running synchronisation without parameters<br> # or the region list includes a 'target' (e.g. 'master:' that is expanded to<br> # the regions in master but the specified in ignore_regions). When the full region<br> # list is provided explicitly via command line, the order of<br> # the parameters is used instead.<br> preferable_order = Trento, Lannion, Waterford, Berlin, Prague<br><br> # The maximum number of simultaneous children to use to do the synchronisation.<br> # Each region is synchronised using a children process, therefore, this<br> # parameter sets how many regions can be synchronised simultaneously.<br> # The default value, max_children = 1, implies that synchronisation is fully<br> # sequential. Be aware that you need also to invoke the sync tool with the<br> # --parallel parameter.<br> #<br> max_children = 1<br><br> # The folder where the master images are (the filename is the UUID of the<br> # image in the master region). The default value is the folder where the<br> # Glance server stores the images.<br> images_dir = /var/lib/glance/images<br><br> [DEFAULT]<br><br> # Values in this section are default values for the other sections.<br><br> # the files with this checksum will be replaced with the master image<br> # parameter may be any or a CSV list (or a CSV list with 'any' at the end),<br> # the checksum is the value in the destination glance service.<br> # replace = 9046fd22131a96502cb0d85b4a406a5a<br><br> # the files with this checksum will be replaced with the master image,<br> # but the old image will be preserved renamed (using same name, but with<br> # .old extension) and made private. The checksum is the value in the<br> # destination glance service.<br> # parameter may be any or a CSV list (or a CSV list with 'any' at the end)<br> # rename = any<br><br> # If replace or rename is any, don't update nor rename images with some of<br> # these checksums. The checksum is the value in the destination glance service.<br> # dontupdate =<br><br> # List of UUIDs that must be synchronised unconditionally.<br> #<br> # This is useful for example to pre-sync images marked as private<br><br> forcesyncs = 6e240dd4-e304-4599-b7d8-e38e13cef058<br><br> # condition to evaluate if the image is synchronised.<br> # image is defined, as well as metadata_set (see next parameter).<br> # Default condition is:<br> #  image.is_public and (not metadata_set or metadata_set.intersection(image.user_properties))<br><br> metadata_condition = image.is_public and\\<br>  ('nid' in image.user_properties or 'type' in image.user_properties)<br><br> # the list of userproperties to synchronise. If this variable is undefined, all<br> # user variables are synchronised.<br> metadata_set = nid , type, sdc_aware, nid_version<br><br> # When the software asks for the list of images in a region, it gets both the<br> # images owned by the tenant and the public images owned by other tenants.<br> # If this parameter is true (the default and recommended value), only the<br> # tenant's images are considered. This implies that it can exist after the<br> # synchronisation a new image with the same name that a public one from other<br> # user. It could be very confusing (actually, a warning is printed when it is<br> # detected), but usually it is not recommend to work with images from other<br> # tenants. To find out more about this, see 'About UUIDs and image names' in<br> # the documentation.<br> #<br> # This parameter only affects to the list of images obtained from the regional<br> # servers. From master region only the tenant's images are considered.<br> only_tenant_images = True<br><br> # When this option is true (the default), the renaming and metadata updating of<br> # obsolete images is activate. See the documentation for details.<br> support_obsolete_images = True<br><br> # These are the properties that are synchronised (in addition to is_public<br> # and the name) in obsolete images, when support_obsolete_images is True.<br> obsolete_syncprops = sdc_aware<br><br> # Timeout to get the image list from a glance server, in seconds. Default<br> # value is 30 seconds.<br> list_images_timeout = 30<br><br> # API required to contact with the keystone server. If this parameter is True,<br> # then version 3 of the API is used. Otherwise, the version 2 is used<br> use_keystone_v3 = False<br><br> [master]<br><br> # This is the only mandatory target: it includes all the regions registered<br> # in the same keystone server than the master region.<br> #<br> # credential set: user, base64(password), keystone_url, tenant_name<br> # as alternative, options user, password, keystone_url and tenant can be used<br> # only with master target, it is possible also to set the credential using<br> # OS_USERNAME, OS_PASSWORD, OS_TENANT_NAME, OS_AUTH_URL (or even mixing this<br> # environment variables with parameters user, password, etc.)<br> credential = user,W91c2x5X2RpZF95b3VfdGhpbmtfdGhpc193YXNfdGhlX3JlYWxfcGFzc3dvcmQ/,http://server:4730/v2.0,tenantid1<br><br> # This parameter is useful when invoking the tool without specifying which<br> # images to synchronise or when the list includes a \"target\" without a region<br> # (e.g. master:). In this case it is expanded with the list of regions in that<br> # target except the included in ignore_regions<br> ignore_regions = Spain1<br><br> [experimental]<br><br> # Another<br> credential = user2,W91c2x5X2RpZF95b3VfdGhpbmtfdGhpc193YXNfdGhlX3JlYWxfcGFzc3dvcmQ/,http://server2:4730/v2.0,tenantid2<br> metadata_condition = image.is_public and image.user_properties.get('type', None) == 'baseimages'<br><br>.. glancesync_conf_end<br><br>This configuration file defines two *targets*: ``master`` and ``experimental``. The first one<br>synchronises all the public images with properties *nid* and/or *type* defined. The last one only<br>synchronises images with ``type=baseimages``<br><br>Security consideration<br>----------------------<br><br>GlanceSync does not require *root* privileges. But at this version it requires<br>read-only access to image directory ``/var/lib/glance/images`` (or making<br>available a copy of all these files, or at least the subset that may be<br>synchronised, in other path and then set the option *images_dir*)<br><br>It is strongly recommended:<br><br>* creating an account to run GlanceSync only<br>* creating a configuration file only readable by the GlanceSync account. This<br>  is because the credentials should not be exposed to other users.<br><br>Top_<br><br><br>Client Running<br>==============<br><br>Basic use<br>---------<br><br>Once installed all the dependencies, there is a way to run GlanceSync manually<br>from the command line invoking the ``sync.py`` tool inside the GlanceSync<br>distribution.<br><br>When ``./sync.py`` is invoked without parameters, it synchronises the images from<br>the master region to all the other regions with a glance endpoint registered in<br>the keystone server (except the ones, if any, specified as a comma separated list<br>in the ``ignore_regions`` parameter, inside the ``master`` section). The command<br>can also receive as parameters the regions to synchronise. It is possible also<br>to specify a target name and the suffix *:*; this way it is expanded to all the<br>regions in that target (e.g. if there are two regions, *regionA* and *regionB* in<br>target *target1*, then *target1:* is expanded with *target1:regionA target1:regionB*)<br><br>Advanced use<br>------------<br><br>By default, GlanceSync synchronises regions one by one. When the command line<br>option *--parallel* is passed, GlanceSync synchronised several regions in<br>parallel. The number or regions synchronised at the same time is determined by the<br>parameter max_children in the main section. Default value is 1 (no parallel).<br>When synchronisation runs on parallel, a directory with the pattern<br>*sync_&lt;year&gt;&lt;month&gt;_&lt;hour&gt;&lt;minute&gt;* is created. Inside this, it is a file for each<br>region with the log of the synchronisation process.<br><br>The option *--dry-run* shows the changes needed to synchronise the images,<br>but without doing the operations actually.<br><br>The option *--show-regions* shows all the regions available in all the targets<br>defined in the configuration file.<br><br>The option *--make-backups* creates a backup of the medatada of the images<br>in the regional Glance servers, instead of running the synchronisation.<br><br>It is possible to override any parameter of the configuration file, using the<br>option *--config*. Be aware that the way of setting several parameters is<br>separating them with spaces (e.g. *--config option1=value1 option2=value2*)<br><br>Finally, the option *--show-status* is to obtain a report about the<br>synchronisation status of the regions. A more detailed information of this is<br>provided in the *Checking status* section.<br><br>As pointed, GlanceSync can synchronised also from the master region to regions<br>that do not use the same keystone server. A *target* is a namespace to refer to<br>the regions sharing a credential. The ``master`` target is the one<br>where the master region is. Each target has a section with its name in the<br>configuration file, to specify the credential and optionally other configuration<br>(most of the parameters are local to each target).<br><br>The way to synchronise to regions that are in other *target*, is to specified<br>the region with the preffix ``&lt;target_name&gt;:``. For example, to synchronise to region<br>Trento and Berlin2, both in the same keystone server than the master region,<br>but also to RegionOne and RegionTwo, registered in target *other* the<br>following command must be invoked:<br><br>.. code::<br><br>   ./sync.py Trento Berlin2 other:RegionOne other:RegionTwo<br><br>Note that the *master:* prefix may be omitted.<br><br>Making a backup of metadata<br>---------------------------<br><br>The option *--make-backups* create a backup of the metadata in the specified<br>regions and in the master region. This is useful for example for<br>debugging or testing, because GlanceSync supports the use of a mock that reads<br>files likes these as input instead of contacting to the real servers. The mock<br>is also used for testing real scenarios.<br><br>The backup is created in a directory named *backup_glance_* with the date and<br>time as suffix. There is a file for each region (the name is backup_&lt;region&gt;.csv)<br>and inside the file a line for each image. The following fields are included:<br><br>* the region name<br>* the image name<br>* the UUID of the image in the region<br>* the status of the image (the OK status is 'active')<br>* the size in bytes<br>* the checksum<br>* the tenant id of the owner (a.k.a. project id)<br>* a boolean indicating if the image is Public<br>* a dictionary with the user properties<br><br>Only the information about public images/ the images owned by the tenant, can<br>be obtained. This is a limitation of the glance API: even the administrator<br>does not get a list of private images of other users.<br><br>Using a mock with a backup<br>__________________________<br><br>.. _mock:<br><br>It is possible to use the result of a backup (optionally after changing the<br>contents) for testing different scenarios.<br><br>Supposing the backup directory *backup_glance_2015-11-17T12:54:26.117838* is<br>renamed to *scenario1*. After invoking this line, instead of operating with<br>the real servers, a mock with metadata saved in *persistent_data* folder is<br>used:<br><br>.. code::<br><br>  eval $(glancesync/glancesync_serverfacade_mock.py  --path persistent_data scenenario1)<br>  export PYTHONPATH=glancesync<br><br>The created scenario is persistent, that is, is possible to invoke *sync.py --show-status*<br>before and after running the synchronisation for checking that the state has<br>changed.<br><br>The mock uses as tenant_id (this is important to compare the owner of the files)<br>the paremeter *tenant_id* if defined in the configuration, otherwise *id* is<br>added to the tenant_name as suffix.<br><br>To make test results deterministic, when a new image is created in the mock, the<br>UUID is not random. The UUID's pattern is *&lt;seq&gt;$&lt;image_name&gt;* where seq is a number<br>starting with 1 that guarantees the UUID uniqueness.<br><br>Checking status<br>---------------<br><br>In order to check the status of the synchronisation, use the following command:<br><br>.. code::<br><br>   ./sync.py --show-status<br><br>This print the status of all the regions in the *master* target, that is, the<br>region in the same keystone server than the master region. If ``ignore_regions``<br>is defined in the *master* configuration section, the specified regions are<br>ignored.<br><br>Of course is also possible to check the status of any group of regions, for<br>example, the call:<br><br>.. code::<br><br>   ./sync.py --show-status Trento Mexico Gent target2:Region1 target2:Region2<br><br>It will show the status of the regions Trento, Mexico, Gent both in the *master*<br>target, and the regions Region1 in Region2 defined in the *target2* target.<br><br>The output of command is a line for each image to be synchronised for each<br>region. That is, in the last example, if 15 images are synchronised to the<br>regions of *master* and 10 images to the regions of *target2*, then a total<br>of 15*3 + 10*2 images are printed.<br><br>Each line is a CSV. The first field is the synchronisation status, the<br>seconds is the region's name, and the third is the image name. This is an<br>example:<br><br>.. code::<br><br> ok,Prague,base_centos_6<br> ok,Prague,base_ubuntu_14.04<br> ok,Prague,base_ubuntu_12.04<br> ok,Prague,base_debian_7<br> ok,Prague,base_centos_7<br> pending_upload,experimental:Valladolid,base_centos_7<br><br>The synchronisation status can be classified in three categories: final status,<br>error status and pending synchronisation status.<br><br>Final status<br>____________<br><br>GlanceSync consider that there is no pending operations: the image is<br>synchronised or marked as 'dontupdate'.<br><br>* ok: the image is fully synchronised<br>* ok_stalled_checksum: the image has a different checksum than master,<br>  but this checksum is included in parameter 'dontupdate'. Therefore the image<br>  will not be updated (content nor metadata)<br><br>Error status<br>____________<br><br>There is an error condition that requires user intervention before trying<br>again.<br><br>* error_checksum: there is an image, but with a different checksum and<br>  there is not a matching dontupdate, rename or replace directive. Action<br>  required: fill the checksum (or use any) with *dontupdate* or *rename* or<br>  *replace*.<br>* error_ami: the image requires a kernel or ramdisk that is not in the<br>  list of images to sync. Action required: ensure that the selection criteria<br>  include the kernel/ramdisk images.<br><br>Pending synchronisation status<br>______________________________<br><br>The image needs synchronisation. Be aware that perhaps the image is on a<br>pending status although GlanceSync execution has completed, because the glance<br>server responded with an error. However, this is yet considered a pending status<br>and not an error status, because it is not a problem that users must resolve by<br>themselves.<br><br>* pending_metadata: there is an image with the right content (checksum), but<br>  metadata must be updated (this may include ramdisk_id and kernel_id)<br>* pending_upload: the image is not synchronised; it must be upload<br>* pending_replace: there is an image, but with different checksum. The<br>  image will be replaced<br>* pending_rename: there is an image, but with different checksum. The<br>  image will be replaced, but before this the old image will be renamed<br>* pending_ami: the image requires a kernel or ramdisk image that is in state<br>  *pending_upload*, *pending_replace* or *pending_rename*.<br><br>How use glancesync without access to images files<br>-------------------------------------------------<br><br>At the moment, GlanceSync is designed to run in the glance server of the master<br>region, because it reads the images that are stored directly in the filesystem.<br><br>This may be an inconvenience, but a real issue is when the Glance backed does not<br>use plain files (e.g. the Cepth backend) and therefore GlanceSync cannot read<br>the files even when it is running at the glance server.<br><br>The following script can be used to pre-download the images required to<br>synchronise the indicated regions to the folder specified by environment<br>variable *GLANCE_IMAGES* (by default, ``/var/lib/glance/images``) and then<br>run the synchronisation:<br><br>.. code::<br><br> #!/bin/bash<br><br> print_required_images_names() {<br>   ./sync.py --show-status $* | awk -v ORS=\" \" -F, \\<br>    '/^pending_(upload|rename)/ {words[$3]++}<br>    END { for (i in words) print substr(i,1, length(i)-1) }'<br> }<br><br> get_id_from_name() {<br>  glance image-show $1 | awk -F\\| \\<br>  ' $2 ~ /^[ ]*id/ { sub(/[ ]+/,\"\",$3) ; print $3}'<br> }<br><br> GLANCE_IMAGES=${GLANCE_IMAGES:-/var/lib/glance/images}<br><br> # First, download the required images to $GLANCE_IMAGES<br> for name in $(print_required_images_names $*) ;<br> do<br>   id=$(get_id_from_name $name)<br>   echo $name $id<br>   if [ ! -f $GLANCE_IMAGES/$id ] ; then<br>     glance image-download --file $GLANCE_IMAGES/$id --progress $id<br>   fi<br> done<br><br> # run synchronisation<br> ./sync.py $* --config images_dir=$GLANCE_IMAGES<br><br><br>Top_<br><br>Server Running<br>==============<br><br>There is several options to execute the GlanceSync server from the command line. You<br>can obtain information of the different options running form the command line the following<br>command:<br><br>.. code::<br><br>    $ python run.py<br><br>    usage: run.py [-h] {gunicornserver,shell,db,runserver} ...<br><br>    positional arguments:<br>      {gunicornserver,shell,db,runserver}<br>        gunicornserver      Run the GlanceSync server application within Gunicorn.<br>        shell               Runs a Python shell inside Flask application context.<br>        db                  Perform database migrations<br>        runserver           Runs the Flask development server i.e. app.run()<br><br>    optional arguments:<br>      -h, --help            show this help message and exit<br><br>We go into details about the db, runserver and gunicornserver options.<br><br>Database configuration<br>----------------------<br><br>If it is the first time that you use the component or if you need to make an upgrade of the database<br>schemas, you will need to execute the commands related to the database management. You can obtain a<br>help of the different operations just executing:<br><br>.. code::<br><br>    $ python run.py db -h<br>    usage: Perform database migrations<br><br>    Perform database migrations<br><br>    positional arguments:<br>      {upgrade,heads,merge,migrate,stamp,show,current,edit,init,downgrade,branches,history,revision}<br>        upgrade             Upgrade to a later version<br>        heads               Show current available heads in the script directory<br>        merge               Merge two revisions together. Creates a new migration<br>                            file<br>        migrate             Alias for 'revision --autogenerate'<br>        stamp               'stamp' the revision table with the given revision;<br>                            don't run any migrations<br>        show                Show the revision denoted by the given symbol.<br>        current             Display the current revision for each database.<br>        edit                Edit current revision.<br>        init                Generates a new migration<br>        downgrade           Revert to a previous version<br>        branches            Show current branch points<br>        history             List changeset scripts in chronological order.<br>        revision            Create a new revision file.<br><br>    optional arguments:<br>      -h, --help            show this help message and exit<br><br>This allows you to keep a revision of the database that we are using. The first time that you use<br>the component you will need to create the database repository and initialize the revision of it. It<br>can be done with the following commands (in order):<br><br>.. code::<br><br>    $ python run.py db init<br>    $ python run.py db migrate<br>    $ python run.py db upgrade<br><br><br>Run basic server<br>----------------<br><br>Once that we have initialized the database, we can launch the application, there is two possibilities.<br>In this section, we see the easy way to launch the application running basically a python process.<br>You can obtain help of the operation just executing:<br><br>.. code::<br><br>    $ python run.py runserver -h<br>    usage: run.py runserver [-h] [-t HOST] [-p PORT] [--threaded]<br>                            [--processes PROCESSES] [--passthrough-errors] [-d]<br>                            [-r]<br><br>    Runs the Flask development server i.e. app.run()<br><br>    optional arguments:<br>      -h, --help            show this help message and exit<br>      -t HOST, --host HOST<br>      -p PORT, --port PORT<br>      --threaded<br>      --processes PROCESSES<br>      --passthrough-errors<br>      -d, --no-debug<br>      -r, --no-reload<br><br>How you can see almost all arguments are optionals, the HOST and PORT are defined in the ``fiware-glancesync.cfg``<br>file. You can execute the server just executing:<br><br>.. code::<br><br>    $ python run.py runserver<br><br><br>Run Gunicorn server<br>-------------------<br><br>There is the possiblity to launch the service behind a Gunicorn HTTP Server. `Gunicorn`_ 'Green Unicorn' is a<br>Python WSGI HTTP Server for UNIX. You need to install this HTTP Server previously to execute the GlanceSync<br>service. Take a look to the Gunicorn site to see how to install it. Keep in bear that you should use a version<br>greater than 0.9.0.<br><br>After the installation of the HTTP server, you can execute the component. If you execute the following command<br>you can obtain detailed information about the options that you have:<br><br>.. code::<br><br>    $ python run.py gunicornserver -h<br>    usage: run.py gunicornserver [-h] [-H HOST] [-p PORT] [-w WORKERS]<br><br>    Run the GlanceSync server application within Gunicorn.<br><br>    optional arguments:<br>      -h, --help            show this help message and exit<br>      -H HOST, --host HOST  IP address or hostname of the Glancesync server.<br>      -p PORT, --port PORT  Port in which the GlanceSync server is running<br>      -w WORKERS, --workers WORKERS<br>                            Number of concurrent workers to be launched, usually<br>                            2*core numbers+1.<br><br>By default, HOST, PORT and WORKERS are defined in the configuration file, it is not necessary to specify them<br>again here. So to run the service, just write the following line:<br><br>.. code::<br><br>    $ python run.py gunicornserver -h<br><br><br>Logging files<br>-------------<br><br>The current version of the GlanceSync service produce logging files that will be located in the sam directory<br>of the application where you launch the application. It is defined with log rotate with allow to control the<br>extension of the file. You can see details of the configuration of the log file in the ``fiware-glancesync-logging.cfg``<br>file. By default it will be named with **glancesync-api.log**. The sucessive rotate files will be numered adding<br>a string from '.1' to '.3' to the previous file name (e.g. glancesync-api.log.1).<br><br>Top_<br><br>API Overview<br>============<br>The GlanceSync offers a REST API, which can be used for synchronizing images<br>in different regions. Please have a look at the API Reference Documentation section<br>bellow.<br><br>API Reference Documentation<br>---------------------------<br><br>- `FIWARE GlanceSync v1 (Apiary) &lt;http://docs.glancesync.apiary.io/&gt;`_<br><br>Top_<br><br><br>Testing<br>=======<br><br>Ent-to-end tests<br>----------------<br><br>To run the end-to-end tests, go to ``test/acceptance`` folder and run:<br><br>.. code::<br><br>    behave features/ --tags ~@skip<br><br>Please, be aware that this tests requires preparing a environment, including<br>at least three glance servers and two keystone servers. Have a look to the<br>``test/acceptance/README.rst`` in order to get more information about how to<br>prepare the environment to run the functional_test target.<br><br><br>Ent-to-end tests with Docker execution<br>______________________________________<br>Glancesync acceptance tests can be executed by Docker. To do that, firstly it is required to create the required docker images (fiware-glancesync and<br>fiware-glancesync-acceptance).<br>To do that:<br><br>.. code::<br><br>    docker build -t fiware-glancesync -f docker/Dockerfile docker<br>    docker build -t fiware-glancesync-acceptance -f docker/AcceptanceTests/Dockerfile docker/AcceptanceTests<br><br>Once the images have been created, we can run the acceptance tests it by using docker-compose (to include the environment variables). To export then is required:<br><br>.. code::<br><br>    export OS_AUTH_URL = {the auth uri of the testbed agains the tests are going to be execute}<br>    export OS_USERNAME = {the user name}<br>    export OS_TENANT_NAME = {the tenant name}<br>    export OS_PASSWORD = {the password}<br>    export OS_REGION_NAME = {the region}<br>    export OS_PROJECT_DOMAIN_NAME = {the project domain name}<br>    export OS_USER_DOMAIN_NAME = {the user domain name}<br>    export KEYSTONE_IP = {The keystone ip where testbed is deployed}<br>    export Region1 = {The region name 1 for tests}<br>    export Region2 = {The region name 2 for tests}<br>    export Region3 = {The region name 3 for tests}<br>    docker-compose -f docker/docker-compose.yml up<br><br>When docker has finished, you can obtain the tests results by<br>.. code::<br><br>   docker cp docker_fiwareglancesync-acceptance:/opt/fiware/glancesync/tests/acceptance/testreport .<br><br><br>Unit tests<br>----------<br>To run the unit tests, you need to create a virtualenv using the requirements<br>both contained in requirements.txt and test-requrirements.txt. You only need to<br>execute the nosetests program in the root dorectory of the fiware-glancesync<br>code. Keep in mind that it requires python2.7 or superior to execute the unit<br>tests.<br><br>.. code::<br><br>     virtualenv -p &lt;root to python v2.7&gt; venv<br>     source ./venv/bin/activate<br>     pip install -r requirements.txt<br>     pip install -r test-requirements.txt<br>     nosetests --exe<br>     deactivate<br><br>Eight tests are marked as skipped because they are more properly integration<br>test. They are in the file \u00b4\u00b4test_glancesync_serversfacade.py\u00b4\u00b4. The tested<br>module contains all the code that interacts with Glance and the tests do some<br>checks against a real glance server. To activate this eight tests, edit the file and<br>change testingFacadeReal to True. It needs the usual OpenStack environment<br>variables (*OS_USERNAME*, *OS_PASSWORD*, *OS_TENANT_NAME*, *OS_REGION_NAME*,<br>*OS_AUTH_URL*)<br><br>Unit tests with Docker execution<br>________________________________<br>Glancesync unit tests can be executed by docker. To do that, firstly it is required to create the docker image,<br>with the following command:<br><br>.. code::<br><br>    docker build -t fiware-glancesync-build -f docker/UnitTests/Dockerfile docker<br><br>Once the fiware-glancesync-build image is created, we can run it by:<br><br>.. code::<br><br>    docker run --name fiware-glancesync-build fiware-glancesync-build<br><br>Finally, it is possible to obtain tests results and coverage information by:<br><br>.. code::<br><br>    docker cp fiware-glancesync-build:/opt/fiware/glancesync/test_results .<br>    docker cp fiware-glancesync-build:/opt/fiware/glancesync/coverage .<br><br>Contributing new tests<br>----------------------<br><br>It is possible to contribute new tests defining a scenario in *tests/resources*<br>For a scenario 'new_scenario', the following folders must be created:<br><br>* new_scenario: there are files for each region with the backup of the metadata<br>                BEFORE invoking the synchronisation. These files can be generated<br>                with *sync.py --make-backup*<br>* new_scenario.result: there are files for each region with the backup of the<br>                       metadata AFTER invoking the synchronisation<br>* new_scenario.status_pre: there are files with the status of each region BEFORE invoking<br>                           the synchronisation. These files can be generated with the<br>                           output of *sync.py --show-status*<br>* new_scenario.status_post: there are files with the status of each region AFTER invoking<br>                            the synchronisation. These files can be generated with the<br>                            output of *sync.py --show-status*<br><br>Inside the forlder *new_scenario*, optionally a *config* file may be included.<br>If this file is not found, then the default configuration defined in the variable<br>*config1* of the test file \u00b4\u00b4tests/unit/test_glancesync.py\u00b4\u00b4 is used.<br><br>Then, a test class must be defined extending *TestGlanceSync_Sync*, for example:<br><br>.. code::<br><br>    class TestGlanceSync_AMI(TestGlanceSync_Sync):<br>        \"\"\"Test a environment with AMI images (kernel_id/ramdisk_id)\"\"\"<br>        def config(self):<br>            path = os.path.abspath(os.curdir)<br>            self.path_test = path + '/tests/unit/resources/ami'<br>            self.regions = ['master:Burgos']<br><br>This class is provided in \u00b4\u00b4tests/unit/test_glancesync.py\u00b4\u00b4.<br><br>More information about the mock: mock_<br><br>Top_<br><br><br>Support<br>=======<br><br>Ask your thorough programming questions using `stackoverflow`_ and your general questions on `FIWARE Q&amp;A`_.<br>In both cases please use the tag *fiware-health*<br><br>Top_<br><br><br>License<br>=======<br><br>\\(c) 2015 Telef\u00f3nica I+D, Apache License 2.0<br><br>Top_<br><br><br>.. IMAGES<br><br>.. |Build Status| image:: https://travis-ci.org/telefonicaid/fiware-glancesync.svg?branch=develop<br>   :target: https://travis-ci.org/telefonicaid/fiware-glancesync<br>   :alt: Build status<br>.. |StackOverflow| image:: https://img.shields.io/badge/support-sof-yellowgreen.svg<br>   :target: https://stackoverflow.com/questions/tagged/fiware-glancesync<br>   :alt: Help? Ask questions<br>.. |Coveralls| image:: https://coveralls.io/repos/telefonicaid/fiware-glancesync/badge.svg?branch=develop&amp;service=github<br>   :target: https://coveralls.io/github/telefonicaid/fiware-glancesync?branch=develop<br>   :alt: Unit Tests coverage<br>.. |License Badge| image:: https://img.shields.io/badge/license-Apache_2.0-blue.svg<br>   :target: LICENSE<br>   :alt: Apache 2.0 License<br>.. |Docker badge| image:: https://img.shields.io/docker/pulls/fiware/glancesync.svg<br>   :target: https://hub.docker.com/r/fiware/glancesync/<br>   :alt: Docker Pulls<br>.. |Documentation Badge| image:: https://readthedocs.org/projects/fiware-glancesync/badge/?version=latest<br>   :target: http://fiware-glancesync.readthedocs.org/en/latest/?badge=latest<br><br>.. REFERENCES<br><br>.. _FIWARE: http://www.fiware.org<br>.. _github issues: https://github.com/telefonicaid/fiware-glancesync/issues/new<br>.. _stackoverflow: http://stackoverflow.com/questions/ask<br>.. _`FIWARE Q&amp;A`: https://ask.fiware.org<br>.. _`Gunicorn`: http://gunicorn.org/\n          </div>"}, "last_serial": 2410142, "releases": {"1.2.0": [], "1.2.0.1": [{"comment_text": "", "digests": {"md5": "95e698629bc6e74559197a9db62622c8", "sha256": "b69765758c096de3d673ad0de8fe0cbf8fff9efae67199843ec8ad6fc303722c"}, "downloads": -1, "filename": "fiware-glancesync-1.2.0.1.tar.gz", "has_sig": false, "md5_digest": "95e698629bc6e74559197a9db62622c8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 48941, "upload_time": "2016-02-01T10:45:15", "upload_time_iso_8601": "2016-02-01T10:45:15.412714Z", "url": "https://files.pythonhosted.org/packages/90/95/a9d053868ca1292fd917f7ab4760b36becd81a4ad5970bd177a335aeeaaa/fiware-glancesync-1.2.0.1.tar.gz", "yanked": false}], "1.2.0.2": [{"comment_text": "", "digests": {"md5": "b5ab432cb6fd4491d30204b449b4739b", "sha256": "a62be7fec77df9e75e5247b136b109b24b6206bdc81e1b42cbba6ccfc0d287c4"}, "downloads": -1, "filename": "fiware-glancesync-1.2.0.2.tar.gz", "has_sig": false, "md5_digest": "b5ab432cb6fd4491d30204b449b4739b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49149, "upload_time": "2016-02-01T11:45:11", "upload_time_iso_8601": "2016-02-01T11:45:11.832264Z", "url": "https://files.pythonhosted.org/packages/be/2d/52852cf51b2c1f49bb6ed74529550165efac459e8a4d0452d49ee018dde6/fiware-glancesync-1.2.0.2.tar.gz", "yanked": false}], "1.2.0.3": [{"comment_text": "", "digests": {"md5": "424783158aeb7f1f93b8ffe345a1842a", "sha256": "38e055d835955805c0fd3bc236cf12c6fe17a3ecc6850f760e02e7e1f86be60d"}, "downloads": -1, "filename": "fiware-glancesync-1.2.0.3.tar.gz", "has_sig": false, "md5_digest": "424783158aeb7f1f93b8ffe345a1842a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51446, "upload_time": "2016-02-01T12:15:10", "upload_time_iso_8601": "2016-02-01T12:15:10.228318Z", "url": "https://files.pythonhosted.org/packages/f6/24/12b91f260af4960ca8cfa92fa889fc300da48a3eb37e11da491caba6275f/fiware-glancesync-1.2.0.3.tar.gz", "yanked": false}], "1.2.0.4": [{"comment_text": "", "digests": {"md5": "4dfb092a495a108d446c369157e1cbed", "sha256": "8ad8ab7ded81134ef34b1897dea1310faba003234565109d933e334c0c8ecbd8"}, "downloads": -1, "filename": "fiware-glancesync-1.2.0.4.tar.gz", "has_sig": false, "md5_digest": "4dfb092a495a108d446c369157e1cbed", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51769, "upload_time": "2016-02-01T13:46:28", "upload_time_iso_8601": "2016-02-01T13:46:28.759212Z", "url": "https://files.pythonhosted.org/packages/2b/ad/79b42100a3b3a23a466855e45b0dee50dabda8157af56f2ae1f75fd7c805/fiware-glancesync-1.2.0.4.tar.gz", "yanked": false}], "1.2.0.5": [{"comment_text": "", "digests": {"md5": "efdc0c9b286575ebdc363244460fd45f", "sha256": "9c2130218334e050cc6f7c9a39799632ca3e57d6e867df5a23167737d7e7e0bc"}, "downloads": -1, "filename": "fiware-glancesync-1.2.0.5.tar.gz", "has_sig": false, "md5_digest": "efdc0c9b286575ebdc363244460fd45f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53879, "upload_time": "2016-02-01T14:04:19", "upload_time_iso_8601": "2016-02-01T14:04:19.317995Z", "url": "https://files.pythonhosted.org/packages/2b/61/d12b4af4f2192dabee7c7953cb4ad32c0d805b0bea17078a94b7048df7c8/fiware-glancesync-1.2.0.5.tar.gz", "yanked": false}], "1.2.0.6": [{"comment_text": "", "digests": {"md5": "91b7346c6e533f04e85cae8a613a646f", "sha256": "69b0a0ba84dfba2618dec2b47ba802ae4ea284bbd28ea39bdf3f5b3ccd8966c2"}, "downloads": -1, "filename": "fiware-glancesync-1.2.0.6.tar.gz", "has_sig": false, "md5_digest": "91b7346c6e533f04e85cae8a613a646f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53826, "upload_time": "2016-02-01T14:33:59", "upload_time_iso_8601": "2016-02-01T14:33:59.584744Z", "url": "https://files.pythonhosted.org/packages/a7/05/704533ff4a1831fa0951cba87fcc22a52b60c15ccf9e6bff367320faceb4/fiware-glancesync-1.2.0.6.tar.gz", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "1f4d04547196200cdaef38ac1e7c9eee", "sha256": "83e8957b5e757a0a060b0617e29112a3a9766abd58c5bf410895e870d5ae03ff"}, "downloads": -1, "filename": "fiware-glancesync-1.3.0.tar.gz", "has_sig": false, "md5_digest": "1f4d04547196200cdaef38ac1e7c9eee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52898, "upload_time": "2016-02-05T08:24:10", "upload_time_iso_8601": "2016-02-05T08:24:10.472837Z", "url": "https://files.pythonhosted.org/packages/b8/1c/3b191acf9f432daa7e843de7253d3a48504d767d6511e239bb55b13311f6/fiware-glancesync-1.3.0.tar.gz", "yanked": false}], "1.3.1": [{"comment_text": "", "digests": {"md5": "5c99bf491218d893c193ac8818a7809f", "sha256": "2612a0be8893c531d88cf2c26d8734e8d3872c2c6b5b00bd8d69e9bc9e4460d2"}, "downloads": -1, "filename": "fiware-glancesync-1.3.1.tar.gz", "has_sig": false, "md5_digest": "5c99bf491218d893c193ac8818a7809f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52880, "upload_time": "2016-02-05T08:38:08", "upload_time_iso_8601": "2016-02-05T08:38:08.004828Z", "url": "https://files.pythonhosted.org/packages/89/47/faca8a2fe045e813d6f29478be0157d2bbb9289751cfadca61edaa3d151c/fiware-glancesync-1.3.1.tar.gz", "yanked": false}], "1.3.2": [{"comment_text": "", "digests": {"md5": "155bba4bf1812ed4a04adfba4d4e190a", "sha256": "aa6c6c360d79d346252e972c12ac4301c627b4fb6b817b607add81ef4b463201"}, "downloads": -1, "filename": "fiware-glancesync-1.3.2.tar.gz", "has_sig": false, "md5_digest": "155bba4bf1812ed4a04adfba4d4e190a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52508, "upload_time": "2016-02-05T09:35:53", "upload_time_iso_8601": "2016-02-05T09:35:53.715852Z", "url": "https://files.pythonhosted.org/packages/55/36/bd8b5d899c0619b55d68977ac023666e20657b7b3291f9cce3580837a47c/fiware-glancesync-1.3.2.tar.gz", "yanked": false}], "1.3.3": [{"comment_text": "", "digests": {"md5": "cb9aac7d6d70dcdb6c6d8b08bdb8cda7", "sha256": "9a5b3feae96b69da013dae48a0083535e8d9da95b4f1f41f4ed2b0e33bcf8f4d"}, "downloads": -1, "filename": "fiware-glancesync-1.3.3.tar.gz", "has_sig": false, "md5_digest": "cb9aac7d6d70dcdb6c6d8b08bdb8cda7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52507, "upload_time": "2016-02-05T09:38:02", "upload_time_iso_8601": "2016-02-05T09:38:02.589912Z", "url": "https://files.pythonhosted.org/packages/14/8d/bd8b45c7aa7d5126f4950b4014c2029389ea7fd93fb9d97309709755e08a/fiware-glancesync-1.3.3.tar.gz", "yanked": false}], "1.3.5": [{"comment_text": "", "digests": {"md5": "dded23a44c4237b0cc0eb30d364919ed", "sha256": "70ee63e0f1dbfcef068ab0fd5d49f33653c52388beebd007e0e9121c9fa5ac36"}, "downloads": -1, "filename": "fiware-glancesync-1.3.5.tar.gz", "has_sig": false, "md5_digest": "dded23a44c4237b0cc0eb30d364919ed", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52603, "upload_time": "2016-02-05T11:07:21", "upload_time_iso_8601": "2016-02-05T11:07:21.659494Z", "url": "https://files.pythonhosted.org/packages/0b/95/a04d34ee96fdfe58eba074c4280402b62912ec2bb7144a2c5f9fc45583d0/fiware-glancesync-1.3.5.tar.gz", "yanked": false}], "1.7.0": [{"comment_text": "", "digests": {"md5": "559a93bd120b28505396a4225d63536d", "sha256": "708b21fbe76c79eff3b483124e81c0f7c5d39e13a6e677f2a985c6a53a1a402d"}, "downloads": -1, "filename": "fiware-glancesync-1.7.0.tar.gz", "has_sig": false, "md5_digest": "559a93bd120b28505396a4225d63536d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101406, "upload_time": "2016-10-19T11:07:27", "upload_time_iso_8601": "2016-10-19T11:07:27.791133Z", "url": "https://files.pythonhosted.org/packages/77/a0/e658178eb234a2ebcd1917615464d613bb6adb20af68ce8cf6b91373f3f1/fiware-glancesync-1.7.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "559a93bd120b28505396a4225d63536d", "sha256": "708b21fbe76c79eff3b483124e81c0f7c5d39e13a6e677f2a985c6a53a1a402d"}, "downloads": -1, "filename": "fiware-glancesync-1.7.0.tar.gz", "has_sig": false, "md5_digest": "559a93bd120b28505396a4225d63536d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101406, "upload_time": "2016-10-19T11:07:27", "upload_time_iso_8601": "2016-10-19T11:07:27.791133Z", "url": "https://files.pythonhosted.org/packages/77/a0/e658178eb234a2ebcd1917615464d613bb6adb20af68ce8cf6b91373f3f1/fiware-glancesync-1.7.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:42:03 2020"}