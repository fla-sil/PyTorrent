{"info": {"author": "Alan Palazzolo (MinnPost), Tom Nehil (MinnPost)", "author_email": "apalazzolo@minnpost.com, tnehil@minnpost.com", "bugtrack_url": null, "classifiers": [], "description": "# Election Night API\n\nA set of tools, configurations, and instructions to collect and serve election results on election night - the Super Bowl of data news - while still providing an off-season service and focusing on saving resources as much as possible.\n\nThis is aimed at small to medium orgs that cannot afford services like AP or Reuters elections, or orgs that need more local results. This works best with states that have an election night feed.\n\nThe architecture of this application is based on [ScraperWiki](https://scraperwiki.com), a platform for scraping and serving data.  The main reason for this is so that on or around election night, an organization can run its own server with high resources, while using the [free](https://scraperwiki.com/pricing) (for [journalists](https://wordpress.scraperwiki.com/solutions/data-journalism/)) infrastructure of ScraperWiki the rest of the year.\n\nThere are two parts to the API.\n\n## The scraper tool\n\nThe `bin/ena` command is a wrapper to run each state's scraper methods. Different scraper methods can be run on differing schedules to account for how often data is updated in a given state.\n\n* Get help on command: `bin/ena -h`\n* Update results for the newest election in MN: `bin/ena MN results`\n* Update areas data for specific election in MN: `bin/ana MN areas -e 20141104`\n\n## The API\n\nThe API allows for arbitrary SQL selects of the data and returns JSON. This means it is easy to get at whatever data is needed for display on a website or other application. There are 3 possible servers you may be using.\n\n* For development, you can use the Local API server (see below).\n* For production, i.e. election night, see the Deploy instructions below.\n* During off-season, you can save money by using ScraperWiki\n\nThough the URL will change a bit, the `?q=` paramater will still be in the input mechanism for the query. Here are some examples.\n\n* Get all contests: `/?q=SELECT * contests`\n* Get a specific contest with results: `/?q=SELECT * FROM contests AS c JOIN results AS r ON c.id = r.contest_id AND c.state = r.state AND s.election = r.election WHERE c.id = 'some-contest-id'`\n\n\n## Install\n\n### Prerequisites\n\nYou may have the following already installed.\n\n1. Install [Git](http://git-scm.com/).\n1. Install [Python](https://www.python.org/downloads/).\n    * Most systems already have Python installed.\n1. Install [libxml](http://xmlsoft.org/).\n    * On a Mac, this should be installed with XCode developer tools: `xcode-select --install`\n1. (optional) Use [virtualenv](http://virtualenv.readthedocs.org/en/latest/) and [virtualenvwrapper](http://virtualenvwrapper.readthedocs.org/en/latest/install.html)\n    1. `pip install virtualenv virtualenvwrapper`\n        * This may need to be run with `sudo`; you should be able to tell if you get a permission error.\n        * To get virtualenvwrapper to load on startup, do the following, though if you have a  non-standard Python install or are not on a bash system, see [full instructions](http://virtualenvwrapper.readthedocs.org/en/latest/install.html). `echo \"export WORKON_HOME=$HOME/.virtualenvs\" >> ~/.bash_profile && echo \"export PROJECT_HOME=$HOME/Devel\" >> ~/.bash_profile && echo \"source /usr/local/bin/virtualenvwrapper.sh\" >> ~/.bash_profile && source ~/.bash_profile`\n\n### Get code and install dependencies\n\n1. Get the code and change to directory: `git clone https://github.com/MinnPost/election-night-api.git && cd election-night-api`\n1. (optional) Make a virtualenv to work in: `mkvirtualenv election-night-api`\n1. Install libraries: `pip install -r requirements.txt`\n\n## Development\n\n### Local API\n\nFor testing purposes, it is probably easier to use the lightweight, not production ready, local API application.\n\n1. Scrape some data with the [scraper tool](#the-scraper-tool).\n1. Run local API with: `python tests/local_api.py`\n1. Make requests similar to: `http://localhost:5000/?q=SELECT * FROM contests LIMIT 10`\n\n### Adding or managing a state\n\nThe data you need to scrape will vary from state to state, though there are some basics (see **Writing a scraper** and **Data modeling** below) and specific files and names that need to be followed. The best way to start is to copy the example and look at the comments in the file.\n\n1. Copy example: `cp -r states/example states/xx`\n1. The `xx_meta.py` file manages each information and configuration about each election in the state.  Create the configuration as is needed for your state; there are only a couple required field.\n    1. Rename `example_meta.py` to `xx_meta.py`\n    1. Change the Election ID. Suggested format is date of the election in the form YYYYMMDD\n    1. (optional) The URL to the election results file can go in here.\n1. The `xx.py` holds the `Scraper` class which has the methods that are run through the command line tool.  Most of this will be specific to your state and source.\n    1. Rename `example.py` to `xx.py`\n    1. Make sure to call `utility.setup()` in the constructor.\n1. The `test_xx.py` file is to hold tests to help unit test your files.\n    1. Rename `test_example.py` to `test_xx.py`\n\nYou need to write code to translate the election results file provided by your Secretary of State or State Elections Board into a set of data fields that can be stored in the database. Since election results file formats vary widely from state to state, each state will require a custom approach, but below are some general guidelines for writing the scraper.\n\n#### Examine data\n\nSpend time becoming familiar with your state's election files by studying example files or files from recent elections. Are the results provided for the entire race or by precinct? Does each race have a unique identifier? Does each candidate? What results data is provided \u2014\u00a0raw vote totals, vote percentage or both?\n\n#### Unique IDs\n\nAt a minimum, each choice in the election (e.g. candidates and ballot question responses)  and each contest must have unique identifiers. In some cases, these will already exist in a single field in the results file and can be read into your scraper (have care to verify that the IDs are in fact unique). If no single field contains a unique identifier, you will need to construct one from the data fields inside your scraper. For example, in the Minnesota scraper, we construct an ID string for each contest by combining fields for state, county, precinct district and office:\n\n  ```\n  #id-State-County-Precinct-District-Office\n  base_id = 'id-' + row[0] + '-' + row[1] + '-' + row[2] + '-' + row[5] + '-' + row[3]\n  ```\n\nFor more information on required fields, see **Data modeling** below.\n\n#### Read the file\n\nIn general, you'll want to iterate through your file, manipulate the data to match the required data fields, and save those results, either by saving them to a dictionary and then writing the dictionary to the database, or by saving directly to the database.\n\nAt a minimum, you need data for a results table (data for each choice) and a contests table (data for each race/office).\n\nThe minimum required results fields are `id, state, election, updated, contest_id, choice, party, votes, percentage, winner`. The minimum required contests fields are `id, state, election, updated, title, precincts_reporting, total_precincts, percent_reporting, total_votes, seats`. (Note: state, election and updated can be filled using `self.util` methods. See **Data modeling** below.)\n\nIn both cases, additional fields can be added to the tables as needed for your specific elections. The `id` in the contests table should match the `contest_id` in the results table and is used to link candidates/options to their overall races. For more information on required fields, see *Data modeling* below.\n\nSome of these data fields may be accessible directly from the results file, but others will require calculation or other manipulation inside the scraper script. Look at existing state scrapers for some examples of this data processing.\n\n#### Manual data\n\nIn some cases, you may want to add in additional election data not available in the election results file. An easy way to do this is to create a Google Spreadsheet with the additional data. The `utility.google_spreadsheet(spreadsheet_id, worksheet_id, gs_types_dict)` method gives you all the rows in a specific Google Spreadsheet which you can iterate over to read additional data for writing to the `results` or `contests` tables. You probably want to match the unique IDs for either results or contests in this spreadsheet.\n\nFor more information, see **Utility library** below.\n\n### Utility library\n\nIn the `Scraper` object, a `utility` object will be passed in. This will be a `ENAUtility` class instance with connections made to the election that is being processed.\n\n* `utility.state`: The state that is being processed.\n* `utility.election_id`: The election ID that is being processed.\n* `utility.election`: The election meta data found in `xx_meta.py` for the election being processed.\n* `utility.setup()`: This connects to the correct database.\n* `utility.timestamp()`: Get an integer timestamp of right now.\n* `utility.save(id_array, data_dict, table_name, index_method)`: Save (insert or update) a row or rows to the database. The index method will be called on the first insert to the table.\n* `utility.has_table(table_name)`: Check if table exists in the database.\n* `utility.save_meta(key_name, value)`: Save a value to the meta table.\n* `utility.google_spreadsheet(spreadsheet_id, worksheet_id, gs_types_dict)`: Get data from a Google Spreadsheet, specific sheet. If dictionary type is given, the utility will attempt to type the data.\n* `utility.save_results(data)`: Save results data. Checks if the basic results fields are there.\n* `utility.save_contests(data)`: Save contests data. Checks if the basic contests fields are there.\n* 'utility.scrape()': Just a link to [scraperwiki.scrape](https://github.com/scraperwiki/scraperwiki-python#scraping).\n* `utility.sql`: A link to [scraperwiki.sql]](https://github.com/scraperwiki/scraperwiki-python#saving-data).\n\n### Tests\n\n`py.test` will find all python files with [specific names](http://pytest.org/latest/goodpractises.html#test-discovery) in a given directory.\n\n1. Run all the tests (including all the states): `py.test`\n1. Run all the state tests: `py.test states/`\n1. Run a specific state test: `py.test states/mn/`\n\n## Data modeling\n\nThis tool allows you to model your data however you want for the most part, but there are some basic requirements.\n\n### Contests\n\nContests are the generic word for races, ballot questions, referendums, etc. This data should have at least the following fields, but you can have as many more fields as you want.\n\n* `id`: A unique ID for the contest across the state and election\n* `state`: State code, can be provided with `self.util.state`\n* `election`: Election ID, can be provided with `self.util.election_id`\n* `updated`: Timestamp integer of last updated, can use `self.util.timestamp()`\n* `title`: Title of contest, e.g. \u201cU.S. Rep. District 2\u201d or \u201cProposed constitutional amendment\u201d\n* `precincts_reporting`: Integer number of precincts reporting\n* `total_precincts`: Integer number of total precincts effected by contest\n* `percent_reporting`: Float percentage (85.0, not 0.85) of precincts reporting\n* `total_votes`: Integer of total votes cast\n* `seats`: Number of seats that can be won, usually 1\n* ... and whatever other data is relevant for this contest\n\nThe utility object has a convenient `save_contests` method for updating results.\n\n### Results\n\nResults are data for each candidate, write-in, answer, etc. for each contest. There will generally be at least two rows of results per contest.\n\n* `id`: A unique ID for the candidate/answer/choice/etc. across the state and election.\n* `state`: State code, can be provided with `self.util.state`\n* `election`: Election ID, can be provided with `self.util.election_id`\n* `updated`: Timestamp integer of last updated, can use `self.util.timestamp()`\n* `contest_id`: The corresponding contest ID from the contests table\n* `choice`: The name of the candidate or question answer (Yes or No usually)\n* `party`: Party identifier, such as `D` or `R`\n* `votes`: Integer number of votes this choice received so far\n* `percentage`: Float percentage (85.0, not 0.85) of the number of total votes in contest so far\n* `winner`: Boolean of whether this choice has won the contest\n* ... and whatever other data is relevant for this result\n\nThe utility object has a convenient `save_results` method for updating results.\n\n### Other data\n\nYou can also save whatever data you want in the database for reference or querying later.\n\nThe utility object has a `save` method for saving any data into any table as needed.\n\n## Election Night deploy\n\nFor election night, the idea is to install this on a resourceful server; overall the server should have most resources towards I/O as opposed to memory or CPU, though those things are needed as well. The following instructions and the provided configuration are aimed at installing the API on an Ubuntu server (on EC2).\n\nIt is suggested to use `Ubuntu Server 14.04 LTS 64-bit (ami-9eaa1cf6)` AMI from EC2.  Your Security Group will need port `80` (HTTP) open and whatever port you will SSH into (default `22`).\n\nNote that these instructions are for a fresh server without other apps running on it. Please look at the instructions and configurations in detail if you have existing apps running on the server.\n\n### Code, libraries, and prerequisites\n\n1. Make sure Ubuntu is up to date: `sudo aptitude update && sudo aptitude safe-upgrade`\n1. Install system and python base packages: `sudo aptitude install git-core git python-pip python-dev build-essential python-lxml sqlite3 nginx-full fcgiwrap`\n1. Install python base packages: `sudo pip install --upgrade pip && sudo pip install --upgrade virtualenv`\n1. Go to the home directory; you can put the code somewhere else but you may have to manually update other parts of the deploy: `cd ~`\n1. Get the code: `git clone https://github.com/MinnPost/election-night-api.git && cd election-night-api`\n1. `sudo pip install -r requirements.txt`\n1. Add path so we have reference for later: `echo \"export ENA_PATH=$(pwd)\" >> ~/.bash_profile`\n\n### Webserver\n\nAs this is meant to emulate how ScraperWiki works, it uses Dumptruck, FastCGI and Nginx to create an API for the scraped data in the sqlite database.\n\n1. [Dumptruck](https://github.com/scraperwiki/dumptruck-web) is a Python script to create an API on-top of an sqlite database.  It's built by ScraperWiki and also handles multiple user location.\n    1. `sudo git clone https://github.com/scraperwiki/dumptruck-web.git /var/www/dumptruck-web && sudo chown -R www-data:www-data /var/www/dumptruck-web && sudo pip install -r /var/www/dumptruck-web/requirements.txt`\n1. FCGIWrap is used to create an interface between the Dumptruck and Nginx. We use a simple script to configure the number of children to use.\n    1. `sudo cp deploy/fcgiwrap /etc/default/fcgiwrap`\n    1. Restart service (note that this can take a minute): `sudo service fcgiwrap restart`\n1. Nginx is used as the top level web server.  It allows for caching and other niceties.  This copies our config, enables it and removes the default.\n    1. `sudo cp deploy/nginx-scraper-api.conf /etc/nginx/sites-available/election-night-api.conf && sudo ln -s /etc/nginx/sites-available/election-night-api.conf /etc/nginx/sites-enabled/election-night-api.conf && sudo rm /etc/nginx/sites-enabled/default`\n    1. Restart service: `sudo service nginx restart`\n    1. Test with something like: http://ec2-XX-XX-XX.compute-1.amazonaws.com/sql?box=ubuntu/election-night-api&method=sql&q=SELECT%20*%20FROM%20results%20LIMIT%2010\n        * The `box` paramater is essentially the directory path where the `scraperwiki.sqlite` file resides.  TODO: Figure out how to make nginx provide a default for this.\n        * Update the `box` parameter if code was installed in another place.\n\n### Cron\n\nFor election night, and leading up to it, you will want the scraper tool to run on an interval, probably with some methods running occasionally, while at least one running continuously.  Utilizing cron for this is best. There is a helpful wrapper, `deploy/continuous-wrapper.sh` that will run the scraper tool continuously.\n\n* Set the `ENA_PATH` in the cron file as this is not carried over from the user: `ENA_PATH=/home/ubuntu/election-night-api`\n* Get results continuously: `* * * * * $ENA_PATH/deploy/continuous-wrapper.sh MN results`\n* Log to home directory: `* * * * * $ENA_PATH/deploy/continuous-wrapper.sh MN results > ~/logs/ena.log`\n* Run less important scrapes: `0 7 * * * $ENA_PATH/bin/ena MN questions`\n\n## ScraperWiki deploy\n\nFor non-election time, it makes sense to save resources and use the ScraperWiki architecture.  We need to install the application on our scraper, then run commands as needed.\n\n1. Make sure you have an account on ScraperWiki\n1. Create new, or use the existing, scraper for the election results.  Select Python for the language.\n1. On your command line, SSH into the \"Code in your Browser\" tool; click on the tab and use the gear icon drop-down.  This should be something like: `ssh xxxxx@premium.scraperwiki.com`\n1. Get the code: `git clone https://github.com/MinnPost/election-night-api.git`\n1. Back in the ScraperWiki editor, copy the code from `deploy/scraperwiki-example.py` from this repository and then edit the scraping commands that you need.\n1. Schedule it!  Probably daily or weekly.\n1. Switch out the API URL in your application.  You can use \"Query with SQL\" tool in the ScraperWiki interface to get the URL, but it should be something similar to: https://premium.scraperwiki.com/xxxxx/yyyyyy/sql/?q=", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/MinnPost/election-night-api", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "election-night-api", "package_url": "https://pypi.org/project/election-night-api/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/election-night-api/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/MinnPost/election-night-api"}, "release_url": "https://pypi.org/project/election-night-api/0.0.1/", "requires_dist": null, "requires_python": null, "summary": "A set of utlities and instructions for running an election night API.", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            # Election Night API<br><br>A set of tools, configurations, and instructions to collect and serve election results on election night - the Super Bowl of data news - while still providing an off-season service and focusing on saving resources as much as possible.<br><br>This is aimed at small to medium orgs that cannot afford services like AP or Reuters elections, or orgs that need more local results. This works best with states that have an election night feed.<br><br>The architecture of this application is based on [ScraperWiki](https://scraperwiki.com), a platform for scraping and serving data.  The main reason for this is so that on or around election night, an organization can run its own server with high resources, while using the [free](https://scraperwiki.com/pricing) (for [journalists](https://wordpress.scraperwiki.com/solutions/data-journalism/)) infrastructure of ScraperWiki the rest of the year.<br><br>There are two parts to the API.<br><br>## The scraper tool<br><br>The `bin/ena` command is a wrapper to run each state's scraper methods. Different scraper methods can be run on differing schedules to account for how often data is updated in a given state.<br><br>* Get help on command: `bin/ena -h`<br>* Update results for the newest election in MN: `bin/ena MN results`<br>* Update areas data for specific election in MN: `bin/ana MN areas -e 20141104`<br><br>## The API<br><br>The API allows for arbitrary SQL selects of the data and returns JSON. This means it is easy to get at whatever data is needed for display on a website or other application. There are 3 possible servers you may be using.<br><br>* For development, you can use the Local API server (see below).<br>* For production, i.e. election night, see the Deploy instructions below.<br>* During off-season, you can save money by using ScraperWiki<br><br>Though the URL will change a bit, the `?q=` paramater will still be in the input mechanism for the query. Here are some examples.<br><br>* Get all contests: `/?q=SELECT * contests`<br>* Get a specific contest with results: `/?q=SELECT * FROM contests AS c JOIN results AS r ON c.id = r.contest_id AND c.state = r.state AND s.election = r.election WHERE c.id = 'some-contest-id'`<br><br><br>## Install<br><br>### Prerequisites<br><br>You may have the following already installed.<br><br>1. Install [Git](http://git-scm.com/).<br>1. Install [Python](https://www.python.org/downloads/).<br>    * Most systems already have Python installed.<br>1. Install [libxml](http://xmlsoft.org/).<br>    * On a Mac, this should be installed with XCode developer tools: `xcode-select --install`<br>1. (optional) Use [virtualenv](http://virtualenv.readthedocs.org/en/latest/) and [virtualenvwrapper](http://virtualenvwrapper.readthedocs.org/en/latest/install.html)<br>    1. `pip install virtualenv virtualenvwrapper`<br>        * This may need to be run with `sudo`; you should be able to tell if you get a permission error.<br>        * To get virtualenvwrapper to load on startup, do the following, though if you have a  non-standard Python install or are not on a bash system, see [full instructions](http://virtualenvwrapper.readthedocs.org/en/latest/install.html). `echo \"export WORKON_HOME=$HOME/.virtualenvs\" &gt;&gt; ~/.bash_profile &amp;&amp; echo \"export PROJECT_HOME=$HOME/Devel\" &gt;&gt; ~/.bash_profile &amp;&amp; echo \"source /usr/local/bin/virtualenvwrapper.sh\" &gt;&gt; ~/.bash_profile &amp;&amp; source ~/.bash_profile`<br><br>### Get code and install dependencies<br><br>1. Get the code and change to directory: `git clone https://github.com/MinnPost/election-night-api.git &amp;&amp; cd election-night-api`<br>1. (optional) Make a virtualenv to work in: `mkvirtualenv election-night-api`<br>1. Install libraries: `pip install -r requirements.txt`<br><br>## Development<br><br>### Local API<br><br>For testing purposes, it is probably easier to use the lightweight, not production ready, local API application.<br><br>1. Scrape some data with the [scraper tool](#the-scraper-tool).<br>1. Run local API with: `python tests/local_api.py`<br>1. Make requests similar to: `http://localhost:5000/?q=SELECT * FROM contests LIMIT 10`<br><br>### Adding or managing a state<br><br>The data you need to scrape will vary from state to state, though there are some basics (see **Writing a scraper** and **Data modeling** below) and specific files and names that need to be followed. The best way to start is to copy the example and look at the comments in the file.<br><br>1. Copy example: `cp -r states/example states/xx`<br>1. The `xx_meta.py` file manages each information and configuration about each election in the state.  Create the configuration as is needed for your state; there are only a couple required field.<br>    1. Rename `example_meta.py` to `xx_meta.py`<br>    1. Change the Election ID. Suggested format is date of the election in the form YYYYMMDD<br>    1. (optional) The URL to the election results file can go in here.<br>1. The `xx.py` holds the `Scraper` class which has the methods that are run through the command line tool.  Most of this will be specific to your state and source.<br>    1. Rename `example.py` to `xx.py`<br>    1. Make sure to call `utility.setup()` in the constructor.<br>1. The `test_xx.py` file is to hold tests to help unit test your files.<br>    1. Rename `test_example.py` to `test_xx.py`<br><br>You need to write code to translate the election results file provided by your Secretary of State or State Elections Board into a set of data fields that can be stored in the database. Since election results file formats vary widely from state to state, each state will require a custom approach, but below are some general guidelines for writing the scraper.<br><br>#### Examine data<br><br>Spend time becoming familiar with your state's election files by studying example files or files from recent elections. Are the results provided for the entire race or by precinct? Does each race have a unique identifier? Does each candidate? What results data is provided \u2014\u00a0raw vote totals, vote percentage or both?<br><br>#### Unique IDs<br><br>At a minimum, each choice in the election (e.g. candidates and ballot question responses)  and each contest must have unique identifiers. In some cases, these will already exist in a single field in the results file and can be read into your scraper (have care to verify that the IDs are in fact unique). If no single field contains a unique identifier, you will need to construct one from the data fields inside your scraper. For example, in the Minnesota scraper, we construct an ID string for each contest by combining fields for state, county, precinct district and office:<br><br>  ```<br>  #id-State-County-Precinct-District-Office<br>  base_id = 'id-' + row[0] + '-' + row[1] + '-' + row[2] + '-' + row[5] + '-' + row[3]<br>  ```<br><br>For more information on required fields, see **Data modeling** below.<br><br>#### Read the file<br><br>In general, you'll want to iterate through your file, manipulate the data to match the required data fields, and save those results, either by saving them to a dictionary and then writing the dictionary to the database, or by saving directly to the database.<br><br>At a minimum, you need data for a results table (data for each choice) and a contests table (data for each race/office).<br><br>The minimum required results fields are `id, state, election, updated, contest_id, choice, party, votes, percentage, winner`. The minimum required contests fields are `id, state, election, updated, title, precincts_reporting, total_precincts, percent_reporting, total_votes, seats`. (Note: state, election and updated can be filled using `self.util` methods. See **Data modeling** below.)<br><br>In both cases, additional fields can be added to the tables as needed for your specific elections. The `id` in the contests table should match the `contest_id` in the results table and is used to link candidates/options to their overall races. For more information on required fields, see *Data modeling* below.<br><br>Some of these data fields may be accessible directly from the results file, but others will require calculation or other manipulation inside the scraper script. Look at existing state scrapers for some examples of this data processing.<br><br>#### Manual data<br><br>In some cases, you may want to add in additional election data not available in the election results file. An easy way to do this is to create a Google Spreadsheet with the additional data. The `utility.google_spreadsheet(spreadsheet_id, worksheet_id, gs_types_dict)` method gives you all the rows in a specific Google Spreadsheet which you can iterate over to read additional data for writing to the `results` or `contests` tables. You probably want to match the unique IDs for either results or contests in this spreadsheet.<br><br>For more information, see **Utility library** below.<br><br>### Utility library<br><br>In the `Scraper` object, a `utility` object will be passed in. This will be a `ENAUtility` class instance with connections made to the election that is being processed.<br><br>* `utility.state`: The state that is being processed.<br>* `utility.election_id`: The election ID that is being processed.<br>* `utility.election`: The election meta data found in `xx_meta.py` for the election being processed.<br>* `utility.setup()`: This connects to the correct database.<br>* `utility.timestamp()`: Get an integer timestamp of right now.<br>* `utility.save(id_array, data_dict, table_name, index_method)`: Save (insert or update) a row or rows to the database. The index method will be called on the first insert to the table.<br>* `utility.has_table(table_name)`: Check if table exists in the database.<br>* `utility.save_meta(key_name, value)`: Save a value to the meta table.<br>* `utility.google_spreadsheet(spreadsheet_id, worksheet_id, gs_types_dict)`: Get data from a Google Spreadsheet, specific sheet. If dictionary type is given, the utility will attempt to type the data.<br>* `utility.save_results(data)`: Save results data. Checks if the basic results fields are there.<br>* `utility.save_contests(data)`: Save contests data. Checks if the basic contests fields are there.<br>* 'utility.scrape()': Just a link to [scraperwiki.scrape](https://github.com/scraperwiki/scraperwiki-python#scraping).<br>* `utility.sql`: A link to [scraperwiki.sql]](https://github.com/scraperwiki/scraperwiki-python#saving-data).<br><br>### Tests<br><br>`py.test` will find all python files with [specific names](http://pytest.org/latest/goodpractises.html#test-discovery) in a given directory.<br><br>1. Run all the tests (including all the states): `py.test`<br>1. Run all the state tests: `py.test states/`<br>1. Run a specific state test: `py.test states/mn/`<br><br>## Data modeling<br><br>This tool allows you to model your data however you want for the most part, but there are some basic requirements.<br><br>### Contests<br><br>Contests are the generic word for races, ballot questions, referendums, etc. This data should have at least the following fields, but you can have as many more fields as you want.<br><br>* `id`: A unique ID for the contest across the state and election<br>* `state`: State code, can be provided with `self.util.state`<br>* `election`: Election ID, can be provided with `self.util.election_id`<br>* `updated`: Timestamp integer of last updated, can use `self.util.timestamp()`<br>* `title`: Title of contest, e.g. \u201cU.S. Rep. District 2\u201d or \u201cProposed constitutional amendment\u201d<br>* `precincts_reporting`: Integer number of precincts reporting<br>* `total_precincts`: Integer number of total precincts effected by contest<br>* `percent_reporting`: Float percentage (85.0, not 0.85) of precincts reporting<br>* `total_votes`: Integer of total votes cast<br>* `seats`: Number of seats that can be won, usually 1<br>* ... and whatever other data is relevant for this contest<br><br>The utility object has a convenient `save_contests` method for updating results.<br><br>### Results<br><br>Results are data for each candidate, write-in, answer, etc. for each contest. There will generally be at least two rows of results per contest.<br><br>* `id`: A unique ID for the candidate/answer/choice/etc. across the state and election.<br>* `state`: State code, can be provided with `self.util.state`<br>* `election`: Election ID, can be provided with `self.util.election_id`<br>* `updated`: Timestamp integer of last updated, can use `self.util.timestamp()`<br>* `contest_id`: The corresponding contest ID from the contests table<br>* `choice`: The name of the candidate or question answer (Yes or No usually)<br>* `party`: Party identifier, such as `D` or `R`<br>* `votes`: Integer number of votes this choice received so far<br>* `percentage`: Float percentage (85.0, not 0.85) of the number of total votes in contest so far<br>* `winner`: Boolean of whether this choice has won the contest<br>* ... and whatever other data is relevant for this result<br><br>The utility object has a convenient `save_results` method for updating results.<br><br>### Other data<br><br>You can also save whatever data you want in the database for reference or querying later.<br><br>The utility object has a `save` method for saving any data into any table as needed.<br><br>## Election Night deploy<br><br>For election night, the idea is to install this on a resourceful server; overall the server should have most resources towards I/O as opposed to memory or CPU, though those things are needed as well. The following instructions and the provided configuration are aimed at installing the API on an Ubuntu server (on EC2).<br><br>It is suggested to use `Ubuntu Server 14.04 LTS 64-bit (ami-9eaa1cf6)` AMI from EC2.  Your Security Group will need port `80` (HTTP) open and whatever port you will SSH into (default `22`).<br><br>Note that these instructions are for a fresh server without other apps running on it. Please look at the instructions and configurations in detail if you have existing apps running on the server.<br><br>### Code, libraries, and prerequisites<br><br>1. Make sure Ubuntu is up to date: `sudo aptitude update &amp;&amp; sudo aptitude safe-upgrade`<br>1. Install system and python base packages: `sudo aptitude install git-core git python-pip python-dev build-essential python-lxml sqlite3 nginx-full fcgiwrap`<br>1. Install python base packages: `sudo pip install --upgrade pip &amp;&amp; sudo pip install --upgrade virtualenv`<br>1. Go to the home directory; you can put the code somewhere else but you may have to manually update other parts of the deploy: `cd ~`<br>1. Get the code: `git clone https://github.com/MinnPost/election-night-api.git &amp;&amp; cd election-night-api`<br>1. `sudo pip install -r requirements.txt`<br>1. Add path so we have reference for later: `echo \"export ENA_PATH=$(pwd)\" &gt;&gt; ~/.bash_profile`<br><br>### Webserver<br><br>As this is meant to emulate how ScraperWiki works, it uses Dumptruck, FastCGI and Nginx to create an API for the scraped data in the sqlite database.<br><br>1. [Dumptruck](https://github.com/scraperwiki/dumptruck-web) is a Python script to create an API on-top of an sqlite database.  It's built by ScraperWiki and also handles multiple user location.<br>    1. `sudo git clone https://github.com/scraperwiki/dumptruck-web.git /var/www/dumptruck-web &amp;&amp; sudo chown -R www-data:www-data /var/www/dumptruck-web &amp;&amp; sudo pip install -r /var/www/dumptruck-web/requirements.txt`<br>1. FCGIWrap is used to create an interface between the Dumptruck and Nginx. We use a simple script to configure the number of children to use.<br>    1. `sudo cp deploy/fcgiwrap /etc/default/fcgiwrap`<br>    1. Restart service (note that this can take a minute): `sudo service fcgiwrap restart`<br>1. Nginx is used as the top level web server.  It allows for caching and other niceties.  This copies our config, enables it and removes the default.<br>    1. `sudo cp deploy/nginx-scraper-api.conf /etc/nginx/sites-available/election-night-api.conf &amp;&amp; sudo ln -s /etc/nginx/sites-available/election-night-api.conf /etc/nginx/sites-enabled/election-night-api.conf &amp;&amp; sudo rm /etc/nginx/sites-enabled/default`<br>    1. Restart service: `sudo service nginx restart`<br>    1. Test with something like: http://ec2-XX-XX-XX.compute-1.amazonaws.com/sql?box=ubuntu/election-night-api&amp;method=sql&amp;q=SELECT%20*%20FROM%20results%20LIMIT%2010<br>        * The `box` paramater is essentially the directory path where the `scraperwiki.sqlite` file resides.  TODO: Figure out how to make nginx provide a default for this.<br>        * Update the `box` parameter if code was installed in another place.<br><br>### Cron<br><br>For election night, and leading up to it, you will want the scraper tool to run on an interval, probably with some methods running occasionally, while at least one running continuously.  Utilizing cron for this is best. There is a helpful wrapper, `deploy/continuous-wrapper.sh` that will run the scraper tool continuously.<br><br>* Set the `ENA_PATH` in the cron file as this is not carried over from the user: `ENA_PATH=/home/ubuntu/election-night-api`<br>* Get results continuously: `* * * * * $ENA_PATH/deploy/continuous-wrapper.sh MN results`<br>* Log to home directory: `* * * * * $ENA_PATH/deploy/continuous-wrapper.sh MN results &gt; ~/logs/ena.log`<br>* Run less important scrapes: `0 7 * * * $ENA_PATH/bin/ena MN questions`<br><br>## ScraperWiki deploy<br><br>For non-election time, it makes sense to save resources and use the ScraperWiki architecture.  We need to install the application on our scraper, then run commands as needed.<br><br>1. Make sure you have an account on ScraperWiki<br>1. Create new, or use the existing, scraper for the election results.  Select Python for the language.<br>1. On your command line, SSH into the \"Code in your Browser\" tool; click on the tab and use the gear icon drop-down.  This should be something like: `ssh xxxxx@premium.scraperwiki.com`<br>1. Get the code: `git clone https://github.com/MinnPost/election-night-api.git`<br>1. Back in the ScraperWiki editor, copy the code from `deploy/scraperwiki-example.py` from this repository and then edit the scraping commands that you need.<br>1. Schedule it!  Probably daily or weekly.<br>1. Switch out the API URL in your application.  You can use \"Query with SQL\" tool in the ScraperWiki interface to get the URL, but it should be something similar to: https://premium.scraperwiki.com/xxxxx/yyyyyy/sql/?q=\n          </div>"}, "last_serial": 1307580, "releases": {"0.0.1": []}, "urls": [], "timestamp": "Fri May  8 00:46:55 2020"}