{"info": {"author": "Nathaniel J. Smith", "author_email": "njs@pobox.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Topic :: Software Development :: Build Tools", "Topic :: Software Development :: Compilers"], "description": "Mach-O Mach-O Mangler\n=====================\n\n.. image:: https://travis-ci.org/njsmith/machomachomangler.svg?branch=master\n   :target: https://travis-ci.org/njsmith/machomachomangler\n   :alt: Automated test status (Travis)\n\n.. image:: https://ci.appveyor.com/api/projects/status/9p8cuhx8vwn2i2jp?svg=true\n   :target: https://ci.appveyor.com/project/njsmith/machomachomangler\n   :alt: Automated test status (Appveyor)\n\n.. image:: https://codecov.io/gh/njsmith/machomachomangler/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/njsmith/machomachomangler\n   :alt: Test coverage\n\n\nThis is a little library for mangling Mach-O and PE files in various\nways. These are the formats used for executables and shared libraries\non MacOS and Windows, respectively. (If you want the equivalent for\nfor Linux, then check out `patchelf\n<https://github.com/NixOS/patchelf>`__.)\n\n\nMacho-O features\n----------------\n\nSome rather specialized (and complex) Mach-O mangling tools designed\nto support `the pynativelib proposal\n<https://github.com/njsmith/wheel-builders/blob/pynativelib-proposal/pynativelib-proposal.rst>`__\nto allow native libraries to be distributed as standalone `wheel files\n<https://pypi.python.org/pypi/wheel>`__. Specifically this includes:\n\n* For pynativelib libraries: a tool that takes a dylib, and a mangling\n  rule, and applies the mangling rule to all the exported\n  symbols. E.g., it can convert a library that exports ``SSL_new``\n  into one that exports ``pynativelib_openssl__SSL_new``. It also\n  changes the library id while it's at it, e.g. from ``ssl.dylib`` ->\n  ``pynativelib_openssl__ssl.dylib`` (like ``install_name_tool -id``)\n\n  Additionally: a tool that creates a \"placeholder\" library, which\n  imports the mangled library described above, and then re-exports the\n  symbols under their original names.\n\n* For code that wants to use a pynativelib library: a tool that\n  takes a dylib/bundle/executable, a list of \"original\" dylibs, and\n  for each \"original\" dylib, a newname for that dylib, and a\n  mangling rule. It then (a) replaces the import of the original\n  dylib with an absolute import of the new dylib name from a\n  non-existent directory, (b) marks this as a \"weak\" import, (c)\n  applies the mangling rule to all symbols imported from this dylib,\n  (d) marks these symbols for lookup in the flat namespace.\n\nIt turns out that this *exact* combination of things is the only way\nprovided for by the MacOS linker/loader to have dylib/bundle A linked\nagainst dylib B where the relative on-disk location of A and B is not\nknown until after the executable starts, while preserving the usual\ntwo-level namespace rules for avoiding symbol collisions. I promise it\nwill all make sense once I have a chance to write it up properly...\n\nSome known limitations of the Mach-O mangling code:\n\n- Unsurprisingly, this kind of patching does not play well with code\n  signing. The code doesn't take any special case with signatures;\n  they'll probably just get messed up. If you want to sign your\n  binaries, then do your mangling first before signing.\n\n- We currently only rewrite the new-style DYLD_INFO symbol table\n  (introduced in 10.5), not the (almost?) totally redundant\n  SYMTAB/DYSYMTAB symbol table. (Interesting fact: all Mach-O binaries\n  include two completely different representations of their symbols\n  tables. The new one is more compact, to save space, but then they\n  keep the old one around for compatibility, so... anyway.) As far as\n  I can tell, the only thing in in modern MacOS that still uses\n  SYMTAB/DYSYMTAB is ``dladdr``, and I don't think anyone is relying\n  on ``dladdr`` output for, well... anything? I think worst case, you\n  might end up seeing the original symbol names inside a debugger or\n  profiler? But this wouldn't be *too* hard to fix if it becomes a\n  problem.\n\n- It doesn't do any special handling of the DYLD_INFO weak_bind table,\n  or weak exports. (NB these have nothing to do\n  ``__attribute__((weak))`` or ``__attribute__((weak_import))`` or any\n  of the mentions of the word ``weak`` in the ``ld`` man page \u00e2\u20ac\u201c I\n  think they're for implementing `vague linkage\n  <http://www.airs.com/blog/archives/52>`__.) This is *probably* not a\n  disastrous option, but I'm not 100% sure whether it's actually\n  correct \u00e2\u20ac\u201c it's an incredibly obscure part of the Mach-O format, and\n  Mach-O is pretty obscure to start with. Fortunately this feature is\n  only used by C++ libraries, so we can get started without it.\n\n- When mangling imports, we convert any lazy imports (that need\n  mangling) into eager imports. This is required because the lazy\n  import stubs hard-code the memory layout of the import table into\n  immediate constants inside the stub assembly itself, and I do not\n  feel like trying to automatically rewrite x86-64 opcodes. Instead,\n  we leave the lazy import table alone (so all the unmangled lazy\n  imports can continue to use it), and eagerly bind all the mangled\n  imports, so the unmangled stubs never get called.\n\n- I noticed some new code dyld in MacOS 10.12 that imposes some\n  annoying arbitrary restrictions on which order the different bits of\n  DYLD_INFO appear in the file. This should only affect libraries that\n  are built with 10.12 as their minimum required version, so for folks\n  trying to build stuff for general distribution this shouldn't matter\n  for a while. This also isn't hard to fix, it just means that we'll\n  probably have to start making some pointless redundant copies of\n  bits of the file that we *didn't* change, just so that the second\n  copy can be placed after the bit of the file that we did change,\n  which is tiresome and I haven't gotten around to it yet.\n\n- When mangling imports, we don't check for re-exports, which are also\n  a kind of import. Should probably fix this...\n\n\nPE features\n-----------\n\nA tool that can read in a PE file (``.exe`` or ``.dll``) that is\ncurrently linked to ``foo.dll``, and rewrite it so that it becomes\nlinked to ``bar.dll`` instead (similar to ``patchelf --replace`` on\nLinux, or ``install_name_tool -change`` on OS X). This is useful for\navoiding naming collisions between different versions of the same\nlibrary.\n\nFor example, suppose you have two Python extensions ``A.dll`` and\n``B.dll``, that are distributed separately by different people. They\nboth contain some fortran code linked to to ``libgfortran-3.dll``, so\nboth packages ship a copy of ``libgfortran-3.dll``. Because of the way\nWindows DLL loading works, what will happen is that if I load\n``A.dll`` first, then *both* ``A.dll`` and ``B.dll`` will end up using\nA's copy of ``libgfortran-3.dll``, while B's copy will be ignored. (Or\nvice-versa if I import B first.) This will happen even if I arrange\nthings so that A's copy is not on the DLL search path at the time that\nB is loaded -- Windows always checks for already-loaded DLL's with a\ngiven basename before it actually checks the DLL search path (modulo\nsome complications around SxS assemblies, but you don't really want to\ngo there).\n\nThis is bad, because there's no guarantee that ``B.dll`` will work\nwith A's version of ``libgfortran-3.dll`` (e.g., A's copy might be too\nold for B). Welcome to `DLL hell\n<https://en.wikipedia.org/wiki/DLL_Hell>`_!\n\nWe could avoid all this by renaming the colliding libraries to have\ndifferent names, e.g. ``libgfortran-3-for-A.dll`` and\n``libgfortran-3-for-B.dll``. But if we just rename the files, then\neverything will break, because ``A.dll`` is looking for\n``libgfortran-3.dll``, not ``libgfortran-3-for-A.dll``.\n\nThis is where ``machomachomangler`` comes in: it lets you patch\n``A.dll`` so that it's linked to ``libgfortran-3-for-A.dll``. And then\neverything works. Hooray.\n\nThis basically solves the same problem as private SxS assemblies,\nexcept better in all ways: it's simpler (no XML manifests), more\nflexible (no finicky requirements for the filesystem layout), and\ndoesn't require reading the awful SxS assembly documentation.\n\nExample usage::\n\n  $ python3 -m machomachomangler.cmd.redll A.dll A-patched.dll libgfortran-3.dll libgfortan-3-for-A.dll\n\nThere's an example in ``example/`` then you can play with. E.g. on\nDebian with a mingw-w64 cross-compiler and wine installed::\n\n  $ cd pe-example/\n\n  $ ./build.sh\n  + i686-w64-mingw32-gcc -shared test_dll.c -o test_dll.dll\n  + i686-w64-mingw32-gcc test.c -o test.exe -L. -ltest_dll\n  + i686-w64-mingw32-strip test.exe\n\n  $ wine test.exe\n  dll_function says: test_dll\n\n  $ mv test_dll.dll test_dll_renamed.dll\n\n  # Apparently wine's way of signalling a missing DLL is to fail silently.\n  $ wine test.exe || echo \"failed -- test_dll.dll is missing\"\n  failed -- test_dll.dll is missing\n\n  $ PYTHONPATH=.. python3 -m machomachomangler.cmd.redll test.exe test-patched.exe test_dll.dll test_dll_renamed.dll\n\n  # Now it works again:\n  $ wine test-patched.exe\n  dll_function says: test_dll\n\nSome known limitations of the PE dll-import-switcheroo code:\n\n- The command line tool could be less minimalist.\n\n- GNU ``objdump`` has a bug where it can't read the import tables of\n  our patched PE files -- it just shows all of the import table until\n  it hits the patched entry, and then it stops displaying\n  anything. (The issue is that ``binutils`` wants all the data\n  involved in the import tables to come from a single PE section.)\n  However, I've tried giving the patched files to Dependency Walker,\n  ``wine``, and Windows itself, and they all handle them fine -- so\n  the files are okay, it's just a bug in ``objdump``. Just be warned\n  that if you're trying to use ``objdump`` to check if the patching\n  worked, then it's almost certainly going to tell you a confusing\n  lie.\n\n- Unsurprisingly, this kind of patching does not play well with code\n  signing. We try to at least clear any existing signatures (so that\n  the binary becomes unsigned, rather than signed with an invalid\n  signature), but this hasn't been tested.\n\n- We don't try to handle files with trailing data after the end of the\n  PE file proper. This commonly occurs with e.g. self-extracting\n  archives and installers. Shouldn't be a big deal in theory, but I\n  did find that when compiling a simple ``.exe`` with mingw-w64 the\n  tool refused to work until I had run ``strip`` on the binary, even\n  though in theory this should work fine -- so probably there's some\n  improvements possible.\n\n  [Note to self: it looks like this is a GNU extension for putting\n  long section names into PE files, which I guess are they use for\n  their debug format -- this is `documented here\n  <https://sourceware.org/binutils/docs/bfd/coff.html>`__, search for\n  \"Coff long section names\". It's probably not hard to handle this\n  better, e.g. by stripping it ourself or even fixing it up.]\n\n- We don't try to update the PE header checksum, since the algorithm\n  for doing this is (nominally) a secret, and I'm informed that for\n  regular user-space code there's nothing that actually cares about\n  whether it's correct. But my information could be wrong. (Note: it\n  looks like binutils might know how to compute this checksum? I'm not\n  sure.)\n\n  [Update: Stefan Kanthak informs me that this algorithm is well\n  known, and in fact it looks `pefile has an MIT-licensed Python\n  implementation\n  <https://github.com/erocarrera/pefile/blob/master/pefile.py#L5150>`_\n  so I guess it might be good to fix this at some point.]\n\n\nGeneral limitations\n-------------------\n\nOnly tested on **Python 3.4 and 3.5**. Probably any Python 3 will\nwork, and Python 2 definitely won't without some fixes. (There's lots\nof fiddly byte-string handling.)\n\nI'm lazy, so I just load the whole binary files into memory -- maybe\nseveral copies of it. This actually wouldn't be too hard to fix (using\nmemory mapping etc.) but I guess it doesn't matter that much because\n`who has multi-gigabyte Mach-O/PE images?\n<http://tvtropes.org/pmwiki/pmwiki.php/Main/WhatCouldPossiblyGoWrong>`_?\n\n\nContact\n-------\n\nwheel-builders@python.org\n\n\nLicense\n-------\n\nIt's Saturday afternoon, I've got the flu or something, and I'm\nspending my free time writing software to make some proprietary\noperating systems -- ones that are backed by one of the world's larger\ncorporations -- better able to compete for developers with other,\nbetter-designed operating systems. I mean, I'm not saying that poring\nover the PE/COFF specification isn't fun!  But it's not *that*\nfun. (And honestly the Mach-O docs are absolutely terrible, to the\nextent they exist at all.)\n\nTo assuage my annoyance, this software is licensed under the *GNU\nAffero General Public License as published by the Free Software\nFoundation, either version 3 of the License or (at your option)\nany later version*. See ``LICENSE.txt`` for details.\n\nThis **shouldn't have any effect** on most uses, since it only affects\npeople who are redistributing this software or running it on behalf of\nother people; you can *use* this software to manipulate your\nBSD-licensed DLLs, your proprietary-licensed DLLs, or whatever you\nlike, and that's fine. The license affects the code for\nmachomachomangler itself; not the code you run it on.\n\nHowever, if for some reason you or your company have some kind of\nallergy to this license, send me `an email\n<mailto:njs@pobox.com>`_ and we'll work out an appropriate tithe.\n\nAlso, to preserve our options in case I get over this fit of pique,\nplease **license all contributions under the MIT license**. (I\ndefinitely will not switch to any proprietary license, but might\nswitch to a permissive OSS license.) Thanks!\n\n\nCode of conduct\n---------------\n\nContributors are requested to follow our `code of conduct\n<https://github.com/njsmith/machomachomangler/blob/master/CODE_OF_CONDUCT.md>`_\nin all project spaces.\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/njsmith/machomachomangler", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "machomachomangler", "package_url": "https://pypi.org/project/machomachomangler/", "platform": "", "project_url": "https://pypi.org/project/machomachomangler/", "project_urls": {"Homepage": "https://github.com/njsmith/machomachomangler"}, "release_url": "https://pypi.org/project/machomachomangler/0.0.1/", "requires_dist": ["attrs"], "requires_python": "", "summary": "Tools for mangling Mach-O and PE binaries", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/njsmith/machomachomangler\" rel=\"nofollow\"><img alt=\"Automated test status (Travis)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c46e6b6d95804dd8b133510ce70ceeda0c740bfd/68747470733a2f2f7472617669732d63692e6f72672f6e6a736d6974682f6d6163686f6d6163686f6d616e676c65722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://ci.appveyor.com/project/njsmith/machomachomangler\" rel=\"nofollow\"><img alt=\"Automated test status (Appveyor)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/12ac1bc5d8afa4d70a83bd56d4898d7ff24c3716/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f397038637568783876776e3269326a703f7376673d74727565\"></a>\n<a href=\"https://codecov.io/gh/njsmith/machomachomangler\" rel=\"nofollow\"><img alt=\"Test coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f9a8414a83b936a265b16252993b21700373d83e/68747470733a2f2f636f6465636f762e696f2f67682f6e6a736d6974682f6d6163686f6d6163686f6d616e676c65722f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<p>This is a little library for mangling Mach-O and PE files in various\nways. These are the formats used for executables and shared libraries\non MacOS and Windows, respectively. (If you want the equivalent for\nfor Linux, then check out <a href=\"https://github.com/NixOS/patchelf\" rel=\"nofollow\">patchelf</a>.)</p>\n<div id=\"macho-o-features\">\n<h2>Macho-O features</h2>\n<p>Some rather specialized (and complex) Mach-O mangling tools designed\nto support <a href=\"https://github.com/njsmith/wheel-builders/blob/pynativelib-proposal/pynativelib-proposal.rst\" rel=\"nofollow\">the pynativelib proposal</a>\nto allow native libraries to be distributed as standalone <a href=\"https://pypi.python.org/pypi/wheel\" rel=\"nofollow\">wheel files</a>. Specifically this includes:</p>\n<ul>\n<li><p>For pynativelib libraries: a tool that takes a dylib, and a mangling\nrule, and applies the mangling rule to all the exported\nsymbols. E.g., it can convert a library that exports <tt>SSL_new</tt>\ninto one that exports <tt>pynativelib_openssl__SSL_new</tt>. It also\nchanges the library id while it\u2019s at it, e.g. from <tt>ssl.dylib</tt> -&gt;\n<tt>pynativelib_openssl__ssl.dylib</tt> (like <tt>install_name_tool <span class=\"pre\">-id</span></tt>)</p>\n<p>Additionally: a tool that creates a \u201cplaceholder\u201d library, which\nimports the mangled library described above, and then re-exports the\nsymbols under their original names.</p>\n</li>\n<li><p>For code that wants to use a pynativelib library: a tool that\ntakes a dylib/bundle/executable, a list of \u201coriginal\u201d dylibs, and\nfor each \u201coriginal\u201d dylib, a newname for that dylib, and a\nmangling rule. It then (a) replaces the import of the original\ndylib with an absolute import of the new dylib name from a\nnon-existent directory, (b) marks this as a \u201cweak\u201d import, (c)\napplies the mangling rule to all symbols imported from this dylib,\n(d) marks these symbols for lookup in the flat namespace.</p>\n</li>\n</ul>\n<p>It turns out that this <em>exact</em> combination of things is the only way\nprovided for by the MacOS linker/loader to have dylib/bundle A linked\nagainst dylib B where the relative on-disk location of A and B is not\nknown until after the executable starts, while preserving the usual\ntwo-level namespace rules for avoiding symbol collisions. I promise it\nwill all make sense once I have a chance to write it up properly\u2026</p>\n<p>Some known limitations of the Mach-O mangling code:</p>\n<ul>\n<li>Unsurprisingly, this kind of patching does not play well with code\nsigning. The code doesn\u2019t take any special case with signatures;\nthey\u2019ll probably just get messed up. If you want to sign your\nbinaries, then do your mangling first before signing.</li>\n<li>We currently only rewrite the new-style DYLD_INFO symbol table\n(introduced in 10.5), not the (almost?) totally redundant\nSYMTAB/DYSYMTAB symbol table. (Interesting fact: all Mach-O binaries\ninclude two completely different representations of their symbols\ntables. The new one is more compact, to save space, but then they\nkeep the old one around for compatibility, so\u2026 anyway.) As far as\nI can tell, the only thing in in modern MacOS that still uses\nSYMTAB/DYSYMTAB is <tt>dladdr</tt>, and I don\u2019t think anyone is relying\non <tt>dladdr</tt> output for, well\u2026 anything? I think worst case, you\nmight end up seeing the original symbol names inside a debugger or\nprofiler? But this wouldn\u2019t be <em>too</em> hard to fix if it becomes a\nproblem.</li>\n<li>It doesn\u2019t do any special handling of the DYLD_INFO weak_bind table,\nor weak exports. (NB these have nothing to do\n<tt><span class=\"pre\">__attribute__((weak))</span></tt> or <tt><span class=\"pre\">__attribute__((weak_import))</span></tt> or any\nof the mentions of the word <tt>weak</tt> in the <tt>ld</tt> man page \u00e2\u20ac\u201c I\nthink they\u2019re for implementing <a href=\"http://www.airs.com/blog/archives/52\" rel=\"nofollow\">vague linkage</a>.) This is <em>probably</em> not a\ndisastrous option, but I\u2019m not 100% sure whether it\u2019s actually\ncorrect \u00e2\u20ac\u201c it\u2019s an incredibly obscure part of the Mach-O format, and\nMach-O is pretty obscure to start with. Fortunately this feature is\nonly used by C++ libraries, so we can get started without it.</li>\n<li>When mangling imports, we convert any lazy imports (that need\nmangling) into eager imports. This is required because the lazy\nimport stubs hard-code the memory layout of the import table into\nimmediate constants inside the stub assembly itself, and I do not\nfeel like trying to automatically rewrite x86-64 opcodes. Instead,\nwe leave the lazy import table alone (so all the unmangled lazy\nimports can continue to use it), and eagerly bind all the mangled\nimports, so the unmangled stubs never get called.</li>\n<li>I noticed some new code dyld in MacOS 10.12 that imposes some\nannoying arbitrary restrictions on which order the different bits of\nDYLD_INFO appear in the file. This should only affect libraries that\nare built with 10.12 as their minimum required version, so for folks\ntrying to build stuff for general distribution this shouldn\u2019t matter\nfor a while. This also isn\u2019t hard to fix, it just means that we\u2019ll\nprobably have to start making some pointless redundant copies of\nbits of the file that we <em>didn\u2019t</em> change, just so that the second\ncopy can be placed after the bit of the file that we did change,\nwhich is tiresome and I haven\u2019t gotten around to it yet.</li>\n<li>When mangling imports, we don\u2019t check for re-exports, which are also\na kind of import. Should probably fix this\u2026</li>\n</ul>\n</div>\n<div id=\"pe-features\">\n<h2>PE features</h2>\n<p>A tool that can read in a PE file (<tt>.exe</tt> or <tt>.dll</tt>) that is\ncurrently linked to <tt>foo.dll</tt>, and rewrite it so that it becomes\nlinked to <tt>bar.dll</tt> instead (similar to <tt>patchelf <span class=\"pre\">--replace</span></tt> on\nLinux, or <tt>install_name_tool <span class=\"pre\">-change</span></tt> on OS X). This is useful for\navoiding naming collisions between different versions of the same\nlibrary.</p>\n<p>For example, suppose you have two Python extensions <tt>A.dll</tt> and\n<tt>B.dll</tt>, that are distributed separately by different people. They\nboth contain some fortran code linked to to <tt><span class=\"pre\">libgfortran-3.dll</span></tt>, so\nboth packages ship a copy of <tt><span class=\"pre\">libgfortran-3.dll</span></tt>. Because of the way\nWindows DLL loading works, what will happen is that if I load\n<tt>A.dll</tt> first, then <em>both</em> <tt>A.dll</tt> and <tt>B.dll</tt> will end up using\nA\u2019s copy of <tt><span class=\"pre\">libgfortran-3.dll</span></tt>, while B\u2019s copy will be ignored. (Or\nvice-versa if I import B first.) This will happen even if I arrange\nthings so that A\u2019s copy is not on the DLL search path at the time that\nB is loaded \u2013 Windows always checks for already-loaded DLL\u2019s with a\ngiven basename before it actually checks the DLL search path (modulo\nsome complications around SxS assemblies, but you don\u2019t really want to\ngo there).</p>\n<p>This is bad, because there\u2019s no guarantee that <tt>B.dll</tt> will work\nwith A\u2019s version of <tt><span class=\"pre\">libgfortran-3.dll</span></tt> (e.g., A\u2019s copy might be too\nold for B). Welcome to <a href=\"https://en.wikipedia.org/wiki/DLL_Hell\" rel=\"nofollow\">DLL hell</a>!</p>\n<p>We could avoid all this by renaming the colliding libraries to have\ndifferent names, e.g. <tt><span class=\"pre\">libgfortran-3-for-A.dll</span></tt> and\n<tt><span class=\"pre\">libgfortran-3-for-B.dll</span></tt>. But if we just rename the files, then\neverything will break, because <tt>A.dll</tt> is looking for\n<tt><span class=\"pre\">libgfortran-3.dll</span></tt>, not <tt><span class=\"pre\">libgfortran-3-for-A.dll</span></tt>.</p>\n<p>This is where <tt>machomachomangler</tt> comes in: it lets you patch\n<tt>A.dll</tt> so that it\u2019s linked to <tt><span class=\"pre\">libgfortran-3-for-A.dll</span></tt>. And then\neverything works. Hooray.</p>\n<p>This basically solves the same problem as private SxS assemblies,\nexcept better in all ways: it\u2019s simpler (no XML manifests), more\nflexible (no finicky requirements for the filesystem layout), and\ndoesn\u2019t require reading the awful SxS assembly documentation.</p>\n<p>Example usage:</p>\n<pre>$ python3 -m machomachomangler.cmd.redll A.dll A-patched.dll libgfortran-3.dll libgfortan-3-for-A.dll\n</pre>\n<p>There\u2019s an example in <tt>example/</tt> then you can play with. E.g. on\nDebian with a mingw-w64 cross-compiler and wine installed:</p>\n<pre>$ cd pe-example/\n\n$ ./build.sh\n+ i686-w64-mingw32-gcc -shared test_dll.c -o test_dll.dll\n+ i686-w64-mingw32-gcc test.c -o test.exe -L. -ltest_dll\n+ i686-w64-mingw32-strip test.exe\n\n$ wine test.exe\ndll_function says: test_dll\n\n$ mv test_dll.dll test_dll_renamed.dll\n\n# Apparently wine's way of signalling a missing DLL is to fail silently.\n$ wine test.exe || echo \"failed -- test_dll.dll is missing\"\nfailed -- test_dll.dll is missing\n\n$ PYTHONPATH=.. python3 -m machomachomangler.cmd.redll test.exe test-patched.exe test_dll.dll test_dll_renamed.dll\n\n# Now it works again:\n$ wine test-patched.exe\ndll_function says: test_dll\n</pre>\n<p>Some known limitations of the PE dll-import-switcheroo code:</p>\n<ul>\n<li><p>The command line tool could be less minimalist.</p>\n</li>\n<li><p>GNU <tt>objdump</tt> has a bug where it can\u2019t read the import tables of\nour patched PE files \u2013 it just shows all of the import table until\nit hits the patched entry, and then it stops displaying\nanything. (The issue is that <tt>binutils</tt> wants all the data\ninvolved in the import tables to come from a single PE section.)\nHowever, I\u2019ve tried giving the patched files to Dependency Walker,\n<tt>wine</tt>, and Windows itself, and they all handle them fine \u2013 so\nthe files are okay, it\u2019s just a bug in <tt>objdump</tt>. Just be warned\nthat if you\u2019re trying to use <tt>objdump</tt> to check if the patching\nworked, then it\u2019s almost certainly going to tell you a confusing\nlie.</p>\n</li>\n<li><p>Unsurprisingly, this kind of patching does not play well with code\nsigning. We try to at least clear any existing signatures (so that\nthe binary becomes unsigned, rather than signed with an invalid\nsignature), but this hasn\u2019t been tested.</p>\n</li>\n<li><p>We don\u2019t try to handle files with trailing data after the end of the\nPE file proper. This commonly occurs with e.g. self-extracting\narchives and installers. Shouldn\u2019t be a big deal in theory, but I\ndid find that when compiling a simple <tt>.exe</tt> with mingw-w64 the\ntool refused to work until I had run <tt>strip</tt> on the binary, even\nthough in theory this should work fine \u2013 so probably there\u2019s some\nimprovements possible.</p>\n<p>[Note to self: it looks like this is a GNU extension for putting\nlong section names into PE files, which I guess are they use for\ntheir debug format \u2013 this is <a href=\"https://sourceware.org/binutils/docs/bfd/coff.html\" rel=\"nofollow\">documented here</a>, search for\n\u201cCoff long section names\u201d. It\u2019s probably not hard to handle this\nbetter, e.g. by stripping it ourself or even fixing it up.]</p>\n</li>\n<li><p>We don\u2019t try to update the PE header checksum, since the algorithm\nfor doing this is (nominally) a secret, and I\u2019m informed that for\nregular user-space code there\u2019s nothing that actually cares about\nwhether it\u2019s correct. But my information could be wrong. (Note: it\nlooks like binutils might know how to compute this checksum? I\u2019m not\nsure.)</p>\n<p>[Update: Stefan Kanthak informs me that this algorithm is well\nknown, and in fact it looks <a href=\"https://github.com/erocarrera/pefile/blob/master/pefile.py#L5150\" rel=\"nofollow\">pefile has an MIT-licensed Python\nimplementation</a>\nso I guess it might be good to fix this at some point.]</p>\n</li>\n</ul>\n</div>\n<div id=\"general-limitations\">\n<h2>General limitations</h2>\n<p>Only tested on <strong>Python 3.4 and 3.5</strong>. Probably any Python 3 will\nwork, and Python 2 definitely won\u2019t without some fixes. (There\u2019s lots\nof fiddly byte-string handling.)</p>\n<p>I\u2019m lazy, so I just load the whole binary files into memory \u2013 maybe\nseveral copies of it. This actually wouldn\u2019t be too hard to fix (using\nmemory mapping etc.) but I guess it doesn\u2019t matter that much because\n<a href=\"http://tvtropes.org/pmwiki/pmwiki.php/Main/WhatCouldPossiblyGoWrong\" rel=\"nofollow\">who has multi-gigabyte Mach-O/PE images?</a>?</p>\n</div>\n<div id=\"contact\">\n<h2>Contact</h2>\n<p><a href=\"mailto:wheel-builders%40python.org\">wheel-builders<span>@</span>python<span>.</span>org</a></p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>It\u2019s Saturday afternoon, I\u2019ve got the flu or something, and I\u2019m\nspending my free time writing software to make some proprietary\noperating systems \u2013 ones that are backed by one of the world\u2019s larger\ncorporations \u2013 better able to compete for developers with other,\nbetter-designed operating systems. I mean, I\u2019m not saying that poring\nover the PE/COFF specification isn\u2019t fun!  But it\u2019s not <em>that</em>\nfun. (And honestly the Mach-O docs are absolutely terrible, to the\nextent they exist at all.)</p>\n<p>To assuage my annoyance, this software is licensed under the <em>GNU\nAffero General Public License as published by the Free Software\nFoundation, either version 3 of the License or (at your option)\nany later version</em>. See <tt>LICENSE.txt</tt> for details.</p>\n<p>This <strong>shouldn\u2019t have any effect</strong> on most uses, since it only affects\npeople who are redistributing this software or running it on behalf of\nother people; you can <em>use</em> this software to manipulate your\nBSD-licensed DLLs, your proprietary-licensed DLLs, or whatever you\nlike, and that\u2019s fine. The license affects the code for\nmachomachomangler itself; not the code you run it on.</p>\n<p>However, if for some reason you or your company have some kind of\nallergy to this license, send me <a href=\"mailto:njs%40pobox.com\">an email</a> and we\u2019ll work out an appropriate tithe.</p>\n<p>Also, to preserve our options in case I get over this fit of pique,\nplease <strong>license all contributions under the MIT license</strong>. (I\ndefinitely will not switch to any proprietary license, but might\nswitch to a permissive OSS license.) Thanks!</p>\n</div>\n<div id=\"code-of-conduct\">\n<h2>Code of conduct</h2>\n<p>Contributors are requested to follow our <a href=\"https://github.com/njsmith/machomachomangler/blob/master/CODE_OF_CONDUCT.md\" rel=\"nofollow\">code of conduct</a>\nin all project spaces.</p>\n</div>\n\n          </div>"}, "last_serial": 3482442, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "6a9efa0be78389fb20604fe09e281f34", "sha256": "4fa66b8b65959399874f05a4d93abe1e49db46f71bef66a68a93e060d9ba0cb3"}, "downloads": -1, "filename": "machomachomangler-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "6a9efa0be78389fb20604fe09e281f34", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 70901, "upload_time": "2018-01-11T23:32:27", "upload_time_iso_8601": "2018-01-11T23:32:27.197498Z", "url": "https://files.pythonhosted.org/packages/71/df/fba669db568cc25eb44a726bbce1a0a40e3a1c5b10a1a57492877b79c00b/machomachomangler-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2d78acc236d6c9469787191c5dbfcee2", "sha256": "2acbad5bd465c5f386e5ceac8a8a1939a9789f503dd84f491e046292cf6e54a6"}, "downloads": -1, "filename": "machomachomangler-0.0.1.tar.gz", "has_sig": false, "md5_digest": "2d78acc236d6c9469787191c5dbfcee2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64271, "upload_time": "2018-01-11T23:32:28", "upload_time_iso_8601": "2018-01-11T23:32:28.608911Z", "url": "https://files.pythonhosted.org/packages/d0/29/d9f07b12f19d0fe64c1e88bbbebe49faf710841144c5a67dba5b98f42ab6/machomachomangler-0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6a9efa0be78389fb20604fe09e281f34", "sha256": "4fa66b8b65959399874f05a4d93abe1e49db46f71bef66a68a93e060d9ba0cb3"}, "downloads": -1, "filename": "machomachomangler-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "6a9efa0be78389fb20604fe09e281f34", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 70901, "upload_time": "2018-01-11T23:32:27", "upload_time_iso_8601": "2018-01-11T23:32:27.197498Z", "url": "https://files.pythonhosted.org/packages/71/df/fba669db568cc25eb44a726bbce1a0a40e3a1c5b10a1a57492877b79c00b/machomachomangler-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2d78acc236d6c9469787191c5dbfcee2", "sha256": "2acbad5bd465c5f386e5ceac8a8a1939a9789f503dd84f491e046292cf6e54a6"}, "downloads": -1, "filename": "machomachomangler-0.0.1.tar.gz", "has_sig": false, "md5_digest": "2d78acc236d6c9469787191c5dbfcee2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64271, "upload_time": "2018-01-11T23:32:28", "upload_time_iso_8601": "2018-01-11T23:32:28.608911Z", "url": "https://files.pythonhosted.org/packages/d0/29/d9f07b12f19d0fe64c1e88bbbebe49faf710841144c5a67dba5b98f42ab6/machomachomangler-0.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:42:20 2020"}