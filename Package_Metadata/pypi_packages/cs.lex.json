{"info": {"author": "Cameron Simpson", "author_email": "cs@cskk.id.au", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "*Latest release 20200318*:\nNew lc_() function to lowercase and dash a string, new titleify_lc() to mostly reverse lc_().\nNew format_as function, FormatableMixin and related FormatAsError.\n\nLexical analysis functions, tokenisers, transcribers.\n\nAn arbitrary assortment of lexical and tokenisation functions useful\nfor writing recursive descent parsers, of which I have several.\nThere are also some transcription function for producing text\nfrom various objects, such as `hexify` and `unctrl`.\n\nGenerally the get_* functions accept a source string and an offset\n(usually optional, default `0`) and return a token and the new offset,\nraising `ValueError` on failed tokenisation.\n\n## Function `as_lines(chunks, partials=None)`\n\nGenerator yielding complete lines from arbitrary pieces of text from\nthe iterable `chunks`.\n\nAfter completion, any remaining newline-free chunks remain\nin the partials list; this will be unavailable to the caller\nunless the list is presupplied.\n\n## Function `cutprefix(s, prefix)`\n\nStrip a `prefix` from the front of `s`.\nReturn the suffix if `.startswith(prefix)`, else `s`.\n\nExample:\n\n    >>> abc_def = 'abc.def'\n    >>> cutprefix(abc_def, 'abc.')\n    'def'\n    >>> cutprefix(abc_def, 'zzz.')\n    'abc.def'\n    >>> cutprefix(abc_def, '.zzz') is abc_def\n    True\n\n## Function `cutsuffix(s, suffix)`\n\nStrip a `suffix` from the end of `s`.\nReturn the prefix if `.endswith(suffix)`, else `s`.\n\nExample:\n\n    >>> abc_def = 'abc.def'\n    >>> cutsuffix(abc_def, '.def')\n    'abc'\n    >>> cutsuffix(abc_def, '.zzz')\n    'abc.def'\n    >>> cutsuffix(abc_def, '.zzz') is abc_def\n    True\n\n## Function `format_as(format_s, format_mapping, error_sep=None)`\n\nFormat the string `format_s` using `format_mapping`,\nreturn the formatted result.\nThis is a wrapper for `str.format_map`\nwhich raises a more informative `FormatAsError` exception on failure.\n\nParameters:\n* `format_s`: the format string to use as the template\n* `format_mapping`: the mapping of available replacement fields\n* `error_sep`: optional separator for the multipart error message,\n  default from FormatAsError.DEFAULT_SEPARATOR:\n  `'; '`\n\n## Class `FormatableMixin`\n\nA mixin to supply a `format_as` method for classes with an\nexisting `format_kwargs` method.\n\nThe `format_as` method is like an inside out `str.format` or\n`object._format__` method.\n`str.format` is designed for formatting a string from a variety\nof other obejcts supplied in the keyword arguments,\nand `object.__format__` is for filling out a single `str.format`\nreplacement field from a single object.\nBy contrast, `format_as` is designed to fill out an entire format\nstring from the current object.\n\nFor example, the `cs.tagset.TagSet` class\nuses `FormatableMixin` to provide a `format_as` method\nwhose replacement fields are derived from the tags in the tag set.\n\n## Class `FormatAsError(builtins.LookupError,builtins.Exception,builtins.BaseException)`\n\nSubclass of `LookupError` for use by `format_as`.\n\n## Function `get_chars(s, offset, gochars)`\n\nScan the string `s` for characters in `gochars` starting at `offset`.\nReturn `(match,new_offset)`.\n\n## Function `get_decimal(s, offset=0)`\n\nScan the string `s` for decimal characters starting at `offset`.\nReturn `(dec_string,new_offset)`.\n\n## Function `get_decimal_or_float_value(s, offset=0)`\n\nFetch a decimal or basic float (nnn.nnn) value\nfrom the str `s` at `offset`.\nReturn `(value,new_offset)`.\n\n## Function `get_decimal_value(s, offset=0)`\n\nScan the string `s` for a decimal value starting at `offset`.\nReturn `(value,new_offset)`.\n\n## Function `get_delimited(s, offset, delim)`\n\nCollect text from the string `s` from position `offset` up\nto the first occurence of delimiter `delim`; return the text\nexcluding the delimiter and the offset after the delimiter.\n\n## Function `get_dotted_identifier(s, offset=0, **kw)`\n\nScan the string `s` for a dotted identifier (by default an\nASCII letter or underscore followed by letters, digits or\nunderscores) with optional trailing dot and another dotted\nidentifier, starting at `offset` (default `0`).\nReturn `(match,new_offset)`.\n\nNote: the empty string and an unchanged offset will be returned if\nthere is no leading letter/underscore.\n\n## Function `get_envvar(s, offset=0, environ=None, default=None, specials=None)`\n\nParse a simple environment variable reference to $varname or\n$x where \"x\" is a special character.\n\nParameters:\n* `s`: the string with the variable reference\n* `offset`: the starting point for the reference\n* `default`: default value for missing environment variables;\n   if None (the default) a ValueError is raised\n* `environ`: the environment mapping, default os.environ\n* `specials`: the mapping of special single character variables\n\n## Function `get_hexadecimal(s, offset=0)`\n\nScan the string `s` for hexadecimal characters starting at `offset`.\nReturn `(hex_string,new_offset)`.\n\n## Function `get_hexadecimal_value(s, offset=0)`\n\nScan the string `s` for a hexadecimal value starting at `offset`.\nReturn `(value,new_offset)`.\n\n## Function `get_identifier(s, offset=0, alpha='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', number='0123456789', extras='_')`\n\nScan the string `s` for an identifier (by default an ASCII\nletter or underscore followed by letters, digits or underscores)\nstarting at `offset` (default 0).\nReturn `(match,new_offset)`.\n\n*Note*: the empty string and an unchanged offset will be returned if\nthere is no leading letter/underscore.\n\nParameters:\n* `s`: the string to scan\n* `offset`: the starting offset, default `0`.\n* `alpha`: the characters considered alphabetic,\n  default `string.ascii_letters`.\n* `number`: the characters considered numeric,\n  default `string.digits`.\n* `extras`: extra characters considered part of an identifier,\n  default `'_'`.\n\n## Function `get_nonwhite(s, offset=0)`\n\nScan the string `s` for characters not in `string.whitespace`\nstarting at `offset` (default 0).\nReturn `(match,new_offset)`.\n\n## Function `get_other_chars(s, offset=0, stopchars=None)`\n\nScan the string `s` for characters not in `stopchars` starting\nat `offset` (default `0`).\nReturn `(match,new_offset)`.\n\n## Function `get_qstr(s, offset=0, q='\"', environ=None, default=None, env_specials=None)`\n\nGet quoted text with slosh escapes and optional environment substitution.\n\nParameters:\n* `s`: the string containg the quoted text.\n* `offset`: the starting point, default 0.\n* `q`: the quote character, default `'\"'`. If `q` is set to `None`,\n  do not expect the string to be delimited by quote marks.\n* `environ`: if not `None`, also parse and expand $envvar references.\n* `default`: passed to `get_envvar`\n\n## Function `get_qstr_or_identifier(s, offset)`\n\nParse a double quoted string or an identifier.\n\n## Function `get_sloshed_text(s, delim, offset=0, slosh='\\\\', mapper=<function slosh_mapper at 0x10fb968b0>, specials=None)`\n\nCollect slosh escaped text from the string `s` from position\n`offset` (default `0`) and return the decoded unicode string and\nthe offset of the completed parse.\n\nParameters:\n* `delim`: end of string delimiter, such as a single or double quote.\n* `offset`: starting offset within `s`, default `0`.\n* `slosh`: escape character, default a slosh ('\\').\n* `mapper`: a mapping function which accepts a single character\n  and returns a replacement string or `None`; this is used the\n  replace things such as '\\t' or '\\n'. The default is the\n  `slosh_mapper` function, whose default mapping is `SLOSH_CHARMAP`.\n* `specials`: a mapping of other special character sequences and parse\n  functions for gathering them up. When one of the special\n  character sequences is found in the string, the parse\n  function is called to parse at that point.\n  The parse functions accept\n  `s` and the offset of the special character. They return\n  the decoded string and the offset past the parse.\n\nThe escape character `slosh` introduces an encoding of some\nreplacement text whose value depends on the following character.\nIf the following character is:\n* the escape character `slosh`, insert the escape character.\n* the string delimiter `delim`, insert the delimiter.\n* the character 'x', insert the character with code from the following\n  2 hexadecimal digits.\n* the character 'u', insert the character with code from the following\n  4 hexadecimal digits.\n* the character 'U', insert the character with code from the following\n  8 hexadecimal digits.\n* a character from the keys of `mapper`\n\n## Function `get_tokens(s, offset, getters)`\n\nParse the string `s` from position `offset` using the supplied\ntokenise functions `getters`; return the list of tokens matched\nand the final offset.\n\nParameters:\n* `s`: the string to parse.\n* `offset`: the starting position for the parse.\n* `getters`: an iterable of tokeniser specifications.\n\nEach tokeniser specification is either:\n* a callable expecting (s, offset) and returning (token, new_offset)\n* a literal string, to be matched exactly\n* a tuple or list with values (func, args, kwargs);\n  call func(s, offset, *args, **kwargs)\n* an object with a .match method such as a regex;\n  call getter.match(s, offset) and return a match object with\n  a .end() method returning the offset of the end of the match\n\n## Function `get_uc_identifier(s, offset=0, number='0123456789', extras='_')`\n\nScan the string `s` for an identifier as for `get_identifier`,\nbut require the letters to be uppercase.\n\n## Function `get_white(s, offset=0)`\n\nScan the string `s` for characters in `string.whitespace`\nstarting at `offset` (default `0`).\nReturn `(match,new_offset)`.\n\n## Function `hexify(bs)`\n\nA flavour of `binascii.hexlify` returning a `str`.\n\n## Function `htmlify(s, nbsp=False)`\n\nConvert a string for safe transcription in HTML.\n\nParameters:\n* `s`: the string\n* `nbsp`: replaces spaces with `\"&nbsp;\"` to prevent word folding,\n  default `False`.\n\n## Function `htmlquote(s)`\n\nQuote a string for use in HTML.\n\n## Function `is_dotted_identifier(s, offset=0, **kw)`\n\nTest if the string `s` is an identifier from position `offset` onward.\n\n## Function `is_identifier(s, offset=0, **kw)`\n\nTest if the string `s` is an identifier from position `offset` onward.\n\n## Function `isUC_(s)`\n\nCheck that a string matches `^[A-Z][A-Z_0-9]*$`.\n\n## Function `jsquote(s)`\n\nQuote a string for use in JavaScript.\n\n## Function `lastlinelen(s)`\n\nThe length of text after the last newline in a string.\n\n(Initially used by cs.hier to compute effective text width.)\n\n## Function `lc_(value)`\n\nReturn `value.lower()`\nwith `'-'` translated into `'_'` and `' '` translated into `'-'`.\n\nI use this to construct lowercase filenames containing a\nreadable transcription of a title string.\n\nSee also `titleify_lc()`, an imperfect reversal of this.\n\n## Function `match_tokens(s, offset, getters)`\n\nWrapper for get_tokens which catches ValueError exceptions\nand returns (None, offset).\n\n## Function `parseUC_sAttr(attr)`\n\nTake an attribute name and return `(key, is_plural)`.\n\n`'FOO'` returns `(`FOO`, False)`.\n`'FOOs'` or `'FOOes'` returns `('FOO', True)`.\nOtherwise return `(None, False)`.\n\n## Function `phpquote(s)`\n\nQuote a string for use in PHP code.\n\n## Function `skipwhite(s, offset=0)`\n\nConvenience routine for skipping past whitespace;\nreturns the offset of the next nonwhitespace character.\n\n## Function `slosh_mapper(c, charmap=None)`\n\nReturn a string to replace backslash-`c`, or `None`.\n\n## Function `stripped_dedent(s)`\n\nSlightly smarter dedent which ignores a string's opening indent.\n\nAlgorithm:\nstrip the supplied string `s`, pull off the leading line,\ndedent the rest, put back the leading line.\n\nThis supports my preferred docstring layout, where the opening\nline of text is on the same line as the opening quote.\n\nExample:\n\n    >>> def func(s):\n    ...   \"\"\" Slightly smarter dedent which ignores a string's opening indent.\n    ...       Strip the supplied string `s`. Pull off the leading line.\n    ...       Dedent the rest. Put back the leading line.\n    ...   \"\"\"\n    ...   pass\n    ...\n    >>> from cs.lex import stripped_dedent\n    >>> print(stripped_dedent(func.__doc__))\n    Slightly smarter dedent which ignores a string's opening indent.\n    Strip the supplied string `s`. Pull off the leading line.\n    Dedent the rest. Put back the leading line.\n\n## Function `strlist(ary, sep=', ')`\n\nConvert an iterable to strings and join with \", \".\n\n## Function `tabpadding(padlen, tabsize=8, offset=0)`\n\nCompute some spaces to use a tab padding at an offfset.\n\n## Function `texthexify(bs, shiftin='[', shiftout=']', whitelist=None)`\n\nTranscribe the bytes `bs` to text using compact text runs for\nsome common text values.\n\nThis can be reversed with the `untexthexify` function.\n\nThis is an ad doc format devised to be compact but also to\nexpose \"text\" embedded within to the eye. The original use\ncase was transcribing a binary directory entry format, where\nthe filename parts would be somewhat visible in the transcription.\n\nThe output is a string of hexadecimal digits for the encoded\nbytes except for runs of values from the whitelist, which are\nenclosed in the shiftin and shiftout markers and transcribed\nas is. The default whitelist is values of the ASCII letters,\nthe decimal digits and the punctuation characters '_-+.,'.\nThe default shiftin and shiftout markers are '[' and ']'.\n\nString objects converted with either `hexify` and `texthexify`\noutput strings may be freely concatenated and decoded with\n`untexthexify`.\n\nExample:\n\n    >>> texthexify(b'&^%&^%abcdefghi)(*)(*')\n    '265e25265e25[abcdefghi]29282a29282a'\n\nParameters:\n* `bs`: the bytes to transcribe\n* `shiftin`: Optional. The marker string used to indicate a shift to\n  direct textual transcription of the bytes, default: `'['`.\n* `shiftout`: Optional. The marker string used to indicate a\n  shift from text mode back into hexadecimal transcription,\n  default `']'`.\n* `whitelist`: an optional bytes or string object indicating byte\n  values which may be represented directly in text;\n  the default value is the ASCII letters, the decimal digits\n  and the punctuation characters `'_-+.,'`.\n\n## Function `titleify_lc(value_lc)`\n\nTranslate `'-'` into `' '` and `'_'` translated into `'-'`,\nthen titlecased.\n\nSee also `lc_()`, which this reverses imperfectly.\n\n## Function `unctrl(s, tabsize=8)`\n\nReturn the string `s` with TABs expanded and control characters\nreplaced with printable representations.\n\n## Function `untexthexify(s, shiftin='[', shiftout=']')`\n\nDecode a textual representation of binary data into binary data.\n\nThis is the reverse of the `texthexify` function.\n\nOutside of the `shiftin`/`shiftout` markers the binary data\nare represented as hexadecimal. Within the markers the bytes\nhave the values of the ordinals of the characters.\n\nExample:\n\n    >>> untexthexify('265e25265e25[abcdefghi]29282a29282a')\n    b'&^%&^%abcdefghi)(*)(*'\n\nParameters:\n* `s`: the string containing the text representation.\n* `shiftin`: Optional. The marker string commencing a sequence\n  of direct text transcription, default `'['`.\n* `shiftout`: Optional. The marker string ending a sequence\n  of direct text transcription, default `']'`.\n\n\n\n# Release Log\n\n*Release 20200318*:\nNew lc_() function to lowercase and dash a string, new titleify_lc() to mostly reverse lc_().\nNew format_as function, FormatableMixin and related FormatAsError.\n\n*Release 20200229*:\nNew cutprefix and cutsuffix functions.\n\n*Release 20190812*:\nFix bad slosh escapes in strings.\n\n*Release 20190220*:\nNew function get_qstr_or_identifier.\n\n*Release 20181108*:\nnew function get_decimal_or_float_value to read a decimal or basic float\n\n*Release 20180815*:\nNo semantic changes; update some docstrings and clean some lint, fix a unit test.\n\n*Release 20180810*:\nNew get_decimal_value and get_hexadecimal_value functions.\nNew stripped_dedent function, a slightly smarter textwrap.dedent.\n\n*Release 20171231*:\nNew function get_decimal. Drop unused function dict2js.\n\n*Release 20170904*:\nPython 2/3 ports, move rfc2047 into new cs.rfc2047 module.\n\n*Release 20160828*:\nUse \"install_requires\" instead of \"requires\" in DISTINFO.\nDiscard str1(), pointless optimisation.\nunrfc2047: map _ to SPACE, improve exception handling.\nAdd phpquote: quote a string for use in PHP code; add docstring to jsquote.\nAdd is_identifier test.\nAdd get_dotted_identifier.\nAdd is_dotted_identifier.\nAdd get_hexadecimal.\nAdd skipwhite, convenince wrapper for get_white returning just the next offset.\nAssorted bugfixes and improvements.\n\n*Release 20150120*:\ncs.lex: texthexify: backport to python 2 using cs.py3 bytes type\n\n*Release 20150118*:\nmetadata updates\n\n*Release 20150116*:\nPyPI metadata and slight code cleanup.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/cameron_simpson/css/commits/all", "keywords": "python2,python3", "license": "GNU General Public License v3 or later (GPLv3+)", "maintainer": "", "maintainer_email": "", "name": "cs.lex", "package_url": "https://pypi.org/project/cs.lex/", "platform": "", "project_url": "https://pypi.org/project/cs.lex/", "project_urls": {"Homepage": "https://bitbucket.org/cameron_simpson/css/commits/all"}, "release_url": "https://pypi.org/project/cs.lex/20200318/", "requires_dist": null, "requires_python": "", "summary": "Lexical analysis functions, tokenisers, transcribers.", "version": "20200318", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><em>Latest release 20200318</em>:\nNew lc_() function to lowercase and dash a string, new titleify_lc() to mostly reverse lc_().\nNew format_as function, FormatableMixin and related FormatAsError.</p>\n<p>Lexical analysis functions, tokenisers, transcribers.</p>\n<p>An arbitrary assortment of lexical and tokenisation functions useful\nfor writing recursive descent parsers, of which I have several.\nThere are also some transcription function for producing text\nfrom various objects, such as <code>hexify</code> and <code>unctrl</code>.</p>\n<p>Generally the get_* functions accept a source string and an offset\n(usually optional, default <code>0</code>) and return a token and the new offset,\nraising <code>ValueError</code> on failed tokenisation.</p>\n<h2>Function <code>as_lines(chunks, partials=None)</code></h2>\n<p>Generator yielding complete lines from arbitrary pieces of text from\nthe iterable <code>chunks</code>.</p>\n<p>After completion, any remaining newline-free chunks remain\nin the partials list; this will be unavailable to the caller\nunless the list is presupplied.</p>\n<h2>Function <code>cutprefix(s, prefix)</code></h2>\n<p>Strip a <code>prefix</code> from the front of <code>s</code>.\nReturn the suffix if <code>.startswith(prefix)</code>, else <code>s</code>.</p>\n<p>Example:</p>\n<pre><code>&gt;&gt;&gt; abc_def = 'abc.def'\n&gt;&gt;&gt; cutprefix(abc_def, 'abc.')\n'def'\n&gt;&gt;&gt; cutprefix(abc_def, 'zzz.')\n'abc.def'\n&gt;&gt;&gt; cutprefix(abc_def, '.zzz') is abc_def\nTrue\n</code></pre>\n<h2>Function <code>cutsuffix(s, suffix)</code></h2>\n<p>Strip a <code>suffix</code> from the end of <code>s</code>.\nReturn the prefix if <code>.endswith(suffix)</code>, else <code>s</code>.</p>\n<p>Example:</p>\n<pre><code>&gt;&gt;&gt; abc_def = 'abc.def'\n&gt;&gt;&gt; cutsuffix(abc_def, '.def')\n'abc'\n&gt;&gt;&gt; cutsuffix(abc_def, '.zzz')\n'abc.def'\n&gt;&gt;&gt; cutsuffix(abc_def, '.zzz') is abc_def\nTrue\n</code></pre>\n<h2>Function <code>format_as(format_s, format_mapping, error_sep=None)</code></h2>\n<p>Format the string <code>format_s</code> using <code>format_mapping</code>,\nreturn the formatted result.\nThis is a wrapper for <code>str.format_map</code>\nwhich raises a more informative <code>FormatAsError</code> exception on failure.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>format_s</code>: the format string to use as the template</li>\n<li><code>format_mapping</code>: the mapping of available replacement fields</li>\n<li><code>error_sep</code>: optional separator for the multipart error message,\ndefault from FormatAsError.DEFAULT_SEPARATOR:\n<code>'; '</code></li>\n</ul>\n<h2>Class <code>FormatableMixin</code></h2>\n<p>A mixin to supply a <code>format_as</code> method for classes with an\nexisting <code>format_kwargs</code> method.</p>\n<p>The <code>format_as</code> method is like an inside out <code>str.format</code> or\n<code>object._format__</code> method.\n<code>str.format</code> is designed for formatting a string from a variety\nof other obejcts supplied in the keyword arguments,\nand <code>object.__format__</code> is for filling out a single <code>str.format</code>\nreplacement field from a single object.\nBy contrast, <code>format_as</code> is designed to fill out an entire format\nstring from the current object.</p>\n<p>For example, the <code>cs.tagset.TagSet</code> class\nuses <code>FormatableMixin</code> to provide a <code>format_as</code> method\nwhose replacement fields are derived from the tags in the tag set.</p>\n<h2>Class <code>FormatAsError(builtins.LookupError,builtins.Exception,builtins.BaseException)</code></h2>\n<p>Subclass of <code>LookupError</code> for use by <code>format_as</code>.</p>\n<h2>Function <code>get_chars(s, offset, gochars)</code></h2>\n<p>Scan the string <code>s</code> for characters in <code>gochars</code> starting at <code>offset</code>.\nReturn <code>(match,new_offset)</code>.</p>\n<h2>Function <code>get_decimal(s, offset=0)</code></h2>\n<p>Scan the string <code>s</code> for decimal characters starting at <code>offset</code>.\nReturn <code>(dec_string,new_offset)</code>.</p>\n<h2>Function <code>get_decimal_or_float_value(s, offset=0)</code></h2>\n<p>Fetch a decimal or basic float (nnn.nnn) value\nfrom the str <code>s</code> at <code>offset</code>.\nReturn <code>(value,new_offset)</code>.</p>\n<h2>Function <code>get_decimal_value(s, offset=0)</code></h2>\n<p>Scan the string <code>s</code> for a decimal value starting at <code>offset</code>.\nReturn <code>(value,new_offset)</code>.</p>\n<h2>Function <code>get_delimited(s, offset, delim)</code></h2>\n<p>Collect text from the string <code>s</code> from position <code>offset</code> up\nto the first occurence of delimiter <code>delim</code>; return the text\nexcluding the delimiter and the offset after the delimiter.</p>\n<h2>Function <code>get_dotted_identifier(s, offset=0, **kw)</code></h2>\n<p>Scan the string <code>s</code> for a dotted identifier (by default an\nASCII letter or underscore followed by letters, digits or\nunderscores) with optional trailing dot and another dotted\nidentifier, starting at <code>offset</code> (default <code>0</code>).\nReturn <code>(match,new_offset)</code>.</p>\n<p>Note: the empty string and an unchanged offset will be returned if\nthere is no leading letter/underscore.</p>\n<h2>Function <code>get_envvar(s, offset=0, environ=None, default=None, specials=None)</code></h2>\n<p>Parse a simple environment variable reference to $varname or\n$x where \"x\" is a special character.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>s</code>: the string with the variable reference</li>\n<li><code>offset</code>: the starting point for the reference</li>\n<li><code>default</code>: default value for missing environment variables;\nif None (the default) a ValueError is raised</li>\n<li><code>environ</code>: the environment mapping, default os.environ</li>\n<li><code>specials</code>: the mapping of special single character variables</li>\n</ul>\n<h2>Function <code>get_hexadecimal(s, offset=0)</code></h2>\n<p>Scan the string <code>s</code> for hexadecimal characters starting at <code>offset</code>.\nReturn <code>(hex_string,new_offset)</code>.</p>\n<h2>Function <code>get_hexadecimal_value(s, offset=0)</code></h2>\n<p>Scan the string <code>s</code> for a hexadecimal value starting at <code>offset</code>.\nReturn <code>(value,new_offset)</code>.</p>\n<h2>Function <code>get_identifier(s, offset=0, alpha='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', number='0123456789', extras='_')</code></h2>\n<p>Scan the string <code>s</code> for an identifier (by default an ASCII\nletter or underscore followed by letters, digits or underscores)\nstarting at <code>offset</code> (default 0).\nReturn <code>(match,new_offset)</code>.</p>\n<p><em>Note</em>: the empty string and an unchanged offset will be returned if\nthere is no leading letter/underscore.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>s</code>: the string to scan</li>\n<li><code>offset</code>: the starting offset, default <code>0</code>.</li>\n<li><code>alpha</code>: the characters considered alphabetic,\ndefault <code>string.ascii_letters</code>.</li>\n<li><code>number</code>: the characters considered numeric,\ndefault <code>string.digits</code>.</li>\n<li><code>extras</code>: extra characters considered part of an identifier,\ndefault <code>'_'</code>.</li>\n</ul>\n<h2>Function <code>get_nonwhite(s, offset=0)</code></h2>\n<p>Scan the string <code>s</code> for characters not in <code>string.whitespace</code>\nstarting at <code>offset</code> (default 0).\nReturn <code>(match,new_offset)</code>.</p>\n<h2>Function <code>get_other_chars(s, offset=0, stopchars=None)</code></h2>\n<p>Scan the string <code>s</code> for characters not in <code>stopchars</code> starting\nat <code>offset</code> (default <code>0</code>).\nReturn <code>(match,new_offset)</code>.</p>\n<h2>Function <code>get_qstr(s, offset=0, q='\"', environ=None, default=None, env_specials=None)</code></h2>\n<p>Get quoted text with slosh escapes and optional environment substitution.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>s</code>: the string containg the quoted text.</li>\n<li><code>offset</code>: the starting point, default 0.</li>\n<li><code>q</code>: the quote character, default <code>'\"'</code>. If <code>q</code> is set to <code>None</code>,\ndo not expect the string to be delimited by quote marks.</li>\n<li><code>environ</code>: if not <code>None</code>, also parse and expand $envvar references.</li>\n<li><code>default</code>: passed to <code>get_envvar</code></li>\n</ul>\n<h2>Function <code>get_qstr_or_identifier(s, offset)</code></h2>\n<p>Parse a double quoted string or an identifier.</p>\n<h2>Function <code>get_sloshed_text(s, delim, offset=0, slosh='\\\\', mapper=&lt;function slosh_mapper at 0x10fb968b0&gt;, specials=None)</code></h2>\n<p>Collect slosh escaped text from the string <code>s</code> from position\n<code>offset</code> (default <code>0</code>) and return the decoded unicode string and\nthe offset of the completed parse.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>delim</code>: end of string delimiter, such as a single or double quote.</li>\n<li><code>offset</code>: starting offset within <code>s</code>, default <code>0</code>.</li>\n<li><code>slosh</code>: escape character, default a slosh ('').</li>\n<li><code>mapper</code>: a mapping function which accepts a single character\nand returns a replacement string or <code>None</code>; this is used the\nreplace things such as '\\t' or '\\n'. The default is the\n<code>slosh_mapper</code> function, whose default mapping is <code>SLOSH_CHARMAP</code>.</li>\n<li><code>specials</code>: a mapping of other special character sequences and parse\nfunctions for gathering them up. When one of the special\ncharacter sequences is found in the string, the parse\nfunction is called to parse at that point.\nThe parse functions accept\n<code>s</code> and the offset of the special character. They return\nthe decoded string and the offset past the parse.</li>\n</ul>\n<p>The escape character <code>slosh</code> introduces an encoding of some\nreplacement text whose value depends on the following character.\nIf the following character is:</p>\n<ul>\n<li>the escape character <code>slosh</code>, insert the escape character.</li>\n<li>the string delimiter <code>delim</code>, insert the delimiter.</li>\n<li>the character 'x', insert the character with code from the following\n2 hexadecimal digits.</li>\n<li>the character 'u', insert the character with code from the following\n4 hexadecimal digits.</li>\n<li>the character 'U', insert the character with code from the following\n8 hexadecimal digits.</li>\n<li>a character from the keys of <code>mapper</code></li>\n</ul>\n<h2>Function <code>get_tokens(s, offset, getters)</code></h2>\n<p>Parse the string <code>s</code> from position <code>offset</code> using the supplied\ntokenise functions <code>getters</code>; return the list of tokens matched\nand the final offset.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>s</code>: the string to parse.</li>\n<li><code>offset</code>: the starting position for the parse.</li>\n<li><code>getters</code>: an iterable of tokeniser specifications.</li>\n</ul>\n<p>Each tokeniser specification is either:</p>\n<ul>\n<li>a callable expecting (s, offset) and returning (token, new_offset)</li>\n<li>a literal string, to be matched exactly</li>\n<li>a tuple or list with values (func, args, kwargs);\ncall func(s, offset, *args, **kwargs)</li>\n<li>an object with a .match method such as a regex;\ncall getter.match(s, offset) and return a match object with\na .end() method returning the offset of the end of the match</li>\n</ul>\n<h2>Function <code>get_uc_identifier(s, offset=0, number='0123456789', extras='_')</code></h2>\n<p>Scan the string <code>s</code> for an identifier as for <code>get_identifier</code>,\nbut require the letters to be uppercase.</p>\n<h2>Function <code>get_white(s, offset=0)</code></h2>\n<p>Scan the string <code>s</code> for characters in <code>string.whitespace</code>\nstarting at <code>offset</code> (default <code>0</code>).\nReturn <code>(match,new_offset)</code>.</p>\n<h2>Function <code>hexify(bs)</code></h2>\n<p>A flavour of <code>binascii.hexlify</code> returning a <code>str</code>.</p>\n<h2>Function <code>htmlify(s, nbsp=False)</code></h2>\n<p>Convert a string for safe transcription in HTML.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>s</code>: the string</li>\n<li><code>nbsp</code>: replaces spaces with <code>\"&amp;nbsp;\"</code> to prevent word folding,\ndefault <code>False</code>.</li>\n</ul>\n<h2>Function <code>htmlquote(s)</code></h2>\n<p>Quote a string for use in HTML.</p>\n<h2>Function <code>is_dotted_identifier(s, offset=0, **kw)</code></h2>\n<p>Test if the string <code>s</code> is an identifier from position <code>offset</code> onward.</p>\n<h2>Function <code>is_identifier(s, offset=0, **kw)</code></h2>\n<p>Test if the string <code>s</code> is an identifier from position <code>offset</code> onward.</p>\n<h2>Function <code>isUC_(s)</code></h2>\n<p>Check that a string matches <code>^[A-Z][A-Z_0-9]*$</code>.</p>\n<h2>Function <code>jsquote(s)</code></h2>\n<p>Quote a string for use in JavaScript.</p>\n<h2>Function <code>lastlinelen(s)</code></h2>\n<p>The length of text after the last newline in a string.</p>\n<p>(Initially used by cs.hier to compute effective text width.)</p>\n<h2>Function <code>lc_(value)</code></h2>\n<p>Return <code>value.lower()</code>\nwith <code>'-'</code> translated into <code>'_'</code> and <code>' '</code> translated into <code>'-'</code>.</p>\n<p>I use this to construct lowercase filenames containing a\nreadable transcription of a title string.</p>\n<p>See also <code>titleify_lc()</code>, an imperfect reversal of this.</p>\n<h2>Function <code>match_tokens(s, offset, getters)</code></h2>\n<p>Wrapper for get_tokens which catches ValueError exceptions\nand returns (None, offset).</p>\n<h2>Function <code>parseUC_sAttr(attr)</code></h2>\n<p>Take an attribute name and return <code>(key, is_plural)</code>.</p>\n<p><code>'FOO'</code> returns <code>(</code>FOO<code>, False)</code>.\n<code>'FOOs'</code> or <code>'FOOes'</code> returns <code>('FOO', True)</code>.\nOtherwise return <code>(None, False)</code>.</p>\n<h2>Function <code>phpquote(s)</code></h2>\n<p>Quote a string for use in PHP code.</p>\n<h2>Function <code>skipwhite(s, offset=0)</code></h2>\n<p>Convenience routine for skipping past whitespace;\nreturns the offset of the next nonwhitespace character.</p>\n<h2>Function <code>slosh_mapper(c, charmap=None)</code></h2>\n<p>Return a string to replace backslash-<code>c</code>, or <code>None</code>.</p>\n<h2>Function <code>stripped_dedent(s)</code></h2>\n<p>Slightly smarter dedent which ignores a string's opening indent.</p>\n<p>Algorithm:\nstrip the supplied string <code>s</code>, pull off the leading line,\ndedent the rest, put back the leading line.</p>\n<p>This supports my preferred docstring layout, where the opening\nline of text is on the same line as the opening quote.</p>\n<p>Example:</p>\n<pre><code>&gt;&gt;&gt; def func(s):\n...   \"\"\" Slightly smarter dedent which ignores a string's opening indent.\n...       Strip the supplied string `s`. Pull off the leading line.\n...       Dedent the rest. Put back the leading line.\n...   \"\"\"\n...   pass\n...\n&gt;&gt;&gt; from cs.lex import stripped_dedent\n&gt;&gt;&gt; print(stripped_dedent(func.__doc__))\nSlightly smarter dedent which ignores a string's opening indent.\nStrip the supplied string `s`. Pull off the leading line.\nDedent the rest. Put back the leading line.\n</code></pre>\n<h2>Function <code>strlist(ary, sep=', ')</code></h2>\n<p>Convert an iterable to strings and join with \", \".</p>\n<h2>Function <code>tabpadding(padlen, tabsize=8, offset=0)</code></h2>\n<p>Compute some spaces to use a tab padding at an offfset.</p>\n<h2>Function <code>texthexify(bs, shiftin='[', shiftout=']', whitelist=None)</code></h2>\n<p>Transcribe the bytes <code>bs</code> to text using compact text runs for\nsome common text values.</p>\n<p>This can be reversed with the <code>untexthexify</code> function.</p>\n<p>This is an ad doc format devised to be compact but also to\nexpose \"text\" embedded within to the eye. The original use\ncase was transcribing a binary directory entry format, where\nthe filename parts would be somewhat visible in the transcription.</p>\n<p>The output is a string of hexadecimal digits for the encoded\nbytes except for runs of values from the whitelist, which are\nenclosed in the shiftin and shiftout markers and transcribed\nas is. The default whitelist is values of the ASCII letters,\nthe decimal digits and the punctuation characters '_-+.,'.\nThe default shiftin and shiftout markers are '[' and ']'.</p>\n<p>String objects converted with either <code>hexify</code> and <code>texthexify</code>\noutput strings may be freely concatenated and decoded with\n<code>untexthexify</code>.</p>\n<p>Example:</p>\n<pre><code>&gt;&gt;&gt; texthexify(b'&amp;^%&amp;^%abcdefghi)(*)(*')\n'265e25265e25[abcdefghi]29282a29282a'\n</code></pre>\n<p>Parameters:</p>\n<ul>\n<li><code>bs</code>: the bytes to transcribe</li>\n<li><code>shiftin</code>: Optional. The marker string used to indicate a shift to\ndirect textual transcription of the bytes, default: <code>'['</code>.</li>\n<li><code>shiftout</code>: Optional. The marker string used to indicate a\nshift from text mode back into hexadecimal transcription,\ndefault <code>']'</code>.</li>\n<li><code>whitelist</code>: an optional bytes or string object indicating byte\nvalues which may be represented directly in text;\nthe default value is the ASCII letters, the decimal digits\nand the punctuation characters <code>'_-+.,'</code>.</li>\n</ul>\n<h2>Function <code>titleify_lc(value_lc)</code></h2>\n<p>Translate <code>'-'</code> into <code>' '</code> and <code>'_'</code> translated into <code>'-'</code>,\nthen titlecased.</p>\n<p>See also <code>lc_()</code>, which this reverses imperfectly.</p>\n<h2>Function <code>unctrl(s, tabsize=8)</code></h2>\n<p>Return the string <code>s</code> with TABs expanded and control characters\nreplaced with printable representations.</p>\n<h2>Function <code>untexthexify(s, shiftin='[', shiftout=']')</code></h2>\n<p>Decode a textual representation of binary data into binary data.</p>\n<p>This is the reverse of the <code>texthexify</code> function.</p>\n<p>Outside of the <code>shiftin</code>/<code>shiftout</code> markers the binary data\nare represented as hexadecimal. Within the markers the bytes\nhave the values of the ordinals of the characters.</p>\n<p>Example:</p>\n<pre><code>&gt;&gt;&gt; untexthexify('265e25265e25[abcdefghi]29282a29282a')\nb'&amp;^%&amp;^%abcdefghi)(*)(*'\n</code></pre>\n<p>Parameters:</p>\n<ul>\n<li><code>s</code>: the string containing the text representation.</li>\n<li><code>shiftin</code>: Optional. The marker string commencing a sequence\nof direct text transcription, default <code>'['</code>.</li>\n<li><code>shiftout</code>: Optional. The marker string ending a sequence\nof direct text transcription, default <code>']'</code>.</li>\n</ul>\n<h1>Release Log</h1>\n<p><em>Release 20200318</em>:\nNew lc_() function to lowercase and dash a string, new titleify_lc() to mostly reverse lc_().\nNew format_as function, FormatableMixin and related FormatAsError.</p>\n<p><em>Release 20200229</em>:\nNew cutprefix and cutsuffix functions.</p>\n<p><em>Release 20190812</em>:\nFix bad slosh escapes in strings.</p>\n<p><em>Release 20190220</em>:\nNew function get_qstr_or_identifier.</p>\n<p><em>Release 20181108</em>:\nnew function get_decimal_or_float_value to read a decimal or basic float</p>\n<p><em>Release 20180815</em>:\nNo semantic changes; update some docstrings and clean some lint, fix a unit test.</p>\n<p><em>Release 20180810</em>:\nNew get_decimal_value and get_hexadecimal_value functions.\nNew stripped_dedent function, a slightly smarter textwrap.dedent.</p>\n<p><em>Release 20171231</em>:\nNew function get_decimal. Drop unused function dict2js.</p>\n<p><em>Release 20170904</em>:\nPython 2/3 ports, move rfc2047 into new cs.rfc2047 module.</p>\n<p><em>Release 20160828</em>:\nUse \"install_requires\" instead of \"requires\" in DISTINFO.\nDiscard str1(), pointless optimisation.\nunrfc2047: map _ to SPACE, improve exception handling.\nAdd phpquote: quote a string for use in PHP code; add docstring to jsquote.\nAdd is_identifier test.\nAdd get_dotted_identifier.\nAdd is_dotted_identifier.\nAdd get_hexadecimal.\nAdd skipwhite, convenince wrapper for get_white returning just the next offset.\nAssorted bugfixes and improvements.</p>\n<p><em>Release 20150120</em>:\ncs.lex: texthexify: backport to python 2 using cs.py3 bytes type</p>\n<p><em>Release 20150118</em>:\nmetadata updates</p>\n<p><em>Release 20150116</em>:\nPyPI metadata and slight code cleanup.</p>\n\n          </div>"}, "last_serial": 6831512, "releases": {"20150118": [{"comment_text": "", "digests": {"md5": "532ce38899726a27d8c0910f751e5e08", "sha256": "fbd1f673a03a36361e0b126241b9e12c18e79d844b6a64ae248d2b2986932500"}, "downloads": -1, "filename": "cs.lex-20150118.tar.gz", "has_sig": false, "md5_digest": "532ce38899726a27d8c0910f751e5e08", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8005, "upload_time": "2015-01-18T05:58:10", "upload_time_iso_8601": "2015-01-18T05:58:10.727397Z", "url": "https://files.pythonhosted.org/packages/8d/3f/519781144aa6b9b603696365283c7c240458f4e3286013cf9bcc6c00ef00/cs.lex-20150118.tar.gz", "yanked": false}], "20150120": [{"comment_text": "", "digests": {"md5": "b8ed5aede3eb8b527acd72417413ef31", "sha256": "84efcc0725cf99fe953148c49c7d0e8c7e283c244f0ea039f6decfac54c98235"}, "downloads": -1, "filename": "cs.lex-20150120.tar.gz", "has_sig": false, "md5_digest": "b8ed5aede3eb8b527acd72417413ef31", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8142, "upload_time": "2015-01-19T23:36:47", "upload_time_iso_8601": "2015-01-19T23:36:47.635773Z", "url": "https://files.pythonhosted.org/packages/b2/5f/83512d8dcd5e5d92bca9a048f2749863fa0f3f2964b4e0c18de761b72f47/cs.lex-20150120.tar.gz", "yanked": false}], "20160828": [{"comment_text": "", "digests": {"md5": "b22839b534cc0deb9d98dd9cef5b2166", "sha256": "b93062cb06598d82335df57268fc27ca49420f07f87c04a3a58019170d6d5a48"}, "downloads": -1, "filename": "cs.lex-20160828.tar.gz", "has_sig": false, "md5_digest": "b22839b534cc0deb9d98dd9cef5b2166", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8951, "upload_time": "2016-08-28T06:07:18", "upload_time_iso_8601": "2016-08-28T06:07:18.786265Z", "url": "https://files.pythonhosted.org/packages/b7/a5/1ddfcf4304d3f40897bce3701053b8521b85d82dc4dfe815321672f184ef/cs.lex-20160828.tar.gz", "yanked": false}], "20170904": [{"comment_text": "", "digests": {"md5": "4d318811bdb1f9a761491a75d029b547", "sha256": "3987b53546cfbab46c188bf8b83fa70b4fa311e1fd8256714e636abacd2254a2"}, "downloads": -1, "filename": "cs.lex-20170904.tar.gz", "has_sig": false, "md5_digest": "4d318811bdb1f9a761491a75d029b547", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8278, "upload_time": "2017-09-04T01:07:12", "upload_time_iso_8601": "2017-09-04T01:07:12.279233Z", "url": "https://files.pythonhosted.org/packages/c5/7c/a952ec94ddaf052b22f4fb2e274c60716cfe6e3727c966f5ee0affc37f1c/cs.lex-20170904.tar.gz", "yanked": false}], "20171231": [{"comment_text": "", "digests": {"md5": "8f4e597627284b45f8ce8fbb3d6c9201", "sha256": "1d8a58aa5f6d1e799d63264554f3bb5831149957d42ae9dc58c586dcf557a0f3"}, "downloads": -1, "filename": "cs.lex-20171231.tar.gz", "has_sig": false, "md5_digest": "8f4e597627284b45f8ce8fbb3d6c9201", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8330, "upload_time": "2017-12-30T22:35:53", "upload_time_iso_8601": "2017-12-30T22:35:53.664497Z", "url": "https://files.pythonhosted.org/packages/20/2f/934c98939143a6e6d0068366ea3940508640e0253616c1a107c05aeff372/cs.lex-20171231.tar.gz", "yanked": false}], "20180810": [{"comment_text": "", "digests": {"md5": "2011039a6649e7c2d22fdf48bba793ea", "sha256": "5feb4b40ec82987c02b6d4543885f5c0d9d26cb5e37e9327879c8c152c0386cb"}, "downloads": -1, "filename": "cs.lex-20180810.tar.gz", "has_sig": false, "md5_digest": "2011039a6649e7c2d22fdf48bba793ea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9679, "upload_time": "2018-08-10T01:53:27", "upload_time_iso_8601": "2018-08-10T01:53:27.224906Z", "url": "https://files.pythonhosted.org/packages/a6/d0/b46b824f86b6e962807711b9afb4fe37dfc9c317d8eb6d3648ff82de89a4/cs.lex-20180810.tar.gz", "yanked": false}], "20180815": [{"comment_text": "", "digests": {"md5": "4d86ff4feda881ba78be5cdecd47828d", "sha256": "5c9e12dc09218525e0a9ade114095194b61f3e5b063a120f7b05b8d51818955c"}, "downloads": -1, "filename": "cs.lex-20180815.tar.gz", "has_sig": false, "md5_digest": "4d86ff4feda881ba78be5cdecd47828d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12030, "upload_time": "2018-08-14T22:52:33", "upload_time_iso_8601": "2018-08-14T22:52:33.113512Z", "url": "https://files.pythonhosted.org/packages/8d/dc/f72474b72057d77fc496ceac38af10f06f8cb2302d7662a871b541ed0e40/cs.lex-20180815.tar.gz", "yanked": false}], "20181108": [{"comment_text": "", "digests": {"md5": "761c5f7e4d207a2e504eb5b44bda5bb5", "sha256": "d9be4e36e2dad5ed15781e8e731869bc1b479b36cec89aea7efc677efb12b095"}, "downloads": -1, "filename": "cs.lex-20181108.tar.gz", "has_sig": false, "md5_digest": "761c5f7e4d207a2e504eb5b44bda5bb5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12207, "upload_time": "2018-11-07T22:03:08", "upload_time_iso_8601": "2018-11-07T22:03:08.782242Z", "url": "https://files.pythonhosted.org/packages/a0/ab/e4808898e4027fcb3e7850164133a66fad3c11322e70ed08bd8e741231ea/cs.lex-20181108.tar.gz", "yanked": false}], "20190220": [{"comment_text": "", "digests": {"md5": "7f00d2dd1eebeac175345b3af6eac019", "sha256": "4f0d8c4d4f6f24c5aa68f2bd99c61990f7dbd05b66067acaaacaef97c54fe9cd"}, "downloads": -1, "filename": "cs.lex-20190220.tar.gz", "has_sig": false, "md5_digest": "7f00d2dd1eebeac175345b3af6eac019", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12271, "upload_time": "2019-02-20T09:19:47", "upload_time_iso_8601": "2019-02-20T09:19:47.232291Z", "url": "https://files.pythonhosted.org/packages/5a/4d/e9a6bbfb07d39c57eb1cc37568572aab322def4b6c3e2669f462ed80ae36/cs.lex-20190220.tar.gz", "yanked": false}], "20190812": [{"comment_text": "", "digests": {"md5": "1f23977a7c4bab25f775d4b14802f9c2", "sha256": "d37baf562a84fb3e65ac1d81b9701ce8fddc12b1aabc8d69b012859ea8d81811"}, "downloads": -1, "filename": "cs.lex-20190812.tar.gz", "has_sig": false, "md5_digest": "1f23977a7c4bab25f775d4b14802f9c2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16395, "upload_time": "2019-08-11T23:36:04", "upload_time_iso_8601": "2019-08-11T23:36:04.880279Z", "url": "https://files.pythonhosted.org/packages/bd/1d/1b62da36c3dc21a2f6d3ddf4f6622e0e23c76a35a47cccfbc51657f4b486/cs.lex-20190812.tar.gz", "yanked": false}], "20200229": [{"comment_text": "", "digests": {"md5": "b00b46edff80b98e5ceda7817e3aa7b8", "sha256": "04141821e1d42db50e7c2e9e980cd8b259cb687d267f69b06245415b71291ab4"}, "downloads": -1, "filename": "cs.lex-20200229.tar.gz", "has_sig": false, "md5_digest": "b00b46edff80b98e5ceda7817e3aa7b8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18076, "upload_time": "2020-02-29T06:26:23", "upload_time_iso_8601": "2020-02-29T06:26:23.606784Z", "url": "https://files.pythonhosted.org/packages/df/14/fa121b02da078f0d3cd852e3b998f3ca715f512f3e75bc89ad5f21737891/cs.lex-20200229.tar.gz", "yanked": false}], "20200318": [{"comment_text": "", "digests": {"md5": "d5278a7525192be2a2ac74d594314ee9", "sha256": "6b09bc36b27ce800f76db4f8e3d93dd3358ece2349c5d080722be2f7b920a073"}, "downloads": -1, "filename": "cs.lex-20200318.tar.gz", "has_sig": false, "md5_digest": "d5278a7525192be2a2ac74d594314ee9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22313, "upload_time": "2020-03-17T20:58:53", "upload_time_iso_8601": "2020-03-17T20:58:53.756475Z", "url": "https://files.pythonhosted.org/packages/e5/6c/d2f0426f0c2a59f2b8859caf40055e1dae7b27aa27a5f5bc81d16d7c3649/cs.lex-20200318.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d5278a7525192be2a2ac74d594314ee9", "sha256": "6b09bc36b27ce800f76db4f8e3d93dd3358ece2349c5d080722be2f7b920a073"}, "downloads": -1, "filename": "cs.lex-20200318.tar.gz", "has_sig": false, "md5_digest": "d5278a7525192be2a2ac74d594314ee9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22313, "upload_time": "2020-03-17T20:58:53", "upload_time_iso_8601": "2020-03-17T20:58:53.756475Z", "url": "https://files.pythonhosted.org/packages/e5/6c/d2f0426f0c2a59f2b8859caf40055e1dae7b27aa27a5f5bc81d16d7c3649/cs.lex-20200318.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:41:48 2020"}