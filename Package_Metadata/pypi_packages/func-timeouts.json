{"info": {"author": "Brian Houle", "author_email": "grimzecho@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: GNU Lesser General Public License v2 (LGPLv2)", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "func\\_timeout\n=============\n\nPython module to support running any existing function with a given timeout.\n\n\nFunction Timeout\n================\n\n\nfunc\\_timeout\n-------------\n\nThis is the function wherein you pass the timeout, the function you want to call, and any arguments, and it runs it for up to #timeout# seconds, and will return/raise anything the passed function would otherwise return or raise.\n\n\tdef func\\_timeout(timeout, func, args=(), kwargs=None):\n\n\t\t'''\n\n\t\t\tfunc\\_timeout \\- Runs the given function for up to #timeout# seconds.\n\n\t\t\tRaises any exceptions #func# would raise, returns what #func# would return (unless timeout is exceeded), in which case it raises FunctionTimedOut\n\n\t\t\t@param timeout <float> \\- Maximum number of seconds to run #func# before terminating\n\n\t\t\t@param func <function> \\- The function to call\n\n\t\t\t@param args    <tuple> \\- Any ordered arguments to pass to the function\n\n\t\t\t@param kwargs  <dict/None> \\- Keyword arguments to pass to the function.\n\n\t\t\t@raises \\- FunctionTimedOut if #timeout# is exceeded, otherwise anything #func# could raise will be raised\n\n\t\t\t@return \\- The return value that #func# gives\n\n\t\t'''\n\n\n**Example**\n\n\nSo, for esxample, if you have a function \"doit('arg1', 'arg2')\" that you want to limit to running for 5 seconds, with func\\_timeout you can call it like this:\n\n\n\tfrom func\\_timeout import func\\_timeout, FunctionTimedOut\n\n\t...\n\n\ttry:\n\n\t\tdoitReturnValue = func\\_timeout(5, doit, args=('arg1', 'arg2'))\n\n\texcept FunctionTimedOut:\n\n\t\tprint ( \"doit('arg1', 'arg2') could not complete within 5 seconds and was terminated.\\\\n\")\n\n\texcept Exception as e:\n\n\t\t# Handle any exceptions that doit might raise here\n\n\n\nfunc\\_set\\_timeout\n------------------\n\n\nThis is a decorator you can use on functions to apply func\\_timeout.\n\nTakes two arguments, \"timeout\" and \"allowOverride\"\n\nIf \"allowOverride\" is present, an optional keyword argument is added to the wrapped function, 'forceTimeout'. When provided, this will override the timeout used on this function.\n\n\nThe \"timeout\" parameter can be either a number (for a fixed timeout), or a function/lambda. If a function/lambda is used, it will be passed the same arguments as the called function was passed. It should return a number which will be used as the timeout for that paticular run. For example, if you have a method that calculates data, you'll want a higher timeout for 1 million records than 50 records.\n\n\n**Example:**\n\n\t@func\\_set\\_timeout(2.5)\n\n\tdef myFunction(self, arg1, arg2):\n\n\t\t...\n\nfunc timeout\n------------------\nThis is another decorator you can use that will apply func\\_timeout.\nThe decorator takes no parameters, but instead expects that the wrapped function will be called with an additional `timeout=` parameter. If no such parameter is passed to the decorated function, then it is invoked as if the decorator wasn't present.\n\n**Example**\n\n | @func\\_set\\_timeout(2.5)\n | def foo(arg1, arg2):\n |   #...\n |   pass\n |\n | try:\n |     result = foo(arg1, arg2, timeout=3)\n | except FunctionTimedOut:\n |     return None\n\n\n\n\n\n\n\n\nFunctionTimedOut\n----------------\n\nException raised if the function times out.\n\n\nHas a \"retry\" method which takes the following arguments:\n\n\t\\* No argument \\- Retry same args, same function, same timeout\n\n\t\\* Number argument \\- Retry same args, same function, provided timeout\n\n\t\\* None \\- Retry same args, same function, no timeout\n\n\nHow it works\n------------\n\nfunc\\_timeout will run the specified function in a thread with the specified arguments until it returns, raises an exception, or the timeout is exceeded.\n\nIf there is a return or an exception raised, it will be returned/raised as normal.\n\nIf the timeout has exceeded, the \"FunctionTimedOut\" exception will be raised in the context of the function being called, as well as from the context of \"func\\_timeout\". You should have your function catch the \"FunctionTimedOut\" exception and exit cleanly if possible. Every 2 seconds until your function is terminated, it will continue to raise FunctionTimedOut. The terminating of the timed-out function happens in the context of the thread and will not block main execution.\n\n\nStoppableThread\n===============\n\nStoppableThread is a subclass of threading.Thread, which supports stopping the thread (supports both python2 and python3). It will work to stop even in C code.\n\nThe way it works is that you pass it an exception, and it raises it via the cpython api (So the next time a \"python\" function is called from C api, or the next line is processed in python code, the exception is raised).\n\n\nUsing StoppableThread\n---------------------\n\nYou can use StoppableThread one of two ways:\n\n**As a Parent Class**\n\n\nYour thread can extend func\\_timeout.StoppableThread\\.StoppableThread and implement the \"run\" method, same as a normal thread.\n\n\n\tfrom func\\_timeout.StoppableThread import StoppableThread\n\n\tclass MyThread(StoppableThread):\n\n\t\tdef run(self):\n\t\t\t\n\t\t\t# Code here\n\n\t\t\treturn\n\n\nThen, you can create and start this thread like:\n\n\tmyThread = MyThread()\n\n\t# Uncomment next line to start thread in \"daemon mode\" \\-\\- i.e. will terminate/join automatically upon main thread exit\n\n\t#myThread.daemon = True\n\n\tmyThread.start()\n\n\nThen, at any time during the thread's execution, you can call \\.stop( StopExceptionType ) to stop it ( more in \"Stopping a Thread\" below\n\n**Direct Thread To Execute A Function**\n\nAlternatively, you can instantiate StoppableThread directly and pass the \"target\", \"args\", and \"kwargs\" arguments to the constructor\n\n\tmyThread = StoppableThread( target=myFunction, args=('ordered', 'args', 'here'), kwargs={ 'keyword args' : 'here' } )\n\n\t# Uncomment next line to start thread in \"daemon mode\" \\-\\- i.e. will terminate/join automatically upon main thread exit\n\n\t#myThread.daemon = True\n\n\tmyThread.start()\n\n\nThis will allow you to call functions in stoppable threads, for example handlers in an event loop, which can be stopped later via the \\.stop() method.\n\n\nStopping a Thread\n-----------------\n\n\nThe *StoppableThread* class (you must extend this for your thread) adds a function, *stop*, which can be called to stop the thread.\n\n\n\tdef stop(self, exception, raiseEvery=2.0):\n\n\t\t'''\n\n\t\t\tStops the thread by raising a given exception.\n\n\t\t\t@param exception <Exception type> \\- Exception to throw. Likely, you want to use something\n\n\t\t\t  that inherits from BaseException (so except Exception as e: continue; isn't a problem)\n\n\t\t\t  This should be a class/type, NOT an instance, i.e.  MyExceptionType   not  MyExceptionType()\n\n\n\t\t\t@param raiseEvery <float> Default 2.0 \\- We will keep raising this exception every #raiseEvery seconds,\n\n\t\t\t\tuntil the thread terminates.\n\n\t\t\t\tIf your code traps a specific exception type, this will allow you #raiseEvery seconds to cleanup before exit.\n\n\t\t\t\tIf you're calling third\\-party code you can't control, which catches BaseException, set this to a low number\n\t\t\t\t \n\t\t\t\t  to break out of their exception handler.\n\n\n\t\t\t @return <None>\n\n\t\t'''\n\n\nThe \"exception\" param must be a type, and it must be instantiable with no arguments (i.e. MyExceptionType() must create the object).\n\nConsider using a custom exception type which extends BaseException, which you can then use to do basic cleanup ( flush any open files, etc. ).\n\nThe exception type you pass will be raised every #raiseEvery seconds in the context of that stoppable thread. You can tweak this value to give yourself more time for cleanups, or you can shrink it down to break out of empty exception handlers  ( try/except with bare except ).\n\n\n**Notes on Exception Type**\n\nIt is recommended that you create an exception that extends BaseException instead of Exception, otherwise code like this will never stop:\n\n\twhile True:\n\n\t\ttry:\n\n\t\t\tdoSomething()\n\n\t\texcept Exception as e:\n\n\t\t\tcontinue\n\nIf you can't avoid such code (third-party lib?) you can set the \"repeatEvery\" to a very very low number (like .00001 ), so hopefully it will raise, go to the except clause, and then raise again before \"continue\" is hit.\n\n\n\nYou may want to consider using singleton types with fixed error messages, so that tracebacks, etc. log that the call timed out.\n\nFor example:\n\n\tclass ServerShutdownExceptionType(BaseException):\n\n\t\tdef \\_\\_init\\_\\_(self, \\*args, \\*\\*kwargs):\n\n\t\t\tBaseException.\\_\\_init\\_\\_(self, 'Server is shutting down')\n\n\nThis will force 'Server is shutting down' as the message held by this exception.\n\n\n\nPydoc\n=====\n\nFind the latest pydoc at http://htmlpreview.github.io/?https://github.com/kata198/func_timeout/blob/master/doc/func_timeout.html?vers=4.3.3 .\n\n\nSupport\n=======\n\nI've tested func\\_timeout with python 2.7, 3.4, 3.5, 3.6, 3.7. It should work on other versions as well.\n\nWorks on windows, linux/unix, cygwin, mac\n\nChangeLog can be found at https://raw.githubusercontent.com/kata198/func_timeout/master/ChangeLog \n\nPydoc can be found at: http://htmlpreview.github.io/?https://github.com/kata198/func_timeout/blob/master/doc/func_timeout.html?vers=1", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/BrianHVB/func_timeouts.git", "keywords": "timeout", "license": "LGPLv2", "maintainer": "Brian Houle", "maintainer_email": "grimzecho@gmail.com", "name": "func-timeouts", "package_url": "https://pypi.org/project/func-timeouts/", "platform": "", "project_url": "https://pypi.org/project/func-timeouts/", "project_urls": {"Homepage": "https://github.com/BrianHVB/func_timeouts.git"}, "release_url": "https://pypi.org/project/func-timeouts/1.0.2/", "requires_dist": null, "requires_python": "", "summary": "Fork of [func_timeout]. Fixes some Exception issues and creates a new decorator for when you always want to specify a timeout value.", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"func-timeout\">\n<h2>func_timeout</h2>\n<p>Python module to support running any existing function with a given timeout.</p>\n</div>\n<div id=\"function-timeout\">\n<h2>Function Timeout</h2>\n<div id=\"id1\">\n<h3>func_timeout</h3>\n<p>This is the function wherein you pass the timeout, the function you want to call, and any arguments, and it runs it for up to #timeout# seconds, and will return/raise anything the passed function would otherwise return or raise.</p>\n<blockquote>\n<p>def func_timeout(timeout, func, args=(), kwargs=None):</p>\n<blockquote>\n<p>\u2018\u2019\u2019</p>\n<blockquote>\n<p>func_timeout - Runs the given function for up to #timeout# seconds.</p>\n<p>Raises any exceptions #func# would raise, returns what #func# would return (unless timeout is exceeded), in which case it raises FunctionTimedOut</p>\n<p>@param timeout &lt;float&gt; - Maximum number of seconds to run #func# before terminating</p>\n<p>@param func &lt;function&gt; - The function to call</p>\n<p>@param args    &lt;tuple&gt; - Any ordered arguments to pass to the function</p>\n<p>@param kwargs  &lt;dict/None&gt; - Keyword arguments to pass to the function.</p>\n<p>@raises - FunctionTimedOut if #timeout# is exceeded, otherwise anything #func# could raise will be raised</p>\n<p>@return - The return value that #func# gives</p>\n</blockquote>\n<p>\u2018\u2019\u2019</p>\n</blockquote>\n</blockquote>\n<p><strong>Example</strong></p>\n<p>So, for esxample, if you have a function \u201cdoit(\u2018arg1\u2019, \u2018arg2\u2019)\u201d that you want to limit to running for 5 seconds, with func_timeout you can call it like this:</p>\n<blockquote>\n<p>from func_timeout import func_timeout, FunctionTimedOut</p>\n<p>\u2026</p>\n<p>try:</p>\n<blockquote>\ndoitReturnValue = func_timeout(5, doit, args=(\u2018arg1\u2019, \u2018arg2\u2019))</blockquote>\n<p>except FunctionTimedOut:</p>\n<blockquote>\nprint ( \u201cdoit(\u2018arg1\u2019, \u2018arg2\u2019) could not complete within 5 seconds and was terminated.\\n\u201d)</blockquote>\n<p>except Exception as e:</p>\n<blockquote>\n# Handle any exceptions that doit might raise here</blockquote>\n</blockquote>\n</div>\n<div id=\"func-set-timeout\">\n<h3>func_set_timeout</h3>\n<p>This is a decorator you can use on functions to apply func_timeout.</p>\n<p>Takes two arguments, \u201ctimeout\u201d and \u201callowOverride\u201d</p>\n<p>If \u201callowOverride\u201d is present, an optional keyword argument is added to the wrapped function, \u2018forceTimeout\u2019. When provided, this will override the timeout used on this function.</p>\n<p>The \u201ctimeout\u201d parameter can be either a number (for a fixed timeout), or a function/lambda. If a function/lambda is used, it will be passed the same arguments as the called function was passed. It should return a number which will be used as the timeout for that paticular run. For example, if you have a method that calculates data, you\u2019ll want a higher timeout for 1 million records than 50 records.</p>\n<p><strong>Example:</strong></p>\n<blockquote>\n<p>@func_set_timeout(2.5)</p>\n<p>def myFunction(self, arg1, arg2):</p>\n<blockquote>\n\u2026</blockquote>\n</blockquote>\n</div>\n<div id=\"id2\">\n<h3>func timeout</h3>\n<p>This is another decorator you can use that will apply func_timeout.\nThe decorator takes no parameters, but instead expects that the wrapped function will be called with an additional <cite>timeout=</cite> parameter. If no such parameter is passed to the decorated function, then it is invoked as if the decorator wasn\u2019t present.</p>\n<p><strong>Example</strong></p>\n<blockquote>\n<div>\n<div>@func_set_timeout(2.5)</div>\n<div>def foo(arg1, arg2):</div>\n<div>\n<div>#\u2026</div>\n<div>pass</div>\n<div><br></div>\n</div>\n<div>try:</div>\n<div>\n<div>result = foo(arg1, arg2, timeout=3)</div>\n</div>\n<div>except FunctionTimedOut:</div>\n<div>\n<div>return None</div>\n</div>\n</div>\n</blockquote>\n</div>\n<div id=\"functiontimedout\">\n<h3>FunctionTimedOut</h3>\n<p>Exception raised if the function times out.</p>\n<p>Has a \u201cretry\u201d method which takes the following arguments:</p>\n<blockquote>\n<p>* No argument - Retry same args, same function, same timeout</p>\n<p>* Number argument - Retry same args, same function, provided timeout</p>\n<p>* None - Retry same args, same function, no timeout</p>\n</blockquote>\n</div>\n<div id=\"how-it-works\">\n<h3>How it works</h3>\n<p>func_timeout will run the specified function in a thread with the specified arguments until it returns, raises an exception, or the timeout is exceeded.</p>\n<p>If there is a return or an exception raised, it will be returned/raised as normal.</p>\n<p>If the timeout has exceeded, the \u201cFunctionTimedOut\u201d exception will be raised in the context of the function being called, as well as from the context of \u201cfunc_timeout\u201d. You should have your function catch the \u201cFunctionTimedOut\u201d exception and exit cleanly if possible. Every 2 seconds until your function is terminated, it will continue to raise FunctionTimedOut. The terminating of the timed-out function happens in the context of the thread and will not block main execution.</p>\n</div>\n</div>\n<div id=\"stoppablethread\">\n<h2>StoppableThread</h2>\n<p>StoppableThread is a subclass of threading.Thread, which supports stopping the thread (supports both python2 and python3). It will work to stop even in C code.</p>\n<p>The way it works is that you pass it an exception, and it raises it via the cpython api (So the next time a \u201cpython\u201d function is called from C api, or the next line is processed in python code, the exception is raised).</p>\n<div id=\"using-stoppablethread\">\n<h3>Using StoppableThread</h3>\n<p>You can use StoppableThread one of two ways:</p>\n<p><strong>As a Parent Class</strong></p>\n<p>Your thread can extend func_timeout.StoppableThread.StoppableThread and implement the \u201crun\u201d method, same as a normal thread.</p>\n<blockquote>\n<p>from func_timeout.StoppableThread import StoppableThread</p>\n<p>class MyThread(StoppableThread):</p>\n<blockquote>\n<p>def run(self):</p>\n<blockquote>\n<p># Code here</p>\n<p>return</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>Then, you can create and start this thread like:</p>\n<blockquote>\n<p>myThread = MyThread()</p>\n<p># Uncomment next line to start thread in \u201cdaemon mode\u201d \u2013 i.e. will terminate/join automatically upon main thread exit</p>\n<p>#myThread.daemon = True</p>\n<p>myThread.start()</p>\n</blockquote>\n<p>Then, at any time during the thread\u2019s execution, you can call .stop( StopExceptionType ) to stop it ( more in \u201cStopping a Thread\u201d below</p>\n<p><strong>Direct Thread To Execute A Function</strong></p>\n<p>Alternatively, you can instantiate StoppableThread directly and pass the \u201ctarget\u201d, \u201cargs\u201d, and \u201ckwargs\u201d arguments to the constructor</p>\n<blockquote>\n<p>myThread = StoppableThread( target=myFunction, args=(\u2018ordered\u2019, \u2018args\u2019, \u2018here\u2019), kwargs={ \u2018keyword args\u2019 : \u2018here\u2019 } )</p>\n<p># Uncomment next line to start thread in \u201cdaemon mode\u201d \u2013 i.e. will terminate/join automatically upon main thread exit</p>\n<p>#myThread.daemon = True</p>\n<p>myThread.start()</p>\n</blockquote>\n<p>This will allow you to call functions in stoppable threads, for example handlers in an event loop, which can be stopped later via the .stop() method.</p>\n</div>\n<div id=\"stopping-a-thread\">\n<h3>Stopping a Thread</h3>\n<p>The <em>StoppableThread</em> class (you must extend this for your thread) adds a function, <em>stop</em>, which can be called to stop the thread.</p>\n<blockquote>\n<p>def stop(self, exception, raiseEvery=2.0):</p>\n<blockquote>\n<p>\u2018\u2019\u2019</p>\n<blockquote>\n<p>Stops the thread by raising a given exception.</p>\n<p>@param exception &lt;Exception type&gt; - Exception to throw. Likely, you want to use something</p>\n<blockquote>\n<p>that inherits from BaseException (so except Exception as e: continue; isn\u2019t a problem)</p>\n<p>This should be a class/type, NOT an instance, i.e.  MyExceptionType   not  MyExceptionType()</p>\n</blockquote>\n<p>@param raiseEvery &lt;float&gt; Default 2.0 - We will keep raising this exception every #raiseEvery seconds,</p>\n<blockquote>\n<blockquote>\n<p>until the thread terminates.</p>\n<p>If your code traps a specific exception type, this will allow you #raiseEvery seconds to cleanup before exit.</p>\n<p>If you\u2019re calling third-party code you can\u2019t control, which catches BaseException, set this to a low number</p>\n<blockquote>\nto break out of their exception handler.</blockquote>\n</blockquote>\n<p>@return &lt;None&gt;</p>\n</blockquote>\n</blockquote>\n<p>\u2018\u2019\u2019</p>\n</blockquote>\n</blockquote>\n<p>The \u201cexception\u201d param must be a type, and it must be instantiable with no arguments (i.e. MyExceptionType() must create the object).</p>\n<p>Consider using a custom exception type which extends BaseException, which you can then use to do basic cleanup ( flush any open files, etc. ).</p>\n<p>The exception type you pass will be raised every #raiseEvery seconds in the context of that stoppable thread. You can tweak this value to give yourself more time for cleanups, or you can shrink it down to break out of empty exception handlers  ( try/except with bare except ).</p>\n<p><strong>Notes on Exception Type</strong></p>\n<p>It is recommended that you create an exception that extends BaseException instead of Exception, otherwise code like this will never stop:</p>\n<blockquote>\n<p>while True:</p>\n<blockquote>\n<p>try:</p>\n<blockquote>\ndoSomething()</blockquote>\n<p>except Exception as e:</p>\n<blockquote>\ncontinue</blockquote>\n</blockquote>\n</blockquote>\n<p>If you can\u2019t avoid such code (third-party lib?) you can set the \u201crepeatEvery\u201d to a very very low number (like .00001 ), so hopefully it will raise, go to the except clause, and then raise again before \u201ccontinue\u201d is hit.</p>\n<p>You may want to consider using singleton types with fixed error messages, so that tracebacks, etc. log that the call timed out.</p>\n<p>For example:</p>\n<blockquote>\n<p>class ServerShutdownExceptionType(BaseException):</p>\n<blockquote>\n<p>def __init__(self, *args, **kwargs):</p>\n<blockquote>\nBaseException.__init__(self, \u2018Server is shutting down\u2019)</blockquote>\n</blockquote>\n</blockquote>\n<p>This will force \u2018Server is shutting down\u2019 as the message held by this exception.</p>\n</div>\n</div>\n<div id=\"pydoc\">\n<h2>Pydoc</h2>\n<p>Find the latest pydoc at <a href=\"http://htmlpreview.github.io/?https://github.com/kata198/func_timeout/blob/master/doc/func_timeout.html\" rel=\"nofollow\">http://htmlpreview.github.io/?https://github.com/kata198/func_timeout/blob/master/doc/func_timeout.html</a>?vers=4.3.3 .</p>\n</div>\n<div id=\"support\">\n<h2>Support</h2>\n<p>I\u2019ve tested func_timeout with python 2.7, 3.4, 3.5, 3.6, 3.7. It should work on other versions as well.</p>\n<p>Works on windows, linux/unix, cygwin, mac</p>\n<p>ChangeLog can be found at <a href=\"https://raw.githubusercontent.com/kata198/func_timeout/master/ChangeLog\" rel=\"nofollow\">https://raw.githubusercontent.com/kata198/func_timeout/master/ChangeLog</a></p>\n<p>Pydoc can be found at: <a href=\"http://htmlpreview.github.io/?https://github.com/kata198/func_timeout/blob/master/doc/func_timeout.html\" rel=\"nofollow\">http://htmlpreview.github.io/?https://github.com/kata198/func_timeout/blob/master/doc/func_timeout.html</a>?vers=1</p>\n</div>\n\n          </div>"}, "last_serial": 5567282, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "003d43482e07acb9c0dac88624ce621e", "sha256": "3f8c19005f6a3f72ceffd7d003581b3fa1d4cd51f07543cb5628b16859bb99e7"}, "downloads": -1, "filename": "func_timeouts-1.0.tar.gz", "has_sig": false, "md5_digest": "003d43482e07acb9c0dac88624ce621e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32435, "upload_time": "2019-07-14T19:31:53", "upload_time_iso_8601": "2019-07-14T19:31:53.410788Z", "url": "https://files.pythonhosted.org/packages/8a/ab/0b117cdea76bae9f6144a998c372c45fbbbba2a9bdd9e90a08c6f5e49dd3/func_timeouts-1.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "ceb03c8d12df7e7c08675049e1dbd061", "sha256": "69b038d6467b4fad9a8545be58750cb665f7e9c5f3e363f16668ebc094f8544e"}, "downloads": -1, "filename": "func_timeouts-1.0.1.tar.gz", "has_sig": false, "md5_digest": "ceb03c8d12df7e7c08675049e1dbd061", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32687, "upload_time": "2019-07-14T20:17:53", "upload_time_iso_8601": "2019-07-14T20:17:53.298573Z", "url": "https://files.pythonhosted.org/packages/f6/33/b31ebe19f01b7e1aa6540476d87d1954a78befea47b4606d51798745d588/func_timeouts-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "d5011442058ef482bdc2977eea57ac98", "sha256": "2af342747b09947507db23dadc1715ebbf65be4f337c6b33fb4dd7c7d2f9aec7"}, "downloads": -1, "filename": "func_timeouts-1.0.2.tar.gz", "has_sig": false, "md5_digest": "d5011442058ef482bdc2977eea57ac98", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32877, "upload_time": "2019-07-22T12:52:59", "upload_time_iso_8601": "2019-07-22T12:52:59.767169Z", "url": "https://files.pythonhosted.org/packages/1a/26/bd3ea9fdb8a577cf99283001eb91251bf4cadc02e956d98167bef8f6e953/func_timeouts-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d5011442058ef482bdc2977eea57ac98", "sha256": "2af342747b09947507db23dadc1715ebbf65be4f337c6b33fb4dd7c7d2f9aec7"}, "downloads": -1, "filename": "func_timeouts-1.0.2.tar.gz", "has_sig": false, "md5_digest": "d5011442058ef482bdc2977eea57ac98", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32877, "upload_time": "2019-07-22T12:52:59", "upload_time_iso_8601": "2019-07-22T12:52:59.767169Z", "url": "https://files.pythonhosted.org/packages/1a/26/bd3ea9fdb8a577cf99283001eb91251bf4cadc02e956d98167bef8f6e953/func_timeouts-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:59:42 2020"}