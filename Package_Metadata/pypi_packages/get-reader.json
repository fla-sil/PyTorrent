{"info": {"author": "Shawn Brown", "author_email": "shawnbrown@users.noreply.github.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: Jython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Utilities"], "description": "get-reader\n==========\n\n![devstatus]&#32;[![build-img]][build-url] ![pyversions] ![license]\n\nThis module provides a `get_reader()` function that returns reader\nobjects similar to those returned by `csv.reader()`. This package:\n\n* reduces common boilerplate code for handling files and reading\n  records\n* reads data from CSV, pandas, SQL connections, MS Excel, DBF, and squint\n* provides a single interface across Python versions (including\n  seamless Unicode-aware CSV support for Python 2)\n* is easy to incorporate into your own projects:\n\n  * has no hard dependencies\n  * runs on Python 2.6, 2.7, 3.2 through 3.8, PyPy, PyPy3, and Jython\n  * is freely available under the Apache License, version 2\n  * can be easily vendored directly into your codebase if you don't\n    want to include it as a dependency\n\n\n**Open a UTF-8 encoded CSV:**\n\n```python\nfrom get_reader import get_reader\n\nreader = get_reader('myfile.csv')\n\nfor row in reader:\n    print(', '.join(row))\n```\n\nIn the above example, file handling is managed automatically by the\nreader object. The file is automatically closed when the iterator is\nexhausted or when the object is deleted. It also handles Unicode in\nPython 2 without changes.\n\n\n**Open a Latin-1 (ISO-8859-1) encoded CSV file:**\n\n```python\nreader = get_reader('myfile.csv', encoding='latin-1')\n\nfor row in reader:\n    print(', '.join(row))\n```\n\n\n**Use the reader as a context manager:**\n\n```python\nwith get_reader('myfile.csv') as reader:\n    for row in reader:\n        print(', '.join(row))\n```\n\nIn this example, `reader` automatically closes its internal file object\nwhen exiting the `with` block even if the for-loop doesn't finish\nexhausting the `reader`.\n\n\n**Access other data sources:**\n\n```python\n# From a pandas DataFrame, Series, Index, or MultiIndex.\ndf = pd.DataFrame([...])\nreader = get_reader(df)  # requires pandas\n\n# From a database connection.\nconnection = ...\nreader = get_reader(connection, 'SELECT col1, col2 FROM mytable;')\n\n# From an Excel file--must install with 'excel' option.\nreader = get_reader('myfile.xlsx')\n\n# From a DBF file--must install with 'dbf' option.\nreader = get_reader('myfile.dbf')\n\n# From a squint Select, Query, or Result.\nselect = ...\nreader = get_reader(select({'col1': 'col2'}).sum())\n```\n\n\n**Call constructors directly to override auto-detect behavior:**\n\n```python\n# Specify tab-delimited data from a text file.\nreader = get_reader.from_csv('myfile.dat', delimiter='\\t')\n```\n\n\n## Install\n\nThe `get_reader` module has no hard dependencies; is tested on\nPython 2.6, 2.7, 3.2 through 3.8, PyPy, PyPy3, and Jython; and\nis freely available under the Apache License, version 2.\n\nYou can install `get_reader` using `pip`:\n\n```shell\npip install get_reader\n```\n\nTo install optional support for MS Excel and DBF files (dBase,\nFoxpro, etc.), use the following:\n\n```shell\npip install get_reader[excel,dbf]\n```\n\n**Python 2 Support Statement**\n\nWhile official support for Python 2 ends on January 1, 2020, this\nproject will continue to support older versions as long as the\nexisting ecosystem provides the ability to run automated tests\non those older versions.\n\n\n## Reference\n\n### get\\_reader(*obj*, \\**args*, \\*\\**kwds*)\n\nReturn a `Reader` object which will iterate over records in\nthe given *obj*\u2014like a `csv.reader()`. The given *obj* may\nbe one of the following:\n\n* CSV file (string path or file object)\n* iterable of dictionary rows\n* database connection (should be DBAPI2 compatible)\n* pandas DataFrame, Series, Index, or MultiIndex\n* squint Select, Query, or Result\n\nIf optional extras are installed, *obj* may also be:\n\n* MS Excel file path\n* DBF file path\n\nWhen *obj* is a file path, the `Reader` contains a file object\nthat is handled internally. When given a file-like *obj* (rather\nthan a path), users are responsible for properly closing this\nfile themselves.\n\nThe given *obj* is checked against supported types and\nautomatically passed to the appropriate constructor if a match is\nfound. If *obj* is a string, it is treated as a file path whose\nextension determines its content type. Any \\**args* and \\*\\**kwds*\nare passed along to the matching constructor:\n\n```python\nfrom get_reader import get_reader\n\n# CSV file.\nreader = get_reader('myfile.csv')\n\n# Database connection.\nconnection = ...\nreader = get_reader(connection, 'SELECT col1, col2 FROM mytable;')\n\n# Pandas DataFrame.\ndf = pd.DataFrame([...])\nreader = get_reader(df)\n\n# Excel file.\nreader = get_reader('myfile.xlsx', worksheet='Sheet2')\n```\n\nIf the *obj* type cannot be determined automatically, users can\ncall the constructor methods directly.\n\n\n#### Constructor Methods\n\n**get\\_reader.from\\_csv**(*csvfile*, *encoding*='utf-8', *dialect*='excel', \\*\\**kwds*)\n\nReturn a reader object which will iterate over lines in the\ngiven *csvfile*. The *csvfile* can be a string (treated as a\nfile path) or any object which supports the iterator protocol\nand returns a string each time its `__next__()` method is\ncalled\u2014file objects and list objects are both suitable. If\n*csvfile* is a file object, it should be opened with `newline=''`.\n\n```python\nfrom get_reader import get_reader\n\nreader = get_reader.from_csv('myfile.tab', delimiter='\\t')\n```\n\nUsing explicit file handling:\n\n```python\nfrom get_reader import get_reader\n\nwith open('myfile.csv') as csvfile:\n    reader = get_reader.from_csv(fh)\n```\n\n\n**get\\_reader.from\\_dicts**(*records*, *fieldnames*=None)\n\nReturn a reader object which will iterate over the given\ndictionary *records*. This can be thought of as converting a\n`csv.DictReader()` into a plain, non-dictionary `csv.reader()`.\n\n```python\nfrom get_reader import get_reader\n\ndictrows = [\n    {'A': 1, 'B': 'x'},\n    {'A': 2, 'B': 'y'},\n]\n\nreader = get_reader.from_dicts(dictrows)\n```\n\nThis method assumes that record contents are consistent. If the first\nrecord is a dictionary, it is assumed that all following records will\nbe dictionaries with matching keys.\n\n\n**get\\_reader.from\\_sql**(*connection*, *table\\_or\\_query*)\n\nReturn a reader object which will iterate over the records\nfrom a given database table or over the records returned from\na SQL query. The *connection* should be a DBAPI2 compatible\ndatabase connection and *table\\_or\\_query* must be a string\nwith a table name or a SQL query.\n\nRead records from a specified table:\n\n```python\nfrom get_reader import get_reader\n\nconnection = ...\nreader = get_reader.from_sql(connection, 'mytable')\n```\n\nRead records from the results of a SQL query:\n\n```python\nreader = get_reader.from_sql(connection, 'SELECT col1, col2 FROM mytable;')\n```\n\n\n**get\\_reader.from\\_excel**(*path*, *worksheet*=0)\n\nReturn a reader object which will iterate over lines in the given\nExcel worksheet. The *path* must specify an XLSX or XLS file and\n*worksheet* must specify the index or name of the worksheet to\nload (defaults to the first worksheet).\n\nLoad first worksheet:\n\n```python\nfrom get_reader import get_reader\n\nreader = get_reader.from_excel('mydata.xlsx')\n```\n\nSpecific worksheets can be loaded by name (a string) or index\n(an integer):\n\n```python\nreader = get_reader.from_excel('mydata.xlsx', 'Sheet 2')\n```\n\n\n**get\\_reader.from\\_pandas**(*obj*, *index*=True)\n\nReturn a reader object which will iterate over records in\na pandas `DataFrame`, `Series`, `Index` or `MultiIndex`.\n\n```python\nimport pandas as pd\nfrom get_reader import get_reader\n\ndf = pd.DataFrame(...)\nreader = get_reader.from_pandas(df)\n```\n\n\n**get\\_reader.from\\_dbf**(*filename*, *encoding*=None, \\*\\**kwds*)\n\nReturn a reader object which will iterate over lines in the given\nDBF file (from dBase, FoxPro, etc.).\n\n```python\nfrom get_reader import get_reader\n\nreader = get_reader.from_dbf('myfile.dbf')\n```\n\n\n**get\\_reader.from\\_squint**(*obj*, *fieldnames*=None)\n\nReturn a reader object which will iterate over the records returned\nfrom a squint `Select`, `Query`, or `Result`. If the *fieldnames*\nargument is not provided, this function tries to construct names\nusing the values from the underlying object.\n\n```python\nimport squint\nfrom get_reader import get_reader\n\nselect = squint.Select(...)\nreader = get_reader.from_squint(select)\n```\n\n\n### *class* Reader(*iterable*, *closefunc=\\<no value\\>*)\n\nAn iterator which will produce rows from the given *iterable*. The\ngiven *iterable* should produce non-string sequences. An optional\n*closefunc* may be provided to close associated resources (files,\ndatabase cursors, etc.) once the reader is no longer needed\u2014it will\nbe automatically called when:\n\n* the iterable is exhausted\n* exiting a `with` statement (if used as a context manager)\n* the Reader is garbage collected\n\n\n**Reader.close**()\n\nCloses any associated resources (calls *closefunc* early):\n\n```python\nfrom get_reader import Reader\n\nreader = Reader(..., closefunc=...)\nreader.close()  # <- Explicitly close resources.\n```\n\nIf the resources have already been closed, this method passes\nwithout error.\n\n\n### *class* ReaderLike()\n\nAn abstract class that can be used for type checking. Objects\nwill test as `ReaderLike` if they are one of the following:\n\n* instance of the `Reader` class\n* object returned by `csv.reader()`\n* non-exhaustible iterable that produces non-string sequences\n\nSee the following examples:\n\n\n```python\n>>> isinstance(get_reader(csvfile), ReaderLike)\nTrue\n\n>>> isinstance(csv.reader(csvfile), ReaderLike)\nTrue\n\n>>> list_of_lists = [['col1', 'col2'], ['a', 'b']]\n>>> isinstance(list_of_lists, ReaderLike)\nTrue\n\n>>> list_of_strings = ['col1,col2', 'a,b']\n>>> isinstance(list_of_strings, ReaderLike)\nFalse\n\n>>> list_of_sets = [{'col1', 'col2'}, {'a', 'b'}]\n>>> isinstance(list_of_sets, ReaderLike)\nFalse\n```\n\n------------------------------------\n\nFreely licensed under the Apache License, Version 2.0\n\n(C) Copyright 2018 \u2013 2019 Shawn Brown.\n\n\n[devstatus]: https://img.shields.io/pypi/status/get_reader.svg\n[build-img]: https://api.travis-ci.org/shawnbrown/get_reader.svg?branch=master\n[build-url]: https://travis-ci.org/shawnbrown/get_reader\n[pyversions]: https://img.shields.io/pypi/pyversions/get_reader.svg\n[license]: https://img.shields.io/badge/license-Apache%202-blue.svg\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/shawnbrown/get_reader", "keywords": "", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "get-reader", "package_url": "https://pypi.org/project/get-reader/", "platform": "", "project_url": "https://pypi.org/project/get-reader/", "project_urls": {"Homepage": "https://github.com/shawnbrown/get_reader"}, "release_url": "https://pypi.org/project/get-reader/1.0.0/", "requires_dist": ["dbfread ; extra == 'dbf'", "xlrd ; extra == 'excel'"], "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "summary": "get_reader() returns csv.reader-like objects from multiple sources", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>get-reader</h1>\n<p><img alt=\"devstatus\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9d132773b8fe86b34ee0628a4fdaf4a6d13c88be/68747470733a2f2f696d672e736869656c64732e696f2f707970692f7374617475732f6765745f7265616465722e737667\"> <a href=\"https://travis-ci.org/shawnbrown/get_reader\" rel=\"nofollow\"><img alt=\"build-img\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/95f37a1ae78e62ad99217b9f9e3e9edc4a21a5ff/68747470733a2f2f6170692e7472617669732d63692e6f72672f736861776e62726f776e2f6765745f7265616465722e7376673f6272616e63683d6d6173746572\"></a> <img alt=\"pyversions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c9368deca0acdb7f259b2adf9d0cdd462fc4f7d1/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f6765745f7265616465722e737667\"> <img alt=\"license\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5f3fc97f8a56b0816bf00a50c634ed430032cfa2/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d417061636865253230322d626c75652e737667\"></p>\n<p>This module provides a <code>get_reader()</code> function that returns reader\nobjects similar to those returned by <code>csv.reader()</code>. This package:</p>\n<ul>\n<li>\n<p>reduces common boilerplate code for handling files and reading\nrecords</p>\n</li>\n<li>\n<p>reads data from CSV, pandas, SQL connections, MS Excel, DBF, and squint</p>\n</li>\n<li>\n<p>provides a single interface across Python versions (including\nseamless Unicode-aware CSV support for Python 2)</p>\n</li>\n<li>\n<p>is easy to incorporate into your own projects:</p>\n<ul>\n<li>has no hard dependencies</li>\n<li>runs on Python 2.6, 2.7, 3.2 through 3.8, PyPy, PyPy3, and Jython</li>\n<li>is freely available under the Apache License, version 2</li>\n<li>can be easily vendored directly into your codebase if you don't\nwant to include it as a dependency</li>\n</ul>\n</li>\n</ul>\n<p><strong>Open a UTF-8 encoded CSV:</strong></p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"s1\">'myfile.csv'</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">row</span> <span class=\"ow\">in</span> <span class=\"n\">reader</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">', '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">))</span>\n</pre>\n<p>In the above example, file handling is managed automatically by the\nreader object. The file is automatically closed when the iterator is\nexhausted or when the object is deleted. It also handles Unicode in\nPython 2 without changes.</p>\n<p><strong>Open a Latin-1 (ISO-8859-1) encoded CSV file:</strong></p>\n<pre><span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"s1\">'myfile.csv'</span><span class=\"p\">,</span> <span class=\"n\">encoding</span><span class=\"o\">=</span><span class=\"s1\">'latin-1'</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">row</span> <span class=\"ow\">in</span> <span class=\"n\">reader</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">', '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">))</span>\n</pre>\n<p><strong>Use the reader as a context manager:</strong></p>\n<pre><span class=\"k\">with</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"s1\">'myfile.csv'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">reader</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">row</span> <span class=\"ow\">in</span> <span class=\"n\">reader</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">', '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">))</span>\n</pre>\n<p>In this example, <code>reader</code> automatically closes its internal file object\nwhen exiting the <code>with</code> block even if the for-loop doesn't finish\nexhausting the <code>reader</code>.</p>\n<p><strong>Access other data sources:</strong></p>\n<pre><span class=\"c1\"># From a pandas DataFrame, Series, Index, or MultiIndex.</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([</span><span class=\"o\">...</span><span class=\"p\">])</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"p\">)</span>  <span class=\"c1\"># requires pandas</span>\n\n<span class=\"c1\"># From a database connection.</span>\n<span class=\"n\">connection</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"s1\">'SELECT col1, col2 FROM mytable;'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># From an Excel file--must install with 'excel' option.</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"s1\">'myfile.xlsx'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># From a DBF file--must install with 'dbf' option.</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"s1\">'myfile.dbf'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># From a squint Select, Query, or Result.</span>\n<span class=\"n\">select</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">select</span><span class=\"p\">({</span><span class=\"s1\">'col1'</span><span class=\"p\">:</span> <span class=\"s1\">'col2'</span><span class=\"p\">})</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">())</span>\n</pre>\n<p><strong>Call constructors directly to override auto-detect behavior:</strong></p>\n<pre><span class=\"c1\"># Specify tab-delimited data from a text file.</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_csv</span><span class=\"p\">(</span><span class=\"s1\">'myfile.dat'</span><span class=\"p\">,</span> <span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">'</span><span class=\"se\">\\t</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n</pre>\n<h2>Install</h2>\n<p>The <code>get_reader</code> module has no hard dependencies; is tested on\nPython 2.6, 2.7, 3.2 through 3.8, PyPy, PyPy3, and Jython; and\nis freely available under the Apache License, version 2.</p>\n<p>You can install <code>get_reader</code> using <code>pip</code>:</p>\n<pre>pip install get_reader\n</pre>\n<p>To install optional support for MS Excel and DBF files (dBase,\nFoxpro, etc.), use the following:</p>\n<pre>pip install get_reader<span class=\"o\">[</span>excel,dbf<span class=\"o\">]</span>\n</pre>\n<p><strong>Python 2 Support Statement</strong></p>\n<p>While official support for Python 2 ends on January 1, 2020, this\nproject will continue to support older versions as long as the\nexisting ecosystem provides the ability to run automated tests\non those older versions.</p>\n<h2>Reference</h2>\n<h3>get_reader(<em>obj</em>, *<em>args</em>, **<em>kwds</em>)</h3>\n<p>Return a <code>Reader</code> object which will iterate over records in\nthe given <em>obj</em>\u2014like a <code>csv.reader()</code>. The given <em>obj</em> may\nbe one of the following:</p>\n<ul>\n<li>CSV file (string path or file object)</li>\n<li>iterable of dictionary rows</li>\n<li>database connection (should be DBAPI2 compatible)</li>\n<li>pandas DataFrame, Series, Index, or MultiIndex</li>\n<li>squint Select, Query, or Result</li>\n</ul>\n<p>If optional extras are installed, <em>obj</em> may also be:</p>\n<ul>\n<li>MS Excel file path</li>\n<li>DBF file path</li>\n</ul>\n<p>When <em>obj</em> is a file path, the <code>Reader</code> contains a file object\nthat is handled internally. When given a file-like <em>obj</em> (rather\nthan a path), users are responsible for properly closing this\nfile themselves.</p>\n<p>The given <em>obj</em> is checked against supported types and\nautomatically passed to the appropriate constructor if a match is\nfound. If <em>obj</em> is a string, it is treated as a file path whose\nextension determines its content type. Any *<em>args</em> and **<em>kwds</em>\nare passed along to the matching constructor:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"c1\"># CSV file.</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"s1\">'myfile.csv'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Database connection.</span>\n<span class=\"n\">connection</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"s1\">'SELECT col1, col2 FROM mytable;'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Pandas DataFrame.</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([</span><span class=\"o\">...</span><span class=\"p\">])</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Excel file.</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"s1\">'myfile.xlsx'</span><span class=\"p\">,</span> <span class=\"n\">worksheet</span><span class=\"o\">=</span><span class=\"s1\">'Sheet2'</span><span class=\"p\">)</span>\n</pre>\n<p>If the <em>obj</em> type cannot be determined automatically, users can\ncall the constructor methods directly.</p>\n<h4>Constructor Methods</h4>\n<p><strong>get_reader.from_csv</strong>(<em>csvfile</em>, <em>encoding</em>='utf-8', <em>dialect</em>='excel', **<em>kwds</em>)</p>\n<p>Return a reader object which will iterate over lines in the\ngiven <em>csvfile</em>. The <em>csvfile</em> can be a string (treated as a\nfile path) or any object which supports the iterator protocol\nand returns a string each time its <code>__next__()</code> method is\ncalled\u2014file objects and list objects are both suitable. If\n<em>csvfile</em> is a file object, it should be opened with <code>newline=''</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_csv</span><span class=\"p\">(</span><span class=\"s1\">'myfile.tab'</span><span class=\"p\">,</span> <span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">'</span><span class=\"se\">\\t</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n</pre>\n<p>Using explicit file handling:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'myfile.csv'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">csvfile</span><span class=\"p\">:</span>\n    <span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_csv</span><span class=\"p\">(</span><span class=\"n\">fh</span><span class=\"p\">)</span>\n</pre>\n<p><strong>get_reader.from_dicts</strong>(<em>records</em>, <em>fieldnames</em>=None)</p>\n<p>Return a reader object which will iterate over the given\ndictionary <em>records</em>. This can be thought of as converting a\n<code>csv.DictReader()</code> into a plain, non-dictionary <code>csv.reader()</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"n\">dictrows</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"p\">{</span><span class=\"s1\">'A'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'B'</span><span class=\"p\">:</span> <span class=\"s1\">'x'</span><span class=\"p\">},</span>\n    <span class=\"p\">{</span><span class=\"s1\">'A'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">'B'</span><span class=\"p\">:</span> <span class=\"s1\">'y'</span><span class=\"p\">},</span>\n<span class=\"p\">]</span>\n\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_dicts</span><span class=\"p\">(</span><span class=\"n\">dictrows</span><span class=\"p\">)</span>\n</pre>\n<p>This method assumes that record contents are consistent. If the first\nrecord is a dictionary, it is assumed that all following records will\nbe dictionaries with matching keys.</p>\n<p><strong>get_reader.from_sql</strong>(<em>connection</em>, <em>table_or_query</em>)</p>\n<p>Return a reader object which will iterate over the records\nfrom a given database table or over the records returned from\na SQL query. The <em>connection</em> should be a DBAPI2 compatible\ndatabase connection and <em>table_or_query</em> must be a string\nwith a table name or a SQL query.</p>\n<p>Read records from a specified table:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"n\">connection</span> <span class=\"o\">=</span> <span class=\"o\">...</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_sql</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"s1\">'mytable'</span><span class=\"p\">)</span>\n</pre>\n<p>Read records from the results of a SQL query:</p>\n<pre><span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_sql</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"s1\">'SELECT col1, col2 FROM mytable;'</span><span class=\"p\">)</span>\n</pre>\n<p><strong>get_reader.from_excel</strong>(<em>path</em>, <em>worksheet</em>=0)</p>\n<p>Return a reader object which will iterate over lines in the given\nExcel worksheet. The <em>path</em> must specify an XLSX or XLS file and\n<em>worksheet</em> must specify the index or name of the worksheet to\nload (defaults to the first worksheet).</p>\n<p>Load first worksheet:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_excel</span><span class=\"p\">(</span><span class=\"s1\">'mydata.xlsx'</span><span class=\"p\">)</span>\n</pre>\n<p>Specific worksheets can be loaded by name (a string) or index\n(an integer):</p>\n<pre><span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_excel</span><span class=\"p\">(</span><span class=\"s1\">'mydata.xlsx'</span><span class=\"p\">,</span> <span class=\"s1\">'Sheet 2'</span><span class=\"p\">)</span>\n</pre>\n<p><strong>get_reader.from_pandas</strong>(<em>obj</em>, <em>index</em>=True)</p>\n<p>Return a reader object which will iterate over records in\na pandas <code>DataFrame</code>, <code>Series</code>, <code>Index</code> or <code>MultiIndex</code>.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"nn\">pd</span>\n<span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_pandas</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"p\">)</span>\n</pre>\n<p><strong>get_reader.from_dbf</strong>(<em>filename</em>, <em>encoding</em>=None, **<em>kwds</em>)</p>\n<p>Return a reader object which will iterate over lines in the given\nDBF file (from dBase, FoxPro, etc.).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_dbf</span><span class=\"p\">(</span><span class=\"s1\">'myfile.dbf'</span><span class=\"p\">)</span>\n</pre>\n<p><strong>get_reader.from_squint</strong>(<em>obj</em>, <em>fieldnames</em>=None)</p>\n<p>Return a reader object which will iterate over the records returned\nfrom a squint <code>Select</code>, <code>Query</code>, or <code>Result</code>. If the <em>fieldnames</em>\nargument is not provided, this function tries to construct names\nusing the values from the underlying object.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">squint</span>\n<span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">get_reader</span>\n\n<span class=\"n\">select</span> <span class=\"o\">=</span> <span class=\"n\">squint</span><span class=\"o\">.</span><span class=\"n\">Select</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">get_reader</span><span class=\"o\">.</span><span class=\"n\">from_squint</span><span class=\"p\">(</span><span class=\"n\">select</span><span class=\"p\">)</span>\n</pre>\n<h3><em>class</em> Reader(<em>iterable</em>, <em>closefunc=&lt;no value&gt;</em>)</h3>\n<p>An iterator which will produce rows from the given <em>iterable</em>. The\ngiven <em>iterable</em> should produce non-string sequences. An optional\n<em>closefunc</em> may be provided to close associated resources (files,\ndatabase cursors, etc.) once the reader is no longer needed\u2014it will\nbe automatically called when:</p>\n<ul>\n<li>the iterable is exhausted</li>\n<li>exiting a <code>with</code> statement (if used as a context manager)</li>\n<li>the Reader is garbage collected</li>\n</ul>\n<p><strong>Reader.close</strong>()</p>\n<p>Closes any associated resources (calls <em>closefunc</em> early):</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">get_reader</span> <span class=\"kn\">import</span> <span class=\"n\">Reader</span>\n\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">Reader</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">closefunc</span><span class=\"o\">=...</span><span class=\"p\">)</span>\n<span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>  <span class=\"c1\"># &lt;- Explicitly close resources.</span>\n</pre>\n<p>If the resources have already been closed, this method passes\nwithout error.</p>\n<h3><em>class</em> ReaderLike()</h3>\n<p>An abstract class that can be used for type checking. Objects\nwill test as <code>ReaderLike</code> if they are one of the following:</p>\n<ul>\n<li>instance of the <code>Reader</code> class</li>\n<li>object returned by <code>csv.reader()</code></li>\n<li>non-exhaustible iterable that produces non-string sequences</li>\n</ul>\n<p>See the following examples:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">csvfile</span><span class=\"p\">),</span> <span class=\"n\">ReaderLike</span><span class=\"p\">)</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">csv</span><span class=\"o\">.</span><span class=\"n\">reader</span><span class=\"p\">(</span><span class=\"n\">csvfile</span><span class=\"p\">),</span> <span class=\"n\">ReaderLike</span><span class=\"p\">)</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">list_of_lists</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"s1\">'col1'</span><span class=\"p\">,</span> <span class=\"s1\">'col2'</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">]]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">list_of_lists</span><span class=\"p\">,</span> <span class=\"n\">ReaderLike</span><span class=\"p\">)</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">list_of_strings</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'col1,col2'</span><span class=\"p\">,</span> <span class=\"s1\">'a,b'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">list_of_strings</span><span class=\"p\">,</span> <span class=\"n\">ReaderLike</span><span class=\"p\">)</span>\n<span class=\"kc\">False</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">list_of_sets</span> <span class=\"o\">=</span> <span class=\"p\">[{</span><span class=\"s1\">'col1'</span><span class=\"p\">,</span> <span class=\"s1\">'col2'</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">}]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">list_of_sets</span><span class=\"p\">,</span> <span class=\"n\">ReaderLike</span><span class=\"p\">)</span>\n<span class=\"kc\">False</span>\n</pre>\n<hr>\n<p>Freely licensed under the Apache License, Version 2.0</p>\n<p>(C) Copyright 2018 \u2013 2019 Shawn Brown.</p>\n\n          </div>"}, "last_serial": 6369879, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "d39e697094b0f63cddbc745d902e9b92", "sha256": "a708b9b2c1d729b68e869ce4d6c224c9fd79fd53bd278d1b855df479a17e456f"}, "downloads": -1, "filename": "get_reader-0.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d39e697094b0f63cddbc745d902e9b92", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "size": 7400, "upload_time": "2019-08-12T02:55:18", "upload_time_iso_8601": "2019-08-12T02:55:18.702793Z", "url": "https://files.pythonhosted.org/packages/3d/07/1c62b2ff475adde08bf0cad5a7c9a96cedd6d45c8210e4cf921bf52cbf99/get_reader-0.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0fef08eca9eb05e2159e7a2db18541f9", "sha256": "44b74b3dc90b88d89c8a49ade1f8f2b5f928db52a0818208e520b5e79912af98"}, "downloads": -1, "filename": "get_reader-0.0.1.tar.gz", "has_sig": false, "md5_digest": "0fef08eca9eb05e2159e7a2db18541f9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "size": 11257, "upload_time": "2019-08-12T02:55:20", "upload_time_iso_8601": "2019-08-12T02:55:20.969649Z", "url": "https://files.pythonhosted.org/packages/64/7e/859f0ed361036a446aab5d5de97fe47c89ae2f14110ca61d61e3adf186d0/get_reader-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "2e5126893d7200fb4b1c73ad18f3c4c1", "sha256": "4514098811cd94d3ecf4fa10717760adde7b4cd20d46f353e068dba23e0621cd"}, "downloads": -1, "filename": "get_reader-0.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2e5126893d7200fb4b1c73ad18f3c4c1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "size": 10468, "upload_time": "2019-09-22T19:18:23", "upload_time_iso_8601": "2019-09-22T19:18:23.804360Z", "url": "https://files.pythonhosted.org/packages/4f/79/c25fd4090e4ffef2cf7328c519d47f8714f0375209c2c4ba3269d4f7abbf/get_reader-0.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6f51c139713b2ef99b54909778ec95bc", "sha256": "3d281ca045fd06369fa917f453dcba5ab0ce3d63ca626b31c60d526c1d4fc6c0"}, "downloads": -1, "filename": "get_reader-0.0.2.tar.gz", "has_sig": false, "md5_digest": "6f51c139713b2ef99b54909778ec95bc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "size": 11699, "upload_time": "2019-09-22T19:18:25", "upload_time_iso_8601": "2019-09-22T19:18:25.755733Z", "url": "https://files.pythonhosted.org/packages/0a/e7/7e548f6a6af805fb044dbeed03a3ba9b905cf9e44640875c168035909df3/get_reader-0.0.2.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "595dff0f47c8edd9b88ff718ae416649", "sha256": "049cde705868d8a88c0fe8abdad0cc36bae1ac769d82b22856b23744e03233a5"}, "downloads": -1, "filename": "get_reader-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "595dff0f47c8edd9b88ff718ae416649", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "size": 10709, "upload_time": "2019-12-29T00:08:12", "upload_time_iso_8601": "2019-12-29T00:08:12.246786Z", "url": "https://files.pythonhosted.org/packages/01/08/a197f7c1234c01b66a7f72b6f6b1fa3e01ae5342bab078812038f492b4eb/get_reader-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ce46a41ceee2bf4fd5743aafbab3142e", "sha256": "b646e60071dea5b5f17cd812da0cc70c5764e1911189564adf181ab89522843d"}, "downloads": -1, "filename": "get_reader-1.0.0.tar.gz", "has_sig": false, "md5_digest": "ce46a41ceee2bf4fd5743aafbab3142e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "size": 11987, "upload_time": "2019-12-29T00:08:13", "upload_time_iso_8601": "2019-12-29T00:08:13.864689Z", "url": "https://files.pythonhosted.org/packages/e9/27/22787b215d9d10de6c52acaa9be50667b430e5c4b9fcf44773a407c2c586/get_reader-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "595dff0f47c8edd9b88ff718ae416649", "sha256": "049cde705868d8a88c0fe8abdad0cc36bae1ac769d82b22856b23744e03233a5"}, "downloads": -1, "filename": "get_reader-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "595dff0f47c8edd9b88ff718ae416649", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "size": 10709, "upload_time": "2019-12-29T00:08:12", "upload_time_iso_8601": "2019-12-29T00:08:12.246786Z", "url": "https://files.pythonhosted.org/packages/01/08/a197f7c1234c01b66a7f72b6f6b1fa3e01ae5342bab078812038f492b4eb/get_reader-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ce46a41ceee2bf4fd5743aafbab3142e", "sha256": "b646e60071dea5b5f17cd812da0cc70c5764e1911189564adf181ab89522843d"}, "downloads": -1, "filename": "get_reader-1.0.0.tar.gz", "has_sig": false, "md5_digest": "ce46a41ceee2bf4fd5743aafbab3142e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6.*, !=3.0.*, !=3.1.*", "size": 11987, "upload_time": "2019-12-29T00:08:13", "upload_time_iso_8601": "2019-12-29T00:08:13.864689Z", "url": "https://files.pythonhosted.org/packages/e9/27/22787b215d9d10de6c52acaa9be50667b430e5c4b9fcf44773a407c2c586/get_reader-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:57:43 2020"}