{"info": {"author": "Yordano Gonzalez Fernandez", "author_email": "yorda891216@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "redis-sort-queue\n================\n\nredis-sort-queue is a priority queue for easy use on redis\n\nInstallation\n------------\n\nThe easiest way to install the redis-sort-queue package is either via\npip:\n\n::\n\n    $ pip install redis-sort-queue\n\nor manually by downloading the source and run the setup.py script:\n\n::\n\n    $ python setup.py install\n\nExamples\n--------\n\nWe have put some self-explanatory examples in the\n`examples <https://github.com/yordanglez/redis-sort-queue/tree/master/redis_sort_queue/example>`__\ndirectory, but here is a quick example on how to get started. Assuming\nthe installation was successful, you can import the redis-sort-queue\npackage like this:\n\nThen, create an instance of **RedisQueue**:\n\n.. code:: python\n\n    from redis_sort_queue import RedisQueue\n\n.. code:: python\n\n    queue = RedisQueue('name_queue')\n    queue.push(100, \"element1\",1, \"element2\")\n    element=queue.pop()\n\nYou can use **datetime** as priority :\n\n.. code:: python\n\n    from redis_sort_queue import RedisQueue\n    from datetime import datetime\n\n    queue = RedisQueue('name_queue')\n    queue.push(datetime.now(), \"element1\",1, \"element2\")\n\nIf you want to use multiple queues you must create an instance of\n**CollectionQueues** :\n\n.. code:: python\n\n    from redis_sort_queue import RedisQueue, CollectionQueues\n\n.. code:: python\n\n    queue1 = RedisQueue('A')\n    queue2 = RedisQueue('B')\n    queue1.push(100, \"E\",1, \"L\")\n    queue2.push(101, \"T\")\n\n.. code:: python\n\n    collection=CollectionQueues()\n    queue3= collection.intersect_queues('intersect1',['A','B'])\n\nIf you want to use pool connection **ConnectionPool** :\n\n.. code:: python\n\n    from redis_sort_queue import RedisQueue, CollectionQueues, ConnectionPool\n\n.. code:: python\n\n    pool = ConnectionPool(host='127.0.0.1', port=6379)\n\n.. code:: python\n\n    queue1 = RedisQueue('A',connection_pool=pool)\n    queue2 = RedisQueue('B',connection_pool=pool)\n    queue1.push(100, \"E\",1, \"L\")\n    queue2.push(101, \"T\",datetime.now(), 10)\n\n    collection=CollectionQueues(connection_pool=pool)\n    queue3= collection.intersect_queues('intersect1',['A','B'])\n    element=queue.pop()\n\nAPI library\n-----------\n\nMethods defined here:\n\n| **clean** ``python clean(self)``\n| Delete all values in queue\n\n**count**\n\n.. code:: python\n\n    count(self)\n\nReturn the number of elements in the queue\n\n**count\\_lex**\n\n.. code:: python\n\n    count_lex(self, min, max)\n\nReturn the number of items in the queue between the lexicographical\nrange **min** and **max**.\n\n**count\\_priority**\n\n.. code:: python\n\n    count_priority(self, min, max)\n\nReturns the number of elements in the queue with a score between **min**\nand **max**.\n\n| **incr\\_priority** ``python incr_priority(self, value, amount=1)``\n| Increment the score of **value** in queue by **amount**\n\n**list**\n\n.. code:: python\n\n    list(self, start=0, end=-1, desc=False, withscores=False, score_cast_func=type float)\n\nReturn a range of values from queue between **start** and **end** sorted\nin ascending order.\n\n**start** and **end** can be negative, indicating the end of the range.\n\n**desc** a boolean indicating whether to sort the results descendingly\n\n**withscores** indicates to return the scores along with the values. The\nreturn type is a list of (value, score) pairs\n\n**score\\_cast\\_func** a callable used to cast the score return value\n\n**list\\_by\\_lex**\n\n.. code:: python\n\n    list_by_lex(self, min, max, start=None, num=None)\n\nReturn the lexicographical range of values from sorted queue between\n**min** and **max**.\n\nIf **start** and **num** are specified, then return a slice of the\nrange.\n\n**list\\_by\\_priority**\n\n.. code:: python\n\n    list_by_priority(self, min, max, start=None, num=None, withscores=False, score_cast_func=<type 'float'>)\n\nReturn the lexicographical range of values from sorted queue between\n**min** and **max**.\n\nIf **start** and **num** are specified, then return a slice of the\nrange.\n\n**pop**\n\n.. code:: python\n\n    pop(self, desc=False)\n\nRemove the first member **values** from queue ordered **desc**\n\n**push**\n\n.. code:: python\n\n    push(self, *args, **kwargs)\n\nSet any number of score, element-name pairs to the queue. Pairs can be\nspecified in two ways:\n\nAs \\*args, in the form of: score1, name1, score2, name2, ...\n\nThe following example would add two values to the queue: redis.push(\n1.1, 'name1', 2.2, 'name2')\n\n**remove**\n\n.. code:: python\n\n    remove(self, *values)\n\nRemove member values from queue", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/yordanglez/redis-sort-queue", "keywords": "Redis,Queue,Priority,Sort", "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "redis-sort-queue", "package_url": "https://pypi.org/project/redis-sort-queue/", "platform": "linux", "project_url": "https://pypi.org/project/redis-sort-queue/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/yordanglez/redis-sort-queue"}, "release_url": "https://pypi.org/project/redis-sort-queue/1.3.3/", "requires_dist": null, "requires_python": null, "summary": "ordered queue for redis", "version": "1.3.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>redis-sort-queue is a priority queue for easy use on redis</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>The easiest way to install the redis-sort-queue package is either via\npip:</p>\n<pre>$ pip install redis-sort-queue\n</pre>\n<p>or manually by downloading the source and run the setup.py script:</p>\n<pre>$ python setup.py install\n</pre>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>We have put some self-explanatory examples in the\n<a href=\"https://github.com/yordanglez/redis-sort-queue/tree/master/redis_sort_queue/example\" rel=\"nofollow\">examples</a>\ndirectory, but here is a quick example on how to get started. Assuming\nthe installation was successful, you can import the redis-sort-queue\npackage like this:</p>\n<p>Then, create an instance of <strong>RedisQueue</strong>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">redis_sort_queue</span> <span class=\"kn\">import</span> <span class=\"n\">RedisQueue</span>\n</pre>\n<pre><span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">RedisQueue</span><span class=\"p\">(</span><span class=\"s1\">'name_queue'</span><span class=\"p\">)</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"s2\">\"element1\"</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s2\">\"element2\"</span><span class=\"p\">)</span>\n<span class=\"n\">element</span><span class=\"o\">=</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n</pre>\n<p>You can use <strong>datetime</strong> as priority :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">redis_sort_queue</span> <span class=\"kn\">import</span> <span class=\"n\">RedisQueue</span>\n<span class=\"kn\">from</span> <span class=\"nn\">datetime</span> <span class=\"kn\">import</span> <span class=\"n\">datetime</span>\n\n<span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">RedisQueue</span><span class=\"p\">(</span><span class=\"s1\">'name_queue'</span><span class=\"p\">)</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">now</span><span class=\"p\">(),</span> <span class=\"s2\">\"element1\"</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s2\">\"element2\"</span><span class=\"p\">)</span>\n</pre>\n<p>If you want to use multiple queues you must create an instance of\n<strong>CollectionQueues</strong> :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">redis_sort_queue</span> <span class=\"kn\">import</span> <span class=\"n\">RedisQueue</span><span class=\"p\">,</span> <span class=\"n\">CollectionQueues</span>\n</pre>\n<pre><span class=\"n\">queue1</span> <span class=\"o\">=</span> <span class=\"n\">RedisQueue</span><span class=\"p\">(</span><span class=\"s1\">'A'</span><span class=\"p\">)</span>\n<span class=\"n\">queue2</span> <span class=\"o\">=</span> <span class=\"n\">RedisQueue</span><span class=\"p\">(</span><span class=\"s1\">'B'</span><span class=\"p\">)</span>\n<span class=\"n\">queue1</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"s2\">\"E\"</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s2\">\"L\"</span><span class=\"p\">)</span>\n<span class=\"n\">queue2</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">101</span><span class=\"p\">,</span> <span class=\"s2\">\"T\"</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"n\">collection</span><span class=\"o\">=</span><span class=\"n\">CollectionQueues</span><span class=\"p\">()</span>\n<span class=\"n\">queue3</span><span class=\"o\">=</span> <span class=\"n\">collection</span><span class=\"o\">.</span><span class=\"n\">intersect_queues</span><span class=\"p\">(</span><span class=\"s1\">'intersect1'</span><span class=\"p\">,[</span><span class=\"s1\">'A'</span><span class=\"p\">,</span><span class=\"s1\">'B'</span><span class=\"p\">])</span>\n</pre>\n<p>If you want to use pool connection <strong>ConnectionPool</strong> :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">redis_sort_queue</span> <span class=\"kn\">import</span> <span class=\"n\">RedisQueue</span><span class=\"p\">,</span> <span class=\"n\">CollectionQueues</span><span class=\"p\">,</span> <span class=\"n\">ConnectionPool</span>\n</pre>\n<pre><span class=\"n\">pool</span> <span class=\"o\">=</span> <span class=\"n\">ConnectionPool</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"o\">=</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">6379</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"n\">queue1</span> <span class=\"o\">=</span> <span class=\"n\">RedisQueue</span><span class=\"p\">(</span><span class=\"s1\">'A'</span><span class=\"p\">,</span><span class=\"n\">connection_pool</span><span class=\"o\">=</span><span class=\"n\">pool</span><span class=\"p\">)</span>\n<span class=\"n\">queue2</span> <span class=\"o\">=</span> <span class=\"n\">RedisQueue</span><span class=\"p\">(</span><span class=\"s1\">'B'</span><span class=\"p\">,</span><span class=\"n\">connection_pool</span><span class=\"o\">=</span><span class=\"n\">pool</span><span class=\"p\">)</span>\n<span class=\"n\">queue1</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"s2\">\"E\"</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s2\">\"L\"</span><span class=\"p\">)</span>\n<span class=\"n\">queue2</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">101</span><span class=\"p\">,</span> <span class=\"s2\">\"T\"</span><span class=\"p\">,</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">now</span><span class=\"p\">(),</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n\n<span class=\"n\">collection</span><span class=\"o\">=</span><span class=\"n\">CollectionQueues</span><span class=\"p\">(</span><span class=\"n\">connection_pool</span><span class=\"o\">=</span><span class=\"n\">pool</span><span class=\"p\">)</span>\n<span class=\"n\">queue3</span><span class=\"o\">=</span> <span class=\"n\">collection</span><span class=\"o\">.</span><span class=\"n\">intersect_queues</span><span class=\"p\">(</span><span class=\"s1\">'intersect1'</span><span class=\"p\">,[</span><span class=\"s1\">'A'</span><span class=\"p\">,</span><span class=\"s1\">'B'</span><span class=\"p\">])</span>\n<span class=\"n\">element</span><span class=\"o\">=</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"api-library\">\n<h2>API library</h2>\n<p>Methods defined here:</p>\n<div>\n<div><strong>clean</strong> <tt>python clean(self)</tt></div>\n<div>Delete all values in queue</div>\n</div>\n<p><strong>count</strong></p>\n<pre><span class=\"n\">count</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n</pre>\n<p>Return the number of elements in the queue</p>\n<p><strong>count_lex</strong></p>\n<pre><span class=\"n\">count_lex</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">,</span> <span class=\"nb\">max</span><span class=\"p\">)</span>\n</pre>\n<p>Return the number of items in the queue between the lexicographical\nrange <strong>min</strong> and <strong>max</strong>.</p>\n<p><strong>count_priority</strong></p>\n<pre><span class=\"n\">count_priority</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">,</span> <span class=\"nb\">max</span><span class=\"p\">)</span>\n</pre>\n<p>Returns the number of elements in the queue with a score between <strong>min</strong>\nand <strong>max</strong>.</p>\n<div>\n<div><strong>incr_priority</strong> <tt>python incr_priority(self, value, amount=1)</tt></div>\n<div>Increment the score of <strong>value</strong> in queue by <strong>amount</strong></div>\n</div>\n<p><strong>list</strong></p>\n<pre><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">desc</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">withscores</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">score_cast_func</span><span class=\"o\">=</span><span class=\"nb\">type</span> <span class=\"nb\">float</span><span class=\"p\">)</span>\n</pre>\n<p>Return a range of values from queue between <strong>start</strong> and <strong>end</strong> sorted\nin ascending order.</p>\n<p><strong>start</strong> and <strong>end</strong> can be negative, indicating the end of the range.</p>\n<p><strong>desc</strong> a boolean indicating whether to sort the results descendingly</p>\n<p><strong>withscores</strong> indicates to return the scores along with the values. The\nreturn type is a list of (value, score) pairs</p>\n<p><strong>score_cast_func</strong> a callable used to cast the score return value</p>\n<p><strong>list_by_lex</strong></p>\n<pre><span class=\"n\">list_by_lex</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">,</span> <span class=\"nb\">max</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>Return the lexicographical range of values from sorted queue between\n<strong>min</strong> and <strong>max</strong>.</p>\n<p>If <strong>start</strong> and <strong>num</strong> are specified, then return a slice of the\nrange.</p>\n<p><strong>list_by_priority</strong></p>\n<pre><span class=\"n\">list_by_priority</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">,</span> <span class=\"nb\">max</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">withscores</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">score_cast_func</span><span class=\"o\">=&lt;</span><span class=\"nb\">type</span> <span class=\"s1\">'float'</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n</pre>\n<p>Return the lexicographical range of values from sorted queue between\n<strong>min</strong> and <strong>max</strong>.</p>\n<p>If <strong>start</strong> and <strong>num</strong> are specified, then return a slice of the\nrange.</p>\n<p><strong>pop</strong></p>\n<pre><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">desc</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>Remove the first member <strong>values</strong> from queue ordered <strong>desc</strong></p>\n<p><strong>push</strong></p>\n<pre><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n</pre>\n<p>Set any number of score, element-name pairs to the queue. Pairs can be\nspecified in two ways:</p>\n<p>As *args, in the form of: score1, name1, score2, name2, \u2026</p>\n<p>The following example would add two values to the queue: redis.push(\n1.1, \u2018name1\u2019, 2.2, \u2018name2\u2019)</p>\n<p><strong>remove</strong></p>\n<pre><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">values</span><span class=\"p\">)</span>\n</pre>\n<p>Remove member values from queue</p>\n</div>\n\n          </div>"}, "last_serial": 2894056, "releases": {"1.3.3": [{"comment_text": "", "digests": {"md5": "0758dcd3e817c6af261718ace5aeb386", "sha256": "e551667e0c267269fda1e47c6690eefffd0638432d6f662ab9c5dee376fed0ba"}, "downloads": -1, "filename": "redis-sort-queue-1.3.3.tar.gz", "has_sig": false, "md5_digest": "0758dcd3e817c6af261718ace5aeb386", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4236, "upload_time": "2017-05-23T19:01:53", "upload_time_iso_8601": "2017-05-23T19:01:53.310402Z", "url": "https://files.pythonhosted.org/packages/83/df/c16a10bb9b384e8246932d431d5ecd2bf817223f16ac2300b91a65dfe82a/redis-sort-queue-1.3.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0758dcd3e817c6af261718ace5aeb386", "sha256": "e551667e0c267269fda1e47c6690eefffd0638432d6f662ab9c5dee376fed0ba"}, "downloads": -1, "filename": "redis-sort-queue-1.3.3.tar.gz", "has_sig": false, "md5_digest": "0758dcd3e817c6af261718ace5aeb386", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4236, "upload_time": "2017-05-23T19:01:53", "upload_time_iso_8601": "2017-05-23T19:01:53.310402Z", "url": "https://files.pythonhosted.org/packages/83/df/c16a10bb9b384e8246932d431d5ecd2bf817223f16ac2300b91a65dfe82a/redis-sort-queue-1.3.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:44 2020"}