{"info": {"author": "Joe Cross", "author_email": "joe.mcross@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Topic :: Software Development :: Libraries"], "description": ".. image:: https://img.shields.io/travis/numberoverzero/texas/master.svg?style=flat-square\n    :target: https://travis-ci.org/numberoverzero/texas\n.. image:: https://img.shields.io/coveralls/numberoverzero/texas/master.svg?style=flat-square\n    :target: https://coveralls.io/github/numberoverzero/texas\n.. image:: https://img.shields.io/pypi/v/texas.svg?style=flat-square\n    :target: https://pypi.python.org/pypi/texas\n.. image:: https://img.shields.io/github/issues-raw/numberoverzero/texas.svg?style=flat-square\n    :target: https://github.com/numberoverzero/texas/issues\n.. image:: https://img.shields.io/pypi/l/texas.svg?style=flat-square\n    :target: https://github.com/numberoverzero/texas/blob/master/LICENSE\n\nPure python.  Path keys.  ChainedMap on steroids.\n\nInstallation\n============\n\n::\n\n    pip install texas\n\nQuick Start\n===========\n\n::\n\n    import texas\n\n    context = texas.Context()\n\n    environment = context.include(\"environment\")\n    cli = context.include(\"cli\")\n\n    config = context.include(\"environment\", \"cli\")\n\n    environment[\"src.root\"] = \"~/pics\"\n    cli[\"src.type\"] = \"jpg\"\n\n    config[\"src.root\"]  # ~/pics\n    config[\"src.type\"]  # jpg\n\n    # Change cli's root\n    cli[\"src.root\"] = \"~/other\"\n\n    # Doesn't change the underlying environment root\n    environment[\"src.root\"]  # ~/pics\n\n    # Modifies cli, which is the top context in config\n    del config[\"src.root\"]\n    config[\"src.root\"]  # ~/pics\n\n    # Snapshot the contexts into a single dict for use in modules that\n    # typecheck against dict (instead of collections.abc.Mapping)\n    import pprint\n    pprint.pprint(config.snapshot)\n    # {\n    #     \"src\": {\n    #         \"root\": \"~/pics\",\n    #         \"type\": \"jpg\"\n    #     }\n    # }\n\nUsage\n=====\n\nContexts are namespaced python dictionaries with (configurable) path lookups::\n\n    import texas\n\n    context = texas.Context()\n    # Single context\n    root = context.include(\"root\")\n\n    # normal dictionary operations\n    root[\"foo\"] = \"bar\"\n    assert \"bar\" == root[\"foo\"]\n    del root[\"foo\"]\n\n    # paths\n    root[\"foo.bar\"] = \"baz\"\n    assert \"baz\" == root[\"foo.bar\"]\n    del root[\"foo.bar\"]\n\nInclude\n-------\n\nInclude takes a variable number of context names to load into a view::\n\n    bottom = context.include(\"bottom\")\n    top = context.include(\"top\")\n\n    both = context.include(\"bottom\", \"top\")\n\nThis can be used to create a priority when looking up values.  The top of the\ncontext stack will be checked for a key first, then the next, until a context\nwith the given key is found::\n\n    bottom[\"key\"] = \"bottom\"\n    assert both[\"key\"] == \"bottom\"\n\n    top[\"key\"] = \"top\"\n    assert both[\"key\"] == \"top\"\n\nCombined with paths, this can be very powerful for configuration management::\n\n    context = texas.Context()\n    env = context.include(\"env\")\n    cli = context.include(\"cli\")\n    config = context.include(\"env\", \"cli\")\n\n    env[\"src.root\"] = \"~/pics\"\n    cli[\"src.type\"] = \"jpg\"\n\n    assert config[\"src.root\"] == \"~/pics\"\n    assert config[\"src.type\"] == \"jpg\"\n\nThis even works with individual path segments, since ContextView returns\nproxies against the underlying mapping objects::\n\n    config[\"src\"]  # <texas.context.ContextView at ... >\n    config[\"src\"][\"type\"]  # \"jpg\"\n\nSetting values only applies to the top context in the view, so the value in\nbottom is still the same::\n\n    assert bottom[\"key\"] == \"bottom\"\n\nThis breaks down with mutable values - for instance, this will modify the list\nin the bottom context:\n\n    context = texas.Context()\n    bottom = context.include(\"bottom\")\n    top = context.include(\"top\")\n    both = context.include(\"bottom\", \"top\")\n\n    bottom[\"list\"] = []\n    top[\"list\"].append(\"modified!\")\n\n    assert bottom[\"list\"] == [\"modified!\"]\n\nSnapshot\n--------\n\nContext does some heavy lifting to make paths and multiple dicts work together\ncomfortably.  Unfortunately, some libraries make ``isinstance`` checks against\n``dict``, and not ``collections.abc.Mapping``.\n\nThis is also useful when passing a ContextView to code that will perform many\nlookups in a tight loop.  Because an intermediate lookup on a deeply nested\nset of dicts creates one proxy per level (ie.\n``something[\"foo\"][\"bar\"][\"baz\"]`` creates two proxies for the value\n``something[\"foo.bar.baz\"] = \"blah\"``) it can be a significant speedup to\n\"snapshot\" or bake the ContextView for much faster reading.\n\nMerging dicts in general is a complex problem at best, with many ambiguities.\nTo simplify things, the following rules are used::\n\n    (1) For every key in each context, the top-most[0] context that contains\n        that key will determine if the value will be used directly, or merged\n        with other contexts.\n    (2) If that value is a collections.abc.Mapping, the value of that key in\n        each context that contains that key will be merged.\n        (A) If there is a context with that key whose value is NOT a mapping,\n            its value will be ignored.\n        (B) If that value is NOT a collections.abc.Mapping, the value will be\n            used directly and no merging occurs[1].\n    3) These rules are applied recursively[2] for any nested mappings.\n\nThe \"top-most context that contains that key\" is not always the top context.\nIn the following, the bottom context is the only one that contains the key\n\"bottom\"::\n\n    {\n        \"bottom\": \"bottom-value\"\n    },\n    {\n        \"top\": \"top-value\"\n    }\n\n    Snapshot:\n\n    {\n        \"bottom\": \"bottom-value\",\n        \"top\": \"top-value\"\n    }\n\nWhen there is a conflict in type (mapping, non-mapping) the top-most context\ndetermines the type.  For example, this will take the mapping values from\nbottom and top, but not middle (whose value is not a mapping)::\n\n    {\n        \"key\": {\n            \"bottom\": \"bottom-value\"\n        }\n    },\n    {\n        \"key\": [\"middle\", \"non\", \"mapping\"]\n    },\n    {\n        \"key\": {\n            \"top\": \"top-value\"\n        }\n    }\n\n    Snapshot:\n\n    {\n        \"key\": {\n            \"bottom\": \"bottom-value\",\n            \"top\": \"top-value\"\n        }\n    }\n\nWhile snapshot applies its rules recursively to mappings, the implementation is\nnot recursive.  A sample file that merges arbitrary iterables of mappings using\nthe same rules as texas is available\n`here <https://gist.github.com/numberoverzero/90a36aef936e6dd5a6c4#file-merge-py>`_.\n\nContext Factory\n---------------\n\nBy default, texas uses simple ``dict``s for storage.  However, this can be\ncustomized with the ``context_factory`` function, such as using a\n``collections.OrderedDict`` or pre-loading values into the node.\n\nThis function is used when creating snapshots, the context root, new contexts,\nand intermediate segments when setting values by paths.\n\n::\n\n    created = 0\n\n    def factory():\n        global created\n        created += 1\n        return dict()\n\n    # Root context container\n    context = texas.Context(context_factory=factory)\n    assert created == 1\n\n    # Including contexts\n    ctx = context.include(\"some-context\")\n    assert created == 2\n\n    # Segments along a path when setting values\n    ctx[\"foo.bar\"] = \"value\"\n    assert created == 3\n\nInternals\n---------\n\nInternally, all data is stored in python dicts.  You can inspect the global\nstate of a context through its ``contexts`` attribute::\n\n    import texas\n    context = texas.Context()\n\n    context.include(\"root.something.or.foo\")\n    context.include(\"bar\", \"and.yet.another.foo\", \"finally\")\n\n    print(context._contexts)\n\nPath traversal is performed by the ``traverse`` function, which only handles\ntraversal of ``collestions.abc.Mapping``.  Therefore, when a non-mapping value\nis expected at the end of a path, the path should be split like so::\n\n    full_path = \"foo.bar.baz\"\n    path, last = full_path.rsplit(\".\", 1)\n\n    assert path == \"foo.bar\"\n    assert last = \"baz\"\n\nThis allows us to travers a root and create the intermediate ``foo`` and\n``bar`` dicts without modifying or inspecting ``baz``::\n\n    from texas.traversal import traverse, create_on_missing\n\n    root = dict()\n    full_path = \"foo.bar.baz\"\n    path, key = full_path.rsplit(\".\", 1)\n\n    node = traverse(root, path, \".\", create_on_missing(dict))\n    node[key] = \"value\"\n\n    assert root[\"foo\"][\"bar\"][\"baz\"] == \"value\"", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/numberoverzero/texas", "keywords": "dict nested context", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "texas", "package_url": "https://pypi.org/project/texas/", "platform": "any", "project_url": "https://pypi.org/project/texas/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/numberoverzero/texas"}, "release_url": "https://pypi.org/project/texas/0.5.2/", "requires_dist": null, "requires_python": null, "summary": "nested dictionaries with paths", "version": "0.5.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/numberoverzero/texas\" rel=\"nofollow\"><img alt=\"https://img.shields.io/travis/numberoverzero/texas/master.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/929f75d22d965a67006a9bf4e9879ef3521c4602/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f6e756d6265726f7665727a65726f2f74657861732f6d61737465722e7376673f7374796c653d666c61742d737175617265\"></a>\n<a href=\"https://coveralls.io/github/numberoverzero/texas\" rel=\"nofollow\"><img alt=\"https://img.shields.io/coveralls/numberoverzero/texas/master.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/26186580c2dbd058247dd133272c1b994b7a4f2d/68747470733a2f2f696d672e736869656c64732e696f2f636f766572616c6c732f6e756d6265726f7665727a65726f2f74657861732f6d61737465722e7376673f7374796c653d666c61742d737175617265\"></a>\n<a href=\"https://pypi.python.org/pypi/texas\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/texas.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/81f43da8ff494e307595b60e87dedf81b89e1c98/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f74657861732e7376673f7374796c653d666c61742d737175617265\"></a>\n<a href=\"https://github.com/numberoverzero/texas/issues\" rel=\"nofollow\"><img alt=\"https://img.shields.io/github/issues-raw/numberoverzero/texas.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/399dcb616b150749a0387870d8e3f7a3fb3eb4ab/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6973737565732d7261772f6e756d6265726f7665727a65726f2f74657861732e7376673f7374796c653d666c61742d737175617265\"></a>\n<a href=\"https://github.com/numberoverzero/texas/blob/master/LICENSE\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/l/texas.svg?style=flat-square\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b7e0552db52c7169335e5b43cae8e6b08c90d813/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f74657861732e7376673f7374796c653d666c61742d737175617265\"></a>\n<p>Pure python.  Path keys.  ChainedMap on steroids.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>pip install texas\n</pre>\n</div>\n<div id=\"quick-start\">\n<h2>Quick Start</h2>\n<pre>import texas\n\ncontext = texas.Context()\n\nenvironment = context.include(\"environment\")\ncli = context.include(\"cli\")\n\nconfig = context.include(\"environment\", \"cli\")\n\nenvironment[\"src.root\"] = \"~/pics\"\ncli[\"src.type\"] = \"jpg\"\n\nconfig[\"src.root\"]  # ~/pics\nconfig[\"src.type\"]  # jpg\n\n# Change cli's root\ncli[\"src.root\"] = \"~/other\"\n\n# Doesn't change the underlying environment root\nenvironment[\"src.root\"]  # ~/pics\n\n# Modifies cli, which is the top context in config\ndel config[\"src.root\"]\nconfig[\"src.root\"]  # ~/pics\n\n# Snapshot the contexts into a single dict for use in modules that\n# typecheck against dict (instead of collections.abc.Mapping)\nimport pprint\npprint.pprint(config.snapshot)\n# {\n#     \"src\": {\n#         \"root\": \"~/pics\",\n#         \"type\": \"jpg\"\n#     }\n# }\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Contexts are namespaced python dictionaries with (configurable) path lookups:</p>\n<pre>import texas\n\ncontext = texas.Context()\n# Single context\nroot = context.include(\"root\")\n\n# normal dictionary operations\nroot[\"foo\"] = \"bar\"\nassert \"bar\" == root[\"foo\"]\ndel root[\"foo\"]\n\n# paths\nroot[\"foo.bar\"] = \"baz\"\nassert \"baz\" == root[\"foo.bar\"]\ndel root[\"foo.bar\"]\n</pre>\n<div id=\"include\">\n<h3>Include</h3>\n<p>Include takes a variable number of context names to load into a view:</p>\n<pre>bottom = context.include(\"bottom\")\ntop = context.include(\"top\")\n\nboth = context.include(\"bottom\", \"top\")\n</pre>\n<p>This can be used to create a priority when looking up values.  The top of the\ncontext stack will be checked for a key first, then the next, until a context\nwith the given key is found:</p>\n<pre>bottom[\"key\"] = \"bottom\"\nassert both[\"key\"] == \"bottom\"\n\ntop[\"key\"] = \"top\"\nassert both[\"key\"] == \"top\"\n</pre>\n<p>Combined with paths, this can be very powerful for configuration management:</p>\n<pre>context = texas.Context()\nenv = context.include(\"env\")\ncli = context.include(\"cli\")\nconfig = context.include(\"env\", \"cli\")\n\nenv[\"src.root\"] = \"~/pics\"\ncli[\"src.type\"] = \"jpg\"\n\nassert config[\"src.root\"] == \"~/pics\"\nassert config[\"src.type\"] == \"jpg\"\n</pre>\n<p>This even works with individual path segments, since ContextView returns\nproxies against the underlying mapping objects:</p>\n<pre>config[\"src\"]  # &lt;texas.context.ContextView at ... &gt;\nconfig[\"src\"][\"type\"]  # \"jpg\"\n</pre>\n<p>Setting values only applies to the top context in the view, so the value in\nbottom is still the same:</p>\n<pre>assert bottom[\"key\"] == \"bottom\"\n</pre>\n<p>This breaks down with mutable values - for instance, this will modify the list\nin the bottom context:</p>\n<blockquote>\n<p>context = texas.Context()\nbottom = context.include(\u201cbottom\u201d)\ntop = context.include(\u201ctop\u201d)\nboth = context.include(\u201cbottom\u201d, \u201ctop\u201d)</p>\n<p>bottom[\u201clist\u201d] = []\ntop[\u201clist\u201d].append(\u201cmodified!\u201d)</p>\n<p>assert bottom[\u201clist\u201d] == [\u201cmodified!\u201d]</p>\n</blockquote>\n</div>\n<div id=\"snapshot\">\n<h3>Snapshot</h3>\n<p>Context does some heavy lifting to make paths and multiple dicts work together\ncomfortably.  Unfortunately, some libraries make <tt>isinstance</tt> checks against\n<tt>dict</tt>, and not <tt>collections.abc.Mapping</tt>.</p>\n<p>This is also useful when passing a ContextView to code that will perform many\nlookups in a tight loop.  Because an intermediate lookup on a deeply nested\nset of dicts creates one proxy per level (ie.\n<tt><span class=\"pre\">something[\"foo\"][\"bar\"][\"baz\"]</span></tt> creates two proxies for the value\n<tt><span class=\"pre\">something[\"foo.bar.baz\"]</span> = \"blah\"</tt>) it can be a significant speedup to\n\u201csnapshot\u201d or bake the ContextView for much faster reading.</p>\n<p>Merging dicts in general is a complex problem at best, with many ambiguities.\nTo simplify things, the following rules are used:</p>\n<pre>(1) For every key in each context, the top-most[0] context that contains\n    that key will determine if the value will be used directly, or merged\n    with other contexts.\n(2) If that value is a collections.abc.Mapping, the value of that key in\n    each context that contains that key will be merged.\n    (A) If there is a context with that key whose value is NOT a mapping,\n        its value will be ignored.\n    (B) If that value is NOT a collections.abc.Mapping, the value will be\n        used directly and no merging occurs[1].\n3) These rules are applied recursively[2] for any nested mappings.\n</pre>\n<p>The \u201ctop-most context that contains that key\u201d is not always the top context.\nIn the following, the bottom context is the only one that contains the key\n\u201cbottom\u201d:</p>\n<pre>{\n    \"bottom\": \"bottom-value\"\n},\n{\n    \"top\": \"top-value\"\n}\n\nSnapshot:\n\n{\n    \"bottom\": \"bottom-value\",\n    \"top\": \"top-value\"\n}\n</pre>\n<p>When there is a conflict in type (mapping, non-mapping) the top-most context\ndetermines the type.  For example, this will take the mapping values from\nbottom and top, but not middle (whose value is not a mapping):</p>\n<pre>{\n    \"key\": {\n        \"bottom\": \"bottom-value\"\n    }\n},\n{\n    \"key\": [\"middle\", \"non\", \"mapping\"]\n},\n{\n    \"key\": {\n        \"top\": \"top-value\"\n    }\n}\n\nSnapshot:\n\n{\n    \"key\": {\n        \"bottom\": \"bottom-value\",\n        \"top\": \"top-value\"\n    }\n}\n</pre>\n<p>While snapshot applies its rules recursively to mappings, the implementation is\nnot recursive.  A sample file that merges arbitrary iterables of mappings using\nthe same rules as texas is available\n<a href=\"https://gist.github.com/numberoverzero/90a36aef936e6dd5a6c4#file-merge-py\" rel=\"nofollow\">here</a>.</p>\n</div>\n<div id=\"context-factory\">\n<h3>Context Factory</h3>\n<p>By default, texas uses simple <tt><span class=\"pre\">dict``s</span> for storage.\u00a0 However, this can be\ncustomized with the ``context_factory</tt> function, such as using a\n<tt>collections.OrderedDict</tt> or pre-loading values into the node.</p>\n<p>This function is used when creating snapshots, the context root, new contexts,\nand intermediate segments when setting values by paths.</p>\n<pre>created = 0\n\ndef factory():\n    global created\n    created += 1\n    return dict()\n\n# Root context container\ncontext = texas.Context(context_factory=factory)\nassert created == 1\n\n# Including contexts\nctx = context.include(\"some-context\")\nassert created == 2\n\n# Segments along a path when setting values\nctx[\"foo.bar\"] = \"value\"\nassert created == 3\n</pre>\n</div>\n<div id=\"internals\">\n<h3>Internals</h3>\n<p>Internally, all data is stored in python dicts.  You can inspect the global\nstate of a context through its <tt>contexts</tt> attribute:</p>\n<pre>import texas\ncontext = texas.Context()\n\ncontext.include(\"root.something.or.foo\")\ncontext.include(\"bar\", \"and.yet.another.foo\", \"finally\")\n\nprint(context._contexts)\n</pre>\n<p>Path traversal is performed by the <tt>traverse</tt> function, which only handles\ntraversal of <tt>collestions.abc.Mapping</tt>.  Therefore, when a non-mapping value\nis expected at the end of a path, the path should be split like so:</p>\n<pre>full_path = \"foo.bar.baz\"\npath, last = full_path.rsplit(\".\", 1)\n\nassert path == \"foo.bar\"\nassert last = \"baz\"\n</pre>\n<p>This allows us to travers a root and create the intermediate <tt>foo</tt> and\n<tt>bar</tt> dicts without modifying or inspecting <tt>baz</tt>:</p>\n<pre>from texas.traversal import traverse, create_on_missing\n\nroot = dict()\nfull_path = \"foo.bar.baz\"\npath, key = full_path.rsplit(\".\", 1)\n\nnode = traverse(root, path, \".\", create_on_missing(dict))\nnode[key] = \"value\"\n\nassert root[\"foo\"][\"bar\"][\"baz\"] == \"value\"\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1973420, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "da7281c5a5aa5b2383bafd965eba3bf1", "sha256": "dcfd7562124616bcf5e51fbb08b62c06252a084042d105eee10b079cbfa3e61c"}, "downloads": -1, "filename": "texas-0.1.tar.gz", "has_sig": false, "md5_digest": "da7281c5a5aa5b2383bafd965eba3bf1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4004, "upload_time": "2016-02-18T10:58:36", "upload_time_iso_8601": "2016-02-18T10:58:36.135741Z", "url": "https://files.pythonhosted.org/packages/3c/f2/ff91616cd0d1a7323f1cac80082f99ba4a6ccff867e95892141c83308355/texas-0.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "05d7aaacc3566d7347c93e361084e86e", "sha256": "0f430254d923c14dd25f5e5b8e3d0ed1677ceb12a382d84b2cf599400d4783d3"}, "downloads": -1, "filename": "texas-0.1.2.tar.gz", "has_sig": false, "md5_digest": "05d7aaacc3566d7347c93e361084e86e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4082, "upload_time": "2016-02-18T11:05:57", "upload_time_iso_8601": "2016-02-18T11:05:57.495618Z", "url": "https://files.pythonhosted.org/packages/a7/9c/f7e1e592ed780f41ac5d3d228856cfcb3c8b25ae57a74506473e1c3c4005/texas-0.1.2.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "b4d7c72b2374bf4f077f1b94dc7e74e4", "sha256": "d6f83c48f4776819d1dc8e15af76ffa7a26771c2a89d1575a8ba5262ab054b86"}, "downloads": -1, "filename": "texas-0.2.tar.gz", "has_sig": false, "md5_digest": "b4d7c72b2374bf4f077f1b94dc7e74e4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5597, "upload_time": "2016-02-21T06:45:00", "upload_time_iso_8601": "2016-02-21T06:45:00.753016Z", "url": "https://files.pythonhosted.org/packages/38/ef/53e1ef9055c344cbb97c4be66c91b82047d4a4430d434dbcb1b41e3d203f/texas-0.2.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "e22a1a6b0efc0f1206c075f7809f4ae3", "sha256": "b311f989dbc2b9acbaf2ba6a5c704d957a689632119bc9f61ee21d95299cf83e"}, "downloads": -1, "filename": "texas-0.2.1.tar.gz", "has_sig": false, "md5_digest": "e22a1a6b0efc0f1206c075f7809f4ae3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5626, "upload_time": "2016-02-21T07:23:55", "upload_time_iso_8601": "2016-02-21T07:23:55.955227Z", "url": "https://files.pythonhosted.org/packages/f4/b4/2f75c1b04154bdb5c55eada5c045c47a47e5f51e841ef0fa54e775ebbbd7/texas-0.2.1.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "749f9c4c6ff949f1b1636733be78578c", "sha256": "f99df0e49d04c2ef2dc8d2fd2e4bd5bf713d73f4f58c6d37bdd41af672d4d2b6"}, "downloads": -1, "filename": "texas-0.3.0.tar.gz", "has_sig": false, "md5_digest": "749f9c4c6ff949f1b1636733be78578c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8408, "upload_time": "2016-02-21T12:55:43", "upload_time_iso_8601": "2016-02-21T12:55:43.111940Z", "url": "https://files.pythonhosted.org/packages/4b/c3/9ab9108780f4386de2abf20737ba9b62cd0772bfc99a18a7b8518835f70b/texas-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "478e0b52e8f499fe4eb552ef65017c22", "sha256": "af95fda23c61a602c13ca08c6b3bf59d39c70945b0b2bb4adcfe62d33e522e07"}, "downloads": -1, "filename": "texas-0.4.0.tar.gz", "has_sig": false, "md5_digest": "478e0b52e8f499fe4eb552ef65017c22", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7679, "upload_time": "2016-02-22T04:20:41", "upload_time_iso_8601": "2016-02-22T04:20:41.202198Z", "url": "https://files.pythonhosted.org/packages/80/18/95b1eb2b0fd6ca3518d77079dbcf358041551ba900d9893151baf32cb3c5/texas-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "082c4ba00027ffdc8dd5526eba76915f", "sha256": "0252ea0141261554750aaf9cb07cfe22e71492a3d1ea44c5b3dbe5bdc1bd416f"}, "downloads": -1, "filename": "texas-0.5.0.tar.gz", "has_sig": false, "md5_digest": "082c4ba00027ffdc8dd5526eba76915f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6952, "upload_time": "2016-02-22T09:49:16", "upload_time_iso_8601": "2016-02-22T09:49:16.659633Z", "url": "https://files.pythonhosted.org/packages/4a/25/68dad24b668860e64ee7763fbc012002d332d6be754254fe2057ae119440/texas-0.5.0.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "34470a80ad9c3f74bace508fc6fda8e1", "sha256": "9a844d9a99007b800a237b8759777b3c69a0a290b71be50e39b891d0944929fc"}, "downloads": -1, "filename": "texas-0.5.1.tar.gz", "has_sig": false, "md5_digest": "34470a80ad9c3f74bace508fc6fda8e1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6960, "upload_time": "2016-02-22T11:00:55", "upload_time_iso_8601": "2016-02-22T11:00:55.122526Z", "url": "https://files.pythonhosted.org/packages/85/4e/2bcbe1d79fd62a9768fd7f0f3bebf67de613965dfae4903b85a91902d68b/texas-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "4c69556406cc3f98f375a7134695c1e4", "sha256": "7de9bc99972e57896ea40e755f6a0bb847bcf6e427dfb16582757d18ccd28adc"}, "downloads": -1, "filename": "texas-0.5.2.tar.gz", "has_sig": false, "md5_digest": "4c69556406cc3f98f375a7134695c1e4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7348, "upload_time": "2016-02-24T07:08:33", "upload_time_iso_8601": "2016-02-24T07:08:33.905192Z", "url": "https://files.pythonhosted.org/packages/2a/b3/85c1a57990b1b46e47456dcb48026d0df14c1736901eac43570eec5249fd/texas-0.5.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4c69556406cc3f98f375a7134695c1e4", "sha256": "7de9bc99972e57896ea40e755f6a0bb847bcf6e427dfb16582757d18ccd28adc"}, "downloads": -1, "filename": "texas-0.5.2.tar.gz", "has_sig": false, "md5_digest": "4c69556406cc3f98f375a7134695c1e4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7348, "upload_time": "2016-02-24T07:08:33", "upload_time_iso_8601": "2016-02-24T07:08:33.905192Z", "url": "https://files.pythonhosted.org/packages/2a/b3/85c1a57990b1b46e47456dcb48026d0df14c1736901eac43570eec5249fd/texas-0.5.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:55:10 2020"}