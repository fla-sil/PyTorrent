{"info": {"author": "Rump Us", "author_email": "ru@mp.us", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: ISC License (ISCL)", "Natural Language :: English", "Programming Language :: Python", "Programming Language :: Python :: 2.7"], "description": "====\nrump\n====\n\n.. image:: https://travis-ci.org/bninja/rump.png\n   :target: https://travis-ci.org/bninja/rump\n\n.. image:: https://coveralls.io/repos/bninja/rump/badge.png\n   :target: https://coveralls.io/r/bninja/rump\n\nR(outing)Ump(ire) is an **experimenal** upstream (i.e. server) selector for\nHTTP requests. It does **not** proxy the request but instead integrates with a\nload-balancer or reverse-proxy that exposes an upstream selection interface:\n\n- nginx `X-Accel-* <http://wiki.nginx.org/X-accel>`_\n- ...\n\ndev\n===\n\n.. code:: bash\n\n   $ git clone git@github.com:bninja/rump.git\n   $ cd rump\n   $ mkvirtualenv rump\n   (rump)$ pip install -e .[tests]\n   (rump)$ py.test test/ --cov=rump --cov-report term-missing\n\nwtf?\n====\n\nTypically you can embed complex routing logic directly in a load-balancer or\nreverse-proxy (e.g. nginx lua, varnish vcl, etc) and that's what should be\ndone 99% of the time.\n\nThis is an **experiment** to see what writing a Python based HTTP upstream\nselector would look like and what flexibility that gives you.\n\nUse it as a ``program`` or embed it as a ``lib`` in your proxy.\n\nprogram\n=======\n\nInstall it:\n\n- `ansible-rump <https://github.com/bninja/ansible-rump>`_\n- ...\n\nUse it:\n\n.. code:: bash\n\n   $ rump list\n   my-router\n   $ rump show -d my-router\n   ...\n   $ rump edit -d my-router\n   $ service rumpd status\n\n\nlib\n===\n\nGet it:\n\n.. code:: bash\n\n   $ pip install rump\n    \n    \nUse it:\n\n.. code:: python\n\n   import rump\n   \n   router = rump.Router(\n       name='my-router',\n       ...\n   )\n\n   upstream = router.match_upstream(router.request_type(wsgi_environ))\n   if upstream:\n      server = upstream()", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/bninja/rump/", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "rump", "package_url": "https://pypi.org/project/rump/", "platform": "any", "project_url": "https://pypi.org/project/rump/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/bninja/rump/"}, "release_url": "https://pypi.org/project/rump/0.2.1/", "requires_dist": null, "requires_python": null, "summary": "Upstream selection.", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/bninja/rump\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/bninja/rump.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/96fe6e98d464dd7ccf1ec7f5d7c7e8be3f54c4be/68747470733a2f2f7472617669732d63692e6f72672f626e696e6a612f72756d702e706e67\"></a>\n<a href=\"https://coveralls.io/r/bninja/rump\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/bninja/rump/badge.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/066c3e3c4ba0266327628d8a630909a3c74047b1/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f626e696e6a612f72756d702f62616467652e706e67\"></a>\n<p>R(outing)Ump(ire) is an <strong>experimenal</strong> upstream (i.e. server) selector for\nHTTP requests. It does <strong>not</strong> proxy the request but instead integrates with a\nload-balancer or reverse-proxy that exposes an upstream selection interface:</p>\n<ul>\n<li>nginx <a href=\"http://wiki.nginx.org/X-accel\" rel=\"nofollow\">X-Accel-*</a></li>\n<li>\u2026</li>\n</ul>\n<div id=\"dev\">\n<h2>dev</h2>\n<pre>$ git clone git@github.com:bninja/rump.git\n$ <span class=\"nb\">cd</span> rump\n$ mkvirtualenv rump\n<span class=\"o\">(</span>rump<span class=\"o\">)</span>$ pip install -e .<span class=\"o\">[</span>tests<span class=\"o\">]</span>\n<span class=\"o\">(</span>rump<span class=\"o\">)</span>$ py.test test/ --cov<span class=\"o\">=</span>rump --cov-report term-missing\n</pre>\n</div>\n<div id=\"wtf\">\n<h2>wtf?</h2>\n<p>Typically you can embed complex routing logic directly in a load-balancer or\nreverse-proxy (e.g. nginx lua, varnish vcl, etc) and that\u2019s what should be\ndone 99% of the time.</p>\n<p>This is an <strong>experiment</strong> to see what writing a Python based HTTP upstream\nselector would look like and what flexibility that gives you.</p>\n<p>Use it as a <tt>program</tt> or embed it as a <tt>lib</tt> in your proxy.</p>\n</div>\n<div id=\"program\">\n<h2>program</h2>\n<p>Install it:</p>\n<ul>\n<li><a href=\"https://github.com/bninja/ansible-rump\" rel=\"nofollow\">ansible-rump</a></li>\n<li>\u2026</li>\n</ul>\n<p>Use it:</p>\n<pre>$ rump list\nmy-router\n$ rump show -d my-router\n...\n$ rump edit -d my-router\n$ service rumpd status\n</pre>\n</div>\n<div id=\"lib\">\n<h2>lib</h2>\n<p>Get it:</p>\n<pre>$ pip install rump\n</pre>\n<p>Use it:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rump</span>\n\n<span class=\"n\">router</span> <span class=\"o\">=</span> <span class=\"n\">rump</span><span class=\"o\">.</span><span class=\"n\">Router</span><span class=\"p\">(</span>\n    <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'my-router'</span><span class=\"p\">,</span>\n    <span class=\"o\">...</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">upstream</span> <span class=\"o\">=</span> <span class=\"n\">router</span><span class=\"o\">.</span><span class=\"n\">match_upstream</span><span class=\"p\">(</span><span class=\"n\">router</span><span class=\"o\">.</span><span class=\"n\">request_type</span><span class=\"p\">(</span><span class=\"n\">wsgi_environ</span><span class=\"p\">))</span>\n<span class=\"k\">if</span> <span class=\"n\">upstream</span><span class=\"p\">:</span>\n   <span class=\"n\">server</span> <span class=\"o\">=</span> <span class=\"n\">upstream</span><span class=\"p\">()</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 1252577, "releases": {"0.2.0": [{"comment_text": "", "digests": {"md5": "9b6f094aea2f8caa32db17a6db1c369e", "sha256": "2ffcff047e4ba30761ffa7f90556e6c282b8b5f190979b8c91e3df31c3fc9648"}, "downloads": -1, "filename": "rump-0.2.0.tar.gz", "has_sig": false, "md5_digest": "9b6f094aea2f8caa32db17a6db1c369e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28351, "upload_time": "2014-10-07T04:40:30", "upload_time_iso_8601": "2014-10-07T04:40:30.801446Z", "url": "https://files.pythonhosted.org/packages/38/f3/9995aefad06a7e5854368d015921c4622063c84e05bce9d0bfd47ee11b4c/rump-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "7eb5d7c011ff399b9190290da399fa82", "sha256": "857ad69152ec4e94401388e17cbf7ce6459aedd5f44d5e6baf2987b4ce5f24c6"}, "downloads": -1, "filename": "rump-0.2.1.tar.gz", "has_sig": false, "md5_digest": "7eb5d7c011ff399b9190290da399fa82", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34849, "upload_time": "2014-10-09T03:19:53", "upload_time_iso_8601": "2014-10-09T03:19:53.548949Z", "url": "https://files.pythonhosted.org/packages/ca/cd/bfde05d262a0302dd88fd2d3ca1b0e6b1d81afeecbb72e823ec10c21632c/rump-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7eb5d7c011ff399b9190290da399fa82", "sha256": "857ad69152ec4e94401388e17cbf7ce6459aedd5f44d5e6baf2987b4ce5f24c6"}, "downloads": -1, "filename": "rump-0.2.1.tar.gz", "has_sig": false, "md5_digest": "7eb5d7c011ff399b9190290da399fa82", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34849, "upload_time": "2014-10-09T03:19:53", "upload_time_iso_8601": "2014-10-09T03:19:53.548949Z", "url": "https://files.pythonhosted.org/packages/ca/cd/bfde05d262a0302dd88fd2d3ca1b0e6b1d81afeecbb72e823ec10c21632c/rump-0.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:05 2020"}