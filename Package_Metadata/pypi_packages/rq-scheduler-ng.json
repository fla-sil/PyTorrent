{"info": {"author": "Selwin Ong", "author_email": "selwin.ong@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "============\nRQ Scheduler\n============\n\n`RQ Scheduler <https://github.com/ui/rq-scheduler>`_ is a small package that\nadds job scheduling capabilities to `RQ <https://github.com/nvie/rq>`_,\na `Redis <http://redis.io/>`_ based Python queuing library.\n\n.. image:: https://travis-ci.org/ui/rq-scheduler.svg?branch=master\n    :target: https://travis-ci.org/ui/rq-scheduler\n\n============\nRequirements\n============\n\n* `RQ`_\n\n============\nInstallation\n============\n\nYou can install `RQ Scheduler`_ via pip::\n\n    pip install rq-scheduler\n\nOr you can download the latest stable package from `PyPI <http://pypi.python.org/pypi/rq-scheduler>`_.\n\n=====\nUsage\n=====\n\nSchedule a job involves doing two different things:\n\n1. Putting a job in the scheduler\n2. Running a scheduler that will move scheduled jobs into queues when the time comes\n\n----------------\nScheduling a Job\n----------------\n\nThere are two ways you can schedule a job. The first is using RQ Scheduler's ``enqueue_at``::\n\n    from redis import Redis\n    from rq_scheduler import Scheduler\n    from datetime import datetime\n\n    scheduler = Scheduler(connection=Redis()) # Get a scheduler for the \"default\" queue\n\n    # Puts a job into the scheduler. The API is similar to RQ except that it\n    # takes a datetime object as first argument. So for example to schedule a\n    # job to run on Jan 1st 2020 we do:\n    scheduler.enqueue_at(datetime(2020, 1, 1), func)\n\n    # Here's another example scheduling a job to run at a specific date and time (in UTC),\n    # complete with args and kwargs.\n    scheduler.enqueue_at(datetime(2020, 1, 1, 3, 4), func, foo, bar=baz)\n\n\nThe second way is using ``enqueue_in``. Instead of taking a ``datetime`` object,\nthis method expects a ``timedelta`` and schedules the job to run at\nX seconds/minutes/hours/days/weeks later. For example, if we want to monitor how\npopular a tweet is a few times during the course of the day, we could do something like::\n\n    from datetime import timedelta\n\n    # Schedule a job to run 10 minutes, 1 hour and 1 day later\n    scheduler.enqueue_in(timedelta(minutes=10), count_retweets, tweet_id)\n    scheduler.enqueue_in(timedelta(hours=1), count_retweets, tweet_id)\n    scheduler.enqueue_in(timedelta(days=1), count_retweets, tweet_id)\n\n\n------------------------\nPeriodic & Repeated Jobs\n------------------------\n\nAs of version 0.3, `RQ Scheduler`_ also supports creating periodic and repeated jobs.\nYou can do this via the ``schedule`` method. Note that this feature needs\n`RQ`_ >= 0.3.1.\n\nThis is how you do it::\n\n    scheduler.schedule(\n        scheduled_time=datetime.now(), # Time for first execution, in UTC timezone\n        func=func,                     # Function to be queued\n        args=[arg1, arg2],             # Arguments passed into function when executed\n        kwargs={'foo': 'bar'},         # Keyword arguments passed into function when executed\n        interval=60,                   # Time before the function is called again, in seconds\n        repeat=10                      # Repeat this number of times (None means repeat forever)\n    )\n\n-------------------------\nRetrieving scheduled jobs\n-------------------------\n\nSometimes you need to know which jobs have already been scheduled. You can get a\nlist of enqueued jobs with the ``get_jobs`` method::\n\n    list_of_job_instances = scheduler.get_jobs()\n\nIn it's simplest form (as seen in the above example) this method returns a list\nof all job instances that are currently scheduled for execution.\n\nAdditionally the method takes two optional keyword arguments ``until`` and\n``with_times``. The first one specifies up to which point in time scheduled jobs\nshould be returned. It can be given as either a datetime / timedelta instance\nor an integer denoting the number of seconds since epoch (1970-01-01 00:00:00).\nThe second argument is a boolen that determines whether the scheduled execution\ntime should be returned along with the job instances.\n\nExample::\n\n    # get all jobs until 2012-11-30 10:00:00\n    list_of_job_instances = scheduler.get_jobs(until=datetime(2012, 10, 30, 10))\n\n    # get all jobs for the next hour\n    list_of_job_instances = scheduler.get_jobs(until=timedelta(hours=1))\n\n    # get all jobs with execution times\n    jobs_and_times = scheduler.get_jobs(with_times=True)\n    # returns a list of tuples:\n    # [(<rq.job.Job object at 0x123456789>, datetime.datetime(2012, 11, 25, 12, 30)), ...]\n\n------------------------------\nChecking if a job is scheduled\n------------------------------\n\nYou can check whether a specific job instance or job id is scheduled for\nexecution using the familiar python ``in`` operator::\n\n    if job_instance in scheduler:\n        # Do something\n    # or\n    if job_id in scheduler:\n        # Do something\n\n---------------\nCanceling a job\n---------------\n\nTo cancel a job, simply do:\n\n    scheduler.cancel(job)\n\n---------------------\nRunning the scheduler\n---------------------\n\n`RQ Scheduler`_ comes with a script ``rqscheduler`` that runs a scheduler\nprocess that polls Redis once every minute and move scheduled jobs to the\nrelevant queues when they need to be executed::\n\n    # This runs a scheduler process using the default Redis connection\n    rqscheduler\n\nIf you want to use a different Redis server you could also do::\n\n    rqscheduler --host localhost --port 6379 --db 0\n\nThe script accepts these arguments:\n\n* ``-H`` or ``--host``: Redis server to connect to\n* ``-p`` or ``--port``: port to connect to\n* ``-d`` or ``--db``: Redis db to use\n* ``-P`` or ``--password``: password to connect to Redis\n\nThe arguments pull default values from environment variables with the\nsame names but with a prefix of ``RQ_REDIS_``.\n\n\nChangelog\n=========\n\nVersion 0.5.1\n-------------\n* Travis CI fixes. Thanks Steven Kryskalla!\n* Modified default logging configuration. You can pass in the ``-v`` or ``--verbose`` argument\n  to ``rqscheduler`` script for more verbose logging.\n* RQ Scheduler now registers Queue name when a new job is scheduled. Thanks @alejandrodob !\n* You can now schedule jobs with string references like ``scheduler.schedule(scheduled_time=now, func='foo.bar')``.\n  Thanks @SirScott !\n* ``rqscheduler`` script now accepts floating point intervals. Thanks Alexander Pikovsky!\n\n\nVersion 0.5.0\n-------------\n* IMPORTANT! Job timestamps are now stored and interpreted in UTC format.\n  If you have existing scheduled jobs, you should probably change their timestamp\n  to UTC before upgrading to 0.5.0. Thanks @michaelbrooks!\n* You can now configure Redis connection via environment variables. Thanks @malthe!\n* ``rqscheduler`` script now accepts ``--pid`` argument. Thanks @jsoncorwin!\n\nVersion 0.4.0\n-------------\n\n* Supports Python 3!\n* ``Scheduler.schedule`` now allows job ``timeout`` to be specified\n* ``rqscheduler`` allows Redis connection to be specified via ``--url`` argument\n* ``rqscheduler`` now accepts ``--path`` argument\n\nVersion 0.3.6\n-------------\n\n* Scheduler key is not set to expire a few seconds after the next scheduling\n  operation. This solves the issue of ``rqscheduler`` refusing to start after\n  an unexpected shut down.\n\nVersion 0.3.5\n-------------\n\n* Support ``StrictRedis``\n\n\nVersion 0.3.4\n-------------\n\n* Scheduler related job attributes (``interval`` and ``repeat``) are now stored\n  in ``job.meta`` introduced in RQ 0.3.4\n\nVersion 0.3.3\n-------------\n\n* You can now check whether a job is scheduled for execution using\n  ``job in scheduler`` syntax\n* Added ``scheduler.get_jobs`` method\n* ``scheduler.enqueue`` and ``scheduler.enqueue_periodic`` will now raise a\n  DeprecationWarning, please use ``scheduler.schedule`` instead\n\nVersion 0.3.2\n-------------\n\n* Periodic jobs now require `RQ`_ >= 0.3.1\n\nVersion 0.3\n-----------\n\n* Added the capability to create periodic (cron) and repeated job using ``scheduler.enqueue``\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ui/rq-scheduler", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "rq-scheduler-ng", "package_url": "https://pypi.org/project/rq-scheduler-ng/", "platform": "", "project_url": "https://pypi.org/project/rq-scheduler-ng/", "project_urls": {"Homepage": "https://github.com/ui/rq-scheduler"}, "release_url": "https://pypi.org/project/rq-scheduler-ng/0.5.1/", "requires_dist": null, "requires_python": "", "summary": "Provides job scheduling capabilities to RQ (Redis Queue)", "version": "0.5.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"rq-scheduler\">\n<h2>RQ Scheduler</h2>\n<p><a href=\"https://github.com/ui/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> is a small package that\nadds job scheduling capabilities to <a href=\"https://github.com/nvie/rq\" rel=\"nofollow\">RQ</a>,\na <a href=\"http://redis.io/\" rel=\"nofollow\">Redis</a> based Python queuing library.</p>\n<a href=\"https://travis-ci.org/ui/rq-scheduler\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/ui/rq-scheduler.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ad286a4671bd934c397c2b3edf5abbaccab0fc5d/68747470733a2f2f7472617669732d63692e6f72672f75692f72712d7363686564756c65722e7376673f6272616e63683d6d6173746572\"></a>\n</div>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<ul>\n<li><a href=\"https://github.com/nvie/rq\" rel=\"nofollow\">RQ</a></li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>You can install <a href=\"https://github.com/ui/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> via pip:</p>\n<pre>pip install rq-scheduler\n</pre>\n<p>Or you can download the latest stable package from <a href=\"http://pypi.python.org/pypi/rq-scheduler\" rel=\"nofollow\">PyPI</a>.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Schedule a job involves doing two different things:</p>\n<ol>\n<li>Putting a job in the scheduler</li>\n<li>Running a scheduler that will move scheduled jobs into queues when the time comes</li>\n</ol>\n<div id=\"scheduling-a-job\">\n<h3>Scheduling a Job</h3>\n<p>There are two ways you can schedule a job. The first is using RQ Scheduler\u2019s <tt>enqueue_at</tt>:</p>\n<pre>from redis import Redis\nfrom rq_scheduler import Scheduler\nfrom datetime import datetime\n\nscheduler = Scheduler(connection=Redis()) # Get a scheduler for the \"default\" queue\n\n# Puts a job into the scheduler. The API is similar to RQ except that it\n# takes a datetime object as first argument. So for example to schedule a\n# job to run on Jan 1st 2020 we do:\nscheduler.enqueue_at(datetime(2020, 1, 1), func)\n\n# Here's another example scheduling a job to run at a specific date and time (in UTC),\n# complete with args and kwargs.\nscheduler.enqueue_at(datetime(2020, 1, 1, 3, 4), func, foo, bar=baz)\n</pre>\n<p>The second way is using <tt>enqueue_in</tt>. Instead of taking a <tt>datetime</tt> object,\nthis method expects a <tt>timedelta</tt> and schedules the job to run at\nX seconds/minutes/hours/days/weeks later. For example, if we want to monitor how\npopular a tweet is a few times during the course of the day, we could do something like:</p>\n<pre>from datetime import timedelta\n\n# Schedule a job to run 10 minutes, 1 hour and 1 day later\nscheduler.enqueue_in(timedelta(minutes=10), count_retweets, tweet_id)\nscheduler.enqueue_in(timedelta(hours=1), count_retweets, tweet_id)\nscheduler.enqueue_in(timedelta(days=1), count_retweets, tweet_id)\n</pre>\n</div>\n<div id=\"periodic-repeated-jobs\">\n<h3>Periodic &amp; Repeated Jobs</h3>\n<p>As of version 0.3, <a href=\"https://github.com/ui/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> also supports creating periodic and repeated jobs.\nYou can do this via the <tt>schedule</tt> method. Note that this feature needs\n<a href=\"https://github.com/nvie/rq\" rel=\"nofollow\">RQ</a> &gt;= 0.3.1.</p>\n<p>This is how you do it:</p>\n<pre>scheduler.schedule(\n    scheduled_time=datetime.now(), # Time for first execution, in UTC timezone\n    func=func,                     # Function to be queued\n    args=[arg1, arg2],             # Arguments passed into function when executed\n    kwargs={'foo': 'bar'},         # Keyword arguments passed into function when executed\n    interval=60,                   # Time before the function is called again, in seconds\n    repeat=10                      # Repeat this number of times (None means repeat forever)\n)\n</pre>\n</div>\n<div id=\"retrieving-scheduled-jobs\">\n<h3>Retrieving scheduled jobs</h3>\n<p>Sometimes you need to know which jobs have already been scheduled. You can get a\nlist of enqueued jobs with the <tt>get_jobs</tt> method:</p>\n<pre>list_of_job_instances = scheduler.get_jobs()\n</pre>\n<p>In it\u2019s simplest form (as seen in the above example) this method returns a list\nof all job instances that are currently scheduled for execution.</p>\n<p>Additionally the method takes two optional keyword arguments <tt>until</tt> and\n<tt>with_times</tt>. The first one specifies up to which point in time scheduled jobs\nshould be returned. It can be given as either a datetime / timedelta instance\nor an integer denoting the number of seconds since epoch (1970-01-01 00:00:00).\nThe second argument is a boolen that determines whether the scheduled execution\ntime should be returned along with the job instances.</p>\n<p>Example:</p>\n<pre># get all jobs until 2012-11-30 10:00:00\nlist_of_job_instances = scheduler.get_jobs(until=datetime(2012, 10, 30, 10))\n\n# get all jobs for the next hour\nlist_of_job_instances = scheduler.get_jobs(until=timedelta(hours=1))\n\n# get all jobs with execution times\njobs_and_times = scheduler.get_jobs(with_times=True)\n# returns a list of tuples:\n# [(&lt;rq.job.Job object at 0x123456789&gt;, datetime.datetime(2012, 11, 25, 12, 30)), ...]\n</pre>\n</div>\n<div id=\"checking-if-a-job-is-scheduled\">\n<h3>Checking if a job is scheduled</h3>\n<p>You can check whether a specific job instance or job id is scheduled for\nexecution using the familiar python <tt>in</tt> operator:</p>\n<pre>if job_instance in scheduler:\n    # Do something\n# or\nif job_id in scheduler:\n    # Do something\n</pre>\n</div>\n<div id=\"canceling-a-job\">\n<h3>Canceling a job</h3>\n<p>To cancel a job, simply do:</p>\n<blockquote>\nscheduler.cancel(job)</blockquote>\n</div>\n<div id=\"running-the-scheduler\">\n<h3>Running the scheduler</h3>\n<p><a href=\"https://github.com/ui/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> comes with a script <tt>rqscheduler</tt> that runs a scheduler\nprocess that polls Redis once every minute and move scheduled jobs to the\nrelevant queues when they need to be executed:</p>\n<pre># This runs a scheduler process using the default Redis connection\nrqscheduler\n</pre>\n<p>If you want to use a different Redis server you could also do:</p>\n<pre>rqscheduler --host localhost --port 6379 --db 0\n</pre>\n<p>The script accepts these arguments:</p>\n<ul>\n<li><tt><span class=\"pre\">-H</span></tt> or <tt><span class=\"pre\">--host</span></tt>: Redis server to connect to</li>\n<li><tt><span class=\"pre\">-p</span></tt> or <tt><span class=\"pre\">--port</span></tt>: port to connect to</li>\n<li><tt><span class=\"pre\">-d</span></tt> or <tt><span class=\"pre\">--db</span></tt>: Redis db to use</li>\n<li><tt><span class=\"pre\">-P</span></tt> or <tt><span class=\"pre\">--password</span></tt>: password to connect to Redis</li>\n</ul>\n<p>The arguments pull default values from environment variables with the\nsame names but with a prefix of <tt>RQ_REDIS_</tt>.</p>\n<div id=\"changelog\">\n<h4>Changelog</h4>\n<div id=\"version-0-5-1\">\n<h5>Version 0.5.1</h5>\n<ul>\n<li>Travis CI fixes. Thanks Steven Kryskalla!</li>\n<li>Modified default logging configuration. You can pass in the <tt><span class=\"pre\">-v</span></tt> or <tt><span class=\"pre\">--verbose</span></tt> argument\nto <tt>rqscheduler</tt> script for more verbose logging.</li>\n<li>RQ Scheduler now registers Queue name when a new job is scheduled. Thanks @alejandrodob !</li>\n<li>You can now schedule jobs with string references like <tt>scheduler.schedule(scheduled_time=now, <span class=\"pre\">func='foo.bar')</span></tt>.\nThanks @SirScott !</li>\n<li><tt>rqscheduler</tt> script now accepts floating point intervals. Thanks Alexander Pikovsky!</li>\n</ul>\n</div>\n<div id=\"version-0-5-0\">\n<h5>Version 0.5.0</h5>\n<ul>\n<li>IMPORTANT! Job timestamps are now stored and interpreted in UTC format.\nIf you have existing scheduled jobs, you should probably change their timestamp\nto UTC before upgrading to 0.5.0. Thanks @michaelbrooks!</li>\n<li>You can now configure Redis connection via environment variables. Thanks @malthe!</li>\n<li><tt>rqscheduler</tt> script now accepts <tt><span class=\"pre\">--pid</span></tt> argument. Thanks @jsoncorwin!</li>\n</ul>\n</div>\n<div id=\"version-0-4-0\">\n<h5>Version 0.4.0</h5>\n<ul>\n<li>Supports Python 3!</li>\n<li><tt>Scheduler.schedule</tt> now allows job <tt>timeout</tt> to be specified</li>\n<li><tt>rqscheduler</tt> allows Redis connection to be specified via <tt><span class=\"pre\">--url</span></tt> argument</li>\n<li><tt>rqscheduler</tt> now accepts <tt><span class=\"pre\">--path</span></tt> argument</li>\n</ul>\n</div>\n<div id=\"version-0-3-6\">\n<h5>Version 0.3.6</h5>\n<ul>\n<li>Scheduler key is not set to expire a few seconds after the next scheduling\noperation. This solves the issue of <tt>rqscheduler</tt> refusing to start after\nan unexpected shut down.</li>\n</ul>\n</div>\n<div id=\"version-0-3-5\">\n<h5>Version 0.3.5</h5>\n<ul>\n<li>Support <tt>StrictRedis</tt></li>\n</ul>\n</div>\n<div id=\"version-0-3-4\">\n<h5>Version 0.3.4</h5>\n<ul>\n<li>Scheduler related job attributes (<tt>interval</tt> and <tt>repeat</tt>) are now stored\nin <tt>job.meta</tt> introduced in RQ 0.3.4</li>\n</ul>\n</div>\n<div id=\"version-0-3-3\">\n<h5>Version 0.3.3</h5>\n<ul>\n<li>You can now check whether a job is scheduled for execution using\n<tt>job in scheduler</tt> syntax</li>\n<li>Added <tt>scheduler.get_jobs</tt> method</li>\n<li><tt>scheduler.enqueue</tt> and <tt>scheduler.enqueue_periodic</tt> will now raise a\nDeprecationWarning, please use <tt>scheduler.schedule</tt> instead</li>\n</ul>\n</div>\n<div id=\"version-0-3-2\">\n<h5>Version 0.3.2</h5>\n<ul>\n<li>Periodic jobs now require <a href=\"https://github.com/nvie/rq\" rel=\"nofollow\">RQ</a> &gt;= 0.3.1</li>\n</ul>\n</div>\n<div id=\"version-0-3\">\n<h5>Version 0.3</h5>\n<ul>\n<li>Added the capability to create periodic (cron) and repeated job using <tt>scheduler.enqueue</tt></li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 2561526, "releases": {"0.5.1": [{"comment_text": "", "digests": {"md5": "eb979a6f767aa2cebf6ffa5a1d736516", "sha256": "ded15d61a14d27834bf1e287e9a2409c6a142c2efaa587aa4e8a496b7bdb0e42"}, "downloads": -1, "filename": "rq_scheduler_ng-0.5.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "eb979a6f767aa2cebf6ffa5a1d736516", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 13567, "upload_time": "2017-01-09T03:29:20", "upload_time_iso_8601": "2017-01-09T03:29:20.985593Z", "url": "https://files.pythonhosted.org/packages/61/86/515362de1bb55adadcb26507f3cc418348c0e7ee622e431f04a1f694f957/rq_scheduler_ng-0.5.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9548f6cde553d8533425d70623dc0a80", "sha256": "dad4cc8faf775dc1eb2e5ffb18efd79b3b5cc13286c665b54488a21b5e025951"}, "downloads": -1, "filename": "rq-scheduler-ng-0.5.1.tar.gz", "has_sig": false, "md5_digest": "9548f6cde553d8533425d70623dc0a80", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12043, "upload_time": "2017-01-09T03:29:15", "upload_time_iso_8601": "2017-01-09T03:29:15.999925Z", "url": "https://files.pythonhosted.org/packages/e0/3e/9fb633898dc786614b47fecb46f29089d88c76b4d08a26f638853ddd5324/rq-scheduler-ng-0.5.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "eb979a6f767aa2cebf6ffa5a1d736516", "sha256": "ded15d61a14d27834bf1e287e9a2409c6a142c2efaa587aa4e8a496b7bdb0e42"}, "downloads": -1, "filename": "rq_scheduler_ng-0.5.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "eb979a6f767aa2cebf6ffa5a1d736516", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 13567, "upload_time": "2017-01-09T03:29:20", "upload_time_iso_8601": "2017-01-09T03:29:20.985593Z", "url": "https://files.pythonhosted.org/packages/61/86/515362de1bb55adadcb26507f3cc418348c0e7ee622e431f04a1f694f957/rq_scheduler_ng-0.5.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9548f6cde553d8533425d70623dc0a80", "sha256": "dad4cc8faf775dc1eb2e5ffb18efd79b3b5cc13286c665b54488a21b5e025951"}, "downloads": -1, "filename": "rq-scheduler-ng-0.5.1.tar.gz", "has_sig": false, "md5_digest": "9548f6cde553d8533425d70623dc0a80", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12043, "upload_time": "2017-01-09T03:29:15", "upload_time_iso_8601": "2017-01-09T03:29:15.999925Z", "url": "https://files.pythonhosted.org/packages/e0/3e/9fb633898dc786614b47fecb46f29089d88c76b4d08a26f638853ddd5324/rq-scheduler-ng-0.5.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:46 2020"}