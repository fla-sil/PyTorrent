{"info": {"author": "Oleg Churkin", "author_email": "bahusoff@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# Easy caching decorators\n\n[![Build Status](https://travis-ci.org/Bahus/easy_cache.svg?branch=master)](https://travis-ci.org/Bahus/easy_cache)\n\nThis package is intended to simplify caching and invalidation process in python-based (primarily) web applications. It's possible to cache execution results of functions; **instance**, **class** and **static** methods; properties. Cache keys may be constructed in various different ways and may depend on any number of parameters.\n\nThe package supports tag-based cache invalidation and better works with Django, however any other frameworks can be used \u2013 see examples below.\n\nThe main idea of this package: you don't need to touch any existing function code to cache its execution results.\n\n## Requirements\n\nLibrary was tested in the following environments:\n\n* Python 2.7, 3.5, 3.6\n* Django 1.8, 1.11, >=2.0.0\n\nFeel free to try it in yours, but it's not guaranteed it will work. Submit an issue if you think it should.\n\n## Installation\n\n```shell\npip install easy_cache\n```\n\n## Introduction\n\n### Different ways to cache something\n\nImagine you have a time consuming function and you need to cache an execution results, the classic way to achieve this is the next one:\n\n```python\n# classic way\nfrom django.core.cache import cache\n\ndef time_consuming_operation(n):\n    \"\"\"Calculate sum of number from 1 to provided n\"\"\"\n    cache_key = 'time_consuming_operation_{}'.format(n)\n    result = cache.get(cache_key, None)\n\n    if result is None:\n        # not found in cache\n        result = sum(range(n + 1))\n        # cache result for one hour\n        cache.set(cache_key, result, 3600)\n\n    return result\n\ndef invalidate_cache(n):\n    cache.delete('time_consuming_operation_{}'.format(n))\n```\n\nWell, we had to add annoying boilerplate code to achieve this.\nNow let's take a look how `easy_cache` can avoid the problem and simplify the code:\n\n```python\n# easy way\nfrom easy_cache import ecached\n\n@ecached('time_consuming_operation_{n}', 3600)\ndef time_consuming_operation(n):\n    return sum(range(n + 1))\n\ndef invalidate_cache(n):\n    time_consuming_operation.invalidate_cache_by_key(n)\n```\n\nAs we can see the function code left clear.\nHeart of the package is two decorators with the similar parameters:\n\n### ecached\n\nShould be used to decorate any callable and cache returned result.\n\nParameters:\n\n* `cache_key` \u2013 cache key generator, default value is `None` so the key will be composed automatically based on a function name, namespace and passed parameters. Also the following types are supported:\n  * **string** \u2013 may contain [Python advanced string formatting syntax](https://docs.python.org/2/library/string.html#formatstrings), a given value will be formatted with a dict of parameters passed to decorated function, see examples below.\n  * **sequence of strings** \u2013 each string must be function parameter name.\n  * **callable** \u2013 is used to generate cache key, decorated function parameters will be passed to this callable and returned value will be used as a cache key. Also one additional signature is available: `callable(meta)`, where `meta` is a dict-like object with some additional attributes \u2013 see below.\n* `timeout` \u2013 value will be cached with provided timeout, basically it should be number of seconds, however it depends on cache backend type. Default value is `DEFAULT_VALUE` \u2013 internal constant means that actually no value is provided to cache backend and thus backend should decide what timeout to use. Callable is also supported.\n* `tags` \u2013 sequence of strings or callable. Should provide or return list of tags added to cached value so cache may be invalidated later with any tag name. Tag may support advanced string formatting syntax. See `cache_key` docs and examples for more details.\n* `prefix` \u2013 this parameter works both: as regular tag and also as cache key prefix, as usual advanced string formatting and callable are supported here.\n* `cache_alias` \u2013 cache backend alias name, it can also be [Django cache backend alias  name](https://docs.djangoproject.com/en/1.10/ref/settings/#std:setting-CACHES).\n* `cache_instance` \u2013 cache backend instance may be provided directly via this parameter.\n\n### ecached_property\n\n Should be used to create so-called cached properties, has signature exactly the same as for `ecached`.\n\n## Simple examples\n\nCode examples is the best way to show the power of this package.\n\n### Decorators can be simply used with default parameters only\n\n```python\nfrom easy_cache import ecached, create_cache_key\n\n# default parameters\n# cache key will be generated automatically:\n#\n# <__module__>.<__class__>.<function name> + function parameters converted to strings,\n#\n# so be careful when using complex objects, it's\n# better to write custom cache key generator in such cases.\n#\n# timeout will be default for specified cache backend\n# \"default\" cache backend will be used if you use Django\n@ecached()\ndef time_consuming_operation(*args, **kwargs):\n    pass\n\n# simple static cache key and cache timeout 100 seconds\n@ecached('time_consuming_operation', 100)\ndef time_consuming_operation():\n    pass\n\n# cache key with advanced string formatting syntax\n@ecached('my_key:{b}:{d}:{c}')\ndef time_consuming_operation(a, b, c=100, d='foo'):\n    pass\n\n# or\n@ecached('key:{kwargs[param1]}:{kwargs[param2]}:{args[0]}')\ndef time_consuming_operation(*args, **kwargs):\n    pass\n\n# use specific cache alias, see \"caches framework\" below\nfrom functools import partial\n\nmemcached = partial(ecached, cache_alias='memcached')\n\n# equivalent to cache_key='{a}:{b}'\n@memcached(['a', 'b'], timeout=600)\ndef time_consuming_operation(a, b, c='default'):\n    pass\n```\n\n### Using custom cache key generators\n\n```python\n# working with parameters provided to cached function\n# cache key generator must have the same signature as decorated function\nfrom easy_cache import create_cache_key\n\ndef custom_cache_key(self, a, b, c, d):\n    return create_cache_key(self.id, a, d)\n\n# working with `meta` object\ndef custom_cache_key_meta(meta):\n    return '{}:{}:{}'.format(meta['self'].id, meta['a'], meta['d'])\n\n# or equivalent\nfrom easy_cache import meta_accepted\n\n@meta_accepted\ndef custom_cache_key_meta(parameter_with_any_name):\n    meta = parameter_with_any_name\n    return '{}:{}:{}'.format(meta['self'].id, meta['a'], meta['d'])\n\n\nclass A(object):\n    id = 1\n\n    @ecached(custom_cache_key)\n    def time_consuming_operation(self, a, b, c=10, d=20):\n        ...\n\n    @ecached(custom_cache_key_meta)\n    def time_consuming_operation(self, a, b, c=10, d=20):\n        ...\n```\n\n### How to cache `staticmethod` and `classmethod` correctly\n\n```python\n# ecached decorator always comes topmost\nclass B(object):\n\n    # cache only for each different year\n    @ecached(lambda start_date: 'get_list:{}'.format(start_date.year))\n    @staticmethod\n    def get_list_by_date(start_date):\n        ...\n\n    CONST = 'abc'\n\n    @ecached('info_cache:{cls.CONST}', 3600, cache_alias='redis_cache')\n    @classmethod\n    def get_info(cls):\n        ...\n```\n\n### MetaCallable object description\n\nMeta object has the following parameters:\n\n* `args` \u2013 tuple with positional arguments provided to decorated function\n* `kwargs` \u2013 dictionary with keyword arguments provided to decorated function\n* `returned_value` \u2013 value returned from decorated function, available only when meta object is handled in `tags` or `prefix` generators. You have to check `has_returned_value` property before using this parameter:\n\n ```python\n def generate_cache_key(meta):\n     if meta.has_returned_value:\n         # ... do something with meta.returned_value ...\n ```\n\n* `call_args` - dictionary with all positional and keyword arguments provided\n to decorated function, you may also access them via `__getitem__` dict interface, e. g. `meta['param1']`.\n* `function` - decorated callable\n* `scope` - object to which decorated callable is attached, `None` otherwise. Usually it's an instance or a class.\n\n### Tags invalidation, refresh and cached properties\n\nTags-based cache invalidation allows you to invalidate several cache keys at once.\n\nImagine you created a web-based book store and your users can mark a book as liked, so you need to maintain a list of liked books for every user but, an information about a book may contain a lot of different data, e.g. authors names, rating, availability in stock, some data from external services and so on.\n\nSome of this information can be calculated on runtime only so you decided to cache the list of liked books.\n\nBut what if a book title was updated and we have to find all cache keys where this book is stored and invalidate them. Such task may be pretty complex to complete, however if you tagged all the necessary cache keys with a specific tag you will just need to invalidate the tag only and related cache keys will be invalidated \"automatically\".\n\nHere are more complex examples introducing Django models and effective tags usage.\nCheck code comments and doc-strings for detailed description.\n\n```python\nfrom django.db import models\nfrom easy_cache import ecached, ecached_property, create_cache_key\n\n\nclass Book(models.Model):\n    title = models.CharField(max_length=250)\n\n    def __unicode__(self):\n        return self.title\n\n\nclass User(models.Model):\n    name = models.CharField(max_length=100)\n    state = models.CharField(\n        max_length=15,\n        choices=(('active', 'active'), ('deleted', 'deleted')),\n    )\n    friends = models.ManyToManyField('self', symmetrical=True)\n    favorite_books = models.ManyToManyField('Book')\n\n    def __unicode__(self):\n        return self.name\n\n    @ecached('users_by_state:{state}', 60, tags=['users_by_states'])\n    @classmethod\n    def get_users_by_state(cls, state):\n        \"\"\"\n        Caches user list by provided state parameter: there will be separate\n        cached value for every different state parameter, so we are having 2 different\n        cache keys:\n\n        users_by_state:active \u2013 cached list of active users\n        users_by_state:deleted \u2013 cached list of deleted users\n\n        Note that `ecached` decorator always comes topmost.\n\n        To invalidate concrete cached state call the following method\n        with the required `state`, e.g.:\n        >>> User.get_users_by_state.invalidate_cache_by_key('active')\n        ... removes `users_by_state:active` cache key\n        or\n        >>> User.get_users_by_state.invalidate_cache_by_key(state='deleted')\n        ... removes `users_by_state:deleted` cache key\n\n        If you'd like to invalidate all caches for all states call:\n        >>> User.get_users_by_state.invalidate_cache_by_tags('users_by_states')\n        ... removes both keys, since `users_by_states` tag attached to all of them,\n\n        `invalidate_cache_by_tags` supports both string and list parameter types:\n        >>> invalidate_cache_by_tags(['tag1', 'tag2', 'tag3'])\n\n        To refresh concrete cached state call the following method\n        with required `state`, e.g:\n        >>> User.get_users_by_state.refresh_cache('active')\n        ... calls `get_users_by_state('active')` and saves returned value to cache\n        or\n        >>> User.get_users_by_state.refresh_cache(state='deleted')\n\n        \"\"\"\n        return list(cls.objects.filter(state=state))\n\n    @ecached_property('user_friends_count:{self.id}', timeout=3600)\n    def friends_count(self):\n        \"\"\"\n        Caches friends count of each user for 1 hour.\n\n        To access cache invalidation functions for a property you\n        have to use class object instead of instance.\n\n        Call the following method, to invalidate cache:\n        >>> User.friends_count.invalidate_cache_by_key(user)\n        ... removes cache key `user_friends_count:{user.id}`\n        or\n        >>> type(self).friends_count.invalidate_cache_by_key(user)\n        or\n        >>> self.__class__.friends_count.invalidate_cache_by_key(user)\n\n        Where `user` is desired User instance to invalidate friends count for.\n\n        Call the following method, to refresh cached data:\n        >>> User.friends_count.refresh_cache(user)\n        ... Updates `user.friends_count` in a cache.\n        or\n        >>> type(self).friends_count.refresh_cache(user)\n        or\n        >>> self.__class__.friends_count.refresh_cache(user)\n        \"\"\"\n        return self.friends.count()\n\n    @staticmethod\n    def get_books_tags(meta):\n        \"\"\"\n        Add one tag for every book in list of favorite books.\n        So we will add a list of tags to cached favorite books list.\n        \"\"\"\n        if not meta.has_returned_value:\n            return []\n\n        favorite_books = meta.returned_value\n        # yes, it may occupy a lot of cache keys\n        return [create_cache_key('book', book.pk) for book in favorite_books]\n\n    @ecached('user_favorite_books:{self.id}', 600, get_books_tags)\n    def get_favorite_books(self):\n        \"\"\"\n        Caches list of related books by user id. So in code you will use:\n\n        >>> favorite_books = request.user.get_favorite_books() # cached for user\n\n        You may want to invalidate this cache in two cases:\n\n        1. User added new book to favorites:\n\n        >>> User.get_favorite_books.invalidate_cache_by_key(user)\n        or\n        >>> User.get_favorite_books.invalidate_cache_by_key(self=user)\n        or\n        >>> from easy_cache import invalidate_cache_key, create_cache_key\n        >>> invalidate_cache_key(create_cache_key('user_favorite_books', user.id))\n        or\n        >>> invalidate_cache_key('user_favorite_books:{}'.format(user.id))\n\n        2. Some information about favorite book was changed, e.g. its title:\n        >>> from easy_cache import invalidate_cache_tags, create_tag_cache_key\n        >>> tag_cache_key = create_tag_cache_key('book', changed_book_id)\n        >>> User.get_favorite_books.invalidate_cache_by_tags(tag_cache_key)\n        or\n        >>> invalidate_cache_tags(tag_cache_key)\n\n        To refresh cached values use the following patterns:\n        >>> User.get_favorite_books.refresh_cache(user)\n        or\n        >>> User.get_favorite_books.refresh_cache(self=user)\n        \"\"\"\n        return self.favorite_books.filter(user=self)\n```\n\n## Prefix usage\n\nCommonly `prefix` is used to invalidate all cache-keys in one namespace, e. g.:\n\n```python\nfrom functools import partial\n\nclass Shop(models.Model):\n    single_shop_cache = partial(ecached, prefix='shop:{self.id}')\n\n    @single_shop_cache('goods_list')\n    def get_all_goods_list(self):\n        return [...]\n\n    @single_shop_cache('prices_list')\n    def get_all_prices_list(self):\n        return [...]\n\n# if you have `shop` object you are able to use the following invalidation\n# strategies:\n\n# Invalidate cached list of goods for concrete shop\nShop.get_all_goods_list.invalidate_cache_by_key(shop)\n\n# Refresh cached list of goods for concrete shop\nShop.get_all_goods_list.refresh_cache(shop)\n\n# Invalidate cached list of prices for concrete shop\nShop.get_all_prices_list.invalidate_cache_by_key(shop)\n\n# Refresh cached list of prices for concrete shop\nShop.get_all_prices_list.refresh_cache(shop)\n\n# Invalidate all cached items for concrete shop\nShop.get_all_goods_list.invalidate_cache_by_prefix(shop)\n# or\nShop.get_all_prices_list.invalidate_cache_by_prefix(shop)\n# or\nfrom easy_cache import invalidate_cache_prefix\ninvalidate_cache_prefix('shop:{self.id}'.format(self=shop))\n```\n\n## Invalidation summary\n\nThere are two ways to invalidate cache objects: use invalidation methods bound to decorated function and separate functions-invalidators.\n\n```python\n<decorated>.invalidate_cache_by_key(*args, **kwargs)\n<decorated>.invalidate_cache_by_tags(tags=(), *args, **kwargs)\n<decorated>.invalidate_cache_by_prefix(*args, **kwargs)\n\n# <decorated> should be used with a class instance if it is used in a class namespace:\nclass A:\n    id = 1\n\n    @ecached()\n    def method(self):\n        pass\n\n    @ecached_property()\n    def obj_property(self):\n        pass\n\n    @ecached_property('{self.id}:hello')\n    def world(self):\n        return '<timeconsuming>'\n\nA.method.invalidate_cache_by_key()\n# or\nA().method.invalidate_cache_by_key()\n# only one variant is possible for a properties\nA.obj_property.invalidate_cache_by_key()\n# and\nitem = A()\nA.world.invalidate_cache_by_key(item)\n\n# and\nfrom easy_cache import (\n    invalidate_cache_key,\n    invalidate_cache_tags,\n    invalidate_cache_prefix,\n    create_cache_key,\n)\n\n# Note that `cache_instance` and `cache_alias` may be passed\n# to the following invalidators\ninvalidate_cache_key(cache_key)\ninvalidate_cache_tags(tags)\ninvalidate_cache_prefix(prefix)\n```\n\nHere `tags` can be a string (single tag) or a list of tags. Bound methods should be provided with parameters if they are used in cache key/tag/prefix:\n\n```python\n@ecached('key:{a}:value:{c}', tags=['tag:{a}'], prefix='pre:{b}', cache_alias='memcached')\ndef time_consuming_operation(a, b, c=100):\n    pass\n\ntime_consuming_operation.invalidate_cache_by_key(a=1, c=11)\ntime_consuming_operation.invalidate_cache_by_tags(a=10)\ntime_consuming_operation.invalidate_cache_by_prefix(b=2)\n\n# or using `create_cache_key` helper\ninvalidate_cache_key(\n    create_cache_key('key', 1, 'value', 11), cache_alias='memcached'\n)\ninvalidate_cache_tags(create_cache_key('tag', 10), cache_alias='memcached')\ninvalidate_cache_prefix('pre:{}'.format(2), cache_alias='memcached')\n```\n\n## Refresh summary\n\nThere is one way to refresh cache objects: use refresh methods bound to decorated function.\n\n```python\n<decorated>.refresh_cache(*args, **kwargs)\n\n# <decorated> should be used with class instance if it is used in class namespace:\nclass A:\n    @ecached()\n    def method(self):\n        pass\n\n    @ecached_property()\n    def obj_property(self):\n        pass\n\nA.method.refresh_cache()\nA.obj_property.refresh_cache()\n```\n\n## Internal caches framework\n\nBe aware: internal cache framework instance is single threaded, so if you add new cache instance in a one thread it won't appear in another.\n\nEasy-cache uses build-in Django cache framework by default, so you can choose what cache storage to use on every decorated function, e.g.:\n\n```python\n# Django settings\nCACHES={\n    'local_memory': {\n        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n        'LOCATION': 'locmem',\n        'KEY_PREFIX': 'custom_prefix',\n    },\n    'memcached': {\n        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',\n        'LOCATION': '127.0.0.1:11211',\n        'KEY_PREFIX': 'memcached',\n    }\n}\n\n# then in somewhere code\n@ecached(..., cache_alias='memcached')\n# or\n@ecached(..., cache_alias='local_memory')\n# or even\nfrom django.core.cache import caches\nanother_cache = caches['another_cache']\n@ecached(..., cache_instance=another_cache)\n```\n\nHowever if you don't use Django, there is cache framework built into easy-cache package, it can be used in the same fashion as Django caches:\n\n```python\n# Custom cache instance class must implement AbstractCacheInstance interface:\nfrom easy_cache.abc import AbstractCacheInstance\nfrom easy_cache.core import DEFAULT_TIMEOUT, NOT_FOUND\n\nclass CustomCache(AbstractCacheInstance):\n\n    def get(self, key, default=NOT_FOUND):\n        ...\n\n    def get_many(self, keys):\n        ...\n\n    def set(self, key, value, timeout=DEFAULT_TIMEOUT):\n        ...\n\n    def set_many(self, data_dict, timeout=DEFAULT_TIMEOUT):\n        ...\n\n    def delete(self, key):\n        ...\n\nfrom easy_cache import caches\n\ncustom_cache = CustomCache()\ncaches['new_cache'] = custom_cache\ncaches.set_default(CustomCacheDefault())\n\n# and then\n@ecached(..., cache_alias='new_cache')\n# or\n@ecached(..., cache_instance=custom_cache)\n# will use `default` alias\n@ecached(...)\n```\n\nThere is already implemented redis cache instance class, based on [redis-py client](https://pypi.python.org/pypi/redis):\n\n```python\nfrom redis import StrictRedis\nfrom easy_cache.contrib.redis_cache import RedisCacheInstance\nfrom easy_cache import caches\n\nredis_cache = RedisCacheInstance(StrictRedis(host='...', port='...'))\ncaches.set_default(redis_cache)\n\n# will use `default` alias\n@ecached(...)\n```\n\n## Dynamic timeout example\n\nYou may need to provide cache timeout dynamically depending on function parameters:\n\n```python\ndef dynamic_timeout(group):\n    if group == 'admins':\n        timeout = 10\n    else:\n        timeout = 100\n    return timeout\n\n@ecached('key:{group}', timeout=dynamic_timeout)\ndef get_users_by_group(group):\n    ...\n```\n\n## Development and contribution\n\nLive instances of Redis and Memcached are required for few tests to pass, so it's recommended to use docker/docker-compose to setup the necessary environment:\n\n```shell\ndocker-compose up -d\n\n# to enable debug logs\n# export EASY_CACHE_DEBUG=\"yes\"\n\n# install package locally\npip install -e .[tests]\n\n# run tests with pytest or tox\npytest\ntox\n```\n\n## Performance and overhead\n\nBenchmarking may be executed with `tox` command and it shows that decorators give about 4% of overhead in worst case and about 1-2% overhead on the average.\n\nIf you don't use tags or prefix you will get one cache request for `get` and one request for `set` if result not found in cache, otherwise two consecutive requests will be made: `get` and `get_many` to receive actual value from cache and validate its tags (prefix). Then one `set_many` request will be performed to save a data to cache storage.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Bahus/easy_cache", "keywords": "cache,decorator,invalidation,memcached,redis,django", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "easy-cache", "package_url": "https://pypi.org/project/easy-cache/", "platform": "Platform Independent", "project_url": "https://pypi.org/project/easy-cache/", "project_urls": {"Homepage": "https://github.com/Bahus/easy_cache"}, "release_url": "https://pypi.org/project/easy-cache/1.1.0/", "requires_dist": ["six", "pytest ; extra == 'tests'", "Django ; extra == 'tests'", "django-redis ; extra == 'tests'", "memory-profiler ; extra == 'tests'", "mock ; extra == 'tests'", "psutil ; extra == 'tests'", "python-memcached ; extra == 'tests'", "redis ; extra == 'tests'", "pylibmc ; extra == 'tests'", "tox-pyenv ; extra == 'tests'"], "requires_python": "", "summary": "Useful cache decorators for methods and properties", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Easy caching decorators</h1>\n<p><a href=\"https://travis-ci.org/Bahus/easy_cache\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d3949f6d335a289b4ddb1f1244f459880483fa1d/68747470733a2f2f7472617669732d63692e6f72672f42616875732f656173795f63616368652e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>This package is intended to simplify caching and invalidation process in python-based (primarily) web applications. It's possible to cache execution results of functions; <strong>instance</strong>, <strong>class</strong> and <strong>static</strong> methods; properties. Cache keys may be constructed in various different ways and may depend on any number of parameters.</p>\n<p>The package supports tag-based cache invalidation and better works with Django, however any other frameworks can be used \u2013 see examples below.</p>\n<p>The main idea of this package: you don't need to touch any existing function code to cache its execution results.</p>\n<h2>Requirements</h2>\n<p>Library was tested in the following environments:</p>\n<ul>\n<li>Python 2.7, 3.5, 3.6</li>\n<li>Django 1.8, 1.11, &gt;=2.0.0</li>\n</ul>\n<p>Feel free to try it in yours, but it's not guaranteed it will work. Submit an issue if you think it should.</p>\n<h2>Installation</h2>\n<pre>pip install easy_cache\n</pre>\n<h2>Introduction</h2>\n<h3>Different ways to cache something</h3>\n<p>Imagine you have a time consuming function and you need to cache an execution results, the classic way to achieve this is the next one:</p>\n<pre><span class=\"c1\"># classic way</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.core.cache</span> <span class=\"kn\">import</span> <span class=\"n\">cache</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Calculate sum of number from 1 to provided n\"\"\"</span>\n    <span class=\"n\">cache_key</span> <span class=\"o\">=</span> <span class=\"s1\">'time_consuming_operation_</span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">cache_key</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">result</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"c1\"># not found in cache</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n        <span class=\"c1\"># cache result for one hour</span>\n        <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">cache_key</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"mi\">3600</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">result</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">invalidate_cache</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"n\">delete</span><span class=\"p\">(</span><span class=\"s1\">'time_consuming_operation_</span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">))</span>\n</pre>\n<p>Well, we had to add annoying boilerplate code to achieve this.\nNow let's take a look how <code>easy_cache</code> can avoid the problem and simplify the code:</p>\n<pre><span class=\"c1\"># easy way</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"n\">ecached</span>\n\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'time_consuming_operation_</span><span class=\"si\">{n}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"mi\">3600</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">invalidate_cache</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"n\">time_consuming_operation</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>As we can see the function code left clear.\nHeart of the package is two decorators with the similar parameters:</p>\n<h3>ecached</h3>\n<p>Should be used to decorate any callable and cache returned result.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>cache_key</code> \u2013 cache key generator, default value is <code>None</code> so the key will be composed automatically based on a function name, namespace and passed parameters. Also the following types are supported:\n<ul>\n<li><strong>string</strong> \u2013 may contain <a href=\"https://docs.python.org/2/library/string.html#formatstrings\" rel=\"nofollow\">Python advanced string formatting syntax</a>, a given value will be formatted with a dict of parameters passed to decorated function, see examples below.</li>\n<li><strong>sequence of strings</strong> \u2013 each string must be function parameter name.</li>\n<li><strong>callable</strong> \u2013 is used to generate cache key, decorated function parameters will be passed to this callable and returned value will be used as a cache key. Also one additional signature is available: <code>callable(meta)</code>, where <code>meta</code> is a dict-like object with some additional attributes \u2013 see below.</li>\n</ul>\n</li>\n<li><code>timeout</code> \u2013 value will be cached with provided timeout, basically it should be number of seconds, however it depends on cache backend type. Default value is <code>DEFAULT_VALUE</code> \u2013 internal constant means that actually no value is provided to cache backend and thus backend should decide what timeout to use. Callable is also supported.</li>\n<li><code>tags</code> \u2013 sequence of strings or callable. Should provide or return list of tags added to cached value so cache may be invalidated later with any tag name. Tag may support advanced string formatting syntax. See <code>cache_key</code> docs and examples for more details.</li>\n<li><code>prefix</code> \u2013 this parameter works both: as regular tag and also as cache key prefix, as usual advanced string formatting and callable are supported here.</li>\n<li><code>cache_alias</code> \u2013 cache backend alias name, it can also be <a href=\"https://docs.djangoproject.com/en/1.10/ref/settings/#std:setting-CACHES\" rel=\"nofollow\">Django cache backend alias  name</a>.</li>\n<li><code>cache_instance</code> \u2013 cache backend instance may be provided directly via this parameter.</li>\n</ul>\n<h3>ecached_property</h3>\n<p>Should be used to create so-called cached properties, has signature exactly the same as for <code>ecached</code>.</p>\n<h2>Simple examples</h2>\n<p>Code examples is the best way to show the power of this package.</p>\n<h3>Decorators can be simply used with default parameters only</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"n\">ecached</span><span class=\"p\">,</span> <span class=\"n\">create_cache_key</span>\n\n<span class=\"c1\"># default parameters</span>\n<span class=\"c1\"># cache key will be generated automatically:</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># &lt;__module__&gt;.&lt;__class__&gt;.&lt;function name&gt; + function parameters converted to strings,</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># so be careful when using complex objects, it's</span>\n<span class=\"c1\"># better to write custom cache key generator in such cases.</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># timeout will be default for specified cache backend</span>\n<span class=\"c1\"># \"default\" cache backend will be used if you use Django</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"c1\"># simple static cache key and cache timeout 100 seconds</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'time_consuming_operation'</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">():</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"c1\"># cache key with advanced string formatting syntax</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'my_key:</span><span class=\"si\">{b}</span><span class=\"s1\">:</span><span class=\"si\">{d}</span><span class=\"s1\">:</span><span class=\"si\">{c}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"s1\">'foo'</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"c1\"># or</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'key:</span><span class=\"si\">{kwargs[param1]}</span><span class=\"s1\">:</span><span class=\"si\">{kwargs[param2]}</span><span class=\"s1\">:</span><span class=\"si\">{args[0]}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"c1\"># use specific cache alias, see \"caches framework\" below</span>\n<span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">partial</span>\n\n<span class=\"n\">memcached</span> <span class=\"o\">=</span> <span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">ecached</span><span class=\"p\">,</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'memcached'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># equivalent to cache_key='{a}:{b}'</span>\n<span class=\"nd\">@memcached</span><span class=\"p\">([</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">],</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">600</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"s1\">'default'</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre>\n<h3>Using custom cache key generators</h3>\n<pre><span class=\"c1\"># working with parameters provided to cached function</span>\n<span class=\"c1\"># cache key generator must have the same signature as decorated function</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"n\">create_cache_key</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">custom_cache_key</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">create_cache_key</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># working with `meta` object</span>\n<span class=\"k\">def</span> <span class=\"nf\">custom_cache_key_meta</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'</span><span class=\"si\">{}</span><span class=\"s1\">:</span><span class=\"si\">{}</span><span class=\"s1\">:</span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">[</span><span class=\"s1\">'self'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">meta</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">],</span> <span class=\"n\">meta</span><span class=\"p\">[</span><span class=\"s1\">'d'</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># or equivalent</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"n\">meta_accepted</span>\n\n<span class=\"nd\">@meta_accepted</span>\n<span class=\"k\">def</span> <span class=\"nf\">custom_cache_key_meta</span><span class=\"p\">(</span><span class=\"n\">parameter_with_any_name</span><span class=\"p\">):</span>\n    <span class=\"n\">meta</span> <span class=\"o\">=</span> <span class=\"n\">parameter_with_any_name</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'</span><span class=\"si\">{}</span><span class=\"s1\">:</span><span class=\"si\">{}</span><span class=\"s1\">:</span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">[</span><span class=\"s1\">'self'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">meta</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">],</span> <span class=\"n\">meta</span><span class=\"p\">[</span><span class=\"s1\">'d'</span><span class=\"p\">])</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">A</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"nb\">id</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"n\">custom_cache_key</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"mi\">20</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n\n    <span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"n\">custom_cache_key_meta</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"mi\">20</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n</pre>\n<h3>How to cache <code>staticmethod</code> and <code>classmethod</code> correctly</h3>\n<pre><span class=\"c1\"># ecached decorator always comes topmost</span>\n<span class=\"k\">class</span> <span class=\"nc\">B</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n\n    <span class=\"c1\"># cache only for each different year</span>\n    <span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"s1\">'get_list:</span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">start_date</span><span class=\"o\">.</span><span class=\"n\">year</span><span class=\"p\">))</span>\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_list_by_date</span><span class=\"p\">(</span><span class=\"n\">start_date</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n\n    <span class=\"n\">CONST</span> <span class=\"o\">=</span> <span class=\"s1\">'abc'</span>\n\n    <span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'info_cache:</span><span class=\"si\">{cls.CONST}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"mi\">3600</span><span class=\"p\">,</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'redis_cache'</span><span class=\"p\">)</span>\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_info</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n</pre>\n<h3>MetaCallable object description</h3>\n<p>Meta object has the following parameters:</p>\n<ul>\n<li><code>args</code> \u2013 tuple with positional arguments provided to decorated function</li>\n<li><code>kwargs</code> \u2013 dictionary with keyword arguments provided to decorated function</li>\n<li><code>returned_value</code> \u2013 value returned from decorated function, available only when meta object is handled in <code>tags</code> or <code>prefix</code> generators. You have to check <code>has_returned_value</code> property before using this parameter:</li>\n</ul>\n<pre><span class=\"k\">def</span> <span class=\"nf\">generate_cache_key</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">meta</span><span class=\"o\">.</span><span class=\"n\">has_returned_value</span><span class=\"p\">:</span>\n        <span class=\"c1\"># ... do something with meta.returned_value ...</span>\n</pre>\n<ul>\n<li><code>call_args</code> - dictionary with all positional and keyword arguments provided\nto decorated function, you may also access them via <code>__getitem__</code> dict interface, e. g. <code>meta['param1']</code>.</li>\n<li><code>function</code> - decorated callable</li>\n<li><code>scope</code> - object to which decorated callable is attached, <code>None</code> otherwise. Usually it's an instance or a class.</li>\n</ul>\n<h3>Tags invalidation, refresh and cached properties</h3>\n<p>Tags-based cache invalidation allows you to invalidate several cache keys at once.</p>\n<p>Imagine you created a web-based book store and your users can mark a book as liked, so you need to maintain a list of liked books for every user but, an information about a book may contain a lot of different data, e.g. authors names, rating, availability in stock, some data from external services and so on.</p>\n<p>Some of this information can be calculated on runtime only so you decided to cache the list of liked books.</p>\n<p>But what if a book title was updated and we have to find all cache keys where this book is stored and invalidate them. Such task may be pretty complex to complete, however if you tagged all the necessary cache keys with a specific tag you will just need to invalidate the tag only and related cache keys will be invalidated \"automatically\".</p>\n<p>Here are more complex examples introducing Django models and effective tags usage.\nCheck code comments and doc-strings for detailed description.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"n\">ecached</span><span class=\"p\">,</span> <span class=\"n\">ecached_property</span><span class=\"p\">,</span> <span class=\"n\">create_cache_key</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Book</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">250</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__unicode__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">title</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">User</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"n\">state</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span>\n        <span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">15</span><span class=\"p\">,</span>\n        <span class=\"n\">choices</span><span class=\"o\">=</span><span class=\"p\">((</span><span class=\"s1\">'active'</span><span class=\"p\">,</span> <span class=\"s1\">'active'</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s1\">'deleted'</span><span class=\"p\">,</span> <span class=\"s1\">'deleted'</span><span class=\"p\">)),</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">friends</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ManyToManyField</span><span class=\"p\">(</span><span class=\"s1\">'self'</span><span class=\"p\">,</span> <span class=\"n\">symmetrical</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">favorite_books</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ManyToManyField</span><span class=\"p\">(</span><span class=\"s1\">'Book'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__unicode__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span>\n\n    <span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'users_by_state:</span><span class=\"si\">{state}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"n\">tags</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'users_by_states'</span><span class=\"p\">])</span>\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_users_by_state</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">state</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Caches user list by provided state parameter: there will be separate</span>\n<span class=\"sd\">        cached value for every different state parameter, so we are having 2 different</span>\n<span class=\"sd\">        cache keys:</span>\n\n<span class=\"sd\">        users_by_state:active \u2013 cached list of active users</span>\n<span class=\"sd\">        users_by_state:deleted \u2013 cached list of deleted users</span>\n\n<span class=\"sd\">        Note that `ecached` decorator always comes topmost.</span>\n\n<span class=\"sd\">        To invalidate concrete cached state call the following method</span>\n<span class=\"sd\">        with the required `state`, e.g.:</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_users_by_state.invalidate_cache_by_key('active')</span>\n<span class=\"sd\">        ... removes `users_by_state:active` cache key</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_users_by_state.invalidate_cache_by_key(state='deleted')</span>\n<span class=\"sd\">        ... removes `users_by_state:deleted` cache key</span>\n\n<span class=\"sd\">        If you'd like to invalidate all caches for all states call:</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_users_by_state.invalidate_cache_by_tags('users_by_states')</span>\n<span class=\"sd\">        ... removes both keys, since `users_by_states` tag attached to all of them,</span>\n\n<span class=\"sd\">        `invalidate_cache_by_tags` supports both string and list parameter types:</span>\n<span class=\"sd\">        &gt;&gt;&gt; invalidate_cache_by_tags(['tag1', 'tag2', 'tag3'])</span>\n\n<span class=\"sd\">        To refresh concrete cached state call the following method</span>\n<span class=\"sd\">        with required `state`, e.g:</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_users_by_state.refresh_cache('active')</span>\n<span class=\"sd\">        ... calls `get_users_by_state('active')` and saves returned value to cache</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_users_by_state.refresh_cache(state='deleted')</span>\n\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"k\">return</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">state</span><span class=\"o\">=</span><span class=\"n\">state</span><span class=\"p\">))</span>\n\n    <span class=\"nd\">@ecached_property</span><span class=\"p\">(</span><span class=\"s1\">'user_friends_count:</span><span class=\"si\">{self.id}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">3600</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">friends_count</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Caches friends count of each user for 1 hour.</span>\n\n<span class=\"sd\">        To access cache invalidation functions for a property you</span>\n<span class=\"sd\">        have to use class object instead of instance.</span>\n\n<span class=\"sd\">        Call the following method, to invalidate cache:</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.friends_count.invalidate_cache_by_key(user)</span>\n<span class=\"sd\">        ... removes cache key `user_friends_count:{user.id}`</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; type(self).friends_count.invalidate_cache_by_key(user)</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; self.__class__.friends_count.invalidate_cache_by_key(user)</span>\n\n<span class=\"sd\">        Where `user` is desired User instance to invalidate friends count for.</span>\n\n<span class=\"sd\">        Call the following method, to refresh cached data:</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.friends_count.refresh_cache(user)</span>\n<span class=\"sd\">        ... Updates `user.friends_count` in a cache.</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; type(self).friends_count.refresh_cache(user)</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; self.__class__.friends_count.refresh_cache(user)</span>\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">friends</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_books_tags</span><span class=\"p\">(</span><span class=\"n\">meta</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Add one tag for every book in list of favorite books.</span>\n<span class=\"sd\">        So we will add a list of tags to cached favorite books list.</span>\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">meta</span><span class=\"o\">.</span><span class=\"n\">has_returned_value</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">[]</span>\n\n        <span class=\"n\">favorite_books</span> <span class=\"o\">=</span> <span class=\"n\">meta</span><span class=\"o\">.</span><span class=\"n\">returned_value</span>\n        <span class=\"c1\"># yes, it may occupy a lot of cache keys</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">create_cache_key</span><span class=\"p\">(</span><span class=\"s1\">'book'</span><span class=\"p\">,</span> <span class=\"n\">book</span><span class=\"o\">.</span><span class=\"n\">pk</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">book</span> <span class=\"ow\">in</span> <span class=\"n\">favorite_books</span><span class=\"p\">]</span>\n\n    <span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'user_favorite_books:</span><span class=\"si\">{self.id}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"n\">get_books_tags</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_favorite_books</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Caches list of related books by user id. So in code you will use:</span>\n\n<span class=\"sd\">        &gt;&gt;&gt; favorite_books = request.user.get_favorite_books() # cached for user</span>\n\n<span class=\"sd\">        You may want to invalidate this cache in two cases:</span>\n\n<span class=\"sd\">        1. User added new book to favorites:</span>\n\n<span class=\"sd\">        &gt;&gt;&gt; User.get_favorite_books.invalidate_cache_by_key(user)</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_favorite_books.invalidate_cache_by_key(self=user)</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; from easy_cache import invalidate_cache_key, create_cache_key</span>\n<span class=\"sd\">        &gt;&gt;&gt; invalidate_cache_key(create_cache_key('user_favorite_books', user.id))</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; invalidate_cache_key('user_favorite_books:{}'.format(user.id))</span>\n\n<span class=\"sd\">        2. Some information about favorite book was changed, e.g. its title:</span>\n<span class=\"sd\">        &gt;&gt;&gt; from easy_cache import invalidate_cache_tags, create_tag_cache_key</span>\n<span class=\"sd\">        &gt;&gt;&gt; tag_cache_key = create_tag_cache_key('book', changed_book_id)</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_favorite_books.invalidate_cache_by_tags(tag_cache_key)</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; invalidate_cache_tags(tag_cache_key)</span>\n\n<span class=\"sd\">        To refresh cached values use the following patterns:</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_favorite_books.refresh_cache(user)</span>\n<span class=\"sd\">        or</span>\n<span class=\"sd\">        &gt;&gt;&gt; User.get_favorite_books.refresh_cache(self=user)</span>\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">favorite_books</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n</pre>\n<h2>Prefix usage</h2>\n<p>Commonly <code>prefix</code> is used to invalidate all cache-keys in one namespace, e. g.:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">partial</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Shop</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">single_shop_cache</span> <span class=\"o\">=</span> <span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">ecached</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'shop:</span><span class=\"si\">{self.id}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@single_shop_cache</span><span class=\"p\">(</span><span class=\"s1\">'goods_list'</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_all_goods_list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"o\">...</span><span class=\"p\">]</span>\n\n    <span class=\"nd\">@single_shop_cache</span><span class=\"p\">(</span><span class=\"s1\">'prices_list'</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_all_prices_list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"o\">...</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># if you have `shop` object you are able to use the following invalidation</span>\n<span class=\"c1\"># strategies:</span>\n\n<span class=\"c1\"># Invalidate cached list of goods for concrete shop</span>\n<span class=\"n\">Shop</span><span class=\"o\">.</span><span class=\"n\">get_all_goods_list</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">(</span><span class=\"n\">shop</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Refresh cached list of goods for concrete shop</span>\n<span class=\"n\">Shop</span><span class=\"o\">.</span><span class=\"n\">get_all_goods_list</span><span class=\"o\">.</span><span class=\"n\">refresh_cache</span><span class=\"p\">(</span><span class=\"n\">shop</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Invalidate cached list of prices for concrete shop</span>\n<span class=\"n\">Shop</span><span class=\"o\">.</span><span class=\"n\">get_all_prices_list</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">(</span><span class=\"n\">shop</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Refresh cached list of prices for concrete shop</span>\n<span class=\"n\">Shop</span><span class=\"o\">.</span><span class=\"n\">get_all_prices_list</span><span class=\"o\">.</span><span class=\"n\">refresh_cache</span><span class=\"p\">(</span><span class=\"n\">shop</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Invalidate all cached items for concrete shop</span>\n<span class=\"n\">Shop</span><span class=\"o\">.</span><span class=\"n\">get_all_goods_list</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_prefix</span><span class=\"p\">(</span><span class=\"n\">shop</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"n\">Shop</span><span class=\"o\">.</span><span class=\"n\">get_all_prices_list</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_prefix</span><span class=\"p\">(</span><span class=\"n\">shop</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"n\">invalidate_cache_prefix</span>\n<span class=\"n\">invalidate_cache_prefix</span><span class=\"p\">(</span><span class=\"s1\">'shop:</span><span class=\"si\">{self.id}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">=</span><span class=\"n\">shop</span><span class=\"p\">))</span>\n</pre>\n<h2>Invalidation summary</h2>\n<p>There are two ways to invalidate cache objects: use invalidation methods bound to decorated function and separate functions-invalidators.</p>\n<pre><span class=\"o\">&lt;</span><span class=\"n\">decorated</span><span class=\"o\">&gt;.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">decorated</span><span class=\"o\">&gt;.</span><span class=\"n\">invalidate_cache_by_tags</span><span class=\"p\">(</span><span class=\"n\">tags</span><span class=\"o\">=</span><span class=\"p\">(),</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">decorated</span><span class=\"o\">&gt;.</span><span class=\"n\">invalidate_cache_by_prefix</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># &lt;decorated&gt; should be used with a class instance if it is used in a class namespace:</span>\n<span class=\"k\">class</span> <span class=\"nc\">A</span><span class=\"p\">:</span>\n    <span class=\"nb\">id</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"nd\">@ecached</span><span class=\"p\">()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@ecached_property</span><span class=\"p\">()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">obj_property</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@ecached_property</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"si\">{self.id}</span><span class=\"s1\">:hello'</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">world</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"s1\">'&lt;timeconsuming&gt;'</span>\n\n<span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">method</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">()</span>\n<span class=\"c1\"># or</span>\n<span class=\"n\">A</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">method</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">()</span>\n<span class=\"c1\"># only one variant is possible for a properties</span>\n<span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">obj_property</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">()</span>\n<span class=\"c1\"># and</span>\n<span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"p\">()</span>\n<span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">world</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># and</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">invalidate_cache_key</span><span class=\"p\">,</span>\n    <span class=\"n\">invalidate_cache_tags</span><span class=\"p\">,</span>\n    <span class=\"n\">invalidate_cache_prefix</span><span class=\"p\">,</span>\n    <span class=\"n\">create_cache_key</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Note that `cache_instance` and `cache_alias` may be passed</span>\n<span class=\"c1\"># to the following invalidators</span>\n<span class=\"n\">invalidate_cache_key</span><span class=\"p\">(</span><span class=\"n\">cache_key</span><span class=\"p\">)</span>\n<span class=\"n\">invalidate_cache_tags</span><span class=\"p\">(</span><span class=\"n\">tags</span><span class=\"p\">)</span>\n<span class=\"n\">invalidate_cache_prefix</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">)</span>\n</pre>\n<p>Here <code>tags</code> can be a string (single tag) or a list of tags. Bound methods should be provided with parameters if they are used in cache key/tag/prefix:</p>\n<pre><span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'key:</span><span class=\"si\">{a}</span><span class=\"s1\">:value:</span><span class=\"si\">{c}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">tags</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'tag:</span><span class=\"si\">{a}</span><span class=\"s1\">'</span><span class=\"p\">],</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'pre:</span><span class=\"si\">{b}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'memcached'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">time_consuming_operation</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"n\">time_consuming_operation</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_key</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">11</span><span class=\"p\">)</span>\n<span class=\"n\">time_consuming_operation</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_tags</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">time_consuming_operation</span><span class=\"o\">.</span><span class=\"n\">invalidate_cache_by_prefix</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># or using `create_cache_key` helper</span>\n<span class=\"n\">invalidate_cache_key</span><span class=\"p\">(</span>\n    <span class=\"n\">create_cache_key</span><span class=\"p\">(</span><span class=\"s1\">'key'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'value'</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">),</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'memcached'</span>\n<span class=\"p\">)</span>\n<span class=\"n\">invalidate_cache_tags</span><span class=\"p\">(</span><span class=\"n\">create_cache_key</span><span class=\"p\">(</span><span class=\"s1\">'tag'</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">),</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'memcached'</span><span class=\"p\">)</span>\n<span class=\"n\">invalidate_cache_prefix</span><span class=\"p\">(</span><span class=\"s1\">'pre:</span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'memcached'</span><span class=\"p\">)</span>\n</pre>\n<h2>Refresh summary</h2>\n<p>There is one way to refresh cache objects: use refresh methods bound to decorated function.</p>\n<pre><span class=\"o\">&lt;</span><span class=\"n\">decorated</span><span class=\"o\">&gt;.</span><span class=\"n\">refresh_cache</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># &lt;decorated&gt; should be used with class instance if it is used in class namespace:</span>\n<span class=\"k\">class</span> <span class=\"nc\">A</span><span class=\"p\">:</span>\n    <span class=\"nd\">@ecached</span><span class=\"p\">()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@ecached_property</span><span class=\"p\">()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">obj_property</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n<span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">method</span><span class=\"o\">.</span><span class=\"n\">refresh_cache</span><span class=\"p\">()</span>\n<span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">obj_property</span><span class=\"o\">.</span><span class=\"n\">refresh_cache</span><span class=\"p\">()</span>\n</pre>\n<h2>Internal caches framework</h2>\n<p>Be aware: internal cache framework instance is single threaded, so if you add new cache instance in a one thread it won't appear in another.</p>\n<p>Easy-cache uses build-in Django cache framework by default, so you can choose what cache storage to use on every decorated function, e.g.:</p>\n<pre><span class=\"c1\"># Django settings</span>\n<span class=\"n\">CACHES</span><span class=\"o\">=</span><span class=\"p\">{</span>\n    <span class=\"s1\">'local_memory'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'BACKEND'</span><span class=\"p\">:</span> <span class=\"s1\">'django.core.cache.backends.locmem.LocMemCache'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'LOCATION'</span><span class=\"p\">:</span> <span class=\"s1\">'locmem'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'KEY_PREFIX'</span><span class=\"p\">:</span> <span class=\"s1\">'custom_prefix'</span><span class=\"p\">,</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'memcached'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'BACKEND'</span><span class=\"p\">:</span> <span class=\"s1\">'django.core.cache.backends.memcached.MemcachedCache'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'LOCATION'</span><span class=\"p\">:</span> <span class=\"s1\">'127.0.0.1:11211'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'KEY_PREFIX'</span><span class=\"p\">:</span> <span class=\"s1\">'memcached'</span><span class=\"p\">,</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\"># then in somewhere code</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'memcached'</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'local_memory'</span><span class=\"p\">)</span>\n<span class=\"c1\"># or even</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.core.cache</span> <span class=\"kn\">import</span> <span class=\"n\">caches</span>\n<span class=\"n\">another_cache</span> <span class=\"o\">=</span> <span class=\"n\">caches</span><span class=\"p\">[</span><span class=\"s1\">'another_cache'</span><span class=\"p\">]</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">cache_instance</span><span class=\"o\">=</span><span class=\"n\">another_cache</span><span class=\"p\">)</span>\n</pre>\n<p>However if you don't use Django, there is cache framework built into easy-cache package, it can be used in the same fashion as Django caches:</p>\n<pre><span class=\"c1\"># Custom cache instance class must implement AbstractCacheInstance interface:</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache.abc</span> <span class=\"kn\">import</span> <span class=\"n\">AbstractCacheInstance</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache.core</span> <span class=\"kn\">import</span> <span class=\"n\">DEFAULT_TIMEOUT</span><span class=\"p\">,</span> <span class=\"n\">NOT_FOUND</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">CustomCache</span><span class=\"p\">(</span><span class=\"n\">AbstractCacheInstance</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"n\">NOT_FOUND</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">get_many</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">keys</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"n\">DEFAULT_TIMEOUT</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">set_many</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data_dict</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"n\">DEFAULT_TIMEOUT</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">):</span>\n        <span class=\"o\">...</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"n\">caches</span>\n\n<span class=\"n\">custom_cache</span> <span class=\"o\">=</span> <span class=\"n\">CustomCache</span><span class=\"p\">()</span>\n<span class=\"n\">caches</span><span class=\"p\">[</span><span class=\"s1\">'new_cache'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">custom_cache</span>\n<span class=\"n\">caches</span><span class=\"o\">.</span><span class=\"n\">set_default</span><span class=\"p\">(</span><span class=\"n\">CustomCacheDefault</span><span class=\"p\">())</span>\n\n<span class=\"c1\"># and then</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'new_cache'</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">cache_instance</span><span class=\"o\">=</span><span class=\"n\">custom_cache</span><span class=\"p\">)</span>\n<span class=\"c1\"># will use `default` alias</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>There is already implemented redis cache instance class, based on <a href=\"https://pypi.python.org/pypi/redis\" rel=\"nofollow\">redis-py client</a>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">redis</span> <span class=\"kn\">import</span> <span class=\"n\">StrictRedis</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache.contrib.redis_cache</span> <span class=\"kn\">import</span> <span class=\"n\">RedisCacheInstance</span>\n<span class=\"kn\">from</span> <span class=\"nn\">easy_cache</span> <span class=\"kn\">import</span> <span class=\"n\">caches</span>\n\n<span class=\"n\">redis_cache</span> <span class=\"o\">=</span> <span class=\"n\">RedisCacheInstance</span><span class=\"p\">(</span><span class=\"n\">StrictRedis</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"o\">=</span><span class=\"s1\">'...'</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"s1\">'...'</span><span class=\"p\">))</span>\n<span class=\"n\">caches</span><span class=\"o\">.</span><span class=\"n\">set_default</span><span class=\"p\">(</span><span class=\"n\">redis_cache</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># will use `default` alias</span>\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<h2>Dynamic timeout example</h2>\n<p>You may need to provide cache timeout dynamically depending on function parameters:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">dynamic_timeout</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">group</span> <span class=\"o\">==</span> <span class=\"s1\">'admins'</span><span class=\"p\">:</span>\n        <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n    <span class=\"k\">return</span> <span class=\"n\">timeout</span>\n\n<span class=\"nd\">@ecached</span><span class=\"p\">(</span><span class=\"s1\">'key:</span><span class=\"si\">{group}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"n\">dynamic_timeout</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">get_users_by_group</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre>\n<h2>Development and contribution</h2>\n<p>Live instances of Redis and Memcached are required for few tests to pass, so it's recommended to use docker/docker-compose to setup the necessary environment:</p>\n<pre>docker-compose up -d\n\n<span class=\"c1\"># to enable debug logs</span>\n<span class=\"c1\"># export EASY_CACHE_DEBUG=\"yes\"</span>\n\n<span class=\"c1\"># install package locally</span>\npip install -e .<span class=\"o\">[</span>tests<span class=\"o\">]</span>\n\n<span class=\"c1\"># run tests with pytest or tox</span>\npytest\ntox\n</pre>\n<h2>Performance and overhead</h2>\n<p>Benchmarking may be executed with <code>tox</code> command and it shows that decorators give about 4% of overhead in worst case and about 1-2% overhead on the average.</p>\n<p>If you don't use tags or prefix you will get one cache request for <code>get</code> and one request for <code>set</code> if result not found in cache, otherwise two consecutive requests will be made: <code>get</code> and <code>get_many</code> to receive actual value from cache and validate its tags (prefix). Then one <code>set_many</code> request will be performed to save a data to cache storage.</p>\n\n          </div>"}, "last_serial": 4719181, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "44e3eb5d25248ceb78e2dcd94beeaea0", "sha256": "3ef1c1e110c6debc45f1f64eb32e177d9a8883b4d35a797c68dfd3fceb74ac69"}, "downloads": -1, "filename": "easy-cache-0.0.1.tar.gz", "has_sig": false, "md5_digest": "44e3eb5d25248ceb78e2dcd94beeaea0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16711, "upload_time": "2015-08-26T22:15:51", "upload_time_iso_8601": "2015-08-26T22:15:51.504709Z", "url": "https://files.pythonhosted.org/packages/c0/d3/7a6d31933703b72685dc6bf9903b96ff64011030edb0c0375003db073f4c/easy-cache-0.0.1.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "0796d5bcaf291075874fca512a14b812", "sha256": "c7b354f62b7e6125b79c5308f43adab1b0be526e3b557621cd0833a4c799ef24"}, "downloads": -1, "filename": "easy-cache-0.1.0.tar.gz", "has_sig": false, "md5_digest": "0796d5bcaf291075874fca512a14b812", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16743, "upload_time": "2015-08-27T07:19:33", "upload_time_iso_8601": "2015-08-27T07:19:33.187335Z", "url": "https://files.pythonhosted.org/packages/0d/c0/31ae14731ce53a3d0db807722fe814474717f34af570e47dbe90a362b8d2/easy-cache-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "4dd666d8c07b75d2244bb5206aca99b1", "sha256": "d30b9f18bf3700b4cbf9bbb9fe42896e5a1b6a39a97a69864555c67fc107ebaf"}, "downloads": -1, "filename": "easy-cache-0.2.0.tar.gz", "has_sig": false, "md5_digest": "4dd666d8c07b75d2244bb5206aca99b1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18888, "upload_time": "2015-09-07T21:59:13", "upload_time_iso_8601": "2015-09-07T21:59:13.516221Z", "url": "https://files.pythonhosted.org/packages/74/2d/9bc0438311b0b691cc8350b6aa93a03552f27c08c1415faaddf92fb5bd04/easy-cache-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "3d3280b9605d1780b69ad73183cdb382", "sha256": "fe6246ce6b90f2dcd7d9fb20bbb36c124204cd310d6a959615436e01a996f50a"}, "downloads": -1, "filename": "easy-cache-0.2.1.tar.gz", "has_sig": false, "md5_digest": "3d3280b9605d1780b69ad73183cdb382", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20167, "upload_time": "2015-09-20T21:51:55", "upload_time_iso_8601": "2015-09-20T21:51:55.057737Z", "url": "https://files.pythonhosted.org/packages/4d/3b/c9d049ec309e47ba42f329d2441108f568d5b10ddc74565dea5ac6c0520f/easy-cache-0.2.1.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "7e57d4651f846c0f1fa71f0fe671f53a", "sha256": "9ac0e9cc93c59fa9c94abc316b445b280aeaa8871902b993cbc07c1ee3dbae3e"}, "downloads": -1, "filename": "easy-cache-0.3.0.tar.gz", "has_sig": false, "md5_digest": "7e57d4651f846c0f1fa71f0fe671f53a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20955, "upload_time": "2016-01-18T21:04:12", "upload_time_iso_8601": "2016-01-18T21:04:12.499320Z", "url": "https://files.pythonhosted.org/packages/01/98/658f75e7178e70809fba0bd87b1be7af11384d35d24eca75b97a6f3e4070/easy-cache-0.3.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "324fdc2b992ed690958eb2f812e0fbf4", "sha256": "83878958a9ea9691cd89de0174a750ea150ebdffe4da42eb63c19eb558904481"}, "downloads": -1, "filename": "easy-cache-0.5.0.tar.gz", "has_sig": false, "md5_digest": "324fdc2b992ed690958eb2f812e0fbf4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32620, "upload_time": "2017-05-02T19:43:11", "upload_time_iso_8601": "2017-05-02T19:43:11.258713Z", "url": "https://files.pythonhosted.org/packages/8a/fd/bb9335eb2377141b78eac0200a49f0bbadaebbfdd069a0d2a5512f10f264/easy-cache-0.5.0.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "95dc204a621d3c87f3a6e693101e9969", "sha256": "672c717d95ef938b38c1a12de1239a6e67361bd2a11f983a0e026b1a24b1ede6"}, "downloads": -1, "filename": "easy-cache-0.6.0.tar.gz", "has_sig": false, "md5_digest": "95dc204a621d3c87f3a6e693101e9969", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38112, "upload_time": "2017-07-15T20:17:35", "upload_time_iso_8601": "2017-07-15T20:17:35.805041Z", "url": "https://files.pythonhosted.org/packages/42/4c/49bca7a420258ec6a1a21372de557eed3d4907e36538ebbb661938e8fa94/easy-cache-0.6.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "46092dea9e379fd6b2945e7a45ea538e", "sha256": "0388a5326cae2cb4f3f4551b8e0014f38c2614db072ade91d54e6c310d96f481"}, "downloads": -1, "filename": "easy-cache-1.0.0.tar.gz", "has_sig": false, "md5_digest": "46092dea9e379fd6b2945e7a45ea538e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35766, "upload_time": "2018-05-12T16:43:33", "upload_time_iso_8601": "2018-05-12T16:43:33.311900Z", "url": "https://files.pythonhosted.org/packages/7f/6a/9c195da378c5cbf8673d6d6889385163ebc30a875d64247ccde2a13cc6bf/easy-cache-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "0826748192b37b998d120069acabdc46", "sha256": "d99412159074d39891c83098dd5f0ca63bb56103e46efaa7e8455560680ce282"}, "downloads": -1, "filename": "easy_cache-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0826748192b37b998d120069acabdc46", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24151, "upload_time": "2019-01-20T20:16:39", "upload_time_iso_8601": "2019-01-20T20:16:39.024832Z", "url": "https://files.pythonhosted.org/packages/01/47/1d30783a8ce9df947f4d0c67726b3ecd0dfd22e363684b4eb1a8bf59e6e4/easy_cache-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "03345f30af74e093d010a3702217db76", "sha256": "95c4c7606bcac7da23762117b20197a59253db3d2e5bfd48b3d4c6e8649774ee"}, "downloads": -1, "filename": "easy-cache-1.1.0.tar.gz", "has_sig": false, "md5_digest": "03345f30af74e093d010a3702217db76", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33861, "upload_time": "2019-01-20T20:16:41", "upload_time_iso_8601": "2019-01-20T20:16:41.526338Z", "url": "https://files.pythonhosted.org/packages/85/2e/27a4000ca2ce756e3a9cc3f4539102793436352b9dbfa97bd47f79cf469e/easy-cache-1.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0826748192b37b998d120069acabdc46", "sha256": "d99412159074d39891c83098dd5f0ca63bb56103e46efaa7e8455560680ce282"}, "downloads": -1, "filename": "easy_cache-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0826748192b37b998d120069acabdc46", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24151, "upload_time": "2019-01-20T20:16:39", "upload_time_iso_8601": "2019-01-20T20:16:39.024832Z", "url": "https://files.pythonhosted.org/packages/01/47/1d30783a8ce9df947f4d0c67726b3ecd0dfd22e363684b4eb1a8bf59e6e4/easy_cache-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "03345f30af74e093d010a3702217db76", "sha256": "95c4c7606bcac7da23762117b20197a59253db3d2e5bfd48b3d4c6e8649774ee"}, "downloads": -1, "filename": "easy-cache-1.1.0.tar.gz", "has_sig": false, "md5_digest": "03345f30af74e093d010a3702217db76", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33861, "upload_time": "2019-01-20T20:16:41", "upload_time_iso_8601": "2019-01-20T20:16:41.526338Z", "url": "https://files.pythonhosted.org/packages/85/2e/27a4000ca2ce756e3a9cc3f4539102793436352b9dbfa97bd47f79cf469e/easy-cache-1.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:48:26 2020"}