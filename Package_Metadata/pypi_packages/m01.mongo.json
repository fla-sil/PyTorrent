{"info": {"author": "Roger Ineichen, Projekt01 GmbH", "author_email": "dev@projekt01.ch", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP"], "description": "This package provides a mongodb object mapper framework including zope\ntransaction support based on some core zope component libraries. This package\ncan get used with or without zope.persistent and as a full replacement for the\nZODB. The package is not heavy based on zope itself and can get used in any\npython project which requires a bridge from mongodb to python object.\n\n\n======\nREADME\n======\n\nIMPORTANT:\nIf you run the tests with the --all option a real mongodb stub server will\nstart at port 45017!\n\nThis package provides non persistent MongoDB object implementations. They can\nsimply get mixed with persistent.Persistent and contained.Contained if you like\nto use them in a mixed MongoDB/ZODB application setup. We currently use this\nframework as ORM (object relation mapper) where we map MongoDB objects\nto python/zope schema based objects including validation etc.\n\nIn our last project, we started with a mixed ZODB/MongoDB application where we\nmixed persistent.persistent into IMongoContainer objects. But later we where\nso exited about the performance and stability that we removed the ZODB\npersistence layer at all. Now we use a ZODB less setup in our application\nwhere we start with a non persistent item as our application root. All required\ntools where we use for such a ZODB less application setup are located in the\np01.publisher and p01.recipe.setup package.\n\nNOTE: Some of this test use a fake mongodb located in m01/mongo/testing and some\nother tests will use our mongdb stub from the m01.stub package. You can run\nthe tests with the --all option if you like to run the full tests which will\nstart and stop the mongodb stub server.\n\nNOTE:\nAll mongo item interfaces will not provide ILocation or IContained but the\nbase mongo item implementations will implement Location which provides the\nILocation interface directly. This makes it simpler for permission\ndeclaration in ZCML.\n\n\nSetup\n-----\n\n  >>> import pymongo\n  >>> import zope.component\n  >>> from m01.mongo import interfaces\n\n\nMongoClient\n-----------\n\nSetup a mongo client:\n\n  >>> client = pymongo.MongoClient('localhost', 45017)\n  >>> client\n  MongoClient(host=['127.0.0.1:45017'])\n\nAs you can see the client is able to access the database:\n\n  >>> db = client.m01MongoTesting\n  >>> db\n  Database(MongoClient(host=['127.0.0.1:45017']), u'm01MongoTesting')\n\nA data base can retrun a collection:\n\n  >>> collection = db['m01MongoTest']\n  >>> collection\n  Collection(Database(MongoClient(host=['127.0.0.1:45017']), u'm01MongoTesting'), u'm01MongoTest')\n\nAs you can see we can write to the collection:\n\n  >>> res = collection.update_one({'_id': '123'}, {'$inc': {'counter': 1}},\n  ...     upsert=True)\n  >>> res\n  <pymongo.results.UpdateResult object at ...>\n\n  >>> res.raw_result\n  {'updatedExisting': False, 'nModified': 0, 'ok': 1, 'upserted': '123', 'n': 1}\n\nAnd we can read from the collection:\n\n  >>> collection.find_one({'_id': '123'})\n  {u'_id': u'123', u'counter': 1}\n\nRemove the result from our test collection:\n\n  >>> res = collection.delete_one({'_id': '123'})\n  >>> res\n  <pymongo.results.DeleteResult object at ...>\n\n  >>> res.raw_result\n  {'ok': 1, 'n': 1}\n\n\ntear down\n---------\n\nNow tear down our MongoDB database with our current MongoDB connection:\n\n  >>> import time\n  >>> time.sleep(1)\n  >>> client.drop_database('m01MongoTesting')\n\n\n==============\nMongoContainer\n==============\n\nThe MongoContainer can store IMongoContainerItem objects in a MongoDB. A\nMongoContainerItem must be able to dump it's data to valid mongodb data. This\ntest will show how our MongoContainer works.\n\n\nCondition\n---------\n\nFirst import some components:\n\n  >>> import json\n  >>> import transaction\n  >>> import zope.interface\n  >>> import zope.schema\n  >>> import m01.mongo.item\n  >>> import m01.mongo.testing\n  >>> from m01.mongo.fieldproperty import MongoFieldProperty\n  >>> from m01.mongo import interfaces\n\nBefor we start testing, check if our thread local cache is empty or if we have\nleft over some junk from previous tests:\n\n  >>> from m01.mongo import LOCAL\n  >>> m01.mongo.testing.pprint(LOCAL.__dict__)\n  {}\n\n\nSetup\n-----\n\nAnd set up a database root:\n\n  >>> root = {}\n\n\nMongoContainerItem\n------------------\n\n  >>> class ISampleContainerItem(interfaces.IMongoContainerItem,\n  ...     zope.location.interfaces.ILocation):\n  ...     \"\"\"Sample item interface.\"\"\"\n  ...\n  ...     title = zope.schema.TextLine(\n  ...         title=u'Object Title',\n  ...         description=u'Object Title',\n  ...         required=True)\n\n\n  >>> class SampleContainerItem(m01.mongo.item.MongoContainerItem):\n  ...     \"\"\"Sample container item\"\"\"\n  ...\n  ...     zope.interface.implements(ISampleContainerItem)\n  ...\n  ...     title = MongoFieldProperty(ISampleContainerItem['title'])\n  ...\n  ...     dumpNames = ['title']\n\n\nMongoContainer\n--------------\n\n  >>> class ISampleContainer(interfaces.IMongoContainer):\n  ...     \"\"\"Sample container interface.\"\"\"\n\n\n  >>> class SampleContainer(m01.mongo.container.MongoContainer):\n  ...     \"\"\"Sample container.\"\"\"\n  ...\n  ...     zope.interface.implements(ISampleContainer)\n  ...\n  ...     @property\n  ...     def collection(self):\n  ...         db = m01.mongo.testing.getTestDatabase()\n  ...         return db['test']\n  ...\n  ...     def load(self, data):\n  ...         \"\"\"Load data into the right mongo item.\"\"\"\n  ...         return SampleContainerItem(data)\n\n  >>> container = SampleContainer()\n  >>> root['container'] = container\n\n\nCreate an object tree\n---------------------\n\nNow we can add a sample MongoContainerItem to our container using the mapping\napi:\n\n  >>> data = {'title': u'Title'}\n  >>> item = SampleContainerItem(data)\n  >>> container = root['container']\n  >>> container[u'item'] = item\n\nTransaction\n-----------\n\nZope provides transactions for store objects in the database. We also provide\nsuch a transaction and a transation data manager for store our objects in the\nmongodb. This means right now nothing get stored in our test database because\nwe didn't commit the transaction:\n\n  >>> collection = m01.mongo.testing.getTestCollection()\n  >>> collection.count()\n  0\n\nLet's commit our transaction an store the container item in mongodb:\n\n  >>> transaction.commit()\n\n  >>> collection = m01.mongo.testing.getTestCollection()\n  >>> collection.count()\n  1\n\nAfter commit, the thread local storage is empty:\n\n  >>> LOCAL.__dict__\n  {}\n\n\nMongodb data\n------------\n\nAs you can see the following data get stored in our mongodb:\n\n  >>> data = collection.find_one({'__name__': 'item'})\n  >>> m01.mongo.testing.pprint(data)\n  {u'__name__': u'item',\n   u'_id': ObjectId('...'),\n   u'_pid': None,\n   u'_type': u'SampleContainerItem',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'title': u'Title'}\n\n\nObject\n------\n\nWe can get from our container and mongo will load the data from mongodb:\n\n  >>> obj = container[u'item']\n  >>> obj\n  <SampleContainerItem u'item'>\n\n  >>> obj.title\n  u'Title'\n\nLet's tear down our test setup:\n\n  >>> transaction.commit()\n  >>> from m01.mongo import clearThreadLocalCache\n  >>> clearThreadLocalCache()\n\nAs you can see our cache items get removed:\n\n  >>> from m01.mongo import LOCAL\n  >>> m01.mongo.testing.pprint(LOCAL.__dict__)\n  {}\n\n\n============\nMongoStorage\n============\n\nThe MongoStorage can store IMongoStorageItem objects in a MongoDB. A\nMongoStorageItem must be able to dump it's data to valid mongo values. This\ntest will show how our MongoStorage works and also shows the limitations.\n\nNote: the mongo container also implements a container/mapping pattern like the\nstorage implementation. The only difference is, the container only provides the\nmapping api using contaner[key] = obj, container[key] and del container[key].\nThe storage api provides no explicit mapping key and offers add and remove\nmethods instead. This means the container uses it's own naming pattern and the\nstorage is using the mongodb._id as it's object name (obj.__name__).\n\n\nCondition\n---------\n\nBefor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:\n\n  >>> from m01.mongo import LOCAL\n  >>> from m01.mongo.testing import pprint\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\nSetup\n-----\n\nFirst import some components:\n\n  >>> import datetime\n  >>> import transaction\n  >>> from zope.container.interfaces import IReadContainer\n  >>> from m01.mongo import interfaces\n  >>> from m01.mongo import testing\n\nAnd set up a database root:\n\n  >>> root = {}\n\n\nMongoStorageItem\n----------------\n\nThe mongo item provides by default a ObjectId stored as _id. If there is none\ngiven during create an object, we will set one:\n\n  >>> data = {}\n  >>> obj = testing.SampleStorageItem(data)\n  >>> obj._id\n  ObjectId('...')\n\nThe ObjectId is also use as our __name__  value. See the MongoContainer and\nMongoContainerItem implementation if you need to choose your own names:\n\n  >>> obj.__name__\n  u'...'\n\n  >>> obj.__name__ == unicode(obj._id)\n  True\n\nA mongo item also provides created and modified date attributes. If we\ninitialize an object without a given created date, a new utc datetime instance\nget used:\n\n  >>> obj.created\n  datetime.datetime(..., tzinfo=UTC)\n\n  >>> obj.modified is None\n  True\n\nA mongo storage item knows if a state get changed. This means we can find out\nif we should write the item back to the MongoDB. The MongoItem stores the state\nin a _m_changed value like persistent objects do in _p_changed. As you can see\nthe initial state is ```None``:\n\n  >>> obj._m_changed is None\n  True\n\nThe MongoItem also has a version number which we increment each time we change\nthe item. By default this version is set as _version attribute and set by\ndefault to 0 (zero):\n\n  >>> obj._version\n  0\n\nIf we change a value in a MongoItem, the state get changed:\n\n  >>> obj.title = u'New Title'\n  >>> obj._m_changed\n  True\n\nbut the version get not imcremented. We only imcrement the version if we save\nthe item in MongoDB:\n\n  >>> obj._version\n  0\n\nWe also change the _m_change marker if we remove a value:\n\n  >>> obj = testing.SampleStorageItem(data)\n  >>> obj._m_changed is None\n  True\n\n  >>> obj.title\n  u''\n\n  >>> obj.title = u'New Title'\n  >>> obj._m_changed\n  True\n\n  >>> obj.title\n  u'New Title'\n\nNow let's set the _m_chande property set to False before we delete the attr:\n\n  >>> obj._m_changed = False\n  >>> obj._m_changed\n  False\n\n  >>> del obj.title\n\nAs you can see we can delete an attribute but it only falls back to the default\nschema field value. This seems fine.\n\n  >>> obj.title\n  u''\n\n  >>> obj._m_changed\n  True\n\n\nMongoStorage\n------------\n\nNow we can add a MongoStorage to the zope datbase:\n\n  >>> storage = testing.SampleStorage()\n  >>> root['storage'] = storage\n  >>> transaction.commit()\n\nNow we can add a sample MongoStorageItem to our storage. Note we can only use the\nadd method which will return the new generated __name__. Using own names is not\nsupported by this implementation. As you can see the name is an MongoDB\n24 hex character string objectId representation.\n\n  >>> data = {'title': u'Title',\n  ...         'description': u'Description'}\n  >>> item = testing.SampleStorageItem(data)\n  >>> storage = root['storage']\n\nOur storage provides the IMongoStorage and IReadContainer interfaces:\n\n  >>> interfaces.IMongoStorage.providedBy(storage)\n  True\n\n  >>> IReadContainer.providedBy(storage)\n  True\n\n\nadd\n---\n\nWe can add a mongo item to our storage by using the add method.\n\n  >>> __name__ = storage.add(item)\n  >>> __name__\n  u'...'\n  >>> len(__name__)\n  24\n\n  >>> transaction.commit()\n\nAfter adding our item, the item provides a created date:\n\n  >>> item.created\n  datetime.datetime(..., tzinfo=UTC)\n\n\n__len__\n-------\n\n  >>> storage = root['storage']\n  >>> len(storage)\n  1\n\n\n__getitem__\n-----------\n\n  >>> item = storage[__name__]\n  >>> item\n  <SampleStorageItem ...>\n\nAs you can see our MongoStorageItem provides the following data. We can dump\nthe item. Note, you probaly have to implement a custom dump method which will\ndump the right data for you MongoStorageItem.\n\n  >>> pprint(item.dump())\n  {'__name__': '...',\n   '_id': ObjectId('...'),\n   '_pid': None,\n   '_type': 'SampleStorageItem',\n   '_version': 1,\n   'comments': [],\n   'created': datetime.datetime(..., tzinfo=UTC),\n   'date': None,\n   'description': 'Description',\n   'item': None,\n   'modified': datetime.datetime(..., tzinfo=UTC),\n   'number': None,\n   'numbers': [],\n   'title': 'Title'}\n\nThe object provides also a name which is the name we've got during adding the\nobject:\n\n  >>> item.__name__ == __name__\n  True\n\n\nkeys\n----\n\nThe container can also return key:\n\n  >>> tuple(storage.keys())\n  (u'...',)\n\n\nvalues\n------\n\nThe container can also return values:\n\n  >>> tuple(storage.values())\n  (<SampleStorageItem ...>,)\n\nitems\n-----\n\nThe container can also return items:\n\n  >>> tuple(storage.items())\n  ((u'...', <SampleStorageItem ...>),)\n\n\n__delitem__\n-----------\n\nAs next we will remove the item:\n\n  >>> del storage[__name__]\n  >>> storage.get(__name__) is None\n  True\n\n  >>> transaction.commit()\n\n\nObject modification\n-------------------\n\nIf we get a mongo item from a storage and modify the item, the version get\nincreased by one and a current modified datetime get set.\n\nLet's add a new item:\n\n  >>> data = {'title': u'A Title',\n  ...         'description': u'A Description'}\n  >>> item = testing.SampleStorageItem(data)\n  >>> __name__ = storage.add(item)\n  >>> transaction.commit()\n\nNow get the item::\n\n  >>> item = storage[__name__]\n  >>> item.title\n  u'A Title'\n\nand change the titel:\n\n  >>> item.title = u'New Title'\n  >>> item.title\n  u'New Title'\n\nAs you can see the item get marked as changed:\n\n  >>> item._m_changed\n  True\n\nNow get the mongo item version. This should be set to 1 (one) since we only\nadded the object and didn't change since we added them:\n\n  >>> item._version\n  1\n\nIf we now commit the transaction, the version get increased by one:\n\n  >>> transaction.commit()\n  >>> item._version\n  2\n\nIf you now load the mongo item from the MongoDB aain, you can see that the\ntitle get changed:\n\n  >>> item = storage[__name__]\n  >>> item.title\n  u'New Title'\n\nAnd that the version get updated to 2:\n\n  >>> item._version\n  2\n\n  >>> transaction.commit()\n\nCheck our thread local cache before we leave this test:\n\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\n=====================\nShared MongoContainer\n=====================\n\nThe MongoContainer can store non persistent IMongoContainerItem objects in a\nMongoDB. A MongoContainerItem must be able to dump it's data to valid mongo\nvalues. This test will show how our MongoContainer works.\n\n\nCondition\n---------\n\nBefor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:\n\n  >>> from m01.mongo.testing import pprint\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\nSetup\n-----\n\nFirst import some components:\n\n  >>> import datetime\n  >>> import transaction\n  >>> from zope.container.interfaces import IContainer\n\n  >>> import m01.mongo\n  >>> import m01.mongo.base\n  >>> import m01.mongo.container\n  >>> from m01.mongo import interfaces\n  >>> from m01.mongo import testing\n\nWe also need a application root object. Let's define a static MongoContainer\nas our application database root item.\n\n  >>> class MongoRoot(m01.mongo.container.MongoContainer):\n  ...     \"\"\"Mongo application root\"\"\"\n  ...\n  ...     _id = m01.mongo.getObjectId(0)\n  ...\n  ...     def __init__(self):\n  ...         pass\n  ...\n  ...     @property\n  ...     def collection(self):\n  ...         return testing.getRootItems()\n  ...\n  ...     @property\n  ...     def cacheKey(self):\n  ...         return 'root'\n  ...\n  ...     def load(self, data):\n  ...         \"\"\"Load data into the right mongo item.\"\"\"\n  ...         return testing.Companies(data)\n  ...\n  ...     def __repr__(self):\n  ...         return '<%s %s>' % (self.__class__.__name__, self._id)\n\n\nAs you can see our MongoRoot class defines a static mongo ObjectID as _id. This\nmeans the same _id get use every time. This _id acts as our __parent__\nreference.\n\nThe following method allows us to generate new MongoRoot item instances. This\nallows us to show that we generate different root items like we would do on a\nserver restart.\n\n  >>> def getRoot():\n  ...     return MongoRoot()\n\nHere is our database root item:\n\n  >>> root = getRoot()\n  >>> root\n  <MongoRoot 000000000000000000000000>\n\n  >>> root._id\n  ObjectId('000000000000000000000000')\n\n\nContainers\n----------\n\nNow let's use our enhanced testing data and setup a content structure:\n\n  >>> data = {'name': u'Europe'}\n  >>> europe = testing.Companies(data)\n  >>> root[u'europe'] = europe\n\n  >>> data = {'name': u'Asia'}\n  >>> asia = testing.Companies(data)\n  >>> root[u'asia'] = asia\n\n  >>> transaction.commit()\n\nLet's check our companies in Mongo:\n\n  >>> rootCollection = testing.getRootItems()\n  >>> obj = rootCollection.find_one({'name': 'Europe'})\n  >>> pprint(obj)\n  {u'__name__': u'europe',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'Companies',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'Europe'}\n\nNow let's add a Company, Employer and some documents:\n\n  >>> data = {'name': u'Projekt01 GmbH'}\n  >>> pro = testing.Company(data)\n  >>> europe[u'pro'] = pro\n\n  >>> data = {'name': u'Roger Ineichen'}\n  >>> roger = testing.Employer(data)\n  >>> pro[u'roger'] = roger\n\n  >>> data = {'name': u'Manual'}\n  >>> manual = testing.Document(data)\n  >>> roger[u'manual'] = manual\n\n  >>> transaction.commit()\n\nAs you can see we added a data structure using our container, item objects:\n\n  >>> root['europe']\n  <Companies u'europe'>\n\n  >>> root['europe']['pro']\n  <Company u'pro'>\n\n  >>> root['europe']['pro']['roger']\n  <Employer u'roger'>\n\n  >>> root['europe']['pro']['roger']['manual']\n  <Document u'manual'>\n\nAs you can see this structure is related to their __parent__ references. This\nmeans if we add another structure into the same mongodb, each item knows it's\ncontainer.\n\n  >>> data = {'name': u'Credit Suisse'}\n  >>> cs = testing.Company(data)\n  >>> asia[u'cs'] = cs\n\n  >>> data = {'name': u'Max Muster'}\n  >>> max = testing.Employer(data)\n  >>> cs[u'max'] = max\n\n  >>> data = {'name': u'Paper'}\n  >>> paper = testing.Document(data)\n  >>> max[u'paper'] = paper\n\n  >>> transaction.commit()\n\n  >>> root['asia']\n  <Companies u'asia'>\n\n  >>> root['asia']['cs']\n  <Company u'cs'>\n\n  >>> root['asia']['cs']['max']\n  <Employer u'max'>\n\n  >>> root['asia']['cs']['max']['paper']\n  <Document u'paper'>\n\nWe can't access another item from the same type from another parent container:\n\n  >>> root['europe']['cs']\n  Traceback (most recent call last):\n  ...\n  KeyError: 'cs'\n\n  >>> transaction.commit()\n\nAs you can see the KeyError left items back in our thread local cache. We can\nuse our thread local cache cleanup event handler which is by default registered\nas an EndRequestEvent subscriber for cleanup our thread local cache:\n\n  >>> pprint(LOCAL.__dict__)\n  {u'europe': {'loaded': {}, 'removed': {}}}\n\nLet's use our subscriber:\n\n  >>> from m01.mongo import clearThreadLocalCache\n  >>> clearThreadLocalCache()\n\nAs you can see our cache items get removed:\n\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\nShared Container\n----------------\n\nNow let's implement a shared container which contains all IEmployer items:\n\n  >>> class SharedEployers(m01.mongo.container.MongoContainer):\n  ...     \"\"\"Shared Employer container\"\"\"\n  ...\n  ...     # mark a container as shared by set the _mpid to None\n  ...     _mpid = None\n  ...\n  ...     @property\n  ...     def collection(self):\n  ...         return testing.getEmployers()\n  ...\n  ...     def load(self, data):\n  ...         return testing.Employer(data)\n\nNow let's try if the shared container can access all Employer items:\n\n  >>> shared = SharedEployers()\n  >>> pprint(tuple(shared.items()))\n  ((u'roger', <Employer u'roger'>), (u'max', <Employer u'max'>))\n\n  >>> for obj in shared.values():\n  ...     pprint(obj.dump())\n  {'__name__': u'roger',\n   '_id': ObjectId('...'),\n   '_pid': ObjectId('...'),\n   '_type': u'Employer',\n   '_version': 1,\n   'created': datetime.datetime(..., tzinfo=UTC),\n   'modified': datetime.datetime(..., tzinfo=UTC),\n   'name': u'Roger Ineichen'}\n  {'__name__': u'max',\n   '_id': ObjectId('...'),\n   '_pid': ObjectId('...'),\n   '_type': u'Employer',\n   '_version': 1,\n   'created': datetime.datetime(..., tzinfo=UTC),\n   'modified': datetime.datetime(..., tzinfo=UTC),\n   'name': u'Max Muster'}\n\nNow commit our transaction which will cleanup our caches. Database cleanup is\ndone in our test teardown:\n\n  >>> transaction.commit()\n\nCheck our thread local cache before we leave this test:\n\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\n===========\nMongoObject\n===========\n\nA MongoObject can get stored independent from anything else in a MongoDB. Such\nMongoObject can get used together with a field property called\nMongoOjectProperty. The field property is responsible for set and get such\nMongoObject to and from MongoDB. A persistent item which provides such a\nMongoObject within a MongoObjectProperty only has to provide an oid attribute\nwith a unique value. You can use the m01.oid package for such a unique oid\nor implement an own pattern.\n\nThe MongoObject uses the __parent__._moid and the attribute (field) name as\nit's unique MongoDB key.\n\nNote, this test uses a fake MongoDB server setup. But this fake server is far\naway from beeing complete. We will add more feature to this fake server if we\nneed them in other projects. See testing.py for more information.\n\n\nCondition\n---------\n\nBefor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:\n\n  >>> from m01.mongo.testing import pprint\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\nSetup\n-----\n\nFirst import some components:\n\n  >>> import datetime\n  >>> import transaction\n  >>> from m01.mongo import interfaces\n  >>> from m01.mongo import testing\n\nFirst, we need to setup a persistent object:\n\n  >>> content = testing.Content(42)\n  >>> content._moid\n  42\n\nAnd add them to the ZODB:\n\n  >>> root = {}\n  >>> root['content'] = content\n  >>> transaction.commit()\n\n  >>> content = root['content']\n  >>> content\n  <Content 42>\n\n\nMongoObject\n-----------\n\nNow let's add a MongoObject instance to our sample content object:\n\n  >>> data = {'title': u'Mongo Object Title',\n  ...         'description': u'A Description',\n  ...         'item': {'text':u'Item'},\n  ...         'date': datetime.date(2010, 2, 28).toordinal(),\n  ...         'numbers': [1,2,3],\n  ...         'comments': [{'text':u'Comment 1'}, {'text':u'Comment 2'}]}\n  >>> obj = testing.SampleMongoObject(data)\n  >>> obj._id\n  ObjectId('...')\n\n  obj.title\n  u'Mongo Object Title'\n\n  >>> obj.description\n  u'A Description'\n\n  >>> obj.item\n  <SampleSubItem u'...'>\n\n  >>> obj.item.text\n  u'Item'\n\n  >>> obj.numbers\n  [1, 2, 3]\n\n  >>> obj.comments\n  [<SampleSubItem u'...'>, <SampleSubItem u'...'>]\n\n  >>> tuple(obj.comments)[0].text\n  u'Comment 1'\n\n  >>> tuple(obj.comments)[1].text\n  u'Comment 2'\n\nOur MongoObject doesn't provide a _aprent__ or __name__ right now:\n\n  >>> obj.__parent__ is None\n  True\n\n  >>> obj.__name__ is None\n  True\n\nBut after adding the mongo object to our content which uses a\nMongoObjectProperty, the mongo object get located and becomes the attribute\nname as _field value. If the object didn't provide a __name__, the same value\nwill also get applied for __name__:\n\n  >>> content.obj = obj\n  >>> obj.__parent__\n  <Content 42>\n\n  >>> obj.__name__\n  u'obj'\n\n  >>> obj.__name__\n  u'obj'\n\nAfter adding our mongo object, there should be a reference in our thread local\ncache:\n\n  >>> pprint(LOCAL.__dict__)\n  {u'42:obj': <SampleMongoObject u'obj'>,\n   'MongoTransactionDataManager': <m01.mongo.tm.MongoTransactionDataManager object at ...>}\n\nA MongoObject provides a _oid attribute which is used as the MongoDB key. This\nvalue uses the __parent__._moid and the mongo objects attribute name:\n\n  >>> obj._oid == '%s:%s' % (content._moid, obj.__name__)\n  True\n\n  >>> obj._oid\n  u'42:obj'\n\nNow check if we can get the mongo object again and if we still get the same\nvalues:\n\n  >>> obj = content.obj\n  >>> obj.title\n  u'Mongo Object Title'\n\n  >>> obj.description\n  u'A Description'\n\n  >>> obj.item\n  <SampleSubItem u'...'>\n\n  >>> obj.item.text\n  u'Item'\n\n  >>> obj.numbers\n  [1, 2, 3]\n\n  >>> obj.comments\n  [<SampleSubItem u'...'>, <SampleSubItem u'...'>]\n\n  >>> tuple(obj.comments)[0].text\n  u'Comment 1'\n\n  >>> tuple(obj.comments)[1].text\n  u'Comment 2'\n\nNow let's commit the transaction which will store the obj in our fake mongo DB:\n\n  >>> transaction.commit()\n\nAfter we commited to the MongoDB, the mongo object and our transaction data\nmanger reference should be gone in the thread local cache:\n\n  >>> pprint(LOCAL.__dict__)\n  {}\n\nNow check our mongo object values again. If your content item is stored in a\nZODB, you would get the content item from a ZODB connection root:\n\n  >>> content = root['content']\n  >>> content\n  <Content 42>\n\n  >>> obj = content.obj\n  >>> obj\n  <SampleMongoObject u'obj'>\n\n  >>> obj.title\n  u'Mongo Object Title'\n\n  >>> obj.description\n  u'A Description'\n\n  >>> obj.item\n  <SampleSubItem u'...'>\n\n  >>> obj.item.text\n  u'Item'\n\n  >>> obj.numbers\n  [1, 2, 3]\n\n  >>> obj.comments\n  [<SampleSubItem u'...'>, <SampleSubItem u'...'>]\n\n  >>> tuple(obj.comments)[0].text\n  u'Comment 1'\n\n  >>> tuple(obj.comments)[1].text\n  u'Comment 2'\n\n  >>> pprint(obj.dump())\n  {'__name__': u'obj',\n   '_field': u'obj',\n   '_id': ObjectId('...'),\n   '_oid': u'42:obj',\n   '_type': u'SampleMongoObject',\n   '_version': 1,\n   'comments': [{'_id': ObjectId('...'),\n                 '_type': u'SampleSubItem',\n                 'created': datetime.datetime(...),\n                 'modified': None,\n                 'text': u'Comment 1'},\n                {'_id': ObjectId('...'),\n                 '_type': u'SampleSubItem',\n                 'created': datetime.datetime(...),\n                 'modified': None,\n                 'text': u'Comment 2'}],\n   'created': datetime.datetime(...),\n   'date': 733831,\n   'description': u'A Description',\n   'item': {'_id': ObjectId('...'),\n            '_type': u'SampleSubItem',\n            'created': datetime.datetime(...),\n            'modified': None,\n            'text': u'Item'},\n   'modified': datetime.datetime(...),\n   'number': None,\n   'numbers': [1, 2, 3],\n   'removed': False,\n   'title': u'Mongo Object Title'}\n\n  >>> transaction.commit()\n\n  >>> pprint(LOCAL.__dict__)\n  {}\n\nNow let's replace the existing item with a new one and add another item to\nthe item lists. Also make sure we can use append instead of re-apply the full\nlist like zope widgets do:\n\n  >>> content = root['content']\n  >>> obj = content.obj\n\n  >>> obj.item = testing.SampleSubItem({'text': u'New Item'})\n\n  >>> newItem = testing.SampleSubItem({'text': u'New List Item'})\n  >>> obj.comments.append(newItem)\n\n  >>> obj.numbers.append(4)\n\n  >>> transaction.commit()\n\ncheck again:\n\n  >>> content = root['content']\n  >>> obj = content.obj\n\n  >>> obj.title\n  u'Mongo Object Title'\n\n  >>> obj.description\n  u'A Description'\n\n  >>> obj.item\n  <SampleSubItem u'...'>\n\n  >>> obj.item.text\n  u'New Item'\n\n  >>> obj.numbers\n  [1, 2, 3, 4]\n\n  >>> obj.comments\n  [<SampleSubItem u'...'>, <SampleSubItem u'...'>]\n\n  >>> tuple(obj.comments)[0].text\n  u'Comment 1'\n\n  >>> tuple(obj.comments)[1].text\n  u'Comment 2'\n\nAnd now re-apply a full list of values to the list field:\n\n  >>> comOne = testing.SampleSubItem({'text': u'First List Item'})\n  >>> comTwo = testing.SampleSubItem({'text': u'Second List Item'})\n  >>> comments = [comOne, comTwo]\n  >>> obj.comments = comments\n  >>> obj.numbers = [1,2,3,4,5]\n  >>> transaction.commit()\n\ncheck again:\n\n  >>> content = root['content']\n  >>> obj = content.obj\n\n  >>> len(obj.comments)\n  2\n\n  >>> obj.comments\n  [<SampleSubItem u'...'>, <SampleSubItem u'...'>]\n\n  >>> len(obj.numbers)\n  5\n\n  >>> obj.numbers\n  [1, 2, 3, 4, 5]\n\nAlso check if we can remove list items:\n\n  >>> obj.numbers.remove(1)\n  >>> obj.numbers.remove(2)\n\n  >>> obj.comments.remove(comTwo)\n\n  >>> transaction.commit()\n\ncheck again:\n\n  >>> content = root['content']\n  >>> obj = content.obj\n\n  >>> len(obj.comments)\n  1\n\n  >>> obj.comments\n  [<SampleSubItem u'...'>]\n\n  >>> len(obj.numbers)\n  3\n\n  >>> obj.numbers\n  [3, 4, 5]\n\n  >>> transaction.commit()\n\nWe can also remove items from the item list by it's __name__:\n\n  >>> content = root['content']\n  >>> obj = content.obj\n\n  >>> del obj.comments[comOne.__name__]\n\n  >>> transaction.commit()\n\ncheck again:\n\n  >>> content = root['content']\n  >>> obj = content.obj\n\n  >>> len(obj.comments)\n  0\n\n  >>> obj.comments\n  []\n\n  >>> transaction.commit()\n\nOr we can add items to the item list by name:\n\n  >>> content = root['content']\n  >>> obj = content.obj\n\n  >>> obj.comments[comOne.__name__] = comOne\n\n  >>> transaction.commit()\n\ncheck again:\n\n  >>> content = root['content']\n  >>> obj = content.obj\n\n  >>> len(obj.comments)\n  1\n\n  >>> obj.comments\n  [<SampleSubItem u'...'>]\n\n  >>> transaction.commit()\n\n\nCoverage\n--------\n\nOur items list also provides the following methods:\n\n  >>> obj.comments.__contains__(comOne.__name__)\n  True\n\n  >>> comOne.__name__ in obj.comments\n  True\n\n  >>> obj.comments.get(comOne.__name__)\n  <SampleSubItem u'...'>\n\n  >>> obj.comments.keys() == [comOne.__name__]\n  True\n\n  >>> obj.comments.values()\n  <generator object ...>\n\n  >>> tuple(obj.comments.values())\n  (<SampleSubItem u'...'>,)\n\n  >>> obj.comments.items()\n  <generator object ...>\n\n  >>> tuple(obj.comments.items())\n  ((u'...', <SampleSubItem u'...'>),)\n\n  >>> obj.comments == obj.comments\n  True\n\nLet's test some internals for increase coverage:\n\n  >>> obj.comments._m_changed\n  Traceback (most recent call last):\n  ...\n  AttributeError: _m_changed is a write only property\n\n  >>> obj.comments._m_changed = False\n  Traceback (most recent call last):\n  ...\n  ValueError: Can only dispatch True to __parent__\n\n  >>> obj.comments.locate(42)\n\nOur simple value typ list also provides the following methods:\n\n  >>> obj.numbers.__contains__(3)\n  True\n\n  >>> 3 in obj.numbers\n  True\n\n  >>> obj.numbers == obj.numbers\n  True\n\n  >>> obj.numbers.pop()\n  5\n\n  >>> del obj.numbers[0]\n\n  >>> obj.numbers[0] = 42\n\n  >>> obj.numbers._m_changed\n  Traceback (most recent call last):\n  ...\n  AttributeError: _m_changed is a write only property\n\n  >>> obj.numbers._m_changed = False\n  Traceback (most recent call last):\n  ...\n  ValueError: Can only dispatch True to __parent__\n\nCheck our thread local cache before we leave this test:\n\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\n===========\nGeoLocation\n===========\n\nThe GeoLocation item can store a geo location and is used in an item as\na kind of sub item providing longitude and latitude. Additional to this\nfields a GeoLocation provides the _m_changed dispatching concept and is able\nto notify the __parent__ item if lon/lat get changed. The item also provides\nILocation for security lookup support. The field property is responsible for\napply a __parent__ and __name__.\n\nThe GeoLocation item supports the order longitude, latitude and preserves them.\n\n\nCondition\n---------\n\nBefor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:\n\n  >>> from m01.mongo.testing import pprint\n  >>> from m01.mongo import LOCAL\n  >>> from m01.mongo.testing import reNormalizer\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\nSetup\n-----\n\nFirst import some components:\n\n  >>> import datetime\n  >>> import transaction\n\n  >>> import m01.mongo\n  >>> import m01.mongo.base\n  >>> import m01.mongo.geo\n  >>> import m01.mongo.container\n  >>> from m01.mongo import interfaces\n  >>> from m01.mongo import testing\n\nWe also need a application root object. Let's define a static MongoContainer\nas our application database root item.\n\n  >>> class MongoRoot(m01.mongo.container.MongoContainer):\n  ...     \"\"\"Mongo application root\"\"\"\n  ...\n  ...     _id = m01.mongo.getObjectId(0)\n  ...\n  ...     def __init__(self):\n  ...         pass\n  ...\n  ...     @property\n  ...     def collection(self):\n  ...         return testing.getRootItems()\n  ...\n  ...     @property\n  ...     def cacheKey(self):\n  ...         return 'root'\n  ...\n  ...     def load(self, data):\n  ...         \"\"\"Load data into the right mongo item.\"\"\"\n  ...         return testing.GeoSample(data)\n  ...\n  ...     def __repr__(self):\n  ...         return '<%s %s>' % (self.__class__.__name__, self._id)\n\n\nThe following method allows us to generate new MongoRoot item instances. This\nallows us to show that we generate different root items like we would do on a\nserver restart.\n\n  >>> def getRoot():\n  ...     return MongoRoot()\n\nHere is our database root item:\n\n  >>> root = getRoot()\n  >>> root\n  <MongoRoot 000000000000000000000000>\n\n  >>> root._id\n  ObjectId('000000000000000000000000')\n\n\nindexing\n--------\n\nFirst setup an index:\n\n  >>> collection = testing.getRootItems()\n\n  >>> from pymongo import GEO2D\n  >>> collection.create_index([('lonlat', GEO2D)])\n  u'lonlat_2d'\n\n\nGeoSample\n---------\n\nAs you can see, we can initialize a GeoLocation within a list of lon/lat values\nor within a lon/lat dict:\n\n  >>> data = {'name': u'sample', 'lonlat': {'lon': 1, 'lat': 3}}\n  >>> sample = testing.GeoSample(data)\n  >>> sample.lonlat\n  <GeoLocation lon:1.0, lat:3.0>\n\n  >>> data = {'name': u'sample', 'lonlat': [1, 3]}\n  >>> sample = testing.GeoSample(data)\n  >>> sample.lonlat\n  <GeoLocation lon:1.0, lat:3.0>\n\n  >>> root[u'sample'] = sample\n\n  >>> transaction.commit()\n\nLet's check our item in Mongo:\n\n  >>> data = collection.find_one({'name': 'sample'})\n  >>> reNormalizer.pprint(data)\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': [1.0, 3.0],\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\nWe can also use a GeoLocation as lonlat data:\n\n  >>> geo = m01.mongo.geo.GeoLocation({u'lat': 4, u'lon': 2})\n  >>> data = {'name': u'sample2', 'lonlat': geo}\n  >>> sample2 = testing.GeoSample(data)\n  >>> root[u'sample2'] = sample2\n\n  >>> transaction.commit()\n\n  >>> data = collection.find_one({'name': 'sample2'})\n  >>> reNormalizer.pprint(data)\n  {u'__name__': u'sample2',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'lat': 4.0, u'lon': 2.0},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample2'}\n\n\nWe can also set a GeoLocation as lonlat value:\n\n  >>> sample2 = root[u'sample2']\n  >>> geo = m01.mongo.geo.GeoLocation({'lon': 4, 'lat': 6})\n  >>> sample2.lonlat = geo\n\n  >>> transaction.commit()\n\n  >>> data = collection.find_one({'name': 'sample2'})\n  >>> reNormalizer.pprint(data)\n  {u'__name__': u'sample2',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 2,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'lat': 6.0, u'lon': 4.0},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample2'}\n\n\nsearch\n------\n\nLet's test some geo location search query and make sure our lon/lat order\nwill fit and get preserved during the mongodb roundtrip.\n\nNow seearch for a geo location:\n\n  >>> def printFind(collection, query):\n  ...     for data in collection.find(query):\n  ...         reNormalizer.pprint(data)\n\nUsing the geospatial index we can find documents near another point:\n\n  >>> printFind(collection, {'lonlat': {'$near': [0, 2]}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': [1.0, 3.0],\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n  {u'__name__': u'sample2',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 2,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'lat': 6.0, u'lon': 4.0},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample2'}\n\nIt's also possible to query for all items within a given rectangle\n(specified by lower-left and upper-right coordinates):\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$box': [[1,2], [2,3]]}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': [1.0, 3.0],\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\nAs you can see if we use the wrong order for lon/lat (lat/lon), we will not\nget a value:\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$box': [[10,20], [20,30]]}}})\n\nWe can also search for a circle (specified by center point and radius):\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 2]}}})\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 4]}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': [1.0, 3.0],\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 10]}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': [1.0, 3.0],\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n  {u'__name__': u'sample2',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 2,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'lat': 6.0, u'lon': 4.0},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample2'}\n\nAlso check if the lat/lon order matters:\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[1, 2], 1]}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': [1.0, 3.0],\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[2, 1], 1]}}})\n\n\nAnd check if we can store real lon/lat values by using a float:\n\n  >>> data = {'name': u'sample', 'lonlat': {'lon': 20.123, 'lat': 29.123}}\n  >>> sample3 = testing.GeoSample(data)\n  >>> root[u'sample3'] = sample3\n\n  >>> transaction.commit()\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[25, 25], 4]}}})\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[25, 25], 10]}}})\n  {u'__name__': u'sample3',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'lat': 29.123, u'lon': 20.123},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\n\ntear down\n---------\n\n  >>> from m01.mongo import clearThreadLocalCache\n  >>> clearThreadLocalCache()\n\nAs you can see our cache items get removed:\n\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\n========\nGeoPoint\n========\n\nThe GeoPoint item can store a geo location and is used in an item as\na kind of sub item providing longitude and latitude and type. Additional to this\nfields a GeoPoint provides the _m_changed dispatching concept and is able\nto notify the __parent__ item if lon/lat get changed. The item also provides\nILocation for security lookup support. The MongoGeoPointProperty field property\nis responsible for apply a __parent__ and __name__ and use the right class\nfactory.\n\nThe GeoPoint item supports the order longitude, latitude and preserves them.\n\n\nCondition\n---------\n\nBefor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:\n\n  >>> from m01.mongo.testing import pprint\n  >>> from m01.mongo import LOCAL\n  >>> from m01.mongo.testing import reNormalizer\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\nSetup\n-----\n\nFirst import some components:\n\n  >>> import datetime\n  >>> import transaction\n\n  >>> import m01.mongo\n  >>> import m01.mongo.base\n  >>> import m01.mongo.geo\n  >>> import m01.mongo.container\n  >>> from m01.mongo import interfaces\n  >>> from m01.mongo import testing\n\nWe also need a application root object. Let's define a static MongoContainer\nas our application database root item.\n\n  >>> class MongoRoot(m01.mongo.container.MongoContainer):\n  ...     \"\"\"Mongo application root\"\"\"\n  ...\n  ...     _id = m01.mongo.getObjectId(0)\n  ...\n  ...     def __init__(self):\n  ...         pass\n  ...\n  ...     @property\n  ...     def collection(self):\n  ...         return testing.getRootItems()\n  ...\n  ...     @property\n  ...     def cacheKey(self):\n  ...         return 'root'\n  ...\n  ...     def load(self, data):\n  ...         \"\"\"Load data into the right mongo item.\"\"\"\n  ...         return testing.GeoPointSample(data)\n  ...\n  ...     def __repr__(self):\n  ...         return '<%s %s>' % (self.__class__.__name__, self._id)\n\n\nThe following method allows us to generate new MongoRoot item instances. This\nallows us to show that we generate different root items like we would do on a\nserver restart.\n\n  >>> def getRoot():\n  ...     return MongoRoot()\n\nHere is our database root item:\n\n  >>> root = getRoot()\n  >>> root\n  <MongoRoot 000000000000000000000000>\n\n  >>> root._id\n  ObjectId('000000000000000000000000')\n\n\nindexing\n--------\n\nFirst setup an index:\n\n  >>> collection = testing.getRootItems()\n\n  >>> from pymongo import GEOSPHERE\n  >>> collection.create_index([('lonlat', GEOSPHERE)])\n  u'lonlat_2dsphere'\n\n\nGeoPointSample\n--------------\n\nAs you can see, we can initialize a GeoPoint within a list of lon/lat values\nor within a lon/lat dict:\n\n  >>> data = {'name': u'sample', 'lonlat': {'lon': 1, 'lat': 3}}\n  >>> sample = testing.GeoPointSample(data)\n  >>> sample.lonlat\n  <GeoPoint lon:1.0, lat:3.0>\n\n  >>> data = {'name': u'sample', 'lonlat': [1, 3]}\n  >>> sample = testing.GeoPointSample(data)\n  >>> sample.lonlat\n  <GeoPoint lon:1.0, lat:3.0>\n\n  >>> root[u'sample'] = sample\n\n  >>> transaction.commit()\n\nLet's check our item in Mongo:\n\n  >>> data = collection.find_one({'name': 'sample'})\n  >>> reNormalizer.pprint(data)\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\nWe can also use a GeoPoint as lonlat data:\n\n  >>> geo = m01.mongo.geo.GeoPoint({u'lat': 4, u'lon': 2})\n  >>> data = {'name': u'sample2', 'lonlat': geo}\n  >>> sample2 = testing.GeoPointSample(data)\n  >>> root[u'sample2'] = sample2\n\n  >>> transaction.commit()\n\n  >>> data = collection.find_one({'name': 'sample2'})\n  >>> reNormalizer.pprint(data)\n  {u'__name__': u'sample2',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [2.0, 4.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample2'}\n\n\nWe can also set a GeoPoint as lonlat value:\n\n  >>> sample2 = root[u'sample2']\n  >>> geo = m01.mongo.geo.GeoPoint({'lon': 4, 'lat': 6})\n  >>> sample2.lonlat = geo\n\n  >>> transaction.commit()\n\n  >>> data = collection.find_one({'name': 'sample2'})\n  >>> reNormalizer.pprint(data)\n  {u'__name__': u'sample2',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 2,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [4.0, 6.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample2'}\n\n\nindex\n-----\n\n  >>> pprint(collection.index_information())\n  {'_id_': {'key': [('_id', 1)], 'ns': 'm01_mongo_testing.items', 'v': 1},\n   'lonlat_2dsphere': {'2dsphereIndexVersion': 2,\n                        'key': [('lonlat', '2dsphere')],\n                        'ns': 'm01_mongo_testing.items',\n                        'v': 1}}\n\n\nsearch\n------\n\nLet's test some geo location search query and make sure our lon/lat order\nwill fit and get preserved during the mongodb roundtrip.\n\nNow seearch for a geo location:\n\n  >>> def printFind(collection, query):\n  ...     for data in collection.find(query):\n  ...         reNormalizer.pprint(data)\n\nUsing the geospatial index we can find documents within another point:\n\n  >>> point = {\"type\": \"Polygon\",\n  ...          \"coordinates\": [[[0,0], [0,6], [2,6], [2,0], [0,0]]]}\n  >>> query = {\"lonlat\": {\"$within\": {\"$geometry\": point}}}\n  >>> printFind(collection, query)\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\nUsing the geospatial index we can find documents near another point:\n\n  >>> point = {'type': 'Point', 'coordinates': [0, 2]}\n  >>> printFind(collection, {'lonlat': {'$near': {'$geometry': point}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n  {u'__name__': u'sample2',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 2,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [4.0, 6.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample2'}\n\nIt's also possible to query for all items within a given rectangle\n(specified by lower-left and upper-right coordinates):\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$box': [[1,2], [2,3]]}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\nAs you can see if we use the wrong order for lon/lat (lat/lon), we will not\nget a value:\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$box': [[2,1], [3,2]]}}})\n\nWe can also search for a circle (specified by center point and radius):\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 2]}}})\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 4]}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 10]}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n  {u'__name__': u'sample2',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 2,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [4.0, 6.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample2'}\n\nAlso check if the lat/lon order matters:\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[1, 2], 1]}}})\n  {u'__name__': u'sample',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[2, 1], 1]}}})\n\n\nAnd check if we can store real lon/lat values by using a float:\n\n  >>> data = {'name': u'sample', 'lonlat': {'lon': 20.123, 'lat': 29.123}}\n  >>> sample3 = testing.GeoPointSample(data)\n  >>> root[u'sample3'] = sample3\n\n  >>> transaction.commit()\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[25, 25], 4]}}})\n\n  >>> printFind(collection, {'lonlat': {'$within': {'$center': [[25, 25], 10]}}})\n  {u'__name__': u'sample3',\n   u'_id': ObjectId('...'),\n   u'_pid': ObjectId('...'),\n   u'_type': u'GeoPointSample',\n   u'_version': 1,\n   u'created': datetime.datetime(..., tzinfo=UTC),\n   u'lonlat': {u'coordinates': [20.123, 29.123], u'type': u'Point'},\n   u'modified': datetime.datetime(..., tzinfo=UTC),\n   u'name': u'sample'}\n\n\ntear down\n---------\n\n  >>> from m01.mongo import clearThreadLocalCache\n  >>> clearThreadLocalCache()\n\nAs you can see our cache items get removed:\n\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\n========\nBatching\n========\n\nThe MongoMappingBase base class used by MongoStorage and MongoContainer can\nreturn batched data or items and batch information.\n\nNote; this test runs in level 2 because it uses a working MongoDB. This is\nneeded because we like to test the real sort and limit functions in a MongoDB.\n\n\nCondition\n---------\n\nBefor we start testing, check if our thread local cache is empty or if we have\nleft over some junk from previous tests:\n\n  >>> from m01.mongo.testing import pprint\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {}\n\nSetup\n-----\n\nFirst import some components:\n\n  >>> import datetime\n  >>> import transaction\n  >>> from m01.mongo import testing\n\n\nsetup\n-----\n\nNow we can add a MongoStorage to the database. Let's just use a simple\ndict as database root:\n\n  >>> root = {}\n  >>> storage = testing.SampleStorage()\n  >>> root['storage'] = storage\n  >>> transaction.commit()\n\nNow let's add 1000 MongoItems:\n\n  >>> storage = root['storage']\n  >>> for i in range(1000):\n  ...     data = {u'title': u'Title %i' % i,\n  ...             u'description': u'Description %i' % i,\n  ...             u'number': i}\n  ...     item = testing.SampleStorageItem(data)\n  ...     __name__ = storage.add(item)\n\n  >>> transaction.commit()\n\nAfter we commited to the MongoDB, the mongo object and our transaction data\nmanger reference should be gone in the thread local cache:\n\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {}\n\nAs you can see, our collection contains 1000 items:\n\n  >>> storage = root['storage']\n  >>> len(storage)\n  1000\n\n\nbatching\n--------\n\nNote, this method does not return items, it only returns the MongoDB data. This\nis what you should use. If this doesn't fit because you need a list of the real\nMongoItem this would be complicated beause we could have removed marked items\nin our LOCAL cache which the MongoDB doesn't know about.\n\nLet's get the batch information:\n\n  >>> storage.getBatchData()\n  (<...Cursor object at ...>, 1, 40, 1000)\n\nAs you an see, we've got a curser with mongo data, the start index, the total\namount of items and the page counter. Note, the first page starts at 1 (one)\nand not zero. Let's show another ample with different values:\n\n  >>> storage.getBatchData(page=5, size=10)\n  (<...Cursor object at ...>, 5, 100, 1000)\n\nAs you can see we can iterate our cursor:\n\n  >>> cursor, page, total, pages = storage.getBatchData(page=1, size=3)\n\n  >>> pprint(tuple(cursor))\n  ({'__name__': '...',\n    '_id': ObjectId('...'),\n    '_pid': None,\n    '_type': 'SampleStorageItem',\n    '_version': 1,\n    'comments': [],\n    'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    'description': 'Description ...',\n    'item': None,\n    'modified': datetime.datetime(..., tzinfo=UTC),\n    'number': ...,\n    'numbers': [],\n    'title': 'Title ...'},\n   {'__name__': '...',\n    '_id': ObjectId('...'),\n    '_pid': None,\n    '_type': 'SampleStorageItem',\n    '_version': 1,\n    'comments': [],\n    'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    'description': 'Description ...',\n    'item': None,\n    'modified': datetime.datetime(..., tzinfo=UTC),\n    'number': ...,\n    'numbers': [],\n    'title': 'Title ...'},\n   {'__name__': '...',\n    '_id': ObjectId('...'),\n    '_pid': None,\n    '_type': 'SampleStorageItem',\n    '_version': 1,\n    'comments': [],\n    'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    'description': 'Description ...',\n    'item': None,\n    'modified': datetime.datetime(..., tzinfo=UTC),\n    'number': ...,\n    'numbers': [],\n    'title': 'Title ...'})\n\nAs you can see, the cursor counts the total amount of items:\n\n  >>> cursor.count()\n  1000\n\nBut we can force to count the result based on limit and skip arguments by use\nTrue as argument:\n\n  >>> cursor.count(True)\n  3\n\nAs you can see batching or any other object lookup will left items back in our\nthread local cache. We can use our thread local cache cleanup event handler\nwhich is normal registered as an EndRequestEvent subscriber:\n\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {u'm01_mongo_testing.test...': {'added': {}, 'removed': {}}}\n\nLet's use our subscriber:\n\n  >>> from m01.mongo import clearThreadLocalCache\n  >>> clearThreadLocalCache()\n\nAs you can see our cache items get removed:\n\n  >>> from m01.mongo import LOCAL\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\norder\n-----\n\nAn important part in batching is ordering. As you can see, we can limit the\nbatch size and get a slice of data from a sequence. It is very important that\nthe data get ordered at the MongoDB before we slice the data into a batch.\nLet's test if this works based on our ordable number value and a sort order\nwhere lowest value comes first. Start with page=0:\n\n  >>> cursor, page, pages, total = storage.getBatchData(page=1, size=3,\n  ...     sortName='number', sortOrder=1)\n\n  >>> cursor\n  <pymongo.cursor.Cursor object at ...>\n\n  >>> page\n  1\n\n  >>> pages\n  334\n\n  >>> total\n  1000\n\nWhen ordering is done right, the first item should have a number value 0 (zero):\n\n  >>> pprint(tuple(cursor))\n  ({u'__name__': u'...',\n    u'_id': ObjectId('...'),\n    '_pid': None,\n    u'_type': u'SampleStorageItem',\n    u'_version': 1,\n    u'comments': [],\n    u'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    u'description': u'Description 0',\n    'item': None,\n    u'modified': datetime.datetime(..., tzinfo=UTC),\n    u'number': 0,\n    u'numbers': [],\n    u'title': u'Title 0'},\n   {u'__name__': u'...',\n    u'_id': ObjectId('...'),\n    '_pid': None,\n    u'_type': u'SampleStorageItem',\n    u'_version': 1,\n    u'comments': [],\n    u'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    u'description': u'Description 1',\n    'item': None,\n    u'modified': datetime.datetime(..., tzinfo=UTC),\n    u'number': 1,\n    u'numbers': [],\n    u'title': u'Title 1'},\n   {u'__name__': u'...',\n    u'_id': ObjectId('...'),\n    '_pid': None,\n    u'_type': u'SampleStorageItem',\n    u'_version': 1,\n    u'comments': [],\n    u'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    u'description': u'Description 2',\n    'item': None,\n    u'modified': datetime.datetime(..., tzinfo=UTC),\n    u'number': 2,\n    u'numbers': [],\n    u'title': u'Title 2'})\n\nThe second page (page=1) should start with number == 3:\n\n  >>> cursor, page, pages, total = storage.getBatchData(page=2, size=3,\n  ...     sortName='number', sortOrder=1)\n  >>> pprint(tuple(cursor))\n  ({u'__name__': u'...',\n    u'_id': ObjectId('...'),\n    '_pid': None,\n    u'_type': u'SampleStorageItem',\n    u'_version': 1,\n    u'comments': [],\n    u'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    u'description': u'Description 3',\n    'item': None,\n    u'modified': datetime.datetime(..., tzinfo=UTC),\n    u'number': 3,\n    u'numbers': [],\n    u'title': u'Title 3'},\n   {u'__name__': u'...',\n    u'_id': ObjectId('...'),\n    '_pid': None,\n    u'_type': u'SampleStorageItem',\n    u'_version': 1,\n    u'comments': [],\n    u'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    u'description': u'Description 4',\n    'item': None,\n    u'modified': datetime.datetime(..., tzinfo=UTC),\n    u'number': 4,\n    u'numbers': [],\n    u'title': u'Title 4'},\n   {u'__name__': u'...',\n    u'_id': ObjectId('...'),\n    '_pid': None,\n    u'_type': u'SampleStorageItem',\n    u'_version': 1,\n    u'comments': [],\n    u'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    u'description': u'Description 5',\n    'item': None,\n    u'modified': datetime.datetime(..., tzinfo=UTC),\n    u'number': 5,\n    u'numbers': [],\n    u'title': u'Title 5'})\n\nAs you can see your page size is 334. Let's show this batch slice. The\nitem in this batch should have a number == 999. but note:\n\n  >>> pages\n  334\n\n  >>> cursor, page, total, pages = storage.getBatchData(page=334, size=3,\n  ...     sortName='number', sortOrder=1)\n  >>> pprint(tuple(cursor))\n  ({u'__name__': u'...',\n    u'_id': ObjectId('...'),\n    '_pid': None,\n    u'_type': u'SampleStorageItem',\n    u'_version': 1,\n    u'comments': [],\n    u'created': datetime.datetime(..., tzinfo=UTC),\n    'date': None,\n    u'description': u'Description 999',\n    'item': None,\n    u'modified': datetime.datetime(..., tzinfo=UTC),\n    u'number': 999,\n    u'numbers': [],\n    u'title': u'Title 999'},)\n\n\nteardown\n--------\n\nCall transaction commit which will cleanup our LOCAL caches:\n\n  >>> transaction.commit()\n\nAgain, clear thread local cache:\n\n  >>> clearThreadLocalCache()\n\nCheck our thread local cache before we leave this test:\n\n  >>> pprint(LOCAL.__dict__)\n  {}\n\n\n=======\nTesting\n=======\n\nLet's test some testing methods.\n\n  >>> import re\n  >>> import datetime\n  >>> import bson.tz_util\n  >>> import m01.mongo\n  >>> import m01.mongo.testing\n  >>> from m01.mongo.testing import pprint\n\nRENormalizer\n------------\n\nThe RENormalizer is able to normalize text and produce comparable output. You\ncan setup the RENormalizer with a list of input, output expressions. This is\nusefull if you dump mongodb data which contains dates or other not so simple\nreproducable data. Such a dump result can get normalized before the unit test\nwill compare the output. Also see zope.testing.renormalizing for the same\npattern which is useable as a doctest checker.\n\n  >>> normalizer = m01.mongo.testing.RENormalizer([\n  ...    (re.compile('[0-9]*[.][0-9]* seconds'), '... seconds'),\n  ...    (re.compile('at 0x[0-9a-f]+'), 'at ...'),\n  ...    ])\n\n  >>> text = \"\"\"\n  ... <object object at 0xb7f14438>\n  ... completed in 1.234 seconds.\n  ... ...\n  ... <object object at 0xb7f14450>\n  ... completed in 1.234 seconds.\n  ... \"\"\"\n\n  >>> print normalizer(text)\n  <BLANKLINE>\n  <object object at ...>\n  completed in ... seconds.\n  ...\n  <object object at ...>\n  completed in ... seconds.\n  <BLANKLINE>\n\nNow let's test some mongodb relevant stuff:\n\n  >>> from bson.dbref import DBRef\n  >>> from bson.min_key import MinKey\n  >>> from bson.max_key import MaxKey\n  >>> from bson.objectid import ObjectId\n  >>> from bson.timestamp import Timestamp\n\n  >>> oid = m01.mongo.getObjectId(42)\n  >>> oid\n  ObjectId('0000002a0000000000000000')\n\n  >>> data = {'oid': oid,\n  ...         'dbref': DBRef(\"foo\", 5, \"db\"),\n  ...         'date': datetime.datetime(2011, 5, 7, 1, 12),\n  ...         'utc': datetime.datetime(2011, 5, 7, 1, 12, tzinfo=bson.tz_util.utc),\n  ...         'min': MinKey(),\n  ...         'max': MaxKey(),\n  ...         'timestamp': Timestamp(4, 13),\n  ...         're': re.compile(\"a*b\", re.IGNORECASE),\n  ...         'string': 'string',\n  ...         'unicode': u'unicode',\n  ...         'int': 42}\n\nNow let's pretty print the data:\n\n  >>> pprint(data)\n  {'date': datetime.datetime(...),\n   'dbref': DBRef('foo', 5, 'db'),\n   'int': 42,\n   'max': MaxKey(),\n   'min': MinKey(),\n   'oid': ObjectId('...'),\n   're': <_sre.SRE_Pattern object at ...>,\n   'string': 'string',\n   'timestamp': Timestamp('...'),\n   'unicode': 'unicode',\n   'utc': datetime.datetime(..., tzinfo=UTC)}\n\n\nreNormalizer\n~~~~~~~~~~~~\n\nAs you can see our predefined reNormalizer will convert the values using our\ngiven patterns:\n\n  >>> import m01.mongo.testing\n  >>> res = m01.mongo.testing.reNormalizer(data)\n  >>> print res\n  {'date': datetime.datetime(...),\n   'dbref': DBRef('foo', 5, 'db'),\n   'int': 42,\n   'max': MaxKey(),\n   'min': MinKey(),\n   'oid': ObjectId('...'),\n   're': <_sre.SRE_Pattern object at ...>,\n   'string': 'string',\n   'timestamp': Timestamp('...'),\n   'unicode': u'unicode',\n   'utc': datetime.datetime(..., tzinfo=UTC)}\n\n\npprint\n~~~~~~\n\n  >>> m01.mongo.testing.reNormalizer.pprint(data)\n  {'date': datetime.datetime(...),\n   'dbref': DBRef('foo', 5, 'db'),\n   'int': 42,\n   'max': MaxKey(),\n   'min': MinKey(),\n   'oid': ObjectId('...'),\n   're': <_sre.SRE_Pattern object at ...>,\n   'string': 'string',\n   'timestamp': Timestamp('...'),\n   'unicode': u'unicode',\n   'utc': datetime.datetime(..., tzinfo=UTC)}\n\n\nUTC\n---\n\nThe pymongo library offers a custom UTC implementation including pickle support\nused by deepcopy. Let's test if this implementation works and replace our custom\ntimezone with the bson.tz_info.utc:\n\n  >>> dt = data['utc']\n  >>> dt\n  datetime.datetime(2011, 5, 7, 1, 12, tzinfo=UTC)\n\n  >>> import copy\n  >>> copy.deepcopy(dt)\n  datetime.datetime(2011, 5, 7, 1, 12, tzinfo=UTC)\n\n===========================\nSpeedup your implementation\n===========================\n\nSince not every strategy is the best for every applications and we can't\nimplement all concepts in this package, we will list here some imporvements.\n\n\nvalues and items\n----------------\n\nThe MongoContainers and MongoStorage implementation will load all data within\nthe values and items methods. Even if we already cached them in our thread\nlocal cache. Here is an optimized method which could get used if you need to\nload a large set of data.\n\nThe original implementation of MongoMappingBase.values looks like::\n\n    def values(self):\n        # join transaction handling\n        self.ensureTransaction()\n        for data in self.doFind(self.collection):\n            __name__ = data['__name__']\n            if __name__ in self._cache_removed:\n                # skip removed items\n                continue\n            obj = self._cache_loaded.get(__name__)\n            if obj is None:\n                try:\n                    # load, locate and cache if not cached\n                    obj = self.doLoad(data)\n                except (KeyError, TypeError):\n                    continue\n            yield obj\n        # also return items not stored in MongoDB yet\n        for k, v in self._cache_added.items():\n            yield v\n\nIf you like to prevent loading all data, you could probably only load\nkeys and lookup data for items which didn't get cached yet. This would\nreduce network traffic and could look like::\n\n    def values(self):\n        # join transaction handling\n        self.ensureTransaction()\n        # only get __name__ and _id\n        for data in self.doFind(self.collection, {}, ['__name__', '_id']):\n            __name__ = data['__name__']\n            if __name__ in self._cache_removed:\n                # skip removed items\n                continue\n            obj = self._cache_loaded.get(__name__)\n            if obj is None:\n                try:\n                    # now we can load data from mongo\n                    d = self.doFindOne(self.collection, data)\n                    # load, locate and cache if not cached\n                    obj = self.doLoad(d)\n                except (KeyError, TypeError):\n                    continue\n            yield obj\n        # also return items not stored in MongoDB yet\n        for k, v in self._cache_added.items():\n            yield v\n\nNote: the same concept can get used for the items method.\n\nNote: I don't recommend to call keys, values or items for large collections\nat any time. Take a look at the batching concept we implemented. The\ngetBatchData method is probably what you need to use with a large set of data.\n\n\nAdvancedConverter\n-----------------\n\nThe class below shows an advanced implementation which is able to convert a\nnested data structure.\n\nNormaly a converter can convert attribute values. If the attribute\nvalue is a list of items which contains another list of items, then you need to\nuse another converter which is able to convert this nested structure. But\nnormaly this is the responsibility of the first level item to convert it's\nvalues. This is the reason why we didn't implement this concept by default.\n\nRemember, a default converter definition looks like::\n\n  def itemConverter(value):\n      _type = value.get('_type')\n      if _type == 'Car':\n          return Car\n      if _type == 'House':\n          return House\n      else:\n          return value\n\nAnd the class defines something like::\n\n  converters = {'myItems': itemConverter}\n\nOur advanced converter sample can convert a nested data structure and looks\nlike::\n\n  def toCar(value):\n      return Car(value)\n\n  converters = {'myItems': {'House': toHouse, 'Car': toCar}}\n\n  class AdvancedConverter(object):\n\n      converters = {} # attr-name/converter or {_type:converter}\n      def convert(self, key, value):\n          \"\"\"This convert method knows how to handle nested converters.\"\"\"\n          converter = self.converters.get(key)\n          if converter is not None:\n              if isinstance(converter, dict):\n                  if isinstance(value, (list, tuple)):\n                      res = []\n                      for o in value:\n                          if isinstance(o, dict):\n                              _type = o.get('_type')\n                              if _type is not None:\n                                  converter = converter.get(_type)\n                                  value = converter(o)\n                          res.append(value)\n                      value = res\n                  elif isinstance(value, dict):\n                      _type = o.get('_type')\n                      if _type is not None:\n                          converter = converter.get(_type)\n                          value = converter(value)\n                  else:\n                      value = converter(value)\n              else:\n                  if isinstance(value, (list, tuple)):\n                      # convert list values\n                      value = [converter(d) for d in value]\n                  else:\n                      # convert simple values\n                      value = converter(value)\n          return value\n\nI'm sure if you understand what we implemented, you will find a lot of space\nto improve and write your own special methods which can do the right thing for\nyour use cases.\n\n\n=======\nCHANGES\n=======\n\n3.3.1 (2020-04-22)\n------------------\n\n- bugfix: register MongoListData class and allow interface IMongoListData.\n  This allows to access the internal implementation like a simply built in\n  type. Note: the object property using this implementation is still protected.\n  We just let our instance act like a buit in simply python type.\n\n\n3.3.0 (2018-02-04)\n------------------\n\n- use new p01.env package for pymongo client environment setup\n\n\n3.2.3 (2018-02-04)\n------------------\n\n- bugfix: removed FakeMongoConnectionPool from mongo client testing setup\n\n- set MONGODB_CONNECT to False as default because client setup takes too long\n  for testing setup. Add MONGODB_CONNECT to your os environment if you need\n  to connect on application startup.\n\n\n3.2.2 (2018-01-29)\n------------------\n\n- bugfix: fix timeout milli seconds and MONGODB_REVOCATION_LIST attr usage\n\n\n3.2.1 (2018-01-29)\n------------------\n\n- bugfix: multiply MONGODB_SERVER_SELECTION_TIMEOUT with 1000because it's used\n  as milli seconds\n\n\n3.2.0 (2018-01-29)\n------------------\n\n- feature: implemented pymongo client setup based on enviroment variables and\n  default settings.py file\n\n\n3.1.0 (2017-01-22)\n------------------\n\n- bugfix: make sure we override existing mongodb values with None if None is\n  given as value in python object. Previous versions didn't override existing values with None. The new implementation will use the default schema value\n  as mongodb value even if default is None. Note, this will break existing\n  test output.\n\n- bugfix: fix performance test setup, conditional include ZODB for performance\n  tests. Supported with extras_require in setup.py.\n\n\n3.0.0 (2015-11-11)\n------------------\n\n- Use 3.0.0 as package version and reflect pymongo > 3.0.0 compatibility.\n\n- feature: change internal doFind, doInsert and doRemove methods, remove old\n  method arguments like safe etc..\n\n- feature: reflect changes in pymongo > 3.0.0. Replace disconnect with close\n  method like the MongoClient does.\n\n- removed MongoConnectionPool, replace them with MongoClient in your code. There\n  is no need for a thread safe connection pool since pymongo is thread safe.\n  Also replace MongoConnection with MongoClient in your test code.\n\n- switch from m01.mongofake to m01.fake including pymongo >= 3.0.0 support\n\n- remove write_concern options in mapping base class. The MongoClient should\n  define the right write concern.\n\n\n1.0.0 (2015-03-17)\n------------------\n\n- improve AttributeError handling on object setup. Additional catch ValueError\n  and zope.interface.Invalid and raise AttributeError with detailed attribute\n  and value information\n\n\n0.11.1 (2014-04-10)\n-------------------\n\n- feature: changed mongo client max_pool_size value from 10MB to 100MB which\n  reflects changes in pymongo >= 2.6.\n\n\n0.11.0 (2013-1-23)\n-------------------\n\n- implement GeoPoint used for 2dsphere geo location indexes. Also provide a\n  MongoGeoPointProperty which is able to create such GeoPoint items.\n\n\n0.10.2 (2013-01-04)\n-------------------\n\n- support _m_insert_write_concern, _m_update_write_concern,\n  _m_remove_write_concern in MongoObject\n\n\n0.10.1 (2012-12-19)\n-------------------\n\n- feature: implemented MongoDatetime schema field supporting timezone info\n  attribute (tzinfo=UTC).\n\n\n0.10.0 (2012-12-16)\n-------------------\n\n- switch from Connection to MongoClient recommended since pymongo 2.4. Replaced\n  safe with write concern options. By default pymongo will now use safe writes.\n\n- use MongoClient as factory in MongoConnectionPool. We didn't rename the class\n  MongoConnectionPool, we will keep them as is. We also don't rename the\n  IMongoConnectionPool interface.\n\n- replaced _m_safe_insert, _m_safe_update, _m_safe_remove with\n  _m_insert_write_concern, _m_update_write_concern, _m_remove_write_concern.\n  This new mapping base class options are an empty dict and can get replaced\n  with the new write concern settings. The default empty dict will force to\n  use the write concern defined in the connection.\n\n\n0.9.0 (2012-12-10)\n------------------\n\n- use m01.mongofake for fake mongodb, collection and friends\n\n\n0.8.0 (2012-11-18)\n------------------\n\n- bugfix: add missing security declaration for dump data\n\n- switch to bson import\n\n- reflect changes in test output based on pymongo 2.3\n\n- remove p01.i18n package dependency\n\n- improve, prevent mark items as changed for same values\n\n- improve sort, support key or list as sortName and allow to skip sortOrder if\n  sortName is given\n\n- added MANIFEST.in file\n\n\n0.7.0 (2012-05-22)\n------------------\n\n- bugfix: FakeCollection.remove: use find to find documents\n\n- preserve order by using SON for query filter and dump methods\n\n- implemented m01.mongo.dictify which can recoursive replace all bson.son.SON\n  with plain dict instances.\n\n\n0.6.2 (2012-03-12)\n------------------\n\n- bugfix: left out a method\n\n\n0.6.1 (2012-03-12)\n------------------\n\n- bugfix: return self in FakeMongoConnection __call__method. This let's an\n  instance act similar then the original pymongo Connection class __init__\n  method.\n\n- feature: Add `sort` parameter for FakeMongoConnection.find()\n\n0.6.0 (2012-01-17)\n------------------\n\n- bugfix: During a query, if a spec key is missing from the doc, the doc is\n  always ignored.\n\n- bugfix: correctly generate an object id in UTC. It was relying on GMT+1\n  (i.e. Roger's timezone).\n\n- bugfix: allow to use None as MongoDateProperty value\n\n- bugfix: set __parent__ in MongoSubItem __init__ method if given\n\n- implemented _m_initialized as a marker for find out when we need to trace\n  changed attributes\n\n- implemented clear method in MongoListData and MongoItemsData which allows to\n  remove sequence items at once wihout to pop each item from the sequence\n\n- improve MongoObject implementation, implemented _field which stores the\n  parent field name which the MongoObject is stored at. Also adjsut the\n  MongoObjectProperty and support backward compatibility by apply the previous\n  stored __name__ as _field if not given. This new _field and __name__\n  separation allos us to use explicit names e.g. the _id or custom names which\n  we can use for traversing to a MongoObject via traverser or other container\n  like implementations.\n\n- Implemented __getattr__ in FakeCollection. This allows to get a sub\n  collection like in pymongo which is a part of the gridfs concept.\n\n\n0.5.5 (2011-10-14)\n------------------\n\n- Implement filtering with dot notation\n\n\n0.5.4 (2011-09-27)\n------------------\n\n- Fix: a real mongo DB accepts tuple as the `fields` parameter of `find`.\n\n\n0.5.3 (2011-09-20)\n------------------\n\n- Fix minimum filtering expressions (Albertas)\n\n\n0.5.2 (2011-09-19)\n------------------\n\n- Added minimum filtering expressions (Albertas)\n\n- moved created and modified to an own interface called ICreatedModified\n\n- implemented simple and generic initial geo location support\n\n\n0.5.1 (2011-09-09)\n------------------\n\n- fix performance test\n- Added database_names and collection_names\n\n\n0.5.0 (2011-08-19)\n------------------\n\n- initial release\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/m01.mongo", "keywords": "Zope3 z3c p01 m01 mongo connection pool container", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "m01.mongo", "package_url": "https://pypi.org/project/m01.mongo/", "platform": "", "project_url": "https://pypi.org/project/m01.mongo/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/m01.mongo"}, "release_url": "https://pypi.org/project/m01.mongo/3.3.1/", "requires_dist": null, "requires_python": "", "summary": "MongoDB connection pool and container implementation for Zope3", "version": "3.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides a mongodb object mapper framework including zope\ntransaction support based on some core zope component libraries. This package\ncan get used with or without zope.persistent and as a full replacement for the\nZODB. The package is not heavy based on zope itself and can get used in any\npython project which requires a bridge from mongodb to python object.</p>\n<div id=\"readme\">\n<h2>README</h2>\n<p>IMPORTANT:\nIf you run the tests with the \u2013all option a real mongodb stub server will\nstart at port 45017!</p>\n<p>This package provides non persistent MongoDB object implementations. They can\nsimply get mixed with persistent.Persistent and contained.Contained if you like\nto use them in a mixed MongoDB/ZODB application setup. We currently use this\nframework as ORM (object relation mapper) where we map MongoDB objects\nto python/zope schema based objects including validation etc.</p>\n<p>In our last project, we started with a mixed ZODB/MongoDB application where we\nmixed persistent.persistent into IMongoContainer objects. But later we where\nso exited about the performance and stability that we removed the ZODB\npersistence layer at all. Now we use a ZODB less setup in our application\nwhere we start with a non persistent item as our application root. All required\ntools where we use for such a ZODB less application setup are located in the\np01.publisher and p01.recipe.setup package.</p>\n<p>NOTE: Some of this test use a fake mongodb located in m01/mongo/testing and some\nother tests will use our mongdb stub from the m01.stub package. You can run\nthe tests with the \u2013all option if you like to run the full tests which will\nstart and stop the mongodb stub server.</p>\n<p>NOTE:\nAll mongo item interfaces will not provide ILocation or IContained but the\nbase mongo item implementations will implement Location which provides the\nILocation interface directly. This makes it simpler for permission\ndeclaration in ZCML.</p>\n<div id=\"setup\">\n<h3>Setup</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; import pymongo\n&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from m01.mongo import interfaces\n</pre>\n</blockquote>\n</div>\n<div id=\"mongoclient\">\n<h3>MongoClient</h3>\n<p>Setup a mongo client:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client = pymongo.MongoClient('localhost', 45017)\n&gt;&gt;&gt; client\nMongoClient(host=['127.0.0.1:45017'])\n</pre>\n</blockquote>\n<p>As you can see the client is able to access the database:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; db = client.m01MongoTesting\n&gt;&gt;&gt; db\nDatabase(MongoClient(host=['127.0.0.1:45017']), u'm01MongoTesting')\n</pre>\n</blockquote>\n<p>A data base can retrun a collection:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; collection = db['m01MongoTest']\n&gt;&gt;&gt; collection\nCollection(Database(MongoClient(host=['127.0.0.1:45017']), u'm01MongoTesting'), u'm01MongoTest')\n</pre>\n</blockquote>\n<p>As you can see we can write to the collection:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = collection.update_one({'_id': '123'}, {'$inc': {'counter': 1}},\n...     upsert=True)\n&gt;&gt;&gt; res\n&lt;pymongo.results.UpdateResult object at ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; res.raw_result\n{'updatedExisting': False, 'nModified': 0, 'ok': 1, 'upserted': '123', 'n': 1}\n</pre>\n</blockquote>\n<p>And we can read from the collection:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; collection.find_one({'_id': '123'})\n{u'_id': u'123', u'counter': 1}\n</pre>\n</blockquote>\n<p>Remove the result from our test collection:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = collection.delete_one({'_id': '123'})\n&gt;&gt;&gt; res\n&lt;pymongo.results.DeleteResult object at ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; res.raw_result\n{'ok': 1, 'n': 1}\n</pre>\n</blockquote>\n</div>\n<div id=\"tear-down\">\n<h3>tear down</h3>\n<p>Now tear down our MongoDB database with our current MongoDB connection:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import time\n&gt;&gt;&gt; time.sleep(1)\n&gt;&gt;&gt; client.drop_database('m01MongoTesting')\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"mongocontainer\">\n<h2>MongoContainer</h2>\n<p>The MongoContainer can store IMongoContainerItem objects in a MongoDB. A\nMongoContainerItem must be able to dump it\u2019s data to valid mongodb data. This\ntest will show how our MongoContainer works.</p>\n<div id=\"condition\">\n<h3>Condition</h3>\n<p>First import some components:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import json\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; import zope.schema\n&gt;&gt;&gt; import m01.mongo.item\n&gt;&gt;&gt; import m01.mongo.testing\n&gt;&gt;&gt; from m01.mongo.fieldproperty import MongoFieldProperty\n&gt;&gt;&gt; from m01.mongo import interfaces\n</pre>\n</blockquote>\n<p>Befor we start testing, check if our thread local cache is empty or if we have\nleft over some junk from previous tests:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; m01.mongo.testing.pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"id1\">\n<h3>Setup</h3>\n<p>And set up a database root:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root = {}\n</pre>\n</blockquote>\n</div>\n<div id=\"mongocontaineritem\">\n<h3>MongoContainerItem</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; class ISampleContainerItem(interfaces.IMongoContainerItem,\n...     zope.location.interfaces.ILocation):\n...     \"\"\"Sample item interface.\"\"\"\n...\n...     title = zope.schema.TextLine(\n...         title=u'Object Title',\n...         description=u'Object Title',\n...         required=True)\n</pre>\n<pre>&gt;&gt;&gt; class SampleContainerItem(m01.mongo.item.MongoContainerItem):\n...     \"\"\"Sample container item\"\"\"\n...\n...     zope.interface.implements(ISampleContainerItem)\n...\n...     title = MongoFieldProperty(ISampleContainerItem['title'])\n...\n...     dumpNames = ['title']\n</pre>\n</blockquote>\n</div>\n<div id=\"id2\">\n<h3>MongoContainer</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; class ISampleContainer(interfaces.IMongoContainer):\n...     \"\"\"Sample container interface.\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; class SampleContainer(m01.mongo.container.MongoContainer):\n...     \"\"\"Sample container.\"\"\"\n...\n...     zope.interface.implements(ISampleContainer)\n...\n...     @property\n...     def collection(self):\n...         db = m01.mongo.testing.getTestDatabase()\n...         return db['test']\n...\n...     def load(self, data):\n...         \"\"\"Load data into the right mongo item.\"\"\"\n...         return SampleContainerItem(data)\n</pre>\n<pre>&gt;&gt;&gt; container = SampleContainer()\n&gt;&gt;&gt; root['container'] = container\n</pre>\n</blockquote>\n</div>\n<div id=\"create-an-object-tree\">\n<h3>Create an object tree</h3>\n<p>Now we can add a sample MongoContainerItem to our container using the mapping\napi:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'title': u'Title'}\n&gt;&gt;&gt; item = SampleContainerItem(data)\n&gt;&gt;&gt; container = root['container']\n&gt;&gt;&gt; container[u'item'] = item\n</pre>\n</blockquote>\n</div>\n<div id=\"transaction\">\n<h3>Transaction</h3>\n<p>Zope provides transactions for store objects in the database. We also provide\nsuch a transaction and a transation data manager for store our objects in the\nmongodb. This means right now nothing get stored in our test database because\nwe didn\u2019t commit the transaction:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; collection = m01.mongo.testing.getTestCollection()\n&gt;&gt;&gt; collection.count()\n0\n</pre>\n</blockquote>\n<p>Let\u2019s commit our transaction an store the container item in mongodb:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; collection = m01.mongo.testing.getTestCollection()\n&gt;&gt;&gt; collection.count()\n1\n</pre>\n</blockquote>\n<p>After commit, the thread local storage is empty:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; LOCAL.__dict__\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"mongodb-data\">\n<h3>Mongodb data</h3>\n<p>As you can see the following data get stored in our mongodb:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = collection.find_one({'__name__': 'item'})\n&gt;&gt;&gt; m01.mongo.testing.pprint(data)\n{u'__name__': u'item',\n u'_id': ObjectId('...'),\n u'_pid': None,\n u'_type': u'SampleContainerItem',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'title': u'Title'}\n</pre>\n</blockquote>\n</div>\n<div id=\"object\">\n<h3>Object</h3>\n<p>We can get from our container and mongo will load the data from mongodb:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj = container[u'item']\n&gt;&gt;&gt; obj\n&lt;SampleContainerItem u'item'&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj.title\nu'Title'\n</pre>\n</blockquote>\n<p>Let\u2019s tear down our test setup:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; from m01.mongo import clearThreadLocalCache\n&gt;&gt;&gt; clearThreadLocalCache()\n</pre>\n</blockquote>\n<p>As you can see our cache items get removed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; m01.mongo.testing.pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"mongostorage\">\n<h2>MongoStorage</h2>\n<p>The MongoStorage can store IMongoStorageItem objects in a MongoDB. A\nMongoStorageItem must be able to dump it\u2019s data to valid mongo values. This\ntest will show how our MongoStorage works and also shows the limitations.</p>\n<p>Note: the mongo container also implements a container/mapping pattern like the\nstorage implementation. The only difference is, the container only provides the\nmapping api using contaner[key] = obj, container[key] and del container[key].\nThe storage api provides no explicit mapping key and offers add and remove\nmethods instead. This means the container uses it\u2019s own naming pattern and the\nstorage is using the mongodb._id as it\u2019s object name (obj.__name__).</p>\n<div id=\"id3\">\n<h3>Condition</h3>\n<p>Befor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; from m01.mongo.testing import pprint\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"id4\">\n<h3>Setup</h3>\n<p>First import some components:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; from zope.container.interfaces import IReadContainer\n&gt;&gt;&gt; from m01.mongo import interfaces\n&gt;&gt;&gt; from m01.mongo import testing\n</pre>\n</blockquote>\n<p>And set up a database root:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root = {}\n</pre>\n</blockquote>\n</div>\n<div id=\"mongostorageitem\">\n<h3>MongoStorageItem</h3>\n<p>The mongo item provides by default a ObjectId stored as _id. If there is none\ngiven during create an object, we will set one:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {}\n&gt;&gt;&gt; obj = testing.SampleStorageItem(data)\n&gt;&gt;&gt; obj._id\nObjectId('...')\n</pre>\n</blockquote>\n<p>The ObjectId is also use as our __name__  value. See the MongoContainer and\nMongoContainerItem implementation if you need to choose your own names:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.__name__\nu'...'\n</pre>\n<pre>&gt;&gt;&gt; obj.__name__ == unicode(obj._id)\nTrue\n</pre>\n</blockquote>\n<p>A mongo item also provides created and modified date attributes. If we\ninitialize an object without a given created date, a new utc datetime instance\nget used:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.created\ndatetime.datetime(..., tzinfo=UTC)\n</pre>\n<pre>&gt;&gt;&gt; obj.modified is None\nTrue\n</pre>\n</blockquote>\n<p>A mongo storage item knows if a state get changed. This means we can find out\nif we should write the item back to the MongoDB. The MongoItem stores the state\nin a _m_changed value like persistent objects do in _p_changed. As you can see\nthe initial state is <tt>`None</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj._m_changed is None\nTrue\n</pre>\n</blockquote>\n<p>The MongoItem also has a version number which we increment each time we change\nthe item. By default this version is set as _version attribute and set by\ndefault to 0 (zero):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj._version\n0\n</pre>\n</blockquote>\n<p>If we change a value in a MongoItem, the state get changed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.title = u'New Title'\n&gt;&gt;&gt; obj._m_changed\nTrue\n</pre>\n</blockquote>\n<p>but the version get not imcremented. We only imcrement the version if we save\nthe item in MongoDB:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj._version\n0\n</pre>\n</blockquote>\n<p>We also change the _m_change marker if we remove a value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj = testing.SampleStorageItem(data)\n&gt;&gt;&gt; obj._m_changed is None\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj.title\nu''\n</pre>\n<pre>&gt;&gt;&gt; obj.title = u'New Title'\n&gt;&gt;&gt; obj._m_changed\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj.title\nu'New Title'\n</pre>\n</blockquote>\n<p>Now let\u2019s set the _m_chande property set to False before we delete the attr:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj._m_changed = False\n&gt;&gt;&gt; obj._m_changed\nFalse\n</pre>\n<pre>&gt;&gt;&gt; del obj.title\n</pre>\n</blockquote>\n<p>As you can see we can delete an attribute but it only falls back to the default\nschema field value. This seems fine.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.title\nu''\n</pre>\n<pre>&gt;&gt;&gt; obj._m_changed\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"id5\">\n<h3>MongoStorage</h3>\n<p>Now we can add a MongoStorage to the zope datbase:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; storage = testing.SampleStorage()\n&gt;&gt;&gt; root['storage'] = storage\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Now we can add a sample MongoStorageItem to our storage. Note we can only use the\nadd method which will return the new generated __name__. Using own names is not\nsupported by this implementation. As you can see the name is an MongoDB\n24 hex character string objectId representation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'title': u'Title',\n...         'description': u'Description'}\n&gt;&gt;&gt; item = testing.SampleStorageItem(data)\n&gt;&gt;&gt; storage = root['storage']\n</pre>\n</blockquote>\n<p>Our storage provides the IMongoStorage and IReadContainer interfaces:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interfaces.IMongoStorage.providedBy(storage)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; IReadContainer.providedBy(storage)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"add\">\n<h3>add</h3>\n<p>We can add a mongo item to our storage by using the add method.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; __name__ = storage.add(item)\n&gt;&gt;&gt; __name__\nu'...'\n&gt;&gt;&gt; len(__name__)\n24\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>After adding our item, the item provides a created date:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item.created\ndatetime.datetime(..., tzinfo=UTC)\n</pre>\n</blockquote>\n</div>\n<div id=\"len\">\n<h3>__len__</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; storage = root['storage']\n&gt;&gt;&gt; len(storage)\n1\n</pre>\n</blockquote>\n</div>\n<div id=\"getitem\">\n<h3>__getitem__</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; item = storage[__name__]\n&gt;&gt;&gt; item\n&lt;SampleStorageItem ...&gt;\n</pre>\n</blockquote>\n<p>As you can see our MongoStorageItem provides the following data. We can dump\nthe item. Note, you probaly have to implement a custom dump method which will\ndump the right data for you MongoStorageItem.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(item.dump())\n{'__name__': '...',\n '_id': ObjectId('...'),\n '_pid': None,\n '_type': 'SampleStorageItem',\n '_version': 1,\n 'comments': [],\n 'created': datetime.datetime(..., tzinfo=UTC),\n 'date': None,\n 'description': 'Description',\n 'item': None,\n 'modified': datetime.datetime(..., tzinfo=UTC),\n 'number': None,\n 'numbers': [],\n 'title': 'Title'}\n</pre>\n</blockquote>\n<p>The object provides also a name which is the name we\u2019ve got during adding the\nobject:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item.__name__ == __name__\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"keys\">\n<h3>keys</h3>\n<p>The container can also return key:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tuple(storage.keys())\n(u'...',)\n</pre>\n</blockquote>\n</div>\n<div id=\"values\">\n<h3>values</h3>\n<p>The container can also return values:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tuple(storage.values())\n(&lt;SampleStorageItem ...&gt;,)\n</pre>\n</blockquote>\n</div>\n<div id=\"items\">\n<h3>items</h3>\n<p>The container can also return items:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tuple(storage.items())\n((u'...', &lt;SampleStorageItem ...&gt;),)\n</pre>\n</blockquote>\n</div>\n<div id=\"delitem\">\n<h3>__delitem__</h3>\n<p>As next we will remove the item:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del storage[__name__]\n&gt;&gt;&gt; storage.get(__name__) is None\nTrue\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n</div>\n<div id=\"object-modification\">\n<h3>Object modification</h3>\n<p>If we get a mongo item from a storage and modify the item, the version get\nincreased by one and a current modified datetime get set.</p>\n<p>Let\u2019s add a new item:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'title': u'A Title',\n...         'description': u'A Description'}\n&gt;&gt;&gt; item = testing.SampleStorageItem(data)\n&gt;&gt;&gt; __name__ = storage.add(item)\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Now get the item:</p>\n<pre>&gt;&gt;&gt; item = storage[__name__]\n&gt;&gt;&gt; item.title\nu'A Title'\n</pre>\n<p>and change the titel:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item.title = u'New Title'\n&gt;&gt;&gt; item.title\nu'New Title'\n</pre>\n</blockquote>\n<p>As you can see the item get marked as changed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item._m_changed\nTrue\n</pre>\n</blockquote>\n<p>Now get the mongo item version. This should be set to 1 (one) since we only\nadded the object and didn\u2019t change since we added them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item._version\n1\n</pre>\n</blockquote>\n<p>If we now commit the transaction, the version get increased by one:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; item._version\n2\n</pre>\n</blockquote>\n<p>If you now load the mongo item from the MongoDB aain, you can see that the\ntitle get changed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = storage[__name__]\n&gt;&gt;&gt; item.title\nu'New Title'\n</pre>\n</blockquote>\n<p>And that the version get updated to 2:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item._version\n2\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Check our thread local cache before we leave this test:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"shared-mongocontainer\">\n<h2>Shared MongoContainer</h2>\n<p>The MongoContainer can store non persistent IMongoContainerItem objects in a\nMongoDB. A MongoContainerItem must be able to dump it\u2019s data to valid mongo\nvalues. This test will show how our MongoContainer works.</p>\n<div id=\"id6\">\n<h3>Condition</h3>\n<p>Befor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo.testing import pprint\n&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"id7\">\n<h3>Setup</h3>\n<p>First import some components:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; from zope.container.interfaces import IContainer\n</pre>\n<pre>&gt;&gt;&gt; import m01.mongo\n&gt;&gt;&gt; import m01.mongo.base\n&gt;&gt;&gt; import m01.mongo.container\n&gt;&gt;&gt; from m01.mongo import interfaces\n&gt;&gt;&gt; from m01.mongo import testing\n</pre>\n</blockquote>\n<p>We also need a application root object. Let\u2019s define a static MongoContainer\nas our application database root item.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MongoRoot(m01.mongo.container.MongoContainer):\n...     \"\"\"Mongo application root\"\"\"\n...\n...     _id = m01.mongo.getObjectId(0)\n...\n...     def __init__(self):\n...         pass\n...\n...     @property\n...     def collection(self):\n...         return testing.getRootItems()\n...\n...     @property\n...     def cacheKey(self):\n...         return 'root'\n...\n...     def load(self, data):\n...         \"\"\"Load data into the right mongo item.\"\"\"\n...         return testing.Companies(data)\n...\n...     def __repr__(self):\n...         return '&lt;%s %s&gt;' % (self.__class__.__name__, self._id)\n</pre>\n</blockquote>\n<p>As you can see our MongoRoot class defines a static mongo ObjectID as _id. This\nmeans the same _id get use every time. This _id acts as our __parent__\nreference.</p>\n<p>The following method allows us to generate new MongoRoot item instances. This\nallows us to show that we generate different root items like we would do on a\nserver restart.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def getRoot():\n...     return MongoRoot()\n</pre>\n</blockquote>\n<p>Here is our database root item:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root = getRoot()\n&gt;&gt;&gt; root\n&lt;MongoRoot 000000000000000000000000&gt;\n</pre>\n<pre>&gt;&gt;&gt; root._id\nObjectId('000000000000000000000000')\n</pre>\n</blockquote>\n</div>\n<div id=\"containers\">\n<h3>Containers</h3>\n<p>Now let\u2019s use our enhanced testing data and setup a content structure:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'name': u'Europe'}\n&gt;&gt;&gt; europe = testing.Companies(data)\n&gt;&gt;&gt; root[u'europe'] = europe\n</pre>\n<pre>&gt;&gt;&gt; data = {'name': u'Asia'}\n&gt;&gt;&gt; asia = testing.Companies(data)\n&gt;&gt;&gt; root[u'asia'] = asia\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Let\u2019s check our companies in Mongo:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; rootCollection = testing.getRootItems()\n&gt;&gt;&gt; obj = rootCollection.find_one({'name': 'Europe'})\n&gt;&gt;&gt; pprint(obj)\n{u'__name__': u'europe',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'Companies',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'Europe'}\n</pre>\n</blockquote>\n<p>Now let\u2019s add a Company, Employer and some documents:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'name': u'Projekt01 GmbH'}\n&gt;&gt;&gt; pro = testing.Company(data)\n&gt;&gt;&gt; europe[u'pro'] = pro\n</pre>\n<pre>&gt;&gt;&gt; data = {'name': u'Roger Ineichen'}\n&gt;&gt;&gt; roger = testing.Employer(data)\n&gt;&gt;&gt; pro[u'roger'] = roger\n</pre>\n<pre>&gt;&gt;&gt; data = {'name': u'Manual'}\n&gt;&gt;&gt; manual = testing.Document(data)\n&gt;&gt;&gt; roger[u'manual'] = manual\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>As you can see we added a data structure using our container, item objects:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root['europe']\n&lt;Companies u'europe'&gt;\n</pre>\n<pre>&gt;&gt;&gt; root['europe']['pro']\n&lt;Company u'pro'&gt;\n</pre>\n<pre>&gt;&gt;&gt; root['europe']['pro']['roger']\n&lt;Employer u'roger'&gt;\n</pre>\n<pre>&gt;&gt;&gt; root['europe']['pro']['roger']['manual']\n&lt;Document u'manual'&gt;\n</pre>\n</blockquote>\n<p>As you can see this structure is related to their __parent__ references. This\nmeans if we add another structure into the same mongodb, each item knows it\u2019s\ncontainer.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'name': u'Credit Suisse'}\n&gt;&gt;&gt; cs = testing.Company(data)\n&gt;&gt;&gt; asia[u'cs'] = cs\n</pre>\n<pre>&gt;&gt;&gt; data = {'name': u'Max Muster'}\n&gt;&gt;&gt; max = testing.Employer(data)\n&gt;&gt;&gt; cs[u'max'] = max\n</pre>\n<pre>&gt;&gt;&gt; data = {'name': u'Paper'}\n&gt;&gt;&gt; paper = testing.Document(data)\n&gt;&gt;&gt; max[u'paper'] = paper\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; root['asia']\n&lt;Companies u'asia'&gt;\n</pre>\n<pre>&gt;&gt;&gt; root['asia']['cs']\n&lt;Company u'cs'&gt;\n</pre>\n<pre>&gt;&gt;&gt; root['asia']['cs']['max']\n&lt;Employer u'max'&gt;\n</pre>\n<pre>&gt;&gt;&gt; root['asia']['cs']['max']['paper']\n&lt;Document u'paper'&gt;\n</pre>\n</blockquote>\n<p>We can\u2019t access another item from the same type from another parent container:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root['europe']['cs']\nTraceback (most recent call last):\n...\nKeyError: 'cs'\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>As you can see the KeyError left items back in our thread local cache. We can\nuse our thread local cache cleanup event handler which is by default registered\nas an EndRequestEvent subscriber for cleanup our thread local cache:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{u'europe': {'loaded': {}, 'removed': {}}}\n</pre>\n</blockquote>\n<p>Let\u2019s use our subscriber:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import clearThreadLocalCache\n&gt;&gt;&gt; clearThreadLocalCache()\n</pre>\n</blockquote>\n<p>As you can see our cache items get removed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"shared-container\">\n<h3>Shared Container</h3>\n<p>Now let\u2019s implement a shared container which contains all IEmployer items:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class SharedEployers(m01.mongo.container.MongoContainer):\n...     \"\"\"Shared Employer container\"\"\"\n...\n...     # mark a container as shared by set the _mpid to None\n...     _mpid = None\n...\n...     @property\n...     def collection(self):\n...         return testing.getEmployers()\n...\n...     def load(self, data):\n...         return testing.Employer(data)\n</pre>\n</blockquote>\n<p>Now let\u2019s try if the shared container can access all Employer items:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; shared = SharedEployers()\n&gt;&gt;&gt; pprint(tuple(shared.items()))\n((u'roger', &lt;Employer u'roger'&gt;), (u'max', &lt;Employer u'max'&gt;))\n</pre>\n<pre>&gt;&gt;&gt; for obj in shared.values():\n...     pprint(obj.dump())\n{'__name__': u'roger',\n '_id': ObjectId('...'),\n '_pid': ObjectId('...'),\n '_type': u'Employer',\n '_version': 1,\n 'created': datetime.datetime(..., tzinfo=UTC),\n 'modified': datetime.datetime(..., tzinfo=UTC),\n 'name': u'Roger Ineichen'}\n{'__name__': u'max',\n '_id': ObjectId('...'),\n '_pid': ObjectId('...'),\n '_type': u'Employer',\n '_version': 1,\n 'created': datetime.datetime(..., tzinfo=UTC),\n 'modified': datetime.datetime(..., tzinfo=UTC),\n 'name': u'Max Muster'}\n</pre>\n</blockquote>\n<p>Now commit our transaction which will cleanup our caches. Database cleanup is\ndone in our test teardown:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Check our thread local cache before we leave this test:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"mongoobject\">\n<h2>MongoObject</h2>\n<p>A MongoObject can get stored independent from anything else in a MongoDB. Such\nMongoObject can get used together with a field property called\nMongoOjectProperty. The field property is responsible for set and get such\nMongoObject to and from MongoDB. A persistent item which provides such a\nMongoObject within a MongoObjectProperty only has to provide an oid attribute\nwith a unique value. You can use the m01.oid package for such a unique oid\nor implement an own pattern.</p>\n<p>The MongoObject uses the __parent__._moid and the attribute (field) name as\nit\u2019s unique MongoDB key.</p>\n<p>Note, this test uses a fake MongoDB server setup. But this fake server is far\naway from beeing complete. We will add more feature to this fake server if we\nneed them in other projects. See testing.py for more information.</p>\n<div id=\"id8\">\n<h3>Condition</h3>\n<p>Befor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo.testing import pprint\n&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"id9\">\n<h3>Setup</h3>\n<p>First import some components:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; from m01.mongo import interfaces\n&gt;&gt;&gt; from m01.mongo import testing\n</pre>\n</blockquote>\n<p>First, we need to setup a persistent object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = testing.Content(42)\n&gt;&gt;&gt; content._moid\n42\n</pre>\n</blockquote>\n<p>And add them to the ZODB:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root = {}\n&gt;&gt;&gt; root['content'] = content\n&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; content\n&lt;Content 42&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id10\">\n<h3>MongoObject</h3>\n<p>Now let\u2019s add a MongoObject instance to our sample content object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'title': u'Mongo Object Title',\n...         'description': u'A Description',\n...         'item': {'text':u'Item'},\n...         'date': datetime.date(2010, 2, 28).toordinal(),\n...         'numbers': [1,2,3],\n...         'comments': [{'text':u'Comment 1'}, {'text':u'Comment 2'}]}\n&gt;&gt;&gt; obj = testing.SampleMongoObject(data)\n&gt;&gt;&gt; obj._id\nObjectId('...')\n</pre>\n<p>obj.title\nu\u2019Mongo Object Title\u2019</p>\n<pre>&gt;&gt;&gt; obj.description\nu'A Description'\n</pre>\n<pre>&gt;&gt;&gt; obj.item\n&lt;SampleSubItem u'...'&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj.item.text\nu'Item'\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers\n[1, 2, 3]\n</pre>\n<pre>&gt;&gt;&gt; obj.comments\n[&lt;SampleSubItem u'...'&gt;, &lt;SampleSubItem u'...'&gt;]\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments)[0].text\nu'Comment 1'\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments)[1].text\nu'Comment 2'\n</pre>\n</blockquote>\n<p>Our MongoObject doesn\u2019t provide a _aprent__ or __name__ right now:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.__parent__ is None\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj.__name__ is None\nTrue\n</pre>\n</blockquote>\n<p>But after adding the mongo object to our content which uses a\nMongoObjectProperty, the mongo object get located and becomes the attribute\nname as _field value. If the object didn\u2019t provide a __name__, the same value\nwill also get applied for __name__:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content.obj = obj\n&gt;&gt;&gt; obj.__parent__\n&lt;Content 42&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj.__name__\nu'obj'\n</pre>\n<pre>&gt;&gt;&gt; obj.__name__\nu'obj'\n</pre>\n</blockquote>\n<p>After adding our mongo object, there should be a reference in our thread local\ncache:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{u'42:obj': &lt;SampleMongoObject u'obj'&gt;,\n 'MongoTransactionDataManager': &lt;m01.mongo.tm.MongoTransactionDataManager object at ...&gt;}\n</pre>\n</blockquote>\n<p>A MongoObject provides a _oid attribute which is used as the MongoDB key. This\nvalue uses the __parent__._moid and the mongo objects attribute name:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj._oid == '%s:%s' % (content._moid, obj.__name__)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj._oid\nu'42:obj'\n</pre>\n</blockquote>\n<p>Now check if we can get the mongo object again and if we still get the same\nvalues:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj = content.obj\n&gt;&gt;&gt; obj.title\nu'Mongo Object Title'\n</pre>\n<pre>&gt;&gt;&gt; obj.description\nu'A Description'\n</pre>\n<pre>&gt;&gt;&gt; obj.item\n&lt;SampleSubItem u'...'&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj.item.text\nu'Item'\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers\n[1, 2, 3]\n</pre>\n<pre>&gt;&gt;&gt; obj.comments\n[&lt;SampleSubItem u'...'&gt;, &lt;SampleSubItem u'...'&gt;]\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments)[0].text\nu'Comment 1'\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments)[1].text\nu'Comment 2'\n</pre>\n</blockquote>\n<p>Now let\u2019s commit the transaction which will store the obj in our fake mongo DB:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>After we commited to the MongoDB, the mongo object and our transaction data\nmanger reference should be gone in the thread local cache:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n<p>Now check our mongo object values again. If your content item is stored in a\nZODB, you would get the content item from a ZODB connection root:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; content\n&lt;Content 42&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj = content.obj\n&gt;&gt;&gt; obj\n&lt;SampleMongoObject u'obj'&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj.title\nu'Mongo Object Title'\n</pre>\n<pre>&gt;&gt;&gt; obj.description\nu'A Description'\n</pre>\n<pre>&gt;&gt;&gt; obj.item\n&lt;SampleSubItem u'...'&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj.item.text\nu'Item'\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers\n[1, 2, 3]\n</pre>\n<pre>&gt;&gt;&gt; obj.comments\n[&lt;SampleSubItem u'...'&gt;, &lt;SampleSubItem u'...'&gt;]\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments)[0].text\nu'Comment 1'\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments)[1].text\nu'Comment 2'\n</pre>\n<pre>&gt;&gt;&gt; pprint(obj.dump())\n{'__name__': u'obj',\n '_field': u'obj',\n '_id': ObjectId('...'),\n '_oid': u'42:obj',\n '_type': u'SampleMongoObject',\n '_version': 1,\n 'comments': [{'_id': ObjectId('...'),\n               '_type': u'SampleSubItem',\n               'created': datetime.datetime(...),\n               'modified': None,\n               'text': u'Comment 1'},\n              {'_id': ObjectId('...'),\n               '_type': u'SampleSubItem',\n               'created': datetime.datetime(...),\n               'modified': None,\n               'text': u'Comment 2'}],\n 'created': datetime.datetime(...),\n 'date': 733831,\n 'description': u'A Description',\n 'item': {'_id': ObjectId('...'),\n          '_type': u'SampleSubItem',\n          'created': datetime.datetime(...),\n          'modified': None,\n          'text': u'Item'},\n 'modified': datetime.datetime(...),\n 'number': None,\n 'numbers': [1, 2, 3],\n 'removed': False,\n 'title': u'Mongo Object Title'}\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n<p>Now let\u2019s replace the existing item with a new one and add another item to\nthe item lists. Also make sure we can use append instead of re-apply the full\nlist like zope widgets do:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; obj = content.obj\n</pre>\n<pre>&gt;&gt;&gt; obj.item = testing.SampleSubItem({'text': u'New Item'})\n</pre>\n<pre>&gt;&gt;&gt; newItem = testing.SampleSubItem({'text': u'New List Item'})\n&gt;&gt;&gt; obj.comments.append(newItem)\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers.append(4)\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>check again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; obj = content.obj\n</pre>\n<pre>&gt;&gt;&gt; obj.title\nu'Mongo Object Title'\n</pre>\n<pre>&gt;&gt;&gt; obj.description\nu'A Description'\n</pre>\n<pre>&gt;&gt;&gt; obj.item\n&lt;SampleSubItem u'...'&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj.item.text\nu'New Item'\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers\n[1, 2, 3, 4]\n</pre>\n<pre>&gt;&gt;&gt; obj.comments\n[&lt;SampleSubItem u'...'&gt;, &lt;SampleSubItem u'...'&gt;]\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments)[0].text\nu'Comment 1'\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments)[1].text\nu'Comment 2'\n</pre>\n</blockquote>\n<p>And now re-apply a full list of values to the list field:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; comOne = testing.SampleSubItem({'text': u'First List Item'})\n&gt;&gt;&gt; comTwo = testing.SampleSubItem({'text': u'Second List Item'})\n&gt;&gt;&gt; comments = [comOne, comTwo]\n&gt;&gt;&gt; obj.comments = comments\n&gt;&gt;&gt; obj.numbers = [1,2,3,4,5]\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>check again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; obj = content.obj\n</pre>\n<pre>&gt;&gt;&gt; len(obj.comments)\n2\n</pre>\n<pre>&gt;&gt;&gt; obj.comments\n[&lt;SampleSubItem u'...'&gt;, &lt;SampleSubItem u'...'&gt;]\n</pre>\n<pre>&gt;&gt;&gt; len(obj.numbers)\n5\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers\n[1, 2, 3, 4, 5]\n</pre>\n</blockquote>\n<p>Also check if we can remove list items:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.numbers.remove(1)\n&gt;&gt;&gt; obj.numbers.remove(2)\n</pre>\n<pre>&gt;&gt;&gt; obj.comments.remove(comTwo)\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>check again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; obj = content.obj\n</pre>\n<pre>&gt;&gt;&gt; len(obj.comments)\n1\n</pre>\n<pre>&gt;&gt;&gt; obj.comments\n[&lt;SampleSubItem u'...'&gt;]\n</pre>\n<pre>&gt;&gt;&gt; len(obj.numbers)\n3\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers\n[3, 4, 5]\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>We can also remove items from the item list by it\u2019s __name__:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; obj = content.obj\n</pre>\n<pre>&gt;&gt;&gt; del obj.comments[comOne.__name__]\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>check again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; obj = content.obj\n</pre>\n<pre>&gt;&gt;&gt; len(obj.comments)\n0\n</pre>\n<pre>&gt;&gt;&gt; obj.comments\n[]\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Or we can add items to the item list by name:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; obj = content.obj\n</pre>\n<pre>&gt;&gt;&gt; obj.comments[comOne.__name__] = comOne\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>check again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; obj = content.obj\n</pre>\n<pre>&gt;&gt;&gt; len(obj.comments)\n1\n</pre>\n<pre>&gt;&gt;&gt; obj.comments\n[&lt;SampleSubItem u'...'&gt;]\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n</div>\n<div id=\"coverage\">\n<h3>Coverage</h3>\n<p>Our items list also provides the following methods:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.comments.__contains__(comOne.__name__)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; comOne.__name__ in obj.comments\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj.comments.get(comOne.__name__)\n&lt;SampleSubItem u'...'&gt;\n</pre>\n<pre>&gt;&gt;&gt; obj.comments.keys() == [comOne.__name__]\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj.comments.values()\n&lt;generator object ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments.values())\n(&lt;SampleSubItem u'...'&gt;,)\n</pre>\n<pre>&gt;&gt;&gt; obj.comments.items()\n&lt;generator object ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; tuple(obj.comments.items())\n((u'...', &lt;SampleSubItem u'...'&gt;),)\n</pre>\n<pre>&gt;&gt;&gt; obj.comments == obj.comments\nTrue\n</pre>\n</blockquote>\n<p>Let\u2019s test some internals for increase coverage:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.comments._m_changed\nTraceback (most recent call last):\n...\nAttributeError: _m_changed is a write only property\n</pre>\n<pre>&gt;&gt;&gt; obj.comments._m_changed = False\nTraceback (most recent call last):\n...\nValueError: Can only dispatch True to __parent__\n</pre>\n<pre>&gt;&gt;&gt; obj.comments.locate(42)\n</pre>\n</blockquote>\n<p>Our simple value typ list also provides the following methods:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj.numbers.__contains__(3)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; 3 in obj.numbers\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers == obj.numbers\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers.pop()\n5\n</pre>\n<pre>&gt;&gt;&gt; del obj.numbers[0]\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers[0] = 42\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers._m_changed\nTraceback (most recent call last):\n...\nAttributeError: _m_changed is a write only property\n</pre>\n<pre>&gt;&gt;&gt; obj.numbers._m_changed = False\nTraceback (most recent call last):\n...\nValueError: Can only dispatch True to __parent__\n</pre>\n</blockquote>\n<p>Check our thread local cache before we leave this test:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"geolocation\">\n<h2>GeoLocation</h2>\n<p>The GeoLocation item can store a geo location and is used in an item as\na kind of sub item providing longitude and latitude. Additional to this\nfields a GeoLocation provides the _m_changed dispatching concept and is able\nto notify the __parent__ item if lon/lat get changed. The item also provides\nILocation for security lookup support. The field property is responsible for\napply a __parent__ and __name__.</p>\n<p>The GeoLocation item supports the order longitude, latitude and preserves them.</p>\n<div id=\"id11\">\n<h3>Condition</h3>\n<p>Befor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo.testing import pprint\n&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; from m01.mongo.testing import reNormalizer\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"id12\">\n<h3>Setup</h3>\n<p>First import some components:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import transaction\n</pre>\n<pre>&gt;&gt;&gt; import m01.mongo\n&gt;&gt;&gt; import m01.mongo.base\n&gt;&gt;&gt; import m01.mongo.geo\n&gt;&gt;&gt; import m01.mongo.container\n&gt;&gt;&gt; from m01.mongo import interfaces\n&gt;&gt;&gt; from m01.mongo import testing\n</pre>\n</blockquote>\n<p>We also need a application root object. Let\u2019s define a static MongoContainer\nas our application database root item.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MongoRoot(m01.mongo.container.MongoContainer):\n...     \"\"\"Mongo application root\"\"\"\n...\n...     _id = m01.mongo.getObjectId(0)\n...\n...     def __init__(self):\n...         pass\n...\n...     @property\n...     def collection(self):\n...         return testing.getRootItems()\n...\n...     @property\n...     def cacheKey(self):\n...         return 'root'\n...\n...     def load(self, data):\n...         \"\"\"Load data into the right mongo item.\"\"\"\n...         return testing.GeoSample(data)\n...\n...     def __repr__(self):\n...         return '&lt;%s %s&gt;' % (self.__class__.__name__, self._id)\n</pre>\n</blockquote>\n<p>The following method allows us to generate new MongoRoot item instances. This\nallows us to show that we generate different root items like we would do on a\nserver restart.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def getRoot():\n...     return MongoRoot()\n</pre>\n</blockquote>\n<p>Here is our database root item:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root = getRoot()\n&gt;&gt;&gt; root\n&lt;MongoRoot 000000000000000000000000&gt;\n</pre>\n<pre>&gt;&gt;&gt; root._id\nObjectId('000000000000000000000000')\n</pre>\n</blockquote>\n</div>\n<div id=\"indexing\">\n<h3>indexing</h3>\n<p>First setup an index:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; collection = testing.getRootItems()\n</pre>\n<pre>&gt;&gt;&gt; from pymongo import GEO2D\n&gt;&gt;&gt; collection.create_index([('lonlat', GEO2D)])\nu'lonlat_2d'\n</pre>\n</blockquote>\n</div>\n<div id=\"geosample\">\n<h3>GeoSample</h3>\n<p>As you can see, we can initialize a GeoLocation within a list of lon/lat values\nor within a lon/lat dict:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'name': u'sample', 'lonlat': {'lon': 1, 'lat': 3}}\n&gt;&gt;&gt; sample = testing.GeoSample(data)\n&gt;&gt;&gt; sample.lonlat\n&lt;GeoLocation lon:1.0, lat:3.0&gt;\n</pre>\n<pre>&gt;&gt;&gt; data = {'name': u'sample', 'lonlat': [1, 3]}\n&gt;&gt;&gt; sample = testing.GeoSample(data)\n&gt;&gt;&gt; sample.lonlat\n&lt;GeoLocation lon:1.0, lat:3.0&gt;\n</pre>\n<pre>&gt;&gt;&gt; root[u'sample'] = sample\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Let\u2019s check our item in Mongo:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = collection.find_one({'name': 'sample'})\n&gt;&gt;&gt; reNormalizer.pprint(data)\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': [1.0, 3.0],\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n</blockquote>\n<p>We can also use a GeoLocation as lonlat data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; geo = m01.mongo.geo.GeoLocation({u'lat': 4, u'lon': 2})\n&gt;&gt;&gt; data = {'name': u'sample2', 'lonlat': geo}\n&gt;&gt;&gt; sample2 = testing.GeoSample(data)\n&gt;&gt;&gt; root[u'sample2'] = sample2\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; data = collection.find_one({'name': 'sample2'})\n&gt;&gt;&gt; reNormalizer.pprint(data)\n{u'__name__': u'sample2',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'lat': 4.0, u'lon': 2.0},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample2'}\n</pre>\n</blockquote>\n<p>We can also set a GeoLocation as lonlat value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sample2 = root[u'sample2']\n&gt;&gt;&gt; geo = m01.mongo.geo.GeoLocation({'lon': 4, 'lat': 6})\n&gt;&gt;&gt; sample2.lonlat = geo\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; data = collection.find_one({'name': 'sample2'})\n&gt;&gt;&gt; reNormalizer.pprint(data)\n{u'__name__': u'sample2',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 2,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'lat': 6.0, u'lon': 4.0},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample2'}\n</pre>\n</blockquote>\n</div>\n<div id=\"search\">\n<h3>search</h3>\n<p>Let\u2019s test some geo location search query and make sure our lon/lat order\nwill fit and get preserved during the mongodb roundtrip.</p>\n<p>Now seearch for a geo location:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def printFind(collection, query):\n...     for data in collection.find(query):\n...         reNormalizer.pprint(data)\n</pre>\n</blockquote>\n<p>Using the geospatial index we can find documents near another point:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$near': [0, 2]}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': [1.0, 3.0],\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n{u'__name__': u'sample2',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 2,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'lat': 6.0, u'lon': 4.0},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample2'}\n</pre>\n</blockquote>\n<p>It\u2019s also possible to query for all items within a given rectangle\n(specified by lower-left and upper-right coordinates):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$box': [[1,2], [2,3]]}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': [1.0, 3.0],\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n</blockquote>\n<p>As you can see if we use the wrong order for lon/lat (lat/lon), we will not\nget a value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$box': [[10,20], [20,30]]}}})\n</pre>\n</blockquote>\n<p>We can also search for a circle (specified by center point and radius):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 2]}}})\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 4]}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': [1.0, 3.0],\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 10]}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': [1.0, 3.0],\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n{u'__name__': u'sample2',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 2,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'lat': 6.0, u'lon': 4.0},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample2'}\n</pre>\n</blockquote>\n<p>Also check if the lat/lon order matters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[1, 2], 1]}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': [1.0, 3.0],\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[2, 1], 1]}}})\n</pre>\n</blockquote>\n<p>And check if we can store real lon/lat values by using a float:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'name': u'sample', 'lonlat': {'lon': 20.123, 'lat': 29.123}}\n&gt;&gt;&gt; sample3 = testing.GeoSample(data)\n&gt;&gt;&gt; root[u'sample3'] = sample3\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[25, 25], 4]}}})\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[25, 25], 10]}}})\n{u'__name__': u'sample3',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'lat': 29.123, u'lon': 20.123},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n</blockquote>\n</div>\n<div id=\"id13\">\n<h3>tear down</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import clearThreadLocalCache\n&gt;&gt;&gt; clearThreadLocalCache()\n</pre>\n</blockquote>\n<p>As you can see our cache items get removed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"geopoint\">\n<h2>GeoPoint</h2>\n<p>The GeoPoint item can store a geo location and is used in an item as\na kind of sub item providing longitude and latitude and type. Additional to this\nfields a GeoPoint provides the _m_changed dispatching concept and is able\nto notify the __parent__ item if lon/lat get changed. The item also provides\nILocation for security lookup support. The MongoGeoPointProperty field property\nis responsible for apply a __parent__ and __name__ and use the right class\nfactory.</p>\n<p>The GeoPoint item supports the order longitude, latitude and preserves them.</p>\n<div id=\"id14\">\n<h3>Condition</h3>\n<p>Befor we start testing, check if our thread local cache is empty or if we have\nlet over some junk from previous tests:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo.testing import pprint\n&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; from m01.mongo.testing import reNormalizer\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"id15\">\n<h3>Setup</h3>\n<p>First import some components:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import transaction\n</pre>\n<pre>&gt;&gt;&gt; import m01.mongo\n&gt;&gt;&gt; import m01.mongo.base\n&gt;&gt;&gt; import m01.mongo.geo\n&gt;&gt;&gt; import m01.mongo.container\n&gt;&gt;&gt; from m01.mongo import interfaces\n&gt;&gt;&gt; from m01.mongo import testing\n</pre>\n</blockquote>\n<p>We also need a application root object. Let\u2019s define a static MongoContainer\nas our application database root item.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MongoRoot(m01.mongo.container.MongoContainer):\n...     \"\"\"Mongo application root\"\"\"\n...\n...     _id = m01.mongo.getObjectId(0)\n...\n...     def __init__(self):\n...         pass\n...\n...     @property\n...     def collection(self):\n...         return testing.getRootItems()\n...\n...     @property\n...     def cacheKey(self):\n...         return 'root'\n...\n...     def load(self, data):\n...         \"\"\"Load data into the right mongo item.\"\"\"\n...         return testing.GeoPointSample(data)\n...\n...     def __repr__(self):\n...         return '&lt;%s %s&gt;' % (self.__class__.__name__, self._id)\n</pre>\n</blockquote>\n<p>The following method allows us to generate new MongoRoot item instances. This\nallows us to show that we generate different root items like we would do on a\nserver restart.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def getRoot():\n...     return MongoRoot()\n</pre>\n</blockquote>\n<p>Here is our database root item:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root = getRoot()\n&gt;&gt;&gt; root\n&lt;MongoRoot 000000000000000000000000&gt;\n</pre>\n<pre>&gt;&gt;&gt; root._id\nObjectId('000000000000000000000000')\n</pre>\n</blockquote>\n</div>\n<div id=\"id16\">\n<h3>indexing</h3>\n<p>First setup an index:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; collection = testing.getRootItems()\n</pre>\n<pre>&gt;&gt;&gt; from pymongo import GEOSPHERE\n&gt;&gt;&gt; collection.create_index([('lonlat', GEOSPHERE)])\nu'lonlat_2dsphere'\n</pre>\n</blockquote>\n</div>\n<div id=\"geopointsample\">\n<h3>GeoPointSample</h3>\n<p>As you can see, we can initialize a GeoPoint within a list of lon/lat values\nor within a lon/lat dict:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'name': u'sample', 'lonlat': {'lon': 1, 'lat': 3}}\n&gt;&gt;&gt; sample = testing.GeoPointSample(data)\n&gt;&gt;&gt; sample.lonlat\n&lt;GeoPoint lon:1.0, lat:3.0&gt;\n</pre>\n<pre>&gt;&gt;&gt; data = {'name': u'sample', 'lonlat': [1, 3]}\n&gt;&gt;&gt; sample = testing.GeoPointSample(data)\n&gt;&gt;&gt; sample.lonlat\n&lt;GeoPoint lon:1.0, lat:3.0&gt;\n</pre>\n<pre>&gt;&gt;&gt; root[u'sample'] = sample\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Let\u2019s check our item in Mongo:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = collection.find_one({'name': 'sample'})\n&gt;&gt;&gt; reNormalizer.pprint(data)\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n</blockquote>\n<p>We can also use a GeoPoint as lonlat data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; geo = m01.mongo.geo.GeoPoint({u'lat': 4, u'lon': 2})\n&gt;&gt;&gt; data = {'name': u'sample2', 'lonlat': geo}\n&gt;&gt;&gt; sample2 = testing.GeoPointSample(data)\n&gt;&gt;&gt; root[u'sample2'] = sample2\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; data = collection.find_one({'name': 'sample2'})\n&gt;&gt;&gt; reNormalizer.pprint(data)\n{u'__name__': u'sample2',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [2.0, 4.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample2'}\n</pre>\n</blockquote>\n<p>We can also set a GeoPoint as lonlat value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sample2 = root[u'sample2']\n&gt;&gt;&gt; geo = m01.mongo.geo.GeoPoint({'lon': 4, 'lat': 6})\n&gt;&gt;&gt; sample2.lonlat = geo\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; data = collection.find_one({'name': 'sample2'})\n&gt;&gt;&gt; reNormalizer.pprint(data)\n{u'__name__': u'sample2',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 2,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [4.0, 6.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample2'}\n</pre>\n</blockquote>\n</div>\n<div id=\"index\">\n<h3>index</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(collection.index_information())\n{'_id_': {'key': [('_id', 1)], 'ns': 'm01_mongo_testing.items', 'v': 1},\n 'lonlat_2dsphere': {'2dsphereIndexVersion': 2,\n                      'key': [('lonlat', '2dsphere')],\n                      'ns': 'm01_mongo_testing.items',\n                      'v': 1}}\n</pre>\n</blockquote>\n</div>\n<div id=\"id17\">\n<h3>search</h3>\n<p>Let\u2019s test some geo location search query and make sure our lon/lat order\nwill fit and get preserved during the mongodb roundtrip.</p>\n<p>Now seearch for a geo location:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def printFind(collection, query):\n...     for data in collection.find(query):\n...         reNormalizer.pprint(data)\n</pre>\n</blockquote>\n<p>Using the geospatial index we can find documents within another point:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point = {\"type\": \"Polygon\",\n...          \"coordinates\": [[[0,0], [0,6], [2,6], [2,0], [0,0]]]}\n&gt;&gt;&gt; query = {\"lonlat\": {\"$within\": {\"$geometry\": point}}}\n&gt;&gt;&gt; printFind(collection, query)\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n</blockquote>\n<p>Using the geospatial index we can find documents near another point:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; point = {'type': 'Point', 'coordinates': [0, 2]}\n&gt;&gt;&gt; printFind(collection, {'lonlat': {'$near': {'$geometry': point}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n{u'__name__': u'sample2',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 2,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [4.0, 6.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample2'}\n</pre>\n</blockquote>\n<p>It\u2019s also possible to query for all items within a given rectangle\n(specified by lower-left and upper-right coordinates):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$box': [[1,2], [2,3]]}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n</blockquote>\n<p>As you can see if we use the wrong order for lon/lat (lat/lon), we will not\nget a value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$box': [[2,1], [3,2]]}}})\n</pre>\n</blockquote>\n<p>We can also search for a circle (specified by center point and radius):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 2]}}})\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 4]}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[0, 0], 10]}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n{u'__name__': u'sample2',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 2,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [4.0, 6.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample2'}\n</pre>\n</blockquote>\n<p>Also check if the lat/lon order matters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[1, 2], 1]}}})\n{u'__name__': u'sample',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [1.0, 3.0], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[2, 1], 1]}}})\n</pre>\n</blockquote>\n<p>And check if we can store real lon/lat values by using a float:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'name': u'sample', 'lonlat': {'lon': 20.123, 'lat': 29.123}}\n&gt;&gt;&gt; sample3 = testing.GeoPointSample(data)\n&gt;&gt;&gt; root[u'sample3'] = sample3\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[25, 25], 4]}}})\n</pre>\n<pre>&gt;&gt;&gt; printFind(collection, {'lonlat': {'$within': {'$center': [[25, 25], 10]}}})\n{u'__name__': u'sample3',\n u'_id': ObjectId('...'),\n u'_pid': ObjectId('...'),\n u'_type': u'GeoPointSample',\n u'_version': 1,\n u'created': datetime.datetime(..., tzinfo=UTC),\n u'lonlat': {u'coordinates': [20.123, 29.123], u'type': u'Point'},\n u'modified': datetime.datetime(..., tzinfo=UTC),\n u'name': u'sample'}\n</pre>\n</blockquote>\n</div>\n<div id=\"id18\">\n<h3>tear down</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import clearThreadLocalCache\n&gt;&gt;&gt; clearThreadLocalCache()\n</pre>\n</blockquote>\n<p>As you can see our cache items get removed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"batching\">\n<h2>Batching</h2>\n<p>The MongoMappingBase base class used by MongoStorage and MongoContainer can\nreturn batched data or items and batch information.</p>\n<p>Note; this test runs in level 2 because it uses a working MongoDB. This is\nneeded because we like to test the real sort and limit functions in a MongoDB.</p>\n<div id=\"id19\">\n<h3>Condition</h3>\n<p>Befor we start testing, check if our thread local cache is empty or if we have\nleft over some junk from previous tests:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo.testing import pprint\n&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"id20\">\n<h3>Setup</h3>\n<p>First import some components:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; from m01.mongo import testing\n</pre>\n</blockquote>\n</div>\n<div id=\"id21\">\n<h3>setup</h3>\n<p>Now we can add a MongoStorage to the database. Let\u2019s just use a simple\ndict as database root:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root = {}\n&gt;&gt;&gt; storage = testing.SampleStorage()\n&gt;&gt;&gt; root['storage'] = storage\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Now let\u2019s add 1000 MongoItems:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; storage = root['storage']\n&gt;&gt;&gt; for i in range(1000):\n...     data = {u'title': u'Title %i' % i,\n...             u'description': u'Description %i' % i,\n...             u'number': i}\n...     item = testing.SampleStorageItem(data)\n...     __name__ = storage.add(item)\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>After we commited to the MongoDB, the mongo object and our transaction data\nmanger reference should be gone in the thread local cache:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n<p>As you can see, our collection contains 1000 items:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; storage = root['storage']\n&gt;&gt;&gt; len(storage)\n1000\n</pre>\n</blockquote>\n</div>\n<div id=\"id22\">\n<h3>batching</h3>\n<p>Note, this method does not return items, it only returns the MongoDB data. This\nis what you should use. If this doesn\u2019t fit because you need a list of the real\nMongoItem this would be complicated beause we could have removed marked items\nin our LOCAL cache which the MongoDB doesn\u2019t know about.</p>\n<p>Let\u2019s get the batch information:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; storage.getBatchData()\n(&lt;...Cursor object at ...&gt;, 1, 40, 1000)\n</pre>\n</blockquote>\n<p>As you an see, we\u2019ve got a curser with mongo data, the start index, the total\namount of items and the page counter. Note, the first page starts at 1 (one)\nand not zero. Let\u2019s show another ample with different values:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; storage.getBatchData(page=5, size=10)\n(&lt;...Cursor object at ...&gt;, 5, 100, 1000)\n</pre>\n</blockquote>\n<p>As you can see we can iterate our cursor:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cursor, page, total, pages = storage.getBatchData(page=1, size=3)\n</pre>\n<pre>&gt;&gt;&gt; pprint(tuple(cursor))\n({'__name__': '...',\n  '_id': ObjectId('...'),\n  '_pid': None,\n  '_type': 'SampleStorageItem',\n  '_version': 1,\n  'comments': [],\n  'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  'description': 'Description ...',\n  'item': None,\n  'modified': datetime.datetime(..., tzinfo=UTC),\n  'number': ...,\n  'numbers': [],\n  'title': 'Title ...'},\n {'__name__': '...',\n  '_id': ObjectId('...'),\n  '_pid': None,\n  '_type': 'SampleStorageItem',\n  '_version': 1,\n  'comments': [],\n  'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  'description': 'Description ...',\n  'item': None,\n  'modified': datetime.datetime(..., tzinfo=UTC),\n  'number': ...,\n  'numbers': [],\n  'title': 'Title ...'},\n {'__name__': '...',\n  '_id': ObjectId('...'),\n  '_pid': None,\n  '_type': 'SampleStorageItem',\n  '_version': 1,\n  'comments': [],\n  'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  'description': 'Description ...',\n  'item': None,\n  'modified': datetime.datetime(..., tzinfo=UTC),\n  'number': ...,\n  'numbers': [],\n  'title': 'Title ...'})\n</pre>\n</blockquote>\n<p>As you can see, the cursor counts the total amount of items:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cursor.count()\n1000\n</pre>\n</blockquote>\n<p>But we can force to count the result based on limit and skip arguments by use\nTrue as argument:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cursor.count(True)\n3\n</pre>\n</blockquote>\n<p>As you can see batching or any other object lookup will left items back in our\nthread local cache. We can use our thread local cache cleanup event handler\nwhich is normal registered as an EndRequestEvent subscriber:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{u'm01_mongo_testing.test...': {'added': {}, 'removed': {}}}\n</pre>\n</blockquote>\n<p>Let\u2019s use our subscriber:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import clearThreadLocalCache\n&gt;&gt;&gt; clearThreadLocalCache()\n</pre>\n</blockquote>\n<p>As you can see our cache items get removed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from m01.mongo import LOCAL\n&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n<div id=\"order\">\n<h3>order</h3>\n<p>An important part in batching is ordering. As you can see, we can limit the\nbatch size and get a slice of data from a sequence. It is very important that\nthe data get ordered at the MongoDB before we slice the data into a batch.\nLet\u2019s test if this works based on our ordable number value and a sort order\nwhere lowest value comes first. Start with page=0:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cursor, page, pages, total = storage.getBatchData(page=1, size=3,\n...     sortName='number', sortOrder=1)\n</pre>\n<pre>&gt;&gt;&gt; cursor\n&lt;pymongo.cursor.Cursor object at ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; page\n1\n</pre>\n<pre>&gt;&gt;&gt; pages\n334\n</pre>\n<pre>&gt;&gt;&gt; total\n1000\n</pre>\n</blockquote>\n<p>When ordering is done right, the first item should have a number value 0 (zero):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(tuple(cursor))\n({u'__name__': u'...',\n  u'_id': ObjectId('...'),\n  '_pid': None,\n  u'_type': u'SampleStorageItem',\n  u'_version': 1,\n  u'comments': [],\n  u'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  u'description': u'Description 0',\n  'item': None,\n  u'modified': datetime.datetime(..., tzinfo=UTC),\n  u'number': 0,\n  u'numbers': [],\n  u'title': u'Title 0'},\n {u'__name__': u'...',\n  u'_id': ObjectId('...'),\n  '_pid': None,\n  u'_type': u'SampleStorageItem',\n  u'_version': 1,\n  u'comments': [],\n  u'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  u'description': u'Description 1',\n  'item': None,\n  u'modified': datetime.datetime(..., tzinfo=UTC),\n  u'number': 1,\n  u'numbers': [],\n  u'title': u'Title 1'},\n {u'__name__': u'...',\n  u'_id': ObjectId('...'),\n  '_pid': None,\n  u'_type': u'SampleStorageItem',\n  u'_version': 1,\n  u'comments': [],\n  u'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  u'description': u'Description 2',\n  'item': None,\n  u'modified': datetime.datetime(..., tzinfo=UTC),\n  u'number': 2,\n  u'numbers': [],\n  u'title': u'Title 2'})\n</pre>\n</blockquote>\n<p>The second page (page=1) should start with number == 3:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cursor, page, pages, total = storage.getBatchData(page=2, size=3,\n...     sortName='number', sortOrder=1)\n&gt;&gt;&gt; pprint(tuple(cursor))\n({u'__name__': u'...',\n  u'_id': ObjectId('...'),\n  '_pid': None,\n  u'_type': u'SampleStorageItem',\n  u'_version': 1,\n  u'comments': [],\n  u'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  u'description': u'Description 3',\n  'item': None,\n  u'modified': datetime.datetime(..., tzinfo=UTC),\n  u'number': 3,\n  u'numbers': [],\n  u'title': u'Title 3'},\n {u'__name__': u'...',\n  u'_id': ObjectId('...'),\n  '_pid': None,\n  u'_type': u'SampleStorageItem',\n  u'_version': 1,\n  u'comments': [],\n  u'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  u'description': u'Description 4',\n  'item': None,\n  u'modified': datetime.datetime(..., tzinfo=UTC),\n  u'number': 4,\n  u'numbers': [],\n  u'title': u'Title 4'},\n {u'__name__': u'...',\n  u'_id': ObjectId('...'),\n  '_pid': None,\n  u'_type': u'SampleStorageItem',\n  u'_version': 1,\n  u'comments': [],\n  u'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  u'description': u'Description 5',\n  'item': None,\n  u'modified': datetime.datetime(..., tzinfo=UTC),\n  u'number': 5,\n  u'numbers': [],\n  u'title': u'Title 5'})\n</pre>\n</blockquote>\n<p>As you can see your page size is 334. Let\u2019s show this batch slice. The\nitem in this batch should have a number == 999. but note:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pages\n334\n</pre>\n<pre>&gt;&gt;&gt; cursor, page, total, pages = storage.getBatchData(page=334, size=3,\n...     sortName='number', sortOrder=1)\n&gt;&gt;&gt; pprint(tuple(cursor))\n({u'__name__': u'...',\n  u'_id': ObjectId('...'),\n  '_pid': None,\n  u'_type': u'SampleStorageItem',\n  u'_version': 1,\n  u'comments': [],\n  u'created': datetime.datetime(..., tzinfo=UTC),\n  'date': None,\n  u'description': u'Description 999',\n  'item': None,\n  u'modified': datetime.datetime(..., tzinfo=UTC),\n  u'number': 999,\n  u'numbers': [],\n  u'title': u'Title 999'},)\n</pre>\n</blockquote>\n</div>\n<div id=\"teardown\">\n<h3>teardown</h3>\n<p>Call transaction commit which will cleanup our LOCAL caches:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Again, clear thread local cache:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; clearThreadLocalCache()\n</pre>\n</blockquote>\n<p>Check our thread local cache before we leave this test:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(LOCAL.__dict__)\n{}\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"testing\">\n<h2>Testing</h2>\n<p>Let\u2019s test some testing methods.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import re\n&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import bson.tz_util\n&gt;&gt;&gt; import m01.mongo\n&gt;&gt;&gt; import m01.mongo.testing\n&gt;&gt;&gt; from m01.mongo.testing import pprint\n</pre>\n</blockquote>\n<div id=\"renormalizer\">\n<h3>RENormalizer</h3>\n<p>The RENormalizer is able to normalize text and produce comparable output. You\ncan setup the RENormalizer with a list of input, output expressions. This is\nusefull if you dump mongodb data which contains dates or other not so simple\nreproducable data. Such a dump result can get normalized before the unit test\nwill compare the output. Also see zope.testing.renormalizing for the same\npattern which is useable as a doctest checker.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; normalizer = m01.mongo.testing.RENormalizer([\n...    (re.compile('[0-9]*[.][0-9]* seconds'), '... seconds'),\n...    (re.compile('at 0x[0-9a-f]+'), 'at ...'),\n...    ])\n</pre>\n<pre>&gt;&gt;&gt; text = \"\"\"\n... &lt;object object at 0xb7f14438&gt;\n... completed in 1.234 seconds.\n... ...\n... &lt;object object at 0xb7f14450&gt;\n... completed in 1.234 seconds.\n... \"\"\"\n</pre>\n<pre>&gt;&gt;&gt; print normalizer(text)\n&lt;BLANKLINE&gt;\n&lt;object object at ...&gt;\ncompleted in ... seconds.\n...\n&lt;object object at ...&gt;\ncompleted in ... seconds.\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>Now let\u2019s test some mongodb relevant stuff:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from bson.dbref import DBRef\n&gt;&gt;&gt; from bson.min_key import MinKey\n&gt;&gt;&gt; from bson.max_key import MaxKey\n&gt;&gt;&gt; from bson.objectid import ObjectId\n&gt;&gt;&gt; from bson.timestamp import Timestamp\n</pre>\n<pre>&gt;&gt;&gt; oid = m01.mongo.getObjectId(42)\n&gt;&gt;&gt; oid\nObjectId('0000002a0000000000000000')\n</pre>\n<pre>&gt;&gt;&gt; data = {'oid': oid,\n...         'dbref': DBRef(\"foo\", 5, \"db\"),\n...         'date': datetime.datetime(2011, 5, 7, 1, 12),\n...         'utc': datetime.datetime(2011, 5, 7, 1, 12, tzinfo=bson.tz_util.utc),\n...         'min': MinKey(),\n...         'max': MaxKey(),\n...         'timestamp': Timestamp(4, 13),\n...         're': re.compile(\"a*b\", re.IGNORECASE),\n...         'string': 'string',\n...         'unicode': u'unicode',\n...         'int': 42}\n</pre>\n</blockquote>\n<p>Now let\u2019s pretty print the data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(data)\n{'date': datetime.datetime(...),\n 'dbref': DBRef('foo', 5, 'db'),\n 'int': 42,\n 'max': MaxKey(),\n 'min': MinKey(),\n 'oid': ObjectId('...'),\n 're': &lt;_sre.SRE_Pattern object at ...&gt;,\n 'string': 'string',\n 'timestamp': Timestamp('...'),\n 'unicode': 'unicode',\n 'utc': datetime.datetime(..., tzinfo=UTC)}\n</pre>\n</blockquote>\n<div id=\"id23\">\n<h4>reNormalizer</h4>\n<p>As you can see our predefined reNormalizer will convert the values using our\ngiven patterns:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import m01.mongo.testing\n&gt;&gt;&gt; res = m01.mongo.testing.reNormalizer(data)\n&gt;&gt;&gt; print res\n{'date': datetime.datetime(...),\n 'dbref': DBRef('foo', 5, 'db'),\n 'int': 42,\n 'max': MaxKey(),\n 'min': MinKey(),\n 'oid': ObjectId('...'),\n 're': &lt;_sre.SRE_Pattern object at ...&gt;,\n 'string': 'string',\n 'timestamp': Timestamp('...'),\n 'unicode': u'unicode',\n 'utc': datetime.datetime(..., tzinfo=UTC)}\n</pre>\n</blockquote>\n</div>\n<div id=\"pprint\">\n<h4>pprint</h4>\n<blockquote>\n<pre>&gt;&gt;&gt; m01.mongo.testing.reNormalizer.pprint(data)\n{'date': datetime.datetime(...),\n 'dbref': DBRef('foo', 5, 'db'),\n 'int': 42,\n 'max': MaxKey(),\n 'min': MinKey(),\n 'oid': ObjectId('...'),\n 're': &lt;_sre.SRE_Pattern object at ...&gt;,\n 'string': 'string',\n 'timestamp': Timestamp('...'),\n 'unicode': u'unicode',\n 'utc': datetime.datetime(..., tzinfo=UTC)}\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"utc\">\n<h3>UTC</h3>\n<p>The pymongo library offers a custom UTC implementation including pickle support\nused by deepcopy. Let\u2019s test if this implementation works and replace our custom\ntimezone with the bson.tz_info.utc:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; dt = data['utc']\n&gt;&gt;&gt; dt\ndatetime.datetime(2011, 5, 7, 1, 12, tzinfo=UTC)\n</pre>\n<pre>&gt;&gt;&gt; import copy\n&gt;&gt;&gt; copy.deepcopy(dt)\ndatetime.datetime(2011, 5, 7, 1, 12, tzinfo=UTC)\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"speedup-your-implementation\">\n<h2>Speedup your implementation</h2>\n<p>Since not every strategy is the best for every applications and we can\u2019t\nimplement all concepts in this package, we will list here some imporvements.</p>\n<div id=\"values-and-items\">\n<h3>values and items</h3>\n<p>The MongoContainers and MongoStorage implementation will load all data within\nthe values and items methods. Even if we already cached them in our thread\nlocal cache. Here is an optimized method which could get used if you need to\nload a large set of data.</p>\n<p>The original implementation of MongoMappingBase.values looks like:</p>\n<pre>def values(self):\n    # join transaction handling\n    self.ensureTransaction()\n    for data in self.doFind(self.collection):\n        __name__ = data['__name__']\n        if __name__ in self._cache_removed:\n            # skip removed items\n            continue\n        obj = self._cache_loaded.get(__name__)\n        if obj is None:\n            try:\n                # load, locate and cache if not cached\n                obj = self.doLoad(data)\n            except (KeyError, TypeError):\n                continue\n        yield obj\n    # also return items not stored in MongoDB yet\n    for k, v in self._cache_added.items():\n        yield v\n</pre>\n<p>If you like to prevent loading all data, you could probably only load\nkeys and lookup data for items which didn\u2019t get cached yet. This would\nreduce network traffic and could look like:</p>\n<pre>def values(self):\n    # join transaction handling\n    self.ensureTransaction()\n    # only get __name__ and _id\n    for data in self.doFind(self.collection, {}, ['__name__', '_id']):\n        __name__ = data['__name__']\n        if __name__ in self._cache_removed:\n            # skip removed items\n            continue\n        obj = self._cache_loaded.get(__name__)\n        if obj is None:\n            try:\n                # now we can load data from mongo\n                d = self.doFindOne(self.collection, data)\n                # load, locate and cache if not cached\n                obj = self.doLoad(d)\n            except (KeyError, TypeError):\n                continue\n        yield obj\n    # also return items not stored in MongoDB yet\n    for k, v in self._cache_added.items():\n        yield v\n</pre>\n<p>Note: the same concept can get used for the items method.</p>\n<p>Note: I don\u2019t recommend to call keys, values or items for large collections\nat any time. Take a look at the batching concept we implemented. The\ngetBatchData method is probably what you need to use with a large set of data.</p>\n</div>\n<div id=\"advancedconverter\">\n<h3>AdvancedConverter</h3>\n<p>The class below shows an advanced implementation which is able to convert a\nnested data structure.</p>\n<p>Normaly a converter can convert attribute values. If the attribute\nvalue is a list of items which contains another list of items, then you need to\nuse another converter which is able to convert this nested structure. But\nnormaly this is the responsibility of the first level item to convert it\u2019s\nvalues. This is the reason why we didn\u2019t implement this concept by default.</p>\n<p>Remember, a default converter definition looks like:</p>\n<pre>def itemConverter(value):\n    _type = value.get('_type')\n    if _type == 'Car':\n        return Car\n    if _type == 'House':\n        return House\n    else:\n        return value\n</pre>\n<p>And the class defines something like:</p>\n<pre>converters = {'myItems': itemConverter}\n</pre>\n<p>Our advanced converter sample can convert a nested data structure and looks\nlike:</p>\n<pre>def toCar(value):\n    return Car(value)\n\nconverters = {'myItems': {'House': toHouse, 'Car': toCar}}\n\nclass AdvancedConverter(object):\n\n    converters = {} # attr-name/converter or {_type:converter}\n    def convert(self, key, value):\n        \"\"\"This convert method knows how to handle nested converters.\"\"\"\n        converter = self.converters.get(key)\n        if converter is not None:\n            if isinstance(converter, dict):\n                if isinstance(value, (list, tuple)):\n                    res = []\n                    for o in value:\n                        if isinstance(o, dict):\n                            _type = o.get('_type')\n                            if _type is not None:\n                                converter = converter.get(_type)\n                                value = converter(o)\n                        res.append(value)\n                    value = res\n                elif isinstance(value, dict):\n                    _type = o.get('_type')\n                    if _type is not None:\n                        converter = converter.get(_type)\n                        value = converter(value)\n                else:\n                    value = converter(value)\n            else:\n                if isinstance(value, (list, tuple)):\n                    # convert list values\n                    value = [converter(d) for d in value]\n                else:\n                    # convert simple values\n                    value = converter(value)\n        return value\n</pre>\n<p>I\u2019m sure if you understand what we implemented, you will find a lot of space\nto improve and write your own special methods which can do the right thing for\nyour use cases.</p>\n</div>\n</div>\n<div id=\"changes\">\n<h2>CHANGES</h2>\n<div id=\"id24\">\n<h3>3.3.1 (2020-04-22)</h3>\n<ul>\n<li>bugfix: register MongoListData class and allow interface IMongoListData.\nThis allows to access the internal implementation like a simply built in\ntype. Note: the object property using this implementation is still protected.\nWe just let our instance act like a buit in simply python type.</li>\n</ul>\n</div>\n<div id=\"id25\">\n<h3>3.3.0 (2018-02-04)</h3>\n<ul>\n<li>use new p01.env package for pymongo client environment setup</li>\n</ul>\n</div>\n<div id=\"id26\">\n<h3>3.2.3 (2018-02-04)</h3>\n<ul>\n<li>bugfix: removed FakeMongoConnectionPool from mongo client testing setup</li>\n<li>set MONGODB_CONNECT to False as default because client setup takes too long\nfor testing setup. Add MONGODB_CONNECT to your os environment if you need\nto connect on application startup.</li>\n</ul>\n</div>\n<div id=\"id27\">\n<h3>3.2.2 (2018-01-29)</h3>\n<ul>\n<li>bugfix: fix timeout milli seconds and MONGODB_REVOCATION_LIST attr usage</li>\n</ul>\n</div>\n<div id=\"id28\">\n<h3>3.2.1 (2018-01-29)</h3>\n<ul>\n<li>bugfix: multiply MONGODB_SERVER_SELECTION_TIMEOUT with 1000because it\u2019s used\nas milli seconds</li>\n</ul>\n</div>\n<div id=\"id29\">\n<h3>3.2.0 (2018-01-29)</h3>\n<ul>\n<li>feature: implemented pymongo client setup based on enviroment variables and\ndefault settings.py file</li>\n</ul>\n</div>\n<div id=\"id30\">\n<h3>3.1.0 (2017-01-22)</h3>\n<ul>\n<li>bugfix: make sure we override existing mongodb values with None if None is\ngiven as value in python object. Previous versions didn\u2019t override existing values with None. The new implementation will use the default schema value\nas mongodb value even if default is None. Note, this will break existing\ntest output.</li>\n<li>bugfix: fix performance test setup, conditional include ZODB for performance\ntests. Supported with extras_require in setup.py.</li>\n</ul>\n</div>\n<div id=\"id31\">\n<h3>3.0.0 (2015-11-11)</h3>\n<ul>\n<li>Use 3.0.0 as package version and reflect pymongo &gt; 3.0.0 compatibility.</li>\n<li>feature: change internal doFind, doInsert and doRemove methods, remove old\nmethod arguments like safe etc..</li>\n<li>feature: reflect changes in pymongo &gt; 3.0.0. Replace disconnect with close\nmethod like the MongoClient does.</li>\n<li>removed MongoConnectionPool, replace them with MongoClient in your code. There\nis no need for a thread safe connection pool since pymongo is thread safe.\nAlso replace MongoConnection with MongoClient in your test code.</li>\n<li>switch from m01.mongofake to m01.fake including pymongo &gt;= 3.0.0 support</li>\n<li>remove write_concern options in mapping base class. The MongoClient should\ndefine the right write concern.</li>\n</ul>\n</div>\n<div id=\"id32\">\n<h3>1.0.0 (2015-03-17)</h3>\n<ul>\n<li>improve AttributeError handling on object setup. Additional catch ValueError\nand zope.interface.Invalid and raise AttributeError with detailed attribute\nand value information</li>\n</ul>\n</div>\n<div id=\"id33\">\n<h3>0.11.1 (2014-04-10)</h3>\n<ul>\n<li>feature: changed mongo client max_pool_size value from 10MB to 100MB which\nreflects changes in pymongo &gt;= 2.6.</li>\n</ul>\n</div>\n<div id=\"id34\">\n<h3>0.11.0 (2013-1-23)</h3>\n<ul>\n<li>implement GeoPoint used for 2dsphere geo location indexes. Also provide a\nMongoGeoPointProperty which is able to create such GeoPoint items.</li>\n</ul>\n</div>\n<div id=\"id35\">\n<h3>0.10.2 (2013-01-04)</h3>\n<ul>\n<li>support _m_insert_write_concern, _m_update_write_concern,\n_m_remove_write_concern in MongoObject</li>\n</ul>\n</div>\n<div id=\"id36\">\n<h3>0.10.1 (2012-12-19)</h3>\n<ul>\n<li>feature: implemented MongoDatetime schema field supporting timezone info\nattribute (tzinfo=UTC).</li>\n</ul>\n</div>\n<div id=\"id37\">\n<h3>0.10.0 (2012-12-16)</h3>\n<ul>\n<li>switch from Connection to MongoClient recommended since pymongo 2.4. Replaced\nsafe with write concern options. By default pymongo will now use safe writes.</li>\n<li>use MongoClient as factory in MongoConnectionPool. We didn\u2019t rename the class\nMongoConnectionPool, we will keep them as is. We also don\u2019t rename the\nIMongoConnectionPool interface.</li>\n<li>replaced _m_safe_insert, _m_safe_update, _m_safe_remove with\n_m_insert_write_concern, _m_update_write_concern, _m_remove_write_concern.\nThis new mapping base class options are an empty dict and can get replaced\nwith the new write concern settings. The default empty dict will force to\nuse the write concern defined in the connection.</li>\n</ul>\n</div>\n<div id=\"id38\">\n<h3>0.9.0 (2012-12-10)</h3>\n<ul>\n<li>use m01.mongofake for fake mongodb, collection and friends</li>\n</ul>\n</div>\n<div id=\"id39\">\n<h3>0.8.0 (2012-11-18)</h3>\n<ul>\n<li>bugfix: add missing security declaration for dump data</li>\n<li>switch to bson import</li>\n<li>reflect changes in test output based on pymongo 2.3</li>\n<li>remove p01.i18n package dependency</li>\n<li>improve, prevent mark items as changed for same values</li>\n<li>improve sort, support key or list as sortName and allow to skip sortOrder if\nsortName is given</li>\n<li>added MANIFEST.in file</li>\n</ul>\n</div>\n<div id=\"id40\">\n<h3>0.7.0 (2012-05-22)</h3>\n<ul>\n<li>bugfix: FakeCollection.remove: use find to find documents</li>\n<li>preserve order by using SON for query filter and dump methods</li>\n<li>implemented m01.mongo.dictify which can recoursive replace all bson.son.SON\nwith plain dict instances.</li>\n</ul>\n</div>\n<div id=\"id41\">\n<h3>0.6.2 (2012-03-12)</h3>\n<ul>\n<li>bugfix: left out a method</li>\n</ul>\n</div>\n<div id=\"id42\">\n<h3>0.6.1 (2012-03-12)</h3>\n<ul>\n<li>bugfix: return self in FakeMongoConnection __call__method. This let\u2019s an\ninstance act similar then the original pymongo Connection class __init__\nmethod.</li>\n<li>feature: Add <cite>sort</cite> parameter for FakeMongoConnection.find()</li>\n</ul>\n</div>\n<div id=\"id43\">\n<h3>0.6.0 (2012-01-17)</h3>\n<ul>\n<li>bugfix: During a query, if a spec key is missing from the doc, the doc is\nalways ignored.</li>\n<li>bugfix: correctly generate an object id in UTC. It was relying on GMT+1\n(i.e. Roger\u2019s timezone).</li>\n<li>bugfix: allow to use None as MongoDateProperty value</li>\n<li>bugfix: set __parent__ in MongoSubItem __init__ method if given</li>\n<li>implemented _m_initialized as a marker for find out when we need to trace\nchanged attributes</li>\n<li>implemented clear method in MongoListData and MongoItemsData which allows to\nremove sequence items at once wihout to pop each item from the sequence</li>\n<li>improve MongoObject implementation, implemented _field which stores the\nparent field name which the MongoObject is stored at. Also adjsut the\nMongoObjectProperty and support backward compatibility by apply the previous\nstored __name__ as _field if not given. This new _field and __name__\nseparation allos us to use explicit names e.g. the _id or custom names which\nwe can use for traversing to a MongoObject via traverser or other container\nlike implementations.</li>\n<li>Implemented __getattr__ in FakeCollection. This allows to get a sub\ncollection like in pymongo which is a part of the gridfs concept.</li>\n</ul>\n</div>\n<div id=\"id44\">\n<h3>0.5.5 (2011-10-14)</h3>\n<ul>\n<li>Implement filtering with dot notation</li>\n</ul>\n</div>\n<div id=\"id45\">\n<h3>0.5.4 (2011-09-27)</h3>\n<ul>\n<li>Fix: a real mongo DB accepts tuple as the <cite>fields</cite> parameter of <cite>find</cite>.</li>\n</ul>\n</div>\n<div id=\"id46\">\n<h3>0.5.3 (2011-09-20)</h3>\n<ul>\n<li>Fix minimum filtering expressions (Albertas)</li>\n</ul>\n</div>\n<div id=\"id47\">\n<h3>0.5.2 (2011-09-19)</h3>\n<ul>\n<li>Added minimum filtering expressions (Albertas)</li>\n<li>moved created and modified to an own interface called ICreatedModified</li>\n<li>implemented simple and generic initial geo location support</li>\n</ul>\n</div>\n<div id=\"id48\">\n<h3>0.5.1 (2011-09-09)</h3>\n<ul>\n<li>fix performance test</li>\n<li>Added database_names and collection_names</li>\n</ul>\n</div>\n<div id=\"id49\">\n<h3>0.5.0 (2011-08-19)</h3>\n<ul>\n<li>initial release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7072131, "releases": {"0.10.0": [{"comment_text": "", "digests": {"md5": "6a2a8776e6b998535a802a287ccbc688", "sha256": "7af0cd6e4be17a1494de5c845dedee2ec2549884e096568db3df434158b5d687"}, "downloads": -1, "filename": "m01.mongo-0.10.0.zip", "has_sig": false, "md5_digest": "6a2a8776e6b998535a802a287ccbc688", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 110564, "upload_time": "2012-12-16T09:01:46", "upload_time_iso_8601": "2012-12-16T09:01:46.073477Z", "url": "https://files.pythonhosted.org/packages/a0/e7/be5e35cc2ce9ce358de97b9a2e041156944630b673791a66b0180abd9cef/m01.mongo-0.10.0.zip", "yanked": false}], "0.10.1": [{"comment_text": "", "digests": {"md5": "8d8e4ea73cc106d9b7dbc4a7a76c1e35", "sha256": "568c72885c4a6d3a6994e92f9086b683e027453d7b2575b0b17e5d38b4e20cdd"}, "downloads": -1, "filename": "m01.mongo-0.10.1.zip", "has_sig": false, "md5_digest": "8d8e4ea73cc106d9b7dbc4a7a76c1e35", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 111601, "upload_time": "2012-12-19T05:39:15", "upload_time_iso_8601": "2012-12-19T05:39:15.099768Z", "url": "https://files.pythonhosted.org/packages/e4/87/8dcd5f1280e0d5bf844bfc282cfecf3f5a9e580bc72bd12da725ab022a4c/m01.mongo-0.10.1.zip", "yanked": false}], "0.10.2": [{"comment_text": "", "digests": {"md5": "e2132e9a894291755bc38b40bb1af258", "sha256": "eb6995feb169201e037a0a4573de70b1adcfc2969d208fcd0810231b7f21bc82"}, "downloads": -1, "filename": "m01.mongo-0.10.2.zip", "has_sig": false, "md5_digest": "e2132e9a894291755bc38b40bb1af258", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 111660, "upload_time": "2013-01-04T14:36:33", "upload_time_iso_8601": "2013-01-04T14:36:33.716186Z", "url": "https://files.pythonhosted.org/packages/44/ac/a1accd21f023e5c78278f2f6db7aeb7792bc422de6e31498d419cdb20c53/m01.mongo-0.10.2.zip", "yanked": false}], "0.11.0": [{"comment_text": "", "digests": {"md5": "236fbeee54af05615bdfd5977d9d6579", "sha256": "ac043d12056d08ceca0358dc80d4697506fc2fc7ea9c27507621436c5884fbfc"}, "downloads": -1, "filename": "m01.mongo-0.11.0.zip", "has_sig": false, "md5_digest": "236fbeee54af05615bdfd5977d9d6579", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 116236, "upload_time": "2013-11-23T17:14:16", "upload_time_iso_8601": "2013-11-23T17:14:16.689236Z", "url": "https://files.pythonhosted.org/packages/6e/29/f0b389028eacfd6fcfa1bd9018a634e5aea7b3c97a0bd51bb918afb77b0e/m01.mongo-0.11.0.zip", "yanked": false}], "0.11.1": [{"comment_text": "", "digests": {"md5": "2ebdf71f0b10674e133bac3f1f9d3af7", "sha256": "8fb85a5cc5c1c0d68d9e9aae14ccedacc80cebabe910a6ffcf5bc93620216675"}, "downloads": -1, "filename": "m01.mongo-0.11.1.zip", "has_sig": false, "md5_digest": "2ebdf71f0b10674e133bac3f1f9d3af7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 116424, "upload_time": "2014-04-10T08:28:54", "upload_time_iso_8601": "2014-04-10T08:28:54.385411Z", "url": "https://files.pythonhosted.org/packages/3f/7f/11bdc58da0aa298017c8055c7c6741b33a9cfe83c4c661feaab7bda2f62c/m01.mongo-0.11.1.zip", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "2a2c0fab4751708ea4debb1b87e9e7a0", "sha256": "cdf56519da740d0ac954f799cd1f8ac205287f82b8d6476413d486e3c908d35e"}, "downloads": -1, "filename": "m01.mongo-0.5.0.zip", "has_sig": false, "md5_digest": "2a2c0fab4751708ea4debb1b87e9e7a0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 94923, "upload_time": "2011-08-19T03:13:48", "upload_time_iso_8601": "2011-08-19T03:13:48.491398Z", "url": "https://files.pythonhosted.org/packages/71/0d/c8954732786f69507904c851185c2ea801b7dc8cb64274c4a706a878b976/m01.mongo-0.5.0.zip", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "f9746c35f48c2f7a792f391a0f16fdbd", "sha256": "1318352a5db3ae9305d7b9330fb4198012bfaa2f8d76f717643e7e69bd36ecb8"}, "downloads": -1, "filename": "m01.mongo-0.5.1.tar.gz", "has_sig": false, "md5_digest": "f9746c35f48c2f7a792f391a0f16fdbd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 74931, "upload_time": "2011-09-09T13:49:17", "upload_time_iso_8601": "2011-09-09T13:49:17.502976Z", "url": "https://files.pythonhosted.org/packages/c2/ba/1e8a021f14af9969b2731ccc30030ee4cc33631b76d8aea3f0c92e833799/m01.mongo-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "d4a56b5e8ed1c6fab385c0f9b83ea4e5", "sha256": "ab69efd8e81fe27501e7ace683adb51de0846e4bb58919294b8a39728027b6e5"}, "downloads": -1, "filename": "m01.mongo-0.5.2.tar.gz", "has_sig": false, "md5_digest": "d4a56b5e8ed1c6fab385c0f9b83ea4e5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78323, "upload_time": "2011-09-19T16:23:31", "upload_time_iso_8601": "2011-09-19T16:23:31.807027Z", "url": "https://files.pythonhosted.org/packages/5c/a8/0351f55be8292163184525f00118c92c1a64b961b8b48d103bd73f26c854/m01.mongo-0.5.2.tar.gz", "yanked": false}], "0.5.3": [{"comment_text": "", "digests": {"md5": "87f3bc5faad38a7c61015a25641ce27e", "sha256": "ae0431bbe04e03c69dd0864bea43129b33678695041161f319d789560f0aa7bb"}, "downloads": -1, "filename": "m01.mongo-0.5.3.tar.gz", "has_sig": false, "md5_digest": "87f3bc5faad38a7c61015a25641ce27e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78795, "upload_time": "2011-09-20T13:17:48", "upload_time_iso_8601": "2011-09-20T13:17:48.104588Z", "url": "https://files.pythonhosted.org/packages/19/d6/2b78b2d5a039d8bc2d01e45e1fcb643a40d98ba440e53a4abcf7319a23ac/m01.mongo-0.5.3.tar.gz", "yanked": false}], "0.5.4": [{"comment_text": "", "digests": {"md5": "7dc31ba157af06a8dae972dac6d14838", "sha256": "8e8ba9c95ba8e499544c9249c58be8084da85c7288ede82ea62f7d9ea48e3abb"}, "downloads": -1, "filename": "m01.mongo-0.5.4.tar.gz", "has_sig": false, "md5_digest": "7dc31ba157af06a8dae972dac6d14838", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78912, "upload_time": "2011-09-27T10:34:42", "upload_time_iso_8601": "2011-09-27T10:34:42.120217Z", "url": "https://files.pythonhosted.org/packages/18/37/7dc5cd41ab4d915e04a60392e4792f6388ddf72a35f8c8b60c9f13331d4a/m01.mongo-0.5.4.tar.gz", "yanked": false}], "0.5.5": [{"comment_text": "", "digests": {"md5": "809b300c55efee36dbc3f17eec0663f9", "sha256": "8d8fbb59a9efa8dd266742dd486cdad0f18cd270e3fcf2267353babb3d8101ae"}, "downloads": -1, "filename": "m01.mongo-0.5.5.tar.gz", "has_sig": false, "md5_digest": "809b300c55efee36dbc3f17eec0663f9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 79416, "upload_time": "2011-10-14T10:52:17", "upload_time_iso_8601": "2011-10-14T10:52:17.938071Z", "url": "https://files.pythonhosted.org/packages/0b/b7/0ea46a86e869d1efe54729df221c1eccf8b878cd7ee6276173927d869071/m01.mongo-0.5.5.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "0ee7562f5815908fd5fc87564e857acf", "sha256": "10a56d5e5a3a86c168c39611232f9ffc029361b829bb75027f3beb841d6a8557"}, "downloads": -1, "filename": "m01.mongo-0.6.0.tar.gz", "has_sig": false, "md5_digest": "0ee7562f5815908fd5fc87564e857acf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 83845, "upload_time": "2012-01-17T19:13:47", "upload_time_iso_8601": "2012-01-17T19:13:47.384947Z", "url": "https://files.pythonhosted.org/packages/e2/9f/c476e6a4d0cf2b59d24eed0ffbb02532d6de7d71fedbaa77b0ed55085eb7/m01.mongo-0.6.0.tar.gz", "yanked": false}], "0.6.1": [{"comment_text": "", "digests": {"md5": "08f92e9b3807d001f8d2ceba945b41d3", "sha256": "d0a91d96e419d5563991ba8e12ba66cec031bb3bf058fc1c38d0bdd74744a2d8"}, "downloads": -1, "filename": "m01.mongo-0.6.1.tar.gz", "has_sig": false, "md5_digest": "08f92e9b3807d001f8d2ceba945b41d3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 83345, "upload_time": "2012-03-12T13:14:38", "upload_time_iso_8601": "2012-03-12T13:14:38.753501Z", "url": "https://files.pythonhosted.org/packages/c8/4b/720fb9e378be487a21953fd4a3e42d9f6413905dc105b66f4f50b481a75f/m01.mongo-0.6.1.tar.gz", "yanked": false}], "0.6.2": [{"comment_text": "", "digests": {"md5": "a3f90dcd14bdecf3a77e94a40952fa09", "sha256": "1b1dbd299ab221c123b3f08bb9e22c4e0ef29824a5cba318b398bd8901cd61c2"}, "downloads": -1, "filename": "m01.mongo-0.6.2.tar.gz", "has_sig": false, "md5_digest": "a3f90dcd14bdecf3a77e94a40952fa09", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 83419, "upload_time": "2012-03-12T13:18:49", "upload_time_iso_8601": "2012-03-12T13:18:49.371767Z", "url": "https://files.pythonhosted.org/packages/9a/45/c54566feccc3af1e1539a633b9daaf2ef938bc6f6ad9ff5d13edce7a28a0/m01.mongo-0.6.2.tar.gz", "yanked": false}], "0.7.0": [{"comment_text": "", "digests": {"md5": "9d3610ad0a173198c7fdc2aca512616d", "sha256": "f723669aadc49b4520859e2f23b0e2890ab27b258864ec31bd95cfd0460b6547"}, "downloads": -1, "filename": "m01.mongo-0.7.0.tar.gz", "has_sig": false, "md5_digest": "9d3610ad0a173198c7fdc2aca512616d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 84359, "upload_time": "2012-05-22T13:02:38", "upload_time_iso_8601": "2012-05-22T13:02:38.122555Z", "url": "https://files.pythonhosted.org/packages/9b/0c/f44f8798278f52ee16c9736a6f99a65afa1b87671a01817adaf1dbf6fbc6/m01.mongo-0.7.0.tar.gz", "yanked": false}], "0.8.0": [{"comment_text": "", "digests": {"md5": "45225c31688cf1f9045d2c169abd6a00", "sha256": "9e6d7734abe2ceda312d36f9ab74baae391cc7b75ebeed32204a81cfd1bf22cd"}, "downloads": -1, "filename": "m01.mongo-0.8.0.zip", "has_sig": false, "md5_digest": "45225c31688cf1f9045d2c169abd6a00", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 113502, "upload_time": "2012-11-18T14:23:45", "upload_time_iso_8601": "2012-11-18T14:23:45.473152Z", "url": "https://files.pythonhosted.org/packages/65/b7/cc9fe88ad2752e149b9059d7cf6efbe873c46bf947c3a3d22ae36b2cea08/m01.mongo-0.8.0.zip", "yanked": false}], "0.9.0": [{"comment_text": "", "digests": {"md5": "6b004fafebc2f6ebebcd07c4e18da6f1", "sha256": "5c1e9b0bcced6a10434eb46ee2b015dc1c9c8c334e489372c4d312045f757750"}, "downloads": -1, "filename": "m01.mongo-0.9.0.zip", "has_sig": false, "md5_digest": "6b004fafebc2f6ebebcd07c4e18da6f1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 109946, "upload_time": "2012-12-10T03:34:13", "upload_time_iso_8601": "2012-12-10T03:34:13.165999Z", "url": "https://files.pythonhosted.org/packages/96/4c/a87ae245e0b4c76aa8d7a94fdad3933678ac6f769c0379711427997352c2/m01.mongo-0.9.0.zip", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "c9dc55a6655de33afc272d7c8e54dbfb", "sha256": "54e32a6e951e3119901a765f5554aa7ee35a5022265ca492b6e6f43cf74941e1"}, "downloads": -1, "filename": "m01.mongo-1.0.0.zip", "has_sig": false, "md5_digest": "c9dc55a6655de33afc272d7c8e54dbfb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 118719, "upload_time": "2015-03-17T13:23:21", "upload_time_iso_8601": "2015-03-17T13:23:21.837699Z", "url": "https://files.pythonhosted.org/packages/2e/0e/fa878a17342e9408a9473bf561eafc218a572ecfe3df3a8c9272f2fadbda/m01.mongo-1.0.0.zip", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "e08181ee56add07d3f154c052cfa375c", "sha256": "90ea0d3c197dcf27f041ca2a248ecf26085086d1e5132c08fcd1b3160f74c01d"}, "downloads": -1, "filename": "m01.mongo-3.0.0.zip", "has_sig": false, "md5_digest": "e08181ee56add07d3f154c052cfa375c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 120356, "upload_time": "2015-11-11T12:54:35", "upload_time_iso_8601": "2015-11-11T12:54:35.074254Z", "url": "https://files.pythonhosted.org/packages/b7/74/1a7081a4f53dccfa2480c504661a97c65e6f834c794a9f05ffc495ea5688/m01.mongo-3.0.0.zip", "yanked": false}], "3.1.0": [{"comment_text": "", "digests": {"md5": "3719c7ee372655a739300125c02e03e6", "sha256": "f5fdb8a4bcd6b3288862f194d71f1ee5c0fb046f72f727e754ca876dbe60e1d4"}, "downloads": -1, "filename": "m01.mongo-3.1.0.tar.gz", "has_sig": false, "md5_digest": "3719c7ee372655a739300125c02e03e6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 112621, "upload_time": "2017-01-22T20:24:39", "upload_time_iso_8601": "2017-01-22T20:24:39.035614Z", "url": "https://files.pythonhosted.org/packages/f3/a0/3519c95ba0fe74175b31622e2a3ff4c96499376862a903d62fdcf31581d0/m01.mongo-3.1.0.tar.gz", "yanked": false}], "3.2.0": [{"comment_text": "", "digests": {"md5": "bc7eb8caf199cc933b94c22f45b756df", "sha256": "7ba88d1bf61b366c210837dcef4933ddce0db5239226e83e1886e08e4eadb177"}, "downloads": -1, "filename": "m01.mongo-3.2.0.tar.gz", "has_sig": false, "md5_digest": "bc7eb8caf199cc933b94c22f45b756df", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 116120, "upload_time": "2018-01-29T02:08:59", "upload_time_iso_8601": "2018-01-29T02:08:59.920429Z", "url": "https://files.pythonhosted.org/packages/a0/50/0e9c7ba53fd7f5d5399220a19295c5f9680d279687234efeb370826599ec/m01.mongo-3.2.0.tar.gz", "yanked": false}], "3.2.1": [{"comment_text": "", "digests": {"md5": "159d77d8e5d6ced62622c67eb14e7d47", "sha256": "2a16d1cdf79dd544ba72ccc4eefdacdc8cf63afa2d46bd571593326754e7e3f8"}, "downloads": -1, "filename": "m01.mongo-3.2.1.tar.gz", "has_sig": false, "md5_digest": "159d77d8e5d6ced62622c67eb14e7d47", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 116327, "upload_time": "2018-01-29T16:30:48", "upload_time_iso_8601": "2018-01-29T16:30:48.289803Z", "url": "https://files.pythonhosted.org/packages/60/c6/a7d4bcfe4b2d869201a57c25b0e5bbc409fda5156acb170078e498af1301/m01.mongo-3.2.1.tar.gz", "yanked": false}], "3.2.2": [{"comment_text": "", "digests": {"md5": "8b98e3b86bf67e1c9ea331ec5d431a18", "sha256": "48602962d03652cae4a469852f11d8dd55d617ad3ebdc16ae580b191d4e7e2bb"}, "downloads": -1, "filename": "m01.mongo-3.2.2.tar.gz", "has_sig": false, "md5_digest": "8b98e3b86bf67e1c9ea331ec5d431a18", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 116495, "upload_time": "2018-01-29T17:57:59", "upload_time_iso_8601": "2018-01-29T17:57:59.307710Z", "url": "https://files.pythonhosted.org/packages/dc/96/16862271f94e669d8658b1d4de93fda8a3c3d0cba27de623185fa6b7da6d/m01.mongo-3.2.2.tar.gz", "yanked": false}], "3.2.3": [{"comment_text": "", "digests": {"md5": "d4322471f5c25332fc0be011a723bc82", "sha256": "471ae7a8c4f76ba2421c56d0f24314ea51887cdc51bad47a75d1e92efc883c24"}, "downloads": -1, "filename": "m01.mongo-3.2.3.tar.gz", "has_sig": false, "md5_digest": "d4322471f5c25332fc0be011a723bc82", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 116849, "upload_time": "2018-02-04T08:43:12", "upload_time_iso_8601": "2018-02-04T08:43:12.683803Z", "url": "https://files.pythonhosted.org/packages/0a/24/2e46886f8bda1419cc2895b4afae3dd94de204b18415d1ed3a4c1876c976/m01.mongo-3.2.3.tar.gz", "yanked": false}], "3.3.0": [{"comment_text": "", "digests": {"md5": "b87fb1c1433f38ed5bb6ba2ff1a1bfbf", "sha256": "99646c2c4e57b22bf2fcd9861ed0ba57d55ee5dfffea5c408a95bb1d3fae285a"}, "downloads": -1, "filename": "m01.mongo-3.3.0.tar.gz", "has_sig": false, "md5_digest": "b87fb1c1433f38ed5bb6ba2ff1a1bfbf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 116426, "upload_time": "2018-02-04T12:52:37", "upload_time_iso_8601": "2018-02-04T12:52:37.438995Z", "url": "https://files.pythonhosted.org/packages/2b/1b/315204801f5400b1111be36a2342ffe1f6095874e630a123136b4c38bec4/m01.mongo-3.3.0.tar.gz", "yanked": false}], "3.3.1": [{"comment_text": "", "digests": {"md5": "29d9f33841c77d2ea22e61a16437c3bc", "sha256": "112174237dc5bb159da431af2af449fa712a767e99019c84e527cb09f3322b72"}, "downloads": -1, "filename": "m01.mongo-3.3.1.tar.gz", "has_sig": false, "md5_digest": "29d9f33841c77d2ea22e61a16437c3bc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 123592, "upload_time": "2020-04-21T22:51:07", "upload_time_iso_8601": "2020-04-21T22:51:07.360469Z", "url": "https://files.pythonhosted.org/packages/61/61/99872df1d761338ef9eb7e59b3c9093f3bb544e17baa10f47195a509abb9/m01.mongo-3.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "29d9f33841c77d2ea22e61a16437c3bc", "sha256": "112174237dc5bb159da431af2af449fa712a767e99019c84e527cb09f3322b72"}, "downloads": -1, "filename": "m01.mongo-3.3.1.tar.gz", "has_sig": false, "md5_digest": "29d9f33841c77d2ea22e61a16437c3bc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 123592, "upload_time": "2020-04-21T22:51:07", "upload_time_iso_8601": "2020-04-21T22:51:07.360469Z", "url": "https://files.pythonhosted.org/packages/61/61/99872df1d761338ef9eb7e59b3c9093f3bb544e17baa10f47195a509abb9/m01.mongo-3.3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:42:35 2020"}