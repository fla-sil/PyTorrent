{"info": {"author": "GoDaddy", "author_email": "devs@locu.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7"], "description": "# PyKronos\n\n## Introduction\n\nThe contents of this file can be found in `demo.py` and are compiled\ninto `README.md`, so you can consume the readme while running the\nPython script to understand how it works.\n\n## Importing PyKronos And Some Useful Utilities\n\nCheck out `pykronos.client` and `pykronos.common.time` for some useful\nutility functions.  PyKronos has a bunch of utilities to deal with\n`datetime` objects.\n```python\nfrom pykronos.client import ID_FIELD\nfrom pykronos.client import TIMESTAMP_FIELD\nfrom pykronos.client import KronosClient\nfrom pykronos.client import ResultOrder\nfrom pykronos.common.time import datetime_to_kronos_time\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom dateutil.tz import tzutc\n```\n## Creating A Client\n\nCreate a Kronos client with the URL of a running server.  Optionally\nprovide a `namespace` to explicitly work with events in a particular\nnamespace.\n```python\nkc = KronosClient('http://localhost:8151', namespace='kronos')\nstart = datetime.now(tz=tzutc())\n```\n### A Non-blocking Client\n\nPass a `blocking=False` to the KronosClient constructor for a client\nthat won't block on the Kronos server when you insert data.  A\nbackground thread will batch up data and send it to the server.  This\nis useful for logging/metrics collection on machines that can't wait\nfor a write acknowledgement.  An optional `sleep_block` argument,\ndefaulting to `0.1` specifies how many seconds to wait between batches\nto the server.  If the process running the client crashes before\nflushing events, those events will be lost.\n```python\nnonblocking = KronosClient('http://localhost:8151', namespace='kronos',\n                           blocking=False)\n```\n## Inserting Events\n\nInsert events with the `put` command.  The argument is a dictionary of\nstream names (e.g., `yourproduct.website.pageviews`) to a list of\nJSON-encodable dictionaries to insert to each stream.\n```python\nkc.put(\n  {'yourproduct.website.pageviews': [\n      {'source': 'http://test.com',\n       'browser': {'name': 'Firefox', 'version': 26},\n       'pages': ['page1.html', 'page2.html']}],\n   'yourproduct.website.clicks': [\n      {'user': 40, 'num_clicks': 7},\n      {'user': 42, 'num_clicks': 2}]\n   })\n```\n### Optionally Add A Timestamp\n\nBy default, each event will be timestamped on the client.  If you add\na `TIMESTAMP_FIELD` argument, you can specify the time at which each\nevent ocurred.\n```python\noptional_time = datetime_to_kronos_time(start + timedelta(seconds=5))\nkc.put({'yourproduct.website.clicks': [\n  {'user': 35, 'num_clicks': 10, TIMESTAMP_FIELD: optional_time}]})\n\n```\n## Retrieving Events\n\nRetrieving events requires a stream name, a start datetime, and an end\ndatetime.  Note that an `ID_FIELD` and `@TIMESTAMP_FIELD` field are\nattached to each event.  The `ID_FIELD` is a UUID1-style identifier\nwith its time bits derived from the timestamp.  This allows event IDs\nto be roughly sortable by the time that they happened while providing\na deterministic tiebreaker when two events happened at the same time.\n```python\nevents = kc.get('yourproduct.website.clicks',\n                start,\n                start + timedelta(minutes=10))\nfor event in events:\n  print 'Received event', event\n  last_event_id = event[ID_FIELD]\n```\n### Event Order\n\nBy default, events are returned in ascending order of their\n`ID_FIELD`.  Pass in an`order=ResultOrder.DESCENDING` argument to\nchange this behavior to be in descending order of `ID_FIELD`.\n```python\nevents = kc.get('yourproduct.website.clicks',\n                start,\n                start + timedelta(minutes=10),\n                order=ResultOrder.DESCENDING)\nfor event in events:\n  print 'Reverse event', event\n  last_event_id = event[ID_FIELD]\n```\n### Limiting Events\n\nIf you only want to retrieve a limited number of events, use the\n`limit` argument.\n```python\nevents = kc.get('yourproduct.website.clicks',\n                start,\n                start + timedelta(minutes=10),\n                order=ResultOrder.DESCENDING,\n                limit=1)\nfor event in events:\n  print 'Limited event', event\n  last_event_id = event[ID_FIELD]\n```\n## Getting A List Of Streams\n\nTo see all streams available in this namespace, use `get_streams`.\n```python\nfor stream in kc.get_streams():\n  print 'Found stream', stream\n```\n## Inferred Schema\n\nYou can retrieve a schema for a stream. The schema is inferred from the\nstructure of the individual events. The schema protocol is based on JSON Schema\nv4.\n```python\nresponse = kc.infer_schema('yourproduct.website.clicks')\nprint response['schema']\n```\n## Deleting Events\n\nSometimes, we make an oopsie and need to delete some events.  The\n`delete` function takes similar arguments for the start and end\ntimestamps to delete.\n\nNote: The most common Kronos use cases are for write-mostly systems\nwith high-throughput reads.  As such, you can imagine that most\nbackends will not be delete-optimized.  There's nothing in the Kronos\nAPI that inherently makes deletes not performant, but we imagine some\nbackends will make tradeoffs to optimize their write and read paths at\nthe expense of fast deletes.\n```python\nkc.delete('yourproduct.website.clicks',\n          start + timedelta(seconds=5),\n          start + timedelta(minutes=10))\n\nevents = kc.get('yourproduct.website.clicks',\n                start,\n                start + timedelta(minutes=10))\nfor event in events:\n  print 'Received event', event\n```", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Locu/chronology/pykronos", "keywords": "kronos,analytics,metrics,client,logging", "license": "MIT License", "maintainer": null, "maintainer_email": null, "name": "pykronos", "package_url": "https://pypi.org/project/pykronos/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pykronos/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/Locu/chronology/pykronos"}, "release_url": "https://pypi.org/project/pykronos/0.6.2/", "requires_dist": null, "requires_python": null, "summary": "A Python client for the Kronos time series storage engine", "version": "0.6.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            # PyKronos<br><br>## Introduction<br><br>The contents of this file can be found in `demo.py` and are compiled<br>into `README.md`, so you can consume the readme while running the<br>Python script to understand how it works.<br><br>## Importing PyKronos And Some Useful Utilities<br><br>Check out `pykronos.client` and `pykronos.common.time` for some useful<br>utility functions.  PyKronos has a bunch of utilities to deal with<br>`datetime` objects.<br>```python<br>from pykronos.client import ID_FIELD<br>from pykronos.client import TIMESTAMP_FIELD<br>from pykronos.client import KronosClient<br>from pykronos.client import ResultOrder<br>from pykronos.common.time import datetime_to_kronos_time<br>from datetime import datetime<br>from datetime import timedelta<br>from dateutil.tz import tzutc<br>```<br>## Creating A Client<br><br>Create a Kronos client with the URL of a running server.  Optionally<br>provide a `namespace` to explicitly work with events in a particular<br>namespace.<br>```python<br>kc = KronosClient('http://localhost:8151', namespace='kronos')<br>start = datetime.now(tz=tzutc())<br>```<br>### A Non-blocking Client<br><br>Pass a `blocking=False` to the KronosClient constructor for a client<br>that won't block on the Kronos server when you insert data.  A<br>background thread will batch up data and send it to the server.  This<br>is useful for logging/metrics collection on machines that can't wait<br>for a write acknowledgement.  An optional `sleep_block` argument,<br>defaulting to `0.1` specifies how many seconds to wait between batches<br>to the server.  If the process running the client crashes before<br>flushing events, those events will be lost.<br>```python<br>nonblocking = KronosClient('http://localhost:8151', namespace='kronos',<br>                           blocking=False)<br>```<br>## Inserting Events<br><br>Insert events with the `put` command.  The argument is a dictionary of<br>stream names (e.g., `yourproduct.website.pageviews`) to a list of<br>JSON-encodable dictionaries to insert to each stream.<br>```python<br>kc.put(<br>  {'yourproduct.website.pageviews': [<br>      {'source': 'http://test.com',<br>       'browser': {'name': 'Firefox', 'version': 26},<br>       'pages': ['page1.html', 'page2.html']}],<br>   'yourproduct.website.clicks': [<br>      {'user': 40, 'num_clicks': 7},<br>      {'user': 42, 'num_clicks': 2}]<br>   })<br>```<br>### Optionally Add A Timestamp<br><br>By default, each event will be timestamped on the client.  If you add<br>a `TIMESTAMP_FIELD` argument, you can specify the time at which each<br>event ocurred.<br>```python<br>optional_time = datetime_to_kronos_time(start + timedelta(seconds=5))<br>kc.put({'yourproduct.website.clicks': [<br>  {'user': 35, 'num_clicks': 10, TIMESTAMP_FIELD: optional_time}]})<br><br>```<br>## Retrieving Events<br><br>Retrieving events requires a stream name, a start datetime, and an end<br>datetime.  Note that an `ID_FIELD` and `@TIMESTAMP_FIELD` field are<br>attached to each event.  The `ID_FIELD` is a UUID1-style identifier<br>with its time bits derived from the timestamp.  This allows event IDs<br>to be roughly sortable by the time that they happened while providing<br>a deterministic tiebreaker when two events happened at the same time.<br>```python<br>events = kc.get('yourproduct.website.clicks',<br>                start,<br>                start + timedelta(minutes=10))<br>for event in events:<br>  print 'Received event', event<br>  last_event_id = event[ID_FIELD]<br>```<br>### Event Order<br><br>By default, events are returned in ascending order of their<br>`ID_FIELD`.  Pass in an`order=ResultOrder.DESCENDING` argument to<br>change this behavior to be in descending order of `ID_FIELD`.<br>```python<br>events = kc.get('yourproduct.website.clicks',<br>                start,<br>                start + timedelta(minutes=10),<br>                order=ResultOrder.DESCENDING)<br>for event in events:<br>  print 'Reverse event', event<br>  last_event_id = event[ID_FIELD]<br>```<br>### Limiting Events<br><br>If you only want to retrieve a limited number of events, use the<br>`limit` argument.<br>```python<br>events = kc.get('yourproduct.website.clicks',<br>                start,<br>                start + timedelta(minutes=10),<br>                order=ResultOrder.DESCENDING,<br>                limit=1)<br>for event in events:<br>  print 'Limited event', event<br>  last_event_id = event[ID_FIELD]<br>```<br>## Getting A List Of Streams<br><br>To see all streams available in this namespace, use `get_streams`.<br>```python<br>for stream in kc.get_streams():<br>  print 'Found stream', stream<br>```<br>## Inferred Schema<br><br>You can retrieve a schema for a stream. The schema is inferred from the<br>structure of the individual events. The schema protocol is based on JSON Schema<br>v4.<br>```python<br>response = kc.infer_schema('yourproduct.website.clicks')<br>print response['schema']<br>```<br>## Deleting Events<br><br>Sometimes, we make an oopsie and need to delete some events.  The<br>`delete` function takes similar arguments for the start and end<br>timestamps to delete.<br><br>Note: The most common Kronos use cases are for write-mostly systems<br>with high-throughput reads.  As such, you can imagine that most<br>backends will not be delete-optimized.  There's nothing in the Kronos<br>API that inherently makes deletes not performant, but we imagine some<br>backends will make tradeoffs to optimize their write and read paths at<br>the expense of fast deletes.<br>```python<br>kc.delete('yourproduct.website.clicks',<br>          start + timedelta(seconds=5),<br>          start + timedelta(minutes=10))<br><br>events = kc.get('yourproduct.website.clicks',<br>                start,<br>                start + timedelta(minutes=10))<br>for event in events:<br>  print 'Received event', event<br>```\n          </div>"}, "last_serial": 1301232, "releases": {"0.6.0": [{"comment_text": "", "digests": {"md5": "8d1d07c89581d3a336c40d21d4ca83a4", "sha256": "5bd41598ae4939677e41ce9ae857e2664173d6cba82ca454efbbebe48b6f73e2"}, "downloads": -1, "filename": "pykronos-0.6.0.tar.gz", "has_sig": false, "md5_digest": "8d1d07c89581d3a336c40d21d4ca83a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29957, "upload_time": "2014-08-19T02:19:32", "upload_time_iso_8601": "2014-08-19T02:19:32.084117Z", "url": "https://files.pythonhosted.org/packages/e0/99/199e60b317068d01bf00416b7568610897d8e25f149d46cd8879c0f20612/pykronos-0.6.0.tar.gz", "yanked": false}], "0.6.2": [{"comment_text": "", "digests": {"md5": "db518d7a15d56ecaca2d762a669dbd64", "sha256": "baf53df5116a03a1c244c192ceb3801f84eec40762422b8f10a16b868de40662"}, "downloads": -1, "filename": "pykronos-0.6.2.tar.gz", "has_sig": false, "md5_digest": "db518d7a15d56ecaca2d762a669dbd64", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31692, "upload_time": "2014-11-10T16:44:57", "upload_time_iso_8601": "2014-11-10T16:44:57.918261Z", "url": "https://files.pythonhosted.org/packages/8b/b9/d117ce9143d57075ebe9c22ae521a3ef94880e9f4f0c7c2e03cf5d781ae9/pykronos-0.6.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "db518d7a15d56ecaca2d762a669dbd64", "sha256": "baf53df5116a03a1c244c192ceb3801f84eec40762422b8f10a16b868de40662"}, "downloads": -1, "filename": "pykronos-0.6.2.tar.gz", "has_sig": false, "md5_digest": "db518d7a15d56ecaca2d762a669dbd64", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31692, "upload_time": "2014-11-10T16:44:57", "upload_time_iso_8601": "2014-11-10T16:44:57.918261Z", "url": "https://files.pythonhosted.org/packages/8b/b9/d117ce9143d57075ebe9c22ae521a3ef94880e9f4f0c7c2e03cf5d781ae9/pykronos-0.6.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:27 2020"}