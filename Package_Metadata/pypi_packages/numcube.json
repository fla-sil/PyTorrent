{"info": {"author": "Vladimir Kraus", "author_email": "vladimir.kraus@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "numcube package\n===============\n\nNumcube extends the functionality of numpy multidimensional arrays by adding named and annotated axes. Such\nstructures are called cubes. Numcube allows operations involving multiple cubes with automatic axis matching and\nalignment. It allows filtering and aggregations based on the axis values. One of the goals was to provide API similar\nto numpy. Internally it uses numpy arrays for the underlying array and axes as well.\n\nAxis matching\n-------------\n\nIn operations involving multiple cubes, the axes are matched and aligned. Matching means that axis names are compared\nand the axes with the same names are aligned (see below), while the unique axes are broadcast (see array\nbroadcasting).\n\nThe cube is meant to not depend on the specific order of axes in most of the features. Nevertheless, the output of\nthe operation has the same order of axes as the first cube in the operation, followed by unique axes from the other\ncubes respecting their order.\n\nAxis alignment\n--------------\n\nThere are basically two types of axes. There are two types of axes - Index and Series. Series has a fixed order or\nvalues and the values do not need to be unique. Index must have unique values, which can be used for look up during\naxis alignment.\n\nIf one of the axes is Series and the other is Index, then the values in Series must be subset of those in Index; the\nresult axis is the Series axis.\n\nIf both axes are of type Index, they must contain the same values; the values however can have different order; the\nresult axis is the first Index axis.\n\nIf both axes are Series, they must be equivalent - they must contain the same values in the same order. The result\naxis is the first Series axis.\n\nFiltering values\n----------------\n\nCubes can be filtered using three distinct methods:\n1) filtering by axis values - function filter(...)\n2) filtering by index along axes - function take(...)\n3) filtering by logical selectors along axes - function compress(...)\n\nFunctions take(...) and compress(...) have the same semantics as in numpy package.\n\n```python\n>> from numcube import Index, Cube\n>> Y = Index(\"year\", range(2014, 3))\n>> Q = Index(\"quarter\", [\"Q1\", \"Q2\", \"Q3\", \"Q4\"])\n>> sales = Cube([[14, 16, 13, 20], [15, 15, 10, 19], [16, 17, 15, 21]], [Y, Q])\n>> # filter by dimension attribute\n>> salesH1 = sales.filter(\"quarter\", [\"Q1\", \"Q2\"])\n>> # filter by numeric indices\n>> salesH1 = sales.take(\"quarter\", [0, 1])\n>> # filter by logical vector\n>> filter_q = np.array([True, True, False, False]\n>> salesH1 = sales.compress(\"quarter\", filter_q))\n```\n\nOperators\n---------\n\nCubes support arithmetical operations between two cubes. The cube axes are matched and aligned and the operations\nare performed element-wise.\n\n```python\n>> from numcube import Index, Cube\n>> year_ax = Index(\"year\", [2014, 2015])\n>> quarter_ax = Index(\"quarter\", [\"Q1\", \"Q2\", \"Q3\", \"Q4\"])\n>> sales = Cube([[14, 16, 13, 20], [15, 15, 10, 19]], [year_ax, quarter_ax])\n>> prices = Cube([1.50, 1.52, 1.53, 1.55], [year_ax])\n>> revenues_q = sales * prices  # quarterly revenues\n```\n\nCube can also be in operation with a scalar value, which is treated as dimensionless Cube.\n\n```python\n>> Y = Index(\"year\", range(2014, 2))\n>> Q = Index(\"quarter\", [\"Q1\", \"Q2\", \"Q3\", \"Q4\"])\n>> prices = Cube([[1.50, 1.52, 1.53, 1.55], [1.48, 1.47, 1.46, 1.49], [Y, Q])\n>> discount = 0.5\n>> discounted_prices = sales * discount  # operation with scalar\n```\n\nAggregations\n------------\n\nCube values can be aggregated along axes using aggregation functions sum, mean, min, max, etc. All aggregation\nfunctions allow defining which axes are going to be aggregated, which are to be kept or values on which are going\nto be grouped.\n\n```python\n>> total_revenues = revenues.sum()\n>> average_annual_revenues = revenues.mean(\"quarter\")\n>> total_annual_revenues = revenues.sum(keep=\"year\")\n```\n\nAggregations can be also used to group values along an axis with non-unique values., for example:\n```python\n>> subject = Axis('subject', [math', 'biology', 'math', 'physics', 'math', 'biology', 'math', 'physics'])\n>> score = Cube([65, 80, 95, 52, 35, 50, 89, 95], subject)\n>> score_by_subject = score.mean(group='subject')\n```\n\nGeneral aggregation function is reduce(), which it is possible to provide with a user defined aggregation function.\n```python\n>> decile_9th = score.reduce(func=lambda x: np.percentile(x, 90.0))\n```\n\nLogical aggregation functions all() and any() can be used to test whether all or any logical value in a cube is True.\n```python\n>> c = Cube(...)\n>> d = Cube(...)\n>> if (c > d).all():  # to test if all values in c are greater than respective values in d\n```\nNote that comparison operators use the same axis matching, alignment adn broadcasting as normal arithmetic operators.\n\nOther\n-----\n\n- the interface of all classes is designed to support immutability\n- Cube supports numerical functions such as sin, cos, log, exp etc.\n- transposition (in n-dimensional space) changes the order of axes", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/vladimir-kraus/numcube", "keywords": "cube,multidimensional,array,axis", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "numcube", "package_url": "https://pypi.org/project/numcube/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/numcube/", "project_urls": {"Homepage": "http://github.com/vladimir-kraus/numcube"}, "release_url": "https://pypi.org/project/numcube/0.2.0/", "requires_dist": null, "requires_python": null, "summary": "Numcube extends the functionality of numpy multidimensional arrays by adding named and annotated axes.", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Numcube extends the functionality of numpy multidimensional arrays by adding named and annotated axes. Such\nstructures are called cubes. Numcube allows operations involving multiple cubes with automatic axis matching and\nalignment. It allows filtering and aggregations based on the axis values. One of the goals was to provide API similar\nto numpy. Internally it uses numpy arrays for the underlying array and axes as well.</p>\n<div id=\"axis-matching\">\n<h2>Axis matching</h2>\n<p>In operations involving multiple cubes, the axes are matched and aligned. Matching means that axis names are compared\nand the axes with the same names are aligned (see below), while the unique axes are broadcast (see array\nbroadcasting).</p>\n<p>The cube is meant to not depend on the specific order of axes in most of the features. Nevertheless, the output of\nthe operation has the same order of axes as the first cube in the operation, followed by unique axes from the other\ncubes respecting their order.</p>\n</div>\n<div id=\"axis-alignment\">\n<h2>Axis alignment</h2>\n<p>There are basically two types of axes. There are two types of axes - Index and Series. Series has a fixed order or\nvalues and the values do not need to be unique. Index must have unique values, which can be used for look up during\naxis alignment.</p>\n<p>If one of the axes is Series and the other is Index, then the values in Series must be subset of those in Index; the\nresult axis is the Series axis.</p>\n<p>If both axes are of type Index, they must contain the same values; the values however can have different order; the\nresult axis is the first Index axis.</p>\n<p>If both axes are Series, they must be equivalent - they must contain the same values in the same order. The result\naxis is the first Series axis.</p>\n</div>\n<div id=\"filtering-values\">\n<h2>Filtering values</h2>\n<p>Cubes can be filtered using three distinct methods:\n1) filtering by axis values - function filter(\u2026)\n2) filtering by index along axes - function take(\u2026)\n3) filtering by logical selectors along axes - function compress(\u2026)</p>\n<p>Functions take(\u2026) and compress(\u2026) have the same semantics as in numpy package.</p>\n<p><tt>`python\n&gt;&gt; from numcube import Index, Cube\n&gt;&gt; Y = <span class=\"pre\">Index(\"year\",</span> range(2014, 3))\n&gt;&gt; Q = <span class=\"pre\">Index(\"quarter\",</span> [\"Q1\", \"Q2\", \"Q3\", <span class=\"pre\">\"Q4\"])</span>\n&gt;&gt; sales = <span class=\"pre\">Cube([[14,</span> 16, 13, 20], [15, 15, 10, 19], [16, 17, 15, <span class=\"pre\">21]],</span> [Y, Q])\n&gt;&gt; # filter by dimension attribute\n&gt;&gt; salesH1 = <span class=\"pre\">sales.filter(\"quarter\",</span> [\"Q1\", <span class=\"pre\">\"Q2\"])</span>\n&gt;&gt; # filter by numeric indices\n&gt;&gt; salesH1 = <span class=\"pre\">sales.take(\"quarter\",</span> [0, 1])\n&gt;&gt; # filter by logical vector\n&gt;&gt; filter_q = <span class=\"pre\">np.array([True,</span> True, False, False]\n&gt;&gt; salesH1 = <span class=\"pre\">sales.compress(\"quarter\",</span> filter_q))\n`</tt></p>\n</div>\n<div id=\"operators\">\n<h2>Operators</h2>\n<p>Cubes support arithmetical operations between two cubes. The cube axes are matched and aligned and the operations\nare performed element-wise.</p>\n<p><tt>`python\n&gt;&gt; from numcube import Index, Cube\n&gt;&gt; year_ax = <span class=\"pre\">Index(\"year\",</span> [2014, 2015])\n&gt;&gt; quarter_ax = <span class=\"pre\">Index(\"quarter\",</span> [\"Q1\", \"Q2\", \"Q3\", <span class=\"pre\">\"Q4\"])</span>\n&gt;&gt; sales = <span class=\"pre\">Cube([[14,</span> 16, 13, 20], [15, 15, 10, <span class=\"pre\">19]],</span> [year_ax, quarter_ax])\n&gt;&gt; prices = <span class=\"pre\">Cube([1.50,</span> 1.52, 1.53, 1.55], [year_ax])\n&gt;&gt; revenues_q = sales * prices\u00a0 # quarterly revenues\n`</tt></p>\n<p>Cube can also be in operation with a scalar value, which is treated as dimensionless Cube.</p>\n<p><tt>`python\n&gt;&gt; Y = <span class=\"pre\">Index(\"year\",</span> range(2014, 2))\n&gt;&gt; Q = <span class=\"pre\">Index(\"quarter\",</span> [\"Q1\", \"Q2\", \"Q3\", <span class=\"pre\">\"Q4\"])</span>\n&gt;&gt; prices = <span class=\"pre\">Cube([[1.50,</span> 1.52, 1.53, 1.55], [1.48, 1.47, 1.46, 1.49], [Y, Q])\n&gt;&gt; discount = 0.5\n&gt;&gt; discounted_prices = sales * discount\u00a0 # operation with scalar\n`</tt></p>\n</div>\n<div id=\"aggregations\">\n<h2>Aggregations</h2>\n<p>Cube values can be aggregated along axes using aggregation functions sum, mean, min, max, etc. All aggregation\nfunctions allow defining which axes are going to be aggregated, which are to be kept or values on which are going\nto be grouped.</p>\n<p><tt>`python\n&gt;&gt; total_revenues = revenues.sum()\n&gt;&gt; average_annual_revenues = <span class=\"pre\">revenues.mean(\"quarter\")</span>\n&gt;&gt; total_annual_revenues = <span class=\"pre\">revenues.sum(keep=\"year\")</span>\n`</tt></p>\n<p>Aggregations can be also used to group values along an axis with non-unique values., for example:\n<tt>`python\n&gt;&gt; subject = <span class=\"pre\">Axis('subject',</span> [math', 'biology', 'math', 'physics', 'math', 'biology', 'math', <span class=\"pre\">'physics'])</span>\n&gt;&gt; score = <span class=\"pre\">Cube([65,</span> 80, 95, 52, 35, 50, 89, 95], subject)\n&gt;&gt; score_by_subject = <span class=\"pre\">score.mean(group='subject')</span>\n`</tt></p>\n<p>General aggregation function is reduce(), which it is possible to provide with a user defined aggregation function.\n<tt>`python\n&gt;&gt; decile_9th = score.reduce(func=lambda x: np.percentile(x, 90.0))\n`</tt></p>\n<p>Logical aggregation functions all() and any() can be used to test whether all or any logical value in a cube is True.\n<tt>`python\n&gt;&gt; c = <span class=\"pre\">Cube(...)</span>\n&gt;&gt; d = <span class=\"pre\">Cube(...)</span>\n&gt;&gt; if (c &gt; <span class=\"pre\">d).all():</span>\u00a0 # to test if all values in c are greater than respective values in d\n`</tt>\nNote that comparison operators use the same axis matching, alignment adn broadcasting as normal arithmetic operators.</p>\n</div>\n<div id=\"other\">\n<h2>Other</h2>\n<ul>\n<li>the interface of all classes is designed to support immutability</li>\n<li>Cube supports numerical functions such as sin, cos, log, exp etc.</li>\n<li>transposition (in n-dimensional space) changes the order of axes</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 2462439, "releases": {"0.1.5": [], "0.1.6": [{"comment_text": "", "digests": {"md5": "2e8fb4dd950e64af7b672c37aa015d5a", "sha256": "ba9ba96f879334113e86c7cea0e6cfd45b1e265baf7a8f78f6463eddcef39579"}, "downloads": -1, "filename": "numcube-0.1.6.zip", "has_sig": false, "md5_digest": "2e8fb4dd950e64af7b672c37aa015d5a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45893, "upload_time": "2016-08-14T10:58:48", "upload_time_iso_8601": "2016-08-14T10:58:48.908166Z", "url": "https://files.pythonhosted.org/packages/c5/3b/a05d7ce23bdc1e22cde2546c5f526ad8bf9ed51e15f2afb006b65c00df52/numcube-0.1.6.zip", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "1ff9dde4e04a76d03e6bdc109c9f96bd", "sha256": "9bd7c0f7a709ebe726c5d94a472a81e0b8fae6ea833abd2b075dd2c9d66fa9ba"}, "downloads": -1, "filename": "numcube-0.2.0-py2-none-any.whl", "has_sig": false, "md5_digest": "1ff9dde4e04a76d03e6bdc109c9f96bd", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 38098, "upload_time": "2016-11-15T18:46:27", "upload_time_iso_8601": "2016-11-15T18:46:27.993881Z", "url": "https://files.pythonhosted.org/packages/09/7a/1ff00dd7fa4c8a8384a542b65aacc46f26088e9e8421790b9b4ed3d614c6/numcube-0.2.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f92c2f674c588fba7ea36a6b179fafba", "sha256": "ebc49b130063fd7d4cdca7257107a74d062d34f0d0af343c9efcc90759244384"}, "downloads": -1, "filename": "numcube-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "f92c2f674c588fba7ea36a6b179fafba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 38096, "upload_time": "2016-11-15T18:46:31", "upload_time_iso_8601": "2016-11-15T18:46:31.828092Z", "url": "https://files.pythonhosted.org/packages/38/33/1a67a69c0329fca7d79ec5385db427560e13ce5c248524ca5e77ea1ddbb7/numcube-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "03c3ba2f33b3c1136fb893fd031fe970", "sha256": "ed494a10ca3bd1a8924f29bc36950b94f8c18053c823a8bf04064e0cc662fdd0"}, "downloads": -1, "filename": "numcube-0.2.0.tar.gz", "has_sig": false, "md5_digest": "03c3ba2f33b3c1136fb893fd031fe970", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32011, "upload_time": "2016-11-15T18:37:39", "upload_time_iso_8601": "2016-11-15T18:37:39.686950Z", "url": "https://files.pythonhosted.org/packages/e8/80/c953483d0f26a9c49c3588b9a97f95f29500924e2c30503cbe97cd08e430/numcube-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1ff9dde4e04a76d03e6bdc109c9f96bd", "sha256": "9bd7c0f7a709ebe726c5d94a472a81e0b8fae6ea833abd2b075dd2c9d66fa9ba"}, "downloads": -1, "filename": "numcube-0.2.0-py2-none-any.whl", "has_sig": false, "md5_digest": "1ff9dde4e04a76d03e6bdc109c9f96bd", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 38098, "upload_time": "2016-11-15T18:46:27", "upload_time_iso_8601": "2016-11-15T18:46:27.993881Z", "url": "https://files.pythonhosted.org/packages/09/7a/1ff00dd7fa4c8a8384a542b65aacc46f26088e9e8421790b9b4ed3d614c6/numcube-0.2.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f92c2f674c588fba7ea36a6b179fafba", "sha256": "ebc49b130063fd7d4cdca7257107a74d062d34f0d0af343c9efcc90759244384"}, "downloads": -1, "filename": "numcube-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "f92c2f674c588fba7ea36a6b179fafba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 38096, "upload_time": "2016-11-15T18:46:31", "upload_time_iso_8601": "2016-11-15T18:46:31.828092Z", "url": "https://files.pythonhosted.org/packages/38/33/1a67a69c0329fca7d79ec5385db427560e13ce5c248524ca5e77ea1ddbb7/numcube-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "03c3ba2f33b3c1136fb893fd031fe970", "sha256": "ed494a10ca3bd1a8924f29bc36950b94f8c18053c823a8bf04064e0cc662fdd0"}, "downloads": -1, "filename": "numcube-0.2.0.tar.gz", "has_sig": false, "md5_digest": "03c3ba2f33b3c1136fb893fd031fe970", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32011, "upload_time": "2016-11-15T18:37:39", "upload_time_iso_8601": "2016-11-15T18:37:39.686950Z", "url": "https://files.pythonhosted.org/packages/e8/80/c953483d0f26a9c49c3588b9a97f95f29500924e2c30503cbe97cd08e430/numcube-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:15 2020"}