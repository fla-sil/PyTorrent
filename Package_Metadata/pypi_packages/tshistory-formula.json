{"info": {"author": "Pythonian", "author_email": "aurelien.campeas@pythonian.fr", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Database", "Topic :: Scientific/Engineering", "Topic :: Software Development :: Version Control"], "description": "TSHISTORY FORMULA\n=================\n\n# Purpose\n\nThis [tshistory][tshistory] component provides a formula language to\nbuild computed series.\n\nUsing `csv` definition files, one can define formula using a simple\nlisp-like syntax, using a pre-defined function library.\n\nFormulae are read-only series (you can't `update` or `replace`\nvalues).\n\nThey also have an history, which is built, time stamps wise, using the\nunion of all constituent time stamps, and value wise, by applying the\nformula.\n\nBecause of this the `staircase` operator is available on formulae.\nSome `staircase` operations can have a very fast implementation if the\nformula obeys commutativity rules.\n\n[tshistory]: https://bitbucket.org/pythonian/tshistory\n\n\n# Formula\n\n## General Syntax\n\nFormulas are expressed in a lisp-like syntax using `operators`,\npositional (mandatory) parameters and keyword (optional) parameters.\n\nThe general form is:\n\n `(<operator> <param1> ... <paramN> #:<keyword1> <value1> ... #:<keywordN> <valueN>)`\n\nHere are a couple examples:\n\n* `(add (series \"wallonie\") (series \"bruxelles\") (series \"flandres\"))`\n\nHere we see the two fundamental `add` and `series` operators at work.\n\nThis would form a new synthetic series out of three base series (which\ncan be either raw series or formulas themselves).\n\nSome notes:\n\n* operator names can contain dashes or arbitrary caracters\n\n* literal values can be: `3` (integer), `5.2` (float), `\"hello\"`\n  (string) and `#t` or `#f` (true ot false)\n\n\n## Pre-defined operators\n\n### *\n\nPerforms a scalar product on a series.\n\nExample: `(* -1 (series \"positive-things\"))`\n\n### +\n\nAdd a constant quantity to a series.\n\nExample: `(+ 42 (series \"i-feel-undervalued\"))`\n\n### /\n\nPerform a scalar division between numbers or a series and a scalar.\n\nExample: `(/ (series \"div-me\") (/ 3 2))`\n\n### add\n\nLinear combination of two or more series. Takes a variable number\nof series as input.\n\nExample: `(add (series \"wallonie\") (series \"bruxelles\") (series \"flandres\"))`\n\nTo specify the behaviour of the `add` operation in the face of missing\ndata, the series can be built with the `fill` keyword. This option is\nonly really applied when several series are combined. By default, if\nan input series has missing values for a given time stamp, the\nresulting series has no value for this timestamp (unless a fill rule\nis provided).\n\n### clip\n\nSet an upper/lower threashold for a series. Takes a series as\npositional parameter and accepts two optional keywords `min` and `max`\nwhich must be numbers (integers or floats).\n\nExample: `(clip (series \"must-be-positive\") #:min 0)`\n\n### date\n\nProduces an utc timestamp from its input string date in iso format.\n\nThe `tz` keyword allows to specify an alternate time zone.\nThe `naive` keyword forces production of a naive timestamp.\nBoth `tz` and `naive` keywords are mutually exlcusive.\n\n### div\n\nElement wise division of two series.\n\nExample: `(div (series \"$-to-\u20ac\") (series \"\u20ac-to-\u00a3\"))`\n\n### min\n\nComputes the row-wise minimum of its input series.\n\nExample: `(min (series \"station0\") (series \"station1\") (series \"station2\"))`\n\n### max\n\nComputes the row-wise maximum of its input series.\n\nExample: `(max (series \"station0\") (series \"station1\") (series \"station2\"))`\n\n### mul\n\nElement wise multiplication of series. Takes a variable number of series\nas input.\n\nExample: `(mul (series \"banana-spot-price ($)\") (series \"$-to-\u20ac\" #:fill 'ffill'))`\n\nThis might convert a series priced in dollars to a series priced in\neuros, using a currency exchange rate series with a forward-fill\noption.\n\n### naive\n\nAllow demoting a series from a tz-aware index (strongly recommended)\nto a tz-naive index (unfortunately sometimes unavoidable for interop\nwith other tz-naive series).\n\nOne must provide a country code and a target timezone.\n\nExample: `(naive (series \"tz-aware-series-from-poland\") \"PL\" \"Europe/Warsaw\")`\n\n### priority\n\nThe priority operator combines its input series as layers. For each\ntimestamp in the union of all series time stamps, the value comes from\nthe first series that provides a value.\n\nExample: `(priority (series \"realized\") (series \"nominated\") (series \"forecasted\"))`\n\nHere `realized` values show up first, and any missing values come from\n`nominated` first and then only from `forecasted`.\n\n### resample\n\nResamples its input series using `freq` and the aggregation method\n`method` (as described in the pandas documentation).\n\nExample: `(resample (series \"hourly\") \"D\")`\n\n### row-mean\n\nThis operator computes the row-wise mean of its input series using the\nseries `weight` option if present. The missing points are handled as\nif the whole series were absent.\n\nExample: `(row-mean (series \"station0\") (series \"station1\" #:weight 2) (series \"station2\"))`\n\nWeights are provided as a keyword to `series`. No weight is\ninterpreted as 1.\n\n### series\n\nThe `series` operator accepts several keywords:\n\n* `fill` to specify a filling policy to avoid `nans` when the series\n  will be `add`ed with others; accepted values are `\"ffill\"`\n  (forward-fill), `\"bfill\"` (backward-fill) or any floating value.\n\n* `prune` to indicate how many points must be truncated from the tail\n  end (useful for priorities).\n\nFor instance in `(add (series \"a\" #:fill 0) (series \"b\")` will make\nsure that series `a`, if shorter than series `b` will get zeroes\ninstead of nans where `b` provides values.\n\nIn `(series \"realized\" #:prune 3)` we would drop the last three points.\n\n### slice\n\nThis allows cutting a series at date points. It takes one positional\nparameter (the series) and two optional keywords `fromdate` and\n`todate` which must be strings in the [iso8601][iso8601] format.\n\nExample: `(slice (series \"cut-me\") #:fromdate \"2018-01-01\")`\n\n[iso8601]: https://en.wikipedia.org/wiki/ISO_8601\n\n### std\n\nComputes the standard deviation over its input series.\n\nExample: `(std (series \"station0\") (series \"station1\") (series \"station2\"))`\n\n### timedelta\n\nTakes a timestamp and a number of years, months, weekds, days,\nhours, minutes (int) and computes a new date according to the asked\ndelta elements.\n\nExample: `(timedelta (date \"2020-1-1\") #:weeks 1 #:hours 2)`\n\n### today\n\nProduces a timezone-aware timestamp as of today\n\nThe `tz` keyword allows to specify an alternate time zone.\nThe `naive` keyword forces production of a naive timestamp.\nBoth `tz` and `naive` keywords are mutually exlcusive.\n\nExample: `(today)`\n\n\n# Registering new operators\n\nThis is a fundamental need. Operators are fixed python functions\nexposed through a lispy syntax. Applications need a variety of fancy\noperators.\n\n## declaring a new operator\n\nOne just needs to decorate a python with the `func` decorator:\n\n```python\n  from tshistory_formula.registry import func\n\n  @func('identity')\n  def identity(series):\n      return series\n```\n\nThe operator will be known to the outer world by the name given to\n`@func`, not the python function name (which can be arbitrary).\n\nThis is enough to get a working transformation operator.  However\noperators built to construct series rather than just transform\npre-existing series are more complicated.\n\n## custom series operator\n\nWe start with an example, a `shifted` operator that gets a series with shifted\nfrom_value_date/to_value_date boundaries by a constant `delta` amount.\n\nWe would use it like this: `(shifted \"shiftme\" #:days -1)`\n\nAs we can see the standard `series` operator won't work there, that is\napplying a shift operator (`(shift (series \"shiftme\"))`) *after* the\ncall to series is too late. The from/to implicit parameters have\nalready been handled by `series` itself and there is nothing left to\n*shift*.\n\nHence `shifted` must be understood as an alternative to `series` itself.\nHere is a possible implementation:\n\n```python\n  from tshistory_formula.registry import func, finder\n\n  @func('shifted')\n  def shifted(__interpreter__, name, days=0):\n      args = __interpreter__.getargs.copy()\n      fromdate = args.get('from_value_date')\n      todate = args.get('to_value_date')\n      if fromdate:\n          args['from_value_date'] = fromdate + timedelta(days=days)\n      if todate:\n          args['to_value_date'] = todate + timedelta(days=days)\n\n      return __interpreter__.get(name, args)\n\n  @finder('shifted')\n  def find_series(cn, tsh, tree):\n      return {\n          tree[1]: tsh.metadata(cn, tree[1])\n      }\n```\n\nAs we can see, we use a new `finder` protocol. But first let's examine\nhow the `shiftme` operator is implemented.\n\nFirst it takes a special `__interpreter__` parameter, which will\nreceive the formula interpreter object, providing access to an\nimportant internal API of the evaluation process.\n\nIndeed from the interpreter we can read the `getargs` attribute, which\ncontains a dictionary of the actual query mapping. We are specially\ninterested in the `from_value_date` and `to_value_date` items in our\nexample, but all the parameters of `tshistory.get` are available\nthere.\n\nOnce we have shifted the from/to value date parameter we again use the\ninterpreter to make a call to `get` which will in turn perform a call\nto the underlying `tshistory.get` (which, we don't know in advance,\nmay yield a primary series or another formula computed series).\n\nImplementing the operator this way, we actually miss two important\npieces of information:\n\n* the system cannot determine a series is _produced_ by the `shifted`\n  operator like it can with `series`\n\n* and because of this it cannot know the technical metadata of the\n  produced series (e.g. the `tzaware` attribute)\n\nThis is where the `finder` protocol and its decorator function comes\ninto play. For `shifted` we define a finder. It is a function that\ntakes the db connection (`cn`), time series protocol handler (`tsh`)\nand formula syntax tree (`tree`), and must return a mapping from\nseries name to its metadata.\n\nThe tree is an obvious Python data structure representing a use of the\noperator in a formula.\n\nFor instance because of the `shifted` python signature, any use will\nbe like that:\n\n* in lisp `... (shifted \"shift-me\" #:hours +1) ... ` (the dots\n  indicate that it can be part of a larger formula)\n\n* tree in python: `['shifted', \"shift-me\", 'hours', 1]`\n\nThe name is always in position 1 in the list. Hence the implementation\nof the shifted *finder*:\n\n```python\n      return {\n          tree[1]: tsh.metadata(cn, tree[1])\n      }\n```\n\nFor the metadata we delegate the computation to the underlying series metadata.\n\nWe might want to provide an ad-hoc metadata dictionary if we had a\nproxy operator that would forward the series from an external source:\n\n```python\n  @func('proxy')\n  def proxy(\n          __interpreter__,\n          series_uid: str,\n          default_start: date,\n          default_end : date) -> pd.Series:\n      i = __interpreter__\n      args = i.getargs.copy()\n      from_value_date = args.get('from_value_date') or default_start\n      to_value_date = args.get('to_value_date') or default_end\n\n      proxy = ProxyClient()\n      return proxy.get(\n          series_uid,\n          from_value_date,\n          to_value_date,\n      )\n\n  @finder('proxy')\n  def proxy(cn, tsh, tree):\n      return {\n          tree[1]: {\n              'index_type': 'datetime64[ns]',\n              'tzaware': False,\n              'value_type': 'float64'\n          }\n      }\n```\n\nHere, because we have no other means to know (and the proxy provides\nsome useful documentation), we write the metadata ourselves\nexplicitly.\n\nAlso note how accessing the `__interpreter__` again is used to forward\nthe query arguments.\n\n\n## Editor Infos\n\nThe `tshistory_formula` package provides a custom callback for the\n`editor` capabilities of [tshistory_editor][tshistory_editor].\n\nA dedicated protocol is available to inform the editor on the way\nto decompose/display a formula.\n\nExample of such a function:\n\n```python\n from tshistory_formula.registry import editor_info\n\n @editor_info\n def operator_with_series(builder, expr):\n     for subexpr in expr[1:]:\n         with builder.series_scope(subexpr):\n             builder.buildinfo_expr(subexpr)\n\n```\n\nThe exact ways to use the builder will be provided soon.\n\n[tshistory_editor]: https://bitbucket.org/pythonian/tshistory_editor\n\n\n# Series API\n\nA few api calls are added to the `tshistory` base:\n\n* `.register_formula` to define a formula\n\n* `.eval_formula` to evaluate on-the-fly a formula (useful to check\n  that it computes before registering it)\n\n## register_formula\n\nExemple:\n\n```python\n  tsh.register_formula(\n      cn,\n      'my-sweet-formula',\n      '(* 3.14 (series \"going-round\"))',\n      reject_unkown=True,\n      update=True\n  )\n```\n\nFirst comes the db connection object, second the formula name, last\nthe actual expression.\n\nThe `reject_unknown` parameter, which is True by default, makes the\nmethod fail if one constituent of the formula does not exist\n(e.g. \"going-round\" is neither a primary series or a formula).\n\nThe `update` parameter tells wether an existing formula can be\noverwritten (False by default).\n\n# eval_formula\n\nExample:\n\n```python\n >>> tsh.eval_formula(cn, '(* 3.14 (series \"going-round\"))')\n ...\n 2020-01-01    3.14\n 2020-01-02    6.28\n 2020-01-03    9.42\n dtype: float64\n```\n\n# Command line\n\nThe `tsh` command carries formula specific subcommands. The output\nbelow shows only the specific formula subcommands:\n\n```shell\n$ tsh\nUsage: tsh [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  ingest-formulas           ingest a csv file of formulas Must be a...\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/pythonian/tshistory_formula", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "tshistory-formula", "package_url": "https://pypi.org/project/tshistory-formula/", "platform": "", "project_url": "https://pypi.org/project/tshistory-formula/", "project_urls": {"Homepage": "https://bitbucket.org/pythonian/tshistory_formula"}, "release_url": "https://pypi.org/project/tshistory-formula/0.6.0/", "requires_dist": ["decorator", "tshistory", "psyl"], "requires_python": "", "summary": "Computed timeseries plugin for `tshistory`", "version": "0.6.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>TSHISTORY FORMULA</h1>\n<h1>Purpose</h1>\n<p>This <a href=\"https://bitbucket.org/pythonian/tshistory\" rel=\"nofollow\">tshistory</a> component provides a formula language to\nbuild computed series.</p>\n<p>Using <code>csv</code> definition files, one can define formula using a simple\nlisp-like syntax, using a pre-defined function library.</p>\n<p>Formulae are read-only series (you can't <code>update</code> or <code>replace</code>\nvalues).</p>\n<p>They also have an history, which is built, time stamps wise, using the\nunion of all constituent time stamps, and value wise, by applying the\nformula.</p>\n<p>Because of this the <code>staircase</code> operator is available on formulae.\nSome <code>staircase</code> operations can have a very fast implementation if the\nformula obeys commutativity rules.</p>\n<h1>Formula</h1>\n<h2>General Syntax</h2>\n<p>Formulas are expressed in a lisp-like syntax using <code>operators</code>,\npositional (mandatory) parameters and keyword (optional) parameters.</p>\n<p>The general form is:</p>\n<p><code>(&lt;operator&gt; &lt;param1&gt; ... &lt;paramN&gt; #:&lt;keyword1&gt; &lt;value1&gt; ... #:&lt;keywordN&gt; &lt;valueN&gt;)</code></p>\n<p>Here are a couple examples:</p>\n<ul>\n<li><code>(add (series \"wallonie\") (series \"bruxelles\") (series \"flandres\"))</code></li>\n</ul>\n<p>Here we see the two fundamental <code>add</code> and <code>series</code> operators at work.</p>\n<p>This would form a new synthetic series out of three base series (which\ncan be either raw series or formulas themselves).</p>\n<p>Some notes:</p>\n<ul>\n<li>\n<p>operator names can contain dashes or arbitrary caracters</p>\n</li>\n<li>\n<p>literal values can be: <code>3</code> (integer), <code>5.2</code> (float), <code>\"hello\"</code>\n(string) and <code>#t</code> or <code>#f</code> (true ot false)</p>\n</li>\n</ul>\n<h2>Pre-defined operators</h2>\n<h3>*</h3>\n<p>Performs a scalar product on a series.</p>\n<p>Example: <code>(* -1 (series \"positive-things\"))</code></p>\n<h3>+</h3>\n<p>Add a constant quantity to a series.</p>\n<p>Example: <code>(+ 42 (series \"i-feel-undervalued\"))</code></p>\n<h3>/</h3>\n<p>Perform a scalar division between numbers or a series and a scalar.</p>\n<p>Example: <code>(/ (series \"div-me\") (/ 3 2))</code></p>\n<h3>add</h3>\n<p>Linear combination of two or more series. Takes a variable number\nof series as input.</p>\n<p>Example: <code>(add (series \"wallonie\") (series \"bruxelles\") (series \"flandres\"))</code></p>\n<p>To specify the behaviour of the <code>add</code> operation in the face of missing\ndata, the series can be built with the <code>fill</code> keyword. This option is\nonly really applied when several series are combined. By default, if\nan input series has missing values for a given time stamp, the\nresulting series has no value for this timestamp (unless a fill rule\nis provided).</p>\n<h3>clip</h3>\n<p>Set an upper/lower threashold for a series. Takes a series as\npositional parameter and accepts two optional keywords <code>min</code> and <code>max</code>\nwhich must be numbers (integers or floats).</p>\n<p>Example: <code>(clip (series \"must-be-positive\") #:min 0)</code></p>\n<h3>date</h3>\n<p>Produces an utc timestamp from its input string date in iso format.</p>\n<p>The <code>tz</code> keyword allows to specify an alternate time zone.\nThe <code>naive</code> keyword forces production of a naive timestamp.\nBoth <code>tz</code> and <code>naive</code> keywords are mutually exlcusive.</p>\n<h3>div</h3>\n<p>Element wise division of two series.</p>\n<p>Example: <code>(div (series \"$-to-\u20ac\") (series \"\u20ac-to-\u00a3\"))</code></p>\n<h3>min</h3>\n<p>Computes the row-wise minimum of its input series.</p>\n<p>Example: <code>(min (series \"station0\") (series \"station1\") (series \"station2\"))</code></p>\n<h3>max</h3>\n<p>Computes the row-wise maximum of its input series.</p>\n<p>Example: <code>(max (series \"station0\") (series \"station1\") (series \"station2\"))</code></p>\n<h3>mul</h3>\n<p>Element wise multiplication of series. Takes a variable number of series\nas input.</p>\n<p>Example: <code>(mul (series \"banana-spot-price ($)\") (series \"$-to-\u20ac\" #:fill 'ffill'))</code></p>\n<p>This might convert a series priced in dollars to a series priced in\neuros, using a currency exchange rate series with a forward-fill\noption.</p>\n<h3>naive</h3>\n<p>Allow demoting a series from a tz-aware index (strongly recommended)\nto a tz-naive index (unfortunately sometimes unavoidable for interop\nwith other tz-naive series).</p>\n<p>One must provide a country code and a target timezone.</p>\n<p>Example: <code>(naive (series \"tz-aware-series-from-poland\") \"PL\" \"Europe/Warsaw\")</code></p>\n<h3>priority</h3>\n<p>The priority operator combines its input series as layers. For each\ntimestamp in the union of all series time stamps, the value comes from\nthe first series that provides a value.</p>\n<p>Example: <code>(priority (series \"realized\") (series \"nominated\") (series \"forecasted\"))</code></p>\n<p>Here <code>realized</code> values show up first, and any missing values come from\n<code>nominated</code> first and then only from <code>forecasted</code>.</p>\n<h3>resample</h3>\n<p>Resamples its input series using <code>freq</code> and the aggregation method\n<code>method</code> (as described in the pandas documentation).</p>\n<p>Example: <code>(resample (series \"hourly\") \"D\")</code></p>\n<h3>row-mean</h3>\n<p>This operator computes the row-wise mean of its input series using the\nseries <code>weight</code> option if present. The missing points are handled as\nif the whole series were absent.</p>\n<p>Example: <code>(row-mean (series \"station0\") (series \"station1\" #:weight 2) (series \"station2\"))</code></p>\n<p>Weights are provided as a keyword to <code>series</code>. No weight is\ninterpreted as 1.</p>\n<h3>series</h3>\n<p>The <code>series</code> operator accepts several keywords:</p>\n<ul>\n<li>\n<p><code>fill</code> to specify a filling policy to avoid <code>nans</code> when the series\nwill be <code>add</code>ed with others; accepted values are <code>\"ffill\"</code>\n(forward-fill), <code>\"bfill\"</code> (backward-fill) or any floating value.</p>\n</li>\n<li>\n<p><code>prune</code> to indicate how many points must be truncated from the tail\nend (useful for priorities).</p>\n</li>\n</ul>\n<p>For instance in <code>(add (series \"a\" #:fill 0) (series \"b\")</code> will make\nsure that series <code>a</code>, if shorter than series <code>b</code> will get zeroes\ninstead of nans where <code>b</code> provides values.</p>\n<p>In <code>(series \"realized\" #:prune 3)</code> we would drop the last three points.</p>\n<h3>slice</h3>\n<p>This allows cutting a series at date points. It takes one positional\nparameter (the series) and two optional keywords <code>fromdate</code> and\n<code>todate</code> which must be strings in the <a href=\"https://en.wikipedia.org/wiki/ISO_8601\" rel=\"nofollow\">iso8601</a> format.</p>\n<p>Example: <code>(slice (series \"cut-me\") #:fromdate \"2018-01-01\")</code></p>\n<h3>std</h3>\n<p>Computes the standard deviation over its input series.</p>\n<p>Example: <code>(std (series \"station0\") (series \"station1\") (series \"station2\"))</code></p>\n<h3>timedelta</h3>\n<p>Takes a timestamp and a number of years, months, weekds, days,\nhours, minutes (int) and computes a new date according to the asked\ndelta elements.</p>\n<p>Example: <code>(timedelta (date \"2020-1-1\") #:weeks 1 #:hours 2)</code></p>\n<h3>today</h3>\n<p>Produces a timezone-aware timestamp as of today</p>\n<p>The <code>tz</code> keyword allows to specify an alternate time zone.\nThe <code>naive</code> keyword forces production of a naive timestamp.\nBoth <code>tz</code> and <code>naive</code> keywords are mutually exlcusive.</p>\n<p>Example: <code>(today)</code></p>\n<h1>Registering new operators</h1>\n<p>This is a fundamental need. Operators are fixed python functions\nexposed through a lispy syntax. Applications need a variety of fancy\noperators.</p>\n<h2>declaring a new operator</h2>\n<p>One just needs to decorate a python with the <code>func</code> decorator:</p>\n<pre>  <span class=\"kn\">from</span> <span class=\"nn\">tshistory_formula.registry</span> <span class=\"kn\">import</span> <span class=\"n\">func</span>\n\n  <span class=\"nd\">@func</span><span class=\"p\">(</span><span class=\"s1\">'identity'</span><span class=\"p\">)</span>\n  <span class=\"k\">def</span> <span class=\"nf\">identity</span><span class=\"p\">(</span><span class=\"n\">series</span><span class=\"p\">):</span>\n      <span class=\"k\">return</span> <span class=\"n\">series</span>\n</pre>\n<p>The operator will be known to the outer world by the name given to\n<code>@func</code>, not the python function name (which can be arbitrary).</p>\n<p>This is enough to get a working transformation operator.  However\noperators built to construct series rather than just transform\npre-existing series are more complicated.</p>\n<h2>custom series operator</h2>\n<p>We start with an example, a <code>shifted</code> operator that gets a series with shifted\nfrom_value_date/to_value_date boundaries by a constant <code>delta</code> amount.</p>\n<p>We would use it like this: <code>(shifted \"shiftme\" #:days -1)</code></p>\n<p>As we can see the standard <code>series</code> operator won't work there, that is\napplying a shift operator (<code>(shift (series \"shiftme\"))</code>) <em>after</em> the\ncall to series is too late. The from/to implicit parameters have\nalready been handled by <code>series</code> itself and there is nothing left to\n<em>shift</em>.</p>\n<p>Hence <code>shifted</code> must be understood as an alternative to <code>series</code> itself.\nHere is a possible implementation:</p>\n<pre>  <span class=\"kn\">from</span> <span class=\"nn\">tshistory_formula.registry</span> <span class=\"kn\">import</span> <span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">finder</span>\n\n  <span class=\"nd\">@func</span><span class=\"p\">(</span><span class=\"s1\">'shifted'</span><span class=\"p\">)</span>\n  <span class=\"k\">def</span> <span class=\"nf\">shifted</span><span class=\"p\">(</span><span class=\"n\">__interpreter__</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">days</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">):</span>\n      <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"n\">__interpreter__</span><span class=\"o\">.</span><span class=\"n\">getargs</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n      <span class=\"n\">fromdate</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'from_value_date'</span><span class=\"p\">)</span>\n      <span class=\"n\">todate</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'to_value_date'</span><span class=\"p\">)</span>\n      <span class=\"k\">if</span> <span class=\"n\">fromdate</span><span class=\"p\">:</span>\n          <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"s1\">'from_value_date'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">fromdate</span> <span class=\"o\">+</span> <span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">days</span><span class=\"o\">=</span><span class=\"n\">days</span><span class=\"p\">)</span>\n      <span class=\"k\">if</span> <span class=\"n\">todate</span><span class=\"p\">:</span>\n          <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"s1\">'to_value_date'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">todate</span> <span class=\"o\">+</span> <span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">days</span><span class=\"o\">=</span><span class=\"n\">days</span><span class=\"p\">)</span>\n\n      <span class=\"k\">return</span> <span class=\"n\">__interpreter__</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n\n  <span class=\"nd\">@finder</span><span class=\"p\">(</span><span class=\"s1\">'shifted'</span><span class=\"p\">)</span>\n  <span class=\"k\">def</span> <span class=\"nf\">find_series</span><span class=\"p\">(</span><span class=\"n\">cn</span><span class=\"p\">,</span> <span class=\"n\">tsh</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">):</span>\n      <span class=\"k\">return</span> <span class=\"p\">{</span>\n          <span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span> <span class=\"n\">tsh</span><span class=\"o\">.</span><span class=\"n\">metadata</span><span class=\"p\">(</span><span class=\"n\">cn</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n      <span class=\"p\">}</span>\n</pre>\n<p>As we can see, we use a new <code>finder</code> protocol. But first let's examine\nhow the <code>shiftme</code> operator is implemented.</p>\n<p>First it takes a special <code>__interpreter__</code> parameter, which will\nreceive the formula interpreter object, providing access to an\nimportant internal API of the evaluation process.</p>\n<p>Indeed from the interpreter we can read the <code>getargs</code> attribute, which\ncontains a dictionary of the actual query mapping. We are specially\ninterested in the <code>from_value_date</code> and <code>to_value_date</code> items in our\nexample, but all the parameters of <code>tshistory.get</code> are available\nthere.</p>\n<p>Once we have shifted the from/to value date parameter we again use the\ninterpreter to make a call to <code>get</code> which will in turn perform a call\nto the underlying <code>tshistory.get</code> (which, we don't know in advance,\nmay yield a primary series or another formula computed series).</p>\n<p>Implementing the operator this way, we actually miss two important\npieces of information:</p>\n<ul>\n<li>\n<p>the system cannot determine a series is <em>produced</em> by the <code>shifted</code>\noperator like it can with <code>series</code></p>\n</li>\n<li>\n<p>and because of this it cannot know the technical metadata of the\nproduced series (e.g. the <code>tzaware</code> attribute)</p>\n</li>\n</ul>\n<p>This is where the <code>finder</code> protocol and its decorator function comes\ninto play. For <code>shifted</code> we define a finder. It is a function that\ntakes the db connection (<code>cn</code>), time series protocol handler (<code>tsh</code>)\nand formula syntax tree (<code>tree</code>), and must return a mapping from\nseries name to its metadata.</p>\n<p>The tree is an obvious Python data structure representing a use of the\noperator in a formula.</p>\n<p>For instance because of the <code>shifted</code> python signature, any use will\nbe like that:</p>\n<ul>\n<li>\n<p>in lisp <code>... (shifted \"shift-me\" #:hours +1) ...</code> (the dots\nindicate that it can be part of a larger formula)</p>\n</li>\n<li>\n<p>tree in python: <code>['shifted', \"shift-me\", 'hours', 1]</code></p>\n</li>\n</ul>\n<p>The name is always in position 1 in the list. Hence the implementation\nof the shifted <em>finder</em>:</p>\n<pre>      <span class=\"k\">return</span> <span class=\"p\">{</span>\n          <span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span> <span class=\"n\">tsh</span><span class=\"o\">.</span><span class=\"n\">metadata</span><span class=\"p\">(</span><span class=\"n\">cn</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n      <span class=\"p\">}</span>\n</pre>\n<p>For the metadata we delegate the computation to the underlying series metadata.</p>\n<p>We might want to provide an ad-hoc metadata dictionary if we had a\nproxy operator that would forward the series from an external source:</p>\n<pre>  <span class=\"nd\">@func</span><span class=\"p\">(</span><span class=\"s1\">'proxy'</span><span class=\"p\">)</span>\n  <span class=\"k\">def</span> <span class=\"nf\">proxy</span><span class=\"p\">(</span>\n          <span class=\"n\">__interpreter__</span><span class=\"p\">,</span>\n          <span class=\"n\">series_uid</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span>\n          <span class=\"n\">default_start</span><span class=\"p\">:</span> <span class=\"n\">date</span><span class=\"p\">,</span>\n          <span class=\"n\">default_end</span> <span class=\"p\">:</span> <span class=\"n\">date</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">:</span>\n      <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">__interpreter__</span>\n      <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">.</span><span class=\"n\">getargs</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n      <span class=\"n\">from_value_date</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'from_value_date'</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"n\">default_start</span>\n      <span class=\"n\">to_value_date</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'to_value_date'</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"n\">default_end</span>\n\n      <span class=\"n\">proxy</span> <span class=\"o\">=</span> <span class=\"n\">ProxyClient</span><span class=\"p\">()</span>\n      <span class=\"k\">return</span> <span class=\"n\">proxy</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span>\n          <span class=\"n\">series_uid</span><span class=\"p\">,</span>\n          <span class=\"n\">from_value_date</span><span class=\"p\">,</span>\n          <span class=\"n\">to_value_date</span><span class=\"p\">,</span>\n      <span class=\"p\">)</span>\n\n  <span class=\"nd\">@finder</span><span class=\"p\">(</span><span class=\"s1\">'proxy'</span><span class=\"p\">)</span>\n  <span class=\"k\">def</span> <span class=\"nf\">proxy</span><span class=\"p\">(</span><span class=\"n\">cn</span><span class=\"p\">,</span> <span class=\"n\">tsh</span><span class=\"p\">,</span> <span class=\"n\">tree</span><span class=\"p\">):</span>\n      <span class=\"k\">return</span> <span class=\"p\">{</span>\n          <span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span> <span class=\"p\">{</span>\n              <span class=\"s1\">'index_type'</span><span class=\"p\">:</span> <span class=\"s1\">'datetime64[ns]'</span><span class=\"p\">,</span>\n              <span class=\"s1\">'tzaware'</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n              <span class=\"s1\">'value_type'</span><span class=\"p\">:</span> <span class=\"s1\">'float64'</span>\n          <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n</pre>\n<p>Here, because we have no other means to know (and the proxy provides\nsome useful documentation), we write the metadata ourselves\nexplicitly.</p>\n<p>Also note how accessing the <code>__interpreter__</code> again is used to forward\nthe query arguments.</p>\n<h2>Editor Infos</h2>\n<p>The <code>tshistory_formula</code> package provides a custom callback for the\n<code>editor</code> capabilities of <a href=\"https://bitbucket.org/pythonian/tshistory_editor\" rel=\"nofollow\">tshistory_editor</a>.</p>\n<p>A dedicated protocol is available to inform the editor on the way\nto decompose/display a formula.</p>\n<p>Example of such a function:</p>\n<pre> <span class=\"kn\">from</span> <span class=\"nn\">tshistory_formula.registry</span> <span class=\"kn\">import</span> <span class=\"n\">editor_info</span>\n\n <span class=\"nd\">@editor_info</span>\n <span class=\"k\">def</span> <span class=\"nf\">operator_with_series</span><span class=\"p\">(</span><span class=\"n\">builder</span><span class=\"p\">,</span> <span class=\"n\">expr</span><span class=\"p\">):</span>\n     <span class=\"k\">for</span> <span class=\"n\">subexpr</span> <span class=\"ow\">in</span> <span class=\"n\">expr</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]:</span>\n         <span class=\"k\">with</span> <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"n\">series_scope</span><span class=\"p\">(</span><span class=\"n\">subexpr</span><span class=\"p\">):</span>\n             <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"n\">buildinfo_expr</span><span class=\"p\">(</span><span class=\"n\">subexpr</span><span class=\"p\">)</span>\n</pre>\n<p>The exact ways to use the builder will be provided soon.</p>\n<h1>Series API</h1>\n<p>A few api calls are added to the <code>tshistory</code> base:</p>\n<ul>\n<li>\n<p><code>.register_formula</code> to define a formula</p>\n</li>\n<li>\n<p><code>.eval_formula</code> to evaluate on-the-fly a formula (useful to check\nthat it computes before registering it)</p>\n</li>\n</ul>\n<h2>register_formula</h2>\n<p>Exemple:</p>\n<pre>  <span class=\"n\">tsh</span><span class=\"o\">.</span><span class=\"n\">register_formula</span><span class=\"p\">(</span>\n      <span class=\"n\">cn</span><span class=\"p\">,</span>\n      <span class=\"s1\">'my-sweet-formula'</span><span class=\"p\">,</span>\n      <span class=\"s1\">'(* 3.14 (series \"going-round\"))'</span><span class=\"p\">,</span>\n      <span class=\"n\">reject_unkown</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n      <span class=\"n\">update</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n  <span class=\"p\">)</span>\n</pre>\n<p>First comes the db connection object, second the formula name, last\nthe actual expression.</p>\n<p>The <code>reject_unknown</code> parameter, which is True by default, makes the\nmethod fail if one constituent of the formula does not exist\n(e.g. \"going-round\" is neither a primary series or a formula).</p>\n<p>The <code>update</code> parameter tells wether an existing formula can be\noverwritten (False by default).</p>\n<h1>eval_formula</h1>\n<p>Example:</p>\n<pre> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">tsh</span><span class=\"o\">.</span><span class=\"n\">eval_formula</span><span class=\"p\">(</span><span class=\"n\">cn</span><span class=\"p\">,</span> <span class=\"s1\">'(* 3.14 (series \"going-round\"))'</span><span class=\"p\">)</span>\n <span class=\"o\">...</span>\n <span class=\"mi\">2020</span><span class=\"o\">-</span><span class=\"mi\">01</span><span class=\"o\">-</span><span class=\"mi\">01</span>    <span class=\"mf\">3.14</span>\n <span class=\"mi\">2020</span><span class=\"o\">-</span><span class=\"mi\">01</span><span class=\"o\">-</span><span class=\"mi\">02</span>    <span class=\"mf\">6.28</span>\n <span class=\"mi\">2020</span><span class=\"o\">-</span><span class=\"mi\">01</span><span class=\"o\">-</span><span class=\"mi\">03</span>    <span class=\"mf\">9.42</span>\n <span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">float64</span>\n</pre>\n<h1>Command line</h1>\n<p>The <code>tsh</code> command carries formula specific subcommands. The output\nbelow shows only the specific formula subcommands:</p>\n<pre>$ tsh\nUsage: tsh <span class=\"o\">[</span>OPTIONS<span class=\"o\">]</span> COMMAND <span class=\"o\">[</span>ARGS<span class=\"o\">]</span>...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  ingest-formulas           ingest a csv file of formulas Must be a...\n</pre>\n\n          </div>"}, "last_serial": 6568875, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "ceb778816d56b40d446e21d68bc2229c", "sha256": "ebb6da42627a3b90dcd1ea5c4ce68287a911db6d846c19f875dcf397008d19f0"}, "downloads": -1, "filename": "tshistory_formula-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "ceb778816d56b40d446e21d68bc2229c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12055, "upload_time": "2019-07-16T14:55:41", "upload_time_iso_8601": "2019-07-16T14:55:41.514194Z", "url": "https://files.pythonhosted.org/packages/6b/d4/e748b3e27c3828e03251e0608d2b5cc41872eb6a3b865c4c2add552460db/tshistory_formula-0.1.0-py3-none-any.whl", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "53451a2c0a62f01bbed8e03857ddc9e7", "sha256": "ce3e3c90dc559d0667b90fee991385a6315c2f9260ae0539c906ceaf6fd744ef"}, "downloads": -1, "filename": "tshistory_formula-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "53451a2c0a62f01bbed8e03857ddc9e7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17124, "upload_time": "2019-10-28T09:47:02", "upload_time_iso_8601": "2019-10-28T09:47:02.781750Z", "url": "https://files.pythonhosted.org/packages/01/81/26167b2e80f70897850a7a13570459a57a538d49555a5dbe637e353cf6aa/tshistory_formula-0.4.0-py3-none-any.whl", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "5ff2414360e23a1c555d091bab12d834", "sha256": "999d250429e820b2419d0b55033f2b95db4dbfb54a9f2f7173a6e83028ab6ba5"}, "downloads": -1, "filename": "tshistory_formula-0.5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "5ff2414360e23a1c555d091bab12d834", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 23423, "upload_time": "2019-11-20T15:05:47", "upload_time_iso_8601": "2019-11-20T15:05:47.950931Z", "url": "https://files.pythonhosted.org/packages/a8/84/83941c74b85233edbf0befd96e37001b79a5300bcc6f3b08e7f9e43981fe/tshistory_formula-0.5.0-py3-none-any.whl", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "85a7b441773cfc26d9aeed29658c8a43", "sha256": "c1dddfe8ae5172e40673299602626ac4963646897c1e267046be78460d8b7f98"}, "downloads": -1, "filename": "tshistory_formula-0.6.0-py3-none-any.whl", "has_sig": false, "md5_digest": "85a7b441773cfc26d9aeed29658c8a43", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24155, "upload_time": "2020-02-04T14:15:21", "upload_time_iso_8601": "2020-02-04T14:15:21.494782Z", "url": "https://files.pythonhosted.org/packages/28/2b/043ee5e9f0bc1df022af99b87d8341d227513d9ce862ef523bce4a8453b7/tshistory_formula-0.6.0-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "85a7b441773cfc26d9aeed29658c8a43", "sha256": "c1dddfe8ae5172e40673299602626ac4963646897c1e267046be78460d8b7f98"}, "downloads": -1, "filename": "tshistory_formula-0.6.0-py3-none-any.whl", "has_sig": false, "md5_digest": "85a7b441773cfc26d9aeed29658c8a43", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24155, "upload_time": "2020-02-04T14:15:21", "upload_time_iso_8601": "2020-02-04T14:15:21.494782Z", "url": "https://files.pythonhosted.org/packages/28/2b/043ee5e9f0bc1df022af99b87d8341d227513d9ce862ef523bce4a8453b7/tshistory_formula-0.6.0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:45:19 2020"}