{"info": {"author": "Peter Fein", "author_email": "pfein@pobox.com", "bugtrack_url": null, "classifiers": [], "description": "Overview\n========\nFactory is an object-oriented approach to partial function application, also known as currying. The Factory module is a more powerful implementation of this pattern. Some improvements include:\n\n- safer, as invalid arguments are detected immediately, instead of at call time\n- intelligent support for classes, instance methods & all other callables\n- bound arguments can be inspected and modified as attributes\n- several convenient methods for (re)binding arguments\n- no \"Russian dolls\" of nested lambdas\n\nUsing Factories can:\n\n- simplify writing callbacks\n- reduce bugs in concurrent applications\n- provide easy lazy evaluation\n\nInstallation\n============\nThe Factory module is available from the `Cheeseshop <http://pypi.python.org/pypi/Factory/>`_.  The source code is available from the `Google Code project page <http://code.google.com/p/python-factory/>`_.\n\nThe Factory module can be installed like any other pure Python module.  Setuptools is supported but not required.  You may also include the ``Factory.py`` file directly in your project's source tree, but you must retain the copyright notice and version and attribution information.\n\nTo run tests for the module, execute the following commands in the ``Factory/`` directory:\n\n- ``python doctest_Factory.py``\n- ``nosetests test_Factory.py``\n\nAbout Currying\n==============\nCurrying creates a new function from an existing one by binding some of the original's arguments:\n\n>>> def adder(x, y):\n...     return x + y\n>>> add_lambda = lambda y: adder(1, y)\n>>> add_lambda(10)\n11\n\nAs of Python 2.5, this pattern is built in with the `partial <http://docs.python.org/whatsnew/2.5.html#pep-309-partial-function-application>`_ function.\n\n>>> add_partial = functools.partial(adder, 1)\n>>> add_partial(y=10)\n11\n\nFactories\n=========\nFactories are better implementation of the currying pattern:\n\n>>> from Factory import *\n>>> add_factory = Factory(adder, x=1)\n>>> add_factory #doctest: +ELLIPSIS\n<Factory(<function adder at ...>) at ...>\n>>> add_factory(y=10)\n11\n\nUnlike lambdas and partial, factories can be inspected and modified:\n\n>>> add_factory.x\n1\n>>> add_factory.x = 2\n>>> add_factory(y=10)\n12\n\nThe arguments that would be passed to the function can be examined, which\nis sometimes helpful in debugging:\n\n>>> import pprint\n>>> args, kwargs = add_factory.generateArgs(y=10)\n>>> pprint.pprint(kwargs)\n{'x': 2, 'y': 10}\n>>> args\n[]\n\nUsage\n=====\nIn the following examples, we mix in **FactoryMixin** to provide a\n``factory`` classmethod on the base class.\n\n>>> class Foo(FactoryMixin):\n...     def __init__(self, foo):\n...         self.foo = foo\n...\n>>> foo_factory = Foo.factory()\n>>> foo_factory.foo = 66\n\nThis is equivalent to:\n\n>>> Factory(Foo) #doctest:+ELLIPSIS\n<Factory(<class 'Foo'>) at ...>\n\nUsing the mixin isn't strictly necessary, but looks nice and is easier to spell.\n\nFactories have a **bind** method that can be used to set several attributes\nat once and returns the factory. It's useful for binding arguments\nwithout assigning the factory to a local variable.\n\n>>> def doStuff(foo_factory):\n...     return foo_factory.foo\n>>> doStuff(foo_factory.bind(foo=11))\n11\n>>> foo_factory2 = foo_factory.bind(foo=42)\n>>> foo_factory2 is foo_factory\nTrue\n>>> foo_factory.foo\n42\n\nYou can also bind attributes when constructing the factory:\n\n>>> foo_factory = Factory(Foo, foo=11)\n>>> foo_factory.foo\n11\n\nFactories ensure that attributes match up with arguments; this makes\nfinding errors easier (instead of raising a ``unexpected keyword argument``\nlater):\n\n>>> foo_factory.bar = 42  #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'No such argument bar'\n\nWhen calling the factory, arguments override attributes:\n\n>>> foo = foo_factory(foo=1111)\n>>> foo.foo\n1111\n\nEach call returns a new instance:\n\n>>> foo2 = foo_factory()\n>>> foo2 is foo\nFalse\n\nThe set of valid attributes is the union of all ``__init__`` arguments in the\ninheritance chain:\n\n>>> class Bar(Foo):\n...     def __init__(self, bar, **kwargs):\n...         super(Bar, self).__init__(**kwargs)\n...         self.bar = bar\n...\n>>> bar_factory = Bar.factory()\n>>> bar_factory.foo = 11\n>>> bar_factory.bar = 42\n>>> bar_factory.quux = 666  #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'No such argument quux'\n>>> bar = bar_factory()\n>>> bar.foo\n11\n>>> bar.bar\n42\n\nBe sure to pass Factory a callable object (a class, not an an instance):\n\n>>> Factory(bar)  #doctest:+ELLIPSIS, +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: must provide known callable type, not <Factory.Bar object at ...>\n\nCallable objects are fine, of course:\n\n>>> class CallMe(object):\n...     def __init__(self, x):\n...         self.x = x\n...     def __call__(self, y):\n...         return self.x + y\n>>> Factory(CallMe(1))(1)\n2\n\nAn existing factory can be passed as the ``callee`` of a new factory.\n\n>>> bar_factory = Bar.factory(bar=2)\n>>> bar_factory2 = Factory(bar_factory, foo = 1)\n>>> bar_factory is not bar_factory2\nTrue\n>>> bar_factory2.bar\n2\n>>> bar_factory2.bar = 4\n>>> bar_factory.bar\n2\n\nUnlike using lambdas, this does not create nested \"Russian dolls\":\n\n>>> bar_factory2.getCallable()\n<class 'Bar'>\n\nDecorators\n==========\n**returnFactory** is a decorator which *replaces* a function with its Factory-producing equivalent:\n\n>>> @returnFactory\n... def mult(x, y):\n...     return x * y\n>>> fac = mult(x=10, y=5)\n>>> isinstance(fac, Factory)\nTrue\n>>> fac()\n50\n\n**factoryAttribute** adds a ``factory`` attribute to the decorated function:\n\n>>> @factoryAttribute\n... def adder(x, y):\n...     return x + y\n>>> fac = adder.factory(x=10)\n>>> isinstance(fac, Factory)\nTrue\n>>> fac2 = adder.factory()\n>>> fac is not fac2\nTrue\n>>> fac(y=42)\n52\n\n**factoryDescriptor** produces instance methods with a ``factory`` attribute. Inside classes, use this descriptor instead of factoryAttribute. This class may be used as a decorator:\n\n>>> class Quux(object):\n...     @factoryDescriptor\n...     def doStuff(self, whatnot):\n...          pass\n>>> quux = Quux()\n>>> fac = quux.doStuff.factory(whatnot=42)\n>>> isinstance(fac, Factory)\nTrue\n>>> fac.whatnot\n42\n\nObjectTemplates\n================\nObjectTemplates are a template for creating objects. They work well with Factories.\n\nA **Bunch** is simply a bunch of attributes. Keyword arguments to a Bunch are turned into attributes:\n\n>>> b = Bunch(pants=42, shirt=15)\n>>> b.pants\n42\n>>> b.shirt\n15\n\nCalling a bunch returns a new copy:\n\n>>> c = b()\n>>> c.__dict__ == b.__dict__\nTrue\n>>> c is b\nFalse\n\nWhen called, an **ObjectTemplate** instance produces a new instance\nof ``bunchClass``. Attributes on the template are passed as kwargs\nto the bunch.  However, if an attribute is callable, it is called\nand the return value is used instead:\n\n>>> counter = itertools.count(1).next # an incrementing counter\n>>> def color():\n...     return \"blue\"\n>>> template = ObjectTemplate(size=42,\n...                           color=color,\n...                           count=counter,\n...                           bunchClass=Bunch)\n>>> bunch = template()\n>>> isinstance(bunch, Bunch)\nTrue\n>>> bunch.size\n42\n>>> bunch.color\n'blue'\n>>> bunch.count\n1\n\nEach call to the template produces a new bunch.  Any functions will\nbe called again:\n\n>>> bunch2 = template()\n>>> bunch2.count\n2\n\nIf you want to pass a callable object to the bunch, wrap it in a lambda:\n\n>>> template = ObjectTemplate()\n>>> template.return_val = color\n>>> template.a_function = lambda: color\n>>> bunch = template()\n>>> bunch.return_val\n'blue'\n>>> bunch.a_function #doctest:+ELLIPSIS\n<function color at ...>\n\nBugs\n====\nBugs, feature requests and praise may be sent directly to `the author <mailto:pfein@pobox.com>`_.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://code.google.com/p/python-factory/", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "Factory", "package_url": "https://pypi.org/project/Factory/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/Factory/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://code.google.com/p/python-factory/"}, "release_url": "https://pypi.org/project/Factory/1.2/", "requires_dist": null, "requires_python": null, "summary": "Object Oriented Currying", "version": "1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"overview\">\n<h2>Overview</h2>\n<p>Factory is an object-oriented approach to partial function application, also known as currying. The Factory module is a more powerful implementation of this pattern. Some improvements include:</p>\n<ul>\n<li>safer, as invalid arguments are detected immediately, instead of at call time</li>\n<li>intelligent support for classes, instance methods &amp; all other callables</li>\n<li>bound arguments can be inspected and modified as attributes</li>\n<li>several convenient methods for (re)binding arguments</li>\n<li>no \u201cRussian dolls\u201d of nested lambdas</li>\n</ul>\n<p>Using Factories can:</p>\n<ul>\n<li>simplify writing callbacks</li>\n<li>reduce bugs in concurrent applications</li>\n<li>provide easy lazy evaluation</li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>The Factory module is available from the <a href=\"http://pypi.python.org/pypi/Factory/\" rel=\"nofollow\">Cheeseshop</a>.  The source code is available from the <a href=\"http://code.google.com/p/python-factory/\" rel=\"nofollow\">Google Code project page</a>.</p>\n<p>The Factory module can be installed like any other pure Python module.  Setuptools is supported but not required.  You may also include the <tt>Factory.py</tt> file directly in your project\u2019s source tree, but you must retain the copyright notice and version and attribution information.</p>\n<p>To run tests for the module, execute the following commands in the <tt>Factory/</tt> directory:</p>\n<ul>\n<li><tt>python doctest_Factory.py</tt></li>\n<li><tt>nosetests test_Factory.py</tt></li>\n</ul>\n</div>\n<div id=\"about-currying\">\n<h2>About Currying</h2>\n<p>Currying creates a new function from an existing one by binding some of the original\u2019s arguments:</p>\n<pre>&gt;&gt;&gt; def adder(x, y):\n...     return x + y\n&gt;&gt;&gt; add_lambda = lambda y: adder(1, y)\n&gt;&gt;&gt; add_lambda(10)\n11\n</pre>\n<p>As of Python 2.5, this pattern is built in with the <a href=\"http://docs.python.org/whatsnew/2.5.html#pep-309-partial-function-application\" rel=\"nofollow\">partial</a> function.</p>\n<pre>&gt;&gt;&gt; add_partial = functools.partial(adder, 1)\n&gt;&gt;&gt; add_partial(y=10)\n11\n</pre>\n</div>\n<div id=\"factories\">\n<h2>Factories</h2>\n<p>Factories are better implementation of the currying pattern:</p>\n<pre>&gt;&gt;&gt; from Factory import *\n&gt;&gt;&gt; add_factory = Factory(adder, x=1)\n&gt;&gt;&gt; add_factory #doctest: +ELLIPSIS\n&lt;Factory(&lt;function adder at ...&gt;) at ...&gt;\n&gt;&gt;&gt; add_factory(y=10)\n11\n</pre>\n<p>Unlike lambdas and partial, factories can be inspected and modified:</p>\n<pre>&gt;&gt;&gt; add_factory.x\n1\n&gt;&gt;&gt; add_factory.x = 2\n&gt;&gt;&gt; add_factory(y=10)\n12\n</pre>\n<p>The arguments that would be passed to the function can be examined, which\nis sometimes helpful in debugging:</p>\n<pre>&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; args, kwargs = add_factory.generateArgs(y=10)\n&gt;&gt;&gt; pprint.pprint(kwargs)\n{'x': 2, 'y': 10}\n&gt;&gt;&gt; args\n[]\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>In the following examples, we mix in <strong>FactoryMixin</strong> to provide a\n<tt>factory</tt> classmethod on the base class.</p>\n<pre>&gt;&gt;&gt; class Foo(FactoryMixin):\n...     def __init__(self, foo):\n...         self.foo = foo\n...\n&gt;&gt;&gt; foo_factory = Foo.factory()\n&gt;&gt;&gt; foo_factory.foo = 66\n</pre>\n<p>This is equivalent to:</p>\n<pre>&gt;&gt;&gt; Factory(Foo) #doctest:+ELLIPSIS\n&lt;Factory(&lt;class 'Foo'&gt;) at ...&gt;\n</pre>\n<p>Using the mixin isn\u2019t strictly necessary, but looks nice and is easier to spell.</p>\n<p>Factories have a <strong>bind</strong> method that can be used to set several attributes\nat once and returns the factory. It\u2019s useful for binding arguments\nwithout assigning the factory to a local variable.</p>\n<pre>&gt;&gt;&gt; def doStuff(foo_factory):\n...     return foo_factory.foo\n&gt;&gt;&gt; doStuff(foo_factory.bind(foo=11))\n11\n&gt;&gt;&gt; foo_factory2 = foo_factory.bind(foo=42)\n&gt;&gt;&gt; foo_factory2 is foo_factory\nTrue\n&gt;&gt;&gt; foo_factory.foo\n42\n</pre>\n<p>You can also bind attributes when constructing the factory:</p>\n<pre>&gt;&gt;&gt; foo_factory = Factory(Foo, foo=11)\n&gt;&gt;&gt; foo_factory.foo\n11\n</pre>\n<p>Factories ensure that attributes match up with arguments; this makes\nfinding errors easier (instead of raising a <tt>unexpected keyword argument</tt>\nlater):</p>\n<pre>&gt;&gt;&gt; foo_factory.bar = 42  #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'No such argument bar'\n</pre>\n<p>When calling the factory, arguments override attributes:</p>\n<pre>&gt;&gt;&gt; foo = foo_factory(foo=1111)\n&gt;&gt;&gt; foo.foo\n1111\n</pre>\n<p>Each call returns a new instance:</p>\n<pre>&gt;&gt;&gt; foo2 = foo_factory()\n&gt;&gt;&gt; foo2 is foo\nFalse\n</pre>\n<p>The set of valid attributes is the union of all <tt>__init__</tt> arguments in the\ninheritance chain:</p>\n<pre>&gt;&gt;&gt; class Bar(Foo):\n...     def __init__(self, bar, **kwargs):\n...         super(Bar, self).__init__(**kwargs)\n...         self.bar = bar\n...\n&gt;&gt;&gt; bar_factory = Bar.factory()\n&gt;&gt;&gt; bar_factory.foo = 11\n&gt;&gt;&gt; bar_factory.bar = 42\n&gt;&gt;&gt; bar_factory.quux = 666  #doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'No such argument quux'\n&gt;&gt;&gt; bar = bar_factory()\n&gt;&gt;&gt; bar.foo\n11\n&gt;&gt;&gt; bar.bar\n42\n</pre>\n<p>Be sure to pass Factory a callable object (a class, not an an instance):</p>\n<pre>&gt;&gt;&gt; Factory(bar)  #doctest:+ELLIPSIS, +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: must provide known callable type, not &lt;Factory.Bar object at ...&gt;\n</pre>\n<p>Callable objects are fine, of course:</p>\n<pre>&gt;&gt;&gt; class CallMe(object):\n...     def __init__(self, x):\n...         self.x = x\n...     def __call__(self, y):\n...         return self.x + y\n&gt;&gt;&gt; Factory(CallMe(1))(1)\n2\n</pre>\n<p>An existing factory can be passed as the <tt>callee</tt> of a new factory.</p>\n<pre>&gt;&gt;&gt; bar_factory = Bar.factory(bar=2)\n&gt;&gt;&gt; bar_factory2 = Factory(bar_factory, foo = 1)\n&gt;&gt;&gt; bar_factory is not bar_factory2\nTrue\n&gt;&gt;&gt; bar_factory2.bar\n2\n&gt;&gt;&gt; bar_factory2.bar = 4\n&gt;&gt;&gt; bar_factory.bar\n2\n</pre>\n<p>Unlike using lambdas, this does not create nested \u201cRussian dolls\u201d:</p>\n<pre>&gt;&gt;&gt; bar_factory2.getCallable()\n&lt;class 'Bar'&gt;\n</pre>\n</div>\n<div id=\"decorators\">\n<h2>Decorators</h2>\n<p><strong>returnFactory</strong> is a decorator which <em>replaces</em> a function with its Factory-producing equivalent:</p>\n<pre>&gt;&gt;&gt; @returnFactory\n... def mult(x, y):\n...     return x * y\n&gt;&gt;&gt; fac = mult(x=10, y=5)\n&gt;&gt;&gt; isinstance(fac, Factory)\nTrue\n&gt;&gt;&gt; fac()\n50\n</pre>\n<p><strong>factoryAttribute</strong> adds a <tt>factory</tt> attribute to the decorated function:</p>\n<pre>&gt;&gt;&gt; @factoryAttribute\n... def adder(x, y):\n...     return x + y\n&gt;&gt;&gt; fac = adder.factory(x=10)\n&gt;&gt;&gt; isinstance(fac, Factory)\nTrue\n&gt;&gt;&gt; fac2 = adder.factory()\n&gt;&gt;&gt; fac is not fac2\nTrue\n&gt;&gt;&gt; fac(y=42)\n52\n</pre>\n<p><strong>factoryDescriptor</strong> produces instance methods with a <tt>factory</tt> attribute. Inside classes, use this descriptor instead of factoryAttribute. This class may be used as a decorator:</p>\n<pre>&gt;&gt;&gt; class Quux(object):\n...     @factoryDescriptor\n...     def doStuff(self, whatnot):\n...          pass\n&gt;&gt;&gt; quux = Quux()\n&gt;&gt;&gt; fac = quux.doStuff.factory(whatnot=42)\n&gt;&gt;&gt; isinstance(fac, Factory)\nTrue\n&gt;&gt;&gt; fac.whatnot\n42\n</pre>\n</div>\n<div id=\"objecttemplates\">\n<h2>ObjectTemplates</h2>\n<p>ObjectTemplates are a template for creating objects. They work well with Factories.</p>\n<p>A <strong>Bunch</strong> is simply a bunch of attributes. Keyword arguments to a Bunch are turned into attributes:</p>\n<pre>&gt;&gt;&gt; b = Bunch(pants=42, shirt=15)\n&gt;&gt;&gt; b.pants\n42\n&gt;&gt;&gt; b.shirt\n15\n</pre>\n<p>Calling a bunch returns a new copy:</p>\n<pre>&gt;&gt;&gt; c = b()\n&gt;&gt;&gt; c.__dict__ == b.__dict__\nTrue\n&gt;&gt;&gt; c is b\nFalse\n</pre>\n<p>When called, an <strong>ObjectTemplate</strong> instance produces a new instance\nof <tt>bunchClass</tt>. Attributes on the template are passed as kwargs\nto the bunch.  However, if an attribute is callable, it is called\nand the return value is used instead:</p>\n<pre>&gt;&gt;&gt; counter = itertools.count(1).next # an incrementing counter\n&gt;&gt;&gt; def color():\n...     return \"blue\"\n&gt;&gt;&gt; template = ObjectTemplate(size=42,\n...                           color=color,\n...                           count=counter,\n...                           bunchClass=Bunch)\n&gt;&gt;&gt; bunch = template()\n&gt;&gt;&gt; isinstance(bunch, Bunch)\nTrue\n&gt;&gt;&gt; bunch.size\n42\n&gt;&gt;&gt; bunch.color\n'blue'\n&gt;&gt;&gt; bunch.count\n1\n</pre>\n<p>Each call to the template produces a new bunch.  Any functions will\nbe called again:</p>\n<pre>&gt;&gt;&gt; bunch2 = template()\n&gt;&gt;&gt; bunch2.count\n2\n</pre>\n<p>If you want to pass a callable object to the bunch, wrap it in a lambda:</p>\n<pre>&gt;&gt;&gt; template = ObjectTemplate()\n&gt;&gt;&gt; template.return_val = color\n&gt;&gt;&gt; template.a_function = lambda: color\n&gt;&gt;&gt; bunch = template()\n&gt;&gt;&gt; bunch.return_val\n'blue'\n&gt;&gt;&gt; bunch.a_function #doctest:+ELLIPSIS\n&lt;function color at ...&gt;\n</pre>\n</div>\n<div id=\"bugs\">\n<h2>Bugs</h2>\n<p>Bugs, feature requests and praise may be sent directly to <a href=\"mailto:pfein%40pobox.com\">the author</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 784232, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "90cc1b5451b1f4d740fa6a733c4a4e54", "sha256": "74f48d24492fa89b0a530ead6501e9b025aa26454af72882885c56703bc9aa8b"}, "downloads": -1, "filename": "Factory-1.0.tar.gz", "has_sig": true, "md5_digest": "90cc1b5451b1f4d740fa6a733c4a4e54", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7621, "upload_time": "2008-11-07T19:48:11", "upload_time_iso_8601": "2008-11-07T19:48:11Z", "url": "https://files.pythonhosted.org/packages/6d/73/e6498aea9b7b6a188b5569126e0a39928ffc1d7bf37eafa511ea9cc81b18/Factory-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "27e1ddf9ddcdc176567818eb36afbc00", "sha256": "2a83eb836b9e929fd8682575a8ee700e4012d8e32c826895db3044aedab96006"}, "downloads": -1, "filename": "Factory-1.1.tar.gz", "has_sig": true, "md5_digest": "27e1ddf9ddcdc176567818eb36afbc00", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8880, "upload_time": "2008-11-10T22:05:51", "upload_time_iso_8601": "2008-11-10T22:05:51Z", "url": "https://files.pythonhosted.org/packages/20/bf/6845c17765bced37a0032e22fb3f8f4fcc30b90617250c445413e1e6a2d8/Factory-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "a1e0c5d326cea1c4e7a588f28ce9c5de", "sha256": "c0af96e123ac9164ca7d1b9905de749f94e819c8e85341c8fb9f1dd2e349c8cc"}, "downloads": -1, "filename": "Factory-1.2.tar.gz", "has_sig": true, "md5_digest": "a1e0c5d326cea1c4e7a588f28ce9c5de", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8944, "upload_time": "2008-12-23T22:07:01", "upload_time_iso_8601": "2008-12-23T22:07:01Z", "url": "https://files.pythonhosted.org/packages/18/7b/342e9c93d32b21deaaded9fb929413b71c37187079bbdce4b6bae4568f47/Factory-1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a1e0c5d326cea1c4e7a588f28ce9c5de", "sha256": "c0af96e123ac9164ca7d1b9905de749f94e819c8e85341c8fb9f1dd2e349c8cc"}, "downloads": -1, "filename": "Factory-1.2.tar.gz", "has_sig": true, "md5_digest": "a1e0c5d326cea1c4e7a588f28ce9c5de", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8944, "upload_time": "2008-12-23T22:07:01", "upload_time_iso_8601": "2008-12-23T22:07:01Z", "url": "https://files.pythonhosted.org/packages/18/7b/342e9c93d32b21deaaded9fb929413b71c37187079bbdce4b6bae4568f47/Factory-1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:03 2020"}