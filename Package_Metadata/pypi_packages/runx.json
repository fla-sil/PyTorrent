{"info": {"author": "Andrew Tao", "author_email": "atao@nvidia.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# runx - An experiment management tool\n\nrunx helps to automate common tasks while doing research:\n* hyperparameter sweeps\n* logging, tensorboard, checkpoint management\n* per-run unique directory creation\n* experiment summarization\n* code checkpointing\n* easy integration\n\n## Quick-start Installation\n\nInstall with pip:\n```\n> pip install runx\n```\n\nInstall with source:\n```\n> git clone https://github.com/NVIDIA/runx\n> cd runx\n> python setup.py install --user\n```\n\n## Introduction: a simple example\nSuppose you have an existing project that you call as follows:\n\n```bash\n> python train.py --lr 0.01 --solver sgd\n```\nTo run a hyperparameter sweep, you'd normally have to code up a one-off script to generate the sweep.\nBut with runx, you would simply define a yaml that defines lists of hyperparams that you'd like to use.\n\nStart by creating a yaml file called `sweep.yml`:\n```yml\ncmd: 'python train.py'\n\nhparams:\n  lr: [0.01, 0.02]\n  solver: ['sgd', 'adam']\n```\n\nNow you can run the sweep with runx:\n\n```bash\n> python -m runx.runx sweep.yml\n\npython train.py --lr 0.01 --solver sgd\npython train.py --lr 0.01 --solver adam\npython train.py --lr 0.02 --solver sgd\npython train.py --lr 0.02 --solver adam\n```\nYou can see that runx automatically computes the cross product of all hyperparameters, which in this\ncase results in 4 runs. It then builds commandlines by concatenating the hyperparameters with\nthe training command.\n\nrunx is intended to be used to launch batch jobs to a farm. Because running many training runs\ninteractively would take a long time! \nFarm support is simple. Create a .runx file that configures the farm:\n\n```yaml\nLOGROOT: /home/logs\nFARM: bigfarm\n\nbigfarm:\n  SUBMIT_CMD: 'submit_job'\n  RESOURCES:\n     gpu: 2\n     cpu: 16\n     mem: 128\n```\nYou've told it a few things here: where to put the assets for each run, under /home/logs, and\nwhat command and what resources to use to submit each run to the farm.\n\nNow when you call runx, because `FARM` is defined as `bigfarm`, it will use `bigfarm`'s\ndefinition to perform submissions.\n\n```bash\n> python -m runx.runx sweep.yml\n\nsubmit_job --gpu 2 --cpu 16 --mem 128 -c \"python train.py --lr 0.01 --solver sgd\"\nsubmit_job --gpu 2 --cpu 16 --mem 128 -c \"python train.py --lr 0.01 --solver adam\"\nsubmit_job --gpu 2 --cpu 16 --mem 128 -c \"python train.py --lr 0.02 --solver sgd\"\nsubmit_job --gpu 2 --cpu 16 --mem 128 -c \"python train.py --lr 0.02 --solver adam\"\n```\nHere, submit_job is a placeholder for your farm submission command.\n\nFinally, we want the results for each training run to go into a unique output/log directory.\nWe don't want things like tensorboard files or logfiles to write over each other.\nrunx solves this problem by automatically generating a unique output directory per run.\nThis directory is passed to your training script via a special field: `LOGDIR`. Your training\nscript must use this path and write it's output there.\n\n```yml\nCMD: 'python train.py'\n\nHPARAMS:\n  lr: [0.01, 0.02]\n  solver: ['sgd', 'adam']\n  logdir: LOGDIR\n```\n\nNow when we launch the jobs, runx automatically generates unique output directories and passes the paths to your training script:\n```bash\n> python -m runx.runx sweep.yml\n\nsubmit_job --gpu 2 --cpu 16 --mem 128 -c \"python train.py --lr 0.01 --solver sgd  --logdir /home/logs/athletic-wallaby_2020.02.06_14.19\"\nsubmit_job --gpu 2 --cpu 16 --mem 128 -c \"python train.py --lr 0.01 --solver adam  --logdir /home/logs/industrious-chicken_2020.02.06_14.19\"\nsubmit_job --gpu 2 --cpu 16 --mem 128 -c \"python train.py --lr 0.02 --solver sgd  --logdir /home/logs/arrogant-buffalo_2020.02.06_14.19\"\nsubmit_job --gpu 2 --cpu 16 --mem 128 -c \"python train.py --lr 0.02 --solver adam  --logdir /home/logs/vengeful-jaguar_2020.02.06_14.19\"\n```\n\nAfter you've run your experiment, you will likely want to summarize the results. \nWhich training run was best?\n\nYou summarize your runs with `sumx`. sumx knows where your logs are kept: it's the concatenation of LOGROOT and your experiment name.\nSo all you need to do is tell sumx which experiment you want summarized:\n\n```bash\n> python -m runx.sumx sweep --sortwith acc\n\n        lr    solver  acc   epoch  epoch_time\n------\t----  ------  ----  -----  ----------\nrun4    0.02  adam    99.1   10     5:11\nrun3    0.02  sgd     99.0   10     5:05\nrun1    0.01  sgd     98.2   10     5:15\nrun2    0.01  adam    98.1   10     5:12\n```\nsumx is part of the runx suite, and is able to summarize the different hyperparmeters used as well as the\nmetrics/results of your runs. Notice that we used the --sortwith feature of sumx, which sorts your results so\nyou can easily locate your best runs.\n\nThis is the basic idea.\nThe following sections will go into more details about all the various features.\n\n## runx Architecture\nrunx consists of three main modules:\n\n* **runx**\n  * Launch sweeps of training runs using a concise yaml format that allows for multiple values for each hyperparameter\n  * In particular, when you call runx:\n    * Calculate cross product of all hyperparameters -> runs\n\t* For each run, create an output directory, copy your code there, and then launch the training command\n* **logx**\n  * Logging of metrics, messages, checkpoints, tensorboard\n* **sumx**\n  * Summarize the results of training runs, showing results and unique hyperparameters\n\nThese modules are intended to be used jointly, but if you just want to use runx, that's fine.\nHowever using sumx requires that you've used logx to record metrics.\n\n\n\n## Installation\n\nThe easiest way to install is via pip:\n\n```bash\n> pip install runx --extra-index-url=https://pypi.perflab.nvidia.com\n```\n\nAlternatively, you could make runx a git submodule of your project:\n\n``` bash\ncd <your repo>\ngit submodule add -b master ssh://git@gitlab-master.nvidia.com:runx.git\n```\n\n## Create a project-specific configuration file\n\nCreate a .runx file within your repo using the example below.\nThe .runx file defines whether and how to submit jobs to your compute cluster, and where to put the output.\n\n* `LOGROOT` - the root directory where you want your logs placed. This is a path that any farm job can write to.\n* `FARM` - if defined, jobs should be submitted to this farm, else run interactively\n* `SUBMIT_CMD` - the cluster submission command\n* `RESOURCES` - hyperparameters passed to `submit_cmd`\n* `CODE_IGNORE_PATTERNS` - ignore these files patterns when copying code to output directory\n\nHere's an example of such a file:\n\n```yaml\nLOGROOT: /home/logs\nFARM: bigfarm\nCODE_IGNORE_PATTERNS: '.git,*.pyc,docs*,test*'\n\n# Farm resource needs\nbigfarm:\n    SUBMIT_CMD: 'submit_job'\n    RESOURCES:\n        image: mydocker-image-big:1.0\n        gpu: 8\n        cpu: 64\n        mem: 450\n\nsmallfarm:\n    SUBMIT_CMD: 'submit_small'\n    RESOURCES:\n        image: mydocker-image-small:1.2\n        gpu: 4\n        cpu: 32\n        mem: 256\n```\n\n## Run directory, logfiles\n\nrunx has two level of experiment hierarchy: **experiments** and **runs**.\nAn experiment correponds to a single yaml file, which may contain many runs.\n\nrunx creates both a parent experiment directory and a unique output directory for each run.\nThe name of the experiment directory is `LOGROOT/<experiment name>`, so in the example of\nsweep.yml, the experiment name is `sweep`, derived from the yaml filename.\n\n```bash\n/home/logs\n  sweep/\n     curious-rattlesnake_2020.02.06_14.19/\n     ambitious-lobster_2020.02.06_14.19/\n     ...\n```\n\nThe individual run directories are named with a combination of `coolname` and date. The\nuse of `coolname` makes it much easier to refer to a given run than referring to a date code.\n\nThe names can be customized using the RUNX.TAG field in your experiment yaml.\n\nCopying code: because runx actually copies your code to each run's output directory, runx is essentially checkpointing your code. This provides two services: (1) it allows you to change your sourcecode after you've launch some runs (2) it records exactly what code was used for a particular run\n\n## Experiment yaml details\n\n### Booleans\nIf you want to specify that a boolean flag should be on or off, this is done using `true` and `false` keywords:\n  ```\n  some_flag: [true, false]\n  ```\nThis would result having one run with `--some_flag` and another run without that flag\n\nIf instead you want to pass an actual string, you could instad do the following:\n```\n  some_arg: ['True', 'False']\n```\nThis would result in one run with `--some_arg True` and other run with `--some_arg False`\n\nIf you'd like an argument to not be passed into your script at all, you can set it to `None`\n```\n  some_arg: None\n```\n\n### Lists, Inheritance\nOftentimes, you might want to define separate lists of hyperparameters in your experiment.\nFor example:\n 1. arch = alexnet with lr=[0.01, 0.02]\n 2. arch = resnet50 with lr=[0.002, 0.005]\n\nYou can do this with hparams defined as follows:\n```yaml\nHPARAMS: [\n  {\n   logdir: LOGDIR,\n   adam: true,\n   arch: alexnet,\n   lr: [0.01, 0.02],\n   epochs: 10,\n   RUNX.TAG: 'alexnet',\n  },\n  {\n   arch: resnet50,\n   lr: [0.002, 0.005],\n   RUNX.TAG: 'resnet50',\n  }\n]\n```\nYou might observe that hparams is now a list of two dicts. \nThe nice thing is that runx assumes inheritance from the first item in the list to all remaining dicts, so that you don't have to re-type all the redundant hyperparms.\n\nWhen you pass this yaml to runx, you'll get the following out:\n\n``` bash\nsubmit_job ... --name alexnet_2020.02.06_6.32  -c \"python train.py --logdir ... --lr 0.01 --adam --arch alexnet --epochs 10\nsubmit_job ... --name alexnet_2020.02.06_6.40  -c \"python train.py --logdir ... --lr 0.02 --adam --arch alexnet --epochs 10\nsubmit_job ... --name resnet50_2020.02.06_6.45 -c \"python train.py --logdir ... --lr 0.002 --adam --arch resnet50 --epochs 10\nsubmit_job ... --name resnet50_2020.02.06_6.50 -c \"python train.py --logdir ... --lr 0.005 --adam --arch resnet50 --epochs 10\n```\nBecause of inheritance, adam, arch, and epochs params are set identically in each run.\n\nThis is also showing the use of the magic variable `RUNX.TAG`, which allows you to add a tag to a subset of your experiment. This is the same as if you'd used the --tag <tagname> option to runx.py, except that here you can specify the tag within the hparams data structure. The value of `RUNX.TAG` is not passed to your training script\n\n## logx - logging, tensorboarding, checkpointing\nIn order to use sumx, you need to export metrics with logx.\nlogx helps to write metrics in a canonical way, so that sumx can summarize the results.\n\nlogx can also make it easy for you to output log information to a file (and stdout)\nlogx can also manage saving of checkpoints automatically, with the benefit being that logx will keep around only the latest and best checkpoints, saving much disk space.\n\nThe basic way you use logx is to modify your training code in the following ways:\n\nAt the top of your training script (or any module that calls logx functions:\n```python\nfrom runx.logx import logx\n```\n\nBefore using logx, you must initialize it as follows:\n```python\n   logx.initialize(logdir=args.logdir, coolname=True, tensorboard=True)\n```\nMake sure that you're only calling logx from rank=0, in the event that you're using distributed data parallel.\n\n\nThen, substitute the following logx calls into your code:\n\n| From                | To                | What                      |\n| ------------------- | ----------------- | ------------------------- |\n| print()             | logx.msg()        | stdout messages           |\n| writer.add_scalar() | logx.add_scalar() | tensorboard scalar writes |\n| writer.add_image()  | logx.add_image()  | tensorboard image writes  |\n|                     | logx.save_model() | save latest/best models   |\n\nFinally, in order for sumx to be able to read the results of your run, you have to push your metrics to logx. You should definitely push the 'val' metrics, but can push 'train' metrics if you like (sumx doesn't consume them at the moment). \n\n```python\n# define which metrics to record\nmetrics = {'loss': test_loss, 'accuracy': accuracy}\n# push the metrics to logfile\nlogx.metric(phase='val', metrics=metrics, epoch=epoch)\n```\n\nSome important points of logx.metric():\n* The `phase` argument describes whether the metric is a train or validation metric.\n* You should set idx == epoch for validation metrics. And for training, idx is typically the iteration count.\n\n\nHere's a final feature of logx: saving of the model. This feature helps save not only the latest but also the best model.\n\n```python\nsave_dict = {'epoch': epoch + 1,\n             'arch': args.arch,\n             'state_dict': model.state_dict(),\n             'best_acc1': best_acc1,\n             'optimizer' : optimizer.state_dict()}\nlogx.save_model(save_dict, metric=accuracy, epoch=epoch, higher_better=True)\n```\n\nYou do have to tell save_model whether the metric is better when it's higher or lower.\n\n## sumx - summarizing your runs\n\nsumx summarizes the results of your runs. It requires that you've logged your metrics with logx.metric().\nWe chose this behavior instead of reading Tensorboard files directly because that would be much slower.\n\n``` bash\n> python -m runx.sumx sweep\n        lr    solver  acc   epoch  epoch_time\nrun4    0.02  adam    99.1  10     5:21\nrun3    0.02  sgd     99.0  10     5:02\nrun1    0.01  sgd     98.2  10     5:40\nrun2    0.01  adam    98.1  10     5:25\n```\n\nA few features worth knowing about:\n* use `--sortwith` to sort the output by a particular field (like accuracy) that you care about most\n* sumx tells you what epoch your run is current on\n* sumx tells you the average epoch time, which is handy if you are monitoring training speed\n* use the optional `--ignore` flag to limit what fields sumx prints out\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/NVIDIA/runx", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "runx", "package_url": "https://pypi.org/project/runx/", "platform": "", "project_url": "https://pypi.org/project/runx/", "project_urls": {"Homepage": "https://github.com/NVIDIA/runx"}, "release_url": "https://pypi.org/project/runx/0.0.4/", "requires_dist": ["pyyaml (>=5.1.1)", "coolname (>=1.1.0)", "tabulate (>=0.8.3)", "tensorboardX (>=1.4)"], "requires_python": ">=3.6", "summary": "runx - experiment manager for machine learning research", "version": "0.0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>runx - An experiment management tool</h1>\n<p>runx helps to automate common tasks while doing research:</p>\n<ul>\n<li>hyperparameter sweeps</li>\n<li>logging, tensorboard, checkpoint management</li>\n<li>per-run unique directory creation</li>\n<li>experiment summarization</li>\n<li>code checkpointing</li>\n<li>easy integration</li>\n</ul>\n<h2>Quick-start Installation</h2>\n<p>Install with pip:</p>\n<pre><code>&gt; pip install runx\n</code></pre>\n<p>Install with source:</p>\n<pre><code>&gt; git clone https://github.com/NVIDIA/runx\n&gt; cd runx\n&gt; python setup.py install --user\n</code></pre>\n<h2>Introduction: a simple example</h2>\n<p>Suppose you have an existing project that you call as follows:</p>\n<pre>&gt; python train.py --lr <span class=\"m\">0</span>.01 --solver sgd\n</pre>\n<p>To run a hyperparameter sweep, you'd normally have to code up a one-off script to generate the sweep.\nBut with runx, you would simply define a yaml that defines lists of hyperparams that you'd like to use.</p>\n<p>Start by creating a yaml file called <code>sweep.yml</code>:</p>\n<pre>cmd: 'python train.py'\n\nhparams:\n  lr: [0.01, 0.02]\n  solver: ['sgd', 'adam']\n</pre>\n<p>Now you can run the sweep with runx:</p>\n<pre>&gt; python -m runx.runx sweep.yml\n\npython train.py --lr <span class=\"m\">0</span>.01 --solver sgd\npython train.py --lr <span class=\"m\">0</span>.01 --solver adam\npython train.py --lr <span class=\"m\">0</span>.02 --solver sgd\npython train.py --lr <span class=\"m\">0</span>.02 --solver adam\n</pre>\n<p>You can see that runx automatically computes the cross product of all hyperparameters, which in this\ncase results in 4 runs. It then builds commandlines by concatenating the hyperparameters with\nthe training command.</p>\n<p>runx is intended to be used to launch batch jobs to a farm. Because running many training runs\ninteractively would take a long time!\nFarm support is simple. Create a .runx file that configures the farm:</p>\n<pre><span class=\"nt\">LOGROOT</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">/home/logs</span>\n<span class=\"nt\">FARM</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">bigfarm</span>\n\n<span class=\"nt\">bigfarm</span><span class=\"p\">:</span>\n  <span class=\"nt\">SUBMIT_CMD</span><span class=\"p\">:</span> <span class=\"s\">'submit_job'</span>\n  <span class=\"nt\">RESOURCES</span><span class=\"p\">:</span>\n     <span class=\"nt\">gpu</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">2</span>\n     <span class=\"nt\">cpu</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">16</span>\n     <span class=\"nt\">mem</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">128</span>\n</pre>\n<p>You've told it a few things here: where to put the assets for each run, under /home/logs, and\nwhat command and what resources to use to submit each run to the farm.</p>\n<p>Now when you call runx, because <code>FARM</code> is defined as <code>bigfarm</code>, it will use <code>bigfarm</code>'s\ndefinition to perform submissions.</p>\n<pre>&gt; python -m runx.runx sweep.yml\n\nsubmit_job --gpu <span class=\"m\">2</span> --cpu <span class=\"m\">16</span> --mem <span class=\"m\">128</span> -c <span class=\"s2\">\"python train.py --lr 0.01 --solver sgd\"</span>\nsubmit_job --gpu <span class=\"m\">2</span> --cpu <span class=\"m\">16</span> --mem <span class=\"m\">128</span> -c <span class=\"s2\">\"python train.py --lr 0.01 --solver adam\"</span>\nsubmit_job --gpu <span class=\"m\">2</span> --cpu <span class=\"m\">16</span> --mem <span class=\"m\">128</span> -c <span class=\"s2\">\"python train.py --lr 0.02 --solver sgd\"</span>\nsubmit_job --gpu <span class=\"m\">2</span> --cpu <span class=\"m\">16</span> --mem <span class=\"m\">128</span> -c <span class=\"s2\">\"python train.py --lr 0.02 --solver adam\"</span>\n</pre>\n<p>Here, submit_job is a placeholder for your farm submission command.</p>\n<p>Finally, we want the results for each training run to go into a unique output/log directory.\nWe don't want things like tensorboard files or logfiles to write over each other.\nrunx solves this problem by automatically generating a unique output directory per run.\nThis directory is passed to your training script via a special field: <code>LOGDIR</code>. Your training\nscript must use this path and write it's output there.</p>\n<pre>CMD: 'python train.py'\n\nHPARAMS:\n  lr: [0.01, 0.02]\n  solver: ['sgd', 'adam']\n  logdir: LOGDIR\n</pre>\n<p>Now when we launch the jobs, runx automatically generates unique output directories and passes the paths to your training script:</p>\n<pre>&gt; python -m runx.runx sweep.yml\n\nsubmit_job --gpu <span class=\"m\">2</span> --cpu <span class=\"m\">16</span> --mem <span class=\"m\">128</span> -c <span class=\"s2\">\"python train.py --lr 0.01 --solver sgd  --logdir /home/logs/athletic-wallaby_2020.02.06_14.19\"</span>\nsubmit_job --gpu <span class=\"m\">2</span> --cpu <span class=\"m\">16</span> --mem <span class=\"m\">128</span> -c <span class=\"s2\">\"python train.py --lr 0.01 --solver adam  --logdir /home/logs/industrious-chicken_2020.02.06_14.19\"</span>\nsubmit_job --gpu <span class=\"m\">2</span> --cpu <span class=\"m\">16</span> --mem <span class=\"m\">128</span> -c <span class=\"s2\">\"python train.py --lr 0.02 --solver sgd  --logdir /home/logs/arrogant-buffalo_2020.02.06_14.19\"</span>\nsubmit_job --gpu <span class=\"m\">2</span> --cpu <span class=\"m\">16</span> --mem <span class=\"m\">128</span> -c <span class=\"s2\">\"python train.py --lr 0.02 --solver adam  --logdir /home/logs/vengeful-jaguar_2020.02.06_14.19\"</span>\n</pre>\n<p>After you've run your experiment, you will likely want to summarize the results.\nWhich training run was best?</p>\n<p>You summarize your runs with <code>sumx</code>. sumx knows where your logs are kept: it's the concatenation of LOGROOT and your experiment name.\nSo all you need to do is tell sumx which experiment you want summarized:</p>\n<pre>&gt; python -m runx.sumx sweep --sortwith acc\n\n        lr    solver  acc   epoch  epoch_time\n------\t----  ------  ----  -----  ----------\nrun4    <span class=\"m\">0</span>.02  adam    <span class=\"m\">99</span>.1   <span class=\"m\">10</span>     <span class=\"m\">5</span>:11\nrun3    <span class=\"m\">0</span>.02  sgd     <span class=\"m\">99</span>.0   <span class=\"m\">10</span>     <span class=\"m\">5</span>:05\nrun1    <span class=\"m\">0</span>.01  sgd     <span class=\"m\">98</span>.2   <span class=\"m\">10</span>     <span class=\"m\">5</span>:15\nrun2    <span class=\"m\">0</span>.01  adam    <span class=\"m\">98</span>.1   <span class=\"m\">10</span>     <span class=\"m\">5</span>:12\n</pre>\n<p>sumx is part of the runx suite, and is able to summarize the different hyperparmeters used as well as the\nmetrics/results of your runs. Notice that we used the --sortwith feature of sumx, which sorts your results so\nyou can easily locate your best runs.</p>\n<p>This is the basic idea.\nThe following sections will go into more details about all the various features.</p>\n<h2>runx Architecture</h2>\n<p>runx consists of three main modules:</p>\n<ul>\n<li><strong>runx</strong>\n<ul>\n<li>Launch sweeps of training runs using a concise yaml format that allows for multiple values for each hyperparameter</li>\n<li>In particular, when you call runx:\n<ul>\n<li>Calculate cross product of all hyperparameters -&gt; runs</li>\n<li>For each run, create an output directory, copy your code there, and then launch the training command</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>logx</strong>\n<ul>\n<li>Logging of metrics, messages, checkpoints, tensorboard</li>\n</ul>\n</li>\n<li><strong>sumx</strong>\n<ul>\n<li>Summarize the results of training runs, showing results and unique hyperparameters</li>\n</ul>\n</li>\n</ul>\n<p>These modules are intended to be used jointly, but if you just want to use runx, that's fine.\nHowever using sumx requires that you've used logx to record metrics.</p>\n<h2>Installation</h2>\n<p>The easiest way to install is via pip:</p>\n<pre>&gt; pip install runx --extra-index-url<span class=\"o\">=</span>https://pypi.perflab.nvidia.com\n</pre>\n<p>Alternatively, you could make runx a git submodule of your project:</p>\n<pre><span class=\"nb\">cd</span> &lt;your repo&gt;\ngit submodule add -b master ssh://git@gitlab-master.nvidia.com:runx.git\n</pre>\n<h2>Create a project-specific configuration file</h2>\n<p>Create a .runx file within your repo using the example below.\nThe .runx file defines whether and how to submit jobs to your compute cluster, and where to put the output.</p>\n<ul>\n<li><code>LOGROOT</code> - the root directory where you want your logs placed. This is a path that any farm job can write to.</li>\n<li><code>FARM</code> - if defined, jobs should be submitted to this farm, else run interactively</li>\n<li><code>SUBMIT_CMD</code> - the cluster submission command</li>\n<li><code>RESOURCES</code> - hyperparameters passed to <code>submit_cmd</code></li>\n<li><code>CODE_IGNORE_PATTERNS</code> - ignore these files patterns when copying code to output directory</li>\n</ul>\n<p>Here's an example of such a file:</p>\n<pre><span class=\"nt\">LOGROOT</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">/home/logs</span>\n<span class=\"nt\">FARM</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">bigfarm</span>\n<span class=\"nt\">CODE_IGNORE_PATTERNS</span><span class=\"p\">:</span> <span class=\"s\">'.git,*.pyc,docs*,test*'</span>\n\n<span class=\"c1\"># Farm resource needs</span>\n<span class=\"nt\">bigfarm</span><span class=\"p\">:</span>\n    <span class=\"nt\">SUBMIT_CMD</span><span class=\"p\">:</span> <span class=\"s\">'submit_job'</span>\n    <span class=\"nt\">RESOURCES</span><span class=\"p\">:</span>\n        <span class=\"nt\">image</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">mydocker-image-big:1.0</span>\n        <span class=\"nt\">gpu</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">8</span>\n        <span class=\"nt\">cpu</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">64</span>\n        <span class=\"nt\">mem</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">450</span>\n\n<span class=\"nt\">smallfarm</span><span class=\"p\">:</span>\n    <span class=\"nt\">SUBMIT_CMD</span><span class=\"p\">:</span> <span class=\"s\">'submit_small'</span>\n    <span class=\"nt\">RESOURCES</span><span class=\"p\">:</span>\n        <span class=\"nt\">image</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">mydocker-image-small:1.2</span>\n        <span class=\"nt\">gpu</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">4</span>\n        <span class=\"nt\">cpu</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">32</span>\n        <span class=\"nt\">mem</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">256</span>\n</pre>\n<h2>Run directory, logfiles</h2>\n<p>runx has two level of experiment hierarchy: <strong>experiments</strong> and <strong>runs</strong>.\nAn experiment correponds to a single yaml file, which may contain many runs.</p>\n<p>runx creates both a parent experiment directory and a unique output directory for each run.\nThe name of the experiment directory is <code>LOGROOT/&lt;experiment name&gt;</code>, so in the example of\nsweep.yml, the experiment name is <code>sweep</code>, derived from the yaml filename.</p>\n<pre>/home/logs\n  sweep/\n     curious-rattlesnake_2020.02.06_14.19/\n     ambitious-lobster_2020.02.06_14.19/\n     ...\n</pre>\n<p>The individual run directories are named with a combination of <code>coolname</code> and date. The\nuse of <code>coolname</code> makes it much easier to refer to a given run than referring to a date code.</p>\n<p>The names can be customized using the RUNX.TAG field in your experiment yaml.</p>\n<p>Copying code: because runx actually copies your code to each run's output directory, runx is essentially checkpointing your code. This provides two services: (1) it allows you to change your sourcecode after you've launch some runs (2) it records exactly what code was used for a particular run</p>\n<h2>Experiment yaml details</h2>\n<h3>Booleans</h3>\n<p>If you want to specify that a boolean flag should be on or off, this is done using <code>true</code> and <code>false</code> keywords:</p>\n<pre><code>some_flag: [true, false]\n</code></pre>\n<p>This would result having one run with <code>--some_flag</code> and another run without that flag</p>\n<p>If instead you want to pass an actual string, you could instad do the following:</p>\n<pre><code>  some_arg: ['True', 'False']\n</code></pre>\n<p>This would result in one run with <code>--some_arg True</code> and other run with <code>--some_arg False</code></p>\n<p>If you'd like an argument to not be passed into your script at all, you can set it to <code>None</code></p>\n<pre><code>  some_arg: None\n</code></pre>\n<h3>Lists, Inheritance</h3>\n<p>Oftentimes, you might want to define separate lists of hyperparameters in your experiment.\nFor example:</p>\n<ol>\n<li>arch = alexnet with lr=[0.01, 0.02]</li>\n<li>arch = resnet50 with lr=[0.002, 0.005]</li>\n</ol>\n<p>You can do this with hparams defined as follows:</p>\n<pre><span class=\"nt\">HPARAMS</span><span class=\"p\">:</span> <span class=\"p p-Indicator\">[</span>\n  <span class=\"p p-Indicator\">{</span>\n<span class=\"nt\">   logdir</span><span class=\"p\">:</span> <span class=\"nv\">LOGDIR</span><span class=\"p p-Indicator\">,</span>\n<span class=\"nt\">   adam</span><span class=\"p\">:</span> <span class=\"nv\">true</span><span class=\"p p-Indicator\">,</span>\n<span class=\"nt\">   arch</span><span class=\"p\">:</span> <span class=\"nv\">alexnet</span><span class=\"p p-Indicator\">,</span>\n<span class=\"nt\">   lr</span><span class=\"p\">:</span> <span class=\"p p-Indicator\">[</span><span class=\"nv\">0.01</span><span class=\"p p-Indicator\">,</span> <span class=\"nv\">0.02</span><span class=\"p p-Indicator\">],</span>\n<span class=\"nt\">   epochs</span><span class=\"p\">:</span> <span class=\"nv\">10</span><span class=\"p p-Indicator\">,</span>\n<span class=\"nt\">   RUNX.TAG</span><span class=\"p\">:</span> <span class=\"s\">'alexnet'</span><span class=\"p p-Indicator\">,</span>\n  <span class=\"p p-Indicator\">},</span>\n  <span class=\"p p-Indicator\">{</span>\n<span class=\"nt\">   arch</span><span class=\"p\">:</span> <span class=\"nv\">resnet50</span><span class=\"p p-Indicator\">,</span>\n<span class=\"nt\">   lr</span><span class=\"p\">:</span> <span class=\"p p-Indicator\">[</span><span class=\"nv\">0.002</span><span class=\"p p-Indicator\">,</span> <span class=\"nv\">0.005</span><span class=\"p p-Indicator\">],</span>\n<span class=\"nt\">   RUNX.TAG</span><span class=\"p\">:</span> <span class=\"s\">'resnet50'</span><span class=\"p p-Indicator\">,</span>\n  <span class=\"p p-Indicator\">}</span>\n<span class=\"p p-Indicator\">]</span>\n</pre>\n<p>You might observe that hparams is now a list of two dicts.\nThe nice thing is that runx assumes inheritance from the first item in the list to all remaining dicts, so that you don't have to re-type all the redundant hyperparms.</p>\n<p>When you pass this yaml to runx, you'll get the following out:</p>\n<pre>submit_job ... --name alexnet_2020.02.06_6.32  -c <span class=\"s2\">\"python train.py --logdir ... --lr 0.01 --adam --arch alexnet --epochs 10</span>\n<span class=\"s2\">submit_job ... --name alexnet_2020.02.06_6.40  -c \"</span>python train.py --logdir ... --lr <span class=\"m\">0</span>.02 --adam --arch alexnet --epochs <span class=\"m\">10</span>\nsubmit_job ... --name resnet50_2020.02.06_6.45 -c <span class=\"s2\">\"python train.py --logdir ... --lr 0.002 --adam --arch resnet50 --epochs 10</span>\n<span class=\"s2\">submit_job ... --name resnet50_2020.02.06_6.50 -c \"</span>python train.py --logdir ... --lr <span class=\"m\">0</span>.005 --adam --arch resnet50 --epochs <span class=\"m\">10</span>\n</pre>\n<p>Because of inheritance, adam, arch, and epochs params are set identically in each run.</p>\n<p>This is also showing the use of the magic variable <code>RUNX.TAG</code>, which allows you to add a tag to a subset of your experiment. This is the same as if you'd used the --tag &lt;tagname&gt; option to runx.py, except that here you can specify the tag within the hparams data structure. The value of <code>RUNX.TAG</code> is not passed to your training script</p>\n<h2>logx - logging, tensorboarding, checkpointing</h2>\n<p>In order to use sumx, you need to export metrics with logx.\nlogx helps to write metrics in a canonical way, so that sumx can summarize the results.</p>\n<p>logx can also make it easy for you to output log information to a file (and stdout)\nlogx can also manage saving of checkpoints automatically, with the benefit being that logx will keep around only the latest and best checkpoints, saving much disk space.</p>\n<p>The basic way you use logx is to modify your training code in the following ways:</p>\n<p>At the top of your training script (or any module that calls logx functions:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">runx.logx</span> <span class=\"kn\">import</span> <span class=\"n\">logx</span>\n</pre>\n<p>Before using logx, you must initialize it as follows:</p>\n<pre>   <span class=\"n\">logx</span><span class=\"o\">.</span><span class=\"n\">initialize</span><span class=\"p\">(</span><span class=\"n\">logdir</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">logdir</span><span class=\"p\">,</span> <span class=\"n\">coolname</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">tensorboard</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Make sure that you're only calling logx from rank=0, in the event that you're using distributed data parallel.</p>\n<p>Then, substitute the following logx calls into your code:</p>\n<table>\n<thead>\n<tr>\n<th>From</th>\n<th>To</th>\n<th>What</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>print()</td>\n<td>logx.msg()</td>\n<td>stdout messages</td>\n</tr>\n<tr>\n<td>writer.add_scalar()</td>\n<td>logx.add_scalar()</td>\n<td>tensorboard scalar writes</td>\n</tr>\n<tr>\n<td>writer.add_image()</td>\n<td>logx.add_image()</td>\n<td>tensorboard image writes</td>\n</tr>\n<tr>\n<td></td>\n<td>logx.save_model()</td>\n<td>save latest/best models</td>\n</tr></tbody></table>\n<p>Finally, in order for sumx to be able to read the results of your run, you have to push your metrics to logx. You should definitely push the 'val' metrics, but can push 'train' metrics if you like (sumx doesn't consume them at the moment).</p>\n<pre><span class=\"c1\"># define which metrics to record</span>\n<span class=\"n\">metrics</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'loss'</span><span class=\"p\">:</span> <span class=\"n\">test_loss</span><span class=\"p\">,</span> <span class=\"s1\">'accuracy'</span><span class=\"p\">:</span> <span class=\"n\">accuracy</span><span class=\"p\">}</span>\n<span class=\"c1\"># push the metrics to logfile</span>\n<span class=\"n\">logx</span><span class=\"o\">.</span><span class=\"n\">metric</span><span class=\"p\">(</span><span class=\"n\">phase</span><span class=\"o\">=</span><span class=\"s1\">'val'</span><span class=\"p\">,</span> <span class=\"n\">metrics</span><span class=\"o\">=</span><span class=\"n\">metrics</span><span class=\"p\">,</span> <span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"n\">epoch</span><span class=\"p\">)</span>\n</pre>\n<p>Some important points of logx.metric():</p>\n<ul>\n<li>The <code>phase</code> argument describes whether the metric is a train or validation metric.</li>\n<li>You should set idx == epoch for validation metrics. And for training, idx is typically the iteration count.</li>\n</ul>\n<p>Here's a final feature of logx: saving of the model. This feature helps save not only the latest but also the best model.</p>\n<pre><span class=\"n\">save_dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'epoch'</span><span class=\"p\">:</span> <span class=\"n\">epoch</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n             <span class=\"s1\">'arch'</span><span class=\"p\">:</span> <span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">arch</span><span class=\"p\">,</span>\n             <span class=\"s1\">'state_dict'</span><span class=\"p\">:</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">state_dict</span><span class=\"p\">(),</span>\n             <span class=\"s1\">'best_acc1'</span><span class=\"p\">:</span> <span class=\"n\">best_acc1</span><span class=\"p\">,</span>\n             <span class=\"s1\">'optimizer'</span> <span class=\"p\">:</span> <span class=\"n\">optimizer</span><span class=\"o\">.</span><span class=\"n\">state_dict</span><span class=\"p\">()}</span>\n<span class=\"n\">logx</span><span class=\"o\">.</span><span class=\"n\">save_model</span><span class=\"p\">(</span><span class=\"n\">save_dict</span><span class=\"p\">,</span> <span class=\"n\">metric</span><span class=\"o\">=</span><span class=\"n\">accuracy</span><span class=\"p\">,</span> <span class=\"n\">epoch</span><span class=\"o\">=</span><span class=\"n\">epoch</span><span class=\"p\">,</span> <span class=\"n\">higher_better</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>You do have to tell save_model whether the metric is better when it's higher or lower.</p>\n<h2>sumx - summarizing your runs</h2>\n<p>sumx summarizes the results of your runs. It requires that you've logged your metrics with logx.metric().\nWe chose this behavior instead of reading Tensorboard files directly because that would be much slower.</p>\n<pre>&gt; python -m runx.sumx sweep\n        lr    solver  acc   epoch  epoch_time\nrun4    <span class=\"m\">0</span>.02  adam    <span class=\"m\">99</span>.1  <span class=\"m\">10</span>     <span class=\"m\">5</span>:21\nrun3    <span class=\"m\">0</span>.02  sgd     <span class=\"m\">99</span>.0  <span class=\"m\">10</span>     <span class=\"m\">5</span>:02\nrun1    <span class=\"m\">0</span>.01  sgd     <span class=\"m\">98</span>.2  <span class=\"m\">10</span>     <span class=\"m\">5</span>:40\nrun2    <span class=\"m\">0</span>.01  adam    <span class=\"m\">98</span>.1  <span class=\"m\">10</span>     <span class=\"m\">5</span>:25\n</pre>\n<p>A few features worth knowing about:</p>\n<ul>\n<li>use <code>--sortwith</code> to sort the output by a particular field (like accuracy) that you care about most</li>\n<li>sumx tells you what epoch your run is current on</li>\n<li>sumx tells you the average epoch time, which is handy if you are monitoring training speed</li>\n<li>use the optional <code>--ignore</code> flag to limit what fields sumx prints out</li>\n</ul>\n\n          </div>"}, "last_serial": 6936633, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "fcf3ee6c9462953bb8abd65e6860de97", "sha256": "abbbf0642c5cef35dd049eb47fa0b279075dcfd44864886c363e1f1a90c54a1b"}, "downloads": -1, "filename": "runx-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "fcf3ee6c9462953bb8abd65e6860de97", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23150, "upload_time": "2020-03-27T21:02:36", "upload_time_iso_8601": "2020-03-27T21:02:36.574787Z", "url": "https://files.pythonhosted.org/packages/f4/a6/cdb69ba9688be1d8d756f8e1ae880c46b8f4f84989e6a6aedea32cfa77ea/runx-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "97d9b29f2be4a3e09afbb28af05cd362", "sha256": "a242ff09c221f5e6b04feaa876ab262f8c7e9f04a6dee4d428ab57ae2e105e3d"}, "downloads": -1, "filename": "runx-0.0.1.tar.gz", "has_sig": false, "md5_digest": "97d9b29f2be4a3e09afbb28af05cd362", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 19332, "upload_time": "2020-03-27T21:02:39", "upload_time_iso_8601": "2020-03-27T21:02:39.935523Z", "url": "https://files.pythonhosted.org/packages/ca/89/20ffdbf3cc1ae4cc563656458bcc5872aa6572ccc73dcd93cd6eecb92565/runx-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "95a70cf52521ba66db08852357bf07ca", "sha256": "d9d9c4987a51eb97c2f079bff62ee2c5c5b6c4ab04381242efb44b82e9a9cfba"}, "downloads": -1, "filename": "runx-0.0.2-py3.6.egg", "has_sig": false, "md5_digest": "95a70cf52521ba66db08852357bf07ca", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": ">=3.6", "size": 42495, "upload_time": "2020-04-02T15:41:43", "upload_time_iso_8601": "2020-04-02T15:41:43.317040Z", "url": "https://files.pythonhosted.org/packages/73/37/c1cef7f28c207cfa3519b6773f6e3cf65093981e3e881a908a627be8a9f3/runx-0.0.2-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "bde23b46fad451f5b794e73aa669a92e", "sha256": "3768017bdba80bd33c451a326aab208d278c653e0ff6f2cc3f0008a8b2a0e4b0"}, "downloads": -1, "filename": "runx-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "bde23b46fad451f5b794e73aa669a92e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23152, "upload_time": "2020-03-27T21:02:38", "upload_time_iso_8601": "2020-03-27T21:02:38.920713Z", "url": "https://files.pythonhosted.org/packages/e7/fc/506f14ab836ceef7e24879c2a6ab842add7fdad0d69823a1425cd1e527fb/runx-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9e56a8859e31822e482f6815e08b4b2c", "sha256": "704822ecb3f2b871c34e65fe68e17009170c069b6b37c2a35ab731aeea647b8b"}, "downloads": -1, "filename": "runx-0.0.2.tar.gz", "has_sig": false, "md5_digest": "9e56a8859e31822e482f6815e08b4b2c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 24197, "upload_time": "2020-03-27T21:02:40", "upload_time_iso_8601": "2020-03-27T21:02:40.985058Z", "url": "https://files.pythonhosted.org/packages/bd/07/0bca78ab29c23617b39e2b82009040e74c72cf1c559c836bb30f682ee7c1/runx-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "81d06c9b953f1af3ea853bd2d6fb2c21", "sha256": "212b8ca800c958e98a41d1e868be0ed71e3734319dc376d3473e6030180bab5a"}, "downloads": -1, "filename": "runx-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "81d06c9b953f1af3ea853bd2d6fb2c21", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23154, "upload_time": "2020-04-02T15:41:40", "upload_time_iso_8601": "2020-04-02T15:41:40.894629Z", "url": "https://files.pythonhosted.org/packages/3a/bf/ee2efb8dc6e52d2f89b81ae313aa481687ac6872841bdd4f28061ae20104/runx-0.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c382a5686e768ff2a05e210109e65a1d", "sha256": "923534db55e0b47ab2f7d4b04324da09bb1b7fd482376f53ea31a680b5741740"}, "downloads": -1, "filename": "runx-0.0.3.tar.gz", "has_sig": false, "md5_digest": "c382a5686e768ff2a05e210109e65a1d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 24014, "upload_time": "2020-04-02T15:41:45", "upload_time_iso_8601": "2020-04-02T15:41:45.455152Z", "url": "https://files.pythonhosted.org/packages/19/39/c6565dbd1c7afee90d37d26f048a34f62b32065a8c323174cb3939f8e5d4/runx-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "64bb3896bcdd9c219c977e36e65b6698", "sha256": "1a428c2af676b69c77649b9211cf9795de38b2e04eb00554a06436bd0297e27f"}, "downloads": -1, "filename": "runx-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "64bb3896bcdd9c219c977e36e65b6698", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23152, "upload_time": "2020-04-02T15:51:18", "upload_time_iso_8601": "2020-04-02T15:51:18.481117Z", "url": "https://files.pythonhosted.org/packages/9f/81/8dd4713f23720c8763a5a1a68d67ad6e83d1b9890a7e321f7fe71b896f7d/runx-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "148308a3db438ef08048af0364a80fee", "sha256": "1aa2652ac05fb570e954d2780302cb249400b8e161a50ce2eaa3007713d11a5c"}, "downloads": -1, "filename": "runx-0.0.4.tar.gz", "has_sig": false, "md5_digest": "148308a3db438ef08048af0364a80fee", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 20491, "upload_time": "2020-04-02T15:51:19", "upload_time_iso_8601": "2020-04-02T15:51:19.489019Z", "url": "https://files.pythonhosted.org/packages/88/e5/a2ec63ac24d93ed880740fdb5c58e831c4a8748fbba007275b7101051288/runx-0.0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "64bb3896bcdd9c219c977e36e65b6698", "sha256": "1a428c2af676b69c77649b9211cf9795de38b2e04eb00554a06436bd0297e27f"}, "downloads": -1, "filename": "runx-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "64bb3896bcdd9c219c977e36e65b6698", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23152, "upload_time": "2020-04-02T15:51:18", "upload_time_iso_8601": "2020-04-02T15:51:18.481117Z", "url": "https://files.pythonhosted.org/packages/9f/81/8dd4713f23720c8763a5a1a68d67ad6e83d1b9890a7e321f7fe71b896f7d/runx-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "148308a3db438ef08048af0364a80fee", "sha256": "1aa2652ac05fb570e954d2780302cb249400b8e161a50ce2eaa3007713d11a5c"}, "downloads": -1, "filename": "runx-0.0.4.tar.gz", "has_sig": false, "md5_digest": "148308a3db438ef08048af0364a80fee", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 20491, "upload_time": "2020-04-02T15:51:19", "upload_time_iso_8601": "2020-04-02T15:51:19.489019Z", "url": "https://files.pythonhosted.org/packages/88/e5/a2ec63ac24d93ed880740fdb5c58e831c4a8748fbba007275b7101051288/runx-0.0.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:59:56 2020"}