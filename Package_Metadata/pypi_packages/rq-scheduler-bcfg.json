{"info": {"author": "Selwin Ong", "author_email": "selwin.ong@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "============\nRQ Scheduler\n============\n\n`RQ Scheduler <https://github.com/rq/rq-scheduler>`_ is a small package that\nadds job scheduling capabilities to `RQ <https://github.com/nvie/rq>`_,\na `Redis <http://redis.io/>`_ based Python queuing library.\n\n.. image:: https://travis-ci.org/rq/rq-scheduler.svg?branch=master\n    :target: https://travis-ci.org/rq/rq-scheduler\n\n============\nRequirements\n============\n\n* `RQ`_\n\n============\nInstallation\n============\n\nYou can install `RQ Scheduler`_ via pip::\n\n    pip install rq-scheduler\n\nOr you can download the latest stable package from `PyPI <http://pypi.python.org/pypi/rq-scheduler>`_.\n\n=====\nUsage\n=====\n\nSchedule a job involves doing two different things:\n\n1. Putting a job in the scheduler\n2. Running a scheduler that will move scheduled jobs into queues when the time comes\n\n----------------\nScheduling a Job\n----------------\n\nThere are two ways you can schedule a job. The first is using RQ Scheduler's ``enqueue_at``\n\n.. code-block:: python\n\n    from redis import Redis\n    from rq import Queue\n    from rq_scheduler import Scheduler\n    from datetime import datetime\n\n    scheduler = Scheduler(connection=Redis()) # Get a scheduler for the \"default\" queue\n\n    # You can also instantiate a Scheduler using an RQ Queue\n    queue = Queue('foo', connection=Redis())\n    scheduler = Scheduler(queue=queue)\n\n    # Puts a job into the scheduler. The API is similar to RQ except that it\n    # takes a datetime object as first argument. So for example to schedule a\n    # job to run on Jan 1st 2020 we do:\n    scheduler.enqueue_at(datetime(2020, 1, 1), func) # Date time should be in UTC\n\n    # Here's another example scheduling a job to run at a specific date and time (in UTC),\n    # complete with args and kwargs.\n    scheduler.enqueue_at(datetime(2020, 1, 1, 3, 4), func, foo, bar=baz)\n\n\nThe second way is using ``enqueue_in``. Instead of taking a ``datetime`` object,\nthis method expects a ``timedelta`` and schedules the job to run at\nX seconds/minutes/hours/days/weeks later. For example, if we want to monitor how\npopular a tweet is a few times during the course of the day, we could do something like\n\n.. code-block:: python\n\n    from datetime import timedelta\n\n    # Schedule a job to run 10 minutes, 1 hour and 1 day later\n    scheduler.enqueue_in(timedelta(minutes=10), count_retweets, tweet_id)\n    scheduler.enqueue_in(timedelta(hours=1), count_retweets, tweet_id)\n    scheduler.enqueue_in(timedelta(days=1), count_retweets, tweet_id)\n\n**IMPORTANT**: You should always use UTC datetime when working with `RQ Scheduler`_.\n\n------------------------\nPeriodic & Repeated Jobs\n------------------------\n\nAs of version 0.3, `RQ Scheduler`_ also supports creating periodic and repeated jobs.\nYou can do this via the ``schedule`` method. Note that this feature needs\n`RQ`_ >= 0.3.1.\n\nThis is how you do it\n\n.. code-block:: python\n\n    scheduler.schedule(\n        scheduled_time=datetime.utcnow(), # Time for first execution, in UTC timezone\n        func=func,                     # Function to be queued\n        args=[arg1, arg2],             # Arguments passed into function when executed\n        kwargs={'foo': 'bar'},         # Keyword arguments passed into function when executed\n        interval=60,                   # Time before the function is called again, in seconds\n        repeat=10,                     # Repeat this number of times (None means repeat forever)\n        meta={'foo': 'bar'}            # Arbitrary pickleable data on the job itself\n    )\n\n**IMPORTANT NOTE**: If you set up a repeated job, you must make sure that you\neither do not set a `result_ttl` value or you set a value larger than the interval.\nOtherwise, the entry with the job details will expire and the job will not get re-scheduled.\n\n------------------------\nCron Jobs\n------------------------\n\nAs of version 0.6.0, `RQ Scheduler`_ also supports creating Cron Jobs, which you can use for\nrepeated jobs to run periodically at fixed times, dates or intervals, for more info check\nhttps://en.wikipedia.org/wiki/Cron. You can do this via the ``cron`` method.\n\nThis is how you do it\n\n.. code-block:: python\n\n    scheduler.cron(\n        cron_string,                # A cron string (e.g. \"0 0 * * 0\")\n        func=func,                  # Function to be queued\n        args=[arg1, arg2],          # Arguments passed into function when executed\n        kwargs={'foo': 'bar'},      # Keyword arguments passed into function when executed\n        repeat=10,                  # Repeat this number of times (None means repeat forever)\n        queue_name=queue_name,      # In which queue the job should be put in\n        meta={'foo': 'bar'}         # Arbitrary pickleable data on the job itself\n    )\n\n-------------------------\nRetrieving scheduled jobs\n-------------------------\n\nSometimes you need to know which jobs have already been scheduled. You can get a\nlist of enqueued jobs with the ``get_jobs`` method\n\n.. code-block:: python\n\n    list_of_job_instances = scheduler.get_jobs()\n\nIn it's simplest form (as seen in the above example) this method returns a list\nof all job instances that are currently scheduled for execution.\n\nAdditionally the method takes two optional keyword arguments ``until`` and\n``with_times``. The first one specifies up to which point in time scheduled jobs\nshould be returned. It can be given as either a datetime / timedelta instance\nor an integer denoting the number of seconds since epoch (1970-01-01 00:00:00).\nThe second argument is a boolen that determines whether the scheduled execution\ntime should be returned along with the job instances.\n\nExample\n\n.. code-block:: python\n\n    # get all jobs until 2012-11-30 10:00:00\n    list_of_job_instances = scheduler.get_jobs(until=datetime(2012, 10, 30, 10))\n\n    # get all jobs for the next hour\n    list_of_job_instances = scheduler.get_jobs(until=timedelta(hours=1))\n\n    # get all jobs with execution times\n    jobs_and_times = scheduler.get_jobs(with_times=True)\n    # returns a list of tuples:\n    # [(<rq.job.Job object at 0x123456789>, datetime.datetime(2012, 11, 25, 12, 30)), ...]\n\n------------------------------\nChecking if a job is scheduled\n------------------------------\n\nYou can check whether a specific job instance or job id is scheduled for\nexecution using the familiar python ``in`` operator\n\n.. code-block:: python\n\n    if job_instance in scheduler:\n        # Do something\n    # or\n    if job_id in scheduler:\n        # Do something\n\n---------------\nCanceling a job\n---------------\n\nTo cancel a job, simply pass a ``Job`` or a job id to ``scheduler.cancel``\n\n.. code-block:: python\n\n    scheduler.cancel(job)\n\nNote that this method returns ``None`` whether the specified job was found or not.\n\n---------------------\nRunning the scheduler\n---------------------\n\n`RQ Scheduler`_ comes with a script ``rqscheduler`` that runs a scheduler\nprocess that polls Redis once every minute and move scheduled jobs to the\nrelevant queues when they need to be executed\n\n.. code-block:: bash\n\n    # This runs a scheduler process using the default Redis connection\n    rqscheduler\n\nIf you want to use a different Redis server you could also do\n\n.. code-block:: bash\n\n    rqscheduler --host localhost --port 6379 --db 0\n\nThe script accepts these arguments:\n\n* ``-H`` or ``--host``: Redis server to connect to\n* ``-p`` or ``--port``: port to connect to\n* ``-d`` or ``--db``: Redis db to use\n* ``-P`` or ``--password``: password to connect to Redis\n* ``-b`` or ``--burst``: runs in burst mode (enqueue scheduled jobs whose execution time is in the past and quit)\n* ``-i INTERVAL`` or ``--interval INTERVAL``: How often the scheduler checks for new jobs to add to the queue (in seconds, can be floating-point for more precision).\n* ``-j`` or ``--job-class``: specify custom job class for rq to use (python module.Class)\n* ``-q`` or ``--queue-class``: specify custom queue class for rq to use (python module.Class)\n\nThe arguments pull default values from environment variables with the\nsame names but with a prefix of ``RQ_REDIS_``.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/as3445/rq-scheduler-bcfg", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "rq-scheduler-bcfg", "package_url": "https://pypi.org/project/rq-scheduler-bcfg/", "platform": "", "project_url": "https://pypi.org/project/rq-scheduler-bcfg/", "project_urls": {"Homepage": "https://github.com/as3445/rq-scheduler-bcfg"}, "release_url": "https://pypi.org/project/rq-scheduler-bcfg/0.8.4/", "requires_dist": null, "requires_python": "", "summary": "Provides job scheduling capabilities to RQ (Redis Queue)", "version": "0.8.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"rq-scheduler\">\n<h2>RQ Scheduler</h2>\n<p><a href=\"https://github.com/rq/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> is a small package that\nadds job scheduling capabilities to <a href=\"https://github.com/nvie/rq\" rel=\"nofollow\">RQ</a>,\na <a href=\"http://redis.io/\" rel=\"nofollow\">Redis</a> based Python queuing library.</p>\n<a href=\"https://travis-ci.org/rq/rq-scheduler\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/rq/rq-scheduler.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/37078634d390a116cdc0b1c37a7de9c2562fecf4/68747470733a2f2f7472617669732d63692e6f72672f72712f72712d7363686564756c65722e7376673f6272616e63683d6d6173746572\"></a>\n</div>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<ul>\n<li><a href=\"https://github.com/nvie/rq\" rel=\"nofollow\">RQ</a></li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>You can install <a href=\"https://github.com/rq/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> via pip:</p>\n<pre>pip install rq-scheduler\n</pre>\n<p>Or you can download the latest stable package from <a href=\"http://pypi.python.org/pypi/rq-scheduler\" rel=\"nofollow\">PyPI</a>.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Schedule a job involves doing two different things:</p>\n<ol>\n<li>Putting a job in the scheduler</li>\n<li>Running a scheduler that will move scheduled jobs into queues when the time comes</li>\n</ol>\n<div id=\"scheduling-a-job\">\n<h3>Scheduling a Job</h3>\n<p>There are two ways you can schedule a job. The first is using RQ Scheduler\u2019s <tt>enqueue_at</tt></p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">redis</span> <span class=\"kn\">import</span> <span class=\"n\">Redis</span>\n<span class=\"kn\">from</span> <span class=\"nn\">rq</span> <span class=\"kn\">import</span> <span class=\"n\">Queue</span>\n<span class=\"kn\">from</span> <span class=\"nn\">rq_scheduler</span> <span class=\"kn\">import</span> <span class=\"n\">Scheduler</span>\n<span class=\"kn\">from</span> <span class=\"nn\">datetime</span> <span class=\"kn\">import</span> <span class=\"n\">datetime</span>\n\n<span class=\"n\">scheduler</span> <span class=\"o\">=</span> <span class=\"n\">Scheduler</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"n\">Redis</span><span class=\"p\">())</span> <span class=\"c1\"># Get a scheduler for the \"default\" queue</span>\n\n<span class=\"c1\"># You can also instantiate a Scheduler using an RQ Queue</span>\n<span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">Queue</span><span class=\"p\">(</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"n\">Redis</span><span class=\"p\">())</span>\n<span class=\"n\">scheduler</span> <span class=\"o\">=</span> <span class=\"n\">Scheduler</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"o\">=</span><span class=\"n\">queue</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Puts a job into the scheduler. The API is similar to RQ except that it</span>\n<span class=\"c1\"># takes a datetime object as first argument. So for example to schedule a</span>\n<span class=\"c1\"># job to run on Jan 1st 2020 we do:</span>\n<span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">enqueue_at</span><span class=\"p\">(</span><span class=\"n\">datetime</span><span class=\"p\">(</span><span class=\"mi\">2020</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">func</span><span class=\"p\">)</span> <span class=\"c1\"># Date time should be in UTC</span>\n\n<span class=\"c1\"># Here's another example scheduling a job to run at a specific date and time (in UTC),</span>\n<span class=\"c1\"># complete with args and kwargs.</span>\n<span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">enqueue_at</span><span class=\"p\">(</span><span class=\"n\">datetime</span><span class=\"p\">(</span><span class=\"mi\">2020</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">),</span> <span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"o\">=</span><span class=\"n\">baz</span><span class=\"p\">)</span>\n</pre>\n<p>The second way is using <tt>enqueue_in</tt>. Instead of taking a <tt>datetime</tt> object,\nthis method expects a <tt>timedelta</tt> and schedules the job to run at\nX seconds/minutes/hours/days/weeks later. For example, if we want to monitor how\npopular a tweet is a few times during the course of the day, we could do something like</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">datetime</span> <span class=\"kn\">import</span> <span class=\"n\">timedelta</span>\n\n<span class=\"c1\"># Schedule a job to run 10 minutes, 1 hour and 1 day later</span>\n<span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">enqueue_in</span><span class=\"p\">(</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">minutes</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">),</span> <span class=\"n\">count_retweets</span><span class=\"p\">,</span> <span class=\"n\">tweet_id</span><span class=\"p\">)</span>\n<span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">enqueue_in</span><span class=\"p\">(</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">hours</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">count_retweets</span><span class=\"p\">,</span> <span class=\"n\">tweet_id</span><span class=\"p\">)</span>\n<span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">enqueue_in</span><span class=\"p\">(</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">days</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">count_retweets</span><span class=\"p\">,</span> <span class=\"n\">tweet_id</span><span class=\"p\">)</span>\n</pre>\n<p><strong>IMPORTANT</strong>: You should always use UTC datetime when working with <a href=\"https://github.com/rq/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a>.</p>\n</div>\n<div id=\"periodic-repeated-jobs\">\n<h3>Periodic &amp; Repeated Jobs</h3>\n<p>As of version 0.3, <a href=\"https://github.com/rq/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> also supports creating periodic and repeated jobs.\nYou can do this via the <tt>schedule</tt> method. Note that this feature needs\n<a href=\"https://github.com/nvie/rq\" rel=\"nofollow\">RQ</a> &gt;= 0.3.1.</p>\n<p>This is how you do it</p>\n<pre><span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">schedule</span><span class=\"p\">(</span>\n    <span class=\"n\">scheduled_time</span><span class=\"o\">=</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">utcnow</span><span class=\"p\">(),</span> <span class=\"c1\"># Time for first execution, in UTC timezone</span>\n    <span class=\"n\">func</span><span class=\"o\">=</span><span class=\"n\">func</span><span class=\"p\">,</span>                     <span class=\"c1\"># Function to be queued</span>\n    <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">arg1</span><span class=\"p\">,</span> <span class=\"n\">arg2</span><span class=\"p\">],</span>             <span class=\"c1\"># Arguments passed into function when executed</span>\n    <span class=\"n\">kwargs</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'bar'</span><span class=\"p\">},</span>         <span class=\"c1\"># Keyword arguments passed into function when executed</span>\n    <span class=\"n\">interval</span><span class=\"o\">=</span><span class=\"mi\">60</span><span class=\"p\">,</span>                   <span class=\"c1\"># Time before the function is called again, in seconds</span>\n    <span class=\"n\">repeat</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>                     <span class=\"c1\"># Repeat this number of times (None means repeat forever)</span>\n    <span class=\"n\">meta</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'bar'</span><span class=\"p\">}</span>            <span class=\"c1\"># Arbitrary pickleable data on the job itself</span>\n<span class=\"p\">)</span>\n</pre>\n<p><strong>IMPORTANT NOTE</strong>: If you set up a repeated job, you must make sure that you\neither do not set a <cite>result_ttl</cite> value or you set a value larger than the interval.\nOtherwise, the entry with the job details will expire and the job will not get re-scheduled.</p>\n</div>\n<div id=\"cron-jobs\">\n<h3>Cron Jobs</h3>\n<p>As of version 0.6.0, <a href=\"https://github.com/rq/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> also supports creating Cron Jobs, which you can use for\nrepeated jobs to run periodically at fixed times, dates or intervals, for more info check\n<a href=\"https://en.wikipedia.org/wiki/Cron\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Cron</a>. You can do this via the <tt>cron</tt> method.</p>\n<p>This is how you do it</p>\n<pre><span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">cron</span><span class=\"p\">(</span>\n    <span class=\"n\">cron_string</span><span class=\"p\">,</span>                <span class=\"c1\"># A cron string (e.g. \"0 0 * * 0\")</span>\n    <span class=\"n\">func</span><span class=\"o\">=</span><span class=\"n\">func</span><span class=\"p\">,</span>                  <span class=\"c1\"># Function to be queued</span>\n    <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">arg1</span><span class=\"p\">,</span> <span class=\"n\">arg2</span><span class=\"p\">],</span>          <span class=\"c1\"># Arguments passed into function when executed</span>\n    <span class=\"n\">kwargs</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'bar'</span><span class=\"p\">},</span>      <span class=\"c1\"># Keyword arguments passed into function when executed</span>\n    <span class=\"n\">repeat</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span>                  <span class=\"c1\"># Repeat this number of times (None means repeat forever)</span>\n    <span class=\"n\">queue_name</span><span class=\"o\">=</span><span class=\"n\">queue_name</span><span class=\"p\">,</span>      <span class=\"c1\"># In which queue the job should be put in</span>\n    <span class=\"n\">meta</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'bar'</span><span class=\"p\">}</span>         <span class=\"c1\"># Arbitrary pickleable data on the job itself</span>\n<span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"retrieving-scheduled-jobs\">\n<h3>Retrieving scheduled jobs</h3>\n<p>Sometimes you need to know which jobs have already been scheduled. You can get a\nlist of enqueued jobs with the <tt>get_jobs</tt> method</p>\n<pre><span class=\"n\">list_of_job_instances</span> <span class=\"o\">=</span> <span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">get_jobs</span><span class=\"p\">()</span>\n</pre>\n<p>In it\u2019s simplest form (as seen in the above example) this method returns a list\nof all job instances that are currently scheduled for execution.</p>\n<p>Additionally the method takes two optional keyword arguments <tt>until</tt> and\n<tt>with_times</tt>. The first one specifies up to which point in time scheduled jobs\nshould be returned. It can be given as either a datetime / timedelta instance\nor an integer denoting the number of seconds since epoch (1970-01-01 00:00:00).\nThe second argument is a boolen that determines whether the scheduled execution\ntime should be returned along with the job instances.</p>\n<p>Example</p>\n<pre><span class=\"c1\"># get all jobs until 2012-11-30 10:00:00</span>\n<span class=\"n\">list_of_job_instances</span> <span class=\"o\">=</span> <span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">get_jobs</span><span class=\"p\">(</span><span class=\"n\">until</span><span class=\"o\">=</span><span class=\"n\">datetime</span><span class=\"p\">(</span><span class=\"mi\">2012</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># get all jobs for the next hour</span>\n<span class=\"n\">list_of_job_instances</span> <span class=\"o\">=</span> <span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">get_jobs</span><span class=\"p\">(</span><span class=\"n\">until</span><span class=\"o\">=</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">hours</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># get all jobs with execution times</span>\n<span class=\"n\">jobs_and_times</span> <span class=\"o\">=</span> <span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">get_jobs</span><span class=\"p\">(</span><span class=\"n\">with_times</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"c1\"># returns a list of tuples:</span>\n<span class=\"c1\"># [(&lt;rq.job.Job object at 0x123456789&gt;, datetime.datetime(2012, 11, 25, 12, 30)), ...]</span>\n</pre>\n</div>\n<div id=\"checking-if-a-job-is-scheduled\">\n<h3>Checking if a job is scheduled</h3>\n<p>You can check whether a specific job instance or job id is scheduled for\nexecution using the familiar python <tt>in</tt> operator</p>\n<pre><span class=\"k\">if</span> <span class=\"n\">job_instance</span> <span class=\"ow\">in</span> <span class=\"n\">scheduler</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Do something</span>\n<span class=\"c1\"># or</span>\n<span class=\"k\">if</span> <span class=\"n\">job_id</span> <span class=\"ow\">in</span> <span class=\"n\">scheduler</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Do something</span>\n</pre>\n</div>\n<div id=\"canceling-a-job\">\n<h3>Canceling a job</h3>\n<p>To cancel a job, simply pass a <tt>Job</tt> or a job id to <tt>scheduler.cancel</tt></p>\n<pre><span class=\"n\">scheduler</span><span class=\"o\">.</span><span class=\"n\">cancel</span><span class=\"p\">(</span><span class=\"n\">job</span><span class=\"p\">)</span>\n</pre>\n<p>Note that this method returns <tt>None</tt> whether the specified job was found or not.</p>\n</div>\n<div id=\"running-the-scheduler\">\n<h3>Running the scheduler</h3>\n<p><a href=\"https://github.com/rq/rq-scheduler\" rel=\"nofollow\">RQ Scheduler</a> comes with a script <tt>rqscheduler</tt> that runs a scheduler\nprocess that polls Redis once every minute and move scheduled jobs to the\nrelevant queues when they need to be executed</p>\n<pre><span class=\"c1\"># This runs a scheduler process using the default Redis connection\n</span>rqscheduler\n</pre>\n<p>If you want to use a different Redis server you could also do</p>\n<pre>rqscheduler --host localhost --port <span class=\"m\">6379</span> --db <span class=\"m\">0</span>\n</pre>\n<p>The script accepts these arguments:</p>\n<ul>\n<li><tt><span class=\"pre\">-H</span></tt> or <tt><span class=\"pre\">--host</span></tt>: Redis server to connect to</li>\n<li><tt><span class=\"pre\">-p</span></tt> or <tt><span class=\"pre\">--port</span></tt>: port to connect to</li>\n<li><tt><span class=\"pre\">-d</span></tt> or <tt><span class=\"pre\">--db</span></tt>: Redis db to use</li>\n<li><tt><span class=\"pre\">-P</span></tt> or <tt><span class=\"pre\">--password</span></tt>: password to connect to Redis</li>\n<li><tt><span class=\"pre\">-b</span></tt> or <tt><span class=\"pre\">--burst</span></tt>: runs in burst mode (enqueue scheduled jobs whose execution time is in the past and quit)</li>\n<li><tt><span class=\"pre\">-i</span> INTERVAL</tt> or <tt><span class=\"pre\">--interval</span> INTERVAL</tt>: How often the scheduler checks for new jobs to add to the queue (in seconds, can be floating-point for more precision).</li>\n<li><tt><span class=\"pre\">-j</span></tt> or <tt><span class=\"pre\">--job-class</span></tt>: specify custom job class for rq to use (python module.Class)</li>\n<li><tt><span class=\"pre\">-q</span></tt> or <tt><span class=\"pre\">--queue-class</span></tt>: specify custom queue class for rq to use (python module.Class)</li>\n</ul>\n<p>The arguments pull default values from environment variables with the\nsame names but with a prefix of <tt>RQ_REDIS_</tt>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3877166, "releases": {"0.8.4": [{"comment_text": "", "digests": {"md5": "c250eaa8b8c91619d974b6b1fe632264", "sha256": "92244fbc4a1414933d0973f998ae17920c1284e483622b7f5874813a34c237b8"}, "downloads": -1, "filename": "rq-scheduler-bcfg-0.8.4.tar.gz", "has_sig": false, "md5_digest": "c250eaa8b8c91619d974b6b1fe632264", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11073, "upload_time": "2018-05-18T18:13:10", "upload_time_iso_8601": "2018-05-18T18:13:10.176042Z", "url": "https://files.pythonhosted.org/packages/f1/9b/2404ea0206f60f345c789332838591959bfbbc0365d6927d3f52129ecb73/rq-scheduler-bcfg-0.8.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c250eaa8b8c91619d974b6b1fe632264", "sha256": "92244fbc4a1414933d0973f998ae17920c1284e483622b7f5874813a34c237b8"}, "downloads": -1, "filename": "rq-scheduler-bcfg-0.8.4.tar.gz", "has_sig": false, "md5_digest": "c250eaa8b8c91619d974b6b1fe632264", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11073, "upload_time": "2018-05-18T18:13:10", "upload_time_iso_8601": "2018-05-18T18:13:10.176042Z", "url": "https://files.pythonhosted.org/packages/f1/9b/2404ea0206f60f345c789332838591959bfbbc0365d6927d3f52129ecb73/rq-scheduler-bcfg-0.8.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:46 2020"}