{"info": {"author": "Jan Max Meyer", "author_email": "info@pynetree.org", "bugtrack_url": null, "classifiers": [], "description": "**pynetree**: *A light-weight parsing toolkit written in pure Python*\n\n\nAbout\n=====\n\n**pynetree** is both a Python library and a command-line utility for\nparsing.\n\nParsing is the process of transferring input matching a particular\ngrammar, like e.g. a program source code, into a well-formed data\nstructure. This data structure is a so called abstract syntax tree\n(AST). pynetree is a tool doing all this for you: It takes a grammar\ndescription, runs a parser on provided input and generates the abstract\nsyntax tree on a successful parse. This AST can than be taken to perform\nsubsequent tasks, like writing an interpreter, compiler or any other\nkind of software requiring a parser.\n\nThe following Python example using pynetree defines a simple\ntwo-function calculator as an expression language, runs a parser on it,\nand dumps out the generated abstract syntax tree.\n\n.. code:: python\n\n    import pynetree\n\n    p = pynetree.Parser(\"\"\"\n        %skip /\\s+/;\n        @int /\\d+/;\n\n        factor: int | '(' expr ')';\n\n        @mul: term '*' factor;\n        term: mul | factor;\n\n        @add: expr '+' term;\n        expr$: add | term;\n    \"\"\")\n\n    p.parse(\"1 + 2 * ( 3 + 4 ) * 5\").dump()\n\nWhen this program is run from a console, a proper abstract syntax tree\nwill be generated and printed, which shows the hierarchical structure of\nthe parsed expression.\n\n::\n\n    add\n     int (1)\n     div\n      mul\n       int (2)\n       add\n        int (3)\n        int (4)\n      int (5)\n\npynetree also provides a handy command-line tool to rapidly prototype\ngrammars. The next command just generates the same parser as the example\nprogram from above.\n\n::\n\n    $ pynetree \"@int /[0-9]+/; f: int | '(' e ')'; t: @mul( t '*' f ) | f; e: @add( e '+' t ) | t;\"\n\nRequirements\n============\n\npynetree is written in pure Python. It runs natively with any Python >=\n2.5.\n\nThe only import done so far is the build-in ``re`` module for regular\nexpression support. Nothing more is required!\n\nFeatures\n========\n\npynetree so far provides\n\n-  A top-down packrat parser with support of direct and indirect left\n   recursive grammars.\n-  Mostly linear parsing time, even for left-recursive grammars due a\n   powerful memorization algorithm.\n-  Grammars can be expressed as dict objects or by a BNF-grammar.\n-  Support functions for generating and traversing abstract syntax trees\n   (AST).\n-  Lexical analysis can be performed via regular expressions (re),\n   string or by Python callables.\n\nPlease check out http://pynetree.org to get help and the newest updates\non the pynetree project.\n\nThe pynetree project is under heavy development, so that changes in API,\nfunction names, syntax or semantics may occur and need existing projects\nto be ported.\n\nIt has been developed in the course of implementing a top-down parser\nsupporting left-recursive grammars. Therefore, pynetree is a parser that\nimplements a modified version of the packrat parsing algorithm, but with\nthe approach to provide true BNF-styled grammars, as known from other\nparser development tools and frameworks.\n\nGetting started\n===============\n\npynetree is not a parser generator in classic terms like yacc or bison.\nIt can be seen as a library to directly express and parse the desired\ngrammar within Python code.\n\nCommand-line interface\n----------------------\n\nNevertheless, a command-line interface is provided for rapidly grammar\nprototyping and testing.\n\n::\n\n    usage: pynetree.py [-h] [-d] [-v] [-V] grammar [input [input ...]]\n\n    pynetree - a light-weight parsing toolkit written in Python.\n\n    positional arguments:\n      grammar        Grammar to create a parser from.\n      input          Input to be processed by the parser.\n\n    optional arguments:\n      -h, --help     show this help message and exit\n      -d, --debug    Verbose, and print debug output\n      -v, --verbose  Print processing information during run\n      -V, --version  show program's version number and exit\n\n    'grammar' and 'input' can be either supplied as strings or files.\n\nUsing it as a library\n---------------------\n\nFor using pynetree in a Python script, it simply is required to create\nan object of the class ``pynetree.Parser``.\n\nThe Parser class requires a BNF-grammar to describe the language that\nshall be parsed as parameter. This grammar can be expressed in two\ndifferent ways:\n\n1. As dict specifying the non-terminals as keys and their left-hand\n   sides as the values (where the left-hand sides can be provided as\n   list of strings). This requires much more configuration on the\n   parsers token and emitting behavior, but is the Python-specific way.\n\n2. The other, more flexible method for specifying a grammar is\n   pynetree's own grammar definition language, which itself internally\n   is implemented using pynetree.\n\n   This language is oriented on the classic BNF-style, but supports\n   several syntactical elements to quickly define a language and its\n   behavior for token definition and abstract syntax tree (AST)\n   construction.\n\nAfter the grammar is generally defined, the parser can be fine-tuned or\nextended to various features.\n\n-  ``pynetree.Parser.token()`` is used to define named terminal symbols,\n   which can be regular expression patterns, static strings or\n   callables.\n-  ``pynetree.Parser.ignore()`` is used for the definition of whitespace\n   tokens, which are generally allowed between all other tokens.\n-  ``pynetree.Parser.emit()`` is used to define symbols (both\n   non-terminal or terminal) that are emitted as nodes in AST. Terminal\n   symbols will always define leafs in the AST, where non-terminals can\n   emit leafs if no sub-ordered symbols are emitted. (In a full parse\n   tree, non-terminals will never be leafs, but nodes).\n\nThe final parsing of a string is performed by the function\n``Parser.parse()``. This function returns the AST for the parsed input.\nAST are consisting of ``pynetree.Node`` objects or - in case of a\nsequence of multiple elements in the same level - lists of\n``pynetree.Node`` objects.\n\nTo walk on such an AST, the function ``pynetree.Node.dump()`` can be\nused to print the AST in a well-formatted style, or\n``pynetree.Parser.traverse()`` to possible call emitting functions on\nevery node. It is also helpful to use these functions as templates for\nother, more specialized tree traversal and walker functions.\n\n-  ``pynetree.Parser.parse()`` parses an input string on the given\n   grammar and returns and AST. The AST is represented as a hierarchy of\n   ``pynetree.Node`` objects.\n-  ``pynetree.Node.dump()`` allows for dumping ASTs returned by\n   ``pynetree.Parser.parse()`` in a well-formed style.\n-  ``pynetree.Parser.traverse()`` walks along an abstract syntax tree\n   generated by ``pynetree.Parser.parse()``, and performs function calls\n   to perform top-down, pass-by and bottom-up tree traversal\n   possibilities.\n\nWhen higher AST traversal features are required for a pynetree parser,\nit is recommended to sub-class ``pynetree.Parser`` into a more specific\nclass, serving as some kind of compiler or interpreter, like this\nexample:\n\n.. code:: python\n\n    import pynetree\n\n    class Calculator(pynetree.Parser):\n        stack = []\n\n        def __init__(self):\n            super(Calculator, self).__init__(\n                \"\"\"\n                %ignore /\\s+/;\n                @INT    /\\d+/;\n\n                f:      INT | '(' e ')';\n\n                @mul:   t \"*\" f;\n                @div:   t \"/\" f;\n                t:      mul | div | f;\n\n                @add:   e \"+\" t;\n                @sub:   e \"-\" t;\n                e:      add | sub | t;\n\n                @calc$: e;\n                \"\"\")\n\n        def post_INT(self, node):\n            self.stack.append(float(node.match))\n\n        def post_add(self, node):\n            self.stack.append(self.stack.pop() + self.stack.pop())\n\n        def post_sub(self, node):\n            x = self.stack.pop()\n            self.stack.append(self.stack.pop() - x)\n\n        def post_mul(self, node):\n            self.stack.append(self.stack.pop() * self.stack.pop())\n\n        def post_div(self, node):\n            x = self.stack.pop()\n            self.stack.append(self.stack.pop() / x)\n\n        def post_calc(self, node):\n            print(self.stack.pop())\n\n    c = Calculator()\n    c.traverse(c.parse(\"1337 - 42 + 23\"))\n\nPlease do also take a look at the many examples provided with pynetree\nto get familiar with these functions and possibilities.\n\nAuthor\n======\n\npynetree is developed and maintained by Jan Max Meyer, Phorward Software\nTechnologies.\n\nIt is the result of a several years experience in parser development\ntools, and is currently worked out as some kind of sister-project of the\n`Phorward Toolkit/libphorward <https://github.com/phorward/phorward>`__,\na parsing a lexical analysis toolkit implementing LR/LALR parsers and\nfocusing on the C programming language. Therefore, the BNF-styled\ngrammar definition language of both pynetree and libphorward are similar\nand provide the same interface for both parser development tools.\n\nLicense\n=======\n\nCopyright (C) 2015-2017 by Jan Max Meyer, Phorward Software\nTechnologies.\n\nYou may use, modify and distribute this software under the terms and\nconditions of the MIT license. The full license terms are provided in\nthe LICENSE file.\n\nTHIS SOFTWARE IS PROVIDED BY JAN MAX MEYER (PHORWARD SOFTWARE\nTECHNOLOGIES) AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\nBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JAN\nMAX MEYER (PHORWARD SOFTWARE TECHNOLOGIES) BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pynetree.org", "keywords": "parsing parser parse packrat left-recursive ast syntax compiler", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pynetree", "package_url": "https://pypi.org/project/pynetree/", "platform": "", "project_url": "https://pypi.org/project/pynetree/", "project_urls": {"Homepage": "http://pynetree.org"}, "release_url": "https://pypi.org/project/pynetree/0.6/", "requires_dist": null, "requires_python": "", "summary": "A light-weight parsing toolkit written in pure Python.", "version": "0.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><strong>pynetree</strong>: <em>A light-weight parsing toolkit written in pure Python</em></p>\n<div id=\"about\">\n<h2>About</h2>\n<p><strong>pynetree</strong> is both a Python library and a command-line utility for\nparsing.</p>\n<p>Parsing is the process of transferring input matching a particular\ngrammar, like e.g. a program source code, into a well-formed data\nstructure. This data structure is a so called abstract syntax tree\n(AST). pynetree is a tool doing all this for you: It takes a grammar\ndescription, runs a parser on provided input and generates the abstract\nsyntax tree on a successful parse. This AST can than be taken to perform\nsubsequent tasks, like writing an interpreter, compiler or any other\nkind of software requiring a parser.</p>\n<p>The following Python example using pynetree defines a simple\ntwo-function calculator as an expression language, runs a parser on it,\nand dumps out the generated abstract syntax tree.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pynetree</span>\n\n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">pynetree</span><span class=\"o\">.</span><span class=\"n\">Parser</span><span class=\"p\">(</span><span class=\"s2\">\"\"\"\n    </span><span class=\"si\">%s</span><span class=\"s2\">kip /\\s+/;\n    @int /\\d+/;\n\n    factor: int | '(' expr ')';\n\n    @mul: term '*' factor;\n    term: mul | factor;\n\n    @add: expr '+' term;\n    expr$: add | term;\n\"\"\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"1 + 2 * ( 3 + 4 ) * 5\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n</pre>\n<p>When this program is run from a console, a proper abstract syntax tree\nwill be generated and printed, which shows the hierarchical structure of\nthe parsed expression.</p>\n<pre>add\n int (1)\n div\n  mul\n   int (2)\n   add\n    int (3)\n    int (4)\n  int (5)\n</pre>\n<p>pynetree also provides a handy command-line tool to rapidly prototype\ngrammars. The next command just generates the same parser as the example\nprogram from above.</p>\n<pre>$ pynetree \"@int /[0-9]+/; f: int | '(' e ')'; t: @mul( t '*' f ) | f; e: @add( e '+' t ) | t;\"\n</pre>\n</div>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<p>pynetree is written in pure Python. It runs natively with any Python &gt;=\n2.5.</p>\n<p>The only import done so far is the build-in <tt>re</tt> module for regular\nexpression support. Nothing more is required!</p>\n</div>\n<div id=\"features\">\n<h2>Features</h2>\n<p>pynetree so far provides</p>\n<ul>\n<li>A top-down packrat parser with support of direct and indirect left\nrecursive grammars.</li>\n<li>Mostly linear parsing time, even for left-recursive grammars due a\npowerful memorization algorithm.</li>\n<li>Grammars can be expressed as dict objects or by a BNF-grammar.</li>\n<li>Support functions for generating and traversing abstract syntax trees\n(AST).</li>\n<li>Lexical analysis can be performed via regular expressions (re),\nstring or by Python callables.</li>\n</ul>\n<p>Please check out <a href=\"http://pynetree.org\" rel=\"nofollow\">http://pynetree.org</a> to get help and the newest updates\non the pynetree project.</p>\n<p>The pynetree project is under heavy development, so that changes in API,\nfunction names, syntax or semantics may occur and need existing projects\nto be ported.</p>\n<p>It has been developed in the course of implementing a top-down parser\nsupporting left-recursive grammars. Therefore, pynetree is a parser that\nimplements a modified version of the packrat parsing algorithm, but with\nthe approach to provide true BNF-styled grammars, as known from other\nparser development tools and frameworks.</p>\n</div>\n<div id=\"getting-started\">\n<h2>Getting started</h2>\n<p>pynetree is not a parser generator in classic terms like yacc or bison.\nIt can be seen as a library to directly express and parse the desired\ngrammar within Python code.</p>\n<div id=\"command-line-interface\">\n<h3>Command-line interface</h3>\n<p>Nevertheless, a command-line interface is provided for rapidly grammar\nprototyping and testing.</p>\n<pre>usage: pynetree.py [-h] [-d] [-v] [-V] grammar [input [input ...]]\n\npynetree - a light-weight parsing toolkit written in Python.\n\npositional arguments:\n  grammar        Grammar to create a parser from.\n  input          Input to be processed by the parser.\n\noptional arguments:\n  -h, --help     show this help message and exit\n  -d, --debug    Verbose, and print debug output\n  -v, --verbose  Print processing information during run\n  -V, --version  show program's version number and exit\n\n'grammar' and 'input' can be either supplied as strings or files.\n</pre>\n</div>\n<div id=\"using-it-as-a-library\">\n<h3>Using it as a library</h3>\n<p>For using pynetree in a Python script, it simply is required to create\nan object of the class <tt>pynetree.Parser</tt>.</p>\n<p>The Parser class requires a BNF-grammar to describe the language that\nshall be parsed as parameter. This grammar can be expressed in two\ndifferent ways:</p>\n<ol>\n<li><p>As dict specifying the non-terminals as keys and their left-hand\nsides as the values (where the left-hand sides can be provided as\nlist of strings). This requires much more configuration on the\nparsers token and emitting behavior, but is the Python-specific way.</p>\n</li>\n<li><p>The other, more flexible method for specifying a grammar is\npynetree\u2019s own grammar definition language, which itself internally\nis implemented using pynetree.</p>\n<p>This language is oriented on the classic BNF-style, but supports\nseveral syntactical elements to quickly define a language and its\nbehavior for token definition and abstract syntax tree (AST)\nconstruction.</p>\n</li>\n</ol>\n<p>After the grammar is generally defined, the parser can be fine-tuned or\nextended to various features.</p>\n<ul>\n<li><tt>pynetree.Parser.token()</tt> is used to define named terminal symbols,\nwhich can be regular expression patterns, static strings or\ncallables.</li>\n<li><tt>pynetree.Parser.ignore()</tt> is used for the definition of whitespace\ntokens, which are generally allowed between all other tokens.</li>\n<li><tt>pynetree.Parser.emit()</tt> is used to define symbols (both\nnon-terminal or terminal) that are emitted as nodes in AST. Terminal\nsymbols will always define leafs in the AST, where non-terminals can\nemit leafs if no sub-ordered symbols are emitted. (In a full parse\ntree, non-terminals will never be leafs, but nodes).</li>\n</ul>\n<p>The final parsing of a string is performed by the function\n<tt>Parser.parse()</tt>. This function returns the AST for the parsed input.\nAST are consisting of <tt>pynetree.Node</tt> objects or - in case of a\nsequence of multiple elements in the same level - lists of\n<tt>pynetree.Node</tt> objects.</p>\n<p>To walk on such an AST, the function <tt>pynetree.Node.dump()</tt> can be\nused to print the AST in a well-formatted style, or\n<tt>pynetree.Parser.traverse()</tt> to possible call emitting functions on\nevery node. It is also helpful to use these functions as templates for\nother, more specialized tree traversal and walker functions.</p>\n<ul>\n<li><tt>pynetree.Parser.parse()</tt> parses an input string on the given\ngrammar and returns and AST. The AST is represented as a hierarchy of\n<tt>pynetree.Node</tt> objects.</li>\n<li><tt>pynetree.Node.dump()</tt> allows for dumping ASTs returned by\n<tt>pynetree.Parser.parse()</tt> in a well-formed style.</li>\n<li><tt>pynetree.Parser.traverse()</tt> walks along an abstract syntax tree\ngenerated by <tt>pynetree.Parser.parse()</tt>, and performs function calls\nto perform top-down, pass-by and bottom-up tree traversal\npossibilities.</li>\n</ul>\n<p>When higher AST traversal features are required for a pynetree parser,\nit is recommended to sub-class <tt>pynetree.Parser</tt> into a more specific\nclass, serving as some kind of compiler or interpreter, like this\nexample:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pynetree</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Calculator</span><span class=\"p\">(</span><span class=\"n\">pynetree</span><span class=\"o\">.</span><span class=\"n\">Parser</span><span class=\"p\">):</span>\n    <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">Calculator</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span>\n            <span class=\"sd\">\"\"\"\n            %ignore /\\s+/;\n            @INT    /\\d+/;\n\n            f:      INT | '(' e ')';\n\n            @mul:   t \"*\" f;\n            @div:   t \"/\" f;\n            t:      mul | div | f;\n\n            @add:   e \"+\" t;\n            @sub:   e \"-\" t;\n            e:      add | sub | t;\n\n            @calc$: e;\n            \"\"\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">post_INT</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">post_add</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">())</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">post_sub</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">post_mul</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">())</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">post_div</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span> <span class=\"o\">/</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">post_calc</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">())</span>\n\n<span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Calculator</span><span class=\"p\">()</span>\n<span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">traverse</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"1337 - 42 + 23\"</span><span class=\"p\">))</span>\n</pre>\n<p>Please do also take a look at the many examples provided with pynetree\nto get familiar with these functions and possibilities.</p>\n</div>\n</div>\n<div id=\"author\">\n<h2>Author</h2>\n<p>pynetree is developed and maintained by Jan Max Meyer, Phorward Software\nTechnologies.</p>\n<p>It is the result of a several years experience in parser development\ntools, and is currently worked out as some kind of sister-project of the\n<a href=\"https://github.com/phorward/phorward\" rel=\"nofollow\">Phorward Toolkit/libphorward</a>,\na parsing a lexical analysis toolkit implementing LR/LALR parsers and\nfocusing on the C programming language. Therefore, the BNF-styled\ngrammar definition language of both pynetree and libphorward are similar\nand provide the same interface for both parser development tools.</p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>Copyright (C) 2015-2017 by Jan Max Meyer, Phorward Software\nTechnologies.</p>\n<p>You may use, modify and distribute this software under the terms and\nconditions of the MIT license. The full license terms are provided in\nthe LICENSE file.</p>\n<p>THIS SOFTWARE IS PROVIDED BY JAN MAX MEYER (PHORWARD SOFTWARE\nTECHNOLOGIES) AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\nBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JAN\nMAX MEYER (PHORWARD SOFTWARE TECHNOLOGIES) BE LIABLE FOR ANY DIRECT,\nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.</p>\n</div>\n\n          </div>"}, "last_serial": 3069202, "releases": {"0.5.0": [{"comment_text": "", "digests": {"md5": "52ae98b2eae4be34733efe21d64add6c", "sha256": "a356c3e7d0fc0b3f824673114870bcdf192e280601b794cc69e608e81581105e"}, "downloads": -1, "filename": "pynetree-0.5.0.tar.gz", "has_sig": false, "md5_digest": "52ae98b2eae4be34733efe21d64add6c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11497, "upload_time": "2017-08-02T12:50:17", "upload_time_iso_8601": "2017-08-02T12:50:17.131169Z", "url": "https://files.pythonhosted.org/packages/0c/1c/fcb30b9ac85f0991f1af94a3a7869044222429e5c7555f590fbe80826164/pynetree-0.5.0.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "4060a96c86d688290201e72c0e1a8dc3", "sha256": "242303ab5b3cbcf0829acce30110f14942bc8a301446c3143933225eec48968e"}, "downloads": -1, "filename": "pynetree-0.5.2.tar.gz", "has_sig": false, "md5_digest": "4060a96c86d688290201e72c0e1a8dc3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12521, "upload_time": "2017-08-02T13:07:28", "upload_time_iso_8601": "2017-08-02T13:07:28.241132Z", "url": "https://files.pythonhosted.org/packages/d8/5d/7fcf43cd05fb93698b36ccfd4d09bff3d5edf9133f7fec33f481af25e2e2/pynetree-0.5.2.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "345f6281198b2b226ab0eb50ce698fe7", "sha256": "78477c33a06d88fcc43877265e28ab109fdde7e9bf3947bf80d795f4303e98db"}, "downloads": -1, "filename": "pynetree-0.6.tar.gz", "has_sig": false, "md5_digest": "345f6281198b2b226ab0eb50ce698fe7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12472, "upload_time": "2017-08-03T08:43:27", "upload_time_iso_8601": "2017-08-03T08:43:27.723522Z", "url": "https://files.pythonhosted.org/packages/c2/04/5bfcc77e808d348679aa3a04e8255edbdd79fb5acd93ef499b918d660b22/pynetree-0.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "345f6281198b2b226ab0eb50ce698fe7", "sha256": "78477c33a06d88fcc43877265e28ab109fdde7e9bf3947bf80d795f4303e98db"}, "downloads": -1, "filename": "pynetree-0.6.tar.gz", "has_sig": false, "md5_digest": "345f6281198b2b226ab0eb50ce698fe7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12472, "upload_time": "2017-08-03T08:43:27", "upload_time_iso_8601": "2017-08-03T08:43:27.723522Z", "url": "https://files.pythonhosted.org/packages/c2/04/5bfcc77e808d348679aa3a04e8255edbdd79fb5acd93ef499b918d660b22/pynetree-0.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:01:16 2020"}