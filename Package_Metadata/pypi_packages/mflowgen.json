{"info": {"author": "Christopher Torng", "author_email": "clt67@cornell.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "License :: OSI Approved :: BSD License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3 :: Only", "Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)", "Topic :: Software Development :: Build Tools"], "description": "mflowgen\n==========================================================================\n[![Documentation Status](https://readthedocs.org/projects/mflowgen/badge/?version=latest)](https://mflowgen.readthedocs.io/en/latest) [![Build Status](https://travis-ci.com/cornell-brg/mflowgen.svg?branch=master)](https://travis-ci.com/cornell-brg/mflowgen)\n\n**Author**: Christopher Torng (clt67@cornell.edu)\n\nmflowgen is a modular flow specification and build-system\ngenerator for ASIC and FPGA design-space exploration built around\nsandboxed and modular steps.\n\nmflowgen allows you to programmatically define and parameterize a graph\nof steps (i.e., sandboxes that run anything you like) with\nwell-defined inputs and outputs. Build system files (e.g., make,\nninja) are then generated which shuttle files between steps before\nrunning them.\n\n<img width='350px' src='docs/_static/images/example-graph.jpg'>\n\nKey features and design philosophies:\n\n- **Process and technology independence** -- Process technology\n  libraries and variables can be abstracted and separated from\n  physical design scripts. Specifically, a single node called the\n  ASIC design kit (ADK) captures this material in one place for\n  better maintainability and access control.\n\n- **Sandboxed and modular steps** -- Traditional ASIC flows are\n  composed of many steps executing with fixed path dependencies. The\n  resulting flows have low reusability across designs and technology\n  nodes and can be confusing and monolithic. In contrast,\n  _modularity_ encourages reuse of the same scripts across many\n  projects, while _sandboxing_ makes each step self-contained and\n  also makes the role of each step easy to understand (i.e., take\n  these inputs and generate those outputs).\n\n- **Programmatically defined build-system generator**: A\n  Python-based scripting interface and a simple graph API allows\n  flexible connection and disconnection of edges, insertion and\n  removal of steps, and parameter space expansions. A simple graph\n  can be specified for a quick synthesis and place-and-route spin,\n  or a more complex graph can be built for a more aggressive chip\n  tapeout (reusing many of the same steps from before).\n\n- **A focus on hardware design-space exploration** -- Parameter\n  expansion can be applied to steps to quickly spin out parallel\n  builds for design-space exploration at both smaller scales with a\n  single parameter (e.g., sweeping clock targets) as well as at\n  larger scales with multiple parameters (e.g., to characterize the\n  area-energy tradeoff space of a new architectural widget with\n  different knobs). Dependent files are shuttled to each sandbox\n  as needed.\n\n- **Complete freedom in defining what steps do** -- Aside from\n  exposing precisely what the inputs and outputs are, no other\n  restrictions are placed on what steps do and a step can be as\n  simple as hello world (one line). A step may conduct an analysis\n  pass and report a gate count. A step can also apply a transform\n  pass to a netlist before passing it to other tools. In addition, a\n  step can even instantiate a subgraph to implement a hierarchical\n  flow.\n\nmflowgen ships with a limited set of ASIC flow scripts for both\nopen-source and commercial tools including synthesis (e.g., Synopsys\nDC, yosys), place and route (e.g., Cadence Innovus Foundation Flow,\nRePlAce, graywolf, qrouter), and signoff (e.g., Synopsys PTPX,\nMentor Calibre). In addition, we include an open-source 45nm ASIC design\nkit (ADK) assembled from FreePDK45 version 1.4 and the NanGate Open\nCell Library.\n\nMore info can be found in the\n[documentation](https://mflowgen.readthedocs.io/en/latest).\n\n--------------------------------------------------------------------------\nLicense\n--------------------------------------------------------------------------\n\nmflowgen is offered under the terms of the Open Source Initiative BSD\n3-Clause License. More information about this license can be found\nhere:\n\n- http://choosealicense.com/licenses/bsd-3-clause\n- http://opensource.org/licenses/BSD-3-Clause\n\n--------------------------------------------------------------------------\nQuick Start\n--------------------------------------------------------------------------\n\nThis repo includes a small Verilog design that computes a greatest\ncommon divisor function. You can use this design to demo the ASIC\nflow with open-source tools. This section steps through how to clone\nthe repo and push this design through synthesis, place, and route\nusing the included open-source 45nm ASIC design kit (ADK), assuming\nthe open-source tools are available.\n\nClone the repo:\n\n    % git clone https://github.com/cornell-brg/mflowgen\n    % cd mflowgen\n    % TOP=${PWD}\n\nInstall mflowgen with pip as an editable repo:\n\n    % pip install -e .\n\nThe example design is a greatest-common divisor circuit in RTL. We\nhave created three demo graphs for this design in\n`$TOP/designs/GcdUnit`: (1) `construct-open.py` uses an open-source\n45nm ASIC toolflow based on FreePDK45 and the NanGate Open Cell\nLibrary; (2) `construct-commercial.py` uses a commercial toolflow\nbased on Synopsys, Cadence, and Mentor tools; and (3)\n`construct-commercial-full.py` expands this commercial toolflow for\ngreater observability.  **Note**: To try different graphs, open\n`$TOP/designs/GcdUnit/.mflowgen.yml` and specify one of the three\nchoices. The remainder of this quickstart will assume you have\nmodified this file to choose the open-source toolflow.\n\n    % cd $TOP\n    % mkdir build && cd build\n    % mflowgen run --design ../designs/GcdUnit\n\nYou can show information about the currently configured flow:\n\n    % make info      # <-- shows which design is being targeted\n    % make list      # <-- shows most things you can do\n    % make status    # <-- prints the build status of each step\n    % make graph     # <-- dumps a graphviz PDF of the configured flow\n\nNow run synthesis and check the outputs of the sandbox to inspect\nthe area report. **Note**: For the commercial flow, check `make\nlist` for the build target name.\n\n    % make open-yosys-synthesis\n    % cat *-open-yosys-synthesis/outputs/synth.stats.txt\n\nYou can also run steps using the number from `make list`:\n\n    % make list      # <-- 3 : open-yosys-synthesis\n    % make 3\n\nThe yosys area report will look something like this:\n\n    === GcdUnit ===\n\n       Number of wires:                406\n       Number of wire bits:           1011\n       Number of public wires:         406\n       Number of public wire bits:    1011\n       Number of memories:               0\n       Number of memory bits:            0\n       Number of processes:              0\n       Number of cells:                941\n         AOI211_X1                       3\n         AOI21_X1                       34\n         AOI22_X1                       30\n         BUF_X1                        626\n         CLKBUF_X1                       5\n         DFF_X1                         34\n         INV_X1                         48\n         NAND2_X1                       42\n         NAND3_X1                        3\n         NOR2_X1                        34\n         NOR3_X1                         3\n         NOR4_X1                         4\n         OAI211_X1                       1\n         OAI21_X1                       40\n         OAI221_X1                       1\n         OAI22_X1                        2\n         OR2_X1                          1\n         XNOR2_X1                       18\n         XOR2_X1                        12\n\n       Chip area for this module: 932.330000\n\nReport runtimes to check how long each step has taken:\n\n    % make runtimes\n\nThen run place-and-route (requires graywolf and qrouter):\n\n    % make open-graywolf-place\n    % make open-qrouter-route\n\n--------------------------------------------------------------------------\nOrganization\n--------------------------------------------------------------------------\n\nThe repository is organized at the top level with directories for\nthe ADKs, designs, and steps (and utility scripts):\n\n```\nmflowgen/\n\u2502\n\u251c\u2500\u2500 adks/      -- Each subdirectory is for an ADK\n\u251c\u2500\u2500 designs/   -- Each subdirectory is for a design (can be a cloned repo)\n\u251c\u2500\u2500 steps/     -- Collection of generic steps\n\u2502\n\u2502\u2500\u2500 mflowgen/  -- Source files for the mflowgen Python API\n\u2502\u2500\u2500 utils/     -- Helper scripts\n\u2514\u2500\u2500 configure  -- Config script to select a design\n```\n\nDesigns include the graph specification, the source code, and any\ndesign-specific steps.\n\nNew designs are meant to be cloned into (or symlinked into) the\ndesigns subdirectory for easy access when configuring with `--design`.\n\n--------------------------------------------------------------------------\nFeature in Detail: Process and Technology Independence\n--------------------------------------------------------------------------\n\nThe ASIC Design Kit (ADK) is a standard interface to all process\ntechnology libraries and variables used across all ASIC scripts in\nthe tool flow. The ADK interface remains constant regardless of\nwhere the actual packages and IP libraries are downloaded and how\nthey are organized. The ADK may include process technology files,\nphysical IP libraries (e.g., IO cells, standard cells, memory\ncompilers), as well as physical verification decks (e.g., Calibre\nDRC/LVS).\n\nmflowgen ships with an open-source 45nm ADK assembled from FreePDK45\nversion 1.4 and the NanGate Open Cell Library. We place all kits and\nlibraries into the directory `adks/freepdk-45nm/pkgs` in a\nrelatively unorganized manner (just untar them). We then create\ndifferent \"views\" into these packages for different purposes (e.g.,\nfront-end only, targeting open-source toolchains, targeting\ncommercial toolchains) by creating subdirectories with different\nsets of symlinks to the vendor files.\n\nHere is the \"view-tiny\" interface to the 45nm ADK containing only\nthe files needed by the open-source ASIC flow tools:\n\n```\nadk.tcl                     -- ADK variables setup script\n\nrtk-tech.info               -- Qflow tech file\nrtk-tech.lef                -- Routing tech kit LEF\nrtk-tech.par                -- Graywolf tech file\n\nstdcells.gds                -- Standard cell library GDS\nstdcells.lef                -- Standard cell library LEF\nstdcells.lib                -- Standard cell library typical Liberty\nstdcells.v                  -- Standard cell library Verilog\n```\n\n**Note**: The `adk.tcl` encapsulates the ADK interface for\nvariables. Any information specific to this ADK goes here (e.g., the\nlist of filler cells, min/max routing metal layers).\n\nThe \"view-standard\" interface for the same 45nm ADK has more entries\nand targets commercial ASIC flow tools. This interface is useful for\narchitectural design-space exploration of block-level designs. Note\nthat we conserve repository space by downloading this view from\nonline at build time:\n\n```\nadk.tcl                     -- ADK variables setup script\n\nrtk-max.tluplus             -- Interconnect parasitics (max timing)\nrtk-min.tluplus             -- Interconnect parasitics (min timing)\nrtk-typical.captable        -- Interconnect parasitics (typical)\nrtk-tech.lef                -- Routing tech kit LEF\nrtk-tech.tf                 -- Routing tech kit Milkyway techfile\nrtk-tluplus.map             -- Routing tech kit TLUPlus map\nrtk-stream-out.map          -- Stream-out layer map for final GDS\n\nstdcells.gds                -- Standard cell library GDS\nstdcells.db                 -- Standard cell library typical DB\nstdcells.lef                -- Standard cell library LEF\nstdcells.lib                -- Standard cell library typical Liberty\nstdcells.mwlib              -- Standard cell library Milkyway\nstdcells.v                  -- Standard cell library Verilog\nstdcells.cdl                -- Standard cell library LVS spice\nstdcells-lpe.spi            -- Standard cell library extracted spice\n\ncalibre-drc-block.rule      -- Calibre DRC ruledeck\ncalibre-lvs.rule            -- Calibre LVS ruledeck\n```\n\nHere is a more complete and general-purpose ADK interface that might\ntarget a chip tapeout (**files not included**):\n\n```\nadk.tcl                     -- ADK-specific setup script\nalib                        -- Synopsys DC performance cache\ncalibre-drc-antenna.rule    -- Calibre DRC antenna rule deck\ncalibre-drc-block.rule      -- Calibre DRC block-level rule deck\ncalibre-drc-chip.rule       -- Calibre DRC chip-level rule deck\ncalibre-drc-wirebond.rule   -- Calibre DRC wire bond rule deck\ncalibre-fill.rule           -- Calibre ODPO/metal fill utility\ncalibre.layerprops          -- Calibre DRV display properties\ncalibre-lvs-DFM             -- Calibre LVS design-for-manufacture rules\ncalibre-lvs.rule            -- Calibre LVS rule deck\ncalibre-rcx-DFM             -- Calibre RCX design-for-manufacture rules\ncalibre-rcx.rule            -- Calibre RCX rules\ncalibre-rcx-rules           -- Calibre RCX rules\ndisplay.drf                 -- Cadence Virtuoso display file\niocells-bc.db               -- IO cell library best-case DB\niocells-bc.lib              -- IO cell library best-case Liberty\niocells-bondpads.gds        -- IO bondpad GDS\niocells-bondpads.lef        -- IO bondpad LEF\niocells.db                  -- IO cell library typical DB\niocells.gds                 -- IO cell library GDS\niocells.lef                 -- IO cell library LEF\niocells.lib                 -- IO cell library Liberty\niocells.spi                 -- IO cell library SPICE\niocells.v                   -- IO cell library Verilog\niocells-wc.db               -- IO cell library worst-case DB\niocells-wc.lib              -- IO cell library worst-case Liberty\nklayout.lyp                 -- KLayout GDS viewer display file\npdk                         -- Link to PDK directory\npdk.layermap                -- PDK layer mapping file\npdk-rcbest-qrcTechFile      -- Interconnect parasitics (rcbest)\npdk-rcworst-qrcTechFile     -- Interconnect parasitics (rcworst)\npdk-typical-qrcTechFile     -- Interconnect parasitics (typical)\nrtk-antenna-rules.tcl       -- Routing rules to avoid antennas\nrtk-cbest.captable          -- Interconnect parasitics (cbest)\nrtk-cworst.captable         -- Interconnect parasitics (cworst)\nrtk-max.tluplus             -- Interconnect parasitics (max timing)\nrtk-min.tluplus             -- Interconnect parasitics (min timing)\nrtk-rcbest.captable         -- Interconnect parasitics (rcbest)\nrtk-rcworst.captable        -- Interconnect parasitics (rcworst)\nrtk-stream-in-milkyway.map  -- GDS-to-Milkyway layer map\nrtk-stream-out.map          -- Stream-out layer map for final GDS\nrtk-stream-out-milkyway.map -- Milkyway-to-GDS layer map\nrtk-tech.lef                -- Routing tech kit LEF\nrtk-tech.tf                 -- Routing tech kit Milkyway techfile\nrtk-tluplus.map             -- Routing tech kit TLUPlus map\nrtk-typical.captable        -- Interconnect parasitics (typical)\nstdcells-bc.db              -- Standard cell library best-case DB\nstdcells-bc.lib             -- Standard cell library best-case Liberty\nstdcells.cdl                -- Standard cell library CDL for LVS\nstdcells.db                 -- Standard cell library typical DB\nstdcells.gds                -- Standard cell library GDS\nstdcells.lef                -- Standard cell library LEF\nstdcells.lib                -- Standard cell library typical Liberty\nstdcells.mwlib              -- Standard cell library Milkyway\nstdcells.v                  -- Standard cell library Verilog\nstdcells-wc.db              -- Standard cell library worst-case DB\nstdcells-wc.lib             -- Standard cell library worst-case Liberty\n```\n\nThe ADK interface for variables in the `adk.tcl` includes the\nfollowing (with example values given), and examples of steps that\nuse these variables are listed in the comment:\n\n```\nset ADK_PROCESS                     28           # steps/innovus-flowsetup\nset ADK_MIN_ROUTING_LAYER_DC        M2           # steps/dc-synthesis\nset ADK_MAX_ROUTING_LAYER_DC        M7           # steps/dc-synthesis\nset ADK_MAX_ROUTING_LAYER_INNOVUS   7            # steps/innovus-flowsetup\nset ADK_POWER_MESH_BOT_LAYER        8            # steps/innovus-plugins\nset ADK_POWER_MESH_TOP_LAYER        9            # steps/innovus-plugins\nset ADK_DRIVING_CELL                (cell-name)  # steps/constraints\nset ADK_TYPICAL_ON_CHIP_LOAD        0.005        # steps/constraints\nset ADK_FILLER_CELLS                (list)       # steps/innovus-flowsetup\nset ADK_TIE_CELLS                   (list)       # steps/innovus-flowsetup\nset ADK_WELL_TAP_CELL               (cell-name)  # steps/innovus-flowsetup\nset ADK_END_CAP_CELL                (cell-name)  # steps/innovus-flowsetup\nset ADK_ANTENNA_CELL                (cell-name)  # steps/innovus-flowsetup\nset ADK_LVS_EXCLUDE_CELL_LIST       \"\"           # steps/innovus-plugins\nset ADK_VIRTUOSO_EXCLUDE_CELL_LIST  \"\"           # steps/innovus-plugins\n```\n\n--------------------------------------------------------------------------\nFeature in Detail: Sandboxed and Modular Steps\n--------------------------------------------------------------------------\n\nA key philosophy of mflowgen is to avoid rigidly structured ASIC flows\nthat cannot be repurposed and to instead break the ASIC flow into\nmodular steps that can be re-assembled into different flows with\nhigh reuse. Specifically, instead of having ASIC steps that directly\nfeed into the next steps, we design each step in modular fashion\nwith an \"inputs\" directory for inputs and an \"outputs\" directory for\noutputs. The build system runs each step in its sandbox, generating\nthe outputs. Then, the build system handles the edges of the graph\nby moving files between sandboxes.\n\nSandboxing each step encourages reuse of the same scripts across\nmany projects.\n\nMore details to come...\n\n--------------------------------------------------------------------------\nFeature in Detail: A focus on hardware design-space exploration\n--------------------------------------------------------------------------\n\nIn contrast to software, hardware design includes both logical\ndesign-space exploration (i.e., architecture, RTL source code) and\nphysical design-space exploration (e.g., floorplanning and power\nstrategy). Physical design-space exploration can be uniquely\nchallenging because ASIC tools work extensively with files, making\nan already challenging problem more difficult due to additional file\nmanagement for many slightly different builds.\n\nmflowgen supports both parameterization and parallel expansion across a\nparameter space.\n\nFor example, suppose we would like to sweep the `clock_period` parameter in the `open-yosys-synthesis` step in this graph:\n\n<img height='300px' src='docs/_static/images/example-params-1.jpg'>\n\nThe mflowgen Python API `param_space()` expands the node for each\nparameter value in the list:\n\n```\n  g = Graph()\n  (... add steps and connect them together ... )\n  g.param_space( 'open-yosys-synthesis', 'clock_period', [ 0.5, 1.0, 1.5 ] )\n```\n\nThe expansion propagates to all downstream nodes, resulting in three\nslightly different builds:\n\n<img height='300px' src='docs/_static/images/example-params-2.jpg'>\n\nThe three builds can be run in parallel and the results compared.\nAll file management is handled cleanly by the build system (which\nmflowgen generates from the graph).\n\nNote that because parameters are passed as environment variables,\nparameter sweeping can be flexibly applied across the physical\ndesign flow in a very simple manner:\n\n1. Replace some code with a variable anywhere in your scripts\n2. Identify this variable as a parameter (i.e., in the step's `configure.yml`)\n3. Use the `param_space()` mflowgen API to perform a sweep of that variable\n\nThis can be useful for automating design-space exploration sweeps\ninvolving one parameter or multiple parameters.\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/cornell-brg/mflowgen", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "mflowgen", "package_url": "https://pypi.org/project/mflowgen/", "platform": "", "project_url": "https://pypi.org/project/mflowgen/", "project_urls": {"Homepage": "https://github.com/cornell-brg/mflowgen"}, "release_url": "https://pypi.org/project/mflowgen/0.2.0/", "requires_dist": ["pytest (>=4.4)", "pyyaml (>=5.0)"], "requires_python": ">=3.6", "summary": "mflowgen: A Modular ASIC and FPGA Flow Generator", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>mflowgen</h1>\n<p><a href=\"https://mflowgen.readthedocs.io/en/latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/771556a1487402d9932380b7128ecdd84f4e652b/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6d666c6f7767656e2f62616467652f3f76657273696f6e3d6c6174657374\"></a> <a href=\"https://travis-ci.com/cornell-brg/mflowgen\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e278e78802fd0cbba04d8289418585055ea0de0f/68747470733a2f2f7472617669732d63692e636f6d2f636f726e656c6c2d6272672f6d666c6f7767656e2e7376673f6272616e63683d6d6173746572\"></a></p>\n<p><strong>Author</strong>: Christopher Torng (<a href=\"mailto:clt67@cornell.edu\">clt67@cornell.edu</a>)</p>\n<p>mflowgen is a modular flow specification and build-system\ngenerator for ASIC and FPGA design-space exploration built around\nsandboxed and modular steps.</p>\n<p>mflowgen allows you to programmatically define and parameterize a graph\nof steps (i.e., sandboxes that run anything you like) with\nwell-defined inputs and outputs. Build system files (e.g., make,\nninja) are then generated which shuttle files between steps before\nrunning them.</p>\n<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b93f22c2e9b2985be27a1da12611222377062792/646f63732f5f7374617469632f696d616765732f6578616d706c652d67726170682e6a7067\" width=\"350px\">\n<p>Key features and design philosophies:</p>\n<ul>\n<li>\n<p><strong>Process and technology independence</strong> -- Process technology\nlibraries and variables can be abstracted and separated from\nphysical design scripts. Specifically, a single node called the\nASIC design kit (ADK) captures this material in one place for\nbetter maintainability and access control.</p>\n</li>\n<li>\n<p><strong>Sandboxed and modular steps</strong> -- Traditional ASIC flows are\ncomposed of many steps executing with fixed path dependencies. The\nresulting flows have low reusability across designs and technology\nnodes and can be confusing and monolithic. In contrast,\n<em>modularity</em> encourages reuse of the same scripts across many\nprojects, while <em>sandboxing</em> makes each step self-contained and\nalso makes the role of each step easy to understand (i.e., take\nthese inputs and generate those outputs).</p>\n</li>\n<li>\n<p><strong>Programmatically defined build-system generator</strong>: A\nPython-based scripting interface and a simple graph API allows\nflexible connection and disconnection of edges, insertion and\nremoval of steps, and parameter space expansions. A simple graph\ncan be specified for a quick synthesis and place-and-route spin,\nor a more complex graph can be built for a more aggressive chip\ntapeout (reusing many of the same steps from before).</p>\n</li>\n<li>\n<p><strong>A focus on hardware design-space exploration</strong> -- Parameter\nexpansion can be applied to steps to quickly spin out parallel\nbuilds for design-space exploration at both smaller scales with a\nsingle parameter (e.g., sweeping clock targets) as well as at\nlarger scales with multiple parameters (e.g., to characterize the\narea-energy tradeoff space of a new architectural widget with\ndifferent knobs). Dependent files are shuttled to each sandbox\nas needed.</p>\n</li>\n<li>\n<p><strong>Complete freedom in defining what steps do</strong> -- Aside from\nexposing precisely what the inputs and outputs are, no other\nrestrictions are placed on what steps do and a step can be as\nsimple as hello world (one line). A step may conduct an analysis\npass and report a gate count. A step can also apply a transform\npass to a netlist before passing it to other tools. In addition, a\nstep can even instantiate a subgraph to implement a hierarchical\nflow.</p>\n</li>\n</ul>\n<p>mflowgen ships with a limited set of ASIC flow scripts for both\nopen-source and commercial tools including synthesis (e.g., Synopsys\nDC, yosys), place and route (e.g., Cadence Innovus Foundation Flow,\nRePlAce, graywolf, qrouter), and signoff (e.g., Synopsys PTPX,\nMentor Calibre). In addition, we include an open-source 45nm ASIC design\nkit (ADK) assembled from FreePDK45 version 1.4 and the NanGate Open\nCell Library.</p>\n<p>More info can be found in the\n<a href=\"https://mflowgen.readthedocs.io/en/latest\" rel=\"nofollow\">documentation</a>.</p>\n<hr>\n<h2>License</h2>\n<p>mflowgen is offered under the terms of the Open Source Initiative BSD\n3-Clause License. More information about this license can be found\nhere:</p>\n<ul>\n<li><a href=\"http://choosealicense.com/licenses/bsd-3-clause\" rel=\"nofollow\">http://choosealicense.com/licenses/bsd-3-clause</a></li>\n<li><a href=\"http://opensource.org/licenses/BSD-3-Clause\" rel=\"nofollow\">http://opensource.org/licenses/BSD-3-Clause</a></li>\n</ul>\n<hr>\n<h2>Quick Start</h2>\n<p>This repo includes a small Verilog design that computes a greatest\ncommon divisor function. You can use this design to demo the ASIC\nflow with open-source tools. This section steps through how to clone\nthe repo and push this design through synthesis, place, and route\nusing the included open-source 45nm ASIC design kit (ADK), assuming\nthe open-source tools are available.</p>\n<p>Clone the repo:</p>\n<pre><code>% git clone https://github.com/cornell-brg/mflowgen\n% cd mflowgen\n% TOP=${PWD}\n</code></pre>\n<p>Install mflowgen with pip as an editable repo:</p>\n<pre><code>% pip install -e .\n</code></pre>\n<p>The example design is a greatest-common divisor circuit in RTL. We\nhave created three demo graphs for this design in\n<code>$TOP/designs/GcdUnit</code>: (1) <code>construct-open.py</code> uses an open-source\n45nm ASIC toolflow based on FreePDK45 and the NanGate Open Cell\nLibrary; (2) <code>construct-commercial.py</code> uses a commercial toolflow\nbased on Synopsys, Cadence, and Mentor tools; and (3)\n<code>construct-commercial-full.py</code> expands this commercial toolflow for\ngreater observability.  <strong>Note</strong>: To try different graphs, open\n<code>$TOP/designs/GcdUnit/.mflowgen.yml</code> and specify one of the three\nchoices. The remainder of this quickstart will assume you have\nmodified this file to choose the open-source toolflow.</p>\n<pre><code>% cd $TOP\n% mkdir build &amp;&amp; cd build\n% mflowgen run --design ../designs/GcdUnit\n</code></pre>\n<p>You can show information about the currently configured flow:</p>\n<pre><code>% make info      # &lt;-- shows which design is being targeted\n% make list      # &lt;-- shows most things you can do\n% make status    # &lt;-- prints the build status of each step\n% make graph     # &lt;-- dumps a graphviz PDF of the configured flow\n</code></pre>\n<p>Now run synthesis and check the outputs of the sandbox to inspect\nthe area report. <strong>Note</strong>: For the commercial flow, check <code>make list</code> for the build target name.</p>\n<pre><code>% make open-yosys-synthesis\n% cat *-open-yosys-synthesis/outputs/synth.stats.txt\n</code></pre>\n<p>You can also run steps using the number from <code>make list</code>:</p>\n<pre><code>% make list      # &lt;-- 3 : open-yosys-synthesis\n% make 3\n</code></pre>\n<p>The yosys area report will look something like this:</p>\n<pre><code>=== GcdUnit ===\n\n   Number of wires:                406\n   Number of wire bits:           1011\n   Number of public wires:         406\n   Number of public wire bits:    1011\n   Number of memories:               0\n   Number of memory bits:            0\n   Number of processes:              0\n   Number of cells:                941\n     AOI211_X1                       3\n     AOI21_X1                       34\n     AOI22_X1                       30\n     BUF_X1                        626\n     CLKBUF_X1                       5\n     DFF_X1                         34\n     INV_X1                         48\n     NAND2_X1                       42\n     NAND3_X1                        3\n     NOR2_X1                        34\n     NOR3_X1                         3\n     NOR4_X1                         4\n     OAI211_X1                       1\n     OAI21_X1                       40\n     OAI221_X1                       1\n     OAI22_X1                        2\n     OR2_X1                          1\n     XNOR2_X1                       18\n     XOR2_X1                        12\n\n   Chip area for this module: 932.330000\n</code></pre>\n<p>Report runtimes to check how long each step has taken:</p>\n<pre><code>% make runtimes\n</code></pre>\n<p>Then run place-and-route (requires graywolf and qrouter):</p>\n<pre><code>% make open-graywolf-place\n% make open-qrouter-route\n</code></pre>\n<hr>\n<h2>Organization</h2>\n<p>The repository is organized at the top level with directories for\nthe ADKs, designs, and steps (and utility scripts):</p>\n<pre><code>mflowgen/\n\u2502\n\u251c\u2500\u2500 adks/      -- Each subdirectory is for an ADK\n\u251c\u2500\u2500 designs/   -- Each subdirectory is for a design (can be a cloned repo)\n\u251c\u2500\u2500 steps/     -- Collection of generic steps\n\u2502\n\u2502\u2500\u2500 mflowgen/  -- Source files for the mflowgen Python API\n\u2502\u2500\u2500 utils/     -- Helper scripts\n\u2514\u2500\u2500 configure  -- Config script to select a design\n</code></pre>\n<p>Designs include the graph specification, the source code, and any\ndesign-specific steps.</p>\n<p>New designs are meant to be cloned into (or symlinked into) the\ndesigns subdirectory for easy access when configuring with <code>--design</code>.</p>\n<hr>\n<h2>Feature in Detail: Process and Technology Independence</h2>\n<p>The ASIC Design Kit (ADK) is a standard interface to all process\ntechnology libraries and variables used across all ASIC scripts in\nthe tool flow. The ADK interface remains constant regardless of\nwhere the actual packages and IP libraries are downloaded and how\nthey are organized. The ADK may include process technology files,\nphysical IP libraries (e.g., IO cells, standard cells, memory\ncompilers), as well as physical verification decks (e.g., Calibre\nDRC/LVS).</p>\n<p>mflowgen ships with an open-source 45nm ADK assembled from FreePDK45\nversion 1.4 and the NanGate Open Cell Library. We place all kits and\nlibraries into the directory <code>adks/freepdk-45nm/pkgs</code> in a\nrelatively unorganized manner (just untar them). We then create\ndifferent \"views\" into these packages for different purposes (e.g.,\nfront-end only, targeting open-source toolchains, targeting\ncommercial toolchains) by creating subdirectories with different\nsets of symlinks to the vendor files.</p>\n<p>Here is the \"view-tiny\" interface to the 45nm ADK containing only\nthe files needed by the open-source ASIC flow tools:</p>\n<pre><code>adk.tcl                     -- ADK variables setup script\n\nrtk-tech.info               -- Qflow tech file\nrtk-tech.lef                -- Routing tech kit LEF\nrtk-tech.par                -- Graywolf tech file\n\nstdcells.gds                -- Standard cell library GDS\nstdcells.lef                -- Standard cell library LEF\nstdcells.lib                -- Standard cell library typical Liberty\nstdcells.v                  -- Standard cell library Verilog\n</code></pre>\n<p><strong>Note</strong>: The <code>adk.tcl</code> encapsulates the ADK interface for\nvariables. Any information specific to this ADK goes here (e.g., the\nlist of filler cells, min/max routing metal layers).</p>\n<p>The \"view-standard\" interface for the same 45nm ADK has more entries\nand targets commercial ASIC flow tools. This interface is useful for\narchitectural design-space exploration of block-level designs. Note\nthat we conserve repository space by downloading this view from\nonline at build time:</p>\n<pre><code>adk.tcl                     -- ADK variables setup script\n\nrtk-max.tluplus             -- Interconnect parasitics (max timing)\nrtk-min.tluplus             -- Interconnect parasitics (min timing)\nrtk-typical.captable        -- Interconnect parasitics (typical)\nrtk-tech.lef                -- Routing tech kit LEF\nrtk-tech.tf                 -- Routing tech kit Milkyway techfile\nrtk-tluplus.map             -- Routing tech kit TLUPlus map\nrtk-stream-out.map          -- Stream-out layer map for final GDS\n\nstdcells.gds                -- Standard cell library GDS\nstdcells.db                 -- Standard cell library typical DB\nstdcells.lef                -- Standard cell library LEF\nstdcells.lib                -- Standard cell library typical Liberty\nstdcells.mwlib              -- Standard cell library Milkyway\nstdcells.v                  -- Standard cell library Verilog\nstdcells.cdl                -- Standard cell library LVS spice\nstdcells-lpe.spi            -- Standard cell library extracted spice\n\ncalibre-drc-block.rule      -- Calibre DRC ruledeck\ncalibre-lvs.rule            -- Calibre LVS ruledeck\n</code></pre>\n<p>Here is a more complete and general-purpose ADK interface that might\ntarget a chip tapeout (<strong>files not included</strong>):</p>\n<pre><code>adk.tcl                     -- ADK-specific setup script\nalib                        -- Synopsys DC performance cache\ncalibre-drc-antenna.rule    -- Calibre DRC antenna rule deck\ncalibre-drc-block.rule      -- Calibre DRC block-level rule deck\ncalibre-drc-chip.rule       -- Calibre DRC chip-level rule deck\ncalibre-drc-wirebond.rule   -- Calibre DRC wire bond rule deck\ncalibre-fill.rule           -- Calibre ODPO/metal fill utility\ncalibre.layerprops          -- Calibre DRV display properties\ncalibre-lvs-DFM             -- Calibre LVS design-for-manufacture rules\ncalibre-lvs.rule            -- Calibre LVS rule deck\ncalibre-rcx-DFM             -- Calibre RCX design-for-manufacture rules\ncalibre-rcx.rule            -- Calibre RCX rules\ncalibre-rcx-rules           -- Calibre RCX rules\ndisplay.drf                 -- Cadence Virtuoso display file\niocells-bc.db               -- IO cell library best-case DB\niocells-bc.lib              -- IO cell library best-case Liberty\niocells-bondpads.gds        -- IO bondpad GDS\niocells-bondpads.lef        -- IO bondpad LEF\niocells.db                  -- IO cell library typical DB\niocells.gds                 -- IO cell library GDS\niocells.lef                 -- IO cell library LEF\niocells.lib                 -- IO cell library Liberty\niocells.spi                 -- IO cell library SPICE\niocells.v                   -- IO cell library Verilog\niocells-wc.db               -- IO cell library worst-case DB\niocells-wc.lib              -- IO cell library worst-case Liberty\nklayout.lyp                 -- KLayout GDS viewer display file\npdk                         -- Link to PDK directory\npdk.layermap                -- PDK layer mapping file\npdk-rcbest-qrcTechFile      -- Interconnect parasitics (rcbest)\npdk-rcworst-qrcTechFile     -- Interconnect parasitics (rcworst)\npdk-typical-qrcTechFile     -- Interconnect parasitics (typical)\nrtk-antenna-rules.tcl       -- Routing rules to avoid antennas\nrtk-cbest.captable          -- Interconnect parasitics (cbest)\nrtk-cworst.captable         -- Interconnect parasitics (cworst)\nrtk-max.tluplus             -- Interconnect parasitics (max timing)\nrtk-min.tluplus             -- Interconnect parasitics (min timing)\nrtk-rcbest.captable         -- Interconnect parasitics (rcbest)\nrtk-rcworst.captable        -- Interconnect parasitics (rcworst)\nrtk-stream-in-milkyway.map  -- GDS-to-Milkyway layer map\nrtk-stream-out.map          -- Stream-out layer map for final GDS\nrtk-stream-out-milkyway.map -- Milkyway-to-GDS layer map\nrtk-tech.lef                -- Routing tech kit LEF\nrtk-tech.tf                 -- Routing tech kit Milkyway techfile\nrtk-tluplus.map             -- Routing tech kit TLUPlus map\nrtk-typical.captable        -- Interconnect parasitics (typical)\nstdcells-bc.db              -- Standard cell library best-case DB\nstdcells-bc.lib             -- Standard cell library best-case Liberty\nstdcells.cdl                -- Standard cell library CDL for LVS\nstdcells.db                 -- Standard cell library typical DB\nstdcells.gds                -- Standard cell library GDS\nstdcells.lef                -- Standard cell library LEF\nstdcells.lib                -- Standard cell library typical Liberty\nstdcells.mwlib              -- Standard cell library Milkyway\nstdcells.v                  -- Standard cell library Verilog\nstdcells-wc.db              -- Standard cell library worst-case DB\nstdcells-wc.lib             -- Standard cell library worst-case Liberty\n</code></pre>\n<p>The ADK interface for variables in the <code>adk.tcl</code> includes the\nfollowing (with example values given), and examples of steps that\nuse these variables are listed in the comment:</p>\n<pre><code>set ADK_PROCESS                     28           # steps/innovus-flowsetup\nset ADK_MIN_ROUTING_LAYER_DC        M2           # steps/dc-synthesis\nset ADK_MAX_ROUTING_LAYER_DC        M7           # steps/dc-synthesis\nset ADK_MAX_ROUTING_LAYER_INNOVUS   7            # steps/innovus-flowsetup\nset ADK_POWER_MESH_BOT_LAYER        8            # steps/innovus-plugins\nset ADK_POWER_MESH_TOP_LAYER        9            # steps/innovus-plugins\nset ADK_DRIVING_CELL                (cell-name)  # steps/constraints\nset ADK_TYPICAL_ON_CHIP_LOAD        0.005        # steps/constraints\nset ADK_FILLER_CELLS                (list)       # steps/innovus-flowsetup\nset ADK_TIE_CELLS                   (list)       # steps/innovus-flowsetup\nset ADK_WELL_TAP_CELL               (cell-name)  # steps/innovus-flowsetup\nset ADK_END_CAP_CELL                (cell-name)  # steps/innovus-flowsetup\nset ADK_ANTENNA_CELL                (cell-name)  # steps/innovus-flowsetup\nset ADK_LVS_EXCLUDE_CELL_LIST       \"\"           # steps/innovus-plugins\nset ADK_VIRTUOSO_EXCLUDE_CELL_LIST  \"\"           # steps/innovus-plugins\n</code></pre>\n<hr>\n<h2>Feature in Detail: Sandboxed and Modular Steps</h2>\n<p>A key philosophy of mflowgen is to avoid rigidly structured ASIC flows\nthat cannot be repurposed and to instead break the ASIC flow into\nmodular steps that can be re-assembled into different flows with\nhigh reuse. Specifically, instead of having ASIC steps that directly\nfeed into the next steps, we design each step in modular fashion\nwith an \"inputs\" directory for inputs and an \"outputs\" directory for\noutputs. The build system runs each step in its sandbox, generating\nthe outputs. Then, the build system handles the edges of the graph\nby moving files between sandboxes.</p>\n<p>Sandboxing each step encourages reuse of the same scripts across\nmany projects.</p>\n<p>More details to come...</p>\n<hr>\n<h2>Feature in Detail: A focus on hardware design-space exploration</h2>\n<p>In contrast to software, hardware design includes both logical\ndesign-space exploration (i.e., architecture, RTL source code) and\nphysical design-space exploration (e.g., floorplanning and power\nstrategy). Physical design-space exploration can be uniquely\nchallenging because ASIC tools work extensively with files, making\nan already challenging problem more difficult due to additional file\nmanagement for many slightly different builds.</p>\n<p>mflowgen supports both parameterization and parallel expansion across a\nparameter space.</p>\n<p>For example, suppose we would like to sweep the <code>clock_period</code> parameter in the <code>open-yosys-synthesis</code> step in this graph:</p>\n<img height=\"300px\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5e902a3eca15ae75017837214607a22ea0af251c/646f63732f5f7374617469632f696d616765732f6578616d706c652d706172616d732d312e6a7067\">\n<p>The mflowgen Python API <code>param_space()</code> expands the node for each\nparameter value in the list:</p>\n<pre><code>  g = Graph()\n  (... add steps and connect them together ... )\n  g.param_space( 'open-yosys-synthesis', 'clock_period', [ 0.5, 1.0, 1.5 ] )\n</code></pre>\n<p>The expansion propagates to all downstream nodes, resulting in three\nslightly different builds:</p>\n<img height=\"300px\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d80b17566ead8339e344506e7a1e27dc9774ee01/646f63732f5f7374617469632f696d616765732f6578616d706c652d706172616d732d322e6a7067\">\n<p>The three builds can be run in parallel and the results compared.\nAll file management is handled cleanly by the build system (which\nmflowgen generates from the graph).</p>\n<p>Note that because parameters are passed as environment variables,\nparameter sweeping can be flexibly applied across the physical\ndesign flow in a very simple manner:</p>\n<ol>\n<li>Replace some code with a variable anywhere in your scripts</li>\n<li>Identify this variable as a parameter (i.e., in the step's <code>configure.yml</code>)</li>\n<li>Use the <code>param_space()</code> mflowgen API to perform a sweep of that variable</li>\n</ol>\n<p>This can be useful for automating design-space exploration sweeps\ninvolving one parameter or multiple parameters.</p>\n\n          </div>"}, "last_serial": 6838521, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "76c636ec99f5839eaaedc1b4064b75cb", "sha256": "c6516a4d1b59b85a814c1a42fb3d8c0ea2f9ab0facfbf5aaf021f627085884ee"}, "downloads": -1, "filename": "mflowgen-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "76c636ec99f5839eaaedc1b4064b75cb", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 3397775, "upload_time": "2020-03-17T08:58:12", "upload_time_iso_8601": "2020-03-17T08:58:12.466257Z", "url": "https://files.pythonhosted.org/packages/1c/72/2e9823dafcfbdafab51d660d5b29958f0b2c5a8f65aff7b227ccc7961e0a/mflowgen-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dc919a8c79e184a85279cd37a478fc7f", "sha256": "8a9355f66824b17204e3767c694a01ac5e36dcebb2516a6ac5b164dce24d1fcb"}, "downloads": -1, "filename": "mflowgen-0.1.0.tar.gz", "has_sig": false, "md5_digest": "dc919a8c79e184a85279cd37a478fc7f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 3230863, "upload_time": "2020-03-17T08:58:19", "upload_time_iso_8601": "2020-03-17T08:58:19.510555Z", "url": "https://files.pythonhosted.org/packages/7d/97/ac9386ba29d8bfcda3792659fdd87be932707c5fba272e4dd370f404dbd4/mflowgen-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "842b68605b5b63b88b2914308f8aa078", "sha256": "ab1b74bab0cfd90c00a1e92ad4831068dacaa5a1fdb111817284f0a2c2c1f8ef"}, "downloads": -1, "filename": "mflowgen-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "842b68605b5b63b88b2914308f8aa078", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 3960167, "upload_time": "2020-03-18T19:16:54", "upload_time_iso_8601": "2020-03-18T19:16:54.706453Z", "url": "https://files.pythonhosted.org/packages/ee/41/0ff12007afb045891aff9dbbf725ca7a494366167ece12be2cd1df5cc2ae/mflowgen-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1d083a2919b4de4d4fe5af9a96270af7", "sha256": "66ffce1b20e79fbc34eb62e5e3724685788665c182d449d34581727b108fab86"}, "downloads": -1, "filename": "mflowgen-0.2.0.tar.gz", "has_sig": false, "md5_digest": "1d083a2919b4de4d4fe5af9a96270af7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 3784519, "upload_time": "2020-03-18T19:17:04", "upload_time_iso_8601": "2020-03-18T19:17:04.362948Z", "url": "https://files.pythonhosted.org/packages/4c/db/deed9e12a9e71a1d9bd18195dd660e0493f59454bc35b6d893a3f3bc93b9/mflowgen-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "842b68605b5b63b88b2914308f8aa078", "sha256": "ab1b74bab0cfd90c00a1e92ad4831068dacaa5a1fdb111817284f0a2c2c1f8ef"}, "downloads": -1, "filename": "mflowgen-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "842b68605b5b63b88b2914308f8aa078", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 3960167, "upload_time": "2020-03-18T19:16:54", "upload_time_iso_8601": "2020-03-18T19:16:54.706453Z", "url": "https://files.pythonhosted.org/packages/ee/41/0ff12007afb045891aff9dbbf725ca7a494366167ece12be2cd1df5cc2ae/mflowgen-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1d083a2919b4de4d4fe5af9a96270af7", "sha256": "66ffce1b20e79fbc34eb62e5e3724685788665c182d449d34581727b108fab86"}, "downloads": -1, "filename": "mflowgen-0.2.0.tar.gz", "has_sig": false, "md5_digest": "1d083a2919b4de4d4fe5af9a96270af7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 3784519, "upload_time": "2020-03-18T19:17:04", "upload_time_iso_8601": "2020-03-18T19:17:04.362948Z", "url": "https://files.pythonhosted.org/packages/4c/db/deed9e12a9e71a1d9bd18195dd660e0493f59454bc35b6d893a3f3bc93b9/mflowgen-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:30 2020"}