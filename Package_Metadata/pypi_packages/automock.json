{"info": {"author": "Depop", "author_email": "dev@depop.com", "bugtrack_url": null, "classifiers": ["Environment :: Plugins", "Framework :: Pytest", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.6"], "description": "automock\n========\n\n|PyPI Version| |Build Status|\n\n.. |PyPI Version| image:: http://img.shields.io/pypi/v/automock.svg?style=flat\n   :target: https://pypi.python.org/pypi/automock/\n   :alt: Latest PyPI version\n\n.. |Build Status| image:: https://circleci.com/gh/depop/python-automock.svg?style=shield&circle-token=cbe5583fec309912d76bfc8b0321f6cfa23b7f6d\n    :alt: Build Status\n\nThere are some things that need to be mocked in unit tests.\n\nFor example: API clients for other backend services - we don't want to run an\ninstance of the other service just for our unit tests. The other service will\nhave its own tests and we only want to test that our code confiorms to the API\ncontract of the other service. Similarly for 3rd party services - we don't want\nour unit tests to connect out over the internet to talk to the 3rd party service\n(even if they offer a 'sandbox' test environment) for the same reasons as above,\nand because this is a recipe for flaky tests.\n\n(There is certainly a role for integration tests which do make live calls to\nother services, but the bulk of tests won't be this kind and need mocking).\n\nPython has the excellent `mock <http://www.voidspace.org.uk/python/mock/>`_ library to help with this.\n\nHowever, say you have six API clients for backend services which are used\nextensively in many places in code for your mobile app backend. You're going to\nend up with a big 'stack' of patch decorators on many tests, e.g.:\n\n.. code:: python\n\n    @mock.patch('services.users.client.get_user', return_value=MockUser(id=1))\n    @mock.patch('services.products.client.get_product', return_value=MockProduct(id=1))\n    @mock.patch('services.paypal.client.make_payment', return_value=PaypalResult('success'))\n    def test_some_web_view(self, *mocks)\n\nSay you have thousands of unit tests, these decorators need applying to many of\nthem. Every time you write a new test you'll need to remember to patch things.\n\nEnter ``automock``.\n\nBasically we want some functions to be 'mocked by default' when running tests.\nBut we also need to be able to easily replace the default mocks in some cases,\nwhere the test needs a specific return value. ``automock`` makes this easy-ish.\n\n\nUsage\n-----\n\n.. code:: bash\n\n    pip install automock\n\n\nIntroduction\n~~~~~~~~~~~~\n\nThe key idea is that we define a 'mock factory' for each function we want to be\nautomocked. When called without arguments the factory should return a suitable\n'default' mock that will allow most tests to pass. The default mock factory is\njust ``MagicMock`` from the ``mock`` library.\n\nRegistering a function to be mocked is simple:\n\n.. code:: python\n\n    import automock\n\n    automock.register('services.users.client.get_user')\n\nBy default this provides a ``MagicMock`` and is equivalent to decorating *all*\nyour test cases with:\n\n.. code:: python\n\n    @mock.patch('services.users.client.get_user')\n\n(for more scenarios see `Customising mock factories`_ below)\n\nFor this to work you just need to do two things.\n\n#. You need to ensure that the modules containing ``automock.register``\n   calls get imported before the tests run. To achieve this we have an\n   ``AUTOMOCK_REGISTRATION_IMPORTS`` config setting. This should contain string paths\n   to modules containing registration calls, e.g.:\n\n   .. code:: python\n\n        AUTOMOCK_REGISTRATION_IMPORTS = (\n            'services.users.test_mocks',\n            'services.products.test_mocks',\n            'services.paypal.test_mocks',\n        )\n\n#. If you're running your tests under `pytest <https://docs.pytest.org/en/latest/>`_\n   then you don't need to do anything else - Automock registers a pytest plugin\n   (named ``automock`` in pytest) that ensures your test cases all run patched.\n\n#. If you're running under another test-runner then your test cases need to inherit\n   from one of our helper classes, e.g.:\n\n   .. code:: python\n\n        from automock import AutomockTestCase, AutomockTestCaseMixin\n\n\n        class TestWebViews(AutomockTestCase):\n            ...\n\n\n        class TestSpecialViews(AutomockTestCaseMixin, MyCustomTestCase):\n            ...\n\n   This will ensure the mock patches get applied before the tests run, and stopped\n   afterwards.\n\n   Alternatively you can start/stop patching manually:\n\n   .. code:: python\n\n        from unittest import TestCase\n\n        import automock\n\n\n        class TestStuff(TestCase):\n\n            # as a decorator\n            @automock.activate()\n            def test_stuff(self):\n                # automocks active\n                ...\n\n            # as a context-manager\n            def test_other_stuff(self):\n                # automocks inactive\n                ...\n                with automock.activate():\n                    # automocks active\n                    ...\n\n                # automocks inactive\n\n\nConfiguration\n~~~~~~~~~~~~~\n\nSettings are intended to be configured primarily via a python file, such\nas your existing Django ``settings.py``. To bootstrap this, there are a couple\nof **env vars** to control how config is loaded:\n\n-  ``AUTOMOCK_APP_CONFIG``\n   should be an import path to a python module, for example:\n   ``AUTOMOCK_APP_CONFIG=django.conf.settings``\n-  ``AUTOMOCK_CONFIG_NAMESPACE``\n   Sets the prefix used for loading further config values from env and\n   config file. Defaults to ``AUTOMOCK``.\n\nThe following config keys are available (and are prefixed with\n``AUTOMOCK_`` by default, see ``AUTOMOCK_CONFIG_NAMESPACE`` above):\n\n-  ``<namespace>_REGISTRATION_IMPORTS`` list of import paths to modules\n   containing ``automock.register`` calls\n\n\nPatching and imports\n~~~~~~~~~~~~~~~~~~~~\n\nAn **important point to note** about the path you mock:\n\nThis has the same caveats as when using ``mock.patch`` directly. Namely that\nyou must patch the path *where it is imported*.\n\nFor example if you do:\n\n.. code:: python\n\n    # mypackage/mymodule.py\n\n    from services.product.client import get_product\n\nWhen you patch it:\n\n.. code:: python\n\n    # won't work:\n    patch('services.product.client.get_product')\n\n    # works:\n    patch('mypackage.mymodule.get_product')\n\nDON'T DO THIS (see this\n`blog post <http://bhfsteve.blogspot.co.uk/2012/06/patching-tip-using-mocks-in-python-unit.html>`_\nfor more details).\n\nThis import style will cause us problems if we want to mock-by-default all\nusages of a particular function, because we only register a single path to mock.\n\nInstead you need to use one of the following import styles *everywhere* in your\ncodebase that the function to mocked is used:\n\n.. code:: python\n\n    # mypackage/mymodule.py\n\n    # either\n    from services.product import client as product_client\n    product_client.get_product(*args)\n\n    # or\n    import services.product.client as product_client\n    product_client.get_product(*args)\n\nThis will ensure that we can:\n\n.. code:: python\n\n    automock.register('services.product.client.get_product')\n\nand have that work reliably.\n\n**NOTE:**\n\nAlways ``import automock`` and use as ``automock.register`` to ensure there is\nonly one registry active.\n\n\nCustomising mock factories\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt's likely you need to do more than provide a bare ``MagicMock``. For example\nwe might want to customise the response based on some values from the request.\n\nIn ``mock.Mock`` this is achieved via a 'side effect'. So we might want to\ndefine our mock factory like this:\n\n.. code:: python\n\n    def batch_counters_mock(return_value=None, side_effect=None, *args, **kwargs):\n        if return_value is None and side_effect is None:\n            def side_effect(product_ids, *args, **kwargs):\n                return {str(p_id): 0 for p_id in product_ids}\n        return mock.MagicMock(return_value=return_value, side_effect=side_effect, *args, **kwargs)\n\n    automock.register('services.products.client.batch_counters', batch_counters_mock)\n\nNote that we passed the custom mock factory as second argument to ``register``.\n\nAs an alternative we can use decorator syntax:\n\n.. code:: python\n\n    @automock.register('services.products.client.batch_counters')\n    def batch_counters_mock(return_value=None, side_effect=None, *args, **kwargs):\n        if return_value is None and side_effect is None:\n            def side_effect(product_ids, *args, **kwargs):\n                return {str(p_id): 0 for p_id in product_ids}\n        return mock.MagicMock(return_value=return_value, side_effect=side_effect, *args, **kwargs)\n\nNow in our tests we can:\n\n.. code:: python\n\n    import services.products.client as products_client\n\n    def test_counters():\n        counters = products_client.batch_counters([1, 2])\n        # we got a default value for each of the ids we passed in:\n        assert counters == {'1': 0, '2': 0}\n\n(This is a useless test of course, it's just to demonstrate the mocking)\n\nOkay. What if we need a custom return value for a particular test?\n\nWell, firstly the regular ``mock.patch`` still works, you could apply that in\nyour test case.\n\nAutomock also provides a ``swap_mock`` helper that allows us to take advantage\nof our custom mock factory.\n\nLet's say our factory looks like:\n\n.. code:: python\n\n    @automock.register('services.things.client.do_something')\n    def do_something_mock(success=True):\n        if success:\n            return mock.MagicMock(return_value='OK')\n        else:\n            return mock.MagicMock(side_effect=requests.HTTPError())\n\nIn our tests we can:\n\n.. code:: python\n\n    import pytest\n    import requests\n    from automock import swap_mock\n\n    import services.things.client as things_client\n\n    def test_success():\n        # default mock from factory gives success response\n        assert things_client.do_something() == 'OK'\n\n    @swap_mock('services.things.client.do_something', success=False)\n    def test_fail():\n        # swap mock applies a customised mock from our factory\n        with pytest.raises(requests.HTPPError):\n            things_client.do_something()\n\nWhat happened here is that the ``*args, **kwargs`` from our ``swap_mock`` call\nare passed through to the ``do_something_mock`` to *get a new mock* which is\nthen applied in place of the default.\n\nWe can also use this as a context manager:\n\n.. code:: python\n\n    import pytest\n    import requests\n    from automock import swap_mock\n\n    import services.things.client as things_client\n\n    def test_do_something():\n        assert things_client.do_something() == 'OK'\n\n        with swap_mock('services.things.client.do_something', success=False):\n            with pytest.raises(requests.HTPPError):\n                things_client.do_something()\n\n        assert things_client.do_something() == 'OK'\n\n\nChecking mocked calls\n~~~~~~~~~~~~~~~~~~~~~\n\nIt's common in tests to want to check if a mocked function was called, and\nwith correct arguments etc. If you use ``mock.patch`` directly this is easy\nbecause it returns the mock object to you.\n\nAutomock provides the ``get_mock`` helper to achieve the same thing:\n\n.. code:: python\n\n    from automock import get_mock\n\n    import services.things.client as things_client\n\n    def test_success():\n        assert things_client.do_something() == 'OK'\n        mocked = get_mock('services.things.client.do_something')\n        assert mocked.called\n\n\nTesting the automocked functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOk, so you've mocked your API clients or whatever. How do you test the mocked\nfunctions themselves if they're mocked out everywhere?\n\nFirstly, you could just not inherit from ``AutomockTestCase`` in those tests.\n\nBut maybe you have a bunch of other automocks you want to keep in place still.\n\nAutomock provides an ``unmock`` helper:\n\n.. code:: python\n\n    import pytest\n    import responses\n    from automock import unmock\n\n    import services.things.client as things_client\n\n    @responses.activate\n    @unmock('services.things.client.do_something')\n    def test_do_something_not_found():\n        responses.add(responses.GET, 'https://thingservice.ourcompany.com/api/1/something',\n                      json={'error': 'Not Found'}, status=404)\n        with pytest.raises(requests.HTPPError):\n            things_client.do_something()\n\n(for functions which make HTTP calls we recommend the excellent\n`responses <https://github.com/getsentry/responses>`_ library)\n\nHere we have un-mocked our client method so that we can test that it correctly\nhandles a 404 response from the remote service.\n\n\nCompatibility\n-------------\n\nThis project is tested against:\n\n=========== ===\nPython 2.7   * \nPython 3.6   * \n=========== ===\n\nRunning the tests\n-----------------\n\nCircleCI\n~~~~~~~~\n\n| The easiest way to test the full version matrix is to install the\n  CircleCI command line app:\n| https://circleci.com/docs/2.0/local-jobs/\n| (requires Docker)\n\nThe cli does not support 'workflows' at the moment so you have to run\nthe two Python version jobs separately:\n\n.. code:: bash\n\n    circleci build --job python-2.7\n\n.. code:: bash\n\n    circleci build --job python-3.6\n\npy.test (single python version)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt's also possible to run the tests locally, allowing for debugging of\nerrors that occur.\n\nNow decide which Python version you want to test and create a virtualenv:\n\n.. code:: bash\n\n    pyenv virtualenv 3.6.4 automock\n    pip install -r requirements-test.txt\n\nNow we can run the tests:\n\n.. code:: bash\n\n    make test", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/depop/python-automock", "keywords": "", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "automock", "package_url": "https://pypi.org/project/automock/", "platform": "", "project_url": "https://pypi.org/project/automock/", "project_urls": {"Homepage": "https://github.com/depop/python-automock"}, "release_url": "https://pypi.org/project/automock/1.2.0/", "requires_dist": null, "requires_python": "", "summary": "Utility to allow some functions to be 'mocked by default' when running tests.", "version": "1.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://pypi.python.org/pypi/automock/\" rel=\"nofollow\"><img alt=\"Latest PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8e552aaff0f81d028c6da7a9b95f4d3deefc2ac8/687474703a2f2f696d672e736869656c64732e696f2f707970692f762f6175746f6d6f636b2e7376673f7374796c653d666c6174\"></a> <img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/819906184e5e68071d067377d9480968a7d21625/68747470733a2f2f636972636c6563692e636f6d2f67682f6465706f702f707974686f6e2d6175746f6d6f636b2e7376673f7374796c653d736869656c6426636972636c652d746f6b656e3d63626535353833666563333039393132643736626663386230333231663663666132336237663664\"></p>\n<p>There are some things that need to be mocked in unit tests.</p>\n<p>For example: API clients for other backend services - we don\u2019t want to run an\ninstance of the other service just for our unit tests. The other service will\nhave its own tests and we only want to test that our code confiorms to the API\ncontract of the other service. Similarly for 3rd party services - we don\u2019t want\nour unit tests to connect out over the internet to talk to the 3rd party service\n(even if they offer a \u2018sandbox\u2019 test environment) for the same reasons as above,\nand because this is a recipe for flaky tests.</p>\n<p>(There is certainly a role for integration tests which do make live calls to\nother services, but the bulk of tests won\u2019t be this kind and need mocking).</p>\n<p>Python has the excellent <a href=\"http://www.voidspace.org.uk/python/mock/\" rel=\"nofollow\">mock</a> library to help with this.</p>\n<p>However, say you have six API clients for backend services which are used\nextensively in many places in code for your mobile app backend. You\u2019re going to\nend up with a big \u2018stack\u2019 of patch decorators on many tests, e.g.:</p>\n<pre><span class=\"nd\">@mock</span><span class=\"o\">.</span><span class=\"n\">patch</span><span class=\"p\">(</span><span class=\"s1\">'services.users.client.get_user'</span><span class=\"p\">,</span> <span class=\"n\">return_value</span><span class=\"o\">=</span><span class=\"n\">MockUser</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"nd\">@mock</span><span class=\"o\">.</span><span class=\"n\">patch</span><span class=\"p\">(</span><span class=\"s1\">'services.products.client.get_product'</span><span class=\"p\">,</span> <span class=\"n\">return_value</span><span class=\"o\">=</span><span class=\"n\">MockProduct</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"nd\">@mock</span><span class=\"o\">.</span><span class=\"n\">patch</span><span class=\"p\">(</span><span class=\"s1\">'services.paypal.client.make_payment'</span><span class=\"p\">,</span> <span class=\"n\">return_value</span><span class=\"o\">=</span><span class=\"n\">PaypalResult</span><span class=\"p\">(</span><span class=\"s1\">'success'</span><span class=\"p\">))</span>\n<span class=\"k\">def</span> <span class=\"nf\">test_some_web_view</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">mocks</span><span class=\"p\">)</span>\n</pre>\n<p>Say you have thousands of unit tests, these decorators need applying to many of\nthem. Every time you write a new test you\u2019ll need to remember to patch things.</p>\n<p>Enter <tt>automock</tt>.</p>\n<p>Basically we want some functions to be \u2018mocked by default\u2019 when running tests.\nBut we also need to be able to easily replace the default mocks in some cases,\nwhere the test needs a specific return value. <tt>automock</tt> makes this easy-ish.</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<pre>pip install automock\n</pre>\n<div id=\"introduction\">\n<h3>Introduction</h3>\n<p>The key idea is that we define a \u2018mock factory\u2019 for each function we want to be\nautomocked. When called without arguments the factory should return a suitable\n\u2018default\u2019 mock that will allow most tests to pass. The default mock factory is\njust <tt>MagicMock</tt> from the <tt>mock</tt> library.</p>\n<p>Registering a function to be mocked is simple:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">automock</span>\n\n<span class=\"n\">automock</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s1\">'services.users.client.get_user'</span><span class=\"p\">)</span>\n</pre>\n<p>By default this provides a <tt>MagicMock</tt> and is equivalent to decorating <em>all</em>\nyour test cases with:</p>\n<pre><span class=\"nd\">@mock</span><span class=\"o\">.</span><span class=\"n\">patch</span><span class=\"p\">(</span><span class=\"s1\">'services.users.client.get_user'</span><span class=\"p\">)</span>\n</pre>\n<p>(for more scenarios see <a href=\"#customising-mock-factories\" rel=\"nofollow\">Customising mock factories</a> below)</p>\n<p>For this to work you just need to do two things.</p>\n<ol>\n<li><p>You need to ensure that the modules containing <tt>automock.register</tt>\ncalls get imported before the tests run. To achieve this we have an\n<tt>AUTOMOCK_REGISTRATION_IMPORTS</tt> config setting. This should contain string paths\nto modules containing registration calls, e.g.:</p>\n<pre><span class=\"n\">AUTOMOCK_REGISTRATION_IMPORTS</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n    <span class=\"s1\">'services.users.test_mocks'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'services.products.test_mocks'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'services.paypal.test_mocks'</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n</pre>\n</li>\n<li><p>If you\u2019re running your tests under <a href=\"https://docs.pytest.org/en/latest/\" rel=\"nofollow\">pytest</a>\nthen you don\u2019t need to do anything else - Automock registers a pytest plugin\n(named <tt>automock</tt> in pytest) that ensures your test cases all run patched.</p>\n</li>\n<li><p>If you\u2019re running under another test-runner then your test cases need to inherit\nfrom one of our helper classes, e.g.:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automock</span> <span class=\"kn\">import</span> <span class=\"n\">AutomockTestCase</span><span class=\"p\">,</span> <span class=\"n\">AutomockTestCaseMixin</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TestWebViews</span><span class=\"p\">(</span><span class=\"n\">AutomockTestCase</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TestSpecialViews</span><span class=\"p\">(</span><span class=\"n\">AutomockTestCaseMixin</span><span class=\"p\">,</span> <span class=\"n\">MyCustomTestCase</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>This will ensure the mock patches get applied before the tests run, and stopped\nafterwards.</p>\n<p>Alternatively you can start/stop patching manually:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">unittest</span> <span class=\"kn\">import</span> <span class=\"n\">TestCase</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">automock</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TestStuff</span><span class=\"p\">(</span><span class=\"n\">TestCase</span><span class=\"p\">):</span>\n\n    <span class=\"c1\"># as a decorator</span>\n    <span class=\"nd\">@automock</span><span class=\"o\">.</span><span class=\"n\">activate</span><span class=\"p\">()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">test_stuff</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># automocks active</span>\n        <span class=\"o\">...</span>\n\n    <span class=\"c1\"># as a context-manager</span>\n    <span class=\"k\">def</span> <span class=\"nf\">test_other_stuff</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"c1\"># automocks inactive</span>\n        <span class=\"o\">...</span>\n        <span class=\"k\">with</span> <span class=\"n\">automock</span><span class=\"o\">.</span><span class=\"n\">activate</span><span class=\"p\">():</span>\n            <span class=\"c1\"># automocks active</span>\n            <span class=\"o\">...</span>\n\n        <span class=\"c1\"># automocks inactive</span>\n</pre>\n</li>\n</ol>\n</div>\n<div id=\"configuration\">\n<h3>Configuration</h3>\n<p>Settings are intended to be configured primarily via a python file, such\nas your existing Django <tt>settings.py</tt>. To bootstrap this, there are a couple\nof <strong>env vars</strong> to control how config is loaded:</p>\n<ul>\n<li><tt>AUTOMOCK_APP_CONFIG</tt>\nshould be an import path to a python module, for example:\n<tt>AUTOMOCK_APP_CONFIG=django.conf.settings</tt></li>\n<li><tt>AUTOMOCK_CONFIG_NAMESPACE</tt>\nSets the prefix used for loading further config values from env and\nconfig file. Defaults to <tt>AUTOMOCK</tt>.</li>\n</ul>\n<p>The following config keys are available (and are prefixed with\n<tt>AUTOMOCK_</tt> by default, see <tt>AUTOMOCK_CONFIG_NAMESPACE</tt> above):</p>\n<ul>\n<li><tt>&lt;namespace&gt;_REGISTRATION_IMPORTS</tt> list of import paths to modules\ncontaining <tt>automock.register</tt> calls</li>\n</ul>\n</div>\n<div id=\"patching-and-imports\">\n<h3>Patching and imports</h3>\n<p>An <strong>important point to note</strong> about the path you mock:</p>\n<p>This has the same caveats as when using <tt>mock.patch</tt> directly. Namely that\nyou must patch the path <em>where it is imported</em>.</p>\n<p>For example if you do:</p>\n<pre><span class=\"c1\"># mypackage/mymodule.py</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">services.product.client</span> <span class=\"kn\">import</span> <span class=\"n\">get_product</span>\n</pre>\n<p>When you patch it:</p>\n<pre><span class=\"c1\"># won't work:</span>\n<span class=\"n\">patch</span><span class=\"p\">(</span><span class=\"s1\">'services.product.client.get_product'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># works:</span>\n<span class=\"n\">patch</span><span class=\"p\">(</span><span class=\"s1\">'mypackage.mymodule.get_product'</span><span class=\"p\">)</span>\n</pre>\n<p>DON\u2019T DO THIS (see this\n<a href=\"http://bhfsteve.blogspot.co.uk/2012/06/patching-tip-using-mocks-in-python-unit.html\" rel=\"nofollow\">blog post</a>\nfor more details).</p>\n<p>This import style will cause us problems if we want to mock-by-default all\nusages of a particular function, because we only register a single path to mock.</p>\n<p>Instead you need to use one of the following import styles <em>everywhere</em> in your\ncodebase that the function to mocked is used:</p>\n<pre><span class=\"c1\"># mypackage/mymodule.py</span>\n\n<span class=\"c1\"># either</span>\n<span class=\"kn\">from</span> <span class=\"nn\">services.product</span> <span class=\"kn\">import</span> <span class=\"n\">client</span> <span class=\"k\">as</span> <span class=\"n\">product_client</span>\n<span class=\"n\">product_client</span><span class=\"o\">.</span><span class=\"n\">get_product</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># or</span>\n<span class=\"kn\">import</span> <span class=\"nn\">services.product.client</span> <span class=\"k\">as</span> <span class=\"nn\">product_client</span>\n<span class=\"n\">product_client</span><span class=\"o\">.</span><span class=\"n\">get_product</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">)</span>\n</pre>\n<p>This will ensure that we can:</p>\n<pre><span class=\"n\">automock</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s1\">'services.product.client.get_product'</span><span class=\"p\">)</span>\n</pre>\n<p>and have that work reliably.</p>\n<p><strong>NOTE:</strong></p>\n<p>Always <tt>import automock</tt> and use as <tt>automock.register</tt> to ensure there is\nonly one registry active.</p>\n</div>\n<div id=\"customising-mock-factories\">\n<h3>Customising mock factories</h3>\n<p>It\u2019s likely you need to do more than provide a bare <tt>MagicMock</tt>. For example\nwe might want to customise the response based on some values from the request.</p>\n<p>In <tt>mock.Mock</tt> this is achieved via a \u2018side effect\u2019. So we might want to\ndefine our mock factory like this:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">batch_counters_mock</span><span class=\"p\">(</span><span class=\"n\">return_value</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">side_effect</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">return_value</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"ow\">and</span> <span class=\"n\">side_effect</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">def</span> <span class=\"nf\">side_effect</span><span class=\"p\">(</span><span class=\"n\">product_ids</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">p_id</span><span class=\"p\">):</span> <span class=\"mi\">0</span> <span class=\"k\">for</span> <span class=\"n\">p_id</span> <span class=\"ow\">in</span> <span class=\"n\">product_ids</span><span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">mock</span><span class=\"o\">.</span><span class=\"n\">MagicMock</span><span class=\"p\">(</span><span class=\"n\">return_value</span><span class=\"o\">=</span><span class=\"n\">return_value</span><span class=\"p\">,</span> <span class=\"n\">side_effect</span><span class=\"o\">=</span><span class=\"n\">side_effect</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n<span class=\"n\">automock</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s1\">'services.products.client.batch_counters'</span><span class=\"p\">,</span> <span class=\"n\">batch_counters_mock</span><span class=\"p\">)</span>\n</pre>\n<p>Note that we passed the custom mock factory as second argument to <tt>register</tt>.</p>\n<p>As an alternative we can use decorator syntax:</p>\n<pre><span class=\"nd\">@automock</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s1\">'services.products.client.batch_counters'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">batch_counters_mock</span><span class=\"p\">(</span><span class=\"n\">return_value</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">side_effect</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">return_value</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"ow\">and</span> <span class=\"n\">side_effect</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">def</span> <span class=\"nf\">side_effect</span><span class=\"p\">(</span><span class=\"n\">product_ids</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">p_id</span><span class=\"p\">):</span> <span class=\"mi\">0</span> <span class=\"k\">for</span> <span class=\"n\">p_id</span> <span class=\"ow\">in</span> <span class=\"n\">product_ids</span><span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">mock</span><span class=\"o\">.</span><span class=\"n\">MagicMock</span><span class=\"p\">(</span><span class=\"n\">return_value</span><span class=\"o\">=</span><span class=\"n\">return_value</span><span class=\"p\">,</span> <span class=\"n\">side_effect</span><span class=\"o\">=</span><span class=\"n\">side_effect</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n</pre>\n<p>Now in our tests we can:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">services.products.client</span> <span class=\"k\">as</span> <span class=\"nn\">products_client</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_counters</span><span class=\"p\">():</span>\n    <span class=\"n\">counters</span> <span class=\"o\">=</span> <span class=\"n\">products_client</span><span class=\"o\">.</span><span class=\"n\">batch_counters</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n    <span class=\"c1\"># we got a default value for each of the ids we passed in:</span>\n    <span class=\"k\">assert</span> <span class=\"n\">counters</span> <span class=\"o\">==</span> <span class=\"p\">{</span><span class=\"s1\">'1'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s1\">'2'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">}</span>\n</pre>\n<p>(This is a useless test of course, it\u2019s just to demonstrate the mocking)</p>\n<p>Okay. What if we need a custom return value for a particular test?</p>\n<p>Well, firstly the regular <tt>mock.patch</tt> still works, you could apply that in\nyour test case.</p>\n<p>Automock also provides a <tt>swap_mock</tt> helper that allows us to take advantage\nof our custom mock factory.</p>\n<p>Let\u2019s say our factory looks like:</p>\n<pre><span class=\"nd\">@automock</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s1\">'services.things.client.do_something'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">do_something_mock</span><span class=\"p\">(</span><span class=\"n\">success</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">success</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">mock</span><span class=\"o\">.</span><span class=\"n\">MagicMock</span><span class=\"p\">(</span><span class=\"n\">return_value</span><span class=\"o\">=</span><span class=\"s1\">'OK'</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">mock</span><span class=\"o\">.</span><span class=\"n\">MagicMock</span><span class=\"p\">(</span><span class=\"n\">side_effect</span><span class=\"o\">=</span><span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">HTTPError</span><span class=\"p\">())</span>\n</pre>\n<p>In our tests we can:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pytest</span>\n<span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n<span class=\"kn\">from</span> <span class=\"nn\">automock</span> <span class=\"kn\">import</span> <span class=\"n\">swap_mock</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">services.things.client</span> <span class=\"k\">as</span> <span class=\"nn\">things_client</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_success</span><span class=\"p\">():</span>\n    <span class=\"c1\"># default mock from factory gives success response</span>\n    <span class=\"k\">assert</span> <span class=\"n\">things_client</span><span class=\"o\">.</span><span class=\"n\">do_something</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"s1\">'OK'</span>\n\n<span class=\"nd\">@swap_mock</span><span class=\"p\">(</span><span class=\"s1\">'services.things.client.do_something'</span><span class=\"p\">,</span> <span class=\"n\">success</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">test_fail</span><span class=\"p\">():</span>\n    <span class=\"c1\"># swap mock applies a customised mock from our factory</span>\n    <span class=\"k\">with</span> <span class=\"n\">pytest</span><span class=\"o\">.</span><span class=\"n\">raises</span><span class=\"p\">(</span><span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">HTPPError</span><span class=\"p\">):</span>\n        <span class=\"n\">things_client</span><span class=\"o\">.</span><span class=\"n\">do_something</span><span class=\"p\">()</span>\n</pre>\n<p>What happened here is that the <tt>*args, **kwargs</tt> from our <tt>swap_mock</tt> call\nare passed through to the <tt>do_something_mock</tt> to <em>get a new mock</em> which is\nthen applied in place of the default.</p>\n<p>We can also use this as a context manager:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pytest</span>\n<span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n<span class=\"kn\">from</span> <span class=\"nn\">automock</span> <span class=\"kn\">import</span> <span class=\"n\">swap_mock</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">services.things.client</span> <span class=\"k\">as</span> <span class=\"nn\">things_client</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_do_something</span><span class=\"p\">():</span>\n    <span class=\"k\">assert</span> <span class=\"n\">things_client</span><span class=\"o\">.</span><span class=\"n\">do_something</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"s1\">'OK'</span>\n\n    <span class=\"k\">with</span> <span class=\"n\">swap_mock</span><span class=\"p\">(</span><span class=\"s1\">'services.things.client.do_something'</span><span class=\"p\">,</span> <span class=\"n\">success</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n        <span class=\"k\">with</span> <span class=\"n\">pytest</span><span class=\"o\">.</span><span class=\"n\">raises</span><span class=\"p\">(</span><span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">HTPPError</span><span class=\"p\">):</span>\n            <span class=\"n\">things_client</span><span class=\"o\">.</span><span class=\"n\">do_something</span><span class=\"p\">()</span>\n\n    <span class=\"k\">assert</span> <span class=\"n\">things_client</span><span class=\"o\">.</span><span class=\"n\">do_something</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"s1\">'OK'</span>\n</pre>\n</div>\n<div id=\"checking-mocked-calls\">\n<h3>Checking mocked calls</h3>\n<p>It\u2019s common in tests to want to check if a mocked function was called, and\nwith correct arguments etc. If you use <tt>mock.patch</tt> directly this is easy\nbecause it returns the mock object to you.</p>\n<p>Automock provides the <tt>get_mock</tt> helper to achieve the same thing:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">automock</span> <span class=\"kn\">import</span> <span class=\"n\">get_mock</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">services.things.client</span> <span class=\"k\">as</span> <span class=\"nn\">things_client</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_success</span><span class=\"p\">():</span>\n    <span class=\"k\">assert</span> <span class=\"n\">things_client</span><span class=\"o\">.</span><span class=\"n\">do_something</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"s1\">'OK'</span>\n    <span class=\"n\">mocked</span> <span class=\"o\">=</span> <span class=\"n\">get_mock</span><span class=\"p\">(</span><span class=\"s1\">'services.things.client.do_something'</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">mocked</span><span class=\"o\">.</span><span class=\"n\">called</span>\n</pre>\n</div>\n<div id=\"testing-the-automocked-functions\">\n<h3>Testing the automocked functions</h3>\n<p>Ok, so you\u2019ve mocked your API clients or whatever. How do you test the mocked\nfunctions themselves if they\u2019re mocked out everywhere?</p>\n<p>Firstly, you could just not inherit from <tt>AutomockTestCase</tt> in those tests.</p>\n<p>But maybe you have a bunch of other automocks you want to keep in place still.</p>\n<p>Automock provides an <tt>unmock</tt> helper:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pytest</span>\n<span class=\"kn\">import</span> <span class=\"nn\">responses</span>\n<span class=\"kn\">from</span> <span class=\"nn\">automock</span> <span class=\"kn\">import</span> <span class=\"n\">unmock</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">services.things.client</span> <span class=\"k\">as</span> <span class=\"nn\">things_client</span>\n\n<span class=\"nd\">@responses</span><span class=\"o\">.</span><span class=\"n\">activate</span>\n<span class=\"nd\">@unmock</span><span class=\"p\">(</span><span class=\"s1\">'services.things.client.do_something'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">test_do_something_not_found</span><span class=\"p\">():</span>\n    <span class=\"n\">responses</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">responses</span><span class=\"o\">.</span><span class=\"n\">GET</span><span class=\"p\">,</span> <span class=\"s1\">'https://thingservice.ourcompany.com/api/1/something'</span><span class=\"p\">,</span>\n                  <span class=\"n\">json</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'error'</span><span class=\"p\">:</span> <span class=\"s1\">'Not Found'</span><span class=\"p\">},</span> <span class=\"n\">status</span><span class=\"o\">=</span><span class=\"mi\">404</span><span class=\"p\">)</span>\n    <span class=\"k\">with</span> <span class=\"n\">pytest</span><span class=\"o\">.</span><span class=\"n\">raises</span><span class=\"p\">(</span><span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">HTPPError</span><span class=\"p\">):</span>\n        <span class=\"n\">things_client</span><span class=\"o\">.</span><span class=\"n\">do_something</span><span class=\"p\">()</span>\n</pre>\n<p>(for functions which make HTTP calls we recommend the excellent\n<a href=\"https://github.com/getsentry/responses\" rel=\"nofollow\">responses</a> library)</p>\n<p>Here we have un-mocked our client method so that we can test that it correctly\nhandles a 404 response from the remote service.</p>\n</div>\n</div>\n<div id=\"compatibility\">\n<h2>Compatibility</h2>\n<p>This project is tested against:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>Python 2.7</td>\n<td><ul>\n<li>\n</ul>\n</td>\n</tr>\n<tr><td>Python 3.6</td>\n<td><ul>\n<li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"running-the-tests\">\n<h2>Running the tests</h2>\n<div id=\"circleci\">\n<h3>CircleCI</h3>\n<div>\n<div>The easiest way to test the full version matrix is to install the\nCircleCI command line app:</div>\n<div><a href=\"https://circleci.com/docs/2.0/local-jobs/\" rel=\"nofollow\">https://circleci.com/docs/2.0/local-jobs/</a></div>\n<div>(requires Docker)</div>\n</div>\n<p>The cli does not support \u2018workflows\u2019 at the moment so you have to run\nthe two Python version jobs separately:</p>\n<pre>circleci build --job python-2.7\n</pre>\n<pre>circleci build --job python-3.6\n</pre>\n</div>\n<div id=\"py-test-single-python-version\">\n<h3>py.test (single python version)</h3>\n<p>It\u2019s also possible to run the tests locally, allowing for debugging of\nerrors that occur.</p>\n<p>Now decide which Python version you want to test and create a virtualenv:</p>\n<pre>pyenv virtualenv <span class=\"m\">3</span>.6.4 automock\npip install -r requirements-test.txt\n</pre>\n<p>Now we can run the tests:</p>\n<pre>make <span class=\"nb\">test</span>\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4955254, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "90438dc7ff8218c4ad03cbe5f8f5c59f", "sha256": "bc6456d79bc93ca7405005f9967bcba49da37a917b218f0c2951178ac574b921"}, "downloads": -1, "filename": "automock-1.0.0.tar.gz", "has_sig": false, "md5_digest": "90438dc7ff8218c4ad03cbe5f8f5c59f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9959, "upload_time": "2018-03-13T15:16:47", "upload_time_iso_8601": "2018-03-13T15:16:47.442802Z", "url": "https://files.pythonhosted.org/packages/a8/b5/f0709eaf9604189f850a4d3e0d2be8070368589e45f7de2777afacc2841e/automock-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "7c8d8c4f75407ee8fa69c3c7a50de683", "sha256": "10b3faef03b66e54cac4578330a86a25f22198df1f9f5f5ccac2169e65585ff3"}, "downloads": -1, "filename": "automock-1.0.1.tar.gz", "has_sig": false, "md5_digest": "7c8d8c4f75407ee8fa69c3c7a50de683", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10066, "upload_time": "2018-03-13T16:28:34", "upload_time_iso_8601": "2018-03-13T16:28:34.019260Z", "url": "https://files.pythonhosted.org/packages/5e/4a/c1f847a5cd219691bff4ff9e9353e36d90ef05ab122427d55d8fe3fe95e6/automock-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "e76eba4a3dfd56e844372a319eb47ddc", "sha256": "93f49e4d17551a7609d6e7f6bde0f65d70d84a54215b62df857ead260ca4e288"}, "downloads": -1, "filename": "automock-1.0.2.tar.gz", "has_sig": false, "md5_digest": "e76eba4a3dfd56e844372a319eb47ddc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10089, "upload_time": "2018-03-13T16:37:47", "upload_time_iso_8601": "2018-03-13T16:37:47.237718Z", "url": "https://files.pythonhosted.org/packages/ee/00/a99c3bd8e984f3f97b3dab309a3f1335642390143e2d277fc8a6ba793c90/automock-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "0c94abd200a949c2b0ac811942467437", "sha256": "a739868c90b5f8e3f4f51c2d082c1b640fd99232fbd7a1a18c1edb9e75f9c656"}, "downloads": -1, "filename": "automock-1.0.3.tar.gz", "has_sig": false, "md5_digest": "0c94abd200a949c2b0ac811942467437", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10321, "upload_time": "2018-03-13T16:41:08", "upload_time_iso_8601": "2018-03-13T16:41:08.969101Z", "url": "https://files.pythonhosted.org/packages/d8/5d/e10872866d332c0cfd6904229f854743d0f00dff62439fc824f691aaca05/automock-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "c5515ac04b6a966368575060e1697bc7", "sha256": "a3a0bf51e1daf5d8bc22a0cdbd5189ba9fd506a52c8bc87c16af6aa37b993dc9"}, "downloads": -1, "filename": "automock-1.0.4.tar.gz", "has_sig": false, "md5_digest": "c5515ac04b6a966368575060e1697bc7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10309, "upload_time": "2018-03-14T13:20:47", "upload_time_iso_8601": "2018-03-14T13:20:47.338502Z", "url": "https://files.pythonhosted.org/packages/1c/b8/27ecef6e439734e62a629dec1ec1ffb518757f70c9a7ebc1e3ae470f1e6a/automock-1.0.4.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "84380c90a0fc24ea5d19d3844e08ab34", "sha256": "b371bfcb429d965156128413551932d37abbe71bdcdf8947e1b519c30668897b"}, "downloads": -1, "filename": "automock-1.1.0.tar.gz", "has_sig": false, "md5_digest": "84380c90a0fc24ea5d19d3844e08ab34", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11012, "upload_time": "2018-03-16T22:10:03", "upload_time_iso_8601": "2018-03-16T22:10:03.655518Z", "url": "https://files.pythonhosted.org/packages/c5/7f/1ede3985bacbfda27c519bb03656b0d277542494eded0377524f14c758e4/automock-1.1.0.tar.gz", "yanked": false}], "1.1.0a1": [{"comment_text": "", "digests": {"md5": "b38ce396d578747a81796a982cd299fe", "sha256": "ec6bd15d38e5e59e7c9e88e66027165286249d97fc29a48ba247812a55f7abc9"}, "downloads": -1, "filename": "automock-1.1.0a1.tar.gz", "has_sig": false, "md5_digest": "b38ce396d578747a81796a982cd299fe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11007, "upload_time": "2018-03-16T22:09:45", "upload_time_iso_8601": "2018-03-16T22:09:45.423127Z", "url": "https://files.pythonhosted.org/packages/9d/b0/f6a66b1c32631a83b4938a6da626b86fdbf2b5647849c8415780160d6f47/automock-1.1.0a1.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "ade365d2d1c80e3a2311a270d4d4632e", "sha256": "b615f48b3ff0406f60974015ea9a41bf709615f65d77339a88b7e6d8a7b3dc92"}, "downloads": -1, "filename": "automock-1.1.1.tar.gz", "has_sig": false, "md5_digest": "ade365d2d1c80e3a2311a270d4d4632e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11084, "upload_time": "2019-02-20T12:19:13", "upload_time_iso_8601": "2019-02-20T12:19:13.741591Z", "url": "https://files.pythonhosted.org/packages/12/b9/6b2ee273106d93891f3b19ec85359fb7ca7bab2cc5f16ffb875f989e860c/automock-1.1.1.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "cbbf95bc3450c7cf3f221ecf78fab84b", "sha256": "70c96d7293749ed60adccd28e43165026395cc1750cf90084aeb38e2d1bcba3e"}, "downloads": -1, "filename": "automock-1.2.0.tar.gz", "has_sig": false, "md5_digest": "cbbf95bc3450c7cf3f221ecf78fab84b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11088, "upload_time": "2019-03-18T18:05:48", "upload_time_iso_8601": "2019-03-18T18:05:48.574935Z", "url": "https://files.pythonhosted.org/packages/3c/ba/b84676809b3528322ca61fcb6703b3704fe4c4b915b76c7d6959fddcbd1f/automock-1.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "cbbf95bc3450c7cf3f221ecf78fab84b", "sha256": "70c96d7293749ed60adccd28e43165026395cc1750cf90084aeb38e2d1bcba3e"}, "downloads": -1, "filename": "automock-1.2.0.tar.gz", "has_sig": false, "md5_digest": "cbbf95bc3450c7cf3f221ecf78fab84b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11088, "upload_time": "2019-03-18T18:05:48", "upload_time_iso_8601": "2019-03-18T18:05:48.574935Z", "url": "https://files.pythonhosted.org/packages/3c/ba/b84676809b3528322ca61fcb6703b3704fe4c4b915b76c7d6959fddcbd1f/automock-1.2.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:13 2020"}