{"info": {"author": "Patrick Maupin", "author_email": "pmaupin@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Multimedia :: Graphics :: Graphics Conversion", "Topic :: Printing", "Topic :: Software Development :: Libraries", "Topic :: Text Processing", "Topic :: Utilities"], "description": "==================\npdfrw 0.4\n==================\n\n:Author: Patrick Maupin\n\n.. contents::\n    :backlinks: none\n\n.. sectnum::\n\nIntroduction\n============\n\n**pdfrw** is a Python library and utility that reads and writes PDF files:\n\n* Version 0.4 is tested and works on Python 2.6, 2.7, 3.3, 3.4, 3.5, and 3.6\n* Operations include subsetting, merging, rotating, modifying metadata, etc.\n* The fastest pure Python PDF parser available\n* Has been used for years by a printer in pre-press production\n* Can be used with rst2pdf to faithfully reproduce vector images\n* Can be used either standalone, or in conjunction with `reportlab`__\n  to reuse existing PDFs in new ones\n* Permissively licensed\n\n__ http://www.reportlab.org/\n\n\npdfrw will faithfully reproduce vector formats without\nrasterization, so the rst2pdf package has used pdfrw\nfor PDF and SVG images by default since March 2010.\n\npdfrw can also be used in conjunction with reportlab, in order\nto re-use portions of existing PDFs in new PDFs created with\nreportlab.\n\n\nExamples\n=========\n\nThe library comes with several examples that show operation both with\nand without reportlab.\n\n\nAll examples\n------------------\n\nThe examples directory has a few scripts which use the library.\nNote that if these examples do not work with your PDF, you should\ntry to use pdftk to uncompress and/or unencrypt them first.\n\n* `4up.py`__ will shrink pages down and place 4 of them on\n  each output page.\n* `alter.py`__ shows an example of modifying metadata, without\n  altering the structure of the PDF.\n* `booklet.py`__ shows an example of creating a 2-up output\n  suitable for printing and folding (e.g on tabloid size paper).\n* `cat.py`__ shows an example of concatenating multiple PDFs together.\n* `extract.py`__ will extract images and Form XObjects (embedded pages)\n  from existing PDFs to make them easier to use and refer to from\n  new PDFs (e.g. with reportlab or rst2pdf).\n* `poster.py`__ increases the size of a PDF so it can be printed\n  as a poster.\n* `print_two.py`__ Allows creation of 8.5 X 5.5\" booklets by slicing\n  8.5 X 11\" paper apart after printing.\n* `rotate.py`__ Rotates all or selected pages in a PDF.\n* `subset.py`__ Creates a new PDF with only a subset of pages from the\n  original.\n* `unspread.py`__ Takes a 2-up PDF, and splits out pages.\n* `watermark.py`__ Adds a watermark PDF image over or under all the pages\n  of a PDF.\n* `rl1/4up.py`__ Another 4up example, using reportlab canvas for output.\n* `rl1/booklet.py`__ Another booklet example, using reportlab canvas for\n  output.\n* `rl1/subset.py`__ Another subsetting example, using reportlab canvas for\n  output.\n* `rl1/platypus_pdf_template.py`__ Another watermarking example, using\n  reportlab canvas and generated output for the document.  Contributed\n  by user asannes.\n* `rl2`__ Experimental code for parsing graphics.  Needs work.\n* `subset_booklets.py`__ shows an example of creating a full printable pdf\n  version in a more professional and pratical way ( take a look at\n  http://www.wikihow.com/Bind-a-Book )\n\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/4up.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/alter.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/booklet.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/cat.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/extract.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/poster.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/print_two.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/rotate.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/subset.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/unspread.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/watermark.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/4up.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/booklet.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/subset.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/platypus_pdf_template.py\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl2/\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/subset_booklets.py\n\nNotes on selected examples\n------------------------------------\n\nReorganizing pages and placing them two-up\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA printer with a fancy printer and/or a full-up copy of Acrobat can\neasily turn your small PDF into a little booklet (for example, print 4\nletter-sized pages on a single 11\" x 17\").\n\nBut that assumes several things, including that the personnel know how\nto operate the hardware and software. `booklet.py`__ lets you turn your PDF\ninto a preformatted booklet, to give them fewer chances to mess it up.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/booklet.py\n\nAdding or modifying metadata\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe `cat.py`__ example will accept multiple input files on the command\nline, concatenate them and output them to output.pdf, after adding some\nnonsensical metadata to the output PDF file.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/cat.py\n\nThe `alter.py`__ example alters a single metadata item in a PDF,\nand writes the result to a new PDF.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/alter.py\n\n\nOne difference is that, since **cat** is creating a new PDF structure,\nand **alter** is attempting to modify an existing PDF structure, the\nPDF produced by alter (and also by watermark.py) *should* be\nmore faithful to the original (except for the desired changes).\n\nFor example, the alter.py navigation should be left intact, whereas with\ncat.py it will be stripped.\n\n\nRotating and doubling\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you ever want to print something that is like a small booklet, but\nneeds to be spiral bound, you either have to do some fancy rearranging,\nor just waste half your paper.\n\nThe `print_two.py`__ example program will, for example, make two side-by-side\ncopies each page of of your PDF on a each output sheet.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/print_two.py\n\nBut, every other page is flipped, so that you can print double-sided and\nthe pages will line up properly and be pre-collated.\n\nGraphics stream parsing proof of concept\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe `copy.py`__ script shows a simple example of reading in a PDF, and\nusing the decodegraphics.py module to try to write the same information\nout to a new PDF through a reportlab canvas. (If you know about reportlab,\nyou know that if you can faithfully render a PDF to a reportlab canvas, you\ncan do pretty much anything else with that PDF you want.) This kind of\nlow level manipulation should be done only if you really need to.\ndecodegraphics is really more than a proof of concept than anything\nelse. For most cases, just use the Form XObject capability, as shown in\nthe examples/rl1/booklet.py demo.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/examples/rl2/copy.py\n\npdfrw philosophy\n==================\n\nCore library\n-------------\n\nThe philosophy of the library portion of pdfrw is to provide intuitive\nfunctions to read, manipulate, and write PDF files.  There should be\nminimal leakage between abstraction layers, although getting useful\nwork done makes \"pure\" functionality separation difficult.\n\nA key concept supported by the library is the use of Form XObjects,\nwhich allow easy embedding of pieces of one PDF into another.\n\nAddition of core support to the library is typically done carefully\nand thoughtfully, so as not to clutter it up with too many special\ncases.\n\nThere are a lot of incorrectly formatted PDFs floating around; support\nfor these is added in some cases.  The decision is often based on what\nacroread and okular do with the PDFs; if they can display them properly,\nthen eventually pdfrw should, too, if it is not too difficult or costly.\n\nContributions are welcome; one user has contributed some decompression\nfilters and the ability to process PDF 1.5 stream objects.  Additional\nfunctionality that would obviously be useful includes additional\ndecompression filters, the ability to process password-protected PDFs,\nand the ability to output linearized PDFs.\n\nExamples\n--------\n\nThe philosophy of the examples is to provide small, easily-understood\nexamples that showcase pdfrw functionality.\n\n\nPDF files and Python\n======================\n\nIntroduction\n------------\n\nIn general, PDF files conceptually map quite well to Python. The major\nobjects to think about are:\n\n-  **strings**. Most things are strings. These also often decompose\n   naturally into\n-  **lists of tokens**. Tokens can be combined to create higher-level\n   objects like\n-  **arrays** and\n-  **dictionaries** and\n-  **Contents streams** (which can be more streams of tokens)\n\nDifficulties\n------------\n\nThe apparent primary difficulty in mapping PDF files to Python is the\nPDF file concept of \"indirect objects.\"  Indirect objects provide\nthe efficiency of allowing a single piece of data to be referred to\nfrom more than one containing object, but probably more importantly,\nindirect objects provide a way to get around the chicken and egg\nproblem of circular object references when mapping arbitrary data\nstructures to files. To flatten out a circular reference, an indirect\nobject is *referred to* instead of being *directly included* in another\nobject. PDF files have a global mechanism for locating indirect objects,\nand they all have two reference numbers (a reference number and a\n\"generation\" number, in case you wanted to append to the PDF file\nrather than just rewriting the whole thing).\n\npdfrw automatically handles indirect references on reading in a PDF\nfile. When pdfrw encounters an indirect PDF file object, the\ncorresponding Python object it creates will have an 'indirect' attribute\nwith a value of True. When writing a PDF file, if you have created\narbitrary data, you just need to make sure that circular references are\nbroken up by putting an attribute named 'indirect' which evaluates to\nTrue on at least one object in every cycle.\n\nAnother PDF file concept that doesn't quite map to regular Python is a\n\"stream\". Streams are dictionaries which each have an associated\nunformatted data block. pdfrw handles streams by placing a special\nattribute on a subclassed dictionary.\n\nUsage Model\n-----------\n\nThe usage model for pdfrw treats most objects as strings (it takes their\nstring representation when writing them to a file). The two main\nexceptions are the PdfArray object and the PdfDict object.\n\nPdfArray is a subclass of list with two special features.  First,\nan 'indirect' attribute allows a PdfArray to be written out as\nan indirect PDF object.  Second, pdfrw reads files lazily, so\nPdfArray knows about, and resolves references to other indirect\nobjects on an as-needed basis.\n\nPdfDict is a subclass of dict that also has an indirect attribute\nand lazy reference resolution as well.  (And the subclassed\nIndirectPdfDict has indirect automatically set True).\n\nBut PdfDict also has an optional associated stream. The stream object\ndefaults to None, but if you assign a stream to the dict, it will\nautomatically set the PDF /Length attribute for the dictionary.\n\nFinally, since PdfDict instances are indexed by PdfName objects (which\nalways start with a /) and since most (all?) standard Adobe PdfName\nobjects use names formatted like \"/CamelCase\", it makes sense to allow\naccess to dictionary elements via object attribute accesses as well as\nobject index accesses. So usage of PdfDict objects is normally via\nattribute access, although non-standard names (though still with a\nleading slash) can be accessed via dictionary index lookup.\n\nReading PDFs\n~~~~~~~~~~~~~~~\n\nThe PdfReader object is a subclass of PdfDict, which allows easy access\nto an entire document::\n\n    >>> from pdfrw import PdfReader\n    >>> x = PdfReader('source.pdf')\n    >>> x.keys()\n    ['/Info', '/Size', '/Root']\n    >>> x.Info\n    {'/Producer': '(cairo 1.8.6 (http://cairographics.org))',\n     '/Creator': '(cairo 1.8.6 (http://cairographics.org))'}\n    >>> x.Root.keys()\n    ['/Type', '/Pages']\n\nInfo, Size, and Root are retrieved from the trailer of the PDF file.\n\nIn addition to the tree structure, pdfrw creates a special attribute\nnamed *pages*, that is a list of all the pages in the document. pdfrw\ncreates the *pages* attribute as a simplification for the user, because\nthe PDF format allows arbitrarily complicated nested dictionaries to\ndescribe the page order. Each entry in the *pages* list is the PdfDict\nobject for one of the pages in the file, in order.\n\n::\n\n    >>> len(x.pages)\n    1\n    >>> x.pages[0]\n    {'/Parent': {'/Kids': [{...}], '/Type': '/Pages', '/Count': '1'},\n     '/Contents': {'/Length': '11260', '/Filter': None},\n     '/Resources': ... (Lots more stuff snipped)\n    >>> x.pages[0].Contents\n    {'/Length': '11260', '/Filter': None}\n    >>> x.pages[0].Contents.stream\n    'q\\n1 1 1 rg /a0 gs\\n0 0 0 RG 0.657436\n      w\\n0 J\\n0 j\\n[] 0.0 d\\n4 M q' ... (Lots more stuff snipped)\n\nWriting PDFs\n~~~~~~~~~~~~~~~\n\nAs you can see, it is quite easy to dig down into a PDF document. But\nwhat about when it's time to write it out?\n\n::\n\n    >>> from pdfrw import PdfWriter\n    >>> y = PdfWriter()\n    >>> y.addpage(x.pages[0])\n    >>> y.write('result.pdf')\n\nThat's all it takes to create a new PDF. You may still need to read the\n`Adobe PDF reference manual`__ to figure out what needs to go *into*\nthe PDF, but at least you don't have to sweat actually building it\nand getting the file offsets right.\n\n__ http://www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf\n\nManipulating PDFs in memory\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor the most part, pdfrw tries to be agnostic about the contents of\nPDF files, and support them as containers, but to do useful work,\nsomething a little higher-level is required, so pdfrw works to\nunderstand a bit about the contents of the containers.  For example:\n\n-  PDF pages. pdfrw knows enough to find the pages in PDF files you read\n   in, and to write a set of pages back out to a new PDF file.\n-  Form XObjects. pdfrw can take any page or rectangle on a page, and\n   convert it to a Form XObject, suitable for use inside another PDF\n   file.  It knows enough about these to perform scaling, rotation,\n   and positioning.\n-  reportlab objects. pdfrw can recursively create a set of reportlab\n   objects from its internal object format. This allows, for example,\n   Form XObjects to be used inside reportlab, so that you can reuse\n   content from an existing PDF file when building a new PDF with\n   reportlab.\n\nThere are several examples that demonstrate these features in\nthe example code directory.\n\nMissing features\n~~~~~~~~~~~~~~~~~~~~~~~\n\nEven as a pure PDF container library, pdfrw comes up a bit short. It\ndoes not currently support:\n\n-  Most compression/decompression filters\n-  encryption\n\n`pdftk`__ is a wonderful command-line\ntool that can convert your PDFs to remove encryption and compression.\nHowever, in most cases, you can do a lot of useful work with PDFs\nwithout actually removing compression, because only certain elements\ninside PDFs are actually compressed.\n\n__ https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/\n\nLibrary internals\n==================\n\nIntroduction\n------------\n\n**pdfrw** currently consists of 19 modules organized into a main\npackage and one sub-package.\n\nThe `__init.py__`__ module does the usual thing of importing a few\nmajor attributes from some of the submodules, and the `errors.py`__\nmodule supports logging and exception generation.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/__init__.py\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/errors.py\n\n\nPDF object model support\n--------------------------\n\nThe `objects`__ sub-package contains one module for each of the\ninternal representations of the kinds of basic objects that exist\nin a PDF file, with the `objects/__init__.py`__ module in that\npackage simply gathering them up and making them available to the\nmain pdfrw package.\n\nOne feature that all the PDF object classes have in common is the\ninclusion of an 'indirect' attribute. If 'indirect' exists and evaluates\nto True, then when the object is written out, it is written out as an\nindirect object. That is to say, it is addressable in the PDF file, and\ncould be referenced by any number (including zero) of container objects.\nThis indirect object capability saves space in PDF files by allowing\nobjects such as fonts to be referenced from multiple pages, and also\nallows PDF files to contain internal circular references.  This latter\ncapability is used, for example, when each page object has a \"parent\"\nobject in its dictionary.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/__init__.py\n\nOrdinary objects\n~~~~~~~~~~~~~~~~\n\nThe `objects/pdfobject.py`__ module contains the PdfObject class, which is\na subclass of str, and is the catch-all object for any PDF file elements\nthat are not explicitly represented by other objects, as described below.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfobject.py\n\nName objects\n~~~~~~~~~~~~\n\nThe `objects/pdfname.py`__ module contains the PdfName singleton object,\nwhich will convert a string into a PDF name by prepending a slash. It can\nbe used either by calling it or getting an attribute, e.g.::\n\n    PdfName.Rotate == PdfName('Rotate') == PdfObject('/Rotate')\n\nIn the example above, there is a slight difference between the objects\nreturned from PdfName, and the object returned from PdfObject.  The\nPdfName objects are actually objects of class \"BasePdfName\".  This\nis important, because only these may be used as keys in PdfDict objects.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfname.py\n\nString objects\n~~~~~~~~~~~~~~\n\nThe `objects/pdfstring.py`__\nmodule contains the PdfString class, which is a subclass of str that is\nused to represent encoded strings in a PDF file. The class has encode\nand decode methods for the strings.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfstring.py\n\n\nArray objects\n~~~~~~~~~~~~~\n\nThe `objects/pdfarray.py`__\nmodule contains the PdfArray class, which is a subclass of list that is\nused to represent arrays in a PDF file. A regular list could be used\ninstead, but use of the PdfArray class allows for an indirect attribute\nto be set, and also allows for proxying of unresolved indirect objects\n(that haven't been read in yet) in a manner that is transparent to pdfrw\nclients.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfarray.py\n\nDict objects\n~~~~~~~~~~~~\n\nThe `objects/pdfdict.py`__\nmodule contains the PdfDict class, which is a subclass of dict that is\nused to represent dictionaries in a PDF file. A regular dict could be\nused instead, but the PdfDict class matches the requirements of PDF\nfiles more closely:\n\n* Transparent (from the library client's viewpoint) proxying\n  of unresolved indirect objects\n* Return of None for non-existent keys (like dict.get)\n* Mapping of attribute accesses to the dict itself\n  (pdfdict.Foo == pdfdict[NameObject('Foo')])\n* Automatic management of following stream and /Length attributes\n  for content dictionaries\n* Indirect attribute\n* Other attributes may be set for private internal use of the\n  library and/or its clients.\n* Support for searching parent dictionaries for PDF \"inheritable\"\n  attributes.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfdict.py\n\nIf a PdfDict has an associated data stream in the PDF file, the stream\nis accessed via the 'stream' (all lower-case) attribute.  Setting the\nstream attribute on the PdfDict will automatically set the /Length attribute\nas well.  If that is not what is desired (for example if the the stream\nis compressed), then _stream (same name with an underscore) may be used\nto associate the stream with the PdfDict without setting the length.\n\nTo set private attributes (that will not be written out to a new PDF\nfile) on a dictionary, use the 'private' attribute::\n\n    mydict.private.foo = 1\n\nOnce the attribute is set, it may be accessed directly as an attribute\nof the dictionary::\n\n    foo = mydict.foo\n\nSome attributes of PDF pages are \"inheritable.\"  That is, they may\nbelong to a parent dictionary (or a parent of a parent dictionary, etc.)\nThe \"inheritable\" attribute allows for easy discovery of these::\n\n    mediabox = mypage.inheritable.MediaBox\n\n\nProxy objects\n~~~~~~~~~~~~~\n\nThe `objects/pdfindirect.py`__\nmodule contains the PdfIndirect class, which is a non-transparent proxy\nobject for PDF objects that have not yet been read in and resolved from\na file. Although these are non-transparent inside the library, client code\nshould never see one of these -- they exist inside the PdfArray and PdfDict\ncontainer types, but are resolved before being returned to a client of\nthose types.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfindirect.py\n\n\nFile reading, tokenization and parsing\n--------------------------------------\n\n`pdfreader.py`__\ncontains the PdfReader class, which can read a PDF file (or be passed a\nfile object or already read string) and parse it. It uses the PdfTokens\nclass in `tokens.py`__  for low-level tokenization.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pdfreader.py\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/tokens.py\n\n\nThe PdfReader class does not, in general, parse into containers (e.g.\ninside the content streams). There is a proof of concept for doing that\ninside the examples/rl2 subdirectory, but that is slow and not well-developed,\nand not useful for most applications.\n\nAn instance of the PdfReader class is an instance of a PdfDict -- the\ntrailer dictionary of the PDF file, to be exact.  It will have a private\nattribute set on it that is named 'pages' that is a list containing all\nthe pages in the file.\n\nWhen instantiating a PdfReader object, there are options available\nfor decompressing all the objects in the file.  pdfrw does not currently\nhave very many options for decompression, so this is not all that useful,\nexcept in the specific case of compressed object streams.\n\nAlso, there are no options for decryption yet.  If you have PDF files\nthat are encrypted or heavily compressed, you may find that using another\nprogram like pdftk on them can make them readable by pdfrw.\n\nIn general, the objects are read from the file lazily, but this is not\ncurrently true with compressed object streams -- all of these are decompressed\nand read in when the PdfReader is instantiated.\n\n\nFile output\n-----------\n\n`pdfwriter.py`__\ncontains the PdfWriter class, which can create and output a PDF file.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pdfwriter.py\n\nThere are a few options available when creating and using this class.\n\nIn the simplest case, an instance of PdfWriter is instantiated, and\nthen pages are added to it from one or more source files (or created\nprogrammatically), and then the write method is called to dump the\nresults out to a file.\n\nIf you have a source PDF and do not want to disturb the structure\nof it too badly, then you may pass its trailer directly to PdfWriter\nrather than letting PdfWriter construct one for you.  There is an\nexample of this (alter.py) in the examples directory.\n\n\nAdvanced features\n-----------------\n\n`buildxobj.py`__\ncontains functions to build Form XObjects out of pages or rectangles on\npages.  These may be reused in new PDFs essentially as if they were images.\n\nbuildxobj is careful to cache any page used so that it only appears in\nthe output once.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/buildxobj.py\n\n\n`toreportlab.py`__\nprovides the makerl function, which will translate pdfrw objects into a\nformat which can be used with `reportlab <http://www.reportlab.org/>`__.\nIt is normally used in conjunction with buildxobj, to be able to reuse\nparts of existing PDFs when using reportlab.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/toreportlab.py\n\n\n`pagemerge.py`__ builds on the foundation laid by buildxobj.  It\ncontains classes to create a new page (or overlay an existing page)\nusing one or more rectangles from other pages.  There are examples\nshowing its use for watermarking, scaling, 4-up output, splitting\neach page in 2, etc.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pagemerge.py\n\n`findobjs.py`__ contains code that can find specific kinds of objects\ninside a PDF file.  The extract.py example uses this module to create\na new PDF that places each image and Form XObject from a source PDF onto\nits own page, e.g. for easy reuse with some of the other examples or\nwith reportlab.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/findobjs.py\n\n\nMiscellaneous\n----------------\n\n`compress.py`__ and `uncompress.py`__\ncontains compression and decompression functions. Very few filters are\ncurrently supported, so an external tool like pdftk might be good if you\nrequire the ability to decompress (or, for that matter, decrypt) PDF\nfiles.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/compress.py\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/uncompress.py\n\n\n`py23_diffs.py`__ contains code to help manage the differences between\nPython 2 and Python 3.\n\n__ https://github.com/pmaupin/pdfrw/tree/master/pdfrw/py23_diffs.py\n\nTesting\n===============\n\nThe tests associated with pdfrw require a large number of PDFs,\nwhich are not distributed with the library.\n\nTo run the tests:\n\n* Download or clone the full package from github.com/pmaupin/pdfrw\n* cd into the tests directory, and then clone the package\n  github.com/pmaupin/static_pdfs into a subdirectory (also named\n  static_pdfs).\n* Now the tests may be run from that directory using unittest, or\n  py.test, or nose.\n* travisci is used at github, and runs the tests with py.test\n\nOther libraries\n=====================\n\nPure Python\n-----------\n\n-  `reportlab <http://www.reportlab.org/>`__\n\n    reportlab is must-have software if you want to programmatically\n    generate arbitrary PDFs.\n\n-  `pyPdf <https://github.com/mstamy2/PyPDF2>`__\n\n    pyPdf is, in some ways, very full-featured. It can do decompression\n    and decryption and seems to know a lot about items inside at least\n    some kinds of PDF files. In comparison, pdfrw knows less about\n    specific PDF file features (such as metadata), but focuses on trying\n    to have a more Pythonic API for mapping the PDF file container\n    syntax to Python, and (IMO) has a simpler and better PDF file\n    parser.  The Form XObject capability of pdfrw means that, in many\n    cases, it does not actually need to decompress objects -- they\n    can be left compressed.\n\n-  `pdftools <http://www.boddie.org.uk/david/Projects/Python/pdftools/index.html>`__\n\n    pdftools feels large and I fell asleep trying to figure out how it\n    all fit together, but many others have done useful things with it.\n\n-  `pagecatcher <http://www.reportlab.com/docs/pagecatcher-ds.pdf>`__\n\n    My understanding is that pagecatcher would have done exactly what I\n    wanted when I built pdfrw. But I was on a zero budget, so I've never\n    had the pleasure of experiencing pagecatcher. I do, however, use and\n    like `reportlab <http://www.reportlab.org/>`__ (open source, from\n    the people who make pagecatcher) so I'm sure pagecatcher is great,\n    better documented and much more full-featured than pdfrw.\n\n-  `pdfminer <http://www.unixuser.org/~euske/python/pdfminer/index.html>`__\n\n    This looks like a useful, actively-developed program. It is quite\n    large, but then, it is trying to actively comprehend a full PDF\n    document. From the website:\n\n    \"PDFMiner is a suite of programs that help extracting and analyzing\n    text data of PDF documents. Unlike other PDF-related tools, it\n    allows to obtain the exact location of texts in a page, as well as\n    other extra information such as font information or ruled lines. It\n    includes a PDF converter that can transform PDF files into other\n    text formats (such as HTML). It has an extensible PDF parser that\n    can be used for other purposes instead of text analysis.\"\n\nnon-pure-Python libraries\n-------------------------\n\n-  `pyPoppler <https://launchpad.net/poppler-python/>`__ can read PDF\n   files.\n-  `pycairo <http://www.cairographics.org/pycairo/>`__ can write PDF\n   files.\n-  `PyMuPDF <https://github.com/rk700/PyMuPDF>`_ high performance rendering\n   of PDF, (Open)XPS, CBZ and EPUB\n\nOther tools\n-----------\n\n-  `pdftk <https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/>`__ is a wonderful command\n   line tool for basic PDF manipulation. It complements pdfrw extremely\n   well, supporting many operations such as decryption and decompression\n   that pdfrw cannot do.\n-  `MuPDF <http://www.mupdf.com/>`_ is a free top performance PDF, (Open)XPS, CBZ and EPUB rendering library\n   that also comes with some command line tools. One of those, ``mutool``, has big overlaps with pdftk's - \n   except it is up to 10 times faster.\n\nRelease information\n=======================\n\nRevisions:\n\n0.4 -- Released 18 September, 2017\n\n    - Python 3.6 added to test matrix\n    - Proper unicode support for text strings in PDFs added\n    - buildxobj fixes allow better support creating form XObjects\n      out of compressed pages in some cases\n    - Compression fixes for Python 3+\n    - New subset_booklets.py example\n    - Bug with non-compressed indices into compressed object streams fixed\n    - Bug with distinguishing compressed object stream first objects fixed\n    - Better error reporting added for some invalid PDFs (e.g. when reading\n      past the end of file)\n    - Better scrubbing of old bookmark information when writing PDFs, to\n      remove dangling references\n    - Refactoring of pdfwriter, including updating API, to allow future\n      enhancements for things like incremental writing\n    - Minor tokenizer speedup\n    - Some flate decompressor bugs fixed\n    - Compression and decompression tests added\n    - Tests for new unicode handling added\n    - PdfReader.readpages() recursion error (issue #92) fixed.\n    - Initial crypt filter support added\n\n\n0.3 -- Released 19 October, 2016.\n\n    - Python 3.5 added to test matrix\n    - Better support under Python 3.x for in-memory PDF file-like objects\n    - Some pagemerge and Unicode patches added\n    - Changes to logging allow better coexistence with other packages\n    - Fix for \"from pdfrw import \\*\"\n    - New fancy_watermark.py example shows off capabilities of pagemerge.py\n    - metadata.py example renamed to cat.py\n\n\n0.2 -- Released 21 June, 2015.  Supports Python 2.6, 2.7, 3.3, and 3.4.\n\n    - Several bugs have been fixed\n    - New regression test functionally tests core with dozens of\n      PDFs, and also tests examples.\n    - Core has been ported and tested on Python3 by round-tripping\n      several difficult files and observing binary matching results\n      across the different Python versions.\n    - Still only minimal support for compression and no support\n      for encryption or newer PDF features.  (pdftk is useful\n      to put PDFs in a form that pdfrw can use.)\n\n0.1 -- Released to PyPI in 2012.  Supports Python 2.5 - 2.7\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pmaupin/pdfrw", "keywords": "pdf vector graphics PDF nup watermark split join merge", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pdfrw", "package_url": "https://pypi.org/project/pdfrw/", "platform": "Independent", "project_url": "https://pypi.org/project/pdfrw/", "project_urls": {"Homepage": "https://github.com/pmaupin/pdfrw"}, "release_url": "https://pypi.org/project/pdfrw/0.4/", "requires_dist": null, "requires_python": "", "summary": "PDF file reader/writer library", "version": "0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <table>\n<col>\n<col>\n<tbody>\n<tr><th>Author:</th>\n<td>Patrick Maupin</td></tr>\n</tbody>\n</table>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#introduction\" id=\"id49\" rel=\"nofollow\">1\u00a0\u00a0\u00a0Introduction</a></li>\n<li><a href=\"#examples\" id=\"id50\" rel=\"nofollow\">2\u00a0\u00a0\u00a0Examples</a><ul>\n<li><a href=\"#all-examples\" id=\"id51\" rel=\"nofollow\">2.1\u00a0\u00a0\u00a0All examples</a></li>\n<li><a href=\"#notes-on-selected-examples\" id=\"id52\" rel=\"nofollow\">2.2\u00a0\u00a0\u00a0Notes on selected examples</a><ul>\n<li><a href=\"#reorganizing-pages-and-placing-them-two-up\" id=\"id53\" rel=\"nofollow\">2.2.1\u00a0\u00a0\u00a0Reorganizing pages and placing them two-up</a></li>\n<li><a href=\"#adding-or-modifying-metadata\" id=\"id54\" rel=\"nofollow\">2.2.2\u00a0\u00a0\u00a0Adding or modifying metadata</a></li>\n<li><a href=\"#rotating-and-doubling\" id=\"id55\" rel=\"nofollow\">2.2.3\u00a0\u00a0\u00a0Rotating and doubling</a></li>\n<li><a href=\"#graphics-stream-parsing-proof-of-concept\" id=\"id56\" rel=\"nofollow\">2.2.4\u00a0\u00a0\u00a0Graphics stream parsing proof of concept</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#pdfrw-philosophy\" id=\"id57\" rel=\"nofollow\">3\u00a0\u00a0\u00a0pdfrw philosophy</a><ul>\n<li><a href=\"#core-library\" id=\"id58\" rel=\"nofollow\">3.1\u00a0\u00a0\u00a0Core library</a></li>\n<li><a href=\"#id24\" id=\"id59\" rel=\"nofollow\">3.2\u00a0\u00a0\u00a0Examples</a></li>\n</ul>\n</li>\n<li><a href=\"#pdf-files-and-python\" id=\"id60\" rel=\"nofollow\">4\u00a0\u00a0\u00a0PDF files and Python</a><ul>\n<li><a href=\"#id25\" id=\"id61\" rel=\"nofollow\">4.1\u00a0\u00a0\u00a0Introduction</a></li>\n<li><a href=\"#difficulties\" id=\"id62\" rel=\"nofollow\">4.2\u00a0\u00a0\u00a0Difficulties</a></li>\n<li><a href=\"#usage-model\" id=\"id63\" rel=\"nofollow\">4.3\u00a0\u00a0\u00a0Usage Model</a><ul>\n<li><a href=\"#reading-pdfs\" id=\"id64\" rel=\"nofollow\">4.3.1\u00a0\u00a0\u00a0Reading PDFs</a></li>\n<li><a href=\"#writing-pdfs\" id=\"id65\" rel=\"nofollow\">4.3.2\u00a0\u00a0\u00a0Writing PDFs</a></li>\n<li><a href=\"#manipulating-pdfs-in-memory\" id=\"id66\" rel=\"nofollow\">4.3.3\u00a0\u00a0\u00a0Manipulating PDFs in memory</a></li>\n<li><a href=\"#missing-features\" id=\"id67\" rel=\"nofollow\">4.3.4\u00a0\u00a0\u00a0Missing features</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#library-internals\" id=\"id68\" rel=\"nofollow\">5\u00a0\u00a0\u00a0Library internals</a><ul>\n<li><a href=\"#id28\" id=\"id69\" rel=\"nofollow\">5.1\u00a0\u00a0\u00a0Introduction</a></li>\n<li><a href=\"#pdf-object-model-support\" id=\"id70\" rel=\"nofollow\">5.2\u00a0\u00a0\u00a0PDF object model support</a><ul>\n<li><a href=\"#ordinary-objects\" id=\"id71\" rel=\"nofollow\">5.2.1\u00a0\u00a0\u00a0Ordinary objects</a></li>\n<li><a href=\"#name-objects\" id=\"id72\" rel=\"nofollow\">5.2.2\u00a0\u00a0\u00a0Name objects</a></li>\n<li><a href=\"#string-objects\" id=\"id73\" rel=\"nofollow\">5.2.3\u00a0\u00a0\u00a0String objects</a></li>\n<li><a href=\"#array-objects\" id=\"id74\" rel=\"nofollow\">5.2.4\u00a0\u00a0\u00a0Array objects</a></li>\n<li><a href=\"#dict-objects\" id=\"id75\" rel=\"nofollow\">5.2.5\u00a0\u00a0\u00a0Dict objects</a></li>\n<li><a href=\"#proxy-objects\" id=\"id76\" rel=\"nofollow\">5.2.6\u00a0\u00a0\u00a0Proxy objects</a></li>\n</ul>\n</li>\n<li><a href=\"#file-reading-tokenization-and-parsing\" id=\"id77\" rel=\"nofollow\">5.3\u00a0\u00a0\u00a0File reading, tokenization and parsing</a></li>\n<li><a href=\"#file-output\" id=\"id78\" rel=\"nofollow\">5.4\u00a0\u00a0\u00a0File output</a></li>\n<li><a href=\"#advanced-features\" id=\"id79\" rel=\"nofollow\">5.5\u00a0\u00a0\u00a0Advanced features</a></li>\n<li><a href=\"#miscellaneous\" id=\"id80\" rel=\"nofollow\">5.6\u00a0\u00a0\u00a0Miscellaneous</a></li>\n</ul>\n</li>\n<li><a href=\"#testing\" id=\"id81\" rel=\"nofollow\">6\u00a0\u00a0\u00a0Testing</a></li>\n<li><a href=\"#other-libraries\" id=\"id82\" rel=\"nofollow\">7\u00a0\u00a0\u00a0Other libraries</a><ul>\n<li><a href=\"#pure-python\" id=\"id83\" rel=\"nofollow\">7.1\u00a0\u00a0\u00a0Pure Python</a></li>\n<li><a href=\"#non-pure-python-libraries\" id=\"id84\" rel=\"nofollow\">7.2\u00a0\u00a0\u00a0non-pure-Python libraries</a></li>\n<li><a href=\"#other-tools\" id=\"id85\" rel=\"nofollow\">7.3\u00a0\u00a0\u00a0Other tools</a></li>\n</ul>\n</li>\n<li><a href=\"#release-information\" id=\"id86\" rel=\"nofollow\">8\u00a0\u00a0\u00a0Release information</a></li>\n</ul>\n</div>\n<div id=\"introduction\">\n<h2>1\u00a0\u00a0\u00a0Introduction</h2>\n<p><strong>pdfrw</strong> is a Python library and utility that reads and writes PDF files:</p>\n<ul>\n<li>Version 0.4 is tested and works on Python 2.6, 2.7, 3.3, 3.4, 3.5, and 3.6</li>\n<li>Operations include subsetting, merging, rotating, modifying metadata, etc.</li>\n<li>The fastest pure Python PDF parser available</li>\n<li>Has been used for years by a printer in pre-press production</li>\n<li>Can be used with rst2pdf to faithfully reproduce vector images</li>\n<li>Can be used either standalone, or in conjunction with <a href=\"http://www.reportlab.org/\" rel=\"nofollow\">reportlab</a>\nto reuse existing PDFs in new ones</li>\n<li>Permissively licensed</li>\n</ul>\n<p>pdfrw will faithfully reproduce vector formats without\nrasterization, so the rst2pdf package has used pdfrw\nfor PDF and SVG images by default since March 2010.</p>\n<p>pdfrw can also be used in conjunction with reportlab, in order\nto re-use portions of existing PDFs in new PDFs created with\nreportlab.</p>\n</div>\n<div id=\"examples\">\n<h2>2\u00a0\u00a0\u00a0Examples</h2>\n<p>The library comes with several examples that show operation both with\nand without reportlab.</p>\n<div id=\"all-examples\">\n<h3>2.1\u00a0\u00a0\u00a0All examples</h3>\n<p>The examples directory has a few scripts which use the library.\nNote that if these examples do not work with your PDF, you should\ntry to use pdftk to uncompress and/or unencrypt them first.</p>\n<ul>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/4up.py\" rel=\"nofollow\">4up.py</a> will shrink pages down and place 4 of them on\neach output page.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/alter.py\" rel=\"nofollow\">alter.py</a> shows an example of modifying metadata, without\naltering the structure of the PDF.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/booklet.py\" rel=\"nofollow\">booklet.py</a> shows an example of creating a 2-up output\nsuitable for printing and folding (e.g on tabloid size paper).</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/cat.py\" rel=\"nofollow\">cat.py</a> shows an example of concatenating multiple PDFs together.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/extract.py\" rel=\"nofollow\">extract.py</a> will extract images and Form XObjects (embedded pages)\nfrom existing PDFs to make them easier to use and refer to from\nnew PDFs (e.g. with reportlab or rst2pdf).</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/poster.py\" rel=\"nofollow\">poster.py</a> increases the size of a PDF so it can be printed\nas a poster.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/print_two.py\" rel=\"nofollow\">print_two.py</a> Allows creation of 8.5 X 5.5\u201d booklets by slicing\n8.5 X 11\u201d paper apart after printing.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/rotate.py\" rel=\"nofollow\">rotate.py</a> Rotates all or selected pages in a PDF.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/subset.py\" rel=\"nofollow\">subset.py</a> Creates a new PDF with only a subset of pages from the\noriginal.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/unspread.py\" rel=\"nofollow\">unspread.py</a> Takes a 2-up PDF, and splits out pages.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/watermark.py\" rel=\"nofollow\">watermark.py</a> Adds a watermark PDF image over or under all the pages\nof a PDF.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/4up.py\" rel=\"nofollow\">rl1/4up.py</a> Another 4up example, using reportlab canvas for output.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/booklet.py\" rel=\"nofollow\">rl1/booklet.py</a> Another booklet example, using reportlab canvas for\noutput.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/subset.py\" rel=\"nofollow\">rl1/subset.py</a> Another subsetting example, using reportlab canvas for\noutput.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/rl1/platypus_pdf_template.py\" rel=\"nofollow\">rl1/platypus_pdf_template.py</a> Another watermarking example, using\nreportlab canvas and generated output for the document.  Contributed\nby user asannes.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/rl2/\" rel=\"nofollow\">rl2</a> Experimental code for parsing graphics.  Needs work.</li>\n<li><a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/subset_booklets.py\" rel=\"nofollow\">subset_booklets.py</a> shows an example of creating a full printable pdf\nversion in a more professional and pratical way ( take a look at\n<a href=\"http://www.wikihow.com/Bind-a-Book\" rel=\"nofollow\">http://www.wikihow.com/Bind-a-Book</a> )</li>\n</ul>\n</div>\n<div id=\"notes-on-selected-examples\">\n<h3>2.2\u00a0\u00a0\u00a0Notes on selected examples</h3>\n<div id=\"reorganizing-pages-and-placing-them-two-up\">\n<h4>2.2.1\u00a0\u00a0\u00a0Reorganizing pages and placing them two-up</h4>\n<p>A printer with a fancy printer and/or a full-up copy of Acrobat can\neasily turn your small PDF into a little booklet (for example, print 4\nletter-sized pages on a single 11\u201d x 17\u201d).</p>\n<p>But that assumes several things, including that the personnel know how\nto operate the hardware and software. <a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/booklet.py\" rel=\"nofollow\">booklet.py</a> lets you turn your PDF\ninto a preformatted booklet, to give them fewer chances to mess it up.</p>\n</div>\n<div id=\"adding-or-modifying-metadata\">\n<h4>2.2.2\u00a0\u00a0\u00a0Adding or modifying metadata</h4>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/cat.py\" rel=\"nofollow\">cat.py</a> example will accept multiple input files on the command\nline, concatenate them and output them to output.pdf, after adding some\nnonsensical metadata to the output PDF file.</p>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/alter.py\" rel=\"nofollow\">alter.py</a> example alters a single metadata item in a PDF,\nand writes the result to a new PDF.</p>\n<p>One difference is that, since <strong>cat</strong> is creating a new PDF structure,\nand <strong>alter</strong> is attempting to modify an existing PDF structure, the\nPDF produced by alter (and also by watermark.py) <em>should</em> be\nmore faithful to the original (except for the desired changes).</p>\n<p>For example, the alter.py navigation should be left intact, whereas with\ncat.py it will be stripped.</p>\n</div>\n<div id=\"rotating-and-doubling\">\n<h4>2.2.3\u00a0\u00a0\u00a0Rotating and doubling</h4>\n<p>If you ever want to print something that is like a small booklet, but\nneeds to be spiral bound, you either have to do some fancy rearranging,\nor just waste half your paper.</p>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/print_two.py\" rel=\"nofollow\">print_two.py</a> example program will, for example, make two side-by-side\ncopies each page of of your PDF on a each output sheet.</p>\n<p>But, every other page is flipped, so that you can print double-sided and\nthe pages will line up properly and be pre-collated.</p>\n</div>\n<div id=\"graphics-stream-parsing-proof-of-concept\">\n<h4>2.2.4\u00a0\u00a0\u00a0Graphics stream parsing proof of concept</h4>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/examples/rl2/copy.py\" rel=\"nofollow\">copy.py</a> script shows a simple example of reading in a PDF, and\nusing the decodegraphics.py module to try to write the same information\nout to a new PDF through a reportlab canvas. (If you know about reportlab,\nyou know that if you can faithfully render a PDF to a reportlab canvas, you\ncan do pretty much anything else with that PDF you want.) This kind of\nlow level manipulation should be done only if you really need to.\ndecodegraphics is really more than a proof of concept than anything\nelse. For most cases, just use the Form XObject capability, as shown in\nthe examples/rl1/booklet.py demo.</p>\n</div>\n</div>\n</div>\n<div id=\"pdfrw-philosophy\">\n<h2>3\u00a0\u00a0\u00a0pdfrw philosophy</h2>\n<div id=\"core-library\">\n<h3>3.1\u00a0\u00a0\u00a0Core library</h3>\n<p>The philosophy of the library portion of pdfrw is to provide intuitive\nfunctions to read, manipulate, and write PDF files.  There should be\nminimal leakage between abstraction layers, although getting useful\nwork done makes \u201cpure\u201d functionality separation difficult.</p>\n<p>A key concept supported by the library is the use of Form XObjects,\nwhich allow easy embedding of pieces of one PDF into another.</p>\n<p>Addition of core support to the library is typically done carefully\nand thoughtfully, so as not to clutter it up with too many special\ncases.</p>\n<p>There are a lot of incorrectly formatted PDFs floating around; support\nfor these is added in some cases.  The decision is often based on what\nacroread and okular do with the PDFs; if they can display them properly,\nthen eventually pdfrw should, too, if it is not too difficult or costly.</p>\n<p>Contributions are welcome; one user has contributed some decompression\nfilters and the ability to process PDF 1.5 stream objects.  Additional\nfunctionality that would obviously be useful includes additional\ndecompression filters, the ability to process password-protected PDFs,\nand the ability to output linearized PDFs.</p>\n</div>\n<div id=\"id24\">\n<h3>3.2\u00a0\u00a0\u00a0Examples</h3>\n<p>The philosophy of the examples is to provide small, easily-understood\nexamples that showcase pdfrw functionality.</p>\n</div>\n</div>\n<div id=\"pdf-files-and-python\">\n<h2>4\u00a0\u00a0\u00a0PDF files and Python</h2>\n<div id=\"id25\">\n<h3>4.1\u00a0\u00a0\u00a0Introduction</h3>\n<p>In general, PDF files conceptually map quite well to Python. The major\nobjects to think about are:</p>\n<ul>\n<li><strong>strings</strong>. Most things are strings. These also often decompose\nnaturally into</li>\n<li><strong>lists of tokens</strong>. Tokens can be combined to create higher-level\nobjects like</li>\n<li><strong>arrays</strong> and</li>\n<li><strong>dictionaries</strong> and</li>\n<li><strong>Contents streams</strong> (which can be more streams of tokens)</li>\n</ul>\n</div>\n<div id=\"difficulties\">\n<h3>4.2\u00a0\u00a0\u00a0Difficulties</h3>\n<p>The apparent primary difficulty in mapping PDF files to Python is the\nPDF file concept of \u201cindirect objects.\u201d  Indirect objects provide\nthe efficiency of allowing a single piece of data to be referred to\nfrom more than one containing object, but probably more importantly,\nindirect objects provide a way to get around the chicken and egg\nproblem of circular object references when mapping arbitrary data\nstructures to files. To flatten out a circular reference, an indirect\nobject is <em>referred to</em> instead of being <em>directly included</em> in another\nobject. PDF files have a global mechanism for locating indirect objects,\nand they all have two reference numbers (a reference number and a\n\u201cgeneration\u201d number, in case you wanted to append to the PDF file\nrather than just rewriting the whole thing).</p>\n<p>pdfrw automatically handles indirect references on reading in a PDF\nfile. When pdfrw encounters an indirect PDF file object, the\ncorresponding Python object it creates will have an \u2018indirect\u2019 attribute\nwith a value of True. When writing a PDF file, if you have created\narbitrary data, you just need to make sure that circular references are\nbroken up by putting an attribute named \u2018indirect\u2019 which evaluates to\nTrue on at least one object in every cycle.</p>\n<p>Another PDF file concept that doesn\u2019t quite map to regular Python is a\n\u201cstream\u201d. Streams are dictionaries which each have an associated\nunformatted data block. pdfrw handles streams by placing a special\nattribute on a subclassed dictionary.</p>\n</div>\n<div id=\"usage-model\">\n<h3>4.3\u00a0\u00a0\u00a0Usage Model</h3>\n<p>The usage model for pdfrw treats most objects as strings (it takes their\nstring representation when writing them to a file). The two main\nexceptions are the PdfArray object and the PdfDict object.</p>\n<p>PdfArray is a subclass of list with two special features.  First,\nan \u2018indirect\u2019 attribute allows a PdfArray to be written out as\nan indirect PDF object.  Second, pdfrw reads files lazily, so\nPdfArray knows about, and resolves references to other indirect\nobjects on an as-needed basis.</p>\n<p>PdfDict is a subclass of dict that also has an indirect attribute\nand lazy reference resolution as well.  (And the subclassed\nIndirectPdfDict has indirect automatically set True).</p>\n<p>But PdfDict also has an optional associated stream. The stream object\ndefaults to None, but if you assign a stream to the dict, it will\nautomatically set the PDF /Length attribute for the dictionary.</p>\n<p>Finally, since PdfDict instances are indexed by PdfName objects (which\nalways start with a /) and since most (all?) standard Adobe PdfName\nobjects use names formatted like \u201c/CamelCase\u201d, it makes sense to allow\naccess to dictionary elements via object attribute accesses as well as\nobject index accesses. So usage of PdfDict objects is normally via\nattribute access, although non-standard names (though still with a\nleading slash) can be accessed via dictionary index lookup.</p>\n<div id=\"reading-pdfs\">\n<h4>4.3.1\u00a0\u00a0\u00a0Reading PDFs</h4>\n<p>The PdfReader object is a subclass of PdfDict, which allows easy access\nto an entire document:</p>\n<pre>&gt;&gt;&gt; from pdfrw import PdfReader\n&gt;&gt;&gt; x = PdfReader('source.pdf')\n&gt;&gt;&gt; x.keys()\n['/Info', '/Size', '/Root']\n&gt;&gt;&gt; x.Info\n{'/Producer': '(cairo 1.8.6 (http://cairographics.org))',\n '/Creator': '(cairo 1.8.6 (http://cairographics.org))'}\n&gt;&gt;&gt; x.Root.keys()\n['/Type', '/Pages']\n</pre>\n<p>Info, Size, and Root are retrieved from the trailer of the PDF file.</p>\n<p>In addition to the tree structure, pdfrw creates a special attribute\nnamed <em>pages</em>, that is a list of all the pages in the document. pdfrw\ncreates the <em>pages</em> attribute as a simplification for the user, because\nthe PDF format allows arbitrarily complicated nested dictionaries to\ndescribe the page order. Each entry in the <em>pages</em> list is the PdfDict\nobject for one of the pages in the file, in order.</p>\n<pre>&gt;&gt;&gt; len(x.pages)\n1\n&gt;&gt;&gt; x.pages[0]\n{'/Parent': {'/Kids': [{...}], '/Type': '/Pages', '/Count': '1'},\n '/Contents': {'/Length': '11260', '/Filter': None},\n '/Resources': ... (Lots more stuff snipped)\n&gt;&gt;&gt; x.pages[0].Contents\n{'/Length': '11260', '/Filter': None}\n&gt;&gt;&gt; x.pages[0].Contents.stream\n'q\\n1 1 1 rg /a0 gs\\n0 0 0 RG 0.657436\n  w\\n0 J\\n0 j\\n[] 0.0 d\\n4 M q' ... (Lots more stuff snipped)\n</pre>\n</div>\n<div id=\"writing-pdfs\">\n<h4>4.3.2\u00a0\u00a0\u00a0Writing PDFs</h4>\n<p>As you can see, it is quite easy to dig down into a PDF document. But\nwhat about when it\u2019s time to write it out?</p>\n<pre>&gt;&gt;&gt; from pdfrw import PdfWriter\n&gt;&gt;&gt; y = PdfWriter()\n&gt;&gt;&gt; y.addpage(x.pages[0])\n&gt;&gt;&gt; y.write('result.pdf')\n</pre>\n<p>That\u2019s all it takes to create a new PDF. You may still need to read the\n<a href=\"http://www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf\" rel=\"nofollow\">Adobe PDF reference manual</a> to figure out what needs to go <em>into</em>\nthe PDF, but at least you don\u2019t have to sweat actually building it\nand getting the file offsets right.</p>\n</div>\n<div id=\"manipulating-pdfs-in-memory\">\n<h4>4.3.3\u00a0\u00a0\u00a0Manipulating PDFs in memory</h4>\n<p>For the most part, pdfrw tries to be agnostic about the contents of\nPDF files, and support them as containers, but to do useful work,\nsomething a little higher-level is required, so pdfrw works to\nunderstand a bit about the contents of the containers.  For example:</p>\n<ul>\n<li>PDF pages. pdfrw knows enough to find the pages in PDF files you read\nin, and to write a set of pages back out to a new PDF file.</li>\n<li>Form XObjects. pdfrw can take any page or rectangle on a page, and\nconvert it to a Form XObject, suitable for use inside another PDF\nfile.  It knows enough about these to perform scaling, rotation,\nand positioning.</li>\n<li>reportlab objects. pdfrw can recursively create a set of reportlab\nobjects from its internal object format. This allows, for example,\nForm XObjects to be used inside reportlab, so that you can reuse\ncontent from an existing PDF file when building a new PDF with\nreportlab.</li>\n</ul>\n<p>There are several examples that demonstrate these features in\nthe example code directory.</p>\n</div>\n<div id=\"missing-features\">\n<h4>4.3.4\u00a0\u00a0\u00a0Missing features</h4>\n<p>Even as a pure PDF container library, pdfrw comes up a bit short. It\ndoes not currently support:</p>\n<ul>\n<li>Most compression/decompression filters</li>\n<li>encryption</li>\n</ul>\n<p><a href=\"https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/\" rel=\"nofollow\">pdftk</a> is a wonderful command-line\ntool that can convert your PDFs to remove encryption and compression.\nHowever, in most cases, you can do a lot of useful work with PDFs\nwithout actually removing compression, because only certain elements\ninside PDFs are actually compressed.</p>\n</div>\n</div>\n</div>\n<div id=\"library-internals\">\n<h2>5\u00a0\u00a0\u00a0Library internals</h2>\n<div id=\"id28\">\n<h3>5.1\u00a0\u00a0\u00a0Introduction</h3>\n<p><strong>pdfrw</strong> currently consists of 19 modules organized into a main\npackage and one sub-package.</p>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/__init__.py\" rel=\"nofollow\">__init.py__</a> module does the usual thing of importing a few\nmajor attributes from some of the submodules, and the <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/errors.py\" rel=\"nofollow\">errors.py</a>\nmodule supports logging and exception generation.</p>\n</div>\n<div id=\"pdf-object-model-support\">\n<h3>5.2\u00a0\u00a0\u00a0PDF object model support</h3>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/\" rel=\"nofollow\">objects</a> sub-package contains one module for each of the\ninternal representations of the kinds of basic objects that exist\nin a PDF file, with the <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/__init__.py\" rel=\"nofollow\">objects/__init__.py</a> module in that\npackage simply gathering them up and making them available to the\nmain pdfrw package.</p>\n<p>One feature that all the PDF object classes have in common is the\ninclusion of an \u2018indirect\u2019 attribute. If \u2018indirect\u2019 exists and evaluates\nto True, then when the object is written out, it is written out as an\nindirect object. That is to say, it is addressable in the PDF file, and\ncould be referenced by any number (including zero) of container objects.\nThis indirect object capability saves space in PDF files by allowing\nobjects such as fonts to be referenced from multiple pages, and also\nallows PDF files to contain internal circular references.  This latter\ncapability is used, for example, when each page object has a \u201cparent\u201d\nobject in its dictionary.</p>\n<div id=\"ordinary-objects\">\n<h4>5.2.1\u00a0\u00a0\u00a0Ordinary objects</h4>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfobject.py\" rel=\"nofollow\">objects/pdfobject.py</a> module contains the PdfObject class, which is\na subclass of str, and is the catch-all object for any PDF file elements\nthat are not explicitly represented by other objects, as described below.</p>\n</div>\n<div id=\"name-objects\">\n<h4>5.2.2\u00a0\u00a0\u00a0Name objects</h4>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfname.py\" rel=\"nofollow\">objects/pdfname.py</a> module contains the PdfName singleton object,\nwhich will convert a string into a PDF name by prepending a slash. It can\nbe used either by calling it or getting an attribute, e.g.:</p>\n<pre>PdfName.Rotate == PdfName('Rotate') == PdfObject('/Rotate')\n</pre>\n<p>In the example above, there is a slight difference between the objects\nreturned from PdfName, and the object returned from PdfObject.  The\nPdfName objects are actually objects of class \u201cBasePdfName\u201d.  This\nis important, because only these may be used as keys in PdfDict objects.</p>\n</div>\n<div id=\"string-objects\">\n<h4>5.2.3\u00a0\u00a0\u00a0String objects</h4>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfstring.py\" rel=\"nofollow\">objects/pdfstring.py</a>\nmodule contains the PdfString class, which is a subclass of str that is\nused to represent encoded strings in a PDF file. The class has encode\nand decode methods for the strings.</p>\n</div>\n<div id=\"array-objects\">\n<h4>5.2.4\u00a0\u00a0\u00a0Array objects</h4>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfarray.py\" rel=\"nofollow\">objects/pdfarray.py</a>\nmodule contains the PdfArray class, which is a subclass of list that is\nused to represent arrays in a PDF file. A regular list could be used\ninstead, but use of the PdfArray class allows for an indirect attribute\nto be set, and also allows for proxying of unresolved indirect objects\n(that haven\u2019t been read in yet) in a manner that is transparent to pdfrw\nclients.</p>\n</div>\n<div id=\"dict-objects\">\n<h4>5.2.5\u00a0\u00a0\u00a0Dict objects</h4>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfdict.py\" rel=\"nofollow\">objects/pdfdict.py</a>\nmodule contains the PdfDict class, which is a subclass of dict that is\nused to represent dictionaries in a PDF file. A regular dict could be\nused instead, but the PdfDict class matches the requirements of PDF\nfiles more closely:</p>\n<ul>\n<li>Transparent (from the library client\u2019s viewpoint) proxying\nof unresolved indirect objects</li>\n<li>Return of None for non-existent keys (like dict.get)</li>\n<li>Mapping of attribute accesses to the dict itself\n(pdfdict.Foo == pdfdict[NameObject(\u2018Foo\u2019)])</li>\n<li>Automatic management of following stream and /Length attributes\nfor content dictionaries</li>\n<li>Indirect attribute</li>\n<li>Other attributes may be set for private internal use of the\nlibrary and/or its clients.</li>\n<li>Support for searching parent dictionaries for PDF \u201cinheritable\u201d\nattributes.</li>\n</ul>\n<p>If a PdfDict has an associated data stream in the PDF file, the stream\nis accessed via the \u2018stream\u2019 (all lower-case) attribute.  Setting the\nstream attribute on the PdfDict will automatically set the /Length attribute\nas well.  If that is not what is desired (for example if the the stream\nis compressed), then _stream (same name with an underscore) may be used\nto associate the stream with the PdfDict without setting the length.</p>\n<p>To set private attributes (that will not be written out to a new PDF\nfile) on a dictionary, use the \u2018private\u2019 attribute:</p>\n<pre>mydict.private.foo = 1\n</pre>\n<p>Once the attribute is set, it may be accessed directly as an attribute\nof the dictionary:</p>\n<pre>foo = mydict.foo\n</pre>\n<p>Some attributes of PDF pages are \u201cinheritable.\u201d  That is, they may\nbelong to a parent dictionary (or a parent of a parent dictionary, etc.)\nThe \u201cinheritable\u201d attribute allows for easy discovery of these:</p>\n<pre>mediabox = mypage.inheritable.MediaBox\n</pre>\n</div>\n<div id=\"proxy-objects\">\n<h4>5.2.6\u00a0\u00a0\u00a0Proxy objects</h4>\n<p>The <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/objects/pdfindirect.py\" rel=\"nofollow\">objects/pdfindirect.py</a>\nmodule contains the PdfIndirect class, which is a non-transparent proxy\nobject for PDF objects that have not yet been read in and resolved from\na file. Although these are non-transparent inside the library, client code\nshould never see one of these \u2013 they exist inside the PdfArray and PdfDict\ncontainer types, but are resolved before being returned to a client of\nthose types.</p>\n</div>\n</div>\n<div id=\"file-reading-tokenization-and-parsing\">\n<h3>5.3\u00a0\u00a0\u00a0File reading, tokenization and parsing</h3>\n<p><a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pdfreader.py\" rel=\"nofollow\">pdfreader.py</a>\ncontains the PdfReader class, which can read a PDF file (or be passed a\nfile object or already read string) and parse it. It uses the PdfTokens\nclass in <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/tokens.py\" rel=\"nofollow\">tokens.py</a>  for low-level tokenization.</p>\n<p>The PdfReader class does not, in general, parse into containers (e.g.\ninside the content streams). There is a proof of concept for doing that\ninside the examples/rl2 subdirectory, but that is slow and not well-developed,\nand not useful for most applications.</p>\n<p>An instance of the PdfReader class is an instance of a PdfDict \u2013 the\ntrailer dictionary of the PDF file, to be exact.  It will have a private\nattribute set on it that is named \u2018pages\u2019 that is a list containing all\nthe pages in the file.</p>\n<p>When instantiating a PdfReader object, there are options available\nfor decompressing all the objects in the file.  pdfrw does not currently\nhave very many options for decompression, so this is not all that useful,\nexcept in the specific case of compressed object streams.</p>\n<p>Also, there are no options for decryption yet.  If you have PDF files\nthat are encrypted or heavily compressed, you may find that using another\nprogram like pdftk on them can make them readable by pdfrw.</p>\n<p>In general, the objects are read from the file lazily, but this is not\ncurrently true with compressed object streams \u2013 all of these are decompressed\nand read in when the PdfReader is instantiated.</p>\n</div>\n<div id=\"file-output\">\n<h3>5.4\u00a0\u00a0\u00a0File output</h3>\n<p><a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pdfwriter.py\" rel=\"nofollow\">pdfwriter.py</a>\ncontains the PdfWriter class, which can create and output a PDF file.</p>\n<p>There are a few options available when creating and using this class.</p>\n<p>In the simplest case, an instance of PdfWriter is instantiated, and\nthen pages are added to it from one or more source files (or created\nprogrammatically), and then the write method is called to dump the\nresults out to a file.</p>\n<p>If you have a source PDF and do not want to disturb the structure\nof it too badly, then you may pass its trailer directly to PdfWriter\nrather than letting PdfWriter construct one for you.  There is an\nexample of this (alter.py) in the examples directory.</p>\n</div>\n<div id=\"advanced-features\">\n<h3>5.5\u00a0\u00a0\u00a0Advanced features</h3>\n<p><a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/buildxobj.py\" rel=\"nofollow\">buildxobj.py</a>\ncontains functions to build Form XObjects out of pages or rectangles on\npages.  These may be reused in new PDFs essentially as if they were images.</p>\n<p>buildxobj is careful to cache any page used so that it only appears in\nthe output once.</p>\n<p><a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/toreportlab.py\" rel=\"nofollow\">toreportlab.py</a>\nprovides the makerl function, which will translate pdfrw objects into a\nformat which can be used with <a href=\"http://www.reportlab.org/\" rel=\"nofollow\">reportlab</a>.\nIt is normally used in conjunction with buildxobj, to be able to reuse\nparts of existing PDFs when using reportlab.</p>\n<p><a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/pagemerge.py\" rel=\"nofollow\">pagemerge.py</a> builds on the foundation laid by buildxobj.  It\ncontains classes to create a new page (or overlay an existing page)\nusing one or more rectangles from other pages.  There are examples\nshowing its use for watermarking, scaling, 4-up output, splitting\neach page in 2, etc.</p>\n<p><a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/findobjs.py\" rel=\"nofollow\">findobjs.py</a> contains code that can find specific kinds of objects\ninside a PDF file.  The extract.py example uses this module to create\na new PDF that places each image and Form XObject from a source PDF onto\nits own page, e.g. for easy reuse with some of the other examples or\nwith reportlab.</p>\n</div>\n<div id=\"miscellaneous\">\n<h3>5.6\u00a0\u00a0\u00a0Miscellaneous</h3>\n<p><a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/compress.py\" rel=\"nofollow\">compress.py</a> and <a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/uncompress.py\" rel=\"nofollow\">uncompress.py</a>\ncontains compression and decompression functions. Very few filters are\ncurrently supported, so an external tool like pdftk might be good if you\nrequire the ability to decompress (or, for that matter, decrypt) PDF\nfiles.</p>\n<p><a href=\"https://github.com/pmaupin/pdfrw/tree/master/pdfrw/py23_diffs.py\" rel=\"nofollow\">py23_diffs.py</a> contains code to help manage the differences between\nPython 2 and Python 3.</p>\n</div>\n</div>\n<div id=\"testing\">\n<h2>6\u00a0\u00a0\u00a0Testing</h2>\n<p>The tests associated with pdfrw require a large number of PDFs,\nwhich are not distributed with the library.</p>\n<p>To run the tests:</p>\n<ul>\n<li>Download or clone the full package from github.com/pmaupin/pdfrw</li>\n<li>cd into the tests directory, and then clone the package\ngithub.com/pmaupin/static_pdfs into a subdirectory (also named\nstatic_pdfs).</li>\n<li>Now the tests may be run from that directory using unittest, or\npy.test, or nose.</li>\n<li>travisci is used at github, and runs the tests with py.test</li>\n</ul>\n</div>\n<div id=\"other-libraries\">\n<h2>7\u00a0\u00a0\u00a0Other libraries</h2>\n<div id=\"pure-python\">\n<h3>7.1\u00a0\u00a0\u00a0Pure Python</h3>\n<ul>\n<li><p><a href=\"http://www.reportlab.org/\" rel=\"nofollow\">reportlab</a></p>\n<blockquote>\n<p>reportlab is must-have software if you want to programmatically\ngenerate arbitrary PDFs.</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/mstamy2/PyPDF2\" rel=\"nofollow\">pyPdf</a></p>\n<blockquote>\n<p>pyPdf is, in some ways, very full-featured. It can do decompression\nand decryption and seems to know a lot about items inside at least\nsome kinds of PDF files. In comparison, pdfrw knows less about\nspecific PDF file features (such as metadata), but focuses on trying\nto have a more Pythonic API for mapping the PDF file container\nsyntax to Python, and (IMO) has a simpler and better PDF file\nparser.  The Form XObject capability of pdfrw means that, in many\ncases, it does not actually need to decompress objects \u2013 they\ncan be left compressed.</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.boddie.org.uk/david/Projects/Python/pdftools/index.html\" rel=\"nofollow\">pdftools</a></p>\n<blockquote>\n<p>pdftools feels large and I fell asleep trying to figure out how it\nall fit together, but many others have done useful things with it.</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.reportlab.com/docs/pagecatcher-ds.pdf\" rel=\"nofollow\">pagecatcher</a></p>\n<blockquote>\n<p>My understanding is that pagecatcher would have done exactly what I\nwanted when I built pdfrw. But I was on a zero budget, so I\u2019ve never\nhad the pleasure of experiencing pagecatcher. I do, however, use and\nlike <a href=\"http://www.reportlab.org/\" rel=\"nofollow\">reportlab</a> (open source, from\nthe people who make pagecatcher) so I\u2019m sure pagecatcher is great,\nbetter documented and much more full-featured than pdfrw.</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.unixuser.org/~euske/python/pdfminer/index.html\" rel=\"nofollow\">pdfminer</a></p>\n<blockquote>\n<p>This looks like a useful, actively-developed program. It is quite\nlarge, but then, it is trying to actively comprehend a full PDF\ndocument. From the website:</p>\n<p>\u201cPDFMiner is a suite of programs that help extracting and analyzing\ntext data of PDF documents. Unlike other PDF-related tools, it\nallows to obtain the exact location of texts in a page, as well as\nother extra information such as font information or ruled lines. It\nincludes a PDF converter that can transform PDF files into other\ntext formats (such as HTML). It has an extensible PDF parser that\ncan be used for other purposes instead of text analysis.\u201d</p>\n</blockquote>\n</li>\n</ul>\n</div>\n<div id=\"non-pure-python-libraries\">\n<h3>7.2\u00a0\u00a0\u00a0non-pure-Python libraries</h3>\n<ul>\n<li><a href=\"https://launchpad.net/poppler-python/\" rel=\"nofollow\">pyPoppler</a> can read PDF\nfiles.</li>\n<li><a href=\"http://www.cairographics.org/pycairo/\" rel=\"nofollow\">pycairo</a> can write PDF\nfiles.</li>\n<li><a href=\"https://github.com/rk700/PyMuPDF\" rel=\"nofollow\">PyMuPDF</a> high performance rendering\nof PDF, (Open)XPS, CBZ and EPUB</li>\n</ul>\n</div>\n<div id=\"other-tools\">\n<h3>7.3\u00a0\u00a0\u00a0Other tools</h3>\n<ul>\n<li><a href=\"https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/\" rel=\"nofollow\">pdftk</a> is a wonderful command\nline tool for basic PDF manipulation. It complements pdfrw extremely\nwell, supporting many operations such as decryption and decompression\nthat pdfrw cannot do.</li>\n<li><a href=\"http://www.mupdf.com/\" rel=\"nofollow\">MuPDF</a> is a free top performance PDF, (Open)XPS, CBZ and EPUB rendering library\nthat also comes with some command line tools. One of those, <tt>mutool</tt>, has big overlaps with pdftk\u2019s -\nexcept it is up to 10 times faster.</li>\n</ul>\n</div>\n</div>\n<div id=\"release-information\">\n<h2>8\u00a0\u00a0\u00a0Release information</h2>\n<p>Revisions:</p>\n<p>0.4 \u2013 Released 18 September, 2017</p>\n<blockquote>\n<ul>\n<li>Python 3.6 added to test matrix</li>\n<li>Proper unicode support for text strings in PDFs added</li>\n<li>buildxobj fixes allow better support creating form XObjects\nout of compressed pages in some cases</li>\n<li>Compression fixes for Python 3+</li>\n<li>New subset_booklets.py example</li>\n<li>Bug with non-compressed indices into compressed object streams fixed</li>\n<li>Bug with distinguishing compressed object stream first objects fixed</li>\n<li>Better error reporting added for some invalid PDFs (e.g. when reading\npast the end of file)</li>\n<li>Better scrubbing of old bookmark information when writing PDFs, to\nremove dangling references</li>\n<li>Refactoring of pdfwriter, including updating API, to allow future\nenhancements for things like incremental writing</li>\n<li>Minor tokenizer speedup</li>\n<li>Some flate decompressor bugs fixed</li>\n<li>Compression and decompression tests added</li>\n<li>Tests for new unicode handling added</li>\n<li>PdfReader.readpages() recursion error (issue #92) fixed.</li>\n<li>Initial crypt filter support added</li>\n</ul>\n</blockquote>\n<p>0.3 \u2013 Released 19 October, 2016.</p>\n<blockquote>\n<ul>\n<li>Python 3.5 added to test matrix</li>\n<li>Better support under Python 3.x for in-memory PDF file-like objects</li>\n<li>Some pagemerge and Unicode patches added</li>\n<li>Changes to logging allow better coexistence with other packages</li>\n<li>Fix for \u201cfrom pdfrw import *\u201d</li>\n<li>New fancy_watermark.py example shows off capabilities of pagemerge.py</li>\n<li>metadata.py example renamed to cat.py</li>\n</ul>\n</blockquote>\n<p>0.2 \u2013 Released 21 June, 2015.  Supports Python 2.6, 2.7, 3.3, and 3.4.</p>\n<blockquote>\n<ul>\n<li>Several bugs have been fixed</li>\n<li>New regression test functionally tests core with dozens of\nPDFs, and also tests examples.</li>\n<li>Core has been ported and tested on Python3 by round-tripping\nseveral difficult files and observing binary matching results\nacross the different Python versions.</li>\n<li>Still only minimal support for compression and no support\nfor encryption or newer PDF features.  (pdftk is useful\nto put PDFs in a form that pdfrw can use.)</li>\n</ul>\n</blockquote>\n<p>0.1 \u2013 Released to PyPI in 2012.  Supports Python 2.5 - 2.7</p>\n</div>\n\n          </div>"}, "last_serial": 3581963, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "e02602c93c96add287d7a306e03bb3d6", "sha256": "8a85cb87b888c030d87cc3fce10ad93e5f99e721b80b99bf50e29a074c048f83"}, "downloads": -1, "filename": "pdfrw-0.1.tar.gz", "has_sig": false, "md5_digest": "e02602c93c96add287d7a306e03bb3d6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30366, "upload_time": "2012-09-18T04:52:15", "upload_time_iso_8601": "2012-09-18T04:52:15.413102Z", "url": "https://files.pythonhosted.org/packages/e3/00/aac35e1fffac513c8f14ea05b0c12caa22d105ad8be133112873c5372e53/pdfrw-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "06af2f23253e5199cd4f5993385a5327", "sha256": "86f6976d5be4cdd93373383472216a2ef745d6de50dfaca396be893e4d6dbb8a"}, "downloads": -1, "filename": "pdfrw-0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "06af2f23253e5199cd4f5993385a5327", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 57485, "upload_time": "2015-06-21T20:59:09", "upload_time_iso_8601": "2015-06-21T20:59:09.300186Z", "url": "https://files.pythonhosted.org/packages/11/2f/d4ee2571df5b4954111cd8bf3bb3b66ec42a84e6f99b50194277ed7ead45/pdfrw-0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1b46eaca5b6e0516ec682459954b210d", "sha256": "09f734df28f9ad712a2c14308b1d60e7202762c3ce2e32a6ad30e7ec149822b2"}, "downloads": -1, "filename": "pdfrw-0.2.tar.gz", "has_sig": false, "md5_digest": "1b46eaca5b6e0516ec682459954b210d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 69177, "upload_time": "2015-06-21T20:59:13", "upload_time_iso_8601": "2015-06-21T20:59:13.233286Z", "url": "https://files.pythonhosted.org/packages/69/08/a3b87f4832f2082aa2e6f0ac019aa6463bce3fc57c10e0a2ea2020c61f45/pdfrw-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "d8d683f26a99801ce8272c8a3d21add1", "sha256": "d17d3aaac3bd960cdd71f2ccf733022d80ba8e941fd0f90292b3b3eaed13926d"}, "downloads": -1, "filename": "pdfrw-0.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d8d683f26a99801ce8272c8a3d21add1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 58009, "upload_time": "2016-10-19T16:48:26", "upload_time_iso_8601": "2016-10-19T16:48:26.694990Z", "url": "https://files.pythonhosted.org/packages/0c/02/6bca8519aecac7e4131e922179168b3437e4e76a73ebf3e552a281a76dea/pdfrw-0.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "31209322130fdf8fde6a67a5fb117741", "sha256": "1af18af301d2c07d846cc7203e3c7ca77b2ed2a9eb3421335cc39f5e3e148f36"}, "downloads": -1, "filename": "pdfrw-0.3.tar.gz", "has_sig": false, "md5_digest": "31209322130fdf8fde6a67a5fb117741", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 71576, "upload_time": "2016-10-19T16:48:30", "upload_time_iso_8601": "2016-10-19T16:48:30.419179Z", "url": "https://files.pythonhosted.org/packages/06/62/7f43c4a9d014b94ea03fe73088332fa07db1a03f806bac01aaa19a7fb887/pdfrw-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "76f4e1c495fc279e4c0a933e4a09c7d2", "sha256": "758289edaa3b672e9a1a67504be73c18ec668d4e5b9d5ac9cbc0dc753d8d196b"}, "downloads": -1, "filename": "pdfrw-0.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "76f4e1c495fc279e4c0a933e4a09c7d2", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 69460, "upload_time": "2017-09-18T10:08:10", "upload_time_iso_8601": "2017-09-18T10:08:10.732666Z", "url": "https://files.pythonhosted.org/packages/c0/84/af442c4458756bb0c0d2424102d1200616f3ff9b82c48aaa130e08549bf6/pdfrw-0.4-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "eaf97243d3634cac954527904dcdecae", "sha256": "0dc0494a0e6561b268542b28ede2280387c2728114f117d3bb5d8e4787b93ef4"}, "downloads": -1, "filename": "pdfrw-0.4.tar.gz", "has_sig": false, "md5_digest": "eaf97243d3634cac954527904dcdecae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 95402, "upload_time": "2017-09-18T10:08:02", "upload_time_iso_8601": "2017-09-18T10:08:02.440182Z", "url": "https://files.pythonhosted.org/packages/61/96/cbde98b96115d10694010e584d00d39f7b97905e1c8303e6ffbb84080e6a/pdfrw-0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "76f4e1c495fc279e4c0a933e4a09c7d2", "sha256": "758289edaa3b672e9a1a67504be73c18ec668d4e5b9d5ac9cbc0dc753d8d196b"}, "downloads": -1, "filename": "pdfrw-0.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "76f4e1c495fc279e4c0a933e4a09c7d2", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 69460, "upload_time": "2017-09-18T10:08:10", "upload_time_iso_8601": "2017-09-18T10:08:10.732666Z", "url": "https://files.pythonhosted.org/packages/c0/84/af442c4458756bb0c0d2424102d1200616f3ff9b82c48aaa130e08549bf6/pdfrw-0.4-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "eaf97243d3634cac954527904dcdecae", "sha256": "0dc0494a0e6561b268542b28ede2280387c2728114f117d3bb5d8e4787b93ef4"}, "downloads": -1, "filename": "pdfrw-0.4.tar.gz", "has_sig": false, "md5_digest": "eaf97243d3634cac954527904dcdecae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 95402, "upload_time": "2017-09-18T10:08:02", "upload_time_iso_8601": "2017-09-18T10:08:02.440182Z", "url": "https://files.pythonhosted.org/packages/61/96/cbde98b96115d10694010e584d00d39f7b97905e1c8303e6ffbb84080e6a/pdfrw-0.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:10 2020"}