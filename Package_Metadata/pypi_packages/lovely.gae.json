{"info": {"author": "Lovely Systems", "author_email": "office@lovelysystems.com", "bugtrack_url": null, "classifiers": [], "description": "Lovely Appengine Packages\n*************************\n\n================\nlovely.gae.async\n================\n\nThis package executes jobs asynchronously, it uses the appengine\ntaskqueue to exectue the jobs.\n\n    >>> from lovely.gae.async import defer, get_tasks\n\nThe defer function executes a handler asynchronously as a job. We\ncreate 3 jobs that have the same signature.\n\n    >>> import time\n    >>> for i in range(3):\n    ...     print defer(time.sleep, [0.3])\n    <google.appengine.api.labs.taskqueue.taskqueue.Task object at ...>\n    None\n    None\n\nLet us have a look on what jobs are there. Note that there is only one\nbecause all the 3 jobs we added were the same.\n\n    >>> len(get_tasks())\n    1\n\nIf we change the signature of the job, a new one will be added.\n\n    >>> added = defer(time.sleep, [0.4])\n    >>> len(get_tasks())\n    2\n\nNormally jobs are automatically executed by the taskqueueapi, we have\na test method which executes the jobs and returns the number of jobs\ndone.\n\n    >>> run_tasks()\n    2\n\nNow we can add the same signature again.\n\n    >>> added = defer(time.sleep, [0.4])\n    >>> run_tasks()\n    1\n\nWe can also set only_once to false to execute a worker many times with\nthe same signature.\n\n    >>> from pprint import pprint\n    >>> defer(pprint, ['hello'], once_only=False)\n    <google.appengine.api.labs.taskqueue.taskqueue.Task object at ...>\n    >>> defer(pprint, ['hello'], once_only=False)\n    <google.appengine.api.labs.taskqueue.taskqueue.Task object at ...>\n    >>> run_tasks()\n    'hello'\n    'hello'\n    2\n\n\n\n\n\n==========================\nDB Custom Property Classes\n==========================\n\nTyped Lists\n===========\n\nThis property converts model instances to keys and ensures a length.\n\n    >>> from lovely.gae.db.property import TypedListProperty\n    >>> from google.appengine.ext import db\n\nLet us create a model\n\n    >>> class Yummy(db.Model): pass\n    >>> class Bummy(db.Model): pass\n\nWe can now reference Yummy instances with our property. Note that we\ncan also use the kind name as an argument of the kind.\n\n    >>> class Dummy(db.Model):\n    ...     yummies = TypedListProperty(Yummy)\n    ...     bummies = TypedListProperty('Bummy', length=3)\n\nThe kind arguement needs to be a subclass kind name or a db.Model.\n\n    >>> TypedListProperty(object)\n    Traceback (most recent call last):\n    ...\n    ValueError: Kind needs to be a subclass of db.Model\n\n    >>> dummy = Dummy()\n    >>> dummy_key = dummy.put()\n    >>> yummy1 = Yummy()\n    >>> yummy1_key = yummy1.put()\n    >>> dummy.yummies = [yummy1]\n\nWe cannot set any other type.\n\n    >>> bummy1 = Bummy()\n    >>> bummy1_key = bummy1.put()\n    >>> dummy.yummies = [bummy1]\n    Traceback (most recent call last):\n    ...\n    BadValueError: Wrong kind u'Bummy'\n\nThe length needs to match if defined (see above).\n\n    >>> dummy.bummies = [bummy1]\n    Traceback (most recent call last):\n    ...\n    BadValueError: Wrong length need 3 got 1\n\n    >>> dummy.bummies = [bummy1, bummy1, bummy1]\n    >>> dummy_key == dummy.put()\n    True\n\nCase-Insensitive String Property\n================================\n\nThis property allows searching for the lowercase prefix in a\ncase-insensitive manner. This is usefull for autocomplete\nimplementations where we do not want to have a seperate property just\nfor searching.\n\n    >>> from lovely.gae.db.property import IStringProperty\n    >>> class Foo(db.Model):\n    ...     title = IStringProperty()\n\n    >>> f1 = Foo(title='Foo 1')\n    >>> kf1 = f1.put()\n    >>> f2 = Foo(title='Foo 2')\n    >>> kf2 = f2.put()\n    >>> f3 = Foo(title='foo 3')\n    >>> kf3 = f3.put()\n    >>> f4 = Foo(title=None)\n    >>> kf4 = f4.put()\n\nThe property does not allow the special seperator character which is\njust one below the  highest unicode character,\n\n    >>> f3 = Foo(title='Foo 3' + IStringProperty.SEPERATOR)\n    Traceback (most recent call last):\n    ...\n    BadValueError: Not all characters in property title\n\nNote that if we want to do an exact search, we have to use a special\nfilter that can be created by the property instance.\n\n    >>> [f.title for f in Foo.all().filter('title =', 'foo 1')]\n    []\n\nThe \"equal\" filter arguments can be computed with a special method on\nthe property.\n\n    >>> ef = Foo.title.equals_filter('Foo 1')\n    >>> ef\n    ('title =', u'foo 1\\xef\\xbf\\xbcFoo 1')\n\n    >>> [f.title for f in Foo.all().filter(*ef)]\n    [u'Foo 1']\n\nLet us try with inequallity, e.g. prefix search. Prefix search is\nnormally done with two filters using the highest unicode character.\n\nSearch for all that starts with \"fo\" case-insensitive.\n\n    >>> q = Foo.all()\n    >>> q = q.filter('title >=', 'fo')\n    >>> q = q.filter('title <', 'fo' + u'\\xEF\\xBF\\xBD')\n    >>> [f.title for f in q]\n    [u'Foo 1', u'Foo 2', u'foo 3']\n\nSearch for all that starts with 'foo 1'\n\n    >>> q = Foo.all()\n    >>> q = q.filter('title >=', 'foo 1')\n    >>> q = q.filter('title <', 'foo 1' + u'\\xEF\\xBF\\xBD')\n    >>> [f.title for f in q]\n    [u'Foo 1']\n\n    >>> q = Foo.all()\n    >>> q = q.filter('title >=', 'foo 2')\n    >>> q = q.filter('title <=', 'foo 2' + u'\\xEF\\xBF\\xBD')\n    >>> [f.title for f in q]\n    [u'Foo 2']\n\n    >>> q = Foo.all()\n    >>> q = q.filter('title >=', 'foo 3')\n    >>> q = q.filter('title <=', 'foo 3' + u'\\xEF\\xBF\\xBD')\n    >>> [f.title for f in q]\n    [u'foo 3']\n\n\nPickle Property\n===============\n\nA pickle property can hold any pickleable python object.\n\n    >>> from lovely.gae.db.property import PickleProperty\n\n    >>> class Pickie(db.Model):\n    ...     data = PickleProperty()\n\n    >>> pickie = Pickie(data={})\n    >>> pickie.data\n    {}\n    >>> kp = pickie.put()\n    >>> pickie.data\n    {}\n    >>> pickie = db.get(kp)\n    >>> pickie.data\n    {}\n    >>> pickie.data = {'key':501*\"x\"}\n    >>> kp = pickie.put()\n    >>> pickie.data\n    {'key': 'xx...xx'}\n\nIf the value is not pickleable we get a validation error.\n\n    >>> pickie = Pickie(data=dict(y=lambda x:x))\n    Traceback (most recent call last):\n    BadValueError: Property 'data' must be pickleable:\n    (Can't pickle <function <lambda> at ...>:\n    it's not found as __main__.<lambda>)\n\n\nSafe ReferenceProperty\n======================\n\n    >>> from lovely.gae.db.property import SafeReferenceProperty\n\nWe use a new model with a gae reference and our safe reference.\n\n    >>> class Refie(db.Model):\n    ...     ref   = db.ReferenceProperty(Yummy, collection_name='ref_ref')\n    ...     sfref = SafeReferenceProperty(Yummy, collection_name='sfref_ref')\n\n    >>> refie = Refie()\n    >>> refie.sfref is None\n    True\n    >>> refie.ref is None\n    True\n\nAn object to be referenced.\n\n    >>> refyummy1 = Yummy()\n    >>> ignore = refyummy1.put()\n\nSet the references to our yummy object.\n\n    >>> refie.sfref = refyummy1\n    >>> refie.sfref\n    <Yummy object at ...>\n    >>> refie.ref = refyummy1\n    >>> refie.ref\n    <Yummy object at ...>\n\n    >>> refieKey = refie.put()\n\nNow we delete the referenced object.\n\n    >>> refyummy1.delete()\n\nAnd reload our referencing object.\n\n    >>> refie = db.get(refieKey)\n\nThe gae reference raises an exception.\n\n    >>> refie.ref\n    Traceback (most recent call last):\n    Error: ReferenceProperty failed to be resolved\n\nWe catch the logs here.\n\n    >>> import logging\n    >>> from StringIO import StringIO\n    >>> log = StringIO()\n    >>> handler = logging.StreamHandler(log)\n    >>> logger = logging.getLogger('lovely.gae.db')\n    >>> logger.setLevel(logging.INFO)\n    >>> logger.addHandler(handler)\n\nOur safe reference returns None.\n\n    >>> pos = log.tell()\n    >>> refie.sfref is None\n    True\n\nLet's see what the log contains.\n\n    >>> log.seek(pos)\n    >>> print log.read()\n    Unresolved Reference for \"Refie._sfref\" set to None\n\nAccessing the stale property once again we will see it was reset to None::\n\n    >>> pos = log.tell()\n    >>> refie.sfref is None\n    True\n\n    >>> log.seek(pos)\n    >>> print log.read() == ''\n    True\n\nThe property get set to None if the reference points to a dead object but only\nif the property is not required::\n\n    >>> class Requy(db.Model):\n    ...     sfref = SafeReferenceProperty(Yummy, collection_name='req_sfref_ref',\n    ...                                   required=True)\n\n    >>> refyummy1 = Yummy()\n    >>> ignore = refyummy1.put()\n\n    >>> requy = Requy(sfref = refyummy1)\n    >>> requyKey = requy.put()\n\n    >>> requy.sfref\n    <Yummy object at ...>\n\n    >>> refyummy1.delete()\n\n    >>> requy = db.get(requyKey)\n\n    >>> pos = log.tell()\n    >>> requy.sfref is None\n    True\n\n    >>> log.seek(pos)\n    >>> print log.read()\n    Unresolved Reference for \"Requy._sfref\" will remain because it is required\n\n=====================\nBatch marker creation\n=====================\n\nThis packages provides the possibility to create markers for every N\nobjects of a given query. This is useful to create batched html pages\nor to generate jobs for every N objects.\n\nA list of attribute values are created that represent the end of a\nbatch at any given position in a given query. The result is stored in\nmemcache and the key is provided to a callback function.\n\n    >>> from lovely.gae import batch\n\nLet us create some test objects.\n\n    >>> from google.appengine.ext import db\n    >>> class Stub(db.Model):\n    ...     c_time = db.DateTimeProperty(auto_now_add=True, required=True)\n    ...     name = db.StringProperty()\n    ...     age = db.IntegerProperty()\n    ...     state = db.IntegerProperty()\n    ...     def __repr__(self):\n    ...         return '<Stub %s>' % self.name\n\n    >>> for i in range(1,13):\n    ...     s = Stub(name=str(i), age=i, state=i%2)\n    ...     sk = s.put()\n\n    >>> Stub.all().count()\n    12\n\nFirst we make sure that we have no tasks in the queue for testing.\n\n    >>> from lovely.gae.async import get_tasks\n    >>> len(get_tasks())\n    0\n\nSo for example if we want to know any 100th key of a given kind we\ncould calculate it like shown below. Note that we provide the pprint function\nas a callback, so we get the memcache key in the output.\n\nThe calculate_markers function returns the memcache key that will be\nused to store the result when the calculation is completed.\n\n    >>> from pprint import pprint\n    >>> mc_key = batch.create_markers('Stub', callback=pprint)\n    >>> mc_key\n    'create_markers:...-...-...'\n\nA task gets created.\n\n    >>> tasks = get_tasks()\n    >>> len(tasks)\n    1\n\nLet us run the task.\n\n    >>> run_tasks(1)\n    1\n\nWe now have another task left for the callback, which is actually the\npprint function.\n\n    >>> run_tasks()\n    'create_markers:...-...-...'\n    1\n\nWe should now have a result. The result shows that we need no batches\nfor the given batch size (because we only have 12 objects).\n\n    >>> from google.appengine.api import memcache\n    >>> memcache.get(mc_key)\n    []\n\nLet us use another batch size. This time without callback.\n\n    >>> mc_key = batch.create_markers('Stub', batchsize=1)\n    >>> run_tasks()\n    1\n\nWe now have exatly 12 keys, because the batch size was 1.\n\n    >>> len(memcache.get(mc_key))\n    12\n\nThe default attributes returned are the keys.\n\n    >>> memcache.get(mc_key)\n    [datastore_types.Key.fro...\n\nWe can also use other attributes. Let us get items batched by c_time\ndescending. Note that it is not checked if values are not unique, so\nif a non-unique attribute is used it might be the case that batch\nranges contains objects twice.\n\n    >>> mc_key = batch.create_markers('Stub',\n    ...                               attribute='c_time',\n    ...                               order='desc',\n    ...                               batchsize=3)\n    >>> run_tasks()\n    1\n    >>> markers = memcache.get(mc_key)\n    >>> markers\n    [datetime.datetime(...\n    >>> len(markers)\n    4\n    >>> sorted(markers, reverse=True) == markers\n    True\n\n    >>> mc_key = batch.create_markers('Stub',\n    ...                               attribute='c_time',\n    ...                               order='asc',\n    ...                               batchsize=3)\n    >>> run_tasks()\n    1\n    >>> markers = memcache.get(mc_key)\n    >>> markers\n    [datetime.datetime(...\n    >>> len(markers)\n    4\n    >>> sorted(markers) == markers\n    True\n\n\nWe can also pass filters to be applied to the query for the batch like this:\n\n    >>> mc_key = batch.create_markers('Stub',\n    ...                               filters=[('state', 0)],\n    ...                               attribute='c_time',\n    ...                               order='asc',\n    ...                               batchsize=3)\n    >>> run_tasks()\n    1\n    >>> markers = memcache.get(mc_key)\n    >>> len(markers)\n    2", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://code.google.com/p/lovely-gae/", "keywords": "appengine datastore backup batch utilities", "license": "Apache License 2.0", "maintainer": null, "maintainer_email": null, "name": "lovely.gae", "package_url": "https://pypi.org/project/lovely.gae/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/lovely.gae/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://code.google.com/p/lovely-gae/"}, "release_url": "https://pypi.org/project/lovely.gae/1.0.0a2/", "requires_dist": null, "requires_python": null, "summary": "Appengine related Python Packages from Lovely Systems", "version": "1.0.0a2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"lovely-gae-async\">\n<h2>lovely.gae.async</h2>\n<p>This package executes jobs asynchronously, it uses the appengine\ntaskqueue to exectue the jobs.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.gae.async import defer, get_tasks\n</pre>\n</blockquote>\n<p>The defer function executes a handler asynchronously as a job. We\ncreate 3 jobs that have the same signature.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import time\n&gt;&gt;&gt; for i in range(3):\n...     print defer(time.sleep, [0.3])\n&lt;google.appengine.api.labs.taskqueue.taskqueue.Task object at ...&gt;\nNone\nNone\n</pre>\n</blockquote>\n<p>Let us have a look on what jobs are there. Note that there is only one\nbecause all the 3 jobs we added were the same.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(get_tasks())\n1\n</pre>\n</blockquote>\n<p>If we change the signature of the job, a new one will be added.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; added = defer(time.sleep, [0.4])\n&gt;&gt;&gt; len(get_tasks())\n2\n</pre>\n</blockquote>\n<p>Normally jobs are automatically executed by the taskqueueapi, we have\na test method which executes the jobs and returns the number of jobs\ndone.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; run_tasks()\n2\n</pre>\n</blockquote>\n<p>Now we can add the same signature again.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; added = defer(time.sleep, [0.4])\n&gt;&gt;&gt; run_tasks()\n1\n</pre>\n</blockquote>\n<p>We can also set only_once to false to execute a worker many times with\nthe same signature.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; defer(pprint, ['hello'], once_only=False)\n&lt;google.appengine.api.labs.taskqueue.taskqueue.Task object at ...&gt;\n&gt;&gt;&gt; defer(pprint, ['hello'], once_only=False)\n&lt;google.appengine.api.labs.taskqueue.taskqueue.Task object at ...&gt;\n&gt;&gt;&gt; run_tasks()\n'hello'\n'hello'\n2\n</pre>\n</blockquote>\n</div>\n<div id=\"db-custom-property-classes\">\n<h2>DB Custom Property Classes</h2>\n<div id=\"typed-lists\">\n<h3>Typed Lists</h3>\n<p>This property converts model instances to keys and ensures a length.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.gae.db.property import TypedListProperty\n&gt;&gt;&gt; from google.appengine.ext import db\n</pre>\n</blockquote>\n<p>Let us create a model</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Yummy(db.Model): pass\n&gt;&gt;&gt; class Bummy(db.Model): pass\n</pre>\n</blockquote>\n<p>We can now reference Yummy instances with our property. Note that we\ncan also use the kind name as an argument of the kind.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Dummy(db.Model):\n...     yummies = TypedListProperty(Yummy)\n...     bummies = TypedListProperty('Bummy', length=3)\n</pre>\n</blockquote>\n<p>The kind arguement needs to be a subclass kind name or a db.Model.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; TypedListProperty(object)\nTraceback (most recent call last):\n...\nValueError: Kind needs to be a subclass of db.Model\n</pre>\n<pre>&gt;&gt;&gt; dummy = Dummy()\n&gt;&gt;&gt; dummy_key = dummy.put()\n&gt;&gt;&gt; yummy1 = Yummy()\n&gt;&gt;&gt; yummy1_key = yummy1.put()\n&gt;&gt;&gt; dummy.yummies = [yummy1]\n</pre>\n</blockquote>\n<p>We cannot set any other type.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; bummy1 = Bummy()\n&gt;&gt;&gt; bummy1_key = bummy1.put()\n&gt;&gt;&gt; dummy.yummies = [bummy1]\nTraceback (most recent call last):\n...\nBadValueError: Wrong kind u'Bummy'\n</pre>\n</blockquote>\n<p>The length needs to match if defined (see above).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; dummy.bummies = [bummy1]\nTraceback (most recent call last):\n...\nBadValueError: Wrong length need 3 got 1\n</pre>\n<pre>&gt;&gt;&gt; dummy.bummies = [bummy1, bummy1, bummy1]\n&gt;&gt;&gt; dummy_key == dummy.put()\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"case-insensitive-string-property\">\n<h3>Case-Insensitive String Property</h3>\n<p>This property allows searching for the lowercase prefix in a\ncase-insensitive manner. This is usefull for autocomplete\nimplementations where we do not want to have a seperate property just\nfor searching.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.gae.db.property import IStringProperty\n&gt;&gt;&gt; class Foo(db.Model):\n...     title = IStringProperty()\n</pre>\n<pre>&gt;&gt;&gt; f1 = Foo(title='Foo 1')\n&gt;&gt;&gt; kf1 = f1.put()\n&gt;&gt;&gt; f2 = Foo(title='Foo 2')\n&gt;&gt;&gt; kf2 = f2.put()\n&gt;&gt;&gt; f3 = Foo(title='foo 3')\n&gt;&gt;&gt; kf3 = f3.put()\n&gt;&gt;&gt; f4 = Foo(title=None)\n&gt;&gt;&gt; kf4 = f4.put()\n</pre>\n</blockquote>\n<p>The property does not allow the special seperator character which is\njust one below the  highest unicode character,</p>\n<blockquote>\n<pre>&gt;&gt;&gt; f3 = Foo(title='Foo 3' + IStringProperty.SEPERATOR)\nTraceback (most recent call last):\n...\nBadValueError: Not all characters in property title\n</pre>\n</blockquote>\n<p>Note that if we want to do an exact search, we have to use a special\nfilter that can be created by the property instance.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; [f.title for f in Foo.all().filter('title =', 'foo 1')]\n[]\n</pre>\n</blockquote>\n<p>The \u201cequal\u201d filter arguments can be computed with a special method on\nthe property.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ef = Foo.title.equals_filter('Foo 1')\n&gt;&gt;&gt; ef\n('title =', u'foo 1\\xef\\xbf\\xbcFoo 1')\n</pre>\n<pre>&gt;&gt;&gt; [f.title for f in Foo.all().filter(*ef)]\n[u'Foo 1']\n</pre>\n</blockquote>\n<p>Let us try with inequallity, e.g. prefix search. Prefix search is\nnormally done with two filters using the highest unicode character.</p>\n<p>Search for all that starts with \u201cfo\u201d case-insensitive.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; q = Foo.all()\n&gt;&gt;&gt; q = q.filter('title &gt;=', 'fo')\n&gt;&gt;&gt; q = q.filter('title &lt;', 'fo' + u'\\xEF\\xBF\\xBD')\n&gt;&gt;&gt; [f.title for f in q]\n[u'Foo 1', u'Foo 2', u'foo 3']\n</pre>\n</blockquote>\n<p>Search for all that starts with \u2018foo 1\u2019</p>\n<blockquote>\n<pre>&gt;&gt;&gt; q = Foo.all()\n&gt;&gt;&gt; q = q.filter('title &gt;=', 'foo 1')\n&gt;&gt;&gt; q = q.filter('title &lt;', 'foo 1' + u'\\xEF\\xBF\\xBD')\n&gt;&gt;&gt; [f.title for f in q]\n[u'Foo 1']\n</pre>\n<pre>&gt;&gt;&gt; q = Foo.all()\n&gt;&gt;&gt; q = q.filter('title &gt;=', 'foo 2')\n&gt;&gt;&gt; q = q.filter('title &lt;=', 'foo 2' + u'\\xEF\\xBF\\xBD')\n&gt;&gt;&gt; [f.title for f in q]\n[u'Foo 2']\n</pre>\n<pre>&gt;&gt;&gt; q = Foo.all()\n&gt;&gt;&gt; q = q.filter('title &gt;=', 'foo 3')\n&gt;&gt;&gt; q = q.filter('title &lt;=', 'foo 3' + u'\\xEF\\xBF\\xBD')\n&gt;&gt;&gt; [f.title for f in q]\n[u'foo 3']\n</pre>\n</blockquote>\n</div>\n<div id=\"pickle-property\">\n<h3>Pickle Property</h3>\n<p>A pickle property can hold any pickleable python object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.gae.db.property import PickleProperty\n</pre>\n<pre>&gt;&gt;&gt; class Pickie(db.Model):\n...     data = PickleProperty()\n</pre>\n<pre>&gt;&gt;&gt; pickie = Pickie(data={})\n&gt;&gt;&gt; pickie.data\n{}\n&gt;&gt;&gt; kp = pickie.put()\n&gt;&gt;&gt; pickie.data\n{}\n&gt;&gt;&gt; pickie = db.get(kp)\n&gt;&gt;&gt; pickie.data\n{}\n&gt;&gt;&gt; pickie.data = {'key':501*\"x\"}\n&gt;&gt;&gt; kp = pickie.put()\n&gt;&gt;&gt; pickie.data\n{'key': 'xx...xx'}\n</pre>\n</blockquote>\n<p>If the value is not pickleable we get a validation error.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pickie = Pickie(data=dict(y=lambda x:x))\nTraceback (most recent call last):\nBadValueError: Property 'data' must be pickleable:\n(Can't pickle &lt;function &lt;lambda&gt; at ...&gt;:\nit's not found as __main__.&lt;lambda&gt;)\n</pre>\n</blockquote>\n</div>\n<div id=\"safe-referenceproperty\">\n<h3>Safe ReferenceProperty</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.gae.db.property import SafeReferenceProperty\n</pre>\n</blockquote>\n<p>We use a new model with a gae reference and our safe reference.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Refie(db.Model):\n...     ref   = db.ReferenceProperty(Yummy, collection_name='ref_ref')\n...     sfref = SafeReferenceProperty(Yummy, collection_name='sfref_ref')\n</pre>\n<pre>&gt;&gt;&gt; refie = Refie()\n&gt;&gt;&gt; refie.sfref is None\nTrue\n&gt;&gt;&gt; refie.ref is None\nTrue\n</pre>\n</blockquote>\n<p>An object to be referenced.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; refyummy1 = Yummy()\n&gt;&gt;&gt; ignore = refyummy1.put()\n</pre>\n</blockquote>\n<p>Set the references to our yummy object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; refie.sfref = refyummy1\n&gt;&gt;&gt; refie.sfref\n&lt;Yummy object at ...&gt;\n&gt;&gt;&gt; refie.ref = refyummy1\n&gt;&gt;&gt; refie.ref\n&lt;Yummy object at ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; refieKey = refie.put()\n</pre>\n</blockquote>\n<p>Now we delete the referenced object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; refyummy1.delete()\n</pre>\n</blockquote>\n<p>And reload our referencing object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; refie = db.get(refieKey)\n</pre>\n</blockquote>\n<p>The gae reference raises an exception.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; refie.ref\nTraceback (most recent call last):\nError: ReferenceProperty failed to be resolved\n</pre>\n</blockquote>\n<p>We catch the logs here.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import logging\n&gt;&gt;&gt; from StringIO import StringIO\n&gt;&gt;&gt; log = StringIO()\n&gt;&gt;&gt; handler = logging.StreamHandler(log)\n&gt;&gt;&gt; logger = logging.getLogger('lovely.gae.db')\n&gt;&gt;&gt; logger.setLevel(logging.INFO)\n&gt;&gt;&gt; logger.addHandler(handler)\n</pre>\n</blockquote>\n<p>Our safe reference returns None.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pos = log.tell()\n&gt;&gt;&gt; refie.sfref is None\nTrue\n</pre>\n</blockquote>\n<p>Let\u2019s see what the log contains.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; log.seek(pos)\n&gt;&gt;&gt; print log.read()\nUnresolved Reference for \"Refie._sfref\" set to None\n</pre>\n</blockquote>\n<p>Accessing the stale property once again we will see it was reset to None:</p>\n<pre>&gt;&gt;&gt; pos = log.tell()\n&gt;&gt;&gt; refie.sfref is None\nTrue\n\n&gt;&gt;&gt; log.seek(pos)\n&gt;&gt;&gt; print log.read() == ''\nTrue\n</pre>\n<p>The property get set to None if the reference points to a dead object but only\nif the property is not required:</p>\n<pre>&gt;&gt;&gt; class Requy(db.Model):\n...     sfref = SafeReferenceProperty(Yummy, collection_name='req_sfref_ref',\n...                                   required=True)\n\n&gt;&gt;&gt; refyummy1 = Yummy()\n&gt;&gt;&gt; ignore = refyummy1.put()\n\n&gt;&gt;&gt; requy = Requy(sfref = refyummy1)\n&gt;&gt;&gt; requyKey = requy.put()\n\n&gt;&gt;&gt; requy.sfref\n&lt;Yummy object at ...&gt;\n\n&gt;&gt;&gt; refyummy1.delete()\n\n&gt;&gt;&gt; requy = db.get(requyKey)\n\n&gt;&gt;&gt; pos = log.tell()\n&gt;&gt;&gt; requy.sfref is None\nTrue\n\n&gt;&gt;&gt; log.seek(pos)\n&gt;&gt;&gt; print log.read()\nUnresolved Reference for \"Requy._sfref\" will remain because it is required\n</pre>\n</div>\n</div>\n<div id=\"batch-marker-creation\">\n<h2>Batch marker creation</h2>\n<p>This packages provides the possibility to create markers for every N\nobjects of a given query. This is useful to create batched html pages\nor to generate jobs for every N objects.</p>\n<p>A list of attribute values are created that represent the end of a\nbatch at any given position in a given query. The result is stored in\nmemcache and the key is provided to a callback function.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.gae import batch\n</pre>\n</blockquote>\n<p>Let us create some test objects.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from google.appengine.ext import db\n&gt;&gt;&gt; class Stub(db.Model):\n...     c_time = db.DateTimeProperty(auto_now_add=True, required=True)\n...     name = db.StringProperty()\n...     age = db.IntegerProperty()\n...     state = db.IntegerProperty()\n...     def __repr__(self):\n...         return '&lt;Stub %s&gt;' % self.name\n</pre>\n<pre>&gt;&gt;&gt; for i in range(1,13):\n...     s = Stub(name=str(i), age=i, state=i%2)\n...     sk = s.put()\n</pre>\n<pre>&gt;&gt;&gt; Stub.all().count()\n12\n</pre>\n</blockquote>\n<p>First we make sure that we have no tasks in the queue for testing.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.gae.async import get_tasks\n&gt;&gt;&gt; len(get_tasks())\n0\n</pre>\n</blockquote>\n<p>So for example if we want to know any 100th key of a given kind we\ncould calculate it like shown below. Note that we provide the pprint function\nas a callback, so we get the memcache key in the output.</p>\n<p>The calculate_markers function returns the memcache key that will be\nused to store the result when the calculation is completed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; mc_key = batch.create_markers('Stub', callback=pprint)\n&gt;&gt;&gt; mc_key\n'create_markers:...-...-...'\n</pre>\n</blockquote>\n<p>A task gets created.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tasks = get_tasks()\n&gt;&gt;&gt; len(tasks)\n1\n</pre>\n</blockquote>\n<p>Let us run the task.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; run_tasks(1)\n1\n</pre>\n</blockquote>\n<p>We now have another task left for the callback, which is actually the\npprint function.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; run_tasks()\n'create_markers:...-...-...'\n1\n</pre>\n</blockquote>\n<p>We should now have a result. The result shows that we need no batches\nfor the given batch size (because we only have 12 objects).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from google.appengine.api import memcache\n&gt;&gt;&gt; memcache.get(mc_key)\n[]\n</pre>\n</blockquote>\n<p>Let us use another batch size. This time without callback.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; mc_key = batch.create_markers('Stub', batchsize=1)\n&gt;&gt;&gt; run_tasks()\n1\n</pre>\n</blockquote>\n<p>We now have exatly 12 keys, because the batch size was 1.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(memcache.get(mc_key))\n12\n</pre>\n</blockquote>\n<p>The default attributes returned are the keys.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; memcache.get(mc_key)\n[datastore_types.Key.fro...\n</pre>\n</blockquote>\n<p>We can also use other attributes. Let us get items batched by c_time\ndescending. Note that it is not checked if values are not unique, so\nif a non-unique attribute is used it might be the case that batch\nranges contains objects twice.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; mc_key = batch.create_markers('Stub',\n...                               attribute='c_time',\n...                               order='desc',\n...                               batchsize=3)\n&gt;&gt;&gt; run_tasks()\n1\n&gt;&gt;&gt; markers = memcache.get(mc_key)\n&gt;&gt;&gt; markers\n[datetime.datetime(...\n&gt;&gt;&gt; len(markers)\n4\n&gt;&gt;&gt; sorted(markers, reverse=True) == markers\nTrue\n</pre>\n<pre>&gt;&gt;&gt; mc_key = batch.create_markers('Stub',\n...                               attribute='c_time',\n...                               order='asc',\n...                               batchsize=3)\n&gt;&gt;&gt; run_tasks()\n1\n&gt;&gt;&gt; markers = memcache.get(mc_key)\n&gt;&gt;&gt; markers\n[datetime.datetime(...\n&gt;&gt;&gt; len(markers)\n4\n&gt;&gt;&gt; sorted(markers) == markers\nTrue\n</pre>\n</blockquote>\n<p>We can also pass filters to be applied to the query for the batch like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; mc_key = batch.create_markers('Stub',\n...                               filters=[('state', 0)],\n...                               attribute='c_time',\n...                               order='asc',\n...                               batchsize=3)\n&gt;&gt;&gt; run_tasks()\n1\n&gt;&gt;&gt; markers = memcache.get(mc_key)\n&gt;&gt;&gt; len(markers)\n2\n</pre>\n</blockquote>\n</div>\n\n          </div>"}, "last_serial": 794365, "releases": {"0.5.0a2": [{"comment_text": "", "digests": {"md5": "3d4fb6ee1174bba44be80b3352dfbd73", "sha256": "de295bb9809c0d10695a23105cc652296fb45fe66c9d08311964a066b51ac6b4"}, "downloads": -1, "filename": "lovely.gae-0.5.0a2.tar.gz", "has_sig": false, "md5_digest": "3d4fb6ee1174bba44be80b3352dfbd73", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27949, "upload_time": "2009-09-01T17:06:29", "upload_time_iso_8601": "2009-09-01T17:06:29.108528Z", "url": "https://files.pythonhosted.org/packages/59/99/71816650bcf67c79628c0257cff1c5c78913f72bca1733070815a80072e9/lovely.gae-0.5.0a2.tar.gz", "yanked": false}], "0.5.0a3": [{"comment_text": "", "digests": {"md5": "dcc023abd29ebecdc45caff99bcad70f", "sha256": "eb68e07b886bbf52a1ddbc8127291a043cb3ea07b6f1bfecb771dd50d1705984"}, "downloads": -1, "filename": "lovely.gae-0.5.0a3.tar.gz", "has_sig": false, "md5_digest": "dcc023abd29ebecdc45caff99bcad70f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28204, "upload_time": "2009-09-02T10:29:44", "upload_time_iso_8601": "2009-09-02T10:29:44.496906Z", "url": "https://files.pythonhosted.org/packages/b6/e4/b38677e73884320366399d7bf1c81b9cde469f3f12592a080b0491306a23/lovely.gae-0.5.0a3.tar.gz", "yanked": false}], "0.5.0a4": [{"comment_text": "", "digests": {"md5": "2aa37fff9c4b30f02695a99ffe023e02", "sha256": "1ecee36eec184772b437455073d030b5fbeaf94d1263206a313cb3480f2459e1"}, "downloads": -1, "filename": "lovely.gae-0.5.0a4.tar.gz", "has_sig": false, "md5_digest": "2aa37fff9c4b30f02695a99ffe023e02", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28405, "upload_time": "2009-09-08T08:50:55", "upload_time_iso_8601": "2009-09-08T08:50:55.856845Z", "url": "https://files.pythonhosted.org/packages/92/5f/67cb847544f2b1a821ff33b12d891f2dba7c11b15903f2c0eb97c65bdd7b/lovely.gae-0.5.0a4.tar.gz", "yanked": false}], "0.5.0a5": [{"comment_text": "", "digests": {"md5": "016431a8f08f8614f7dde4e9c227a0d5", "sha256": "228f7e76edf01273c9b7d07ced84075712b556fddfc351f6570334cdb85f1875"}, "downloads": -1, "filename": "lovely.gae-0.5.0a5.tar.gz", "has_sig": false, "md5_digest": "016431a8f08f8614f7dde4e9c227a0d5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34225, "upload_time": "2010-01-04T11:58:55", "upload_time_iso_8601": "2010-01-04T11:58:55.659853Z", "url": "https://files.pythonhosted.org/packages/12/55/5330fe931c8e3bc76ab322013789e06090c4dcfe99705388a63b17164563/lovely.gae-0.5.0a5.tar.gz", "yanked": false}], "0.5.0a6": [{"comment_text": "", "digests": {"md5": "ec8e33d4b010a9551e8645de13f9f004", "sha256": "e9c7cbc230a3bfaf4bdffd0627f57a92118a8e1a2b541b457907ec958132a39f"}, "downloads": -1, "filename": "lovely.gae-0.5.0a6.tar.gz", "has_sig": false, "md5_digest": "ec8e33d4b010a9551e8645de13f9f004", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34453, "upload_time": "2010-01-05T14:34:21", "upload_time_iso_8601": "2010-01-05T14:34:21.633853Z", "url": "https://files.pythonhosted.org/packages/77/59/36a3598e97b42ec5d9b04326642f5c2cd638452ffeb34f5b513077f46572/lovely.gae-0.5.0a6.tar.gz", "yanked": false}], "0.5.0a8": [{"comment_text": "", "digests": {"md5": "78ae7bcb1c563c0a0e7c34ff9e33f109", "sha256": "7d54df329f7eb319a03918086df3a3651bdc73e66f40bc9ac24fc5315a6a8e4e"}, "downloads": -1, "filename": "lovely.gae-0.5.0a8.tar.gz", "has_sig": false, "md5_digest": "78ae7bcb1c563c0a0e7c34ff9e33f109", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35448, "upload_time": "2010-05-17T11:09:55", "upload_time_iso_8601": "2010-05-17T11:09:55.426767Z", "url": "https://files.pythonhosted.org/packages/0c/f4/95969d55fc2dd231fa6d1c24427a62968ff81763703a7c0762fa62ac1193/lovely.gae-0.5.0a8.tar.gz", "yanked": false}], "1.0.0a1": [{"comment_text": "", "digests": {"md5": "c8c8eaf06ea4a5be6c4f3d86d91144b2", "sha256": "1f7d196db7d406406358d580e650d4322edef793998c0da403ca61bf41e8fa9f"}, "downloads": -1, "filename": "lovely.gae-1.0.0a1.tar.gz", "has_sig": false, "md5_digest": "c8c8eaf06ea4a5be6c4f3d86d91144b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23297, "upload_time": "2010-06-11T11:24:54", "upload_time_iso_8601": "2010-06-11T11:24:54.125091Z", "url": "https://files.pythonhosted.org/packages/cf/4a/63c0c7f6c3cc1eb3afb44f5fbb8cfe8c2a40c18a9c6e8c83f85381c6cb1d/lovely.gae-1.0.0a1.tar.gz", "yanked": false}], "1.0.0a2": [{"comment_text": "", "digests": {"md5": "59f5858de18b1f7cf0cadb7a67a844ea", "sha256": "44768188e14cef5967700491ad141bfccdfb4a57cf784132a68194863ed38cdd"}, "downloads": -1, "filename": "lovely.gae-1.0.0a2.tar.gz", "has_sig": false, "md5_digest": "59f5858de18b1f7cf0cadb7a67a844ea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23332, "upload_time": "2010-06-11T12:45:49", "upload_time_iso_8601": "2010-06-11T12:45:49.109955Z", "url": "https://files.pythonhosted.org/packages/70/f7/3085010612aab92592163b7d7323029f0fc4cb8316bffe6684f48f429ae7/lovely.gae-1.0.0a2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "59f5858de18b1f7cf0cadb7a67a844ea", "sha256": "44768188e14cef5967700491ad141bfccdfb4a57cf784132a68194863ed38cdd"}, "downloads": -1, "filename": "lovely.gae-1.0.0a2.tar.gz", "has_sig": false, "md5_digest": "59f5858de18b1f7cf0cadb7a67a844ea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23332, "upload_time": "2010-06-11T12:45:49", "upload_time_iso_8601": "2010-06-11T12:45:49.109955Z", "url": "https://files.pythonhosted.org/packages/70/f7/3085010612aab92592163b7d7323029f0fc4cb8316bffe6684f48f429ae7/lovely.gae-1.0.0a2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:43:41 2020"}