{"info": {"author": "Vanessa Sochat", "author_email": "vsochat@stanford.edu", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU Affero General Public License v3 or later (AGPLv3+)", "Operating System :: Unix", "Programming Language :: C", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering", "Topic :: Software Development"], "description": "# Puzzle\n\nI've recently taken up a fondness for puzzles. Over a conversation one night,\nwe joked how cool it would be to have a digital puzzle. It actually\nwouldn't be such a crazy idea - each puzzle piece would need to have some sort of\ntiny sensor to understand it's location relative to the others, and some tiny\ndigital display that a mapped portion of an image would be shown on. Given that\nwe have something like the Kindle, the technology for \"long lasting and low power\nimages\" didn't seem that far off.\n\nBut the use of sensors is a bit out of my budget and current knowledge base. As\nI usually do, I thought of breaking the problem into smaller pieces (pun intended).\nPerhaps there is a similar problem I can solve that would be a step in the right \ndirection? How about a robot that solves puzzles? \n\n## High Level Algorithm\n\nA \"robot puzzle solver\" means that we do the following:\n\n 1. We take a picture of all the puzzle pieces on some consistently colored surface.\n 2. The puzzle pieces are segmented.\n 3. We represented features and edges of the pieces.\n 4. Based on these features, the segmented pieces are put together by an algorithm.\n\n## Variables\n\nSome things we would need to account for in the above (and these are general notes \nfor now).\n\n - the puzzle pieces would ideally have consistent lighting and all be turned with picture upwards.\n - the camera, even from the top down, would introduce a bit of skew, both for shape and for color.\n - we can't make any assumption about the shape or position of the pieces. This means that although we could represent an edge as some sort of curve, the second you introduce a weirdo pieces that doesn't work well with the assumption, the algorithm breaks. For this reason, we might consider a pixel-based approach.\n - It could be the case that the algorithm can solve a puzzle as would a human - perhaps the edge pieces are easiest to do first, and then work from corners in?\n - We could do a recursive backtracking approach, where we start with edges, then work inwards from the corners, and choose the most probable piece given each new location with two \"decided\" edges. But as soon as the probabilities of a correct piece drop below some threshold, we should turn back.\n - Puzzles are real, and thus inherently imperfect. There needs to be an allowed margin of error.\n\n## Applications\n\nAs silly as this is, there are some fun applications for a robot puzzle solver.\n\n - Puzzles are currently ranked on number of pieces, but I've found this isn't a good representation for how difficult they are. The robot puzzle solver could come up with a metric that represents difficulty based on the algorithm.\n - Has anyone ever wondered how much harder it is to solve a puzzle if you are color blind? Given a metric of difficulty, we can see how that changes with different variables removed. For example, if we remove color, how much longer does the algorithm take?\n\n# Puzzle Solver\n\nI want to document this process, because it's a relatively complex problem that requires\nimage processing, machine learning, and lots of creativity that will feel overwhelming if not broken\ninto... pieces (okay I'll stop that). The first thing I decided to do was work with some \"dummy\" data.\nI'm actually set up in a good position because I have a fully assembed puzzle that I can photograph, label\nwith \"ground truth,\" and then test by breaking apart and photographing the pieces in many different\nways. But to start, I want to just try and represent a puzzle.\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://www.github.com/vsoch/puzzles", "keywords": "python puzzle solver", "license": "LICENSE", "maintainer": "", "maintainer_email": "", "name": "puzzles", "package_url": "https://pypi.org/project/puzzles/", "platform": "", "project_url": "https://pypi.org/project/puzzles/", "project_urls": {"Homepage": "http://www.github.com/vsoch/puzzles"}, "release_url": "https://pypi.org/project/puzzles/0.0.1/", "requires_dist": null, "requires_python": "", "summary": "solve puzzles with Python", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p># Puzzle</p>\n<p>I\u2019ve recently taken up a fondness for puzzles. Over a conversation one night,\nwe joked how cool it would be to have a digital puzzle. It actually\nwouldn\u2019t be such a crazy idea - each puzzle piece would need to have some sort of\ntiny sensor to understand it\u2019s location relative to the others, and some tiny\ndigital display that a mapped portion of an image would be shown on. Given that\nwe have something like the Kindle, the technology for \u201clong lasting and low power\nimages\u201d didn\u2019t seem that far off.</p>\n<p>But the use of sensors is a bit out of my budget and current knowledge base. As\nI usually do, I thought of breaking the problem into smaller pieces (pun intended).\nPerhaps there is a similar problem I can solve that would be a step in the right\ndirection? How about a robot that solves puzzles?</p>\n<p>## High Level Algorithm</p>\n<p>A \u201crobot puzzle solver\u201d means that we do the following:</p>\n<blockquote>\n<ol>\n<li>We take a picture of all the puzzle pieces on some consistently colored surface.</li>\n<li>The puzzle pieces are segmented.</li>\n<li>We represented features and edges of the pieces.</li>\n<li>Based on these features, the segmented pieces are put together by an algorithm.</li>\n</ol>\n</blockquote>\n<p>## Variables</p>\n<p>Some things we would need to account for in the above (and these are general notes\nfor now).</p>\n<blockquote>\n<ul>\n<li>the puzzle pieces would ideally have consistent lighting and all be turned with picture upwards.</li>\n<li>the camera, even from the top down, would introduce a bit of skew, both for shape and for color.</li>\n<li>we can\u2019t make any assumption about the shape or position of the pieces. This means that although we could represent an edge as some sort of curve, the second you introduce a weirdo pieces that doesn\u2019t work well with the assumption, the algorithm breaks. For this reason, we might consider a pixel-based approach.</li>\n<li>It could be the case that the algorithm can solve a puzzle as would a human - perhaps the edge pieces are easiest to do first, and then work from corners in?</li>\n<li>We could do a recursive backtracking approach, where we start with edges, then work inwards from the corners, and choose the most probable piece given each new location with two \u201cdecided\u201d edges. But as soon as the probabilities of a correct piece drop below some threshold, we should turn back.</li>\n<li>Puzzles are real, and thus inherently imperfect. There needs to be an allowed margin of error.</li>\n</ul>\n</blockquote>\n<p>## Applications</p>\n<p>As silly as this is, there are some fun applications for a robot puzzle solver.</p>\n<blockquote>\n<ul>\n<li>Puzzles are currently ranked on number of pieces, but I\u2019ve found this isn\u2019t a good representation for how difficult they are. The robot puzzle solver could come up with a metric that represents difficulty based on the algorithm.</li>\n<li>Has anyone ever wondered how much harder it is to solve a puzzle if you are color blind? Given a metric of difficulty, we can see how that changes with different variables removed. For example, if we remove color, how much longer does the algorithm take?</li>\n</ul>\n</blockquote>\n<p># Puzzle Solver</p>\n<p>I want to document this process, because it\u2019s a relatively complex problem that requires\nimage processing, machine learning, and lots of creativity that will feel overwhelming if not broken\ninto\u2026 pieces (okay I\u2019ll stop that). The first thing I decided to do was work with some \u201cdummy\u201d data.\nI\u2019m actually set up in a good position because I have a fully assembed puzzle that I can photograph, label\nwith \u201cground truth,\u201d and then test by breaking apart and photographing the pieces in many different\nways. But to start, I want to just try and represent a puzzle.</p>\n\n          </div>"}, "last_serial": 4398310, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "a532f42469e259eef01e133cffd63ce8", "sha256": "d911c182ec1f1b28c0c5e7aa0e7ae8e3ada9598d6a703aaa46f61fd78163749c"}, "downloads": -1, "filename": "puzzles-0.0.1.tar.gz", "has_sig": false, "md5_digest": "a532f42469e259eef01e133cffd63ce8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4347, "upload_time": "2018-10-21T00:01:48", "upload_time_iso_8601": "2018-10-21T00:01:48.417874Z", "url": "https://files.pythonhosted.org/packages/d6/b7/4c79bf0221f5d915dc957f4a9197c0e7892d36f41f7613f66b8f56b0ac31/puzzles-0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a532f42469e259eef01e133cffd63ce8", "sha256": "d911c182ec1f1b28c0c5e7aa0e7ae8e3ada9598d6a703aaa46f61fd78163749c"}, "downloads": -1, "filename": "puzzles-0.0.1.tar.gz", "has_sig": false, "md5_digest": "a532f42469e259eef01e133cffd63ce8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4347, "upload_time": "2018-10-21T00:01:48", "upload_time_iso_8601": "2018-10-21T00:01:48.417874Z", "url": "https://files.pythonhosted.org/packages/d6/b7/4c79bf0221f5d915dc957f4a9197c0e7892d36f41f7613f66b8f56b0ac31/puzzles-0.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:13:02 2020"}