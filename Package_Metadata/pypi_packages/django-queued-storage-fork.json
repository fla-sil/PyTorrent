{"info": {"author": "Alen Mujezinovic", "author_email": "alen@caffeinehit.com", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "Operating System :: OS Independent", "Programming Language :: Python"], "description": "django-queued-storage\n=====================\n\nThis storage backend enables having a local and a remote storage\nbackend. It will save any file locally and queue a task to transfer it\nsomewhere else.\n\nIf the file is accessed before it's transferred, the local copy is\nreturned.\n\nThe default tasks use `Celery <http://celeryproject.org/>`_ for queing\ntransfer tasks but is agnostic about your choice.\n\nInstallation\n------------\n\n::\n\n    pip install django-queued-storage\n\nConfiguration\n-------------\n\n-  Follow the configuration instructions for\n   `django-celery <https://github.com/ask/django-celery>`_\n-  Set up a `caching\n   backend <https://docs.djangoproject.com/en/1.3/topics/cache/#setting-up-the-cache>`_\n-  Add ``queued_storage`` to your ``INSTALLED_APPS`` tuple\n\nUsage\n-----\n\nThe ``QueuedRemoteStorage`` can be used as a drop-in replacement\nwherever ``django.core.file.storage.Storage`` might otherwise be\nrequired.\n\nThis example is using\n`django-storages <http://code.welldev.org/django-storages/>`_ for the\nremote backend:\n\n::\n\n    from django.db import models\n    from queued_storage.storage import QueuedRemoteStorage\n\n    class MyModel(models.Model):\n        image = ImageField(storage = QueuedRemoteStorage(\n            local = 'django.core.files.storage.FileSystemStorage',\n            remote = 'storages.backends.s3boto.S3BotoStorage'))\n\nBackends\n--------\n\n-  ``queued_storage.backend.QueuedRemoteStorage``:\n    Base class for queued storages. You can use this to specify your own\n   backends.\n\n-  ``queued_storage.backend.DoubleFilesystemStorage``:\n    Used for testing, but can be handy if you want uploaded files to be\n   stored in two places. Example:\n\n   ::\n\n       image = ImageField(\n           storage = DoubleFilesystemStorage(\n               local_kwargs = {'location': '/backup'},\n               remote_kwargs = {'location': settings.MEDIA_ROOT}))\n\n-  ``queued_storage.backend.S3Storage``:\n    Shortcut for the above example.\n\n   ::\n\n       image = ImageField(storage = S3Storage())\n\n-  ``queued_storage.backend.DelayedStorage``:\n    This backend does *not* transfer files to the remote location\n   automatically.\n\n   ::\n\n       image = ImageField(storage = DelayedStorage(\n           'django.core.files.storage.FileSystemStorage',\n           'storages.backends.s3boto.S3BotoStorage'))\n\n       >>> m = MyModel(image = File(open('image.png')))\n       >>> # Save locally:\n       >>> m.save() \n       >>> # Transfer to remote location:\n       >>> m.file.storage.transfer(m.file.name) \n\nUseful if you want to do preprocessing\n\nFields\n------\n\n-  ``queued_storage.backend.RemoteFileField``:\n    Tiny wrapper around any ``QueuedRemoteStorage``, provides a\n   convenient method to transfer files. The above ``DelayedStorage``\n   example would look like this:\n\n   ::\n\n       image = RemoteFileField(storage = DelayedStorage(\n           'django.core.files.storage.FileSystemStorage',\n           'storages.backends.s3boto.S3BotoStorage'))\n\n       >>> m = MyModel(image = File(open('image.png')))\n       >>> # Save locally:\n       >>> m.save() \n       >>> # Transfer to remote location:\n       >>> m.file.transfer()\n\nTasks\n-----\n\n-  ``queued_storage.backend.Transfer``:\n    The default task. Transfers to a remote location. The actual\n   transfer is implemented in the remote backend.\n\n-  ``queued_storage.backend.TransferAndDelete``:\n    Once the file was transferred, the local copy is deleted.\n\nTo create new tasks, do something like this:\n\n::\n\n    from celery.registry import tasks\n    from queued_storage.backend import Transfer\n\n    class TransferAndDelete(Transfer):\n        def transfer(self, name, local, remote, **kwargs):\n            result = super(TransferAndDelete, self).transfer(name, local, remote, **kwargs)\n\n            if result:\n                local.delete(name)\n\n            return result\n\n    tasks.register(TransferAndDelete)\n\nThe result is ``True`` if the transfer was successful, else ``False``\nand the task is retried.\n\nIn case you don't want to use Celery, have a look\n`here <https://github.com/flashingpumpkin/django-queued-storage/blob/master/queued_storage/tests/__init__.py#L80>`_.\n\nTo use a different task, pass it into the backend:\n\n::\n\n    image = models.ImageField(storage = S3Storage(task = TransferAndDelete))\n\nSettings\n--------\n\n-  ``QUEUED_STORAGE_CACHE_KEY``:\n    Use a different key for caching.\n\n-  ``QUEUED_STORAGE_RETRIES``:\n    How many retries should be attempted before aborting.\n\n-  ``QUEUED_STORAGE_RETRY_DELAY``:\n    The delay between retries.\n\nRELEASE NOTES\n=============\n\nv0.3 - *BACKWARDS INCOMPATIBLE*\n\n-  Added tests\n-  Added ``S3Storage`` and ``DelayedStorage``\n-  Added ``TransferAndDelete`` task\n-  Classes renamed to be consistent", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "django-queued-storage-fork", "package_url": "https://pypi.org/project/django-queued-storage-fork/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-queued-storage-fork/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/django-queued-storage-fork/0.3/", "requires_dist": null, "requires_python": null, "summary": "Allows for files to be uploaded locally and then transferred to a remote location. This is a fork because the original is not online.", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            django-queued-storage<br>=====================<br><br>This storage backend enables having a local and a remote storage<br>backend. It will save any file locally and queue a task to transfer it<br>somewhere else.<br><br>If the file is accessed before it's transferred, the local copy is<br>returned.<br><br>The default tasks use `Celery &lt;http://celeryproject.org/&gt;`_ for queing<br>transfer tasks but is agnostic about your choice.<br><br>Installation<br>------------<br><br>::<br><br>    pip install django-queued-storage<br><br>Configuration<br>-------------<br><br>-  Follow the configuration instructions for<br>   `django-celery &lt;https://github.com/ask/django-celery&gt;`_<br>-  Set up a `caching<br>   backend &lt;https://docs.djangoproject.com/en/1.3/topics/cache/#setting-up-the-cache&gt;`_<br>-  Add ``queued_storage`` to your ``INSTALLED_APPS`` tuple<br><br>Usage<br>-----<br><br>The ``QueuedRemoteStorage`` can be used as a drop-in replacement<br>wherever ``django.core.file.storage.Storage`` might otherwise be<br>required.<br><br>This example is using<br>`django-storages &lt;http://code.welldev.org/django-storages/&gt;`_ for the<br>remote backend:<br><br>::<br><br>    from django.db import models<br>    from queued_storage.storage import QueuedRemoteStorage<br><br>    class MyModel(models.Model):<br>        image = ImageField(storage = QueuedRemoteStorage(<br>            local = 'django.core.files.storage.FileSystemStorage',<br>            remote = 'storages.backends.s3boto.S3BotoStorage'))<br><br>Backends<br>--------<br><br>-  ``queued_storage.backend.QueuedRemoteStorage``:<br>    Base class for queued storages. You can use this to specify your own<br>   backends.<br><br>-  ``queued_storage.backend.DoubleFilesystemStorage``:<br>    Used for testing, but can be handy if you want uploaded files to be<br>   stored in two places. Example:<br><br>   ::<br><br>       image = ImageField(<br>           storage = DoubleFilesystemStorage(<br>               local_kwargs = {'location': '/backup'},<br>               remote_kwargs = {'location': settings.MEDIA_ROOT}))<br><br>-  ``queued_storage.backend.S3Storage``:<br>    Shortcut for the above example.<br><br>   ::<br><br>       image = ImageField(storage = S3Storage())<br><br>-  ``queued_storage.backend.DelayedStorage``:<br>    This backend does *not* transfer files to the remote location<br>   automatically.<br><br>   ::<br><br>       image = ImageField(storage = DelayedStorage(<br>           'django.core.files.storage.FileSystemStorage',<br>           'storages.backends.s3boto.S3BotoStorage'))<br><br>       &gt;&gt;&gt; m = MyModel(image = File(open('image.png')))<br>       &gt;&gt;&gt; # Save locally:<br>       &gt;&gt;&gt; m.save() <br>       &gt;&gt;&gt; # Transfer to remote location:<br>       &gt;&gt;&gt; m.file.storage.transfer(m.file.name) <br><br>Useful if you want to do preprocessing<br><br>Fields<br>------<br><br>-  ``queued_storage.backend.RemoteFileField``:<br>    Tiny wrapper around any ``QueuedRemoteStorage``, provides a<br>   convenient method to transfer files. The above ``DelayedStorage``<br>   example would look like this:<br><br>   ::<br><br>       image = RemoteFileField(storage = DelayedStorage(<br>           'django.core.files.storage.FileSystemStorage',<br>           'storages.backends.s3boto.S3BotoStorage'))<br><br>       &gt;&gt;&gt; m = MyModel(image = File(open('image.png')))<br>       &gt;&gt;&gt; # Save locally:<br>       &gt;&gt;&gt; m.save() <br>       &gt;&gt;&gt; # Transfer to remote location:<br>       &gt;&gt;&gt; m.file.transfer()<br><br>Tasks<br>-----<br><br>-  ``queued_storage.backend.Transfer``:<br>    The default task. Transfers to a remote location. The actual<br>   transfer is implemented in the remote backend.<br><br>-  ``queued_storage.backend.TransferAndDelete``:<br>    Once the file was transferred, the local copy is deleted.<br><br>To create new tasks, do something like this:<br><br>::<br><br>    from celery.registry import tasks<br>    from queued_storage.backend import Transfer<br><br>    class TransferAndDelete(Transfer):<br>        def transfer(self, name, local, remote, **kwargs):<br>            result = super(TransferAndDelete, self).transfer(name, local, remote, **kwargs)<br><br>            if result:<br>                local.delete(name)<br><br>            return result<br><br>    tasks.register(TransferAndDelete)<br><br>The result is ``True`` if the transfer was successful, else ``False``<br>and the task is retried.<br><br>In case you don't want to use Celery, have a look<br>`here &lt;https://github.com/flashingpumpkin/django-queued-storage/blob/master/queued_storage/tests/__init__.py#L80&gt;`_.<br><br>To use a different task, pass it into the backend:<br><br>::<br><br>    image = models.ImageField(storage = S3Storage(task = TransferAndDelete))<br><br>Settings<br>--------<br><br>-  ``QUEUED_STORAGE_CACHE_KEY``:<br>    Use a different key for caching.<br><br>-  ``QUEUED_STORAGE_RETRIES``:<br>    How many retries should be attempted before aborting.<br><br>-  ``QUEUED_STORAGE_RETRY_DELAY``:<br>    The delay between retries.<br><br>RELEASE NOTES<br>=============<br><br>v0.3 - *BACKWARDS INCOMPATIBLE*<br><br>-  Added tests<br>-  Added ``S3Storage`` and ``DelayedStorage``<br>-  Added ``TransferAndDelete`` task<br>-  Classes renamed to be consistent\n          </div>"}, "last_serial": 790394, "releases": {"0.3": [{"comment_text": "", "digests": {"md5": "fe0a3d4bd4ad4b4cf4fa0ac6af8630d5", "sha256": "5db79fa99a9074ea6dc1cfb2974bf1fc7322f614e29093d496f8791b9b8f38fd"}, "downloads": -1, "filename": "django-queued-storage-fork-0.3.tar.gz", "has_sig": false, "md5_digest": "fe0a3d4bd4ad4b4cf4fa0ac6af8630d5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37172, "upload_time": "2011-09-12T11:41:01", "upload_time_iso_8601": "2011-09-12T11:41:01.166594Z", "url": "https://files.pythonhosted.org/packages/6d/c2/d8a5d35fa2a719c0e83144be7155ab5aa59fe501fc484b5eeca34060b72c/django-queued-storage-fork-0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fe0a3d4bd4ad4b4cf4fa0ac6af8630d5", "sha256": "5db79fa99a9074ea6dc1cfb2974bf1fc7322f614e29093d496f8791b9b8f38fd"}, "downloads": -1, "filename": "django-queued-storage-fork-0.3.tar.gz", "has_sig": false, "md5_digest": "fe0a3d4bd4ad4b4cf4fa0ac6af8630d5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37172, "upload_time": "2011-09-12T11:41:01", "upload_time_iso_8601": "2011-09-12T11:41:01.166594Z", "url": "https://files.pythonhosted.org/packages/6d/c2/d8a5d35fa2a719c0e83144be7155ab5aa59fe501fc484b5eeca34060b72c/django-queued-storage-fork-0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:28 2020"}