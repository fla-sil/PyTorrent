{"info": {"author": "sg495", "author_email": "sg495@users.noreply.github.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3.7", "Typing :: Typed"], "description": "# typing-json\n[![Build Status](https://api.travis-ci.com/sg495/typing-json.svg?branch=master)](https://travis-ci.com/sg495/typing-json)\n[![codecov](https://codecov.io/gh/sg495/typing-json/graph/badge.svg)](https://codecov.io/gh/sg495/typing-json/)\n[![Generic badge](https://img.shields.io/badge/python-3.7.4+-green.svg)](https://shields.io/)\n[![Checked with mypy](http://www.mypy-lang.org/static/mypy_badge.svg)](http://mypy-lang.org/)\n[![PyPI version shields.io](https://img.shields.io/pypi/v/typing-json.svg)](https://pypi.python.org/pypi/typing-json/)\n[![PyPI status](https://img.shields.io/pypi/status/typing-json.svg)](https://pypi.python.org/pypi/typing-json/)\n[![Generic badge](https://img.shields.io/badge/license-MIT-green.svg)](https://choosealicense.com/licenses/mit/)\n\nAdd typing support to python JSON serialization.\n\n## typechecking\n\nThe typechecking module contains utilities for dynamic typechecking which support relevant types from the typing and typing_extensions libraries.\n\n### is_hashable\n\n```python\ndef is_hashable(t: Any, failure_callback: Optional[Callable[[str], None]] = None) -> bool:\n    ...\n````\n\nThe function `is_hashable(t)` returns `True` if and only if the `t` argument is one of the types considered to be hashable for the purposes of dynamic typechecking in this package. Types currently deemed to be hashable by this function:\n\n- the standard types `bool`, `int`, `float`, `complex`, `str`, `bytes`, `range`, `slice`, `type` and `NoneType` (as well as the value `None`, treated equivalently to `NoneType`);\n- the `typing` types `Tuple[_T1,...]` (single-type variadic tuple), `Tuple[_T1,...,_TN]` (multi-type fixed arity tuple), `FrozenSet[_T]`, `Optional[_T]`, `Union[_T1,...,_TN]` where `_T`, `_S`, `_T1`, ..., `_TN` are themselves hashable types;\n- the `typing_extensions` type `Literal[_v1, ..., _vn]` where `_v1`, ..., `_vn` are of hashable standard type (see above);\n- types created using `typing.NamedTuple` using hashable field types;\n\nSupport for enum types and NewType is planned (see pull request [#5](https://github.com/sg495/typing-json/pull/5)).\n\nIf present, `failure_callback` is called to log all reasons why `t` fails to be hashable, in the order in which they arise.\n\n\n\n### is_typecheckable\n\n```python\ndef is_typecheckable(t: Any, failure_callback: Optional[Callable[[str], None]] = None) -> bool:\n    ...\n````\n\nThe function `is_typecheckable(t)` returns `True` if and only if the `t` argument is one of the types supported for dynamic typechecking using the `is_instance(obj, t)` function from the same module. Currently supported types:\n\n- the standard types `bool`, `int`, `float`, `complex`, `str`, `bytes`, `bytearray`, `memoryview`, `list`, `tuple`, `range`, `slice`, `set`, `frozenset`, `dict`, `type`, `NoneType` and `object` (as well as the value `None`, treated equivalently to `NoneType`);\n- the `collections` types `deque` and `OrderedDict`;\n- the `typing` types `Any`, `List[_T]`, `Tuple[_T1,...]` (single-type variadic tuple), `Tuple[_T1,...,_TN]` (multi-type fixed arity tuple), `Set[_T]`, `FrozenSet[_T]`, `Dict[_T, _S]`, `OrderedDict[_T, _S]`, `Mapping[_T, _S]`, `Deque[_T]`, `Optional[_T]`, `Union[_T1,...,_TN]` where `_T`, `_S`, `_T1`, ..., `_TN` are themselves supported types;\n- the `typing_extensions` type `Literal[_v1, ..., _vn]` where `_v1`, ..., `_vn` are of typecheckable standard of `collections` type (see above);\n- types created using `typing.NamedTuple` using typecheckable field types;\n\nArbitrary classes are currently not supported, regardless of type annotations. Support for types created using `collections.namedtuple` is not planned. Support for enum types and NewType is planned (see pull request [#5](https://github.com/sg495/typing-json/pull/5)).\n\nIf present, `failure_callback` is called to log all reasons why `t` fails to be typecheckable, in the order in which they arise.\n\n\n\n### is_instance\n\n```python\ndef is_instance(obj: Any, t: Any, failure_callback: Optional[Callable[[str], None]] = None) -> bool:\n    ...\n````\n\nThe function `is_instance(obj, t)` returns `True` if and only if the `obj` argument is of type `t`. If `t` is not typecheckable according to `is_typecheckable(t)` then `TypeError` is raised.\n\nIf present, `failure_callback` is called to log all reasons why `obj` fails to be an instance of `t`, in the order in which they arise.\n\n\n\n### is_namedtuple\n\n```python\ndef is_namedtuple(t: Any) -> bool:\n    ...\n```\n\nThe function `is_namedtuple(t)` returns `True` if the `obj` argument was created using `typing.NamedTuple` and all field types are typecheckable. It is currently possible to fool this method by using `collections.namedtuple` and manually adding a `_field_types:` dictionary with string keys and typecheckable types.\n\nIf present, `failure_callback` is called to log all reasons why `t` fails to be a NamedTuple, in the order in which they arise.\n\n\n## encoding\n\n### is_json_encodable\n\n```python\ndef is_json_encodable(t: Any, failure_callback: Optional[Callable[[str], None]] = None) -> bool:\n    ...\n````\n\nThe function `is_json_encodable(t)` returns `True` if and only if `t` is a json-encodable type according to this package. At present, the following are json-encodable types:\n\n- the standard types `bool`, `int`, `float`, `str`, and `NoneType` (as well as the value `None`, treated equivalently to `NoneType`);\n- any `t` such that `is_namedtuple(t)` and such that all field types are json-encodable themselves;\n- the `typing` types `List[_T]`, `Set[_T]`, `FrozenSet[_T]`, `Deque[_T]`, `Tuple[_T,...]`, `Tuple[_T1,...,_TN]`, `Dict[str, _T]`, `OrderedDict[str, _T]`, `Mapping[str, _T]`, `Union[_T1,...,_TN]`, `Optional[_T]`where `_T`, `_T1`, ..., `_TN` are themselves json-encodable types;\n- the `typing_extensions` type `Literal[_v1,...,_vn]`, where where each `_vj in [_v1,...,_vn]` is of type `bool`, `int`, `float`, `str` or `NoneType`.\n\nFuture support is planned for more `typing` and `typing_extensions` types, including enum types and NewType (see pull request [#5](https://github.com/sg495/typing-json/pull/5)).\n\nIf present, `failure_callback` is called to log all reasons why `t` fails to be json-encodable, in the order in which they arise.\n\n\n### to_json_obj\n\n```python\ndef to_json_obj(obj: Any, t: Any) -> Any:\n    ...\n````\n\nThe function `to_json_obj(obj, t)` takes an object `obj` and a json encodable type `t` and converts `obj` into a natively--json-compatible object with the same fields and types. The conversion goes as follows:\n\n- if `t in (bool, int, float, str)`, `obj` is returned unaltered;\n- if `t in (None, NoneType, ...)`, `None` is returned;\n- if `is_namedtuple(t)`, a `collections.OrderedDict` is returned with the fields of the named tuple as keys and respective values recursively converted to natively--json-compatible;\n- if `t` is `Union[_T1,...,_TN]`, `obj` is converted to natively--json-compatible type according to the first type `_Tj` in the sequence `_T1`,...,`_TN` such that `is_instance(obj, _Tj)`;\n- the type `Optional[_T]` is treated as `Union[_T, NoneType]`;\n- if `t` is `Literal[_v1,...,_vN]`, `obj` is returned unaltered;\n- if `t` is one of `List[_T]`, `Set[_T]`, `FrozenSet[_T]`, `Deque[_T]`, `Tuple[_T,...]` a list is returned, containing all elements of `obj` recursively converted to natively--json-compatible objects using type `_T` for the conversion;\n- if `t` is `Tuple[_T1,...,_TN]`, a list is returned, containing all elements of `obj` recursively converted to natively--json-compatible objects using types `_T1`,...,`_TN` for the conversion of the elements `x1`,...,`xN` of `obj`;\n- if `t` is `Dict[_S, _T]` or `Mapping[_S, _T]`, a dictionary is returned with keys and values recursively converted to natively--json-compatible type according to types `_S` and `_T` respectively, and the string version of the keys json is used if they are not one of `bool`, `int`, `float`, `str` or `NoneType`;\n- if `t` is `OrderedDict[_S, _T]`, an dictionary is returned with keys and values recursively converted to natively--json-compatible type according to types `_S` and `_T` respectively, and the string version of the keys json is used if they are not one of `bool`, `int`, `float`, `str` or `NoneType`;\n\nIf `t` is not json-encodable according to `is_json_encodable(t)` then `TypeError` is raised. If `obj` is not of type `t` according to `is_instance(obj, t)` then `TypeError` is raised.\n\nFor the purposes of this library, natively--json-compatible types are: `bool`, `int`, `float`, `str`, `NoneType`, `list`, `dict` and `collections.OrderedDict`.\n\n\n### dump and dumps\n\n```python\ndef dump(obj: Any, encoded_type: Any, ...):\n    ...\n\ndef dumps(obj: Any, encoded_type: Any, ...):\n    ...\n````\n\nThe functions `dump` and `dumps` of `typing_json` mimic the functions `dump` and `dumps` of the standard `json` library, first performing a conversion of `obj` from json-encodable type `encoded_type` to a json object before dumping.\n\n\n## decoding\n\n### from_json_obj\n\n```python\ndef from_json_obj(obj: Any, t: Any) -> Any:\n    ...\n````\n\nThe function `to_json_obj(obj, t)` takes an object `obj` and a json encodable type `t` and converts `obj` into an equivalent object of type `t`. The conversion goes as follows:\n\n- if `t in (bool, int, float, str)`, `obj` is returned unaltered (`TypeError` is raised if `not isinstance(obj, t)`);\n- if `t in (None, NoneType)`, `None` is returned (`TypeError` is raised if `obj is not None`);\n- if `t is ...`, `...` is returned (`TypeError` is raised if `obj is not None`);\n- if `is_namedtuple(t)`, the key values of the (ordered) dictionary `obj` are recursively converted to the types of the fields of `t` with the same keys and any missing key is replaced with it default value in `t`, if present (`TypeError` is raised if `obj` is not a (ordered) dictionary, if `obj` contains keys which are not fields of `t`, or if a non-default field of `t` does not appear as a key in `obj`);\n- if `t` is `Union[_T1,..._TN]` then conversion of `obj` to each type `_Tj` listed in the union is attempted in order and the first successful result is returned (`TypeError` is raised if no conversion is successful);\n- if `t` is `Literal` then `obj` is returned unaltered (`TypeError` is raised if `not is_instance(obj, t)`);\n- if `t` is `List[_T]` then all members of `obj` are recursively converted to type `_T` and a list of the results is returned (`TypeError` is raised if `obj` is not a list);\n- if `t` is `Deque[_T]` then all members of `obj` are recursively converted to type `_T` and a deque of the results is returned (`TypeError` is raised if `obj` is not a list);\n- if `t` is `Set[_T]` then all members of `obj` are recursively converted to type `_T` and a set of the results is returned (`TypeError` is raised if `obj` is not a list, order preservation is not guaranteed);\n- if `t` is `FrozenSet[_T]` then all members of `obj` are recursively converted to type `_T` and a frozenset of the results is returned (`TypeError` is raised if `obj` is not a list, order preservation is not guaranteed);\n- if `t` is `Tuple[_T,...]` then all members of `obj` are recursively converted to type `_T` and a tuple of the results is returned (`TypeError` is raised if `obj` is not a list);\n- if `t` is `Tuple[_TN,...,_TN]` then all members of `obj` are recursively converted to the respective types `_Tj` and a tuple of the results is returned (`TypeError` is raised if `obj` is not a list or if the length does not match the required length for the tuple);\n- if `t` is `Dict[_S, _T]` or `Mapping[_S, _T]` then all keys and values of `obj` are recursively converted to types `_S` and `_T` respectively (if `_S` is not one of `bool`, `int`, `float`, `str`, `NoneType` or `None`, the keys are first json-parsed from strings), and a dict of the results is returned (`TypeError` is raised if `obj` is not a (ordered) dictionary);\n- if `t` is `OrderedDict[_S, _T]`  then all keys and values of `obj` are recursively converted to types `_S` and `_T` respectively (if `_S` is not one of `bool`, `int`, `float`, `str`, `NoneType` or `None`, the keys are first json-parsed from strings), and an ordered dict of the results is returned (`TypeError` is raised if `obj` is not an ordered dictionary);\n\nIf `t` is not json-encodable according to `is_json_encodable(t)` then `TypeError` is raised.\n\n\n### load and loads\n\n```python\ndef load(fp, decoded_type: Any, ...) -> Any:\n    ...\n\ndef dumps(s: str, decoded_type: Any, ...) -> Any:\n    ...\n````\n\nThe functions `load` and `loads` of `typing_json` mimic the functions `load` and `loads` of the standard `json` library, performing a conversion of the loaded json object to json-encodable type `decoded_type` before returning.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/sg495/typing-json", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "typing-json", "package_url": "https://pypi.org/project/typing-json/", "platform": "", "project_url": "https://pypi.org/project/typing-json/", "project_urls": {"Homepage": "https://github.com/sg495/typing-json"}, "release_url": "https://pypi.org/project/typing-json/0.0.7/", "requires_dist": null, "requires_python": "", "summary": "Add typing support to python JSON serialization.", "version": "0.0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>typing-json</h1>\n<p><a href=\"https://travis-ci.com/sg495/typing-json\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cdcd68d52611121fa2d519b962c5dc3b52a1e3c6/68747470733a2f2f6170692e7472617669732d63692e636f6d2f73673439352f747970696e672d6a736f6e2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/sg495/typing-json/\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4d5129303cc8fa263ea646b50edabbaa3871f590/68747470733a2f2f636f6465636f762e696f2f67682f73673439352f747970696e672d6a736f6e2f67726170682f62616467652e737667\"></a>\n<a href=\"https://shields.io/\" rel=\"nofollow\"><img alt=\"Generic badge\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ea727bfa5f3fa57fbca990ce65969b2cfced5abf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e372e342b2d677265656e2e737667\"></a>\n<a href=\"http://mypy-lang.org/\" rel=\"nofollow\"><img alt=\"Checked with mypy\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d0db8f5dcbf5f340f278004d5db3d16b4cdf33ba/687474703a2f2f7777772e6d7970792d6c616e672e6f72672f7374617469632f6d7970795f62616467652e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/typing-json/\" rel=\"nofollow\"><img alt=\"PyPI version shields.io\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/56df3b76819f9f0da10ea4b834ad5b078be76c38/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f747970696e672d6a736f6e2e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/typing-json/\" rel=\"nofollow\"><img alt=\"PyPI status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a4ac450cf57f5cd661aa1d6958689d2cdc76f218/68747470733a2f2f696d672e736869656c64732e696f2f707970692f7374617475732f747970696e672d6a736f6e2e737667\"></a>\n<a href=\"https://choosealicense.com/licenses/mit/\" rel=\"nofollow\"><img alt=\"Generic badge\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f7db8d43223f55fabe102838639f47819829c1ca/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d677265656e2e737667\"></a></p>\n<p>Add typing support to python JSON serialization.</p>\n<h2>typechecking</h2>\n<p>The typechecking module contains utilities for dynamic typechecking which support relevant types from the typing and typing_extensions libraries.</p>\n<h3>is_hashable</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">is_hashable</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">failure_callback</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"kc\">None</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The function <code>is_hashable(t)</code> returns <code>True</code> if and only if the <code>t</code> argument is one of the types considered to be hashable for the purposes of dynamic typechecking in this package. Types currently deemed to be hashable by this function:</p>\n<ul>\n<li>the standard types <code>bool</code>, <code>int</code>, <code>float</code>, <code>complex</code>, <code>str</code>, <code>bytes</code>, <code>range</code>, <code>slice</code>, <code>type</code> and <code>NoneType</code> (as well as the value <code>None</code>, treated equivalently to <code>NoneType</code>);</li>\n<li>the <code>typing</code> types <code>Tuple[_T1,...]</code> (single-type variadic tuple), <code>Tuple[_T1,...,_TN]</code> (multi-type fixed arity tuple), <code>FrozenSet[_T]</code>, <code>Optional[_T]</code>, <code>Union[_T1,...,_TN]</code> where <code>_T</code>, <code>_S</code>, <code>_T1</code>, ..., <code>_TN</code> are themselves hashable types;</li>\n<li>the <code>typing_extensions</code> type <code>Literal[_v1, ..., _vn]</code> where <code>_v1</code>, ..., <code>_vn</code> are of hashable standard type (see above);</li>\n<li>types created using <code>typing.NamedTuple</code> using hashable field types;</li>\n</ul>\n<p>Support for enum types and NewType is planned (see pull request <a href=\"https://github.com/sg495/typing-json/pull/5\" rel=\"nofollow\">#5</a>).</p>\n<p>If present, <code>failure_callback</code> is called to log all reasons why <code>t</code> fails to be hashable, in the order in which they arise.</p>\n<h3>is_typecheckable</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">is_typecheckable</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">failure_callback</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"kc\">None</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The function <code>is_typecheckable(t)</code> returns <code>True</code> if and only if the <code>t</code> argument is one of the types supported for dynamic typechecking using the <code>is_instance(obj, t)</code> function from the same module. Currently supported types:</p>\n<ul>\n<li>the standard types <code>bool</code>, <code>int</code>, <code>float</code>, <code>complex</code>, <code>str</code>, <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code>, <code>list</code>, <code>tuple</code>, <code>range</code>, <code>slice</code>, <code>set</code>, <code>frozenset</code>, <code>dict</code>, <code>type</code>, <code>NoneType</code> and <code>object</code> (as well as the value <code>None</code>, treated equivalently to <code>NoneType</code>);</li>\n<li>the <code>collections</code> types <code>deque</code> and <code>OrderedDict</code>;</li>\n<li>the <code>typing</code> types <code>Any</code>, <code>List[_T]</code>, <code>Tuple[_T1,...]</code> (single-type variadic tuple), <code>Tuple[_T1,...,_TN]</code> (multi-type fixed arity tuple), <code>Set[_T]</code>, <code>FrozenSet[_T]</code>, <code>Dict[_T, _S]</code>, <code>OrderedDict[_T, _S]</code>, <code>Mapping[_T, _S]</code>, <code>Deque[_T]</code>, <code>Optional[_T]</code>, <code>Union[_T1,...,_TN]</code> where <code>_T</code>, <code>_S</code>, <code>_T1</code>, ..., <code>_TN</code> are themselves supported types;</li>\n<li>the <code>typing_extensions</code> type <code>Literal[_v1, ..., _vn]</code> where <code>_v1</code>, ..., <code>_vn</code> are of typecheckable standard of <code>collections</code> type (see above);</li>\n<li>types created using <code>typing.NamedTuple</code> using typecheckable field types;</li>\n</ul>\n<p>Arbitrary classes are currently not supported, regardless of type annotations. Support for types created using <code>collections.namedtuple</code> is not planned. Support for enum types and NewType is planned (see pull request <a href=\"https://github.com/sg495/typing-json/pull/5\" rel=\"nofollow\">#5</a>).</p>\n<p>If present, <code>failure_callback</code> is called to log all reasons why <code>t</code> fails to be typecheckable, in the order in which they arise.</p>\n<h3>is_instance</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">is_instance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">failure_callback</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"kc\">None</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The function <code>is_instance(obj, t)</code> returns <code>True</code> if and only if the <code>obj</code> argument is of type <code>t</code>. If <code>t</code> is not typecheckable according to <code>is_typecheckable(t)</code> then <code>TypeError</code> is raised.</p>\n<p>If present, <code>failure_callback</code> is called to log all reasons why <code>obj</code> fails to be an instance of <code>t</code>, in the order in which they arise.</p>\n<h3>is_namedtuple</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">is_namedtuple</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The function <code>is_namedtuple(t)</code> returns <code>True</code> if the <code>obj</code> argument was created using <code>typing.NamedTuple</code> and all field types are typecheckable. It is currently possible to fool this method by using <code>collections.namedtuple</code> and manually adding a <code>_field_types:</code> dictionary with string keys and typecheckable types.</p>\n<p>If present, <code>failure_callback</code> is called to log all reasons why <code>t</code> fails to be a NamedTuple, in the order in which they arise.</p>\n<h2>encoding</h2>\n<h3>is_json_encodable</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">is_json_encodable</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">failure_callback</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"kc\">None</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The function <code>is_json_encodable(t)</code> returns <code>True</code> if and only if <code>t</code> is a json-encodable type according to this package. At present, the following are json-encodable types:</p>\n<ul>\n<li>the standard types <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code>, and <code>NoneType</code> (as well as the value <code>None</code>, treated equivalently to <code>NoneType</code>);</li>\n<li>any <code>t</code> such that <code>is_namedtuple(t)</code> and such that all field types are json-encodable themselves;</li>\n<li>the <code>typing</code> types <code>List[_T]</code>, <code>Set[_T]</code>, <code>FrozenSet[_T]</code>, <code>Deque[_T]</code>, <code>Tuple[_T,...]</code>, <code>Tuple[_T1,...,_TN]</code>, <code>Dict[str, _T]</code>, <code>OrderedDict[str, _T]</code>, <code>Mapping[str, _T]</code>, <code>Union[_T1,...,_TN]</code>, <code>Optional[_T]</code>where <code>_T</code>, <code>_T1</code>, ..., <code>_TN</code> are themselves json-encodable types;</li>\n<li>the <code>typing_extensions</code> type <code>Literal[_v1,...,_vn]</code>, where where each <code>_vj in [_v1,...,_vn]</code> is of type <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code> or <code>NoneType</code>.</li>\n</ul>\n<p>Future support is planned for more <code>typing</code> and <code>typing_extensions</code> types, including enum types and NewType (see pull request <a href=\"https://github.com/sg495/typing-json/pull/5\" rel=\"nofollow\">#5</a>).</p>\n<p>If present, <code>failure_callback</code> is called to log all reasons why <code>t</code> fails to be json-encodable, in the order in which they arise.</p>\n<h3>to_json_obj</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">to_json_obj</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Any</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The function <code>to_json_obj(obj, t)</code> takes an object <code>obj</code> and a json encodable type <code>t</code> and converts <code>obj</code> into a natively--json-compatible object with the same fields and types. The conversion goes as follows:</p>\n<ul>\n<li>if <code>t in (bool, int, float, str)</code>, <code>obj</code> is returned unaltered;</li>\n<li>if <code>t in (None, NoneType, ...)</code>, <code>None</code> is returned;</li>\n<li>if <code>is_namedtuple(t)</code>, a <code>collections.OrderedDict</code> is returned with the fields of the named tuple as keys and respective values recursively converted to natively--json-compatible;</li>\n<li>if <code>t</code> is <code>Union[_T1,...,_TN]</code>, <code>obj</code> is converted to natively--json-compatible type according to the first type <code>_Tj</code> in the sequence <code>_T1</code>,...,<code>_TN</code> such that <code>is_instance(obj, _Tj)</code>;</li>\n<li>the type <code>Optional[_T]</code> is treated as <code>Union[_T, NoneType]</code>;</li>\n<li>if <code>t</code> is <code>Literal[_v1,...,_vN]</code>, <code>obj</code> is returned unaltered;</li>\n<li>if <code>t</code> is one of <code>List[_T]</code>, <code>Set[_T]</code>, <code>FrozenSet[_T]</code>, <code>Deque[_T]</code>, <code>Tuple[_T,...]</code> a list is returned, containing all elements of <code>obj</code> recursively converted to natively--json-compatible objects using type <code>_T</code> for the conversion;</li>\n<li>if <code>t</code> is <code>Tuple[_T1,...,_TN]</code>, a list is returned, containing all elements of <code>obj</code> recursively converted to natively--json-compatible objects using types <code>_T1</code>,...,<code>_TN</code> for the conversion of the elements <code>x1</code>,...,<code>xN</code> of <code>obj</code>;</li>\n<li>if <code>t</code> is <code>Dict[_S, _T]</code> or <code>Mapping[_S, _T]</code>, a dictionary is returned with keys and values recursively converted to natively--json-compatible type according to types <code>_S</code> and <code>_T</code> respectively, and the string version of the keys json is used if they are not one of <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code> or <code>NoneType</code>;</li>\n<li>if <code>t</code> is <code>OrderedDict[_S, _T]</code>, an dictionary is returned with keys and values recursively converted to natively--json-compatible type according to types <code>_S</code> and <code>_T</code> respectively, and the string version of the keys json is used if they are not one of <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code> or <code>NoneType</code>;</li>\n</ul>\n<p>If <code>t</code> is not json-encodable according to <code>is_json_encodable(t)</code> then <code>TypeError</code> is raised. If <code>obj</code> is not of type <code>t</code> according to <code>is_instance(obj, t)</code> then <code>TypeError</code> is raised.</p>\n<p>For the purposes of this library, natively--json-compatible types are: <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code>, <code>NoneType</code>, <code>list</code>, <code>dict</code> and <code>collections.OrderedDict</code>.</p>\n<h3>dump and dumps</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">encoded_type</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">dumps</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">encoded_type</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The functions <code>dump</code> and <code>dumps</code> of <code>typing_json</code> mimic the functions <code>dump</code> and <code>dumps</code> of the standard <code>json</code> library, first performing a conversion of <code>obj</code> from json-encodable type <code>encoded_type</code> to a json object before dumping.</p>\n<h2>decoding</h2>\n<h3>from_json_obj</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">from_json_obj</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Any</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The function <code>to_json_obj(obj, t)</code> takes an object <code>obj</code> and a json encodable type <code>t</code> and converts <code>obj</code> into an equivalent object of type <code>t</code>. The conversion goes as follows:</p>\n<ul>\n<li>if <code>t in (bool, int, float, str)</code>, <code>obj</code> is returned unaltered (<code>TypeError</code> is raised if <code>not isinstance(obj, t)</code>);</li>\n<li>if <code>t in (None, NoneType)</code>, <code>None</code> is returned (<code>TypeError</code> is raised if <code>obj is not None</code>);</li>\n<li>if <code>t is ...</code>, <code>...</code> is returned (<code>TypeError</code> is raised if <code>obj is not None</code>);</li>\n<li>if <code>is_namedtuple(t)</code>, the key values of the (ordered) dictionary <code>obj</code> are recursively converted to the types of the fields of <code>t</code> with the same keys and any missing key is replaced with it default value in <code>t</code>, if present (<code>TypeError</code> is raised if <code>obj</code> is not a (ordered) dictionary, if <code>obj</code> contains keys which are not fields of <code>t</code>, or if a non-default field of <code>t</code> does not appear as a key in <code>obj</code>);</li>\n<li>if <code>t</code> is <code>Union[_T1,..._TN]</code> then conversion of <code>obj</code> to each type <code>_Tj</code> listed in the union is attempted in order and the first successful result is returned (<code>TypeError</code> is raised if no conversion is successful);</li>\n<li>if <code>t</code> is <code>Literal</code> then <code>obj</code> is returned unaltered (<code>TypeError</code> is raised if <code>not is_instance(obj, t)</code>);</li>\n<li>if <code>t</code> is <code>List[_T]</code> then all members of <code>obj</code> are recursively converted to type <code>_T</code> and a list of the results is returned (<code>TypeError</code> is raised if <code>obj</code> is not a list);</li>\n<li>if <code>t</code> is <code>Deque[_T]</code> then all members of <code>obj</code> are recursively converted to type <code>_T</code> and a deque of the results is returned (<code>TypeError</code> is raised if <code>obj</code> is not a list);</li>\n<li>if <code>t</code> is <code>Set[_T]</code> then all members of <code>obj</code> are recursively converted to type <code>_T</code> and a set of the results is returned (<code>TypeError</code> is raised if <code>obj</code> is not a list, order preservation is not guaranteed);</li>\n<li>if <code>t</code> is <code>FrozenSet[_T]</code> then all members of <code>obj</code> are recursively converted to type <code>_T</code> and a frozenset of the results is returned (<code>TypeError</code> is raised if <code>obj</code> is not a list, order preservation is not guaranteed);</li>\n<li>if <code>t</code> is <code>Tuple[_T,...]</code> then all members of <code>obj</code> are recursively converted to type <code>_T</code> and a tuple of the results is returned (<code>TypeError</code> is raised if <code>obj</code> is not a list);</li>\n<li>if <code>t</code> is <code>Tuple[_TN,...,_TN]</code> then all members of <code>obj</code> are recursively converted to the respective types <code>_Tj</code> and a tuple of the results is returned (<code>TypeError</code> is raised if <code>obj</code> is not a list or if the length does not match the required length for the tuple);</li>\n<li>if <code>t</code> is <code>Dict[_S, _T]</code> or <code>Mapping[_S, _T]</code> then all keys and values of <code>obj</code> are recursively converted to types <code>_S</code> and <code>_T</code> respectively (if <code>_S</code> is not one of <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code>, <code>NoneType</code> or <code>None</code>, the keys are first json-parsed from strings), and a dict of the results is returned (<code>TypeError</code> is raised if <code>obj</code> is not a (ordered) dictionary);</li>\n<li>if <code>t</code> is <code>OrderedDict[_S, _T]</code>  then all keys and values of <code>obj</code> are recursively converted to types <code>_S</code> and <code>_T</code> respectively (if <code>_S</code> is not one of <code>bool</code>, <code>int</code>, <code>float</code>, <code>str</code>, <code>NoneType</code> or <code>None</code>, the keys are first json-parsed from strings), and an ordered dict of the results is returned (<code>TypeError</code> is raised if <code>obj</code> is not an ordered dictionary);</li>\n</ul>\n<p>If <code>t</code> is not json-encodable according to <code>is_json_encodable(t)</code> then <code>TypeError</code> is raised.</p>\n<h3>load and loads</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">load</span><span class=\"p\">(</span><span class=\"n\">fp</span><span class=\"p\">,</span> <span class=\"n\">decoded_type</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Any</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">dumps</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">decoded_type</span><span class=\"p\">:</span> <span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Any</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The functions <code>load</code> and <code>loads</code> of <code>typing_json</code> mimic the functions <code>load</code> and <code>loads</code> of the standard <code>json</code> library, performing a conversion of the loaded json object to json-encodable type <code>decoded_type</code> before returning.</p>\n\n          </div>"}, "last_serial": 5808326, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "f5969a71a17c5021d599938866048f51", "sha256": "40a1d9bd0ccbf956b7f6e4606b456d29cfd869829c1e440cfc13ad2249a0b973"}, "downloads": -1, "filename": "typing_json-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f5969a71a17c5021d599938866048f51", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 8604, "upload_time": "2019-09-02T12:20:25", "upload_time_iso_8601": "2019-09-02T12:20:25.929878Z", "url": "https://files.pythonhosted.org/packages/30/14/c972d69fe1f2c30f43cb0d88ee9841766e73848f42fe4cac4b9a48460e3a/typing_json-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "577247c988f6034ec023eb25af755c40", "sha256": "5bdd8c4e5f602e21844c4d22dbd9d3e656b57b66b767687aa06e7f8f0dbe7a47"}, "downloads": -1, "filename": "typing-json-0.0.1.tar.gz", "has_sig": false, "md5_digest": "577247c988f6034ec023eb25af755c40", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11563, "upload_time": "2019-09-02T12:20:28", "upload_time_iso_8601": "2019-09-02T12:20:28.715010Z", "url": "https://files.pythonhosted.org/packages/a9/8a/bd7eb436cc66dd9f8e7ddb1714ff7231765d46631c0775a1c44de1f682a0/typing-json-0.0.1.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "0f5a527e746940c41d3b115f2c1a4f2c", "sha256": "72ea7b3ee38bd7da01d6c4977338e1eb71555e2cd891afc004c042cef1df1bae"}, "downloads": -1, "filename": "typing_json-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "0f5a527e746940c41d3b115f2c1a4f2c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 8768, "upload_time": "2019-09-02T17:15:24", "upload_time_iso_8601": "2019-09-02T17:15:24.258295Z", "url": "https://files.pythonhosted.org/packages/ac/82/2743b96c8f98be7c297f597ff97e95e76f16539d5b3180cbc37e77e9d055/typing_json-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c28f041b0f8268123bbe1ab5190d1209", "sha256": "2062723e4f9268d343817899745f302fc5524d1e457c9cc16c3c727fb652adfd"}, "downloads": -1, "filename": "typing-json-0.0.4.tar.gz", "has_sig": false, "md5_digest": "c28f041b0f8268123bbe1ab5190d1209", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11649, "upload_time": "2019-09-02T17:15:26", "upload_time_iso_8601": "2019-09-02T17:15:26.140551Z", "url": "https://files.pythonhosted.org/packages/7e/0c/4688c2138ffd5c78f7606fc18012ec761b0d9771b01781a6fa3388d8e61b/typing-json-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "b2ee1e76366c2ae815e1c8a3f0d63787", "sha256": "29cdc8e28c366912a8aecd34dad4d97212383bef29b8aa784d6b283cc87fc02c"}, "downloads": -1, "filename": "typing_json-0.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "b2ee1e76366c2ae815e1c8a3f0d63787", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9019, "upload_time": "2019-09-03T17:42:12", "upload_time_iso_8601": "2019-09-03T17:42:12.675188Z", "url": "https://files.pythonhosted.org/packages/ee/43/edddc80e62dc330c97eb27f990cd4f9b192a48e624a7680cd7a8fc3f79f6/typing_json-0.0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3bea2e5a148fc26d573331e5c13dc4c1", "sha256": "9f942b345f4f9717a5659d5960d8866f74d131157945f596c6fa214ed26ee6dd"}, "downloads": -1, "filename": "typing-json-0.0.5.tar.gz", "has_sig": false, "md5_digest": "3bea2e5a148fc26d573331e5c13dc4c1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11986, "upload_time": "2019-09-03T17:42:14", "upload_time_iso_8601": "2019-09-03T17:42:14.327510Z", "url": "https://files.pythonhosted.org/packages/2f/f4/553184e122fccf61257f1550732809828adb645b26a4409ab8ac3236066f/typing-json-0.0.5.tar.gz", "yanked": false}], "0.0.6": [{"comment_text": "", "digests": {"md5": "7cb0112e23dfc78c80307ab8f95790ef", "sha256": "4b6c3f6e7a5499e80e344b21733f2e8cb6757bd8a1101dbe76572080abe214b7"}, "downloads": -1, "filename": "typing_json-0.0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "7cb0112e23dfc78c80307ab8f95790ef", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11629, "upload_time": "2019-09-07T15:44:31", "upload_time_iso_8601": "2019-09-07T15:44:31.227973Z", "url": "https://files.pythonhosted.org/packages/3d/a8/c05b4cd84250d657373f81aed9a7993f353873a266118fbd34f9376b750c/typing_json-0.0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a1ba3096866eec3f3b76e9fce5788079", "sha256": "9710a42bf1e17325cca2cf1f8e85dc592cc6b160683a95fc1a84499120f5f1e3"}, "downloads": -1, "filename": "typing-json-0.0.6.tar.gz", "has_sig": false, "md5_digest": "a1ba3096866eec3f3b76e9fce5788079", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15723, "upload_time": "2019-09-07T15:44:33", "upload_time_iso_8601": "2019-09-07T15:44:33.112846Z", "url": "https://files.pythonhosted.org/packages/11/6e/caf3c554a0fff2f410adea5db7483d57aa103ee05fa6382c0aafa2347e1d/typing-json-0.0.6.tar.gz", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "c1e1e45a8ba8907e25c7a5b71b9874fe", "sha256": "15d683be4be67a71f328b27285b0b1dd636ca92839e3ba87ce9726b273334750"}, "downloads": -1, "filename": "typing_json-0.0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "c1e1e45a8ba8907e25c7a5b71b9874fe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11690, "upload_time": "2019-09-10T11:13:14", "upload_time_iso_8601": "2019-09-10T11:13:14.157423Z", "url": "https://files.pythonhosted.org/packages/de/3e/b76dbd2ff1bf7af37574779cf955b9a85345c7b8cfcb8b00c70090cb7d34/typing_json-0.0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "880d49e351164072ccdfe8e5e374ff1f", "sha256": "b2f20a81a976470b54b6e0cfe1b5e570a42a827e74c73d20a6856b54d333438c"}, "downloads": -1, "filename": "typing-json-0.0.7.tar.gz", "has_sig": false, "md5_digest": "880d49e351164072ccdfe8e5e374ff1f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15899, "upload_time": "2019-09-10T11:13:15", "upload_time_iso_8601": "2019-09-10T11:13:15.889247Z", "url": "https://files.pythonhosted.org/packages/cd/2a/6e3f15464ff807a59bf9e2da940b7c31d033612e6ab072bf6e41646252c7/typing-json-0.0.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c1e1e45a8ba8907e25c7a5b71b9874fe", "sha256": "15d683be4be67a71f328b27285b0b1dd636ca92839e3ba87ce9726b273334750"}, "downloads": -1, "filename": "typing_json-0.0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "c1e1e45a8ba8907e25c7a5b71b9874fe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11690, "upload_time": "2019-09-10T11:13:14", "upload_time_iso_8601": "2019-09-10T11:13:14.157423Z", "url": "https://files.pythonhosted.org/packages/de/3e/b76dbd2ff1bf7af37574779cf955b9a85345c7b8cfcb8b00c70090cb7d34/typing_json-0.0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "880d49e351164072ccdfe8e5e374ff1f", "sha256": "b2f20a81a976470b54b6e0cfe1b5e570a42a827e74c73d20a6856b54d333438c"}, "downloads": -1, "filename": "typing-json-0.0.7.tar.gz", "has_sig": false, "md5_digest": "880d49e351164072ccdfe8e5e374ff1f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15899, "upload_time": "2019-09-10T11:13:15", "upload_time_iso_8601": "2019-09-10T11:13:15.889247Z", "url": "https://files.pythonhosted.org/packages/cd/2a/6e3f15464ff807a59bf9e2da940b7c31d033612e6ab072bf6e41646252c7/typing-json-0.0.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:42:37 2020"}