{"info": {"author": "Sean myers", "author_email": "semyers@redhat.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: Information Technology", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7"], "description": "# YAYCL: YAML Configuration loader and cache\n\nAll YAML files stored in the given directory are automatically parsed and loaded on request.\nThe parsed files are exposed as object attributes based on the yaml file name. \n\nFor example, consider a ``conf/config.yaml`` file:\n\n```yaml\ndict_key:\n    key1: value1\n    key2: value2\n    key3: value3\nlist_key:\n    - 1\n    - 2\n    - 3\nstring_key: 'string value'\n```\n\nNow, you can interact with that yaml in python with minimal fuss:\n```python\nimport yaycl\nconf = yaycl.Config('conf')\n# assuming config.yaml is valid yaml, this should work:\nassert 'key2' in conf.config.dict_key\n```\n\nOnce loaded, the yaml contents are cached. The entire cache of a config object can be cleared,\nor a single config file's cache can be cleared:\n```python\nconf.clear()  # clears the entire cache\nconf.config.clear() or conf['config'].clear()  # clears the cache only for config.yaml\n```\n\nNote that, as in the example above, yaml files loaded by yaycl (currently) must be a mapping type at the top level. Files containing more than one yaml document are (currently) unsupported.\n\n## .yaml vs. .yml\n\nMany projects use the `.yml` file extension for YAML files. This is supported by passing the\n`extension` keyword argument to `yaycl.Config`. For this example, assume `conf/config.yaml`\nhas been renamed to `conf/config.yml`:\n\n```python\nimport yaycl\nconf = yaycl.Config('conf', extension='.yml')\n# Now this config will be loaded from conf/config.yml\nassert 'key2' in conf.config.dict_key\n```\n\n## Module Impersonation\n\n`yaycl.Config` is indended to manage config files for an entire project. To facilitate\nthat goal, it supports acting as a module, making configurations importable.\n\nThe module's name doesn't matter, as long as it can be imported by that name.\n\nIn this example, we'll make a module called `conf.py`, with contents:\n\n```python\nimport sys\n\nfrom yaycl import Config\n\nsys.modules[__name__] = Config('/path/to/yaml/config/dir')\n```\n\nNow, the first time `conf` is imported, it will replace itself in conf with an instance of\n`yaycl.Config`, which will be what python imports thereafter. Once done, you can import config\nfiles directly. Here's the same example from before, but using the direct import method:\n\n```python\nfrom conf import config\nassert 'key2' in conf.config.dict_key\n```\n\nFor brevity, following examples will use the module impersonation mechanism.\n\n## Shenanigans\n\nSpecial care has been taken to ensure that all objects are mutated, rather than replaced,\nso all names will reference the same config object.\n\nAll objects representing config files (attributes or items accessed directly from the conf\nmodule) will be some type of `AttrDict`. Attempting to make such a config object be anything\nother than an `AttrDict` (see \"Inherited methods section below)  will probably break everything\nand should not be attempted, lest shenanigans be called.\n\n```python\n# Don't do this...\nconf.key = 'not a dict'\n# ...or this.\nconf['key'] = ['also', 'not', 'a', 'dict']\n```\n\nGenerally speaking, with the exception of runtime overrides (see below), a `yaycl.Config` instance\nshould be considered read-only.\n\n# Local Configuration Overrides\n\nIn addition to loading YAML files, the `yacl.Config` loader supports local override\nfiles. This feature is useful for maintaining a shared set of config files for a team, while\nstill allowing for local configuration.\n\nTake the following example YAML file, `config.local.yaml`:\n\n```yaml\nstring_key: 'new string value'\n```\n\nWhen loaded by the conf loader, the `string_key` will be automatically overridden by the value\nin the local YAML file::\n\n```python\nfrom conf import config\nprint config.string_key\n```\n\nThis will print: `new string value`, instead of the value in the base config, `string value`\n\nThe existing keys (`dict_key` and `list_key` in this case) will not altered by the local\nconfig override.\n\nThis allows for configurations to be stored in revision control, while still making it trivial\nto test new configs, override an existing config, or even create configs that only exist\nlocally.\n\n```\n# .gitignore suggestion; adapt to your SCM of choice\n*.local.yaml\n```\n\n# Runtime Overrides\n\nSometimes writing to the config files is an inconvenient way to ensure that runtime changes\npersist through configuration cache clearing. These \"runtime\" changes can be stashed in the\nruntime overrides dict, allowing them to persist through a cache clear.\n\nThe runtime overrides dictionary mimics the layout of the conf module itself, where\nconfiguration file names are keys in the runtime overrides dictionary. So, for example, to\nupdate the base_url in a way that will persist clearing of the cache, the following will work:\n\n```python\nimport conf\nconf.runtime['config']['string_key'] = 'overridden string key'\nprint conf.config.string_key\n```\n\nThat should print `overridden string key`\n\n## runtime.yaml\n\nIf you have a config file named 'runtime.yaml' that you'd like to load, or really any config\nname that interferes with python names ('get.yaml', for example), note that the configs are\nalways available via dictionary lookup; attribute lookup is supported for brevity, but dict\nitem lookup should always work.\n\n```python\nconf.runtime['runtime'] = {'shenanigans': True}\nassert conf['runtime']['shenanigans']\n```\n\n# Inherited methods\n\nOnce loaded, all configs are instances of `AttrDict`, a very helpful class from the\n[layered-yaml-attrdict-config](https://pypi.python.org/pypi/layered-yaml-attrdict-config/)\npackage. As such, all methods normally available to AttrDicts are available here.\n\nFor example, `Config.save` and `Config`'s inheritance abilities rely on `AttrDict`'s\n`dump` and `rebase` methods, respectively.\n\nOf course, since `AttrDict` is a `dict` subclass, dictionary methods can also be used to\nmanipulate a `yaycl.Config` at runtime. The `clear` method is particularly\nuseful as a means to trigger a reload of all config files by clearing yaycl's cache.\n\n# Thread safety\n\nNo care whatsoever has been taken to ensure thread-safety, so if you're doing threaded\nthings with the conf module you should manage your own locking when making any conf\nchanges. Since most config are loaded from the filesystem, generally this means that\nany changes to the runtime overrides should be done under a lock.\n\n[![Coverage Status](https://coveralls.io/repos/seandst/yaycl/badge.svg?branch=master)](https://coveralls.io/r/seandst/yaycl?branch=master)\n[![Build Status](https://travis-ci.org/seandst/yaycl.svg?branch=master)](https://travis-ci.org/seandst/yaycl)", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/seandst/yaycl", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "yaycl", "package_url": "https://pypi.org/project/yaycl/", "platform": "", "project_url": "https://pypi.org/project/yaycl/", "project_urls": {"Homepage": "https://github.com/seandst/yaycl"}, "release_url": "https://pypi.org/project/yaycl/0.3.0/", "requires_dist": null, "requires_python": "", "summary": "YAML Config Autoloader", "version": "0.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            # YAYCL: YAML Configuration loader and cache<br><br>All YAML files stored in the given directory are automatically parsed and loaded on request.<br>The parsed files are exposed as object attributes based on the yaml file name. <br><br>For example, consider a ``conf/config.yaml`` file:<br><br>```yaml<br>dict_key:<br>    key1: value1<br>    key2: value2<br>    key3: value3<br>list_key:<br>    - 1<br>    - 2<br>    - 3<br>string_key: 'string value'<br>```<br><br>Now, you can interact with that yaml in python with minimal fuss:<br>```python<br>import yaycl<br>conf = yaycl.Config('conf')<br># assuming config.yaml is valid yaml, this should work:<br>assert 'key2' in conf.config.dict_key<br>```<br><br>Once loaded, the yaml contents are cached. The entire cache of a config object can be cleared,<br>or a single config file's cache can be cleared:<br>```python<br>conf.clear()  # clears the entire cache<br>conf.config.clear() or conf['config'].clear()  # clears the cache only for config.yaml<br>```<br><br>Note that, as in the example above, yaml files loaded by yaycl (currently) must be a mapping type at the top level. Files containing more than one yaml document are (currently) unsupported.<br><br>## .yaml vs. .yml<br><br>Many projects use the `.yml` file extension for YAML files. This is supported by passing the<br>`extension` keyword argument to `yaycl.Config`. For this example, assume `conf/config.yaml`<br>has been renamed to `conf/config.yml`:<br><br>```python<br>import yaycl<br>conf = yaycl.Config('conf', extension='.yml')<br># Now this config will be loaded from conf/config.yml<br>assert 'key2' in conf.config.dict_key<br>```<br><br>## Module Impersonation<br><br>`yaycl.Config` is indended to manage config files for an entire project. To facilitate<br>that goal, it supports acting as a module, making configurations importable.<br><br>The module's name doesn't matter, as long as it can be imported by that name.<br><br>In this example, we'll make a module called `conf.py`, with contents:<br><br>```python<br>import sys<br><br>from yaycl import Config<br><br>sys.modules[__name__] = Config('/path/to/yaml/config/dir')<br>```<br><br>Now, the first time `conf` is imported, it will replace itself in conf with an instance of<br>`yaycl.Config`, which will be what python imports thereafter. Once done, you can import config<br>files directly. Here's the same example from before, but using the direct import method:<br><br>```python<br>from conf import config<br>assert 'key2' in conf.config.dict_key<br>```<br><br>For brevity, following examples will use the module impersonation mechanism.<br><br>## Shenanigans<br><br>Special care has been taken to ensure that all objects are mutated, rather than replaced,<br>so all names will reference the same config object.<br><br>All objects representing config files (attributes or items accessed directly from the conf<br>module) will be some type of `AttrDict`. Attempting to make such a config object be anything<br>other than an `AttrDict` (see \"Inherited methods section below)  will probably break everything<br>and should not be attempted, lest shenanigans be called.<br><br>```python<br># Don't do this...<br>conf.key = 'not a dict'<br># ...or this.<br>conf['key'] = ['also', 'not', 'a', 'dict']<br>```<br><br>Generally speaking, with the exception of runtime overrides (see below), a `yaycl.Config` instance<br>should be considered read-only.<br><br># Local Configuration Overrides<br><br>In addition to loading YAML files, the `yacl.Config` loader supports local override<br>files. This feature is useful for maintaining a shared set of config files for a team, while<br>still allowing for local configuration.<br><br>Take the following example YAML file, `config.local.yaml`:<br><br>```yaml<br>string_key: 'new string value'<br>```<br><br>When loaded by the conf loader, the `string_key` will be automatically overridden by the value<br>in the local YAML file::<br><br>```python<br>from conf import config<br>print config.string_key<br>```<br><br>This will print: `new string value`, instead of the value in the base config, `string value`<br><br>The existing keys (`dict_key` and `list_key` in this case) will not altered by the local<br>config override.<br><br>This allows for configurations to be stored in revision control, while still making it trivial<br>to test new configs, override an existing config, or even create configs that only exist<br>locally.<br><br>```<br># .gitignore suggestion; adapt to your SCM of choice<br>*.local.yaml<br>```<br><br># Runtime Overrides<br><br>Sometimes writing to the config files is an inconvenient way to ensure that runtime changes<br>persist through configuration cache clearing. These \"runtime\" changes can be stashed in the<br>runtime overrides dict, allowing them to persist through a cache clear.<br><br>The runtime overrides dictionary mimics the layout of the conf module itself, where<br>configuration file names are keys in the runtime overrides dictionary. So, for example, to<br>update the base_url in a way that will persist clearing of the cache, the following will work:<br><br>```python<br>import conf<br>conf.runtime['config']['string_key'] = 'overridden string key'<br>print conf.config.string_key<br>```<br><br>That should print `overridden string key`<br><br>## runtime.yaml<br><br>If you have a config file named 'runtime.yaml' that you'd like to load, or really any config<br>name that interferes with python names ('get.yaml', for example), note that the configs are<br>always available via dictionary lookup; attribute lookup is supported for brevity, but dict<br>item lookup should always work.<br><br>```python<br>conf.runtime['runtime'] = {'shenanigans': True}<br>assert conf['runtime']['shenanigans']<br>```<br><br># Inherited methods<br><br>Once loaded, all configs are instances of `AttrDict`, a very helpful class from the<br>[layered-yaml-attrdict-config](https://pypi.python.org/pypi/layered-yaml-attrdict-config/)<br>package. As such, all methods normally available to AttrDicts are available here.<br><br>For example, `Config.save` and `Config`'s inheritance abilities rely on `AttrDict`'s<br>`dump` and `rebase` methods, respectively.<br><br>Of course, since `AttrDict` is a `dict` subclass, dictionary methods can also be used to<br>manipulate a `yaycl.Config` at runtime. The `clear` method is particularly<br>useful as a means to trigger a reload of all config files by clearing yaycl's cache.<br><br># Thread safety<br><br>No care whatsoever has been taken to ensure thread-safety, so if you're doing threaded<br>things with the conf module you should manage your own locking when making any conf<br>changes. Since most config are loaded from the filesystem, generally this means that<br>any changes to the runtime overrides should be done under a lock.<br><br>[![Coverage Status](https://coveralls.io/repos/seandst/yaycl/badge.svg?branch=master)](https://coveralls.io/r/seandst/yaycl?branch=master)<br>[![Build Status](https://travis-ci.org/seandst/yaycl.svg?branch=master)](https://travis-ci.org/seandst/yaycl)\n          </div>"}, "last_serial": 3341989, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "08fdad2678c79f479dd1c875a69ce828", "sha256": "aa7be812df589a5e7c7c62f411bd0fdbd0a618b910d59d38cfba3dc6cdcd136a"}, "downloads": -1, "filename": "yaycl-0.1.1-py27-none-any.whl", "has_sig": false, "md5_digest": "08fdad2678c79f479dd1c875a69ce828", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 10293, "upload_time": "2015-02-18T20:34:01", "upload_time_iso_8601": "2015-02-18T20:34:01.739685Z", "url": "https://files.pythonhosted.org/packages/d1/ca/3e031fd9de02663da8fc1c743ce9458ffb9fdeaf7b7be5d2bdf8d66feda3/yaycl-0.1.1-py27-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e8ba2080082f6f0556e8905581b226e9", "sha256": "1add87817b72f71e7bd548dd84292dc49b240234331b3e6e71d0f9c69a2fcab5"}, "downloads": -1, "filename": "yaycl-0.1.1.tar.gz", "has_sig": false, "md5_digest": "e8ba2080082f6f0556e8905581b226e9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9505, "upload_time": "2015-02-18T20:33:59", "upload_time_iso_8601": "2015-02-18T20:33:59.476077Z", "url": "https://files.pythonhosted.org/packages/1b/7e/9e740dde56ff58a70040a54146dbd97ab65162777daae50b68e93ec8bb31/yaycl-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "cc408713a61a73258b78abb45b7ea8af", "sha256": "b63f294f93fa017f9a1b623e7753c7031652420079cc4887647be03fceb40242"}, "downloads": -1, "filename": "yaycl-0.1.2-py27-none-any.whl", "has_sig": false, "md5_digest": "cc408713a61a73258b78abb45b7ea8af", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 10373, "upload_time": "2015-02-23T22:34:03", "upload_time_iso_8601": "2015-02-23T22:34:03.175357Z", "url": "https://files.pythonhosted.org/packages/5b/0a/47d7c0dcd19f8a45ffecb52cbe6205d7df3318005648933dfc051d6edeb8/yaycl-0.1.2-py27-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6202809ea4a908407a2e29c28654b8e2", "sha256": "f11c213d8fcefc64988bbc04bf6a56c496aa23efe3c886a81af1cc28c1ae898a"}, "downloads": -1, "filename": "yaycl-0.1.2.tar.gz", "has_sig": false, "md5_digest": "6202809ea4a908407a2e29c28654b8e2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9726, "upload_time": "2015-02-23T22:34:00", "upload_time_iso_8601": "2015-02-23T22:34:00.591790Z", "url": "https://files.pythonhosted.org/packages/2b/f1/867de81c4042d6a01c32e2dd889e607175261477a71ecb122ea633bdd9fa/yaycl-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "8de566a8d6edd2811e8f6a659fda0615", "sha256": "b24be1b47ad446363b0c588054fd89993b32869f7cd62dc63ba7f434f67385db"}, "downloads": -1, "filename": "yaycl-0.1.3-py2.7.egg", "has_sig": false, "md5_digest": "8de566a8d6edd2811e8f6a659fda0615", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 10773, "upload_time": "2015-09-01T15:36:19", "upload_time_iso_8601": "2015-09-01T15:36:19.845606Z", "url": "https://files.pythonhosted.org/packages/72/2d/4d1fbf6d34635de0065af85b5989ec12b55ba4875de827752d8322cc2a1d/yaycl-0.1.3-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "87d83b573caf07703bce555c1ec0062a", "sha256": "5ae4695232108445e9da44f22e626eb9c66558fab7fa59e511c0f967e72c92f8"}, "downloads": -1, "filename": "yaycl-0.1.3.tar.gz", "has_sig": false, "md5_digest": "87d83b573caf07703bce555c1ec0062a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9778, "upload_time": "2015-09-01T15:36:10", "upload_time_iso_8601": "2015-09-01T15:36:10.942573Z", "url": "https://files.pythonhosted.org/packages/e8/14/675b503bdc95865773d565ca633524a8072e68867d05871a5cbca7ef3637/yaycl-0.1.3.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "0eab3e735e89bc88847633819eb13b4f", "sha256": "0a761497e77389a4a4d764d216ec1554e69370bd33b9d6619f693d736de95b40"}, "downloads": -1, "filename": "yaycl-0.2.0-py2.7.egg", "has_sig": false, "md5_digest": "0eab3e735e89bc88847633819eb13b4f", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 11166, "upload_time": "2015-09-13T21:01:33", "upload_time_iso_8601": "2015-09-13T21:01:33.372986Z", "url": "https://files.pythonhosted.org/packages/80/00/74cd69966693a4818c149d052ceea9cb3d061e96bc2454c51d2e77000574/yaycl-0.2.0-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "86981cafab2babae3a63ee95facebfae", "sha256": "f30718ba551395e796f4e8438ca5f348c7ce7759f6714cf1e4af531d035c217b"}, "downloads": -1, "filename": "yaycl-0.2.0.tar.gz", "has_sig": false, "md5_digest": "86981cafab2babae3a63ee95facebfae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10099, "upload_time": "2015-09-13T21:01:29", "upload_time_iso_8601": "2015-09-13T21:01:29.523137Z", "url": "https://files.pythonhosted.org/packages/b8/d0/afc643ede500dfbfcbe955df6be1e60c5de0b7265f6b3a19ba2f75eccda4/yaycl-0.2.0.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "71472b2b332ca613984f6ebb4f4f3d92", "sha256": "7c0895613b1c3d8ccb3b0615faa3920eac6b39255d36fcd4ec4d750253e49373"}, "downloads": -1, "filename": "yaycl-0.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "71472b2b332ca613984f6ebb4f4f3d92", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 10977, "upload_time": "2017-11-17T17:16:07", "upload_time_iso_8601": "2017-11-17T17:16:07.539483Z", "url": "https://files.pythonhosted.org/packages/05/60/18dad9c630d32e9925c094c1ab8c539c543a2f477956eb28879104fe5879/yaycl-0.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0359351dbbba5e7dca4db28cf2899d21", "sha256": "81d8a45092d9069d517d3e090579e5687f6e896a99d5217e8713661f744a58ba"}, "downloads": -1, "filename": "yaycl-0.3.0.tar.gz", "has_sig": false, "md5_digest": "0359351dbbba5e7dca4db28cf2899d21", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10241, "upload_time": "2017-11-17T17:12:47", "upload_time_iso_8601": "2017-11-17T17:12:47.765399Z", "url": "https://files.pythonhosted.org/packages/5a/c0/4cc05c689260f85b9465a768d0c253737a72dedef684d6fcc5df7b897f1c/yaycl-0.3.0.tar.gz", "yanked": false}], "v0.1.0": [{"comment_text": "", "digests": {"md5": "7f03dd5396768701ca24b9f5c3182cc2", "sha256": "7588e9f1ad6ecf24aa2ffe8b30adee31a94bfb50f8006f4cf3d01564efe86330"}, "downloads": -1, "filename": "yaycl-v0.1.0.tar.gz", "has_sig": false, "md5_digest": "7f03dd5396768701ca24b9f5c3182cc2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8723, "upload_time": "2015-02-10T02:13:09", "upload_time_iso_8601": "2015-02-10T02:13:09.543833Z", "url": "https://files.pythonhosted.org/packages/0f/6d/2dae5adb755d21ca997926da87565bb030ea92a88a03cb88044574b52ed8/yaycl-v0.1.0.tar.gz", "yanked": false}], "v0.1.1": [{"comment_text": "", "digests": {"md5": "3f9a113e10038f9e802eecdc6a2dcd44", "sha256": "7eaa6dc8c2ca47fba622cb9df01436f01ba0b471efe27022730986c41996eaff"}, "downloads": -1, "filename": "yaycl-v0.1.1.tar.gz", "has_sig": false, "md5_digest": "3f9a113e10038f9e802eecdc6a2dcd44", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9458, "upload_time": "2015-02-12T18:57:50", "upload_time_iso_8601": "2015-02-12T18:57:50.790464Z", "url": "https://files.pythonhosted.org/packages/0d/6b/072e0c64c77995205212a20a6339a6eec6aacc1f4e20a68fd4afdffe77a1/yaycl-v0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "71472b2b332ca613984f6ebb4f4f3d92", "sha256": "7c0895613b1c3d8ccb3b0615faa3920eac6b39255d36fcd4ec4d750253e49373"}, "downloads": -1, "filename": "yaycl-0.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "71472b2b332ca613984f6ebb4f4f3d92", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 10977, "upload_time": "2017-11-17T17:16:07", "upload_time_iso_8601": "2017-11-17T17:16:07.539483Z", "url": "https://files.pythonhosted.org/packages/05/60/18dad9c630d32e9925c094c1ab8c539c543a2f477956eb28879104fe5879/yaycl-0.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0359351dbbba5e7dca4db28cf2899d21", "sha256": "81d8a45092d9069d517d3e090579e5687f6e896a99d5217e8713661f744a58ba"}, "downloads": -1, "filename": "yaycl-0.3.0.tar.gz", "has_sig": false, "md5_digest": "0359351dbbba5e7dca4db28cf2899d21", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10241, "upload_time": "2017-11-17T17:12:47", "upload_time_iso_8601": "2017-11-17T17:12:47.765399Z", "url": "https://files.pythonhosted.org/packages/5a/c0/4cc05c689260f85b9465a768d0c253737a72dedef684d6fcc5df7b897f1c/yaycl-0.3.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:22:35 2020"}