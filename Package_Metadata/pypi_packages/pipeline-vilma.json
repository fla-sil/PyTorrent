{"info": {"author": "Claudio Busatto", "author_email": "cjcbusatto@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Pipeline Vilma\n\n## Introduction\n\nPipeline Vilma is a Data Pipeline designed to be used in Machine Learning\nprojects. The main goal is to create a pipeline which allows user to only\nannotate information and let the process to the pipeline.\n\nThe design is based on components communicating through messages, therefore it\nis possible to use them all together, as we design or connect the components to\nyour current data pipeline.\n\n## Components\n\n### Provider\n\n```python\nclass Provider:\n\"\"\"\nAn abstract class used to represent a data provider.\nExamples of data providers:\n- RGB Camera, providing frames\n- Humidity sensor, providing actual humidity level\n- Termographic camera, providing a heatmap\n...\n\nAttributes\n----------\nqueue_server : str\n    the IPv4 of a RabbitMQ queue server\nqueue_output : str\n    the name of the queue where provider will publish their data\nsensor_id : str\n    an unique identification of the provider, e.g, rgbcamera, microphone, etc\n\nMethods\n-------\npack_data(self, data_type, content)\n    Based on the data type, choose the right package format for the content\n\nrun(self, loop_interval=0.016)\n    Main loop method that should be implemented, in order to describe a provider\n    behaviour\n\nforward(self, message)\n    Forward the package to the next component of the pipeline (queue_output)\n\"\"\"\n```\n\n### Collector\n\n```python\nclass Collector:\n\"\"\"\nAn abstract class used to represent a data collector.\nThe component is the responsible for creating a dataset from providers input\n...\n\nAttributes\n----------\nbypass : bool\n    some applications cannot store data, and or create dataset for privacy\n    reasons, therefore collector can work in bypass mode where it only forwards\n    the received data\nratio : floatclass\n    the percentage (between [0,1]) number of samples to be collected, i.e.,\n    if \"ratio\" is set to 0.5, half of the samples received on collector will be\n    stored for dataset creation\nqueue_server : str\n    the IPv4 of a RabbitMQ queue server\nqueue_input: str\n    the name of the queue from where collector consume\nqueue_output : str\n    the name of the queue where provider will publish their data\ndata_api_config: dict\n    expects a Python dictionary with the endpoints to map the class to an user\n    implemented API. It allows the component to support different data API\n    solutions (like different databases, languages, implementations) as long\n    as the expected endpoints are supported.\n\n    Expected dictionary:\n        {\n            \"base_url\": \"http://192.168.0.1\" # IP where the API is running\n            \"port\": 3333,                    # The API's server portclass\n            \"endpoints\": {\n                \"add_item\": \"/collection\",\n                \"get_item\": \"/collection/<ID>\",\n                \"mark_trained\": \"/collection/<ID>\",\n                \"count_labeled\": \"/collector/counter\",\n                \"get_training_set\": \"/dataset/\"\n            }\n        }\n\n    Endpoints description:\n    - add_item\n        - Method type: HTTP POST\n        - URL format: http://host:port/resource\n        - Data: support the JSON messager structure, e.g. ImageBase64\n        - Request example:\n            - http://192.168.0.1:3333/collection\n            - Data: {\"x\": data, \"y\": data }\n        - Response example:\n            - The JSON messager sent\n    - get_item\n        - Method type: HTTP GET\n        - URL format: http://host:port/resource/<ID>\n        - Request example:\n            - http://192.168.0.1:3333/collection/1\n        - Response example:\n            - A JSON pipeline supported message item\n    - mark_trained\n        - Method type: HTTP PUT\n        - URL format: http://host:port/resource/<ID>\n        - Data: {\"status\": \"readyForTraining\"}\n        - Request example:\n            - http://192.168.0.1:3333/collection/1\n            - Data: {\"status\": \"readyForTraining\"}\n        - Response example:\n            {\"message\": \"success\"}\n    - count_labeled:\n        - Method type: HTTP GET\n        - URL format: http://host:port/resource\n        - Request example:\n            - http://192.168.0.1:3333/collection-counter\n        - Response example:\n            - { \"readyForTraining\": 123 }\n    - get_training_set:\n        - Method type: HTTP GET\n        - URL format: http://host:port/resource\n        - Request example:\n            - http://192.168.0.1:3333/training-set\n        - Response example:\n            - { \"readyForTraining\": [\"itemId1\", \"itemId2\"] }\n\nMethods\n-------\nrun(self)\n    Starts consuming collectors input queue\n\non_new_message(self, ch, method, properties, body)\n    Based on component's configuration, perform the actions on each\n    received message.\n    Finally, forwards the current message state to the next component\n    of the pipeline.\n\nreceive(self, callback)\n    Creates a listener on collector's input queue\n\nforward(self, sensor_id, message)\n    Forward the message to an individual queue related to the unique\n    sensor id\n\n\"\"\"\n```\n\n### CollectorDataApi\n\n```python\nclass CollectorDataApi:\n\"\"\"\nA class used to link an HTTP Data API to Collector component.\nIt is reponsible to allow users to create different APIs\nimplementation and by that the usage of any database.\nTo connect it to the pipeline, it is required the\nimplementation of the APIs described in Collector.\n...\n\nStatics\n----------\nSTATUS_FOR_LABELING : str\n    default value: 'labeling-required'\n    an internal status used to notify other components about a\n    data item waiting for labeling\nSTATUS_READY_FOR_TRAINING : str\n    default value: 'readyForTraining'\n    an internal status used to notify other components\n    about a data item ready for training\n\nAttributes\n----------\nstorage_api : dict\n    expects a Python dictionary with the endpoints to an API\n    implemented to store the data on a database or any other\n    persistence system\n\n    An API, persisting the data on a MongoDB is available on the examples.\n\nMethods\n-------\ndef _add_labeling_properties(self, message)\n    Include on the message the labeling status and creation timestamp\n\ndef _insert_on_db(self, message)\n    Make a request to the API to persist the message\n\ndef add_item(self, message)\ndef get_item(self, item_id)\ndef mark_trained(self, item_id, status)\ndef get_training_data(self)\ndef count_labeled(self)\n\ndef store(self, message)\n    public method responsible to execute the private ones and store\n    the message on the database\n\n\"\"\"\n```\n\n### FileManager\n\n```python\nclass FileManager:\n\"\"\"\nA class used to create and manage required files for training and evaluation\nprocess.\nTo connect it to the pipeline, it is required the implementation of the API\nendpoints described in CollectorDataApi.\n...\n\nAttributes\n----------\nqueue_server : str\n    the IPv4 of a RabbitMQ queue server\nqueue_output : str\n    the name of the queue where FileManager will publish their data\nretrain_counter : number\n    FileManager is designed to work together with a Trainer component,\n    therefore, it is possible to define a minimum number of files to trigger\n    this interaction. If retrain_counter is set to 20, every new 20 labeled\n    instances are ready for training, this data is turned into physical files\n    and then forwarded to training process.\ndata_api : dict\n    expects a Python dictionary with the endpoints to an API implemented\n    to store the data on a database or any other persistence system\n\n    An API, persisting the data on a MongoDB is available on the examples.\n\nMethods\n-------\ndef run(self, loop_interval=0.016)\n    Run the component with the following behaviour:\n    - Get the number of ready for training items through DataApi\n    - In case, the number of items is greater than the retrain_counter, download\n    the data and forward it to the next component which is usually a training\n    component\n    - Mark the forwarded items as sent to training\n\ndef mark_data_as_included_in_the_training_process(self, item_ids)\n    Set the items on the DataApi as \"already in training set\"\n\ndef _download_data_and_labels(self)\n    Download the information from DataApi and call a method to be implemented to\n    store this data in a physical file, i.e., it is expected from user\n    to develop how the file should be, e.g. for images an JPG, for sound MP3,\n    etc.\n\ndef store_on_filemanager(self, name, x, y)\n    Store an item identified by its name, together with its X data, e.g., for\n    image the Bas64 encoded image\n    and its Y, e.g., for image detection, the annotated bounding boxes\n\ndef get_dataset_paths(self)\n    Provide the absolute path where the items and their annotations where\n    stored. It is expected to return an tuple in the format (items, labels)\n\ndef forward_to_trainer(self, message)\n    Forward the set of ready items to a training component\n\"\"\"\n```\n\n### Instancer\n\n```python\nclass Instancer:\n\"\"\"\nAn abstract class used to create instances based on multiple sensors (providers)\nThe instancer is responsible to create data relationship from the different\nproviders, based on the necessities of the estimator component\n\nAttributes\n----------\nnumber_of_providers : int\n    the current number of providers included in the pipeline\nqueue_server : str\n    the IPv4 of a RabbitMQ queue server\nqueue_input: str\n    the name of the queue from where collector consume\nqueue_output : str\n    the name of the queue where provider will publish their data\n\nMethods\n-------\nrun(self)\n    Should be implemented from the user, in order to describe the provider\n    behaviour\n\ncreate_custom_instance(self)\n    Should be implemented from the user, in order to describe the provider\n    behaviour\n\ncreate_simple_instance(self)\n    Create an instance directly from the data from the input queue\n\ncreate_instance_by_time_window(self, sensor_id, time_window_s)\n    Create an instance based on the list of messages received in a time window\n\ncreate_instance_by_repetition(self, sensor_id, number_of_messages)\n    Create an instance based on a defined number of received messages.\n    e.g.: a model requires 7 images as its input.\n\ncreate_instance_by_syncing_all_providers(self)\n    Synchronize all the providers and create an instance including all of them.\n\nforward(self, message)\n    Forward the message to the next component of the pipeline\n\n\"\"\"\n```\n\n### Messager\n\n```python\nclass Messager:\n\"\"\"\nAn class responsible to define the communication between components\nIt is a wrapper on RabbitMQ library pika\n\nAttributes\n----------\nserver_url : str\n    the IPv4 of a RabbitMQ queue server\nqueue_name: str\n    the name of the queue to be interacted\n\nMethods\n-------\nvalidate(self, message)\n    Validate the received message, based on the defined schema\n\npublish_to_sibling_queue(self, message, unique_id, validate=True)\n    Send a message to a fragmented queue component, i.e., to a component which\n    expects\n    multiple queues as its input. Used to publish providers' data in individual\n    queues\n\npublish(self, message, exchange='', validate=True)\n    Publish the data to the Messager's queue\n\nget_message(self)\n    Get a message from the queue, FIFO-based.\n\nconsume(self, callback)\n    Provide a listener to the queue, so every new message on the queue, the\n    callback (implemented by the user) is called\n\n\"\"\"\n```\n\n### Estimator\n\n```python\nclass Estimator:\n\"\"\"\nAn class responsible to define the behavior of an estimator responsible to\nperform inferences on the pipeline's data\n\nAttributes\n----------\nqueue_server : str\n    the IPv4 of a RabbitMQ queue server\ninput_queue_instancer : str\n    the name of the queue to be interacted\ninput_evaluator_queue : str\n    the name of the queue used from evaluator to inform estimator about\n    new models\noutput_queue : str\n    the name of the queue to be interacted\n\nMethods\n-------\nget_estimator_model(self)\n    Should be implemented from the user, in order to describe the desired\n    behaviour\n\nset_estimator_model(self, message)\n    Should be implemented from the user, in order to describe the desired\n    behaviour\n\nupdate_model(self)\n    Should be implemented from the user, in order to describe the desired\n    behaviour\n\nestimate(self, message)\n    Should be implemented from the user, in order to describe the desired\n    behaviour\n\nrun(self)\n    Provide the component's behaviour:\n        - Check for new models available\n        - Get a message from the queue\n        - Make an inference\n        - Forward the results\n\nforward(self, message)\n    Forward the message to the next component of the pipeline\n\n\"\"\"\n```\n\n### Evaluator\n\n```python\nclass Evaluator:\n\"\"\"\nAn abstract class responsible to evaluate the quality of trained models.\n\nGet a list of models from a trainer component and forwards the best one for an\nEstimator component, therefore, the inference is always done with the best\npossible results.\n\nConstructor\n----------\n\nAttributes\n----------\n\nqueue_server : str\n    the IPv4 of a RabbitMQ queue server\ninput_queue : Messager\n    the name of the queue to be consumed\noutput_queue : Messager\n    the name of the queue which Evaluator publish its data\nevaluated : list(key,value)\n    a list of already evaluated models\ncurrent_best : (key,value)\n    the current best model, e.g. weights, evaluated, i.e., the one recommended\n    to be used on an Estimator component\n\nMethods\n-------\n\nevaluate_models(self, message)\n    Should be implemented from the user, in order to describe the provider\n    behaviour\n\ninclude_evaluation_to_list(self, key, value)\n    self.evaluated.append((key, value))\n\nis_included_in_evaluation_list(self, key):\n    check if a model, identified by its key, was already evaluated\n    this can reduce drastically the processing time of the component\n\nget_current_best_evaluated(self):\n    return the actual best model evaluated in the format (key,value)\n    key: model path\n    value: it's evaluation value, e.g. mAP\n\nset_current_best_evaluated(self, key, value):\n    update the current best evaluated model that is informed to the interested\n    components by the queue system\n\nrun(self):\n    implements the behaviour of the component\n\nforward(self, message):\n    publish the evaluated data to next component\n    the message follows the format:\n    {\n        \"key\": \"uniqueFilePath\",\n        \"value\" \"the evaluation value of the model\",\n        \"params\": {\n            \"modelDefinition\": \"some extra data about the results\"\n        }\n    }\n\"\"\"\n```\n\n### TrainerDetection\n```python\n\nclass TrainerDetection:\n    \"\"\"\n    An abstract class responsible to evaluate the quality of trained models.\n\n    Get a list of models from a trainer component and forwards the best one for an\n    Estimator component, therefore, the inference is always done with the best\n    possible results.\n\n    Constructor\n    ----------\n\n    Attributes\n    ----------\n\n    queue_server : str\n        the IPv4 of a RabbitMQ queue server\n    queue_input : str\n        the name of the queue to be consumed\n    queue_output : str\n        the name of the queue which Evaluator publish its data\n    \"\"\" \n\n    def get_new_training_samples(self):\n        \"\"\"\n        \"\"\"\n\n    def train(self, pretrained):\n        \"\"\"\n        Should be implemented from the user, in order to describe the component's\n        behaviour\n        \"\"\"\n\n    def create_train_and_validation_files(self, message):\n        \"\"\"\n        Should be implemented from the user, in order to describe the component's\n        behaviour\n        \"\"\"\n\n    def get_latest_pretrained_weights(self):\n        \"\"\"\n        Should be implemented from the user, in order to describe the component's\n        behaviour\n        \"\"\"\n\n    def send_weights_to_evaluator(self):\n        \"\"\"\n        Should be implemented from the user, in order to describe the component's\n        behaviour\n        \"\"\"\n\n    def run(self, loop_interval=0.016):\n        \"\"\"\n        Run the component with the following behaviour:\n        - Check for new samples for training\n        - In case there is new samples, split them on validation and training\n        - Retrain\n        - Forward the trained models\n        the data and forward it to the next component which is usually a training\n        component\n        - Mark the forwarded items as sent to training\n        \"\"\"\n\n    def forward(self, message):\n        \"\"\"\n        Forward the message to the next component of the pipeline\n        \"\"\"\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/cjcbusatto/pipeline-vilma", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pipeline-vilma", "package_url": "https://pypi.org/project/pipeline-vilma/", "platform": "", "project_url": "https://pypi.org/project/pipeline-vilma/", "project_urls": {"Homepage": "https://github.com/cjcbusatto/pipeline-vilma"}, "release_url": "https://pypi.org/project/pipeline-vilma/0.0.32/", "requires_dist": ["loguru (==0.3.2)", "pika (==1.1.0)", "requests (==2.22.0)"], "requires_python": ">=3.6", "summary": "Data pipeline", "version": "0.0.32", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Pipeline Vilma</h1>\n<h2>Introduction</h2>\n<p>Pipeline Vilma is a Data Pipeline designed to be used in Machine Learning\nprojects. The main goal is to create a pipeline which allows user to only\nannotate information and let the process to the pipeline.</p>\n<p>The design is based on components communicating through messages, therefore it\nis possible to use them all together, as we design or connect the components to\nyour current data pipeline.</p>\n<h2>Components</h2>\n<h3>Provider</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Provider</span><span class=\"p\">:</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">An abstract class used to represent a data provider.</span>\n<span class=\"sd\">Examples of data providers:</span>\n<span class=\"sd\">- RGB Camera, providing frames</span>\n<span class=\"sd\">- Humidity sensor, providing actual humidity level</span>\n<span class=\"sd\">- Termographic camera, providing a heatmap</span>\n<span class=\"sd\">...</span>\n\n<span class=\"sd\">Attributes</span>\n<span class=\"sd\">----------</span>\n<span class=\"sd\">queue_server : str</span>\n<span class=\"sd\">    the IPv4 of a RabbitMQ queue server</span>\n<span class=\"sd\">queue_output : str</span>\n<span class=\"sd\">    the name of the queue where provider will publish their data</span>\n<span class=\"sd\">sensor_id : str</span>\n<span class=\"sd\">    an unique identification of the provider, e.g, rgbcamera, microphone, etc</span>\n\n<span class=\"sd\">Methods</span>\n<span class=\"sd\">-------</span>\n<span class=\"sd\">pack_data(self, data_type, content)</span>\n<span class=\"sd\">    Based on the data type, choose the right package format for the content</span>\n\n<span class=\"sd\">run(self, loop_interval=0.016)</span>\n<span class=\"sd\">    Main loop method that should be implemented, in order to describe a provider</span>\n<span class=\"sd\">    behaviour</span>\n\n<span class=\"sd\">forward(self, message)</span>\n<span class=\"sd\">    Forward the package to the next component of the pipeline (queue_output)</span>\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<h3>Collector</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Collector</span><span class=\"p\">:</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">An abstract class used to represent a data collector.</span>\n<span class=\"sd\">The component is the responsible for creating a dataset from providers input</span>\n<span class=\"sd\">...</span>\n\n<span class=\"sd\">Attributes</span>\n<span class=\"sd\">----------</span>\n<span class=\"sd\">bypass : bool</span>\n<span class=\"sd\">    some applications cannot store data, and or create dataset for privacy</span>\n<span class=\"sd\">    reasons, therefore collector can work in bypass mode where it only forwards</span>\n<span class=\"sd\">    the received data</span>\n<span class=\"sd\">ratio : floatclass</span>\n<span class=\"sd\">    the percentage (between [0,1]) number of samples to be collected, i.e.,</span>\n<span class=\"sd\">    if \"ratio\" is set to 0.5, half of the samples received on collector will be</span>\n<span class=\"sd\">    stored for dataset creation</span>\n<span class=\"sd\">queue_server : str</span>\n<span class=\"sd\">    the IPv4 of a RabbitMQ queue server</span>\n<span class=\"sd\">queue_input: str</span>\n<span class=\"sd\">    the name of the queue from where collector consume</span>\n<span class=\"sd\">queue_output : str</span>\n<span class=\"sd\">    the name of the queue where provider will publish their data</span>\n<span class=\"sd\">data_api_config: dict</span>\n<span class=\"sd\">    expects a Python dictionary with the endpoints to map the class to an user</span>\n<span class=\"sd\">    implemented API. It allows the component to support different data API</span>\n<span class=\"sd\">    solutions (like different databases, languages, implementations) as long</span>\n<span class=\"sd\">    as the expected endpoints are supported.</span>\n\n<span class=\"sd\">    Expected dictionary:</span>\n<span class=\"sd\">        {</span>\n<span class=\"sd\">            \"base_url\": \"http://192.168.0.1\" # IP where the API is running</span>\n<span class=\"sd\">            \"port\": 3333,                    # The API's server portclass</span>\n<span class=\"sd\">            \"endpoints\": {</span>\n<span class=\"sd\">                \"add_item\": \"/collection\",</span>\n<span class=\"sd\">                \"get_item\": \"/collection/&lt;ID&gt;\",</span>\n<span class=\"sd\">                \"mark_trained\": \"/collection/&lt;ID&gt;\",</span>\n<span class=\"sd\">                \"count_labeled\": \"/collector/counter\",</span>\n<span class=\"sd\">                \"get_training_set\": \"/dataset/\"</span>\n<span class=\"sd\">            }</span>\n<span class=\"sd\">        }</span>\n\n<span class=\"sd\">    Endpoints description:</span>\n<span class=\"sd\">    - add_item</span>\n<span class=\"sd\">        - Method type: HTTP POST</span>\n<span class=\"sd\">        - URL format: http://host:port/resource</span>\n<span class=\"sd\">        - Data: support the JSON messager structure, e.g. ImageBase64</span>\n<span class=\"sd\">        - Request example:</span>\n<span class=\"sd\">            - http://192.168.0.1:3333/collection</span>\n<span class=\"sd\">            - Data: {\"x\": data, \"y\": data }</span>\n<span class=\"sd\">        - Response example:</span>\n<span class=\"sd\">            - The JSON messager sent</span>\n<span class=\"sd\">    - get_item</span>\n<span class=\"sd\">        - Method type: HTTP GET</span>\n<span class=\"sd\">        - URL format: http://host:port/resource/&lt;ID&gt;</span>\n<span class=\"sd\">        - Request example:</span>\n<span class=\"sd\">            - http://192.168.0.1:3333/collection/1</span>\n<span class=\"sd\">        - Response example:</span>\n<span class=\"sd\">            - A JSON pipeline supported message item</span>\n<span class=\"sd\">    - mark_trained</span>\n<span class=\"sd\">        - Method type: HTTP PUT</span>\n<span class=\"sd\">        - URL format: http://host:port/resource/&lt;ID&gt;</span>\n<span class=\"sd\">        - Data: {\"status\": \"readyForTraining\"}</span>\n<span class=\"sd\">        - Request example:</span>\n<span class=\"sd\">            - http://192.168.0.1:3333/collection/1</span>\n<span class=\"sd\">            - Data: {\"status\": \"readyForTraining\"}</span>\n<span class=\"sd\">        - Response example:</span>\n<span class=\"sd\">            {\"message\": \"success\"}</span>\n<span class=\"sd\">    - count_labeled:</span>\n<span class=\"sd\">        - Method type: HTTP GET</span>\n<span class=\"sd\">        - URL format: http://host:port/resource</span>\n<span class=\"sd\">        - Request example:</span>\n<span class=\"sd\">            - http://192.168.0.1:3333/collection-counter</span>\n<span class=\"sd\">        - Response example:</span>\n<span class=\"sd\">            - { \"readyForTraining\": 123 }</span>\n<span class=\"sd\">    - get_training_set:</span>\n<span class=\"sd\">        - Method type: HTTP GET</span>\n<span class=\"sd\">        - URL format: http://host:port/resource</span>\n<span class=\"sd\">        - Request example:</span>\n<span class=\"sd\">            - http://192.168.0.1:3333/training-set</span>\n<span class=\"sd\">        - Response example:</span>\n<span class=\"sd\">            - { \"readyForTraining\": [\"itemId1\", \"itemId2\"] }</span>\n\n<span class=\"sd\">Methods</span>\n<span class=\"sd\">-------</span>\n<span class=\"sd\">run(self)</span>\n<span class=\"sd\">    Starts consuming collectors input queue</span>\n\n<span class=\"sd\">on_new_message(self, ch, method, properties, body)</span>\n<span class=\"sd\">    Based on component's configuration, perform the actions on each</span>\n<span class=\"sd\">    received message.</span>\n<span class=\"sd\">    Finally, forwards the current message state to the next component</span>\n<span class=\"sd\">    of the pipeline.</span>\n\n<span class=\"sd\">receive(self, callback)</span>\n<span class=\"sd\">    Creates a listener on collector's input queue</span>\n\n<span class=\"sd\">forward(self, sensor_id, message)</span>\n<span class=\"sd\">    Forward the message to an individual queue related to the unique</span>\n<span class=\"sd\">    sensor id</span>\n\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<h3>CollectorDataApi</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">CollectorDataApi</span><span class=\"p\">:</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">A class used to link an HTTP Data API to Collector component.</span>\n<span class=\"sd\">It is reponsible to allow users to create different APIs</span>\n<span class=\"sd\">implementation and by that the usage of any database.</span>\n<span class=\"sd\">To connect it to the pipeline, it is required the</span>\n<span class=\"sd\">implementation of the APIs described in Collector.</span>\n<span class=\"sd\">...</span>\n\n<span class=\"sd\">Statics</span>\n<span class=\"sd\">----------</span>\n<span class=\"sd\">STATUS_FOR_LABELING : str</span>\n<span class=\"sd\">    default value: 'labeling-required'</span>\n<span class=\"sd\">    an internal status used to notify other components about a</span>\n<span class=\"sd\">    data item waiting for labeling</span>\n<span class=\"sd\">STATUS_READY_FOR_TRAINING : str</span>\n<span class=\"sd\">    default value: 'readyForTraining'</span>\n<span class=\"sd\">    an internal status used to notify other components</span>\n<span class=\"sd\">    about a data item ready for training</span>\n\n<span class=\"sd\">Attributes</span>\n<span class=\"sd\">----------</span>\n<span class=\"sd\">storage_api : dict</span>\n<span class=\"sd\">    expects a Python dictionary with the endpoints to an API</span>\n<span class=\"sd\">    implemented to store the data on a database or any other</span>\n<span class=\"sd\">    persistence system</span>\n\n<span class=\"sd\">    An API, persisting the data on a MongoDB is available on the examples.</span>\n\n<span class=\"sd\">Methods</span>\n<span class=\"sd\">-------</span>\n<span class=\"sd\">def _add_labeling_properties(self, message)</span>\n<span class=\"sd\">    Include on the message the labeling status and creation timestamp</span>\n\n<span class=\"sd\">def _insert_on_db(self, message)</span>\n<span class=\"sd\">    Make a request to the API to persist the message</span>\n\n<span class=\"sd\">def add_item(self, message)</span>\n<span class=\"sd\">def get_item(self, item_id)</span>\n<span class=\"sd\">def mark_trained(self, item_id, status)</span>\n<span class=\"sd\">def get_training_data(self)</span>\n<span class=\"sd\">def count_labeled(self)</span>\n\n<span class=\"sd\">def store(self, message)</span>\n<span class=\"sd\">    public method responsible to execute the private ones and store</span>\n<span class=\"sd\">    the message on the database</span>\n\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<h3>FileManager</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">FileManager</span><span class=\"p\">:</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">A class used to create and manage required files for training and evaluation</span>\n<span class=\"sd\">process.</span>\n<span class=\"sd\">To connect it to the pipeline, it is required the implementation of the API</span>\n<span class=\"sd\">endpoints described in CollectorDataApi.</span>\n<span class=\"sd\">...</span>\n\n<span class=\"sd\">Attributes</span>\n<span class=\"sd\">----------</span>\n<span class=\"sd\">queue_server : str</span>\n<span class=\"sd\">    the IPv4 of a RabbitMQ queue server</span>\n<span class=\"sd\">queue_output : str</span>\n<span class=\"sd\">    the name of the queue where FileManager will publish their data</span>\n<span class=\"sd\">retrain_counter : number</span>\n<span class=\"sd\">    FileManager is designed to work together with a Trainer component,</span>\n<span class=\"sd\">    therefore, it is possible to define a minimum number of files to trigger</span>\n<span class=\"sd\">    this interaction. If retrain_counter is set to 20, every new 20 labeled</span>\n<span class=\"sd\">    instances are ready for training, this data is turned into physical files</span>\n<span class=\"sd\">    and then forwarded to training process.</span>\n<span class=\"sd\">data_api : dict</span>\n<span class=\"sd\">    expects a Python dictionary with the endpoints to an API implemented</span>\n<span class=\"sd\">    to store the data on a database or any other persistence system</span>\n\n<span class=\"sd\">    An API, persisting the data on a MongoDB is available on the examples.</span>\n\n<span class=\"sd\">Methods</span>\n<span class=\"sd\">-------</span>\n<span class=\"sd\">def run(self, loop_interval=0.016)</span>\n<span class=\"sd\">    Run the component with the following behaviour:</span>\n<span class=\"sd\">    - Get the number of ready for training items through DataApi</span>\n<span class=\"sd\">    - In case, the number of items is greater than the retrain_counter, download</span>\n<span class=\"sd\">    the data and forward it to the next component which is usually a training</span>\n<span class=\"sd\">    component</span>\n<span class=\"sd\">    - Mark the forwarded items as sent to training</span>\n\n<span class=\"sd\">def mark_data_as_included_in_the_training_process(self, item_ids)</span>\n<span class=\"sd\">    Set the items on the DataApi as \"already in training set\"</span>\n\n<span class=\"sd\">def _download_data_and_labels(self)</span>\n<span class=\"sd\">    Download the information from DataApi and call a method to be implemented to</span>\n<span class=\"sd\">    store this data in a physical file, i.e., it is expected from user</span>\n<span class=\"sd\">    to develop how the file should be, e.g. for images an JPG, for sound MP3,</span>\n<span class=\"sd\">    etc.</span>\n\n<span class=\"sd\">def store_on_filemanager(self, name, x, y)</span>\n<span class=\"sd\">    Store an item identified by its name, together with its X data, e.g., for</span>\n<span class=\"sd\">    image the Bas64 encoded image</span>\n<span class=\"sd\">    and its Y, e.g., for image detection, the annotated bounding boxes</span>\n\n<span class=\"sd\">def get_dataset_paths(self)</span>\n<span class=\"sd\">    Provide the absolute path where the items and their annotations where</span>\n<span class=\"sd\">    stored. It is expected to return an tuple in the format (items, labels)</span>\n\n<span class=\"sd\">def forward_to_trainer(self, message)</span>\n<span class=\"sd\">    Forward the set of ready items to a training component</span>\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<h3>Instancer</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Instancer</span><span class=\"p\">:</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">An abstract class used to create instances based on multiple sensors (providers)</span>\n<span class=\"sd\">The instancer is responsible to create data relationship from the different</span>\n<span class=\"sd\">providers, based on the necessities of the estimator component</span>\n\n<span class=\"sd\">Attributes</span>\n<span class=\"sd\">----------</span>\n<span class=\"sd\">number_of_providers : int</span>\n<span class=\"sd\">    the current number of providers included in the pipeline</span>\n<span class=\"sd\">queue_server : str</span>\n<span class=\"sd\">    the IPv4 of a RabbitMQ queue server</span>\n<span class=\"sd\">queue_input: str</span>\n<span class=\"sd\">    the name of the queue from where collector consume</span>\n<span class=\"sd\">queue_output : str</span>\n<span class=\"sd\">    the name of the queue where provider will publish their data</span>\n\n<span class=\"sd\">Methods</span>\n<span class=\"sd\">-------</span>\n<span class=\"sd\">run(self)</span>\n<span class=\"sd\">    Should be implemented from the user, in order to describe the provider</span>\n<span class=\"sd\">    behaviour</span>\n\n<span class=\"sd\">create_custom_instance(self)</span>\n<span class=\"sd\">    Should be implemented from the user, in order to describe the provider</span>\n<span class=\"sd\">    behaviour</span>\n\n<span class=\"sd\">create_simple_instance(self)</span>\n<span class=\"sd\">    Create an instance directly from the data from the input queue</span>\n\n<span class=\"sd\">create_instance_by_time_window(self, sensor_id, time_window_s)</span>\n<span class=\"sd\">    Create an instance based on the list of messages received in a time window</span>\n\n<span class=\"sd\">create_instance_by_repetition(self, sensor_id, number_of_messages)</span>\n<span class=\"sd\">    Create an instance based on a defined number of received messages.</span>\n<span class=\"sd\">    e.g.: a model requires 7 images as its input.</span>\n\n<span class=\"sd\">create_instance_by_syncing_all_providers(self)</span>\n<span class=\"sd\">    Synchronize all the providers and create an instance including all of them.</span>\n\n<span class=\"sd\">forward(self, message)</span>\n<span class=\"sd\">    Forward the message to the next component of the pipeline</span>\n\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<h3>Messager</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Messager</span><span class=\"p\">:</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">An class responsible to define the communication between components</span>\n<span class=\"sd\">It is a wrapper on RabbitMQ library pika</span>\n\n<span class=\"sd\">Attributes</span>\n<span class=\"sd\">----------</span>\n<span class=\"sd\">server_url : str</span>\n<span class=\"sd\">    the IPv4 of a RabbitMQ queue server</span>\n<span class=\"sd\">queue_name: str</span>\n<span class=\"sd\">    the name of the queue to be interacted</span>\n\n<span class=\"sd\">Methods</span>\n<span class=\"sd\">-------</span>\n<span class=\"sd\">validate(self, message)</span>\n<span class=\"sd\">    Validate the received message, based on the defined schema</span>\n\n<span class=\"sd\">publish_to_sibling_queue(self, message, unique_id, validate=True)</span>\n<span class=\"sd\">    Send a message to a fragmented queue component, i.e., to a component which</span>\n<span class=\"sd\">    expects</span>\n<span class=\"sd\">    multiple queues as its input. Used to publish providers' data in individual</span>\n<span class=\"sd\">    queues</span>\n\n<span class=\"sd\">publish(self, message, exchange='', validate=True)</span>\n<span class=\"sd\">    Publish the data to the Messager's queue</span>\n\n<span class=\"sd\">get_message(self)</span>\n<span class=\"sd\">    Get a message from the queue, FIFO-based.</span>\n\n<span class=\"sd\">consume(self, callback)</span>\n<span class=\"sd\">    Provide a listener to the queue, so every new message on the queue, the</span>\n<span class=\"sd\">    callback (implemented by the user) is called</span>\n\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<h3>Estimator</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Estimator</span><span class=\"p\">:</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">An class responsible to define the behavior of an estimator responsible to</span>\n<span class=\"sd\">perform inferences on the pipeline's data</span>\n\n<span class=\"sd\">Attributes</span>\n<span class=\"sd\">----------</span>\n<span class=\"sd\">queue_server : str</span>\n<span class=\"sd\">    the IPv4 of a RabbitMQ queue server</span>\n<span class=\"sd\">input_queue_instancer : str</span>\n<span class=\"sd\">    the name of the queue to be interacted</span>\n<span class=\"sd\">input_evaluator_queue : str</span>\n<span class=\"sd\">    the name of the queue used from evaluator to inform estimator about</span>\n<span class=\"sd\">    new models</span>\n<span class=\"sd\">output_queue : str</span>\n<span class=\"sd\">    the name of the queue to be interacted</span>\n\n<span class=\"sd\">Methods</span>\n<span class=\"sd\">-------</span>\n<span class=\"sd\">get_estimator_model(self)</span>\n<span class=\"sd\">    Should be implemented from the user, in order to describe the desired</span>\n<span class=\"sd\">    behaviour</span>\n\n<span class=\"sd\">set_estimator_model(self, message)</span>\n<span class=\"sd\">    Should be implemented from the user, in order to describe the desired</span>\n<span class=\"sd\">    behaviour</span>\n\n<span class=\"sd\">update_model(self)</span>\n<span class=\"sd\">    Should be implemented from the user, in order to describe the desired</span>\n<span class=\"sd\">    behaviour</span>\n\n<span class=\"sd\">estimate(self, message)</span>\n<span class=\"sd\">    Should be implemented from the user, in order to describe the desired</span>\n<span class=\"sd\">    behaviour</span>\n\n<span class=\"sd\">run(self)</span>\n<span class=\"sd\">    Provide the component's behaviour:</span>\n<span class=\"sd\">        - Check for new models available</span>\n<span class=\"sd\">        - Get a message from the queue</span>\n<span class=\"sd\">        - Make an inference</span>\n<span class=\"sd\">        - Forward the results</span>\n\n<span class=\"sd\">forward(self, message)</span>\n<span class=\"sd\">    Forward the message to the next component of the pipeline</span>\n\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<h3>Evaluator</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Evaluator</span><span class=\"p\">:</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">An abstract class responsible to evaluate the quality of trained models.</span>\n\n<span class=\"sd\">Get a list of models from a trainer component and forwards the best one for an</span>\n<span class=\"sd\">Estimator component, therefore, the inference is always done with the best</span>\n<span class=\"sd\">possible results.</span>\n\n<span class=\"sd\">Constructor</span>\n<span class=\"sd\">----------</span>\n\n<span class=\"sd\">Attributes</span>\n<span class=\"sd\">----------</span>\n\n<span class=\"sd\">queue_server : str</span>\n<span class=\"sd\">    the IPv4 of a RabbitMQ queue server</span>\n<span class=\"sd\">input_queue : Messager</span>\n<span class=\"sd\">    the name of the queue to be consumed</span>\n<span class=\"sd\">output_queue : Messager</span>\n<span class=\"sd\">    the name of the queue which Evaluator publish its data</span>\n<span class=\"sd\">evaluated : list(key,value)</span>\n<span class=\"sd\">    a list of already evaluated models</span>\n<span class=\"sd\">current_best : (key,value)</span>\n<span class=\"sd\">    the current best model, e.g. weights, evaluated, i.e., the one recommended</span>\n<span class=\"sd\">    to be used on an Estimator component</span>\n\n<span class=\"sd\">Methods</span>\n<span class=\"sd\">-------</span>\n\n<span class=\"sd\">evaluate_models(self, message)</span>\n<span class=\"sd\">    Should be implemented from the user, in order to describe the provider</span>\n<span class=\"sd\">    behaviour</span>\n\n<span class=\"sd\">include_evaluation_to_list(self, key, value)</span>\n<span class=\"sd\">    self.evaluated.append((key, value))</span>\n\n<span class=\"sd\">is_included_in_evaluation_list(self, key):</span>\n<span class=\"sd\">    check if a model, identified by its key, was already evaluated</span>\n<span class=\"sd\">    this can reduce drastically the processing time of the component</span>\n\n<span class=\"sd\">get_current_best_evaluated(self):</span>\n<span class=\"sd\">    return the actual best model evaluated in the format (key,value)</span>\n<span class=\"sd\">    key: model path</span>\n<span class=\"sd\">    value: it's evaluation value, e.g. mAP</span>\n\n<span class=\"sd\">set_current_best_evaluated(self, key, value):</span>\n<span class=\"sd\">    update the current best evaluated model that is informed to the interested</span>\n<span class=\"sd\">    components by the queue system</span>\n\n<span class=\"sd\">run(self):</span>\n<span class=\"sd\">    implements the behaviour of the component</span>\n\n<span class=\"sd\">forward(self, message):</span>\n<span class=\"sd\">    publish the evaluated data to next component</span>\n<span class=\"sd\">    the message follows the format:</span>\n<span class=\"sd\">    {</span>\n<span class=\"sd\">        \"key\": \"uniqueFilePath\",</span>\n<span class=\"sd\">        \"value\" \"the evaluation value of the model\",</span>\n<span class=\"sd\">        \"params\": {</span>\n<span class=\"sd\">            \"modelDefinition\": \"some extra data about the results\"</span>\n<span class=\"sd\">        }</span>\n<span class=\"sd\">    }</span>\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<h3>TrainerDetection</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">TrainerDetection</span><span class=\"p\">:</span>\n    <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">    An abstract class responsible to evaluate the quality of trained models.</span>\n\n<span class=\"sd\">    Get a list of models from a trainer component and forwards the best one for an</span>\n<span class=\"sd\">    Estimator component, therefore, the inference is always done with the best</span>\n<span class=\"sd\">    possible results.</span>\n\n<span class=\"sd\">    Constructor</span>\n<span class=\"sd\">    ----------</span>\n\n<span class=\"sd\">    Attributes</span>\n<span class=\"sd\">    ----------</span>\n\n<span class=\"sd\">    queue_server : str</span>\n<span class=\"sd\">        the IPv4 of a RabbitMQ queue server</span>\n<span class=\"sd\">    queue_input : str</span>\n<span class=\"sd\">        the name of the queue to be consumed</span>\n<span class=\"sd\">    queue_output : str</span>\n<span class=\"sd\">        the name of the queue which Evaluator publish its data</span>\n<span class=\"sd\">    \"\"\"</span> \n\n    <span class=\"k\">def</span> <span class=\"nf\">get_new_training_samples</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        \"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">train</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">pretrained</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Should be implemented from the user, in order to describe the component's</span>\n<span class=\"sd\">        behaviour</span>\n<span class=\"sd\">        \"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">create_train_and_validation_files</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Should be implemented from the user, in order to describe the component's</span>\n<span class=\"sd\">        behaviour</span>\n<span class=\"sd\">        \"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">get_latest_pretrained_weights</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Should be implemented from the user, in order to describe the component's</span>\n<span class=\"sd\">        behaviour</span>\n<span class=\"sd\">        \"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">send_weights_to_evaluator</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Should be implemented from the user, in order to describe the component's</span>\n<span class=\"sd\">        behaviour</span>\n<span class=\"sd\">        \"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">run</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">loop_interval</span><span class=\"o\">=</span><span class=\"mf\">0.016</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Run the component with the following behaviour:</span>\n<span class=\"sd\">        - Check for new samples for training</span>\n<span class=\"sd\">        - In case there is new samples, split them on validation and training</span>\n<span class=\"sd\">        - Retrain</span>\n<span class=\"sd\">        - Forward the trained models</span>\n<span class=\"sd\">        the data and forward it to the next component which is usually a training</span>\n<span class=\"sd\">        component</span>\n<span class=\"sd\">        - Mark the forwarded items as sent to training</span>\n<span class=\"sd\">        \"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">forward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Forward the message to the next component of the pipeline</span>\n<span class=\"sd\">        \"\"\"</span>\n</pre>\n\n          </div>"}, "last_serial": 6636276, "releases": {"0.0.10": [{"comment_text": "", "digests": {"md5": "73f9cb3db5e82258b1c35b6cf46462d5", "sha256": "0cb556f46ed7c7dfe2a9d7c169aab5a23759fac8688ec5abd09c11af96afaa4e"}, "downloads": -1, "filename": "pipeline_vilma-0.0.10-py3-none-any.whl", "has_sig": false, "md5_digest": "73f9cb3db5e82258b1c35b6cf46462d5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12456, "upload_time": "2020-01-03T10:18:48", "upload_time_iso_8601": "2020-01-03T10:18:48.477492Z", "url": "https://files.pythonhosted.org/packages/0d/c8/d77a109d48c3180349627b2b3835ad4dd3ded7bade02fc5134a208b4f1cf/pipeline_vilma-0.0.10-py3-none-any.whl", "yanked": false}], "0.0.11": [{"comment_text": "", "digests": {"md5": "bbc3ebb7c6aa807eeebda40c62f455b2", "sha256": "3ae92525a54828423a5d367ec32bfd2101c565b796611c10516fd8edd834d551"}, "downloads": -1, "filename": "pipeline_vilma-0.0.11-py3-none-any.whl", "has_sig": false, "md5_digest": "bbc3ebb7c6aa807eeebda40c62f455b2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12463, "upload_time": "2020-01-03T10:36:32", "upload_time_iso_8601": "2020-01-03T10:36:32.012601Z", "url": "https://files.pythonhosted.org/packages/f8/63/4cd9a41ed4c8c3e79a15e31ef60efba3eaf2eb3d78fec603f18ae520e54e/pipeline_vilma-0.0.11-py3-none-any.whl", "yanked": false}], "0.0.12": [{"comment_text": "", "digests": {"md5": "4b5af8fb3f50a9cfeabce8e85ca69644", "sha256": "ce21a792154cfd3f335d70123d4dfcab433b972ef321d0429bd2a93216f07dc4"}, "downloads": -1, "filename": "pipeline_vilma-0.0.12-py3-none-any.whl", "has_sig": false, "md5_digest": "4b5af8fb3f50a9cfeabce8e85ca69644", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12456, "upload_time": "2020-01-03T10:38:07", "upload_time_iso_8601": "2020-01-03T10:38:07.635404Z", "url": "https://files.pythonhosted.org/packages/6c/01/4ad246665ea2e593b131426ae39cdec1670d4b7aab26ebcff7d43e966285/pipeline_vilma-0.0.12-py3-none-any.whl", "yanked": false}], "0.0.13": [{"comment_text": "", "digests": {"md5": "1b0acc05d2f6a40076096eabcbde2752", "sha256": "cc731d87674f8cea48a6a59d6fcfe2b4d0a60a6522631566025faf57a2d18bac"}, "downloads": -1, "filename": "pipeline_vilma-0.0.13-py3-none-any.whl", "has_sig": false, "md5_digest": "1b0acc05d2f6a40076096eabcbde2752", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12504, "upload_time": "2020-01-03T10:44:15", "upload_time_iso_8601": "2020-01-03T10:44:15.458676Z", "url": "https://files.pythonhosted.org/packages/5b/f0/6c96c85cf219b8e47563a98f6e79fb7ec40946770aa721019a4e1a844698/pipeline_vilma-0.0.13-py3-none-any.whl", "yanked": false}], "0.0.14": [{"comment_text": "", "digests": {"md5": "d27aa2cd74e631963866827b86421500", "sha256": "5255ce42920bc15b540a2dc0a37e684cbb3c656b582dd971e364ef52e293262a"}, "downloads": -1, "filename": "pipeline_vilma-0.0.14-py3-none-any.whl", "has_sig": false, "md5_digest": "d27aa2cd74e631963866827b86421500", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12496, "upload_time": "2020-01-03T11:06:02", "upload_time_iso_8601": "2020-01-03T11:06:02.689641Z", "url": "https://files.pythonhosted.org/packages/11/c9/59b46296b5846d1fcd5c419ee9c6637c1a769e18c3d98d6aa5fb0b3807f2/pipeline_vilma-0.0.14-py3-none-any.whl", "yanked": false}], "0.0.15": [{"comment_text": "", "digests": {"md5": "b4fb88b628ca2baefcbc1c367803f27c", "sha256": "b42d07db82f5255d3467f75cce028e6910e02008b9c002b1a6491a0e1b3b30e2"}, "downloads": -1, "filename": "pipeline_vilma-0.0.15-py3-none-any.whl", "has_sig": false, "md5_digest": "b4fb88b628ca2baefcbc1c367803f27c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12463, "upload_time": "2020-01-03T17:22:45", "upload_time_iso_8601": "2020-01-03T17:22:45.496429Z", "url": "https://files.pythonhosted.org/packages/e8/3c/857929b247039ce1224262f0f0f16fe3d7e763d651b805554cd104f4c54d/pipeline_vilma-0.0.15-py3-none-any.whl", "yanked": false}], "0.0.17": [{"comment_text": "", "digests": {"md5": "1187d92d0d1cd4693fbf53776a446ae3", "sha256": "8e435cd22a233ea9c762180d0519e17dbae89f2e12cda2710614626f5b4dec4b"}, "downloads": -1, "filename": "pipeline_vilma-0.0.17-py3-none-any.whl", "has_sig": false, "md5_digest": "1187d92d0d1cd4693fbf53776a446ae3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 13779, "upload_time": "2020-01-07T19:09:02", "upload_time_iso_8601": "2020-01-07T19:09:02.211980Z", "url": "https://files.pythonhosted.org/packages/46/e3/85993201f588441899d83855a62eb6be67e620a2ced83cbaee4d21d8f09c/pipeline_vilma-0.0.17-py3-none-any.whl", "yanked": false}], "0.0.18": [{"comment_text": "", "digests": {"md5": "13574c38087ed061fe2a91c171f310e2", "sha256": "d8dc0c797bfb722c5a8a39db4877f9238e5369cf7b38ae60a6eaa445a24a822d"}, "downloads": -1, "filename": "pipeline_vilma-0.0.18-py3-none-any.whl", "has_sig": false, "md5_digest": "13574c38087ed061fe2a91c171f310e2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 16038, "upload_time": "2020-01-18T20:26:31", "upload_time_iso_8601": "2020-01-18T20:26:31.295940Z", "url": "https://files.pythonhosted.org/packages/89/89/813bd889e82b7ae7d38b3aa77f3e85bc0ff778b2928486683bf619dcca81/pipeline_vilma-0.0.18-py3-none-any.whl", "yanked": false}], "0.0.20": [{"comment_text": "", "digests": {"md5": "e857c0f24416a2aa84d6a0c830fdf9f0", "sha256": "709db3571a5384a46bf5a2cb457e347608e3c613f0160a66b49a43968032a845"}, "downloads": -1, "filename": "pipeline_vilma-0.0.20-py3-none-any.whl", "has_sig": false, "md5_digest": "e857c0f24416a2aa84d6a0c830fdf9f0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 16986, "upload_time": "2020-01-20T22:11:55", "upload_time_iso_8601": "2020-01-20T22:11:55.434780Z", "url": "https://files.pythonhosted.org/packages/f9/55/9771152eef34b2ab28b213e00293b6fb37000ec4b53639b6a4840282193a/pipeline_vilma-0.0.20-py3-none-any.whl", "yanked": false}], "0.0.21": [{"comment_text": "", "digests": {"md5": "72a8e45fc355125b64c0f31a1f783c87", "sha256": "a4903d7f31d825a8eff287bc65c05b070fc019e5344d1ccbbd59efca2b85eb2c"}, "downloads": -1, "filename": "pipeline_vilma-0.0.21-py3-none-any.whl", "has_sig": false, "md5_digest": "72a8e45fc355125b64c0f31a1f783c87", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 16992, "upload_time": "2020-01-20T22:23:13", "upload_time_iso_8601": "2020-01-20T22:23:13.092860Z", "url": "https://files.pythonhosted.org/packages/d1/9a/c41275ccfe0096793c0a0418de8000d7d9df869f02615b86faf4cde2f071/pipeline_vilma-0.0.21-py3-none-any.whl", "yanked": false}], "0.0.22": [{"comment_text": "", "digests": {"md5": "02a8a5bb41441c7ae6ce5aa585308f83", "sha256": "13d6d9ef9588884c22e3c4a01c50b610e38b292c7b91ccf1ba6d45ea0a1213fb"}, "downloads": -1, "filename": "pipeline_vilma-0.0.22-py3-none-any.whl", "has_sig": false, "md5_digest": "02a8a5bb41441c7ae6ce5aa585308f83", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17004, "upload_time": "2020-01-20T22:33:03", "upload_time_iso_8601": "2020-01-20T22:33:03.949743Z", "url": "https://files.pythonhosted.org/packages/9b/2e/fa0ac1d2213c75c2d0c05fd1e58f5ff3890669ea55945ce274b80ea25574/pipeline_vilma-0.0.22-py3-none-any.whl", "yanked": false}], "0.0.23": [{"comment_text": "", "digests": {"md5": "4882016cce848befad67323f0a236752", "sha256": "48c8144949f6f98481ac31eb3d22510cc8e60d082797296a94040f67b2c9efa7"}, "downloads": -1, "filename": "pipeline_vilma-0.0.23-py3-none-any.whl", "has_sig": false, "md5_digest": "4882016cce848befad67323f0a236752", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 16979, "upload_time": "2020-01-20T22:56:07", "upload_time_iso_8601": "2020-01-20T22:56:07.788048Z", "url": "https://files.pythonhosted.org/packages/bb/4b/f6e3fec1f02de07db2501fc3ec74fded469e55f1140c5c3d833adf02cc16/pipeline_vilma-0.0.23-py3-none-any.whl", "yanked": false}], "0.0.25": [{"comment_text": "", "digests": {"md5": "0b56cc87a82b8f460dec041e94369e94", "sha256": "8f74ad6b61d223351724d6aaf58c01b95cb016359d82452a3970d16d33b03def"}, "downloads": -1, "filename": "pipeline_vilma-0.0.25-py3-none-any.whl", "has_sig": false, "md5_digest": "0b56cc87a82b8f460dec041e94369e94", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17291, "upload_time": "2020-01-20T23:57:23", "upload_time_iso_8601": "2020-01-20T23:57:23.933647Z", "url": "https://files.pythonhosted.org/packages/02/43/12661a363f3732e9db247b379c40eba5e6b49ff7b9155f100a413abe83af/pipeline_vilma-0.0.25-py3-none-any.whl", "yanked": false}], "0.0.26": [{"comment_text": "", "digests": {"md5": "1ff7957bededc48669f6827e37a332da", "sha256": "48b1b6865f8773ff071c8f7e1dab6a2555279631382eff55139f6ea83d686f11"}, "downloads": -1, "filename": "pipeline_vilma-0.0.26-py3-none-any.whl", "has_sig": false, "md5_digest": "1ff7957bededc48669f6827e37a332da", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17749, "upload_time": "2020-01-21T00:25:58", "upload_time_iso_8601": "2020-01-21T00:25:58.358129Z", "url": "https://files.pythonhosted.org/packages/48/3b/101591c7f48c04c701b806882ba31150a6a109b9c2f84fa64b612ba330f4/pipeline_vilma-0.0.26-py3-none-any.whl", "yanked": false}], "0.0.27": [{"comment_text": "", "digests": {"md5": "6d2df014e3349d6961e02ba8e868e1ff", "sha256": "9addefe9dcebcc1c0a36839b8b83726efcb662a8716fa6cbf073878010e4d9a4"}, "downloads": -1, "filename": "pipeline_vilma-0.0.27-py3-none-any.whl", "has_sig": false, "md5_digest": "6d2df014e3349d6961e02ba8e868e1ff", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17761, "upload_time": "2020-01-21T00:27:38", "upload_time_iso_8601": "2020-01-21T00:27:38.058145Z", "url": "https://files.pythonhosted.org/packages/30/2a/6ef501f748099aa158b9d278f696ebd2b18c15fed879b375bb1b15d0a755/pipeline_vilma-0.0.27-py3-none-any.whl", "yanked": false}], "0.0.28": [{"comment_text": "", "digests": {"md5": "9bb0ea76ca4f099574b380483d63cc67", "sha256": "43f8151848529e7eafd58c5e0b63aa385a60fafe521bba007a8f1d72081dadcd"}, "downloads": -1, "filename": "pipeline_vilma-0.0.28-py3-none-any.whl", "has_sig": false, "md5_digest": "9bb0ea76ca4f099574b380483d63cc67", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 18552, "upload_time": "2020-01-21T00:40:25", "upload_time_iso_8601": "2020-01-21T00:40:25.166993Z", "url": "https://files.pythonhosted.org/packages/a7/32/8dc0eb512f60f95925c7f4978ed80478e0c7402cf5ca4087c7c95d49efba/pipeline_vilma-0.0.28-py3-none-any.whl", "yanked": false}], "0.0.29": [{"comment_text": "", "digests": {"md5": "13d1753c203bd7b67d1081b360188f79", "sha256": "2885234104d2b47ce58d723ea4a757a879e249648149fd1268f206b8a3cf7945"}, "downloads": -1, "filename": "pipeline_vilma-0.0.29-py3-none-any.whl", "has_sig": false, "md5_digest": "13d1753c203bd7b67d1081b360188f79", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 18560, "upload_time": "2020-01-21T00:43:52", "upload_time_iso_8601": "2020-01-21T00:43:52.945821Z", "url": "https://files.pythonhosted.org/packages/a2/c0/b56f1de8d8ad113944fc6876a3047f09827ab4c56980cb0f451c674a6789/pipeline_vilma-0.0.29-py3-none-any.whl", "yanked": false}], "0.0.30": [{"comment_text": "", "digests": {"md5": "c352e6b34f9a33f8c0f00e3291ad8008", "sha256": "9f06f05f704fac2a886cd86e845d3aa6e6195d72ac97c1a4aaac3b2705ba5827"}, "downloads": -1, "filename": "pipeline_vilma-0.0.30-py3-none-any.whl", "has_sig": false, "md5_digest": "c352e6b34f9a33f8c0f00e3291ad8008", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 22840, "upload_time": "2020-02-15T12:02:02", "upload_time_iso_8601": "2020-02-15T12:02:02.295953Z", "url": "https://files.pythonhosted.org/packages/99/d1/84d9cd8dfd2b7d2fb72db9c7ce0bc8ea0b1b9de51cf2d819bf7f8cbb6102/pipeline_vilma-0.0.30-py3-none-any.whl", "yanked": false}], "0.0.31": [{"comment_text": "", "digests": {"md5": "594e1bbe341829dffc1f2308069c988a", "sha256": "9e7347aab03121b57ec7656bf404038174571bf0c47d85e22c18b7b1d60b3bd9"}, "downloads": -1, "filename": "pipeline_vilma-0.0.31-py3-none-any.whl", "has_sig": false, "md5_digest": "594e1bbe341829dffc1f2308069c988a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 22835, "upload_time": "2020-02-15T12:03:14", "upload_time_iso_8601": "2020-02-15T12:03:14.613622Z", "url": "https://files.pythonhosted.org/packages/21/99/134d5ef40db5e1de9dd6ca959f20b934e784711cdbf8fafc0c9f1d7caefd/pipeline_vilma-0.0.31-py3-none-any.whl", "yanked": false}], "0.0.32": [{"comment_text": "", "digests": {"md5": "b6c2e3bc69e4bd2bda3f9e3eb01044df", "sha256": "e6b83aca3dc523f057ecfaa9fda22f930541b22ed190f9ade471ed0ed25fa688"}, "downloads": -1, "filename": "pipeline_vilma-0.0.32-py3-none-any.whl", "has_sig": false, "md5_digest": "b6c2e3bc69e4bd2bda3f9e3eb01044df", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23087, "upload_time": "2020-02-15T13:01:17", "upload_time_iso_8601": "2020-02-15T13:01:17.825602Z", "url": "https://files.pythonhosted.org/packages/6e/1d/ed6cc51a44b4c8f1da7ef9ee81ec0f6e98ee9eb6ae0cfa77de26d15bf864/pipeline_vilma-0.0.32-py3-none-any.whl", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "0ac769650832b9d0513f4037c35c3c99", "sha256": "c7bbed55343baa9a7f008d66b4e1dca3efce7865eebfff2f4f63ed65bcb3aa2c"}, "downloads": -1, "filename": "pipeline_vilma-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "0ac769650832b9d0513f4037c35c3c99", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 10397, "upload_time": "2019-12-27T11:10:29", "upload_time_iso_8601": "2019-12-27T11:10:29.180458Z", "url": "https://files.pythonhosted.org/packages/33/53/d0b8e1282fdc9ee8281011731a61909ea2b78f7210643f60b12da0af7a5d/pipeline_vilma-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fbe9d770e2f4d15eac0633a32551a2c2", "sha256": "60aef8d9c25a59e3332cf215300e5efd648b1540a11b62ca7b3ae921a6feb794"}, "downloads": -1, "filename": "pipeline-vilma-0.0.4.tar.gz", "has_sig": false, "md5_digest": "fbe9d770e2f4d15eac0633a32551a2c2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4705, "upload_time": "2019-12-27T11:10:30", "upload_time_iso_8601": "2019-12-27T11:10:30.520660Z", "url": "https://files.pythonhosted.org/packages/4b/de/6b4d9c28cb351c175e687b5c9f41c593ce06cd0ecbaa5b2c2e725a5bc791/pipeline-vilma-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "791e7eff1f0d6493fa9f7cb95142dd75", "sha256": "93e9a93213606ee5119236a4255eb9d134a18a1f9434938fe7d52378f0a4f305"}, "downloads": -1, "filename": "pipeline_vilma-0.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "791e7eff1f0d6493fa9f7cb95142dd75", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 11584, "upload_time": "2019-12-27T23:41:12", "upload_time_iso_8601": "2019-12-27T23:41:12.087191Z", "url": "https://files.pythonhosted.org/packages/59/e4/d0b01a1203ca95f319be1e5dfc1d28ccae29627ae1c935578895ef25daca/pipeline_vilma-0.0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1e34dfb3f349cba8d448a7932e1ef7fa", "sha256": "2db7719c9c1a8f7acfdde6a36e7fdd111cba51d2edfa69a6378bb89118926f01"}, "downloads": -1, "filename": "pipeline-vilma-0.0.5.tar.gz", "has_sig": false, "md5_digest": "1e34dfb3f349cba8d448a7932e1ef7fa", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 5236, "upload_time": "2019-12-27T23:41:14", "upload_time_iso_8601": "2019-12-27T23:41:14.027085Z", "url": "https://files.pythonhosted.org/packages/ff/a4/3cfe60e45f63c11bff0862edaa6586249c6124d45551ee5e451e18b09bec/pipeline-vilma-0.0.5.tar.gz", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "2f05f76e76d875d483b64b3d8be64e52", "sha256": "422d21fa4d76ee73cb4ab07b2d80040b210eef2a70c7894294bb8d6cba900cda"}, "downloads": -1, "filename": "pipeline_vilma-0.0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "2f05f76e76d875d483b64b3d8be64e52", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 11110, "upload_time": "2019-12-28T17:59:04", "upload_time_iso_8601": "2019-12-28T17:59:04.214574Z", "url": "https://files.pythonhosted.org/packages/67/77/2fbd38512d31c214a39973d8b39e9cdbf790ca78fc80fc89b47cd7dd8c98/pipeline_vilma-0.0.7-py3-none-any.whl", "yanked": false}], "0.0.8": [{"comment_text": "", "digests": {"md5": "8395951a34ffefaa329fec47fbd74445", "sha256": "e1f4b2c71e576b617f70cf9fefc1383568733f6b8e06567261ad1d7fe4830898"}, "downloads": -1, "filename": "pipeline_vilma-0.0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "8395951a34ffefaa329fec47fbd74445", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 11172, "upload_time": "2019-12-30T17:29:26", "upload_time_iso_8601": "2019-12-30T17:29:26.887642Z", "url": "https://files.pythonhosted.org/packages/d0/c7/94d73469be81330193665008f6eb060badeb564d7cb645f33ce87cf95f58/pipeline_vilma-0.0.8-py3-none-any.whl", "yanked": false}], "0.0.9": [{"comment_text": "", "digests": {"md5": "809421633f543c421df52c9664b6cfcd", "sha256": "309ef4a2d7290635513460ddcf05700c80809086bab280663a611658ca15f54f"}, "downloads": -1, "filename": "pipeline_vilma-0.0.9-py3-none-any.whl", "has_sig": false, "md5_digest": "809421633f543c421df52c9664b6cfcd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12425, "upload_time": "2020-01-03T10:14:49", "upload_time_iso_8601": "2020-01-03T10:14:49.066947Z", "url": "https://files.pythonhosted.org/packages/75/d7/4d1f15df1ea4941b7b9f8464227144960cfee4fa52c66c31a16229d23654/pipeline_vilma-0.0.9-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b6c2e3bc69e4bd2bda3f9e3eb01044df", "sha256": "e6b83aca3dc523f057ecfaa9fda22f930541b22ed190f9ade471ed0ed25fa688"}, "downloads": -1, "filename": "pipeline_vilma-0.0.32-py3-none-any.whl", "has_sig": false, "md5_digest": "b6c2e3bc69e4bd2bda3f9e3eb01044df", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23087, "upload_time": "2020-02-15T13:01:17", "upload_time_iso_8601": "2020-02-15T13:01:17.825602Z", "url": "https://files.pythonhosted.org/packages/6e/1d/ed6cc51a44b4c8f1da7ef9ee81ec0f6e98ee9eb6ae0cfa77de26d15bf864/pipeline_vilma-0.0.32-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 02:54:19 2020"}