{"info": {"author": "Giampaolo Rodola", "author_email": "g.rodola@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX :: AIX", "Operating System :: POSIX :: BSD", "Operating System :: POSIX :: BSD :: FreeBSD", "Operating System :: POSIX :: Linux", "Operating System :: POSIX :: SunOS/Solaris", "Programming Language :: C", "Programming Language :: Python :: 2.5", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.0", "Programming Language :: Python :: 3.1", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Topic :: Internet :: File Transfer Protocol (FTP)", "Topic :: Internet :: WWW/HTTP", "Topic :: System :: Networking", "Topic :: System :: Operating System"], "description": ".. image:: https://pypip.in/d/pysendfile/badge.png\n    :target: https://crate.io/packages/pysendfile/\n    :alt: Download this month\n\n.. image:: https://pypip.in/v/pysendfile/badge.png\n    :target: https://pypi.python.org/pypi/pysendfile/\n    :alt: Latest version\n\n.. image:: https://pypip.in/license/pysendfile/badge.png\n    :target: https://pypi.python.org/pypi/pysendfile/\n    :alt: License\n\n.. image:: https://api.travis-ci.org/giampaolo/pysendfile.png?branch=master\n    :target: https://travis-ci.org/giampaolo/pysendfile\n    :alt: Travis\n\n===========\nQuick links\n===========\n\n- `Home page <https://github.com/giampaolo/pysendfile>`_\n- `Mailing list <http://groups.google.com/group/py-sendfile>`_\n- `Blog <http://grodola.blogspot.com/search/label/pysendfile>`_\n- `What's new <https://github.com/giampaolo/pysendfile/blob/master/HISTORY.rst>`_\n\n=====\nAbout\n=====\n\n`sendfile(2) <http://linux.die.net/man/2/sendfile>`__ is a system call which\nprovides a \"zero-copy\" way of copying data from one file descriptor to another\n(a socket). The phrase \"zero-copy\" refers to the fact that all of the copying\nof data between the two descriptors is done entirely by the kernel, with no\ncopying of data into userspace buffers. This is particularly useful when\nsending a file over a socket (e.g. FTP).\nThe normal way of sending a file over a socket involves reading data from the\nfile into a userspace buffer, then write that buffer to the socket via\n`send() <http://docs.python.org/library/socket.html#socket.socket.send>`__ or\n`sendall() <http://docs.python.org/library/socket.html#socket.socket.sendall>`__:\n\n.. code-block:: python\n\n    # how a file is tipically sent\n\n    import socket\n\n    file = open(\"somefile\", \"rb\")\n    sock = socket.socket()\n    sock.connect((\"127.0.0.1\", 8021))\n\n    while True:\n        chunk = file.read(65536)\n        if not chunk:\n            break  # EOF\n        sock.sendall(chunk)\n\nThis copying of the data twice (once into the userland buffer, and once out\nfrom that userland buffer) imposes some performance and resource penalties.\n`sendfile(2) <http://linux.die.net/man/2/sendfile>`__ syscall avoids these\npenalties by avoiding any use of userland buffers; it also results in a single\nsystem call (and thus only one context switch), rather than the series of\n`read(2) <http://linux.die.net/man/2/read>`__ /\n`write(2) <http://linux.die.net/man/2/write>`__ system calls (each system call\nrequiring a context switch) used internally for the data copying.\n\n.. code-block:: python\n\n    import socket\n    from sendfile import sendfile\n\n    file = open(\"somefile\", \"rb\")\n    blocksize = os.path.getsize(\"somefile\")\n    sock = socket.socket()\n    sock.connect((\"127.0.0.1\", 8021))\n    offset = 0\n\n    while True:\n        sent = sendfile(sock.fileno(), file.fileno(), offset, blocksize)\n        if sent == 0:\n            break  # EOF\n        offset += sent\n\n==================\nA simple benchmark\n==================\n\nThis `benchmark script <https://github.com/giampaolo/pysendfile/blob/master/test/benchmark.py>`__\nimplements the two examples above and compares plain socket.send() and\nsendfile() performances in terms of CPU time spent and bytes transmitted per\nsecond resulting in sendfile() being about **2.5x faster**. These are the\nresults I get on my Linux 2.6.38 box, AMD dual-core 1.6 GHz:\n\n*send()*\n\n+---------------+-----------------+\n| CPU time      | 28.84 usec/pass |\n+---------------+-----------------+\n| transfer rate | 359.38 MB/sec   |\n+---------------+-----------------+\n\n*sendfile()*\n\n+---------------+-----------------+\n| CPU time      | 11.28 usec/pass |\n+---------------+-----------------+\n| transfer rate | 860.88 MB/sec   |\n+---------------+-----------------+\n\n===========================\nWhen do you want to use it?\n===========================\n\nBasically any application sending files over the network can take advantage of\nsendfile(2). HTTP and FTP servers are a typical example.\n`proftpd <http://www.proftpd.org/>`__ and\n`vsftpd <https://security.appspot.com/vsftpd.html>`__ are known to use it, so is\n`pyftpdlib <http://code.google.com/p/pyftpdlib/>`__.\n\n=================\nAPI documentation\n=================\n\nsendfile module provides a single function: sendfile().\n\n- ``sendfile.sendfile(out, in, offset, nbytes, header=\"\", trailer=\"\", flags=0)``\n\n  Copy *nbytes* bytes from file descriptor *in* (a regular file) to file\n  descriptor *out* (a socket) starting at *offset*. Return the number of\n  bytes just being sent. When the end of file is reached return 0.\n  On Linux, if *offset* is given as *None*, the bytes are read from the current\n  position of *in* and the position of *in* is updated.\n  *headers* and *trailers* are strings that are written before and after the\n  data from *in* is written. In cross platform applications their usage is\n  discouraged\n  (`send() <http://docs.python.org/library/socket.html#socket.socket.send>`__ or\n  `sendall() <http://docs.python.org/library/socket.html#socket.socket.sendall>`__\n  can be used instead). On Solaris, _out_ may be the file descriptor of a\n  regular file or the file descriptor of a socket. On all other platforms,\n  *out* must be the file descriptor of an open socket.\n  *flags* argument is only supported on FreeBSD.\n\n- ``sendfile.SF_NODISKIO``\n- ``sendfile.SF_MNOWAIT``\n- ``sendfile.SF_SYNC``\n\n  Parameters for the _flags_ argument, if the implementation supports it. They\n  are available on FreeBSD platforms. See `FreeBSD's man sendfile(2) <http://www.freebsd.org/cgi/man.cgi?query=sendfile&sektion=2>`__.\n\n=======================\nDifferences with send()\n=======================\n\n- sendfile(2) works with regular (mmap-like) files only (e.g. you can't use it\n  with a `StringIO <http://docs.python.org/library/stringio.html>`__ object).\n- Also, it must be clear that the file can only be sent \"as is\" (e.g. you\n  can't modify the content while transmitting).\n  There might be problems with non regular filesystems such as NFS,\n  SMBFS/Samba and CIFS. For this please refer to\n  `proftpd documentation <http://www.proftpd.org/docs/howto/Sendfile.html>`__.\n- `OSError <http://docs.python.org/library/exceptions.html#exceptions.OSError>`__\n  is raised instead of `socket.error <http://docs.python.org/library/socket.html#socket.error>`__.\n  The accompaining `error codes <http://docs.python.org/library/errno.html>`__\n  have the same meaning though: EAGAIN, EWOULDBLOCK, EBUSY meaning you are\n  supposed to retry, ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED in case of\n  disconnection. Some examples:\n  `benchmark script <https://github.com/giampaolo/pysendfile/blob/release-2.0.1/test/benchmark.py#L182>`__,\n  `test suite <https://github.com/giampaolo/pysendfile/blob/release-2.0.1/test/test_sendfile.py#L202>`__,\n  `pyftpdlib wrapper <http://code.google.com/p/pyftpdlib/source/browse/tags/release-0.7.0/pyftpdlib/ftpserver.py#1035>`__.\n\n===================\nSupported platforms\n===================\n\nThis module works with Python versions from **2.5** to **3.4**. The supported platforms are:\n\n- **Linux**\n- **Mac OSX**\n- **FreeBSD**\n- **Dragon Fly BSD**\n- **Sun OS**\n- **AIX** (not properly tested)\n\n=======\nSupport\n=======\n\nFeel free to mail me at *g.rodola [AT] gmail [DOT] com* or post on the the\nmailing list: http://groups.google.com/group/py-sendfile.\n\n======\nStatus\n======\n\nAs of now the code includes a solid `test suite <https://github.com/giampaolo/pysendfile/blob/master/test/test_sendfile.py>`__ and its ready for production use.\nIt's been included in `pyftpdlib <http://code.google.com/p/pyftpdlib/>`__\nproject and used in production environments for almost a year now without any\nproblem being reported so far.\n\n=======\nAuthors\n=======\n\npysendfile was originally written by *Ben Woolley* including Linux, FreeBSD and\nDragonFly BSD support. Later on *Niklas Edmundsson* took over maintenance and\nadded AIX support. After a couple of years of project stagnation\n`Giampaolo Rodola' <http://grodola.blogspot.com/p/about.html>`__ took over\nmaintenance and rewrote it from scratch adding support for:\n\n- Python 3\n- non-blocking sockets\n- `large file <http://docs.python.org/library/posix.html#large-file-support>`__ support\n- Mac OSX\n- Sun OS\n- FreeBSD flag argument\n- multiple threads (release GIL)\n- a simple benchmark suite\n- unit tests\n- documentation", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/giampaolo/pysendfile", "keywords": "sendfile,python,performance,ftp", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "pysendfile", "package_url": "https://pypi.org/project/pysendfile/", "platform": "UNIX", "project_url": "https://pypi.org/project/pysendfile/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/giampaolo/pysendfile"}, "release_url": "https://pypi.org/project/pysendfile/2.0.1/", "requires_dist": null, "requires_python": null, "summary": "A Python interface to sendfile(2)", "version": "2.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://crate.io/packages/pysendfile/\" rel=\"nofollow\"><img alt=\"Download this month\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5a901e7106b46ab9f393b4373c0c3b591c2dd2ae/68747470733a2f2f70797069702e696e2f642f707973656e6466696c652f62616467652e706e67\"></a>\n<a href=\"https://pypi.python.org/pypi/pysendfile/\" rel=\"nofollow\"><img alt=\"Latest version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bb6d69202eb6fb3a05827c9a81de09639a7f1685/68747470733a2f2f70797069702e696e2f762f707973656e6466696c652f62616467652e706e67\"></a>\n<a href=\"https://pypi.python.org/pypi/pysendfile/\" rel=\"nofollow\"><img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/250ea69fac30a3376fe5520586273aeb8da225b0/68747470733a2f2f70797069702e696e2f6c6963656e73652f707973656e6466696c652f62616467652e706e67\"></a>\n<a href=\"https://travis-ci.org/giampaolo/pysendfile\" rel=\"nofollow\"><img alt=\"Travis\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8c7ea40d8d64aad8a732a73cf339741f433745f6/68747470733a2f2f6170692e7472617669732d63692e6f72672f6769616d70616f6c6f2f707973656e6466696c652e706e673f6272616e63683d6d6173746572\"></a>\n<div id=\"quick-links\">\n<h2>Quick links</h2>\n<ul>\n<li><a href=\"https://github.com/giampaolo/pysendfile\" rel=\"nofollow\">Home page</a></li>\n<li><a href=\"http://groups.google.com/group/py-sendfile\" rel=\"nofollow\">Mailing list</a></li>\n<li><a href=\"http://grodola.blogspot.com/search/label/pysendfile\" rel=\"nofollow\">Blog</a></li>\n<li><a href=\"https://github.com/giampaolo/pysendfile/blob/master/HISTORY.rst\" rel=\"nofollow\">What\u2019s new</a></li>\n</ul>\n</div>\n<div id=\"about\">\n<h2>About</h2>\n<p><a href=\"http://linux.die.net/man/2/sendfile\" rel=\"nofollow\">sendfile(2)</a> is a system call which\nprovides a \u201czero-copy\u201d way of copying data from one file descriptor to another\n(a socket). The phrase \u201czero-copy\u201d refers to the fact that all of the copying\nof data between the two descriptors is done entirely by the kernel, with no\ncopying of data into userspace buffers. This is particularly useful when\nsending a file over a socket (e.g. FTP).\nThe normal way of sending a file over a socket involves reading data from the\nfile into a userspace buffer, then write that buffer to the socket via\n<a href=\"http://docs.python.org/library/socket.html#socket.socket.send\" rel=\"nofollow\">send()</a> or\n<a href=\"http://docs.python.org/library/socket.html#socket.socket.sendall\" rel=\"nofollow\">sendall()</a>:</p>\n<pre><span class=\"c1\"># how a file is tipically sent</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">socket</span>\n\n<span class=\"n\">file</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"somefile\"</span><span class=\"p\">,</span> <span class=\"s2\">\"rb\"</span><span class=\"p\">)</span>\n<span class=\"n\">sock</span> <span class=\"o\">=</span> <span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">socket</span><span class=\"p\">()</span>\n<span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">((</span><span class=\"s2\">\"127.0.0.1\"</span><span class=\"p\">,</span> <span class=\"mi\">8021</span><span class=\"p\">))</span>\n\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"n\">chunk</span> <span class=\"o\">=</span> <span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"mi\">65536</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">chunk</span><span class=\"p\">:</span>\n        <span class=\"k\">break</span>  <span class=\"c1\"># EOF</span>\n    <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">sendall</span><span class=\"p\">(</span><span class=\"n\">chunk</span><span class=\"p\">)</span>\n</pre>\n<p>This copying of the data twice (once into the userland buffer, and once out\nfrom that userland buffer) imposes some performance and resource penalties.\n<a href=\"http://linux.die.net/man/2/sendfile\" rel=\"nofollow\">sendfile(2)</a> syscall avoids these\npenalties by avoiding any use of userland buffers; it also results in a single\nsystem call (and thus only one context switch), rather than the series of\n<a href=\"http://linux.die.net/man/2/read\" rel=\"nofollow\">read(2)</a> /\n<a href=\"http://linux.die.net/man/2/write\" rel=\"nofollow\">write(2)</a> system calls (each system call\nrequiring a context switch) used internally for the data copying.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">socket</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sendfile</span> <span class=\"kn\">import</span> <span class=\"n\">sendfile</span>\n\n<span class=\"n\">file</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"somefile\"</span><span class=\"p\">,</span> <span class=\"s2\">\"rb\"</span><span class=\"p\">)</span>\n<span class=\"n\">blocksize</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">getsize</span><span class=\"p\">(</span><span class=\"s2\">\"somefile\"</span><span class=\"p\">)</span>\n<span class=\"n\">sock</span> <span class=\"o\">=</span> <span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"n\">socket</span><span class=\"p\">()</span>\n<span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">((</span><span class=\"s2\">\"127.0.0.1\"</span><span class=\"p\">,</span> <span class=\"mi\">8021</span><span class=\"p\">))</span>\n<span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"n\">sent</span> <span class=\"o\">=</span> <span class=\"n\">sendfile</span><span class=\"p\">(</span><span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">offset</span><span class=\"p\">,</span> <span class=\"n\">blocksize</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">sent</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">break</span>  <span class=\"c1\"># EOF</span>\n    <span class=\"n\">offset</span> <span class=\"o\">+=</span> <span class=\"n\">sent</span>\n</pre>\n</div>\n<div id=\"a-simple-benchmark\">\n<h2>A simple benchmark</h2>\n<p>This <a href=\"https://github.com/giampaolo/pysendfile/blob/master/test/benchmark.py\" rel=\"nofollow\">benchmark script</a>\nimplements the two examples above and compares plain socket.send() and\nsendfile() performances in terms of CPU time spent and bytes transmitted per\nsecond resulting in sendfile() being about <strong>2.5x faster</strong>. These are the\nresults I get on my Linux 2.6.38 box, AMD dual-core 1.6 GHz:</p>\n<p><em>send()</em></p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>CPU time</td>\n<td>28.84 usec/pass</td>\n</tr>\n<tr><td>transfer rate</td>\n<td>359.38 MB/sec</td>\n</tr>\n</tbody>\n</table>\n<p><em>sendfile()</em></p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>CPU time</td>\n<td>11.28 usec/pass</td>\n</tr>\n<tr><td>transfer rate</td>\n<td>860.88 MB/sec</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"when-do-you-want-to-use-it\">\n<h2>When do you want to use it?</h2>\n<p>Basically any application sending files over the network can take advantage of\nsendfile(2). HTTP and FTP servers are a typical example.\n<a href=\"http://www.proftpd.org/\" rel=\"nofollow\">proftpd</a> and\n<a href=\"https://security.appspot.com/vsftpd.html\" rel=\"nofollow\">vsftpd</a> are known to use it, so is\n<a href=\"http://code.google.com/p/pyftpdlib/\" rel=\"nofollow\">pyftpdlib</a>.</p>\n</div>\n<div id=\"api-documentation\">\n<h2>API documentation</h2>\n<p>sendfile module provides a single function: sendfile().</p>\n<ul>\n<li><p><tt>sendfile.sendfile(out, in, offset, nbytes, <span class=\"pre\">header=\"\",</span> <span class=\"pre\">trailer=\"\",</span> flags=0)</tt></p>\n<p>Copy <em>nbytes</em> bytes from file descriptor <em>in</em> (a regular file) to file\ndescriptor <em>out</em> (a socket) starting at <em>offset</em>. Return the number of\nbytes just being sent. When the end of file is reached return 0.\nOn Linux, if <em>offset</em> is given as <em>None</em>, the bytes are read from the current\nposition of <em>in</em> and the position of <em>in</em> is updated.\n<em>headers</em> and <em>trailers</em> are strings that are written before and after the\ndata from <em>in</em> is written. In cross platform applications their usage is\ndiscouraged\n(<a href=\"http://docs.python.org/library/socket.html#socket.socket.send\" rel=\"nofollow\">send()</a> or\n<a href=\"http://docs.python.org/library/socket.html#socket.socket.sendall\" rel=\"nofollow\">sendall()</a>\ncan be used instead). On Solaris, _out_ may be the file descriptor of a\nregular file or the file descriptor of a socket. On all other platforms,\n<em>out</em> must be the file descriptor of an open socket.\n<em>flags</em> argument is only supported on FreeBSD.</p>\n</li>\n<li><p><tt>sendfile.SF_NODISKIO</tt></p>\n</li>\n<li><p><tt>sendfile.SF_MNOWAIT</tt></p>\n</li>\n<li><p><tt>sendfile.SF_SYNC</tt></p>\n<p>Parameters for the _flags_ argument, if the implementation supports it. They\nare available on FreeBSD platforms. See <a href=\"http://www.freebsd.org/cgi/man.cgi?query=sendfile&amp;sektion=2\" rel=\"nofollow\">FreeBSD\u2019s man sendfile(2)</a>.</p>\n</li>\n</ul>\n</div>\n<div id=\"differences-with-send\">\n<h2>Differences with send()</h2>\n<ul>\n<li>sendfile(2) works with regular (mmap-like) files only (e.g. you can\u2019t use it\nwith a <a href=\"http://docs.python.org/library/stringio.html\" rel=\"nofollow\">StringIO</a> object).</li>\n<li>Also, it must be clear that the file can only be sent \u201cas is\u201d (e.g. you\ncan\u2019t modify the content while transmitting).\nThere might be problems with non regular filesystems such as NFS,\nSMBFS/Samba and CIFS. For this please refer to\n<a href=\"http://www.proftpd.org/docs/howto/Sendfile.html\" rel=\"nofollow\">proftpd documentation</a>.</li>\n<li><a href=\"http://docs.python.org/library/exceptions.html#exceptions.OSError\" rel=\"nofollow\">OSError</a>\nis raised instead of <a href=\"http://docs.python.org/library/socket.html#socket.error\" rel=\"nofollow\">socket.error</a>.\nThe accompaining <a href=\"http://docs.python.org/library/errno.html\" rel=\"nofollow\">error codes</a>\nhave the same meaning though: EAGAIN, EWOULDBLOCK, EBUSY meaning you are\nsupposed to retry, ECONNRESET, ENOTCONN, ESHUTDOWN, ECONNABORTED in case of\ndisconnection. Some examples:\n<a href=\"https://github.com/giampaolo/pysendfile/blob/release-2.0.1/test/benchmark.py#L182\" rel=\"nofollow\">benchmark script</a>,\n<a href=\"https://github.com/giampaolo/pysendfile/blob/release-2.0.1/test/test_sendfile.py#L202\" rel=\"nofollow\">test suite</a>,\n<a href=\"http://code.google.com/p/pyftpdlib/source/browse/tags/release-0.7.0/pyftpdlib/ftpserver.py#1035\" rel=\"nofollow\">pyftpdlib wrapper</a>.</li>\n</ul>\n</div>\n<div id=\"supported-platforms\">\n<h2>Supported platforms</h2>\n<p>This module works with Python versions from <strong>2.5</strong> to <strong>3.4</strong>. The supported platforms are:</p>\n<ul>\n<li><strong>Linux</strong></li>\n<li><strong>Mac OSX</strong></li>\n<li><strong>FreeBSD</strong></li>\n<li><strong>Dragon Fly BSD</strong></li>\n<li><strong>Sun OS</strong></li>\n<li><strong>AIX</strong> (not properly tested)</li>\n</ul>\n</div>\n<div id=\"support\">\n<h2>Support</h2>\n<p>Feel free to mail me at <em>g.rodola [AT] gmail [DOT] com</em> or post on the the\nmailing list: <a href=\"http://groups.google.com/group/py-sendfile\" rel=\"nofollow\">http://groups.google.com/group/py-sendfile</a>.</p>\n</div>\n<div id=\"status\">\n<h2>Status</h2>\n<p>As of now the code includes a solid <a href=\"https://github.com/giampaolo/pysendfile/blob/master/test/test_sendfile.py\" rel=\"nofollow\">test suite</a> and its ready for production use.\nIt\u2019s been included in <a href=\"http://code.google.com/p/pyftpdlib/\" rel=\"nofollow\">pyftpdlib</a>\nproject and used in production environments for almost a year now without any\nproblem being reported so far.</p>\n</div>\n<div id=\"authors\">\n<h2>Authors</h2>\n<p>pysendfile was originally written by <em>Ben Woolley</em> including Linux, FreeBSD and\nDragonFly BSD support. Later on <em>Niklas Edmundsson</em> took over maintenance and\nadded AIX support. After a couple of years of project stagnation\n<a href=\"http://grodola.blogspot.com/p/about.html\" rel=\"nofollow\">Giampaolo Rodola\u2019</a> took over\nmaintenance and rewrote it from scratch adding support for:</p>\n<ul>\n<li>Python 3</li>\n<li>non-blocking sockets</li>\n<li><a href=\"http://docs.python.org/library/posix.html#large-file-support\" rel=\"nofollow\">large file</a> support</li>\n<li>Mac OSX</li>\n<li>Sun OS</li>\n<li>FreeBSD flag argument</li>\n<li>multiple threads (release GIL)</li>\n<li>a simple benchmark suite</li>\n<li>unit tests</li>\n<li>documentation</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 1105484, "releases": {"0.2.0": [], "2.0.0": [{"comment_text": "", "digests": {"md5": "bd8d96b64e7c5c5b91ea2a6659aa82a3", "sha256": "b7b747e47f2b1b16942d8db9139e0f0f70546ca80a06460bd5abfdc7a1bca957"}, "downloads": -1, "filename": "pysendfile-2.0.0.tar.gz", "has_sig": false, "md5_digest": "bd8d96b64e7c5c5b91ea2a6659aa82a3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11155, "upload_time": "2014-04-30T21:51:04", "upload_time_iso_8601": "2014-04-30T21:51:04.288341Z", "url": "https://files.pythonhosted.org/packages/16/f1/7a275a36a0ab8ddc6851c8b71b119cfe67aa8ea493c1480d86a58989965f/pysendfile-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "e7b301eddd703ab74a48c59a8fda1f97", "sha256": "510a414b270986fba3c79cb76d90a4c910c701bfb43ff983a5d4e92846050e17"}, "downloads": -1, "filename": "pysendfile-2.0.1.tar.gz", "has_sig": false, "md5_digest": "e7b301eddd703ab74a48c59a8fda1f97", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19315, "upload_time": "2014-05-27T11:07:29", "upload_time_iso_8601": "2014-05-27T11:07:29.823919Z", "url": "https://files.pythonhosted.org/packages/cd/3f/4aa268afd0252f06b3b487c296a066a01ddd4222a46b7a3748599c8fc8c3/pysendfile-2.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e7b301eddd703ab74a48c59a8fda1f97", "sha256": "510a414b270986fba3c79cb76d90a4c910c701bfb43ff983a5d4e92846050e17"}, "downloads": -1, "filename": "pysendfile-2.0.1.tar.gz", "has_sig": false, "md5_digest": "e7b301eddd703ab74a48c59a8fda1f97", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19315, "upload_time": "2014-05-27T11:07:29", "upload_time_iso_8601": "2014-05-27T11:07:29.823919Z", "url": "https://files.pythonhosted.org/packages/cd/3f/4aa268afd0252f06b3b487c296a066a01ddd4222a46b7a3748599c8fc8c3/pysendfile-2.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:08 2020"}