{"info": {"author": "Dominik Leibenger", "author_email": "python-fastchunking@mails.dominik-leibenger.de", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "===========================\nfastchunking Python library\n===========================\n\n.. image:: https://travis-ci.org/netleibi/fastchunking.svg?branch=master\n    :target: https://travis-ci.org/netleibi/fastchunking\n\n.. image:: https://badge.fury.io/py/fastchunking.svg\n    :target: https://badge.fury.io/py/fastchunking\n\n.. image:: https://readthedocs.org/projects/fastchunking/badge/?version=latest\n    :target: http://fastchunking.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\nWhat it is\n----------\n\n`fastchunking` is a Python library that contains efficient and easy-to-use\nimplementations of string chunking algorithms.\n\nIt has been developed as part of the work [LS16]_ at CISPA, Saarland University.\n\nInstallation\n------------\n\n::\n\n    $ pip install fastchunking\n\n.. note:: For performance reasons, parts of this library are implemented in C++.\n\tInstallation from a source distribution, thus, requires availability of a\n\tcorrectly configured C++ compiler.\n\nUsage and Overview\n------------------\n\n`fastchunking` provides efficient implementations for different string chunking\nalgorithms, e.g., static chunking (SC) and content-defined chunking (CDC).\n\nStatic Chunking (SC)\n^^^^^^^^^^^^^^^^^^^^\n\nStatic chunking splits a message into fixed-size chunks.\n\nLet us consider a random example message that shall be chunked:\n    >>> import os\n    >>> message = os.urandom(1024*1024)\n\nStatic chunking is trivial when chunking a single message:\n    >>> import fastchunking\n    >>> sc = fastchunking.SC()\n    >>> chunker = sc.create_chunker(chunk_size=4096)\n    >>> chunker.next_chunk_boundaries(message)\n    [4096, 8192, 12288, ...]\n\nA large message can also be chunked in fragments, though:\n    >>> chunker = sc.create_chunker(chunk_size=4096)\n    >>> chunker.next_chunk_boundaries(message[:10240])\n    [4096, 8192]\n    >>> chunker.next_chunk_boundaries(message[10240:])\n    [2048, 6144, 10240, ...]\n\nContent-Defined Chunking (CDC)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n`fastchunking` supports content-defined chunking, i.e., chunking of messages\ninto fragments of variable lengths.\n\nCurrently, a chunking strategy based on Rabin-Karp rolling hashes is supported.\n\nAs a rolling hash computation on plain-Python strings is incredibly slow with\nany interpreter, most of the computation is performed by a C++ extension which\nis based on the `ngramhashing` library by Daniel Lemire, see:\nhttps://github.com/lemire/rollinghashcpp\n\nLet us consider a random message that should be chunked:\n    >>> import os\n    >>> message = os.urandom(1024*1024)\n\nWhen using static chunking, we have to specify a rolling hash window size (here:\n48 bytes) and an optional seed value that affects the pseudo-random distribution\nof the generated chunk boundaries.\n\nDespite that, usage is similar to static chunking:\n    >>> import fastchunking\n    >>> cdc = fastchunking.RabinKarpCDC(window_size=48, seed=0)\n    >>> chunker = cdc.create_chunker(chunk_size=4096)\n    >>> chunker.next_chunk_boundaries(message)\n    [7475, 10451, 12253, 13880, 15329, 19808, ...]\n    \nChunking in fragments is straightforward:\n    >>> chunker = cdc.create_chunker(chunk_size=4096)\n    >>> chunker.next_chunk_boundaries(message[:10240])\n    [7475]\n    >>> chunker.next_chunk_boundaries(message[10240:])\n    [211, 2013, 3640, 5089, 9568, ...]\n\nMulti-Level Chunking (ML-\\*)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nMultiple chunkers of the same type (but with different chunk sizes) can be\nefficiently used in parallel, e.g., to perform multi-level chunking [LS16]_.\n\nAgain, let us consider a random message that should be chunked:\n    >>> import os\n    >>> message = os.urandom(1024*1024)\n\nUsage of multi-level-chunking, e.g., ML-CDC, is easy:\n    >>> import fastchunking\n    >>> cdc = fastchunking.RabinKarpCDC(window_size=48, seed=0)\n    >>> chunk_sizes = [1024, 2048, 4096]\n    >>> chunker = cdc.create_multilevel_chunker(chunk_sizes)\n    >>> chunker.next_chunk_boundaries_with_levels(message)\n    [(1049, 2), (1511, 1), (1893, 2), (2880, 1), (2886, 0),\n    (3701, 0), (4617, 0), (5809, 2), (5843, 0), ...]\n\nThe second value in each tuple indicates the highest chunk size that leads to\na boundary. Here, the first boundary is a boundary created by the chunker with\nindex 2, i.e., the chunker with 4096 bytes target chunk size.\n\n.. note::\n   Only the highest index is output if multiple chunkers yield the same\n   boundary.\n    \n.. warning::\n   Chunk sizes have to be passed in correct order, i.e., from lowest to highest\n   value.\n\nPerformance\n-----------\n\nComputation costs for `static chunking` are barely measurable: As chunking does\nnot depend on the actual message but only its length, computation costs are\nessentially limited to a single :code:`xrange` call.\n\n`Content-defined chunking`, however, is expensive: The algorithm has to compute\nhash values for rolling hash window contents at `every` byte position of the\nmessage that is to be chunked. To minimize costs, fastchunking works as follows:\n    \n    1. The message (fragment) is passed in its entirety to the C++ extension.\n    2. Chunking is performed within the C++ extension.\n    3. The resulting list of chunk boundaries is communicated back to Python and\n       converted into a Python list.\n\nBased on a 100 MiB random content, the author measured the following throughput\non an Intel Core i7-4770K in a single, non-representative test run using\nPython 3.5 (Windows x86-64):\n\n    =========== ==========\n    chunk size  throughput\n    =========== ==========\n    64 bytes    118 MiB/s\n    128 bytes   153 MiB/s\n    256 bytes   187 MiB/s\n    512 bytes   206 MiB/s\n    1024 bytes  221 MiB/s\n    2048 bytes  226 MiB/s\n    4096 bytes  231 MiB/s\n    8192 bytes  234 MiB/s\n    16384 bytes 233 MiB/s\n    32768 bytes 234 MiB/s\n    =========== ==========\n\nTesting\n-------\n\n`fastchunking` uses tox for testing, so simply run:\n\n::\n\n\t$ tox\n\nReferences:\n    .. [LS16] Dominik Leibenger and Christoph Sorge (2016). sec-cs: Getting the\n       Most out of Untrusted Cloud Storage.\n       `arXiv:1606.03368 <http://arxiv.org/abs/1606.03368>`_", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/netleibi/fastchunking", "keywords": "text chunking,SC,static chunking,CDC,content-defined chunking,ML-*,multi-level chunking,ML-SC,ML-CDC,Rabin Karp,rolling hash", "license": "Apache Software License", "maintainer": "", "maintainer_email": "", "name": "fastchunking", "package_url": "https://pypi.org/project/fastchunking/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/fastchunking/", "project_urls": {"Homepage": "https://github.com/netleibi/fastchunking"}, "release_url": "https://pypi.org/project/fastchunking/0.0.3/", "requires_dist": null, "requires_python": "", "summary": "Fast chunking library.", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/netleibi/fastchunking\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/netleibi/fastchunking.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5a6ccc7a661170e89e6aa2503e8a049b240957bc/68747470733a2f2f7472617669732d63692e6f72672f6e65746c656962692f666173746368756e6b696e672e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://badge.fury.io/py/fastchunking\" rel=\"nofollow\"><img alt=\"https://badge.fury.io/py/fastchunking.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/21adcefb10065c1901f0b970d37cc779aad5e0db/68747470733a2f2f62616467652e667572792e696f2f70792f666173746368756e6b696e672e737667\"></a>\n<a href=\"http://fastchunking.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2e25eb6e3c82c2bfe61a32583523dd3ebc878268/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f666173746368756e6b696e672f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<div id=\"what-it-is\">\n<h2>What it is</h2>\n<p><cite>fastchunking</cite> is a Python library that contains efficient and easy-to-use\nimplementations of string chunking algorithms.</p>\n<p>It has been developed as part of the work <a href=\"#ls16\" id=\"id1\" rel=\"nofollow\">[LS16]</a> at CISPA, Saarland University.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>$ pip install fastchunking\n</pre>\n<div>\n<p>Note</p>\n<p>For performance reasons, parts of this library are implemented in C++.\nInstallation from a source distribution, thus, requires availability of a\ncorrectly configured C++ compiler.</p>\n</div>\n</div>\n<div id=\"usage-and-overview\">\n<h2>Usage and Overview</h2>\n<p><cite>fastchunking</cite> provides efficient implementations for different string chunking\nalgorithms, e.g., static chunking (SC) and content-defined chunking (CDC).</p>\n<div id=\"static-chunking-sc\">\n<h3>Static Chunking (SC)</h3>\n<p>Static chunking splits a message into fixed-size chunks.</p>\n<dl>\n<dt>Let us consider a random example message that shall be chunked:</dt>\n<dd><pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; message = os.urandom(1024*1024)\n</pre>\n</dd>\n<dt>Static chunking is trivial when chunking a single message:</dt>\n<dd><pre>&gt;&gt;&gt; import fastchunking\n&gt;&gt;&gt; sc = fastchunking.SC()\n&gt;&gt;&gt; chunker = sc.create_chunker(chunk_size=4096)\n&gt;&gt;&gt; chunker.next_chunk_boundaries(message)\n[4096, 8192, 12288, ...]\n</pre>\n</dd>\n<dt>A large message can also be chunked in fragments, though:</dt>\n<dd><pre>&gt;&gt;&gt; chunker = sc.create_chunker(chunk_size=4096)\n&gt;&gt;&gt; chunker.next_chunk_boundaries(message[:10240])\n[4096, 8192]\n&gt;&gt;&gt; chunker.next_chunk_boundaries(message[10240:])\n[2048, 6144, 10240, ...]\n</pre>\n</dd>\n</dl>\n</div>\n<div id=\"content-defined-chunking-cdc\">\n<h3>Content-Defined Chunking (CDC)</h3>\n<p><cite>fastchunking</cite> supports content-defined chunking, i.e., chunking of messages\ninto fragments of variable lengths.</p>\n<p>Currently, a chunking strategy based on Rabin-Karp rolling hashes is supported.</p>\n<p>As a rolling hash computation on plain-Python strings is incredibly slow with\nany interpreter, most of the computation is performed by a C++ extension which\nis based on the <cite>ngramhashing</cite> library by Daniel Lemire, see:\n<a href=\"https://github.com/lemire/rollinghashcpp\" rel=\"nofollow\">https://github.com/lemire/rollinghashcpp</a></p>\n<dl>\n<dt>Let us consider a random message that should be chunked:</dt>\n<dd><pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; message = os.urandom(1024*1024)\n</pre>\n</dd>\n</dl>\n<p>When using static chunking, we have to specify a rolling hash window size (here:\n48 bytes) and an optional seed value that affects the pseudo-random distribution\nof the generated chunk boundaries.</p>\n<dl>\n<dt>Despite that, usage is similar to static chunking:</dt>\n<dd><pre>&gt;&gt;&gt; import fastchunking\n&gt;&gt;&gt; cdc = fastchunking.RabinKarpCDC(window_size=48, seed=0)\n&gt;&gt;&gt; chunker = cdc.create_chunker(chunk_size=4096)\n&gt;&gt;&gt; chunker.next_chunk_boundaries(message)\n[7475, 10451, 12253, 13880, 15329, 19808, ...]\n</pre>\n</dd>\n<dt>Chunking in fragments is straightforward:</dt>\n<dd><pre>&gt;&gt;&gt; chunker = cdc.create_chunker(chunk_size=4096)\n&gt;&gt;&gt; chunker.next_chunk_boundaries(message[:10240])\n[7475]\n&gt;&gt;&gt; chunker.next_chunk_boundaries(message[10240:])\n[211, 2013, 3640, 5089, 9568, ...]\n</pre>\n</dd>\n</dl>\n</div>\n<div id=\"multi-level-chunking-ml\">\n<h3>Multi-Level Chunking (ML-*)</h3>\n<p>Multiple chunkers of the same type (but with different chunk sizes) can be\nefficiently used in parallel, e.g., to perform multi-level chunking <a href=\"#ls16\" id=\"id2\" rel=\"nofollow\">[LS16]</a>.</p>\n<dl>\n<dt>Again, let us consider a random message that should be chunked:</dt>\n<dd><pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; message = os.urandom(1024*1024)\n</pre>\n</dd>\n<dt>Usage of multi-level-chunking, e.g., ML-CDC, is easy:</dt>\n<dd><pre>&gt;&gt;&gt; import fastchunking\n&gt;&gt;&gt; cdc = fastchunking.RabinKarpCDC(window_size=48, seed=0)\n&gt;&gt;&gt; chunk_sizes = [1024, 2048, 4096]\n&gt;&gt;&gt; chunker = cdc.create_multilevel_chunker(chunk_sizes)\n&gt;&gt;&gt; chunker.next_chunk_boundaries_with_levels(message)\n[(1049, 2), (1511, 1), (1893, 2), (2880, 1), (2886, 0),\n(3701, 0), (4617, 0), (5809, 2), (5843, 0), ...]\n</pre>\n</dd>\n</dl>\n<p>The second value in each tuple indicates the highest chunk size that leads to\na boundary. Here, the first boundary is a boundary created by the chunker with\nindex 2, i.e., the chunker with 4096 bytes target chunk size.</p>\n<div>\n<p>Note</p>\n<p>Only the highest index is output if multiple chunkers yield the same\nboundary.</p>\n</div>\n<div>\n<p>Warning</p>\n<p>Chunk sizes have to be passed in correct order, i.e., from lowest to highest\nvalue.</p>\n</div>\n</div>\n</div>\n<div id=\"performance\">\n<h2>Performance</h2>\n<p>Computation costs for <cite>static chunking</cite> are barely measurable: As chunking does\nnot depend on the actual message but only its length, computation costs are\nessentially limited to a single <code>xrange</code> call.</p>\n<p><cite>Content-defined chunking</cite>, however, is expensive: The algorithm has to compute\nhash values for rolling hash window contents at <cite>every</cite> byte position of the\nmessage that is to be chunked. To minimize costs, fastchunking works as follows:</p>\n<blockquote>\n<ol>\n<li>The message (fragment) is passed in its entirety to the C++ extension.</li>\n<li>Chunking is performed within the C++ extension.</li>\n<li>The resulting list of chunk boundaries is communicated back to Python and\nconverted into a Python list.</li>\n</ol>\n</blockquote>\n<p>Based on a 100 MiB random content, the author measured the following throughput\non an Intel Core i7-4770K in a single, non-representative test run using\nPython 3.5 (Windows x86-64):</p>\n<blockquote>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>chunk size</th>\n<th>throughput</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>64 bytes</td>\n<td>118 MiB/s</td>\n</tr>\n<tr><td>128 bytes</td>\n<td>153 MiB/s</td>\n</tr>\n<tr><td>256 bytes</td>\n<td>187 MiB/s</td>\n</tr>\n<tr><td>512 bytes</td>\n<td>206 MiB/s</td>\n</tr>\n<tr><td>1024 bytes</td>\n<td>221 MiB/s</td>\n</tr>\n<tr><td>2048 bytes</td>\n<td>226 MiB/s</td>\n</tr>\n<tr><td>4096 bytes</td>\n<td>231 MiB/s</td>\n</tr>\n<tr><td>8192 bytes</td>\n<td>234 MiB/s</td>\n</tr>\n<tr><td>16384 bytes</td>\n<td>233 MiB/s</td>\n</tr>\n<tr><td>32768 bytes</td>\n<td>234 MiB/s</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"testing\">\n<h2>Testing</h2>\n<p><cite>fastchunking</cite> uses tox for testing, so simply run:</p>\n<pre>$ tox\n</pre>\n<dl>\n<dt>References:</dt>\n<dd><table id=\"ls16\">\n<col><col>\n<tbody>\n<tr><td>[LS16]</td><td><em>(<a href=\"#id1\" rel=\"nofollow\">1</a>, <a href=\"#id2\" rel=\"nofollow\">2</a>)</em> Dominik Leibenger and Christoph Sorge (2016). sec-cs: Getting the\nMost out of Untrusted Cloud Storage.\n<a href=\"http://arxiv.org/abs/1606.03368\" rel=\"nofollow\">arXiv:1606.03368</a></td></tr>\n</tbody>\n</table>\n</dd>\n</dl>\n</div>\n\n          </div>"}, "last_serial": 2641300, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "34d0c57a3bf39e7cc0213781917462c5", "sha256": "e08825537f962471c53ebd4453612e4d80c29906aaae209d5ffdb083e0abb5ec"}, "downloads": -1, "filename": "fastchunking-0.0.1.zip", "has_sig": false, "md5_digest": "34d0c57a3bf39e7cc0213781917462c5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30314, "upload_time": "2016-06-10T16:16:54", "upload_time_iso_8601": "2016-06-10T16:16:54.258700Z", "url": "https://files.pythonhosted.org/packages/5f/8a/e8021aa8bbe4cca395d4da245e1b495de2ead69d60680467d96315e13a8d/fastchunking-0.0.1.zip", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "81dfabba4bedaff9f257273ca0ea2e2d", "sha256": "a1719609cca099e7d5518481e2d194f19a5ae075866a4f8ce12b35a5c8860219"}, "downloads": -1, "filename": "fastchunking-0.0.2.zip", "has_sig": false, "md5_digest": "81dfabba4bedaff9f257273ca0ea2e2d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30555, "upload_time": "2016-06-10T22:57:36", "upload_time_iso_8601": "2016-06-10T22:57:36.678161Z", "url": "https://files.pythonhosted.org/packages/5c/d3/9d49991625c91377a148f6cad08e61e1e2cc195cbf378e14c8cde5db6536/fastchunking-0.0.2.zip", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "b99349db3b4c78bf095c904c17ce1bc7", "sha256": "c23cae643f09176145cc1628d987e7dfcb9d4bae3e1a80d7b6f0fae83d0bcaa2"}, "downloads": -1, "filename": "fastchunking-0.0.3.tar.gz", "has_sig": false, "md5_digest": "b99349db3b4c78bf095c904c17ce1bc7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24938, "upload_time": "2017-02-14T15:40:28", "upload_time_iso_8601": "2017-02-14T15:40:28.740493Z", "url": "https://files.pythonhosted.org/packages/64/89/f9ede0f8c27c34ca7794beb3eede54aa630e7a1be9449aede50100db10ab/fastchunking-0.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b99349db3b4c78bf095c904c17ce1bc7", "sha256": "c23cae643f09176145cc1628d987e7dfcb9d4bae3e1a80d7b6f0fae83d0bcaa2"}, "downloads": -1, "filename": "fastchunking-0.0.3.tar.gz", "has_sig": false, "md5_digest": "b99349db3b4c78bf095c904c17ce1bc7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24938, "upload_time": "2017-02-14T15:40:28", "upload_time_iso_8601": "2017-02-14T15:40:28.740493Z", "url": "https://files.pythonhosted.org/packages/64/89/f9ede0f8c27c34ca7794beb3eede54aa630e7a1be9449aede50100db10ab/fastchunking-0.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:43:36 2020"}