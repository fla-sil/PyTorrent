{"info": {"author": "Xavier Barbosa", "author_email": "clint.northwood@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Quality Assurance", "Topic :: System :: Clustering", "Topic :: System :: Monitoring", "Topic :: System :: Networking :: Monitoring"], "description": "AIO Riemann\n===========\n\nThis is a client for Riemann_ build on top of async/await syntax.\nIt supports TCP, UDP and TLS connections.\n\n\nInstallation\n------------\n\n::\n\n    pip install aioriemann\n\n\nWorking with client\n-------------------\n\nNow that AIORiemann is installed, let's try sending some of our own states\nthrough the client::\n\n    >>> from aioriemann import Riemann\n    >>> client = Riemann()\n\nWe can send events with ``send()``. For example, let's log an HTTP request::\n\n    >>> await client.send({\n    ...   \"host\": \"www1\",\n    ...   \"service\": \"http req\",\n    ...   \"metric\": 2.53,\n    ...   \"state\": \"critical\",\n    ...   \"description\": \"Request took 2.53 seconds.\",\n    ...   \"tags\": [\"http\"]\n    ... })\n\nOn the dashboard, critical events (like the one we just submitted) show up in\nred. All of these fields are optional, by the way. The client will assume your\nevents come from the local host name unless you pass ``host=None``.\n\nNow let's ask for all events that have a service beginning with \"http\"::\n\n    >>> await client.query('service =~ \"http%\"')\n    [\n        {\n            \"timestamp\": 1330041937,\n            \"state\": \"critical\",\n            \"service\": \"http req\",\n            \"host\": \"www1\",\n            \"description\": \"Request took 2.53 seconds.\",\n            \"tags\": [\"http\"],\n            \"ttl\": 300.0,\n            \"metric\": 2.5299999713897705\n        }\n    ]\n\nThere's the event we submitted.\n\n**query()** and **send()** are wrapped in asyncio.Task. so it means that\nthey are scheduled automatically event without ``await`` keyword::\n\n    >>> client.send({\n    ...   \"host\": \"www1\",\n    ...   \"service\": \"http req\",\n    ...   \"metric\": 2.53,\n    ...   \"state\": \"critical\",\n    ...   \"description\": \"Request took 2.53 seconds.\",\n    ...   \"tags\": [\"http\"]\n    ... }).add_done_callback(func)\n    >>> client.query('service =~ \"http%\"').add_done_callback(func)\n\nAnd later call **join()** to ensure that tasks have been done::\n\n    >>> await client.join()\n\n\nSpecifications\n--------------\n\nA TCP connection to Riemann is a stream of messages. Each message is a 4 byte\nnetwork-endian integer *length*, followed by a Protocol Buffer Message of\n*length* bytes. See the `protocol buffer definition`_ for the details.\n\nOver UDP, the length header is omitted; just send the protobuf Message directly.\nUDP datagrams have a default maximum size of 16384 bytes by Riemann's default;\nlarger messages should go over TCP. This limit is configurable in both the\nclient and server; client values *must* be smaller than the server's.\n\nThe server will accept a repeated list of Events, and respond with a\nconfirmation message with either an acknowledgement or an error. Check the ok\nboolean in the message; if false, message.error will be a descriptive string.\n\nBecause protocol buffers is a strongly typed protocol, the metric of an event\nis represented as one of metric_d (floating point 64-bit), metric_f (floating\npoint 32-bit), or metric_sint64 (64-bit signed integer). Your client should\nemit and consume all of these types. For compatibility with older versions of\nRiemann, you may *also* emit a metric_f alongside the normal type; newer\nversions of Riemann will prefer the higher-resolution types.\n\nEvents are uniquely identified by host and service. Both allow null. Event.time\nis the time in unix epoch seconds and is optional. The server will generate a\ntime for each event when received if you do not provide one. I don't need time\nresolution finer than 1 second presently, but if you do, my plan is to add a\nnanosecond field as well.\n\nYou can also query events from the index using a basic query language. Just\nsubmit a Message with your query in message.query.string. Search queries will\nreturn a message with repeated Events matching that expression. A null\nexpression will return no states. For some example queries, see\n`The query test suite`_.\n\nYou might find it useful to read the `Ruby client`_ source as a guide to\nwriting your own client.\n\n\nReading list\n------------\n\n* Realtime cluster monitoring with docker swarm and riemann:\n  https://blog.docker.com/2016/03/realtime-cluster-monitoring-docker-swarm-riemann/\n\n.. _Riemann: http://riemann.io\n.. _`protocol buffer definition`: https://github.com/riemann/riemann-java-client/blob/master/riemann-java-client/src/main/proto/riemann/proto.proto\n.. _`The query test suite`: https://github.com/riemann/riemann/blob/master/test/riemann/query_test.clj\n.. _`Ruby client`: https://github.com/riemann/riemann-ruby-client\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://aio.errorist.io/aioriemann", "keywords": "infrastructure,asyncio,service discovery,health checking,key/value store", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "aioriemann", "package_url": "https://pypi.org/project/aioriemann/", "platform": "", "project_url": "https://pypi.org/project/aioriemann/", "project_urls": {"Homepage": "http://aio.errorist.io/aioriemann"}, "release_url": "https://pypi.org/project/aioriemann/1.0.0a1/", "requires_dist": ["protobuf3"], "requires_python": "", "summary": "async/await client for Riemann", "version": "1.0.0a1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This is a client for <a href=\"http://riemann.io\" rel=\"nofollow\">Riemann</a> build on top of async/await syntax.\nIt supports TCP, UDP and TLS connections.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>pip install aioriemann\n</pre>\n</div>\n<div id=\"working-with-client\">\n<h2>Working with client</h2>\n<p>Now that AIORiemann is installed, let\u2019s try sending some of our own states\nthrough the client:</p>\n<pre>&gt;&gt;&gt; from aioriemann import Riemann\n&gt;&gt;&gt; client = Riemann()\n</pre>\n<p>We can send events with <tt>send()</tt>. For example, let\u2019s log an HTTP request:</p>\n<pre>&gt;&gt;&gt; await client.send({\n...   \"host\": \"www1\",\n...   \"service\": \"http req\",\n...   \"metric\": 2.53,\n...   \"state\": \"critical\",\n...   \"description\": \"Request took 2.53 seconds.\",\n...   \"tags\": [\"http\"]\n... })\n</pre>\n<p>On the dashboard, critical events (like the one we just submitted) show up in\nred. All of these fields are optional, by the way. The client will assume your\nevents come from the local host name unless you pass <tt>host=None</tt>.</p>\n<p>Now let\u2019s ask for all events that have a service beginning with \u201chttp\u201d:</p>\n<pre>&gt;&gt;&gt; await client.query('service =~ \"http%\"')\n[\n    {\n        \"timestamp\": 1330041937,\n        \"state\": \"critical\",\n        \"service\": \"http req\",\n        \"host\": \"www1\",\n        \"description\": \"Request took 2.53 seconds.\",\n        \"tags\": [\"http\"],\n        \"ttl\": 300.0,\n        \"metric\": 2.5299999713897705\n    }\n]\n</pre>\n<p>There\u2019s the event we submitted.</p>\n<p><strong>query()</strong> and <strong>send()</strong> are wrapped in asyncio.Task. so it means that\nthey are scheduled automatically event without <tt>await</tt> keyword:</p>\n<pre>&gt;&gt;&gt; client.send({\n...   \"host\": \"www1\",\n...   \"service\": \"http req\",\n...   \"metric\": 2.53,\n...   \"state\": \"critical\",\n...   \"description\": \"Request took 2.53 seconds.\",\n...   \"tags\": [\"http\"]\n... }).add_done_callback(func)\n&gt;&gt;&gt; client.query('service =~ \"http%\"').add_done_callback(func)\n</pre>\n<p>And later call <strong>join()</strong> to ensure that tasks have been done:</p>\n<pre>&gt;&gt;&gt; await client.join()\n</pre>\n</div>\n<div id=\"specifications\">\n<h2>Specifications</h2>\n<p>A TCP connection to Riemann is a stream of messages. Each message is a 4 byte\nnetwork-endian integer <em>length</em>, followed by a Protocol Buffer Message of\n<em>length</em> bytes. See the <a href=\"https://github.com/riemann/riemann-java-client/blob/master/riemann-java-client/src/main/proto/riemann/proto.proto\" rel=\"nofollow\">protocol buffer definition</a> for the details.</p>\n<p>Over UDP, the length header is omitted; just send the protobuf Message directly.\nUDP datagrams have a default maximum size of 16384 bytes by Riemann\u2019s default;\nlarger messages should go over TCP. This limit is configurable in both the\nclient and server; client values <em>must</em> be smaller than the server\u2019s.</p>\n<p>The server will accept a repeated list of Events, and respond with a\nconfirmation message with either an acknowledgement or an error. Check the ok\nboolean in the message; if false, message.error will be a descriptive string.</p>\n<p>Because protocol buffers is a strongly typed protocol, the metric of an event\nis represented as one of metric_d (floating point 64-bit), metric_f (floating\npoint 32-bit), or metric_sint64 (64-bit signed integer). Your client should\nemit and consume all of these types. For compatibility with older versions of\nRiemann, you may <em>also</em> emit a metric_f alongside the normal type; newer\nversions of Riemann will prefer the higher-resolution types.</p>\n<p>Events are uniquely identified by host and service. Both allow null. Event.time\nis the time in unix epoch seconds and is optional. The server will generate a\ntime for each event when received if you do not provide one. I don\u2019t need time\nresolution finer than 1 second presently, but if you do, my plan is to add a\nnanosecond field as well.</p>\n<p>You can also query events from the index using a basic query language. Just\nsubmit a Message with your query in message.query.string. Search queries will\nreturn a message with repeated Events matching that expression. A null\nexpression will return no states. For some example queries, see\n<a href=\"https://github.com/riemann/riemann/blob/master/test/riemann/query_test.clj\" rel=\"nofollow\">The query test suite</a>.</p>\n<p>You might find it useful to read the <a href=\"https://github.com/riemann/riemann-ruby-client\" rel=\"nofollow\">Ruby client</a> source as a guide to\nwriting your own client.</p>\n</div>\n<div id=\"reading-list\">\n<h2>Reading list</h2>\n<ul>\n<li>Realtime cluster monitoring with docker swarm and riemann:\n<a href=\"https://blog.docker.com/2016/03/realtime-cluster-monitoring-docker-swarm-riemann/\" rel=\"nofollow\">https://blog.docker.com/2016/03/realtime-cluster-monitoring-docker-swarm-riemann/</a></li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 2440241, "releases": {"1.0.0a1": [{"comment_text": "", "digests": {"md5": "10ed003afe2929df987716a724d32828", "sha256": "50160f8811c83dcef012c358199b4e029017febfc849e0e86622a26ce8f6f5a4"}, "downloads": -1, "filename": "aioriemann-1.0.0a1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "10ed003afe2929df987716a724d32828", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 13162, "upload_time": "2016-11-03T14:45:54", "upload_time_iso_8601": "2016-11-03T14:45:54.086138Z", "url": "https://files.pythonhosted.org/packages/86/43/635599db26b1463ced75841bc96cda05428acfdb572b37ac2a0acd35002a/aioriemann-1.0.0a1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e201afc8be9f3ce9734fb0641d9b608a", "sha256": "22f16dfbb12d9d751ccd32f324db45f12617c49162cd1a9c3a1528470e42a030"}, "downloads": -1, "filename": "aioriemann-1.0.0a1.tar.gz", "has_sig": false, "md5_digest": "e201afc8be9f3ce9734fb0641d9b608a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24436, "upload_time": "2016-11-03T14:45:56", "upload_time_iso_8601": "2016-11-03T14:45:56.223522Z", "url": "https://files.pythonhosted.org/packages/65/0e/c5bc159ba1358088cbd82ec7a27c0b2384d259ed8e6f4334c4118915269a/aioriemann-1.0.0a1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "10ed003afe2929df987716a724d32828", "sha256": "50160f8811c83dcef012c358199b4e029017febfc849e0e86622a26ce8f6f5a4"}, "downloads": -1, "filename": "aioriemann-1.0.0a1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "10ed003afe2929df987716a724d32828", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 13162, "upload_time": "2016-11-03T14:45:54", "upload_time_iso_8601": "2016-11-03T14:45:54.086138Z", "url": "https://files.pythonhosted.org/packages/86/43/635599db26b1463ced75841bc96cda05428acfdb572b37ac2a0acd35002a/aioriemann-1.0.0a1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e201afc8be9f3ce9734fb0641d9b608a", "sha256": "22f16dfbb12d9d751ccd32f324db45f12617c49162cd1a9c3a1528470e42a030"}, "downloads": -1, "filename": "aioriemann-1.0.0a1.tar.gz", "has_sig": false, "md5_digest": "e201afc8be9f3ce9734fb0641d9b608a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24436, "upload_time": "2016-11-03T14:45:56", "upload_time_iso_8601": "2016-11-03T14:45:56.223522Z", "url": "https://files.pythonhosted.org/packages/65/0e/c5bc159ba1358088cbd82ec7a27c0b2384d259ed8e6f4334c4118915269a/aioriemann-1.0.0a1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:20:51 2020"}