{"info": {"author": "Jochen Weber", "author_email": "weberj3@mskcc.org", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# isic-archive (ISIC Archive access python module)\nThe [ISIC Archive](https://www.isic-archive.com/) is an online repository and\narchive published and maintained by the International Skin Imaging\nCollaboration. Next to the human-readable and browsable website, it also\nprovides a publicly available [API](https://isic-archive.com/api/v1), which\noffers several functions (called endpoints) for interacting with the data\nprogrammatically.\n\nThe present python package is an attempt at bundling the more frequently used\nfunctionality into a single module, thus reducing the need to re-write certain\ncode for a diverse set of projects.\n\n## First steps\nTo start with, please import the ```IsicApi``` class from the ```isicarchive```\nmodule and create an instance of the class:\n\n~~~~\nfrom isicarchive import IsicApi\napi = IsicApi()\n~~~~\n\n### Data availability\nAll general features are available without logging into the API. However,\nsince many datasets (and with them their images) as well as studies are not\nmarked as being \"publicly available\", the number of items returned by\nmany functions (endpoints) differ based on whether you have successfully\nauthenticated with the API. If you do not plan to register a username, you\ncan skip the next section, and either set the ```username``` parameter to\n```None``` or skip it altogether in the call to ```IsicApi```.\n\n### Logging into the ISIC Archive\nFor instance, some annotations created by study participants, or retrieving\ncertain images that are not marked for public access requires that you are\nlogged into the archive/API. This can be achieved by instantiating the\n```IsicApi``` object with a valid username (and password):\n\n~~~~\n# set username\nusername = 'address@provider.com'\n\n# create API object\napi = IsicApi(username)\n\n# or, if you can securely store a password as well\napi = IsicApi(username, password)\n~~~~\n\n**Please do *not* enter the password in clear text into your source code**. If\nyou provide only the username, the password will be requested from either the\nconsole or, if used in a Jupyter notebook, below the active cell using the\n```getpass``` library.\n\n### Local cache folder\nSince a lot of the data that can be retrieved from the archive (API) is\nrelatively static--that is, it will not change between uses of the API--you\ncan keep a locally cached copy, which will speed up processing of data on\nthe next call you use the same image or annotation, for instance. To do so,\nplease add the ```cache_folder``` parameter to the call, like so:\n\n~~~~\n# For Linux/Mac\ncache_folder = '/some/local/folder'\n# For Windows\ncache_folder = 'C:\\\\Users\\\\username\\\\some\\\\local\\\\folder' # use double \\\\ !\n\n# Create object\napi = IsicApi(cache_folder=cache_folder)\n# or\napi = IsicApi(username, cache_folder=cache_folder)\n# or\napi = IsicApi(username, password, cache_folder=cache_folder)\n~~~~\n\nRelatively large and complex data (annotations, images, etc.) will have a\nstored local copy, which means that they can be retrieved later from the\ncache, instead of having to request them again from the web-based API.\n\nWithin the cache folder the ```IsicApi``` object will, on first use,\ncreate 16 subfolders, named ```0``` through ```9```, and ```a``` through\n```f``` (the 16 hexadecimal digits), to avoid downloading too many files\ninto a single folder, which would slow down the operation later on. For each\nfile, the sub-folder is determined by the last hexadecimal digit of the\nunique object ID (explained below).\n\nImages are stored with a filename pattern of ```image_[objectId]_[name].ext```\nwhereas ```objectId``` is the unique ID for this image within the archive,\n```name``` is the filename (typically ```ISIC_xxxxxxx```), and ```.ext``` is\nthe extension as provided by the Content-Type header of the downloaded image.\n\nSuperpixel images (also explained below) are stored with the filename pattern\nof ```spimg_[objectId].png``` using the associated image's object ID! In\naddition, a derived superpixel index array is stored with a filename pattern\nof ```spidx_[objectID].npz``` (using ```numpy.savez```).\n\n### Caching information about all images\nSince the archive contains several thousand images, it can often be helpful\nto be able to search for specific images. To do so locally, you can download\nthe details about all images available in the archive (if you're) calling\nthe ```IsicApi``` object with the cache_folder parameter) like so:\n\n~~~~\n# Populate image cache\napi.cache_images()\n\n# display information about image ISIC_000000 (by its ID) from the cache\nimage_info = api.image_cache[api.images['ISIC_0000000']]\nprint(image_info)\n~~~~\n\nWhen called for the first time, building the cache may take several minutes.\nOnce the information is downloaded, however, only a single call will be made to\nthe web-based API to confirm that, indeed, no new images are available. **For\nthis to work, however, it is important that you do not use the same\ncache folder for sessions where you are either logged in (authenticated)\nversus not!** The cache file itself will be stored in the file named\n```[cache_folder]/0/imcache_000000000000000000000000.json.gz```.\n\nFinally, feature annotations associated with a specific study can be\ndownloaded in bulk and cached using this syntax:\n\n~~~~\n# Load annotation markup feature superpixel arrays\nstudy.load_annotations()\n~~~~\n\nThe resulting file will be stored in ```stann_[objectId].json.gz```, and not\nfor each annotation object separately, so that loading will be much faster.\n\n## Some more details on the web-based API\nAny interaction with the web-based API is performed by the ```IsicApi```\nobject through the HTTPS protocol, using the\n[requests](https://2.python-requests.org/en/master/) package methods. As part\nof the requests made, the endpoint (function and type of element being\ninteracted with) is specified, and one or several parameters can be set,\nwhich are appended to the URL. For instance, retrieving information about\none specific image would be achieved by accessing the following URL:\n\n```https://isic-archive.com/api/v1/image/5436e3abbae478396759f0cf```\n\n### Object IDs and element representation\nThis last portion of the URL that appears after the ```image/``` part is\ncalled the (object) id, and is a system-wide unique value that identifies\neach element to ensure that one interacts only with the intended target. The\noutput of the URL above is (slightly truncated for brevity):\n\n~~~~\n{\n  \"_id\": \"5436e3abbae478396759f0cf\",\n  \"_modelType\": \"image\",\n  \"created\": \"2014-10-09T19:36:11.989000+00:00\",\n  \"creator\": {\n    \"_id\": \"5450e996bae47865794e4d0d\",\n    \"name\": \"User 6VSN\"\n  },\n  \"dataset\": {\n    \"_accessLevel\": 0,\n    \"_id\": \"5a2ecc5e1165975c945942a2\",\n    \"description\": \"Moles and melanomas.\",\n    \"license\": \"CC-0\",\n    \"name\": \"UDA-1\",\n    \"updated\": \"2014-11-10T02:39:56.492000+00:00\"\n  },\n  \"meta\": {\n    \"acquisition\": {\n      \"image_type\": \"dermoscopic\",\n      \"pixelsX\": 1022,\n      \"pixelsY\": 767\n    },\n    \"clinical\": {\n      \"age_approx\": 55,\n      \"anatom_site_general\": \"anterior torso\",\n      \"benign_malignant\": \"benign\",\n      \"diagnosis\": \"nevus\",\n      \"diagnosis_confirm_type\": null,\n      \"melanocytic\": true,\n      \"sex\": \"female\"\n    }\n  },\n  \"name\": \"ISIC_0000000\",\n  \"updated\": \"2015-02-23T02:48:17.495000+00:00\"\n}\n~~~~\n\nPretty much all elements available through the API are returned in the form of\ntheir [JSON](https://en.wikipedia.org/wiki/JSON) representation (notation) as\ntext. Lists of elements are returned as arrays. The exception are binary blobs\n(such as image data, superpixel image data, and mask images).\n\nWithin the ISIC archive (and thus for the API), the following elements are\nrecognized:\n\n- **images** (having both a JSON and several associated binary blob elements)\n- **segmentations** (also having a JSON and a binary mask image component)\n- **datasets** (collection of images)\n- **studies** (selection of images from multiple datasets, together with questions and features to be annotated by users)\n- **annotations** (responses to questions and image-based per-feature annotation as a selection of \"superpixels\")\n- **users** (information about each registered user)\n- **tasks** (information about tasks assigned to the logged in user)\n\nOf these, currently accessible via the ```IsicApi``` object are **image, study,\ndataset, and annotation**.\n\n### Image superpixels\nAs part of the image processing capabilities of the ISIC Archive itself, each\nimage that is uploaded will be automatically compartmentalized into about 1,000\npatches of roughly equal size. E.g. for an image with a 4-by-3 aspect ratio,\nthere would be roughly 36 times 27 superpixels. The superpixel information is\nstored in a specifically RGB-encoded image, such that for each superpixel the\npatch has a (for the computer uniquely represented) RGB color code:\n\n![ISIC_0000000 image superpixels](data/ISIC_0000000_superpixels_demo.png?raw=true \"Superpixel demonstration\")\n\nThe ```IsicApi.image.Image``` class contains functions to decode and map this\nimage first into an index array, and then into a mapping array:\n\n~~~~\nfrom isicarchive import IsicApi\n\n# load superpixel image for first image\napi = IsicApi()\nimage = api.image('ISIC_0000000')\nimage.load_superpixels()\nsuperpixel_index_image = image.superpixels['idx']\nimage.map_superpixels()\nsuperpixel_mapping = image.superpixels['map']\n~~~~\n\nThis mapping array can be used to rapidly access (e.g. extract or paint over)\nthe pixels in the actual color image of a skin lesion:\n\n~~~~\n# paint over superpixel with index 472 in an image with red (RGB=(255,0,0))\nimage = api.image('ISIC_0000000')\nimage.load_imagedata()\nimage.load_superpixels()\nimage.map_superpixels()\nimage_data = image.data\nimage_shape = image_data.shape\nimage_data.shape = (image_shape[0] * image_shape[1], -1)\nmap = image.superpixels['map']\nsuperpixel_index = 472\npixel_count = map[superpixel_index, -1]\nsuperpixel_pixels = map[superpixel_index, 0:pixel_count]\nimage_data[superpixel_pixels, 0] = 255\nimage_data[superpixel_pixels, 1] = 0\nimage_data[superpixel_pixels, 2] = 0\nimage_data.shape = image_shape\n\n# show image\nimport matplotlib.pyplot as plt\nplt.imshow(image_data)\nplt.show()\n~~~~\n\n### Retrieving information about a study\nThe syntax below will make a call to the web-based API, and retrieve the\ninformation about the study named in ```study_name```. If the study is not\nfound, an exception is raised! Other than the web-based API (which does\nnot support names), you do not have to look up the object ID manually first.\nThe returned value, ```study``` is an object of type ```isicarchive.Study```,\nwhich provides some additional methods.\n\n~~~~\n# Retrieve study object\nstudy = api.study('ISBI 2016: 100 Lesion Classification')\n\n# Download all accessible images and superpixel images for this study\nstudy.cache_imagedata()\n\n# Print study features\nstudy.load_annotations()\nprint(study.features)\n~~~~\n\nIn addition to the information regularly provided by the ISIC Archive API,\nthe IsicApi object's implementation can also attempt to mass-download\ninformation about all annotations.\n\n### Retrieving information about a dataset\n~~~~\ndataset = api.dataset(dataset_name)\n~~~~\n\nSimilarly to a study, this will create an object of type\n```isicarchive.Dataset```, which allows additional methods to be called.\n\nIn addition to the information regularly provided by the ISIC Archive API,\nthe IsicApi object's implementation will also attempt to already download\ninformation about the access list, metadata, and images up for review.\n\n### Retrieving images\n~~~~\n# Load the first image of the loaded study\nimage = api.image(study.images[0])\n~~~~\n\nThis will, initially, only load the information about the image. If you would\nlike to make the binary data available, please use the following methods:\n\n~~~~\n# Load image data\nimage.load_imagedata()\n\n# Load superpixel image data\nimage.load_superpixels()\n\n# Parse superpixels into a mapping-to-pixel-indices array\nimage.map_superpixels()\n~~~~\n\nThe mapping of an image takes a second or so, but storing the map in a\ndifferent format would be relatively wasteful, and so this seems preferable.\n\n### Selecting images\nThe ```IsicApi``` object allows to select images based on the contents of\nany subfield in the image details (JSON) representation:\n\n~~~~\n# Make initial selection\nselection = api.select_images([\n    ['meta.acquisition.pixelsX', '>=', 2048],\n    ['meta.acquisition.image_type', '==', 'dermoscopic'],\n    ['meta.clinical.diagnosis', '!=', 'nevus'],\n])\n\n# refine selection (you can inspect the results after each step)\nselection = api.select_images(['dataset._accessLevel', '==', 0], sub_select=True)\nselection = api.select_images(['notes.tags', 'ni', 'ISBI 2017: Training'], sub_select=True)\nselection = api.select_images(['meta.unstructured.biopsy done', '==', 'Y'], sub_select=True)\nselection = api.select_images(['meta.clinical.melanocytic', 'is', True], sub_select=True)\n~~~~\nThe selection will both be returned, and also stored in the\n```api.image_selection``` field. So, in a Jupyter notebook, please assign the\nresult to a variable if it is the last statement in a cell and you wish not\nto print the output!\n\n## Housekeeping\nThis section contains information about the package.\n\n### Author information\n```isicarchive``` is being developed by Jochen Weber, who works at Memorial\nSloan Kettering Cancer Center in New York City. He is supported by Nick\nKurtansky and Dr. Konstantinos Liopyris (both MSKCC as well) and collaborates\nclosely with Brian Helba and Dan LaManna (both with\n[Kitware](https://www.kitware.com)), who work on the web-based API.\n\n### History\n- 8/21/2019\n  - began refactoring test code (with unit testing)\n  - added ```api.select_images(...)``` to select images from the entire archive\n  - added ```func.selected(...)``` and ```func.select_from(...)``` for selection logic\n  - improved ```func``` module with better Typing hints (and general cleanup)\n  - added ```func.write_image(...)``` to write out images, including into a buffer\n  - moved code from ```Annotation.show_in_notebook(...)``` to ```func.color_superpixels(...)```\n- 8/20/2019\n  - added ```func.print_progress(...)``` function (text-based progress bar)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/neuroelf/isicarchive", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "isicarchive", "package_url": "https://pypi.org/project/isicarchive/", "platform": "", "project_url": "https://pypi.org/project/isicarchive/", "project_urls": {"Homepage": "https://github.com/neuroelf/isicarchive"}, "release_url": "https://pypi.org/project/isicarchive/0.4.7/", "requires_dist": ["imageio (>=2.5.0)", "ipython (>=7.1.0)", "matplotlib (>=3.1.0)", "numba (>=0.45.1)", "numpy (>=1.16.2)", "requests (>=2.22.0)"], "requires_python": ">=3.6", "summary": "ISIC Archive API", "version": "0.4.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>isic-archive (ISIC Archive access python module)</h1>\n<p>The <a href=\"https://www.isic-archive.com/\" rel=\"nofollow\">ISIC Archive</a> is an online repository and\narchive published and maintained by the International Skin Imaging\nCollaboration. Next to the human-readable and browsable website, it also\nprovides a publicly available <a href=\"https://isic-archive.com/api/v1\" rel=\"nofollow\">API</a>, which\noffers several functions (called endpoints) for interacting with the data\nprogrammatically.</p>\n<p>The present python package is an attempt at bundling the more frequently used\nfunctionality into a single module, thus reducing the need to re-write certain\ncode for a diverse set of projects.</p>\n<h2>First steps</h2>\n<p>To start with, please import the <code>IsicApi</code> class from the <code>isicarchive</code>\nmodule and create an instance of the class:</p>\n<pre><code>from isicarchive import IsicApi\napi = IsicApi()\n</code></pre>\n<h3>Data availability</h3>\n<p>All general features are available without logging into the API. However,\nsince many datasets (and with them their images) as well as studies are not\nmarked as being \"publicly available\", the number of items returned by\nmany functions (endpoints) differ based on whether you have successfully\nauthenticated with the API. If you do not plan to register a username, you\ncan skip the next section, and either set the <code>username</code> parameter to\n<code>None</code> or skip it altogether in the call to <code>IsicApi</code>.</p>\n<h3>Logging into the ISIC Archive</h3>\n<p>For instance, some annotations created by study participants, or retrieving\ncertain images that are not marked for public access requires that you are\nlogged into the archive/API. This can be achieved by instantiating the\n<code>IsicApi</code> object with a valid username (and password):</p>\n<pre><code># set username\nusername = 'address@provider.com'\n\n# create API object\napi = IsicApi(username)\n\n# or, if you can securely store a password as well\napi = IsicApi(username, password)\n</code></pre>\n<p><strong>Please do <em>not</em> enter the password in clear text into your source code</strong>. If\nyou provide only the username, the password will be requested from either the\nconsole or, if used in a Jupyter notebook, below the active cell using the\n<code>getpass</code> library.</p>\n<h3>Local cache folder</h3>\n<p>Since a lot of the data that can be retrieved from the archive (API) is\nrelatively static--that is, it will not change between uses of the API--you\ncan keep a locally cached copy, which will speed up processing of data on\nthe next call you use the same image or annotation, for instance. To do so,\nplease add the <code>cache_folder</code> parameter to the call, like so:</p>\n<pre><code># For Linux/Mac\ncache_folder = '/some/local/folder'\n# For Windows\ncache_folder = 'C:\\\\Users\\\\username\\\\some\\\\local\\\\folder' # use double \\\\ !\n\n# Create object\napi = IsicApi(cache_folder=cache_folder)\n# or\napi = IsicApi(username, cache_folder=cache_folder)\n# or\napi = IsicApi(username, password, cache_folder=cache_folder)\n</code></pre>\n<p>Relatively large and complex data (annotations, images, etc.) will have a\nstored local copy, which means that they can be retrieved later from the\ncache, instead of having to request them again from the web-based API.</p>\n<p>Within the cache folder the <code>IsicApi</code> object will, on first use,\ncreate 16 subfolders, named <code>0</code> through <code>9</code>, and <code>a</code> through\n<code>f</code> (the 16 hexadecimal digits), to avoid downloading too many files\ninto a single folder, which would slow down the operation later on. For each\nfile, the sub-folder is determined by the last hexadecimal digit of the\nunique object ID (explained below).</p>\n<p>Images are stored with a filename pattern of <code>image_[objectId]_[name].ext</code>\nwhereas <code>objectId</code> is the unique ID for this image within the archive,\n<code>name</code> is the filename (typically <code>ISIC_xxxxxxx</code>), and <code>.ext</code> is\nthe extension as provided by the Content-Type header of the downloaded image.</p>\n<p>Superpixel images (also explained below) are stored with the filename pattern\nof <code>spimg_[objectId].png</code> using the associated image's object ID! In\naddition, a derived superpixel index array is stored with a filename pattern\nof <code>spidx_[objectID].npz</code> (using <code>numpy.savez</code>).</p>\n<h3>Caching information about all images</h3>\n<p>Since the archive contains several thousand images, it can often be helpful\nto be able to search for specific images. To do so locally, you can download\nthe details about all images available in the archive (if you're) calling\nthe <code>IsicApi</code> object with the cache_folder parameter) like so:</p>\n<pre><code># Populate image cache\napi.cache_images()\n\n# display information about image ISIC_000000 (by its ID) from the cache\nimage_info = api.image_cache[api.images['ISIC_0000000']]\nprint(image_info)\n</code></pre>\n<p>When called for the first time, building the cache may take several minutes.\nOnce the information is downloaded, however, only a single call will be made to\nthe web-based API to confirm that, indeed, no new images are available. <strong>For\nthis to work, however, it is important that you do not use the same\ncache folder for sessions where you are either logged in (authenticated)\nversus not!</strong> The cache file itself will be stored in the file named\n<code>[cache_folder]/0/imcache_000000000000000000000000.json.gz</code>.</p>\n<p>Finally, feature annotations associated with a specific study can be\ndownloaded in bulk and cached using this syntax:</p>\n<pre><code># Load annotation markup feature superpixel arrays\nstudy.load_annotations()\n</code></pre>\n<p>The resulting file will be stored in <code>stann_[objectId].json.gz</code>, and not\nfor each annotation object separately, so that loading will be much faster.</p>\n<h2>Some more details on the web-based API</h2>\n<p>Any interaction with the web-based API is performed by the <code>IsicApi</code>\nobject through the HTTPS protocol, using the\n<a href=\"https://2.python-requests.org/en/master/\" rel=\"nofollow\">requests</a> package methods. As part\nof the requests made, the endpoint (function and type of element being\ninteracted with) is specified, and one or several parameters can be set,\nwhich are appended to the URL. For instance, retrieving information about\none specific image would be achieved by accessing the following URL:</p>\n<p><code>https://isic-archive.com/api/v1/image/5436e3abbae478396759f0cf</code></p>\n<h3>Object IDs and element representation</h3>\n<p>This last portion of the URL that appears after the <code>image/</code> part is\ncalled the (object) id, and is a system-wide unique value that identifies\neach element to ensure that one interacts only with the intended target. The\noutput of the URL above is (slightly truncated for brevity):</p>\n<pre><code>{\n  \"_id\": \"5436e3abbae478396759f0cf\",\n  \"_modelType\": \"image\",\n  \"created\": \"2014-10-09T19:36:11.989000+00:00\",\n  \"creator\": {\n    \"_id\": \"5450e996bae47865794e4d0d\",\n    \"name\": \"User 6VSN\"\n  },\n  \"dataset\": {\n    \"_accessLevel\": 0,\n    \"_id\": \"5a2ecc5e1165975c945942a2\",\n    \"description\": \"Moles and melanomas.\",\n    \"license\": \"CC-0\",\n    \"name\": \"UDA-1\",\n    \"updated\": \"2014-11-10T02:39:56.492000+00:00\"\n  },\n  \"meta\": {\n    \"acquisition\": {\n      \"image_type\": \"dermoscopic\",\n      \"pixelsX\": 1022,\n      \"pixelsY\": 767\n    },\n    \"clinical\": {\n      \"age_approx\": 55,\n      \"anatom_site_general\": \"anterior torso\",\n      \"benign_malignant\": \"benign\",\n      \"diagnosis\": \"nevus\",\n      \"diagnosis_confirm_type\": null,\n      \"melanocytic\": true,\n      \"sex\": \"female\"\n    }\n  },\n  \"name\": \"ISIC_0000000\",\n  \"updated\": \"2015-02-23T02:48:17.495000+00:00\"\n}\n</code></pre>\n<p>Pretty much all elements available through the API are returned in the form of\ntheir <a href=\"https://en.wikipedia.org/wiki/JSON\" rel=\"nofollow\">JSON</a> representation (notation) as\ntext. Lists of elements are returned as arrays. The exception are binary blobs\n(such as image data, superpixel image data, and mask images).</p>\n<p>Within the ISIC archive (and thus for the API), the following elements are\nrecognized:</p>\n<ul>\n<li><strong>images</strong> (having both a JSON and several associated binary blob elements)</li>\n<li><strong>segmentations</strong> (also having a JSON and a binary mask image component)</li>\n<li><strong>datasets</strong> (collection of images)</li>\n<li><strong>studies</strong> (selection of images from multiple datasets, together with questions and features to be annotated by users)</li>\n<li><strong>annotations</strong> (responses to questions and image-based per-feature annotation as a selection of \"superpixels\")</li>\n<li><strong>users</strong> (information about each registered user)</li>\n<li><strong>tasks</strong> (information about tasks assigned to the logged in user)</li>\n</ul>\n<p>Of these, currently accessible via the <code>IsicApi</code> object are <strong>image, study,\ndataset, and annotation</strong>.</p>\n<h3>Image superpixels</h3>\n<p>As part of the image processing capabilities of the ISIC Archive itself, each\nimage that is uploaded will be automatically compartmentalized into about 1,000\npatches of roughly equal size. E.g. for an image with a 4-by-3 aspect ratio,\nthere would be roughly 36 times 27 superpixels. The superpixel information is\nstored in a specifically RGB-encoded image, such that for each superpixel the\npatch has a (for the computer uniquely represented) RGB color code:</p>\n<p><img alt=\"ISIC_0000000 image superpixels\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/aea5ec2ee225f5f903b5128f9839647358eefafa/646174612f495349435f303030303030305f7375706572706978656c735f64656d6f2e706e673f7261773d74727565\"></p>\n<p>The <code>IsicApi.image.Image</code> class contains functions to decode and map this\nimage first into an index array, and then into a mapping array:</p>\n<pre><code>from isicarchive import IsicApi\n\n# load superpixel image for first image\napi = IsicApi()\nimage = api.image('ISIC_0000000')\nimage.load_superpixels()\nsuperpixel_index_image = image.superpixels['idx']\nimage.map_superpixels()\nsuperpixel_mapping = image.superpixels['map']\n</code></pre>\n<p>This mapping array can be used to rapidly access (e.g. extract or paint over)\nthe pixels in the actual color image of a skin lesion:</p>\n<pre><code># paint over superpixel with index 472 in an image with red (RGB=(255,0,0))\nimage = api.image('ISIC_0000000')\nimage.load_imagedata()\nimage.load_superpixels()\nimage.map_superpixels()\nimage_data = image.data\nimage_shape = image_data.shape\nimage_data.shape = (image_shape[0] * image_shape[1], -1)\nmap = image.superpixels['map']\nsuperpixel_index = 472\npixel_count = map[superpixel_index, -1]\nsuperpixel_pixels = map[superpixel_index, 0:pixel_count]\nimage_data[superpixel_pixels, 0] = 255\nimage_data[superpixel_pixels, 1] = 0\nimage_data[superpixel_pixels, 2] = 0\nimage_data.shape = image_shape\n\n# show image\nimport matplotlib.pyplot as plt\nplt.imshow(image_data)\nplt.show()\n</code></pre>\n<h3>Retrieving information about a study</h3>\n<p>The syntax below will make a call to the web-based API, and retrieve the\ninformation about the study named in <code>study_name</code>. If the study is not\nfound, an exception is raised! Other than the web-based API (which does\nnot support names), you do not have to look up the object ID manually first.\nThe returned value, <code>study</code> is an object of type <code>isicarchive.Study</code>,\nwhich provides some additional methods.</p>\n<pre><code># Retrieve study object\nstudy = api.study('ISBI 2016: 100 Lesion Classification')\n\n# Download all accessible images and superpixel images for this study\nstudy.cache_imagedata()\n\n# Print study features\nstudy.load_annotations()\nprint(study.features)\n</code></pre>\n<p>In addition to the information regularly provided by the ISIC Archive API,\nthe IsicApi object's implementation can also attempt to mass-download\ninformation about all annotations.</p>\n<h3>Retrieving information about a dataset</h3>\n<pre><code>dataset = api.dataset(dataset_name)\n</code></pre>\n<p>Similarly to a study, this will create an object of type\n<code>isicarchive.Dataset</code>, which allows additional methods to be called.</p>\n<p>In addition to the information regularly provided by the ISIC Archive API,\nthe IsicApi object's implementation will also attempt to already download\ninformation about the access list, metadata, and images up for review.</p>\n<h3>Retrieving images</h3>\n<pre><code># Load the first image of the loaded study\nimage = api.image(study.images[0])\n</code></pre>\n<p>This will, initially, only load the information about the image. If you would\nlike to make the binary data available, please use the following methods:</p>\n<pre><code># Load image data\nimage.load_imagedata()\n\n# Load superpixel image data\nimage.load_superpixels()\n\n# Parse superpixels into a mapping-to-pixel-indices array\nimage.map_superpixels()\n</code></pre>\n<p>The mapping of an image takes a second or so, but storing the map in a\ndifferent format would be relatively wasteful, and so this seems preferable.</p>\n<h3>Selecting images</h3>\n<p>The <code>IsicApi</code> object allows to select images based on the contents of\nany subfield in the image details (JSON) representation:</p>\n<pre><code># Make initial selection\nselection = api.select_images([\n    ['meta.acquisition.pixelsX', '&gt;=', 2048],\n    ['meta.acquisition.image_type', '==', 'dermoscopic'],\n    ['meta.clinical.diagnosis', '!=', 'nevus'],\n])\n\n# refine selection (you can inspect the results after each step)\nselection = api.select_images(['dataset._accessLevel', '==', 0], sub_select=True)\nselection = api.select_images(['notes.tags', 'ni', 'ISBI 2017: Training'], sub_select=True)\nselection = api.select_images(['meta.unstructured.biopsy done', '==', 'Y'], sub_select=True)\nselection = api.select_images(['meta.clinical.melanocytic', 'is', True], sub_select=True)\n</code></pre>\n<p>The selection will both be returned, and also stored in the\n<code>api.image_selection</code> field. So, in a Jupyter notebook, please assign the\nresult to a variable if it is the last statement in a cell and you wish not\nto print the output!</p>\n<h2>Housekeeping</h2>\n<p>This section contains information about the package.</p>\n<h3>Author information</h3>\n<p><code>isicarchive</code> is being developed by Jochen Weber, who works at Memorial\nSloan Kettering Cancer Center in New York City. He is supported by Nick\nKurtansky and Dr. Konstantinos Liopyris (both MSKCC as well) and collaborates\nclosely with Brian Helba and Dan LaManna (both with\n<a href=\"https://www.kitware.com\" rel=\"nofollow\">Kitware</a>), who work on the web-based API.</p>\n<h3>History</h3>\n<ul>\n<li>8/21/2019\n<ul>\n<li>began refactoring test code (with unit testing)</li>\n<li>added <code>api.select_images(...)</code> to select images from the entire archive</li>\n<li>added <code>func.selected(...)</code> and <code>func.select_from(...)</code> for selection logic</li>\n<li>improved <code>func</code> module with better Typing hints (and general cleanup)</li>\n<li>added <code>func.write_image(...)</code> to write out images, including into a buffer</li>\n<li>moved code from <code>Annotation.show_in_notebook(...)</code> to <code>func.color_superpixels(...)</code></li>\n</ul>\n</li>\n<li>8/20/2019\n<ul>\n<li>added <code>func.print_progress(...)</code> function (text-based progress bar)</li>\n</ul>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 5712424, "releases": {"0.2.0": [{"comment_text": "", "digests": {"md5": "f91377a817656417b97e43b284d6356e", "sha256": "0d3ae28586e06f409562e08ccec81c1e7c64c9d2a2fa939151018a2539c937d1"}, "downloads": -1, "filename": "isicarchive-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "f91377a817656417b97e43b284d6356e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19471, "upload_time": "2019-08-15T00:55:15", "upload_time_iso_8601": "2019-08-15T00:55:15.970822Z", "url": "https://files.pythonhosted.org/packages/fd/ad/7d92722e7ccbc1ae25c6d5513d91c02c9100a483253e14afb56ff3bc187f/isicarchive-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0f96875fc6b3ce9d96ed8ca1e8f1e2b6", "sha256": "faa4633394e4bb35ba1a90585dd415fa87f8f8999de75154844f20a88b3d7328"}, "downloads": -1, "filename": "isicarchive-0.2.0.tar.gz", "has_sig": false, "md5_digest": "0f96875fc6b3ce9d96ed8ca1e8f1e2b6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 15561, "upload_time": "2019-08-15T00:55:17", "upload_time_iso_8601": "2019-08-15T00:55:17.819151Z", "url": "https://files.pythonhosted.org/packages/d4/3b/9f32bf6d12213aff65d94d73ed4a05fd94b9b82e082b1763fd6b3da8c1ec/isicarchive-0.2.0.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "7966b818e0b83a5d7ecda0fde1811523", "sha256": "75cff97af6a427826b667f4e6f743e4d16ed7c27bf671288e8bf6c4dc4a6b714"}, "downloads": -1, "filename": "isicarchive-0.2.3-py3-none-any.whl", "has_sig": false, "md5_digest": "7966b818e0b83a5d7ecda0fde1811523", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23101, "upload_time": "2019-08-15T18:54:48", "upload_time_iso_8601": "2019-08-15T18:54:48.053709Z", "url": "https://files.pythonhosted.org/packages/5c/6c/c44879726edcfe291eb58a1063a776c4e3740a63506a98576109a2ebc20d/isicarchive-0.2.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "688abf8c1613a18b906564ba2779ff0f", "sha256": "715c26ba7f81c61b9f542ccd2c3c7f604907bbf1f2018b0218434da27cd05d7a"}, "downloads": -1, "filename": "isicarchive-0.2.3.tar.gz", "has_sig": false, "md5_digest": "688abf8c1613a18b906564ba2779ff0f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 18579, "upload_time": "2019-08-15T18:54:49", "upload_time_iso_8601": "2019-08-15T18:54:49.178668Z", "url": "https://files.pythonhosted.org/packages/87/c5/da39e302f4ac4542d0817ab35ebe2f23badb5346e6fe044e994723aad171/isicarchive-0.2.3.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "5b24b989eead2a6d3b916e8aba11aa5d", "sha256": "e39f016934a78b887cc4975c642c367c7a3a6b11ef329ca07dc5ca9b303d4ec3"}, "downloads": -1, "filename": "isicarchive-0.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "5b24b989eead2a6d3b916e8aba11aa5d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23355, "upload_time": "2019-08-17T22:26:06", "upload_time_iso_8601": "2019-08-17T22:26:06.416570Z", "url": "https://files.pythonhosted.org/packages/42/64/cbf4242271885f109682d206d3e0828b71c906c85a53a3b9966bc62b93be/isicarchive-0.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "74b98c273aac993cf5e35eedf7fb92e0", "sha256": "8565676b50534ce0f56375118b103524178c5a506feb0646b8bdf18696901def"}, "downloads": -1, "filename": "isicarchive-0.3.0.tar.gz", "has_sig": false, "md5_digest": "74b98c273aac993cf5e35eedf7fb92e0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 18543, "upload_time": "2019-08-17T22:26:07", "upload_time_iso_8601": "2019-08-17T22:26:07.877739Z", "url": "https://files.pythonhosted.org/packages/3e/fc/840f309e01fd72808dac200abd67f376aa49b0ccb73c4a5b1fe7d1e8fa17/isicarchive-0.3.0.tar.gz", "yanked": false}], "0.3.5": [{"comment_text": "", "digests": {"md5": "00838241b6df94916ebd88cd4da36b66", "sha256": "cc1b4a0ad927d32e8632fcb74bbc4320e6725f79deb6cfef552e8fcc71590e32"}, "downloads": -1, "filename": "isicarchive-0.3.5-py3-none-any.whl", "has_sig": false, "md5_digest": "00838241b6df94916ebd88cd4da36b66", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 25969, "upload_time": "2019-08-18T23:26:53", "upload_time_iso_8601": "2019-08-18T23:26:53.387065Z", "url": "https://files.pythonhosted.org/packages/8c/43/8e02d355cb3796b811ad0319c5f916622f2382b1081ac2983b9ecd404259/isicarchive-0.3.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "26b2cf4cc86856c6781926ce7c31d287", "sha256": "6b1faa66a3b2721ebcbbe2ccae18573a6129e58151b0ee85a6d330e868a27c5d"}, "downloads": -1, "filename": "isicarchive-0.3.5.tar.gz", "has_sig": false, "md5_digest": "26b2cf4cc86856c6781926ce7c31d287", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 20942, "upload_time": "2019-08-18T23:26:55", "upload_time_iso_8601": "2019-08-18T23:26:55.005756Z", "url": "https://files.pythonhosted.org/packages/1c/d6/09218947eb438c6079d7030987963e914aa61e4f5063129483a713454a1a/isicarchive-0.3.5.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "0df84c62e5f654c461fc2f86356a3f61", "sha256": "b99685bc7e574e03733dfefd4293b722156806f2f07830a73d7e6e7fc0b03b7a"}, "downloads": -1, "filename": "isicarchive-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0df84c62e5f654c461fc2f86356a3f61", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 28609, "upload_time": "2019-08-19T21:52:55", "upload_time_iso_8601": "2019-08-19T21:52:55.492862Z", "url": "https://files.pythonhosted.org/packages/a3/f5/9c9f84fd8bdef0cf61bd95f139fbe5b61473d5033dab2cd2219a299c656c/isicarchive-0.4.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a71f21e0ee7168d6d80835106e2cda3d", "sha256": "fd66a2b8abc3cecb0b580e5e06d0f76416ca4221cd58b81e5528cef8eb5bc643"}, "downloads": -1, "filename": "isicarchive-0.4.0.tar.gz", "has_sig": false, "md5_digest": "a71f21e0ee7168d6d80835106e2cda3d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 23908, "upload_time": "2019-08-19T21:52:56", "upload_time_iso_8601": "2019-08-19T21:52:56.603010Z", "url": "https://files.pythonhosted.org/packages/fe/ad/4eeef33dd77740d9bbf347c315e180465f5c54b26bb49b40ef103f2687d7/isicarchive-0.4.0.tar.gz", "yanked": false}], "0.4.6": [{"comment_text": "", "digests": {"md5": "73d53d8d06b18057fb9736412f0863a2", "sha256": "1400d04421616b853fcaa69c3bc8e7e23e3ade30b0280da320be4c7ca305128e"}, "downloads": -1, "filename": "isicarchive-0.4.6-py3-none-any.whl", "has_sig": false, "md5_digest": "73d53d8d06b18057fb9736412f0863a2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 41201, "upload_time": "2019-08-21T23:57:17", "upload_time_iso_8601": "2019-08-21T23:57:17.661258Z", "url": "https://files.pythonhosted.org/packages/f2/10/2f178cf84227ad60d5931543d3f7ba0376e66309d99b92b9aeff88669f1b/isicarchive-0.4.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6b9f6ad07005cca012ee9cad0b18ba78", "sha256": "5793aa0a0c913159b4d20848059488793ac3dc13d92f82222948df5eca04fb37"}, "downloads": -1, "filename": "isicarchive-0.4.6.tar.gz", "has_sig": false, "md5_digest": "6b9f6ad07005cca012ee9cad0b18ba78", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 42263, "upload_time": "2019-08-21T23:57:19", "upload_time_iso_8601": "2019-08-21T23:57:19.634408Z", "url": "https://files.pythonhosted.org/packages/7f/63/75b058e5cf5eb8e7617ae45d801cd0b5ec141c2c5558c86daeb70bd21e3f/isicarchive-0.4.6.tar.gz", "yanked": false}], "0.4.7": [{"comment_text": "", "digests": {"md5": "e3e543f1ad0c8c5e917bbce4994019ef", "sha256": "e4fb2e28212dfc94860ab1ba209e06998c81b9c2ff1feb0682b75c0c303e69e8"}, "downloads": -1, "filename": "isicarchive-0.4.7-py3-none-any.whl", "has_sig": false, "md5_digest": "e3e543f1ad0c8c5e917bbce4994019ef", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 41393, "upload_time": "2019-08-22T00:07:06", "upload_time_iso_8601": "2019-08-22T00:07:06.418978Z", "url": "https://files.pythonhosted.org/packages/65/40/b750285d8460ee3ef31e565def94ef33c2092475935616a7dc5e990457c5/isicarchive-0.4.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9ef1aeea1ff8ac746d181f1a0202de6e", "sha256": "4bd7a16cef229ea9c01cfafae9888bc309ba36b58e0c158c146f2a9c2fe9bde6"}, "downloads": -1, "filename": "isicarchive-0.4.7.tar.gz", "has_sig": false, "md5_digest": "9ef1aeea1ff8ac746d181f1a0202de6e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 42355, "upload_time": "2019-08-22T00:07:08", "upload_time_iso_8601": "2019-08-22T00:07:08.215419Z", "url": "https://files.pythonhosted.org/packages/1a/a3/ab9b5d1739d9919b7ea5c0d7a483a4c2f7687531afe8305d71ea42e8285a/isicarchive-0.4.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e3e543f1ad0c8c5e917bbce4994019ef", "sha256": "e4fb2e28212dfc94860ab1ba209e06998c81b9c2ff1feb0682b75c0c303e69e8"}, "downloads": -1, "filename": "isicarchive-0.4.7-py3-none-any.whl", "has_sig": false, "md5_digest": "e3e543f1ad0c8c5e917bbce4994019ef", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 41393, "upload_time": "2019-08-22T00:07:06", "upload_time_iso_8601": "2019-08-22T00:07:06.418978Z", "url": "https://files.pythonhosted.org/packages/65/40/b750285d8460ee3ef31e565def94ef33c2092475935616a7dc5e990457c5/isicarchive-0.4.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9ef1aeea1ff8ac746d181f1a0202de6e", "sha256": "4bd7a16cef229ea9c01cfafae9888bc309ba36b58e0c158c146f2a9c2fe9bde6"}, "downloads": -1, "filename": "isicarchive-0.4.7.tar.gz", "has_sig": false, "md5_digest": "9ef1aeea1ff8ac746d181f1a0202de6e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 42355, "upload_time": "2019-08-22T00:07:08", "upload_time_iso_8601": "2019-08-22T00:07:08.215419Z", "url": "https://files.pythonhosted.org/packages/1a/a3/ab9b5d1739d9919b7ea5c0d7a483a4c2f7687531afe8305d71ea42e8285a/isicarchive-0.4.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:06 2020"}