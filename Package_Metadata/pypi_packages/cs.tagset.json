{"info": {"author": "Cameron Simpson", "author_email": "cs@cskk.id.au", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "*Latest release 20200318*:\n*Note that the TagsOntology stuff is in flux and totally alpha.*\nTag.prefix_name factory returning a new tag if prefix is not empty, ptherwise self.\nTagSet.update: accept an optional prefix for inserting \"foreign\" tags with a distinguishing name prefix.\nTag.as_json: turn sets and tuples into lists for encoding.\nBackport for Python < 3.7 (no fromisoformat functions).\nTagSet: drop unused and illplaced .titleify, .episode_title and .title methods.\nTagSet: remove \"defaults\", unused.\nMake TagSet a direct subclass of dict, adjust uses of .update etc.\nNew ExtendedNamespace class which is a SimpleNamespace with some inferred attributes and a partial mapping API (keys and __getitem__).\nNew TagSet.ns() returning the Tags as an ExtendedNamespace, which doubles as a mapping for str.format_map; TagSet.format_kwargs is now an alias for this.\nNew Tag.from_string factory to parse a str into a Tag.\nNew TagsOntology and TypedTag classes to provide type and value-detail information; very very alpha and subject to change.\n\nTags and sets of tags.\n\n## Class `ExtendedNamespace(types.SimpleNamespace)`\n\nSubclass `SimpleNamespace` with inferred attributes.\nThis also presents attributes as `[]` elements via `__getitem__`.\n\n## Class `Tag(Tag,builtins.tuple)`\n\nA Tag has a `.name` (`str`) and a `.value`.\n\nThe `name` must be a dotted identifier.\n\nA \"bare\" `Tag` has a `value` of `None`.\n\n## Class `TagChoice(TagChoice,builtins.tuple)`\n\nA \"tag choice\", an apply/reject flag and a `Tag`,\nused to apply changes to a `TagSet`\nor as a criterion for a tag search.\n\nAttributes:\n* `spec`: the source text from which this choice was parsed,\n  possibly `None`\n* `choice`: the apply/reject flag\n* `tag`: the `Tag` representing the criterion\n\n## Class `TagSet(builtins.dict,cs.lex.FormatableMixin)`\n\nA setlike class associating a set of tag names with values.\n\n### Method `TagSet.__init__(self)`\n\nInitialise the `TagSet`.\n\n## Class `TagsOntology(cs.obj.SingletonMixin)`\n\nAn ontology for tag names.\n\nThis is based around a mapping of tag names\nto ontological information expressed as a `TagSet`.\n\nA `cs.fstags.FSTags` uses ontologies initialised from `TagFile`s\ncontaining ontology mappings.\n\n## Class `TypedTag(cs.lex.FormatableMixin)`\n\nA `Tag`like object linked to a `TagOntology`,\nproviding associated detail about a `Tag`.\n\nLike `Tag`, this has a `.name` and `.value`.\n\nAdditionally it has the following attributes:\n* `ontology`: the supporting `TagOntology`\n* `tag`: the originating `Tag`\n  (computed from the `(name,value)` tuple if supplied)\n* `defn`: the `TagSet` from `.ontology`\n  which defines this\n* `type`: `defn['type']`\n* `member_type`: `defn['member_type']` if present;\n  we expect `type` to be a list or mapping type name\n\nIndexing a `TypedTag` indexes its `.value`\nand returns a tuple `(element,TagSet)`\nwhere the `TagSet` is information from the ontology\nabout the element's value (if `element` is a `str`).\n\nIf the `.value` looks like a mapping\n.ie. it has a `.keys()` method\nthen a `TypedTag` has `.keys()` and `.items()` methods.\nThe `.keys()` call returns `.value.keys()`.\nThe `.items()` call yields `(key,self[key])`\nfor each of `self.keys()`.\n\nIterating over a `TypedTag`\nyields its keys if it has a `.keys()` method,\notherwise values from `range(len(self.value))`.\n\n### Method `TypedTag.__init__(self, name, value=None, *, ontology)`\n\nPrepare the `TypedTag` from a `Tag` or `(name,value)` tuple.\n\n\n\n# Release Log\n\n*Release 20200318*:\n*Note that the TagsOntology stuff is in flux and totally alpha.*\nTag.prefix_name factory returning a new tag if prefix is not empty, ptherwise self.\nTagSet.update: accept an optional prefix for inserting \"foreign\" tags with a distinguishing name prefix.\nTag.as_json: turn sets and tuples into lists for encoding.\nBackport for Python < 3.7 (no fromisoformat functions).\nTagSet: drop unused and illplaced .titleify, .episode_title and .title methods.\nTagSet: remove \"defaults\", unused.\nMake TagSet a direct subclass of dict, adjust uses of .update etc.\nNew ExtendedNamespace class which is a SimpleNamespace with some inferred attributes and a partial mapping API (keys and __getitem__).\nNew TagSet.ns() returning the Tags as an ExtendedNamespace, which doubles as a mapping for str.format_map; TagSet.format_kwargs is now an alias for this.\nNew Tag.from_string factory to parse a str into a Tag.\nNew TagsOntology and TypedTag classes to provide type and value-detail information; very very alpha and subject to change.\n\n*Release 20200229.1*:\nInitial release: pull TagSet, Tag, TagChoice from cs.fstags for independent use.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/cameron_simpson/css/commits/all", "keywords": "python3", "license": "GNU General Public License v3 or later (GPLv3+)", "maintainer": "", "maintainer_email": "", "name": "cs.tagset", "package_url": "https://pypi.org/project/cs.tagset/", "platform": "", "project_url": "https://pypi.org/project/cs.tagset/", "project_urls": {"Homepage": "https://bitbucket.org/cameron_simpson/css/commits/all"}, "release_url": "https://pypi.org/project/cs.tagset/20200318/", "requires_dist": null, "requires_python": "", "summary": "Tags and sets of tags.", "version": "20200318", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><em>Latest release 20200318</em>:\n<em>Note that the TagsOntology stuff is in flux and totally alpha.</em>\nTag.prefix_name factory returning a new tag if prefix is not empty, ptherwise self.\nTagSet.update: accept an optional prefix for inserting \"foreign\" tags with a distinguishing name prefix.\nTag.as_json: turn sets and tuples into lists for encoding.\nBackport for Python &lt; 3.7 (no fromisoformat functions).\nTagSet: drop unused and illplaced .titleify, .episode_title and .title methods.\nTagSet: remove \"defaults\", unused.\nMake TagSet a direct subclass of dict, adjust uses of .update etc.\nNew ExtendedNamespace class which is a SimpleNamespace with some inferred attributes and a partial mapping API (keys and <strong>getitem</strong>).\nNew TagSet.ns() returning the Tags as an ExtendedNamespace, which doubles as a mapping for str.format_map; TagSet.format_kwargs is now an alias for this.\nNew Tag.from_string factory to parse a str into a Tag.\nNew TagsOntology and TypedTag classes to provide type and value-detail information; very very alpha and subject to change.</p>\n<p>Tags and sets of tags.</p>\n<h2>Class <code>ExtendedNamespace(types.SimpleNamespace)</code></h2>\n<p>Subclass <code>SimpleNamespace</code> with inferred attributes.\nThis also presents attributes as <code>[]</code> elements via <code>__getitem__</code>.</p>\n<h2>Class <code>Tag(Tag,builtins.tuple)</code></h2>\n<p>A Tag has a <code>.name</code> (<code>str</code>) and a <code>.value</code>.</p>\n<p>The <code>name</code> must be a dotted identifier.</p>\n<p>A \"bare\" <code>Tag</code> has a <code>value</code> of <code>None</code>.</p>\n<h2>Class <code>TagChoice(TagChoice,builtins.tuple)</code></h2>\n<p>A \"tag choice\", an apply/reject flag and a <code>Tag</code>,\nused to apply changes to a <code>TagSet</code>\nor as a criterion for a tag search.</p>\n<p>Attributes:</p>\n<ul>\n<li><code>spec</code>: the source text from which this choice was parsed,\npossibly <code>None</code></li>\n<li><code>choice</code>: the apply/reject flag</li>\n<li><code>tag</code>: the <code>Tag</code> representing the criterion</li>\n</ul>\n<h2>Class <code>TagSet(builtins.dict,cs.lex.FormatableMixin)</code></h2>\n<p>A setlike class associating a set of tag names with values.</p>\n<h3>Method <code>TagSet.__init__(self)</code></h3>\n<p>Initialise the <code>TagSet</code>.</p>\n<h2>Class <code>TagsOntology(cs.obj.SingletonMixin)</code></h2>\n<p>An ontology for tag names.</p>\n<p>This is based around a mapping of tag names\nto ontological information expressed as a <code>TagSet</code>.</p>\n<p>A <code>cs.fstags.FSTags</code> uses ontologies initialised from <code>TagFile</code>s\ncontaining ontology mappings.</p>\n<h2>Class <code>TypedTag(cs.lex.FormatableMixin)</code></h2>\n<p>A <code>Tag</code>like object linked to a <code>TagOntology</code>,\nproviding associated detail about a <code>Tag</code>.</p>\n<p>Like <code>Tag</code>, this has a <code>.name</code> and <code>.value</code>.</p>\n<p>Additionally it has the following attributes:</p>\n<ul>\n<li><code>ontology</code>: the supporting <code>TagOntology</code></li>\n<li><code>tag</code>: the originating <code>Tag</code>\n(computed from the <code>(name,value)</code> tuple if supplied)</li>\n<li><code>defn</code>: the <code>TagSet</code> from <code>.ontology</code>\nwhich defines this</li>\n<li><code>type</code>: <code>defn['type']</code></li>\n<li><code>member_type</code>: <code>defn['member_type']</code> if present;\nwe expect <code>type</code> to be a list or mapping type name</li>\n</ul>\n<p>Indexing a <code>TypedTag</code> indexes its <code>.value</code>\nand returns a tuple <code>(element,TagSet)</code>\nwhere the <code>TagSet</code> is information from the ontology\nabout the element's value (if <code>element</code> is a <code>str</code>).</p>\n<p>If the <code>.value</code> looks like a mapping\n.ie. it has a <code>.keys()</code> method\nthen a <code>TypedTag</code> has <code>.keys()</code> and <code>.items()</code> methods.\nThe <code>.keys()</code> call returns <code>.value.keys()</code>.\nThe <code>.items()</code> call yields <code>(key,self[key])</code>\nfor each of <code>self.keys()</code>.</p>\n<p>Iterating over a <code>TypedTag</code>\nyields its keys if it has a <code>.keys()</code> method,\notherwise values from <code>range(len(self.value))</code>.</p>\n<h3>Method <code>TypedTag.__init__(self, name, value=None, *, ontology)</code></h3>\n<p>Prepare the <code>TypedTag</code> from a <code>Tag</code> or <code>(name,value)</code> tuple.</p>\n<h1>Release Log</h1>\n<p><em>Release 20200318</em>:\n<em>Note that the TagsOntology stuff is in flux and totally alpha.</em>\nTag.prefix_name factory returning a new tag if prefix is not empty, ptherwise self.\nTagSet.update: accept an optional prefix for inserting \"foreign\" tags with a distinguishing name prefix.\nTag.as_json: turn sets and tuples into lists for encoding.\nBackport for Python &lt; 3.7 (no fromisoformat functions).\nTagSet: drop unused and illplaced .titleify, .episode_title and .title methods.\nTagSet: remove \"defaults\", unused.\nMake TagSet a direct subclass of dict, adjust uses of .update etc.\nNew ExtendedNamespace class which is a SimpleNamespace with some inferred attributes and a partial mapping API (keys and <strong>getitem</strong>).\nNew TagSet.ns() returning the Tags as an ExtendedNamespace, which doubles as a mapping for str.format_map; TagSet.format_kwargs is now an alias for this.\nNew Tag.from_string factory to parse a str into a Tag.\nNew TagsOntology and TypedTag classes to provide type and value-detail information; very very alpha and subject to change.</p>\n<p><em>Release 20200229.1</em>:\nInitial release: pull TagSet, Tag, TagChoice from cs.fstags for independent use.</p>\n\n          </div>"}, "last_serial": 6832148, "releases": {"20200229.1": [{"comment_text": "", "digests": {"md5": "9712b7a37bc14169ea137362825ce19a", "sha256": "28f7bb21383e8a26b5f568ab6ba67466b62eaa6b09b39baab700fc853ffe4128"}, "downloads": -1, "filename": "cs.tagset-20200229.1.tar.gz", "has_sig": false, "md5_digest": "9712b7a37bc14169ea137362825ce19a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5337, "upload_time": "2020-02-29T04:46:50", "upload_time_iso_8601": "2020-02-29T04:46:50.220007Z", "url": "https://files.pythonhosted.org/packages/ae/85/23c1872c76dceb62b5b50ea0f907b1412e465b6e584d7495b691bcd8194a/cs.tagset-20200229.1.tar.gz", "yanked": false}], "20200318": [{"comment_text": "", "digests": {"md5": "0db5c840cbb226abe45e592b33667f9d", "sha256": "4637c6b0198ec60cdcda260beaa541ef7673f4cf982c82e764059024b818a7ab"}, "downloads": -1, "filename": "cs.tagset-20200318.tar.gz", "has_sig": false, "md5_digest": "0db5c840cbb226abe45e592b33667f9d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10385, "upload_time": "2020-03-17T23:11:36", "upload_time_iso_8601": "2020-03-17T23:11:36.925303Z", "url": "https://files.pythonhosted.org/packages/db/63/d2645b65a42bf62a7341200f887c5b47646727f8b36821778ad1ec676073/cs.tagset-20200318.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0db5c840cbb226abe45e592b33667f9d", "sha256": "4637c6b0198ec60cdcda260beaa541ef7673f4cf982c82e764059024b818a7ab"}, "downloads": -1, "filename": "cs.tagset-20200318.tar.gz", "has_sig": false, "md5_digest": "0db5c840cbb226abe45e592b33667f9d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10385, "upload_time": "2020-03-17T23:11:36", "upload_time_iso_8601": "2020-03-17T23:11:36.925303Z", "url": "https://files.pythonhosted.org/packages/db/63/d2645b65a42bf62a7341200f887c5b47646727f8b36821778ad1ec676073/cs.tagset-20200318.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:41:44 2020"}