{"info": {"author": "GE Ning", "author_email": "benjaminzge@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)", "Operating System :: OS Independent", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Text Processing :: General", "Topic :: Utilities"], "description": "2-dimensional Sequence Regular Expression (SEQ RE)\n==================================================\n\nThis module provides regular expression matching operations over a sequence of tuples\n(or a sequence of sequence) data structure. It looks like the following::\n\n    seq_m_n = [[str_11, str_12, ... str_1n],\n               [str_21, str_22, ... str_2n],\n                ...,\n               [str_m1, str_m2, ... str_mn]]\n\nThe sequence is a homogeneous 2D array, that is a matrix with m rows and n columns.\nIn practice, m maybe vary from sequence to sequence, while n is usually a fixed-size.\n\nA element in the tuple of the sequence can be considered as either a string, a word, a phrase,\na char, a flag, a token or a tag, and maybe a set of tags or values (multi-values) in the future.\n\nTo match a pattern over a sequence of tuples,\nthe SEQ RE patterns is written like one of the examples::\n\n    ([;;PERSON]+) [was|has been] [an]? .{0,3} ([^painter|drawing artist|\u753b\u5bb6])\n\n    (?P<name@0,1,2>[;;PERSON]) [;VERB be;] [born] [on] (?P<birthday@0:3>([;;NUMBER|MONTH]|[-]){2,3})\n\n\n1. The syntax of SEQ RE pattern\n-------------------------------\n\nA SEQ RE pattern is very similar to the ordinary regular express (RE) used in Python,\nin which the delimiters ``[...]`` is to indicate a tuple -- the second dimension of the sequence.\n\n1.1 Inside ``[...]``\n++++++++++++++++++++\n\n- ``[`` and ``]``\n\n  is the beginning and end delimiter of the tuple, e.g. ``[...]``.\n\n- ``;``\n\n  separates each element which the tuple contains,\n  and the continuous ``;`` at the tail can be omitted,\n  e.g. ``[A|B;X;;]``, ``[A|B;X]``.\n\n- ``|``\n\n  indicates the different values of one element, e.g. ``A|B``.\n  These values form a set, and any string in the set will be matched,\n  e.g. ``A|B`` will match ``A`` or ``B``.\n\n- ``^``\n\n  be the first character of an element,\n  all the string that are not in the value set of this element will be matched.\n  And ``^`` has no special meaning if it\u2019s not the first character of the element.\n  If ``^`` comes the first character of an element but it is a part of a literal string,\n  ``\\^`` should be used to escape it.\n\n- The priority of above-mentioned operations:\n\n  ``[`` ``]`` < ``;`` < ``^`` (not literal) < ``|`` < ``^`` (literal) .\n\n- ``\\``\n\n  is an escaping symbol before aforementioned special characters.\n  Characters other than ``]``, ``:`` or ``\\`` lose their special meaning inside ``[...]``.\n  To express ``]``, ``:`` or ``|`` in literal, ``\\`` should be added before ``]``, ``:`` or ``|``.\n  Meanwhile, to represent a literal backslash ``\\`` before ``]``, ``;`` or ``|``,\n  ``\\\\`` should be used in the plain text\n  that is to say ``'\\\\\\\\'`` must be used in the Python code.\n\n1.2 Outside ``[...]``\n+++++++++++++++++++++\n\n- The special meanings of special characters in the ordinary RE are available here,\n  but with the limitations discussed below.\n\n  1. **Not** support ``[`` and ``]`` as special characters to indicate a set of characters.\n\n  2. **Not** support the following escaped special characters:\n     ``\\number``, ``\\A``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s``, ``\\S``,\n     ``\\w``, ``\\W``, ``\\Z``, ``\\a``, ``\\b``, ``\\f``, ``\\n``, ``\\r``, ``\\t``, ``\\v``,\n     ``\\x``.\n\n  3. **Not** support ranges of characters,\n     such as ``[0-9A-Za-z]``, ``[\\u4E00-\\u9FBB\\u3007]`` (Unihan and Chinese character ``\u3007``)\n     used in ordinary RE.\n\n  4. The whitespace and non-special characters are ignored.\n\n- ``.`` is an abbreviation of an arbitrary tuple ``[]`` or ``[;]``.\n\n- The named groups in the pattern are very useful.\n  As an extension, a format string starting with ``@`` can be followed after the group name,\n  to describe which element of the tuples belonging this group will be output as the result.\n  For example: ``(?P<name@d1,d2:d3>...)``,\n  in which ``d1``, ``d2`` and ``d3`` are all 0-based position index number of elements in the tuple.\n\n  1. ``@0,2:4`` means in the matched result only the 0th\n     and from 2nd to 3rd elements of tuples will be output.\n\n  2. ``@@`` means the pattern of the group itself will be output other than the matched result.\n     one can choose whether to include the group name and parentheses or not.\n\n  3. ``@`` means all elements of tuples in the matched result will be output.\n\n1.3 Boolean logic in the ``[...]``\n++++++++++++++++++++++++++++++++++\n\nGiven a sequence of 3-tuple ``[[s1, s2, s3], ... ]``,\n\n- AND\n\n  ``[X;;Y]`` will match ``s1`` == ``X`` && ``s3`` == ``Y``.\n  Its behavior looks like the ordinary RE pattern ``(?:X.Y)``.\n\n- OR\n\n  ``[X;;]|[;;Y]`` will match ``s1`` == ``X`` || ``s3`` == ``Y``.\n  Its behavior looks like the ordinary RE pattern ``(?:X..)|(?:..Y)``\n\n- NOT\n\n  If ``[;^P;]`` will match ``s2`` != ``P``.\n  Its behavior looks like the ordinary RE pattern ``(?:.[^P].)``.\n\n  We can also use a negative lookahead assertion of the ordinary RE,\n  to give a negative covering its following.\n  e.g. ``(?![;P;][Q])[;;][;;]`` <==> ``[;^P;][^Q;;]``,\n  which behavior looks like the ordinary RE pattern ``(?!(?:.P.)(?:Q..))...``.\n\n2. Notes\n--------\n\n**Not** support comparing the number of figures.\n\nMulti-values of one element is not supported now, but this feature may be improved in the future.\n\nAlthough SEQ RE has sufficient ability to express a pattern over sequences of tuples,\nit is still not a cascaded regular expressions (see also: `Stanford TokensRegex\n<https://nlp.stanford.edu/software/tokensregex.html>`_).\n\n\n3. Examples\n-----------\n\nThe usage of seq_re module::\n\n    from __future__ import print_function\n    import seq_re\n\n    n = 3\n    pattern = ('(?P<name@0>[;;PERSON]+) [is|was|has been] [a|an]? '\n               '(?P<attrib@0,1>.{0,3}) ([artist])')\n    seq = [['Vincent van Gogh', 'NNP', 'PERSON'],\n           ['was', 'VBD', 'O'],\n           ['a', 'DT', 'O'],\n           ['Dutch', 'JJ', 'O'],\n           ['Post-Impressionist', 'NN', 'O'],\n           ['painter', 'NN', 'OCCUPATION'],\n           ['who', 'WP', 'O'],\n           ['is', 'VBZ', 'O'],\n           ['among', 'IN', 'O'],\n           ['the', 'DT', 'O'],\n           ['most', 'RBS', 'O'],\n           ['famous', 'JJ', 'O'],\n           ['and', 'CC', 'O'],\n           ['influential', 'JJ', 'O'],\n           ['figures', 'NNS', 'O'],\n           ['in', 'IN', 'O'],\n           ['the', 'DT', 'O'],\n           ['history', 'NN', 'O'],\n           ['of', 'IN', 'O'],\n           ['Western art', 'NNP', 'DOMAIN'],\n           ['.', '.', 'O']]\n    placeholder_dict = {'artist': ['painter', 'drawing artist']}\n\n    sr = seq_re.SeqRegex(n).compile(pattern, **placeholder_dict)\n    match = sr.search(seq)\n    if match:\n        for g in match.group_list:\n            print(' '.join(['`'.join(tup) for tup in g[1]]))\n        for name in sorted(match.named_group_dict,\n                           key=lambda gn: match.named_group_dict[gn][0]):\n            print(name, match.format_group_to_str(name, True))", "description_content_type": null, "docs_url": "https://pythonhosted.org/seq-re/", "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/gening/seq_re", "keywords": "n-tuple n-vector token sequence seq 2D-array matrix regular-expressions regex", "license": "LGPL-3.0", "maintainer": "", "maintainer_email": "", "name": "seq-re", "package_url": "https://pypi.org/project/seq-re/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/seq-re/", "project_urls": {"Homepage": "https://github.com/gening/seq_re"}, "release_url": "https://pypi.org/project/seq-re/0.2.1/", "requires_dist": null, "requires_python": "", "summary": "2-dimensional Sequence Regular Expression (SEQ RE)", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This module provides regular expression matching operations over a sequence of tuples\n(or a sequence of sequence) data structure. It looks like the following:</p>\n<pre>seq_m_n = [[str_11, str_12, ... str_1n],\n           [str_21, str_22, ... str_2n],\n            ...,\n           [str_m1, str_m2, ... str_mn]]\n</pre>\n<p>The sequence is a homogeneous 2D array, that is a matrix with m rows and n columns.\nIn practice, m maybe vary from sequence to sequence, while n is usually a fixed-size.</p>\n<p>A element in the tuple of the sequence can be considered as either a string, a word, a phrase,\na char, a flag, a token or a tag, and maybe a set of tags or values (multi-values) in the future.</p>\n<p>To match a pattern over a sequence of tuples,\nthe SEQ RE patterns is written like one of the examples:</p>\n<pre>([;;PERSON]+) [was|has been] [an]? .{0,3} ([^painter|drawing artist|\u753b\u5bb6])\n\n(?P&lt;name@0,1,2&gt;[;;PERSON]) [;VERB be;] [born] [on] (?P&lt;birthday@0:3&gt;([;;NUMBER|MONTH]|[-]){2,3})\n</pre>\n<div id=\"the-syntax-of-seq-re-pattern\">\n<h2>1. The syntax of SEQ RE pattern</h2>\n<p>A SEQ RE pattern is very similar to the ordinary regular express (RE) used in Python,\nin which the delimiters <tt><span class=\"pre\">[...]</span></tt> is to indicate a tuple \u2013 the second dimension of the sequence.</p>\n<div id=\"inside\">\n<h3>1.1 Inside <tt><span class=\"pre\">[...]</span></tt></h3>\n<ul>\n<li><p><tt>[</tt> and <tt>]</tt></p>\n<p>is the beginning and end delimiter of the tuple, e.g. <tt><span class=\"pre\">[...]</span></tt>.</p>\n</li>\n<li><p><tt>;</tt></p>\n<p>separates each element which the tuple contains,\nand the continuous <tt>;</tt> at the tail can be omitted,\ne.g. <tt><span class=\"pre\">[A|B;X;;]</span></tt>, <tt>[A|B;X]</tt>.</p>\n</li>\n<li><p><tt>|</tt></p>\n<p>indicates the different values of one element, e.g. <tt>A|B</tt>.\nThese values form a set, and any string in the set will be matched,\ne.g. <tt>A|B</tt> will match <tt>A</tt> or <tt>B</tt>.</p>\n</li>\n<li><p><tt>^</tt></p>\n<p>be the first character of an element,\nall the string that are not in the value set of this element will be matched.\nAnd <tt>^</tt> has no special meaning if it\u2019s not the first character of the element.\nIf <tt>^</tt> comes the first character of an element but it is a part of a literal string,\n<tt>\\^</tt> should be used to escape it.</p>\n</li>\n<li><p>The priority of above-mentioned operations:</p>\n<p><tt>[</tt> <tt>]</tt> &lt; <tt>;</tt> &lt; <tt>^</tt> (not literal) &lt; <tt>|</tt> &lt; <tt>^</tt> (literal) .</p>\n</li>\n<li><p><tt>\\</tt></p>\n<p>is an escaping symbol before aforementioned special characters.\nCharacters other than <tt>]</tt>, <tt>:</tt> or <tt>\\</tt> lose their special meaning inside <tt><span class=\"pre\">[...]</span></tt>.\nTo express <tt>]</tt>, <tt>:</tt> or <tt>|</tt> in literal, <tt>\\</tt> should be added before <tt>]</tt>, <tt>:</tt> or <tt>|</tt>.\nMeanwhile, to represent a literal backslash <tt>\\</tt> before <tt>]</tt>, <tt>;</tt> or <tt>|</tt>,\n<tt>\\\\</tt> should be used in the plain text\nthat is to say <tt><span class=\"pre\">'\\\\\\\\'</span></tt> must be used in the Python code.</p>\n</li>\n</ul>\n</div>\n<div id=\"outside\">\n<h3>1.2 Outside <tt><span class=\"pre\">[...]</span></tt></h3>\n<ul>\n<li>The special meanings of special characters in the ordinary RE are available here,\nbut with the limitations discussed below.<ol>\n<li><strong>Not</strong> support <tt>[</tt> and <tt>]</tt> as special characters to indicate a set of characters.</li>\n<li><strong>Not</strong> support the following escaped special characters:\n<tt>\\number</tt>, <tt>\\A</tt>, <tt>\\b</tt>, <tt>\\B</tt>, <tt>\\d</tt>, <tt>\\D</tt>, <tt>\\s</tt>, <tt>\\S</tt>,\n<tt>\\w</tt>, <tt>\\W</tt>, <tt>\\Z</tt>, <tt>\\a</tt>, <tt>\\b</tt>, <tt>\\f</tt>, <tt>\\n</tt>, <tt>\\r</tt>, <tt>\\t</tt>, <tt>\\v</tt>,\n<tt>\\x</tt>.</li>\n<li><strong>Not</strong> support ranges of characters,\nsuch as <tt><span class=\"pre\">[0-9A-Za-z]</span></tt>, <tt><span class=\"pre\">[\\u4E00-\\u9FBB\\u3007]</span></tt> (Unihan and Chinese character <tt>\u3007</tt>)\nused in ordinary RE.</li>\n<li>The whitespace and non-special characters are ignored.</li>\n</ol>\n</li>\n<li><tt>.</tt> is an abbreviation of an arbitrary tuple <tt>[]</tt> or <tt>[;]</tt>.</li>\n<li>The named groups in the pattern are very useful.\nAs an extension, a format string starting with <tt>@</tt> can be followed after the group name,\nto describe which element of the tuples belonging this group will be output as the result.\nFor example: <tt><span class=\"pre\">(?P&lt;name@d1,d2:d3&gt;...)</span></tt>,\nin which <tt>d1</tt>, <tt>d2</tt> and <tt>d3</tt> are all 0-based position index number of elements in the tuple.<ol>\n<li><tt>@0,2:4</tt> means in the matched result only the 0th\nand from 2nd to 3rd elements of tuples will be output.</li>\n<li><tt>@@</tt> means the pattern of the group itself will be output other than the matched result.\none can choose whether to include the group name and parentheses or not.</li>\n<li><tt>@</tt> means all elements of tuples in the matched result will be output.</li>\n</ol>\n</li>\n</ul>\n</div>\n<div id=\"boolean-logic-in-the\">\n<h3>1.3 Boolean logic in the <tt><span class=\"pre\">[...]</span></tt></h3>\n<p>Given a sequence of 3-tuple <tt>[[s1, s2, s3], ... ]</tt>,</p>\n<ul>\n<li><p>AND</p>\n<p><tt><span class=\"pre\">[X;;Y]</span></tt> will match <tt>s1</tt> == <tt>X</tt> &amp;&amp; <tt>s3</tt> == <tt>Y</tt>.\nIts behavior looks like the ordinary RE pattern <tt><span class=\"pre\">(?:X.Y)</span></tt>.</p>\n</li>\n<li><p>OR</p>\n<p><tt><span class=\"pre\">[X;;]|[;;Y]</span></tt> will match <tt>s1</tt> == <tt>X</tt> || <tt>s3</tt> == <tt>Y</tt>.\nIts behavior looks like the ordinary RE pattern <tt><span class=\"pre\">(?:X..)|(?:..Y)</span></tt></p>\n</li>\n<li><p>NOT</p>\n<p>If <tt><span class=\"pre\">[;^P;]</span></tt> will match <tt>s2</tt> != <tt>P</tt>.\nIts behavior looks like the ordinary RE pattern <tt><span class=\"pre\">(?:.[^P].)</span></tt>.</p>\n<p>We can also use a negative lookahead assertion of the ordinary RE,\nto give a negative covering its following.\ne.g. <tt><span class=\"pre\">(?![;P;][Q])[;;][;;]</span></tt> &lt;==&gt; <tt><span class=\"pre\">[;^P;][^Q;;]</span></tt>,\nwhich behavior looks like the ordinary RE pattern <tt><span class=\"pre\">(?!(?:.P.)(?:Q..))...</span></tt>.</p>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"notes\">\n<h2>2. Notes</h2>\n<p><strong>Not</strong> support comparing the number of figures.</p>\n<p>Multi-values of one element is not supported now, but this feature may be improved in the future.</p>\n<p>Although SEQ RE has sufficient ability to express a pattern over sequences of tuples,\nit is still not a cascaded regular expressions (see also: <a href=\"https://nlp.stanford.edu/software/tokensregex.html\" rel=\"nofollow\">Stanford TokensRegex</a>).</p>\n</div>\n<div id=\"examples\">\n<h2>3. Examples</h2>\n<p>The usage of seq_re module:</p>\n<pre>from __future__ import print_function\nimport seq_re\n\nn = 3\npattern = ('(?P&lt;name@0&gt;[;;PERSON]+) [is|was|has been] [a|an]? '\n           '(?P&lt;attrib@0,1&gt;.{0,3}) ([artist])')\nseq = [['Vincent van Gogh', 'NNP', 'PERSON'],\n       ['was', 'VBD', 'O'],\n       ['a', 'DT', 'O'],\n       ['Dutch', 'JJ', 'O'],\n       ['Post-Impressionist', 'NN', 'O'],\n       ['painter', 'NN', 'OCCUPATION'],\n       ['who', 'WP', 'O'],\n       ['is', 'VBZ', 'O'],\n       ['among', 'IN', 'O'],\n       ['the', 'DT', 'O'],\n       ['most', 'RBS', 'O'],\n       ['famous', 'JJ', 'O'],\n       ['and', 'CC', 'O'],\n       ['influential', 'JJ', 'O'],\n       ['figures', 'NNS', 'O'],\n       ['in', 'IN', 'O'],\n       ['the', 'DT', 'O'],\n       ['history', 'NN', 'O'],\n       ['of', 'IN', 'O'],\n       ['Western art', 'NNP', 'DOMAIN'],\n       ['.', '.', 'O']]\nplaceholder_dict = {'artist': ['painter', 'drawing artist']}\n\nsr = seq_re.SeqRegex(n).compile(pattern, **placeholder_dict)\nmatch = sr.search(seq)\nif match:\n    for g in match.group_list:\n        print(' '.join(['`'.join(tup) for tup in g[1]]))\n    for name in sorted(match.named_group_dict,\n                       key=lambda gn: match.named_group_dict[gn][0]):\n        print(name, match.format_group_to_str(name, True))\n</pre>\n</div>\n\n          </div>"}, "last_serial": 2828603, "releases": {"0.2": [{"comment_text": "", "digests": {"md5": "4ab481cde404bf86a602a68f91d752e8", "sha256": "b83767e5e52f5efd37bfd8120a3d97408cf08be6cbc0e698d58cd14f483c4fc6"}, "downloads": -1, "filename": "seq_re-0.2.tar.gz", "has_sig": false, "md5_digest": "4ab481cde404bf86a602a68f91d752e8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21478, "upload_time": "2017-04-19T10:23:46", "upload_time_iso_8601": "2017-04-19T10:23:46.771477Z", "url": "https://files.pythonhosted.org/packages/a3/f9/61335fec062990c7de2ccf77513e5995e0f7c5a35a6439741cf4c6d7d8a1/seq_re-0.2.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "941f32ef91938bdf8905d51cfd6e7dcb", "sha256": "f26aa53ed1c49bff18bf3aadb98f0b58944b406e4b503b024c129b5060bb97f1"}, "downloads": -1, "filename": "seq_re-0.2.1.tar.gz", "has_sig": false, "md5_digest": "941f32ef91938bdf8905d51cfd6e7dcb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22031, "upload_time": "2017-04-25T11:53:28", "upload_time_iso_8601": "2017-04-25T11:53:28.140655Z", "url": "https://files.pythonhosted.org/packages/01/fc/3b3ab30b98bb7e8b9ae525615251686f35580c54ada0a246eebe374f6516/seq_re-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "941f32ef91938bdf8905d51cfd6e7dcb", "sha256": "f26aa53ed1c49bff18bf3aadb98f0b58944b406e4b503b024c129b5060bb97f1"}, "downloads": -1, "filename": "seq_re-0.2.1.tar.gz", "has_sig": false, "md5_digest": "941f32ef91938bdf8905d51cfd6e7dcb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22031, "upload_time": "2017-04-25T11:53:28", "upload_time_iso_8601": "2017-04-25T11:53:28.140655Z", "url": "https://files.pythonhosted.org/packages/01/fc/3b3ab30b98bb7e8b9ae525615251686f35580c54ada0a246eebe374f6516/seq_re-0.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:54:50 2020"}