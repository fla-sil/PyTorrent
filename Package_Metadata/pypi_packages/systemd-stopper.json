{"info": {"author": "Christoph Schmitt", "author_email": "dev@chschmitt.de", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Programming Language :: Python :: Implementation :: CPython"], "description": "systemd-stopper\r\n===============\r\n\r\n``systemd-stopper`` is a small library for conveniently handling the ``systemctl stop`` operation in Python application running as ``systemd`` units. Since running a Python process with ``systemd`` is simple, handling the stop command should be simple as well. \r\n\r\nQuickstart\r\n----------\r\n\r\nConsider the following unit-file defining ``my_app.service``::\r\n\r\n    [Unit]\r\n    Description=Cool Python Unit\r\n    After=network.target\r\n    \r\n    [Service]\r\n    ExecStart=/usr/bin/python3 /home/user/my_app.py\r\n    KillMode=Process\r\n    \r\n    [Install]\r\n    WantedBy=multi-user.target\r\n\r\n\r\nTo stop the application gracefully via ``systemctl stop my_app``, we have to implement a signal handler for the ``SIGTERM`` signal. Using the ``signal`` module from the standard library directly is a bit low-level, escpecially if your application is multithreaded or if you have to implement the signal handling in multiple applications.\r\n\r\n``systemd-stopper`` lets you handle the stop event straightforward, for example in an application with a simple main loop::\r\n\r\n    import systemd_stopper\r\n    stopper = systemd_stopper.install()\r\n    while stopper.run:\r\n        do_stuff()\r\n    handle_graceful_shutdown()\r\n\r\nThe ``install()`` function sets up the signal handlers and returns a ``Stopper`` object to query the status of the stop command. You have multiple options::\r\n\r\n    # Use other signals for stopping the application.\r\n    stopper = systemd_stopper.install('USR1', 'HUP')\r\n    \r\n    # Wait for a threading.Event instead of polling the run attribute.\r\n    stopper.event.wait() # returns when the stop signal has been receive\r\n    \r\n    # Use a callback function that gets called exactly once, which is useful\r\n    # for single-threaded IO loops like those of tornado or asyncio\r\n    ioloop = framework_of_choice.get_io_loop()\r\n    systemd_stopper.install(callback=ioloop.stop)\r\n    \r\n\r\nInstallation\r\n------------\r\n\r\n``pip install systemd-stopper``\r\n\r\n\r\nFurther documentation\r\n---------------------\r\n\r\nFurther documentation will be added when I have the time to write it.\r\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/chschmitt/systemd-stopper", "keywords": "systemd linux signal-handling", "license": "BSD License", "maintainer": "", "maintainer_email": "", "name": "systemd-stopper", "package_url": "https://pypi.org/project/systemd-stopper/", "platform": "", "project_url": "https://pypi.org/project/systemd-stopper/", "project_urls": {"Homepage": "https://github.com/chschmitt/systemd-stopper"}, "release_url": "https://pypi.org/project/systemd-stopper/0.1.0/", "requires_dist": null, "requires_python": "", "summary": "A signal handler utility for Python applications running as systemd units", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><tt><span class=\"pre\">systemd-stopper</span></tt> is a small library for conveniently handling the <tt>systemctl stop</tt> operation in Python application running as <tt>systemd</tt> units. Since running a Python process with <tt>systemd</tt> is simple, handling the stop command should be simple as well.</p>\n<div id=\"quickstart\">\n<h2>Quickstart</h2>\n<p>Consider the following unit-file defining <tt>my_app.service</tt>:</p>\n<pre>[Unit]\nDescription=Cool Python Unit\nAfter=network.target\n\n[Service]\nExecStart=/usr/bin/python3 /home/user/my_app.py\nKillMode=Process\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n<p>To stop the application gracefully via <tt>systemctl stop my_app</tt>, we have to implement a signal handler for the <tt>SIGTERM</tt> signal. Using the <tt>signal</tt> module from the standard library directly is a bit low-level, escpecially if your application is multithreaded or if you have to implement the signal handling in multiple applications.</p>\n<p><tt><span class=\"pre\">systemd-stopper</span></tt> lets you handle the stop event straightforward, for example in an application with a simple main loop:</p>\n<pre>import systemd_stopper\nstopper = systemd_stopper.install()\nwhile stopper.run:\n    do_stuff()\nhandle_graceful_shutdown()\n</pre>\n<p>The <tt>install()</tt> function sets up the signal handlers and returns a <tt>Stopper</tt> object to query the status of the stop command. You have multiple options:</p>\n<pre># Use other signals for stopping the application.\nstopper = systemd_stopper.install('USR1', 'HUP')\n\n# Wait for a threading.Event instead of polling the run attribute.\nstopper.event.wait() # returns when the stop signal has been receive\n\n# Use a callback function that gets called exactly once, which is useful\n# for single-threaded IO loops like those of tornado or asyncio\nioloop = framework_of_choice.get_io_loop()\nsystemd_stopper.install(callback=ioloop.stop)\n</pre>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p><tt>pip install <span class=\"pre\">systemd-stopper</span></tt></p>\n</div>\n<div id=\"further-documentation\">\n<h2>Further documentation</h2>\n<p>Further documentation will be added when I have the time to write it.</p>\n</div>\n\n          </div>"}, "last_serial": 3474943, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "5b2b1f3324dcf8145478246708d52983", "sha256": "8f10983de5caa0a09b7155c9c40a99c959db27cac1b0bc12d2725861cbb5bb31"}, "downloads": -1, "filename": "systemd-stopper-0.1.0.tar.gz", "has_sig": false, "md5_digest": "5b2b1f3324dcf8145478246708d52983", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5029, "upload_time": "2018-01-09T17:34:10", "upload_time_iso_8601": "2018-01-09T17:34:10.772575Z", "url": "https://files.pythonhosted.org/packages/d9/6e/bd57fbd3e09fbab4f3f4c5b7c31bb5e8b737fbe8892eb95dc72132bf57df/systemd-stopper-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5b2b1f3324dcf8145478246708d52983", "sha256": "8f10983de5caa0a09b7155c9c40a99c959db27cac1b0bc12d2725861cbb5bb31"}, "downloads": -1, "filename": "systemd-stopper-0.1.0.tar.gz", "has_sig": false, "md5_digest": "5b2b1f3324dcf8145478246708d52983", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5029, "upload_time": "2018-01-09T17:34:10", "upload_time_iso_8601": "2018-01-09T17:34:10.772575Z", "url": "https://files.pythonhosted.org/packages/d9/6e/bd57fbd3e09fbab4f3f4c5b7c31bb5e8b737fbe8892eb95dc72132bf57df/systemd-stopper-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:51 2020"}