{"info": {"author": "Fabrice Desclaux", "author_email": "serpilliere@droid-corp.org", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6"], "description": "[![Build Status](https://travis-ci.org/cea-sec/miasm.svg)](https://travis-ci.org/cea-sec/miasm)\n[![Build status](https://ci.appveyor.com/api/projects/status/g845jr23nt18uf29/branch/master?svg=true)](https://ci.appveyor.com/project/cea-sec/miasm)\n[![Code Climate](https://codeclimate.com/github/cea-sec/miasm/badges/gpa.svg)](https://codeclimate.com/github/cea-sec/miasm) [![Join the chat at https://gitter.im/cea-sec/miasm](https://badges.gitter.im/cea-sec/miasm.svg)](https://gitter.im/cea-sec/miasm?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n\n<p align=\"center\">\n<img src=\"https://raw.githubusercontent.com/cea-sec/miasm/master/doc/logo_miasm.png\">\n</p>\n\n\nWhat is Miasm?\n==============\n\nMiasm is a free and open source (GPLv2) reverse engineering framework.\nMiasm aims to analyze / modify / generate binary programs. Here is\na non exhaustive list of features:\n\n* Opening / modifying / generating PE / ELF 32 / 64 LE / BE\n* Assembling / Disassembling X86 / ARM / MIPS / SH4 / MSP430\n* Representing assembly semantic using intermediate language\n* Emulating using JIT (dynamic code analysis, unpacking, ...)\n* Expression simplification for automatic de-obfuscation\n* ...\n\nSee the official [blog](http://miasm.re) for more examples and demos.\n\nTable of Contents\n=================\n\n- [What is Miasm?](#user-content-what-is-miasm)\n- [Basic examples](#user-content-basic-examples)\n\t- [Assembling / Disassembling](#user-content-assembling--disassembling)\n\t- [Intermediate representation](#user-content-intermediate-representation)\n\t- [Emulation](#user-content-emulation)\n\t- [Symbolic execution](#user-content-symbolic-execution)\n- [How does it work?](#user-content-how-does-it-work)\n- [Documentation](#user-content-documentation)\n- [Obtaining Miasm](#user-content-obtaining-miasm)\n\t- [Software requirements](#user-content-software-requirements)\n\t- [Configuration](#user-content-configuration)\n\t- [Windows & IDA](#user-content-windows--ida)\n- [Testing](#user-content-testing)\n- [They already use Miasm](#user-content-they-already-use-miasm)\n- [Misc](#user-content-misc)\n\n\nBasic examples\n==============\n\nAssembling / Disassembling\n--------------------------\n\nImport Miasm x86 architecture:\n```pycon\n>>> from miasm.arch.x86.arch import mn_x86\n>>> from miasm.core.locationdb import LocationDB\n```\nGet a location db:\n\n```pycon\n>>> loc_db = LocationDB()\n```\nAssemble a line:\n```pycon\n>>> l = mn_x86.fromstring('XOR ECX, ECX', loc_db, 32)\n>>> print(l)\nXOR        ECX, ECX\n>>> mn_x86.asm(l)\n['1\\xc9', '3\\xc9', 'g1\\xc9', 'g3\\xc9']\n```\nModify an operand:\n```pycon\n>>> l.args[0] = mn_x86.regs.EAX\n>>> print(l)\nXOR        EAX, ECX\n>>> a = mn_x86.asm(l)\n>>> print(a)\n['1\\xc8', '3\\xc1', 'g1\\xc8', 'g3\\xc1']\n```\nDisassemble the result:\n```pycon\n>>> print(mn_x86.dis(a[0], 32))\nXOR        EAX, ECX\n```\nUsing `Machine` abstraction:\n\n```pycon\n>>> from miasm.analysis.machine import Machine\n>>> mn = Machine('x86_32').mn\n>>> print(mn.dis('\\x33\\x30', 32))\nXOR        ESI, DWORD PTR [EAX]\n```\n\nFor Mips:\n```pycon\n>>> mn = Machine('mips32b').mn\n>>> print(mn.dis(b'\\x97\\xa3\\x00 ', \"b\"))\nLHU        V1, 0x20(SP)\n```\nIntermediate representation\n---------------------------\n\nCreate an instruction:\n\n```pycon\n>>> machine = Machine('arml')\n>>> instr = machine.mn.dis('\\x00 \\x88\\xe0', 'l')\n>>> print(instr)\nADD        R2, R8, R0\n```\n\nCreate an intermediate representation object:\n```pycon\n>>> ira = machine.ira(loc_db)\n```\nCreate an empty ircfg\n```pycon\n>>> ircfg = ira.new_ircfg()\n```\nAdd instruction to the pool:\n```pycon\n>>> ira.add_instr_to_ircfg(instr, ircfg)\n```\n\nPrint current pool:\n```pycon\n>>> for lbl, irblock in ircfg.blocks.items():\n...     print(irblock.to_string(loc_db))\nloc_0:\nR2 = R8 + R0\n\nIRDst = loc_4\n\n```\nWorking with IR, for instance by getting side effects:\n```pycon\n>>> for lbl, irblock in ircfg.blocks.iteritems():\n...     for assignblk in irblock:\n...         rw = assignblk.get_rw()\n...         for dst, reads in rw.iteritems():\n...             print('read:   ', [str(x) for x in reads])\n...             print('written:', dst)\n...             print()\n...\nread:    ['R8', 'R0']\nwritten: R2\n\nread:    []\nwritten: IRDst\n\n```\n\nEmulation\n---------\n\nGiving a shellcode:\n```pycon\n00000000 8d4904      lea    ecx, [ecx+0x4]\n00000003 8d5b01      lea    ebx, [ebx+0x1]\n00000006 80f901      cmp    cl, 0x1\n00000009 7405        jz     0x10\n0000000b 8d5bff      lea    ebx, [ebx-1]\n0000000e eb03        jmp    0x13\n00000010 8d5b01      lea    ebx, [ebx+0x1]\n00000013 89d8        mov    eax, ebx\n00000015 c3          ret\n>>> s = '\\x8dI\\x04\\x8d[\\x01\\x80\\xf9\\x01t\\x05\\x8d[\\xff\\xeb\\x03\\x8d[\\x01\\x89\\xd8\\xc3'\n```\nImport the shellcode thanks to the `Container` abstraction:\n\n```pycon\n>>> from miasm.analysis.binary import Container\n>>> c = Container.from_string(s)\n>>> c\n<miasm.analysis.binary.ContainerUnknown object at 0x7f34cefe6090>\n```\n\nDisassembling the shellcode at address `0`:\n\n```pycon\n>>> from miasm.analysis.machine import Machine\n>>> machine = Machine('x86_32')\n>>> mdis = machine.dis_engine(c.bin_stream)\n>>> asmcfg = mdis.dis_multiblock(0)\n>>> for block in asmcfg.blocks:\n...  print(block.to_string(asmcfg.loc_db))\n...\nloc_0\nLEA        ECX, DWORD PTR [ECX + 0x4]\nLEA        EBX, DWORD PTR [EBX + 0x1]\nCMP        CL, 0x1\nJZ         loc_10\n->      c_next:loc_b    c_to:loc_10\nloc_10\nLEA        EBX, DWORD PTR [EBX + 0x1]\n->      c_next:loc_13\nloc_b\nLEA        EBX, DWORD PTR [EBX + 0xFFFFFFFF]\nJMP        loc_13\n->      c_to:loc_13\nloc_13\nMOV        EAX, EBX\nRET\n```\n\nInitializing the Jit engine with a stack:\n\n```pycon\n>>> jitter = machine.jitter(jit_type='python')\n>>> jitter.init_stack()\n```\n\nAdd the shellcode in an arbitrary memory location:\n```pycon\n>>> run_addr = 0x40000000\n>>> from miasm.jitter.csts import PAGE_READ, PAGE_WRITE\n>>> jitter.vm.add_memory_page(run_addr, PAGE_READ | PAGE_WRITE, s)\n```\n\nCreate a sentinelle to catch the return of the shellcode:\n\n```Python\ndef code_sentinelle(jitter):\n    jitter.run = False\n    jitter.pc = 0\n    return True\n\n>>> jitter.add_breakpoint(0x1337beef, code_sentinelle)\n>>> jitter.push_uint32_t(0x1337beef)\n```\n\nActive logs:\n\n```pycon\n>>> jitter.set_trace_log()\n```\n\nRun at arbitrary address:\n\n```pycon\n>>> jitter.init_run(run_addr)\n>>> jitter.continue_run()\nRAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000000 RDX 0000000000000000\nRSI 0000000000000000 RDI 0000000000000000 RSP 000000000123FFF8 RBP 0000000000000000\nzf 0000000000000000 nf 0000000000000000 of 0000000000000000 cf 0000000000000000\nRIP 0000000040000000\n40000000 LEA        ECX, DWORD PTR [ECX+0x4]\nRAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000004 RDX 0000000000000000\nRSI 0000000000000000 RDI 0000000000000000 RSP 000000000123FFF8 RBP 0000000000000000\nzf 0000000000000000 nf 0000000000000000 of 0000000000000000 cf 0000000000000000\n....\n4000000e JMP        loc_0000000040000013:0x40000013\nRAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000004 RDX 0000000000000000\nRSI 0000000000000000 RDI 0000000000000000 RSP 000000000123FFF8 RBP 0000000000000000\nzf 0000000000000000 nf 0000000000000000 of 0000000000000000 cf 0000000000000000\nRIP 0000000040000013\n40000013 MOV        EAX, EBX\nRAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000004 RDX 0000000000000000\nRSI 0000000000000000 RDI 0000000000000000 RSP 000000000123FFF8 RBP 0000000000000000\nzf 0000000000000000 nf 0000000000000000 of 0000000000000000 cf 0000000000000000\nRIP 0000000040000013\n40000015 RET\n>>>\n\n```\n\nInteracting with the jitter:\n\n```pycon\n>>> jitter.vm\nad 1230000 size 10000 RW_ hpad 0x2854b40\nad 40000000 size 16 RW_ hpad 0x25e0ed0\n\n>>> hex(jitter.cpu.EAX)\n'0x0L'\n>>> jitter.cpu.ESI = 12\n```\n\nSymbolic execution\n------------------\n\nInitializing the IR pool:\n\n```pycon\n>>> ira = machine.ira(loc_db)\n>>> ircfg = ira.new_ircfg_from_asmcfg(asmcfg)\n```\n\nInitializing the engine with default symbolic values:\n\n```pycon\n>>> from miasm.ir.symbexec import SymbolicExecutionEngine\n>>> sb = SymbolicExecutionEngine(ira)\n```\n\nLaunching the execution:\n\n```pycon\n>>> symbolic_pc = sb.run_at(ircfg, 0)\n>>> print(symbolic_pc)\n((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\n```\n\nSame, with step logs (only changes are displayed):\n\n```pycon\n>>> sb = SymbolicExecutionEngine(ira, machine.mn.regs.regs_init)\n>>> symbolic_pc = sb.run_at(ircfg, 0, step=True)\nInstr LEA        ECX, DWORD PTR [ECX + 0x4]\nAssignblk:\nECX = ECX + 0x4\n________________________________________________________________________________\nECX                = ECX + 0x4\n________________________________________________________________________________\nInstr LEA        EBX, DWORD PTR [EBX + 0x1]\nAssignblk:\nEBX = EBX + 0x1\n________________________________________________________________________________\nEBX                = EBX + 0x1\nECX                = ECX + 0x4\n________________________________________________________________________________\nInstr CMP        CL, 0x1\nAssignblk:\nzf = (ECX[0:8] + -0x1)?(0x0,0x1)\nnf = (ECX[0:8] + -0x1)[7:8]\npf = parity((ECX[0:8] + -0x1) & 0xFF)\nof = ((ECX[0:8] ^ (ECX[0:8] + -0x1)) & (ECX[0:8] ^ 0x1))[7:8]\ncf = (((ECX[0:8] ^ 0x1) ^ (ECX[0:8] + -0x1)) ^ ((ECX[0:8] ^ (ECX[0:8] + -0x1)) & (ECX[0:8] ^ 0x1)))[7:8]\naf = ((ECX[0:8] ^ 0x1) ^ (ECX[0:8] + -0x1))[4:5]\n________________________________________________________________________________\naf                 = (((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[4:5]\npf                 = parity((ECX + 0x4)[0:8] + 0xFF)\nzf                 = ((ECX + 0x4)[0:8] + 0xFF)?(0x0,0x1)\nECX                = ECX + 0x4\nof                 = ((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) & ((ECX + 0x4)[0:8] ^ 0x1))[7:8]\nnf                 = ((ECX + 0x4)[0:8] + 0xFF)[7:8]\ncf                 = (((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) & ((ECX + 0x4)[0:8] ^ 0x1)) ^ ((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[7:8]\nEBX                = EBX + 0x1\n________________________________________________________________________________\nInstr JZ         loc_key_1\nAssignblk:\nIRDst = zf?(loc_key_1,loc_key_2)\nEIP = zf?(loc_key_1,loc_key_2)\n________________________________________________________________________________\naf                 = (((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[4:5]\nEIP                = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\npf                 = parity((ECX + 0x4)[0:8] + 0xFF)\nIRDst              = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\nzf                 = ((ECX + 0x4)[0:8] + 0xFF)?(0x0,0x1)\nECX                = ECX + 0x4\nof                 = ((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) & ((ECX + 0x4)[0:8] ^ 0x1))[7:8]\nnf                 = ((ECX + 0x4)[0:8] + 0xFF)[7:8]\ncf                 = (((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) & ((ECX + 0x4)[0:8] ^ 0x1)) ^ ((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[7:8]\nEBX                = EBX + 0x1\n________________________________________________________________________________\n>>>\n```\n\n\nRetry execution with a concrete ECX. Here, the symbolic / concolic execution reach the shellcode's end:\n\n```pycon\n>>> from miasm.expression.expression import ExprInt\n>>> sb.symbols[machine.mn.regs.ECX] = ExprInt(-3, 32)\n>>> symbolic_pc = sb.run_at(ircfg, 0, step=True)\nInstr LEA        ECX, DWORD PTR [ECX + 0x4]\nAssignblk:\nECX = ECX + 0x4\n________________________________________________________________________________\naf                 = (((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[4:5]\nEIP                = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\npf                 = parity((ECX + 0x4)[0:8] + 0xFF)\nIRDst              = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\nzf                 = ((ECX + 0x4)[0:8] + 0xFF)?(0x0,0x1)\nECX                = 0x1\nof                 = ((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) & ((ECX + 0x4)[0:8] ^ 0x1))[7:8]\nnf                 = ((ECX + 0x4)[0:8] + 0xFF)[7:8]\ncf                 = (((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) & ((ECX + 0x4)[0:8] ^ 0x1)) ^ ((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[7:8]\nEBX                = EBX + 0x1\n________________________________________________________________________________\nInstr LEA        EBX, DWORD PTR [EBX + 0x1]\nAssignblk:\nEBX = EBX + 0x1\n________________________________________________________________________________\naf                 = (((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[4:5]\nEIP                = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\npf                 = parity((ECX + 0x4)[0:8] + 0xFF)\nIRDst              = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\nzf                 = ((ECX + 0x4)[0:8] + 0xFF)?(0x0,0x1)\nECX                = 0x1\nof                 = ((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) & ((ECX + 0x4)[0:8] ^ 0x1))[7:8]\nnf                 = ((ECX + 0x4)[0:8] + 0xFF)[7:8]\ncf                 = (((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) & ((ECX + 0x4)[0:8] ^ 0x1)) ^ ((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[7:8]\nEBX                = EBX + 0x2\n________________________________________________________________________________\nInstr CMP        CL, 0x1\nAssignblk:\nzf = (ECX[0:8] + -0x1)?(0x0,0x1)\nnf = (ECX[0:8] + -0x1)[7:8]\npf = parity((ECX[0:8] + -0x1) & 0xFF)\nof = ((ECX[0:8] ^ (ECX[0:8] + -0x1)) & (ECX[0:8] ^ 0x1))[7:8]\ncf = (((ECX[0:8] ^ 0x1) ^ (ECX[0:8] + -0x1)) ^ ((ECX[0:8] ^ (ECX[0:8] + -0x1)) & (ECX[0:8] ^ 0x1)))[7:8]\naf = ((ECX[0:8] ^ 0x1) ^ (ECX[0:8] + -0x1))[4:5]\n________________________________________________________________________________\naf                 = 0x0\nEIP                = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\npf                 = 0x1\nIRDst              = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)\nzf                 = 0x1\nECX                = 0x1\nof                 = 0x0\nnf                 = 0x0\ncf                 = 0x0\nEBX                = EBX + 0x2\n________________________________________________________________________________\nInstr JZ         loc_key_1\nAssignblk:\nIRDst = zf?(loc_key_1,loc_key_2)\nEIP = zf?(loc_key_1,loc_key_2)\n________________________________________________________________________________\naf                 = 0x0\nEIP                = 0x10\npf                 = 0x1\nIRDst              = 0x10\nzf                 = 0x1\nECX                = 0x1\nof                 = 0x0\nnf                 = 0x0\ncf                 = 0x0\nEBX                = EBX + 0x2\n________________________________________________________________________________\nInstr LEA        EBX, DWORD PTR [EBX + 0x1]\nAssignblk:\nEBX = EBX + 0x1\n________________________________________________________________________________\naf                 = 0x0\nEIP                = 0x10\npf                 = 0x1\nIRDst              = 0x10\nzf                 = 0x1\nECX                = 0x1\nof                 = 0x0\nnf                 = 0x0\ncf                 = 0x0\nEBX                = EBX + 0x3\n________________________________________________________________________________\nInstr LEA        EBX, DWORD PTR [EBX + 0x1]\nAssignblk:\nIRDst = loc_key_3\n________________________________________________________________________________\naf                 = 0x0\nEIP                = 0x10\npf                 = 0x1\nIRDst              = 0x13\nzf                 = 0x1\nECX                = 0x1\nof                 = 0x0\nnf                 = 0x0\ncf                 = 0x0\nEBX                = EBX + 0x3\n________________________________________________________________________________\nInstr MOV        EAX, EBX\nAssignblk:\nEAX = EBX\n________________________________________________________________________________\naf                 = 0x0\nEIP                = 0x10\npf                 = 0x1\nIRDst              = 0x13\nzf                 = 0x1\nECX                = 0x1\nof                 = 0x0\nnf                 = 0x0\ncf                 = 0x0\nEBX                = EBX + 0x3\nEAX                = EBX + 0x3\n________________________________________________________________________________\nInstr RET\nAssignblk:\nIRDst = @32[ESP[0:32]]\nESP = {ESP[0:32] + 0x4 0 32}\nEIP = @32[ESP[0:32]]\n________________________________________________________________________________\naf                 = 0x0\nEIP                = @32[ESP]\npf                 = 0x1\nIRDst              = @32[ESP]\nzf                 = 0x1\nECX                = 0x1\nof                 = 0x0\nnf                 = 0x0\ncf                 = 0x0\nEBX                = EBX + 0x3\nESP                = ESP + 0x4\nEAX                = EBX + 0x3\n________________________________________________________________________________\n>>>\n```\n\n\n\nHow does it work?\n=================\n\nMiasm embeds its own disassembler, intermediate language and\ninstruction semantic. It is written in Python.\n\nTo emulate code, it uses LLVM, GCC, Clang or Python to JIT the\nintermediate representation. It can emulate shellcodes and all or parts of\nbinaries. Python callbacks can be executed to interact with the execution, for\ninstance to emulate library functions effects.\n\nDocumentation\n=============\n\nTODO\n\nAn auto-generated documentation is available [here](http://miasmdoc.ajax.re).\n\nObtaining Miasm\n===============\n\n* Clone the repository: [Miasm on GitHub](https://github.com/cea-sec/miasm/)\n* Get one of the Docker images at [Docker Hub](https://registry.hub.docker.com/u/miasm/)\n\nSoftware requirements\n---------------------\n\nMiasm uses:\n\n* python-pyparsing\n* python-dev\n* optionally python-pycparser (version >= 2.17)\n\nTo enable code JIT, one of the following module is mandatory:\n* GCC\n* Clang\n* LLVM with Numba llvmlite, see below\n\n'optional' Miasm can also use:\n* Z3, the [Theorem Prover](https://github.com/Z3Prover/z3)\n\nConfiguration\n-------------\n\nTo use the jitter, GCC or LLVM is recommended\n* GCC (any version)\n* Clang (any version)\n* LLVM\n  * Debian (testing/unstable): Not tested\n  * Debian stable/Ubuntu/Kali/whatever: `pip install llvmlite` or install from [llvmlite](https://github.com/numba/llvmlite)\n  * Windows: Not tested\n* Build and install Miasm:\n```pycon\n$ cd miasm_directory\n$ python setup.py build\n$ sudo python setup.py install\n```\n\nIf something goes wrong during one of the jitter modules compilation, Miasm will\nskip the error and disable the corresponding module (see the compilation\noutput).\n\nWindows & IDA\n-------------\n\nMost of Miasm's IDA plugins use a subset of Miasm functionality.\nA quick way to have them working is to add:\n* `pyparsing.py` to `C:\\...\\IDA\\python\\` or `pip install pyparsing`\n* `miasm/miasm` directory to `C:\\...\\IDA\\python\\`\n\nAll features excepting JITter related ones will be available. For a more complete installation, please refer to above paragraphs.\n\nTesting\n=======\n\nMiasm comes with a set of regression tests. To run all of them:\n\n```pycon\ncd miasm_directory/test\npython test_all.py\n```\n\nSome options can be specified:\n\n* Mono threading: `-m`\n* Code coverage instrumentation: `-c`\n* Only fast tests: `-t long` (excludes the long tests)\n\nThey already use Miasm\n======================\n\nTools\n-----\n\n* [Sibyl](https://github.com/cea-sec/Sibyl): A function divination too\n* [R2M2](https://github.com/guedou/r2m2): Use miasm as a radare2 plugin\n* [CGrex](https://github.com/mechaphish/cgrex) : Targeted patcher for CGC binaries\n* [ethRE](https://github.com/jbcayrou/ethRE) Reversing tool for Ethereum EVM (with corresponding Miasm2 architecture)\n\nBlog posts / papers / conferences\n---------------------------------\n\n* [Deobfuscation: recovering an OLLVM-protected program](http://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html)\n* [Taming a Wild Nanomite-protected MIPS Binary With Symbolic Execution: No Such Crackme](https://doar-e.github.io/blog/2014/10/11/taiming-a-wild-nanomite-protected-mips-binary-with-symbolic-execution-no-such-crackme/)\n* [G\u00e9n\u00e9ration rapide de DGA avec Miasm](https://www.lexsi.com/securityhub/generation-rapide-de-dga-avec-miasm/): Quick computation of DGA (French article)\n* [Enabling Client-Side Crash-Resistance to Overcome Diversification and Information Hiding](https://www.internetsociety.org/sites/default/files/blogs-media/enabling-client-side-crash-resistance-overcome-diversification-information-hiding.pdf): Detect undirected call potential arguments\n* [Miasm: Framework de reverse engineering](https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/) (French)\n* [Tutorial miasm](https://www.sstic.org/2014/presentation/Tutorial_miasm/) (French video)\n* [Graphes de d\u00e9pendances : Petit Poucet style](https://www.sstic.org/2016/presentation/graphes_de_dpendances__petit_poucet_style/): DepGraph (French)\n\nBooks\n-----\n\n* [Practical Reverse Engineering: X86, X64, Arm, Windows Kernel, Reversing Tools, and Obfuscation](http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118787315,subjectCd-CSJ0.html): Introduction to Miasm (Chapter 5 \"Obfuscation\")\n* [BlackHat Python - Appendix](https://github.com/oreilly-japan/black-hat-python-jp-support/tree/master/appendix-A): Japan security book's samples\n\n\nMisc\n====\n\n* Man, does miasm has a link with rr0d?\n* Yes! crappy code and uggly documentation.", "description_content_type": "text/markdown; charset=UTF-8", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://miasm.re", "keywords": "reverse engineering,disassembler,emulator,symbolic execution,intermediate representation,assembler", "license": "GPLv2", "maintainer": "", "maintainer_email": "", "name": "miasm", "package_url": "https://pypi.org/project/miasm/", "platform": "", "project_url": "https://pypi.org/project/miasm/", "project_urls": {"Homepage": "http://miasm.re"}, "release_url": "https://pypi.org/project/miasm/0.1.3/", "requires_dist": null, "requires_python": "", "summary": "Machine code manipulation library", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/cea-sec/miasm\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ccac43eeee25668e6ff7bc4d9cd86746eb0a1b60/68747470733a2f2f7472617669732d63692e6f72672f6365612d7365632f6d6961736d2e737667\"></a>\n<a href=\"https://ci.appveyor.com/project/cea-sec/miasm\" rel=\"nofollow\"><img alt=\"Build status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7a3a21bd070f9c3d51f068c55a2203f23e4fafe8/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f673834356a7232336e743138756632392f6272616e63682f6d61737465723f7376673d74727565\"></a>\n<a href=\"https://codeclimate.com/github/cea-sec/miasm\" rel=\"nofollow\"><img alt=\"Code Climate\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/846041462dc42d6249560ae7d36fdb231b8ed5e0/68747470733a2f2f636f6465636c696d6174652e636f6d2f6769746875622f6365612d7365632f6d6961736d2f6261646765732f6770612e737667\"></a> <a href=\"https://gitter.im/cea-sec/miasm?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge\" rel=\"nofollow\"><img alt=\"Join the chat at https://gitter.im/cea-sec/miasm\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9a5df184ea15f2ebcb744c4ee59a20b6834da550/68747470733a2f2f6261646765732e6769747465722e696d2f6365612d7365632f6d6961736d2e737667\"></a></p>\n<p align=\"center\">\n<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/29acf7b32f3d4977eafd2e6cc1b295577346f1cb/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6365612d7365632f6d6961736d2f6d61737465722f646f632f6c6f676f5f6d6961736d2e706e67\">\n</p>\n<h1>What is Miasm?</h1>\n<p>Miasm is a free and open source (GPLv2) reverse engineering framework.\nMiasm aims to analyze / modify / generate binary programs. Here is\na non exhaustive list of features:</p>\n<ul>\n<li>Opening / modifying / generating PE / ELF 32 / 64 LE / BE</li>\n<li>Assembling / Disassembling X86 / ARM / MIPS / SH4 / MSP430</li>\n<li>Representing assembly semantic using intermediate language</li>\n<li>Emulating using JIT (dynamic code analysis, unpacking, ...)</li>\n<li>Expression simplification for automatic de-obfuscation</li>\n<li>...</li>\n</ul>\n<p>See the official <a href=\"http://miasm.re\" rel=\"nofollow\">blog</a> for more examples and demos.</p>\n<h1>Table of Contents</h1>\n<ul>\n<li><a href=\"#user-content-what-is-miasm\" rel=\"nofollow\">What is Miasm?</a></li>\n<li><a href=\"#user-content-basic-examples\" rel=\"nofollow\">Basic examples</a>\n<ul>\n<li><a href=\"#user-content-assembling--disassembling\" rel=\"nofollow\">Assembling / Disassembling</a></li>\n<li><a href=\"#user-content-intermediate-representation\" rel=\"nofollow\">Intermediate representation</a></li>\n<li><a href=\"#user-content-emulation\" rel=\"nofollow\">Emulation</a></li>\n<li><a href=\"#user-content-symbolic-execution\" rel=\"nofollow\">Symbolic execution</a></li>\n</ul>\n</li>\n<li><a href=\"#user-content-how-does-it-work\" rel=\"nofollow\">How does it work?</a></li>\n<li><a href=\"#user-content-documentation\" rel=\"nofollow\">Documentation</a></li>\n<li><a href=\"#user-content-obtaining-miasm\" rel=\"nofollow\">Obtaining Miasm</a>\n<ul>\n<li><a href=\"#user-content-software-requirements\" rel=\"nofollow\">Software requirements</a></li>\n<li><a href=\"#user-content-configuration\" rel=\"nofollow\">Configuration</a></li>\n<li><a href=\"#user-content-windows--ida\" rel=\"nofollow\">Windows &amp; IDA</a></li>\n</ul>\n</li>\n<li><a href=\"#user-content-testing\" rel=\"nofollow\">Testing</a></li>\n<li><a href=\"#user-content-they-already-use-miasm\" rel=\"nofollow\">They already use Miasm</a></li>\n<li><a href=\"#user-content-misc\" rel=\"nofollow\">Misc</a></li>\n</ul>\n<h1>Basic examples</h1>\n<h2>Assembling / Disassembling</h2>\n<p>Import Miasm x86 architecture:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">miasm.arch.x86.arch</span> <span class=\"kn\">import</span> <span class=\"n\">mn_x86</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">miasm.core.locationdb</span> <span class=\"kn\">import</span> <span class=\"n\">LocationDB</span>\n</pre>\n<p>Get a location db:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">loc_db</span> <span class=\"o\">=</span> <span class=\"n\">LocationDB</span><span class=\"p\">()</span>\n</pre>\n<p>Assemble a line:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mn_x86</span><span class=\"o\">.</span><span class=\"n\">fromstring</span><span class=\"p\">(</span><span class=\"s1\">'XOR ECX, ECX'</span><span class=\"p\">,</span> <span class=\"n\">loc_db</span><span class=\"p\">,</span> <span class=\"mi\">32</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">)</span>\n<span class=\"go\">XOR        ECX, ECX</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mn_x86</span><span class=\"o\">.</span><span class=\"n\">asm</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">)</span>\n<span class=\"go\">['1\\xc9', '3\\xc9', 'g1\\xc9', 'g3\\xc9']</span>\n</pre>\n<p>Modify an operand:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">mn_x86</span><span class=\"o\">.</span><span class=\"n\">regs</span><span class=\"o\">.</span><span class=\"n\">EAX</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">)</span>\n<span class=\"go\">XOR        EAX, ECX</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">mn_x86</span><span class=\"o\">.</span><span class=\"n\">asm</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"go\">['1\\xc8', '3\\xc1', 'g1\\xc8', 'g3\\xc1']</span>\n</pre>\n<p>Disassemble the result:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mn_x86</span><span class=\"o\">.</span><span class=\"n\">dis</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"mi\">32</span><span class=\"p\">))</span>\n<span class=\"go\">XOR        EAX, ECX</span>\n</pre>\n<p>Using <code>Machine</code> abstraction:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">miasm.analysis.machine</span> <span class=\"kn\">import</span> <span class=\"n\">Machine</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mn</span> <span class=\"o\">=</span> <span class=\"n\">Machine</span><span class=\"p\">(</span><span class=\"s1\">'x86_32'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">mn</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mn</span><span class=\"o\">.</span><span class=\"n\">dis</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\x33\\x30</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"mi\">32</span><span class=\"p\">))</span>\n<span class=\"go\">XOR        ESI, DWORD PTR [EAX]</span>\n</pre>\n<p>For Mips:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mn</span> <span class=\"o\">=</span> <span class=\"n\">Machine</span><span class=\"p\">(</span><span class=\"s1\">'mips32b'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">mn</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mn</span><span class=\"o\">.</span><span class=\"n\">dis</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x97\\xa3\\x00</span><span class=\"s1\"> '</span><span class=\"p\">,</span> <span class=\"s2\">\"b\"</span><span class=\"p\">))</span>\n<span class=\"go\">LHU        V1, 0x20(SP)</span>\n</pre>\n<h2>Intermediate representation</h2>\n<p>Create an instruction:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">machine</span> <span class=\"o\">=</span> <span class=\"n\">Machine</span><span class=\"p\">(</span><span class=\"s1\">'arml'</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">instr</span> <span class=\"o\">=</span> <span class=\"n\">machine</span><span class=\"o\">.</span><span class=\"n\">mn</span><span class=\"o\">.</span><span class=\"n\">dis</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\x00</span><span class=\"s1\"> </span><span class=\"se\">\\x88\\xe0</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"s1\">'l'</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">instr</span><span class=\"p\">)</span>\n<span class=\"go\">ADD        R2, R8, R0</span>\n</pre>\n<p>Create an intermediate representation object:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ira</span> <span class=\"o\">=</span> <span class=\"n\">machine</span><span class=\"o\">.</span><span class=\"n\">ira</span><span class=\"p\">(</span><span class=\"n\">loc_db</span><span class=\"p\">)</span>\n</pre>\n<p>Create an empty ircfg</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ircfg</span> <span class=\"o\">=</span> <span class=\"n\">ira</span><span class=\"o\">.</span><span class=\"n\">new_ircfg</span><span class=\"p\">()</span>\n</pre>\n<p>Add instruction to the pool:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ira</span><span class=\"o\">.</span><span class=\"n\">add_instr_to_ircfg</span><span class=\"p\">(</span><span class=\"n\">instr</span><span class=\"p\">,</span> <span class=\"n\">ircfg</span><span class=\"p\">)</span>\n</pre>\n<p>Print current pool:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">lbl</span><span class=\"p\">,</span> <span class=\"n\">irblock</span> <span class=\"ow\">in</span> <span class=\"n\">ircfg</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n<span class=\"gp\">... </span>    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">irblock</span><span class=\"o\">.</span><span class=\"n\">to_string</span><span class=\"p\">(</span><span class=\"n\">loc_db</span><span class=\"p\">))</span>\n<span class=\"go\">loc_0:</span>\n<span class=\"go\">R2 = R8 + R0</span>\n\n<span class=\"go\">IRDst = loc_4</span>\n</pre>\n<p>Working with IR, for instance by getting side effects:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">lbl</span><span class=\"p\">,</span> <span class=\"n\">irblock</span> <span class=\"ow\">in</span> <span class=\"n\">ircfg</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">iteritems</span><span class=\"p\">():</span>\n<span class=\"gp\">... </span>    <span class=\"k\">for</span> <span class=\"n\">assignblk</span> <span class=\"ow\">in</span> <span class=\"n\">irblock</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>        <span class=\"n\">rw</span> <span class=\"o\">=</span> <span class=\"n\">assignblk</span><span class=\"o\">.</span><span class=\"n\">get_rw</span><span class=\"p\">()</span>\n<span class=\"gp\">... </span>        <span class=\"k\">for</span> <span class=\"n\">dst</span><span class=\"p\">,</span> <span class=\"n\">reads</span> <span class=\"ow\">in</span> <span class=\"n\">rw</span><span class=\"o\">.</span><span class=\"n\">iteritems</span><span class=\"p\">():</span>\n<span class=\"gp\">... </span>            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'read:   '</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">reads</span><span class=\"p\">])</span>\n<span class=\"gp\">... </span>            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'written:'</span><span class=\"p\">,</span> <span class=\"n\">dst</span><span class=\"p\">)</span>\n<span class=\"gp\">... </span>            <span class=\"nb\">print</span><span class=\"p\">()</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">read:    ['R8', 'R0']</span>\n<span class=\"go\">written: R2</span>\n\n<span class=\"go\">read:    []</span>\n<span class=\"go\">written: IRDst</span>\n</pre>\n<h2>Emulation</h2>\n<p>Giving a shellcode:</p>\n<pre><span class=\"go\">00000000 8d4904      lea    ecx, [ecx+0x4]</span>\n<span class=\"go\">00000003 8d5b01      lea    ebx, [ebx+0x1]</span>\n<span class=\"go\">00000006 80f901      cmp    cl, 0x1</span>\n<span class=\"go\">00000009 7405        jz     0x10</span>\n<span class=\"go\">0000000b 8d5bff      lea    ebx, [ebx-1]</span>\n<span class=\"go\">0000000e eb03        jmp    0x13</span>\n<span class=\"go\">00000010 8d5b01      lea    ebx, [ebx+0x1]</span>\n<span class=\"go\">00000013 89d8        mov    eax, ebx</span>\n<span class=\"go\">00000015 c3          ret</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\x8d</span><span class=\"s1\">I</span><span class=\"se\">\\x04\\x8d</span><span class=\"s1\">[</span><span class=\"se\">\\x01\\x80\\xf9\\x01</span><span class=\"s1\">t</span><span class=\"se\">\\x05\\x8d</span><span class=\"s1\">[</span><span class=\"se\">\\xff\\xeb\\x03\\x8d</span><span class=\"s1\">[</span><span class=\"se\">\\x01\\x89\\xd8\\xc3</span><span class=\"s1\">'</span>\n</pre>\n<p>Import the shellcode thanks to the <code>Container</code> abstraction:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">miasm.analysis.binary</span> <span class=\"kn\">import</span> <span class=\"n\">Container</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Container</span><span class=\"o\">.</span><span class=\"n\">from_string</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">c</span>\n<span class=\"go\">&lt;miasm.analysis.binary.ContainerUnknown object at 0x7f34cefe6090&gt;</span>\n</pre>\n<p>Disassembling the shellcode at address <code>0</code>:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">miasm.analysis.machine</span> <span class=\"kn\">import</span> <span class=\"n\">Machine</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">machine</span> <span class=\"o\">=</span> <span class=\"n\">Machine</span><span class=\"p\">(</span><span class=\"s1\">'x86_32'</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">mdis</span> <span class=\"o\">=</span> <span class=\"n\">machine</span><span class=\"o\">.</span><span class=\"n\">dis_engine</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">bin_stream</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">asmcfg</span> <span class=\"o\">=</span> <span class=\"n\">mdis</span><span class=\"o\">.</span><span class=\"n\">dis_multiblock</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">for</span> <span class=\"n\">block</span> <span class=\"ow\">in</span> <span class=\"n\">asmcfg</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"o\">.</span><span class=\"n\">to_string</span><span class=\"p\">(</span><span class=\"n\">asmcfg</span><span class=\"o\">.</span><span class=\"n\">loc_db</span><span class=\"p\">))</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">loc_0</span>\n<span class=\"go\">LEA        ECX, DWORD PTR [ECX + 0x4]</span>\n<span class=\"go\">LEA        EBX, DWORD PTR [EBX + 0x1]</span>\n<span class=\"go\">CMP        CL, 0x1</span>\n<span class=\"go\">JZ         loc_10</span>\n<span class=\"go\">-&gt;      c_next:loc_b    c_to:loc_10</span>\n<span class=\"go\">loc_10</span>\n<span class=\"go\">LEA        EBX, DWORD PTR [EBX + 0x1]</span>\n<span class=\"go\">-&gt;      c_next:loc_13</span>\n<span class=\"go\">loc_b</span>\n<span class=\"go\">LEA        EBX, DWORD PTR [EBX + 0xFFFFFFFF]</span>\n<span class=\"go\">JMP        loc_13</span>\n<span class=\"go\">-&gt;      c_to:loc_13</span>\n<span class=\"go\">loc_13</span>\n<span class=\"go\">MOV        EAX, EBX</span>\n<span class=\"go\">RET</span>\n</pre>\n<p>Initializing the Jit engine with a stack:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">jitter</span> <span class=\"o\">=</span> <span class=\"n\">machine</span><span class=\"o\">.</span><span class=\"n\">jitter</span><span class=\"p\">(</span><span class=\"n\">jit_type</span><span class=\"o\">=</span><span class=\"s1\">'python'</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">init_stack</span><span class=\"p\">()</span>\n</pre>\n<p>Add the shellcode in an arbitrary memory location:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">run_addr</span> <span class=\"o\">=</span> <span class=\"mh\">0x40000000</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">miasm.jitter.csts</span> <span class=\"kn\">import</span> <span class=\"n\">PAGE_READ</span><span class=\"p\">,</span> <span class=\"n\">PAGE_WRITE</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">vm</span><span class=\"o\">.</span><span class=\"n\">add_memory_page</span><span class=\"p\">(</span><span class=\"n\">run_addr</span><span class=\"p\">,</span> <span class=\"n\">PAGE_READ</span> <span class=\"o\">|</span> <span class=\"n\">PAGE_WRITE</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">)</span>\n</pre>\n<p>Create a sentinelle to catch the return of the shellcode:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">code_sentinelle</span><span class=\"p\">(</span><span class=\"n\">jitter</span><span class=\"p\">):</span>\n    <span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">run</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n    <span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">pc</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">add_breakpoint</span><span class=\"p\">(</span><span class=\"mh\">0x1337beef</span><span class=\"p\">,</span> <span class=\"n\">code_sentinelle</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">push_uint32_t</span><span class=\"p\">(</span><span class=\"mh\">0x1337beef</span><span class=\"p\">)</span>\n</pre>\n<p>Active logs:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">set_trace_log</span><span class=\"p\">()</span>\n</pre>\n<p>Run at arbitrary address:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">init_run</span><span class=\"p\">(</span><span class=\"n\">run_addr</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">continue_run</span><span class=\"p\">()</span>\n<span class=\"go\">RAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000000 RDX 0000000000000000</span>\n<span class=\"go\">RSI 0000000000000000 RDI 0000000000000000 RSP 000000000123FFF8 RBP 0000000000000000</span>\n<span class=\"go\">zf 0000000000000000 nf 0000000000000000 of 0000000000000000 cf 0000000000000000</span>\n<span class=\"go\">RIP 0000000040000000</span>\n<span class=\"go\">40000000 LEA        ECX, DWORD PTR [ECX+0x4]</span>\n<span class=\"go\">RAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000004 RDX 0000000000000000</span>\n<span class=\"go\">RSI 0000000000000000 RDI 0000000000000000 RSP 000000000123FFF8 RBP 0000000000000000</span>\n<span class=\"go\">zf 0000000000000000 nf 0000000000000000 of 0000000000000000 cf 0000000000000000</span>\n<span class=\"go\">....</span>\n<span class=\"go\">4000000e JMP        loc_0000000040000013:0x40000013</span>\n<span class=\"go\">RAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000004 RDX 0000000000000000</span>\n<span class=\"go\">RSI 0000000000000000 RDI 0000000000000000 RSP 000000000123FFF8 RBP 0000000000000000</span>\n<span class=\"go\">zf 0000000000000000 nf 0000000000000000 of 0000000000000000 cf 0000000000000000</span>\n<span class=\"go\">RIP 0000000040000013</span>\n<span class=\"go\">40000013 MOV        EAX, EBX</span>\n<span class=\"go\">RAX 0000000000000000 RBX 0000000000000000 RCX 0000000000000004 RDX 0000000000000000</span>\n<span class=\"go\">RSI 0000000000000000 RDI 0000000000000000 RSP 000000000123FFF8 RBP 0000000000000000</span>\n<span class=\"go\">zf 0000000000000000 nf 0000000000000000 of 0000000000000000 cf 0000000000000000</span>\n<span class=\"go\">RIP 0000000040000013</span>\n<span class=\"go\">40000015 RET</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n</pre>\n<p>Interacting with the jitter:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">vm</span>\n<span class=\"go\">ad 1230000 size 10000 RW_ hpad 0x2854b40</span>\n<span class=\"go\">ad 40000000 size 16 RW_ hpad 0x25e0ed0</span>\n\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">hex</span><span class=\"p\">(</span><span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">cpu</span><span class=\"o\">.</span><span class=\"n\">EAX</span><span class=\"p\">)</span>\n<span class=\"go\">'0x0L'</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">jitter</span><span class=\"o\">.</span><span class=\"n\">cpu</span><span class=\"o\">.</span><span class=\"n\">ESI</span> <span class=\"o\">=</span> <span class=\"mi\">12</span>\n</pre>\n<h2>Symbolic execution</h2>\n<p>Initializing the IR pool:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ira</span> <span class=\"o\">=</span> <span class=\"n\">machine</span><span class=\"o\">.</span><span class=\"n\">ira</span><span class=\"p\">(</span><span class=\"n\">loc_db</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ircfg</span> <span class=\"o\">=</span> <span class=\"n\">ira</span><span class=\"o\">.</span><span class=\"n\">new_ircfg_from_asmcfg</span><span class=\"p\">(</span><span class=\"n\">asmcfg</span><span class=\"p\">)</span>\n</pre>\n<p>Initializing the engine with default symbolic values:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">miasm.ir.symbexec</span> <span class=\"kn\">import</span> <span class=\"n\">SymbolicExecutionEngine</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sb</span> <span class=\"o\">=</span> <span class=\"n\">SymbolicExecutionEngine</span><span class=\"p\">(</span><span class=\"n\">ira</span><span class=\"p\">)</span>\n</pre>\n<p>Launching the execution:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">symbolic_pc</span> <span class=\"o\">=</span> <span class=\"n\">sb</span><span class=\"o\">.</span><span class=\"n\">run_at</span><span class=\"p\">(</span><span class=\"n\">ircfg</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">symbolic_pc</span><span class=\"p\">)</span>\n<span class=\"go\">((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n</pre>\n<p>Same, with step logs (only changes are displayed):</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sb</span> <span class=\"o\">=</span> <span class=\"n\">SymbolicExecutionEngine</span><span class=\"p\">(</span><span class=\"n\">ira</span><span class=\"p\">,</span> <span class=\"n\">machine</span><span class=\"o\">.</span><span class=\"n\">mn</span><span class=\"o\">.</span><span class=\"n\">regs</span><span class=\"o\">.</span><span class=\"n\">regs_init</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">symbolic_pc</span> <span class=\"o\">=</span> <span class=\"n\">sb</span><span class=\"o\">.</span><span class=\"n\">run_at</span><span class=\"p\">(</span><span class=\"n\">ircfg</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">step</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">Instr LEA        ECX, DWORD PTR [ECX + 0x4]</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">ECX = ECX + 0x4</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">ECX                = ECX + 0x4</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr LEA        EBX, DWORD PTR [EBX + 0x1]</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">EBX = EBX + 0x1</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">EBX                = EBX + 0x1</span>\n<span class=\"go\">ECX                = ECX + 0x4</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr CMP        CL, 0x1</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">zf = (ECX[0:8] + -0x1)?(0x0,0x1)</span>\n<span class=\"go\">nf = (ECX[0:8] + -0x1)[7:8]</span>\n<span class=\"go\">pf = parity((ECX[0:8] + -0x1) &amp; 0xFF)</span>\n<span class=\"go\">of = ((ECX[0:8] ^ (ECX[0:8] + -0x1)) &amp; (ECX[0:8] ^ 0x1))[7:8]</span>\n<span class=\"go\">cf = (((ECX[0:8] ^ 0x1) ^ (ECX[0:8] + -0x1)) ^ ((ECX[0:8] ^ (ECX[0:8] + -0x1)) &amp; (ECX[0:8] ^ 0x1)))[7:8]</span>\n<span class=\"go\">af = ((ECX[0:8] ^ 0x1) ^ (ECX[0:8] + -0x1))[4:5]</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = (((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[4:5]</span>\n<span class=\"go\">pf                 = parity((ECX + 0x4)[0:8] + 0xFF)</span>\n<span class=\"go\">zf                 = ((ECX + 0x4)[0:8] + 0xFF)?(0x0,0x1)</span>\n<span class=\"go\">ECX                = ECX + 0x4</span>\n<span class=\"go\">of                 = ((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) &amp; ((ECX + 0x4)[0:8] ^ 0x1))[7:8]</span>\n<span class=\"go\">nf                 = ((ECX + 0x4)[0:8] + 0xFF)[7:8]</span>\n<span class=\"go\">cf                 = (((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) &amp; ((ECX + 0x4)[0:8] ^ 0x1)) ^ ((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[7:8]</span>\n<span class=\"go\">EBX                = EBX + 0x1</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr JZ         loc_key_1</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">IRDst = zf?(loc_key_1,loc_key_2)</span>\n<span class=\"go\">EIP = zf?(loc_key_1,loc_key_2)</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = (((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[4:5]</span>\n<span class=\"go\">EIP                = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n<span class=\"go\">pf                 = parity((ECX + 0x4)[0:8] + 0xFF)</span>\n<span class=\"go\">IRDst              = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n<span class=\"go\">zf                 = ((ECX + 0x4)[0:8] + 0xFF)?(0x0,0x1)</span>\n<span class=\"go\">ECX                = ECX + 0x4</span>\n<span class=\"go\">of                 = ((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) &amp; ((ECX + 0x4)[0:8] ^ 0x1))[7:8]</span>\n<span class=\"go\">nf                 = ((ECX + 0x4)[0:8] + 0xFF)[7:8]</span>\n<span class=\"go\">cf                 = (((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) &amp; ((ECX + 0x4)[0:8] ^ 0x1)) ^ ((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[7:8]</span>\n<span class=\"go\">EBX                = EBX + 0x1</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n</pre>\n<p>Retry execution with a concrete ECX. Here, the symbolic / concolic execution reach the shellcode's end:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">miasm.expression.expression</span> <span class=\"kn\">import</span> <span class=\"n\">ExprInt</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sb</span><span class=\"o\">.</span><span class=\"n\">symbols</span><span class=\"p\">[</span><span class=\"n\">machine</span><span class=\"o\">.</span><span class=\"n\">mn</span><span class=\"o\">.</span><span class=\"n\">regs</span><span class=\"o\">.</span><span class=\"n\">ECX</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ExprInt</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">32</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">symbolic_pc</span> <span class=\"o\">=</span> <span class=\"n\">sb</span><span class=\"o\">.</span><span class=\"n\">run_at</span><span class=\"p\">(</span><span class=\"n\">ircfg</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">step</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"go\">Instr LEA        ECX, DWORD PTR [ECX + 0x4]</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">ECX = ECX + 0x4</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = (((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[4:5]</span>\n<span class=\"go\">EIP                = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n<span class=\"go\">pf                 = parity((ECX + 0x4)[0:8] + 0xFF)</span>\n<span class=\"go\">IRDst              = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n<span class=\"go\">zf                 = ((ECX + 0x4)[0:8] + 0xFF)?(0x0,0x1)</span>\n<span class=\"go\">ECX                = 0x1</span>\n<span class=\"go\">of                 = ((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) &amp; ((ECX + 0x4)[0:8] ^ 0x1))[7:8]</span>\n<span class=\"go\">nf                 = ((ECX + 0x4)[0:8] + 0xFF)[7:8]</span>\n<span class=\"go\">cf                 = (((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) &amp; ((ECX + 0x4)[0:8] ^ 0x1)) ^ ((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[7:8]</span>\n<span class=\"go\">EBX                = EBX + 0x1</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr LEA        EBX, DWORD PTR [EBX + 0x1]</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">EBX = EBX + 0x1</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = (((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[4:5]</span>\n<span class=\"go\">EIP                = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n<span class=\"go\">pf                 = parity((ECX + 0x4)[0:8] + 0xFF)</span>\n<span class=\"go\">IRDst              = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n<span class=\"go\">zf                 = ((ECX + 0x4)[0:8] + 0xFF)?(0x0,0x1)</span>\n<span class=\"go\">ECX                = 0x1</span>\n<span class=\"go\">of                 = ((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) &amp; ((ECX + 0x4)[0:8] ^ 0x1))[7:8]</span>\n<span class=\"go\">nf                 = ((ECX + 0x4)[0:8] + 0xFF)[7:8]</span>\n<span class=\"go\">cf                 = (((((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8]) &amp; ((ECX + 0x4)[0:8] ^ 0x1)) ^ ((ECX + 0x4)[0:8] + 0xFF) ^ (ECX + 0x4)[0:8] ^ 0x1)[7:8]</span>\n<span class=\"go\">EBX                = EBX + 0x2</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr CMP        CL, 0x1</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">zf = (ECX[0:8] + -0x1)?(0x0,0x1)</span>\n<span class=\"go\">nf = (ECX[0:8] + -0x1)[7:8]</span>\n<span class=\"go\">pf = parity((ECX[0:8] + -0x1) &amp; 0xFF)</span>\n<span class=\"go\">of = ((ECX[0:8] ^ (ECX[0:8] + -0x1)) &amp; (ECX[0:8] ^ 0x1))[7:8]</span>\n<span class=\"go\">cf = (((ECX[0:8] ^ 0x1) ^ (ECX[0:8] + -0x1)) ^ ((ECX[0:8] ^ (ECX[0:8] + -0x1)) &amp; (ECX[0:8] ^ 0x1)))[7:8]</span>\n<span class=\"go\">af = ((ECX[0:8] ^ 0x1) ^ (ECX[0:8] + -0x1))[4:5]</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = 0x0</span>\n<span class=\"go\">EIP                = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n<span class=\"go\">pf                 = 0x1</span>\n<span class=\"go\">IRDst              = ((ECX + 0x4)[0:8] + 0xFF)?(0xB,0x10)</span>\n<span class=\"go\">zf                 = 0x1</span>\n<span class=\"go\">ECX                = 0x1</span>\n<span class=\"go\">of                 = 0x0</span>\n<span class=\"go\">nf                 = 0x0</span>\n<span class=\"go\">cf                 = 0x0</span>\n<span class=\"go\">EBX                = EBX + 0x2</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr JZ         loc_key_1</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">IRDst = zf?(loc_key_1,loc_key_2)</span>\n<span class=\"go\">EIP = zf?(loc_key_1,loc_key_2)</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = 0x0</span>\n<span class=\"go\">EIP                = 0x10</span>\n<span class=\"go\">pf                 = 0x1</span>\n<span class=\"go\">IRDst              = 0x10</span>\n<span class=\"go\">zf                 = 0x1</span>\n<span class=\"go\">ECX                = 0x1</span>\n<span class=\"go\">of                 = 0x0</span>\n<span class=\"go\">nf                 = 0x0</span>\n<span class=\"go\">cf                 = 0x0</span>\n<span class=\"go\">EBX                = EBX + 0x2</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr LEA        EBX, DWORD PTR [EBX + 0x1]</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">EBX = EBX + 0x1</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = 0x0</span>\n<span class=\"go\">EIP                = 0x10</span>\n<span class=\"go\">pf                 = 0x1</span>\n<span class=\"go\">IRDst              = 0x10</span>\n<span class=\"go\">zf                 = 0x1</span>\n<span class=\"go\">ECX                = 0x1</span>\n<span class=\"go\">of                 = 0x0</span>\n<span class=\"go\">nf                 = 0x0</span>\n<span class=\"go\">cf                 = 0x0</span>\n<span class=\"go\">EBX                = EBX + 0x3</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr LEA        EBX, DWORD PTR [EBX + 0x1]</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">IRDst = loc_key_3</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = 0x0</span>\n<span class=\"go\">EIP                = 0x10</span>\n<span class=\"go\">pf                 = 0x1</span>\n<span class=\"go\">IRDst              = 0x13</span>\n<span class=\"go\">zf                 = 0x1</span>\n<span class=\"go\">ECX                = 0x1</span>\n<span class=\"go\">of                 = 0x0</span>\n<span class=\"go\">nf                 = 0x0</span>\n<span class=\"go\">cf                 = 0x0</span>\n<span class=\"go\">EBX                = EBX + 0x3</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr MOV        EAX, EBX</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">EAX = EBX</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = 0x0</span>\n<span class=\"go\">EIP                = 0x10</span>\n<span class=\"go\">pf                 = 0x1</span>\n<span class=\"go\">IRDst              = 0x13</span>\n<span class=\"go\">zf                 = 0x1</span>\n<span class=\"go\">ECX                = 0x1</span>\n<span class=\"go\">of                 = 0x0</span>\n<span class=\"go\">nf                 = 0x0</span>\n<span class=\"go\">cf                 = 0x0</span>\n<span class=\"go\">EBX                = EBX + 0x3</span>\n<span class=\"go\">EAX                = EBX + 0x3</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">Instr RET</span>\n<span class=\"go\">Assignblk:</span>\n<span class=\"go\">IRDst = @32[ESP[0:32]]</span>\n<span class=\"go\">ESP = {ESP[0:32] + 0x4 0 32}</span>\n<span class=\"go\">EIP = @32[ESP[0:32]]</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">af                 = 0x0</span>\n<span class=\"go\">EIP                = @32[ESP]</span>\n<span class=\"go\">pf                 = 0x1</span>\n<span class=\"go\">IRDst              = @32[ESP]</span>\n<span class=\"go\">zf                 = 0x1</span>\n<span class=\"go\">ECX                = 0x1</span>\n<span class=\"go\">of                 = 0x0</span>\n<span class=\"go\">nf                 = 0x0</span>\n<span class=\"go\">cf                 = 0x0</span>\n<span class=\"go\">EBX                = EBX + 0x3</span>\n<span class=\"go\">ESP                = ESP + 0x4</span>\n<span class=\"go\">EAX                = EBX + 0x3</span>\n<span class=\"go\">________________________________________________________________________________</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n</pre>\n<h1>How does it work?</h1>\n<p>Miasm embeds its own disassembler, intermediate language and\ninstruction semantic. It is written in Python.</p>\n<p>To emulate code, it uses LLVM, GCC, Clang or Python to JIT the\nintermediate representation. It can emulate shellcodes and all or parts of\nbinaries. Python callbacks can be executed to interact with the execution, for\ninstance to emulate library functions effects.</p>\n<h1>Documentation</h1>\n<p>TODO</p>\n<p>An auto-generated documentation is available <a href=\"http://miasmdoc.ajax.re\" rel=\"nofollow\">here</a>.</p>\n<h1>Obtaining Miasm</h1>\n<ul>\n<li>Clone the repository: <a href=\"https://github.com/cea-sec/miasm/\" rel=\"nofollow\">Miasm on GitHub</a></li>\n<li>Get one of the Docker images at <a href=\"https://registry.hub.docker.com/u/miasm/\" rel=\"nofollow\">Docker Hub</a></li>\n</ul>\n<h2>Software requirements</h2>\n<p>Miasm uses:</p>\n<ul>\n<li>python-pyparsing</li>\n<li>python-dev</li>\n<li>optionally python-pycparser (version &gt;= 2.17)</li>\n</ul>\n<p>To enable code JIT, one of the following module is mandatory:</p>\n<ul>\n<li>GCC</li>\n<li>Clang</li>\n<li>LLVM with Numba llvmlite, see below</li>\n</ul>\n<p>'optional' Miasm can also use:</p>\n<ul>\n<li>Z3, the <a href=\"https://github.com/Z3Prover/z3\" rel=\"nofollow\">Theorem Prover</a></li>\n</ul>\n<h2>Configuration</h2>\n<p>To use the jitter, GCC or LLVM is recommended</p>\n<ul>\n<li>GCC (any version)</li>\n<li>Clang (any version)</li>\n<li>LLVM\n<ul>\n<li>Debian (testing/unstable): Not tested</li>\n<li>Debian stable/Ubuntu/Kali/whatever: <code>pip install llvmlite</code> or install from <a href=\"https://github.com/numba/llvmlite\" rel=\"nofollow\">llvmlite</a></li>\n<li>Windows: Not tested</li>\n</ul>\n</li>\n<li>Build and install Miasm:</li>\n</ul>\n<pre><span class=\"go\">$ cd miasm_directory</span>\n<span class=\"go\">$ python setup.py build</span>\n<span class=\"go\">$ sudo python setup.py install</span>\n</pre>\n<p>If something goes wrong during one of the jitter modules compilation, Miasm will\nskip the error and disable the corresponding module (see the compilation\noutput).</p>\n<h2>Windows &amp; IDA</h2>\n<p>Most of Miasm's IDA plugins use a subset of Miasm functionality.\nA quick way to have them working is to add:</p>\n<ul>\n<li><code>pyparsing.py</code> to <code>C:\\...\\IDA\\python\\</code> or <code>pip install pyparsing</code></li>\n<li><code>miasm/miasm</code> directory to <code>C:\\...\\IDA\\python\\</code></li>\n</ul>\n<p>All features excepting JITter related ones will be available. For a more complete installation, please refer to above paragraphs.</p>\n<h1>Testing</h1>\n<p>Miasm comes with a set of regression tests. To run all of them:</p>\n<pre><span class=\"go\">cd miasm_directory/test</span>\n<span class=\"go\">python test_all.py</span>\n</pre>\n<p>Some options can be specified:</p>\n<ul>\n<li>Mono threading: <code>-m</code></li>\n<li>Code coverage instrumentation: <code>-c</code></li>\n<li>Only fast tests: <code>-t long</code> (excludes the long tests)</li>\n</ul>\n<h1>They already use Miasm</h1>\n<h2>Tools</h2>\n<ul>\n<li><a href=\"https://github.com/cea-sec/Sibyl\" rel=\"nofollow\">Sibyl</a>: A function divination too</li>\n<li><a href=\"https://github.com/guedou/r2m2\" rel=\"nofollow\">R2M2</a>: Use miasm as a radare2 plugin</li>\n<li><a href=\"https://github.com/mechaphish/cgrex\" rel=\"nofollow\">CGrex</a> : Targeted patcher for CGC binaries</li>\n<li><a href=\"https://github.com/jbcayrou/ethRE\" rel=\"nofollow\">ethRE</a> Reversing tool for Ethereum EVM (with corresponding Miasm2 architecture)</li>\n</ul>\n<h2>Blog posts / papers / conferences</h2>\n<ul>\n<li><a href=\"http://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html\" rel=\"nofollow\">Deobfuscation: recovering an OLLVM-protected program</a></li>\n<li><a href=\"https://doar-e.github.io/blog/2014/10/11/taiming-a-wild-nanomite-protected-mips-binary-with-symbolic-execution-no-such-crackme/\" rel=\"nofollow\">Taming a Wild Nanomite-protected MIPS Binary With Symbolic Execution: No Such Crackme</a></li>\n<li><a href=\"https://www.lexsi.com/securityhub/generation-rapide-de-dga-avec-miasm/\" rel=\"nofollow\">G\u00e9n\u00e9ration rapide de DGA avec Miasm</a>: Quick computation of DGA (French article)</li>\n<li><a href=\"https://www.internetsociety.org/sites/default/files/blogs-media/enabling-client-side-crash-resistance-overcome-diversification-information-hiding.pdf\" rel=\"nofollow\">Enabling Client-Side Crash-Resistance to Overcome Diversification and Information Hiding</a>: Detect undirected call potential arguments</li>\n<li><a href=\"https://www.sstic.org/2012/presentation/miasm_framework_de_reverse_engineering/\" rel=\"nofollow\">Miasm: Framework de reverse engineering</a> (French)</li>\n<li><a href=\"https://www.sstic.org/2014/presentation/Tutorial_miasm/\" rel=\"nofollow\">Tutorial miasm</a> (French video)</li>\n<li><a href=\"https://www.sstic.org/2016/presentation/graphes_de_dpendances__petit_poucet_style/\" rel=\"nofollow\">Graphes de d\u00e9pendances : Petit Poucet style</a>: DepGraph (French)</li>\n</ul>\n<h2>Books</h2>\n<ul>\n<li><a href=\"http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1118787315,subjectCd-CSJ0.html\" rel=\"nofollow\">Practical Reverse Engineering: X86, X64, Arm, Windows Kernel, Reversing Tools, and Obfuscation</a>: Introduction to Miasm (Chapter 5 \"Obfuscation\")</li>\n<li><a href=\"https://github.com/oreilly-japan/black-hat-python-jp-support/tree/master/appendix-A\" rel=\"nofollow\">BlackHat Python - Appendix</a>: Japan security book's samples</li>\n</ul>\n<h1>Misc</h1>\n<ul>\n<li>Man, does miasm has a link with rr0d?</li>\n<li>Yes! crappy code and uggly documentation.</li>\n</ul>\n\n          </div>"}, "last_serial": 6284016, "releases": {"0.1.2": [{"comment_text": "", "digests": {"md5": "f40fea1eb0d4a1d47e08e27b45aad37c", "sha256": "107145aa953d2a07e8696b2af25e0f84d3c67ffcb8860fefed6b747552bb0b1d"}, "downloads": -1, "filename": "miasm-0.1.2.tar.gz", "has_sig": false, "md5_digest": "f40fea1eb0d4a1d47e08e27b45aad37c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 552379, "upload_time": "2019-12-11T14:04:34", "upload_time_iso_8601": "2019-12-11T14:04:34.427838Z", "url": "https://files.pythonhosted.org/packages/94/1d/18e95e00f5fa29b461d94ecadca1ed21ff6a9bc31df4de5e24f51e9d2273/miasm-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "c1504709a35ba21735a43fe55f0a9926", "sha256": "9c1263862d373949e1b03899532a0f762c10f2388b450d8d7c89d503df1c5d9a"}, "downloads": -1, "filename": "miasm-0.1.3.tar.gz", "has_sig": false, "md5_digest": "c1504709a35ba21735a43fe55f0a9926", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 554132, "upload_time": "2019-12-12T09:04:23", "upload_time_iso_8601": "2019-12-12T09:04:23.129283Z", "url": "https://files.pythonhosted.org/packages/a2/d6/207063f6e95a54aafe9c53488c32bb03352d27e909333093af5c097bbb36/miasm-0.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c1504709a35ba21735a43fe55f0a9926", "sha256": "9c1263862d373949e1b03899532a0f762c10f2388b450d8d7c89d503df1c5d9a"}, "downloads": -1, "filename": "miasm-0.1.3.tar.gz", "has_sig": false, "md5_digest": "c1504709a35ba21735a43fe55f0a9926", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 554132, "upload_time": "2019-12-12T09:04:23", "upload_time_iso_8601": "2019-12-12T09:04:23.129283Z", "url": "https://files.pythonhosted.org/packages/a2/d6/207063f6e95a54aafe9c53488c32bb03352d27e909333093af5c097bbb36/miasm-0.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:23 2020"}