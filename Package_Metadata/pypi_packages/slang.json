{"info": {"author": "Thor Whalen", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3.7", "Topic :: Software Development"], "description": "# Slang: Light weight tools to build signal languages\n\nSlang is a structural approach to sound/signal machine learning. \nHere, signals are structured into inter-related annotated parts. \nThe signal's stream is transformed into a stream of symbols with associated \nqualifications, quantifications and/or relations that can be used to analyze, interpret, and \ncommunicate the signal's informational content: \nA language.\n\nWe humans have developed many systems of symbols to represent or transmit various forms of information. \nFor instance,\n- Natural spoken language, from phonemes to morphemes, to words and meta-word structures (simply put, grammar).\n- Written scripts to symbolize either the sounds of the spoken words, or the ideas they mean to symbolize. \n- Similarly, various musical notation evolved in different times and parts of the world. \nThese codified what was considered to be the essentials of musical expression, in\nsuch a way that it could be communicated in written form.\n\nSymbols, though not fully faithful representatives of what they symbolize, \ncan go a long way in communicating what's essential -- whether it's meaning, feeling, or how to make pizza.\nWhat is more; what the symbols (say words) themselves lack in accuracy, \ntheir combination and context make up for. \n\nSlang's objective is to provide that ability for signal. \nNote we will focus on sound mainly, since sound recognition is the birthplace of Slang, \nand it makes communicating ideas simpler and possibly more intuitive. \nBut we keep generalization in mind.\n\n## A story to paint the horizon\n\nImagine a device that could be dropped into a remote inhabited region with no prior knowledge of the local language. \nAfter hours/days of listening, it would figure out what phonemes the locals use, \nhow these phonemes co-occur (learning words), and eventually patterns guiding the structure of word sequences (grammar). \nIt has learned the syntax of the local language, unsupervised. \n\nNow show it examples of concrete things people are talking about (this is called \"grounding a language\"), \nand it will now be able to develop semantics.\n\nThe common thread through this learning evolutiion is the ability to detect and annotate patterns \nand relate these patterns to each other from lower to higher levels of abstraction. \n\n# Sound Language\n\nNot surprisingly, speech recognition is the sub-domain of sound recognition \nthat is closest to the syntactic method we propose. \nSpeech recognition must featurize sound at a granular level to capture micro occurrences such as phones, \nsubsequently combined to form phonemes, morphemes, and recognisable phrases. \nAdvanced speech recognition uses natural language processing to improve accuracy in that \nit exploits language contextual information in order to more accurately map sound to words.\n\nA language of sound would aspire to link sound to meaning in a similar combinatorial way, but offers a few differences \n\u2014 some simplifying and other complexifying the task. \nIn speech recognition the language, its constructs (phones, phonemes, words) \nand its combinatorial rules (grammar) are fixed and known. \nIn sound recognition, the language needs to be inferred (generated) from the context, \nits constructs defined, and its combinatorial rules learned. \nHowever, there is a fortuitous consideration: though natural language\u2019s expressive power is expansive, \nin sound recognition we need only to describe events relevant to sound.\n\nEssentially, SLANG represents both acoustic and semantic facets of the sound recognition pipeline as networks of \ninterconnected elements. An attractive implication is the possibility to apply the extensive research in \nnatural language processing (NLP) to carry out general recognition tasks. \nThis representation puts emphasis on structural aspects, \nyet the most significant quantitative characteristics of sound are kept in the properties of the elements, \nconnections, and accompanying codebooks.\n\n# Structural and Syntactical Pattern Recognition\n\nIn contrast with the standard paradigms of machine learning, \nthe less common \u200bstructured learning approach attempts to use structural information of both the classified objects and \nthe classification domain. An even lesser known research area takes this idea a step further by articulating \nthe structural aspect as a formal grammar that defines rules that derive signal constructs to classification constructs.\nWe propose an approach where both sound and its semantics are expressed in a manner that enables the detection system \nto take advantage of the structural aspects of both.\nThe importance of a structural framework is further supported as we attempt to go beyond detecting isolated \n\u200bsound occurrence\u200b toward interpreting sequences of these occurrences and discovering \u200bsound generating activities\u200b. \nThese sound generating activities can be expressed through ontologies \nand sequential rules composed from other semantical elements.\n\n\nThis approach has been coined as \u201csyntactical pattern recognition\u201d or \u201cgrammar induction\u201d. These techniques have been \nused in Chinese character recognition [\u200b4\u200b], analysis of textures [\u200b10\u200b], medical diagnosis (heart disease detection) [\u200b16\u200b],\n visual scene recognition [\u200b22\u200b], movement recognition in video [\u200b19\u200b], activity monitoring in video [\u200b19\u200b], \n and closer to sound (since uni-dimensional time-series), seismic signal analysis (eg. in oil detection) [\u200b8\u200b] \n and ECG analysis [\u200b18\u200b, \u200b16\u200b].\nAs far as we know, no research has been carried out to apply syntactical pattern recognition techniques \nto general sound recognition, and we intend to take inspiration in this literature in an effort to derive semantics \nfrom sound.\n\n# Semantic Structure\n\nThe elements of the semantic structure will be taken from plain English. \nThese will be words and phrases that are connected to sound events. These elements could describe, for example,\n- particular types of sound (\u200bbark,\u200b\u200b rustle\u200b,\u200b cling, \u200b\u200bbang)\u200b\n- sound sources (\u200bdog, wind\u200b,\u200b thunder,\u200b r\u200bunning\u200b \u200bwater\u200b)\n- sound generating activities that may have a very wide temporal range \u2014 such as \u200bstorm\u200b or cooking.\u200b\n\nThe \u200badvantage\u200b of structured learning \u200blies in its exploitation of the structure of the output space. \nClip-clop, clippety-clop, clop, clopping, clunking\u200b and \u200bclumping\u200b can be considered to be synonyms of each other \nin the context of sound. A \u200bclop\u200b (and its twins) is closer to \u200bknock\u200b and \u200bplunk than it is to \u200bhiss\u200b and \u200bbuzz.\u200b \nYet b\u200buzz\u200b and \u200bknock\u200b, though not similar acoustically, are strongly related to each other through their relation to \u200bdoor\u200b \nand activities surrounding it. If we consider all these sound labels as separate, we would be depriving ourselves \nfrom the valuable information encoded in their interrelationships. \nSemantic structure allows models to avoid problems of synonymy and polysemy, \nbut also allow the emergence of a fuller picture of the sound\u2019s contents \n\u2014 through (formal grammar) derivations such as `rustle + blowing \u2014> wind` and `wind + thunder \u2014> storm`.\n\nAs a first step, these relationships can be mined from NLP tools and APIs such as WordNet and WordsAPI. \nOnce connected to sound however, these relationships should be enhanced according to the acoustic similarities of \nthe sounds the semantic constructs are related to. \nMoreover, in practice semantics are usually grounded in action, \nso the semantic structure should be able to be edited and augmented for the application\u2019s needs.\n\n# Acoustics Structure\n\nOn the acoustic side of SLANG, a similar structured approach should be taken, identifying, symbolizing, \nand interconnecting acoustical units into ever higher combinations, eventually connecting them to the semantic \nidentifiers.\n\nThis process is based on the following steps:\n- Chunk audio streams into very short (and possibly overlapping) frames and compute feature\nvectors of these frames. We will call these frame features.\n- Quantize the frame features, creating a codebook of frame features\n- Enhance the codebook with frame similarity information\n- Use both supervised and unsupervised techniques to carry out pattern detection and annotate code subsequences with these\n- Carry out classification and structured learning techniques to link these patterns to semantic identifiers and structures\n\nThese steps will be detailed in the following sections.\n\n## Alphabetization\n\nAn audio stream is chunked into short (and possibly overlapping) frames over which we compute suitable feature vectors. \nThese features (e.g. spectrogram, chromagram, mel-spectrum, MFCC slices [17]) encode \u201cinstantaneous\u201d \ncharacteristics of sound \u2014 such as intensity and spectral features \u2014 but do not encompass wide-range characteristics \nsuch as autocorrelation and intensity monotonicity. \nThese wide-range characteristics will be captured through combinatorial analysis later on.\nThe frame features are then quantized to a discrete set of symbols [6]. \nVector quantization will map the frame features to a finite number of symbols that will represent all frame features \nwithin a bounded region. These symbols, which we will call \u201csnips\u201d (short for \u201csound nips\u201d) will play the role of our \nsound language alphabet. We record statistical information about the feature space covered by each snip in order to \nqualify and quantify feature-based relationships.\n\n## Snips network\n\nQuantization maps multi-dimensional numerical features to unidimensional nominal ones, thereby seemingly losing all \nsimilarity relationships that the numerical features contain. \nAn approximation of these similarities can be recovered through the numerical feature statistics \nwe associated with each snip, but it would be computationally intensive to have to generate these using \nthe original feature vectors every time we need this information.\n\nInstead, we will use the statistical relationships recorded about the feature space covered by the snips to build a \nnetwork documenting these similarities. \nIn this network we can store information about snips themselves (the nodes) as well as pairs of snips (the links). \nThis serves to keep and be able to readily key into, useful information about the snips and their relationships.\n\nFor example, since sequential patterns of intensity are important in sound recognition, \nwe will store statistics (such as mean and standard deviation) of the intensity of the feature subspace or train data \nframes associated to the each snip. Further, we label the pairs of snips (links of the network) with information about \nthe frames associated to them \u2014 such as various similarity metrics. \nOne notable property to retain is the \u201csnip confusion\u201d metric, \nwhich is the probability that a snip could have been another, \ngiven the arbitrary offset of the initial segmentation into frames.\n\nThe properties stored in the snips network enable us to generate a \u201chalo\u201d around snips where pattern search can operate. \nFurther, enhancing the snip codebook with such information that links back to the original raw data, \nopens the possibility to merge codebooks or translate (at least approximately) one snipping system to another.\n\n\n# Snips Annotations\n\nIn our framework, annotations replace both chunk features and semantic labels. An annotation specifies a segment of \nsound and a property associated to it. Since we now represent sound by a sequence of snips, the segment can be specified \nby a {sound source id, offset snip index, end snip index} triple, and annotations can be grouped or merged to optimize \nindexing, storage and retrieval needs. The property of an annotation can be any data that provides information about \nthe segment.\n\nAnnotations serve a purpose on both sides of the machine learning process: \n- Marking sound segments with acoustical information that may allow models to link sound to meaning. \n- Acquiring precise \u201csupervised data\u201d. Precise because (a) unlike a chunked approach, we can delineate exactly what \npart of the sound we are labeling and (b) we are not limited by single labels, but can express any multi-faceted and \neven structured details about sound segments.\n\nAnnotations may include:\n- **Frequent snip sub-sequences**\u200b: If they are frequent enough, they are important enough to note whether for negative \nor positive inference. The discovery of frequent patterns in sequential data is crucial in Bioinformatics [20]. \nThis can be compared to the use of n-grams and skip-grams in text processing. \nExamples of n-grams applied to sound can be found in [12] and [14].\n- **Frequent snip patterns**: The ability to pinpoint frequent patterns in snip sequences or sets supplies further \npattern mining processes with more \u201csynonymous sets of words\u201d to work with. Snip networks will serve to expand or \nreduce the input snips to find patterns. Compare to NLP information retrieval, \nwhere words of a query are reduced (e.g. stemming [9] and stopword removal) or expanded \n(e.g. related words expansion and edit distance radius [9]).\n- **Pattern-homogeneous sub-sequences**: The distribution of snips of a segment could be considered to belong to a \nsame \u201ctopic\u201d or latent semantic state. See for example the \u201cbag of frames\u201d techniques ([13], [15]), \nwhich cast soundscapes and music information retrieval to a classical NLP term-document approach.\n- **Aggregate features**: Since snips use only short-range features, we seem to have lost the ability to use acoustic \nfeatures that assume significance only over some period of time, but these can be approximated from the snip codebook \nlink to the original frame features statistics and only those with highest significance and utility need to be recorded \n(for example only high autocorrelation).\n- **Semantic annotations**: On the other end of the sound-to-semantics spectrum we can annotate low level semantic \nidentifiers (such as `cling`, `chop` and `splash`) , wide-range segments with words describing a sound-generating \nactivity (such as `cooking`), and context, which is crucial to the proper interpretation of sound events. \nThese annotations are typically generated by a semi-supervised process \u2014 though inferred semantic annotations \ncan be useful to quickly access and validate possible categories of interest.\nWell indexed, this annotation system provides the ability to retrieve audio, \nfeatures or semantic labels from queries expressed as audio, features or semantic labels. \nThis is not only useful as a sound search engine, but gives us all we need to extract acoustic and semantic constructs \nand build models relating these.\n\n\n## Relationship between Annotations and the Syntactic Approach\n\nAnnotated segments provide relationships between acoustical facets of sound semantics through the co-occurrence of \noverlapping annotations in a same segment. Consider all annotations that entirely contain a particular segment. \nAll properties (acoustic and semantic) contained within each annotation are related since they describe \nthe same segment.\n\nAlong with the aforementioned semantic and snips structures, this set of co-occurring properties can be used to \ngenerate a (stochastic formal) grammar over the alphabet of snips and annotations. \nThis grammar provides statistical rules that can be used to derive snips to targeted semantic annotations, \ntherefore linking sound constructs to semantic constructs.\n\nIn order to adequately use annotation overlaps to extract co-occurrence data, \nthese properties should contain information that describe how and when this can be done. \nFor example, a \u201chigh-autocorrelation\u201d property loses its significance if we\u2019re considering only a small portion \nof the annotated segment. Similarly, a different semantic annotation might be more or less stable according to how \nlittle the considered subsequence is \u2014 a 4 second `purr` might still be a purr if we consider 0.5 seconds of it, \nbut a laugh might not be recognisable at that level. \nThis indicates a need for a \u201cannotation calculus\u201d that will specify how we \ncan derive co-occurrence data from annotation overlaps.\n\n# Modeling\nAt this point we have various implicit models that connect acoustic and semantic constructs between themselves. \nAcoustic and semantic constructs become connected to each other through the acoustic-semantic co-occurrence assertions \nprovided by semantic annotations. Models must then supply a computable path between streaming sound and probabilities of \ntargeted semantic constructs.\n\nThe annotation queryable system we propose can at the very least provide a modeler with the means to effectively extract \nwell tuned training and testing data, as well as provide hints as to what acoustical facets are most correlated to the \ntargeted semantic categories, from which any type of model can be applied.\n\nHowever the syntactical approach can be applied here too. We may view the stream of snips as initial symbols \nthat should be combined in such a manner as to derive the targeted semantical symbols. \nIn practice, it is often useful to have a \u201clight\u201d model that efficiently detects only specific categories. \nTo achieve this, we can borrow a page from the speech recognition community and use automatons. \nIndeed, automatons are a suitable choice considering we are given a sequence of symbols, \nmust follow several combinatorial pathways, updated for every new incoming symbol, and when a \u201cterminal\u201d symbol is \nreached this means a detection has been made.\n\n# References\n\nReferences \n\n[1] Aucouturier, J.-J., Defreville, B. and Pachet F.: \u201cThe bag-of-frames approach to audio pattern recognition: \nA sufficient model for urban soundscapes but not for polyphonic music.\u201d \nIn: Journal of the Acoustical Society of America 122.2, pp 881\u2013891 (2007) \t\n[2] Ehsan Amid, Annamaria Mesaros, Kalle Palomaki, Jorma Laaksonen, Mikko Kurimo, \n\u201cUnsupervised feature extraction for multimedia event detection and ranking using audio content\u201d \n- 2014 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP) - (2014)\n\n[3] V. Carletti, P. Foggia, G. Percannella, A. Saggese, N. Strisciuglio, and M. Vento, \n\u201cAudio surveillance using a bag of aural words classifier,\u201d Proc. of AVSS, pp. 81\u201386, 2013. \n\n[4] K. S. Fu, \u201cSyntactic Pattern Recognition and Applications.\u201d Prentice Hall, 1982.\n\n[5] R. I. Godoy, \u201cChunking sound for musical analysis\u201d. CMMR 2008, Springer.\n\n[6] R.M. Gray, \u201cVector Quantization,\u201dIEEE ASSP Magazine, Vol. 1, 1984 .\n\n[7] T.Heittola, A.Mesaros, A.Eronen, and T.Virtanen, \u201cContext- dependent sound event detection,\u201d \nEURASIP Journal on Audio, Speech, and Music Processing, 2013.\n\n[8] K.Y. Huang, \u201cSyntactic Pattern Recognition for Seismic Oil Exploration\u201d, \nSeries in Machine Percep. Artificial Intelligence, v. 46.\n\n[9] D. Jurafsky, \u201cSpeech and language processing\u201d, 2nd edition, Prentice Hall, 2008.\n\n[10] B. Julesz, \"Textons, the elements of texture perceptions, and their interactions\", \nNature, vol 290., pp. 91-97, 1981.\n\n[11] WaveNet: \u201cA Generative Model for Raw Audio\u201d, Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, \nOriol Vinyals, Alex Graves, Nal Kalchbrenner, Andrew Senior, Koray Kavukcuoglu, 2016, https://arxiv.org/abs/1609.03499\n\n[12] S. Kim, S. Sundaram, P. Georgiou, and S. Narayanan, \u201cAn N -gram model for unstructured audio signals toward \ninformation retrieval,\u201d in Multimedia Signal Processing, 2010 IEEE International Workshop on, 2010. \n\n[13]  Stephanie Pancoast and Murat Akbacak, \u201cBag-of- Audio-Words Approach for Multimedia Event Classification\u201d.\n\n[14] S. Pancoast and M. Akbacak, \u201cN-gram extension for bag-of-audio-words,\u201d in Proc. of the 38th IEEE International \nConference on Acoustics,Speech and Signal Processing(ICASSP). Vancouver, Canada: IEEE, 2013, pp. 778\u2013782. \n\n[15]  H.Phan, A.Mertins, \u201cExploring superframe co-occurrence for acoustic event recognition,\u201d in Proc. EUSIPCO, 2014, \npp. 631\u2013 635. \n\n[16] Meyer-Baese, Schmid., \u201cPattern Recognition and Signal analysis in Medical Imaging\u201d.\n\n[17] L. Su, C. Yeh, J. Liu, J. Wang, and Y. Yang. \u201cA Systematic Evaluation of the Bag-of-Frames Representation for \nMusic Information Retrieval\u201d, IEEE Transaction on Multimedia, Vol 16, N. 5, 2014.\n\n[18] P. Trahanias, E. Skordalakis, Syntactic Pattern Recognition of the ECG, IEEE transactions on pattern analysis \nand machine intelligence, v. 12, No. 7, 1990.\n\n[19] N.N Vo, A. Bobick, \u201cFrom stochastic grammar to Bayes network: probabilistic parsing of complex activity\u201d, \nCVPR 2014.\n\n[20] J. T. L Wang, M. Zaki and others, \u201cData mining in Bioinformatics\u201d, Springer, 2005.\n\n[21] C. Yu, D. H. Ballard, \u201cOn the integration of grounding language and learning objects\u201d, AAAI, 2004. \n\n[22] S-C. Zhu, D. Mumford, \u201cA stochastic Grammar of Images\u201d, \nFoundations and trends in Computer Vision and Graphics, 2006\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/thorwhalen/slang", "keywords": "sound recognition,machine learning,language,audio,signal processing,natural language processing,NLP,text mining", "license": "Apache", "maintainer": "", "maintainer_email": "", "name": "slang", "package_url": "https://pypi.org/project/slang/", "platform": "", "project_url": "https://pypi.org/project/slang/", "project_urls": {"Homepage": "https://github.com/thorwhalen/slang"}, "release_url": "https://pypi.org/project/slang/0.0.4/", "requires_dist": ["numpy", "pandas"], "requires_python": "", "summary": "Tools to endow signals with language-like structure.", "version": "0.0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Slang: Light weight tools to build signal languages</h1>\n<p>Slang is a structural approach to sound/signal machine learning.\nHere, signals are structured into inter-related annotated parts.\nThe signal's stream is transformed into a stream of symbols with associated\nqualifications, quantifications and/or relations that can be used to analyze, interpret, and\ncommunicate the signal's informational content:\nA language.</p>\n<p>We humans have developed many systems of symbols to represent or transmit various forms of information.\nFor instance,</p>\n<ul>\n<li>Natural spoken language, from phonemes to morphemes, to words and meta-word structures (simply put, grammar).</li>\n<li>Written scripts to symbolize either the sounds of the spoken words, or the ideas they mean to symbolize.</li>\n<li>Similarly, various musical notation evolved in different times and parts of the world.\nThese codified what was considered to be the essentials of musical expression, in\nsuch a way that it could be communicated in written form.</li>\n</ul>\n<p>Symbols, though not fully faithful representatives of what they symbolize,\ncan go a long way in communicating what's essential -- whether it's meaning, feeling, or how to make pizza.\nWhat is more; what the symbols (say words) themselves lack in accuracy,\ntheir combination and context make up for.</p>\n<p>Slang's objective is to provide that ability for signal.\nNote we will focus on sound mainly, since sound recognition is the birthplace of Slang,\nand it makes communicating ideas simpler and possibly more intuitive.\nBut we keep generalization in mind.</p>\n<h2>A story to paint the horizon</h2>\n<p>Imagine a device that could be dropped into a remote inhabited region with no prior knowledge of the local language.\nAfter hours/days of listening, it would figure out what phonemes the locals use,\nhow these phonemes co-occur (learning words), and eventually patterns guiding the structure of word sequences (grammar).\nIt has learned the syntax of the local language, unsupervised.</p>\n<p>Now show it examples of concrete things people are talking about (this is called \"grounding a language\"),\nand it will now be able to develop semantics.</p>\n<p>The common thread through this learning evolutiion is the ability to detect and annotate patterns\nand relate these patterns to each other from lower to higher levels of abstraction.</p>\n<h1>Sound Language</h1>\n<p>Not surprisingly, speech recognition is the sub-domain of sound recognition\nthat is closest to the syntactic method we propose.\nSpeech recognition must featurize sound at a granular level to capture micro occurrences such as phones,\nsubsequently combined to form phonemes, morphemes, and recognisable phrases.\nAdvanced speech recognition uses natural language processing to improve accuracy in that\nit exploits language contextual information in order to more accurately map sound to words.</p>\n<p>A language of sound would aspire to link sound to meaning in a similar combinatorial way, but offers a few differences\n\u2014 some simplifying and other complexifying the task.\nIn speech recognition the language, its constructs (phones, phonemes, words)\nand its combinatorial rules (grammar) are fixed and known.\nIn sound recognition, the language needs to be inferred (generated) from the context,\nits constructs defined, and its combinatorial rules learned.\nHowever, there is a fortuitous consideration: though natural language\u2019s expressive power is expansive,\nin sound recognition we need only to describe events relevant to sound.</p>\n<p>Essentially, SLANG represents both acoustic and semantic facets of the sound recognition pipeline as networks of\ninterconnected elements. An attractive implication is the possibility to apply the extensive research in\nnatural language processing (NLP) to carry out general recognition tasks.\nThis representation puts emphasis on structural aspects,\nyet the most significant quantitative characteristics of sound are kept in the properties of the elements,\nconnections, and accompanying codebooks.</p>\n<h1>Structural and Syntactical Pattern Recognition</h1>\n<p>In contrast with the standard paradigms of machine learning,\nthe less common \u200bstructured learning approach attempts to use structural information of both the classified objects and\nthe classification domain. An even lesser known research area takes this idea a step further by articulating\nthe structural aspect as a formal grammar that defines rules that derive signal constructs to classification constructs.\nWe propose an approach where both sound and its semantics are expressed in a manner that enables the detection system\nto take advantage of the structural aspects of both.\nThe importance of a structural framework is further supported as we attempt to go beyond detecting isolated\n\u200bsound occurrence\u200b toward interpreting sequences of these occurrences and discovering \u200bsound generating activities\u200b.\nThese sound generating activities can be expressed through ontologies\nand sequential rules composed from other semantical elements.</p>\n<p>This approach has been coined as \u201csyntactical pattern recognition\u201d or \u201cgrammar induction\u201d. These techniques have been\nused in Chinese character recognition [\u200b4\u200b], analysis of textures [\u200b10\u200b], medical diagnosis (heart disease detection) [\u200b16\u200b],\nvisual scene recognition [\u200b22\u200b], movement recognition in video [\u200b19\u200b], activity monitoring in video [\u200b19\u200b],\nand closer to sound (since uni-dimensional time-series), seismic signal analysis (eg. in oil detection) [\u200b8\u200b]\nand ECG analysis [\u200b18\u200b, \u200b16\u200b].\nAs far as we know, no research has been carried out to apply syntactical pattern recognition techniques\nto general sound recognition, and we intend to take inspiration in this literature in an effort to derive semantics\nfrom sound.</p>\n<h1>Semantic Structure</h1>\n<p>The elements of the semantic structure will be taken from plain English.\nThese will be words and phrases that are connected to sound events. These elements could describe, for example,</p>\n<ul>\n<li>particular types of sound (\u200bbark,\u200b\u200b rustle\u200b,\u200b cling, \u200b\u200bbang)\u200b</li>\n<li>sound sources (\u200bdog, wind\u200b,\u200b thunder,\u200b r\u200bunning\u200b \u200bwater\u200b)</li>\n<li>sound generating activities that may have a very wide temporal range \u2014 such as \u200bstorm\u200b or cooking.\u200b</li>\n</ul>\n<p>The \u200badvantage\u200b of structured learning \u200blies in its exploitation of the structure of the output space.\nClip-clop, clippety-clop, clop, clopping, clunking\u200b and \u200bclumping\u200b can be considered to be synonyms of each other\nin the context of sound. A \u200bclop\u200b (and its twins) is closer to \u200bknock\u200b and \u200bplunk than it is to \u200bhiss\u200b and \u200bbuzz.\u200b\nYet b\u200buzz\u200b and \u200bknock\u200b, though not similar acoustically, are strongly related to each other through their relation to \u200bdoor\u200b\nand activities surrounding it. If we consider all these sound labels as separate, we would be depriving ourselves\nfrom the valuable information encoded in their interrelationships.\nSemantic structure allows models to avoid problems of synonymy and polysemy,\nbut also allow the emergence of a fuller picture of the sound\u2019s contents\n\u2014 through (formal grammar) derivations such as <code>rustle + blowing \u2014&gt; wind</code> and <code>wind + thunder \u2014&gt; storm</code>.</p>\n<p>As a first step, these relationships can be mined from NLP tools and APIs such as WordNet and WordsAPI.\nOnce connected to sound however, these relationships should be enhanced according to the acoustic similarities of\nthe sounds the semantic constructs are related to.\nMoreover, in practice semantics are usually grounded in action,\nso the semantic structure should be able to be edited and augmented for the application\u2019s needs.</p>\n<h1>Acoustics Structure</h1>\n<p>On the acoustic side of SLANG, a similar structured approach should be taken, identifying, symbolizing,\nand interconnecting acoustical units into ever higher combinations, eventually connecting them to the semantic\nidentifiers.</p>\n<p>This process is based on the following steps:</p>\n<ul>\n<li>Chunk audio streams into very short (and possibly overlapping) frames and compute feature\nvectors of these frames. We will call these frame features.</li>\n<li>Quantize the frame features, creating a codebook of frame features</li>\n<li>Enhance the codebook with frame similarity information</li>\n<li>Use both supervised and unsupervised techniques to carry out pattern detection and annotate code subsequences with these</li>\n<li>Carry out classification and structured learning techniques to link these patterns to semantic identifiers and structures</li>\n</ul>\n<p>These steps will be detailed in the following sections.</p>\n<h2>Alphabetization</h2>\n<p>An audio stream is chunked into short (and possibly overlapping) frames over which we compute suitable feature vectors.\nThese features (e.g. spectrogram, chromagram, mel-spectrum, MFCC slices [17]) encode \u201cinstantaneous\u201d\ncharacteristics of sound \u2014 such as intensity and spectral features \u2014 but do not encompass wide-range characteristics\nsuch as autocorrelation and intensity monotonicity.\nThese wide-range characteristics will be captured through combinatorial analysis later on.\nThe frame features are then quantized to a discrete set of symbols [6].\nVector quantization will map the frame features to a finite number of symbols that will represent all frame features\nwithin a bounded region. These symbols, which we will call \u201csnips\u201d (short for \u201csound nips\u201d) will play the role of our\nsound language alphabet. We record statistical information about the feature space covered by each snip in order to\nqualify and quantify feature-based relationships.</p>\n<h2>Snips network</h2>\n<p>Quantization maps multi-dimensional numerical features to unidimensional nominal ones, thereby seemingly losing all\nsimilarity relationships that the numerical features contain.\nAn approximation of these similarities can be recovered through the numerical feature statistics\nwe associated with each snip, but it would be computationally intensive to have to generate these using\nthe original feature vectors every time we need this information.</p>\n<p>Instead, we will use the statistical relationships recorded about the feature space covered by the snips to build a\nnetwork documenting these similarities.\nIn this network we can store information about snips themselves (the nodes) as well as pairs of snips (the links).\nThis serves to keep and be able to readily key into, useful information about the snips and their relationships.</p>\n<p>For example, since sequential patterns of intensity are important in sound recognition,\nwe will store statistics (such as mean and standard deviation) of the intensity of the feature subspace or train data\nframes associated to the each snip. Further, we label the pairs of snips (links of the network) with information about\nthe frames associated to them \u2014 such as various similarity metrics.\nOne notable property to retain is the \u201csnip confusion\u201d metric,\nwhich is the probability that a snip could have been another,\ngiven the arbitrary offset of the initial segmentation into frames.</p>\n<p>The properties stored in the snips network enable us to generate a \u201chalo\u201d around snips where pattern search can operate.\nFurther, enhancing the snip codebook with such information that links back to the original raw data,\nopens the possibility to merge codebooks or translate (at least approximately) one snipping system to another.</p>\n<h1>Snips Annotations</h1>\n<p>In our framework, annotations replace both chunk features and semantic labels. An annotation specifies a segment of\nsound and a property associated to it. Since we now represent sound by a sequence of snips, the segment can be specified\nby a {sound source id, offset snip index, end snip index} triple, and annotations can be grouped or merged to optimize\nindexing, storage and retrieval needs. The property of an annotation can be any data that provides information about\nthe segment.</p>\n<p>Annotations serve a purpose on both sides of the machine learning process:</p>\n<ul>\n<li>Marking sound segments with acoustical information that may allow models to link sound to meaning.</li>\n<li>Acquiring precise \u201csupervised data\u201d. Precise because (a) unlike a chunked approach, we can delineate exactly what\npart of the sound we are labeling and (b) we are not limited by single labels, but can express any multi-faceted and\neven structured details about sound segments.</li>\n</ul>\n<p>Annotations may include:</p>\n<ul>\n<li><strong>Frequent snip sub-sequences</strong>\u200b: If they are frequent enough, they are important enough to note whether for negative\nor positive inference. The discovery of frequent patterns in sequential data is crucial in Bioinformatics [20].\nThis can be compared to the use of n-grams and skip-grams in text processing.\nExamples of n-grams applied to sound can be found in [12] and [14].</li>\n<li><strong>Frequent snip patterns</strong>: The ability to pinpoint frequent patterns in snip sequences or sets supplies further\npattern mining processes with more \u201csynonymous sets of words\u201d to work with. Snip networks will serve to expand or\nreduce the input snips to find patterns. Compare to NLP information retrieval,\nwhere words of a query are reduced (e.g. stemming [9] and stopword removal) or expanded\n(e.g. related words expansion and edit distance radius [9]).</li>\n<li><strong>Pattern-homogeneous sub-sequences</strong>: The distribution of snips of a segment could be considered to belong to a\nsame \u201ctopic\u201d or latent semantic state. See for example the \u201cbag of frames\u201d techniques ([13], [15]),\nwhich cast soundscapes and music information retrieval to a classical NLP term-document approach.</li>\n<li><strong>Aggregate features</strong>: Since snips use only short-range features, we seem to have lost the ability to use acoustic\nfeatures that assume significance only over some period of time, but these can be approximated from the snip codebook\nlink to the original frame features statistics and only those with highest significance and utility need to be recorded\n(for example only high autocorrelation).</li>\n<li><strong>Semantic annotations</strong>: On the other end of the sound-to-semantics spectrum we can annotate low level semantic\nidentifiers (such as <code>cling</code>, <code>chop</code> and <code>splash</code>) , wide-range segments with words describing a sound-generating\nactivity (such as <code>cooking</code>), and context, which is crucial to the proper interpretation of sound events.\nThese annotations are typically generated by a semi-supervised process \u2014 though inferred semantic annotations\ncan be useful to quickly access and validate possible categories of interest.\nWell indexed, this annotation system provides the ability to retrieve audio,\nfeatures or semantic labels from queries expressed as audio, features or semantic labels.\nThis is not only useful as a sound search engine, but gives us all we need to extract acoustic and semantic constructs\nand build models relating these.</li>\n</ul>\n<h2>Relationship between Annotations and the Syntactic Approach</h2>\n<p>Annotated segments provide relationships between acoustical facets of sound semantics through the co-occurrence of\noverlapping annotations in a same segment. Consider all annotations that entirely contain a particular segment.\nAll properties (acoustic and semantic) contained within each annotation are related since they describe\nthe same segment.</p>\n<p>Along with the aforementioned semantic and snips structures, this set of co-occurring properties can be used to\ngenerate a (stochastic formal) grammar over the alphabet of snips and annotations.\nThis grammar provides statistical rules that can be used to derive snips to targeted semantic annotations,\ntherefore linking sound constructs to semantic constructs.</p>\n<p>In order to adequately use annotation overlaps to extract co-occurrence data,\nthese properties should contain information that describe how and when this can be done.\nFor example, a \u201chigh-autocorrelation\u201d property loses its significance if we\u2019re considering only a small portion\nof the annotated segment. Similarly, a different semantic annotation might be more or less stable according to how\nlittle the considered subsequence is \u2014 a 4 second <code>purr</code> might still be a purr if we consider 0.5 seconds of it,\nbut a laugh might not be recognisable at that level.\nThis indicates a need for a \u201cannotation calculus\u201d that will specify how we\ncan derive co-occurrence data from annotation overlaps.</p>\n<h1>Modeling</h1>\n<p>At this point we have various implicit models that connect acoustic and semantic constructs between themselves.\nAcoustic and semantic constructs become connected to each other through the acoustic-semantic co-occurrence assertions\nprovided by semantic annotations. Models must then supply a computable path between streaming sound and probabilities of\ntargeted semantic constructs.</p>\n<p>The annotation queryable system we propose can at the very least provide a modeler with the means to effectively extract\nwell tuned training and testing data, as well as provide hints as to what acoustical facets are most correlated to the\ntargeted semantic categories, from which any type of model can be applied.</p>\n<p>However the syntactical approach can be applied here too. We may view the stream of snips as initial symbols\nthat should be combined in such a manner as to derive the targeted semantical symbols.\nIn practice, it is often useful to have a \u201clight\u201d model that efficiently detects only specific categories.\nTo achieve this, we can borrow a page from the speech recognition community and use automatons.\nIndeed, automatons are a suitable choice considering we are given a sequence of symbols,\nmust follow several combinatorial pathways, updated for every new incoming symbol, and when a \u201cterminal\u201d symbol is\nreached this means a detection has been made.</p>\n<h1>References</h1>\n<p>References</p>\n<p>[1] Aucouturier, J.-J., Defreville, B. and Pachet F.: \u201cThe bag-of-frames approach to audio pattern recognition:\nA sufficient model for urban soundscapes but not for polyphonic music.\u201d\nIn: Journal of the Acoustical Society of America 122.2, pp 881\u2013891 (2007)\n[2] Ehsan Amid, Annamaria Mesaros, Kalle Palomaki, Jorma Laaksonen, Mikko Kurimo,\n\u201cUnsupervised feature extraction for multimedia event detection and ranking using audio content\u201d</p>\n<ul>\n<li>2014 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP) - (2014)</li>\n</ul>\n<p>[3] V. Carletti, P. Foggia, G. Percannella, A. Saggese, N. Strisciuglio, and M. Vento,\n\u201cAudio surveillance using a bag of aural words classifier,\u201d Proc. of AVSS, pp. 81\u201386, 2013.</p>\n<p>[4] K. S. Fu, \u201cSyntactic Pattern Recognition and Applications.\u201d Prentice Hall, 1982.</p>\n<p>[5] R. I. Godoy, \u201cChunking sound for musical analysis\u201d. CMMR 2008, Springer.</p>\n<p>[6] R.M. Gray, \u201cVector Quantization,\u201dIEEE ASSP Magazine, Vol. 1, 1984 .</p>\n<p>[7] T.Heittola, A.Mesaros, A.Eronen, and T.Virtanen, \u201cContext- dependent sound event detection,\u201d\nEURASIP Journal on Audio, Speech, and Music Processing, 2013.</p>\n<p>[8] K.Y. Huang, \u201cSyntactic Pattern Recognition for Seismic Oil Exploration\u201d,\nSeries in Machine Percep. Artificial Intelligence, v. 46.</p>\n<p>[9] D. Jurafsky, \u201cSpeech and language processing\u201d, 2nd edition, Prentice Hall, 2008.</p>\n<p>[10] B. Julesz, \"Textons, the elements of texture perceptions, and their interactions\",\nNature, vol 290., pp. 91-97, 1981.</p>\n<p>[11] WaveNet: \u201cA Generative Model for Raw Audio\u201d, Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan,\nOriol Vinyals, Alex Graves, Nal Kalchbrenner, Andrew Senior, Koray Kavukcuoglu, 2016, <a href=\"https://arxiv.org/abs/1609.03499\" rel=\"nofollow\">https://arxiv.org/abs/1609.03499</a></p>\n<p>[12] S. Kim, S. Sundaram, P. Georgiou, and S. Narayanan, \u201cAn N -gram model for unstructured audio signals toward\ninformation retrieval,\u201d in Multimedia Signal Processing, 2010 IEEE International Workshop on, 2010.</p>\n<p>[13]  Stephanie Pancoast and Murat Akbacak, \u201cBag-of- Audio-Words Approach for Multimedia Event Classification\u201d.</p>\n<p>[14] S. Pancoast and M. Akbacak, \u201cN-gram extension for bag-of-audio-words,\u201d in Proc. of the 38th IEEE International\nConference on Acoustics,Speech and Signal Processing(ICASSP). Vancouver, Canada: IEEE, 2013, pp. 778\u2013782.</p>\n<p>[15]  H.Phan, A.Mertins, \u201cExploring superframe co-occurrence for acoustic event recognition,\u201d in Proc. EUSIPCO, 2014,\npp. 631\u2013 635.</p>\n<p>[16] Meyer-Baese, Schmid., \u201cPattern Recognition and Signal analysis in Medical Imaging\u201d.</p>\n<p>[17] L. Su, C. Yeh, J. Liu, J. Wang, and Y. Yang. \u201cA Systematic Evaluation of the Bag-of-Frames Representation for\nMusic Information Retrieval\u201d, IEEE Transaction on Multimedia, Vol 16, N. 5, 2014.</p>\n<p>[18] P. Trahanias, E. Skordalakis, Syntactic Pattern Recognition of the ECG, IEEE transactions on pattern analysis\nand machine intelligence, v. 12, No. 7, 1990.</p>\n<p>[19] N.N Vo, A. Bobick, \u201cFrom stochastic grammar to Bayes network: probabilistic parsing of complex activity\u201d,\nCVPR 2014.</p>\n<p>[20] J. T. L Wang, M. Zaki and others, \u201cData mining in Bioinformatics\u201d, Springer, 2005.</p>\n<p>[21] C. Yu, D. H. Ballard, \u201cOn the integration of grounding language and learning objects\u201d, AAAI, 2004.</p>\n<p>[22] S-C. Zhu, D. Mumford, \u201cA stochastic Grammar of Images\u201d,\nFoundations and trends in Computer Vision and Graphics, 2006</p>\n\n          </div>"}, "last_serial": 7148685, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "af4450b4c744f43fab162e3db9f83582", "sha256": "f18f4cf6a3b00f8a3c6368d3b0f991167e1c6c877288becbc10644614bfc89f7"}, "downloads": -1, "filename": "slang-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "af4450b4c744f43fab162e3db9f83582", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 42375, "upload_time": "2020-04-15T16:28:44", "upload_time_iso_8601": "2020-04-15T16:28:44.425595Z", "url": "https://files.pythonhosted.org/packages/8e/5a/fab32b0dc1fb5caa4afafb0448dd336c133aaf5b212602d9ed72c75f9042/slang-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "62f0c2fd2fefc511da6ac74d2946d3ed", "sha256": "f5ad816329d41cc8862501d03e10ece74227feb64adc41e9839d0a1cdeff290a"}, "downloads": -1, "filename": "slang-0.0.1.tar.gz", "has_sig": false, "md5_digest": "62f0c2fd2fefc511da6ac74d2946d3ed", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47648, "upload_time": "2020-04-15T16:28:47", "upload_time_iso_8601": "2020-04-15T16:28:47.721958Z", "url": "https://files.pythonhosted.org/packages/35/8c/14248a2a6804530bc1c31063823742855993b257b58a14b084b4889d5485/slang-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "e79ef7aea3d6c8e35aa79b053cbc4b5c", "sha256": "0cb50fb4c4f4e5a64cd747eb8f2f95df0dd15eeb31e5dc0bf6a49edae15bd8d5"}, "downloads": -1, "filename": "slang-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "e79ef7aea3d6c8e35aa79b053cbc4b5c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 46934, "upload_time": "2020-04-16T19:30:33", "upload_time_iso_8601": "2020-04-16T19:30:33.361083Z", "url": "https://files.pythonhosted.org/packages/55/8c/783bc3009255fab9b05bab8600ab8d46d8d4515fa2ce4c1cc2ed7449bf8e/slang-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2446cdd8efe37e3498c996507acdabd6", "sha256": "83b21d4e6c9663d5596c9cb4242d4de9c016e4a6e93e2e7dc77221673b668591"}, "downloads": -1, "filename": "slang-0.0.2.tar.gz", "has_sig": false, "md5_digest": "2446cdd8efe37e3498c996507acdabd6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51383, "upload_time": "2020-04-16T19:30:35", "upload_time_iso_8601": "2020-04-16T19:30:35.681411Z", "url": "https://files.pythonhosted.org/packages/98/a0/99b2e26c02f2409bc9680a51bf754499d9170e4413f8f22ea778fd8a8cf5/slang-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "5532cb12316199c634f6958246086501", "sha256": "e6c5d184b9e9bf75080d075a9a56a1761afb34ee67fbf842d576ac75075b6627"}, "downloads": -1, "filename": "slang-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "5532cb12316199c634f6958246086501", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 47412, "upload_time": "2020-04-16T22:52:17", "upload_time_iso_8601": "2020-04-16T22:52:17.184477Z", "url": "https://files.pythonhosted.org/packages/a4/ca/12547988a2e5c692ab060503241e20ab40dcb116a1a6e6b41f705cda28b5/slang-0.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "54c5996e1f43b175fb51b5dc791b58ca", "sha256": "ef5d3b2e4a2698b917c58c871e09673d65cb4594760261a7e50c826abfdeabcd"}, "downloads": -1, "filename": "slang-0.0.3.tar.gz", "has_sig": false, "md5_digest": "54c5996e1f43b175fb51b5dc791b58ca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51752, "upload_time": "2020-04-16T22:52:19", "upload_time_iso_8601": "2020-04-16T22:52:19.871444Z", "url": "https://files.pythonhosted.org/packages/bc/3f/7a2deb09c24466e33c1ea489c14efaae6d56c927b06f53a95c1ecf61614d/slang-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "e7e2dd60620e5e8e665c9c7a7411521c", "sha256": "bd954d3a6532733d421774a2c11c146a4f07fb8f4f79dcf7b34ab854b7e41903"}, "downloads": -1, "filename": "slang-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "e7e2dd60620e5e8e665c9c7a7411521c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 47726, "upload_time": "2020-05-01T22:37:16", "upload_time_iso_8601": "2020-05-01T22:37:16.926649Z", "url": "https://files.pythonhosted.org/packages/96/3b/4847fed3a37deb26d44ee2fb6e3a33f6af4d3b4be5ee3d670ca56ab3bb32/slang-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "363fbe1023774a691fa4e89a6315d392", "sha256": "b73516e953739503b0d8684a39765c025ac6cbc3f8d3ed3aa23e94c527aa183e"}, "downloads": -1, "filename": "slang-0.0.4.tar.gz", "has_sig": false, "md5_digest": "363fbe1023774a691fa4e89a6315d392", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52021, "upload_time": "2020-05-01T22:37:18", "upload_time_iso_8601": "2020-05-01T22:37:18.991633Z", "url": "https://files.pythonhosted.org/packages/c5/b5/c98ec719c7bdcd36e907f860097e03ad1a716a93adb4c31d7bf37e65a7f3/slang-0.0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e7e2dd60620e5e8e665c9c7a7411521c", "sha256": "bd954d3a6532733d421774a2c11c146a4f07fb8f4f79dcf7b34ab854b7e41903"}, "downloads": -1, "filename": "slang-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "e7e2dd60620e5e8e665c9c7a7411521c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 47726, "upload_time": "2020-05-01T22:37:16", "upload_time_iso_8601": "2020-05-01T22:37:16.926649Z", "url": "https://files.pythonhosted.org/packages/96/3b/4847fed3a37deb26d44ee2fb6e3a33f6af4d3b4be5ee3d670ca56ab3bb32/slang-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "363fbe1023774a691fa4e89a6315d392", "sha256": "b73516e953739503b0d8684a39765c025ac6cbc3f8d3ed3aa23e94c527aa183e"}, "downloads": -1, "filename": "slang-0.0.4.tar.gz", "has_sig": false, "md5_digest": "363fbe1023774a691fa4e89a6315d392", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52021, "upload_time": "2020-05-01T22:37:18", "upload_time_iso_8601": "2020-05-01T22:37:18.991633Z", "url": "https://files.pythonhosted.org/packages/c5/b5/c98ec719c7bdcd36e907f860097e03ad1a716a93adb4c31d7bf37e65a7f3/slang-0.0.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:08:35 2020"}