{"info": {"author": "Edvard Rejthar", "author_email": "edvard.rejthar@nic.cz", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 3"], "description": "# envelope\n\n[![Build Status](https://travis-ci.org/CZ-NIC/envelope.svg?branch=master)](https://travis-ci.org/CZ-NIC/envelope)\n\nQuick layer over [python-gnupg](https://bitbucket.org/vinay.sajip/python-gnupg/src), [M2Crypto](https://m2crypto.readthedocs.io/), [smtplib](https://docs.python.org/3/library/smtplib.html), [magic](https://pypi.org/project/python-magic/) and [email](https://docs.python.org/3/library/email.html?highlight=email#module-email) handling packages. Their common usecases merged into a single function. Want to sign a text and tired of forgetting how to do it right? You do not need to know everything about GPG or S/MIME, you do not have to bother with importing keys. Do not hassle with reconnecting SMTP server. Do not study various headers meanings to let your users unsubscribe via a URL.  \nYou insert a message and attachments and receive signed and/or encrypted output to the file or to your recipients' e-mail.  \nJust single line of code. With the great help of the examples below.  \n\n```python3\nenvelope(\"my message\")\n    .subject(\"hello world\")\n    .to(\"example@example.com\")\n    .attach(file_contents, filename=\"attached-file.txt\")\n    .smtp(\"localhost\", 587, \"user\", \"pass\", \"starttls\")\n    .signature()\n    .send()\n```\n\n- [Installation](#installation)\n  * [Bash completion](#bash-completion)\n- [Usage](#usage)\n  * [CLI](#cli)\n  * [Module: one-liner function](#module-one-liner-function)\n  * [Module: fluent interface](#module-fluent-interface)\n- [Documentation](#documentation)\n  * [Command list](#command-list)\n    + [Input / Output](#input--output)\n    + [Cipher standard method](#cipher-standard-method)\n    + [Signing](#signing)\n    + [Encrypting](#encrypting)\n    + [Sending](#sending)\n      - [Specific headers](#specific-headers)\n    + [Supportive](#supportive)\n  * [Default values](#default-values)\n  * [Converting object to str or bool](#converting-object-to-str-or-bool)\n- [Examples](#examples)\n  * [Signing and encrypting](#signing-and-encrypting)\n  * [Sending](#sending-1)\n  * [Attachment](#attachment)\n  * [Complex example](#complex-example)\n- [Related affairs](#related-affairs)\n  * [Configure your SMTP](#configure-your-smtp)\n  * [Choose ciphering method](#choose-ciphering-method)\n    + [Configure your GPG](#configure-your-gpg)\n    + [Configure your S/MIME](#configure-your-smime)\n  * [DNS validation tools](#dns-validation-tools)\n    + [SPF](#spf)\n    + [DKIM](#dkim)\n    + [DMARC](#dmarc)\n\n\n# Installation\n* If planning to use S/MIME, you should ensure some prerequisites:\n```bash\nsudo apt install swig\npip3 install M2Crypto\n```\n* Install with a single command from [PyPi](https://pypi.org/project/envelope/)\n    ```bash \n    pip3 install envelope\n    ```\n    * Or install current GitHub master\n    ```bash\n    pip3 install git+https://github.com/CZ-NIC/envelope.git\n    ```\n    * Or just download the project and launch `./envelope.py`\n* If planning to send e-mails, prepare SMTP credentials or visit [Configure your SMTP](#configure-your-smtp) tutorial.\n* If your e-mails are to be received outside your local domain, visit [DMARC](#dmarc) section.\n* If planning to sign/encrypt with GPG, install the corresponding package and possibly see [Configure your GPG](#configure-your-gpg) tutorial.\n```bash\nsudo apt install gpg\n```\n\n## Bash completion\n1. Run: apt-get install bash-completion jq\n2. Copy: extra/convey-autocompletion.bash to /etc/bash_completion.d/\n3. Restart terminal\n\n# Usage\nAs an example, let's produce in three equal ways an `output_file` with the GPG-encrypted \"Hello world\" content.\n## CLI\nLaunch as a CLI application in terminal, see `envelope --help`\n  \n```bash\nenvelope --message \"Hello world\" \\\n               --output \"/tmp/output_file\" \\\n               --sender \"me@example.com\" \\\n               --to \"remote_person@example.com\" \\\n               --encrypt-path \"/tmp/remote_key.asc\"\n```\n## Module: one-liner function\nYou can easily write a one-liner function that encrypts your code or sends an e-mail from within your application when imported as a module. See `pydoc3 envelope` or documentation below.\n\n```python3\nimport envelope\nenvelope(message=\"Hello world\",\n        output=\"/tmp/output_file\",\n        sender=\"me@example.com\",\n        to=\"remote_person@example.com\",\n        encrypt=\"/tmp/remote_key.asc\")\n```\n\n## Module: fluent interface\nComfortable way to create the structure if your IDE supports autocompletion.\n```python3\nimport envelope\nenvelope().message(\"Hello world\")\\\n    .output(\"/tmp/output_file\")\\\n    .sender(\"me@example.com\")\\\n    .to(\"remote_person@example.com\")\\\n    .encrypt(key_path=\"/tmp/remote_key.asc\")\n```\n\nNote: if autocompletion does not work, use **`from envelope import envelope`** instead of `import envelope`.  \n(For example, Jupyter can autocomplete with `import envelope` but PyCharm cannot because it does not serves itself with a [running kernel](https://youtrack.jetbrains.com/issue/PY-38086#comment=27-3716668).)\n\n# Documentation\n\nBoth `envelope --help` for CLI arguments help and `pydoc3 envelope` to see module arguments help should contain same information as here.\n\n## Command list\nAll parameters are optional. \n\n* **--param** is used in CLI\n* **envelope(param=)** is a one-liner argument\n* **.param(value)** denotes a positional argument\n* **.param(value=)** denotes a keyword argument\n \nAny fetchable contents means plain text, bytes or stream (ex: from open()). In *module interface*, you may use Path object to the file. In *CLI interface*, additional flags are provided.         \n\n### Input / Output\n  * **message**: Message / body text.\n    * **--message**: String\n    * **--input**: *(CLI only)* Path to the message file. (Alternative to `--message` parameter.)\n    * **envelope(message=)**: Any fetchable contents\n    * **.message(text)**:  String or stream.\n    * **.message(path=None)**: Path to the file.\n    \n    Equivalents for setting a string (in *Python* and in *Bash*).\n    ```python3\n    envelope(message=\"hello\") == envelope().message(\"hello\")\n    ```\n    ```bash\n    envelope --message \"hello\"\n    ``` \n    Equivalents for setting contents of a file (in *Python* and in *Bash*).\n    ```python3\n    from pathlib import Path\n    envelope(message=Path(\"file.txt\")) == envelope(message=open(\"file.txt\")) == envelope.message(path=\"file.txt\") \n    ```\n    ```bash\n    envelope --input file.txt\n    ```\n  * **output**: Path to file to be written to (else the contents is returned).\n    * **--output**\n    * **envelope(output=)**\n    * **.output(output_file)**\n### Cipher standard method\nNote that if neither *gpg* nor *smime* is specified, we try to determine the method automatically.\n  * **gpg**: True to prefer GPG over S/MIME or home path to GNUPG rings (otherwise default ~/.gnupg is used)\n    * **--gpg [path]**\n    * **envelope(gpg=True)**\n    * **.gpg(gnugp_home=True)**\n  * **.smime**: Prefer S/MIME over GPG\n    * **--smime**\n    * **envelope(smime=True)**\n    * **.smime()**\n### Signing\n  * **sign**: Sign the message.\n    * **--sign**:\n        * \"auto\" for turning on signing if there is a key matching to the \"from\" header\n        * GPG: Blank for user default key or key ID/fingerprint.\n        * S/MIME: Any fetchable contents with key.\n    * **--sign-path**: S/MIME: Filename with the sender\\'s private key. (Alternative to `sign` parameter.)\n    * **--passphrase**: Passphrase to the key if needed.\n    * **--attach-key**: GPG: Blank for appending public key to the attachments when sending.\n    * **--cert**: S/MIME: Certificate contents if not included in the key.\n    * **--cert-path**: S/MIME: Filename with the sender's private cert if cert not included in the key. (Alternative to `cert` parameter.)\n    * **envelope(sign=)**:\n        * GPG: True for user default key or key ID/fingerprint.\n        * S/MIME: Key contents.\n    * **envelope(passphrase=)**: Passphrase to the key if needed.\n    * **envelope(attach_key=)**: GPG: Append public key to the attachments when sending.\n    * **envelope(cert=)**: S/MIME: Any fetchable contents.\n    * **.sign(key=True, passphrase=, attach_key=False, cert=None, key_path=None)**: Sign now (and you may specify the parameters)         \n    * **.signature(key=True, passphrase=, attach_key=False, cert=None, key_path=None)**: Sign later (when launched with *.sign()*, *.encrypt()* or *.send()* functions\n### Encrypting\nIf the GPG encryption fails, it tries to determine which recipient misses the key.\n\n  * **encrypt**:  Recipient GPG public key or S/MIME certificate to be encrypted with. \n    * **--encrypt**: Key string or blank or 1/true/yes if the key should be in the ring from before. Put 0/false/no to disable `encrypt-path`.\n    * **--encrypt-path** *(CLI only)*: Recipient public key stored in a file path. (Alternative to `--encrypt`.)  \n    * **envelope(encrypt=)**: Any fetchable contents\n    * **.encrypt(key=True, sign=, key_path=)**: With *sign*, you may specify boolean or default signing key ID/fingerprint for GPG or Any fetchable contents with S/MIME key + signing certificate. If import needed, put your encrypting GPG key contents or S/MIME certificate to *key* or path to the key/certificate contents file in *key_path*.\n    * **.encryption(key=True, key_path=)**: Encrypt later (when launched with *.sign()*, *.encrypt()* or *.send()* functions. If needed, in the parameters specify Any fetchable contents with GPG encryption key or S/MIME encryption certificate. \n  * **to**: E-mail or list. When encrypting, we use keys of these identities.\n    * **--to**: One or more e-mail addresses.\n    * **envelope(to=)**: E-mail or their list.\n    * **.to(email_or_list)**:\n      ```bash\n      envelope --to first@example.com second@example.com --message \"hello\" \n      ```  \n  * **sender**: E-mail \u2013 needed to choose our key if encrypting.\n    * **--sender** E-mail\n    * **--no-sender** Declare we want to encrypt and never decrypt back.\n    * **--from** Alias for *--sender*\n    * **envelope(sender=)**: Sender e-mail or False to explicitly omit. When encrypting without sender, we do not use their key so that we will not be able to decipher again.\n    * **.sender(email)**: E-mail or False.\n    * **.from_(email)**: an alias for *.sender*\n### Sending\n  * **send**: Send the message to the recipients by e-mail. True (blank in *CLI*) to send now or False to print out debug information.\n    * **--send**\n    * **envelope(send=)**\n    * **.send(send=True, sign=None, encrypt=None)**\n        * *send*: True to send now. False (or 0/false/no in *CLI*) to print debug information.\n    \n    ```bash\n    $ envelope --to \"user@example.org\" --message \"Hello world\" --send 0\n    ****************************************************************************************************\n    Have not been sent from  to user@example.org\n    \n    Content-Type: text/html; charset=\"utf-8\"\n    Content-Transfer-Encoding: 7bit\n    MIME-Version: 1.0\n    Subject:\n    From:\n    To: user@example.org\n    Date: Mon, 07 Oct 2019 16:13:37 +0200\n    Message-ID: <157045761791.29779.5279828659897745855@...>\n    \n    Hello world\n    ```\n  * **subject**: Mail subject. Gets encrypted with GPG, stays visible with S/MIME.\n    * **--subject**\n    * **envelope(subject=)**\n    * **.subject(text)**     \n  * **cc**: E-mail or their list\n    * **--cc**\n    * **envelope(cc=)**\n    * **.cc(email_or_list)**\n  * **bcc**: E-mail or their list\n    * **--bcc**\n    * **envelope(bcc=)**\n    * **.bcc(email_or_list)**\n  * **reply-to**: E-mail to be replied to. The field is not encrypted.\n    * **--reply-to**\n    * **envelope(reply_to=)**\n    * **.reply_to(email)**\n  * **smtp**: SMTP server\n    * **--smtp**\n    * **envelope(smtp=)**\n    * **.smtp(host=\"localhost\", port=25, user=, password=, security=)**\n    * Parameters:\n        * `host` may include hostname or any of the following input formats (ex: path to an INI file or a `dict`)\n        * `security` if not set, automatically set to `starttls` for port *587* and to `tls` for port *465*\n    * Input format may be in the following form:\n        * `None` default localhost server used\n        * `smtplib.SMTP` object\n        * `list` or `tuple` having `host, [port, [username, password, [security]]]` parameters\n            * ex: `envelope --smtp localhost 125 me@example.com` will set up host, port and username parameters\n        * `dict` specifying {\"host\": ..., \"port\": ...}\n            * ex: `envelope --smtp '{\"host\": \"localhost\"}'` will set up host parameter\n        * `str` hostname or path to an INI file (existing file, ending at `.ini`, with the section [SMTP])\n            ```ini\n            [SMTP]\n            host = example.com\n            port = 587            \n            ```\n    * Do not fear to pass the `smtp` in a loop, we make just a single connection to the server. If timed out, we attempt to reconnect once.\n    ```python3\n    smtp = localhost, 25\n    for mail in mails:\n        envelope(...).smtp(smtp).send()\n    ```\n  * **attachments**\n    * **--attachment**: Path to the attachment, followed by optional file name to be used and/or mime type. This parameter may be used multiple times.\n    ```bash\n    envelope --attachment \"/tmp/file.txt\" \"displayed-name.txt\" \"text/plain\" --attachment \"/tmp/another-file.txt\"\n    ```\n    * **gpggp(attachments=)**: Attachment or their list. Attachment is defined by any fetchable contents, optionally in tuple with the file name to be used in the e-mail and/or mime type: `content [,name] [,mimetype]`\n    ```python3\n    envelope(attachments=[(Path(\"/tmp/file.txt\"), \"displayed-name.txt\", \"text/plain\"), Path(\"/tmp/another-file.txt\"])\n    ```    \n    * **.attach(attachment_or_list=, path=, mimetype=, filename=)**: Three different usages.\n        * **.attach(attachment_or_list=, mimetype=, filename=)**: You can put Any fetchable contents in *attachment_or_list* and optionally mimetype or displayed filename.\n        * **.attach(path=, mimetype=, filename=)**: You can specify path and optionally mimetype or displayed filename.\n        * **.attach(attachment_or_list=)**: You can put a list of attachments.\n    ```python3\n    envelope().attach(path=\"/tmp/file.txt\").attach(path=\"/tmp/another-file.txt\")\n    ```\n    * **mime**: Set contents mime subtype: \"auto\" (default), \"html\" or \"plain\" for plain text. Ignored if `Content-Type` header put to the message.         \n        * **--mime SUBTYPE**\n        * **envelope(mime=)**\n        * **.mime(subtype=\"auto\", nl2br=\"auto\")**\n            * nl2br: True: envelope will append `<br>` to every line break in the HTML message. \"auto\": line breaks are changed only if there is no `<br` or `<p` in the HTML message,\n    * **headers**: Any custom headers (these will not be encrypted with GPG nor S/MIME)\n        * **--header name value** (may be used multiple times)\n        * **envelope(headers=[(name, value)])**\n        * **.header(name, value)**\n        \n        Equivalent headers: \n        ```bash\n        envelope --header X-Mailer my-app\n        ```\n        \n        ```python3\n        envelope(headers=[(\"X-Mailer\", \"my-app\")])\n        envelope().header(\"X-Mailer\", \"my-app\")\n        ```                \n#### Specific headers\nThese helpers are available via fluent interface.\n    \n* **.list_unsubscribe(uri=None, one_click=False, web=None, email=None)**: You can specify either url, email or both.\n    * **.list_unsubscribe(uri)**: We try to determine whether this is e-mail and prepend brackets and 'https:'/'mailto:' if needed. Ex: `me@example.com?subject=unsubscribe`, `example.com/unsubscribe`, `<https://example.com/unsubscribe>`\n    * **.list_unsubscribe(email=)**: E-mail address. Ex: `me@example.com`, `mailto:me@example.com`\n    * **.list_unsubscribe(web=, one_click=False)**: Specify URL. Ex: `example.com/unsubscribe`, `http://example.com/unsubscribe`. If `one_click=True`, rfc8058 List-Unsubscribe-Post header is added. This says user can unsubscribe with a single click that is realized by a POST request in order to prevent e-mail scanner to access the unsubscribe page by mistake. A 'https' url must be present.\n\n    ```python3\n    # These will produce:\n    # List-Unsubscribe: <https://example.com/unsubscribe>\n    envelope().list_unsubscribe(\"example.com/unsubscribe\")\n    envelope().list_unsubscribe(web=\"example.com/unsubscribe\")\n    envelope().list_unsubscribe(\"<https://example.com/unsubscribe>\")\n    \n    # This will produce:\n    # List-Unsubscribe: <https://example.com/unsubscribe>, <mailto:me@example.com?subject=unsubscribe>\n    envelope().list_unsubscribe(\"example.com/unsubscribe\", mail=\"me@example.com?subject=unsubscribe\")\n    ```    \n    \n* **.auto_submitted**: \n    * **.auto_submitted(val=\"auto-replied\")**: Direct response to another message by an automatic process. \n    * **.auto_submitted.auto_generated()**: automatic (often periodic) processes (such as UNIX \"cron jobs\") which are not direct responses to other messages\n    * **.auto_submitted.no()**: message was originated by a human\n\n```python3\nenvelope().auto_submitted()  # mark message as automatic        \nenvelope().auto_submitted.no()  # mark message as human produced\n```    \n### Supportive\n  * **.recipients()**: Return set of all recipients \u2013 To, Cc, Bcc\n    * **.recipients(clear=True)**: All To, Cc and Bcc recipients are removed and the object is returned.\n  * Read message and subject by **.message()** and **.subject()**\n  * **.preview()**: Returns the string of the message or data with the readable text.\n            Ex: whilst we have to use quoted-printable (as seen in __str__), here the output will be plain text.\n  * **check**: Check SMTP connection and returns True/False if succeeded. Tries to find SPF, DKIM and DMARC DNS records depending on the sender's domain and print them out.\n    * **--check**\n    * **.check()**\n    \n    ```bash\n    $ envelope --smtp localhost 25 --sender me@example.com --check \n    SPF found on the domain example.com: v=spf1 -all\n    See: dig -t SPF example.com && dig -t TXT example.com\n    DKIM found: ['v=DKIM1; g=*; k=rsa; p=...']\n    Could not spot DMARC.\n    Trying to connect to the SMTP...\n    Check succeeded.\n    ```\n * *static* **.load(message)** **(experimental)**: Parse any fetchable contents like an EML file to build an Envelope object.\n    * Still considered experimental: it cannot read an attachment which stays a mere part of the body, it cannot decrypt.\n    * Note that if you will send this reconstructed message, you might not probably receive it due to the Message-ID duplication.\n        Delete at least Message-ID header prior to re-sending. \n    ```python3\n   envelope.load(\"Subject: testing message\").subject()  # \"testing message\"\n    ```\n    \n## Default values\n\nIn *module* interface, you may set the defaults when accessing `envelope.default` instance. \n\n```python3\nenvelope.default.subject(\"Test subject\").signature()\nenvelope(\"Hello\")  # this message has a default subject and is signed by default when sent\n```\n\n## Converting object to str or bool\n\nWhen successfully signing, encrypting or sending, object is resolvable to True and signed text / produced e-mail could be obtained via str().\n\n```python3\no = envelope(\"message\", sign=True)\nstr(o)  # signed text\nbool(o)  # True\n```\n\n# Examples\n\n## Signing and encrypting\n\nSign the message.\n```python3\nenvelope(message=\"Hello world\", sign=True)\n```\n\nSign the message loaded from a file by standard pathlib library\n```python3\nfrom pathlib import Path\nenvelope(message=Path(\"/tmp/message.txt\"), sign=True)\n```\n\nSign the message got from a file-stream\n```python3\nwith open(\"/tmp/message.txt\") as f:\n    envelope(message=f, sign=True)\n```\n\nSign and encrypt the message so that's decryptable by keys for me@example.com and remote_person@example.com (that should already be loaded in the keyring).\n```python3 \nenvelope(message=\"Hello world\", sign=True\n        encrypt=True,\n        sender=\"me@example.com\",\n        to=\"remote_person@example.com\")\n```\n\nSign and encrypt the message so that's decryptable by keys for me@example.com and remote_person@example.com (that get's imported to the keyring from the file).\n```python3 \nenvelope(message=\"Hello world\", sign=True\n        encrypt=Path(\"/tmp/remote_key.asc\"),\n        sender=\"me@example.com\",\n        to=\"remote_person@example.com\")\n```\n\nSign the message via different keyring.\n```python3\nenvelope(message=\"Hello world\", sign=True, gnupg=\"/tmp/my-keyring/\")\n```\n\nSign the message with a key that needs passphrase.\n```python3 \nenvelope(message=\"Hello world\", sign=True, passphrase=\"my-password\")\n```\n\nSign a message without signing by default turned previously on and having a default keyring path. Every `envelope` call will honour these defaults. \n```python3 \nenvelope.default.signature(True).gnupghome(\"/tmp/my-keyring\")\nenvelope(message=\"Hello world\")\n```\n\n## Sending\nSend an e-mail via module call.\n```python3\nenvelope(message=\"Hello world\", send=True)\n```\n\nSend an e-mail via CLI and default SMTP server localhost on port 25.\n```bash\nenvelope --to \"user@example.org\" --message \"Hello world\" --send\n```\n\nSend while having specified the SMTP server host, port, username, password.\n\n```bash\nenvelope --to \"user@example.org\" message \"Hello world\" --send --smtp localhost 123 username password \n```\n\nSend while having specified the SMTP server through a dictionary.\n```bash\nenvelope --to \"user@example.org\" --message \"Hello world\" --send --smtp '{\"host\": \"localhost\", \"port\": \"123\"}' \n```\n\nSend while having specified the SMTP server via module call.\n```python3\nenvelope(message=\"Hello world\", to=\"user@example.org\", send=True, smtp={\"host\":\"localhost\"}) \n```\n\n## Attachment\nYou can attach a file in many different ways. Pick the one that suits you the best.\n```python3\nenvelope(attachment=Path(\"/tmp/file.txt\"))  # filename will be 'file.txt'\n\nwith open(\"/tmp/file.txt\") as f:\n    envelope(attachment=f)  # filename will be 'file.txt'\n    \nwith open(\"/tmp/file.txt\") as f:\n    envelope(attachment=(f, \"filename.txt\"))\n    \nenvelope().attach(path=\"/tmp/file.txt\",filename=\"filename.txt\")\n```\n\n## Complex example\nSend an encrypted and signed message via the default SMTP server, via all three interfaces.\n```bash\n# CLI interface\nenvelope --message \"Hello world\" --to \"user@example.org\" --sender \"me@example.org\" --subject \"Test\" --sign --encrypt -a /tmp/file.txt -a /tmp/file2 application/gzip zipped-file.zip --send\n```\n```python3\n# one-liner interface\nfrom pathlib import Path\nenvelope().message(\"Hello world\").to(\"user@example.org\").sender(\"me@example.org\").subject(\"Test\").signature().encryption().attach(path=\"/tmp/file.txt\").attach(Path(\"/tmp/file2\"), \"application/gzip\", \"zipped-file.zip\").send()\n\n# fluent interface\nenvelope(message=\"Hello world\", to=\"user@example.org\", sender=\"me@example.org\", subject=\"Test\", sign=True, encrypt=True, attachments=[(Path(\"/tmp/file.txt\"), (Path(\"/tmp/file2\"), \"application/gzip\", \"zipped-file.zip\")], send=True)\n```\n\nIn the condition *me@example.com* private key for signing, *user@example.com* public key for encrypting and open SMTP server on *localhost:25* are available, change `--send` to `--send 0` (or `.send()` to `.send(False)` or `send=True` to `send=False`) to investigate the generated message that may be similar to the following output:\n```bash\n****************************************************************************************************\nHave not been sent from me@example.org to user@example.org\nEncrypted subject: Test\nEncrypted message: b'Hello world'\n\nSubject: Encrypted message\nMIME-Version: 1.0\nContent-Type: multipart/encrypted; protocol=\"application/pgp-encrypted\";\n boundary=\"===============8462917939563016793==\"\nFrom: me@example.org\nTo: user@example.org\nDate: Tue, 08 Oct 2019 16:16:18 +0200\nMessage-ID: <157054417817.4405.938581433237601455@promyka>\n\n--===============8462917939563016793==\nContent-Type: application/pgp-encrypted\n\nVersion: 1\n--===============8462917939563016793==\nContent-Type: application/octet-stream; name=\"encrypted.asc\"\nContent-Description: OpenPGP encrypted message\nContent-Disposition: inline; filename=\"encrypted.asc\"\n\n-----BEGIN PGP MESSAGE-----\n\nhQMOAyx1c9zl1h4wEAv+PmtwjQDt+4XCn8YQJ6d7kyrp2R7xzS3PQwOZ7e+HWJjY\n(...)\nRQ8QtLLEza+rs+1lgcPgdBZEHFpYpgDb0AUvYg9d\n=YuqI\n-----END PGP MESSAGE-----\n\n--===============8462917939563016793==--\n```\n\n# Related affairs\nSending an e-mail does not mean it will be received. Sending it successfully through your local domain does not mean a public mailbox will accept it as well. If you are not trustworthy enough, your e-mail may not even appear at the recipient's spam bin, it can just be discarded without notice. \n\n## Configure your SMTP\nIt is always easier if you have an account on an SMTP server the application is able to send e-mails with. If it is not the case, various SMTP server exist but as a quick and non-secure solution, I've tested [bytemark/smtp](https://hub.docker.com/r/bytemark/smtp/) docker image that allows you to start up a SMTP server by a single line.\n\n```bash\ndocker run --network=host --restart always -d bytemark/smtp   # starts open port 25 on localhost\nenvelope --message \"SMTP test\" --from [your e-mail] --to [your e-mail] --smtp localhost 25 --send\n```\n\n## Choose ciphering method\n\n### Configure your GPG\nIn order to sign messages, you need a private key. Let's pretend a usecase when your application will run under `www-data` user and GPG sign messages through the keys located at: `/var/www/.gnupg`. You have got a SMTP server with an e-mail account the application may use.\n```bash \nGNUPGHOME=/var/www/.gnupg sudo -H -u www-data gpg --full-generate-key  # put application e-mail your are able to send the e-mail from\n# if the generation fails now because you are on a remote terminal, you may want to change temporarily the ownership of the terminal by the following command: \n# sudo chown www-data $(tty)  # put it back afterwards\nGNUPGHOME=/var/www/.gnupg sudo -H -u www-data gpg --list-secret-keys  # get key ID\nGNUPGHOME=/var/www/.gnupg sudo -H -u www-data gpg --send-keys [key ID]  # now the world is able to pull the key from a global webserver when they receive an e-mail from you\nGNUPGHOME=/var/www/.gnupg sudo -H -u www-data envelope --message \"Hello world\" --subject \"GPG signing test\" --sign [key ID] --from [application e-mail] --to [your e-mail] --send  # you now receive e-mail and may import the key and set the trust to the key\n```\n\nIt takes few hours to a key to propagate. If the key cannot be imported in your e-mail client because not found on the servers, try in the morning again or check the online search form at http://hkps.pool.sks-keyservers.net.  \nPut your fingerprint on the web or on the business card then so that everybody can check your signature is valid.\n\n### Configure your S/MIME\nIf you are supposed to use S/MIME, you would probably be told where to take your key and certificate from. If planning to try it all by yourself, generate your `certificate.pem`.\n \n* Either: Do you have private key?\n```bash\nopenssl req -key YOUR-KEY.pem -nodes -x509 -days 365 -out certificate.pem  # will generate privkey.pem alongside\n```\n \n* Or: Do not you have private key? \n```bash\nopenssl req -newkey rsa:1024 -nodes -x509 -days 365 -out certificate.pem  # will generate privkey.pem alongside\n```\n\nNow, you may sign a message with your key and certificate. (However, the messages **will not be trustworthy** because no authority signed the certificate.) Give your friend the certificate so that they might verify the message comes from you. Receive a certificate from a friend to encrypt them a message with.\n```\nenvelope --message \"Hello world\" --subject \"S/MIME signing test\" --sign-path [key file] --cert-path [certificate file] --from [application e-mail] --to [your e-mail] --send # you now receive e-mail\n```\n\n## DNS validation tools\nThis is just a short explanation on these anti-spam mechanisms so that you can take basic notion what is going on.\n\nEvery time, the receiver should ask the sender's domain these questions over DNS.  \n\n### SPF\nThe receiver asks the sender's domain: Do you allow the senders IP/domain to send the e-mail on your behalf?\n\nCheck your domain on SPF:\n```bash\ndig -t TXT example.com\n``` \n\n### DKIM\nThe receiver asks the sender's domain: Give me the public key so that I may check the hash in the e-mail header that assert the message was composed by your private key. So that the e-mail comes trustworthy from you and nobody modified it on the way.\n\nCheck your domain on DKIM:\n```bash\ndig -t TXT [selector]._domainkey.example.com\n``` \nYou can obtain the `selector` from an e-mail message you received. Check the line `DKIM-Signature` and the value of the param `s`.\n```\nDKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=example.com; s=default;\n```\n\n## DMARC\nWhat is your policy concerning SPF and DKIM? What abuse address do you have?\n\nCheck your domain on DMARC:\n```bash\ndig -t TXT _dmarc.example.com\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/CZ-NIC/envelope", "keywords": "", "license": "GNU GPLv3", "maintainer": "", "maintainer_email": "", "name": "envelope", "package_url": "https://pypi.org/project/envelope/", "platform": "", "project_url": "https://pypi.org/project/envelope/", "project_urls": {"Homepage": "https://github.com/CZ-NIC/envelope"}, "release_url": "https://pypi.org/project/envelope/0.9.9/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Insert a message and attachments and send e-mail / sign / encrypt contents by a single line.", "version": "0.9.9", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>envelope</h1>\n<p><a href=\"https://travis-ci.org/CZ-NIC/envelope\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bf443f35d401dd6409a13ed6aca4408240e27c8a/68747470733a2f2f7472617669732d63692e6f72672f435a2d4e49432f656e76656c6f70652e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>Quick layer over <a href=\"https://bitbucket.org/vinay.sajip/python-gnupg/src\" rel=\"nofollow\">python-gnupg</a>, <a href=\"https://m2crypto.readthedocs.io/\" rel=\"nofollow\">M2Crypto</a>, <a href=\"https://docs.python.org/3/library/smtplib.html\" rel=\"nofollow\">smtplib</a>, <a href=\"https://pypi.org/project/python-magic/\" rel=\"nofollow\">magic</a> and <a href=\"https://docs.python.org/3/library/email.html?highlight=email#module-email\" rel=\"nofollow\">email</a> handling packages. Their common usecases merged into a single function. Want to sign a text and tired of forgetting how to do it right? You do not need to know everything about GPG or S/MIME, you do not have to bother with importing keys. Do not hassle with reconnecting SMTP server. Do not study various headers meanings to let your users unsubscribe via a URL.<br>\nYou insert a message and attachments and receive signed and/or encrypted output to the file or to your recipients' e-mail.<br>\nJust single line of code. With the great help of the examples below.</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"s2\">\"my message\"</span><span class=\"p\">)</span>\n    <span class=\"o\">.</span><span class=\"n\">subject</span><span class=\"p\">(</span><span class=\"s2\">\"hello world\"</span><span class=\"p\">)</span>\n    <span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s2\">\"example@example.com\"</span><span class=\"p\">)</span>\n    <span class=\"o\">.</span><span class=\"n\">attach</span><span class=\"p\">(</span><span class=\"n\">file_contents</span><span class=\"p\">,</span> <span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s2\">\"attached-file.txt\"</span><span class=\"p\">)</span>\n    <span class=\"o\">.</span><span class=\"n\">smtp</span><span class=\"p\">(</span><span class=\"s2\">\"localhost\"</span><span class=\"p\">,</span> <span class=\"mi\">587</span><span class=\"p\">,</span> <span class=\"s2\">\"user\"</span><span class=\"p\">,</span> <span class=\"s2\">\"pass\"</span><span class=\"p\">,</span> <span class=\"s2\">\"starttls\"</span><span class=\"p\">)</span>\n    <span class=\"o\">.</span><span class=\"n\">signature</span><span class=\"p\">()</span>\n    <span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">()</span>\n</pre>\n<ul>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a>\n<ul>\n<li><a href=\"#bash-completion\" rel=\"nofollow\">Bash completion</a></li>\n</ul>\n</li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a>\n<ul>\n<li><a href=\"#cli\" rel=\"nofollow\">CLI</a></li>\n<li><a href=\"#module-one-liner-function\" rel=\"nofollow\">Module: one-liner function</a></li>\n<li><a href=\"#module-fluent-interface\" rel=\"nofollow\">Module: fluent interface</a></li>\n</ul>\n</li>\n<li><a href=\"#documentation\" rel=\"nofollow\">Documentation</a>\n<ul>\n<li><a href=\"#command-list\" rel=\"nofollow\">Command list</a>\n<ul>\n<li><a href=\"#input--output\" rel=\"nofollow\">Input / Output</a></li>\n<li><a href=\"#cipher-standard-method\" rel=\"nofollow\">Cipher standard method</a></li>\n<li><a href=\"#signing\" rel=\"nofollow\">Signing</a></li>\n<li><a href=\"#encrypting\" rel=\"nofollow\">Encrypting</a></li>\n<li><a href=\"#sending\" rel=\"nofollow\">Sending</a>\n<ul>\n<li><a href=\"#specific-headers\" rel=\"nofollow\">Specific headers</a></li>\n</ul>\n</li>\n<li><a href=\"#supportive\" rel=\"nofollow\">Supportive</a></li>\n</ul>\n</li>\n<li><a href=\"#default-values\" rel=\"nofollow\">Default values</a></li>\n<li><a href=\"#converting-object-to-str-or-bool\" rel=\"nofollow\">Converting object to str or bool</a></li>\n</ul>\n</li>\n<li><a href=\"#examples\" rel=\"nofollow\">Examples</a>\n<ul>\n<li><a href=\"#signing-and-encrypting\" rel=\"nofollow\">Signing and encrypting</a></li>\n<li><a href=\"#sending-1\" rel=\"nofollow\">Sending</a></li>\n<li><a href=\"#attachment\" rel=\"nofollow\">Attachment</a></li>\n<li><a href=\"#complex-example\" rel=\"nofollow\">Complex example</a></li>\n</ul>\n</li>\n<li><a href=\"#related-affairs\" rel=\"nofollow\">Related affairs</a>\n<ul>\n<li><a href=\"#configure-your-smtp\" rel=\"nofollow\">Configure your SMTP</a></li>\n<li><a href=\"#choose-ciphering-method\" rel=\"nofollow\">Choose ciphering method</a>\n<ul>\n<li><a href=\"#configure-your-gpg\" rel=\"nofollow\">Configure your GPG</a></li>\n<li><a href=\"#configure-your-smime\" rel=\"nofollow\">Configure your S/MIME</a></li>\n</ul>\n</li>\n<li><a href=\"#dns-validation-tools\" rel=\"nofollow\">DNS validation tools</a>\n<ul>\n<li><a href=\"#spf\" rel=\"nofollow\">SPF</a></li>\n<li><a href=\"#dkim\" rel=\"nofollow\">DKIM</a></li>\n<li><a href=\"#dmarc\" rel=\"nofollow\">DMARC</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1>Installation</h1>\n<ul>\n<li>If planning to use S/MIME, you should ensure some prerequisites:</li>\n</ul>\n<pre>sudo apt install swig\npip3 install M2Crypto\n</pre>\n<ul>\n<li>Install with a single command from <a href=\"https://pypi.org/project/envelope/\" rel=\"nofollow\">PyPi</a>\n<pre>pip3 install envelope\n</pre>\n<ul>\n<li>Or install current GitHub master</li>\n</ul>\n<pre>pip3 install git+https://github.com/CZ-NIC/envelope.git\n</pre>\n<ul>\n<li>Or just download the project and launch <code>./envelope.py</code></li>\n</ul>\n</li>\n<li>If planning to send e-mails, prepare SMTP credentials or visit <a href=\"#configure-your-smtp\" rel=\"nofollow\">Configure your SMTP</a> tutorial.</li>\n<li>If your e-mails are to be received outside your local domain, visit <a href=\"#dmarc\" rel=\"nofollow\">DMARC</a> section.</li>\n<li>If planning to sign/encrypt with GPG, install the corresponding package and possibly see <a href=\"#configure-your-gpg\" rel=\"nofollow\">Configure your GPG</a> tutorial.</li>\n</ul>\n<pre>sudo apt install gpg\n</pre>\n<h2>Bash completion</h2>\n<ol>\n<li>Run: apt-get install bash-completion jq</li>\n<li>Copy: extra/convey-autocompletion.bash to /etc/bash_completion.d/</li>\n<li>Restart terminal</li>\n</ol>\n<h1>Usage</h1>\n<p>As an example, let's produce in three equal ways an <code>output_file</code> with the GPG-encrypted \"Hello world\" content.</p>\n<h2>CLI</h2>\n<p>Launch as a CLI application in terminal, see <code>envelope --help</code></p>\n<pre>envelope --message <span class=\"s2\">\"Hello world\"</span> <span class=\"se\">\\</span>\n               --output <span class=\"s2\">\"/tmp/output_file\"</span> <span class=\"se\">\\</span>\n               --sender <span class=\"s2\">\"me@example.com\"</span> <span class=\"se\">\\</span>\n               --to <span class=\"s2\">\"remote_person@example.com\"</span> <span class=\"se\">\\</span>\n               --encrypt-path <span class=\"s2\">\"/tmp/remote_key.asc\"</span>\n</pre>\n<h2>Module: one-liner function</h2>\n<p>You can easily write a one-liner function that encrypts your code or sends an e-mail from within your application when imported as a module. See <code>pydoc3 envelope</code> or documentation below.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">envelope</span>\n<span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span>\n        <span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/output_file\"</span><span class=\"p\">,</span>\n        <span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"s2\">\"me@example.com\"</span><span class=\"p\">,</span>\n        <span class=\"n\">to</span><span class=\"o\">=</span><span class=\"s2\">\"remote_person@example.com\"</span><span class=\"p\">,</span>\n        <span class=\"n\">encrypt</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/remote_key.asc\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Module: fluent interface</h2>\n<p>Comfortable way to create the structure if your IDE supports autocompletion.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">envelope</span>\n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">message</span><span class=\"p\">(</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">)</span>\\\n    <span class=\"o\">.</span><span class=\"n\">output</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/output_file\"</span><span class=\"p\">)</span>\\\n    <span class=\"o\">.</span><span class=\"n\">sender</span><span class=\"p\">(</span><span class=\"s2\">\"me@example.com\"</span><span class=\"p\">)</span>\\\n    <span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s2\">\"remote_person@example.com\"</span><span class=\"p\">)</span>\\\n    <span class=\"o\">.</span><span class=\"n\">encrypt</span><span class=\"p\">(</span><span class=\"n\">key_path</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/remote_key.asc\"</span><span class=\"p\">)</span>\n</pre>\n<p>Note: if autocompletion does not work, use <strong><code>from envelope import envelope</code></strong> instead of <code>import envelope</code>.<br>\n(For example, Jupyter can autocomplete with <code>import envelope</code> but PyCharm cannot because it does not serves itself with a <a href=\"https://youtrack.jetbrains.com/issue/PY-38086#comment=27-3716668\" rel=\"nofollow\">running kernel</a>.)</p>\n<h1>Documentation</h1>\n<p>Both <code>envelope --help</code> for CLI arguments help and <code>pydoc3 envelope</code> to see module arguments help should contain same information as here.</p>\n<h2>Command list</h2>\n<p>All parameters are optional.</p>\n<ul>\n<li><strong>--param</strong> is used in CLI</li>\n<li><strong>envelope(param=)</strong> is a one-liner argument</li>\n<li><strong>.param(value)</strong> denotes a positional argument</li>\n<li><strong>.param(value=)</strong> denotes a keyword argument</li>\n</ul>\n<p>Any fetchable contents means plain text, bytes or stream (ex: from open()). In <em>module interface</em>, you may use Path object to the file. In <em>CLI interface</em>, additional flags are provided.</p>\n<h3>Input / Output</h3>\n<ul>\n<li>\n<p><strong>message</strong>: Message / body text.</p>\n<ul>\n<li><strong>--message</strong>: String</li>\n<li><strong>--input</strong>: <em>(CLI only)</em> Path to the message file. (Alternative to <code>--message</code> parameter.)</li>\n<li><strong>envelope(message=)</strong>: Any fetchable contents</li>\n<li><strong>.message(text)</strong>:  String or stream.</li>\n<li><strong>.message(path=None)</strong>: Path to the file.</li>\n</ul>\n<p>Equivalents for setting a string (in <em>Python</em> and in <em>Bash</em>).</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"hello\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">message</span><span class=\"p\">(</span><span class=\"s2\">\"hello\"</span><span class=\"p\">)</span>\n</pre>\n<pre>envelope --message <span class=\"s2\">\"hello\"</span>\n</pre>\n<p>Equivalents for setting contents of a file (in <em>Python</em> and in <em>Bash</em>).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pathlib</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n<span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"file.txt\"</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"file.txt\"</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"n\">envelope</span><span class=\"o\">.</span><span class=\"n\">message</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s2\">\"file.txt\"</span><span class=\"p\">)</span> \n</pre>\n<pre>envelope --input file.txt\n</pre>\n</li>\n<li>\n<p><strong>output</strong>: Path to file to be written to (else the contents is returned).</p>\n<ul>\n<li><strong>--output</strong></li>\n<li><strong>envelope(output=)</strong></li>\n<li><strong>.output(output_file)</strong></li>\n</ul>\n</li>\n</ul>\n<h3>Cipher standard method</h3>\n<p>Note that if neither <em>gpg</em> nor <em>smime</em> is specified, we try to determine the method automatically.</p>\n<ul>\n<li><strong>gpg</strong>: True to prefer GPG over S/MIME or home path to GNUPG rings (otherwise default ~/.gnupg is used)\n<ul>\n<li><strong>--gpg [path]</strong></li>\n<li><strong>envelope(gpg=True)</strong></li>\n<li><strong>.gpg(gnugp_home=True)</strong></li>\n</ul>\n</li>\n<li><strong>.smime</strong>: Prefer S/MIME over GPG\n<ul>\n<li><strong>--smime</strong></li>\n<li><strong>envelope(smime=True)</strong></li>\n<li><strong>.smime()</strong></li>\n</ul>\n</li>\n</ul>\n<h3>Signing</h3>\n<ul>\n<li><strong>sign</strong>: Sign the message.\n<ul>\n<li><strong>--sign</strong>:\n<ul>\n<li>\"auto\" for turning on signing if there is a key matching to the \"from\" header</li>\n<li>GPG: Blank for user default key or key ID/fingerprint.</li>\n<li>S/MIME: Any fetchable contents with key.</li>\n</ul>\n</li>\n<li><strong>--sign-path</strong>: S/MIME: Filename with the sender's private key. (Alternative to <code>sign</code> parameter.)</li>\n<li><strong>--passphrase</strong>: Passphrase to the key if needed.</li>\n<li><strong>--attach-key</strong>: GPG: Blank for appending public key to the attachments when sending.</li>\n<li><strong>--cert</strong>: S/MIME: Certificate contents if not included in the key.</li>\n<li><strong>--cert-path</strong>: S/MIME: Filename with the sender's private cert if cert not included in the key. (Alternative to <code>cert</code> parameter.)</li>\n<li><strong>envelope(sign=)</strong>:\n<ul>\n<li>GPG: True for user default key or key ID/fingerprint.</li>\n<li>S/MIME: Key contents.</li>\n</ul>\n</li>\n<li><strong>envelope(passphrase=)</strong>: Passphrase to the key if needed.</li>\n<li><strong>envelope(attach_key=)</strong>: GPG: Append public key to the attachments when sending.</li>\n<li><strong>envelope(cert=)</strong>: S/MIME: Any fetchable contents.</li>\n<li><strong>.sign(key=True, passphrase=, attach_key=False, cert=None, key_path=None)</strong>: Sign now (and you may specify the parameters)</li>\n<li><strong>.signature(key=True, passphrase=, attach_key=False, cert=None, key_path=None)</strong>: Sign later (when launched with <em>.sign()</em>, <em>.encrypt()</em> or <em>.send()</em> functions</li>\n</ul>\n</li>\n</ul>\n<h3>Encrypting</h3>\n<p>If the GPG encryption fails, it tries to determine which recipient misses the key.</p>\n<ul>\n<li><strong>encrypt</strong>:  Recipient GPG public key or S/MIME certificate to be encrypted with.\n<ul>\n<li><strong>--encrypt</strong>: Key string or blank or 1/true/yes if the key should be in the ring from before. Put 0/false/no to disable <code>encrypt-path</code>.</li>\n<li><strong>--encrypt-path</strong> <em>(CLI only)</em>: Recipient public key stored in a file path. (Alternative to <code>--encrypt</code>.)</li>\n<li><strong>envelope(encrypt=)</strong>: Any fetchable contents</li>\n<li><strong>.encrypt(key=True, sign=, key_path=)</strong>: With <em>sign</em>, you may specify boolean or default signing key ID/fingerprint for GPG or Any fetchable contents with S/MIME key + signing certificate. If import needed, put your encrypting GPG key contents or S/MIME certificate to <em>key</em> or path to the key/certificate contents file in <em>key_path</em>.</li>\n<li><strong>.encryption(key=True, key_path=)</strong>: Encrypt later (when launched with <em>.sign()</em>, <em>.encrypt()</em> or <em>.send()</em> functions. If needed, in the parameters specify Any fetchable contents with GPG encryption key or S/MIME encryption certificate.</li>\n</ul>\n</li>\n<li><strong>to</strong>: E-mail or list. When encrypting, we use keys of these identities.\n<ul>\n<li><strong>--to</strong>: One or more e-mail addresses.</li>\n<li><strong>envelope(to=)</strong>: E-mail or their list.</li>\n<li><strong>.to(email_or_list)</strong>:\n<pre>envelope --to first@example.com second@example.com --message <span class=\"s2\">\"hello\"</span> \n</pre>\n</li>\n</ul>\n</li>\n<li><strong>sender</strong>: E-mail \u2013 needed to choose our key if encrypting.\n<ul>\n<li><strong>--sender</strong> E-mail</li>\n<li><strong>--no-sender</strong> Declare we want to encrypt and never decrypt back.</li>\n<li><strong>--from</strong> Alias for <em>--sender</em></li>\n<li><strong>envelope(sender=)</strong>: Sender e-mail or False to explicitly omit. When encrypting without sender, we do not use their key so that we will not be able to decipher again.</li>\n<li><strong>.sender(email)</strong>: E-mail or False.</li>\n<li><strong>.from_(email)</strong>: an alias for <em>.sender</em></li>\n</ul>\n</li>\n</ul>\n<h3>Sending</h3>\n<ul>\n<li>\n<p><strong>send</strong>: Send the message to the recipients by e-mail. True (blank in <em>CLI</em>) to send now or False to print out debug information.</p>\n<ul>\n<li><strong>--send</strong></li>\n<li><strong>envelope(send=)</strong></li>\n<li><strong>.send(send=True, sign=None, encrypt=None)</strong>\n<ul>\n<li><em>send</em>: True to send now. False (or 0/false/no in <em>CLI</em>) to print debug information.</li>\n</ul>\n</li>\n</ul>\n<pre>$ envelope --to <span class=\"s2\">\"user@example.org\"</span> --message <span class=\"s2\">\"Hello world\"</span> --send <span class=\"m\">0</span>\n****************************************************************************************************\nHave not been sent from  to user@example.org\n\nContent-Type: text/html<span class=\"p\">;</span> <span class=\"nv\">charset</span><span class=\"o\">=</span><span class=\"s2\">\"utf-8\"</span>\nContent-Transfer-Encoding: 7bit\nMIME-Version: <span class=\"m\">1</span>.0\nSubject:\nFrom:\nTo: user@example.org\nDate: Mon, <span class=\"m\">07</span> Oct <span class=\"m\">2019</span> <span class=\"m\">16</span>:13:37 +0200\nMessage-ID: &lt;<span class=\"m\">157045761791</span>.29779.5279828659897745855@...&gt;\n\nHello world\n</pre>\n</li>\n<li>\n<p><strong>subject</strong>: Mail subject. Gets encrypted with GPG, stays visible with S/MIME.</p>\n<ul>\n<li><strong>--subject</strong></li>\n<li><strong>envelope(subject=)</strong></li>\n<li><strong>.subject(text)</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>cc</strong>: E-mail or their list</p>\n<ul>\n<li><strong>--cc</strong></li>\n<li><strong>envelope(cc=)</strong></li>\n<li><strong>.cc(email_or_list)</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>bcc</strong>: E-mail or their list</p>\n<ul>\n<li><strong>--bcc</strong></li>\n<li><strong>envelope(bcc=)</strong></li>\n<li><strong>.bcc(email_or_list)</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>reply-to</strong>: E-mail to be replied to. The field is not encrypted.</p>\n<ul>\n<li><strong>--reply-to</strong></li>\n<li><strong>envelope(reply_to=)</strong></li>\n<li><strong>.reply_to(email)</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>smtp</strong>: SMTP server</p>\n<ul>\n<li><strong>--smtp</strong></li>\n<li><strong>envelope(smtp=)</strong></li>\n<li><strong>.smtp(host=\"localhost\", port=25, user=, password=, security=)</strong></li>\n<li>Parameters:\n<ul>\n<li><code>host</code> may include hostname or any of the following input formats (ex: path to an INI file or a <code>dict</code>)</li>\n<li><code>security</code> if not set, automatically set to <code>starttls</code> for port <em>587</em> and to <code>tls</code> for port <em>465</em></li>\n</ul>\n</li>\n<li>Input format may be in the following form:\n<ul>\n<li><code>None</code> default localhost server used</li>\n<li><code>smtplib.SMTP</code> object</li>\n<li><code>list</code> or <code>tuple</code> having <code>host, [port, [username, password, [security]]]</code> parameters\n<ul>\n<li>ex: <code>envelope --smtp localhost 125 me@example.com</code> will set up host, port and username parameters</li>\n</ul>\n</li>\n<li><code>dict</code> specifying {\"host\": ..., \"port\": ...}\n<ul>\n<li>ex: <code>envelope --smtp '{\"host\": \"localhost\"}'</code> will set up host parameter</li>\n</ul>\n</li>\n<li><code>str</code> hostname or path to an INI file (existing file, ending at <code>.ini</code>, with the section [SMTP])\n<pre><span class=\"k\">[SMTP]</span>\n<span class=\"na\">host</span> <span class=\"o\">=</span> <span class=\"s\">example.com</span>\n<span class=\"na\">port</span> <span class=\"o\">=</span> <span class=\"s\">587            </span>\n</pre>\n</li>\n</ul>\n</li>\n<li>Do not fear to pass the <code>smtp</code> in a loop, we make just a single connection to the server. If timed out, we attempt to reconnect once.</li>\n</ul>\n<pre><span class=\"n\">smtp</span> <span class=\"o\">=</span> <span class=\"n\">localhost</span><span class=\"p\">,</span> <span class=\"mi\">25</span>\n<span class=\"k\">for</span> <span class=\"n\">mail</span> <span class=\"ow\">in</span> <span class=\"n\">mails</span><span class=\"p\">:</span>\n    <span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">smtp</span><span class=\"p\">(</span><span class=\"n\">smtp</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">()</span>\n</pre>\n</li>\n<li>\n<p><strong>attachments</strong></p>\n<ul>\n<li><strong>--attachment</strong>: Path to the attachment, followed by optional file name to be used and/or mime type. This parameter may be used multiple times.</li>\n</ul>\n<pre>envelope --attachment <span class=\"s2\">\"/tmp/file.txt\"</span> <span class=\"s2\">\"displayed-name.txt\"</span> <span class=\"s2\">\"text/plain\"</span> --attachment <span class=\"s2\">\"/tmp/another-file.txt\"</span>\n</pre>\n<ul>\n<li><strong>gpggp(attachments=)</strong>: Attachment or their list. Attachment is defined by any fetchable contents, optionally in tuple with the file name to be used in the e-mail and/or mime type: <code>content [,name] [,mimetype]</code></li>\n</ul>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">attachments</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/file.txt\"</span><span class=\"p\">),</span> <span class=\"s2\">\"displayed-name.txt\"</span><span class=\"p\">,</span> <span class=\"s2\">\"text/plain\"</span><span class=\"p\">),</span> <span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/another-file.txt\"</span><span class=\"p\">])</span>\n</pre>\n<ul>\n<li><strong>.attach(attachment_or_list=, path=, mimetype=, filename=)</strong>: Three different usages.\n<ul>\n<li><strong>.attach(attachment_or_list=, mimetype=, filename=)</strong>: You can put Any fetchable contents in <em>attachment_or_list</em> and optionally mimetype or displayed filename.</li>\n<li><strong>.attach(path=, mimetype=, filename=)</strong>: You can specify path and optionally mimetype or displayed filename.</li>\n<li><strong>.attach(attachment_or_list=)</strong>: You can put a list of attachments.</li>\n</ul>\n</li>\n</ul>\n<pre><span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">attach</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/file.txt\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">attach</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/another-file.txt\"</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li>\n<p><strong>mime</strong>: Set contents mime subtype: \"auto\" (default), \"html\" or \"plain\" for plain text. Ignored if <code>Content-Type</code> header put to the message.</p>\n<ul>\n<li><strong>--mime SUBTYPE</strong></li>\n<li><strong>envelope(mime=)</strong></li>\n<li><strong>.mime(subtype=\"auto\", nl2br=\"auto\")</strong>\n<ul>\n<li>nl2br: True: envelope will append <code>&lt;br&gt;</code> to every line break in the HTML message. \"auto\": line breaks are changed only if there is no <code>&lt;br</code> or <code>&lt;p</code> in the HTML message,</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>headers</strong>: Any custom headers (these will not be encrypted with GPG nor S/MIME)</p>\n<ul>\n<li><strong>--header name value</strong> (may be used multiple times)</li>\n<li><strong>envelope(headers=[(name, value)])</strong></li>\n<li><strong>.header(name, value)</strong></li>\n</ul>\n<p>Equivalent headers:</p>\n<pre>envelope --header X-Mailer my-app\n</pre>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">headers</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"s2\">\"X-Mailer\"</span><span class=\"p\">,</span> <span class=\"s2\">\"my-app\"</span><span class=\"p\">)])</span>\n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">header</span><span class=\"p\">(</span><span class=\"s2\">\"X-Mailer\"</span><span class=\"p\">,</span> <span class=\"s2\">\"my-app\"</span><span class=\"p\">)</span>\n</pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4>Specific headers</h4>\n<p>These helpers are available via fluent interface.</p>\n<ul>\n<li>\n<p><strong>.list_unsubscribe(uri=None, one_click=False, web=None, email=None)</strong>: You can specify either url, email or both.</p>\n<ul>\n<li><strong>.list_unsubscribe(uri)</strong>: We try to determine whether this is e-mail and prepend brackets and 'https:'/'mailto:' if needed. Ex: <code>me@example.com?subject=unsubscribe</code>, <code>example.com/unsubscribe</code>, <code>&lt;https://example.com/unsubscribe&gt;</code></li>\n<li><strong>.list_unsubscribe(email=)</strong>: E-mail address. Ex: <code>me@example.com</code>, <code>mailto:me@example.com</code></li>\n<li><strong>.list_unsubscribe(web=, one_click=False)</strong>: Specify URL. Ex: <code>example.com/unsubscribe</code>, <code>http://example.com/unsubscribe</code>. If <code>one_click=True</code>, rfc8058 List-Unsubscribe-Post header is added. This says user can unsubscribe with a single click that is realized by a POST request in order to prevent e-mail scanner to access the unsubscribe page by mistake. A 'https' url must be present.</li>\n</ul>\n<pre><span class=\"c1\"># These will produce:</span>\n<span class=\"c1\"># List-Unsubscribe: &lt;https://example.com/unsubscribe&gt;</span>\n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">list_unsubscribe</span><span class=\"p\">(</span><span class=\"s2\">\"example.com/unsubscribe\"</span><span class=\"p\">)</span>\n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">list_unsubscribe</span><span class=\"p\">(</span><span class=\"n\">web</span><span class=\"o\">=</span><span class=\"s2\">\"example.com/unsubscribe\"</span><span class=\"p\">)</span>\n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">list_unsubscribe</span><span class=\"p\">(</span><span class=\"s2\">\"&lt;https://example.com/unsubscribe&gt;\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># This will produce:</span>\n<span class=\"c1\"># List-Unsubscribe: &lt;https://example.com/unsubscribe&gt;, &lt;mailto:me@example.com?subject=unsubscribe&gt;</span>\n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">list_unsubscribe</span><span class=\"p\">(</span><span class=\"s2\">\"example.com/unsubscribe\"</span><span class=\"p\">,</span> <span class=\"n\">mail</span><span class=\"o\">=</span><span class=\"s2\">\"me@example.com?subject=unsubscribe\"</span><span class=\"p\">)</span>\n</pre>\n</li>\n<li>\n<p><strong>.auto_submitted</strong>:</p>\n<ul>\n<li><strong>.auto_submitted(val=\"auto-replied\")</strong>: Direct response to another message by an automatic process.</li>\n<li><strong>.auto_submitted.auto_generated()</strong>: automatic (often periodic) processes (such as UNIX \"cron jobs\") which are not direct responses to other messages</li>\n<li><strong>.auto_submitted.no()</strong>: message was originated by a human</li>\n</ul>\n</li>\n</ul>\n<pre><span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">auto_submitted</span><span class=\"p\">()</span>  <span class=\"c1\"># mark message as automatic        </span>\n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">auto_submitted</span><span class=\"o\">.</span><span class=\"n\">no</span><span class=\"p\">()</span>  <span class=\"c1\"># mark message as human produced</span>\n</pre>\n<h3>Supportive</h3>\n<ul>\n<li>\n<p><strong>.recipients()</strong>: Return set of all recipients \u2013 To, Cc, Bcc</p>\n<ul>\n<li><strong>.recipients(clear=True)</strong>: All To, Cc and Bcc recipients are removed and the object is returned.</li>\n</ul>\n</li>\n<li>\n<p>Read message and subject by <strong>.message()</strong> and <strong>.subject()</strong></p>\n</li>\n<li>\n<p><strong>.preview()</strong>: Returns the string of the message or data with the readable text.\nEx: whilst we have to use quoted-printable (as seen in <strong>str</strong>), here the output will be plain text.</p>\n</li>\n<li>\n<p><strong>check</strong>: Check SMTP connection and returns True/False if succeeded. Tries to find SPF, DKIM and DMARC DNS records depending on the sender's domain and print them out.</p>\n<ul>\n<li><strong>--check</strong></li>\n<li><strong>.check()</strong></li>\n</ul>\n<pre>$ envelope --smtp localhost <span class=\"m\">25</span> --sender me@example.com --check \nSPF found on the domain example.com: <span class=\"nv\">v</span><span class=\"o\">=</span>spf1 -all\nSee: dig -t SPF example.com <span class=\"o\">&amp;&amp;</span> dig -t TXT example.com\nDKIM found: <span class=\"o\">[</span><span class=\"s1\">'v=DKIM1; g=*; k=rsa; p=...'</span><span class=\"o\">]</span>\nCould not spot DMARC.\nTrying to connect to the SMTP...\nCheck succeeded.\n</pre>\n</li>\n<li>\n<p><em>static</em> <strong>.load(message)</strong> <strong>(experimental)</strong>: Parse any fetchable contents like an EML file to build an Envelope object.</p>\n<ul>\n<li>Still considered experimental: it cannot read an attachment which stays a mere part of the body, it cannot decrypt.</li>\n<li>Note that if you will send this reconstructed message, you might not probably receive it due to the Message-ID duplication.\nDelete at least Message-ID header prior to re-sending.</li>\n</ul>\n<pre><span class=\"n\">envelope</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s2\">\"Subject: testing message\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">subject</span><span class=\"p\">()</span>  <span class=\"c1\"># \"testing message\"</span>\n</pre>\n</li>\n</ul>\n<h2>Default values</h2>\n<p>In <em>module</em> interface, you may set the defaults when accessing <code>envelope.default</code> instance.</p>\n<pre><span class=\"n\">envelope</span><span class=\"o\">.</span><span class=\"n\">default</span><span class=\"o\">.</span><span class=\"n\">subject</span><span class=\"p\">(</span><span class=\"s2\">\"Test subject\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">signature</span><span class=\"p\">()</span>\n<span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"s2\">\"Hello\"</span><span class=\"p\">)</span>  <span class=\"c1\"># this message has a default subject and is signed by default when sent</span>\n</pre>\n<h2>Converting object to str or bool</h2>\n<p>When successfully signing, encrypting or sending, object is resolvable to True and signed text / produced e-mail could be obtained via str().</p>\n<pre><span class=\"n\">o</span> <span class=\"o\">=</span> <span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"s2\">\"message\"</span><span class=\"p\">,</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">)</span>  <span class=\"c1\"># signed text</span>\n<span class=\"nb\">bool</span><span class=\"p\">(</span><span class=\"n\">o</span><span class=\"p\">)</span>  <span class=\"c1\"># True</span>\n</pre>\n<h1>Examples</h1>\n<h2>Signing and encrypting</h2>\n<p>Sign the message.</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Sign the message loaded from a file by standard pathlib library</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pathlib</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n<span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/message.txt\"</span><span class=\"p\">),</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Sign the message got from a file-stream</p>\n<pre><span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/message.txt\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Sign and encrypt the message so that's decryptable by keys for <a href=\"mailto:me@example.com\">me@example.com</a> and <a href=\"mailto:remote_person@example.com\">remote_person@example.com</a> (that should already be loaded in the keyring).</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n        <span class=\"n\">encrypt</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n        <span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"s2\">\"me@example.com\"</span><span class=\"p\">,</span>\n        <span class=\"n\">to</span><span class=\"o\">=</span><span class=\"s2\">\"remote_person@example.com\"</span><span class=\"p\">)</span>\n</pre>\n<p>Sign and encrypt the message so that's decryptable by keys for <a href=\"mailto:me@example.com\">me@example.com</a> and <a href=\"mailto:remote_person@example.com\">remote_person@example.com</a> (that get's imported to the keyring from the file).</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n        <span class=\"n\">encrypt</span><span class=\"o\">=</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/remote_key.asc\"</span><span class=\"p\">),</span>\n        <span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"s2\">\"me@example.com\"</span><span class=\"p\">,</span>\n        <span class=\"n\">to</span><span class=\"o\">=</span><span class=\"s2\">\"remote_person@example.com\"</span><span class=\"p\">)</span>\n</pre>\n<p>Sign the message via different keyring.</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">gnupg</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/my-keyring/\"</span><span class=\"p\">)</span>\n</pre>\n<p>Sign the message with a key that needs passphrase.</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">passphrase</span><span class=\"o\">=</span><span class=\"s2\">\"my-password\"</span><span class=\"p\">)</span>\n</pre>\n<p>Sign a message without signing by default turned previously on and having a default keyring path. Every <code>envelope</code> call will honour these defaults.</p>\n<pre><span class=\"n\">envelope</span><span class=\"o\">.</span><span class=\"n\">default</span><span class=\"o\">.</span><span class=\"n\">signature</span><span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">gnupghome</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/my-keyring\"</span><span class=\"p\">)</span>\n<span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Sending</h2>\n<p>Send an e-mail via module call.</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span> <span class=\"n\">send</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Send an e-mail via CLI and default SMTP server localhost on port 25.</p>\n<pre>envelope --to <span class=\"s2\">\"user@example.org\"</span> --message <span class=\"s2\">\"Hello world\"</span> --send\n</pre>\n<p>Send while having specified the SMTP server host, port, username, password.</p>\n<pre>envelope --to <span class=\"s2\">\"user@example.org\"</span> message <span class=\"s2\">\"Hello world\"</span> --send --smtp localhost <span class=\"m\">123</span> username password \n</pre>\n<p>Send while having specified the SMTP server through a dictionary.</p>\n<pre>envelope --to <span class=\"s2\">\"user@example.org\"</span> --message <span class=\"s2\">\"Hello world\"</span> --send --smtp <span class=\"s1\">'{\"host\": \"localhost\", \"port\": \"123\"}'</span> \n</pre>\n<p>Send while having specified the SMTP server via module call.</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"o\">=</span><span class=\"s2\">\"user@example.org\"</span><span class=\"p\">,</span> <span class=\"n\">send</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">smtp</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span><span class=\"s2\">\"localhost\"</span><span class=\"p\">})</span> \n</pre>\n<h2>Attachment</h2>\n<p>You can attach a file in many different ways. Pick the one that suits you the best.</p>\n<pre><span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">attachment</span><span class=\"o\">=</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/file.txt\"</span><span class=\"p\">))</span>  <span class=\"c1\"># filename will be 'file.txt'</span>\n\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/file.txt\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">attachment</span><span class=\"o\">=</span><span class=\"n\">f</span><span class=\"p\">)</span>  <span class=\"c1\"># filename will be 'file.txt'</span>\n    \n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/file.txt\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">attachment</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"s2\">\"filename.txt\"</span><span class=\"p\">))</span>\n    \n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">attach</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/file.txt\"</span><span class=\"p\">,</span><span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s2\">\"filename.txt\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Complex example</h2>\n<p>Send an encrypted and signed message via the default SMTP server, via all three interfaces.</p>\n<pre><span class=\"c1\"># CLI interface</span>\nenvelope --message <span class=\"s2\">\"Hello world\"</span> --to <span class=\"s2\">\"user@example.org\"</span> --sender <span class=\"s2\">\"me@example.org\"</span> --subject <span class=\"s2\">\"Test\"</span> --sign --encrypt -a /tmp/file.txt -a /tmp/file2 application/gzip zipped-file.zip --send\n</pre>\n<pre><span class=\"c1\"># one-liner interface</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pathlib</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n<span class=\"n\">envelope</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">message</span><span class=\"p\">(</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s2\">\"user@example.org\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">sender</span><span class=\"p\">(</span><span class=\"s2\">\"me@example.org\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">subject</span><span class=\"p\">(</span><span class=\"s2\">\"Test\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">signature</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">encryption</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">attach</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/file.txt\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">attach</span><span class=\"p\">(</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/file2\"</span><span class=\"p\">),</span> <span class=\"s2\">\"application/gzip\"</span><span class=\"p\">,</span> <span class=\"s2\">\"zipped-file.zip\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># fluent interface</span>\n<span class=\"n\">envelope</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"s2\">\"Hello world\"</span><span class=\"p\">,</span> <span class=\"n\">to</span><span class=\"o\">=</span><span class=\"s2\">\"user@example.org\"</span><span class=\"p\">,</span> <span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"s2\">\"me@example.org\"</span><span class=\"p\">,</span> <span class=\"n\">subject</span><span class=\"o\">=</span><span class=\"s2\">\"Test\"</span><span class=\"p\">,</span> <span class=\"n\">sign</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">encrypt</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">attachments</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/file.txt\"</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/file2\"</span><span class=\"p\">),</span> <span class=\"s2\">\"application/gzip\"</span><span class=\"p\">,</span> <span class=\"s2\">\"zipped-file.zip\"</span><span class=\"p\">)],</span> <span class=\"n\">send</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>In the condition <em><a href=\"mailto:me@example.com\">me@example.com</a></em> private key for signing, <em><a href=\"mailto:user@example.com\">user@example.com</a></em> public key for encrypting and open SMTP server on <em>localhost:25</em> are available, change <code>--send</code> to <code>--send 0</code> (or <code>.send()</code> to <code>.send(False)</code> or <code>send=True</code> to <code>send=False</code>) to investigate the generated message that may be similar to the following output:</p>\n<pre>****************************************************************************************************\nHave not been sent from me@example.org to user@example.org\nEncrypted subject: Test\nEncrypted message: b<span class=\"s1\">'Hello world'</span>\n\nSubject: Encrypted message\nMIME-Version: <span class=\"m\">1</span>.0\nContent-Type: multipart/encrypted<span class=\"p\">;</span> <span class=\"nv\">protocol</span><span class=\"o\">=</span><span class=\"s2\">\"application/pgp-encrypted\"</span><span class=\"p\">;</span>\n <span class=\"nv\">boundary</span><span class=\"o\">=</span><span class=\"s2\">\"===============8462917939563016793==\"</span>\nFrom: me@example.org\nTo: user@example.org\nDate: Tue, <span class=\"m\">08</span> Oct <span class=\"m\">2019</span> <span class=\"m\">16</span>:16:18 +0200\nMessage-ID: &lt;<span class=\"m\">157054417817</span>.4405.938581433237601455@promyka&gt;\n\n--<span class=\"o\">===============</span><span class=\"nv\">8462917939563016793</span><span class=\"o\">==</span>\nContent-Type: application/pgp-encrypted\n\nVersion: <span class=\"m\">1</span>\n--<span class=\"o\">===============</span><span class=\"nv\">8462917939563016793</span><span class=\"o\">==</span>\nContent-Type: application/octet-stream<span class=\"p\">;</span> <span class=\"nv\">name</span><span class=\"o\">=</span><span class=\"s2\">\"encrypted.asc\"</span>\nContent-Description: OpenPGP encrypted message\nContent-Disposition: inline<span class=\"p\">;</span> <span class=\"nv\">filename</span><span class=\"o\">=</span><span class=\"s2\">\"encrypted.asc\"</span>\n\n-----BEGIN PGP MESSAGE-----\n\nhQMOAyx1c9zl1h4wEAv+PmtwjQDt+4XCn8YQJ6d7kyrp2R7xzS3PQwOZ7e+HWJjY\n<span class=\"o\">(</span>...<span class=\"o\">)</span>\nRQ8QtLLEza+rs+1lgcPgdBZEHFpYpgDb0AUvYg9d\n<span class=\"o\">=</span>YuqI\n-----END PGP MESSAGE-----\n\n--<span class=\"o\">===============</span><span class=\"nv\">8462917939563016793</span><span class=\"o\">==</span>--\n</pre>\n<h1>Related affairs</h1>\n<p>Sending an e-mail does not mean it will be received. Sending it successfully through your local domain does not mean a public mailbox will accept it as well. If you are not trustworthy enough, your e-mail may not even appear at the recipient's spam bin, it can just be discarded without notice.</p>\n<h2>Configure your SMTP</h2>\n<p>It is always easier if you have an account on an SMTP server the application is able to send e-mails with. If it is not the case, various SMTP server exist but as a quick and non-secure solution, I've tested <a href=\"https://hub.docker.com/r/bytemark/smtp/\" rel=\"nofollow\">bytemark/smtp</a> docker image that allows you to start up a SMTP server by a single line.</p>\n<pre>docker run --network<span class=\"o\">=</span>host --restart always -d bytemark/smtp   <span class=\"c1\"># starts open port 25 on localhost</span>\nenvelope --message <span class=\"s2\">\"SMTP test\"</span> --from <span class=\"o\">[</span>your e-mail<span class=\"o\">]</span> --to <span class=\"o\">[</span>your e-mail<span class=\"o\">]</span> --smtp localhost <span class=\"m\">25</span> --send\n</pre>\n<h2>Choose ciphering method</h2>\n<h3>Configure your GPG</h3>\n<p>In order to sign messages, you need a private key. Let's pretend a usecase when your application will run under <code>www-data</code> user and GPG sign messages through the keys located at: <code>/var/www/.gnupg</code>. You have got a SMTP server with an e-mail account the application may use.</p>\n<pre><span class=\"nv\">GNUPGHOME</span><span class=\"o\">=</span>/var/www/.gnupg sudo -H -u www-data gpg --full-generate-key  <span class=\"c1\"># put application e-mail your are able to send the e-mail from</span>\n<span class=\"c1\"># if the generation fails now because you are on a remote terminal, you may want to change temporarily the ownership of the terminal by the following command: </span>\n<span class=\"c1\"># sudo chown www-data $(tty)  # put it back afterwards</span>\n<span class=\"nv\">GNUPGHOME</span><span class=\"o\">=</span>/var/www/.gnupg sudo -H -u www-data gpg --list-secret-keys  <span class=\"c1\"># get key ID</span>\n<span class=\"nv\">GNUPGHOME</span><span class=\"o\">=</span>/var/www/.gnupg sudo -H -u www-data gpg --send-keys <span class=\"o\">[</span>key ID<span class=\"o\">]</span>  <span class=\"c1\"># now the world is able to pull the key from a global webserver when they receive an e-mail from you</span>\n<span class=\"nv\">GNUPGHOME</span><span class=\"o\">=</span>/var/www/.gnupg sudo -H -u www-data envelope --message <span class=\"s2\">\"Hello world\"</span> --subject <span class=\"s2\">\"GPG signing test\"</span> --sign <span class=\"o\">[</span>key ID<span class=\"o\">]</span> --from <span class=\"o\">[</span>application e-mail<span class=\"o\">]</span> --to <span class=\"o\">[</span>your e-mail<span class=\"o\">]</span> --send  <span class=\"c1\"># you now receive e-mail and may import the key and set the trust to the key</span>\n</pre>\n<p>It takes few hours to a key to propagate. If the key cannot be imported in your e-mail client because not found on the servers, try in the morning again or check the online search form at <a href=\"http://hkps.pool.sks-keyservers.net\" rel=\"nofollow\">http://hkps.pool.sks-keyservers.net</a>.<br>\nPut your fingerprint on the web or on the business card then so that everybody can check your signature is valid.</p>\n<h3>Configure your S/MIME</h3>\n<p>If you are supposed to use S/MIME, you would probably be told where to take your key and certificate from. If planning to try it all by yourself, generate your <code>certificate.pem</code>.</p>\n<ul>\n<li>Either: Do you have private key?</li>\n</ul>\n<pre>openssl req -key YOUR-KEY.pem -nodes -x509 -days <span class=\"m\">365</span> -out certificate.pem  <span class=\"c1\"># will generate privkey.pem alongside</span>\n</pre>\n<ul>\n<li>Or: Do not you have private key?</li>\n</ul>\n<pre>openssl req -newkey rsa:1024 -nodes -x509 -days <span class=\"m\">365</span> -out certificate.pem  <span class=\"c1\"># will generate privkey.pem alongside</span>\n</pre>\n<p>Now, you may sign a message with your key and certificate. (However, the messages <strong>will not be trustworthy</strong> because no authority signed the certificate.) Give your friend the certificate so that they might verify the message comes from you. Receive a certificate from a friend to encrypt them a message with.</p>\n<pre><code>envelope --message \"Hello world\" --subject \"S/MIME signing test\" --sign-path [key file] --cert-path [certificate file] --from [application e-mail] --to [your e-mail] --send # you now receive e-mail\n</code></pre>\n<h2>DNS validation tools</h2>\n<p>This is just a short explanation on these anti-spam mechanisms so that you can take basic notion what is going on.</p>\n<p>Every time, the receiver should ask the sender's domain these questions over DNS.</p>\n<h3>SPF</h3>\n<p>The receiver asks the sender's domain: Do you allow the senders IP/domain to send the e-mail on your behalf?</p>\n<p>Check your domain on SPF:</p>\n<pre>dig -t TXT example.com\n</pre>\n<h3>DKIM</h3>\n<p>The receiver asks the sender's domain: Give me the public key so that I may check the hash in the e-mail header that assert the message was composed by your private key. So that the e-mail comes trustworthy from you and nobody modified it on the way.</p>\n<p>Check your domain on DKIM:</p>\n<pre>dig -t TXT <span class=\"o\">[</span>selector<span class=\"o\">]</span>._domainkey.example.com\n</pre>\n<p>You can obtain the <code>selector</code> from an e-mail message you received. Check the line <code>DKIM-Signature</code> and the value of the param <code>s</code>.</p>\n<pre><code>DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=example.com; s=default;\n</code></pre>\n<h2>DMARC</h2>\n<p>What is your policy concerning SPF and DKIM? What abuse address do you have?</p>\n<p>Check your domain on DMARC:</p>\n<pre>dig -t TXT _dmarc.example.com\n</pre>\n\n          </div>"}, "last_serial": 6604395, "releases": {"0.9.1": [{"comment_text": "", "digests": {"md5": "64db16f61bad8312afc2b16dbce122e0", "sha256": "26f56de14602eb499274207a8452b197f16bcfeeefa937ee7200f964c68b6cd8"}, "downloads": -1, "filename": "envelope-0.9.1.tar.gz", "has_sig": false, "md5_digest": "64db16f61bad8312afc2b16dbce122e0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 21718, "upload_time": "2019-10-02T18:21:09", "upload_time_iso_8601": "2019-10-02T18:21:09.587075Z", "url": "https://files.pythonhosted.org/packages/91/64/73c64971a8634b581c201c131a96e5e2249ab4c5e5337aa1cd41b2d33aa3/envelope-0.9.1.tar.gz", "yanked": false}], "0.9.2": [{"comment_text": "", "digests": {"md5": "2ac3128124bb130d5a72c992c161c8bb", "sha256": "27e96b6eb748b5da2cfe30343f419a893a415933ae28df90339a03fcf3e708ac"}, "downloads": -1, "filename": "envelope-0.9.2.tar.gz", "has_sig": false, "md5_digest": "2ac3128124bb130d5a72c992c161c8bb", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 28611, "upload_time": "2019-10-07T14:22:13", "upload_time_iso_8601": "2019-10-07T14:22:13.984532Z", "url": "https://files.pythonhosted.org/packages/19/81/2acb5cd58ec9b818ec3d55d87a3ac5e62794555edf0b7cd940be88905186/envelope-0.9.2.tar.gz", "yanked": false}], "0.9.3": [{"comment_text": "", "digests": {"md5": "6a26cbf1b690be7ab1b26b79e9fa8a42", "sha256": "ded1881d0892c7fee80a6433a7194652e397bd0d296f4fe429886fca6e74843f"}, "downloads": -1, "filename": "envelope-0.9.3.tar.gz", "has_sig": false, "md5_digest": "6a26cbf1b690be7ab1b26b79e9fa8a42", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30046, "upload_time": "2019-11-29T23:11:07", "upload_time_iso_8601": "2019-11-29T23:11:07.704846Z", "url": "https://files.pythonhosted.org/packages/22/b3/873d30519b19d5df4a2e9224ce43b009344ec0d1d14c5faf677917168979/envelope-0.9.3.tar.gz", "yanked": false}], "0.9.4": [{"comment_text": "", "digests": {"md5": "2786902bf1e8a2c3a41e48e2472f6391", "sha256": "2918fc8294982cff7993d16c21a976e4fdd3e704a56221b5faccefb9cb5cdf4b"}, "downloads": -1, "filename": "envelope-0.9.4.tar.gz", "has_sig": false, "md5_digest": "2786902bf1e8a2c3a41e48e2472f6391", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30063, "upload_time": "2019-12-03T16:46:42", "upload_time_iso_8601": "2019-12-03T16:46:42.769521Z", "url": "https://files.pythonhosted.org/packages/20/59/1a47bc023888d7ae9234aeb36e732fb44ed75b5b8b45a797bcca37ddb4c8/envelope-0.9.4.tar.gz", "yanked": false}], "0.9.5": [{"comment_text": "", "digests": {"md5": "59705c6c6ec5dac2a4f431587878174e", "sha256": "6fae8b9f166877a9fb9213efb901d820e2e9c69622b44a68cdda5ecab7115f04"}, "downloads": -1, "filename": "envelope-0.9.5.tar.gz", "has_sig": false, "md5_digest": "59705c6c6ec5dac2a4f431587878174e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 34645, "upload_time": "2019-12-12T18:32:21", "upload_time_iso_8601": "2019-12-12T18:32:21.677469Z", "url": "https://files.pythonhosted.org/packages/1e/97/811aa8164d43d597cb7bde258d6e1ee70895d5f350487b3ac3d1cac53613/envelope-0.9.5.tar.gz", "yanked": false}], "0.9.6": [{"comment_text": "", "digests": {"md5": "2ca76c997e7bfd6b947a9003d54d97a5", "sha256": "5eedf251150e57c912f17473a47780ce75eaecea84fd5d5d5d84678e919daa25"}, "downloads": -1, "filename": "envelope-0.9.6.tar.gz", "has_sig": false, "md5_digest": "2ca76c997e7bfd6b947a9003d54d97a5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 34771, "upload_time": "2020-01-14T20:47:41", "upload_time_iso_8601": "2020-01-14T20:47:41.568518Z", "url": "https://files.pythonhosted.org/packages/34/b0/de451416c42e73fc7f739e03d0e1d637737f1abdcf392ce8a354a1217582/envelope-0.9.6.tar.gz", "yanked": false}], "0.9.7": [{"comment_text": "", "digests": {"md5": "0e0dcae1de79f18b22356d743920b353", "sha256": "bca5f4a450277ff6cb6dbbf456f9f8a55ad7e444da279016946bd159023b142f"}, "downloads": -1, "filename": "envelope-0.9.7.tar.gz", "has_sig": false, "md5_digest": "0e0dcae1de79f18b22356d743920b353", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 37642, "upload_time": "2020-01-17T00:53:40", "upload_time_iso_8601": "2020-01-17T00:53:40.338858Z", "url": "https://files.pythonhosted.org/packages/9c/a9/67c005f1d23d4689259d6cb083f51b58225df5ee4783f2407017273c0174/envelope-0.9.7.tar.gz", "yanked": false}], "0.9.8": [{"comment_text": "", "digests": {"md5": "4ee81e7ebb3cbf620e88dfc45db73eed", "sha256": "0af93adf30fb7c57ae85f7b99d301a3e7febef2244eb63204f03927e6c846c90"}, "downloads": -1, "filename": "envelope-0.9.8.tar.gz", "has_sig": false, "md5_digest": "4ee81e7ebb3cbf620e88dfc45db73eed", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40615, "upload_time": "2020-01-27T22:23:27", "upload_time_iso_8601": "2020-01-27T22:23:27.120722Z", "url": "https://files.pythonhosted.org/packages/04/f1/f950cbce0fc6d703bd9b9f4b0688d509c52fcf034f73cbe16a53be66b8fc/envelope-0.9.8.tar.gz", "yanked": false}], "0.9.9": [{"comment_text": "", "digests": {"md5": "ff1453a200697c8d7b4d2bab1bf6f906", "sha256": "a3db86660fa121ab2f31b443aaa7d753f7b4ee34a12c420c122f86f73aa87ff5"}, "downloads": -1, "filename": "envelope-0.9.9.tar.gz", "has_sig": false, "md5_digest": "ff1453a200697c8d7b4d2bab1bf6f906", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40606, "upload_time": "2020-02-10T18:58:48", "upload_time_iso_8601": "2020-02-10T18:58:48.670690Z", "url": "https://files.pythonhosted.org/packages/8f/cb/405a99221f6df352e2b50cdfa8a7f2659519e6d6ab6d4dbcfef82e73856d/envelope-0.9.9.tar.gz", "yanked": false}], "0.9.9rc1": [{"comment_text": "", "digests": {"md5": "48b8b1ac44546d04c9e9dbe10590ab01", "sha256": "154aaee4fc4bb36584634e95947f33d2c6b1f4b95b092eb35dfa2f97b587a34d"}, "downloads": -1, "filename": "envelope-0.9.9rc1.tar.gz", "has_sig": false, "md5_digest": "48b8b1ac44546d04c9e9dbe10590ab01", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40525, "upload_time": "2020-02-10T17:16:16", "upload_time_iso_8601": "2020-02-10T17:16:16.579234Z", "url": "https://files.pythonhosted.org/packages/24/b7/2f6ff99849ae201f00f6730d9792e8d30502f986eb483797780ba65142ab/envelope-0.9.9rc1.tar.gz", "yanked": false}], "0.9.9rc2": [{"comment_text": "", "digests": {"md5": "75f0e1bbd616e32d047b7e9b7106329f", "sha256": "73f159e83840e8e33f7a8f7d789081ddf0d8f0af7a10fa3a3b04961be94cc040"}, "downloads": -1, "filename": "envelope-0.9.9rc2.tar.gz", "has_sig": false, "md5_digest": "75f0e1bbd616e32d047b7e9b7106329f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40654, "upload_time": "2020-02-10T18:41:55", "upload_time_iso_8601": "2020-02-10T18:41:55.769498Z", "url": "https://files.pythonhosted.org/packages/9b/44/49586327e90b0363537bac7e4e93af671a714ec718b465242afd5dd9e4c3/envelope-0.9.9rc2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ff1453a200697c8d7b4d2bab1bf6f906", "sha256": "a3db86660fa121ab2f31b443aaa7d753f7b4ee34a12c420c122f86f73aa87ff5"}, "downloads": -1, "filename": "envelope-0.9.9.tar.gz", "has_sig": false, "md5_digest": "ff1453a200697c8d7b4d2bab1bf6f906", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40606, "upload_time": "2020-02-10T18:58:48", "upload_time_iso_8601": "2020-02-10T18:58:48.670690Z", "url": "https://files.pythonhosted.org/packages/8f/cb/405a99221f6df352e2b50cdfa8a7f2659519e6d6ab6d4dbcfef82e73856d/envelope-0.9.9.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:10 2020"}