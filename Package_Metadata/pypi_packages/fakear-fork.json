{"info": {"author": "Franck LOURME", "author_email": "flourme@scaleway.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Software Development :: Testing"], "description": "# Fakear\n\nA module that creates fake binaries from valid configuration ( a yaml file or a dict ) and launch them in the context of your Python script, without efforts.\n\n# Installation\n\n```\npip install fakear\n```\n\n# Quick Start\n\nThis is a mock of a fake `ls` command, that \n\n```yaml\nls:\n  - args:\n      - dexter\n    return_code: 0\n    output: Omelette du Fromage\n```\n\nOn Python, you can now use Fakear to fake ls behaviour and act according to our mock.\n\n```python\n>>> from subprocess import run\n>>> from fakear import Fakear\n>>> p = run([\"ls\", \"dexter\"])\nls: dexter: No such file or directory\n>>> p.returncode\n1\n>>> with Fakear(cfg=\"fake_ls.yaml\"):\n...   fake_cmd = run([\"ls\", \"dexter\"])\nOmelette du Fromage\n>>> fake_cmd.returncode\n0\n```\n\nYou can use it as well in your unit test routine:\n\n```python\nfrom fakear import Fakear\nfrom subprocess import check_output\n\ndef test_faked_ls(self):\n    with Fakear(cfg=\"fake_ls.yaml\"):\n        proc = check_output([\"ls\", \"dexter\"])\n\n    assert proc.decode() == \"Omelette du fromage\\n\"\n```\n\n# How does it works ?\n\nAn instance handles a specific configuration file, with scenarios for one or\nmultiple commands to fake.\n\nBy default, an instance is deactivated, meaning you can still configure it\nbefore the fake happens\n\nWhen activated:\n - The instance creates the folder that should contains the fake binaries (faked_path)\n - It builds shell scripts corresponding to all the scenarios\n - It ensures every scripts are runnable\n - It sets in os.environ[\"PATH\"] the faked_path at first place\n\nSo, as long as the instance is activated, you can run faked commands with subprocess module.\n\nWhen deactivated, the instance removes the faked_path from PATH and deletes the folder from the filesystem\n\n\n# Documentation\n\n## YAML Files\n\nEvery program mock should start with the program name as a key. Then you can describe multiple behaviours for a given set of arguments.\n\n```yaml\n__command_name__ :\n  # Default output with no arguments\n  - return_code: -1\n    output: This is a fake program, please give the correct arguments\n  # output with arguments\n  - args:\n    - first_arg\n    - sec_arg\n    return_code: 0\n    output: This is an example of fake command\n  # output_file with arguments\n  - args:\n    - first_arg\n    - sec_arg\n    return_code: 0\n    output_file: semver.txt\n__command2_name__ :\n  # Default behaviour of a program generated by Fakear\n```\n\nYou can use those options to customise your fake program:\n\n  - **args (Optionna\u0326l)** : a list of positionnal arguments that invoke this fake output\n  - **return_code** : the return code when the program exits\n  - **output**: The raw data to output when you invoke the program with these args\n  - **output_file**: The path of a file containing the output to show\n\nNotice that if you mention no args to your list in a subcommand, it overrides the default behaviour of your fake program.\n\nAlso, you have to set either **output** or **output_file** keys in the same subcommand.\nOtherwise, it should throw an error.\n\n\n## API\n\nYou can use Fakear in two ways:\n\n- as an instance:\n```py\n>>> fakear = Fakear(cfg=\"path_of_a_valid.yml\")\n>>> fakear.enable()\n# DO THINGS\n>>> fakear.disable()\n```\nA Fakear instance can be manually enabled or disabled with the correct methods\n\n- as a Context Manager (recommended):\n\n```python\nwith Fakear(cfg=\"fake_ls.yml\"):\n    # DO THINGS\n```\nWith the context manager, enable et disable are handled automatically, and you can set the fake path at instanciation\n\n### Init variables\n```py\nFakear(cfg=\"/path/cfg.yaml\", raw=cfg_data, path=\"/tmp/bin\")\n```\n\n- cfg: Path of the config file to use\n- raw: Python dict\n- path: Path for fake binaries\n\nYou can use either cfg or raw but not both of them, as it should overlap scenarios of the same command and create undefined behaviour.\n\n### Available Methods\n\n- enable() : Activate the instance\n- deactivate() : Deactivate the instance\n- set_path(path: str) : Sets a new path for faked commands. It must be absolute. You can't modify path when the instance is activated\n\n\n# Contribute\n\nFeel free to open an issue on this repository.\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "fakear-fork", "package_url": "https://pypi.org/project/fakear-fork/", "platform": "", "project_url": "https://pypi.org/project/fakear-fork/", "project_urls": null, "release_url": "https://pypi.org/project/fakear-fork/0.1.3.dev1/", "requires_dist": ["pyyaml", "voluptuous"], "requires_python": "", "summary": "A Shell-command faker for Python Unit Testing", "version": "0.1.3.dev1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Fakear</h1>\n<p>A module that creates fake binaries from valid configuration ( a yaml file or a dict ) and launch them in the context of your Python script, without efforts.</p>\n<h1>Installation</h1>\n<pre><code>pip install fakear\n</code></pre>\n<h1>Quick Start</h1>\n<p>This is a mock of a fake <code>ls</code> command, that</p>\n<pre><span class=\"nt\">ls</span><span class=\"p\">:</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">args</span><span class=\"p\">:</span>\n      <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">dexter</span>\n    <span class=\"nt\">return_code</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">0</span>\n    <span class=\"nt\">output</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">Omelette du Fromage</span>\n</pre>\n<p>On Python, you can now use Fakear to fake ls behaviour and act according to our mock.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">subprocess</span> <span class=\"kn\">import</span> <span class=\"n\">run</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">fakear</span> <span class=\"kn\">import</span> <span class=\"n\">Fakear</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">run</span><span class=\"p\">([</span><span class=\"s2\">\"ls\"</span><span class=\"p\">,</span> <span class=\"s2\">\"dexter\"</span><span class=\"p\">])</span>\n<span class=\"n\">ls</span><span class=\"p\">:</span> <span class=\"n\">dexter</span><span class=\"p\">:</span> <span class=\"n\">No</span> <span class=\"n\">such</span> <span class=\"n\">file</span> <span class=\"ow\">or</span> <span class=\"n\">directory</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">returncode</span>\n<span class=\"mi\">1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">with</span> <span class=\"n\">Fakear</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"o\">=</span><span class=\"s2\">\"fake_ls.yaml\"</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>   <span class=\"n\">fake_cmd</span> <span class=\"o\">=</span> <span class=\"n\">run</span><span class=\"p\">([</span><span class=\"s2\">\"ls\"</span><span class=\"p\">,</span> <span class=\"s2\">\"dexter\"</span><span class=\"p\">])</span>\n<span class=\"n\">Omelette</span> <span class=\"n\">du</span> <span class=\"n\">Fromage</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">fake_cmd</span><span class=\"o\">.</span><span class=\"n\">returncode</span>\n<span class=\"mi\">0</span>\n</pre>\n<p>You can use it as well in your unit test routine:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">fakear</span> <span class=\"kn\">import</span> <span class=\"n\">Fakear</span>\n<span class=\"kn\">from</span> <span class=\"nn\">subprocess</span> <span class=\"kn\">import</span> <span class=\"n\">check_output</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_faked_ls</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">Fakear</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"o\">=</span><span class=\"s2\">\"fake_ls.yaml\"</span><span class=\"p\">):</span>\n        <span class=\"n\">proc</span> <span class=\"o\">=</span> <span class=\"n\">check_output</span><span class=\"p\">([</span><span class=\"s2\">\"ls\"</span><span class=\"p\">,</span> <span class=\"s2\">\"dexter\"</span><span class=\"p\">])</span>\n\n    <span class=\"k\">assert</span> <span class=\"n\">proc</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"s2\">\"Omelette du fromage</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n</pre>\n<h1>How does it works ?</h1>\n<p>An instance handles a specific configuration file, with scenarios for one or\nmultiple commands to fake.</p>\n<p>By default, an instance is deactivated, meaning you can still configure it\nbefore the fake happens</p>\n<p>When activated:</p>\n<ul>\n<li>The instance creates the folder that should contains the fake binaries (faked_path)</li>\n<li>It builds shell scripts corresponding to all the scenarios</li>\n<li>It ensures every scripts are runnable</li>\n<li>It sets in os.environ[\"PATH\"] the faked_path at first place</li>\n</ul>\n<p>So, as long as the instance is activated, you can run faked commands with subprocess module.</p>\n<p>When deactivated, the instance removes the faked_path from PATH and deletes the folder from the filesystem</p>\n<h1>Documentation</h1>\n<h2>YAML Files</h2>\n<p>Every program mock should start with the program name as a key. Then you can describe multiple behaviours for a given set of arguments.</p>\n<pre><span class=\"nt\">__command_name__ </span><span class=\"p\">:</span>\n  <span class=\"c1\"># Default output with no arguments</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">return_code</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">-1</span>\n    <span class=\"nt\">output</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">This is a fake program, please give the correct arguments</span>\n  <span class=\"c1\"># output with arguments</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">args</span><span class=\"p\">:</span>\n    <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">first_arg</span>\n    <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">sec_arg</span>\n    <span class=\"nt\">return_code</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">0</span>\n    <span class=\"nt\">output</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">This is an example of fake command</span>\n  <span class=\"c1\"># output_file with arguments</span>\n  <span class=\"p p-Indicator\">-</span> <span class=\"nt\">args</span><span class=\"p\">:</span>\n    <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">first_arg</span>\n    <span class=\"p p-Indicator\">-</span> <span class=\"l l-Scalar l-Scalar-Plain\">sec_arg</span>\n    <span class=\"nt\">return_code</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">0</span>\n    <span class=\"nt\">output_file</span><span class=\"p\">:</span> <span class=\"l l-Scalar l-Scalar-Plain\">semver.txt</span>\n<span class=\"nt\">__command2_name__ </span><span class=\"p\">:</span>\n  <span class=\"c1\"># Default behaviour of a program generated by Fakear</span>\n</pre>\n<p>You can use those options to customise your fake program:</p>\n<ul>\n<li><strong>args (Optionna\u0326l)</strong> : a list of positionnal arguments that invoke this fake output</li>\n<li><strong>return_code</strong> : the return code when the program exits</li>\n<li><strong>output</strong>: The raw data to output when you invoke the program with these args</li>\n<li><strong>output_file</strong>: The path of a file containing the output to show</li>\n</ul>\n<p>Notice that if you mention no args to your list in a subcommand, it overrides the default behaviour of your fake program.</p>\n<p>Also, you have to set either <strong>output</strong> or <strong>output_file</strong> keys in the same subcommand.\nOtherwise, it should throw an error.</p>\n<h2>API</h2>\n<p>You can use Fakear in two ways:</p>\n<ul>\n<li>as an instance:</li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">fakear</span> <span class=\"o\">=</span> <span class=\"n\">Fakear</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"o\">=</span><span class=\"s2\">\"path_of_a_valid.yml\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">fakear</span><span class=\"o\">.</span><span class=\"n\">enable</span><span class=\"p\">()</span>\n<span class=\"c1\"># DO THINGS</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">fakear</span><span class=\"o\">.</span><span class=\"n\">disable</span><span class=\"p\">()</span>\n</pre>\n<p>A Fakear instance can be manually enabled or disabled with the correct methods</p>\n<ul>\n<li>as a Context Manager (recommended):</li>\n</ul>\n<pre><span class=\"k\">with</span> <span class=\"n\">Fakear</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"o\">=</span><span class=\"s2\">\"fake_ls.yml\"</span><span class=\"p\">):</span>\n    <span class=\"c1\"># DO THINGS</span>\n</pre>\n<p>With the context manager, enable et disable are handled automatically, and you can set the fake path at instanciation</p>\n<h3>Init variables</h3>\n<pre><span class=\"n\">Fakear</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"o\">=</span><span class=\"s2\">\"/path/cfg.yaml\"</span><span class=\"p\">,</span> <span class=\"n\">raw</span><span class=\"o\">=</span><span class=\"n\">cfg_data</span><span class=\"p\">,</span> <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s2\">\"/tmp/bin\"</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li>cfg: Path of the config file to use</li>\n<li>raw: Python dict</li>\n<li>path: Path for fake binaries</li>\n</ul>\n<p>You can use either cfg or raw but not both of them, as it should overlap scenarios of the same command and create undefined behaviour.</p>\n<h3>Available Methods</h3>\n<ul>\n<li>enable() : Activate the instance</li>\n<li>deactivate() : Deactivate the instance</li>\n<li>set_path(path: str) : Sets a new path for faked commands. It must be absolute. You can't modify path when the instance is activated</li>\n</ul>\n<h1>Contribute</h1>\n<p>Feel free to open an issue on this repository.</p>\n\n          </div>"}, "last_serial": 6068039, "releases": {"0.1.3.dev1": [{"comment_text": "", "digests": {"md5": "15bc35199b18a05775ae5330e7d39d38", "sha256": "a8ddd0a56622e25d7ccff2c47693bb8c016e19144eb95ddf950eb6d92337cc62"}, "downloads": -1, "filename": "fakear_fork-0.1.3.dev1-py3-none-any.whl", "has_sig": false, "md5_digest": "15bc35199b18a05775ae5330e7d39d38", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9791, "upload_time": "2019-11-02T12:58:51", "upload_time_iso_8601": "2019-11-02T12:58:51.955959Z", "url": "https://files.pythonhosted.org/packages/40/9c/c39217571fe36cecd3e60f150b56450437b1a0f3f5af04ce79fd91283a5e/fakear_fork-0.1.3.dev1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3c6ebbe4c9858b860d79673c5090417e", "sha256": "eb10595c03f106855793f24e43eb95f33dab15ae4e37fbf5274b2ad977f7762f"}, "downloads": -1, "filename": "fakear-fork-0.1.3.dev1.tar.gz", "has_sig": false, "md5_digest": "3c6ebbe4c9858b860d79673c5090417e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7149, "upload_time": "2019-11-02T12:58:54", "upload_time_iso_8601": "2019-11-02T12:58:54.080883Z", "url": "https://files.pythonhosted.org/packages/58/c0/7ce9c6e7a5da6f9d670213bf9fcf1af062bda79084c9c9cfde06cd2e7ba0/fakear-fork-0.1.3.dev1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "15bc35199b18a05775ae5330e7d39d38", "sha256": "a8ddd0a56622e25d7ccff2c47693bb8c016e19144eb95ddf950eb6d92337cc62"}, "downloads": -1, "filename": "fakear_fork-0.1.3.dev1-py3-none-any.whl", "has_sig": false, "md5_digest": "15bc35199b18a05775ae5330e7d39d38", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9791, "upload_time": "2019-11-02T12:58:51", "upload_time_iso_8601": "2019-11-02T12:58:51.955959Z", "url": "https://files.pythonhosted.org/packages/40/9c/c39217571fe36cecd3e60f150b56450437b1a0f3f5af04ce79fd91283a5e/fakear_fork-0.1.3.dev1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3c6ebbe4c9858b860d79673c5090417e", "sha256": "eb10595c03f106855793f24e43eb95f33dab15ae4e37fbf5274b2ad977f7762f"}, "downloads": -1, "filename": "fakear-fork-0.1.3.dev1.tar.gz", "has_sig": false, "md5_digest": "3c6ebbe4c9858b860d79673c5090417e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7149, "upload_time": "2019-11-02T12:58:54", "upload_time_iso_8601": "2019-11-02T12:58:54.080883Z", "url": "https://files.pythonhosted.org/packages/58/c0/7ce9c6e7a5da6f9d670213bf9fcf1af062bda79084c9c9cfde06cd2e7ba0/fakear-fork-0.1.3.dev1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:43:57 2020"}