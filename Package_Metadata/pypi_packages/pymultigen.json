{"info": {"author": "Mike Pagel", "author_email": "mike@mpagel.de", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3 :: Only", "Topic :: Software Development", "Topic :: Software Development :: Libraries"], "description": "pymultigen - Multi-file frontend for single-file code generators\n================================================================\n\n.. image:: https://travis-ci.org/moltob/pymultigen.svg?branch=master\n    :target: https://travis-ci.org/moltob/pymultigen\n\n.. image:: https://badge.fury.io/py/pymultigen.svg\n    :target: https://badge.fury.io/py/pymultigen\n\n.. image:: https://coveralls.io/repos/github/moltob/pymultigen/badge.svg?branch=master\n    :target: https://coveralls.io/github/moltob/pymultigen?branch=master\n\n.. image:: https://img.shields.io/badge/License-MIT-yellow.svg\n    :target: https://opensource.org/licenses/MIT\n\n.. image:: https://img.shields.io/badge/contributions-welcome-brightgreen.svg\n\nThis small library adds multi-file management on top of one or more existing single-file code\ngenerators.\n\n.. contents:: :depth: 2\n\nWhy would I need pymultigen?\n----------------------------\n\nCode generators like `Mako <http://www.makotemplates.org/>`_ or `Jinja <http://jinja.pocoo.org/>`_\nare great and can be used to generate just about any kind of textual output from templates with a\nnice template language. They are very mature and battle-proven. However, most of those generators\nhave their origin in the web application domain. The typical usecase is to dynamically render a\nsingle HTTP response (most of the time an HTML page) from one or more templates. *One* HTML page.\n\nIf you want to use these generators in other scenarious, e.g. to generate code or reports, but not\nto *one* but to *multiple* files in different folders, pymultigen can help. It simply adds an easy\nto configure file and folder management layer on top of one or more existing code generators.\n\nInstallation\n------------\n\npymultigen comes in form or a regular Python distribution and can be installed from Github or PyPI\nwith a simple:\n\n.. code-block:: shell\n\n    $ pip install pymultigen\n\nThe library works with any version of Python >= 3.3.\n\nUsage\n-----\n\nThe overall concept of pymultigen is simple:\n\n* A ``Generator`` class controls the overall generation workflow. The most important method it\n  implements is ``generate(model, folder)``. This is the single method called by *users* of the\n  created multi-file generator.\n* The ``Generator`` has a static list of ``Task`` objects. Each ``Task`` describes a step executed\n  at generation time.\n* One ``Task`` is responsible for translating a specific set of elements in the input model to one\n  output file in the output folder. The input set can be chosen arbitrarily, often this is the list\n  of a certain model element type (e.g. instance of a ``Table`` class in a relational model from\n  which SQL statements should be generated).\n\nUsing pymultigen means therefore to create one ``Generator`` class for your new generator and one or\nmore ``Task`` classes, one for each type of output artifact. If you are using a template-based code\ngenerator under the hood, you usually will have one ``Task`` per output template.\n\nBefore you start, you need to check, whether pymultigen already has an integration for your\nsingle-file code generator built-in. Currently, the following integrations are available:\n\n* Jinja2\n\nIf you want to use another generation engine, you can easily add support yourself (the current\nJinja2 integration consists of less than 20 lines of code). If you've done so, please consider\ngiving back to the community. Your contribution is welcome! Please see below for instructions how to\nextend pymultigen with a new integration.\n\nUsing the Jinja2 integration\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou may want to check out `pyecoregen <https://github.com/pyecore/pyecoregen>`_, a code generator\nfrom `pyecore <https://github.com/pyecore/pyecore>`_-based models to Python classes. It is a\nconcrete Jinja2-based code generator built with pymultigen.\n\nJinja2 is a template-based text generator. Writing a file-generator with Jinja therefore involves\nwriting a template for each type of output file. In pymultigen you will then implement a ``Task``\nclass per output file type, i.e. per Jinja template.\n\nThe general form of such a ``Task`` looks like this:\n\n.. code-block:: python\n\n    class MyTask(multigen.jinja.JinjaTask):\n\n        # Name of template file used by this task.\n        template_name = 'name-of-template.tpl'\n\n        def filtered_elements(self, model):\n            \"\"\"Return iterator based over elements in model that are passed to template.\"\"\"\n\n        def relative_path_for_element(self, element):\n            \"\"\"Returns relative file path receiving the generator output for given element.\"\"\"\n\nThe workflow engine will initially call ``filtered_elements``. This method is expected to return an\ninterator over model elements for which a single file needs to be generated. *Model* is meant here\nin an abstract way: It may be an instance of a formal metamodel, but it could be any Python object,\nlike a dictionaries or lists. The contained elements being iterated over are accessible from within\na template as ``element``.\n\nOnce Jinja has produced a textual result it must be written to file. This is where\n``relative_path_for_element`` comes into play. For a given element that was filtered from the model\nbefore, it returns the corresponding filepath. Note that this path is interpreted to be relative to\nthe top-level output path of the overall generation (see below). If subfolders are mentioned here,\nthey are created on demand.\n\nOne of more tasks classes like this must then be registered with a top-level generator. Just like\nbefore, a new ``Generator`` class is derived from the appropriate base class:\n\n.. code-block:: python\n\n    class MyGenerator(multigen.jinja.JinjaGenerator):\n\n        # List of task objects to be processed by this generator.\n        tasks = [\n            MyTask(),\n        ]\n\n        # Root path where Jinja templates are found.\n        templates_path = os.path.join(\n            os.path.abspath(os.path.dirname(__file__)),\n            'templates'\n        )\n\n        def create_environment(self, **kwargs):\n            \"\"\"Create Jinja2 environment.\"\"\"\n            environment = super().create_environment(**kwargs)\n            # Do any customization of environment here, or delete this method.\n            return environment\n\nThe base class implementation of {{create_environment}} passes {{templates_path}} to the created\nenvironment object to allow Jinja to find the template names specified in a ``Tasks``'s\n``template_name``. By overriding this method you can extend the environment, e.g. to add filters and\ntests. Of course you can also completely replace the implementation, e.g. to change the way how\ntemplates how looked up.\n\nThe example above simply instantiates the new ``Task`` class. Here you can optionally pass a\nformatter function, that is then applied to the output of Jinja. Formatters are simple string\ntransformations, some of which are built-in in the ``formatters.py`` module. If you actually are\nwriting a Python code generator you may want to clean up the generated code according to pep8,\nsimply pass the appropriate formatter during task instantiation:\n\n.. code-block:: python\n\n    class MyGeneratorWithPep8(multigen.jinja.JinjaGenerator):\n\n        # List of task objects to be processed by this generator.\n        tasks = [\n            MyTask(formatter=multigen.formatter.format_autopep8),\n        ]\n\n        ...\n\nExtending pymultigen\n--------------------\n\nContributions welcome!\n\nBelow the most typical extension scenarios are described. Note that in theory pymultigen can be used\nwith *any* code that produces text, not just a templating engine. Take a look at the class hierarchy\nin ``generator.py`` to get more insights or drop me a note if this is something you plan to do.\n\nFormatters\n~~~~~~~~~~\n\nWriting a new formatter is trivial: Simply create a function that transforms an input string into\nthe nicely formatted output string. If you want to get your formatter added to pymultigen, please\nmake sure that:\n\n* New dependencies (like autopep8 in the existing pep8 formatter) are only imported in the\n  formatting function. This way user only pay for what they use.\n* Please write unittests and add your possible dependencies to the ``tests_require`` argument in\n  ``setup.py``.\n\nThere is not much more to it.\n\nTemplating engine\n~~~~~~~~~~~~~~~~~\n\nFor a live sample, look at the Jinja2 integration in ``jinja.py``. For your templating engine ``X``,\nyou probably have to write small ``Generator`` and ``Task`` base classes like this:\n\n.. code-block:: python\n\n    class XGenerator(TemplateGenerator):\n\n        def __init__(self, environment=None, **kwargs):\n            super().__init__(**kwargs)\n            # Add any attributes to the generator that are static with respect to a full generation\n            # run (over all files), like a Jinja2 environment.\n            ...\n\n\n    class XTask(TemplateFileTask):\n\n        def generate_file(self, element, filepath):\n            \"\"\"Actual generation of element.\"\"\"\n\nEach element that is iterated over from the input model is eventually passed to the tasks's\n``generate_file`` method. Here simply call you template engine to produce the output string. You\nalso want to apply the optional formatter before writing the string to disk. This is how the Jinja\ntask does it:\n\n.. code-block:: python\n\n    def generate_file(self, element, filepath):\n        template = self.environment.get_template(self.template_name)\n        context = self.create_template_context(element=element)\n\n        with open(filepath, 'wt') as file:\n            file.write(self.formatter(template.render(**context)))\n\nThe implementation shows two more things:\n\n* The template to be used is retrieved from an ``environment`` that is specific to the template\n  engine. Such an environment is usually passed down from the ``Generator`` class to the ``Task``.\n* ``create_template_context`` is a function implemented in base class ``TemplateTask``. It\n  implements the very common case of dictionaries being used as template context objects. Of course\n  you can override this if it doesn't match your engine.\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/moltob/pymultigen", "keywords": "code generator jinja multi-file", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "pymultigen", "package_url": "https://pypi.org/project/pymultigen/", "platform": "", "project_url": "https://pypi.org/project/pymultigen/", "project_urls": {"Homepage": "https://github.com/moltob/pymultigen"}, "release_url": "https://pypi.org/project/pymultigen/0.2.0/", "requires_dist": null, "requires_python": "", "summary": "Multi-file frontend for single-file code generators.", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/moltob/pymultigen\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/moltob/pymultigen.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/db827b443286d500d13f4ca63496cae607efc763/68747470733a2f2f7472617669732d63692e6f72672f6d6f6c746f622f70796d756c746967656e2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://badge.fury.io/py/pymultigen\" rel=\"nofollow\"><img alt=\"https://badge.fury.io/py/pymultigen.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2de812ddbc6af476cdaf113851ee33364f8e2d53/68747470733a2f2f62616467652e667572792e696f2f70792f70796d756c746967656e2e737667\"></a>\n<a href=\"https://coveralls.io/github/moltob/pymultigen?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/moltob/pymultigen/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4b7f506c3afca111ce83fb6ceda14b06a8e078a5/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6d6f6c746f622f70796d756c746967656e2f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/License-MIT-yellow.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8645b002dd7ec1b54275a80574942e7a318e03c6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d79656c6c6f772e737667\"></a>\n<img alt=\"https://img.shields.io/badge/contributions-welcome-brightgreen.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/220aa3f89f789ec18b3b3c9096a2a11ab994fd90/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f6e747269627574696f6e732d77656c636f6d652d627269676874677265656e2e737667\">\n<p>This small library adds multi-file management on top of one or more existing single-file code\ngenerators.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#why-would-i-need-pymultigen\" id=\"id1\" rel=\"nofollow\">Why would I need pymultigen?</a></li>\n<li><a href=\"#installation\" id=\"id2\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#usage\" id=\"id3\" rel=\"nofollow\">Usage</a><ul>\n<li><a href=\"#using-the-jinja2-integration\" id=\"id4\" rel=\"nofollow\">Using the Jinja2 integration</a></li>\n</ul>\n</li>\n<li><a href=\"#extending-pymultigen\" id=\"id5\" rel=\"nofollow\">Extending pymultigen</a><ul>\n<li><a href=\"#formatters\" id=\"id6\" rel=\"nofollow\">Formatters</a></li>\n<li><a href=\"#templating-engine\" id=\"id7\" rel=\"nofollow\">Templating engine</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"why-would-i-need-pymultigen\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Why would I need pymultigen?</a></h2>\n<p>Code generators like <a href=\"http://www.makotemplates.org/\" rel=\"nofollow\">Mako</a> or <a href=\"http://jinja.pocoo.org/\" rel=\"nofollow\">Jinja</a>\nare great and can be used to generate just about any kind of textual output from templates with a\nnice template language. They are very mature and battle-proven. However, most of those generators\nhave their origin in the web application domain. The typical usecase is to dynamically render a\nsingle HTTP response (most of the time an HTML page) from one or more templates. <em>One</em> HTML page.</p>\n<p>If you want to use these generators in other scenarious, e.g. to generate code or reports, but not\nto <em>one</em> but to <em>multiple</em> files in different folders, pymultigen can help. It simply adds an easy\nto configure file and folder management layer on top of one or more existing code generators.</p>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Installation</a></h2>\n<p>pymultigen comes in form or a regular Python distribution and can be installed from Github or PyPI\nwith a simple:</p>\n<pre>$ pip install pymultigen\n</pre>\n<p>The library works with any version of Python &gt;= 3.3.</p>\n</div>\n<div id=\"usage\">\n<h2><a href=\"#id3\" rel=\"nofollow\">Usage</a></h2>\n<p>The overall concept of pymultigen is simple:</p>\n<ul>\n<li>A <tt>Generator</tt> class controls the overall generation workflow. The most important method it\nimplements is <tt>generate(model, folder)</tt>. This is the single method called by <em>users</em> of the\ncreated multi-file generator.</li>\n<li>The <tt>Generator</tt> has a static list of <tt>Task</tt> objects. Each <tt>Task</tt> describes a step executed\nat generation time.</li>\n<li>One <tt>Task</tt> is responsible for translating a specific set of elements in the input model to one\noutput file in the output folder. The input set can be chosen arbitrarily, often this is the list\nof a certain model element type (e.g. instance of a <tt>Table</tt> class in a relational model from\nwhich SQL statements should be generated).</li>\n</ul>\n<p>Using pymultigen means therefore to create one <tt>Generator</tt> class for your new generator and one or\nmore <tt>Task</tt> classes, one for each type of output artifact. If you are using a template-based code\ngenerator under the hood, you usually will have one <tt>Task</tt> per output template.</p>\n<p>Before you start, you need to check, whether pymultigen already has an integration for your\nsingle-file code generator built-in. Currently, the following integrations are available:</p>\n<ul>\n<li>Jinja2</li>\n</ul>\n<p>If you want to use another generation engine, you can easily add support yourself (the current\nJinja2 integration consists of less than 20 lines of code). If you\u2019ve done so, please consider\ngiving back to the community. Your contribution is welcome! Please see below for instructions how to\nextend pymultigen with a new integration.</p>\n<div id=\"using-the-jinja2-integration\">\n<h3><a href=\"#id4\" rel=\"nofollow\">Using the Jinja2 integration</a></h3>\n<p>You may want to check out <a href=\"https://github.com/pyecore/pyecoregen\" rel=\"nofollow\">pyecoregen</a>, a code generator\nfrom <a href=\"https://github.com/pyecore/pyecore\" rel=\"nofollow\">pyecore</a>-based models to Python classes. It is a\nconcrete Jinja2-based code generator built with pymultigen.</p>\n<p>Jinja2 is a template-based text generator. Writing a file-generator with Jinja therefore involves\nwriting a template for each type of output file. In pymultigen you will then implement a <tt>Task</tt>\nclass per output file type, i.e. per Jinja template.</p>\n<p>The general form of such a <tt>Task</tt> looks like this:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyTask</span><span class=\"p\">(</span><span class=\"n\">multigen</span><span class=\"o\">.</span><span class=\"n\">jinja</span><span class=\"o\">.</span><span class=\"n\">JinjaTask</span><span class=\"p\">):</span>\n\n    <span class=\"c1\"># Name of template file used by this task.</span>\n    <span class=\"n\">template_name</span> <span class=\"o\">=</span> <span class=\"s1\">'name-of-template.tpl'</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">filtered_elements</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Return iterator based over elements in model that are passed to template.\"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">relative_path_for_element</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Returns relative file path receiving the generator output for given element.\"\"\"</span>\n</pre>\n<p>The workflow engine will initially call <tt>filtered_elements</tt>. This method is expected to return an\ninterator over model elements for which a single file needs to be generated. <em>Model</em> is meant here\nin an abstract way: It may be an instance of a formal metamodel, but it could be any Python object,\nlike a dictionaries or lists. The contained elements being iterated over are accessible from within\na template as <tt>element</tt>.</p>\n<p>Once Jinja has produced a textual result it must be written to file. This is where\n<tt>relative_path_for_element</tt> comes into play. For a given element that was filtered from the model\nbefore, it returns the corresponding filepath. Note that this path is interpreted to be relative to\nthe top-level output path of the overall generation (see below). If subfolders are mentioned here,\nthey are created on demand.</p>\n<p>One of more tasks classes like this must then be registered with a top-level generator. Just like\nbefore, a new <tt>Generator</tt> class is derived from the appropriate base class:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyGenerator</span><span class=\"p\">(</span><span class=\"n\">multigen</span><span class=\"o\">.</span><span class=\"n\">jinja</span><span class=\"o\">.</span><span class=\"n\">JinjaGenerator</span><span class=\"p\">):</span>\n\n    <span class=\"c1\"># List of task objects to be processed by this generator.</span>\n    <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"n\">MyTask</span><span class=\"p\">(),</span>\n    <span class=\"p\">]</span>\n\n    <span class=\"c1\"># Root path where Jinja templates are found.</span>\n    <span class=\"n\">templates_path</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span>\n        <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">abspath</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">dirname</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">)),</span>\n        <span class=\"s1\">'templates'</span>\n    <span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">create_environment</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Create Jinja2 environment.\"\"\"</span>\n        <span class=\"n\">environment</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">create_environment</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Do any customization of environment here, or delete this method.</span>\n        <span class=\"k\">return</span> <span class=\"n\">environment</span>\n</pre>\n<p>The base class implementation of {{create_environment}} passes {{templates_path}} to the created\nenvironment object to allow Jinja to find the template names specified in a <tt>Tasks</tt>\u2019s\n<tt>template_name</tt>. By overriding this method you can extend the environment, e.g. to add filters and\ntests. Of course you can also completely replace the implementation, e.g. to change the way how\ntemplates how looked up.</p>\n<p>The example above simply instantiates the new <tt>Task</tt> class. Here you can optionally pass a\nformatter function, that is then applied to the output of Jinja. Formatters are simple string\ntransformations, some of which are built-in in the <tt>formatters.py</tt> module. If you actually are\nwriting a Python code generator you may want to clean up the generated code according to pep8,\nsimply pass the appropriate formatter during task instantiation:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyGeneratorWithPep8</span><span class=\"p\">(</span><span class=\"n\">multigen</span><span class=\"o\">.</span><span class=\"n\">jinja</span><span class=\"o\">.</span><span class=\"n\">JinjaGenerator</span><span class=\"p\">):</span>\n\n    <span class=\"c1\"># List of task objects to be processed by this generator.</span>\n    <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"n\">MyTask</span><span class=\"p\">(</span><span class=\"n\">formatter</span><span class=\"o\">=</span><span class=\"n\">multigen</span><span class=\"o\">.</span><span class=\"n\">formatter</span><span class=\"o\">.</span><span class=\"n\">format_autopep8</span><span class=\"p\">),</span>\n    <span class=\"p\">]</span>\n\n    <span class=\"o\">...</span>\n</pre>\n</div>\n</div>\n<div id=\"extending-pymultigen\">\n<h2><a href=\"#id5\" rel=\"nofollow\">Extending pymultigen</a></h2>\n<p>Contributions welcome!</p>\n<p>Below the most typical extension scenarios are described. Note that in theory pymultigen can be used\nwith <em>any</em> code that produces text, not just a templating engine. Take a look at the class hierarchy\nin <tt>generator.py</tt> to get more insights or drop me a note if this is something you plan to do.</p>\n<div id=\"formatters\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Formatters</a></h3>\n<p>Writing a new formatter is trivial: Simply create a function that transforms an input string into\nthe nicely formatted output string. If you want to get your formatter added to pymultigen, please\nmake sure that:</p>\n<ul>\n<li>New dependencies (like autopep8 in the existing pep8 formatter) are only imported in the\nformatting function. This way user only pay for what they use.</li>\n<li>Please write unittests and add your possible dependencies to the <tt>tests_require</tt> argument in\n<tt>setup.py</tt>.</li>\n</ul>\n<p>There is not much more to it.</p>\n</div>\n<div id=\"templating-engine\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Templating engine</a></h3>\n<p>For a live sample, look at the Jinja2 integration in <tt>jinja.py</tt>. For your templating engine <tt>X</tt>,\nyou probably have to write small <tt>Generator</tt> and <tt>Task</tt> base classes like this:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">XGenerator</span><span class=\"p\">(</span><span class=\"n\">TemplateGenerator</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">environment</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Add any attributes to the generator that are static with respect to a full generation</span>\n        <span class=\"c1\"># run (over all files), like a Jinja2 environment.</span>\n        <span class=\"o\">...</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">XTask</span><span class=\"p\">(</span><span class=\"n\">TemplateFileTask</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">generate_file</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">filepath</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Actual generation of element.\"\"\"</span>\n</pre>\n<p>Each element that is iterated over from the input model is eventually passed to the tasks\u2019s\n<tt>generate_file</tt> method. Here simply call you template engine to produce the output string. You\nalso want to apply the optional formatter before writing the string to disk. This is how the Jinja\ntask does it:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">generate_file</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">filepath</span><span class=\"p\">):</span>\n    <span class=\"n\">template</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">environment</span><span class=\"o\">.</span><span class=\"n\">get_template</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">template_name</span><span class=\"p\">)</span>\n    <span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">create_template_context</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"o\">=</span><span class=\"n\">element</span><span class=\"p\">)</span>\n\n    <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">filepath</span><span class=\"p\">,</span> <span class=\"s1\">'wt'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">file</span><span class=\"p\">:</span>\n        <span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">formatter</span><span class=\"p\">(</span><span class=\"n\">template</span><span class=\"o\">.</span><span class=\"n\">render</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">context</span><span class=\"p\">)))</span>\n</pre>\n<p>The implementation shows two more things:</p>\n<ul>\n<li>The template to be used is retrieved from an <tt>environment</tt> that is specific to the template\nengine. Such an environment is usually passed down from the <tt>Generator</tt> class to the <tt>Task</tt>.</li>\n<li><tt>create_template_context</tt> is a function implemented in base class <tt>TemplateTask</tt>. It\nimplements the very common case of dictionaries being used as template context objects. Of course\nyou can override this if it doesn\u2019t match your engine.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3125458, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "77557db616188327e9ca141bd3925a98", "sha256": "b1c37f85db7a8ebf76b9ebfa60f85b6c50d5962607bbee7d7eaeaa263e55c1a9"}, "downloads": -1, "filename": "pymultigen-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "77557db616188327e9ca141bd3925a98", "packagetype": "bdist_wheel", "python_version": "3.6", "requires_python": null, "size": 5515, "upload_time": "2017-05-23T19:03:03", "upload_time_iso_8601": "2017-05-23T19:03:03.892461Z", "url": "https://files.pythonhosted.org/packages/e5/7c/040aad71db88a7c50a0d3d8cef2ba279a9271d4d4df05f6acf7fd4edc426/pymultigen-0.0.1-py3-none-any.whl", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "6bbcde513b0123dd9a21477699845652", "sha256": "b38def3ea691682f7f9f1bd118d05e8491ad31a9c403809f2f920bab86426b68"}, "downloads": -1, "filename": "pymultigen-0.0.2.tar.gz", "has_sig": false, "md5_digest": "6bbcde513b0123dd9a21477699845652", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3619, "upload_time": "2017-05-23T19:51:25", "upload_time_iso_8601": "2017-05-23T19:51:25.956241Z", "url": "https://files.pythonhosted.org/packages/59/81/7d808ee38e1807ab7666ab9461ffe465897a637f76dd4ec987d71219c476/pymultigen-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "f592cfaf9f10ba00ca917141769c66c9", "sha256": "60bbe3c25bd677a8329ca7ac0c50b1b239218713ea0f98e344250b3e364f94e8"}, "downloads": -1, "filename": "pymultigen-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "f592cfaf9f10ba00ca917141769c66c9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5693, "upload_time": "2017-05-23T20:00:37", "upload_time_iso_8601": "2017-05-23T20:00:37.788983Z", "url": "https://files.pythonhosted.org/packages/85/d3/36514277314fb680d8cc718e7d2334afd41ec92c90b5db58be6c4269f418/pymultigen-0.0.3-py3-none-any.whl", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "b1cdaa1f7327cacdf9226296854d1a07", "sha256": "f0a46ae944ec62e07ecb9f2260859cff72e23862d75e3eff7b76af4e9683346f"}, "downloads": -1, "filename": "pymultigen-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b1cdaa1f7327cacdf9226296854d1a07", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12026, "upload_time": "2017-05-25T15:00:19", "upload_time_iso_8601": "2017-05-25T15:00:19.715592Z", "url": "https://files.pythonhosted.org/packages/a3/3b/d16f922b9446298a188867c5dbf60a3bbdd0fc1c53e791ce0b63e8cb86c9/pymultigen-0.1.1-py3-none-any.whl", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "fa330d4747182cf73a21a5ef0669a62d", "sha256": "b84b8d7227354ba7373db3ea04b0ecc4c87fffc3e980be447c0d0b4428b6f492"}, "downloads": -1, "filename": "pymultigen-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "fa330d4747182cf73a21a5ef0669a62d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12255, "upload_time": "2017-08-26T18:48:44", "upload_time_iso_8601": "2017-08-26T18:48:44.573384Z", "url": "https://files.pythonhosted.org/packages/23/d5/07571f86a39e8a99e573a1864646d8615614fd10225e0c894c67102123f9/pymultigen-0.2.0-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fa330d4747182cf73a21a5ef0669a62d", "sha256": "b84b8d7227354ba7373db3ea04b0ecc4c87fffc3e980be447c0d0b4428b6f492"}, "downloads": -1, "filename": "pymultigen-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "fa330d4747182cf73a21a5ef0669a62d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12255, "upload_time": "2017-08-26T18:48:44", "upload_time_iso_8601": "2017-08-26T18:48:44.573384Z", "url": "https://files.pythonhosted.org/packages/23/d5/07571f86a39e8a99e573a1864646d8615614fd10225e0c894c67102123f9/pymultigen-0.2.0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:01:33 2020"}