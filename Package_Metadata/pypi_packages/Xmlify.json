{"info": {"author": "saaj", "author_email": "mail@saaj.me", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Libraries"], "description": ".. image:: https://badge.fury.io/py/Xmlify.png\r\n  :target: https://pypi.python.org/pypi/Xmlify\r\n\r\n======\r\nXmlify\r\n======\r\nXmlify is simple and fast Python built-in type XML serialiser. Its purpose is to convert\r\nnested structures that are composed of types like ``dict``, ``list``, ``tuple``, ``str``, \r\n``int``, etc. It has no dependencies, uses ``xml.etree.cElementTree`` and produces XML \r\nstructure suitable for humans to read.\r\n\r\nUse case\r\n========\r\nI use it for structured logging into MySQL. Later, when I need to investigation an incident,\r\nI can further narrow the result set using `MySQL XML functions \r\n<https://dev.mysql.com/doc/refman/5.1/en/xml-functions.html>`_. You can\r\nuse it for something else.\r\n\r\nResult markup\r\n=============\r\nBecause the XML tree is constructed only using ``xml.etree.cElementTree`` the output is\r\nalways valid XML. But it is more restrictive to tag names. Output tag names avoid colon \r\n(XML namespaces) and are ASCII-only, even though the specification `permits Unicode \r\ncodepoints <http://www.w3.org/TR/REC-xml/#NT-NameChar>`_. It was to simplify things, \r\nas there was no benefit of having Unicode tags, and to maximise XML parser compatibility. \r\n\r\nUnicode tag names are hex-encoded and prefixed with ``x``. XML-incompatible binary values\r\nare hex-encoded in the same way. XML-incompatible ASCII characters in tag names are replaced \r\nwith underscore. If tag name starts with a digit it is prefixed with ``n``. Though, it's easy\r\nto override. The following regular expressions control substitution and tag's first character\r\nmatch. You can also monkeypatch ``xmlify._key`` completely.   \r\n\r\n.. sourcecode:: python\r\n\r\n  xmlify._notFirstCharRe  = re.compile(r'[^a-z_]{1}', re.IGNORECASE)\r\n  xmlify._notOtherCharsRe = re.compile(r'[^a-z0-9_\\-\\.]', re.IGNORECASE)\r\n\r\nThe type information isn't preserved intentionally to make the output easier to read to a human.\r\nIf you need to preserve type information or to convert XML to objects two-way, just use stdlib's\r\n``xmlrpclib.dumps``/``xmlrpclib.loads``. \r\n\r\nUsage\r\n=====\r\nThis is the public API:\r\n\r\n.. sourcecode:: python\r\n\r\n  def dump(obj, fp, root = 'data', declaration = False): pass\r\n  \r\n  def dumps(obj, root = 'data', declaration = False): pass\r\n  \r\nUse it like:\r\n\r\n.. sourcecode:: python\r\n\r\n  import datetime\r\n  import xmlify\r\n  \r\n  d = {\r\n    'python' : {\r\n      2 : {\r\n        2.7 : {\r\n          'version' : (2, 7, 10),\r\n          'date'    : datetime.date(2015, 5, 23) \r\n        }\r\n      },\r\n      3 : {\r\n        3.3 : {\r\n          'version' : (3, 3, 6),\r\n          'date'    : datetime.date(2014, 10, 12) \r\n        },\r\n        3.4 : {\r\n          'version' : (3, 4, 3),\r\n          'date'    : datetime.date(2015, 2, 25) \r\n        }        \r\n      }\r\n    }\r\n  }\r\n  print(xmlify.dumps(d))\r\n\r\nIt prints the following XML (indented separately):\r\n  \r\n.. sourcecode:: xml\r\n\r\n  <data>\r\n    <python>\r\n      <n2>\r\n        <n2.7>\r\n          <date>2015-05-23</date>\r\n          <version>\r\n            <version-item>2</version-item>\r\n            <version-item>7</version-item>\r\n            <version-item>10</version-item>\r\n          </version>\r\n        </n2.7>\r\n      </n2>\r\n      <n3>\r\n        <n3.3>\r\n          <date>2014-10-12</date>\r\n          <version>\r\n            <version-item>3</version-item>\r\n            <version-item>3</version-item>\r\n            <version-item>6</version-item>\r\n          </version>\r\n        </n3.3>\r\n        <n3.4>\r\n          <date>2015-02-25</date>\r\n          <version>\r\n            <version-item>3</version-item>\r\n            <version-item>4</version-item>\r\n            <version-item>3</version-item>\r\n          </version>\r\n        </n3.4>\r\n      </n3>\r\n    </python>\r\n  </data>\r\n  \r\nSimple?\r\n=======\r\nIt's worth just 14 LLOC of a `recursive function \r\n<https://bitbucket.org/saaj/xmlify/src/fb27d4fe/xmlify/__init__.py#cl-54>`_. The rest ~100 LLOC\r\nis supporting code that goes in line with Pareto principle.\r\n\r\nFast?\r\n=====\r\n.. sourcecode:: bash\r\n\r\n  $ python -c 'import os; print(len(os.environ))'\r\n  58\r\n  $ python2.7 -m timeit 'import os,xmlify; xmlify.dumps(os.environ)'\r\n  1000 loops, best of 3: 987 usec per loop\r\n  $ python3.3 -m timeit 'import os,xmlify; xmlify.dumps(os.environ)'\r\n  1000 loops, best of 3: 1.62 msec per loop\r\n  $ pypy -m timeit 'import os,xmlify; xmlify.dumps(os.environ)'\r\n  1000 loops, best of 3: 193 usec per loop\r\n  \r\nInventing own wheel\r\n===================\r\nNIH was not the case \u2013 even though I already had a working code I would happily have used an\r\nexisting library that fits my needs. At the Cheese Shop there were several groups of libraries \r\nthat do the same or closely related thing:\r\n\r\n* Mappers that need schema up-front\r\n* Libraries that need to build dependencies with OS package dependencies, e.g. lxml\r\n* Marshallers that try to preserve type information, thus making result markup hard to read\r\n* Libraries that build XML tree manually with strings and thus with potential escaping issues\r\n* Just broken\r\n\r\nI the end I just decided to package the code I had.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/saaj/xmlify", "keywords": "python xml", "license": "LGPL-2.1+", "maintainer": "", "maintainer_email": "", "name": "Xmlify", "package_url": "https://pypi.org/project/Xmlify/", "platform": "Any", "project_url": "https://pypi.org/project/Xmlify/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://bitbucket.org/saaj/xmlify"}, "release_url": "https://pypi.org/project/Xmlify/0.1.1/", "requires_dist": null, "requires_python": null, "summary": "Simple and fast Python built-in type XML serialiser", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.python.org/pypi/Xmlify\" rel=\"nofollow\"><img alt=\"https://badge.fury.io/py/Xmlify.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/717288edc25b34e79bbf086ab81da059e65225bf/68747470733a2f2f62616467652e667572792e696f2f70792f586d6c6966792e706e67\"></a>\n<div id=\"xmlify\">\n<h2>Xmlify</h2>\n<p>Xmlify is simple and fast Python built-in type XML serialiser. Its purpose is to convert\nnested structures that are composed of types like <tt>dict</tt>, <tt>list</tt>, <tt>tuple</tt>, <tt>str</tt>,\n<tt>int</tt>, etc. It has no dependencies, uses <tt>xml.etree.cElementTree</tt> and produces XML\nstructure suitable for humans to read.</p>\n<div id=\"use-case\">\n<h3>Use case</h3>\n<p>I use it for structured logging into MySQL. Later, when I need to investigation an incident,\nI can further narrow the result set using <a href=\"https://dev.mysql.com/doc/refman/5.1/en/xml-functions.html\" rel=\"nofollow\">MySQL XML functions</a>. You can\nuse it for something else.</p>\n</div>\n<div id=\"result-markup\">\n<h3>Result markup</h3>\n<p>Because the XML tree is constructed only using <tt>xml.etree.cElementTree</tt> the output is\nalways valid XML. But it is more restrictive to tag names. Output tag names avoid colon\n(XML namespaces) and are ASCII-only, even though the specification <a href=\"http://www.w3.org/TR/REC-xml/#NT-NameChar\" rel=\"nofollow\">permits Unicode\ncodepoints</a>. It was to simplify things,\nas there was no benefit of having Unicode tags, and to maximise XML parser compatibility.</p>\n<p>Unicode tag names are hex-encoded and prefixed with <tt>x</tt>. XML-incompatible binary values\nare hex-encoded in the same way. XML-incompatible ASCII characters in tag names are replaced\nwith underscore. If tag name starts with a digit it is prefixed with <tt>n</tt>. Though, it\u2019s easy\nto override. The following regular expressions control substitution and tag\u2019s first character\nmatch. You can also monkeypatch <tt>xmlify._key</tt> completely.</p>\n<pre><span class=\"n\">xmlify</span><span class=\"o\">.</span><span class=\"n\">_notFirstCharRe</span>  <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[^a-z_]</span><span class=\"si\">{1}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">IGNORECASE</span><span class=\"p\">)</span>\n<span class=\"n\">xmlify</span><span class=\"o\">.</span><span class=\"n\">_notOtherCharsRe</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[^a-z0-9_\\-\\.]'</span><span class=\"p\">,</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">IGNORECASE</span><span class=\"p\">)</span>\n</pre>\n<p>The type information isn\u2019t preserved intentionally to make the output easier to read to a human.\nIf you need to preserve type information or to convert XML to objects two-way, just use stdlib\u2019s\n<tt>xmlrpclib.dumps</tt>/<tt>xmlrpclib.loads</tt>.</p>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<p>This is the public API:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">fp</span><span class=\"p\">,</span> <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"s1\">'data'</span><span class=\"p\">,</span> <span class=\"n\">declaration</span> <span class=\"o\">=</span> <span class=\"kc\">False</span><span class=\"p\">):</span> <span class=\"k\">pass</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">dumps</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"s1\">'data'</span><span class=\"p\">,</span> <span class=\"n\">declaration</span> <span class=\"o\">=</span> <span class=\"kc\">False</span><span class=\"p\">):</span> <span class=\"k\">pass</span>\n</pre>\n<p>Use it like:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">datetime</span>\n<span class=\"kn\">import</span> <span class=\"nn\">xmlify</span>\n\n<span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"s1\">'python'</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"mi\">2</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"mf\">2.7</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'version'</span> <span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">),</span>\n        <span class=\"s1\">'date'</span>    <span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">(</span><span class=\"mi\">2015</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">23</span><span class=\"p\">)</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"mi\">3</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"mf\">3.3</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'version'</span> <span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">),</span>\n        <span class=\"s1\">'date'</span>    <span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">(</span><span class=\"mi\">2014</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">)</span>\n      <span class=\"p\">},</span>\n      <span class=\"mf\">3.4</span> <span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'version'</span> <span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">),</span>\n        <span class=\"s1\">'date'</span>    <span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">(</span><span class=\"mi\">2015</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">)</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">xmlify</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">))</span>\n</pre>\n<p>It prints the following XML (indented separately):</p>\n<pre><span class=\"nt\">&lt;data&gt;</span>\n  <span class=\"nt\">&lt;python&gt;</span>\n    <span class=\"nt\">&lt;n2&gt;</span>\n      <span class=\"nt\">&lt;n2.7&gt;</span>\n        <span class=\"nt\">&lt;date&gt;</span>2015-05-23<span class=\"nt\">&lt;/date&gt;</span>\n        <span class=\"nt\">&lt;version&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>2<span class=\"nt\">&lt;/version-item&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>7<span class=\"nt\">&lt;/version-item&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>10<span class=\"nt\">&lt;/version-item&gt;</span>\n        <span class=\"nt\">&lt;/version&gt;</span>\n      <span class=\"nt\">&lt;/n2.7&gt;</span>\n    <span class=\"nt\">&lt;/n2&gt;</span>\n    <span class=\"nt\">&lt;n3&gt;</span>\n      <span class=\"nt\">&lt;n3.3&gt;</span>\n        <span class=\"nt\">&lt;date&gt;</span>2014-10-12<span class=\"nt\">&lt;/date&gt;</span>\n        <span class=\"nt\">&lt;version&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>3<span class=\"nt\">&lt;/version-item&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>3<span class=\"nt\">&lt;/version-item&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>6<span class=\"nt\">&lt;/version-item&gt;</span>\n        <span class=\"nt\">&lt;/version&gt;</span>\n      <span class=\"nt\">&lt;/n3.3&gt;</span>\n      <span class=\"nt\">&lt;n3.4&gt;</span>\n        <span class=\"nt\">&lt;date&gt;</span>2015-02-25<span class=\"nt\">&lt;/date&gt;</span>\n        <span class=\"nt\">&lt;version&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>3<span class=\"nt\">&lt;/version-item&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>4<span class=\"nt\">&lt;/version-item&gt;</span>\n          <span class=\"nt\">&lt;version-item&gt;</span>3<span class=\"nt\">&lt;/version-item&gt;</span>\n        <span class=\"nt\">&lt;/version&gt;</span>\n      <span class=\"nt\">&lt;/n3.4&gt;</span>\n    <span class=\"nt\">&lt;/n3&gt;</span>\n  <span class=\"nt\">&lt;/python&gt;</span>\n<span class=\"nt\">&lt;/data&gt;</span>\n</pre>\n</div>\n<div id=\"simple\">\n<h3>Simple?</h3>\n<p>It\u2019s worth just 14 LLOC of a <a href=\"https://bitbucket.org/saaj/xmlify/src/fb27d4fe/xmlify/__init__.py#cl-54\" rel=\"nofollow\">recursive function</a>. The rest ~100 LLOC\nis supporting code that goes in line with Pareto principle.</p>\n</div>\n<div id=\"fast\">\n<h3>Fast?</h3>\n<pre>$ python -c <span class=\"s1\">'import os; print(len(os.environ))'</span>\n<span class=\"m\">58</span>\n$ python2.7 -m timeit <span class=\"s1\">'import os,xmlify; xmlify.dumps(os.environ)'</span>\n<span class=\"m\">1000</span> loops, best of <span class=\"m\">3</span>: <span class=\"m\">987</span> usec per loop\n$ python3.3 -m timeit <span class=\"s1\">'import os,xmlify; xmlify.dumps(os.environ)'</span>\n<span class=\"m\">1000</span> loops, best of <span class=\"m\">3</span>: <span class=\"m\">1</span>.62 msec per loop\n$ pypy -m timeit <span class=\"s1\">'import os,xmlify; xmlify.dumps(os.environ)'</span>\n<span class=\"m\">1000</span> loops, best of <span class=\"m\">3</span>: <span class=\"m\">193</span> usec per loop\n</pre>\n</div>\n<div id=\"inventing-own-wheel\">\n<h3>Inventing own wheel</h3>\n<p>NIH was not the case \u2013 even though I already had a working code I would happily have used an\nexisting library that fits my needs. At the Cheese Shop there were several groups of libraries\nthat do the same or closely related thing:</p>\n<ul>\n<li>Mappers that need schema up-front</li>\n<li>Libraries that need to build dependencies with OS package dependencies, e.g. lxml</li>\n<li>Marshallers that try to preserve type information, thus making result markup hard to read</li>\n<li>Libraries that build XML tree manually with strings and thus with potential escaping issues</li>\n<li>Just broken</li>\n</ul>\n<p>I the end I just decided to package the code I had.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 2380698, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "b9dca511da3c2fb1aabd44bfcc660d6d", "sha256": "07cec4669193924e679c46a68b8bb25c2878e28837f101e2384820a90523c914"}, "downloads": -1, "filename": "Xmlify-0.1.0.tar.gz", "has_sig": false, "md5_digest": "b9dca511da3c2fb1aabd44bfcc660d6d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5888, "upload_time": "2015-06-02T19:31:21", "upload_time_iso_8601": "2015-06-02T19:31:21.449939Z", "url": "https://files.pythonhosted.org/packages/26/68/8c4aef8aa9da2e13fa9e215e8826d4f15ffb5b718fd1925e1c22a3d280d0/Xmlify-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "18d08194e0cf97a3fdaff9ea88f6899a", "sha256": "1a34e3fb2cb91f35036ff474c81f01d1fff4fcf271815b60f51b42839efc12dc"}, "downloads": -1, "filename": "Xmlify-0.1.1.tar.gz", "has_sig": false, "md5_digest": "18d08194e0cf97a3fdaff9ea88f6899a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5941, "upload_time": "2015-06-09T18:54:36", "upload_time_iso_8601": "2015-06-09T18:54:36.926400Z", "url": "https://files.pythonhosted.org/packages/d6/8a/d5b77b9d8d7c2acc539e608c37cb84b0c057f4ec088d66d682467150ddaf/Xmlify-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "18d08194e0cf97a3fdaff9ea88f6899a", "sha256": "1a34e3fb2cb91f35036ff474c81f01d1fff4fcf271815b60f51b42839efc12dc"}, "downloads": -1, "filename": "Xmlify-0.1.1.tar.gz", "has_sig": false, "md5_digest": "18d08194e0cf97a3fdaff9ea88f6899a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5941, "upload_time": "2015-06-09T18:54:36", "upload_time_iso_8601": "2015-06-09T18:54:36.926400Z", "url": "https://files.pythonhosted.org/packages/d6/8a/d5b77b9d8d7c2acc539e608c37cb84b0c057f4ec088d66d682467150ddaf/Xmlify-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:25:00 2020"}