{"info": {"author": "Miguel Araujo", "author_email": "miguel.araujo.perez@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# requests-oauth\n\nThis plugins adds OAuth v1.0 support to <a href=\"https://github.com/kennethreitz\">@kennethreitz</a> well-known <a href=\"http://github.com/kennethreitz/requests\">requests</a> library providing both header and url-encoded authentication.\n\nrequests-oauth wants to provide the simplest and easiest way to do OAuth in Python. It was initially based on <a href=\"https://github.com/simplegeo/python-oauth2\">python-oauth2</a> (which looks unmaintained), kudos to the authors and contributors for doing a huge effort in providing OAuth to python httplib2. From that point on, the code base has been cleaned, fixing several bugs and heavily refactoring it to eliminate dependencies with python-oauth2, being now a stand-alone plugin.\n\n* Author: <a href=\"http://www.github.com/maraujop/\">Miguel Araujo</a>\n* Licence: BSD\n\n## Installation\n\nYou can install requests-oauth by simply doing:\n\n    pip install requests-oauth\n\n## Usage\n\nImport the hook doing:\n\n    from oauth_hook import OAuthHook\n\nYou can initialize the hook passing it 5 parameters: `access_token`, `access_token_secret`, `consumer_key`, `consumer_secret` and `header_auth`. First two `access_token` and `access_token_secret` are optional, in case you want to retrieve those from the API service (see later for an example). There are two ways to do initialize the hook. First one:\n\n    oauth_hook = OAuthHook(access_token, access_token_secret, consumer_key, consumer_secret, header_auth)\n\nThe `header_auth` parameter lets you chose the authentication method used. It's a boolean, if you set it to `True` you will be using an Authorization header. If your API supports this authentication method, it's the one you should be using and the prefered method by the OAuth spec (<a href=\"http://tools.ietf.org/html/rfc5849#section-3.5\">RFC 5849</a>), an example would be Twitter's API. By default `header_auth` is set to `False`, which means url encoded authentication will be used. This is because this the most widely supported authentication system.\n\nIf you are using the same `consumer_key` and `consumer_secret` all the time, you probably want to setup those fixed, so that you only have to pass the token parameters for setting the hook:\n\n    OAuthHook.consumer_key = consumer_key\n    OAuthHook.consumer_secret = consumer_secret\n    oauth_hook = OAuthHook(access_token, access_token_secret, header_auth=True)\n\nNow you need to pass the hook to python-requests, you probably want to do it as a session, so you don't have to do this every time:\n\n    client = requests.session(hooks={'pre_request': oauth_hook})\n\nWhat you get is python-requests client which you can use the same way as you use requests API. Let's see a GET example:\n\n    response = client.get('http://api.twitter.com/1/account/rate_limit_status.json')\n    results = json.loads(response.content)\n\nAnd a POST example:\n\n    response = client.post('http://api.twitter.com/1/statuses/update.json', {'status': \"Yay! It works!\", 'wrap_links': True})\n\n## 3-legged Authorization\n\nFirst time authorization and authentication follows a system named three legged OAuth, very well described in <a href=\"https://dev.twitter.com/docs/auth/implementing-sign-twitter\">Twitter documentation</a>.\n\nBasically it is composed of three steps. Let's see an example based on Imgur's API. All the other APIs work pretty much the same way, only endpoints (urls) change:\n\n#### Step 1: Obtaining a request token\n\nWe start asking for a request token, which will finally turn into an access token, the one we need to operate on behalf of the user.\n\n    imgur_oauth_hook = OAuthHook(consumer_key=YOUR_IMGUR_CONSUMER_KEY, consumer_secret=YOUR_IMGUR_CONSUMER_SECRET)\n    response = requests.post('http://api.imgur.com/oauth/request_token', hooks={'pre_request': imgur_oauth_hook})\n    qs = parse_qs(response.text)\n    oauth_token = qs['oauth_token'][0]\n    oauth_secret = qs['oauth_token_secret'][0]\n\n#### Step 2: Redirecting the user for getting authorization\n\nIn this step we give the user a link or open a web browser redirecting him to an endpoint, passing the `oauth_token` got in the previous step as a url parameter. The user will get a dialog asking for authorization for our application. In this case we are doing an out of band desktop application, so the user will have to input us a code named `verifier`. In web apps, we will get this code as a webhook.\n\n    print \"Go to http://api.imgur.com/oauth/authorize?oauth_token=%s allow the app and copy your PIN\" % oauth_token\n    oauth_verifier = raw_input('Please enter your PIN:')\n\n#### Step 3: Authenticate\n\nOnce we get user's authorization, we request a final access token, to operate on behalf of the user. We build a new hook using previous request token information achieved on step1 and pass the verifier (got in step2) as data using `oauth_verifier` key:\n\n    new_imgur_oauth_hook = OAuthHook(oauth_token, oauth_secret, IMGUR_CONSUMER_KEY, IMGUR_CONSUMER_SECRET)\n    response = requests.post('http://api.imgur.com/oauth/access_token', {'oauth_verifier': oauth_verifier}, hooks={'pre_request': new_imgur_oauth_hook})\n    response = parse_qs(response.content)\n    final_token = response['oauth_token'][0]\n    final_token_secret = response['oauth_token_secret'][0]\n\nThese `final_token` and `final_token_secret` are the credentials we need to use for handling user's oauth, so most likely you will want to persist them somehow. These are the ones you should use for building a requests session with a new hook. Beware that not all OAuth APIs provide unlimited time credentials.\n\n## Testing\n\nIf you want to run the tests, you will need to copy `test_settings.py.template` into `test_settings.py`. This file is in the `.gitignore` index, so it won't be committed:\n\n    cp test_settings.py.template test_settings.py\n\nThen fill in the information there. The testing of the library is done in a functional way, doing GETs and POSTs against public OAuth APIs like Twitter, so use a test account and not your personal account:\n\n    ./tests.py\n\n## Contributing\n\nIf you'd like to contribute, simply fork the repository, commit your changes to the `dev` branch (or branch off of it), and send a pull request. Make sure you add yourself to AUTHORS.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/maraujop/requests-oauth", "keywords": "requests,python-requests,OAuth,open authentication", "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "requests-oauth", "package_url": "https://pypi.org/project/requests-oauth/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/requests-oauth/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/maraujop/requests-oauth"}, "release_url": "https://pypi.org/project/requests-oauth/0.4.1/", "requires_dist": null, "requires_python": null, "summary": "Hook for adding Open Authentication support to Python-requests HTTP library.", "version": "0.4.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p># requests-oauth</p>\n<p>This plugins adds OAuth v1.0 support to &lt;a href=\u201d<a href=\"https://github.com/kennethreitz\" rel=\"nofollow\">https://github.com/kennethreitz</a>\u201d&gt;@kennethreitz&lt;/a&gt; well-known &lt;a href=\u201d<a href=\"http://github.com/kennethreitz/requests\" rel=\"nofollow\">http://github.com/kennethreitz/requests</a>\u201d&gt;requests&lt;/a&gt; library providing both header and url-encoded authentication.</p>\n<p>requests-oauth wants to provide the simplest and easiest way to do OAuth in Python. It was initially based on &lt;a href=\u201d<a href=\"https://github.com/simplegeo/python-oauth2\" rel=\"nofollow\">https://github.com/simplegeo/python-oauth2</a>\u201d&gt;python-oauth2&lt;/a&gt; (which looks unmaintained), kudos to the authors and contributors for doing a huge effort in providing OAuth to python httplib2. From that point on, the code base has been cleaned, fixing several bugs and heavily refactoring it to eliminate dependencies with python-oauth2, being now a stand-alone plugin.</p>\n<ul>\n<li>Author: &lt;a href=\u201d<a href=\"http://www.github.com/maraujop/\" rel=\"nofollow\">http://www.github.com/maraujop/</a>\u201d&gt;Miguel Araujo&lt;/a&gt;</li>\n<li>Licence: BSD</li>\n</ul>\n<p>## Installation</p>\n<p>You can install requests-oauth by simply doing:</p>\n<blockquote>\npip install requests-oauth</blockquote>\n<p>## Usage</p>\n<p>Import the hook doing:</p>\n<blockquote>\nfrom oauth_hook import OAuthHook</blockquote>\n<p>You can initialize the hook passing it 5 parameters: <cite>access_token</cite>, <cite>access_token_secret</cite>, <cite>consumer_key</cite>, <cite>consumer_secret</cite> and <cite>header_auth</cite>. First two <cite>access_token</cite> and <cite>access_token_secret</cite> are optional, in case you want to retrieve those from the API service (see later for an example). There are two ways to do initialize the hook. First one:</p>\n<blockquote>\noauth_hook = OAuthHook(access_token, access_token_secret, consumer_key, consumer_secret, header_auth)</blockquote>\n<p>The <cite>header_auth</cite> parameter lets you chose the authentication method used. It\u2019s a boolean, if you set it to <cite>True</cite> you will be using an Authorization header. If your API supports this authentication method, it\u2019s the one you should be using and the prefered method by the OAuth spec (&lt;a href=\u201d<a href=\"http://tools.ietf.org/html/rfc5849#section-3.5\" rel=\"nofollow\">http://tools.ietf.org/html/rfc5849#section-3.5</a>\u201d&gt;RFC 5849&lt;/a&gt;), an example would be Twitter\u2019s API. By default <cite>header_auth</cite> is set to <cite>False</cite>, which means url encoded authentication will be used. This is because this the most widely supported authentication system.</p>\n<p>If you are using the same <cite>consumer_key</cite> and <cite>consumer_secret</cite> all the time, you probably want to setup those fixed, so that you only have to pass the token parameters for setting the hook:</p>\n<blockquote>\nOAuthHook.consumer_key = consumer_key\nOAuthHook.consumer_secret = consumer_secret\noauth_hook = OAuthHook(access_token, access_token_secret, header_auth=True)</blockquote>\n<p>Now you need to pass the hook to python-requests, you probably want to do it as a session, so you don\u2019t have to do this every time:</p>\n<blockquote>\nclient = requests.session(hooks={\u2018pre_request\u2019: oauth_hook})</blockquote>\n<p>What you get is python-requests client which you can use the same way as you use requests API. Let\u2019s see a GET example:</p>\n<blockquote>\nresponse = client.get(\u2018<a href=\"http://api.twitter.com/1/account/rate_limit_status.json\" rel=\"nofollow\">http://api.twitter.com/1/account/rate_limit_status.json</a>\u2019)\nresults = json.loads(response.content)</blockquote>\n<p>And a POST example:</p>\n<blockquote>\nresponse = client.post(\u2018<a href=\"http://api.twitter.com/1/statuses/update.json\" rel=\"nofollow\">http://api.twitter.com/1/statuses/update.json</a>\u2019, {\u2018status\u2019: \u201cYay! It works!\u201d, \u2018wrap_links\u2019: True})</blockquote>\n<p>## 3-legged Authorization</p>\n<p>First time authorization and authentication follows a system named three legged OAuth, very well described in &lt;a href=\u201d<a href=\"https://dev.twitter.com/docs/auth/implementing-sign-twitter\" rel=\"nofollow\">https://dev.twitter.com/docs/auth/implementing-sign-twitter</a>\u201d&gt;Twitter documentation&lt;/a&gt;.</p>\n<p>Basically it is composed of three steps. Let\u2019s see an example based on Imgur\u2019s API. All the other APIs work pretty much the same way, only endpoints (urls) change:</p>\n<p>#### Step 1: Obtaining a request token</p>\n<p>We start asking for a request token, which will finally turn into an access token, the one we need to operate on behalf of the user.</p>\n<blockquote>\nimgur_oauth_hook = OAuthHook(consumer_key=YOUR_IMGUR_CONSUMER_KEY, consumer_secret=YOUR_IMGUR_CONSUMER_SECRET)\nresponse = requests.post(\u2018<a href=\"http://api.imgur.com/oauth/request_token\" rel=\"nofollow\">http://api.imgur.com/oauth/request_token</a>\u2019, hooks={\u2018pre_request\u2019: imgur_oauth_hook})\nqs = parse_qs(response.text)\noauth_token = qs[\u2018oauth_token\u2019][0]\noauth_secret = qs[\u2018oauth_token_secret\u2019][0]</blockquote>\n<p>#### Step 2: Redirecting the user for getting authorization</p>\n<p>In this step we give the user a link or open a web browser redirecting him to an endpoint, passing the <cite>oauth_token</cite> got in the previous step as a url parameter. The user will get a dialog asking for authorization for our application. In this case we are doing an out of band desktop application, so the user will have to input us a code named <cite>verifier</cite>. In web apps, we will get this code as a webhook.</p>\n<blockquote>\nprint \u201cGo to <a href=\"http://api.imgur.com/oauth/authorize?oauth_token=%s\" rel=\"nofollow\">http://api.imgur.com/oauth/authorize?oauth_token=%s</a> allow the app and copy your PIN\u201d % oauth_token\noauth_verifier = raw_input(\u2018Please enter your PIN:\u2019)</blockquote>\n<p>#### Step 3: Authenticate</p>\n<p>Once we get user\u2019s authorization, we request a final access token, to operate on behalf of the user. We build a new hook using previous request token information achieved on step1 and pass the verifier (got in step2) as data using <cite>oauth_verifier</cite> key:</p>\n<blockquote>\nnew_imgur_oauth_hook = OAuthHook(oauth_token, oauth_secret, IMGUR_CONSUMER_KEY, IMGUR_CONSUMER_SECRET)\nresponse = requests.post(\u2018<a href=\"http://api.imgur.com/oauth/access_token\" rel=\"nofollow\">http://api.imgur.com/oauth/access_token</a>\u2019, {\u2018oauth_verifier\u2019: oauth_verifier}, hooks={\u2018pre_request\u2019: new_imgur_oauth_hook})\nresponse = parse_qs(response.content)\nfinal_token = response[\u2018oauth_token\u2019][0]\nfinal_token_secret = response[\u2018oauth_token_secret\u2019][0]</blockquote>\n<p>These <cite>final_token</cite> and <cite>final_token_secret</cite> are the credentials we need to use for handling user\u2019s oauth, so most likely you will want to persist them somehow. These are the ones you should use for building a requests session with a new hook. Beware that not all OAuth APIs provide unlimited time credentials.</p>\n<p>## Testing</p>\n<p>If you want to run the tests, you will need to copy <cite>test_settings.py.template</cite> into <cite>test_settings.py</cite>. This file is in the <cite>.gitignore</cite> index, so it won\u2019t be committed:</p>\n<blockquote>\ncp test_settings.py.template test_settings.py</blockquote>\n<p>Then fill in the information there. The testing of the library is done in a functional way, doing GETs and POSTs against public OAuth APIs like Twitter, so use a test account and not your personal account:</p>\n<blockquote>\n./tests.py</blockquote>\n<p>## Contributing</p>\n<p>If you\u2019d like to contribute, simply fork the repository, commit your changes to the <cite>dev</cite> branch (or branch off of it), and send a pull request. Make sure you add yourself to AUTHORS.</p>\n\n          </div>"}, "last_serial": 798884, "releases": {"0.2.1": [{"comment_text": "", "digests": {"md5": "cdbac4737f2c31badc81d4fb1798467a", "sha256": "f6c06a9e4d5238b00b5c80919020669d3ecedfd245aa9449ede4709d4cb26fc3"}, "downloads": -1, "filename": "requests-oauth-0.2.1.tar.gz", "has_sig": false, "md5_digest": "cdbac4737f2c31badc81d4fb1798467a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8275, "upload_time": "2011-11-10T12:06:15", "upload_time_iso_8601": "2011-11-10T12:06:15.485399Z", "url": "https://files.pythonhosted.org/packages/dc/27/62cdbbcb8621ccd728a79a1b093f81be505daa30d2896ca3c34c5c6ae3c3/requests-oauth-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "51aa2b9ae0f596405a6ef564c88dd406", "sha256": "e0cbc6ac2a7c1c867b2fc6567d4fb0e3860d682fb8471457d8862292838c0569"}, "downloads": -1, "filename": "requests-oauth-0.2.2.tar.gz", "has_sig": false, "md5_digest": "51aa2b9ae0f596405a6ef564c88dd406", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8352, "upload_time": "2011-11-17T14:03:02", "upload_time_iso_8601": "2011-11-17T14:03:02.647673Z", "url": "https://files.pythonhosted.org/packages/49/5d/db1119336366094f2814295744e16b55aca2eeb80760764381cac9b8e042/requests-oauth-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "c128a07d8668ac4c682bf23de5aac05d", "sha256": "e792ff0fc700472a08257c1154c08e2f815e8777634014f5b11e45c39ee36f12"}, "downloads": -1, "filename": "requests-oauth-0.2.3.tar.gz", "has_sig": false, "md5_digest": "c128a07d8668ac4c682bf23de5aac05d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7836, "upload_time": "2011-11-20T17:52:21", "upload_time_iso_8601": "2011-11-20T17:52:21.235489Z", "url": "https://files.pythonhosted.org/packages/60/dc/7290b5f82cfaf1f8da4c966b0fe21e3bf40d988046f1e360067bf1ef72a7/requests-oauth-0.2.3.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "6ec90068b7a60eebfa5584489a2efa45", "sha256": "a09084eea004c2f734cb133cb4e63cf2ba02b1c85bebba09fdc2f9940839eec5"}, "downloads": -1, "filename": "requests-oauth-0.3.0.tar.gz", "has_sig": false, "md5_digest": "6ec90068b7a60eebfa5584489a2efa45", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8266, "upload_time": "2012-01-13T18:58:14", "upload_time_iso_8601": "2012-01-13T18:58:14.371571Z", "url": "https://files.pythonhosted.org/packages/15/97/742c8eb60d2c6b7cfc6c6eafa12ee5e90237642f169c247632df37febad5/requests-oauth-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "2987d399a78bbe6f17983864bbad9671", "sha256": "988045afd2da963d94bc54270437274962b2d49ee78385b0d02bb5726225c09f"}, "downloads": -1, "filename": "requests-oauth-0.4.0.tar.gz", "has_sig": false, "md5_digest": "2987d399a78bbe6f17983864bbad9671", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8671, "upload_time": "2012-05-16T16:40:59", "upload_time_iso_8601": "2012-05-16T16:40:59.926209Z", "url": "https://files.pythonhosted.org/packages/6d/53/36719778c58e209b933d25b10d11aad436f3e6b884970ba0cde3833bdae1/requests-oauth-0.4.0.tar.gz", "yanked": false}], "0.4.1": [{"comment_text": "", "digests": {"md5": "49636788c3e2d94d9db1c765c90842c5", "sha256": "9c1b0738967ef1c0f6f0eb1ff09a7000499cd07a609ea8f1770b515b953af692"}, "downloads": -1, "filename": "requests-oauth-0.4.1.tar.gz", "has_sig": false, "md5_digest": "49636788c3e2d94d9db1c765c90842c5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9955, "upload_time": "2012-06-21T09:10:36", "upload_time_iso_8601": "2012-06-21T09:10:36.404143Z", "url": "https://files.pythonhosted.org/packages/b5/4c/b333b8ece6d9c59ac7113190a8dda844374d3bbbd3076913607fb2df326d/requests-oauth-0.4.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "49636788c3e2d94d9db1c765c90842c5", "sha256": "9c1b0738967ef1c0f6f0eb1ff09a7000499cd07a609ea8f1770b515b953af692"}, "downloads": -1, "filename": "requests-oauth-0.4.1.tar.gz", "has_sig": false, "md5_digest": "49636788c3e2d94d9db1c765c90842c5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9955, "upload_time": "2012-06-21T09:10:36", "upload_time_iso_8601": "2012-06-21T09:10:36.404143Z", "url": "https://files.pythonhosted.org/packages/b5/4c/b333b8ece6d9c59ac7113190a8dda844374d3bbbd3076913607fb2df326d/requests-oauth-0.4.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:04:03 2020"}