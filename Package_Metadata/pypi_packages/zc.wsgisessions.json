{"info": {"author": "Zope Corporation", "author_email": "info@zope.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Paste", "Framework :: Zope3", "Intended Audience :: Developers", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: WSGI", "Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "****************\nZC WSGI Sessions\n****************\n\nThis is an implementation of persistent sessions as a WSGI middleware\nusing `zope.session` as an underlying mechanism.\n\nTo use it:\n\n1. Add `zc.wsgisessions` to `install_requires` list in `setup.py` of\n   your application (e.g., `myapp`)\n\n2. Add the following to `myapp.ini`::\n\n    [filter:sessions]\n    use = egg:zc.wsgisessions\n\n   You can add to configuration::\n\n    secure = true\n\n   or::\n\n    http-only = off\n\n   Valid words are: `true`, `false`, `on`, `off`, `yes`, `no`, 1, and 0.\n\n   Other options include::\n\n     domain = .example.com\n\n     max-age = 10000\n\n     path = /foo\n\n   You can also specify a database name for session storage::\n\n    db-name = appdb\n\n3. Add `sessions` to the pipeline *after* database middleware, but\n   *before* the application.\n\n4. Add to a function that is listed as `initializer` for the database\n   middleware::\n\n    zc.wsgisessions.sessions.initialize_database(database)\n\n   You can also pass keyword arguments for: `db_name`, `namespace`,\n   `secret`, `timeout`, and `resolution`.\n\n5. Add to a function that is listed as `bobo.configure` (initializer of\n   your WSGI application)::\n\n    zope.component.provideAdapter(zc.wsgisessions.sessions.get_session)\n\n6. You can use some helpers in your authentication code::\n\n    PKG_KEY = __name__  # e.g., myapp.auth\n\n    def get_user(request):\n        return zc.wsgisessions.sessions.get(request, PKG_KEY, 'user')\n\n    def save_user(request, user):\n        zc.wsgisession.sessions.store(request, PKG_KEY, 'user', user)\n\n    def forget_user(request):\n        return zc.wsgisessions.sessions.remove(request, PKG_KEY, 'user')\n\n7. When running `Selenium` tests, `HttpOnly` cookies cannot be used.\n   Set the option ``'http-only': False`` in the `global_conf` dictionary\n   of your testing application.\n\n\n.. See ``src/zc/wsgisessions/sessions.txt`` for details.\n\n\nDetailed Documentation\n**********************\n\n========\nSessions\n========\n\nThere are two aspects to the sessions support: browser identification,\nand session storage.  Browsers are identified using cookies; if the\ncookie isn't set on an incoming request, the response sets it for future\nrequests.\n\nSession data are stored using a persistent session data container, as\ndefined by the ``zope.session`` package.  An instance is added to the\ndatabase at startup if not present.  We can control certain parameters\nby passing keyword arguments to the database initializer.  One run of\nthis test uses the default settings, while a second run sets custom\nparameters.\n\n    >>> import re\n    >>> import zc.wsgisessions.testing\n    >>> import zc.wsgisessions.sessions\n    >>> db_name = 'sessions'\n    >>> if zc.wsgisessions.testing.TEST_DB_INIT:\n    ...     db_name = 'test'\n    ...     db = conn.get_connection(db_name).db()\n    ...     zc.wsgisessions.sessions.initialize_database(\n    ...         db,\n    ...         db_name=db_name,\n    ...         namespace='browserid_c0defeed',\n    ...         secret='0.10612221415937506119',\n    ...         timeout=(15 * 60),  # 15 minutes\n    ...         resolution=60,      #  1 minute\n    ...         )\n\n    >>> dbroot = conn.get_connection(db_name).root()\n    >>> dbroot['sessions']\n    <zope.session.session.PersistentSessionDataContainer object at 0xc0defeed>\n\n    >>> if zc.wsgisessions.testing.TEST_DB_INIT:\n    ...     expected_id = re.compile('browserid_c0defeed')\n    ...     expected_secret = re.compile('0.10612221415937506119')\n    ...     expected_timeout = 15 * 60\n    ...     expected_resolution = 60\n    ... else:\n    ...     expected_id = re.compile('browserid_[0-9a-f]{8}')\n    ...     expected_secret = re.compile('[0-9a-f]{20}')\n    ...     expected_timeout = 24 * 60 * 60\n    ...     expected_resolution = 60 * 60\n    >>> re.match(expected_id, dbroot['browserid_info'][0]) is not None\n    True\n    >>> re.match(expected_secret, dbroot['browserid_info'][1]) is not None\n    True\n    >>> dbroot['sessions'].timeout == expected_timeout\n    True\n    >>> dbroot['sessions'].resolution == expected_resolution\n    True\n\nIf the configuration contains `secure` set to true or if the request is\nhttps, `secure` is added to the Set-Cookie response.  Also `HttpOnly` is\nadded to the Set-Cookie response, unless the configuration sets\n`http-only` to false.\n\n    >>> global_conf = {}\n    >>> filter_conf = {'db-name': db_name}\n    >>> filter = zc.wsgisessions.sessions.BrowserIdFilter(\n    ...     global_conf, **filter_conf)(object())\n    >>> environ = {\n    ...     'zodb.connection': conn.get_connection('test'),\n    ...     'wsgi.url_scheme': 'https'\n    ... }\n    >>> h = dict(filter.prepare(environ, lambda *args: args)(200, [], None)[1])\n    >>> cookie_parts = h['Set-Cookie'].split('; ')\n    >>> 'secure' in cookie_parts\n    True\n    >>> 'HttpOnly' in cookie_parts\n    True\n\nWhen the settings are changed in the filter configuration (in `.ini`\nfile), the defaults are replaced.\n\n    >>> filter_conf.update({'http-only': 'false', 'secure': 'true',\n    ...                     'domain': '.example.com', 'max-age': '5000',\n    ...                     'path': '/foo'})\n    >>> filter = zc.wsgisessions.sessions.BrowserIdFilter(\n    ...     global_conf, **filter_conf)(object())\n    >>> environ['wsgi.url_scheme'] = 'http'\n    >>> h = dict(filter.prepare(environ, lambda *args: args)(200, [], None)[1])\n    >>> cookie_parts = h['Set-Cookie'].split('; ')\n    >>> 'secure' in cookie_parts\n    True\n    >>> 'HttpOnly' in cookie_parts\n    False\n    >>> 'Domain=.example.com' in cookie_parts\n    True\n    >>> 'Max-Age=5000' in cookie_parts\n    True\n    >>> 'Path=/foo' in cookie_parts\n    True\n\nNotice that the URL scheme above was *not* https, but the secure was set\nbecause it was requested in the filter configuration.\n\nFor Selenium testing we need to reset `HttpOnly` and since we are using\nhttp URL scheme in development, the default for `secure` (off) is\nacceptable.  Notice that we are setting `http-only` in global\nconfiguration this time to override the value from the settings in\n`.ini` file.\n\n    >>> global_conf = {'http-only': 'off'}\n    >>> filter_conf = {'db-name': db_name, 'http-only': 'on'}\n    >>> filter = zc.wsgisessions.sessions.BrowserIdFilter(\n    ...     global_conf, **filter_conf)(object())\n    >>> h = dict(filter.prepare(environ, lambda *args: args)(200, [], None)[1])\n    >>> cookie_parts = h['Set-Cookie'].split('; ')\n    >>> 'secure' in cookie_parts\n    False\n    >>> 'HttpOnly' in cookie_parts\n    False\n\nThe database name for session storage is set in `initialize_database` to\n`sessions` by default or to a supplied `db_name` (`test` for the second\nrun of these tests).  If we try to pass a wrong database name to the\nfilter from its configuration (in `.ini` file) we'll get an error.\n\n    >>> if zc.wsgisessions.testing.TEST_DB_INIT:\n    ...     filter_conf['db-name'] = 'sessions'\n    ...     filter = zc.wsgisessions.sessions.BrowserIdFilter(\n    ...         global_conf, **filter_conf)(object())\n    ... else:\n    ...     filter_conf['db-name'] = 'test'\n    ...     filter = zc.wsgisessions.sessions.BrowserIdFilter(\n    ...         global_conf, **filter_conf)(object())\n    >>> h = dict(filter.prepare(environ, lambda *args: args)(200, [], None)[1])\n    Traceback (most recent call last):\n      ...\n    KeyError: 'browserid_info'\n\n\nBrowser identification\n======================\n\nInformation needed to support the cookies is also stored in the\ndatabase:\n\n    >>> dbroot['browserid_info']\n    ('browserid_...', '...')\n\n    >>> cookie_name = dbroot['browserid_info'][0]\n\n    >>> import webtest\n    >>> app = webtest.TestApp(app)\n    >>> response = app.get('http://localhost/')\n\n    >>> cookie_value = app.cookies[cookie_name]\n    >>> len(cookie_value)\n    54\n\nIf we change the secret in the database, we can cause the session\nidentifier to be re-set:\n\n    >>> import random\n    >>> import transaction\n\n    >>> secret = '%.20f' % random.random()\n    >>> dbroot['browserid_info'] = cookie_name, secret\n    >>> transaction.commit()\n\n    >>> response = app.get('http://localhost/')\n\n    >>> cookie_value == app.cookies[cookie_name]\n    False\n\n    >>> cookie_value = app.cookies[cookie_name]\n    >>> app.cookies[cookie_name] = 'bad'\n    >>> response = app.get('http://localhost/')\n\n    >>> cookie_value == app.cookies[cookie_name]\n    False\n\n\nSession storage\n===============\n\nOnce the cookie has been loaded from the request, or arranged to be sent\nwith the response, an ``ISession`` object is stored on the request.\nLet's create one directly so we can see how that works:\n\n    >>> sdc = dbroot['sessions']\n    >>> session = zc.wsgisessions.sessions.Session(cookie_value, sdc)\n\n    >>> pkgdata = session['myapp.auth']\n    >>> pkgdata['mydata'] = 42\n\n    >>> sdc[cookie_value]['myapp.auth']['mydata']\n    42\n\n    >>> list(session)\n    Traceback (most recent call last):\n    ...\n    NotImplementedError\n\n\nHelpers\n=======\n\n    >>> import webob\n    >>> import zc.dbconnection\n    >>> import zope.session.interfaces\n    >>> zc.dbconnection.set_local(conn)\n    >>> environ = {'zc.wsgisessions.session': session}\n    >>> request = webob.Request(environ=environ)\n\n\nget(request, pkg_id, key=None)\n------------------------------\n\nRetrieve a value from the session; if no key is specified, retrieves the\nSessionPkgData container.\n\n    >>> pkgdata = zc.wsgisessions.sessions.get(request, 'myapp.auth')\n    >>> zope.session.interfaces.ISessionPkgData.providedBy(pkgdata)\n    True\n\n    >>> zc.wsgisessions.sessions.get(request, 'myapp.auth', 'blah') is None\n    True\n\n    >>> pkgdata['blah'] = '!!!'\n    >>> zc.wsgisessions.sessions.get(request, 'myapp.auth', 'blah')\n    '!!!'\n\n    >>> zc.wsgisessions.sessions.get(request, 'myapp.auth', 'mydata')\n    42\n\nWhen specifying a pkg identifier and a key name, the session data object\nis not created if it doesn't already exist.\n\n    >>> zc.wsgisessions.sessions.get(request, \"dontcreateme\", \"blah\") is None\n    True\n    >>> adapter = zope.session.interfaces.ISession(request)\n    >>> adapter.get(\"dontcreateme\") is None\n    True\n\n\nstore(request, pkg_id, key, value)\n----------------------------------\n\nStore the key/value pair in the session.\n\n    >>> obj = object()\n    >>> zc.wsgisessions.sessions.store(\n    ...     request, 'myapp.auth', 'someobject', obj)\n    >>> zc.wsgisessions.sessions.get(\n    ...     request, 'myapp.auth', 'someobject') is obj\n    True\n\n    >>> obj = object()\n    >>> zc.wsgisessions.sessions.store(\n    ...     request, 'myapp.data', 'someobject', obj)\n    >>> zc.wsgisessions.sessions.get(\n    ...     request, 'myapp.auth', 'someobject') is obj\n    False\n\n    >>> zc.wsgisessions.sessions.get(\n    ...     request, 'myapp.data', 'someobject') is obj\n    True\n\n\nremove(request, pkg_id, key)\n----------------------------\n\nRemove a value from the session by key.  If pkg_id is not specified,\nthe default pkg_id of zc.wsgisessions.sessions.KEY is used.\n\n    >>> _obj = zc.wsgisessions.sessions.remove(\n    ...     request, 'myapp.auth', 'someobject')\n    >>> zc.wsgisessions.sessions.get(\n    ...     request, 'myapp.auth', 'someobject') is None\n    True\n\n    >>> zc.wsgisessions.sessions.get(\n    ...     request, 'myapp.data', 'someobject') is obj\n    True\n\n    >>> zc.wsgisessions.sessions.remove(\n    ...     request, 'myapp.data', 'someobject') is obj\n    True\n    >>> zc.wsgisessions.sessions.get(\n    ...     request, 'myapp.data', 'someobject') is None\n    True\n\nThe underlying session data mapping is not created if it does not\nalready exist.\n\n    >>> zc.wsgisessions.sessions.remove(\n    ...     request, \"dontcreateme\", \"somekey\") is None\n    True\n    >>> adapter.get(\"dontcreateme\") is None\n    True\n\n\n=======\nCHANGES\n=======\n\n\n0.6.1 (2013-10-08)\n==================\n\n- Include CHANGES.txt in release.\n\n\n0.6.0 (2013-10-08)\n==================\n\n- Add `domain`, `max-age`, and `path` configuration options.\n\n0.5.1 (2013-06-12)\n==================\n\nOpen-source release.\n\n0.5 (2013-03-12)\n================\n\n- Use a cryptographically secure random number source (os.urandom) for\n  generating browser ids.\n- Fix a bug in the get/remove helpers that caused SessionData objects\n  to be created unnecessarily.\n\n0.4 (2012-01-03)\n================\n\n- Accept a database name parameter for session storage.\n\n\n0.3 (2011-11-11)\n================\n\n- Put arguments to helper functions in a more logical order.\n- Require pkg_id to discourage bad use pattern.\n\n\n0.2 (2011-11-10)\n================\n\n- Make http-only and secure configurable.\n- Test configuration options.\n- Test database initialization and options.\n\n\n0.1 (2011-11-10)\n================\n\nInitial release", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": "Zope WSGI session", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "zc.wsgisessions", "package_url": "https://pypi.org/project/zc.wsgisessions/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/zc.wsgisessions/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/zc.wsgisessions/0.6.1/", "requires_dist": null, "requires_python": null, "summary": "ZC WSGI sessions", "version": "0.6.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This is an implementation of persistent sessions as a WSGI middleware\nusing <cite>zope.session</cite> as an underlying mechanism.</p>\n<p>To use it:</p>\n<ol>\n<li><p>Add <cite>zc.wsgisessions</cite> to <cite>install_requires</cite> list in <cite>setup.py</cite> of\nyour application (e.g., <cite>myapp</cite>)</p>\n</li>\n<li><p>Add the following to <cite>myapp.ini</cite>:</p>\n<pre>[filter:sessions]\nuse = egg:zc.wsgisessions\n</pre>\n<p>You can add to configuration:</p>\n<pre>secure = true\n</pre>\n<p>or:</p>\n<pre>http-only = off\n</pre>\n<p>Valid words are: <cite>true</cite>, <cite>false</cite>, <cite>on</cite>, <cite>off</cite>, <cite>yes</cite>, <cite>no</cite>, 1, and 0.</p>\n<p>Other options include:</p>\n<pre>domain = .example.com\n\nmax-age = 10000\n\npath = /foo\n</pre>\n<p>You can also specify a database name for session storage:</p>\n<pre>db-name = appdb\n</pre>\n</li>\n<li><p>Add <cite>sessions</cite> to the pipeline <em>after</em> database middleware, but\n<em>before</em> the application.</p>\n</li>\n<li><p>Add to a function that is listed as <cite>initializer</cite> for the database\nmiddleware:</p>\n<pre>zc.wsgisessions.sessions.initialize_database(database)\n</pre>\n<p>You can also pass keyword arguments for: <cite>db_name</cite>, <cite>namespace</cite>,\n<cite>secret</cite>, <cite>timeout</cite>, and <cite>resolution</cite>.</p>\n</li>\n<li><p>Add to a function that is listed as <cite>bobo.configure</cite> (initializer of\nyour WSGI application):</p>\n<pre>zope.component.provideAdapter(zc.wsgisessions.sessions.get_session)\n</pre>\n</li>\n<li><p>You can use some helpers in your authentication code:</p>\n<pre>PKG_KEY = __name__  # e.g., myapp.auth\n\ndef get_user(request):\n    return zc.wsgisessions.sessions.get(request, PKG_KEY, 'user')\n\ndef save_user(request, user):\n    zc.wsgisession.sessions.store(request, PKG_KEY, 'user', user)\n\ndef forget_user(request):\n    return zc.wsgisessions.sessions.remove(request, PKG_KEY, 'user')\n</pre>\n</li>\n<li><p>When running <cite>Selenium</cite> tests, <cite>HttpOnly</cite> cookies cannot be used.\nSet the option <tt><span class=\"pre\">'http-only':</span> False</tt> in the <cite>global_conf</cite> dictionary\nof your testing application.</p>\n</li>\n</ol>\n<div id=\"detailed-documentation\">\n<h2>Detailed Documentation</h2>\n<div id=\"sessions\">\n<h3>Sessions</h3>\n<p>There are two aspects to the sessions support: browser identification,\nand session storage.  Browsers are identified using cookies; if the\ncookie isn\u2019t set on an incoming request, the response sets it for future\nrequests.</p>\n<p>Session data are stored using a persistent session data container, as\ndefined by the <tt>zope.session</tt> package.  An instance is added to the\ndatabase at startup if not present.  We can control certain parameters\nby passing keyword arguments to the database initializer.  One run of\nthis test uses the default settings, while a second run sets custom\nparameters.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import re\n&gt;&gt;&gt; import zc.wsgisessions.testing\n&gt;&gt;&gt; import zc.wsgisessions.sessions\n&gt;&gt;&gt; db_name = 'sessions'\n&gt;&gt;&gt; if zc.wsgisessions.testing.TEST_DB_INIT:\n...     db_name = 'test'\n...     db = conn.get_connection(db_name).db()\n...     zc.wsgisessions.sessions.initialize_database(\n...         db,\n...         db_name=db_name,\n...         namespace='browserid_c0defeed',\n...         secret='0.10612221415937506119',\n...         timeout=(15 * 60),  # 15 minutes\n...         resolution=60,      #  1 minute\n...         )\n</pre>\n<pre>&gt;&gt;&gt; dbroot = conn.get_connection(db_name).root()\n&gt;&gt;&gt; dbroot['sessions']\n&lt;zope.session.session.PersistentSessionDataContainer object at 0xc0defeed&gt;\n</pre>\n<pre>&gt;&gt;&gt; if zc.wsgisessions.testing.TEST_DB_INIT:\n...     expected_id = re.compile('browserid_c0defeed')\n...     expected_secret = re.compile('0.10612221415937506119')\n...     expected_timeout = 15 * 60\n...     expected_resolution = 60\n... else:\n...     expected_id = re.compile('browserid_[0-9a-f]{8}')\n...     expected_secret = re.compile('[0-9a-f]{20}')\n...     expected_timeout = 24 * 60 * 60\n...     expected_resolution = 60 * 60\n&gt;&gt;&gt; re.match(expected_id, dbroot['browserid_info'][0]) is not None\nTrue\n&gt;&gt;&gt; re.match(expected_secret, dbroot['browserid_info'][1]) is not None\nTrue\n&gt;&gt;&gt; dbroot['sessions'].timeout == expected_timeout\nTrue\n&gt;&gt;&gt; dbroot['sessions'].resolution == expected_resolution\nTrue\n</pre>\n</blockquote>\n<p>If the configuration contains <cite>secure</cite> set to true or if the request is\nhttps, <cite>secure</cite> is added to the Set-Cookie response.  Also <cite>HttpOnly</cite> is\nadded to the Set-Cookie response, unless the configuration sets\n<cite>http-only</cite> to false.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; global_conf = {}\n&gt;&gt;&gt; filter_conf = {'db-name': db_name}\n&gt;&gt;&gt; filter = zc.wsgisessions.sessions.BrowserIdFilter(\n...     global_conf, **filter_conf)(object())\n&gt;&gt;&gt; environ = {\n...     'zodb.connection': conn.get_connection('test'),\n...     'wsgi.url_scheme': 'https'\n... }\n&gt;&gt;&gt; h = dict(filter.prepare(environ, lambda *args: args)(200, [], None)[1])\n&gt;&gt;&gt; cookie_parts = h['Set-Cookie'].split('; ')\n&gt;&gt;&gt; 'secure' in cookie_parts\nTrue\n&gt;&gt;&gt; 'HttpOnly' in cookie_parts\nTrue\n</pre>\n</blockquote>\n<p>When the settings are changed in the filter configuration (in <cite>.ini</cite>\nfile), the defaults are replaced.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; filter_conf.update({'http-only': 'false', 'secure': 'true',\n...                     'domain': '.example.com', 'max-age': '5000',\n...                     'path': '/foo'})\n&gt;&gt;&gt; filter = zc.wsgisessions.sessions.BrowserIdFilter(\n...     global_conf, **filter_conf)(object())\n&gt;&gt;&gt; environ['wsgi.url_scheme'] = 'http'\n&gt;&gt;&gt; h = dict(filter.prepare(environ, lambda *args: args)(200, [], None)[1])\n&gt;&gt;&gt; cookie_parts = h['Set-Cookie'].split('; ')\n&gt;&gt;&gt; 'secure' in cookie_parts\nTrue\n&gt;&gt;&gt; 'HttpOnly' in cookie_parts\nFalse\n&gt;&gt;&gt; 'Domain=.example.com' in cookie_parts\nTrue\n&gt;&gt;&gt; 'Max-Age=5000' in cookie_parts\nTrue\n&gt;&gt;&gt; 'Path=/foo' in cookie_parts\nTrue\n</pre>\n</blockquote>\n<p>Notice that the URL scheme above was <em>not</em> https, but the secure was set\nbecause it was requested in the filter configuration.</p>\n<p>For Selenium testing we need to reset <cite>HttpOnly</cite> and since we are using\nhttp URL scheme in development, the default for <cite>secure</cite> (off) is\nacceptable.  Notice that we are setting <cite>http-only</cite> in global\nconfiguration this time to override the value from the settings in\n<cite>.ini</cite> file.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; global_conf = {'http-only': 'off'}\n&gt;&gt;&gt; filter_conf = {'db-name': db_name, 'http-only': 'on'}\n&gt;&gt;&gt; filter = zc.wsgisessions.sessions.BrowserIdFilter(\n...     global_conf, **filter_conf)(object())\n&gt;&gt;&gt; h = dict(filter.prepare(environ, lambda *args: args)(200, [], None)[1])\n&gt;&gt;&gt; cookie_parts = h['Set-Cookie'].split('; ')\n&gt;&gt;&gt; 'secure' in cookie_parts\nFalse\n&gt;&gt;&gt; 'HttpOnly' in cookie_parts\nFalse\n</pre>\n</blockquote>\n<p>The database name for session storage is set in <cite>initialize_database</cite> to\n<cite>sessions</cite> by default or to a supplied <cite>db_name</cite> (<cite>test</cite> for the second\nrun of these tests).  If we try to pass a wrong database name to the\nfilter from its configuration (in <cite>.ini</cite> file) we\u2019ll get an error.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; if zc.wsgisessions.testing.TEST_DB_INIT:\n...     filter_conf['db-name'] = 'sessions'\n...     filter = zc.wsgisessions.sessions.BrowserIdFilter(\n...         global_conf, **filter_conf)(object())\n... else:\n...     filter_conf['db-name'] = 'test'\n...     filter = zc.wsgisessions.sessions.BrowserIdFilter(\n...         global_conf, **filter_conf)(object())\n&gt;&gt;&gt; h = dict(filter.prepare(environ, lambda *args: args)(200, [], None)[1])\nTraceback (most recent call last):\n  ...\nKeyError: 'browserid_info'\n</pre>\n</blockquote>\n<div id=\"browser-identification\">\n<h4>Browser identification</h4>\n<p>Information needed to support the cookies is also stored in the\ndatabase:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; dbroot['browserid_info']\n('browserid_...', '...')\n</pre>\n<pre>&gt;&gt;&gt; cookie_name = dbroot['browserid_info'][0]\n</pre>\n<pre>&gt;&gt;&gt; import webtest\n&gt;&gt;&gt; app = webtest.TestApp(app)\n&gt;&gt;&gt; response = app.get('http://localhost/')\n</pre>\n<pre>&gt;&gt;&gt; cookie_value = app.cookies[cookie_name]\n&gt;&gt;&gt; len(cookie_value)\n54\n</pre>\n</blockquote>\n<p>If we change the secret in the database, we can cause the session\nidentifier to be re-set:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import random\n&gt;&gt;&gt; import transaction\n</pre>\n<pre>&gt;&gt;&gt; secret = '%.20f' % random.random()\n&gt;&gt;&gt; dbroot['browserid_info'] = cookie_name, secret\n&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; response = app.get('http://localhost/')\n</pre>\n<pre>&gt;&gt;&gt; cookie_value == app.cookies[cookie_name]\nFalse\n</pre>\n<pre>&gt;&gt;&gt; cookie_value = app.cookies[cookie_name]\n&gt;&gt;&gt; app.cookies[cookie_name] = 'bad'\n&gt;&gt;&gt; response = app.get('http://localhost/')\n</pre>\n<pre>&gt;&gt;&gt; cookie_value == app.cookies[cookie_name]\nFalse\n</pre>\n</blockquote>\n</div>\n<div id=\"session-storage\">\n<h4>Session storage</h4>\n<p>Once the cookie has been loaded from the request, or arranged to be sent\nwith the response, an <tt>ISession</tt> object is stored on the request.\nLet\u2019s create one directly so we can see how that works:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sdc = dbroot['sessions']\n&gt;&gt;&gt; session = zc.wsgisessions.sessions.Session(cookie_value, sdc)\n</pre>\n<pre>&gt;&gt;&gt; pkgdata = session['myapp.auth']\n&gt;&gt;&gt; pkgdata['mydata'] = 42\n</pre>\n<pre>&gt;&gt;&gt; sdc[cookie_value]['myapp.auth']['mydata']\n42\n</pre>\n<pre>&gt;&gt;&gt; list(session)\nTraceback (most recent call last):\n...\nNotImplementedError\n</pre>\n</blockquote>\n</div>\n<div id=\"helpers\">\n<h4>Helpers</h4>\n<blockquote>\n<pre>&gt;&gt;&gt; import webob\n&gt;&gt;&gt; import zc.dbconnection\n&gt;&gt;&gt; import zope.session.interfaces\n&gt;&gt;&gt; zc.dbconnection.set_local(conn)\n&gt;&gt;&gt; environ = {'zc.wsgisessions.session': session}\n&gt;&gt;&gt; request = webob.Request(environ=environ)\n</pre>\n</blockquote>\n<div id=\"get-request-pkg-id-key-none\">\n<h5>get(request, pkg_id, key=None)</h5>\n<p>Retrieve a value from the session; if no key is specified, retrieves the\nSessionPkgData container.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pkgdata = zc.wsgisessions.sessions.get(request, 'myapp.auth')\n&gt;&gt;&gt; zope.session.interfaces.ISessionPkgData.providedBy(pkgdata)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; zc.wsgisessions.sessions.get(request, 'myapp.auth', 'blah') is None\nTrue\n</pre>\n<pre>&gt;&gt;&gt; pkgdata['blah'] = '!!!'\n&gt;&gt;&gt; zc.wsgisessions.sessions.get(request, 'myapp.auth', 'blah')\n'!!!'\n</pre>\n<pre>&gt;&gt;&gt; zc.wsgisessions.sessions.get(request, 'myapp.auth', 'mydata')\n42\n</pre>\n</blockquote>\n<p>When specifying a pkg identifier and a key name, the session data object\nis not created if it doesn\u2019t already exist.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zc.wsgisessions.sessions.get(request, \"dontcreateme\", \"blah\") is None\nTrue\n&gt;&gt;&gt; adapter = zope.session.interfaces.ISession(request)\n&gt;&gt;&gt; adapter.get(\"dontcreateme\") is None\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"store-request-pkg-id-key-value\">\n<h5>store(request, pkg_id, key, value)</h5>\n<p>Store the key/value pair in the session.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; obj = object()\n&gt;&gt;&gt; zc.wsgisessions.sessions.store(\n...     request, 'myapp.auth', 'someobject', obj)\n&gt;&gt;&gt; zc.wsgisessions.sessions.get(\n...     request, 'myapp.auth', 'someobject') is obj\nTrue\n</pre>\n<pre>&gt;&gt;&gt; obj = object()\n&gt;&gt;&gt; zc.wsgisessions.sessions.store(\n...     request, 'myapp.data', 'someobject', obj)\n&gt;&gt;&gt; zc.wsgisessions.sessions.get(\n...     request, 'myapp.auth', 'someobject') is obj\nFalse\n</pre>\n<pre>&gt;&gt;&gt; zc.wsgisessions.sessions.get(\n...     request, 'myapp.data', 'someobject') is obj\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"remove-request-pkg-id-key\">\n<h5>remove(request, pkg_id, key)</h5>\n<p>Remove a value from the session by key.  If pkg_id is not specified,\nthe default pkg_id of zc.wsgisessions.sessions.KEY is used.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; _obj = zc.wsgisessions.sessions.remove(\n...     request, 'myapp.auth', 'someobject')\n&gt;&gt;&gt; zc.wsgisessions.sessions.get(\n...     request, 'myapp.auth', 'someobject') is None\nTrue\n</pre>\n<pre>&gt;&gt;&gt; zc.wsgisessions.sessions.get(\n...     request, 'myapp.data', 'someobject') is obj\nTrue\n</pre>\n<pre>&gt;&gt;&gt; zc.wsgisessions.sessions.remove(\n...     request, 'myapp.data', 'someobject') is obj\nTrue\n&gt;&gt;&gt; zc.wsgisessions.sessions.get(\n...     request, 'myapp.data', 'someobject') is None\nTrue\n</pre>\n</blockquote>\n<p>The underlying session data mapping is not created if it does not\nalready exist.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zc.wsgisessions.sessions.remove(\n...     request, \"dontcreateme\", \"somekey\") is None\nTrue\n&gt;&gt;&gt; adapter.get(\"dontcreateme\") is None\nTrue\n</pre>\n</blockquote>\n</div>\n</div>\n</div>\n<div id=\"changes\">\n<h3>CHANGES</h3>\n<div id=\"id1\">\n<h4>0.6.1 (2013-10-08)</h4>\n<ul>\n<li>Include CHANGES.txt in release.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h4>0.6.0 (2013-10-08)</h4>\n<ul>\n<li>Add <cite>domain</cite>, <cite>max-age</cite>, and <cite>path</cite> configuration options.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h4>0.5.1 (2013-06-12)</h4>\n<p>Open-source release.</p>\n</div>\n<div id=\"id4\">\n<h4>0.5 (2013-03-12)</h4>\n<ul>\n<li>Use a cryptographically secure random number source (os.urandom) for\ngenerating browser ids.</li>\n<li>Fix a bug in the get/remove helpers that caused SessionData objects\nto be created unnecessarily.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h4>0.4 (2012-01-03)</h4>\n<ul>\n<li>Accept a database name parameter for session storage.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h4>0.3 (2011-11-11)</h4>\n<ul>\n<li>Put arguments to helper functions in a more logical order.</li>\n<li>Require pkg_id to discourage bad use pattern.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h4>0.2 (2011-11-10)</h4>\n<ul>\n<li>Make http-only and secure configurable.</li>\n<li>Test configuration options.</li>\n<li>Test database initialization and options.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h4>0.1 (2011-11-10)</h4>\n<p>Initial release</p>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 884477, "releases": {"0.5.1": [{"comment_text": "", "digests": {"md5": "42bb9dca633977a53a22f2597622e077", "sha256": "b62b1921b0ee6f064ca1bfc81fa6d96c5f2556fc31bbab2d1d371856cdbec9cb"}, "downloads": -1, "filename": "zc.wsgisessions-0.5.1.tar.gz", "has_sig": false, "md5_digest": "42bb9dca633977a53a22f2597622e077", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26707, "upload_time": "2013-06-13T00:46:13", "upload_time_iso_8601": "2013-06-13T00:46:13.025045Z", "url": "https://files.pythonhosted.org/packages/81/65/69d5b6a3e76280c705b4b8bfde927d9ab76e3f5820924615bedf906cbec2/zc.wsgisessions-0.5.1.tar.gz", "yanked": false}], "0.6.1": []}, "urls": [], "timestamp": "Fri May  8 03:18:52 2020"}