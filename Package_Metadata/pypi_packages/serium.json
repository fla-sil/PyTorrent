{"info": {"author": "Harel Ben-Attia", "author_email": "harelba@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 2 :: Only", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "serium\n======\n\nA serialization library that inherently provides resiliency to data\nstructure evolution over time.\n\nThis kind of resiliency is achieved by providing case classes that are\ninherently serializable in a way that preserves version information, and\nseamlessly migrating old data structures on-the-fly while performing\ndeserialization.\n\nThe approach that this library takes towards data structure evolution is\ndifferent than many other serialization formats. Instead of defining\nevolution at the protocol-level (e.g.\u00a0adding new fields which might be\nempty, deprecating fields, converting types, etc.), it defines evolution\nat the domain-level. Developers explicitly define conversion functions\nbetween versions, and the infrastructure uses these functions in order\nto provide the application code with the current version of each object.\nThis approach allows to change the data structures according to real\nbussiness/development needs, and not be limited to protocol-level\nchanges.\n\nA related concept to this approach is that the codebase itself acts as\nthe \u201cschema repository\u201d, holding the structures of all \u201clive versions\u201d.\nThis, combined with the conversion functions, allows to manage the\nevolution of the data using standard code tools and practices.\n\nThis initial implementation of the library is in python, which is\ndynamically typed. This required creating full support for strictly\ntyped case classes, a feature which in other languages might have been\nprovided by the language itself.\n\nMain Features\n-------------\n\n-  Strictly typed, immutable, nested case classes (including recursive\n   definitions)\n-  Support for case class version management and powerful schema\n   evolution inside the codebase\n-  Inherent serialization capabilities (currently json only)\n-  On-the-fly data migration on read\n-  Support for subtypes - A method for mimicking inheritance in\n   serialized data. Supertype can contain a \u201cselector field\u201d which\n   denotes the actual type of another field, fully integrating with the\n   version management capabilities of the library.\n\nDesign assumptions\n------------------\n\n-  CPU/Memory is cheaper than developer time and time-to-market of new\n   features\n-  Decoupling feature release from any maintenance/migration work is a\n   good thing\n-  Logical evolution of the data strcutures is required in many real\n   world use cases\n-  The codebase and the programming language can serve as an accurate\n   \u201cdistributed schema repository\u201d, taking advantage of standard code\n   management tools\n-  In many cases, the migration logic is relatively simple, and the cost\n   of applying it during read (cpu+latency) is worth it if it means less\n   roadblocks to production\n\nDue to these design assumptions, the library is currently optimized\nmainly for ease of development and iteration, and for decoupling between\nthe developer\u2019s work and devops work. Obviously, once the concepts\nstabilize enough, speed/space optimizations will get into focus.\n\nFuture plans\n------------\n\n-  At least one strictly-typed implementation (e.g.\u00a0Scala)\n-  Other serialization formats\n-  Higher-level types (e.g.\u00a0url, phone-number, etc.)\n-  Higher-level constraints on the data as part of the type definitions\n   (e.g.\u00a0valid-url, positive-value, not-empty, in-range, etc.)\n-  Dynamic search scope of subtypes\n-  Create IDL or reuse existing IDL such as protobuf\n-  Typed enums (currently just regular strings)\n-  Typed timestamps (currently just ints or longs)\n-  Less verbose syntax\n\nLibrary Status\n==============\n\nWhile already being used in one production setting, the library is still\nconsidered to be in alpha status. Any feedback regarding the concept and\nthe direction this needs to take will be greatly appreciated.\n\nInstallation\n============\n\n``pip install serium``\n\nExamples\n========\n\nBasic Example\n-------------\n\n.. code:: python\n\n    # BASIC_EXAMPLE_START\n\n    from collections import OrderedDict\n    from uuid import uuid4\n\n    from serium.caseclasses import CaseClass, cc_to_json_str, cc_from_json_str\n    from serium.caseclasses import SeriumEnv, CaseClassSerializationContext, CaseClassDeserializationContext, CaseClassJsonSerialization\n    from serium.types import cc_list, cc_uuid\n\n\n    # Let's define the first case class.\n\n    # In order to define a case class, just create a basic value-object class definition, \n    # accepting all parameters in the constructor. There are three things to note here:\n    # 1. The class should inherit from CaseClass\n    # 2. There is a static field called CC_TYPES. This is an ordered dict between field names \n    #    and types. This is a placeholder for a full fledged IDL which will exist in the future \n    #    (or reuse existing serialization format IDLs).\n    #    Also, when we provide implementations for statically typed languages, the language's\n    #    type system will be used\n    # 3. There's another static field called CC_V which denotes the version of the class. \n    #    For now it's just 1 (and essentially could have been omitted).\n    class Author(CaseClass):\n        CC_TYPES = OrderedDict([\n            ('author_id', int),\n            ('name', unicode)\n        ])\n        CC_V = 1\n\n        def __init__(self, author_id, name):\n            self.author_id = author_id\n            self.name = name\n\n\n    # Now let's create another class called Book. Two things to note here:\n    # 1. The book_id field is of type cc_uuid. This is essentially a UUID field that the system \n    #    knows how to serialize and deserialize into strings. More about it later\n    # 2. The author field is of type Author - The case class we've defined above.\n    class Book(CaseClass):\n        CC_TYPES = OrderedDict([\n            ('book_id', cc_uuid),\n            ('title', unicode),\n            ('author', Author)\n        ])\n        CC_V = 1\n\n        def __init__(self, book_id, title, author):\n            self.book_id = book_id\n            self.title = title\n            self.author = author\n\n\n    # Let's create an instance of Author\n    a = Author(500, u'Amos Oz')\n    # and an instance of book. Notice that it gets a as the author field. We won't show it \n    # here, but passing the wrong types when creating an instance would throw an exception\n    b = Book(uuid4(), u'A tale of Love and Darkness', a)\n\n    # Now let's serialize the book to a json string.\n    serialized_book = cc_to_json_str(b)\n    print serialized_book\n    '''\n    {\"title\": \"A tale of Love and Darkness\", \"_ccvt\": \"Book/1\", \"book_id\": \"e3cb81c0-6555-45e6-8615-85fae4729bf1\", \"author\": {\"author_id\": 500, \"name\": \"Amos Oz\", \"_ccvt\": \"Author/1\"}}\n    '''\n\n    # You can notice two things:\n    # * There's a field called _ccvt in each level, storing the \"versioned type\" of the instance. \n    #   This will allow automatic migration, as we'll see later on. Notice that that library \n    #   can provide \"pure serialization of case classes\" as well, to support writing/sending \n    #   to legacy systems. See SeriumEnv in the docs for details.\n    # * The book_id has been serialized into a string. This is accomplished by the cc_uuid type, \n    #   which essentially states that this is a UUID value when in memory, but has a string \n    #   representation when serialized.\n\n    # Let's deserialize this string back into an object\n    new_book_instance = cc_from_json_str(serialized_book, Book)\n    print new_book_instance\n    '''\n    Book(book_id=UUID('c9814b3f-fea0-4494-a828-0d66b50336c1'),title=u'A tale of Love and Darkness',\n         author=Author(author_id=500,name=u'Amos Oz'))\n    '''\n\n    # The variable new_book_instance now contains a Book instance with the proper info. \n    # Notice that book_id is a UUID again, and that author has been deserialized into an object as well.\n\n    # One last thing to notice is that the string representation of the case classes is \"executable\". \n    # This means that you can copy-paste the output as code, and recreate the relevant object.\n\n    ## Immutability\n\n    # Case classes are immutable, meaning that once created, you cannot change any of the fields, \n    # or recreate new fields. Trying to do so will cause an exception. In order to modify an \n    # instance, use the copy() method on the case class, and pass keyword arguments with the \n    # new values\n    modified_book = b.copy(title=u'A new title')\n    print modified_book\n    '''\n    Book(book_id=UUID('f0115f3b-d8e8-4424-97bd-6541323b3427'),title=u'A new title',\n         author=Author(author_id=500,name=u'Amos Oz'))\n    '''\n\n\n    # BASIC_EXAMPLE_END\n\nData Migration Example\n----------------------\n\n.. code:: python\n\n    # DATA_MIGRATION_EXAMPLE_START\n\n    # Let's assume that we're storing this (and other similar) jsons somewhere over time.\n\n    # Now let's say that at some point, we've decided to support multiple authors per book.\n    # In order to do that, we need to do the following:\n\n    # 1. Rename the Book case class so it becomes Book__v1\n    class Book__v1(CaseClass):\n        CC_TYPES = OrderedDict([\n            ('book_id', cc_uuid),\n            ('title', unicode),\n            ('author', Author)\n        ])\n        CC_V = 1\n\n        def __init__(self, book_id, title, author):\n            self.book_id = book_id\n            self.title = title\n            self.author = author\n\n\n    # 2. Create a new Book class, with the modified structure. We'll explain the changes below.\n    class Book(CaseClass):\n        CC_TYPES = OrderedDict([\n            ('book_id', cc_uuid),\n            ('title', unicode),\n            ('authors', cc_list(Author))\n        ])\n        CC_V = 2\n        CC_MIGRATIONS = {\n            1: lambda old: Book(book_id=old.book_id, title=old.title, authors=[old.author] if old.author is not None else [])\n        }\n\n        def __init__(self, book_id, title, authors):\n            self.book_id = book_id\n            self.title = title\n            self.authors = authors\n\n\n    # So, several things to notice in the modified Book definition:\n    # 1. The CC_V field has changed to 2\n    # 2. The field is now named \"authors\" to reflect the fact that it's a list\n    # 3. The type of the field is now a list of authors (cc_list(t) just means a list of \n    #    elements of type t)\n    # 4. We've added a \"migration definition\" through the CC_MIGRATIONS dictionary. This \n    #    dictionary is a mapping between a source version (1 in this case) and a function \n    #    which gets an old instance and returns a new one after conversion. In this case, \n    #    we're taking the old author and just put it in the new \"author\" field as a single \n    #    element inside a list.\n    # 5. We haven't touched the Author class itself\n\n    # The rest of the code is totally unaware of the Book__v1 class - The application code \n    # continues to use the Book class only, expecting multiple authors per customer.\n\n    # So, what happens when we read an old serialized Book? Let's take the serialized book \n    # we had before (assume it's been stored somewhere):\n    some_old_serialized_book = '''\n    {\n      \"_ccvt\": \"Book/1\",\n      \"author\": {\n        \"_ccvt\": \"Author/1\",\n        \"author_id\": 500,\n        \"name\": \"Amos Oz\"\n      },\n      \"book_id\": \"1f028cef-0540-4c98-b8f6-c55a3c324c44\",\n      \"title\": \"A tale of Love and Darkness\"\n    }\n    '''\n\n    # And deserialize this string into a Book. Notice that the cc_from_json_str takes a \n    # second argument saying we expect a Book instance:\n    deserialized_book = cc_from_json_str(some_old_serialized_book, Book)\n    # This is the newly constructed book instance:\n    print deserialized_book\n    '''\n    Book(book_id=UUID('1f028cef-0540-4c98-b8f6-c55a3c324c44'),title=u'A tale of Love and Darkness',\n         authors=[Author(author_id=500,name=u'Amos Oz')])\n    '''\n\n    # Notice that it has an authors field containing the previous 'author' value of the old \n    # book instance. This means that it's a version 2 book. When the deserialization happened, \n    # the library detected the fact that we're reading an old customer instance, and \n    # automatically migrated it to a version 2 customer on-the-fly, before returning the \n    # deserialized object. If there existed multiple versions, the library would find the \n    # shortest migration path automatically, performing multiple successive migrations as \n    # needed in order to provide the app with a proper \"current\" Customer instance.\n\n    # It's important to note that this kind of auto-migration happens behind the scenes on \n    # each object level separately. For example, if we created a version-2 Author as well, \n    # the auto-migration for it would have been performed on-the-fly as well, providing the\n    # app with a version-2 book with a version-2 author inside it.\n\n    # This demonstrates one of the main concepts behind this library - Being able to \n    # explicitly provide the migration logic on a per object basis, while hiding the burden \n    # of managing the versioning from most of the application code.\n\n    # Another important concept is the fact that the on-the-fly migration allows to decouple \n    # the release of a new feature from the database/storage migration phase. Even in cases \n    # where a complete data migration would be necessary, it's would still be possible to\n    # release the feature early, and perform the complete migration in some other time, or \n    # incrementally, without hurting the delivery schedules.\n\n    # DATA_MIGRATION_EXAMPLE_END\n\nFiner control over serialization using SeriumEnv\n------------------------------------------------\n\n.. code:: python\n\n    # USING_SERIUM_ENV_EXAMPLE_START\n\n    # Let's see how we can modify the behaviour of serium by using a SeriumEnv. In this \n    # example, we'll just make the json serialization more pretty:\n    from serium.caseclasses import cc_pretty_json_serialization, cc_compact_json_serialization\n    env = SeriumEnv(CaseClassSerializationContext(), CaseClassDeserializationContext(), cc_pretty_json_serialization)\n\n    # (cc_pretty_json_serialization is just a shortcut for specifying a CaseClassJsonSerialization() \n    #  instance with some standard json-module parameters. You can just create your own instance\n    #  any parameters you'd like). \n    # There's also a cc_compact_json_serialization which provides a standard compact json\n    # presentation.\n\n    # Now let's use the env we created in order to serialize the original book instance b:\n    print env.cc_to_json_str(b)\n    '''\n    {\n      \"_ccvt\": \"Book/1\",\n      \"author\": {\n        \"_ccvt\": \"Author/1\",\n        \"author_id\": 500,\n        \"name\": \"Amos Oz\"\n      },\n      \"book_id\": \"c56675d3-10e0-42e9-af9a-b8462c4e1104\",\n      \"title\": \"A tale of Love and Darkness\"\n    }\n    '''\n\n    # CaseClassSerializationContext and CaseClassDeserializationContext contain additional\n    # parameters that can control the ser/de process, mostly related to supporting writing\n    # to and reading from other systems which do not support versioning. See the docs\n    # for details on each of the params.\n\n    # USING_SERIUM_ENV_EXAMPLE_END\n\nReference for case class definitions\n====================================\n\nBasic structure for defining a case class\n-----------------------------------------\n\n.. code:: python\n\n    class MyClass(CaseClass):\n        CC_TYPES = OrderedDict([ <pairs of field-name/field-type> ])\n        CC_V = <version>\n        CC_MIGRATIONS = {\n            <old-version-number>: lambda old: <construct a new MyClass using old>,\n            ...\n        }\n        def __init__(self,<field-names>):\n            self.field_name1 = field_name1\n            ...\n\nSupported types\n---------------\n\n.. code:: python\n\n        from serium.types import cc_self_type, cc_list, cc_dict, cc_decimal, cc_uuid\n        ...\n        CC_TYPES = OrderedDict([\n            ('my_int',int),\n            ('my_long',long),\n            ('my_float',float),\n            ('my_bool',bool),\n            ('my_str',str), \n            ('my_unicode',unicode), \n            ('my_uuid',cc_uuid),\n            ('my_decimal',cc_decimal),\n            ('my_raw_dict',dict),\n            ('my_list_of_ints',cc_list(int)),\n            ('my_typed_dict',cc_dict(str,int)),\n            ('my_sibling_node',cc_self_type),\n            ('my_type_as_string',cc_type_as_string(t)),  # Assumes t is a type which can serialize itself to string using str() and deserialize itself from string using a one-parameter constructor. For example, cc_uuid is actualy cc_type_as_string(UUID).\n            ('my_other_case_class',<case-class-name>)\n        ])\n\nBasic conversion to/from dict\n-----------------------------\n\n-  ``cc_to_dict(x)`` - Convert case class instance ``x`` to a dictionary\n-  ``cc_from_dict(d,cc_type)`` - Convert dict ``d`` back into a case\n   class of type ``cc_type``\n\nBasic conversion to/from json string\n------------------------------------\n\n-  ``cc_to_json_str(x)`` - Conver case class instance ``x`` to a json\n   string\n-  ``cc_from_json_str(s, cc_type)`` - Convert json string ``s`` back\n   into a case class instance of type ``cc_type``\n\nSimple type checking\n--------------------\n\n-  ``cc_check(x, cc_type)`` - Throws an exception if case class instance\n   x is not of type ``cc_type``\n\nAdvanced serialization and deserialization control\n--------------------------------------------------\n\nThe module-level functions in ``serium.caseclasses`` provide a simple\nout-of-the-box experience, with several behaviour defaults regarding\ncontrolling the serde process. When you need more control over these,\nyou can create a ``SeriumEnv`` instance and run the same functions\ndefined above, as methods of this instance. Here\u2019s an example:\n\n.. code:: python\n\n    from serium.caseclasses import SeriumEnv\n\n    env = SeriumEnv(...)\n\n    env.cc_from_dict(...)\n    env.cc_to_json_str(...) \n\nSeriumEnv gets three parameters:\n\n-  ``serialization_ctx`` - An instance of\n   ``CaseClassSerializationContext``. Params:\n\n   -  ``force_unversioned_serialization`` - A boolean flag. When true,\n      the serialized output will be plain - It will not include\n      versioning info. This can be used in order to send data to\n      external systems, for example, which cann\u2019t tolerate extra fields.\n      Default to False, meaning that output will include versioning\n      info.\n\n-  ``deserialization_ctx`` - An instance of\n   ``CaseClassDeserializationContext``. Params:\n\n   -  ``fail_on_unversioned_data`` - A boolean, defaults to True, which\n      means that if there\u2019s no version information in the serialized\n      data, an exception will be thrown. If set to False, the \u201ccurrent\n      version\u201d case class will be used in order to attempt to\n      deserialize the data without errors.\n   -  ``fail_on_incompatible_types`` - A boolean, defaults to True. When\n      set to False, the deserializer will attempt to forcefully\n      deserialize a non-matching type into the requested type. This will\n      succeed only if both types happen to share the same field names\n      and types\n   -  ``external_version_provider_func`` - A function ``f(cc_type, d)``\n      where cc_type is a case class type, and d is a dictionary. The\n      function should return a version number for the relevant params.\n      This allows to effectively inject specific versions during\n      deserialization, whenever they don\u2019t exist in the data itself\n      (e.g.\u00a0data from external system, initial migration to this\n      library, etc.).\n   -  ``fail_on_null_subtypes`` - A boolean denoting whether or not to\n      fail on deserialization if a subtype value field is null. Defaults\n      to False, meaning that null values for subtype object is allowed.\n\nBuilding\n========\n\nRun ``make init`` after initial checkout.\n\nRun ``make create-doc`` to compile docs/README.md into README.rst (Don\u2019t\nforget to checkin the rst file afterwards). The rst file content becomes\nthe pypi long description for the package.\n\nRun ``make test`` to run tests.\n\nRun ``make prepare-dist`` to Prepare the distribution packages. Make\nsure to change the versions in setup.py before doing it.\n\nRun ``make upload-to-testpypy`` to upload to the *test* pypi repository.\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/harelba/serium/archive/0.1.10.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/harelba/serium", "keywords": "serium case-classes serialization data-migration data-structures strict-typing schema-evolution schema", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "serium", "package_url": "https://pypi.org/project/serium/", "platform": "", "project_url": "https://pypi.org/project/serium/", "project_urls": {"Download": "https://github.com/harelba/serium/archive/0.1.10.tar.gz", "Homepage": "https://github.com/harelba/serium"}, "release_url": "https://pypi.org/project/serium/0.1.10/", "requires_dist": ["pytest; extra == 'dev'", "pytest; extra == 'test'"], "requires_python": ">=2.6,<3", "summary": "Sustainable case-class serialization library", "version": "0.1.10", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"serium\">\n<h2>serium</h2>\n<p>A serialization library that inherently provides resiliency to data\nstructure evolution over time.</p>\n<p>This kind of resiliency is achieved by providing case classes that are\ninherently serializable in a way that preserves version information, and\nseamlessly migrating old data structures on-the-fly while performing\ndeserialization.</p>\n<p>The approach that this library takes towards data structure evolution is\ndifferent than many other serialization formats. Instead of defining\nevolution at the protocol-level (e.g.\u00a0adding new fields which might be\nempty, deprecating fields, converting types, etc.), it defines evolution\nat the domain-level. Developers explicitly define conversion functions\nbetween versions, and the infrastructure uses these functions in order\nto provide the application code with the current version of each object.\nThis approach allows to change the data structures according to real\nbussiness/development needs, and not be limited to protocol-level\nchanges.</p>\n<p>A related concept to this approach is that the codebase itself acts as\nthe \u201cschema repository\u201d, holding the structures of all \u201clive versions\u201d.\nThis, combined with the conversion functions, allows to manage the\nevolution of the data using standard code tools and practices.</p>\n<p>This initial implementation of the library is in python, which is\ndynamically typed. This required creating full support for strictly\ntyped case classes, a feature which in other languages might have been\nprovided by the language itself.</p>\n<div id=\"main-features\">\n<h3>Main Features</h3>\n<ul>\n<li>Strictly typed, immutable, nested case classes (including recursive\ndefinitions)</li>\n<li>Support for case class version management and powerful schema\nevolution inside the codebase</li>\n<li>Inherent serialization capabilities (currently json only)</li>\n<li>On-the-fly data migration on read</li>\n<li>Support for subtypes - A method for mimicking inheritance in\nserialized data. Supertype can contain a \u201cselector field\u201d which\ndenotes the actual type of another field, fully integrating with the\nversion management capabilities of the library.</li>\n</ul>\n</div>\n<div id=\"design-assumptions\">\n<h3>Design assumptions</h3>\n<ul>\n<li>CPU/Memory is cheaper than developer time and time-to-market of new\nfeatures</li>\n<li>Decoupling feature release from any maintenance/migration work is a\ngood thing</li>\n<li>Logical evolution of the data strcutures is required in many real\nworld use cases</li>\n<li>The codebase and the programming language can serve as an accurate\n\u201cdistributed schema repository\u201d, taking advantage of standard code\nmanagement tools</li>\n<li>In many cases, the migration logic is relatively simple, and the cost\nof applying it during read (cpu+latency) is worth it if it means less\nroadblocks to production</li>\n</ul>\n<p>Due to these design assumptions, the library is currently optimized\nmainly for ease of development and iteration, and for decoupling between\nthe developer\u2019s work and devops work. Obviously, once the concepts\nstabilize enough, speed/space optimizations will get into focus.</p>\n</div>\n<div id=\"future-plans\">\n<h3>Future plans</h3>\n<ul>\n<li>At least one strictly-typed implementation (e.g.\u00a0Scala)</li>\n<li>Other serialization formats</li>\n<li>Higher-level types (e.g.\u00a0url, phone-number, etc.)</li>\n<li>Higher-level constraints on the data as part of the type definitions\n(e.g.\u00a0valid-url, positive-value, not-empty, in-range, etc.)</li>\n<li>Dynamic search scope of subtypes</li>\n<li>Create IDL or reuse existing IDL such as protobuf</li>\n<li>Typed enums (currently just regular strings)</li>\n<li>Typed timestamps (currently just ints or longs)</li>\n<li>Less verbose syntax</li>\n</ul>\n</div>\n</div>\n<div id=\"library-status\">\n<h2>Library Status</h2>\n<p>While already being used in one production setting, the library is still\nconsidered to be in alpha status. Any feedback regarding the concept and\nthe direction this needs to take will be greatly appreciated.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p><tt>pip install serium</tt></p>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<div id=\"basic-example\">\n<h3>Basic Example</h3>\n<pre><span class=\"c1\"># BASIC_EXAMPLE_START</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">collections</span> <span class=\"kn\">import</span> <span class=\"n\">OrderedDict</span>\n<span class=\"kn\">from</span> <span class=\"nn\">uuid</span> <span class=\"kn\">import</span> <span class=\"n\">uuid4</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">serium.caseclasses</span> <span class=\"kn\">import</span> <span class=\"n\">CaseClass</span><span class=\"p\">,</span> <span class=\"n\">cc_to_json_str</span><span class=\"p\">,</span> <span class=\"n\">cc_from_json_str</span>\n<span class=\"kn\">from</span> <span class=\"nn\">serium.caseclasses</span> <span class=\"kn\">import</span> <span class=\"n\">SeriumEnv</span><span class=\"p\">,</span> <span class=\"n\">CaseClassSerializationContext</span><span class=\"p\">,</span> <span class=\"n\">CaseClassDeserializationContext</span><span class=\"p\">,</span> <span class=\"n\">CaseClassJsonSerialization</span>\n<span class=\"kn\">from</span> <span class=\"nn\">serium.types</span> <span class=\"kn\">import</span> <span class=\"n\">cc_list</span><span class=\"p\">,</span> <span class=\"n\">cc_uuid</span>\n\n\n<span class=\"c1\"># Let's define the first case class.</span>\n\n<span class=\"c1\"># In order to define a case class, just create a basic value-object class definition,</span>\n<span class=\"c1\"># accepting all parameters in the constructor. There are three things to note here:</span>\n<span class=\"c1\"># 1. The class should inherit from CaseClass</span>\n<span class=\"c1\"># 2. There is a static field called CC_TYPES. This is an ordered dict between field names</span>\n<span class=\"c1\">#    and types. This is a placeholder for a full fledged IDL which will exist in the future</span>\n<span class=\"c1\">#    (or reuse existing serialization format IDLs).</span>\n<span class=\"c1\">#    Also, when we provide implementations for statically typed languages, the language's</span>\n<span class=\"c1\">#    type system will be used</span>\n<span class=\"c1\"># 3. There's another static field called CC_V which denotes the version of the class.</span>\n<span class=\"c1\">#    For now it's just 1 (and essentially could have been omitted).</span>\n<span class=\"k\">class</span> <span class=\"nc\">Author</span><span class=\"p\">(</span><span class=\"n\">CaseClass</span><span class=\"p\">):</span>\n    <span class=\"n\">CC_TYPES</span> <span class=\"o\">=</span> <span class=\"n\">OrderedDict</span><span class=\"p\">([</span>\n        <span class=\"p\">(</span><span class=\"s1\">'author_id'</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"s1\">'name'</span><span class=\"p\">,</span> <span class=\"n\">unicode</span><span class=\"p\">)</span>\n    <span class=\"p\">])</span>\n    <span class=\"n\">CC_V</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">author_id</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">author_id</span> <span class=\"o\">=</span> <span class=\"n\">author_id</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n\n\n<span class=\"c1\"># Now let's create another class called Book. Two things to note here:</span>\n<span class=\"c1\"># 1. The book_id field is of type cc_uuid. This is essentially a UUID field that the system</span>\n<span class=\"c1\">#    knows how to serialize and deserialize into strings. More about it later</span>\n<span class=\"c1\"># 2. The author field is of type Author - The case class we've defined above.</span>\n<span class=\"k\">class</span> <span class=\"nc\">Book</span><span class=\"p\">(</span><span class=\"n\">CaseClass</span><span class=\"p\">):</span>\n    <span class=\"n\">CC_TYPES</span> <span class=\"o\">=</span> <span class=\"n\">OrderedDict</span><span class=\"p\">([</span>\n        <span class=\"p\">(</span><span class=\"s1\">'book_id'</span><span class=\"p\">,</span> <span class=\"n\">cc_uuid</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"s1\">'title'</span><span class=\"p\">,</span> <span class=\"n\">unicode</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"s1\">'author'</span><span class=\"p\">,</span> <span class=\"n\">Author</span><span class=\"p\">)</span>\n    <span class=\"p\">])</span>\n    <span class=\"n\">CC_V</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">book_id</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"p\">,</span> <span class=\"n\">author</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">book_id</span> <span class=\"o\">=</span> <span class=\"n\">book_id</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"n\">title</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">author</span> <span class=\"o\">=</span> <span class=\"n\">author</span>\n\n\n<span class=\"c1\"># Let's create an instance of Author</span>\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">Author</span><span class=\"p\">(</span><span class=\"mi\">500</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'Amos Oz'</span><span class=\"p\">)</span>\n<span class=\"c1\"># and an instance of book. Notice that it gets a as the author field. We won't show it</span>\n<span class=\"c1\"># here, but passing the wrong types when creating an instance would throw an exception</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Book</span><span class=\"p\">(</span><span class=\"n\">uuid4</span><span class=\"p\">(),</span> <span class=\"sa\">u</span><span class=\"s1\">'A tale of Love and Darkness'</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Now let's serialize the book to a json string.</span>\n<span class=\"n\">serialized_book</span> <span class=\"o\">=</span> <span class=\"n\">cc_to_json_str</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span> <span class=\"n\">serialized_book</span>\n<span class=\"sd\">'''\n{\"title\": \"A tale of Love and Darkness\", \"_ccvt\": \"Book/1\", \"book_id\": \"e3cb81c0-6555-45e6-8615-85fae4729bf1\", \"author\": {\"author_id\": 500, \"name\": \"Amos Oz\", \"_ccvt\": \"Author/1\"}}\n'''</span>\n\n<span class=\"c1\"># You can notice two things:</span>\n<span class=\"c1\"># * There's a field called _ccvt in each level, storing the \"versioned type\" of the instance.</span>\n<span class=\"c1\">#   This will allow automatic migration, as we'll see later on. Notice that that library</span>\n<span class=\"c1\">#   can provide \"pure serialization of case classes\" as well, to support writing/sending</span>\n<span class=\"c1\">#   to legacy systems. See SeriumEnv in the docs for details.</span>\n<span class=\"c1\"># * The book_id has been serialized into a string. This is accomplished by the cc_uuid type,</span>\n<span class=\"c1\">#   which essentially states that this is a UUID value when in memory, but has a string</span>\n<span class=\"c1\">#   representation when serialized.</span>\n\n<span class=\"c1\"># Let's deserialize this string back into an object</span>\n<span class=\"n\">new_book_instance</span> <span class=\"o\">=</span> <span class=\"n\">cc_from_json_str</span><span class=\"p\">(</span><span class=\"n\">serialized_book</span><span class=\"p\">,</span> <span class=\"n\">Book</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span> <span class=\"n\">new_book_instance</span>\n<span class=\"sd\">'''\nBook(book_id=UUID('c9814b3f-fea0-4494-a828-0d66b50336c1'),title=u'A tale of Love and Darkness',\n     author=Author(author_id=500,name=u'Amos Oz'))\n'''</span>\n\n<span class=\"c1\"># The variable new_book_instance now contains a Book instance with the proper info.</span>\n<span class=\"c1\"># Notice that book_id is a UUID again, and that author has been deserialized into an object as well.</span>\n\n<span class=\"c1\"># One last thing to notice is that the string representation of the case classes is \"executable\".</span>\n<span class=\"c1\"># This means that you can copy-paste the output as code, and recreate the relevant object.</span>\n\n<span class=\"c1\">## Immutability</span>\n\n<span class=\"c1\"># Case classes are immutable, meaning that once created, you cannot change any of the fields,</span>\n<span class=\"c1\"># or recreate new fields. Trying to do so will cause an exception. In order to modify an</span>\n<span class=\"c1\"># instance, use the copy() method on the case class, and pass keyword arguments with the</span>\n<span class=\"c1\"># new values</span>\n<span class=\"n\">modified_book</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"n\">title</span><span class=\"o\">=</span><span class=\"sa\">u</span><span class=\"s1\">'A new title'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span> <span class=\"n\">modified_book</span>\n<span class=\"sd\">'''\nBook(book_id=UUID('f0115f3b-d8e8-4424-97bd-6541323b3427'),title=u'A new title',\n     author=Author(author_id=500,name=u'Amos Oz'))\n'''</span>\n\n\n<span class=\"c1\"># BASIC_EXAMPLE_END</span>\n</pre>\n</div>\n<div id=\"data-migration-example\">\n<h3>Data Migration Example</h3>\n<pre><span class=\"c1\"># DATA_MIGRATION_EXAMPLE_START</span>\n\n<span class=\"c1\"># Let's assume that we're storing this (and other similar) jsons somewhere over time.</span>\n\n<span class=\"c1\"># Now let's say that at some point, we've decided to support multiple authors per book.</span>\n<span class=\"c1\"># In order to do that, we need to do the following:</span>\n\n<span class=\"c1\"># 1. Rename the Book case class so it becomes Book__v1</span>\n<span class=\"k\">class</span> <span class=\"nc\">Book__v1</span><span class=\"p\">(</span><span class=\"n\">CaseClass</span><span class=\"p\">):</span>\n    <span class=\"n\">CC_TYPES</span> <span class=\"o\">=</span> <span class=\"n\">OrderedDict</span><span class=\"p\">([</span>\n        <span class=\"p\">(</span><span class=\"s1\">'book_id'</span><span class=\"p\">,</span> <span class=\"n\">cc_uuid</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"s1\">'title'</span><span class=\"p\">,</span> <span class=\"n\">unicode</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"s1\">'author'</span><span class=\"p\">,</span> <span class=\"n\">Author</span><span class=\"p\">)</span>\n    <span class=\"p\">])</span>\n    <span class=\"n\">CC_V</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">book_id</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"p\">,</span> <span class=\"n\">author</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">book_id</span> <span class=\"o\">=</span> <span class=\"n\">book_id</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"n\">title</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">author</span> <span class=\"o\">=</span> <span class=\"n\">author</span>\n\n\n<span class=\"c1\"># 2. Create a new Book class, with the modified structure. We'll explain the changes below.</span>\n<span class=\"k\">class</span> <span class=\"nc\">Book</span><span class=\"p\">(</span><span class=\"n\">CaseClass</span><span class=\"p\">):</span>\n    <span class=\"n\">CC_TYPES</span> <span class=\"o\">=</span> <span class=\"n\">OrderedDict</span><span class=\"p\">([</span>\n        <span class=\"p\">(</span><span class=\"s1\">'book_id'</span><span class=\"p\">,</span> <span class=\"n\">cc_uuid</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"s1\">'title'</span><span class=\"p\">,</span> <span class=\"n\">unicode</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"s1\">'authors'</span><span class=\"p\">,</span> <span class=\"n\">cc_list</span><span class=\"p\">(</span><span class=\"n\">Author</span><span class=\"p\">))</span>\n    <span class=\"p\">])</span>\n    <span class=\"n\">CC_V</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n    <span class=\"n\">CC_MIGRATIONS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"k\">lambda</span> <span class=\"n\">old</span><span class=\"p\">:</span> <span class=\"n\">Book</span><span class=\"p\">(</span><span class=\"n\">book_id</span><span class=\"o\">=</span><span class=\"n\">old</span><span class=\"o\">.</span><span class=\"n\">book_id</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"n\">old</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"p\">,</span> <span class=\"n\">authors</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">old</span><span class=\"o\">.</span><span class=\"n\">author</span><span class=\"p\">]</span> <span class=\"k\">if</span> <span class=\"n\">old</span><span class=\"o\">.</span><span class=\"n\">author</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span> <span class=\"k\">else</span> <span class=\"p\">[])</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">book_id</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"p\">,</span> <span class=\"n\">authors</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">book_id</span> <span class=\"o\">=</span> <span class=\"n\">book_id</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"n\">title</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">authors</span> <span class=\"o\">=</span> <span class=\"n\">authors</span>\n\n\n<span class=\"c1\"># So, several things to notice in the modified Book definition:</span>\n<span class=\"c1\"># 1. The CC_V field has changed to 2</span>\n<span class=\"c1\"># 2. The field is now named \"authors\" to reflect the fact that it's a list</span>\n<span class=\"c1\"># 3. The type of the field is now a list of authors (cc_list(t) just means a list of</span>\n<span class=\"c1\">#    elements of type t)</span>\n<span class=\"c1\"># 4. We've added a \"migration definition\" through the CC_MIGRATIONS dictionary. This</span>\n<span class=\"c1\">#    dictionary is a mapping between a source version (1 in this case) and a function</span>\n<span class=\"c1\">#    which gets an old instance and returns a new one after conversion. In this case,</span>\n<span class=\"c1\">#    we're taking the old author and just put it in the new \"author\" field as a single</span>\n<span class=\"c1\">#    element inside a list.</span>\n<span class=\"c1\"># 5. We haven't touched the Author class itself</span>\n\n<span class=\"c1\"># The rest of the code is totally unaware of the Book__v1 class - The application code</span>\n<span class=\"c1\"># continues to use the Book class only, expecting multiple authors per customer.</span>\n\n<span class=\"c1\"># So, what happens when we read an old serialized Book? Let's take the serialized book</span>\n<span class=\"c1\"># we had before (assume it's been stored somewhere):</span>\n<span class=\"n\">some_old_serialized_book</span> <span class=\"o\">=</span> <span class=\"s1\">'''\n{\n  \"_ccvt\": \"Book/1\",\n  \"author\": {\n    \"_ccvt\": \"Author/1\",\n    \"author_id\": 500,\n    \"name\": \"Amos Oz\"\n  },\n  \"book_id\": \"1f028cef-0540-4c98-b8f6-c55a3c324c44\",\n  \"title\": \"A tale of Love and Darkness\"\n}\n'''</span>\n\n<span class=\"c1\"># And deserialize this string into a Book. Notice that the cc_from_json_str takes a</span>\n<span class=\"c1\"># second argument saying we expect a Book instance:</span>\n<span class=\"n\">deserialized_book</span> <span class=\"o\">=</span> <span class=\"n\">cc_from_json_str</span><span class=\"p\">(</span><span class=\"n\">some_old_serialized_book</span><span class=\"p\">,</span> <span class=\"n\">Book</span><span class=\"p\">)</span>\n<span class=\"c1\"># This is the newly constructed book instance:</span>\n<span class=\"nb\">print</span> <span class=\"n\">deserialized_book</span>\n<span class=\"sd\">'''\nBook(book_id=UUID('1f028cef-0540-4c98-b8f6-c55a3c324c44'),title=u'A tale of Love and Darkness',\n     authors=[Author(author_id=500,name=u'Amos Oz')])\n'''</span>\n\n<span class=\"c1\"># Notice that it has an authors field containing the previous 'author' value of the old</span>\n<span class=\"c1\"># book instance. This means that it's a version 2 book. When the deserialization happened,</span>\n<span class=\"c1\"># the library detected the fact that we're reading an old customer instance, and</span>\n<span class=\"c1\"># automatically migrated it to a version 2 customer on-the-fly, before returning the</span>\n<span class=\"c1\"># deserialized object. If there existed multiple versions, the library would find the</span>\n<span class=\"c1\"># shortest migration path automatically, performing multiple successive migrations as</span>\n<span class=\"c1\"># needed in order to provide the app with a proper \"current\" Customer instance.</span>\n\n<span class=\"c1\"># It's important to note that this kind of auto-migration happens behind the scenes on</span>\n<span class=\"c1\"># each object level separately. For example, if we created a version-2 Author as well,</span>\n<span class=\"c1\"># the auto-migration for it would have been performed on-the-fly as well, providing the</span>\n<span class=\"c1\"># app with a version-2 book with a version-2 author inside it.</span>\n\n<span class=\"c1\"># This demonstrates one of the main concepts behind this library - Being able to</span>\n<span class=\"c1\"># explicitly provide the migration logic on a per object basis, while hiding the burden</span>\n<span class=\"c1\"># of managing the versioning from most of the application code.</span>\n\n<span class=\"c1\"># Another important concept is the fact that the on-the-fly migration allows to decouple</span>\n<span class=\"c1\"># the release of a new feature from the database/storage migration phase. Even in cases</span>\n<span class=\"c1\"># where a complete data migration would be necessary, it's would still be possible to</span>\n<span class=\"c1\"># release the feature early, and perform the complete migration in some other time, or</span>\n<span class=\"c1\"># incrementally, without hurting the delivery schedules.</span>\n\n<span class=\"c1\"># DATA_MIGRATION_EXAMPLE_END</span>\n</pre>\n</div>\n<div id=\"finer-control-over-serialization-using-seriumenv\">\n<h3>Finer control over serialization using SeriumEnv</h3>\n<pre><span class=\"c1\"># USING_SERIUM_ENV_EXAMPLE_START</span>\n\n<span class=\"c1\"># Let's see how we can modify the behaviour of serium by using a SeriumEnv. In this</span>\n<span class=\"c1\"># example, we'll just make the json serialization more pretty:</span>\n<span class=\"kn\">from</span> <span class=\"nn\">serium.caseclasses</span> <span class=\"kn\">import</span> <span class=\"n\">cc_pretty_json_serialization</span><span class=\"p\">,</span> <span class=\"n\">cc_compact_json_serialization</span>\n<span class=\"n\">env</span> <span class=\"o\">=</span> <span class=\"n\">SeriumEnv</span><span class=\"p\">(</span><span class=\"n\">CaseClassSerializationContext</span><span class=\"p\">(),</span> <span class=\"n\">CaseClassDeserializationContext</span><span class=\"p\">(),</span> <span class=\"n\">cc_pretty_json_serialization</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># (cc_pretty_json_serialization is just a shortcut for specifying a CaseClassJsonSerialization()</span>\n<span class=\"c1\">#  instance with some standard json-module parameters. You can just create your own instance</span>\n<span class=\"c1\">#  any parameters you'd like).</span>\n<span class=\"c1\"># There's also a cc_compact_json_serialization which provides a standard compact json</span>\n<span class=\"c1\"># presentation.</span>\n\n<span class=\"c1\"># Now let's use the env we created in order to serialize the original book instance b:</span>\n<span class=\"nb\">print</span> <span class=\"n\">env</span><span class=\"o\">.</span><span class=\"n\">cc_to_json_str</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"sd\">'''\n{\n  \"_ccvt\": \"Book/1\",\n  \"author\": {\n    \"_ccvt\": \"Author/1\",\n    \"author_id\": 500,\n    \"name\": \"Amos Oz\"\n  },\n  \"book_id\": \"c56675d3-10e0-42e9-af9a-b8462c4e1104\",\n  \"title\": \"A tale of Love and Darkness\"\n}\n'''</span>\n\n<span class=\"c1\"># CaseClassSerializationContext and CaseClassDeserializationContext contain additional</span>\n<span class=\"c1\"># parameters that can control the ser/de process, mostly related to supporting writing</span>\n<span class=\"c1\"># to and reading from other systems which do not support versioning. See the docs</span>\n<span class=\"c1\"># for details on each of the params.</span>\n\n<span class=\"c1\"># USING_SERIUM_ENV_EXAMPLE_END</span>\n</pre>\n</div>\n</div>\n<div id=\"reference-for-case-class-definitions\">\n<h2>Reference for case class definitions</h2>\n<div id=\"basic-structure-for-defining-a-case-class\">\n<h3>Basic structure for defining a case class</h3>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyClass</span><span class=\"p\">(</span><span class=\"n\">CaseClass</span><span class=\"p\">):</span>\n    <span class=\"n\">CC_TYPES</span> <span class=\"o\">=</span> <span class=\"n\">OrderedDict</span><span class=\"p\">([</span> <span class=\"o\">&lt;</span><span class=\"n\">pairs</span> <span class=\"n\">of</span> <span class=\"n\">field</span><span class=\"o\">-</span><span class=\"n\">name</span><span class=\"o\">/</span><span class=\"n\">field</span><span class=\"o\">-</span><span class=\"nb\">type</span><span class=\"o\">&gt;</span> <span class=\"p\">])</span>\n    <span class=\"n\">CC_V</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">version</span><span class=\"o\">&gt;</span>\n    <span class=\"n\">CC_MIGRATIONS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"o\">&lt;</span><span class=\"n\">old</span><span class=\"o\">-</span><span class=\"n\">version</span><span class=\"o\">-</span><span class=\"n\">number</span><span class=\"o\">&gt;</span><span class=\"p\">:</span> <span class=\"k\">lambda</span> <span class=\"n\">old</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">construct</span> <span class=\"n\">a</span> <span class=\"n\">new</span> <span class=\"n\">MyClass</span> <span class=\"n\">using</span> <span class=\"n\">old</span><span class=\"o\">&gt;</span><span class=\"p\">,</span>\n        <span class=\"o\">...</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"o\">&lt;</span><span class=\"n\">field</span><span class=\"o\">-</span><span class=\"n\">names</span><span class=\"o\">&gt;</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">field_name1</span> <span class=\"o\">=</span> <span class=\"n\">field_name1</span>\n        <span class=\"o\">...</span>\n</pre>\n</div>\n<div id=\"supported-types\">\n<h3>Supported types</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">serium.types</span> <span class=\"kn\">import</span> <span class=\"n\">cc_self_type</span><span class=\"p\">,</span> <span class=\"n\">cc_list</span><span class=\"p\">,</span> <span class=\"n\">cc_dict</span><span class=\"p\">,</span> <span class=\"n\">cc_decimal</span><span class=\"p\">,</span> <span class=\"n\">cc_uuid</span>\n<span class=\"o\">...</span>\n<span class=\"n\">CC_TYPES</span> <span class=\"o\">=</span> <span class=\"n\">OrderedDict</span><span class=\"p\">([</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_int'</span><span class=\"p\">,</span><span class=\"nb\">int</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_long'</span><span class=\"p\">,</span><span class=\"n\">long</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_float'</span><span class=\"p\">,</span><span class=\"nb\">float</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_bool'</span><span class=\"p\">,</span><span class=\"nb\">bool</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_str'</span><span class=\"p\">,</span><span class=\"nb\">str</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_unicode'</span><span class=\"p\">,</span><span class=\"n\">unicode</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_uuid'</span><span class=\"p\">,</span><span class=\"n\">cc_uuid</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_decimal'</span><span class=\"p\">,</span><span class=\"n\">cc_decimal</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_raw_dict'</span><span class=\"p\">,</span><span class=\"nb\">dict</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_list_of_ints'</span><span class=\"p\">,</span><span class=\"n\">cc_list</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">)),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_typed_dict'</span><span class=\"p\">,</span><span class=\"n\">cc_dict</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">,</span><span class=\"nb\">int</span><span class=\"p\">)),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_sibling_node'</span><span class=\"p\">,</span><span class=\"n\">cc_self_type</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_type_as_string'</span><span class=\"p\">,</span><span class=\"n\">cc_type_as_string</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)),</span>  <span class=\"c1\"># Assumes t is a type which can serialize itself to string using str() and deserialize itself from string using a one-parameter constructor. For example, cc_uuid is actualy cc_type_as_string(UUID).</span>\n    <span class=\"p\">(</span><span class=\"s1\">'my_other_case_class'</span><span class=\"p\">,</span><span class=\"o\">&lt;</span><span class=\"n\">case</span><span class=\"o\">-</span><span class=\"n\">class</span><span class=\"o\">-</span><span class=\"n\">name</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n<span class=\"p\">])</span>\n</pre>\n</div>\n<div id=\"basic-conversion-to-from-dict\">\n<h3>Basic conversion to/from dict</h3>\n<ul>\n<li><tt>cc_to_dict(x)</tt> - Convert case class instance <tt>x</tt> to a dictionary</li>\n<li><tt>cc_from_dict(d,cc_type)</tt> - Convert dict <tt>d</tt> back into a case\nclass of type <tt>cc_type</tt></li>\n</ul>\n</div>\n<div id=\"basic-conversion-to-from-json-string\">\n<h3>Basic conversion to/from json string</h3>\n<ul>\n<li><tt>cc_to_json_str(x)</tt> - Conver case class instance <tt>x</tt> to a json\nstring</li>\n<li><tt>cc_from_json_str(s, cc_type)</tt> - Convert json string <tt>s</tt> back\ninto a case class instance of type <tt>cc_type</tt></li>\n</ul>\n</div>\n<div id=\"simple-type-checking\">\n<h3>Simple type checking</h3>\n<ul>\n<li><tt>cc_check(x, cc_type)</tt> - Throws an exception if case class instance\nx is not of type <tt>cc_type</tt></li>\n</ul>\n</div>\n<div id=\"advanced-serialization-and-deserialization-control\">\n<h3>Advanced serialization and deserialization control</h3>\n<p>The module-level functions in <tt>serium.caseclasses</tt> provide a simple\nout-of-the-box experience, with several behaviour defaults regarding\ncontrolling the serde process. When you need more control over these,\nyou can create a <tt>SeriumEnv</tt> instance and run the same functions\ndefined above, as methods of this instance. Here\u2019s an example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">serium.caseclasses</span> <span class=\"kn\">import</span> <span class=\"n\">SeriumEnv</span>\n\n<span class=\"n\">env</span> <span class=\"o\">=</span> <span class=\"n\">SeriumEnv</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"n\">env</span><span class=\"o\">.</span><span class=\"n\">cc_from_dict</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"n\">env</span><span class=\"o\">.</span><span class=\"n\">cc_to_json_str</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>SeriumEnv gets three parameters:</p>\n<ul>\n<li><tt>serialization_ctx</tt> - An instance of\n<tt>CaseClassSerializationContext</tt>. Params:<ul>\n<li><tt>force_unversioned_serialization</tt> - A boolean flag. When true,\nthe serialized output will be plain - It will not include\nversioning info. This can be used in order to send data to\nexternal systems, for example, which cann\u2019t tolerate extra fields.\nDefault to False, meaning that output will include versioning\ninfo.</li>\n</ul>\n</li>\n<li><tt>deserialization_ctx</tt> - An instance of\n<tt>CaseClassDeserializationContext</tt>. Params:<ul>\n<li><tt>fail_on_unversioned_data</tt> - A boolean, defaults to True, which\nmeans that if there\u2019s no version information in the serialized\ndata, an exception will be thrown. If set to False, the \u201ccurrent\nversion\u201d case class will be used in order to attempt to\ndeserialize the data without errors.</li>\n<li><tt>fail_on_incompatible_types</tt> - A boolean, defaults to True. When\nset to False, the deserializer will attempt to forcefully\ndeserialize a non-matching type into the requested type. This will\nsucceed only if both types happen to share the same field names\nand types</li>\n<li><tt>external_version_provider_func</tt> - A function <tt>f(cc_type, d)</tt>\nwhere cc_type is a case class type, and d is a dictionary. The\nfunction should return a version number for the relevant params.\nThis allows to effectively inject specific versions during\ndeserialization, whenever they don\u2019t exist in the data itself\n(e.g.\u00a0data from external system, initial migration to this\nlibrary, etc.).</li>\n<li><tt>fail_on_null_subtypes</tt> - A boolean denoting whether or not to\nfail on deserialization if a subtype value field is null. Defaults\nto False, meaning that null values for subtype object is allowed.</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"building\">\n<h2>Building</h2>\n<p>Run <tt>make init</tt> after initial checkout.</p>\n<p>Run <tt>make <span class=\"pre\">create-doc</span></tt> to compile docs/README.md into README.rst (Don\u2019t\nforget to checkin the rst file afterwards). The rst file content becomes\nthe pypi long description for the package.</p>\n<p>Run <tt>make test</tt> to run tests.</p>\n<p>Run <tt>make <span class=\"pre\">prepare-dist</span></tt> to Prepare the distribution packages. Make\nsure to change the versions in setup.py before doing it.</p>\n<p>Run <tt>make <span class=\"pre\">upload-to-testpypy</span></tt> to upload to the <em>test</em> pypi repository.</p>\n</div>\n\n          </div>"}, "last_serial": 3335937, "releases": {"0.1.10": [{"comment_text": "", "digests": {"md5": "49527c7182267b0395d8202cb2449a3f", "sha256": "6046a58d1f019ec3c7ec3e83c61c0bf13e15b54dbfb5e25fb68b3c5af67267b1"}, "downloads": -1, "filename": "serium-0.1.10-py2-none-any.whl", "has_sig": false, "md5_digest": "49527c7182267b0395d8202cb2449a3f", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=2.6,<3", "size": 24175, "upload_time": "2017-11-15T16:57:05", "upload_time_iso_8601": "2017-11-15T16:57:05.773316Z", "url": "https://files.pythonhosted.org/packages/10/5e/31876ace4050b9c6cd6cc6d8a0a548d4d3bde81520a05b07aa9d08fa4741/serium-0.1.10-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "981f6e465fccc8c986ab7c66c187e121", "sha256": "ecc78a5cc3e8ecddb4f570ef776666950d3f75d26bf91eb3deb565468944840e"}, "downloads": -1, "filename": "serium-0.1.10.tar.gz", "has_sig": false, "md5_digest": "981f6e465fccc8c986ab7c66c187e121", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6,<3", "size": 23834, "upload_time": "2017-11-15T16:57:07", "upload_time_iso_8601": "2017-11-15T16:57:07.144997Z", "url": "https://files.pythonhosted.org/packages/fd/7c/f768b534a8f79397e296d0767e9653030d8a2b246ba2f4b6104ebc97cd61/serium-0.1.10.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "49527c7182267b0395d8202cb2449a3f", "sha256": "6046a58d1f019ec3c7ec3e83c61c0bf13e15b54dbfb5e25fb68b3c5af67267b1"}, "downloads": -1, "filename": "serium-0.1.10-py2-none-any.whl", "has_sig": false, "md5_digest": "49527c7182267b0395d8202cb2449a3f", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=2.6,<3", "size": 24175, "upload_time": "2017-11-15T16:57:05", "upload_time_iso_8601": "2017-11-15T16:57:05.773316Z", "url": "https://files.pythonhosted.org/packages/10/5e/31876ace4050b9c6cd6cc6d8a0a548d4d3bde81520a05b07aa9d08fa4741/serium-0.1.10-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "981f6e465fccc8c986ab7c66c187e121", "sha256": "ecc78a5cc3e8ecddb4f570ef776666950d3f75d26bf91eb3deb565468944840e"}, "downloads": -1, "filename": "serium-0.1.10.tar.gz", "has_sig": false, "md5_digest": "981f6e465fccc8c986ab7c66c187e121", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.6,<3", "size": 23834, "upload_time": "2017-11-15T16:57:07", "upload_time_iso_8601": "2017-11-15T16:57:07.144997Z", "url": "https://files.pythonhosted.org/packages/fd/7c/f768b534a8f79397e296d0767e9653030d8a2b246ba2f4b6104ebc97cd61/serium-0.1.10.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:09 2020"}