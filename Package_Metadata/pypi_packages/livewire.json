{"info": {"author": "Tom Christie", "author_email": "tom@tomchristie.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Internet :: WWW/HTTP"], "description": "# HTTPCore\n\n<a href=\"https://travis-ci.org/encode/httpcore\">\n    <img src=\"https://travis-ci.org/encode/httpcore.svg?branch=master\" alt=\"Build Status\">\n</a>\n<a href=\"https://codecov.io/gh/encode/httpcore\">\n    <img src=\"https://codecov.io/gh/encode/httpcore/branch/master/graph/badge.svg\" alt=\"Coverage\">\n</a>\n<a href=\"https://pypi.org/project/httpcore/\">\n    <img src=\"https://badge.fury.io/py/httpcore.svg\" alt=\"Package version\">\n</a>\n\n## Feature support\n\n* `HTTP/2` and `HTTP/1.1` support.\n* `async`/`await` support for non-blocking HTTP requests.\n* Strict timeouts everywhere by default.\n* Fully type annotated.\n* 100% test coverage.\n\nPlus all the standard features of requests...\n\n* International Domains and URLs\n* Keep-Alive & Connection Pooling\n* Sessions with Cookie Persistence\n* Browser-style SSL Verification\n* Basic/Digest Authentication *TODO - We have Basic, but not Digest yet.*\n* Elegant Key/Value Cookies\n* Automatic Decompression\n* Automatic Content Decoding\n* Unicode Response Bodies\n* Multipart File Uploads *TODO - Request content currently supports URL encoded data, JSON, bytes, or async byte iterators.*\n* HTTP(S) Proxy Support *TODO*\n* Connection Timeouts\n* Streaming Downloads\n* .netrc Support *TODO*\n* Chunked Requests\n\n## Usage\n\nMaking a request:\n\n```python\n>>> import httpcore\n>>> client = httpcore.Client()\n>>> response = client.get('https://example.com')\n>>> response.status_code\n<HTTPStatus.OK: 200>\n>>> response.protocol\n'HTTP/2'\n>>> response.text\n'<!doctype html>\\n<html>\\n<head>\\n<title>Example Domain</title>\\n...'\n```\n\nAlternatively, async requests:\n\n**Note**: Use `ipython` to try this from the console, since it supports `await`.\n\n```python\n>>> import httpcore\n>>> client = httpcore.AsyncClient()\n>>> response = await client.get('https://example.com')\n>>> response.status_code\n<StatusCode.OK: 200>\n>>> response.protocol\n'HTTP/2'\n>>> response.text\n'<!doctype html>\\n<html>\\n<head>\\n<title>Example Domain</title>\\n...'\n```\n\n---\n\n## Dependencies\n\n* `h2` - HTTP/2 support.\n* `h11` - HTTP/1.1 support.\n* `certifi` - SSL certificates.\n* `chardet` - Fallback auto-detection for response encoding.\n* `idna` - Internationalized domain name support.\n* `rfc3986` - URL parsing & normalization.\n* `brotlipy` - Decoding for \"brotli\" compressed responses. *(Optional)*\n\nA huge amount of credit is due to `requests` for the API layout that\nmuch of this work follows, as well as to `urllib3` for plenty of design\ninspiration around the lower level networking details.\n\n---\n\n## API Reference\n\n### `Client`\n\n*An HTTP client, with connection pooling, redirects, cookie persistence, etc.*\n\n```python\n>>> client = Client()\n>>> response = client.get('https://example.org')\n```\n\n* `def __init__([auth], [cookies], [verify], [cert], [timeout], [pool_limits], [max_redirects], [dispatch])`\n* `def .request(method, url, [data], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .get(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .options(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .head(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .post(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .put(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .patch(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .delete(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .prepare_request(request)`\n* `def .send(request, [stream], [allow_redirects], [verify], [cert], [timeout])`\n* `def .close()`\n\n### `Response`\n\n*An HTTP response.*\n\n* `def __init__(...)`\n* `.status_code` - **int** *(Typically a `StatusCode` IntEnum.)*\n* `.reason_phrase` - **str**\n* `.protocol` - `\"HTTP/2\"` or `\"HTTP/1.1\"`\n* `.url` - **URL**\n* `.headers` - **Headers**\n* `.content` - **bytes**\n* `.text` - **str**\n* `.encoding` - **str**\n* `.is_redirect` - **bool**\n* `.request` - **Request**\n* `.cookies` - **Cookies**\n* `.history` - **List[Response]**\n* `def .raise_for_status()` - **None**\n* `def .json()` - **Any**\n* `def .read()` - **bytes**\n* `def .stream()` - **bytes iterator**\n* `def .raw()` - **bytes iterator**\n* `def .close()` - **None**\n* `def .next()` - **Response**\n\n### `Request`\n\n*An HTTP request. Can be constructed explicitly for more control over exactly\nwhat gets sent over the wire.*\n\n```python\n>>> request = Request(\"GET\", \"https://example.org\", headers={'host': 'example.org'})\n>>> response = client.send(request)\n```\n\n* `def __init__(method, url, [params], [data], [json], [headers], [cookies])`\n* `.method` - **str**\n* `.url` - **URL**\n* `.content` - **byte** or **byte async iterator**\n* `.headers` - **Headers**\n* `.cookies` - **Cookies**\n\n### `URL`\n\n*A normalized, IDNA supporting URL.*\n\n```python\n>>> url = URL(\"https://example.org/\")\n>>> url.host\n'example.org'\n```\n\n* `def __init__(url, allow_relative=False, params=None)`\n* `.scheme` - **str**\n* `.authority` - **str**\n* `.host` - **str**\n* `.port` - **int**\n* `.path` - **str**\n* `.query` - **str**\n* `.full_path` - **str**\n* `.fragment` - **str**\n* `.is_ssl` - **bool**\n* `.origin` - **Origin**\n* `.is_absolute_url` - **bool**\n* `.is_relative_url` - **bool**\n* `def .copy_with([scheme], [authority], [path], [query], [fragment])` - **URL**\n* `def .resolve_with(url)` - **URL**\n\n### `Origin`\n\n*A normalized, IDNA supporting set of scheme/host/port info.*\n\n```python\n>>> Origin('https://example.org') == Origin('HTTPS://EXAMPLE.ORG:443')\nTrue\n```\n\n* `def __init__(url)`\n* `.is_ssl` - **bool**\n* `.host` - **str**\n* `.port` - **int**\n\n### `Headers`\n\n*A case-insensitive multi-dict.*\n\n```python\n>>> headers = Headers({'Content-Type': 'application/json'})\n>>> headers['content-type']\n'application/json'\n```\n\n* `def __init__(self, headers)`\n\n### `Cookies`\n\n*A dict-like cookie store.*\n\n```python\n>>> cookies = Cookies()\n>>> cookies.set(\"name\", \"value\", domain=\"example.org\")\n```\n\n* `def __init__(cookies: [dict, Cookies, CookieJar])`\n* `.jar` - **CookieJar**\n* `def extract_cookies(response)`\n* `def set_cookie_header(request)`\n* `def set(name, value, [domain], [path])`\n* `def get(name, [domain], [path])`\n* `def delete(name, [domain], [path])`\n* `def clear([domain], [path])`\n* *Standard mutable mapping interface*\n\n___\n\n## Alternate backends\n\n### `AsyncClient`\n\nAn asyncio client.\n\n### `TrioClient`\n\n*TODO*\n\n---\n\n## The Stack\n\nThere are two main layers in the stack. The client handles redirection,\ncookie persistence (TODO), and authentication (TODO). The dispatcher\nhandles sending the actual request and getting the response.\n\n* `Client` - Redirect, authentication, cookies etc.\n* `ConnectionPool(Dispatcher)` - Connection pooling & keep alive.\n  * `HTTPConnection` - A single connection.\n    * `HTTP11Connection` - A single HTTP/1.1 connection.\n    * `HTTP2Connection` - A single HTTP/2 connection, with multiple streams.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/encode/livewire", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "livewire", "package_url": "https://pypi.org/project/livewire/", "platform": "", "project_url": "https://pypi.org/project/livewire/", "project_urls": {"Homepage": "https://github.com/encode/livewire"}, "release_url": "https://pypi.org/project/livewire/0.0.0/", "requires_dist": null, "requires_python": ">=3.6", "summary": "...", "version": "0.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>HTTPCore</h1>\n<a href=\"https://travis-ci.org/encode/httpcore\" rel=\"nofollow\">\n    <img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/22a77d7457883c0ef49aef4ee0e74ab7548c4002/68747470733a2f2f7472617669732d63692e6f72672f656e636f64652f68747470636f72652e7376673f6272616e63683d6d6173746572\">\n</a>\n<a href=\"https://codecov.io/gh/encode/httpcore\" rel=\"nofollow\">\n    <img alt=\"Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/27de70bbf19a80cd87a942ee135adecd9f15ca72/68747470733a2f2f636f6465636f762e696f2f67682f656e636f64652f68747470636f72652f6272616e63682f6d61737465722f67726170682f62616467652e737667\">\n</a>\n<a href=\"https://pypi.org/project/httpcore/\" rel=\"nofollow\">\n    <img alt=\"Package version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2296c21a237fd63f8a8c678959c9819d9ecea14b/68747470733a2f2f62616467652e667572792e696f2f70792f68747470636f72652e737667\">\n</a>\n<h2>Feature support</h2>\n<ul>\n<li><code>HTTP/2</code> and <code>HTTP/1.1</code> support.</li>\n<li><code>async</code>/<code>await</code> support for non-blocking HTTP requests.</li>\n<li>Strict timeouts everywhere by default.</li>\n<li>Fully type annotated.</li>\n<li>100% test coverage.</li>\n</ul>\n<p>Plus all the standard features of requests...</p>\n<ul>\n<li>International Domains and URLs</li>\n<li>Keep-Alive &amp; Connection Pooling</li>\n<li>Sessions with Cookie Persistence</li>\n<li>Browser-style SSL Verification</li>\n<li>Basic/Digest Authentication <em>TODO - We have Basic, but not Digest yet.</em></li>\n<li>Elegant Key/Value Cookies</li>\n<li>Automatic Decompression</li>\n<li>Automatic Content Decoding</li>\n<li>Unicode Response Bodies</li>\n<li>Multipart File Uploads <em>TODO - Request content currently supports URL encoded data, JSON, bytes, or async byte iterators.</em></li>\n<li>HTTP(S) Proxy Support <em>TODO</em></li>\n<li>Connection Timeouts</li>\n<li>Streaming Downloads</li>\n<li>.netrc Support <em>TODO</em></li>\n<li>Chunked Requests</li>\n</ul>\n<h2>Usage</h2>\n<p>Making a request:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">httpcore</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">httpcore</span><span class=\"o\">.</span><span class=\"n\">Client</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'https://example.com'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">status_code</span>\n<span class=\"o\">&lt;</span><span class=\"n\">HTTPStatus</span><span class=\"o\">.</span><span class=\"n\">OK</span><span class=\"p\">:</span> <span class=\"mi\">200</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">protocol</span>\n<span class=\"s1\">'HTTP/2'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">text</span>\n<span class=\"s1\">'&lt;!doctype html&gt;</span><span class=\"se\">\\n</span><span class=\"s1\">&lt;html&gt;</span><span class=\"se\">\\n</span><span class=\"s1\">&lt;head&gt;</span><span class=\"se\">\\n</span><span class=\"s1\">&lt;title&gt;Example Domain&lt;/title&gt;</span><span class=\"se\">\\n</span><span class=\"s1\">...'</span>\n</pre>\n<p>Alternatively, async requests:</p>\n<p><strong>Note</strong>: Use <code>ipython</code> to try this from the console, since it supports <code>await</code>.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">httpcore</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">httpcore</span><span class=\"o\">.</span><span class=\"n\">AsyncClient</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'https://example.com'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">status_code</span>\n<span class=\"o\">&lt;</span><span class=\"n\">StatusCode</span><span class=\"o\">.</span><span class=\"n\">OK</span><span class=\"p\">:</span> <span class=\"mi\">200</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">protocol</span>\n<span class=\"s1\">'HTTP/2'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">text</span>\n<span class=\"s1\">'&lt;!doctype html&gt;</span><span class=\"se\">\\n</span><span class=\"s1\">&lt;html&gt;</span><span class=\"se\">\\n</span><span class=\"s1\">&lt;head&gt;</span><span class=\"se\">\\n</span><span class=\"s1\">&lt;title&gt;Example Domain&lt;/title&gt;</span><span class=\"se\">\\n</span><span class=\"s1\">...'</span>\n</pre>\n<hr>\n<h2>Dependencies</h2>\n<ul>\n<li><code>h2</code> - HTTP/2 support.</li>\n<li><code>h11</code> - HTTP/1.1 support.</li>\n<li><code>certifi</code> - SSL certificates.</li>\n<li><code>chardet</code> - Fallback auto-detection for response encoding.</li>\n<li><code>idna</code> - Internationalized domain name support.</li>\n<li><code>rfc3986</code> - URL parsing &amp; normalization.</li>\n<li><code>brotlipy</code> - Decoding for \"brotli\" compressed responses. <em>(Optional)</em></li>\n</ul>\n<p>A huge amount of credit is due to <code>requests</code> for the API layout that\nmuch of this work follows, as well as to <code>urllib3</code> for plenty of design\ninspiration around the lower level networking details.</p>\n<hr>\n<h2>API Reference</h2>\n<h3><code>Client</code></h3>\n<p><em>An HTTP client, with connection pooling, redirects, cookie persistence, etc.</em></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">Client</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'https://example.org'</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>def __init__([auth], [cookies], [verify], [cert], [timeout], [pool_limits], [max_redirects], [dispatch])</code></li>\n<li><code>def .request(method, url, [data], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .get(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .options(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .head(url, [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .post(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .put(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .patch(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .delete(url, [data], [json], [params], [headers], [cookies], [auth], [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .prepare_request(request)</code></li>\n<li><code>def .send(request, [stream], [allow_redirects], [verify], [cert], [timeout])</code></li>\n<li><code>def .close()</code></li>\n</ul>\n<h3><code>Response</code></h3>\n<p><em>An HTTP response.</em></p>\n<ul>\n<li><code>def __init__(...)</code></li>\n<li><code>.status_code</code> - <strong>int</strong> <em>(Typically a <code>StatusCode</code> IntEnum.)</em></li>\n<li><code>.reason_phrase</code> - <strong>str</strong></li>\n<li><code>.protocol</code> - <code>\"HTTP/2\"</code> or <code>\"HTTP/1.1\"</code></li>\n<li><code>.url</code> - <strong>URL</strong></li>\n<li><code>.headers</code> - <strong>Headers</strong></li>\n<li><code>.content</code> - <strong>bytes</strong></li>\n<li><code>.text</code> - <strong>str</strong></li>\n<li><code>.encoding</code> - <strong>str</strong></li>\n<li><code>.is_redirect</code> - <strong>bool</strong></li>\n<li><code>.request</code> - <strong>Request</strong></li>\n<li><code>.cookies</code> - <strong>Cookies</strong></li>\n<li><code>.history</code> - <strong>List[Response]</strong></li>\n<li><code>def .raise_for_status()</code> - <strong>None</strong></li>\n<li><code>def .json()</code> - <strong>Any</strong></li>\n<li><code>def .read()</code> - <strong>bytes</strong></li>\n<li><code>def .stream()</code> - <strong>bytes iterator</strong></li>\n<li><code>def .raw()</code> - <strong>bytes iterator</strong></li>\n<li><code>def .close()</code> - <strong>None</strong></li>\n<li><code>def .next()</code> - <strong>Response</strong></li>\n</ul>\n<h3><code>Request</code></h3>\n<p><em>An HTTP request. Can be constructed explicitly for more control over exactly\nwhat gets sent over the wire.</em></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">request</span> <span class=\"o\">=</span> <span class=\"n\">Request</span><span class=\"p\">(</span><span class=\"s2\">\"GET\"</span><span class=\"p\">,</span> <span class=\"s2\">\"https://example.org\"</span><span class=\"p\">,</span> <span class=\"n\">headers</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'host'</span><span class=\"p\">:</span> <span class=\"s1\">'example.org'</span><span class=\"p\">})</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>def __init__(method, url, [params], [data], [json], [headers], [cookies])</code></li>\n<li><code>.method</code> - <strong>str</strong></li>\n<li><code>.url</code> - <strong>URL</strong></li>\n<li><code>.content</code> - <strong>byte</strong> or <strong>byte async iterator</strong></li>\n<li><code>.headers</code> - <strong>Headers</strong></li>\n<li><code>.cookies</code> - <strong>Cookies</strong></li>\n</ul>\n<h3><code>URL</code></h3>\n<p><em>A normalized, IDNA supporting URL.</em></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">url</span> <span class=\"o\">=</span> <span class=\"n\">URL</span><span class=\"p\">(</span><span class=\"s2\">\"https://example.org/\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">url</span><span class=\"o\">.</span><span class=\"n\">host</span>\n<span class=\"s1\">'example.org'</span>\n</pre>\n<ul>\n<li><code>def __init__(url, allow_relative=False, params=None)</code></li>\n<li><code>.scheme</code> - <strong>str</strong></li>\n<li><code>.authority</code> - <strong>str</strong></li>\n<li><code>.host</code> - <strong>str</strong></li>\n<li><code>.port</code> - <strong>int</strong></li>\n<li><code>.path</code> - <strong>str</strong></li>\n<li><code>.query</code> - <strong>str</strong></li>\n<li><code>.full_path</code> - <strong>str</strong></li>\n<li><code>.fragment</code> - <strong>str</strong></li>\n<li><code>.is_ssl</code> - <strong>bool</strong></li>\n<li><code>.origin</code> - <strong>Origin</strong></li>\n<li><code>.is_absolute_url</code> - <strong>bool</strong></li>\n<li><code>.is_relative_url</code> - <strong>bool</strong></li>\n<li><code>def .copy_with([scheme], [authority], [path], [query], [fragment])</code> - <strong>URL</strong></li>\n<li><code>def .resolve_with(url)</code> - <strong>URL</strong></li>\n</ul>\n<h3><code>Origin</code></h3>\n<p><em>A normalized, IDNA supporting set of scheme/host/port info.</em></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Origin</span><span class=\"p\">(</span><span class=\"s1\">'https://example.org'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Origin</span><span class=\"p\">(</span><span class=\"s1\">'HTTPS://EXAMPLE.ORG:443'</span><span class=\"p\">)</span>\n<span class=\"kc\">True</span>\n</pre>\n<ul>\n<li><code>def __init__(url)</code></li>\n<li><code>.is_ssl</code> - <strong>bool</strong></li>\n<li><code>.host</code> - <strong>str</strong></li>\n<li><code>.port</code> - <strong>int</strong></li>\n</ul>\n<h3><code>Headers</code></h3>\n<p><em>A case-insensitive multi-dict.</em></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">headers</span> <span class=\"o\">=</span> <span class=\"n\">Headers</span><span class=\"p\">({</span><span class=\"s1\">'Content-Type'</span><span class=\"p\">:</span> <span class=\"s1\">'application/json'</span><span class=\"p\">})</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">headers</span><span class=\"p\">[</span><span class=\"s1\">'content-type'</span><span class=\"p\">]</span>\n<span class=\"s1\">'application/json'</span>\n</pre>\n<ul>\n<li><code>def __init__(self, headers)</code></li>\n</ul>\n<h3><code>Cookies</code></h3>\n<p><em>A dict-like cookie store.</em></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cookies</span> <span class=\"o\">=</span> <span class=\"n\">Cookies</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cookies</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"s2\">\"name\"</span><span class=\"p\">,</span> <span class=\"s2\">\"value\"</span><span class=\"p\">,</span> <span class=\"n\">domain</span><span class=\"o\">=</span><span class=\"s2\">\"example.org\"</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>def __init__(cookies: [dict, Cookies, CookieJar])</code></li>\n<li><code>.jar</code> - <strong>CookieJar</strong></li>\n<li><code>def extract_cookies(response)</code></li>\n<li><code>def set_cookie_header(request)</code></li>\n<li><code>def set(name, value, [domain], [path])</code></li>\n<li><code>def get(name, [domain], [path])</code></li>\n<li><code>def delete(name, [domain], [path])</code></li>\n<li><code>def clear([domain], [path])</code></li>\n<li><em>Standard mutable mapping interface</em></li>\n</ul>\n<hr>\n<h2>Alternate backends</h2>\n<h3><code>AsyncClient</code></h3>\n<p>An asyncio client.</p>\n<h3><code>TrioClient</code></h3>\n<p><em>TODO</em></p>\n<hr>\n<h2>The Stack</h2>\n<p>There are two main layers in the stack. The client handles redirection,\ncookie persistence (TODO), and authentication (TODO). The dispatcher\nhandles sending the actual request and getting the response.</p>\n<ul>\n<li><code>Client</code> - Redirect, authentication, cookies etc.</li>\n<li><code>ConnectionPool(Dispatcher)</code> - Connection pooling &amp; keep alive.\n<ul>\n<li><code>HTTPConnection</code> - A single connection.\n<ul>\n<li><code>HTTP11Connection</code> - A single HTTP/1.1 connection.</li>\n<li><code>HTTP2Connection</code> - A single HTTP/2 connection, with multiple streams.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 5312462, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "37a5b59689a4e76c15966df0f9ad09b2", "sha256": "ff76f06aecbf6d9b4f4f0a594e5841baef3650ffd651fb448bb63c4c29e95d4e"}, "downloads": -1, "filename": "livewire-0.0.0.tar.gz", "has_sig": false, "md5_digest": "37a5b59689a4e76c15966df0f9ad09b2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 29412, "upload_time": "2019-05-24T11:59:54", "upload_time_iso_8601": "2019-05-24T11:59:54.245700Z", "url": "https://files.pythonhosted.org/packages/cb/1d/656aa27e1f2a1fceb815c2daf02296c69e98fdb4d56b99128a24967f681a/livewire-0.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "37a5b59689a4e76c15966df0f9ad09b2", "sha256": "ff76f06aecbf6d9b4f4f0a594e5841baef3650ffd651fb448bb63c4c29e95d4e"}, "downloads": -1, "filename": "livewire-0.0.0.tar.gz", "has_sig": false, "md5_digest": "37a5b59689a4e76c15966df0f9ad09b2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 29412, "upload_time": "2019-05-24T11:59:54", "upload_time_iso_8601": "2019-05-24T11:59:54.245700Z", "url": "https://files.pythonhosted.org/packages/cb/1d/656aa27e1f2a1fceb815c2daf02296c69e98fdb4d56b99128a24967f681a/livewire-0.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:45:03 2020"}