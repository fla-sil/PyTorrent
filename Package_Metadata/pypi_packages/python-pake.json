{"info": {"author": "Teriks", "author_email": "Teriks@users.noreply.github.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3.5", "Topic :: Software Development :: Build Tools", "Topic :: Utilities"], "description": "About pake\n==========\n\n|Master Documentation Status| |codecov|\n\npake is a make-like python build utility where tasks, dependencies and\nbuild commands can be expressed entirely in python, similar to ruby\nrake.\n\npake supports automatic file/directory change detection when dealing with\ntask inputs and outputs, and also parallel builds.\n\npake requires python3.5+\n\n\nThis readme contains only a little information about how to use pake, please\ncheckout the latest documentation at the links above for an expansive\noverview on how pake works and how pakefiles should be written.\n\nInstalling\n==========\n\nNote: pake is Alpha and likely to change some.\n\n\nTo install the latest release use:\n\n``sudo pip3 install python-pake --upgrade``\n\n\nIf you want to install the development branch you can use:\n\n``sudo pip3 install git+git://github.com/Teriks/pake@develop``\n\n\nExample project using pake\n==========================\n\nI am using libasm\\_io to help test pake and have included a pakefile\nbuild along side the makefiles in that project.\n\nhttps://github.com/Teriks/libasm\\_io\n\n\nSee the build with pake section of **libasm\\_io/build-readme.md** here_.\n\n.. _here: https://github.com/Teriks/libasm_io/blob/develop/build-readme.md#build-with-pake\n\nWriting Basic Tasks\n===================\n\nHere's a contrived pake demo:\n\n.. code-block:: python\n\n    import pake\n\n    # Tasks are registered the the pake.Pake object\n    # returned by pake's initialization call, using the task decorator.\n\n    pk = pake.init()\n\n    # Try to grab a command line define.\n    # In particular the value of -D CC=..\n    # CC will default to 'gcc' in this case if\n    # it was not specified.\n\n    CC = pk.get_define('CC', 'gcc')\n\n    # you can also use the syntax: pk[\"CC\"] to\n    # attempt to get the defines value, if it is not\n    # defined then it will return None.\n\n    # ===\n\n    # If you just have a single input/output, there is no\n    # need to pass a list to the tasks inputs/outputs\n\n    @pk.task(i='foo/foo.c', o='foo/foo.o')\n    def foo(ctx):\n        # Execute a program (gcc) and print its stdout/stderr to the tasks output.\n\n        # ctx.call can be passed a command line as variadic arguments, an iterable, or\n        # as a string.  It will automatically flatten out non string iterables in your variadic\n        # arguments or iterable object, so you can pass an iterable such as ctx.inputs\n        # as part of your full command line invocation instead of trying to create the command\n        # line by concatenating lists or using the indexer on ctx.inputs/ctx.outputs\n\n        ctx.call(CC, '-c', ctx.inputs, '-o', ctx.outputs)\n\n\n    # Pake can handle file change detection with multiple inputs\n    # and outputs. If the amount of inputs is different from\n    # the amount of outputs, the task is considered to be out\n    # of date if any input file is newer than any output file.\n\n    # When the amount of inputs is equal to the amount of outputs,\n    # pake will compare each input to its corresponding output\n    # and collect out of date input/outputs into ctx.outdated_inputs\n    # and ctx.outdated_outputs respectively.  ctx.outdated_pairs\n    # can be used to get a generator over (input, output) pairs,\n    # it is shorthand for zip(ctx.outdated_inputs, ctx.outdated_outputs)\n\n    @pk.task(i=pake.glob('bar/*.c'), o=pake.pattern('bar/%.o'))\n    def bar(ctx):\n\n        # zip together the outdated inputs and outputs, since they\n        # correspond to each other, this iterates of a sequence of python\n        # tuple objects in the form (input, output)\n\n        for i, o in ctx.outdated_pairs:\n            ctx.call(CC, '-c', i, '-o', o)\n\n\n    # This task depends on the 'foo' and 'bar' tasks, as\n    # specified with the decorators leading parameters.\n    # It outputs 'bin/baz' by taking the input 'main.c'\n    # and linking it to the object files produced in the other tasks.\n\n    @pk.task(foo, bar, o='bin/baz', i='main.c')\n    def baz(ctx):\n        \"\"\"Use this to build baz\"\"\"\n\n        # Documentation strings can be viewed by running 'pake -ti' in\n        # the directory the pakefile exists in, it will list all documented\n        # tasks with their python doc strings.\n\n        # The pake.FileHelper class can be used to preform basic file\n        # system operations while printing information about the operations\n        # it has completed to the tasks output.\n\n        file_helper = pake.FileHelper(ctx)\n\n        # Create a bin directory, this won't complain if it exists already\n        file_helper.makedirs('bin')\n\n        # ctx.dependency_outputs contains a list of all outputs that this\n        # tasks immediate dependencies produce\n\n        ctx.call(CC, '-o', ctx.outputs, ctx.inputs, ctx.dependency_outputs)\n\n\n    @pk.task\n    def clean(ctx):\n        \"\"\"Clean binaries\"\"\"\n\n        file_helper = pake.FileHelper(ctx)\n\n        # Clean up using the FileHelper object.\n        # Remove the bin directory, this wont complain if 'bin'\n        # does not exist.\n\n        file_helper.rmtree('bin')\n\n        # Glob remove object files from the foo and bar directories\n\n        file_helper.glob_remove('foo/*.o')\n        file_helper.glob_remove('bar/*.o')\n\n\n    # Run pake; The default task that will be executed when\n    # none are specified on the command line will be 'baz' in\n    # this case.\n\n    # The tasks parameter is optional, but if it is not specified\n    # here, you will be required to specify a task or tasks on the\n    # command line.\n\n    pake.run(pk, tasks=baz)\n\n\nOutput from command ``pake``:\n\n.. code-block:: bash\n\n    ===== Executing task: \"bar\"\n    gcc -c bar/bar.c -o bar/bar.o\n    ===== Executing task: \"foo\"\n    gcc -c foo/foo.c -o foo/foo.o\n    ===== Executing task: \"baz\"\n    Created Directory(s): \"bin\"\n    gcc -o bin/baz main.c foo/foo.o bar/bar.o\n\n\nOutput from command ``pake clean``:\n\n.. code-block:: bash\n\n    ===== Executing task: \"clean\"\n    Removed Directory(s): \"bin\"\n    Glob Removed Files: \"foo/*.o\"\n    Glob Removed Files: \"bar/*.o\"\n\n\nConcurrency Inside Tasks\n========================\n\nWork can be submitted to the threadpool pake is running its tasks on to achieve a\npredictable level of concurrency for sub tasks that is limited by the **--jobs** command line argument,\nor the **jobs** parameter of **pake.run** and **pake.Pake.run**.\n\nExample:\n\n.. code-block:: python\n\n    import pake\n\n    # functools.partial is used for binding argument values to functions\n\n    from functools import partial\n\n\n    pk = pake.init()\n\n\n    @pk.task(i=pake.glob('src/*.c'), o=pake.pattern('obj/%.o'))\n    def build_c(ctx)\n\n       file_helper = pake.FileHelper(ctx)\n\n       # Make 'obj' directory if it does not exist.\n       # This does not complain if it is already there.\n\n       file_helper.makedirs('obj')\n\n       # Start multitasking\n\n       with ctx.multitask() as mt:\n           for i, o in ctx.outdated_pairs:\n\n               # Read the section 'Output synchronization with ctx.call & ctx.subpake'\n               # in the 'Concurrency Inside Tasks` page on http://pake.readthedocs.io\n               # for an explanation of 'sync_call' below, and how output\n               # synchronization is achieved for ctx.call and ctx.subpake\n\n               sync_call = partial(ctx.call,\n                                   collect_output=pk.max_jobs > 1)\n\n               # Submit a work function with arguments to the threadpool\n               mt.submit(sync_call, ['gcc', '-c', i, '-o', o])\n\n\n    @pk.task(build_c, i=pake.glob('obj/*.o'), o='main')\n    def build(ctx):\n\n       # Utilizing the automatic non string iterable\n       # flattening here to pass ctx.inputs and ctx.outputs\n\n       ctx.call('gcc', ctx.inputs, '-o', ctx.outputs)\n\n\n    pake.run(pk, tasks=build)\n\n\nRunning Sub Pakefiles\n=====================\n\nPake is able to run itself through the use of **pake.TaskContext.subpake**\nand **pake.subpake**.\n\n**pake.subpake** is meant to be used outside of tasks, and can even be\ncalled before pake is initialized.\n\n**pake.TaskContext.subpake** is preferred for use inside of tasks because\nit handles writing to the task's output queue for you, without having to specify\nextra parameters to **pake.subpake** to get it working correctly.\n\n**pake.TaskContext** instance is passed into the single argument of each task function,\nwhich you can in turn call **subpake** from.\n\nDefines can be exported to pakefiles ran with the **subpake** functions using **pake.export**.\n\n**pake.subpake** and **pake.TaskContext.subpake** use the **--stdin-defines** option of\npake to pass exported define values into the new process instance, which means you can overwrite your\nexported define values with **-D/--define** in the subpake command arguments if you need to.\n\nExport / Subpake Example:\n\n.. code-block:: python\n\n    import pake\n\n    pk = pake.init()\n\n    # Try to get the CC define from the command line,\n    # default to 'gcc'.\n\n    CC = pk.get_define('CC', 'gcc')\n\n    # Export the CC variable's value to all invocations\n    # of pake.subpake or ctx.subpake as a define that can be\n    # retrieved with pk.get_define()\n\n    pake.export('CC', CC)\n\n\n    # You can also export lists, dictionaries sets and tuples,\n    # as long as they only contain literal values.\n    # Literal values being: strings, integers, floats; and\n    # other lists, dicts, sets and tuples.  Collections must only\n    # contain literals, or objects that repr() into a parsable literal.\n\n    pake.export('CC_FLAGS', ['-Wextra', '-Wall'])\n\n\n    # Nesting works with composite literals,\n    # as long as everything is a pure literal or something\n    # that str()'s into a literal.\n\n    pake.export('STUFF',\n                ['you',\n                 ['might',\n                  ('be',\n                   ['a',\n                    {'bad' :\n                         ['person', ['if', {'you', 'do'}, ('this',) ]]\n                     }])]])\n\n\n    # This export will be overrode in the next call\n    pake.export('OVERRIDE_ME', False)\n\n\n    # Execute outside of a task, by default the stdout/stderr\n    # of the subscript goes to this scripts stdout.  The file\n    # object to which stdout gets written to can be specified\n    # with pake.subpake(..., stdout=(file))\n\n    # This command also demonstrates that you can override\n    # your exports using the -D/--define option\n\n    pake.subpake('sometasks/pakefile.py', 'dotasks', '-D', 'OVERRIDE_ME=True')\n\n\n    # This task does not depend on anything or have any inputs/outputs\n    # it will basically only run if you explicitly specify it as a default\n    # task in pake.run, or specify it on the command line\n\n    @pk.task\n    def my_phony_task(ctx):\n        # Arguments are passed in a variadic parameter...\n\n        # Specify that the \"foo\" task is to be ran.\n        # The scripts output is written to this tasks output queue\n\n        ctx.subpake('library/pakefile.py', 'foo')\n\n\n\n    # Run this pake script, with a default task of 'my_phony_task'\n\n    pake.run(pk, tasks=my_phony_task)\n\n\nOutput from the example above:\n\n.. code-block:: bash\n\n    *** enter subpake[1]:\n    pake[1]: Entering Directory \"(REST OF PATH...)/paketest/sometasks\"\n    ===== Executing Task: \"dotasks\"\n    Do Tasks\n    pake[1]: Exiting Directory \"(REST OF PATH...)/paketest/sometasks\"\n    *** exit subpake[1]:\n    ===== Executing Task: \"my_phony_task\"\n    *** enter subpake[1]:\n    pake[1]: Entering Directory \"(REST OF PATH...)/paketest/library\"\n    ===== Executing Task: \"foo\"\n    Foo!\n    pake[1]: Exiting Directory \"(REST OF PATH...)/paketest/library\"\n    *** exit subpake[1]:\n\n\nRunning pake\n============\n\n.. code-block:: bash\n\n    cd your_pakefile_directory\n\n    # Run pake with up to 10 tasks running in parallel\n\n    pake -j 10\n\npake will look for \"pakefile.py\" or \"pakefile\" in the current directory\nand run it.\n\nOr you can specify one or more files to run with **-f/--file**. The\nswitch does not have multiple arguments, but it can be used more than\nonce to specify multiple files.\n\nFor example:\n\n``pake -f pakefile.py foo``\n\n``pake -f your_pakefile_1.py -f your_pakefile_2.py foo``\n\nYou can also specify multiple tasks, but do not rely on unrelated tasks\nbeing executed in any specific order because they won't be. If there is\na specific order you need your tasks to execute in, the one that comes\nfirst should be declared a dependency of the one that comes second, then\nthe second task should be specified to run.\n\nWhen running parallel builds, leaf dependencies will start executing\npretty much simultaneously, and non related tasks that have a dependency\nchain may execute in parallel.\n\n``pake task unrelated_task order_independent_phony``\n\nCommand Line Options\n--------------------\n\n::\n\n    usage: pake [-h] [-v] [-D DEFINE] [--stdin-defines] [-j JOBS] [-n]\n                [-C DIRECTORY] [-t] [-ti] [--sync-output {True, False, 1, 0}]\n                [-f FILE]\n                [tasks [tasks ...]]\n\n    positional arguments:\n      tasks                 Build tasks.\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      -v, --version         show program's version number and exit\n      -D DEFINE, --define DEFINE\n                            Add defined value.\n      --stdin-defines       Read defines from a Python Dictionary piped into\n                            stdin. Defines read with this option can be\n                            overwritten by defines specified on the command line\n                            with -D/--define.\n      -j JOBS, --jobs JOBS  Max number of parallel jobs. Using this option enables\n                            unrelated tasks to run in parallel with a max of N\n                            tasks running at a time.\n      -n, --dry-run         Use to preform a dry run, lists all tasks that will be\n                            executed in the next actual invocation.\n      -C DIRECTORY, --directory DIRECTORY\n                            Change directory before executing.\n      -t, --show-tasks      List all task names.\n      -ti, --show-task-info\n                            List all tasks along side their doc string. Only tasks\n                            with doc strings present will be shown.\n      --sync-output {True, False, 1, 0}\n                            Tell pake whether it should synchronize task output\n                            when running with multiple jobs. Console output can\n                            get scrambled under the right circumstances with this\n                            turned off, but pake will run slightly faster. This\n                            option will override any value in the PAKE_SYNC_OUTPUT\n                            environmental variable, and is inherited by subpake\n                            invocations unless the argument is re-passed with a\n                            different value or overridden in pake.init.\n      -f FILE, --file FILE  Pakefile path(s). This switch can be used more than\n                            once, all specified pakefiles will be executed in\n                            order with the current directory as the working\n                            directory (unless -C is specified).\n\n\n.. |Master Documentation Status| image:: https://readthedocs.org/projects/pake/badge/?version=latest\n   :target: http://pake.readthedocs.io/en/latest/?badge=latest\n.. |codecov| image:: https://codecov.io/gh/Teriks/pake/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/Teriks/pake", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Teriks/pake", "keywords": "", "license": "BSD 3-Clause", "maintainer": "", "maintainer_email": "", "name": "python-pake", "package_url": "https://pypi.org/project/python-pake/", "platform": "", "project_url": "https://pypi.org/project/python-pake/", "project_urls": {"Homepage": "https://github.com/Teriks/pake"}, "release_url": "https://pypi.org/project/python-pake/0.17.0.3a1/", "requires_dist": null, "requires_python": "", "summary": "A make-like build utility entirely in python.", "version": "0.17.0.3a1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"about-pake\">\n<h2>About pake</h2>\n<p><a href=\"http://pake.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Master Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/429c15565369d6789e8516f8c5b9d9028f4df35c/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f70616b652f62616467652f3f76657273696f6e3d6c6174657374\"></a> <a href=\"https://codecov.io/gh/Teriks/pake\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/74692504b77525ed68fc8ea25b28be549282611d/68747470733a2f2f636f6465636f762e696f2f67682f546572696b732f70616b652f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<p>pake is a make-like python build utility where tasks, dependencies and\nbuild commands can be expressed entirely in python, similar to ruby\nrake.</p>\n<p>pake supports automatic file/directory change detection when dealing with\ntask inputs and outputs, and also parallel builds.</p>\n<p>pake requires python3.5+</p>\n<p>This readme contains only a little information about how to use pake, please\ncheckout the latest documentation at the links above for an expansive\noverview on how pake works and how pakefiles should be written.</p>\n</div>\n<div id=\"installing\">\n<h2>Installing</h2>\n<p>Note: pake is Alpha and likely to change some.</p>\n<p>To install the latest release use:</p>\n<p><tt>sudo pip3 install <span class=\"pre\">python-pake</span> <span class=\"pre\">--upgrade</span></tt></p>\n<p>If you want to install the development branch you can use:</p>\n<p><tt>sudo pip3 install <span class=\"pre\">git+git://github.com/Teriks/pake@develop</span></tt></p>\n</div>\n<div id=\"example-project-using-pake\">\n<h2>Example project using pake</h2>\n<p>I am using libasm_io to help test pake and have included a pakefile\nbuild along side the makefiles in that project.</p>\n<p><a href=\"https://github.com/Teriks/libasm_io\" rel=\"nofollow\">https://github.com/Teriks/libasm_io</a></p>\n<p>See the build with pake section of <strong>libasm_io/build-readme.md</strong> <a href=\"https://github.com/Teriks/libasm_io/blob/develop/build-readme.md#build-with-pake\" rel=\"nofollow\">here</a>.</p>\n</div>\n<div id=\"writing-basic-tasks\">\n<h2>Writing Basic Tasks</h2>\n<p>Here\u2019s a contrived pake demo:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pake</span>\n\n<span class=\"c1\"># Tasks are registered the the pake.Pake object</span>\n<span class=\"c1\"># returned by pake's initialization call, using the task decorator.</span>\n\n<span class=\"n\">pk</span> <span class=\"o\">=</span> <span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">init</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Try to grab a command line define.</span>\n<span class=\"c1\"># In particular the value of -D CC=..</span>\n<span class=\"c1\"># CC will default to 'gcc' in this case if</span>\n<span class=\"c1\"># it was not specified.</span>\n\n<span class=\"n\">CC</span> <span class=\"o\">=</span> <span class=\"n\">pk</span><span class=\"o\">.</span><span class=\"n\">get_define</span><span class=\"p\">(</span><span class=\"s1\">'CC'</span><span class=\"p\">,</span> <span class=\"s1\">'gcc'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># you can also use the syntax: pk[\"CC\"] to</span>\n<span class=\"c1\"># attempt to get the defines value, if it is not</span>\n<span class=\"c1\"># defined then it will return None.</span>\n\n<span class=\"c1\"># ===</span>\n\n<span class=\"c1\"># If you just have a single input/output, there is no</span>\n<span class=\"c1\"># need to pass a list to the tasks inputs/outputs</span>\n\n<span class=\"nd\">@pk</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"s1\">'foo/foo.c'</span><span class=\"p\">,</span> <span class=\"n\">o</span><span class=\"o\">=</span><span class=\"s1\">'foo/foo.o'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Execute a program (gcc) and print its stdout/stderr to the tasks output.</span>\n\n    <span class=\"c1\"># ctx.call can be passed a command line as variadic arguments, an iterable, or</span>\n    <span class=\"c1\"># as a string.  It will automatically flatten out non string iterables in your variadic</span>\n    <span class=\"c1\"># arguments or iterable object, so you can pass an iterable such as ctx.inputs</span>\n    <span class=\"c1\"># as part of your full command line invocation instead of trying to create the command</span>\n    <span class=\"c1\"># line by concatenating lists or using the indexer on ctx.inputs/ctx.outputs</span>\n\n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"n\">CC</span><span class=\"p\">,</span> <span class=\"s1\">'-c'</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">inputs</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Pake can handle file change detection with multiple inputs</span>\n<span class=\"c1\"># and outputs. If the amount of inputs is different from</span>\n<span class=\"c1\"># the amount of outputs, the task is considered to be out</span>\n<span class=\"c1\"># of date if any input file is newer than any output file.</span>\n\n<span class=\"c1\"># When the amount of inputs is equal to the amount of outputs,</span>\n<span class=\"c1\"># pake will compare each input to its corresponding output</span>\n<span class=\"c1\"># and collect out of date input/outputs into ctx.outdated_inputs</span>\n<span class=\"c1\"># and ctx.outdated_outputs respectively.  ctx.outdated_pairs</span>\n<span class=\"c1\"># can be used to get a generator over (input, output) pairs,</span>\n<span class=\"c1\"># it is shorthand for zip(ctx.outdated_inputs, ctx.outdated_outputs)</span>\n\n<span class=\"nd\">@pk</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"s1\">'bar/*.c'</span><span class=\"p\">),</span> <span class=\"n\">o</span><span class=\"o\">=</span><span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"p\">(</span><span class=\"s1\">'bar/%.o'</span><span class=\"p\">))</span>\n<span class=\"k\">def</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n\n    <span class=\"c1\"># zip together the outdated inputs and outputs, since they</span>\n    <span class=\"c1\"># correspond to each other, this iterates of a sequence of python</span>\n    <span class=\"c1\"># tuple objects in the form (input, output)</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">o</span> <span class=\"ow\">in</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">outdated_pairs</span><span class=\"p\">:</span>\n        <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"n\">CC</span><span class=\"p\">,</span> <span class=\"s1\">'-c'</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"n\">o</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># This task depends on the 'foo' and 'bar' tasks, as</span>\n<span class=\"c1\"># specified with the decorators leading parameters.</span>\n<span class=\"c1\"># It outputs 'bin/baz' by taking the input 'main.c'</span>\n<span class=\"c1\"># and linking it to the object files produced in the other tasks.</span>\n\n<span class=\"nd\">@pk</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"p\">,</span> <span class=\"n\">o</span><span class=\"o\">=</span><span class=\"s1\">'bin/baz'</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"s1\">'main.c'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">baz</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Use this to build baz\"\"\"</span>\n\n    <span class=\"c1\"># Documentation strings can be viewed by running 'pake -ti' in</span>\n    <span class=\"c1\"># the directory the pakefile exists in, it will list all documented</span>\n    <span class=\"c1\"># tasks with their python doc strings.</span>\n\n    <span class=\"c1\"># The pake.FileHelper class can be used to preform basic file</span>\n    <span class=\"c1\"># system operations while printing information about the operations</span>\n    <span class=\"c1\"># it has completed to the tasks output.</span>\n\n    <span class=\"n\">file_helper</span> <span class=\"o\">=</span> <span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">FileHelper</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Create a bin directory, this won't complain if it exists already</span>\n    <span class=\"n\">file_helper</span><span class=\"o\">.</span><span class=\"n\">makedirs</span><span class=\"p\">(</span><span class=\"s1\">'bin'</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># ctx.dependency_outputs contains a list of all outputs that this</span>\n    <span class=\"c1\"># tasks immediate dependencies produce</span>\n\n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"n\">CC</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">outputs</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">inputs</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">dependency_outputs</span><span class=\"p\">)</span>\n\n\n<span class=\"nd\">@pk</span><span class=\"o\">.</span><span class=\"n\">task</span>\n<span class=\"k\">def</span> <span class=\"nf\">clean</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Clean binaries\"\"\"</span>\n\n    <span class=\"n\">file_helper</span> <span class=\"o\">=</span> <span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">FileHelper</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Clean up using the FileHelper object.</span>\n    <span class=\"c1\"># Remove the bin directory, this wont complain if 'bin'</span>\n    <span class=\"c1\"># does not exist.</span>\n\n    <span class=\"n\">file_helper</span><span class=\"o\">.</span><span class=\"n\">rmtree</span><span class=\"p\">(</span><span class=\"s1\">'bin'</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Glob remove object files from the foo and bar directories</span>\n\n    <span class=\"n\">file_helper</span><span class=\"o\">.</span><span class=\"n\">glob_remove</span><span class=\"p\">(</span><span class=\"s1\">'foo/*.o'</span><span class=\"p\">)</span>\n    <span class=\"n\">file_helper</span><span class=\"o\">.</span><span class=\"n\">glob_remove</span><span class=\"p\">(</span><span class=\"s1\">'bar/*.o'</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Run pake; The default task that will be executed when</span>\n<span class=\"c1\"># none are specified on the command line will be 'baz' in</span>\n<span class=\"c1\"># this case.</span>\n\n<span class=\"c1\"># The tasks parameter is optional, but if it is not specified</span>\n<span class=\"c1\"># here, you will be required to specify a task or tasks on the</span>\n<span class=\"c1\"># command line.</span>\n\n<span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">pk</span><span class=\"p\">,</span> <span class=\"n\">tasks</span><span class=\"o\">=</span><span class=\"n\">baz</span><span class=\"p\">)</span>\n</pre>\n<p>Output from command <tt>pake</tt>:</p>\n<pre><span class=\"o\">=====</span> Executing task: <span class=\"s2\">\"bar\"</span>\ngcc -c bar/bar.c -o bar/bar.o\n<span class=\"o\">=====</span> Executing task: <span class=\"s2\">\"foo\"</span>\ngcc -c foo/foo.c -o foo/foo.o\n<span class=\"o\">=====</span> Executing task: <span class=\"s2\">\"baz\"</span>\nCreated Directory<span class=\"o\">(</span>s<span class=\"o\">)</span>: <span class=\"s2\">\"bin\"</span>\ngcc -o bin/baz main.c foo/foo.o bar/bar.o\n</pre>\n<p>Output from command <tt>pake clean</tt>:</p>\n<pre><span class=\"o\">=====</span> Executing task: <span class=\"s2\">\"clean\"</span>\nRemoved Directory<span class=\"o\">(</span>s<span class=\"o\">)</span>: <span class=\"s2\">\"bin\"</span>\nGlob Removed Files: <span class=\"s2\">\"foo/*.o\"</span>\nGlob Removed Files: <span class=\"s2\">\"bar/*.o\"</span>\n</pre>\n</div>\n<div id=\"concurrency-inside-tasks\">\n<h2>Concurrency Inside Tasks</h2>\n<p>Work can be submitted to the threadpool pake is running its tasks on to achieve a\npredictable level of concurrency for sub tasks that is limited by the <strong>\u2013jobs</strong> command line argument,\nor the <strong>jobs</strong> parameter of <strong>pake.run</strong> and <strong>pake.Pake.run</strong>.</p>\n<p>Example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pake</span>\n\n<span class=\"c1\"># functools.partial is used for binding argument values to functions</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">partial</span>\n\n\n<span class=\"n\">pk</span> <span class=\"o\">=</span> <span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">init</span><span class=\"p\">()</span>\n\n\n<span class=\"nd\">@pk</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"s1\">'src/*.c'</span><span class=\"p\">),</span> <span class=\"n\">o</span><span class=\"o\">=</span><span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">pattern</span><span class=\"p\">(</span><span class=\"s1\">'obj/%.o'</span><span class=\"p\">))</span>\n<span class=\"k\">def</span> <span class=\"nf\">build_c</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n\n   <span class=\"n\">file_helper</span> <span class=\"o\">=</span> <span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">FileHelper</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n\n   <span class=\"c1\"># Make 'obj' directory if it does not exist.</span>\n   <span class=\"c1\"># This does not complain if it is already there.</span>\n\n   <span class=\"n\">file_helper</span><span class=\"o\">.</span><span class=\"n\">makedirs</span><span class=\"p\">(</span><span class=\"s1\">'obj'</span><span class=\"p\">)</span>\n\n   <span class=\"c1\"># Start multitasking</span>\n\n   <span class=\"k\">with</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">multitask</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">mt</span><span class=\"p\">:</span>\n       <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">o</span> <span class=\"ow\">in</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">outdated_pairs</span><span class=\"p\">:</span>\n\n           <span class=\"c1\"># Read the section 'Output synchronization with ctx.call &amp; ctx.subpake'</span>\n           <span class=\"c1\"># in the 'Concurrency Inside Tasks` page on http://pake.readthedocs.io</span>\n           <span class=\"c1\"># for an explanation of 'sync_call' below, and how output</span>\n           <span class=\"c1\"># synchronization is achieved for ctx.call and ctx.subpake</span>\n\n           <span class=\"n\">sync_call</span> <span class=\"o\">=</span> <span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">,</span>\n                               <span class=\"n\">collect_output</span><span class=\"o\">=</span><span class=\"n\">pk</span><span class=\"o\">.</span><span class=\"n\">max_jobs</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n           <span class=\"c1\"># Submit a work function with arguments to the threadpool</span>\n           <span class=\"n\">mt</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">sync_call</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'gcc'</span><span class=\"p\">,</span> <span class=\"s1\">'-c'</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"n\">o</span><span class=\"p\">])</span>\n\n\n<span class=\"nd\">@pk</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">build_c</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"s1\">'obj/*.o'</span><span class=\"p\">),</span> <span class=\"n\">o</span><span class=\"o\">=</span><span class=\"s1\">'main'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">build</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n\n   <span class=\"c1\"># Utilizing the automatic non string iterable</span>\n   <span class=\"c1\"># flattening here to pass ctx.inputs and ctx.outputs</span>\n\n   <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'gcc'</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">inputs</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">pk</span><span class=\"p\">,</span> <span class=\"n\">tasks</span><span class=\"o\">=</span><span class=\"n\">build</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"running-sub-pakefiles\">\n<h2>Running Sub Pakefiles</h2>\n<p>Pake is able to run itself through the use of <strong>pake.TaskContext.subpake</strong>\nand <strong>pake.subpake</strong>.</p>\n<p><strong>pake.subpake</strong> is meant to be used outside of tasks, and can even be\ncalled before pake is initialized.</p>\n<p><strong>pake.TaskContext.subpake</strong> is preferred for use inside of tasks because\nit handles writing to the task\u2019s output queue for you, without having to specify\nextra parameters to <strong>pake.subpake</strong> to get it working correctly.</p>\n<p><strong>pake.TaskContext</strong> instance is passed into the single argument of each task function,\nwhich you can in turn call <strong>subpake</strong> from.</p>\n<p>Defines can be exported to pakefiles ran with the <strong>subpake</strong> functions using <strong>pake.export</strong>.</p>\n<p><strong>pake.subpake</strong> and <strong>pake.TaskContext.subpake</strong> use the <strong>\u2013stdin-defines</strong> option of\npake to pass exported define values into the new process instance, which means you can overwrite your\nexported define values with <strong>-D/\u2013define</strong> in the subpake command arguments if you need to.</p>\n<p>Export / Subpake Example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pake</span>\n\n<span class=\"n\">pk</span> <span class=\"o\">=</span> <span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">init</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Try to get the CC define from the command line,</span>\n<span class=\"c1\"># default to 'gcc'.</span>\n\n<span class=\"n\">CC</span> <span class=\"o\">=</span> <span class=\"n\">pk</span><span class=\"o\">.</span><span class=\"n\">get_define</span><span class=\"p\">(</span><span class=\"s1\">'CC'</span><span class=\"p\">,</span> <span class=\"s1\">'gcc'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Export the CC variable's value to all invocations</span>\n<span class=\"c1\"># of pake.subpake or ctx.subpake as a define that can be</span>\n<span class=\"c1\"># retrieved with pk.get_define()</span>\n\n<span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">export</span><span class=\"p\">(</span><span class=\"s1\">'CC'</span><span class=\"p\">,</span> <span class=\"n\">CC</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># You can also export lists, dictionaries sets and tuples,</span>\n<span class=\"c1\"># as long as they only contain literal values.</span>\n<span class=\"c1\"># Literal values being: strings, integers, floats; and</span>\n<span class=\"c1\"># other lists, dicts, sets and tuples.  Collections must only</span>\n<span class=\"c1\"># contain literals, or objects that repr() into a parsable literal.</span>\n\n<span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">export</span><span class=\"p\">(</span><span class=\"s1\">'CC_FLAGS'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'-Wextra'</span><span class=\"p\">,</span> <span class=\"s1\">'-Wall'</span><span class=\"p\">])</span>\n\n\n<span class=\"c1\"># Nesting works with composite literals,</span>\n<span class=\"c1\"># as long as everything is a pure literal or something</span>\n<span class=\"c1\"># that str()'s into a literal.</span>\n\n<span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">export</span><span class=\"p\">(</span><span class=\"s1\">'STUFF'</span><span class=\"p\">,</span>\n            <span class=\"p\">[</span><span class=\"s1\">'you'</span><span class=\"p\">,</span>\n             <span class=\"p\">[</span><span class=\"s1\">'might'</span><span class=\"p\">,</span>\n              <span class=\"p\">(</span><span class=\"s1\">'be'</span><span class=\"p\">,</span>\n               <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span>\n                <span class=\"p\">{</span><span class=\"s1\">'bad'</span> <span class=\"p\">:</span>\n                     <span class=\"p\">[</span><span class=\"s1\">'person'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'if'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'you'</span><span class=\"p\">,</span> <span class=\"s1\">'do'</span><span class=\"p\">},</span> <span class=\"p\">(</span><span class=\"s1\">'this'</span><span class=\"p\">,)</span> <span class=\"p\">]]</span>\n                 <span class=\"p\">}])]])</span>\n\n\n<span class=\"c1\"># This export will be overrode in the next call</span>\n<span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">export</span><span class=\"p\">(</span><span class=\"s1\">'OVERRIDE_ME'</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Execute outside of a task, by default the stdout/stderr</span>\n<span class=\"c1\"># of the subscript goes to this scripts stdout.  The file</span>\n<span class=\"c1\"># object to which stdout gets written to can be specified</span>\n<span class=\"c1\"># with pake.subpake(..., stdout=(file))</span>\n\n<span class=\"c1\"># This command also demonstrates that you can override</span>\n<span class=\"c1\"># your exports using the -D/--define option</span>\n\n<span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">subpake</span><span class=\"p\">(</span><span class=\"s1\">'sometasks/pakefile.py'</span><span class=\"p\">,</span> <span class=\"s1\">'dotasks'</span><span class=\"p\">,</span> <span class=\"s1\">'-D'</span><span class=\"p\">,</span> <span class=\"s1\">'OVERRIDE_ME=True'</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># This task does not depend on anything or have any inputs/outputs</span>\n<span class=\"c1\"># it will basically only run if you explicitly specify it as a default</span>\n<span class=\"c1\"># task in pake.run, or specify it on the command line</span>\n\n<span class=\"nd\">@pk</span><span class=\"o\">.</span><span class=\"n\">task</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_phony_task</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Arguments are passed in a variadic parameter...</span>\n\n    <span class=\"c1\"># Specify that the \"foo\" task is to be ran.</span>\n    <span class=\"c1\"># The scripts output is written to this tasks output queue</span>\n\n    <span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">subpake</span><span class=\"p\">(</span><span class=\"s1\">'library/pakefile.py'</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">)</span>\n\n\n\n<span class=\"c1\"># Run this pake script, with a default task of 'my_phony_task'</span>\n\n<span class=\"n\">pake</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">pk</span><span class=\"p\">,</span> <span class=\"n\">tasks</span><span class=\"o\">=</span><span class=\"n\">my_phony_task</span><span class=\"p\">)</span>\n</pre>\n<p>Output from the example above:</p>\n<pre>*** enter subpake<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]</span>:\npake<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]</span>: Entering Directory <span class=\"s2\">\"(REST OF PATH...)/paketest/sometasks\"</span>\n<span class=\"o\">=====</span> Executing Task: <span class=\"s2\">\"dotasks\"</span>\nDo Tasks\npake<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]</span>: Exiting Directory <span class=\"s2\">\"(REST OF PATH...)/paketest/sometasks\"</span>\n*** <span class=\"nb\">exit</span> subpake<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]</span>:\n<span class=\"o\">=====</span> Executing Task: <span class=\"s2\">\"my_phony_task\"</span>\n*** enter subpake<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]</span>:\npake<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]</span>: Entering Directory <span class=\"s2\">\"(REST OF PATH...)/paketest/library\"</span>\n<span class=\"o\">=====</span> Executing Task: <span class=\"s2\">\"foo\"</span>\nFoo!\npake<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]</span>: Exiting Directory <span class=\"s2\">\"(REST OF PATH...)/paketest/library\"</span>\n*** <span class=\"nb\">exit</span> subpake<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]</span>:\n</pre>\n</div>\n<div id=\"running-pake\">\n<h2>Running pake</h2>\n<pre><span class=\"nb\">cd</span> your_pakefile_directory\n\n<span class=\"c1\"># Run pake with up to 10 tasks running in parallel\n</span>\npake -j <span class=\"m\">10</span>\n</pre>\n<p>pake will look for \u201cpakefile.py\u201d or \u201cpakefile\u201d in the current directory\nand run it.</p>\n<p>Or you can specify one or more files to run with <strong>-f/\u2013file</strong>. The\nswitch does not have multiple arguments, but it can be used more than\nonce to specify multiple files.</p>\n<p>For example:</p>\n<p><tt>pake <span class=\"pre\">-f</span> pakefile.py foo</tt></p>\n<p><tt>pake <span class=\"pre\">-f</span> your_pakefile_1.py <span class=\"pre\">-f</span> your_pakefile_2.py foo</tt></p>\n<p>You can also specify multiple tasks, but do not rely on unrelated tasks\nbeing executed in any specific order because they won\u2019t be. If there is\na specific order you need your tasks to execute in, the one that comes\nfirst should be declared a dependency of the one that comes second, then\nthe second task should be specified to run.</p>\n<p>When running parallel builds, leaf dependencies will start executing\npretty much simultaneously, and non related tasks that have a dependency\nchain may execute in parallel.</p>\n<p><tt>pake task unrelated_task order_independent_phony</tt></p>\n<div id=\"command-line-options\">\n<h3>Command Line Options</h3>\n<pre>usage: pake [-h] [-v] [-D DEFINE] [--stdin-defines] [-j JOBS] [-n]\n            [-C DIRECTORY] [-t] [-ti] [--sync-output {True, False, 1, 0}]\n            [-f FILE]\n            [tasks [tasks ...]]\n\npositional arguments:\n  tasks                 Build tasks.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n  -D DEFINE, --define DEFINE\n                        Add defined value.\n  --stdin-defines       Read defines from a Python Dictionary piped into\n                        stdin. Defines read with this option can be\n                        overwritten by defines specified on the command line\n                        with -D/--define.\n  -j JOBS, --jobs JOBS  Max number of parallel jobs. Using this option enables\n                        unrelated tasks to run in parallel with a max of N\n                        tasks running at a time.\n  -n, --dry-run         Use to preform a dry run, lists all tasks that will be\n                        executed in the next actual invocation.\n  -C DIRECTORY, --directory DIRECTORY\n                        Change directory before executing.\n  -t, --show-tasks      List all task names.\n  -ti, --show-task-info\n                        List all tasks along side their doc string. Only tasks\n                        with doc strings present will be shown.\n  --sync-output {True, False, 1, 0}\n                        Tell pake whether it should synchronize task output\n                        when running with multiple jobs. Console output can\n                        get scrambled under the right circumstances with this\n                        turned off, but pake will run slightly faster. This\n                        option will override any value in the PAKE_SYNC_OUTPUT\n                        environmental variable, and is inherited by subpake\n                        invocations unless the argument is re-passed with a\n                        different value or overridden in pake.init.\n  -f FILE, --file FILE  Pakefile path(s). This switch can be used more than\n                        once, all specified pakefiles will be executed in\n                        order with the current directory as the working\n                        directory (unless -C is specified).\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 5719680, "releases": {"0.17.0.3a1": [{"comment_text": "", "digests": {"md5": "8a2f77f8553c4faf406c7a2dc28c550d", "sha256": "37759e5ca5a55d5bc7a2edae842f9ff52b9aeb5653cf62234e0ccaa27fd9248a"}, "downloads": -1, "filename": "python-pake-0.17.0.3a1.tar.gz", "has_sig": false, "md5_digest": "8a2f77f8553c4faf406c7a2dc28c550d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72449, "upload_time": "2019-08-23T09:07:07", "upload_time_iso_8601": "2019-08-23T09:07:07.168602Z", "url": "https://files.pythonhosted.org/packages/e8/7b/b2102872ac02e154e719a39060abd2e23977390cbed59faaa65d81166eb9/python-pake-0.17.0.3a1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8a2f77f8553c4faf406c7a2dc28c550d", "sha256": "37759e5ca5a55d5bc7a2edae842f9ff52b9aeb5653cf62234e0ccaa27fd9248a"}, "downloads": -1, "filename": "python-pake-0.17.0.3a1.tar.gz", "has_sig": false, "md5_digest": "8a2f77f8553c4faf406c7a2dc28c550d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72449, "upload_time": "2019-08-23T09:07:07", "upload_time_iso_8601": "2019-08-23T09:07:07.168602Z", "url": "https://files.pythonhosted.org/packages/e8/7b/b2102872ac02e154e719a39060abd2e23977390cbed59faaa65d81166eb9/python-pake-0.17.0.3a1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:16:03 2020"}