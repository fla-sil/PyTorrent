{"info": {"author": "Justin Turner Arthur", "author_email": "justinarthur@gmail.com", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# socklocks\nThis is a proof of concept of inter-process synchronization using sockets to\ncoordinate the pausing and resuming of code across multiple processes.\n\nIt's implemented in Python 3 using only the standard libraries. The code can\nserve as reference for a faster implementation such as one written in C or Rust.\n\nIt's written by Justin Turner Arthur and is licensed under the Apache License\n2.0.\n\n## Usage\nThe primary lock classes are `SocketLock` and `SocketLockThreadSafe`. Like most\nlocks in Python, instances can be used as context managers using the `with`\nstatement.\n\n```python\nfrom socklocks import SocketLock\n\n\nlock = SocketLock()\nwith lock:\n    print('This code will run once lock is acquired.')\n    print('It will release the lock afterwards')\n```\n\nThe locks are purpose built for use in multiprocessing. They can be initialized\nbefore a process is forked then acquired and released from the sub-processes.\n```python\nfile_lock = SocketLock()\ndef hard_maths(increment):\n    # Only one invocation should read/write from the file at a time\n    with file_lock:\n        with open('number.txt', 'r') as f:\n            number = int(f.read())\n        number = math.factorial(number) + increment\n        with open('number.txt', 'w') as f:\n            f.write(str(number))\n\nmultiprocessing.Pool().map(hard_maths, range(5))\n```\n\nThey don't require forking. Multiple scripts could be run\nindependently that initialize the same effective lock by supplying the same\nname.\n```python\n# script1.py\nwith SocketLock('critical_resource1'):\n    do_stuff_to_res1()\n```\n```python\n# script2.py\nwith SocketLock('critical_resource1'):\n    do_other_stuff_to_res1()\n```\n\nIf multiple threads within a process will need to acquire the same lock, use\nthe thread-safe `SocketLockThreadSafe`.\n\n### Using it to work around AWS Lambda's missing SHM bug\nAWS Lambda execution environments have an operating system that requires a SHM\nfilesystem mount (RAM disk), but such a filesystem is never mounted. This bug\ndoesn't usually show itself until you need to do something that would use this\nmount, like use POSIX semaphores for inter-process synchronization.\n\nCPython's multiprocessing and concurrent.futures modules use POSIX semaphores in\nthis way and when the OS tries to use SHM files to power POSIX sempahores it\nfails:\n```python-traceback\nTraceback (most recent call last):\n  File \"/var/task/lambda_function.py\", line 15, in process_things\n    with ProcessPoolExecutor() as executor:\n  File \"/var/lang/lib/python3.6/concurrent/futures/process.py\", line 390, in __init__\n    EXTRA_QUEUED_CALLS)\n  File \"/var/lang/lib/python3.6/multiprocessing/context.py\", line 102, in Queue\n    return Queue(maxsize, ctx=self.get_context())\n  File \"/var/lang/lib/python3.6/multiprocessing/queues.py\", line 42, in __init__\n    self._rlock = ctx.Lock()\n  File \"/var/lang/lib/python3.6/multiprocessing/context.py\", line 67, in Lock\n    return Lock(ctx=self.get_context())\n  File \"/var/lang/lib/python3.6/multiprocessing/synchronize.py\", line 163, in __init__\n    SemLock.__init__(self, SEMAPHORE, 1, 1, ctx=ctx)\n  File \"/var/lang/lib/python3.6/multiprocessing/synchronize.py\", line 60, in __init__\n    unlink_now)\nOSError: [Errno 38] Function not implemented\n```\n\nTo get around this, you'd theoretically replace lock factories in your\nmultiprocessing context with corresponding socklocks constructors:\n```python\nimport socklocks\n\n# Raw multiprocessing:\nwith socklocks.replace_mp_context_locks(mp):\n    mp.Pool.map(do_work, work_items)\n\n# concurrent.futures in Python 3.7+:\nwith socklocks.replace_mp_context_locks(mp):\n    with concurrent.futures.ProcessPoolExecutor(mp_context=mp) as executor:\n        executor.map(do_work, work_items)\n```\n\u2026however, the multiprocessing queues and pools also use\n`multiprocessing.BoundedSemaphore`, which this library doesn't provide a\nreplacement for yet, so pools will not work\u2014only basic locking will.\n\n### Tests\nIn a local clone of the repo in a Python 3 env with socklocks installed:\n\n        pip install pytest\n        pytest\n\n## How it works\nAny attempt to acquire a lock starts with trying to bind a listening socket\nto an address determined by the lock's name/id. If some other candidate has\nalready bound to that address, we assume they have the lock and connect to the\ncurrent acquirer's listening socket. If it's our turn to acquire the lock, the\ncurrent acquirer passes a socket handle of the listening socket to us. Once\nwe're done with the lock, we pass a handle of the listening socket to the next\nconnection waiting or close the listening socket if no one else is waiting.\n\nBased on what's available in the Python implementation and operating system, the\nfollowing address types are used, in order of highest to lowest performance:\n* Linux Abstract Socket Name\n* Unix Domain Socket Path\n* IPv4 address 127.0.0.1 on a determined IP port\n\nSocket handles or file descriptors are passed using\n[sendmsg](http://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html)\nin POSIX-compliant systems that support the `SCM_RIGHTS` control message type.\nOtherwise, acquirers pass the listener their process ID and a handle is prepared\nfor the new acquirer using other means like\n[Winsock shared sockets](https://docs.microsoft.com/en-us/windows/desktop/winsock/shared-sockets-2).\n\n### Race Conditions that Result in Retried Operations\n* A lock-holder might see no incoming connections and start shutting down the\nlistening socket only to have a new requester connect before the listening\nsocket is closed.\n* An attempt to connect to a unix socket path might happen in between a\nlistening socket shutdown and the deletion of the file.\n* A new requester might try to connect to the current acquirer's listening\nsocket before the socket has been put in listening mode, resulting in\nconnection refusal.\n\nWhen Linux abstract sockets are used, many race conditions are mitigated\nbecause there is no file to clean up. \n\n### Known Issues\n* Currently only bytes or ASCII-compatible strings can be used as lock names.\n* Windows socket descriptor sharing is untested. Let me know how it goes.\n* When IP networking is the only infrastructure available, there is a higher\nchance of lock names colliding because the system's port range is used\nas a name space.\n* Only basic locks are implemented. Re-entrant locks and semaphores are not\n(yet?) part of this library.\n\n## Comparison to other lock Mechanisms\n### threading.Lock and _thread locks\nThe locks found in the Python standard library's `threading` and `_thread`\nmodules will generally perform better than the socket lock for synchronizing\ncode that only has multiple threads running from the same process. The point of\nusing sockets is to take advantage of the fact that they can be used for\ninter-process synchronization.\n\n### multiprocessing.Lock\n`SocketLockThreadSafe` can be used as a drop-in replacement for\n`multiprocessing.Lock`. This is useful if there are issues using the\n`multiprocessing.Lock` supplied by your Python platform. The non-threadsafe\n`SocketLock` will provide better performance where multi-threaded lock\nacquisition isn't going to happen. If unsure, go with the thread-safe option.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/JustinTArthur/socklocks", "keywords": "query string,querystring,URL,parser", "license": "Apache License 2.0", "maintainer": "", "maintainer_email": "", "name": "socklocks", "package_url": "https://pypi.org/project/socklocks/", "platform": "", "project_url": "https://pypi.org/project/socklocks/", "project_urls": {"Homepage": "https://github.com/JustinTArthur/socklocks"}, "release_url": "https://pypi.org/project/socklocks/0.1.0/", "requires_dist": null, "requires_python": "", "summary": "Library of Python locks that use sockets to keep processes synchronized.", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>socklocks</h1>\n<p>This is a proof of concept of inter-process synchronization using sockets to\ncoordinate the pausing and resuming of code across multiple processes.</p>\n<p>It's implemented in Python 3 using only the standard libraries. The code can\nserve as reference for a faster implementation such as one written in C or Rust.</p>\n<p>It's written by Justin Turner Arthur and is licensed under the Apache License\n2.0.</p>\n<h2>Usage</h2>\n<p>The primary lock classes are <code>SocketLock</code> and <code>SocketLockThreadSafe</code>. Like most\nlocks in Python, instances can be used as context managers using the <code>with</code>\nstatement.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">socklocks</span> <span class=\"kn\">import</span> <span class=\"n\">SocketLock</span>\n\n\n<span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"n\">SocketLock</span><span class=\"p\">()</span>\n<span class=\"k\">with</span> <span class=\"n\">lock</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'This code will run once lock is acquired.'</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'It will release the lock afterwards'</span><span class=\"p\">)</span>\n</pre>\n<p>The locks are purpose built for use in multiprocessing. They can be initialized\nbefore a process is forked then acquired and released from the sub-processes.</p>\n<pre><span class=\"n\">file_lock</span> <span class=\"o\">=</span> <span class=\"n\">SocketLock</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">hard_maths</span><span class=\"p\">(</span><span class=\"n\">increment</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Only one invocation should read/write from the file at a time</span>\n    <span class=\"k\">with</span> <span class=\"n\">file_lock</span><span class=\"p\">:</span>\n        <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'number.txt'</span><span class=\"p\">,</span> <span class=\"s1\">'r'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n            <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">())</span>\n        <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">factorial</span><span class=\"p\">(</span><span class=\"n\">number</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">increment</span>\n        <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'number.txt'</span><span class=\"p\">,</span> <span class=\"s1\">'w'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n            <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">number</span><span class=\"p\">))</span>\n\n<span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">Pool</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">hard_maths</span><span class=\"p\">,</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre>\n<p>They don't require forking. Multiple scripts could be run\nindependently that initialize the same effective lock by supplying the same\nname.</p>\n<pre><span class=\"c1\"># script1.py</span>\n<span class=\"k\">with</span> <span class=\"n\">SocketLock</span><span class=\"p\">(</span><span class=\"s1\">'critical_resource1'</span><span class=\"p\">):</span>\n    <span class=\"n\">do_stuff_to_res1</span><span class=\"p\">()</span>\n</pre>\n<pre><span class=\"c1\"># script2.py</span>\n<span class=\"k\">with</span> <span class=\"n\">SocketLock</span><span class=\"p\">(</span><span class=\"s1\">'critical_resource1'</span><span class=\"p\">):</span>\n    <span class=\"n\">do_other_stuff_to_res1</span><span class=\"p\">()</span>\n</pre>\n<p>If multiple threads within a process will need to acquire the same lock, use\nthe thread-safe <code>SocketLockThreadSafe</code>.</p>\n<h3>Using it to work around AWS Lambda's missing SHM bug</h3>\n<p>AWS Lambda execution environments have an operating system that requires a SHM\nfilesystem mount (RAM disk), but such a filesystem is never mounted. This bug\ndoesn't usually show itself until you need to do something that would use this\nmount, like use POSIX semaphores for inter-process synchronization.</p>\n<p>CPython's multiprocessing and concurrent.futures modules use POSIX semaphores in\nthis way and when the OS tries to use SHM files to power POSIX sempahores it\nfails:</p>\n<pre>Traceback (most recent call last):\n  File \"/var/task/lambda_function.py\", line 15, in process_things\n    with ProcessPoolExecutor() as executor:\n  File \"/var/lang/lib/python3.6/concurrent/futures/process.py\", line 390, in __init__\n    EXTRA_QUEUED_CALLS)\n  File \"/var/lang/lib/python3.6/multiprocessing/context.py\", line 102, in Queue\n    return Queue(maxsize, ctx=self.get_context())\n  File \"/var/lang/lib/python3.6/multiprocessing/queues.py\", line 42, in __init__\n    self._rlock = ctx.Lock()\n  File \"/var/lang/lib/python3.6/multiprocessing/context.py\", line 67, in Lock\n    return Lock(ctx=self.get_context())\n  File \"/var/lang/lib/python3.6/multiprocessing/synchronize.py\", line 163, in __init__\n    SemLock.__init__(self, SEMAPHORE, 1, 1, ctx=ctx)\n  File \"/var/lang/lib/python3.6/multiprocessing/synchronize.py\", line 60, in __init__\n    unlink_now)\nOSError: [Errno 38] Function not implemented\n</pre>\n<p>To get around this, you'd theoretically replace lock factories in your\nmultiprocessing context with corresponding socklocks constructors:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">socklocks</span>\n\n<span class=\"c1\"># Raw multiprocessing:</span>\n<span class=\"k\">with</span> <span class=\"n\">socklocks</span><span class=\"o\">.</span><span class=\"n\">replace_mp_context_locks</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">):</span>\n    <span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">Pool</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">do_work</span><span class=\"p\">,</span> <span class=\"n\">work_items</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># concurrent.futures in Python 3.7+:</span>\n<span class=\"k\">with</span> <span class=\"n\">socklocks</span><span class=\"o\">.</span><span class=\"n\">replace_mp_context_locks</span><span class=\"p\">(</span><span class=\"n\">mp</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">concurrent</span><span class=\"o\">.</span><span class=\"n\">futures</span><span class=\"o\">.</span><span class=\"n\">ProcessPoolExecutor</span><span class=\"p\">(</span><span class=\"n\">mp_context</span><span class=\"o\">=</span><span class=\"n\">mp</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">executor</span><span class=\"p\">:</span>\n        <span class=\"n\">executor</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">do_work</span><span class=\"p\">,</span> <span class=\"n\">work_items</span><span class=\"p\">)</span>\n</pre>\n<p>\u2026however, the multiprocessing queues and pools also use\n<code>multiprocessing.BoundedSemaphore</code>, which this library doesn't provide a\nreplacement for yet, so pools will not work\u2014only basic locking will.</p>\n<h3>Tests</h3>\n<p>In a local clone of the repo in a Python 3 env with socklocks installed:</p>\n<pre><code>    pip install pytest\n    pytest\n</code></pre>\n<h2>How it works</h2>\n<p>Any attempt to acquire a lock starts with trying to bind a listening socket\nto an address determined by the lock's name/id. If some other candidate has\nalready bound to that address, we assume they have the lock and connect to the\ncurrent acquirer's listening socket. If it's our turn to acquire the lock, the\ncurrent acquirer passes a socket handle of the listening socket to us. Once\nwe're done with the lock, we pass a handle of the listening socket to the next\nconnection waiting or close the listening socket if no one else is waiting.</p>\n<p>Based on what's available in the Python implementation and operating system, the\nfollowing address types are used, in order of highest to lowest performance:</p>\n<ul>\n<li>Linux Abstract Socket Name</li>\n<li>Unix Domain Socket Path</li>\n<li>IPv4 address 127.0.0.1 on a determined IP port</li>\n</ul>\n<p>Socket handles or file descriptors are passed using\n<a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html\" rel=\"nofollow\">sendmsg</a>\nin POSIX-compliant systems that support the <code>SCM_RIGHTS</code> control message type.\nOtherwise, acquirers pass the listener their process ID and a handle is prepared\nfor the new acquirer using other means like\n<a href=\"https://docs.microsoft.com/en-us/windows/desktop/winsock/shared-sockets-2\" rel=\"nofollow\">Winsock shared sockets</a>.</p>\n<h3>Race Conditions that Result in Retried Operations</h3>\n<ul>\n<li>A lock-holder might see no incoming connections and start shutting down the\nlistening socket only to have a new requester connect before the listening\nsocket is closed.</li>\n<li>An attempt to connect to a unix socket path might happen in between a\nlistening socket shutdown and the deletion of the file.</li>\n<li>A new requester might try to connect to the current acquirer's listening\nsocket before the socket has been put in listening mode, resulting in\nconnection refusal.</li>\n</ul>\n<p>When Linux abstract sockets are used, many race conditions are mitigated\nbecause there is no file to clean up.</p>\n<h3>Known Issues</h3>\n<ul>\n<li>Currently only bytes or ASCII-compatible strings can be used as lock names.</li>\n<li>Windows socket descriptor sharing is untested. Let me know how it goes.</li>\n<li>When IP networking is the only infrastructure available, there is a higher\nchance of lock names colliding because the system's port range is used\nas a name space.</li>\n<li>Only basic locks are implemented. Re-entrant locks and semaphores are not\n(yet?) part of this library.</li>\n</ul>\n<h2>Comparison to other lock Mechanisms</h2>\n<h3>threading.Lock and _thread locks</h3>\n<p>The locks found in the Python standard library's <code>threading</code> and <code>_thread</code>\nmodules will generally perform better than the socket lock for synchronizing\ncode that only has multiple threads running from the same process. The point of\nusing sockets is to take advantage of the fact that they can be used for\ninter-process synchronization.</p>\n<h3>multiprocessing.Lock</h3>\n<p><code>SocketLockThreadSafe</code> can be used as a drop-in replacement for\n<code>multiprocessing.Lock</code>. This is useful if there are issues using the\n<code>multiprocessing.Lock</code> supplied by your Python platform. The non-threadsafe\n<code>SocketLock</code> will provide better performance where multi-threaded lock\nacquisition isn't going to happen. If unsure, go with the thread-safe option.</p>\n\n          </div>"}, "last_serial": 4758503, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "3c9dd02f3d562730e274695965a14e4c", "sha256": "b645b0f3713ae8d628ab339c1aa2982fae28efd7a5d5de4d52db7be931d2da6e"}, "downloads": -1, "filename": "socklocks-0.1.0-py3-none-any.whl", "has_sig": true, "md5_digest": "3c9dd02f3d562730e274695965a14e4c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11383, "upload_time": "2019-01-30T07:47:47", "upload_time_iso_8601": "2019-01-30T07:47:47.358606Z", "url": "https://files.pythonhosted.org/packages/f1/c3/9a5aeaf0e31badb561e0753372f17163a3907b25c0db9da9604bd418dbda/socklocks-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e50932322093920be207edea8b8335ec", "sha256": "d9c7ac83a7adb85247db37a34180456ae975844c756acac7f82adf6934651a1b"}, "downloads": -1, "filename": "socklocks-0.1.0.tar.gz", "has_sig": true, "md5_digest": "e50932322093920be207edea8b8335ec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7441, "upload_time": "2019-01-30T07:47:58", "upload_time_iso_8601": "2019-01-30T07:47:58.995191Z", "url": "https://files.pythonhosted.org/packages/33/07/21d808f751fe39fa1992457dd1aa3fec7947c5a666dde5e46815d311a197/socklocks-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3c9dd02f3d562730e274695965a14e4c", "sha256": "b645b0f3713ae8d628ab339c1aa2982fae28efd7a5d5de4d52db7be931d2da6e"}, "downloads": -1, "filename": "socklocks-0.1.0-py3-none-any.whl", "has_sig": true, "md5_digest": "3c9dd02f3d562730e274695965a14e4c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11383, "upload_time": "2019-01-30T07:47:47", "upload_time_iso_8601": "2019-01-30T07:47:47.358606Z", "url": "https://files.pythonhosted.org/packages/f1/c3/9a5aeaf0e31badb561e0753372f17163a3907b25c0db9da9604bd418dbda/socklocks-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e50932322093920be207edea8b8335ec", "sha256": "d9c7ac83a7adb85247db37a34180456ae975844c756acac7f82adf6934651a1b"}, "downloads": -1, "filename": "socklocks-0.1.0.tar.gz", "has_sig": true, "md5_digest": "e50932322093920be207edea8b8335ec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7441, "upload_time": "2019-01-30T07:47:58", "upload_time_iso_8601": "2019-01-30T07:47:58.995191Z", "url": "https://files.pythonhosted.org/packages/33/07/21d808f751fe39fa1992457dd1aa3fec7947c5a666dde5e46815d311a197/socklocks-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:06:59 2020"}