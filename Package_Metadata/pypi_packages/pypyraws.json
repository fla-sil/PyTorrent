{"info": {"author": "Thomas Gaigher", "author_email": "info@pypyr.io", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Build Tools", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "#################\npypyr aws plug-in\n#################\n\n.. image:: https://pypyr.io/images/pypyr-logo-small.png\n    :alt: pypyr-logo\n    :align: left\n\n*pypyr*\n  pronounce how you like, but I generally say *piper* as in \"piping down the\n  valleys wild\"\n\n  `pypyr <https://github.com/pypyr/pypyr-cli>`__ is a command line interface to\n  run pipelines defined in yaml.\n\n*the pypyr aws plug-in*\n  Run anything on aws. No really, anything. If the aws api supports it, the\n  pypyr aws plug-in supports it.\n\n  It's a pretty easy way of invoking the aws api as a step\n  in a series of steps.\n  Why use this when you could just use the aws-cli instead? The aws cli is all\n  kinds of awesome, but I find more often than not it's not just one or two aws\n  *ad hoc* cli or aws api methods you have to execute, but especially when\n  automating and scripting you actually need to run a sequence of commands,\n  where the output of a previous command influences what you pass to the next\n  command.\n\n  Sure, you can bash it up, and I do that too, but running it as a pipeline\n  via pypyr has actually made my life quite a bit easier in terms of not having\n  to deal with conditionals, error traps and input validation.\n\n|build-status| |coverage| |pypi|\n\n.. contents::\n\n.. section-numbering::\n\n************\nInstallation\n************\n\npip\n===\n.. code-block:: bash\n\n  # pip install --upgrade pypyraws\n\npypyraws depends on the ``pypyr`` cli. The above ``pip`` will install it for\nyou if you don't have it already.\n\nPython version\n==============\nTested against Python >=3.6\n\n********\nExamples\n********\nIf you prefer reading code to reading words, https://github.com/pypyr/pypyr-example\n\n*****\nsteps\n*****\n+-------------------------------+-------------------------------------------------+------------------------------+\n| **step**                      | **description**                                 | **input context properties** |\n+-------------------------------+-------------------------------------------------+------------------------------+\n| `pypyraws.steps.client`_      | Execute any low-level aws client method         | awsClientIn (dict)           |\n+-------------------------------+-------------------------------------------------+------------------------------+\n| `pypyraws.steps.ecswaitprep`_ | Run me after an ecs task run or stop to prepare | awsClientOut (dict)          |\n|                               | an ecs waiter.                                  |                              |\n|                               |                                                 | awsEcsWaitPrepCluster (str)  |\n+-------------------------------+-------------------------------------------------+------------------------------+\n| `pypyraws.steps.s3fetchjson`_ | Fetch a json file from s3 into the pypyr        | s3Fetch (dict)               |\n|                               | context.                                        |                              |\n+-------------------------------+-------------------------------------------------+------------------------------+\n| `pypyraws.steps.s3fetchyaml`_ | Fetch a yaml file from s3 into the pypyr        | s3Fetch (dict)               |\n|                               | context.                                        |                              |\n+-------------------------------+-------------------------------------------------+------------------------------+\n| `pypyraws.steps.wait`_        | Wait for an aws client waiter method to         | awsWaitIn (dict)             |\n|                               | complete.                                       |                              |\n+-------------------------------+-------------------------------------------------+------------------------------+\n| `pypyraws.steps.waitfor`_     | Wait for any aws client method to complete,     | awsWaitFor (dict)            |\n|                               | even when it doesn't have an official waiter.   |                              |\n+-------------------------------+-------------------------------------------------+------------------------------+\n\npypyraws.steps.client\n=====================\nWhat can I do with pypyraws.steps.client?\n-----------------------------------------\nThis step provides an easy way of getting at the low-level AWS api from the\npypyr pipeline runner. So in short, pretty much anything you can do with the\nAWS api, you got it, as the Big O might have said.\n\nThis step lets you specify the service name and the service method you want to\nexecute dynamically. You can also control the service header arguments and the\nmethod arguments themselves.\n\nThe arguments you pass to the service and its methods are exactly as given by\nthe AWS help documentation. So you do not have to learn yet another\nconfiguration based abstraction on top of the AWS api that might not even\nsupport all the methods you need.\n\nYou can actually pretty much just grab the json as written from the excellent\nAWS help docs, paste it into some json that pypyr consumes and tadaaa!\nAlternatively, grab the samples from the boto3 python documentation to include\nin some yaml - the python dictionary structures map to yaml without too much\nfaff.\n\nSupported AWS services\n----------------------\nClients provide a low-level interface to AWS whose methods map close to 1:1\nwith the AWS REST service APIs. All service operations are supported by clients.\n\nRun any method on any of the following aws low-level client services:\n\n  acm, apigateway, application-autoscaling, appstream, autoscaling,\n  batch, budgets, clouddirectory, cloudformation, cloudfront, cloudhsm,\n  cloudsearch, cloudsearchdomain, cloudtrail, cloudwatch, codebuild, codecommit,\n  codedeploy, codepipeline, codestar, cognito-identity, cognito-idp,\n  cognito-sync, config, cur, datapipeline, devicefarm, directconnect, discovery,\n  dms, ds, dynamodb, dynamodbstreams, ec2, ecr, ecs, efs, elasticache,\n  elasticbeanstalk, elastictranscoder, elb, elbv2, emr, es, events, firehose,\n  gamelift, glacier, health, iam, importexport, inspector, iot, iot-data,\n  kinesis, kinesisanalytics, kms, lambda, lex-models, lex-runtime, lightsail,\n  logs, machinelearning, marketplace-entitlement, marketplacecommerceanalytics,\n  meteringmarketplace, mturk, opsworks, opsworkscm, organizations, pinpoint,\n  polly, rds, redshift, rekognition, resourcegroupstaggingapi, route53,\n  route53domains, s3, sdb, servicecatalog, ses, shield, sms, snowball, sns, sqs,\n  ssm, stepfunctions, storagegateway, sts, support, swf, waf, waf-regional,\n  workdocs, workspaces, xray\n\nYou can find full details for the supported services and what methods you can\nrun against them here:  http://boto3.readthedocs.io/en/latest/reference/services/\n\nWith the speed of new features and services AWS introduces, it's pretty\nunlikely I'll get round to updating the list each and every time.\n\npypyr-aws will automatically support new services AWS releases for the boto3\nclient, in case the list above gets out of date. So while the document might\nnot update, the code already will dynamically use new features and services on\nthe boto3 client.\n\npypyr context\n-------------\nRequires the following context items:\n\n.. code-block:: yaml\n\n  awsClientIn:\n    serviceName: 'aws service name here'\n    methodName: 'execute this method of the aws service'\n    clientArgs: # optional\n      arg1Name: arg1Value\n      arg2Name: arg2Value\n    methodArgs: # optional\n      arg1Name: arg1Value\n      arg2Name: arg2Value\n\nThe *awsClientIn* context supports text `Substitutions`_.\n\nAWS response\n------------\nAfter this step completes the full response is available to subsequent steps\nin the pypyr context in the *awsClientOut* key.\n\nSample pipeline\n---------------\nHere is some sample yaml of what a pipeline using the pypyr-aws plug-in *client*\nstep could look like:\n\n.. code-block:: yaml\n\n  context_parser: pypyr.parser.keyvaluepairs\n  steps:\n    - name: pypyraws.steps.client\n      description: upload a file to s3\n      in:\n        awsClientIn:\n          serviceName: s3\n          methodName: upload_file\n          methodArgs:\n            Filename: ./testfiles/arb.txt\n            Bucket: '{bucket}'\n            Key: arb.txt\n\nIf you saved this yaml as ``./pipelines/go-go-s3.yaml``, you can run\nfrom ./ the following to upload *arb.txt* to your specified bucket:\n\n.. code-block:: bash\n\n  $ pypyr go-go-s3 \"bucket=myuniquebucketname\"\n\n\nSee a worked example for `pypyr aws s3 here\n<https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-s3.yaml>`__.\n\npypyraws.steps.ecswaitprep\n==========================\nRun me after an ecs task run or stop to prepare an ecs waiter.\n\nPrepares the awsWaitIn context key for pypyraws.steps.wait\n\nAvailable ecs waiters are:\n\n- ServicesInactive\n- ServicesStable\n- TasksRunning\n- TasksStopped\n\nFull details here: http://boto3.readthedocs.io/en/latest/reference/services/ecs.html#waiters\n\nUse this step after any of the following ecs client methods if you want to use\none of the ecs waiters to wait for a specific state:\n\n- describe_services\n- describe_tasks\n- list_services - specify awsEcsWaitPrepCluster if you don't want default\n- list_tasks - specify awsEcsWaitPrepCluster if you don't want default\n- run_task\n- start_task\n- stop_task\n- update_service\n\nYou don't have to use this step, you could always just construct the awsWaitIn\ndictionary in context yourself. It just so happens this step saves you some\nlegwork to do so.\n\nRequired context:\n\n- awsClientOut\n\n  - dict. mandatory.\n  - This is the context key that any ecs command executed by\n    pypyraws.steps.service adds. Chances are pretty good you don't want to\n    construct this by hand yourself - the idea is to use the output as\n    generated by one of the supported ecs methods.\n\n- awsEcsWaitPrepCluster\n\n  - string. optional.\n  - The short name or full arn of the cluster that hosts the task to\n    describe. If you do not specify a cluster, the default cluster is\n    assumed. For most of the ecs methods the code automatically deduces the\n    cluster from awsClientOut, so don't worry about it.\n  - But, when following list_services and list_tasks, you have to specify\n    this parameter.\n  - Specifying this parameter will override any automatically deduced cluster arn\n\nSee a worked example for `pypyr aws ecs here\n<https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-ecs.yaml>`__.\n\npypyraws.steps.s3fetchjson\n==========================\nFetch a json file from s3 and put the json values into context.\n\nRequired input context is:\n\n.. code-block:: yaml\n\n  s3Fetch:\n    clientArgs: # optional\n      arg1Name: arg1Value\n    methodArgs:\n      Bucket: '{bucket}'\n      Key: arb.json\n    outKey: 'destination pypyr context key' # optional\n\n- *clientArgs* are passed to the aws s3 client constructor. These are optional.\n- *methodArgs* are passed the the s3 ``get_object`` call. The minimum required\n  values are:\n\n  - Bucket\n  - Key\n\n- Check here for all available arguments (including SSE server-side encryption):\n  http://boto3.readthedocs.io/en/latest/reference/services/s3.html#S3.Client.get_object\n- *outKey* writes fetched json to this context key. If not specified, json\n  writes directly to context root.\n\nJson parsed from the file will be merged into the pypyr context. This will\noverwrite existing values if the same keys are already in there.\n\nI.e if file json has ``{'eggs' : 'boiled'}``, but context ``{'eggs': 'fried'}``\nalready exists, returned ``context['eggs']`` will be 'boiled'.\n\nIf *outKey* is not specified, the json should not be an Array [] at the root\nlevel, but rather an Object {}.\n\nThe *s3Fetch* input context supports text `Substitutions`_.\n\nSee a worked example for `pypyr aws s3fetch here\n<https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-s3fetch.yaml>`__.\n\npypyraws.steps.s3fetchyaml\n==========================\nFetch a yaml file from s3 and put the yaml structure into context.\n\nRequired input context is:\n\n.. code-block:: yaml\n\n  s3Fetch:\n    clientArgs: # optional\n      arg1Name: arg1Value\n    methodArgs:\n      Bucket: '{bucket}'\n      Key: arb.yaml\n    outKey: 'destination pypyr context key' # optional\n\n- *clientArgs* are passed to the aws s3 client constructor. These are optional.\n- *methodArgs* are passed the the s3 ``get_object`` call. The minimum required\n  values are:\n\n  - Bucket\n  - Key\n\n- Check here for all available arguments (including SSE server-side encryption):\n  http://boto3.readthedocs.io/en/latest/reference/services/s3.html#S3.Client.get_object\n- *outKey* writes fetched yaml to this context key. If not specified, yaml\n  writes directly to context root.\n\nThe *s3Fetch* context supports text `Substitutions`_.\n\nYaml parsed from the file will be merged into the pypyr context. This will\noverwrite existing values if the same keys are already in there.\n\nI.e if file yaml has\n\n.. code-block:: yaml\n\n  eggs: boiled\n\nbut context ``{'eggs': 'fried'}`` already exists, returned ``context['eggs']``\nwill be 'boiled'.\n\nIf *outKey* is not specified, the yaml should not be a list at the top level,\nbut rather a mapping. So the top-level yaml should not look like this:\n\n.. code-block:: yaml\n\n  - eggs\n  - ham\n\nbut rather like this:\n\n.. code-block:: yaml\n\n  breakfastOfChampions:\n    - eggs\n    - ham\n\nSee a worked example for `pypyr aws s3fetch here\n<https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-s3fetch.yaml>`__.\n\npypyraws.steps.wait\n===================\nWait for things in AWS to complete before continuing pipeline.\n\nRun any low-level boto3 client wait() from get_waiter.\n\nWaiters use a client's service operations to poll the status of an AWS resource\nand suspend execution until the AWS resource reaches the state that the waiter\nis polling for or a failure occurs while polling.\n\nhttp://boto3.readthedocs.io/en/latest/guide/clients.html#waiters\n\nThe input context requires:\n\n.. code-block:: yaml\n\n  awsWaitIn:\n    serviceName: 'service name' # Available services here: http://boto3.readthedocs.io/en/latest/reference/services/\n    waiterName: 'waiter name' # Check service docs for available waiters for each service\n    waiterArgs:\n      arg1Name: arg1Value # optional. Dict. kwargs for get_waiter\n    waitArgs:\n      arg1Name: arg1Value #optional. Dict. kwargs for wait\n\nThe *awsWaitIn* context supports text `Substitutions`_.\n\npypyraws.steps.waitfor\n======================\nCustom waiter for any aws client operation. Where `pypyraws.steps.wait`_ uses\nthe official AWS waiters from the low-level client api, this step allows you to\nexecute *any* aws low-level client method and wait for a specified field in\nthe response to become the value you want it to be.\n\nThis is especially handy for things like Beanstalk, because Elastic Beanstalk\ndoes not have Waiters for environment creation.\n\nThe input context looks like this:\n\n.. code-block:: yaml\n\n  awsWaitFor:\n    awsClientIn: # required. awsClientIn allows the same arguments as pypyraws.steps.client.\n      serviceName: elasticbeanstalk\n      methodName: describe_environments\n      methodArgs:\n          ApplicationName: my wonderful beanstalk default application\n          EnvironmentNames:\n            - my-wonderful-environment\n          VersionLabel: v0.1\n    waitForField: '{Environments[0][Status]}' # required. format expression for field name to check in awsClient response\n    toBe: Ready # required. Stop waiting when waitForField equals this value\n    pollInterval: 30 # optional. Seconds to wait between polling attempts. Defaults to 30 if not specified.\n    maxAttempts: 10 # optional. Defaults to 10 if not specified.\n    errorOnWaitTimeout: True # optional. Defaults to True if not specified. Stop processing if maxAttempts exhausted without reaching toBe value.\n\nSee `pypyraws.steps.client`_ for a full listing of available arguments under\n*awsClientIn*.\n\nIf ``errorOnWaitTimeout`` is True and ``max_attempts`` exhaust before reaching\nthe desired target state, pypyr will stop processing with a\n``pypyraws.errors.WaitTimeOut`` error.\n\nOnce this step completes it adds ``awsWaitForTimedOut`` to the pypyr context.\nThis is a boolean value with values:\n\n+--------------------------+---------------------------------------------------+\n| awsWaitForTimedOut       | Description                                       |\n+--------------------------+---------------------------------------------------+\n| True                     | ``errorOnWaitTimeout=False`` and ``max_attempts`` |\n|                          | exhausted without reaching ``toBe``.              |\n+--------------------------+---------------------------------------------------+\n| False                    | ``waitForField``'s value becomes ``toBe`` within  |\n|                          | ``max_attempts``.                                 |\n+--------------------------+---------------------------------------------------+\n\n\nThe *awsWaitFor* context supports text `Substitutions`_. Do note that while\n``waitForField`` uses substitution style format strings, the substitutions are\nmade against the response object that returns from the aws client call specified\nin *awsClientIn*, and not from the pypyr context itself.\n\nSee a worked example for an `elastic beanstalk custom waiter for environmment\ncreation here\n<https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-beanstalk-waitfor.yaml>`__.\n\n*************\nSubstitutions\n*************\nYou can use substitution tokens, aka string interpolation, where specified for\ncontext items. This substitutes anything between {curly braces} with the\ncontext value for that key. This also works where you have dictionaries/lists\ninside dictionaries/lists. For example, if your context looked like this:\n\n.. code-block:: yaml\n\n  bucketValue: the.bucket\n  keyValue: dont.kick\n  moreArbText: wild\n  awsClientIn:\n    serviceName: s3\n    methodName: get_object\n    methodArgs:\n      Bucket: '{bucketValue}'\n      Key: '{keyValue}'\n\nThis will run s3 get_object to retrieve file *dont.kick* from *the.bucket*.\n\n- *Bucket: '{bucketValue}'* becomes *Bucket: the.bucket*\n- *Key: '{keyValue}'* becomes *Key: dont.kick*\n\nIn json & yaml, curlies need to be inside quotes to make sure they parse as\nstrings.\n\nEscape literal curly braces with doubles: {{ for {, }} for }\n\nSee a worked example `for substitutions here\n<https://github.com/pypyr/pypyr-example/tree/master/pipelines/substitutions.yaml>`__.\n\n\n******************\naws authentication\n******************\nConfiguring credentials\n=======================\npypyr-aws pretty much just uses the underlying boto3 authentication mechanisms.\nMore info here: http://boto3.readthedocs.io/en/latest/guide/configuration.html\n\nThis means any of the following will work:\n\n- If you are running inside of AWS - on EC2 or inside an ECS container, it will\n  automatically use IAM role credentials if it does not find credentials in any\n  of the other places listed below.\n- In the pypyr context\n\n  .. code-block:: python\n\n    context['awsClientIn']['clientArgs'] = {\n        aws_access_key_id: ACCESS_KEY,\n        aws_secret_access_key: SECRET_KEY,\n        aws_session_token: SESSION_TOKEN,\n      }\n\n- $ENV variables\n\n  - AWS_ACCESS_KEY_ID\n  - AWS_SECRET_ACCESS_KEY\n  - AWS_SESSION_TOKEN\n\n- Credentials file at *~/.aws/credentials* or *~/.aws/config*\n\n  - If you have the aws-cli installed, run ``aws configure`` to get these\n    configured for you automatically.\n\nTip: On dev boxes I generally don't bother with credentials, because chances\nare pretty good that I have the aws-cli installed already anyway, so pypyr\nwill just re-use the aws shared configuration files that are there anyway.\n\nEnsure secrets stay secret\n==========================\nBe safe! Don't hard-code your aws credentials. Don't check credentials into a\npublic repo.\n\nTip: if you're running pypyr inside of aws - e.g in an ec2 instance or an ecs\ncontainer that is running under an IAM role, you don't actually *need*\nexplicitly to configure credentials for pypyr-aws.\n\nDo remember not to fling your key & secret around as shell arguments - it could\nvery easily leak that way into logs or expose via a ``ps``. I generally use one\nof the pypyr built-in context parsers like *pypyr.parser.jsonfile* or\n*pypyr.parser.yamlfile*, see\n`here for details <https://github.com/pypyr/pypyr-cli#built-in-context-parsers>`__.\n\nDo remember also that $ENV variables are not a particularly secure place to\nkeep your secrets.\n\n*******\nTesting\n*******\nTesting without worrying about dependencies\n===========================================\nRun from tox to test the packaging cycle inside a virtual env, plus run all\ntests:\n\n.. code-block:: bash\n\n    # just run tests\n    $ tox -e dev -- tests\n    # run tests, validate README.rst, run flake8 linter\n    $ tox -e stage -- tests\n\nIf tox is taking too long\n=========================\nThe test framework is pytest. If you only want to run tests:\n\n.. code-block:: bash\n\n  $ pip install -e .[dev,test]\n\nDay-to-day testing\n==================\n- Tests live under */tests* (surprising, eh?). Mirror the directory structure of\n  the code being tested.\n- Prefix a test definition with *test_* - so a unit test looks like\n\n  .. code-block:: python\n\n    def test_this_should_totally_work():\n\n- To execute tests, from root directory:\n\n  .. code-block:: bash\n\n    pytest tests\n\n- For a bit more info on running tests:\n\n  .. code-block:: bash\n\n    pytest --verbose [path]\n\n- To execute a specific test module:\n\n  .. code-block:: bash\n\n    pytest tests/unit/arb_test_file.py\n\n*****\nHelp!\n*****\nDon't Panic! For help, community or talk, join the chat on |discord|!\n\n**********\nContribute\n**********\nDevelopers\n==========\nFor information on how to help with pypyr, run tests and coverage, please do\ncheck out the `contribution guide <https://github.com/pypyr/pypyr-cli/blob/master/CONTRIBUTING.rst>`_.\n\nBugs\n====\nWell, you know. No one's perfect. Feel free to `create an issue\n<https://github.com/pypyr/pypyr-aws/issues/new>`_.\n\n\n.. |build-status| image:: https://api.shippable.com/projects/58efdfe130eb380700e559a4/badge?branch=master\n                    :alt: build status\n                    :target: https://app.shippable.com/github/pypyr/pypyr-aws\n\n.. |coverage| image:: https://api.shippable.com/projects/58efdfe130eb380700e559a4/coverageBadge?branch=master\n                :alt: coverage status\n                :target: https://app.shippable.com/github/pypyr/pypyr-aws\n\n.. |pypi| image:: https://badge.fury.io/py/pypyraws.svg\n                :alt: pypi version\n                :target: https://pypi.python.org/pypi/pypyraws/\n                :align: bottom\n\n.. |discord| replace:: `discord <https://discordapp.com/invite/8353JkB>`__\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pypyr/pypyr-aws", "keywords": "pypyr aws plugin devops pipeline runner", "license": "Apache License 2.0", "maintainer": "", "maintainer_email": "", "name": "pypyraws", "package_url": "https://pypi.org/project/pypyraws/", "platform": "", "project_url": "https://pypi.org/project/pypyraws/", "project_urls": {"Homepage": "https://github.com/pypyr/pypyr-aws"}, "release_url": "https://pypi.org/project/pypyraws/1.1.1/", "requires_dist": ["pypyr", "boto3", "ruamel.yaml", "bumpversion; extra == 'deploy'", "twine; extra == 'deploy'", "check-manifest; extra == 'dev'", "flake8; extra == 'dev'", "pytest; extra == 'test'", "pytest-cov; extra == 'test'", "tox; extra == 'test'"], "requires_python": "", "summary": "pypyr pipeline runner AWS plugin. Steps for ECS, S3, Beanstalk.", "version": "1.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <img alt=\"pypyr-logo\" class=\"align-left\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/40de27d5839d7442962020f105dc03b040632c2f/68747470733a2f2f70797079722e696f2f696d616765732f70797079722d6c6f676f2d736d616c6c2e706e67\">\n<dl>\n<dt><em>pypyr</em></dt>\n<dd><p>pronounce how you like, but I generally say <em>piper</em> as in \u201cpiping down the\nvalleys wild\u201d</p>\n<p><a href=\"https://github.com/pypyr/pypyr-cli\" rel=\"nofollow\">pypyr</a> is a command line interface to\nrun pipelines defined in yaml.</p>\n</dd>\n<dt><em>the pypyr aws plug-in</em></dt>\n<dd><p>Run anything on aws. No really, anything. If the aws api supports it, the\npypyr aws plug-in supports it.</p>\n<p>It\u2019s a pretty easy way of invoking the aws api as a step\nin a series of steps.\nWhy use this when you could just use the aws-cli instead? The aws cli is all\nkinds of awesome, but I find more often than not it\u2019s not just one or two aws\n<em>ad hoc</em> cli or aws api methods you have to execute, but especially when\nautomating and scripting you actually need to run a sequence of commands,\nwhere the output of a previous command influences what you pass to the next\ncommand.</p>\n<p>Sure, you can bash it up, and I do that too, but running it as a pipeline\nvia pypyr has actually made my life quite a bit easier in terms of not having\nto deal with conditionals, error traps and input validation.</p>\n</dd>\n</dl>\n<p><a href=\"https://app.shippable.com/github/pypyr/pypyr-aws\" rel=\"nofollow\"><img alt=\"build status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/48d39ab7e0ecd439ef7dd8e4a2f0314cf1ce9c82/68747470733a2f2f6170692e736869707061626c652e636f6d2f70726f6a656374732f3538656664666531333065623338303730306535353961342f62616467653f6272616e63683d6d6173746572\"></a> <a href=\"https://app.shippable.com/github/pypyr/pypyr-aws\" rel=\"nofollow\"><img alt=\"coverage status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1b2756cfcca40a0dc541d84657a86be424fd2894/68747470733a2f2f6170692e736869707061626c652e636f6d2f70726f6a656374732f3538656664666531333065623338303730306535353961342f636f76657261676542616467653f6272616e63683d6d6173746572\"></a> <a href=\"https://pypi.python.org/pypi/pypyraws/\" rel=\"nofollow\"><img alt=\"pypi version\" class=\"align-bottom\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/733edf66adb38329c7e98b97ff4b08146a696d73/68747470733a2f2f62616467652e667572792e696f2f70792f70797079726177732e737667\"></a></p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#installation\" id=\"id1\" rel=\"nofollow\">1\u00a0\u00a0\u00a0Installation</a><ul>\n<li><a href=\"#pip\" id=\"id2\" rel=\"nofollow\">1.1\u00a0\u00a0\u00a0pip</a></li>\n<li><a href=\"#python-version\" id=\"id3\" rel=\"nofollow\">1.2\u00a0\u00a0\u00a0Python version</a></li>\n</ul>\n</li>\n<li><a href=\"#examples\" id=\"id4\" rel=\"nofollow\">2\u00a0\u00a0\u00a0Examples</a></li>\n<li><a href=\"#steps\" id=\"id5\" rel=\"nofollow\">3\u00a0\u00a0\u00a0steps</a><ul>\n<li><a href=\"#pypyraws-steps-client\" id=\"id6\" rel=\"nofollow\">3.1\u00a0\u00a0\u00a0pypyraws.steps.client</a><ul>\n<li><a href=\"#what-can-i-do-with-pypyraws-steps-client\" id=\"id7\" rel=\"nofollow\">3.1.1\u00a0\u00a0\u00a0What can I do with pypyraws.steps.client?</a></li>\n<li><a href=\"#supported-aws-services\" id=\"id8\" rel=\"nofollow\">3.1.2\u00a0\u00a0\u00a0Supported AWS services</a></li>\n<li><a href=\"#pypyr-context\" id=\"id9\" rel=\"nofollow\">3.1.3\u00a0\u00a0\u00a0pypyr context</a></li>\n<li><a href=\"#aws-response\" id=\"id10\" rel=\"nofollow\">3.1.4\u00a0\u00a0\u00a0AWS response</a></li>\n<li><a href=\"#sample-pipeline\" id=\"id11\" rel=\"nofollow\">3.1.5\u00a0\u00a0\u00a0Sample pipeline</a></li>\n</ul>\n</li>\n<li><a href=\"#pypyraws-steps-ecswaitprep\" id=\"id12\" rel=\"nofollow\">3.2\u00a0\u00a0\u00a0pypyraws.steps.ecswaitprep</a></li>\n<li><a href=\"#pypyraws-steps-s3fetchjson\" id=\"id13\" rel=\"nofollow\">3.3\u00a0\u00a0\u00a0pypyraws.steps.s3fetchjson</a></li>\n<li><a href=\"#pypyraws-steps-s3fetchyaml\" id=\"id14\" rel=\"nofollow\">3.4\u00a0\u00a0\u00a0pypyraws.steps.s3fetchyaml</a></li>\n<li><a href=\"#pypyraws-steps-wait\" id=\"id15\" rel=\"nofollow\">3.5\u00a0\u00a0\u00a0pypyraws.steps.wait</a></li>\n<li><a href=\"#pypyraws-steps-waitfor\" id=\"id16\" rel=\"nofollow\">3.6\u00a0\u00a0\u00a0pypyraws.steps.waitfor</a></li>\n</ul>\n</li>\n<li><a href=\"#substitutions\" id=\"id17\" rel=\"nofollow\">4\u00a0\u00a0\u00a0Substitutions</a></li>\n<li><a href=\"#aws-authentication\" id=\"id18\" rel=\"nofollow\">5\u00a0\u00a0\u00a0aws authentication</a><ul>\n<li><a href=\"#configuring-credentials\" id=\"id19\" rel=\"nofollow\">5.1\u00a0\u00a0\u00a0Configuring credentials</a></li>\n<li><a href=\"#ensure-secrets-stay-secret\" id=\"id20\" rel=\"nofollow\">5.2\u00a0\u00a0\u00a0Ensure secrets stay secret</a></li>\n</ul>\n</li>\n<li><a href=\"#testing\" id=\"id21\" rel=\"nofollow\">6\u00a0\u00a0\u00a0Testing</a><ul>\n<li><a href=\"#testing-without-worrying-about-dependencies\" id=\"id22\" rel=\"nofollow\">6.1\u00a0\u00a0\u00a0Testing without worrying about dependencies</a></li>\n<li><a href=\"#if-tox-is-taking-too-long\" id=\"id23\" rel=\"nofollow\">6.2\u00a0\u00a0\u00a0If tox is taking too long</a></li>\n<li><a href=\"#day-to-day-testing\" id=\"id24\" rel=\"nofollow\">6.3\u00a0\u00a0\u00a0Day-to-day testing</a></li>\n</ul>\n</li>\n<li><a href=\"#help\" id=\"id25\" rel=\"nofollow\">7\u00a0\u00a0\u00a0Help!</a></li>\n<li><a href=\"#contribute\" id=\"id26\" rel=\"nofollow\">8\u00a0\u00a0\u00a0Contribute</a><ul>\n<li><a href=\"#developers\" id=\"id27\" rel=\"nofollow\">8.1\u00a0\u00a0\u00a0Developers</a></li>\n<li><a href=\"#bugs\" id=\"id28\" rel=\"nofollow\">8.2\u00a0\u00a0\u00a0Bugs</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id1\" rel=\"nofollow\">1\u00a0\u00a0\u00a0Installation</a></h2>\n<div id=\"pip\">\n<h3><a href=\"#id2\" rel=\"nofollow\">1.1\u00a0\u00a0\u00a0pip</a></h3>\n<pre><span class=\"c1\"># pip install --upgrade pypyraws</span>\n</pre>\n<p>pypyraws depends on the <tt>pypyr</tt> cli. The above <tt>pip</tt> will install it for\nyou if you don\u2019t have it already.</p>\n</div>\n<div id=\"python-version\">\n<h3><a href=\"#id3\" rel=\"nofollow\">1.2\u00a0\u00a0\u00a0Python version</a></h3>\n<p>Tested against Python &gt;=3.6</p>\n</div>\n</div>\n<div id=\"examples\">\n<h2><a href=\"#id4\" rel=\"nofollow\">2\u00a0\u00a0\u00a0Examples</a></h2>\n<p>If you prefer reading code to reading words, <a href=\"https://github.com/pypyr/pypyr-example\" rel=\"nofollow\">https://github.com/pypyr/pypyr-example</a></p>\n</div>\n<div id=\"steps\">\n<h2><a href=\"#id5\" rel=\"nofollow\">3\u00a0\u00a0\u00a0steps</a></h2>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td><strong>step</strong></td>\n<td><strong>description</strong></td>\n<td><strong>input context properties</strong></td>\n</tr>\n<tr><td><a href=\"#pypyraws-steps-client\" rel=\"nofollow\">pypyraws.steps.client</a></td>\n<td>Execute any low-level aws client method</td>\n<td>awsClientIn (dict)</td>\n</tr>\n<tr><td><a href=\"#pypyraws-steps-ecswaitprep\" rel=\"nofollow\">pypyraws.steps.ecswaitprep</a></td>\n<td>Run me after an ecs task run or stop to prepare\nan ecs waiter.</td>\n<td><p>awsClientOut (dict)</p>\n<p>awsEcsWaitPrepCluster (str)</p>\n</td>\n</tr>\n<tr><td><a href=\"#pypyraws-steps-s3fetchjson\" rel=\"nofollow\">pypyraws.steps.s3fetchjson</a></td>\n<td>Fetch a json file from s3 into the pypyr\ncontext.</td>\n<td>s3Fetch (dict)</td>\n</tr>\n<tr><td><a href=\"#pypyraws-steps-s3fetchyaml\" rel=\"nofollow\">pypyraws.steps.s3fetchyaml</a></td>\n<td>Fetch a yaml file from s3 into the pypyr\ncontext.</td>\n<td>s3Fetch (dict)</td>\n</tr>\n<tr><td><a href=\"#pypyraws-steps-wait\" rel=\"nofollow\">pypyraws.steps.wait</a></td>\n<td>Wait for an aws client waiter method to\ncomplete.</td>\n<td>awsWaitIn (dict)</td>\n</tr>\n<tr><td><a href=\"#pypyraws-steps-waitfor\" rel=\"nofollow\">pypyraws.steps.waitfor</a></td>\n<td>Wait for any aws client method to complete,\neven when it doesn\u2019t have an official waiter.</td>\n<td>awsWaitFor (dict)</td>\n</tr>\n</tbody>\n</table>\n<div id=\"pypyraws-steps-client\">\n<h3><a href=\"#id6\" rel=\"nofollow\">3.1\u00a0\u00a0\u00a0pypyraws.steps.client</a></h3>\n<div id=\"what-can-i-do-with-pypyraws-steps-client\">\n<h4><a href=\"#id7\" rel=\"nofollow\">3.1.1\u00a0\u00a0\u00a0What can I do with pypyraws.steps.client?</a></h4>\n<p>This step provides an easy way of getting at the low-level AWS api from the\npypyr pipeline runner. So in short, pretty much anything you can do with the\nAWS api, you got it, as the Big O might have said.</p>\n<p>This step lets you specify the service name and the service method you want to\nexecute dynamically. You can also control the service header arguments and the\nmethod arguments themselves.</p>\n<p>The arguments you pass to the service and its methods are exactly as given by\nthe AWS help documentation. So you do not have to learn yet another\nconfiguration based abstraction on top of the AWS api that might not even\nsupport all the methods you need.</p>\n<p>You can actually pretty much just grab the json as written from the excellent\nAWS help docs, paste it into some json that pypyr consumes and tadaaa!\nAlternatively, grab the samples from the boto3 python documentation to include\nin some yaml - the python dictionary structures map to yaml without too much\nfaff.</p>\n</div>\n<div id=\"supported-aws-services\">\n<h4><a href=\"#id8\" rel=\"nofollow\">3.1.2\u00a0\u00a0\u00a0Supported AWS services</a></h4>\n<p>Clients provide a low-level interface to AWS whose methods map close to 1:1\nwith the AWS REST service APIs. All service operations are supported by clients.</p>\n<p>Run any method on any of the following aws low-level client services:</p>\n<blockquote>\nacm, apigateway, application-autoscaling, appstream, autoscaling,\nbatch, budgets, clouddirectory, cloudformation, cloudfront, cloudhsm,\ncloudsearch, cloudsearchdomain, cloudtrail, cloudwatch, codebuild, codecommit,\ncodedeploy, codepipeline, codestar, cognito-identity, cognito-idp,\ncognito-sync, config, cur, datapipeline, devicefarm, directconnect, discovery,\ndms, ds, dynamodb, dynamodbstreams, ec2, ecr, ecs, efs, elasticache,\nelasticbeanstalk, elastictranscoder, elb, elbv2, emr, es, events, firehose,\ngamelift, glacier, health, iam, importexport, inspector, iot, iot-data,\nkinesis, kinesisanalytics, kms, lambda, lex-models, lex-runtime, lightsail,\nlogs, machinelearning, marketplace-entitlement, marketplacecommerceanalytics,\nmeteringmarketplace, mturk, opsworks, opsworkscm, organizations, pinpoint,\npolly, rds, redshift, rekognition, resourcegroupstaggingapi, route53,\nroute53domains, s3, sdb, servicecatalog, ses, shield, sms, snowball, sns, sqs,\nssm, stepfunctions, storagegateway, sts, support, swf, waf, waf-regional,\nworkdocs, workspaces, xray</blockquote>\n<p>You can find full details for the supported services and what methods you can\nrun against them here:  <a href=\"http://boto3.readthedocs.io/en/latest/reference/services/\" rel=\"nofollow\">http://boto3.readthedocs.io/en/latest/reference/services/</a></p>\n<p>With the speed of new features and services AWS introduces, it\u2019s pretty\nunlikely I\u2019ll get round to updating the list each and every time.</p>\n<p>pypyr-aws will automatically support new services AWS releases for the boto3\nclient, in case the list above gets out of date. So while the document might\nnot update, the code already will dynamically use new features and services on\nthe boto3 client.</p>\n</div>\n<div id=\"pypyr-context\">\n<h4><a href=\"#id9\" rel=\"nofollow\">3.1.3\u00a0\u00a0\u00a0pypyr context</a></h4>\n<p>Requires the following context items:</p>\n<pre><span class=\"nt\">awsClientIn</span><span class=\"p\">:</span>\n  <span class=\"nt\">serviceName</span><span class=\"p\">:</span> <span class=\"s\">'aws</span><span class=\"nv\"> </span><span class=\"s\">service</span><span class=\"nv\"> </span><span class=\"s\">name</span><span class=\"nv\"> </span><span class=\"s\">here'</span>\n  <span class=\"nt\">methodName</span><span class=\"p\">:</span> <span class=\"s\">'execute</span><span class=\"nv\"> </span><span class=\"s\">this</span><span class=\"nv\"> </span><span class=\"s\">method</span><span class=\"nv\"> </span><span class=\"s\">of</span><span class=\"nv\"> </span><span class=\"s\">the</span><span class=\"nv\"> </span><span class=\"s\">aws</span><span class=\"nv\"> </span><span class=\"s\">service'</span>\n  <span class=\"nt\">clientArgs</span><span class=\"p\">:</span> <span class=\"c1\"># optional</span>\n    <span class=\"nt\">arg1Name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arg1Value</span>\n    <span class=\"nt\">arg2Name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arg2Value</span>\n  <span class=\"nt\">methodArgs</span><span class=\"p\">:</span> <span class=\"c1\"># optional</span>\n    <span class=\"nt\">arg1Name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arg1Value</span>\n    <span class=\"nt\">arg2Name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arg2Value</span>\n</pre>\n<p>The <em>awsClientIn</em> context supports text <a href=\"#substitutions\" rel=\"nofollow\">Substitutions</a>.</p>\n</div>\n<div id=\"aws-response\">\n<h4><a href=\"#id10\" rel=\"nofollow\">3.1.4\u00a0\u00a0\u00a0AWS response</a></h4>\n<p>After this step completes the full response is available to subsequent steps\nin the pypyr context in the <em>awsClientOut</em> key.</p>\n</div>\n<div id=\"sample-pipeline\">\n<h4><a href=\"#id11\" rel=\"nofollow\">3.1.5\u00a0\u00a0\u00a0Sample pipeline</a></h4>\n<p>Here is some sample yaml of what a pipeline using the pypyr-aws plug-in <em>client</em>\nstep could look like:</p>\n<pre><span class=\"nt\">context_parser</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">pypyr.parser.keyvaluepairs</span>\n<span class=\"nt\">steps</span><span class=\"p\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"nt\">name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">pypyraws.steps.client</span>\n    <span class=\"nt\">description</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">upload a file to s3</span>\n    <span class=\"nt\">in</span><span class=\"p\">:</span>\n      <span class=\"nt\">awsClientIn</span><span class=\"p\">:</span>\n        <span class=\"nt\">serviceName</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">s3</span>\n        <span class=\"nt\">methodName</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">upload_file</span>\n        <span class=\"nt\">methodArgs</span><span class=\"p\">:</span>\n          <span class=\"nt\">Filename</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">./testfiles/arb.txt</span>\n          <span class=\"nt\">Bucket</span><span class=\"p\">:</span> <span class=\"s\">'{bucket}'</span>\n          <span class=\"nt\">Key</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arb.txt</span>\n</pre>\n<p>If you saved this yaml as <tt><span class=\"pre\">./pipelines/go-go-s3.yaml</span></tt>, you can run\nfrom ./ the following to upload <em>arb.txt</em> to your specified bucket:</p>\n<pre>$ pypyr go-go-s3 <span class=\"s2\">\"bucket=myuniquebucketname\"</span>\n</pre>\n<p>See a worked example for <a href=\"https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-s3.yaml\" rel=\"nofollow\">pypyr aws s3 here</a>.</p>\n</div>\n</div>\n<div id=\"pypyraws-steps-ecswaitprep\">\n<h3><a href=\"#id12\" rel=\"nofollow\">3.2\u00a0\u00a0\u00a0pypyraws.steps.ecswaitprep</a></h3>\n<p>Run me after an ecs task run or stop to prepare an ecs waiter.</p>\n<p>Prepares the awsWaitIn context key for pypyraws.steps.wait</p>\n<p>Available ecs waiters are:</p>\n<ul>\n<li>ServicesInactive</li>\n<li>ServicesStable</li>\n<li>TasksRunning</li>\n<li>TasksStopped</li>\n</ul>\n<p>Full details here: <a href=\"http://boto3.readthedocs.io/en/latest/reference/services/ecs.html#waiters\" rel=\"nofollow\">http://boto3.readthedocs.io/en/latest/reference/services/ecs.html#waiters</a></p>\n<p>Use this step after any of the following ecs client methods if you want to use\none of the ecs waiters to wait for a specific state:</p>\n<ul>\n<li>describe_services</li>\n<li>describe_tasks</li>\n<li>list_services - specify awsEcsWaitPrepCluster if you don\u2019t want default</li>\n<li>list_tasks - specify awsEcsWaitPrepCluster if you don\u2019t want default</li>\n<li>run_task</li>\n<li>start_task</li>\n<li>stop_task</li>\n<li>update_service</li>\n</ul>\n<p>You don\u2019t have to use this step, you could always just construct the awsWaitIn\ndictionary in context yourself. It just so happens this step saves you some\nlegwork to do so.</p>\n<p>Required context:</p>\n<ul>\n<li>awsClientOut<ul>\n<li>dict. mandatory.</li>\n<li>This is the context key that any ecs command executed by\npypyraws.steps.service adds. Chances are pretty good you don\u2019t want to\nconstruct this by hand yourself - the idea is to use the output as\ngenerated by one of the supported ecs methods.</li>\n</ul>\n</li>\n<li>awsEcsWaitPrepCluster<ul>\n<li>string. optional.</li>\n<li>The short name or full arn of the cluster that hosts the task to\ndescribe. If you do not specify a cluster, the default cluster is\nassumed. For most of the ecs methods the code automatically deduces the\ncluster from awsClientOut, so don\u2019t worry about it.</li>\n<li>But, when following list_services and list_tasks, you have to specify\nthis parameter.</li>\n<li>Specifying this parameter will override any automatically deduced cluster arn</li>\n</ul>\n</li>\n</ul>\n<p>See a worked example for <a href=\"https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-ecs.yaml\" rel=\"nofollow\">pypyr aws ecs here</a>.</p>\n</div>\n<div id=\"pypyraws-steps-s3fetchjson\">\n<h3><a href=\"#id13\" rel=\"nofollow\">3.3\u00a0\u00a0\u00a0pypyraws.steps.s3fetchjson</a></h3>\n<p>Fetch a json file from s3 and put the json values into context.</p>\n<p>Required input context is:</p>\n<pre><span class=\"nt\">s3Fetch</span><span class=\"p\">:</span>\n  <span class=\"nt\">clientArgs</span><span class=\"p\">:</span> <span class=\"c1\"># optional</span>\n    <span class=\"nt\">arg1Name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arg1Value</span>\n  <span class=\"nt\">methodArgs</span><span class=\"p\">:</span>\n    <span class=\"nt\">Bucket</span><span class=\"p\">:</span> <span class=\"s\">'{bucket}'</span>\n    <span class=\"nt\">Key</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arb.json</span>\n  <span class=\"nt\">outKey</span><span class=\"p\">:</span> <span class=\"s\">'destination</span><span class=\"nv\"> </span><span class=\"s\">pypyr</span><span class=\"nv\"> </span><span class=\"s\">context</span><span class=\"nv\"> </span><span class=\"s\">key'</span> <span class=\"c1\"># optional</span>\n</pre>\n<ul>\n<li><em>clientArgs</em> are passed to the aws s3 client constructor. These are optional.</li>\n<li><em>methodArgs</em> are passed the the s3 <tt>get_object</tt> call. The minimum required\nvalues are:<ul>\n<li>Bucket</li>\n<li>Key</li>\n</ul>\n</li>\n<li>Check here for all available arguments (including SSE server-side encryption):\n<a href=\"http://boto3.readthedocs.io/en/latest/reference/services/s3.html#S3.Client.get_object\" rel=\"nofollow\">http://boto3.readthedocs.io/en/latest/reference/services/s3.html#S3.Client.get_object</a></li>\n<li><em>outKey</em> writes fetched json to this context key. If not specified, json\nwrites directly to context root.</li>\n</ul>\n<p>Json parsed from the file will be merged into the pypyr context. This will\noverwrite existing values if the same keys are already in there.</p>\n<p>I.e if file json has <tt>{'eggs' : 'boiled'}</tt>, but context <tt>{'eggs': 'fried'}</tt>\nalready exists, returned <tt><span class=\"pre\">context['eggs']</span></tt> will be \u2018boiled\u2019.</p>\n<p>If <em>outKey</em> is not specified, the json should not be an Array [] at the root\nlevel, but rather an Object {}.</p>\n<p>The <em>s3Fetch</em> input context supports text <a href=\"#substitutions\" rel=\"nofollow\">Substitutions</a>.</p>\n<p>See a worked example for <a href=\"https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-s3fetch.yaml\" rel=\"nofollow\">pypyr aws s3fetch here</a>.</p>\n</div>\n<div id=\"pypyraws-steps-s3fetchyaml\">\n<h3><a href=\"#id14\" rel=\"nofollow\">3.4\u00a0\u00a0\u00a0pypyraws.steps.s3fetchyaml</a></h3>\n<p>Fetch a yaml file from s3 and put the yaml structure into context.</p>\n<p>Required input context is:</p>\n<pre><span class=\"nt\">s3Fetch</span><span class=\"p\">:</span>\n  <span class=\"nt\">clientArgs</span><span class=\"p\">:</span> <span class=\"c1\"># optional</span>\n    <span class=\"nt\">arg1Name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arg1Value</span>\n  <span class=\"nt\">methodArgs</span><span class=\"p\">:</span>\n    <span class=\"nt\">Bucket</span><span class=\"p\">:</span> <span class=\"s\">'{bucket}'</span>\n    <span class=\"nt\">Key</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arb.yaml</span>\n  <span class=\"nt\">outKey</span><span class=\"p\">:</span> <span class=\"s\">'destination</span><span class=\"nv\"> </span><span class=\"s\">pypyr</span><span class=\"nv\"> </span><span class=\"s\">context</span><span class=\"nv\"> </span><span class=\"s\">key'</span> <span class=\"c1\"># optional</span>\n</pre>\n<ul>\n<li><em>clientArgs</em> are passed to the aws s3 client constructor. These are optional.</li>\n<li><em>methodArgs</em> are passed the the s3 <tt>get_object</tt> call. The minimum required\nvalues are:<ul>\n<li>Bucket</li>\n<li>Key</li>\n</ul>\n</li>\n<li>Check here for all available arguments (including SSE server-side encryption):\n<a href=\"http://boto3.readthedocs.io/en/latest/reference/services/s3.html#S3.Client.get_object\" rel=\"nofollow\">http://boto3.readthedocs.io/en/latest/reference/services/s3.html#S3.Client.get_object</a></li>\n<li><em>outKey</em> writes fetched yaml to this context key. If not specified, yaml\nwrites directly to context root.</li>\n</ul>\n<p>The <em>s3Fetch</em> context supports text <a href=\"#substitutions\" rel=\"nofollow\">Substitutions</a>.</p>\n<p>Yaml parsed from the file will be merged into the pypyr context. This will\noverwrite existing values if the same keys are already in there.</p>\n<p>I.e if file yaml has</p>\n<pre><span class=\"nt\">eggs</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">boiled</span>\n</pre>\n<p>but context <tt>{'eggs': 'fried'}</tt> already exists, returned <tt><span class=\"pre\">context['eggs']</span></tt>\nwill be \u2018boiled\u2019.</p>\n<p>If <em>outKey</em> is not specified, the yaml should not be a list at the top level,\nbut rather a mapping. So the top-level yaml should not look like this:</p>\n<pre><span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">eggs</span>\n<span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">ham</span>\n</pre>\n<p>but rather like this:</p>\n<pre><span class=\"nt\">breakfastOfChampions</span><span class=\"p\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">eggs</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">ham</span>\n</pre>\n<p>See a worked example for <a href=\"https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-s3fetch.yaml\" rel=\"nofollow\">pypyr aws s3fetch here</a>.</p>\n</div>\n<div id=\"pypyraws-steps-wait\">\n<h3><a href=\"#id15\" rel=\"nofollow\">3.5\u00a0\u00a0\u00a0pypyraws.steps.wait</a></h3>\n<p>Wait for things in AWS to complete before continuing pipeline.</p>\n<p>Run any low-level boto3 client wait() from get_waiter.</p>\n<p>Waiters use a client\u2019s service operations to poll the status of an AWS resource\nand suspend execution until the AWS resource reaches the state that the waiter\nis polling for or a failure occurs while polling.</p>\n<p><a href=\"http://boto3.readthedocs.io/en/latest/guide/clients.html#waiters\" rel=\"nofollow\">http://boto3.readthedocs.io/en/latest/guide/clients.html#waiters</a></p>\n<p>The input context requires:</p>\n<pre><span class=\"nt\">awsWaitIn</span><span class=\"p\">:</span>\n  <span class=\"nt\">serviceName</span><span class=\"p\">:</span> <span class=\"s\">'service</span><span class=\"nv\"> </span><span class=\"s\">name'</span> <span class=\"c1\"># Available services here: http://boto3.readthedocs.io/en/latest/reference/services/</span>\n  <span class=\"nt\">waiterName</span><span class=\"p\">:</span> <span class=\"s\">'waiter</span><span class=\"nv\"> </span><span class=\"s\">name'</span> <span class=\"c1\"># Check service docs for available waiters for each service</span>\n  <span class=\"nt\">waiterArgs</span><span class=\"p\">:</span>\n    <span class=\"nt\">arg1Name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arg1Value</span> <span class=\"c1\"># optional. Dict. kwargs for get_waiter</span>\n  <span class=\"nt\">waitArgs</span><span class=\"p\">:</span>\n    <span class=\"nt\">arg1Name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">arg1Value</span> <span class=\"c1\">#optional. Dict. kwargs for wait</span>\n</pre>\n<p>The <em>awsWaitIn</em> context supports text <a href=\"#substitutions\" rel=\"nofollow\">Substitutions</a>.</p>\n</div>\n<div id=\"pypyraws-steps-waitfor\">\n<h3><a href=\"#id16\" rel=\"nofollow\">3.6\u00a0\u00a0\u00a0pypyraws.steps.waitfor</a></h3>\n<p>Custom waiter for any aws client operation. Where <a href=\"#pypyraws-steps-wait\" rel=\"nofollow\">pypyraws.steps.wait</a> uses\nthe official AWS waiters from the low-level client api, this step allows you to\nexecute <em>any</em> aws low-level client method and wait for a specified field in\nthe response to become the value you want it to be.</p>\n<p>This is especially handy for things like Beanstalk, because Elastic Beanstalk\ndoes not have Waiters for environment creation.</p>\n<p>The input context looks like this:</p>\n<pre><span class=\"nt\">awsWaitFor</span><span class=\"p\">:</span>\n  <span class=\"nt\">awsClientIn</span><span class=\"p\">:</span> <span class=\"c1\"># required. awsClientIn allows the same arguments as pypyraws.steps.client.</span>\n    <span class=\"nt\">serviceName</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">elasticbeanstalk</span>\n    <span class=\"nt\">methodName</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">describe_environments</span>\n    <span class=\"nt\">methodArgs</span><span class=\"p\">:</span>\n        <span class=\"nt\">ApplicationName</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">my wonderful beanstalk default application</span>\n        <span class=\"nt\">EnvironmentNames</span><span class=\"p\">:</span>\n          <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">my-wonderful-environment</span>\n        <span class=\"nt\">VersionLabel</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">v0.1</span>\n  <span class=\"nt\">waitForField</span><span class=\"p\">:</span> <span class=\"s\">'{Environments[0][Status]}'</span> <span class=\"c1\"># required. format expression for field name to check in awsClient response</span>\n  <span class=\"nt\">toBe</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">Ready</span> <span class=\"c1\"># required. Stop waiting when waitForField equals this value</span>\n  <span class=\"nt\">pollInterval</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">30</span> <span class=\"c1\"># optional. Seconds to wait between polling attempts. Defaults to 30 if not specified.</span>\n  <span class=\"nt\">maxAttempts</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">10</span> <span class=\"c1\"># optional. Defaults to 10 if not specified.</span>\n  <span class=\"nt\">errorOnWaitTimeout</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">True</span> <span class=\"c1\"># optional. Defaults to True if not specified. Stop processing if maxAttempts exhausted without reaching toBe value.</span>\n</pre>\n<p>See <a href=\"#pypyraws-steps-client\" rel=\"nofollow\">pypyraws.steps.client</a> for a full listing of available arguments under\n<em>awsClientIn</em>.</p>\n<p>If <tt>errorOnWaitTimeout</tt> is True and <tt>max_attempts</tt> exhaust before reaching\nthe desired target state, pypyr will stop processing with a\n<tt>pypyraws.errors.WaitTimeOut</tt> error.</p>\n<p>Once this step completes it adds <tt>awsWaitForTimedOut</tt> to the pypyr context.\nThis is a boolean value with values:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td>awsWaitForTimedOut</td>\n<td>Description</td>\n</tr>\n<tr><td>True</td>\n<td><tt>errorOnWaitTimeout=False</tt> and <tt>max_attempts</tt>\nexhausted without reaching <tt>toBe</tt>.</td>\n</tr>\n<tr><td>False</td>\n<td><tt>waitForField</tt>\u2019s value becomes <tt>toBe</tt> within\n<tt>max_attempts</tt>.</td>\n</tr>\n</tbody>\n</table>\n<p>The <em>awsWaitFor</em> context supports text <a href=\"#substitutions\" rel=\"nofollow\">Substitutions</a>. Do note that while\n<tt>waitForField</tt> uses substitution style format strings, the substitutions are\nmade against the response object that returns from the aws client call specified\nin <em>awsClientIn</em>, and not from the pypyr context itself.</p>\n<p>See a worked example for an <a href=\"https://github.com/pypyr/pypyr-example/blob/master/pipelines/aws-beanstalk-waitfor.yaml\" rel=\"nofollow\">elastic beanstalk custom waiter for environmment\ncreation here</a>.</p>\n</div>\n</div>\n<div id=\"substitutions\">\n<h2><a href=\"#id17\" rel=\"nofollow\">4\u00a0\u00a0\u00a0Substitutions</a></h2>\n<p>You can use substitution tokens, aka string interpolation, where specified for\ncontext items. This substitutes anything between {curly braces} with the\ncontext value for that key. This also works where you have dictionaries/lists\ninside dictionaries/lists. For example, if your context looked like this:</p>\n<pre><span class=\"nt\">bucketValue</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">the.bucket</span>\n<span class=\"nt\">keyValue</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">dont.kick</span>\n<span class=\"nt\">moreArbText</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">wild</span>\n<span class=\"nt\">awsClientIn</span><span class=\"p\">:</span>\n  <span class=\"nt\">serviceName</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">s3</span>\n  <span class=\"nt\">methodName</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">get_object</span>\n  <span class=\"nt\">methodArgs</span><span class=\"p\">:</span>\n    <span class=\"nt\">Bucket</span><span class=\"p\">:</span> <span class=\"s\">'{bucketValue}'</span>\n    <span class=\"nt\">Key</span><span class=\"p\">:</span> <span class=\"s\">'{keyValue}'</span>\n</pre>\n<p>This will run s3 get_object to retrieve file <em>dont.kick</em> from <em>the.bucket</em>.</p>\n<ul>\n<li><em>Bucket: \u2018{bucketValue}\u2019</em> becomes <em>Bucket: the.bucket</em></li>\n<li><em>Key: \u2018{keyValue}\u2019</em> becomes <em>Key: dont.kick</em></li>\n</ul>\n<p>In json &amp; yaml, curlies need to be inside quotes to make sure they parse as\nstrings.</p>\n<p>Escape literal curly braces with doubles: {{ for {, }} for }</p>\n<p>See a worked example <a href=\"https://github.com/pypyr/pypyr-example/tree/master/pipelines/substitutions.yaml\" rel=\"nofollow\">for substitutions here</a>.</p>\n</div>\n<div id=\"aws-authentication\">\n<h2><a href=\"#id18\" rel=\"nofollow\">5\u00a0\u00a0\u00a0aws authentication</a></h2>\n<div id=\"configuring-credentials\">\n<h3><a href=\"#id19\" rel=\"nofollow\">5.1\u00a0\u00a0\u00a0Configuring credentials</a></h3>\n<p>pypyr-aws pretty much just uses the underlying boto3 authentication mechanisms.\nMore info here: <a href=\"http://boto3.readthedocs.io/en/latest/guide/configuration.html\" rel=\"nofollow\">http://boto3.readthedocs.io/en/latest/guide/configuration.html</a></p>\n<p>This means any of the following will work:</p>\n<ul>\n<li><p>If you are running inside of AWS - on EC2 or inside an ECS container, it will\nautomatically use IAM role credentials if it does not find credentials in any\nof the other places listed below.</p>\n</li>\n<li><p>In the pypyr context</p>\n<pre><span class=\"n\">context</span><span class=\"p\">[</span><span class=\"s1\">'awsClientIn'</span><span class=\"p\">][</span><span class=\"s1\">'clientArgs'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"n\">aws_access_key_id</span><span class=\"p\">:</span> <span class=\"n\">ACCESS_KEY</span><span class=\"p\">,</span>\n    <span class=\"n\">aws_secret_access_key</span><span class=\"p\">:</span> <span class=\"n\">SECRET_KEY</span><span class=\"p\">,</span>\n    <span class=\"n\">aws_session_token</span><span class=\"p\">:</span> <span class=\"n\">SESSION_TOKEN</span><span class=\"p\">,</span>\n  <span class=\"p\">}</span>\n</pre>\n</li>\n<li><p>$ENV variables</p>\n<ul>\n<li>AWS_ACCESS_KEY_ID</li>\n<li>AWS_SECRET_ACCESS_KEY</li>\n<li>AWS_SESSION_TOKEN</li>\n</ul>\n</li>\n<li><p>Credentials file at <em>~/.aws/credentials</em> or <em>~/.aws/config</em></p>\n<ul>\n<li>If you have the aws-cli installed, run <tt>aws configure</tt> to get these\nconfigured for you automatically.</li>\n</ul>\n</li>\n</ul>\n<p>Tip: On dev boxes I generally don\u2019t bother with credentials, because chances\nare pretty good that I have the aws-cli installed already anyway, so pypyr\nwill just re-use the aws shared configuration files that are there anyway.</p>\n</div>\n<div id=\"ensure-secrets-stay-secret\">\n<h3><a href=\"#id20\" rel=\"nofollow\">5.2\u00a0\u00a0\u00a0Ensure secrets stay secret</a></h3>\n<p>Be safe! Don\u2019t hard-code your aws credentials. Don\u2019t check credentials into a\npublic repo.</p>\n<p>Tip: if you\u2019re running pypyr inside of aws - e.g in an ec2 instance or an ecs\ncontainer that is running under an IAM role, you don\u2019t actually <em>need</em>\nexplicitly to configure credentials for pypyr-aws.</p>\n<p>Do remember not to fling your key &amp; secret around as shell arguments - it could\nvery easily leak that way into logs or expose via a <tt>ps</tt>. I generally use one\nof the pypyr built-in context parsers like <em>pypyr.parser.jsonfile</em> or\n<em>pypyr.parser.yamlfile</em>, see\n<a href=\"https://github.com/pypyr/pypyr-cli#built-in-context-parsers\" rel=\"nofollow\">here for details</a>.</p>\n<p>Do remember also that $ENV variables are not a particularly secure place to\nkeep your secrets.</p>\n</div>\n</div>\n<div id=\"testing\">\n<h2><a href=\"#id21\" rel=\"nofollow\">6\u00a0\u00a0\u00a0Testing</a></h2>\n<div id=\"testing-without-worrying-about-dependencies\">\n<h3><a href=\"#id22\" rel=\"nofollow\">6.1\u00a0\u00a0\u00a0Testing without worrying about dependencies</a></h3>\n<p>Run from tox to test the packaging cycle inside a virtual env, plus run all\ntests:</p>\n<pre><span class=\"c1\"># just run tests\n</span>$ tox -e dev -- tests\n<span class=\"c1\"># run tests, validate README.rst, run flake8 linter\n</span>$ tox -e stage -- tests\n</pre>\n</div>\n<div id=\"if-tox-is-taking-too-long\">\n<h3><a href=\"#id23\" rel=\"nofollow\">6.2\u00a0\u00a0\u00a0If tox is taking too long</a></h3>\n<p>The test framework is pytest. If you only want to run tests:</p>\n<pre>$ pip install -e .<span class=\"o\">[</span>dev,test<span class=\"o\">]</span>\n</pre>\n</div>\n<div id=\"day-to-day-testing\">\n<h3><a href=\"#id24\" rel=\"nofollow\">6.3\u00a0\u00a0\u00a0Day-to-day testing</a></h3>\n<ul>\n<li><p>Tests live under <em>/tests</em> (surprising, eh?). Mirror the directory structure of\nthe code being tested.</p>\n</li>\n<li><p>Prefix a test definition with <em>test_</em> - so a unit test looks like</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_this_should_totally_work</span><span class=\"p\">():</span>\n</pre>\n</li>\n<li><p>To execute tests, from root directory:</p>\n<pre>pytest tests\n</pre>\n</li>\n<li><p>For a bit more info on running tests:</p>\n<pre>pytest --verbose <span class=\"o\">[</span>path<span class=\"o\">]</span>\n</pre>\n</li>\n<li><p>To execute a specific test module:</p>\n<pre>pytest tests/unit/arb_test_file.py\n</pre>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"help\">\n<h2><a href=\"#id25\" rel=\"nofollow\">7\u00a0\u00a0\u00a0Help!</a></h2>\n<p>Don\u2019t Panic! For help, community or talk, join the chat on <a href=\"https://discordapp.com/invite/8353JkB\" rel=\"nofollow\">discord</a>!</p>\n</div>\n<div id=\"contribute\">\n<h2><a href=\"#id26\" rel=\"nofollow\">8\u00a0\u00a0\u00a0Contribute</a></h2>\n<div id=\"developers\">\n<h3><a href=\"#id27\" rel=\"nofollow\">8.1\u00a0\u00a0\u00a0Developers</a></h3>\n<p>For information on how to help with pypyr, run tests and coverage, please do\ncheck out the <a href=\"https://github.com/pypyr/pypyr-cli/blob/master/CONTRIBUTING.rst\" rel=\"nofollow\">contribution guide</a>.</p>\n</div>\n<div id=\"bugs\">\n<h3><a href=\"#id28\" rel=\"nofollow\">8.2\u00a0\u00a0\u00a0Bugs</a></h3>\n<p>Well, you know. No one\u2019s perfect. Feel free to <a href=\"https://github.com/pypyr/pypyr-aws/issues/new\" rel=\"nofollow\">create an issue</a>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 5693243, "releases": {"0.0.0": [], "0.0.1": [{"comment_text": "", "digests": {"md5": "88600e65ee5ff2a175ca3f74271c850f", "sha256": "0448c347d6fecac699c60be28852e870aa50ff46c4a6c8fde2f91cdeb0390915"}, "downloads": -1, "filename": "pypyraws-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "88600e65ee5ff2a175ca3f74271c850f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14801, "upload_time": "2017-05-12T20:40:00", "upload_time_iso_8601": "2017-05-12T20:40:00.030827Z", "url": "https://files.pythonhosted.org/packages/f6/41/380f4948284e55c577d44c75a253aebc3d85e8bdc2751c38ce60afef16ef/pypyraws-0.0.1-py3-none-any.whl", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "07839907be21a50944704ff1e25efb83", "sha256": "899d4aca4a1369cf3e75c9a42a325888ab46b48cf65a4a59159e95e052e9ff44"}, "downloads": -1, "filename": "pypyraws-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "07839907be21a50944704ff1e25efb83", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 23841, "upload_time": "2017-05-12T22:13:42", "upload_time_iso_8601": "2017-05-12T22:13:42.544573Z", "url": "https://files.pythonhosted.org/packages/e2/b6/ae717aba0f06e928b939af58bc4735632e4fcad74f961597ac8fa36e3c88/pypyraws-0.0.2-py3-none-any.whl", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "bb718c4c031b72514e9aec1de9c0ac3d", "sha256": "bb3552cdf7010516209fb8d46578f45850eece7d4c8749cc59ef461d82b65c4a"}, "downloads": -1, "filename": "pypyraws-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "bb718c4c031b72514e9aec1de9c0ac3d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28855, "upload_time": "2017-06-02T15:05:02", "upload_time_iso_8601": "2017-06-02T15:05:02.977330Z", "url": "https://files.pythonhosted.org/packages/a3/f5/04f85105889eed90df13abc0789e7037372a728ace51ec9a5d30a8e8a553/pypyraws-0.0.3-py3-none-any.whl", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "e5fffc3f5573bf020392abd23b932c5c", "sha256": "1983aa7361270eb467b16221d52d9c158e8adcdf0bedf1f759353736aa3815f5"}, "downloads": -1, "filename": "pypyraws-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "e5fffc3f5573bf020392abd23b932c5c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28873, "upload_time": "2017-06-05T08:07:23", "upload_time_iso_8601": "2017-06-05T08:07:23.603559Z", "url": "https://files.pythonhosted.org/packages/5c/46/4176f8ba05c1bca194493a9f2dd6c3a42188249a075501ba8e800d3ed3a1/pypyraws-0.0.4-py3-none-any.whl", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "546087e09830e7ea2fcdfc0139bfc9f8", "sha256": "bc1860145ef940af5d61bc38cf8203b9810cf849d71ae2bc7bca22bfc8a5c9d5"}, "downloads": -1, "filename": "pypyraws-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "546087e09830e7ea2fcdfc0139bfc9f8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 20708, "upload_time": "2018-06-14T02:19:25", "upload_time_iso_8601": "2018-06-14T02:19:25.464342Z", "url": "https://files.pythonhosted.org/packages/1f/66/8577be3b71cd904a99fe2bb53b4a218ee51747384f1668d08c1e76368a67/pypyraws-0.1.1-py3-none-any.whl", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "b603f9532b683861ad7758aea3c6aa9c", "sha256": "8f641e1235cfa12094aa9817f29ac03d297e05e28753982352e7269b17774d73"}, "downloads": -1, "filename": "pypyraws-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b603f9532b683861ad7758aea3c6aa9c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 20718, "upload_time": "2018-07-26T20:34:54", "upload_time_iso_8601": "2018-07-26T20:34:54.779389Z", "url": "https://files.pythonhosted.org/packages/4c/73/9c602778fafa67b05f153b70ef4de162ed82ff0bb44b843d9b89034bf1fd/pypyraws-1.0.0-py3-none-any.whl", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "999a4bf251ee478c2248d22b1a4bfb0a", "sha256": "6513bc88f59f21f09c68cabe210700f06171a7166fd1374ee9c554dd200faae5"}, "downloads": -1, "filename": "pypyraws-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "999a4bf251ee478c2248d22b1a4bfb0a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21447, "upload_time": "2018-11-21T22:38:01", "upload_time_iso_8601": "2018-11-21T22:38:01.871229Z", "url": "https://files.pythonhosted.org/packages/11/e8/2f630a96e61e77199cd55a6d5b2736f7f71f0824017703b033a34ffb766c/pypyraws-1.1.0-py3-none-any.whl", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "3a389e016ba92200940763ed24fc5a7c", "sha256": "46a030dd4ce6f168953fabcefd33ef03815524cc9d17ec70ee115497d345c31d"}, "downloads": -1, "filename": "pypyraws-1.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3a389e016ba92200940763ed24fc5a7c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21433, "upload_time": "2019-08-18T02:20:34", "upload_time_iso_8601": "2019-08-18T02:20:34.910686Z", "url": "https://files.pythonhosted.org/packages/9d/5f/c0ac3128650865e703a7e026fe062aaf1b99c3439daaec258f2240d4d1e5/pypyraws-1.1.1-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3a389e016ba92200940763ed24fc5a7c", "sha256": "46a030dd4ce6f168953fabcefd33ef03815524cc9d17ec70ee115497d345c31d"}, "downloads": -1, "filename": "pypyraws-1.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3a389e016ba92200940763ed24fc5a7c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21433, "upload_time": "2019-08-18T02:20:34", "upload_time_iso_8601": "2019-08-18T02:20:34.910686Z", "url": "https://files.pythonhosted.org/packages/9d/5f/c0ac3128650865e703a7e026fe062aaf1b99c3439daaec258f2240d4d1e5/pypyraws-1.1.1-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 02:58:54 2020"}