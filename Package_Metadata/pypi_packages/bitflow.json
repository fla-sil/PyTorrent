{"info": {"author": "Lucas Saldyt", "author_email": "lucassaldyt@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Bitflow Data Pipeline\n\nPeTaL's data pipeline is responsible for building the `neo4j` database used by the main PeTaL website.\nIt contains web scrapers and machine learning tools, which are chained together by defining type signatures on `neo4j` node labels.\nFor example, the species catalog module generates `Taxon` nodes, and the wikipedia article module receives `Taxon` nodes and creates `WikipediaArticle` nodes.\n\n## Extending Mining Capability\n\nThe pipeline can be extending by creating a module, for instance in the `modules/mining/` directory.  \nA module is defined by a type signature (type in) -> (type out, label from, label to) and a process(node : type in) function which creates a list of Transaction() objects from (type in) nodes.  \nHere, \"types\" are neo4j labels. \n\n#### Independent\nA basic skeleton of an \"independent\" module (with no inputs) looks like this:\n```python\nfrom pipeline.utils.module import Module\n\nclass MyModule(Module):\n    def __init__(self, in_label=None, out_label='Output', connect_labels=None, name='MyModule'):\n        Module.__init__(self, in_label, out_label, connect_labels, name)\n\n    def process(self):\n    \tfor json_data in ...:\n\t\tyield self.default_transaction(json_data) # Create new nodes of type 'Output'\n```\nA good example of this is `modules/mining/OptimizedCatalog.py`\n\n#### Dependent\nA basic skeleton of a \"dependent\" module looks like this:\n```python\nfrom pipeline.utils.module import Module\n\nclass MyModule(Module):\n    def __init__(self, in_label='Input', out_label='Output', connect_labels=('to', 'from'), name='MyModule'):\n        Module.__init__(self, in_label, out_label, connect_labels, name)\n\n    def process(self, previous):\n        data = previous.data # Get the neo4j JSON of a node with label 'Input'\n\t# new_data = ...\n\tyield self.default_transaction(new_data)\n```\nA good example of this is `modules/mining/WikipediaModule.py`\n\nWithin a Module's process() function, self.default\\_transaction(data) is used to create a Transaction() object from JSON for node properties. For more advanced data miners, see self.custom\\_transaction() and self.query\\_transaction() as they are all defined in `modules/mining/module.py`.\n\n#### Machine Learning\n\nRelevant base classes to machine learning live in `pipeline/utils`.  \nIn particular, `BatchLearner`, `BatchTorchLearner`, `OnlineLearner`, and `OnlineTorchLearner` are worth looking at.\n\nA basic skeleton of a neural-network based machine learning module in PeTaL looks like this:\n```python\nfrom petal.pipeline.utils.BatchTorchLearner import BatchTorchLearner\n\nclass MyMLModule(BatchTorchLearner):\n    def __init__(self, filename='data/models/my_ML_module.nn'):\n    \t# Change these based on the underlying ML model, see BatchTorchLearner documentation.\n        BatchTorchLearner.__init__(self, nn.CrossEntropyLoss, optim.SGD, dict(lr=0.001, momentum=0.9), in_label='Input', name='MyMLModule', filename=filename)\n\n    def init_model(self):\n        self.model = TorchModel(..)\n\n    def transform(self, node):\n    \t# Process node.data into inputs and outputs\n        yield inputs, outputs\n```\nSee `modules/taxon_classifier/TaxonClassifier` for an example of this.\n\nA more advanced neural network example might look like this.\nBoth examples use the same base class, but more fine-grained control is given by overloading more functions.\n```python\nclass MyMLModule(BatchTorchLearner):\n    def __init__(self, filename='data/models/my_model.nn', name='MyMLModule'):\n        BatchTorchLearner.__init__(self, filename=filename, epochs=2, train_fraction=0.8, test_fraction=0.2, validate_fraction=0.00, criterion=nn.MSELoss, optimizer=optim.Adadelta, optimizer_kwargs=dict(lr=1.0, rho=0.9, eps=1e-06, weight_decay=0), in_label='Input', name=name)\n\n    def init_model(self):\n        self.model = TorchModel(..)\n\n    # def learn() inherited, uses transform()\n    def transform(self, node):\n\tyield inputs, outputs\n\n    def test(self, batch):\n    \t# Process a test batch (given 20% of the time, based on test_fraction parameter above)\n\n    def val(self, batch):\n    \t# Process a validation batch (given 20% of the time, based on test_fraction parameter above)\n```\n\n## Scheduler, Driver, and Pipeline classes\n\nBehind the scenes, this is how the pipeline works at a very high level. \nThis code is (if I may say so) well documented, because I saw it as being the hardest to understand or fix.\nSee the top-level of the `pipeline` directory.\n\n#### Scheduler\n\nScheduler will load any modules importable from the `modules` subdirectories.\nIt expects a file containing a class of the same name.\nFor example `modules/mymodules/MyModule.py` with `class MyModule: ...` within the file is a valid setup.\nAlso, each module should derive from a base `Module` class (or another class that derives from `Module`.\nAs documented above, these are located in `pipeline.utils`.\n\nScheduler reads the type signatures of modules, and runs them based on this.  \nFor instance, `OptimizedCatalog` is \"indepdent\", because it generates `Taxon` nodes without any input, so this is run initially.  \nThen, once Species nodes are created, modules which rely on them are scheduled and eventually run, with respect to the amount of nodes available.  \nFor instance, `WikipediaModule`, `EOLModule`, and `JEBModule` will all run after BackboneModule has generated 10 nodes.\n\n#### Driver\n\nDriver is just a connection to a neo4j database.\nEssentially it enables some useful abstraction over the `neo4j` api, specifically allowing the developer to worry only about the JSON containing in nodes, and their labels and connections.\nThis is done by using the `Transaction` class, located in `pipeline/utils`.\nFor further understanding, see the file-level documentation.\n\n#### Pipeline\n\nPipeline is an interface which allows the server to dynamically load modules and settings (like how a Djano site supports changing files while the website is running).\nIt's really that simple, but it's also documented at the file-level in the `pipeline` folder.\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/LSaldyt/bitflow", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "bitflow", "package_url": "https://pypi.org/project/bitflow/", "platform": "", "project_url": "https://pypi.org/project/bitflow/", "project_urls": {"Homepage": "https://github.com/LSaldyt/bitflow"}, "release_url": "https://pypi.org/project/bitflow/0.0.1/", "requires_dist": null, "requires_python": ">=3.7", "summary": "An efficient data pipeline", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Bitflow Data Pipeline</h1>\n<p>PeTaL's data pipeline is responsible for building the <code>neo4j</code> database used by the main PeTaL website.\nIt contains web scrapers and machine learning tools, which are chained together by defining type signatures on <code>neo4j</code> node labels.\nFor example, the species catalog module generates <code>Taxon</code> nodes, and the wikipedia article module receives <code>Taxon</code> nodes and creates <code>WikipediaArticle</code> nodes.</p>\n<h2>Extending Mining Capability</h2>\n<p>The pipeline can be extending by creating a module, for instance in the <code>modules/mining/</code> directory.<br>\nA module is defined by a type signature (type in) -&gt; (type out, label from, label to) and a process(node : type in) function which creates a list of Transaction() objects from (type in) nodes.<br>\nHere, \"types\" are neo4j labels.</p>\n<h4>Independent</h4>\n<p>A basic skeleton of an \"independent\" module (with no inputs) looks like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pipeline.utils.module</span> <span class=\"kn\">import</span> <span class=\"n\">Module</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModule</span><span class=\"p\">(</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">in_label</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">out_label</span><span class=\"o\">=</span><span class=\"s1\">'Output'</span><span class=\"p\">,</span> <span class=\"n\">connect_labels</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'MyModule'</span><span class=\"p\">):</span>\n        <span class=\"n\">Module</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">in_label</span><span class=\"p\">,</span> <span class=\"n\">out_label</span><span class=\"p\">,</span> <span class=\"n\">connect_labels</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">process</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n    \t<span class=\"k\">for</span> <span class=\"n\">json_data</span> <span class=\"ow\">in</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n\t\t<span class=\"k\">yield</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">default_transaction</span><span class=\"p\">(</span><span class=\"n\">json_data</span><span class=\"p\">)</span> <span class=\"c1\"># Create new nodes of type 'Output'</span>\n</pre>\n<p>A good example of this is <code>modules/mining/OptimizedCatalog.py</code></p>\n<h4>Dependent</h4>\n<p>A basic skeleton of a \"dependent\" module looks like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pipeline.utils.module</span> <span class=\"kn\">import</span> <span class=\"n\">Module</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModule</span><span class=\"p\">(</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">in_label</span><span class=\"o\">=</span><span class=\"s1\">'Input'</span><span class=\"p\">,</span> <span class=\"n\">out_label</span><span class=\"o\">=</span><span class=\"s1\">'Output'</span><span class=\"p\">,</span> <span class=\"n\">connect_labels</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">'to'</span><span class=\"p\">,</span> <span class=\"s1\">'from'</span><span class=\"p\">),</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'MyModule'</span><span class=\"p\">):</span>\n        <span class=\"n\">Module</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">in_label</span><span class=\"p\">,</span> <span class=\"n\">out_label</span><span class=\"p\">,</span> <span class=\"n\">connect_labels</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">process</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">previous</span><span class=\"p\">):</span>\n        <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">previous</span><span class=\"o\">.</span><span class=\"n\">data</span> <span class=\"c1\"># Get the neo4j JSON of a node with label 'Input'</span>\n\t<span class=\"c1\"># new_data = ...</span>\n\t<span class=\"k\">yield</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">default_transaction</span><span class=\"p\">(</span><span class=\"n\">new_data</span><span class=\"p\">)</span>\n</pre>\n<p>A good example of this is <code>modules/mining/WikipediaModule.py</code></p>\n<p>Within a Module's process() function, self.default_transaction(data) is used to create a Transaction() object from JSON for node properties. For more advanced data miners, see self.custom_transaction() and self.query_transaction() as they are all defined in <code>modules/mining/module.py</code>.</p>\n<h4>Machine Learning</h4>\n<p>Relevant base classes to machine learning live in <code>pipeline/utils</code>.<br>\nIn particular, <code>BatchLearner</code>, <code>BatchTorchLearner</code>, <code>OnlineLearner</code>, and <code>OnlineTorchLearner</code> are worth looking at.</p>\n<p>A basic skeleton of a neural-network based machine learning module in PeTaL looks like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">petal.pipeline.utils.BatchTorchLearner</span> <span class=\"kn\">import</span> <span class=\"n\">BatchTorchLearner</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyMLModule</span><span class=\"p\">(</span><span class=\"n\">BatchTorchLearner</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">'data/models/my_ML_module.nn'</span><span class=\"p\">):</span>\n    \t<span class=\"c1\"># Change these based on the underlying ML model, see BatchTorchLearner documentation.</span>\n        <span class=\"n\">BatchTorchLearner</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">CrossEntropyLoss</span><span class=\"p\">,</span> <span class=\"n\">optim</span><span class=\"o\">.</span><span class=\"n\">SGD</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">lr</span><span class=\"o\">=</span><span class=\"mf\">0.001</span><span class=\"p\">,</span> <span class=\"n\">momentum</span><span class=\"o\">=</span><span class=\"mf\">0.9</span><span class=\"p\">),</span> <span class=\"n\">in_label</span><span class=\"o\">=</span><span class=\"s1\">'Input'</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'MyMLModule'</span><span class=\"p\">,</span> <span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"n\">filename</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">init_model</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">TorchModel</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">transform</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n    \t<span class=\"c1\"># Process node.data into inputs and outputs</span>\n        <span class=\"k\">yield</span> <span class=\"n\">inputs</span><span class=\"p\">,</span> <span class=\"n\">outputs</span>\n</pre>\n<p>See <code>modules/taxon_classifier/TaxonClassifier</code> for an example of this.</p>\n<p>A more advanced neural network example might look like this.\nBoth examples use the same base class, but more fine-grained control is given by overloading more functions.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyMLModule</span><span class=\"p\">(</span><span class=\"n\">BatchTorchLearner</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">'data/models/my_model.nn'</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'MyMLModule'</span><span class=\"p\">):</span>\n        <span class=\"n\">BatchTorchLearner</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"n\">filename</span><span class=\"p\">,</span> <span class=\"n\">epochs</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">train_fraction</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"n\">test_fraction</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"n\">validate_fraction</span><span class=\"o\">=</span><span class=\"mf\">0.00</span><span class=\"p\">,</span> <span class=\"n\">criterion</span><span class=\"o\">=</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">MSELoss</span><span class=\"p\">,</span> <span class=\"n\">optimizer</span><span class=\"o\">=</span><span class=\"n\">optim</span><span class=\"o\">.</span><span class=\"n\">Adadelta</span><span class=\"p\">,</span> <span class=\"n\">optimizer_kwargs</span><span class=\"o\">=</span><span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">lr</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"o\">=</span><span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"n\">eps</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span><span class=\"p\">,</span> <span class=\"n\">weight_decay</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">in_label</span><span class=\"o\">=</span><span class=\"s1\">'Input'</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"n\">name</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">init_model</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">TorchModel</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># def learn() inherited, uses transform()</span>\n    <span class=\"k\">def</span> <span class=\"nf\">transform</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n\t<span class=\"k\">yield</span> <span class=\"n\">inputs</span><span class=\"p\">,</span> <span class=\"n\">outputs</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">test</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">batch</span><span class=\"p\">):</span>\n    \t<span class=\"c1\"># Process a test batch (given 20% of the time, based on test_fraction parameter above)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">val</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">batch</span><span class=\"p\">):</span>\n    \t<span class=\"c1\"># Process a validation batch (given 20% of the time, based on test_fraction parameter above)</span>\n</pre>\n<h2>Scheduler, Driver, and Pipeline classes</h2>\n<p>Behind the scenes, this is how the pipeline works at a very high level.\nThis code is (if I may say so) well documented, because I saw it as being the hardest to understand or fix.\nSee the top-level of the <code>pipeline</code> directory.</p>\n<h4>Scheduler</h4>\n<p>Scheduler will load any modules importable from the <code>modules</code> subdirectories.\nIt expects a file containing a class of the same name.\nFor example <code>modules/mymodules/MyModule.py</code> with <code>class MyModule: ...</code> within the file is a valid setup.\nAlso, each module should derive from a base <code>Module</code> class (or another class that derives from <code>Module</code>.\nAs documented above, these are located in <code>pipeline.utils</code>.</p>\n<p>Scheduler reads the type signatures of modules, and runs them based on this.<br>\nFor instance, <code>OptimizedCatalog</code> is \"indepdent\", because it generates <code>Taxon</code> nodes without any input, so this is run initially.<br>\nThen, once Species nodes are created, modules which rely on them are scheduled and eventually run, with respect to the amount of nodes available.<br>\nFor instance, <code>WikipediaModule</code>, <code>EOLModule</code>, and <code>JEBModule</code> will all run after BackboneModule has generated 10 nodes.</p>\n<h4>Driver</h4>\n<p>Driver is just a connection to a neo4j database.\nEssentially it enables some useful abstraction over the <code>neo4j</code> api, specifically allowing the developer to worry only about the JSON containing in nodes, and their labels and connections.\nThis is done by using the <code>Transaction</code> class, located in <code>pipeline/utils</code>.\nFor further understanding, see the file-level documentation.</p>\n<h4>Pipeline</h4>\n<p>Pipeline is an interface which allows the server to dynamically load modules and settings (like how a Djano site supports changing files while the website is running).\nIt's really that simple, but it's also documented at the file-level in the <code>pipeline</code> folder.</p>\n\n          </div>"}, "last_serial": 7149711, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "fa6dd191454c32d36d95a77d4bb61167", "sha256": "d8632a5465317ed700d4266d563e8eda784423c7eaee15f68422b01a5e90908d"}, "downloads": -1, "filename": "bitflow-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "fa6dd191454c32d36d95a77d4bb61167", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 21927, "upload_time": "2020-05-02T04:41:14", "upload_time_iso_8601": "2020-05-02T04:41:14.579058Z", "url": "https://files.pythonhosted.org/packages/40/69/78905ddb8e77d21e91f76f6def2d89cb3b5f858a6af488bbfb0775f2d3d6/bitflow-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "461f943723c40a9a6670465a8289d64c", "sha256": "d0b0991b52bdee05fdf7568cec1a2cc6b70cd5e9642d7a78a788f437c08225cf"}, "downloads": -1, "filename": "bitflow-0.0.1.tar.gz", "has_sig": false, "md5_digest": "461f943723c40a9a6670465a8289d64c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 18657, "upload_time": "2020-05-02T04:41:16", "upload_time_iso_8601": "2020-05-02T04:41:16.636996Z", "url": "https://files.pythonhosted.org/packages/e5/17/4cbf778a293e6a8d9c0e6b6996a160be66c4558ae15309ea5131287d0908/bitflow-0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fa6dd191454c32d36d95a77d4bb61167", "sha256": "d8632a5465317ed700d4266d563e8eda784423c7eaee15f68422b01a5e90908d"}, "downloads": -1, "filename": "bitflow-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "fa6dd191454c32d36d95a77d4bb61167", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 21927, "upload_time": "2020-05-02T04:41:14", "upload_time_iso_8601": "2020-05-02T04:41:14.579058Z", "url": "https://files.pythonhosted.org/packages/40/69/78905ddb8e77d21e91f76f6def2d89cb3b5f858a6af488bbfb0775f2d3d6/bitflow-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "461f943723c40a9a6670465a8289d64c", "sha256": "d0b0991b52bdee05fdf7568cec1a2cc6b70cd5e9642d7a78a788f437c08225cf"}, "downloads": -1, "filename": "bitflow-0.0.1.tar.gz", "has_sig": false, "md5_digest": "461f943723c40a9a6670465a8289d64c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 18657, "upload_time": "2020-05-02T04:41:16", "upload_time_iso_8601": "2020-05-02T04:41:16.636996Z", "url": "https://files.pythonhosted.org/packages/e5/17/4cbf778a293e6a8d9c0e6b6996a160be66c4558ae15309ea5131287d0908/bitflow-0.0.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:37:17 2020"}