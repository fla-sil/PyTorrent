{"info": {"author": "Chaim-Leib Halbert, Konstantin Tretyakov", "author_email": "kt@ut.ee", "bugtrack_url": null, "classifiers": ["Development Status :: 7 - Inactive", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)", "Programming Language :: Python", "Topic :: Scientific/Engineering :: Bio-Informatics", "Topic :: Software Development :: Libraries"], "description": "==============\nPyIntervalTree\n==============\n\n    NB: This package **is deprecated**. Please, use the ``intervaltree`` package instead (available via `Github <https://github.com/chaimleib/intervaltree>`__ or `PyPI <https://pypi.python.org/pypi/intervaltree>`__).\n    \n    The genome-related functionality is extracted to the ``intervaltree-bio`` package (`Github <https://github.com/konstantint/intervaltree-bio>`__, `PyPI <https://pypi.python.org/pypi/intervaltree-bio>`__).\n        \n    **No future versions of this package are planned. Do not file issues.**\n\nA mutable, self-balancing interval tree. Queries may be by point, by range \noverlap, or by range envelopment.\n\nThis library was designed to allow tagging text and time intervals, where the\nintervals include the lower bound but not the upper bound.\n\nInstallation\n------------\n\nThe easiest way to install most Python packages is via ``easy_install`` or ``pip``::\n\n    $ pip install PyIntervalTree\n\nFeatures\n--------\n\n* Initialize blank or from an iterable of Intervals in O(n * log n).\n* Insertions\n\n  * ``tree[begin:end] = data``\n  * ``tree.add(interval)``\n  * ``tree.addi(begin, end, data)``\n  * ``tree.extend(list_of_interval_objs)``\n\n* Deletions\n\n  * ``tree.remove(interval)``             (raises ``ValueError`` if not present)\n  * ``tree.discard(interval)``            (quiet if not present)\n  * ``tree.removei(begin, end, data)``\n  * ``tree.discardi(begin, end, data)``\n  * ``tree.remove_overlap(point)``\n  * ``tree.remove_overlap(begin, end)``   (removes all overlapping the range)\n  * ``tree.remove_envelop(begin, end)``   (removes all enveloped in the range)\n\n* Overlap queries:\n\n  * ``tree[point]``\n  * ``tree[begin:end]``\n  * ``tree.search(point)``\n  * ``tree.search(begin, end)``\n\n* Envelop queries:\n\n  * ``tree.search(begin, end, strict = True)``\n\n* Membership queries:\n\n  * ``interval_obj in tree``              (this is fastest, O(1))\n  * ``tree.containsi(begin, end, data)``\n  * ``tree.overlaps(point)``\n  * ``tree.overlaps(begin, end)``\n\n* Iterable:\n\n  * ``for interval_obj in tree:``\n  * ``tree.items()``\n\n* Sizing:\n\n  * ``len(tree)``\n  * ``tree.is_empty()``\n  * ``not tree``\n  * ``tree.begin()`` (the smallest coordinate of the leftmost interval)\n  * ``tree.end()`` (the ``end`` coordinate of the rightmost interval)\n\n* Restructuring\n\n  * ``split_overlaps()``\n\n* Copy- and typecast-able:\n\n  * ``IntervalTree(tree)``    (``Interval`` objects are same as those in tree)\n  * ``tree.copy()``           (``Interval`` objects are shallow copies of those in tree)\n  * ``set(tree)``             (can later be fed into ``IntervalTree()``)\n  * ``list(tree)``            (ditto)\n\n* Equal-able\n* Pickle-friendly\n* Automatic AVL balancing\n    \nExamples\n--------\n\n* Getting started::\n\n        from intervaltree import Interval, IntervalTree\n        t = IntervalTree()\n\n* Adding intervals - you don't have to use strings!::\n\n        t[1:2] = \"1-2\"\n        t[4:7] = \"4-7\"\n        t[5:9] = \"5-9\"\n\n* Query by point::\n\n        ivs = t[6]            # set([Interval(4, 7, '4-7'), Interval(5, 9, '5-9')])\n        iv = sorted(ivs)[0]   # Interval(4, 7, '4-7')\n  \n* Accessing an ``Interval`` object::\n\n        iv.begin  # 4\n        iv.end    # 7\n        iv.data   # \"4-7\"\n  \n* Query by range:\n\n  Note that ranges are inclusive of the lower limit, but non-inclusive of the\n  upper limit. So::\n\n        t[2:4]    # set([])\n\n  But::\n\n        t[1:5]    # set([Interval(1, 2, '1-2'), Interval(4, 7, '4-7')])\n\n* Constructing from lists of ``Interval``'s:\n\n  We could have made the same tree this way::\n\n        ivs = [ [1,2], [4,7], [5,9] ]\n        ivs = map( lambda begin,end: Interval(begin, end, \"%d-%d\" % (begin,end), \n                   *zip(*ivs) )\n  \n        t = IntervalTree(ivs)\n\n* Removing intervals::\n\n        t.remove( Interval(1, 2, \"1-2\") )\n        list(t)     # [Interval(4, 7, '4-7'), Interval(5, 9, '5-9')]\n        \n        t.remove( Interval(500, 1000, \"Doesn't exist\") # raises ValueError\n        t.discard(Interval(500, 1000, \"Doesn't exist\") # quietly does nothing\n        \n        t.remove_overlap(5)   \n        list(t)     # []\n\n  We could also empty a tree by removing all intervals, from the lowest bound\n  to the highest bound of the ``IntervalTree``::\n  \n        t.remove_overlap(t.begin(), t.end())\n\nUsage with Genomic Data\n-----------------------\n\nInterval trees are especially commonly used in bioinformatics, where intervals correspond to genes or various features along the genome. Such intervals are commonly stored in ``BED``-format files. To simplify working with such data, the package ``intervaltree.bio`` provides a ``GenomeIntervalTree`` class.\n\n``GenomeIntervalTree`` is essentially a ``dict`` of ``IntervalTree``-s, indexed by chromosome names::\n\n    gtree = GenomeIntervalTree()\n    gtree['chr1'].addi(10000, 20000)\n    \nThere is a convenience function for adding intervals::\n\n    gtree.addi('chr2', 20000, 30000)\n    \nYou can create a ``GenomeIntervalTree`` instance from a ``BED`` file::\n\n    test_url = 'http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeAwgTfbsUniform/wgEncodeAwgTfbsBroadDnd41Ezh239875UniPk.narrowPeak.gz'\n    data = zlib.decompress(urlopen(test_url).read(), 16+zlib.MAX_WBITS)\n    gtree = GenomeIntervalTree.from_bed(StringIO(data))\n    \nIn addition, special functions are offered to read in `UCSC tables of gene positions <https://genome.ucsc.edu/cgi-bin/hgTables>`_:\n\n* Load the UCSC ``knownGene`` table with each interval corresponding to gene's transcribed region::\n\n    knownGene = GenomeIntervalTree.from_table()\n  \n* Load the UCSC ``refGene`` table with each interval corresponding to gene's coding region::\n\n    url = 'http://hgdownload.cse.ucsc.edu/goldenpath/hg19/database/refGene.txt.gz'\n    refGene = GenomeIntervalTree.from_table(url=url, parser=UCSCTable.REF_GENE, mode='cds')\n    \n* Load the UCSC ``ensGene`` table with each interval corresponding to a gene's exon::\n\n    url = 'http://hgdownload.cse.ucsc.edu/goldenpath/hg19/database/ensGene.txt.gz'\n    ensGene = GenomeIntervalTree.from_table(url=url, parser=UCSCTable.ENS_GENE, mode='exons') \n\nYou may add methods for parsing your own tabular files with genomic intervals, see the documentation for ``GenomeIntervalTree.from_table``.\n\nBased on\n--------\n\n  * Eternally Confuzzled's `AVL tree <http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_avl.aspx>`_\n  * Wikipedia's `Interval Tree <http://en.wikipedia.org/wiki/Interval_tree>`_\n  * Heavily modified from Tyler Kahn's `Interval Tree implementation in Python <http://forrst.com/posts/Interval_Tree_implementation_in_python-e0K>`_ (`GitHub project <https://github.com/tylerkahn/intervaltree-python>`_)\n\nCopyright\n---------\n\n  * `Chaim-Leib Halbert <https://github.com/MusashiAharon/PyIntervalTree>`_\n  * This particular fork by `Konstantin Tretyakov <https://github.com/konstantint/PyIntervalTree>`_. See changes in CHANGELOG.txt.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/konstantint/PyIntervalTree", "keywords": "interval-tree data-structure intervals tree", "license": "LGPL", "maintainer": null, "maintainer_email": null, "name": "PyIntervalTree", "package_url": "https://pypi.org/project/PyIntervalTree/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/PyIntervalTree/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/konstantint/PyIntervalTree"}, "release_url": "https://pypi.org/project/PyIntervalTree/0.5/", "requires_dist": null, "requires_python": null, "summary": "Mutable, self-balancing interval tree", "version": "0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <blockquote>\n<p>NB: This package <strong>is deprecated</strong>. Please, use the <tt>intervaltree</tt> package instead (available via <a href=\"https://github.com/chaimleib/intervaltree\" rel=\"nofollow\">Github</a> or <a href=\"https://pypi.python.org/pypi/intervaltree\" rel=\"nofollow\">PyPI</a>).</p>\n<p>The genome-related functionality is extracted to the <tt><span class=\"pre\">intervaltree-bio</span></tt> package (<a href=\"https://github.com/konstantint/intervaltree-bio\" rel=\"nofollow\">Github</a>, <a href=\"https://pypi.python.org/pypi/intervaltree-bio\" rel=\"nofollow\">PyPI</a>).</p>\n<p><strong>No future versions of this package are planned. Do not file issues.</strong></p>\n</blockquote>\n<p>A mutable, self-balancing interval tree. Queries may be by point, by range\noverlap, or by range envelopment.</p>\n<p>This library was designed to allow tagging text and time intervals, where the\nintervals include the lower bound but not the upper bound.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>The easiest way to install most Python packages is via <tt>easy_install</tt> or <tt>pip</tt>:</p>\n<pre>$ pip install PyIntervalTree\n</pre>\n</div>\n<div id=\"features\">\n<h2>Features</h2>\n<ul>\n<li>Initialize blank or from an iterable of Intervals in O(n * log n).</li>\n<li>Insertions<ul>\n<li><tt>tree[begin:end] = data</tt></li>\n<li><tt>tree.add(interval)</tt></li>\n<li><tt>tree.addi(begin, end, data)</tt></li>\n<li><tt>tree.extend(list_of_interval_objs)</tt></li>\n</ul>\n</li>\n<li>Deletions<ul>\n<li><tt>tree.remove(interval)</tt>             (raises <tt>ValueError</tt> if not present)</li>\n<li><tt>tree.discard(interval)</tt>            (quiet if not present)</li>\n<li><tt>tree.removei(begin, end, data)</tt></li>\n<li><tt>tree.discardi(begin, end, data)</tt></li>\n<li><tt>tree.remove_overlap(point)</tt></li>\n<li><tt>tree.remove_overlap(begin, end)</tt>   (removes all overlapping the range)</li>\n<li><tt>tree.remove_envelop(begin, end)</tt>   (removes all enveloped in the range)</li>\n</ul>\n</li>\n<li>Overlap queries:<ul>\n<li><tt>tree[point]</tt></li>\n<li><tt>tree[begin:end]</tt></li>\n<li><tt>tree.search(point)</tt></li>\n<li><tt>tree.search(begin, end)</tt></li>\n</ul>\n</li>\n<li>Envelop queries:<ul>\n<li><tt>tree.search(begin, end, strict = True)</tt></li>\n</ul>\n</li>\n<li>Membership queries:<ul>\n<li><tt>interval_obj in tree</tt>              (this is fastest, O(1))</li>\n<li><tt>tree.containsi(begin, end, data)</tt></li>\n<li><tt>tree.overlaps(point)</tt></li>\n<li><tt>tree.overlaps(begin, end)</tt></li>\n</ul>\n</li>\n<li>Iterable:<ul>\n<li><tt>for interval_obj in tree:</tt></li>\n<li><tt>tree.items()</tt></li>\n</ul>\n</li>\n<li>Sizing:<ul>\n<li><tt>len(tree)</tt></li>\n<li><tt>tree.is_empty()</tt></li>\n<li><tt>not tree</tt></li>\n<li><tt>tree.begin()</tt> (the smallest coordinate of the leftmost interval)</li>\n<li><tt>tree.end()</tt> (the <tt>end</tt> coordinate of the rightmost interval)</li>\n</ul>\n</li>\n<li>Restructuring<ul>\n<li><tt>split_overlaps()</tt></li>\n</ul>\n</li>\n<li>Copy- and typecast-able:<ul>\n<li><tt>IntervalTree(tree)</tt>    (<tt>Interval</tt> objects are same as those in tree)</li>\n<li><tt>tree.copy()</tt>           (<tt>Interval</tt> objects are shallow copies of those in tree)</li>\n<li><tt>set(tree)</tt>             (can later be fed into <tt>IntervalTree()</tt>)</li>\n<li><tt>list(tree)</tt>            (ditto)</li>\n</ul>\n</li>\n<li>Equal-able</li>\n<li>Pickle-friendly</li>\n<li>Automatic AVL balancing</li>\n</ul>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<ul>\n<li><p>Getting started:</p>\n<pre>from intervaltree import Interval, IntervalTree\nt = IntervalTree()\n</pre>\n</li>\n<li><p>Adding intervals - you don\u2019t have to use strings!:</p>\n<pre>t[1:2] = \"1-2\"\nt[4:7] = \"4-7\"\nt[5:9] = \"5-9\"\n</pre>\n</li>\n<li><p>Query by point:</p>\n<pre>ivs = t[6]            # set([Interval(4, 7, '4-7'), Interval(5, 9, '5-9')])\niv = sorted(ivs)[0]   # Interval(4, 7, '4-7')\n</pre>\n</li>\n<li><p>Accessing an <tt>Interval</tt> object:</p>\n<pre>iv.begin  # 4\niv.end    # 7\niv.data   # \"4-7\"\n</pre>\n</li>\n<li><p>Query by range:</p>\n<p>Note that ranges are inclusive of the lower limit, but non-inclusive of the\nupper limit. So:</p>\n<pre>t[2:4]    # set([])\n</pre>\n<p>But:</p>\n<pre>t[1:5]    # set([Interval(1, 2, '1-2'), Interval(4, 7, '4-7')])\n</pre>\n</li>\n<li><p>Constructing from lists of <tt>Interval</tt>\u2019s:</p>\n<p>We could have made the same tree this way:</p>\n<pre>ivs = [ [1,2], [4,7], [5,9] ]\nivs = map( lambda begin,end: Interval(begin, end, \"%d-%d\" % (begin,end),\n           *zip(*ivs) )\n\nt = IntervalTree(ivs)\n</pre>\n</li>\n<li><p>Removing intervals:</p>\n<pre>t.remove( Interval(1, 2, \"1-2\") )\nlist(t)     # [Interval(4, 7, '4-7'), Interval(5, 9, '5-9')]\n\nt.remove( Interval(500, 1000, \"Doesn't exist\") # raises ValueError\nt.discard(Interval(500, 1000, \"Doesn't exist\") # quietly does nothing\n\nt.remove_overlap(5)\nlist(t)     # []\n</pre>\n<p>We could also empty a tree by removing all intervals, from the lowest bound\nto the highest bound of the <tt>IntervalTree</tt>:</p>\n<pre>t.remove_overlap(t.begin(), t.end())\n</pre>\n</li>\n</ul>\n</div>\n<div id=\"usage-with-genomic-data\">\n<h2>Usage with Genomic Data</h2>\n<p>Interval trees are especially commonly used in bioinformatics, where intervals correspond to genes or various features along the genome. Such intervals are commonly stored in <tt>BED</tt>-format files. To simplify working with such data, the package <tt>intervaltree.bio</tt> provides a <tt>GenomeIntervalTree</tt> class.</p>\n<p><tt>GenomeIntervalTree</tt> is essentially a <tt>dict</tt> of <tt>IntervalTree</tt>-s, indexed by chromosome names:</p>\n<pre>gtree = GenomeIntervalTree()\ngtree['chr1'].addi(10000, 20000)\n</pre>\n<p>There is a convenience function for adding intervals:</p>\n<pre>gtree.addi('chr2', 20000, 30000)\n</pre>\n<p>You can create a <tt>GenomeIntervalTree</tt> instance from a <tt>BED</tt> file:</p>\n<pre>test_url = 'http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeAwgTfbsUniform/wgEncodeAwgTfbsBroadDnd41Ezh239875UniPk.narrowPeak.gz'\ndata = zlib.decompress(urlopen(test_url).read(), 16+zlib.MAX_WBITS)\ngtree = GenomeIntervalTree.from_bed(StringIO(data))\n</pre>\n<p>In addition, special functions are offered to read in <a href=\"https://genome.ucsc.edu/cgi-bin/hgTables\" rel=\"nofollow\">UCSC tables of gene positions</a>:</p>\n<ul>\n<li><p>Load the UCSC <tt>knownGene</tt> table with each interval corresponding to gene\u2019s transcribed region:</p>\n<pre>knownGene = GenomeIntervalTree.from_table()\n</pre>\n</li>\n<li><p>Load the UCSC <tt>refGene</tt> table with each interval corresponding to gene\u2019s coding region:</p>\n<pre>url = 'http://hgdownload.cse.ucsc.edu/goldenpath/hg19/database/refGene.txt.gz'\nrefGene = GenomeIntervalTree.from_table(url=url, parser=UCSCTable.REF_GENE, mode='cds')\n</pre>\n</li>\n<li><p>Load the UCSC <tt>ensGene</tt> table with each interval corresponding to a gene\u2019s exon:</p>\n<pre>url = 'http://hgdownload.cse.ucsc.edu/goldenpath/hg19/database/ensGene.txt.gz'\nensGene = GenomeIntervalTree.from_table(url=url, parser=UCSCTable.ENS_GENE, mode='exons')\n</pre>\n</li>\n</ul>\n<p>You may add methods for parsing your own tabular files with genomic intervals, see the documentation for <tt>GenomeIntervalTree.from_table</tt>.</p>\n</div>\n<div id=\"based-on\">\n<h2>Based on</h2>\n<blockquote>\n<ul>\n<li>Eternally Confuzzled\u2019s <a href=\"http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_avl.aspx\" rel=\"nofollow\">AVL tree</a></li>\n<li>Wikipedia\u2019s <a href=\"http://en.wikipedia.org/wiki/Interval_tree\" rel=\"nofollow\">Interval Tree</a></li>\n<li>Heavily modified from Tyler Kahn\u2019s <a href=\"http://forrst.com/posts/Interval_Tree_implementation_in_python-e0K\" rel=\"nofollow\">Interval Tree implementation in Python</a> (<a href=\"https://github.com/tylerkahn/intervaltree-python\" rel=\"nofollow\">GitHub project</a>)</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"copyright\">\n<h2>Copyright</h2>\n<blockquote>\n<ul>\n<li><a href=\"https://github.com/MusashiAharon/PyIntervalTree\" rel=\"nofollow\">Chaim-Leib Halbert</a></li>\n<li>This particular fork by <a href=\"https://github.com/konstantint/PyIntervalTree\" rel=\"nofollow\">Konstantin Tretyakov</a>. See changes in CHANGELOG.txt.</li>\n</ul>\n</blockquote>\n</div>\n\n          </div>"}, "last_serial": 1383866, "releases": {"0.2.3": [{"comment_text": "", "digests": {"md5": "9763b1f7d1b3bda2e3177fea1c66adea", "sha256": "21ac05d074e5eb850af16080ba7017fa407dfeb3aa5877d682fe55a8f532e9dc"}, "downloads": -1, "filename": "PyIntervalTree-0.2.3.zip", "has_sig": false, "md5_digest": "9763b1f7d1b3bda2e3177fea1c66adea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28509, "upload_time": "2014-06-17T20:02:25", "upload_time_iso_8601": "2014-06-17T20:02:25.061622Z", "url": "https://files.pythonhosted.org/packages/5b/7d/c685968a7b4e15e795cc1109bdda2e4ee0b2a872225dd5f18c86f929f0ec/PyIntervalTree-0.2.3.zip", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "a9ce6cd439fb67ce5ac94318a8e17193", "sha256": "922a5a6f86efcc6e27a6bfb12ec0d4b7c7dc205f93ee85ab4471bd6e9a7a2453"}, "downloads": -1, "filename": "PyIntervalTree-0.3.zip", "has_sig": false, "md5_digest": "a9ce6cd439fb67ce5ac94318a8e17193", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29345, "upload_time": "2014-11-18T14:38:47", "upload_time_iso_8601": "2014-11-18T14:38:47.634922Z", "url": "https://files.pythonhosted.org/packages/fd/d0/4e56ba42c8b8b01ae1c923fd31eb5547f151ed8b307d35a86000f83f1e8f/PyIntervalTree-0.3.zip", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "8ff7b324df87656d20ed39203a5a1789", "sha256": "268b6b68c72b5c206f7eb0010eed443162577f58884edb4ea5fe01159e675144"}, "downloads": -1, "filename": "PyIntervalTree-0.4.zip", "has_sig": false, "md5_digest": "8ff7b324df87656d20ed39203a5a1789", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29518, "upload_time": "2014-12-02T01:12:24", "upload_time_iso_8601": "2014-12-02T01:12:24.208221Z", "url": "https://files.pythonhosted.org/packages/f2/7e/ece0dca1422371a67f0610d174879544fcbbe29c83b4f5fae39d9d8a36e3/PyIntervalTree-0.4.zip", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "d7c970ae01a94eed856a49063edf1a1f", "sha256": "e2558a26595e7af52f411d0c137fad58c95c4eb9fc7c19ac1c2fed6455fb46af"}, "downloads": -1, "filename": "PyIntervalTree-0.5.zip", "has_sig": false, "md5_digest": "d7c970ae01a94eed856a49063edf1a1f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34113, "upload_time": "2015-01-15T18:05:50", "upload_time_iso_8601": "2015-01-15T18:05:50.635015Z", "url": "https://files.pythonhosted.org/packages/aa/53/dbdb521c8e36301108114878ff1620255c559c12ba8fe0ce2eaf9b65cbef/PyIntervalTree-0.5.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d7c970ae01a94eed856a49063edf1a1f", "sha256": "e2558a26595e7af52f411d0c137fad58c95c4eb9fc7c19ac1c2fed6455fb46af"}, "downloads": -1, "filename": "PyIntervalTree-0.5.zip", "has_sig": false, "md5_digest": "d7c970ae01a94eed856a49063edf1a1f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34113, "upload_time": "2015-01-15T18:05:50", "upload_time_iso_8601": "2015-01-15T18:05:50.635015Z", "url": "https://files.pythonhosted.org/packages/aa/53/dbdb521c8e36301108114878ff1620255c559c12ba8fe0ce2eaf9b65cbef/PyIntervalTree-0.5.zip", "yanked": false}], "timestamp": "Fri May  8 03:03:57 2020"}