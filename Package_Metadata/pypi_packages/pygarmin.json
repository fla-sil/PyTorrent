{"info": {"author": "Quentin Stafford-Fraser", "author_email": "quentin@pobox.com", "bugtrack_url": null, "classifiers": [], "description": "PyGarmin\n========\n\n![PyGarmin](pygarmin.png)\n\nPyGarmin is a set of Python classes for interfacing with (mostly older) Garmin GPS equipment.\n\nBackground\n----------\n\nPyGarmin is a set of [Python] classes which implement the protocol used by\n[Garmin] GPS receivers to talk to each other and to other machines. It is based\non the official [protocol specification]. The project was started by [Quentin\nStafford-Fraser] but several others have helped to make it what it is today.\n\nPyGarmin is not a complete application. Some simple applications are now\nincluded, one of which is called pygarmin, but it is primarily just a toolkit\nto help you write applications.  This is a project which is in development.\nNo support. No guarantees. And so forth.\n\nHaving said all of that, this has been used to transfer information to and from\nseveral different Garmin receivers, mostly under Linux, though there is some\nWindows support now and people have used it on Mac OS X as well. If you use\nPyGarmin, it will probably be much quicker than writing your own software from\nscratch.\n\nWe suggest you read these docs first. The code looks quites scary if you don't\nknow what's happening, though it's actually pretty simple.\n\n\nBasics\n------\n\nAlmost every model of Garmin receiver implements a slightly different\nprotocol. They have many things in common, but there are minor differences.\nFor example, some receivers can display icons, and they therefore transmit\nwaypoints which have an extra 'symbol' field, which is not used in other\nmodels. Others don't use icons, but do store altitude. And so forth. You need\nto get the protocol right for your particular model.\n\nThis makes matters more complicated, but at least these things are well\ndocumented by Garmin. The [protocol specification]\nincludes a big table which details, for each product type, what protocol it\nuses for basic commands, what it uses for downloading waypoints, what it uses\nfor downloading routes, and so forth.\n\nI have created Python classes for each of the protocols listed in the spec,\nand for each of the data types. Well, most of them. The big table becomes, in\nPython, a mapping from the Garmin product ID to the set of relevant classes.\nThis means that, while there are a large number of classes defined in the\nsource, only a few of them will ever be used by any given receiver. The\nclasses are all given names based on those used in the specification, so look\nat the spec if you want to know more about the classes.\n\nThe class <tt>garmin.Garmin</tt> will connect to your GPS, read its product\nID and software version, and then look up the appropriate classes in the\ntable. It creates instances of the protocol classes and notes the datatype\nclasses for each type of data used in the transmisisons. It also has some\nfriendly methods like 'getWaypoints', which do what you would expect.\nWhat you get back when you call this is a list of objects, each of which is  an\ninstance of a class derived from garmin.Waypoint, but the precise type of the\nobjects will depend on the GPS you're talking to.\n\nInstallation\n------------\n\nPygarmin makes use of the PySerial package for talking to serial ports.  If you don't have it already you can do a standard\n\n    pip install -r requirements.txt\n\nto get it.\n\nYou may also need to set suitable permissions on the serial port (e.g /dev/ttyS0) that you're planning to use.\n\nExample Code\n------------\nOK. Here's a simple Python program. \n\n     #! /usr/bin/env python\n\n     import garmin\n\n     # Create a 'physical layer' connection using serial port\n     phys = garmin.UnixSerialLink(\"/dev/ttyS0\")\n\n     # Create a Garmin object using this connection\n     gps = garmin.Garmin(phys)\n\n     # Get the waypoints from the GPS\n     # (This may take a little while)\n     waypoints = gps.getWaypoints()\n\n     # Print the waypoints\n     for w in waypoints:\n         print w.ident,\n         lat = garmin.degrees(w.slat)\n         lon = garmin.degrees(w.slon)\n         print lat, lon, w.cmnt\n\nSimple, eh? This should work for almost any model, because all waypoints will have an identity, a latitude &amp; longitude, and a comment field. The latitude and longitude are stored in 'semicircle' coordinates (basically degrees, but scaled to fill a signed long integer), and so the fields are called 'slat' and 'slon'. The function `garmin.degrees()` converts these to degrees.\n\n\nMore details\n------------\n\nThere are 3 levels of protocol documented:\n\n     ................\n    |  Application   | (highest level)\n     ................\n    |  Link layer    |\n     ................\n    | Physical layer | (lowest level)\n     ................\n\nThe specification documents the various different versions of these under\nlabels of Pxxx, Lxxx, Axxx etc, where xxx is a number, and this convention is\nfollowed in the code. There are also various data types, named Dxxx. Roughly\nspeaking, the Physical protocols specify RS232, the Link protocols specify a\npacket structure for sending messages to and fro, and the Application\nprotocols specify what can actually go in those packets.\n\nFor example, a Garmin GPS 38 will talk to your computer over physical layer\nP000 (RS232) using a packet structure defined by link layer L001. If you want\nto transfer waypoints to and from it, they will be sent using application\nlayer A100 (a waypoint transfer protocol), and the actual waypoints\ntransferred will be of type D100.\n\nAt the time of writing, the only documented physical layer is P000 which is\nroughly RS232 at 9600 baud, 8 data bits, no parity, 1 stop bit. In the\nsoftware, we model this as a P000 class that has read and write methods, which\ncan be used by the higher protocol levels. The UnixSerialPort class used in\nthe sample code above is a subtype of P000.\n\nThat should be enough to get you going.\n\nSome data type classes are not implemented here, just because I got bored\nof typing. We've done the ones used by the more common units, but if yours\nisn't covered, it should be easy to add. They're only a few lines each.\n\n\nLicence\n-------\n\nThis software is released under the GNU General Public Licence v2. It comes with no warranties, explicit or implied, and you use it at your own risk.\n\n\nAcknowledgements\n----------------\n\nThanks are due to, amongst others:\n\n* [Quentin Stafford-Fraser](http://www.statusq.org)\n* James Skillen\n* [Bjorn Tillenius](http://tillenius.me/)\n* Hyrum K. Wright\n* Cedric Dutoit\n\nand probably others, to whom our apologies!\n\nThe logo was designed by [Quentin Stafford-Fraser].\n\n[Python]: http://www.python.org\n[Garmin]: http://www.garmin.com\n[protocol specification]: http://www.garmin.com/support/commProtocol.html\n[Quentin Stafford-Fraser]: http://quentinsf.com\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/quentinsf/pygarmin", "keywords": "gps gis", "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "pygarmin", "package_url": "https://pypi.org/project/pygarmin/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pygarmin/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/quentinsf/pygarmin"}, "release_url": "https://pypi.org/project/pygarmin/0.8/", "requires_dist": null, "requires_python": null, "summary": "A Python interface to older Garmin GPS equipment", "version": "0.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            PyGarmin<br>========<br><br>![PyGarmin](pygarmin.png)<br><br>PyGarmin is a set of Python classes for interfacing with (mostly older) Garmin GPS equipment.<br><br>Background<br>----------<br><br>PyGarmin is a set of [Python] classes which implement the protocol used by<br>[Garmin] GPS receivers to talk to each other and to other machines. It is based<br>on the official [protocol specification]. The project was started by [Quentin<br>Stafford-Fraser] but several others have helped to make it what it is today.<br><br>PyGarmin is not a complete application. Some simple applications are now<br>included, one of which is called pygarmin, but it is primarily just a toolkit<br>to help you write applications.  This is a project which is in development.<br>No support. No guarantees. And so forth.<br><br>Having said all of that, this has been used to transfer information to and from<br>several different Garmin receivers, mostly under Linux, though there is some<br>Windows support now and people have used it on Mac OS X as well. If you use<br>PyGarmin, it will probably be much quicker than writing your own software from<br>scratch.<br><br>We suggest you read these docs first. The code looks quites scary if you don't<br>know what's happening, though it's actually pretty simple.<br><br><br>Basics<br>------<br><br>Almost every model of Garmin receiver implements a slightly different<br>protocol. They have many things in common, but there are minor differences.<br>For example, some receivers can display icons, and they therefore transmit<br>waypoints which have an extra 'symbol' field, which is not used in other<br>models. Others don't use icons, but do store altitude. And so forth. You need<br>to get the protocol right for your particular model.<br><br>This makes matters more complicated, but at least these things are well<br>documented by Garmin. The [protocol specification]<br>includes a big table which details, for each product type, what protocol it<br>uses for basic commands, what it uses for downloading waypoints, what it uses<br>for downloading routes, and so forth.<br><br>I have created Python classes for each of the protocols listed in the spec,<br>and for each of the data types. Well, most of them. The big table becomes, in<br>Python, a mapping from the Garmin product ID to the set of relevant classes.<br>This means that, while there are a large number of classes defined in the<br>source, only a few of them will ever be used by any given receiver. The<br>classes are all given names based on those used in the specification, so look<br>at the spec if you want to know more about the classes.<br><br>The class &lt;tt&gt;garmin.Garmin&lt;/tt&gt; will connect to your GPS, read its product<br>ID and software version, and then look up the appropriate classes in the<br>table. It creates instances of the protocol classes and notes the datatype<br>classes for each type of data used in the transmisisons. It also has some<br>friendly methods like 'getWaypoints', which do what you would expect.<br>What you get back when you call this is a list of objects, each of which is  an<br>instance of a class derived from garmin.Waypoint, but the precise type of the<br>objects will depend on the GPS you're talking to.<br><br>Installation<br>------------<br><br>Pygarmin makes use of the PySerial package for talking to serial ports.  If you don't have it already you can do a standard<br><br>    pip install -r requirements.txt<br><br>to get it.<br><br>You may also need to set suitable permissions on the serial port (e.g /dev/ttyS0) that you're planning to use.<br><br>Example Code<br>------------<br>OK. Here's a simple Python program. <br><br>     #! /usr/bin/env python<br><br>     import garmin<br><br>     # Create a 'physical layer' connection using serial port<br>     phys = garmin.UnixSerialLink(\"/dev/ttyS0\")<br><br>     # Create a Garmin object using this connection<br>     gps = garmin.Garmin(phys)<br><br>     # Get the waypoints from the GPS<br>     # (This may take a little while)<br>     waypoints = gps.getWaypoints()<br><br>     # Print the waypoints<br>     for w in waypoints:<br>         print w.ident,<br>         lat = garmin.degrees(w.slat)<br>         lon = garmin.degrees(w.slon)<br>         print lat, lon, w.cmnt<br><br>Simple, eh? This should work for almost any model, because all waypoints will have an identity, a latitude &amp;amp; longitude, and a comment field. The latitude and longitude are stored in 'semicircle' coordinates (basically degrees, but scaled to fill a signed long integer), and so the fields are called 'slat' and 'slon'. The function `garmin.degrees()` converts these to degrees.<br><br><br>More details<br>------------<br><br>There are 3 levels of protocol documented:<br><br>     ................<br>    |  Application   | (highest level)<br>     ................<br>    |  Link layer    |<br>     ................<br>    | Physical layer | (lowest level)<br>     ................<br><br>The specification documents the various different versions of these under<br>labels of Pxxx, Lxxx, Axxx etc, where xxx is a number, and this convention is<br>followed in the code. There are also various data types, named Dxxx. Roughly<br>speaking, the Physical protocols specify RS232, the Link protocols specify a<br>packet structure for sending messages to and fro, and the Application<br>protocols specify what can actually go in those packets.<br><br>For example, a Garmin GPS 38 will talk to your computer over physical layer<br>P000 (RS232) using a packet structure defined by link layer L001. If you want<br>to transfer waypoints to and from it, they will be sent using application<br>layer A100 (a waypoint transfer protocol), and the actual waypoints<br>transferred will be of type D100.<br><br>At the time of writing, the only documented physical layer is P000 which is<br>roughly RS232 at 9600 baud, 8 data bits, no parity, 1 stop bit. In the<br>software, we model this as a P000 class that has read and write methods, which<br>can be used by the higher protocol levels. The UnixSerialPort class used in<br>the sample code above is a subtype of P000.<br><br>That should be enough to get you going.<br><br>Some data type classes are not implemented here, just because I got bored<br>of typing. We've done the ones used by the more common units, but if yours<br>isn't covered, it should be easy to add. They're only a few lines each.<br><br><br>Licence<br>-------<br><br>This software is released under the GNU General Public Licence v2. It comes with no warranties, explicit or implied, and you use it at your own risk.<br><br><br>Acknowledgements<br>----------------<br><br>Thanks are due to, amongst others:<br><br>* [Quentin Stafford-Fraser](http://www.statusq.org)<br>* James Skillen<br>* [Bjorn Tillenius](http://tillenius.me/)<br>* Hyrum K. Wright<br>* Cedric Dutoit<br><br>and probably others, to whom our apologies!<br><br>The logo was designed by [Quentin Stafford-Fraser].<br><br>[Python]: http://www.python.org<br>[Garmin]: http://www.garmin.com<br>[protocol specification]: http://www.garmin.com/support/commProtocol.html<br>[Quentin Stafford-Fraser]: http://quentinsf.com<br>\n          </div>"}, "last_serial": 1691064, "releases": {"0.8": [{"comment_text": "", "digests": {"md5": "fe6e5fe2578329d9f20b24a3994c1f28", "sha256": "d0c1c7083d43753b717755fe1188e60746d306424556f0c885d37af736c92aa1"}, "downloads": -1, "filename": "pygarmin-0.8.tar.gz", "has_sig": false, "md5_digest": "fe6e5fe2578329d9f20b24a3994c1f28", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47194, "upload_time": "2015-08-24T14:17:35", "upload_time_iso_8601": "2015-08-24T14:17:35.910167Z", "url": "https://files.pythonhosted.org/packages/04/0e/7f3fd5caa6bfddde0b24b1e66f408c291319938236f171d584f24c0363b2/pygarmin-0.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fe6e5fe2578329d9f20b24a3994c1f28", "sha256": "d0c1c7083d43753b717755fe1188e60746d306424556f0c885d37af736c92aa1"}, "downloads": -1, "filename": "pygarmin-0.8.tar.gz", "has_sig": false, "md5_digest": "fe6e5fe2578329d9f20b24a3994c1f28", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47194, "upload_time": "2015-08-24T14:17:35", "upload_time_iso_8601": "2015-08-24T14:17:35.910167Z", "url": "https://files.pythonhosted.org/packages/04/0e/7f3fd5caa6bfddde0b24b1e66f408c291319938236f171d584f24c0363b2/pygarmin-0.8.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:17 2020"}