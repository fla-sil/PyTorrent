{"info": {"author": "Dan Parker", "author_email": "dan.m.parker0@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# smm2sim\n\nThis package simulates the GSA Mario Maker 2 Endless Expert League regular season and playoffs using a simple, customizable Monte Carlo method.\n\n### Installation\n\nThe package is on [PyPI] and can be installed with pip:\n\n```\npip install smm2sim\n```\n\n### How it works\n\nDuring each simulation, smm2sim uses the methods described below to assign a winner to all remaining matches in the season. It then calculates seasonal point totals and breaks ties to determine playoff seeding, and the playoffs are simulated match-by-match. The playoff structure is assumed to be single-elimination best-of-3 matches with no reseeding.\n\nBefore beginning the simulations, each player is assigned a power rating (PWR), such that a player with a PWR of 8 would be expected to score an average of 8 points in a 15 minute match. By default, the base power rankings for each player are a simple average of their past results (excluding points scored during untimed tiebreakers). Custom ranking systems are also supported, which can be combined with the default ratings or replace them entirely. The individual rating systems and the combined rankings can be regressed to the mean (or to custom player-specific values) as desired.\n\nThe player PWR rankings are adjusted at the beginning of each season simulation by a random amount, determined using a normal distribution with mean 0 and a user-provided standard deviation (1 point by default):\n```\nadjusted_pwr = [PWR] - numpy.random.normal(0, [rank_adj])\n```\n    \nThis adjustment represents the uncertainty in each player's base PWR projection, which includes both model error and potential player skill changes. Higher values equate to more variance in outcomes.\n\nEach match consists of 3 simulated games. When simulating a game, player A's PWR is compared to player B's PWR. The resulting point differential is used to generate a normal cumulative distribution function, which estimates player A's probability of winning the game. This win probability is compared to a random number to determine the simulated winner of the game:\n```\npwr_difference = [PWR A] - [PWR B]\nwin_probability = 1 - scipy.stats.norm(pwr_difference, [stdev]).cdf(0)\nis_winner = numpy.random.random() < win_probability\n```\n\nThe standard deviation used to generate the normal distribution ([2.5 points by default]) is configurable.\n\n### Usage\n\n##### Basics\n\nEach simulation is controlled by a Simulate object. You create an object by specifying the number of simulations:\n```python\nimport smm2sim as smm2\nsimulation = smm2.Simulate(n_sims=10000)\n```\n    \nIf desired, you can customize the values of the PWR rank adjustment used at the beginning of each simulation and the standard deviation used when simulating individual games:\n```python\nsimulation = smm2.Simulate(n_sims=10000, rank_adj=1, st_dev=2.5)\n```    \n##### PWRsystems\n    \nYou can customize how the power rankings are generated by creating a PWRsystems object. You create an object by indicating which systems to include; the built-in system is called \"srs\":\n```python\nsystems = smm2.PWRsystems(srs=True)\nsimulation = smm2.Simulate(n_sims=10000, pwr_systems=systems)\n```\n\nYou can also use your own rating system by creating a generic PWR object and passing it a pandas DataFrame containing the custom rankings. The DataFrame must include one column called 'Player' containing the name of each player (case sensitive) and another column containing the rankings. The name of the ranking column should be unique from those of the other systems being used (so don't use \"SRS\"):\n```python\nmy_sys_df = pd.DataFrame([{'Player':'A','Power':7},{'Player':'B','Power':5}])\nmy_sys = smm2.PWR(values=my_sys_df)\nsystems = smm2.PWRsystems(others=my_sys)\n```\n\nYou can also combine multiple systems. The weights for each system (default = 1) can be specified using the built-in objects for each system:\n```python\nmy_sys_df = pandas.DataFrame([{'Player':'A','Power':7},{'Player':'B','Power':5}])\nmy_sys = smm2.PWR(weight=1, values=my_sys_df)\nsystems = smm2.PWRsystems(srs=smm2.SRS(weight=2), others=my_sys)\n```\n\nTo use multiple custom systems, pass a list of PWR objects instead of a single PWR object:\n```python\ndf1 = pd.DataFrame([{'Player':'A','Power1':7},{'Player':'B','Power1':5}])\ndf2 = pd.DataFrame([{'Player':'A','Power2':2},{'Player':'B','Power2':6}])\nmy_sys_1 = smm2.PWR(weight=2, values=df1)\nmy_sys_2 = smm2.PWR(weight=1.5, values=df2)\nsystems = smm2.PWRsystems(srs=True, others=[my_sys_1, my_sys_2])\n```\n\n##### Regression\n\nOptionally, you can choose to regress the ratings generated by each system by creating a Regression object (if regress_to is omitted, no regression will be used). By default, PWR values will be regressed to the sample mean:\n```python\nmy_sys = smm2.SRS(weight=2, regress_to=smm2.Regression())\n```\n\nYou can use fixed weighting by specifying a decimal between 0 and 1, or variable weighting based on the percentage of a specified number of games played (the default option):\n```python\n#(PWR * 0.75) + (sample_mean * 0.25)\nregression_fixed = smm2.Regression(weight=0.25)\n#((PWR * games_played) + (sample_mean * max(0, 12 - games_played))) / max(12, games_played)\nregression_variable = smm2.Regression(n_games=12)\n```\n    \nYou can regress PWR to a fixed value rather than using the sample mean:\n```python\nregression = smm2.Regression(to=0, weight=0.5)\n```\n    \nYou can also specify a custom regression value for each player using a pandas DataFrame. The DataFrame must contain one column called 'Player' containing the player names (case sensitive) and another called 'Baseline' for the regression values:\n```python\ndf = pd.DataFrame([{'Player':'A','Baseline':5},{'Player':'B','Baseline':8}])\nregression = smm2.Regression(to=df, n_games=33)\n```\n    \nIn addition to (or instead of) regressing the values for individual PWR systems, you can choose to regress the final results after combining the various systems:\n```python\nregression = smm2.Regression(n_games=12)\nsystems = smm2.PWRsystems(regress_to=regression, srs=True, others=my_sys)\n```\n\n##### Execution and Analysis\n\nOnce you've set up your Simulate object, use run() to execute the simulation.\n```python\nsimulation = smm2.Simulate(n_sims=10000)\nsimulation.run()\n```\n    \nThe run() method will return a reference to the Simulate object, so this syntax is also acceptable:\n```python\nsimulation = smm2.Simulate(n_sims=10000).run()\n```\n\nBy default, run() will use the joblib package to run the simulations in parallel; this can be overridden by setting parallel=False:\n```python\nsimulation = smm2.Simulate(n_sims=100).run(parallel=False)\n```\n    \nOnce the simulation has executed, the results are aggregated and stored in several related dataframes. These can either be directly accessed using the simulations property:\n```python\nstandings = sim.simulations.standings\nregularseason = sim.simulations.regularseason\nseeding = sim.simulations.seeding\nplayoffs = sim.simulations.playoffs\n```\n\nOr returned as copies using class methods:\n```python\nstandings = sim.standings()\nregularseason = sim.regularseason()\nseeding = sim.seeding()\nplayoffs = sim.playoffs()\n```\n\nBy default, all of the aggregated dataframes use MultiIndexes incorporating the simulation number and the within-simulation row number. The class methods include an option to extract the MultiIndex into separate columns in the dataframe:\n```python\nstandings_reindexed = sim.standings(reindex=True)\n```\n\nYou can also entirely disable the generation of aggregated statistics, in which case the results are stored as a list of Simulation objects:\n```python\nsim = smm2.Simulate(n_sims=100000).run(combine=False)\nfor simulation in sim.simulations.values:\n    rankings = simulation.rankings\n    standings = simulation.standings\n    regularseason = simulation.regularseason\n    seeding = simulation.seeding\n    playoffs = simulation.playoffs\n```\n\n[//]: #\n   [PyPI]: <https://pypi.org/project/smm2sim/>", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/dmparker0/smm2sim/archive/v1.0.10.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dmparker0/smm2sim/", "keywords": "Mario,SMM,SMM2,GSA,speedrun,simulation,statistics", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "smm2sim", "package_url": "https://pypi.org/project/smm2sim/", "platform": "", "project_url": "https://pypi.org/project/smm2sim/", "project_urls": {"Download": "https://github.com/dmparker0/smm2sim/archive/v1.0.10.tar.gz", "Homepage": "https://github.com/dmparker0/smm2sim/"}, "release_url": "https://pypi.org/project/smm2sim/1.0.10/", "requires_dist": null, "requires_python": "", "summary": "A tool for simulating the GSA Mario Maker 2 Endless Expert League", "version": "1.0.10", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>smm2sim</h1>\n<p>This package simulates the GSA Mario Maker 2 Endless Expert League regular season and playoffs using a simple, customizable Monte Carlo method.</p>\n<h3>Installation</h3>\n<p>The package is on <a href=\"https://pypi.org/project/smm2sim/\" rel=\"nofollow\">PyPI</a> and can be installed with pip:</p>\n<pre><code>pip install smm2sim\n</code></pre>\n<h3>How it works</h3>\n<p>During each simulation, smm2sim uses the methods described below to assign a winner to all remaining matches in the season. It then calculates seasonal point totals and breaks ties to determine playoff seeding, and the playoffs are simulated match-by-match. The playoff structure is assumed to be single-elimination best-of-3 matches with no reseeding.</p>\n<p>Before beginning the simulations, each player is assigned a power rating (PWR), such that a player with a PWR of 8 would be expected to score an average of 8 points in a 15 minute match. By default, the base power rankings for each player are a simple average of their past results (excluding points scored during untimed tiebreakers). Custom ranking systems are also supported, which can be combined with the default ratings or replace them entirely. The individual rating systems and the combined rankings can be regressed to the mean (or to custom player-specific values) as desired.</p>\n<p>The player PWR rankings are adjusted at the beginning of each season simulation by a random amount, determined using a normal distribution with mean 0 and a user-provided standard deviation (1 point by default):</p>\n<pre><code>adjusted_pwr = [PWR] - numpy.random.normal(0, [rank_adj])\n</code></pre>\n<p>This adjustment represents the uncertainty in each player's base PWR projection, which includes both model error and potential player skill changes. Higher values equate to more variance in outcomes.</p>\n<p>Each match consists of 3 simulated games. When simulating a game, player A's PWR is compared to player B's PWR. The resulting point differential is used to generate a normal cumulative distribution function, which estimates player A's probability of winning the game. This win probability is compared to a random number to determine the simulated winner of the game:</p>\n<pre><code>pwr_difference = [PWR A] - [PWR B]\nwin_probability = 1 - scipy.stats.norm(pwr_difference, [stdev]).cdf(0)\nis_winner = numpy.random.random() &lt; win_probability\n</code></pre>\n<p>The standard deviation used to generate the normal distribution ([2.5 points by default]) is configurable.</p>\n<h3>Usage</h3>\n<h5>Basics</h5>\n<p>Each simulation is controlled by a Simulate object. You create an object by specifying the number of simulations:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">smm2sim</span> <span class=\"k\">as</span> <span class=\"nn\">smm2</span>\n<span class=\"n\">simulation</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Simulate</span><span class=\"p\">(</span><span class=\"n\">n_sims</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">)</span>\n</pre>\n<p>If desired, you can customize the values of the PWR rank adjustment used at the beginning of each simulation and the standard deviation used when simulating individual games:</p>\n<pre><span class=\"n\">simulation</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Simulate</span><span class=\"p\">(</span><span class=\"n\">n_sims</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"n\">rank_adj</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">st_dev</span><span class=\"o\">=</span><span class=\"mf\">2.5</span><span class=\"p\">)</span>\n</pre>\n<h5>PWRsystems</h5>\n<p>You can customize how the power rankings are generated by creating a PWRsystems object. You create an object by indicating which systems to include; the built-in system is called \"srs\":</p>\n<pre><span class=\"n\">systems</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWRsystems</span><span class=\"p\">(</span><span class=\"n\">srs</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">simulation</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Simulate</span><span class=\"p\">(</span><span class=\"n\">n_sims</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"n\">pwr_systems</span><span class=\"o\">=</span><span class=\"n\">systems</span><span class=\"p\">)</span>\n</pre>\n<p>You can also use your own rating system by creating a generic PWR object and passing it a pandas DataFrame containing the custom rankings. The DataFrame must include one column called 'Player' containing the name of each player (case sensitive) and another column containing the rankings. The name of the ranking column should be unique from those of the other systems being used (so don't use \"SRS\"):</p>\n<pre><span class=\"n\">my_sys_df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'A'</span><span class=\"p\">,</span><span class=\"s1\">'Power'</span><span class=\"p\">:</span><span class=\"mi\">7</span><span class=\"p\">},{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'B'</span><span class=\"p\">,</span><span class=\"s1\">'Power'</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"p\">}])</span>\n<span class=\"n\">my_sys</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWR</span><span class=\"p\">(</span><span class=\"n\">values</span><span class=\"o\">=</span><span class=\"n\">my_sys_df</span><span class=\"p\">)</span>\n<span class=\"n\">systems</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWRsystems</span><span class=\"p\">(</span><span class=\"n\">others</span><span class=\"o\">=</span><span class=\"n\">my_sys</span><span class=\"p\">)</span>\n</pre>\n<p>You can also combine multiple systems. The weights for each system (default = 1) can be specified using the built-in objects for each system:</p>\n<pre><span class=\"n\">my_sys_df</span> <span class=\"o\">=</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'A'</span><span class=\"p\">,</span><span class=\"s1\">'Power'</span><span class=\"p\">:</span><span class=\"mi\">7</span><span class=\"p\">},{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'B'</span><span class=\"p\">,</span><span class=\"s1\">'Power'</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"p\">}])</span>\n<span class=\"n\">my_sys</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWR</span><span class=\"p\">(</span><span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"o\">=</span><span class=\"n\">my_sys_df</span><span class=\"p\">)</span>\n<span class=\"n\">systems</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWRsystems</span><span class=\"p\">(</span><span class=\"n\">srs</span><span class=\"o\">=</span><span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">SRS</span><span class=\"p\">(</span><span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">others</span><span class=\"o\">=</span><span class=\"n\">my_sys</span><span class=\"p\">)</span>\n</pre>\n<p>To use multiple custom systems, pass a list of PWR objects instead of a single PWR object:</p>\n<pre><span class=\"n\">df1</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'A'</span><span class=\"p\">,</span><span class=\"s1\">'Power1'</span><span class=\"p\">:</span><span class=\"mi\">7</span><span class=\"p\">},{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'B'</span><span class=\"p\">,</span><span class=\"s1\">'Power1'</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"p\">}])</span>\n<span class=\"n\">df2</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'A'</span><span class=\"p\">,</span><span class=\"s1\">'Power2'</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">},{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'B'</span><span class=\"p\">,</span><span class=\"s1\">'Power2'</span><span class=\"p\">:</span><span class=\"mi\">6</span><span class=\"p\">}])</span>\n<span class=\"n\">my_sys_1</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWR</span><span class=\"p\">(</span><span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"o\">=</span><span class=\"n\">df1</span><span class=\"p\">)</span>\n<span class=\"n\">my_sys_2</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWR</span><span class=\"p\">(</span><span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"o\">=</span><span class=\"n\">df2</span><span class=\"p\">)</span>\n<span class=\"n\">systems</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWRsystems</span><span class=\"p\">(</span><span class=\"n\">srs</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">others</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">my_sys_1</span><span class=\"p\">,</span> <span class=\"n\">my_sys_2</span><span class=\"p\">])</span>\n</pre>\n<h5>Regression</h5>\n<p>Optionally, you can choose to regress the ratings generated by each system by creating a Regression object (if regress_to is omitted, no regression will be used). By default, PWR values will be regressed to the sample mean:</p>\n<pre><span class=\"n\">my_sys</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">SRS</span><span class=\"p\">(</span><span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">regress_to</span><span class=\"o\">=</span><span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Regression</span><span class=\"p\">())</span>\n</pre>\n<p>You can use fixed weighting by specifying a decimal between 0 and 1, or variable weighting based on the percentage of a specified number of games played (the default option):</p>\n<pre><span class=\"c1\">#(PWR * 0.75) + (sample_mean * 0.25)</span>\n<span class=\"n\">regression_fixed</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Regression</span><span class=\"p\">(</span><span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"mf\">0.25</span><span class=\"p\">)</span>\n<span class=\"c1\">#((PWR * games_played) + (sample_mean * max(0, 12 - games_played))) / max(12, games_played)</span>\n<span class=\"n\">regression_variable</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Regression</span><span class=\"p\">(</span><span class=\"n\">n_games</span><span class=\"o\">=</span><span class=\"mi\">12</span><span class=\"p\">)</span>\n</pre>\n<p>You can regress PWR to a fixed value rather than using the sample mean:</p>\n<pre><span class=\"n\">regression</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Regression</span><span class=\"p\">(</span><span class=\"n\">to</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n</pre>\n<p>You can also specify a custom regression value for each player using a pandas DataFrame. The DataFrame must contain one column called 'Player' containing the player names (case sensitive) and another called 'Baseline' for the regression values:</p>\n<pre><span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'A'</span><span class=\"p\">,</span><span class=\"s1\">'Baseline'</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"p\">},{</span><span class=\"s1\">'Player'</span><span class=\"p\">:</span><span class=\"s1\">'B'</span><span class=\"p\">,</span><span class=\"s1\">'Baseline'</span><span class=\"p\">:</span><span class=\"mi\">8</span><span class=\"p\">}])</span>\n<span class=\"n\">regression</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Regression</span><span class=\"p\">(</span><span class=\"n\">to</span><span class=\"o\">=</span><span class=\"n\">df</span><span class=\"p\">,</span> <span class=\"n\">n_games</span><span class=\"o\">=</span><span class=\"mi\">33</span><span class=\"p\">)</span>\n</pre>\n<p>In addition to (or instead of) regressing the values for individual PWR systems, you can choose to regress the final results after combining the various systems:</p>\n<pre><span class=\"n\">regression</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Regression</span><span class=\"p\">(</span><span class=\"n\">n_games</span><span class=\"o\">=</span><span class=\"mi\">12</span><span class=\"p\">)</span>\n<span class=\"n\">systems</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">PWRsystems</span><span class=\"p\">(</span><span class=\"n\">regress_to</span><span class=\"o\">=</span><span class=\"n\">regression</span><span class=\"p\">,</span> <span class=\"n\">srs</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">others</span><span class=\"o\">=</span><span class=\"n\">my_sys</span><span class=\"p\">)</span>\n</pre>\n<h5>Execution and Analysis</h5>\n<p>Once you've set up your Simulate object, use run() to execute the simulation.</p>\n<pre><span class=\"n\">simulation</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Simulate</span><span class=\"p\">(</span><span class=\"n\">n_sims</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">)</span>\n<span class=\"n\">simulation</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<p>The run() method will return a reference to the Simulate object, so this syntax is also acceptable:</p>\n<pre><span class=\"n\">simulation</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Simulate</span><span class=\"p\">(</span><span class=\"n\">n_sims</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<p>By default, run() will use the joblib package to run the simulations in parallel; this can be overridden by setting parallel=False:</p>\n<pre><span class=\"n\">simulation</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Simulate</span><span class=\"p\">(</span><span class=\"n\">n_sims</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">parallel</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>Once the simulation has executed, the results are aggregated and stored in several related dataframes. These can either be directly accessed using the simulations property:</p>\n<pre><span class=\"n\">standings</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">simulations</span><span class=\"o\">.</span><span class=\"n\">standings</span>\n<span class=\"n\">regularseason</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">simulations</span><span class=\"o\">.</span><span class=\"n\">regularseason</span>\n<span class=\"n\">seeding</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">simulations</span><span class=\"o\">.</span><span class=\"n\">seeding</span>\n<span class=\"n\">playoffs</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">simulations</span><span class=\"o\">.</span><span class=\"n\">playoffs</span>\n</pre>\n<p>Or returned as copies using class methods:</p>\n<pre><span class=\"n\">standings</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">standings</span><span class=\"p\">()</span>\n<span class=\"n\">regularseason</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">regularseason</span><span class=\"p\">()</span>\n<span class=\"n\">seeding</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">seeding</span><span class=\"p\">()</span>\n<span class=\"n\">playoffs</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">playoffs</span><span class=\"p\">()</span>\n</pre>\n<p>By default, all of the aggregated dataframes use MultiIndexes incorporating the simulation number and the within-simulation row number. The class methods include an option to extract the MultiIndex into separate columns in the dataframe:</p>\n<pre><span class=\"n\">standings_reindexed</span> <span class=\"o\">=</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">standings</span><span class=\"p\">(</span><span class=\"n\">reindex</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>You can also entirely disable the generation of aggregated statistics, in which case the results are stored as a list of Simulation objects:</p>\n<pre><span class=\"n\">sim</span> <span class=\"o\">=</span> <span class=\"n\">smm2</span><span class=\"o\">.</span><span class=\"n\">Simulate</span><span class=\"p\">(</span><span class=\"n\">n_sims</span><span class=\"o\">=</span><span class=\"mi\">100000</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">combine</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">simulation</span> <span class=\"ow\">in</span> <span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">simulations</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">:</span>\n    <span class=\"n\">rankings</span> <span class=\"o\">=</span> <span class=\"n\">simulation</span><span class=\"o\">.</span><span class=\"n\">rankings</span>\n    <span class=\"n\">standings</span> <span class=\"o\">=</span> <span class=\"n\">simulation</span><span class=\"o\">.</span><span class=\"n\">standings</span>\n    <span class=\"n\">regularseason</span> <span class=\"o\">=</span> <span class=\"n\">simulation</span><span class=\"o\">.</span><span class=\"n\">regularseason</span>\n    <span class=\"n\">seeding</span> <span class=\"o\">=</span> <span class=\"n\">simulation</span><span class=\"o\">.</span><span class=\"n\">seeding</span>\n    <span class=\"n\">playoffs</span> <span class=\"o\">=</span> <span class=\"n\">simulation</span><span class=\"o\">.</span><span class=\"n\">playoffs</span>\n</pre>\n\n          </div>"}, "last_serial": 6853152, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "526934b5dd5c9b6c800eb0e666e17ed1", "sha256": "3d1db236a4842d97c548a729248df25b9bd418014f3f99a0219b7a3eae81500d"}, "downloads": -1, "filename": "smm2sim-1.0.0.tar.gz", "has_sig": false, "md5_digest": "526934b5dd5c9b6c800eb0e666e17ed1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13307, "upload_time": "2019-08-29T22:13:04", "upload_time_iso_8601": "2019-08-29T22:13:04.557567Z", "url": "https://files.pythonhosted.org/packages/df/e3/5b501b59622a0ae0e69245e2ad715e5bb7658269a4c57236b1bc90dea26c/smm2sim-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "92b1eb8a076c4999f22a9b245eb6c549", "sha256": "cb73a070f186062862dd116de9f5a0957213b7296a6550ce292ff4471cc76919"}, "downloads": -1, "filename": "smm2sim-1.0.1.tar.gz", "has_sig": false, "md5_digest": "92b1eb8a076c4999f22a9b245eb6c549", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13181, "upload_time": "2019-08-30T17:23:28", "upload_time_iso_8601": "2019-08-30T17:23:28.986185Z", "url": "https://files.pythonhosted.org/packages/ad/36/e9d388af24de1a97dc4d7630c96d4ac092d595b8c724909762de44803539/smm2sim-1.0.1.tar.gz", "yanked": false}], "1.0.10": [{"comment_text": "", "digests": {"md5": "fd1d3d9e53b08df4ff4c92bfd5c31690", "sha256": "5e5c98ddab021e604a126d43558c98742574db8a902e2011a736b9e5be71d36f"}, "downloads": -1, "filename": "smm2sim-1.0.10.tar.gz", "has_sig": false, "md5_digest": "fd1d3d9e53b08df4ff4c92bfd5c31690", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13739, "upload_time": "2020-03-20T22:38:47", "upload_time_iso_8601": "2020-03-20T22:38:47.450246Z", "url": "https://files.pythonhosted.org/packages/5c/56/4ba186562f411fc33478701e8d51ff6cc25701789231f27d10debfd39d8a/smm2sim-1.0.10.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "f1cb04e8303cc4c9c2a2a2d9b84d6c4b", "sha256": "de628a29d079d19defe4041778a564dd68a52abe24a778d1ecba9bf0a25a31b0"}, "downloads": -1, "filename": "smm2sim-1.0.2.tar.gz", "has_sig": false, "md5_digest": "f1cb04e8303cc4c9c2a2a2d9b84d6c4b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13215, "upload_time": "2019-09-03T20:28:56", "upload_time_iso_8601": "2019-09-03T20:28:56.976935Z", "url": "https://files.pythonhosted.org/packages/59/b4/18c7c94fdb36d4b9dbd2b619767ee087d47516ee6f224752c499ef74e8e9/smm2sim-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "11ab9d75449f6180e1841c50a7963d14", "sha256": "f72844dfeece45937d9510ab37dc605da0c5ad698505a64cf8acb84aac27e546"}, "downloads": -1, "filename": "smm2sim-1.0.3.tar.gz", "has_sig": false, "md5_digest": "11ab9d75449f6180e1841c50a7963d14", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13203, "upload_time": "2019-09-03T21:40:11", "upload_time_iso_8601": "2019-09-03T21:40:11.237988Z", "url": "https://files.pythonhosted.org/packages/9f/55/177abc31551f76ab042bbadb40cae1c0045bc0f1cc740e453d6689f5d8fc/smm2sim-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "cd09ddabce8e9ff64234ab2d23acf9ff", "sha256": "85c0a89a39a73cd9fdbd141862dbc810aa4d94daa8508d0a27abfc765d8a9309"}, "downloads": -1, "filename": "smm2sim-1.0.4.tar.gz", "has_sig": false, "md5_digest": "cd09ddabce8e9ff64234ab2d23acf9ff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13781, "upload_time": "2020-02-14T18:21:05", "upload_time_iso_8601": "2020-02-14T18:21:05.152870Z", "url": "https://files.pythonhosted.org/packages/c5/d6/563063c2b09e274213948f614b27611d5f1186bf4ad78f9501ed28b9358e/smm2sim-1.0.4.tar.gz", "yanked": false}], "1.0.5": [{"comment_text": "", "digests": {"md5": "4bb97f5e1d2ff3023a6e877b4f85b80b", "sha256": "1ad59af0c39b2d81999b069133ed643a7fb6a1a854dbc9f93c402bc27713e086"}, "downloads": -1, "filename": "smm2sim-1.0.5.tar.gz", "has_sig": false, "md5_digest": "4bb97f5e1d2ff3023a6e877b4f85b80b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13651, "upload_time": "2020-02-19T18:52:17", "upload_time_iso_8601": "2020-02-19T18:52:17.044939Z", "url": "https://files.pythonhosted.org/packages/3b/97/c106d901588594603c162b02339386adb39057a2019fb9965ab675970ab7/smm2sim-1.0.5.tar.gz", "yanked": false}], "1.0.6": [{"comment_text": "", "digests": {"md5": "0870b28eb349b163b0d7935cc742c538", "sha256": "87eb6e57b4912373f6d117d2cc93447e47af3bb8cd7fb7c78ff9535295d983fc"}, "downloads": -1, "filename": "smm2sim-1.0.6.tar.gz", "has_sig": false, "md5_digest": "0870b28eb349b163b0d7935cc742c538", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13640, "upload_time": "2020-02-19T18:55:25", "upload_time_iso_8601": "2020-02-19T18:55:25.021420Z", "url": "https://files.pythonhosted.org/packages/6f/19/e33fdcd0b318a63e050ade2157bed13213bed24b6e0b81894eb36338ffc5/smm2sim-1.0.6.tar.gz", "yanked": false}], "1.0.7": [{"comment_text": "", "digests": {"md5": "2485b5a5a4edf383e956f8745addd6ab", "sha256": "8d730beaf5aed5bb2405d0c5febec15622b531d766a72f2a68563b65e3026da3"}, "downloads": -1, "filename": "smm2sim-1.0.7.tar.gz", "has_sig": false, "md5_digest": "2485b5a5a4edf383e956f8745addd6ab", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13648, "upload_time": "2020-02-19T19:12:50", "upload_time_iso_8601": "2020-02-19T19:12:50.304130Z", "url": "https://files.pythonhosted.org/packages/06/36/3867ce3d411ef3ca9cf3a7531c7e5ce6424d2f828fd9fbfbf873aa9d861e/smm2sim-1.0.7.tar.gz", "yanked": false}], "1.0.8": [{"comment_text": "", "digests": {"md5": "6362a8d5ef136983c2223c933b4b40c4", "sha256": "fd73edef00b20482e2e1c61de1afbffb8bfa9832ed5ea2476eeed24e864be1f7"}, "downloads": -1, "filename": "smm2sim-1.0.8.tar.gz", "has_sig": false, "md5_digest": "6362a8d5ef136983c2223c933b4b40c4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13651, "upload_time": "2020-02-19T20:07:03", "upload_time_iso_8601": "2020-02-19T20:07:03.864201Z", "url": "https://files.pythonhosted.org/packages/20/82/80fe5d4d10b96c7343429427bf5a640f0e801022dbb7093788dc69ef5a9d/smm2sim-1.0.8.tar.gz", "yanked": false}], "1.0.9": [{"comment_text": "", "digests": {"md5": "9a9215f2c131ac8de50d797c36046334", "sha256": "1e6fdf6ec221f88e50640cfdf3e68eb42641499a072023c2d0222278d757c4ca"}, "downloads": -1, "filename": "smm2sim-1.0.9.tar.gz", "has_sig": false, "md5_digest": "9a9215f2c131ac8de50d797c36046334", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13651, "upload_time": "2020-02-19T20:22:10", "upload_time_iso_8601": "2020-02-19T20:22:10.525846Z", "url": "https://files.pythonhosted.org/packages/8a/ad/81fc0943767f8af040ee4fa988ce25f6c115eb81745d2d79357ed167f7fd/smm2sim-1.0.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fd1d3d9e53b08df4ff4c92bfd5c31690", "sha256": "5e5c98ddab021e604a126d43558c98742574db8a902e2011a736b9e5be71d36f"}, "downloads": -1, "filename": "smm2sim-1.0.10.tar.gz", "has_sig": false, "md5_digest": "fd1d3d9e53b08df4ff4c92bfd5c31690", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13739, "upload_time": "2020-03-20T22:38:47", "upload_time_iso_8601": "2020-03-20T22:38:47.450246Z", "url": "https://files.pythonhosted.org/packages/5c/56/4ba186562f411fc33478701e8d51ff6cc25701789231f27d10debfd39d8a/smm2sim-1.0.10.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:52 2020"}