{"info": {"author": "Monsyne Dragon", "author_email": "mdragon@rackspace.com", "bugtrack_url": null, "classifiers": [], "description": "# stackdistiller\n\nA data extraction and transformation library for OpenStack notifications.\n\nStackdistiller is designed to extract data from openstack notifications\nand convert it into a form relevant to the application consuming the\nnotification. It consists of two components, the Distiller, which extracts\ndata from notifications according to a YAML [config file](doc/event_definitions_config.md),\nand the Condenser, which receives the data extracted by the Distiller,\nand formats it into an application-specific object, referred to as an Event.\nThis could be a simple python dictionary, an XML document tree, or a set of\nORM model objects.\n\n## Distiller\n\nThe Distiller reads a YAML config file to determine what data to extract\nfrom each notification, according to it's event type. event types can be\nwildcarded using shell glob syntax. The distiller will extract two types of\ndata from each notification:\n\n* Metadata from the notifications envelope, including the event type,\n  message id (uuid of the notification) and the timestamp showing when\n  notification was generated by the source system.\n* A series of data items extracted from the notification's body. These\n  are called Traits. Traits are basically just typed name-value pairs.\n\nThe distiller can also do some basic data massaging on traits extracted\nfrom the notification, such as splitting a value from a string. This is\nhandled by trait plugins. These are just classes that implement the\nTraitPluginBase interface. They are referred to by name in the config, and\nare looked up in a trait\\_plugin\\_map passed to the distiller on init.\nThe plugin map is just a dictionary, or dictionary-like object (such as a\nplugin manager) that maps names to plugin classes. If no map is passed to\nthe distiller, it will use a default that just contains the builtin plugins\nbundled with stackdistiller.\n\nIf a notification does not match any event definition in the distiller's\nconfig file, the distiller's to\\_event method will return None, indicating\nit cannot extract that notification. This may be what you want (i.e. your\napplication may only be interested in certain notifications.), but if you\nwant to record basic informaton from *any* event type, you can pass\n\"catchall=True\" to the distiller, and it will generate a minimal event from\nany notification.\n\n## Condenser\n\nThe Condenser receives the data extracted from the notification by the\nDistiller and formats it into an appropriate type of Event object.\nAn instance of a Condenser class is passed, along with the raw,\ndeserialized notification, to the distiller object's to\\_event method.\nTo create your own type of Event from the data extracted by the distiller,\nyou just need to create a Condenser class to receive the data.\nCondenser classes don't have to subclass any particular class, as long as\nthey implement the methods defined in stackdistiller.condenser.CondenserBase.\nIf you do not pass a condenser to the distiller when you call to\\_event,\nit will create an instance of the default DictionaryCondenser for you.\nThis just formats the event as a plain python dictionary.\n\n## Example:\n\n    import json\n    from stackdistiller import distiller\n    from stackdistiller import condenser\n\n    config_file_name = \"events_i_want.yaml\"\n    notification_string = open('a_notification_here.json', 'r').read()\n\n    notification = json.loads(notification_string)\n    config = distiller.load_config(config_file_name)\n\n    dist = distiller.Distiller(config, catchall=False)\n\n    #this is the default condenser.\n    cond = condenser.DictionaryCondenser()\n\n    if dist.to_event(notification, cond):\n        # What get_event() returns is up to the condenser class. In this\n        # case, it's a dictionary.\n        event = cond.get_event()\n        print \"Yay! An Event: %s\" % str(event)\n    else:\n        print \"Not something we are interested in. Ignoring.\"", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/stackforge/stacktach-stackdistiller", "keywords": "OpenStack\nnotifications\nevents\nextraction\ntransformation", "license": "Apache-2", "maintainer": null, "maintainer_email": null, "name": "stackdistiller", "package_url": "https://pypi.org/project/stackdistiller/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/stackdistiller/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/stackforge/stacktach-stackdistiller"}, "release_url": "https://pypi.org/project/stackdistiller/0.12/", "requires_dist": null, "requires_python": null, "summary": "A data extraction and transformation library for OpenStack notifications", "version": "0.12", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p># stackdistiller</p>\n<p>A data extraction and transformation library for OpenStack notifications.</p>\n<p>Stackdistiller is designed to extract data from openstack notifications\nand convert it into a form relevant to the application consuming the\nnotification. It consists of two components, the Distiller, which extracts\ndata from notifications according to a YAML [config file](doc/event_definitions_config.md),\nand the Condenser, which receives the data extracted by the Distiller,\nand formats it into an application-specific object, referred to as an Event.\nThis could be a simple python dictionary, an XML document tree, or a set of\nORM model objects.</p>\n<p>## Distiller</p>\n<p>The Distiller reads a YAML config file to determine what data to extract\nfrom each notification, according to it\u2019s event type. event types can be\nwildcarded using shell glob syntax. The distiller will extract two types of\ndata from each notification:</p>\n<ul>\n<li>Metadata from the notifications envelope, including the event type,\nmessage id (uuid of the notification) and the timestamp showing when\nnotification was generated by the source system.</li>\n<li>A series of data items extracted from the notification\u2019s body. These\nare called Traits. Traits are basically just typed name-value pairs.</li>\n</ul>\n<p>The distiller can also do some basic data massaging on traits extracted\nfrom the notification, such as splitting a value from a string. This is\nhandled by trait plugins. These are just classes that implement the\nTraitPluginBase interface. They are referred to by name in the config, and\nare looked up in a trait_plugin_map passed to the distiller on init.\nThe plugin map is just a dictionary, or dictionary-like object (such as a\nplugin manager) that maps names to plugin classes. If no map is passed to\nthe distiller, it will use a default that just contains the builtin plugins\nbundled with stackdistiller.</p>\n<p>If a notification does not match any event definition in the distiller\u2019s\nconfig file, the distiller\u2019s to_event method will return None, indicating\nit cannot extract that notification. This may be what you want (i.e. your\napplication may only be interested in certain notifications.), but if you\nwant to record basic informaton from <em>any</em> event type, you can pass\n\u201ccatchall=True\u201d to the distiller, and it will generate a minimal event from\nany notification.</p>\n<p>## Condenser</p>\n<p>The Condenser receives the data extracted from the notification by the\nDistiller and formats it into an appropriate type of Event object.\nAn instance of a Condenser class is passed, along with the raw,\ndeserialized notification, to the distiller object\u2019s to_event method.\nTo create your own type of Event from the data extracted by the distiller,\nyou just need to create a Condenser class to receive the data.\nCondenser classes don\u2019t have to subclass any particular class, as long as\nthey implement the methods defined in stackdistiller.condenser.CondenserBase.\nIf you do not pass a condenser to the distiller when you call to_event,\nit will create an instance of the default DictionaryCondenser for you.\nThis just formats the event as a plain python dictionary.</p>\n<p>## Example:</p>\n<blockquote>\n<p>import json\nfrom stackdistiller import distiller\nfrom stackdistiller import condenser</p>\n<p>config_file_name = \u201cevents_i_want.yaml\u201d\nnotification_string = open(\u2018a_notification_here.json\u2019, \u2018r\u2019).read()</p>\n<p>notification = json.loads(notification_string)\nconfig = distiller.load_config(config_file_name)</p>\n<p>dist = distiller.Distiller(config, catchall=False)</p>\n<p>#this is the default condenser.\ncond = condenser.DictionaryCondenser()</p>\n<dl>\n<dt>if dist.to_event(notification, cond):</dt>\n<dd># What get_event() returns is up to the condenser class. In this\n# case, it\u2019s a dictionary.\nevent = cond.get_event()\nprint \u201cYay! An Event: %s\u201d % str(event)</dd>\n<dt>else:</dt>\n<dd>print \u201cNot something we are interested in. Ignoring.\u201d</dd>\n</dl>\n</blockquote>\n\n          </div>"}, "last_serial": 1573857, "releases": {"0.10": [{"comment_text": "", "digests": {"md5": "2d96891e5fc719eaaa5d21da2acf0ae5", "sha256": "f00385335062197ba8133d72e8da6b92ac3cd3be57260451fd5b2ae267986a42"}, "downloads": -1, "filename": "stackdistiller-0.10.tar.gz", "has_sig": false, "md5_digest": "2d96891e5fc719eaaa5d21da2acf0ae5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18238, "upload_time": "2014-05-29T19:59:32", "upload_time_iso_8601": "2014-05-29T19:59:32.499216Z", "url": "https://files.pythonhosted.org/packages/6e/00/e780c2fa3b2246c3215754c68cb89514edc6ac2aa5a8d690160ac15094b2/stackdistiller-0.10.tar.gz", "yanked": false}], "0.11": [{"comment_text": "", "digests": {"md5": "3004303c8f2aa6df57db41a5bb99c734", "sha256": "6b0ead451476b563cd42a301501259fc67482be0181379bc1c0178d93ceb7b99"}, "downloads": -1, "filename": "stackdistiller-0.11.tar.gz", "has_sig": false, "md5_digest": "3004303c8f2aa6df57db41a5bb99c734", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9949, "upload_time": "2015-01-06T20:22:13", "upload_time_iso_8601": "2015-01-06T20:22:13.306076Z", "url": "https://files.pythonhosted.org/packages/37/92/ac3991e7d6450952dfc1347c43f5af01df83cd55c156f80e6445d6322883/stackdistiller-0.11.tar.gz", "yanked": false}], "0.12": [{"comment_text": "", "digests": {"md5": "036401ea2b41b52c94fbfd24d9b8aa75", "sha256": "397a22d1744d6ef197e6753a0a9bd5fb86a8a52aa678714c51fd43e706c171c3"}, "downloads": -1, "filename": "stackdistiller-0.12.tar.gz", "has_sig": false, "md5_digest": "036401ea2b41b52c94fbfd24d9b8aa75", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22397, "upload_time": "2015-06-01T19:35:57", "upload_time_iso_8601": "2015-06-01T19:35:57.995366Z", "url": "https://files.pythonhosted.org/packages/6b/c0/ea4d5f0428ef85ed3d4272429f50d85ff40d529dd3bbb1e36b98b01d14e8/stackdistiller-0.12.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "036401ea2b41b52c94fbfd24d9b8aa75", "sha256": "397a22d1744d6ef197e6753a0a9bd5fb86a8a52aa678714c51fd43e706c171c3"}, "downloads": -1, "filename": "stackdistiller-0.12.tar.gz", "has_sig": false, "md5_digest": "036401ea2b41b52c94fbfd24d9b8aa75", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22397, "upload_time": "2015-06-01T19:35:57", "upload_time_iso_8601": "2015-06-01T19:35:57.995366Z", "url": "https://files.pythonhosted.org/packages/6b/c0/ea4d5f0428ef85ed3d4272429f50d85ff40d529dd3bbb1e36b98b01d14e8/stackdistiller-0.12.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:52 2020"}