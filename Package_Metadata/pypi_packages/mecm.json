{"info": {"author": "Quentin Baghi", "author_email": "", "bugtrack_url": null, "classifiers": [], "description": "mecm\n=================\n\n\n\nThe MECM python package provides an implementation of the modified expectation maximization\nalgorithm developed by Q. Baghi et al., for which a reference can be found in\nhttps://arxiv.org/abs/1608.08530\n\n\n\nShort Description\n-----------------\n\nThe MECM package is a tool to perform gaussian linear regressions on time series affected\nby colored stationary noise and missing data. It is based on an algorithm close to the\nexpectation-maximization, which is efficiently implemented by taking advantage of fast\nFourier transforms, fast matrix-to-vector multiplications, and sparse linear algebra.\n\nLet's consider a data model that can be written on the form\n\n.. math::\n\n  y = A \\beta + n\n\nwhere:\n\n  * y is the measured time series data (size N), evenly sampled.\n\n  * A is the design matrix (size N x K)\n\n  * beta is the vector of parameters to estimate (size K)\n\n  * n is the noise vector, assumed to follow a Gaussian stationary distribution with a given smooth spectral density S(f)\n\nNow assume that only some entries of the vector y are observed. The indices of\nobserved and missing data are provided by a binary mask vector M, whose entries\nare equal to 1 when data are observed, 0 otherwise.\nSo in fact we observe only a vector y_obs such that\n\n.. code-block::\n\n  y_obs = y[M==1]\n\nThe mecm package implements a method to estimate $\\beta$ and $S(f)$ given y_obs,\nA and M.\n\n\nThe main methods of the package are:\n\n  * maxlike: quasi-maximum likelihood estimation with missing data for gaussian stationary models of the form $y = A*beta + epsilon$\n\n  * PSD_estimate: a class to perform power spectral density estimation with local linear smoothers.\n\n  * conditionalDraw: a function computing the conditional expectation of the missing data conditionally on the observed data, assuming a Gaussian stationary model.\n\n\n\n\nRequired Packages\n-----------------\n\nPrior to installation make sure that the following python packages are already installed:\n\n* NumPy: http://www.numpy.org/\n\n* SciPy: https://www.scipy.org/\n\n* pyFFTW: https://pypi.python.org/pypi/pyFFTW\n\n* cvxopt: http://cvxopt.org/\n\n* numba: https://numba.pydata.org/\n\n\n\nInstallation\n------------\n\nmecm can be installed by unzipping the source code in one directory, then open up a terminal (or execute a CMD on Windows) and using this command: ::\n\n    sudo python setup.py install\n\nYou can also install it directly from the Python Package Index with this command: ::\n\n    sudo pip mecm install\n\n\n\n\n\nLicence\n-------\n\nSee `licence file <https://github.com/Porlopopof/mecm/blob/master/LICENCE.txt>`_\n\n\nQuick start guide\n-----------------\n\nMECM can be basically used to perform any multilinear regression analysis where\nthe distribution of the noise is assumed to be Gaussian and stationary in the\nwide sense, with a smooth power spectral density (PSD).\n\nLet us show how it works with an example.\n\n1. Data generation\n\nTo begin with, we generate some simple time series which contains noise and signal.\nTo generate the noise, we start with a white, zero-mean Gaussian noise that\nwe then filter to obtain a stationary colored noise:\n\n.. code-block::\n\n  # Import mecm and other useful packages\n  import mecm\n  import numpy as np\n  import random\n  from scipy import signal\n  # Choose size of data\n  N = 2**14\n  # Generate Gaussian white noise\n  noise = np.random.normal(loc=0.0, scale=1.0, size = N)\n  # Apply filtering to turn it into colored noise\n  r = 0.01\n  b, a = signal.butter(3, 0.1/0.5, btype='high', analog=False)\n  n = signal.lfilter(b,a, noise, axis=-1, zi=None) + noise*r\n\nThen we need a deterministic signal to add. We choose a sinusoid with some\nfrequency f0 and amplitude a0:\n\n.. code-block::\n\n  t = np.arange(0,N)\n  f0 = 1e-2\n  a0 = 5e-3\n  s = a0*np.sin(2*np.pi*f0*t)\n\nWe just have generated a time series that can be written in the form\n\n.. math::\n\n  y = A \\beta + n\n\nNow assume that some data are missing, i.e. the time series is cut by random gaps.\nThe pattern is represented by a mask vector M with entries equal to 1 when data\nis observed, and 0 otherwise:\n\n.. code-block::\n\n  M = np.ones(N)\n  Ngaps = 30\n  gapstarts = (N*np.random.random(Ngaps)).astype(int)\n  gaplength = 10\n  gapends = (gapstarts+gaplength).astype(int)\n  for k in range(Ngaps): M[gapstarts[k]:gapends[k]]= 0\n\nTherefore, we do not observe y but its masked version, M*y.\n\n2. Linear regression\n\nNow let's assume that we observed M*y and that we want to estimate the amplitude\nof the sine wave whose frequency and phase are known, along with the PSD of the\nnoise residuals.\nThe available data is\n\n.. code-block::\n\n  y = M*(s+n)\n\nWe must specify the design matrix (i.e. the data model) by:\n\n.. code-block::\n\n  A = np.array([np.sin(2*np.pi*f0*t)]).T\n\nThen we can just run the mecm maximum likelihood estimator, by writing:\n\n.. code-block::\n\n  a0_est,a0_cov,a0_vect,y_rec,I_condMean,PSD = mecm.maxlike(y,M,A)\n\nThe result of this function is, in the order provided: the estimated amplitude,\nits estimated covariance, the vector containing the amplitude updates at each\niteration of the algorithm, the estimated complete-data vector, the conditional\nexpectation of the data periodogram (at Fourier frequencies), and an instance of\nthe PSD_estimate class.\n\nDocumentation\n-------------\n\nFor a more detailed description of the outputs and information about how to tune\nthe mecm algorithm, please have a look at the `documentation <https://github.com/Porlopopof/mecm/blob/master/docs/build/html/index.html>`_\n\n\nContribute\n----------\nmecm is an open-source software. Everyone is welcome to contribute !\nPlease site the original paper in scientific contributions:\nhttps://arxiv.org/abs/1608.08530\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "see LICENSE.txt", "maintainer": "", "maintainer_email": "", "name": "mecm", "package_url": "https://pypi.org/project/mecm/", "platform": "", "project_url": "https://pypi.org/project/mecm/", "project_urls": null, "release_url": "https://pypi.org/project/mecm/0.1.0/", "requires_dist": null, "requires_python": "", "summary": "", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            mecm<br>=================<br><br><br><br>The MECM python package provides an implementation of the modified expectation maximization<br>algorithm developed by Q. Baghi et al., for which a reference can be found in<br>https://arxiv.org/abs/1608.08530<br><br><br><br>Short Description<br>-----------------<br><br>The MECM package is a tool to perform gaussian linear regressions on time series affected<br>by colored stationary noise and missing data. It is based on an algorithm close to the<br>expectation-maximization, which is efficiently implemented by taking advantage of fast<br>Fourier transforms, fast matrix-to-vector multiplications, and sparse linear algebra.<br><br>Let's consider a data model that can be written on the form<br><br>.. math::<br><br>  y = A \\beta + n<br><br>where:<br><br>  * y is the measured time series data (size N), evenly sampled.<br><br>  * A is the design matrix (size N x K)<br><br>  * beta is the vector of parameters to estimate (size K)<br><br>  * n is the noise vector, assumed to follow a Gaussian stationary distribution with a given smooth spectral density S(f)<br><br>Now assume that only some entries of the vector y are observed. The indices of<br>observed and missing data are provided by a binary mask vector M, whose entries<br>are equal to 1 when data are observed, 0 otherwise.<br>So in fact we observe only a vector y_obs such that<br><br>.. code-block::<br><br>  y_obs = y[M==1]<br><br>The mecm package implements a method to estimate $\\beta$ and $S(f)$ given y_obs,<br>A and M.<br><br><br>The main methods of the package are:<br><br>  * maxlike: quasi-maximum likelihood estimation with missing data for gaussian stationary models of the form $y = A*beta + epsilon$<br><br>  * PSD_estimate: a class to perform power spectral density estimation with local linear smoothers.<br><br>  * conditionalDraw: a function computing the conditional expectation of the missing data conditionally on the observed data, assuming a Gaussian stationary model.<br><br><br><br><br>Required Packages<br>-----------------<br><br>Prior to installation make sure that the following python packages are already installed:<br><br>* NumPy: http://www.numpy.org/<br><br>* SciPy: https://www.scipy.org/<br><br>* pyFFTW: https://pypi.python.org/pypi/pyFFTW<br><br>* cvxopt: http://cvxopt.org/<br><br>* numba: https://numba.pydata.org/<br><br><br><br>Installation<br>------------<br><br>mecm can be installed by unzipping the source code in one directory, then open up a terminal (or execute a CMD on Windows) and using this command: ::<br><br>    sudo python setup.py install<br><br>You can also install it directly from the Python Package Index with this command: ::<br><br>    sudo pip mecm install<br><br><br><br><br><br>Licence<br>-------<br><br>See `licence file &lt;https://github.com/Porlopopof/mecm/blob/master/LICENCE.txt&gt;`_<br><br><br>Quick start guide<br>-----------------<br><br>MECM can be basically used to perform any multilinear regression analysis where<br>the distribution of the noise is assumed to be Gaussian and stationary in the<br>wide sense, with a smooth power spectral density (PSD).<br><br>Let us show how it works with an example.<br><br>1. Data generation<br><br>To begin with, we generate some simple time series which contains noise and signal.<br>To generate the noise, we start with a white, zero-mean Gaussian noise that<br>we then filter to obtain a stationary colored noise:<br><br>.. code-block::<br><br>  # Import mecm and other useful packages<br>  import mecm<br>  import numpy as np<br>  import random<br>  from scipy import signal<br>  # Choose size of data<br>  N = 2**14<br>  # Generate Gaussian white noise<br>  noise = np.random.normal(loc=0.0, scale=1.0, size = N)<br>  # Apply filtering to turn it into colored noise<br>  r = 0.01<br>  b, a = signal.butter(3, 0.1/0.5, btype='high', analog=False)<br>  n = signal.lfilter(b,a, noise, axis=-1, zi=None) + noise*r<br><br>Then we need a deterministic signal to add. We choose a sinusoid with some<br>frequency f0 and amplitude a0:<br><br>.. code-block::<br><br>  t = np.arange(0,N)<br>  f0 = 1e-2<br>  a0 = 5e-3<br>  s = a0*np.sin(2*np.pi*f0*t)<br><br>We just have generated a time series that can be written in the form<br><br>.. math::<br><br>  y = A \\beta + n<br><br>Now assume that some data are missing, i.e. the time series is cut by random gaps.<br>The pattern is represented by a mask vector M with entries equal to 1 when data<br>is observed, and 0 otherwise:<br><br>.. code-block::<br><br>  M = np.ones(N)<br>  Ngaps = 30<br>  gapstarts = (N*np.random.random(Ngaps)).astype(int)<br>  gaplength = 10<br>  gapends = (gapstarts+gaplength).astype(int)<br>  for k in range(Ngaps): M[gapstarts[k]:gapends[k]]= 0<br><br>Therefore, we do not observe y but its masked version, M*y.<br><br>2. Linear regression<br><br>Now let's assume that we observed M*y and that we want to estimate the amplitude<br>of the sine wave whose frequency and phase are known, along with the PSD of the<br>noise residuals.<br>The available data is<br><br>.. code-block::<br><br>  y = M*(s+n)<br><br>We must specify the design matrix (i.e. the data model) by:<br><br>.. code-block::<br><br>  A = np.array([np.sin(2*np.pi*f0*t)]).T<br><br>Then we can just run the mecm maximum likelihood estimator, by writing:<br><br>.. code-block::<br><br>  a0_est,a0_cov,a0_vect,y_rec,I_condMean,PSD = mecm.maxlike(y,M,A)<br><br>The result of this function is, in the order provided: the estimated amplitude,<br>its estimated covariance, the vector containing the amplitude updates at each<br>iteration of the algorithm, the estimated complete-data vector, the conditional<br>expectation of the data periodogram (at Fourier frequencies), and an instance of<br>the PSD_estimate class.<br><br>Documentation<br>-------------<br><br>For a more detailed description of the outputs and information about how to tune<br>the mecm algorithm, please have a look at the `documentation &lt;https://github.com/Porlopopof/mecm/blob/master/docs/build/html/index.html&gt;`_<br><br><br>Contribute<br>----------<br>mecm is an open-source software. Everyone is welcome to contribute !<br>Please site the original paper in scientific contributions:<br>https://arxiv.org/abs/1608.08530<br>\n          </div>"}, "last_serial": 3747119, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "a827fddcc33fb969957610a2b07d21a4", "sha256": "752fae6d40d82ead7cbfa4901c5dbe1df762263e2f497e8c8fd0a10f64d1d004"}, "downloads": -1, "filename": "mecm-0.1.0.tar.gz", "has_sig": false, "md5_digest": "a827fddcc33fb969957610a2b07d21a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37784, "upload_time": "2018-04-09T00:03:42", "upload_time_iso_8601": "2018-04-09T00:03:42.680399Z", "url": "https://files.pythonhosted.org/packages/a5/0f/f36f13001ef3d4d16dda8c95cff563538e53016922ea5d98502fee077c1c/mecm-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a827fddcc33fb969957610a2b07d21a4", "sha256": "752fae6d40d82ead7cbfa4901c5dbe1df762263e2f497e8c8fd0a10f64d1d004"}, "downloads": -1, "filename": "mecm-0.1.0.tar.gz", "has_sig": false, "md5_digest": "a827fddcc33fb969957610a2b07d21a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37784, "upload_time": "2018-04-09T00:03:42", "upload_time_iso_8601": "2018-04-09T00:03:42.680399Z", "url": "https://files.pythonhosted.org/packages/a5/0f/f36f13001ef3d4d16dda8c95cff563538e53016922ea5d98502fee077c1c/mecm-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:39 2020"}