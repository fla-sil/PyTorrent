{"info": {"author": "Reuben Rusk", "author_email": "pythoro@mindquip.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# fastwire\n\nFastwire is a simple package to facilitate communication between objects. It\nprovides similar functionality to several other packages, such as:\n \n* blinker\n* wires\n* wired\n* observable\n* pyDispatcher\n* pymitter\n* py-notify\n* zope-event\n\nFastwire is intended to be elegant to use, fast to implement, and more\nflexible, while maintianing high performance.\n\n## Basic usage\n\nCreate a signal container:\n\n\n```python\n\nimport fastwire as fw\n\nsc = fw.SignalContainer()\n```\n\nThen create a signal...\n\n```python\nsignal = sc.signal('your_name')\n```\n\nWe can connect to that signal like this:\n\n```python\nclass A():\n    def __init__(self):\n    signal.connect(self.connected)\n\n    def connected(self, a):\n        print('Class A instance received a: ' + str(a))\n\na = B()\nsignal.connect(a.connected)\t\nsignal.emit(a=5.7)\n# Class A instance received a 5.7\n```\n\nAnd we can connect other signals if we want to:\n\n```python\nsignal_b = sc.signal('new_sig')\nsignal_b.connect(a.connected)\nsignal_b.emit(a=3)\n# Class A instance received a 5.7\n```\n\nConnecting also works with functions. We can connect a function to the same\nsignal.\n\n```python\ndef test_fun(a):\n    print('test_fun got a ' + str(a))\n    \nsignal.connect(test_fun)\nsignal.emit(a=5.7)\n# Class A instance received a 5.7\n# test_fun got a 5.7\n```\n\nOnly keyword arguments are accepted to ensure the required type of data is \npassed.\n\n\nThe emit method doesn't return anything. But the signal.fetch method does. It\nrequires there to be a single function or method that 'supplies' the return\nvalue. The signal.fetch_all method returns a list of return values from\nall receivers.\n\n## Signal properties\n\n### signal.n\nNumber of recievers.\n\n### signal.receivers_present\nTrue if receivers are present.\n\n### name\nThe name of the signal.\n\n## Decorators\n\nIt can be convenient to use decorators to automatically connect. Do do this,\nthe class needs to inherit fw.Wired.\n\n```python\nsignal_c = sc.signal('C')\n\nclass B(fw.Wired):\n\t@fw.receives(signal_c)\n\tdef connected(self, a):\n\t\tprint('Class B instance got ' + str(a))\n\nb = B()\nsignal_c.emit(a=7)\n# Class B instance got 7\n```\n\nFunctions need to use a different decorator.\n\n```python\n@fw.fn_receives(signal_c)\ndef test_fun_2(a):\n    print('test_fun_2 got ' + str(a))\nsignal_c.emit(a=88)\n# Class B instance got 88\n# test_fun_2 got 88\n```\n\nUse the @fastwire.supply decorator for methods that supply data,\nand the @fastwire.fn_supply decorator for functions that supply data.\n\n\n## Conditions\n\nConditions can be added. They need to have a method called 'check', which is\npassed combined keyword arguments from the caller and receiver. It needs to\nreturn a boolean. If it's true, the given receiver gets the signal, if not,\nit doesn't. They also need a class attribute called 'name'.\n\nAdd a signal condition like this:\n\n```python\n\nclass My_Condition():\n    name = 'default'\n    def check(self, a, **kwargs):\n        ''' The main check call - must return a boolean '''\n        if a < 10:\n            return True\n        else:\n            return False\n            \nsignal.add_condition(My_Condition())\n```\n\nNow, receivers only get the signal when a is less than 10:\n\n```python\nsignal.emit(a=5.7)\n# Class A instance received a 5.7\n# test_fun got a 5.7\n\nsignal.emit(a=15)\n# Nothing happens\n```\n\nTo remove:\n\n```python\nsignal.remove_condition(My_Condition.name)\nsignal.emit(a=15)\n# Class A instance received a 15\n# test_fun got a 15\n```\n\nCondition classes are completely open - they can be as simple as the above\nexample or as complex as a state machine.\n\n## Muting\n\nNo receivers get a muted signal. You can mute and unmute a signal easily...\n\n```python\nsignal.mute()\nsignal.emit(a=3)\n# Nothing mappens\n\nsignal.unmute()\nsignal.emit(a=3)\n# Class A instance received a 3\n# test_fun got a 3\n```\n\n## Documentation\n\nDocumentation is hosted at ReadTheDocs.org.\n\nhttps://fastwire.readthedocs.io/en/latest/", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/pythoro/fastwire/archive/v0.1.6.zip", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pythoro/fastwire.git", "keywords": "WIRE,CONNECTION,UTILITY", "license": "", "maintainer": "", "maintainer_email": "", "name": "fastwire", "package_url": "https://pypi.org/project/fastwire/", "platform": "", "project_url": "https://pypi.org/project/fastwire/", "project_urls": {"Download": "https://github.com/pythoro/fastwire/archive/v0.1.6.zip", "Homepage": "https://github.com/pythoro/fastwire.git"}, "release_url": "https://pypi.org/project/fastwire/0.1.6/", "requires_dist": null, "requires_python": "", "summary": "Easy data transfer between classes.", "version": "0.1.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>fastwire</h1>\n<p>Fastwire is a simple package to facilitate communication between objects. It\nprovides similar functionality to several other packages, such as:</p>\n<ul>\n<li>blinker</li>\n<li>wires</li>\n<li>wired</li>\n<li>observable</li>\n<li>pyDispatcher</li>\n<li>pymitter</li>\n<li>py-notify</li>\n<li>zope-event</li>\n</ul>\n<p>Fastwire is intended to be elegant to use, fast to implement, and more\nflexible, while maintianing high performance.</p>\n<h2>Basic usage</h2>\n<p>Create a signal container:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">fastwire</span> <span class=\"k\">as</span> <span class=\"nn\">fw</span>\n\n<span class=\"n\">sc</span> <span class=\"o\">=</span> <span class=\"n\">fw</span><span class=\"o\">.</span><span class=\"n\">SignalContainer</span><span class=\"p\">()</span>\n</pre>\n<p>Then create a signal...</p>\n<pre><span class=\"n\">signal</span> <span class=\"o\">=</span> <span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">signal</span><span class=\"p\">(</span><span class=\"s1\">'your_name'</span><span class=\"p\">)</span>\n</pre>\n<p>We can connect to that signal like this:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">A</span><span class=\"p\">():</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n    <span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">connected</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">connected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Class A instance received a: '</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">()</span>\n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">connected</span><span class=\"p\">)</span>\t\n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">5.7</span><span class=\"p\">)</span>\n<span class=\"c1\"># Class A instance received a 5.7</span>\n</pre>\n<p>And we can connect other signals if we want to:</p>\n<pre><span class=\"n\">signal_b</span> <span class=\"o\">=</span> <span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">signal</span><span class=\"p\">(</span><span class=\"s1\">'new_sig'</span><span class=\"p\">)</span>\n<span class=\"n\">signal_b</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">connected</span><span class=\"p\">)</span>\n<span class=\"n\">signal_b</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"c1\"># Class A instance received a 5.7</span>\n</pre>\n<p>Connecting also works with functions. We can connect a function to the same\nsignal.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_fun</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'test_fun got a '</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span>\n    \n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">test_fun</span><span class=\"p\">)</span>\n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">5.7</span><span class=\"p\">)</span>\n<span class=\"c1\"># Class A instance received a 5.7</span>\n<span class=\"c1\"># test_fun got a 5.7</span>\n</pre>\n<p>Only keyword arguments are accepted to ensure the required type of data is\npassed.</p>\n<p>The emit method doesn't return anything. But the signal.fetch method does. It\nrequires there to be a single function or method that 'supplies' the return\nvalue. The signal.fetch_all method returns a list of return values from\nall receivers.</p>\n<h2>Signal properties</h2>\n<h3>signal.n</h3>\n<p>Number of recievers.</p>\n<h3>signal.receivers_present</h3>\n<p>True if receivers are present.</p>\n<h3>name</h3>\n<p>The name of the signal.</p>\n<h2>Decorators</h2>\n<p>It can be convenient to use decorators to automatically connect. Do do this,\nthe class needs to inherit fw.Wired.</p>\n<pre><span class=\"n\">signal_c</span> <span class=\"o\">=</span> <span class=\"n\">sc</span><span class=\"o\">.</span><span class=\"n\">signal</span><span class=\"p\">(</span><span class=\"s1\">'C'</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">B</span><span class=\"p\">(</span><span class=\"n\">fw</span><span class=\"o\">.</span><span class=\"n\">Wired</span><span class=\"p\">):</span>\n\t<span class=\"nd\">@fw</span><span class=\"o\">.</span><span class=\"n\">receives</span><span class=\"p\">(</span><span class=\"n\">signal_c</span><span class=\"p\">)</span>\n\t<span class=\"k\">def</span> <span class=\"nf\">connected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">):</span>\n\t\t<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Class B instance got '</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span>\n\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">()</span>\n<span class=\"n\">signal_c</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"c1\"># Class B instance got 7</span>\n</pre>\n<p>Functions need to use a different decorator.</p>\n<pre><span class=\"nd\">@fw</span><span class=\"o\">.</span><span class=\"n\">fn_receives</span><span class=\"p\">(</span><span class=\"n\">signal_c</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">test_fun_2</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'test_fun_2 got '</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span>\n<span class=\"n\">signal_c</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">88</span><span class=\"p\">)</span>\n<span class=\"c1\"># Class B instance got 88</span>\n<span class=\"c1\"># test_fun_2 got 88</span>\n</pre>\n<p>Use the @fastwire.supply decorator for methods that supply data,\nand the @fastwire.fn_supply decorator for functions that supply data.</p>\n<h2>Conditions</h2>\n<p>Conditions can be added. They need to have a method called 'check', which is\npassed combined keyword arguments from the caller and receiver. It needs to\nreturn a boolean. If it's true, the given receiver gets the signal, if not,\nit doesn't. They also need a class attribute called 'name'.</p>\n<p>Add a signal condition like this:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">My_Condition</span><span class=\"p\">():</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'default'</span>\n    <span class=\"k\">def</span> <span class=\"nf\">check</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"sd\">''' The main check call - must return a boolean '''</span>\n        <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"o\">&lt;</span> <span class=\"mi\">10</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"kc\">True</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"kc\">False</span>\n            \n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">add_condition</span><span class=\"p\">(</span><span class=\"n\">My_Condition</span><span class=\"p\">())</span>\n</pre>\n<p>Now, receivers only get the signal when a is less than 10:</p>\n<pre><span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mf\">5.7</span><span class=\"p\">)</span>\n<span class=\"c1\"># Class A instance received a 5.7</span>\n<span class=\"c1\"># test_fun got a 5.7</span>\n\n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">15</span><span class=\"p\">)</span>\n<span class=\"c1\"># Nothing happens</span>\n</pre>\n<p>To remove:</p>\n<pre><span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">remove_condition</span><span class=\"p\">(</span><span class=\"n\">My_Condition</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">)</span>\n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">15</span><span class=\"p\">)</span>\n<span class=\"c1\"># Class A instance received a 15</span>\n<span class=\"c1\"># test_fun got a 15</span>\n</pre>\n<p>Condition classes are completely open - they can be as simple as the above\nexample or as complex as a state machine.</p>\n<h2>Muting</h2>\n<p>No receivers get a muted signal. You can mute and unmute a signal easily...</p>\n<pre><span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">mute</span><span class=\"p\">()</span>\n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"c1\"># Nothing mappens</span>\n\n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">unmute</span><span class=\"p\">()</span>\n<span class=\"n\">signal</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"c1\"># Class A instance received a 3</span>\n<span class=\"c1\"># test_fun got a 3</span>\n</pre>\n<h2>Documentation</h2>\n<p>Documentation is hosted at ReadTheDocs.org.</p>\n<p><a href=\"https://fastwire.readthedocs.io/en/latest/\" rel=\"nofollow\">https://fastwire.readthedocs.io/en/latest/</a></p>\n\n          </div>"}, "last_serial": 6399848, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "b3e4a572fc1c209299b67fd7ec478f7e", "sha256": "380092ecc45ce29036ea4313b93e65f35e09c8e1b2fe1275470908ebcfbfa9eb"}, "downloads": -1, "filename": "fastwire-0.1.1.tar.gz", "has_sig": false, "md5_digest": "b3e4a572fc1c209299b67fd7ec478f7e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3814, "upload_time": "2019-07-22T01:09:12", "upload_time_iso_8601": "2019-07-22T01:09:12.771992Z", "url": "https://files.pythonhosted.org/packages/4d/ad/246c7352f11a558d5dc9e255425367db7fbc67fa9edf9c535ac629e8c438/fastwire-0.1.1.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "b88ba632fbd97b467bb10a4d7401165f", "sha256": "7f209e904b0cd019caf461c12cc580b6f8cb2f6a530f0a975b10d91022ae72ec"}, "downloads": -1, "filename": "fastwire-0.1.3.tar.gz", "has_sig": false, "md5_digest": "b88ba632fbd97b467bb10a4d7401165f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5663, "upload_time": "2019-07-24T02:55:31", "upload_time_iso_8601": "2019-07-24T02:55:31.966334Z", "url": "https://files.pythonhosted.org/packages/a6/49/acf1d3ade4bca7ebfeecc885bb75fd93bbfb2a593759ca29b400299d3989/fastwire-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "10eb31b3a6488d4d1f13c2e98c683e33", "sha256": "838a8a6b58af0eacf6d3ed9bd3faab7047ce2214bb2ae88c2a60fc6bfa0f0dad"}, "downloads": -1, "filename": "fastwire-0.1.4.tar.gz", "has_sig": false, "md5_digest": "10eb31b3a6488d4d1f13c2e98c683e33", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11899, "upload_time": "2019-09-02T06:26:48", "upload_time_iso_8601": "2019-09-02T06:26:48.425159Z", "url": "https://files.pythonhosted.org/packages/c4/88/9fe9169b1468354303e4dc3f18a561846863dac01354a7b589c0291fd0c5/fastwire-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "c47f8e93065582efc6fef3efefe3205a", "sha256": "456720b413ba36a9583685361b9104c3a39cb51026d2fae697337ccf7b1c62c1"}, "downloads": -1, "filename": "fastwire-0.1.5.tar.gz", "has_sig": false, "md5_digest": "c47f8e93065582efc6fef3efefe3205a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11888, "upload_time": "2019-09-10T21:39:59", "upload_time_iso_8601": "2019-09-10T21:39:59.277843Z", "url": "https://files.pythonhosted.org/packages/aa/1b/9686b4e1b5c37d8bf162aa87d56b48ed56eb312c0df197b13fe0f76ab330/fastwire-0.1.5.tar.gz", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "79a5837cbf20d6cf294341c7ceb4f6f5", "sha256": "fa41b1c383a540842185be208633f1d0cc449650a1bcaa324d801b84223d860f"}, "downloads": -1, "filename": "fastwire-0.1.6.tar.gz", "has_sig": false, "md5_digest": "79a5837cbf20d6cf294341c7ceb4f6f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12464, "upload_time": "2020-01-05T23:20:55", "upload_time_iso_8601": "2020-01-05T23:20:55.142219Z", "url": "https://files.pythonhosted.org/packages/f7/68/c09878ea41cdd88a5fefba62bb9a7a60617d8260e13eedad6d718a4c4b27/fastwire-0.1.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "79a5837cbf20d6cf294341c7ceb4f6f5", "sha256": "fa41b1c383a540842185be208633f1d0cc449650a1bcaa324d801b84223d860f"}, "downloads": -1, "filename": "fastwire-0.1.6.tar.gz", "has_sig": false, "md5_digest": "79a5837cbf20d6cf294341c7ceb4f6f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12464, "upload_time": "2020-01-05T23:20:55", "upload_time_iso_8601": "2020-01-05T23:20:55.142219Z", "url": "https://files.pythonhosted.org/packages/f7/68/c09878ea41cdd88a5fefba62bb9a7a60617d8260e13eedad6d718a4c4b27/fastwire-0.1.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:43:22 2020"}