{"info": {"author": "Agendaless Consulting", "author_email": "pylons-discuss@googlegroups.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Programming Language :: Python", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy"], "description": "Colander\n========\n\nAn extensible package which can be used to:\n\n- deserialize and validate a data structure composed of strings,\n  mappings, and lists.\n\n- serialize an arbitrary data structure to a data structure composed\n  of strings, mappings, and lists.\n\nIt runs on Python 2.6, 2.7, 3.2, and 3.3.\n\nPlease see http://docs.pylonsproject.org/projects/colander/en/latest/\nfor further documentation.\n\nSee https://github.com/Pylons/colander for in-development version.\n\n\nUnreleased\n----------\n\nBug Fixes\n~~~~~~~~~\n\n- Removed forked iso8601 and change to dependency on pypi iso8601\n  (due to float rounding bug on microsecond portion when parsing\n  iso8601 datetime string).  Left an iso8601.py stub for backwards\n  compatibility.\n\n- Time of \"00:00\" no longer gives ``colander.Invalid``.\n\n- Un-break wrapping of callable instances as ``colander.deferred``.\n  See https://github.com/Pylons/colander/issues/141.\n\n- Set the max length TLD to 22 in ``Email`` validator based on the\n  current list of valid TLDs.\n  See https://github.com/Pylons/colander/issues/159\n\n- Fix an issue where ``drop`` was not recognized as a default and was\n  returning the ``drop`` instance instead of omitting the value.\n  https://github.com/Pylons/colander/issues/139\n\n- Fix an issue where the ``SchemaNode.title`` was clobbered by the ``name``\n  when defined as a class attribute.\n  See https://github.com/Pylons/colander/pull/183 and\n  https://github.com/Pylons/colander/pull/185\n\nFeatures\n~~~~~~~~\n\n- Add `Any` validator which succeeds if at least one of its subvalidators\n  succeeded.\n\n- Allow localization of error messages returned by ``colander.Invalid.asdict``\n  by adding an optional ``translate`` callable argument.\n\n1.0b1 (2013-09-01)\n------------------\n\nBug Fixes\n~~~~~~~~~\n\n- In 1.0a1, there was a change merged from\n  https://github.com/Pylons/colander/pull/73 which made it possible to supply\n  ``None`` as the ``default`` value for a String type, and upon serialization,\n  the value would be rendered as ``colander.null`` if the default were used.\n  This confused people who were actually supplying the value ``None`` as a\n  default when the associated appstruct had no value, so the change has been\n  reverted.  When you supply ``None`` as the ``default`` argument to a String,\n  the rendered serialize() value will again be ``'None'``.  Sorry.\n\n- Normalize ``colander.Function`` argument ``message`` to be ``msg``. This now\n  matches other APIs within Colander. The ``message`` argument is now\n  deprecated and a warning will be emitted.\n  https://github.com/Pylons/colander/issues/31\n  https://github.com/Pylons/colander/issues/64\n\n- ``iso8601.py``:  Convert ``ValueError`` (raised by ``datetime``) into\n  ``ParseErrorr`` in ``parse_date``, so that the validation machinery\n  upstream handles it properly.\n\n- ``iso8601.py``:  Correctly parse datetimes with a timezone of Z even\n  when the default_timezone is set. These previously had the default\n  timezone.\n\n- ``colander.String`` schema type now raises ``colander.Invalid`` when trying\n  to deserialize a non-string item.\n  See https://github.com/Pylons/colander/issues/100\n\nFeatures\n~~~~~~~~\n\n- Add ``colander.List`` type, modeled on ``deform.List``:  this type\n  preserves ordering, and allows duplicates.\n\n- It is now possible to use the value ``colander.drop`` as the ``default``\n  value for items that are subitems of a mapping.  If ``colander.drop`` is used\n  as the ``default`` for a subnode of a mapping schema, and the mapping\n  appstruct being serialized does not have a value for that schema node, the\n  value will be omitted from the serialized mapping.  For instance, the\n  following script, when run would not raise an assertion error::\n\n      class What(colander.MappingSchema):\n        thing = colander.SchemaNode(colander.String(), default=colander.drop)\n\n      result = What().serialize({}) # no \"thing\" in mapping\n      assert result == {}\n\n- The ``typ`` of a ``SchemaNode`` can optionally be pased in as a keyword\n  argument. See https://github.com/Pylons/colander/issues/90\n\n- Add a ``missing_msg`` argument to ``SchemaNode`` that specifies the error\n  message to be used when the node is required and missing\n\n1.0a5 (2013-05-31)\n------------------\n\n- Fix bug introduced by supporting spec-mandated truncations of ISO-8601\n  timezones.  A TypeError would be raised instead of Invalid.  See\n  https://github.com/Pylons/colander/issues/111.\n\n1.0a4 (2013-05-21)\n------------------\n\n- Loosen Email validator regex (permit apostrophes, bang, etc in localpart).\n\n- Allow for timezone info objects to be pickled and unpickled \"more correctly\"\n  (Use '__getinitargs__' to provide unpickling-only defaults).  See\n  https://github.com/Pylons/colander/pull/108.\n\n1.0a3 (2013-05-16)\n------------------\n\nFeatures\n~~~~~~~~\n\n- Support spec-mandated truncations of ISO-8601 timezones.\n\n- Support spec-mandated truncations of ISO-8601 datetimes.\n\n- Allow specifying custom representations of values for boolean fields.\n\nBug Fixes\n~~~~~~~~~\n\n- Ensure that ``colander.iso8601.FixedOffset`` instances can be unpickled.\n\n- Avoid validating strings as sequences under Py3k.\n\n- Sync documentation with 0.9.9 change to use ``insert_before`` rather than\n  ``schema_order``.  See https://github.com/Pylons/colander/issues/104\n\n\n1.0a2 (2013-01-30)\n------------------\n\nFeatures\n~~~~~~~~\n\n- Add ``colander.ContainsOnly`` and ``colander.url`` validators.\n\n- Add ``colander.instantiate`` to help define schemas containing\n  mappings and sequences more succinctly.\n\n1.0a1 (2013-01-10)\n------------------\n\nBug Fixes\n~~~~~~~~~\n\n- Work around a regression in Python 3.3 for ``colander.Decimal`` when it's\n  used with a ``quant`` argument but without a ``rounding`` argument.\n  See https://github.com/Pylons/colander/issues/66\n\n- Using ``SchemaNode(String, default='', ..)`` now works properly, or at least\n  more intuitively.  Previously if an empty-string ``default`` was supplied,\n  serialization would return a defaulted value as ``colander.null``.  See\n  https://github.com/Pylons/colander/pull/73.\n\n- Stricter checking in colander.Mapping to prevent items which are logically\n  not mappings from being accepted during validation (see\n  https://github.com/Pylons/colander/pull/96).\n\nFeatures\n~~~~~~~~\n\n- Add ``colander.Set`` type, ported from ``deform.Set``\n\n- Add Python 3.3 to tox configuration and use newer tox testing regime\n  (setup.py dev).\n\n- Add Python 3.3 Trove classifier.\n\n- Calling ``bind`` on a schema node e.g. ``cloned_node = somenode.bind(a=1,\n  b=2)`` on a schema node now results in the cloned node having a\n  ``bindings`` attribute of the value ``{'a':1, 'b':2}``.\n\n- It is no longer necessary to pass a ``typ`` argument to a SchemaNode\n  constructor if the node class has a ``schema_type`` callable as a class\n  attribute which, when called with no arguments, returns a schema type.\n  This callable will be called to obtain the schema type if a ``typ`` is not\n  supplied to the constructor.  The default ``SchemaNode`` object's\n  ``schema_type`` callable raises a ``NotImplementedError`` when it is\n  called.\n\n- SchemaNode now has a ``raise_invalid`` method which accepts a message and\n  raises a colander.Invalid exception using ``self`` as the node and the\n  message as its message.\n\n- It is now possible and advisable to subclass ``SchemaNode`` in order to\n  create a bundle of default node behavior.  The subclass can define the\n  following methods and attributes: ``preparer``, ``validator``, ``default``,\n  ``missing``, ``name``, ``title``, ``description``, ``widget``, and\n  ``after_bind``.\n\n  For example, the older, more imperative style that looked like this still\n  works, of course::\n\n     from colander import SchemaNode\n\n     ranged_int = colander.SchemaNode(\n         validator=colander.Range(0, 10),\n         default = 10,\n         title='Ranged Int'\n         )\n\n  But you can alternately now do something like this::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         validator = colander.Range(0, 10)\n         default = 10\n         title = 'Ranged Int'\n\n     ranged_int = RangedInt()\n\n  Values that are expected to be callables can now alternately be methods of\n  the schemanode subclass instead of plain attributes::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n\n         def validator(self, node, cstruct):\n            if not 0 < cstruct < 10:\n                raise colander.Invalid(node, 'Must be between 0 and 10')\n\n     ranged_int = RangedInt()\n\n  Note that when implementing a method value such as ``validator`` that\n  expects to receive a ``node`` argument, ``node`` must be provided in the\n  call signature, even though ``node`` will almost always be the same as\n  ``self``.  This is because Colander simply treats the method as another\n  kind of callable, be it a method, or a function, or an instance that has a\n  ``__call__`` method.  It doesn't care that it happens to be a method of\n  ``self``, and it needs to support callables that are not methods, so it\n  sends ``node`` in regardless.\n\n  You can't currently use *method* definitions as ``colander.deferred``\n  callables.  For example this will *not* work::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n\n         @colander.deferred\n         def validator(self, node, kw):\n            request = kw['request']\n            def avalidator(node, cstruct):\n                if not 0 < cstruct < 10:\n                    if request.user != 'admin':\n                        raise colander.Invalid(node, 'Must be between 0 and 10')\n            return avalidator\n\n     ranged_int = RangedInt()\n     bound_ranged_int = ranged_int.bind(request=request)\n\n  This will result in::\n\n        TypeError: avalidator() takes exactly 3 arguments (2 given)\n\n  However, if you treat the thing being decorated as a function instead of a\n  method (remove the ``self`` argument from the argument list), it will\n  indeed work)::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n\n         @colander.deferred\n         def validator(node, kw):\n            request = kw['request']\n            def avalidator(node, cstruct):\n                if not 0 < cstruct < 10:\n                    if request.user != 'admin':\n                        raise colander.Invalid(node, 'Must be between 0 and 10')\n            return avalidator\n\n     ranged_int = RangedInt()\n     bound_ranged_int = ranged_int.bind(request=request)\n\n  In previous releases of Colander, the only way to defer the computation of\n  values was via the ``colander.deferred`` decorator.  In this release,\n  however, you can instead use the ``bindings`` attribute of ``self`` to\n  obtain access to the bind parameters within values that are plain old\n  methods::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n\n         def validator(self, node, cstruct):\n            request = self.bindings['request']\n            if not 0 < cstruct < 10:\n                if request.user != 'admin':\n                    raise colander.Invalid(node, 'Must be between 0 and 10')\n\n     ranged_int = RangedInt()\n     bound_range_int = ranged_int.bind(request=request)\n\n  If the things you're trying to defer aren't callables like ``validator``,\n  but they're instead just plain attributes like ``missing`` or ``default``,\n  instead of using a ``colander.deferred``, you can use ``after_bind`` to set\n  attributes of the schemanode that rely on binding variables::\n\n     from colander import SchemaNode\n\n     class UserIdSchemaNode(SchemaNode):\n         title = 'User Id'\n\n         def after_bind(self, node, kw):\n             self.default = kw['request'].user.id\n\n  You can override the default values of a schemanode subclass in its\n  constructor::\n\n     from colander import SchemaNode\n\n     class RangedIntSchemaNode(SchemaNode):\n         default = 10\n         title = 'Ranged Int'\n         validator = colander.Range(0, 10)\n\n     ranged_int = RangedInt(validator=colander.Range(0, 20))\n\n  In the above example, the validation will be done on 0-20, not 0-10.\n\n  If a schema node name conflicts with a schema value attribute name on the\n  same class, you can work around it by giving the schema node a bogus name\n  in the class definition but providing a correct ``name`` argument to the\n  schema node constructor::\n\n     from colander import SchemaNode, Schema\n\n     class SomeSchema(Schema):\n         title = 'Some Schema'\n         thisnamewillbeignored = colander.SchemaNode(\n                                             colander.String(),\n                                             name='title'\n                                             )\n\n  Note that such a workaround is only required if the conflicting names are\n  attached to the *exact same* class definition.  Colander scrapes off schema\n  node definitions at each class' construction time, so it's not an issue for\n  inherited values.  For example::\n\n     from colander import SchemaNode, Schema\n\n     class SomeSchema(Schema):\n         title = colander.SchemaNode(colander.String())\n\n     class AnotherSchema(SomeSchema):\n         title = 'Some Schema'\n\n     schema = AnotherSchema()\n\n  In the above example, even though the ``title = 'Some Schema'`` appears to\n  override the superclass' ``title`` SchemaNode, a ``title`` SchemaNode will\n  indeed be present in the child list of the ``schema`` instance\n  (``schema['title']`` will return the ``title`` SchemaNode) and the schema's\n  ``title`` attribute will be ``Some Schema`` (``schema.title`` will return\n  ``Some Schema``).\n\n  Normal inheritance rules apply to class attributes and methods defined in\n  a schemanode subclass.  If your schemanode subclass inherits from another\n  schemanode class, your schemanode subclass' methods and class attributes\n  will override the superclass' methods and class attributes.\n\n  Ordering of child schema nodes when inheritance is used works like this:\n  the \"deepest\" SchemaNode class in the MRO of the inheritance chain is\n  consulted first for nodes, then the next deepest, then the next, and so on.\n  So the deepest class' nodes come first in the relative ordering of schema\n  nodes, then the next deepest, and so on.  For example::\n\n      class One(colander.Schema):\n          a = colander.SchemaNode(\n              colander.String(),\n              id='a1',\n              )\n          b = colander.SchemaNode(\n              colander.String(),\n              id='b1',\n              )\n          d = colander.SchemaNode(\n              colander.String(),\n              id='d1',\n              )\n\n      class Two(One):\n          a = colander.SchemaNode(\n              colander.String(),\n              id='a2',\n              )\n          c = colander.SchemaNode(\n              colander.String(), \n              id='c2',\n              )\n          e = colander.SchemaNode(\n              colander.String(),\n              id='e2',\n              )\n\n      class Three(Two):\n          b = colander.SchemaNode(\n              colander.String(),\n              id='b3',\n              )\n          d = colander.SchemaNode(\n              colander.String(),\n              id='d3',\n              )\n          f = colander.SchemaNode(\n              colander.String(),\n              id='f3',\n              )\n\n      three = Three()\n\n  The ordering of child nodes computed in the schema node ``three`` will be\n  ``['a2', 'b3', 'd3', 'c2', 'e2', 'f3']``.  The ordering starts ``a1``,\n  ``b1``, ``d1`` because that's the ordering of nodes in ``One``, and\n  ``One`` is the deepest SchemaNode in the inheritance hierarchy.  Then it\n  processes the nodes attached to ``Two``, the next deepest, which causes\n  ``a1`` to be replaced by ``a2``, and ``c2`` and ``e2`` to be appended to\n  the node list.  Then finally it processes the nodes attached to ``Three``,\n  which causes ``b1`` to be replaced by ``b3``, and ``d1`` to be replaced by\n  ``d3``, then finally ``f`` is appended.\n\n  Multiple inheritance works the same way::\n\n      class One(colander.Schema):\n          a = colander.SchemaNode(\n              colander.String(),\n              id='a1',\n              )\n          b = colander.SchemaNode(\n              colander.String(),\n              id='b1',\n              )\n          d = colander.SchemaNode(\n              colander.String(),\n              id='d1',\n              )\n\n      class Two(colander.Schema):\n          a = colander.SchemaNode(\n              colander.String(),\n              id='a2',\n              )\n          c = colander.SchemaNode(\n              colander.String(), \n              id='c2',\n              )\n          e = colander.SchemaNode(\n              colander.String(),\n              id='e2',\n              )\n\n      class Three(Two, One):\n          b = colander.SchemaNode(\n              colander.String(),\n              id='b3',\n              )\n          d = colander.SchemaNode(\n              colander.String(),\n              id='d3',\n              )\n          f = colander.SchemaNode(\n              colander.String(),\n              id='f3',\n              )\n\n      three = Three()\n\n  The resulting node ordering of ``three`` is the same as the single\n  inheritance example: ``['a2', 'b3', 'd3', 'c2', 'e2', 'f3']`` due to the\n  MRO deepest-first ordering (``One``, then ``Two``, then ``Three``).\n\nBackwards Incompatibilities\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- Passing non-SchemaNode derivative instances as ``*children`` into a\n  SchemaNode constructor is no longer supported.  Symptom: ``AttributeError:\n  name`` when constructing a SchemaNode.\n\n0.9.9 (2012-09-24)\n------------------\n\nFeatures\n~~~~~~~~\n\n- Allow the use of ``missing=None`` for Number.  See\n  https://github.com/Pylons/colander/pull/59 .\n\n- Create a ``colander.Money`` type that is a Decimal type with\n  two-decimal-point precision rounded-up.\n\n- Allow ``quant`` and ``rounding`` args to ``colander.Decimal`` constructor.\n\n- ``luhnok`` validator added (credit card luhn mod10 validator).\n\n- Add an ``insert`` method to SchemaNode objects.\n\n- Add an ``insert_before`` method to SchemaNode objects.\n\n- Better class-based mapping schema inheritance model.\n\n  * A node declared in a subclass of a mapping schema superclass now\n    overrides any node with the same name inherited from any superclass.\n    Previously, it just repeated and didn't override.\n\n  * An ``insert_before`` keyword argument may be passed to a SchemaNode\n    constructor.  This is a string naming a node in a superclass.  A node\n    with an ``insert_before`` will be placed before the named node in a\n    parent mapping schema.\n\n- The ``preparer=`` argument to SchemaNodes may now be a sequence of\n  preparers.\n\n- Added a ``cstruct_children`` method to SchemaNode.\n\n- A new ``cstruct_children`` API should exist on schema types.  If\n  ``SchemaNode.cstruct_children`` is called on a node with a type that does\n  not have a ``cstruct_children`` method, a deprecation warning is emitted\n  and ``[]`` is returned (this may or may not be the correct value for your\n  custom type).\n\nBackwards Incompatibilities\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- The inheritance changes required a minor backwards incompatibility: calling\n  ``__setitem__`` on a SchemaNode will no longer raise ``KeyError`` when\n  attempting to set a subnode into a node that doesn't already have an\n  existing subnode by that name.  Instead, the subnode will be appended to\n  the child list.\n\nDocumentation\n~~~~~~~~~~~~~\n\n- A \"Schema Inheritance\" section was added to the Basics chapter\n  documentation.\n\n0.9.8 (2012-04-27)\n------------------\n\n- False evaluating values are now serialized to colander.null for\n  String, Date, and Time.  This resolves the issue where a None value\n  would be rendered as 'None' for String, and missing='None' was not\n  possible for Date, Datetime, and Time.\n  See https://github.com/Pylons/colander/pull/1 .\n\n- Updated Brazilian Portugese translations.\n\n- Updated Japanese translations.\n\n- Updated Russian translations.\n\n- Fix documentation: 0.9.3 allowed explicitly passing None to DateTime\n  to have no default timezone applied.\n\n- Add ``dev`` and ``docs`` setup.py aliases (e.g. ``python setup.py dev``).\n\n0.9.7 (2012-03-20)\n------------------\n\n- Using ``schema.flatten(...)`` against a mapping schema node without a name\n  produced incorrectly dot-prefixed keys.  See\n  https://github.com/Pylons/colander/issues/37\n\n- Fix invalid.asdict for multiple error messages.  See\n  https://github.com/Pylons/colander/pull/22 ,\n  https://github.com/Pylons/colander/pull/27 ,\n  https://github.com/Pylons/colander/pull/12 , and\n  https://github.com/Pylons/colander/issues/2 .\n\n- Invalid.messages() now returns an empty list if there are no messages.\n  See https://github.com/Pylons/colander/pull/21 .\n\n- ``name`` passed to a SchemaNode constructor was not respected in\n  declaratively constructed schemas.  Now if you pass ``name`` to the\n  SchemaNode constructor within the body of a schema class, it will take\n  precedence over the name it's been assigned to in the schema class.\n  See https://github.com/Pylons/colander/issues/39 .\n\n- Japanese translation thanks to OCHIAI, Gouji.\n\n- Replaced incorrect ``%{err}`` with correct ``${err}`` in String.deserialize\n  error message.  See https://github.com/Pylons/colander/pull/41\n\n0.9.6 (2012-02-14)\n------------------\n\n- No longer runs on Python 2.4 or 2.5.  Python 2.6+ is now required.\n\n- Python 3.2 compatibility.\n\n- Removed a dependency on the iso8601 package (code from the package is now\n  inlined in Colander itself).\n\n- Added copyright and licensing information for iso8601-derived code to\n  LICENSE.txt.\n\n0.9.5 (2012-01-13)\n------------------\n\n- Added Czech translation.\n\n- Compile pt_BR translation (it was previously uncompiled).\n\n- Minor docs fixes.\n\n- Documentation added about flatten and unflatten.\n\n0.9.4 (2011-10-14)\n------------------\n\n- ``flatten`` now only includes leaf nodes in the flattened dict.\n\n- ``flatten`` does not include a path element for the name of the type node\n  for sequences.\n\n- ``unflatten`` is implemented.\n\n- Added ``__setitem__`` to ``SchemaNode``, allowing replacement of nodes by\n  name.\n\n- Added ``get_value`` and ``set_value`` methods to ``Schema`` which allow\n  access and mutation of appstructs using dotted name paths.\n\n- Add Swedish, French, Chinese translations.\n\n0.9.3 (2011-06-23)\n------------------\n\n- Add ``Time`` type.\n\n- Add Dutch translation.\n\n- Fix documentation: 0.9.2 requires ``deserialize`` of types to explicitly\n  deal with the potential to receive ``colander.null``.\n\n- Use ``default_tzinfo`` when deserializing naive datetimes.  See\n  https://github.com/Pylons/colander/issues#issue/5.\n\n- Allow ``default_tzinfo`` to be ``None`` when creating a\n  ``colander.DateTime``.  See\n  https://github.com/Pylons/colander/issues#issue/6.\n\n- Add the ability to insert a ``colander.interfaces.Preparer`` between\n  deserialization and validation. See the Preparing section in the\n  documentation.\n\n0.9.2 (2011-03-28)\n------------------\n\n- Added Polish translation, thanks to Jedrzej Nowak.\n\n- Moved to Pylons Project GitHub (https://github.com/Pylons/colander).\n\n- Add tox.ini for testing purposes.\n\n- New API: ``colander.required``.  Used as the marker value when a\n  ``missing`` argument is left unspecified.\n\n- Bug fix: if a ``title`` argument which is the empty string or ``None`` is\n  passed explicitly to a SchemaNode, it is no longer replaced by a title\n  computed from the name.\n\n- Add SchemaNode.__contains__ to support \"name in schema\".\n\n- SchemaNode deserialization now unconditionally calls the schema type's\n  ``deserialize`` method to obtain an appstruct before attempting to\n  validate.  Third party schema types should now return ``colander.null`` if\n  passed a ``colander.null`` value or another logically \"empty\" value as a\n  cstruct during ``deserialize``.\n\n0.9.1 (2010-12-02)\n------------------\n\n- When ``colander.null`` was unpickled, the reference created during\n  unpickling was *not* a reference to the singleton but rather a new instance\n  of the ``colander._null`` class.  This was unintentional, because lots of\n  code checks for ``if x is colander.null``, which will fail across pickling\n  and unpickling.  Now the reference created when ``colander.null`` is\n  pickled is unpickled as the singleton itself.\n\n0.9  (2010-11-28)\n-----------------\n\n- SchemaNode constructor now accepts arbitrary keyword arguments.  It\n  sets any unknown values within the ``**kw`` sequence as attributes\n  of the node object.\n\n- Added Spanish locale:  thanks to Douglas Cerna for the translations!\n\n- If you use a schema with deferred ``validator``, ``missing`` or\n  ``default`` attributes, but you use it to perform serialization and\n  deserialization without calling its ``bind`` method:\n\n  - If ``validator`` is deferred, no validation will be performed.\n\n  - If ``missing`` is deferred, the field will be considered *required*.\n\n  - If ``default`` is deferred, the serialization default will be\n    assumed to be ``colander.null``.\n\n- Undocumented internal API for all type objects: ``flatten``.\n  External type objects should now inherit from\n  ``colander.SchemaType`` to get a default implementation.\n\n0.8  (2010/09/08)\n-----------------\n\n- Docstring fixes to ``colander.SchemaNode`` (``missing`` is not the\n  ``null`` value when required, it's a special marker value).\n\n- The concept of \"schema binding\" was added, which allows for a more\n  declarative-looking spelling of schemas and schema nodes which have\n  dependencies on values available after the schema has already been\n  fully constructed.  See the new narrative chapter in the\n  documentation entitled \"Schema Binding\".\n\n- The interface of ``colander.SchemaNode`` has grown a ``__delitem__``\n  method.  The ``__iter__``, and ``__getitem__`` methods have now also\n  been properly documented.\n\n0.7.3 (2010/09/02)\n------------------\n\n- The title of a schema node now defaults to a titleization of the\n  ``name``.  Underscores in the ``name`` are replaced with empty\n  strings and the first letter of every resulting word is capitalized.\n  Previously the ``name`` was not split on underscores, and the\n  entirety of the ``name`` was capitalized.\n\n- A method of the ``colander.Invalid`` exception named ``messages``\n  was added.  It returns an iterable of error messages using the\n  ``msg`` attribute of its related exception node.  If the ``msg``\n  attribute is iterable, it is returned.  If it is not iterable, a\n  single-element list containing the ``msg`` value is returned.\n\n0.7.2 (2010/08/30)\n------------------\n\n- Add an ``colander.SchemaNode.__iter__`` method, which iterates over\n  the children nodes of a schema node.\n\n- The constructor of a ``colander.SchemaNode`` now accepts a\n  ``widget`` keyword argument, for use by Deform (it is not used\n  internally).\n\n0.7.1 (2010/06/12)\n------------------\n\n- Make it possible to use ``colander.null`` as a ``missing`` argument\n  to ``colander.SchemaNode`` for roundtripping purposes.\n\n- Make it possible to pickle ``colander.null``.\n\n0.7.0\n-----\n\nA release centered around normalizing the treatment of default and\nmissing values.\n\nBug Fixes\n~~~~~~~~~\n\n- Allow ``colander.Regex`` validator to accept a pattern object\n  instead of just a string.\n\n- Get rid of circular reference in Invalid exceptions: Invalid\n  exceptions now no longer have a ``parent`` attribute.  Instead, they\n  have a ``positional`` attribute, which signifies that the parent\n  node type of the schema node to which they relate inherits from\n  Positional.  This attribute isn't an API; it's used only internally\n  for reporting.\n\n- Raise a ``TypeError`` when bogus keyword arguments are passed to\n  ``colander.SchemaNode``.\n\nBackwards Incompatiblities / New Features\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- ``missing`` constructor arg to SchemaNode: signifies\n  *deserialization* default, disambiguated from ``default`` which acted\n  as both serialization and deserialization default previously.\n\n  Changes necessitated / made possible by SchemaNode ``missing``\n  addition:\n\n  - The ``allow_empty`` argument of the ``colander.String`` type was\n    removed (use ``missing=''`` as a wrapper SchemaNode argument\n    instead).\n\n- New concept: ``colander.null`` input to serialization and\n  deserialization.  Use of ``colander.null`` normalizes serialization\n  and deserialization default handling.\n\n  Changes necessitated / made possible by ``colander.null`` addition:\n\n  - ``partial`` argument and attribute of colander.MappingSchema has\n     been removed; all serializations are partial, and partial\n     deserializations are not necessary.\n\n  - ``colander.null`` values are added to the cstruct for partial\n     serializations instead of omitting missing node values from\n     the cstruct.\n\n  - ``colander.null`` may now be present in serialized and\n     deserialized data structures.\n\n  - ``sdefault`` attribute of SchemaNode has been removed; we never need\n    to serialize a default anymore.\n\n  - The value ``colander.null`` will be passed as ``appstruct`` to\n    each type's ``serialize`` method when a mapping appstruct doesn't\n    have a corresponding key instead of ``None``, as was the practice\n    previously.\n\n  - The value ``colander.null`` will be passed as ``cstruct`` to\n    each type's ``deserialize`` method when a mapping cstruct\n    doesn't have a corresponding key instead of ``None``, as was the\n    practice previously.\n\n  - Types now must handle ``colander.null`` explicitly during\n    serialization.\n\n- Updated and expanded documentation, particularly with respect to new\n  ``colander.null`` handling.\n\n- The ``value`` argument`` to the ``serialize`` method of a SchemaNode\n  is now named ``appstruct``.  It is no longer a required argument; it\n  defaults to ``colander.null`` now.\n\n  The ``value`` argument to the ``deserialize`` method of a SchemaNode\n  is now named ``cstruct``.  It is no longer a required argument; it\n  defaults to ``colander.null`` now.\n\n- The ``value`` argument to the ``serialize`` method of each built-in\n  type is now named ``appstruct``, and is now required: it is no\n  longer a keyword argument that has a default.\n\n  The ``value`` argument to the ``deserialize`` method of each\n  built-in type is now named ``cstruct``, and is now required: it is\n  no longer a keyword argument that has a default.\n\n0.6.2 (2010-05-08)\n------------------\n\n- The default ``encoding`` parameter value to the ``colander.String``\n  type is still ``None``, however its meaning has changed.  An\n  encoding of ``None`` now means that no special encoding and decoding\n  of Unicode values is done by the String type.  This differs from the\n  previous behavior, where ``None`` implied that the encoding was\n  ``utf-8``.  Pass the encoding as ``utf-8`` specifically to get the\n  older behavior back.  This is in support of Deform.\n\n- The default ``err_template`` value attached to the ``colander.Date``\n  and ``colander.Datetime`` types was changed.  It is now simply\n  ``Invalid date`` instead of ``_('${val} cannot be parsed as an\n  iso8601 date: ${err}')``.  This is in support of Deform.\n\n- Fix bug in ``colander.Boolean`` that attempted to call ``.lower`` on\n  a bool value when a default value was found for the schema node.\n\n0.6.1 (2010-05-04)\n------------------\n\n- Add a Decimal type (number type which uses ``decimal.Decimal`` as a\n  deserialization target).\n\n0.6.0 (2010-05-02)\n------------------\n\n- (Hopefully) fix intermittent datetime-granularity-related test\n  failures.\n\n- Internationalized error messages.  This required some changes to\n  error message formatting, which may impact you if you were feeding\n  colander an error message template.\n\n- New project dependency: ``translationstring`` package for\n  internationalization.\n\n- New argument to ``colander.String`` constructor: ``allow_empty``.\n  This is a boolean representing whether an empty string is a valid\n  value during deserialization, defaulting to ``False``.\n\n- Add minimal documentation about the composition of a\n  colander.Invalid exception to the narrative docs.\n\n- Add (existing, but previously non-API) colander.Invalid attributes\n  to its interface within the API documentation.\n\n0.5.2 (2010-04-09)\n------------------\n\n- Add Email and Regex validators (courtesy Steve Howe).\n\n- Raise a ``colander.Invalid`` error if a ``colander.SequenceSchema``\n  is created with more than one member.\n\n- Add ``Function`` validator.\n\n- Fix bug in serialization of non-Unicode values in the ``String`` class.\n\n- Get rid of ``pserialize`` in favor of making ``serialize`` always\n  partially serialize.\n\n- Get rid of ``pdeserialize``: it existed only for symmetry.  We'll\n  add something like it back later if we need it.\n\n0.5.1 (2010-04-02)\n------------------\n\n- The constructor arguments to a the ``colander.Schema`` class are now\n  sent to the constructed SchemaNode rather than to the type it represents.\n\n- Allow ``colander.Date`` and ``colander.DateTime`` invalid error\n  messages to be customized.\n\n- Add a ``pos`` argument to the ``colander.Invalid.add`` method.\n\n- Add a ``__setitem__`` method to the ``colander.Invalid`` class.\n\n- The ``colander.Mapping`` constructor keyword argument\n  ``unknown_keys`` has been renamed to ``unknown``.\n\n- Allow ``colander.Mapping`` type to accept a new constructor\n  argument: ``partial``.\n\n- New interface methods required by types and schema nodes:\n  ``pserialize`` and ``pdeserialize``.  These partially serialize or\n  partially deserialize a value (the definition of \"partial\" is up to\n  the type).\n\n0.5 (2010-03-31)\n----------------\n\n- 0.4 was mispackaged (CHANGES.txt missing); no code changes from 0.4\n  however.\n\n0.4 (2010-03-30)\n----------------\n\n- Add ``colander.DateTime`` and ``colander.Date`` data types.\n\n- Depend on the ``iso8601`` package for date support.\n\n0.3 (2010-03-29)\n----------------\n\n- Subnodes of a schema node are now kept in the ``children`` attribute\n  rather than the ``nodes`` attribute.\n\n- Add an ``sdefault`` property to ``colander.SchemaNode`` objects.\n\n- Add a ``clone`` method to ``colander.SchemaNode`` objects.\n\n- Add a ``__str__`` method to the ``colander.Invalid`` exception that\n  prints an error summary.\n\n- Various error message improvements.\n\n- Add ``colander.Length`` validator class.\n\n0.2 (2010-03-23)\n----------------\n\n- Make nodetype overrideable.\n\n- Add __getitem__ to SchemaNode.\n\n- Fix OneOf message.\n\n- Capitalize node titles.\n\n- Deal with empty strings in String, Boolean, and Float types.\n\n- Introduce description; make title the same as name.\n\n- Remove copy method from schemanode.\n\n- Allow schema nodes to have titles.\n\n- The term \"structure\" is too overloaded to use for schema purposes:\n  structure -> schema node.\n\n- Make Sequence more like Tuple and Mapping (it uses a substructure\n  rather than a structure parameter to denote its type).\n\n- Add __repr__ and copy methods to structure.\n\n- Add accept_scalar flag to Sequence.\n\n\n0.1 (2010-03-14)\n----------------\n\n- Initial release.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://docs.pylonsproject.org/projects/colander/en/latest/", "keywords": "serialize deserialize validate schema validation", "license": "BSD-derived (http://www.repoze.org/LICENSE.txt)", "maintainer": null, "maintainer_email": null, "name": "ba-colander", "package_url": "https://pypi.org/project/ba-colander/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/ba-colander/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://docs.pylonsproject.org/projects/colander/en/latest/"}, "release_url": "https://pypi.org/project/ba-colander/1.0b1/", "requires_dist": null, "requires_python": null, "summary": "A simple schema-based serialization and deserialization library", "version": "1.0b1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>An extensible package which can be used to:</p>\n<ul>\n<li>deserialize and validate a data structure composed of strings,\nmappings, and lists.</li>\n<li>serialize an arbitrary data structure to a data structure composed\nof strings, mappings, and lists.</li>\n</ul>\n<p>It runs on Python 2.6, 2.7, 3.2, and 3.3.</p>\n<p>Please see <a href=\"http://docs.pylonsproject.org/projects/colander/en/latest/\" rel=\"nofollow\">http://docs.pylonsproject.org/projects/colander/en/latest/</a>\nfor further documentation.</p>\n<p>See <a href=\"https://github.com/Pylons/colander\" rel=\"nofollow\">https://github.com/Pylons/colander</a> for in-development version.</p>\n<div id=\"unreleased\">\n<h2>Unreleased</h2>\n<div id=\"bug-fixes\">\n<h3>Bug Fixes</h3>\n<ul>\n<li>Removed forked iso8601 and change to dependency on pypi iso8601\n(due to float rounding bug on microsecond portion when parsing\niso8601 datetime string).  Left an iso8601.py stub for backwards\ncompatibility.</li>\n<li>Time of \u201c00:00\u201d no longer gives <tt>colander.Invalid</tt>.</li>\n<li>Un-break wrapping of callable instances as <tt>colander.deferred</tt>.\nSee <a href=\"https://github.com/Pylons/colander/issues/141\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/141</a>.</li>\n<li>Set the max length TLD to 22 in <tt>Email</tt> validator based on the\ncurrent list of valid TLDs.\nSee <a href=\"https://github.com/Pylons/colander/issues/159\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/159</a></li>\n<li>Fix an issue where <tt>drop</tt> was not recognized as a default and was\nreturning the <tt>drop</tt> instance instead of omitting the value.\n<a href=\"https://github.com/Pylons/colander/issues/139\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/139</a></li>\n<li>Fix an issue where the <tt>SchemaNode.title</tt> was clobbered by the <tt>name</tt>\nwhen defined as a class attribute.\nSee <a href=\"https://github.com/Pylons/colander/pull/183\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/183</a> and\n<a href=\"https://github.com/Pylons/colander/pull/185\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/185</a></li>\n</ul>\n</div>\n<div id=\"features\">\n<h3>Features</h3>\n<ul>\n<li>Add <cite>Any</cite> validator which succeeds if at least one of its subvalidators\nsucceeded.</li>\n<li>Allow localization of error messages returned by <tt>colander.Invalid.asdict</tt>\nby adding an optional <tt>translate</tt> callable argument.</li>\n</ul>\n</div>\n</div>\n<div id=\"b1-2013-09-01\">\n<h2>1.0b1 (2013-09-01)</h2>\n<div id=\"id1\">\n<h3>Bug Fixes</h3>\n<ul>\n<li>In 1.0a1, there was a change merged from\n<a href=\"https://github.com/Pylons/colander/pull/73\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/73</a> which made it possible to supply\n<tt>None</tt> as the <tt>default</tt> value for a String type, and upon serialization,\nthe value would be rendered as <tt>colander.null</tt> if the default were used.\nThis confused people who were actually supplying the value <tt>None</tt> as a\ndefault when the associated appstruct had no value, so the change has been\nreverted.  When you supply <tt>None</tt> as the <tt>default</tt> argument to a String,\nthe rendered serialize() value will again be <tt>'None'</tt>.  Sorry.</li>\n<li>Normalize <tt>colander.Function</tt> argument <tt>message</tt> to be <tt>msg</tt>. This now\nmatches other APIs within Colander. The <tt>message</tt> argument is now\ndeprecated and a warning will be emitted.\n<a href=\"https://github.com/Pylons/colander/issues/31\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/31</a>\n<a href=\"https://github.com/Pylons/colander/issues/64\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/64</a></li>\n<li><tt>iso8601.py</tt>:  Convert <tt>ValueError</tt> (raised by <tt>datetime</tt>) into\n<tt>ParseErrorr</tt> in <tt>parse_date</tt>, so that the validation machinery\nupstream handles it properly.</li>\n<li><tt>iso8601.py</tt>:  Correctly parse datetimes with a timezone of Z even\nwhen the default_timezone is set. These previously had the default\ntimezone.</li>\n<li><tt>colander.String</tt> schema type now raises <tt>colander.Invalid</tt> when trying\nto deserialize a non-string item.\nSee <a href=\"https://github.com/Pylons/colander/issues/100\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/100</a></li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>Features</h3>\n<ul>\n<li><p>Add <tt>colander.List</tt> type, modeled on <tt>deform.List</tt>:  this type\npreserves ordering, and allows duplicates.</p>\n</li>\n<li><p>It is now possible to use the value <tt>colander.drop</tt> as the <tt>default</tt>\nvalue for items that are subitems of a mapping.  If <tt>colander.drop</tt> is used\nas the <tt>default</tt> for a subnode of a mapping schema, and the mapping\nappstruct being serialized does not have a value for that schema node, the\nvalue will be omitted from the serialized mapping.  For instance, the\nfollowing script, when run would not raise an assertion error:</p>\n<pre>class What(colander.MappingSchema):\n  thing = colander.SchemaNode(colander.String(), default=colander.drop)\n\nresult = What().serialize({}) # no \"thing\" in mapping\nassert result == {}\n</pre>\n</li>\n<li><p>The <tt>typ</tt> of a <tt>SchemaNode</tt> can optionally be pased in as a keyword\nargument. See <a href=\"https://github.com/Pylons/colander/issues/90\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/90</a></p>\n</li>\n<li><p>Add a <tt>missing_msg</tt> argument to <tt>SchemaNode</tt> that specifies the error\nmessage to be used when the node is required and missing</p>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"a5-2013-05-31\">\n<h2>1.0a5 (2013-05-31)</h2>\n<ul>\n<li>Fix bug introduced by supporting spec-mandated truncations of ISO-8601\ntimezones.  A TypeError would be raised instead of Invalid.  See\n<a href=\"https://github.com/Pylons/colander/issues/111\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/111</a>.</li>\n</ul>\n</div>\n<div id=\"a4-2013-05-21\">\n<h2>1.0a4 (2013-05-21)</h2>\n<ul>\n<li>Loosen Email validator regex (permit apostrophes, bang, etc in localpart).</li>\n<li>Allow for timezone info objects to be pickled and unpickled \u201cmore correctly\u201d\n(Use \u2018__getinitargs__\u2019 to provide unpickling-only defaults).  See\n<a href=\"https://github.com/Pylons/colander/pull/108\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/108</a>.</li>\n</ul>\n</div>\n<div id=\"a3-2013-05-16\">\n<h2>1.0a3 (2013-05-16)</h2>\n<div id=\"id3\">\n<h3>Features</h3>\n<ul>\n<li>Support spec-mandated truncations of ISO-8601 timezones.</li>\n<li>Support spec-mandated truncations of ISO-8601 datetimes.</li>\n<li>Allow specifying custom representations of values for boolean fields.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>Bug Fixes</h3>\n<ul>\n<li>Ensure that <tt>colander.iso8601.FixedOffset</tt> instances can be unpickled.</li>\n<li>Avoid validating strings as sequences under Py3k.</li>\n<li>Sync documentation with 0.9.9 change to use <tt>insert_before</tt> rather than\n<tt>schema_order</tt>.  See <a href=\"https://github.com/Pylons/colander/issues/104\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/104</a></li>\n</ul>\n</div>\n</div>\n<div id=\"a2-2013-01-30\">\n<h2>1.0a2 (2013-01-30)</h2>\n<h2 id=\"id5\"><span class=\"section-subtitle\">Features</span></h2>\n<ul>\n<li>Add <tt>colander.ContainsOnly</tt> and <tt>colander.url</tt> validators.</li>\n<li>Add <tt>colander.instantiate</tt> to help define schemas containing\nmappings and sequences more succinctly.</li>\n</ul>\n</div>\n<div id=\"a1-2013-01-10\">\n<h2>1.0a1 (2013-01-10)</h2>\n<div id=\"id6\">\n<h3>Bug Fixes</h3>\n<ul>\n<li>Work around a regression in Python 3.3 for <tt>colander.Decimal</tt> when it\u2019s\nused with a <tt>quant</tt> argument but without a <tt>rounding</tt> argument.\nSee <a href=\"https://github.com/Pylons/colander/issues/66\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/66</a></li>\n<li>Using <tt>SchemaNode(String, <span class=\"pre\">default='',</span> ..)</tt> now works properly, or at least\nmore intuitively.  Previously if an empty-string <tt>default</tt> was supplied,\nserialization would return a defaulted value as <tt>colander.null</tt>.  See\n<a href=\"https://github.com/Pylons/colander/pull/73\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/73</a>.</li>\n<li>Stricter checking in colander.Mapping to prevent items which are logically\nnot mappings from being accepted during validation (see\n<a href=\"https://github.com/Pylons/colander/pull/96\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/96</a>).</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>Features</h3>\n<ul>\n<li><p>Add <tt>colander.Set</tt> type, ported from <tt>deform.Set</tt></p>\n</li>\n<li><p>Add Python 3.3 to tox configuration and use newer tox testing regime\n(setup.py dev).</p>\n</li>\n<li><p>Add Python 3.3 Trove classifier.</p>\n</li>\n<li><p>Calling <tt>bind</tt> on a schema node e.g. <tt>cloned_node = somenode.bind(a=1,\nb=2)</tt> on a schema node now results in the cloned node having a\n<tt>bindings</tt> attribute of the value <tt><span class=\"pre\">{'a':1,</span> <span class=\"pre\">'b':2}</span></tt>.</p>\n</li>\n<li><p>It is no longer necessary to pass a <tt>typ</tt> argument to a SchemaNode\nconstructor if the node class has a <tt>schema_type</tt> callable as a class\nattribute which, when called with no arguments, returns a schema type.\nThis callable will be called to obtain the schema type if a <tt>typ</tt> is not\nsupplied to the constructor.  The default <tt>SchemaNode</tt> object\u2019s\n<tt>schema_type</tt> callable raises a <tt>NotImplementedError</tt> when it is\ncalled.</p>\n</li>\n<li><p>SchemaNode now has a <tt>raise_invalid</tt> method which accepts a message and\nraises a colander.Invalid exception using <tt>self</tt> as the node and the\nmessage as its message.</p>\n</li>\n<li><p>It is now possible and advisable to subclass <tt>SchemaNode</tt> in order to\ncreate a bundle of default node behavior.  The subclass can define the\nfollowing methods and attributes: <tt>preparer</tt>, <tt>validator</tt>, <tt>default</tt>,\n<tt>missing</tt>, <tt>name</tt>, <tt>title</tt>, <tt>description</tt>, <tt>widget</tt>, and\n<tt>after_bind</tt>.</p>\n<p>For example, the older, more imperative style that looked like this still\nworks, of course:</p>\n<pre>from colander import SchemaNode\n\nranged_int = colander.SchemaNode(\n    validator=colander.Range(0, 10),\n    default = 10,\n    title='Ranged Int'\n    )\n</pre>\n<p>But you can alternately now do something like this:</p>\n<pre>from colander import SchemaNode\n\nclass RangedIntSchemaNode(SchemaNode):\n    validator = colander.Range(0, 10)\n    default = 10\n    title = 'Ranged Int'\n\nranged_int = RangedInt()\n</pre>\n<p>Values that are expected to be callables can now alternately be methods of\nthe schemanode subclass instead of plain attributes:</p>\n<pre>from colander import SchemaNode\n\nclass RangedIntSchemaNode(SchemaNode):\n    default = 10\n    title = 'Ranged Int'\n\n    def validator(self, node, cstruct):\n       if not 0 &lt; cstruct &lt; 10:\n           raise colander.Invalid(node, 'Must be between 0 and 10')\n\nranged_int = RangedInt()\n</pre>\n<p>Note that when implementing a method value such as <tt>validator</tt> that\nexpects to receive a <tt>node</tt> argument, <tt>node</tt> must be provided in the\ncall signature, even though <tt>node</tt> will almost always be the same as\n<tt>self</tt>.  This is because Colander simply treats the method as another\nkind of callable, be it a method, or a function, or an instance that has a\n<tt>__call__</tt> method.  It doesn\u2019t care that it happens to be a method of\n<tt>self</tt>, and it needs to support callables that are not methods, so it\nsends <tt>node</tt> in regardless.</p>\n<p>You can\u2019t currently use <em>method</em> definitions as <tt>colander.deferred</tt>\ncallables.  For example this will <em>not</em> work:</p>\n<pre>from colander import SchemaNode\n\nclass RangedIntSchemaNode(SchemaNode):\n    default = 10\n    title = 'Ranged Int'\n\n    @colander.deferred\n    def validator(self, node, kw):\n       request = kw['request']\n       def avalidator(node, cstruct):\n           if not 0 &lt; cstruct &lt; 10:\n               if request.user != 'admin':\n                   raise colander.Invalid(node, 'Must be between 0 and 10')\n       return avalidator\n\nranged_int = RangedInt()\nbound_ranged_int = ranged_int.bind(request=request)\n</pre>\n<p>This will result in:</p>\n<pre>TypeError: avalidator() takes exactly 3 arguments (2 given)\n</pre>\n<p>However, if you treat the thing being decorated as a function instead of a\nmethod (remove the <tt>self</tt> argument from the argument list), it will\nindeed work):</p>\n<pre>from colander import SchemaNode\n\nclass RangedIntSchemaNode(SchemaNode):\n    default = 10\n    title = 'Ranged Int'\n\n    @colander.deferred\n    def validator(node, kw):\n       request = kw['request']\n       def avalidator(node, cstruct):\n           if not 0 &lt; cstruct &lt; 10:\n               if request.user != 'admin':\n                   raise colander.Invalid(node, 'Must be between 0 and 10')\n       return avalidator\n\nranged_int = RangedInt()\nbound_ranged_int = ranged_int.bind(request=request)\n</pre>\n<p>In previous releases of Colander, the only way to defer the computation of\nvalues was via the <tt>colander.deferred</tt> decorator.  In this release,\nhowever, you can instead use the <tt>bindings</tt> attribute of <tt>self</tt> to\nobtain access to the bind parameters within values that are plain old\nmethods:</p>\n<pre>from colander import SchemaNode\n\nclass RangedIntSchemaNode(SchemaNode):\n    default = 10\n    title = 'Ranged Int'\n\n    def validator(self, node, cstruct):\n       request = self.bindings['request']\n       if not 0 &lt; cstruct &lt; 10:\n           if request.user != 'admin':\n               raise colander.Invalid(node, 'Must be between 0 and 10')\n\nranged_int = RangedInt()\nbound_range_int = ranged_int.bind(request=request)\n</pre>\n<p>If the things you\u2019re trying to defer aren\u2019t callables like <tt>validator</tt>,\nbut they\u2019re instead just plain attributes like <tt>missing</tt> or <tt>default</tt>,\ninstead of using a <tt>colander.deferred</tt>, you can use <tt>after_bind</tt> to set\nattributes of the schemanode that rely on binding variables:</p>\n<pre>from colander import SchemaNode\n\nclass UserIdSchemaNode(SchemaNode):\n    title = 'User Id'\n\n    def after_bind(self, node, kw):\n        self.default = kw['request'].user.id\n</pre>\n<p>You can override the default values of a schemanode subclass in its\nconstructor:</p>\n<pre>from colander import SchemaNode\n\nclass RangedIntSchemaNode(SchemaNode):\n    default = 10\n    title = 'Ranged Int'\n    validator = colander.Range(0, 10)\n\nranged_int = RangedInt(validator=colander.Range(0, 20))\n</pre>\n<p>In the above example, the validation will be done on 0-20, not 0-10.</p>\n<p>If a schema node name conflicts with a schema value attribute name on the\nsame class, you can work around it by giving the schema node a bogus name\nin the class definition but providing a correct <tt>name</tt> argument to the\nschema node constructor:</p>\n<pre>from colander import SchemaNode, Schema\n\nclass SomeSchema(Schema):\n    title = 'Some Schema'\n    thisnamewillbeignored = colander.SchemaNode(\n                                        colander.String(),\n                                        name='title'\n                                        )\n</pre>\n<p>Note that such a workaround is only required if the conflicting names are\nattached to the <em>exact same</em> class definition.  Colander scrapes off schema\nnode definitions at each class\u2019 construction time, so it\u2019s not an issue for\ninherited values.  For example:</p>\n<pre>from colander import SchemaNode, Schema\n\nclass SomeSchema(Schema):\n    title = colander.SchemaNode(colander.String())\n\nclass AnotherSchema(SomeSchema):\n    title = 'Some Schema'\n\nschema = AnotherSchema()\n</pre>\n<p>In the above example, even though the <tt>title = 'Some Schema'</tt> appears to\noverride the superclass\u2019 <tt>title</tt> SchemaNode, a <tt>title</tt> SchemaNode will\nindeed be present in the child list of the <tt>schema</tt> instance\n(<tt><span class=\"pre\">schema['title']</span></tt> will return the <tt>title</tt> SchemaNode) and the schema\u2019s\n<tt>title</tt> attribute will be <tt>Some Schema</tt> (<tt>schema.title</tt> will return\n<tt>Some Schema</tt>).</p>\n<p>Normal inheritance rules apply to class attributes and methods defined in\na schemanode subclass.  If your schemanode subclass inherits from another\nschemanode class, your schemanode subclass\u2019 methods and class attributes\nwill override the superclass\u2019 methods and class attributes.</p>\n<p>Ordering of child schema nodes when inheritance is used works like this:\nthe \u201cdeepest\u201d SchemaNode class in the MRO of the inheritance chain is\nconsulted first for nodes, then the next deepest, then the next, and so on.\nSo the deepest class\u2019 nodes come first in the relative ordering of schema\nnodes, then the next deepest, and so on.  For example:</p>\n<pre>class One(colander.Schema):\n    a = colander.SchemaNode(\n        colander.String(),\n        id='a1',\n        )\n    b = colander.SchemaNode(\n        colander.String(),\n        id='b1',\n        )\n    d = colander.SchemaNode(\n        colander.String(),\n        id='d1',\n        )\n\nclass Two(One):\n    a = colander.SchemaNode(\n        colander.String(),\n        id='a2',\n        )\n    c = colander.SchemaNode(\n        colander.String(),\n        id='c2',\n        )\n    e = colander.SchemaNode(\n        colander.String(),\n        id='e2',\n        )\n\nclass Three(Two):\n    b = colander.SchemaNode(\n        colander.String(),\n        id='b3',\n        )\n    d = colander.SchemaNode(\n        colander.String(),\n        id='d3',\n        )\n    f = colander.SchemaNode(\n        colander.String(),\n        id='f3',\n        )\n\nthree = Three()\n</pre>\n<p>The ordering of child nodes computed in the schema node <tt>three</tt> will be\n<tt>['a2', 'b3', 'd3', 'c2', 'e2', 'f3']</tt>.  The ordering starts <tt>a1</tt>,\n<tt>b1</tt>, <tt>d1</tt> because that\u2019s the ordering of nodes in <tt>One</tt>, and\n<tt>One</tt> is the deepest SchemaNode in the inheritance hierarchy.  Then it\nprocesses the nodes attached to <tt>Two</tt>, the next deepest, which causes\n<tt>a1</tt> to be replaced by <tt>a2</tt>, and <tt>c2</tt> and <tt>e2</tt> to be appended to\nthe node list.  Then finally it processes the nodes attached to <tt>Three</tt>,\nwhich causes <tt>b1</tt> to be replaced by <tt>b3</tt>, and <tt>d1</tt> to be replaced by\n<tt>d3</tt>, then finally <tt>f</tt> is appended.</p>\n<p>Multiple inheritance works the same way:</p>\n<pre>class One(colander.Schema):\n    a = colander.SchemaNode(\n        colander.String(),\n        id='a1',\n        )\n    b = colander.SchemaNode(\n        colander.String(),\n        id='b1',\n        )\n    d = colander.SchemaNode(\n        colander.String(),\n        id='d1',\n        )\n\nclass Two(colander.Schema):\n    a = colander.SchemaNode(\n        colander.String(),\n        id='a2',\n        )\n    c = colander.SchemaNode(\n        colander.String(),\n        id='c2',\n        )\n    e = colander.SchemaNode(\n        colander.String(),\n        id='e2',\n        )\n\nclass Three(Two, One):\n    b = colander.SchemaNode(\n        colander.String(),\n        id='b3',\n        )\n    d = colander.SchemaNode(\n        colander.String(),\n        id='d3',\n        )\n    f = colander.SchemaNode(\n        colander.String(),\n        id='f3',\n        )\n\nthree = Three()\n</pre>\n<p>The resulting node ordering of <tt>three</tt> is the same as the single\ninheritance example: <tt>['a2', 'b3', 'd3', 'c2', 'e2', 'f3']</tt> due to the\nMRO deepest-first ordering (<tt>One</tt>, then <tt>Two</tt>, then <tt>Three</tt>).</p>\n</li>\n</ul>\n</div>\n<div id=\"backwards-incompatibilities\">\n<h3>Backwards Incompatibilities</h3>\n<ul>\n<li>Passing non-SchemaNode derivative instances as <tt>*children</tt> into a\nSchemaNode constructor is no longer supported.  Symptom: <tt>AttributeError:\nname</tt> when constructing a SchemaNode.</li>\n</ul>\n</div>\n</div>\n<div id=\"id8\">\n<h2>0.9.9 (2012-09-24)</h2>\n<div id=\"id9\">\n<h3>Features</h3>\n<ul>\n<li>Allow the use of <tt>missing=None</tt> for Number.  See\n<a href=\"https://github.com/Pylons/colander/pull/59\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/59</a> .</li>\n<li>Create a <tt>colander.Money</tt> type that is a Decimal type with\ntwo-decimal-point precision rounded-up.</li>\n<li>Allow <tt>quant</tt> and <tt>rounding</tt> args to <tt>colander.Decimal</tt> constructor.</li>\n<li><tt>luhnok</tt> validator added (credit card luhn mod10 validator).</li>\n<li>Add an <tt>insert</tt> method to SchemaNode objects.</li>\n<li>Add an <tt>insert_before</tt> method to SchemaNode objects.</li>\n<li>Better class-based mapping schema inheritance model.<ul>\n<li>A node declared in a subclass of a mapping schema superclass now\noverrides any node with the same name inherited from any superclass.\nPreviously, it just repeated and didn\u2019t override.</li>\n<li>An <tt>insert_before</tt> keyword argument may be passed to a SchemaNode\nconstructor.  This is a string naming a node in a superclass.  A node\nwith an <tt>insert_before</tt> will be placed before the named node in a\nparent mapping schema.</li>\n</ul>\n</li>\n<li>The <tt>preparer=</tt> argument to SchemaNodes may now be a sequence of\npreparers.</li>\n<li>Added a <tt>cstruct_children</tt> method to SchemaNode.</li>\n<li>A new <tt>cstruct_children</tt> API should exist on schema types.  If\n<tt>SchemaNode.cstruct_children</tt> is called on a node with a type that does\nnot have a <tt>cstruct_children</tt> method, a deprecation warning is emitted\nand <tt>[]</tt> is returned (this may or may not be the correct value for your\ncustom type).</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3>Backwards Incompatibilities</h3>\n<ul>\n<li>The inheritance changes required a minor backwards incompatibility: calling\n<tt>__setitem__</tt> on a SchemaNode will no longer raise <tt>KeyError</tt> when\nattempting to set a subnode into a node that doesn\u2019t already have an\nexisting subnode by that name.  Instead, the subnode will be appended to\nthe child list.</li>\n</ul>\n</div>\n<div id=\"documentation\">\n<h3>Documentation</h3>\n<ul>\n<li>A \u201cSchema Inheritance\u201d section was added to the Basics chapter\ndocumentation.</li>\n</ul>\n</div>\n</div>\n<div id=\"id11\">\n<h2>0.9.8 (2012-04-27)</h2>\n<ul>\n<li>False evaluating values are now serialized to colander.null for\nString, Date, and Time.  This resolves the issue where a None value\nwould be rendered as \u2018None\u2019 for String, and missing=\u2019None\u2019 was not\npossible for Date, Datetime, and Time.\nSee <a href=\"https://github.com/Pylons/colander/pull/1\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/1</a> .</li>\n<li>Updated Brazilian Portugese translations.</li>\n<li>Updated Japanese translations.</li>\n<li>Updated Russian translations.</li>\n<li>Fix documentation: 0.9.3 allowed explicitly passing None to DateTime\nto have no default timezone applied.</li>\n<li>Add <tt>dev</tt> and <tt>docs</tt> setup.py aliases (e.g. <tt>python setup.py dev</tt>).</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h2>0.9.7 (2012-03-20)</h2>\n<ul>\n<li>Using <tt><span class=\"pre\">schema.flatten(...)</span></tt> against a mapping schema node without a name\nproduced incorrectly dot-prefixed keys.  See\n<a href=\"https://github.com/Pylons/colander/issues/37\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/37</a></li>\n<li>Fix invalid.asdict for multiple error messages.  See\n<a href=\"https://github.com/Pylons/colander/pull/22\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/22</a> ,\n<a href=\"https://github.com/Pylons/colander/pull/27\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/27</a> ,\n<a href=\"https://github.com/Pylons/colander/pull/12\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/12</a> , and\n<a href=\"https://github.com/Pylons/colander/issues/2\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/2</a> .</li>\n<li>Invalid.messages() now returns an empty list if there are no messages.\nSee <a href=\"https://github.com/Pylons/colander/pull/21\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/21</a> .</li>\n<li><tt>name</tt> passed to a SchemaNode constructor was not respected in\ndeclaratively constructed schemas.  Now if you pass <tt>name</tt> to the\nSchemaNode constructor within the body of a schema class, it will take\nprecedence over the name it\u2019s been assigned to in the schema class.\nSee <a href=\"https://github.com/Pylons/colander/issues/39\" rel=\"nofollow\">https://github.com/Pylons/colander/issues/39</a> .</li>\n<li>Japanese translation thanks to OCHIAI, Gouji.</li>\n<li>Replaced incorrect <tt>%{err}</tt> with correct <tt>${err}</tt> in String.deserialize\nerror message.  See <a href=\"https://github.com/Pylons/colander/pull/41\" rel=\"nofollow\">https://github.com/Pylons/colander/pull/41</a></li>\n</ul>\n</div>\n<div id=\"id13\">\n<h2>0.9.6 (2012-02-14)</h2>\n<ul>\n<li>No longer runs on Python 2.4 or 2.5.  Python 2.6+ is now required.</li>\n<li>Python 3.2 compatibility.</li>\n<li>Removed a dependency on the iso8601 package (code from the package is now\ninlined in Colander itself).</li>\n<li>Added copyright and licensing information for iso8601-derived code to\nLICENSE.txt.</li>\n</ul>\n</div>\n<div id=\"id14\">\n<h2>0.9.5 (2012-01-13)</h2>\n<ul>\n<li>Added Czech translation.</li>\n<li>Compile pt_BR translation (it was previously uncompiled).</li>\n<li>Minor docs fixes.</li>\n<li>Documentation added about flatten and unflatten.</li>\n</ul>\n</div>\n<div id=\"id15\">\n<h2>0.9.4 (2011-10-14)</h2>\n<ul>\n<li><tt>flatten</tt> now only includes leaf nodes in the flattened dict.</li>\n<li><tt>flatten</tt> does not include a path element for the name of the type node\nfor sequences.</li>\n<li><tt>unflatten</tt> is implemented.</li>\n<li>Added <tt>__setitem__</tt> to <tt>SchemaNode</tt>, allowing replacement of nodes by\nname.</li>\n<li>Added <tt>get_value</tt> and <tt>set_value</tt> methods to <tt>Schema</tt> which allow\naccess and mutation of appstructs using dotted name paths.</li>\n<li>Add Swedish, French, Chinese translations.</li>\n</ul>\n</div>\n<div id=\"id16\">\n<h2>0.9.3 (2011-06-23)</h2>\n<ul>\n<li>Add <tt>Time</tt> type.</li>\n<li>Add Dutch translation.</li>\n<li>Fix documentation: 0.9.2 requires <tt>deserialize</tt> of types to explicitly\ndeal with the potential to receive <tt>colander.null</tt>.</li>\n<li>Use <tt>default_tzinfo</tt> when deserializing naive datetimes.  See\n<a href=\"https://github.com/Pylons/colander/issues#issue/5\" rel=\"nofollow\">https://github.com/Pylons/colander/issues#issue/5</a>.</li>\n<li>Allow <tt>default_tzinfo</tt> to be <tt>None</tt> when creating a\n<tt>colander.DateTime</tt>.  See\n<a href=\"https://github.com/Pylons/colander/issues#issue/6\" rel=\"nofollow\">https://github.com/Pylons/colander/issues#issue/6</a>.</li>\n<li>Add the ability to insert a <tt>colander.interfaces.Preparer</tt> between\ndeserialization and validation. See the Preparing section in the\ndocumentation.</li>\n</ul>\n</div>\n<div id=\"id17\">\n<h2>0.9.2 (2011-03-28)</h2>\n<ul>\n<li>Added Polish translation, thanks to Jedrzej Nowak.</li>\n<li>Moved to Pylons Project GitHub (<a href=\"https://github.com/Pylons/colander\" rel=\"nofollow\">https://github.com/Pylons/colander</a>).</li>\n<li>Add tox.ini for testing purposes.</li>\n<li>New API: <tt>colander.required</tt>.  Used as the marker value when a\n<tt>missing</tt> argument is left unspecified.</li>\n<li>Bug fix: if a <tt>title</tt> argument which is the empty string or <tt>None</tt> is\npassed explicitly to a SchemaNode, it is no longer replaced by a title\ncomputed from the name.</li>\n<li>Add SchemaNode.__contains__ to support \u201cname in schema\u201d.</li>\n<li>SchemaNode deserialization now unconditionally calls the schema type\u2019s\n<tt>deserialize</tt> method to obtain an appstruct before attempting to\nvalidate.  Third party schema types should now return <tt>colander.null</tt> if\npassed a <tt>colander.null</tt> value or another logically \u201cempty\u201d value as a\ncstruct during <tt>deserialize</tt>.</li>\n</ul>\n</div>\n<div id=\"id18\">\n<h2>0.9.1 (2010-12-02)</h2>\n<ul>\n<li>When <tt>colander.null</tt> was unpickled, the reference created during\nunpickling was <em>not</em> a reference to the singleton but rather a new instance\nof the <tt>colander._null</tt> class.  This was unintentional, because lots of\ncode checks for <tt>if x is colander.null</tt>, which will fail across pickling\nand unpickling.  Now the reference created when <tt>colander.null</tt> is\npickled is unpickled as the singleton itself.</li>\n</ul>\n</div>\n<div id=\"id19\">\n<h2>0.9  (2010-11-28)</h2>\n<ul>\n<li>SchemaNode constructor now accepts arbitrary keyword arguments.  It\nsets any unknown values within the <tt>**kw</tt> sequence as attributes\nof the node object.</li>\n<li>Added Spanish locale:  thanks to Douglas Cerna for the translations!</li>\n<li>If you use a schema with deferred <tt>validator</tt>, <tt>missing</tt> or\n<tt>default</tt> attributes, but you use it to perform serialization and\ndeserialization without calling its <tt>bind</tt> method:<ul>\n<li>If <tt>validator</tt> is deferred, no validation will be performed.</li>\n<li>If <tt>missing</tt> is deferred, the field will be considered <em>required</em>.</li>\n<li>If <tt>default</tt> is deferred, the serialization default will be\nassumed to be <tt>colander.null</tt>.</li>\n</ul>\n</li>\n<li>Undocumented internal API for all type objects: <tt>flatten</tt>.\nExternal type objects should now inherit from\n<tt>colander.SchemaType</tt> to get a default implementation.</li>\n</ul>\n</div>\n<div id=\"id20\">\n<h2>0.8  (2010/09/08)</h2>\n<ul>\n<li>Docstring fixes to <tt>colander.SchemaNode</tt> (<tt>missing</tt> is not the\n<tt>null</tt> value when required, it\u2019s a special marker value).</li>\n<li>The concept of \u201cschema binding\u201d was added, which allows for a more\ndeclarative-looking spelling of schemas and schema nodes which have\ndependencies on values available after the schema has already been\nfully constructed.  See the new narrative chapter in the\ndocumentation entitled \u201cSchema Binding\u201d.</li>\n<li>The interface of <tt>colander.SchemaNode</tt> has grown a <tt>__delitem__</tt>\nmethod.  The <tt>__iter__</tt>, and <tt>__getitem__</tt> methods have now also\nbeen properly documented.</li>\n</ul>\n</div>\n<div id=\"id21\">\n<h2>0.7.3 (2010/09/02)</h2>\n<ul>\n<li>The title of a schema node now defaults to a titleization of the\n<tt>name</tt>.  Underscores in the <tt>name</tt> are replaced with empty\nstrings and the first letter of every resulting word is capitalized.\nPreviously the <tt>name</tt> was not split on underscores, and the\nentirety of the <tt>name</tt> was capitalized.</li>\n<li>A method of the <tt>colander.Invalid</tt> exception named <tt>messages</tt>\nwas added.  It returns an iterable of error messages using the\n<tt>msg</tt> attribute of its related exception node.  If the <tt>msg</tt>\nattribute is iterable, it is returned.  If it is not iterable, a\nsingle-element list containing the <tt>msg</tt> value is returned.</li>\n</ul>\n</div>\n<div id=\"id22\">\n<h2>0.7.2 (2010/08/30)</h2>\n<ul>\n<li>Add an <tt>colander.SchemaNode.__iter__</tt> method, which iterates over\nthe children nodes of a schema node.</li>\n<li>The constructor of a <tt>colander.SchemaNode</tt> now accepts a\n<tt>widget</tt> keyword argument, for use by Deform (it is not used\ninternally).</li>\n</ul>\n</div>\n<div id=\"id23\">\n<h2>0.7.1 (2010/06/12)</h2>\n<ul>\n<li>Make it possible to use <tt>colander.null</tt> as a <tt>missing</tt> argument\nto <tt>colander.SchemaNode</tt> for roundtripping purposes.</li>\n<li>Make it possible to pickle <tt>colander.null</tt>.</li>\n</ul>\n</div>\n<div id=\"id24\">\n<h2>0.7.0</h2>\n<p>A release centered around normalizing the treatment of default and\nmissing values.</p>\n<div id=\"id25\">\n<h3>Bug Fixes</h3>\n<ul>\n<li>Allow <tt>colander.Regex</tt> validator to accept a pattern object\ninstead of just a string.</li>\n<li>Get rid of circular reference in Invalid exceptions: Invalid\nexceptions now no longer have a <tt>parent</tt> attribute.  Instead, they\nhave a <tt>positional</tt> attribute, which signifies that the parent\nnode type of the schema node to which they relate inherits from\nPositional.  This attribute isn\u2019t an API; it\u2019s used only internally\nfor reporting.</li>\n<li>Raise a <tt>TypeError</tt> when bogus keyword arguments are passed to\n<tt>colander.SchemaNode</tt>.</li>\n</ul>\n</div>\n<div id=\"backwards-incompatiblities-new-features\">\n<h3>Backwards Incompatiblities / New Features</h3>\n<ul>\n<li><p><tt>missing</tt> constructor arg to SchemaNode: signifies\n<em>deserialization</em> default, disambiguated from <tt>default</tt> which acted\nas both serialization and deserialization default previously.</p>\n<p>Changes necessitated / made possible by SchemaNode <tt>missing</tt>\naddition:</p>\n<ul>\n<li>The <tt>allow_empty</tt> argument of the <tt>colander.String</tt> type was\nremoved (use <tt><span class=\"pre\">missing=''</span></tt> as a wrapper SchemaNode argument\ninstead).</li>\n</ul>\n</li>\n<li><p>New concept: <tt>colander.null</tt> input to serialization and\ndeserialization.  Use of <tt>colander.null</tt> normalizes serialization\nand deserialization default handling.</p>\n<p>Changes necessitated / made possible by <tt>colander.null</tt> addition:</p>\n<ul>\n<li><dl>\n<dt><tt>partial</tt> argument and attribute of colander.MappingSchema has</dt>\n<dd>been removed; all serializations are partial, and partial\ndeserializations are not necessary.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>colander.null</tt> values are added to the cstruct for partial</dt>\n<dd>serializations instead of omitting missing node values from\nthe cstruct.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>colander.null</tt> may now be present in serialized and</dt>\n<dd>deserialized data structures.</dd>\n</dl>\n</li>\n<li><tt>sdefault</tt> attribute of SchemaNode has been removed; we never need\nto serialize a default anymore.</li>\n<li>The value <tt>colander.null</tt> will be passed as <tt>appstruct</tt> to\neach type\u2019s <tt>serialize</tt> method when a mapping appstruct doesn\u2019t\nhave a corresponding key instead of <tt>None</tt>, as was the practice\npreviously.</li>\n<li>The value <tt>colander.null</tt> will be passed as <tt>cstruct</tt> to\neach type\u2019s <tt>deserialize</tt> method when a mapping cstruct\ndoesn\u2019t have a corresponding key instead of <tt>None</tt>, as was the\npractice previously.</li>\n<li>Types now must handle <tt>colander.null</tt> explicitly during\nserialization.</li>\n</ul>\n</li>\n<li><p>Updated and expanded documentation, particularly with respect to new\n<tt>colander.null</tt> handling.</p>\n</li>\n<li><p>The <tt>value</tt> argument`` to the <tt>serialize</tt> method of a SchemaNode\nis now named <tt>appstruct</tt>.  It is no longer a required argument; it\ndefaults to <tt>colander.null</tt> now.</p>\n<p>The <tt>value</tt> argument to the <tt>deserialize</tt> method of a SchemaNode\nis now named <tt>cstruct</tt>.  It is no longer a required argument; it\ndefaults to <tt>colander.null</tt> now.</p>\n</li>\n<li><p>The <tt>value</tt> argument to the <tt>serialize</tt> method of each built-in\ntype is now named <tt>appstruct</tt>, and is now required: it is no\nlonger a keyword argument that has a default.</p>\n<p>The <tt>value</tt> argument to the <tt>deserialize</tt> method of each\nbuilt-in type is now named <tt>cstruct</tt>, and is now required: it is\nno longer a keyword argument that has a default.</p>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"id26\">\n<h2>0.6.2 (2010-05-08)</h2>\n<ul>\n<li>The default <tt>encoding</tt> parameter value to the <tt>colander.String</tt>\ntype is still <tt>None</tt>, however its meaning has changed.  An\nencoding of <tt>None</tt> now means that no special encoding and decoding\nof Unicode values is done by the String type.  This differs from the\nprevious behavior, where <tt>None</tt> implied that the encoding was\n<tt><span class=\"pre\">utf-8</span></tt>.  Pass the encoding as <tt><span class=\"pre\">utf-8</span></tt> specifically to get the\nolder behavior back.  This is in support of Deform.</li>\n<li>The default <tt>err_template</tt> value attached to the <tt>colander.Date</tt>\nand <tt>colander.Datetime</tt> types was changed.  It is now simply\n<tt>Invalid date</tt> instead of <tt><span class=\"pre\">_('${val}</span> cannot be parsed as an\niso8601 date: <span class=\"pre\">${err}')</span></tt>.  This is in support of Deform.</li>\n<li>Fix bug in <tt>colander.Boolean</tt> that attempted to call <tt>.lower</tt> on\na bool value when a default value was found for the schema node.</li>\n</ul>\n</div>\n<div id=\"id27\">\n<h2>0.6.1 (2010-05-04)</h2>\n<ul>\n<li>Add a Decimal type (number type which uses <tt>decimal.Decimal</tt> as a\ndeserialization target).</li>\n</ul>\n</div>\n<div id=\"id28\">\n<h2>0.6.0 (2010-05-02)</h2>\n<ul>\n<li>(Hopefully) fix intermittent datetime-granularity-related test\nfailures.</li>\n<li>Internationalized error messages.  This required some changes to\nerror message formatting, which may impact you if you were feeding\ncolander an error message template.</li>\n<li>New project dependency: <tt>translationstring</tt> package for\ninternationalization.</li>\n<li>New argument to <tt>colander.String</tt> constructor: <tt>allow_empty</tt>.\nThis is a boolean representing whether an empty string is a valid\nvalue during deserialization, defaulting to <tt>False</tt>.</li>\n<li>Add minimal documentation about the composition of a\ncolander.Invalid exception to the narrative docs.</li>\n<li>Add (existing, but previously non-API) colander.Invalid attributes\nto its interface within the API documentation.</li>\n</ul>\n</div>\n<div id=\"id29\">\n<h2>0.5.2 (2010-04-09)</h2>\n<ul>\n<li>Add Email and Regex validators (courtesy Steve Howe).</li>\n<li>Raise a <tt>colander.Invalid</tt> error if a <tt>colander.SequenceSchema</tt>\nis created with more than one member.</li>\n<li>Add <tt>Function</tt> validator.</li>\n<li>Fix bug in serialization of non-Unicode values in the <tt>String</tt> class.</li>\n<li>Get rid of <tt>pserialize</tt> in favor of making <tt>serialize</tt> always\npartially serialize.</li>\n<li>Get rid of <tt>pdeserialize</tt>: it existed only for symmetry.  We\u2019ll\nadd something like it back later if we need it.</li>\n</ul>\n</div>\n<div id=\"id30\">\n<h2>0.5.1 (2010-04-02)</h2>\n<ul>\n<li>The constructor arguments to a the <tt>colander.Schema</tt> class are now\nsent to the constructed SchemaNode rather than to the type it represents.</li>\n<li>Allow <tt>colander.Date</tt> and <tt>colander.DateTime</tt> invalid error\nmessages to be customized.</li>\n<li>Add a <tt>pos</tt> argument to the <tt>colander.Invalid.add</tt> method.</li>\n<li>Add a <tt>__setitem__</tt> method to the <tt>colander.Invalid</tt> class.</li>\n<li>The <tt>colander.Mapping</tt> constructor keyword argument\n<tt>unknown_keys</tt> has been renamed to <tt>unknown</tt>.</li>\n<li>Allow <tt>colander.Mapping</tt> type to accept a new constructor\nargument: <tt>partial</tt>.</li>\n<li>New interface methods required by types and schema nodes:\n<tt>pserialize</tt> and <tt>pdeserialize</tt>.  These partially serialize or\npartially deserialize a value (the definition of \u201cpartial\u201d is up to\nthe type).</li>\n</ul>\n</div>\n<div id=\"id31\">\n<h2>0.5 (2010-03-31)</h2>\n<ul>\n<li>0.4 was mispackaged (CHANGES.txt missing); no code changes from 0.4\nhowever.</li>\n</ul>\n</div>\n<div id=\"id32\">\n<h2>0.4 (2010-03-30)</h2>\n<ul>\n<li>Add <tt>colander.DateTime</tt> and <tt>colander.Date</tt> data types.</li>\n<li>Depend on the <tt>iso8601</tt> package for date support.</li>\n</ul>\n</div>\n<div id=\"id33\">\n<h2>0.3 (2010-03-29)</h2>\n<ul>\n<li>Subnodes of a schema node are now kept in the <tt>children</tt> attribute\nrather than the <tt>nodes</tt> attribute.</li>\n<li>Add an <tt>sdefault</tt> property to <tt>colander.SchemaNode</tt> objects.</li>\n<li>Add a <tt>clone</tt> method to <tt>colander.SchemaNode</tt> objects.</li>\n<li>Add a <tt>__str__</tt> method to the <tt>colander.Invalid</tt> exception that\nprints an error summary.</li>\n<li>Various error message improvements.</li>\n<li>Add <tt>colander.Length</tt> validator class.</li>\n</ul>\n</div>\n<div id=\"id34\">\n<h2>0.2 (2010-03-23)</h2>\n<ul>\n<li>Make nodetype overrideable.</li>\n<li>Add __getitem__ to SchemaNode.</li>\n<li>Fix OneOf message.</li>\n<li>Capitalize node titles.</li>\n<li>Deal with empty strings in String, Boolean, and Float types.</li>\n<li>Introduce description; make title the same as name.</li>\n<li>Remove copy method from schemanode.</li>\n<li>Allow schema nodes to have titles.</li>\n<li>The term \u201cstructure\u201d is too overloaded to use for schema purposes:\nstructure -&gt; schema node.</li>\n<li>Make Sequence more like Tuple and Mapping (it uses a substructure\nrather than a structure parameter to denote its type).</li>\n<li>Add __repr__ and copy methods to structure.</li>\n<li>Add accept_scalar flag to Sequence.</li>\n</ul>\n</div>\n<div id=\"id35\">\n<h2>0.1 (2010-03-14)</h2>\n<ul>\n<li>Initial release.</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 1228300, "releases": {"1.0b1": [{"comment_text": "", "digests": {"md5": "797c7c42b1c4f02cf0935446f367d85b", "sha256": "555109ba7fe43432b18db203d2df403ba6bced1916cab6481fb4916e7aa99aaf"}, "downloads": -1, "filename": "ba-colander-1.0b1.tar.gz", "has_sig": false, "md5_digest": "797c7c42b1c4f02cf0935446f367d85b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58055, "upload_time": "2014-09-17T18:41:33", "upload_time_iso_8601": "2014-09-17T18:41:33.627348Z", "url": "https://files.pythonhosted.org/packages/f0/7c/de8b539b0bbc469767276db3779a766a8afffab6f5138548b117216e225f/ba-colander-1.0b1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "797c7c42b1c4f02cf0935446f367d85b", "sha256": "555109ba7fe43432b18db203d2df403ba6bced1916cab6481fb4916e7aa99aaf"}, "downloads": -1, "filename": "ba-colander-1.0b1.tar.gz", "has_sig": false, "md5_digest": "797c7c42b1c4f02cf0935446f367d85b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58055, "upload_time": "2014-09-17T18:41:33", "upload_time_iso_8601": "2014-09-17T18:41:33.627348Z", "url": "https://files.pythonhosted.org/packages/f0/7c/de8b539b0bbc469767276db3779a766a8afffab6f5138548b117216e225f/ba-colander-1.0b1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:15:06 2020"}