{"info": {"author": "David Hagen", "author_email": "david@drhagen.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only", "Topic :: Software Development :: Libraries"], "description": "Parsita\n=======\n\n.. image:: https://travis-ci.org/drhagen/parsita.svg\n   :target: https://travis-ci.org/drhagen/parsita\n.. image:: https://codecov.io/github/drhagen/parsita/coverage.svg\n   :target: https://codecov.io/github/drhagen/parsita\n.. image:: https://img.shields.io/pypi/v/parsita.svg\n   :target: https://pypi.python.org/pypi/parsita\n.. image:: https://img.shields.io/pypi/pyversions/parsita.svg\n   :target: https://pypi.python.org/pypi/parsita\n\nThe executable grammar of parsers combinators made available in the executable pseudocode of Python.\n\nMotivation\n----------\n\nParsita is a parser combinator library written in Python. Parser combinators provide an easy way to define a grammar using code so that the grammar itself effectively parses the source. They are not the fastest to parse, but they are the easiest to write. The science of parser combinators is best left to `others <http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators>`__, so I will demonstrate only the syntax of Parsita.\n\nLike all good parser combinator libraries, this one abuses operators to provide a clean grammar-like syntax. The ``__or__`` method is defined so that ``|`` tests between two alternatives. The ``__and__`` method is defined so that ``&`` tests two parsers in sequence. Other operators are used as well.\n\nIn a technique that I think is new to Python, Parsita uses metaclass magic to allow for forward declarations of values. This is important for parser combinators because grammars are often recursive or mutually recursive, meaning that some components must be used in the definition of others before they themselves are defined.\n\nMotivating example\n^^^^^^^^^^^^^^^^^^\n\nBelow is a complete parser of `JSON <https://tools.ietf.org/html/rfc7159>`__. It could have be shorter if I chose to cheat with Python's ``eval``, but I wanted to show the full power of Parsita:\n\n.. code:: python\n\n    from parsita import *\n    from parsita.util import constant\n\n    class JsonStringParsers(TextParsers, whitespace=None):\n        quote = lit(r'\\\"') > constant('\"')\n        reverse_solidus = lit(r'\\\\') > constant('\\\\')\n        solidus = lit(r'\\/') > constant('/')\n        backspace = lit(r'\\b') > constant('\\b')\n        form_feed = lit(r'\\f') > constant('\\f')\n        line_feed = lit(r'\\n') > constant('\\n')\n        carriage_return = lit(r'\\r') > constant('\\r')\n        tab = lit(r'\\t') > constant('\\t')\n        uni = reg(r'\\\\u([0-9a-fA-F]{4})') > (lambda x: chr(int(x.group(1), 16)))\n\n        escaped = (quote | reverse_solidus | solidus | backspace | form_feed\n                  | line_feed | carriage_return | tab | uni)\n        unescaped = reg(r'[\\u0020-\\u0021\\u0023-\\u005B\\u005D-\\U0010FFFF]+')\n\n        string = '\"' >> rep(escaped | unescaped) << '\"' > ''.join\n\n\n    class JsonParsers(TextParsers, whitespace=r'[ \\t\\n\\r]*'):\n        number = reg(r'-?(0|[1-9][0-9]*)(\\.[0-9]+)?([eE][-+]?[0-9]+)?') > float\n\n        false = lit('false') > constant(False)\n        true = lit('true') > constant(True)\n        null = lit('null') > constant(None)\n\n        string = JsonStringParsers.string\n\n        array = '[' >> repsep(value, ',') << ']'\n\n        entry = string << ':' & value\n        obj = '{' >> repsep(entry, ',') << '}' > dict\n\n        value = number | false | true | null | string | array | obj\n\n    if __name__ == '__main__':\n        strings = [\n            '\"name\"',\n            '-12.40e2',\n            '[false, true, null]',\n            '{\"__class__\" : \"Point\", \"x\" : 2.3, \"y\" : -1.6}',\n            '{\"__class__\" : \"Rectangle\", \"location\" : {\"x\":-1.3,\"y\":-4.5}, \"height\" : 2.0, \"width\" : 4.0}',\n        ]\n\n        for string in strings:\n            print('source: {}\\nvalue: {}'.format(string, JsonParsers.value.parse(string)))\n\nTutorial\n--------\n\nThe recommended means of installation is with ``pip`` from PyPI.\n\n.. code:: bash\n\n    pip3 install parsita\n\nThere is a lot of generic parsing machinery under the hood. Parser combinators have a rich science behind them. If you know all about that and want to do advanced parsing, by all means pop open the source hood and install some nitro. However, most users will want the basic interface, which is described below.\n\n.. code:: python\n\n    from parsita import *\n\nMetaclass magic\n^^^^^^^^^^^^^^^\n\n``GeneralParsers`` and ``TextParsers`` are two classes that are imported that are just wrappers around a couple of metaclasses. They are not meant to be instantiated. They are meant to be inherited from and their class bodies used to define a grammar. I am going to call these classes \"contexts\" to reflect their intended usage.\n\n.. code:: python\n\n    class MyParsers(TextParsers):\n        ...\n\nIf you are parsing strings (and you almost certainly are), use ``TextParsers`` not the other one. If you know what it means to parse things other than strings, you probably don't need this tutorial anyway. ``TextParsers`` ignores whitespace. By default it considers ``r\"\\s*\"`` to be whitespace, but this can be configured using the ``whitespace`` keyword. Use ``None`` to disable whitespace skipping.\n\n.. code:: python\n\n    class MyParsers(TextParsers, whitespace=r'[ \\t]*'):\n        # In here, only space and tab are considered whitespace.\n        # This can be useful for grammars sensitive to newlines.\n        ...\n\n``lit(*literals)``: literal parser\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis is the simplest parser. It matches the exact string provided and returns the string as its value. If multiple arguments are provided, it tries each one in succession, returning the first one it finds.\n\n.. code:: python\n\n    class HelloParsers(TextParsers):\n        hello = lit('Hello World!')\n    assert HelloParsers.hello.parse('Hello World!') == Success('Hello World!')\n    assert HelloParsers.hello.parse('Goodbye') == Failure(\"Hello World! expected but Goodbye found\")\n\nIn most cases, the call to ``lit`` is handled automatically. If a bare string is provided to the functions and operators below, it will be promoted to literal parser whenever possible. Only when an operator is between two Python types, like a string and a string ``'a' | 'b'`` or a string and function ``'100' > int`` will this \"implicit conversion\" not take place and you have to use ``lit`` (e.g. ``lit('a', 'b')`` and ``lit('100') > int``).\n\n``reg(pattern)``: regular expression parser\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nLike ``lit``, this matches a string and returns it, but the matching is done with a `regular expression <https://docs.python.org/3/library/re.html>`__.\n\n.. code:: python\n\n    class IntegerParsers(TextParsers):\n        integer = reg(r'[-+]?[0-9]+')\n    assert IntegerParsers.integer.parse('-128') == Success('-128')\n\n``parser > function``: conversion parser\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nConversion parsers don't change how the text is parsed\u2014they change the value returned. Every parser returns a value when it succeeds. The function supplied must take a single argument (that value) and returns a new value. This is how text is converted to other objects and simpler objects built into larger ones. In accordance with Python's operator precedence, ``>`` is the operator in Parsita with the loosest binding.\n\n.. code:: python\n\n    class IntegerParsers(TextParsers):\n        integer = reg(r'[-+]?[0-9]+') > int\n    assert IntegerParsers.integer.parse('-128') == Success(-128)\n\n``parser1 | parser2``: alternative parser\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis tries to match ``parser1``. If it fails, it then tries to match ``parser2``. If both fail, it returns the failure message from whichever one got farther. Either side can be a bare string, not both because ``'a' | 'b'`` tries to call ``__or__`` on ``str`` which fails. To try alternative literals, use ``lit`` with multiple arguments.\n\n.. code:: python\n\n    class NumberParsers(TextParsers):\n        integer = reg(r'[-+]?[0-9]+') > int\n        real = reg(r'[+-]?\\d+\\.\\d+(e[+-]?\\d+)?') | 'nan' | 'inf' > float\n        number = real | integer\n    assert NumberParsers.number.parse('4.0000') == Success(4.0)\n\n``parser1 & parser2``: sequential parser\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAll the parsers above will match at most one thing. This is the syntax for matching one parser and then another after it. If working in the ``TextParsers`` context, the two may be separated by whitespace. The value returned is a list of all the values returned by each parser. If there are multiple parsers separated by ``&``, a list of the same length as the number of parsers is returned. Like ``|``, either side may be a bare string, but not both. In accordance with Python's operator precedence, ``&`` binds more tightly than ``|``.\n\n.. code:: python\n\n    class UrlParsers(TextParsers, whitespace=None):\n        url = lit('http', 'ftp') & '://' & reg(r'[^/]+') & reg(r'.*')\n    assert UrlParsers.url.parse('http://drhagen.com/blog/sane-equality/') == \\\n        Success(['http', '://', 'drhagen.com', '/blog/sane_equality/'])\n\n``parser1 >> parser2`` and ``parser1 << parser2``: discard left and right parsers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe discard left and discard right parser match the exact same text as ``parser1 & parser2``, but rather than return a list of values from both, the left value in ``>>`` and the right value in ``<<`` is discarded so that only the remaining value is returned. A mnemonic to help remember which is which is to imagine the symbols as open mouths eating the parser to be discarded.\n\n.. code:: python\n\n    class PointParsers(TextParsers):\n        integer = reg(r'[-+]?[0-9]+') > int\n        point = '(' >> integer << ',' & integer << ')'\n    assert PointParsers.point.parse('(4, 3)') == Success([4, 3])\n\nIn accordance with Python's operator precedence, these bind more tightly than any other operators including ``&`` or ``|``, meaning that ``<<`` and ``>>`` discard only the immediate parser.\n\n-  Incorrect: ``entry = key << ':' >> value``\n-  Correct: ``entry = key << ':' & value``\n-  Also correct: ``entry = key & ':' >> value``\n-  Incorrect: ``hostname = lit('http', 'ftp') & '://' >> reg(r'[^/]+') << reg(r'.*')``\n-  Correct: ``hostname = lit('http', 'ftp') >> '://' >> reg(r'[^/]+') << reg(r'.*')``\n-  Also correct: ``hostname = (lit('http', 'ftp') & '://') >> reg(r'[^/]+') << reg(r'.*')``\n\n``opt(parser)``: optional parser\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn optional parser tries to match its argument. If the argument succeeds, it returns a list of length one with the successful value as its only element. If the argument fails, then ``opt`` succeeds anyway, but returns an empty list and consumes no input.\n\n.. code:: python\n\n    class DeclarationParsers(TextParsers):\n        id = reg(r'[A-Za-z_][A-Za-z0-9_]+')\n        declaration = id & opt(':' >> id)\n    assert DeclarationParsers.declaration.parse('x: int') == Success(['x', ['int']])\n\n``rep(parser)`` and ``rep1(parser)``: repeated parsers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA repeated parser matches repeated instances of its parser argument. It returns a list with each element being the value of one match. ``rep1`` only succeeds if at least one match is found. ``rep`` always succeeds, returning an empty list if no matches are found.\n\n.. code:: python\n\n    class SummationParsers(TextParsers):\n        integer = reg(r'[-+]?[0-9]+') > int\n        summation = integer & rep('+' >> integer) > lambda x: sum([x[0]] + x[1])\n    assert SummationParsers.summation.parse('1 + 1 + 2 + 3 + 5') == Success(12)\n\n``repsep(parser, separator)`` and ``rep1sep(parser, separator)``: repeated separated parsers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nA repeated separated parser matches ``parser`` separated by ``separator``, returning a list of the values returned by ``parser`` and discarding the value of ``separator``. ``rep1sep`` only succeeds if at least one match is found. ``repsep`` always succeeds, returning an empty list if no matches are found.\n\n.. code:: python\n\n    class ListParsers(TextParsers):\n        integer = reg(r'[-+]?[0-9]+') > int\n        my_list = '[' >> repsep(integer, ',') << ']'\n    assert ListParsers.my_list.parse('[1,2,3]') == Success([1, 2, 3])\n\n``eof``: end of file\n^^^^^^^^^^^^^^^^^^^^\n\nA parser than matches the end of the input stream. It is not necessary to include this on every parser. The ``parse`` method on every parser is successful if it matches the entire input. The ``eof`` parser is only needed to indicate that the preceding parser is only valid at the end of the input. Most commonly, it is used an alternative to an end token when the end token may be omitted at the end of the input. Note that ``eof`` is not a function\u2014it is a complete parser itself.\n\n.. code:: python\n\n    class OptionsParsers(TextParsers):\n        option = reg(r'[A-Za-z]+') << '=' & reg(r'[A-Za-z]+') << (';' | eof)\n        options = rep(option)\n    assert OptionsParsers.options.parse('log=warn;detail=minimal;') == \\\n        Success([['log', 'warn'], ['detail', 'minimal']])\n    assert OptionsParsers.options.parse('log=warn;detail=minimal') == \\\n        Success([['log', 'warn'], ['detail', 'minimal']])\n\n``fwd()``: forward declaration\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis creates a forward declaration for a parser to be defined later. This function is not typically needed because forward declarations are created automatically within the class bodies of subclasses of ``TextParsers`` and ``GeneralParsers``, which is the recommended way to use Parsita. This function exists so you can create a forward declaration manually because you are either working outside of the magic classes or wish to define them manually to make your IDE happier.\n\nTo use ``fwd``, first assign ``fwd()`` to a variable, then use that variable in other combinators like any other parser, then call the ``define(parser: Parser)`` method on the object to provide the forward declaration with its definition. The forward declaration will now look and act like the definition provided.\n\n.. code:: python\n\n    class ArithmeticParsers(TextParsers):\n        number = reg(r'[+-]?\\d+(\\.\\d+)?(e[+-]?\\d+)?') > float\n        expr = fwd()\n        base = '(' >> expr << ')' | number\n        add = base & '+' >> expr > (lambda x: x[0] + x[1])\n        subtract = base & '-' >> expr > (lambda x: x[0] - x[1])\n        expr.define(add | subtract | base)\n    assert ArithmeticParsers.expr.parse('2-(1+2)') == Success(-1.0)\n\n``success(value)``: always succeed with value\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis parser always succeeds with the given ``value`` of an arbitrary type while consuming no input. Its utility is limited to inserting arbitrary values into complex parsers, often as a placeholder for unimplemented code. Usually, these kinds of values are better inserted as a post processing step or with a conversion parser ``>``, but for prototyping, this parser can be convenient.\n\n.. code:: python\n\n    class HostnameParsers(TextParsers, whitespace=None):\n        port = success(80)  # TODO: do not just ignore other ports\n        host = rep1sep(reg('[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*'), '.')\n        server = host & port\n    assert HostnameParsers.server.parse('drhagen.com') == Success([['drhagen', 'com'], 80])\n\n``failure(expected)``: always fail with message\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis parser always fails with a message that it is expecting the given string ``expected``. Its utility is limited to marking sections of code as either not yet implemented or providing a better error message for common bad input. Usually, these kinds of messages are better crafted as a processing step following parsing, but for prototyping, they can be inserted with this parser.\n\n.. code:: python\n\n    class HostnameParsers(TextParsers, whitespace=None):\n        # TODO: implement allowing different port\n        port = lit('80') | reg('[0-9]+') & failure('no other port than 80')\n        host = rep1sep(reg('[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*'), '.')\n        server = host << ':' & port\n    assert HostnameParsers.server.parse('drhagen.com:443') == \\\n        Failure('Expected no other port than 80 but found end of source')\n\nUtilities\n^^^^^^^^^\n\nThere are several utility functions, ``constant``, ``splat``, and ``unsplat``. They are mostly useful when used with the conversion parser (``>``).\n\n``constant(value)``: create a function that always returns the same value\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe function ``constant(value: A) -> Callable[..., A]`` accepts any single value returns a function. The function takes any number of arguments of any types and returns ``value``. It is useful for defining parsers (usually of a particular literal) that evaluate to a particular value.\n\n.. code:: python\n\n    from parsita import *\n    from parsita.util import constant\n\n    class BooleanParsers(TextParsers, whitespace=None):\n        true = lit('true') > constant(True)\n        false = lit('false') > constant(False)\n        boolean = true | false\n    assert BooleanParsers.boolean.parse('false') == Success(False)\n\n``splat(function)``: convert a function of many arguments to take only one list argument\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe function ``splat(function: Callable[Tuple[*B], A]) -> Callable[Tuple[Tuple[*B]], A]`` has a complicated type signature, but does a simple thing. It takes a single function that takes multiple arguments and converts it to a function that takes only one argument, which is a list of all original arguments. It is particularly useful for passing a list of results from a sequential parser ``&`` to a function that takes each element as an separate argument. By applying ``splat`` to the function, it now takes the single list that is returned by the sequential parser.\n\n.. code:: python\n\n    from collections import namedtuple\n    from parsita import *\n    from parsita.util import splat\n\n    Url = namedtuple('Url', ['host', 'port', 'path'])\n\n    class UrlParsers(TextParsers, whitespace=None):\n        host = reg(r'[A-Za-z0-9.]+')\n        port = reg(r'[0-9]+') > int\n        path = reg(r'[-._~A-Za-z0-9/]*')\n        url = 'https://' >> host << ':' & port & path > splat(Url)\n    assert UrlParsers.url.parse('https://drhagen.com:443/blog/') == \\\n        Success(Url('drhagen.com', 443, '/blog/'))\n\n``unsplat(function)``: convert a function of one list argument to take many arguments\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe function ``unsplat(function: Callable[Tuple[Tuple[*B]], A]) -> Callable[Tuple[*B], A]`` does the opposite of ``splat``. It takes a single function that takes a single argument that is a list and converts it to a function that takes multiple arguments, each of which was an element of the original list. It is not very useful for writing parsers because the conversion parser always calls its converter function with a single argument, but is included here to complement ``splat``.\n\n.. code:: python\n\n    from parsita.util import splat, unsplat\n\n    def sum_args(*x):\n        return sum(x)\n\n    def sum_list(x):\n        return sum(x)\n\n    splatted_sum_args = splat(sum_args)\n    unsplatted_sum_list = unsplat(sum_list)\n\n    assert unsplatted_sum_list(2, 3, 5) == sum_args(2, 3, 5)\n    assert splatted_sum_args([2, 3, 5]) == sum_list([2, 3, 5])", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/drhagen/parsita", "keywords": "parser combinator", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "parsita", "package_url": "https://pypi.org/project/parsita/", "platform": "", "project_url": "https://pypi.org/project/parsita/", "project_urls": {"Homepage": "https://github.com/drhagen/parsita"}, "release_url": "https://pypi.org/project/parsita/1.3.3/", "requires_dist": null, "requires_python": "", "summary": "Parser combinator library for Python.", "version": "1.3.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/drhagen/parsita\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/drhagen/parsita.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/138dedbe5d884c8c93f5173d41e9c007a12dedf0/68747470733a2f2f7472617669732d63692e6f72672f6472686167656e2f706172736974612e737667\"></a>\n<a href=\"https://codecov.io/github/drhagen/parsita\" rel=\"nofollow\"><img alt=\"https://codecov.io/github/drhagen/parsita/coverage.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8245fc9b2166de971d8cd5529a04d134a7848aff/68747470733a2f2f636f6465636f762e696f2f6769746875622f6472686167656e2f706172736974612f636f7665726167652e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/parsita\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/parsita.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/72c771c0188a05fa2e9b5565d7315840404020a4/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f706172736974612e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/parsita\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/pyversions/parsita.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9844ccd1c48344e71a6e9c15e710090ef20929ec/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f706172736974612e737667\"></a>\n<p>The executable grammar of parsers combinators made available in the executable pseudocode of Python.</p>\n<div id=\"motivation\">\n<h2>Motivation</h2>\n<p>Parsita is a parser combinator library written in Python. Parser combinators provide an easy way to define a grammar using code so that the grammar itself effectively parses the source. They are not the fastest to parse, but they are the easiest to write. The science of parser combinators is best left to <a href=\"http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators\" rel=\"nofollow\">others</a>, so I will demonstrate only the syntax of Parsita.</p>\n<p>Like all good parser combinator libraries, this one abuses operators to provide a clean grammar-like syntax. The <tt>__or__</tt> method is defined so that <tt>|</tt> tests between two alternatives. The <tt>__and__</tt> method is defined so that <tt>&amp;</tt> tests two parsers in sequence. Other operators are used as well.</p>\n<p>In a technique that I think is new to Python, Parsita uses metaclass magic to allow for forward declarations of values. This is important for parser combinators because grammars are often recursive or mutually recursive, meaning that some components must be used in the definition of others before they themselves are defined.</p>\n<div id=\"motivating-example\">\n<h3>Motivating example</h3>\n<p>Below is a complete parser of <a href=\"https://tools.ietf.org/html/rfc7159\" rel=\"nofollow\">JSON</a>. It could have be shorter if I chose to cheat with Python\u2019s <tt>eval</tt>, but I wanted to show the full power of Parsita:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">parsita</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parsita.util</span> <span class=\"kn\">import</span> <span class=\"n\">constant</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">JsonStringParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">,</span> <span class=\"n\">whitespace</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"n\">quote</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'\\\"'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'\"'</span><span class=\"p\">)</span>\n    <span class=\"n\">reverse_solidus</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'</span><span class=\"se\">\\\\</span><span class=\"s1\">'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\\\</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n    <span class=\"n\">solidus</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'\\/'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">)</span>\n    <span class=\"n\">backspace</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'\\b'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\b</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n    <span class=\"n\">form_feed</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'\\f'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\f</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n    <span class=\"n\">line_feed</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'\\n'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\n</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n    <span class=\"n\">carriage_return</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'\\r'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\r</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n    <span class=\"n\">tab</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'\\t'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\t</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n    <span class=\"n\">uni</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'</span><span class=\"se\">\\\\</span><span class=\"s1\">u([0-9a-fA-F]</span><span class=\"si\">{4}</span><span class=\"s1\">)'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">chr</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">group</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"mi\">16</span><span class=\"p\">)))</span>\n\n    <span class=\"n\">escaped</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">quote</span> <span class=\"o\">|</span> <span class=\"n\">reverse_solidus</span> <span class=\"o\">|</span> <span class=\"n\">solidus</span> <span class=\"o\">|</span> <span class=\"n\">backspace</span> <span class=\"o\">|</span> <span class=\"n\">form_feed</span>\n              <span class=\"o\">|</span> <span class=\"n\">line_feed</span> <span class=\"o\">|</span> <span class=\"n\">carriage_return</span> <span class=\"o\">|</span> <span class=\"n\">tab</span> <span class=\"o\">|</span> <span class=\"n\">uni</span><span class=\"p\">)</span>\n    <span class=\"n\">unescaped</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[\\u0020-\\u0021\\u0023-\\u005B\\u005D-\\U0010FFFF]+'</span><span class=\"p\">)</span>\n\n    <span class=\"n\">string</span> <span class=\"o\">=</span> <span class=\"s1\">'\"'</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">rep</span><span class=\"p\">(</span><span class=\"n\">escaped</span> <span class=\"o\">|</span> <span class=\"n\">unescaped</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">'\"'</span> <span class=\"o\">&gt;</span> <span class=\"s1\">''</span><span class=\"o\">.</span><span class=\"n\">join</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">JsonParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">,</span> <span class=\"n\">whitespace</span><span class=\"o\">=</span><span class=\"sa\">r</span><span class=\"s1\">'[ \\t\\n\\r]*'</span><span class=\"p\">):</span>\n    <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'-?(0|[1-9][0-9]*)(\\.[0-9]+)?([eE][-+]?[0-9]+)?'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">float</span>\n\n    <span class=\"n\">false</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"s1\">'false'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n    <span class=\"n\">true</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"s1\">'true'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">null</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"s1\">'null'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n\n    <span class=\"n\">string</span> <span class=\"o\">=</span> <span class=\"n\">JsonStringParsers</span><span class=\"o\">.</span><span class=\"n\">string</span>\n\n    <span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"s1\">'['</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">repsep</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"s1\">','</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">']'</span>\n\n    <span class=\"n\">entry</span> <span class=\"o\">=</span> <span class=\"n\">string</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">':'</span> <span class=\"o\">&amp;</span> <span class=\"n\">value</span>\n    <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"s1\">'{'</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">repsep</span><span class=\"p\">(</span><span class=\"n\">entry</span><span class=\"p\">,</span> <span class=\"s1\">','</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">'}'</span> <span class=\"o\">&gt;</span> <span class=\"nb\">dict</span>\n\n    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">number</span> <span class=\"o\">|</span> <span class=\"n\">false</span> <span class=\"o\">|</span> <span class=\"n\">true</span> <span class=\"o\">|</span> <span class=\"n\">null</span> <span class=\"o\">|</span> <span class=\"n\">string</span> <span class=\"o\">|</span> <span class=\"n\">array</span> <span class=\"o\">|</span> <span class=\"n\">obj</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">strings</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"s1\">'\"name\"'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'-12.40e2'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'[false, true, null]'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'{\"__class__\" : \"Point\", \"x\" : 2.3, \"y\" : -1.6}'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'{\"__class__\" : \"Rectangle\", \"location\" : {\"x\":-1.3,\"y\":-4.5}, \"height\" : 2.0, \"width\" : 4.0}'</span><span class=\"p\">,</span>\n    <span class=\"p\">]</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">string</span> <span class=\"ow\">in</span> <span class=\"n\">strings</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'source: </span><span class=\"si\">{}</span><span class=\"se\">\\n</span><span class=\"s1\">value: </span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">,</span> <span class=\"n\">JsonParsers</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)))</span>\n</pre>\n</div>\n</div>\n<div id=\"tutorial\">\n<h2>Tutorial</h2>\n<p>The recommended means of installation is with <tt>pip</tt> from PyPI.</p>\n<pre>pip3 install parsita\n</pre>\n<p>There is a lot of generic parsing machinery under the hood. Parser combinators have a rich science behind them. If you know all about that and want to do advanced parsing, by all means pop open the source hood and install some nitro. However, most users will want the basic interface, which is described below.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">parsita</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n</pre>\n<div id=\"metaclass-magic\">\n<h3>Metaclass magic</h3>\n<p><tt>GeneralParsers</tt> and <tt>TextParsers</tt> are two classes that are imported that are just wrappers around a couple of metaclasses. They are not meant to be instantiated. They are meant to be inherited from and their class bodies used to define a grammar. I am going to call these classes \u201ccontexts\u201d to reflect their intended usage.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>If you are parsing strings (and you almost certainly are), use <tt>TextParsers</tt> not the other one. If you know what it means to parse things other than strings, you probably don\u2019t need this tutorial anyway. <tt>TextParsers</tt> ignores whitespace. By default it considers <tt><span class=\"pre\">r\"\\s*\"</span></tt> to be whitespace, but this can be configured using the <tt>whitespace</tt> keyword. Use <tt>None</tt> to disable whitespace skipping.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">,</span> <span class=\"n\">whitespace</span><span class=\"o\">=</span><span class=\"sa\">r</span><span class=\"s1\">'[ \\t]*'</span><span class=\"p\">):</span>\n    <span class=\"c1\"># In here, only space and tab are considered whitespace.</span>\n    <span class=\"c1\"># This can be useful for grammars sensitive to newlines.</span>\n    <span class=\"o\">...</span>\n</pre>\n</div>\n<div id=\"lit-literals-literal-parser\">\n<h3><tt><span class=\"pre\">lit(*literals)</span></tt>: literal parser</h3>\n<p>This is the simplest parser. It matches the exact string provided and returns the string as its value. If multiple arguments are provided, it tries each one in succession, returning the first one it finds.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">HelloParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">hello</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"s1\">'Hello World!'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">HelloParsers</span><span class=\"o\">.</span><span class=\"n\">hello</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'Hello World!'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">(</span><span class=\"s1\">'Hello World!'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">HelloParsers</span><span class=\"o\">.</span><span class=\"n\">hello</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'Goodbye'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Failure</span><span class=\"p\">(</span><span class=\"s2\">\"Hello World! expected but Goodbye found\"</span><span class=\"p\">)</span>\n</pre>\n<p>In most cases, the call to <tt>lit</tt> is handled automatically. If a bare string is provided to the functions and operators below, it will be promoted to literal parser whenever possible. Only when an operator is between two Python types, like a string and a string <tt>'a' | 'b'</tt> or a string and function <tt>'100' &gt; int</tt> will this \u201cimplicit conversion\u201d not take place and you have to use <tt>lit</tt> (e.g. <tt><span class=\"pre\">lit('a',</span> 'b')</tt> and <tt><span class=\"pre\">lit('100')</span> &gt; int</tt>).</p>\n</div>\n<div id=\"reg-pattern-regular-expression-parser\">\n<h3><tt>reg(pattern)</tt>: regular expression parser</h3>\n<p>Like <tt>lit</tt>, this matches a string and returns it, but the matching is done with a <a href=\"https://docs.python.org/3/library/re.html\" rel=\"nofollow\">regular expression</a>.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">IntegerParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">integer</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[-+]?[0-9]+'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">IntegerParsers</span><span class=\"o\">.</span><span class=\"n\">integer</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'-128'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">(</span><span class=\"s1\">'-128'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"parser-function-conversion-parser\">\n<h3><tt>parser &gt; function</tt>: conversion parser</h3>\n<p>Conversion parsers don\u2019t change how the text is parsed\u2014they change the value returned. Every parser returns a value when it succeeds. The function supplied must take a single argument (that value) and returns a new value. This is how text is converted to other objects and simpler objects built into larger ones. In accordance with Python\u2019s operator precedence, <tt>&gt;</tt> is the operator in Parsita with the loosest binding.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">IntegerParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">integer</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[-+]?[0-9]+'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">int</span>\n<span class=\"k\">assert</span> <span class=\"n\">IntegerParsers</span><span class=\"o\">.</span><span class=\"n\">integer</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'-128'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">128</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"parser1-parser2-alternative-parser\">\n<h3><tt>parser1 | parser2</tt>: alternative parser</h3>\n<p>This tries to match <tt>parser1</tt>. If it fails, it then tries to match <tt>parser2</tt>. If both fail, it returns the failure message from whichever one got farther. Either side can be a bare string, not both because <tt>'a' | 'b'</tt> tries to call <tt>__or__</tt> on <tt>str</tt> which fails. To try alternative literals, use <tt>lit</tt> with multiple arguments.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">NumberParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">integer</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[-+]?[0-9]+'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">int</span>\n    <span class=\"n\">real</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[+-]?\\d+\\.\\d+(e[+-]?\\d+)?'</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"s1\">'nan'</span> <span class=\"o\">|</span> <span class=\"s1\">'inf'</span> <span class=\"o\">&gt;</span> <span class=\"nb\">float</span>\n    <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"n\">real</span> <span class=\"o\">|</span> <span class=\"n\">integer</span>\n<span class=\"k\">assert</span> <span class=\"n\">NumberParsers</span><span class=\"o\">.</span><span class=\"n\">number</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'4.0000'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">(</span><span class=\"mf\">4.0</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"parser1-parser2-sequential-parser\">\n<h3><tt>parser1 &amp; parser2</tt>: sequential parser</h3>\n<p>All the parsers above will match at most one thing. This is the syntax for matching one parser and then another after it. If working in the <tt>TextParsers</tt> context, the two may be separated by whitespace. The value returned is a list of all the values returned by each parser. If there are multiple parsers separated by <tt>&amp;</tt>, a list of the same length as the number of parsers is returned. Like <tt>|</tt>, either side may be a bare string, but not both. In accordance with Python\u2019s operator precedence, <tt>&amp;</tt> binds more tightly than <tt>|</tt>.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">UrlParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">,</span> <span class=\"n\">whitespace</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"n\">url</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"s1\">'http'</span><span class=\"p\">,</span> <span class=\"s1\">'ftp'</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"s1\">'://'</span> <span class=\"o\">&amp;</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[^/]+'</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'.*'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">UrlParsers</span><span class=\"o\">.</span><span class=\"n\">url</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'http://drhagen.com/blog/sane-equality/'</span><span class=\"p\">)</span> <span class=\"o\">==</span> \\\n    <span class=\"n\">Success</span><span class=\"p\">([</span><span class=\"s1\">'http'</span><span class=\"p\">,</span> <span class=\"s1\">'://'</span><span class=\"p\">,</span> <span class=\"s1\">'drhagen.com'</span><span class=\"p\">,</span> <span class=\"s1\">'/blog/sane_equality/'</span><span class=\"p\">])</span>\n</pre>\n</div>\n<div id=\"parser1-parser2-and-parser1-parser2-discard-left-and-right-parsers\">\n<h3><tt>parser1 &gt;&gt; parser2</tt> and <tt>parser1 &lt;&lt; parser2</tt>: discard left and right parsers</h3>\n<p>The discard left and discard right parser match the exact same text as <tt>parser1 &amp; parser2</tt>, but rather than return a list of values from both, the left value in <tt>&gt;&gt;</tt> and the right value in <tt>&lt;&lt;</tt> is discarded so that only the remaining value is returned. A mnemonic to help remember which is which is to imagine the symbols as open mouths eating the parser to be discarded.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">PointParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">integer</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[-+]?[0-9]+'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">int</span>\n    <span class=\"n\">point</span> <span class=\"o\">=</span> <span class=\"s1\">'('</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">integer</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">','</span> <span class=\"o\">&amp;</span> <span class=\"n\">integer</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">')'</span>\n<span class=\"k\">assert</span> <span class=\"n\">PointParsers</span><span class=\"o\">.</span><span class=\"n\">point</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(4, 3)'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">([</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n</pre>\n<p>In accordance with Python\u2019s operator precedence, these bind more tightly than any other operators including <tt>&amp;</tt> or <tt>|</tt>, meaning that <tt>&lt;&lt;</tt> and <tt>&gt;&gt;</tt> discard only the immediate parser.</p>\n<ul>\n<li>Incorrect: <tt>entry = key &lt;&lt; ':' &gt;&gt; value</tt></li>\n<li>Correct: <tt>entry = key &lt;&lt; ':' &amp; value</tt></li>\n<li>Also correct: <tt>entry = key &amp; ':' &gt;&gt; value</tt></li>\n<li>Incorrect: <tt>hostname = <span class=\"pre\">lit('http',</span> 'ftp') &amp; <span class=\"pre\">'://'</span> &gt;&gt; <span class=\"pre\">reg(r'[^/]+')</span> &lt;&lt; <span class=\"pre\">reg(r'.*')</span></tt></li>\n<li>Correct: <tt>hostname = <span class=\"pre\">lit('http',</span> 'ftp') &gt;&gt; <span class=\"pre\">'://'</span> &gt;&gt; <span class=\"pre\">reg(r'[^/]+')</span> &lt;&lt; <span class=\"pre\">reg(r'.*')</span></tt></li>\n<li>Also correct: <tt>hostname = <span class=\"pre\">(lit('http',</span> 'ftp') &amp; <span class=\"pre\">'://')</span> &gt;&gt; <span class=\"pre\">reg(r'[^/]+')</span> &lt;&lt; <span class=\"pre\">reg(r'.*')</span></tt></li>\n</ul>\n</div>\n<div id=\"opt-parser-optional-parser\">\n<h3><tt>opt(parser)</tt>: optional parser</h3>\n<p>An optional parser tries to match its argument. If the argument succeeds, it returns a list of length one with the successful value as its only element. If the argument fails, then <tt>opt</tt> succeeds anyway, but returns an empty list and consumes no input.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">DeclarationParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"nb\">id</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[A-Za-z_][A-Za-z0-9_]+'</span><span class=\"p\">)</span>\n    <span class=\"n\">declaration</span> <span class=\"o\">=</span> <span class=\"nb\">id</span> <span class=\"o\">&amp;</span> <span class=\"n\">opt</span><span class=\"p\">(</span><span class=\"s1\">':'</span> <span class=\"o\">&gt;&gt;</span> <span class=\"nb\">id</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">DeclarationParsers</span><span class=\"o\">.</span><span class=\"n\">declaration</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'x: int'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">([</span><span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'int'</span><span class=\"p\">]])</span>\n</pre>\n</div>\n<div id=\"rep-parser-and-rep1-parser-repeated-parsers\">\n<h3><tt>rep(parser)</tt> and <tt>rep1(parser)</tt>: repeated parsers</h3>\n<p>A repeated parser matches repeated instances of its parser argument. It returns a list with each element being the value of one match. <tt>rep1</tt> only succeeds if at least one match is found. <tt>rep</tt> always succeeds, returning an empty list if no matches are found.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">SummationParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">integer</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[-+]?[0-9]+'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">int</span>\n    <span class=\"n\">summation</span> <span class=\"o\">=</span> <span class=\"n\">integer</span> <span class=\"o\">&amp;</span> <span class=\"n\">rep</span><span class=\"p\">(</span><span class=\"s1\">'+'</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">integer</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">sum</span><span class=\"p\">([</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]]</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"k\">assert</span> <span class=\"n\">SummationParsers</span><span class=\"o\">.</span><span class=\"n\">summation</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'1 + 1 + 2 + 3 + 5'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">(</span><span class=\"mi\">12</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"repsep-parser-separator-and-rep1sep-parser-separator-repeated-separated-parsers\">\n<h3><tt>repsep(parser, separator)</tt> and <tt>rep1sep(parser, separator)</tt>: repeated separated parsers</h3>\n<p>A repeated separated parser matches <tt>parser</tt> separated by <tt>separator</tt>, returning a list of the values returned by <tt>parser</tt> and discarding the value of <tt>separator</tt>. <tt>rep1sep</tt> only succeeds if at least one match is found. <tt>repsep</tt> always succeeds, returning an empty list if no matches are found.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">ListParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">integer</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[-+]?[0-9]+'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">int</span>\n    <span class=\"n\">my_list</span> <span class=\"o\">=</span> <span class=\"s1\">'['</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">repsep</span><span class=\"p\">(</span><span class=\"n\">integer</span><span class=\"p\">,</span> <span class=\"s1\">','</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">']'</span>\n<span class=\"k\">assert</span> <span class=\"n\">ListParsers</span><span class=\"o\">.</span><span class=\"n\">my_list</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'[1,2,3]'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">])</span>\n</pre>\n</div>\n<div id=\"eof-end-of-file\">\n<h3><tt>eof</tt>: end of file</h3>\n<p>A parser than matches the end of the input stream. It is not necessary to include this on every parser. The <tt>parse</tt> method on every parser is successful if it matches the entire input. The <tt>eof</tt> parser is only needed to indicate that the preceding parser is only valid at the end of the input. Most commonly, it is used an alternative to an end token when the end token may be omitted at the end of the input. Note that <tt>eof</tt> is not a function\u2014it is a complete parser itself.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">OptionsParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">option</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[A-Za-z]+'</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">'='</span> <span class=\"o\">&amp;</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[A-Za-z]+'</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"s1\">';'</span> <span class=\"o\">|</span> <span class=\"n\">eof</span><span class=\"p\">)</span>\n    <span class=\"n\">options</span> <span class=\"o\">=</span> <span class=\"n\">rep</span><span class=\"p\">(</span><span class=\"n\">option</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">OptionsParsers</span><span class=\"o\">.</span><span class=\"n\">options</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'log=warn;detail=minimal;'</span><span class=\"p\">)</span> <span class=\"o\">==</span> \\\n    <span class=\"n\">Success</span><span class=\"p\">([[</span><span class=\"s1\">'log'</span><span class=\"p\">,</span> <span class=\"s1\">'warn'</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s1\">'detail'</span><span class=\"p\">,</span> <span class=\"s1\">'minimal'</span><span class=\"p\">]])</span>\n<span class=\"k\">assert</span> <span class=\"n\">OptionsParsers</span><span class=\"o\">.</span><span class=\"n\">options</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'log=warn;detail=minimal'</span><span class=\"p\">)</span> <span class=\"o\">==</span> \\\n    <span class=\"n\">Success</span><span class=\"p\">([[</span><span class=\"s1\">'log'</span><span class=\"p\">,</span> <span class=\"s1\">'warn'</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s1\">'detail'</span><span class=\"p\">,</span> <span class=\"s1\">'minimal'</span><span class=\"p\">]])</span>\n</pre>\n</div>\n<div id=\"fwd-forward-declaration\">\n<h3><tt>fwd()</tt>: forward declaration</h3>\n<p>This creates a forward declaration for a parser to be defined later. This function is not typically needed because forward declarations are created automatically within the class bodies of subclasses of <tt>TextParsers</tt> and <tt>GeneralParsers</tt>, which is the recommended way to use Parsita. This function exists so you can create a forward declaration manually because you are either working outside of the magic classes or wish to define them manually to make your IDE happier.</p>\n<p>To use <tt>fwd</tt>, first assign <tt>fwd()</tt> to a variable, then use that variable in other combinators like any other parser, then call the <tt>define(parser: Parser)</tt> method on the object to provide the forward declaration with its definition. The forward declaration will now look and act like the definition provided.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">ArithmeticParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">):</span>\n    <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[+-]?\\d+(\\.\\d+)?(e[+-]?\\d+)?'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">float</span>\n    <span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"n\">fwd</span><span class=\"p\">()</span>\n    <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"s1\">'('</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">expr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">')'</span> <span class=\"o\">|</span> <span class=\"n\">number</span>\n    <span class=\"n\">add</span> <span class=\"o\">=</span> <span class=\"n\">base</span> <span class=\"o\">&amp;</span> <span class=\"s1\">'+'</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">expr</span> <span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n    <span class=\"n\">subtract</span> <span class=\"o\">=</span> <span class=\"n\">base</span> <span class=\"o\">&amp;</span> <span class=\"s1\">'-'</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">expr</span> <span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n    <span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">define</span><span class=\"p\">(</span><span class=\"n\">add</span> <span class=\"o\">|</span> <span class=\"n\">subtract</span> <span class=\"o\">|</span> <span class=\"n\">base</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">ArithmeticParsers</span><span class=\"o\">.</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'2-(1+2)'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"success-value-always-succeed-with-value\">\n<h3><tt>success(value)</tt>: always succeed with value</h3>\n<p>This parser always succeeds with the given <tt>value</tt> of an arbitrary type while consuming no input. Its utility is limited to inserting arbitrary values into complex parsers, often as a placeholder for unimplemented code. Usually, these kinds of values are better inserted as a post processing step or with a conversion parser <tt>&gt;</tt>, but for prototyping, this parser can be convenient.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">HostnameParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">,</span> <span class=\"n\">whitespace</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"n\">port</span> <span class=\"o\">=</span> <span class=\"n\">success</span><span class=\"p\">(</span><span class=\"mi\">80</span><span class=\"p\">)</span>  <span class=\"c1\"># TODO: do not just ignore other ports</span>\n    <span class=\"n\">host</span> <span class=\"o\">=</span> <span class=\"n\">rep1sep</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"s1\">'[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*'</span><span class=\"p\">),</span> <span class=\"s1\">'.'</span><span class=\"p\">)</span>\n    <span class=\"n\">server</span> <span class=\"o\">=</span> <span class=\"n\">host</span> <span class=\"o\">&amp;</span> <span class=\"n\">port</span>\n<span class=\"k\">assert</span> <span class=\"n\">HostnameParsers</span><span class=\"o\">.</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'drhagen.com'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">([[</span><span class=\"s1\">'drhagen'</span><span class=\"p\">,</span> <span class=\"s1\">'com'</span><span class=\"p\">],</span> <span class=\"mi\">80</span><span class=\"p\">])</span>\n</pre>\n</div>\n<div id=\"failure-expected-always-fail-with-message\">\n<h3><tt>failure(expected)</tt>: always fail with message</h3>\n<p>This parser always fails with a message that it is expecting the given string <tt>expected</tt>. Its utility is limited to marking sections of code as either not yet implemented or providing a better error message for common bad input. Usually, these kinds of messages are better crafted as a processing step following parsing, but for prototyping, they can be inserted with this parser.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">HostnameParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">,</span> <span class=\"n\">whitespace</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"c1\"># TODO: implement allowing different port</span>\n    <span class=\"n\">port</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"s1\">'80'</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"s1\">'[0-9]+'</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">failure</span><span class=\"p\">(</span><span class=\"s1\">'no other port than 80'</span><span class=\"p\">)</span>\n    <span class=\"n\">host</span> <span class=\"o\">=</span> <span class=\"n\">rep1sep</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"s1\">'[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*'</span><span class=\"p\">),</span> <span class=\"s1\">'.'</span><span class=\"p\">)</span>\n    <span class=\"n\">server</span> <span class=\"o\">=</span> <span class=\"n\">host</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">':'</span> <span class=\"o\">&amp;</span> <span class=\"n\">port</span>\n<span class=\"k\">assert</span> <span class=\"n\">HostnameParsers</span><span class=\"o\">.</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'drhagen.com:443'</span><span class=\"p\">)</span> <span class=\"o\">==</span> \\\n    <span class=\"n\">Failure</span><span class=\"p\">(</span><span class=\"s1\">'Expected no other port than 80 but found end of source'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"utilities\">\n<h3>Utilities</h3>\n<p>There are several utility functions, <tt>constant</tt>, <tt>splat</tt>, and <tt>unsplat</tt>. They are mostly useful when used with the conversion parser (<tt>&gt;</tt>).</p>\n<div id=\"constant-value-create-a-function-that-always-returns-the-same-value\">\n<h4><tt>constant(value)</tt>: create a function that always returns the same value</h4>\n<p>The function <tt>constant(value: A) <span class=\"pre\">-&gt;</span> <span class=\"pre\">Callable[...,</span> A]</tt> accepts any single value returns a function. The function takes any number of arguments of any types and returns <tt>value</tt>. It is useful for defining parsers (usually of a particular literal) that evaluate to a particular value.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">parsita</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parsita.util</span> <span class=\"kn\">import</span> <span class=\"n\">constant</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">BooleanParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">,</span> <span class=\"n\">whitespace</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"n\">true</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"s1\">'true'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">false</span> <span class=\"o\">=</span> <span class=\"n\">lit</span><span class=\"p\">(</span><span class=\"s1\">'false'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n    <span class=\"n\">boolean</span> <span class=\"o\">=</span> <span class=\"n\">true</span> <span class=\"o\">|</span> <span class=\"n\">false</span>\n<span class=\"k\">assert</span> <span class=\"n\">BooleanParsers</span><span class=\"o\">.</span><span class=\"n\">boolean</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'false'</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Success</span><span class=\"p\">(</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"splat-function-convert-a-function-of-many-arguments-to-take-only-one-list-argument\">\n<h4><tt>splat(function)</tt>: convert a function of many arguments to take only one list argument</h4>\n<p>The function <tt>splat(function: <span class=\"pre\">Callable[Tuple[*B],</span> A]) <span class=\"pre\">-&gt;</span> <span class=\"pre\">Callable[Tuple[Tuple[*B]],</span> A]</tt> has a complicated type signature, but does a simple thing. It takes a single function that takes multiple arguments and converts it to a function that takes only one argument, which is a list of all original arguments. It is particularly useful for passing a list of results from a sequential parser <tt>&amp;</tt> to a function that takes each element as an separate argument. By applying <tt>splat</tt> to the function, it now takes the single list that is returned by the sequential parser.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">collections</span> <span class=\"kn\">import</span> <span class=\"n\">namedtuple</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parsita</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n<span class=\"kn\">from</span> <span class=\"nn\">parsita.util</span> <span class=\"kn\">import</span> <span class=\"n\">splat</span>\n\n<span class=\"n\">Url</span> <span class=\"o\">=</span> <span class=\"n\">namedtuple</span><span class=\"p\">(</span><span class=\"s1\">'Url'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'host'</span><span class=\"p\">,</span> <span class=\"s1\">'port'</span><span class=\"p\">,</span> <span class=\"s1\">'path'</span><span class=\"p\">])</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">UrlParsers</span><span class=\"p\">(</span><span class=\"n\">TextParsers</span><span class=\"p\">,</span> <span class=\"n\">whitespace</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"n\">host</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[A-Za-z0-9.]+'</span><span class=\"p\">)</span>\n    <span class=\"n\">port</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[0-9]+'</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"nb\">int</span>\n    <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[-._~A-Za-z0-9/]*'</span><span class=\"p\">)</span>\n    <span class=\"n\">url</span> <span class=\"o\">=</span> <span class=\"s1\">'https://'</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">host</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s1\">':'</span> <span class=\"o\">&amp;</span> <span class=\"n\">port</span> <span class=\"o\">&amp;</span> <span class=\"n\">path</span> <span class=\"o\">&gt;</span> <span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"n\">Url</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">UrlParsers</span><span class=\"o\">.</span><span class=\"n\">url</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'https://drhagen.com:443/blog/'</span><span class=\"p\">)</span> <span class=\"o\">==</span> \\\n    <span class=\"n\">Success</span><span class=\"p\">(</span><span class=\"n\">Url</span><span class=\"p\">(</span><span class=\"s1\">'drhagen.com'</span><span class=\"p\">,</span> <span class=\"mi\">443</span><span class=\"p\">,</span> <span class=\"s1\">'/blog/'</span><span class=\"p\">))</span>\n</pre>\n</div>\n<div id=\"unsplat-function-convert-a-function-of-one-list-argument-to-take-many-arguments\">\n<h4><tt>unsplat(function)</tt>: convert a function of one list argument to take many arguments</h4>\n<p>The function <tt>unsplat(function: <span class=\"pre\">Callable[Tuple[Tuple[*B]],</span> A]) <span class=\"pre\">-&gt;</span> <span class=\"pre\">Callable[Tuple[*B],</span> A]</tt> does the opposite of <tt>splat</tt>. It takes a single function that takes a single argument that is a list and converts it to a function that takes multiple arguments, each of which was an element of the original list. It is not very useful for writing parsers because the conversion parser always calls its converter function with a single argument, but is included here to complement <tt>splat</tt>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">parsita.util</span> <span class=\"kn\">import</span> <span class=\"n\">splat</span><span class=\"p\">,</span> <span class=\"n\">unsplat</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">sum_args</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">sum_list</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n<span class=\"n\">splatted_sum_args</span> <span class=\"o\">=</span> <span class=\"n\">splat</span><span class=\"p\">(</span><span class=\"n\">sum_args</span><span class=\"p\">)</span>\n<span class=\"n\">unsplatted_sum_list</span> <span class=\"o\">=</span> <span class=\"n\">unsplat</span><span class=\"p\">(</span><span class=\"n\">sum_list</span><span class=\"p\">)</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">unsplatted_sum_list</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">sum_args</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">splatted_sum_args</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span> <span class=\"o\">==</span> <span class=\"n\">sum_list</span><span class=\"p\">([</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n</pre>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6150599, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "4985de483ec4c96514d6361e1fbd6bd9", "sha256": "8ae26767555ca54e254b0cbb2a66ff3dd0cffdde5172e590f6b70c5952937b12"}, "downloads": -1, "filename": "parsita-1.0.0.tar.gz", "has_sig": false, "md5_digest": "4985de483ec4c96514d6361e1fbd6bd9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13214, "upload_time": "2016-10-02T21:56:50", "upload_time_iso_8601": "2016-10-02T21:56:50.029266Z", "url": "https://files.pythonhosted.org/packages/ff/d0/35c46eaa4c10de297ce26c61748283e9946e67c7082743301b90102fdcb6/parsita-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "d807af75dd3bec1e8240ff0c662deb17", "sha256": "02aebe9c7e92e54692fd3b16309d247a6e90b26e916cf6cbcdff4b8e8ff48c6a"}, "downloads": -1, "filename": "parsita-1.1.0.tar.gz", "has_sig": false, "md5_digest": "d807af75dd3bec1e8240ff0c662deb17", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13630, "upload_time": "2016-11-16T11:47:40", "upload_time_iso_8601": "2016-11-16T11:47:40.484720Z", "url": "https://files.pythonhosted.org/packages/60/71/5b03a55c9899f2100592967da146ffb35b8043e3c51f9dc70415515c800d/parsita-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "bde32bc55719d2935def133c9ff19b0b", "sha256": "dbe859430f3bd4b03998e782b1363a2ae8ae09cc34cfe9479f8c8327739c4a2e"}, "downloads": -1, "filename": "parsita-1.1.1.tar.gz", "has_sig": false, "md5_digest": "bde32bc55719d2935def133c9ff19b0b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13632, "upload_time": "2017-02-18T14:07:08", "upload_time_iso_8601": "2017-02-18T14:07:08.648798Z", "url": "https://files.pythonhosted.org/packages/ee/7e/30bd339ca51947f649868615879b193e04cf0935df68c84d8794769144d7/parsita-1.1.1.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "d58d079431d4d109471fd3b95a5b3312", "sha256": "f1ba917e714df20c78f033d081d05cf90a47481a2a879561afa340c3f95f7848"}, "downloads": -1, "filename": "parsita-1.2.0.tar.gz", "has_sig": false, "md5_digest": "d58d079431d4d109471fd3b95a5b3312", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14698, "upload_time": "2017-10-06T00:46:14", "upload_time_iso_8601": "2017-10-06T00:46:14.555362Z", "url": "https://files.pythonhosted.org/packages/f7/da/9b5e7a944cd52fbba67fe1bb7d018eeeabb539a4948d05ff3db8cfe83559/parsita-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "4649974e716b3a0a36dc028268164133", "sha256": "bf3a35287599bf65f23e7095784131fdda60500b9f760480c332a9b20903c008"}, "downloads": -1, "filename": "parsita-1.2.1.tar.gz", "has_sig": false, "md5_digest": "4649974e716b3a0a36dc028268164133", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15719, "upload_time": "2018-04-02T00:57:45", "upload_time_iso_8601": "2018-04-02T00:57:45.034445Z", "url": "https://files.pythonhosted.org/packages/86/f6/bb50d2e8d15034607f0b5abea0d464ebdda5bfba6536d35954bdbebd0271/parsita-1.2.1.tar.gz", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "33d3dbca0ec0112363a0c305e8bd55ad", "sha256": "96a4fb94a6ee705a256aa5251791bb04be0186af2eaea9acb5d09ed1f3a33748"}, "downloads": -1, "filename": "parsita-1.3.0.tar.gz", "has_sig": false, "md5_digest": "33d3dbca0ec0112363a0c305e8bd55ad", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17138, "upload_time": "2018-04-28T17:26:45", "upload_time_iso_8601": "2018-04-28T17:26:45.863953Z", "url": "https://files.pythonhosted.org/packages/27/95/31f369c4cbf5df3b5e78d1bfb71d4f9921734f03d7fb653f0a62356a5392/parsita-1.3.0.tar.gz", "yanked": false}], "1.3.1": [{"comment_text": "", "digests": {"md5": "169497e4548f0a825b35abb3bb42c5fc", "sha256": "6096ddc5ff9d2def24d195a39275d9fa7045b0ff65d8c993f15491890a895546"}, "downloads": -1, "filename": "parsita-1.3.1.tar.gz", "has_sig": false, "md5_digest": "169497e4548f0a825b35abb3bb42c5fc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17143, "upload_time": "2018-04-28T17:49:21", "upload_time_iso_8601": "2018-04-28T17:49:21.447916Z", "url": "https://files.pythonhosted.org/packages/c9/2e/793eef161fd99511962d696df9c28b4db51de9e9201f8233fb48010b5dd9/parsita-1.3.1.tar.gz", "yanked": false}], "1.3.2": [{"comment_text": "", "digests": {"md5": "4b00e08bc4a80df304c82fe280e5c58e", "sha256": "9a5a132f1e40339c204406b86e024ddc8819764a1b776fbe297391c559156e87"}, "downloads": -1, "filename": "parsita-1.3.2.tar.gz", "has_sig": false, "md5_digest": "4b00e08bc4a80df304c82fe280e5c58e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17166, "upload_time": "2018-07-25T16:08:26", "upload_time_iso_8601": "2018-07-25T16:08:26.200446Z", "url": "https://files.pythonhosted.org/packages/b8/8c/596a5b4c2e6a6d6402c2a02c9c7526b0f45e471dd6a663417ae5dcff5537/parsita-1.3.2.tar.gz", "yanked": false}], "1.3.3": [{"comment_text": "", "digests": {"md5": "33e0fd30ca9ef4efa4f6901940f89be1", "sha256": "be2b4c72d866b5d2b168b256a9fc69fb700d45a413fe5a66cacb790c00a51000"}, "downloads": -1, "filename": "parsita-1.3.3.tar.gz", "has_sig": false, "md5_digest": "33e0fd30ca9ef4efa4f6901940f89be1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24264, "upload_time": "2019-11-17T14:21:46", "upload_time_iso_8601": "2019-11-17T14:21:46.540418Z", "url": "https://files.pythonhosted.org/packages/61/a9/48a031a0464b3f079067d3950369c3989139f70ac2e8c0069f85facfcad6/parsita-1.3.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "33e0fd30ca9ef4efa4f6901940f89be1", "sha256": "be2b4c72d866b5d2b168b256a9fc69fb700d45a413fe5a66cacb790c00a51000"}, "downloads": -1, "filename": "parsita-1.3.3.tar.gz", "has_sig": false, "md5_digest": "33e0fd30ca9ef4efa4f6901940f89be1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24264, "upload_time": "2019-11-17T14:21:46", "upload_time_iso_8601": "2019-11-17T14:21:46.540418Z", "url": "https://files.pythonhosted.org/packages/61/a9/48a031a0464b3f079067d3950369c3989139f70ac2e8c0069f85facfcad6/parsita-1.3.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:16 2020"}