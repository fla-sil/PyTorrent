{"info": {"author": "Matthew Schinckel", "author_email": "matt@schinckel.net", "bugtrack_url": null, "classifiers": ["Framework :: Django", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python"], "description": "django-websocket\n================\n\nIntroduction\n------------\n\nWSGI is thought to be largely incompatible with WebSockets, but that's not necessarily the case. As is shown by `gevent-websocket <https://pypi.python.org/pypi/gevent-websocket/>`_, you can get a really easy WSGI/WebSocket server running using gunicorn.\n\n\nHowever, it would be really nice to be able to integrate a WebSocket server with Django. That is, not just have access to the Django models, but access to the whole Django infrastructure. Whilst it may not make much sense to use the template rendering, it certainly would be convenient to get access to the middleware and authentication from your django project. And being able to use the django form handling to validate user input means you can write more robust code.\n\n\nThis module allows you to do just that. You run a server alongside your normal WSGI server, that listens for WebSocket connection requests. An incoming connection is handled initially by the Django url routing facility (but with a seperate urlconf), and the Django middleware is applied. Then, your WebSocket view function is called, that handles the connection from that point on.\n\n\n.. warning::\n\n  This is still a work in progress. I'm not using it in any projects other than for testing. It may actually turn out not to be feasible to use this for production-level WebSockets, but I am still hopeful.\n\n\nPlayground\n----------\n\nGo into test_project::\n\n  $ virtualenv .\n  . bin/activate\n  pip install -r requirements.txt\n\nYou will then need to have two shells open::\n\n  ./project/manage.py runserver 0.0.0.0\n  gunicorn -k \"geventwebsocket.gunicorn.workers.GeventWebSocketWorker\" project.wsgi:websocket -b 0.0.0.0:8001\n\n\nVisit http://localhost:8000/chat/ to open a chat window.\n  \nYou can have multiple windows in multiple browsers open, and chat between them.\nYou may change the user name, and the colour that the name should appear in.\n\nThere are a couple of other example WebSocket servers:\n\n* http://localhost:8000/echo/ - Repeats back to you whatever you send to it.\n* http://localhost:8000/ping/ - Respond with 'pong' if you send 'ping', and vice versa. Otherwise, don't respond at all.\n\n\nInstallation\n------------\n\nInstall from PyPI using::\n\n  $ pip install django-gevent-websocket\n\nIt will install it's various dependencies:\n\n* django\n* gevent-websocket\n* gunicorn\n\nUsage\n-----\n\nSettings\n~~~~~~~~\n\nAdd the following to your ``$PROJECT_DIR/wsgi.py``::\n\n  from django_websocket.wsgi import get_wsgi_websocket_application\n  websocket = get_wsgi_websocket_application()\n\nAdd the following to your ``$PROJECT_DIR/settings.py``::\n\n  WEBSOCKET_URLCONF = '<path-to-websocket-urlconf>'\n  \nA suggested urlconf would be ``$PROJECT_DIR/websocket_urls.py``.\n\nYou then need to add your WebSocket urls to that file: they will be very similar to your normal urls, but will only contain the endpoints that should accept a WebSocket connection::\n\n  from django.conf.urls import patterns, url\n  \n  urlpatterns = patterns('',\n      url(r'^chat/$', 'path.to.view', name='chat'),\n  )\n\nIf you want to use ``{% websocket_url %}`` to get absolute urls that point to the correct WebSocket server and port, then you'll need to set\n\nViews\n~~~~~\n\nA WebSocket view function looks very much like a normal django view function, indeed, it is called by the regular django request cycle, but it does not return an HttpResponse object. Instead, you grab the websocket object from the request, and ``.receive()`` data from it, or ``.send(data)`` to it.\n\nTo make things easier, you can use the decorators to wrap your views::\n\n    from django_websocket.decorators import websocket\n    \n    @websocket\n    def view_function(request, websocket, *args, **kwargs):\n        # do stuff here.\n\nThis decorator adds the websocket as the second argument to your view: you still have the request object, allowing you to do things like permissions checking. You can still use any of the regular django decorators if you wish.\n\nAsynchronicity in views\n***********************\n\nA WebSocket view should listen for incoming data from the client that needs to be processed, but will probably also want to be listening for data coming from another source, that will be sent back to the client.\n\nA simple way to do this is to use the `select.select` function, and use this to write non-blocking code that waits for a signal to proceed. Typically, you'll want to loop until the websocket is closed, and then wait for a signal::\n\n    from select import select\n    \n    from django_websocket.decorators import websocket\n    \n    @websocket\n    def view_function(request, websocket):\n        ws_sock = websocket.handler.socket.fileno()\n        other_sock = ... # other socket to listen on.\n        \n        while not websocket.closed():\n            fd = select([ws_sock, other_sock], [], [])[0][0]\n            \n            if fd == ws_sock:\n                data = websocket.receive()\n                # Deal with incoming data.\n            else: ## fd == other_sock:\n                # Deal with data from the other source\n                websocket.send(message)\n\nA good 'other' source might be a Redis PubSub subscription, which allows you to subscribe to channels, and will notify you when new data is available on any of these.\n\nFrom ``django_websocket.servers.chat``::\n\n    from select import select\n\n    import redis\n\n    from ..decorators import websocket\n\n    @websocket\n    def chat(request, websocket, *args, **kwargs):\n\n        conn = redis.StrictRedis()\n        subs = conn.pubsub()\n        subs.subscribe('CHAT')\n    \n        def incoming():\n            data = websocket.receive()\n            if data:\n                conn.publish('CHAT', data)\n    \n        def outgoing():\n            msg_type, channel, message = subs.parse_response()\n            if msg_type == 'message':\n                websocket.send(message)\n    \n        sockets = {\n            websocket.handler.socket.fileno(): incoming,\n            subs.connection._sock.fileno(): outgoing\n        }\n    \n        while not websocket.closed:\n            fd = select(sockets.keys(), [], [])[0][0]\n            sockets[fd]()\n\n\nTemplate Tag\n~~~~~~~~~~~~\n\nBecause you should have a different urlconf for your WebSocket views, you will need to use a slightly different template tag to get access to the WebSocket urls::\n\n    {% load websockets %}\n    \n    <script>\n      var ws = new WebSocket(\"{% websocket_url 'urlname' %}\");\n      \n      // Do something with your shiny new WebSocket!\n      // ws.send('foo');\n    </script>\n\n\n\nStarting the Server\n~~~~~~~~~~~~~~~~~~~\n\nYou will need to start the ``geventwebsocket`` server seperately: there is no django management command (which mirrors the deprecation of run_gunicorn)::\n\n  gunicorn -k \"geventwebsocket.gunicorn.workers.GeventWebSocketWorker\" $PROJECT_DIR.wsgi:websocket -b 127.0.0.1:8001\n\nNote this runs on a different port than your django development server (or gunicorn in production). In production you will probably stick both of them behind an nginx proxy or similar. If you want to do this, you may have to do some tricky to get the splitting out of the websocket connections to work. I did something like::\n\n\n  server {\n    listen  80;\n    proxy_set_header Host $host;\n    \n    location /static/ {\n      alias ...\n    }\n    \n    if ($http_upgrade) {\n      rewrite ^(.*)$ /__ws__/$1 break;\n    }\n  \n    location /__ws__/ {\n      proxy_pass http://127.0.0.1:8001;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection \"upgrade\";\n      rewrite ^/__ws__/(.*)$ $1 break;\n      return;\n    }\n    \n    location / {\n      proxy_pass http://127.0.0.1:8000;\n    }\n  }\n\nNotice the double rewrite. It rewrites the url when the Upgrade header is present, and then rewrites it back, so that the url matches within django.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://bitbucket.org/schinckel/django-gevent-websocket/", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "django-gevent-websocket", "package_url": "https://pypi.org/project/django-gevent-websocket/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-gevent-websocket/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://bitbucket.org/schinckel/django-gevent-websocket/"}, "release_url": "https://pypi.org/project/django-gevent-websocket/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "Easy WebSocket server for django using gevent-websocket", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>WSGI is thought to be largely incompatible with WebSockets, but that\u2019s not necessarily the case. As is shown by <a href=\"https://pypi.python.org/pypi/gevent-websocket/\" rel=\"nofollow\">gevent-websocket</a>, you can get a really easy WSGI/WebSocket server running using gunicorn.</p>\n<p>However, it would be really nice to be able to integrate a WebSocket server with Django. That is, not just have access to the Django models, but access to the whole Django infrastructure. Whilst it may not make much sense to use the template rendering, it certainly would be convenient to get access to the middleware and authentication from your django project. And being able to use the django form handling to validate user input means you can write more robust code.</p>\n<p>This module allows you to do just that. You run a server alongside your normal WSGI server, that listens for WebSocket connection requests. An incoming connection is handled initially by the Django url routing facility (but with a seperate urlconf), and the Django middleware is applied. Then, your WebSocket view function is called, that handles the connection from that point on.</p>\n<div>\n<p>Warning</p>\n<p>This is still a work in progress. I\u2019m not using it in any projects other than for testing. It may actually turn out not to be feasible to use this for production-level WebSockets, but I am still hopeful.</p>\n</div>\n</div>\n<div id=\"playground\">\n<h2>Playground</h2>\n<p>Go into test_project:</p>\n<pre>$ virtualenv .\n. bin/activate\npip install -r requirements.txt\n</pre>\n<p>You will then need to have two shells open:</p>\n<pre>./project/manage.py runserver 0.0.0.0\ngunicorn -k \"geventwebsocket.gunicorn.workers.GeventWebSocketWorker\" project.wsgi:websocket -b 0.0.0.0:8001\n</pre>\n<p>Visit <a href=\"http://localhost:8000/chat/\" rel=\"nofollow\">http://localhost:8000/chat/</a> to open a chat window.</p>\n<p>You can have multiple windows in multiple browsers open, and chat between them.\nYou may change the user name, and the colour that the name should appear in.</p>\n<p>There are a couple of other example WebSocket servers:</p>\n<ul>\n<li><a href=\"http://localhost:8000/echo/\" rel=\"nofollow\">http://localhost:8000/echo/</a> - Repeats back to you whatever you send to it.</li>\n<li><a href=\"http://localhost:8000/ping/\" rel=\"nofollow\">http://localhost:8000/ping/</a> - Respond with \u2018pong\u2019 if you send \u2018ping\u2019, and vice versa. Otherwise, don\u2019t respond at all.</li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Install from PyPI using:</p>\n<pre>$ pip install django-gevent-websocket\n</pre>\n<p>It will install it\u2019s various dependencies:</p>\n<ul>\n<li>django</li>\n<li>gevent-websocket</li>\n<li>gunicorn</li>\n</ul>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<div id=\"settings\">\n<h3>Settings</h3>\n<p>Add the following to your <tt>$PROJECT_DIR/wsgi.py</tt>:</p>\n<pre>from django_websocket.wsgi import get_wsgi_websocket_application\nwebsocket = get_wsgi_websocket_application()\n</pre>\n<p>Add the following to your <tt>$PROJECT_DIR/settings.py</tt>:</p>\n<pre>WEBSOCKET_URLCONF = '&lt;path-to-websocket-urlconf&gt;'\n</pre>\n<p>A suggested urlconf would be <tt>$PROJECT_DIR/websocket_urls.py</tt>.</p>\n<p>You then need to add your WebSocket urls to that file: they will be very similar to your normal urls, but will only contain the endpoints that should accept a WebSocket connection:</p>\n<pre>from django.conf.urls import patterns, url\n\nurlpatterns = patterns('',\n    url(r'^chat/$', 'path.to.view', name='chat'),\n)\n</pre>\n<p>If you want to use <tt>{% websocket_url %}</tt> to get absolute urls that point to the correct WebSocket server and port, then you\u2019ll need to set</p>\n</div>\n<div id=\"views\">\n<h3>Views</h3>\n<p>A WebSocket view function looks very much like a normal django view function, indeed, it is called by the regular django request cycle, but it does not return an HttpResponse object. Instead, you grab the websocket object from the request, and <tt>.receive()</tt> data from it, or <tt>.send(data)</tt> to it.</p>\n<p>To make things easier, you can use the decorators to wrap your views:</p>\n<pre>from django_websocket.decorators import websocket\n\n@websocket\ndef view_function(request, websocket, *args, **kwargs):\n    # do stuff here.\n</pre>\n<p>This decorator adds the websocket as the second argument to your view: you still have the request object, allowing you to do things like permissions checking. You can still use any of the regular django decorators if you wish.</p>\n<div id=\"asynchronicity-in-views\">\n<h4>Asynchronicity in views</h4>\n<p>A WebSocket view should listen for incoming data from the client that needs to be processed, but will probably also want to be listening for data coming from another source, that will be sent back to the client.</p>\n<p>A simple way to do this is to use the <cite>select.select</cite> function, and use this to write non-blocking code that waits for a signal to proceed. Typically, you\u2019ll want to loop until the websocket is closed, and then wait for a signal:</p>\n<pre>from select import select\n\nfrom django_websocket.decorators import websocket\n\n@websocket\ndef view_function(request, websocket):\n    ws_sock = websocket.handler.socket.fileno()\n    other_sock = ... # other socket to listen on.\n\n    while not websocket.closed():\n        fd = select([ws_sock, other_sock], [], [])[0][0]\n\n        if fd == ws_sock:\n            data = websocket.receive()\n            # Deal with incoming data.\n        else: ## fd == other_sock:\n            # Deal with data from the other source\n            websocket.send(message)\n</pre>\n<p>A good \u2018other\u2019 source might be a Redis PubSub subscription, which allows you to subscribe to channels, and will notify you when new data is available on any of these.</p>\n<p>From <tt>django_websocket.servers.chat</tt>:</p>\n<pre>from select import select\n\nimport redis\n\nfrom ..decorators import websocket\n\n@websocket\ndef chat(request, websocket, *args, **kwargs):\n\n    conn = redis.StrictRedis()\n    subs = conn.pubsub()\n    subs.subscribe('CHAT')\n\n    def incoming():\n        data = websocket.receive()\n        if data:\n            conn.publish('CHAT', data)\n\n    def outgoing():\n        msg_type, channel, message = subs.parse_response()\n        if msg_type == 'message':\n            websocket.send(message)\n\n    sockets = {\n        websocket.handler.socket.fileno(): incoming,\n        subs.connection._sock.fileno(): outgoing\n    }\n\n    while not websocket.closed:\n        fd = select(sockets.keys(), [], [])[0][0]\n        sockets[fd]()\n</pre>\n</div>\n</div>\n<div id=\"template-tag\">\n<h3>Template Tag</h3>\n<p>Because you should have a different urlconf for your WebSocket views, you will need to use a slightly different template tag to get access to the WebSocket urls:</p>\n<pre>{% load websockets %}\n\n&lt;script&gt;\n  var ws = new WebSocket(\"{% websocket_url 'urlname' %}\");\n\n  // Do something with your shiny new WebSocket!\n  // ws.send('foo');\n&lt;/script&gt;\n</pre>\n</div>\n<div id=\"starting-the-server\">\n<h3>Starting the Server</h3>\n<p>You will need to start the <tt>geventwebsocket</tt> server seperately: there is no django management command (which mirrors the deprecation of run_gunicorn):</p>\n<pre>gunicorn -k \"geventwebsocket.gunicorn.workers.GeventWebSocketWorker\" $PROJECT_DIR.wsgi:websocket -b 127.0.0.1:8001\n</pre>\n<p>Note this runs on a different port than your django development server (or gunicorn in production). In production you will probably stick both of them behind an nginx proxy or similar. If you want to do this, you may have to do some tricky to get the splitting out of the websocket connections to work. I did something like:</p>\n<pre>server {\n  listen  80;\n  proxy_set_header Host $host;\n\n  location /static/ {\n    alias ...\n  }\n\n  if ($http_upgrade) {\n    rewrite ^(.*)$ /__ws__/$1 break;\n  }\n\n  location /__ws__/ {\n    proxy_pass http://127.0.0.1:8001;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"upgrade\";\n    rewrite ^/__ws__/(.*)$ $1 break;\n    return;\n  }\n\n  location / {\n    proxy_pass http://127.0.0.1:8000;\n  }\n}\n</pre>\n<p>Notice the double rewrite. It rewrites the url when the Upgrade header is present, and then rewrites it back, so that the url matches within django.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3870535, "releases": {"0.0.1": [], "0.0.2": [{"comment_text": "", "digests": {"md5": "693615edaf9360edc1544fcf6647766e", "sha256": "7be027838825eb8a7bbbb8bebbc43e36f2ae83ec0a897c1ab35e456efaf19c5a"}, "downloads": -1, "filename": "django-gevent-websocket-0.0.2.tar.gz", "has_sig": false, "md5_digest": "693615edaf9360edc1544fcf6647766e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5832, "upload_time": "2018-05-17T00:01:36", "upload_time_iso_8601": "2018-05-17T00:01:36.354862Z", "url": "https://files.pythonhosted.org/packages/3f/e8/5fd92f458a39ee2b92d34940416e9840319c30d296303064fff91f846679/django-gevent-websocket-0.0.2.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "0fa4d80a42606742982f88fdc5b449f8", "sha256": "963117664518297608bf301dc1229c584c479b51e8b24e6771475119bd4c6946"}, "downloads": -1, "filename": "django-gevent-websocket-0.1.0.tar.gz", "has_sig": false, "md5_digest": "0fa4d80a42606742982f88fdc5b449f8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5867, "upload_time": "2014-07-25T02:58:18", "upload_time_iso_8601": "2014-07-25T02:58:18.662509Z", "url": "https://files.pythonhosted.org/packages/82/af/05d4ea8f81f36083630af6f462d86cbf266fcf9ea866badf790f6f733c36/django-gevent-websocket-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0fa4d80a42606742982f88fdc5b449f8", "sha256": "963117664518297608bf301dc1229c584c479b51e8b24e6771475119bd4c6946"}, "downloads": -1, "filename": "django-gevent-websocket-0.1.0.tar.gz", "has_sig": false, "md5_digest": "0fa4d80a42606742982f88fdc5b449f8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5867, "upload_time": "2014-07-25T02:58:18", "upload_time_iso_8601": "2014-07-25T02:58:18.662509Z", "url": "https://files.pythonhosted.org/packages/82/af/05d4ea8f81f36083630af6f462d86cbf266fcf9ea866badf790f6f733c36/django-gevent-websocket-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:35:52 2020"}