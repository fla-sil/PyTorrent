{"info": {"author": "Charlie Liban", "author_email": "charlie@tyrannosaur.ca", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python"], "description": "keypool\r\n=======\r\n\r\n``keypool`` is a library to generate and maintain a pool of unique\r\ninteger keys. Priority is given to reusing freed keys rather than\r\ngenerating new ones.\r\n\r\nThis package is meant for situations where keys for a dict are\r\nirrelevant or arbitrary.\r\n\r\nInstallation\r\n------------\r\n\r\nPython\r\n~~~~~~\r\n\r\nOnly Python 2.6+ is required!\r\n\r\n-  Install with pip: ``pip install keypool``\r\n-  Clone and install: ``python python/setup.py install``\r\n\r\nIf you want to run the tests, ensure ``nose`` is installed with\r\n``pip install nose``.\r\n\r\nJavaScript\r\n~~~~~~~~~~\r\n\r\nThe JavaScript version requires no dependencies or special interpreters.\r\n\r\nThe basics\r\n----------\r\n\r\nPython\r\n~~~~~~\r\n\r\n::\r\n\r\n          from keypool import KeypoolDict\r\n          items = KeypoolDict()\r\n\r\n          # Assign a value with a unique, generated key\r\n          items[items.next()] = 'hello, world'\r\n\r\n          # Assign a value but capture the key\r\n          key = items.setitem('hello again, world')\r\n\r\n          # Assign anything except an integer, like a normal dict\r\n          items['hello'] = 'world'\r\n\r\nWhen an item is deleted, its key is freed for reuse:\r\n\r\n::\r\n\r\n          from keypool import KeypoolDict\r\n          items = KeypoolDict()\r\n\r\n          # Add some items\r\n          keys = [items.setitem(word) for word in ['aardvark', 'baboon', 'crocodile']]\r\n\r\n          # [0, 1, 2]\r\n          print(keys)\r\n\r\n          # Delete 0\r\n          del items[keys[0]]\r\n\r\n          # Add a new item\r\n          key = items.setitem('dragonfly')\r\n\r\n          # 0 (as opposed to 3)\r\n          print(key)             \r\n\r\nJavaScript\r\n~~~~~~~~~~\r\n\r\n::\r\n\r\n         var items = keyPool();\r\n         \r\n         // Assign a value with a unique integer.\r\n         // The key is immediately generated, unlike in Python\r\n         items[items.newKey()] = 'hello, world';\r\n         \r\n         // Assign a value but capture the key\r\n         var key = items.set('hello again, world');\r\n         \r\n         // Assign anything except an integer to the internal object\r\n         items['hello'] = 'world';\r\n              \r\n         items.del(key);      // key 1 is removed and the next free key will be 1\r\n         items.del('hello');  // a key outside the pool is removed\r\n\r\nExamples\r\n--------\r\n\r\nLet\u2019s say you\u2019re wrapping a timer function in some horrible API:\r\n\r\n::\r\n\r\n          def timer(unique_name, **kwargs):\r\n                ...\r\n\r\nand each active timer needs to be stored for efficient lookup (i.e. a\r\n``dict``). Usually a timestamp or uuid will suffice for this type of\r\nproblem:\r\n\r\n::\r\n\r\n          import time\r\n          \r\n          timers = {}\r\n          \r\n          def create_timer(**kwargs):                  \r\n                key = str(time.time())\r\n                timers[key] = timer(unique_name=key, **kwargs)\r\n                return key\r\n\r\n          keys = [create_timer(...) for i in xrange(0, 10)]\r\n\r\nOops, the loop is iterating faster than ``time.time``\\ \u2019s precision and\r\nthus all keys are identical:\r\n\r\n::\r\n\r\n          # [1310422700.9400001, 1310422700.9400001, 1310422700.9400001, \r\n          #  1310422700.9400001, 1310422700.9400001, 1310422700.9400001, \r\n          #  1310422700.9400001, 1310422700.9400001, 1310422700.9400001, \r\n          #  1310422700.9400001]\r\n          print(keys)\r\n          \r\n          assert not all([keys[0] == key for key in keys])        \r\n\r\nA ``KeypoolDict`` solves this problem in a cleaner fashion with unique\r\ninteger keys:\r\n\r\n::\r\n\r\n          from keypool import KeypoolDict\r\n          from operator import delitem\r\n          \r\n          timers = KeypoolDict()\r\n          \r\n          def create_timer(**kwargs):\r\n                key = timers.next()\r\n                timers[key] = timer(unique_name=key, **kwargs)\r\n                return key\r\n          \r\n          keys = [create_timer(...) for i in xrange(0, 10)]\r\n\r\nNo keys are identical now!\r\n\r\n::\r\n\r\n          # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n          print(keys)      \r\n          \r\n          assert all([x == y for x,y in zip(sorted(set(keys)), sorted(keys))])\r\n\r\nKeys are also reused when deleted, so arbitrarily increasing values are\r\nmostly avoided:\r\n\r\n::\r\n\r\n          # Delete all the items\r\n          [delitem(timers, key) for key in timers.keys()]\r\n          \r\n          # The old keys are now reused      \r\n          keys = [create_timer(...) for i in xrange(0, 10)]\r\n          \r\n          # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n          print(keys)", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/tyrannosaur/keypool/zipball/master", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tyrannosaur/keypool", "keywords": "data structures", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "keypool", "package_url": "https://pypi.org/project/keypool/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/keypool/", "project_urls": {"Download": "https://github.com/tyrannosaur/keypool/zipball/master", "Homepage": "https://github.com/tyrannosaur/keypool"}, "release_url": "https://pypi.org/project/keypool/0.1/", "requires_dist": null, "requires_python": null, "summary": "Generate and maintain a pool of unique integer keys.", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><tt>keypool</tt> is a library to generate and maintain a pool of unique\ninteger keys. Priority is given to reusing freed keys rather than\ngenerating new ones.</p>\n<p>This package is meant for situations where keys for a dict are\nirrelevant or arbitrary.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<div id=\"python\">\n<h3>Python</h3>\n<p>Only Python 2.6+ is required!</p>\n<ul>\n<li>Install with pip: <tt>pip install keypool</tt></li>\n<li>Clone and install: <tt>python python/setup.py install</tt></li>\n</ul>\n<p>If you want to run the tests, ensure <tt>nose</tt> is installed with\n<tt>pip install nose</tt>.</p>\n</div>\n<div id=\"javascript\">\n<h3>JavaScript</h3>\n<p>The JavaScript version requires no dependencies or special interpreters.</p>\n</div>\n</div>\n<div id=\"the-basics\">\n<h2>The basics</h2>\n<div id=\"id1\">\n<h3>Python</h3>\n<pre>from keypool import KeypoolDict\nitems = KeypoolDict()\n\n# Assign a value with a unique, generated key\nitems[items.next()] = 'hello, world'\n\n# Assign a value but capture the key\nkey = items.setitem('hello again, world')\n\n# Assign anything except an integer, like a normal dict\nitems['hello'] = 'world'\n</pre>\n<p>When an item is deleted, its key is freed for reuse:</p>\n<pre>from keypool import KeypoolDict\nitems = KeypoolDict()\n\n# Add some items\nkeys = [items.setitem(word) for word in ['aardvark', 'baboon', 'crocodile']]\n\n# [0, 1, 2]\nprint(keys)\n\n# Delete 0\ndel items[keys[0]]\n\n# Add a new item\nkey = items.setitem('dragonfly')\n\n# 0 (as opposed to 3)\nprint(key)\n</pre>\n</div>\n<div id=\"id2\">\n<h3>JavaScript</h3>\n<pre>var items = keyPool();\n\n// Assign a value with a unique integer.\n// The key is immediately generated, unlike in Python\nitems[items.newKey()] = 'hello, world';\n\n// Assign a value but capture the key\nvar key = items.set('hello again, world');\n\n// Assign anything except an integer to the internal object\nitems['hello'] = 'world';\n\nitems.del(key);      // key 1 is removed and the next free key will be 1\nitems.del('hello');  // a key outside the pool is removed\n</pre>\n</div>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>Let\u2019s say you\u2019re wrapping a timer function in some horrible API:</p>\n<pre>def timer(unique_name, **kwargs):\n      ...\n</pre>\n<p>and each active timer needs to be stored for efficient lookup (i.e. a\n<tt>dict</tt>). Usually a timestamp or uuid will suffice for this type of\nproblem:</p>\n<pre>import time\n\ntimers = {}\n\ndef create_timer(**kwargs):\n      key = str(time.time())\n      timers[key] = timer(unique_name=key, **kwargs)\n      return key\n\nkeys = [create_timer(...) for i in xrange(0, 10)]\n</pre>\n<p>Oops, the loop is iterating faster than <tt>time.time</tt>\u2019s precision and\nthus all keys are identical:</p>\n<pre># [1310422700.9400001, 1310422700.9400001, 1310422700.9400001,\n#  1310422700.9400001, 1310422700.9400001, 1310422700.9400001,\n#  1310422700.9400001, 1310422700.9400001, 1310422700.9400001,\n#  1310422700.9400001]\nprint(keys)\n\nassert not all([keys[0] == key for key in keys])\n</pre>\n<p>A <tt>KeypoolDict</tt> solves this problem in a cleaner fashion with unique\ninteger keys:</p>\n<pre>from keypool import KeypoolDict\nfrom operator import delitem\n\ntimers = KeypoolDict()\n\ndef create_timer(**kwargs):\n      key = timers.next()\n      timers[key] = timer(unique_name=key, **kwargs)\n      return key\n\nkeys = [create_timer(...) for i in xrange(0, 10)]\n</pre>\n<p>No keys are identical now!</p>\n<pre># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(keys)\n\nassert all([x == y for x,y in zip(sorted(set(keys)), sorted(keys))])\n</pre>\n<p>Keys are also reused when deleted, so arbitrarily increasing values are\nmostly avoided:</p>\n<pre># Delete all the items\n[delitem(timers, key) for key in timers.keys()]\n\n# The old keys are now reused\nkeys = [create_timer(...) for i in xrange(0, 10)]\n\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(keys)\n</pre>\n</div>\n\n          </div>"}, "last_serial": 793926, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "b9f45f37c06853d43eade038815a102d", "sha256": "03097d4919c44043a6f2f94dc98bc67062aa5501a8b2ba5bd8c7286b2284a198"}, "downloads": -1, "filename": "keypool-0.1.tar.gz", "has_sig": false, "md5_digest": "b9f45f37c06853d43eade038815a102d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3538, "upload_time": "2012-06-12T21:47:11", "upload_time_iso_8601": "2012-06-12T21:47:11.489695Z", "url": "https://files.pythonhosted.org/packages/81/01/c03870995cbcb7701be0c2a8dc7397f3de44238d98e2ba7170bad2db7cec/keypool-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b9f45f37c06853d43eade038815a102d", "sha256": "03097d4919c44043a6f2f94dc98bc67062aa5501a8b2ba5bd8c7286b2284a198"}, "downloads": -1, "filename": "keypool-0.1.tar.gz", "has_sig": false, "md5_digest": "b9f45f37c06853d43eade038815a102d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3538, "upload_time": "2012-06-12T21:47:11", "upload_time_iso_8601": "2012-06-12T21:47:11.489695Z", "url": "https://files.pythonhosted.org/packages/81/01/c03870995cbcb7701be0c2a8dc7397f3de44238d98e2ba7170bad2db7cec/keypool-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:49:57 2020"}