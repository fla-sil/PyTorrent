{"info": {"author": "Michele Cappellari", "author_email": "michele.cappellari@physics.ox.ac.uk", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "**pPXF: Full Spectrum Fitting of Galactic and Stellar Spectra**\n\n.. image:: http://www-astro.physics.ox.ac.uk/~mxc/software/ppxf_logo.png\n.. image:: https://img.shields.io/pypi/v/ppxf.svg\n    :target: https://pypi.org/project/ppxf/\n.. image:: https://img.shields.io/badge/arXiv-1607.08538-orange.svg\n    :target: https://arxiv.org/abs/1607.08538\n.. image:: https://img.shields.io/badge/DOI-10.1093/mnras/stw3020-green.svg\n        :target: https://doi.org/10.1093/mnras/stw3020\n\nThis ``pPXF`` package contains a Python implementation of the Penalized\nPiXel-Fitting (``pPXF``) method to fit the stellar and gas kinematics,\nas well as the stellar population of galaxies. The method was originally\ndescribed in `Cappellari & Emsellem (2004)\n<https://ui.adsabs.harvard.edu/abs/2004PASP..116..138C>`_\nand was substantially upgraded in subsequent years and particularly in \n`Cappellari (2017) <https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C>`_.\n\n.. contents:: :depth: 1\n\nAttribution\n-----------\n\nIf you use this software for your research, please cite at least\n`Cappellari (2017) <https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C>`_.\nThe BibTeX entry for the paper is::\n\n    @ARTICLE{Cappellari2017,\n        author = {{Cappellari}, M.},\n        title = \"{Improving the full spectrum fitting method:\n            accurate convolution with Gauss-Hermite functions}\",\n        journal = {MNRAS},\n        eprint = {1607.08538},\n        year = 2017,\n        volume = 466,\n        pages = {798-811},\n        doi = {10.1093/mnras/stw3020}\n    }\n\nInstallation\n------------\n\ninstall with::\n\n    pip install ppxf\n\nWithout write access to the global ``site-packages`` directory, use::\n\n    pip install --user ppxf\n\nUsage Examples\n--------------\n\nTo learn how to use the main program ``pPXF`` run the example programs in the\n``ppxf/examples`` directory, within the main package installation folder inside\n``site-packages``, and read the detailed documentation in the docstring of the\nfile ``ppxf.py``, on `PyPi <https://pypi.org/project/ppxf/>`_ or as PDF from\n`<https://purl.org/cappellari/software>`_.\n\n###########################################################################\n\npPXF Purpose\n------------\n\nExtract galaxy stellar kinematics ``(V, sigma, h3, h4, h5, h6,...)``\nor the stellar population and gas emission by fitting a template\nto an observed spectrum in pixel space, using the Penalized PiXel-Fitting\n(``pPXF``) method originally described in\n\n`Cappellari & Emsellem (2004) <https://ui.adsabs.harvard.edu/abs/2004PASP..116..138C>`_\n\nand substantially upgraded in subsequent years and particularly in\n\n`Cappellari (2017) <https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C>`_\n\nThe following key optional features are also available:\n\n1)  An optimal template, positive linear combination of different input\n    templates, can be fitted together with the kinematics.\n2)  One can enforce smoothness on the template weights during the fit. This\n    is useful to attach a physical meaning to the weights e.g. in terms of\n    the star formation history of a galaxy.\n3)  One can fit multiple kinematic components for both the stars and the gas\n    emission lines. Both the stellar and gas LOSVD can be penalized and can\n    be described by a general Gauss-Hermite series.\n4)  Any parameter of the LOSVD (e.g. sigma) for any kinematic component can\n    either be fitted, or held fixed to a given value, while other parameters\n    are fitted. Alternatively, parameters can be constrained to lie within\n    given limits or even tied by simple relations to other parameters.\n5)  One can enforce linear equality/inequality constraints on either the\n    template weights or the kinematic parameters.\n6)  Additive and/or multiplicative polynomials can be included to adjust the\n    continuum shape of the template to the observed spectrum.\n7)  Iterative sigma clipping can be used to clean the spectrum.\n8)  It is possible to fit a mirror-symmetric LOSVD to two spectra at the\n    same time. This is useful for spectra taken at point-symmetric spatial\n    positions with respect to the center of an equilibrium stellar system.\n9)  One can include sky spectra in the fit, to deal with cases where the sky\n    dominates the observed spectrum and an accurate sky subtraction is\n    critical.\n10) One can derive an estimate of the reddening in the spectrum. This can be\n    done independently for the stellar spectrum or the Balmer emission lines.\n11) The covariance matrix can be input instead of the error spectrum, to\n    account for correlated errors in the spectral pixels.\n12) One can specify the weights fraction between two kinematics components,\n    e.g. to model bulge and disk contributions.\n13) One can use templates with higher resolution than the galaxy, to\n    improve the accuracy of the LOSVD extraction at low dispersion.\n\n\nCalling Sequence\n----------------\n\n.. code-block:: python\n\n    from ppxf.ppxf import ppxf\n\n    pp = ppxf(self, templates, galaxy, noise, velscale, start,\n             bias=None, bounds=None, clean=False, component=0,\n             constr_templ={}, constr_kinem={}, degree=4, fixed=None,\n             fraction=None, ftol=1e-4, gas_component=None, gas_names=None,\n             gas_reddening=None, goodpixels=None, lam=None, linear=False,\n             linear_method = 'nnls', mask=None, method='capfit', mdegree=0,\n             moments=2, plot=False, quiet=False, reddening=None,\n             reddening_func=None, reg_dim=None, reg_ord=2, regul=0,\n             sigma_diff=0, sky=None, templates_rfft=None, tied=None,\n             trig=False, velscale_ratio=1, vsyst=0):\n\n    print(pp.sol)  # print best-fitting kinematics (V, sigma, h3, h4)\n    pp.plot()      # Plot best fit and gas lines\n\nInput Parameters\n----------------\n\ntemplates:\n    Vector containing the spectrum of a single template star or more\n    commonly an array of dimensions ``templates[nPixels, nTemplates]``\n    containing different templates to be optimized during the fit of the\n    kinematics. It has to be ``nPixels >= galaxy.size``.\n\n    To apply linear regularization to the ``weights`` via the keyword\n    ``regul``, ``templates`` should be an array of two\n    ``templates[nPixels, nAge]``, three ``templates[nPixels, nAge, nMetal]``\n    or four ``templates[nPixels, nAge, nMetal, nAlpha]`` dimensions,\n    depending on the number of population variables one wants to study.\n    This can be useful to try to attach a physical meaning to the output\n    ``weights``, in term of the galaxy star formation history and chemical\n    composition distribution.\n    In that case the templates may represent single stellar population SSP\n    models and should be arranged in sequence of increasing age,\n    metallicity or alpha along the second, third or fourth dimension of the\n    array respectively.\ngalaxy:\n    Vector containing the spectrum of the galaxy to be measured. The\n    star and the galaxy spectra have to be logarithmically rebinned but the\n    continuum should *not* be subtracted. The rebinning may be performed\n    with the ``log_rebin`` routine in ``ppxf.ppxf_util``.\n\n    For high redshift galaxies, one should bring the spectra close to the\n    restframe wavelength, before doing the ``pPXF`` fit. This can be done\n    by dividing the observed wavelength by ``(1 + z)``, where ``z`` is a\n    rough estimate of the galaxy redshift, before the logarithmic\n    rebinning. See Section 2.4 of `Cappellari (2017)`_ for details.\n\n    ``galaxy`` can also be an array of dimensions ``galaxy[nGalPixels, 2]``\n    containing two spectra to be fitted, at the same time, with a\n    reflection-symmetric LOSVD. This is useful for spectra taken at\n    point-symmetric spatial positions with respect to the center of an\n    equilibrium stellar system.\n    For a discussion of the usefulness of this two-sided fitting see e.g.\n    Section 3.6 of `Rix & White (1992)\n    <http://ui.adsabs.harvard.edu/abs/1992MNRAS.254..389R>`_.\n\n    IMPORTANT: (1) For the two-sided fitting the ``vsyst`` keyword has to\n    be used. (2) Make sure the spectra are rescaled to be not too many\n    order of magnitude different from unity, to avoid over or underflow\n    problems in the calculation. E.g. units of ``erg/(s cm^2 A)`` may cause\n    problems!\nnoise:\n    Vector containing the ``1*sigma`` uncertainty (per pixel) in the galaxy\n    spectrum, or covariance matrix describing the correlated uncertainties\n    in the galaxy spectrum. Of course this vector/matrix must have the same\n    units as the galaxy spectrum.\n\n    If ``galaxy`` is a ``Nx2`` array, ``noise`` has to be an array with the\n    same dimensions.\n\n    When ``noise`` has dimensions ``NxN`` it is assumed to contain the\n    covariance matrix with elements ``sigma(i, j)``. When the errors in the\n    spectrum are uncorrelated it is mathematically equivalent to input in\n    ``pPXF`` an error vector ``noise=errvec`` or a ``NxN`` diagonal matrix\n    ``noise=np.diag(errvec**2)`` (note squared!).\n\n    IMPORTANT: the penalty term of the ``pPXF`` method is based on the\n    *relative* change of the fit residuals. For this reason, the penalty\n    will work as expected even if no reliable estimate of the ``noise`` is\n    available (see `Cappellari & Emsellem (2004)`_ for details). If no\n    reliable noise is available this keyword can just be set to::\n\n        noise = np.ones_like(galaxy)  # Same weight for all pixels\n\nvelscale:\n    Velocity scale of the spectra in km/s per pixel. It has to be the\n    same for both the galaxy and the template spectra.\n    An exception is when the ``velscale_ratio`` keyword is used, in which\n    case one can input ``templates`` with smaller ``velscale`` than\n    ``galaxy``.\n\n    ``velscale`` is *defined* in ``pPXF`` by\n    ``velscale = c*Delta[np.log(lambda)]``, which is approximately\n    ``velscale ~ c*Delta(lambda)/lambda``.\n    See Section 2.3 of `Cappellari (2017)`_ for details.\nstart:\n    Vector, or list/array of vectors ``[start1, start2, ...]``, with the\n    initial estimate for the LOSVD parameters.\n\n    When LOSVD parameters are not held fixed, each vector only needs to\n    contain ``start = [velStart, sigmaStart]`` the initial guess for the\n    velocity and the velocity dispersion in km/s. The starting values for\n    h3-h6 (if they are fitted) are all set to zero by default.\n    In other words, when ``moments=4``::\n\n        start = [velStart, sigmaStart]\n\n    is interpreted as::\n\n        start = [velStart, sigmaStart, 0, 0]\n\n    When the LOSVD for some kinematic components is held fixed (see\n    ``fixed`` keyword), all values for ``[Vel, Sigma, h3, h4,...]`` can be\n    provided.\n\n    Unless a good initial guess is available, it is recommended to set the\n    starting ``sigma >= 3*velscale`` in km/s (i.e. 3 pixels). In fact when\n    the sigma is very low, and far from the true solution, the ``chi^2`` of\n    the fit becomes weakly sensitive to small variations in sigma (see\n    ``pPXF`` paper). In some instances, the near-constancy of ``chi^2`` may\n    cause premature convergence of the optimization.\n\n    In the case of two-sided fitting a good starting value for the velocity\n    is ``velStart = 0.0`` (in this case ``vsyst`` will generally be\n    nonzero). Alternatively on should keep in mind that velStart refers to\n    the first input galaxy spectrum, while the second will have velocity\n    ``-velStart``.\n\n    With multiple kinematic components ``start`` must be a list of starting\n    values, one for each different component.\n\n    EXAMPLE: We want to fit two kinematic components. We fit 4 moments for\n    the first component and 2 moments for the second one as follows::\n\n        component = [0, 0, ... 0, 1, 1, ... 1]\n        moments = [4, 2]\n        start = [[V1, sigma1], [V2, sigma2]]\n\nOptional Keywords\n-----------------\n\nbias:\n    This parameter biases the ``(h3, h4, ...)`` measurements towards zero\n    (Gaussian LOSVD) unless their inclusion significantly decreases the\n    error in the fit. Set this to ``bias=0`` not to bias the fit: the\n    solution (including ``[V, sigma]``) will be noisier in that case. The\n    default ``bias`` should provide acceptable results in most cases, but\n    it would be safe to test it with Monte Carlo simulations. This keyword\n    precisely corresponds to the parameter ``lambda`` in the\n    `Cappellari & Emsellem (2004)`_ paper.\n    Note that the penalty depends on the *relative* change of the fit\n    residuals, so it is insensitive to proper scaling of the ``noise``\n    vector. A nonzero ``bias`` can be safely used even without a reliable\n    ``noise`` spectrum, or with equal weighting for all pixels.\nbounds:\n    Lower and upper bounds for every kinematic parameter. This is an array,\n    or list of arrays, with the same dimensions as ``start``, except for\n    the last dimension, which is 2. In practice, for every element of\n    ``start`` one needs to specify a pair of values ``[lower, upper]``.\n\n    EXAMPLE: We want to fit two kinematic components, with 4 moments for\n    the first component and 2 for the second (e.g. stars and gas). In this\n    case::\n\n        moments = [4, 2]\n        start_stars = [V1, sigma1, 0, 0]\n        start_gas = [V2, sigma2]\n        start = [start_stars, start_gas]\n\n    then we can specify boundaries for each kinematic parameter as::\n\n        bounds_stars = [[V1_lo, V1_up], [sigma1_lo, sigma1_up],\n                        [-0.3, 0.3], [-0.3, 0.3]]\n        bounds_gas = [[V2_lo, V2_up], [sigma2_lo, sigma2_up]]\n        bounds = [bounds_stars, bounds_gas]\n\ncomponent:\n    When fitting more than one kinematic component, this keyword should\n    contain the component number of each input template. In principle every\n    template can belong to a different kinematic component.\n\n    EXAMPLE: We want to fit the first 50 templates to component 0 and the\n    last 10 templates to component 1. In this case::\n\n        component = [0]*50 + [1]*10\n\n    which, in Python syntax, is equivalent to::\n\n        component = [0, 0, ... 0, 1, 1, ... 1]\n\n    This keyword is especially useful when fitting both emissions (gas) and\n    absorption (stars) templates simultaneously (see the example for\n    ``moments`` keyword).\nconstr_templ:\n    It enforces linear constraints on the template weights during the fit.\n    This is specified by the following dictionary, where ``A_ineq`` and\n    ``A_eq`` are arrays (have ``A.ndim = 2``), while ``b_ineq`` and ``b_eq``\n    are vectors (have ``b.ndim = 1``). Either the ``_eq`` or the ``_ineq``\n    keys can be omitted if not needed::\n\n        constr_templ = {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq, \"A_eq\": A_eq, \"b_eq\": b_eq}\n\n    The resulting pPXF solution will satisfy the following linear matrix\n    inequalities and/or equalities::\n\n        A_ineq @ pp.weights <= b_ineq\n        A_eq @ pp.weights == b_eq\n\n    Inequality can be used e.g. to constrain the fluxes of emission lines to\n    lie within prescribed ranges.\n    Equalities can be used e.g. to force the weights for different kinematic\n    components to contain prescribed fractions of the total weights.\n\n    EXAMPLES: We are fitting a spectrum using four templates, the first two\n    templates belong to one kinematic component and the rest to the other.\n    This implies we have::\n\n        component=[0, 0, 1, 1]\n\n    then we can set the constraint that the sum of the weights of the first\n    kinematic component is equal to ``fraction`` times the total as follows\n    [cfr. equation 30 of `Cappellari (2017)`_]::\n\n        A_eq = [[fraction - 1, fraction - 1, fraction, fraction]]\n        b_eq = [0]\n        constr_templ = {\"A_eq\": A_eq, \"b_eq\": b_eq}\n\n    An identical result can be obtained in this case using the ``fraction``\n    keyword, but ``constr_templ`` additionally allows for general linear\n    constraints for multiple kinematic components.\n\n    We can constrain the ratio of the first two templates weights to lie in\n    the interval ``ratio_min <= w[0]/w[1] <= ratio_max`` as follows::\n\n        A_ineq = [[-1, ratio_min, 0, 0],    # -w[0] + ratio_min*w[1] <= 0\n                  [1, -ratio_max, 0, 0]]    # +w[0] - ratio_max*w[1] <= 0\n        b_ineq = [0, 0]\n        constr_templ = {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq}\n\nconstr_kinem:\n    It enforces linear constraints on the kinematic parameters during the fit.\n    This is specified by the following dictionary, where ``A_ineq`` and\n    ``A_eq`` are arrays (have ``A.ndim = 2``), while ``b_ineq`` and ``b_eq``\n    are vectors (have ``b.ndim = 1``). Either the ``_eq`` or the ``_ineq``\n    keys can be omitted if not needed::\n\n        constr_kinem = {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq, \"A_eq\": A_eq, \"b_eq\": b_eq}\n\n    The resulting pPXF kinematics solution will satisfy the following linear\n    matrix inequalities and/or equalities::\n\n        params = np.ravel(pp.sol)  # Unravel for multiple components\n        A_ineq @ params <= b_ineq\n        A_eq @ params == b_eq\n\n    IMPORTANT: the starting guess ``start`` must satisfy the constraints,\n    or in other words, it must lie in the feasible region.\n\n    Inequalities can be used e.g. to force one kinematic component to have\n    larger velocity or dispersion than another one. This is useful e.g. when\n    extracting two stellar kinematic components or when fitting both narrow\n    and broad components of gas emission lines.\n\n    EXAMPLES: We want to fit two kinematic components, with two moments for\n    both the first and second component. In this case::\n\n        moments = [2, 2]\n        start = [[V1, sigma1], [V2, sigma2]]\n\n    then we can set the constraint ``sigma1 >= 3*sigma2`` as follows::\n\n        A_ineq = [[0, -1, 0, 3]]  # -sigma1 + 3*sigma2 <= 0\n        b_ineq = [0]\n        constr_kinem = {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq}\n\n    We can set the constraint ``sigma1 >= sigma2 + 2*velscale`` as follows::\n\n        A_ineq = [[0, -1, 0, 1]]  # -sigma1 + sigma2 <= -2*velscale\n        b_ineq = [-2]             # kinem. in pixels (-2 --> -2*velscale)!\n        constr_kinem =  {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq}\n\n    We can set both the constraints ``V1 >= V2`` and\n    ``sigma1 >= sigma2 + 2*velscale`` as follows::\n\n        A_ineq = [[-1, 0, 1, 0],   # -V1 + V2 <= 0\n                  [0, -1, 0, 1]]   # -sigma1 + sigma2 <= -2*velscale\n        b_ineq = [0, -2]           # kinem. in pixels (-2 --> -2*velscale)!\n        constr_kinem =  {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq}\n\nclean:\n    Set this keyword to use the iterative sigma clipping method described\n    in Section 2.1 of `Cappellari et al. (2002)\n    <http://ui.adsabs.harvard.edu/abs/2002ApJ...578..787C>`_.\n    This is useful to remove from the fit unmasked bad pixels, residual gas\n    emissions or cosmic rays.\n\n    IMPORTANT: This is recommended *only* if a reliable estimate of the\n    ``noise`` spectrum is available. See also note below for ``.chi2``.\ndegree:\n    Degree of the *additive* Legendre polynomial used to correct the\n    template continuum shape during the fit (default: 4).\n    Set ``degree=-1`` not to include any additive polynomial.\nfixed:\n    Boolean vector set to ``True`` where a given kinematic parameter has to\n    be held fixed with the value given in ``start``. This is an array, or\n    list, with the same dimensions as ``start``.\n\n    EXAMPLE: We want to fit two kinematic components, with 4 moments for\n    the first component and 2 for the second. In this case::\n\n        moments = [4, 2]\n        start = [[V1, sigma1, h3, h4], [V2, sigma2]]\n\n    then we can held fixed e.g. the sigma (only) of both components using::\n\n        fixed = [[0, 1, 0, 0], [0, 1]]\n\n    NOTE: Setting a negative ``moments`` for a kinematic component is\n    entirely equivalent to setting ``fixed = 1`` for all parameters of the\n    given kinematic component. In other words::\n\n        moments = [-4, 2]\n\n    is equivalent to::\n\n        moments = [4, 2]\n        fixed = [[1, 1, 1, 1], [0, 0]]\n\nfraction:\n    This keyword allows one to fix the ratio between the first two\n    kinematic components. This is a scalar defined as follows::\n\n        fraction = np.sum(weights[component == 0])\n                 / np.sum(weights[component < 2])\n\n    This is useful e.g. to try to kinematically decompose bulge and disk.\n\n    The remaining kinematic components (``component > 1``) are left free,\n    and this allows, for example, to still include gas emission line\n    components.\n    More general linear constraints, for multiple components at the same\n    time, can be specified using the ``constr_templ`` keyword.\nftol:\n    Fractional tolerance for stopping the non-linear minimization (default\n    1e-4).\ngas_component:\n    Boolean vector, of the same size as ``component``, set to ``True``\n    where the given ``component`` describes a gas emission line. If given,\n    ``pPXF`` provides the ``pp.gas_flux`` and ``pp.gas_flux_error`` in\n    output.\n\n    EXAMPLE: In the common situation where ``component = 0`` are stellar\n    templates and the rest are gas emission lines, one will set::\n\n        gas_component = component > 0\n\n    This keyword is also used to plot the gas lines with a different color.\ngas_names:\n    String array specifying the names of the emission lines (e.g.\n    ``gas_names=[\"Hbeta\", \"[OIII]\",...]``, one per gas line. The length of\n    this vector must match the number of nonzero elements in\n    ``gas_component``. This vector is only used by ``pPXF`` to print the\n    line names on the console.\ngas_reddening:\n    Set this keyword to an initial estimate of the gas reddening\n    ``E(B-V) >= 0`` to fit a positive gas reddening together with the\n    kinematics and the templates. This reddening is applied only to the gas\n    templates, namely to the templates with the corresponding element of\n    ``gas_component=True``. The fit assumes by default the extinction curve\n    of `Calzetti et al. (2000)\n    <http://ui.adsabs.harvard.edu/abs/2000ApJ...533..682C>`_ but any other\n    prescription can be passed via the ``reddening_func`` keyword.\ngoodpixels:\n    Integer vector containing the indices of the good pixels in the\n    ``galaxy`` spectrum (in increasing order). Only these spectral pixels\n    are included in the fit.\n\n    IMPORTANT: in all likely situations this keyword *has* to be specified.\nlam:\n    When the keyword ``reddening`` or ``gas_reddening`` are used, the user\n    has to pass in this keyword a vector with the same dimensions of\n    ``galaxy``, giving the restframe wavelength in Angstrom of every pixel\n    in the input galaxy spectrum. If one uses my ``log_rebin`` routine to\n    rebin the spectrum before the ``pPXF`` fit::\n\n        from ppxf.ppxf_util import log_rebin\n        specNew, logLam, velscale = log_rebin(lamRange, galaxy)\n\n    the wavelength can be obtained as ``lam = np.exp(logLam)``.\n\n    When ``lam`` is given, the wavelength is shown in the best-fitting\n    plot, instead of the pixels.\nlinear:\n    Set to ``True`` to keep *all* nonlinear parameters fixed and *only*\n    perform a linear fit for the templates and additive polynomials\n    weights. The output solution is a copy of the input one and the errors\n    are zero.\nlinear_method: {'nnls', 'lsqlin', 'cvxopt'} optional\n    Method used for the solution of the linear least-squares subproblem\n    to fit for the templates weights (default 'nnls').\n\n    The computational speed of the three alternative linear methods depends\n    on the size of the problem, with 'lsqlin' or 'cvxopt' generally being\n    faster with smaller problem and 'nnls' being faster for larger ones.\n    'cvxopt', if installed, is a good alternative to the lighter 'lsqlin'.\n    Testing is recomended in your specific setup.\n\n    The ``constr_templ`` and ``fraction`` keywords are only supported\n    with ``method='lsqlin'`` or ``method='cvxopt'``.\n\n    Before v7.0 ``pPXF`` only used the 'nnls' method.\nmask:\n    Boolean vector of length ``galaxy.size`` specifying with ``True`` the\n    pixels that should be included in the fit. This keyword is just an\n    alternative way of specifying the ``goodpixels``.\nmethod: {'capfit', 'trf', 'dogbox', 'lm'}, optional.\n    Algorithm to perform the non-linear minimization step.\n    The default ``'capfit'`` is a novel trust-region implementation of the\n    Levenberg-Marquardt method, extended to allow for general linear\n    constraints in a rigorous manner, while also supporting tied or fixed\n    variables. See documentation of ``scipy.optimize.least_squares`` for a\n    description of the other methods.\nmdegree:\n    Degree of the *multiplicative* Legendre polynomial (with a mean of 1)\n    used to correct the continuum shape during the fit (default: 0). The\n    zero degree multiplicative polynomial is always included in the fit as\n    it corresponds to the weights assigned to the templates. Note that the\n    computation time is longer with multiplicative polynomials than with\n    the same number of additive polynomials.\n\n    IMPORTANT: Multiplicative polynomials cannot be used when the\n    ``reddening`` keyword is set, as they are degenerate with the\n    reddening.\nmoments:\n    Order of the Gauss-Hermite moments to fit. Set this keyword to 4 to\n    fit ``[h3, h4]`` and to 6 to fit ``[h3, h4, h5, h6]``. Note that in all\n    cases the G-H moments are fitted (non-linearly) *together* with\n    ``[V, sigma]``.\n\n    If ``moments=2`` or ``moments`` is not set then only ``[V, sigma]`` are\n    fitted.\n\n    If ``moments`` is negative then the kinematics of the given\n    ``component`` are kept fixed to the input values.\n    NOTE: Setting a negative ``moments`` for a kinematic component is\n    entirely equivalent to setting ``fixed = 1`` for all parameters of the\n    given kinematic component.\n\n    EXAMPLE: We want to keep fixed ``component = 0``, which has a LOSVD\n    described by ``[V, sigma, h3, h4]`` and is modelled with 100 spectral\n    templates; At the same time, we fit ``[V, sigma]`` for \n    ``component = 1``, which is described by 5 templates (this situation\n    may arise when fitting stellar templates with pre-determined stellar\n    kinematics, while fitting the gas emission).\n    We should give in input to ``pPXF`` the following parameters::\n\n        component = [0]*100 + [1]*5   # --> [0, 0, ... 0, 1, 1, 1, 1, 1]\n        moments = [-4, 2]\n        start = [[V, sigma, h3, h4], [V, sigma]]\n\nplot:\n    Set this keyword to plot the best fitting solution and the residuals\n    at the end of the fit.\n\n    One can also call the class function ``pp.plot()`` after the call to\n    ``pp = ppxf(...)``.\nquiet:\n    Set this keyword to suppress verbose output of the best fitting\n    parameters at the end of the fit.\nreddening:\n    Set this keyword to an initial estimate of the stellar reddening\n    ``E(B-V) >= 0`` to fit a positive stellar reddening together with the\n    kinematics and the templates. This reddening is applied only to the\n    stellar templates, namely to the templates with the corresponding\n    element of ``gas_component=False``, or to all templates, if\n    ``gas_component`` is not set. The fit assumes by default the extinction\n    curve of `Calzetti et al. (2000)`_ but any other prescription can be\n    passed via the ``reddening_func`` keyword.\n\n    IMPORTANT: The ``mdegree`` keyword cannot be used when ``reddening`` is\n    set.\nregul:\n    If this keyword is nonzero, the program applies first or second order\n    linear regularization to the ``weights`` during the ``pPXF`` fit.\n    Regularization is done in one, two or three dimensions depending on\n    whether the array of ``templates`` has two, three or four dimensions\n    respectively.\n    Large ``regul`` values correspond to smoother ``weights`` output. When\n    this keyword is nonzero the solution will be a trade-off between the\n    smoothness of ``weights`` and goodness of fit.\n\n    Section 3.5 of `Cappellari (2017)`_ gives a description of\n    regularization.\n\n    When fitting multiple kinematic ``component`` the regularization is\n    applied only to the first ``component = 0``, while additional\n    components are not regularized. This is useful when fitting stellar\n    population together with gas emission lines. In that case, the SSP\n    spectral templates must be given first and the gas emission templates\n    are given last. In this situation, one has to use the ``reg_dim``\n    keyword (below), to give ``pPXF`` the dimensions of the population\n    parameters (e.g. ``nAge``, ``nMetal``, ``nAlpha``). A usage example is\n    given in the file ``ppxf_example_population_gas_sdss.py``.\n\n    The effect of the regularization scheme is the following:\n\n    * With ``reg_ord=1`` it enforces the numerical first derivatives\n      between neighbouring weights (in the 1-dim case) to be equal to\n      ``w[j] - w[j+1] = 0`` with an error ``Delta = 1/regul``.\n\n    * With ``reg_ord=2`` it enforces the numerical second derivatives\n      between neighboring weights (in the 1-dim case) to be equal to\n      ``w[j-1] - 2*w[j] + w[j+1] = 0`` with an error ``Delta = 1/regul``.\n\n    It may be helpful to define ``regul = 1/Delta`` and think of ``Delta``\n    as the regularization error.\n\n    IMPORTANT: ``Delta`` needs to be smaller but of the same order of\n    magnitude of the typical ``weights`` to play an effect on the\n    regularization. One quick way to achieve this is:\n\n    1. Divide the full ``templates`` array by a scalar in such a way that\n       the typical template has a median of one::\n\n            templates /= np.median(templates)\n\n    2. Do the same for the input galaxy spectrum::\n\n            galaxy /= np.median(galaxy)\n\n    3. In this situation, a sensible guess for ``Delta`` will be a few\n       percent (e.g. ``0.01 --> regul=100``).\n\n    Alternatively, for a more rigorous definition of the parameter\n    ``regul``:\n\n    A. Perform an un-regularized fit (``regul=0``) and then rescale the\n       input ``noise`` spectrum so that::\n\n            Chi^2/DOF = Chi^2/goodPixels.size = 1.\n\n       This is achieved by rescaling the input ``noise`` spectrum as::\n\n            noise = noise*sqrt(Chi**2/DOF) = noise*sqrt(pp.chi2);\n\n    B. Increase ``regul`` and iteratively redo the ``pPXF`` fit until the\n       ``Chi^2`` increases from the unregularized value\n       ``Chi^2 = goodPixels.size`` by\n       ``DeltaChi^2 = sqrt(2*goodPixels.size)``.\n\n    The derived regularization corresponds to the maximum one still\n    consistent with the observations and the derived star formation history\n    will be the smoothest (minimum curvature or minimum variation) that is\n    still consistent with the observations.\nreg_dim:\n    When using regularization with more than one kinematic component (using\n    the ``component`` keyword), the regularization is only applied to the\n    first one (``component=0``). This is useful to fit the stellar\n    population and gas emission together.\n\n    In this situation, one has to use the ``reg_dim`` keyword, to give\n    ``pPXF`` the dimensions of the population parameters (e.g. ``nAge``,\n    ``nMetal``, ``nAlpha``). One should creates the initial array of\n    population templates like e.g.\n    ``templates[nPixels, nAge, nMetal, nAlpha]`` and define::\n\n        reg_dim = templates.shape[1:]   # = [nAge, nMetal, nAlpha]\n\n    The array of stellar templates is then reshaped into a 2-dim array as::\n\n        templates = templates.reshape(templates.shape[0], -1)\n\n    and the gas emission templates are appended as extra columns at the\n    end. An usage example is given in\n    ``ppxf_example_population_gas_sdss.py``.\n\n    When using regularization with a single component (the ``component``\n    keyword is not used, or contains identical values), the number of\n    population templates along different dimensions (e.g. ``nAge``,\n    ``nMetal``, ``nAlpha``) is inferred from the dimensions of the\n    ``templates`` array and this keyword is not necessary.\nreg_ord:\n    Order of the derivative that is minimized by the regularization.\n    The following two rotationally-symmetric estimators are supported:\n\n    * ``reg_ord=1``: minimizes the integral over the weights of the squared\n      gradient::\n\n        Grad[w] @ Grad[w].\n\n    * ``reg_ord=2``: minimizes the integral over the weights of the squared\n      curvature::\n\n        Laplacian[w]**2.\n\nsigma_diff:\n    Quadratic difference in km/s defined as::\n\n        sigma_diff**2 = sigma_inst**2 - sigma_temp**2\n\n    between the instrumental dispersion of the galaxy spectrum and the\n    instrumental dispersion of the template spectra.\n\n    This keyword is useful when the templates have higher resolution than\n    the galaxy and they were not convolved to match the instrumental\n    dispersion of the galaxy spectrum. In this situation, the convolution\n    is done by ``pPXF`` with increased accuracy, using an analytic Fourier\n    Transform.\nsky:\n    vector containing the spectrum of the sky to be included in the fit, or\n    array of dimensions ``sky[nPixels, nSky]`` containing different sky\n    spectra to add to the model of the observed ``galaxy`` spectrum. The\n    ``sky`` has to be log-rebinned as the ``galaxy`` spectrum and needs to\n    have the same number of pixels.\n\n    The sky is generally subtracted from the data before the ``pPXF`` fit.\n    However, for observations very heavily dominated by the sky spectrum,\n    where a very accurate sky subtraction is critical, it may be useful\n    *not* to subtract the sky from the spectrum, but to include it in the\n    fit using this keyword.\ntemplates_rfft:\n    When calling ``pPXF`` many times with an identical set of templates,\n    one can use this keyword to pass the real FFT of the templates,\n    computed in a previous ``pPXF`` call, stored in the\n    ``pp.templates_rfft`` attribute. This keyword mainly exists to show\n    that there is no need for it...\n\n    IMPORTANT: Use this keyword only if you understand what you are doing!\ntied:\n    A list of string expressions. Each expression \"ties\" the parameter to\n    other free or fixed parameters.  Any expression involving constants and\n    the parameter array ``p[j]`` are permitted. Since they are totally\n    constrained, tied parameters are considered to be fixed; no errors are\n    computed for them.\n\n    This is an array, or list of arrays, with the same dimensions as\n    ``start``. In practice, for every element of ``start`` one needs to\n    specify either an empty string ``''`` implying that the parameter is\n    free, or a string expression involving some of the variables ``p[j]``,\n    where ``j`` represents the index of the flattened list of kinematic \n    parameters.\n\n    EXAMPLE: We want to fit three kinematic components, with 4 moments for\n    the first component and 2 moments for the second and third (e.g. stars\n    and two gas components). In this case::\n\n        moments = [4, 2, 2]\n        start = [[V1, sigma1, 0, 0], [V2, sigma2], [V3, sigma3]]\n\n    then we can force the equality constraint ``V2 = V3`` as follows::\n\n        tied = [['', '', '', ''], ['', ''], ['p[4]', '']]\n\n    or we can force the equality constraint ``sigma2 = sigma3`` as\n    follows::\n\n        tied = [['', '', '', ''], ['', ''], ['', 'p[5]']]\n\n    NOTE: One could in principle use the ``tied`` keyword to completely tie\n    the LOSVD of two kinematic components. However, this same effect is more\n    efficient achieved by assigning them to the same kinematic component\n    using the ``component`` keyword.\ntrig:\n    Set ``trig=True`` to use trigonometric series as an alternative to\n    Legendre polynomials, for both the additive and multiplicative\n    polynomials. When ``trig=True`` the fitted series below has\n    ``N = degree/2`` or ``N = mdegree/2``::\n\n        poly = A_0 + sum_{n=1}^{N} [A_n*cos(n*th) + B_n*sin(n*th)]\n\n    IMPORTANT: The trigonometric series has periodic boundary conditions.\n    This is sometimes a desirable property, but this expansion is not as\n    flexible as the Legendre polynomials.\nvelscale_ratio:\n    Integer. Gives the integer ``ratio >= 1`` between the ``velscale`` of\n    the ``galaxy`` and the ``templates``. When this keyword is used, the\n    templates are convolved by the LOSVD at their native resolution, and\n    only subsequently are integrated over the pixels and fitted to\n    ``galaxy``. This keyword is generally unnecessary and mostly useful for\n    testing.\n\n    Note that in realistic situations the uncertainty in the knowledge and\n    variations of the intrinsic line-spread function become the limiting\n    factor in recovering the LOSVD well below ``velscale``.\nvsyst:\n    Reference velocity in ``km/s`` (default 0). The input initial guess and\n    the output velocities are measured with respect to this velocity. This\n    keyword is generally used to account for the difference in the starting\n    wavelength of the templates and the galaxy spectrum as follows::\n\n        vsyst = c*np.log(wave_temp[0]/wave_gal[0])\n\n    The value assigned to this keyword is *crucial* for the two-sided\n    fitting. In this case ``vsyst`` can be determined from a previous\n    normal one-sided fit to the galaxy velocity profile. After that initial\n    fit, ``vsyst`` can be defined as the measured velocity at the galaxy\n    center. More accurately ``vsyst`` is the value which has to be\n    subtracted to obtain a nearly anti-symmetric velocity profile at the\n    two opposite sides of the galaxy nucleus.\n\n    IMPORTANT: this value is generally *different* from the systemic\n    velocity one can get from the literature. Do not try to use that!\n\nOutput Parameters\n-----------------\n\nStored as attributes of the ``pPXF`` class:\n\n.apoly:\n    Vector with the best fitting additive polynomial.\n.bestfit:\n    Vector with the best fitting model for the galaxy spectrum.\n    This is a linear combination of the templates, convolved with the best\n    fitting LOSVD, multiplied by the multiplicative polynomials and\n    with subsequently added polynomial continuum terms or sky components.\n.chi2:\n    The reduced ``chi^2`` (namely ``chi^2/DOF``) of the fit\n    (where ``DOF ~ pp.goodpixels.size``).\n\n    IMPORTANT: if ``Chi^2/DOF`` is not ~1 it means that the errors are not\n    properly estimated, or that the template is bad and it is *not* safe to\n    set the ``clean`` keyword.\n.error:\n    This variable contains a vector of *formal* uncertainty (``1*sigma``)\n    for the fitted parameters in the output vector ``sol``. This option can\n    be used when speed is essential, to obtain an order of magnitude\n    estimate of the uncertainties, but we *strongly* recommend to run\n    bootstrapping simulations to obtain more reliable errors. In fact these\n    errors can be severely underestimated in the region where the penalty\n    effect is most important (``sigma < 2*velscale``).\n\n    These errors are meaningless unless ``Chi^2/DOF ~ 1``. However if one\n    *assumes* that the fit is good, a corrected estimate of the errors is::\n\n        error_corr = error*sqrt(chi^2/DOF) = pp.error*sqrt(pp.chi2).\n\n    IMPORTANT: when running Monte Carlo simulations to determine the error,\n    the penalty (``bias``) should be set to zero, or better to a very small\n    value. See Section 3.4 of `Cappellari & Emsellem (2004)`_ for an\n    explanation.\n.gas_bestfit:\n    If ``gas_component`` is not ``None``, this attribute returns the\n    best-fitting gas spectrum alone. The stellar spectrum alone can be\n    computed as ``stellar_spectrum = pp.bestfit - pp.gas_bestfit``\n.gas_flux:\n    Vector with the integrated flux (in counts) of all lines set as\n    ``True`` in the input ``gas_component`` keyword. This is the flux of\n    individual gas templates, which may include multiple lines.\n    This implies that, if a gas template describes a doublet, the flux is\n    that of both lines. If the Balmer series is input as a single template,\n    this is the flux of the entire series.\n\n    The returned fluxes are not corrected in any way and in particular, no\n    reddening correction is applied. In other words, the returned\n    ``.gas_flux`` should be unchanged, within the errors, regardless of\n    whether reddening or multiplicative polynomials were fitted by ``pPXF``\n    or not. The fluxes are just raw values as one could measure (with lower\n    accuracy) by summing the pixels, within the given gas lines, on the\n    continuum-subtracted input galaxy spectrum.\n\n    IMPORTANT: ``pPXF`` makes no assumptions about the input flux units:\n    The returned ``.gas_flux`` has the same units as the quantity one would\n    obtain by just summing the values of the spectral pixels within the gas\n    emission. This implies that, if the spectrum is in units of \n    ``erg/(cm^2 s A)``, the gas flux returned by ``pPXF`` should be\n    multiplied by the pixel size in Angstrom at the line wavelength to\n    obtain the integrated line flux in units of ``erg/(cm^2 s)``.\n\n    NOTE: If there is no gas reddening and each input gas templates was\n    normalized to ``sum = 1``, then \n    ``pp.gas_flux = pp.weights[pp.gas_component]``.\n\n    When a gas template is identically zero within the fitted region, then\n    ``pp.gas_flux = pp.gas_flux_error = np.nan``. The corresponding\n    components of ``pp.gas_zero_template`` are set to ``True``. These\n    ``np.nan`` values are set at the end of the calculation to flag the\n    undefined values. They do *not* indicate numerical issues with the\n    actual ``pPXF`` calculation, and the rest of the ``pPXF`` output is\n    reliable.\n.gas_flux_error:\n    *Formal* uncertainty (``1*sigma``) for the quantity ``pp.gas_flux``, in\n    the same units as the gas fluxes.\n\n    This error is approximate as it ignores the covariance between the gas\n    flux and any non-linear parameter. Bootstrapping can be used for more\n    accurate errors.\n\n    These errors are meaningless unless ``Chi^2/DOF ~ 1``. However if one\n    *assumes* that the fit is good, a corrected estimate of the errors is::\n\n        gas_flux_error_corr = gas_flux_error*sqrt(chi^2/DOF)\n                            = pp.gas_flux_error*sqrt(pp.chi2).\n\n.gas_mpoly:\n    vector with the best-fitting gas reddening curve.\n.gas_reddening:\n    Best fitting ``E(B-V)`` value if the ``gas_reddening`` keyword is set.\n    This is especially useful when the Balmer series is input as a single\n    template with an assumed theoretically predicted decrement e.g. using\n    ``emission_lines(..., tie_balmer=True)`` in ``ppxf.ppxf_util`` to\n    compute the gas templates.\n.gas_zero_template:\n    vector of size ``gas_component.sum()`` set to ``True`` where\n    the gas template was identically zero within the fitted region.\n    For those gas components ``pp.gas_flux = pp.gas_flux_error = np.nan``.\n.goodpixels:\n    Integer vector containing the indices of the good pixels in the fit.\n    This vector is a copy of the input ``goodpixels`` if ``clean = False``\n    otherwise it will be updated by removing the detected outliers.\n.matrix:\n    Prediction ``matrix[nPixels, degree+nTemplates]`` of the linear system.\n\n    ``pp.matrix[nPixels, :degree]`` contains the additive polynomials if\n    ``degree >= 0``.\n\n    ``pp.matrix[nPixels, degree:]`` contains the templates convolved by the\n    LOSVD, and multiplied by the multiplicative polynomials if \n    ``mdegree > 0``.\n.mpoly:\n    Best fitting multiplicative polynomial (or reddening curve when\n    ``reddening`` is set).\n.mpolyweights:\n    This is largely superseded by the ``.mpoly`` attribute above.\n\n    When ``mdegree > 0`` this contains in output the coefficients of the\n    multiplicative Legendre polynomials of order ``1, 2,... mdegree``.\n    The polynomial can be explicitly evaluated as::\n\n        from numpy.polynomial import legendre\n        x = np.linspace(-1, 1, len(galaxy))\n        mpoly = legendre.legval(x, np.append(1, pp.mpolyweights))\n\n    When ``trig = True`` the polynomial is evaluated as::\n\n        mpoly = pp.trigval(x, np.append(1, pp.mpolyweights))\n\n.polyweights:\n    This is largely superseded by the ``.apoly`` attribute above.\n\n    When ``degree >= 0`` contains the weights of the additive Legendre\n    polynomials of order ``0, 1,... degree``. The best fitting additive\n    polynomial can be explicitly evaluated as::\n\n        from numpy.polynomial import legendre\n        x = np.linspace(-1, 1, len(galaxy))\n        apoly = legendre.legval(x, pp.polyweights)\n\n    When ``trig=True`` the polynomial is evaluated as::\n\n        apoly = pp.trigval(x, pp.polyweights)\n\n    When doing a two-sided fitting (see help for ``galaxy`` parameter), the\n    additive polynomials are allowed to be different for the left and right\n    spectrum. In that case, the output weights of the additive polynomials\n    alternate between the first (left) spectrum and the second (right)\n    spectrum.\n.reddening:\n    Best fitting ``E(B-V)`` value if the ``reddening`` keyword is set.\n.sol:\n    Vector containing in output the parameters of the kinematics.\n\n    * If ``moments=2`` this contains ``[Vel, Sigma]``\n    * If ``moments=4`` this contains ``[Vel, Sigma, h3, h4]``\n    * If ``moments=N`` this contains ``[Vel, Sigma, h3,... hN]``\n\n    When fitting multiple kinematic ``component``, ``pp.sol`` contains a\n    list with the solution for all different components, one after the\n    other, sorted by ``component``: ``pp.sol = [sol1, sol2,...]``.\n\n    ``Vel`` is the velocity, ``Sigma`` is the velocity dispersion, \n    ``h3 - h6`` are the Gauss-Hermite coefficients. The model parameters\n    are fitted simultaneously.\n\n    IMPORTANT: The precise relation between the output ``pPXF`` velocity\n    and redshift is ``Vel = c*np.log(1 + z)``. See Section 2.3 of\n    `Cappellari (2017)`_ for a detailed explanation.\n\n    These are the default safety limits on the fitting parameters\n    (they can be changed using the ``bounds`` keyword):\n\n    * Vel is constrained to be +/-2000 km/s from the first input guess\n    * ``velscale/100 < Sigma < 1000`` km/s\n    * ``-0.3 < [h3, h4, ...] < 0.3``  (extreme value for real galaxies)\n\n    In the case of two-sided LOSVD fitting the output values refer to the\n    first input galaxy spectrum, while the second spectrum will have by\n    construction kinematics parameters ``[-Vel, Sigma, -h3, h4, -h5, h6]``.\n    If ``vsyst`` is nonzero (as required for two-sided fitting), then the\n    output velocity is measured with respect to ``vsyst``.\n.status:\n    Contains the output status of the optimization. Positive values\n    generally represent success (the status is defined as in\n    ``scipy.optimize.least_squares``).\n.weights:\n    Receives the value of the weights by which each template was\n    multiplied to best fit the galaxy spectrum. The optimal template can be\n    computed with an array-vector multiplication::\n\n        bestemp = templates @ weights\n\n    These weights do not include the weights of the additive polynomials\n    which are separately stored in ``pp.polyweights``.\n\n    When the ``sky`` keyword is used ``weights[:nTemplates]`` contains the\n    weights for the templates, while ``weights[nTemplates:]`` gives the\n    ones for the sky. In that case the best fitting galaxy template and sky\n    are given by::\n\n        bestemp = templates @ weights[:nTemplates]\n        bestsky = sky @ weights[nTemplates:]\n\n    When doing a two-sided fitting (see help for ``galaxy`` parameter)\n    *together* with the ``sky`` keyword, the sky weights are allowed to be\n    different for the left and right spectrum. In that case the output sky\n    weights alternate between the first (left) spectrum and the second\n    (right) spectrum.\n\nHow to Set Regularization\n-------------------------\n\nThe ``pPXF`` routine can give sensible quick results with the default\n``bias`` parameter, however, like in any penalized/filtered/regularized\nmethod, the optimal amount of penalization generally depends on the problem\nunder study.\n\nThe general rule here is that the penalty should leave the line-of-sight\nvelocity-distribution (LOSVD) virtually unaffected, when it is well sampled\nand the signal-to-noise ratio (``S/N``) is sufficiently high.\n\nEXAMPLE: If you expect a LOSVD with up to a high ``h4 ~ 0.2`` and your\nadopted penalty (``bias``) biases the solution towards a much lower \n``h4 ~ 0.1``, even when the measured ``sigma > 3*velscale`` and the S/N is\nhigh, then you are *misusing* the ``pPXF`` method!\n\nTHE RECIPE: The following is a simple practical recipe for a sensible\ndetermination of the penalty in ``pPXF``:\n\n1. Choose a minimum ``(S/N)_min`` level for your kinematics extraction and\n   spatially bin your data so that there are no spectra below\n   ``(S/N)_min``;\n2. Perform a fit of your kinematics *without* penalty (keyword ``bias=0``).\n   The solution will be noisy and may be affected by spurious solutions,\n   however, this step will allow you to check the expected mean ranges in\n   the Gauss-Hermite parameters ``[h3, h4]`` for the galaxy under study;\n3. Perform a Monte Carlo simulation of your spectra, following e.g. the\n   included ``ppxf_example_simulation.py`` routine. Adopt as ``S/N`` in the\n   simulation the chosen value ``(S/N)_min`` and as input ``[h3, h4]`` the\n   maximum representative values measured in the non-penalized ``pPXF`` fit\n   of the previous step;\n4. Choose as the penalty (``bias``) the *largest* value such that, for\n   ``sigma > 3*velscale``, the mean difference delta between the output \n   ``[h3, h4]`` and the input ``[h3, h4]`` is well within (e.g. \n   ``delta ~ rms/3``) the rms scatter of the simulated values (see an\n   example in Fig. 2 of `Emsellem et al. 2004\n   <http://ui.adsabs.harvard.edu/abs/2004MNRAS.352..721E>`_).\n\nProblems with Your First Fit?\n-----------------------------\n\nCommon problems with your first ``pPXF`` fit are caused by incorrect\nwavelength ranges or different velocity scales between galaxy and\ntemplates. To quickly detect these problems try to overplot the (log\nrebinned) galaxy and the template just before calling the ``pPXF``\nprocedure.\n\nYou can use something like the following Python lines while adjusting the\nsmoothing window and the pixels shift. If you cannot get a rough match\nby eye it means something is wrong and it is unlikely that ``pPXF``\n(or any other program) will find a good match:\n\n.. code-block:: python\n\n    import numpy as np\n    import matplotlib.pyplot as plt\n    import scipy.ndimage\n\n    sigma = 2       # Velocity dispersion in pixels\n    shift = -20     # Velocity shift in pixels\n    template = np.roll(ndimage.gaussian_filter1d(template, sigma), shift)\n    plt.plot(galaxy, 'k')\n    plt.plot(template*np.median(galaxy)/np.median(template), 'r')\n\n###########################################################################\n\n\nLicense\n-------\n\nOther/Proprietary License\n\nCopyright (c) 2001-2020 Michele Cappellari\n\nThis software is provided as is without any warranty whatsoever.\nPermission to use, for non-commercial purposes is granted.\nPermission to modify for personal or internal use is granted,\nprovided this copyright and disclaimer are included in all \ncopies of the software. All other rights are reserved.\nIn particular, redistribution of the code is not allowed.\n\nChangelog\n---------\n\nV7.2.0: MC, Oxford, 4 May 2020\n++++++++++++++++++++++++++++++\n\n- Allow for ``linear_method='cvxopt'`` when the optional ``cvxopt`` package\n  is installed.\n\nV7.1.0: MC, Oxford, 30 April 2020\n+++++++++++++++++++++++++++++++++\n\n- Introduced new ``ppxf`` keyword ``linear_method``, and corresponding changes \n  in the code, to select between the old ('nnls') and the new ('lsqlin') \n  approach to the solution of the linear least-squares subproblem in ``ppxf``. \n  Thanks to Sam Vaughan (sydney.edu.au) for a convincing minimal example \n  illustrating the usefulness of this keyword.\n\nV7.0.1: MC, Oxford, 8 April 2020\n++++++++++++++++++++++++++++++++\n\n- Support ``.gas_zero_template`` and ``fraction`` together with other \n  equality constraints.\n- Included ``np.pad(...mode='constant')`` for backward compatibility with \n  Numpy 1.16. Thanks to Shravan Shetty (KIAA-PKU) for the suggestion.\n- Fix ``rebin()`` not retaining the dimensionality of an input column-vector. \n  This resulted in a program stop with a single gas template and \n  ``velscale_ratio > 1``. Thanks to Zhiyuan Ji (astro.umass.edu) for a clear \n  example reproducing the bug.\n- ``capfit``: New keyword ``cond`` for ``lsqlin``.\n- ``capfit``: Relaxed assertion for inconsistent inequalities in ``lsqlin`` \n  to avoid false positives. Thanks to Kyle Westfall (UCO Lick) for a detailed \n  bug report.\n\nV7.0.0: MC, Oxford, 10 January 2020\n+++++++++++++++++++++++++++++++++++\n\n- ``capfit``: New general linear least-squares optimization function\n  ``lsqlin`` which is now used to solve the quadratic subproblem.\n- ``capfit``: Allow for linear inequality/equality constraints\n  ``A_ineq``, ``b_ineq`` and  ``A_eq``, ``b_eq``.\n- ``ppxf``: Use (faster) ``capfit.lsqlin`` for the linear fit.\n- ``ppxf``: Use updated ``capfit.capfit`` for the non-linear optimization.\n- ``ppxf``: Allow for linear equalities/inequalities for both the template\n  weights and the kinematic parameters with the ``constr_templ`` and\n  ``constr_kinem`` optional keywords.\n- ``ppxf``: New ``set_linear_constraints`` function.\n- ``ppxf``: Updated documentation.\n\nV6.7.17: MC, Oxford, 14 November 2019\n+++++++++++++++++++++++++++++++++++++\n\n- ``capfit``: Written complete documentation.\n- ``capfit``: Improved print formatting.\n- ``capfit``: Return ``.message`` attribute.\n- ``capfit``: Improved ``xtol`` convergence test.\n- ``capfit``: Only accept final move if ``chi2`` decreased.\n- ``capfit``: Strictly satisfy bounds during Jacobian computation.\n\nV6.7.16: MC, Oxford, 12 June 2019\n+++++++++++++++++++++++++++++++++\n\n- ``capfit``: Use only free parameters for ``xtol`` convergence test.\n- ``capfit``: Describe in words convergence status with nonzero ``verbose``.\n- ``capfit``: Fixed program stop when ``abs_step`` is undefined.\n- ``capfit``: Fixed ignoring optional ``max_nfev``.\n\nV6.7.15: MC, Oxford, 7 February 2019\n++++++++++++++++++++++++++++++++++++\n- Removed unused ``re`` import.\n- Removed Scipy's ``next_fast_len`` usage due to an issue with odd padding size.\n  Thanks to Eric Emsellem (ESO) for a clear example illustrating this rare and\n  subtle bug.\n\nV6.7.14: MC, Oxford, 27 November 2018\n++++++++++++++++++++++++++++++++++++++\n- Print used ``tied`` parameters equalities, if any.\n- Return ``.ndof`` attribute.\n- Do not remove ``fixed`` or ``tied`` parameters from the DOF calculation.\n  Thanks to Joanna Woo (Univ. of Victoria) for the correction.\n- Replaced ``normalize``, ``min_age``, ``max_age`` and ``metal`` keywords with\n  ``norm_range``, ``age_range`` and ``metal_range`` in ``ppxf.miles_util.miles``.\n- Fixed ``clock`` ``DeprecationWarning`` in Python 3.7.\n\nV6.7.13: MC, Oxford, 20 September 2018\n++++++++++++++++++++++++++++++++++++++\n- Expanded documentation of ``reddening`` and ``gas_reddening``.\n  Thanks to Nick Boardman (Univ. Utah) for the feedback.\n- ``capfit`` now raises an error if one tries to tie parameters to themselves.\n  Thanks to Kyle Westfall (Univ. Santa Cruz) for the suggestion.\n- ``capfit`` uses Python 3.6 f-strings.\n\nV6.7.12: MC, Oxford, 9 July 2018\n++++++++++++++++++++++++++++++++\n- Allow for ``velscale`` and ``vsyst`` to be Numpy arrays rather than scalars.\n- Improved criterion for when the Balmer series is within the fitted wavelength\n  range in ``ppxf.ppxf_util.emission_lines``. Thanks to Sam Vaughan\n  (Univ. of Oxford) for the feedback.\n- Included ``width`` keyword in ``ppxf.ppxf_util.determine_goodpixels``.\n  Thanks to George Privon (Univ. of Florida) for the suggestion.\n- Expanded ``.gas_flux`` documentation.\n\nV6.7.11: MC, Oxford, 5 June 2018\n++++++++++++++++++++++++++++++++\n\n- Formatted ``ppxf.py`` docstring in reStructuredText.\n- Removed CHANGELOG from the code and placed in a separate file.\n- Modified ``setup.py`` to show help and CHANGELOG on PyPi page.\n- Included ``ppxf.__version__``.\n\nV6.7.8: MC, Oxford, 21 May 2018\n+++++++++++++++++++++++++++++++\n\n- Moved package to the Python Package Index (PyPi).\n- Dropped legacy Python 2.7 support.\n\nV6.7.6: MC, Oxford, 16 April 2018\n+++++++++++++++++++++++++++++++++\n\n- Changed imports for the conversion of ppxf to a package.\n  Thanks to Joe Burchett (Santa Cruz) for the suggestion.\n\nV6.7.5: MC, Oxford, 10 April 2018\n+++++++++++++++++++++++++++++++++\n\n- Fixed syntax error under Python 2.7.\n\nV6.7.4: MC, Oxford, 16 February 2018\n++++++++++++++++++++++++++++++++++++\n\n- Fixed bug in ``reddening_cal00()``. It only affected NIR lam > 1000 nm.\n\nV6.7.3: MC, Oxford, 8 February 2018\n+++++++++++++++++++++++++++++++++++\n\n- Plot wavelength in nm instead of Angstrom, following IAU rules.\n- Ensures each element of ``start`` is not longer than its ``moments``.\n- Removed underscore from internal function names.\n- Included ``ftol`` keyword.\n\nV6.7.2: MC, Oxford, 30 January 2018\n+++++++++++++++++++++++++++++++++++\n\n- Included dunder names as suggested by Peter Weilbacher (Potsdam).\n- Fixed wrong ``.gas_reddening`` when ``mdegree > 0``.\n- Improved formatting of documentation.\n\nV6.7.1: MC, Oxford, 29 November 2017\n++++++++++++++++++++++++++++++++++++\n\n- Removed import of ``misc.factorial``, deprecated in Scipy 1.0.\n\nV6.7.0: MC, Oxford, 6 November 2017\n+++++++++++++++++++++++++++++++++++\n\n- Allow users to input identically-zero gas templates while still\n  producing a stable NNLS solution. In this case, warn the user and set\n  the .gas_zero_template attribute. This situation can indicate an input\n  bug or a gas line which entirely falls within a masked region.\n- Corrected ``gas_flux_error`` normalization, when input not normalized.\n- Return ``.gas_bestfit``, ``.gas_mpoly``, ``.mpoly`` and ``.apoly`` attributes.\n- Do not multiply gas emission lines by polynomials, instead allow for\n  ``gas_reddening`` (useful with tied Balmer emission lines).\n- Use ``axvspan`` to visualize masked regions in plot.\n- Fixed program stop with ``linear`` keyword.\n- Introduced ``reddening_func`` keyword.\n\nV6.6.4: MC, Oxford, 5 October 2017\n++++++++++++++++++++++++++++++++++\n\n- Check for NaN in ``galaxy`` and check all ``bounds`` have two elements.\n- Allow ``start`` to be either a list or an array or vectors.\n\nV6.6.3: MC, Oxford, 25 September 2017\n+++++++++++++++++++++++++++++++++++++\n\n- Reduced bounds on multiplicative polynomials and clipped to positive\n  values. Thanks to Xihan Ji (Tsinghua University) for providing an\n  example of slightly negative gas emission lines, when the spectrum\n  contains essentially just noise.\n- Improved visualization of masked pixels.\n\nV6.6.2: MC, Oxford, 15 September 2017\n+++++++++++++++++++++++++++++++++++++\n\n- Fixed program stop with a 2-dim templates array and regularization.\n  Thanks to Adriano Poci (Macquarie University) for the clear report and\n  the fix.\n\nV6.6.1: MC, Oxford, 4 August 2017\n+++++++++++++++++++++++++++++++++\n\n- Included note on ``.gas_flux`` output units. Thanks to Xihan Ji\n  (Tsinghua University) for the feedback.\n\nV6.6.0: MC, Oxford, 27 June 2017\n++++++++++++++++++++++++++++++++\n\n- Print and return gas fluxes and errors, if requested, with the new\n  ``gas_component`` and ``gas_names`` keywords.\n\nV6.5.0: MC, Oxford, 23 June 2017\n++++++++++++++++++++++++++++++++\n\n- Replaced ``MPFIT`` with ``capfit`` for a Levenberg-Marquardt method with\n  fixed or tied variables, which rigorously accounts for box constraints.\n\nV6.4.2: MC, Oxford, 2 June 2017\n+++++++++++++++++++++++++++++++\n\n- Fixed removal of bounds in solution, introduced in V6.4.1.\n  Thanks to Kyle Westfall (Univ. Santa Cruz) for reporting this.\n- Included ``method`` keyword to use Scipy's ``least_squares()``\n  as alternative to MPFIT.\n- Force float division in pixel conversion of ``start`` and ``bounds``.\n\nV6.4.1: MC, Oxford, 25 May 2017\n+++++++++++++++++++++++++++++++\n\n- ``linear_fit()`` does not return unused status any more, for\n  consistency with the correspinding change to ``cap_mpfit``.\n\nV6.4.0: MC, Oxford, 12 May 2017\n+++++++++++++++++++++++++++++++\n\n- Introduced ``tied`` keyword to tie parameters during fitting.\n- Included discussion of formal errors of ``.weights``.\n\nV6.3.2: MC, Oxford, 4 May 2017\n++++++++++++++++++++++++++++++\n\n- Fixed possible program stop introduced in V6.0.7 and consequently\n  removed unnecessary function ``_templates_rfft()``. Many thanks to\n  Jesus Falcon-Barroso for a very clear and useful bug report!\n\nV6.3.1: MC, Oxford, 13 April 2017\n+++++++++++++++++++++++++++++++++\n\n- Fixed program stop when fitting two galaxy spectra with\n  reflection-symmetric LOSVD.\n\nV6.3.0: MC, Oxford, 30 March 2017\n+++++++++++++++++++++++++++++++++\n\n- Included ``reg_ord`` keyword to allow for both first and second order\n  regularization.\n\nV6.2.0: MC, Oxford, 27 March 2017\n+++++++++++++++++++++++++++++++++\n\n- Improved curvature criterion for regularization when ``dim > 1``.\n\nV6.1.0: MC, Oxford, 15 March 2017\n+++++++++++++++++++++++++++++++++\n\n- Introduced ``trig`` keyword to use a trigonometric series as\n  alternative to Legendre polynomials.\n\nV6.0.7: MC, Oxford, 13 March 2017\n+++++++++++++++++++++++++++++++++\n\n- Use ``next_fast_len()`` for optimal ``rfft()`` zero padding.\n- Included keyword ``gas_component`` in the ``.plot()`` method, to\n  distinguish gas emission lines in best-fitting plots.\n- Improved plot of residuals for noisy spectra.\n- Simplified regularization implementation.\n\nV6.0.6: MC, Oxford, 23 February 2017\n++++++++++++++++++++++++++++++++++++\n\n- Added ``linear_fit()`` and ``nonlinear_fit()`` functions to better\n  clarify the code structure. Included ``templates_rfft`` keyword.\n- Updated documentation. Some code simplifications.\n\nV6.0.5: MC, Oxford, 21 February 2017\n++++++++++++++++++++++++++++++++++++\n\n- Consistently use new format_output() function both with/without\n  the ``linear`` keyword. Added ``.status`` attribute. Changes suggested by\n  Kyle Westfall (Univ. Santa Cruz).\n\nV6.0.4: MC, Oxford, 30 January 2017\n+++++++++++++++++++++++++++++++++++\n\n- Re-introduced ``linear`` keyword to only perform a linear fit and\n  skip the non-linear optimization.\n\nV6.0.3: MC, Oxford, 1 December 2016\n+++++++++++++++++++++++++++++++++++\n\n- Return usual ``Chi**2/DOF`` instead of Biweight estimate.\n\nV6.0.2: MC, Oxford, 15 August 2016\n++++++++++++++++++++++++++++++++++\n\n- Improved formatting of printed output.\n\nV6.0.1: MC, Oxford, 10 August 2016\n++++++++++++++++++++++++++++++++++\n\n- Allow ``moments`` to be an arbitrary integer.\n- Allow for scalar ``moments`` with multiple kinematic components.\n\nV6.0.0: MC, Oxford, 28 July 2016\n++++++++++++++++++++++++++++++++\n\n- Compute the Fourier Transform of the LOSVD analytically:\n- Major improvement in velocity accuracy when ``sigma < velscale``.\n- Removed ``oversample`` keyword, which is now unnecessary.\n- Removed limit on velocity shift of templates.\n- Simplified FFT zero padding. Updated documentation.\n\nV5.3.3: MC, Oxford 24 May 2016\n++++++++++++++++++++++++++++++\n\n- Fixed Python 2 compatibility. Thanks to Masato Onodera (NAOJ).\n\nV5.3.2: MC, Oxford, 22 May 2016\n+++++++++++++++++++++++++++++++\n\n- Backward compatibility change: allow ``start`` to be smaller than\n  ``moments``. After feedback by Masato Onodera (NAOJ).\n- Updated documentation of ``bounds`` and ``fixed``.\n\nV5.3.1: MC, Oxford, 18 May 2016\n+++++++++++++++++++++++++++++++\n\n- Use wavelength in plot when available. Make ``plot()`` a class function.\n  Changes suggested and provided by Johann Cohen-Tanugi (LUPM).\n\nV5.3.0: MC, Oxford, 9 May 2016\n++++++++++++++++++++++++++++++\n\n- Included ``velscale_ratio`` keyword to pass a set of templates with\n  higher resolution than the galaxy spectrum.\n- Changed ``oversample`` keyword to require integers not Booleans.\n\nV5.2.0: MC, Baltimore, 26 April 2016\n++++++++++++++++++++++++++++++++++++\n\n- Included ``bounds``, ``fixed`` and ``fraction`` keywords.\n\nV5.1.18: MC, Oxford, 20 April 2016\n++++++++++++++++++++++++++++++++++\n\n- Fixed deprecation warning in Numpy 1.11. Changed order from 1 to 3\n  during oversampling. Warn if sigma is under-sampled.\n\nV5.1.17: MC, Oxford, 21 January 2016\n++++++++++++++++++++++++++++++++++++\n\n- Expanded explanation of the relation between output velocity and redshift.\n\nV5.1.16: MC, Oxford, 9 November 2015\n++++++++++++++++++++++++++++++++++++\n\n- Fixed potentially misleading typo in documentation of ``moments``.\n\nV5.1.15: MC, Oxford, 22 October 2015\n++++++++++++++++++++++++++++++++++++\n\n- Updated documentation. Thanks to Peter Weilbacher (Potsdam) for\n  corrections.\n\nV5.1.14: MC, Oxford, 19 October 2015\n++++++++++++++++++++++++++++++++++++\n\n- Fixed deprecation warning in Numpy 1.10.\n\nV5.1.13: MC, Oxford, 24 April 2015\n++++++++++++++++++++++++++++++++++\n\n- Updated documentation.\n\nV5.1.12: MC, Oxford, 25 February 2015\n+++++++++++++++++++++++++++++++++++++\n\n- Use ``color=`` instead of ``c=`` to avoid new Matplotlib 1.4 bug.\n\nV5.1.11: MC, Sydney, 5 February 2015\n++++++++++++++++++++++++++++++++++++\n\n- Reverted change introduced in V5.1.2. Thanks to Nora Lu\"tzgendorf\n  for reporting problems with ``oversample``.\n\nV5.1.10: MC, Oxford, 14 October 2014\n++++++++++++++++++++++++++++++++++++\n\n- Fixed bug in saving output introduced in previous version.\n\nV5.1.9: MC, Las Vegas Airport, 13 September 2014\n++++++++++++++++++++++++++++++++++++++++++++++++\n\n- Pre-compute FFT and oversampling of templates. This speeds up the\n  calculation for very long or highly-oversampled spectra. Thanks to\n  Remco van den Bosch for reporting situations where this optimization\n  may be useful.\n\nV5.1.8: MC, Utah, 10 September 2014\n+++++++++++++++++++++++++++++++++++\n\n- Fixed program stop with ``reddening`` keyword. Thanks to Masatao\n  Onodera for reporting the problem.\n\nV5.1.7: MC, Oxford, 3 September 2014\n++++++++++++++++++++++++++++++++++++\n\n- Relaxed requirement on input maximum velocity shift.\n- Minor reorganization of the code structure.\n\nV5.1.6: MC, Oxford, 6 August 2014\n+++++++++++++++++++++++++++++++++\n\n- Catch an additional input error. Updated documentation for Python.\n  Included templates ``matrix`` in output. Modified plotting colours.\n\nV5.1.5: MC, Oxford, 21 June 2014\n++++++++++++++++++++++++++++++++\n\n- Fixed deprecation warning.\n\nV5.1.4: MC, Oxford, 25 May 2014\n+++++++++++++++++++++++++++++++\n\n- Support both Python 2.7 and Python 3.\n\nV5.1.3: MC, Oxford, 7 May 2014\n++++++++++++++++++++++++++++++\n\n- Allow for an input covariance matrix instead of an error spectrum.\n\nV5.1.2: MC, Oxford, 6 May 2014\n++++++++++++++++++++++++++++++\n\n- Replaced REBIN with INTERPOLATE + /OVERSAMPLE keyword. This is\n  to account for the fact that the Line Spread Function of the observed\n  galaxy spectrum already includes pixel convolution. Thanks to Mike\n  Blanton for the suggestion.\n\nV5.1.1: MC, Dallas Airport, 9 February 2014\n+++++++++++++++++++++++++++++++++++++++++++\n\n- Fixed typo in the documentation of ``nnls_flags``.\n\nV5.1.0: MC, Oxford, 9 January 2014\n++++++++++++++++++++++++++++++++++\n\n- Allow for a different LOSVD for each template. Templates can be\n  stellar or can be gas emission lines. A ppxf version adapted for\n  multiple kinematic components existed for years. It was updated in\n  JAN/2012 for the paper by Johnston et al. (2013, MNRAS). This version\n  merges those changes with the public ppxf version, making sure that all\n  previous ppxf options are still supported.\n\nV5.0.1: MC, Oxford, 12 December 2013\n++++++++++++++++++++++++++++++++++++\n\n- Minor cleaning and corrections.\n\nV5.0.0: MC, Oxford, 6 December 2013\n+++++++++++++++++++++++++++++++++++\n\n- Translated from IDL into Python and tested against the original version.\n\nV4.6.6: MC, Paranal, 8 November 2013\n++++++++++++++++++++++++++++++++++++\n\n- Uses CAP_RANGE to avoid potential naming conflicts.\n\nV4.6.5: MC, Oxford, 15 November 2012\n++++++++++++++++++++++++++++++++++++\n\n- Expanded documentation of REGUL keyword.\n\nV4.6.4: MC, Oxford, 9 December 2011\n+++++++++++++++++++++++++++++++++++\n\n- Increased oversampling factor to 30x, when the /OVERSAMPLE keyword\n  is used. Updated corresponding documentation. Thanks to Nora\n  Lu\"tzgendorf for test cases illustrating errors in the recovered\n  velocity when the sigma is severely undersampled.\n\nV4.6.3: MC, Oxford 25 October 2011\n++++++++++++++++++++++++++++++++++\n\n- Do not change TEMPLATES array in output when REGUL is nonzero.\n  From feedback of Richard McDermid.\n\nV4.6.2: MC, Oxford, 17 October 2011\n+++++++++++++++++++++++++++++++++++\n\n- Included option for 3D regularization and updated documentation of\n  REGUL keyword.\n\nV4.6.1: MC, Oxford, 29 July 2011\n++++++++++++++++++++++++++++++++\n\n- Use Coyote Graphics (http://www.idlcoyote.com/) by David W. Fanning.\n  The required routines are now included in NASA IDL Astronomy Library.\n\nV4.6.0: MC, Oxford, 12 April 2011\n+++++++++++++++++++++++++++++++++\n\n- Important fix to /CLEAN procedure: bad pixels are now properly\n  updated during the 3sigma iterations.\n\nV4.5.0: MC, Oxford, 13 April 2010\n+++++++++++++++++++++++++++++++++\n\n- Dramatic speed up in the convolution of long spectra.\n\nV4.4.0: MC, Oxford, 18 September 2009\n+++++++++++++++++++++++++++++++++++++\n\n- Introduced Calzetti et al. (2000) ppxf_REDDENING_CURVE function to\n  estimate the reddening from the fit.\n\nV4.3.0: MC, Oxford, 4 Mach 2009\n+++++++++++++++++++++++++++++++\n\n- Introduced REGUL keyword to perform linear regularization of WEIGHTS\n  in one or two dimensions.\n\nV4.2.3: MC, Oxford, 27 November 2008\n++++++++++++++++++++++++++++++++++++\n\n- Corrected error message for too big velocity shift.\n\nV4.2.2: MC, Windhoek, 3 July 2008\n+++++++++++++++++++++++++++++++++\n\n- Added keyword POLYWEIGHTS.\n\nV4.2.1: MC, Oxford, 17 May 2008\n+++++++++++++++++++++++++++++++\n\n- Use LA_LEAST_SQUARES (IDL 5.6) instead of SVDC when fitting a single\n  template. Please let me know if you need to use ppxf with an older IDL\n  version.\n\nV4.2.0: MC, Oxford, 15 March 2008\n+++++++++++++++++++++++++++++++++\n\n- Introduced optional fitting of SKY spectrum. Many thanks to\n  Anne-Marie Weijmans for testing.\n\nV4.1.7: MC, Oxford, 6 October 2007\n++++++++++++++++++++++++++++++++++\n\n- Updated documentation with important note on penalty determination.\n\nV4.1.6: MC, Leiden, 20 January 2006\n+++++++++++++++++++++++++++++++++++\n\n- Print number of nonzero templates. Do not print outliers in /QUIET mode.\n\nV4.1.5: MC, Leiden, 10 February 2005\n++++++++++++++++++++++++++++++++++++\n\n- Verify that GOODPIXELS is monotonic and does not contain duplicated\n  values. After feedback from Richard McDermid.\n\nV4.1.4: MC, Leiden, 12 January 2005\n+++++++++++++++++++++++++++++++++++\n\n- Make sure input NOISE is a positive vector.\n\nV4.1.3: MC, Vicenza, 30 December 2004\n+++++++++++++++++++++++++++++++++++++\n\n- Updated documentation.\n\nV4.1.2: MC, Leiden, 11 November 2004\n++++++++++++++++++++++++++++++++++++\n\n- Handle special case where a single template without additive\n  polynomials is fitted to the galaxy.\n\nV4.1.1: MC, Leiden, 21 September 2004\n+++++++++++++++++++++++++++++++++++++\n\n- Increased maximum number of iterations ITMAX in BVLS. Thanks to\n  Jesus Falcon-Barroso for reporting problems.\n- Introduced error message when velocity shift is too big.\n- Corrected output when MOMENTS=0.\n\nV4.1.0: MC, Leiden, 3 September 2004\n++++++++++++++++++++++++++++++++++++\n\n- Corrected implementation of two-sided fitting of the LOSVD. Thanks\n  to Stefan van Dongen for reporting problems.\n\nV4.0.0: MC, Vicenza, 16 August 2004\n+++++++++++++++++++++++++++++++++++\n\n- Introduced optional two-sided fitting assuming a reflection\n  symmetric LOSVD for two input spectra.\n\nV3.7.3: MC, Leiden, 7 August 2004\n+++++++++++++++++++++++++++++++++\n\n- Corrected bug: keyword ERROR was returned in pixels instead of km/s.\n- Decreased lower limit on fitted dispersion. Thanks to Igor V. Chilingarian.\n\nV3.7.2: MC, Leiden, 28 April 2004\n+++++++++++++++++++++++++++++++++\n\n- Corrected program stop after fit when MOMENTS=2. Bug was introduced in V3.7.0.\n\nV3.7.1: MC, Leiden, 31 March 2004\n+++++++++++++++++++++++++++++++++\n\n- Updated documentation.\n\nV3.7.0: MC, Leiden, 23 March 2004\n+++++++++++++++++++++++++++++++++\n\n- Revised implementation of MDEGREE option. Nonlinear implementation:\n  straightforward, robust, but slower.\n\nV3.6.0: MC, Leiden, 19 March 2004\n+++++++++++++++++++++++++++++++++\n\n- Added MDEGREE option for multiplicative polynomials. Linear implementation:\n  fast, works well in most cases, but can fail in certain cases.\n\nV3.5.0: MC, Leiden, 11 December 2003\n++++++++++++++++++++++++++++++++++++\n\n- Included /OVERSAMPLE option.\n\nV3.4.7: MC, Leiden, 8 December 2003\n+++++++++++++++++++++++++++++++++++\n\n- First released version.\n\nV1.0.0: Leiden, 10 October 2001\n+++++++++++++++++++++++++++++++\n\n- Created by Michele Cappellari.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://purl.org/cappellari/software", "keywords": "", "license": "Other/Proprietary License", "maintainer": "", "maintainer_email": "", "name": "ppxf", "package_url": "https://pypi.org/project/ppxf/", "platform": "", "project_url": "https://pypi.org/project/ppxf/", "project_urls": {"Homepage": "http://purl.org/cappellari/software"}, "release_url": "https://pypi.org/project/ppxf/7.2.0/", "requires_dist": null, "requires_python": "", "summary": "pPXF: Full Spectrum Fitting of Galactic and Stellar Spectra", "version": "7.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><strong>pPXF: Full Spectrum Fitting of Galactic and Stellar Spectra</strong></p>\n<img alt=\"http://www-astro.physics.ox.ac.uk/~mxc/software/ppxf_logo.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/87bcb00acfc9e9dadb14638dad9bf972216d6043/687474703a2f2f7777772d617374726f2e706879736963732e6f782e61632e756b2f7e6d78632f736f6674776172652f707078665f6c6f676f2e706e67\">\n<a href=\"https://pypi.org/project/ppxf/\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/ppxf.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/eeffafe9450a9cd940f5caed09bf78ab67710fed/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f707078662e737667\"></a>\n<a href=\"https://arxiv.org/abs/1607.08538\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/arXiv-1607.08538-orange.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/321f7d2c8c75b595eef23a8ff59c14b682fc35ee/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f61725869762d313630372e30383533382d6f72616e67652e737667\"></a>\n<a href=\"https://doi.org/10.1093/mnras/stw3020\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/DOI-10.1093/mnras/stw3020-green.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/04675321c36afa3b185f42e6365132a33101509a/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f444f492d31302e313039332f6d6e7261732f737477333032302d677265656e2e737667\"></a>\n<p>This <tt>pPXF</tt> package contains a Python implementation of the Penalized\nPiXel-Fitting (<tt>pPXF</tt>) method to fit the stellar and gas kinematics,\nas well as the stellar population of galaxies. The method was originally\ndescribed in <a href=\"https://ui.adsabs.harvard.edu/abs/2004PASP..116..138C\" rel=\"nofollow\">Cappellari &amp; Emsellem (2004)</a>\nand was substantially upgraded in subsequent years and particularly in\n<a href=\"https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C\" rel=\"nofollow\">Cappellari (2017)</a>.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#attribution\" id=\"id4\" rel=\"nofollow\">Attribution</a></li>\n<li><a href=\"#installation\" id=\"id5\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#usage-examples\" id=\"id6\" rel=\"nofollow\">Usage Examples</a></li>\n<li><a href=\"#ppxf-purpose\" id=\"id7\" rel=\"nofollow\">pPXF Purpose</a></li>\n<li><a href=\"#calling-sequence\" id=\"id8\" rel=\"nofollow\">Calling Sequence</a></li>\n<li><a href=\"#input-parameters\" id=\"id9\" rel=\"nofollow\">Input Parameters</a></li>\n<li><a href=\"#optional-keywords\" id=\"id10\" rel=\"nofollow\">Optional Keywords</a></li>\n<li><a href=\"#output-parameters\" id=\"id11\" rel=\"nofollow\">Output Parameters</a></li>\n<li><a href=\"#how-to-set-regularization\" id=\"id12\" rel=\"nofollow\">How to Set Regularization</a></li>\n<li><a href=\"#problems-with-your-first-fit\" id=\"id13\" rel=\"nofollow\">Problems with Your First Fit?</a></li>\n<li><a href=\"#license\" id=\"id14\" rel=\"nofollow\">License</a></li>\n<li><a href=\"#changelog\" id=\"id15\" rel=\"nofollow\">Changelog</a></li>\n</ul>\n</div>\n<div id=\"attribution\">\n<h2><a href=\"#id4\" rel=\"nofollow\">Attribution</a></h2>\n<p>If you use this software for your research, please cite at least\n<a href=\"https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C\" rel=\"nofollow\">Cappellari (2017)</a>.\nThe BibTeX entry for the paper is:</p>\n<pre>@ARTICLE{Cappellari2017,\n    author = {{Cappellari}, M.},\n    title = \"{Improving the full spectrum fitting method:\n        accurate convolution with Gauss-Hermite functions}\",\n    journal = {MNRAS},\n    eprint = {1607.08538},\n    year = 2017,\n    volume = 466,\n    pages = {798-811},\n    doi = {10.1093/mnras/stw3020}\n}\n</pre>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id5\" rel=\"nofollow\">Installation</a></h2>\n<p>install with:</p>\n<pre>pip install ppxf\n</pre>\n<p>Without write access to the global <tt><span class=\"pre\">site-packages</span></tt> directory, use:</p>\n<pre>pip install --user ppxf\n</pre>\n</div>\n<div id=\"usage-examples\">\n<h2><a href=\"#id6\" rel=\"nofollow\">Usage Examples</a></h2>\n<p>To learn how to use the main program <tt>pPXF</tt> run the example programs in the\n<tt>ppxf/examples</tt> directory, within the main package installation folder inside\n<tt><span class=\"pre\">site-packages</span></tt>, and read the detailed documentation in the docstring of the\nfile <tt>ppxf.py</tt>, on <a href=\"https://pypi.org/project/ppxf/\" rel=\"nofollow\">PyPi</a> or as PDF from\n<a href=\"https://purl.org/cappellari/software\" rel=\"nofollow\">https://purl.org/cappellari/software</a>.</p>\n</div>\n<hr class=\"docutils\">\n<div id=\"ppxf-purpose\">\n<h2><a href=\"#id7\" rel=\"nofollow\">pPXF Purpose</a></h2>\n<p>Extract galaxy stellar kinematics <tt>(V, sigma, h3, h4, h5, <span class=\"pre\">h6,...)</span></tt>\nor the stellar population and gas emission by fitting a template\nto an observed spectrum in pixel space, using the Penalized PiXel-Fitting\n(<tt>pPXF</tt>) method originally described in</p>\n<p><a href=\"https://ui.adsabs.harvard.edu/abs/2004PASP..116..138C\" rel=\"nofollow\">Cappellari &amp; Emsellem (2004)</a></p>\n<p>and substantially upgraded in subsequent years and particularly in</p>\n<p><a href=\"https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C\" rel=\"nofollow\">Cappellari (2017)</a></p>\n<p>The following key optional features are also available:</p>\n<ol>\n<li>An optimal template, positive linear combination of different input\ntemplates, can be fitted together with the kinematics.</li>\n<li>One can enforce smoothness on the template weights during the fit. This\nis useful to attach a physical meaning to the weights e.g. in terms of\nthe star formation history of a galaxy.</li>\n<li>One can fit multiple kinematic components for both the stars and the gas\nemission lines. Both the stellar and gas LOSVD can be penalized and can\nbe described by a general Gauss-Hermite series.</li>\n<li>Any parameter of the LOSVD (e.g. sigma) for any kinematic component can\neither be fitted, or held fixed to a given value, while other parameters\nare fitted. Alternatively, parameters can be constrained to lie within\ngiven limits or even tied by simple relations to other parameters.</li>\n<li>One can enforce linear equality/inequality constraints on either the\ntemplate weights or the kinematic parameters.</li>\n<li>Additive and/or multiplicative polynomials can be included to adjust the\ncontinuum shape of the template to the observed spectrum.</li>\n<li>Iterative sigma clipping can be used to clean the spectrum.</li>\n<li>It is possible to fit a mirror-symmetric LOSVD to two spectra at the\nsame time. This is useful for spectra taken at point-symmetric spatial\npositions with respect to the center of an equilibrium stellar system.</li>\n<li>One can include sky spectra in the fit, to deal with cases where the sky\ndominates the observed spectrum and an accurate sky subtraction is\ncritical.</li>\n<li>One can derive an estimate of the reddening in the spectrum. This can be\ndone independently for the stellar spectrum or the Balmer emission lines.</li>\n<li>The covariance matrix can be input instead of the error spectrum, to\naccount for correlated errors in the spectral pixels.</li>\n<li>One can specify the weights fraction between two kinematics components,\ne.g. to model bulge and disk contributions.</li>\n<li>One can use templates with higher resolution than the galaxy, to\nimprove the accuracy of the LOSVD extraction at low dispersion.</li>\n</ol>\n</div>\n<div id=\"calling-sequence\">\n<h2><a href=\"#id8\" rel=\"nofollow\">Calling Sequence</a></h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">ppxf.ppxf</span> <span class=\"kn\">import</span> <span class=\"n\">ppxf</span>\n\n<span class=\"n\">pp</span> <span class=\"o\">=</span> <span class=\"n\">ppxf</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">templates</span><span class=\"p\">,</span> <span class=\"n\">galaxy</span><span class=\"p\">,</span> <span class=\"n\">noise</span><span class=\"p\">,</span> <span class=\"n\">velscale</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"p\">,</span>\n         <span class=\"n\">bias</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">bounds</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">clean</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">component</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n         <span class=\"n\">constr_templ</span><span class=\"o\">=</span><span class=\"p\">{},</span> <span class=\"n\">constr_kinem</span><span class=\"o\">=</span><span class=\"p\">{},</span> <span class=\"n\">degree</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">fixed</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n         <span class=\"n\">fraction</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">ftol</span><span class=\"o\">=</span><span class=\"mf\">1e-4</span><span class=\"p\">,</span> <span class=\"n\">gas_component</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">gas_names</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n         <span class=\"n\">gas_reddening</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">goodpixels</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">lam</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">linear</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n         <span class=\"n\">linear_method</span> <span class=\"o\">=</span> <span class=\"s1\">'nnls'</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">'capfit'</span><span class=\"p\">,</span> <span class=\"n\">mdegree</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n         <span class=\"n\">moments</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">plot</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">quiet</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">reddening</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n         <span class=\"n\">reddening_func</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">reg_dim</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">reg_ord</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">regul</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n         <span class=\"n\">sigma_diff</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sky</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">templates_rfft</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">tied</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n         <span class=\"n\">trig</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">velscale_ratio</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">vsyst</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">):</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">pp</span><span class=\"o\">.</span><span class=\"n\">sol</span><span class=\"p\">)</span>  <span class=\"c1\"># print best-fitting kinematics (V, sigma, h3, h4)</span>\n<span class=\"n\">pp</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>      <span class=\"c1\"># Plot best fit and gas lines</span>\n</pre>\n</div>\n<div id=\"input-parameters\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Input Parameters</a></h2>\n<dl>\n<dt>templates:</dt>\n<dd><p>Vector containing the spectrum of a single template star or more\ncommonly an array of dimensions <tt>templates[nPixels, nTemplates]</tt>\ncontaining different templates to be optimized during the fit of the\nkinematics. It has to be <tt>nPixels &gt;= galaxy.size</tt>.</p>\n<p>To apply linear regularization to the <tt>weights</tt> via the keyword\n<tt>regul</tt>, <tt>templates</tt> should be an array of two\n<tt>templates[nPixels, nAge]</tt>, three <tt>templates[nPixels, nAge, nMetal]</tt>\nor four <tt>templates[nPixels, nAge, nMetal, nAlpha]</tt> dimensions,\ndepending on the number of population variables one wants to study.\nThis can be useful to try to attach a physical meaning to the output\n<tt>weights</tt>, in term of the galaxy star formation history and chemical\ncomposition distribution.\nIn that case the templates may represent single stellar population SSP\nmodels and should be arranged in sequence of increasing age,\nmetallicity or alpha along the second, third or fourth dimension of the\narray respectively.</p>\n</dd>\n<dt>galaxy:</dt>\n<dd><p>Vector containing the spectrum of the galaxy to be measured. The\nstar and the galaxy spectra have to be logarithmically rebinned but the\ncontinuum should <em>not</em> be subtracted. The rebinning may be performed\nwith the <tt>log_rebin</tt> routine in <tt>ppxf.ppxf_util</tt>.</p>\n<p>For high redshift galaxies, one should bring the spectra close to the\nrestframe wavelength, before doing the <tt>pPXF</tt> fit. This can be done\nby dividing the observed wavelength by <tt>(1 + z)</tt>, where <tt>z</tt> is a\nrough estimate of the galaxy redshift, before the logarithmic\nrebinning. See Section 2.4 of <a href=\"https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C\" rel=\"nofollow\">Cappellari (2017)</a> for details.</p>\n<p><tt>galaxy</tt> can also be an array of dimensions <tt>galaxy[nGalPixels, 2]</tt>\ncontaining two spectra to be fitted, at the same time, with a\nreflection-symmetric LOSVD. This is useful for spectra taken at\npoint-symmetric spatial positions with respect to the center of an\nequilibrium stellar system.\nFor a discussion of the usefulness of this two-sided fitting see e.g.\nSection 3.6 of <a href=\"http://ui.adsabs.harvard.edu/abs/1992MNRAS.254..389R\" rel=\"nofollow\">Rix &amp; White (1992)</a>.</p>\n<p>IMPORTANT: (1) For the two-sided fitting the <tt>vsyst</tt> keyword has to\nbe used. (2) Make sure the spectra are rescaled to be not too many\norder of magnitude different from unity, to avoid over or underflow\nproblems in the calculation. E.g. units of <tt><span class=\"pre\">erg/(s</span> cm^2 A)</tt> may cause\nproblems!</p>\n</dd>\n<dt>noise:</dt>\n<dd><p>Vector containing the <tt>1*sigma</tt> uncertainty (per pixel) in the galaxy\nspectrum, or covariance matrix describing the correlated uncertainties\nin the galaxy spectrum. Of course this vector/matrix must have the same\nunits as the galaxy spectrum.</p>\n<p>If <tt>galaxy</tt> is a <tt>Nx2</tt> array, <tt>noise</tt> has to be an array with the\nsame dimensions.</p>\n<p>When <tt>noise</tt> has dimensions <tt>NxN</tt> it is assumed to contain the\ncovariance matrix with elements <tt>sigma(i, j)</tt>. When the errors in the\nspectrum are uncorrelated it is mathematically equivalent to input in\n<tt>pPXF</tt> an error vector <tt>noise=errvec</tt> or a <tt>NxN</tt> diagonal matrix\n<tt><span class=\"pre\">noise=np.diag(errvec**2)</span></tt> (note squared!).</p>\n<p>IMPORTANT: the penalty term of the <tt>pPXF</tt> method is based on the\n<em>relative</em> change of the fit residuals. For this reason, the penalty\nwill work as expected even if no reliable estimate of the <tt>noise</tt> is\navailable (see <a href=\"https://ui.adsabs.harvard.edu/abs/2004PASP..116..138C\" rel=\"nofollow\">Cappellari &amp; Emsellem (2004)</a> for details). If no\nreliable noise is available this keyword can just be set to:</p>\n<pre>noise = np.ones_like(galaxy)  # Same weight for all pixels\n</pre>\n</dd>\n<dt>velscale:</dt>\n<dd><p>Velocity scale of the spectra in km/s per pixel. It has to be the\nsame for both the galaxy and the template spectra.\nAn exception is when the <tt>velscale_ratio</tt> keyword is used, in which\ncase one can input <tt>templates</tt> with smaller <tt>velscale</tt> than\n<tt>galaxy</tt>.</p>\n<p><tt>velscale</tt> is <em>defined</em> in <tt>pPXF</tt> by\n<tt>velscale = c*Delta[np.log(lambda)]</tt>, which is approximately\n<tt>velscale ~ <span class=\"pre\">c*Delta(lambda)/lambda</span></tt>.\nSee Section 2.3 of <a href=\"https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C\" rel=\"nofollow\">Cappellari (2017)</a> for details.</p>\n</dd>\n<dt>start:</dt>\n<dd><p>Vector, or list/array of vectors <tt>[start1, start2, <span class=\"pre\">...]</span></tt>, with the\ninitial estimate for the LOSVD parameters.</p>\n<p>When LOSVD parameters are not held fixed, each vector only needs to\ncontain <tt>start = [velStart, sigmaStart]</tt> the initial guess for the\nvelocity and the velocity dispersion in km/s. The starting values for\nh3-h6 (if they are fitted) are all set to zero by default.\nIn other words, when <tt>moments=4</tt>:</p>\n<pre>start = [velStart, sigmaStart]\n</pre>\n<p>is interpreted as:</p>\n<pre>start = [velStart, sigmaStart, 0, 0]\n</pre>\n<p>When the LOSVD for some kinematic components is held fixed (see\n<tt>fixed</tt> keyword), all values for <tt>[Vel, Sigma, h3, <span class=\"pre\">h4,...]</span></tt> can be\nprovided.</p>\n<p>Unless a good initial guess is available, it is recommended to set the\nstarting <tt>sigma &gt;= 3*velscale</tt> in km/s (i.e. 3 pixels). In fact when\nthe sigma is very low, and far from the true solution, the <tt>chi^2</tt> of\nthe fit becomes weakly sensitive to small variations in sigma (see\n<tt>pPXF</tt> paper). In some instances, the near-constancy of <tt>chi^2</tt> may\ncause premature convergence of the optimization.</p>\n<p>In the case of two-sided fitting a good starting value for the velocity\nis <tt>velStart = 0.0</tt> (in this case <tt>vsyst</tt> will generally be\nnonzero). Alternatively on should keep in mind that velStart refers to\nthe first input galaxy spectrum, while the second will have velocity\n<tt><span class=\"pre\">-velStart</span></tt>.</p>\n<p>With multiple kinematic components <tt>start</tt> must be a list of starting\nvalues, one for each different component.</p>\n<p>EXAMPLE: We want to fit two kinematic components. We fit 4 moments for\nthe first component and 2 moments for the second one as follows:</p>\n<pre>component = [0, 0, ... 0, 1, 1, ... 1]\nmoments = [4, 2]\nstart = [[V1, sigma1], [V2, sigma2]]\n</pre>\n</dd>\n</dl>\n</div>\n<div id=\"optional-keywords\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Optional Keywords</a></h2>\n<dl>\n<dt>bias:</dt>\n<dd>This parameter biases the <tt>(h3, h4, <span class=\"pre\">...)</span></tt> measurements towards zero\n(Gaussian LOSVD) unless their inclusion significantly decreases the\nerror in the fit. Set this to <tt>bias=0</tt> not to bias the fit: the\nsolution (including <tt>[V, sigma]</tt>) will be noisier in that case. The\ndefault <tt>bias</tt> should provide acceptable results in most cases, but\nit would be safe to test it with Monte Carlo simulations. This keyword\nprecisely corresponds to the parameter <tt>lambda</tt> in the\n<a href=\"https://ui.adsabs.harvard.edu/abs/2004PASP..116..138C\" rel=\"nofollow\">Cappellari &amp; Emsellem (2004)</a> paper.\nNote that the penalty depends on the <em>relative</em> change of the fit\nresiduals, so it is insensitive to proper scaling of the <tt>noise</tt>\nvector. A nonzero <tt>bias</tt> can be safely used even without a reliable\n<tt>noise</tt> spectrum, or with equal weighting for all pixels.</dd>\n<dt>bounds:</dt>\n<dd><p>Lower and upper bounds for every kinematic parameter. This is an array,\nor list of arrays, with the same dimensions as <tt>start</tt>, except for\nthe last dimension, which is 2. In practice, for every element of\n<tt>start</tt> one needs to specify a pair of values <tt>[lower, upper]</tt>.</p>\n<p>EXAMPLE: We want to fit two kinematic components, with 4 moments for\nthe first component and 2 for the second (e.g. stars and gas). In this\ncase:</p>\n<pre>moments = [4, 2]\nstart_stars = [V1, sigma1, 0, 0]\nstart_gas = [V2, sigma2]\nstart = [start_stars, start_gas]\n</pre>\n<p>then we can specify boundaries for each kinematic parameter as:</p>\n<pre>bounds_stars = [[V1_lo, V1_up], [sigma1_lo, sigma1_up],\n                [-0.3, 0.3], [-0.3, 0.3]]\nbounds_gas = [[V2_lo, V2_up], [sigma2_lo, sigma2_up]]\nbounds = [bounds_stars, bounds_gas]\n</pre>\n</dd>\n<dt>component:</dt>\n<dd><p>When fitting more than one kinematic component, this keyword should\ncontain the component number of each input template. In principle every\ntemplate can belong to a different kinematic component.</p>\n<p>EXAMPLE: We want to fit the first 50 templates to component 0 and the\nlast 10 templates to component 1. In this case:</p>\n<pre>component = [0]*50 + [1]*10\n</pre>\n<p>which, in Python syntax, is equivalent to:</p>\n<pre>component = [0, 0, ... 0, 1, 1, ... 1]\n</pre>\n<p>This keyword is especially useful when fitting both emissions (gas) and\nabsorption (stars) templates simultaneously (see the example for\n<tt>moments</tt> keyword).</p>\n</dd>\n<dt>constr_templ:</dt>\n<dd><p>It enforces linear constraints on the template weights during the fit.\nThis is specified by the following dictionary, where <tt>A_ineq</tt> and\n<tt>A_eq</tt> are arrays (have <tt>A.ndim = 2</tt>), while <tt>b_ineq</tt> and <tt>b_eq</tt>\nare vectors (have <tt>b.ndim = 1</tt>). Either the <tt>_eq</tt> or the <tt>_ineq</tt>\nkeys can be omitted if not needed:</p>\n<pre>constr_templ = {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq, \"A_eq\": A_eq, \"b_eq\": b_eq}\n</pre>\n<p>The resulting pPXF solution will satisfy the following linear matrix\ninequalities and/or equalities:</p>\n<pre>A_ineq @ pp.weights &lt;= b_ineq\nA_eq @ pp.weights == b_eq\n</pre>\n<p>Inequality can be used e.g. to constrain the fluxes of emission lines to\nlie within prescribed ranges.\nEqualities can be used e.g. to force the weights for different kinematic\ncomponents to contain prescribed fractions of the total weights.</p>\n<p>EXAMPLES: We are fitting a spectrum using four templates, the first two\ntemplates belong to one kinematic component and the rest to the other.\nThis implies we have:</p>\n<pre>component=[0, 0, 1, 1]\n</pre>\n<p>then we can set the constraint that the sum of the weights of the first\nkinematic component is equal to <tt>fraction</tt> times the total as follows\n[cfr. equation 30 of <a href=\"https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C\" rel=\"nofollow\">Cappellari (2017)</a>]:</p>\n<pre>A_eq = [[fraction - 1, fraction - 1, fraction, fraction]]\nb_eq = [0]\nconstr_templ = {\"A_eq\": A_eq, \"b_eq\": b_eq}\n</pre>\n<p>An identical result can be obtained in this case using the <tt>fraction</tt>\nkeyword, but <tt>constr_templ</tt> additionally allows for general linear\nconstraints for multiple kinematic components.</p>\n<p>We can constrain the ratio of the first two templates weights to lie in\nthe interval <tt>ratio_min &lt;= <span class=\"pre\">w[0]/w[1]</span> &lt;= ratio_max</tt> as follows:</p>\n<pre>A_ineq = [[-1, ratio_min, 0, 0],    # -w[0] + ratio_min*w[1] &lt;= 0\n          [1, -ratio_max, 0, 0]]    # +w[0] - ratio_max*w[1] &lt;= 0\nb_ineq = [0, 0]\nconstr_templ = {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq}\n</pre>\n</dd>\n<dt>constr_kinem:</dt>\n<dd><p>It enforces linear constraints on the kinematic parameters during the fit.\nThis is specified by the following dictionary, where <tt>A_ineq</tt> and\n<tt>A_eq</tt> are arrays (have <tt>A.ndim = 2</tt>), while <tt>b_ineq</tt> and <tt>b_eq</tt>\nare vectors (have <tt>b.ndim = 1</tt>). Either the <tt>_eq</tt> or the <tt>_ineq</tt>\nkeys can be omitted if not needed:</p>\n<pre>constr_kinem = {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq, \"A_eq\": A_eq, \"b_eq\": b_eq}\n</pre>\n<p>The resulting pPXF kinematics solution will satisfy the following linear\nmatrix inequalities and/or equalities:</p>\n<pre>params = np.ravel(pp.sol)  # Unravel for multiple components\nA_ineq @ params &lt;= b_ineq\nA_eq @ params == b_eq\n</pre>\n<p>IMPORTANT: the starting guess <tt>start</tt> must satisfy the constraints,\nor in other words, it must lie in the feasible region.</p>\n<p>Inequalities can be used e.g. to force one kinematic component to have\nlarger velocity or dispersion than another one. This is useful e.g. when\nextracting two stellar kinematic components or when fitting both narrow\nand broad components of gas emission lines.</p>\n<p>EXAMPLES: We want to fit two kinematic components, with two moments for\nboth the first and second component. In this case:</p>\n<pre>moments = [2, 2]\nstart = [[V1, sigma1], [V2, sigma2]]\n</pre>\n<p>then we can set the constraint <tt>sigma1 &gt;= 3*sigma2</tt> as follows:</p>\n<pre>A_ineq = [[0, -1, 0, 3]]  # -sigma1 + 3*sigma2 &lt;= 0\nb_ineq = [0]\nconstr_kinem = {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq}\n</pre>\n<p>We can set the constraint <tt>sigma1 &gt;= sigma2 + 2*velscale</tt> as follows:</p>\n<pre>A_ineq = [[0, -1, 0, 1]]  # -sigma1 + sigma2 &lt;= -2*velscale\nb_ineq = [-2]             # kinem. in pixels (-2 --&gt; -2*velscale)!\nconstr_kinem =  {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq}\n</pre>\n<p>We can set both the constraints <tt>V1 &gt;= V2</tt> and\n<tt>sigma1 &gt;= sigma2 + 2*velscale</tt> as follows:</p>\n<pre>A_ineq = [[-1, 0, 1, 0],   # -V1 + V2 &lt;= 0\n          [0, -1, 0, 1]]   # -sigma1 + sigma2 &lt;= -2*velscale\nb_ineq = [0, -2]           # kinem. in pixels (-2 --&gt; -2*velscale)!\nconstr_kinem =  {\"A_ineq\": A_ineq, \"b_ineq\": b_ineq}\n</pre>\n</dd>\n<dt>clean:</dt>\n<dd><p>Set this keyword to use the iterative sigma clipping method described\nin Section 2.1 of <a href=\"http://ui.adsabs.harvard.edu/abs/2002ApJ...578..787C\" rel=\"nofollow\">Cappellari et al. (2002)</a>.\nThis is useful to remove from the fit unmasked bad pixels, residual gas\nemissions or cosmic rays.</p>\n<p>IMPORTANT: This is recommended <em>only</em> if a reliable estimate of the\n<tt>noise</tt> spectrum is available. See also note below for <tt>.chi2</tt>.</p>\n</dd>\n<dt>degree:</dt>\n<dd>Degree of the <em>additive</em> Legendre polynomial used to correct the\ntemplate continuum shape during the fit (default: 4).\nSet <tt><span class=\"pre\">degree=-1</span></tt> not to include any additive polynomial.</dd>\n<dt>fixed:</dt>\n<dd><p>Boolean vector set to <tt>True</tt> where a given kinematic parameter has to\nbe held fixed with the value given in <tt>start</tt>. This is an array, or\nlist, with the same dimensions as <tt>start</tt>.</p>\n<p>EXAMPLE: We want to fit two kinematic components, with 4 moments for\nthe first component and 2 for the second. In this case:</p>\n<pre>moments = [4, 2]\nstart = [[V1, sigma1, h3, h4], [V2, sigma2]]\n</pre>\n<p>then we can held fixed e.g. the sigma (only) of both components using:</p>\n<pre>fixed = [[0, 1, 0, 0], [0, 1]]\n</pre>\n<p>NOTE: Setting a negative <tt>moments</tt> for a kinematic component is\nentirely equivalent to setting <tt>fixed = 1</tt> for all parameters of the\ngiven kinematic component. In other words:</p>\n<pre>moments = [-4, 2]\n</pre>\n<p>is equivalent to:</p>\n<pre>moments = [4, 2]\nfixed = [[1, 1, 1, 1], [0, 0]]\n</pre>\n</dd>\n<dt>fraction:</dt>\n<dd><p>This keyword allows one to fix the ratio between the first two\nkinematic components. This is a scalar defined as follows:</p>\n<pre>fraction = np.sum(weights[component == 0])\n         / np.sum(weights[component &lt; 2])\n</pre>\n<p>This is useful e.g. to try to kinematically decompose bulge and disk.</p>\n<p>The remaining kinematic components (<tt>component &gt; 1</tt>) are left free,\nand this allows, for example, to still include gas emission line\ncomponents.\nMore general linear constraints, for multiple components at the same\ntime, can be specified using the <tt>constr_templ</tt> keyword.</p>\n</dd>\n<dt>ftol:</dt>\n<dd>Fractional tolerance for stopping the non-linear minimization (default\n1e-4).</dd>\n<dt>gas_component:</dt>\n<dd><p>Boolean vector, of the same size as <tt>component</tt>, set to <tt>True</tt>\nwhere the given <tt>component</tt> describes a gas emission line. If given,\n<tt>pPXF</tt> provides the <tt>pp.gas_flux</tt> and <tt>pp.gas_flux_error</tt> in\noutput.</p>\n<p>EXAMPLE: In the common situation where <tt>component = 0</tt> are stellar\ntemplates and the rest are gas emission lines, one will set:</p>\n<pre>gas_component = component &gt; 0\n</pre>\n<p>This keyword is also used to plot the gas lines with a different color.</p>\n</dd>\n<dt>gas_names:</dt>\n<dd>String array specifying the names of the emission lines (e.g.\n<tt><span class=\"pre\">gas_names=[\"Hbeta\",</span> <span class=\"pre\">\"[OIII]\",...]</span></tt>, one per gas line. The length of\nthis vector must match the number of nonzero elements in\n<tt>gas_component</tt>. This vector is only used by <tt>pPXF</tt> to print the\nline names on the console.</dd>\n<dt>gas_reddening:</dt>\n<dd>Set this keyword to an initial estimate of the gas reddening\n<tt><span class=\"pre\">E(B-V)</span> &gt;= 0</tt> to fit a positive gas reddening together with the\nkinematics and the templates. This reddening is applied only to the gas\ntemplates, namely to the templates with the corresponding element of\n<tt>gas_component=True</tt>. The fit assumes by default the extinction curve\nof <a href=\"http://ui.adsabs.harvard.edu/abs/2000ApJ...533..682C\" rel=\"nofollow\">Calzetti et al. (2000)</a> but any other\nprescription can be passed via the <tt>reddening_func</tt> keyword.</dd>\n<dt>goodpixels:</dt>\n<dd><p>Integer vector containing the indices of the good pixels in the\n<tt>galaxy</tt> spectrum (in increasing order). Only these spectral pixels\nare included in the fit.</p>\n<p>IMPORTANT: in all likely situations this keyword <em>has</em> to be specified.</p>\n</dd>\n<dt>lam:</dt>\n<dd><p>When the keyword <tt>reddening</tt> or <tt>gas_reddening</tt> are used, the user\nhas to pass in this keyword a vector with the same dimensions of\n<tt>galaxy</tt>, giving the restframe wavelength in Angstrom of every pixel\nin the input galaxy spectrum. If one uses my <tt>log_rebin</tt> routine to\nrebin the spectrum before the <tt>pPXF</tt> fit:</p>\n<pre>from ppxf.ppxf_util import log_rebin\nspecNew, logLam, velscale = log_rebin(lamRange, galaxy)\n</pre>\n<p>the wavelength can be obtained as <tt>lam = np.exp(logLam)</tt>.</p>\n<p>When <tt>lam</tt> is given, the wavelength is shown in the best-fitting\nplot, instead of the pixels.</p>\n</dd>\n<dt>linear:</dt>\n<dd>Set to <tt>True</tt> to keep <em>all</em> nonlinear parameters fixed and <em>only</em>\nperform a linear fit for the templates and additive polynomials\nweights. The output solution is a copy of the input one and the errors\nare zero.</dd>\n<dt>linear_method: {\u2018nnls\u2019, \u2018lsqlin\u2019, \u2018cvxopt\u2019} optional</dt>\n<dd><p>Method used for the solution of the linear least-squares subproblem\nto fit for the templates weights (default \u2018nnls\u2019).</p>\n<p>The computational speed of the three alternative linear methods depends\non the size of the problem, with \u2018lsqlin\u2019 or \u2018cvxopt\u2019 generally being\nfaster with smaller problem and \u2018nnls\u2019 being faster for larger ones.\n\u2018cvxopt\u2019, if installed, is a good alternative to the lighter \u2018lsqlin\u2019.\nTesting is recomended in your specific setup.</p>\n<p>The <tt>constr_templ</tt> and <tt>fraction</tt> keywords are only supported\nwith <tt><span class=\"pre\">method='lsqlin'</span></tt> or <tt><span class=\"pre\">method='cvxopt'</span></tt>.</p>\n<p>Before v7.0 <tt>pPXF</tt> only used the \u2018nnls\u2019 method.</p>\n</dd>\n<dt>mask:</dt>\n<dd>Boolean vector of length <tt>galaxy.size</tt> specifying with <tt>True</tt> the\npixels that should be included in the fit. This keyword is just an\nalternative way of specifying the <tt>goodpixels</tt>.</dd>\n<dt>method: {\u2018capfit\u2019, \u2018trf\u2019, \u2018dogbox\u2019, \u2018lm\u2019}, optional.</dt>\n<dd>Algorithm to perform the non-linear minimization step.\nThe default <tt>'capfit'</tt> is a novel trust-region implementation of the\nLevenberg-Marquardt method, extended to allow for general linear\nconstraints in a rigorous manner, while also supporting tied or fixed\nvariables. See documentation of <tt>scipy.optimize.least_squares</tt> for a\ndescription of the other methods.</dd>\n<dt>mdegree:</dt>\n<dd><p>Degree of the <em>multiplicative</em> Legendre polynomial (with a mean of 1)\nused to correct the continuum shape during the fit (default: 0). The\nzero degree multiplicative polynomial is always included in the fit as\nit corresponds to the weights assigned to the templates. Note that the\ncomputation time is longer with multiplicative polynomials than with\nthe same number of additive polynomials.</p>\n<p>IMPORTANT: Multiplicative polynomials cannot be used when the\n<tt>reddening</tt> keyword is set, as they are degenerate with the\nreddening.</p>\n</dd>\n<dt>moments:</dt>\n<dd><p>Order of the Gauss-Hermite moments to fit. Set this keyword to 4 to\nfit <tt>[h3, h4]</tt> and to 6 to fit <tt>[h3, h4, h5, h6]</tt>. Note that in all\ncases the G-H moments are fitted (non-linearly) <em>together</em> with\n<tt>[V, sigma]</tt>.</p>\n<p>If <tt>moments=2</tt> or <tt>moments</tt> is not set then only <tt>[V, sigma]</tt> are\nfitted.</p>\n<p>If <tt>moments</tt> is negative then the kinematics of the given\n<tt>component</tt> are kept fixed to the input values.\nNOTE: Setting a negative <tt>moments</tt> for a kinematic component is\nentirely equivalent to setting <tt>fixed = 1</tt> for all parameters of the\ngiven kinematic component.</p>\n<p>EXAMPLE: We want to keep fixed <tt>component = 0</tt>, which has a LOSVD\ndescribed by <tt>[V, sigma, h3, h4]</tt> and is modelled with 100 spectral\ntemplates; At the same time, we fit <tt>[V, sigma]</tt> for\n<tt>component = 1</tt>, which is described by 5 templates (this situation\nmay arise when fitting stellar templates with pre-determined stellar\nkinematics, while fitting the gas emission).\nWe should give in input to <tt>pPXF</tt> the following parameters:</p>\n<pre>component = [0]*100 + [1]*5   # --&gt; [0, 0, ... 0, 1, 1, 1, 1, 1]\nmoments = [-4, 2]\nstart = [[V, sigma, h3, h4], [V, sigma]]\n</pre>\n</dd>\n<dt>plot:</dt>\n<dd><p>Set this keyword to plot the best fitting solution and the residuals\nat the end of the fit.</p>\n<p>One can also call the class function <tt>pp.plot()</tt> after the call to\n<tt>pp = <span class=\"pre\">ppxf(...)</span></tt>.</p>\n</dd>\n<dt>quiet:</dt>\n<dd>Set this keyword to suppress verbose output of the best fitting\nparameters at the end of the fit.</dd>\n<dt>reddening:</dt>\n<dd><p>Set this keyword to an initial estimate of the stellar reddening\n<tt><span class=\"pre\">E(B-V)</span> &gt;= 0</tt> to fit a positive stellar reddening together with the\nkinematics and the templates. This reddening is applied only to the\nstellar templates, namely to the templates with the corresponding\nelement of <tt>gas_component=False</tt>, or to all templates, if\n<tt>gas_component</tt> is not set. The fit assumes by default the extinction\ncurve of <a href=\"http://ui.adsabs.harvard.edu/abs/2000ApJ...533..682C\" rel=\"nofollow\">Calzetti et al. (2000)</a> but any other prescription can be\npassed via the <tt>reddening_func</tt> keyword.</p>\n<p>IMPORTANT: The <tt>mdegree</tt> keyword cannot be used when <tt>reddening</tt> is\nset.</p>\n</dd>\n<dt>regul:</dt>\n<dd><p>If this keyword is nonzero, the program applies first or second order\nlinear regularization to the <tt>weights</tt> during the <tt>pPXF</tt> fit.\nRegularization is done in one, two or three dimensions depending on\nwhether the array of <tt>templates</tt> has two, three or four dimensions\nrespectively.\nLarge <tt>regul</tt> values correspond to smoother <tt>weights</tt> output. When\nthis keyword is nonzero the solution will be a trade-off between the\nsmoothness of <tt>weights</tt> and goodness of fit.</p>\n<p>Section 3.5 of <a href=\"https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C\" rel=\"nofollow\">Cappellari (2017)</a> gives a description of\nregularization.</p>\n<p>When fitting multiple kinematic <tt>component</tt> the regularization is\napplied only to the first <tt>component = 0</tt>, while additional\ncomponents are not regularized. This is useful when fitting stellar\npopulation together with gas emission lines. In that case, the SSP\nspectral templates must be given first and the gas emission templates\nare given last. In this situation, one has to use the <tt>reg_dim</tt>\nkeyword (below), to give <tt>pPXF</tt> the dimensions of the population\nparameters (e.g. <tt>nAge</tt>, <tt>nMetal</tt>, <tt>nAlpha</tt>). A usage example is\ngiven in the file <tt>ppxf_example_population_gas_sdss.py</tt>.</p>\n<p>The effect of the regularization scheme is the following:</p>\n<ul>\n<li>With <tt>reg_ord=1</tt> it enforces the numerical first derivatives\nbetween neighbouring weights (in the 1-dim case) to be equal to\n<tt>w[j] - w[j+1] = 0</tt> with an error <tt>Delta = 1/regul</tt>.</li>\n<li>With <tt>reg_ord=2</tt> it enforces the numerical second derivatives\nbetween neighboring weights (in the 1-dim case) to be equal to\n<tt><span class=\"pre\">w[j-1]</span> - 2*w[j] + w[j+1] = 0</tt> with an error <tt>Delta = 1/regul</tt>.</li>\n</ul>\n<p>It may be helpful to define <tt>regul = 1/Delta</tt> and think of <tt>Delta</tt>\nas the regularization error.</p>\n<p>IMPORTANT: <tt>Delta</tt> needs to be smaller but of the same order of\nmagnitude of the typical <tt>weights</tt> to play an effect on the\nregularization. One quick way to achieve this is:</p>\n<ol>\n<li><p>Divide the full <tt>templates</tt> array by a scalar in such a way that\nthe typical template has a median of one:</p>\n<pre>templates /= np.median(templates)\n</pre>\n</li>\n<li><p>Do the same for the input galaxy spectrum:</p>\n<pre>galaxy /= np.median(galaxy)\n</pre>\n</li>\n<li><p>In this situation, a sensible guess for <tt>Delta</tt> will be a few\npercent (e.g. <tt>0.01 <span class=\"pre\">--&gt;</span> regul=100</tt>).</p>\n</li>\n</ol>\n<p>Alternatively, for a more rigorous definition of the parameter\n<tt>regul</tt>:</p>\n<ol>\n<li><p>Perform an un-regularized fit (<tt>regul=0</tt>) and then rescale the\ninput <tt>noise</tt> spectrum so that:</p>\n<pre>Chi^2/DOF = Chi^2/goodPixels.size = 1.\n</pre>\n<p>This is achieved by rescaling the input <tt>noise</tt> spectrum as:</p>\n<pre>noise = noise*sqrt(Chi**2/DOF) = noise*sqrt(pp.chi2);\n</pre>\n</li>\n<li><p>Increase <tt>regul</tt> and iteratively redo the <tt>pPXF</tt> fit until the\n<tt>Chi^2</tt> increases from the unregularized value\n<tt>Chi^2 = goodPixels.size</tt> by\n<tt>DeltaChi^2 = sqrt(2*goodPixels.size)</tt>.</p>\n</li>\n</ol>\n<p>The derived regularization corresponds to the maximum one still\nconsistent with the observations and the derived star formation history\nwill be the smoothest (minimum curvature or minimum variation) that is\nstill consistent with the observations.</p>\n</dd>\n<dt>reg_dim:</dt>\n<dd><p>When using regularization with more than one kinematic component (using\nthe <tt>component</tt> keyword), the regularization is only applied to the\nfirst one (<tt>component=0</tt>). This is useful to fit the stellar\npopulation and gas emission together.</p>\n<p>In this situation, one has to use the <tt>reg_dim</tt> keyword, to give\n<tt>pPXF</tt> the dimensions of the population parameters (e.g. <tt>nAge</tt>,\n<tt>nMetal</tt>, <tt>nAlpha</tt>). One should creates the initial array of\npopulation templates like e.g.\n<tt>templates[nPixels, nAge, nMetal, nAlpha]</tt> and define:</p>\n<pre>reg_dim = templates.shape[1:]   # = [nAge, nMetal, nAlpha]\n</pre>\n<p>The array of stellar templates is then reshaped into a 2-dim array as:</p>\n<pre>templates = templates.reshape(templates.shape[0], -1)\n</pre>\n<p>and the gas emission templates are appended as extra columns at the\nend. An usage example is given in\n<tt>ppxf_example_population_gas_sdss.py</tt>.</p>\n<p>When using regularization with a single component (the <tt>component</tt>\nkeyword is not used, or contains identical values), the number of\npopulation templates along different dimensions (e.g. <tt>nAge</tt>,\n<tt>nMetal</tt>, <tt>nAlpha</tt>) is inferred from the dimensions of the\n<tt>templates</tt> array and this keyword is not necessary.</p>\n</dd>\n<dt>reg_ord:</dt>\n<dd><p>Order of the derivative that is minimized by the regularization.\nThe following two rotationally-symmetric estimators are supported:</p>\n<ul>\n<li><p><tt>reg_ord=1</tt>: minimizes the integral over the weights of the squared\ngradient:</p>\n<pre>Grad[w] @ Grad[w].\n</pre>\n</li>\n<li><p><tt>reg_ord=2</tt>: minimizes the integral over the weights of the squared\ncurvature:</p>\n<pre>Laplacian[w]**2.\n</pre>\n</li>\n</ul>\n</dd>\n<dt>sigma_diff:</dt>\n<dd><p>Quadratic difference in km/s defined as:</p>\n<pre>sigma_diff**2 = sigma_inst**2 - sigma_temp**2\n</pre>\n<p>between the instrumental dispersion of the galaxy spectrum and the\ninstrumental dispersion of the template spectra.</p>\n<p>This keyword is useful when the templates have higher resolution than\nthe galaxy and they were not convolved to match the instrumental\ndispersion of the galaxy spectrum. In this situation, the convolution\nis done by <tt>pPXF</tt> with increased accuracy, using an analytic Fourier\nTransform.</p>\n</dd>\n<dt>sky:</dt>\n<dd><p>vector containing the spectrum of the sky to be included in the fit, or\narray of dimensions <tt>sky[nPixels, nSky]</tt> containing different sky\nspectra to add to the model of the observed <tt>galaxy</tt> spectrum. The\n<tt>sky</tt> has to be log-rebinned as the <tt>galaxy</tt> spectrum and needs to\nhave the same number of pixels.</p>\n<p>The sky is generally subtracted from the data before the <tt>pPXF</tt> fit.\nHowever, for observations very heavily dominated by the sky spectrum,\nwhere a very accurate sky subtraction is critical, it may be useful\n<em>not</em> to subtract the sky from the spectrum, but to include it in the\nfit using this keyword.</p>\n</dd>\n<dt>templates_rfft:</dt>\n<dd><p>When calling <tt>pPXF</tt> many times with an identical set of templates,\none can use this keyword to pass the real FFT of the templates,\ncomputed in a previous <tt>pPXF</tt> call, stored in the\n<tt>pp.templates_rfft</tt> attribute. This keyword mainly exists to show\nthat there is no need for it\u2026</p>\n<p>IMPORTANT: Use this keyword only if you understand what you are doing!</p>\n</dd>\n<dt>tied:</dt>\n<dd><p>A list of string expressions. Each expression \u201cties\u201d the parameter to\nother free or fixed parameters.  Any expression involving constants and\nthe parameter array <tt>p[j]</tt> are permitted. Since they are totally\nconstrained, tied parameters are considered to be fixed; no errors are\ncomputed for them.</p>\n<p>This is an array, or list of arrays, with the same dimensions as\n<tt>start</tt>. In practice, for every element of <tt>start</tt> one needs to\nspecify either an empty string <tt>''</tt> implying that the parameter is\nfree, or a string expression involving some of the variables <tt>p[j]</tt>,\nwhere <tt>j</tt> represents the index of the flattened list of kinematic\nparameters.</p>\n<p>EXAMPLE: We want to fit three kinematic components, with 4 moments for\nthe first component and 2 moments for the second and third (e.g. stars\nand two gas components). In this case:</p>\n<pre>moments = [4, 2, 2]\nstart = [[V1, sigma1, 0, 0], [V2, sigma2], [V3, sigma3]]\n</pre>\n<p>then we can force the equality constraint <tt>V2 = V3</tt> as follows:</p>\n<pre>tied = [['', '', '', ''], ['', ''], ['p[4]', '']]\n</pre>\n<p>or we can force the equality constraint <tt>sigma2 = sigma3</tt> as\nfollows:</p>\n<pre>tied = [['', '', '', ''], ['', ''], ['', 'p[5]']]\n</pre>\n<p>NOTE: One could in principle use the <tt>tied</tt> keyword to completely tie\nthe LOSVD of two kinematic components. However, this same effect is more\nefficient achieved by assigning them to the same kinematic component\nusing the <tt>component</tt> keyword.</p>\n</dd>\n<dt>trig:</dt>\n<dd><p>Set <tt>trig=True</tt> to use trigonometric series as an alternative to\nLegendre polynomials, for both the additive and multiplicative\npolynomials. When <tt>trig=True</tt> the fitted series below has\n<tt>N = degree/2</tt> or <tt>N = mdegree/2</tt>:</p>\n<pre>poly = A_0 + sum_{n=1}^{N} [A_n*cos(n*th) + B_n*sin(n*th)]\n</pre>\n<p>IMPORTANT: The trigonometric series has periodic boundary conditions.\nThis is sometimes a desirable property, but this expansion is not as\nflexible as the Legendre polynomials.</p>\n</dd>\n<dt>velscale_ratio:</dt>\n<dd><p>Integer. Gives the integer <tt>ratio &gt;= 1</tt> between the <tt>velscale</tt> of\nthe <tt>galaxy</tt> and the <tt>templates</tt>. When this keyword is used, the\ntemplates are convolved by the LOSVD at their native resolution, and\nonly subsequently are integrated over the pixels and fitted to\n<tt>galaxy</tt>. This keyword is generally unnecessary and mostly useful for\ntesting.</p>\n<p>Note that in realistic situations the uncertainty in the knowledge and\nvariations of the intrinsic line-spread function become the limiting\nfactor in recovering the LOSVD well below <tt>velscale</tt>.</p>\n</dd>\n<dt>vsyst:</dt>\n<dd><p>Reference velocity in <tt>km/s</tt> (default 0). The input initial guess and\nthe output velocities are measured with respect to this velocity. This\nkeyword is generally used to account for the difference in the starting\nwavelength of the templates and the galaxy spectrum as follows:</p>\n<pre>vsyst = c*np.log(wave_temp[0]/wave_gal[0])\n</pre>\n<p>The value assigned to this keyword is <em>crucial</em> for the two-sided\nfitting. In this case <tt>vsyst</tt> can be determined from a previous\nnormal one-sided fit to the galaxy velocity profile. After that initial\nfit, <tt>vsyst</tt> can be defined as the measured velocity at the galaxy\ncenter. More accurately <tt>vsyst</tt> is the value which has to be\nsubtracted to obtain a nearly anti-symmetric velocity profile at the\ntwo opposite sides of the galaxy nucleus.</p>\n<p>IMPORTANT: this value is generally <em>different</em> from the systemic\nvelocity one can get from the literature. Do not try to use that!</p>\n</dd>\n</dl>\n</div>\n<div id=\"output-parameters\">\n<h2><a href=\"#id11\" rel=\"nofollow\">Output Parameters</a></h2>\n<p>Stored as attributes of the <tt>pPXF</tt> class:</p>\n<dl>\n<dt>.apoly:</dt>\n<dd>Vector with the best fitting additive polynomial.</dd>\n<dt>.bestfit:</dt>\n<dd>Vector with the best fitting model for the galaxy spectrum.\nThis is a linear combination of the templates, convolved with the best\nfitting LOSVD, multiplied by the multiplicative polynomials and\nwith subsequently added polynomial continuum terms or sky components.</dd>\n<dt>.chi2:</dt>\n<dd><p>The reduced <tt>chi^2</tt> (namely <tt>chi^2/DOF</tt>) of the fit\n(where <tt>DOF ~ pp.goodpixels.size</tt>).</p>\n<p>IMPORTANT: if <tt>Chi^2/DOF</tt> is not ~1 it means that the errors are not\nproperly estimated, or that the template is bad and it is <em>not</em> safe to\nset the <tt>clean</tt> keyword.</p>\n</dd>\n<dt>.error:</dt>\n<dd><p>This variable contains a vector of <em>formal</em> uncertainty (<tt>1*sigma</tt>)\nfor the fitted parameters in the output vector <tt>sol</tt>. This option can\nbe used when speed is essential, to obtain an order of magnitude\nestimate of the uncertainties, but we <em>strongly</em> recommend to run\nbootstrapping simulations to obtain more reliable errors. In fact these\nerrors can be severely underestimated in the region where the penalty\neffect is most important (<tt>sigma &lt; 2*velscale</tt>).</p>\n<p>These errors are meaningless unless <tt>Chi^2/DOF ~ 1</tt>. However if one\n<em>assumes</em> that the fit is good, a corrected estimate of the errors is:</p>\n<pre>error_corr = error*sqrt(chi^2/DOF) = pp.error*sqrt(pp.chi2).\n</pre>\n<p>IMPORTANT: when running Monte Carlo simulations to determine the error,\nthe penalty (<tt>bias</tt>) should be set to zero, or better to a very small\nvalue. See Section 3.4 of <a href=\"https://ui.adsabs.harvard.edu/abs/2004PASP..116..138C\" rel=\"nofollow\">Cappellari &amp; Emsellem (2004)</a> for an\nexplanation.</p>\n</dd>\n<dt>.gas_bestfit:</dt>\n<dd>If <tt>gas_component</tt> is not <tt>None</tt>, this attribute returns the\nbest-fitting gas spectrum alone. The stellar spectrum alone can be\ncomputed as <tt>stellar_spectrum = pp.bestfit - pp.gas_bestfit</tt></dd>\n<dt>.gas_flux:</dt>\n<dd><p>Vector with the integrated flux (in counts) of all lines set as\n<tt>True</tt> in the input <tt>gas_component</tt> keyword. This is the flux of\nindividual gas templates, which may include multiple lines.\nThis implies that, if a gas template describes a doublet, the flux is\nthat of both lines. If the Balmer series is input as a single template,\nthis is the flux of the entire series.</p>\n<p>The returned fluxes are not corrected in any way and in particular, no\nreddening correction is applied. In other words, the returned\n<tt>.gas_flux</tt> should be unchanged, within the errors, regardless of\nwhether reddening or multiplicative polynomials were fitted by <tt>pPXF</tt>\nor not. The fluxes are just raw values as one could measure (with lower\naccuracy) by summing the pixels, within the given gas lines, on the\ncontinuum-subtracted input galaxy spectrum.</p>\n<p>IMPORTANT: <tt>pPXF</tt> makes no assumptions about the input flux units:\nThe returned <tt>.gas_flux</tt> has the same units as the quantity one would\nobtain by just summing the values of the spectral pixels within the gas\nemission. This implies that, if the spectrum is in units of\n<tt><span class=\"pre\">erg/(cm^2</span> s A)</tt>, the gas flux returned by <tt>pPXF</tt> should be\nmultiplied by the pixel size in Angstrom at the line wavelength to\nobtain the integrated line flux in units of <tt><span class=\"pre\">erg/(cm^2</span> s)</tt>.</p>\n<p>NOTE: If there is no gas reddening and each input gas templates was\nnormalized to <tt>sum = 1</tt>, then\n<tt>pp.gas_flux = pp.weights[pp.gas_component]</tt>.</p>\n<p>When a gas template is identically zero within the fitted region, then\n<tt>pp.gas_flux = pp.gas_flux_error = np.nan</tt>. The corresponding\ncomponents of <tt>pp.gas_zero_template</tt> are set to <tt>True</tt>. These\n<tt>np.nan</tt> values are set at the end of the calculation to flag the\nundefined values. They do <em>not</em> indicate numerical issues with the\nactual <tt>pPXF</tt> calculation, and the rest of the <tt>pPXF</tt> output is\nreliable.</p>\n</dd>\n<dt>.gas_flux_error:</dt>\n<dd><p><em>Formal</em> uncertainty (<tt>1*sigma</tt>) for the quantity <tt>pp.gas_flux</tt>, in\nthe same units as the gas fluxes.</p>\n<p>This error is approximate as it ignores the covariance between the gas\nflux and any non-linear parameter. Bootstrapping can be used for more\naccurate errors.</p>\n<p>These errors are meaningless unless <tt>Chi^2/DOF ~ 1</tt>. However if one\n<em>assumes</em> that the fit is good, a corrected estimate of the errors is:</p>\n<pre>gas_flux_error_corr = gas_flux_error*sqrt(chi^2/DOF)\n                    = pp.gas_flux_error*sqrt(pp.chi2).\n</pre>\n</dd>\n<dt>.gas_mpoly:</dt>\n<dd>vector with the best-fitting gas reddening curve.</dd>\n<dt>.gas_reddening:</dt>\n<dd>Best fitting <tt><span class=\"pre\">E(B-V)</span></tt> value if the <tt>gas_reddening</tt> keyword is set.\nThis is especially useful when the Balmer series is input as a single\ntemplate with an assumed theoretically predicted decrement e.g. using\n<tt><span class=\"pre\">emission_lines(...,</span> tie_balmer=True)</tt> in <tt>ppxf.ppxf_util</tt> to\ncompute the gas templates.</dd>\n<dt>.gas_zero_template:</dt>\n<dd>vector of size <tt>gas_component.sum()</tt> set to <tt>True</tt> where\nthe gas template was identically zero within the fitted region.\nFor those gas components <tt>pp.gas_flux = pp.gas_flux_error = np.nan</tt>.</dd>\n<dt>.goodpixels:</dt>\n<dd>Integer vector containing the indices of the good pixels in the fit.\nThis vector is a copy of the input <tt>goodpixels</tt> if <tt>clean = False</tt>\notherwise it will be updated by removing the detected outliers.</dd>\n<dt>.matrix:</dt>\n<dd><p>Prediction <tt>matrix[nPixels, degree+nTemplates]</tt> of the linear system.</p>\n<p><tt>pp.matrix[nPixels, :degree]</tt> contains the additive polynomials if\n<tt>degree &gt;= 0</tt>.</p>\n<p><tt>pp.matrix[nPixels, degree:]</tt> contains the templates convolved by the\nLOSVD, and multiplied by the multiplicative polynomials if\n<tt>mdegree &gt; 0</tt>.</p>\n</dd>\n<dt>.mpoly:</dt>\n<dd>Best fitting multiplicative polynomial (or reddening curve when\n<tt>reddening</tt> is set).</dd>\n<dt>.mpolyweights:</dt>\n<dd><p>This is largely superseded by the <tt>.mpoly</tt> attribute above.</p>\n<p>When <tt>mdegree &gt; 0</tt> this contains in output the coefficients of the\nmultiplicative Legendre polynomials of order <tt>1, <span class=\"pre\">2,...</span> mdegree</tt>.\nThe polynomial can be explicitly evaluated as:</p>\n<pre>from numpy.polynomial import legendre\nx = np.linspace(-1, 1, len(galaxy))\nmpoly = legendre.legval(x, np.append(1, pp.mpolyweights))\n</pre>\n<p>When <tt>trig = True</tt> the polynomial is evaluated as:</p>\n<pre>mpoly = pp.trigval(x, np.append(1, pp.mpolyweights))\n</pre>\n</dd>\n<dt>.polyweights:</dt>\n<dd><p>This is largely superseded by the <tt>.apoly</tt> attribute above.</p>\n<p>When <tt>degree &gt;= 0</tt> contains the weights of the additive Legendre\npolynomials of order <tt>0, <span class=\"pre\">1,...</span> degree</tt>. The best fitting additive\npolynomial can be explicitly evaluated as:</p>\n<pre>from numpy.polynomial import legendre\nx = np.linspace(-1, 1, len(galaxy))\napoly = legendre.legval(x, pp.polyweights)\n</pre>\n<p>When <tt>trig=True</tt> the polynomial is evaluated as:</p>\n<pre>apoly = pp.trigval(x, pp.polyweights)\n</pre>\n<p>When doing a two-sided fitting (see help for <tt>galaxy</tt> parameter), the\nadditive polynomials are allowed to be different for the left and right\nspectrum. In that case, the output weights of the additive polynomials\nalternate between the first (left) spectrum and the second (right)\nspectrum.</p>\n</dd>\n<dt>.reddening:</dt>\n<dd>Best fitting <tt><span class=\"pre\">E(B-V)</span></tt> value if the <tt>reddening</tt> keyword is set.</dd>\n<dt>.sol:</dt>\n<dd><p>Vector containing in output the parameters of the kinematics.</p>\n<ul>\n<li>If <tt>moments=2</tt> this contains <tt>[Vel, Sigma]</tt></li>\n<li>If <tt>moments=4</tt> this contains <tt>[Vel, Sigma, h3, h4]</tt></li>\n<li>If <tt>moments=N</tt> this contains <tt>[Vel, Sigma, <span class=\"pre\">h3,...</span> hN]</tt></li>\n</ul>\n<p>When fitting multiple kinematic <tt>component</tt>, <tt>pp.sol</tt> contains a\nlist with the solution for all different components, one after the\nother, sorted by <tt>component</tt>: <tt>pp.sol = [sol1, <span class=\"pre\">sol2,...]</span></tt>.</p>\n<p><tt>Vel</tt> is the velocity, <tt>Sigma</tt> is the velocity dispersion,\n<tt>h3 - h6</tt> are the Gauss-Hermite coefficients. The model parameters\nare fitted simultaneously.</p>\n<p>IMPORTANT: The precise relation between the output <tt>pPXF</tt> velocity\nand redshift is <tt>Vel = c*np.log(1 + z)</tt>. See Section 2.3 of\n<a href=\"https://ui.adsabs.harvard.edu/abs/2017MNRAS.466..798C\" rel=\"nofollow\">Cappellari (2017)</a> for a detailed explanation.</p>\n<p>These are the default safety limits on the fitting parameters\n(they can be changed using the <tt>bounds</tt> keyword):</p>\n<ul>\n<li>Vel is constrained to be +/-2000 km/s from the first input guess</li>\n<li><tt>velscale/100 &lt; Sigma &lt; 1000</tt> km/s</li>\n<li><tt><span class=\"pre\">-0.3</span> &lt; [h3, h4, <span class=\"pre\">...]</span> &lt; 0.3</tt>  (extreme value for real galaxies)</li>\n</ul>\n<p>In the case of two-sided LOSVD fitting the output values refer to the\nfirst input galaxy spectrum, while the second spectrum will have by\nconstruction kinematics parameters <tt><span class=\"pre\">[-Vel,</span> Sigma, <span class=\"pre\">-h3,</span> h4, <span class=\"pre\">-h5,</span> h6]</tt>.\nIf <tt>vsyst</tt> is nonzero (as required for two-sided fitting), then the\noutput velocity is measured with respect to <tt>vsyst</tt>.</p>\n</dd>\n<dt>.status:</dt>\n<dd>Contains the output status of the optimization. Positive values\ngenerally represent success (the status is defined as in\n<tt>scipy.optimize.least_squares</tt>).</dd>\n<dt>.weights:</dt>\n<dd><p>Receives the value of the weights by which each template was\nmultiplied to best fit the galaxy spectrum. The optimal template can be\ncomputed with an array-vector multiplication:</p>\n<pre>bestemp = templates @ weights\n</pre>\n<p>These weights do not include the weights of the additive polynomials\nwhich are separately stored in <tt>pp.polyweights</tt>.</p>\n<p>When the <tt>sky</tt> keyword is used <tt><span class=\"pre\">weights[:nTemplates]</span></tt> contains the\nweights for the templates, while <tt>weights[nTemplates:]</tt> gives the\nones for the sky. In that case the best fitting galaxy template and sky\nare given by:</p>\n<pre>bestemp = templates @ weights[:nTemplates]\nbestsky = sky @ weights[nTemplates:]\n</pre>\n<p>When doing a two-sided fitting (see help for <tt>galaxy</tt> parameter)\n<em>together</em> with the <tt>sky</tt> keyword, the sky weights are allowed to be\ndifferent for the left and right spectrum. In that case the output sky\nweights alternate between the first (left) spectrum and the second\n(right) spectrum.</p>\n</dd>\n</dl>\n</div>\n<div id=\"how-to-set-regularization\">\n<h2><a href=\"#id12\" rel=\"nofollow\">How to Set Regularization</a></h2>\n<p>The <tt>pPXF</tt> routine can give sensible quick results with the default\n<tt>bias</tt> parameter, however, like in any penalized/filtered/regularized\nmethod, the optimal amount of penalization generally depends on the problem\nunder study.</p>\n<p>The general rule here is that the penalty should leave the line-of-sight\nvelocity-distribution (LOSVD) virtually unaffected, when it is well sampled\nand the signal-to-noise ratio (<tt>S/N</tt>) is sufficiently high.</p>\n<p>EXAMPLE: If you expect a LOSVD with up to a high <tt>h4 ~ 0.2</tt> and your\nadopted penalty (<tt>bias</tt>) biases the solution towards a much lower\n<tt>h4 ~ 0.1</tt>, even when the measured <tt>sigma &gt; 3*velscale</tt> and the S/N is\nhigh, then you are <em>misusing</em> the <tt>pPXF</tt> method!</p>\n<p>THE RECIPE: The following is a simple practical recipe for a sensible\ndetermination of the penalty in <tt>pPXF</tt>:</p>\n<ol>\n<li>Choose a minimum <tt>(S/N)_min</tt> level for your kinematics extraction and\nspatially bin your data so that there are no spectra below\n<tt>(S/N)_min</tt>;</li>\n<li>Perform a fit of your kinematics <em>without</em> penalty (keyword <tt>bias=0</tt>).\nThe solution will be noisy and may be affected by spurious solutions,\nhowever, this step will allow you to check the expected mean ranges in\nthe Gauss-Hermite parameters <tt>[h3, h4]</tt> for the galaxy under study;</li>\n<li>Perform a Monte Carlo simulation of your spectra, following e.g. the\nincluded <tt>ppxf_example_simulation.py</tt> routine. Adopt as <tt>S/N</tt> in the\nsimulation the chosen value <tt>(S/N)_min</tt> and as input <tt>[h3, h4]</tt> the\nmaximum representative values measured in the non-penalized <tt>pPXF</tt> fit\nof the previous step;</li>\n<li>Choose as the penalty (<tt>bias</tt>) the <em>largest</em> value such that, for\n<tt>sigma &gt; 3*velscale</tt>, the mean difference delta between the output\n<tt>[h3, h4]</tt> and the input <tt>[h3, h4]</tt> is well within (e.g.\n<tt>delta ~ rms/3</tt>) the rms scatter of the simulated values (see an\nexample in Fig. 2 of <a href=\"http://ui.adsabs.harvard.edu/abs/2004MNRAS.352..721E\" rel=\"nofollow\">Emsellem et al. 2004</a>).</li>\n</ol>\n</div>\n<div id=\"problems-with-your-first-fit\">\n<h2><a href=\"#id13\" rel=\"nofollow\">Problems with Your First Fit?</a></h2>\n<p>Common problems with your first <tt>pPXF</tt> fit are caused by incorrect\nwavelength ranges or different velocity scales between galaxy and\ntemplates. To quickly detect these problems try to overplot the (log\nrebinned) galaxy and the template just before calling the <tt>pPXF</tt>\nprocedure.</p>\n<p>You can use something like the following Python lines while adjusting the\nsmoothing window and the pixels shift. If you cannot get a rough match\nby eye it means something is wrong and it is unlikely that <tt>pPXF</tt>\n(or any other program) will find a good match:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"kn\">import</span> <span class=\"nn\">scipy.ndimage</span>\n\n<span class=\"n\">sigma</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>       <span class=\"c1\"># Velocity dispersion in pixels</span>\n<span class=\"n\">shift</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">20</span>     <span class=\"c1\"># Velocity shift in pixels</span>\n<span class=\"n\">template</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">roll</span><span class=\"p\">(</span><span class=\"n\">ndimage</span><span class=\"o\">.</span><span class=\"n\">gaussian_filter1d</span><span class=\"p\">(</span><span class=\"n\">template</span><span class=\"p\">,</span> <span class=\"n\">sigma</span><span class=\"p\">),</span> <span class=\"n\">shift</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">galaxy</span><span class=\"p\">,</span> <span class=\"s1\">'k'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">template</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">median</span><span class=\"p\">(</span><span class=\"n\">galaxy</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">median</span><span class=\"p\">(</span><span class=\"n\">template</span><span class=\"p\">),</span> <span class=\"s1\">'r'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<hr class=\"docutils\">\n<div id=\"license\">\n<h2><a href=\"#id14\" rel=\"nofollow\">License</a></h2>\n<p>Other/Proprietary License</p>\n<p>Copyright (c) 2001-2020 Michele Cappellari</p>\n<p>This software is provided as is without any warranty whatsoever.\nPermission to use, for non-commercial purposes is granted.\nPermission to modify for personal or internal use is granted,\nprovided this copyright and disclaimer are included in all\ncopies of the software. All other rights are reserved.\nIn particular, redistribution of the code is not allowed.</p>\n</div>\n<div id=\"changelog\">\n<h2><a href=\"#id15\" rel=\"nofollow\">Changelog</a></h2>\n<div id=\"v7-2-0-mc-oxford-4-may-2020\">\n<h3>V7.2.0: MC, Oxford, 4 May 2020</h3>\n<ul>\n<li>Allow for <tt><span class=\"pre\">linear_method='cvxopt'</span></tt> when the optional <tt>cvxopt</tt> package\nis installed.</li>\n</ul>\n</div>\n<div id=\"v7-1-0-mc-oxford-30-april-2020\">\n<h3>V7.1.0: MC, Oxford, 30 April 2020</h3>\n<ul>\n<li>Introduced new <tt>ppxf</tt> keyword <tt>linear_method</tt>, and corresponding changes\nin the code, to select between the old (\u2018nnls\u2019) and the new (\u2018lsqlin\u2019)\napproach to the solution of the linear least-squares subproblem in <tt>ppxf</tt>.\nThanks to Sam Vaughan (sydney.edu.au) for a convincing minimal example\nillustrating the usefulness of this keyword.</li>\n</ul>\n</div>\n<div id=\"v7-0-1-mc-oxford-8-april-2020\">\n<h3>V7.0.1: MC, Oxford, 8 April 2020</h3>\n<ul>\n<li>Support <tt>.gas_zero_template</tt> and <tt>fraction</tt> together with other\nequality constraints.</li>\n<li>Included <tt><span class=\"pre\">np.pad(...mode='constant')</span></tt> for backward compatibility with\nNumpy 1.16. Thanks to Shravan Shetty (KIAA-PKU) for the suggestion.</li>\n<li>Fix <tt>rebin()</tt> not retaining the dimensionality of an input column-vector.\nThis resulted in a program stop with a single gas template and\n<tt>velscale_ratio &gt; 1</tt>. Thanks to Zhiyuan Ji (astro.umass.edu) for a clear\nexample reproducing the bug.</li>\n<li><tt>capfit</tt>: New keyword <tt>cond</tt> for <tt>lsqlin</tt>.</li>\n<li><tt>capfit</tt>: Relaxed assertion for inconsistent inequalities in <tt>lsqlin</tt>\nto avoid false positives. Thanks to Kyle Westfall (UCO Lick) for a detailed\nbug report.</li>\n</ul>\n</div>\n<div id=\"v7-0-0-mc-oxford-10-january-2020\">\n<h3>V7.0.0: MC, Oxford, 10 January 2020</h3>\n<ul>\n<li><tt>capfit</tt>: New general linear least-squares optimization function\n<tt>lsqlin</tt> which is now used to solve the quadratic subproblem.</li>\n<li><tt>capfit</tt>: Allow for linear inequality/equality constraints\n<tt>A_ineq</tt>, <tt>b_ineq</tt> and  <tt>A_eq</tt>, <tt>b_eq</tt>.</li>\n<li><tt>ppxf</tt>: Use (faster) <tt>capfit.lsqlin</tt> for the linear fit.</li>\n<li><tt>ppxf</tt>: Use updated <tt>capfit.capfit</tt> for the non-linear optimization.</li>\n<li><tt>ppxf</tt>: Allow for linear equalities/inequalities for both the template\nweights and the kinematic parameters with the <tt>constr_templ</tt> and\n<tt>constr_kinem</tt> optional keywords.</li>\n<li><tt>ppxf</tt>: New <tt>set_linear_constraints</tt> function.</li>\n<li><tt>ppxf</tt>: Updated documentation.</li>\n</ul>\n</div>\n<div id=\"v6-7-17-mc-oxford-14-november-2019\">\n<h3>V6.7.17: MC, Oxford, 14 November 2019</h3>\n<ul>\n<li><tt>capfit</tt>: Written complete documentation.</li>\n<li><tt>capfit</tt>: Improved print formatting.</li>\n<li><tt>capfit</tt>: Return <tt>.message</tt> attribute.</li>\n<li><tt>capfit</tt>: Improved <tt>xtol</tt> convergence test.</li>\n<li><tt>capfit</tt>: Only accept final move if <tt>chi2</tt> decreased.</li>\n<li><tt>capfit</tt>: Strictly satisfy bounds during Jacobian computation.</li>\n</ul>\n</div>\n<div id=\"v6-7-16-mc-oxford-12-june-2019\">\n<h3>V6.7.16: MC, Oxford, 12 June 2019</h3>\n<ul>\n<li><tt>capfit</tt>: Use only free parameters for <tt>xtol</tt> convergence test.</li>\n<li><tt>capfit</tt>: Describe in words convergence status with nonzero <tt>verbose</tt>.</li>\n<li><tt>capfit</tt>: Fixed program stop when <tt>abs_step</tt> is undefined.</li>\n<li><tt>capfit</tt>: Fixed ignoring optional <tt>max_nfev</tt>.</li>\n</ul>\n</div>\n<div id=\"v6-7-15-mc-oxford-7-february-2019\">\n<h3>V6.7.15: MC, Oxford, 7 February 2019</h3>\n<ul>\n<li>Removed unused <tt>re</tt> import.</li>\n<li>Removed Scipy\u2019s <tt>next_fast_len</tt> usage due to an issue with odd padding size.\nThanks to Eric Emsellem (ESO) for a clear example illustrating this rare and\nsubtle bug.</li>\n</ul>\n</div>\n<div id=\"v6-7-14-mc-oxford-27-november-2018\">\n<h3>V6.7.14: MC, Oxford, 27 November 2018</h3>\n<ul>\n<li>Print used <tt>tied</tt> parameters equalities, if any.</li>\n<li>Return <tt>.ndof</tt> attribute.</li>\n<li>Do not remove <tt>fixed</tt> or <tt>tied</tt> parameters from the DOF calculation.\nThanks to Joanna Woo (Univ. of Victoria) for the correction.</li>\n<li>Replaced <tt>normalize</tt>, <tt>min_age</tt>, <tt>max_age</tt> and <tt>metal</tt> keywords with\n<tt>norm_range</tt>, <tt>age_range</tt> and <tt>metal_range</tt> in <tt>ppxf.miles_util.miles</tt>.</li>\n<li>Fixed <tt>clock</tt> <tt>DeprecationWarning</tt> in Python 3.7.</li>\n</ul>\n</div>\n<div id=\"v6-7-13-mc-oxford-20-september-2018\">\n<h3>V6.7.13: MC, Oxford, 20 September 2018</h3>\n<ul>\n<li>Expanded documentation of <tt>reddening</tt> and <tt>gas_reddening</tt>.\nThanks to Nick Boardman (Univ. Utah) for the feedback.</li>\n<li><tt>capfit</tt> now raises an error if one tries to tie parameters to themselves.\nThanks to Kyle Westfall (Univ. Santa Cruz) for the suggestion.</li>\n<li><tt>capfit</tt> uses Python 3.6 f-strings.</li>\n</ul>\n</div>\n<div id=\"v6-7-12-mc-oxford-9-july-2018\">\n<h3>V6.7.12: MC, Oxford, 9 July 2018</h3>\n<ul>\n<li>Allow for <tt>velscale</tt> and <tt>vsyst</tt> to be Numpy arrays rather than scalars.</li>\n<li>Improved criterion for when the Balmer series is within the fitted wavelength\nrange in <tt>ppxf.ppxf_util.emission_lines</tt>. Thanks to Sam Vaughan\n(Univ. of Oxford) for the feedback.</li>\n<li>Included <tt>width</tt> keyword in <tt>ppxf.ppxf_util.determine_goodpixels</tt>.\nThanks to George Privon (Univ. of Florida) for the suggestion.</li>\n<li>Expanded <tt>.gas_flux</tt> documentation.</li>\n</ul>\n</div>\n<div id=\"v6-7-11-mc-oxford-5-june-2018\">\n<h3>V6.7.11: MC, Oxford, 5 June 2018</h3>\n<ul>\n<li>Formatted <tt>ppxf.py</tt> docstring in reStructuredText.</li>\n<li>Removed CHANGELOG from the code and placed in a separate file.</li>\n<li>Modified <tt>setup.py</tt> to show help and CHANGELOG on PyPi page.</li>\n<li>Included <tt>ppxf.__version__</tt>.</li>\n</ul>\n</div>\n<div id=\"v6-7-8-mc-oxford-21-may-2018\">\n<h3>V6.7.8: MC, Oxford, 21 May 2018</h3>\n<ul>\n<li>Moved package to the Python Package Index (PyPi).</li>\n<li>Dropped legacy Python 2.7 support.</li>\n</ul>\n</div>\n<div id=\"v6-7-6-mc-oxford-16-april-2018\">\n<h3>V6.7.6: MC, Oxford, 16 April 2018</h3>\n<ul>\n<li>Changed imports for the conversion of ppxf to a package.\nThanks to Joe Burchett (Santa Cruz) for the suggestion.</li>\n</ul>\n</div>\n<div id=\"v6-7-5-mc-oxford-10-april-2018\">\n<h3>V6.7.5: MC, Oxford, 10 April 2018</h3>\n<ul>\n<li>Fixed syntax error under Python 2.7.</li>\n</ul>\n</div>\n<div id=\"v6-7-4-mc-oxford-16-february-2018\">\n<h3>V6.7.4: MC, Oxford, 16 February 2018</h3>\n<ul>\n<li>Fixed bug in <tt>reddening_cal00()</tt>. It only affected NIR lam &gt; 1000 nm.</li>\n</ul>\n</div>\n<div id=\"v6-7-3-mc-oxford-8-february-2018\">\n<h3>V6.7.3: MC, Oxford, 8 February 2018</h3>\n<ul>\n<li>Plot wavelength in nm instead of Angstrom, following IAU rules.</li>\n<li>Ensures each element of <tt>start</tt> is not longer than its <tt>moments</tt>.</li>\n<li>Removed underscore from internal function names.</li>\n<li>Included <tt>ftol</tt> keyword.</li>\n</ul>\n</div>\n<div id=\"v6-7-2-mc-oxford-30-january-2018\">\n<h3>V6.7.2: MC, Oxford, 30 January 2018</h3>\n<ul>\n<li>Included dunder names as suggested by Peter Weilbacher (Potsdam).</li>\n<li>Fixed wrong <tt>.gas_reddening</tt> when <tt>mdegree &gt; 0</tt>.</li>\n<li>Improved formatting of documentation.</li>\n</ul>\n</div>\n<div id=\"v6-7-1-mc-oxford-29-november-2017\">\n<h3>V6.7.1: MC, Oxford, 29 November 2017</h3>\n<ul>\n<li>Removed import of <tt>misc.factorial</tt>, deprecated in Scipy 1.0.</li>\n</ul>\n</div>\n<div id=\"v6-7-0-mc-oxford-6-november-2017\">\n<h3>V6.7.0: MC, Oxford, 6 November 2017</h3>\n<ul>\n<li>Allow users to input identically-zero gas templates while still\nproducing a stable NNLS solution. In this case, warn the user and set\nthe .gas_zero_template attribute. This situation can indicate an input\nbug or a gas line which entirely falls within a masked region.</li>\n<li>Corrected <tt>gas_flux_error</tt> normalization, when input not normalized.</li>\n<li>Return <tt>.gas_bestfit</tt>, <tt>.gas_mpoly</tt>, <tt>.mpoly</tt> and <tt>.apoly</tt> attributes.</li>\n<li>Do not multiply gas emission lines by polynomials, instead allow for\n<tt>gas_reddening</tt> (useful with tied Balmer emission lines).</li>\n<li>Use <tt>axvspan</tt> to visualize masked regions in plot.</li>\n<li>Fixed program stop with <tt>linear</tt> keyword.</li>\n<li>Introduced <tt>reddening_func</tt> keyword.</li>\n</ul>\n</div>\n<div id=\"v6-6-4-mc-oxford-5-october-2017\">\n<h3>V6.6.4: MC, Oxford, 5 October 2017</h3>\n<ul>\n<li>Check for NaN in <tt>galaxy</tt> and check all <tt>bounds</tt> have two elements.</li>\n<li>Allow <tt>start</tt> to be either a list or an array or vectors.</li>\n</ul>\n</div>\n<div id=\"v6-6-3-mc-oxford-25-september-2017\">\n<h3>V6.6.3: MC, Oxford, 25 September 2017</h3>\n<ul>\n<li>Reduced bounds on multiplicative polynomials and clipped to positive\nvalues. Thanks to Xihan Ji (Tsinghua University) for providing an\nexample of slightly negative gas emission lines, when the spectrum\ncontains essentially just noise.</li>\n<li>Improved visualization of masked pixels.</li>\n</ul>\n</div>\n<div id=\"v6-6-2-mc-oxford-15-september-2017\">\n<h3>V6.6.2: MC, Oxford, 15 September 2017</h3>\n<ul>\n<li>Fixed program stop with a 2-dim templates array and regularization.\nThanks to Adriano Poci (Macquarie University) for the clear report and\nthe fix.</li>\n</ul>\n</div>\n<div id=\"v6-6-1-mc-oxford-4-august-2017\">\n<h3>V6.6.1: MC, Oxford, 4 August 2017</h3>\n<ul>\n<li>Included note on <tt>.gas_flux</tt> output units. Thanks to Xihan Ji\n(Tsinghua University) for the feedback.</li>\n</ul>\n</div>\n<div id=\"v6-6-0-mc-oxford-27-june-2017\">\n<h3>V6.6.0: MC, Oxford, 27 June 2017</h3>\n<ul>\n<li>Print and return gas fluxes and errors, if requested, with the new\n<tt>gas_component</tt> and <tt>gas_names</tt> keywords.</li>\n</ul>\n</div>\n<div id=\"v6-5-0-mc-oxford-23-june-2017\">\n<h3>V6.5.0: MC, Oxford, 23 June 2017</h3>\n<ul>\n<li>Replaced <tt>MPFIT</tt> with <tt>capfit</tt> for a Levenberg-Marquardt method with\nfixed or tied variables, which rigorously accounts for box constraints.</li>\n</ul>\n</div>\n<div id=\"v6-4-2-mc-oxford-2-june-2017\">\n<h3>V6.4.2: MC, Oxford, 2 June 2017</h3>\n<ul>\n<li>Fixed removal of bounds in solution, introduced in V6.4.1.\nThanks to Kyle Westfall (Univ. Santa Cruz) for reporting this.</li>\n<li>Included <tt>method</tt> keyword to use Scipy\u2019s <tt>least_squares()</tt>\nas alternative to MPFIT.</li>\n<li>Force float division in pixel conversion of <tt>start</tt> and <tt>bounds</tt>.</li>\n</ul>\n</div>\n<div id=\"v6-4-1-mc-oxford-25-may-2017\">\n<h3>V6.4.1: MC, Oxford, 25 May 2017</h3>\n<ul>\n<li><tt>linear_fit()</tt> does not return unused status any more, for\nconsistency with the correspinding change to <tt>cap_mpfit</tt>.</li>\n</ul>\n</div>\n<div id=\"v6-4-0-mc-oxford-12-may-2017\">\n<h3>V6.4.0: MC, Oxford, 12 May 2017</h3>\n<ul>\n<li>Introduced <tt>tied</tt> keyword to tie parameters during fitting.</li>\n<li>Included discussion of formal errors of <tt>.weights</tt>.</li>\n</ul>\n</div>\n<div id=\"v6-3-2-mc-oxford-4-may-2017\">\n<h3>V6.3.2: MC, Oxford, 4 May 2017</h3>\n<ul>\n<li>Fixed possible program stop introduced in V6.0.7 and consequently\nremoved unnecessary function <tt>_templates_rfft()</tt>. Many thanks to\nJesus Falcon-Barroso for a very clear and useful bug report!</li>\n</ul>\n</div>\n<div id=\"v6-3-1-mc-oxford-13-april-2017\">\n<h3>V6.3.1: MC, Oxford, 13 April 2017</h3>\n<ul>\n<li>Fixed program stop when fitting two galaxy spectra with\nreflection-symmetric LOSVD.</li>\n</ul>\n</div>\n<div id=\"v6-3-0-mc-oxford-30-march-2017\">\n<h3>V6.3.0: MC, Oxford, 30 March 2017</h3>\n<ul>\n<li>Included <tt>reg_ord</tt> keyword to allow for both first and second order\nregularization.</li>\n</ul>\n</div>\n<div id=\"v6-2-0-mc-oxford-27-march-2017\">\n<h3>V6.2.0: MC, Oxford, 27 March 2017</h3>\n<ul>\n<li>Improved curvature criterion for regularization when <tt>dim &gt; 1</tt>.</li>\n</ul>\n</div>\n<div id=\"v6-1-0-mc-oxford-15-march-2017\">\n<h3>V6.1.0: MC, Oxford, 15 March 2017</h3>\n<ul>\n<li>Introduced <tt>trig</tt> keyword to use a trigonometric series as\nalternative to Legendre polynomials.</li>\n</ul>\n</div>\n<div id=\"v6-0-7-mc-oxford-13-march-2017\">\n<h3>V6.0.7: MC, Oxford, 13 March 2017</h3>\n<ul>\n<li>Use <tt>next_fast_len()</tt> for optimal <tt>rfft()</tt> zero padding.</li>\n<li>Included keyword <tt>gas_component</tt> in the <tt>.plot()</tt> method, to\ndistinguish gas emission lines in best-fitting plots.</li>\n<li>Improved plot of residuals for noisy spectra.</li>\n<li>Simplified regularization implementation.</li>\n</ul>\n</div>\n<div id=\"v6-0-6-mc-oxford-23-february-2017\">\n<h3>V6.0.6: MC, Oxford, 23 February 2017</h3>\n<ul>\n<li>Added <tt>linear_fit()</tt> and <tt>nonlinear_fit()</tt> functions to better\nclarify the code structure. Included <tt>templates_rfft</tt> keyword.</li>\n<li>Updated documentation. Some code simplifications.</li>\n</ul>\n</div>\n<div id=\"v6-0-5-mc-oxford-21-february-2017\">\n<h3>V6.0.5: MC, Oxford, 21 February 2017</h3>\n<ul>\n<li>Consistently use new format_output() function both with/without\nthe <tt>linear</tt> keyword. Added <tt>.status</tt> attribute. Changes suggested by\nKyle Westfall (Univ. Santa Cruz).</li>\n</ul>\n</div>\n<div id=\"v6-0-4-mc-oxford-30-january-2017\">\n<h3>V6.0.4: MC, Oxford, 30 January 2017</h3>\n<ul>\n<li>Re-introduced <tt>linear</tt> keyword to only perform a linear fit and\nskip the non-linear optimization.</li>\n</ul>\n</div>\n<div id=\"v6-0-3-mc-oxford-1-december-2016\">\n<h3>V6.0.3: MC, Oxford, 1 December 2016</h3>\n<ul>\n<li>Return usual <tt><span class=\"pre\">Chi**2/DOF</span></tt> instead of Biweight estimate.</li>\n</ul>\n</div>\n<div id=\"v6-0-2-mc-oxford-15-august-2016\">\n<h3>V6.0.2: MC, Oxford, 15 August 2016</h3>\n<ul>\n<li>Improved formatting of printed output.</li>\n</ul>\n</div>\n<div id=\"v6-0-1-mc-oxford-10-august-2016\">\n<h3>V6.0.1: MC, Oxford, 10 August 2016</h3>\n<ul>\n<li>Allow <tt>moments</tt> to be an arbitrary integer.</li>\n<li>Allow for scalar <tt>moments</tt> with multiple kinematic components.</li>\n</ul>\n</div>\n<div id=\"v6-0-0-mc-oxford-28-july-2016\">\n<h3>V6.0.0: MC, Oxford, 28 July 2016</h3>\n<ul>\n<li>Compute the Fourier Transform of the LOSVD analytically:</li>\n<li>Major improvement in velocity accuracy when <tt>sigma &lt; velscale</tt>.</li>\n<li>Removed <tt>oversample</tt> keyword, which is now unnecessary.</li>\n<li>Removed limit on velocity shift of templates.</li>\n<li>Simplified FFT zero padding. Updated documentation.</li>\n</ul>\n</div>\n<div id=\"v5-3-3-mc-oxford-24-may-2016\">\n<h3>V5.3.3: MC, Oxford 24 May 2016</h3>\n<ul>\n<li>Fixed Python 2 compatibility. Thanks to Masato Onodera (NAOJ).</li>\n</ul>\n</div>\n<div id=\"v5-3-2-mc-oxford-22-may-2016\">\n<h3>V5.3.2: MC, Oxford, 22 May 2016</h3>\n<ul>\n<li>Backward compatibility change: allow <tt>start</tt> to be smaller than\n<tt>moments</tt>. After feedback by Masato Onodera (NAOJ).</li>\n<li>Updated documentation of <tt>bounds</tt> and <tt>fixed</tt>.</li>\n</ul>\n</div>\n<div id=\"v5-3-1-mc-oxford-18-may-2016\">\n<h3>V5.3.1: MC, Oxford, 18 May 2016</h3>\n<ul>\n<li>Use wavelength in plot when available. Make <tt>plot()</tt> a class function.\nChanges suggested and provided by Johann Cohen-Tanugi (LUPM).</li>\n</ul>\n</div>\n<div id=\"v5-3-0-mc-oxford-9-may-2016\">\n<h3>V5.3.0: MC, Oxford, 9 May 2016</h3>\n<ul>\n<li>Included <tt>velscale_ratio</tt> keyword to pass a set of templates with\nhigher resolution than the galaxy spectrum.</li>\n<li>Changed <tt>oversample</tt> keyword to require integers not Booleans.</li>\n</ul>\n</div>\n<div id=\"v5-2-0-mc-baltimore-26-april-2016\">\n<h3>V5.2.0: MC, Baltimore, 26 April 2016</h3>\n<ul>\n<li>Included <tt>bounds</tt>, <tt>fixed</tt> and <tt>fraction</tt> keywords.</li>\n</ul>\n</div>\n<div id=\"v5-1-18-mc-oxford-20-april-2016\">\n<h3>V5.1.18: MC, Oxford, 20 April 2016</h3>\n<ul>\n<li>Fixed deprecation warning in Numpy 1.11. Changed order from 1 to 3\nduring oversampling. Warn if sigma is under-sampled.</li>\n</ul>\n</div>\n<div id=\"v5-1-17-mc-oxford-21-january-2016\">\n<h3>V5.1.17: MC, Oxford, 21 January 2016</h3>\n<ul>\n<li>Expanded explanation of the relation between output velocity and redshift.</li>\n</ul>\n</div>\n<div id=\"v5-1-16-mc-oxford-9-november-2015\">\n<h3>V5.1.16: MC, Oxford, 9 November 2015</h3>\n<ul>\n<li>Fixed potentially misleading typo in documentation of <tt>moments</tt>.</li>\n</ul>\n</div>\n<div id=\"v5-1-15-mc-oxford-22-october-2015\">\n<h3>V5.1.15: MC, Oxford, 22 October 2015</h3>\n<ul>\n<li>Updated documentation. Thanks to Peter Weilbacher (Potsdam) for\ncorrections.</li>\n</ul>\n</div>\n<div id=\"v5-1-14-mc-oxford-19-october-2015\">\n<h3>V5.1.14: MC, Oxford, 19 October 2015</h3>\n<ul>\n<li>Fixed deprecation warning in Numpy 1.10.</li>\n</ul>\n</div>\n<div id=\"v5-1-13-mc-oxford-24-april-2015\">\n<h3>V5.1.13: MC, Oxford, 24 April 2015</h3>\n<ul>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"v5-1-12-mc-oxford-25-february-2015\">\n<h3>V5.1.12: MC, Oxford, 25 February 2015</h3>\n<ul>\n<li>Use <tt>color=</tt> instead of <tt>c=</tt> to avoid new Matplotlib 1.4 bug.</li>\n</ul>\n</div>\n<div id=\"v5-1-11-mc-sydney-5-february-2015\">\n<h3>V5.1.11: MC, Sydney, 5 February 2015</h3>\n<ul>\n<li>Reverted change introduced in V5.1.2. Thanks to Nora Lu\u201dtzgendorf\nfor reporting problems with <tt>oversample</tt>.</li>\n</ul>\n</div>\n<div id=\"v5-1-10-mc-oxford-14-october-2014\">\n<h3>V5.1.10: MC, Oxford, 14 October 2014</h3>\n<ul>\n<li>Fixed bug in saving output introduced in previous version.</li>\n</ul>\n</div>\n<div id=\"v5-1-9-mc-las-vegas-airport-13-september-2014\">\n<h3>V5.1.9: MC, Las Vegas Airport, 13 September 2014</h3>\n<ul>\n<li>Pre-compute FFT and oversampling of templates. This speeds up the\ncalculation for very long or highly-oversampled spectra. Thanks to\nRemco van den Bosch for reporting situations where this optimization\nmay be useful.</li>\n</ul>\n</div>\n<div id=\"v5-1-8-mc-utah-10-september-2014\">\n<h3>V5.1.8: MC, Utah, 10 September 2014</h3>\n<ul>\n<li>Fixed program stop with <tt>reddening</tt> keyword. Thanks to Masatao\nOnodera for reporting the problem.</li>\n</ul>\n</div>\n<div id=\"v5-1-7-mc-oxford-3-september-2014\">\n<h3>V5.1.7: MC, Oxford, 3 September 2014</h3>\n<ul>\n<li>Relaxed requirement on input maximum velocity shift.</li>\n<li>Minor reorganization of the code structure.</li>\n</ul>\n</div>\n<div id=\"v5-1-6-mc-oxford-6-august-2014\">\n<h3>V5.1.6: MC, Oxford, 6 August 2014</h3>\n<ul>\n<li>Catch an additional input error. Updated documentation for Python.\nIncluded templates <tt>matrix</tt> in output. Modified plotting colours.</li>\n</ul>\n</div>\n<div id=\"v5-1-5-mc-oxford-21-june-2014\">\n<h3>V5.1.5: MC, Oxford, 21 June 2014</h3>\n<ul>\n<li>Fixed deprecation warning.</li>\n</ul>\n</div>\n<div id=\"v5-1-4-mc-oxford-25-may-2014\">\n<h3>V5.1.4: MC, Oxford, 25 May 2014</h3>\n<ul>\n<li>Support both Python 2.7 and Python 3.</li>\n</ul>\n</div>\n<div id=\"v5-1-3-mc-oxford-7-may-2014\">\n<h3>V5.1.3: MC, Oxford, 7 May 2014</h3>\n<ul>\n<li>Allow for an input covariance matrix instead of an error spectrum.</li>\n</ul>\n</div>\n<div id=\"v5-1-2-mc-oxford-6-may-2014\">\n<h3>V5.1.2: MC, Oxford, 6 May 2014</h3>\n<ul>\n<li>Replaced REBIN with INTERPOLATE + /OVERSAMPLE keyword. This is\nto account for the fact that the Line Spread Function of the observed\ngalaxy spectrum already includes pixel convolution. Thanks to Mike\nBlanton for the suggestion.</li>\n</ul>\n</div>\n<div id=\"v5-1-1-mc-dallas-airport-9-february-2014\">\n<h3>V5.1.1: MC, Dallas Airport, 9 February 2014</h3>\n<ul>\n<li>Fixed typo in the documentation of <tt>nnls_flags</tt>.</li>\n</ul>\n</div>\n<div id=\"v5-1-0-mc-oxford-9-january-2014\">\n<h3>V5.1.0: MC, Oxford, 9 January 2014</h3>\n<ul>\n<li>Allow for a different LOSVD for each template. Templates can be\nstellar or can be gas emission lines. A ppxf version adapted for\nmultiple kinematic components existed for years. It was updated in\nJAN/2012 for the paper by Johnston et al. (2013, MNRAS). This version\nmerges those changes with the public ppxf version, making sure that all\nprevious ppxf options are still supported.</li>\n</ul>\n</div>\n<div id=\"v5-0-1-mc-oxford-12-december-2013\">\n<h3>V5.0.1: MC, Oxford, 12 December 2013</h3>\n<ul>\n<li>Minor cleaning and corrections.</li>\n</ul>\n</div>\n<div id=\"v5-0-0-mc-oxford-6-december-2013\">\n<h3>V5.0.0: MC, Oxford, 6 December 2013</h3>\n<ul>\n<li>Translated from IDL into Python and tested against the original version.</li>\n</ul>\n</div>\n<div id=\"v4-6-6-mc-paranal-8-november-2013\">\n<h3>V4.6.6: MC, Paranal, 8 November 2013</h3>\n<ul>\n<li>Uses CAP_RANGE to avoid potential naming conflicts.</li>\n</ul>\n</div>\n<div id=\"v4-6-5-mc-oxford-15-november-2012\">\n<h3>V4.6.5: MC, Oxford, 15 November 2012</h3>\n<ul>\n<li>Expanded documentation of REGUL keyword.</li>\n</ul>\n</div>\n<div id=\"v4-6-4-mc-oxford-9-december-2011\">\n<h3>V4.6.4: MC, Oxford, 9 December 2011</h3>\n<ul>\n<li>Increased oversampling factor to 30x, when the /OVERSAMPLE keyword\nis used. Updated corresponding documentation. Thanks to Nora\nLu\u201dtzgendorf for test cases illustrating errors in the recovered\nvelocity when the sigma is severely undersampled.</li>\n</ul>\n</div>\n<div id=\"v4-6-3-mc-oxford-25-october-2011\">\n<h3>V4.6.3: MC, Oxford 25 October 2011</h3>\n<ul>\n<li>Do not change TEMPLATES array in output when REGUL is nonzero.\nFrom feedback of Richard McDermid.</li>\n</ul>\n</div>\n<div id=\"v4-6-2-mc-oxford-17-october-2011\">\n<h3>V4.6.2: MC, Oxford, 17 October 2011</h3>\n<ul>\n<li>Included option for 3D regularization and updated documentation of\nREGUL keyword.</li>\n</ul>\n</div>\n<div id=\"v4-6-1-mc-oxford-29-july-2011\">\n<h3>V4.6.1: MC, Oxford, 29 July 2011</h3>\n<ul>\n<li>Use Coyote Graphics (<a href=\"http://www.idlcoyote.com/\" rel=\"nofollow\">http://www.idlcoyote.com/</a>) by David W. Fanning.\nThe required routines are now included in NASA IDL Astronomy Library.</li>\n</ul>\n</div>\n<div id=\"v4-6-0-mc-oxford-12-april-2011\">\n<h3>V4.6.0: MC, Oxford, 12 April 2011</h3>\n<ul>\n<li>Important fix to /CLEAN procedure: bad pixels are now properly\nupdated during the 3sigma iterations.</li>\n</ul>\n</div>\n<div id=\"v4-5-0-mc-oxford-13-april-2010\">\n<h3>V4.5.0: MC, Oxford, 13 April 2010</h3>\n<ul>\n<li>Dramatic speed up in the convolution of long spectra.</li>\n</ul>\n</div>\n<div id=\"v4-4-0-mc-oxford-18-september-2009\">\n<h3>V4.4.0: MC, Oxford, 18 September 2009</h3>\n<ul>\n<li>Introduced Calzetti et al. (2000) ppxf_REDDENING_CURVE function to\nestimate the reddening from the fit.</li>\n</ul>\n</div>\n<div id=\"v4-3-0-mc-oxford-4-mach-2009\">\n<h3>V4.3.0: MC, Oxford, 4 Mach 2009</h3>\n<ul>\n<li>Introduced REGUL keyword to perform linear regularization of WEIGHTS\nin one or two dimensions.</li>\n</ul>\n</div>\n<div id=\"v4-2-3-mc-oxford-27-november-2008\">\n<h3>V4.2.3: MC, Oxford, 27 November 2008</h3>\n<ul>\n<li>Corrected error message for too big velocity shift.</li>\n</ul>\n</div>\n<div id=\"v4-2-2-mc-windhoek-3-july-2008\">\n<h3>V4.2.2: MC, Windhoek, 3 July 2008</h3>\n<ul>\n<li>Added keyword POLYWEIGHTS.</li>\n</ul>\n</div>\n<div id=\"v4-2-1-mc-oxford-17-may-2008\">\n<h3>V4.2.1: MC, Oxford, 17 May 2008</h3>\n<ul>\n<li>Use LA_LEAST_SQUARES (IDL 5.6) instead of SVDC when fitting a single\ntemplate. Please let me know if you need to use ppxf with an older IDL\nversion.</li>\n</ul>\n</div>\n<div id=\"v4-2-0-mc-oxford-15-march-2008\">\n<h3>V4.2.0: MC, Oxford, 15 March 2008</h3>\n<ul>\n<li>Introduced optional fitting of SKY spectrum. Many thanks to\nAnne-Marie Weijmans for testing.</li>\n</ul>\n</div>\n<div id=\"v4-1-7-mc-oxford-6-october-2007\">\n<h3>V4.1.7: MC, Oxford, 6 October 2007</h3>\n<ul>\n<li>Updated documentation with important note on penalty determination.</li>\n</ul>\n</div>\n<div id=\"v4-1-6-mc-leiden-20-january-2006\">\n<h3>V4.1.6: MC, Leiden, 20 January 2006</h3>\n<ul>\n<li>Print number of nonzero templates. Do not print outliers in /QUIET mode.</li>\n</ul>\n</div>\n<div id=\"v4-1-5-mc-leiden-10-february-2005\">\n<h3>V4.1.5: MC, Leiden, 10 February 2005</h3>\n<ul>\n<li>Verify that GOODPIXELS is monotonic and does not contain duplicated\nvalues. After feedback from Richard McDermid.</li>\n</ul>\n</div>\n<div id=\"v4-1-4-mc-leiden-12-january-2005\">\n<h3>V4.1.4: MC, Leiden, 12 January 2005</h3>\n<ul>\n<li>Make sure input NOISE is a positive vector.</li>\n</ul>\n</div>\n<div id=\"v4-1-3-mc-vicenza-30-december-2004\">\n<h3>V4.1.3: MC, Vicenza, 30 December 2004</h3>\n<ul>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"v4-1-2-mc-leiden-11-november-2004\">\n<h3>V4.1.2: MC, Leiden, 11 November 2004</h3>\n<ul>\n<li>Handle special case where a single template without additive\npolynomials is fitted to the galaxy.</li>\n</ul>\n</div>\n<div id=\"v4-1-1-mc-leiden-21-september-2004\">\n<h3>V4.1.1: MC, Leiden, 21 September 2004</h3>\n<ul>\n<li>Increased maximum number of iterations ITMAX in BVLS. Thanks to\nJesus Falcon-Barroso for reporting problems.</li>\n<li>Introduced error message when velocity shift is too big.</li>\n<li>Corrected output when MOMENTS=0.</li>\n</ul>\n</div>\n<div id=\"v4-1-0-mc-leiden-3-september-2004\">\n<h3>V4.1.0: MC, Leiden, 3 September 2004</h3>\n<ul>\n<li>Corrected implementation of two-sided fitting of the LOSVD. Thanks\nto Stefan van Dongen for reporting problems.</li>\n</ul>\n</div>\n<div id=\"v4-0-0-mc-vicenza-16-august-2004\">\n<h3>V4.0.0: MC, Vicenza, 16 August 2004</h3>\n<ul>\n<li>Introduced optional two-sided fitting assuming a reflection\nsymmetric LOSVD for two input spectra.</li>\n</ul>\n</div>\n<div id=\"v3-7-3-mc-leiden-7-august-2004\">\n<h3>V3.7.3: MC, Leiden, 7 August 2004</h3>\n<ul>\n<li>Corrected bug: keyword ERROR was returned in pixels instead of km/s.</li>\n<li>Decreased lower limit on fitted dispersion. Thanks to Igor V. Chilingarian.</li>\n</ul>\n</div>\n<div id=\"v3-7-2-mc-leiden-28-april-2004\">\n<h3>V3.7.2: MC, Leiden, 28 April 2004</h3>\n<ul>\n<li>Corrected program stop after fit when MOMENTS=2. Bug was introduced in V3.7.0.</li>\n</ul>\n</div>\n<div id=\"v3-7-1-mc-leiden-31-march-2004\">\n<h3>V3.7.1: MC, Leiden, 31 March 2004</h3>\n<ul>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"v3-7-0-mc-leiden-23-march-2004\">\n<h3>V3.7.0: MC, Leiden, 23 March 2004</h3>\n<ul>\n<li>Revised implementation of MDEGREE option. Nonlinear implementation:\nstraightforward, robust, but slower.</li>\n</ul>\n</div>\n<div id=\"v3-6-0-mc-leiden-19-march-2004\">\n<h3>V3.6.0: MC, Leiden, 19 March 2004</h3>\n<ul>\n<li>Added MDEGREE option for multiplicative polynomials. Linear implementation:\nfast, works well in most cases, but can fail in certain cases.</li>\n</ul>\n</div>\n<div id=\"v3-5-0-mc-leiden-11-december-2003\">\n<h3>V3.5.0: MC, Leiden, 11 December 2003</h3>\n<ul>\n<li>Included /OVERSAMPLE option.</li>\n</ul>\n</div>\n<div id=\"v3-4-7-mc-leiden-8-december-2003\">\n<h3>V3.4.7: MC, Leiden, 8 December 2003</h3>\n<ul>\n<li>First released version.</li>\n</ul>\n</div>\n<div id=\"v1-0-0-leiden-10-october-2001\">\n<h3>V1.0.0: Leiden, 10 October 2001</h3>\n<ul>\n<li>Created by Michele Cappellari.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7166025, "releases": {"6.7.11": [{"comment_text": "", "digests": {"md5": "c8666b8a309e0fba9745f6f45fc0ff65", "sha256": "ef411718f2cd1800b572d414818b356a0b64a93e96f532c9629cd14ba203b009"}, "downloads": -1, "filename": "ppxf-6.7.11.tar.gz", "has_sig": false, "md5_digest": "c8666b8a309e0fba9745f6f45fc0ff65", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3268127, "upload_time": "2018-06-05T13:55:05", "upload_time_iso_8601": "2018-06-05T13:55:05.780575Z", "url": "https://files.pythonhosted.org/packages/e8/ad/09b6cb0d9adbf9989c9cfaab2a344e5d5c019d432e032ab128b62012bae8/ppxf-6.7.11.tar.gz", "yanked": false}], "6.7.12": [{"comment_text": "", "digests": {"md5": "b8a6449a16befd961c5aa382b719d51a", "sha256": "c9caab4582764a852d6a5ab452030f01235212cbe29216b25e040236379dd310"}, "downloads": -1, "filename": "ppxf-6.7.12.tar.gz", "has_sig": false, "md5_digest": "b8a6449a16befd961c5aa382b719d51a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3269455, "upload_time": "2018-07-09T10:01:06", "upload_time_iso_8601": "2018-07-09T10:01:06.797248Z", "url": "https://files.pythonhosted.org/packages/83/11/4940cb01e78df8feeb1cd1026171fa22dbee24a5db9f1711d6415b3e2551/ppxf-6.7.12.tar.gz", "yanked": false}], "6.7.13": [{"comment_text": "", "digests": {"md5": "3980d0e00fceb0742a47ca9569d5a0cf", "sha256": "b4bc8272bf9dafa0fe0db2bb849723eff837fbba12d5597424f77b6790843cdd"}, "downloads": -1, "filename": "ppxf-6.7.13.tar.gz", "has_sig": false, "md5_digest": "3980d0e00fceb0742a47ca9569d5a0cf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3269942, "upload_time": "2018-09-20T15:15:55", "upload_time_iso_8601": "2018-09-20T15:15:55.221332Z", "url": "https://files.pythonhosted.org/packages/29/fb/c4ff828af045f1d702b45a672a33a70d515a2f4db9a21f81bed9d0ed8063/ppxf-6.7.13.tar.gz", "yanked": false}], "6.7.14": [{"comment_text": "", "digests": {"md5": "af6832d3668467d9b999778121360f45", "sha256": "c7d4f1196388c0788bd8a18e06655fe6347f09c23fd149a354e0cf3053fdbcf7"}, "downloads": -1, "filename": "ppxf-6.7.14.tar.gz", "has_sig": false, "md5_digest": "af6832d3668467d9b999778121360f45", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3271992, "upload_time": "2018-11-27T18:38:21", "upload_time_iso_8601": "2018-11-27T18:38:21.899812Z", "url": "https://files.pythonhosted.org/packages/3c/d0/c419334ca1d3f1062202f4a54c13c5285ba717dc086d80ae3446e2bd6f19/ppxf-6.7.14.tar.gz", "yanked": false}], "6.7.15": [{"comment_text": "", "digests": {"md5": "c5e408260cfc23f24b130768868b2f34", "sha256": "49942ace6c6d2d0903b11ebcbc9f7c3a4c529328dee1f7a0473e6eee18ab42e3"}, "downloads": -1, "filename": "ppxf-6.7.15.tar.gz", "has_sig": false, "md5_digest": "c5e408260cfc23f24b130768868b2f34", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3269778, "upload_time": "2019-02-07T16:51:53", "upload_time_iso_8601": "2019-02-07T16:51:53.388436Z", "url": "https://files.pythonhosted.org/packages/78/c4/e6b1fa4ed5a3e1a799c096a9dde010263befe17a89ce3a76971c7754ad75/ppxf-6.7.15.tar.gz", "yanked": false}], "6.7.16": [{"comment_text": "", "digests": {"md5": "a6e21097f1517f760e8fa20022cce739", "sha256": "1b50c1aae4c4932558ba8fd23bc8facddeebd4594bced5d2348d2e9a8052bfcf"}, "downloads": -1, "filename": "ppxf-6.7.16.tar.gz", "has_sig": false, "md5_digest": "a6e21097f1517f760e8fa20022cce739", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3270119, "upload_time": "2019-06-12T09:59:17", "upload_time_iso_8601": "2019-06-12T09:59:17.794647Z", "url": "https://files.pythonhosted.org/packages/44/52/bbc40f1ecfca314822ea4c10dd0bd92743e9d980a7b3e729a0f2565f1bf0/ppxf-6.7.16.tar.gz", "yanked": false}], "6.7.17": [{"comment_text": "", "digests": {"md5": "335ae211d289cb588faa82f9b6116bc1", "sha256": "7cf74acce92abc5af0c161f6333ba42621566cf41407412e0a8d512f0ae15270"}, "downloads": -1, "filename": "ppxf-6.7.17.tar.gz", "has_sig": false, "md5_digest": "335ae211d289cb588faa82f9b6116bc1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3272206, "upload_time": "2019-11-14T15:39:08", "upload_time_iso_8601": "2019-11-14T15:39:08.696614Z", "url": "https://files.pythonhosted.org/packages/be/78/cb0704f48ee8e4e275a41e5a329684ea2fe1f01294ebc8e48526db2aafaa/ppxf-6.7.17.tar.gz", "yanked": false}], "6.7.8": [{"comment_text": "", "digests": {"md5": "6eae34bfcf8dccb2234f764cf7e83ea9", "sha256": "6d2314f2ba90750b33c6236006ad1c8a0167e0c072b58b33badd354cd53bfb80"}, "downloads": -1, "filename": "ppxf-6.7.8.tar.gz", "has_sig": false, "md5_digest": "6eae34bfcf8dccb2234f764cf7e83ea9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3231032, "upload_time": "2018-05-21T10:29:00", "upload_time_iso_8601": "2018-05-21T10:29:00.717930Z", "url": "https://files.pythonhosted.org/packages/26/69/96e269d9d7ec78a63bcf08fc94f22eab530e06282a10d88c7266f2613953/ppxf-6.7.8.tar.gz", "yanked": false}], "7.0.0": [{"comment_text": "", "digests": {"md5": "bd38efb3ef87033bfb7eb28a54fcdb2d", "sha256": "b99260ed56b0bcd78d3cb8a814b03c8bbad9810514a7a5243a163e9d33a3ffec"}, "downloads": -1, "filename": "ppxf-7.0.0.tar.gz", "has_sig": false, "md5_digest": "bd38efb3ef87033bfb7eb28a54fcdb2d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3276372, "upload_time": "2020-01-10T18:55:19", "upload_time_iso_8601": "2020-01-10T18:55:19.544729Z", "url": "https://files.pythonhosted.org/packages/b6/30/32a218a3e2f3aa05fa641d24c2ac1ca15a937226d2e91068b7e636854901/ppxf-7.0.0.tar.gz", "yanked": false}], "7.0.1": [{"comment_text": "", "digests": {"md5": "f27bb7b460c6934037f31c1564f79630", "sha256": "d422bc2f8e02840cf3b3b8fd36346a30630a75f7bafe47596c8e137e60b1061f"}, "downloads": -1, "filename": "ppxf-7.0.1.tar.gz", "has_sig": false, "md5_digest": "f27bb7b460c6934037f31c1564f79630", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3277788, "upload_time": "2020-04-08T18:37:25", "upload_time_iso_8601": "2020-04-08T18:37:25.348022Z", "url": "https://files.pythonhosted.org/packages/01/3e/70b98d56b75a2c48b4ade6d8c3cc5bbd99ac49800de832920c3978f7b25b/ppxf-7.0.1.tar.gz", "yanked": false}], "7.1.0": [{"comment_text": "", "digests": {"md5": "ebf58ae65888dc518929ff01006e4082", "sha256": "facddb3b34f83af356e78714e8966560154ace8c134fdaa181440e72d5906faa"}, "downloads": -1, "filename": "ppxf-7.1.0.tar.gz", "has_sig": false, "md5_digest": "ebf58ae65888dc518929ff01006e4082", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3279230, "upload_time": "2020-04-30T17:35:59", "upload_time_iso_8601": "2020-04-30T17:35:59.990283Z", "url": "https://files.pythonhosted.org/packages/c7/17/d81127baaf710afe7e1c76d6312b3edf65baee7e855e1882903b46fa9dcd/ppxf-7.1.0.tar.gz", "yanked": false}], "7.2.0": [{"comment_text": "", "digests": {"md5": "1c2215ac8ec6e99917b47ba39b634d0c", "sha256": "8f4ae9e226a0c138f4fb90090e0e891321c777cc83fd45d9494b257c646a42b0"}, "downloads": -1, "filename": "ppxf-7.2.0.tar.gz", "has_sig": false, "md5_digest": "1c2215ac8ec6e99917b47ba39b634d0c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3279857, "upload_time": "2020-05-04T17:20:22", "upload_time_iso_8601": "2020-05-04T17:20:22.059189Z", "url": "https://files.pythonhosted.org/packages/93/71/e83e67d08e1aa4a35c5cb91c0b1b0362282dfe10dbeb0d3fb596b9ea0594/ppxf-7.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1c2215ac8ec6e99917b47ba39b634d0c", "sha256": "8f4ae9e226a0c138f4fb90090e0e891321c777cc83fd45d9494b257c646a42b0"}, "downloads": -1, "filename": "ppxf-7.2.0.tar.gz", "has_sig": false, "md5_digest": "1c2215ac8ec6e99917b47ba39b634d0c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3279857, "upload_time": "2020-05-04T17:20:22", "upload_time_iso_8601": "2020-05-04T17:20:22.059189Z", "url": "https://files.pythonhosted.org/packages/93/71/e83e67d08e1aa4a35c5cb91c0b1b0362282dfe10dbeb0d3fb596b9ea0594/ppxf-7.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:18 2020"}