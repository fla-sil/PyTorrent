{"info": {"author": "Permuta Triangle", "author_email": "permutatriangle@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Education", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Education", "Topic :: Scientific/Engineering :: Mathematics"], "description": "Combinatorial Specification Searcher\n====================================\n.. image:: https://travis-ci.org/PermutaTriangle/comb_spec_searcher.svg?branch=master\n    :alt: Travis\n    :target: https://travis-ci.org/PermutaTriangle/comb_spec_searcher\n.. image:: https://img.shields.io/coveralls/github/PermutaTriangle/comb_spec_searcher.svg\n    :alt: Coveralls\n    :target: https://coveralls.io/github/PermutaTriangle/comb_spec_searcher\n.. image:: https://img.shields.io/pypi/v/comb_spec_searcher.svg\n    :alt: PyPI\n    :target: https://pypi.python.org/pypi/comb_spec_searcher\n.. image:: https://img.shields.io/pypi/l/comb_spec_searcher.svg\n    :target: https://pypi.python.org/pypi/comb_spec_searcher\n.. image:: https://img.shields.io/pypi/pyversions/comb_spec_searcher.svg\n    :target: https://pypi.python.org/pypi/comb_spec_searcher\n\n.. image:: http://img.shields.io/badge/readme-tested-brightgreen.svg\n    :alt: Travis\n    :target: https://travis-ci.org/PermutaTriangle/comb_spec_searcher\n\n.. image:: https://requires.io/github/PermutaTriangle/comb_spec_searcher/requirements.svg?branch=master\n     :target: https://requires.io/github/PermutaTriangle/comb_spec_searcher/requirements/?branch=master\n     :alt: Requirements Status\n\nThe ``comb_spec_searcher`` package contains code for combinatorial\nexploration.\n\nInstalling\n----------\n\nTo install ``comb_spec_searcher`` on your system, run:\n\n.. code:: bash\n\n       pip install comb_spec_searcher\n\nIt is also possible to install comb_spec_searcher in development mode to\nwork on the source code, in which case you run the following after\ncloning the repository:\n\n.. code:: bash\n\n       ./setup.py develop\n\nCombinatorial exploration\n-------------------------\n\nA (combinatorial) class is a set of objects with a notion of size such\nthat there are finitely many objects of each size. One of the primary\ngoals of enumerative combinatorics is to count how many objects of each\nsize there are in a class. One method for doing this is to find a\n(combinatorial) specification, which is a collection of (combinatorial)\nrules that describe how to build a class from other classes using\nwell-defined constructors. Such a specification can then be used to\ncount the number of objects of each size.\n\n*Combinatorial exploration* is a systematic application of strategies to\ncreate rules about a class of interest, until a specification can be\nfound. This package can be used to perform this process automatically.\nSee the `Combinatorial Exploration\nproject <https://permutatriangle.github.io/papers/2019-02-27-combex.html>`__\nand `Christian Bean\u2019s PhD\nthesis <https://skemman.is/handle/1946/31663>`__ for more details.\n\nThe remainder of this README will be an example of how to use this\npackage for performing combinatorial exploration on a specific class,\nnamely words avoiding consecutive patterns.\n\nAvoiding consecutive patterns in words\n--------------------------------------\n\nA word ``w`` over an alphabet ``\u03a3`` is a string consisting of letters\nfrom ``\u03a3``. We say that ``w`` contains the word ``p`` if there is a\nconsecutive sequence of letters in ``w`` equal to ``p``. We say ``w``\navoids ``p`` if it does not contain ``p``. In this context, we call\n``p`` a pattern. In ``python``, this containment check can be checked\nusing ``in``.\n\n.. code:: python\n\n   >>> w = \"acbabcabbb\"\n   >>> p = \"abcab\"\n   >>> p in w\n   True\n\nFor an alphabet ``\u03a3`` and a set of patterns ``P`` we define ``\u03a3*(P)`` to\nbe the set of words over ``\u03a3`` that avoid every pattern in ``P``. These\nare the classes that we will count. Of course, these all form regular\nlanguages, but it will serve as a good example of how to use the\n``comb_spec_searcher`` package.\n\nThe first step is to create the classes that will be used for\ndiscovering the underlying structure of the class of interest. In this\ncase, considering the prefix of the words is what we need. We then\ncreate a new python ``class`` representing this that inherits from\n``CombinatorialClass`` which can be imported from\n``comb_spec_searcher``.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import CombinatorialClass\n\n\n   >>> class AvoidingWithPrefix(CombinatorialClass):\n   ...     def __init__(self, prefix, patterns, alphabet, just_prefix=False):\n   ...         self.alphabet = frozenset(alphabet)\n   ...         self.prefix = prefix\n   ...         self.patterns = frozenset(patterns)\n   ...         self.just_prefix = just_prefix # this will be needed later\n\nInheriting from ``CombinatorialClass`` requires you to implement a few\nfunctions for combinatorial exploration: ``is_empty``, ``to_jsonable``,\n``__eq__``, ``__hash__``, ``__repr__``, and ``__str__``.\n\nWe will start by implementing the dunder methods (the ones with double\nunderscores) required. The ``__eq__`` method is particularly important\nas the ``CombinatorialSpecificationSearcher`` will use it to recognise\nif the same class appears multiple times.\n\n.. code:: python\n\n   ...     # The dunder methods required to perform combinatorial exploration\n   ...\n   ...     def __eq__(self, other):\n   ...         return (self.alphabet == other.alphabet and\n   ...                 self.prefix == other.prefix and\n   ...                 self.patterns == other.patterns and\n   ...                 self.just_prefix == other.just_prefix)\n   ...\n   ...     def __hash__(self):\n   ...         return hash(hash(self.prefix) + hash(self.patterns) +\n   ...                     hash(self.alphabet) + hash(self.just_prefix))\n   ...\n   ...     def __str__(self):\n   ...         if self.just_prefix:\n   ...             return \"The word {}\".format(self.prefix)\n   ...         return (\"Words over {{{}}} avoiding {{{}}} with prefix {}\"\n   ...                 \"\".format(\", \".join(l for l in self.alphabet),\n   ...                           \", \".join(p for p in self.patterns),\n   ...                           self.prefix if self.prefix else '\"\"'))\n   ...\n   ...     def __repr__(self):\n   ...         return \"AvoidingWithPrefix({}, {}, {}\".format(repr(self.prefix),\n   ...                                                       repr(self.patterns),\n   ...                                                       repr(self.alphabet))\n\nPerhaps the most important function to be implemented is the\n``is_empty`` function. This should return ``True`` if there are no\nobjects of any length in the class, otherwise ``False``. If it is not\ncorrectly implemented it may lead to tautological specifications. For\nexample, in our case the class is empty if and only if the prefix\ncontains a pattern to be avoided.\n\n.. code:: python\n\n   ...     def is_empty(self):\n   ...         return any(p in self.prefix for p in self.patterns)\n\nThe final function required is ``to_jsonable``. This is primarily for\nthe output, and only necessary for saving the output. It should be in a\nformat that can be interpretated by ``json``. What is important is that\nthe ``from_dict`` function is written in such a way that for any class\n``c`` we have ``CombinatorialClass.from_dict(c.to_jsonable()) == c``.\n\n.. code:: python\n\n   ...     def to_jsonable(self):\n   ...         return {\"prefix\": self.prefix,\n   ...                 \"patterns\": tuple(sorted(self.patterns)),\n   ...                 \"alphabet\": tuple(sorted(self.alphabet)),\n   ...                 \"just_prefix\": int(self.just_prefix)}\n   ...\n   ...     @classmethod\n   ...     def from_dict(cls, data):\n   ...         return cls(data['prefix'],\n   ...                    data['patterns'],\n   ...                    data['alphabet'],\n   ...                    bool(int(data['just_prefix'])))\n\nWe also add some methods that we will need to get the enumerations of the\nobjects later.\n\n.. code:: python\n\n   ...     def is_epsilon(self):\n   ...         \"\"\" Returns True if the generating function is 1\"\"\"\n   ...         return self.prefix == \"\" and self.just_prefix\n   ...\n   ...     def is_atom(self):\n   ...         \"\"\" Returns True if the generating function is x\"\"\"\n   ...         return len(self.prefix) == 1 and self.just_prefix\n   ...\n   ...     def is_positive(self):\n   ...         \"\"\" Returns True if the constant term of the generating function is 0\"\"\"\n   ...         return len(self.prefix) > 0\n\nOur ``CombinatorialClass`` is now ready. What is left to do is create\nthe strategies that the ``CombinatorialSpecificationSearcher`` will use\nfor performing combinatorial exploration. This is given in the form of a\n``StrategyPack`` which can be imported from ``comb_spec_searcher`` that\nwe will populate in the remainder of this example.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import StrategyPack\n   >>> pack = StrategyPack(initial_strats=[],\n   ...                     inferral_strats=[],\n   ...                     expansion_strats=[],\n   ...                     ver_strats=[],\n   ...                     name=(\"Finding specification for words avoiding \"\n   ...                           \"consecutive patterns.\"))\n\nStrategies are functions that take as input a class ``C`` and produce\nrules about ``C``. The types of strategies are as follows: -\n``initial_strats``: yields rules for classes - ``inferral_strats``:\nreturns a single equivalence rule - ``expansion_strats``: yields rules\nfor classes - ``ver_strats``: returns a rule when the count of a class\nis known\n\nFor example, every word over the alphabet ``\u03a3`` starting with prefix\n``p`` is either just ``p`` or has prefix ``pa`` for some ``a`` in ``\u03a3``.\nThis rule is splitting the original into disjoint subsets. We call a\nrule using disjoint union a ``BatchRule``. Although in this case there\nis a unique rule created by the strategy, strategies are assumed to\ncreate multiple rules, and as such should be implemented as generators.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import BatchRule\n\n\n   >>> def expansion(avoiding_with_prefix, **kwargs):\n   ...     if avoiding_with_prefix.just_prefix:\n   ...         return\n   ...     alphabet, prefix, patterns = (avoiding_with_prefix.alphabet,\n   ...                                   avoiding_with_prefix.prefix,\n   ...                                   avoiding_with_prefix.patterns)\n   ...     # either just p\n   ...     comb_classes = [AvoidingWithPrefix(prefix, patterns, alphabet, True)]\n   ...     for a in alphabet:\n   ...         # or has prefix pa for some a in \u03a3.\n   ...         ends_with_a = AvoidingWithPrefix(prefix + a, patterns, alphabet)\n   ...         comb_classes.append(ends_with_a)\n   ...     yield BatchRule((\"The next letter in the prefix is one of {{{}}}\"\n   ...                      \"\".format(\", \".join(l for l in alphabet))),\n   ...                     comb_classes)\n\nThe classes that we will verify are those that consist of just the\nprefix. To verify these we create a new strategy that returns a\n``VerificationRule`` when this is the case.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import VerificationRule\n\n\n   >>> def only_prefix(avoiding_with_prefix, **kwargs):\n   ...     if avoiding_with_prefix.just_prefix:\n   ...         return VerificationRule((\"The set contains only the word {}\"\n   ...                                  \"\".format(avoiding_with_prefix.prefix)))\n\nThe final strategy we will need is one that peels off much as possible\nfrom the front of the prefix ``p`` such that the avoidance conditions\nare unaffected. This should then give a rule that is a cartesian product\nof the part that is peeled off together with the words whose prefix is\nthat of the remainder of the original prefix. We call rules whose\nconstructor is cartesian product a ``DecompositionRule``.\n\n.. code:: python\n\n   >>> from comb_spec_searcher import DecompositionRule\n\n\n   >>> def remove_front_of_prefix(avoiding_with_prefix, **kwargs):\n   ...     \"\"\"If the k is the maximum length of a pattern to be avoided, then any\n   ...     occurrence using indices further to the right of the prefix can use at\n   ...     most the last k - 1 letters in the prefix.\"\"\"\n   ...     if avoiding_with_prefix.just_prefix:\n   ...         return\n   ...     prefix, patterns, alphabet = (avoiding_with_prefix.prefix,\n   ...                                   avoiding_with_prefix.patterns,\n   ...                                   avoiding_with_prefix.alphabet)\n   ...     # safe will be the index of the prefix in which we can remove upto without\n   ...     # affecting the avoidance conditions\n   ...     safe = max(0, len(prefix) - max(len(p) for p in patterns) + 1)\n   ...     for i in range(safe, len(prefix)):\n   ...         end = prefix[i:]\n   ...         if any(end == patt[:len(end)] for patt in patterns):\n   ...             break\n   ...         safe = i + 1\n   ...     if safe > 0:\n   ...         start_prefix = prefix[:safe]\n   ...         end_prefix = prefix[safe:]\n   ...         start = AvoidingWithPrefix(start_prefix, patterns, alphabet, True)\n   ...         end = AvoidingWithPrefix(end_prefix, patterns, alphabet)\n   ...         yield DecompositionRule(\"Remove up to index {} of prefix\".format(safe),\n   ...                                 [start, end])\n\nWith these three strategies we are now ready to perform combinatorial\nexploration using the following pack.\n\n.. code:: python\n\n   >>> pack = StrategyPack(initial_strats=[remove_front_of_prefix],\n   ...                     inferral_strats=[],\n   ...                     expansion_strats=[[expansion]],\n   ...                     ver_strats=[only_prefix],\n   ...                     name=(\"Finding specification for words avoiding \"\n   ...                           \"consecutive patterns.\"))\n\nFirst we need to create the combinatorial class we want to count. For\nexample, consider the words over the alphabet ``{a, b}`` that avoid\n``ababa`` and ``babb``. This class can be created using our initialise\nfunction.\n\n.. code:: python\n\n   >>> prefix = ''\n   >>> patterns = ['ababa', 'babb']\n   >>> alphabet = ['a', 'b']\n   >>> start_class = AvoidingWithPrefix(prefix, patterns, alphabet)\n\nWe can then initialise our ``CombinatorialSpecificationSearcher``, and\nuse the ``auto_search`` function which will return a ``ProofTree``\nobject that represents a specification assuming one is found (which in\nthis case always will).\n\n.. code:: python\n\n   >>> from comb_spec_searcher import CombinatorialSpecificationSearcher\n\n\n   >>> searcher = CombinatorialSpecificationSearcher(start_class, pack)\n   >>> tree = searcher.auto_search()\n\nNow that we have a ``ProofTree`` i.e., a specification, the obvious\nthing we want to do is find the generating function for the class that\ncounts the number of objects of each size. This can be done by using the\n``get_genf`` or ``get_min_poly`` methods on ``ProofTree``. To use these\nmethods we will need to go back and implement a few functions in our\n``CombinatorialClass``.\n\nWhen you verify a class, this tells the ``ProofTree`` class that it can\nget the generating function by calling the ``get_genf`` (and/or the\n``get_min_poly``) function on ``CombinatorialClass``. In our case, we\nverified exactly when the class was only the prefix, say ``p``. The\ngenerating function of this is clearly ``x**len(p)``. We add these\nmethods to our class.\n\n.. code:: python\n\n   >>> from sympy import abc, var\n\n   >>> def get_genf(self, **kwargs):\n   ...     \"\"\"Return the generating function when only a prefix.\"\"\"\n   ...     if self.just_prefix:\n   ...         if self.is_empty():\n   ...             return 0\n   ...         else:\n   ...             return abc.x**len(self.prefix)\n   >>> AvoidingWithPrefix.get_genf = get_genf\n   >>> def get_min_poly(self, *args, **kwargs):\n   ...     \"\"\"Return the minimum polynomial satisfied by the generating function\n   ...     of the combinatorial class (in terms of F).\"\"\"\n   ...     if self.just_prefix:\n   ...         if self.is_empty():\n   ...             return 0\n   ...         else:\n   ...             return var('F') - abc.x**len(self.prefix)\n   >>> AvoidingWithPrefix.get_min_poly = get_min_poly\n\nFinally, in order to get initial terms, you will also need to implement\nthe ``objects_of_length`` function which should yield all of the objects\nof a given length in the class.\n\n.. code:: python\n\n   >>> from itertools import product\n\n   >>> def objects_of_length(self, length):\n   ...     \"\"\"Yield the words of given length that start with prefix and avoid the\n   ...     patterns. If just_prefix, then only yield that word.\"\"\"\n   ...     def possible_words():\n   ...         \"\"\"Yield all words of given length over the alphabet with prefix\"\"\"\n   ...         if len(self.prefix) > length:\n   ...            return\n   ...         for letters in product(self.alphabet,\n   ...                                 repeat=length - len(self.prefix)):\n   ...             yield self.prefix + \"\".join(a for a in letters)\n   ...\n   ...     if self.just_prefix:\n   ...         if length == len(self.prefix) and not self.is_empty():\n   ...             yield self.prefix\n   ...         return\n   ...     for word in possible_words():\n   ...         if all(patt not in word for patt in self.patterns):\n   ...             yield word\n   >>> AvoidingWithPrefix.objects_of_length = objects_of_length\n\nWith these in place if we then call the ``get_min_poly`` function with\nthe flag ``solve=True``\n\n.. code:: python\n\n   >>> tree.get_min_poly()\n   F*x**6 + F*x**3 - F*x**2 + 2*F*x - F + x**7 + x**5 + x**4 + x**3 + x**2 + 1\n   >>> tree.get_genf()\n   -(x + 1)*(x**2 - x + 1)**2*(x**2 + x + 1)/(x**6 + x**3 - x**2 + 2*x - 1)\n\nwe see that the minimum polynomial satisfied by the generating function\n``F`` is\n``F*(x**6 + x**3 - x**2 + 2*x - 1) + x**7 + x**5 + x**4 + x**3 + x**2 + 1``\nand moreover\n``F = -(x**7 + x**5 + x**4 + x**3 + x**2 + 1)/(x**6 + x**3 - x**2 + 2*x - 1)``.\n\nMoreover, we can get directly the number of objects by length with the method\n`count_objects_of_length`.\n\n.. code:: python\n\n   >>> [tree.count_objects_of_length(i) for i in range(11)]\n   [1, 2, 4, 8, 15, 27, 48, 87, 157, 283, 511]\n\nYou can now try this yourself using the file ``example.py``, which can\ncount any set of words avoiding consecutive patterns.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/PermutaTriangle/comb_spec_searcher", "keywords": "enumerative combinatorics combinatorial specification counting", "license": "BSD-3", "maintainer": "", "maintainer_email": "", "name": "comb-spec-searcher", "package_url": "https://pypi.org/project/comb-spec-searcher/", "platform": "", "project_url": "https://pypi.org/project/comb-spec-searcher/", "project_urls": {"Homepage": "https://github.com/PermutaTriangle/comb_spec_searcher", "Source": "https://github.com/PermutaTriangle/comb_spec_searcher", "Tracker": "https://github.com/PermutaTriangle/comb_spec_searcher/issues"}, "release_url": "https://pypi.org/project/comb-spec-searcher/0.5.0/", "requires_dist": null, "requires_python": ">=3.5", "summary": "A library for performing combinatorial exploration.", "version": "0.5.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/PermutaTriangle/comb_spec_searcher\" rel=\"nofollow\"><img alt=\"Travis\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5cd7a7ddbb741e10fe9973bc858ef84aae1f1d92/68747470733a2f2f7472617669732d63692e6f72672f5065726d757461547269616e676c652f636f6d625f737065635f73656172636865722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/PermutaTriangle/comb_spec_searcher\" rel=\"nofollow\"><img alt=\"Coveralls\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a9627966eeaa4193ddad121624bcf48218e66694/68747470733a2f2f696d672e736869656c64732e696f2f636f766572616c6c732f6769746875622f5065726d757461547269616e676c652f636f6d625f737065635f73656172636865722e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/comb_spec_searcher\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8ff60e4c3ecd6002c7a409e856d18060e25a847b/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f636f6d625f737065635f73656172636865722e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/comb_spec_searcher\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/l/comb_spec_searcher.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4a7f523e4516fc859f070026c9bc5c8f92772f56/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f636f6d625f737065635f73656172636865722e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/comb_spec_searcher\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/pyversions/comb_spec_searcher.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1b374facdcccdcb7b37338ac616c75405a1542b4/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f636f6d625f737065635f73656172636865722e737667\"></a>\n<a href=\"https://travis-ci.org/PermutaTriangle/comb_spec_searcher\" rel=\"nofollow\"><img alt=\"Travis\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f383ec26d7de8ebe4e4066de3f394faa52e78b78/687474703a2f2f696d672e736869656c64732e696f2f62616467652f726561646d652d7465737465642d627269676874677265656e2e737667\"></a>\n<a href=\"https://requires.io/github/PermutaTriangle/comb_spec_searcher/requirements/?branch=master\" rel=\"nofollow\"><img alt=\"Requirements Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/33c5e3182a7fd03900555dc60ef30300ecbee51e/68747470733a2f2f72657175697265732e696f2f6769746875622f5065726d757461547269616e676c652f636f6d625f737065635f73656172636865722f726571756972656d656e74732e7376673f6272616e63683d6d6173746572\"></a>\n<p>The <tt>comb_spec_searcher</tt> package contains code for combinatorial\nexploration.</p>\n<div id=\"installing\">\n<h2>Installing</h2>\n<p>To install <tt>comb_spec_searcher</tt> on your system, run:</p>\n<pre>pip install comb_spec_searcher\n</pre>\n<p>It is also possible to install comb_spec_searcher in development mode to\nwork on the source code, in which case you run the following after\ncloning the repository:</p>\n<pre>./setup.py develop\n</pre>\n</div>\n<div id=\"combinatorial-exploration\">\n<h2>Combinatorial exploration</h2>\n<p>A (combinatorial) class is a set of objects with a notion of size such\nthat there are finitely many objects of each size. One of the primary\ngoals of enumerative combinatorics is to count how many objects of each\nsize there are in a class. One method for doing this is to find a\n(combinatorial) specification, which is a collection of (combinatorial)\nrules that describe how to build a class from other classes using\nwell-defined constructors. Such a specification can then be used to\ncount the number of objects of each size.</p>\n<p><em>Combinatorial exploration</em> is a systematic application of strategies to\ncreate rules about a class of interest, until a specification can be\nfound. This package can be used to perform this process automatically.\nSee the <a href=\"https://permutatriangle.github.io/papers/2019-02-27-combex.html\" rel=\"nofollow\">Combinatorial Exploration\nproject</a>\nand <a href=\"https://skemman.is/handle/1946/31663\" rel=\"nofollow\">Christian Bean\u2019s PhD\nthesis</a> for more details.</p>\n<p>The remainder of this README will be an example of how to use this\npackage for performing combinatorial exploration on a specific class,\nnamely words avoiding consecutive patterns.</p>\n</div>\n<div id=\"avoiding-consecutive-patterns-in-words\">\n<h2>Avoiding consecutive patterns in words</h2>\n<p>A word <tt>w</tt> over an alphabet <tt>\u03a3</tt> is a string consisting of letters\nfrom <tt>\u03a3</tt>. We say that <tt>w</tt> contains the word <tt>p</tt> if there is a\nconsecutive sequence of letters in <tt>w</tt> equal to <tt>p</tt>. We say <tt>w</tt>\navoids <tt>p</tt> if it does not contain <tt>p</tt>. In this context, we call\n<tt>p</tt> a pattern. In <tt>python</tt>, this containment check can be checked\nusing <tt>in</tt>.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"s2\">\"acbabcabbb\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"s2\">\"abcab\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">w</span>\n<span class=\"kc\">True</span>\n</pre>\n<p>For an alphabet <tt>\u03a3</tt> and a set of patterns <tt>P</tt> we define <tt><span class=\"pre\">\u03a3*(P)</span></tt> to\nbe the set of words over <tt>\u03a3</tt> that avoid every pattern in <tt>P</tt>. These\nare the classes that we will count. Of course, these all form regular\nlanguages, but it will serve as a good example of how to use the\n<tt>comb_spec_searcher</tt> package.</p>\n<p>The first step is to create the classes that will be used for\ndiscovering the underlying structure of the class of interest. In this\ncase, considering the prefix of the words is what we need. We then\ncreate a new python <tt>class</tt> representing this that inherits from\n<tt>CombinatorialClass</tt> which can be imported from\n<tt>comb_spec_searcher</tt>.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">comb_spec_searcher</span> <span class=\"kn\">import</span> <span class=\"n\">CombinatorialClass</span>\n\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">class</span> <span class=\"nc\">AvoidingWithPrefix</span><span class=\"p\">(</span><span class=\"n\">CombinatorialClass</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">alphabet</span><span class=\"p\">,</span> <span class=\"n\">just_prefix</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alphabet</span> <span class=\"o\">=</span> <span class=\"nb\">frozenset</span><span class=\"p\">(</span><span class=\"n\">alphabet</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>         <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"n\">prefix</span>\n<span class=\"o\">...</span>         <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patterns</span> <span class=\"o\">=</span> <span class=\"nb\">frozenset</span><span class=\"p\">(</span><span class=\"n\">patterns</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>         <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span> <span class=\"o\">=</span> <span class=\"n\">just_prefix</span> <span class=\"c1\"># this will be needed later</span>\n</pre>\n<p>Inheriting from <tt>CombinatorialClass</tt> requires you to implement a few\nfunctions for combinatorial exploration: <tt>is_empty</tt>, <tt>to_jsonable</tt>,\n<tt>__eq__</tt>, <tt>__hash__</tt>, <tt>__repr__</tt>, and <tt>__str__</tt>.</p>\n<p>We will start by implementing the dunder methods (the ones with double\nunderscores) required. The <tt>__eq__</tt> method is particularly important\nas the <tt>CombinatorialSpecificationSearcher</tt> will use it to recognise\nif the same class appears multiple times.</p>\n<pre><span class=\"o\">...</span>     <span class=\"c1\"># The dunder methods required to perform combinatorial exploration</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"fm\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alphabet</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">alphabet</span> <span class=\"ow\">and</span>\n<span class=\"o\">...</span>                 <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"ow\">and</span>\n<span class=\"o\">...</span>                 <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patterns</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">patterns</span> <span class=\"ow\">and</span>\n<span class=\"o\">...</span>                 <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"fm\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">hash</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">)</span> <span class=\"o\">+</span>\n<span class=\"o\">...</span>                     <span class=\"nb\">hash</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alphabet</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"nb\">hash</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">))</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"fm\">__str__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>             <span class=\"k\">return</span> <span class=\"s2\">\"The word </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"s2\">\"Words over {{</span><span class=\"si\">{}</span><span class=\"s2\">}} avoiding {{</span><span class=\"si\">{}</span><span class=\"s2\">}} with prefix </span><span class=\"si\">{}</span><span class=\"s2\">\"</span>\n<span class=\"o\">...</span>                 <span class=\"s2\">\"\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"s2\">\", \"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alphabet</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>                           <span class=\"s2\">\", \"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>                           <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"k\">else</span> <span class=\"s1\">'\"\"'</span><span class=\"p\">))</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"s2\">\"AvoidingWithPrefix(</span><span class=\"si\">{}</span><span class=\"s2\">, </span><span class=\"si\">{}</span><span class=\"s2\">, </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>                                                       <span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>                                                       <span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alphabet</span><span class=\"p\">))</span>\n</pre>\n<p>Perhaps the most important function to be implemented is the\n<tt>is_empty</tt> function. This should return <tt>True</tt> if there are no\nobjects of any length in the class, otherwise <tt>False</tt>. If it is not\ncorrectly implemented it may lead to tautological specifications. For\nexample, in our case the class is empty if and only if the prefix\ncontains a pattern to be avoided.</p>\n<pre><span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"nf\">is_empty</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">)</span>\n</pre>\n<p>The final function required is <tt>to_jsonable</tt>. This is primarily for\nthe output, and only necessary for saving the output. It should be in a\nformat that can be interpretated by <tt>json</tt>. What is important is that\nthe <tt>from_dict</tt> function is written in such a way that for any class\n<tt>c</tt> we have <tt><span class=\"pre\">CombinatorialClass.from_dict(c.to_jsonable())</span> == c</tt>.</p>\n<pre><span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"nf\">to_jsonable</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"prefix\"</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>                 <span class=\"s2\">\"patterns\"</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">)),</span>\n<span class=\"o\">...</span>                 <span class=\"s2\">\"alphabet\"</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alphabet</span><span class=\"p\">)),</span>\n<span class=\"o\">...</span>                 <span class=\"s2\">\"just_prefix\"</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">)}</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"nd\">@classmethod</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"nf\">from_dict</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"bp\">cls</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">'prefix'</span><span class=\"p\">],</span>\n<span class=\"o\">...</span>                    <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">'patterns'</span><span class=\"p\">],</span>\n<span class=\"o\">...</span>                    <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">'alphabet'</span><span class=\"p\">],</span>\n<span class=\"o\">...</span>                    <span class=\"nb\">bool</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">'just_prefix'</span><span class=\"p\">])))</span>\n</pre>\n<p>We also add some methods that we will need to get the enumerations of the\nobjects later.</p>\n<pre><span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"nf\">is_epsilon</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"s2\">\"\"\" Returns True if the generating function is 1\"\"\"</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"o\">==</span> <span class=\"s2\">\"\"</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"nf\">is_atom</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"s2\">\"\"\" Returns True if the generating function is x\"\"\"</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"nf\">is_positive</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>         <span class=\"s2\">\"\"\" Returns True if the constant term of the generating function is 0\"\"\"</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span>\n</pre>\n<p>Our <tt>CombinatorialClass</tt> is now ready. What is left to do is create\nthe strategies that the <tt>CombinatorialSpecificationSearcher</tt> will use\nfor performing combinatorial exploration. This is given in the form of a\n<tt>StrategyPack</tt> which can be imported from <tt>comb_spec_searcher</tt> that\nwe will populate in the remainder of this example.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">comb_spec_searcher</span> <span class=\"kn\">import</span> <span class=\"n\">StrategyPack</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pack</span> <span class=\"o\">=</span> <span class=\"n\">StrategyPack</span><span class=\"p\">(</span><span class=\"n\">initial_strats</span><span class=\"o\">=</span><span class=\"p\">[],</span>\n<span class=\"o\">...</span>                     <span class=\"n\">inferral_strats</span><span class=\"o\">=</span><span class=\"p\">[],</span>\n<span class=\"o\">...</span>                     <span class=\"n\">expansion_strats</span><span class=\"o\">=</span><span class=\"p\">[],</span>\n<span class=\"o\">...</span>                     <span class=\"n\">ver_strats</span><span class=\"o\">=</span><span class=\"p\">[],</span>\n<span class=\"o\">...</span>                     <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s2\">\"Finding specification for words avoiding \"</span>\n<span class=\"o\">...</span>                           <span class=\"s2\">\"consecutive patterns.\"</span><span class=\"p\">))</span>\n</pre>\n<p>Strategies are functions that take as input a class <tt>C</tt> and produce\nrules about <tt>C</tt>. The types of strategies are as follows: -\n<tt>initial_strats</tt>: yields rules for classes - <tt>inferral_strats</tt>:\nreturns a single equivalence rule - <tt>expansion_strats</tt>: yields rules\nfor classes - <tt>ver_strats</tt>: returns a rule when the count of a class\nis known</p>\n<p>For example, every word over the alphabet <tt>\u03a3</tt> starting with prefix\n<tt>p</tt> is either just <tt>p</tt> or has prefix <tt>pa</tt> for some <tt>a</tt> in <tt>\u03a3</tt>.\nThis rule is splitting the original into disjoint subsets. We call a\nrule using disjoint union a <tt>BatchRule</tt>. Although in this case there\nis a unique rule created by the strategy, strategies are assumed to\ncreate multiple rules, and as such should be implemented as generators.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">comb_spec_searcher</span> <span class=\"kn\">import</span> <span class=\"n\">BatchRule</span>\n\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">expansion</span><span class=\"p\">(</span><span class=\"n\">avoiding_with_prefix</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span>\n<span class=\"o\">...</span>     <span class=\"n\">alphabet</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"n\">patterns</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">alphabet</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>                                   <span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>                                   <span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"c1\"># either just p</span>\n<span class=\"o\">...</span>     <span class=\"n\">comb_classes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">AvoidingWithPrefix</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">alphabet</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">)]</span>\n<span class=\"o\">...</span>     <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"n\">alphabet</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"c1\"># or has prefix pa for some a in \u03a3.</span>\n<span class=\"o\">...</span>         <span class=\"n\">ends_with_a</span> <span class=\"o\">=</span> <span class=\"n\">AvoidingWithPrefix</span><span class=\"p\">(</span><span class=\"n\">prefix</span> <span class=\"o\">+</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">alphabet</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>         <span class=\"n\">comb_classes</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">ends_with_a</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"k\">yield</span> <span class=\"n\">BatchRule</span><span class=\"p\">((</span><span class=\"s2\">\"The next letter in the prefix is one of {{</span><span class=\"si\">{}</span><span class=\"s2\">}}\"</span>\n<span class=\"o\">...</span>                      <span class=\"s2\">\"\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"s2\">\", \"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"k\">for</span> <span class=\"n\">l</span> <span class=\"ow\">in</span> <span class=\"n\">alphabet</span><span class=\"p\">))),</span>\n<span class=\"o\">...</span>                     <span class=\"n\">comb_classes</span><span class=\"p\">)</span>\n</pre>\n<p>The classes that we will verify are those that consist of just the\nprefix. To verify these we create a new strategy that returns a\n<tt>VerificationRule</tt> when this is the case.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">comb_spec_searcher</span> <span class=\"kn\">import</span> <span class=\"n\">VerificationRule</span>\n\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">only_prefix</span><span class=\"p\">(</span><span class=\"n\">avoiding_with_prefix</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span> <span class=\"n\">VerificationRule</span><span class=\"p\">((</span><span class=\"s2\">\"The set contains only the word </span><span class=\"si\">{}</span><span class=\"s2\">\"</span>\n<span class=\"o\">...</span>                                  <span class=\"s2\">\"\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)))</span>\n</pre>\n<p>The final strategy we will need is one that peels off much as possible\nfrom the front of the prefix <tt>p</tt> such that the avoidance conditions\nare unaffected. This should then give a rule that is a cartesian product\nof the part that is peeled off together with the words whose prefix is\nthat of the remainder of the original prefix. We call rules whose\nconstructor is cartesian product a <tt>DecompositionRule</tt>.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">comb_spec_searcher</span> <span class=\"kn\">import</span> <span class=\"n\">DecompositionRule</span>\n\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">remove_front_of_prefix</span><span class=\"p\">(</span><span class=\"n\">avoiding_with_prefix</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"s2\">\"\"\"If the k is the maximum length of a pattern to be avoided, then any\n...     occurrence using indices further to the right of the prefix can use at\n...     most the last k - 1 letters in the prefix.\"\"\"</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span>\n<span class=\"o\">...</span>     <span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">alphabet</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>                                   <span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>                                   <span class=\"n\">avoiding_with_prefix</span><span class=\"o\">.</span><span class=\"n\">alphabet</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"c1\"># safe will be the index of the prefix in which we can remove upto without</span>\n<span class=\"o\">...</span>     <span class=\"c1\"># affecting the avoidance conditions</span>\n<span class=\"o\">...</span>     <span class=\"n\">safe</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">patterns</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">safe</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">)):</span>\n<span class=\"o\">...</span>         <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">prefix</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">:]</span>\n<span class=\"o\">...</span>         <span class=\"k\">if</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">==</span> <span class=\"n\">patt</span><span class=\"p\">[:</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">end</span><span class=\"p\">)]</span> <span class=\"k\">for</span> <span class=\"n\">patt</span> <span class=\"ow\">in</span> <span class=\"n\">patterns</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>             <span class=\"k\">break</span>\n<span class=\"o\">...</span>         <span class=\"n\">safe</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"n\">safe</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"n\">start_prefix</span> <span class=\"o\">=</span> <span class=\"n\">prefix</span><span class=\"p\">[:</span><span class=\"n\">safe</span><span class=\"p\">]</span>\n<span class=\"o\">...</span>         <span class=\"n\">end_prefix</span> <span class=\"o\">=</span> <span class=\"n\">prefix</span><span class=\"p\">[</span><span class=\"n\">safe</span><span class=\"p\">:]</span>\n<span class=\"o\">...</span>         <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">AvoidingWithPrefix</span><span class=\"p\">(</span><span class=\"n\">start_prefix</span><span class=\"p\">,</span> <span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">alphabet</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>         <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">AvoidingWithPrefix</span><span class=\"p\">(</span><span class=\"n\">end_prefix</span><span class=\"p\">,</span> <span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">alphabet</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>         <span class=\"k\">yield</span> <span class=\"n\">DecompositionRule</span><span class=\"p\">(</span><span class=\"s2\">\"Remove up to index </span><span class=\"si\">{}</span><span class=\"s2\"> of prefix\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">safe</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>                                 <span class=\"p\">[</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">])</span>\n</pre>\n<p>With these three strategies we are now ready to perform combinatorial\nexploration using the following pack.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pack</span> <span class=\"o\">=</span> <span class=\"n\">StrategyPack</span><span class=\"p\">(</span><span class=\"n\">initial_strats</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">remove_front_of_prefix</span><span class=\"p\">],</span>\n<span class=\"o\">...</span>                     <span class=\"n\">inferral_strats</span><span class=\"o\">=</span><span class=\"p\">[],</span>\n<span class=\"o\">...</span>                     <span class=\"n\">expansion_strats</span><span class=\"o\">=</span><span class=\"p\">[[</span><span class=\"n\">expansion</span><span class=\"p\">]],</span>\n<span class=\"o\">...</span>                     <span class=\"n\">ver_strats</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">only_prefix</span><span class=\"p\">],</span>\n<span class=\"o\">...</span>                     <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s2\">\"Finding specification for words avoiding \"</span>\n<span class=\"o\">...</span>                           <span class=\"s2\">\"consecutive patterns.\"</span><span class=\"p\">))</span>\n</pre>\n<p>First we need to create the combinatorial class we want to count. For\nexample, consider the words over the alphabet <tt>{a, b}</tt> that avoid\n<tt>ababa</tt> and <tt>babb</tt>. This class can be created using our initialise\nfunction.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">''</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">patterns</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'ababa'</span><span class=\"p\">,</span> <span class=\"s1\">'babb'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">alphabet</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">start_class</span> <span class=\"o\">=</span> <span class=\"n\">AvoidingWithPrefix</span><span class=\"p\">(</span><span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"n\">patterns</span><span class=\"p\">,</span> <span class=\"n\">alphabet</span><span class=\"p\">)</span>\n</pre>\n<p>We can then initialise our <tt>CombinatorialSpecificationSearcher</tt>, and\nuse the <tt>auto_search</tt> function which will return a <tt>ProofTree</tt>\nobject that represents a specification assuming one is found (which in\nthis case always will).</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">comb_spec_searcher</span> <span class=\"kn\">import</span> <span class=\"n\">CombinatorialSpecificationSearcher</span>\n\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">searcher</span> <span class=\"o\">=</span> <span class=\"n\">CombinatorialSpecificationSearcher</span><span class=\"p\">(</span><span class=\"n\">start_class</span><span class=\"p\">,</span> <span class=\"n\">pack</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">searcher</span><span class=\"o\">.</span><span class=\"n\">auto_search</span><span class=\"p\">()</span>\n</pre>\n<p>Now that we have a <tt>ProofTree</tt> i.e., a specification, the obvious\nthing we want to do is find the generating function for the class that\ncounts the number of objects of each size. This can be done by using the\n<tt>get_genf</tt> or <tt>get_min_poly</tt> methods on <tt>ProofTree</tt>. To use these\nmethods we will need to go back and implement a few functions in our\n<tt>CombinatorialClass</tt>.</p>\n<p>When you verify a class, this tells the <tt>ProofTree</tt> class that it can\nget the generating function by calling the <tt>get_genf</tt> (and/or the\n<tt>get_min_poly</tt>) function on <tt>CombinatorialClass</tt>. In our case, we\nverified exactly when the class was only the prefix, say <tt>p</tt>. The\ngenerating function of this is clearly <tt><span class=\"pre\">x**len(p)</span></tt>. We add these\nmethods to our class.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">sympy</span> <span class=\"kn\">import</span> <span class=\"n\">abc</span><span class=\"p\">,</span> <span class=\"n\">var</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">get_genf</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"s2\">\"\"\"Return the generating function when only a prefix.\"\"\"</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">is_empty</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>             <span class=\"k\">return</span> <span class=\"mi\">0</span>\n<span class=\"o\">...</span>         <span class=\"k\">else</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>             <span class=\"k\">return</span> <span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">AvoidingWithPrefix</span><span class=\"o\">.</span><span class=\"n\">get_genf</span> <span class=\"o\">=</span> <span class=\"n\">get_genf</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">get_min_poly</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"s2\">\"\"\"Return the minimum polynomial satisfied by the generating function\n...     of the combinatorial class (in terms of F).\"\"\"</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">is_empty</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>             <span class=\"k\">return</span> <span class=\"mi\">0</span>\n<span class=\"o\">...</span>         <span class=\"k\">else</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>             <span class=\"k\">return</span> <span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s1\">'F'</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">AvoidingWithPrefix</span><span class=\"o\">.</span><span class=\"n\">get_min_poly</span> <span class=\"o\">=</span> <span class=\"n\">get_min_poly</span>\n</pre>\n<p>Finally, in order to get initial terms, you will also need to implement\nthe <tt>objects_of_length</tt> function which should yield all of the objects\nof a given length in the class.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">itertools</span> <span class=\"kn\">import</span> <span class=\"n\">product</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">def</span> <span class=\"nf\">objects_of_length</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"s2\">\"\"\"Yield the words of given length that start with prefix and avoid the\n...     patterns. If just_prefix, then only yield that word.\"\"\"</span>\n<span class=\"o\">...</span>     <span class=\"k\">def</span> <span class=\"nf\">possible_words</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>         <span class=\"s2\">\"\"\"Yield all words of given length over the alphabet with prefix\"\"\"</span>\n<span class=\"o\">...</span>         <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">length</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>            <span class=\"k\">return</span>\n<span class=\"o\">...</span>         <span class=\"k\">for</span> <span class=\"n\">letters</span> <span class=\"ow\">in</span> <span class=\"n\">product</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">alphabet</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>                                 <span class=\"n\">repeat</span><span class=\"o\">=</span><span class=\"n\">length</span> <span class=\"o\">-</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)):</span>\n<span class=\"o\">...</span>             <span class=\"k\">yield</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"o\">+</span> <span class=\"s2\">\"\"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"n\">letters</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">just_prefix</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"k\">if</span> <span class=\"n\">length</span> <span class=\"o\">==</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">is_empty</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>             <span class=\"k\">yield</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span>\n<span class=\"o\">...</span>         <span class=\"k\">return</span>\n<span class=\"o\">...</span>     <span class=\"k\">for</span> <span class=\"n\">word</span> <span class=\"ow\">in</span> <span class=\"n\">possible_words</span><span class=\"p\">():</span>\n<span class=\"o\">...</span>         <span class=\"k\">if</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"n\">patt</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">word</span> <span class=\"k\">for</span> <span class=\"n\">patt</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patterns</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>             <span class=\"k\">yield</span> <span class=\"n\">word</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">AvoidingWithPrefix</span><span class=\"o\">.</span><span class=\"n\">objects_of_length</span> <span class=\"o\">=</span> <span class=\"n\">objects_of_length</span>\n</pre>\n<p>With these in place if we then call the <tt>get_min_poly</tt> function with\nthe flag <tt>solve=True</tt></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">get_min_poly</span><span class=\"p\">()</span>\n<span class=\"n\">F</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">6</span> <span class=\"o\">+</span> <span class=\"n\">F</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">3</span> <span class=\"o\">-</span> <span class=\"n\">F</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">F</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"n\">F</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">7</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">5</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">4</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">3</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">get_genf</span><span class=\"p\">()</span>\n<span class=\"o\">-</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">6</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">3</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>we see that the minimum polynomial satisfied by the generating function\n<tt>F</tt> is\n<tt><span class=\"pre\">F*(x**6</span> + <span class=\"pre\">x**3</span> - <span class=\"pre\">x**2</span> + 2*x - 1) + <span class=\"pre\">x**7</span> + <span class=\"pre\">x**5</span> + <span class=\"pre\">x**4</span> + <span class=\"pre\">x**3</span> + <span class=\"pre\">x**2</span> + 1</tt>\nand moreover\n<tt>F = <span class=\"pre\">-(x**7</span> + <span class=\"pre\">x**5</span> + <span class=\"pre\">x**4</span> + <span class=\"pre\">x**3</span> + <span class=\"pre\">x**2</span> + <span class=\"pre\">1)/(x**6</span> + <span class=\"pre\">x**3</span> - <span class=\"pre\">x**2</span> + 2*x - 1)</tt>.</p>\n<p>Moreover, we can get directly the number of objects by length with the method\n<cite>count_objects_of_length</cite>.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">[</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">count_objects_of_length</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">11</span><span class=\"p\">)]</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"mi\">27</span><span class=\"p\">,</span> <span class=\"mi\">48</span><span class=\"p\">,</span> <span class=\"mi\">87</span><span class=\"p\">,</span> <span class=\"mi\">157</span><span class=\"p\">,</span> <span class=\"mi\">283</span><span class=\"p\">,</span> <span class=\"mi\">511</span><span class=\"p\">]</span>\n</pre>\n<p>You can now try this yourself using the file <tt>example.py</tt>, which can\ncount any set of words avoiding consecutive patterns.</p>\n</div>\n\n          </div>"}, "last_serial": 6913901, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "579c732385da80b3ecfa898972cdb6be", "sha256": "f8b8463d2155e013940185feb2ed0471a73b5ca623cef52de9e3cf2fc3a371c6"}, "downloads": -1, "filename": "comb_spec_searcher-0.1.0.tar.gz", "has_sig": false, "md5_digest": "579c732385da80b3ecfa898972cdb6be", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 37207, "upload_time": "2019-05-28T14:20:40", "upload_time_iso_8601": "2019-05-28T14:20:40.891718Z", "url": "https://files.pythonhosted.org/packages/5a/b0/97e8ed3ac923abca077221f7b4ca8529de6ed2d304f0cef9238197f4de83/comb_spec_searcher-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "77a4d470cf0a42a04211b26124d188ae", "sha256": "eb1b63d2c813e090afaad13a96ebac86436c4e74df197e03e5c0d3e1e8dbf4fe"}, "downloads": -1, "filename": "comb_spec_searcher-0.2.0.tar.gz", "has_sig": false, "md5_digest": "77a4d470cf0a42a04211b26124d188ae", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 39398, "upload_time": "2019-08-26T15:08:48", "upload_time_iso_8601": "2019-08-26T15:08:48.193469Z", "url": "https://files.pythonhosted.org/packages/69/09/8fbf254b3cd4fb2a4c1c031a3ed0193089f412c5045aa0ac0ccbfe235066/comb_spec_searcher-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "9d3655476280ce8df57f948679a4750c", "sha256": "59c1115b7a1e299df18859880acbe309837d31f2dfc79c2c9cde1e383d5cddb7"}, "downloads": -1, "filename": "comb_spec_searcher-0.2.1.tar.gz", "has_sig": false, "md5_digest": "9d3655476280ce8df57f948679a4750c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 39396, "upload_time": "2019-08-26T17:01:43", "upload_time_iso_8601": "2019-08-26T17:01:43.106153Z", "url": "https://files.pythonhosted.org/packages/79/d9/a52d9198702efde2ddd0217973485966602f6e582d4dc4f911a4d4f7cd5e/comb_spec_searcher-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "5e8550277aec1c1d08e3dc38ce684210", "sha256": "62138211bcb17b760296b091c22de1e599abdbc1ee5dc516a4eba9636e4b89e0"}, "downloads": -1, "filename": "comb_spec_searcher-0.2.2.tar.gz", "has_sig": false, "md5_digest": "5e8550277aec1c1d08e3dc38ce684210", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 41268, "upload_time": "2019-09-06T15:02:27", "upload_time_iso_8601": "2019-09-06T15:02:27.001177Z", "url": "https://files.pythonhosted.org/packages/7c/df/df26af38316cb5837a24d192575dc07b79c96a0999efb1e143f6a74ebe21/comb_spec_searcher-0.2.2.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "62b342f8f140a43cd3d60e97651ffc06", "sha256": "c91c091744b515484fd40fa5acebd8353e650b37218acd8a593aed6c4b02a8ff"}, "downloads": -1, "filename": "comb_spec_searcher-0.3.0.tar.gz", "has_sig": false, "md5_digest": "62b342f8f140a43cd3d60e97651ffc06", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 36195, "upload_time": "2020-01-20T10:49:49", "upload_time_iso_8601": "2020-01-20T10:49:49.886856Z", "url": "https://files.pythonhosted.org/packages/a1/1d/a87fa3e6302793a6c712f75d1b6eb074de14a65eb4ed19f9bd335cdcd4ba/comb_spec_searcher-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "afdd179d6ecc45d43ede331024001926", "sha256": "3d3420a29dca7ef3e3fafff8b46ca481aa5f49e315c395a2ffc14b7da5b52bae"}, "downloads": -1, "filename": "comb_spec_searcher-0.4.0.tar.gz", "has_sig": false, "md5_digest": "afdd179d6ecc45d43ede331024001926", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 41531, "upload_time": "2020-02-20T12:38:35", "upload_time_iso_8601": "2020-02-20T12:38:35.929859Z", "url": "https://files.pythonhosted.org/packages/7b/fc/9fcb6d3231f6960196d9a7112fcce131fba597689e7dbaa4df4207562e8c/comb_spec_searcher-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "6e37fa19f8420950f667984e29f3cb4e", "sha256": "d7864a654457b5c31225ec9f218b4be05b7dbbfa39002cb66f6c519f5b29a558"}, "downloads": -1, "filename": "comb_spec_searcher-0.5.0.tar.gz", "has_sig": false, "md5_digest": "6e37fa19f8420950f667984e29f3cb4e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 42199, "upload_time": "2020-03-30T15:43:11", "upload_time_iso_8601": "2020-03-30T15:43:11.991213Z", "url": "https://files.pythonhosted.org/packages/65/fe/fe8dc03a66e0915de3d2addfab0fea19ad9365f1e20f40d0673155cbc2ce/comb_spec_searcher-0.5.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6e37fa19f8420950f667984e29f3cb4e", "sha256": "d7864a654457b5c31225ec9f218b4be05b7dbbfa39002cb66f6c519f5b29a558"}, "downloads": -1, "filename": "comb_spec_searcher-0.5.0.tar.gz", "has_sig": false, "md5_digest": "6e37fa19f8420950f667984e29f3cb4e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 42199, "upload_time": "2020-03-30T15:43:11", "upload_time_iso_8601": "2020-03-30T15:43:11.991213Z", "url": "https://files.pythonhosted.org/packages/65/fe/fe8dc03a66e0915de3d2addfab0fea19ad9365f1e20f40d0673155cbc2ce/comb_spec_searcher-0.5.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:28 2020"}