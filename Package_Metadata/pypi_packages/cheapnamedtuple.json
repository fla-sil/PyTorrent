{"info": {"author": "Arnau Orriols", "author_email": "dev@arnauorriols.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Programming Language :: Python :: 2 :: Only"], "description": "Cheap namedtuple implementation (Python 2.7)\n============================================\n\nNamedtuples are a neat goody of Python, but they have one big caveat. In\norder to be precise with the type definition, they compile with exec a\nstring template, formated with the variables given in the namedtuple()\nfunction factory. This compilation is very expensive computation-wise,\nand in practice can be spared if needed for performance reasons.\n\nAn `issue <http://bugs.python.org/issue3974>`__ was opened years ago in\nthe Python bug tracker but it got rejected, arguing that the official\nimplementation is clearer and more maintainable. This is true, but there\nare cases where performance is key, and the current implementation using\nexec is just not an option.\n\nIf you need to define new namedtuple types dynamically, and you have\nhigh performance constraints, this is for you.\n\nThere are multiple versions out there, using\n`metaclasses <https://gist.github.com/aliles/1160525>`__, or\n`metaclasses <http://bugs.python.org/file11608/new_namedtuples.diff>`__,\nor\n`ABC <http://code.activestate.com/recipes/577629-namedtupleabc-abstract-base-class-mix-in-for-named/>`__\n\nThis versions is simpler. Just define a new class closed-over by the\nfactory function.\n\nUnittests from cPython2.7 implementation are copied here to assert that\nthe same expected behaviour is honored.\n\nInstall\n-------\n\n.. code:: bash\n\n    pip install cheapnamedtuple\n\nUsage\n-----\n\nFor the purist, the ``namedtuple`` implementation is 3.75x faster than\nPython's implementation, while honouring 100% of the Python's\nimplementation behaviour, including docstrings and everything else\n(corroborated by unit tests):\n\n.. code:: python\n\n    >>> from cheapnamedtuple import namedtuple\n    >>> Point = namedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)\n\nFor the practical, a ``cheapnamedtuple`` implementation is 26.6x faster\nthan the Python's implementation, while still honouring all the public\nbehaviour (corroborated by doctests), and still supporting copy and\npickle. The only caveats identified so far are:\n\n-  The docstring of the type generated by the cheapnamedtuple factory\n   cannot be generated ad-hoc for it\n-  Some typechecking has been trade in favor of performance (see\n   test\\_name\\_fixer test case)\n\n.. code:: python\n\n    >>> from cheapnamedtuple import cheapnamedtuple\n    >>> Point = cheapnamedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)\n\nCompatibility\n=============\n\nCurrently only tested in Python 2.7\n\nBenchmarking\n============\n\nPython's stdlib implementation:\n\n.. code:: bash\n\n    $python -m timeit -vvvv \"from collections import namedtuple\" \"A = namedtuple('A', ['foo', 'bar', 'foobar'])\" \"a = A(1, 2, 3)\" \"a.bar\"\n    10 loops -> 0.00922394 secs\n    100 loops -> 0.0595999 secs\n    1000 loops -> 0.350676 secs\n    raw times: 0.328964 0.33169 0.327519\n    1000 loops, best of 3: 327.519 usec per loop\n\n``namedtuple`` implementation:\n\n.. code:: bash\n\n    $ python -m timeit -vvvv \"from cheapnamedtuple import namedtuple\" \"A = namedtuple('A', ['foo', 'bar', 'foobar'])\" \"a = A(1, 2, 3)\" \"a.bar\"\n    10 loops -> 0.00332594 secs\n    100 loops -> 0.01106 secs\n    1000 loops -> 0.09164 secs\n    10000 loops -> 0.955008 secs\n    raw times: 0.929455 0.872804 0.904877\n    10000 loops, best of 3: 87.2804 usec per loop\n\n``cheapnamedtuple`` implementation:\n\n.. code:: bash\n\n    $ python -m timeit -vvvv \"from cheapnamedtuple import cheapnamedtuple\" \"A = cheapnamedtuple('A', ['foo', 'bar', 'foobar'])\" \"a = A(1, 2, 3)\" \"a.bar\"\n    10 loops -> 0.00241184 secs\n    100 loops -> 0.00281 secs\n    1000 loops -> 0.0245481 secs\n    10000 loops -> 0.156194 secs\n    100000 loops -> 1.25612 secs\n    raw times: 1.23459 1.23159 1.23687\n    100000 loops, best of 3: 12.3159 usec per loop\n\nUsing metaclass version found\n`here <https://gist.github.com/aliles/1160525>`__:\n\n.. code:: bash\n\n    $ python -m timeit -vvvv \"from metanamedtuple import namedtuple\" \"A = namedtuple('A', ['foo', 'bar', 'foobar'])\" \"a = A(1, 2, 3)\" \"a.bar\"\n    10 loops -> 0.00334907 secs\n    100 loops -> 0.0108609 secs\n    1000 loops -> 0.088969 secs\n    10000 loops -> 1.25756 secs\n    raw times: 1.2868 1.24004 1.25383\n    10000 loops, best of 3: 124.004 usec per loop", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/arnauorriols/cheapnamedtuple", "keywords": "namedtuple exec performance", "license": "MIT License", "maintainer": null, "maintainer_email": null, "name": "cheapnamedtuple", "package_url": "https://pypi.org/project/cheapnamedtuple/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/cheapnamedtuple/", "project_urls": {"Homepage": "https://github.com/arnauorriols/cheapnamedtuple"}, "release_url": "https://pypi.org/project/cheapnamedtuple/1.1.2/", "requires_dist": null, "requires_python": null, "summary": "Faster reimplementation of stdlib collections.namedtuple", "version": "1.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"cheap-namedtuple-implementation-python-2-7\">\n<h2>Cheap namedtuple implementation (Python 2.7)</h2>\n<p>Namedtuples are a neat goody of Python, but they have one big caveat. In\norder to be precise with the type definition, they compile with exec a\nstring template, formated with the variables given in the namedtuple()\nfunction factory. This compilation is very expensive computation-wise,\nand in practice can be spared if needed for performance reasons.</p>\n<p>An <a href=\"http://bugs.python.org/issue3974\" rel=\"nofollow\">issue</a> was opened years ago in\nthe Python bug tracker but it got rejected, arguing that the official\nimplementation is clearer and more maintainable. This is true, but there\nare cases where performance is key, and the current implementation using\nexec is just not an option.</p>\n<p>If you need to define new namedtuple types dynamically, and you have\nhigh performance constraints, this is for you.</p>\n<p>There are multiple versions out there, using\n<a href=\"https://gist.github.com/aliles/1160525\" rel=\"nofollow\">metaclasses</a>, or\n<a href=\"http://bugs.python.org/file11608/new_namedtuples.diff\" rel=\"nofollow\">metaclasses</a>,\nor\n<a href=\"http://code.activestate.com/recipes/577629-namedtupleabc-abstract-base-class-mix-in-for-named/\" rel=\"nofollow\">ABC</a></p>\n<p>This versions is simpler. Just define a new class closed-over by the\nfactory function.</p>\n<p>Unittests from cPython2.7 implementation are copied here to assert that\nthe same expected behaviour is honored.</p>\n<div id=\"install\">\n<h3>Install</h3>\n<pre>pip install cheapnamedtuple\n</pre>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<p>For the purist, the <tt>namedtuple</tt> implementation is 3.75x faster than\nPython\u2019s implementation, while honouring 100% of the Python\u2019s\nimplementation behaviour, including docstrings and everything else\n(corroborated by unit tests):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">cheapnamedtuple</span> <span class=\"kn\">import</span> <span class=\"n\">namedtuple</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Point</span> <span class=\"o\">=</span> <span class=\"n\">namedtuple</span><span class=\"p\">(</span><span class=\"s1\">'Point'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Point</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span>                   <span class=\"c1\"># docstring for the new class</span>\n<span class=\"s1\">'Point(x, y)'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">22</span><span class=\"p\">)</span>             <span class=\"c1\"># instantiate with positional args or keywords</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>                     <span class=\"c1\"># indexable like a plain tuple</span>\n<span class=\"mi\">33</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">p</span>                        <span class=\"c1\"># unpack like a regular tuple</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"p\">(</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"mi\">22</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">y</span>                       <span class=\"c1\"># fields also accessible by name</span>\n<span class=\"mi\">33</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">_asdict</span><span class=\"p\">()</span>                 <span class=\"c1\"># convert to a dictionary</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"s1\">'x'</span><span class=\"p\">]</span>\n<span class=\"mi\">11</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">d</span><span class=\"p\">)</span>                      <span class=\"c1\"># convert from a dictionary</span>\n<span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">22</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">_replace</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>               <span class=\"c1\"># _replace() is like str.replace() but targets named fields</span>\n<span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">22</span><span class=\"p\">)</span>\n</pre>\n<p>For the practical, a <tt>cheapnamedtuple</tt> implementation is 26.6x faster\nthan the Python\u2019s implementation, while still honouring all the public\nbehaviour (corroborated by doctests), and still supporting copy and\npickle. The only caveats identified so far are:</p>\n<ul>\n<li>The docstring of the type generated by the cheapnamedtuple factory\ncannot be generated ad-hoc for it</li>\n<li>Some typechecking has been trade in favor of performance (see\ntest_name_fixer test case)</li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">cheapnamedtuple</span> <span class=\"kn\">import</span> <span class=\"n\">cheapnamedtuple</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Point</span> <span class=\"o\">=</span> <span class=\"n\">cheapnamedtuple</span><span class=\"p\">(</span><span class=\"s1\">'Point'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Point</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span>                   <span class=\"c1\"># docstring for the new class</span>\n<span class=\"s1\">'Point(x, y)'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">22</span><span class=\"p\">)</span>             <span class=\"c1\"># instantiate with positional args or keywords</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>                     <span class=\"c1\"># indexable like a plain tuple</span>\n<span class=\"mi\">33</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">p</span>                        <span class=\"c1\"># unpack like a regular tuple</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span>\n<span class=\"p\">(</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"mi\">22</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">y</span>                       <span class=\"c1\"># fields also accessible by name</span>\n<span class=\"mi\">33</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">_asdict</span><span class=\"p\">()</span>                 <span class=\"c1\"># convert to a dictionary</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"s1\">'x'</span><span class=\"p\">]</span>\n<span class=\"mi\">11</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">d</span><span class=\"p\">)</span>                      <span class=\"c1\"># convert from a dictionary</span>\n<span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">22</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">_replace</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>               <span class=\"c1\"># _replace() is like str.replace() but targets named fields</span>\n<span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mi\">22</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"compatibility\">\n<h2>Compatibility</h2>\n<p>Currently only tested in Python 2.7</p>\n</div>\n<div id=\"benchmarking\">\n<h2>Benchmarking</h2>\n<p>Python\u2019s stdlib implementation:</p>\n<pre><span class=\"nv\">$python</span> -m timeit -vvvv <span class=\"s2\">\"from collections import namedtuple\"</span> <span class=\"s2\">\"A = namedtuple('A', ['foo', 'bar', 'foobar'])\"</span> <span class=\"s2\">\"a = A(1, 2, 3)\"</span> <span class=\"s2\">\"a.bar\"</span>\n<span class=\"m\">10</span> loops -&gt; <span class=\"m\">0</span>.00922394 secs\n<span class=\"m\">100</span> loops -&gt; <span class=\"m\">0</span>.0595999 secs\n<span class=\"m\">1000</span> loops -&gt; <span class=\"m\">0</span>.350676 secs\nraw times: <span class=\"m\">0</span>.328964 <span class=\"m\">0</span>.33169 <span class=\"m\">0</span>.327519\n<span class=\"m\">1000</span> loops, best of <span class=\"m\">3</span>: <span class=\"m\">327</span>.519 usec per loop\n</pre>\n<p><tt>namedtuple</tt> implementation:</p>\n<pre>$ python -m timeit -vvvv <span class=\"s2\">\"from cheapnamedtuple import namedtuple\"</span> <span class=\"s2\">\"A = namedtuple('A', ['foo', 'bar', 'foobar'])\"</span> <span class=\"s2\">\"a = A(1, 2, 3)\"</span> <span class=\"s2\">\"a.bar\"</span>\n<span class=\"m\">10</span> loops -&gt; <span class=\"m\">0</span>.00332594 secs\n<span class=\"m\">100</span> loops -&gt; <span class=\"m\">0</span>.01106 secs\n<span class=\"m\">1000</span> loops -&gt; <span class=\"m\">0</span>.09164 secs\n<span class=\"m\">10000</span> loops -&gt; <span class=\"m\">0</span>.955008 secs\nraw times: <span class=\"m\">0</span>.929455 <span class=\"m\">0</span>.872804 <span class=\"m\">0</span>.904877\n<span class=\"m\">10000</span> loops, best of <span class=\"m\">3</span>: <span class=\"m\">87</span>.2804 usec per loop\n</pre>\n<p><tt>cheapnamedtuple</tt> implementation:</p>\n<pre>$ python -m timeit -vvvv <span class=\"s2\">\"from cheapnamedtuple import cheapnamedtuple\"</span> <span class=\"s2\">\"A = cheapnamedtuple('A', ['foo', 'bar', 'foobar'])\"</span> <span class=\"s2\">\"a = A(1, 2, 3)\"</span> <span class=\"s2\">\"a.bar\"</span>\n<span class=\"m\">10</span> loops -&gt; <span class=\"m\">0</span>.00241184 secs\n<span class=\"m\">100</span> loops -&gt; <span class=\"m\">0</span>.00281 secs\n<span class=\"m\">1000</span> loops -&gt; <span class=\"m\">0</span>.0245481 secs\n<span class=\"m\">10000</span> loops -&gt; <span class=\"m\">0</span>.156194 secs\n<span class=\"m\">100000</span> loops -&gt; <span class=\"m\">1</span>.25612 secs\nraw times: <span class=\"m\">1</span>.23459 <span class=\"m\">1</span>.23159 <span class=\"m\">1</span>.23687\n<span class=\"m\">100000</span> loops, best of <span class=\"m\">3</span>: <span class=\"m\">12</span>.3159 usec per loop\n</pre>\n<p>Using metaclass version found\n<a href=\"https://gist.github.com/aliles/1160525\" rel=\"nofollow\">here</a>:</p>\n<pre>$ python -m timeit -vvvv <span class=\"s2\">\"from metanamedtuple import namedtuple\"</span> <span class=\"s2\">\"A = namedtuple('A', ['foo', 'bar', 'foobar'])\"</span> <span class=\"s2\">\"a = A(1, 2, 3)\"</span> <span class=\"s2\">\"a.bar\"</span>\n<span class=\"m\">10</span> loops -&gt; <span class=\"m\">0</span>.00334907 secs\n<span class=\"m\">100</span> loops -&gt; <span class=\"m\">0</span>.0108609 secs\n<span class=\"m\">1000</span> loops -&gt; <span class=\"m\">0</span>.088969 secs\n<span class=\"m\">10000</span> loops -&gt; <span class=\"m\">1</span>.25756 secs\nraw times: <span class=\"m\">1</span>.2868 <span class=\"m\">1</span>.24004 <span class=\"m\">1</span>.25383\n<span class=\"m\">10000</span> loops, best of <span class=\"m\">3</span>: <span class=\"m\">124</span>.004 usec per loop\n</pre>\n</div>\n\n          </div>"}, "last_serial": 2240670, "releases": {"1.1.2": [{"comment_text": "", "digests": {"md5": "db9051fa627bc31fac3885c6e537bdde", "sha256": "669f7b8ba56a3a01503fd36eaf8a923f2cc2d209b8ec9a7dadf9c7c2a97e21c9"}, "downloads": -1, "filename": "cheapnamedtuple-1.1.2.tar.gz", "has_sig": false, "md5_digest": "db9051fa627bc31fac3885c6e537bdde", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5854, "upload_time": "2016-07-24T10:56:39", "upload_time_iso_8601": "2016-07-24T10:56:39.253530Z", "url": "https://files.pythonhosted.org/packages/b5/7b/90a3658845ce21e25b02a45625983fc14017b1066a55140194e0a6ddff05/cheapnamedtuple-1.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "db9051fa627bc31fac3885c6e537bdde", "sha256": "669f7b8ba56a3a01503fd36eaf8a923f2cc2d209b8ec9a7dadf9c7c2a97e21c9"}, "downloads": -1, "filename": "cheapnamedtuple-1.1.2.tar.gz", "has_sig": false, "md5_digest": "db9051fa627bc31fac3885c6e537bdde", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5854, "upload_time": "2016-07-24T10:56:39", "upload_time_iso_8601": "2016-07-24T10:56:39.253530Z", "url": "https://files.pythonhosted.org/packages/b5/7b/90a3658845ce21e25b02a45625983fc14017b1066a55140194e0a6ddff05/cheapnamedtuple-1.1.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:34:21 2020"}