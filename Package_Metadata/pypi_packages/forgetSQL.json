{"info": {"author": "Stian Soiland-Reyes", "author_email": "stian@soiland-reyes.com", "bugtrack_url": null, "classifiers": ["Development Status :: 7 - Inactive"], "description": "================\nforgetSQL readme\n================\n\n:Author: Stian Soiland <stian@soiland.no>\n:WWW: http://forgetsql.sourceforge.net/\n:License: GNU Lesser General Public License (LGPL)\n          See the file COPYING for details.\n:Status: unfinished\n:Abstract:\n    forgetSQL is a Python module for accessing SQL databases by creating\n    classes that maps SQL tables to objects, normally one class pr. SQL\n    table. The idea is to forget everything about SQL and just worrying\n    about normal classes and objects.\n\n.. contents:: Contents\n\n\nInstallation\n============\n\nInstallation of the forgetSQL module is pretty straight\nforward:\n    \n    python setup.py install\n\nThis will install forgetSQL.py into site-packages/ of your \nPython distribution.\n\n\nDependencies\n------------\n\n* Python 2.2.1 (True/False, new style classes, classmethods, iterators)\n* Some database module (tested: MySQLdb, psycopg)\n\nIf using psycopg, mx.DateTime is needed to avoid a psycopg\nbug related to re-inserting dates. psycopg depends on mx.DateTime, so\nthat shouldn't be a problem.\n\n\nWhat is forgetSQL?\n==================\n\nWhy forgetSQL?\n--------------\n\nLet's start by showing an example using an imaginary database\n``mydatabase``:\n\nThis example is based on these SQL tables:\n\naccount\n~~~~~~~\n\n===========  =================  =======\naccountid    fullname           groupid\n===========  =================  =======\nstain        Stian Soiland      15\nmagnun       Magnus Nordseth    15\nstornes      Sverre Stornes     17\nmjaavatt     Erlend Mjaavatten  15\n===========  =================  =======\n\n\ngroup\n~~~~~\n\n=======  ====\ngroupid  name \n=======  ====\n15       unix \n17       tie\n=======  ====\n\nAnd should output something like::\n\n    Account details for Stian S\ufffdiland\n    Group unix (15)\n    Other members:\n    Magnus Nordseth\n    Erlend Mjaavatten\n\n\nIn regular SQL programming, this could be done something like this::\n\n    cursor = dbconn.cursor()\n    cursor.execute(\"SELECT fullname,groupid FROM account WHERE accountid=%s\", \n                   ('stain',))    \n    fullname,groupid = cursor.fetchone()\n    print \"Account details for\", fullname\n\n    cursor.execute(\"SELECT name FROM group WHERE groupid=%s\" % groupid)\n    (groupname,) = cursor.fetchone()\n    print \"Group %s (%s)\" % (groupid, name)\n\n    cursor.execute(\"\"\"SELECT fullname \n                      FROM account JOIN group USING (groupid)\n                      WHERE group.groupid=%s AND\n                            NOT account.accountid=%s\"\"\",\n                   (groupid, accountid))\n    print \"Other members:\"\n    for (membername,) in cursor.fetchall():\n        print membername\n\n\nNow, using forgetSQL::\n\n    from mydatabase import *\n    account = Account(\"stain\") # primary key\n    print \"Account details for\", account.fullname\n    group = account.group\n    print \"Group %s (%s)\" % (group.name, group.groupid)\n    print \"Other members: \"\n    \n    for member in group.getChildren(Account):\n        # find Account with group as foreign key\n        if member <> account:\n            print member.fullname\n\n\nNotice the difference in size and complexity of these two examples.\n\nThe first example is tightly bound against SQL. The programmer is forced\nto think about SQL instead of the real code. This programming style \ntends to move high-level details to SQL, even if it is not neccessary.\nIn this example, when getting \"other members\", the detail of skipping\nthe active user is done in SQL. \n\nThis would hardly save any CPU time on modern computers, but has made\nthe code more complex.  Thinking in SQL makes your program very large,\nas everything can be solved by some specialized SQL. Trying to change \nyour program or database structure at a later time would be a nightmare.\n\nNow, forgetSQL removes all those details for the every-day-SQL tasks. It\nwill not be hyper-effective or give you points in the\nlargest-join-ever-possible-contest, but it will help you focus on what\nyou should be thinking of, making your program work.\n\nIf you at a later point (when everything runs without failures)\ndiscovers that you need to optimize something with a mega-query in SQL,\nyou could just replace that code with regular SQL operations.\nOf course, if you've been using test-driven development (like in \nhttp://c2.com/cgi/wiki?ExtremeProgramming ) your tests will show if\nthe replaced code works.\n\nAnother alternative could be to use views and stored procedure, and\nlayer forgetSQL on top of those views and procedures. This has never\nbeen tested, though. =)\n\nWhat does forgetSQL do?\n-----------------------\n\nFor each table in your database, a class is created. Each instance\ncreated of these classes refer to a row in the given table. Each\ninstance have attributes that refer to the fields in the database. \nNote that the instance is not created until you access that particular\nrow.\n\nSo accessing a column of a row is simply accessing the attribute\n``row.column``.  Now, if this column is a reference to another table, a\nforeign key, instead of an identifier you will in ``row.column`` find an \ninstance from the other table, ie. from the other class.\n\nThis is what happens in the example above, ``group = account.group``\nretrieves this instance. Further attribute access within this instance\nis resolved from the matching row in the group table.\n\nIf you want to change some value, you could just change the attribute\nvalue. In the example, if you want to change my name, simply run\n``account.fullname = \"Knut Carlsen\"`` (my boss). \n\nYou can retrieve every row in some table that refers to the current\nobject. This is what happens in ``group.getChildren(Account)``, which will\nreturn a list of those Accounts that have a foreign key refering to\n``group``. \n\nIf you retrieve the objects several times, the constructor will return\nthe same object the second time (unless some timeout has expired). This\nmeans that changes done to the object is immediately visible to all\ninstances. This is to reflect normal behaviour in object oriented\nprogramming.  \n\n    >>> stain = Account(\"stain\")\n    >>> stain2 = Account(\"stain\")\n    >>> stain.fullname = \"Knut Carlsen\"\n    >>> print stain2.fullname\n    Knut Carlsen\n\n\nWhat does forgetSQL not do?\n---------------------------\n\nforgetSQL is not a way to store objects in a database. It is a way to\nuse databases as objects. You cannot store arbitrary objects in the\ndatabase unless you use pickling.\n\nforgetSQL does not help you with database design, although you might\nchoose a development style that uses regular classes and objects at\nfirst, and then design the database afterwards. You could then change\nyour classes to use forgetSQL for data retrieval and storage, and later\npossibly replace forgetSQL classes with even more advanced objects.\n\nforgetSQL does not remove the need of heavy duty SQL. In some\nsituations, SQL is simply the best solution. forgetSQL might involve\nmany SQL operations for something that could be done in a single\noperations with a large magic query. If something does not scale up\nwith forgetSQL, even if you refactored your code, you might try using\nSQL instead.  This example would use excessive time in a table with a\nmillion rows::\n\n    for row in table.getAll():\n        row.backedUp = True\n        row.save()\n\nThis would involve creating one million object instances (each row), one\nmillion SELECTs (to get the other values that needs to be saved), and\none million UPDATEs.  By using ``getAllIterator`` you could reduce this to\njust one million UPDATEs (one SELECT, reusing the same object), but\nstill it would be far much slower than ``UPDATE table SET\nbackedUp=true``.\n\nforgetSQL does not support commits/rollback. This might be implemented\nlater, but I'm still unsure of how to actually use this in programming.\nAny suggestions are welcome.\n\nKeeping in sync\n~~~~~~~~~~~~~~~\n\nforgetSQL does not ensure that objects in memory are in sync with what\nis stored in the database. The values in the object will be a snapshot\nof how the row were at the time you first tried to retrieve an\nattribute. If you change some value, and then save the object, the row\nis updated to your version, no matter what has happened in the database\nmeanwhile. An object does not timeout while in memory, it does not\nrefresh it's values unless you call ``_loadDB()`` manually, as\nautomatically updating could confuse programmers. However, a timeout\nvalue is set, and if exceeded, *new* objects retrieved from database\n(ie. ``Account(\"stain\")`` will be fresh.\n\nIt is not easy to make a general way to ensure objects are updated. For\ninstance, always checking it could be heavy. It could also confuse some\nprograms if an object suddenly changes some of it's attributes without\ntelling, this could fuck up any updates the program is attempting to do.\nOn the other hand, saving a changed object as forgetSQL is now, will\noverwrite *all* attributes, not just the changed ones.\n\n\nUsage\n=====\n\nforgetsql-generate\n------------------\n\nBefore you can use forgetSQL, you will need to generate a module\ncontaing the classes representing database tables. Luckily, forgetSQL\nships with a program that can do this for you by guessing.\n\nThe program is called ``forgetsql-generate`` and should be installed by\n``setup.py`` or the packaging system. You might need the devel-version\nof the forgetSQL package.\n\nCreate a file ``tables.txt``, with a list of database tables, one per\nline. (This is needed since there is no consistent way to query a\ndatabase about it's tables)\n\nThen generate the module representing your tables::\n\n    forgetsql-generate --dbmodule psycopg --username=johndoe\n                         --password=Jens1PuLe --database=genious\n                         --tables tables.txt --output Genious.py\n\nAlternative, you could pipe the table list to ``forgetsql-generate``\nand avoid ``--tables`` -- and likewise drop ``--output`` and capture stdout \nfrom forgetsql-generate.\n\nThe generated module is ready for use, except that you need should\nset database connecting details. One possible way is included in the\ngenerated code, commented out and without a password. \n\nIt is recommended to set connection details from the outside instead,\nsince the tables might be used by different parts of a system using\ndifferent database passwords, connection details could be in a\nconfiguration file, you need persistent database connections, etc. \n\nThe way to do this is to set Genious._Wrapper.cursor to a cursor\nmethod, and Genious._Wrapper._dbModule to the database module used::\n\n    import Genious\n    import psycopg\n    conn = psycopg.connect(user=\"blal\", pass=\"sdlksdlk\", database=\"blabla\")\n    Genious._Wrapper.cursor = conn.cursor()\n    Genious._Wrapper._dbModule = psycopg\n\nThis should be refactored to a more userfriendly interface. \n\n\nNormal use\n----------\n\nWe'll call a class that is a representation of a database table a\nforgetter, because it inherits forgetSQL.Forgetter.\nThis chapter will present normal usage of such forgetters by examples.\n\nGetting a row by giving primary key\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nExample::\n\n    account = Account(\"stain\")\n    print account.fullname\n\nIf the primary key is wrong (ie. the row does not exist) accessing\n``account.fullname`` will raise ``forgetSQL.NotFound``. The object is\nactually not loaded from the database until a attribute is read.\n(delayed loading) One problem with that is that ``forgetSQL.NotFound``\nwill not be raised until the attribute is read.\n\nTo test if the primary key is valid, force a load::\n\n    account = Account(\"stain\")\n    try:    \n        account.load()\n    except forgetSQL.NotFound():\n        print \"Cannot find stain\"\n        return\n\n\nGetting all rows in a table\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nExample::\n\n    allAccounts = Account.getAll()\n    for account in allAccounts:\n        print account.accountid, account.fullname\n\nNote that ``getAll`` is a class method, so it is available even before\ncreating some ``Account``. The returned list will be empty if nothing is\nfound.\n\nAlso note that if what you want to do is to iterate, using\n``getAllIterator()`` would work well. This avoids creating all objects\nat once.\n\nTo create a new row in a table\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nExample::\n\n    account = Account()\n    account.accountid = \"jennyme\" # primary key\n    account.fullname = \"Jenny Marie Ellingsaeter\"\n    account.save()\n\nIf you have forgotten to set some required fields, save() will fail. If\nyou don't set the primary key, forgetSQL will try to guess the sequence\nname (tablename_primarykey_seq) to retrieve a new one. This might or\nmight not work. For MySQL some other magic is involved, but it should\nwork.\n\n\nChange some attribute\n~~~~~~~~~~~~~~~~~~~~~\n\nExample::\n\n    account = Account(\"stain\")\n    account.fullname = \"Stian Stornes\" # got married to a beautiful man\n\nYou can choose wether you want to call ``save()`` or not. If you don't call\n``save()``, the object will be saved when the object reference disappaers\n(ie. del account, end of function, etc.) and collected by the garbage\ncollector. Note that this might be delayed, and that any errors \nwill be disgarded.\n\nIf you are unsure if you have used the correct datatype or want to\ncatch save-errors, use ``save()``::\n\n    group = Group(17)\n    group.accountid = 'itil' # a string won't work in a integer field\n    try:\n        group.save()\n    except Exception, e:\n        print \"Could not save group %s: %s\" % (group, e)\n\nThe exception raised will be database module specific, like\n``psycopg.ProgrammingError``, possible containing some useful information.\n\n``save()`` will return ``True`` if successful.\n\nUndoing an attribute change\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you changed an attribute, and you don't want to save the change to\nthe database (as this will happen when the garbage collector kicks in),\nyou have two choices:\n    \n* reset the instance to a blank state::\n\n     group.reset() \n\n  This sets everything to None, including the primary key. \n  If you have referenced the instance anywhere else, they \n  will now experience a blank instance. \n\n* reload from database::\n\n    group.load()\n\n  Note, ``load()`` will perform a new SELECT.  \n\nNote that you don't have to ``reset()`` if you haven't changed any\nattributes, the instance will only save if anything has changed. \n\n\nAccess foreign keys\n~~~~~~~~~~~~~~~~~~~\n\nExample::\n\n    account = Account(\"stain\")\n    print account.group.accountid\n    print account.group.name\n\nAn attribute which is a foreign key to some other table will be\nidentified by forgetsql-generate if it's name is something like \n``other_table_id``. If the generator could not identify foreign keys\ncorrectly, modify ``_userClasses`` in the generated  Forgetter\ndefinition. (See `Specializing the forgetters`_). \n\nTo access the real primary key, use account.group.accountid or\naccount.group._getID(). Note that the latter will return a tupple\n(in case the primary key contained several columns).o\n\nYou can set a foreign key attribute to a new object from the\nforeign class::\n\n    import random\n    allGroups = Group.getAll()\n    for account in Account.getAll():\n        # Set the group to one of the Group instances\n        # in allGroups\n        account.group = random.choice(allGroups)\n    del account\n    # Note that by reusing the account variable all of these\n    # will be saved by the garbage collector\n\nor to just the foreign primary key::\n\n    account.group = 18\n\nNote that this referencing magic makes JOIN unneccessary in many cases,\nbut be aware that due to lazy loading (attributes are not loaded from\ndatabase before they are accessed for the first time), in some cases\nthis might result in many SELECT-calls. There are ways to avoid this,\nsee `Wrapping SQL queries`_.\n\n\nFinding foreign keys\n~~~~~~~~~~~~~~~~~~~~\n\nYou might want to walk in reverse, finding all accounts that have a\ngiven group as a foreign key::\n\n    group = Group(15)\n    members = group.getChildren(Account)\n\nThis is equivalent to SQL::\n\n    SELECT * FROM account WHERE groupid=15\n\n\nDeleting an instance\n~~~~~~~~~~~~~~~~~~~~\n\nNote that although rows are represented as instances, they will not be\ndeleted from the database by dereferencing. Simply removing a name\nbinding only removes the representation. (and actually forces a \n``save()`` if anything has changed).\n\nTo remove a row from the database::\n    \n    account = Account(\"stornes\")\n    account.delete()\n    \n``delete()`` might fail if your database claims reference integrity but\ndoes not cascade delete::\n\n    group = Group(17)\n    group.delete()\n    \n\nAdvanced use\n------------\n\nWHERE-clasules\n~~~~~~~~~~~~~~\n\nYou may specify a where-sentence to be inserted into the SELECT-call of\n``getAll``-methods::\n\n    members = Account.getAll(where=\"groupid=17\")\n\nNote that you must take care of proper escaping on your own by using\nthis approach. Most database modules have some form of escape functions.\n\nIn many cases, what you want to do with WHERE is probably the\nsame as with ``getChildren()``::\n    \n    group = Group(17)\n    members = group.getChildren(Account)\n\nThis will be as effective as generating a WHERE-clasule, since\n``group.load()`` won't be run (no attributes accessed, only the primary\nkey).\n\nThe sentence is directly inserted, so you need to use the actual SQL\ncolumn names, not the attribute names. You can use AND and OR as you\nlike.\n\nIf you have several clauses to be AND-ed together, forgetSQL can do this\nfor you, as the where-parameter can be a list::\n\n    where = []\n    where.append(\"groupid=17\")\n    if something:\n        where.append(\"fullname like 'Stian%'\")\n    Account.getAll(where=where)\n\n\nSorting\n~~~~~~~\n\nIf you have specified ``_orderBy`` (see `Specializing the forgetters`_),\nthe results of ``getAll*`` and ``getChildren`` will be ordered by those\nattributes. \n\nIf you want to specify ordering manually, you can supply a keyword\nargument to getAll::\n    \n    all = Account.getAll(orderBy=\"fullname\")\n\nThe value of ``orderBy`` could be either a string (representing the\nobject attribute to be sorted) or a tupple of strings (order by A, then\nB, etc.). Note that you can only order by attributes defined in the\ngiven table.    \n    \nIf you want some other fancy sorting, sort the list after retrieval\nusing regular ``list.sort()``::\n\n    all = Account.getAll()\n    all.sort(lambda a,b:\n                cmp(a.split()[-1],\n                    b.split()[-1]))\n    # order by last name! :=)                \n\n\nMore getAll\n~~~~~~~~~~~\n\nThere are specialized ``getAll`` methods for different situations.\n\nIf you just want the IDs in a table::\n\n    >>> all = Account.getAllIDs()\n    ['stornes', 'stain', 'magnun', 'mjaavatt']\n\nThe regular ``getAll()`` actually runs ``getAllIDs()``, and returns a\nlist of instances based on those IDs. The real data is not loaded\nuntil attribute access. In some cases, this might be OK, for instance if\nyou want to call getChildren and really don't care about the attribute\nvalues.\n\nIf you are going to iterate through the list, a common case, use\ninstead::\n\n    for account in Account.getAllIterator():\n        print account.fullname    \n\nThis will return an iterator, not a list, returning ``Account`` objects.\nFor each iteration, a new instance is returned, with all fields\nloaded. Internally in the iterator, a buffer of results from SELECT * is\ncontained.\n\nIn Python, object creation is a bit expensive, so you might reuse the\nsame object for each iteration by creating it first and specifying it \nas the keyword argument ``useObject``::\n\n    for account in Account.getAllIterator(useObject=Account()):\n        print account.fullname\n\nNote that changes made to account in this case will be flushed unless\nyou manually call ``save()``. Do not pass this instance on, as it's content\nwill change for each iteration.\n\nFinally, ``getAllText()`` will use ``_shortView`` (See `Specializing\nthe forgetters`_) and return tupples of (id, text). This is useful for\na dropdown-list of selectors.\n\nSpecializing the forgetters\n---------------------------\n.. About specifying and correcting _sqlFields, etc.\n\nSorry, this section is currently unfinished.\n\nWrapping SQL queries\n--------------------\n.. About joins, views, functions.\n\nSorry, this section is currently unfinished.\n\n\nFramework suggestion\n--------------------\n.. My suggestions for how you should wrap up things nicely, \n.. How to deal with database connections and extensions.\n\nSorry, this section is currently unfinished.\n\n", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/stain/forgetSQL/releases/download/0.5.1/forgetSQL-0.5.1.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/stain/forgetSQL", "keywords": "", "license": "LGPL 2.1 or later", "maintainer": "", "maintainer_email": "", "name": "forgetSQL", "package_url": "https://pypi.org/project/forgetSQL/", "platform": "", "project_url": "https://pypi.org/project/forgetSQL/", "project_urls": {"Download": "https://github.com/stain/forgetSQL/releases/download/0.5.1/forgetSQL-0.5.1.tar.gz", "Homepage": "https://github.com/stain/forgetSQL"}, "release_url": "https://pypi.org/project/forgetSQL/0.5.1/", "requires_dist": null, "requires_python": null, "summary": "forgetSQL is a Python module for accessing SQL databases by creating", "version": "0.5.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <table>\n<col>\n<col>\n<tbody>\n<tr><th>Author:</th>\n<td>Stian Soiland &lt;<a href=\"mailto:stian%40soiland.no\">stian<span>@</span>soiland<span>.</span>no</a>&gt;</td></tr>\n<tr><th>WWW:</th><td><a href=\"http://forgetsql.sourceforge.net/\" rel=\"nofollow\">http://forgetsql.sourceforge.net/</a></td>\n</tr>\n<tr><th>License:</th><td>GNU Lesser General Public License (LGPL)\nSee the file COPYING for details.</td>\n</tr>\n<tr><th>Status:</th>\n<td>unfinished</td></tr>\n</tbody>\n</table>\n<div>\n<p>Abstract</p>\n<p>forgetSQL is a Python module for accessing SQL databases by creating\nclasses that maps SQL tables to objects, normally one class pr. SQL\ntable. The idea is to forget everything about SQL and just worrying\nabout normal classes and objects.</p>\n</div>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#installation\" id=\"id1\" rel=\"nofollow\">Installation</a><ul>\n<li><a href=\"#dependencies\" id=\"id2\" rel=\"nofollow\">Dependencies</a></li>\n</ul>\n</li>\n<li><a href=\"#what-is-forgetsql\" id=\"id3\" rel=\"nofollow\">What is forgetSQL?</a><ul>\n<li><a href=\"#why-forgetsql\" id=\"id4\" rel=\"nofollow\">Why forgetSQL?</a><ul>\n<li><a href=\"#account\" id=\"id5\" rel=\"nofollow\">account</a></li>\n<li><a href=\"#group\" id=\"id6\" rel=\"nofollow\">group</a></li>\n</ul>\n</li>\n<li><a href=\"#what-does-forgetsql-do\" id=\"id7\" rel=\"nofollow\">What does forgetSQL do?</a></li>\n<li><a href=\"#what-does-forgetsql-not-do\" id=\"id8\" rel=\"nofollow\">What does forgetSQL not do?</a><ul>\n<li><a href=\"#keeping-in-sync\" id=\"id9\" rel=\"nofollow\">Keeping in sync</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#usage\" id=\"id10\" rel=\"nofollow\">Usage</a><ul>\n<li><a href=\"#forgetsql-generate\" id=\"id11\" rel=\"nofollow\">forgetsql-generate</a></li>\n<li><a href=\"#normal-use\" id=\"id12\" rel=\"nofollow\">Normal use</a><ul>\n<li><a href=\"#getting-a-row-by-giving-primary-key\" id=\"id13\" rel=\"nofollow\">Getting a row by giving primary key</a></li>\n<li><a href=\"#getting-all-rows-in-a-table\" id=\"id14\" rel=\"nofollow\">Getting all rows in a table</a></li>\n<li><a href=\"#to-create-a-new-row-in-a-table\" id=\"id15\" rel=\"nofollow\">To create a new row in a table</a></li>\n<li><a href=\"#change-some-attribute\" id=\"id16\" rel=\"nofollow\">Change some attribute</a></li>\n<li><a href=\"#undoing-an-attribute-change\" id=\"id17\" rel=\"nofollow\">Undoing an attribute change</a></li>\n<li><a href=\"#access-foreign-keys\" id=\"id18\" rel=\"nofollow\">Access foreign keys</a></li>\n<li><a href=\"#finding-foreign-keys\" id=\"id19\" rel=\"nofollow\">Finding foreign keys</a></li>\n<li><a href=\"#deleting-an-instance\" id=\"id20\" rel=\"nofollow\">Deleting an instance</a></li>\n</ul>\n</li>\n<li><a href=\"#advanced-use\" id=\"id21\" rel=\"nofollow\">Advanced use</a><ul>\n<li><a href=\"#where-clasules\" id=\"id22\" rel=\"nofollow\">WHERE-clasules</a></li>\n<li><a href=\"#sorting\" id=\"id23\" rel=\"nofollow\">Sorting</a></li>\n<li><a href=\"#more-getall\" id=\"id24\" rel=\"nofollow\">More getAll</a></li>\n</ul>\n</li>\n<li><a href=\"#specializing-the-forgetters\" id=\"id25\" rel=\"nofollow\">Specializing the forgetters</a></li>\n<li><a href=\"#wrapping-sql-queries\" id=\"id26\" rel=\"nofollow\">Wrapping SQL queries</a></li>\n<li><a href=\"#framework-suggestion\" id=\"id27\" rel=\"nofollow\">Framework suggestion</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Installation</a></h2>\n<p>Installation of the forgetSQL module is pretty straight\nforward:</p>\n<blockquote>\npython setup.py install</blockquote>\n<p>This will install forgetSQL.py into site-packages/ of your\nPython distribution.</p>\n<div id=\"dependencies\">\n<h3><a href=\"#id2\" rel=\"nofollow\">Dependencies</a></h3>\n<ul>\n<li>Python 2.2.1 (True/False, new style classes, classmethods, iterators)</li>\n<li>Some database module (tested: MySQLdb, psycopg)</li>\n</ul>\n<p>If using psycopg, mx.DateTime is needed to avoid a psycopg\nbug related to re-inserting dates. psycopg depends on mx.DateTime, so\nthat shouldn\u2019t be a problem.</p>\n</div>\n</div>\n<div id=\"what-is-forgetsql\">\n<h2><a href=\"#id3\" rel=\"nofollow\">What is forgetSQL?</a></h2>\n<div id=\"why-forgetsql\">\n<h3><a href=\"#id4\" rel=\"nofollow\">Why forgetSQL?</a></h3>\n<p>Let\u2019s start by showing an example using an imaginary database\n<tt>mydatabase</tt>:</p>\n<p>This example is based on these SQL tables:</p>\n<div id=\"account\">\n<h4><a href=\"#id5\" rel=\"nofollow\">account</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>accountid</th>\n<th>fullname</th>\n<th>groupid</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>stain</td>\n<td>Stian Soiland</td>\n<td>15</td>\n</tr>\n<tr><td>magnun</td>\n<td>Magnus Nordseth</td>\n<td>15</td>\n</tr>\n<tr><td>stornes</td>\n<td>Sverre Stornes</td>\n<td>17</td>\n</tr>\n<tr><td>mjaavatt</td>\n<td>Erlend Mjaavatten</td>\n<td>15</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"group\">\n<h4><a href=\"#id6\" rel=\"nofollow\">group</a></h4>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>groupid</th>\n<th>name</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>15</td>\n<td>unix</td>\n</tr>\n<tr><td>17</td>\n<td>tie</td>\n</tr>\n</tbody>\n</table>\n<p>And should output something like:</p>\n<pre>Account details for Stian S\ufffdiland\nGroup unix (15)\nOther members:\nMagnus Nordseth\nErlend Mjaavatten\n</pre>\n<p>In regular SQL programming, this could be done something like this:</p>\n<pre>cursor = dbconn.cursor()\ncursor.execute(\"SELECT fullname,groupid FROM account WHERE accountid=%s\",\n               ('stain',))\nfullname,groupid = cursor.fetchone()\nprint \"Account details for\", fullname\n\ncursor.execute(\"SELECT name FROM group WHERE groupid=%s\" % groupid)\n(groupname,) = cursor.fetchone()\nprint \"Group %s (%s)\" % (groupid, name)\n\ncursor.execute(\"\"\"SELECT fullname\n                  FROM account JOIN group USING (groupid)\n                  WHERE group.groupid=%s AND\n                        NOT account.accountid=%s\"\"\",\n               (groupid, accountid))\nprint \"Other members:\"\nfor (membername,) in cursor.fetchall():\n    print membername\n</pre>\n<p>Now, using forgetSQL:</p>\n<pre>from mydatabase import *\naccount = Account(\"stain\") # primary key\nprint \"Account details for\", account.fullname\ngroup = account.group\nprint \"Group %s (%s)\" % (group.name, group.groupid)\nprint \"Other members: \"\n\nfor member in group.getChildren(Account):\n    # find Account with group as foreign key\n    if member &lt;&gt; account:\n        print member.fullname\n</pre>\n<p>Notice the difference in size and complexity of these two examples.</p>\n<p>The first example is tightly bound against SQL. The programmer is forced\nto think about SQL instead of the real code. This programming style\ntends to move high-level details to SQL, even if it is not neccessary.\nIn this example, when getting \u201cother members\u201d, the detail of skipping\nthe active user is done in SQL.</p>\n<p>This would hardly save any CPU time on modern computers, but has made\nthe code more complex.  Thinking in SQL makes your program very large,\nas everything can be solved by some specialized SQL. Trying to change\nyour program or database structure at a later time would be a nightmare.</p>\n<p>Now, forgetSQL removes all those details for the every-day-SQL tasks. It\nwill not be hyper-effective or give you points in the\nlargest-join-ever-possible-contest, but it will help you focus on what\nyou should be thinking of, making your program work.</p>\n<p>If you at a later point (when everything runs without failures)\ndiscovers that you need to optimize something with a mega-query in SQL,\nyou could just replace that code with regular SQL operations.\nOf course, if you\u2019ve been using test-driven development (like in\n<a href=\"http://c2.com/cgi/wiki?ExtremeProgramming\" rel=\"nofollow\">http://c2.com/cgi/wiki?ExtremeProgramming</a> ) your tests will show if\nthe replaced code works.</p>\n<p>Another alternative could be to use views and stored procedure, and\nlayer forgetSQL on top of those views and procedures. This has never\nbeen tested, though. =)</p>\n</div>\n</div>\n<div id=\"what-does-forgetsql-do\">\n<h3><a href=\"#id7\" rel=\"nofollow\">What does forgetSQL do?</a></h3>\n<p>For each table in your database, a class is created. Each instance\ncreated of these classes refer to a row in the given table. Each\ninstance have attributes that refer to the fields in the database.\nNote that the instance is not created until you access that particular\nrow.</p>\n<p>So accessing a column of a row is simply accessing the attribute\n<tt>row.column</tt>.  Now, if this column is a reference to another table, a\nforeign key, instead of an identifier you will in <tt>row.column</tt> find an\ninstance from the other table, ie. from the other class.</p>\n<p>This is what happens in the example above, <tt>group = account.group</tt>\nretrieves this instance. Further attribute access within this instance\nis resolved from the matching row in the group table.</p>\n<p>If you want to change some value, you could just change the attribute\nvalue. In the example, if you want to change my name, simply run\n<tt>account.fullname = \"Knut Carlsen\"</tt> (my boss).</p>\n<p>You can retrieve every row in some table that refers to the current\nobject. This is what happens in <tt>group.getChildren(Account)</tt>, which will\nreturn a list of those Accounts that have a foreign key refering to\n<tt>group</tt>.</p>\n<p>If you retrieve the objects several times, the constructor will return\nthe same object the second time (unless some timeout has expired). This\nmeans that changes done to the object is immediately visible to all\ninstances. This is to reflect normal behaviour in object oriented\nprogramming.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; stain = Account(\"stain\")\n&gt;&gt;&gt; stain2 = Account(\"stain\")\n&gt;&gt;&gt; stain.fullname = \"Knut Carlsen\"\n&gt;&gt;&gt; print stain2.fullname\nKnut Carlsen\n</pre>\n</blockquote>\n</div>\n<div id=\"what-does-forgetsql-not-do\">\n<h3><a href=\"#id8\" rel=\"nofollow\">What does forgetSQL not do?</a></h3>\n<p>forgetSQL is not a way to store objects in a database. It is a way to\nuse databases as objects. You cannot store arbitrary objects in the\ndatabase unless you use pickling.</p>\n<p>forgetSQL does not help you with database design, although you might\nchoose a development style that uses regular classes and objects at\nfirst, and then design the database afterwards. You could then change\nyour classes to use forgetSQL for data retrieval and storage, and later\npossibly replace forgetSQL classes with even more advanced objects.</p>\n<p>forgetSQL does not remove the need of heavy duty SQL. In some\nsituations, SQL is simply the best solution. forgetSQL might involve\nmany SQL operations for something that could be done in a single\noperations with a large magic query. If something does not scale up\nwith forgetSQL, even if you refactored your code, you might try using\nSQL instead.  This example would use excessive time in a table with a\nmillion rows:</p>\n<pre>for row in table.getAll():\n    row.backedUp = True\n    row.save()\n</pre>\n<p>This would involve creating one million object instances (each row), one\nmillion SELECTs (to get the other values that needs to be saved), and\none million UPDATEs.  By using <tt>getAllIterator</tt> you could reduce this to\njust one million UPDATEs (one SELECT, reusing the same object), but\nstill it would be far much slower than <tt>UPDATE table SET\nbackedUp=true</tt>.</p>\n<p>forgetSQL does not support commits/rollback. This might be implemented\nlater, but I\u2019m still unsure of how to actually use this in programming.\nAny suggestions are welcome.</p>\n<div id=\"keeping-in-sync\">\n<h4><a href=\"#id9\" rel=\"nofollow\">Keeping in sync</a></h4>\n<p>forgetSQL does not ensure that objects in memory are in sync with what\nis stored in the database. The values in the object will be a snapshot\nof how the row were at the time you first tried to retrieve an\nattribute. If you change some value, and then save the object, the row\nis updated to your version, no matter what has happened in the database\nmeanwhile. An object does not timeout while in memory, it does not\nrefresh it\u2019s values unless you call <tt>_loadDB()</tt> manually, as\nautomatically updating could confuse programmers. However, a timeout\nvalue is set, and if exceeded, <em>new</em> objects retrieved from database\n(ie. <tt><span class=\"pre\">Account(\"stain\")</span></tt> will be fresh.</p>\n<p>It is not easy to make a general way to ensure objects are updated. For\ninstance, always checking it could be heavy. It could also confuse some\nprograms if an object suddenly changes some of it\u2019s attributes without\ntelling, this could fuck up any updates the program is attempting to do.\nOn the other hand, saving a changed object as forgetSQL is now, will\noverwrite <em>all</em> attributes, not just the changed ones.</p>\n</div>\n</div>\n</div>\n<div id=\"usage\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Usage</a></h2>\n<div id=\"forgetsql-generate\">\n<h3><a href=\"#id11\" rel=\"nofollow\">forgetsql-generate</a></h3>\n<p>Before you can use forgetSQL, you will need to generate a module\ncontaing the classes representing database tables. Luckily, forgetSQL\nships with a program that can do this for you by guessing.</p>\n<p>The program is called <tt><span class=\"pre\">forgetsql-generate</span></tt> and should be installed by\n<tt>setup.py</tt> or the packaging system. You might need the devel-version\nof the forgetSQL package.</p>\n<p>Create a file <tt>tables.txt</tt>, with a list of database tables, one per\nline. (This is needed since there is no consistent way to query a\ndatabase about it\u2019s tables)</p>\n<p>Then generate the module representing your tables:</p>\n<pre>forgetsql-generate --dbmodule psycopg --username=johndoe\n                     --password=Jens1PuLe --database=genious\n                     --tables tables.txt --output Genious.py\n</pre>\n<p>Alternative, you could pipe the table list to <tt><span class=\"pre\">forgetsql-generate</span></tt>\nand avoid <tt><span class=\"pre\">--tables</span></tt> \u2013 and likewise drop <tt><span class=\"pre\">--output</span></tt> and capture stdout\nfrom forgetsql-generate.</p>\n<p>The generated module is ready for use, except that you need should\nset database connecting details. One possible way is included in the\ngenerated code, commented out and without a password.</p>\n<p>It is recommended to set connection details from the outside instead,\nsince the tables might be used by different parts of a system using\ndifferent database passwords, connection details could be in a\nconfiguration file, you need persistent database connections, etc.</p>\n<p>The way to do this is to set Genious._Wrapper.cursor to a cursor\nmethod, and Genious._Wrapper._dbModule to the database module used:</p>\n<pre>import Genious\nimport psycopg\nconn = psycopg.connect(user=\"blal\", pass=\"sdlksdlk\", database=\"blabla\")\nGenious._Wrapper.cursor = conn.cursor()\nGenious._Wrapper._dbModule = psycopg\n</pre>\n<p>This should be refactored to a more userfriendly interface.</p>\n</div>\n<div id=\"normal-use\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Normal use</a></h3>\n<p>We\u2019ll call a class that is a representation of a database table a\nforgetter, because it inherits forgetSQL.Forgetter.\nThis chapter will present normal usage of such forgetters by examples.</p>\n<div id=\"getting-a-row-by-giving-primary-key\">\n<h4><a href=\"#id13\" rel=\"nofollow\">Getting a row by giving primary key</a></h4>\n<p>Example:</p>\n<pre>account = Account(\"stain\")\nprint account.fullname\n</pre>\n<p>If the primary key is wrong (ie. the row does not exist) accessing\n<tt>account.fullname</tt> will raise <tt>forgetSQL.NotFound</tt>. The object is\nactually not loaded from the database until a attribute is read.\n(delayed loading) One problem with that is that <tt>forgetSQL.NotFound</tt>\nwill not be raised until the attribute is read.</p>\n<p>To test if the primary key is valid, force a load:</p>\n<pre>account = Account(\"stain\")\ntry:\n    account.load()\nexcept forgetSQL.NotFound():\n    print \"Cannot find stain\"\n    return\n</pre>\n</div>\n<div id=\"getting-all-rows-in-a-table\">\n<h4><a href=\"#id14\" rel=\"nofollow\">Getting all rows in a table</a></h4>\n<p>Example:</p>\n<pre>allAccounts = Account.getAll()\nfor account in allAccounts:\n    print account.accountid, account.fullname\n</pre>\n<p>Note that <tt>getAll</tt> is a class method, so it is available even before\ncreating some <tt>Account</tt>. The returned list will be empty if nothing is\nfound.</p>\n<p>Also note that if what you want to do is to iterate, using\n<tt>getAllIterator()</tt> would work well. This avoids creating all objects\nat once.</p>\n</div>\n<div id=\"to-create-a-new-row-in-a-table\">\n<h4><a href=\"#id15\" rel=\"nofollow\">To create a new row in a table</a></h4>\n<p>Example:</p>\n<pre>account = Account()\naccount.accountid = \"jennyme\" # primary key\naccount.fullname = \"Jenny Marie Ellingsaeter\"\naccount.save()\n</pre>\n<p>If you have forgotten to set some required fields, save() will fail. If\nyou don\u2019t set the primary key, forgetSQL will try to guess the sequence\nname (tablename_primarykey_seq) to retrieve a new one. This might or\nmight not work. For MySQL some other magic is involved, but it should\nwork.</p>\n</div>\n<div id=\"change-some-attribute\">\n<h4><a href=\"#id16\" rel=\"nofollow\">Change some attribute</a></h4>\n<p>Example:</p>\n<pre>account = Account(\"stain\")\naccount.fullname = \"Stian Stornes\" # got married to a beautiful man\n</pre>\n<p>You can choose wether you want to call <tt>save()</tt> or not. If you don\u2019t call\n<tt>save()</tt>, the object will be saved when the object reference disappaers\n(ie. del account, end of function, etc.) and collected by the garbage\ncollector. Note that this might be delayed, and that any errors\nwill be disgarded.</p>\n<p>If you are unsure if you have used the correct datatype or want to\ncatch save-errors, use <tt>save()</tt>:</p>\n<pre>group = Group(17)\ngroup.accountid = 'itil' # a string won't work in a integer field\ntry:\n    group.save()\nexcept Exception, e:\n    print \"Could not save group %s: %s\" % (group, e)\n</pre>\n<p>The exception raised will be database module specific, like\n<tt>psycopg.ProgrammingError</tt>, possible containing some useful information.</p>\n<p><tt>save()</tt> will return <tt>True</tt> if successful.</p>\n</div>\n<div id=\"undoing-an-attribute-change\">\n<h4><a href=\"#id17\" rel=\"nofollow\">Undoing an attribute change</a></h4>\n<p>If you changed an attribute, and you don\u2019t want to save the change to\nthe database (as this will happen when the garbage collector kicks in),\nyou have two choices:</p>\n<ul>\n<li><p>reset the instance to a blank state:</p>\n<pre>group.reset()\n</pre>\n<p>This sets everything to None, including the primary key.\nIf you have referenced the instance anywhere else, they\nwill now experience a blank instance.</p>\n</li>\n<li><p>reload from database:</p>\n<pre>group.load()\n</pre>\n<p>Note, <tt>load()</tt> will perform a new SELECT.</p>\n</li>\n</ul>\n<p>Note that you don\u2019t have to <tt>reset()</tt> if you haven\u2019t changed any\nattributes, the instance will only save if anything has changed.</p>\n</div>\n<div id=\"access-foreign-keys\">\n<h4><a href=\"#id18\" rel=\"nofollow\">Access foreign keys</a></h4>\n<p>Example:</p>\n<pre>account = Account(\"stain\")\nprint account.group.accountid\nprint account.group.name\n</pre>\n<p>An attribute which is a foreign key to some other table will be\nidentified by forgetsql-generate if it\u2019s name is something like\n<tt>other_table_id</tt>. If the generator could not identify foreign keys\ncorrectly, modify <tt>_userClasses</tt> in the generated  Forgetter\ndefinition. (See <a href=\"#specializing-the-forgetters\" rel=\"nofollow\">Specializing the forgetters</a>).</p>\n<p>To access the real primary key, use account.group.accountid or\naccount.group._getID(). Note that the latter will return a tupple\n(in case the primary key contained several columns).o</p>\n<p>You can set a foreign key attribute to a new object from the\nforeign class:</p>\n<pre>import random\nallGroups = Group.getAll()\nfor account in Account.getAll():\n    # Set the group to one of the Group instances\n    # in allGroups\n    account.group = random.choice(allGroups)\ndel account\n# Note that by reusing the account variable all of these\n# will be saved by the garbage collector\n</pre>\n<p>or to just the foreign primary key:</p>\n<pre>account.group = 18\n</pre>\n<p>Note that this referencing magic makes JOIN unneccessary in many cases,\nbut be aware that due to lazy loading (attributes are not loaded from\ndatabase before they are accessed for the first time), in some cases\nthis might result in many SELECT-calls. There are ways to avoid this,\nsee <a href=\"#wrapping-sql-queries\" rel=\"nofollow\">Wrapping SQL queries</a>.</p>\n</div>\n<div id=\"finding-foreign-keys\">\n<h4><a href=\"#id19\" rel=\"nofollow\">Finding foreign keys</a></h4>\n<p>You might want to walk in reverse, finding all accounts that have a\ngiven group as a foreign key:</p>\n<pre>group = Group(15)\nmembers = group.getChildren(Account)\n</pre>\n<p>This is equivalent to SQL:</p>\n<pre>SELECT * FROM account WHERE groupid=15\n</pre>\n</div>\n<div id=\"deleting-an-instance\">\n<h4><a href=\"#id20\" rel=\"nofollow\">Deleting an instance</a></h4>\n<p>Note that although rows are represented as instances, they will not be\ndeleted from the database by dereferencing. Simply removing a name\nbinding only removes the representation. (and actually forces a\n<tt>save()</tt> if anything has changed).</p>\n<p>To remove a row from the database:</p>\n<pre>account = Account(\"stornes\")\naccount.delete()\n</pre>\n<p><tt>delete()</tt> might fail if your database claims reference integrity but\ndoes not cascade delete:</p>\n<pre>group = Group(17)\ngroup.delete()\n</pre>\n</div>\n</div>\n<div id=\"advanced-use\">\n<h3><a href=\"#id21\" rel=\"nofollow\">Advanced use</a></h3>\n<div id=\"where-clasules\">\n<h4><a href=\"#id22\" rel=\"nofollow\">WHERE-clasules</a></h4>\n<p>You may specify a where-sentence to be inserted into the SELECT-call of\n<tt>getAll</tt>-methods:</p>\n<pre>members = Account.getAll(where=\"groupid=17\")\n</pre>\n<p>Note that you must take care of proper escaping on your own by using\nthis approach. Most database modules have some form of escape functions.</p>\n<p>In many cases, what you want to do with WHERE is probably the\nsame as with <tt>getChildren()</tt>:</p>\n<pre>group = Group(17)\nmembers = group.getChildren(Account)\n</pre>\n<p>This will be as effective as generating a WHERE-clasule, since\n<tt>group.load()</tt> won\u2019t be run (no attributes accessed, only the primary\nkey).</p>\n<p>The sentence is directly inserted, so you need to use the actual SQL\ncolumn names, not the attribute names. You can use AND and OR as you\nlike.</p>\n<p>If you have several clauses to be AND-ed together, forgetSQL can do this\nfor you, as the where-parameter can be a list:</p>\n<pre>where = []\nwhere.append(\"groupid=17\")\nif something:\n    where.append(\"fullname like 'Stian%'\")\nAccount.getAll(where=where)\n</pre>\n</div>\n<div id=\"sorting\">\n<h4><a href=\"#id23\" rel=\"nofollow\">Sorting</a></h4>\n<p>If you have specified <tt>_orderBy</tt> (see <a href=\"#specializing-the-forgetters\" rel=\"nofollow\">Specializing the forgetters</a>),\nthe results of <tt>getAll*</tt> and <tt>getChildren</tt> will be ordered by those\nattributes.</p>\n<p>If you want to specify ordering manually, you can supply a keyword\nargument to getAll:</p>\n<pre>all = Account.getAll(orderBy=\"fullname\")\n</pre>\n<p>The value of <tt>orderBy</tt> could be either a string (representing the\nobject attribute to be sorted) or a tupple of strings (order by A, then\nB, etc.). Note that you can only order by attributes defined in the\ngiven table.</p>\n<p>If you want some other fancy sorting, sort the list after retrieval\nusing regular <tt>list.sort()</tt>:</p>\n<pre>all = Account.getAll()\nall.sort(lambda a,b:\n            cmp(a.split()[-1],\n                b.split()[-1]))\n# order by last name! :=)\n</pre>\n</div>\n<div id=\"more-getall\">\n<h4><a href=\"#id24\" rel=\"nofollow\">More getAll</a></h4>\n<p>There are specialized <tt>getAll</tt> methods for different situations.</p>\n<p>If you just want the IDs in a table:</p>\n<pre>&gt;&gt;&gt; all = Account.getAllIDs()\n['stornes', 'stain', 'magnun', 'mjaavatt']\n</pre>\n<p>The regular <tt>getAll()</tt> actually runs <tt>getAllIDs()</tt>, and returns a\nlist of instances based on those IDs. The real data is not loaded\nuntil attribute access. In some cases, this might be OK, for instance if\nyou want to call getChildren and really don\u2019t care about the attribute\nvalues.</p>\n<p>If you are going to iterate through the list, a common case, use\ninstead:</p>\n<pre>for account in Account.getAllIterator():\n    print account.fullname\n</pre>\n<p>This will return an iterator, not a list, returning <tt>Account</tt> objects.\nFor each iteration, a new instance is returned, with all fields\nloaded. Internally in the iterator, a buffer of results from SELECT * is\ncontained.</p>\n<p>In Python, object creation is a bit expensive, so you might reuse the\nsame object for each iteration by creating it first and specifying it\nas the keyword argument <tt>useObject</tt>:</p>\n<pre>for account in Account.getAllIterator(useObject=Account()):\n    print account.fullname\n</pre>\n<p>Note that changes made to account in this case will be flushed unless\nyou manually call <tt>save()</tt>. Do not pass this instance on, as it\u2019s content\nwill change for each iteration.</p>\n<p>Finally, <tt>getAllText()</tt> will use <tt>_shortView</tt> (See <a href=\"#specializing-the-forgetters\" rel=\"nofollow\">Specializing\nthe forgetters</a>) and return tupples of (id, text). This is useful for\na dropdown-list of selectors.</p>\n</div>\n</div>\n<div id=\"specializing-the-forgetters\">\n<h3><a href=\"#id25\" rel=\"nofollow\">Specializing the forgetters</a></h3>\n<p>Sorry, this section is currently unfinished.</p>\n</div>\n<div id=\"wrapping-sql-queries\">\n<h3><a href=\"#id26\" rel=\"nofollow\">Wrapping SQL queries</a></h3>\n<p>Sorry, this section is currently unfinished.</p>\n</div>\n<div id=\"framework-suggestion\">\n<h3><a href=\"#id27\" rel=\"nofollow\">Framework suggestion</a></h3>\n<p>Sorry, this section is currently unfinished.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1837485, "releases": {"0.5.1": [{"comment_text": "", "digests": {"md5": "ea780a55e89f53da1185a336f04f1401", "sha256": "73bba937b8e2278d2e85df73b8bec66f5375ae8883d926755445827cae409e57"}, "downloads": -1, "filename": "forgetSQL-0.5.1.tar.gz", "has_sig": true, "md5_digest": "ea780a55e89f53da1185a336f04f1401", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29546, "upload_time": "2015-11-28T16:28:26", "upload_time_iso_8601": "2015-11-28T16:28:26.689893Z", "url": "https://files.pythonhosted.org/packages/2f/08/8fad5c8e2d8ae0460abc9a8d52a8e792f7b39894c03d97de1431ae707c40/forgetSQL-0.5.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ea780a55e89f53da1185a336f04f1401", "sha256": "73bba937b8e2278d2e85df73b8bec66f5375ae8883d926755445827cae409e57"}, "downloads": -1, "filename": "forgetSQL-0.5.1.tar.gz", "has_sig": true, "md5_digest": "ea780a55e89f53da1185a336f04f1401", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29546, "upload_time": "2015-11-28T16:28:26", "upload_time_iso_8601": "2015-11-28T16:28:26.689893Z", "url": "https://files.pythonhosted.org/packages/2f/08/8fad5c8e2d8ae0460abc9a8d52a8e792f7b39894c03d97de1431ae707c40/forgetSQL-0.5.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:00:52 2020"}