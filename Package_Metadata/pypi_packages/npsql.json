{"info": {"author": "Stephen Boesch", "author_email": "javadba@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "About Nptab\n============\n\nLightweight, intuitive and fast data-tables.\n\n*Nptab* data-tables are tables with columns and column names, rows and row\nnumbers. Indexing and slicing your data is analogous to numpy array's. The\nonly real difference is that each column can have its own data type.\n\n\nDesign objectives\n-----------------\n\nI got frustrated with pandas: it's complicated slicing syntax (.loc, .x,\n.iloc, .. etc), it's enforced index column and the Series objects I get when I\nwant a numpy array. With Nptab I created the simplified pandas I need for many\nof my data-jobs. Just focussing on simple slicing of multi-datatype tables and\nbasic table tools.\n\n* Intuitive simple slicing.\n\n* Using numpy machinery, for best performance, integration with other tools\n  and future support.\n\n* Store data by column numpy arrays (column store).\n\n* No particular index column, all columns can be used as the index, the choice\n  is up to the user.\n\n* Fundamental necessities for sorting, grouping, joining and appending tables.\n\n\nInstall\n========\n\npip install npsql\n\nQuickstart\n===========\n\ninit\n----\n\nTo setup a Nptab:\n\n>>> from npsql import Nptab\n>>> npsql = Nptab([ [\"John\", \"Joe\", \"Jane\"],\n...                [1.82,1.65,2.15],\n...                [False,False,True]], columns = [\"Name\", \"Height\", \"Married\"])\n>>> npsql\n Name   |   Height |   Married\n--------+----------+-----------\n John   |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n3 rows ['<U4', '<f8', '|b1']\n\nAlternatively, Tabls can be setup from dictionaries, numpy arrays, pandas\nDataFrames, or no data at all. Database connectors usually return data as a list\nof records, the module provides a convenience function to transpose this into a\nlist of columns.\n\nslice\n-----\n\nSlicing can be done the numpy way, always returning Nptab objects:\n\n>>> npsql[1:3,[0,2]]\n Name   |   Married\n--------+-----------\n Joe    |         0\n Jane   |         1\n2 rows ['<U4', '|b1']\n\nSlices will always return a Nptab except in three distinct cases, when:\n\n1. explicitly one column is requested, a numpy array is returned:\n\n>>> npsql[1:3,'Name']       # doctest: +SKIP\narray(['Joe', 'Jane'],\n      dtype='<U4')\n\n2. explicitly one row is requested, a tuple is returned:\n\n>>> npsql[0,:]\n('John', 1.82, False)\n\n3. explicitly one element is requested:\n\n>>> npsql[0,'Name']\n'John'\n\nIn general, slicing is intuitive and does not deviate from what would expect\nfrom numpy. With the one addition that columns can be referred to by names as\nwell as numbers.\n\nset\n----\n\nSetting elements works the same as slicing:\n\n>>> npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n>>> npsql[0,\"Name\"] = \"Jos\"\n>>> npsql\n Name   |   Height |   Married\n--------+----------+-----------\n Jos    |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n3 rows ['<U4', '<f8', '|b1']\n\nThe datatype that the value is expected to have, is the same as the datatype a\nslice would result into.\n\nAdding columns, works the same as setting elements, just give it a new name:\n\n>>> npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n>>> npsql['new'] = [1,2,3]\n>>> npsql\n Name   |   Height |   Married |   new\n--------+----------+-----------+-------\n John   |     1.82 |         0 |     1\n Joe    |     1.65 |         0 |     2\n Jane   |     2.15 |         1 |     3\n3 rows ['<U4', '<f8', '|b1', '<i8']\n\nOr set the whole column to the same value:\n\n>>> npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n>>> npsql['new'] = 13\n>>> npsql\n Name   |   Height |   Married |   new\n--------+----------+-----------+-------\n John   |     1.82 |         0 |    13\n Joe    |     1.65 |         0 |    13\n Jane   |     2.15 |         1 |    13\n3 rows ['<U4', '<f8', '|b1', '<i8']\n\nJust like numpy, slices are not actual copies of the data, rather they are\nreferences.\n\nappend Nptab and row\n---------------------\n\nTabls can be appended with other Tabls:\n\n>>> npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n>>> npsql += npsql\n>>> npsql\n Name   |   Height |   Married\n--------+----------+-----------\n John   |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n John   |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n6 rows ['<U4', '<f8', '|b1']\n\nOr append rows as dictionary:\n\n>>> npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n>>> npsql.row_append({'Height':1.81, 'Name':\"Jack\", 'Married':True})\n>>> npsql\n Name   |   Height |   Married\n--------+----------+-----------\n John   |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n Jack   |     1.81 |         1\n4 rows ['<U4', '<f8', '|b1']\n\n\ninstance properties\n--------------------\n\nYour data is simply stored as a list of numpy arrays and can be accessed or\nmanipulated like that (just don't make a mess):\n\n>>> npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n>>> npsql.columns\n['Name', 'Height', 'Married']\n>>> npsql.data        # doctest: +SKIP\n[array(['John', 'Joe', 'Jane'],\n      dtype='<U4'), array([ 1.82,  1.65,  2.15]), array([False, False,  True], dtype=bool)]\n\nFurther the basic means to asses the size of your data:\n\n>>> npsql.shape\n(3, 3)\n>>> len(npsql)\n3\n\npandas\n-------\n\nFor for interfacing with the popular datatable framework, going back and forth\nis easy:\n\n>>> import pandas as pd\n>>> df = pd.DataFrame({'a':range(3),'b':range(10,13)})\n>>> df\n   a   b\n0  0  10\n1  1  11\n2  2  12\n\nTo make a Nptab from a DataFrame, just supply it to the initialize:\n\n>>> npsql = Nptab(df)\n>>> npsql\n   a |   b\n-----+-----\n   0 |  10\n   1 |  11\n   2 |  12\n3 rows ['<i8', '<i8']\n\nThe dict property of Nptab provides a way to make a DataFrame from a Nptab:\n\n>>> df = pd.DataFrame(npsql.dict)\n>>> df\n   a   b\n0  0  10\n1  1  11\n2  2  12\n\n\nDependencies\n============\n\n* numpy\n* tabulate (optional, recommended)\n* pandas (optional, for converting back and forth to DataFrames)\n\nTested on:\n----------\n\n* Python 3.8.2;  numpy 1.18.1\n\n\nContributing to Nptab\n=====================\nNptab is perfect already, no more contributions needed. Just kidding!\n\nSee the repository for filing issues and proposing enhancements.\n\n - pytest ::\n\n    cd npsql/test\n    conda activate py38\n    pytest\n\n - pylint ::\n\n    cd npsql/\n    ./pylint.sh\n\n - doctest ::\n\n    cd npsql/docs\n    make doctest\n\n - sphynx ::\n\n    cd npsql/docs\n    make html\n\n - setuptools/pypi ::\n\n    python setup.py sdist bdist_wheel\n    twine upload dist/npsql-*\n\nContributors\n============\n\n* Stephen Boesch [javadba@gmail.com]\n* For the original `tabel` logic: Bastiaan Bergman [Bastiaan.Bergman@gmail.com].", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/javadba/npsql", "keywords": "numpy sql table", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "npsql", "package_url": "https://pypi.org/project/npsql/", "platform": "", "project_url": "https://pypi.org/project/npsql/", "project_urls": {"Homepage": "https://github.com/javadba/npsql", "Source Code": "https://github.com/javadba/npsql"}, "release_url": "https://pypi.org/project/npsql/0.1.0/", "requires_dist": null, "requires_python": ">=3.7", "summary": "SQL atop numpy arrays represented as tables. Tables logic forked from github.com/BastiaanBergman/npsql", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"about-nptab\">\n<h2>About Nptab</h2>\n<p>Lightweight, intuitive and fast data-tables.</p>\n<p><em>Nptab</em> data-tables are tables with columns and column names, rows and row\nnumbers. Indexing and slicing your data is analogous to numpy array\u2019s. The\nonly real difference is that each column can have its own data type.</p>\n<div id=\"design-objectives\">\n<h3>Design objectives</h3>\n<p>I got frustrated with pandas: it\u2019s complicated slicing syntax (.loc, .x,\n.iloc, .. etc), it\u2019s enforced index column and the Series objects I get when I\nwant a numpy array. With Nptab I created the simplified pandas I need for many\nof my data-jobs. Just focussing on simple slicing of multi-datatype tables and\nbasic table tools.</p>\n<ul>\n<li>Intuitive simple slicing.</li>\n<li>Using numpy machinery, for best performance, integration with other tools\nand future support.</li>\n<li>Store data by column numpy arrays (column store).</li>\n<li>No particular index column, all columns can be used as the index, the choice\nis up to the user.</li>\n<li>Fundamental necessities for sorting, grouping, joining and appending tables.</li>\n</ul>\n</div>\n</div>\n<div id=\"install\">\n<h2>Install</h2>\n<p>pip install npsql</p>\n</div>\n<div id=\"quickstart\">\n<h2>Quickstart</h2>\n<div id=\"init\">\n<h3>init</h3>\n<p>To setup a Nptab:</p>\n<pre>&gt;&gt;&gt; from npsql import Nptab\n&gt;&gt;&gt; npsql = Nptab([ [\"John\", \"Joe\", \"Jane\"],\n...                [1.82,1.65,2.15],\n...                [False,False,True]], columns = [\"Name\", \"Height\", \"Married\"])\n&gt;&gt;&gt; npsql\n Name   |   Height |   Married\n--------+----------+-----------\n John   |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n3 rows ['&lt;U4', '&lt;f8', '|b1']\n</pre>\n<p>Alternatively, Tabls can be setup from dictionaries, numpy arrays, pandas\nDataFrames, or no data at all. Database connectors usually return data as a list\nof records, the module provides a convenience function to transpose this into a\nlist of columns.</p>\n</div>\n<div id=\"slice\">\n<h3>slice</h3>\n<p>Slicing can be done the numpy way, always returning Nptab objects:</p>\n<pre>&gt;&gt;&gt; npsql[1:3,[0,2]]\n Name   |   Married\n--------+-----------\n Joe    |         0\n Jane   |         1\n2 rows ['&lt;U4', '|b1']\n</pre>\n<p>Slices will always return a Nptab except in three distinct cases, when:</p>\n<ol>\n<li>explicitly one column is requested, a numpy array is returned:</li>\n</ol>\n<pre>&gt;&gt;&gt; npsql[1:3,'Name']       # doctest: +SKIP\narray(['Joe', 'Jane'],\n      dtype='&lt;U4')\n</pre>\n<ol>\n<li>explicitly one row is requested, a tuple is returned:</li>\n</ol>\n<pre>&gt;&gt;&gt; npsql[0,:]\n('John', 1.82, False)\n</pre>\n<ol>\n<li>explicitly one element is requested:</li>\n</ol>\n<pre>&gt;&gt;&gt; npsql[0,'Name']\n'John'\n</pre>\n<p>In general, slicing is intuitive and does not deviate from what would expect\nfrom numpy. With the one addition that columns can be referred to by names as\nwell as numbers.</p>\n</div>\n<div id=\"set\">\n<h3>set</h3>\n<p>Setting elements works the same as slicing:</p>\n<pre>&gt;&gt;&gt; npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n&gt;&gt;&gt; npsql[0,\"Name\"] = \"Jos\"\n&gt;&gt;&gt; npsql\n Name   |   Height |   Married\n--------+----------+-----------\n Jos    |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n3 rows ['&lt;U4', '&lt;f8', '|b1']\n</pre>\n<p>The datatype that the value is expected to have, is the same as the datatype a\nslice would result into.</p>\n<p>Adding columns, works the same as setting elements, just give it a new name:</p>\n<pre>&gt;&gt;&gt; npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n&gt;&gt;&gt; npsql['new'] = [1,2,3]\n&gt;&gt;&gt; npsql\n Name   |   Height |   Married |   new\n--------+----------+-----------+-------\n John   |     1.82 |         0 |     1\n Joe    |     1.65 |         0 |     2\n Jane   |     2.15 |         1 |     3\n3 rows ['&lt;U4', '&lt;f8', '|b1', '&lt;i8']\n</pre>\n<p>Or set the whole column to the same value:</p>\n<pre>&gt;&gt;&gt; npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n&gt;&gt;&gt; npsql['new'] = 13\n&gt;&gt;&gt; npsql\n Name   |   Height |   Married |   new\n--------+----------+-----------+-------\n John   |     1.82 |         0 |    13\n Joe    |     1.65 |         0 |    13\n Jane   |     2.15 |         1 |    13\n3 rows ['&lt;U4', '&lt;f8', '|b1', '&lt;i8']\n</pre>\n<p>Just like numpy, slices are not actual copies of the data, rather they are\nreferences.</p>\n</div>\n<div id=\"append-nptab-and-row\">\n<h3>append Nptab and row</h3>\n<p>Tabls can be appended with other Tabls:</p>\n<pre>&gt;&gt;&gt; npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n&gt;&gt;&gt; npsql += npsql\n&gt;&gt;&gt; npsql\n Name   |   Height |   Married\n--------+----------+-----------\n John   |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n John   |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n6 rows ['&lt;U4', '&lt;f8', '|b1']\n</pre>\n<p>Or append rows as dictionary:</p>\n<pre>&gt;&gt;&gt; npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n&gt;&gt;&gt; npsql.row_append({'Height':1.81, 'Name':\"Jack\", 'Married':True})\n&gt;&gt;&gt; npsql\n Name   |   Height |   Married\n--------+----------+-----------\n John   |     1.82 |         0\n Joe    |     1.65 |         0\n Jane   |     2.15 |         1\n Jack   |     1.81 |         1\n4 rows ['&lt;U4', '&lt;f8', '|b1']\n</pre>\n</div>\n<div id=\"instance-properties\">\n<h3>instance properties</h3>\n<p>Your data is simply stored as a list of numpy arrays and can be accessed or\nmanipulated like that (just don\u2019t make a mess):</p>\n<pre>&gt;&gt;&gt; npsql = Nptab({'Name' : [\"John\", \"Joe\", \"Jane\"], 'Height' : [1.82,1.65,2.15], 'Married': [False,False,True]})\n&gt;&gt;&gt; npsql.columns\n['Name', 'Height', 'Married']\n&gt;&gt;&gt; npsql.data        # doctest: +SKIP\n[array(['John', 'Joe', 'Jane'],\n      dtype='&lt;U4'), array([ 1.82,  1.65,  2.15]), array([False, False,  True], dtype=bool)]\n</pre>\n<p>Further the basic means to asses the size of your data:</p>\n<pre>&gt;&gt;&gt; npsql.shape\n(3, 3)\n&gt;&gt;&gt; len(npsql)\n3\n</pre>\n</div>\n<div id=\"pandas\">\n<h3>pandas</h3>\n<p>For for interfacing with the popular datatable framework, going back and forth\nis easy:</p>\n<pre>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; df = pd.DataFrame({'a':range(3),'b':range(10,13)})\n&gt;&gt;&gt; df\n   a   b\n0  0  10\n1  1  11\n2  2  12\n</pre>\n<p>To make a Nptab from a DataFrame, just supply it to the initialize:</p>\n<pre>&gt;&gt;&gt; npsql = Nptab(df)\n&gt;&gt;&gt; npsql\n   a |   b\n-----+-----\n   0 |  10\n   1 |  11\n   2 |  12\n3 rows ['&lt;i8', '&lt;i8']\n</pre>\n<p>The dict property of Nptab provides a way to make a DataFrame from a Nptab:</p>\n<pre>&gt;&gt;&gt; df = pd.DataFrame(npsql.dict)\n&gt;&gt;&gt; df\n   a   b\n0  0  10\n1  1  11\n2  2  12\n</pre>\n</div>\n</div>\n<div id=\"dependencies\">\n<h2>Dependencies</h2>\n<ul>\n<li>numpy</li>\n<li>tabulate (optional, recommended)</li>\n<li>pandas (optional, for converting back and forth to DataFrames)</li>\n</ul>\n<div id=\"tested-on\">\n<h3>Tested on:</h3>\n<ul>\n<li>Python 3.8.2;  numpy 1.18.1</li>\n</ul>\n</div>\n</div>\n<div id=\"contributing-to-nptab\">\n<h2>Contributing to Nptab</h2>\n<p>Nptab is perfect already, no more contributions needed. Just kidding!</p>\n<p>See the repository for filing issues and proposing enhancements.</p>\n<blockquote>\n<ul>\n<li><p>pytest</p>\n<pre>cd npsql/test\nconda activate py38\npytest\n</pre>\n</li>\n<li><p>pylint</p>\n<pre>cd npsql/\n./pylint.sh\n</pre>\n</li>\n<li><p>doctest</p>\n<pre>cd npsql/docs\nmake doctest\n</pre>\n</li>\n<li><p>sphynx</p>\n<pre>cd npsql/docs\nmake html\n</pre>\n</li>\n<li><p>setuptools/pypi</p>\n<pre>python setup.py sdist bdist_wheel\ntwine upload dist/npsql-*\n</pre>\n</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"contributors\">\n<h2>Contributors</h2>\n<ul>\n<li>Stephen Boesch [<a href=\"mailto:javadba%40gmail.com\">javadba<span>@</span>gmail<span>.</span>com</a>]</li>\n<li>For the original <cite>tabel</cite> logic: Bastiaan Bergman [<a href=\"mailto:Bastiaan.Bergman%40gmail.com\">Bastiaan<span>.</span>Bergman<span>@</span>gmail<span>.</span>com</a>].</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 6809347, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "fbc32e0caf9370d2daa24795c82ca8ad", "sha256": "158303ad95c7e8a131a2b25806fb4e1603cda171a8968224b6bce5a993fa8d8b"}, "downloads": -1, "filename": "npsql-0.1.0-py3.8.egg", "has_sig": false, "md5_digest": "fbc32e0caf9370d2daa24795c82ca8ad", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.7", "size": 35007, "upload_time": "2020-03-13T21:47:01", "upload_time_iso_8601": "2020-03-13T21:47:01.200276Z", "url": "https://files.pythonhosted.org/packages/5e/66/ed1c6b23be6a863c1da5c0ba86822efb3c45e56d5d3d2d81b4f292240c52/npsql-0.1.0-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "d9c582c03e3c650145cac1caffba7028", "sha256": "92338dbc62b447913f6c33b6198d42df574744a010a60e26728a1ba4de82cf92"}, "downloads": -1, "filename": "npsql-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d9c582c03e3c650145cac1caffba7028", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 17573, "upload_time": "2020-03-13T23:17:41", "upload_time_iso_8601": "2020-03-13T23:17:41.455656Z", "url": "https://files.pythonhosted.org/packages/22/72/01a0376cc8972c5a4138ee584d3099b1623b826b5fa65d9c739bb70f1621/npsql-0.1.0-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fbc32e0caf9370d2daa24795c82ca8ad", "sha256": "158303ad95c7e8a131a2b25806fb4e1603cda171a8968224b6bce5a993fa8d8b"}, "downloads": -1, "filename": "npsql-0.1.0-py3.8.egg", "has_sig": false, "md5_digest": "fbc32e0caf9370d2daa24795c82ca8ad", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.7", "size": 35007, "upload_time": "2020-03-13T21:47:01", "upload_time_iso_8601": "2020-03-13T21:47:01.200276Z", "url": "https://files.pythonhosted.org/packages/5e/66/ed1c6b23be6a863c1da5c0ba86822efb3c45e56d5d3d2d81b4f292240c52/npsql-0.1.0-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "d9c582c03e3c650145cac1caffba7028", "sha256": "92338dbc62b447913f6c33b6198d42df574744a010a60e26728a1ba4de82cf92"}, "downloads": -1, "filename": "npsql-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d9c582c03e3c650145cac1caffba7028", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 17573, "upload_time": "2020-03-13T23:17:41", "upload_time_iso_8601": "2020-03-13T23:17:41.455656Z", "url": "https://files.pythonhosted.org/packages/22/72/01a0376cc8972c5a4138ee584d3099b1623b826b5fa65d9c739bb70f1621/npsql-0.1.0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 00:44:31 2020"}