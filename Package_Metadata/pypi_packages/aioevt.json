{"info": {"author": "Austin Archer", "author_email": "aarcher@protonmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Plugins", "Framework :: AsyncIO", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3 :: Only", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# Aioevt\n#### Simplified Asyncio Event Management\n\n\n### Problem\nAsyncio offers a lot of utilities that provide thread-safe execution of coroutines and synchronous functions. However, there isn't any one \"unified\" way of emitting/catching events accross threads.\n\n### Solution\naioevt - After creating the manager, you can emit 'global' events in a thread-safe way. Callbacks can be both registered and emitted from any thread. This allows you to very easily share objects through multithreaded HTTP servers such as Sanic or Vibora.\n\n\n## Documentation\n\n#### Create a manager    \n\n#### Register an event\n\n    def register(self, name: str, func: Callable, loop: asyncio.AbstractEventLoop=None, recurring: bool=True):\n        \"\"\"\n        Register a global event to be triggered from a provided event loop when a named event is emitted.\n\n        :param name: event name.\n        :param func: callable function to be called when an event is emitted\n        :param loop: the loop from which you want the callback to be executed\n        :param recurring: whether or not the event should be re-registered after it is\n        \"\"\"\n#### Emitting an event\n\n    def emit(self, name: str, *args):\n        \"\"\"\n        Non-blocking function to emit a signal with arbitrary parameters. This can execute both\n        synchronous or asynchronous callbacks.\n\n        :param name: event name\n        :param args: additional event arguments\n\n        :return None\n        \"\"\"\n\n\n#### Waiting for an event\n\n    @asyncio.coroutine\n    def wait(self, name: str, timeout: float=None):\n        \"\"\"\n        Wait until an event fures and return the emit parameters\n\n        :param name: Event Name\n        :param loop: the event loop\n        :param timeout: the maximum time (in seconds) to wait before it raises an exception\n        :return the parameters passed to `emit`\n        :raises asyncio.TimeoutError when necessary\n        \"\"\"\n\n\n#### Unregistering an event\n\n    def unregister(self, name=None, func=None):\n        \"\"\"\n        Unregister an event\n        NOTE: by name is significantly faster than by function since it just needs to do a single lookup.\n        Unregistering an event via callback means it needs to iterate through ALL events.\n\n        :param name: Event name\n        :param func: callback function\n        :return None\n        \"\"\"\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/GoodiesHQ/aioevt", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "aioevt", "package_url": "https://pypi.org/project/aioevt/", "platform": "", "project_url": "https://pypi.org/project/aioevt/", "project_urls": {"Homepage": "https://github.com/GoodiesHQ/aioevt"}, "release_url": "https://pypi.org/project/aioevt/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Aioevt</h1>\n<h4>Simplified Asyncio Event Management</h4>\n<h3>Problem</h3>\n<p>Asyncio offers a lot of utilities that provide thread-safe execution of coroutines and synchronous functions. However, there isn't any one \"unified\" way of emitting/catching events accross threads.</p>\n<h3>Solution</h3>\n<p>aioevt - After creating the manager, you can emit 'global' events in a thread-safe way. Callbacks can be both registered and emitted from any thread. This allows you to very easily share objects through multithreaded HTTP servers such as Sanic or Vibora.</p>\n<h2>Documentation</h2>\n<h4>Create a manager</h4>\n<h4>Register an event</h4>\n<pre><code>def register(self, name: str, func: Callable, loop: asyncio.AbstractEventLoop=None, recurring: bool=True):\n    \"\"\"\n    Register a global event to be triggered from a provided event loop when a named event is emitted.\n\n    :param name: event name.\n    :param func: callable function to be called when an event is emitted\n    :param loop: the loop from which you want the callback to be executed\n    :param recurring: whether or not the event should be re-registered after it is\n    \"\"\"\n</code></pre>\n<h4>Emitting an event</h4>\n<pre><code>def emit(self, name: str, *args):\n    \"\"\"\n    Non-blocking function to emit a signal with arbitrary parameters. This can execute both\n    synchronous or asynchronous callbacks.\n\n    :param name: event name\n    :param args: additional event arguments\n\n    :return None\n    \"\"\"\n</code></pre>\n<h4>Waiting for an event</h4>\n<pre><code>@asyncio.coroutine\ndef wait(self, name: str, timeout: float=None):\n    \"\"\"\n    Wait until an event fures and return the emit parameters\n\n    :param name: Event Name\n    :param loop: the event loop\n    :param timeout: the maximum time (in seconds) to wait before it raises an exception\n    :return the parameters passed to `emit`\n    :raises asyncio.TimeoutError when necessary\n    \"\"\"\n</code></pre>\n<h4>Unregistering an event</h4>\n<pre><code>def unregister(self, name=None, func=None):\n    \"\"\"\n    Unregister an event\n    NOTE: by name is significantly faster than by function since it just needs to do a single lookup.\n    Unregistering an event via callback means it needs to iterate through ALL events.\n\n    :param name: Event name\n    :param func: callback function\n    :return None\n    \"\"\"\n</code></pre>\n\n          </div>"}, "last_serial": 6633196, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "1f16184b60dff274e2594e8d65d98691", "sha256": "746f71ecd1d2eaa855c57f6600b52c75e989a41e2f9349640afa21ba1b8c1349"}, "downloads": -1, "filename": "aioevt-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1f16184b60dff274e2594e8d65d98691", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 4338, "upload_time": "2018-08-12T22:08:20", "upload_time_iso_8601": "2018-08-12T22:08:20.192982Z", "url": "https://files.pythonhosted.org/packages/33/69/853ed5989a5efb54e58ba0589215c5ae294d9a04453564de5eac42929c70/aioevt-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7a06cf29c7bcf73aa2379fc491440c66", "sha256": "5170f03958d17a2352042caddc824e807aa23c1684f2cedbe9a3ede95844240b"}, "downloads": -1, "filename": "aioevt-0.1.0.tar.gz", "has_sig": false, "md5_digest": "7a06cf29c7bcf73aa2379fc491440c66", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3346, "upload_time": "2018-08-12T22:08:21", "upload_time_iso_8601": "2018-08-12T22:08:21.518853Z", "url": "https://files.pythonhosted.org/packages/19/38/fceffbb8d7ec8c215b5552129cbec23be35377d294466ab212aeb1ba53b5/aioevt-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "6f154fc7e6a08b35815d519f77244b11", "sha256": "170c3b1c196fc398e3db8bca6246e38f0379e00297200391162ef77e900f78e7"}, "downloads": -1, "filename": "aioevt-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "6f154fc7e6a08b35815d519f77244b11", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17064, "upload_time": "2020-02-14T19:24:05", "upload_time_iso_8601": "2020-02-14T19:24:05.836721Z", "url": "https://files.pythonhosted.org/packages/cc/2b/64ffc667f62e31f19f432550647ae57f38c4f021d38df9172c551ae00cfd/aioevt-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "140449fa8efa3405909df783b741b19c", "sha256": "93778b487dcab3bf8e317409e77387f82f48798caa5080926e03b34d6a27f7be"}, "downloads": -1, "filename": "aioevt-0.1.1.tar.gz", "has_sig": false, "md5_digest": "140449fa8efa3405909df783b741b19c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3828, "upload_time": "2020-02-14T19:24:07", "upload_time_iso_8601": "2020-02-14T19:24:07.350790Z", "url": "https://files.pythonhosted.org/packages/89/41/7cf02c1f15ad064b4b25d40b4d07581b793f1e4b28b43f6278cd1995f0b7/aioevt-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6f154fc7e6a08b35815d519f77244b11", "sha256": "170c3b1c196fc398e3db8bca6246e38f0379e00297200391162ef77e900f78e7"}, "downloads": -1, "filename": "aioevt-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "6f154fc7e6a08b35815d519f77244b11", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17064, "upload_time": "2020-02-14T19:24:05", "upload_time_iso_8601": "2020-02-14T19:24:05.836721Z", "url": "https://files.pythonhosted.org/packages/cc/2b/64ffc667f62e31f19f432550647ae57f38c4f021d38df9172c551ae00cfd/aioevt-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "140449fa8efa3405909df783b741b19c", "sha256": "93778b487dcab3bf8e317409e77387f82f48798caa5080926e03b34d6a27f7be"}, "downloads": -1, "filename": "aioevt-0.1.1.tar.gz", "has_sig": false, "md5_digest": "140449fa8efa3405909df783b741b19c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3828, "upload_time": "2020-02-14T19:24:07", "upload_time_iso_8601": "2020-02-14T19:24:07.350790Z", "url": "https://files.pythonhosted.org/packages/89/41/7cf02c1f15ad064b4b25d40b4d07581b793f1e4b28b43f6278cd1995f0b7/aioevt-0.1.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:21:37 2020"}