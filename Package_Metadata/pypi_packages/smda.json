{"info": {"author": "Daniel Plohmann", "author_email": "daniel.plohmann@mailbox.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Security", "Topic :: Software Development :: Disassemblers"], "description": "# SMDA\n\nSMDA is a minimalist recursive disassembler library that is optimized for accurate Control Flow Graph (CFG) recovery from memory dumps.\nIt is based on [Capstone](http://www.capstone-engine.org/) and currently supports x86/x64 Intel machine code.\nAs input, arbitrary memory dumps (ideally with known base address) can be processed.\nThe output is a collection of functions, basic blocks, and instructions with their respective edges between blocks and functions (in/out).\nOptionally, references to the Windows API can be inferred by using the ApiScout method.\n\n## Installation\n\nWith version 1.2.0, we have finally simplified things by moving to [PyPI](https://pypi.org/project/smda/)!  \nSo installation now is as easy as:\n\n```\n$ pip install smda\n```\n\n## Usage\n\nA typical workflow using SMDA could like this:\n\n```\n>>> from smda.Disassembler import Disassembler\n>>> disassembler = Disassembler()\n>>> report = disassembler.disassembleFile(\"/bin/cat\")\n>>> print(report)\n 0.777s -> (architecture: intel.64bit, base_addr: 0x00000000): 143 functions\n>>> for fn in report.getFunctions():\n...     print(fn)\n...     for ins in fn.getInstructions():\n...         print(ins)\n...\n0x00001720: (->   1,    1->)   3 blocks,    7 instructions.\n0x00001720: (      4883ec08) - sub rsp, 8\n0x00001724: (488b05bd682000) - mov rax, qword ptr [rip + 0x2068bd]\n0x0000172b: (        4885c0) - test rax, rax\n0x0000172e: (          7402) - je 0x1732\n0x00001730: (          ffd0) - call rax\n0x00001732: (      4883c408) - add rsp, 8\n0x00001736: (            c3) - ret \n0x00001ad0: (->   1,    4->)   1 blocks,   12 instructions.\n[...]\n>>> json_report = report.toDict()\n``` \n\nThere is also a demo script:\n\n* analyze.py -- example usage: perform disassembly on a file or memory dump and optionally store results in JSON to a given output path.\n\nThe code should be fully compatible with Python 2 and 3.\nFurther explanation on the innerworkings follow in separate publications but will be referenced here.\n\nTo take full advantage of SMDA's capabilities, make sure to (optionally) install:\n * lief \n * pdbparse (currently as fork from https://github.com/VPaulV/pdbparse to support Python3)\n\n## Version History\n\n * 2020-05-04: v1.2.4 - Various minor fixes.\n * 2020-04-29: v1.2.0 - Restructured config.py into smda/SmdaConfig.py to similfy usage and now available via PyPI! The smda/Disassembler.py now emits a report object (smda.common.SmdaReport) that allows direct (pythonic) interaction with the results - a JSON can still be easily generated by using toDict() on the report.\n * 2020-04-28: v1.1.0 - Several improvements, including: x64 jump table handling, better data flow handling for calls using registers and tailcalls, extended list of common prologues based on much more groundtruth data, extended padding instruction list for gap function discovery, adjusted weights in candidate priority score, filtering code areas based on section tables, using exported symbols as candidates, new function output metadata: confidence score based on instruction mnemonic histogram, PIC hash based on escaped binary instruction sequence\n * 2020-03-10: Various minor fixes and QoL improvements.\n * 2019-08-20: IdaExporter is now handling failed instruction conversion via capstone properly.\n * 2019-08-19: Minor fix for crashes caused by PDB parser.\n * 2019-08-05: v1.0.3 - SMDA can now export reports from IDA Pro (requires capstone to be available for idapython).\n * 2019-06-13: PDB symbols for functions are now resolved if given a PDB file using parameter \"-d\" (THX to @VPaulV).\n * 2019-05-15: Fixed a bug in PE mapper where buffer would be shortened because of misinterpretation of section sizes.\n * 2019-02-14: v1.0.2 - ELF symbols for functions are now resolved, if present in the file. Also \"-m\" parameter changed to \"-p\" to imply parsing instead of just mapping (THX: @VPaulV).\n * 2018-12-12: all gcc jump table styles are now parsed correctly. \n * 2018-11-26: Better handling of multibyte NOPs, ELF loader now provides base addr.\n * 2018-09-28: We now have functional PE/ELF loaders.\n * 2018-07-09: v1.0.1 - Performance improvements.\n * 2018-07-01: v1.0.0 - Initial Release.\n\n\n## Credits\n\nThanks to Steffen Enders for his extensive contributions to this project.\nThanks to Paul Hordiienko for adding symbol parsing support (ELF PDB).\n\nPull requests welcome! :)", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/danielplohmann/smda", "keywords": "", "license": "BSD 2-Clause", "maintainer": "", "maintainer_email": "", "name": "smda", "package_url": "https://pypi.org/project/smda/", "platform": "", "project_url": "https://pypi.org/project/smda/", "project_urls": {"Homepage": "https://github.com/danielplohmann/smda"}, "release_url": "https://pypi.org/project/smda/1.2.4/", "requires_dist": null, "requires_python": "", "summary": "A recursive disassmbler optimized for CFG recovery from memory dumps. Based on capstone.", "version": "1.2.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>SMDA</h1>\n<p>SMDA is a minimalist recursive disassembler library that is optimized for accurate Control Flow Graph (CFG) recovery from memory dumps.\nIt is based on <a href=\"http://www.capstone-engine.org/\" rel=\"nofollow\">Capstone</a> and currently supports x86/x64 Intel machine code.\nAs input, arbitrary memory dumps (ideally with known base address) can be processed.\nThe output is a collection of functions, basic blocks, and instructions with their respective edges between blocks and functions (in/out).\nOptionally, references to the Windows API can be inferred by using the ApiScout method.</p>\n<h2>Installation</h2>\n<p>With version 1.2.0, we have finally simplified things by moving to <a href=\"https://pypi.org/project/smda/\" rel=\"nofollow\">PyPI</a>!<br>\nSo installation now is as easy as:</p>\n<pre><code>$ pip install smda\n</code></pre>\n<h2>Usage</h2>\n<p>A typical workflow using SMDA could like this:</p>\n<pre><code>&gt;&gt;&gt; from smda.Disassembler import Disassembler\n&gt;&gt;&gt; disassembler = Disassembler()\n&gt;&gt;&gt; report = disassembler.disassembleFile(\"/bin/cat\")\n&gt;&gt;&gt; print(report)\n 0.777s -&gt; (architecture: intel.64bit, base_addr: 0x00000000): 143 functions\n&gt;&gt;&gt; for fn in report.getFunctions():\n...     print(fn)\n...     for ins in fn.getInstructions():\n...         print(ins)\n...\n0x00001720: (-&gt;   1,    1-&gt;)   3 blocks,    7 instructions.\n0x00001720: (      4883ec08) - sub rsp, 8\n0x00001724: (488b05bd682000) - mov rax, qword ptr [rip + 0x2068bd]\n0x0000172b: (        4885c0) - test rax, rax\n0x0000172e: (          7402) - je 0x1732\n0x00001730: (          ffd0) - call rax\n0x00001732: (      4883c408) - add rsp, 8\n0x00001736: (            c3) - ret \n0x00001ad0: (-&gt;   1,    4-&gt;)   1 blocks,   12 instructions.\n[...]\n&gt;&gt;&gt; json_report = report.toDict()\n</code></pre>\n<p>There is also a demo script:</p>\n<ul>\n<li>analyze.py -- example usage: perform disassembly on a file or memory dump and optionally store results in JSON to a given output path.</li>\n</ul>\n<p>The code should be fully compatible with Python 2 and 3.\nFurther explanation on the innerworkings follow in separate publications but will be referenced here.</p>\n<p>To take full advantage of SMDA's capabilities, make sure to (optionally) install:</p>\n<ul>\n<li>lief</li>\n<li>pdbparse (currently as fork from <a href=\"https://github.com/VPaulV/pdbparse\" rel=\"nofollow\">https://github.com/VPaulV/pdbparse</a> to support Python3)</li>\n</ul>\n<h2>Version History</h2>\n<ul>\n<li>2020-05-04: v1.2.4 - Various minor fixes.</li>\n<li>2020-04-29: v1.2.0 - Restructured config.py into smda/SmdaConfig.py to similfy usage and now available via PyPI! The smda/Disassembler.py now emits a report object (smda.common.SmdaReport) that allows direct (pythonic) interaction with the results - a JSON can still be easily generated by using toDict() on the report.</li>\n<li>2020-04-28: v1.1.0 - Several improvements, including: x64 jump table handling, better data flow handling for calls using registers and tailcalls, extended list of common prologues based on much more groundtruth data, extended padding instruction list for gap function discovery, adjusted weights in candidate priority score, filtering code areas based on section tables, using exported symbols as candidates, new function output metadata: confidence score based on instruction mnemonic histogram, PIC hash based on escaped binary instruction sequence</li>\n<li>2020-03-10: Various minor fixes and QoL improvements.</li>\n<li>2019-08-20: IdaExporter is now handling failed instruction conversion via capstone properly.</li>\n<li>2019-08-19: Minor fix for crashes caused by PDB parser.</li>\n<li>2019-08-05: v1.0.3 - SMDA can now export reports from IDA Pro (requires capstone to be available for idapython).</li>\n<li>2019-06-13: PDB symbols for functions are now resolved if given a PDB file using parameter \"-d\" (THX to @VPaulV).</li>\n<li>2019-05-15: Fixed a bug in PE mapper where buffer would be shortened because of misinterpretation of section sizes.</li>\n<li>2019-02-14: v1.0.2 - ELF symbols for functions are now resolved, if present in the file. Also \"-m\" parameter changed to \"-p\" to imply parsing instead of just mapping (THX: @VPaulV).</li>\n<li>2018-12-12: all gcc jump table styles are now parsed correctly.</li>\n<li>2018-11-26: Better handling of multibyte NOPs, ELF loader now provides base addr.</li>\n<li>2018-09-28: We now have functional PE/ELF loaders.</li>\n<li>2018-07-09: v1.0.1 - Performance improvements.</li>\n<li>2018-07-01: v1.0.0 - Initial Release.</li>\n</ul>\n<h2>Credits</h2>\n<p>Thanks to Steffen Enders for his extensive contributions to this project.\nThanks to Paul Hordiienko for adding symbol parsing support (ELF PDB).</p>\n<p>Pull requests welcome! :)</p>\n\n          </div>"}, "last_serial": 7164580, "releases": {"1.2.0": [{"comment_text": "", "digests": {"md5": "c603f283ad8ba2908eaa6536689fa39a", "sha256": "a94ba2b609e9e9f56e29620e245a0fd4de61fb14dbbb2de604361b3532feee69"}, "downloads": -1, "filename": "smda-1.2.0.tar.gz", "has_sig": false, "md5_digest": "c603f283ad8ba2908eaa6536689fa39a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55464, "upload_time": "2020-05-01T12:20:16", "upload_time_iso_8601": "2020-05-01T12:20:16.877804Z", "url": "https://files.pythonhosted.org/packages/66/3e/12d10b35bbb3506b1264f2c289159bba2d44902fb461c3467ad14755d5f5/smda-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "7cc4004d2181b19d78ac265b57371413", "sha256": "ee7eea656afc7a82b1b281f37c7ad2d57d256c60b3d62b2431687f0ca492f349"}, "downloads": -1, "filename": "smda-1.2.1.tar.gz", "has_sig": false, "md5_digest": "7cc4004d2181b19d78ac265b57371413", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55499, "upload_time": "2020-05-04T07:52:29", "upload_time_iso_8601": "2020-05-04T07:52:29.940231Z", "url": "https://files.pythonhosted.org/packages/4e/f8/ccfd2ccd493380945dba27237d37e7fdf0e51899c962304b006c3948d8d8/smda-1.2.1.tar.gz", "yanked": false}], "1.2.2": [{"comment_text": "", "digests": {"md5": "e499c968a42ae2e721dc3c0e9fa2e548", "sha256": "5fa20c09dfd593e772dbf4d304d8cb721fb6c8e18771a7d28ef5e744ed3b09df"}, "downloads": -1, "filename": "smda-1.2.2.tar.gz", "has_sig": false, "md5_digest": "e499c968a42ae2e721dc3c0e9fa2e548", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55701, "upload_time": "2020-05-04T12:20:52", "upload_time_iso_8601": "2020-05-04T12:20:52.350332Z", "url": "https://files.pythonhosted.org/packages/5f/33/f5ed88943ca6434914fe8c998f6beee624d00ff3194d6a14e299ef57488f/smda-1.2.2.tar.gz", "yanked": false}], "1.2.3": [{"comment_text": "", "digests": {"md5": "980310744624092e4e70c50bef98b3dc", "sha256": "b3eed3fba76fbec13d51561c9f87b51bc10f04b91c1178d8d2b2b27c4009eae9"}, "downloads": -1, "filename": "smda-1.2.3.tar.gz", "has_sig": false, "md5_digest": "980310744624092e4e70c50bef98b3dc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55789, "upload_time": "2020-05-04T13:11:03", "upload_time_iso_8601": "2020-05-04T13:11:03.975263Z", "url": "https://files.pythonhosted.org/packages/47/c5/e7e48813c7518770e8c99062f50e0351641edfa0d236cb0d21c7c79fc6f9/smda-1.2.3.tar.gz", "yanked": false}], "1.2.4": [{"comment_text": "", "digests": {"md5": "e07d9c8adcb44278b12199f7ddad35a3", "sha256": "522e301d03a8f56712576d9c01bf5d01c30ff76328d35c7f3ed7d565268f637c"}, "downloads": -1, "filename": "smda-1.2.4.tar.gz", "has_sig": false, "md5_digest": "e07d9c8adcb44278b12199f7ddad35a3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55633, "upload_time": "2020-05-04T13:52:43", "upload_time_iso_8601": "2020-05-04T13:52:43.248251Z", "url": "https://files.pythonhosted.org/packages/cc/e3/531dfb2ffe3d97fa5c102fdc9c5b7fc6ad96e0243b0d8ec8d4cc37d59466/smda-1.2.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e07d9c8adcb44278b12199f7ddad35a3", "sha256": "522e301d03a8f56712576d9c01bf5d01c30ff76328d35c7f3ed7d565268f637c"}, "downloads": -1, "filename": "smda-1.2.4.tar.gz", "has_sig": false, "md5_digest": "e07d9c8adcb44278b12199f7ddad35a3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55633, "upload_time": "2020-05-04T13:52:43", "upload_time_iso_8601": "2020-05-04T13:52:43.248251Z", "url": "https://files.pythonhosted.org/packages/cc/e3/531dfb2ffe3d97fa5c102fdc9c5b7fc6ad96e0243b0d8ec8d4cc37d59466/smda-1.2.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:56 2020"}