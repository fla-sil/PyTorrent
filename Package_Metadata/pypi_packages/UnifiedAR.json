{"info": {"author": "modaresi mr", "author_email": "modaresimr@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# DataSet\n## Dataset Format:\n### Object:\n    An object is a primitive object, a vector or in the form of a tuple of data components:\n    Object ={o|     o is Primitive or\n\t                o=[o_1, ... , o_n] such that o_i is Object(Vector of object) or\n\t                o=(Prop_1, ... , Prop_n) forall i in {1...n}, Prop_i(o) is Object}\n### Time Object:\nTime might be a point, in case of an instantaneous event, or an interval during if it is durative. Supported durative time is range.\n\n    time | [start_time:end_time]\n\n\n### Event:\n|Type|Actor| Time |\n|-|-|-|\n### Sensor Events:\n|(Type, Value)|SensorId| Time |\n|-|-|-|\n\n### Activity Events:\n|ActivityId|ActorId| Time |\n|-|-|-|\n\n### DataInformation:\n#### Sensor Info\n| Id | Name | Cumulative | OnChange | Nominal | Range | Location | Object | Sensor |\n|-|-|-|-|-|-|-|-|-|\n\n\n\n#### Activity Info\n|Id|Name|\n|-|-|\n\n\n\n\n### File format: CSV\n#### Sensor Info:\n| Id | Name | Cumulative | OnChange | Nominal | Range | Location | Object | Sensor |\n|-|-|-|-|-|-|-|-|-|\n| int | string | bool | bool | bool | json {min,max}/{items} | string | string | string |\nin case of nominal sensors, the range contain items and for numeric sensors, the range contain min and max\n\n#### Sensor events:\n|Type | Value | SensorId | Time |\n|-|-|-|-|\n\n#### Activity events:\n|ActivityId|ActorId| StartTime | EndTime|\n|-|-|-|-|\n\n![](http://yuml.me/diagram/scruffy/class/[Preprocessing]->[Dispacher],[Dispacher]->[Segmentation],[Segmentation]->[FeatureExtraction],[FeatureExtraction]->[Classifier],[Classifier]->[Combiner],[Combiner]->[Evaluation])\n\n#### Approaches\n\\begin{Example}[Different Segmentation approaches]\n\\end{Example}\n    \\begin{lstlisting}[mathescape=true]\nfunction Fixed time window(S,X,r,l) {//S=SegmentHistory, X=Events, \n         //r=Shift, l=windowLength\n    p=begin(S[last])\n    return X.eventsIn([p + r : p + r + l]); \n}\nfunction Fixed siding window(S,X,r,l) {\n    prev_w=S[last]; p=begin(S[last])\n    be=first({e \\in X| p + r $\\leq$ time(e)}\n    return X.eventsIn([be : be + l]); \n}\nfunction Significant events(S,X,m) {//m=significant events per segments\n    se=significantEvents(X) $\\subseteq$ X\n    begin=time(se[1]);//next significant event \n    end=time(se[1 + m]);\n    return X.eventsIn([begin:end]); \n}\n//Probabilistic Approach\ngiven:(By analyzing training set) \n    $ws(A_m)$ is average window size of activity $A_m$\n    $w_1 = min \\{ws(A_1), ws(A_2), ..., ws(A_M)\\}$\n    $w_L = median\\{ws(A_1), ws(A_2), ..., ws(A_M)\\}$\n    $w_l=(w_L-w_1)\\times l/L+w_1$\n    $window\\_sizes= \\{w_1, w_2, . . . , w_L\\}$\n    $P(w_l /A_m)$//probability of windows length $w_l$ for an activity Am\n    $P(A_m /s_i)$//probability of Activity $A_i$ associated with the sensor $s_i$.\nfunction Probabilistic Approach(S,X) {\n    x=nextEvent(X)\n    $w^{\\star} =\\underset{w_l}{max}  \\{P(w_l /x)\\}=\\underset{w_l}{max}[P(w_l /A_m)\\times P(A_m /x)] $\n    end=time(x);//Next event\n    return X.eventsIn(end-$w^\\star$,end]); \n}\nfunction Metric base Approach(S,X) {//S=SegmentHistory, X=Events    \n    indx=len(S[last])+1 //first event not in old segment\n    $m_i=metric(\\{X[indx],...,X[i]\\})$\n    find first i which $H(\\{m_{0}....m_i\\})$ is true// \n    return X.eventsIn([time(X[indx]):time(X[i])]); \n}\nfunction SWAB Approach(S,X,bs) {//bs=Buffer size    \n    indx=len(S[last])+1 //first event not in old segment\n    $m=BottomUp(\\{X[indx],...,X[indx+bs]\\})$\n    return m[0]; \n}\n\\end{lstlisting}\n\n\n# Similar Works\n[pyActLearn](https://github.com/TinghuiWang/pyActLearn/) -> [documents](https://pyactlearn.readthedocs.io/en/latest/)", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/modaresimr/UnifiedAR", "keywords": "", "license": "Apache Software License", "maintainer": "", "maintainer_email": "", "name": "UnifiedAR", "package_url": "https://pypi.org/project/UnifiedAR/", "platform": "", "project_url": "https://pypi.org/project/UnifiedAR/", "project_urls": {"Homepage": "https://github.com/modaresimr/UnifiedAR"}, "release_url": "https://pypi.org/project/UnifiedAR/1/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Activity Recognition", "version": "1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>DataSet</h1>\n<h2>Dataset Format:</h2>\n<h3>Object:</h3>\n<pre><code>An object is a primitive object, a vector or in the form of a tuple of data components:\nObject ={o|     o is Primitive or\n                o=[o_1, ... , o_n] such that o_i is Object(Vector of object) or\n                o=(Prop_1, ... , Prop_n) forall i in {1...n}, Prop_i(o) is Object}\n</code></pre>\n<h3>Time Object:</h3>\n<p>Time might be a point, in case of an instantaneous event, or an interval during if it is durative. Supported durative time is range.</p>\n<pre><code>time | [start_time:end_time]\n</code></pre>\n<h3>Event:</h3>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Actor</th>\n<th>Time</th>\n</tr>\n</thead></table>\n<h3>Sensor Events:</h3>\n<table>\n<thead>\n<tr>\n<th>(Type, Value)</th>\n<th>SensorId</th>\n<th>Time</th>\n</tr>\n</thead></table>\n<h3>Activity Events:</h3>\n<table>\n<thead>\n<tr>\n<th>ActivityId</th>\n<th>ActorId</th>\n<th>Time</th>\n</tr>\n</thead></table>\n<h3>DataInformation:</h3>\n<h4>Sensor Info</h4>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>Name</th>\n<th>Cumulative</th>\n<th>OnChange</th>\n<th>Nominal</th>\n<th>Range</th>\n<th>Location</th>\n<th>Object</th>\n<th>Sensor</th>\n</tr>\n</thead></table>\n<h4>Activity Info</h4>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>Name</th>\n</tr>\n</thead></table>\n<h3>File format: CSV</h3>\n<h4>Sensor Info:</h4>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>Name</th>\n<th>Cumulative</th>\n<th>OnChange</th>\n<th>Nominal</th>\n<th>Range</th>\n<th>Location</th>\n<th>Object</th>\n<th>Sensor</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>string</td>\n<td>bool</td>\n<td>bool</td>\n<td>bool</td>\n<td>json {min,max}/{items}</td>\n<td>string</td>\n<td>string</td>\n<td>string</td>\n</tr>\n<tr>\n<td>in case of nominal sensors, the range contain items and for numeric sensors, the range contain min and max</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr></tbody></table>\n<h4>Sensor events:</h4>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Value</th>\n<th>SensorId</th>\n<th>Time</th>\n</tr>\n</thead></table>\n<h4>Activity events:</h4>\n<table>\n<thead>\n<tr>\n<th>ActivityId</th>\n<th>ActorId</th>\n<th>StartTime</th>\n<th>EndTime</th>\n</tr>\n</thead></table>\n<p><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/52009de934f0345a489fd2ea21eb07a0dc1abdc7/687474703a2f2f79756d6c2e6d652f6469616772616d2f736372756666792f636c6173732f25354250726570726f63657373696e672535442d2533452535424469737061636865722535442c2535424469737061636865722535442d2533452535425365676d656e746174696f6e2535442c2535425365676d656e746174696f6e2535442d2533452535424665617475726545787472616374696f6e2535442c2535424665617475726545787472616374696f6e2535442d253345253542436c61737369666965722535442c253542436c61737369666965722535442d253345253542436f6d62696e65722535442c253542436f6d62696e65722535442d2533452535424576616c756174696f6e253544\"></p>\n<h4>Approaches</h4>\n<p>\\begin{Example}[Different Segmentation approaches]\n\\end{Example}\n\\begin{lstlisting}[mathescape=true]\nfunction Fixed time window(S,X,r,l) {//S=SegmentHistory, X=Events,\n//r=Shift, l=windowLength\np=begin(S[last])\nreturn X.eventsIn([p + r : p + r + l]);\n}\nfunction Fixed siding window(S,X,r,l) {\nprev_w=S[last]; p=begin(S[last])\nbe=first({e \\in X| p + r $\\leq$ time(e)}\nreturn X.eventsIn([be : be + l]);\n}\nfunction Significant events(S,X,m) {//m=significant events per segments\nse=significantEvents(X) $\\subseteq$ X\nbegin=time(se[1]);//next significant event\nend=time(se[1 + m]);\nreturn X.eventsIn([begin:end]);\n}\n//Probabilistic Approach\ngiven:(By analyzing training set)\n$ws(A_m)$ is average window size of activity $A_m$\n$w_1 = min {ws(A_1), ws(A_2), ..., ws(A_M)}$\n$w_L = median{ws(A_1), ws(A_2), ..., ws(A_M)}$\n$w_l=(w_L-w_1)\\times l/L+w_1$\n$window_sizes= {w_1, w_2, . . . , w_L}$\n$P(w_l /A_m)$//probability of windows length $w_l$ for an activity Am\n$P(A_m /s_i)$//probability of Activity $A_i$ associated with the sensor $s_i$.\nfunction Probabilistic Approach(S,X) {\nx=nextEvent(X)\n$w^{\\star} =\\underset{w_l}{max}  {P(w_l /x)}=\\underset{w_l}{max}[P(w_l /A_m)\\times P(A_m /x)] $\nend=time(x);//Next event\nreturn X.eventsIn(end-$w^\\star$,end]);\n}\nfunction Metric base Approach(S,X) {//S=SegmentHistory, X=Events<br>\nindx=len(S[last])+1 //first event not in old segment\n$m_i=metric({X[indx],...,X[i]})$\nfind first i which $H({m_{0}....m_i})$ is true//\nreturn X.eventsIn([time(X[indx]):time(X[i])]);\n}\nfunction SWAB Approach(S,X,bs) {//bs=Buffer size<br>\nindx=len(S[last])+1 //first event not in old segment\n$m=BottomUp({X[indx],...,X[indx+bs]})$\nreturn m[0];\n}\n\\end{lstlisting}</p>\n<h1>Similar Works</h1>\n<p><a href=\"https://github.com/TinghuiWang/pyActLearn/\" rel=\"nofollow\">pyActLearn</a> -&gt; <a href=\"https://pyactlearn.readthedocs.io/en/latest/\" rel=\"nofollow\">documents</a></p>\n\n          </div>"}, "last_serial": 6601477, "releases": {"1": [{"comment_text": "", "digests": {"md5": "18a5254a7265c2b5c9407c28717232e6", "sha256": "fe12d5907e7eeb61f0f1341db3e9daab35aee87a88332d577f913a6195fc1832"}, "downloads": -1, "filename": "UnifiedAR-1.tar.gz", "has_sig": false, "md5_digest": "18a5254a7265c2b5c9407c28717232e6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 50556, "upload_time": "2020-02-10T09:55:49", "upload_time_iso_8601": "2020-02-10T09:55:49.479851Z", "url": "https://files.pythonhosted.org/packages/55/c0/54875e8985906bc5e8951ebe7acfa7f96ce74d964cc687c209c17b4dd546/UnifiedAR-1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "18a5254a7265c2b5c9407c28717232e6", "sha256": "fe12d5907e7eeb61f0f1341db3e9daab35aee87a88332d577f913a6195fc1832"}, "downloads": -1, "filename": "UnifiedAR-1.tar.gz", "has_sig": false, "md5_digest": "18a5254a7265c2b5c9407c28717232e6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 50556, "upload_time": "2020-02-10T09:55:49", "upload_time_iso_8601": "2020-02-10T09:55:49.479851Z", "url": "https://files.pythonhosted.org/packages/55/c0/54875e8985906bc5e8951ebe7acfa7f96ce74d964cc687c209c17b4dd546/UnifiedAR-1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:40:34 2020"}