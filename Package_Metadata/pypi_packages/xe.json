{"info": {"author": "Eric Larson", "author_email": "eric@ionrock.org", "bugtrack_url": null, "classifiers": [], "description": "====\n Xe\n====\n\n`xe` stands for eXecutable Environment.\n\nThere are a ton of \"best practices\" for python projects. We can all\nagree that you should use a virtualenv_ and a test runner such as\npytest_ or nose_. Pip_ is another good tool to use. Sphinx_ is great\nfor documentation. The list goes on.\n\n.. _virtualenv: http://virtualenv.org\n.. _pytest: http://pytest.org\n.. _nose: http://nose.readthedocs.org/en/latest/\n.. _pip: http://pip-installer.org\n.. _sphinx: http://sphinx-doc.org\n\n\nThe problem is that while we agree on the tools, we seldom agree on\nhow we should use the tools. Some people use virtualenvwrapper_ and\nprefer to hide all their virtualenv's in a hidden directory. Others\nprefer to create a directory within the project root. Others like to\ndo a `virtualenv .` to create a virtualenv for a project so activation\ndoes the \"Right Thing\" with the prompt and uses the project name. Not\nto mention tools like tox_ that help create virtualenvs for different\nversions of Python and make sure your dev environment doesn't mix with\nyour test environment.\n\n.. _virtualenvwrapper: http://virtualenvwrapper.readthedocs.org/en/latest/\n.. _tox: http://tox.readthedocs.org/en/latest/\n\nWhile I'm positive that I can't bring the Python world together in\nharmony, I can write a tool to make this sort of environment\nmanagement and automate my own standard practices. I'm calling this\ntool `xe`.\n\n\nProject Opinions\n================\n\n`xe` is slightly opinionated in decisions it makes regarding a\nproject's dev environment. These opinions are never meant to be\ncontroversial! In fact the goal is to be as benign as possible in\nhopes that `xe` will easily support any developer's workflow.\n\nWith that in mind, there are some ideals that `xe` tries to maintain\nin order to be general and easy to work with.\n\n 1. all commands should be runnable without a required \"activation\"\n    step\n 2. a project should have its own environment\n\n\nAvoiding Activation\n-------------------\n\nIf you've ever deployed a project only to realize that you failed to\nupdate a dependency, then there is a good chance you were bitten by a\nfragile environment. While it is handy to be able to \"activate\" your\nenvironment, it makes it really easy to miss things when you are\nupdating dependencies.\n\nXe explicitly avoids shell level activation and instead finds your\nvirtualenv on every command.\n\n\nThe Right Environment for Every Command\n---------------------------------------\n\nAnother area `xe` helps is when you use an IDE type tool. Most editors\nand IDEs have the idea of a project. In the project settings you can\nconfigure builds that typically map to running tests or project\ntasks. If you are using a non-virtualenv aware tool, you usually have\nto configure environment variables in order to make sure the correct\nvirtualenv is used. Even if your tool does understand virtualenvs, you\nstill need to supply some configuration to the correct environment.\n\nUsing `xe` you can easily configure the default build as `xe test\n$fn`. There is not a list of environment variables you have to setup\nand configure. You don't have to specify a virtualenv directory or\ntesting tool. You can let `xe` takes care of it.\n\n\nIsolating Your Environment\n--------------------------\n\nA project should have its own environment because you should be\ntesting and using that project in isolation. That doesn't mean you\nshouldn't have subrepos or install other packages as editable. It\nsimply means that if you are working in a project directory, you\nshould be using that project's environment.\n\nAlong similar lines, a project environment should be easy to delete\nand rebuild from scratch. Using `xe`, the default behavior is to\ncreate a directory local virtualenv that can be removed and rebuilt\nfrom scratch when necessary.\n\n\nStandard Project Files and Directories\n======================================\n\nHere are the standard project files and directories that `xe`\nutilizes.\n\n  1. setup.py\n  2. requirements.txt\n  3. dev_requirements.txt\n  4. venv/ (virtualenv directory)\n\nMost of these can be configured to point to other non-root\ndirectories, but if you use these files, `xe` will try to work out of\nthe box without extra configuration.\n\nIt would be nice to eventually support different build tools, but I\nimagine that will be implemented via plugins. The idea being that an\norganization could implement their own build entry points and use `xe`\nto run them correctly.\n\n\nGetting Started\n===============\n\nTypically you'd read this first, but as this is our code we're talking\nabout we needed to get the prereq's out of the way and make sure that\nyour project isn't going to get borked by `xe`. Assuming things look\nreaonable, you can get started by doing:\n\n  $ xe bootstrap\n\n`xe` will create a virtualenv if one hasn't been created yet. It will\nthen look for a `dev_requirements.txt` and run that in the newly\ncreate environment. From there you can use `xe` to run tasks. A good\ndefault is simply running python:\n\n  $ xe python\n\nThat will start up the python in the `xe` virtualenv. If you are using\na django project you can use the following shortcut to have access to\nyour `manage.py` commands:\n\n  $ xe manage runserver\n\nIf you use pytest, you can run your tests too:\n\n  $ xe test -x\n\nSay you build your docs with make, you can use `xe` to run make and be\nconfident your environment will be in place.\n\n  $ xe make html\n\n\nWorking with Virtual Machines\n-----------------------------\n\nAnother concept of an environment is to work on a remote machine or\nvirtual machine such as `Vagrant <https://vagrantup.com>`_. `xe`\nsupports `rdo <https://rdo.readthedocs.org/en/latest/>`_ for running\ncommands on remote machines.\n\nTo use `rdo` for all commands, add to your `.xerc`:\n\n.. code-block:: yaml\n\n   USE_RDO: true\n\nIf you only want to use `rdo` for specific commands, specify them via\nthe `RDO_COMMANDS` field:\n\n.. code-block:: yaml\n\n   RDO_COMMANDS:\n     - make\n     - python", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/ionrock/xe", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "xe", "package_url": "https://pypi.org/project/xe/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/xe/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/ionrock/xe"}, "release_url": "https://pypi.org/project/xe/0.2/", "requires_dist": null, "requires_python": null, "summary": "Reliably manage your python dev environment.", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><cite>xe</cite> stands for eXecutable Environment.</p>\n<p>There are a ton of \u201cbest practices\u201d for python projects. We can all\nagree that you should use a <a href=\"http://virtualenv.org\" rel=\"nofollow\">virtualenv</a> and a test runner such as\n<a href=\"http://pytest.org\" rel=\"nofollow\">pytest</a> or <a href=\"http://nose.readthedocs.org/en/latest/\" rel=\"nofollow\">nose</a>. <a href=\"http://pip-installer.org\" rel=\"nofollow\">Pip</a> is another good tool to use. <a href=\"http://sphinx-doc.org\" rel=\"nofollow\">Sphinx</a> is great\nfor documentation. The list goes on.</p>\n<p>The problem is that while we agree on the tools, we seldom agree on\nhow we should use the tools. Some people use <a href=\"http://virtualenvwrapper.readthedocs.org/en/latest/\" rel=\"nofollow\">virtualenvwrapper</a> and\nprefer to hide all their virtualenv\u2019s in a hidden directory. Others\nprefer to create a directory within the project root. Others like to\ndo a <cite>virtualenv .</cite> to create a virtualenv for a project so activation\ndoes the \u201cRight Thing\u201d with the prompt and uses the project name. Not\nto mention tools like <a href=\"http://tox.readthedocs.org/en/latest/\" rel=\"nofollow\">tox</a> that help create virtualenvs for different\nversions of Python and make sure your dev environment doesn\u2019t mix with\nyour test environment.</p>\n<p>While I\u2019m positive that I can\u2019t bring the Python world together in\nharmony, I can write a tool to make this sort of environment\nmanagement and automate my own standard practices. I\u2019m calling this\ntool <cite>xe</cite>.</p>\n<div id=\"project-opinions\">\n<h2>Project Opinions</h2>\n<p><cite>xe</cite> is slightly opinionated in decisions it makes regarding a\nproject\u2019s dev environment. These opinions are never meant to be\ncontroversial! In fact the goal is to be as benign as possible in\nhopes that <cite>xe</cite> will easily support any developer\u2019s workflow.</p>\n<p>With that in mind, there are some ideals that <cite>xe</cite> tries to maintain\nin order to be general and easy to work with.</p>\n<blockquote>\n<ol>\n<li>all commands should be runnable without a required \u201cactivation\u201d\nstep</li>\n<li>a project should have its own environment</li>\n</ol>\n</blockquote>\n<div id=\"avoiding-activation\">\n<h3>Avoiding Activation</h3>\n<p>If you\u2019ve ever deployed a project only to realize that you failed to\nupdate a dependency, then there is a good chance you were bitten by a\nfragile environment. While it is handy to be able to \u201cactivate\u201d your\nenvironment, it makes it really easy to miss things when you are\nupdating dependencies.</p>\n<p>Xe explicitly avoids shell level activation and instead finds your\nvirtualenv on every command.</p>\n</div>\n<div id=\"the-right-environment-for-every-command\">\n<h3>The Right Environment for Every Command</h3>\n<p>Another area <cite>xe</cite> helps is when you use an IDE type tool. Most editors\nand IDEs have the idea of a project. In the project settings you can\nconfigure builds that typically map to running tests or project\ntasks. If you are using a non-virtualenv aware tool, you usually have\nto configure environment variables in order to make sure the correct\nvirtualenv is used. Even if your tool does understand virtualenvs, you\nstill need to supply some configuration to the correct environment.</p>\n<p>Using <cite>xe</cite> you can easily configure the default build as <cite>xe test\n$fn</cite>. There is not a list of environment variables you have to setup\nand configure. You don\u2019t have to specify a virtualenv directory or\ntesting tool. You can let <cite>xe</cite> takes care of it.</p>\n</div>\n<div id=\"isolating-your-environment\">\n<h3>Isolating Your Environment</h3>\n<p>A project should have its own environment because you should be\ntesting and using that project in isolation. That doesn\u2019t mean you\nshouldn\u2019t have subrepos or install other packages as editable. It\nsimply means that if you are working in a project directory, you\nshould be using that project\u2019s environment.</p>\n<p>Along similar lines, a project environment should be easy to delete\nand rebuild from scratch. Using <cite>xe</cite>, the default behavior is to\ncreate a directory local virtualenv that can be removed and rebuilt\nfrom scratch when necessary.</p>\n</div>\n</div>\n<div id=\"standard-project-files-and-directories\">\n<h2>Standard Project Files and Directories</h2>\n<p>Here are the standard project files and directories that <cite>xe</cite>\nutilizes.</p>\n<blockquote>\n<ol>\n<li>setup.py</li>\n<li>requirements.txt</li>\n<li>dev_requirements.txt</li>\n<li>venv/ (virtualenv directory)</li>\n</ol>\n</blockquote>\n<p>Most of these can be configured to point to other non-root\ndirectories, but if you use these files, <cite>xe</cite> will try to work out of\nthe box without extra configuration.</p>\n<p>It would be nice to eventually support different build tools, but I\nimagine that will be implemented via plugins. The idea being that an\norganization could implement their own build entry points and use <cite>xe</cite>\nto run them correctly.</p>\n</div>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<p>Typically you\u2019d read this first, but as this is our code we\u2019re talking\nabout we needed to get the prereq\u2019s out of the way and make sure that\nyour project isn\u2019t going to get borked by <cite>xe</cite>. Assuming things look\nreaonable, you can get started by doing:</p>\n<blockquote>\n$ xe bootstrap</blockquote>\n<p><cite>xe</cite> will create a virtualenv if one hasn\u2019t been created yet. It will\nthen look for a <cite>dev_requirements.txt</cite> and run that in the newly\ncreate environment. From there you can use <cite>xe</cite> to run tasks. A good\ndefault is simply running python:</p>\n<blockquote>\n$ xe python</blockquote>\n<p>That will start up the python in the <cite>xe</cite> virtualenv. If you are using\na django project you can use the following shortcut to have access to\nyour <cite>manage.py</cite> commands:</p>\n<blockquote>\n$ xe manage runserver</blockquote>\n<p>If you use pytest, you can run your tests too:</p>\n<blockquote>\n$ xe test -x</blockquote>\n<p>Say you build your docs with make, you can use <cite>xe</cite> to run make and be\nconfident your environment will be in place.</p>\n<blockquote>\n$ xe make html</blockquote>\n<div id=\"working-with-virtual-machines\">\n<h3>Working with Virtual Machines</h3>\n<p>Another concept of an environment is to work on a remote machine or\nvirtual machine such as <a href=\"https://vagrantup.com\" rel=\"nofollow\">Vagrant</a>. <cite>xe</cite>\nsupports <a href=\"https://rdo.readthedocs.org/en/latest/\" rel=\"nofollow\">rdo</a> for running\ncommands on remote machines.</p>\n<p>To use <cite>rdo</cite> for all commands, add to your <cite>.xerc</cite>:</p>\n<pre><span class=\"nt\">USE_RDO</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">true</span>\n</pre>\n<p>If you only want to use <cite>rdo</cite> for specific commands, specify them via\nthe <cite>RDO_COMMANDS</cite> field:</p>\n<pre><span class=\"nt\">RDO_COMMANDS</span><span class=\"p\">:</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">make</span>\n  <span class=\"p-Indicator\">-</span> <span class=\"l-Scalar-Plain\">python</span>\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1558383, "releases": {"0.2": [{"comment_text": "", "digests": {"md5": "b71c6037f103b46d41c95038c0585661", "sha256": "ad97c60ce725c6eb19ab7892f207991bac11aa6c69c19905e0f568c9cc3787d0"}, "downloads": -1, "filename": "xe-0.2.tar.gz", "has_sig": false, "md5_digest": "b71c6037f103b46d41c95038c0585661", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6718, "upload_time": "2015-05-22T18:12:10", "upload_time_iso_8601": "2015-05-22T18:12:10.076892Z", "url": "https://files.pythonhosted.org/packages/76/08/96472ecb9641d0d84c62ef72e0948d06a782983aaf6421e37ea0813ca724/xe-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b71c6037f103b46d41c95038c0585661", "sha256": "ad97c60ce725c6eb19ab7892f207991bac11aa6c69c19905e0f568c9cc3787d0"}, "downloads": -1, "filename": "xe-0.2.tar.gz", "has_sig": false, "md5_digest": "b71c6037f103b46d41c95038c0585661", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6718, "upload_time": "2015-05-22T18:12:10", "upload_time_iso_8601": "2015-05-22T18:12:10.076892Z", "url": "https://files.pythonhosted.org/packages/76/08/96472ecb9641d0d84c62ef72e0948d06a782983aaf6421e37ea0813ca724/xe-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:25:47 2020"}