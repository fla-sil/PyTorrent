{"info": {"author": "Zoltan Sylvester", "author_email": "zoltan.sylvester@beg.utexas.edu", "bugtrack_url": null, "classifiers": ["Intended Audience :: Science/Research", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3"], "description": "<img src=\"https://github.com/zsylvester/meanderpy/blob/master/meanderpy_logo.svg\" width=\"300\">\n\n## Description\n\n'meanderpy' is a Python module that implements a simple numerical model of meandering, the one described by Howard & Knutson in their 1984 paper [\"Sufficient Conditions for River Meandering: A Simulation Approach\"](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/WR020i011p01659). This is a kinematic model that is based on computing migration rate as the weighted sum of upstream curvatures; flow velocity does not enter the equation. Curvature is transformed into a 'nominal migration rate' through multiplication with a migration rate (or erodibility) constant; in the  Howard & Knutson (1984) paper this is a nonlinear relationship based on field observations that suggested a complex link between curvature and migration rate. In the 'meanderpy' module we use a simple linear relationship between the nominal migration rate and curvature, as recent work using time-lapse satellite imagery suggests that high curvatures result in high migration rates ([Sylvester et al., 2019](https://doi.org/10.1130/G45608.1)).\n\n## Installation\n\n<code>pip install meanderpy</code>\n\n## Usage\n\n<img src=\"https://github.com/zsylvester/meanderpy/blob/master/meanderpy_sketch.png\" width=\"600\">\n\nThe sketch above shows the three 'meanderpy' components: channel, cutoff, channel belt. These are implemented as classes; a 'Channel' and a 'Cutoff' are defined by their width, depth, and x,y,z centerline coordinates, and a 'ChannelBelt' is a collection of channels and cutoffs. In addition, the 'ChannelBelt' object also has a 'cl_times' and a 'cutoff_times' attribute that specify the age of the channels and the cutoffs. This age is relative to the start time of the simulation (= the first channel, age = 0.0).\n\nThe initial Channel object can be created using the 'generate_initial_channel' function. This creates a straight line, with some noise added. However, a Channel can be created (and then used as the first channel in a ChannelBelt) using any set of x,y,z,W,D variables.\n\n```python\nch = mp.generate_initial_channel(W,D,Sl,deltas,pad,n_bends) # initialize channel\nchb = mp.ChannelBelt(channels=[ch],cutoffs=[],cl_times=[0.0],cutoff_times=[]) # create channel belt object\n```\n\nA reasonable set of input parameters are as follows:\n\n```python\nW = 200.0                    # channel width (m)\nD = 16.0                     # channel depth (m)\npad = 100                    # padding (number of nodepoints along centerline)\ndeltas = 50.0                # sampling distance along centerline\nnit = 1500                   # number of iterations\nCf = 0.03                    # dimensionless Chezy friction factor\ncrdist = W                   # threshold distance at which cutoffs occur\nkl = 60.0/(365*24*60*60.0)   # migration rate constant (m/s)\nkv =  3*10*5.0E-13           # vertical slope-dependent erosion rate constant (m/s)\ndt = 0.1*(365*24*60*60.0)    # time step (s)\ndens = 1000                  # density of water (kg/m3)\nsaved_ts = 20                # which time steps will be saved\nn_bends = 30                 # approximate number of bends you want to model\nSl = 0.0                     # initial slope (setting this to non-zero results in instabilities in long runs)\n```\n\nThe core functionality of 'meanderpy' is built into the 'migrate' method of the 'ChannelBelt' class. This is the function that computes migration rates and moves the channel centerline to its new position. The last Channel of a ChannelBelt can be further migrated through applying the 'migrate' method to the ChannelBelt instance.\n\n```python\nchb.migrate(nit,saved_ts,deltas,pad,crdist,Cf,kl,kv,dt,dens) # channel migration\n```\n\nChannelBelt objects can be visualized using the 'plot' method. This creates a map of all the channels and cutoffs in the channel belt; there are two styles of plotting: a 'stratigraphic' view and a 'morphologic' view (see below). The morphologic view tries to account for the fact that older point bars and oxbow lakes tend to be gradually covered with vegetation. \n\n```python\n# migrate an additional 1000 iterations and plot results\nchb.migrate(1000,saved_ts,deltas,pad,crdist,Cf,kl,kv,dt,dens)\nfig = chb.plot('strat',20,60)\n```\n\n<img src=\"https://github.com/zsylvester/meanderpy/blob/master/meanderpy_strat_vs_morph.png\" width=\"1000\">\n\nA series of movie frames (in PNG format) can be created using the 'create_movie' method:\n\n```python\nchb.create_movie(xmin,xmax,plot_type,filename,dirname,pb_age,ob_age,scale,end_time)\n```\nThe frames have to be assembled into an animation outside of 'meanderpy'.\n\n## Build 3D model\n\n'meanderpy' includes the functionality to build 3D stratigraphic models. However, this functionality is decoupled from the centerline generation, mainly because it would be computationally expensive to generate surfaces for all centerlines, along their whole lengths. Instead, the 3D model is only created after a Channelbelt object has been generated; a model domain is defined either through specifying the xmin, xmax, ymin, ymax coordinates, or through clicking the upper left and lower right corners of the domain, using the matplotlib 'ginput' command:\n\n<img src=\"https://github.com/zsylvester/meanderpy/blob/master/define_3D_domain.png\" width=\"600\">\n\nImportant parameters for a fluvial 3D model are the following:\n\n```python\nSl = 0.0              # initial slope (matters more for submarine channels than rivers)\nt1 = 500              # time step when incision starts\nt2 = 700              # time step when lateral migration starts\nt3 = 1400             # time step when aggradation starts\naggr_factor = 4e-9    # aggradation rate (in m/s, it kicks in after t3)\nh_mud = 0.4           # thickness of overbank deposit for each time step\ndx = 10.0             # gridcell size in meters\n```\nThe first five of these parameters have to be specified before creating the centerlines. The initial slope (Sl) in a fluvial model is best set to zero, as typical gradients in meandering rivers are very low and artifacts associated with the along-channel slope variation will be visible in the model surfaces [this is not an issue with steeper submarine channel models]. t1 is the time step when incision starts; before t1, the centerlines are given time to develop some sinuosity. At time t2, incision stops and the channel only migrates laterally until t3; this is the time when aggradation starts. The rate of incision (if Sl is set to zero) is set by the quantity 'kv x dens x 9.81 x D x dt x 0.01' (as if the slope was 0.01, but of course it is not), where kv is the vertical incision rate constant. This approach does not require a new incision rate constant. The rate of aggradation is set by 'aggr_factor x dt' (so 'aggr_factor' must be a small number, as it is measured in m/s). 'h_mud' is the maximum thickness of the overbank deposit in each time step, and 'dx' is the gridcell size in meters. 'h_mud' has to be large enough that it matches the channel aggradation rate; weird artefacts are generated otherwise.\n\nThe Jupyter notebook has two examples for building 3D models, for a fluvial and a submarine channel system. The 'plot_xsection' method can be used to create a cross section at a given x (pixel) coordinate (this is the first argument of the function). The second argument determines the colors that are used for the different facies (in this case: brown, yellow, brown RGB values). The third argument is the vertical exaggeration.\n\n```python\nfig1,fig2,fig3 = chb_3d.plot_xsection(343, [[0.5,0.25,0],[0.9,0.9,0],[0.5,0.25,0]], 4)\n```\nThis function also plots the basal erosional surface and the final topographic surface. An example topographic surface and a zoomed-in cross section are shown below.\n\n<img src=\"https://github.com/zsylvester/meanderpy/blob/master/fluvial_meanderpy_example_map.png\" width=\"400\">\n\n<img src=\"https://github.com/zsylvester/meanderpy/blob/master/fluvial_meanderpy_example_section.png\" width=\"900\">\n\n## Related publications\n\nIf you use meanderpy in your work, please consider citing one or more of these publications:\n\nSylvester, Z., Durkin, P., and Covault, J.A., 2019, High curvatures drive river meandering: Geology, v. 47, p. 263\u2013266, [doi:10.1130/G45608.1](https://doi.org/10.1130/G45608.1).\n\nSylvester, Z., and Covault, J.A., 2016, Development of cutoff-related knickpoints during early evolution of submarine channels: Geology, v. 44, p. 835\u2013838, [doi:10.1130/G38397.1](https://doi.org/10.1130/G38397.1).\n\nCovault, J.A., Sylvester, Z., Hubbard, S.M., and Jobe, Z.R., 2016, The Stratigraphic Record of Submarine-Channel Evolution: The Sedimentary Record, v. 14, no. 3, p. 4-11, [doi:10.2210/sedred.2016.3](https://www.sepm.org/files/143article.hqx9r9brxux8f2se.pdf).\n\nSylvester, Z., Pirmez, C., and Cantelli, A., 2011, A model of submarine channel-levee evolution based on channel trajectories: Implications for stratigraphic architecture: Marine and Petroleum Geology, v. 28, p. 716\u2013727, [doi:10.1016/j.marpetgeo.2010.05.012](https://doi.org/10.1016/j.marpetgeo.2010.05.012).\n\n## Acknowledgements\n\nWhile the code in 'meanderpy' was written relatively recently, many of the ideas implemented in it come from numerous discussions with Carlos Pirmez, Alessandro Cantelli, Matt Wolinsky, Nick Howes, and Jake Covault. Funding for this work comes from the [Quantitative Clastics Laboratory industrial consortium](http://www.beg.utexas.edu/qcl) at the Bureau of Economic Geology, The University of Texas at Austin.\n\n## License\n\nmeanderpy is licensed under the [Apache License 2.0](https://github.com/zsylvester/meanderpy/blob/master/LICENSE.txt).\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/zsylvester/meanderpy", "keywords": "rivers,meandering,geomorphology,stratigraphy", "license": "", "maintainer": "", "maintainer_email": "", "name": "meanderpy", "package_url": "https://pypi.org/project/meanderpy/", "platform": "", "project_url": "https://pypi.org/project/meanderpy/", "project_urls": {"Homepage": "https://github.com/zsylvester/meanderpy"}, "release_url": "https://pypi.org/project/meanderpy/0.1.6/", "requires_dist": ["numpy", "matplotlib", "seaborn", "scipy", "numba", "ipython", "pillow", "scikit-image"], "requires_python": "", "summary": "A simple model of meander migration", "version": "0.1.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2a82d31cc0904b08a5951a8aca21697ee2079dc3/68747470733a2f2f6769746875622e636f6d2f7a73796c7665737465722f6d65616e64657270792f626c6f622f6d61737465722f6d65616e64657270795f6c6f676f2e737667\" width=\"300\">\n<h2>Description</h2>\n<p>'meanderpy' is a Python module that implements a simple numerical model of meandering, the one described by Howard &amp; Knutson in their 1984 paper <a href=\"https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/WR020i011p01659\" rel=\"nofollow\">\"Sufficient Conditions for River Meandering: A Simulation Approach\"</a>. This is a kinematic model that is based on computing migration rate as the weighted sum of upstream curvatures; flow velocity does not enter the equation. Curvature is transformed into a 'nominal migration rate' through multiplication with a migration rate (or erodibility) constant; in the  Howard &amp; Knutson (1984) paper this is a nonlinear relationship based on field observations that suggested a complex link between curvature and migration rate. In the 'meanderpy' module we use a simple linear relationship between the nominal migration rate and curvature, as recent work using time-lapse satellite imagery suggests that high curvatures result in high migration rates (<a href=\"https://doi.org/10.1130/G45608.1\" rel=\"nofollow\">Sylvester et al., 2019</a>).</p>\n<h2>Installation</h2>\n<p><code>pip install meanderpy</code></p>\n<h2>Usage</h2>\n<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dde7456b76d5bedabedbaace03cd8a9edae25018/68747470733a2f2f6769746875622e636f6d2f7a73796c7665737465722f6d65616e64657270792f626c6f622f6d61737465722f6d65616e64657270795f736b657463682e706e67\" width=\"600\">\n<p>The sketch above shows the three 'meanderpy' components: channel, cutoff, channel belt. These are implemented as classes; a 'Channel' and a 'Cutoff' are defined by their width, depth, and x,y,z centerline coordinates, and a 'ChannelBelt' is a collection of channels and cutoffs. In addition, the 'ChannelBelt' object also has a 'cl_times' and a 'cutoff_times' attribute that specify the age of the channels and the cutoffs. This age is relative to the start time of the simulation (= the first channel, age = 0.0).</p>\n<p>The initial Channel object can be created using the 'generate_initial_channel' function. This creates a straight line, with some noise added. However, a Channel can be created (and then used as the first channel in a ChannelBelt) using any set of x,y,z,W,D variables.</p>\n<pre><span class=\"n\">ch</span> <span class=\"o\">=</span> <span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">generate_initial_channel</span><span class=\"p\">(</span><span class=\"n\">W</span><span class=\"p\">,</span><span class=\"n\">D</span><span class=\"p\">,</span><span class=\"n\">Sl</span><span class=\"p\">,</span><span class=\"n\">deltas</span><span class=\"p\">,</span><span class=\"n\">pad</span><span class=\"p\">,</span><span class=\"n\">n_bends</span><span class=\"p\">)</span> <span class=\"c1\"># initialize channel</span>\n<span class=\"n\">chb</span> <span class=\"o\">=</span> <span class=\"n\">mp</span><span class=\"o\">.</span><span class=\"n\">ChannelBelt</span><span class=\"p\">(</span><span class=\"n\">channels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">ch</span><span class=\"p\">],</span><span class=\"n\">cutoffs</span><span class=\"o\">=</span><span class=\"p\">[],</span><span class=\"n\">cl_times</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">0.0</span><span class=\"p\">],</span><span class=\"n\">cutoff_times</span><span class=\"o\">=</span><span class=\"p\">[])</span> <span class=\"c1\"># create channel belt object</span>\n</pre>\n<p>A reasonable set of input parameters are as follows:</p>\n<pre><span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"mf\">200.0</span>                    <span class=\"c1\"># channel width (m)</span>\n<span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"mf\">16.0</span>                     <span class=\"c1\"># channel depth (m)</span>\n<span class=\"n\">pad</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>                    <span class=\"c1\"># padding (number of nodepoints along centerline)</span>\n<span class=\"n\">deltas</span> <span class=\"o\">=</span> <span class=\"mf\">50.0</span>                <span class=\"c1\"># sampling distance along centerline</span>\n<span class=\"n\">nit</span> <span class=\"o\">=</span> <span class=\"mi\">1500</span>                   <span class=\"c1\"># number of iterations</span>\n<span class=\"n\">Cf</span> <span class=\"o\">=</span> <span class=\"mf\">0.03</span>                    <span class=\"c1\"># dimensionless Chezy friction factor</span>\n<span class=\"n\">crdist</span> <span class=\"o\">=</span> <span class=\"n\">W</span>                   <span class=\"c1\"># threshold distance at which cutoffs occur</span>\n<span class=\"n\">kl</span> <span class=\"o\">=</span> <span class=\"mf\">60.0</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">365</span><span class=\"o\">*</span><span class=\"mi\">24</span><span class=\"o\">*</span><span class=\"mi\">60</span><span class=\"o\">*</span><span class=\"mf\">60.0</span><span class=\"p\">)</span>   <span class=\"c1\"># migration rate constant (m/s)</span>\n<span class=\"n\">kv</span> <span class=\"o\">=</span>  <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"mi\">10</span><span class=\"o\">*</span><span class=\"mf\">5.0E-13</span>           <span class=\"c1\"># vertical slope-dependent erosion rate constant (m/s)</span>\n<span class=\"n\">dt</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">365</span><span class=\"o\">*</span><span class=\"mi\">24</span><span class=\"o\">*</span><span class=\"mi\">60</span><span class=\"o\">*</span><span class=\"mf\">60.0</span><span class=\"p\">)</span>    <span class=\"c1\"># time step (s)</span>\n<span class=\"n\">dens</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span>                  <span class=\"c1\"># density of water (kg/m3)</span>\n<span class=\"n\">saved_ts</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>                <span class=\"c1\"># which time steps will be saved</span>\n<span class=\"n\">n_bends</span> <span class=\"o\">=</span> <span class=\"mi\">30</span>                 <span class=\"c1\"># approximate number of bends you want to model</span>\n<span class=\"n\">Sl</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>                     <span class=\"c1\"># initial slope (setting this to non-zero results in instabilities in long runs)</span>\n</pre>\n<p>The core functionality of 'meanderpy' is built into the 'migrate' method of the 'ChannelBelt' class. This is the function that computes migration rates and moves the channel centerline to its new position. The last Channel of a ChannelBelt can be further migrated through applying the 'migrate' method to the ChannelBelt instance.</p>\n<pre><span class=\"n\">chb</span><span class=\"o\">.</span><span class=\"n\">migrate</span><span class=\"p\">(</span><span class=\"n\">nit</span><span class=\"p\">,</span><span class=\"n\">saved_ts</span><span class=\"p\">,</span><span class=\"n\">deltas</span><span class=\"p\">,</span><span class=\"n\">pad</span><span class=\"p\">,</span><span class=\"n\">crdist</span><span class=\"p\">,</span><span class=\"n\">Cf</span><span class=\"p\">,</span><span class=\"n\">kl</span><span class=\"p\">,</span><span class=\"n\">kv</span><span class=\"p\">,</span><span class=\"n\">dt</span><span class=\"p\">,</span><span class=\"n\">dens</span><span class=\"p\">)</span> <span class=\"c1\"># channel migration</span>\n</pre>\n<p>ChannelBelt objects can be visualized using the 'plot' method. This creates a map of all the channels and cutoffs in the channel belt; there are two styles of plotting: a 'stratigraphic' view and a 'morphologic' view (see below). The morphologic view tries to account for the fact that older point bars and oxbow lakes tend to be gradually covered with vegetation.</p>\n<pre><span class=\"c1\"># migrate an additional 1000 iterations and plot results</span>\n<span class=\"n\">chb</span><span class=\"o\">.</span><span class=\"n\">migrate</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">,</span><span class=\"n\">saved_ts</span><span class=\"p\">,</span><span class=\"n\">deltas</span><span class=\"p\">,</span><span class=\"n\">pad</span><span class=\"p\">,</span><span class=\"n\">crdist</span><span class=\"p\">,</span><span class=\"n\">Cf</span><span class=\"p\">,</span><span class=\"n\">kl</span><span class=\"p\">,</span><span class=\"n\">kv</span><span class=\"p\">,</span><span class=\"n\">dt</span><span class=\"p\">,</span><span class=\"n\">dens</span><span class=\"p\">)</span>\n<span class=\"n\">fig</span> <span class=\"o\">=</span> <span class=\"n\">chb</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"s1\">'strat'</span><span class=\"p\">,</span><span class=\"mi\">20</span><span class=\"p\">,</span><span class=\"mi\">60</span><span class=\"p\">)</span>\n</pre>\n<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b3bc9c4aa6d9b13c13fe3c8fb2530be7896bb4b7/68747470733a2f2f6769746875622e636f6d2f7a73796c7665737465722f6d65616e64657270792f626c6f622f6d61737465722f6d65616e64657270795f73747261745f76735f6d6f7270682e706e67\" width=\"1000\">\n<p>A series of movie frames (in PNG format) can be created using the 'create_movie' method:</p>\n<pre><span class=\"n\">chb</span><span class=\"o\">.</span><span class=\"n\">create_movie</span><span class=\"p\">(</span><span class=\"n\">xmin</span><span class=\"p\">,</span><span class=\"n\">xmax</span><span class=\"p\">,</span><span class=\"n\">plot_type</span><span class=\"p\">,</span><span class=\"n\">filename</span><span class=\"p\">,</span><span class=\"n\">dirname</span><span class=\"p\">,</span><span class=\"n\">pb_age</span><span class=\"p\">,</span><span class=\"n\">ob_age</span><span class=\"p\">,</span><span class=\"n\">scale</span><span class=\"p\">,</span><span class=\"n\">end_time</span><span class=\"p\">)</span>\n</pre>\n<p>The frames have to be assembled into an animation outside of 'meanderpy'.</p>\n<h2>Build 3D model</h2>\n<p>'meanderpy' includes the functionality to build 3D stratigraphic models. However, this functionality is decoupled from the centerline generation, mainly because it would be computationally expensive to generate surfaces for all centerlines, along their whole lengths. Instead, the 3D model is only created after a Channelbelt object has been generated; a model domain is defined either through specifying the xmin, xmax, ymin, ymax coordinates, or through clicking the upper left and lower right corners of the domain, using the matplotlib 'ginput' command:</p>\n<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bd3f77194729be66cb4a4ac31abebc809365277d/68747470733a2f2f6769746875622e636f6d2f7a73796c7665737465722f6d65616e64657270792f626c6f622f6d61737465722f646566696e655f33445f646f6d61696e2e706e67\" width=\"600\">\n<p>Important parameters for a fluvial 3D model are the following:</p>\n<pre><span class=\"n\">Sl</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>              <span class=\"c1\"># initial slope (matters more for submarine channels than rivers)</span>\n<span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>              <span class=\"c1\"># time step when incision starts</span>\n<span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"mi\">700</span>              <span class=\"c1\"># time step when lateral migration starts</span>\n<span class=\"n\">t3</span> <span class=\"o\">=</span> <span class=\"mi\">1400</span>             <span class=\"c1\"># time step when aggradation starts</span>\n<span class=\"n\">aggr_factor</span> <span class=\"o\">=</span> <span class=\"mf\">4e-9</span>    <span class=\"c1\"># aggradation rate (in m/s, it kicks in after t3)</span>\n<span class=\"n\">h_mud</span> <span class=\"o\">=</span> <span class=\"mf\">0.4</span>           <span class=\"c1\"># thickness of overbank deposit for each time step</span>\n<span class=\"n\">dx</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span>             <span class=\"c1\"># gridcell size in meters</span>\n</pre>\n<p>The first five of these parameters have to be specified before creating the centerlines. The initial slope (Sl) in a fluvial model is best set to zero, as typical gradients in meandering rivers are very low and artifacts associated with the along-channel slope variation will be visible in the model surfaces [this is not an issue with steeper submarine channel models]. t1 is the time step when incision starts; before t1, the centerlines are given time to develop some sinuosity. At time t2, incision stops and the channel only migrates laterally until t3; this is the time when aggradation starts. The rate of incision (if Sl is set to zero) is set by the quantity 'kv x dens x 9.81 x D x dt x 0.01' (as if the slope was 0.01, but of course it is not), where kv is the vertical incision rate constant. This approach does not require a new incision rate constant. The rate of aggradation is set by 'aggr_factor x dt' (so 'aggr_factor' must be a small number, as it is measured in m/s). 'h_mud' is the maximum thickness of the overbank deposit in each time step, and 'dx' is the gridcell size in meters. 'h_mud' has to be large enough that it matches the channel aggradation rate; weird artefacts are generated otherwise.</p>\n<p>The Jupyter notebook has two examples for building 3D models, for a fluvial and a submarine channel system. The 'plot_xsection' method can be used to create a cross section at a given x (pixel) coordinate (this is the first argument of the function). The second argument determines the colors that are used for the different facies (in this case: brown, yellow, brown RGB values). The third argument is the vertical exaggeration.</p>\n<pre><span class=\"n\">fig1</span><span class=\"p\">,</span><span class=\"n\">fig2</span><span class=\"p\">,</span><span class=\"n\">fig3</span> <span class=\"o\">=</span> <span class=\"n\">chb_3d</span><span class=\"o\">.</span><span class=\"n\">plot_xsection</span><span class=\"p\">(</span><span class=\"mi\">343</span><span class=\"p\">,</span> <span class=\"p\">[[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span><span class=\"mf\">0.25</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],[</span><span class=\"mf\">0.9</span><span class=\"p\">,</span><span class=\"mf\">0.9</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span><span class=\"mf\">0.25</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]],</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n</pre>\n<p>This function also plots the basal erosional surface and the final topographic surface. An example topographic surface and a zoomed-in cross section are shown below.</p>\n<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/26dd3aa12bc37e0ff16ae043d7a811ca51ad0a15/68747470733a2f2f6769746875622e636f6d2f7a73796c7665737465722f6d65616e64657270792f626c6f622f6d61737465722f666c757669616c5f6d65616e64657270795f6578616d706c655f6d61702e706e67\" width=\"400\">\n<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fb8283d8899033cd8944dcbafc71d535a19f1d38/68747470733a2f2f6769746875622e636f6d2f7a73796c7665737465722f6d65616e64657270792f626c6f622f6d61737465722f666c757669616c5f6d65616e64657270795f6578616d706c655f73656374696f6e2e706e67\" width=\"900\">\n<h2>Related publications</h2>\n<p>If you use meanderpy in your work, please consider citing one or more of these publications:</p>\n<p>Sylvester, Z., Durkin, P., and Covault, J.A., 2019, High curvatures drive river meandering: Geology, v. 47, p. 263\u2013266, <a href=\"https://doi.org/10.1130/G45608.1\" rel=\"nofollow\">doi:10.1130/G45608.1</a>.</p>\n<p>Sylvester, Z., and Covault, J.A., 2016, Development of cutoff-related knickpoints during early evolution of submarine channels: Geology, v. 44, p. 835\u2013838, <a href=\"https://doi.org/10.1130/G38397.1\" rel=\"nofollow\">doi:10.1130/G38397.1</a>.</p>\n<p>Covault, J.A., Sylvester, Z., Hubbard, S.M., and Jobe, Z.R., 2016, The Stratigraphic Record of Submarine-Channel Evolution: The Sedimentary Record, v. 14, no. 3, p. 4-11, <a href=\"https://www.sepm.org/files/143article.hqx9r9brxux8f2se.pdf\" rel=\"nofollow\">doi:10.2210/sedred.2016.3</a>.</p>\n<p>Sylvester, Z., Pirmez, C., and Cantelli, A., 2011, A model of submarine channel-levee evolution based on channel trajectories: Implications for stratigraphic architecture: Marine and Petroleum Geology, v. 28, p. 716\u2013727, <a href=\"https://doi.org/10.1016/j.marpetgeo.2010.05.012\" rel=\"nofollow\">doi:10.1016/j.marpetgeo.2010.05.012</a>.</p>\n<h2>Acknowledgements</h2>\n<p>While the code in 'meanderpy' was written relatively recently, many of the ideas implemented in it come from numerous discussions with Carlos Pirmez, Alessandro Cantelli, Matt Wolinsky, Nick Howes, and Jake Covault. Funding for this work comes from the <a href=\"http://www.beg.utexas.edu/qcl\" rel=\"nofollow\">Quantitative Clastics Laboratory industrial consortium</a> at the Bureau of Economic Geology, The University of Texas at Austin.</p>\n<h2>License</h2>\n<p>meanderpy is licensed under the <a href=\"https://github.com/zsylvester/meanderpy/blob/master/LICENSE.txt\" rel=\"nofollow\">Apache License 2.0</a>.</p>\n\n          </div>"}, "last_serial": 5416972, "releases": {"0.1.5": [{"comment_text": "", "digests": {"md5": "ead87c4074f210b7bf307b8b2b38c23a", "sha256": "1565cae0e3541cd08707d259679f0ccf2ccfb31cc2222cc226ef73eafe7a8fc5"}, "downloads": -1, "filename": "meanderpy-0.1.5-py3-none-any.whl", "has_sig": false, "md5_digest": "ead87c4074f210b7bf307b8b2b38c23a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 30827, "upload_time": "2019-05-29T21:25:52", "upload_time_iso_8601": "2019-05-29T21:25:52.404471Z", "url": "https://files.pythonhosted.org/packages/a1/23/f6cd641b8fafe78c3652b0573d06df475a4b25de4bc6217e3fc595b3d1f4/meanderpy-0.1.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "12eebd69099e1844960ce501a4b178fe", "sha256": "8bf02101c097888932ee159a6bb867d9f37339adcdf5d9e2d882a816057a8f5f"}, "downloads": -1, "filename": "meanderpy-0.1.5.tar.gz", "has_sig": false, "md5_digest": "12eebd69099e1844960ce501a4b178fe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18849, "upload_time": "2019-05-29T21:25:54", "upload_time_iso_8601": "2019-05-29T21:25:54.349826Z", "url": "https://files.pythonhosted.org/packages/02/3e/e076fc420c2c799229467e3d9433a4068d5b045ceb748f899e1390b0a010/meanderpy-0.1.5.tar.gz", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "23e0fb84425b5db9250428da6092f5ae", "sha256": "a947d03b803b56969d5f4671bee3ff9ebb2d7214e2417c3fd9e24935529a6c98"}, "downloads": -1, "filename": "meanderpy-0.1.6-py3-none-any.whl", "has_sig": false, "md5_digest": "23e0fb84425b5db9250428da6092f5ae", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 33520, "upload_time": "2019-06-18T19:51:09", "upload_time_iso_8601": "2019-06-18T19:51:09.459776Z", "url": "https://files.pythonhosted.org/packages/7a/fb/3354d572463c5462367c9deee620ee5e3229e9faff916ed67f50beb17205/meanderpy-0.1.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d4c4d20835b05dbb5cb2179f59b9f7ba", "sha256": "f175af1e19d3fab907742a47b665102e815bcc5fa8efa2ea3d8c56dfdf10d4a6"}, "downloads": -1, "filename": "meanderpy-0.1.6.tar.gz", "has_sig": false, "md5_digest": "d4c4d20835b05dbb5cb2179f59b9f7ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20182, "upload_time": "2019-06-18T19:51:11", "upload_time_iso_8601": "2019-06-18T19:51:11.198798Z", "url": "https://files.pythonhosted.org/packages/85/d6/3f5b3254e858e34dba96351681d7cfd65bfcf8f4e32b8e1b3e17fb52ed07/meanderpy-0.1.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "23e0fb84425b5db9250428da6092f5ae", "sha256": "a947d03b803b56969d5f4671bee3ff9ebb2d7214e2417c3fd9e24935529a6c98"}, "downloads": -1, "filename": "meanderpy-0.1.6-py3-none-any.whl", "has_sig": false, "md5_digest": "23e0fb84425b5db9250428da6092f5ae", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 33520, "upload_time": "2019-06-18T19:51:09", "upload_time_iso_8601": "2019-06-18T19:51:09.459776Z", "url": "https://files.pythonhosted.org/packages/7a/fb/3354d572463c5462367c9deee620ee5e3229e9faff916ed67f50beb17205/meanderpy-0.1.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d4c4d20835b05dbb5cb2179f59b9f7ba", "sha256": "f175af1e19d3fab907742a47b665102e815bcc5fa8efa2ea3d8c56dfdf10d4a6"}, "downloads": -1, "filename": "meanderpy-0.1.6.tar.gz", "has_sig": false, "md5_digest": "d4c4d20835b05dbb5cb2179f59b9f7ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20182, "upload_time": "2019-06-18T19:51:11", "upload_time_iso_8601": "2019-06-18T19:51:11.198798Z", "url": "https://files.pythonhosted.org/packages/85/d6/3f5b3254e858e34dba96351681d7cfd65bfcf8f4e32b8e1b3e17fb52ed07/meanderpy-0.1.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:42 2020"}