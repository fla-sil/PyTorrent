{"info": {"author": "Taras Gaidukov", "author_email": "kemaweyan@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "singleton-decorator\n===================\n\nA testable singleton decorator allows easily create a singleton objects\njust adding a decorator to class definition but also allows easily write\nunit tests for those classes.\n\nA problem\n=========\n\nIf you use a simple singleton pattern based on a decorator function that\nwraps a class with inner wrapper function like this:\n\n.. code-block::\n\n    def singleton(cls):\n        instances = {}\n        def wrapper(*args, **kwargs):\n            if cls not in instances:\n              instances[cls] = cls(*args, **kwargs)\n            return instances[cls]\n        return wrapper\n\nit works fine with your classes, but it makes impossible a direct access\nto the class object without decorator. So you cannot call methods using\na class name in unit tests:\n\n.. code-block::\n\n    @singleton\n    class YourClass:\n        def method(self):\n            ...\n    YourClass.method(...)\n\nthis code would not work because ``YouClass`` actually contains a wrapper function\nbut not your class object. Also this approach causes another problem if your\ntests require separate instances of the objects, so a singleton pattern could\nbreak an isolation of different tests.\n\nSolution\n========\n\nThe **singleton-decorator** offers a simple solution to avoid both of these\nproblems. It uses a separate wrapper object for each decorated class and holds\na class within ``__wrapped__`` attribute so you can access the decorated class\ndirectly in your unit tests.\n\nInstallation\n============\n\nTo install the **singleton-decorator** just type in the command line:\n\n.. code-block::\n\n    $ pip install singleton-decorator\n\nUsage\n=====\n\nAt first import the singleton decorator:\n\n.. code-block::\n\n    from singleton_decorator import singleton\n\nThen decorate you classes with this decorator:\n\n.. code-block::\n\n    @singleton\n    class YourClass:\n        ...\n\nThat's all. Now you could create or get existing instance of your class by\ncalling it as a simple class object:\n\n.. code-block::\n\n    obj = YourClass()  # creates a new instance\n    obj2 = YourClass()  # returns the same instance\n    obj3 = YourClass()  # returns the same instance\n    ...\n\nYou also could pass args and kwargs into constructor of your class:\n\n.. code-block::\n\n    obj = YourClass(1, \"foo\", bar=\"baz\")\n\n.. NOTE::\n\n    Since the singleton pattern allows to create only one instance from\n    the class, an ``__init__`` method would be called once with args and\n    kwargs passed at the first call. Arguments of all future calls would\n    be completely ignored and would not impact the existing instance at all.\n\nUnit testing\n============\n\nIn your unit tests to run the methods of decorated classes in isolation\nwithout instantiation the object (to avoid running a constructor code),\nuse the ``__wrapped__`` attribute of the wrapper object:\n\n.. code-block::\n\n    # your_module.py\n    @singleton\n    class YourClass:\n        def your_method(self):\n            ...\n\n.. code-block::\n\n    # tests.py\n    class TestYourClass(TestCase):\n        def test_your_method(self):\n            obj = mock.MagicMock()\n            YourClass.__wrapped__.your_method(obj)\n            ...\n\nThis test runs a code of the ``your_method`` only using a mock object\nas the ``self`` argument, so the test would be run in complete isolation\nand would not depend on another pieces of your code including a constructor\nmethod.\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Kemaweyan/singleton_decorator", "keywords": "singleton decorator unittest", "license": "GPLv3", "maintainer": "", "maintainer_email": "", "name": "singleton-decorator", "package_url": "https://pypi.org/project/singleton-decorator/", "platform": "", "project_url": "https://pypi.org/project/singleton-decorator/", "project_urls": {"Homepage": "https://github.com/Kemaweyan/singleton_decorator"}, "release_url": "https://pypi.org/project/singleton-decorator/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "A testable singleton decorator", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"singleton-decorator\">\n<h2>singleton-decorator</h2>\n<p>A testable singleton decorator allows easily create a singleton objects\njust adding a decorator to class definition but also allows easily write\nunit tests for those classes.</p>\n</div>\n<div id=\"a-problem\">\n<h2>A problem</h2>\n<p>If you use a simple singleton pattern based on a decorator function that\nwraps a class with inner wrapper function like this:</p>\n<pre>def singleton(cls):\n    instances = {}\n    def wrapper(*args, **kwargs):\n        if cls not in instances:\n          instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return wrapper\n</pre>\n<p>it works fine with your classes, but it makes impossible a direct access\nto the class object without decorator. So you cannot call methods using\na class name in unit tests:</p>\n<pre>@singleton\nclass YourClass:\n    def method(self):\n        ...\nYourClass.method(...)\n</pre>\n<p>this code would not work because <tt>YouClass</tt> actually contains a wrapper function\nbut not your class object. Also this approach causes another problem if your\ntests require separate instances of the objects, so a singleton pattern could\nbreak an isolation of different tests.</p>\n</div>\n<div id=\"solution\">\n<h2>Solution</h2>\n<p>The <strong>singleton-decorator</strong> offers a simple solution to avoid both of these\nproblems. It uses a separate wrapper object for each decorated class and holds\na class within <tt>__wrapped__</tt> attribute so you can access the decorated class\ndirectly in your unit tests.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>To install the <strong>singleton-decorator</strong> just type in the command line:</p>\n<pre>$ pip install singleton-decorator\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>At first import the singleton decorator:</p>\n<pre>from singleton_decorator import singleton\n</pre>\n<p>Then decorate you classes with this decorator:</p>\n<pre>@singleton\nclass YourClass:\n    ...\n</pre>\n<p>That\u2019s all. Now you could create or get existing instance of your class by\ncalling it as a simple class object:</p>\n<pre>obj = YourClass()  # creates a new instance\nobj2 = YourClass()  # returns the same instance\nobj3 = YourClass()  # returns the same instance\n...\n</pre>\n<p>You also could pass args and kwargs into constructor of your class:</p>\n<pre>obj = YourClass(1, \"foo\", bar=\"baz\")\n</pre>\n<div>\n<p>Note</p>\n<p>Since the singleton pattern allows to create only one instance from\nthe class, an <tt>__init__</tt> method would be called once with args and\nkwargs passed at the first call. Arguments of all future calls would\nbe completely ignored and would not impact the existing instance at all.</p>\n</div>\n</div>\n<div id=\"unit-testing\">\n<h2>Unit testing</h2>\n<p>In your unit tests to run the methods of decorated classes in isolation\nwithout instantiation the object (to avoid running a constructor code),\nuse the <tt>__wrapped__</tt> attribute of the wrapper object:</p>\n<pre># your_module.py\n@singleton\nclass YourClass:\n    def your_method(self):\n        ...\n</pre>\n<pre># tests.py\nclass TestYourClass(TestCase):\n    def test_your_method(self):\n        obj = mock.MagicMock()\n        YourClass.__wrapped__.your_method(obj)\n        ...\n</pre>\n<p>This test runs a code of the <tt>your_method</tt> only using a mock object\nas the <tt>self</tt> argument, so the test would be run in complete isolation\nand would not depend on another pieces of your code including a constructor\nmethod.</p>\n</div>\n\n          </div>"}, "last_serial": 3087969, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "9b0011c7d33a671bc02b58362ef3dc18", "sha256": "1a90ad8a8a738be591c9c167fdd677c5d4a43d1bc6b1c128227be1c5e03bee07"}, "downloads": -1, "filename": "singleton-decorator-1.0.0.tar.gz", "has_sig": false, "md5_digest": "9b0011c7d33a671bc02b58362ef3dc18", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2791, "upload_time": "2017-08-10T19:52:45", "upload_time_iso_8601": "2017-08-10T19:52:45.903156Z", "url": "https://files.pythonhosted.org/packages/33/98/a8b5c919bee1152a9a1afd82014431f8db5882699754de50d1b3aba4d136/singleton-decorator-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9b0011c7d33a671bc02b58362ef3dc18", "sha256": "1a90ad8a8a738be591c9c167fdd677c5d4a43d1bc6b1c128227be1c5e03bee07"}, "downloads": -1, "filename": "singleton-decorator-1.0.0.tar.gz", "has_sig": false, "md5_digest": "9b0011c7d33a671bc02b58362ef3dc18", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2791, "upload_time": "2017-08-10T19:52:45", "upload_time_iso_8601": "2017-08-10T19:52:45.903156Z", "url": "https://files.pythonhosted.org/packages/33/98/a8b5c919bee1152a9a1afd82014431f8db5882699754de50d1b3aba4d136/singleton-decorator-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:09:30 2020"}