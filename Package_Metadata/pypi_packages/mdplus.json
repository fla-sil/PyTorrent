{"info": {"author": "The University of Nottingham & BSC", "author_email": "charles.laughton@nottingham.ac.uk", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX", "Operating System :: Unix", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering"], "description": "# MDPlus: Python tools for molecular modelling. #\n\n## Introduction\n\n*MDPlus* brings together a number of tools related to the setup and analysis of molecular simulations:\n\n* PCA - the Principal Component Analysis library as used by [pyPcazip](https://claughton.bitbucket.io/pypcazip.html).\n  \n* GLIMPS - a machine learning method for backmapping coarse-grained structures to finer-grained ones.\n\n* REFINE - a constraints-based approach to the refinement of approximate molecular models.\n\n----------\n\n## Installation:\n\nEasiest via pip:\n```\npip install mdplus\n```\n\n---------------\n\n## Getting started:\n\n\n### API overview\n\nFor maximum compatibility with other Python-based MD simulation processing packages, All tools operate on simple arrays of coordinate data (typically [n_frames, n_atoms, 3] `numpy` arrays).\n\nAll tools have a similar API, modelled on the *transformer* object approach that used by many of the utilities in `scipy` and `scikit-learn`. \n\n### PCA\n\nAn instance of a PCA transformer is fit to an ensemble of structures, to obtain the eigenvectors, eigenvalues and mean. This trained transformer can then be used to transform further coordinate sets of the same system into the PCA space, and vice-versa:\n\n```\nfrom mdplus.pca import PCA\n\npca_transformer = PCA()\npca_transformer.fit(traj) # traj should be an [n_frames, n_atoms, 3] numpy array\nscores = pca_transformer.transform(traj) # scores will be an [n_frames, n_components] numpy array\nreconstituted_traj = pca_transformer.inverse_transform(scores)\n```\n\n### GLIMPS\n\nWhile tools to transform high-resolution models to lower resolution ones (e.g. atomistic to coarse-grained) are relatively available and/or easy to implement, the reverse - \"back-mapping\" - is typically much harder. Given a training set of high-resolution structures and their low-resolution counterparts obtained by application of a forward-mapping tool, GLIMPS learns the reverse transform from the low resolution dataset to the higher resolution one, and once trained can back-map further low-resolution models. \n\n```\nfrom mdplus.multiscale import GLIMPS\n\nbackmapper = GLIMPS()\nbackmapper.fit(cg_training_traj, fg_training_traj) # matched pairs of low and high resolution structures\nfg_structure = backmapper.transform(cg_structure)\n```\n\n### REFINE\n\nREFINE implements *SHAKE*-type constraints based refinement of approximate molecular structures. It can be a useful post-processor for structures obtained from PCA inverse transforms or from GLIMPS. REFINE learns the set of constraints from a training set of \"good\" molecular structures, and can then refine further approximate structures:\n\n```\nfrom mdplus.refinement import REFINE\n\nrefiner = REFINE()\nrefiner.fit(training_traj) # A diverse collection of good-quality structures\nrefined_traj = refiner.transform(crude_traj)\n```\n\n-----------------\n\n## Who do I talk to?\n\n* charles.laughton@nottingham.ac.uk\n\n\n\n```python\n\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://bitbucket.org/claughton/mdplus/get/0.0.2.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/claughton/mdplus/overview", "keywords": "", "license": "BSD license.", "maintainer": "", "maintainer_email": "", "name": "mdplus", "package_url": "https://pypi.org/project/mdplus/", "platform": "", "project_url": "https://pypi.org/project/mdplus/", "project_urls": {"Download": "https://bitbucket.org/claughton/mdplus/get/0.0.2.tar.gz", "Homepage": "https://bitbucket.org/claughton/mdplus/overview"}, "release_url": "https://pypi.org/project/mdplus/0.0.2/", "requires_dist": null, "requires_python": "", "summary": "Tools for molecular dynamics simulation setup and analysis.", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>MDPlus: Python tools for molecular modelling.</h1>\n<h2>Introduction</h2>\n<p><em>MDPlus</em> brings together a number of tools related to the setup and analysis of molecular simulations:</p>\n<ul>\n<li>\n<p>PCA - the Principal Component Analysis library as used by <a href=\"https://claughton.bitbucket.io/pypcazip.html\" rel=\"nofollow\">pyPcazip</a>.</p>\n</li>\n<li>\n<p>GLIMPS - a machine learning method for backmapping coarse-grained structures to finer-grained ones.</p>\n</li>\n<li>\n<p>REFINE - a constraints-based approach to the refinement of approximate molecular models.</p>\n</li>\n</ul>\n<hr>\n<h2>Installation:</h2>\n<p>Easiest via pip:</p>\n<pre><code>pip install mdplus\n</code></pre>\n<hr>\n<h2>Getting started:</h2>\n<h3>API overview</h3>\n<p>For maximum compatibility with other Python-based MD simulation processing packages, All tools operate on simple arrays of coordinate data (typically [n_frames, n_atoms, 3] <code>numpy</code> arrays).</p>\n<p>All tools have a similar API, modelled on the <em>transformer</em> object approach that used by many of the utilities in <code>scipy</code> and <code>scikit-learn</code>.</p>\n<h3>PCA</h3>\n<p>An instance of a PCA transformer is fit to an ensemble of structures, to obtain the eigenvectors, eigenvalues and mean. This trained transformer can then be used to transform further coordinate sets of the same system into the PCA space, and vice-versa:</p>\n<pre><code>from mdplus.pca import PCA\n\npca_transformer = PCA()\npca_transformer.fit(traj) # traj should be an [n_frames, n_atoms, 3] numpy array\nscores = pca_transformer.transform(traj) # scores will be an [n_frames, n_components] numpy array\nreconstituted_traj = pca_transformer.inverse_transform(scores)\n</code></pre>\n<h3>GLIMPS</h3>\n<p>While tools to transform high-resolution models to lower resolution ones (e.g. atomistic to coarse-grained) are relatively available and/or easy to implement, the reverse - \"back-mapping\" - is typically much harder. Given a training set of high-resolution structures and their low-resolution counterparts obtained by application of a forward-mapping tool, GLIMPS learns the reverse transform from the low resolution dataset to the higher resolution one, and once trained can back-map further low-resolution models.</p>\n<pre><code>from mdplus.multiscale import GLIMPS\n\nbackmapper = GLIMPS()\nbackmapper.fit(cg_training_traj, fg_training_traj) # matched pairs of low and high resolution structures\nfg_structure = backmapper.transform(cg_structure)\n</code></pre>\n<h3>REFINE</h3>\n<p>REFINE implements <em>SHAKE</em>-type constraints based refinement of approximate molecular structures. It can be a useful post-processor for structures obtained from PCA inverse transforms or from GLIMPS. REFINE learns the set of constraints from a training set of \"good\" molecular structures, and can then refine further approximate structures:</p>\n<pre><code>from mdplus.refinement import REFINE\n\nrefiner = REFINE()\nrefiner.fit(training_traj) # A diverse collection of good-quality structures\nrefined_traj = refiner.transform(crude_traj)\n</code></pre>\n<hr>\n<h2>Who do I talk to?</h2>\n<ul>\n<li><a href=\"mailto:charles.laughton@nottingham.ac.uk\">charles.laughton@nottingham.ac.uk</a></li>\n</ul>\n<pre></pre>\n\n          </div>"}, "last_serial": 7059041, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "fc8f91578bee2f5d574b1813b9afaaf2", "sha256": "8df1ef4e61e775591068b9eade4cb895fe7c4efb28ac099939f1129e9493352a"}, "downloads": -1, "filename": "mdplus-0.0.2.tar.gz", "has_sig": false, "md5_digest": "fc8f91578bee2f5d574b1813b9afaaf2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 115067, "upload_time": "2020-04-20T10:19:22", "upload_time_iso_8601": "2020-04-20T10:19:22.054311Z", "url": "https://files.pythonhosted.org/packages/a2/ca/29dbcc628c41dc4ba82f68aeaf75392bea8d48878625c5c6f3fb8ad30f6f/mdplus-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fc8f91578bee2f5d574b1813b9afaaf2", "sha256": "8df1ef4e61e775591068b9eade4cb895fe7c4efb28ac099939f1129e9493352a"}, "downloads": -1, "filename": "mdplus-0.0.2.tar.gz", "has_sig": false, "md5_digest": "fc8f91578bee2f5d574b1813b9afaaf2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 115067, "upload_time": "2020-04-20T10:19:22", "upload_time_iso_8601": "2020-04-20T10:19:22.054311Z", "url": "https://files.pythonhosted.org/packages/a2/ca/29dbcc628c41dc4ba82f68aeaf75392bea8d48878625c5c6f3fb8ad30f6f/mdplus-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:48 2020"}