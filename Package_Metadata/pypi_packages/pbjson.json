{"info": {"author": "Scott Maxwell", "author_email": "scott@codecobblers.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Academic Free License (AFL)", "License :: OSI Approved :: MIT License", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "pbjson\n======\n\nPacked Binary JSON extension for Python\n\n``pbjson`` is a packed binary JSON encoder and decoder for Python 2.5+\nand Python 3.3+. It is pure Python code with no dependencies, but\nincludes an optional C extension for a serious speed boost.\n\n``pbjson`` can be used standalone or as an extension to the standard\n``json`` module or to ``simplejson``, from which code was heavily\nborrowed. The latest documentation for ``simplejson`` can be read online\nhere: http://simplejson.readthedocs.org/\n\nThe encoder can be specialized to provide serialization in any kind of\nsituation, without any special support by the objects to be serialized\n(somewhat like pickle). This is best done with the ``default`` kwarg to\ndumps.\n\nThe decoder can handle incoming JSON strings of any specified encoding\n(UTF-8 by default). It can also be specialized to post-process JSON\nobjects with the ``object_hook`` or ``object_pairs_hook`` kwargs. This\nis particularly useful for implementing protocols that have a richer\ntype system than JSON itself.\n\nWhat is Packed Binary JSON (``PBJSON``)\n---------------------------------------\n\nPacked Binary JSON is not the same as ``BSON``. ``BSON`` is a format\nused primarily in MongoDB and is meant for efficient parsing. ``PBJSON``\nis meant for efficient conversion from a dict or list, transmission and\nconversion back to a dict or list on the other end. ``BSON`` has\nexplicit support for several types not available in standard JSON.\nPBJSON supports only those types supported by normal JSON, plus binary\ndata blobs and set collections.\n\nUnlike ``BSON``, ``PBJSON`` is almost always smaller than the equivalent\nJSON. Like ``BSON``, ``PBJSON`` can be very quickly encoded and decoded\nsince all elements are length encoded.\n\nThere are two types of tokens in ``PBJSON``: data and key. Data tokens\ncan be zero length fundamental types (``false``, ``true``, ``null``),\nvariable length fundamental types (``int``, ``float``, ``string``,\n``binary``) or containers (``set``, ``array``, ``dict``).\n\nThe type for the data token is generally stored in the top 3 bits (bits\n5-7). Type zero is a special type to represent the zero length\nfundamental types. The lower bits indicate the actual value. These are:\n\nZero-length Data Types:\n\n-  00 - false\n-  01 - true\n-  02 - null\n\nAll other types are variable length. If the length is between 0 and 15,\nthat length is stored in bits 0-3. For lengths in the 16-2047 range, bit\n4 is set and bits 0-2 are combined with the next byte to make an 11-bit\nlength. If bits 4 and 3 are both set, then the value in bits 0-2 are\ncombined with the next 2 bytes to create a 19-bit length. However, if\nbits 4-0 are all set, this indicates that the following 4 bytes are\nsimply used as a size. So the token plus length is, one byte (length of\n0-15), two bytes (16-2047), three bytes (2048-458751) or five bytes\n(458876-4294967295).\n\nVariable-length Data types:\n\n-  2x - int (bytes stored big endian with leading zero bytes removed)\n-  4x - negative int (bytes stored big endian as a positive number with\n   leading zero bytes removed)\n-  6x - float (stored as big endian double precision with trailing zero\n   bytes removed)\n-  8x - string\n-  Ax - binary\n\nCollection types: (length is number of elements)\n\n-  Cx - array\n-  Ex - object\n-  0C - terminated array\n-  0F - terminator\n\nThe final entry, the \"terminated array\" works a bit differently. This is\nfor use when the length is not known when writing begins. Instead, a\nterminator (0F) is written to the stream when the last element of the\narray has been written.\n\nObject keys must be text and are a maximum of 127 bytes in length. They\nare stored as a (7-bit length, followed by the actual key. The first 128\nkeys are remembered by index. If the same key is used again, it can be\nrepresented as a single byte consisting of the high bit and the index\nnumber of the key.\n\nIn other words, if the recurring key is \"toast\", it should be encoded as\n05 toast. The next time the key \"toast\" is needed, it can be encoded as\nsimply 80, since it was the first key.\n\nHere is an example of a simple structure:\n\n.. code:: javascript\n\n   {\n       \"toast\": true,\n       \"burned\": false,\n       \"name\": \"the best\",\n       \"toppings\": [\"jelly\",\"jam\",\"butter\"],\n       \"dimensions\": {\n           \"thickness\": 0.7,\n           \"width\": 4.5\n       }\n   }\n\n::\n\n   E5 05 'toast' 01 06 'burned' 00 04 'name' 88 'the best'\n   08 'toppings' C3 85 'jelly' 83 'jam' 86 'butter'\n   0A 'dimensions' E2 09 'thickness' 68 3FE6666666666666 05 'width' 62 4012\n\nLet\u2019s break that out:\n\n-  00: E5 - dict with 5 elements\n-  01: 05 - key with 5 characters\n-  02-06: toast\n-  07: 01 - true\n-  08: 06 - key with 6 characters\n-  09-0E: burned\n-  0F: 00 - false\n-  10: 04 - key with 4 characters\n-  11-14: name\n-  15: 88 - string with 8 characters\n-  16-1D: the best\n-  1E: 08 - key with 8 bytes\n-  1F-26: toppings\n-  27: C3 - array with 3 elements\n-  28: 85 - string with 5 characters\n-  29-2D: jelly\n-  2E: 83 - string with 3 characters\n-  2F-31: jam\n-  32: 86 - string with 6 characters\n-  33-38: butter\n-  39: 0A - key with 10 bytes\n-  3A-43: dimensions\n-  44: E3 - dict with 2 elements\n-  45: 09 - key with 9 characters\n-  46-4E: thickness\n-  4F: 68 - float with 8 bytes\n-  50-57: IEEE representation of .7\n-  58: 05 - key with 5 characters\n-  59-5D: width\n-  5E: 62 - float with 2 bytes\n-  5F-60: first 2 bytes of IEEE representation of 4.5. Remaining 6 bytes\n   were all zeros.\n\nTotal 97 bytes. The tightest ``JSON`` representation requires 126 bytes.\nMarshal takes 153 bytes. Pickle takes 184 bytes. BSON takes 145 bytes.\n\nNow here is an example with repeating data:\n\n.. code:: javascript\n\n   {\n       \"region\": 3,\n       \"countries\": [\n           {\"code\": \"us\", \"name\": \"United States\"},\n           {\"code\": \"ca\", \"name\": \"Canada\"},\n           {\"code\": \"mx\", \"name\": \"Mexico\"}\n       ]\n   }\n\n::\n\n   E2 06 region 21 03 09 countries C3\n   E2 04 code 82 us 04 name 8D United States\n   E2 82 82 ca 83 86 Canada\n   E2 82 82 mx 83 86 Mexico\n\nThis breaks down thus:\n\n-  00: E2 - dict with 2 elements\n-  01: 06 - key with 6 characters\n-  02-07: region\n-  08: 21 - int with 1 byte\n-  09: 03 - the int for 3. Only a single byte is required.\n-  0A: 09 - key with 9 bytes\n-  0B-13: countries\n-  14: C3 - array with 3 elements\n-  15: E2 - dict with 2 elements\n-  16: 04 - key with 4 characters\n-  17-1A: code\n-  19: 82 - string with 2 characters\n-  1A-1B: us\n-  1C: 04 - key with 4 characters\n-  1E-21: name\n-  22: 8D - string with 13 characters\n-  23-2F: United States\n-  30: E2 - dict with 2 elements\n-  31: 82 - recurring key 2. Since \u2018code\u2019 was the 3rd key, it has an\n   index of 2.\n-  32: 82 - string with 2 characters\n-  33-34: ca\n-  35: 83 - recurring key 3\n-  36: 86 - string with 6 characters\n-  37-3C: Canada\n-  3D: E2 - dict with 2 elements\n-  3E: 82 - recurring key 0\n-  3F: 82 - string with 2 characters\n-  40-41: mx\n-  42: 83 - recurring key 1\n-  43: 86 - string with 6 characters\n-  44-49: Mexico\n\nTotal 74 bytes. The tightest ``JSON`` representation requires 123 bytes.\nMarshal takes 158 bytes and Pickle takes 162. BSON takes 154 bytes.\n\n``Packed Binary JSON`` is available now in the ``pbjson`` Python module.\nThat module includes a command line utility to convert between normal\n``JSON`` files and ``PBJSON``.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/scottkmaxwell/pbjson", "keywords": "", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "pbjson", "package_url": "https://pypi.org/project/pbjson/", "platform": "any", "project_url": "https://pypi.org/project/pbjson/", "project_urls": {"Homepage": "https://github.com/scottkmaxwell/pbjson"}, "release_url": "https://pypi.org/project/pbjson/1.15/", "requires_dist": null, "requires_python": "", "summary": "Packed Binary JSON encoder/decoder for Python", "version": "1.15", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Packed Binary JSON extension for Python</p>\n<p><tt>pbjson</tt> is a packed binary JSON encoder and decoder for Python 2.5+\nand Python 3.3+. It is pure Python code with no dependencies, but\nincludes an optional C extension for a serious speed boost.</p>\n<p><tt>pbjson</tt> can be used standalone or as an extension to the standard\n<tt>json</tt> module or to <tt>simplejson</tt>, from which code was heavily\nborrowed. The latest documentation for <tt>simplejson</tt> can be read online\nhere: <a href=\"http://simplejson.readthedocs.org/\" rel=\"nofollow\">http://simplejson.readthedocs.org/</a></p>\n<p>The encoder can be specialized to provide serialization in any kind of\nsituation, without any special support by the objects to be serialized\n(somewhat like pickle). This is best done with the <tt>default</tt> kwarg to\ndumps.</p>\n<p>The decoder can handle incoming JSON strings of any specified encoding\n(UTF-8 by default). It can also be specialized to post-process JSON\nobjects with the <tt>object_hook</tt> or <tt>object_pairs_hook</tt> kwargs. This\nis particularly useful for implementing protocols that have a richer\ntype system than JSON itself.</p>\n<div id=\"what-is-packed-binary-json-pbjson\">\n<h2>What is Packed Binary JSON (<tt>PBJSON</tt>)</h2>\n<p>Packed Binary JSON is not the same as <tt>BSON</tt>. <tt>BSON</tt> is a format\nused primarily in MongoDB and is meant for efficient parsing. <tt>PBJSON</tt>\nis meant for efficient conversion from a dict or list, transmission and\nconversion back to a dict or list on the other end. <tt>BSON</tt> has\nexplicit support for several types not available in standard JSON.\nPBJSON supports only those types supported by normal JSON, plus binary\ndata blobs and set collections.</p>\n<p>Unlike <tt>BSON</tt>, <tt>PBJSON</tt> is almost always smaller than the equivalent\nJSON. Like <tt>BSON</tt>, <tt>PBJSON</tt> can be very quickly encoded and decoded\nsince all elements are length encoded.</p>\n<p>There are two types of tokens in <tt>PBJSON</tt>: data and key. Data tokens\ncan be zero length fundamental types (<tt>false</tt>, <tt>true</tt>, <tt>null</tt>),\nvariable length fundamental types (<tt>int</tt>, <tt>float</tt>, <tt>string</tt>,\n<tt>binary</tt>) or containers (<tt>set</tt>, <tt>array</tt>, <tt>dict</tt>).</p>\n<p>The type for the data token is generally stored in the top 3 bits (bits\n5-7). Type zero is a special type to represent the zero length\nfundamental types. The lower bits indicate the actual value. These are:</p>\n<p>Zero-length Data Types:</p>\n<ul>\n<li>00 - false</li>\n<li>01 - true</li>\n<li>02 - null</li>\n</ul>\n<p>All other types are variable length. If the length is between 0 and 15,\nthat length is stored in bits 0-3. For lengths in the 16-2047 range, bit\n4 is set and bits 0-2 are combined with the next byte to make an 11-bit\nlength. If bits 4 and 3 are both set, then the value in bits 0-2 are\ncombined with the next 2 bytes to create a 19-bit length. However, if\nbits 4-0 are all set, this indicates that the following 4 bytes are\nsimply used as a size. So the token plus length is, one byte (length of\n0-15), two bytes (16-2047), three bytes (2048-458751) or five bytes\n(458876-4294967295).</p>\n<p>Variable-length Data types:</p>\n<ul>\n<li>2x - int (bytes stored big endian with leading zero bytes removed)</li>\n<li>4x - negative int (bytes stored big endian as a positive number with\nleading zero bytes removed)</li>\n<li>6x - float (stored as big endian double precision with trailing zero\nbytes removed)</li>\n<li>8x - string</li>\n<li>Ax - binary</li>\n</ul>\n<p>Collection types: (length is number of elements)</p>\n<ul>\n<li>Cx - array</li>\n<li>Ex - object</li>\n<li>0C - terminated array</li>\n<li>0F - terminator</li>\n</ul>\n<p>The final entry, the \u201cterminated array\u201d works a bit differently. This is\nfor use when the length is not known when writing begins. Instead, a\nterminator (0F) is written to the stream when the last element of the\narray has been written.</p>\n<p>Object keys must be text and are a maximum of 127 bytes in length. They\nare stored as a (7-bit length, followed by the actual key. The first 128\nkeys are remembered by index. If the same key is used again, it can be\nrepresented as a single byte consisting of the high bit and the index\nnumber of the key.</p>\n<p>In other words, if the recurring key is \u201ctoast\u201d, it should be encoded as\n05 toast. The next time the key \u201ctoast\u201d is needed, it can be encoded as\nsimply 80, since it was the first key.</p>\n<p>Here is an example of a simple structure:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"s2\">\"toast\"</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"burned\"</span><span class=\"o\">:</span> <span class=\"kc\">false</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"name\"</span><span class=\"o\">:</span> <span class=\"s2\">\"the best\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"toppings\"</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"jelly\"</span><span class=\"p\">,</span><span class=\"s2\">\"jam\"</span><span class=\"p\">,</span><span class=\"s2\">\"butter\"</span><span class=\"p\">],</span>\n    <span class=\"s2\">\"dimensions\"</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"s2\">\"thickness\"</span><span class=\"o\">:</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span>\n        <span class=\"s2\">\"width\"</span><span class=\"o\">:</span> <span class=\"mf\">4.5</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<pre>E5 05 'toast' 01 06 'burned' 00 04 'name' 88 'the best'\n08 'toppings' C3 85 'jelly' 83 'jam' 86 'butter'\n0A 'dimensions' E2 09 'thickness' 68 3FE6666666666666 05 'width' 62 4012\n</pre>\n<p>Let\u2019s break that out:</p>\n<ul>\n<li>00: E5 - dict with 5 elements</li>\n<li>01: 05 - key with 5 characters</li>\n<li>02-06: toast</li>\n<li>07: 01 - true</li>\n<li>08: 06 - key with 6 characters</li>\n<li>09-0E: burned</li>\n<li>0F: 00 - false</li>\n<li>10: 04 - key with 4 characters</li>\n<li>11-14: name</li>\n<li>15: 88 - string with 8 characters</li>\n<li>16-1D: the best</li>\n<li>1E: 08 - key with 8 bytes</li>\n<li>1F-26: toppings</li>\n<li>27: C3 - array with 3 elements</li>\n<li>28: 85 - string with 5 characters</li>\n<li>29-2D: jelly</li>\n<li>2E: 83 - string with 3 characters</li>\n<li>2F-31: jam</li>\n<li>32: 86 - string with 6 characters</li>\n<li>33-38: butter</li>\n<li>39: 0A - key with 10 bytes</li>\n<li>3A-43: dimensions</li>\n<li>44: E3 - dict with 2 elements</li>\n<li>45: 09 - key with 9 characters</li>\n<li>46-4E: thickness</li>\n<li>4F: 68 - float with 8 bytes</li>\n<li>50-57: IEEE representation of .7</li>\n<li>58: 05 - key with 5 characters</li>\n<li>59-5D: width</li>\n<li>5E: 62 - float with 2 bytes</li>\n<li>5F-60: first 2 bytes of IEEE representation of 4.5. Remaining 6 bytes\nwere all zeros.</li>\n</ul>\n<p>Total 97 bytes. The tightest <tt>JSON</tt> representation requires 126 bytes.\nMarshal takes 153 bytes. Pickle takes 184 bytes. BSON takes 145 bytes.</p>\n<p>Now here is an example with repeating data:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"s2\">\"region\"</span><span class=\"o\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"countries\"</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span><span class=\"s2\">\"code\"</span><span class=\"o\">:</span> <span class=\"s2\">\"us\"</span><span class=\"p\">,</span> <span class=\"s2\">\"name\"</span><span class=\"o\">:</span> <span class=\"s2\">\"United States\"</span><span class=\"p\">},</span>\n        <span class=\"p\">{</span><span class=\"s2\">\"code\"</span><span class=\"o\">:</span> <span class=\"s2\">\"ca\"</span><span class=\"p\">,</span> <span class=\"s2\">\"name\"</span><span class=\"o\">:</span> <span class=\"s2\">\"Canada\"</span><span class=\"p\">},</span>\n        <span class=\"p\">{</span><span class=\"s2\">\"code\"</span><span class=\"o\">:</span> <span class=\"s2\">\"mx\"</span><span class=\"p\">,</span> <span class=\"s2\">\"name\"</span><span class=\"o\">:</span> <span class=\"s2\">\"Mexico\"</span><span class=\"p\">}</span>\n    <span class=\"p\">]</span>\n<span class=\"p\">}</span>\n</pre>\n<pre>E2 06 region 21 03 09 countries C3\nE2 04 code 82 us 04 name 8D United States\nE2 82 82 ca 83 86 Canada\nE2 82 82 mx 83 86 Mexico\n</pre>\n<p>This breaks down thus:</p>\n<ul>\n<li>00: E2 - dict with 2 elements</li>\n<li>01: 06 - key with 6 characters</li>\n<li>02-07: region</li>\n<li>08: 21 - int with 1 byte</li>\n<li>09: 03 - the int for 3. Only a single byte is required.</li>\n<li>0A: 09 - key with 9 bytes</li>\n<li>0B-13: countries</li>\n<li>14: C3 - array with 3 elements</li>\n<li>15: E2 - dict with 2 elements</li>\n<li>16: 04 - key with 4 characters</li>\n<li>17-1A: code</li>\n<li>19: 82 - string with 2 characters</li>\n<li>1A-1B: us</li>\n<li>1C: 04 - key with 4 characters</li>\n<li>1E-21: name</li>\n<li>22: 8D - string with 13 characters</li>\n<li>23-2F: United States</li>\n<li>30: E2 - dict with 2 elements</li>\n<li>31: 82 - recurring key 2. Since \u2018code\u2019 was the 3rd key, it has an\nindex of 2.</li>\n<li>32: 82 - string with 2 characters</li>\n<li>33-34: ca</li>\n<li>35: 83 - recurring key 3</li>\n<li>36: 86 - string with 6 characters</li>\n<li>37-3C: Canada</li>\n<li>3D: E2 - dict with 2 elements</li>\n<li>3E: 82 - recurring key 0</li>\n<li>3F: 82 - string with 2 characters</li>\n<li>40-41: mx</li>\n<li>42: 83 - recurring key 1</li>\n<li>43: 86 - string with 6 characters</li>\n<li>44-49: Mexico</li>\n</ul>\n<p>Total 74 bytes. The tightest <tt>JSON</tt> representation requires 123 bytes.\nMarshal takes 158 bytes and Pickle takes 162. BSON takes 154 bytes.</p>\n<p><tt>Packed Binary JSON</tt> is available now in the <tt>pbjson</tt> Python module.\nThat module includes a command line utility to convert between normal\n<tt>JSON</tt> files and <tt>PBJSON</tt>.</p>\n</div>\n\n          </div>"}, "last_serial": 5204703, "releases": {"1.12": [{"comment_text": "", "digests": {"md5": "e4934642f846e48bcf668e709d5d193d", "sha256": "de636888b677ad4fa075ca907c94bf5b9825458ea2e769ea2d7bfc187e84e71f"}, "downloads": -1, "filename": "pbjson-1.12.tar.gz", "has_sig": false, "md5_digest": "e4934642f846e48bcf668e709d5d193d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38122, "upload_time": "2019-04-29T17:11:52", "upload_time_iso_8601": "2019-04-29T17:11:52.095076Z", "url": "https://files.pythonhosted.org/packages/d9/3b/3e2e103472c5ba57b7c694461bb3066c4230ab1d4ae90816472b32e03e31/pbjson-1.12.tar.gz", "yanked": false}], "1.13": [{"comment_text": "", "digests": {"md5": "a3aed4c30ede2a139e67173d57253000", "sha256": "c8b163f9cd2662dc40d55c64ee48753128ec97ab8c56c46718ba8cbcfa4dae95"}, "downloads": -1, "filename": "pbjson-1.13.tar.gz", "has_sig": false, "md5_digest": "a3aed4c30ede2a139e67173d57253000", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39556, "upload_time": "2019-04-29T17:49:12", "upload_time_iso_8601": "2019-04-29T17:49:12.163767Z", "url": "https://files.pythonhosted.org/packages/9f/59/efd7668c60df21d25acba05b5d510d7cc2d4c97b13dbd35bdfac19418b3a/pbjson-1.13.tar.gz", "yanked": false}], "1.14": [{"comment_text": "", "digests": {"md5": "d18b108bfa64093f6cb80f052fb400a3", "sha256": "24936c8ee5b7b0d5559d9d38560d1a28561e57e64905f0c4b96ec55bb9f07877"}, "downloads": -1, "filename": "pbjson-1.14.tar.gz", "has_sig": false, "md5_digest": "d18b108bfa64093f6cb80f052fb400a3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39572, "upload_time": "2019-04-29T17:51:40", "upload_time_iso_8601": "2019-04-29T17:51:40.822018Z", "url": "https://files.pythonhosted.org/packages/ce/69/cf74681c2fb485793b27f101f70a2bb249b1b556229c86c42a137858e7a0/pbjson-1.14.tar.gz", "yanked": false}], "1.15": [{"comment_text": "", "digests": {"md5": "e26626df18806ed7e82af76c6142f08c", "sha256": "eb9c239afd8cc2465ed2a04074e0fd71fb9380815b83a402ed71442549c0982f"}, "downloads": -1, "filename": "pbjson-1.15.tar.gz", "has_sig": false, "md5_digest": "e26626df18806ed7e82af76c6142f08c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39540, "upload_time": "2019-04-29T19:53:39", "upload_time_iso_8601": "2019-04-29T19:53:39.454546Z", "url": "https://files.pythonhosted.org/packages/a9/fa/a301fc138b8ae1d391fc3b029e9e6ac21f570d999ea9a2cb4838f1346ebb/pbjson-1.15.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e26626df18806ed7e82af76c6142f08c", "sha256": "eb9c239afd8cc2465ed2a04074e0fd71fb9380815b83a402ed71442549c0982f"}, "downloads": -1, "filename": "pbjson-1.15.tar.gz", "has_sig": false, "md5_digest": "e26626df18806ed7e82af76c6142f08c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39540, "upload_time": "2019-04-29T19:53:39", "upload_time_iso_8601": "2019-04-29T19:53:39.454546Z", "url": "https://files.pythonhosted.org/packages/a9/fa/a301fc138b8ae1d391fc3b029e9e6ac21f570d999ea9a2cb4838f1346ebb/pbjson-1.15.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:36 2020"}