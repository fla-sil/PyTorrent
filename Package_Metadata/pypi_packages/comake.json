{"info": {"author": "liaosiwei", "author_email": "liaosiwei@163.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2.7", "Topic :: Software Development :: Build Tools"], "description": "Comake - A compiling tool for c++ which handles dependency automatically.\n========================================================================\n\n## Introduction\nComake is a tool that aimed to be a handy c++ project organizer such as 'cargo' in rust or 'go get' in golang. It downloads and compiles \ndenpendencies automatically and organizes the include paths and library paths in a uniform way to support your main c++ application, and\nit also generate a custom Makefile for your application which makes you free of the pain of writing the Makefile.\n\nSince comake simplifies the process of the dependencies' and your main application's build, it may lack some of customization and flexibility.\n\n-------\n\n## Prerequisites\n* c++11 or above\n* python 2.7+ (python 3 may don't work)\n* cmake 3.4.1+\n* GNU autoconf & automake\n* [GitPython](https://github.com/gitpython-developers/GitPython)\n* [Jinja2](http://jinja.pocoo.org/)\n* [pytoml](https://github.com/avakar/pytoml)\n\n## Install\n1. pip install comake\n2. set COMAKEPATH environment varible to your project path\n3. type 'comake.py -v' to test whether installation is success or not\n\n## Basic usage\nBasically, comake is a command line tool which has several options to act different functions as follows:\n\n* ```comake.py -S```\nit generates a COMAKE file which is the core configuration file of comake\n* ```comake.py -U```\nit fetchs dependencies and switch them to specified version that is set in COMAKE file\n* ```comake.py -B```\nit compiles all dependencies that is set in COMAKE file, the dependency version is not changed\n* ```comake.py```\nit generate a Makefile according to the COMAKE file\n\n## COMAKE file\nA COMAKE file set many aspects of your project including project name, dependencies, compilers, compiling options and outputs and so on.\nTake gflags's COMAKE as an example:\n```\nproject = \"gflags\"\n\nCC = \"gcc\"\n\nCXX = \"g++\"\n\n# C\u9884\u5904\u7406\u53c2\u6570\nc_pre_flags = \"-DGNU_SOURCE\"\n\n# C\u7f16\u8bd1\u53c2\u6570\nc_compile_flags = \"-Wall\"\n\n# C++\u7f16\u8bd1\u53c2\u6570\ncxx_compile_flags = \"-Wall -std=c++11\"\n\n# \u4f18\u5316\u7b49\u7ea7,\u53ea\u5bf9release\u751f\u6548\nopt_level = \"-O3\"\n\n# \u94fe\u63a5\u53c2\u6570\nld_flags = \"-lpthread\"\n\n# \u641c\u7d22\u5934\u6587\u4ef6\u8def\u5f84\ninclude_path = \".\"\n\n# \u641c\u7d22\u5e93\u6587\u4ef6\u8def\u5f84\nlibrary_path = \".\"\n\n[[dependency]]\nuri = \"\"\ntag = \"\"\n\n[[output]]\nsources = \"\"\nheaders = \"\"\nlibs = \"\"\nbin = \"\"\nso = \"\"\na = \"\"\n\n[cmd]\nbefore = \"if [ ! -d build ]; then mkdir build; fi && cd build && cmake .. && make\"\nafter = \"mv build/include/gflags/* output/include/gflags && mv build/lib/* output/lib\"\n```\nsome config option is obvious, we skip them. \n* include_path and library_path is the corresponding compiler options which don't contained in your dependencies. It should be your project's headers and library path\n* dependency is an array that the element contains uri and tag. The uri is the git address and tag is git tag which indicates its version\n* output is an array too. it's sources and headers should be your projct's c++ sources and headers, and libs, bin, so, a represents the outputing\nlibrary name, binary file name, dynamic library name and static library name\n* cmd is a configuration for shell script execution before application building and after it's building.\nAs for exmaple 'gflag', [before] cmd uses cmake to build gflag dependency and [after] cmd copies output to specified path which will be written\ninto generated Makefile\n\n### COMAKE detail\n\nSince COMAKE is new , many projects don't use it as a build tool, then if a dependency that specified in your COMAKE file does't have a COMAKE, what will happend?\n\nBy design, when a dependency is downloaded, comake trys to find it's COMAKE. If the file is found, comake parses it, otherwise comake will download a corresponding COMAKE file according to it's uri from a website. The website address is [http://beautifuldocument.com:8080/](http://beautifuldocument.com:8080/). \nIt is just a temporary way to retrieve other people's COMAKE file that belongs to one specific git project which COMAKE file is not provided by default. \n\nComake is a system that is promoted by sharing and opening. \n\nWhat about dependency conflict?\nThis problem is solved by an engineering approach other than an academic approach. For instance, following is a dependency tree:\n```\n  L1                    A\n  L2                  /   \\\n  L3                 B     C\n  L4                / \\   /  \\\n  L5              C    D E    D\n```  \ncomake have two rules to solve above dependency problem:\n* rule1: if A belongs to L[M] and L[N] at the same time, then comake use A that belongs to L[min(M, N)]\n* rule2: if M == N, the first one that occurred to comake will be chosen\n\nIn the above dependency tree, C belongs to L2 and L3, then comake will choose C in L2. And let's consider D that both of it belong to L5, since the sequence of comake parseing dependency, the D that is a child of B will be chosen.\n\nThe sequence of parsing dependency in comake\nAs in the dependency tree above, comake parses dedenpency from L1, L2 ... to LN, and in one level L[K], comake parses from left to right.\n\n## Note\nThe project is inspired by a product of Baidu Inc, but it has nothing relative to the product. The only relation between this product and that from\nBaidu Inc is their name is identical, nothing else. The code is dependently written and open-sourced, pull request and advise are welcome.\n", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/boully/comake/tarball/v0.1.6", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/boully/comake", "keywords": "c++,auto-build,dependency", "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "comake", "package_url": "https://pypi.org/project/comake/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/comake/", "project_urls": {"Download": "https://github.com/boully/comake/tarball/v0.1.6", "Homepage": "https://github.com/boully/comake"}, "release_url": "https://pypi.org/project/comake/v0.1.6/", "requires_dist": null, "requires_python": null, "summary": "A c++ build tool", "version": "v0.1.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            Comake - A compiling tool for c++ which handles dependency automatically.<br>========================================================================<br><br>## Introduction<br>Comake is a tool that aimed to be a handy c++ project organizer such as 'cargo' in rust or 'go get' in golang. It downloads and compiles <br>denpendencies automatically and organizes the include paths and library paths in a uniform way to support your main c++ application, and<br>it also generate a custom Makefile for your application which makes you free of the pain of writing the Makefile.<br><br>Since comake simplifies the process of the dependencies' and your main application's build, it may lack some of customization and flexibility.<br><br>-------<br><br>## Prerequisites<br>* c++11 or above<br>* python 2.7+ (python 3 may don't work)<br>* cmake 3.4.1+<br>* GNU autoconf &amp; automake<br>* [GitPython](https://github.com/gitpython-developers/GitPython)<br>* [Jinja2](http://jinja.pocoo.org/)<br>* [pytoml](https://github.com/avakar/pytoml)<br><br>## Install<br>1. pip install comake<br>2. set COMAKEPATH environment varible to your project path<br>3. type 'comake.py -v' to test whether installation is success or not<br><br>## Basic usage<br>Basically, comake is a command line tool which has several options to act different functions as follows:<br><br>* ```comake.py -S```<br>it generates a COMAKE file which is the core configuration file of comake<br>* ```comake.py -U```<br>it fetchs dependencies and switch them to specified version that is set in COMAKE file<br>* ```comake.py -B```<br>it compiles all dependencies that is set in COMAKE file, the dependency version is not changed<br>* ```comake.py```<br>it generate a Makefile according to the COMAKE file<br><br>## COMAKE file<br>A COMAKE file set many aspects of your project including project name, dependencies, compilers, compiling options and outputs and so on.<br>Take gflags's COMAKE as an example:<br>```<br>project = \"gflags\"<br><br>CC = \"gcc\"<br><br>CXX = \"g++\"<br><br># C\u9884\u5904\u7406\u53c2\u6570<br>c_pre_flags = \"-DGNU_SOURCE\"<br><br># C\u7f16\u8bd1\u53c2\u6570<br>c_compile_flags = \"-Wall\"<br><br># C++\u7f16\u8bd1\u53c2\u6570<br>cxx_compile_flags = \"-Wall -std=c++11\"<br><br># \u4f18\u5316\u7b49\u7ea7,\u53ea\u5bf9release\u751f\u6548<br>opt_level = \"-O3\"<br><br># \u94fe\u63a5\u53c2\u6570<br>ld_flags = \"-lpthread\"<br><br># \u641c\u7d22\u5934\u6587\u4ef6\u8def\u5f84<br>include_path = \".\"<br><br># \u641c\u7d22\u5e93\u6587\u4ef6\u8def\u5f84<br>library_path = \".\"<br><br>[[dependency]]<br>uri = \"\"<br>tag = \"\"<br><br>[[output]]<br>sources = \"\"<br>headers = \"\"<br>libs = \"\"<br>bin = \"\"<br>so = \"\"<br>a = \"\"<br><br>[cmd]<br>before = \"if [ ! -d build ]; then mkdir build; fi &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make\"<br>after = \"mv build/include/gflags/* output/include/gflags &amp;&amp; mv build/lib/* output/lib\"<br>```<br>some config option is obvious, we skip them. <br>* include_path and library_path is the corresponding compiler options which don't contained in your dependencies. It should be your project's headers and library path<br>* dependency is an array that the element contains uri and tag. The uri is the git address and tag is git tag which indicates its version<br>* output is an array too. it's sources and headers should be your projct's c++ sources and headers, and libs, bin, so, a represents the outputing<br>library name, binary file name, dynamic library name and static library name<br>* cmd is a configuration for shell script execution before application building and after it's building.<br>As for exmaple 'gflag', [before] cmd uses cmake to build gflag dependency and [after] cmd copies output to specified path which will be written<br>into generated Makefile<br><br>### COMAKE detail<br><br>Since COMAKE is new , many projects don't use it as a build tool, then if a dependency that specified in your COMAKE file does't have a COMAKE, what will happend?<br><br>By design, when a dependency is downloaded, comake trys to find it's COMAKE. If the file is found, comake parses it, otherwise comake will download a corresponding COMAKE file according to it's uri from a website. The website address is [http://beautifuldocument.com:8080/](http://beautifuldocument.com:8080/). <br>It is just a temporary way to retrieve other people's COMAKE file that belongs to one specific git project which COMAKE file is not provided by default. <br><br>Comake is a system that is promoted by sharing and opening. <br><br>What about dependency conflict?<br>This problem is solved by an engineering approach other than an academic approach. For instance, following is a dependency tree:<br>```<br>  L1                    A<br>  L2                  /   \\<br>  L3                 B     C<br>  L4                / \\   /  \\<br>  L5              C    D E    D<br>```  <br>comake have two rules to solve above dependency problem:<br>* rule1: if A belongs to L[M] and L[N] at the same time, then comake use A that belongs to L[min(M, N)]<br>* rule2: if M == N, the first one that occurred to comake will be chosen<br><br>In the above dependency tree, C belongs to L2 and L3, then comake will choose C in L2. And let's consider D that both of it belong to L5, since the sequence of comake parseing dependency, the D that is a child of B will be chosen.<br><br>The sequence of parsing dependency in comake<br>As in the dependency tree above, comake parses dedenpency from L1, L2 ... to LN, and in one level L[K], comake parses from left to right.<br><br>## Note<br>The project is inspired by a product of Baidu Inc, but it has nothing relative to the product. The only relation between this product and that from<br>Baidu Inc is their name is identical, nothing else. The code is dependently written and open-sourced, pull request and advise are welcome.<br>\n          </div>"}, "last_serial": 2313645, "releases": {"v0.1.0": [{"comment_text": "", "digests": {"md5": "92585baaacb70d77027eeb0e69652728", "sha256": "8c3cfdb0b64d77051f1cdcd930fd3d29abbe7b9ecbe21c1cf6581fed906bb613"}, "downloads": -1, "filename": "comake-v0.1.1.tar.gz", "has_sig": false, "md5_digest": "92585baaacb70d77027eeb0e69652728", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6998, "upload_time": "2016-08-27T02:43:36", "upload_time_iso_8601": "2016-08-27T02:43:36.708525Z", "url": "https://files.pythonhosted.org/packages/b7/f9/0b6d2ccddbf15f88525dde3706c424f5778b32f0dcfdd1baa51f4d38e271/comake-v0.1.1.tar.gz", "yanked": false}], "v0.1.2": [{"comment_text": "", "digests": {"md5": "76454b799936ac706cdaf6ecd3574701", "sha256": "019fc7d8dfac7e35913b2bd904264a31f1452f714946e053fc1feaab1d1c4740"}, "downloads": -1, "filename": "comake-v0.1.2.tar.gz", "has_sig": false, "md5_digest": "76454b799936ac706cdaf6ecd3574701", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9556, "upload_time": "2016-08-29T16:25:37", "upload_time_iso_8601": "2016-08-29T16:25:37.856733Z", "url": "https://files.pythonhosted.org/packages/f5/38/f855afc555bba294514d408a5c5492a0b00d85ad3fd69c3dae7af40fbd63/comake-v0.1.2.tar.gz", "yanked": false}], "v0.1.3": [{"comment_text": "", "digests": {"md5": "f720c6e90d193c41224c283aec464dd9", "sha256": "334a1ea6c1d7565a686a72c9a657a6a6d86bef5ea3bce769880fd9321d3c656f"}, "downloads": -1, "filename": "comake-v0.1.3.tar.gz", "has_sig": false, "md5_digest": "f720c6e90d193c41224c283aec464dd9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9541, "upload_time": "2016-08-29T16:38:53", "upload_time_iso_8601": "2016-08-29T16:38:53.298749Z", "url": "https://files.pythonhosted.org/packages/f6/d6/b067f0603135216a64b0e1684f13581cfa3a41891ac6408f4a156561370d/comake-v0.1.3.tar.gz", "yanked": false}], "v0.1.4": [{"comment_text": "", "digests": {"md5": "fa00dc2453c26458a9dee632ab92c994", "sha256": "81a107e6d5517f4bda902fd2f07b5afc63cefa37ae49f15cc2078d6185020be6"}, "downloads": -1, "filename": "comake-v0.1.4.tar.gz", "has_sig": false, "md5_digest": "fa00dc2453c26458a9dee632ab92c994", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9545, "upload_time": "2016-08-29T16:52:08", "upload_time_iso_8601": "2016-08-29T16:52:08.768129Z", "url": "https://files.pythonhosted.org/packages/a4/1e/15bbd02d629cb08a7ce003545ae71bc186781355a8543a24b23d60206df8/comake-v0.1.4.tar.gz", "yanked": false}], "v0.1.5": [{"comment_text": "", "digests": {"md5": "70d9307791f800c023cdc129063c9bda", "sha256": "a60bcb8b697f2a49572d6a3f3fafe796c3357d17d5f3cc26d039122f57b6090f"}, "downloads": -1, "filename": "comake-v0.1.5.tar.gz", "has_sig": false, "md5_digest": "70d9307791f800c023cdc129063c9bda", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9540, "upload_time": "2016-08-29T16:57:54", "upload_time_iso_8601": "2016-08-29T16:57:54.854366Z", "url": "https://files.pythonhosted.org/packages/da/59/37fb21b849ac74ef0792734800e2f546c9d33a755b30ef95ce9a815d80a4/comake-v0.1.5.tar.gz", "yanked": false}], "v0.1.6": [{"comment_text": "", "digests": {"md5": "8ad04cbf99f67b9df6e25af5afb77bb8", "sha256": "1c53cff391f413b701b604d608448ae347051f5b3ce3b24d937522ea59d34cab"}, "downloads": -1, "filename": "comake-v0.1.6.tar.gz", "has_sig": false, "md5_digest": "8ad04cbf99f67b9df6e25af5afb77bb8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9644, "upload_time": "2016-08-30T14:52:39", "upload_time_iso_8601": "2016-08-30T14:52:39.209024Z", "url": "https://files.pythonhosted.org/packages/37/34/fdf32c4a6aa77c1beb79cf38e10954c2dcbc9513b29759e81189ff7b72fc/comake-v0.1.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8ad04cbf99f67b9df6e25af5afb77bb8", "sha256": "1c53cff391f413b701b604d608448ae347051f5b3ce3b24d937522ea59d34cab"}, "downloads": -1, "filename": "comake-v0.1.6.tar.gz", "has_sig": false, "md5_digest": "8ad04cbf99f67b9df6e25af5afb77bb8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9644, "upload_time": "2016-08-30T14:52:39", "upload_time_iso_8601": "2016-08-30T14:52:39.209024Z", "url": "https://files.pythonhosted.org/packages/37/34/fdf32c4a6aa77c1beb79cf38e10954c2dcbc9513b29759e81189ff7b72fc/comake-v0.1.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:30 2020"}