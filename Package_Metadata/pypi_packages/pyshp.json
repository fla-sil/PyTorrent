{"info": {"author": "Joel Lawhead", "author_email": "jlawhead@geospatialpython.com", "bugtrack_url": null, "classifiers": ["Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: GIS", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# PyShp\n\nThe Python Shapefile Library (PyShp) reads and writes ESRI Shapefiles in pure Python.\n\n![pyshp logo](http://4.bp.blogspot.com/_SBi37QEsCvg/TPQuOhlHQxI/AAAAAAAAAE0/QjFlWfMx0tQ/S350/GSP_Logo.png \"PyShp\")\n\n[![Build Status](https://travis-ci.org/GeospatialPython/pyshp.svg?branch=master)](https://travis-ci.org/GeospatialPython/pyshp)\n\n## Contents\n\n[Overview](#overview)\n\n[Version Changes](#version-changes)\n\n[Examples](#examples)\n- [Reading Shapefiles](#reading-shapefiles)\n  - [Reading Shapefiles Using the Context Manager](#reading-shapefiles-using-the-context-manager)\n  - [Reading Shapefiles from File-Like Objects](#reading-shapefiles-from-file-like-objects)\n  - [Reading Shapefile Meta-Data](#reading-shapefile-meta-data)\n  - [Reading Geometry](#reading-geometry)\n  - [Reading Records](#reading-records)\n  - [Reading Geometry and Records Simultaneously](#reading-geometry-and-records-simultaneously)\n- [Writing Shapefiles](#writing-shapefiles)\n  - [Writing Shapefiles Using the Context Manager](#writing-shapefiles-using-the-context-manager)\n  - [Writing Shapefiles to File-Like Objects](#writing-shapefiles-to-file-like-objects)\n  - [Setting the Shape Type](#setting-the-shape-type)\n  - [Adding Records](#adding-records)\n  - [Adding Geometry](#adding-geometry)\n  - [Geometry and Record Balancing](#geometry-and-record-balancing)\n  \n[How To's](#how-tos)\n- [3D and Other Geometry Types](#3d-and-other-geometry-types)\n- [Working with Large Shapefiles](#working-with-large-shapefiles)\n- [Unicode and Shapefile Encodings](#unicode-and-shapefile-encodings)\n\n[Testing](#testing)\n\n\n# Overview\n\nThe Python Shapefile Library (PyShp) provides read and write support for the\nEsri Shapefile format. The Shapefile format is a popular Geographic\nInformation System vector data format created by Esri. For more information\nabout this format please read the well-written \"ESRI Shapefile Technical\nDescription - July 1998\" located at [http://www.esri.com/library/whitepapers/p\ndfs/shapefile.pdf](http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf)\n. The Esri document describes the shp and shx file formats. However a third\nfile format called dbf is also required. This format is documented on the web\nas the \"XBase File Format Description\" and is a simple file-based database\nformat created in the 1960's. For more on this specification see: [http://www.clicketyclick.dk/databases/xbase/format/index.html](http://www.clicketyclick.dk/databases/xbase/format/index.html)\n\nBoth the Esri and XBase file-formats are very simple in design and memory\nefficient which is part of the reason the shapefile format remains popular\ndespite the numerous ways to store and exchange GIS data available today.\n\nPyshp is compatible with Python 2.7-3.x.\n\nThis document provides examples for using PyShp to read and write shapefiles. However \nmany more examples are continually added to the blog [http://GeospatialPython.com](http://GeospatialPython.com),\nand by searching for PyShp on [https://gis.stackexchange.com](https://gis.stackexchange.com). \n\nCurrently the sample census blockgroup shapefile referenced in the examples is available on the GitHub project site at\n[https://github.com/GeospatialPython/pyshp](https://github.com/GeospatialPython/pyshp). These\nexamples are straight-forward and you can also easily run them against your\nown shapefiles with minimal modification. \n\nImportant: If you are new to GIS you should read about map projections.\nPlease visit: [https://github.com/GeospatialPython/pyshp/wiki/Map-Projections](https://github.com/GeospatialPython/pyshp/wiki/Map-Projections)\n\nI sincerely hope this library eliminates the mundane distraction of simply\nreading and writing data, and allows you to focus on the challenging and FUN\npart of your geospatial project.\n\n\n# Version Changes\n\n## 2.1.0\n\n### New Features:\n- Added back read/write support for unicode field names. \n- Improved Record representation\n- More support for geojson on Reader, ShapeRecord, ShapeRecords, and shapes()\n\n### Bug fixes:\n\n- Fixed error when reading optional m-values\n- Fixed Record attribute autocomplete in Python 3\n- Misc readme cleanup\n\n## 2.0.0\n\nThe newest version of PyShp, version 2.0 introduced some major new improvements. \nA great thanks to all who have contributed code and raised issues, and for everyone's\npatience and understanding during the transition period. \nSome of the new changes are incompatible with previous versions. \nUsers of the previous version 1.x should therefore take note of the following changes\n(Note: Some contributor attributions may be missing): \n\n### Major Changes:\n\n- Full support for unicode text, with custom encoding, and exception handling. \n  - Means that the Reader returns unicode, and the Writer accepts unicode. \n- PyShp has been simplified to a pure input-output library using the Reader and Writer classes, dropping the Editor class. \n- Switched to a new streaming approach when writing files, keeping memory-usage at a minimum:\n  - Specify filepath/destination and text encoding when creating the Writer. \n  - The file is written incrementally with each call to shape/record. \n  - Adding shapes is now done using dedicated methods for each shapetype. \n- Reading shapefiles is now more convenient:\n  - Shapefiles can be opened using the context manager, and files are properly closed. \n  - Shapefiles can be iterated, have a length, and supports the geo interface. \n  - New ways of inspecing shapefile metadata by printing. [@megies]\n  - More convenient accessing of Record values as attributes. [@philippkraft]\n  - More convenient shape type name checking. [@megies] \n- Add more support and documentation for MultiPatch 3D shapes. \n- The Reader \"elevation\" and \"measure\" attributes now renamed \"zbox\" and \"mbox\", to make it clear they refer to the min/max values. \n- Better documentation of previously unclear aspects, such as field types. \n\n### Important Fixes:\n\n- More reliable/robust:\n  - Fixed shapefile bbox error for empty or point type shapefiles. [@mcuprjak]\n  - Reading and writing Z and M type shapes is now more robust, fixing many errors, and has been added to the documentation. [@ShinNoNoir]\n  - Improved parsing of field value types, fixed errors and made more flexible. \n  - Fixed bug when writing shapefiles with datefield and date values earlier than 1900 [@megies]\n- Fix some geo interface errors, including checking polygon directions.\n- Bug fixes for reading from case sensitive file names, individual files separately, and from file-like objects. [@gastoneb, @kb003308, @erickskb]\n- Enforce maximum field limit. [@mwtoews]\n\n\n# Examples\n\nBefore doing anything you must import the library.\n\n\n\t>>> import shapefile\n\nThe examples below will use a shapefile created from the U.S. Census Bureau\nBlockgroups data set near San Francisco, CA and available in the git\nrepository of the PyShp GitHub site.\n\n## Reading Shapefiles\n\nTo read a shapefile create a new \"Reader\" object and pass it the name of an\nexisting shapefile. The shapefile format is actually a collection of three\nfiles. You specify the base filename of the shapefile or the complete filename\nof any of the shapefile component files.\n\n\n\t>>> sf = shapefile.Reader(\"shapefiles/blockgroups\")\n\nOR\n\n\n\t>>> sf = shapefile.Reader(\"shapefiles/blockgroups.shp\")\n\nOR\n\n\n\t>>> sf = shapefile.Reader(\"shapefiles/blockgroups.dbf\")\n\nOR any of the other 5+ formats which are potentially part of a shapefile. The\nlibrary does not care about file extensions.\n\n### Reading Shapefiles Using the Context Manager\n\nThe \"Reader\" class can be used as a context manager, to ensure open file\nobjects are properly closed when done reading the data:\n\n    >>> with shapefile.Reader(\"shapefiles/blockgroups.shp\") as shp:\n    ...     print(shp)\n    shapefile Reader\n        663 shapes (type 'POLYGON')\n        663 records (44 fields)\n\n### Reading Shapefiles from File-Like Objects\n\nYou can also load shapefiles from any Python file-like object using keyword\narguments to specify any of the three files. This feature is very powerful and\nallows you to load shapefiles from a url, a zip file, a serialized object,\nor in some cases a database.\n\n\n\t>>> myshp = open(\"shapefiles/blockgroups.shp\", \"rb\")\n\t>>> mydbf = open(\"shapefiles/blockgroups.dbf\", \"rb\")\n\t>>> r = shapefile.Reader(shp=myshp, dbf=mydbf)\n\nNotice in the examples above the shx file is never used. The shx file is a\nvery simple fixed-record index for the variable-length records in the shp\nfile. This file is optional for reading. If it's available PyShp will use the\nshx file to access shape records a little faster but will do just fine without\nit.\n\n### Reading Shapefile Meta-Data\n\nShapefiles have a number of attributes for inspecting the file contents.\nA shapefile is a container for a specific type of geometry, and this can be checked using the \nshapeType attribute. \n\n\n\t>>> sf.shapeType\n\t5\n\nShape types are represented by numbers between 0 and 31 as defined by the\nshapefile specification and listed below. It is important to note that the numbering system has\nseveral reserved numbers that have not been used yet, therefore the numbers of\nthe existing shape types are not sequential:\n\n- NULL = 0\n- POINT = 1\n- POLYLINE = 3\n- POLYGON = 5\n- MULTIPOINT = 8\n- POINTZ = 11\n- POLYLINEZ = 13\n- POLYGONZ = 15\n- MULTIPOINTZ = 18\n- POINTM = 21\n- POLYLINEM = 23\n- POLYGONM = 25\n- MULTIPOINTM = 28\n- MULTIPATCH = 31\n\t\nBased on this we can see that our blockgroups shapefile contains\nPolygon type shapes. The shape types are also defined as constants in\nthe shapefile module, so that we can compare types more intuitively:\n\n\n\t>>> sf.shapeType == shapefile.POLYGON\n\tTrue\n\nFor convenience, you can also get the name of the shape type as a string:\n\n\n\t>>> sf.shapeTypeName == 'POLYGON'\n\tTrue\n\t\nOther pieces of meta-data that we can check include the number of features \nand the bounding box area the shapefile covers:\n\n\n\t>>> len(sf)\n\t663\n\t>>> sf.bbox\n\t[-122.515048, 37.652916, -122.327622, 37.863433]\n\t\nFinally, if you would prefer to work with the entire shapefile in a different\nformat, you can convert all of it to a GeoJSON dictionary, although you may lose\nsome information in the process, such as z- and m-values: \n\n\n\t>>> sf.__geo_interface__['type']\n\t'FeatureCollection'\n\n### Reading Geometry\n\nA shapefile's geometry is the collection of points or shapes made from\nvertices and implied arcs representing physical locations. All types of\nshapefiles just store points. The metadata about the points determine how they\nare handled by software.\n\nYou can get a list of the shapefile's geometry by calling the shapes()\nmethod.\n\n\n\t>>> shapes = sf.shapes()\n\nThe shapes method returns a list of Shape objects describing the geometry of\neach shape record.\n\n\n\t>>> len(shapes)\n\t663\n\t\nTo read a single shape by calling its index use the shape() method. The index\nis the shape's count from 0. So to read the 8th shape record you would use its\nindex which is 7.\n\n\n\t>>> s = sf.shape(7)\n\n\t>>> # Read the bbox of the 8th shape to verify\n\t>>> # Round coordinates to 3 decimal places\n\t>>> ['%.3f' % coord for coord in s.bbox]\n\t['-122.450', '37.801', '-122.442', '37.808']\n\nEach shape record (except Points) contains the following attributes. Records of\nshapeType Point do not have a bounding box 'bbox'.\n\n\n\t>>> for name in dir(shapes[3]):\n\t...     if not name.startswith('_'):\n\t...         name\n\t'bbox'\n\t'parts'\n\t'points'\n\t'shapeType'\n\t'shapeTypeName'\n\n  * shapeType: an integer representing the type of shape as defined by the\n\t  shapefile specification.\n\n\n\t\t>>> shapes[3].shapeType\n\t\t5\n\n  * shapeTypeName: a string representation of the type of shape as defined by shapeType. Read-only. \n\n\n\t\t>>> shapes[3].shapeTypeName\n\t\t'POLYGON'\n\t\t\n  * bbox: If the shape type contains multiple points this tuple describes the\n\t  lower left (x,y) coordinate and upper right corner coordinate creating a\n\t  complete box around the points. If the shapeType is a\n\t  Null (shapeType == 0) then an AttributeError is raised.\n\n\n\t\t>>> # Get the bounding box of the 4th shape.\n\t\t>>> # Round coordinates to 3 decimal places\n\t\t>>> bbox = shapes[3].bbox\n\t\t>>> ['%.3f' % coord for coord in bbox]\n\t\t['-122.486', '37.787', '-122.446', '37.811']\n\n  * parts: Parts simply group collections of points into shapes. If the shape\n\t  record has multiple parts this attribute contains the index of the first\n\t  point of each part. If there is only one part then a list containing 0 is\n\t  returned.\n\n\n\t\t>>> shapes[3].parts\n\t\t[0]\n\n  * points: The points attribute contains a list of tuples containing an\n\t  (x,y) coordinate for each point in the shape.\n\n\n\t\t>>> len(shapes[3].points)\n\t\t173\n\t\t>>> # Get the 8th point of the fourth shape\n\t\t>>> # Truncate coordinates to 3 decimal places\n\t\t>>> shape = shapes[3].points[7]\n\t\t>>> ['%.3f' % coord for coord in shape]\n\t\t['-122.471', '37.787']\n\nIn most cases, however, if you need to do more than just type or bounds checking, you may want \nto convert the geometry to the more human-readable [GeoJSON format](http://geojson.org),\nwhere lines and polygons are grouped for you:\n\n\n\t>>> s = sf.shape(0)\n\t>>> geoj = s.__geo_interface__\n\t>>> geoj[\"type\"]\n\t'MultiPolygon'\n\t\nThe results from the shapes() method similiarly supports converting to GeoJSON:\n\n\n\t>>> shapes.__geo_interface__['type']\n\t'GeometryCollection'\n\t\n\n### Reading Records\n\nA record in a shapefile contains the attributes for each shape in the\ncollection of geometries. Records are stored in the dbf file. The link between\ngeometry and attributes is the foundation of all geographic information systems.\nThis critical link is implied by the order of shapes and corresponding records\nin the shp geometry file and the dbf attribute file.\n\nThe field names of a shapefile are available as soon as you read a shapefile.\nYou can call the \"fields\" attribute of the shapefile as a Python list. Each\nfield is a Python list with the following information:\n\n  * Field name: the name describing the data at this column index.\n  * Field type: the type of data at this column index. Types can be: \n       * \"C\": Characters, text.\n\t   * \"N\": Numbers, with or without decimals.\n\t   * \"F\": Floats (same as \"N\").\n\t   * \"L\": Logical, for boolean True/False values. \n\t   * \"D\": Dates. \n\t   * \"M\": Memo, has no meaning within a GIS and is part of the xbase spec instead.\n  * Field length: the length of the data found at this column index. Older GIS\n\t   software may truncate this length to 8 or 11 characters for \"Character\"\n\t   fields.\n  * Decimal length: the number of decimal places found in \"Number\" fields.\n\nTo see the fields for the Reader object above (sf) call the \"fields\"\nattribute:\n\n\n\t>>> fields = sf.fields\n\n\t>>> assert fields == [(\"DeletionFlag\", \"C\", 1, 0), [\"AREA\", \"N\", 18, 5],\n\t... [\"BKG_KEY\", \"C\", 12, 0], [\"POP1990\", \"N\", 9, 0], [\"POP90_SQMI\", \"N\", 10, 1],\n\t... [\"HOUSEHOLDS\", \"N\", 9, 0],\n\t... [\"MALES\", \"N\", 9, 0], [\"FEMALES\", \"N\", 9, 0], [\"WHITE\", \"N\", 9, 0],\n\t... [\"BLACK\", \"N\", 8, 0], [\"AMERI_ES\", \"N\", 7, 0], [\"ASIAN_PI\", \"N\", 8, 0],\n\t... [\"OTHER\", \"N\", 8, 0], [\"HISPANIC\", \"N\", 8, 0], [\"AGE_UNDER5\", \"N\", 8, 0],\n\t... [\"AGE_5_17\", \"N\", 8, 0], [\"AGE_18_29\", \"N\", 8, 0], [\"AGE_30_49\", \"N\", 8, 0],\n\t... [\"AGE_50_64\", \"N\", 8, 0], [\"AGE_65_UP\", \"N\", 8, 0],\n\t... [\"NEVERMARRY\", \"N\", 8, 0], [\"MARRIED\", \"N\", 9, 0], [\"SEPARATED\", \"N\", 7, 0],\n\t... [\"WIDOWED\", \"N\", 8, 0], [\"DIVORCED\", \"N\", 8, 0], [\"HSEHLD_1_M\", \"N\", 8, 0],\n\t... [\"HSEHLD_1_F\", \"N\", 8, 0], [\"MARHH_CHD\", \"N\", 8, 0],\n\t... [\"MARHH_NO_C\", \"N\", 8, 0], [\"MHH_CHILD\", \"N\", 7, 0],\n\t... [\"FHH_CHILD\", \"N\", 7, 0], [\"HSE_UNITS\", \"N\", 9, 0], [\"VACANT\", \"N\", 7, 0],\n\t... [\"OWNER_OCC\", \"N\", 8, 0], [\"RENTER_OCC\", \"N\", 8, 0],\n\t... [\"MEDIAN_VAL\", \"N\", 7, 0], [\"MEDIANRENT\", \"N\", 4, 0],\n\t... [\"UNITS_1DET\", \"N\", 8, 0], [\"UNITS_1ATT\", \"N\", 7, 0], [\"UNITS2\", \"N\", 7, 0],\n\t... [\"UNITS3_9\", \"N\", 8, 0], [\"UNITS10_49\", \"N\", 8, 0],\n\t... [\"UNITS50_UP\", \"N\", 8, 0], [\"MOBILEHOME\", \"N\", 7, 0]]\n\nYou can get a list of the shapefile's records by calling the records() method:\n\n\n\t>>> records = sf.records()\n\n\t>>> len(records)\n\t663\n\nTo read a single record call the record() method with the record's index:\n\n\n\t>>> rec = sf.record(3)\n\t\nEach record is a list-like Record object containing the values corresponding to each field in\nthe field list. A record's values can be accessed by positional indexing or slicing.\nFor example in the blockgroups shapefile the 2nd and 3rd fields are the blockgroup id \nand the 1990 population count of that San Francisco blockgroup:\n\n\n\t>>> rec[1:3]\n\t['060750601001', 4715]\n\nFor simpler access, the fields of a record can also accessed via the name of the field,\neither as a key or as an attribute name. The blockgroup id (BKG_KEY) of the blockgroups shapefile \ncan also be retrieved as:\n\n\n    >>> rec['BKG_KEY']\n    '060750601001'\n\n    >>> rec.BKG_KEY\n    '060750601001'\n\t\nThe record values can be easily integrated with other programs by converting it to a field-value dictionary:\n\n\n\t>>> dct = rec.as_dict()\n\t>>> sorted(dct.items())\n\t[('AGE_18_29', 1467), ('AGE_30_49', 1681), ('AGE_50_64', 92), ('AGE_5_17', 848), ('AGE_65_UP', 30), ('AGE_UNDER5', 597), ('AMERI_ES', 6), ('AREA', 2.34385), ('ASIAN_PI', 452), ('BKG_KEY', '060750601001'), ('BLACK', 1007), ('DIVORCED', 149), ('FEMALES', 2095), ('FHH_CHILD', 16), ('HISPANIC', 416), ('HOUSEHOLDS', 1195), ('HSEHLD_1_F', 40), ('HSEHLD_1_M', 22), ('HSE_UNITS', 1258), ('MALES', 2620), ('MARHH_CHD', 79), ('MARHH_NO_C', 958), ('MARRIED', 2021), ('MEDIANRENT', 739), ('MEDIAN_VAL', 337500), ('MHH_CHILD', 0), ('MOBILEHOME', 0), ('NEVERMARRY', 703), ('OTHER', 288), ('OWNER_OCC', 66), ('POP1990', 4715), ('POP90_SQMI', 2011.6), ('RENTER_OCC', 3733), ('SEPARATED', 49), ('UNITS10_49', 49), ('UNITS2', 160), ('UNITS3_9', 672), ('UNITS50_UP', 0), ('UNITS_1ATT', 302), ('UNITS_1DET', 43), ('VACANT', 93), ('WHITE', 2962), ('WIDOWED', 37)]\n\nIf at a later point you need to check the record's index position in the original \nshapefile, you can do this through the \"oid\" attribute:\n\n\n\t>>> rec.oid\n\t3\n\t\n### Reading Geometry and Records Simultaneously\n\nYou may want to examine both the geometry and the attributes for a record at\nthe same time. The shapeRecord() and shapeRecords() method let you do just\nthat.\n\nCalling the shapeRecords() method will return the geometry and attributes for\nall shapes as a list of ShapeRecord objects. Each ShapeRecord instance has a\n\"shape\" and \"record\" attribute. The shape attribute is a Shape object as\ndiscussed in the first section \"Reading Geometry\". The record attribute is a\nlist-like object containing field values as demonstrated in the \"Reading Records\" section.\n\n\n\t>>> shapeRecs = sf.shapeRecords()\n\nLet's read the blockgroup key and the population for the 4th blockgroup:\n\n\n\t>>> shapeRecs[3].record[1:3]\n\t['060750601001', 4715]\n\nThe results from the shapeRecords() method is a list-like object that can be easily converted\nto GeoJSON through the _\\_geo_interface\\_\\_:\n\n\n\t>>> shapeRecs.__geo_interface__['type']\n\t'FeatureCollection'\n\nThe shapeRecord() method reads a single shape/record pair at the specified index.\nTo get the 4th shape record from the blockgroups shapefile use the third index:\n\n\n\t>>> shapeRec = sf.shapeRecord(3)\n\t\nEach individual shape record also supports the _\\_geo_interface\\_\\_ to convert it to a GeoJSON:\n\n\n\t>>> shapeRec.__geo_interface__['type']\n\t'Feature'\n\nThe blockgroup key and population count:\n\n\n\t>>> shapeRec.record[1:3]\n\t['060750601001', 4715]\n\t\n\n## Writing Shapefiles\n\nPyShp tries to be as flexible as possible when writing shapefiles while\nmaintaining some degree of automatic validation to make sure you don't\naccidentally write an invalid file.\n\nPyShp can write just one of the component files such as the shp or dbf file\nwithout writing the others. So in addition to being a complete shapefile\nlibrary, it can also be used as a basic dbf (xbase) library. Dbf files are a\ncommon database format which are often useful as a standalone simple database\nformat. And even shp files occasionally have uses as a standalone format. Some\nweb-based GIS systems use an user-uploaded shp file to specify an area of\ninterest. Many precision agriculture chemical field sprayers also use the shp\nformat as a control file for the sprayer system (usually in combination with\ncustom database file formats).\n\nTo create a shapefile you begin by initiating a new Writer instance, passing it\nthe file path and name to save to:\n\n\n\t>>> w = shapefile.Writer('shapefiles/test/testfile')\n\t\nFile extensions are optional when reading or writing shapefiles. If you specify\nthem PyShp ignores them anyway. When you save files you can specify a base\nfile name that is used for all three file types. Or you can specify a name for\none or more file types:\n\n\n\t>>> w = shapefile.Writer(dbf='shapefiles/test/onlydbf.dbf')\n\t\nIn that case, any file types not assigned will not\nsave and only file types with file names will be saved. \n\n### Writing Shapefiles Using the Context Manager\n\nThe \"Writer\" class automatically closes the open files and writes the final headers once it is garbage collected.\nIn case of a crash and to make the code more readable, it is nevertheless recommended \nyou do this manually by calling the \"close()\" method: \n\n\n\t>>> w.close()\n\nAlternatively, you can also use the \"Writer\" class as a context manager, to ensure open file\nobjects are properly closed and final headers written once you exit the with-clause:\n\n\n\t>>> with shapefile.Writer(\"shapefiles/test/contextwriter\") as shp:\n\t...\t\tpass\n\n### Writing Shapefiles to File-Like Objects\n\nJust as you can read shapefiles from python file-like objects you can also\nwrite to them:\n\n\n\t>>> try:\n\t...     from StringIO import StringIO\n\t... except ImportError:\n\t...     from io import BytesIO as StringIO\n\t>>> shp = StringIO()\n\t>>> shx = StringIO()\n\t>>> dbf = StringIO()\n\t>>> w = shapefile.Writer(shp=shp, shx=shx, dbf=dbf)\n\t>>> w.field('field1', 'C')\n\t>>> w.record()\n\t>>> w.null()\n\t>>> w.close()\n\t>>> # To read back the files you could call the \"StringIO.getvalue()\" method later.\n\t\n### Setting the Shape Type\n\nThe shape type defines the type of geometry contained in the shapefile. All of\nthe shapes must match the shape type setting.\n\nThere are three ways to set the shape type: \n  * Set it when creating the class instance. \n  * Set it by assigning a value to an existing class instance. \n  * Set it automatically to the type of the first non-null shape by saving the shapefile.\n\nTo manually set the shape type for a Writer object when creating the Writer:\n\n\n\t>>> w = shapefile.Writer('shapefiles/test/shapetype', shapeType=3)\n\n\t>>> w.shapeType\n\t3\n\nOR you can set it after the Writer is created:\n\n\n\t>>> w.shapeType = 1\n\n\t>>> w.shapeType\n\t1\n\t\n\n### Adding Records\n\nBefore you can add records you must first create the fields that define what types of \nvalues will go into each attribute. \n\nThere are several different field types, all of which support storing None values as NULL. \n\nText fields are created using the 'C' type, and the third 'size' argument can be customized to the expected\nlength of text values to save space:\n\n\n\t>>> w = shapefile.Writer('shapefiles/test/dtype')\n\t>>> w.field('TEXT', 'C')\n\t>>> w.field('SHORT_TEXT', 'C', size=5)\n\t>>> w.field('LONG_TEXT', 'C', size=250)\n\t>>> w.null()\n\t>>> w.record('Hello', 'World', 'World'*50)\n\t>>> w.close()\n\t\n\t>>> r = shapefile.Reader('shapefiles/test/dtype')\n\t>>> assert r.record(0) == ['Hello', 'World', 'World'*50]\n\nDate fields are created using the 'D' type, and can be created using either \ndate objects, lists, or a YYYYMMDD formatted string. \nField length or decimal have no impact on this type:\n\n\n\t>>> from datetime import date\n\t>>> w = shapefile.Writer('shapefiles/test/dtype')\n\t>>> w.field('DATE', 'D')\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.record(date(1898,1,30))\n\t>>> w.record([1998,1,30])\n\t>>> w.record('19980130')\n\t>>> w.record(None)\n\t>>> w.close()\n\t\n\t>>> r = shapefile.Reader('shapefiles/test/dtype')\n\t>>> assert r.record(0) == [date(1898,1,30)]\n\t>>> assert r.record(1) == [date(1998,1,30)]\n\t>>> assert r.record(2) == [date(1998,1,30)]\n\t>>> assert r.record(3) == [None]\n\nNumeric fields are created using the 'N' type (or the 'F' type, which is exactly the same). \nBy default the fourth decimal argument is set to zero, essentially creating an integer field. \nTo store floats you must set the decimal argument to the precision of your choice. \nTo store very large numbers you must increase the field length size to the total number of digits \n(including comma and minus). \n\n\n\t>>> w = shapefile.Writer('shapefiles/test/dtype')\n\t>>> w.field('INT', 'N')\n\t>>> w.field('LOWPREC', 'N', decimal=2)\n\t>>> w.field('MEDPREC', 'N', decimal=10)\n\t>>> w.field('HIGHPREC', 'N', decimal=30)\n\t>>> w.field('FTYPE', 'F', decimal=10)\n\t>>> w.field('LARGENR', 'N', 101)\n\t>>> nr = 1.3217328\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.record(INT=nr, LOWPREC=nr, MEDPREC=nr, HIGHPREC=-3.2302e-25, FTYPE=nr, LARGENR=int(nr)*10**100)\n\t>>> w.record(None, None, None, None, None, None)\n\t>>> w.close()\n\t\n\t>>> r = shapefile.Reader('shapefiles/test/dtype')\n\t>>> assert r.record(0) == [1, 1.32, 1.3217328, -3.2302e-25, 1.3217328, 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]\n\t>>> assert r.record(1) == [None, None, None, None, None, None]\n\n\t\nFinally, we can create boolean fields by setting the type to 'L'. \nThis field can take True or False values, or 1 (True) or 0 (False). \nNone is interpreted as missing. \n\n\n\t>>> w = shapefile.Writer('shapefiles/test/dtype')\n\t>>> w.field('BOOLEAN', 'L')\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.record(True)\n\t>>> w.record(1)\n\t>>> w.record(False)\n\t>>> w.record(0)\n\t>>> w.record(None)\n\t>>> w.record(\"Nonesense\")\n\t>>> w.close()\n\t\n\t>>> r = shapefile.Reader('shapefiles/test/dtype')\n\t>>> r.record(0)\n\tRecord #0: [True]\n\t>>> r.record(1)\n\tRecord #1: [True]\n\t>>> r.record(2)\n\tRecord #2: [False]\n\t>>> r.record(3)\n\tRecord #3: [False]\n\t>>> r.record(4)\n\tRecord #4: [None]\n\t>>> r.record(5)\n\tRecord #5: [None]\n\t\nYou can also add attributes using keyword arguments where the keys are field names.\n\n\n\t>>> w = shapefile.Writer('shapefiles/test/dtype')\n\t>>> w.field('FIRST_FLD','C','40')\n\t>>> w.field('SECOND_FLD','C','40')\n\t>>> w.null()\n\t>>> w.null()\n\t>>> w.record('First', 'Line')\n\t>>> w.record(FIRST_FLD='First', SECOND_FLD='Line')\n\t>>> w.close()\n\n### Adding Geometry\n\nGeometry is added using one of several convenience methods. The \"null\" method is used\nfor null shapes, \"point\" is used for point shapes, \"multipoint\" is used for multipoint shapes, \"line\" for lines,\n\"poly\" for polygons. \n\n**Adding a Null shape**\n\nA shapefile may contain some records for which geometry is not available, and may be set using the \"null\" method. \nBecause Null shape types (shape type 0) have no geometry the \"null\" method is called without any arguments. \n\n\n\t>>> w = shapefile.Writer('shapefiles/test/null')\n\t>>> w.field('name', 'C')\n\n\t>>> w.null()\n\t>>> w.record('nullgeom')\n\n\t>>> w.close()\n\n**Adding a Point shape**\n\nPoint shapes are added using the \"point\" method. A point is specified by an x and\ny value. \n\n\n\t>>> w = shapefile.Writer('shapefiles/test/point')\n\t>>> w.field('name', 'C')\n\t\n\t>>> w.point(122, 37) \n\t>>> w.record('point1')\n\t\n\t>>> w.close()\n\n**Adding a MultiPoint shape**\n\nIf your point data allows for the possibility of multiple points per feature, use \"multipoint\" instead. \nThese are specified as a list of xy point coordinates. \n\n\n\t>>> w = shapefile.Writer('shapefiles/test/multipoint')\n\t>>> w.field('name', 'C')\n\t\n\t>>> w.multipoint([[122,37], [124,32]]) \n\t>>> w.record('multipoint1')\n\t\n\t>>> w.close()\n\t\n**Adding a LineString shape**\n\nFor LineString shapefiles, each shape is given as a list of one or more linear features. \nEach of the linear features must have at least two points. \n\t\n\t\n\t>>> w = shapefile.Writer('shapefiles/test/line')\n\t>>> w.field('name', 'C')\n\t\n\t>>> w.line([\n\t...\t\t\t[[1,5],[5,5],[5,1],[3,3],[1,1]], # line 1\n\t...\t\t\t[[3,2],[2,6]] # line 2\n\t...\t\t\t])\n\t\n\t>>> w.record('linestring1')\n\t\n\t>>> w.close()\n\t\n**Adding a Polygon shape**\n\nSimilarly to LineString, Polygon shapes consist of multiple polygons, and must be given as a list of polygons.\nThe main difference is that polygons must have at least 4 points and the last point must be the same as the first. \nIt's also okay if you forget to repeat the first point at the end; PyShp automatically checks and closes the polygons\nif you don't.\n\nIt's important to note that for Polygon shapefiles, your polygon coordinates must be ordered in a clockwise direction.\nIf any of the polygons have holes, then the hole polygon coordinates must be ordered in a counterclockwise direction.\nThe direction of your polygons determines how shapefile readers will distinguish between polygon outlines and holes. \n\n\n\t>>> w = shapefile.Writer('shapefiles/test/polygon')\n\t>>> w.field('name', 'C')\n\n\t>>> w.poly([\n\t...\t        [[122,37], [117,36], [115,32], [118,20], [113,24]], # poly 1\n\t...\t        [[15,2], [17,6], [22,7]], # hole 1\n\t...         [[122,37], [117,36], [115,32]] # poly 2\n\t...        ])\n\t>>> w.record('polygon1')\n\t\n\t>>> w.close()\n\t\t\n**Adding from an existing Shape object**\n\nFinally, geometry can be added by passing an existing \"Shape\" object to the \"shape\" method.\nYou can also pass it any GeoJSON dictionary or _\\_geo_interface\\_\\_ compatible object. \nThis can be particularly useful for copying from one file to another:\n\n\n\t>>> r = shapefile.Reader('shapefiles/test/polygon')\n\n\t>>> w = shapefile.Writer('shapefiles/test/copy')\n\t>>> w.fields = r.fields[1:] # skip first deletion field\n\n\t>>> # adding existing Shape objects\n\t>>> for shaperec in r.iterShapeRecords():\n\t...     w.record(*shaperec.record)\n\t...     w.shape(shaperec.shape)\n\t\n\t>>> # or GeoJSON dicts\n\t>>> for shaperec in r.iterShapeRecords():\n\t...     w.record(*shaperec.record)\n\t...     w.shape(shaperec.shape.__geo_interface__)\n\t\n\t>>> w.close()\t\n\t\n\n### Geometry and Record Balancing\n\nBecause every shape must have a corresponding record it is critical that the\nnumber of records equals the number of shapes to create a valid shapefile. You\nmust take care to add records and shapes in the same order so that the record\ndata lines up with the geometry data. For example:\n\n\t\n\t>>> w = shapefile.Writer('shapefiles/test/balancing', shapeType=shapefile.POINT)\n\t>>> w.field(\"field1\", \"C\")\n\t>>> w.field(\"field2\", \"C\")\n\t\n\t>>> w.record(\"row\", \"one\")\n\t>>> w.point(1, 1)\n\t\n\t>>> w.record(\"row\", \"two\")\n\t>>> w.point(2, 2)\n\t\nTo help prevent accidental misalignment PyShp has an \"auto balance\" feature to\nmake sure when you add either a shape or a record the two sides of the\nequation line up. This way if you forget to update an entry the\nshapefile will still be valid and handled correctly by most shapefile\nsoftware. Autobalancing is NOT turned on by default. To activate it set\nthe attribute autoBalance to 1 or True:\n\n\n    >>> w.autoBalance = 1\n\t>>> w.record(\"row\", \"three\")\n\t>>> w.record(\"row\", \"four\")\n\t>>> w.point(4, 4)\n\t\n\t>>> w.recNum == w.shpNum\n\tTrue\n\nYou also have the option of manually calling the balance() method at any time\nto ensure the other side is up to date. When balancing is used\nnull shapes are created on the geometry side or records\nwith a value of \"NULL\" for each field is created on the attribute side.\nThis gives you flexibility in how you build the shapefile.\nYou can create all of the shapes and then create all of the records or vice versa. \n\n\n    >>> w.autoBalance = 0\n\t>>> w.record(\"row\", \"five\")\n\t>>> w.record(\"row\", \"six\")\n\t>>> w.record(\"row\", \"seven\")\n\t>>> w.point(5, 5)\n\t>>> w.point(6, 6)\n\t>>> w.balance()\n\t\n\t>>> w.recNum == w.shpNum\n\tTrue\n\nIf you do not use the autoBalance() or balance() method and forget to manually\nbalance the geometry and attributes the shapefile will be viewed as corrupt by\nmost shapefile software.\n\t\n\n\n# How To's\n\n## 3D and Other Geometry Types\n\nMost shapefiles store conventional 2D points, lines, or polygons. But the shapefile format is also capable\nof storing various other types of geometries as well, including complex 3D surfaces and objects. \n\n**Shapefiles with measurement (M) values**\n\nMeasured shape types are shapes that include a measurement value at each vertex, for instance\nspeed measurements from a GPS device. Shapes with measurement (M) values are added with the following\nmethods: \"pointm\", \"multipointm\", \"linem\", and \"polygonm\". The M-values are specified by adding a\nthird M value to each XY coordinate. Missing or unobserved M-values are specified with a None value,\nor by simply omitting the third M-coordinate.\n\n\n\t>>> w = shapefile.Writer('shapefiles/test/linem')\n\t>>> w.field('name', 'C')\n\t\n\t>>> w.linem([\n\t...\t\t\t[[1,5,0],[5,5],[5,1,3],[3,3,None],[1,1,0]], # line with one omitted and one missing M-value\n\t...\t\t\t[[3,2],[2,6]] # line without any M-values\n\t...\t\t\t])\n\t\n\t>>> w.record('linem1')\n\t\n\t>>> w.close()\n\t\nShapefiles containing M-values can be examined in several ways:\n\n\t>>> r = shapefile.Reader('shapefiles/test/linem')\n\t\n\t>>> r.mbox # the lower and upper bound of M-values in the shapefile\n\t[0.0, 3.0]\n\t\n\t>>> r.shape(0).m # flat list of M-values\n\t[0.0, None, 3.0, None, 0.0, None, None]\n\n\t\n**Shapefiles with elevation (Z) values**\n\nElevation shape types are shapes that include an elevation value at each vertex, for instance elevation from a GPS device. \nShapes with elevation (Z) values are added with the following methods: \"pointz\", \"multipointz\", \"linez\", and \"polygonz\". \nThe Z-values are specified by adding a third Z value to each XY coordinate. Z-values do not support the concept of missing data,\nbut if you omit the third Z-coordinate it will default to 0. Note that Z-type shapes also support measurement (M) values added\nas a fourth M-coordinate. This too is optional. \n\t\n\t\n\t>>> w = shapefile.Writer('shapefiles/test/linez')\n\t>>> w.field('name', 'C')\n\t\n\t>>> w.linez([\n\t...\t\t\t[[1,5,18],[5,5,20],[5,1,22],[3,3],[1,1]], # line with some omitted Z-values\n\t...\t\t\t[[3,2],[2,6]], # line without any Z-values\n\t...\t\t\t[[3,2,15,0],[2,6,13,3],[1,9,14,2]] # line with both Z- and M-values\n\t...\t\t\t])\n\t\n\t>>> w.record('linez1')\n\t\n\t>>> w.close()\n\t\nTo examine a Z-type shapefile you can do:\n\n\t>>> r = shapefile.Reader('shapefiles/test/linez')\n\t\n\t>>> r.zbox # the lower and upper bound of Z-values in the shapefile\n\t[0.0, 22.0]\n\t\n\t>>> r.shape(0).z # flat list of Z-values\n\t[18.0, 20.0, 22.0, 0.0, 0.0, 0.0, 0.0, 15.0, 13.0, 14.0]\n\n**3D MultiPatch Shapefiles**\n\nMultipatch shapes are useful for storing composite 3-Dimensional objects. \nA MultiPatch shape represents a 3D object made up of one or more surface parts.\nEach surface in \"parts\" is defined by a list of XYZM values (Z and M values optional), and its corresponding type is\ngiven in the \"partTypes\" argument. The part type decides how the coordinate sequence is to be interpreted, and can be one \nof the following module constants: TRIANGLE_STRIP, TRIANGLE_FAN, OUTER_RING, INNER_RING, FIRST_RING, or RING.\nFor instance, a TRIANGLE_STRIP may be used to represent the walls of a building, combined with a TRIANGLE_FAN to represent \nits roof: \n\n\t>>> from shapefile import TRIANGLE_STRIP, TRIANGLE_FAN\n\t\n\t>>> w = shapefile.Writer('shapefiles/test/multipatch')\n\t>>> w.field('name', 'C')\n\t\n\t>>> w.multipatch([\n\t...\t\t\t\t [[0,0,0],[0,0,3],[5,0,0],[5,0,3],[5,5,0],[5,5,3],[0,5,0],[0,5,3],[0,0,0],[0,0,3]], # TRIANGLE_STRIP for house walls\n\t...\t\t\t\t [[2.5,2.5,5],[0,0,3],[5,0,3],[5,5,3],[0,5,3],[0,0,3]], # TRIANGLE_FAN for pointed house roof\n\t...\t\t\t\t ],\n\t...\t\t\t\t partTypes=[TRIANGLE_STRIP, TRIANGLE_FAN]) # one type for each part\n\t\n\t>>> w.record('house1')\n\t\n\t>>> w.close()\n\t\nFor an introduction to the various multipatch part types and examples of how to create 3D MultiPatch objects see [this\nESRI White Paper](http://downloads.esri.com/support/whitepapers/ao_/J9749_MultiPatch_Geometry_Type.pdf). \n\n## Working with Large Shapefiles\n\nDespite being a lightweight library, PyShp is designed to be able to read and write \nshapefiles of any size, allowing you to work with hundreds of thousands or even millions \nof records and complex geometries. \n\nWhen first creating the Reader class, the library only reads the header information\nand leaves the rest of the file contents alone. Once you call the records() and shapes() \nmethods however, it will attempt to read the entire file into memory at once. \nFor very large files this can result in MemoryError. So when working with large files\nit is recommended to use instead the iterShapes(), iterRecords(), or iterShapeRecords()\nmethods instead. These iterate through the file contents one at a time, enabling you to loop \nthrough them while keeping memory usage at a minimum. \n\n\n\t>>> for shape in sf.iterShapes():\n\t...     # do something here\n\t...     pass\n\t\n\t>>> for rec in sf.iterRecords():\n\t...     # do something here\n\t...     pass\n\t\n\t>>> for shapeRec in sf.iterShapeRecords():\n\t...     # do something here\n\t...     pass\n\n\t>>> for shapeRec in sf: # same as iterShapeRecords()\n\t...     # do something here\n\t...     pass\n\t\nThe shapefile Writer class uses a similar streaming approach to keep memory \nusage at a minimum. The library takes care of this under-the-hood by immediately \nwriting each geometry and record to disk the moment they \nare added using shape() or record(). Once the writer is closed, exited, or garbage \ncollected, the final header information is calculated and written to the beginning of \nthe file. \n\nThis means that as long as you are able to iterate through a source file without having\nto load everything into memory, such as a large CSV table or a large shapefile, you can \nprocess and write any number of items, and even merge many different source files into a single \nlarge shapefile. If you need to edit or undo any of your writing you would have to read the \nfile back in, one record at a time, make your changes, and write it back out. \n\n## Unicode and Shapefile Encodings\n\nPyShp has full support for unicode and shapefile encodings, so you can always expect to be working\nwith unicode strings in shapefiles that have text fields. \nMost shapefiles are written in UTF-8 encoding, PyShp's default encoding, so in most cases you don't \nhave to specify the encoding. For reading shapefiles in any other encoding, such as Latin-1, just \nsupply the encoding option when creating the Reader class. \n\n\n\t>>> r = shapefile.Reader(\"shapefiles/test/latin1.shp\", encoding=\"latin1\")\n\t>>> r.record(0) == [2, u'\u00d1and\u00fa']\n\tTrue\n\t\nOnce you have loaded the shapefile, you may choose to save it using another more supportive encoding such \nas UTF-8. Provided the new encoding supports the characters you are trying to write, reading it back in \nshould give you the same unicode string you started with. \n\n\n\t>>> w = shapefile.Writer(\"shapefiles/test/latin_as_utf8.shp\", encoding=\"utf8\")\n\t>>> w.fields = r.fields[1:]\n\t>>> w.record(*r.record(0))\n\t>>> w.null()\n\t>>> w.close()\n\t\n\t>>> r = shapefile.Reader(\"shapefiles/test/latin_as_utf8.shp\", encoding=\"utf8\")\n\t>>> r.record(0) == [2, u'\u00d1and\u00fa']\n\tTrue\n\t\nIf you supply the wrong encoding and the string is unable to be decoded, PyShp will by default raise an\nexception. If however, on rare occasion, you are unable to find the correct encoding and want to ignore\nor replace encoding errors, you can specify the \"encodingErrors\" to be used by the decode method. This\napplies to both reading and writing. \n\n\n\t>>> r = shapefile.Reader(\"shapefiles/test/latin1.shp\", encoding=\"ascii\", encodingErrors=\"replace\")\n\t>>> r.record(0) == [2, u'\ufffdand\ufffd']\n\tTrue\n\n\t\n# Testing\n\nThe testing framework is doctest, which are located in this file README.md.\nIn the same folder as README.md and shapefile.py, from the command line run \n```\n$ python shapefile.py\n``` \n\nLinux/Mac and similar platforms will need to run `$ dos2unix README.md` in order\ncorrect line endings in README.md.\n\n# Contributors\n\n```\nAtle Frenvik Sveen\nBas Couwenberg\nCasey Meisenzahl\nCharles Arnold\nDavid A. Riggs\ndavidh-ssec\nEvan Heidtmann\nezcitron\ngeospatialpython\nHannes\nIgnacio Martinez Vazquez\nJason Moujaes\nKarim Bahgat\nKyle Kelley\nLouis Tiao\nMarcin Cuprjak\nMicah Cochran\nMichael Davis\nMichal \u010ciha\u0159\nMike Toews\nNilo\npakoun\nPaulo Ernesto\nRaynor Vliegendhart\nRazzi Abuissa\nRoss Rogers\nRyan Brideau\nTobias Megies\nTommi Penttinen\nUli K\u00f6hler\nZac Miller\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/GeospatialPython/pyshp/archive/2.1.0.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/GeospatialPython/pyshp", "keywords": "gis geospatial geographic shapefile shapefiles", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pyshp", "package_url": "https://pypi.org/project/pyshp/", "platform": "", "project_url": "https://pypi.org/project/pyshp/", "project_urls": {"Download": "https://github.com/GeospatialPython/pyshp/archive/2.1.0.tar.gz", "Homepage": "https://github.com/GeospatialPython/pyshp"}, "release_url": "https://pypi.org/project/pyshp/2.1.0/", "requires_dist": null, "requires_python": ">= 2.7", "summary": "Pure Python read/write support for ESRI Shapefile format", "version": "2.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>PyShp</h1>\n<p>The Python Shapefile Library (PyShp) reads and writes ESRI Shapefiles in pure Python.</p>\n<p><img alt=\"pyshp logo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/137a4c72f0614cb78375ead3f8f94cdc5280ec9b/687474703a2f2f342e62702e626c6f6773706f742e636f6d2f5f53426933375145734376672f545051754f686c485178492f41414141414141414145302f516a466c57664d783074512f533335302f4753505f4c6f676f2e706e67\"></p>\n<p><a href=\"https://travis-ci.org/GeospatialPython/pyshp\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7558b35c0e2e35b7c6629ee6c0339fd263637298/68747470733a2f2f7472617669732d63692e6f72672f47656f7370617469616c507974686f6e2f70797368702e7376673f6272616e63683d6d6173746572\"></a></p>\n<h2>Contents</h2>\n<p><a href=\"#overview\" rel=\"nofollow\">Overview</a></p>\n<p><a href=\"#version-changes\" rel=\"nofollow\">Version Changes</a></p>\n<p><a href=\"#examples\" rel=\"nofollow\">Examples</a></p>\n<ul>\n<li><a href=\"#reading-shapefiles\" rel=\"nofollow\">Reading Shapefiles</a>\n<ul>\n<li><a href=\"#reading-shapefiles-using-the-context-manager\" rel=\"nofollow\">Reading Shapefiles Using the Context Manager</a></li>\n<li><a href=\"#reading-shapefiles-from-file-like-objects\" rel=\"nofollow\">Reading Shapefiles from File-Like Objects</a></li>\n<li><a href=\"#reading-shapefile-meta-data\" rel=\"nofollow\">Reading Shapefile Meta-Data</a></li>\n<li><a href=\"#reading-geometry\" rel=\"nofollow\">Reading Geometry</a></li>\n<li><a href=\"#reading-records\" rel=\"nofollow\">Reading Records</a></li>\n<li><a href=\"#reading-geometry-and-records-simultaneously\" rel=\"nofollow\">Reading Geometry and Records Simultaneously</a></li>\n</ul>\n</li>\n<li><a href=\"#writing-shapefiles\" rel=\"nofollow\">Writing Shapefiles</a>\n<ul>\n<li><a href=\"#writing-shapefiles-using-the-context-manager\" rel=\"nofollow\">Writing Shapefiles Using the Context Manager</a></li>\n<li><a href=\"#writing-shapefiles-to-file-like-objects\" rel=\"nofollow\">Writing Shapefiles to File-Like Objects</a></li>\n<li><a href=\"#setting-the-shape-type\" rel=\"nofollow\">Setting the Shape Type</a></li>\n<li><a href=\"#adding-records\" rel=\"nofollow\">Adding Records</a></li>\n<li><a href=\"#adding-geometry\" rel=\"nofollow\">Adding Geometry</a></li>\n<li><a href=\"#geometry-and-record-balancing\" rel=\"nofollow\">Geometry and Record Balancing</a></li>\n</ul>\n</li>\n</ul>\n<p><a href=\"#how-tos\" rel=\"nofollow\">How To's</a></p>\n<ul>\n<li><a href=\"#3d-and-other-geometry-types\" rel=\"nofollow\">3D and Other Geometry Types</a></li>\n<li><a href=\"#working-with-large-shapefiles\" rel=\"nofollow\">Working with Large Shapefiles</a></li>\n<li><a href=\"#unicode-and-shapefile-encodings\" rel=\"nofollow\">Unicode and Shapefile Encodings</a></li>\n</ul>\n<p><a href=\"#testing\" rel=\"nofollow\">Testing</a></p>\n<h1>Overview</h1>\n<p>The Python Shapefile Library (PyShp) provides read and write support for the\nEsri Shapefile format. The Shapefile format is a popular Geographic\nInformation System vector data format created by Esri. For more information\nabout this format please read the well-written \"ESRI Shapefile Technical\nDescription - July 1998\" located at <a href=\"http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf\" rel=\"nofollow\">http://www.esri.com/library/whitepapers/p\ndfs/shapefile.pdf</a>\n. The Esri document describes the shp and shx file formats. However a third\nfile format called dbf is also required. This format is documented on the web\nas the \"XBase File Format Description\" and is a simple file-based database\nformat created in the 1960's. For more on this specification see: <a href=\"http://www.clicketyclick.dk/databases/xbase/format/index.html\" rel=\"nofollow\">http://www.clicketyclick.dk/databases/xbase/format/index.html</a></p>\n<p>Both the Esri and XBase file-formats are very simple in design and memory\nefficient which is part of the reason the shapefile format remains popular\ndespite the numerous ways to store and exchange GIS data available today.</p>\n<p>Pyshp is compatible with Python 2.7-3.x.</p>\n<p>This document provides examples for using PyShp to read and write shapefiles. However\nmany more examples are continually added to the blog <a href=\"http://GeospatialPython.com\" rel=\"nofollow\">http://GeospatialPython.com</a>,\nand by searching for PyShp on <a href=\"https://gis.stackexchange.com\" rel=\"nofollow\">https://gis.stackexchange.com</a>.</p>\n<p>Currently the sample census blockgroup shapefile referenced in the examples is available on the GitHub project site at\n<a href=\"https://github.com/GeospatialPython/pyshp\" rel=\"nofollow\">https://github.com/GeospatialPython/pyshp</a>. These\nexamples are straight-forward and you can also easily run them against your\nown shapefiles with minimal modification.</p>\n<p>Important: If you are new to GIS you should read about map projections.\nPlease visit: <a href=\"https://github.com/GeospatialPython/pyshp/wiki/Map-Projections\" rel=\"nofollow\">https://github.com/GeospatialPython/pyshp/wiki/Map-Projections</a></p>\n<p>I sincerely hope this library eliminates the mundane distraction of simply\nreading and writing data, and allows you to focus on the challenging and FUN\npart of your geospatial project.</p>\n<h1>Version Changes</h1>\n<h2>2.1.0</h2>\n<h3>New Features:</h3>\n<ul>\n<li>Added back read/write support for unicode field names.</li>\n<li>Improved Record representation</li>\n<li>More support for geojson on Reader, ShapeRecord, ShapeRecords, and shapes()</li>\n</ul>\n<h3>Bug fixes:</h3>\n<ul>\n<li>Fixed error when reading optional m-values</li>\n<li>Fixed Record attribute autocomplete in Python 3</li>\n<li>Misc readme cleanup</li>\n</ul>\n<h2>2.0.0</h2>\n<p>The newest version of PyShp, version 2.0 introduced some major new improvements.\nA great thanks to all who have contributed code and raised issues, and for everyone's\npatience and understanding during the transition period.\nSome of the new changes are incompatible with previous versions.\nUsers of the previous version 1.x should therefore take note of the following changes\n(Note: Some contributor attributions may be missing):</p>\n<h3>Major Changes:</h3>\n<ul>\n<li>Full support for unicode text, with custom encoding, and exception handling.\n<ul>\n<li>Means that the Reader returns unicode, and the Writer accepts unicode.</li>\n</ul>\n</li>\n<li>PyShp has been simplified to a pure input-output library using the Reader and Writer classes, dropping the Editor class.</li>\n<li>Switched to a new streaming approach when writing files, keeping memory-usage at a minimum:\n<ul>\n<li>Specify filepath/destination and text encoding when creating the Writer.</li>\n<li>The file is written incrementally with each call to shape/record.</li>\n<li>Adding shapes is now done using dedicated methods for each shapetype.</li>\n</ul>\n</li>\n<li>Reading shapefiles is now more convenient:\n<ul>\n<li>Shapefiles can be opened using the context manager, and files are properly closed.</li>\n<li>Shapefiles can be iterated, have a length, and supports the geo interface.</li>\n<li>New ways of inspecing shapefile metadata by printing. [@megies]</li>\n<li>More convenient accessing of Record values as attributes. [@philippkraft]</li>\n<li>More convenient shape type name checking. [@megies]</li>\n</ul>\n</li>\n<li>Add more support and documentation for MultiPatch 3D shapes.</li>\n<li>The Reader \"elevation\" and \"measure\" attributes now renamed \"zbox\" and \"mbox\", to make it clear they refer to the min/max values.</li>\n<li>Better documentation of previously unclear aspects, such as field types.</li>\n</ul>\n<h3>Important Fixes:</h3>\n<ul>\n<li>More reliable/robust:\n<ul>\n<li>Fixed shapefile bbox error for empty or point type shapefiles. [@mcuprjak]</li>\n<li>Reading and writing Z and M type shapes is now more robust, fixing many errors, and has been added to the documentation. [@ShinNoNoir]</li>\n<li>Improved parsing of field value types, fixed errors and made more flexible.</li>\n<li>Fixed bug when writing shapefiles with datefield and date values earlier than 1900 [@megies]</li>\n</ul>\n</li>\n<li>Fix some geo interface errors, including checking polygon directions.</li>\n<li>Bug fixes for reading from case sensitive file names, individual files separately, and from file-like objects. [@gastoneb, @kb003308, @erickskb]</li>\n<li>Enforce maximum field limit. [@mwtoews]</li>\n</ul>\n<h1>Examples</h1>\n<p>Before doing anything you must import the library.</p>\n<pre><code>&gt;&gt;&gt; import shapefile\n</code></pre>\n<p>The examples below will use a shapefile created from the U.S. Census Bureau\nBlockgroups data set near San Francisco, CA and available in the git\nrepository of the PyShp GitHub site.</p>\n<h2>Reading Shapefiles</h2>\n<p>To read a shapefile create a new \"Reader\" object and pass it the name of an\nexisting shapefile. The shapefile format is actually a collection of three\nfiles. You specify the base filename of the shapefile or the complete filename\nof any of the shapefile component files.</p>\n<pre><code>&gt;&gt;&gt; sf = shapefile.Reader(\"shapefiles/blockgroups\")\n</code></pre>\n<p>OR</p>\n<pre><code>&gt;&gt;&gt; sf = shapefile.Reader(\"shapefiles/blockgroups.shp\")\n</code></pre>\n<p>OR</p>\n<pre><code>&gt;&gt;&gt; sf = shapefile.Reader(\"shapefiles/blockgroups.dbf\")\n</code></pre>\n<p>OR any of the other 5+ formats which are potentially part of a shapefile. The\nlibrary does not care about file extensions.</p>\n<h3>Reading Shapefiles Using the Context Manager</h3>\n<p>The \"Reader\" class can be used as a context manager, to ensure open file\nobjects are properly closed when done reading the data:</p>\n<pre><code>&gt;&gt;&gt; with shapefile.Reader(\"shapefiles/blockgroups.shp\") as shp:\n...     print(shp)\nshapefile Reader\n    663 shapes (type 'POLYGON')\n    663 records (44 fields)\n</code></pre>\n<h3>Reading Shapefiles from File-Like Objects</h3>\n<p>You can also load shapefiles from any Python file-like object using keyword\narguments to specify any of the three files. This feature is very powerful and\nallows you to load shapefiles from a url, a zip file, a serialized object,\nor in some cases a database.</p>\n<pre><code>&gt;&gt;&gt; myshp = open(\"shapefiles/blockgroups.shp\", \"rb\")\n&gt;&gt;&gt; mydbf = open(\"shapefiles/blockgroups.dbf\", \"rb\")\n&gt;&gt;&gt; r = shapefile.Reader(shp=myshp, dbf=mydbf)\n</code></pre>\n<p>Notice in the examples above the shx file is never used. The shx file is a\nvery simple fixed-record index for the variable-length records in the shp\nfile. This file is optional for reading. If it's available PyShp will use the\nshx file to access shape records a little faster but will do just fine without\nit.</p>\n<h3>Reading Shapefile Meta-Data</h3>\n<p>Shapefiles have a number of attributes for inspecting the file contents.\nA shapefile is a container for a specific type of geometry, and this can be checked using the\nshapeType attribute.</p>\n<pre><code>&gt;&gt;&gt; sf.shapeType\n5\n</code></pre>\n<p>Shape types are represented by numbers between 0 and 31 as defined by the\nshapefile specification and listed below. It is important to note that the numbering system has\nseveral reserved numbers that have not been used yet, therefore the numbers of\nthe existing shape types are not sequential:</p>\n<ul>\n<li>NULL = 0</li>\n<li>POINT = 1</li>\n<li>POLYLINE = 3</li>\n<li>POLYGON = 5</li>\n<li>MULTIPOINT = 8</li>\n<li>POINTZ = 11</li>\n<li>POLYLINEZ = 13</li>\n<li>POLYGONZ = 15</li>\n<li>MULTIPOINTZ = 18</li>\n<li>POINTM = 21</li>\n<li>POLYLINEM = 23</li>\n<li>POLYGONM = 25</li>\n<li>MULTIPOINTM = 28</li>\n<li>MULTIPATCH = 31</li>\n</ul>\n<p>Based on this we can see that our blockgroups shapefile contains\nPolygon type shapes. The shape types are also defined as constants in\nthe shapefile module, so that we can compare types more intuitively:</p>\n<pre><code>&gt;&gt;&gt; sf.shapeType == shapefile.POLYGON\nTrue\n</code></pre>\n<p>For convenience, you can also get the name of the shape type as a string:</p>\n<pre><code>&gt;&gt;&gt; sf.shapeTypeName == 'POLYGON'\nTrue\n</code></pre>\n<p>Other pieces of meta-data that we can check include the number of features\nand the bounding box area the shapefile covers:</p>\n<pre><code>&gt;&gt;&gt; len(sf)\n663\n&gt;&gt;&gt; sf.bbox\n[-122.515048, 37.652916, -122.327622, 37.863433]\n</code></pre>\n<p>Finally, if you would prefer to work with the entire shapefile in a different\nformat, you can convert all of it to a GeoJSON dictionary, although you may lose\nsome information in the process, such as z- and m-values:</p>\n<pre><code>&gt;&gt;&gt; sf.__geo_interface__['type']\n'FeatureCollection'\n</code></pre>\n<h3>Reading Geometry</h3>\n<p>A shapefile's geometry is the collection of points or shapes made from\nvertices and implied arcs representing physical locations. All types of\nshapefiles just store points. The metadata about the points determine how they\nare handled by software.</p>\n<p>You can get a list of the shapefile's geometry by calling the shapes()\nmethod.</p>\n<pre><code>&gt;&gt;&gt; shapes = sf.shapes()\n</code></pre>\n<p>The shapes method returns a list of Shape objects describing the geometry of\neach shape record.</p>\n<pre><code>&gt;&gt;&gt; len(shapes)\n663\n</code></pre>\n<p>To read a single shape by calling its index use the shape() method. The index\nis the shape's count from 0. So to read the 8th shape record you would use its\nindex which is 7.</p>\n<pre><code>&gt;&gt;&gt; s = sf.shape(7)\n\n&gt;&gt;&gt; # Read the bbox of the 8th shape to verify\n&gt;&gt;&gt; # Round coordinates to 3 decimal places\n&gt;&gt;&gt; ['%.3f' % coord for coord in s.bbox]\n['-122.450', '37.801', '-122.442', '37.808']\n</code></pre>\n<p>Each shape record (except Points) contains the following attributes. Records of\nshapeType Point do not have a bounding box 'bbox'.</p>\n<pre><code>&gt;&gt;&gt; for name in dir(shapes[3]):\n...     if not name.startswith('_'):\n...         name\n'bbox'\n'parts'\n'points'\n'shapeType'\n'shapeTypeName'\n</code></pre>\n<ul>\n<li>\n<p>shapeType: an integer representing the type of shape as defined by the\nshapefile specification.</p>\n<pre><code>&gt;&gt;&gt; shapes[3].shapeType\n5\n</code></pre>\n</li>\n<li>\n<p>shapeTypeName: a string representation of the type of shape as defined by shapeType. Read-only.</p>\n<pre><code>&gt;&gt;&gt; shapes[3].shapeTypeName\n'POLYGON'\n</code></pre>\n</li>\n<li>\n<p>bbox: If the shape type contains multiple points this tuple describes the\nlower left (x,y) coordinate and upper right corner coordinate creating a\ncomplete box around the points. If the shapeType is a\nNull (shapeType == 0) then an AttributeError is raised.</p>\n<pre><code>&gt;&gt;&gt; # Get the bounding box of the 4th shape.\n&gt;&gt;&gt; # Round coordinates to 3 decimal places\n&gt;&gt;&gt; bbox = shapes[3].bbox\n&gt;&gt;&gt; ['%.3f' % coord for coord in bbox]\n['-122.486', '37.787', '-122.446', '37.811']\n</code></pre>\n</li>\n<li>\n<p>parts: Parts simply group collections of points into shapes. If the shape\nrecord has multiple parts this attribute contains the index of the first\npoint of each part. If there is only one part then a list containing 0 is\nreturned.</p>\n<pre><code>&gt;&gt;&gt; shapes[3].parts\n[0]\n</code></pre>\n</li>\n<li>\n<p>points: The points attribute contains a list of tuples containing an\n(x,y) coordinate for each point in the shape.</p>\n<pre><code>&gt;&gt;&gt; len(shapes[3].points)\n173\n&gt;&gt;&gt; # Get the 8th point of the fourth shape\n&gt;&gt;&gt; # Truncate coordinates to 3 decimal places\n&gt;&gt;&gt; shape = shapes[3].points[7]\n&gt;&gt;&gt; ['%.3f' % coord for coord in shape]\n['-122.471', '37.787']\n</code></pre>\n</li>\n</ul>\n<p>In most cases, however, if you need to do more than just type or bounds checking, you may want\nto convert the geometry to the more human-readable <a href=\"http://geojson.org\" rel=\"nofollow\">GeoJSON format</a>,\nwhere lines and polygons are grouped for you:</p>\n<pre><code>&gt;&gt;&gt; s = sf.shape(0)\n&gt;&gt;&gt; geoj = s.__geo_interface__\n&gt;&gt;&gt; geoj[\"type\"]\n'MultiPolygon'\n</code></pre>\n<p>The results from the shapes() method similiarly supports converting to GeoJSON:</p>\n<pre><code>&gt;&gt;&gt; shapes.__geo_interface__['type']\n'GeometryCollection'\n</code></pre>\n<h3>Reading Records</h3>\n<p>A record in a shapefile contains the attributes for each shape in the\ncollection of geometries. Records are stored in the dbf file. The link between\ngeometry and attributes is the foundation of all geographic information systems.\nThis critical link is implied by the order of shapes and corresponding records\nin the shp geometry file and the dbf attribute file.</p>\n<p>The field names of a shapefile are available as soon as you read a shapefile.\nYou can call the \"fields\" attribute of the shapefile as a Python list. Each\nfield is a Python list with the following information:</p>\n<ul>\n<li>Field name: the name describing the data at this column index.</li>\n<li>Field type: the type of data at this column index. Types can be:\n<ul>\n<li>\"C\": Characters, text.</li>\n<li>\"N\": Numbers, with or without decimals.</li>\n<li>\"F\": Floats (same as \"N\").</li>\n<li>\"L\": Logical, for boolean True/False values.</li>\n<li>\"D\": Dates.</li>\n<li>\"M\": Memo, has no meaning within a GIS and is part of the xbase spec instead.</li>\n</ul>\n</li>\n<li>Field length: the length of the data found at this column index. Older GIS\nsoftware may truncate this length to 8 or 11 characters for \"Character\"\nfields.</li>\n<li>Decimal length: the number of decimal places found in \"Number\" fields.</li>\n</ul>\n<p>To see the fields for the Reader object above (sf) call the \"fields\"\nattribute:</p>\n<pre><code>&gt;&gt;&gt; fields = sf.fields\n\n&gt;&gt;&gt; assert fields == [(\"DeletionFlag\", \"C\", 1, 0), [\"AREA\", \"N\", 18, 5],\n... [\"BKG_KEY\", \"C\", 12, 0], [\"POP1990\", \"N\", 9, 0], [\"POP90_SQMI\", \"N\", 10, 1],\n... [\"HOUSEHOLDS\", \"N\", 9, 0],\n... [\"MALES\", \"N\", 9, 0], [\"FEMALES\", \"N\", 9, 0], [\"WHITE\", \"N\", 9, 0],\n... [\"BLACK\", \"N\", 8, 0], [\"AMERI_ES\", \"N\", 7, 0], [\"ASIAN_PI\", \"N\", 8, 0],\n... [\"OTHER\", \"N\", 8, 0], [\"HISPANIC\", \"N\", 8, 0], [\"AGE_UNDER5\", \"N\", 8, 0],\n... [\"AGE_5_17\", \"N\", 8, 0], [\"AGE_18_29\", \"N\", 8, 0], [\"AGE_30_49\", \"N\", 8, 0],\n... [\"AGE_50_64\", \"N\", 8, 0], [\"AGE_65_UP\", \"N\", 8, 0],\n... [\"NEVERMARRY\", \"N\", 8, 0], [\"MARRIED\", \"N\", 9, 0], [\"SEPARATED\", \"N\", 7, 0],\n... [\"WIDOWED\", \"N\", 8, 0], [\"DIVORCED\", \"N\", 8, 0], [\"HSEHLD_1_M\", \"N\", 8, 0],\n... [\"HSEHLD_1_F\", \"N\", 8, 0], [\"MARHH_CHD\", \"N\", 8, 0],\n... [\"MARHH_NO_C\", \"N\", 8, 0], [\"MHH_CHILD\", \"N\", 7, 0],\n... [\"FHH_CHILD\", \"N\", 7, 0], [\"HSE_UNITS\", \"N\", 9, 0], [\"VACANT\", \"N\", 7, 0],\n... [\"OWNER_OCC\", \"N\", 8, 0], [\"RENTER_OCC\", \"N\", 8, 0],\n... [\"MEDIAN_VAL\", \"N\", 7, 0], [\"MEDIANRENT\", \"N\", 4, 0],\n... [\"UNITS_1DET\", \"N\", 8, 0], [\"UNITS_1ATT\", \"N\", 7, 0], [\"UNITS2\", \"N\", 7, 0],\n... [\"UNITS3_9\", \"N\", 8, 0], [\"UNITS10_49\", \"N\", 8, 0],\n... [\"UNITS50_UP\", \"N\", 8, 0], [\"MOBILEHOME\", \"N\", 7, 0]]\n</code></pre>\n<p>You can get a list of the shapefile's records by calling the records() method:</p>\n<pre><code>&gt;&gt;&gt; records = sf.records()\n\n&gt;&gt;&gt; len(records)\n663\n</code></pre>\n<p>To read a single record call the record() method with the record's index:</p>\n<pre><code>&gt;&gt;&gt; rec = sf.record(3)\n</code></pre>\n<p>Each record is a list-like Record object containing the values corresponding to each field in\nthe field list. A record's values can be accessed by positional indexing or slicing.\nFor example in the blockgroups shapefile the 2nd and 3rd fields are the blockgroup id\nand the 1990 population count of that San Francisco blockgroup:</p>\n<pre><code>&gt;&gt;&gt; rec[1:3]\n['060750601001', 4715]\n</code></pre>\n<p>For simpler access, the fields of a record can also accessed via the name of the field,\neither as a key or as an attribute name. The blockgroup id (BKG_KEY) of the blockgroups shapefile\ncan also be retrieved as:</p>\n<pre><code>&gt;&gt;&gt; rec['BKG_KEY']\n'060750601001'\n\n&gt;&gt;&gt; rec.BKG_KEY\n'060750601001'\n</code></pre>\n<p>The record values can be easily integrated with other programs by converting it to a field-value dictionary:</p>\n<pre><code>&gt;&gt;&gt; dct = rec.as_dict()\n&gt;&gt;&gt; sorted(dct.items())\n[('AGE_18_29', 1467), ('AGE_30_49', 1681), ('AGE_50_64', 92), ('AGE_5_17', 848), ('AGE_65_UP', 30), ('AGE_UNDER5', 597), ('AMERI_ES', 6), ('AREA', 2.34385), ('ASIAN_PI', 452), ('BKG_KEY', '060750601001'), ('BLACK', 1007), ('DIVORCED', 149), ('FEMALES', 2095), ('FHH_CHILD', 16), ('HISPANIC', 416), ('HOUSEHOLDS', 1195), ('HSEHLD_1_F', 40), ('HSEHLD_1_M', 22), ('HSE_UNITS', 1258), ('MALES', 2620), ('MARHH_CHD', 79), ('MARHH_NO_C', 958), ('MARRIED', 2021), ('MEDIANRENT', 739), ('MEDIAN_VAL', 337500), ('MHH_CHILD', 0), ('MOBILEHOME', 0), ('NEVERMARRY', 703), ('OTHER', 288), ('OWNER_OCC', 66), ('POP1990', 4715), ('POP90_SQMI', 2011.6), ('RENTER_OCC', 3733), ('SEPARATED', 49), ('UNITS10_49', 49), ('UNITS2', 160), ('UNITS3_9', 672), ('UNITS50_UP', 0), ('UNITS_1ATT', 302), ('UNITS_1DET', 43), ('VACANT', 93), ('WHITE', 2962), ('WIDOWED', 37)]\n</code></pre>\n<p>If at a later point you need to check the record's index position in the original\nshapefile, you can do this through the \"oid\" attribute:</p>\n<pre><code>&gt;&gt;&gt; rec.oid\n3\n</code></pre>\n<h3>Reading Geometry and Records Simultaneously</h3>\n<p>You may want to examine both the geometry and the attributes for a record at\nthe same time. The shapeRecord() and shapeRecords() method let you do just\nthat.</p>\n<p>Calling the shapeRecords() method will return the geometry and attributes for\nall shapes as a list of ShapeRecord objects. Each ShapeRecord instance has a\n\"shape\" and \"record\" attribute. The shape attribute is a Shape object as\ndiscussed in the first section \"Reading Geometry\". The record attribute is a\nlist-like object containing field values as demonstrated in the \"Reading Records\" section.</p>\n<pre><code>&gt;&gt;&gt; shapeRecs = sf.shapeRecords()\n</code></pre>\n<p>Let's read the blockgroup key and the population for the 4th blockgroup:</p>\n<pre><code>&gt;&gt;&gt; shapeRecs[3].record[1:3]\n['060750601001', 4715]\n</code></pre>\n<p>The results from the shapeRecords() method is a list-like object that can be easily converted\nto GeoJSON through the __geo_interface__:</p>\n<pre><code>&gt;&gt;&gt; shapeRecs.__geo_interface__['type']\n'FeatureCollection'\n</code></pre>\n<p>The shapeRecord() method reads a single shape/record pair at the specified index.\nTo get the 4th shape record from the blockgroups shapefile use the third index:</p>\n<pre><code>&gt;&gt;&gt; shapeRec = sf.shapeRecord(3)\n</code></pre>\n<p>Each individual shape record also supports the __geo_interface__ to convert it to a GeoJSON:</p>\n<pre><code>&gt;&gt;&gt; shapeRec.__geo_interface__['type']\n'Feature'\n</code></pre>\n<p>The blockgroup key and population count:</p>\n<pre><code>&gt;&gt;&gt; shapeRec.record[1:3]\n['060750601001', 4715]\n</code></pre>\n<h2>Writing Shapefiles</h2>\n<p>PyShp tries to be as flexible as possible when writing shapefiles while\nmaintaining some degree of automatic validation to make sure you don't\naccidentally write an invalid file.</p>\n<p>PyShp can write just one of the component files such as the shp or dbf file\nwithout writing the others. So in addition to being a complete shapefile\nlibrary, it can also be used as a basic dbf (xbase) library. Dbf files are a\ncommon database format which are often useful as a standalone simple database\nformat. And even shp files occasionally have uses as a standalone format. Some\nweb-based GIS systems use an user-uploaded shp file to specify an area of\ninterest. Many precision agriculture chemical field sprayers also use the shp\nformat as a control file for the sprayer system (usually in combination with\ncustom database file formats).</p>\n<p>To create a shapefile you begin by initiating a new Writer instance, passing it\nthe file path and name to save to:</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/testfile')\n</code></pre>\n<p>File extensions are optional when reading or writing shapefiles. If you specify\nthem PyShp ignores them anyway. When you save files you can specify a base\nfile name that is used for all three file types. Or you can specify a name for\none or more file types:</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer(dbf='shapefiles/test/onlydbf.dbf')\n</code></pre>\n<p>In that case, any file types not assigned will not\nsave and only file types with file names will be saved.</p>\n<h3>Writing Shapefiles Using the Context Manager</h3>\n<p>The \"Writer\" class automatically closes the open files and writes the final headers once it is garbage collected.\nIn case of a crash and to make the code more readable, it is nevertheless recommended\nyou do this manually by calling the \"close()\" method:</p>\n<pre><code>&gt;&gt;&gt; w.close()\n</code></pre>\n<p>Alternatively, you can also use the \"Writer\" class as a context manager, to ensure open file\nobjects are properly closed and final headers written once you exit the with-clause:</p>\n<pre><code>&gt;&gt;&gt; with shapefile.Writer(\"shapefiles/test/contextwriter\") as shp:\n...\t\tpass\n</code></pre>\n<h3>Writing Shapefiles to File-Like Objects</h3>\n<p>Just as you can read shapefiles from python file-like objects you can also\nwrite to them:</p>\n<pre><code>&gt;&gt;&gt; try:\n...     from StringIO import StringIO\n... except ImportError:\n...     from io import BytesIO as StringIO\n&gt;&gt;&gt; shp = StringIO()\n&gt;&gt;&gt; shx = StringIO()\n&gt;&gt;&gt; dbf = StringIO()\n&gt;&gt;&gt; w = shapefile.Writer(shp=shp, shx=shx, dbf=dbf)\n&gt;&gt;&gt; w.field('field1', 'C')\n&gt;&gt;&gt; w.record()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.close()\n&gt;&gt;&gt; # To read back the files you could call the \"StringIO.getvalue()\" method later.\n</code></pre>\n<h3>Setting the Shape Type</h3>\n<p>The shape type defines the type of geometry contained in the shapefile. All of\nthe shapes must match the shape type setting.</p>\n<p>There are three ways to set the shape type:</p>\n<ul>\n<li>Set it when creating the class instance.</li>\n<li>Set it by assigning a value to an existing class instance.</li>\n<li>Set it automatically to the type of the first non-null shape by saving the shapefile.</li>\n</ul>\n<p>To manually set the shape type for a Writer object when creating the Writer:</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/shapetype', shapeType=3)\n\n&gt;&gt;&gt; w.shapeType\n3\n</code></pre>\n<p>OR you can set it after the Writer is created:</p>\n<pre><code>&gt;&gt;&gt; w.shapeType = 1\n\n&gt;&gt;&gt; w.shapeType\n1\n</code></pre>\n<h3>Adding Records</h3>\n<p>Before you can add records you must first create the fields that define what types of\nvalues will go into each attribute.</p>\n<p>There are several different field types, all of which support storing None values as NULL.</p>\n<p>Text fields are created using the 'C' type, and the third 'size' argument can be customized to the expected\nlength of text values to save space:</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/dtype')\n&gt;&gt;&gt; w.field('TEXT', 'C')\n&gt;&gt;&gt; w.field('SHORT_TEXT', 'C', size=5)\n&gt;&gt;&gt; w.field('LONG_TEXT', 'C', size=250)\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.record('Hello', 'World', 'World'*50)\n&gt;&gt;&gt; w.close()\n\n&gt;&gt;&gt; r = shapefile.Reader('shapefiles/test/dtype')\n&gt;&gt;&gt; assert r.record(0) == ['Hello', 'World', 'World'*50]\n</code></pre>\n<p>Date fields are created using the 'D' type, and can be created using either\ndate objects, lists, or a YYYYMMDD formatted string.\nField length or decimal have no impact on this type:</p>\n<pre><code>&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/dtype')\n&gt;&gt;&gt; w.field('DATE', 'D')\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.record(date(1898,1,30))\n&gt;&gt;&gt; w.record([1998,1,30])\n&gt;&gt;&gt; w.record('19980130')\n&gt;&gt;&gt; w.record(None)\n&gt;&gt;&gt; w.close()\n\n&gt;&gt;&gt; r = shapefile.Reader('shapefiles/test/dtype')\n&gt;&gt;&gt; assert r.record(0) == [date(1898,1,30)]\n&gt;&gt;&gt; assert r.record(1) == [date(1998,1,30)]\n&gt;&gt;&gt; assert r.record(2) == [date(1998,1,30)]\n&gt;&gt;&gt; assert r.record(3) == [None]\n</code></pre>\n<p>Numeric fields are created using the 'N' type (or the 'F' type, which is exactly the same).\nBy default the fourth decimal argument is set to zero, essentially creating an integer field.\nTo store floats you must set the decimal argument to the precision of your choice.\nTo store very large numbers you must increase the field length size to the total number of digits\n(including comma and minus).</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/dtype')\n&gt;&gt;&gt; w.field('INT', 'N')\n&gt;&gt;&gt; w.field('LOWPREC', 'N', decimal=2)\n&gt;&gt;&gt; w.field('MEDPREC', 'N', decimal=10)\n&gt;&gt;&gt; w.field('HIGHPREC', 'N', decimal=30)\n&gt;&gt;&gt; w.field('FTYPE', 'F', decimal=10)\n&gt;&gt;&gt; w.field('LARGENR', 'N', 101)\n&gt;&gt;&gt; nr = 1.3217328\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.record(INT=nr, LOWPREC=nr, MEDPREC=nr, HIGHPREC=-3.2302e-25, FTYPE=nr, LARGENR=int(nr)*10**100)\n&gt;&gt;&gt; w.record(None, None, None, None, None, None)\n&gt;&gt;&gt; w.close()\n\n&gt;&gt;&gt; r = shapefile.Reader('shapefiles/test/dtype')\n&gt;&gt;&gt; assert r.record(0) == [1, 1.32, 1.3217328, -3.2302e-25, 1.3217328, 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]\n&gt;&gt;&gt; assert r.record(1) == [None, None, None, None, None, None]\n</code></pre>\n<p>Finally, we can create boolean fields by setting the type to 'L'.\nThis field can take True or False values, or 1 (True) or 0 (False).\nNone is interpreted as missing.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/dtype')\n&gt;&gt;&gt; w.field('BOOLEAN', 'L')\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.record(True)\n&gt;&gt;&gt; w.record(1)\n&gt;&gt;&gt; w.record(False)\n&gt;&gt;&gt; w.record(0)\n&gt;&gt;&gt; w.record(None)\n&gt;&gt;&gt; w.record(\"Nonesense\")\n&gt;&gt;&gt; w.close()\n\n&gt;&gt;&gt; r = shapefile.Reader('shapefiles/test/dtype')\n&gt;&gt;&gt; r.record(0)\nRecord #0: [True]\n&gt;&gt;&gt; r.record(1)\nRecord #1: [True]\n&gt;&gt;&gt; r.record(2)\nRecord #2: [False]\n&gt;&gt;&gt; r.record(3)\nRecord #3: [False]\n&gt;&gt;&gt; r.record(4)\nRecord #4: [None]\n&gt;&gt;&gt; r.record(5)\nRecord #5: [None]\n</code></pre>\n<p>You can also add attributes using keyword arguments where the keys are field names.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/dtype')\n&gt;&gt;&gt; w.field('FIRST_FLD','C','40')\n&gt;&gt;&gt; w.field('SECOND_FLD','C','40')\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.record('First', 'Line')\n&gt;&gt;&gt; w.record(FIRST_FLD='First', SECOND_FLD='Line')\n&gt;&gt;&gt; w.close()\n</code></pre>\n<h3>Adding Geometry</h3>\n<p>Geometry is added using one of several convenience methods. The \"null\" method is used\nfor null shapes, \"point\" is used for point shapes, \"multipoint\" is used for multipoint shapes, \"line\" for lines,\n\"poly\" for polygons.</p>\n<p><strong>Adding a Null shape</strong></p>\n<p>A shapefile may contain some records for which geometry is not available, and may be set using the \"null\" method.\nBecause Null shape types (shape type 0) have no geometry the \"null\" method is called without any arguments.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/null')\n&gt;&gt;&gt; w.field('name', 'C')\n\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.record('nullgeom')\n\n&gt;&gt;&gt; w.close()\n</code></pre>\n<p><strong>Adding a Point shape</strong></p>\n<p>Point shapes are added using the \"point\" method. A point is specified by an x and\ny value.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/point')\n&gt;&gt;&gt; w.field('name', 'C')\n\n&gt;&gt;&gt; w.point(122, 37) \n&gt;&gt;&gt; w.record('point1')\n\n&gt;&gt;&gt; w.close()\n</code></pre>\n<p><strong>Adding a MultiPoint shape</strong></p>\n<p>If your point data allows for the possibility of multiple points per feature, use \"multipoint\" instead.\nThese are specified as a list of xy point coordinates.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/multipoint')\n&gt;&gt;&gt; w.field('name', 'C')\n\n&gt;&gt;&gt; w.multipoint([[122,37], [124,32]]) \n&gt;&gt;&gt; w.record('multipoint1')\n\n&gt;&gt;&gt; w.close()\n</code></pre>\n<p><strong>Adding a LineString shape</strong></p>\n<p>For LineString shapefiles, each shape is given as a list of one or more linear features.\nEach of the linear features must have at least two points.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/line')\n&gt;&gt;&gt; w.field('name', 'C')\n\n&gt;&gt;&gt; w.line([\n...\t\t\t[[1,5],[5,5],[5,1],[3,3],[1,1]], # line 1\n...\t\t\t[[3,2],[2,6]] # line 2\n...\t\t\t])\n\n&gt;&gt;&gt; w.record('linestring1')\n\n&gt;&gt;&gt; w.close()\n</code></pre>\n<p><strong>Adding a Polygon shape</strong></p>\n<p>Similarly to LineString, Polygon shapes consist of multiple polygons, and must be given as a list of polygons.\nThe main difference is that polygons must have at least 4 points and the last point must be the same as the first.\nIt's also okay if you forget to repeat the first point at the end; PyShp automatically checks and closes the polygons\nif you don't.</p>\n<p>It's important to note that for Polygon shapefiles, your polygon coordinates must be ordered in a clockwise direction.\nIf any of the polygons have holes, then the hole polygon coordinates must be ordered in a counterclockwise direction.\nThe direction of your polygons determines how shapefile readers will distinguish between polygon outlines and holes.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/polygon')\n&gt;&gt;&gt; w.field('name', 'C')\n\n&gt;&gt;&gt; w.poly([\n...\t        [[122,37], [117,36], [115,32], [118,20], [113,24]], # poly 1\n...\t        [[15,2], [17,6], [22,7]], # hole 1\n...         [[122,37], [117,36], [115,32]] # poly 2\n...        ])\n&gt;&gt;&gt; w.record('polygon1')\n\n&gt;&gt;&gt; w.close()\n</code></pre>\n<p><strong>Adding from an existing Shape object</strong></p>\n<p>Finally, geometry can be added by passing an existing \"Shape\" object to the \"shape\" method.\nYou can also pass it any GeoJSON dictionary or __geo_interface__ compatible object.\nThis can be particularly useful for copying from one file to another:</p>\n<pre><code>&gt;&gt;&gt; r = shapefile.Reader('shapefiles/test/polygon')\n\n&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/copy')\n&gt;&gt;&gt; w.fields = r.fields[1:] # skip first deletion field\n\n&gt;&gt;&gt; # adding existing Shape objects\n&gt;&gt;&gt; for shaperec in r.iterShapeRecords():\n...     w.record(*shaperec.record)\n...     w.shape(shaperec.shape)\n\n&gt;&gt;&gt; # or GeoJSON dicts\n&gt;&gt;&gt; for shaperec in r.iterShapeRecords():\n...     w.record(*shaperec.record)\n...     w.shape(shaperec.shape.__geo_interface__)\n\n&gt;&gt;&gt; w.close()\t\n</code></pre>\n<h3>Geometry and Record Balancing</h3>\n<p>Because every shape must have a corresponding record it is critical that the\nnumber of records equals the number of shapes to create a valid shapefile. You\nmust take care to add records and shapes in the same order so that the record\ndata lines up with the geometry data. For example:</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/balancing', shapeType=shapefile.POINT)\n&gt;&gt;&gt; w.field(\"field1\", \"C\")\n&gt;&gt;&gt; w.field(\"field2\", \"C\")\n\n&gt;&gt;&gt; w.record(\"row\", \"one\")\n&gt;&gt;&gt; w.point(1, 1)\n\n&gt;&gt;&gt; w.record(\"row\", \"two\")\n&gt;&gt;&gt; w.point(2, 2)\n</code></pre>\n<p>To help prevent accidental misalignment PyShp has an \"auto balance\" feature to\nmake sure when you add either a shape or a record the two sides of the\nequation line up. This way if you forget to update an entry the\nshapefile will still be valid and handled correctly by most shapefile\nsoftware. Autobalancing is NOT turned on by default. To activate it set\nthe attribute autoBalance to 1 or True:</p>\n<pre><code>&gt;&gt;&gt; w.autoBalance = 1\n&gt;&gt;&gt; w.record(\"row\", \"three\")\n&gt;&gt;&gt; w.record(\"row\", \"four\")\n&gt;&gt;&gt; w.point(4, 4)\n\n&gt;&gt;&gt; w.recNum == w.shpNum\nTrue\n</code></pre>\n<p>You also have the option of manually calling the balance() method at any time\nto ensure the other side is up to date. When balancing is used\nnull shapes are created on the geometry side or records\nwith a value of \"NULL\" for each field is created on the attribute side.\nThis gives you flexibility in how you build the shapefile.\nYou can create all of the shapes and then create all of the records or vice versa.</p>\n<pre><code>&gt;&gt;&gt; w.autoBalance = 0\n&gt;&gt;&gt; w.record(\"row\", \"five\")\n&gt;&gt;&gt; w.record(\"row\", \"six\")\n&gt;&gt;&gt; w.record(\"row\", \"seven\")\n&gt;&gt;&gt; w.point(5, 5)\n&gt;&gt;&gt; w.point(6, 6)\n&gt;&gt;&gt; w.balance()\n\n&gt;&gt;&gt; w.recNum == w.shpNum\nTrue\n</code></pre>\n<p>If you do not use the autoBalance() or balance() method and forget to manually\nbalance the geometry and attributes the shapefile will be viewed as corrupt by\nmost shapefile software.</p>\n<h1>How To's</h1>\n<h2>3D and Other Geometry Types</h2>\n<p>Most shapefiles store conventional 2D points, lines, or polygons. But the shapefile format is also capable\nof storing various other types of geometries as well, including complex 3D surfaces and objects.</p>\n<p><strong>Shapefiles with measurement (M) values</strong></p>\n<p>Measured shape types are shapes that include a measurement value at each vertex, for instance\nspeed measurements from a GPS device. Shapes with measurement (M) values are added with the following\nmethods: \"pointm\", \"multipointm\", \"linem\", and \"polygonm\". The M-values are specified by adding a\nthird M value to each XY coordinate. Missing or unobserved M-values are specified with a None value,\nor by simply omitting the third M-coordinate.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/linem')\n&gt;&gt;&gt; w.field('name', 'C')\n\n&gt;&gt;&gt; w.linem([\n...\t\t\t[[1,5,0],[5,5],[5,1,3],[3,3,None],[1,1,0]], # line with one omitted and one missing M-value\n...\t\t\t[[3,2],[2,6]] # line without any M-values\n...\t\t\t])\n\n&gt;&gt;&gt; w.record('linem1')\n\n&gt;&gt;&gt; w.close()\n</code></pre>\n<p>Shapefiles containing M-values can be examined in several ways:</p>\n<pre><code>&gt;&gt;&gt; r = shapefile.Reader('shapefiles/test/linem')\n\n&gt;&gt;&gt; r.mbox # the lower and upper bound of M-values in the shapefile\n[0.0, 3.0]\n\n&gt;&gt;&gt; r.shape(0).m # flat list of M-values\n[0.0, None, 3.0, None, 0.0, None, None]\n</code></pre>\n<p><strong>Shapefiles with elevation (Z) values</strong></p>\n<p>Elevation shape types are shapes that include an elevation value at each vertex, for instance elevation from a GPS device.\nShapes with elevation (Z) values are added with the following methods: \"pointz\", \"multipointz\", \"linez\", and \"polygonz\".\nThe Z-values are specified by adding a third Z value to each XY coordinate. Z-values do not support the concept of missing data,\nbut if you omit the third Z-coordinate it will default to 0. Note that Z-type shapes also support measurement (M) values added\nas a fourth M-coordinate. This too is optional.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/linez')\n&gt;&gt;&gt; w.field('name', 'C')\n\n&gt;&gt;&gt; w.linez([\n...\t\t\t[[1,5,18],[5,5,20],[5,1,22],[3,3],[1,1]], # line with some omitted Z-values\n...\t\t\t[[3,2],[2,6]], # line without any Z-values\n...\t\t\t[[3,2,15,0],[2,6,13,3],[1,9,14,2]] # line with both Z- and M-values\n...\t\t\t])\n\n&gt;&gt;&gt; w.record('linez1')\n\n&gt;&gt;&gt; w.close()\n</code></pre>\n<p>To examine a Z-type shapefile you can do:</p>\n<pre><code>&gt;&gt;&gt; r = shapefile.Reader('shapefiles/test/linez')\n\n&gt;&gt;&gt; r.zbox # the lower and upper bound of Z-values in the shapefile\n[0.0, 22.0]\n\n&gt;&gt;&gt; r.shape(0).z # flat list of Z-values\n[18.0, 20.0, 22.0, 0.0, 0.0, 0.0, 0.0, 15.0, 13.0, 14.0]\n</code></pre>\n<p><strong>3D MultiPatch Shapefiles</strong></p>\n<p>Multipatch shapes are useful for storing composite 3-Dimensional objects.\nA MultiPatch shape represents a 3D object made up of one or more surface parts.\nEach surface in \"parts\" is defined by a list of XYZM values (Z and M values optional), and its corresponding type is\ngiven in the \"partTypes\" argument. The part type decides how the coordinate sequence is to be interpreted, and can be one\nof the following module constants: TRIANGLE_STRIP, TRIANGLE_FAN, OUTER_RING, INNER_RING, FIRST_RING, or RING.\nFor instance, a TRIANGLE_STRIP may be used to represent the walls of a building, combined with a TRIANGLE_FAN to represent\nits roof:</p>\n<pre><code>&gt;&gt;&gt; from shapefile import TRIANGLE_STRIP, TRIANGLE_FAN\n\n&gt;&gt;&gt; w = shapefile.Writer('shapefiles/test/multipatch')\n&gt;&gt;&gt; w.field('name', 'C')\n\n&gt;&gt;&gt; w.multipatch([\n...\t\t\t\t [[0,0,0],[0,0,3],[5,0,0],[5,0,3],[5,5,0],[5,5,3],[0,5,0],[0,5,3],[0,0,0],[0,0,3]], # TRIANGLE_STRIP for house walls\n...\t\t\t\t [[2.5,2.5,5],[0,0,3],[5,0,3],[5,5,3],[0,5,3],[0,0,3]], # TRIANGLE_FAN for pointed house roof\n...\t\t\t\t ],\n...\t\t\t\t partTypes=[TRIANGLE_STRIP, TRIANGLE_FAN]) # one type for each part\n\n&gt;&gt;&gt; w.record('house1')\n\n&gt;&gt;&gt; w.close()\n</code></pre>\n<p>For an introduction to the various multipatch part types and examples of how to create 3D MultiPatch objects see <a href=\"http://downloads.esri.com/support/whitepapers/ao_/J9749_MultiPatch_Geometry_Type.pdf\" rel=\"nofollow\">this\nESRI White Paper</a>.</p>\n<h2>Working with Large Shapefiles</h2>\n<p>Despite being a lightweight library, PyShp is designed to be able to read and write\nshapefiles of any size, allowing you to work with hundreds of thousands or even millions\nof records and complex geometries.</p>\n<p>When first creating the Reader class, the library only reads the header information\nand leaves the rest of the file contents alone. Once you call the records() and shapes()\nmethods however, it will attempt to read the entire file into memory at once.\nFor very large files this can result in MemoryError. So when working with large files\nit is recommended to use instead the iterShapes(), iterRecords(), or iterShapeRecords()\nmethods instead. These iterate through the file contents one at a time, enabling you to loop\nthrough them while keeping memory usage at a minimum.</p>\n<pre><code>&gt;&gt;&gt; for shape in sf.iterShapes():\n...     # do something here\n...     pass\n\n&gt;&gt;&gt; for rec in sf.iterRecords():\n...     # do something here\n...     pass\n\n&gt;&gt;&gt; for shapeRec in sf.iterShapeRecords():\n...     # do something here\n...     pass\n\n&gt;&gt;&gt; for shapeRec in sf: # same as iterShapeRecords()\n...     # do something here\n...     pass\n</code></pre>\n<p>The shapefile Writer class uses a similar streaming approach to keep memory\nusage at a minimum. The library takes care of this under-the-hood by immediately\nwriting each geometry and record to disk the moment they\nare added using shape() or record(). Once the writer is closed, exited, or garbage\ncollected, the final header information is calculated and written to the beginning of\nthe file.</p>\n<p>This means that as long as you are able to iterate through a source file without having\nto load everything into memory, such as a large CSV table or a large shapefile, you can\nprocess and write any number of items, and even merge many different source files into a single\nlarge shapefile. If you need to edit or undo any of your writing you would have to read the\nfile back in, one record at a time, make your changes, and write it back out.</p>\n<h2>Unicode and Shapefile Encodings</h2>\n<p>PyShp has full support for unicode and shapefile encodings, so you can always expect to be working\nwith unicode strings in shapefiles that have text fields.\nMost shapefiles are written in UTF-8 encoding, PyShp's default encoding, so in most cases you don't\nhave to specify the encoding. For reading shapefiles in any other encoding, such as Latin-1, just\nsupply the encoding option when creating the Reader class.</p>\n<pre><code>&gt;&gt;&gt; r = shapefile.Reader(\"shapefiles/test/latin1.shp\", encoding=\"latin1\")\n&gt;&gt;&gt; r.record(0) == [2, u'\u00d1and\u00fa']\nTrue\n</code></pre>\n<p>Once you have loaded the shapefile, you may choose to save it using another more supportive encoding such\nas UTF-8. Provided the new encoding supports the characters you are trying to write, reading it back in\nshould give you the same unicode string you started with.</p>\n<pre><code>&gt;&gt;&gt; w = shapefile.Writer(\"shapefiles/test/latin_as_utf8.shp\", encoding=\"utf8\")\n&gt;&gt;&gt; w.fields = r.fields[1:]\n&gt;&gt;&gt; w.record(*r.record(0))\n&gt;&gt;&gt; w.null()\n&gt;&gt;&gt; w.close()\n\n&gt;&gt;&gt; r = shapefile.Reader(\"shapefiles/test/latin_as_utf8.shp\", encoding=\"utf8\")\n&gt;&gt;&gt; r.record(0) == [2, u'\u00d1and\u00fa']\nTrue\n</code></pre>\n<p>If you supply the wrong encoding and the string is unable to be decoded, PyShp will by default raise an\nexception. If however, on rare occasion, you are unable to find the correct encoding and want to ignore\nor replace encoding errors, you can specify the \"encodingErrors\" to be used by the decode method. This\napplies to both reading and writing.</p>\n<pre><code>&gt;&gt;&gt; r = shapefile.Reader(\"shapefiles/test/latin1.shp\", encoding=\"ascii\", encodingErrors=\"replace\")\n&gt;&gt;&gt; r.record(0) == [2, u'\ufffdand\ufffd']\nTrue\n</code></pre>\n<h1>Testing</h1>\n<p>The testing framework is doctest, which are located in this file README.md.\nIn the same folder as README.md and shapefile.py, from the command line run</p>\n<pre><code>$ python shapefile.py\n</code></pre>\n<p>Linux/Mac and similar platforms will need to run <code>$ dos2unix README.md</code> in order\ncorrect line endings in README.md.</p>\n<h1>Contributors</h1>\n<pre><code>Atle Frenvik Sveen\nBas Couwenberg\nCasey Meisenzahl\nCharles Arnold\nDavid A. Riggs\ndavidh-ssec\nEvan Heidtmann\nezcitron\ngeospatialpython\nHannes\nIgnacio Martinez Vazquez\nJason Moujaes\nKarim Bahgat\nKyle Kelley\nLouis Tiao\nMarcin Cuprjak\nMicah Cochran\nMichael Davis\nMichal \u010ciha\u0159\nMike Toews\nNilo\npakoun\nPaulo Ernesto\nRaynor Vliegendhart\nRazzi Abuissa\nRoss Rogers\nRyan Brideau\nTobias Megies\nTommi Penttinen\nUli K\u00f6hler\nZac Miller\n</code></pre>\n\n          </div>"}, "last_serial": 4826813, "releases": {"1.0.5": [{"comment_text": "", "digests": {"md5": "94e3365595be166331fdaedd7377631d", "sha256": "4c2e4a7f8c8994cf89c0166bfbdfd8335d3d2d4c1f9207c0a0c7df6df91229a0"}, "downloads": -1, "filename": "pyshp-1.0.5-py2.7.egg", "has_sig": false, "md5_digest": "94e3365595be166331fdaedd7377631d", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 38146, "upload_time": "2011-09-02T21:19:11", "upload_time_iso_8601": "2011-09-02T21:19:11.331675Z", "url": "https://files.pythonhosted.org/packages/35/e4/f3202d9a935a30d628f1e869a535a7fe3c330c7c1afc9ba1f081bcdb9064/pyshp-1.0.5-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "4549091975758208bfe755ecbb1a5c81", "sha256": "f10a59b955e8d71c8391916bf13ef015b4e89322de4559249ee0c04cd0b94bdc"}, "downloads": -1, "filename": "pyshp-1.0.5.zip", "has_sig": false, "md5_digest": "4549091975758208bfe755ecbb1a5c81", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27592, "upload_time": "2011-09-02T21:18:14", "upload_time_iso_8601": "2011-09-02T21:18:14.779459Z", "url": "https://files.pythonhosted.org/packages/d9/68/38c3c5e422d54d61dc17b005592b69c4cf242458bcfa6d865efa0b6a68aa/pyshp-1.0.5.zip", "yanked": false}], "1.0.6": [{"comment_text": "", "digests": {"md5": "b17b867a6e8a6e7f136d10aaadfae14d", "sha256": "90a363d591cef62dd63c60a8f276120110bd88f651924bed0f16e2cbdcadcc98"}, "downloads": -1, "filename": "pyshp-1.0.6-py2.7.egg", "has_sig": false, "md5_digest": "b17b867a6e8a6e7f136d10aaadfae14d", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 38197, "upload_time": "2011-09-05T18:22:44", "upload_time_iso_8601": "2011-09-05T18:22:44.693773Z", "url": "https://files.pythonhosted.org/packages/7d/14/9fd7628b12b6bff6b82afd231457dc50f927bee4d547190cd2421eea4531/pyshp-1.0.6-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "03dd68f7b48913fff036ab1142867ca3", "sha256": "8fa2482b4c1d71ca5dd73b9ece85f94781636d4a74a87e24eed36c7a11dc538b"}, "downloads": -1, "filename": "pyshp-1.0.6.zip", "has_sig": false, "md5_digest": "03dd68f7b48913fff036ab1142867ca3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27628, "upload_time": "2011-09-05T18:22:12", "upload_time_iso_8601": "2011-09-05T18:22:12.524689Z", "url": "https://files.pythonhosted.org/packages/ea/bb/fce489a4338dd4a37ad03776c5ec5b1f9ea2d74ecad9cc521af631c3cf48/pyshp-1.0.6.zip", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "e5dc20d8dd4d5c5262277a997adcec7e", "sha256": "e6e8b33f528d7be6e266d46592127b5c35b607325d7f6975096fb8596df9cfed"}, "downloads": -1, "filename": "pyshp-1.1.0-py2.7.egg", "has_sig": false, "md5_digest": "e5dc20d8dd4d5c5262277a997adcec7e", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 41504, "upload_time": "2011-09-22T05:25:15", "upload_time_iso_8601": "2011-09-22T05:25:15.748035Z", "url": "https://files.pythonhosted.org/packages/2f/05/430a903f94a78ec5668a8580ea8a1153d13167c441e16edc1373e4eee238/pyshp-1.1.0-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "da89ce9e9124f29fd7f0a8b1fbe995f4", "sha256": "525eb76a34f1dbdb4024982bd9c4dd47237031f3a4165f9c49767c2945558a02"}, "downloads": -1, "filename": "pyshp-1.1.0.zip", "has_sig": false, "md5_digest": "da89ce9e9124f29fd7f0a8b1fbe995f4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 183520, "upload_time": "2011-09-22T05:23:53", "upload_time_iso_8601": "2011-09-22T05:23:53.192083Z", "url": "https://files.pythonhosted.org/packages/8f/fb/5b81d357a69c81975f7563f653e5a2b8315af9d67164137e5525d0d5c826/pyshp-1.1.0.zip", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "721f915105be8f56eaa0eb54a574d4b0", "sha256": "c5d5c8088a70dfc2fd500ae5cbd37735ef8f4ff4f2635f958255781852faf905"}, "downloads": -1, "filename": "pyshp-1.1.3-py2.7.egg", "has_sig": false, "md5_digest": "721f915105be8f56eaa0eb54a574d4b0", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 28829, "upload_time": "2011-09-27T04:58:08", "upload_time_iso_8601": "2011-09-27T04:58:08.533422Z", "url": "https://files.pythonhosted.org/packages/aa/53/d75eb9a28d12dc9dad73bedd72260917cfb0c885f480454fa46e47e27968/pyshp-1.1.3-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "3f1c716ba602f71b495c25a8b27d20a7", "sha256": "615ff3ed290305a6427e19df4fc3a494b1b7c328103e07079e649d09ad8f5408"}, "downloads": -1, "filename": "pyshp-1.1.3.zip", "has_sig": false, "md5_digest": "3f1c716ba602f71b495c25a8b27d20a7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 184036, "upload_time": "2011-09-27T04:58:00", "upload_time_iso_8601": "2011-09-27T04:58:00.459166Z", "url": "https://files.pythonhosted.org/packages/c6/ea/f77e19cf654e99766db49f107b3f77d4d8e486925d5aaa9f003d6001b888/pyshp-1.1.3.zip", "yanked": false}], "1.1.4": [{"comment_text": "", "digests": {"md5": "1abbbee8ffe83e24f7a49b351574c995", "sha256": "e2c6f1f6d8b549a632b3ea976a245ac7fb2fb152fe1da47f5dfff486bf728df2"}, "downloads": -1, "filename": "pyshp-1.1.4-py2.7.egg", "has_sig": false, "md5_digest": "1abbbee8ffe83e24f7a49b351574c995", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 29562, "upload_time": "2011-10-03T06:43:59", "upload_time_iso_8601": "2011-10-03T06:43:59.337075Z", "url": "https://files.pythonhosted.org/packages/9c/2a/61f222f3044e61dee810b81999e55cedfe62c90b17495ec20d05a89df526/pyshp-1.1.4-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "67153ea40a3d162ce5946b23b8f67d6a", "sha256": "8a54365252cf56f09341f28aee0ec6b3ef1ce83f37ace5cc272e50b63309ac81"}, "downloads": -1, "filename": "pyshp-1.1.4.zip", "has_sig": false, "md5_digest": "67153ea40a3d162ce5946b23b8f67d6a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 183836, "upload_time": "2011-10-03T06:43:47", "upload_time_iso_8601": "2011-10-03T06:43:47.170782Z", "url": "https://files.pythonhosted.org/packages/0d/34/8c7df11cd1c46022a3860038f2bf5c015fc9912a9a90cf8297fcb035e9f5/pyshp-1.1.4.zip", "yanked": false}], "1.1.7": [{"comment_text": "", "digests": {"md5": "1404f804c0eabe101eee57781e31c6dd", "sha256": "d8ee8dd95550c0ff80be37ad11e8b8c36b8420b6ee0d00d6e5c68ae4d7e055fa"}, "downloads": -1, "filename": "pyshp-1.1.7-py2.7.egg", "has_sig": false, "md5_digest": "1404f804c0eabe101eee57781e31c6dd", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 32741, "upload_time": "2013-06-23T19:34:25", "upload_time_iso_8601": "2013-06-23T19:34:25.921915Z", "url": "https://files.pythonhosted.org/packages/18/ec/9327222ad784c82b0ae84bb049290b28ce1ee24dd61e6c4fa96034919891/pyshp-1.1.7-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "2a6ab78d48308000f1ad7e73f20227f4", "sha256": "f0785f589cf3fa94f13a2709f0ad950cca6566774f8e96f874edb2c0a7034c7c"}, "downloads": -1, "filename": "pyshp-1.1.7-py3.2.egg", "has_sig": false, "md5_digest": "2a6ab78d48308000f1ad7e73f20227f4", "packagetype": "bdist_egg", "python_version": "3.2", "requires_python": null, "size": 33235, "upload_time": "2013-06-23T19:42:05", "upload_time_iso_8601": "2013-06-23T19:42:05.655166Z", "url": "https://files.pythonhosted.org/packages/85/a6/f9cfe5364249a0c34c9459135813350d92ed896f2e5ca5ed5e6452e1ab8a/pyshp-1.1.7-py3.2.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "8372c3b1414f92bbd72c2707c28795a5", "sha256": "8fb6988282a27d9e6ae50816b6fee644a62ff05b07808c64423a97794d513551"}, "downloads": -1, "filename": "pyshp-1.1.7.tar.gz", "has_sig": false, "md5_digest": "8372c3b1414f92bbd72c2707c28795a5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47017, "upload_time": "2013-06-23T19:35:15", "upload_time_iso_8601": "2013-06-23T19:35:15.797189Z", "url": "https://files.pythonhosted.org/packages/4f/6a/0fb71cf32e07c07120c971588856002e6a6561ff67cdc2a7c800290a7df3/pyshp-1.1.7.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "b44b739267f7871e0efd1f9b5868b952", "sha256": "2632771a0abfb763620f95695712b36cbd41f704a92fc5a58be8fa4172d73984"}, "downloads": -1, "filename": "pyshp-1.1.7.zip", "has_sig": false, "md5_digest": "b44b739267f7871e0efd1f9b5868b952", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58690, "upload_time": "2013-06-23T19:34:39", "upload_time_iso_8601": "2013-06-23T19:34:39.574950Z", "url": "https://files.pythonhosted.org/packages/a7/47/26fc798c72312b74ed06da13cbaeb6aacb903f7a6bfb67457778ad3cf41f/pyshp-1.1.7.zip", "yanked": false}], "1.1.8": [{"comment_text": "", "digests": {"md5": "0a9c3eaa782c6b95e91eb08e4d5454b9", "sha256": "a3aa489205b7ea4933aa005bcdb5e7341a0a0190d023128c5590e0b391f02ca4"}, "downloads": -1, "filename": "pyshp-1.1.8-py2.7.egg", "has_sig": false, "md5_digest": "0a9c3eaa782c6b95e91eb08e4d5454b9", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 33233, "upload_time": "2013-07-02T16:36:10", "upload_time_iso_8601": "2013-07-02T16:36:10.689697Z", "url": "https://files.pythonhosted.org/packages/41/72/8e17e9085090320206f5471d2831d6df03cf651a47745921ea4b1cd83c7f/pyshp-1.1.8-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "04908cbd64302f1c2c8b022fcfd3fc1a", "sha256": "2b2bcef4c941c9aeaeb91333347ab353dfd83d16a8f62116c331ad85bc8902aa"}, "downloads": -1, "filename": "pyshp-1.1.8-py3.2.egg", "has_sig": false, "md5_digest": "04908cbd64302f1c2c8b022fcfd3fc1a", "packagetype": "bdist_egg", "python_version": "3.2", "requires_python": null, "size": 33730, "upload_time": "2013-07-02T16:36:17", "upload_time_iso_8601": "2013-07-02T16:36:17.020716Z", "url": "https://files.pythonhosted.org/packages/0c/45/ad23342fbfb2bba82c307a6c3b75a2e98bc83855bd8417e3defddd5916bd/pyshp-1.1.8-py3.2.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "d3eb5fe70de2c3019cb8385fc367ca92", "sha256": "97742b8855090b50dd3e4a9c510024e31a6b8b48da6b642d3e3ad28732710bd8"}, "downloads": -1, "filename": "pyshp-1.1.8.tar.gz", "has_sig": false, "md5_digest": "d3eb5fe70de2c3019cb8385fc367ca92", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 48766, "upload_time": "2013-07-02T16:36:04", "upload_time_iso_8601": "2013-07-02T16:36:04.205167Z", "url": "https://files.pythonhosted.org/packages/27/92/7c2db73be5d32d1faed842ca5a7796641d7d36c21d8d86200750c14546dc/pyshp-1.1.8.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "b75768d467c1ca88fcbd9d7d75d62018", "sha256": "4c9c8468e152c5e773cc46cddf591074d5ad0df4bb3f5393e6403e5a7788cf7d"}, "downloads": -1, "filename": "pyshp-1.1.8.zip", "has_sig": false, "md5_digest": "b75768d467c1ca88fcbd9d7d75d62018", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 60372, "upload_time": "2013-07-02T16:36:01", "upload_time_iso_8601": "2013-07-02T16:36:01.706235Z", "url": "https://files.pythonhosted.org/packages/8c/1f/d8013ab5ab369e83204fefca929da9acc8114f5d15c0df1ea1f0fe309b7a/pyshp-1.1.8.zip", "yanked": false}], "1.1.9": [{"comment_text": "", "digests": {"md5": "0d6095d8a822745f9c8b8c48a7b0a5ec", "sha256": "2bec94ca576860418b9cc6501abf1a0617921b301bfc7be82cc49b97903381bb"}, "downloads": -1, "filename": "pyshp-1.1.9-py2.7.egg", "has_sig": false, "md5_digest": "0d6095d8a822745f9c8b8c48a7b0a5ec", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 33931, "upload_time": "2013-07-27T21:09:47", "upload_time_iso_8601": "2013-07-27T21:09:47.455153Z", "url": "https://files.pythonhosted.org/packages/21/99/fc1fcdd6966719171d59392944ec127c3a1a52b24a2f18be7b764453e093/pyshp-1.1.9-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "25eb1ac17bd49c64babc69329d6addc4", "sha256": "575669332c132bcad25f3c063fa9bc7f3bef1772c4f96b5d9080c8db2155f203"}, "downloads": -1, "filename": "pyshp-1.1.9-py3.2.egg", "has_sig": false, "md5_digest": "25eb1ac17bd49c64babc69329d6addc4", "packagetype": "bdist_egg", "python_version": "3.2", "requires_python": null, "size": 34442, "upload_time": "2013-07-27T21:09:53", "upload_time_iso_8601": "2013-07-27T21:09:53.512521Z", "url": "https://files.pythonhosted.org/packages/73/23/5dce5a890e00469686708cd0b16ce4912a1340ea63c085263bb84c62ca0b/pyshp-1.1.9-py3.2.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "415d7bc6668ebf3ed8d28541c37aad93", "sha256": "6d88007c9158b28856b1b61bb696668f673a9050ae21255f066b293380dc81af"}, "downloads": -1, "filename": "pyshp-1.1.9.tar.gz", "has_sig": false, "md5_digest": "415d7bc6668ebf3ed8d28541c37aad93", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 50620, "upload_time": "2013-07-27T21:09:40", "upload_time_iso_8601": "2013-07-27T21:09:40.998018Z", "url": "https://files.pythonhosted.org/packages/1d/73/e2d7bb82a8c6a2f4a81ce3774c5c4fa78f86ca8828be0cfb4bf3ec5692fd/pyshp-1.1.9.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "ce245620ce9b0f1c0c80018b90e6b4b0", "sha256": "1e391df5818347588396e56bcd7cc69c44fbdece55c5100d5d3342f4b29e8d4a"}, "downloads": -1, "filename": "pyshp-1.1.9.zip", "has_sig": false, "md5_digest": "ce245620ce9b0f1c0c80018b90e6b4b0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62577, "upload_time": "2013-07-27T21:09:36", "upload_time_iso_8601": "2013-07-27T21:09:36.722332Z", "url": "https://files.pythonhosted.org/packages/aa/c2/4591baf1fb02625b44b7ee788909f87b388a35b7715422cde003a3b45075/pyshp-1.1.9.zip", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "3af141343620cf2d5840fbb221e29ebf", "sha256": "e11bc95bdda086edc573349a138c502610ed36f045d0fd11bc296961f1f71522"}, "downloads": -1, "filename": "pyshp-1.2.0-py2.7.egg", "has_sig": false, "md5_digest": "3af141343620cf2d5840fbb221e29ebf", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 34243, "upload_time": "2013-09-06T02:09:14", "upload_time_iso_8601": "2013-09-06T02:09:14.282701Z", "url": "https://files.pythonhosted.org/packages/ea/83/649bc72ef657520febf2440ba1d2bc769911ac26594cd77c013d9eafdf08/pyshp-1.2.0-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b97e9b21e04bd1fc2f98fec6b088febf", "sha256": "d97dc0cb471366ec08c39fc4ee8441646b5dbd1eff8adcef55c61fc9ffb06619"}, "downloads": -1, "filename": "pyshp-1.2.0-py3.2.egg", "has_sig": false, "md5_digest": "b97e9b21e04bd1fc2f98fec6b088febf", "packagetype": "bdist_egg", "python_version": "3.2", "requires_python": null, "size": 34763, "upload_time": "2013-09-06T02:09:21", "upload_time_iso_8601": "2013-09-06T02:09:21.606348Z", "url": "https://files.pythonhosted.org/packages/13/d8/be9adfe5bd2686df7d9acc00dce7f0ee86ff31c661262dfe31f5d94aa6f3/pyshp-1.2.0-py3.2.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "9075f34109f0bb4b45a90fd1fb5db94b", "sha256": "16e9a9b5caae5b69149c7be09415381b61af4f85f2087d08c0698c75e70000e7"}, "downloads": -1, "filename": "pyshp-1.2.0.tar.gz", "has_sig": false, "md5_digest": "9075f34109f0bb4b45a90fd1fb5db94b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58993, "upload_time": "2013-09-06T02:09:08", "upload_time_iso_8601": "2013-09-06T02:09:08.968607Z", "url": "https://files.pythonhosted.org/packages/3e/a0/1c763c5809faa97cbfc1fb7ad31f470da897d130c473032c2c8f22bec253/pyshp-1.2.0.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "1ab1a1c76740636eeaa3af5889c033ea", "sha256": "5975e46808fd9c804774765984330fb695822f096554bb0eda16cf5547a4690c"}, "downloads": -1, "filename": "pyshp-1.2.0.zip", "has_sig": false, "md5_digest": "1ab1a1c76740636eeaa3af5889c033ea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63934, "upload_time": "2013-09-06T02:09:06", "upload_time_iso_8601": "2013-09-06T02:09:06.269052Z", "url": "https://files.pythonhosted.org/packages/7b/63/624ab15ec0504ae0ef4e1de4f48ec49baf277dcd0e18640f8a634a8b5483/pyshp-1.2.0.zip", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "60f092c8f27a9e672fc0e3ad8cde44db", "sha256": "35b65f6e807723746030c2af7caffc5b30298ab272bbf7c0e2687b0ce81e62cb"}, "downloads": -1, "filename": "pyshp-1.2.1-py2.7.egg", "has_sig": false, "md5_digest": "60f092c8f27a9e672fc0e3ad8cde44db", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 34514, "upload_time": "2014-05-12T03:02:52", "upload_time_iso_8601": "2014-05-12T03:02:52.022156Z", "url": "https://files.pythonhosted.org/packages/29/ec/c866a53668c89b0f1d54c0acad97dfe47ce57aeb5f01735aff7a92f4274f/pyshp-1.2.1-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "ac1dffea96e676030e99b4cbd54e3cc2", "sha256": "89883764ade2d4071dadc8589dcc941bcd49fad0c143f07425cb2ed525723819"}, "downloads": -1, "filename": "pyshp-1.2.1-py3.2.egg", "has_sig": false, "md5_digest": "ac1dffea96e676030e99b4cbd54e3cc2", "packagetype": "bdist_egg", "python_version": "3.2", "requires_python": null, "size": 35043, "upload_time": "2014-05-12T03:02:59", "upload_time_iso_8601": "2014-05-12T03:02:59.849055Z", "url": "https://files.pythonhosted.org/packages/35/84/08a5a3a12a3f767a3dde8cad4c461f86cfdc9f09d6786b1beaf368960259/pyshp-1.2.1-py3.2.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "156654b3c7878c4a31d27e4b9dc34377", "sha256": "eb4a1999f7c7bd573f3c8920344f50bd86221114980f07f521858d23654a33b0"}, "downloads": -1, "filename": "pyshp-1.2.1.tar.gz", "has_sig": false, "md5_digest": "156654b3c7878c4a31d27e4b9dc34377", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59218, "upload_time": "2014-05-12T03:02:48", "upload_time_iso_8601": "2014-05-12T03:02:48.162134Z", "url": "https://files.pythonhosted.org/packages/20/98/18103bcbca6086aad96f7386d05486303fbca45ad852baa9e3c2dd69930b/pyshp-1.2.1.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "2a6ea8f28bd104393b8618e855fb68d4", "sha256": "c4bb7fa3446ffc79bc2d136c8b2c0bdc5aba5495c7b556e7627290271096ba44"}, "downloads": -1, "filename": "pyshp-1.2.1.zip", "has_sig": false, "md5_digest": "2a6ea8f28bd104393b8618e855fb68d4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64160, "upload_time": "2014-05-12T03:02:44", "upload_time_iso_8601": "2014-05-12T03:02:44.681142Z", "url": "https://files.pythonhosted.org/packages/f4/20/d97172b34bc25b7495b7fe56e35dff00b8952aedb6cb5200569324f90fe4/pyshp-1.2.1.zip", "yanked": false}], "1.2.10": [{"comment_text": "", "digests": {"md5": "cff5b8530f747656f518526054c43eee", "sha256": "009e02b281d7f509c34d31aca3545334e45bea15136f3bb81a37b4d13e21f9bd"}, "downloads": -1, "filename": "pyshp-1.2.10.tar.gz", "has_sig": false, "md5_digest": "cff5b8530f747656f518526054c43eee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 176501, "upload_time": "2016-09-24T19:48:32", "upload_time_iso_8601": "2016-09-24T19:48:32.976988Z", "url": "https://files.pythonhosted.org/packages/c2/cc/1851049f2740d09c7bd8e4b464b1b78638723f6173e71d44aea12deca1f8/pyshp-1.2.10.tar.gz", "yanked": false}], "1.2.11": [{"comment_text": "", "digests": {"md5": "6734346e50ad4b6003318d00dff8da4c", "sha256": "8b4be2ec3d816067972e9ecc38526e9c45e9ee9b49b7fd94acfab9c0fc84fa63"}, "downloads": -1, "filename": "pyshp-1.2.11.tar.gz", "has_sig": false, "md5_digest": "6734346e50ad4b6003318d00dff8da4c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 192763, "upload_time": "2017-04-29T21:14:41", "upload_time_iso_8601": "2017-04-29T21:14:41.911091Z", "url": "https://files.pythonhosted.org/packages/31/a1/b4bc192188af5b761bb5dde39fde6c1439adef0dc63c62bcdacb215ace6a/pyshp-1.2.11.tar.gz", "yanked": false}], "1.2.12": [{"comment_text": "", "digests": {"md5": "63d33d151ac308f1db71ea0f22c30d8b", "sha256": "8dcd65e0aa2aa2951527ddb7339ea6e69023543d8a20a73fc51e2829b9ed6179"}, "downloads": -1, "filename": "pyshp-1.2.12.tar.gz", "has_sig": false, "md5_digest": "63d33d151ac308f1db71ea0f22c30d8b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 193089, "upload_time": "2017-08-24T14:58:09", "upload_time_iso_8601": "2017-08-24T14:58:09.484035Z", "url": "https://files.pythonhosted.org/packages/c8/ac/8e9adb8e0dadabbb3b708d38a83119ee42115d9f8fd88858261f5bec50f0/pyshp-1.2.12.tar.gz", "yanked": false}], "1.2.2": [{"comment_text": "", "digests": {"md5": "dc99cd3237f20894d5b9d445275390a6", "sha256": "0fb48d9fe8db5f6c8709c437cbb13bf8b44a31a47c79970f1d1397f56352b39f"}, "downloads": -1, "filename": "pyshp-1.2.2.tar.gz", "has_sig": false, "md5_digest": "dc99cd3237f20894d5b9d445275390a6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28707, "upload_time": "2015-06-22T03:03:59", "upload_time_iso_8601": "2015-06-22T03:03:59.768245Z", "url": "https://files.pythonhosted.org/packages/d0/b8/43638fae7e1fa75e428533453f03a5589a5cd1f2260ed20757399c6d7f9a/pyshp-1.2.2.tar.gz", "yanked": false}], "1.2.3": [{"comment_text": "", "digests": {"md5": "f857099a57f93830e0c72a31e9c506a8", "sha256": "e18cc19659dadc5ddaa891eb780a6958094da0cf105a1efe0f67e75b4fa1cdf9"}, "downloads": -1, "filename": "pyshp-1.2.3.tar.gz", "has_sig": false, "md5_digest": "f857099a57f93830e0c72a31e9c506a8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28708, "upload_time": "2015-06-22T04:11:09", "upload_time_iso_8601": "2015-06-22T04:11:09.512683Z", "url": "https://files.pythonhosted.org/packages/e1/90/f6a8734f6fbf31cc1d133e90c9dfa4ddf34fa6e387e44fbd79b0cf38a14e/pyshp-1.2.3.tar.gz", "yanked": false}], "1.2.9": [], "2.0.0": [{"comment_text": "", "digests": {"md5": "146077b7be9bd9bd4c82c9dcc5ebd0bd", "sha256": "dff308d52ac0f53a182c78b6a0e200997ed33bd847ca8d29e3f46e741012aa50"}, "downloads": -1, "filename": "pyshp-2.0.0.tar.gz", "has_sig": false, "md5_digest": "146077b7be9bd9bd4c82c9dcc5ebd0bd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 213054, "upload_time": "2018-11-05T04:18:36", "upload_time_iso_8601": "2018-11-05T04:18:36.875592Z", "url": "https://files.pythonhosted.org/packages/da/65/48606341aa058adcb596165c5047fc0df93c6a06d9ea1322059c9be78591/pyshp-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "e50e82c79a9cb9f705a30de876f7e01d", "sha256": "5a092adcb8c2cd1dbeab76b62695db9b8e6e1408e7c37cf49eb61c0dcc913d11"}, "downloads": -1, "filename": "pyshp-2.0.1.tar.gz", "has_sig": false, "md5_digest": "e50e82c79a9cb9f705a30de876f7e01d", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 2.7", "size": 214225, "upload_time": "2018-11-07T05:59:53", "upload_time_iso_8601": "2018-11-07T05:59:53.473581Z", "url": "https://files.pythonhosted.org/packages/08/3e/3bda7dfdbee0d7a22d38443f5cc8d154ff6d4701e615f4c07bf1ed003563/pyshp-2.0.1.tar.gz", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "b29cc19a2dc53e57ccd5bf78fb7f9323", "sha256": "e65c7f24d372b97d0920b864bbeb78322bb37b83f2606e2a2212631d5d51e5c0"}, "downloads": -1, "filename": "pyshp-2.1.0.tar.gz", "has_sig": false, "md5_digest": "b29cc19a2dc53e57ccd5bf78fb7f9323", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 2.7", "size": 215360, "upload_time": "2019-02-15T20:12:43", "upload_time_iso_8601": "2019-02-15T20:12:43.737978Z", "url": "https://files.pythonhosted.org/packages/27/16/3bf15aa864fb77845fab8007eda22c2bd67bd6c1fd13496df452c8c43621/pyshp-2.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b29cc19a2dc53e57ccd5bf78fb7f9323", "sha256": "e65c7f24d372b97d0920b864bbeb78322bb37b83f2606e2a2212631d5d51e5c0"}, "downloads": -1, "filename": "pyshp-2.1.0.tar.gz", "has_sig": false, "md5_digest": "b29cc19a2dc53e57ccd5bf78fb7f9323", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 2.7", "size": 215360, "upload_time": "2019-02-15T20:12:43", "upload_time_iso_8601": "2019-02-15T20:12:43.737978Z", "url": "https://files.pythonhosted.org/packages/27/16/3bf15aa864fb77845fab8007eda22c2bd67bd6c1fd13496df452c8c43621/pyshp-2.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:57 2020"}