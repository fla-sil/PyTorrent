{"info": {"author": "Suriyan Laohaprapanon, Gaurav Sood", "author_email": "suriyant@gmail.com, gsood07@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.5", "Topic :: Scientific/Engineering :: Information Analysis", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "allocator: Optimally Allocate Geographically Distributed Tasks\n==============================================================\n\n.. image:: https://travis-ci.org/soodoku/allocator.svg?branch=master\n    :target: https://travis-ci.org/soodoku/allocator\n.. image:: https://ci.appveyor.com/api/projects/status/qfvbu8h99ymtw2ub?svg=true\n    :target: https://ci.appveyor.com/project/soodoku/allocator\n.. image:: https://img.shields.io/pypi/v/allocator.svg\n    :target: https://pypi.python.org/pypi/allocator\n\nHow can we efficiently collect data from geographically distributed locations? If the data \ncollection is being crowd-sourced, then we may want to exploit the fact that workers\nare geographically distributed. One simple heuristic to do so is to order the locations by \ndistance for each worker (with some task registration backend). If you have hired \nworkers (or rented drones) who you can send to different locations, then you must split the tasks \nacross workers (drones), and plan the 'shortest' routes for each, ala the Traveling Salesman \nProblem (TSP). This is a problem that companies like Fedex etc. solve all the time. Since there \nare no computationally feasible solutions for solving for the global minimum, one heuristic solution \nis to split the locations into clusters of points that are close to each other (ideally, \nwe want the clusters to be 'balanced'), and then to estimate a TSP solution for each cluster. \n\nThe package provides a simple way to implement these solutions. Broadly, it provides three kinds of functions:\n\n1. **Sort by Distance:** Produces an ordered list of workers for each point or an ordered list of points \n    for each worker.\n\n2. **Cluster the Points:** Clusters the points into *n_worker* groups.\n\n3. **Shortest Path:** Order points within a cluster (or any small number of points) into a path or itinerary. \n\nThe package also provides access to three different kinds of distance functions for calculating the distance matrices\nthat underlie these functions: \n\n1. **Euclidean Distance:** use option ``-d euclidean``; similar to the Haversine distance within the same `UTM zone <https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system>`__)\n\n2. **Haversine Distance:** use option ``-d haversine``. \n\n3. **OSRM Distance:** use option ``-d osrm``. Neither Haversine nor Euclidean distance take account of the actual road network or the traffic. To use actual travel time, use `Open Source Routing Machine API <http://project-osrm.org/docs/v5.7.0/api/?language=Python#table-service>`__ A maximum number of 100 points can be passed to the function if we use the public server. However, you can set up your own private OSRM server with ``--max-table-size`` to specific the maximum number of points.\n\n4. **Google Distance Matrix API:**. use option ``-d google``. This option available in ``sort_by_distane`` and ``cluster_kahip`` only due to Google Distance Matrix API has very usage limits. Please look at the limitations `here. <https://developers.google.com/maps/documentation/distance-matrix/usage-limits>`__\n\nRelated Package\n^^^^^^^^^^^^^^^\nTo sample locations randomly on the streets, check out `geo_sampling <https://github.com/soodoku/geo_sampling>`__.\n\nApplication\n^^^^^^^^^^^^^^^\nMissing Women on the streets of Delhi. See `women count <https://github.com/soodoku/women-count>`__\n\nInstall\n-------\n\n::\n\n    pip install allocator\n\nFunctions\n---------\n\n1. `Sort By Distance <allocator/sort_by_distance.py>`__\n    \n2. **Cluster**\n    \n    Cluster data collection locations using k-means (clustering) or KaHIP (graph partitioning). To check which of the algorithms produces more cohesive, balanced clusters,\n    run `Compare K-means to KaHIP <allocator/compare_kahip_kmeans.py>`__\n    \n    a. `k-means <allocator/cluster_kmeans.py>`__\n\n        **Examples:**\n\n        ::\n\n            python -m allocator.cluster_kmeans -n 10 allocator/examples/chonburi-roads-1k.csv --plot\n\n\n    b. `KaHIP allocator <allocator/cluster_kahip.py>`__\n\n\n3. **Shortest Path**\n\n    These function can be used find the estimated shortest path across all the locations in a cluster. We expose three different ways of getting the 'shortest' path, a) via MST (Christofides algorithm), b) via Google OR-Tools, b) Google Maps Directions API.\n\n    a. `Approximate TSP using MST <allocator/shortest_path_mst_tsp.py>`__\n\n    b. `Google OR Tools TSP solver Shortest path <allocator/shortest_path_ortools.py>`__\n\n    c. `Google Maps Directions API Shortest path <allocator/shortest_path_gm.py>`__ \n\n    d. `OSRM Trip API Shortest path <allocator/shortest_path_osrm.py>`__ \n\n\nDocumentation\n-------------\n\nDocumentation available at: https://allocator.readthedocs.io/en/latest/\n\nAuthors\n-------\n\nSuriyan Laohaprapanon and Gaurav Sood\n\nContributor Code of Conduct\n---------------------------\n\nThe project welcomes contributions from everyone! In fact, it depends on\nit. To maintain this welcoming atmosphere, and to collaborate in a fun\nand productive way, we expect contributors to the project to abide by\nthe `Contributor Code of\nConduct <http://contributor-covenant.org/version/1/0/0/>`__.\n\nLicense\n-------\n\nThe package is released under the `MIT\nLicense <https://opensource.org/licenses/MIT>`__.\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/soodoku/allocator", "keywords": "routing shortest path", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "allocator", "package_url": "https://pypi.org/project/allocator/", "platform": "", "project_url": "https://pypi.org/project/allocator/", "project_urls": {"Homepage": "https://github.com/soodoku/allocator"}, "release_url": "https://pypi.org/project/allocator/0.1.7/", "requires_dist": null, "requires_python": "", "summary": "Optimally Allocate Geographically Distributed Tasks", "version": "0.1.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/soodoku/allocator\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/soodoku/allocator.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2d321a69c13746fc4e47b6f8675417777b72ef90/68747470733a2f2f7472617669732d63692e6f72672f736f6f646f6b752f616c6c6f6361746f722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://ci.appveyor.com/project/soodoku/allocator\" rel=\"nofollow\"><img alt=\"https://ci.appveyor.com/api/projects/status/qfvbu8h99ymtw2ub?svg=true\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bce08691d618cdfda6e1824ce0f5cf16eb72a9b3/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f716676627538683939796d74773275623f7376673d74727565\"></a>\n<a href=\"https://pypi.python.org/pypi/allocator\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/allocator.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/55e63a473442841cbf5cc6921e863aa3efdd6803/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f616c6c6f6361746f722e737667\"></a>\n<p>How can we efficiently collect data from geographically distributed locations? If the data\ncollection is being crowd-sourced, then we may want to exploit the fact that workers\nare geographically distributed. One simple heuristic to do so is to order the locations by\ndistance for each worker (with some task registration backend). If you have hired\nworkers (or rented drones) who you can send to different locations, then you must split the tasks\nacross workers (drones), and plan the \u2018shortest\u2019 routes for each, ala the Traveling Salesman\nProblem (TSP). This is a problem that companies like Fedex etc. solve all the time. Since there\nare no computationally feasible solutions for solving for the global minimum, one heuristic solution\nis to split the locations into clusters of points that are close to each other (ideally,\nwe want the clusters to be \u2018balanced\u2019), and then to estimate a TSP solution for each cluster.</p>\n<p>The package provides a simple way to implement these solutions. Broadly, it provides three kinds of functions:</p>\n<ol>\n<li><dl>\n<dt><strong>Sort by Distance:</strong> Produces an ordered list of workers for each point or an ordered list of points</dt>\n<dd>for each worker.</dd>\n</dl>\n</li>\n<li><strong>Cluster the Points:</strong> Clusters the points into <em>n_worker</em> groups.</li>\n<li><strong>Shortest Path:</strong> Order points within a cluster (or any small number of points) into a path or itinerary.</li>\n</ol>\n<p>The package also provides access to three different kinds of distance functions for calculating the distance matrices\nthat underlie these functions:</p>\n<ol>\n<li><strong>Euclidean Distance:</strong> use option <tt><span class=\"pre\">-d</span> euclidean</tt>; similar to the Haversine distance within the same <a href=\"https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system\" rel=\"nofollow\">UTM zone</a>)</li>\n<li><strong>Haversine Distance:</strong> use option <tt><span class=\"pre\">-d</span> haversine</tt>.</li>\n<li><strong>OSRM Distance:</strong> use option <tt><span class=\"pre\">-d</span> osrm</tt>. Neither Haversine nor Euclidean distance take account of the actual road network or the traffic. To use actual travel time, use <a href=\"http://project-osrm.org/docs/v5.7.0/api/?language=Python#table-service\" rel=\"nofollow\">Open Source Routing Machine API</a> A maximum number of 100 points can be passed to the function if we use the public server. However, you can set up your own private OSRM server with <tt><span class=\"pre\">--max-table-size</span></tt> to specific the maximum number of points.</li>\n<li><strong>Google Distance Matrix API:</strong>. use option <tt><span class=\"pre\">-d</span> google</tt>. This option available in <tt>sort_by_distane</tt> and <tt>cluster_kahip</tt> only due to Google Distance Matrix API has very usage limits. Please look at the limitations <a href=\"https://developers.google.com/maps/documentation/distance-matrix/usage-limits\" rel=\"nofollow\">here.</a></li>\n</ol>\n<div id=\"related-package\">\n<h2>Related Package</h2>\n<p>To sample locations randomly on the streets, check out <a href=\"https://github.com/soodoku/geo_sampling\" rel=\"nofollow\">geo_sampling</a>.</p>\n</div>\n<div id=\"application\">\n<h2>Application</h2>\n<p>Missing Women on the streets of Delhi. See <a href=\"https://github.com/soodoku/women-count\" rel=\"nofollow\">women count</a></p>\n<div id=\"install\">\n<h3>Install</h3>\n<pre>pip install allocator\n</pre>\n</div>\n<div id=\"functions\">\n<h3>Functions</h3>\n<ol>\n<li><p><a href=\"allocator/sort_by_distance.py\" rel=\"nofollow\">Sort By Distance</a></p>\n</li>\n<li><p><strong>Cluster</strong></p>\n<blockquote>\n<p>Cluster data collection locations using k-means (clustering) or KaHIP (graph partitioning). To check which of the algorithms produces more cohesive, balanced clusters,\nrun <a href=\"allocator/compare_kahip_kmeans.py\" rel=\"nofollow\">Compare K-means to KaHIP</a></p>\n<ol>\n<li><p><a href=\"allocator/cluster_kmeans.py\" rel=\"nofollow\">k-means</a></p>\n<blockquote>\n<p><strong>Examples:</strong></p>\n<pre>python -m allocator.cluster_kmeans -n 10 allocator/examples/chonburi-roads-1k.csv --plot\n</pre>\n</blockquote>\n</li>\n<li><p><a href=\"allocator/cluster_kahip.py\" rel=\"nofollow\">KaHIP allocator</a></p>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p><strong>Shortest Path</strong></p>\n<blockquote>\n<p>These function can be used find the estimated shortest path across all the locations in a cluster. We expose three different ways of getting the \u2018shortest\u2019 path, a) via MST (Christofides algorithm), b) via Google OR-Tools, b) Google Maps Directions API.</p>\n<ol>\n<li><a href=\"allocator/shortest_path_mst_tsp.py\" rel=\"nofollow\">Approximate TSP using MST</a></li>\n<li><a href=\"allocator/shortest_path_ortools.py\" rel=\"nofollow\">Google OR Tools TSP solver Shortest path</a></li>\n<li><a href=\"allocator/shortest_path_gm.py\" rel=\"nofollow\">Google Maps Directions API Shortest path</a></li>\n<li><a href=\"allocator/shortest_path_osrm.py\" rel=\"nofollow\">OSRM Trip API Shortest path</a></li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</div>\n<div id=\"documentation\">\n<h3>Documentation</h3>\n<p>Documentation available at: <a href=\"https://allocator.readthedocs.io/en/latest/\" rel=\"nofollow\">https://allocator.readthedocs.io/en/latest/</a></p>\n</div>\n<div id=\"authors\">\n<h3>Authors</h3>\n<p>Suriyan Laohaprapanon and Gaurav Sood</p>\n</div>\n<div id=\"contributor-code-of-conduct\">\n<h3>Contributor Code of Conduct</h3>\n<p>The project welcomes contributions from everyone! In fact, it depends on\nit. To maintain this welcoming atmosphere, and to collaborate in a fun\nand productive way, we expect contributors to the project to abide by\nthe <a href=\"http://contributor-covenant.org/version/1/0/0/\" rel=\"nofollow\">Contributor Code of\nConduct</a>.</p>\n</div>\n<div id=\"license\">\n<h3>License</h3>\n<p>The package is released under the <a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\">MIT\nLicense</a>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6656356, "releases": {"0.1.6": [{"comment_text": "", "digests": {"md5": "2bb12b73f821e7a629bde79ebf23f210", "sha256": "11bf7d622db9e23ccb29ba4548d938904fd02babf2a7746c9beaae657a2d0eb5"}, "downloads": -1, "filename": "allocator-0.1.6.tar.gz", "has_sig": false, "md5_digest": "2bb12b73f821e7a629bde79ebf23f210", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25415352, "upload_time": "2017-07-16T01:01:52", "upload_time_iso_8601": "2017-07-16T01:01:52.172086Z", "url": "https://files.pythonhosted.org/packages/67/19/0e5ee85d7a4d2302486d19b4b8bfa9efed2b0b79eca60c85bb6a02567040/allocator-0.1.6.tar.gz", "yanked": false}], "0.1.7": [{"comment_text": "", "digests": {"md5": "db5685b67b160695ef8791cd10314a3c", "sha256": "a0941ebd7dde324231d2204d1c53d556ce0c11cf026130bbf3f441b5dd39364d"}, "downloads": -1, "filename": "allocator-0.1.7.tar.gz", "has_sig": false, "md5_digest": "db5685b67b160695ef8791cd10314a3c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25418348, "upload_time": "2017-07-16T06:25:04", "upload_time_iso_8601": "2017-07-16T06:25:04.078015Z", "url": "https://files.pythonhosted.org/packages/7a/4d/160163df199e40214f6f1939d38530c48384f9736320703896ca19aaf114/allocator-0.1.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "db5685b67b160695ef8791cd10314a3c", "sha256": "a0941ebd7dde324231d2204d1c53d556ce0c11cf026130bbf3f441b5dd39364d"}, "downloads": -1, "filename": "allocator-0.1.7.tar.gz", "has_sig": false, "md5_digest": "db5685b67b160695ef8791cd10314a3c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25418348, "upload_time": "2017-07-16T06:25:04", "upload_time_iso_8601": "2017-07-16T06:25:04.078015Z", "url": "https://files.pythonhosted.org/packages/7a/4d/160163df199e40214f6f1939d38530c48384f9736320703896ca19aaf114/allocator-0.1.7.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:19:25 2020"}