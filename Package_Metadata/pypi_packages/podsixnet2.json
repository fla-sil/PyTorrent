{"info": {"author": "Chris McCormick", "author_email": "chris@mccormick.cx", "bugtrack_url": null, "classifiers": [], "description": "PodSixNet - lightweight multiplayer networking library for Python games\n-----------------------------------------------------------------------\n\nPodSixNet (now called ``podsixnet2``) is a lightweight network layer\ndesigned to make it easy to write multiplayer games in Python. It uses\nPython's built in asyncore library and rencode.py (included) to\nasynchronously serialise network events and arbitrary data structures,\nand deliver them to your high level classes through simple callback\nmethods.\n\nEach class within your game client which wants to receive network\nevents, subclasses the ConnectionListener class and then implements\n``Network_*`` methods to catch specific user-defined events from the\nserver. You don't have to wait for buffers to fill, or check sockets for\nwaiting data or anything like that, just do ``connection.Pump()`` once\nper game loop and the library will handle everything else for you,\npassing off events to all classes that are listening. Sending data back\nto the server is just as easy, using ``connection.Send(mydata)``.\nLikewise on the server side, events are propagated to ``Network_*``\nmethod callbacks and data is sent back to clients with the\n``client.Send(mydata)`` method.\n\nThe `podsixnet2 mailing\nlist <http://groups.google.com/group/podsixnet>`__ is good for getting\nhelp from other users.\n\nFor users of the Construct game making environment for Windows, there is\na tutorial on doing multiplayer networking with podsixnet2,\n`here <http://www.scirra.com/forum/viewtopic.php?f=8&t=6299>`__. Thanks\nto Dave Chabo for contributing this tutorial.\n\nHere is `another tutorial by Julian\nMeyer <http://www.raywenderlich.com/38732/multiplayer-game-programming-for-teens-with-python>`__.\n\nInstall\n-------\n\n``pip install podsixnet2``\n\nor\n\n``easy_install podsixnet2``\n\nFrom source\n~~~~~~~~~~~\n\nFirst make sure you have `Python <http://python.org/>`__ 2.4 or greater\ninstalled (python 3 also works).\n\nNext you'll want to get the podsixnet2 source.\n\nThe module is found inside a subdirectory called podsixnet2 within the\ntop level folder. There's an ``__init__.py`` inside there, so you can\njust copy or symlink the podsixnet2 sub-directory into your own project\nand then do ``import podsixnet2``, or else you can run\n``sudo python setup.py install`` to install podsixnet2 into your Python\npath. Use ``sudo python setup.py develop`` if you want to stay up to\ndate with the cutting edge and still be able to svn/bzr up every now and\nthen.\n\nBy default podsixnet2 uses a binary encoder to transfer data over the\nnetwork, but it can optionally use the `JSON <http://json.org/>`__\nformat or other formats supported by a serialiser which has 'dumps' and\n'loads' methods. If you want to serialise your data using JSON you can\nchange the first line of Channel.py to 'from simplejson import dumps,\nloads' or use the built-in json library in Python 2.6 or higher. This\nwill allow you to write game clients in languages that can't read the\n'rencode' binary format, such as Javascript.\n\nExamples\n--------\n\nChat example:\n\n-  ``python examples/ChatServer.py``\n-  and a couple of instances of ``python examples/ChatClient.py``\n\nWhiteboard example:\n\n-  ``python examples/WhiteboardServer.py``\n-  and a couple of instances of ``python examples/WhiteboardClient.py``\n\nLagTime example (measures round-trip time from the server to the\nclient):\n\n-  ``python examples/LagTimeServer.py``\n-  and a couple of instances of ``python examples/LagTimeClient.py``\n\nQuick start - Server\n--------------------\n\nYou will need to subclass two classes in order to make your own server.\nEach time a client connects, a new Channel based class will be created,\nso you should subclass Channel to make your own\nserver-representation-of-a-client class like this:\n\n.. code:: python\n\n    from podsixnet2.Channel import Channel\n\n    class ClientChannel(Channel):\n\n        def Network(self, data):\n            print data\n\n        def Network_myaction(self, data):\n            print \"myaction:\", data\n\nWhenever the client does ``connection.Send(mydata)``, the ``Network()``\nmethod will be called. The method ``Network_myaction()`` will only be\ncalled if your data has a key called 'action' with a value of\n\"myaction\". In other words if it looks something like this:\n\n.. code:: python\n\n    data = {\"action\": \"myaction\", \"blah\": 123, ... }\n\nNext you need to subclass the Server class like this:\n\n.. code:: python\n\n        from podsixnet2.Server import Server\n        \n        class MyServer(Server):\n            \n            channelClass = ClientChannel\n            \n            def Connected(self, channel, addr):\n                print 'new connection:', channel\n\nSet ``channelClass`` to the channel class that you created above. The\nmethod ``Connected()`` will be called whenever a new client connects to\nyour server. See the example servers for an idea of what you might do\neach time a client connects. You need to call ``Server.Pump()`` every\nnow and then, probably once per game loop. For example:\n\n.. code:: python\n\n        myserver = MyServer()\n        while True:\n            myserver.Pump()\n            sleep(0.0001)\n\nWhen you want to send data to a specific client/channel, use the Send\nmethod of the Channel class:\n\n.. code:: python\n\n    channel.Send({\"action\": \"hello\", \"message\": \"hello client!\"})\n\nQuick start - Client\n--------------------\n\nTo have a client connect to your new server, you should use the\nConnection module. See ``pydoc Connection`` for more details, but here's\na summary:\n\n``Connection.connection`` is a singleton Channel which connects to the\nserver. You'll only have one of these in your game code, and you'll use\nit to connect to the server and send messages to the server.\n\n.. code:: python\n\n    from podsixnet2.Connection import connection\n\n    # connect to the server - optionally pass hostname and port like: (\"mccormick.cx\", 31425)\n    connection.Connect()\n\n    connection.Send({\"action\": \"myaction\", \"blah\": 123, \"things\": [3, 4, 3, 4, 7]})\n\nYou'll also need to put the following code once somewhere in your game\nloop:\n\n.. code:: python\n\n    connection.Pump()\n\nAny time you have an object in your game which you want to receive\nmessages from the server, subclass ``ConnectionListener``. For example:\n\n.. code:: python\n\n        from podsixnet2.Connection import ConnectionListener\n        \n        class MyNetworkListener(ConnectionListener):\n        \n            def Network(self, data):\n                print 'network data:', data\n            \n            def Network_connected(self, data):\n                print \"connected to the server\"\n            \n            def Network_error(self, data):\n                print \"error:\", data['error'][1]\n            \n            def Network_disconnected(self, data):\n                print \"disconnected from the server\"\n            \n            def Network_myaction(data):\n                print \"myaction:\", data\n\nJust like in the server case, the network events are received by\n``Network_*`` callback methods, where you should replace '\\*' with the\nvalue in the 'action' key you want to catch. You can implement as many\nor as few of the above as you like. For example, NetworkGUI would\nprobably only want to listen for the ``_connected``, ``_disconnected``,\nand ``_error`` network events. The data for ``_error`` always comes in\nthe form of network exceptions, like (111, 'Connection refused') - these\nare passed straight from the socket layer and are standard socket\nerrors.\n\nAnother class might implement custom methods like\n``Network_myaction()``, which will receive any data that gets sent from\nthe server with an 'action' key that has the name 'myaction'. For\nexample, the server might send a message with the number of players\ncurrently connected like so:\n\n.. code:: python\n\n    channel.Send({\"action\": \"numplayers\", \"players\": 10})\n\nAnd the listener would look like this:\n\n.. code:: python\n\n        from podsixnet2.Connection import ConnectionListener\n        \n        class MyPlayerListener(ConnectionListener):\n        \n            def Network_numplayers(data):\n                # update gui element displaying the number of currently connected players\n                print data['players']\n\nYou can subclass ``ConnectionListener`` as many times as you like in\nyour application, and every class you make which subclasses it will\nreceive the network events via named Network callbacks. You should call\nthe ``Pump()`` method on each object you instantiate once per game loop:\n\n.. code:: python\n\n        gui = MyPlayerListener()\n        while 1:\n            connection.Pump()\n            gui.Pump()\n\nLicense\n-------\n\nCopyright `Chris McCormick <http://mccormick.cx/>`__, 2009-2015.\n\npodsixnet2 is licensed under the terms of the LGPL v3.0 or higher. See\nthe file called `COPYING <COPYING>`__ for details.\n\nThis basically means that you can use it in most types of projects\n(commercial or otherwise), but if you make changes to the podsixnet2\ncode you must make the modified code available with the distribution of\nyour software. Hopefully you'll tell us about it so we can incorporate\nyour changes. I am not a lawyer, so please read the license carefully to\nunderstand your rights with respect to this code.\n\nWhy not use Twisted instead?\n----------------------------\n\nTwisted is a fantastic library for writing robust network code. I have\nused it in several projects in the past, and it was quite nice to work\nwith. That said, Twisted:\n\n-  wants to steal the mainloop\n-  is bloated not KISS (it implements many many different protocols)\n-  has a weird template launching language when Python should do just\n   fine\n-  is not written 100% for the specfic use-case of multiplayer games\n\nThese are some of the reasons why I decided to write a library that is\nlightweight, has no dependencies except Python, and is dedicated 100% to\nthe task of multiplayer game networking.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/chr15m/PodSixNet", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "podsixnet2", "package_url": "https://pypi.org/project/podsixnet2/", "platform": "", "project_url": "https://pypi.org/project/podsixnet2/", "project_urls": {"Homepage": "https://github.com/chr15m/PodSixNet"}, "release_url": "https://pypi.org/project/podsixnet2/2.0.1/", "requires_dist": null, "requires_python": "", "summary": "Multiplayer networking library for games", "version": "2.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"podsixnet-lightweight-multiplayer-networking-library-for-python-games\">\n<h2>PodSixNet - lightweight multiplayer networking library for Python games</h2>\n<p>PodSixNet (now called <tt>podsixnet2</tt>) is a lightweight network layer\ndesigned to make it easy to write multiplayer games in Python. It uses\nPython\u2019s built in asyncore library and rencode.py (included) to\nasynchronously serialise network events and arbitrary data structures,\nand deliver them to your high level classes through simple callback\nmethods.</p>\n<p>Each class within your game client which wants to receive network\nevents, subclasses the ConnectionListener class and then implements\n<tt>Network_*</tt> methods to catch specific user-defined events from the\nserver. You don\u2019t have to wait for buffers to fill, or check sockets for\nwaiting data or anything like that, just do <tt>connection.Pump()</tt> once\nper game loop and the library will handle everything else for you,\npassing off events to all classes that are listening. Sending data back\nto the server is just as easy, using <tt>connection.Send(mydata)</tt>.\nLikewise on the server side, events are propagated to <tt>Network_*</tt>\nmethod callbacks and data is sent back to clients with the\n<tt>client.Send(mydata)</tt> method.</p>\n<p>The <a href=\"http://groups.google.com/group/podsixnet\" rel=\"nofollow\">podsixnet2 mailing\nlist</a> is good for getting\nhelp from other users.</p>\n<p>For users of the Construct game making environment for Windows, there is\na tutorial on doing multiplayer networking with podsixnet2,\n<a href=\"http://www.scirra.com/forum/viewtopic.php?f=8&amp;t=6299\" rel=\"nofollow\">here</a>. Thanks\nto Dave Chabo for contributing this tutorial.</p>\n<p>Here is <a href=\"http://www.raywenderlich.com/38732/multiplayer-game-programming-for-teens-with-python\" rel=\"nofollow\">another tutorial by Julian\nMeyer</a>.</p>\n</div>\n<div id=\"install\">\n<h2>Install</h2>\n<p><tt>pip install podsixnet2</tt></p>\n<p>or</p>\n<p><tt>easy_install podsixnet2</tt></p>\n<div id=\"from-source\">\n<h3>From source</h3>\n<p>First make sure you have <a href=\"http://python.org/\" rel=\"nofollow\">Python</a> 2.4 or greater\ninstalled (python 3 also works).</p>\n<p>Next you\u2019ll want to get the podsixnet2 source.</p>\n<p>The module is found inside a subdirectory called podsixnet2 within the\ntop level folder. There\u2019s an <tt>__init__.py</tt> inside there, so you can\njust copy or symlink the podsixnet2 sub-directory into your own project\nand then do <tt>import podsixnet2</tt>, or else you can run\n<tt>sudo python setup.py install</tt> to install podsixnet2 into your Python\npath. Use <tt>sudo python setup.py develop</tt> if you want to stay up to\ndate with the cutting edge and still be able to svn/bzr up every now and\nthen.</p>\n<p>By default podsixnet2 uses a binary encoder to transfer data over the\nnetwork, but it can optionally use the <a href=\"http://json.org/\" rel=\"nofollow\">JSON</a>\nformat or other formats supported by a serialiser which has \u2018dumps\u2019 and\n\u2018loads\u2019 methods. If you want to serialise your data using JSON you can\nchange the first line of Channel.py to \u2018from simplejson import dumps,\nloads\u2019 or use the built-in json library in Python 2.6 or higher. This\nwill allow you to write game clients in languages that can\u2019t read the\n\u2018rencode\u2019 binary format, such as Javascript.</p>\n</div>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>Chat example:</p>\n<ul>\n<li><tt>python examples/ChatServer.py</tt></li>\n<li>and a couple of instances of <tt>python examples/ChatClient.py</tt></li>\n</ul>\n<p>Whiteboard example:</p>\n<ul>\n<li><tt>python examples/WhiteboardServer.py</tt></li>\n<li>and a couple of instances of <tt>python examples/WhiteboardClient.py</tt></li>\n</ul>\n<p>LagTime example (measures round-trip time from the server to the\nclient):</p>\n<ul>\n<li><tt>python examples/LagTimeServer.py</tt></li>\n<li>and a couple of instances of <tt>python examples/LagTimeClient.py</tt></li>\n</ul>\n</div>\n<div id=\"quick-start-server\">\n<h2>Quick start - Server</h2>\n<p>You will need to subclass two classes in order to make your own server.\nEach time a client connects, a new Channel based class will be created,\nso you should subclass Channel to make your own\nserver-representation-of-a-client class like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">podsixnet2.Channel</span> <span class=\"kn\">import</span> <span class=\"n\">Channel</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ClientChannel</span><span class=\"p\">(</span><span class=\"n\">Channel</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Network</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span> <span class=\"n\">data</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Network_myaction</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span> <span class=\"s2\">\"myaction:\"</span><span class=\"p\">,</span> <span class=\"n\">data</span>\n</pre>\n<p>Whenever the client does <tt>connection.Send(mydata)</tt>, the <tt>Network()</tt>\nmethod will be called. The method <tt>Network_myaction()</tt> will only be\ncalled if your data has a key called \u2018action\u2019 with a value of\n\u201cmyaction\u201d. In other words if it looks something like this:</p>\n<pre><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"action\"</span><span class=\"p\">:</span> <span class=\"s2\">\"myaction\"</span><span class=\"p\">,</span> <span class=\"s2\">\"blah\"</span><span class=\"p\">:</span> <span class=\"mi\">123</span><span class=\"p\">,</span> <span class=\"o\">...</span> <span class=\"p\">}</span>\n</pre>\n<p>Next you need to subclass the Server class like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">podsixnet2.Server</span> <span class=\"kn\">import</span> <span class=\"n\">Server</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyServer</span><span class=\"p\">(</span><span class=\"n\">Server</span><span class=\"p\">):</span>\n\n    <span class=\"n\">channelClass</span> <span class=\"o\">=</span> <span class=\"n\">ClientChannel</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Connected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">addr</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span> <span class=\"s1\">'new connection:'</span><span class=\"p\">,</span> <span class=\"n\">channel</span>\n</pre>\n<p>Set <tt>channelClass</tt> to the channel class that you created above. The\nmethod <tt>Connected()</tt> will be called whenever a new client connects to\nyour server. See the example servers for an idea of what you might do\neach time a client connects. You need to call <tt>Server.Pump()</tt> every\nnow and then, probably once per game loop. For example:</p>\n<pre><span class=\"n\">myserver</span> <span class=\"o\">=</span> <span class=\"n\">MyServer</span><span class=\"p\">()</span>\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"n\">myserver</span><span class=\"o\">.</span><span class=\"n\">Pump</span><span class=\"p\">()</span>\n    <span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">0.0001</span><span class=\"p\">)</span>\n</pre>\n<p>When you want to send data to a specific client/channel, use the Send\nmethod of the Channel class:</p>\n<pre><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">Send</span><span class=\"p\">({</span><span class=\"s2\">\"action\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hello\"</span><span class=\"p\">,</span> <span class=\"s2\">\"message\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hello client!\"</span><span class=\"p\">})</span>\n</pre>\n</div>\n<div id=\"quick-start-client\">\n<h2>Quick start - Client</h2>\n<p>To have a client connect to your new server, you should use the\nConnection module. See <tt>pydoc Connection</tt> for more details, but here\u2019s\na summary:</p>\n<p><tt>Connection.connection</tt> is a singleton Channel which connects to the\nserver. You\u2019ll only have one of these in your game code, and you\u2019ll use\nit to connect to the server and send messages to the server.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">podsixnet2.Connection</span> <span class=\"kn\">import</span> <span class=\"n\">connection</span>\n\n<span class=\"c1\"># connect to the server - optionally pass hostname and port like: (\"mccormick.cx\", 31425)</span>\n<span class=\"n\">connection</span><span class=\"o\">.</span><span class=\"n\">Connect</span><span class=\"p\">()</span>\n\n<span class=\"n\">connection</span><span class=\"o\">.</span><span class=\"n\">Send</span><span class=\"p\">({</span><span class=\"s2\">\"action\"</span><span class=\"p\">:</span> <span class=\"s2\">\"myaction\"</span><span class=\"p\">,</span> <span class=\"s2\">\"blah\"</span><span class=\"p\">:</span> <span class=\"mi\">123</span><span class=\"p\">,</span> <span class=\"s2\">\"things\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">]})</span>\n</pre>\n<p>You\u2019ll also need to put the following code once somewhere in your game\nloop:</p>\n<pre><span class=\"n\">connection</span><span class=\"o\">.</span><span class=\"n\">Pump</span><span class=\"p\">()</span>\n</pre>\n<p>Any time you have an object in your game which you want to receive\nmessages from the server, subclass <tt>ConnectionListener</tt>. For example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">podsixnet2.Connection</span> <span class=\"kn\">import</span> <span class=\"n\">ConnectionListener</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyNetworkListener</span><span class=\"p\">(</span><span class=\"n\">ConnectionListener</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Network</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span> <span class=\"s1\">'network data:'</span><span class=\"p\">,</span> <span class=\"n\">data</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Network_connected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span> <span class=\"s2\">\"connected to the server\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Network_error</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span> <span class=\"s2\">\"error:\"</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">'error'</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Network_disconnected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span> <span class=\"s2\">\"disconnected from the server\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Network_myaction</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span> <span class=\"s2\">\"myaction:\"</span><span class=\"p\">,</span> <span class=\"n\">data</span>\n</pre>\n<p>Just like in the server case, the network events are received by\n<tt>Network_*</tt> callback methods, where you should replace \u2018*\u2019 with the\nvalue in the \u2018action\u2019 key you want to catch. You can implement as many\nor as few of the above as you like. For example, NetworkGUI would\nprobably only want to listen for the <tt>_connected</tt>, <tt>_disconnected</tt>,\nand <tt>_error</tt> network events. The data for <tt>_error</tt> always comes in\nthe form of network exceptions, like (111, \u2018Connection refused\u2019) - these\nare passed straight from the socket layer and are standard socket\nerrors.</p>\n<p>Another class might implement custom methods like\n<tt>Network_myaction()</tt>, which will receive any data that gets sent from\nthe server with an \u2018action\u2019 key that has the name \u2018myaction\u2019. For\nexample, the server might send a message with the number of players\ncurrently connected like so:</p>\n<pre><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">Send</span><span class=\"p\">({</span><span class=\"s2\">\"action\"</span><span class=\"p\">:</span> <span class=\"s2\">\"numplayers\"</span><span class=\"p\">,</span> <span class=\"s2\">\"players\"</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">})</span>\n</pre>\n<p>And the listener would look like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">podsixnet2.Connection</span> <span class=\"kn\">import</span> <span class=\"n\">ConnectionListener</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyPlayerListener</span><span class=\"p\">(</span><span class=\"n\">ConnectionListener</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">Network_numplayers</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"c1\"># update gui element displaying the number of currently connected players</span>\n        <span class=\"nb\">print</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">'players'</span><span class=\"p\">]</span>\n</pre>\n<p>You can subclass <tt>ConnectionListener</tt> as many times as you like in\nyour application, and every class you make which subclasses it will\nreceive the network events via named Network callbacks. You should call\nthe <tt>Pump()</tt> method on each object you instantiate once per game loop:</p>\n<pre><span class=\"n\">gui</span> <span class=\"o\">=</span> <span class=\"n\">MyPlayerListener</span><span class=\"p\">()</span>\n<span class=\"k\">while</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n    <span class=\"n\">connection</span><span class=\"o\">.</span><span class=\"n\">Pump</span><span class=\"p\">()</span>\n    <span class=\"n\">gui</span><span class=\"o\">.</span><span class=\"n\">Pump</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>Copyright <a href=\"http://mccormick.cx/\" rel=\"nofollow\">Chris McCormick</a>, 2009-2015.</p>\n<p>podsixnet2 is licensed under the terms of the LGPL v3.0 or higher. See\nthe file called <a href=\"COPYING\" rel=\"nofollow\">COPYING</a> for details.</p>\n<p>This basically means that you can use it in most types of projects\n(commercial or otherwise), but if you make changes to the podsixnet2\ncode you must make the modified code available with the distribution of\nyour software. Hopefully you\u2019ll tell us about it so we can incorporate\nyour changes. I am not a lawyer, so please read the license carefully to\nunderstand your rights with respect to this code.</p>\n</div>\n<div id=\"why-not-use-twisted-instead\">\n<h2>Why not use Twisted instead?</h2>\n<p>Twisted is a fantastic library for writing robust network code. I have\nused it in several projects in the past, and it was quite nice to work\nwith. That said, Twisted:</p>\n<ul>\n<li>wants to steal the mainloop</li>\n<li>is bloated not KISS (it implements many many different protocols)</li>\n<li>has a weird template launching language when Python should do just\nfine</li>\n<li>is not written 100% for the specfic use-case of multiplayer games</li>\n</ul>\n<p>These are some of the reasons why I decided to write a library that is\nlightweight, has no dependencies except Python, and is dedicated 100% to\nthe task of multiplayer game networking.</p>\n</div>\n\n          </div>"}, "last_serial": 7015448, "releases": {"2.0.0": [{"comment_text": "", "digests": {"md5": "e794dd6653a992ebac65e5f261243d51", "sha256": "13affadbd9a9af1400033cf6da07cc87754ff20c2553bbe9b167ce132fe7070a"}, "downloads": -1, "filename": "podsixnet2-2.0.0.tar.gz", "has_sig": false, "md5_digest": "e794dd6653a992ebac65e5f261243d51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8818, "upload_time": "2020-04-14T08:15:45", "upload_time_iso_8601": "2020-04-14T08:15:45.401742Z", "url": "https://files.pythonhosted.org/packages/ce/54/7e8196109c92293bd2017ad9c5432f5c84573693c73c08946b7b7f1b5084/podsixnet2-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "6232df966f97219d7acaae134c5d432e", "sha256": "f8382ab65e06e7fab5746b4ce7427e1ab7310298287cf92bf18a74a0b1a53852"}, "downloads": -1, "filename": "podsixnet2-2.0.1.tar.gz", "has_sig": false, "md5_digest": "6232df966f97219d7acaae134c5d432e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12323, "upload_time": "2020-04-14T08:21:08", "upload_time_iso_8601": "2020-04-14T08:21:08.981420Z", "url": "https://files.pythonhosted.org/packages/ed/4b/ea69ac128b3812b4c78ac9fcb903efc5efcf9b528ffaa514ceb9e5f53cb7/podsixnet2-2.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6232df966f97219d7acaae134c5d432e", "sha256": "f8382ab65e06e7fab5746b4ce7427e1ab7310298287cf92bf18a74a0b1a53852"}, "downloads": -1, "filename": "podsixnet2-2.0.1.tar.gz", "has_sig": false, "md5_digest": "6232df966f97219d7acaae134c5d432e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12323, "upload_time": "2020-04-14T08:21:08", "upload_time_iso_8601": "2020-04-14T08:21:08.981420Z", "url": "https://files.pythonhosted.org/packages/ed/4b/ea69ac128b3812b4c78ac9fcb903efc5efcf9b528ffaa514ceb9e5f53cb7/podsixnet2-2.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:52:05 2020"}