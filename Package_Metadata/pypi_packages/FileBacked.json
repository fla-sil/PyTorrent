{"info": {"author": "", "author_email": "", "bugtrack_url": null, "classifiers": [], "description": "==========\nFileBacked\n==========\n\nThe FileBacked library allows you to easily define complex Python\ntypes which can be saved to disk in a format that is efficient,\ninspectable and interfaceable outside of Python.\n\nWhile pickling is generally quite reliable for storing Python objects\non disk, it cannot truly function as an interface format for other\nlanguages, and it is also not secure and stable enough to be used for\nanything other than storing and reading your own files.\n\nFileBacked works by storing objects in HDF5 format. This is ideal for\nnumpy arrays, but also works well for most of the other standard\nPython types.\n\n\nHow it works\n------------\n\nDefine a class with attributes that are backed by disk storage.\n\n.. code-block:: python\n\n   from filebacked import FileBacked, FileBackedAttribute\n\n   class MyClass(FileBacked):\n       myint = FileBackedAttribute(int)\n\n   myobj = MyClass()\n   myobj.myint = 1\n\n\nThe type and name of the attribute will influence the format of the\nresulting HDF5 file.  Let us save the object.\n\n.. code-block:: python\n\n   import h5py\n\n   with h5py.File('myfile.hdf5', 'w') as f:\n       myobj.write(f)\n\n\nThe resulting file should have a root dataset named 'myint', a scalar\nwith value 1. And now let us read it again.\n\n.. code-block:: python\n\n   with h5py.File('myfile.hdf5', 'r') as f:\n       newobj = MyClass.read(f)\n   assert newobj.myint == 1\n\n\nSupported types\n---------------\n\nThe following types are supported:\n\n- Scalar numbers (*int*, *float* and numpy scalar types)\n- Strings (*str*)\n- Numpy arrays (``numpy.ndarray``)\n- Homogeneous tuples (``Tuple[eltype, ...]``) and lists (``List[eltype]``)\n  where the element type is supported\n- Dictionaries (``Dict[keytype, valuetype]``) where the key and value\n  types are supported\n- Subclasses of ``FileBacked`` and ``FileBackedDict[keytype, valuetype]``\n\nArbitrary Python objects are stored as pickled strings if the\n*allow_pickle* keyword argument is passed to the *write* and *read*\nmethods, respectively.\n\nTypes can be specified using standard builtins or type hint objects\nfrom the *typing* module, as above.\n\nTo add support for a custom type, create a new *Filter* subclass:\n\n.. code-block:: python\n\n   from filebacked import Filter, register_filter\n\n   class MyFilter(Filter):\n\n       def applicable(self, tp):\n           # Return true if the filter can be used for objects of the\n           # given type.\n\n       def write(self, group, name, obj, tp, **kwargs):\n           # Write the object to the given group as a subgroup or\n           # dataset with the given name.\n\n       def read(self, group, tp, **kwargs):\n           # Read the object from the given group or dataset and\n           # return it.\n\n   register_filter(MyFilter())\n\n\nNewly registered filters will take priority over existing filters.\n\n\nInterface\n---------\n\nFor writing subclasses of *FileBacked* or *FileBackedDict*, it is most\nuseful to use the following pattern.  In this case, you cannot write\nmore than one object to a file, or you risk overlapping attributes.\n\n.. code-block:: python\n\n   with h5py.File('myfile.hdf5', 'w') as f:\n       myobj.write(f)\n\n\nAlternatively, use the *write* function for arbitrary objects of\nsupported type.  In this case you must specify a name and optionally\na type for the object.  It is recommended to always specify the type,\nbecause element types of generic objects cannot be deduced from the\nobject alone.\n\n.. code-block:: python\n\n   with h5py.File('myfile.hdf5', 'w') as f:\n       filebacked.write(f, 'somename', 3, int)\n\n\nThe *write* function will detect subclasses of *FileBacked* or\n*FileBackedDict* and delegate writing accordingly, and the *write*\nmethod of those two classes will delegate writing of attributes to the\n*write* function.\n\nAll the write functions take an arbitrary amount of keyword arguments\nthat are passed throughout the object reference tree.  You can use\nthis to customize writing behaviour.  For example, the\n``FileBacked.write`` and ``FileBackedDict.write`` methods accept the\nkeyword arguments *only* and *skip*, to avoid writing some attributes\nif necessary:\n\n.. code-block:: python\n\n   class MyClass(FileBacked):\n       small = FileBackedAttribute(int)\n       large = FileBackedAttribute(np.ndarray)\n\n       def write(self, group, sparse=False, **kwargs):\n           if sparse:\n               super().write(group, skip=('small',), **kwargs)\n           else:\n               super().write(group, **kwargs)\n\n\nLazy reading\n^^^^^^^^^^^^\n\nRead functions accept an optional *lazy* parameter that can activate\nlazy reading.  In this case, when possible, objects will only be read\nfrom disk when accessed.  This is possible for attributes of\n*FileBacked* objects, and for *FileBackedDict* objects whose keys are\nintegers or strings.  All builtin Python types are read eagerly.  Note\nthat when using lazy reading, it is imperative that the file object is\nkept open for as long necessary to allow objects to be read on\ndemand.  When using eager reading, the file object may be closed\nimmediately after the *read* call.\n\n\nFile objects\n^^^^^^^^^^^^\n\nThe standard Python package for HDF5 is h5py.  However, FileBacked\ndoes not itself require h5py or depend on it.  Any HDF5 package with a\ncompatible interface will work.  FileBacked is tested to maintain\ncompatibility with h5py for reading and writing, and with pyfive for\nreading.\n\n\nInitialization\n^^^^^^^^^^^^^^\n\nWhen subclassing *FileBacked* and *FileBackedDict*, it is necessary to\ncall the superclass constructor before accessing any of the attributes\nor keys that are managed by files (in the case of *FileBackedDict*,\nthat means any keys at all).\n\nUpon reading an object from a file, the constructor will not be\ncalled as it otherwise would.  Instead, the ``__pyinit__`` method will\nbe called, with no arguments, both when constructing an object\nnormally *and* when reading it from the file.  You can use this method\nto perform extra object initialization if required, such as assigning\nattributes which are not file-backed.\n\n\nCaution\n-------\n\nUnlike pickle, FileBacked will not maintain reference equality between\nobjects.  If the same (mutable) object is referenced more than once in\nthe reference graph, it will instantiate as two different mutable\nobjects upon reading.  For the same reason, circular references will\ncause problems.\n\nFileBacked uses type hints to determine the structure of the resulting\nHDF5 file.  It does not prevent you from assigning objects with\nincorrect types.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/TheBB/FileBacked", "keywords": "", "license": "", "maintainer": "Eivind Fonn", "maintainer_email": "evfonn@gmail.com", "name": "FileBacked", "package_url": "https://pypi.org/project/FileBacked/", "platform": "", "project_url": "https://pypi.org/project/FileBacked/", "project_urls": {"Homepage": "https://github.com/TheBB/FileBacked"}, "release_url": "https://pypi.org/project/FileBacked/1.1.1/", "requires_dist": ["dill", "numpy", "typing-inspect"], "requires_python": "", "summary": "Simple file-backed HDF5 storage for Python objects", "version": "1.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>The FileBacked library allows you to easily define complex Python\ntypes which can be saved to disk in a format that is efficient,\ninspectable and interfaceable outside of Python.</p>\n<p>While pickling is generally quite reliable for storing Python objects\non disk, it cannot truly function as an interface format for other\nlanguages, and it is also not secure and stable enough to be used for\nanything other than storing and reading your own files.</p>\n<p>FileBacked works by storing objects in HDF5 format. This is ideal for\nnumpy arrays, but also works well for most of the other standard\nPython types.</p>\n<div id=\"how-it-works\">\n<h2>How it works</h2>\n<p>Define a class with attributes that are backed by disk storage.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">filebacked</span> <span class=\"kn\">import</span> <span class=\"n\">FileBacked</span><span class=\"p\">,</span> <span class=\"n\">FileBackedAttribute</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyClass</span><span class=\"p\">(</span><span class=\"n\">FileBacked</span><span class=\"p\">):</span>\n    <span class=\"n\">myint</span> <span class=\"o\">=</span> <span class=\"n\">FileBackedAttribute</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">)</span>\n\n<span class=\"n\">myobj</span> <span class=\"o\">=</span> <span class=\"n\">MyClass</span><span class=\"p\">()</span>\n<span class=\"n\">myobj</span><span class=\"o\">.</span><span class=\"n\">myint</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n</pre>\n<p>The type and name of the attribute will influence the format of the\nresulting HDF5 file.  Let us save the object.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">h5py</span>\n\n<span class=\"k\">with</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"s1\">'myfile.hdf5'</span><span class=\"p\">,</span> <span class=\"s1\">'w'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">myobj</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>The resulting file should have a root dataset named \u2018myint\u2019, a scalar\nwith value 1. And now let us read it again.</p>\n<pre><span class=\"k\">with</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"s1\">'myfile.hdf5'</span><span class=\"p\">,</span> <span class=\"s1\">'r'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">newobj</span> <span class=\"o\">=</span> <span class=\"n\">MyClass</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">newobj</span><span class=\"o\">.</span><span class=\"n\">myint</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n</pre>\n</div>\n<div id=\"supported-types\">\n<h2>Supported types</h2>\n<p>The following types are supported:</p>\n<ul>\n<li>Scalar numbers (<em>int</em>, <em>float</em> and numpy scalar types)</li>\n<li>Strings (<em>str</em>)</li>\n<li>Numpy arrays (<tt>numpy.ndarray</tt>)</li>\n<li>Homogeneous tuples (<tt>Tuple[eltype, <span class=\"pre\">...]</span></tt>) and lists (<tt>List[eltype]</tt>)\nwhere the element type is supported</li>\n<li>Dictionaries (<tt>Dict[keytype, valuetype]</tt>) where the key and value\ntypes are supported</li>\n<li>Subclasses of <tt>FileBacked</tt> and <tt>FileBackedDict[keytype, valuetype]</tt></li>\n</ul>\n<p>Arbitrary Python objects are stored as pickled strings if the\n<em>allow_pickle</em> keyword argument is passed to the <em>write</em> and <em>read</em>\nmethods, respectively.</p>\n<p>Types can be specified using standard builtins or type hint objects\nfrom the <em>typing</em> module, as above.</p>\n<p>To add support for a custom type, create a new <em>Filter</em> subclass:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">filebacked</span> <span class=\"kn\">import</span> <span class=\"n\">Filter</span><span class=\"p\">,</span> <span class=\"n\">register_filter</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyFilter</span><span class=\"p\">(</span><span class=\"n\">Filter</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">applicable</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">tp</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Return true if the filter can be used for objects of the</span>\n        <span class=\"c1\"># given type.</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Write the object to the given group as a subgroup or</span>\n        <span class=\"c1\"># dataset with the given name.</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">,</span> <span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Read the object from the given group or dataset and</span>\n        <span class=\"c1\"># return it.</span>\n\n<span class=\"n\">register_filter</span><span class=\"p\">(</span><span class=\"n\">MyFilter</span><span class=\"p\">())</span>\n</pre>\n<p>Newly registered filters will take priority over existing filters.</p>\n</div>\n<div id=\"interface\">\n<h2>Interface</h2>\n<p>For writing subclasses of <em>FileBacked</em> or <em>FileBackedDict</em>, it is most\nuseful to use the following pattern.  In this case, you cannot write\nmore than one object to a file, or you risk overlapping attributes.</p>\n<pre><span class=\"k\">with</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"s1\">'myfile.hdf5'</span><span class=\"p\">,</span> <span class=\"s1\">'w'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">myobj</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>Alternatively, use the <em>write</em> function for arbitrary objects of\nsupported type.  In this case you must specify a name and optionally\na type for the object.  It is recommended to always specify the type,\nbecause element types of generic objects cannot be deduced from the\nobject alone.</p>\n<pre><span class=\"k\">with</span> <span class=\"n\">h5py</span><span class=\"o\">.</span><span class=\"n\">File</span><span class=\"p\">(</span><span class=\"s1\">'myfile.hdf5'</span><span class=\"p\">,</span> <span class=\"s1\">'w'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">filebacked</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"s1\">'somename'</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">)</span>\n</pre>\n<p>The <em>write</em> function will detect subclasses of <em>FileBacked</em> or\n<em>FileBackedDict</em> and delegate writing accordingly, and the <em>write</em>\nmethod of those two classes will delegate writing of attributes to the\n<em>write</em> function.</p>\n<p>All the write functions take an arbitrary amount of keyword arguments\nthat are passed throughout the object reference tree.  You can use\nthis to customize writing behaviour.  For example, the\n<tt>FileBacked.write</tt> and <tt>FileBackedDict.write</tt> methods accept the\nkeyword arguments <em>only</em> and <em>skip</em>, to avoid writing some attributes\nif necessary:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyClass</span><span class=\"p\">(</span><span class=\"n\">FileBacked</span><span class=\"p\">):</span>\n    <span class=\"n\">small</span> <span class=\"o\">=</span> <span class=\"n\">FileBackedAttribute</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">)</span>\n    <span class=\"n\">large</span> <span class=\"o\">=</span> <span class=\"n\">FileBackedAttribute</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">,</span> <span class=\"n\">sparse</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">sparse</span><span class=\"p\">:</span>\n            <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">,</span> <span class=\"n\">skip</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">'small'</span><span class=\"p\">,),</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n</pre>\n<div id=\"lazy-reading\">\n<h3>Lazy reading</h3>\n<p>Read functions accept an optional <em>lazy</em> parameter that can activate\nlazy reading.  In this case, when possible, objects will only be read\nfrom disk when accessed.  This is possible for attributes of\n<em>FileBacked</em> objects, and for <em>FileBackedDict</em> objects whose keys are\nintegers or strings.  All builtin Python types are read eagerly.  Note\nthat when using lazy reading, it is imperative that the file object is\nkept open for as long necessary to allow objects to be read on\ndemand.  When using eager reading, the file object may be closed\nimmediately after the <em>read</em> call.</p>\n</div>\n<div id=\"file-objects\">\n<h3>File objects</h3>\n<p>The standard Python package for HDF5 is h5py.  However, FileBacked\ndoes not itself require h5py or depend on it.  Any HDF5 package with a\ncompatible interface will work.  FileBacked is tested to maintain\ncompatibility with h5py for reading and writing, and with pyfive for\nreading.</p>\n</div>\n<div id=\"initialization\">\n<h3>Initialization</h3>\n<p>When subclassing <em>FileBacked</em> and <em>FileBackedDict</em>, it is necessary to\ncall the superclass constructor before accessing any of the attributes\nor keys that are managed by files (in the case of <em>FileBackedDict</em>,\nthat means any keys at all).</p>\n<p>Upon reading an object from a file, the constructor will not be\ncalled as it otherwise would.  Instead, the <tt>__pyinit__</tt> method will\nbe called, with no arguments, both when constructing an object\nnormally <em>and</em> when reading it from the file.  You can use this method\nto perform extra object initialization if required, such as assigning\nattributes which are not file-backed.</p>\n</div>\n</div>\n<div id=\"caution\">\n<h2>Caution</h2>\n<p>Unlike pickle, FileBacked will not maintain reference equality between\nobjects.  If the same (mutable) object is referenced more than once in\nthe reference graph, it will instantiate as two different mutable\nobjects upon reading.  For the same reason, circular references will\ncause problems.</p>\n<p>FileBacked uses type hints to determine the structure of the resulting\nHDF5 file.  It does not prevent you from assigning objects with\nincorrect types.</p>\n</div>\n\n          </div>"}, "last_serial": 7068955, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "61f466ee5bb890419e01187f9eda71ae", "sha256": "0c39eb4dd3fca77036ae473ee20cf53ff709de6ada9c83917e1cc34a4a86b4a8"}, "downloads": -1, "filename": "FileBacked-0.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "61f466ee5bb890419e01187f9eda71ae", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7720, "upload_time": "2020-04-21T15:44:18", "upload_time_iso_8601": "2020-04-21T15:44:18.411713Z", "url": "https://files.pythonhosted.org/packages/17/64/3834c7de70a4898631a5bd75d5ac6c6dfc82f840aa109fd63bbde4575139/FileBacked-0.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "60155685444790d5239ebafa371f78f3", "sha256": "deb4427dcf93aa0af532c7d7fc8036e34752358eb0481528a787a9ba7a041dcf"}, "downloads": -1, "filename": "FileBacked-0.0.0.tar.gz", "has_sig": false, "md5_digest": "60155685444790d5239ebafa371f78f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8787, "upload_time": "2020-04-21T15:44:21", "upload_time_iso_8601": "2020-04-21T15:44:21.244525Z", "url": "https://files.pythonhosted.org/packages/77/21/951b626d95e41505c0c89b8a5b58cf4dc2b8dc224533761f0dcd4dc42fd1/FileBacked-0.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "8ab03c380483b274b4d713c66cc30182", "sha256": "c7183b0e84f7f06e74cb94c02b08337acc9fa38c956b9724e2f38aedd323a8b7"}, "downloads": -1, "filename": "FileBacked-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "8ab03c380483b274b4d713c66cc30182", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7722, "upload_time": "2020-04-21T15:44:20", "upload_time_iso_8601": "2020-04-21T15:44:20.252402Z", "url": "https://files.pythonhosted.org/packages/2e/be/e8f84b1c4422321fdc3f4f65c94770fc887a427574137c694dc053a70593/FileBacked-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a308797d9bcd65476d7aaa29afe4dc74", "sha256": "dd1eba8b8cff2d0bd8780423c52f6e272cd2aac96fef037ba8f6181a688ebbdf"}, "downloads": -1, "filename": "FileBacked-1.1.0.tar.gz", "has_sig": false, "md5_digest": "a308797d9bcd65476d7aaa29afe4dc74", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8844, "upload_time": "2020-04-21T15:44:22", "upload_time_iso_8601": "2020-04-21T15:44:22.432091Z", "url": "https://files.pythonhosted.org/packages/67/62/04ed879bf427afc156463a9d3714e14e7230d3abddb497a4c1b7e8c34c50/FileBacked-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "d88b91c3ee7b9a217f38a2189b658865", "sha256": "fb8eb83b7063d6012201f9e48d11843f4f9383db8ba3d0e6c7187ec7a33b27d6"}, "downloads": -1, "filename": "FileBacked-1.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "d88b91c3ee7b9a217f38a2189b658865", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12801, "upload_time": "2020-04-21T15:54:02", "upload_time_iso_8601": "2020-04-21T15:54:02.865641Z", "url": "https://files.pythonhosted.org/packages/1d/d4/d17977e4470a9d5a806c6b6c60d378e94d2a9ce79ff5f2454d418ab079aa/FileBacked-1.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bd785d7a89096c73277e4d2944a8c43f", "sha256": "216c8b2b03aabe39818af16990c910c084829fb2c112db26af7e446d5ce33a59"}, "downloads": -1, "filename": "FileBacked-1.1.1.tar.gz", "has_sig": false, "md5_digest": "bd785d7a89096c73277e4d2944a8c43f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9656, "upload_time": "2020-04-21T15:54:04", "upload_time_iso_8601": "2020-04-21T15:54:04.134155Z", "url": "https://files.pythonhosted.org/packages/75/85/e29bb236f1480baf985da54b734bdfd653ba00ea11b60e161166841bdc2e/FileBacked-1.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d88b91c3ee7b9a217f38a2189b658865", "sha256": "fb8eb83b7063d6012201f9e48d11843f4f9383db8ba3d0e6c7187ec7a33b27d6"}, "downloads": -1, "filename": "FileBacked-1.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "d88b91c3ee7b9a217f38a2189b658865", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12801, "upload_time": "2020-04-21T15:54:02", "upload_time_iso_8601": "2020-04-21T15:54:02.865641Z", "url": "https://files.pythonhosted.org/packages/1d/d4/d17977e4470a9d5a806c6b6c60d378e94d2a9ce79ff5f2454d418ab079aa/FileBacked-1.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bd785d7a89096c73277e4d2944a8c43f", "sha256": "216c8b2b03aabe39818af16990c910c084829fb2c112db26af7e446d5ce33a59"}, "downloads": -1, "filename": "FileBacked-1.1.1.tar.gz", "has_sig": false, "md5_digest": "bd785d7a89096c73277e4d2944a8c43f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9656, "upload_time": "2020-04-21T15:54:04", "upload_time_iso_8601": "2020-04-21T15:54:04.134155Z", "url": "https://files.pythonhosted.org/packages/75/85/e29bb236f1480baf985da54b734bdfd653ba00ea11b60e161166841bdc2e/FileBacked-1.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:42:37 2020"}