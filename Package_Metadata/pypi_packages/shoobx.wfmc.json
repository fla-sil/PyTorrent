{"info": {"author": "Zope Corporation and Contributors", "author_email": "zope3-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython"], "description": "--------------------------------\nShoobx WfMC-based Process Engine\n--------------------------------\n\n.. image:: https://travis-ci.org/Shoobx/shoobx.wfmc.png?branch=master\n   :target: https://travis-ci.org/Shoobx/shoobx.wfmc\n\n.. image:: https://coveralls.io/repos/github/Shoobx/shoobx.wfmc/badge.svg?branch=master\n   :target: https://coveralls.io/github/Shoobx/shoobx.wfmc?branch=master\n\n.. image:: https://img.shields.io/pypi/v/shoobx.wfmc.svg\n    :target: https://pypi.python.org/pypi/shoobx.wfmc\n\n.. image:: https://img.shields.io/pypi/pyversions/shoobx.wfmc.svg\n    :target: https://pypi.python.org/pypi/shoobx.wfmc/\n\n.. image:: https://api.codeclimate.com/v1/badges/f3c23e8e1b19a03a37e1/maintainability\n   :target: https://codeclimate.com/github/Shoobx/shoobx.wfmc/maintainability\n   :alt: Maintainability\n   \nThis package provides an implementation of a Workflow-Management\nCoalition (WFMC) workflow engine. The engine is provided as a\ncollection of workflow process components. Workflow processes can be\ndefined in Python or via the XML Process-Definition Language, XPDL.\n\n\nDetailed Documentation\n++++++++++++++++++++++\n\n\n\nWorkflow-Management Coalition Workflow Engine\n=============================================\n\nThis package provides an implementation of a Workflow-Management\nCoalition (WFMC) workflow engine.  The engine is provided as a\ncollection of workflow process components.  Workflow processes can be\ndefined in Python or via the XML Process-Definition Language, XPDL.\n\nIn this document, we'll look at Python-defined process definitions:\n\n    >>> from shoobx.wfmc import process\n    >>> pd = process.ProcessDefinition('sample')\n\nThe argument to the process is a process id.\n\nA process has a number of parts.  Let's look at a sample review\nprocess::\n\n                              -----------\n                           -->| Publish |\n  ----------   ---------- /   -----------\n  | Author |-->| Review |-    ----------\n  ----------   ---------- \\-->| Reject |\n                              ----------\n\nHere we have a single start activity and 2 end activities.  We could\nhave modeled this with a single end activity, but that is not\nrequired.  A single start activity *is* required. A process definition\nhas a set of activities, with transitions between them.  Let's define\nthe activities for our process definition:\n\n    >>> pd.defineActivities(\n    ...     author  = process.ActivityDefinition(),\n    ...     review  = process.ActivityDefinition(),\n    ...     publish = process.ActivityDefinition(),\n    ...     reject  = process.ActivityDefinition(),\n    ...     )\n\nWe supply activities as keyword arguments. The argument names provide\nactivity ids that we'll use when defining transitions:\n\n    >>> pd.defineTransitions(\n    ...     process.TransitionDefinition('author', 'review'),\n    ...     process.TransitionDefinition('review', 'publish'),\n    ...     process.TransitionDefinition('review', 'reject'),\n    ...     )\n\nEach transition is constructed with an identifier for a starting\nactivity, and an identifier for an ending activity.\n\nBefore we can use a workflow definition, we have to register it as a\nutility. This is necessary so that process instances can find their\ndefinitions.  In addition, the utility name must match the process id:\n\n    >>> import zope.component\n    >>> from shoobx.wfmc.process import StaticProcessDefinitionFactory\n    >>> pdfactory = StaticProcessDefinitionFactory()\n    >>> zope.component.provideUtility(pdfactory)\n    >>> pdfactory.register(pd)\n\nNow, with this definition, we can execute our workflow.  We haven't\ndefined any work yet, but we can see the workflow execute.  We'll see\nthe workflow executing by registering a subscriber that logs workflow\nevents:\n\n    >>> def log_workflow(event):\n    ...     print (event)\n\n    >>> import zope.event\n    >>> zope.event.subscribers.append(log_workflow)\n\nTo use the workflow definition, we need to create an instance:\n\n    >>> proc = pd()\n\nNow, if we start the workflow:\n\n    >>> proc.start()\n    ProcessStarted(Process('sample'))\n    Transition(None, Activity('sample.author'))\n    ActivityStarted(Activity('sample.author'))\n    ActivityFinished(Activity('sample.author'))\n    Transition(Activity('sample.author'), Activity('sample.review'))\n    ActivityStarted(Activity('sample.review'))\n    ActivityFinished(Activity('sample.review'))\n    Transition(Activity('sample.review'), Activity('sample.publish'))\n    ActivityStarted(Activity('sample.publish'))\n    ActivityFinished(Activity('sample.publish'))\n    ProcessFinished(Process('sample'))\n\nwe see that we transition immediately into the author activity, then\ninto review and publish.  Normally, we'd need to do some work in each\nactivity, and transitions would continue only after work had been\ndone, however, in this case, we didn't define any work, so each\nactivity completed immediately.\n\nNote that we didn't transition into the rejected activity.  By\ndefault, when an activity is completed, the first transition for which\nits condition evaluates to `True` is used.  By default, transitions\nhave boolean conditions that evaluate to `True`, so the transition\nto `publish` is used because it was defined before the transition to\n`reject`.  What we want is to transition to `publish` if a reviewer\napproves the content for publication, but to `reject` if the reviewer\nrejects the content for publication.  We can use a condition for this:\n\n    >>> pd = process.ProcessDefinition('sample')\n    >>> pdfactory.register(pd)\n\n    >>> pd.defineActivities(\n    ...     author = process.ActivityDefinition(),\n    ...     review = process.ActivityDefinition(),\n    ...     publish = process.ActivityDefinition(),\n    ...     reject = process.ActivityDefinition(),\n    ...     )\n    >>> pd.defineTransitions(\n    ...     process.TransitionDefinition('author', 'review'),\n    ...     process.TransitionDefinition(\n    ...         'review', 'publish',\n    ...         condition=lambda proc: proc.workflowRelevantData.publish),\n    ...     process.TransitionDefinition('review', 'reject'),\n    ...     )\n\nWe redefined the workflow process, specifying a condition for the\ntransition to `publish`.  Boolean conditions are just callable objects that\ntake a data object and return a boolean value.  The data object is\ncalled \"workflow-relevant data\".  A process instance has a data object\ncontaining this data.  In the example, above, the condition simply\nreturned the value of the `publish` attribute. How does this attribute\nget set? It needs to be set by the review activity. To do that, we\nneed to arrange for the activity to set the data.  This brings us to\napplications.\n\nProcess definitions are meant to be used with different\napplications. For this reason, process definitions don't include\napplication logic.  What they do include is a specifications of the\napplications to be invoked and the flow of work-flow-relevant data to\nand from the application.  Now, we can define our applications:\n\n    >>> pd.defineApplications(\n    ...     author = process.Application(),\n    ...     review = process.Application(\n    ...         process.OutputParameter('publish')),\n    ...     publish = process.Application(),\n    ...     reject = process.Application(),\n    ...     )\n\nWe used the same names for the applications that we used for our\nactivities. This isn't required, but is a common practice.  Note that\nthe `review` application includes a specification of an output\nparameter.  Now that we've defined our applications, we need to modify\nour activities to use them:\n\n    >>> pd.activities['author'].addApplication('author')\n    >>> pd.activities['review'].addApplication('review', ['publish'])\n    >>> pd.activities['publish'].addApplication('publish')\n    >>> pd.activities['reject'].addApplication('reject')\n\nAn activity can use many applications, so we call `addApplication`.\nIn the application definition for the 'review' application, we\nprovided the name of a workflow-relevent data variable corresponding\nto the output parameter defined for the application.  When using an\napplication in an activity, a workflow-relevent data variable name\nmust be provided for each of the parameters in the identified\napplications's signature.  When an application is used in an activity,\nworkflow-relevent data are passed for each of the input parameters and\nare set by each of the output parameters. In this example, the output\nparameter, will be used to add a `publish` attribute to the workflow\nrelevant data.\n\nParticipants\n------------\n\nWe've declared some applications, and we've wired them up to\nactivities, but we still haven't specified any application code. Before\nwe can specify application code, we need to consider who will be\nperforming the application.  Workflow applications are normally\nexecuted by people, or other external actors.  As with applications,\nprocess definitions allow participants in the workflow to be declared\nand identified with activities.  We declare participants much as we\ndeclare applications, except without parameters:\n\n    >>> pd.defineParticipants(\n    ...     author   = process.Participant(),\n    ...     reviewer = process.Participant(),\n    ...     )\n\nIn this case, we happened to reuse an activity name for one, but\nnot both of the participants.  Having defined these participants, we\ncan associate them with activities:\n\n    >>> pd.activities['author'].definePerformer('author')\n    >>> pd.activities['review'].definePerformer('reviewer')\n\nApplication Integration\n-----------------------\n\nTo use a process definition to control application logic, we need to\nassociate it with an \"integration\" object.\n\nWhen a process needs to get a participant, it calls createParticipant\non its integration attribute, passing the process id and the\nperformer id. If an activity doesn't have a\nperformer, then the procedure above is used with an empty performer id.\n\nSimilarly, when a process needs a work item, it calls createWorkItem\non its integration attribute, passing the process id and the\napplication id.\n\nWork items provide a `start` method, which is used to start the work\nand pass input arguments.  It is the responsibility of the work item,\nat some later time, to call the `workItemFinished` method on the\nactivity, to notify the activity that the work item was\ncompleted. Output parameters are passed to the `workItemFinished`\nmethod.\n\nA simple way to create integration objects is with\n`shoobx.wfmc.attributeintegration.AttributeIntegration`.\n\n    >>> from shoobx.wfmc.attributeintegration import AttributeIntegration\n    >>> integration = AttributeIntegration()\n    >>> pd.integration = integration\n\nWe'll start by defining a simple Participant class:\n\n    >>> import zope.interface\n    >>> from shoobx.wfmc import interfaces\n\n    >>> @zope.interface.implementer(interfaces.IParticipant)\n    ... class Participant(object):\n    ...     zope.component.adapts(interfaces.IActivity)\n    ... \n    ...     def __init__(self, activity, process):\n    ...         self.activity = activity\n\nWe set attributes on the integration for each participant:\n\n    >>> integration.authorParticipant   = Participant\n    >>> integration.reviewerParticipant = Participant\n\nWe also define an attribute for participants for activities that don't\nhave performers:\n\n    >>> integration.Participant = Participant\n\nNow we'll define our work-items. First we'll define some classes:\n\n    >>> work_list = []\n\n    >>> @zope.interface.implementer(interfaces.IWorkItem)\n    ... class ApplicationBase:\n    ...     zope.component.adapts(interfaces.IParticipant)\n    ... \n    ...     def __init__(self, participant, process, activity):\n    ...         self.participant = participant\n    ...         work_list.append(self)\n    ... \n    ...     def start(self, args):\n    ...         pass\n    ... \n    ...     def finish(self):\n    ...         self.participant.activity.workItemFinished(self)\n\n    >>> class Review(ApplicationBase):\n    ...     def finish(self, publish):\n    ...         output = {'publish': publish}\n    ...         self.participant.activity.workItemFinished(self, output)\n\n    >>> class Publish(ApplicationBase):\n    ...     def start(self, args):\n    ...         print (\"Published\")\n    ...         self.finish()\n\n    >>> class Reject(ApplicationBase):\n    ...     def start(self, args):\n    ...         print (\"Rejected\")\n    ...         self.finish()\n\nand then we'll hook them up with the integration object:\n\n    >>> integration.authorWorkItem  = ApplicationBase\n    >>> integration.reviewWorkItem  = Review\n    >>> integration.publishWorkItem = Publish\n    >>> integration.rejectWorkItem  = Reject\n\nUsing workflow processes\n------------------------\n\nTo use a process definition, instantiate it and call its start method\nto start execution:\n\n    >>> proc = pd()\n    >>> proc.start()\n    ... # doctest: +NORMALIZE_WHITESPACE\n    ProcessStarted(Process('sample'))\n    Transition(None, Activity('sample.author'))\n    ActivityStarted(Activity('sample.author'))\n    WorkItemStarting('author')\n    WorkItemStarted('author')\n\nWe transition into the author activity and wait for work to get done.\nTo move forward, we need to get at the authoring work item, so we can\nfinish it.  Our work items add themselves to a work list, so we can\nget the item from the list.\n\n    >>> item = work_list.pop()\n\nNow we can finish the work item, by calling its finish method:\n\n    >>> item.finish()\n    WorkItemFinished('author')\n    ActivityFinished(Activity('sample.author'))\n    Transition(Activity('sample.author'), Activity('sample.review'))\n    ActivityStarted(Activity('sample.review'))\n    WorkItemStarting('review')\n    WorkItemStarted('review')\n\nWe see that we transitioned to the review activity.  Note that the\n`finish` method isn't a part of the workflow APIs.  It was defined by\nour sample classes. Other applications could use different mechanisms.\n\nNow, we'll finish the review process by calling the review work item's\n`finish`. We'll pass `False`, indicating that the content should not\nbe published:\n\n    >>> work_list.pop().finish(False)\n    WorkItemFinished('review')\n    ActivityFinished(Activity('sample.review'))\n    Transition(Activity('sample.review'), Activity('sample.reject'))\n    ActivityStarted(Activity('sample.reject'))\n    WorkItemStarting('reject')\n    Rejected\n    WorkItemFinished('reject')\n    ActivityFinished(Activity('sample.reject'))\n    ProcessFinished(Process('sample'))\n    WorkItemStarted('reject')\n\nOrdering output transitions\n---------------------------\n\nNormally, outgoing transitions are ordered in the order of transition\ndefinition and all transitions from a given activity are used.\n\nIf transitions are defined in an inconvenient order, then the workflow\nmight not work as expected.  For example, let's modify the above\nprocess by switching the order of definition of some of the\ntransitions.  We'll reuse our integration object from the previous\nexample by passing it to the definition constructor:\n\n    >>> pd = process.ProcessDefinition('sample', integration)\n    >>> pdfactory.register(pd)\n\n    >>> pd.defineActivities(\n    ...     author = process.ActivityDefinition(),\n    ...     review = process.ActivityDefinition(),\n    ...     publish = process.ActivityDefinition(),\n    ...     reject = process.ActivityDefinition(),\n    ...     )\n    >>> pd.defineTransitions(\n    ...     process.TransitionDefinition('author', 'review'),\n    ...     process.TransitionDefinition('review', 'reject'),\n    ...     process.TransitionDefinition(\n    ...         'review', 'publish',\n    ...         condition=lambda proc: proc.workflowRelevantData.publish),\n    ...     )\n\n    >>> pd.defineApplications(\n    ...     author = process.Application(),\n    ...     review = process.Application(\n    ...         process.OutputParameter('publish')),\n    ...     publish = process.Application(),\n    ...     reject = process.Application(),\n    ...     )\n\n    >>> pd.activities['author'].addApplication('author')\n    >>> pd.activities['review'].addApplication('review', ['publish'])\n    >>> pd.activities['publish'].addApplication('publish')\n    >>> pd.activities['reject'].addApplication('reject')\n\n    >>> pd.defineParticipants(\n    ...     author   = process.Participant(),\n    ...     reviewer = process.Participant(),\n    ...     )\n\n    >>> pd.activities['author'].definePerformer('author')\n    >>> pd.activities['review'].definePerformer('reviewer')\n\nand run our process:\n\n    >>> proc = pd()\n    >>> proc.start()\n    ... # doctest: +NORMALIZE_WHITESPACE\n    ProcessStarted(Process('sample'))\n    Transition(None, Activity('sample.author'))\n    ActivityStarted(Activity('sample.author'))\n    WorkItemStarting('author')\n    WorkItemStarted('author')\n\n    >>> work_list.pop().finish()\n    WorkItemFinished('author')\n    ActivityFinished(Activity('sample.author'))\n    Transition(Activity('sample.author'), Activity('sample.review'))\n    ActivityStarted(Activity('sample.review'))\n    WorkItemStarting('review')\n    WorkItemStarted('review')\n\nThis time, we'll say that we should publish:\n\n    >>> work_list.pop().finish(True)\n    WorkItemFinished('review')\n    ActivityFinished(Activity('sample.review'))\n    Transition(Activity('sample.review'), Activity('sample.reject'))\n    ActivityStarted(Activity('sample.reject'))\n    WorkItemStarting('reject')\n    Rejected\n    WorkItemFinished('reject')\n    ActivityFinished(Activity('sample.reject'))\n    ProcessFinished(Process('sample'))\n    WorkItemStarted('reject')\n\nBut we went to the reject activity anyway. Why? Because transitions\nare tested in order. Because the transition to the reject activity was\ntested first and had no condition, we followed it without checking the\ncondition for the transition to the publish activity.  We can fix this\nby specifying outgoing transitions on the reviewer activity directly.\nTo do this, we'll also need to specify ids in our transitions.  Let's\nredefine the process:\n\n\n    >>> pd = process.ProcessDefinition('sample', integration)\n    >>> pdfactory.register(pd)\n\n    >>> pd.defineActivities(\n    ...     author = process.ActivityDefinition(),\n    ...     review = process.ActivityDefinition(),\n    ...     publish = process.ActivityDefinition(),\n    ...     reject = process.ActivityDefinition(),\n    ...     )\n    >>> pd.defineTransitions(\n    ...     process.TransitionDefinition('author', 'review'),\n    ...     process.TransitionDefinition('review', 'reject', id='reject'),\n    ...     process.TransitionDefinition(\n    ...         'review', 'publish', id='publish',\n    ...         condition=lambda proc: proc.workflowRelevantData.publish),\n    ...     )\n\n    >>> pd.defineApplications(\n    ...     author = process.Application(),\n    ...     review = process.Application(\n    ...         process.OutputParameter('publish')),\n    ...     publish = process.Application(),\n    ...     reject = process.Application(),\n    ...     )\n\n    >>> pd.activities['author'].addApplication('author')\n    >>> pd.activities['review'].addApplication('review', ['publish'])\n    >>> pd.activities['publish'].addApplication('publish')\n    >>> pd.activities['reject'].addApplication('reject')\n\n    >>> pd.defineParticipants(\n    ...     author   = process.Participant(),\n    ...     reviewer = process.Participant(),\n    ...     )\n\n    >>> pd.activities['author'].definePerformer('author')\n    >>> pd.activities['review'].definePerformer('reviewer')\n\n    >>> pd.activities['review'].addOutgoing('publish')\n    >>> pd.activities['review'].addOutgoing('reject')\n\nNow, when we run the process, we'll go to the publish activity as\nexpected:\n\n\n    >>> proc = pd()\n    >>> proc.start()\n    ... # doctest: +NORMALIZE_WHITESPACE\n    ProcessStarted(Process('sample'))\n    Transition(None, Activity('sample.author'))\n    ActivityStarted(Activity('sample.author'))\n    WorkItemStarting('author')\n    WorkItemStarted('author')\n\n    >>> work_list.pop().finish()\n    WorkItemFinished('author')\n    ActivityFinished(Activity('sample.author'))\n    Transition(Activity('sample.author'), Activity('sample.review'))\n    ActivityStarted(Activity('sample.review'))\n    WorkItemStarting('review')\n    WorkItemStarted('review')\n\n    >>> work_list.pop().finish(True)\n    WorkItemFinished('review')\n    ActivityFinished(Activity('sample.review'))\n    Transition(Activity('sample.review'), Activity('sample.publish'))\n    ActivityStarted(Activity('sample.publish'))\n    WorkItemStarting('publish')\n    Published\n    WorkItemFinished('publish')\n    ActivityFinished(Activity('sample.publish'))\n    ProcessFinished(Process('sample'))\n    WorkItemStarted('publish')\n\n\nLet's see the other way also, where we should transition to reject:\n\n\n    >>> proc = pd()\n    >>> proc.start()\n    ... # doctest: +NORMALIZE_WHITESPACE\n    ProcessStarted(Process('sample'))\n    Transition(None, Activity('sample.author'))\n    ActivityStarted(Activity('sample.author'))\n    WorkItemStarting('author')\n    WorkItemStarted('author')\n\n    >>> work_list.pop().finish()\n    WorkItemFinished('author')\n    ActivityFinished(Activity('sample.author'))\n    Transition(Activity('sample.author'), Activity('sample.review'))\n    ActivityStarted(Activity('sample.review'))\n    WorkItemStarting('review')\n    WorkItemStarted('review')\n\n    >>> work_list.pop().finish(False)\n    WorkItemFinished('review')\n    ActivityFinished(Activity('sample.review'))\n    Transition(Activity('sample.review'), Activity('sample.reject'))\n    ActivityStarted(Activity('sample.reject'))\n    WorkItemStarting('reject')\n    Rejected\n    WorkItemFinished('reject')\n    ActivityFinished(Activity('sample.reject'))\n    ProcessFinished(Process('sample'))\n    WorkItemStarted('reject')\n\n\nComplex Flows\n-------------\n\nLets look at a more complex example.  In this example, we'll extend\nthe process to work with multiple reviewers.  We'll also make the\nwork-list handling a bit more sophisticated.  We'll also introduce\nsome new concepts:\n\n- splits and joins\n\n- process arguments\n\nConsider the publication\nprocess shown below::\n\n\n  Author:      Tech          Tech          Editorial\n               Reviewer 1:   Reviewer 2:   Reviewer:\n  ===========  ===========   ===========   ==============\n                                                           ---------\n       ----------------------------------------------------| Start |\n      /                                                    ---------\n      |\n      V\n  -----------\n  | Prepare |<------------------------------\\\n  -----------                                \\\n      |        ------------                   \\\n      |        | Tech     |--------------- \\   \\\n      |------->| Review 1 |                 V   |\n      |        ------------  ----------    -------------\n       \\                     | Tech   |    | Editorial |   ----------\n         ------------------->| Review |--->| Review    |-->| Reject |\n                             | 2      |    -------------   ----------\n                             ----------      |      |\n  -----------                               /        \\\n  | Prepare |                              /          \\--------\\\n  | Final   |<----------------------------/                    |\n  -----------                                                  |\n     ^   |                                 ----------          V\n     |    \\------------------------------->| Review |      -----------\n      \\                                    | Final  |----->| Publish |\n       ------------------------------------|        |      -----------\n                                           ----------\n\nHere we've arranged the process diagram into columns, with the\nactivities for each participant. We have four participants, the\nauthor, two technical reviewers, and an editorial reviewer.  The\nauthor prepares a draft.  The author sends the draft to *both*\ntechnical reviewers for review.  When the technical reviews have\ncompleted, the editorial review does an initial editorial\nreview. Based on the technical reviews, the editor may choose to:\n\n- Reject the document\n\n- Publish the document as is\n\n- Request technical changes (based on the technical reviewers'\n  comments), or\n\n- Request editorial changes.\n\nIf technical changes are required, the work flows back to the\n\"Prepare\" activity.  If editorial changes are necessary, then work\nflows to the \"Prepare Final\" activity.  When the author has made the\neditorial changes, work flows to \"Review Final\".  The editor may\nrequest additional changes, in which case, work flows back to \"Prepare\nFinal\", otherwise, the work flows to \"Publish\".\n\nThis example illustrates different kinds of \"joins\" and \"splits\".  The\nterm \"join\" refers to the way incoming transitions to an activity are\nhandled. There are two kinds of joins: \"and\" and \"xor\".  With an \"and\"\njoin, the activity waits for each of the incoming transitions.  In\nthis example, the inputs to the \"Editorial Review\" activity form an\n\"and\" join.  Editorial review waits until each of the technical\nreviews are completed.  The rest of the joins in this example are\n\"xor\" joins.  The activity starts on any transition into the activity.\n\nThe term \"split\" refers to way outgoing transitions from an activity\nare handled.  Normally, exactly one transition out of an activity is\nused. This is called an \"xor\" split.  With an \"and\" split, all\ntransitions with boolean conditions that evaluate to `True` are used.\nIn this example, the \"Prepare\" activity has an \"and\" split.  Work\nflows simultaneously to the two technical review activities.  The rest\nof the splits in this example are \"xor\" splits.\n\nLets create our new workflow process. We'll reuse our existing\nintegration object:\n\n    >>> Publication = process.ProcessDefinition('Publication')\n    >>> Publication.integration = integration\n    >>> pdfactory.register(Publication)\n\n    >>> Publication.defineActivities(\n    ...     start   = process.ActivityDefinition(\"Start\"),\n    ...     prepare = process.ActivityDefinition(\"Prepare\"),\n    ...     tech1   = process.ActivityDefinition(\"Technical Review 1\"),\n    ...     tech2   = process.ActivityDefinition(\"Technical Review 2\"),\n    ...     review  = process.ActivityDefinition(\"Editorial Review\"),\n    ...     final   = process.ActivityDefinition(\"Final Preparation\"),\n    ...     rfinal  = process.ActivityDefinition(\"Review Final\"),\n    ...     publish = process.ActivityDefinition(\"Publish\"),\n    ...     reject  = process.ActivityDefinition(\"Reject\"),\n    ...     )\n\nHere, we've passed strings to the activity definitions providing\nnames. Names must be either unicode or ASCII strings.\n\nWe define our transitions:\n\n    >>> Publication.defineTransitions(\n    ...     process.TransitionDefinition('start', 'prepare'),\n    ...     process.TransitionDefinition('prepare', 'tech1'),\n    ...     process.TransitionDefinition('prepare', 'tech2'),\n    ...     process.TransitionDefinition('tech1', 'review'),\n    ...     process.TransitionDefinition('tech2', 'review'),\n    ...\n    ...     process.TransitionDefinition(\n    ...         'review', 'reject',\n    ...         condition=lambda proc: not proc.workflowRelevantData.publish\n    ...         ),\n    ...     process.TransitionDefinition(\n    ...         'review', 'prepare',\n    ...         condition=lambda proc: proc.workflowRelevantData.tech_changes\n    ...         ),\n    ...     process.TransitionDefinition(\n    ...         'review', 'final',\n    ...         condition=lambda proc: proc.workflowRelevantData.ed_changes\n    ...         ),\n    ...     process.TransitionDefinition('review', 'publish'),\n    ...\n    ...     process.TransitionDefinition('final', 'rfinal'),\n    ...     process.TransitionDefinition(\n    ...         'rfinal', 'final',\n    ...         condition=lambda proc: proc.workflowRelevantData.ed_changes\n    ...         ),\n    ...     process.TransitionDefinition('rfinal', 'publish'),\n    ...     )\n\nWe specify our \"and\" split and join:\n\n    >>> Publication.activities['prepare'].andSplit(True)\n    >>> Publication.activities['review'].andJoin(True)\n\nWe define our participants and applications:\n\n    >>> Publication.defineParticipants(\n    ...     author   = process.Participant(\"Author\"),\n    ...     tech1    = process.Participant(\"Technical Reviewer 1\"),\n    ...     tech2    = process.Participant(\"Technical Reviewer 2\"),\n    ...     reviewer = process.Participant(\"Editorial Reviewer\"),\n    ...     )\n\n    >>> Publication.defineApplications(\n    ...     prepare = process.Application(),\n    ...     tech_review = process.Application(\n    ...         process.OutputParameter('publish'),\n    ...         process.OutputParameter('tech_changes'),\n    ...         ),\n    ...     ed_review = process.Application(\n    ...         process.InputParameter('publish1'),\n    ...         process.InputParameter('tech_changes1'),\n    ...         process.InputParameter('publish2'),\n    ...         process.InputParameter('tech_changes2'),\n    ...         process.OutputParameter('publish'),\n    ...         process.OutputParameter('tech_changes'),\n    ...         process.OutputParameter('ed_changes'),\n    ...         ),\n    ...     publish = process.Application(),\n    ...     reject = process.Application(),\n    ...     final = process.Application(),\n    ...     rfinal = process.Application(\n    ...         process.OutputParameter('ed_changes'),\n    ...         ),\n    ...     )\n\n    >>> Publication.activities['prepare'].definePerformer('author')\n    >>> Publication.activities['prepare'].addApplication('prepare')\n\n    >>> Publication.activities['tech1'].definePerformer('tech1')\n    >>> Publication.activities['tech1'].addApplication(\n    ...     'tech_review', ['publish1', 'tech_changes1'])\n\n    >>> Publication.activities['tech2'].definePerformer('tech2')\n    >>> Publication.activities['tech2'].addApplication(\n    ...     'tech_review', ['publish2', 'tech_changes2'])\n\n    >>> Publication.activities['review'].definePerformer('reviewer')\n    >>> Publication.activities['review'].addApplication(\n    ...     'ed_review',\n    ...     ['publish1', 'tech_changes1', 'publish2', 'tech_changes2',\n    ...      'publish', 'tech_changes', 'ed_changes'],\n    ...     )\n\n    >>> Publication.activities['final'].definePerformer('author')\n    >>> Publication.activities['final'].addApplication('final')\n\n    >>> Publication.activities['rfinal'].definePerformer('reviewer')\n    >>> Publication.activities['rfinal'].addApplication(\n    ...     'rfinal', ['ed_changes'],\n    ...     )\n\n    >>> Publication.activities['publish'].addApplication('publish')\n    >>> Publication.activities['reject'].addApplication('reject')\n\nWe want to be able to specify an author when we start the process.\nWe'd also like to be told the final disposition of the process.  To\naccomplish this, we'll define parameters for our process:\n\n    >>> Publication.defineParameters(\n    ...     process.InputParameter('author'),\n    ...     process.OutputParameter('publish'),\n    ...     )\n\nNow that we've defined the process, we need to provide participant and\napplication components.  Let's start with our participants.  Rather\nthan sharing a single work list, we'll give each user their own\nwork list.  We'll also create preexisting participants and return\nthem. Finally, we'll create multiple authors and use the selected one:\n\n\n    >>> class User:\n    ...     def __init__(self):\n    ...         self.work_list = []\n\n    >>> authors = {'bob': User(), 'ted': User(), 'sally': User()}\n\n    >>> reviewer = User()\n    >>> tech1 = User()\n    >>> tech2 = User()\n\n    >>> class Author(Participant):\n    ...     def __init__(self, activity, process):\n    ...         Participant.__init__(self, activity, process)\n    ...         author_name = activity.process.workflowRelevantData.author\n    ...         print((\"Author `%s` selected\" % author_name))\n    ...         self.user = authors[author_name]\n\nIn this example, we need to define a separate attribute for each participant:\n\n    >>> integration.authorParticipant = Author\n\nWhen the process is created, the author name will be passed in and\nassigned to the workflow-relevant data.  Our author class uses this\ninformation to select the named user.\n\n    >>> class Reviewer(Participant):\n    ...     user = reviewer\n    >>> integration.reviewerParticipant = Reviewer\n\n    >>> class Tech1(Participant):\n    ...     user = tech1\n    >>> integration.tech1Participant = Tech1\n\n    >>> class Tech2(Participant):\n    ...     user = tech2\n    >>> integration.tech2Participant = Tech2\n\nWe'll use our orginal participation class for activities without\nperformers:\n\n    >>> integration.Participant = Participant\n\nNow we'll create our applications. Let's start with our author:\n\n    >>> @zope.interface.implementer(interfaces.IWorkItem)\n    ... class ApplicationBase(object):\n    ...     zope.component.adapts(interfaces.IParticipant)\n    ... \n    ...     def __init__(self, participant, process, activity):\n    ...         self.participant = participant\n    ...         self.activity = participant.activity\n    ...         participant.user.work_list.append(self)\n    ... \n    ...     def start(self, args):\n    ...         pass\n    ... \n    ...     def finish(self):\n    ...         self.participant.activity.workItemFinished(self)\n\n    >>> class Prepare(ApplicationBase):\n    ...\n    ...     def summary(self):\n    ...         process = self.activity.process\n    ...         doc = getattr(process.applicationRelevantData, 'doc', '')\n    ...         if doc:\n    ...             print ('Previous draft:')\n    ...             print (doc)\n    ...             print ('Changes we need to make:')\n    ...             for change in process.workflowRelevantData.tech_changes:\n    ...                 print (change)\n    ...         else:\n    ...             print ('Please write the initial draft')\n    ...\n    ...     def finish(self, doc):\n    ...         self.activity.process.applicationRelevantData.doc = doc\n    ...         super(Prepare, self).finish()\n\n    >>> integration.prepareWorkItem = Prepare\n\nSince we used the prepare application for revisions as well as initial\npreparation, we provide a summary method to show us what we have to do.\n\nHere we get the document created by the author passed in as an\nargument to the finish method.  In a more realistic implementation,\nthe author task would create the document at the start of the task and\nprovide a user interface for the user to edit it.  We store the\ndocument as application-relevant data, since we'll want reviewers to\nbe able to access it, but we don't need it directly for workflow\ncontrol.\n\n    >>> class TechReview(ApplicationBase):\n    ...\n    ...     def getDoc(self):\n    ...         return self.activity.process.applicationRelevantData.doc\n    ...\n    ...     def finish(self, decision, changes):\n    ...         output = {'publish': decision, 'tech_changes': changes}\n    ...         self.activity.workItemFinished(self, output)\n\n    >>> integration.tech_reviewWorkItem = TechReview\n\nHere, we provided a method to access the original document.\n\n    >>> class Review(TechReview):\n    ...\n    ...     def start(self, args):\n    ...         publish1 = args['publish1']\n    ...         publish2 = args['publish2']\n    ...         changes1 = args['tech_changes1']\n    ...         changes2 = args['tech_changes2']\n    ...         if not (publish1 and publish2):\n    ...             output = {'publish': False, \n    ...                       'tech_changes': changes1 + changes2, \n    ...                       'ed_changes': ()}\n    ...             # Reject if either tech reviewer rejects\n    ...             self.activity.workItemFinished(\n    ...                 self, output)\n    ...\n    ...         if changes1 or changes2:\n    ...             output = {'publish': True, \n    ...                       'tech_changes': changes1 + changes2, \n    ...                       'ed_changes': ()}\n    ...             # we won't do anything if there are tech changes\n    ...             self.activity.workItemFinished(\n    ...                 self, output)\n    ...\n    ...     def finish(self, ed_changes):\n    ...         output = {'publish': True, 'tech_changes': (), 'ed_changes': ed_changes}\n    ...         self.activity.workItemFinished(self, output)\n\n    >>> integration.ed_reviewWorkItem = Review\n\nIn this implementation, we decided to reject outright if either\ntechnical editor recommended rejection and to send work back to\npreparation if there are any technical changes. We also subclassed\n`TechReview` to get the `getDoc` method.\n\nWe'll reuse the `publish` and `reject` application from the previous\nexample.\n\n    >>> class Final(ApplicationBase):\n    ... \n    ...     def summary(self):\n    ...         process = self.activity.process\n    ...         doc = getattr(process.applicationRelevantData, 'doc', '')\n    ...         print ('Previous draft:')\n    ...         print((self.activity.process.applicationRelevantData.doc))\n    ...         print ('Changes we need to make:')\n    ...         for change in process.workflowRelevantData.ed_changes:\n    ...            print (change)\n    ... \n    ...     def finish(self, doc):\n    ...         self.activity.process.applicationRelevantData.doc = doc\n    ...         super(Final, self).finish()\n\n    >>> integration.finalWorkItem = Final\n\nIn our this application, we simply update the document to reflect\nchanges.\n\n    >>> class ReviewFinal(TechReview):\n    ...\n    ...     def finish(self, ed_changes):\n    ...         output = {'ed_changes': ed_changes}\n    ...         self.activity.workItemFinished(self, output)\n\n    >>> integration.rfinalWorkItem = ReviewFinal\n\nOur process now returns data.  When we create a process, we need to\nsupply an object that it can call back to:\n\n    >>> @zope.interface.implementer(interfaces.IProcessContext)\n    ... class PublicationContext:\n    ... \n    ...     def processFinished(self, process, decision):\n    ...         self.decision = decision\n\nNow, let's try out our process:\n\n    >>> context = PublicationContext()\n    >>> proc = Publication(context)\n    >>> proc.start('bob')\n    ProcessStarted(Process('Publication'))\n    Transition(None, Activity('Publication.start'))\n    ActivityStarted(Activity('Publication.start'))\n    ActivityFinished(Activity('Publication.start'))\n    Author `bob` selected\n    Transition(Activity('Publication.start'), Activity('Publication.prepare'))\n    ActivityStarted(Activity('Publication.prepare'))\n    WorkItemStarting('prepare')\n    WorkItemStarted('prepare')\n\nWe should have added an item to bob's work list. Let's get it and\nfinish it, submitting a document:\n\n    >>> item = authors['bob'].work_list.pop()\n    >>> item.finish(\"I give my pledge, as an American\\n\"\n    ...             \"to save, and faithfully to defend from waste\\n\"\n    ...             \"the natural resources of my Country.\")\n    WorkItemFinished('prepare')\n    ActivityFinished(Activity('Publication.prepare'))\n    Transition(Activity('Publication.prepare'), Activity('Publication.tech1'))\n    ActivityStarted(Activity('Publication.tech1'))\n    WorkItemStarting('tech_review')\n    WorkItemStarted('tech_review')\n    Transition(Activity('Publication.prepare'), Activity('Publication.tech2'))\n    ActivityStarted(Activity('Publication.tech2'))\n    WorkItemStarting('tech_review')\n    WorkItemStarted('tech_review')\n\nNotice that we transitioned to *two* activities, `tech1` and\n`tech2`.  This is because the prepare activity has an \"and\" split.\nNow we'll do a tech review.  Let's see what tech1 has:\n\n    >>> item = tech1.work_list.pop()\n    >>> print((item.getDoc()))\n    I give my pledge, as an American\n    to save, and faithfully to defend from waste\n    the natural resources of my Country.\n\nLet's tell the author to change \"American\" to \"Earthling\":\n\n    >>> item.finish(True, ['Change \"American\" to \"Earthling\"'])\n    WorkItemFinished('tech_review')\n    ActivityFinished(Activity('Publication.tech1'))\n    Transition(Activity('Publication.tech1'), Activity('Publication.review'))\n\nHere we transitioned to the editorial review activity, but we didn't\nstart it. This is because the editorial review activity has an \"and\"\njoin, meaning that it won't start until both transitions have\noccurred.\n\nNow we'll do the other technical review:\n\n    >>> item = tech2.work_list.pop()\n    >>> item.finish(True, ['Change \"Country\" to \"planet\"'])\n    WorkItemFinished('tech_review')\n    ActivityFinished(Activity('Publication.tech2'))\n    Transition(Activity('Publication.tech2'), Activity('Publication.review'))\n    ActivityStarted(Activity('Publication.review'))\n    WorkItemStarting('ed_review')\n    WorkItemFinished('ed_review')\n    ActivityFinished(Activity('Publication.review'))\n    Author `bob` selected\n    Transition(Activity('Publication.review'), Activity('Publication.prepare'))\n    ActivityStarted(Activity('Publication.prepare'))\n    WorkItemStarting('prepare')\n    WorkItemStarted('prepare')\n    WorkItemStarted('ed_review')\n\nNow when we transitioned to the editorial review activity, we started\nit, because each of the input transitions had happened.  Our editorial\nreview application automatically sent the work back to preparation,\nbecause there were technical comments. Of course the author is still `bob`.\nLet's address the comments:\n\n    >>> item = authors['bob'].work_list.pop()\n    >>> item.summary()\n    Previous draft:\n    I give my pledge, as an American\n    to save, and faithfully to defend from waste\n    the natural resources of my Country.\n    Changes we need to make:\n    Change \"American\" to \"Earthling\"\n    Change \"Country\" to \"planet\"\n\n    >>> item.finish(\"I give my pledge, as an Earthling\\n\"\n    ...             \"to save, and faithfully to defend from waste\\n\"\n    ...             \"the natural resources of my planet.\")\n    WorkItemFinished('prepare')\n    ActivityFinished(Activity('Publication.prepare'))\n    Transition(Activity('Publication.prepare'), Activity('Publication.tech1'))\n    ActivityStarted(Activity('Publication.tech1'))\n    WorkItemStarting('tech_review')\n    WorkItemStarted('tech_review')\n    Transition(Activity('Publication.prepare'), Activity('Publication.tech2'))\n    ActivityStarted(Activity('Publication.tech2'))\n    WorkItemStarting('tech_review')\n    WorkItemStarted('tech_review')\n\nAs before, after completing the initial edits, we start the technical\nreview activities again.  We'll review it again. This time, we have no\ncomments, because the author applied our requested changes:\n\n    >>> item = tech1.work_list.pop()\n    >>> item.finish(True, [])\n    WorkItemFinished('tech_review')\n    ActivityFinished(Activity('Publication.tech1'))\n    Transition(Activity('Publication.tech1'), Activity('Publication.review'))\n\n    >>> item = tech2.work_list.pop()\n    >>> item.finish(True, [])\n    WorkItemFinished('tech_review')\n    ActivityFinished(Activity('Publication.tech2'))\n    Transition(Activity('Publication.tech2'), Activity('Publication.review'))\n    ActivityStarted(Activity('Publication.review'))\n    WorkItemStarting('ed_review')\n    WorkItemStarted('ed_review')\n\nThis time, we are left in the technical review activity because there\nweren't any technical changes. We're ready to do our editorial review.\nWe'll request an editorial change:\n\n    >>> item = reviewer.work_list.pop()\n    >>> print((item.getDoc()))\n    I give my pledge, as an Earthling\n    to save, and faithfully to defend from waste\n    the natural resources of my planet.\n\n    >>> item.finish(['change \"an\" to \"a\"'])\n    WorkItemFinished('ed_review')\n    ActivityFinished(Activity('Publication.review'))\n    Author `bob` selected\n    Transition(Activity('Publication.review'), Activity('Publication.final'))\n    ActivityStarted(Activity('Publication.final'))\n    WorkItemStarting('final')\n    WorkItemStarted('final')\n\nBecause we requested editorial changes, we transitioned to the final\nediting activity, so that the author (still bob) can make the changes:\n\n    >>> item = authors['bob'].work_list.pop()\n    >>> item.summary()\n    Previous draft:\n    I give my pledge, as an Earthling\n    to save, and faithfully to defend from waste\n    the natural resources of my planet.\n    Changes we need to make:\n    change \"an\" to \"a\"\n\n    >>> item.finish(\"I give my pledge, as a Earthling\\n\"\n    ...             \"to save, and faithfully to defend from waste\\n\"\n    ...             \"the natural resources of my planet.\")\n    WorkItemFinished('final')\n    ActivityFinished(Activity('Publication.final'))\n    Transition(Activity('Publication.final'), Activity('Publication.rfinal'))\n    ActivityStarted(Activity('Publication.rfinal'))\n    WorkItemStarting('rfinal')\n    WorkItemStarted('rfinal')\n\nWe transition to the activity for reviewing the final edits.  We\nreview the document and approve it for publication:\n\n    >>> item = reviewer.work_list.pop()\n    >>> print((item.getDoc()))\n    I give my pledge, as a Earthling\n    to save, and faithfully to defend from waste\n    the natural resources of my planet.\n\n    >>> item.finish([])\n    WorkItemFinished('rfinal')\n    ActivityFinished(Activity('Publication.rfinal'))\n    Transition(Activity('Publication.rfinal'), Activity('Publication.publish'))\n    ActivityStarted(Activity('Publication.publish'))\n    WorkItemStarting('publish')\n    Published\n    WorkItemFinished('publish')\n    ActivityFinished(Activity('Publication.publish'))\n    ProcessFinished(Process('Publication'))\n    WorkItemStarted('publish')\n\nAt this point, the rest of the process finished automatically.  In\naddition, the decision was recorded in the process context object:\n\n    >>> proc.workflowRelevantData.publish\n    True\n\nComing Soon\n------------\n\n- Timeouts/exceptions\n\n\nSee also\n---------\nhttp://www.wfmc.org\nhttp://www.wfmc.org/standards/standards.htm\n\n\n\n\n===========\nXPDL Import\n===========\n\nWe can import process definitions from files in the XML Process\nDefinition Language (XPDL) format. An XPDL file contains multiple\nprocess definitions arranged in a package. When we load the file, we\nget a package containing some number of process definitions.\n\nLet's look at an example.  The file `publication.xpdl`\ncontains a definition for the publication example developed in the\n\"README.txt\" file.  We can read it using the xpdl module:\n\n    >>> from shoobx.wfmc import xpdl\n    >>> import os\n    >>> package = xpdl.read(open(os.path.join(this_directory,\n    ...                                       'publication-1.0.xpdl')))\n\nThis package contains a single definition:\n\n    >>> package\n    {u'Publication': ProcessDefinition(u'Publication')}\n\n    >>> pd = package[u'Publication']\n    >>> from shoobx.wfmc.attributeintegration import AttributeIntegration\n    >>> integration = AttributeIntegration()\n    >>> pd.integration = integration\n\nNow, having read the process definition, we can use it as we did\nbefore (in \"README.txt\").  As before, we'll create an event subscriber\nso that we can see what's going on:\n\n    >>> def log_workflow(event):\n    ...     print(event)\n\n    >>> import zope.event\n    >>> zope.event.subscribers.append(log_workflow)\n\nand we'll register the process definition as a utility:\n\n    >>> import zope.component\n    >>> from shoobx.wfmc.process import StaticProcessDefinitionFactory\n    >>> pdfactory = StaticProcessDefinitionFactory()\n    >>> zope.component.provideUtility(pdfactory)\n    >>> pdfactory.register(pd)\n\nand we'll define and register participant and application adapters:\n\n    >>> import zope.interface\n    >>> from shoobx.wfmc import interfaces\n\n    >>> @zope.interface.implementer(interfaces.IParticipant)\n    ... class Participant(object):\n    ...     zope.component.adapts(interfaces.IActivity)\n    ...\n    ...     def __init__(self, activity, process):\n    ...         self.activity = activity\n\n    >>> class User:\n    ...     def __init__(self):\n    ...         self.work_list = []\n\n    >>> authors = {'bob': User(), 'ted': User(), 'sally': User()}\n\n    >>> reviewer = User()\n    >>> tech1 = User()\n    >>> tech2 = User()\n\n    >>> class Author(Participant):\n    ...     def __init__(self, activity, process):\n    ...         Participant.__init__(self, activity, process)\n    ...         author_name = activity.process.workflowRelevantData.author\n    ...         print(\"Author `%s` selected\" % author_name)\n    ...         self.user = authors[author_name]\n\n    >>> integration.authorParticipant = Author\n\n    >>> class Reviewer(Participant):\n    ...     user = reviewer\n    >>> integration.reviewerParticipant = Reviewer\n\n    >>> class Tech1(Participant):\n    ...     user = tech1\n    >>> integration.tech1Participant = Tech1\n\n    >>> class Tech2(Participant):\n    ...     user = tech2\n    >>> integration.tech2Participant = Tech2\n\n    >>> integration.SystemParticipant = Participant\n\n    >>> @zope.interface.implementer(interfaces.IWorkItem)\n    ... class ApplicationBase(object):\n    ...     zope.component.adapts(interfaces.IParticipant)\n    ...\n    ...     def __init__(self, participant, process, activity):\n    ...         self.participant = participant\n    ...         self.activity = participant.activity\n    ...         participant.user.work_list.append(self)\n    ...\n    ...     def start(self, args):\n    ...         pass\n    ...\n    ...     def finish(self):\n    ...         self.participant.activity.workItemFinished(self)\n\n    >>> class Prepare(ApplicationBase):\n    ...\n    ...     def summary(self):\n    ...         process = self.activity.process\n    ...         doc = getattr(process.applicationRelevantData, 'doc', '')\n    ...         if doc:\n    ...             print('Previous draft:')\n    ...             print(doc)\n    ...             print('Changes we need to make:')\n    ...             for change in process.workflowRelevantData.tech_changes:\n    ...                 print(change)\n    ...         else:\n    ...             print('Please write the initial draft')\n    ...\n    ...     def finish(self, doc):\n    ...         self.activity.process.applicationRelevantData.doc = doc\n    ...         super(Prepare, self).finish()\n\n    >>> integration.prepareWorkItem = Prepare\n\n    >>> class TechReview(ApplicationBase):\n    ...\n    ...     def getDoc(self):\n    ...         return self.activity.process.applicationRelevantData.doc\n    ...\n    ...     def finish(self, decision, changes):\n    ...         output = {'publish': decision, 'tech_changes': changes}\n    ...         self.activity.workItemFinished(self, output)\n\n    >>> integration.tech_reviewWorkItem = TechReview\n\n    >>> class Review(TechReview):\n    ...\n    ...     def start(self, args):\n    ...         publish1 = args['publish1']\n    ...         publish2 = args['publish2']\n    ...         changes1 = args['tech_changes1']\n    ...         changes2 = args['tech_changes2']\n    ...         if not (publish1 and publish2):\n    ...             output = {'publish': False,\n    ...                       'tech_changes': changes1 + changes2,\n    ...                       'ed_changes': ()}\n    ...             # Reject if either tech reviewer rejects\n    ...             self.activity.workItemFinished(\n    ...                 self, output)\n    ...\n    ...         if changes1 or changes2:\n    ...             output = {'publish': True,\n    ...                       'tech_changes': changes1 + changes2,\n    ...                       'ed_changes': ()}\n    ...             # we won't do anyting if there are tech changes\n    ...             self.activity.workItemFinished(\n    ...                 self, output)\n    ...\n    ...     def finish(self, ed_changes):\n    ...         output = {'publish': True, 'tech_changes': (), 'ed_changes': ed_changes}\n    ...         self.activity.workItemFinished(self, output)\n\n    >>> integration.ed_reviewWorkItem = Review\n\n    >>> class Final(ApplicationBase):\n    ...\n    ...     def summary(self):\n    ...         process = self.activity.process\n    ...         doc = getattr(process.applicationRelevantData, 'doc', '')\n    ...         print('Previous draft:')\n    ...         print(self.activity.process.applicationRelevantData.doc)\n    ...         print('Changes we need to make:')\n    ...         for change in process.workflowRelevantData.ed_changes:\n    ...            print(change)\n    ...\n    ...     def finish(self, doc):\n    ...         self.activity.process.applicationRelevantData.doc = doc\n    ...         super(Final, self).finish()\n\n    >>> integration.finalWorkItem = Final\n\n    >>> class ReviewFinal(TechReview):\n    ...\n    ...     def finish(self, ed_changes):\n    ...         output = {'publish': True, 'tech_changes': (), 'ed_changes': ed_changes}\n    ...         self.activity.workItemFinished(self, output)\n\n    >>> integration.rfinalWorkItem = ReviewFinal\n\n\n    >>> @zope.interface.implementer(interfaces.IWorkItem)\n    ... class Publish:\n    ...     zope.component.adapts(interfaces.IParticipant)\n    ...\n    ...     def __init__(self, participant, process, activity):\n    ...         self.participant = participant\n    ...\n    ...     def start(self, args):\n    ...         print(\"Published\")\n    ...         self.finish()\n    ...\n    ...     def finish(self):\n    ...         self.participant.activity.workItemFinished(self)\n\n\n    >>> integration.publishWorkItem = Publish\n\n    >>> class Reject(Publish):\n    ...     def start(self, args):\n    ...         print(\"Rejected\")\n    ...         self.finish()\n\n    >>> integration.rejectWorkItem = Reject\n\nand a process context, so we can pass parameters:\n\n    >>> @zope.interface.implementer(interfaces.IProcessContext)\n    ... class PublicationContext:\n    ...\n    ...     def processFinished(self, process, decision):\n    ...         self.decision = decision\n\nNow, let's try out our process.  We'll follow the same steps we did in\n\"README.txt\", getting the same results:\n\n    >>> context = PublicationContext()\n    >>> proc = pd(context)\n    >>> proc.start('bob')\n    ProcessStarted(Process(u'Publication'))\n    Transition(None, Activity(u'Publication.start'))\n    ActivityStarted(Activity(u'Publication.start'))\n    ActivityFinished(Activity(u'Publication.start'))\n    Author `bob` selected\n    Transition(Activity(u'Publication.start'),\n               Activity(u'Publication.prepare'))\n    ActivityStarted(Activity(u'Publication.prepare'))\n    WorkItemStarting(u'prepare')\n    WorkItemStarted(u'prepare')\n\n    >>> item = authors['bob'].work_list.pop()\n    >>> item.finish(\"I give my pledge, as an American\\n\"\n    ...             \"to save, and faithfully to defend from waste\\n\"\n    ...             \"the natural resources of my Country.\")\n    WorkItemFinished(u'prepare')\n    ActivityFinished(Activity(u'Publication.prepare'))\n    Transition(Activity(u'Publication.prepare'),\n               Activity(u'Publication.tech1'))\n    ActivityStarted(Activity(u'Publication.tech1'))\n    WorkItemStarting(u'tech_review')\n    WorkItemStarted(u'tech_review')\n    Transition(Activity(u'Publication.prepare'),\n               Activity(u'Publication.tech2'))\n    ActivityStarted(Activity(u'Publication.tech2'))\n    WorkItemStarting(u'tech_review')\n    WorkItemStarted(u'tech_review')\n\n    >>> item = tech1.work_list.pop()\n    >>> print(item.getDoc())\n    I give my pledge, as an American\n    to save, and faithfully to defend from waste\n    the natural resources of my Country.\n\n    >>> item.finish(True, ['Change \"American\" to \"human\"'])\n    WorkItemFinished(u'tech_review')\n    ActivityFinished(Activity(u'Publication.tech1'))\n    Transition(Activity(u'Publication.tech1'),\n               Activity(u'Publication.review'))\n\n    >>> item = tech2.work_list.pop()\n    >>> item.finish(True, ['Change \"Country\" to \"planet\"'])\n    WorkItemFinished(u'tech_review')\n    ActivityFinished(Activity(u'Publication.tech2'))\n    Transition(Activity(u'Publication.tech2'),\n               Activity(u'Publication.review'))\n    ActivityStarted(Activity(u'Publication.review'))\n    WorkItemStarting(u'ed_review')\n    WorkItemFinished(u'ed_review')\n    ActivityFinished(Activity(u'Publication.review'))\n    Author `bob` selected\n    Transition(Activity(u'Publication.review'),\n               Activity(u'Publication.prepare'))\n    ActivityStarted(Activity(u'Publication.prepare'))\n    WorkItemStarting(u'prepare')\n    WorkItemStarted(u'prepare')\n    WorkItemStarted(u'ed_review')\n\n    >>> item = authors['bob'].work_list.pop()\n    >>> item.summary()\n    Previous draft:\n    I give my pledge, as an American\n    to save, and faithfully to defend from waste\n    the natural resources of my Country.\n    Changes we need to make:\n    Change \"American\" to \"human\"\n    Change \"Country\" to \"planet\"\n\n    >>> item.finish(\"I give my pledge, as an human\\n\"\n    ...             \"to save, and faithfully to defend from waste\\n\"\n    ...             \"the natural resources of my planet.\")\n    WorkItemFinished(u'prepare')\n    ActivityFinished(Activity(u'Publication.prepare'))\n    Transition(Activity(u'Publication.prepare'),\n               Activity(u'Publication.tech1'))\n    ActivityStarted(Activity(u'Publication.tech1'))\n    WorkItemStarting(u'tech_review')\n    WorkItemStarted(u'tech_review')\n    Transition(Activity(u'Publication.prepare'),\n               Activity(u'Publication.tech2'))\n    ActivityStarted(Activity(u'Publication.tech2'))\n    WorkItemStarting(u'tech_review')\n    WorkItemStarted(u'tech_review')\n\n    >>> item = tech1.work_list.pop()\n    >>> item.finish(True, [])\n    WorkItemFinished(u'tech_review')\n    ActivityFinished(Activity(u'Publication.tech1'))\n    Transition(Activity(u'Publication.tech1'),\n               Activity(u'Publication.review'))\n\n    >>> item = tech2.work_list.pop()\n    >>> item.finish(True, [])\n    WorkItemFinished(u'tech_review')\n    ActivityFinished(Activity(u'Publication.tech2'))\n    Transition(Activity(u'Publication.tech2'),\n               Activity(u'Publication.review'))\n    ActivityStarted(Activity(u'Publication.review'))\n    WorkItemStarting(u'ed_review')\n    WorkItemStarted(u'ed_review')\n\n    >>> item = reviewer.work_list.pop()\n    >>> print(item.getDoc())\n    I give my pledge, as an human\n    to save, and faithfully to defend from waste\n    the natural resources of my planet.\n\n    >>> item.finish(['change \"an\" to \"a\"'])\n    WorkItemFinished(u'ed_review')\n    ActivityFinished(Activity(u'Publication.review'))\n    Author `bob` selected\n    Transition(Activity(u'Publication.review'),\n               Activity(u'Publication.final'))\n    ActivityStarted(Activity(u'Publication.final'))\n    WorkItemStarting(u'final')\n    WorkItemStarted(u'final')\n\n    >>> item = authors['bob'].work_list.pop()\n    >>> item.summary()\n    Previous draft:\n    I give my pledge, as an human\n    to save, and faithfully to defend from waste\n    the natural resources of my planet.\n    Changes we need to make:\n    change \"an\" to \"a\"\n\n    >>> item.finish(\"I give my pledge, as a human\\n\"\n    ...             \"to save, and faithfully to defend from waste\\n\"\n    ...             \"the natural resources of my planet.\")\n    WorkItemFinished(u'final')\n    ActivityFinished(Activity(u'Publication.final'))\n    Transition(Activity(u'Publication.final'),\n               Activity(u'Publication.rfinal'))\n    ActivityStarted(Activity(u'Publication.rfinal'))\n    WorkItemStarting(u'rfinal')\n    WorkItemStarted(u'rfinal')\n\n    >>> item = reviewer.work_list.pop()\n    >>> print(item.getDoc())\n    I give my pledge, as a human\n    to save, and faithfully to defend from waste\n    the natural resources of my planet.\n\n    >>> item.finish([])\n    WorkItemFinished(u'rfinal')\n    ActivityFinished(Activity(u'Publication.rfinal'))\n    Transition(Activity(u'Publication.rfinal'),\n               Activity(u'Publication.publish'))\n    ActivityStarted(Activity(u'Publication.publish'))\n    WorkItemStarting(u'publish')\n    Published\n    WorkItemFinished(u'publish')\n    ActivityFinished(Activity(u'Publication.publish'))\n    ProcessFinished(Process(u'Publication'))\n    WorkItemStarted(u'publish')\n\n    >>> proc.workflowRelevantData.publish\n    True\n\n\nDescriptions\n------------\n\nMost process elements can have names and descriptions.\n\n    >>> pd.__name__\n    u'Publication'\n\n    >>> pd.description\n    u'This is the sample process'\n\n    >>> pd.applications['prepare'].__name__\n    u'Prepare'\n\n    >>> pd.applications['prepare'].description\n    u'Prepare the initial draft'\n\n    >>> pd.activities['tech1'].__name__\n    u'Technical Review 1'\n\n    >>> pd.activities['tech1'].description\n    u'This is the first Technical Review.'\n\n    >>> pd.participants['tech1'].__name__\n    u'Technical Reviewer 1'\n\n    >>> pd.participants['tech1'].description\n    u'He is a smart guy.'\n\n    >>> sorted([item.__name__ for item in pd.transitions])\n        [u'Transition', u'Transition', u'Transition', u'Transition',\n        u'Transition', u'Transition', u'Transition', u'Transition',\n        u'Transition', u'Transition', u'Transition to Tech Review 1',\n        u'Transition to Tech Review 2']\n\n    >>> descriptions = [item.description for item in pd.transitions if item.description]\n    >>> u'Use this transition if there are editorial changes required.' in descriptions\n    True\n\n\n\n\n=======\nCHANGES\n=======\n\n4.2.2 (2019-09-06)\n------------------\n\n- Exposed deadline parsing as `Activity.digestDeadlineDefinition`\n\n\n4.2.0 (2018-11-12)\n------------------\n\n- Add Python 3.7 support.\n\n- Remove Python 3.5 support.\n\n- Remvoe all deprecation and resource warnings.\n\n\n4.1.1 (2018-02-08)\n------------------\n\n- More Python 3 compatibility.\n\n\n4.1.0 (2018-02-06)\n------------------\n\n- Python 3 support.\n\n\n4.0.4 (2017-11-01)\n------------------\n\n- Make the `now` function pluggable.\n\n\n4.0.3 (2017-06-20)\n------------------\n\n- Nothing changed yet.\n\n\n4.0.2 (2017-05-25)\n------------------\n\n- Update and improve Trove classifiers.\n\n\n4.0.1 (2017-05-25)\n------------------\n\n- Fix small ReST issues, so that PyPI description will render.\n\n\n4.0.0 (2017-05-25)\n------------------\n\n- Renamed from `zope.wfmc` to `shoobx.wfmc`.\n\n- Added support for community CI and coverage tools.\n\n- Raise an exception on duplicate `ExtendedAttribute` `Name` in a single\n  `ExtendedAttributes` container\n\n- Use IProcessDefinitionFactory to retrieve process definitions instead of\n  named utilities. This additional layer of indirection allows to generate\n  definitions dynamically.\n\n- Support for synchronious and asynchronous execution of WFMC subflows.\n  Subflows are executed   as part of main process, however have their separate\n  state (workflow variables).\n\n- The simplistic Python ``evaluate(expr, locals)`` function has been replaced\n  by the `PythonExpressionEvaluator` component, which is an adapter from\n  `IProcess` to `IPythonExpressionEvaluator`. The evaluation locals namespace\n  is automatically filled with workflow- and application-relevant data\n  attributes, the context of the process and the passed in locals variable.\n\n  All calls of `evaluate()` have been updated to use the adapter.\n\n  This change allows for easy replacement of the evaluation engine to hook up\n  a safe Python engine (i.e. RestrictedPython) and to provide more namespace\n  entries.\n\n- Transition conditions can now be evaluated in the larger context of a\n  process, instead of just the workflow-relevant data. Thus their calling\n  signature changed from `condition(data)` to `condition(process, data)`.\n\n- `TextCondition` has been changed to use the `PythonExpressionEvaluator`\n  component. Also, the compile optimization has been removed, since the\n  expression evalautor can do this more effectively.\n\n- Support for aborting processes and activities.\n\n  * Work items can be abortable by implementing ``IAbortWorkItem``.\n\n  * Work items can be cleaned up, if they implement ``ICleanupWorkItem``.\n\n  * Activities keep track of finished work items.\n\n  * Activities can clean themselves up by cleaning up work items.\n\n  * Processes keep track of finished activities.\n\n  * When processes are aborted, the following is done:\n\n    + All activities are aborted.\n\n    + All finished activities are cleaned up.\n\n\t+ isAborted flag is set on a process.\n\n- Support for reading XPDL-2.1 added\n\n- Added reading Pools and Lanes from XPDL\n\n\n3.5.0 (2009-07-24)\n------------------\n\n- Update tests to latest package versions.\n\n\n3.4.0 (2007-11-02)\n------------------\n\n- Initial release independent of the main Zope tree.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/shoobx.wfmc", "keywords": "bpmn wfmc xpdl workflow engine", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "shoobx.wfmc", "package_url": "https://pypi.org/project/shoobx.wfmc/", "platform": "", "project_url": "https://pypi.org/project/shoobx.wfmc/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/shoobx.wfmc"}, "release_url": "https://pypi.org/project/shoobx.wfmc/4.2.2/", "requires_dist": null, "requires_python": "", "summary": "Workflow-Management Coalition Workflow Engine", "version": "4.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/Shoobx/shoobx.wfmc\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/Shoobx/shoobx.wfmc.png?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f09b2d9bc3236c462076655d7163097106c36331/68747470733a2f2f7472617669732d63692e6f72672f53686f6f62782f73686f6f62782e77666d632e706e673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/Shoobx/shoobx.wfmc?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/Shoobx/shoobx.wfmc/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2cc8e44a876becc283c7dc7a8de3ffa312964db3/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f53686f6f62782f73686f6f62782e77666d632f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.python.org/pypi/shoobx.wfmc\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/shoobx.wfmc.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ad9c9f39c9043962422f435f56f5a7fb732872cc/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f73686f6f62782e77666d632e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/shoobx.wfmc/\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/pyversions/shoobx.wfmc.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cbd2a3b8639936d482dc37e257479659dbe23493/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f73686f6f62782e77666d632e737667\"></a>\n<a href=\"https://codeclimate.com/github/Shoobx/shoobx.wfmc/maintainability\" rel=\"nofollow\"><img alt=\"Maintainability\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cec6c30f832cfbac79a820d6f1318e4501284bcf/68747470733a2f2f6170692e636f6465636c696d6174652e636f6d2f76312f6261646765732f66336332336538653162313961303361333765312f6d61696e7461696e6162696c697479\"></a>\n<p>This package provides an implementation of a Workflow-Management\nCoalition (WFMC) workflow engine. The engine is provided as a\ncollection of workflow process components. Workflow processes can be\ndefined in Python or via the XML Process-Definition Language, XPDL.</p>\n<div id=\"detailed-documentation\">\n<h2>Detailed Documentation</h2>\n<h2 id=\"workflow-management-coalition-workflow-engine\"><span class=\"section-subtitle\">Workflow-Management Coalition Workflow Engine</span></h2>\n<p>This package provides an implementation of a Workflow-Management\nCoalition (WFMC) workflow engine.  The engine is provided as a\ncollection of workflow process components.  Workflow processes can be\ndefined in Python or via the XML Process-Definition Language, XPDL.</p>\n<p>In this document, we\u2019ll look at Python-defined process definitions:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from shoobx.wfmc import process\n&gt;&gt;&gt; pd = process.ProcessDefinition('sample')\n</pre>\n</blockquote>\n<p>The argument to the process is a process id.</p>\n<p>A process has a number of parts.  Let\u2019s look at a sample review\nprocess:</p>\n<pre>                            -----------\n                         --&gt;| Publish |\n----------   ---------- /   -----------\n| Author |--&gt;| Review |-    ----------\n----------   ---------- \\--&gt;| Reject |\n                            ----------\n</pre>\n<p>Here we have a single start activity and 2 end activities.  We could\nhave modeled this with a single end activity, but that is not\nrequired.  A single start activity <em>is</em> required. A process definition\nhas a set of activities, with transitions between them.  Let\u2019s define\nthe activities for our process definition:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd.defineActivities(\n...     author  = process.ActivityDefinition(),\n...     review  = process.ActivityDefinition(),\n...     publish = process.ActivityDefinition(),\n...     reject  = process.ActivityDefinition(),\n...     )\n</pre>\n</blockquote>\n<p>We supply activities as keyword arguments. The argument names provide\nactivity ids that we\u2019ll use when defining transitions:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd.defineTransitions(\n...     process.TransitionDefinition('author', 'review'),\n...     process.TransitionDefinition('review', 'publish'),\n...     process.TransitionDefinition('review', 'reject'),\n...     )\n</pre>\n</blockquote>\n<p>Each transition is constructed with an identifier for a starting\nactivity, and an identifier for an ending activity.</p>\n<p>Before we can use a workflow definition, we have to register it as a\nutility. This is necessary so that process instances can find their\ndefinitions.  In addition, the utility name must match the process id:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from shoobx.wfmc.process import StaticProcessDefinitionFactory\n&gt;&gt;&gt; pdfactory = StaticProcessDefinitionFactory()\n&gt;&gt;&gt; zope.component.provideUtility(pdfactory)\n&gt;&gt;&gt; pdfactory.register(pd)\n</pre>\n</blockquote>\n<p>Now, with this definition, we can execute our workflow.  We haven\u2019t\ndefined any work yet, but we can see the workflow execute.  We\u2019ll see\nthe workflow executing by registering a subscriber that logs workflow\nevents:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def log_workflow(event):\n...     print (event)\n</pre>\n<pre>&gt;&gt;&gt; import zope.event\n&gt;&gt;&gt; zope.event.subscribers.append(log_workflow)\n</pre>\n</blockquote>\n<p>To use the workflow definition, we need to create an instance:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proc = pd()\n</pre>\n</blockquote>\n<p>Now, if we start the workflow:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proc.start()\nProcessStarted(Process('sample'))\nTransition(None, Activity('sample.author'))\nActivityStarted(Activity('sample.author'))\nActivityFinished(Activity('sample.author'))\nTransition(Activity('sample.author'), Activity('sample.review'))\nActivityStarted(Activity('sample.review'))\nActivityFinished(Activity('sample.review'))\nTransition(Activity('sample.review'), Activity('sample.publish'))\nActivityStarted(Activity('sample.publish'))\nActivityFinished(Activity('sample.publish'))\nProcessFinished(Process('sample'))\n</pre>\n</blockquote>\n<p>we see that we transition immediately into the author activity, then\ninto review and publish.  Normally, we\u2019d need to do some work in each\nactivity, and transitions would continue only after work had been\ndone, however, in this case, we didn\u2019t define any work, so each\nactivity completed immediately.</p>\n<p>Note that we didn\u2019t transition into the rejected activity.  By\ndefault, when an activity is completed, the first transition for which\nits condition evaluates to <cite>True</cite> is used.  By default, transitions\nhave boolean conditions that evaluate to <cite>True</cite>, so the transition\nto <cite>publish</cite> is used because it was defined before the transition to\n<cite>reject</cite>.  What we want is to transition to <cite>publish</cite> if a reviewer\napproves the content for publication, but to <cite>reject</cite> if the reviewer\nrejects the content for publication.  We can use a condition for this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd = process.ProcessDefinition('sample')\n&gt;&gt;&gt; pdfactory.register(pd)\n</pre>\n<pre>&gt;&gt;&gt; pd.defineActivities(\n...     author = process.ActivityDefinition(),\n...     review = process.ActivityDefinition(),\n...     publish = process.ActivityDefinition(),\n...     reject = process.ActivityDefinition(),\n...     )\n&gt;&gt;&gt; pd.defineTransitions(\n...     process.TransitionDefinition('author', 'review'),\n...     process.TransitionDefinition(\n...         'review', 'publish',\n...         condition=lambda proc: proc.workflowRelevantData.publish),\n...     process.TransitionDefinition('review', 'reject'),\n...     )\n</pre>\n</blockquote>\n<p>We redefined the workflow process, specifying a condition for the\ntransition to <cite>publish</cite>.  Boolean conditions are just callable objects that\ntake a data object and return a boolean value.  The data object is\ncalled \u201cworkflow-relevant data\u201d.  A process instance has a data object\ncontaining this data.  In the example, above, the condition simply\nreturned the value of the <cite>publish</cite> attribute. How does this attribute\nget set? It needs to be set by the review activity. To do that, we\nneed to arrange for the activity to set the data.  This brings us to\napplications.</p>\n<p>Process definitions are meant to be used with different\napplications. For this reason, process definitions don\u2019t include\napplication logic.  What they do include is a specifications of the\napplications to be invoked and the flow of work-flow-relevant data to\nand from the application.  Now, we can define our applications:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd.defineApplications(\n...     author = process.Application(),\n...     review = process.Application(\n...         process.OutputParameter('publish')),\n...     publish = process.Application(),\n...     reject = process.Application(),\n...     )\n</pre>\n</blockquote>\n<p>We used the same names for the applications that we used for our\nactivities. This isn\u2019t required, but is a common practice.  Note that\nthe <cite>review</cite> application includes a specification of an output\nparameter.  Now that we\u2019ve defined our applications, we need to modify\nour activities to use them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd.activities['author'].addApplication('author')\n&gt;&gt;&gt; pd.activities['review'].addApplication('review', ['publish'])\n&gt;&gt;&gt; pd.activities['publish'].addApplication('publish')\n&gt;&gt;&gt; pd.activities['reject'].addApplication('reject')\n</pre>\n</blockquote>\n<p>An activity can use many applications, so we call <cite>addApplication</cite>.\nIn the application definition for the \u2018review\u2019 application, we\nprovided the name of a workflow-relevent data variable corresponding\nto the output parameter defined for the application.  When using an\napplication in an activity, a workflow-relevent data variable name\nmust be provided for each of the parameters in the identified\napplications\u2019s signature.  When an application is used in an activity,\nworkflow-relevent data are passed for each of the input parameters and\nare set by each of the output parameters. In this example, the output\nparameter, will be used to add a <cite>publish</cite> attribute to the workflow\nrelevant data.</p>\n<div id=\"participants\">\n<h3>Participants</h3>\n<p>We\u2019ve declared some applications, and we\u2019ve wired them up to\nactivities, but we still haven\u2019t specified any application code. Before\nwe can specify application code, we need to consider who will be\nperforming the application.  Workflow applications are normally\nexecuted by people, or other external actors.  As with applications,\nprocess definitions allow participants in the workflow to be declared\nand identified with activities.  We declare participants much as we\ndeclare applications, except without parameters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd.defineParticipants(\n...     author   = process.Participant(),\n...     reviewer = process.Participant(),\n...     )\n</pre>\n</blockquote>\n<p>In this case, we happened to reuse an activity name for one, but\nnot both of the participants.  Having defined these participants, we\ncan associate them with activities:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd.activities['author'].definePerformer('author')\n&gt;&gt;&gt; pd.activities['review'].definePerformer('reviewer')\n</pre>\n</blockquote>\n</div>\n<div id=\"application-integration\">\n<h3>Application Integration</h3>\n<p>To use a process definition to control application logic, we need to\nassociate it with an \u201cintegration\u201d object.</p>\n<p>When a process needs to get a participant, it calls createParticipant\non its integration attribute, passing the process id and the\nperformer id. If an activity doesn\u2019t have a\nperformer, then the procedure above is used with an empty performer id.</p>\n<p>Similarly, when a process needs a work item, it calls createWorkItem\non its integration attribute, passing the process id and the\napplication id.</p>\n<p>Work items provide a <cite>start</cite> method, which is used to start the work\nand pass input arguments.  It is the responsibility of the work item,\nat some later time, to call the <cite>workItemFinished</cite> method on the\nactivity, to notify the activity that the work item was\ncompleted. Output parameters are passed to the <cite>workItemFinished</cite>\nmethod.</p>\n<p>A simple way to create integration objects is with\n<cite>shoobx.wfmc.attributeintegration.AttributeIntegration</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from shoobx.wfmc.attributeintegration import AttributeIntegration\n&gt;&gt;&gt; integration = AttributeIntegration()\n&gt;&gt;&gt; pd.integration = integration\n</pre>\n</blockquote>\n<p>We\u2019ll start by defining a simple Participant class:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; from shoobx.wfmc import interfaces\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.IParticipant)\n... class Participant(object):\n...     zope.component.adapts(interfaces.IActivity)\n...\n...     def __init__(self, activity, process):\n...         self.activity = activity\n</pre>\n</blockquote>\n<p>We set attributes on the integration for each participant:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; integration.authorParticipant   = Participant\n&gt;&gt;&gt; integration.reviewerParticipant = Participant\n</pre>\n</blockquote>\n<p>We also define an attribute for participants for activities that don\u2019t\nhave performers:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; integration.Participant = Participant\n</pre>\n</blockquote>\n<p>Now we\u2019ll define our work-items. First we\u2019ll define some classes:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; work_list = []\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.IWorkItem)\n... class ApplicationBase:\n...     zope.component.adapts(interfaces.IParticipant)\n...\n...     def __init__(self, participant, process, activity):\n...         self.participant = participant\n...         work_list.append(self)\n...\n...     def start(self, args):\n...         pass\n...\n...     def finish(self):\n...         self.participant.activity.workItemFinished(self)\n</pre>\n<pre>&gt;&gt;&gt; class Review(ApplicationBase):\n...     def finish(self, publish):\n...         output = {'publish': publish}\n...         self.participant.activity.workItemFinished(self, output)\n</pre>\n<pre>&gt;&gt;&gt; class Publish(ApplicationBase):\n...     def start(self, args):\n...         print (\"Published\")\n...         self.finish()\n</pre>\n<pre>&gt;&gt;&gt; class Reject(ApplicationBase):\n...     def start(self, args):\n...         print (\"Rejected\")\n...         self.finish()\n</pre>\n</blockquote>\n<p>and then we\u2019ll hook them up with the integration object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; integration.authorWorkItem  = ApplicationBase\n&gt;&gt;&gt; integration.reviewWorkItem  = Review\n&gt;&gt;&gt; integration.publishWorkItem = Publish\n&gt;&gt;&gt; integration.rejectWorkItem  = Reject\n</pre>\n</blockquote>\n</div>\n<div id=\"using-workflow-processes\">\n<h3>Using workflow processes</h3>\n<p>To use a process definition, instantiate it and call its start method\nto start execution:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proc = pd()\n&gt;&gt;&gt; proc.start()\n... # doctest: +NORMALIZE_WHITESPACE\nProcessStarted(Process('sample'))\nTransition(None, Activity('sample.author'))\nActivityStarted(Activity('sample.author'))\nWorkItemStarting('author')\nWorkItemStarted('author')\n</pre>\n</blockquote>\n<p>We transition into the author activity and wait for work to get done.\nTo move forward, we need to get at the authoring work item, so we can\nfinish it.  Our work items add themselves to a work list, so we can\nget the item from the list.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = work_list.pop()\n</pre>\n</blockquote>\n<p>Now we can finish the work item, by calling its finish method:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item.finish()\nWorkItemFinished('author')\nActivityFinished(Activity('sample.author'))\nTransition(Activity('sample.author'), Activity('sample.review'))\nActivityStarted(Activity('sample.review'))\nWorkItemStarting('review')\nWorkItemStarted('review')\n</pre>\n</blockquote>\n<p>We see that we transitioned to the review activity.  Note that the\n<cite>finish</cite> method isn\u2019t a part of the workflow APIs.  It was defined by\nour sample classes. Other applications could use different mechanisms.</p>\n<p>Now, we\u2019ll finish the review process by calling the review work item\u2019s\n<cite>finish</cite>. We\u2019ll pass <cite>False</cite>, indicating that the content should not\nbe published:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; work_list.pop().finish(False)\nWorkItemFinished('review')\nActivityFinished(Activity('sample.review'))\nTransition(Activity('sample.review'), Activity('sample.reject'))\nActivityStarted(Activity('sample.reject'))\nWorkItemStarting('reject')\nRejected\nWorkItemFinished('reject')\nActivityFinished(Activity('sample.reject'))\nProcessFinished(Process('sample'))\nWorkItemStarted('reject')\n</pre>\n</blockquote>\n</div>\n<div id=\"ordering-output-transitions\">\n<h3>Ordering output transitions</h3>\n<p>Normally, outgoing transitions are ordered in the order of transition\ndefinition and all transitions from a given activity are used.</p>\n<p>If transitions are defined in an inconvenient order, then the workflow\nmight not work as expected.  For example, let\u2019s modify the above\nprocess by switching the order of definition of some of the\ntransitions.  We\u2019ll reuse our integration object from the previous\nexample by passing it to the definition constructor:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd = process.ProcessDefinition('sample', integration)\n&gt;&gt;&gt; pdfactory.register(pd)\n</pre>\n<pre>&gt;&gt;&gt; pd.defineActivities(\n...     author = process.ActivityDefinition(),\n...     review = process.ActivityDefinition(),\n...     publish = process.ActivityDefinition(),\n...     reject = process.ActivityDefinition(),\n...     )\n&gt;&gt;&gt; pd.defineTransitions(\n...     process.TransitionDefinition('author', 'review'),\n...     process.TransitionDefinition('review', 'reject'),\n...     process.TransitionDefinition(\n...         'review', 'publish',\n...         condition=lambda proc: proc.workflowRelevantData.publish),\n...     )\n</pre>\n<pre>&gt;&gt;&gt; pd.defineApplications(\n...     author = process.Application(),\n...     review = process.Application(\n...         process.OutputParameter('publish')),\n...     publish = process.Application(),\n...     reject = process.Application(),\n...     )\n</pre>\n<pre>&gt;&gt;&gt; pd.activities['author'].addApplication('author')\n&gt;&gt;&gt; pd.activities['review'].addApplication('review', ['publish'])\n&gt;&gt;&gt; pd.activities['publish'].addApplication('publish')\n&gt;&gt;&gt; pd.activities['reject'].addApplication('reject')\n</pre>\n<pre>&gt;&gt;&gt; pd.defineParticipants(\n...     author   = process.Participant(),\n...     reviewer = process.Participant(),\n...     )\n</pre>\n<pre>&gt;&gt;&gt; pd.activities['author'].definePerformer('author')\n&gt;&gt;&gt; pd.activities['review'].definePerformer('reviewer')\n</pre>\n</blockquote>\n<p>and run our process:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proc = pd()\n&gt;&gt;&gt; proc.start()\n... # doctest: +NORMALIZE_WHITESPACE\nProcessStarted(Process('sample'))\nTransition(None, Activity('sample.author'))\nActivityStarted(Activity('sample.author'))\nWorkItemStarting('author')\nWorkItemStarted('author')\n</pre>\n<pre>&gt;&gt;&gt; work_list.pop().finish()\nWorkItemFinished('author')\nActivityFinished(Activity('sample.author'))\nTransition(Activity('sample.author'), Activity('sample.review'))\nActivityStarted(Activity('sample.review'))\nWorkItemStarting('review')\nWorkItemStarted('review')\n</pre>\n</blockquote>\n<p>This time, we\u2019ll say that we should publish:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; work_list.pop().finish(True)\nWorkItemFinished('review')\nActivityFinished(Activity('sample.review'))\nTransition(Activity('sample.review'), Activity('sample.reject'))\nActivityStarted(Activity('sample.reject'))\nWorkItemStarting('reject')\nRejected\nWorkItemFinished('reject')\nActivityFinished(Activity('sample.reject'))\nProcessFinished(Process('sample'))\nWorkItemStarted('reject')\n</pre>\n</blockquote>\n<p>But we went to the reject activity anyway. Why? Because transitions\nare tested in order. Because the transition to the reject activity was\ntested first and had no condition, we followed it without checking the\ncondition for the transition to the publish activity.  We can fix this\nby specifying outgoing transitions on the reviewer activity directly.\nTo do this, we\u2019ll also need to specify ids in our transitions.  Let\u2019s\nredefine the process:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd = process.ProcessDefinition('sample', integration)\n&gt;&gt;&gt; pdfactory.register(pd)\n</pre>\n<pre>&gt;&gt;&gt; pd.defineActivities(\n...     author = process.ActivityDefinition(),\n...     review = process.ActivityDefinition(),\n...     publish = process.ActivityDefinition(),\n...     reject = process.ActivityDefinition(),\n...     )\n&gt;&gt;&gt; pd.defineTransitions(\n...     process.TransitionDefinition('author', 'review'),\n...     process.TransitionDefinition('review', 'reject', id='reject'),\n...     process.TransitionDefinition(\n...         'review', 'publish', id='publish',\n...         condition=lambda proc: proc.workflowRelevantData.publish),\n...     )\n</pre>\n<pre>&gt;&gt;&gt; pd.defineApplications(\n...     author = process.Application(),\n...     review = process.Application(\n...         process.OutputParameter('publish')),\n...     publish = process.Application(),\n...     reject = process.Application(),\n...     )\n</pre>\n<pre>&gt;&gt;&gt; pd.activities['author'].addApplication('author')\n&gt;&gt;&gt; pd.activities['review'].addApplication('review', ['publish'])\n&gt;&gt;&gt; pd.activities['publish'].addApplication('publish')\n&gt;&gt;&gt; pd.activities['reject'].addApplication('reject')\n</pre>\n<pre>&gt;&gt;&gt; pd.defineParticipants(\n...     author   = process.Participant(),\n...     reviewer = process.Participant(),\n...     )\n</pre>\n<pre>&gt;&gt;&gt; pd.activities['author'].definePerformer('author')\n&gt;&gt;&gt; pd.activities['review'].definePerformer('reviewer')\n</pre>\n<pre>&gt;&gt;&gt; pd.activities['review'].addOutgoing('publish')\n&gt;&gt;&gt; pd.activities['review'].addOutgoing('reject')\n</pre>\n</blockquote>\n<p>Now, when we run the process, we\u2019ll go to the publish activity as\nexpected:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proc = pd()\n&gt;&gt;&gt; proc.start()\n... # doctest: +NORMALIZE_WHITESPACE\nProcessStarted(Process('sample'))\nTransition(None, Activity('sample.author'))\nActivityStarted(Activity('sample.author'))\nWorkItemStarting('author')\nWorkItemStarted('author')\n</pre>\n<pre>&gt;&gt;&gt; work_list.pop().finish()\nWorkItemFinished('author')\nActivityFinished(Activity('sample.author'))\nTransition(Activity('sample.author'), Activity('sample.review'))\nActivityStarted(Activity('sample.review'))\nWorkItemStarting('review')\nWorkItemStarted('review')\n</pre>\n<pre>&gt;&gt;&gt; work_list.pop().finish(True)\nWorkItemFinished('review')\nActivityFinished(Activity('sample.review'))\nTransition(Activity('sample.review'), Activity('sample.publish'))\nActivityStarted(Activity('sample.publish'))\nWorkItemStarting('publish')\nPublished\nWorkItemFinished('publish')\nActivityFinished(Activity('sample.publish'))\nProcessFinished(Process('sample'))\nWorkItemStarted('publish')\n</pre>\n</blockquote>\n<p>Let\u2019s see the other way also, where we should transition to reject:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proc = pd()\n&gt;&gt;&gt; proc.start()\n... # doctest: +NORMALIZE_WHITESPACE\nProcessStarted(Process('sample'))\nTransition(None, Activity('sample.author'))\nActivityStarted(Activity('sample.author'))\nWorkItemStarting('author')\nWorkItemStarted('author')\n</pre>\n<pre>&gt;&gt;&gt; work_list.pop().finish()\nWorkItemFinished('author')\nActivityFinished(Activity('sample.author'))\nTransition(Activity('sample.author'), Activity('sample.review'))\nActivityStarted(Activity('sample.review'))\nWorkItemStarting('review')\nWorkItemStarted('review')\n</pre>\n<pre>&gt;&gt;&gt; work_list.pop().finish(False)\nWorkItemFinished('review')\nActivityFinished(Activity('sample.review'))\nTransition(Activity('sample.review'), Activity('sample.reject'))\nActivityStarted(Activity('sample.reject'))\nWorkItemStarting('reject')\nRejected\nWorkItemFinished('reject')\nActivityFinished(Activity('sample.reject'))\nProcessFinished(Process('sample'))\nWorkItemStarted('reject')\n</pre>\n</blockquote>\n</div>\n<div id=\"complex-flows\">\n<h3>Complex Flows</h3>\n<p>Lets look at a more complex example.  In this example, we\u2019ll extend\nthe process to work with multiple reviewers.  We\u2019ll also make the\nwork-list handling a bit more sophisticated.  We\u2019ll also introduce\nsome new concepts:</p>\n<ul>\n<li>splits and joins</li>\n<li>process arguments</li>\n</ul>\n<p>Consider the publication\nprocess shown below:</p>\n<pre>Author:      Tech          Tech          Editorial\n             Reviewer 1:   Reviewer 2:   Reviewer:\n===========  ===========   ===========   ==============\n                                                         ---------\n     ----------------------------------------------------| Start |\n    /                                                    ---------\n    |\n    V\n-----------\n| Prepare |&lt;------------------------------\\\n-----------                                \\\n    |        ------------                   \\\n    |        | Tech     |--------------- \\   \\\n    |-------&gt;| Review 1 |                 V   |\n    |        ------------  ----------    -------------\n     \\                     | Tech   |    | Editorial |   ----------\n       -------------------&gt;| Review |---&gt;| Review    |--&gt;| Reject |\n                           | 2      |    -------------   ----------\n                           ----------      |      |\n-----------                               /        \\\n| Prepare |                              /          \\--------\\\n| Final   |&lt;----------------------------/                    |\n-----------                                                  |\n   ^   |                                 ----------          V\n   |    \\-------------------------------&gt;| Review |      -----------\n    \\                                    | Final  |-----&gt;| Publish |\n     ------------------------------------|        |      -----------\n                                         ----------\n</pre>\n<p>Here we\u2019ve arranged the process diagram into columns, with the\nactivities for each participant. We have four participants, the\nauthor, two technical reviewers, and an editorial reviewer.  The\nauthor prepares a draft.  The author sends the draft to <em>both</em>\ntechnical reviewers for review.  When the technical reviews have\ncompleted, the editorial review does an initial editorial\nreview. Based on the technical reviews, the editor may choose to:</p>\n<ul>\n<li>Reject the document</li>\n<li>Publish the document as is</li>\n<li>Request technical changes (based on the technical reviewers\u2019\ncomments), or</li>\n<li>Request editorial changes.</li>\n</ul>\n<p>If technical changes are required, the work flows back to the\n\u201cPrepare\u201d activity.  If editorial changes are necessary, then work\nflows to the \u201cPrepare Final\u201d activity.  When the author has made the\neditorial changes, work flows to \u201cReview Final\u201d.  The editor may\nrequest additional changes, in which case, work flows back to \u201cPrepare\nFinal\u201d, otherwise, the work flows to \u201cPublish\u201d.</p>\n<p>This example illustrates different kinds of \u201cjoins\u201d and \u201csplits\u201d.  The\nterm \u201cjoin\u201d refers to the way incoming transitions to an activity are\nhandled. There are two kinds of joins: \u201cand\u201d and \u201cxor\u201d.  With an \u201cand\u201d\njoin, the activity waits for each of the incoming transitions.  In\nthis example, the inputs to the \u201cEditorial Review\u201d activity form an\n\u201cand\u201d join.  Editorial review waits until each of the technical\nreviews are completed.  The rest of the joins in this example are\n\u201cxor\u201d joins.  The activity starts on any transition into the activity.</p>\n<p>The term \u201csplit\u201d refers to way outgoing transitions from an activity\nare handled.  Normally, exactly one transition out of an activity is\nused. This is called an \u201cxor\u201d split.  With an \u201cand\u201d split, all\ntransitions with boolean conditions that evaluate to <cite>True</cite> are used.\nIn this example, the \u201cPrepare\u201d activity has an \u201cand\u201d split.  Work\nflows simultaneously to the two technical review activities.  The rest\nof the splits in this example are \u201cxor\u201d splits.</p>\n<p>Lets create our new workflow process. We\u2019ll reuse our existing\nintegration object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; Publication = process.ProcessDefinition('Publication')\n&gt;&gt;&gt; Publication.integration = integration\n&gt;&gt;&gt; pdfactory.register(Publication)\n</pre>\n<pre>&gt;&gt;&gt; Publication.defineActivities(\n...     start   = process.ActivityDefinition(\"Start\"),\n...     prepare = process.ActivityDefinition(\"Prepare\"),\n...     tech1   = process.ActivityDefinition(\"Technical Review 1\"),\n...     tech2   = process.ActivityDefinition(\"Technical Review 2\"),\n...     review  = process.ActivityDefinition(\"Editorial Review\"),\n...     final   = process.ActivityDefinition(\"Final Preparation\"),\n...     rfinal  = process.ActivityDefinition(\"Review Final\"),\n...     publish = process.ActivityDefinition(\"Publish\"),\n...     reject  = process.ActivityDefinition(\"Reject\"),\n...     )\n</pre>\n</blockquote>\n<p>Here, we\u2019ve passed strings to the activity definitions providing\nnames. Names must be either unicode or ASCII strings.</p>\n<p>We define our transitions:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; Publication.defineTransitions(\n...     process.TransitionDefinition('start', 'prepare'),\n...     process.TransitionDefinition('prepare', 'tech1'),\n...     process.TransitionDefinition('prepare', 'tech2'),\n...     process.TransitionDefinition('tech1', 'review'),\n...     process.TransitionDefinition('tech2', 'review'),\n...\n...     process.TransitionDefinition(\n...         'review', 'reject',\n...         condition=lambda proc: not proc.workflowRelevantData.publish\n...         ),\n...     process.TransitionDefinition(\n...         'review', 'prepare',\n...         condition=lambda proc: proc.workflowRelevantData.tech_changes\n...         ),\n...     process.TransitionDefinition(\n...         'review', 'final',\n...         condition=lambda proc: proc.workflowRelevantData.ed_changes\n...         ),\n...     process.TransitionDefinition('review', 'publish'),\n...\n...     process.TransitionDefinition('final', 'rfinal'),\n...     process.TransitionDefinition(\n...         'rfinal', 'final',\n...         condition=lambda proc: proc.workflowRelevantData.ed_changes\n...         ),\n...     process.TransitionDefinition('rfinal', 'publish'),\n...     )\n</pre>\n</blockquote>\n<p>We specify our \u201cand\u201d split and join:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; Publication.activities['prepare'].andSplit(True)\n&gt;&gt;&gt; Publication.activities['review'].andJoin(True)\n</pre>\n</blockquote>\n<p>We define our participants and applications:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; Publication.defineParticipants(\n...     author   = process.Participant(\"Author\"),\n...     tech1    = process.Participant(\"Technical Reviewer 1\"),\n...     tech2    = process.Participant(\"Technical Reviewer 2\"),\n...     reviewer = process.Participant(\"Editorial Reviewer\"),\n...     )\n</pre>\n<pre>&gt;&gt;&gt; Publication.defineApplications(\n...     prepare = process.Application(),\n...     tech_review = process.Application(\n...         process.OutputParameter('publish'),\n...         process.OutputParameter('tech_changes'),\n...         ),\n...     ed_review = process.Application(\n...         process.InputParameter('publish1'),\n...         process.InputParameter('tech_changes1'),\n...         process.InputParameter('publish2'),\n...         process.InputParameter('tech_changes2'),\n...         process.OutputParameter('publish'),\n...         process.OutputParameter('tech_changes'),\n...         process.OutputParameter('ed_changes'),\n...         ),\n...     publish = process.Application(),\n...     reject = process.Application(),\n...     final = process.Application(),\n...     rfinal = process.Application(\n...         process.OutputParameter('ed_changes'),\n...         ),\n...     )\n</pre>\n<pre>&gt;&gt;&gt; Publication.activities['prepare'].definePerformer('author')\n&gt;&gt;&gt; Publication.activities['prepare'].addApplication('prepare')\n</pre>\n<pre>&gt;&gt;&gt; Publication.activities['tech1'].definePerformer('tech1')\n&gt;&gt;&gt; Publication.activities['tech1'].addApplication(\n...     'tech_review', ['publish1', 'tech_changes1'])\n</pre>\n<pre>&gt;&gt;&gt; Publication.activities['tech2'].definePerformer('tech2')\n&gt;&gt;&gt; Publication.activities['tech2'].addApplication(\n...     'tech_review', ['publish2', 'tech_changes2'])\n</pre>\n<pre>&gt;&gt;&gt; Publication.activities['review'].definePerformer('reviewer')\n&gt;&gt;&gt; Publication.activities['review'].addApplication(\n...     'ed_review',\n...     ['publish1', 'tech_changes1', 'publish2', 'tech_changes2',\n...      'publish', 'tech_changes', 'ed_changes'],\n...     )\n</pre>\n<pre>&gt;&gt;&gt; Publication.activities['final'].definePerformer('author')\n&gt;&gt;&gt; Publication.activities['final'].addApplication('final')\n</pre>\n<pre>&gt;&gt;&gt; Publication.activities['rfinal'].definePerformer('reviewer')\n&gt;&gt;&gt; Publication.activities['rfinal'].addApplication(\n...     'rfinal', ['ed_changes'],\n...     )\n</pre>\n<pre>&gt;&gt;&gt; Publication.activities['publish'].addApplication('publish')\n&gt;&gt;&gt; Publication.activities['reject'].addApplication('reject')\n</pre>\n</blockquote>\n<p>We want to be able to specify an author when we start the process.\nWe\u2019d also like to be told the final disposition of the process.  To\naccomplish this, we\u2019ll define parameters for our process:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; Publication.defineParameters(\n...     process.InputParameter('author'),\n...     process.OutputParameter('publish'),\n...     )\n</pre>\n</blockquote>\n<p>Now that we\u2019ve defined the process, we need to provide participant and\napplication components.  Let\u2019s start with our participants.  Rather\nthan sharing a single work list, we\u2019ll give each user their own\nwork list.  We\u2019ll also create preexisting participants and return\nthem. Finally, we\u2019ll create multiple authors and use the selected one:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class User:\n...     def __init__(self):\n...         self.work_list = []\n</pre>\n<pre>&gt;&gt;&gt; authors = {'bob': User(), 'ted': User(), 'sally': User()}\n</pre>\n<pre>&gt;&gt;&gt; reviewer = User()\n&gt;&gt;&gt; tech1 = User()\n&gt;&gt;&gt; tech2 = User()\n</pre>\n<pre>&gt;&gt;&gt; class Author(Participant):\n...     def __init__(self, activity, process):\n...         Participant.__init__(self, activity, process)\n...         author_name = activity.process.workflowRelevantData.author\n...         print((\"Author `%s` selected\" % author_name))\n...         self.user = authors[author_name]\n</pre>\n</blockquote>\n<p>In this example, we need to define a separate attribute for each participant:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; integration.authorParticipant = Author\n</pre>\n</blockquote>\n<p>When the process is created, the author name will be passed in and\nassigned to the workflow-relevant data.  Our author class uses this\ninformation to select the named user.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Reviewer(Participant):\n...     user = reviewer\n&gt;&gt;&gt; integration.reviewerParticipant = Reviewer\n</pre>\n<pre>&gt;&gt;&gt; class Tech1(Participant):\n...     user = tech1\n&gt;&gt;&gt; integration.tech1Participant = Tech1\n</pre>\n<pre>&gt;&gt;&gt; class Tech2(Participant):\n...     user = tech2\n&gt;&gt;&gt; integration.tech2Participant = Tech2\n</pre>\n</blockquote>\n<p>We\u2019ll use our orginal participation class for activities without\nperformers:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; integration.Participant = Participant\n</pre>\n</blockquote>\n<p>Now we\u2019ll create our applications. Let\u2019s start with our author:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.IWorkItem)\n... class ApplicationBase(object):\n...     zope.component.adapts(interfaces.IParticipant)\n...\n...     def __init__(self, participant, process, activity):\n...         self.participant = participant\n...         self.activity = participant.activity\n...         participant.user.work_list.append(self)\n...\n...     def start(self, args):\n...         pass\n...\n...     def finish(self):\n...         self.participant.activity.workItemFinished(self)\n</pre>\n<pre>&gt;&gt;&gt; class Prepare(ApplicationBase):\n...\n...     def summary(self):\n...         process = self.activity.process\n...         doc = getattr(process.applicationRelevantData, 'doc', '')\n...         if doc:\n...             print ('Previous draft:')\n...             print (doc)\n...             print ('Changes we need to make:')\n...             for change in process.workflowRelevantData.tech_changes:\n...                 print (change)\n...         else:\n...             print ('Please write the initial draft')\n...\n...     def finish(self, doc):\n...         self.activity.process.applicationRelevantData.doc = doc\n...         super(Prepare, self).finish()\n</pre>\n<pre>&gt;&gt;&gt; integration.prepareWorkItem = Prepare\n</pre>\n</blockquote>\n<p>Since we used the prepare application for revisions as well as initial\npreparation, we provide a summary method to show us what we have to do.</p>\n<p>Here we get the document created by the author passed in as an\nargument to the finish method.  In a more realistic implementation,\nthe author task would create the document at the start of the task and\nprovide a user interface for the user to edit it.  We store the\ndocument as application-relevant data, since we\u2019ll want reviewers to\nbe able to access it, but we don\u2019t need it directly for workflow\ncontrol.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class TechReview(ApplicationBase):\n...\n...     def getDoc(self):\n...         return self.activity.process.applicationRelevantData.doc\n...\n...     def finish(self, decision, changes):\n...         output = {'publish': decision, 'tech_changes': changes}\n...         self.activity.workItemFinished(self, output)\n</pre>\n<pre>&gt;&gt;&gt; integration.tech_reviewWorkItem = TechReview\n</pre>\n</blockquote>\n<p>Here, we provided a method to access the original document.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Review(TechReview):\n...\n...     def start(self, args):\n...         publish1 = args['publish1']\n...         publish2 = args['publish2']\n...         changes1 = args['tech_changes1']\n...         changes2 = args['tech_changes2']\n...         if not (publish1 and publish2):\n...             output = {'publish': False,\n...                       'tech_changes': changes1 + changes2,\n...                       'ed_changes': ()}\n...             # Reject if either tech reviewer rejects\n...             self.activity.workItemFinished(\n...                 self, output)\n...\n...         if changes1 or changes2:\n...             output = {'publish': True,\n...                       'tech_changes': changes1 + changes2,\n...                       'ed_changes': ()}\n...             # we won't do anything if there are tech changes\n...             self.activity.workItemFinished(\n...                 self, output)\n...\n...     def finish(self, ed_changes):\n...         output = {'publish': True, 'tech_changes': (), 'ed_changes': ed_changes}\n...         self.activity.workItemFinished(self, output)\n</pre>\n<pre>&gt;&gt;&gt; integration.ed_reviewWorkItem = Review\n</pre>\n</blockquote>\n<p>In this implementation, we decided to reject outright if either\ntechnical editor recommended rejection and to send work back to\npreparation if there are any technical changes. We also subclassed\n<cite>TechReview</cite> to get the <cite>getDoc</cite> method.</p>\n<p>We\u2019ll reuse the <cite>publish</cite> and <cite>reject</cite> application from the previous\nexample.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Final(ApplicationBase):\n...\n...     def summary(self):\n...         process = self.activity.process\n...         doc = getattr(process.applicationRelevantData, 'doc', '')\n...         print ('Previous draft:')\n...         print((self.activity.process.applicationRelevantData.doc))\n...         print ('Changes we need to make:')\n...         for change in process.workflowRelevantData.ed_changes:\n...            print (change)\n...\n...     def finish(self, doc):\n...         self.activity.process.applicationRelevantData.doc = doc\n...         super(Final, self).finish()\n</pre>\n<pre>&gt;&gt;&gt; integration.finalWorkItem = Final\n</pre>\n</blockquote>\n<p>In our this application, we simply update the document to reflect\nchanges.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class ReviewFinal(TechReview):\n...\n...     def finish(self, ed_changes):\n...         output = {'ed_changes': ed_changes}\n...         self.activity.workItemFinished(self, output)\n</pre>\n<pre>&gt;&gt;&gt; integration.rfinalWorkItem = ReviewFinal\n</pre>\n</blockquote>\n<p>Our process now returns data.  When we create a process, we need to\nsupply an object that it can call back to:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.IProcessContext)\n... class PublicationContext:\n...\n...     def processFinished(self, process, decision):\n...         self.decision = decision\n</pre>\n</blockquote>\n<p>Now, let\u2019s try out our process:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context = PublicationContext()\n&gt;&gt;&gt; proc = Publication(context)\n&gt;&gt;&gt; proc.start('bob')\nProcessStarted(Process('Publication'))\nTransition(None, Activity('Publication.start'))\nActivityStarted(Activity('Publication.start'))\nActivityFinished(Activity('Publication.start'))\nAuthor `bob` selected\nTransition(Activity('Publication.start'), Activity('Publication.prepare'))\nActivityStarted(Activity('Publication.prepare'))\nWorkItemStarting('prepare')\nWorkItemStarted('prepare')\n</pre>\n</blockquote>\n<p>We should have added an item to bob\u2019s work list. Let\u2019s get it and\nfinish it, submitting a document:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = authors['bob'].work_list.pop()\n&gt;&gt;&gt; item.finish(\"I give my pledge, as an American\\n\"\n...             \"to save, and faithfully to defend from waste\\n\"\n...             \"the natural resources of my Country.\")\nWorkItemFinished('prepare')\nActivityFinished(Activity('Publication.prepare'))\nTransition(Activity('Publication.prepare'), Activity('Publication.tech1'))\nActivityStarted(Activity('Publication.tech1'))\nWorkItemStarting('tech_review')\nWorkItemStarted('tech_review')\nTransition(Activity('Publication.prepare'), Activity('Publication.tech2'))\nActivityStarted(Activity('Publication.tech2'))\nWorkItemStarting('tech_review')\nWorkItemStarted('tech_review')\n</pre>\n</blockquote>\n<p>Notice that we transitioned to <em>two</em> activities, <cite>tech1</cite> and\n<cite>tech2</cite>.  This is because the prepare activity has an \u201cand\u201d split.\nNow we\u2019ll do a tech review.  Let\u2019s see what tech1 has:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = tech1.work_list.pop()\n&gt;&gt;&gt; print((item.getDoc()))\nI give my pledge, as an American\nto save, and faithfully to defend from waste\nthe natural resources of my Country.\n</pre>\n</blockquote>\n<p>Let\u2019s tell the author to change \u201cAmerican\u201d to \u201cEarthling\u201d:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item.finish(True, ['Change \"American\" to \"Earthling\"'])\nWorkItemFinished('tech_review')\nActivityFinished(Activity('Publication.tech1'))\nTransition(Activity('Publication.tech1'), Activity('Publication.review'))\n</pre>\n</blockquote>\n<p>Here we transitioned to the editorial review activity, but we didn\u2019t\nstart it. This is because the editorial review activity has an \u201cand\u201d\njoin, meaning that it won\u2019t start until both transitions have\noccurred.</p>\n<p>Now we\u2019ll do the other technical review:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = tech2.work_list.pop()\n&gt;&gt;&gt; item.finish(True, ['Change \"Country\" to \"planet\"'])\nWorkItemFinished('tech_review')\nActivityFinished(Activity('Publication.tech2'))\nTransition(Activity('Publication.tech2'), Activity('Publication.review'))\nActivityStarted(Activity('Publication.review'))\nWorkItemStarting('ed_review')\nWorkItemFinished('ed_review')\nActivityFinished(Activity('Publication.review'))\nAuthor `bob` selected\nTransition(Activity('Publication.review'), Activity('Publication.prepare'))\nActivityStarted(Activity('Publication.prepare'))\nWorkItemStarting('prepare')\nWorkItemStarted('prepare')\nWorkItemStarted('ed_review')\n</pre>\n</blockquote>\n<p>Now when we transitioned to the editorial review activity, we started\nit, because each of the input transitions had happened.  Our editorial\nreview application automatically sent the work back to preparation,\nbecause there were technical comments. Of course the author is still <cite>bob</cite>.\nLet\u2019s address the comments:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = authors['bob'].work_list.pop()\n&gt;&gt;&gt; item.summary()\nPrevious draft:\nI give my pledge, as an American\nto save, and faithfully to defend from waste\nthe natural resources of my Country.\nChanges we need to make:\nChange \"American\" to \"Earthling\"\nChange \"Country\" to \"planet\"\n</pre>\n<pre>&gt;&gt;&gt; item.finish(\"I give my pledge, as an Earthling\\n\"\n...             \"to save, and faithfully to defend from waste\\n\"\n...             \"the natural resources of my planet.\")\nWorkItemFinished('prepare')\nActivityFinished(Activity('Publication.prepare'))\nTransition(Activity('Publication.prepare'), Activity('Publication.tech1'))\nActivityStarted(Activity('Publication.tech1'))\nWorkItemStarting('tech_review')\nWorkItemStarted('tech_review')\nTransition(Activity('Publication.prepare'), Activity('Publication.tech2'))\nActivityStarted(Activity('Publication.tech2'))\nWorkItemStarting('tech_review')\nWorkItemStarted('tech_review')\n</pre>\n</blockquote>\n<p>As before, after completing the initial edits, we start the technical\nreview activities again.  We\u2019ll review it again. This time, we have no\ncomments, because the author applied our requested changes:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = tech1.work_list.pop()\n&gt;&gt;&gt; item.finish(True, [])\nWorkItemFinished('tech_review')\nActivityFinished(Activity('Publication.tech1'))\nTransition(Activity('Publication.tech1'), Activity('Publication.review'))\n</pre>\n<pre>&gt;&gt;&gt; item = tech2.work_list.pop()\n&gt;&gt;&gt; item.finish(True, [])\nWorkItemFinished('tech_review')\nActivityFinished(Activity('Publication.tech2'))\nTransition(Activity('Publication.tech2'), Activity('Publication.review'))\nActivityStarted(Activity('Publication.review'))\nWorkItemStarting('ed_review')\nWorkItemStarted('ed_review')\n</pre>\n</blockquote>\n<p>This time, we are left in the technical review activity because there\nweren\u2019t any technical changes. We\u2019re ready to do our editorial review.\nWe\u2019ll request an editorial change:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = reviewer.work_list.pop()\n&gt;&gt;&gt; print((item.getDoc()))\nI give my pledge, as an Earthling\nto save, and faithfully to defend from waste\nthe natural resources of my planet.\n</pre>\n<pre>&gt;&gt;&gt; item.finish(['change \"an\" to \"a\"'])\nWorkItemFinished('ed_review')\nActivityFinished(Activity('Publication.review'))\nAuthor `bob` selected\nTransition(Activity('Publication.review'), Activity('Publication.final'))\nActivityStarted(Activity('Publication.final'))\nWorkItemStarting('final')\nWorkItemStarted('final')\n</pre>\n</blockquote>\n<p>Because we requested editorial changes, we transitioned to the final\nediting activity, so that the author (still bob) can make the changes:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = authors['bob'].work_list.pop()\n&gt;&gt;&gt; item.summary()\nPrevious draft:\nI give my pledge, as an Earthling\nto save, and faithfully to defend from waste\nthe natural resources of my planet.\nChanges we need to make:\nchange \"an\" to \"a\"\n</pre>\n<pre>&gt;&gt;&gt; item.finish(\"I give my pledge, as a Earthling\\n\"\n...             \"to save, and faithfully to defend from waste\\n\"\n...             \"the natural resources of my planet.\")\nWorkItemFinished('final')\nActivityFinished(Activity('Publication.final'))\nTransition(Activity('Publication.final'), Activity('Publication.rfinal'))\nActivityStarted(Activity('Publication.rfinal'))\nWorkItemStarting('rfinal')\nWorkItemStarted('rfinal')\n</pre>\n</blockquote>\n<p>We transition to the activity for reviewing the final edits.  We\nreview the document and approve it for publication:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; item = reviewer.work_list.pop()\n&gt;&gt;&gt; print((item.getDoc()))\nI give my pledge, as a Earthling\nto save, and faithfully to defend from waste\nthe natural resources of my planet.\n</pre>\n<pre>&gt;&gt;&gt; item.finish([])\nWorkItemFinished('rfinal')\nActivityFinished(Activity('Publication.rfinal'))\nTransition(Activity('Publication.rfinal'), Activity('Publication.publish'))\nActivityStarted(Activity('Publication.publish'))\nWorkItemStarting('publish')\nPublished\nWorkItemFinished('publish')\nActivityFinished(Activity('Publication.publish'))\nProcessFinished(Process('Publication'))\nWorkItemStarted('publish')\n</pre>\n</blockquote>\n<p>At this point, the rest of the process finished automatically.  In\naddition, the decision was recorded in the process context object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proc.workflowRelevantData.publish\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"coming-soon\">\n<h3>Coming Soon</h3>\n<ul>\n<li>Timeouts/exceptions</li>\n</ul>\n</div>\n<div id=\"see-also\">\n<h3>See also</h3>\n<p><a href=\"http://www.wfmc.org\" rel=\"nofollow\">http://www.wfmc.org</a>\n<a href=\"http://www.wfmc.org/standards/standards.htm\" rel=\"nofollow\">http://www.wfmc.org/standards/standards.htm</a></p>\n<div id=\"xpdl-import\">\n<h4>XPDL Import</h4>\n<p>We can import process definitions from files in the XML Process\nDefinition Language (XPDL) format. An XPDL file contains multiple\nprocess definitions arranged in a package. When we load the file, we\nget a package containing some number of process definitions.</p>\n<p>Let\u2019s look at an example.  The file <cite>publication.xpdl</cite>\ncontains a definition for the publication example developed in the\n\u201cREADME.txt\u201d file.  We can read it using the xpdl module:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from shoobx.wfmc import xpdl\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; package = xpdl.read(open(os.path.join(this_directory,\n...                                       'publication-1.0.xpdl')))\n</pre>\n</blockquote>\n<p>This package contains a single definition:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; package\n{u'Publication': ProcessDefinition(u'Publication')}\n</pre>\n<pre>&gt;&gt;&gt; pd = package[u'Publication']\n&gt;&gt;&gt; from shoobx.wfmc.attributeintegration import AttributeIntegration\n&gt;&gt;&gt; integration = AttributeIntegration()\n&gt;&gt;&gt; pd.integration = integration\n</pre>\n</blockquote>\n<p>Now, having read the process definition, we can use it as we did\nbefore (in \u201cREADME.txt\u201d).  As before, we\u2019ll create an event subscriber\nso that we can see what\u2019s going on:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def log_workflow(event):\n...     print(event)\n</pre>\n<pre>&gt;&gt;&gt; import zope.event\n&gt;&gt;&gt; zope.event.subscribers.append(log_workflow)\n</pre>\n</blockquote>\n<p>and we\u2019ll register the process definition as a utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from shoobx.wfmc.process import StaticProcessDefinitionFactory\n&gt;&gt;&gt; pdfactory = StaticProcessDefinitionFactory()\n&gt;&gt;&gt; zope.component.provideUtility(pdfactory)\n&gt;&gt;&gt; pdfactory.register(pd)\n</pre>\n</blockquote>\n<p>and we\u2019ll define and register participant and application adapters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; from shoobx.wfmc import interfaces\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.IParticipant)\n... class Participant(object):\n...     zope.component.adapts(interfaces.IActivity)\n...\n...     def __init__(self, activity, process):\n...         self.activity = activity\n</pre>\n<pre>&gt;&gt;&gt; class User:\n...     def __init__(self):\n...         self.work_list = []\n</pre>\n<pre>&gt;&gt;&gt; authors = {'bob': User(), 'ted': User(), 'sally': User()}\n</pre>\n<pre>&gt;&gt;&gt; reviewer = User()\n&gt;&gt;&gt; tech1 = User()\n&gt;&gt;&gt; tech2 = User()\n</pre>\n<pre>&gt;&gt;&gt; class Author(Participant):\n...     def __init__(self, activity, process):\n...         Participant.__init__(self, activity, process)\n...         author_name = activity.process.workflowRelevantData.author\n...         print(\"Author `%s` selected\" % author_name)\n...         self.user = authors[author_name]\n</pre>\n<pre>&gt;&gt;&gt; integration.authorParticipant = Author\n</pre>\n<pre>&gt;&gt;&gt; class Reviewer(Participant):\n...     user = reviewer\n&gt;&gt;&gt; integration.reviewerParticipant = Reviewer\n</pre>\n<pre>&gt;&gt;&gt; class Tech1(Participant):\n...     user = tech1\n&gt;&gt;&gt; integration.tech1Participant = Tech1\n</pre>\n<pre>&gt;&gt;&gt; class Tech2(Participant):\n...     user = tech2\n&gt;&gt;&gt; integration.tech2Participant = Tech2\n</pre>\n<pre>&gt;&gt;&gt; integration.SystemParticipant = Participant\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.IWorkItem)\n... class ApplicationBase(object):\n...     zope.component.adapts(interfaces.IParticipant)\n...\n...     def __init__(self, participant, process, activity):\n...         self.participant = participant\n...         self.activity = participant.activity\n...         participant.user.work_list.append(self)\n...\n...     def start(self, args):\n...         pass\n...\n...     def finish(self):\n...         self.participant.activity.workItemFinished(self)\n</pre>\n<pre>&gt;&gt;&gt; class Prepare(ApplicationBase):\n...\n...     def summary(self):\n...         process = self.activity.process\n...         doc = getattr(process.applicationRelevantData, 'doc', '')\n...         if doc:\n...             print('Previous draft:')\n...             print(doc)\n...             print('Changes we need to make:')\n...             for change in process.workflowRelevantData.tech_changes:\n...                 print(change)\n...         else:\n...             print('Please write the initial draft')\n...\n...     def finish(self, doc):\n...         self.activity.process.applicationRelevantData.doc = doc\n...         super(Prepare, self).finish()\n</pre>\n<pre>&gt;&gt;&gt; integration.prepareWorkItem = Prepare\n</pre>\n<pre>&gt;&gt;&gt; class TechReview(ApplicationBase):\n...\n...     def getDoc(self):\n...         return self.activity.process.applicationRelevantData.doc\n...\n...     def finish(self, decision, changes):\n...         output = {'publish': decision, 'tech_changes': changes}\n...         self.activity.workItemFinished(self, output)\n</pre>\n<pre>&gt;&gt;&gt; integration.tech_reviewWorkItem = TechReview\n</pre>\n<pre>&gt;&gt;&gt; class Review(TechReview):\n...\n...     def start(self, args):\n...         publish1 = args['publish1']\n...         publish2 = args['publish2']\n...         changes1 = args['tech_changes1']\n...         changes2 = args['tech_changes2']\n...         if not (publish1 and publish2):\n...             output = {'publish': False,\n...                       'tech_changes': changes1 + changes2,\n...                       'ed_changes': ()}\n...             # Reject if either tech reviewer rejects\n...             self.activity.workItemFinished(\n...                 self, output)\n...\n...         if changes1 or changes2:\n...             output = {'publish': True,\n...                       'tech_changes': changes1 + changes2,\n...                       'ed_changes': ()}\n...             # we won't do anyting if there are tech changes\n...             self.activity.workItemFinished(\n...                 self, output)\n...\n...     def finish(self, ed_changes):\n...         output = {'publish': True, 'tech_changes': (), 'ed_changes': ed_changes}\n...         self.activity.workItemFinished(self, output)\n</pre>\n<pre>&gt;&gt;&gt; integration.ed_reviewWorkItem = Review\n</pre>\n<pre>&gt;&gt;&gt; class Final(ApplicationBase):\n...\n...     def summary(self):\n...         process = self.activity.process\n...         doc = getattr(process.applicationRelevantData, 'doc', '')\n...         print('Previous draft:')\n...         print(self.activity.process.applicationRelevantData.doc)\n...         print('Changes we need to make:')\n...         for change in process.workflowRelevantData.ed_changes:\n...            print(change)\n...\n...     def finish(self, doc):\n...         self.activity.process.applicationRelevantData.doc = doc\n...         super(Final, self).finish()\n</pre>\n<pre>&gt;&gt;&gt; integration.finalWorkItem = Final\n</pre>\n<pre>&gt;&gt;&gt; class ReviewFinal(TechReview):\n...\n...     def finish(self, ed_changes):\n...         output = {'publish': True, 'tech_changes': (), 'ed_changes': ed_changes}\n...         self.activity.workItemFinished(self, output)\n</pre>\n<pre>&gt;&gt;&gt; integration.rfinalWorkItem = ReviewFinal\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.IWorkItem)\n... class Publish:\n...     zope.component.adapts(interfaces.IParticipant)\n...\n...     def __init__(self, participant, process, activity):\n...         self.participant = participant\n...\n...     def start(self, args):\n...         print(\"Published\")\n...         self.finish()\n...\n...     def finish(self):\n...         self.participant.activity.workItemFinished(self)\n</pre>\n<pre>&gt;&gt;&gt; integration.publishWorkItem = Publish\n</pre>\n<pre>&gt;&gt;&gt; class Reject(Publish):\n...     def start(self, args):\n...         print(\"Rejected\")\n...         self.finish()\n</pre>\n<pre>&gt;&gt;&gt; integration.rejectWorkItem = Reject\n</pre>\n</blockquote>\n<p>and a process context, so we can pass parameters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.IProcessContext)\n... class PublicationContext:\n...\n...     def processFinished(self, process, decision):\n...         self.decision = decision\n</pre>\n</blockquote>\n<p>Now, let\u2019s try out our process.  We\u2019ll follow the same steps we did in\n\u201cREADME.txt\u201d, getting the same results:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context = PublicationContext()\n&gt;&gt;&gt; proc = pd(context)\n&gt;&gt;&gt; proc.start('bob')\nProcessStarted(Process(u'Publication'))\nTransition(None, Activity(u'Publication.start'))\nActivityStarted(Activity(u'Publication.start'))\nActivityFinished(Activity(u'Publication.start'))\nAuthor `bob` selected\nTransition(Activity(u'Publication.start'),\n           Activity(u'Publication.prepare'))\nActivityStarted(Activity(u'Publication.prepare'))\nWorkItemStarting(u'prepare')\nWorkItemStarted(u'prepare')\n</pre>\n<pre>&gt;&gt;&gt; item = authors['bob'].work_list.pop()\n&gt;&gt;&gt; item.finish(\"I give my pledge, as an American\\n\"\n...             \"to save, and faithfully to defend from waste\\n\"\n...             \"the natural resources of my Country.\")\nWorkItemFinished(u'prepare')\nActivityFinished(Activity(u'Publication.prepare'))\nTransition(Activity(u'Publication.prepare'),\n           Activity(u'Publication.tech1'))\nActivityStarted(Activity(u'Publication.tech1'))\nWorkItemStarting(u'tech_review')\nWorkItemStarted(u'tech_review')\nTransition(Activity(u'Publication.prepare'),\n           Activity(u'Publication.tech2'))\nActivityStarted(Activity(u'Publication.tech2'))\nWorkItemStarting(u'tech_review')\nWorkItemStarted(u'tech_review')\n</pre>\n<pre>&gt;&gt;&gt; item = tech1.work_list.pop()\n&gt;&gt;&gt; print(item.getDoc())\nI give my pledge, as an American\nto save, and faithfully to defend from waste\nthe natural resources of my Country.\n</pre>\n<pre>&gt;&gt;&gt; item.finish(True, ['Change \"American\" to \"human\"'])\nWorkItemFinished(u'tech_review')\nActivityFinished(Activity(u'Publication.tech1'))\nTransition(Activity(u'Publication.tech1'),\n           Activity(u'Publication.review'))\n</pre>\n<pre>&gt;&gt;&gt; item = tech2.work_list.pop()\n&gt;&gt;&gt; item.finish(True, ['Change \"Country\" to \"planet\"'])\nWorkItemFinished(u'tech_review')\nActivityFinished(Activity(u'Publication.tech2'))\nTransition(Activity(u'Publication.tech2'),\n           Activity(u'Publication.review'))\nActivityStarted(Activity(u'Publication.review'))\nWorkItemStarting(u'ed_review')\nWorkItemFinished(u'ed_review')\nActivityFinished(Activity(u'Publication.review'))\nAuthor `bob` selected\nTransition(Activity(u'Publication.review'),\n           Activity(u'Publication.prepare'))\nActivityStarted(Activity(u'Publication.prepare'))\nWorkItemStarting(u'prepare')\nWorkItemStarted(u'prepare')\nWorkItemStarted(u'ed_review')\n</pre>\n<pre>&gt;&gt;&gt; item = authors['bob'].work_list.pop()\n&gt;&gt;&gt; item.summary()\nPrevious draft:\nI give my pledge, as an American\nto save, and faithfully to defend from waste\nthe natural resources of my Country.\nChanges we need to make:\nChange \"American\" to \"human\"\nChange \"Country\" to \"planet\"\n</pre>\n<pre>&gt;&gt;&gt; item.finish(\"I give my pledge, as an human\\n\"\n...             \"to save, and faithfully to defend from waste\\n\"\n...             \"the natural resources of my planet.\")\nWorkItemFinished(u'prepare')\nActivityFinished(Activity(u'Publication.prepare'))\nTransition(Activity(u'Publication.prepare'),\n           Activity(u'Publication.tech1'))\nActivityStarted(Activity(u'Publication.tech1'))\nWorkItemStarting(u'tech_review')\nWorkItemStarted(u'tech_review')\nTransition(Activity(u'Publication.prepare'),\n           Activity(u'Publication.tech2'))\nActivityStarted(Activity(u'Publication.tech2'))\nWorkItemStarting(u'tech_review')\nWorkItemStarted(u'tech_review')\n</pre>\n<pre>&gt;&gt;&gt; item = tech1.work_list.pop()\n&gt;&gt;&gt; item.finish(True, [])\nWorkItemFinished(u'tech_review')\nActivityFinished(Activity(u'Publication.tech1'))\nTransition(Activity(u'Publication.tech1'),\n           Activity(u'Publication.review'))\n</pre>\n<pre>&gt;&gt;&gt; item = tech2.work_list.pop()\n&gt;&gt;&gt; item.finish(True, [])\nWorkItemFinished(u'tech_review')\nActivityFinished(Activity(u'Publication.tech2'))\nTransition(Activity(u'Publication.tech2'),\n           Activity(u'Publication.review'))\nActivityStarted(Activity(u'Publication.review'))\nWorkItemStarting(u'ed_review')\nWorkItemStarted(u'ed_review')\n</pre>\n<pre>&gt;&gt;&gt; item = reviewer.work_list.pop()\n&gt;&gt;&gt; print(item.getDoc())\nI give my pledge, as an human\nto save, and faithfully to defend from waste\nthe natural resources of my planet.\n</pre>\n<pre>&gt;&gt;&gt; item.finish(['change \"an\" to \"a\"'])\nWorkItemFinished(u'ed_review')\nActivityFinished(Activity(u'Publication.review'))\nAuthor `bob` selected\nTransition(Activity(u'Publication.review'),\n           Activity(u'Publication.final'))\nActivityStarted(Activity(u'Publication.final'))\nWorkItemStarting(u'final')\nWorkItemStarted(u'final')\n</pre>\n<pre>&gt;&gt;&gt; item = authors['bob'].work_list.pop()\n&gt;&gt;&gt; item.summary()\nPrevious draft:\nI give my pledge, as an human\nto save, and faithfully to defend from waste\nthe natural resources of my planet.\nChanges we need to make:\nchange \"an\" to \"a\"\n</pre>\n<pre>&gt;&gt;&gt; item.finish(\"I give my pledge, as a human\\n\"\n...             \"to save, and faithfully to defend from waste\\n\"\n...             \"the natural resources of my planet.\")\nWorkItemFinished(u'final')\nActivityFinished(Activity(u'Publication.final'))\nTransition(Activity(u'Publication.final'),\n           Activity(u'Publication.rfinal'))\nActivityStarted(Activity(u'Publication.rfinal'))\nWorkItemStarting(u'rfinal')\nWorkItemStarted(u'rfinal')\n</pre>\n<pre>&gt;&gt;&gt; item = reviewer.work_list.pop()\n&gt;&gt;&gt; print(item.getDoc())\nI give my pledge, as a human\nto save, and faithfully to defend from waste\nthe natural resources of my planet.\n</pre>\n<pre>&gt;&gt;&gt; item.finish([])\nWorkItemFinished(u'rfinal')\nActivityFinished(Activity(u'Publication.rfinal'))\nTransition(Activity(u'Publication.rfinal'),\n           Activity(u'Publication.publish'))\nActivityStarted(Activity(u'Publication.publish'))\nWorkItemStarting(u'publish')\nPublished\nWorkItemFinished(u'publish')\nActivityFinished(Activity(u'Publication.publish'))\nProcessFinished(Process(u'Publication'))\nWorkItemStarted(u'publish')\n</pre>\n<pre>&gt;&gt;&gt; proc.workflowRelevantData.publish\nTrue\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"descriptions\">\n<h3>Descriptions</h3>\n<p>Most process elements can have names and descriptions.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pd.__name__\nu'Publication'\n</pre>\n<pre>&gt;&gt;&gt; pd.description\nu'This is the sample process'\n</pre>\n<pre>&gt;&gt;&gt; pd.applications['prepare'].__name__\nu'Prepare'\n</pre>\n<pre>&gt;&gt;&gt; pd.applications['prepare'].description\nu'Prepare the initial draft'\n</pre>\n<pre>&gt;&gt;&gt; pd.activities['tech1'].__name__\nu'Technical Review 1'\n</pre>\n<pre>&gt;&gt;&gt; pd.activities['tech1'].description\nu'This is the first Technical Review.'\n</pre>\n<pre>&gt;&gt;&gt; pd.participants['tech1'].__name__\nu'Technical Reviewer 1'\n</pre>\n<pre>&gt;&gt;&gt; pd.participants['tech1'].description\nu'He is a smart guy.'\n</pre>\n<pre>&gt;&gt;&gt; sorted([item.__name__ for item in pd.transitions])\n    [u'Transition', u'Transition', u'Transition', u'Transition',\n    u'Transition', u'Transition', u'Transition', u'Transition',\n    u'Transition', u'Transition', u'Transition to Tech Review 1',\n    u'Transition to Tech Review 2']\n</pre>\n<pre>&gt;&gt;&gt; descriptions = [item.description for item in pd.transitions if item.description]\n&gt;&gt;&gt; u'Use this transition if there are editorial changes required.' in descriptions\nTrue\n</pre>\n</blockquote>\n<div id=\"changes\">\n<h4>CHANGES</h4>\n</div>\n</div>\n<div id=\"id1\">\n<h3>4.2.2 (2019-09-06)</h3>\n<ul>\n<li>Exposed deadline parsing as <cite>Activity.digestDeadlineDefinition</cite></li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>4.2.0 (2018-11-12)</h3>\n<ul>\n<li>Add Python 3.7 support.</li>\n<li>Remove Python 3.5 support.</li>\n<li>Remvoe all deprecation and resource warnings.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>4.1.1 (2018-02-08)</h3>\n<ul>\n<li>More Python 3 compatibility.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>4.1.0 (2018-02-06)</h3>\n<ul>\n<li>Python 3 support.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>4.0.4 (2017-11-01)</h3>\n<ul>\n<li>Make the <cite>now</cite> function pluggable.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>4.0.3 (2017-06-20)</h3>\n<ul>\n<li>Nothing changed yet.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>4.0.2 (2017-05-25)</h3>\n<ul>\n<li>Update and improve Trove classifiers.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>4.0.1 (2017-05-25)</h3>\n<ul>\n<li>Fix small ReST issues, so that PyPI description will render.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3>4.0.0 (2017-05-25)</h3>\n<ul>\n<li><p>Renamed from <cite>zope.wfmc</cite> to <cite>shoobx.wfmc</cite>.</p>\n</li>\n<li><p>Added support for community CI and coverage tools.</p>\n</li>\n<li><p>Raise an exception on duplicate <cite>ExtendedAttribute</cite> <cite>Name</cite> in a single\n<cite>ExtendedAttributes</cite> container</p>\n</li>\n<li><p>Use IProcessDefinitionFactory to retrieve process definitions instead of\nnamed utilities. This additional layer of indirection allows to generate\ndefinitions dynamically.</p>\n</li>\n<li><p>Support for synchronious and asynchronous execution of WFMC subflows.\nSubflows are executed   as part of main process, however have their separate\nstate (workflow variables).</p>\n</li>\n<li><p>The simplistic Python <tt>evaluate(expr, locals)</tt> function has been replaced\nby the <cite>PythonExpressionEvaluator</cite> component, which is an adapter from\n<cite>IProcess</cite> to <cite>IPythonExpressionEvaluator</cite>. The evaluation locals namespace\nis automatically filled with workflow- and application-relevant data\nattributes, the context of the process and the passed in locals variable.</p>\n<p>All calls of <cite>evaluate()</cite> have been updated to use the adapter.</p>\n<p>This change allows for easy replacement of the evaluation engine to hook up\na safe Python engine (i.e. RestrictedPython) and to provide more namespace\nentries.</p>\n</li>\n<li><p>Transition conditions can now be evaluated in the larger context of a\nprocess, instead of just the workflow-relevant data. Thus their calling\nsignature changed from <cite>condition(data)</cite> to <cite>condition(process, data)</cite>.</p>\n</li>\n<li><p><cite>TextCondition</cite> has been changed to use the <cite>PythonExpressionEvaluator</cite>\ncomponent. Also, the compile optimization has been removed, since the\nexpression evalautor can do this more effectively.</p>\n</li>\n<li><p>Support for aborting processes and activities.</p>\n<ul>\n<li><p>Work items can be abortable by implementing <tt>IAbortWorkItem</tt>.</p>\n</li>\n<li><p>Work items can be cleaned up, if they implement <tt>ICleanupWorkItem</tt>.</p>\n</li>\n<li><p>Activities keep track of finished work items.</p>\n</li>\n<li><p>Activities can clean themselves up by cleaning up work items.</p>\n</li>\n<li><p>Processes keep track of finished activities.</p>\n</li>\n<li><p>When processes are aborted, the following is done:</p>\n<ul>\n<li><p>All activities are aborted.</p>\n</li>\n<li><p>All finished activities are cleaned up.</p>\n<blockquote>\n<ul>\n<li>isAborted flag is set on a process.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Support for reading XPDL-2.1 added</p>\n</li>\n<li><p>Added reading Pools and Lanes from XPDL</p>\n</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3>3.5.0 (2009-07-24)</h3>\n<ul>\n<li>Update tests to latest package versions.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3>3.4.0 (2007-11-02)</h3>\n<ul>\n<li>Initial release independent of the main Zope tree.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 5793760, "releases": {"4.0.0": [{"comment_text": "", "digests": {"md5": "d8045e67795eb777b0d8bc8099348cb2", "sha256": "c69aa4edf4bbce88e3e052dcb52b336988a80e40129e9317c03a7f4cb910bcdb"}, "downloads": -1, "filename": "shoobx.wfmc-4.0.0.tar.gz", "has_sig": false, "md5_digest": "d8045e67795eb777b0d8bc8099348cb2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 73650, "upload_time": "2017-05-25T15:27:30", "upload_time_iso_8601": "2017-05-25T15:27:30.118872Z", "url": "https://files.pythonhosted.org/packages/ac/f6/c5958302486f5ba82a8616efd5f76966084e1e8dc71f114e053e44a665f2/shoobx.wfmc-4.0.0.tar.gz", "yanked": false}], "4.0.1": [{"comment_text": "", "digests": {"md5": "013ea546af73f400fc4cca412fc7d655", "sha256": "40d3911b97c19108de1b3e4207d49baa5ec8e82b1518b595ae5b7b8f3f453d5a"}, "downloads": -1, "filename": "shoobx.wfmc-4.0.1.tar.gz", "has_sig": false, "md5_digest": "013ea546af73f400fc4cca412fc7d655", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 73722, "upload_time": "2017-05-25T15:46:23", "upload_time_iso_8601": "2017-05-25T15:46:23.942920Z", "url": "https://files.pythonhosted.org/packages/5f/c2/d70e32a290318b74fdaf61a8dfdb1a0c3a7a5802660b8086286722fa3193/shoobx.wfmc-4.0.1.tar.gz", "yanked": false}], "4.0.2": [{"comment_text": "", "digests": {"md5": "592f602151a064b647f72c17c755b5e2", "sha256": "c08ab52d4e7233357d13339cba45515ee8fd0eed2e48f20b5b70fb281b8fe995"}, "downloads": -1, "filename": "shoobx.wfmc-4.0.2.tar.gz", "has_sig": false, "md5_digest": "592f602151a064b647f72c17c755b5e2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 73834, "upload_time": "2017-05-25T15:48:44", "upload_time_iso_8601": "2017-05-25T15:48:44.437863Z", "url": "https://files.pythonhosted.org/packages/d4/d0/c150f7cd242813b623fe79764445a540cbd1eb7d4eb3423227f8f5f0166c/shoobx.wfmc-4.0.2.tar.gz", "yanked": false}], "4.0.3": [{"comment_text": "", "digests": {"md5": "cf87fdb04ea8455268f7313e03a14f28", "sha256": "2cba5db4745e5bcd7bcb810b4aaf22d8a7762dde8a2fac185a37164cef12b886"}, "downloads": -1, "filename": "shoobx.wfmc-4.0.3.tar.gz", "has_sig": false, "md5_digest": "cf87fdb04ea8455268f7313e03a14f28", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75400, "upload_time": "2017-06-20T18:19:06", "upload_time_iso_8601": "2017-06-20T18:19:06.095787Z", "url": "https://files.pythonhosted.org/packages/1a/30/a15d9ea78363dda5f69f783f433fa49458e9526f4c1e3df9f49a0e3e4ce8/shoobx.wfmc-4.0.3.tar.gz", "yanked": false}], "4.0.4": [{"comment_text": "", "digests": {"md5": "13a3d0503474840d2ed9783727f2ff90", "sha256": "1744d95ca20bfa4816580a9083fd4d96c46dec3298868e03507ad412db92deae"}, "downloads": -1, "filename": "shoobx.wfmc-4.0.4.tar.gz", "has_sig": false, "md5_digest": "13a3d0503474840d2ed9783727f2ff90", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 74900, "upload_time": "2017-11-01T17:01:59", "upload_time_iso_8601": "2017-11-01T17:01:59.710561Z", "url": "https://files.pythonhosted.org/packages/51/f4/26b9d064bd9747255e0b40622327721acdb8021ab18fde3bc4c11fe4363a/shoobx.wfmc-4.0.4.tar.gz", "yanked": false}], "4.1.0": [{"comment_text": "", "digests": {"md5": "72b5e2133dfd259e04d0dc391f5fb2d2", "sha256": "9f93ebf6a59631a997c7030be8fb51d739ecbf1b88f98eacd5c3eec14ef83713"}, "downloads": -1, "filename": "shoobx.wfmc-4.1.0.tar.gz", "has_sig": false, "md5_digest": "72b5e2133dfd259e04d0dc391f5fb2d2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78088, "upload_time": "2018-02-06T08:59:47", "upload_time_iso_8601": "2018-02-06T08:59:47.543850Z", "url": "https://files.pythonhosted.org/packages/80/db/8c913bec4436fcc254f7a3c28daf4863add5081926a2f792b255f8ab9617/shoobx.wfmc-4.1.0.tar.gz", "yanked": false}], "4.1.1": [{"comment_text": "", "digests": {"md5": "980d514c65f7ea6b43197ac7c932d491", "sha256": "9fd7fdb6c405579b91da00d399c3d84eadebe09a5ea3ae37f2cd390e5f710a1e"}, "downloads": -1, "filename": "shoobx.wfmc-4.1.1.tar.gz", "has_sig": false, "md5_digest": "980d514c65f7ea6b43197ac7c932d491", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78052, "upload_time": "2018-02-08T14:40:05", "upload_time_iso_8601": "2018-02-08T14:40:05.607399Z", "url": "https://files.pythonhosted.org/packages/45/43/92a21a5a37b4542d667914fba467bc4ecd0fcbf8bc8000f68dfef5e7f8cf/shoobx.wfmc-4.1.1.tar.gz", "yanked": false}], "4.2.0": [{"comment_text": "", "digests": {"md5": "ba5fb41845b710cdd0ead98fa6a33982", "sha256": "e46d42e5cd5c9c4f27c7fb9a2b56342767974765ff12abfefd9e672ff3e3890b"}, "downloads": -1, "filename": "shoobx.wfmc-4.2.0.tar.gz", "has_sig": false, "md5_digest": "ba5fb41845b710cdd0ead98fa6a33982", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75144, "upload_time": "2018-11-13T02:20:49", "upload_time_iso_8601": "2018-11-13T02:20:49.427653Z", "url": "https://files.pythonhosted.org/packages/0b/7c/383b3b2f25f8956b5a2ff9d94e2a56c18ba99bd488b6c2a6bf120aa2349b/shoobx.wfmc-4.2.0.tar.gz", "yanked": false}], "4.2.2": [{"comment_text": "", "digests": {"md5": "338a5f8117de84cece8e36a0416861f6", "sha256": "02ef47baa07b004127436f0d2fe5c0deb93d3ab342f87520965ce88fabda6992"}, "downloads": -1, "filename": "shoobx.wfmc-4.2.2.tar.gz", "has_sig": false, "md5_digest": "338a5f8117de84cece8e36a0416861f6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77054, "upload_time": "2019-09-06T20:17:09", "upload_time_iso_8601": "2019-09-06T20:17:09.112056Z", "url": "https://files.pythonhosted.org/packages/1a/ff/d1800cff9f30bedaa36bc2e9c588ef703419825bbb96836dead5ec302ba4/shoobx.wfmc-4.2.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "338a5f8117de84cece8e36a0416861f6", "sha256": "02ef47baa07b004127436f0d2fe5c0deb93d3ab342f87520965ce88fabda6992"}, "downloads": -1, "filename": "shoobx.wfmc-4.2.2.tar.gz", "has_sig": false, "md5_digest": "338a5f8117de84cece8e36a0416861f6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77054, "upload_time": "2019-09-06T20:17:09", "upload_time_iso_8601": "2019-09-06T20:17:09.112056Z", "url": "https://files.pythonhosted.org/packages/1a/ff/d1800cff9f30bedaa36bc2e9c588ef703419825bbb96836dead5ec302ba4/shoobx.wfmc-4.2.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:12:45 2020"}