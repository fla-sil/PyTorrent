{"info": {"author": "Elijah Shaw-Rutschman", "author_email": "elijahr@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: BSD License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy"], "description": "# ringbuf\n\nA lock-free, single-producer, single-consumer, ring buffer for Python and Cython.\n\n![build_status](https://travis-ci.org/elijahr/ringbuf.svg?branch=master)\n\n## Installation\n\nOS X: `brew install boost`\n\nUbuntu: `apt-get install libboost-all-dev`\n\nThen:\n\n```shell\npip install ringbuf\n```\n\n## Motivation\n\nWhen working with realtime DSP in Python, we might be wrapping some external C/C++ library (for instance, PortAudio) which runs some user-provided callback function in realtime. The callback function shouldn't allocate/deallocate memory, shouldn't contain any critical sections (mutexes), and so forth, to prevent priority inversion. If the callback were to contain Python objects, we'd likely be allocating and deallocating, and at the very least, acquiring and releasing the GIL. So, the callback cannot interact with Python objects if we expect realtime performance. As such, there's a need for buffering data in a non-locking way between a C/C++ callback and Python.\n\nEnter ringbuf, Cython wrappers for [`boost::lockfree::spsc_queue`](https://www.boost.org/doc/libs/1_72_0/doc/html/boost/lockfree/spsc_queue.html). Our Python code can read from and write to a `ringbuf.RingBuffer` object, and our C++ code can read from and write to that buffer's underlying `spsc_queue`, no GIL required.\n\n## Usage\n\nAny Python object which supports the [buffer protocol](https://docs.python.org/3/c-api/buffer.html) can be stored in `ringbuf.RingBuffer`. This includes, but is not limited to: `bytes`, `bytearray`, `array.array`, and `numpy.ndarray`.\n\n### NumPy\n\n```python\nimport numpy as np\nfrom ringbuf import RingBuffer\n\nbuffer = RingBuffer(format='f', capacity=100)\n\ndata = np.linspace(-1, 1, num=100, dtype='f')\n\nbuffer.push(data)\n\npopped = buffer.pop(100)\n\nassert np.array_equal(data, popped)\n```\n\n### bytes\n\n```python\nfrom ringbuf import RingBuffer\n\nbuffer = RingBuffer(format='B', capacity=11)\n\nbuffer.push(b'hello world')\n\npopped = buffer.pop(11)\n\nassert bytes(popped) == b'hello world'\n```\n\n### Interfacing with C/C++\n\nmymodule.pxd:\n\n```cython\n# distutils: language = c++\n\nfrom ringbuf.boost cimport spsc_queue, void_ptr_to_spsc_queue_char_ptr\n\ncdef void callback(void* q)\n```\n\nmymodule.pyx:\n\n```cython\n# distutils: language = c++\n\nfrom array import array\nfrom some_c_library cimport some_c_function\n\ncdef void callback(void* q):\n    cdef:\n        # Cast the void* back to an spsc_queue.\n        # The underlying queue always holds chars.\n        spsc_queue[char] *queue = void_ptr_to_spsc_queue_char_ptr(q)\n        double[5] to_push = [1.0, 2.0, 3.0, 4.0, 5.0]\n\n    # Since the queue holds chars, you'll have to cast and adjust size accordingly.\n    queue.push(<char*>to_push, sizeof(double) * 5)\n\n\ndef do_stuff():\n    cdef:\n        RingBuffer buffer = RingBuffer(format='d', capacity=100)\n        void* queue = buffer.queue_void_ptr()\n\n    # Pass our callback and a void* to the buffer's queue to some third party library.\n    # Presumably, the C library schedules the callback and passes it the queue's void pointer.\n    some_c_function(callback, queue)\n\n    sleep(1)\n\n    assert array.array('d', buffer.pop(5)) == array.array('d', range(1, 6))\n```\n\n### Handling overflow & underflow\n\nWhen `RingBuffer.push()` overflows, it returns the data that couldn't be pushed (or None, if all was pushed):\n\n```python\nfrom ringbuf import RingBuffer\n\nbuffer = RingBuffer(format='B', capacity=10)\noverflowed = buffer.push(b'spam eggs ham')\nassert overflowed == b'ham'\n```\n\nWhen `RingBuffer.pop()` underflows, it returns whatever data could be popped:\n\n```python\nfrom ringbuf import RingBuffer\n\nbuffer = RingBuffer(format='B', capacity=10)\noverflowed = buffer.push(b'spam eggs ham')\nassert overflowed == b'ham'\n```\n\n\n\nFor additional usage see the [tests](https://github.com/elijahr/ringbuf/blob/master/test.py).\n\n## Supported platforms\n\nTravis CI tests with the following configurations:\n* Ubuntu 18.04 Bionic Beaver + [CPython3.6, CPython3.7, CPython3.8, PyPy7.3.0 (3.6.9)]\n* OS X + [CPython3.6, CPython3.7, CPython3.8, PyPy7.3.0 (3.6.9)]\n\nAny platform with a C++11 compiler will probably work.\n\n## Contributing\n\nPull requests are welcome, please file any issues you encounter.\n\n## Changelog\n\n### v2.4.0 2020-03-23\n* Added `RingBuffer.reset()` method for .\n\n### v2.3.0 2020-03-22\n* Added `concatenate` function for joining multiple arbitrary Python objects that support the buffer protocol.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/elijahr/ringbuf", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "ringbuf", "package_url": "https://pypi.org/project/ringbuf/", "platform": "", "project_url": "https://pypi.org/project/ringbuf/", "project_urls": {"Homepage": "https://github.com/elijahr/ringbuf"}, "release_url": "https://pypi.org/project/ringbuf/2.4.0/", "requires_dist": null, "requires_python": "", "summary": "A lock-free ring buffer for Python and Cython.", "version": "2.4.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>ringbuf</h1>\n<p>A lock-free, single-producer, single-consumer, ring buffer for Python and Cython.</p>\n<p><img alt=\"build_status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/412efd842cb2dc2a56aac841e6e611b33b4b7b20/68747470733a2f2f7472617669732d63692e6f72672f656c696a6168722f72696e676275662e7376673f6272616e63683d6d6173746572\"></p>\n<h2>Installation</h2>\n<p>OS X: <code>brew install boost</code></p>\n<p>Ubuntu: <code>apt-get install libboost-all-dev</code></p>\n<p>Then:</p>\n<pre>pip install ringbuf\n</pre>\n<h2>Motivation</h2>\n<p>When working with realtime DSP in Python, we might be wrapping some external C/C++ library (for instance, PortAudio) which runs some user-provided callback function in realtime. The callback function shouldn't allocate/deallocate memory, shouldn't contain any critical sections (mutexes), and so forth, to prevent priority inversion. If the callback were to contain Python objects, we'd likely be allocating and deallocating, and at the very least, acquiring and releasing the GIL. So, the callback cannot interact with Python objects if we expect realtime performance. As such, there's a need for buffering data in a non-locking way between a C/C++ callback and Python.</p>\n<p>Enter ringbuf, Cython wrappers for <a href=\"https://www.boost.org/doc/libs/1_72_0/doc/html/boost/lockfree/spsc_queue.html\" rel=\"nofollow\"><code>boost::lockfree::spsc_queue</code></a>. Our Python code can read from and write to a <code>ringbuf.RingBuffer</code> object, and our C++ code can read from and write to that buffer's underlying <code>spsc_queue</code>, no GIL required.</p>\n<h2>Usage</h2>\n<p>Any Python object which supports the <a href=\"https://docs.python.org/3/c-api/buffer.html\" rel=\"nofollow\">buffer protocol</a> can be stored in <code>ringbuf.RingBuffer</code>. This includes, but is not limited to: <code>bytes</code>, <code>bytearray</code>, <code>array.array</code>, and <code>numpy.ndarray</code>.</p>\n<h3>NumPy</h3>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">ringbuf</span> <span class=\"kn\">import</span> <span class=\"n\">RingBuffer</span>\n\n<span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">RingBuffer</span><span class=\"p\">(</span><span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">'f'</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">'f'</span><span class=\"p\">)</span>\n\n<span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n\n<span class=\"n\">popped</span> <span class=\"o\">=</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array_equal</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">popped</span><span class=\"p\">)</span>\n</pre>\n<h3>bytes</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">ringbuf</span> <span class=\"kn\">import</span> <span class=\"n\">RingBuffer</span>\n\n<span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">RingBuffer</span><span class=\"p\">(</span><span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">=</span><span class=\"mi\">11</span><span class=\"p\">)</span>\n\n<span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'hello world'</span><span class=\"p\">)</span>\n\n<span class=\"n\">popped</span> <span class=\"o\">=</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"mi\">11</span><span class=\"p\">)</span>\n\n<span class=\"k\">assert</span> <span class=\"nb\">bytes</span><span class=\"p\">(</span><span class=\"n\">popped</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"sa\">b</span><span class=\"s1\">'hello world'</span>\n</pre>\n<h3>Interfacing with C/C++</h3>\n<p>mymodule.pxd:</p>\n<pre><span class=\"c\"># distutils: language = c++</span>\n\n<span class=\"k\">from</span> <span class=\"nn\">ringbuf.boost</span> <span class=\"k\">cimport</span> <span class=\"n\">spsc_queue</span><span class=\"p\">,</span> <span class=\"n\">void_ptr_to_spsc_queue_char_ptr</span>\n\n<span class=\"k\">cdef</span> <span class=\"kt\">void</span> <span class=\"nf\">callback</span><span class=\"p\">(</span><span class=\"n\">void</span><span class=\"o\">*</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n</pre>\n<p>mymodule.pyx:</p>\n<pre><span class=\"c\"># distutils: language = c++</span>\n\n<span class=\"k\">from</span> <span class=\"nn\">array</span> <span class=\"k\">import</span> <span class=\"n\">array</span>\n<span class=\"k\">from</span> <span class=\"nn\">some_c_library</span> <span class=\"k\">cimport</span> <span class=\"n\">some_c_function</span>\n\n<span class=\"k\">cdef</span> <span class=\"kt\">void</span> <span class=\"nf\">callback</span><span class=\"p\">(</span><span class=\"n\">void</span><span class=\"o\">*</span> <span class=\"n\">q</span><span class=\"p\">):</span>\n    <span class=\"k\">cdef</span><span class=\"p\">:</span>\n        <span class=\"c\"># Cast the void* back to an spsc_queue.</span>\n        <span class=\"c\"># The underlying queue always holds chars.</span>\n        <span class=\"n\">spsc_queue</span><span class=\"p\">[</span><span class=\"n\">char</span><span class=\"p\">]</span> <span class=\"o\">*</span><span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">void_ptr_to_spsc_queue_char_ptr</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">)</span>\n        <span class=\"n\">double</span><span class=\"p\">[</span><span class=\"mf\">5</span><span class=\"p\">]</span> <span class=\"n\">to_push</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"mf\">4.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">]</span>\n\n    <span class=\"c\"># Since the queue holds chars, you'll have to cast and adjust size accordingly.</span>\n    <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">char</span><span class=\"o\">*&gt;</span><span class=\"n\">to_push</span><span class=\"p\">,</span> <span class=\"n\">sizeof</span><span class=\"p\">(</span><span class=\"n\">double</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"mf\">5</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">do_stuff</span><span class=\"p\">():</span>\n    <span class=\"k\">cdef</span><span class=\"p\">:</span>\n        <span class=\"n\">RingBuffer</span> <span class=\"nb\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">RingBuffer</span><span class=\"p\">(</span><span class=\"n\">format</span><span class=\"o\">=</span><span class=\"s\">'d'</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">=</span><span class=\"mf\">100</span><span class=\"p\">)</span>\n        <span class=\"n\">void</span><span class=\"o\">*</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"nb\">buffer</span><span class=\"o\">.</span><span class=\"n\">queue_void_ptr</span><span class=\"p\">()</span>\n\n    <span class=\"c\"># Pass our callback and a void* to the buffer's queue to some third party library.</span>\n    <span class=\"c\"># Presumably, the C library schedules the callback and passes it the queue's void pointer.</span>\n    <span class=\"n\">some_c_function</span><span class=\"p\">(</span><span class=\"n\">callback</span><span class=\"p\">,</span> <span class=\"n\">queue</span><span class=\"p\">)</span>\n\n    <span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">1</span><span class=\"p\">)</span>\n\n    <span class=\"k\">assert</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"s\">'d'</span><span class=\"p\">,</span> <span class=\"nb\">buffer</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"mf\">5</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"s\">'d'</span><span class=\"p\">,</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mf\">1</span><span class=\"p\">,</span> <span class=\"mf\">6</span><span class=\"p\">))</span>\n</pre>\n<h3>Handling overflow &amp; underflow</h3>\n<p>When <code>RingBuffer.push()</code> overflows, it returns the data that couldn't be pushed (or None, if all was pushed):</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">ringbuf</span> <span class=\"kn\">import</span> <span class=\"n\">RingBuffer</span>\n\n<span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">RingBuffer</span><span class=\"p\">(</span><span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">overflowed</span> <span class=\"o\">=</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'spam eggs ham'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">overflowed</span> <span class=\"o\">==</span> <span class=\"sa\">b</span><span class=\"s1\">'ham'</span>\n</pre>\n<p>When <code>RingBuffer.pop()</code> underflows, it returns whatever data could be popped:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">ringbuf</span> <span class=\"kn\">import</span> <span class=\"n\">RingBuffer</span>\n\n<span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">RingBuffer</span><span class=\"p\">(</span><span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">overflowed</span> <span class=\"o\">=</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'spam eggs ham'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">overflowed</span> <span class=\"o\">==</span> <span class=\"sa\">b</span><span class=\"s1\">'ham'</span>\n</pre>\n<p>For additional usage see the <a href=\"https://github.com/elijahr/ringbuf/blob/master/test.py\" rel=\"nofollow\">tests</a>.</p>\n<h2>Supported platforms</h2>\n<p>Travis CI tests with the following configurations:</p>\n<ul>\n<li>Ubuntu 18.04 Bionic Beaver + [CPython3.6, CPython3.7, CPython3.8, PyPy7.3.0 (3.6.9)]</li>\n<li>OS X + [CPython3.6, CPython3.7, CPython3.8, PyPy7.3.0 (3.6.9)]</li>\n</ul>\n<p>Any platform with a C++11 compiler will probably work.</p>\n<h2>Contributing</h2>\n<p>Pull requests are welcome, please file any issues you encounter.</p>\n<h2>Changelog</h2>\n<h3>v2.4.0 2020-03-23</h3>\n<ul>\n<li>Added <code>RingBuffer.reset()</code> method for .</li>\n</ul>\n<h3>v2.3.0 2020-03-22</h3>\n<ul>\n<li>Added <code>concatenate</code> function for joining multiple arbitrary Python objects that support the buffer protocol.</li>\n</ul>\n\n          </div>"}, "last_serial": 6870497, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "68d4a4ae562bbcd7d2dbb2a444326943", "sha256": "17d5dc8d93b1f0f2948750210eff36548ce0401a00270ce2bd130d5094985f11"}, "downloads": -1, "filename": "ringbuf-1.0.0.tar.gz", "has_sig": false, "md5_digest": "68d4a4ae562bbcd7d2dbb2a444326943", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 163506, "upload_time": "2020-03-11T06:01:13", "upload_time_iso_8601": "2020-03-11T06:01:13.465865Z", "url": "https://files.pythonhosted.org/packages/fe/48/d8ebf1cf3fffc098fcaeb37aca660565d9c1dfc9096e8028855da83c1e1b/ringbuf-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "00c92d2e3acdddf26cdf86bb0b42ab4f", "sha256": "0080053f255e1cc2e7f060f215e6e0e9d978b2f86138ac974b0ac873fc61d85e"}, "downloads": -1, "filename": "ringbuf-1.0.1.tar.gz", "has_sig": false, "md5_digest": "00c92d2e3acdddf26cdf86bb0b42ab4f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 163548, "upload_time": "2020-03-11T06:03:24", "upload_time_iso_8601": "2020-03-11T06:03:24.831294Z", "url": "https://files.pythonhosted.org/packages/7d/e4/bea4e6b87008f8c6e0f5bc162ac2a602840176f2fc590a1f519db32b50e0/ringbuf-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "438cf9d8cde1c9a050f6f1bab47f2c62", "sha256": "c156753577de6ad2440eabd8248a7fbfda5ffe74d8f61467d1c53780f74ab8a4"}, "downloads": -1, "filename": "ringbuf-1.0.2.tar.gz", "has_sig": false, "md5_digest": "438cf9d8cde1c9a050f6f1bab47f2c62", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 163532, "upload_time": "2020-03-11T06:05:11", "upload_time_iso_8601": "2020-03-11T06:05:11.447522Z", "url": "https://files.pythonhosted.org/packages/d4/aa/72b139bc32610b261f7b62efeb49e0d671c5678880f986a43cc0a13fdf81/ringbuf-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "26b82a6ab1ee08d5bbd174fb8a6e445b", "sha256": "6cd796bdd86caaee564ece241ba611f67332b8fbd9f4799d7d64c33a28019240"}, "downloads": -1, "filename": "ringbuf-1.0.3.tar.gz", "has_sig": false, "md5_digest": "26b82a6ab1ee08d5bbd174fb8a6e445b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 134719, "upload_time": "2020-03-14T22:36:07", "upload_time_iso_8601": "2020-03-14T22:36:07.105271Z", "url": "https://files.pythonhosted.org/packages/f4/41/d2e6682958eea61d4e0d8c3de1815f8d78f19bef55aadf66366ea494e6f6/ringbuf-1.0.3.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "6f5f244d5e57256942f10b350ba9aa68", "sha256": "b754cc06651925eb641e62001d7380ee4dfaba35625dd8cd86c85451ef80b785"}, "downloads": -1, "filename": "ringbuf-2.0.0.tar.gz", "has_sig": false, "md5_digest": "6f5f244d5e57256942f10b350ba9aa68", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 134926, "upload_time": "2020-03-15T00:01:36", "upload_time_iso_8601": "2020-03-15T00:01:36.285703Z", "url": "https://files.pythonhosted.org/packages/44/81/32cc1d015309ec5540bf8e6b04d3f23e124e367fd4d1760e7392fa4a9ad6/ringbuf-2.0.0.tar.gz", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "b3f405bf95f8f6b741639dec2090c145", "sha256": "c63b0a68189741700d3f968d70c6ef5c66de61c362346c155ddbaf09bda3b5b5"}, "downloads": -1, "filename": "ringbuf-2.1.0.tar.gz", "has_sig": false, "md5_digest": "b3f405bf95f8f6b741639dec2090c145", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 146611, "upload_time": "2020-03-22T21:04:05", "upload_time_iso_8601": "2020-03-22T21:04:05.001784Z", "url": "https://files.pythonhosted.org/packages/30/69/806d2434bde1e17426c11c5f38a972713138a29a592d82e295a8f9e0cf66/ringbuf-2.1.0.tar.gz", "yanked": false}], "2.2.0": [{"comment_text": "", "digests": {"md5": "da9b40964a2d1668811b339c569de384", "sha256": "f8c9e43795bf2f195c39b0b913f140a17fdd36a3b725e5919fb281b901f58b6c"}, "downloads": -1, "filename": "ringbuf-2.2.0.tar.gz", "has_sig": false, "md5_digest": "da9b40964a2d1668811b339c569de384", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148275, "upload_time": "2020-03-23T00:34:05", "upload_time_iso_8601": "2020-03-23T00:34:05.175526Z", "url": "https://files.pythonhosted.org/packages/ff/3e/cf6bb6fa907b5483839688d4193f254bfe95941a88c72006e46db60ea02d/ringbuf-2.2.0.tar.gz", "yanked": false}], "2.3.0": [{"comment_text": "", "digests": {"md5": "2e5fe9f0e9998b933dec5e82c1a1586e", "sha256": "2be4d8e2179667bafa2e524adb107e9d1c35da865e7fde49eb21c35c3139be15"}, "downloads": -1, "filename": "ringbuf-2.3.0.tar.gz", "has_sig": false, "md5_digest": "2e5fe9f0e9998b933dec5e82c1a1586e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149772, "upload_time": "2020-03-23T02:59:07", "upload_time_iso_8601": "2020-03-23T02:59:07.876807Z", "url": "https://files.pythonhosted.org/packages/1a/5c/1bb1fa7b677672eef44c812276d2bd13c7badef6978bdf86316f6bc7524c/ringbuf-2.3.0.tar.gz", "yanked": false}], "2.4.0": [{"comment_text": "", "digests": {"md5": "1c53d28a119ffee34eb960aa5e25e277", "sha256": "549d30d418ee8f66b20cce58d660fe3d6efc0e42bb6735b82235c881d54a10ab"}, "downloads": -1, "filename": "ringbuf-2.4.0.tar.gz", "has_sig": false, "md5_digest": "1c53d28a119ffee34eb960aa5e25e277", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149976, "upload_time": "2020-03-24T04:45:26", "upload_time_iso_8601": "2020-03-24T04:45:26.527945Z", "url": "https://files.pythonhosted.org/packages/b3/36/cc79d3fcf9f42927f1152dd3f3f69e333a3bbb3018e9737f24e73146c153/ringbuf-2.4.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1c53d28a119ffee34eb960aa5e25e277", "sha256": "549d30d418ee8f66b20cce58d660fe3d6efc0e42bb6735b82235c881d54a10ab"}, "downloads": -1, "filename": "ringbuf-2.4.0.tar.gz", "has_sig": false, "md5_digest": "1c53d28a119ffee34eb960aa5e25e277", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149976, "upload_time": "2020-03-24T04:45:26", "upload_time_iso_8601": "2020-03-24T04:45:26.527945Z", "url": "https://files.pythonhosted.org/packages/b3/36/cc79d3fcf9f42927f1152dd3f3f69e333a3bbb3018e9737f24e73146c153/ringbuf-2.4.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:37 2020"}