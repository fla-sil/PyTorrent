{"info": {"author": "Vincent Pelletier", "author_email": "plr.vincent@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Libraries"], "description": ".. contents::\n\nLinux AIO API wrapper\n\nThis is about in-kernel, file-descriptor-based asynchronous I/O.\nIt has nothing to do with the ``asyncio`` standard module.\n\nLinux AIO primer\n----------------\n\nWhen sending or expecting data, the typical issue a developer faces is knowing\nwhen the operation will complete, so the program can carry on.\n\n- read/write/recv/send: blocks until stuff happened\n- same, on a non-blocking file descriptor: errors out instead of blocking,\n  developper has to implement retry somehow, and may end up wasting CPU time\n  just resubmitting the same operation over and over.\n- select/poll/epoll: kernel tells the program when (re)submitting an operation\n  should not block (if developer is careful to not have competing IO sources)\n\nAIO is the next level: the application expresses the intention that some IO\noperation happens when the file descriptor accepts it *and* provides\ncorresponding buffer to the kernel.\nCompared to select/poll/epoll, this avoids one round-trip to userland when the\noperation becomes possible:\n\n- kernel sends notification (ex: fd is readable)\n- program initiates actual IO (ex: read from fd)\n\nInstead, kernel only has to notify userland the operation is already completed,\nand application may either process received data, or submit more data to send.\n\nEdge cases\n----------\n\nBecause of this high level of integration, low-level implementation\nconstraints which are abstracted by higher-overhead APIs may become apparent.\n\nFor example, when submitting AIO blocks to an USB gadget endpoint file, the\nblock should be aligned to page boundaries because some USB Device Controllers\ndo not have the ability to read/write partial pages.\n\nIn python, this means ``mmap`` should be used to allocate such buffer instead\nof just any ``bytearray``.\n\nAnother place where implementation details appear is completion statuses,\n``res`` and ``res2``. Their meaning depends on the module handling operations\non used file descriptor, so python-libaio transmits these values without\nassuming their meaning (rather than, say, raise on negative values).\n\nYet another place is application-initiated closures: there is a fundamental\nrace-condition when cancelling an AIO block (maybe hardware-triggered\ncompletion will happen first, or maybe software-initiated cancellation will).\nIn any case, a completion event will be produced and application may check\nwhich origin won. A consequence of this is that AIO context closure may take\ntime: while requesting cancellation does not block, software should wait for\nhardware to hand the buffers back.\n\npython 2 Notes\n--------------\n\nIn python 2.7, a memoryview of a bytearray, despite being writable, is rejected\nby ctypes:\n\n.. code:: python\n\n    >>> from ctypes import c_char\n    >>> a = bytearray(b'foo')\n    >>> c_char.from_buffer(a)\n    c_char('f')\n    >>> b = memoryview(a)\n    >>> b.readonly\n    False\n    >>> c_char.from_buffer(b)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: expected a writeable buffer object\n\nThis means that it is not possible to only read or write a few bytes at the\nbeginning of a large buffer without having to copy memory.\n\nThe same code works fine with python 3.x .\n\nThis is considered a python 2.7 ctypes or memoryview bug, and not a python-libaio bug.\n\nAlso, memoryview refuses to use an mmap object:\n\n.. code:: python\n\n    >>> import mmap\n    >>> a = mmap.mmap(-1, 16*1024)\n    >>> b = memoryview(a)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: cannot make memory view because object does not have the buffer interface\n    >>>\n\n...but ctypes is happy with it:\n\n.. code:: python\n\n    >>> import ctypes\n    >>> c = (ctypes.c_char * len(a)).from_buffer(a)\n    >>>\n\n...and memoryview accepts being constructed over ctype objects:\n\n.. code:: python\n\n    >>> d = memoryview(c)\n    >>>\n\n...and it really works !\n\n.. code:: python\n\n    >>> a[0]\n    '\\x00'\n    >>> c[0]\n    '\\x00'\n    >>> d[0]\n    '\\x00'\n    >>> d[0] = '\\x01'\n    >>> c[0]\n    '\\x01'\n    >>> a[0]\n    '\\x01'\n    >>> a[0] = '\\x02'\n    >>> c[0]\n    '\\x02'\n    >>> d[0]\n    '\\x02'\n\nThis is considered a python 2.7 memoryview or mmap bug.\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/vpelletier/python-libaio", "keywords": "linux aio libaio", "license": "LGPLv3+", "maintainer": "", "maintainer_email": "", "name": "libaio", "package_url": "https://pypi.org/project/libaio/", "platform": "linux", "project_url": "https://pypi.org/project/libaio/", "project_urls": {"Homepage": "http://github.com/vpelletier/python-libaio"}, "release_url": "https://pypi.org/project/libaio/0.8/", "requires_dist": null, "requires_python": "", "summary": "Linux AIO API wrapper", "version": "0.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#linux-aio-primer\" id=\"id1\" rel=\"nofollow\">Linux AIO primer</a></li>\n<li><a href=\"#edge-cases\" id=\"id2\" rel=\"nofollow\">Edge cases</a></li>\n<li><a href=\"#python-2-notes\" id=\"id3\" rel=\"nofollow\">python 2 Notes</a></li>\n</ul>\n</div>\n<p>Linux AIO API wrapper</p>\n<p>This is about in-kernel, file-descriptor-based asynchronous I/O.\nIt has nothing to do with the <tt>asyncio</tt> standard module.</p>\n<div id=\"linux-aio-primer\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Linux AIO primer</a></h2>\n<p>When sending or expecting data, the typical issue a developer faces is knowing\nwhen the operation will complete, so the program can carry on.</p>\n<ul>\n<li>read/write/recv/send: blocks until stuff happened</li>\n<li>same, on a non-blocking file descriptor: errors out instead of blocking,\ndevelopper has to implement retry somehow, and may end up wasting CPU time\njust resubmitting the same operation over and over.</li>\n<li>select/poll/epoll: kernel tells the program when (re)submitting an operation\nshould not block (if developer is careful to not have competing IO sources)</li>\n</ul>\n<p>AIO is the next level: the application expresses the intention that some IO\noperation happens when the file descriptor accepts it <em>and</em> provides\ncorresponding buffer to the kernel.\nCompared to select/poll/epoll, this avoids one round-trip to userland when the\noperation becomes possible:</p>\n<ul>\n<li>kernel sends notification (ex: fd is readable)</li>\n<li>program initiates actual IO (ex: read from fd)</li>\n</ul>\n<p>Instead, kernel only has to notify userland the operation is already completed,\nand application may either process received data, or submit more data to send.</p>\n</div>\n<div id=\"edge-cases\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Edge cases</a></h2>\n<p>Because of this high level of integration, low-level implementation\nconstraints which are abstracted by higher-overhead APIs may become apparent.</p>\n<p>For example, when submitting AIO blocks to an USB gadget endpoint file, the\nblock should be aligned to page boundaries because some USB Device Controllers\ndo not have the ability to read/write partial pages.</p>\n<p>In python, this means <tt>mmap</tt> should be used to allocate such buffer instead\nof just any <tt>bytearray</tt>.</p>\n<p>Another place where implementation details appear is completion statuses,\n<tt>res</tt> and <tt>res2</tt>. Their meaning depends on the module handling operations\non used file descriptor, so python-libaio transmits these values without\nassuming their meaning (rather than, say, raise on negative values).</p>\n<p>Yet another place is application-initiated closures: there is a fundamental\nrace-condition when cancelling an AIO block (maybe hardware-triggered\ncompletion will happen first, or maybe software-initiated cancellation will).\nIn any case, a completion event will be produced and application may check\nwhich origin won. A consequence of this is that AIO context closure may take\ntime: while requesting cancellation does not block, software should wait for\nhardware to hand the buffers back.</p>\n</div>\n<div id=\"python-2-notes\">\n<h2><a href=\"#id3\" rel=\"nofollow\">python 2 Notes</a></h2>\n<p>In python 2.7, a memoryview of a bytearray, despite being writable, is rejected\nby ctypes:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">ctypes</span> <span class=\"kn\">import</span> <span class=\"n\">c_char</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"nb\">bytearray</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'foo'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c_char</span><span class=\"o\">.</span><span class=\"n\">from_buffer</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"n\">c_char</span><span class=\"p\">(</span><span class=\"s1\">'f'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"nb\">memoryview</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">readonly</span>\n<span class=\"kc\">False</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c_char</span><span class=\"o\">.</span><span class=\"n\">from_buffer</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"n\">Traceback</span> <span class=\"p\">(</span><span class=\"n\">most</span> <span class=\"n\">recent</span> <span class=\"n\">call</span> <span class=\"n\">last</span><span class=\"p\">):</span>\n  <span class=\"n\">File</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span><span class=\"o\">&gt;</span>\n<span class=\"ne\">TypeError</span><span class=\"p\">:</span> <span class=\"n\">expected</span> <span class=\"n\">a</span> <span class=\"n\">writeable</span> <span class=\"n\">buffer</span> <span class=\"nb\">object</span>\n</pre>\n<p>This means that it is not possible to only read or write a few bytes at the\nbeginning of a large buffer without having to copy memory.</p>\n<p>The same code works fine with python 3.x .</p>\n<p>This is considered a python 2.7 ctypes or memoryview bug, and not a python-libaio bug.</p>\n<p>Also, memoryview refuses to use an mmap object:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">mmap</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">mmap</span><span class=\"o\">.</span><span class=\"n\">mmap</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"o\">*</span><span class=\"mi\">1024</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"nb\">memoryview</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"n\">Traceback</span> <span class=\"p\">(</span><span class=\"n\">most</span> <span class=\"n\">recent</span> <span class=\"n\">call</span> <span class=\"n\">last</span><span class=\"p\">):</span>\n  <span class=\"n\">File</span> <span class=\"s2\">\"&lt;stdin&gt;\"</span><span class=\"p\">,</span> <span class=\"n\">line</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">in</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span><span class=\"o\">&gt;</span>\n<span class=\"ne\">TypeError</span><span class=\"p\">:</span> <span class=\"n\">cannot</span> <span class=\"n\">make</span> <span class=\"n\">memory</span> <span class=\"n\">view</span> <span class=\"n\">because</span> <span class=\"nb\">object</span> <span class=\"n\">does</span> <span class=\"ow\">not</span> <span class=\"n\">have</span> <span class=\"n\">the</span> <span class=\"n\">buffer</span> <span class=\"n\">interface</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n</pre>\n<p>\u2026but ctypes is happy with it:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">ctypes</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">ctypes</span><span class=\"o\">.</span><span class=\"n\">c_char</span> <span class=\"o\">*</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">from_buffer</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n</pre>\n<p>\u2026and memoryview accepts being constructed over ctype objects:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"nb\">memoryview</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n</pre>\n<p>\u2026and it really works !</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"s1\">'</span><span class=\"se\">\\x00</span><span class=\"s1\">'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"s1\">'</span><span class=\"se\">\\x00</span><span class=\"s1\">'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"s1\">'</span><span class=\"se\">\\x00</span><span class=\"s1\">'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\x01</span><span class=\"s1\">'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"s1\">'</span><span class=\"se\">\\x01</span><span class=\"s1\">'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"s1\">'</span><span class=\"se\">\\x01</span><span class=\"s1\">'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\x02</span><span class=\"s1\">'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"s1\">'</span><span class=\"se\">\\x02</span><span class=\"s1\">'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"s1\">'</span><span class=\"se\">\\x02</span><span class=\"s1\">'</span>\n</pre>\n<p>This is considered a python 2.7 memoryview or mmap bug.</p>\n</div>\n\n          </div>"}, "last_serial": 7031045, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "ac2c2a4e3809ef617ebcdc3a52882aa4", "sha256": "c8efd0ac86dfce9dfcb4524d38a0b4d7e3eabed9056ff2e2ae7fe7577f98f85d"}, "downloads": -1, "filename": "libaio-0.1.tar.gz", "has_sig": false, "md5_digest": "ac2c2a4e3809ef617ebcdc3a52882aa4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5365, "upload_time": "2017-11-17T12:21:10", "upload_time_iso_8601": "2017-11-17T12:21:10.653801Z", "url": "https://files.pythonhosted.org/packages/f3/b4/979476df4d6a99791616a70829322d66c33c339425117d51a834739154e7/libaio-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "ad887eed2f04dcad56d300c2dd946578", "sha256": "d524522516820c48fb539d1d155419dc72077bbdf42bf62373696f4017514a9f"}, "downloads": -1, "filename": "libaio-0.2.tar.gz", "has_sig": false, "md5_digest": "ad887eed2f04dcad56d300c2dd946578", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5621, "upload_time": "2017-11-25T06:47:28", "upload_time_iso_8601": "2017-11-25T06:47:28.632227Z", "url": "https://files.pythonhosted.org/packages/52/bd/5fdd9ff28feb23e9fed880000e0cdf38f33fb2c52026c917635913f61b73/libaio-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "45e8b1b264e5cad80ba5b616e440d3f5", "sha256": "dbb3edbef2288f510c0a81b33ae5f4bb497ceab30dd570687950a869a39e292e"}, "downloads": -1, "filename": "libaio-0.3.tar.gz", "has_sig": false, "md5_digest": "45e8b1b264e5cad80ba5b616e440d3f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6745, "upload_time": "2018-07-25T03:22:59", "upload_time_iso_8601": "2018-07-25T03:22:59.640662Z", "url": "https://files.pythonhosted.org/packages/45/ca/bad843c75cf398490a2727c95ba39bd6d5be036a9cdd2fb4c6792a9674dd/libaio-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "53ab90b9e0193cae78ef8265f1923d0c", "sha256": "794bd26ebeb809edf4b3caa4cf83bb83b243af8712cbe2540c450742e86f6961"}, "downloads": -1, "filename": "libaio-0.4.tar.gz", "has_sig": false, "md5_digest": "53ab90b9e0193cae78ef8265f1923d0c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8547, "upload_time": "2018-09-15T14:20:26", "upload_time_iso_8601": "2018-09-15T14:20:26.142792Z", "url": "https://files.pythonhosted.org/packages/54/db/f2f18d11e434e76427a82177aa0ff3379f87dba91e10a4eec9c9077c7e9d/libaio-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "221e2c99b21656c7729ba8c4ecfbc596", "sha256": "7002b99aa4e27297bc1775eea1bf5dd78ee90c38557dee7cbad9224971555613"}, "downloads": -1, "filename": "libaio-0.5.tar.gz", "has_sig": false, "md5_digest": "221e2c99b21656c7729ba8c4ecfbc596", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9674, "upload_time": "2018-09-22T06:59:13", "upload_time_iso_8601": "2018-09-22T06:59:13.581407Z", "url": "https://files.pythonhosted.org/packages/41/93/31f56257a602544028e8223a129f297b5781472a72020e9243a36b0570f3/libaio-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "0940533caa58d61342bec7ea2b8f0701", "sha256": "d1d119cccc77cc7c6ed7c67fd170b02d9e6237f48a5ac5ade2a90f1450640501"}, "downloads": -1, "filename": "libaio-0.6.tar.gz", "has_sig": false, "md5_digest": "0940533caa58d61342bec7ea2b8f0701", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13062, "upload_time": "2019-05-30T22:25:01", "upload_time_iso_8601": "2019-05-30T22:25:01.349737Z", "url": "https://files.pythonhosted.org/packages/fa/a5/8c66a1b9f8d8a51a2ae6a8a6f68193e8c6577cb1361a02266a336ac6ef7e/libaio-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "7d53b022c4bb109fcf016cc8a35c1efc", "sha256": "4cb08b79ebc882a8dc25150efbd56cd11c23ae3288ed643fcff35ea234df3189"}, "downloads": -1, "filename": "libaio-0.7.tar.gz", "has_sig": false, "md5_digest": "7d53b022c4bb109fcf016cc8a35c1efc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45319, "upload_time": "2019-06-23T22:19:28", "upload_time_iso_8601": "2019-06-23T22:19:28.733446Z", "url": "https://files.pythonhosted.org/packages/c3/55/7a559e6564289ce79c5ba2494cfced92610c328b66d15db3b525803ff93f/libaio-0.7.tar.gz", "yanked": false}], "0.8": [{"comment_text": "", "digests": {"md5": "fd9edfeecbfe94929922fc9f9e4f414e", "sha256": "370f15fd2d3d86da59b4a5034d1f6bdfb710693586a0f7ac8f7c29a29400a738"}, "downloads": -1, "filename": "libaio-0.8.tar.gz", "has_sig": false, "md5_digest": "fd9edfeecbfe94929922fc9f9e4f414e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45336, "upload_time": "2020-04-16T10:11:55", "upload_time_iso_8601": "2020-04-16T10:11:55.939993Z", "url": "https://files.pythonhosted.org/packages/32/e4/b598f23df0e4b4aabf01a2b32a4a772da523b7e528c55e53851fe5e64db2/libaio-0.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fd9edfeecbfe94929922fc9f9e4f414e", "sha256": "370f15fd2d3d86da59b4a5034d1f6bdfb710693586a0f7ac8f7c29a29400a738"}, "downloads": -1, "filename": "libaio-0.8.tar.gz", "has_sig": false, "md5_digest": "fd9edfeecbfe94929922fc9f9e4f414e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45336, "upload_time": "2020-04-16T10:11:55", "upload_time_iso_8601": "2020-04-16T10:11:55.939993Z", "url": "https://files.pythonhosted.org/packages/32/e4/b598f23df0e4b4aabf01a2b32a4a772da523b7e528c55e53851fe5e64db2/libaio-0.8.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:41 2020"}