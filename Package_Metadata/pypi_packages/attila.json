{"info": {"author": "Christian Visintin", "author_email": "christian.visintin1997@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "Intended Audience :: End Users/Desktop", "Intended Audience :: Telecommunications Industry", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Topic :: Communications :: Telephony", "Topic :: Home Automation", "Topic :: Software Development :: Libraries"], "description": "# ATtila\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-teal.svg)](https://opensource.org/licenses/MIT) [![Stars](https://img.shields.io/github/stars/ChristianVisintin/ATtila.svg)](https://github.com/ChristianVisintin/ATtila) [![Issues](https://img.shields.io/github/issues/ChristianVisintin/ATtila.svg)](https://github.com/ChristianVisintin/ATtila/) [![PyPI version](https://badge.fury.io/py/attila.svg)](https://pypi.org/project/attila/) [![Build](https://api.travis-ci.org/ChristianVisintin/ATtila.svg?branch=master)](https://travis-ci.org/ChristianVisintin/ATtila) [![codecov](https://codecov.io/gh/ChristianVisintin/ATtila/branch/master/graph/badge.svg)](https://codecov.io/gh/ChristianVisintin/ATtila)\n\nDeveloped by *Christian Visintin*\n\nCurrent Version: **1.1.6 (25/03/2020)**\n\n- [ATtila](#attila)\n  - [Introduction](#introduction)\n  - [Requirements](#requirements)\n  - [Implementation](#implementation)\n    - [Virtual Device](#virtual-device)\n  - [ATScript](#atscript)\n    - [ATScript Introduction](#atscript-introduction)\n    - [ATScript Commands](#atscript-commands)\n      - [Examples](#examples)\n        - [Basic command](#basic-command)\n        - [Command and expected response](#command-and-expected-response)\n        - [Delay and timeout](#delay-and-timeout)\n      - [Doppelgangers](#doppelgangers)\n      - [Collectables](#collectables)\n      - [Session Values](#session-values)\n    - [Environment Setup Keywords](#environment-setup-keywords)\n    - [Let's put it all together](#lets-put-it-all-together)\n  - [Known Issues](#known-issues)\n  - [Tests Units](#tests-units)\n  - [Changelog](#changelog)\n    - [ATtila 1.1.6 (25/03/2020)](#attila-116-25032020)\n    - [ATtila 1.1.5 (09/03/2020)](#attila-115-09032020)\n    - [ATtila 1.1.4 (05/03/2020)](#attila-114-05032020)\n    - [ATtila 1.1.3 (07/12/2019)](#attila-113-07122019)\n    - [ATtila 1.1.2 (29/10/2019)](#attila-112-29102019)\n    - [ATtila 1.1.1 (26/10/2019)](#attila-111-26102019)\n    - [ATtila 1.1.0 (26/10/2019)](#attila-110-26102019)\n    - [ATtila 1.0.4 (13/10/2019)](#attila-104-13102019)\n    - [ATtila 1.0.3 (12/10/2019)](#attila-103-12102019)\n  - [Branches](#branches)\n  - [License](#license)\n\n---\n\n```sh\npip3 install attila\n```\n\n## Introduction\n\nATtila is a Python module which purpose is to ease the communication with an RF module which uses AT commands. It is both possible to send single AT commands indicating what response is expected and AT scritps which indicate all the commands to send, the expected response for each command, what information to store for each command and define an alternative behaviour in case of unexpected responses.  \nThese are the main functionalities that ATtila provides:\n\n- Sending individual AT command to RF module/modem through serial port and get the response for them\n- Sending of multiple AT commands using \u201cATScripts\u201d. ATScripts in particular allows you to:\n  - Define a set of commands to execute on the RF module\n  - Get the response and choose what information to store for each commands\n  - Use the response of a certain command in a command which will be executed later\n  - Define alternative behaviour in case of error\n\nATtila comes with a binary (which should be used instead of chat in my opinion) or for anything you want.\nYou can run ATtila binary with\n\n```sh\npython3 -m attila\n```\n\n```txt\nUsage: attila [OPTION]... [FILE]\n\n  With no FILE, run in interactive mode\n\n  -p  <device path>     Use this device to communicate\n  -b  <baud rate>       Use the specified baudrate to communicate\n  -T  <default timeout> Use the specified timeout as default to communicate\n  -B  <break>           Use the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  -A  <True/False>      Abort on failure (Default: True)\n  -L  <logfile>         Enable log and log to the specified log file (stdout is supported)\n  -l  <loglevel>        Specify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO)\n  -v                    Be more verbose\n  -q                    Be quiet (print only PRINT ESKs and ERRORS)\n  -h                    Show this page\n```\n\n## Requirements\n\n- Python3.5 (>= 1.2.0)\n  - Python3.4 (up to 1.1.4)\n- pyserial3\n\n## Implementation\n\nIn order to build your own implementation using ATtila these are the steps you'll need to follow:\n\n1. The first thing you have to do is import the AT Runtime Environment and the exceptions it can raise in your project:  \n  ```from attila.atre import ATRuntimeEnvironment```  \n  ```from attila.exceptions import ATREUninitializedError, ATRuntimeError, ATScriptNotFound, ATScriptSyntaxError, ATSerialPortError```\n2. Instance an ATRuntimeEnvironment object:  \n  ```atrunenv = ATRuntimeEnvironment(abort_on_failure)```\n3. Configure the communicator, the component which will communicate with your device:  \n  ```atrunenv.configure_communicator(device, baud_rate, default_timeout, line_break)```\n4. Open the serial port (Be careful, this function can return a ATSerialPortError):  \n  ```atrunenv.open_serial()```\n5. Choose how to parse commands:\n   1. Parse an ATScript (parse_ATScript can raise ATScriptNotFound or ATScriptSyntaxError):  \n    ```atrunenv.parse_ATScript(script_file)```\n   2. Execute directly a command (or an ESK):\n    ```response = atrunenv.exec(command_str)```\n   3. Add an ATCommand to the session:\n    ```atrunenv.add_command(command_str)```\n6. Execute commands:\n   1. Run everything at once and then get a list of ATResponse (if abort_on_failure is True, the ATRE will raise ATRuntimeError during execution):  \n    ```response_list = atrunenv.run()```\n   2. Run one command a time (if abort_on_failure is True, the ATRE will raise ATRuntimeError):\n    ```response = atrunenv.exec_next()```\n7. Collect the values you need:  \n  ```rssi = atrunenv.get_session_value(\"rssi\")```\n8. Close serial: ```atrunenv.close_serial()```\n\n### Virtual Device\n\nSince version 1.1.0, it is possible to use a virtual serial device, instead of a real one. This has been introduced for tests purpose, but can actually used in cases where you need to emulate a serial device and you want to keep using ATtila.\nIn this case, in the ATRE, instead of using configure_communicator use:\n\n```py\ndef configure_virtual_communicator(self, serial_port, baud_rate, timeout = None, line_break = \"\\r\\n\", read_callback = None, write_callback = None, in_waiting_callback = None)\n```\n\nThe virtual communicator, in addition to the standard one, requires a read, a write and an in waiting callback. These callbacks must replace the I/O operations of the serial device, with something else (e.g. a socket with an HTTP request)\n\n## ATScript\n\n### ATScript Introduction\n\nATScript is the most important feature of ATtila, since it allows to execute a set of AT commands (*well, not only AT based to be honest...*) sequentially and evaluate, store and combine their output.\n\nBasically in an AT scripts there are three things:\n\n- **Commands**: describe what you want to send to the device and how to treat its response.\n- **Environment Setup Keywords**: describes how to establish and manage the communication.\n- **Comments**: you can obviously put comments in the ATScripts, the ATScriptParser will just ignore them. A comment statement must start with '#' character.\n\n### ATScript Commands\n\nObviously the most important feature of ATScripts is the possibility to execute AT Commands.\nAs far as we\u2019ve learned up to now, we know that a command has the following parameters:\n\n- the **command** itself\n- the **response** we expect\n- the **doppelganger** and it's expected response\n- **collectables**\n- a **delay** (milliseconds to wait before its execution)\n- a **timeout**\n\nSo basically, to think it easy, the syntax for commands will be a combination of them:\n\n```txt\nCOMMAND;;RESPONSE_EXPR;;DELAY;;TIMEOUT;;[\"COLLECTABLE1\",\"...\",\"COLLECTABLEn\"];;DOPPELGANGER;;DOPPELGANGER_RESPONSE\n```\n\nTo see practical applications of them, let's see a few examples.\n\n#### Examples\n\nWe\u2019ll start with a simple one: the \"AT\" command\n\nThe most basic usable syntax is just:\n\n##### Basic command\n\n```txt\nAT\n```\n\n##### Command and expected response\n\nbut you probably want at least to verify if its response is what you expect:\n\n```txt\nAT;;OK\n```\n\nWe told ATtila that we expect to find \u201cOK\u201d in the command response.\nWe can also use a regex in the expected response, for example if a command returns 16 hex digits, we can use\n\n```txt\nAT+GSN;;^[0-9,A-F]{16}$\n```\n\n##### Delay and timeout\n\nThen we can also add a delay before command execution (in milliseconds) and a timeout (in seconds)\n\n```txt\nAT;;OK;;1000;;5\n```\n\nThese commands don\u2019t have all the available parameters, we still need to go deep and the see **doppelgangers and collectables** concepts.\n\n#### Doppelgangers\n\nIn the previous example we\u2019ve seen the basic parameters associated to a command, but now I want to introduce you the doppelganger feature included in ATScripts. Imagine for instance that we want to set the SIM pin, but only if it requires to be unlocked (This is a situation I\u2019ve encountered many times at job where there could be devices with locked and unlocked PIN, but the chat script was the same).\nWe\u2019ll use AT+CPIN?, in case the SIM is unlocked it will return \u201c+CPIN:READY\u201d; we want to set the PIN only if returns something else. (If locked, returns \u201cCPIN:SIM PIN\u201d)\nThe command we\u2019ll use is:\n\n```txt\nAT+CPIN?;;READY;;0;;5;;;;AT+CPIN=7782;;OK\n```\n\nWhat does this command mean?\nIt tells ATtila to send AT+CPIN? and that we expect to find \"READY\" string in the response. If READY is found in the response it will proceed with the next command, but what happens for example if the device answers with \u201c+CPIN: SIM PIN\u201d? The ATSession will set as next command its doppelganger, which is AT+CPIN=7782, which will be executed as the next command.\n\n#### Collectables\n\nThe last, but not least important parameter you can set in a command is collectables.\nCollectables are values that you can collect from a command response and transform into a **session value** (we\u2019ll talk about session values in the next chapter).\nImagine for example you want to collect the current signal quality and store it into a variable you want for example to save on Redis, you can do it just by specifying what you\u2019re looking for and the session value name and the job is done: ATila will do the job for you!\n\n```txt\nAT+CSQ;;+CSQ;;0;;5;;[\"AT+CSQ=?{rssi},\",\"AT+CSQ=${rssi},?{ber}\"]\n```\n\nThis command has two collectables, which are the rssi and the Ber. We know that AT+CSQ, in case of a positive response (+CSQ:...), will return the **rssi and the ber** after \u201cAT+CSQ=\u201d separated by a comma. Imagine that we want to get both. The first value we want is located after \u201cAT+CSQ=\u201d and terminates with the ',' comma before the ber. So we tell ATtila to get a value between these two strings and to store it into a session value called \u201crssi\u201d. The other value will be located after the other part of the string; we can as you can see, reuse the rssi value in the second collectable (since rssi is already set).\nThe syntax which describes the start of a collectable is **?{SESSION_KEY}**.\n\nThis was a simple case, where we knew the value where between 'AT+CSQ=...,' and after 'AT+CSQ=rssi,...'. But sometimes we have to get a value which hasn't anything around. An example of this case is AT+CGSN, which returns the IMEI. The IMEI is returned on a line, with nothing around:\n\n```txt\nAT+CGSN\n123456789012345\nOK\n```\n\nHow can we get this value using collectables? Well, we can, but making a collectable a little more bit complex. We need to use a key regex:\n\n```txt\nAT+CGSN;;OK;;;;;;[\"?{IMEI::^[0-9]{15}$}\"]\n```\n\nThis means we're looking for a value between nothing, but which has to respect the regex we provided which is ```^[0-9]{15}$```. If a number of 15 digits is found in the response, this value will be stored into the session storage into a key named \"IMEI\".\nThe separator between the **key name** and the **key regex** is ```::```\nThis mechanism can also be used to solve ambiguity in the response to get the value that we really want.\n\nFor example we can make a more severe check on the CSQ using:\n\n```txt\nAT+CSQ;;OK;;;;;;[\"AT+CSQ=?{rssi::[0-9]{1,2}},\",\"AT+CSQ=${rssi},?{ber::[0-9]{1,2}}\"]\n```\n\n#### Session Values\n\nWe\u2019ve seen that session values are values we can store using collectables and also setting environment variables and through Environment Setup Keywords, but we\u2019ll see that in the next chapter.\nA session value **is just a key associated to a value**, stored in the **session storage**. The session storage is a dictionary made up of all the session values, it lives only for the current command set, when a new session is instanced, the session storage is empty again.\n*It\u2019s not that complicated.*\n\nWe can rethink the previous example of CPIN using session values.\nThe script which set the SIM PIN only if locked, could be a part of an image installed on plenty of devices, but we can\u2019t have a different script for each device and using a script which replace runtime the text with the configured PIN is not such a good way to do things.\nHere is where the power of session values comes in help!\nThe SIM pin could be for instance, written example in a configuration file and we want to set it as a session value.\nIf before the execution of our script, we execute \u201cexport SIM_PIN=7782\u201d and then we execute this row in ATila using GETENV (we'll see what GETENV is in the next chapter) somewhere in the script before its execution.\n\n```txt\nGETENV SIM_PIN\nAT+CPIN;;READY;;0;;5;;;;AT+CPIN=${SIM_PIN};;OK\n```\n\nSIM_PIN will be replaced by 7782.\n\nBut as we seen in the previous chapter, Session values can also be used to get collectables (if we already know a value that will be for sure in the response).\n\n### Environment Setup Keywords\n\nAs said before, ATScripts are not made only up of commands, but also of another thing called **Environment Setup Keywords (ESKs)**.\nLet\u2019s start from talking briefly about how ATtila works. ATtila has two main components: the **AT Runtime Environment (ATRE)** and the **ATSession**. The AT Runtime Environment instances a session and executes it following its commands, when the session execution ends, a new session can be instanced and the previous one gets destroyed, while the runtime environment persists. While **commands describe the ATSession execution path**, the **ESKs describe the setup for the AT Runtime Environment**, not only at the initial setup, but also at any time during runtime. ESKs can also be used to invoke the ATRE to execute some commands as we'll see..\nSo, to summarize, **ESKs are commands you can put (but are not mandatory) in your scripts and tell the Runtime Environment how to configure its components or extra instructions to be executed**.\nLet\u2019s see then which ESKs are supported.\n\n| ESK      | Value                         | Description                                                                                              |\n|----------|-------------------------------|----------------------------------------------------------------------------------------------------------|\n| DEVICE   | String                        | Indicates the target device used to communicate (e.g. /dev/ttyUSB0)                                      |\n| BAUDRATE | Int                           | Describes the baud rate used to communicate (e.g. 9600)                                                  |\n| TIMEOUT  | Int                           | Describes the default command timeout (e.g. 5)                                                           |\n| BREAK    | \"LF\" / \"CRLF\" / \"CR\" / \"NONE\" | Describes the line break used for commands between LF and CRLF                                           |\n| AOF      | True / False                  | Abort on failure: describes whether the runtime environment shut abort on command failure                |\n| SET      | String=String                 | Tells ATRE to set a session value with a certain key and value: (e.g. SET SIM=7789)                      |\n| GETENV   | String                        | Tells ATRE to store in session storage a certain environmental variable. (e.g. GETENV SIM_PIN)           |\n| PRINT    | String                        | Tells ATRE to print to stdout a string (e.g. PRINT SIM PIN: ${SIM_PIN})                                  |\n| EXEC     | String                        | Tells ATRE to execute a shell process (e.g. EXEC \u201cexport SIM_PIN=`cat /tmp/config.json | jq .modem.pin`\u201d |\n\n### Let's put it all together\n\nNow that we know everything about ATScripts, let's build a Modem dial script :D\n\n```txt\n#Set up communication parameters\nDEVICE /dev/ttyUSB0\nBAUDRATE 115200\nTIMEOUT 10\nBREAK CRLF\n#Abort on failure\nAOF True\n#Get the SIM PIN and the APN\nGETENV SIM_PIN\nGETENV APN\n#Let's start with modem setup\nPRINT Configuring modem parameters\n#+++ doesn't want a break\nBREAK NONE\n+++\nBREAK CRLF\nATH0;;;;5000\nATE0;;OK\nATZ;;OK\nATE0;;OK\n#I'm going to verify signal etc, we don't need to aof\nAOF False\nAT+CSQ;;OK;;;;;;[\"AT+CSQ=?{rssi::[0-9]{1,2}},\",\"AT+CSQ=${rssi},?{ber::[0-9]{1,2}}\"]\nAT+CGSN;;OK;;;;;;[\"?{IMEI::^[0-9]{15}$}\"]\nAT+CREG?;;OK\n#Now I'm configuring modem for dialup, so AOF it's important\nAOF True\nAT+CPIN?;;READY;;0;;5;;;;AT+CPIN=${SIM_PIN};;OK\nAT+CGDCONT=1,\"IP\",\"${APN}\";;OK;;1000\n#Dial APN\nPRINT Dialing your ISP...\nAT+CGDATA=\"PPP\",1;;CONNECT\n```\n\n## Known Issues\n\nNone, as far as I know at least.\n\n## Tests Units\n\nATtila is provided with tests units, which can be found under tests/ directory.\nThese tests units tests the three most important parts of ATtila which are the ATScriptParser, the ATSession and the ATRuntimeEnvironment.\nTo launch test unit just type:\n\n```sh\nnosetests -v --with-coverage --cover-tests --cover-package=attila --nocapture tests/\n```\n\n## Changelog\n\n### ATtila 1.1.6 (25/03/2020)\n\n- Fixed response collection\n\n### ATtila 1.1.5 (09/03/2020)\n\n- Fixed serial communication which didn't wait for all input\n  - Serial is now slower, especially for lower baudrate\n\n### ATtila 1.1.4 (05/03/2020)\n\n- Fixed slow serial read when working with low baud rates\n- Added ```rtscts=True, dsrdtr=True``` options to serial open\n- Serial Write is no more blocking\n- Fixed doppelganger and collectables\n\n### ATtila 1.1.3 (07/12/2019)\n\n- Fixed a typo in ATRE for ESK EXEC (commit ref: 8506523)\n\n### ATtila 1.1.2 (29/10/2019)\n\n- Fixed broken windows installation\n\n### ATtila 1.1.1 (26/10/2019)\n\n- Didn't deploy virtual.\n\n### ATtila 1.1.0 (26/10/2019)\n\n- Fixed device not None after serial close\n- Fixed ATCommand response getter\n- Added SyntaxError exception handler in ATScriptParser\n- Fixed value getter in ESK\n- Added Virtual Serial device\n- Test improvements\n\n### ATtila 1.0.4 (13/10/2019)\n\n- Added codecov\n- Added missing CR value in BREAK ESK\n- Added ESK and ATRE tests\n\n### ATtila 1.0.3 (12/10/2019)\n\n- Fixed help in main\n- Added Travis\n\n## Branches\n\n- master: stable only\n- dev: main development branch\n- other features\n\n---\n\n## License\n\n```txt\nMIT License\n\nCopyright (c) 2019 Christian Visintin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ChristianVisintin/ATtila", "keywords": "AT commands,IOT,wireless,radio frequency,modem,rf modules", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "attila", "package_url": "https://pypi.org/project/attila/", "platform": "", "project_url": "https://pypi.org/project/attila/", "project_urls": {"Homepage": "https://github.com/ChristianVisintin/ATtila"}, "release_url": "https://pypi.org/project/attila/1.1.6/", "requires_dist": null, "requires_python": ">=3.4", "summary": "Python module to communicate easily with modems and RF modules using AT commands", "version": "1.1.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>ATtila</h1>\n<p><a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img alt=\"License: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fc9fa3dc420e55d14d6ba8afdba03a3497cf16b1/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d7465616c2e737667\"></a> <a href=\"https://github.com/ChristianVisintin/ATtila\" rel=\"nofollow\"><img alt=\"Stars\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/eca583fb360cbe68b237858980faa1ca15db5edc/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f73746172732f43687269737469616e566973696e74696e2f415474696c612e737667\"></a> <a href=\"https://github.com/ChristianVisintin/ATtila/\" rel=\"nofollow\"><img alt=\"Issues\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/433c71bbc2b7e439169f0803a53d431a208f746a/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6973737565732f43687269737469616e566973696e74696e2f415474696c612e737667\"></a> <a href=\"https://pypi.org/project/attila/\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5c81a5ba37b5ce8d58ee746071611a5b62dabd26/68747470733a2f2f62616467652e667572792e696f2f70792f617474696c612e737667\"></a> <a href=\"https://travis-ci.org/ChristianVisintin/ATtila\" rel=\"nofollow\"><img alt=\"Build\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e9078f7526c12430b3dcca9a10d369390eef9764/68747470733a2f2f6170692e7472617669732d63692e6f72672f43687269737469616e566973696e74696e2f415474696c612e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://codecov.io/gh/ChristianVisintin/ATtila\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d49a37bf5b4630cea2fd56fe4d1079ca9148f998/68747470733a2f2f636f6465636f762e696f2f67682f43687269737469616e566973696e74696e2f415474696c612f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<p>Developed by <em>Christian Visintin</em></p>\n<p>Current Version: <strong>1.1.6 (25/03/2020)</strong></p>\n<ul>\n<li><a href=\"#attila\" rel=\"nofollow\">ATtila</a>\n<ul>\n<li><a href=\"#introduction\" rel=\"nofollow\">Introduction</a></li>\n<li><a href=\"#requirements\" rel=\"nofollow\">Requirements</a></li>\n<li><a href=\"#implementation\" rel=\"nofollow\">Implementation</a>\n<ul>\n<li><a href=\"#virtual-device\" rel=\"nofollow\">Virtual Device</a></li>\n</ul>\n</li>\n<li><a href=\"#atscript\" rel=\"nofollow\">ATScript</a>\n<ul>\n<li><a href=\"#atscript-introduction\" rel=\"nofollow\">ATScript Introduction</a></li>\n<li><a href=\"#atscript-commands\" rel=\"nofollow\">ATScript Commands</a>\n<ul>\n<li><a href=\"#examples\" rel=\"nofollow\">Examples</a>\n<ul>\n<li><a href=\"#basic-command\" rel=\"nofollow\">Basic command</a></li>\n<li><a href=\"#command-and-expected-response\" rel=\"nofollow\">Command and expected response</a></li>\n<li><a href=\"#delay-and-timeout\" rel=\"nofollow\">Delay and timeout</a></li>\n</ul>\n</li>\n<li><a href=\"#doppelgangers\" rel=\"nofollow\">Doppelgangers</a></li>\n<li><a href=\"#collectables\" rel=\"nofollow\">Collectables</a></li>\n<li><a href=\"#session-values\" rel=\"nofollow\">Session Values</a></li>\n</ul>\n</li>\n<li><a href=\"#environment-setup-keywords\" rel=\"nofollow\">Environment Setup Keywords</a></li>\n<li><a href=\"#lets-put-it-all-together\" rel=\"nofollow\">Let's put it all together</a></li>\n</ul>\n</li>\n<li><a href=\"#known-issues\" rel=\"nofollow\">Known Issues</a></li>\n<li><a href=\"#tests-units\" rel=\"nofollow\">Tests Units</a></li>\n<li><a href=\"#changelog\" rel=\"nofollow\">Changelog</a>\n<ul>\n<li><a href=\"#attila-116-25032020\" rel=\"nofollow\">ATtila 1.1.6 (25/03/2020)</a></li>\n<li><a href=\"#attila-115-09032020\" rel=\"nofollow\">ATtila 1.1.5 (09/03/2020)</a></li>\n<li><a href=\"#attila-114-05032020\" rel=\"nofollow\">ATtila 1.1.4 (05/03/2020)</a></li>\n<li><a href=\"#attila-113-07122019\" rel=\"nofollow\">ATtila 1.1.3 (07/12/2019)</a></li>\n<li><a href=\"#attila-112-29102019\" rel=\"nofollow\">ATtila 1.1.2 (29/10/2019)</a></li>\n<li><a href=\"#attila-111-26102019\" rel=\"nofollow\">ATtila 1.1.1 (26/10/2019)</a></li>\n<li><a href=\"#attila-110-26102019\" rel=\"nofollow\">ATtila 1.1.0 (26/10/2019)</a></li>\n<li><a href=\"#attila-104-13102019\" rel=\"nofollow\">ATtila 1.0.4 (13/10/2019)</a></li>\n<li><a href=\"#attila-103-12102019\" rel=\"nofollow\">ATtila 1.0.3 (12/10/2019)</a></li>\n</ul>\n</li>\n<li><a href=\"#branches\" rel=\"nofollow\">Branches</a></li>\n<li><a href=\"#license\" rel=\"nofollow\">License</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<pre>pip3 install attila\n</pre>\n<h2>Introduction</h2>\n<p>ATtila is a Python module which purpose is to ease the communication with an RF module which uses AT commands. It is both possible to send single AT commands indicating what response is expected and AT scritps which indicate all the commands to send, the expected response for each command, what information to store for each command and define an alternative behaviour in case of unexpected responses.<br>\nThese are the main functionalities that ATtila provides:</p>\n<ul>\n<li>Sending individual AT command to RF module/modem through serial port and get the response for them</li>\n<li>Sending of multiple AT commands using \u201cATScripts\u201d. ATScripts in particular allows you to:\n<ul>\n<li>Define a set of commands to execute on the RF module</li>\n<li>Get the response and choose what information to store for each commands</li>\n<li>Use the response of a certain command in a command which will be executed later</li>\n<li>Define alternative behaviour in case of error</li>\n</ul>\n</li>\n</ul>\n<p>ATtila comes with a binary (which should be used instead of chat in my opinion) or for anything you want.\nYou can run ATtila binary with</p>\n<pre>python3 -m attila\n</pre>\n<pre>Usage: attila [OPTION]... [FILE]\n\n  With no FILE, run in interactive mode\n\n  -p  &lt;device path&gt;     Use this device to communicate\n  -b  &lt;baud rate&gt;       Use the specified baudrate to communicate\n  -T  &lt;default timeout&gt; Use the specified timeout as default to communicate\n  -B  &lt;break&gt;           Use the specified line break [CRLF, LF, CR, NONE] (Default: CRLF)\n  -A  &lt;True/False&gt;      Abort on failure (Default: True)\n  -L  &lt;logfile&gt;         Enable log and log to the specified log file (stdout is supported)\n  -l  &lt;loglevel&gt;        Specify the log level (0: CRITICAL, 1: ERROR, 2: WARN, 3: INFO, 4: DEBUG) (Default: INFO)\n  -v                    Be more verbose\n  -q                    Be quiet (print only PRINT ESKs and ERRORS)\n  -h                    Show this page\n</pre>\n<h2>Requirements</h2>\n<ul>\n<li>Python3.5 (&gt;= 1.2.0)\n<ul>\n<li>Python3.4 (up to 1.1.4)</li>\n</ul>\n</li>\n<li>pyserial3</li>\n</ul>\n<h2>Implementation</h2>\n<p>In order to build your own implementation using ATtila these are the steps you'll need to follow:</p>\n<ol>\n<li>The first thing you have to do is import the AT Runtime Environment and the exceptions it can raise in your project:<br>\n<code>from attila.atre import ATRuntimeEnvironment</code><br>\n<code>from attila.exceptions import ATREUninitializedError, ATRuntimeError, ATScriptNotFound, ATScriptSyntaxError, ATSerialPortError</code></li>\n<li>Instance an ATRuntimeEnvironment object:<br>\n<code>atrunenv = ATRuntimeEnvironment(abort_on_failure)</code></li>\n<li>Configure the communicator, the component which will communicate with your device:<br>\n<code>atrunenv.configure_communicator(device, baud_rate, default_timeout, line_break)</code></li>\n<li>Open the serial port (Be careful, this function can return a ATSerialPortError):<br>\n<code>atrunenv.open_serial()</code></li>\n<li>Choose how to parse commands:\n<ol>\n<li>Parse an ATScript (parse_ATScript can raise ATScriptNotFound or ATScriptSyntaxError):<br>\n<code>atrunenv.parse_ATScript(script_file)</code></li>\n<li>Execute directly a command (or an ESK):\n<code>response = atrunenv.exec(command_str)</code></li>\n<li>Add an ATCommand to the session:\n<code>atrunenv.add_command(command_str)</code></li>\n</ol>\n</li>\n<li>Execute commands:\n<ol>\n<li>Run everything at once and then get a list of ATResponse (if abort_on_failure is True, the ATRE will raise ATRuntimeError during execution):<br>\n<code>response_list = atrunenv.run()</code></li>\n<li>Run one command a time (if abort_on_failure is True, the ATRE will raise ATRuntimeError):\n<code>response = atrunenv.exec_next()</code></li>\n</ol>\n</li>\n<li>Collect the values you need:<br>\n<code>rssi = atrunenv.get_session_value(\"rssi\")</code></li>\n<li>Close serial: <code>atrunenv.close_serial()</code></li>\n</ol>\n<h3>Virtual Device</h3>\n<p>Since version 1.1.0, it is possible to use a virtual serial device, instead of a real one. This has been introduced for tests purpose, but can actually used in cases where you need to emulate a serial device and you want to keep using ATtila.\nIn this case, in the ATRE, instead of using configure_communicator use:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">configure_virtual_communicator</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">serial_port</span><span class=\"p\">,</span> <span class=\"n\">baud_rate</span><span class=\"p\">,</span> <span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">line_break</span> <span class=\"o\">=</span> <span class=\"s2\">\"</span><span class=\"se\">\\r\\n</span><span class=\"s2\">\"</span><span class=\"p\">,</span> <span class=\"n\">read_callback</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">write_callback</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">in_waiting_callback</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>The virtual communicator, in addition to the standard one, requires a read, a write and an in waiting callback. These callbacks must replace the I/O operations of the serial device, with something else (e.g. a socket with an HTTP request)</p>\n<h2>ATScript</h2>\n<h3>ATScript Introduction</h3>\n<p>ATScript is the most important feature of ATtila, since it allows to execute a set of AT commands (<em>well, not only AT based to be honest...</em>) sequentially and evaluate, store and combine their output.</p>\n<p>Basically in an AT scripts there are three things:</p>\n<ul>\n<li><strong>Commands</strong>: describe what you want to send to the device and how to treat its response.</li>\n<li><strong>Environment Setup Keywords</strong>: describes how to establish and manage the communication.</li>\n<li><strong>Comments</strong>: you can obviously put comments in the ATScripts, the ATScriptParser will just ignore them. A comment statement must start with '#' character.</li>\n</ul>\n<h3>ATScript Commands</h3>\n<p>Obviously the most important feature of ATScripts is the possibility to execute AT Commands.\nAs far as we\u2019ve learned up to now, we know that a command has the following parameters:</p>\n<ul>\n<li>the <strong>command</strong> itself</li>\n<li>the <strong>response</strong> we expect</li>\n<li>the <strong>doppelganger</strong> and it's expected response</li>\n<li><strong>collectables</strong></li>\n<li>a <strong>delay</strong> (milliseconds to wait before its execution)</li>\n<li>a <strong>timeout</strong></li>\n</ul>\n<p>So basically, to think it easy, the syntax for commands will be a combination of them:</p>\n<pre>COMMAND;;RESPONSE_EXPR;;DELAY;;TIMEOUT;;[\"COLLECTABLE1\",\"...\",\"COLLECTABLEn\"];;DOPPELGANGER;;DOPPELGANGER_RESPONSE\n</pre>\n<p>To see practical applications of them, let's see a few examples.</p>\n<h4>Examples</h4>\n<p>We\u2019ll start with a simple one: the \"AT\" command</p>\n<p>The most basic usable syntax is just:</p>\n<h5>Basic command</h5>\n<pre>AT\n</pre>\n<h5>Command and expected response</h5>\n<p>but you probably want at least to verify if its response is what you expect:</p>\n<pre>AT;;OK\n</pre>\n<p>We told ATtila that we expect to find \u201cOK\u201d in the command response.\nWe can also use a regex in the expected response, for example if a command returns 16 hex digits, we can use</p>\n<pre>AT+GSN;;^[0-9,A-F]{16}$\n</pre>\n<h5>Delay and timeout</h5>\n<p>Then we can also add a delay before command execution (in milliseconds) and a timeout (in seconds)</p>\n<pre>AT;;OK;;1000;;5\n</pre>\n<p>These commands don\u2019t have all the available parameters, we still need to go deep and the see <strong>doppelgangers and collectables</strong> concepts.</p>\n<h4>Doppelgangers</h4>\n<p>In the previous example we\u2019ve seen the basic parameters associated to a command, but now I want to introduce you the doppelganger feature included in ATScripts. Imagine for instance that we want to set the SIM pin, but only if it requires to be unlocked (This is a situation I\u2019ve encountered many times at job where there could be devices with locked and unlocked PIN, but the chat script was the same).\nWe\u2019ll use AT+CPIN?, in case the SIM is unlocked it will return \u201c+CPIN:READY\u201d; we want to set the PIN only if returns something else. (If locked, returns \u201cCPIN:SIM PIN\u201d)\nThe command we\u2019ll use is:</p>\n<pre>AT+CPIN?;;READY;;0;;5;;;;AT+CPIN=7782;;OK\n</pre>\n<p>What does this command mean?\nIt tells ATtila to send AT+CPIN? and that we expect to find \"READY\" string in the response. If READY is found in the response it will proceed with the next command, but what happens for example if the device answers with \u201c+CPIN: SIM PIN\u201d? The ATSession will set as next command its doppelganger, which is AT+CPIN=7782, which will be executed as the next command.</p>\n<h4>Collectables</h4>\n<p>The last, but not least important parameter you can set in a command is collectables.\nCollectables are values that you can collect from a command response and transform into a <strong>session value</strong> (we\u2019ll talk about session values in the next chapter).\nImagine for example you want to collect the current signal quality and store it into a variable you want for example to save on Redis, you can do it just by specifying what you\u2019re looking for and the session value name and the job is done: ATila will do the job for you!</p>\n<pre>AT+CSQ;;+CSQ;;0;;5;;[\"AT+CSQ=?{rssi},\",\"AT+CSQ=${rssi},?{ber}\"]\n</pre>\n<p>This command has two collectables, which are the rssi and the Ber. We know that AT+CSQ, in case of a positive response (+CSQ:...), will return the <strong>rssi and the ber</strong> after \u201cAT+CSQ=\u201d separated by a comma. Imagine that we want to get both. The first value we want is located after \u201cAT+CSQ=\u201d and terminates with the ',' comma before the ber. So we tell ATtila to get a value between these two strings and to store it into a session value called \u201crssi\u201d. The other value will be located after the other part of the string; we can as you can see, reuse the rssi value in the second collectable (since rssi is already set).\nThe syntax which describes the start of a collectable is <strong>?{SESSION_KEY}</strong>.</p>\n<p>This was a simple case, where we knew the value where between 'AT+CSQ=...,' and after 'AT+CSQ=rssi,...'. But sometimes we have to get a value which hasn't anything around. An example of this case is AT+CGSN, which returns the IMEI. The IMEI is returned on a line, with nothing around:</p>\n<pre>AT+CGSN\n123456789012345\nOK\n</pre>\n<p>How can we get this value using collectables? Well, we can, but making a collectable a little more bit complex. We need to use a key regex:</p>\n<pre>AT+CGSN;;OK;;;;;;[\"?{IMEI::^[0-9]{15}$}\"]\n</pre>\n<p>This means we're looking for a value between nothing, but which has to respect the regex we provided which is <code>^[0-9]{15}$</code>. If a number of 15 digits is found in the response, this value will be stored into the session storage into a key named \"IMEI\".\nThe separator between the <strong>key name</strong> and the <strong>key regex</strong> is <code>::</code>\nThis mechanism can also be used to solve ambiguity in the response to get the value that we really want.</p>\n<p>For example we can make a more severe check on the CSQ using:</p>\n<pre>AT+CSQ;;OK;;;;;;[\"AT+CSQ=?{rssi::[0-9]{1,2}},\",\"AT+CSQ=${rssi},?{ber::[0-9]{1,2}}\"]\n</pre>\n<h4>Session Values</h4>\n<p>We\u2019ve seen that session values are values we can store using collectables and also setting environment variables and through Environment Setup Keywords, but we\u2019ll see that in the next chapter.\nA session value <strong>is just a key associated to a value</strong>, stored in the <strong>session storage</strong>. The session storage is a dictionary made up of all the session values, it lives only for the current command set, when a new session is instanced, the session storage is empty again.\n<em>It\u2019s not that complicated.</em></p>\n<p>We can rethink the previous example of CPIN using session values.\nThe script which set the SIM PIN only if locked, could be a part of an image installed on plenty of devices, but we can\u2019t have a different script for each device and using a script which replace runtime the text with the configured PIN is not such a good way to do things.\nHere is where the power of session values comes in help!\nThe SIM pin could be for instance, written example in a configuration file and we want to set it as a session value.\nIf before the execution of our script, we execute \u201cexport SIM_PIN=7782\u201d and then we execute this row in ATila using GETENV (we'll see what GETENV is in the next chapter) somewhere in the script before its execution.</p>\n<pre>GETENV SIM_PIN\nAT+CPIN;;READY;;0;;5;;;;AT+CPIN=${SIM_PIN};;OK\n</pre>\n<p>SIM_PIN will be replaced by 7782.</p>\n<p>But as we seen in the previous chapter, Session values can also be used to get collectables (if we already know a value that will be for sure in the response).</p>\n<h3>Environment Setup Keywords</h3>\n<p>As said before, ATScripts are not made only up of commands, but also of another thing called <strong>Environment Setup Keywords (ESKs)</strong>.\nLet\u2019s start from talking briefly about how ATtila works. ATtila has two main components: the <strong>AT Runtime Environment (ATRE)</strong> and the <strong>ATSession</strong>. The AT Runtime Environment instances a session and executes it following its commands, when the session execution ends, a new session can be instanced and the previous one gets destroyed, while the runtime environment persists. While <strong>commands describe the ATSession execution path</strong>, the <strong>ESKs describe the setup for the AT Runtime Environment</strong>, not only at the initial setup, but also at any time during runtime. ESKs can also be used to invoke the ATRE to execute some commands as we'll see..\nSo, to summarize, <strong>ESKs are commands you can put (but are not mandatory) in your scripts and tell the Runtime Environment how to configure its components or extra instructions to be executed</strong>.\nLet\u2019s see then which ESKs are supported.</p>\n<table>\n<thead>\n<tr>\n<th>ESK</th>\n<th>Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DEVICE</td>\n<td>String</td>\n<td>Indicates the target device used to communicate (e.g. /dev/ttyUSB0)</td>\n</tr>\n<tr>\n<td>BAUDRATE</td>\n<td>Int</td>\n<td>Describes the baud rate used to communicate (e.g. 9600)</td>\n</tr>\n<tr>\n<td>TIMEOUT</td>\n<td>Int</td>\n<td>Describes the default command timeout (e.g. 5)</td>\n</tr>\n<tr>\n<td>BREAK</td>\n<td>\"LF\" / \"CRLF\" / \"CR\" / \"NONE\"</td>\n<td>Describes the line break used for commands between LF and CRLF</td>\n</tr>\n<tr>\n<td>AOF</td>\n<td>True / False</td>\n<td>Abort on failure: describes whether the runtime environment shut abort on command failure</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>String=String</td>\n<td>Tells ATRE to set a session value with a certain key and value: (e.g. SET SIM=7789)</td>\n</tr>\n<tr>\n<td>GETENV</td>\n<td>String</td>\n<td>Tells ATRE to store in session storage a certain environmental variable. (e.g. GETENV SIM_PIN)</td>\n</tr>\n<tr>\n<td>PRINT</td>\n<td>String</td>\n<td>Tells ATRE to print to stdout a string (e.g. PRINT SIM PIN: ${SIM_PIN})</td>\n</tr>\n<tr>\n<td>EXEC</td>\n<td>String</td>\n<td>Tells ATRE to execute a shell process (e.g. EXEC \u201cexport SIM_PIN=`cat /tmp/config.json</td>\n</tr></tbody></table>\n<h3>Let's put it all together</h3>\n<p>Now that we know everything about ATScripts, let's build a Modem dial script :D</p>\n<pre>#Set up communication parameters\nDEVICE /dev/ttyUSB0\nBAUDRATE 115200\nTIMEOUT 10\nBREAK CRLF\n#Abort on failure\nAOF True\n#Get the SIM PIN and the APN\nGETENV SIM_PIN\nGETENV APN\n#Let's start with modem setup\nPRINT Configuring modem parameters\n#+++ doesn't want a break\nBREAK NONE\n+++\nBREAK CRLF\nATH0;;;;5000\nATE0;;OK\nATZ;;OK\nATE0;;OK\n#I'm going to verify signal etc, we don't need to aof\nAOF False\nAT+CSQ;;OK;;;;;;[\"AT+CSQ=?{rssi::[0-9]{1,2}},\",\"AT+CSQ=${rssi},?{ber::[0-9]{1,2}}\"]\nAT+CGSN;;OK;;;;;;[\"?{IMEI::^[0-9]{15}$}\"]\nAT+CREG?;;OK\n#Now I'm configuring modem for dialup, so AOF it's important\nAOF True\nAT+CPIN?;;READY;;0;;5;;;;AT+CPIN=${SIM_PIN};;OK\nAT+CGDCONT=1,\"IP\",\"${APN}\";;OK;;1000\n#Dial APN\nPRINT Dialing your ISP...\nAT+CGDATA=\"PPP\",1;;CONNECT\n</pre>\n<h2>Known Issues</h2>\n<p>None, as far as I know at least.</p>\n<h2>Tests Units</h2>\n<p>ATtila is provided with tests units, which can be found under tests/ directory.\nThese tests units tests the three most important parts of ATtila which are the ATScriptParser, the ATSession and the ATRuntimeEnvironment.\nTo launch test unit just type:</p>\n<pre>nosetests -v --with-coverage --cover-tests --cover-package<span class=\"o\">=</span>attila --nocapture tests/\n</pre>\n<h2>Changelog</h2>\n<h3>ATtila 1.1.6 (25/03/2020)</h3>\n<ul>\n<li>Fixed response collection</li>\n</ul>\n<h3>ATtila 1.1.5 (09/03/2020)</h3>\n<ul>\n<li>Fixed serial communication which didn't wait for all input\n<ul>\n<li>Serial is now slower, especially for lower baudrate</li>\n</ul>\n</li>\n</ul>\n<h3>ATtila 1.1.4 (05/03/2020)</h3>\n<ul>\n<li>Fixed slow serial read when working with low baud rates</li>\n<li>Added <code>rtscts=True, dsrdtr=True</code> options to serial open</li>\n<li>Serial Write is no more blocking</li>\n<li>Fixed doppelganger and collectables</li>\n</ul>\n<h3>ATtila 1.1.3 (07/12/2019)</h3>\n<ul>\n<li>Fixed a typo in ATRE for ESK EXEC (commit ref: 8506523)</li>\n</ul>\n<h3>ATtila 1.1.2 (29/10/2019)</h3>\n<ul>\n<li>Fixed broken windows installation</li>\n</ul>\n<h3>ATtila 1.1.1 (26/10/2019)</h3>\n<ul>\n<li>Didn't deploy virtual.</li>\n</ul>\n<h3>ATtila 1.1.0 (26/10/2019)</h3>\n<ul>\n<li>Fixed device not None after serial close</li>\n<li>Fixed ATCommand response getter</li>\n<li>Added SyntaxError exception handler in ATScriptParser</li>\n<li>Fixed value getter in ESK</li>\n<li>Added Virtual Serial device</li>\n<li>Test improvements</li>\n</ul>\n<h3>ATtila 1.0.4 (13/10/2019)</h3>\n<ul>\n<li>Added codecov</li>\n<li>Added missing CR value in BREAK ESK</li>\n<li>Added ESK and ATRE tests</li>\n</ul>\n<h3>ATtila 1.0.3 (12/10/2019)</h3>\n<ul>\n<li>Fixed help in main</li>\n<li>Added Travis</li>\n</ul>\n<h2>Branches</h2>\n<ul>\n<li>master: stable only</li>\n<li>dev: main development branch</li>\n<li>other features</li>\n</ul>\n<hr>\n<h2>License</h2>\n<pre>MIT License\n\nCopyright (c) 2019 Christian Visintin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</pre>\n\n          </div>"}, "last_serial": 6880638, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "feb59bee4348714d97af65149836e49a", "sha256": "abc5e4973d4cc456817a044335b03337b7cc6fe4f2bf628de429143e92511e3b"}, "downloads": -1, "filename": "attila-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "feb59bee4348714d97af65149836e49a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.4", "size": 34832, "upload_time": "2019-10-07T20:27:45", "upload_time_iso_8601": "2019-10-07T20:27:45.130513Z", "url": "https://files.pythonhosted.org/packages/35/21/e3f71c00fc64d6eff0a477cf99ad0c907de2673ceaf90693b09398184a0a/attila-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4ca9b79b6e9a1f4a21317890d3e37ecf", "sha256": "7003342bfb39f81092e121bb1c8433ce05777d7d1e8075bb9eb5bfe4ff2576dd"}, "downloads": -1, "filename": "attila-1.0.0.tar.gz", "has_sig": false, "md5_digest": "4ca9b79b6e9a1f4a21317890d3e37ecf", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 19383, "upload_time": "2019-10-07T20:27:47", "upload_time_iso_8601": "2019-10-07T20:27:47.962925Z", "url": "https://files.pythonhosted.org/packages/6d/6d/d21de2248730ac438dda64f1e121a3681c4a3304ee53ab2eb3e3b605ae6d/attila-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "9a0ef63186b0cdee23338b55895512db", "sha256": "0168a0b29b3e295225935dd3906b2dc4c6ec3fe339664d21c9a46556353f48f7"}, "downloads": -1, "filename": "attila-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "9a0ef63186b0cdee23338b55895512db", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.4", "size": 34533, "upload_time": "2019-10-07T20:29:27", "upload_time_iso_8601": "2019-10-07T20:29:27.879890Z", "url": "https://files.pythonhosted.org/packages/50/4a/699a92dcd98cc931f433d281cd3e260826e70f96e46c730fc89a44f7b5a7/attila-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fc0e47265be9e33f5b23cb3201aab1e1", "sha256": "d5a91f623826d3183f8700cc6c478b57ee247fbb2f54e00fe502f9654ad0833b"}, "downloads": -1, "filename": "attila-1.0.1.tar.gz", "has_sig": false, "md5_digest": "fc0e47265be9e33f5b23cb3201aab1e1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 19239, "upload_time": "2019-10-07T20:29:29", "upload_time_iso_8601": "2019-10-07T20:29:29.727702Z", "url": "https://files.pythonhosted.org/packages/43/55/279f8c1c1f069baee73ec6c56a1d67e83a96c668dc6153c2cf6ad419a355/attila-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "0d4719b39f93bf6a21f0e21feafc8843", "sha256": "7fa3f166d98a2abecc53dc16469889ead4da7cb9496a8bfb96a6b6ae6fea941b"}, "downloads": -1, "filename": "attila-1.0.2.tar.gz", "has_sig": false, "md5_digest": "0d4719b39f93bf6a21f0e21feafc8843", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 26107, "upload_time": "2019-10-12T16:33:11", "upload_time_iso_8601": "2019-10-12T16:33:11.355111Z", "url": "https://files.pythonhosted.org/packages/1b/71/985e74b6f9f48c83a85a39adab0335c9f8379363b72cfc529e46f4d89133/attila-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "6309adc44aa1a3c8b288db1ef6a6dfbe", "sha256": "eb8645ac1c4b4337df751847d5787f8e0e78a1100bf477d52f5211e62253ad57"}, "downloads": -1, "filename": "attila-1.0.3.tar.gz", "has_sig": false, "md5_digest": "6309adc44aa1a3c8b288db1ef6a6dfbe", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 27622, "upload_time": "2019-10-12T16:54:09", "upload_time_iso_8601": "2019-10-12T16:54:09.744941Z", "url": "https://files.pythonhosted.org/packages/81/1d/9dee123ac7dce96bd94363baeec5ef9ede4a2dee4f1412afa6fecf6847a9/attila-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "43820f1e2547d96cd8d521b802c27687", "sha256": "4148c6de12b3b3e70039d0554a8377e5ab3b8e3983b692fbc6aaab3583a62ae0"}, "downloads": -1, "filename": "attila-1.0.4.tar.gz", "has_sig": false, "md5_digest": "43820f1e2547d96cd8d521b802c27687", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 27685, "upload_time": "2019-10-13T08:55:23", "upload_time_iso_8601": "2019-10-13T08:55:23.882790Z", "url": "https://files.pythonhosted.org/packages/2c/53/dfb9930b1020a1fc0b2b0d0e7d3ccce2ffb9c8228862594a136a167b2827/attila-1.0.4.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "7bbccf335f836e0217e9cecad46816f7", "sha256": "0dd21301176dc23a6f814cf455fe3e8a8f666b8182a670528fd88fc56b35bbce"}, "downloads": -1, "filename": "attila-1.1.0.tar.gz", "has_sig": false, "md5_digest": "7bbccf335f836e0217e9cecad46816f7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 28621, "upload_time": "2019-10-26T14:40:30", "upload_time_iso_8601": "2019-10-26T14:40:30.511169Z", "url": "https://files.pythonhosted.org/packages/18/7c/1356a4889f9559e5745adc2d78442483f46180dbea5c0c857907768a01f5/attila-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "fafb0047a87484538f1fb51cb18ea823", "sha256": "9ec2a8ee92e886e15526976d805e985cc9af37d01e5f1cbf6cbac1789f53532a"}, "downloads": -1, "filename": "attila-1.1.1.tar.gz", "has_sig": false, "md5_digest": "fafb0047a87484538f1fb51cb18ea823", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 30680, "upload_time": "2019-10-26T14:52:11", "upload_time_iso_8601": "2019-10-26T14:52:11.152587Z", "url": "https://files.pythonhosted.org/packages/e6/e4/b39bba3514d0c9a8f90e109343e52658dcedd84c4e366b9c6de8a278a031/attila-1.1.1.tar.gz", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "e609535e145e2216e69be9ccd1a85ae3", "sha256": "084a00cbcc6a75f4b95aebd2339ceb05b95d6f342240e140d94065097ae97d17"}, "downloads": -1, "filename": "attila-1.1.2.tar.gz", "has_sig": false, "md5_digest": "e609535e145e2216e69be9ccd1a85ae3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 30408, "upload_time": "2019-10-29T09:27:39", "upload_time_iso_8601": "2019-10-29T09:27:39.965654Z", "url": "https://files.pythonhosted.org/packages/66/84/e7f7ebe8bea881b801aa12a51a555b65ff81df9efe8902870db80da5bded/attila-1.1.2.tar.gz", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "d0b3cf93e9a13b974f176df378cc1dde", "sha256": "bf9accb6f44324aa11b5db148d41a2430c361eb277fc0a805454499491f77c61"}, "downloads": -1, "filename": "attila-1.1.3.tar.gz", "has_sig": false, "md5_digest": "d0b3cf93e9a13b974f176df378cc1dde", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 30499, "upload_time": "2019-12-07T16:34:21", "upload_time_iso_8601": "2019-12-07T16:34:21.279764Z", "url": "https://files.pythonhosted.org/packages/38/d1/d672e93dee5b7d0edbfd5e6d8814a0848b4ca761e9dd445a18839b168cda/attila-1.1.3.tar.gz", "yanked": false}], "1.1.4": [{"comment_text": "", "digests": {"md5": "dfff42de0f8777f06f94853fc8884aee", "sha256": "974858b935c1a7ea85aa612b0fb94c2d53a4483c5a9d3552065dd79762894923"}, "downloads": -1, "filename": "attila-1.1.4.tar.gz", "has_sig": false, "md5_digest": "dfff42de0f8777f06f94853fc8884aee", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 31138, "upload_time": "2020-03-05T20:08:49", "upload_time_iso_8601": "2020-03-05T20:08:49.657449Z", "url": "https://files.pythonhosted.org/packages/2b/13/c7e2fa1953dbfd46b67dd3fc37f8484dabc0b5cc5cfa1b30dbaf5594af97/attila-1.1.4.tar.gz", "yanked": false}], "1.1.5": [{"comment_text": "", "digests": {"md5": "6d54f89eb7035fcf9861ae3387d16507", "sha256": "e48e83be68af10bdb1b743f741b063d8f7fb666aa8c031deb314d6919a9f7eac"}, "downloads": -1, "filename": "attila-1.1.5.tar.gz", "has_sig": false, "md5_digest": "6d54f89eb7035fcf9861ae3387d16507", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 31570, "upload_time": "2020-03-09T20:06:28", "upload_time_iso_8601": "2020-03-09T20:06:28.742148Z", "url": "https://files.pythonhosted.org/packages/7c/15/ca7e6a2bd55c4f9b436291ea43fa986daf703f6011c379ddb0dc3d27aabb/attila-1.1.5.tar.gz", "yanked": false}], "1.1.6": [{"comment_text": "", "digests": {"md5": "f295f0b1d7653bba81b27d4bdb53cd89", "sha256": "1b9b48aea37f4aff305d0055ae609a39c5f8c79bea1df6a433c7edab7e1d3546"}, "downloads": -1, "filename": "attila-1.1.6.tar.gz", "has_sig": false, "md5_digest": "f295f0b1d7653bba81b27d4bdb53cd89", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 24553, "upload_time": "2020-03-25T13:41:03", "upload_time_iso_8601": "2020-03-25T13:41:03.949579Z", "url": "https://files.pythonhosted.org/packages/63/a2/e1d7358e10acee9a1b178b095719413c110c4f9b588d356d15bc52aab521/attila-1.1.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f295f0b1d7653bba81b27d4bdb53cd89", "sha256": "1b9b48aea37f4aff305d0055ae609a39c5f8c79bea1df6a433c7edab7e1d3546"}, "downloads": -1, "filename": "attila-1.1.6.tar.gz", "has_sig": false, "md5_digest": "f295f0b1d7653bba81b27d4bdb53cd89", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 24553, "upload_time": "2020-03-25T13:41:03", "upload_time_iso_8601": "2020-03-25T13:41:03.949579Z", "url": "https://files.pythonhosted.org/packages/63/a2/e1d7358e10acee9a1b178b095719413c110c4f9b588d356d15bc52aab521/attila-1.1.6.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:30 2020"}