{"info": {"author": "Thomas Roehl", "author_email": "thomas.roehl@googlemail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU General Public License v2 (GPLv2)", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Scientific/Engineering", "Topic :: Software Development", "Topic :: Utilities"], "description": "pylikwid\n========\n\nPython interface for the C API of LIKWID\n(https://github.com/RRZE-HPC/likwid)\n\n.. image:: https://travis-ci.org/RRZE-HPC/pylikwid.svg?branch=master\n    :target: https://travis-ci.org/RRZE-HPC/pylikwid?branch=master\n\nInstallation\n============\n\nI added a setup.py script for the installation. It builds the C module\nand copies it to the proper destination.\n\n::\n\n    $ git clone https://github.com/RRZE-HPC/pylikwid.git\n    $ cd pylikwid\n    # Build C interface\n    $ python setup.py build_ext -I <include path for likwid> -L <library path for likwid> -R <library path for likwid>\n    # Install module to the proper location\n    $ python setup.py install (--prefix=<where to install>)\n    # Testing\n    $ python -c \"import pylikwid\"\n    $ ./testlib.py\n\nFunctions\n=========\n\nAfter ``import pylikwid`` you can call the following functions:\n\nMarker API\n----------\n\n-  ``pylikwid.markerinit()``: Initialize the Marker API of the LIKWID library.\n   Must be called previous to all other functions.\n-  ``pylikwid.markerthreadinit()``: Add the current thread to the Marker API.\n   Since Python is commonly single-threaded simply call it directly\n   after ``pylikwid.markerinit()``\n-  ``rr = pylikwid.registerregion(regiontag)``: Register a region to the\n   Marker API. This is an optional function to reduce the overhead of\n   region registration at ``pylikwid.markerstartregion``. If you don't call\n   ``pylikwid.registerregion(regiontag)``, the registration is done at\n   ``pylikwid.markerstartregion(regiontag)``. On success, 0 is return. If you\n   havn't called ``pylikwid.markerinit()``, a negative number is returned.\n-  ``err = pylikwid.markerstartregion(regiontag)``: Start measurements under\n   the name ``regiontag``. On success, 0 is return. If you havn't called\n   ``pylikwid.markerinit()``, a negative number is returned.\n-  ``err = pylikwid.markerstopregion(regiontag)``: Stop measurements under the\n   name ``regiontag`` again. On success, 0 is return. If you havn't\n   called ``pylikwid.markerinit()``, a negative number is returned.\n-  ``num_events, events[], time, count = pylikwid.markergetregion(regiontag)``:\n   Get the intermediate results of the region identified by\n   ``regiontag``. On success, it returns the number of events in the\n   current group, a list with all the aggregated event results, the\n   measurement time for the region and the number of calls.\n-  ``pylikwid.nextgroup()``: Switch to the next event set in a\n   round-robin fashion. If you have set only one event set on the\n   command line, this function performs no operation.\n-  ``pylikwid.markerreset(regiontag)``: Reset the values stored using the region\n   name ``regiontag``. On success, 0 is returned.\n-  ``pylikwid.markerclose()``: Close the connection to the LIKWID Marker API\n   and write out measurement data to file. This file will be evaluated\n   by ``likwid-perfctr``.\n-  ``pylikwid.getprocessorid()``: Returns the ID of the currently\n   executing CPU\n-  ``pylikwid.pinprocess(cpuid)``: Pins the current process to the CPU\n   given as ``cpuid``.\n-  ``pylikwid.pinthread(cpuid)``: Pins the current thread to the CPU\n   given as ``cpuid``.\n\nTopology\n--------\n\n-  ``pylikwid.inittopology()``: Initialize the topology module (reads in\n   system topology)\n-  ``infodict = pylikwid.getcpuinfo()``: Return a dict with general\n   information about the system (CPU model, CPU family, ...)\n\n   -  ``osname``: Name of the CPU retrieved from the CPUID leafs\n   -  ``name``: Name of the micro architecture\n   -  ``short_name``: Short name of the micro architecture\n   -  ``family``: ID of the CPU family\n   -  ``model``: Vendor-specific model number of the CPU\n   -  ``stepping``: Stepping (Revision) of the CPU\n   -  ``perf_version``: Version number of the hardware performance\n      monitoring capabilities\n   -  ``perf_num_ctr``: Amount of general-purpose counter registers per\n      hardware thread\n   -  ``perf_num_fixed_ctr``: Amount of fixed-purpose counter registers\n      per hardware thread\n   -  ``perf_width_ctr``: Bit length of the counter registers\n   -  ``clock``: CPU clock (only unequal to 0 if timer module is\n      initialized)\n   -  ``turbo``: Is turbo mode supported?\n   -  ``isIntel``: Is it an Intel CPU?\n   -  ``supportUncore``: Does the system have performance monitoring\n      counters in the Uncore?\n   -  ``features``: String with performance relevant CPU features (AVX,\n      SSE, ...)\n   -  ``featureFlags``: Bitmask for all available CPU features\n\n-  ``topodict = pylikwid.getcputopology()``: Return a dict with the\n   topology of the system. Here is a list of fields in the dict:\n\n   -  ``numSockets``: Number of CPU sockets\n   -  ``numHWThreads``: Number of hardware threads (physical +\n      hyperthreading cores)\n   -  ``activeHWThreads``: Number of active/usable hardware threads\n   -  ``numCoresPerSocket``: Amount of hardware threads per CPU socket\n   -  ``numThreadsPerCore``: Amount of hardware threads assembled in\n      every physical CPU core\n   -  ``numCacheLevels``: Amount of levels in cacheing hierarchy\n   -  ``cacheLevels``: Dict with information about the cache levels,\n      keys are the levels (1, 2, 3,...)\n\n      -  ``level``: Level of the cache in the hierarchy\n      -  ``lineSize``: Size of a cache line\n      -  ``sets``: Amount of sets\n      -  ``inclusive``: Is the cache inclusive or exclusive?\\`\n      -  ``threads``: Amount of threads attached to the cache\n      -  ``associativity``: Associativity of the cache\n      -  ``type``: data (= data cache), unified = (data + instruction\n         cache)\n      -  ``size``: Size of the cache in bytes\n\n   -  ``threadPool``: Dict with information about the hardware threads.\n      Keys are the os-generated ID of the hardware thread\n\n      -  ``coreId``: ID of the corresponding physical core\n      -  ``apicId``: ID set by the operating system\n      -  ``threadId``: ID of the hardware thread in the physical core\n      -  ``packageId``: ID of the CPU socket hosting the hardware thread\n\n-  ``pylikwid.printsupportedcpus()``: Prints all supported micro\n   architecture names to stdout\n-  ``pylikwid.finalizetopology()``: Delete all information in the\n   topology module\n\nNUMA\n----\n\n-  ``numadict = pylikwid.initnuma()``: Initialize the NUMA module and\n   return the gathered values\n\n   -  ``numberOfNodes``: Amount of NUMA nodes in the system\n   -  ``nodes``: Dict holding the information about the NUMA domains.\n      Keys are the NUMA domain IDs\n\n      -  ``id``: ID of the NUMA domain (should be equal to dict key)\n      -  ``numberOfProcessors``: Number of hardware threads attached to\n         the NUMA domain\n      -  ``processors``: List of all CPU IDs attached to the NUMA domain\n      -  ``freeMemory``: Amount of free memory in the NUMA domain (in\n         Kbytes)\n      -  ``totalMemory``: Amount of total memory in the NUMA domain (in\n         Kbytes)\n      -  ``numberOfDistances``: How many distances to self/other NUMA\n         domains\n      -  ``distances``: List with distances, NUMA domain IDs are the\n         destination indexes in the list\n\n-  ``pylikwid.finalizenuma()``: Delete all information in the NUMA\n   module\n\nAffinity\n--------\n\n-  ``affdict = pylikwid.initaffinity()``: Initialize the affinity domain\n   module and return the gathered values\n\n   -  ``numberOfAffinityDomains``: Amount of affinity domains\n   -  ``numberOfSocketDomains``: Amount of CPU socket related affinity\n      domains\n   -  ``numberOfNumaDomains``: Amount of NUMA related affinity domains\n   -  ``numberOfCacheDomains``: Amount of last level cache related\n      affinity domains\n   -  ``numberOfProcessorsPerSocket``: Amount of hardware threads per\n      CPU socket\n   -  ``numberOfCoresPerCache``: Amount of physical CPU cores per last\n      level cache\n   -  ``numberOfProcessorsPerCache``: Amount of hardware threads per\n      last level cache\n   -  ``domains``: Dict holding the information about the affinity\n      domains\n\n      -  ``tag``: Name of the affinity domain (N = node, SX = socket X,\n         CY = cache Y, MZ = memory domain Z)\n      -  ``numberOfProcessors``: Amount of hardware threads in the\n         domain\n      -  ``numberOfCores``: Amount of physical CPU cores in the domain\n      -  ``processorList``: List holding the CPU IDs in the domain\n\n-  ``pylikwid.finalizeaffinity()``: Delete all information in the\n   affinity domain module\n-  ``pylikwid.cpustr_to_cpulist()``: Transform a valid cpu string in\n   LIKWID syntax into a list of CPU IDs\n\nTimer\n-----\n\n-  ``pylikwid.getcpuclock()``: Return the CPU clock\n-  ``t_start = pylikwid.startclock()``: Start the clock and return the\n   current timestamp\n-  ``t_end = pylikwid.stopclock()``: Stop the clock and return the\n   current timestamp\n-  ``t = pylikwid.getclock(t_start, t_end)``: Return the time in seconds\n   between ``t_start`` and ``t_end``\n-  ``c = pylikwid.getclockcycles(t_start, t_end)``: Return the amount of\n   CPU cycles between ``t_start`` and ``t_end``\n\nTemperature\n-----------\n\n-  ``pylikwid.inittemp(cpu)``: Initialize the temperature module for CPU\n   ``cpu``\n-  ``pylikwid.readtemp(cpu)``: Read the current temperature of CPU\n   ``cpu``\n\nEnergy\n------\n\n-  ``pinfo = pylikwid.getpowerinfo()``: Initializes the energy module\n   and returns gathered information. If it returns ``None``, there is no\n   energy support\n\n   -  ``minFrequency``: Minimal possible frequency of a CPU core\n   -  ``baseFrequency``: Base frequency of a CPU core\n   -  ``hasRAPL``: Are energy reading supported?\n   -  ``timeUnit``: Time unit\n   -  ``powerUnit``: Power unit\n   -  ``domains``: Dict holding the information about the energy\n      domains. Keys are PKG, PP0, PP1, DRAM\n\n      -  ``ID``: ID of the energy domain\n      -  ``energyUnit``: Unit to derive raw register counts to uJ\n      -  ``supportInfo``: Is the information register available?\n      -  ``tdp``: TDP of the domain (only if supportInfo == True)\n      -  ``minPower``: Minimal power consumption by the domain (only if\n         supportInfo == True)\n      -  ``maxPower``: Maximal power consumption by the domain (only if\n         supportInfo == True)\n      -  ``maxTimeWindow``: Maximal time window between updates of the\n         energy registers\n      -  ``supportStatus``: Are energy readings from the domain are\n         possible?\n      -  ``supportPerf``: Is power capping etc. available?\n      -  ``supportPolicy``: Can we set a power policy for the domain?\n\n-  ``e_start = pylikwid.startpower(cpu, domainid)``: Return the start\n   value for a cpu for the domain with ``domainid``. The ``domainid``\n   can be found in ``pinfo[\"domains\"][domainname][\"ID\"]``\n-  ``e_stop = pylikwid.stoppower(cpu, domainid)``: Return the stop value\n   for a cpu for the domain with ``domainid``. The ``domainid`` can be\n   found in ``pinfo[\"domains\"][domainname][\"ID\"]``\n-  ``e = pylikwid.getpower(e_start, e_stop, domainid)``: Calculate the\n   uJ from the values retrieved by ``startpower`` and ``stoppower``.\n\nConfiguration\n-------------\n\n-  ``pylikwid.initconfiguration()``: Read in config file from different\n   places. Default is ``/etc/likwid.cfg``\n-  ``config = pylikwid.getconfiguration()``: Get the dict with the\n   configuration options\n\n   -  ``configFileName``: Path to the config file\n   -  ``topologyCfgFileName``: If a topology file was created with\n      ``likwid-genTopoCfg`` and found by ``initconfiguration()``\n   -  ``daemonPath``: Path to the access daemon executable\n   -  ``groupPath``: Path to the base directory with the performance\n      group files\n   -  ``daemonMode``: Configured access mode (0=direct, 1=accessDaemon)\n   -  ``maxNumThreads``: Maximal amount of hardware threads that can be\n      handled by LIKWID\n   -  ``maxNumNodes``: Maximal amount of CPU sockets that can be handled\n      by LIKWID\n\n-  ``pylikwid.destroyconfiguration()``: Destroy all information about\n   the configuration\n\nAccess module\n-------------\n\n-  ``pylikwid.hpmmode(mode)``: Set access mode. For x86 there are two\n   modes:\n\n   -  ``mode = 0``: Access the MSR and PCI devices directly. May require\n      root access\n   -  ``mode = 1``: Access the MSR and PCI devices through access daemon\n      instances\n\n-  ``pylikwid.hpminit()``: Initialize the access functions according to\n   the access mode\n-  ``pylikwid.hpmaddthread(cpu)``: Add CPU ``cpu`` to the access layer\n   (opens devices files or connection to an access daemon)\n-  ``pylikwid.hpmfinalize()``: Unregister all CPUs from the access layer\n   and close files/connections\n\nPerformance Monitoring\n----------------------\n\n-  ``pylikwid.init(cpus)``: Initialize the perfmon module for the CPUs\n   given in list ``cpus``\n-  ``pylikwid.getnumberofthreads()``: Return the number of threads\n   initialized in the perfmon module\n-  ``pylikwid.getnumberofgroups()``: Return the number of groups\n   currently registered in the perfmon module\n-  ``pylikwid.getgroups()``: Return a list of all available groups. Each\n   list entry is a dict:\n\n   -  ``Name``: Name of the performance group\n   -  ``Short``: Short information about the performance group\n   -  ``Long``: Long description of the performance group\n\n-  ``gid = pylikwid.addeventset(estr)``: Add a performance group or a\n   custom event set to the perfmon module. The ``gid`` is required to\n   specify the event set later\n-  ``pylikwid.getnameofgroup(gid)``: Return the name of the group\n   identified by ``gid``. If it is a custom event set, the name is set\n   to ``Custom``\n-  ``pylikwid.getshortinfoofgroup(gid)``: Return the short information\n   about a performance group\n-  ``pylikwid.getlonginfoofgroup(gid)``: Return the description of a\n   performance group\n-  ``pylikwid.getnumberofevents(gid)``: Return the amount of events in\n   the group\n-  ``pylikwid.getnumberofmetrics(gid)``: Return the amount of derived\n   metrics in the group. Always 0 for custom event sets.\n-  ``pylikwid.getnameofevent(gid, eidx)``: Return the name of the event\n   identified by ``gid`` and the index in the list of events\n-  ``pylikwid.getnameofcounter(gid, eidx)``: Return the name of the\n   counter register identified by ``gid`` and the index in the list of\n   events\n-  ``pylikwid.getnameofmetric(gid, midx)``: Return the name of a derived\n   metric identified by ``gid`` and the index in the list of metrics\n-  ``pylikwid.setup(gid)``: Program the counter registers to measure all\n   events in group ``gid``\n-  ``pylikwid.start()``: Start the counter registers\n-  ``pylikwid.stop()``: Stop the counter registers\n-  ``pylikwid.read()``: Read the counter registers (stop->read->start)\n-  ``pylikwid.switch(gid)``: Switch to group ``gid``\n   (stop->setup(gid)->start)\n-  ``pylikwid.getidofactivegroup()`` Return the ``gid`` of the currently\n   configured group\n-  ``pylikwid.getresult(gid, eidx, tidx)``: Return the raw counter\n   register result of all measurements identified by group ``gid`` and\n   the indices for event ``eidx`` and thread ``tidx``\n-  ``pylikwid.getlastresult(gid, eidx, tidx)``: Return the raw counter\n   register result of the last measurement cycle identified by group\n   ``gid`` and the indices for event ``eidx`` and thread ``tidx``\n-  ``pylikwid.getmetric(gid, midx, tidx)``: Return the derived metric\n   result of all measurements identified by group ``gid`` and the\n   indices for metric ``midx`` and thread ``tidx``\n-  ``pylikwid.getlastmetric(gid, midx, tidx)``: Return the derived\n   metric result of the last measurement cycle identified by group\n   ``gid`` and the indices for metric ``midx`` and thread ``tidx``\n-  ``pylikwid.gettimeofgroup(gid)``: Return the measurement time for\n   group identified by ``gid``\n-  ``pylikwid.finalize()``: Reset all used registers and delete internal\n   measurement results\n\nMarker API result file reader\n-----------------------------\n\n-  ``pylikwid.markerreadfile(filename)``: Reads in the result file of an\n   application run instrumented by the LIKWID Marker API\n-  ``pylikwid.markernumregions()``: Return the number of regions in an\n   application run\n-  ``pylikwid.markerregiontag(rid)``: Return the region tag for the\n   region identified by ``rid``\n-  ``pylikwid.markerregiongroup(rid)``: Return the group name for the\n   region identified by ``rid``\n-  ``pylikwid.markerregionevents(rid)``: Return the amount of events for\n   the region identified by ``rid``\n-  ``pylikwid.markerregionthreads(rid)``: Return the amount of threads\n   that executed the region identified by ``rid``\n-  ``pylikwid.markerregiontime(rid, tidx)``: Return the accumulated\n   measurement time for the region identified by ``rid`` and the thread\n   index ``tidx``\n-  ``pylikwid.markerregioncount(rid, tidx)``: Return the call count for\n   the region identified by ``rid`` and the thread index ``tidx``\n-  ``pylikwid.markerregionresult(rid, eidx, tidx)``: Return the call\n   count for the region identified by ``rid``, the event index ``eidx``\n   and the thread index ``tidx``\n-  ``pylikwid.markerregionmetric(rid, midx, tidx)``: Return the call\n   count for the region identified by ``rid``, the metric index ``midx``\n   and the thread index ``tidx``\n\nGPU Topology (if LIKWID is built with Nvidia interface)\n-------------------------------------------------------\n\n-  ``pylikwid.initgputopology()``: Initialize the topology module (reads in\n   system topology)\n\n-  ``topolist = pylikwid.getgputopology()``: Return a list with the\n   GPU topology of the system. Each GPU is represented by a dict. The entries in\n   the dicts are:\n\n   -  ``devid``: Device identifier for the GPU\n   -  ``numaNode``: The NUMA node identifier the GPU is attached at\n   -  ``name``: Name of the device\n   -  ``mem``: Memory capacity of the device\n   -  ``ccapMajor``: Major number of the compute capability\n   -  ``ccapMinor``: Minor number of the compute capability\n   -  ``maxThreadsDim[3]``: Maximum sizes of each dimension of a block\n   -  ``maxGridSize[3]``: Maximum sizes of each dimension of a grid\n   -  ``maxThreadsPerBlock``: Maximam number of thread per block\n   -  ``sharedMemPerBlock``: Total amount of shared memory available per block\n   -  ``totalConstantMemory``: Total amount of constant memory available on the device\n   -  ``simdWidth``: SIMD width of arithmetic units = warp size\n   -  ``memPitch``: Maximum pitch allowed by the memory copy functions that involve memory regions allocated through cuMemAllocPitch()\n   -  ``regsPerBlock``: Total number of registers available per block\n   -  ``clockRatekHz``: Clock frequency in kilohertz\n   -  ``textureAlign``: Alignment requirement\n   -  ``surfaceAlign``: Alignment requirement for surfaces\n   -  ``l2Size``: L2 cache in bytes. 0 if the device doesn't have L2 cache\n   -  ``memClockRatekHz``: Peak memory clock frequency in kilohertz\n   -  ``pciBus``: PCI bus identifier of the device\n   -  ``pciDev``: PCI device (also known as slot) identifier of the device\n   -  ``pciDom``: PCI domain identifier of the device\n   -  ``maxBlockRegs``: Maximum number of 32-bit registers available to a thread block\n   -  ``numMultiProcs``: Number of multiprocessors on the device\n   -  ``maxThreadPerMultiProc``: Maximum resident threads per multiprocessor\n   -  ``memBusWidth``: Global memory bus width in bits\n   -  ``unifiedAddrSpace``: 1 if the device shares a unified address space with the host, or 0 if not\n   -  ``ecc``: 1 if error correction is enabled on the device, 0 if error correction is disabled or not supported by the device\n   -  ``asyncEngines``: Number of asynchronous engines\n   -  ``mapHostMem``: 1 if the device can map host memory into the CUDA address space\n   -  ``integrated``: 1 if the device is an integrated (motherboard) GPU and 0 if it is a discrete (card) component\n\n-  ``pylikwid.finalizegputopology()``: Delete all information in the\n   topology module\n\n\nPerformance Monitoring for Nvidia GPUs (if LIKWID is built with Nvidia interface)\n---------------------------------------------------------------------------------\n\n-  ``pylikwid.nvinit(gpus)``: Initialize the nvmon module for the GPUs\n   given in list ``gpus``\n-  ``pylikwid.nvgetnumberofgpus()``: Return the number of GPUs\n   initialized in the nvmon module\n-  ``pylikwid.nvgetnumberofgroups()``: Return the number of groups\n   currently registered in the nvmon module\n-  ``pylikwid.nvgetgroups()``: Return a list of all available groups. Each\n   list entry is a dict:\n\n   -  ``Name``: Name of the performance group\n   -  ``Short``: Short information about the performance group\n   -  ``Long``: Long description of the performance group\n\n-  ``gid = pylikwid.nvaddeventset(estr)``: Add a performance group or a\n   custom event set to the perfmon module. The ``gid`` is required to\n   specify the event set later\n-  ``pylikwid.nvgetnameofgroup(gid)``: Return the name of the group\n   identified by ``gid``. If it is a custom event set, the name is set\n   to ``Custom``\n-  ``pylikwid.nvgetshortinfoofgroup(gid)``: Return the short information\n   about a performance group\n-  ``pylikwid.nvgetlonginfoofgroup(gid)``: Return the description of a\n   performance group\n-  ``pylikwid.nvgetnumberofevents(gid)``: Return the amount of events in\n   the group\n-  ``pylikwid.nvgetnumberofmetrics(gid)``: Return the amount of derived\n   metrics in the group. Always 0 for custom event sets.\n-  ``pylikwid.nvgetnameofevent(gid, eidx)``: Return the name of the event\n   identified by ``gid`` and the index in the list of events\n-  ``pylikwid.nvgetnameofcounter(gid, eidx)``: Return the name of the\n   counter register identified by ``gid`` and the index in the list of\n   events\n-  ``pylikwid.nvgetnameofmetric(gid, midx)``: Return the name of a derived\n   metric identified by ``gid`` and the index in the list of metrics\n-  ``pylikwid.nvsetup(gid)``: Program the counter registers to measure all\n   events in group ``gid``\n-  ``pylikwid.nvstart()``: Start the counter registers\n-  ``pylikwid.nvstop()``: Stop the counter registers\n-  ``pylikwid.nvread()``: Read the counter registers (stop->read->start)\n-  ``pylikwid.nvswitch(gid)``: Switch to group ``gid``\n   (stop->setup(gid)->start)\n-  ``pylikwid.nvgetidofactivegroup()`` Return the ``gid`` of the currently\n   configured group\n-  ``pylikwid.nvgetresult(gid, eidx, tidx)``: Return the raw counter\n   register result of all measurements identified by group ``gid`` and\n   the indices for event ``eidx`` and thread ``tidx``\n-  ``pylikwid.nvgetlastresult(gid, eidx, tidx)``: Return the raw counter\n   register result of the last measurement cycle identified by group\n   ``gid`` and the indices for event ``eidx`` and thread ``tidx``\n-  ``pylikwid.nvgetmetric(gid, midx, tidx)``: Return the derived metric\n   result of all measurements identified by group ``gid`` and the\n   indices for metric ``midx`` and thread ``tidx``\n-  ``pylikwid.nvgetlastmetric(gid, midx, tidx)``: Return the derived\n   metric result of the last measurement cycle identified by group\n   ``gid`` and the indices for metric ``midx`` and thread ``tidx``\n-  ``pylikwid.nvgettimeofgroup(gid)``: Return the measurement time for\n   group identified by ``gid``\n-  ``pylikwid.nvfinalize()``: Reset all used registers and delete internal\n   measurement results\n\nNvmon Marker API (if LIKWID is built with Nvidia interface)\n-----------------------------------------------------------\n\n-  ``pylikwid.gpumarkerinit()``: Initialize the Nvmon Marker API of the LIKWID library.\n   Must be called previous to all other functions.\n-  ``rr = pylikwid.gpuregisterregion(regiontag)``: Register a region to the\n   Nvmon Marker API. This is an optional function to reduce the overhead of\n   region registration at ``pylikwid.markerstartregion``. If you don't call\n   ``pylikwid.gpumarkerregisterregion(regiontag)``, the registration is done at\n   ``pylikwid.gpumarkerstartregion(regiontag)``. On success, 0 is return. If you\n   havn't called ``pylikwid.gpumarkerinit()``, a negative number is returned.\n-  ``err = pylikwid.gpumarkerstartregion(regiontag)``: Start measurements under\n   the name ``regiontag``. On success, 0 is return. If you havn't called\n   ``pylikwid.gpumarkerinit()``, a negative number is returned.\n-  ``err = pylikwid.gpumarkerstopregion(regiontag)``: Stop measurements under the\n   name ``regiontag`` again. On success, 0 is return. If you havn't\n   called ``pylikwid.gpumarkerinit()``, a negative number is returned.\n-  ``num_gpus, num_events, events[][], time[], count[] = pylikwid.gpumarkergetregion(regiontag)``:\n   Get the intermediate results of the region identified by\n   ``regiontag``. On success, it returns the number of events in the\n   current group, a list with all the aggregated event results per GPU, the\n   measurement time for the region and the number of calls.\n-  ``pylikwid.gpunextgroup()``: Switch to the next event set in a\n   round-robin fashion. If you have set only one event set on the\n   command line, this function performs no operation.\n-  ``pylikwid.gpumarkerreset(regiontag)``: Reset the values stored using the region\n   name ``regiontag``. On success, 0 is returned.\n-  ``pylikwid.gpumarkerclose()``: Close the connection to the LIKWID Nvmon Marker API\n   and write out measurement data to file. This file will be evaluated\n   by ``likwid-perfctr``.\n\n\nUsage\n=====\n\nMarker API\n----------\n\nCode\n~~~~\n\nHere is a small example Python script how to use the LIKWID Marker API\nin Python:\n\n::\n\n    #!/usr/bin/env python\n\n    import pylikwid\n\n    pylikwid.markerinit()\n    pylikwid.markerthreadinit()\n    liste = []\n    pylikwid.markerstartregion(\"listappend\")\n    for i in range(0,1000000):\n        liste.append(i)\n    pylikwid.markerstopregion(\"listappend\")\n    nr_events, eventlist, time, count = pylikwid.markergetregion(\"listappend\")\n    for i, e in enumerate(eventlist):\n        print(i, e)\n    pylikwid.markerclose()\n\nThis code simply measures the hardware performance counters for\nappending 1000000 elements to a list. First the API is initialized with\n``likwid.init()`` and ``likwid.threadinit()``. Afterwards it creates an\nempty list, starts the measurements with\n``likwid.startregion(\"listappend\")`` and executes the appending loop.\nWhen the loop has finished, we stop the measurements again using\n``likwid.stopregion(\"listappend\")``. Just for the example, we get the\nvalues inside our script using ``likwid.getregion(\"listappend\")`` and\nprint out the results. Finally, we close the connection to the LIKWID\nMarker API.\n\nYou always have to use ``likwid-perfctr`` to program the hardware\nperformance counters and specify the CPUs that should be measured. Since\nPython is commonly single-threaded, the cpu set only contains one entry:\n``likwid-perfctr -C 0 -g <EVENTSET> -m <PYTHONSCRIPT>`` This pins the\nPython interpreter to CPU 0 and measures ``<EVENTSET>`` for all regions\nin the Python script. You can set multiple event sets by adding multiple\n``-g <EVENTSET>`` to the command line. Please see the LIKWID page for\nfurther information how to use ``likwid-perfctr``. Link:\nhttps://github.com/rrze-likwid/likwid\n\nExample\n~~~~~~~\n\nUsing the above Python script we can measure the L2 to L3 cache data\nvolume:\n\n::\n\n    $ likwid-perfctr -C 0 -g L3 -m ./test.py\n    --------------------------------------------------------------------------------\n    CPU name:   Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz\n    CPU type:   Intel Core Haswell processor\n    CPU clock:  3.39 GHz\n    --------------------------------------------------------------------------------\n    (0, 926208305.0)\n    (1, 325539316.0)\n    (2, 284626172.0)\n    (3, 1219118.0)\n    (4, 918368.0)\n    Wrote LIKWID Marker API output to file /tmp/likwid_17275.txt\n    --------------------------------------------------------------------------------\n    ================================================================================\n    Group 1 L3: Region listappend\n    ================================================================================\n    +-------------------+----------+\n    |    Region Info    |  Core 0  |\n    +-------------------+----------+\n    | RDTSC Runtime [s] | 0.091028 |\n    |     call count    |     1    |\n    +-------------------+----------+\n\n    +-----------------------+---------+--------------+\n    |         Event         | Counter |    Core 0    |\n    +-----------------------+---------+--------------+\n    |   INSTR_RETIRED_ANY   |  FIXC0  | 9.262083e+08 |\n    | CPU_CLK_UNHALTED_CORE |  FIXC1  | 3.255393e+08 |\n    |  CPU_CLK_UNHALTED_REF |  FIXC2  | 2.846262e+08 |\n    |    L2_LINES_IN_ALL    |   PMC0  | 1.219118e+06 |\n    |     L2_TRANS_L2_WB    |   PMC1  | 9.183680e+05 |\n    +-----------------------+---------+--------------+\n\n    +-------------------------------+--------------+\n    |             Metric            |    Core 0    |\n    +-------------------------------+--------------+\n    |      Runtime (RDTSC) [s]      |  0.09102752  |\n    |      Runtime unhalted [s]     | 9.596737e-02 |\n    |          Clock [MHz]          | 3.879792e+03 |\n    |              CPI              | 3.514753e-01 |\n    |  L3 load bandwidth [MBytes/s] | 8.571425e+02 |\n    |  L3 load data volume [GBytes] |  0.078023552 |\n    | L3 evict bandwidth [MBytes/s] | 6.456899e+02 |\n    | L3 evict data volume [GBytes] |  0.058775552 |\n    |    L3 bandwidth [MBytes/s]    | 1.502832e+03 |\n    |    L3 data volume [GBytes]    |  0.136799104 |\n    +-------------------------------+--------------+\n\nAt first a header with the current system type and clock is printed.\nAfterwards the output of the Python script lists the results of the\nmeasurements we got internally with ``likwid.getregion``. The next\noutput is the region results evaluated by ``likwid-perfctr`` and prints\nat first a headline stating the measured eventset, here ``L3`` and the\nregion name ``listappend``. Afterwards 2 or 3 tables are printed. At\nfirst some basic information about the region like run time (or better\nmeasurement time) and the number of calls of the region. The next table\ncontains the raw values for each event in the eventset. These numbers\nare similar to the ones we got internally with ``likwid.getregion``. If\nyou have set an performance group (here ``L3``) instead of a custom\nevent set, the raw results are derived to commonly used metrics, here\nthe ``CPI`` (Cycles per instruction, lower is better) and different\nbandwidths and data volumes. You can see, that the load bandwidth for\nthe small loop is 857 MByte/s and the evict (write) bandwidth is 645\nMByte/s. In total we have a bandwidth of 1502 MByte/s.\n\nFull API\n--------\n\nCode\n~~~~\n\n::\n\n    #!/usr/bin/env python\n\n    import pylikwid\n\n    liste = []\n    cpus = [0,1]\n\n    pylikwid.init(cpus)\n    group = pylikwid.addeventset(\"INSTR_RETIRED_ANY:FIXC0\")\n    pylikwid.setup(group)\n    pylikwid.start()\n    for i in range(0,1000000):\n        liste.append(i)\n    pylikwid.stop()\n    for thread in range(0,len(cpus)):\n        print(\"Result CPU %d : %f\" % (cpus[thread], pylikwid.getresult(group,0,thread)))\n    pylikwid.finalize()\n\nExample\n~~~~~~~\n\n::\n\n    $ ./test.py\n    Result CPU 0 : 87335.000000\n    Result CPU 1 : 5222188.000000\n\nFurther comments\n================\n\nPlease be aware that Python is a high-level language and your simple\ncode is translated to a lot of Assembly instructions. The ``CPI`` value\nis commonly low (=> good) for high-level languages because they have to\nperform type-checking and similar stuff that can be executed fast in\ncomparison to the CPU clock. If you would compare the results to a lower\nlevel language like C or Fortran, the ``CPI`` will be worse for them but\nthe performance will be higher as no type-checking and transformations\nneed to be done.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/RRZE-HPC/pylikwid", "keywords": "hpc performance benchmark analysis", "license": "GPLv2", "maintainer": "", "maintainer_email": "", "name": "pylikwid", "package_url": "https://pypi.org/project/pylikwid/", "platform": "", "project_url": "https://pypi.org/project/pylikwid/", "project_urls": {"Homepage": "https://github.com/RRZE-HPC/pylikwid"}, "release_url": "https://pypi.org/project/pylikwid/0.4.0/", "requires_dist": null, "requires_python": "", "summary": "A Python module to access the function of the LIKWID library", "version": "0.4.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"pylikwid\">\n<h2>pylikwid</h2>\n<p>Python interface for the C API of LIKWID\n(<a href=\"https://github.com/RRZE-HPC/likwid\" rel=\"nofollow\">https://github.com/RRZE-HPC/likwid</a>)</p>\n<a href=\"https://travis-ci.org/RRZE-HPC/pylikwid?branch=master\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/RRZE-HPC/pylikwid.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9034f484e871d3d3172f21a88a5e96c447034c2f/68747470733a2f2f7472617669732d63692e6f72672f52525a452d4850432f70796c696b7769642e7376673f6272616e63683d6d6173746572\"></a>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>I added a setup.py script for the installation. It builds the C module\nand copies it to the proper destination.</p>\n<pre>$ git clone https://github.com/RRZE-HPC/pylikwid.git\n$ cd pylikwid\n# Build C interface\n$ python setup.py build_ext -I &lt;include path for likwid&gt; -L &lt;library path for likwid&gt; -R &lt;library path for likwid&gt;\n# Install module to the proper location\n$ python setup.py install (--prefix=&lt;where to install&gt;)\n# Testing\n$ python -c \"import pylikwid\"\n$ ./testlib.py\n</pre>\n</div>\n<div id=\"functions\">\n<h2>Functions</h2>\n<p>After <tt>import pylikwid</tt> you can call the following functions:</p>\n<div id=\"marker-api\">\n<h3>Marker API</h3>\n<ul>\n<li><tt>pylikwid.markerinit()</tt>: Initialize the Marker API of the LIKWID library.\nMust be called previous to all other functions.</li>\n<li><tt>pylikwid.markerthreadinit()</tt>: Add the current thread to the Marker API.\nSince Python is commonly single-threaded simply call it directly\nafter <tt>pylikwid.markerinit()</tt></li>\n<li><tt>rr = pylikwid.registerregion(regiontag)</tt>: Register a region to the\nMarker API. This is an optional function to reduce the overhead of\nregion registration at <tt>pylikwid.markerstartregion</tt>. If you don\u2019t call\n<tt>pylikwid.registerregion(regiontag)</tt>, the registration is done at\n<tt>pylikwid.markerstartregion(regiontag)</tt>. On success, 0 is return. If you\nhavn\u2019t called <tt>pylikwid.markerinit()</tt>, a negative number is returned.</li>\n<li><tt>err = pylikwid.markerstartregion(regiontag)</tt>: Start measurements under\nthe name <tt>regiontag</tt>. On success, 0 is return. If you havn\u2019t called\n<tt>pylikwid.markerinit()</tt>, a negative number is returned.</li>\n<li><tt>err = pylikwid.markerstopregion(regiontag)</tt>: Stop measurements under the\nname <tt>regiontag</tt> again. On success, 0 is return. If you havn\u2019t\ncalled <tt>pylikwid.markerinit()</tt>, a negative number is returned.</li>\n<li><tt>num_events, <span class=\"pre\">events[],</span> time, count = pylikwid.markergetregion(regiontag)</tt>:\nGet the intermediate results of the region identified by\n<tt>regiontag</tt>. On success, it returns the number of events in the\ncurrent group, a list with all the aggregated event results, the\nmeasurement time for the region and the number of calls.</li>\n<li><tt>pylikwid.nextgroup()</tt>: Switch to the next event set in a\nround-robin fashion. If you have set only one event set on the\ncommand line, this function performs no operation.</li>\n<li><tt>pylikwid.markerreset(regiontag)</tt>: Reset the values stored using the region\nname <tt>regiontag</tt>. On success, 0 is returned.</li>\n<li><tt>pylikwid.markerclose()</tt>: Close the connection to the LIKWID Marker API\nand write out measurement data to file. This file will be evaluated\nby <tt><span class=\"pre\">likwid-perfctr</span></tt>.</li>\n<li><tt>pylikwid.getprocessorid()</tt>: Returns the ID of the currently\nexecuting CPU</li>\n<li><tt>pylikwid.pinprocess(cpuid)</tt>: Pins the current process to the CPU\ngiven as <tt>cpuid</tt>.</li>\n<li><tt>pylikwid.pinthread(cpuid)</tt>: Pins the current thread to the CPU\ngiven as <tt>cpuid</tt>.</li>\n</ul>\n</div>\n<div id=\"topology\">\n<h3>Topology</h3>\n<ul>\n<li><tt>pylikwid.inittopology()</tt>: Initialize the topology module (reads in\nsystem topology)</li>\n<li><tt>infodict = pylikwid.getcpuinfo()</tt>: Return a dict with general\ninformation about the system (CPU model, CPU family, \u2026)<ul>\n<li><tt>osname</tt>: Name of the CPU retrieved from the CPUID leafs</li>\n<li><tt>name</tt>: Name of the micro architecture</li>\n<li><tt>short_name</tt>: Short name of the micro architecture</li>\n<li><tt>family</tt>: ID of the CPU family</li>\n<li><tt>model</tt>: Vendor-specific model number of the CPU</li>\n<li><tt>stepping</tt>: Stepping (Revision) of the CPU</li>\n<li><tt>perf_version</tt>: Version number of the hardware performance\nmonitoring capabilities</li>\n<li><tt>perf_num_ctr</tt>: Amount of general-purpose counter registers per\nhardware thread</li>\n<li><tt>perf_num_fixed_ctr</tt>: Amount of fixed-purpose counter registers\nper hardware thread</li>\n<li><tt>perf_width_ctr</tt>: Bit length of the counter registers</li>\n<li><tt>clock</tt>: CPU clock (only unequal to 0 if timer module is\ninitialized)</li>\n<li><tt>turbo</tt>: Is turbo mode supported?</li>\n<li><tt>isIntel</tt>: Is it an Intel CPU?</li>\n<li><tt>supportUncore</tt>: Does the system have performance monitoring\ncounters in the Uncore?</li>\n<li><tt>features</tt>: String with performance relevant CPU features (AVX,\nSSE, \u2026)</li>\n<li><tt>featureFlags</tt>: Bitmask for all available CPU features</li>\n</ul>\n</li>\n<li><tt>topodict = pylikwid.getcputopology()</tt>: Return a dict with the\ntopology of the system. Here is a list of fields in the dict:<ul>\n<li><tt>numSockets</tt>: Number of CPU sockets</li>\n<li><tt>numHWThreads</tt>: Number of hardware threads (physical +\nhyperthreading cores)</li>\n<li><tt>activeHWThreads</tt>: Number of active/usable hardware threads</li>\n<li><tt>numCoresPerSocket</tt>: Amount of hardware threads per CPU socket</li>\n<li><tt>numThreadsPerCore</tt>: Amount of hardware threads assembled in\nevery physical CPU core</li>\n<li><tt>numCacheLevels</tt>: Amount of levels in cacheing hierarchy</li>\n<li><tt>cacheLevels</tt>: Dict with information about the cache levels,\nkeys are the levels (1, 2, 3,\u2026)<ul>\n<li><tt>level</tt>: Level of the cache in the hierarchy</li>\n<li><tt>lineSize</tt>: Size of a cache line</li>\n<li><tt>sets</tt>: Amount of sets</li>\n<li><tt>inclusive</tt>: Is the cache inclusive or exclusive?`</li>\n<li><tt>threads</tt>: Amount of threads attached to the cache</li>\n<li><tt>associativity</tt>: Associativity of the cache</li>\n<li><tt>type</tt>: data (= data cache), unified = (data + instruction\ncache)</li>\n<li><tt>size</tt>: Size of the cache in bytes</li>\n</ul>\n</li>\n<li><tt>threadPool</tt>: Dict with information about the hardware threads.\nKeys are the os-generated ID of the hardware thread<ul>\n<li><tt>coreId</tt>: ID of the corresponding physical core</li>\n<li><tt>apicId</tt>: ID set by the operating system</li>\n<li><tt>threadId</tt>: ID of the hardware thread in the physical core</li>\n<li><tt>packageId</tt>: ID of the CPU socket hosting the hardware thread</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><tt>pylikwid.printsupportedcpus()</tt>: Prints all supported micro\narchitecture names to stdout</li>\n<li><tt>pylikwid.finalizetopology()</tt>: Delete all information in the\ntopology module</li>\n</ul>\n</div>\n<div id=\"numa\">\n<h3>NUMA</h3>\n<ul>\n<li><tt>numadict = pylikwid.initnuma()</tt>: Initialize the NUMA module and\nreturn the gathered values<ul>\n<li><tt>numberOfNodes</tt>: Amount of NUMA nodes in the system</li>\n<li><tt>nodes</tt>: Dict holding the information about the NUMA domains.\nKeys are the NUMA domain IDs<ul>\n<li><tt>id</tt>: ID of the NUMA domain (should be equal to dict key)</li>\n<li><tt>numberOfProcessors</tt>: Number of hardware threads attached to\nthe NUMA domain</li>\n<li><tt>processors</tt>: List of all CPU IDs attached to the NUMA domain</li>\n<li><tt>freeMemory</tt>: Amount of free memory in the NUMA domain (in\nKbytes)</li>\n<li><tt>totalMemory</tt>: Amount of total memory in the NUMA domain (in\nKbytes)</li>\n<li><tt>numberOfDistances</tt>: How many distances to self/other NUMA\ndomains</li>\n<li><tt>distances</tt>: List with distances, NUMA domain IDs are the\ndestination indexes in the list</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><tt>pylikwid.finalizenuma()</tt>: Delete all information in the NUMA\nmodule</li>\n</ul>\n</div>\n<div id=\"affinity\">\n<h3>Affinity</h3>\n<ul>\n<li><tt>affdict = pylikwid.initaffinity()</tt>: Initialize the affinity domain\nmodule and return the gathered values<ul>\n<li><tt>numberOfAffinityDomains</tt>: Amount of affinity domains</li>\n<li><tt>numberOfSocketDomains</tt>: Amount of CPU socket related affinity\ndomains</li>\n<li><tt>numberOfNumaDomains</tt>: Amount of NUMA related affinity domains</li>\n<li><tt>numberOfCacheDomains</tt>: Amount of last level cache related\naffinity domains</li>\n<li><tt>numberOfProcessorsPerSocket</tt>: Amount of hardware threads per\nCPU socket</li>\n<li><tt>numberOfCoresPerCache</tt>: Amount of physical CPU cores per last\nlevel cache</li>\n<li><tt>numberOfProcessorsPerCache</tt>: Amount of hardware threads per\nlast level cache</li>\n<li><tt>domains</tt>: Dict holding the information about the affinity\ndomains<ul>\n<li><tt>tag</tt>: Name of the affinity domain (N = node, SX = socket X,\nCY = cache Y, MZ = memory domain Z)</li>\n<li><tt>numberOfProcessors</tt>: Amount of hardware threads in the\ndomain</li>\n<li><tt>numberOfCores</tt>: Amount of physical CPU cores in the domain</li>\n<li><tt>processorList</tt>: List holding the CPU IDs in the domain</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><tt>pylikwid.finalizeaffinity()</tt>: Delete all information in the\naffinity domain module</li>\n<li><tt>pylikwid.cpustr_to_cpulist()</tt>: Transform a valid cpu string in\nLIKWID syntax into a list of CPU IDs</li>\n</ul>\n</div>\n<div id=\"timer\">\n<h3>Timer</h3>\n<ul>\n<li><tt>pylikwid.getcpuclock()</tt>: Return the CPU clock</li>\n<li><tt>t_start = pylikwid.startclock()</tt>: Start the clock and return the\ncurrent timestamp</li>\n<li><tt>t_end = pylikwid.stopclock()</tt>: Stop the clock and return the\ncurrent timestamp</li>\n<li><tt>t = pylikwid.getclock(t_start, t_end)</tt>: Return the time in seconds\nbetween <tt>t_start</tt> and <tt>t_end</tt></li>\n<li><tt>c = pylikwid.getclockcycles(t_start, t_end)</tt>: Return the amount of\nCPU cycles between <tt>t_start</tt> and <tt>t_end</tt></li>\n</ul>\n</div>\n<div id=\"temperature\">\n<h3>Temperature</h3>\n<ul>\n<li><tt>pylikwid.inittemp(cpu)</tt>: Initialize the temperature module for CPU\n<tt>cpu</tt></li>\n<li><tt>pylikwid.readtemp(cpu)</tt>: Read the current temperature of CPU\n<tt>cpu</tt></li>\n</ul>\n</div>\n<div id=\"energy\">\n<h3>Energy</h3>\n<ul>\n<li><tt>pinfo = pylikwid.getpowerinfo()</tt>: Initializes the energy module\nand returns gathered information. If it returns <tt>None</tt>, there is no\nenergy support<ul>\n<li><tt>minFrequency</tt>: Minimal possible frequency of a CPU core</li>\n<li><tt>baseFrequency</tt>: Base frequency of a CPU core</li>\n<li><tt>hasRAPL</tt>: Are energy reading supported?</li>\n<li><tt>timeUnit</tt>: Time unit</li>\n<li><tt>powerUnit</tt>: Power unit</li>\n<li><tt>domains</tt>: Dict holding the information about the energy\ndomains. Keys are PKG, PP0, PP1, DRAM<ul>\n<li><tt>ID</tt>: ID of the energy domain</li>\n<li><tt>energyUnit</tt>: Unit to derive raw register counts to uJ</li>\n<li><tt>supportInfo</tt>: Is the information register available?</li>\n<li><tt>tdp</tt>: TDP of the domain (only if supportInfo == True)</li>\n<li><tt>minPower</tt>: Minimal power consumption by the domain (only if\nsupportInfo == True)</li>\n<li><tt>maxPower</tt>: Maximal power consumption by the domain (only if\nsupportInfo == True)</li>\n<li><tt>maxTimeWindow</tt>: Maximal time window between updates of the\nenergy registers</li>\n<li><tt>supportStatus</tt>: Are energy readings from the domain are\npossible?</li>\n<li><tt>supportPerf</tt>: Is power capping etc. available?</li>\n<li><tt>supportPolicy</tt>: Can we set a power policy for the domain?</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><tt>e_start = pylikwid.startpower(cpu, domainid)</tt>: Return the start\nvalue for a cpu for the domain with <tt>domainid</tt>. The <tt>domainid</tt>\ncan be found in <tt><span class=\"pre\">pinfo[\"domains\"][domainname][\"ID\"]</span></tt></li>\n<li><tt>e_stop = pylikwid.stoppower(cpu, domainid)</tt>: Return the stop value\nfor a cpu for the domain with <tt>domainid</tt>. The <tt>domainid</tt> can be\nfound in <tt><span class=\"pre\">pinfo[\"domains\"][domainname][\"ID\"]</span></tt></li>\n<li><tt>e = pylikwid.getpower(e_start, e_stop, domainid)</tt>: Calculate the\nuJ from the values retrieved by <tt>startpower</tt> and <tt>stoppower</tt>.</li>\n</ul>\n</div>\n<div id=\"configuration\">\n<h3>Configuration</h3>\n<ul>\n<li><tt>pylikwid.initconfiguration()</tt>: Read in config file from different\nplaces. Default is <tt>/etc/likwid.cfg</tt></li>\n<li><tt>config = pylikwid.getconfiguration()</tt>: Get the dict with the\nconfiguration options<ul>\n<li><tt>configFileName</tt>: Path to the config file</li>\n<li><tt>topologyCfgFileName</tt>: If a topology file was created with\n<tt><span class=\"pre\">likwid-genTopoCfg</span></tt> and found by <tt>initconfiguration()</tt></li>\n<li><tt>daemonPath</tt>: Path to the access daemon executable</li>\n<li><tt>groupPath</tt>: Path to the base directory with the performance\ngroup files</li>\n<li><tt>daemonMode</tt>: Configured access mode (0=direct, 1=accessDaemon)</li>\n<li><tt>maxNumThreads</tt>: Maximal amount of hardware threads that can be\nhandled by LIKWID</li>\n<li><tt>maxNumNodes</tt>: Maximal amount of CPU sockets that can be handled\nby LIKWID</li>\n</ul>\n</li>\n<li><tt>pylikwid.destroyconfiguration()</tt>: Destroy all information about\nthe configuration</li>\n</ul>\n</div>\n<div id=\"access-module\">\n<h3>Access module</h3>\n<ul>\n<li><tt>pylikwid.hpmmode(mode)</tt>: Set access mode. For x86 there are two\nmodes:<ul>\n<li><tt>mode = 0</tt>: Access the MSR and PCI devices directly. May require\nroot access</li>\n<li><tt>mode = 1</tt>: Access the MSR and PCI devices through access daemon\ninstances</li>\n</ul>\n</li>\n<li><tt>pylikwid.hpminit()</tt>: Initialize the access functions according to\nthe access mode</li>\n<li><tt>pylikwid.hpmaddthread(cpu)</tt>: Add CPU <tt>cpu</tt> to the access layer\n(opens devices files or connection to an access daemon)</li>\n<li><tt>pylikwid.hpmfinalize()</tt>: Unregister all CPUs from the access layer\nand close files/connections</li>\n</ul>\n</div>\n<div id=\"performance-monitoring\">\n<h3>Performance Monitoring</h3>\n<ul>\n<li><tt>pylikwid.init(cpus)</tt>: Initialize the perfmon module for the CPUs\ngiven in list <tt>cpus</tt></li>\n<li><tt>pylikwid.getnumberofthreads()</tt>: Return the number of threads\ninitialized in the perfmon module</li>\n<li><tt>pylikwid.getnumberofgroups()</tt>: Return the number of groups\ncurrently registered in the perfmon module</li>\n<li><tt>pylikwid.getgroups()</tt>: Return a list of all available groups. Each\nlist entry is a dict:<ul>\n<li><tt>Name</tt>: Name of the performance group</li>\n<li><tt>Short</tt>: Short information about the performance group</li>\n<li><tt>Long</tt>: Long description of the performance group</li>\n</ul>\n</li>\n<li><tt>gid = pylikwid.addeventset(estr)</tt>: Add a performance group or a\ncustom event set to the perfmon module. The <tt>gid</tt> is required to\nspecify the event set later</li>\n<li><tt>pylikwid.getnameofgroup(gid)</tt>: Return the name of the group\nidentified by <tt>gid</tt>. If it is a custom event set, the name is set\nto <tt>Custom</tt></li>\n<li><tt>pylikwid.getshortinfoofgroup(gid)</tt>: Return the short information\nabout a performance group</li>\n<li><tt>pylikwid.getlonginfoofgroup(gid)</tt>: Return the description of a\nperformance group</li>\n<li><tt>pylikwid.getnumberofevents(gid)</tt>: Return the amount of events in\nthe group</li>\n<li><tt>pylikwid.getnumberofmetrics(gid)</tt>: Return the amount of derived\nmetrics in the group. Always 0 for custom event sets.</li>\n<li><tt>pylikwid.getnameofevent(gid, eidx)</tt>: Return the name of the event\nidentified by <tt>gid</tt> and the index in the list of events</li>\n<li><tt>pylikwid.getnameofcounter(gid, eidx)</tt>: Return the name of the\ncounter register identified by <tt>gid</tt> and the index in the list of\nevents</li>\n<li><tt>pylikwid.getnameofmetric(gid, midx)</tt>: Return the name of a derived\nmetric identified by <tt>gid</tt> and the index in the list of metrics</li>\n<li><tt>pylikwid.setup(gid)</tt>: Program the counter registers to measure all\nevents in group <tt>gid</tt></li>\n<li><tt>pylikwid.start()</tt>: Start the counter registers</li>\n<li><tt>pylikwid.stop()</tt>: Stop the counter registers</li>\n<li><tt>pylikwid.read()</tt>: Read the counter registers (stop-&gt;read-&gt;start)</li>\n<li><tt>pylikwid.switch(gid)</tt>: Switch to group <tt>gid</tt>\n(stop-&gt;setup(gid)-&gt;start)</li>\n<li><tt>pylikwid.getidofactivegroup()</tt> Return the <tt>gid</tt> of the currently\nconfigured group</li>\n<li><tt>pylikwid.getresult(gid, eidx, tidx)</tt>: Return the raw counter\nregister result of all measurements identified by group <tt>gid</tt> and\nthe indices for event <tt>eidx</tt> and thread <tt>tidx</tt></li>\n<li><tt>pylikwid.getlastresult(gid, eidx, tidx)</tt>: Return the raw counter\nregister result of the last measurement cycle identified by group\n<tt>gid</tt> and the indices for event <tt>eidx</tt> and thread <tt>tidx</tt></li>\n<li><tt>pylikwid.getmetric(gid, midx, tidx)</tt>: Return the derived metric\nresult of all measurements identified by group <tt>gid</tt> and the\nindices for metric <tt>midx</tt> and thread <tt>tidx</tt></li>\n<li><tt>pylikwid.getlastmetric(gid, midx, tidx)</tt>: Return the derived\nmetric result of the last measurement cycle identified by group\n<tt>gid</tt> and the indices for metric <tt>midx</tt> and thread <tt>tidx</tt></li>\n<li><tt>pylikwid.gettimeofgroup(gid)</tt>: Return the measurement time for\ngroup identified by <tt>gid</tt></li>\n<li><tt>pylikwid.finalize()</tt>: Reset all used registers and delete internal\nmeasurement results</li>\n</ul>\n</div>\n<div id=\"marker-api-result-file-reader\">\n<h3>Marker API result file reader</h3>\n<ul>\n<li><tt>pylikwid.markerreadfile(filename)</tt>: Reads in the result file of an\napplication run instrumented by the LIKWID Marker API</li>\n<li><tt>pylikwid.markernumregions()</tt>: Return the number of regions in an\napplication run</li>\n<li><tt>pylikwid.markerregiontag(rid)</tt>: Return the region tag for the\nregion identified by <tt>rid</tt></li>\n<li><tt>pylikwid.markerregiongroup(rid)</tt>: Return the group name for the\nregion identified by <tt>rid</tt></li>\n<li><tt>pylikwid.markerregionevents(rid)</tt>: Return the amount of events for\nthe region identified by <tt>rid</tt></li>\n<li><tt>pylikwid.markerregionthreads(rid)</tt>: Return the amount of threads\nthat executed the region identified by <tt>rid</tt></li>\n<li><tt>pylikwid.markerregiontime(rid, tidx)</tt>: Return the accumulated\nmeasurement time for the region identified by <tt>rid</tt> and the thread\nindex <tt>tidx</tt></li>\n<li><tt>pylikwid.markerregioncount(rid, tidx)</tt>: Return the call count for\nthe region identified by <tt>rid</tt> and the thread index <tt>tidx</tt></li>\n<li><tt>pylikwid.markerregionresult(rid, eidx, tidx)</tt>: Return the call\ncount for the region identified by <tt>rid</tt>, the event index <tt>eidx</tt>\nand the thread index <tt>tidx</tt></li>\n<li><tt>pylikwid.markerregionmetric(rid, midx, tidx)</tt>: Return the call\ncount for the region identified by <tt>rid</tt>, the metric index <tt>midx</tt>\nand the thread index <tt>tidx</tt></li>\n</ul>\n</div>\n<div id=\"gpu-topology-if-likwid-is-built-with-nvidia-interface\">\n<h3>GPU Topology (if LIKWID is built with Nvidia interface)</h3>\n<ul>\n<li><tt>pylikwid.initgputopology()</tt>: Initialize the topology module (reads in\nsystem topology)</li>\n<li><tt>topolist = pylikwid.getgputopology()</tt>: Return a list with the\nGPU topology of the system. Each GPU is represented by a dict. The entries in\nthe dicts are:<ul>\n<li><tt>devid</tt>: Device identifier for the GPU</li>\n<li><tt>numaNode</tt>: The NUMA node identifier the GPU is attached at</li>\n<li><tt>name</tt>: Name of the device</li>\n<li><tt>mem</tt>: Memory capacity of the device</li>\n<li><tt>ccapMajor</tt>: Major number of the compute capability</li>\n<li><tt>ccapMinor</tt>: Minor number of the compute capability</li>\n<li><tt>maxThreadsDim[3]</tt>: Maximum sizes of each dimension of a block</li>\n<li><tt>maxGridSize[3]</tt>: Maximum sizes of each dimension of a grid</li>\n<li><tt>maxThreadsPerBlock</tt>: Maximam number of thread per block</li>\n<li><tt>sharedMemPerBlock</tt>: Total amount of shared memory available per block</li>\n<li><tt>totalConstantMemory</tt>: Total amount of constant memory available on the device</li>\n<li><tt>simdWidth</tt>: SIMD width of arithmetic units = warp size</li>\n<li><tt>memPitch</tt>: Maximum pitch allowed by the memory copy functions that involve memory regions allocated through cuMemAllocPitch()</li>\n<li><tt>regsPerBlock</tt>: Total number of registers available per block</li>\n<li><tt>clockRatekHz</tt>: Clock frequency in kilohertz</li>\n<li><tt>textureAlign</tt>: Alignment requirement</li>\n<li><tt>surfaceAlign</tt>: Alignment requirement for surfaces</li>\n<li><tt>l2Size</tt>: L2 cache in bytes. 0 if the device doesn\u2019t have L2 cache</li>\n<li><tt>memClockRatekHz</tt>: Peak memory clock frequency in kilohertz</li>\n<li><tt>pciBus</tt>: PCI bus identifier of the device</li>\n<li><tt>pciDev</tt>: PCI device (also known as slot) identifier of the device</li>\n<li><tt>pciDom</tt>: PCI domain identifier of the device</li>\n<li><tt>maxBlockRegs</tt>: Maximum number of 32-bit registers available to a thread block</li>\n<li><tt>numMultiProcs</tt>: Number of multiprocessors on the device</li>\n<li><tt>maxThreadPerMultiProc</tt>: Maximum resident threads per multiprocessor</li>\n<li><tt>memBusWidth</tt>: Global memory bus width in bits</li>\n<li><tt>unifiedAddrSpace</tt>: 1 if the device shares a unified address space with the host, or 0 if not</li>\n<li><tt>ecc</tt>: 1 if error correction is enabled on the device, 0 if error correction is disabled or not supported by the device</li>\n<li><tt>asyncEngines</tt>: Number of asynchronous engines</li>\n<li><tt>mapHostMem</tt>: 1 if the device can map host memory into the CUDA address space</li>\n<li><tt>integrated</tt>: 1 if the device is an integrated (motherboard) GPU and 0 if it is a discrete (card) component</li>\n</ul>\n</li>\n<li><tt>pylikwid.finalizegputopology()</tt>: Delete all information in the\ntopology module</li>\n</ul>\n</div>\n<div id=\"performance-monitoring-for-nvidia-gpus-if-likwid-is-built-with-nvidia-interface\">\n<h3>Performance Monitoring for Nvidia GPUs (if LIKWID is built with Nvidia interface)</h3>\n<ul>\n<li><tt>pylikwid.nvinit(gpus)</tt>: Initialize the nvmon module for the GPUs\ngiven in list <tt>gpus</tt></li>\n<li><tt>pylikwid.nvgetnumberofgpus()</tt>: Return the number of GPUs\ninitialized in the nvmon module</li>\n<li><tt>pylikwid.nvgetnumberofgroups()</tt>: Return the number of groups\ncurrently registered in the nvmon module</li>\n<li><tt>pylikwid.nvgetgroups()</tt>: Return a list of all available groups. Each\nlist entry is a dict:<ul>\n<li><tt>Name</tt>: Name of the performance group</li>\n<li><tt>Short</tt>: Short information about the performance group</li>\n<li><tt>Long</tt>: Long description of the performance group</li>\n</ul>\n</li>\n<li><tt>gid = pylikwid.nvaddeventset(estr)</tt>: Add a performance group or a\ncustom event set to the perfmon module. The <tt>gid</tt> is required to\nspecify the event set later</li>\n<li><tt>pylikwid.nvgetnameofgroup(gid)</tt>: Return the name of the group\nidentified by <tt>gid</tt>. If it is a custom event set, the name is set\nto <tt>Custom</tt></li>\n<li><tt>pylikwid.nvgetshortinfoofgroup(gid)</tt>: Return the short information\nabout a performance group</li>\n<li><tt>pylikwid.nvgetlonginfoofgroup(gid)</tt>: Return the description of a\nperformance group</li>\n<li><tt>pylikwid.nvgetnumberofevents(gid)</tt>: Return the amount of events in\nthe group</li>\n<li><tt>pylikwid.nvgetnumberofmetrics(gid)</tt>: Return the amount of derived\nmetrics in the group. Always 0 for custom event sets.</li>\n<li><tt>pylikwid.nvgetnameofevent(gid, eidx)</tt>: Return the name of the event\nidentified by <tt>gid</tt> and the index in the list of events</li>\n<li><tt>pylikwid.nvgetnameofcounter(gid, eidx)</tt>: Return the name of the\ncounter register identified by <tt>gid</tt> and the index in the list of\nevents</li>\n<li><tt>pylikwid.nvgetnameofmetric(gid, midx)</tt>: Return the name of a derived\nmetric identified by <tt>gid</tt> and the index in the list of metrics</li>\n<li><tt>pylikwid.nvsetup(gid)</tt>: Program the counter registers to measure all\nevents in group <tt>gid</tt></li>\n<li><tt>pylikwid.nvstart()</tt>: Start the counter registers</li>\n<li><tt>pylikwid.nvstop()</tt>: Stop the counter registers</li>\n<li><tt>pylikwid.nvread()</tt>: Read the counter registers (stop-&gt;read-&gt;start)</li>\n<li><tt>pylikwid.nvswitch(gid)</tt>: Switch to group <tt>gid</tt>\n(stop-&gt;setup(gid)-&gt;start)</li>\n<li><tt>pylikwid.nvgetidofactivegroup()</tt> Return the <tt>gid</tt> of the currently\nconfigured group</li>\n<li><tt>pylikwid.nvgetresult(gid, eidx, tidx)</tt>: Return the raw counter\nregister result of all measurements identified by group <tt>gid</tt> and\nthe indices for event <tt>eidx</tt> and thread <tt>tidx</tt></li>\n<li><tt>pylikwid.nvgetlastresult(gid, eidx, tidx)</tt>: Return the raw counter\nregister result of the last measurement cycle identified by group\n<tt>gid</tt> and the indices for event <tt>eidx</tt> and thread <tt>tidx</tt></li>\n<li><tt>pylikwid.nvgetmetric(gid, midx, tidx)</tt>: Return the derived metric\nresult of all measurements identified by group <tt>gid</tt> and the\nindices for metric <tt>midx</tt> and thread <tt>tidx</tt></li>\n<li><tt>pylikwid.nvgetlastmetric(gid, midx, tidx)</tt>: Return the derived\nmetric result of the last measurement cycle identified by group\n<tt>gid</tt> and the indices for metric <tt>midx</tt> and thread <tt>tidx</tt></li>\n<li><tt>pylikwid.nvgettimeofgroup(gid)</tt>: Return the measurement time for\ngroup identified by <tt>gid</tt></li>\n<li><tt>pylikwid.nvfinalize()</tt>: Reset all used registers and delete internal\nmeasurement results</li>\n</ul>\n</div>\n<div id=\"nvmon-marker-api-if-likwid-is-built-with-nvidia-interface\">\n<h3>Nvmon Marker API (if LIKWID is built with Nvidia interface)</h3>\n<ul>\n<li><tt>pylikwid.gpumarkerinit()</tt>: Initialize the Nvmon Marker API of the LIKWID library.\nMust be called previous to all other functions.</li>\n<li><tt>rr = pylikwid.gpuregisterregion(regiontag)</tt>: Register a region to the\nNvmon Marker API. This is an optional function to reduce the overhead of\nregion registration at <tt>pylikwid.markerstartregion</tt>. If you don\u2019t call\n<tt>pylikwid.gpumarkerregisterregion(regiontag)</tt>, the registration is done at\n<tt>pylikwid.gpumarkerstartregion(regiontag)</tt>. On success, 0 is return. If you\nhavn\u2019t called <tt>pylikwid.gpumarkerinit()</tt>, a negative number is returned.</li>\n<li><tt>err = pylikwid.gpumarkerstartregion(regiontag)</tt>: Start measurements under\nthe name <tt>regiontag</tt>. On success, 0 is return. If you havn\u2019t called\n<tt>pylikwid.gpumarkerinit()</tt>, a negative number is returned.</li>\n<li><tt>err = pylikwid.gpumarkerstopregion(regiontag)</tt>: Stop measurements under the\nname <tt>regiontag</tt> again. On success, 0 is return. If you havn\u2019t\ncalled <tt>pylikwid.gpumarkerinit()</tt>, a negative number is returned.</li>\n<li><tt>num_gpus, num_events, <span class=\"pre\">events[][],</span> <span class=\"pre\">time[],</span> count[] = pylikwid.gpumarkergetregion(regiontag)</tt>:\nGet the intermediate results of the region identified by\n<tt>regiontag</tt>. On success, it returns the number of events in the\ncurrent group, a list with all the aggregated event results per GPU, the\nmeasurement time for the region and the number of calls.</li>\n<li><tt>pylikwid.gpunextgroup()</tt>: Switch to the next event set in a\nround-robin fashion. If you have set only one event set on the\ncommand line, this function performs no operation.</li>\n<li><tt>pylikwid.gpumarkerreset(regiontag)</tt>: Reset the values stored using the region\nname <tt>regiontag</tt>. On success, 0 is returned.</li>\n<li><tt>pylikwid.gpumarkerclose()</tt>: Close the connection to the LIKWID Nvmon Marker API\nand write out measurement data to file. This file will be evaluated\nby <tt><span class=\"pre\">likwid-perfctr</span></tt>.</li>\n</ul>\n</div>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<div id=\"id1\">\n<h3>Marker API</h3>\n<div id=\"code\">\n<h4>Code</h4>\n<p>Here is a small example Python script how to use the LIKWID Marker API\nin Python:</p>\n<pre>#!/usr/bin/env python\n\nimport pylikwid\n\npylikwid.markerinit()\npylikwid.markerthreadinit()\nliste = []\npylikwid.markerstartregion(\"listappend\")\nfor i in range(0,1000000):\n    liste.append(i)\npylikwid.markerstopregion(\"listappend\")\nnr_events, eventlist, time, count = pylikwid.markergetregion(\"listappend\")\nfor i, e in enumerate(eventlist):\n    print(i, e)\npylikwid.markerclose()\n</pre>\n<p>This code simply measures the hardware performance counters for\nappending 1000000 elements to a list. First the API is initialized with\n<tt>likwid.init()</tt> and <tt>likwid.threadinit()</tt>. Afterwards it creates an\nempty list, starts the measurements with\n<tt><span class=\"pre\">likwid.startregion(\"listappend\")</span></tt> and executes the appending loop.\nWhen the loop has finished, we stop the measurements again using\n<tt><span class=\"pre\">likwid.stopregion(\"listappend\")</span></tt>. Just for the example, we get the\nvalues inside our script using <tt><span class=\"pre\">likwid.getregion(\"listappend\")</span></tt> and\nprint out the results. Finally, we close the connection to the LIKWID\nMarker API.</p>\n<p>You always have to use <tt><span class=\"pre\">likwid-perfctr</span></tt> to program the hardware\nperformance counters and specify the CPUs that should be measured. Since\nPython is commonly single-threaded, the cpu set only contains one entry:\n<tt><span class=\"pre\">likwid-perfctr</span> <span class=\"pre\">-C</span> 0 <span class=\"pre\">-g</span> &lt;EVENTSET&gt; <span class=\"pre\">-m</span> &lt;PYTHONSCRIPT&gt;</tt> This pins the\nPython interpreter to CPU 0 and measures <tt>&lt;EVENTSET&gt;</tt> for all regions\nin the Python script. You can set multiple event sets by adding multiple\n<tt><span class=\"pre\">-g</span> &lt;EVENTSET&gt;</tt> to the command line. Please see the LIKWID page for\nfurther information how to use <tt><span class=\"pre\">likwid-perfctr</span></tt>. Link:\n<a href=\"https://github.com/rrze-likwid/likwid\" rel=\"nofollow\">https://github.com/rrze-likwid/likwid</a></p>\n</div>\n<div id=\"example\">\n<h4>Example</h4>\n<p>Using the above Python script we can measure the L2 to L3 cache data\nvolume:</p>\n<pre>$ likwid-perfctr -C 0 -g L3 -m ./test.py\n--------------------------------------------------------------------------------\nCPU name:   Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz\nCPU type:   Intel Core Haswell processor\nCPU clock:  3.39 GHz\n--------------------------------------------------------------------------------\n(0, 926208305.0)\n(1, 325539316.0)\n(2, 284626172.0)\n(3, 1219118.0)\n(4, 918368.0)\nWrote LIKWID Marker API output to file /tmp/likwid_17275.txt\n--------------------------------------------------------------------------------\n================================================================================\nGroup 1 L3: Region listappend\n================================================================================\n+-------------------+----------+\n|    Region Info    |  Core 0  |\n+-------------------+----------+\n| RDTSC Runtime [s] | 0.091028 |\n|     call count    |     1    |\n+-------------------+----------+\n\n+-----------------------+---------+--------------+\n|         Event         | Counter |    Core 0    |\n+-----------------------+---------+--------------+\n|   INSTR_RETIRED_ANY   |  FIXC0  | 9.262083e+08 |\n| CPU_CLK_UNHALTED_CORE |  FIXC1  | 3.255393e+08 |\n|  CPU_CLK_UNHALTED_REF |  FIXC2  | 2.846262e+08 |\n|    L2_LINES_IN_ALL    |   PMC0  | 1.219118e+06 |\n|     L2_TRANS_L2_WB    |   PMC1  | 9.183680e+05 |\n+-----------------------+---------+--------------+\n\n+-------------------------------+--------------+\n|             Metric            |    Core 0    |\n+-------------------------------+--------------+\n|      Runtime (RDTSC) [s]      |  0.09102752  |\n|      Runtime unhalted [s]     | 9.596737e-02 |\n|          Clock [MHz]          | 3.879792e+03 |\n|              CPI              | 3.514753e-01 |\n|  L3 load bandwidth [MBytes/s] | 8.571425e+02 |\n|  L3 load data volume [GBytes] |  0.078023552 |\n| L3 evict bandwidth [MBytes/s] | 6.456899e+02 |\n| L3 evict data volume [GBytes] |  0.058775552 |\n|    L3 bandwidth [MBytes/s]    | 1.502832e+03 |\n|    L3 data volume [GBytes]    |  0.136799104 |\n+-------------------------------+--------------+\n</pre>\n<p>At first a header with the current system type and clock is printed.\nAfterwards the output of the Python script lists the results of the\nmeasurements we got internally with <tt>likwid.getregion</tt>. The next\noutput is the region results evaluated by <tt><span class=\"pre\">likwid-perfctr</span></tt> and prints\nat first a headline stating the measured eventset, here <tt>L3</tt> and the\nregion name <tt>listappend</tt>. Afterwards 2 or 3 tables are printed. At\nfirst some basic information about the region like run time (or better\nmeasurement time) and the number of calls of the region. The next table\ncontains the raw values for each event in the eventset. These numbers\nare similar to the ones we got internally with <tt>likwid.getregion</tt>. If\nyou have set an performance group (here <tt>L3</tt>) instead of a custom\nevent set, the raw results are derived to commonly used metrics, here\nthe <tt>CPI</tt> (Cycles per instruction, lower is better) and different\nbandwidths and data volumes. You can see, that the load bandwidth for\nthe small loop is 857 MByte/s and the evict (write) bandwidth is 645\nMByte/s. In total we have a bandwidth of 1502 MByte/s.</p>\n</div>\n</div>\n<div id=\"full-api\">\n<h3>Full API</h3>\n<div id=\"id2\">\n<h4>Code</h4>\n<pre>#!/usr/bin/env python\n\nimport pylikwid\n\nliste = []\ncpus = [0,1]\n\npylikwid.init(cpus)\ngroup = pylikwid.addeventset(\"INSTR_RETIRED_ANY:FIXC0\")\npylikwid.setup(group)\npylikwid.start()\nfor i in range(0,1000000):\n    liste.append(i)\npylikwid.stop()\nfor thread in range(0,len(cpus)):\n    print(\"Result CPU %d : %f\" % (cpus[thread], pylikwid.getresult(group,0,thread)))\npylikwid.finalize()\n</pre>\n</div>\n<div id=\"id3\">\n<h4>Example</h4>\n<pre>$ ./test.py\nResult CPU 0 : 87335.000000\nResult CPU 1 : 5222188.000000\n</pre>\n</div>\n</div>\n</div>\n<div id=\"further-comments\">\n<h2>Further comments</h2>\n<p>Please be aware that Python is a high-level language and your simple\ncode is translated to a lot of Assembly instructions. The <tt>CPI</tt> value\nis commonly low (=&gt; good) for high-level languages because they have to\nperform type-checking and similar stuff that can be executed fast in\ncomparison to the CPU clock. If you would compare the results to a lower\nlevel language like C or Fortran, the <tt>CPI</tt> will be worse for them but\nthe performance will be higher as no type-checking and transformations\nneed to be done.</p>\n</div>\n\n          </div>"}, "last_serial": 6391495, "releases": {"0.1": [], "0.1.3": [{"comment_text": "", "digests": {"md5": "bc4c3726be71fdb5ff3870e85b615151", "sha256": "1820b9b9499419b6ea36fdc33a3d3b61ffa973f9eb91afb9f0390e407aa1f80a"}, "downloads": -1, "filename": "pylikwid-0.1.3.tar.gz", "has_sig": false, "md5_digest": "bc4c3726be71fdb5ff3870e85b615151", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9921, "upload_time": "2017-04-19T14:45:27", "upload_time_iso_8601": "2017-04-19T14:45:27.688221Z", "url": "https://files.pythonhosted.org/packages/96/d4/f02f80ecb31fb68cb5eb6bedba384b69cbdf626b548eeba9c2785947756b/pylikwid-0.1.3.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "61d1b0c119110bda37a1b77dc53bec61", "sha256": "a360ec589467283f008b3d775d8f1272c41dc3028fe4f25e06e6edd3a4f46b02"}, "downloads": -1, "filename": "pylikwid-0.2.tar.gz", "has_sig": false, "md5_digest": "61d1b0c119110bda37a1b77dc53bec61", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9627, "upload_time": "2017-04-19T14:58:38", "upload_time_iso_8601": "2017-04-19T14:58:38.774791Z", "url": "https://files.pythonhosted.org/packages/99/9b/a60541be31908fff3eece082de5a51b04a2a5b6ccc8a7537413ed62da845/pylikwid-0.2.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "4d66b52716ed6f2c2544a86e63f9dc74", "sha256": "51750cb3e42b82487a2c32a62ad1ff431717e758d9a2a63bd572d8bd0c6e3d5e"}, "downloads": -1, "filename": "pylikwid-0.2.1.tar.gz", "has_sig": false, "md5_digest": "4d66b52716ed6f2c2544a86e63f9dc74", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15431, "upload_time": "2017-04-20T10:31:21", "upload_time_iso_8601": "2017-04-20T10:31:21.817682Z", "url": "https://files.pythonhosted.org/packages/20/b6/7e709b1a3a343f579ea93d3eda092196da366c3fd807e01f5d7dc48c244a/pylikwid-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "41141534d45b18727e267a25b07f80fa", "sha256": "7ee5125afe1d477d7c6f589bafc31587351a72dffaaca62809ca4a1c4ed1aa78"}, "downloads": -1, "filename": "pylikwid-0.2.2.tar.gz", "has_sig": false, "md5_digest": "41141534d45b18727e267a25b07f80fa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30733, "upload_time": "2017-12-21T11:30:57", "upload_time_iso_8601": "2017-12-21T11:30:57.088276Z", "url": "https://files.pythonhosted.org/packages/d7/5f/711a228e4280b82d6321e193487252cc0df8cf07eeca9bca83b81def9243/pylikwid-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "ea7f92d44d9e4c0e528e4a97f4b2b7c7", "sha256": "e4321a21dfa6cdf75f7fcbe6a8dbc1ba9b83afe06623693e2f0fd1282a8a935a"}, "downloads": -1, "filename": "pylikwid-0.2.3.tar.gz", "has_sig": false, "md5_digest": "ea7f92d44d9e4c0e528e4a97f4b2b7c7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30760, "upload_time": "2018-01-02T14:47:12", "upload_time_iso_8601": "2018-01-02T14:47:12.414842Z", "url": "https://files.pythonhosted.org/packages/48/36/b355fe713a1de2434af8f552d6f4d23eac36772e1e56078a2ee46699befd/pylikwid-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "339cad9dd1ef4b5dd6c986c53cfb357b", "sha256": "25548d049d8fb37b3dd7fee8aefe9282f04d424442a5b04d16711af85acbd8b4"}, "downloads": -1, "filename": "pylikwid-0.2.4.tar.gz", "has_sig": false, "md5_digest": "339cad9dd1ef4b5dd6c986c53cfb357b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30958, "upload_time": "2018-01-02T15:14:18", "upload_time_iso_8601": "2018-01-02T15:14:18.449961Z", "url": "https://files.pythonhosted.org/packages/bd/73/a8baea30ebd31e4ba6ae5110a83dfdacdc4c5c527ff5e1abf8038499a753/pylikwid-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "1757e1ffeb37e7c82c3dc9101ee95ab6", "sha256": "6ed18cd8d897764a318be4333a8649801ece755ed6be6e1c9be24793ef3100df"}, "downloads": -1, "filename": "pylikwid-0.2.5.tar.gz", "has_sig": false, "md5_digest": "1757e1ffeb37e7c82c3dc9101ee95ab6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31072, "upload_time": "2018-05-29T13:08:43", "upload_time_iso_8601": "2018-05-29T13:08:43.308165Z", "url": "https://files.pythonhosted.org/packages/c2/ca/5e1df2fed6ecc90f5b748d275c77906b96107026eb437b4b5204f843f0e3/pylikwid-0.2.5.tar.gz", "yanked": false}], "0.2.6": [{"comment_text": "", "digests": {"md5": "83f0fd3bf8ce1ae94b50a7b6be99a5dd", "sha256": "7e2495a9cedfde2340ad7852a84010cc6a045748428bc5124d0ce64242d792a3"}, "downloads": -1, "filename": "pylikwid-0.2.6.tar.gz", "has_sig": false, "md5_digest": "83f0fd3bf8ce1ae94b50a7b6be99a5dd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31075, "upload_time": "2018-05-29T13:22:55", "upload_time_iso_8601": "2018-05-29T13:22:55.972185Z", "url": "https://files.pythonhosted.org/packages/97/ae/0e6a77c122fe82dac4f987995924831ecdac322a7bd7e48dd93d00dee4d4/pylikwid-0.2.6.tar.gz", "yanked": false}], "0.2.7": [{"comment_text": "", "digests": {"md5": "8368a3061276e335fdbbd1623bd1b03e", "sha256": "ff3fd9af97320bff10da920b1330ed0a4c4b71d933878dcb75a0ea56fe726b7e"}, "downloads": -1, "filename": "pylikwid-0.2.7.tar.gz", "has_sig": false, "md5_digest": "8368a3061276e335fdbbd1623bd1b03e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31038, "upload_time": "2018-06-04T10:17:47", "upload_time_iso_8601": "2018-06-04T10:17:47.736301Z", "url": "https://files.pythonhosted.org/packages/c1/6f/9b74caea82019cb569a3c14be2e0bb40e639a3532f210bded31e503f006c/pylikwid-0.2.7.tar.gz", "yanked": false}], "0.2.8": [{"comment_text": "", "digests": {"md5": "1b8b9d66c9b6c28ff7aef318498f93aa", "sha256": "9744a2cbbaed880db024c8351158ab1b6febd2d081640771ebe6907ed2b5c652"}, "downloads": -1, "filename": "pylikwid-0.2.8.tar.gz", "has_sig": false, "md5_digest": "1b8b9d66c9b6c28ff7aef318498f93aa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31823, "upload_time": "2018-06-25T18:31:49", "upload_time_iso_8601": "2018-06-25T18:31:49.226225Z", "url": "https://files.pythonhosted.org/packages/8a/47/b5115b439b584b59a907438c185440e84e40f4ee2adf6468096c3a039fdc/pylikwid-0.2.8.tar.gz", "yanked": false}], "0.2.9": [{"comment_text": "", "digests": {"md5": "465826dd047ca6ea5a5fceb2c4d04a05", "sha256": "5da656832de02046bb99b6f26c37f78f124313c27958540ac43d6a9787bf9d9f"}, "downloads": -1, "filename": "pylikwid-0.2.9.tar.gz", "has_sig": false, "md5_digest": "465826dd047ca6ea5a5fceb2c4d04a05", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31835, "upload_time": "2018-06-27T08:44:27", "upload_time_iso_8601": "2018-06-27T08:44:27.339304Z", "url": "https://files.pythonhosted.org/packages/5d/45/28576fc23f7cf3fb2c10353cfea5d6513e8b6fecb6cbb35ce231c6c513cd/pylikwid-0.2.9.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "656e9a658c514764fa1b8b632c861eb4", "sha256": "bf940c28c7ea81512fa72d73419f2b2bb837b6c612e94b3ecb17013d8a1f747a"}, "downloads": -1, "filename": "pylikwid-0.3.0.tar.gz", "has_sig": false, "md5_digest": "656e9a658c514764fa1b8b632c861eb4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32065, "upload_time": "2019-04-24T14:14:59", "upload_time_iso_8601": "2019-04-24T14:14:59.823544Z", "url": "https://files.pythonhosted.org/packages/bf/3b/93e49b5e691e130445cc148057cba5d064ea940581c14e770cf0bef7a78a/pylikwid-0.3.0.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "4718bc68e3966647fefcc863706f63f2", "sha256": "ac6ada2dc0856a89a7acee0ef536b34259cd33cca4b5af3eff33c679be623fd0"}, "downloads": -1, "filename": "pylikwid-0.3.1.tar.gz", "has_sig": false, "md5_digest": "4718bc68e3966647fefcc863706f63f2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32079, "upload_time": "2019-04-24T14:56:16", "upload_time_iso_8601": "2019-04-24T14:56:16.346179Z", "url": "https://files.pythonhosted.org/packages/ac/83/917a50fad8a0bfcc5e684cecf0633a3ba5be7a72ffb97b9b9c61c4ca7c7c/pylikwid-0.3.1.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "2f1d6b89628beba497907cc261fe117a", "sha256": "f7894a6d7ebcea7da133ef639599a314f850f55cd6c5ffdd630bb879bd2aa0b8"}, "downloads": -1, "filename": "pylikwid-0.4.0.tar.gz", "has_sig": false, "md5_digest": "2f1d6b89628beba497907cc261fe117a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37197, "upload_time": "2020-01-03T15:26:03", "upload_time_iso_8601": "2020-01-03T15:26:03.691099Z", "url": "https://files.pythonhosted.org/packages/1e/02/895de87e388d4eeb25c466e4ff8939660cdd0c299d46ee9a6420c9adb2a7/pylikwid-0.4.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2f1d6b89628beba497907cc261fe117a", "sha256": "f7894a6d7ebcea7da133ef639599a314f850f55cd6c5ffdd630bb879bd2aa0b8"}, "downloads": -1, "filename": "pylikwid-0.4.0.tar.gz", "has_sig": false, "md5_digest": "2f1d6b89628beba497907cc261fe117a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37197, "upload_time": "2020-01-03T15:26:03", "upload_time_iso_8601": "2020-01-03T15:26:03.691099Z", "url": "https://files.pythonhosted.org/packages/1e/02/895de87e388d4eeb25c466e4ff8939660cdd0c299d46ee9a6420c9adb2a7/pylikwid-0.4.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:05 2020"}