{"info": {"author": "Tim Savannah", "author_email": "kata198@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Internet :: WWW/HTTP", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Text Processing :: Markup :: HTML"], "description": "AdvancedHTMLParser\n==================\n\nAdvancedHTMLParser is an Advanced HTML Parser, with support for adding, removing, modifying, and formatting HTML.\n\nIt aims to provide the same interface as you would find in a compliant browser through javascript ( i.e. all the getElement methods, appendChild, etc), an XPath implementation, as well as many more complex and sophisticated features not available through a browser. And most importantly, it's in python!\n\n\nThere are many potential applications, not limited to:\n\n * Webpage Scraping / Data Extraction\n\n * Testing and Validation\n\n * HTML Modification/Insertion\n\n * Outputting your website\n\n * Debugging\n\n * HTML Document generation\n\n * Web Crawling\n\n * Formatting HTML documents or web pages\n\n\nIt is especially good for servlets/webpages. It is quick to take an expertly crafted page in raw HTML / css, and have your servlet's ingest with AdvancedHTMLParser and create/insert data elements into the existing view using a simple and well-known interface ( javascript-like + HTML DOM ).\n\nAnother useful scenario is creating automated testing suites which can operate much more quickly and reliably (and at a deeper function-level), unlike in-browser testing suites.\n\n\n\nFull API\n--------\n\nCan be found  http://htmlpreview.github.io/?https://github.com/kata198/AdvancedHTMLParser/blob/master/doc/AdvancedHTMLParser.html?vers=8.1.8 .\n\n\nExamples\n--------\n\nVarious examples can be found in the \"tests\" directory. A very old, simple example can also be found as \"example.py\" in the root directory.\n\n\nShort Doc\n---------\n\n\n**The Package and Modules**\n\nThe top-level module in this package is \"*AdvancedHTMLParser*.\"\n\n\n\timport AdvancedHTMLParser\n\n\nMost everything \"public\" is available through this top-level module, but some corner-case usages may require importing from a submodule. All of these associations can be found through the pydocs.\n\n\nFor example, to access AdvancedTag, the recommended path is just to import the top-level, and use dot-access:\n\n\timport AdvancedHTMLParser\n\n\tmyTag = AdvancedHTMLParser.AdvancedTag('div')\n\n\nHowever, you can also import AdvancedTag through this top-level module:\n\n\timport AdvancedHTMLParser\n\n\tfrom AdvancedHTMLParser import AdvancedTag\n\n\nOr, you can import from the specific sub-module, directly:\n\n\timport AdvancedHTMLParser\n\n\tfrom AdvancedHTMLParser.Tags import AdvancedTag\n\n\nAll examples below are written as if \"import AdvancedHTMLParser\" has already been performed, and all relations in examples are based off usages from the top-level import, only.\n\n\n**AdvancedHTMLParser**\n\nThink of this like \"document\" in a browser.\n\n\nThe AdvancedHTMLParser can read in a file (or string) of HTML, and will create a modifiable DOM tree from it. It can also be constructed manually from AdvancedHTMLParser.AdvancedTag objects.\n\n\nTo populate an AdvancedHTMLParser from existing HTML:\n\n\tparser = AdvancedHTMLParser.AdvancedHTMLParser()\n\n\t# Parse an HTML string into the document\n\n\tparser.parseStr(htmlStr)\n\n\t# Parse an HTML file into the document\n\n\tparser.parseFile(filename)\n\n\n\nThe parser then exposes many \"standard\" functions as you'd find on the web for accessing the data, and some others:\n\n\tgetElementsByTagName   \\- Returns a list of all elements matching a tag name\n\n\tgetElementsByName      \\- Returns a list of all elements with a given name attribute\n\n\tgetElementById         \\- Returns a single AdvancedTag (or None) if found an element matching the provided ID\n\n\tgetElementsByClassName \\- Returns a list of all elements containing one or more space\\-separated class names\n\n\tgetElementsByAttr       \\- Returns a list of all elements matching a paticular attribute/value pair.\n\n\tgetElementsByXPathExpression \\- Return a TagCollection (list) of all elements matching a given XPath expression\n\n\tgetElementsWithAttrValues \\- Returns a list of all elements with a specific attribute name containing one of a list of values\n\n\tgetElementsCustomFilter \\- Provide a function/lambda that takes a tag argument, and returns True to \"match\" it. Returns all matched objects\n\n\tgetRootNodes            \\- Get a list of nodes at root level (0)\n\n\tgetAllNodes             \\- Get all the nodes contained within this document\n\n\tgetHTML                 \\- Returns string of HTML representing this DOM\n\n\tgetFormattedHTML        \\- Returns a formatted string (using AdvancedHTMLFormatter; see below) of the HTML. Takes as argument an indent (defaults to four spaces)\n\n\tgetMiniHTML             \\- Returns a \"mini\" HTML representation which disregards all whitespace and indentation beyond the functional single\\-space\n\n\nThe results of all of these getElement\\* functions are TagCollection objects. This is a special kind of list which contains additional functions. See the \"TagCollection\" section below for more info.\n\nThese objects can be modified, and will be reflected in the parent DOM.\n\n\nThe parser also contains some expected properties, like\n\n\n\thead                    \\- The \"head\" tag associated with this document, or None\n\n\tbody                    \\- The \"body\" tag associated with this document, or None\n\n\tforms                   \\- All \"forms\" on this document as a TagCollection\n\n\n**General Attributes**\n\nIn general, attributes can be accessed with dot-syntax, i.e.\n\n\ttagEm.id = \"Hello\"\n\nwill set the \"id\" attribute. If it works in HTML javascript on a tag element, it should work on an AdvancedTag element with python.\n\nsetAttribute, getAttribute, and removeAttribute are more explicit and recommended ways of getting/setting/deleting attributes on elements.\n\nThe same names are used in python as in the javascript/DOM, such as 'className' corrosponding to a space-separated string of the 'class' attribute, 'classList' corrosponding to a list of classes, etc.\n\n\n**Style Attribute**\n\nStyle attributes can be manipulated just like in javascript, so element.style.position = 'relative' for setting, or element.style.position for access.\n\nYou can also assign the tag.style as a string, like:\n\n\tmyTag.style = \"display: block; float: right; font\\-weight: bold\"\n\nin addition to individual properties:\n\n\tmyTag.style.display = 'block'\n\n\tmyTag.style.float = 'right'\n\n\tmyTag.style.fontWeight = 'bold'\n\nYou can remove style properties by setting its value to an empty string.\n\nFor example, to clear \"display\" property:\n\n\tmyTag.style.display = ''\n\nA standard method *setProperty* can also obe used to set or remove individual properties\n\nFor example:\n\n\tmyTag.style.setProperty(\"display\", \"block\") # Set display: block\n\n\tmyTag.style.setProperty(\"display\", '') # Clear display: property\n\n\nThe naming conventions are the same as in javascript, like \"element.style.paddingTop\" for \"padding-top\" attribute.\n\n\n**TagCollection**\n\nA TagCollection can be used like a list. Every element has a unique uuid associated with it, and a TagCollection will ensure that the same element does not appear twice within its list (so it acts like an ordered set)\n\nIt also exposes the various getElement\\* functions which operate on the elements within the list (and their children).\n\nFor example:\n\n\n\t# Filter off the parser all tags with \"item\" in class\n\n\ttagCollection = document.getElementsByClassName('item')\n\n\t# Return all nodes which are nested within any class=\"item\" object\n\n\t#  and also contains the class name \"onsale\"\n\n\titemsWithOnSaleClass = tagCollection.getElementsByClassName('onsale')\n\n\nTo operate just on items in the list, you can use the TagCollection method, *filterCollection*, which takes a lambda/function and returns True to retain that tag in the return.\n\nFor example:\n\n\t# Filter off the parser all tags with \"item\" in class\n\n\ttagCollection = document.getElementsByClassName('item')\n\n\t# Provide a lambda to filter this collection, returning in tagCollection2\n\n\t#   those items which have a \"value\" attribute > 20 and contains at least\n\n\t#   1 child element with \"specialPrice\" class\n\n\ttagCollection2 = tagCollection.filterCollection( lambda node : int(node.getAttribute('value') or 0) > 20 and len(node.getElementsByClassName('specialPrice')) > 1 )\n\n\nTagCollections also support advanced filtering (find/filter methods), see \"Advanced Filtering\" section below.\n\n\n**AdvancedTag**\n\nThe AdvancedTag represents a single tag and its inner text. It exposes many of the functions and properties you would expect to be present if using javascript.\n\neach AdvancedTag also supports the same getElementsBy\\* functions as the parser.\n\nIt adds several additional that are not found in javascript, such as peers and arbitrary attribute searching.\n\nsome of these include:\n\n\tappendText              \\- Append text to this element\n\n\tappendChild             \\- Append a child to this element\n\n\tappendBlock             \\- Append a block (text or AdvancedTag) to this element\n\n\tappend                  \\- alias of appendBlock\n\n\tremoveChild             \\- Removes a child\n\n\tremoveText              \\- Removes first occurance of some text from any text nodes\n\n\tremoveTextAll           \\- Removes ALL occurances of some text from any text nodes\n\n\tinsertBefore            \\- Inserts a child before an existing child\n\n\tinsertAfter             \\- Inserts a child after an existing child\n\n\tgetChildren             \\- Returns the children as a list\n\n\tgetStartTag             \\- Start Tag, with attributes\n\n\tgetEndTag               \\- End Tag\n\n\tgetPeersByName          \\- Gets \"peers\" (elements with same parent, at same level in tree) with a given name\n\n\tgetPeersByAttr          \\- Gets peers by an arbitrary attribute/value combination\n\n\tgetPeersWithAttrValues  \\- Gets peers by an arbitrary attribute/values combination.\n\n\tgetPeersByClassName   \\- Gets peers that contain a given class name\n\n\tgetElement\\\\\\*            \\- Same as above, but act on the children of this element.\n\n\tgetParentElementCustomFilter \\- Takes a lambda/function and applies on all parents of this element upward until the document root. Returns the first node that when passed to this function returns True, or None if no matches on any parent nodes\n\n\tgetHTML / toHTML / asHTML \\- Get the HTML representation using this node as a root (so start tag and attributes, innerHTML (text and child nodes), and end tag)\n\n\tfirstChild             \\- Get the first child of this node, be it text or an element (AdvancedTag)\n\n\tfirstElementChild      \\- Get the first child of this node that is an element\n\n\tlastChild             \\- Get the last child of this node, be it text or an element (AdvancedTag)\n\n\tlastElementChild      \\- Get the last child of this node that is an element\n\n\tnextSibling            \\- Get next sibling, be it text  or  an element\n\n\tnextElementSibling     \\- Get next sibling, that is an element\n\n\tpreviousSibling            \\- Get previous sibling, be it text  or  an element\n\n\tpreviousElementSibling     \\- Get previous sibling, that is an element\n\n\t{get,set,has,remove}Attribute  \\- get/set/test/remove an attribute\n\n\t{add,remove}Class       \\- Add/remove a class from the list of classes\n\n\tsetStyle                \\- Set a specific style property [like: setStyle(\"font\\-weight\", \"bold\") ]\n\n\tisTagEqual              \\- Compare if two tags have the same attributes. Using the == operator will compare if they are the same exact tag (by uuid)\n\n\tgetUid                  \\- Get a unique ID for this tag (internal)\n\n\tgetAllChildNodes        \\- Gets all nodes beneath this node in the document (its children, its children's children, etc)\n\n\tgetAllNodes             \\- Same as getAllChildNodes, but also includes this node\n\n\tcontains                \\- Check if a provided node appears anywhere beneath this node (as child, child\\-of\\-child, etc)\n\n\tremove                  \\- Remove this node from its parent element, and disassociates this and all sub\\-nodes from the associated document\n\n\t\\_\\_str\\_\\_                 \\- str(tag) will show start tag with attributes, inner text, and end tag\n\n\t\\_\\_repr\\_\\_                \\- Shows a reconstructable representation of this tag\n\n\t\\_\\_getitem\\_\\_             \\- Can be indexed like tag[2] to access second child.\n\n\nAnd some properties:\n\n\tchildren/childNodes     \\- The children (tags) as a list NOTE: This returns only AdvancedTag objects, not text.\n\n\tchildBlocks             \\- All direct child blocks. This includes both AdvnacedTag objects and text nodes (str)\n\n\tinnerHTML               \\- The innerHTML including the html of all children\n\n\tinnerText               \\- The text nodes, in order, as they appear as direct children to this node as a string\n\n\ttextContent             \\- All the text nodes, in order, as they appear within this node or any children (or their children, etc.)\n\n\touterHTML               \\- innerHTML wrapped in this tag\n\n\tclassNames/classList    \\- a list of the classes\n\n\tparentNode/parentElement \\- The parent tag\n\n\ttagName                \\- The tag name\n\n\townerDocument          \\- The document associated with this node, if any\n\n\nAnd many others. See the pydocs for a full list, and associated docstrings.\n\n\n**Appending raw HTML**\n\nYou can append raw HTML to a tag by calling:\n\n\ttagEm.appendInnerHTML('<div id=\"Some sample HTML\"> <span> Yes </span> </div>')\n\nwhich acts like, in javascript:\n\n\ttagEm.innerHTML += '<div id=\"Some sample HTML\"> <span> Yes </span> </div>';\n\n\n**Creating Tags from HTML**\n\nTags can be created from HTML strings outside of AdvancedHTMLParser.parseStr (which parses an entire document) by:\n\n* Parser.AdvancedHTMLParser.createElement - Like document.createElement, creates a tag with a given tag name. Not associated with any document.\n\n* Parser.AdvancedHTMLParser.createElementFromHTML - Creates a single tag from HTML.\n\n* Parser.AdvancedHTMLParser.createElementsFromHTML - Creates and returns a list of one or more tags from HTML.\n\n* Parser.AdvancedHTMLParser.createBlocksFromHTML - Creates and returns a list of blocks. These can be AdvancedTag objects (A tag), or a str object (if raw text outside of tags). This is recommended for parsing arbitrary HTML outside of parsing the entire document. The createElement{,s}FromHTML functions will discard any text outside of the tags passed in.\n\n\n\nAdvanced Filtering\n------------------\n\nAdvancedHTMLParser contains two kinds of \"Advanced Filtering\":\n\n**find**\n\nThe most basic unified-search, AdvancedHTMLParser has a \"find\" method on it. This will search all nodes with a single, simple query.\n\nThis is not as robust as the \"filter\" method (which can also be used on any tag or TagCollection), but does not require any dependency packages.\n\n\tfind \\- Perform a search of elements using attributes as keys and potential values as values\n\n\t   (i.e.  parser.find(name='blah', tagname='span')  will return all elements in this document\n\n\t\t with the name \"blah\" of the tag type \"span\" )\n\n\tArguments are key = value, or key can equal a tuple/list of values to match ANY of those values.\n\n\tAppend a key with \\_\\_contains to test if some strs (or several possible strs) are within an element\n\n\tAppend a key with \\_\\_icontains to perform the same \\_\\_contains op, but ignoring case\n\n\tSpecial keys:\n\n\t   tagname    \\- The tag name of the element\n\n\t   text       \\- The text within an element\n\n\tNOTE: Empty string means both \"not set\" and \"no value\" in this implementation.\n\n\nExample:\n\n\tcheddarElements = parser.find(name='items', text\\_\\_icontains='cheddar')\n\n\n**filter**\n\nIf you have QueryableList installed (a default dependency since 7.0.0 to AdvancedHTMLParser, but can be skipped with '\\-\\-no\\-deps' passed to setup.py)\n\nthen you can take advantage of the advanced \"filter\" methods, on either the parser (entire document), any tag (that tag and nodes beneath), or tag collection (any of those tags, or any tags beneath them).\n\nA full explanation of the various filter modes that QueryableList supports can be found at https://github.com/kata198/QueryableList\n\nSpecial keys are: \"tagname\" for the tag name, and \"text\" for the inner text of a node.\n\nAn attribute that is unset has a value of None, which is different than a set attribute with an empty value ''.\n\n\nFor example:\n\n\tcheddarElements = parser.filter(name='items', text\\_\\_icontains='cheddar')\n\n\nThe AdvancedHTMLParser has:\n\n\tfilter / filterAnd      \\- Perform a filter query on all nodes in this document, returning a TagCollection of elements matching ALL criteria\n\n\tfilterOr                \\- Perform a filter query on all nodes in this document, returning a TagCollection of elements matching ANY criteria\n\n\nEvery AdvancedTag has:\n\n\tfilter / filterAnd      \\- Perform a filter query on this nodes and all sub\\-nodes, returning a TagCollection of elements matching ALL criteria\n\n\tfilterOr                \\- Perform a filter query on this nodes and all sub\\-nodes, returning a TagCollection of elements matching ANY criteria\n\n\nEvery TagCollection has:\n\n\n\tfilter / filterAnd      \\- Perform a filter query on JUST the nodes contained within this list (no children), returning a TagCollection of elements matching ALL criteria\n\n\tfilterOr                \\- Perform a filter query on JUST the nodes contained within this list (no children), returning a TagCollection of elements matching ANY criteria\n\n\tfilterAll / filterAllAnd \\- Perform a filter query on the nodes contained within this list, and all of their sub\\-nodes, returning a TagCollection of elements matching ALL criteria\n\n\tfilterAllOr              \\- Perform a filter query on the nodes contained within this list, and all of their sub\\-nodes, returning a TagCollection of elements matching ANY criteria\n\n\n\nValidation\n----------\nValidation can be performed by using ValidatingAdvancedHTMLParser. It will raise an exception if an assumption would have to be made to continue parsing (i.e. something important).\n\nInvalidCloseException - Tried to close a tag that shouldn't have been closed\n\nMissedCloseException  - Missed a non-optional close of a tag that would lead to causing an assumption during parsing.\n\nInvalidAttributeNameException - An attribute name was found that contained an invalid character, or broke a naming rule.\n\n\nXPath\n-----\n\n**XPath support is in Beta phase.**\n\n\nBasic XPath support has been added, which supports searching, attribute matching, positions, indexes, some functions, most axes (such as parent::).\n\n\nExamples of some currently supported expressions:\n\n\t//table//tr[last()]/parent::tbody\n\nFind any table, descend to any descendant that is the last tr of its parent, rise to and return the parent tbody of that tr.\n\n\t//div[ @name = \"Cheese\" ]/span[2]\n\nFind any div with attribute name=\"Cheese\" , and return the second direct child which is a span.\n\n\t//\\*[ normalize\\-space() = \"Banana\" ]\n\nFind and return any tag which contains the inner text, normalized for whitespace, of \"Banana\"\n\n\nFind and return any tag under a div containing a class \"purple-cheese\"\n\n\t//div/\\*[ contains( concat( ' ', @class, ' ' ), 'purple\\-cheese' ) ]\n\n\nMore will be added. If you have a needed xpath feature not currently supported (you'll know by parse exception raised), please open an issue and I will make it a priority!\n\n\nIndexedAdvancedHTMLParser\n=========================\n\nIndexedAdvancedHTMLParser provides the ability to use indexing for faster search. If you are just parsing and not modifying, this is your best bet. If you are modifying the DOM tree, make sure you call IndexedAdvancedHTMLParser.reindex() before relying on them.\n\nEach of the get\\* functions above takes an additional \"useIndex\" function, which can also be set to False to skip index. See constructor for more information, and \"Performance and Indexing\" section below.\n\nAdvancedHTMLFormatter and formatHTML\n------------------------------------\n\n**AdvancedHTMLFormatter**\n\nThe AdvancedHTMLFormatter formats HTML into a pretty layout. It can handle elements like pre, core, script, style, etc to keep their contents preserved, but does not understand CSS rules.\n\nThe methods are:\n\n\tparseStr               \\- Parse a string of contents\n\n\tparseFile              \\- Parse a filename or file object\n\n\tgetHTML                \\- Get the formatted html\n\n\tgetRootNodes           \\- Get a list of the \"root\" nodes (most outer nodes, should be <html> on a valid document)\n\n\tgetRoot                \\- Gets the \"root\" node (on a valid document this should be <html>). For arbitrary HTML, you should use getRootNodes, as there may be several nodes at the same outermost level\n\n\nYou can access this same formatting off an AdvancedHTMLParser.AdvancedHTMLParser (or IndexedAdvancedHTMLParser) by calling .getFormattedHTML()\n\n\n**AdvancedHTMLMiniFormatter**\n\nThe AdvancedHTMLMiniFormatter will strip all non-functional whitespace (meaning any whitespace which wouldn't normally add a space to the document or is required for xhtml) and provide no indentation.\n\nUse this when pretty-printing doesn't matter and you'd like to save space.\n\n\nYou can access this same formatting off an AdvancedHTMLParser.AdvancedHTMLParser (or IndexedAdvancedHTMLParser) by calling .getMiniHTML()\n\n\n**AdvancedHTMLSlimTagFormatter and AdvancedHTMLSlimTagMiniFormatter**\n\nIn order to support some less-leniant parsers, AdvancedHTMLParser will by default include a space prior to the close-tag '>' character in HTML output.\n\nFor example:\n\n\t<span id=\"abc\" >Blah</span>\n\n\t<br />\n\n\t<hr class=\"bigline\" />\n\n\nIt is recommended to keep these extra spaces, but if for some reason you feel you need to get rid of them, you can use either *AdvancedHTMLSlimTagFormatter* or *AdvancedHTMLSlimTagMiniFormatter*.\n\n\n*AdvancedHTMLSlimTagFormatter* will do pretty-printing (like getFormattedHTML / AdvancedHTMLFormatter.getHTML output)\n\n*AdvancedHTMLSlimTagMiniFormatter* will do mini-printing (like getMiniHTML / AdvancedHTMLMiniFormatter.getHTML output)\n\n\nFeeding in your HTML via formatter.parseStr(htmlStr) [where htmlStr can be parser.getHTML()] will cause it to be output without the start-tag padding.\n\nFor example:\n\n\t<span id=\"abc\">Blah</span>\n\nBy default, self-closing tags will retain their padding so that an xhtml-compliant parser doesn't treat \"/\" as either an attribute or part of the attribute-value of the preceding attribute.\n\nFor example:\n\n\t<hr class=\"bigline\"/>\n\nCould be interpreted as a horizontal rule with a class name of \"bigline/\". Most modern browsers work around this and will not have issue, but some parsers will.\n\nYou may pass an optional keyword-argument to the formatter constructor, slimSelfClosing=True, in order to force removal of this padding from self-closing tags.\n\nFor example:\n\n\tmyHtml = '<hr class=\"bigline\" />'\n\n\tformatter = AdvancedHTMLSlimTagMiniFormatter(slimSelfClosing=True)\n\n\tformatter.parseStr(myHtml)\n\n\tminiHtml = formatter.getHTML()\n\n\t# miniHtml will now contain '<hr class=\"bigline\"/>'\n\n.\n\n**formatHTML script**\n\n\nA script, formatHTML comes with this package and will perform formatting on an input file, and output to a file or stdout:\n\n\tUsage: formatHTML (Optional Arguments) (optional: /path/to/in.html) (optional: [/path/to/output.html])\n\n\t  Formats HTML on input and writes to output.\n\n\t Optional Arguments:\n\n\t \\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n\t\t\\-e [encoding]        \\- Specify an encoding to use. Default is utf\\-8\n\n\t\t\\-m  or \\-\\-mini        \\- Output \"mini\" HTML (only retain functional whitespace,\n\n\t\t\t\t\t\t\t\tstrip the rest and no indentation)\n\n\t\t\\-p  or \\-\\-pretty      \\- Output \"pretty\" HTML [This is the defualt mode]\n\n\n\t\t\\-\\-indent='    '      \\- Use the provided string [default 4\\-spaces] to represent each\n\n\t\t\t\t\t\t\t\tlevel of nesting. Use \\-\\-indent=\"\t\" for 1 tab insead, for example.\n\n\t\t\t\t\t\t\t   Affects pretty printing mode only\n\n\n\t If output filename is not specified or is empty string, output will be to stdout.\n\n\t If input filename is not specified or is empty string, input will be from stdin\n\n\t If \\-e is provided, will use that as the encoding. Defaults to utf\\-8\n\n\nNotes\n-----\n\n* Each tag has a generated unique ID which is assigned at create time. The search functions use these to prevent duplicates in search results. There is a global function in the module, AdvancedHTMLParser.uniqueTags, which will filter a list of tags and remove any duplicates. TagCollections will only allow one instance of a tag (no duplicates)\n\n* In general, for tag names and attribute names, you should use lowercase values. During parsing, the parser will lowercase attribute names (like NAME=\"Abc\" becomes name=\"Abc\"). During searching, however, for performance reasons, it is assumed you are passing in already-lowercased strings. If you can't trust the input to be lowercase, then it is your responsibility to call .lower() before calling .getElementsBy\\*\n\n* If you are using IndexedAdvancedHTMLParser (instead of AdvancedHTMLParser) to construct HTML and not search, I recommend either setting the index params to False in the constructor, or calling  IndexedAdvancedHTMLParser.disableIndexing(). When you are finished and want to go back to searching, you can call IndexedAdvancedHTMLParser.reindex and set to True what you want to reindex.\n\n* There are additional functions and usages not documented here, check the file for more information.\n\nPerformance and Indexing\n------------------------\n\nPerformance is very good using either AdvancedHTMLParser, and even better (for scraping) using IndexedAdvancedHTMLParser class. The performance can be further enhanced on IndexedAdvancedHTMLParser via several indexing tunables:\n\nFirst, in the constructor of IndexedAdvancedHTMLParser and in the reindex method is a boolean to be set which determines if each field is indexed (e.x. indexIDs will make getElementByID use an index).\n\nIf an index is used, parsing time slightly goes up, but searches become O(1) (from root node, slightly less efficent from other nodes) instead of O(n) [n=num elements].\n\nBy default, IDs, Names, Tag Names, Class Names are indexed.\n\nYou can add an index for any arbitrary field (used in getElementByAttr) via IndexedAdvancedHTMLParser.addIndexOnAttribute('src'), for example, to index the 'src' attribute. This index can be removed via removeIndexOnAttribute.\n\n\nDependencies\n------------\n\nAdvancedHTMLParser can be installed without dependencies (pass '\\-\\-no\\-deps' to setup.py), and everything will function EXCEPT filter\\* methods.\n\nBy default, https://github.com/kata198/QueryableList will be installed, which will enable support for those additional filter methods.\n\n\nUnicode\n-------\n\nAdvancedHTMLParser generally has very good support for unicode, and defaults to \"utf\\-8\" (can be altered by the \"encoding\" argument to the AdvancedHTMLParser.AdvancedHTMLParser when parsing.)\n\nIf you are still getting UnicodeDecodeError or UnicodeEncodeError, there are a few things you can try:\n\n* If the error happens when printing/writing to stdout ( default behaviour for apache / mod\\_python is to open stdout with the ANSI/ASCII encoding ), ensure your streams are, in fact, set to utf\\-8.\n\n\t\\* Set the environment variable PYTHONIOENCODING to \"utf\\\\\\-8\" before python is launched. In Apache, you can add the line \"SetEnv PYTHONIOENCODING utf\\\\\\-8\" to your httpd.conf in order to achieve this.\n\n* Ensure that the data you are passing to AdvancedHTMLParser has the correct encoding (matching the \"encoding\" parameter).\n\n* Switch to python3 if at all possible \\-\\- python2 does have 'unicode' support and AdvancedHTMLParser uses it to the best of its ability, but python2 does still have some inherit flaws which may come up using standard library / output functions. You should ensure that these are set to use utf\\-8 (as described above).\n\n\nAdvancedHTMLParser is tested against unicode ( even has a unit test ) which works in both python2 and python3 in the general case.\n\nIf you are having an issue (even on python2) and you've checked the above \"common configuration/usage\" errors and think there is still an issue, please open a bug report on https://github.com/kata198/AdvancedHTMLParser with a test case, python version, and traceback.\n\n\nThe library itself is considered unicode-safe, and almost always it's an issue outside of this library, or has a simple workaround.\n\n\nExample Usage\n-------------\n\nSee https://raw.githubusercontent.com/kata198/AdvancedHTMLParser/master/example.py for an example of parsing store data using this class.\n\nChanges\n-------\nSee: https://raw.githubusercontent.com/kata198/AdvancedHTMLParser/master/ChangeLog\n\n\nContact Me / Support\n--------------------\n\nI am available by email to provide support, answer questions, or otherwise  provide assistance in using this software. Use my email kata198 at gmail.com with \"AdvancedHTMLParser\" in the subject line.\n\n\nIf you are having an issue / found a bug / want to merge in some changes, please open a pull request.\n\n\nUnit Tests\n----------\n\nSee \"tests\" directory available in github. Use \"runTests.py\" within that directory. Tests use my `GoodTests <https://github.com/kata198/GoodTests>`_ framework. It will download it to the current directory if not found in path, so you don't need to worry that it's a dependency.", "description_content_type": "", "docs_url": "https://pythonhosted.org/AdvancedHTMLParser/", "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kata198/AdvancedHTMLParser", "keywords": "html,parser,tree,DOM,getElementsByName,getElementById,getElementsByClassName,simple,python,xml,HTMLParser,getElementsByTagName,getElementsByAttr,javascript,parse,scrape,test,SimpleHTMLParser,modify,JS,write", "license": "LGPLv3", "maintainer": "Tim Savannah", "maintainer_email": "kata198@gmail.com", "name": "AdvancedHTMLParser", "package_url": "https://pypi.org/project/AdvancedHTMLParser/", "platform": "", "project_url": "https://pypi.org/project/AdvancedHTMLParser/", "project_urls": {"Homepage": "https://github.com/kata198/AdvancedHTMLParser"}, "release_url": "https://pypi.org/project/AdvancedHTMLParser/9.0.1/", "requires_dist": null, "requires_python": "", "summary": "A Powerful HTML Parser/Scraper/Validator/Formatter that constructs a modifiable, searchable DOM tree, and includes many standard JS DOM functions (getElementsBy*, appendChild, etc) and additional methods", "version": "9.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"advancedhtmlparser\">\n<h2>AdvancedHTMLParser</h2>\n<p>AdvancedHTMLParser is an Advanced HTML Parser, with support for adding, removing, modifying, and formatting HTML.</p>\n<p>It aims to provide the same interface as you would find in a compliant browser through javascript ( i.e. all the getElement methods, appendChild, etc), an XPath implementation, as well as many more complex and sophisticated features not available through a browser. And most importantly, it\u2019s in python!</p>\n<p>There are many potential applications, not limited to:</p>\n<blockquote>\n<ul>\n<li>Webpage Scraping / Data Extraction</li>\n<li>Testing and Validation</li>\n<li>HTML Modification/Insertion</li>\n<li>Outputting your website</li>\n<li>Debugging</li>\n<li>HTML Document generation</li>\n<li>Web Crawling</li>\n<li>Formatting HTML documents or web pages</li>\n</ul>\n</blockquote>\n<p>It is especially good for servlets/webpages. It is quick to take an expertly crafted page in raw HTML / css, and have your servlet\u2019s ingest with AdvancedHTMLParser and create/insert data elements into the existing view using a simple and well-known interface ( javascript-like + HTML DOM ).</p>\n<p>Another useful scenario is creating automated testing suites which can operate much more quickly and reliably (and at a deeper function-level), unlike in-browser testing suites.</p>\n<div id=\"full-api\">\n<h3>Full API</h3>\n<p>Can be found  <a href=\"http://htmlpreview.github.io/?https://github.com/kata198/AdvancedHTMLParser/blob/master/doc/AdvancedHTMLParser.html\" rel=\"nofollow\">http://htmlpreview.github.io/?https://github.com/kata198/AdvancedHTMLParser/blob/master/doc/AdvancedHTMLParser.html</a>?vers=8.1.8 .</p>\n</div>\n<div id=\"examples\">\n<h3>Examples</h3>\n<p>Various examples can be found in the \u201ctests\u201d directory. A very old, simple example can also be found as \u201cexample.py\u201d in the root directory.</p>\n</div>\n<div id=\"short-doc\">\n<h3>Short Doc</h3>\n<p><strong>The Package and Modules</strong></p>\n<p>The top-level module in this package is \u201c<em>AdvancedHTMLParser</em>.\u201d</p>\n<blockquote>\nimport AdvancedHTMLParser</blockquote>\n<p>Most everything \u201cpublic\u201d is available through this top-level module, but some corner-case usages may require importing from a submodule. All of these associations can be found through the pydocs.</p>\n<p>For example, to access AdvancedTag, the recommended path is just to import the top-level, and use dot-access:</p>\n<blockquote>\n<p>import AdvancedHTMLParser</p>\n<p>myTag = AdvancedHTMLParser.AdvancedTag(\u2018div\u2019)</p>\n</blockquote>\n<p>However, you can also import AdvancedTag through this top-level module:</p>\n<blockquote>\n<p>import AdvancedHTMLParser</p>\n<p>from AdvancedHTMLParser import AdvancedTag</p>\n</blockquote>\n<p>Or, you can import from the specific sub-module, directly:</p>\n<blockquote>\n<p>import AdvancedHTMLParser</p>\n<p>from AdvancedHTMLParser.Tags import AdvancedTag</p>\n</blockquote>\n<p>All examples below are written as if \u201cimport AdvancedHTMLParser\u201d has already been performed, and all relations in examples are based off usages from the top-level import, only.</p>\n<p><strong>AdvancedHTMLParser</strong></p>\n<p>Think of this like \u201cdocument\u201d in a browser.</p>\n<p>The AdvancedHTMLParser can read in a file (or string) of HTML, and will create a modifiable DOM tree from it. It can also be constructed manually from AdvancedHTMLParser.AdvancedTag objects.</p>\n<p>To populate an AdvancedHTMLParser from existing HTML:</p>\n<blockquote>\n<p>parser = AdvancedHTMLParser.AdvancedHTMLParser()</p>\n<p># Parse an HTML string into the document</p>\n<p>parser.parseStr(htmlStr)</p>\n<p># Parse an HTML file into the document</p>\n<p>parser.parseFile(filename)</p>\n</blockquote>\n<p>The parser then exposes many \u201cstandard\u201d functions as you\u2019d find on the web for accessing the data, and some others:</p>\n<blockquote>\n<p>getElementsByTagName   - Returns a list of all elements matching a tag name</p>\n<p>getElementsByName      - Returns a list of all elements with a given name attribute</p>\n<p>getElementById         - Returns a single AdvancedTag (or None) if found an element matching the provided ID</p>\n<p>getElementsByClassName - Returns a list of all elements containing one or more space-separated class names</p>\n<p>getElementsByAttr       - Returns a list of all elements matching a paticular attribute/value pair.</p>\n<p>getElementsByXPathExpression - Return a TagCollection (list) of all elements matching a given XPath expression</p>\n<p>getElementsWithAttrValues - Returns a list of all elements with a specific attribute name containing one of a list of values</p>\n<p>getElementsCustomFilter - Provide a function/lambda that takes a tag argument, and returns True to \u201cmatch\u201d it. Returns all matched objects</p>\n<p>getRootNodes            - Get a list of nodes at root level (0)</p>\n<p>getAllNodes             - Get all the nodes contained within this document</p>\n<p>getHTML                 - Returns string of HTML representing this DOM</p>\n<p>getFormattedHTML        - Returns a formatted string (using AdvancedHTMLFormatter; see below) of the HTML. Takes as argument an indent (defaults to four spaces)</p>\n<p>getMiniHTML             - Returns a \u201cmini\u201d HTML representation which disregards all whitespace and indentation beyond the functional single-space</p>\n</blockquote>\n<p>The results of all of these getElement* functions are TagCollection objects. This is a special kind of list which contains additional functions. See the \u201cTagCollection\u201d section below for more info.</p>\n<p>These objects can be modified, and will be reflected in the parent DOM.</p>\n<p>The parser also contains some expected properties, like</p>\n<blockquote>\n<p>head                    - The \u201chead\u201d tag associated with this document, or None</p>\n<p>body                    - The \u201cbody\u201d tag associated with this document, or None</p>\n<p>forms                   - All \u201cforms\u201d on this document as a TagCollection</p>\n</blockquote>\n<p><strong>General Attributes</strong></p>\n<p>In general, attributes can be accessed with dot-syntax, i.e.</p>\n<blockquote>\ntagEm.id = \u201cHello\u201d</blockquote>\n<p>will set the \u201cid\u201d attribute. If it works in HTML javascript on a tag element, it should work on an AdvancedTag element with python.</p>\n<p>setAttribute, getAttribute, and removeAttribute are more explicit and recommended ways of getting/setting/deleting attributes on elements.</p>\n<p>The same names are used in python as in the javascript/DOM, such as \u2018className\u2019 corrosponding to a space-separated string of the \u2018class\u2019 attribute, \u2018classList\u2019 corrosponding to a list of classes, etc.</p>\n<p><strong>Style Attribute</strong></p>\n<p>Style attributes can be manipulated just like in javascript, so element.style.position = \u2018relative\u2019 for setting, or element.style.position for access.</p>\n<p>You can also assign the tag.style as a string, like:</p>\n<blockquote>\nmyTag.style = \u201cdisplay: block; float: right; font-weight: bold\u201d</blockquote>\n<p>in addition to individual properties:</p>\n<blockquote>\n<p>myTag.style.display = \u2018block\u2019</p>\n<p>myTag.style.float = \u2018right\u2019</p>\n<p>myTag.style.fontWeight = \u2018bold\u2019</p>\n</blockquote>\n<p>You can remove style properties by setting its value to an empty string.</p>\n<p>For example, to clear \u201cdisplay\u201d property:</p>\n<blockquote>\nmyTag.style.display = \u2018\u2019</blockquote>\n<p>A standard method <em>setProperty</em> can also obe used to set or remove individual properties</p>\n<p>For example:</p>\n<blockquote>\n<p>myTag.style.setProperty(\u201cdisplay\u201d, \u201cblock\u201d) # Set display: block</p>\n<p>myTag.style.setProperty(\u201cdisplay\u201d, \u2018\u2019) # Clear display: property</p>\n</blockquote>\n<p>The naming conventions are the same as in javascript, like \u201celement.style.paddingTop\u201d for \u201cpadding-top\u201d attribute.</p>\n<p><strong>TagCollection</strong></p>\n<p>A TagCollection can be used like a list. Every element has a unique uuid associated with it, and a TagCollection will ensure that the same element does not appear twice within its list (so it acts like an ordered set)</p>\n<p>It also exposes the various getElement* functions which operate on the elements within the list (and their children).</p>\n<p>For example:</p>\n<blockquote>\n<p># Filter off the parser all tags with \u201citem\u201d in class</p>\n<p>tagCollection = document.getElementsByClassName(\u2018item\u2019)</p>\n<p># Return all nodes which are nested within any class=\u201ditem\u201d object</p>\n<p>#  and also contains the class name \u201consale\u201d</p>\n<p>itemsWithOnSaleClass = tagCollection.getElementsByClassName(\u2018onsale\u2019)</p>\n</blockquote>\n<p>To operate just on items in the list, you can use the TagCollection method, <em>filterCollection</em>, which takes a lambda/function and returns True to retain that tag in the return.</p>\n<p>For example:</p>\n<blockquote>\n<p># Filter off the parser all tags with \u201citem\u201d in class</p>\n<p>tagCollection = document.getElementsByClassName(\u2018item\u2019)</p>\n<p># Provide a lambda to filter this collection, returning in tagCollection2</p>\n<p>#   those items which have a \u201cvalue\u201d attribute &gt; 20 and contains at least</p>\n<p>#   1 child element with \u201cspecialPrice\u201d class</p>\n<p>tagCollection2 = tagCollection.filterCollection( lambda node : int(node.getAttribute(\u2018value\u2019) or 0) &gt; 20 and len(node.getElementsByClassName(\u2018specialPrice\u2019)) &gt; 1 )</p>\n</blockquote>\n<p>TagCollections also support advanced filtering (find/filter methods), see \u201cAdvanced Filtering\u201d section below.</p>\n<p><strong>AdvancedTag</strong></p>\n<p>The AdvancedTag represents a single tag and its inner text. It exposes many of the functions and properties you would expect to be present if using javascript.</p>\n<p>each AdvancedTag also supports the same getElementsBy* functions as the parser.</p>\n<p>It adds several additional that are not found in javascript, such as peers and arbitrary attribute searching.</p>\n<p>some of these include:</p>\n<blockquote>\n<p>appendText              - Append text to this element</p>\n<p>appendChild             - Append a child to this element</p>\n<p>appendBlock             - Append a block (text or AdvancedTag) to this element</p>\n<p>append                  - alias of appendBlock</p>\n<p>removeChild             - Removes a child</p>\n<p>removeText              - Removes first occurance of some text from any text nodes</p>\n<p>removeTextAll           - Removes ALL occurances of some text from any text nodes</p>\n<p>insertBefore            - Inserts a child before an existing child</p>\n<p>insertAfter             - Inserts a child after an existing child</p>\n<p>getChildren             - Returns the children as a list</p>\n<p>getStartTag             - Start Tag, with attributes</p>\n<p>getEndTag               - End Tag</p>\n<p>getPeersByName          - Gets \u201cpeers\u201d (elements with same parent, at same level in tree) with a given name</p>\n<p>getPeersByAttr          - Gets peers by an arbitrary attribute/value combination</p>\n<p>getPeersWithAttrValues  - Gets peers by an arbitrary attribute/values combination.</p>\n<p>getPeersByClassName   - Gets peers that contain a given class name</p>\n<p>getElement\\*            - Same as above, but act on the children of this element.</p>\n<p>getParentElementCustomFilter - Takes a lambda/function and applies on all parents of this element upward until the document root. Returns the first node that when passed to this function returns True, or None if no matches on any parent nodes</p>\n<p>getHTML / toHTML / asHTML - Get the HTML representation using this node as a root (so start tag and attributes, innerHTML (text and child nodes), and end tag)</p>\n<p>firstChild             - Get the first child of this node, be it text or an element (AdvancedTag)</p>\n<p>firstElementChild      - Get the first child of this node that is an element</p>\n<p>lastChild             - Get the last child of this node, be it text or an element (AdvancedTag)</p>\n<p>lastElementChild      - Get the last child of this node that is an element</p>\n<p>nextSibling            - Get next sibling, be it text  or  an element</p>\n<p>nextElementSibling     - Get next sibling, that is an element</p>\n<p>previousSibling            - Get previous sibling, be it text  or  an element</p>\n<p>previousElementSibling     - Get previous sibling, that is an element</p>\n<p>{get,set,has,remove}Attribute  - get/set/test/remove an attribute</p>\n<p>{add,remove}Class       - Add/remove a class from the list of classes</p>\n<p>setStyle                - Set a specific style property [like: setStyle(\u201cfont-weight\u201d, \u201cbold\u201d) ]</p>\n<p>isTagEqual              - Compare if two tags have the same attributes. Using the == operator will compare if they are the same exact tag (by uuid)</p>\n<p>getUid                  - Get a unique ID for this tag (internal)</p>\n<p>getAllChildNodes        - Gets all nodes beneath this node in the document (its children, its children\u2019s children, etc)</p>\n<p>getAllNodes             - Same as getAllChildNodes, but also includes this node</p>\n<p>contains                - Check if a provided node appears anywhere beneath this node (as child, child-of-child, etc)</p>\n<p>remove                  - Remove this node from its parent element, and disassociates this and all sub-nodes from the associated document</p>\n<p>__str__                 - str(tag) will show start tag with attributes, inner text, and end tag</p>\n<p>__repr__                - Shows a reconstructable representation of this tag</p>\n<p>__getitem__             - Can be indexed like tag[2] to access second child.</p>\n</blockquote>\n<p>And some properties:</p>\n<blockquote>\n<p>children/childNodes     - The children (tags) as a list NOTE: This returns only AdvancedTag objects, not text.</p>\n<p>childBlocks             - All direct child blocks. This includes both AdvnacedTag objects and text nodes (str)</p>\n<p>innerHTML               - The innerHTML including the html of all children</p>\n<p>innerText               - The text nodes, in order, as they appear as direct children to this node as a string</p>\n<p>textContent             - All the text nodes, in order, as they appear within this node or any children (or their children, etc.)</p>\n<p>outerHTML               - innerHTML wrapped in this tag</p>\n<p>classNames/classList    - a list of the classes</p>\n<p>parentNode/parentElement - The parent tag</p>\n<p>tagName                - The tag name</p>\n<p>ownerDocument          - The document associated with this node, if any</p>\n</blockquote>\n<p>And many others. See the pydocs for a full list, and associated docstrings.</p>\n<p><strong>Appending raw HTML</strong></p>\n<p>You can append raw HTML to a tag by calling:</p>\n<blockquote>\ntagEm.appendInnerHTML(\u2018&lt;div id=\u201dSome sample HTML\u201d&gt; &lt;span&gt; Yes &lt;/span&gt; &lt;/div&gt;\u2019)</blockquote>\n<p>which acts like, in javascript:</p>\n<blockquote>\ntagEm.innerHTML += \u2018&lt;div id=\u201dSome sample HTML\u201d&gt; &lt;span&gt; Yes &lt;/span&gt; &lt;/div&gt;\u2019;</blockquote>\n<p><strong>Creating Tags from HTML</strong></p>\n<p>Tags can be created from HTML strings outside of AdvancedHTMLParser.parseStr (which parses an entire document) by:</p>\n<ul>\n<li>Parser.AdvancedHTMLParser.createElement - Like document.createElement, creates a tag with a given tag name. Not associated with any document.</li>\n<li>Parser.AdvancedHTMLParser.createElementFromHTML - Creates a single tag from HTML.</li>\n<li>Parser.AdvancedHTMLParser.createElementsFromHTML - Creates and returns a list of one or more tags from HTML.</li>\n<li>Parser.AdvancedHTMLParser.createBlocksFromHTML - Creates and returns a list of blocks. These can be AdvancedTag objects (A tag), or a str object (if raw text outside of tags). This is recommended for parsing arbitrary HTML outside of parsing the entire document. The createElement{,s}FromHTML functions will discard any text outside of the tags passed in.</li>\n</ul>\n</div>\n<div id=\"advanced-filtering\">\n<h3>Advanced Filtering</h3>\n<p>AdvancedHTMLParser contains two kinds of \u201cAdvanced Filtering\u201d:</p>\n<p><strong>find</strong></p>\n<p>The most basic unified-search, AdvancedHTMLParser has a \u201cfind\u201d method on it. This will search all nodes with a single, simple query.</p>\n<p>This is not as robust as the \u201cfilter\u201d method (which can also be used on any tag or TagCollection), but does not require any dependency packages.</p>\n<blockquote>\n<p>find - Perform a search of elements using attributes as keys and potential values as values</p>\n<blockquote>\n<p>(i.e.  parser.find(name=\u2019blah\u2019, tagname=\u2019span\u2019)  will return all elements in this document</p>\n<blockquote>\nwith the name \u201cblah\u201d of the tag type \u201cspan\u201d )</blockquote>\n</blockquote>\n<p>Arguments are key = value, or key can equal a tuple/list of values to match ANY of those values.</p>\n<p>Append a key with __contains to test if some strs (or several possible strs) are within an element</p>\n<p>Append a key with __icontains to perform the same __contains op, but ignoring case</p>\n<p>Special keys:</p>\n<blockquote>\n<p>tagname    - The tag name of the element</p>\n<p>text       - The text within an element</p>\n</blockquote>\n<p>NOTE: Empty string means both \u201cnot set\u201d and \u201cno value\u201d in this implementation.</p>\n</blockquote>\n<p>Example:</p>\n<blockquote>\ncheddarElements = parser.find(name=\u2019items\u2019, text__icontains=\u2019cheddar\u2019)</blockquote>\n<p><strong>filter</strong></p>\n<p>If you have QueryableList installed (a default dependency since 7.0.0 to AdvancedHTMLParser, but can be skipped with \u2018\u2013no-deps\u2019 passed to setup.py)</p>\n<p>then you can take advantage of the advanced \u201cfilter\u201d methods, on either the parser (entire document), any tag (that tag and nodes beneath), or tag collection (any of those tags, or any tags beneath them).</p>\n<p>A full explanation of the various filter modes that QueryableList supports can be found at <a href=\"https://github.com/kata198/QueryableList\" rel=\"nofollow\">https://github.com/kata198/QueryableList</a></p>\n<p>Special keys are: \u201ctagname\u201d for the tag name, and \u201ctext\u201d for the inner text of a node.</p>\n<p>An attribute that is unset has a value of None, which is different than a set attribute with an empty value \u2018\u2019.</p>\n<p>For example:</p>\n<blockquote>\ncheddarElements = parser.filter(name=\u2019items\u2019, text__icontains=\u2019cheddar\u2019)</blockquote>\n<p>The AdvancedHTMLParser has:</p>\n<blockquote>\n<p>filter / filterAnd      - Perform a filter query on all nodes in this document, returning a TagCollection of elements matching ALL criteria</p>\n<p>filterOr                - Perform a filter query on all nodes in this document, returning a TagCollection of elements matching ANY criteria</p>\n</blockquote>\n<p>Every AdvancedTag has:</p>\n<blockquote>\n<p>filter / filterAnd      - Perform a filter query on this nodes and all sub-nodes, returning a TagCollection of elements matching ALL criteria</p>\n<p>filterOr                - Perform a filter query on this nodes and all sub-nodes, returning a TagCollection of elements matching ANY criteria</p>\n</blockquote>\n<p>Every TagCollection has:</p>\n<blockquote>\n<p>filter / filterAnd      - Perform a filter query on JUST the nodes contained within this list (no children), returning a TagCollection of elements matching ALL criteria</p>\n<p>filterOr                - Perform a filter query on JUST the nodes contained within this list (no children), returning a TagCollection of elements matching ANY criteria</p>\n<p>filterAll / filterAllAnd - Perform a filter query on the nodes contained within this list, and all of their sub-nodes, returning a TagCollection of elements matching ALL criteria</p>\n<p>filterAllOr              - Perform a filter query on the nodes contained within this list, and all of their sub-nodes, returning a TagCollection of elements matching ANY criteria</p>\n</blockquote>\n</div>\n<div id=\"validation\">\n<h3>Validation</h3>\n<p>Validation can be performed by using ValidatingAdvancedHTMLParser. It will raise an exception if an assumption would have to be made to continue parsing (i.e. something important).</p>\n<p>InvalidCloseException - Tried to close a tag that shouldn\u2019t have been closed</p>\n<p>MissedCloseException  - Missed a non-optional close of a tag that would lead to causing an assumption during parsing.</p>\n<p>InvalidAttributeNameException - An attribute name was found that contained an invalid character, or broke a naming rule.</p>\n</div>\n<div id=\"xpath\">\n<h3>XPath</h3>\n<p><strong>XPath support is in Beta phase.</strong></p>\n<p>Basic XPath support has been added, which supports searching, attribute matching, positions, indexes, some functions, most axes (such as parent::).</p>\n<p>Examples of some currently supported expressions:</p>\n<blockquote>\n//table//tr[last()]/parent::tbody</blockquote>\n<p>Find any table, descend to any descendant that is the last tr of its parent, rise to and return the parent tbody of that tr.</p>\n<blockquote>\n//div[ @name = \u201cCheese\u201d ]/span[2]</blockquote>\n<p>Find any div with attribute name=\u201dCheese\u201d , and return the second direct child which is a span.</p>\n<blockquote>\n//*[ normalize-space() = \u201cBanana\u201d ]</blockquote>\n<p>Find and return any tag which contains the inner text, normalized for whitespace, of \u201cBanana\u201d</p>\n<p>Find and return any tag under a div containing a class \u201cpurple-cheese\u201d</p>\n<blockquote>\n//div/*[ contains( concat( \u2018 \u2018, @class, \u2018 \u2018 ), \u2018purple-cheese\u2019 ) ]</blockquote>\n<p>More will be added. If you have a needed xpath feature not currently supported (you\u2019ll know by parse exception raised), please open an issue and I will make it a priority!</p>\n</div>\n</div>\n<div id=\"indexedadvancedhtmlparser\">\n<h2>IndexedAdvancedHTMLParser</h2>\n<p>IndexedAdvancedHTMLParser provides the ability to use indexing for faster search. If you are just parsing and not modifying, this is your best bet. If you are modifying the DOM tree, make sure you call IndexedAdvancedHTMLParser.reindex() before relying on them.</p>\n<p>Each of the get* functions above takes an additional \u201cuseIndex\u201d function, which can also be set to False to skip index. See constructor for more information, and \u201cPerformance and Indexing\u201d section below.</p>\n<div id=\"advancedhtmlformatter-and-formathtml\">\n<h3>AdvancedHTMLFormatter and formatHTML</h3>\n<p><strong>AdvancedHTMLFormatter</strong></p>\n<p>The AdvancedHTMLFormatter formats HTML into a pretty layout. It can handle elements like pre, core, script, style, etc to keep their contents preserved, but does not understand CSS rules.</p>\n<p>The methods are:</p>\n<blockquote>\n<p>parseStr               - Parse a string of contents</p>\n<p>parseFile              - Parse a filename or file object</p>\n<p>getHTML                - Get the formatted html</p>\n<p>getRootNodes           - Get a list of the \u201croot\u201d nodes (most outer nodes, should be &lt;html&gt; on a valid document)</p>\n<p>getRoot                - Gets the \u201croot\u201d node (on a valid document this should be &lt;html&gt;). For arbitrary HTML, you should use getRootNodes, as there may be several nodes at the same outermost level</p>\n</blockquote>\n<p>You can access this same formatting off an AdvancedHTMLParser.AdvancedHTMLParser (or IndexedAdvancedHTMLParser) by calling .getFormattedHTML()</p>\n<p><strong>AdvancedHTMLMiniFormatter</strong></p>\n<p>The AdvancedHTMLMiniFormatter will strip all non-functional whitespace (meaning any whitespace which wouldn\u2019t normally add a space to the document or is required for xhtml) and provide no indentation.</p>\n<p>Use this when pretty-printing doesn\u2019t matter and you\u2019d like to save space.</p>\n<p>You can access this same formatting off an AdvancedHTMLParser.AdvancedHTMLParser (or IndexedAdvancedHTMLParser) by calling .getMiniHTML()</p>\n<p><strong>AdvancedHTMLSlimTagFormatter and AdvancedHTMLSlimTagMiniFormatter</strong></p>\n<p>In order to support some less-leniant parsers, AdvancedHTMLParser will by default include a space prior to the close-tag \u2018&gt;\u2019 character in HTML output.</p>\n<p>For example:</p>\n<blockquote>\n<p>&lt;span id=\u201dabc\u201d &gt;Blah&lt;/span&gt;</p>\n<p>&lt;br /&gt;</p>\n<p>&lt;hr class=\u201dbigline\u201d /&gt;</p>\n</blockquote>\n<p>It is recommended to keep these extra spaces, but if for some reason you feel you need to get rid of them, you can use either <em>AdvancedHTMLSlimTagFormatter</em> or <em>AdvancedHTMLSlimTagMiniFormatter</em>.</p>\n<p><em>AdvancedHTMLSlimTagFormatter</em> will do pretty-printing (like getFormattedHTML / AdvancedHTMLFormatter.getHTML output)</p>\n<p><em>AdvancedHTMLSlimTagMiniFormatter</em> will do mini-printing (like getMiniHTML / AdvancedHTMLMiniFormatter.getHTML output)</p>\n<p>Feeding in your HTML via formatter.parseStr(htmlStr) [where htmlStr can be parser.getHTML()] will cause it to be output without the start-tag padding.</p>\n<p>For example:</p>\n<blockquote>\n&lt;span id=\u201dabc\u201d&gt;Blah&lt;/span&gt;</blockquote>\n<p>By default, self-closing tags will retain their padding so that an xhtml-compliant parser doesn\u2019t treat \u201c/\u201d as either an attribute or part of the attribute-value of the preceding attribute.</p>\n<p>For example:</p>\n<blockquote>\n&lt;hr class=\u201dbigline\u201d/&gt;</blockquote>\n<p>Could be interpreted as a horizontal rule with a class name of \u201cbigline/\u201d. Most modern browsers work around this and will not have issue, but some parsers will.</p>\n<p>You may pass an optional keyword-argument to the formatter constructor, slimSelfClosing=True, in order to force removal of this padding from self-closing tags.</p>\n<p>For example:</p>\n<blockquote>\n<p>myHtml = \u2018&lt;hr class=\u201dbigline\u201d /&gt;\u2019</p>\n<p>formatter = AdvancedHTMLSlimTagMiniFormatter(slimSelfClosing=True)</p>\n<p>formatter.parseStr(myHtml)</p>\n<p>miniHtml = formatter.getHTML()</p>\n<p># miniHtml will now contain \u2018&lt;hr class=\u201dbigline\u201d/&gt;\u2019</p>\n</blockquote>\n<p>.</p>\n<p><strong>formatHTML script</strong></p>\n<p>A script, formatHTML comes with this package and will perform formatting on an input file, and output to a file or stdout:</p>\n<blockquote>\n<p>Usage: formatHTML (Optional Arguments) (optional: /path/to/in.html) (optional: [/path/to/output.html])</p>\n<blockquote>\n<blockquote>\nFormats HTML on input and writes to output.</blockquote>\n<p>Optional Arguments:</p>\n<p>\u2014\u2014\u2014\u2014\u2014\u2014-</p>\n<blockquote>\n<p>-e [encoding]        - Specify an encoding to use. Default is utf-8</p>\n<p>-m  or \u2013mini        - Output \u201cmini\u201d HTML (only retain functional whitespace,</p>\n<blockquote>\nstrip the rest and no indentation)</blockquote>\n<p>-p  or \u2013pretty      - Output \u201cpretty\u201d HTML [This is the defualt mode]</p>\n<p>\u2013indent=\u2019    \u2018      - Use the provided string [default 4-spaces] to represent each</p>\n<blockquote>\n<blockquote>\nlevel of nesting. Use \u2013indent=\u201d      \u201d for 1 tab insead, for example.</blockquote>\n<p>Affects pretty printing mode only</p>\n</blockquote>\n</blockquote>\n<p>If output filename is not specified or is empty string, output will be to stdout.</p>\n<p>If input filename is not specified or is empty string, input will be from stdin</p>\n<p>If -e is provided, will use that as the encoding. Defaults to utf-8</p>\n</blockquote>\n</blockquote>\n</div>\n<div id=\"notes\">\n<h3>Notes</h3>\n<ul>\n<li>Each tag has a generated unique ID which is assigned at create time. The search functions use these to prevent duplicates in search results. There is a global function in the module, AdvancedHTMLParser.uniqueTags, which will filter a list of tags and remove any duplicates. TagCollections will only allow one instance of a tag (no duplicates)</li>\n<li>In general, for tag names and attribute names, you should use lowercase values. During parsing, the parser will lowercase attribute names (like NAME=\u201dAbc\u201d becomes name=\u201dAbc\u201d). During searching, however, for performance reasons, it is assumed you are passing in already-lowercased strings. If you can\u2019t trust the input to be lowercase, then it is your responsibility to call .lower() before calling .getElementsBy*</li>\n<li>If you are using IndexedAdvancedHTMLParser (instead of AdvancedHTMLParser) to construct HTML and not search, I recommend either setting the index params to False in the constructor, or calling  IndexedAdvancedHTMLParser.disableIndexing(). When you are finished and want to go back to searching, you can call IndexedAdvancedHTMLParser.reindex and set to True what you want to reindex.</li>\n<li>There are additional functions and usages not documented here, check the file for more information.</li>\n</ul>\n</div>\n<div id=\"performance-and-indexing\">\n<h3>Performance and Indexing</h3>\n<p>Performance is very good using either AdvancedHTMLParser, and even better (for scraping) using IndexedAdvancedHTMLParser class. The performance can be further enhanced on IndexedAdvancedHTMLParser via several indexing tunables:</p>\n<p>First, in the constructor of IndexedAdvancedHTMLParser and in the reindex method is a boolean to be set which determines if each field is indexed (e.x. indexIDs will make getElementByID use an index).</p>\n<p>If an index is used, parsing time slightly goes up, but searches become O(1) (from root node, slightly less efficent from other nodes) instead of O(n) [n=num elements].</p>\n<p>By default, IDs, Names, Tag Names, Class Names are indexed.</p>\n<p>You can add an index for any arbitrary field (used in getElementByAttr) via IndexedAdvancedHTMLParser.addIndexOnAttribute(\u2018src\u2019), for example, to index the \u2018src\u2019 attribute. This index can be removed via removeIndexOnAttribute.</p>\n</div>\n<div id=\"dependencies\">\n<h3>Dependencies</h3>\n<p>AdvancedHTMLParser can be installed without dependencies (pass \u2018\u2013no-deps\u2019 to setup.py), and everything will function EXCEPT filter* methods.</p>\n<p>By default, <a href=\"https://github.com/kata198/QueryableList\" rel=\"nofollow\">https://github.com/kata198/QueryableList</a> will be installed, which will enable support for those additional filter methods.</p>\n</div>\n<div id=\"unicode\">\n<h3>Unicode</h3>\n<p>AdvancedHTMLParser generally has very good support for unicode, and defaults to \u201cutf-8\u201d (can be altered by the \u201cencoding\u201d argument to the AdvancedHTMLParser.AdvancedHTMLParser when parsing.)</p>\n<p>If you are still getting UnicodeDecodeError or UnicodeEncodeError, there are a few things you can try:</p>\n<ul>\n<li><p>If the error happens when printing/writing to stdout ( default behaviour for apache / mod_python is to open stdout with the ANSI/ASCII encoding ), ensure your streams are, in fact, set to utf-8.</p>\n<blockquote>\n<p>* Set the environment variable PYTHONIOENCODING to \u201cutf-8\u201d before python is launched. In Apache, you can add the line \u201cSetEnv PYTHONIOENCODING utf-8\u201d to your httpd.conf in order to achieve this.</p>\n</blockquote>\n</li>\n<li><p>Ensure that the data you are passing to AdvancedHTMLParser has the correct encoding (matching the \u201cencoding\u201d parameter).</p>\n</li>\n<li><p>Switch to python3 if at all possible \u2013 python2 does have \u2018unicode\u2019 support and AdvancedHTMLParser uses it to the best of its ability, but python2 does still have some inherit flaws which may come up using standard library / output functions. You should ensure that these are set to use utf-8 (as described above).</p>\n</li>\n</ul>\n<p>AdvancedHTMLParser is tested against unicode ( even has a unit test ) which works in both python2 and python3 in the general case.</p>\n<p>If you are having an issue (even on python2) and you\u2019ve checked the above \u201ccommon configuration/usage\u201d errors and think there is still an issue, please open a bug report on <a href=\"https://github.com/kata198/AdvancedHTMLParser\" rel=\"nofollow\">https://github.com/kata198/AdvancedHTMLParser</a> with a test case, python version, and traceback.</p>\n<p>The library itself is considered unicode-safe, and almost always it\u2019s an issue outside of this library, or has a simple workaround.</p>\n</div>\n<div id=\"example-usage\">\n<h3>Example Usage</h3>\n<p>See <a href=\"https://raw.githubusercontent.com/kata198/AdvancedHTMLParser/master/example.py\" rel=\"nofollow\">https://raw.githubusercontent.com/kata198/AdvancedHTMLParser/master/example.py</a> for an example of parsing store data using this class.</p>\n</div>\n<div id=\"changes\">\n<h3>Changes</h3>\n<p>See: <a href=\"https://raw.githubusercontent.com/kata198/AdvancedHTMLParser/master/ChangeLog\" rel=\"nofollow\">https://raw.githubusercontent.com/kata198/AdvancedHTMLParser/master/ChangeLog</a></p>\n</div>\n<div id=\"contact-me-support\">\n<h3>Contact Me / Support</h3>\n<p>I am available by email to provide support, answer questions, or otherwise  provide assistance in using this software. Use my email kata198 at gmail.com with \u201cAdvancedHTMLParser\u201d in the subject line.</p>\n<p>If you are having an issue / found a bug / want to merge in some changes, please open a pull request.</p>\n</div>\n<div id=\"unit-tests\">\n<h3>Unit Tests</h3>\n<p>See \u201ctests\u201d directory available in github. Use \u201crunTests.py\u201d within that directory. Tests use my <a href=\"https://github.com/kata198/GoodTests\" rel=\"nofollow\">GoodTests</a> framework. It will download it to the current directory if not found in path, so you don\u2019t need to worry that it\u2019s a dependency.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6619098, "releases": {"5.0.1": [{"comment_text": "", "digests": {"md5": "66ed30a9bc9259b22fbac83844741539", "sha256": "22f0d979ff50d480833f0bd58780afd8a7d0c8f99720a0d3cd4e1be0ba28840a"}, "downloads": -1, "filename": "AdvancedHTMLParser-5.0.1.tar.gz", "has_sig": false, "md5_digest": "66ed30a9bc9259b22fbac83844741539", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14066, "upload_time": "2015-06-10T17:55:59", "upload_time_iso_8601": "2015-06-10T17:55:59.316881Z", "url": "https://files.pythonhosted.org/packages/d6/01/e409030c80a0f457740739986874104c2d5e24875fb8f28ef218d0557e86/AdvancedHTMLParser-5.0.1.tar.gz", "yanked": false}], "6.0.0": [{"comment_text": "", "digests": {"md5": "8d58f4a4e95384652b784b3d7d5954ba", "sha256": "f8269f82d6727828cb5d768e35a42fc2475ee552047245596afa054129f2b975"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.0.0.tar.gz", "has_sig": false, "md5_digest": "8d58f4a4e95384652b784b3d7d5954ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17256, "upload_time": "2015-06-24T03:55:30", "upload_time_iso_8601": "2015-06-24T03:55:30.553174Z", "url": "https://files.pythonhosted.org/packages/de/6e/dded58429b47eb80701ac2344fd17441f8be34bfa0644e3b0ea522821508/AdvancedHTMLParser-6.0.0.tar.gz", "yanked": false}], "6.0.1": [{"comment_text": "", "digests": {"md5": "c037ec9ea8c78949ead5692866d4c6e8", "sha256": "9788ee300ffe6087ba7f89e761bb4e40b0f0bfd756380d88772d681a2641771c"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.0.1.tar.gz", "has_sig": false, "md5_digest": "c037ec9ea8c78949ead5692866d4c6e8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19291, "upload_time": "2015-06-27T23:53:39", "upload_time_iso_8601": "2015-06-27T23:53:39.111770Z", "url": "https://files.pythonhosted.org/packages/c8/af/7f76b8726b53d30cd2056abe9e53c695c9d3a74aa863dc58c189c4d77632/AdvancedHTMLParser-6.0.1.tar.gz", "yanked": false}], "6.1.0": [{"comment_text": "built for Linux-3.17.4-1-ck2-ck-x86_64-with-glibc2.2.5", "digests": {"md5": "0ce939f1e699e2d4ccf8cd6926677850", "sha256": "9987df1561c9fdfd87f9e200a34b5b2354b498f0839710f7c71903ffe1520371"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.1.0.linux-x86_64.tar.gz", "has_sig": false, "md5_digest": "0ce939f1e699e2d4ccf8cd6926677850", "packagetype": "bdist_dumb", "python_version": "any", "requires_python": null, "size": 36213, "upload_time": "2015-08-05T05:03:59", "upload_time_iso_8601": "2015-08-05T05:03:59.432991Z", "url": "https://files.pythonhosted.org/packages/53/10/25c2300e97aabc0b305ecc2255a4e7658c9f5313af4afd17d6737ebf0401/AdvancedHTMLParser-6.1.0.linux-x86_64.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "dbc2f07c5174ba7b1253346a863b3745", "sha256": "493d5e64a28b6bdb0a8cecb7896a4d31127541f3411cd17f650b53b32ce74326"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.1.0-py2-none-any.whl", "has_sig": false, "md5_digest": "dbc2f07c5174ba7b1253346a863b3745", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 27166, "upload_time": "2015-08-05T05:04:03", "upload_time_iso_8601": "2015-08-05T05:04:03.084771Z", "url": "https://files.pythonhosted.org/packages/ea/45/f52eb34b24ed1fabaf98e751e80039a110aeff7d841e8b33999dbb26a760/AdvancedHTMLParser-6.1.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d5ec4211c774dc00dfd0c29bcfecbb53", "sha256": "9801b0b459c64e124ec47ef92df08e9223d392edd41396286bf1b043250927ad"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d5ec4211c774dc00dfd0c29bcfecbb53", "packagetype": "bdist_wheel", "python_version": "3.4", "requires_python": null, "size": 27169, "upload_time": "2015-08-05T05:05:00", "upload_time_iso_8601": "2015-08-05T05:05:00.610578Z", "url": "https://files.pythonhosted.org/packages/4c/ff/c9e9dbc215fc2a14677631204e49ba5c461a765bd19dd4044da4bde95455/AdvancedHTMLParser-6.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "728e155297855533cd08bef80f18d89f", "sha256": "77860f68908eafeef4ba4ce13b93ec144b6eceff874a907b8aa4e2e9aeddb5ac"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.1.0.tar.gz", "has_sig": false, "md5_digest": "728e155297855533cd08bef80f18d89f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25656, "upload_time": "2015-08-05T05:03:56", "upload_time_iso_8601": "2015-08-05T05:03:56.185317Z", "url": "https://files.pythonhosted.org/packages/7a/0b/04d6383328ec7482a6747dd95ff17bc1bbc3a79eac0ed7567944aab9f57e/AdvancedHTMLParser-6.1.0.tar.gz", "yanked": false}], "6.2.1": [{"comment_text": "", "digests": {"md5": "ed99f9cc0ab1e56ad0de37165addce3f", "sha256": "43c4ac6410b919b3fc752820e2ec5532698395c83e8a6eaa78a5aa097df89eb8"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.2.1.tar.gz", "has_sig": false, "md5_digest": "ed99f9cc0ab1e56ad0de37165addce3f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 66731, "upload_time": "2015-08-11T03:41:50", "upload_time_iso_8601": "2015-08-11T03:41:50.986959Z", "url": "https://files.pythonhosted.org/packages/8b/7c/62572803f8a903181bd856216110aa31673acd08d8bfa2482d45cc37fa39/AdvancedHTMLParser-6.2.1.tar.gz", "yanked": false}], "6.2.2": [], "6.2.2.0": [{"comment_text": "", "digests": {"md5": "9cf7ff7d3c8f4d1e774f903b1f62bd33", "sha256": "fa182c472121fc43b4d6b5f71aa022e18cbf6bde3d0a2e3c5cec0ac37e443bf7"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.2.2.0.tar.gz", "has_sig": false, "md5_digest": "9cf7ff7d3c8f4d1e774f903b1f62bd33", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67149, "upload_time": "2015-08-17T17:09:38", "upload_time_iso_8601": "2015-08-17T17:09:38.431410Z", "url": "https://files.pythonhosted.org/packages/61/d8/ed729010da0a62914351ceb5798170c2f318ce508361a5ca12808bb81ae0/AdvancedHTMLParser-6.2.2.0.tar.gz", "yanked": false}], "6.2.3": [{"comment_text": "", "digests": {"md5": "e42e1221f8f6d40b1b7dcbd58f309e2f", "sha256": "91394e9067fb9bfddf1873f34503c88023dcd5c8ae4d9c1cac4f6d68f553ea92"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.2.3.tar.gz", "has_sig": false, "md5_digest": "e42e1221f8f6d40b1b7dcbd58f309e2f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56388, "upload_time": "2015-08-18T20:02:31", "upload_time_iso_8601": "2015-08-18T20:02:31.008078Z", "url": "https://files.pythonhosted.org/packages/2f/90/cb49a14aaee169e2d0a90259d62b91760f18d891cccee7109ae7949a350c/AdvancedHTMLParser-6.2.3.tar.gz", "yanked": false}], "6.2.4": [{"comment_text": "", "digests": {"md5": "56032a81437d1c2a6b98c0bb4d9b536b", "sha256": "da81d650e309e4e34ff1b1e0b3f9da7d285cd226769f297d7ad3bc7a09a06e1d"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.2.4.tar.gz", "has_sig": false, "md5_digest": "56032a81437d1c2a6b98c0bb4d9b536b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56518, "upload_time": "2015-08-18T20:15:07", "upload_time_iso_8601": "2015-08-18T20:15:07.671675Z", "url": "https://files.pythonhosted.org/packages/1f/aa/51d0f339980062d92cdd64a97f59cb8fa4c2504c4bb66b76d237a0d47d1f/AdvancedHTMLParser-6.2.4.tar.gz", "yanked": false}], "6.2.5": [{"comment_text": "", "digests": {"md5": "5b637b9ff24e2efa5136df0e571f0cf2", "sha256": "11e6a0793e19ed6e9b39996566013f62b5cb8c501d456dff5b97fd9dae2ee2a5"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.2.5.tar.gz", "has_sig": false, "md5_digest": "5b637b9ff24e2efa5136df0e571f0cf2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 57779, "upload_time": "2015-08-18T20:32:23", "upload_time_iso_8601": "2015-08-18T20:32:23.224553Z", "url": "https://files.pythonhosted.org/packages/ec/11/c757fbb891f6c709422963ff53781510979d36c37302e4ab9d409fccd2c1/AdvancedHTMLParser-6.2.5.tar.gz", "yanked": false}], "6.3.0": [{"comment_text": "", "digests": {"md5": "bfe25d7dcae9bf9fb060d47a3a04af36", "sha256": "068be12454d849e4aa8b89ccdd3e204bb77af58cbeec27ad6456158d572b129d"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.3.0.tar.gz", "has_sig": false, "md5_digest": "bfe25d7dcae9bf9fb060d47a3a04af36", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63936, "upload_time": "2015-09-04T19:06:52", "upload_time_iso_8601": "2015-09-04T19:06:52.273327Z", "url": "https://files.pythonhosted.org/packages/a9/a7/6ae5f1671a9ce46a9d8f71633c20441aa07e4f1c1d275947169568071441/AdvancedHTMLParser-6.3.0.tar.gz", "yanked": false}], "6.4.0": [{"comment_text": "", "digests": {"md5": "b80f3a3604044a9b524f2df0b8f89d4e", "sha256": "b22a2e67fd3158bffa02ce60527ecad49ad4e62ea91b860402593a4897d88807"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.4.0.tar.gz", "has_sig": false, "md5_digest": "b80f3a3604044a9b524f2df0b8f89d4e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75008, "upload_time": "2015-10-16T03:38:46", "upload_time_iso_8601": "2015-10-16T03:38:46.225401Z", "url": "https://files.pythonhosted.org/packages/eb/de/a82531ecaa13406c416c993d1a523ce837a7b4f4aea086c05cfa4782ff79/AdvancedHTMLParser-6.4.0.tar.gz", "yanked": false}], "6.4.1": [{"comment_text": "", "digests": {"md5": "660902dd06829f4e596fc2785a16efe5", "sha256": "567cdc5ef68a4473d3ac86d9dfe71394b3557b3244e8b45ad61e6b450fa92a58"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.4.1.tar.gz", "has_sig": false, "md5_digest": "660902dd06829f4e596fc2785a16efe5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75060, "upload_time": "2015-10-16T03:43:42", "upload_time_iso_8601": "2015-10-16T03:43:42.970841Z", "url": "https://files.pythonhosted.org/packages/e1/58/70d015bdc38649468c5218f826118513722b7924eb728f8b3aeba28a5158/AdvancedHTMLParser-6.4.1.tar.gz", "yanked": false}], "6.4.2": [{"comment_text": "", "digests": {"md5": "aa5f1496817b5440de6457c809f27e22", "sha256": "b207f2c1688c763241b737b52b100320c1ebee2220b84bd1dbf088a214eeeb74"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.4.2.tar.gz", "has_sig": false, "md5_digest": "aa5f1496817b5440de6457c809f27e22", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67184, "upload_time": "2015-10-19T16:20:04", "upload_time_iso_8601": "2015-10-19T16:20:04.956289Z", "url": "https://files.pythonhosted.org/packages/03/2e/38341885281014f750e1433829079c1920641e4daae3ce34f948d0f92558/AdvancedHTMLParser-6.4.2.tar.gz", "yanked": false}], "6.5.0": [{"comment_text": "", "digests": {"md5": "b2f213196099ccfed3295d00ed882024", "sha256": "bfe5804c7b8bcb975e089f8c4047baa263dc6bdae261853df71d2beac657652c"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.5.0.tar.gz", "has_sig": false, "md5_digest": "b2f213196099ccfed3295d00ed882024", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 82599, "upload_time": "2015-12-24T20:07:28", "upload_time_iso_8601": "2015-12-24T20:07:28.437292Z", "url": "https://files.pythonhosted.org/packages/3a/36/5e77d466864ae0c3bc855917b863595435a721e4cc12da56506613400a9d/AdvancedHTMLParser-6.5.0.tar.gz", "yanked": false}], "6.5.1": [{"comment_text": "", "digests": {"md5": "b3d61d043350a9745d582208d3918b0f", "sha256": "f01315bc13d71b94a01e07118c52fc2eb761bd1e71282776039b5abf6dd65f83"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.5.1.tar.gz", "has_sig": false, "md5_digest": "b3d61d043350a9745d582208d3918b0f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 74569, "upload_time": "2016-03-25T18:33:06", "upload_time_iso_8601": "2016-03-25T18:33:06.994721Z", "url": "https://files.pythonhosted.org/packages/d0/2f/487ca213a57654dc02dfeb62d944ff7b109efef5d05a5cce752570077a21/AdvancedHTMLParser-6.5.1.tar.gz", "yanked": false}], "6.6.0": [{"comment_text": "", "digests": {"md5": "cb11e52fa62a700305cf0c2c2655b2e9", "sha256": "17b29804cb5f13175ef10e275dc7c6d33a56ea99dee840d8334b7f7e962adf52"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.6.0.tar.gz", "has_sig": false, "md5_digest": "cb11e52fa62a700305cf0c2c2655b2e9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 98226, "upload_time": "2016-07-25T16:42:13", "upload_time_iso_8601": "2016-07-25T16:42:13.576322Z", "url": "https://files.pythonhosted.org/packages/de/d1/499f6385375a77f80107f893f73a025286a7927450bc9286b2669c82229e/AdvancedHTMLParser-6.6.0.tar.gz", "yanked": false}], "6.6.1": [{"comment_text": "", "digests": {"md5": "bb89bf8c83da978818941188aee4c0e1", "sha256": "45399a537fc4aacfea0a48ba0b4577d0fb67f00c6e6578063ad60a47219aeb5e"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.6.1.tar.gz", "has_sig": false, "md5_digest": "bb89bf8c83da978818941188aee4c0e1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 110809, "upload_time": "2016-07-27T04:03:57", "upload_time_iso_8601": "2016-07-27T04:03:57.109057Z", "url": "https://files.pythonhosted.org/packages/9e/f8/234485faa8e8327bbc5b7b4b4f40a7898fd1bd305d0c7d78893e415d3306/AdvancedHTMLParser-6.6.1.tar.gz", "yanked": false}], "6.6.2": [{"comment_text": "", "digests": {"md5": "83bca919d8949b41eab85dcb62ace247", "sha256": "b471401ef71e0527b676ebaa8405e11f1757cf386bee30cf0ec21f79251fd958"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.6.2.tar.gz", "has_sig": false, "md5_digest": "83bca919d8949b41eab85dcb62ace247", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 104190, "upload_time": "2016-07-27T04:42:50", "upload_time_iso_8601": "2016-07-27T04:42:50.144821Z", "url": "https://files.pythonhosted.org/packages/21/46/4cb5a740e54ed1213771389ef79614603149292c0c413c766cc8a0284aab/AdvancedHTMLParser-6.6.2.tar.gz", "yanked": false}], "6.6.3": [{"comment_text": "", "digests": {"md5": "3581dde54c019aaad1760ff13548f941", "sha256": "cd29651813b10d9abe90eab04b61baddcf1ee81c8ca8fe0cb623b554ead90d75"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.6.3.tar.gz", "has_sig": false, "md5_digest": "3581dde54c019aaad1760ff13548f941", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77289, "upload_time": "2016-10-03T22:49:49", "upload_time_iso_8601": "2016-10-03T22:49:49.417934Z", "url": "https://files.pythonhosted.org/packages/c3/a7/332835172f3d4a8b6afa50987eaac05a60bad62548b333438f789143e391/AdvancedHTMLParser-6.6.3.tar.gz", "yanked": false}], "6.6.4": [{"comment_text": "", "digests": {"md5": "b4c02a8f5f88402036fb7ce99ddaa6ba", "sha256": "3b7585d18248d79a1508bdc10cd65583c090289d32885863412db22c5bb0ce4f"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.6.4.tar.gz", "has_sig": false, "md5_digest": "b4c02a8f5f88402036fb7ce99ddaa6ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77594, "upload_time": "2016-10-27T20:57:17", "upload_time_iso_8601": "2016-10-27T20:57:17.864404Z", "url": "https://files.pythonhosted.org/packages/54/5c/2421bc91569a4d82d6b032b1595c14e33cc0c2635f7e43eae71a9f2182d2/AdvancedHTMLParser-6.6.4.tar.gz", "yanked": false}], "6.7.0": [{"comment_text": "", "digests": {"md5": "3cf7c5b4cdbe9c626946859083e3d4af", "sha256": "344e58a375f1eb1a85156c6871612ea73a31d148f33d5a6083c9ccefe2fc7d55"}, "downloads": -1, "filename": "AdvancedHTMLParser-6.7.0.tar.gz", "has_sig": false, "md5_digest": "3cf7c5b4cdbe9c626946859083e3d4af", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 88668, "upload_time": "2017-03-14T21:33:24", "upload_time_iso_8601": "2017-03-14T21:33:24.741005Z", "url": "https://files.pythonhosted.org/packages/01/66/f2ad73686a55083bc2a32a29ebd1a671600f43675fdd09b6de10453cf7db/AdvancedHTMLParser-6.7.0.tar.gz", "yanked": false}], "7.0.0": [{"comment_text": "", "digests": {"md5": "bc4d406d3d7f8b508603ff21d9dead98", "sha256": "c49299f287c057e0a3bf1b88f4dc4fa4a9c1e8978e0db3ed86c9ecb9b65341f2"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.0.0.tar.gz", "has_sig": false, "md5_digest": "bc4d406d3d7f8b508603ff21d9dead98", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 148065, "upload_time": "2017-04-06T18:27:28", "upload_time_iso_8601": "2017-04-06T18:27:28.332887Z", "url": "https://files.pythonhosted.org/packages/4e/18/7a527021d5d479b1fd570f2b5e134c8a9780809ec6e6349547858aba1f32/AdvancedHTMLParser-7.0.0.tar.gz", "yanked": false}], "7.0.1": [{"comment_text": "", "digests": {"md5": "a8a9c414014a6d022517fffe82bf2381", "sha256": "211ca9b8250e935dae23b17882f7b30536b4e7761fbb6bc6886b65244a4c241c"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.0.1.tar.gz", "has_sig": false, "md5_digest": "a8a9c414014a6d022517fffe82bf2381", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 177452, "upload_time": "2017-04-28T21:41:42", "upload_time_iso_8601": "2017-04-28T21:41:42.574598Z", "url": "https://files.pythonhosted.org/packages/ab/22/70cf3e2ac99c4ab3a3222b4b33e4cf54b64f3b199759600e23044a0a2225/AdvancedHTMLParser-7.0.1.tar.gz", "yanked": false}], "7.0.2": [{"comment_text": "", "digests": {"md5": "139e5de7d4bd5da357f0e9157c0dfe7c", "sha256": "3e49fa46f39d0385df1f126b3e2bf938e5c02219a7a2592c718fdca909c9ceec"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.0.2.tar.gz", "has_sig": false, "md5_digest": "139e5de7d4bd5da357f0e9157c0dfe7c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 177541, "upload_time": "2017-04-28T21:45:56", "upload_time_iso_8601": "2017-04-28T21:45:56.922635Z", "url": "https://files.pythonhosted.org/packages/5d/c1/884c380076969c906afe955847a5c750d4e87379b7ab245fe0fda546b7ec/AdvancedHTMLParser-7.0.2.tar.gz", "yanked": false}], "7.1.0": [{"comment_text": "", "digests": {"md5": "8ce95880b35778609202120f764224e2", "sha256": "b48395226e1420e2a99b284d0b27f6029656c71ce0883d23dc61bcddff9aa9da"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.1.0.tar.gz", "has_sig": false, "md5_digest": "8ce95880b35778609202120f764224e2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 180291, "upload_time": "2017-05-21T06:57:31", "upload_time_iso_8601": "2017-05-21T06:57:31.099105Z", "url": "https://files.pythonhosted.org/packages/93/39/1ba5fd6b1d8e375093dce27a4a5888b29c95befb131bbc5130adb347619f/AdvancedHTMLParser-7.1.0.tar.gz", "yanked": false}], "7.2.0": [{"comment_text": "", "digests": {"md5": "d38c2516e5842f0a8c90743411853ae3", "sha256": "0847be8f5b117500f9ffd60b321006183804115fc11118dd9f136aac26316dc9"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.2.0.tar.gz", "has_sig": false, "md5_digest": "d38c2516e5842f0a8c90743411853ae3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 189412, "upload_time": "2017-06-04T07:14:23", "upload_time_iso_8601": "2017-06-04T07:14:23.923592Z", "url": "https://files.pythonhosted.org/packages/6f/22/6a418066502fc60cc2bf8d2758727ca1436c3274fcbbf381b7c74362d76f/AdvancedHTMLParser-7.2.0.tar.gz", "yanked": false}], "7.2.1": [{"comment_text": "", "digests": {"md5": "e0c71a20a6ab0c2c11935c5e6d8281f9", "sha256": "eb0f4bfd59c7101e4ec5f1034e7f1faa63970c374195eb4c8944ea1fd82c5e36"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.2.1.tar.gz", "has_sig": false, "md5_digest": "e0c71a20a6ab0c2c11935c5e6d8281f9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 189203, "upload_time": "2017-07-14T02:35:34", "upload_time_iso_8601": "2017-07-14T02:35:34.980523Z", "url": "https://files.pythonhosted.org/packages/62/d4/aac3a8b1c30a1471e2723b47c5ce1bceb08d8d76b1fb23829dd290fb936d/AdvancedHTMLParser-7.2.1.tar.gz", "yanked": false}], "7.2.2": [{"comment_text": "", "digests": {"md5": "1f749b41086b95d5d213c5427781e2a2", "sha256": "b4669f9cc89b4163625c9047cb4b5a81f9a772dd017269de6ac544b1fef5f2a7"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.2.2.tar.gz", "has_sig": false, "md5_digest": "1f749b41086b95d5d213c5427781e2a2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 191390, "upload_time": "2017-08-07T23:25:39", "upload_time_iso_8601": "2017-08-07T23:25:39.640474Z", "url": "https://files.pythonhosted.org/packages/8b/e4/c5915dede37d0da7f6582fe2287fe2b1fd17bf2de90363289c9c1c3d15fe/AdvancedHTMLParser-7.2.2.tar.gz", "yanked": false}], "7.2.3": [{"comment_text": "", "digests": {"md5": "1e41946d5c7bb1d62e155da7eced4c9d", "sha256": "2fdc90ee7e54376baa68fce251e295a385c694a6d689f3ba06bf5c39d4288df7"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.2.3.tar.gz", "has_sig": false, "md5_digest": "1e41946d5c7bb1d62e155da7eced4c9d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 191586, "upload_time": "2017-09-01T16:11:13", "upload_time_iso_8601": "2017-09-01T16:11:13.337859Z", "url": "https://files.pythonhosted.org/packages/98/8e/34a0b3eec5812011a68e37e044f0eda9512825afaea972d60f36ba799e59/AdvancedHTMLParser-7.2.3.tar.gz", "yanked": false}], "7.2.3.1": [{"comment_text": "", "digests": {"md5": "71518ce715ce0af4d5c01ced7b27183a", "sha256": "7f9ed7ca8d5797e8c38b1a89e2977c3be0c3f02617fa0f00abba3564f8351942"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.2.3.1.tar.gz", "has_sig": false, "md5_digest": "71518ce715ce0af4d5c01ced7b27183a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 194355, "upload_time": "2017-09-01T17:31:09", "upload_time_iso_8601": "2017-09-01T17:31:09.860895Z", "url": "https://files.pythonhosted.org/packages/e4/22/deefa03adb5dbb1acc5b157e8f6ee4505737a5d4c2d31f9497ffe0561373/AdvancedHTMLParser-7.2.3.1.tar.gz", "yanked": false}], "7.2.3.2": [{"comment_text": "", "digests": {"md5": "7ccc1e2a1412af4bd31e5b2d62ca65f5", "sha256": "13e044a2d4b2e9e92ad17af4a15e4b9e5da7a4e616262b08166dc482102720f9"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.2.3.2.tar.gz", "has_sig": false, "md5_digest": "7ccc1e2a1412af4bd31e5b2d62ca65f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 194360, "upload_time": "2017-09-01T17:36:39", "upload_time_iso_8601": "2017-09-01T17:36:39.324385Z", "url": "https://files.pythonhosted.org/packages/ec/7f/d490a4e01ffd5c7a610e3a49cbda5eff93fc9b773ed613c92cb376b65c6c/AdvancedHTMLParser-7.2.3.2.tar.gz", "yanked": false}], "7.3.0": [{"comment_text": "", "digests": {"md5": "2af8b1c5dbd74ab6026ef26fb76f730e", "sha256": "63a2843c29765332e22df0e682e1de68d9df40baf3bfc08fcf49922d94aa419c"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.3.0.tar.gz", "has_sig": false, "md5_digest": "2af8b1c5dbd74ab6026ef26fb76f730e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 207294, "upload_time": "2017-11-19T20:50:01", "upload_time_iso_8601": "2017-11-19T20:50:01.323057Z", "url": "https://files.pythonhosted.org/packages/c9/1c/b8d134c7eccb358acbeb23c5a7f1c93d18ace0083251df06a89032b714c5/AdvancedHTMLParser-7.3.0.tar.gz", "yanked": false}], "7.3.1": [{"comment_text": "", "digests": {"md5": "02ab9bd423c27c394835c126d15558a0", "sha256": "11725bc34fbb3065b476472a07bd1a5b19dd4a740b735694f4cfe029283cc786"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.3.1.tar.gz", "has_sig": false, "md5_digest": "02ab9bd423c27c394835c126d15558a0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 220065, "upload_time": "2017-11-22T03:13:26", "upload_time_iso_8601": "2017-11-22T03:13:26.691854Z", "url": "https://files.pythonhosted.org/packages/9a/7b/bcea7dd622a8fb89d3b0988492778e5ad75795fc3758a49846af7cfb32ec/AdvancedHTMLParser-7.3.1.tar.gz", "yanked": false}], "7.3.1.1": [{"comment_text": "", "digests": {"md5": "db72481877e05a1f60fd1a13fc67d9e6", "sha256": "3e813f4a0e495a865a267cd30432c7573e1ce3b4f054667f0b142e8e72ee1b2b"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.3.1.1.tar.gz", "has_sig": false, "md5_digest": "db72481877e05a1f60fd1a13fc67d9e6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 220345, "upload_time": "2017-11-22T03:24:32", "upload_time_iso_8601": "2017-11-22T03:24:32.363748Z", "url": "https://files.pythonhosted.org/packages/4d/2f/2d5a9d11ebf690589e0fcac29cdd298fdfc9caca94dccd60257a3fff1e58/AdvancedHTMLParser-7.3.1.1.tar.gz", "yanked": false}], "7.3.2": [{"comment_text": "", "digests": {"md5": "84afb044e9d18b3a6d9e65e87292a32d", "sha256": "ef59b2796131cf15a22867a9f8d5e3e311c8a81a7ec28bb157dd35509c4cddb9"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.3.2.tar.gz", "has_sig": false, "md5_digest": "84afb044e9d18b3a6d9e65e87292a32d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 226151, "upload_time": "2017-11-25T01:27:10", "upload_time_iso_8601": "2017-11-25T01:27:10.701327Z", "url": "https://files.pythonhosted.org/packages/01/46/08852fbef8323b088d1682a68a1a9c0c07fa983ff0a564ee8e365611e007/AdvancedHTMLParser-7.3.2.tar.gz", "yanked": false}], "7.4.0": [{"comment_text": "", "digests": {"md5": "5815aab3dd474dfc1a9fa08dfe91ccb6", "sha256": "4f19b1b403bb9cff25ba8d645b17a0cc0981dc8a97ffe10d9676a91dbad817ef"}, "downloads": -1, "filename": "AdvancedHTMLParser-7.4.0.tar.gz", "has_sig": false, "md5_digest": "5815aab3dd474dfc1a9fa08dfe91ccb6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 246644, "upload_time": "2017-11-30T21:17:19", "upload_time_iso_8601": "2017-11-30T21:17:19.238178Z", "url": "https://files.pythonhosted.org/packages/1a/1d/5169f3fca9814a3256e7f8d03c30267b116ec302018cf46535f270012794/AdvancedHTMLParser-7.4.0.tar.gz", "yanked": false}], "8.0.0": [{"comment_text": "", "digests": {"md5": "65f57295a034fa6a5c41ba298c33a631", "sha256": "995323f4a42d72de74d0cf32258e9e321088a7e252e160cba044e58f62c60810"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.0.0.tar.gz", "has_sig": false, "md5_digest": "65f57295a034fa6a5c41ba298c33a631", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 246732, "upload_time": "2017-11-30T21:20:50", "upload_time_iso_8601": "2017-11-30T21:20:50.990907Z", "url": "https://files.pythonhosted.org/packages/4c/60/52db99959493a65a6978eb20226428bcee9ee1500b99e16ac6611e4ebfe2/AdvancedHTMLParser-8.0.0.tar.gz", "yanked": false}], "8.0.1": [{"comment_text": "", "digests": {"md5": "a20e69d762bfff8a10bbc0ca1048bc3b", "sha256": "4872c90b2e9bb7e447c48577f04fa0099c113634e7dbb905e180f4eba2a1fc47"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.0.1.tar.gz", "has_sig": false, "md5_digest": "a20e69d762bfff8a10bbc0ca1048bc3b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 248879, "upload_time": "2017-11-30T22:11:44", "upload_time_iso_8601": "2017-11-30T22:11:44.958728Z", "url": "https://files.pythonhosted.org/packages/3e/4d/0fc6dc531df31b5c4d11b7f05c55cef87238a4d363d4b7d21f7b5a78beb8/AdvancedHTMLParser-8.0.1.tar.gz", "yanked": false}], "8.1.0": [{"comment_text": "", "digests": {"md5": "9859931159425e81f746cf3219834225", "sha256": "1ca979c828827a1d80c0e39b8122ff03995935941bbda1c46fc837874184a28f"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.0.tar.gz", "has_sig": false, "md5_digest": "9859931159425e81f746cf3219834225", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 243353, "upload_time": "2018-10-16T02:41:02", "upload_time_iso_8601": "2018-10-16T02:41:02.237688Z", "url": "https://files.pythonhosted.org/packages/2f/2d/263c202ca1fda0f6a28471c9ceab37c70393d0c24b728b2a6bc582ab8d7f/AdvancedHTMLParser-8.1.0.tar.gz", "yanked": false}], "8.1.1": [{"comment_text": "", "digests": {"md5": "4865c0a253e7cd3f13beb2f2b0eeeef7", "sha256": "97683c6e9be6c73b3d824eb671dd0a98cc2ffc0e31bcc4ebdb8b7ee9acd52bf6"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.1.tar.gz", "has_sig": false, "md5_digest": "4865c0a253e7cd3f13beb2f2b0eeeef7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 244655, "upload_time": "2018-10-16T03:02:29", "upload_time_iso_8601": "2018-10-16T03:02:29.229711Z", "url": "https://files.pythonhosted.org/packages/48/1a/960ef019d6db4d52a467c0606f8f6a87744a00a64efee87ebe99955ff714/AdvancedHTMLParser-8.1.1.tar.gz", "yanked": false}], "8.1.2": [{"comment_text": "", "digests": {"md5": "e7cf0b93da4d7461a9ed16759381399b", "sha256": "c10cdce18310686554ad7340aa8c76a80831c17e15d687e8a3220bcbc80a685b"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.2.tar.gz", "has_sig": false, "md5_digest": "e7cf0b93da4d7461a9ed16759381399b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 252763, "upload_time": "2018-10-17T03:42:58", "upload_time_iso_8601": "2018-10-17T03:42:58.750252Z", "url": "https://files.pythonhosted.org/packages/6c/b6/aa24e353ab177531b02ace8813ad77fede6431604d267fa20c619330b5b4/AdvancedHTMLParser-8.1.2.tar.gz", "yanked": false}], "8.1.3": [{"comment_text": "", "digests": {"md5": "229f90e58640dbb0ac608959d84e839d", "sha256": "a516cd06e97ff3880b4c3577ee895e0d3f9902657a2e0af3608f23274a8f547a"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.3.tar.gz", "has_sig": false, "md5_digest": "229f90e58640dbb0ac608959d84e839d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 252896, "upload_time": "2018-10-17T04:09:24", "upload_time_iso_8601": "2018-10-17T04:09:24.585715Z", "url": "https://files.pythonhosted.org/packages/7e/cb/de90732a0dc02ca32be4f7705ee9f68c36a4a06d92226a7904910ffc1fc1/AdvancedHTMLParser-8.1.3.tar.gz", "yanked": false}], "8.1.4": [{"comment_text": "", "digests": {"md5": "8c32670e21cb067e154463d3c811e4e0", "sha256": "21a73137026c8ec3248c654a24cc40064196029256cdf71681149f6835e9ed39"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.4.tar.gz", "has_sig": false, "md5_digest": "8c32670e21cb067e154463d3c811e4e0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 255819, "upload_time": "2018-11-15T00:00:26", "upload_time_iso_8601": "2018-11-15T00:00:26.224257Z", "url": "https://files.pythonhosted.org/packages/cd/fa/4827afeaa1588f3f3b0343b7cb4175511b71ef3c19ae02bf7b6ce261ecdc/AdvancedHTMLParser-8.1.4.tar.gz", "yanked": false}], "8.1.5": [{"comment_text": "", "digests": {"md5": "eb88de8be230fac6963c904c88dc5e0e", "sha256": "4a0339ce0dd41d9d959bd471a51054ebbdb49db610db4dc0039c1aadd53d8c10"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.5.tar.gz", "has_sig": false, "md5_digest": "eb88de8be230fac6963c904c88dc5e0e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 258942, "upload_time": "2019-05-13T14:56:16", "upload_time_iso_8601": "2019-05-13T14:56:16.385135Z", "url": "https://files.pythonhosted.org/packages/40/1e/fdbddd16d62acf7c735288d4711adf7ba29255bb5e0acf45b50662ac7edb/AdvancedHTMLParser-8.1.5.tar.gz", "yanked": false}], "8.1.6": [{"comment_text": "", "digests": {"md5": "c30291877913ddb21e24bcdeb8f621e3", "sha256": "dd4cbe21408ac3d557a809b381836561ddeb3e14012d5b75f417ef5529772f5d"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.6.tar.gz", "has_sig": false, "md5_digest": "c30291877913ddb21e24bcdeb8f621e3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 260788, "upload_time": "2019-06-22T02:20:11", "upload_time_iso_8601": "2019-06-22T02:20:11.981486Z", "url": "https://files.pythonhosted.org/packages/07/68/b884188b67be2d4e9cf7f68bc2b01f4449e8b0431f7b1412b89e2c5e7d98/AdvancedHTMLParser-8.1.6.tar.gz", "yanked": false}], "8.1.7": [{"comment_text": "", "digests": {"md5": "c05953c2deb263a7c4d8a1e38f4330cf", "sha256": "4463caf599b6f43db73656ccff49792dd85e5c3c67bcf75cb1a5de6501beee5d"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.7.tar.gz", "has_sig": false, "md5_digest": "c05953c2deb263a7c4d8a1e38f4330cf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 262142, "upload_time": "2019-07-20T06:07:52", "upload_time_iso_8601": "2019-07-20T06:07:52.430243Z", "url": "https://files.pythonhosted.org/packages/40/cb/1ef41441134ab0a84b5bc3fda98af20141ebabcb7185b3ef0f17df1c9c49/AdvancedHTMLParser-8.1.7.tar.gz", "yanked": false}], "8.1.8": [{"comment_text": "", "digests": {"md5": "3453e63317e42d92e0995b46e8117ed8", "sha256": "bbaa6d3025b05eab91d795fc8670d4708b914a738aaae287944ca4d53a1d6009"}, "downloads": -1, "filename": "AdvancedHTMLParser-8.1.8.tar.gz", "has_sig": false, "md5_digest": "3453e63317e42d92e0995b46e8117ed8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 262175, "upload_time": "2019-07-22T08:00:19", "upload_time_iso_8601": "2019-07-22T08:00:19.677461Z", "url": "https://files.pythonhosted.org/packages/0d/cb/11a67f4ab3ed0aeb67223d196918806d07b8f75b4e570367214f7f44dc68/AdvancedHTMLParser-8.1.8.tar.gz", "yanked": false}], "9.0.0": [{"comment_text": "", "digests": {"md5": "5bc8aa05a53e1e4648fce817c9c93872", "sha256": "2ec0b9f1845e649402b8bb008dc756e4a9ab99575e24926f34bde1527166470c"}, "downloads": -1, "filename": "AdvancedHTMLParser-9.0.0.tar.gz", "has_sig": false, "md5_digest": "5bc8aa05a53e1e4648fce817c9c93872", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 317329, "upload_time": "2020-01-16T21:46:15", "upload_time_iso_8601": "2020-01-16T21:46:15.630807Z", "url": "https://files.pythonhosted.org/packages/40/9f/2431046ba00ce56a0c51be4fdeb5bbe6016e0ac3fc5d12f64d9e4bf5c7f0/AdvancedHTMLParser-9.0.0.tar.gz", "yanked": false}], "9.0.1": [{"comment_text": "", "digests": {"md5": "78a0522c4025ca2cf0c23954085e489c", "sha256": "1b7f632ca4c61fca50ee896c84112b97915c07d5b25b9527aefe7cbad8458837"}, "downloads": -1, "filename": "AdvancedHTMLParser-9.0.1.tar.gz", "has_sig": false, "md5_digest": "78a0522c4025ca2cf0c23954085e489c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 317393, "upload_time": "2020-02-12T22:10:03", "upload_time_iso_8601": "2020-02-12T22:10:03.451011Z", "url": "https://files.pythonhosted.org/packages/bb/51/80d4d52c6d59fcd4e4ccefb221ec43277cb3ae05163d01cb6efe768788e9/AdvancedHTMLParser-9.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "78a0522c4025ca2cf0c23954085e489c", "sha256": "1b7f632ca4c61fca50ee896c84112b97915c07d5b25b9527aefe7cbad8458837"}, "downloads": -1, "filename": "AdvancedHTMLParser-9.0.1.tar.gz", "has_sig": false, "md5_digest": "78a0522c4025ca2cf0c23954085e489c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 317393, "upload_time": "2020-02-12T22:10:03", "upload_time_iso_8601": "2020-02-12T22:10:03.451011Z", "url": "https://files.pythonhosted.org/packages/bb/51/80d4d52c6d59fcd4e4ccefb221ec43277cb3ae05163d01cb6efe768788e9/AdvancedHTMLParser-9.0.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:23:08 2020"}