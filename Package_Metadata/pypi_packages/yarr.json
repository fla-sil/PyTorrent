{"info": {"author": "Bartholomew Roberts", "author_email": "git@maeppi.e4ward.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: System :: Networking"], "description": "\ufeffYarr ain't RPC, Ritchie!\n------------------------\n\nA simple RPC implementation using a binary serialization protocol. It supports\nthe basic built-in types, numpy arrays work if available on both client and\nserver. Hence, yarr is well equipped to efficiently handle large binary booty.\n\nA friend asked me about RPC and large binary data in python. It sounded like a\nfun exercise so I charged forth. I choose to write my own serialization\nprotocol to have more control and a bit more security than pickle. I also ran\nmy benchmarks which pickle serialization and surprisingly yarr is not that slow.\nLists and dict take the biggest hit, being ~ 2x slower compared to pickle.\n\nExample\n-------\n```python\n# server\nyarr.yarr(('localhost', 8000), [print])\n# client\nyarr.call(('localhost', 8000), 'print', 'Ahoy Lads!')\n```\n\nFeatures\n--------\nCompared to other RPC frameworks yarr has better support for native python \ntypes. It's speed depends on the connection. On localhost it appears to be 2-10\ntimes faster than the other frameworks. Over LAN it's comparable to \njsonrpc2-zeromq. Over internet the ZeroMQ based frameworks are twice as fast,\nbut yarr is still on par with xmlrpc.\n\nHere is a table comparing it to other RPC frameworks. Partial support is marked\nwith p, usually due to type decay. The speed value is based on the benchmarks\nbelow. Feel free to add more.\n\n|              | yarr | xmlrpc | rpyc | jr2-zmq | spyne | 0rpc |\n|--------------|------|--------|------|---------|-------|------|\n| speed        | 1.0  | 0.6    | 0.04 | 0.9     | 0.3   | 0.6  |\n| dependencies | 0    | 0      | 1    | 3       | 1     | 5    |\n| recursion    | -    | -      | x    | -       | -     | -    |\n| bool         | x    | x      | x    | x       | x     | x    |\n| int          | x    | x      | x    | x       | x     | x    |\n| int64        | x    | -      | x    | x       | x     | x    |\n| bignum       | x    | -      | x    | x       | -     | -    |\n| float        | x    | x      | x    | x       | x     | x    |\n| complex      | x    | -      | x    | -       | -     | -    |\n| str          | x    | x      | x    | x       | x     | x    |\n| pep383       | x    | -      | -    | x       | -     | -    |\n| dict         | x    | p      | x    | p       | x     | x    |\n| tupledict    | x    | -      | x    | -       | p     | -    |\n| list         | x    | x      | x    | x       | p     | x    |\n| tuple        | x    | p      | x    | p       | x     | p    |\n| set          | x    | -      | x    | -       | -     | -    |\n| bytes        | x    | p      | x    | -       | x     | x    |\n| ndarray      | x    | -      | x    | -       | -     | -    |\n\nXmlrpc is part of python's stdlib. Good enough for simple use-cases.\n\nRpyc is glacially slow but has almost perfect type support. Surprisingly it\nstumbles over pep 383. It's also one of the few frameworks that can handle\nrecursion.\n\nJsonrpc2-zeromq has decent speed, though it is limited by it's protocol. There\nis no direct support for binary data. The base64 workaround works but impacts\nspeed.\n\nSpyne is a big project and can do a lot more than pure RPC. For this test\nMessagePack and ZeroMQ were used.\n\nZerorpc performance is below jsonrpc2-zeromq, which was unexpected given it's\nchoice of protocols. A dict containing tuple keys crashes the server.\n\nBenchmarks\n----------\nThe values below are in calls per second. This test was run over LAN with a\nserver ping of 0.2 ms. The most recent framework versions (May 2020) were used.\nWhen running this benchmark over internet with a ping of 25 ms, yarr\nperformance is roughly half of jsonrpc2-zeromq.\n\n|          | yarr | xmlrpc |  rpyc | jr2-zmq | spyne | 0rpc |\n|----------|-----:|-------:|------:|--------:|------:|-----:|\n|none      | 1291 |    746 |    56 |    1225 |   457 |  800 |\n|bool      | 1254 |    746 |    54 |    1253 |   450 |  774 |\n|int       | 1250 |    740 |    49 |    1263 |   448 |  769 |\n|int64     | 1238 |      - |    47 |    1188 |   450 |  765 |\n|bignum    | 1205 |      - |    49 |    1165 |     - |    - |\n|float     | 1211 |    750 |    52 |    1223 |   448 |  765 |\n|complex   | 1236 |      - |    54 |       - |     - |    - |\n|str       | 1204 |    770 |    54 |    1131 |   449 |  740 |\n|pep383    | 1236 |      - |     - |    1134 |     - |    - |\n|dict      | 1214 |    741 |    54 |    1040 |   447 |  757 |\n|list      | 1183 |    743 |    56 |    1141 |   449 |  759 |\n|tuple     | 1186 |    714 |    63 |    1142 |   448 |  778 |\n|set       | 1214 |      - |    49 |       - |     - |    - |\n|frozenset | 1189 |      - |    54 |       - |     - |    - |\n|bytes     |  785 |    504 |    46 |     484 |   349 |  533 |\n|bytearray |  780 |    502 |    60 |     481 |   350 |  534 |\n|ndarray   |  765 |      - |    19 |       - |     - |    - |\n\nProtocol\n--------\nThe main design goals were simplicity and performance. There is no clever\nencoding scheme like MessagePack. Data is basically just dumped into the TCP\nsocket without any transformations. Values are transferred as little endian,\nthere really is no point in using network byte order these days.\n\nIn some cases messages can actually be bigger than in json, for example when it\ncontains many short strings. However if the total size stays below the MTU\nthere is be no big performance hit. I tried adding zlib compression and a\npersistent connection, but that did not have a big impact and made everything\nmore complicated.\n\nBugs\n---\n* Not enough pirate-speak in documentation.\n* Malicious data can cause crash.\n* Recursive containers cause crash.\n\nLicense\n-------\nDo What The Fuck You Want To Public License\n\nEveryone is permitted to copy and distribute verbatim or modified\ncopies of this license document, and changing it is allowed as long\nas the name is changed.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://git.sr.ht/~maep/yarr", "keywords": "", "license": "WTFPL", "maintainer": "", "maintainer_email": "", "name": "yarr", "package_url": "https://pypi.org/project/yarr/", "platform": "", "project_url": "https://pypi.org/project/yarr/", "project_urls": {"Homepage": "https://git.sr.ht/~maep/yarr"}, "release_url": "https://pypi.org/project/yarr/0.9.0/", "requires_dist": null, "requires_python": ">= 3.1", "summary": "A simple and fast RPC framework", "version": "0.9.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h2>Yarr ain't RPC, Ritchie!</h2>\n<p>A simple RPC implementation using a binary serialization protocol. It supports\nthe basic built-in types, numpy arrays work if available on both client and\nserver. Hence, yarr is well equipped to efficiently handle large binary booty.</p>\n<p>A friend asked me about RPC and large binary data in python. It sounded like a\nfun exercise so I charged forth. I choose to write my own serialization\nprotocol to have more control and a bit more security than pickle. I also ran\nmy benchmarks which pickle serialization and surprisingly yarr is not that slow.\nLists and dict take the biggest hit, being ~ 2x slower compared to pickle.</p>\n<h2>Example</h2>\n<pre><span class=\"c1\"># server</span>\n<span class=\"n\">yarr</span><span class=\"o\">.</span><span class=\"n\">yarr</span><span class=\"p\">((</span><span class=\"s1\">'localhost'</span><span class=\"p\">,</span> <span class=\"mi\">8000</span><span class=\"p\">),</span> <span class=\"p\">[</span><span class=\"nb\">print</span><span class=\"p\">])</span>\n<span class=\"c1\"># client</span>\n<span class=\"n\">yarr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">((</span><span class=\"s1\">'localhost'</span><span class=\"p\">,</span> <span class=\"mi\">8000</span><span class=\"p\">),</span> <span class=\"s1\">'print'</span><span class=\"p\">,</span> <span class=\"s1\">'Ahoy Lads!'</span><span class=\"p\">)</span>\n</pre>\n<h2>Features</h2>\n<p>Compared to other RPC frameworks yarr has better support for native python\ntypes. It's speed depends on the connection. On localhost it appears to be 2-10\ntimes faster than the other frameworks. Over LAN it's comparable to\njsonrpc2-zeromq. Over internet the ZeroMQ based frameworks are twice as fast,\nbut yarr is still on par with xmlrpc.</p>\n<p>Here is a table comparing it to other RPC frameworks. Partial support is marked\nwith p, usually due to type decay. The speed value is based on the benchmarks\nbelow. Feel free to add more.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>yarr</th>\n<th>xmlrpc</th>\n<th>rpyc</th>\n<th>jr2-zmq</th>\n<th>spyne</th>\n<th>0rpc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>speed</td>\n<td>1.0</td>\n<td>0.6</td>\n<td>0.04</td>\n<td>0.9</td>\n<td>0.3</td>\n<td>0.6</td>\n</tr>\n<tr>\n<td>dependencies</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>3</td>\n<td>1</td>\n<td>5</td>\n</tr>\n<tr>\n<td>recursion</td>\n<td>-</td>\n<td>-</td>\n<td>x</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>int</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>int64</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>bignum</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n<td>x</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>float</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>complex</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>str</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>pep383</td>\n<td>x</td>\n<td>-</td>\n<td>-</td>\n<td>x</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>dict</td>\n<td>x</td>\n<td>p</td>\n<td>x</td>\n<td>p</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>tupledict</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n<td>-</td>\n<td>p</td>\n<td>-</td>\n</tr>\n<tr>\n<td>list</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>p</td>\n<td>x</td>\n</tr>\n<tr>\n<td>tuple</td>\n<td>x</td>\n<td>p</td>\n<td>x</td>\n<td>p</td>\n<td>x</td>\n<td>p</td>\n</tr>\n<tr>\n<td>set</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>x</td>\n<td>p</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>ndarray</td>\n<td>x</td>\n<td>-</td>\n<td>x</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr></tbody></table>\n<p>Xmlrpc is part of python's stdlib. Good enough for simple use-cases.</p>\n<p>Rpyc is glacially slow but has almost perfect type support. Surprisingly it\nstumbles over pep 383. It's also one of the few frameworks that can handle\nrecursion.</p>\n<p>Jsonrpc2-zeromq has decent speed, though it is limited by it's protocol. There\nis no direct support for binary data. The base64 workaround works but impacts\nspeed.</p>\n<p>Spyne is a big project and can do a lot more than pure RPC. For this test\nMessagePack and ZeroMQ were used.</p>\n<p>Zerorpc performance is below jsonrpc2-zeromq, which was unexpected given it's\nchoice of protocols. A dict containing tuple keys crashes the server.</p>\n<h2>Benchmarks</h2>\n<p>The values below are in calls per second. This test was run over LAN with a\nserver ping of 0.2 ms. The most recent framework versions (May 2020) were used.\nWhen running this benchmark over internet with a ping of 25 ms, yarr\nperformance is roughly half of jsonrpc2-zeromq.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"right\">yarr</th>\n<th align=\"right\">xmlrpc</th>\n<th align=\"right\">rpyc</th>\n<th align=\"right\">jr2-zmq</th>\n<th align=\"right\">spyne</th>\n<th align=\"right\">0rpc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>none</td>\n<td align=\"right\">1291</td>\n<td align=\"right\">746</td>\n<td align=\"right\">56</td>\n<td align=\"right\">1225</td>\n<td align=\"right\">457</td>\n<td align=\"right\">800</td>\n</tr>\n<tr>\n<td>bool</td>\n<td align=\"right\">1254</td>\n<td align=\"right\">746</td>\n<td align=\"right\">54</td>\n<td align=\"right\">1253</td>\n<td align=\"right\">450</td>\n<td align=\"right\">774</td>\n</tr>\n<tr>\n<td>int</td>\n<td align=\"right\">1250</td>\n<td align=\"right\">740</td>\n<td align=\"right\">49</td>\n<td align=\"right\">1263</td>\n<td align=\"right\">448</td>\n<td align=\"right\">769</td>\n</tr>\n<tr>\n<td>int64</td>\n<td align=\"right\">1238</td>\n<td align=\"right\">-</td>\n<td align=\"right\">47</td>\n<td align=\"right\">1188</td>\n<td align=\"right\">450</td>\n<td align=\"right\">765</td>\n</tr>\n<tr>\n<td>bignum</td>\n<td align=\"right\">1205</td>\n<td align=\"right\">-</td>\n<td align=\"right\">49</td>\n<td align=\"right\">1165</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n</tr>\n<tr>\n<td>float</td>\n<td align=\"right\">1211</td>\n<td align=\"right\">750</td>\n<td align=\"right\">52</td>\n<td align=\"right\">1223</td>\n<td align=\"right\">448</td>\n<td align=\"right\">765</td>\n</tr>\n<tr>\n<td>complex</td>\n<td align=\"right\">1236</td>\n<td align=\"right\">-</td>\n<td align=\"right\">54</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n</tr>\n<tr>\n<td>str</td>\n<td align=\"right\">1204</td>\n<td align=\"right\">770</td>\n<td align=\"right\">54</td>\n<td align=\"right\">1131</td>\n<td align=\"right\">449</td>\n<td align=\"right\">740</td>\n</tr>\n<tr>\n<td>pep383</td>\n<td align=\"right\">1236</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n<td align=\"right\">1134</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n</tr>\n<tr>\n<td>dict</td>\n<td align=\"right\">1214</td>\n<td align=\"right\">741</td>\n<td align=\"right\">54</td>\n<td align=\"right\">1040</td>\n<td align=\"right\">447</td>\n<td align=\"right\">757</td>\n</tr>\n<tr>\n<td>list</td>\n<td align=\"right\">1183</td>\n<td align=\"right\">743</td>\n<td align=\"right\">56</td>\n<td align=\"right\">1141</td>\n<td align=\"right\">449</td>\n<td align=\"right\">759</td>\n</tr>\n<tr>\n<td>tuple</td>\n<td align=\"right\">1186</td>\n<td align=\"right\">714</td>\n<td align=\"right\">63</td>\n<td align=\"right\">1142</td>\n<td align=\"right\">448</td>\n<td align=\"right\">778</td>\n</tr>\n<tr>\n<td>set</td>\n<td align=\"right\">1214</td>\n<td align=\"right\">-</td>\n<td align=\"right\">49</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n</tr>\n<tr>\n<td>frozenset</td>\n<td align=\"right\">1189</td>\n<td align=\"right\">-</td>\n<td align=\"right\">54</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td align=\"right\">785</td>\n<td align=\"right\">504</td>\n<td align=\"right\">46</td>\n<td align=\"right\">484</td>\n<td align=\"right\">349</td>\n<td align=\"right\">533</td>\n</tr>\n<tr>\n<td>bytearray</td>\n<td align=\"right\">780</td>\n<td align=\"right\">502</td>\n<td align=\"right\">60</td>\n<td align=\"right\">481</td>\n<td align=\"right\">350</td>\n<td align=\"right\">534</td>\n</tr>\n<tr>\n<td>ndarray</td>\n<td align=\"right\">765</td>\n<td align=\"right\">-</td>\n<td align=\"right\">19</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n<td align=\"right\">-</td>\n</tr></tbody></table>\n<h2>Protocol</h2>\n<p>The main design goals were simplicity and performance. There is no clever\nencoding scheme like MessagePack. Data is basically just dumped into the TCP\nsocket without any transformations. Values are transferred as little endian,\nthere really is no point in using network byte order these days.</p>\n<p>In some cases messages can actually be bigger than in json, for example when it\ncontains many short strings. However if the total size stays below the MTU\nthere is be no big performance hit. I tried adding zlib compression and a\npersistent connection, but that did not have a big impact and made everything\nmore complicated.</p>\n<h2>Bugs</h2>\n<ul>\n<li>Not enough pirate-speak in documentation.</li>\n<li>Malicious data can cause crash.</li>\n<li>Recursive containers cause crash.</li>\n</ul>\n<h2>License</h2>\n<p>Do What The Fuck You Want To Public License</p>\n<p>Everyone is permitted to copy and distribute verbatim or modified\ncopies of this license document, and changing it is allowed as long\nas the name is changed.</p>\n\n          </div>"}, "last_serial": 6965747, "releases": {"0.9.0": [{"comment_text": "", "digests": {"md5": "5a818789542fa2fa3ae909298dbb0395", "sha256": "fba4dca55f26ecdb7634d6417da20d0befcdefa216e1750006e4f0fd40bc0898"}, "downloads": -1, "filename": "yarr-0.9.0-py3-none-any.whl", "has_sig": false, "md5_digest": "5a818789542fa2fa3ae909298dbb0395", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">= 3.1", "size": 5816, "upload_time": "2020-04-07T00:54:11", "upload_time_iso_8601": "2020-04-07T00:54:11.381497Z", "url": "https://files.pythonhosted.org/packages/19/d5/adcca763018e852668642e7bb2c0ebf9f805fcb749bf32213d7d17ab70f3/yarr-0.9.0-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5a818789542fa2fa3ae909298dbb0395", "sha256": "fba4dca55f26ecdb7634d6417da20d0befcdefa216e1750006e4f0fd40bc0898"}, "downloads": -1, "filename": "yarr-0.9.0-py3-none-any.whl", "has_sig": false, "md5_digest": "5a818789542fa2fa3ae909298dbb0395", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">= 3.1", "size": 5816, "upload_time": "2020-04-07T00:54:11", "upload_time_iso_8601": "2020-04-07T00:54:11.381497Z", "url": "https://files.pythonhosted.org/packages/19/d5/adcca763018e852668642e7bb2c0ebf9f805fcb749bf32213d7d17ab70f3/yarr-0.9.0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:22:49 2020"}