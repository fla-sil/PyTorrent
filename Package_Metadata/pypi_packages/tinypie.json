{"info": {"author": "Ruslan Spivak", "author_email": "ruslan.spivak@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: Unix", "Programming Language :: Python", "Topic :: Software Development :: Interpreters"], "description": "TinyPie - Tree-Based Interpreter, Compiler, and VM for TinyPie language\n=======================================================================\n\nOverview\n--------\n\nTinyPie is a tree-based interpreter for a simple programming\nlanguage with a Python-like syntax.\n\nIt's based on Pie language from [Language Implementation Patterns](http://pragprog.com/titles/tpdsl/language-implementation-patterns) Ch.9\n\nQuote from [the book](http://pragprog.com/titles/tpdsl/language-implementation-patterns): \"A tree-based interpreter is like a compiler front\nend with an interpreter grafted onto the end instead of a code generator\"\n\nTinyPie also includes Bytecode Assembler and Register-Based Virtual Machine.\n\nGoals of the project\n--------------------\n\n1. Self-education\n\n2. To serve as an example for people interested in crafting\n   their own interpreter in Python for a simple programming language or DSL\n\n\nInstallation\n------------\n\n1. Using `buildout`\n\n        $ git clone git://github.com/rspivak/tinypie.git\n        $ cd tinypie\n        $ python bootstrap.py\n        $ bin/buildout\n\n        Run the interpreter\n\n        $ bin/tinypie factorial.tp\n\n2. Using `pip` or `easy_install` (no need for sudo if using `virtualenv`)\n\n        $ sudo pip install tinypie\n\n        (or run alternatively easy_install: $ sudo easy_install tinypie)\n\n        Run the interpreter\n\n        $ tinypie factorial.tp\n\n\nMain interpreter features\n-------------------------\n\n- Implemented in Python\n\n- Regexp-based lexer\n\n- LL(k) recursive-descent parser\n\n- Parser constructs homogeneous Abstract Syntax Tree (AST)\n\n- Static / lexical scope support.\n  Interpreter builds complete scope tree during AST construction.\n\n- Interpeter manages global memory space and function space stack\n\n- Interpreter implements external AST visitor\n\n- Forward references support\n\n\nHigh-level overview:\n\n                   |                 +------------------------------------+\n                   |  source code    |      Symbol Table / Scope Tree     |\n                   |                 |                                    |\n                  \\|/                |      +-----------------------+     |\n    +--------------X---------------+ |      |      GlobalScope      |     |\n    |                              | |      +----/-------------\\----+     |\n    |     Regexp-based lexer       | |          /               \\         |\n    |                              | |+--------/-----+   +-------\\-------+|\n    +--------------+---------------+ ||FunctionSymbol|   |FunctionSymbol ||\n                   |                 |+------X-------+   +-------X-------+|\n                   |  token stream   |      /|\\                 /|\\       |\n                  \\|/                |       |                   |        |\n    +--------------X---------------+ |+------+-------+   +-------+-------+|\n    |                              | ||  LocalScope  |   |  LocalScope   ||\n    |LL(k) recursive-descent parser| |+--------------+   +---------------+|\n    |                              | +------------------------------------+\n    +--------------+---------------+\n                   |                 +------------------------------------+\n                   |  AST            |           Memory Space             |\n                  \\|/                |                                    |\n    +--------------X-------------+   |Function Space    Global Memory     |\n    |        Interpreter         |   |Stack             Space             |\n    | with external tree visitor |   |+-------------+   +----------------+|\n    |                            |   ||FunctionSpace|   |  MemorySpace   ||\n    +--------------+-------------+   |+-------------+   +----------------+|\n                   |                 |+-------------+                     |\n                   |  output         ||FunctionSpace|                     |\n                  \\|/                |+-------------+                     |\n                   X                 +------------------------------------+\n\n\n\nThis Tree-Based Interpreter is similar to [Syntax-Directed Interpreter](http://github.com/rspivak/nososql) but instead of directly executing\nsource code during parsing the interpreter executes the source code by\nconstructing AST and then walking the tree.\n\nAdvantages of tree-based interperter over syntax-directed one:\n\n1. Symbol definition and symbol resolution happen at different stages:\n   - symbol definition is performed during parsing\n   - symbol resolution is performed during interpretation\n\n   This allows forward references and simplifies implementation -\n   parser deals with scope tree only and interpreter deals with memory\n   spaces.\n\n2. More flexible because of AST as an intermediate representation.\n\n\nLanguage grammar\n----------------\n\n    program             -> (function_definition | statement)+ EOF\n    function_definition -> 'def' ID '(' (ID (',' ID)*)? ')' slist\n    slist               -> ':' NL statement+ '.' NL\n                           | statement\n    statement           -> 'print' expr NL\n                           | 'return' expr NL\n                           | call NL\n                           | assign NL\n                           | 'if' expr slist ('else' slist)?\n                           | 'while' expr slist\n                           | NL\n    assign              -> ID '=' expr\n    expr                -> add_expr (('<' | '==') add_expr)?\n    add_expr            -> mult_expr (('+' | '-') mult_expr)*\n    mult_expr           -> atom ('*' atom)*\n    atom                -> ID | INT | STRING | call | '(' expr ')'\n    call                -> ID '(' (expr (',' expr)*)? ')'\n\n\nShort language reference\n------------------------\n\n- statements: `print`, `return`, `if`, `while`,  and function call\n- literals: integers and strings\n- operators: <, ==, +, -, *\n\nExpressions may contain identifiers.\n\nCode examples\n-------------\n\n1. Factorial\n\n        print factorial(6)               # forward reference\n\n        def factorial(x):                # function definition\n            if x < 2 return 1            # if statement\n            return x * factorial(x - 1)  # return statement\n        .                                # DOT marks the block end\n\n2. WHILE loop\n\n        index = 0\n\n        while index < 10:\n            print index\n            index = index + 1\n        .                                # DOT marks the block end\n\n3. IF ELSE\n\n        x = 10\n        if x == 10 print 'Yes'\n        else print 'No'\n\n4. Variable lookup in different scopes\n\n        x = 1        # global variable\n        def foo(x):  # 'foo' is defined in global memory space\n            print x  # prints 3 (parameter value)\n        .            # DOT marks the block end\n        def bar():   # 'bar' is defined in global memory space\n            x = 7    # modify global variable\n        .            # DOT marks the block end\n\n        foo(3)       # prints 3\n        bar()\n        print x      # prints 7 ('bar' modified global variable)\n\n\nAST Examples\n------------\n\nTrees in these examples are represented as S-expressions for tersness.\n\nFunction call:\n\n    foo(5, 7)\n\n    (CALL ID INT INT) means CALL is the root with children ID(foo), INT(5), and INT(7)\n\nFunction definition:\n\n    def foo(x, y):\n        z = x + y\n        return z\n    .\n\n    (FUNC_DEF ID ID ID (BLOCK (ASSIGN ID (SUB ID ID)) (RETURN ID)))\n\n\nDevelopment\n-----------\n\nInstall 'enscript' utility (optional).\nIf you are on Ubuntu:\n\n    $ sudo apt-get install enscript\n\nBoostrap the buildout and run it:\n\n    $ cd tinypie\n    $ python bootstrap.py\n    $ bin/buildout\n\nRun tests, test coverage and produce coverage reports:\n\n    $ bin/test\n    $ bin/coverage-test\n    $ bin/coveragereport\n\n    Check ./var/report/tinypie.html out for coverage report.\n\nRun pep8 and pylint to check code style and search for potential bugs:\n\n    $ bin/pep8\n    $ bin/pylint\n\nAST visualizer\n--------------\n\nTo see how TinyPie AST for different language constructs looks\nlike you can use `gendot` command line utility that is generated\nby buildout. This utility generates DOT file than can be further\nprocessed by [dot](http://www.graphviz.org/) program to draw nice graphs.\n\n    $ echo -n 'foo(3)' | bin/gendot\n    digraph astgraph {\n       node [shape=plaintext, fontsize=12, fontname=\"Courier\", height=.1];\n       ranksep=.3;\n       edge [arrowsize=.5]\n\n       node1 [label=\"BLOCK\"];\n       node2 [label=\"CALL\"];\n       node3 [label=\"ID (foo)\"];\n       node4 [label=\"INT (3)\"];\n\n       node2 -> node3\n       node2 -> node4\n       node1 -> node2\n    }\n\n    To draw graph and save it as a PNG image:\n\n    $ echo -n 'foo(3)' | bin/gendot > funcall.dot\n    $ dot -Tpng -o funcall.png funcall.dot\n\n\nBytecode Assembler\n------------------\n\nConverts assembly program into binary bytecodes.\nThe bytecode is further interpreted by the TinyPie\nRegister-Based Bytecode Interpreter / Virtual Machine.\n\nTinyPie Assembly language grammar:\n\n    program -> globals? (label | function_definition | instruction | NL)+\n    globals -> '.globals' INT NL\n    label -> ID ':' NL\n    function_definition -> '.def' ID ':' 'args' '=' INT ',' 'locals' '=' INT NL\n    instruction -> ID NL\n                 | ID operand NL\n                 | ID operand ',' operand NL\n                 | ID operand ',' operand NL ',' operand NL\n                 | 'call' ID ',' operand NL\n                 | 'loadk' REG ',' (INT | STRING) NL\n    operand -> REG | ID | STRING | INT\n\n\nAssembler yields the following components:\n\n1. *Code memory*: This is a `bytearray` containing\n   bytecode instructions and their operands derived from\n   the assembly source code.\n\n2. *Global data memory size*: The number of slots allocated\n   in global memory for use with GSTORE and GLOAD assembly commands.\n\n3. *Program entry point*: An address of main function `.def main: ...`\n\n4. *Constant pool*: A list of objects (integers, strings, function symbols)\n   that are not part of the code memory. Bytecode instructions refer\n   to those objects via integer index.\n\n\nHere is a factorial function in TinyPie language:\n\n    def factorial(x):\n        if x < 2 return 1\n        return x * factorial(x - 1)\n    .\n\n    print factorial(5)\n\n\nHere is an equivalent TinyPie assembly code:\n\n    .def factorial: args=1, locals=3\n        # r1 holds argument 'n'\n        loadk r2, 2\n        lt r3, r1, r2        # n < 2 ?\n        brf r3, cont         # if n >= 2 jump to 'cont'\n        loadk r0, 1          # else return 1\n        ret\n    cont:\n        loadk r2, 1          # r2 = 1\n        move r3, r1          # r3 = n\n        sub r1, r1, r2       # r1 = n - 1\n        call factorial, r1   # factorial(n - 1)\n        mul r0, r3, r0       # n = n * result of factorial(n - 1)\n        ret\n\n    .def main: args=0, locals=1\n        loadk r1, 5\n        call factorial, r1   # factorial(5)\n        print r0             # 120\n        halt\n\nHere are the resulting elements produced by the Bytecode Assembler\nby translating the above assembly code:\n\n    Constant pool:\n    0000: <FunctionSymbol: name='factorial', address=0, args=1, locals=3>\n    0001: 2\n    0002: 1\n    0003: <FunctionSymbol: name='main', address=95, args=0, locals=1>\n    0004: 3\n\n    Code memory:\n    0000:   6   0   0   0   2   0   0   0\n    0008:   1   4   0   0   0   3   0   0\n    0016:   0   1   0   0   0   2  13   0\n    0024:   0   0   3   0   0   0  41   6\n    0032:   0   0   0   0   0   0   0   2\n    0040:   9   6   0   0   0   2   0   0\n    0048:   0   2  14   0   0   0   3   0\n    0056:   0   0   1   2   0   0   0   1\n    0064:   0   0   0   1   0   0   0   2\n    0072:  16   0   0   0   0   0   0   0\n    0080:   1   3   0   0   0   0   0   0\n    0088:   0   3   0   0   0   0   9   6\n    0096:   0   0   0   1   0   0   0   4\n    0104:  16   0   0   0   0   0   0   0\n    0112:   1  15   0   0   0   0  10\n\nBytecode instructions are described in the following section.\n\n\nRegister-Based Bytecode Interpreter / Virtual Machine\n-----------------------------------------------------\n\nVirtual Machine architecture:\n\n1. **IP**: Instruction pointer register that points into the *code memory*\n   at the next instruction to execute.\n\n2. **CPU**: Instruction dispatcher that simulates *fetch-decode-execute*\n   cycle with a *switch* (if elif) statement in a loop - reads bytecode\n   at IP, decodes its operands and executes corresponding operation.\n\n3. **Global data memory**: a list of global objects. Contents is\n   accessed via integer index.\n\n4. **Code memory**: Holds bytecode instructions and their operands.\n\n5. **Call stack**: Holds StackFrame objects with function return address,\n   parameters, and local variables.\n\n6. **Stack frame**: A StackFrame object that holds all required information\n   to invoke a function:\n   - function symbol\n   - function return address\n   - registers hold return value, arguments, locals, and temporary values\n\n7. **FP**: Frame pointer - a special-purpose register that points to\n   the top of the function `call stack`\n\n8. **Constant pool**: Integers, strings, and function symbols all go into\n   constant pool. Instructions refer to constant pool values via an integer\n   index.\n\n\nHigh-level overview:\n\n                                       |\n                               TinyPie | assembly\n                                       |\n                                       V\n                            +-----------------------+\n                            |                       |\n                            |  Bytecode Assembler   |\n                            |                       |\n                            +----------+------------+\n                                       |\n                code memory(bytecode)  |  constant pool\n                                       V\n    +--------------------------------------------------------------------------+\n    |                                                                          |\n    |          Register-Based Bytecode Interpreter / Virtual Machine           |\n    |                                                                          |\n    | +------------------------+        +------------------------------------+ |\n    | |                        |        |       Function Call Stack          | |\n    | |     Constant Pool      +----+   |                                    | |\n    | |   (integer, string,    |    |   |                                    | |\n    | |    function symbol)    |    |   | +--------------------------------+ | |\n    | +------------------------+    |   | |        Stack Frame             | | |\n    |                               |   | |                                | | |\n    |                               |   | |function symbol: FS('main')     | | |\n    |                               |   | |return address:  0              | | |\n    | +------------------------+    |   | |          ret| args|locals      | | |\n    | |                        |    |   | |registers: r0|r1 r2|r3 r4 r5    | | |\n    | |  Global data memory    |    |   | +--------------------------------+ | |\n    | |                        +-|  |   |                                    | |\n    | |                        | |  |   |                                    | |\n    | +------------------------+ |  |   | +--------------------------------+ | |\n    |                            |  |   | |        Stack Frame             | | |\n    |                            |  |   | |                                | | |\n    |                            |  |   | |function symbol: FS('fact')     | | |\n    | +------------------------+ |  |   | |return address: 17              | | |\n    | |                        | |  |   | |          ret| args   |locals   | | |\n    | |    Code memory         | |  |   | |registers: r0|r1 r2 r3|r4       | | |\n    | |    (bytecode)          | |  |   | +--------------------------------+ | |\n    | |                        | |  |   |                                    | |\n    | +----------+-------------+ |  |   |                                    | |\n    |            |               |  |   +------------------------------------+ |\n    |            V               |  |                                          |\n    + +------------------------+ |  |                                          |\n    | |                        | |  |                                          |\n    | |         CPU            <-+  |                                          |\n    | | (fetch-decode-execute) |    |                                          |\n    | |                        <----+                                          |\n    | +------------------------+                                               |\n    |                                                                          |\n    +--------------------------------------------------------------------------+\n\n\nBytecode instructions for TinyPie VM:\n\n    # Index serves as an opcode\n    INSTRUCTIONS = [\n        None,\n        Instruction('add', REG, REG, REG),   # A B C  R(A) = R(B) + R(C)\n        Instruction('sub', REG, REG, REG),   # A B C  R(A) = R(B) - R(C)\n        Instruction('mul', REG, REG, REG),   # A B C  R(A) = R(B) * R(C)\n        Instruction('lt', REG, REG, REG),    # A B C  R(A) = R(B) < R(C)\n        Instruction('eq', REG, REG, REG),    # A B C  R(A) = R(B) == R(C)\n        Instruction('loadk', REG, POOL),     # A B    R(A) = CONST_POOL[B]\n        Instruction('gload', REG, POOL),     # A B    R(A) = GLOBALS[B]\n        Instruction('gstore', POOL, REG),    # A B    GLOBALS[A] = R(B)\n        Instruction('ret'),\n        Instruction('halt'),\n        Instruction('br', INT),              # A      branch to A\n        Instruction('brt', REG, INT),        # A B    R(A) is True -> branch to B\n        Instruction('brf', REG, INT),        # A B    R(A) is False -> branch to B\n        Instruction('move', REG, REG),       # A B    R(A) = R(B)\n        Instruction('print', REG),           # A      print R(A)\n        Instruction('call', FUNC, REG),      # A B    call A, R(B)\n        ]\n\nTinyPie VM comes with a `tpvm` command line utility:\n\n    $ bin/tpvm -h\n    Usage: tpvm [input file]\n\n    If no input file is provided STDIN is used by default.\n\n\n    Options:\n      -h, --help            show this help message and exit\n      -i FILE, --input=FILE\n                            Input file. Defaults to standard input.\n      -c, --coredump        Print coredump to standard output.\n      -d, --disasm          Print disassembled code to standard output.\n      -t, --trace           Print execution trace.\n\nExample output:\n\n    fact.tps\n    .def fact: args=1, locals=3\n        # r1 holds argument 'n'\n        loadk r2, 2\n        lt r3, r1, r2        # n < 2 ?\n        brf r3, cont         # if n >= 2 jump to 'cont'\n        loadk r0, 1          # else return 1\n        ret\n    cont:\n        loadk r2, 1          # r2 = 1\n        move r3, r1          # r3 = n\n        sub r1, r1, r2       # r1 = n - 1\n        call fact, r1        # fact(n - 1)\n        mul r0, r3, r0       # n = n * result of fact(n - 1)\n        ret\n\n    .def main: args=0, locals=1\n        loadk r1, 3\n        call fact, r1        # fact(3)\n        print r0             # 6\n        halt\n\n    $ bin/tpvm --coredump --disasm --trace -i /tmp/fact.tps\n    0095: LOADK   r1, #4:3         main.registers=[? | ?]              calls=[main]\n    0104: CALL    #0:fact@0, r1    main.registers=[? | 3]              calls=[main]\n    0000: LOADK   r2, #1:2         fact.registers=[? | 3 | ? ? ?]      calls=[main fact]\n    0009: LT      r3, r1, r2       fact.registers=[? | 3 | 2 ? ?]      calls=[main fact]\n    0022: BRF     r3, 41           fact.registers=[? | 3 | 2 0 ?]      calls=[main fact]\n    0041: LOADK   r2, #2:1         fact.registers=[? | 3 | 2 0 ?]      calls=[main fact]\n    0050: MOVE    r3, r1           fact.registers=[? | 3 | 1 0 ?]      calls=[main fact]\n    0059: SUB     r1, r1, r2       fact.registers=[? | 3 | 1 3 ?]      calls=[main fact]\n    0072: CALL    #0:fact@0, r1    fact.registers=[? | 2 | 1 3 ?]      calls=[main fact]\n    0000: LOADK   r2, #1:2         fact.registers=[? | 2 | ? ? ?]      calls=[main fact fact]\n    0009: LT      r3, r1, r2       fact.registers=[? | 2 | 2 ? ?]      calls=[main fact fact]\n    0022: BRF     r3, 41           fact.registers=[? | 2 | 2 0 ?]      calls=[main fact fact]\n    0041: LOADK   r2, #2:1         fact.registers=[? | 2 | 2 0 ?]      calls=[main fact fact]\n    0050: MOVE    r3, r1           fact.registers=[? | 2 | 1 0 ?]      calls=[main fact fact]\n    0059: SUB     r1, r1, r2       fact.registers=[? | 2 | 1 2 ?]      calls=[main fact fact]\n    0072: CALL    #0:fact@0, r1    fact.registers=[? | 1 | 1 2 ?]      calls=[main fact fact]\n    0000: LOADK   r2, #1:2         fact.registers=[? | 1 | ? ? ?]      calls=[main fact fact fact]\n    0009: LT      r3, r1, r2       fact.registers=[? | 1 | 2 ? ?]      calls=[main fact fact fact]\n    0022: BRF     r3, 41           fact.registers=[? | 1 | 2 1 ?]      calls=[main fact fact fact]\n    0031: LOADK   r0, #2:1         fact.registers=[? | 1 | 2 1 ?]      calls=[main fact fact fact]\n    0040: RET                      fact.registers=[1 | 1 | 2 1 ?]      calls=[main fact fact fact]\n    0081: MUL     r0, r3, r0       fact.registers=[1 | 1 | 1 2 ?]      calls=[main fact fact]\n    0094: RET                      fact.registers=[2 | 1 | 1 2 ?]      calls=[main fact fact]\n    0081: MUL     r0, r3, r0       fact.registers=[2 | 2 | 1 3 ?]      calls=[main fact]\n    0094: RET                      fact.registers=[6 | 2 | 1 3 ?]      calls=[main fact]\n    0113: PRINT   r0               main.registers=[6 | 3]              calls=[main]\n    6\n    Constant pool:\n    0000: <FunctionSymbol: name='fact', address=0, args=1, locals=3>\n    0001: 2\n    0002: 1\n    0003: <FunctionSymbol: name='main', address=95, args=0, locals=1>\n    0004: 3\n\n    Code memory:\n    0000:   6   0   0   0   2   0   0   0\n    0008:   1   4   0   0   0   3   0   0\n    0016:   0   1   0   0   0   2  13   0\n    0024:   0   0   3   0   0   0  41   6\n    0032:   0   0   0   0   0   0   0   2\n    0040:   9   6   0   0   0   2   0   0\n    0048:   0   2  14   0   0   0   3   0\n    0056:   0   0   1   2   0   0   0   1\n    0064:   0   0   0   1   0   0   0   2\n    0072:  16   0   0   0   0   0   0   0\n    0080:   1   3   0   0   0   0   0   0\n    0088:   0   3   0   0   0   0   9   6\n    0096:   0   0   0   1   0   0   0   4\n    0104:  16   0   0   0   0   0   0   0\n    0112:   1  15   0   0   0   0  10\n\n    Disassembly:\n    0000: LOADK   r2, #1:2\n    0009: LT      r3, r1, r2\n    0022: BRF     r3, 41\n    0031: LOADK   r0, #2:1\n    0040: RET\n    0041: LOADK   r2, #2:1\n    0050: MOVE    r3, r1\n    0059: SUB     r1, r1, r2\n    0072: CALL    #0:fact@0, r1\n    0081: MUL     r0, r3, r0\n    0094: RET\n    0095: LOADK   r1, #4:3\n    0104: CALL    #0:fact@0, r1\n    0113: PRINT   r0\n    0118: HALT\n\n\n\n=======\nCHANGES\n=======\n\n0.2 (2011-03-03)\n----------------\n\n- Added Bytecode Assembler\n- Added Register-Based Virtual Machine\n\n0.1 (initial release)\n---------------------\n\n- Initial release of TinyPie interpreter", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/rspivak/tinypie", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "tinypie", "package_url": "https://pypi.org/project/tinypie/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/tinypie/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/rspivak/tinypie"}, "release_url": "https://pypi.org/project/tinypie/0.2/", "requires_dist": null, "requires_python": null, "summary": "Tree-Based Interpreter, Compiler and VM for TinyPie language", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            TinyPie - Tree-Based Interpreter, Compiler, and VM for TinyPie language<br>=======================================================================<br><br>Overview<br>--------<br><br>TinyPie is a tree-based interpreter for a simple programming<br>language with a Python-like syntax.<br><br>It's based on Pie language from [Language Implementation Patterns](http://pragprog.com/titles/tpdsl/language-implementation-patterns) Ch.9<br><br>Quote from [the book](http://pragprog.com/titles/tpdsl/language-implementation-patterns): \"A tree-based interpreter is like a compiler front<br>end with an interpreter grafted onto the end instead of a code generator\"<br><br>TinyPie also includes Bytecode Assembler and Register-Based Virtual Machine.<br><br>Goals of the project<br>--------------------<br><br>1. Self-education<br><br>2. To serve as an example for people interested in crafting<br>   their own interpreter in Python for a simple programming language or DSL<br><br><br>Installation<br>------------<br><br>1. Using `buildout`<br><br>        $ git clone git://github.com/rspivak/tinypie.git<br>        $ cd tinypie<br>        $ python bootstrap.py<br>        $ bin/buildout<br><br>        Run the interpreter<br><br>        $ bin/tinypie factorial.tp<br><br>2. Using `pip` or `easy_install` (no need for sudo if using `virtualenv`)<br><br>        $ sudo pip install tinypie<br><br>        (or run alternatively easy_install: $ sudo easy_install tinypie)<br><br>        Run the interpreter<br><br>        $ tinypie factorial.tp<br><br><br>Main interpreter features<br>-------------------------<br><br>- Implemented in Python<br><br>- Regexp-based lexer<br><br>- LL(k) recursive-descent parser<br><br>- Parser constructs homogeneous Abstract Syntax Tree (AST)<br><br>- Static / lexical scope support.<br>  Interpreter builds complete scope tree during AST construction.<br><br>- Interpeter manages global memory space and function space stack<br><br>- Interpreter implements external AST visitor<br><br>- Forward references support<br><br><br>High-level overview:<br><br>                   |                 +------------------------------------+<br>                   |  source code    |      Symbol Table / Scope Tree     |<br>                   |                 |                                    |<br>                  \\|/                |      +-----------------------+     |<br>    +--------------X---------------+ |      |      GlobalScope      |     |<br>    |                              | |      +----/-------------\\----+     |<br>    |     Regexp-based lexer       | |          /               \\         |<br>    |                              | |+--------/-----+   +-------\\-------+|<br>    +--------------+---------------+ ||FunctionSymbol|   |FunctionSymbol ||<br>                   |                 |+------X-------+   +-------X-------+|<br>                   |  token stream   |      /|\\                 /|\\       |<br>                  \\|/                |       |                   |        |<br>    +--------------X---------------+ |+------+-------+   +-------+-------+|<br>    |                              | ||  LocalScope  |   |  LocalScope   ||<br>    |LL(k) recursive-descent parser| |+--------------+   +---------------+|<br>    |                              | +------------------------------------+<br>    +--------------+---------------+<br>                   |                 +------------------------------------+<br>                   |  AST            |           Memory Space             |<br>                  \\|/                |                                    |<br>    +--------------X-------------+   |Function Space    Global Memory     |<br>    |        Interpreter         |   |Stack             Space             |<br>    | with external tree visitor |   |+-------------+   +----------------+|<br>    |                            |   ||FunctionSpace|   |  MemorySpace   ||<br>    +--------------+-------------+   |+-------------+   +----------------+|<br>                   |                 |+-------------+                     |<br>                   |  output         ||FunctionSpace|                     |<br>                  \\|/                |+-------------+                     |<br>                   X                 +------------------------------------+<br><br><br><br>This Tree-Based Interpreter is similar to [Syntax-Directed Interpreter](http://github.com/rspivak/nososql) but instead of directly executing<br>source code during parsing the interpreter executes the source code by<br>constructing AST and then walking the tree.<br><br>Advantages of tree-based interperter over syntax-directed one:<br><br>1. Symbol definition and symbol resolution happen at different stages:<br>   - symbol definition is performed during parsing<br>   - symbol resolution is performed during interpretation<br><br>   This allows forward references and simplifies implementation -<br>   parser deals with scope tree only and interpreter deals with memory<br>   spaces.<br><br>2. More flexible because of AST as an intermediate representation.<br><br><br>Language grammar<br>----------------<br><br>    program             -&gt; (function_definition | statement)+ EOF<br>    function_definition -&gt; 'def' ID '(' (ID (',' ID)*)? ')' slist<br>    slist               -&gt; ':' NL statement+ '.' NL<br>                           | statement<br>    statement           -&gt; 'print' expr NL<br>                           | 'return' expr NL<br>                           | call NL<br>                           | assign NL<br>                           | 'if' expr slist ('else' slist)?<br>                           | 'while' expr slist<br>                           | NL<br>    assign              -&gt; ID '=' expr<br>    expr                -&gt; add_expr (('&lt;' | '==') add_expr)?<br>    add_expr            -&gt; mult_expr (('+' | '-') mult_expr)*<br>    mult_expr           -&gt; atom ('*' atom)*<br>    atom                -&gt; ID | INT | STRING | call | '(' expr ')'<br>    call                -&gt; ID '(' (expr (',' expr)*)? ')'<br><br><br>Short language reference<br>------------------------<br><br>- statements: `print`, `return`, `if`, `while`,  and function call<br>- literals: integers and strings<br>- operators: &lt;, ==, +, -, *<br><br>Expressions may contain identifiers.<br><br>Code examples<br>-------------<br><br>1. Factorial<br><br>        print factorial(6)               # forward reference<br><br>        def factorial(x):                # function definition<br>            if x &lt; 2 return 1            # if statement<br>            return x * factorial(x - 1)  # return statement<br>        .                                # DOT marks the block end<br><br>2. WHILE loop<br><br>        index = 0<br><br>        while index &lt; 10:<br>            print index<br>            index = index + 1<br>        .                                # DOT marks the block end<br><br>3. IF ELSE<br><br>        x = 10<br>        if x == 10 print 'Yes'<br>        else print 'No'<br><br>4. Variable lookup in different scopes<br><br>        x = 1        # global variable<br>        def foo(x):  # 'foo' is defined in global memory space<br>            print x  # prints 3 (parameter value)<br>        .            # DOT marks the block end<br>        def bar():   # 'bar' is defined in global memory space<br>            x = 7    # modify global variable<br>        .            # DOT marks the block end<br><br>        foo(3)       # prints 3<br>        bar()<br>        print x      # prints 7 ('bar' modified global variable)<br><br><br>AST Examples<br>------------<br><br>Trees in these examples are represented as S-expressions for tersness.<br><br>Function call:<br><br>    foo(5, 7)<br><br>    (CALL ID INT INT) means CALL is the root with children ID(foo), INT(5), and INT(7)<br><br>Function definition:<br><br>    def foo(x, y):<br>        z = x + y<br>        return z<br>    .<br><br>    (FUNC_DEF ID ID ID (BLOCK (ASSIGN ID (SUB ID ID)) (RETURN ID)))<br><br><br>Development<br>-----------<br><br>Install 'enscript' utility (optional).<br>If you are on Ubuntu:<br><br>    $ sudo apt-get install enscript<br><br>Boostrap the buildout and run it:<br><br>    $ cd tinypie<br>    $ python bootstrap.py<br>    $ bin/buildout<br><br>Run tests, test coverage and produce coverage reports:<br><br>    $ bin/test<br>    $ bin/coverage-test<br>    $ bin/coveragereport<br><br>    Check ./var/report/tinypie.html out for coverage report.<br><br>Run pep8 and pylint to check code style and search for potential bugs:<br><br>    $ bin/pep8<br>    $ bin/pylint<br><br>AST visualizer<br>--------------<br><br>To see how TinyPie AST for different language constructs looks<br>like you can use `gendot` command line utility that is generated<br>by buildout. This utility generates DOT file than can be further<br>processed by [dot](http://www.graphviz.org/) program to draw nice graphs.<br><br>    $ echo -n 'foo(3)' | bin/gendot<br>    digraph astgraph {<br>       node [shape=plaintext, fontsize=12, fontname=\"Courier\", height=.1];<br>       ranksep=.3;<br>       edge [arrowsize=.5]<br><br>       node1 [label=\"BLOCK\"];<br>       node2 [label=\"CALL\"];<br>       node3 [label=\"ID (foo)\"];<br>       node4 [label=\"INT (3)\"];<br><br>       node2 -&gt; node3<br>       node2 -&gt; node4<br>       node1 -&gt; node2<br>    }<br><br>    To draw graph and save it as a PNG image:<br><br>    $ echo -n 'foo(3)' | bin/gendot &gt; funcall.dot<br>    $ dot -Tpng -o funcall.png funcall.dot<br><br><br>Bytecode Assembler<br>------------------<br><br>Converts assembly program into binary bytecodes.<br>The bytecode is further interpreted by the TinyPie<br>Register-Based Bytecode Interpreter / Virtual Machine.<br><br>TinyPie Assembly language grammar:<br><br>    program -&gt; globals? (label | function_definition | instruction | NL)+<br>    globals -&gt; '.globals' INT NL<br>    label -&gt; ID ':' NL<br>    function_definition -&gt; '.def' ID ':' 'args' '=' INT ',' 'locals' '=' INT NL<br>    instruction -&gt; ID NL<br>                 | ID operand NL<br>                 | ID operand ',' operand NL<br>                 | ID operand ',' operand NL ',' operand NL<br>                 | 'call' ID ',' operand NL<br>                 | 'loadk' REG ',' (INT | STRING) NL<br>    operand -&gt; REG | ID | STRING | INT<br><br><br>Assembler yields the following components:<br><br>1. *Code memory*: This is a `bytearray` containing<br>   bytecode instructions and their operands derived from<br>   the assembly source code.<br><br>2. *Global data memory size*: The number of slots allocated<br>   in global memory for use with GSTORE and GLOAD assembly commands.<br><br>3. *Program entry point*: An address of main function `.def main: ...`<br><br>4. *Constant pool*: A list of objects (integers, strings, function symbols)<br>   that are not part of the code memory. Bytecode instructions refer<br>   to those objects via integer index.<br><br><br>Here is a factorial function in TinyPie language:<br><br>    def factorial(x):<br>        if x &lt; 2 return 1<br>        return x * factorial(x - 1)<br>    .<br><br>    print factorial(5)<br><br><br>Here is an equivalent TinyPie assembly code:<br><br>    .def factorial: args=1, locals=3<br>        # r1 holds argument 'n'<br>        loadk r2, 2<br>        lt r3, r1, r2        # n &lt; 2 ?<br>        brf r3, cont         # if n &gt;= 2 jump to 'cont'<br>        loadk r0, 1          # else return 1<br>        ret<br>    cont:<br>        loadk r2, 1          # r2 = 1<br>        move r3, r1          # r3 = n<br>        sub r1, r1, r2       # r1 = n - 1<br>        call factorial, r1   # factorial(n - 1)<br>        mul r0, r3, r0       # n = n * result of factorial(n - 1)<br>        ret<br><br>    .def main: args=0, locals=1<br>        loadk r1, 5<br>        call factorial, r1   # factorial(5)<br>        print r0             # 120<br>        halt<br><br>Here are the resulting elements produced by the Bytecode Assembler<br>by translating the above assembly code:<br><br>    Constant pool:<br>    0000: &lt;FunctionSymbol: name='factorial', address=0, args=1, locals=3&gt;<br>    0001: 2<br>    0002: 1<br>    0003: &lt;FunctionSymbol: name='main', address=95, args=0, locals=1&gt;<br>    0004: 3<br><br>    Code memory:<br>    0000:   6   0   0   0   2   0   0   0<br>    0008:   1   4   0   0   0   3   0   0<br>    0016:   0   1   0   0   0   2  13   0<br>    0024:   0   0   3   0   0   0  41   6<br>    0032:   0   0   0   0   0   0   0   2<br>    0040:   9   6   0   0   0   2   0   0<br>    0048:   0   2  14   0   0   0   3   0<br>    0056:   0   0   1   2   0   0   0   1<br>    0064:   0   0   0   1   0   0   0   2<br>    0072:  16   0   0   0   0   0   0   0<br>    0080:   1   3   0   0   0   0   0   0<br>    0088:   0   3   0   0   0   0   9   6<br>    0096:   0   0   0   1   0   0   0   4<br>    0104:  16   0   0   0   0   0   0   0<br>    0112:   1  15   0   0   0   0  10<br><br>Bytecode instructions are described in the following section.<br><br><br>Register-Based Bytecode Interpreter / Virtual Machine<br>-----------------------------------------------------<br><br>Virtual Machine architecture:<br><br>1. **IP**: Instruction pointer register that points into the *code memory*<br>   at the next instruction to execute.<br><br>2. **CPU**: Instruction dispatcher that simulates *fetch-decode-execute*<br>   cycle with a *switch* (if elif) statement in a loop - reads bytecode<br>   at IP, decodes its operands and executes corresponding operation.<br><br>3. **Global data memory**: a list of global objects. Contents is<br>   accessed via integer index.<br><br>4. **Code memory**: Holds bytecode instructions and their operands.<br><br>5. **Call stack**: Holds StackFrame objects with function return address,<br>   parameters, and local variables.<br><br>6. **Stack frame**: A StackFrame object that holds all required information<br>   to invoke a function:<br>   - function symbol<br>   - function return address<br>   - registers hold return value, arguments, locals, and temporary values<br><br>7. **FP**: Frame pointer - a special-purpose register that points to<br>   the top of the function `call stack`<br><br>8. **Constant pool**: Integers, strings, and function symbols all go into<br>   constant pool. Instructions refer to constant pool values via an integer<br>   index.<br><br><br>High-level overview:<br><br>                                       |<br>                               TinyPie | assembly<br>                                       |<br>                                       V<br>                            +-----------------------+<br>                            |                       |<br>                            |  Bytecode Assembler   |<br>                            |                       |<br>                            +----------+------------+<br>                                       |<br>                code memory(bytecode)  |  constant pool<br>                                       V<br>    +--------------------------------------------------------------------------+<br>    |                                                                          |<br>    |          Register-Based Bytecode Interpreter / Virtual Machine           |<br>    |                                                                          |<br>    | +------------------------+        +------------------------------------+ |<br>    | |                        |        |       Function Call Stack          | |<br>    | |     Constant Pool      +----+   |                                    | |<br>    | |   (integer, string,    |    |   |                                    | |<br>    | |    function symbol)    |    |   | +--------------------------------+ | |<br>    | +------------------------+    |   | |        Stack Frame             | | |<br>    |                               |   | |                                | | |<br>    |                               |   | |function symbol: FS('main')     | | |<br>    |                               |   | |return address:  0              | | |<br>    | +------------------------+    |   | |          ret| args|locals      | | |<br>    | |                        |    |   | |registers: r0|r1 r2|r3 r4 r5    | | |<br>    | |  Global data memory    |    |   | +--------------------------------+ | |<br>    | |                        +-|  |   |                                    | |<br>    | |                        | |  |   |                                    | |<br>    | +------------------------+ |  |   | +--------------------------------+ | |<br>    |                            |  |   | |        Stack Frame             | | |<br>    |                            |  |   | |                                | | |<br>    |                            |  |   | |function symbol: FS('fact')     | | |<br>    | +------------------------+ |  |   | |return address: 17              | | |<br>    | |                        | |  |   | |          ret| args   |locals   | | |<br>    | |    Code memory         | |  |   | |registers: r0|r1 r2 r3|r4       | | |<br>    | |    (bytecode)          | |  |   | +--------------------------------+ | |<br>    | |                        | |  |   |                                    | |<br>    | +----------+-------------+ |  |   |                                    | |<br>    |            |               |  |   +------------------------------------+ |<br>    |            V               |  |                                          |<br>    + +------------------------+ |  |                                          |<br>    | |                        | |  |                                          |<br>    | |         CPU            &lt;-+  |                                          |<br>    | | (fetch-decode-execute) |    |                                          |<br>    | |                        &lt;----+                                          |<br>    | +------------------------+                                               |<br>    |                                                                          |<br>    +--------------------------------------------------------------------------+<br><br><br>Bytecode instructions for TinyPie VM:<br><br>    # Index serves as an opcode<br>    INSTRUCTIONS = [<br>        None,<br>        Instruction('add', REG, REG, REG),   # A B C  R(A) = R(B) + R(C)<br>        Instruction('sub', REG, REG, REG),   # A B C  R(A) = R(B) - R(C)<br>        Instruction('mul', REG, REG, REG),   # A B C  R(A) = R(B) * R(C)<br>        Instruction('lt', REG, REG, REG),    # A B C  R(A) = R(B) &lt; R(C)<br>        Instruction('eq', REG, REG, REG),    # A B C  R(A) = R(B) == R(C)<br>        Instruction('loadk', REG, POOL),     # A B    R(A) = CONST_POOL[B]<br>        Instruction('gload', REG, POOL),     # A B    R(A) = GLOBALS[B]<br>        Instruction('gstore', POOL, REG),    # A B    GLOBALS[A] = R(B)<br>        Instruction('ret'),<br>        Instruction('halt'),<br>        Instruction('br', INT),              # A      branch to A<br>        Instruction('brt', REG, INT),        # A B    R(A) is True -&gt; branch to B<br>        Instruction('brf', REG, INT),        # A B    R(A) is False -&gt; branch to B<br>        Instruction('move', REG, REG),       # A B    R(A) = R(B)<br>        Instruction('print', REG),           # A      print R(A)<br>        Instruction('call', FUNC, REG),      # A B    call A, R(B)<br>        ]<br><br>TinyPie VM comes with a `tpvm` command line utility:<br><br>    $ bin/tpvm -h<br>    Usage: tpvm [input file]<br><br>    If no input file is provided STDIN is used by default.<br><br><br>    Options:<br>      -h, --help            show this help message and exit<br>      -i FILE, --input=FILE<br>                            Input file. Defaults to standard input.<br>      -c, --coredump        Print coredump to standard output.<br>      -d, --disasm          Print disassembled code to standard output.<br>      -t, --trace           Print execution trace.<br><br>Example output:<br><br>    fact.tps<br>    .def fact: args=1, locals=3<br>        # r1 holds argument 'n'<br>        loadk r2, 2<br>        lt r3, r1, r2        # n &lt; 2 ?<br>        brf r3, cont         # if n &gt;= 2 jump to 'cont'<br>        loadk r0, 1          # else return 1<br>        ret<br>    cont:<br>        loadk r2, 1          # r2 = 1<br>        move r3, r1          # r3 = n<br>        sub r1, r1, r2       # r1 = n - 1<br>        call fact, r1        # fact(n - 1)<br>        mul r0, r3, r0       # n = n * result of fact(n - 1)<br>        ret<br><br>    .def main: args=0, locals=1<br>        loadk r1, 3<br>        call fact, r1        # fact(3)<br>        print r0             # 6<br>        halt<br><br>    $ bin/tpvm --coredump --disasm --trace -i /tmp/fact.tps<br>    0095: LOADK   r1, #4:3         main.registers=[? | ?]              calls=[main]<br>    0104: CALL    #0:fact@0, r1    main.registers=[? | 3]              calls=[main]<br>    0000: LOADK   r2, #1:2         fact.registers=[? | 3 | ? ? ?]      calls=[main fact]<br>    0009: LT      r3, r1, r2       fact.registers=[? | 3 | 2 ? ?]      calls=[main fact]<br>    0022: BRF     r3, 41           fact.registers=[? | 3 | 2 0 ?]      calls=[main fact]<br>    0041: LOADK   r2, #2:1         fact.registers=[? | 3 | 2 0 ?]      calls=[main fact]<br>    0050: MOVE    r3, r1           fact.registers=[? | 3 | 1 0 ?]      calls=[main fact]<br>    0059: SUB     r1, r1, r2       fact.registers=[? | 3 | 1 3 ?]      calls=[main fact]<br>    0072: CALL    #0:fact@0, r1    fact.registers=[? | 2 | 1 3 ?]      calls=[main fact]<br>    0000: LOADK   r2, #1:2         fact.registers=[? | 2 | ? ? ?]      calls=[main fact fact]<br>    0009: LT      r3, r1, r2       fact.registers=[? | 2 | 2 ? ?]      calls=[main fact fact]<br>    0022: BRF     r3, 41           fact.registers=[? | 2 | 2 0 ?]      calls=[main fact fact]<br>    0041: LOADK   r2, #2:1         fact.registers=[? | 2 | 2 0 ?]      calls=[main fact fact]<br>    0050: MOVE    r3, r1           fact.registers=[? | 2 | 1 0 ?]      calls=[main fact fact]<br>    0059: SUB     r1, r1, r2       fact.registers=[? | 2 | 1 2 ?]      calls=[main fact fact]<br>    0072: CALL    #0:fact@0, r1    fact.registers=[? | 1 | 1 2 ?]      calls=[main fact fact]<br>    0000: LOADK   r2, #1:2         fact.registers=[? | 1 | ? ? ?]      calls=[main fact fact fact]<br>    0009: LT      r3, r1, r2       fact.registers=[? | 1 | 2 ? ?]      calls=[main fact fact fact]<br>    0022: BRF     r3, 41           fact.registers=[? | 1 | 2 1 ?]      calls=[main fact fact fact]<br>    0031: LOADK   r0, #2:1         fact.registers=[? | 1 | 2 1 ?]      calls=[main fact fact fact]<br>    0040: RET                      fact.registers=[1 | 1 | 2 1 ?]      calls=[main fact fact fact]<br>    0081: MUL     r0, r3, r0       fact.registers=[1 | 1 | 1 2 ?]      calls=[main fact fact]<br>    0094: RET                      fact.registers=[2 | 1 | 1 2 ?]      calls=[main fact fact]<br>    0081: MUL     r0, r3, r0       fact.registers=[2 | 2 | 1 3 ?]      calls=[main fact]<br>    0094: RET                      fact.registers=[6 | 2 | 1 3 ?]      calls=[main fact]<br>    0113: PRINT   r0               main.registers=[6 | 3]              calls=[main]<br>    6<br>    Constant pool:<br>    0000: &lt;FunctionSymbol: name='fact', address=0, args=1, locals=3&gt;<br>    0001: 2<br>    0002: 1<br>    0003: &lt;FunctionSymbol: name='main', address=95, args=0, locals=1&gt;<br>    0004: 3<br><br>    Code memory:<br>    0000:   6   0   0   0   2   0   0   0<br>    0008:   1   4   0   0   0   3   0   0<br>    0016:   0   1   0   0   0   2  13   0<br>    0024:   0   0   3   0   0   0  41   6<br>    0032:   0   0   0   0   0   0   0   2<br>    0040:   9   6   0   0   0   2   0   0<br>    0048:   0   2  14   0   0   0   3   0<br>    0056:   0   0   1   2   0   0   0   1<br>    0064:   0   0   0   1   0   0   0   2<br>    0072:  16   0   0   0   0   0   0   0<br>    0080:   1   3   0   0   0   0   0   0<br>    0088:   0   3   0   0   0   0   9   6<br>    0096:   0   0   0   1   0   0   0   4<br>    0104:  16   0   0   0   0   0   0   0<br>    0112:   1  15   0   0   0   0  10<br><br>    Disassembly:<br>    0000: LOADK   r2, #1:2<br>    0009: LT      r3, r1, r2<br>    0022: BRF     r3, 41<br>    0031: LOADK   r0, #2:1<br>    0040: RET<br>    0041: LOADK   r2, #2:1<br>    0050: MOVE    r3, r1<br>    0059: SUB     r1, r1, r2<br>    0072: CALL    #0:fact@0, r1<br>    0081: MUL     r0, r3, r0<br>    0094: RET<br>    0095: LOADK   r1, #4:3<br>    0104: CALL    #0:fact@0, r1<br>    0113: PRINT   r0<br>    0118: HALT<br><br><br><br>=======<br>CHANGES<br>=======<br><br>0.2 (2011-03-03)<br>----------------<br><br>- Added Bytecode Assembler<br>- Added Register-Based Virtual Machine<br><br>0.1 (initial release)<br>---------------------<br><br>- Initial release of TinyPie interpreter\n          </div>"}, "last_serial": 800706, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "7420865a3eca3f6468eac6d3f0dba41c", "sha256": "c3eb41a8699f8a72e8e7990b073a4d464614169d1dc5d5ae26c4ffe7fe4ea351"}, "downloads": -1, "filename": "tinypie-0.1.tar.gz", "has_sig": false, "md5_digest": "7420865a3eca3f6468eac6d3f0dba41c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13366, "upload_time": "2011-01-21T12:29:29", "upload_time_iso_8601": "2011-01-21T12:29:29.061372Z", "url": "https://files.pythonhosted.org/packages/f5/6f/26be9d70b957d2b448a92dcd03d9bb4c81fcdc23ba977b32dba92c21dfbc/tinypie-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "bfa44b8c67097bf5c77b15d6e248aa86", "sha256": "36a470f2cab64db87cb11f287e542c2b3c19fe30d2823e762aeaa8b454dd125f"}, "downloads": -1, "filename": "tinypie-0.2.tar.gz", "has_sig": false, "md5_digest": "bfa44b8c67097bf5c77b15d6e248aa86", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31008, "upload_time": "2011-03-03T07:17:00", "upload_time_iso_8601": "2011-03-03T07:17:00.314328Z", "url": "https://files.pythonhosted.org/packages/e7/8b/bfafdf8249c77929428c201a440944ea0285d11b4fe6910b23e944465de3/tinypie-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bfa44b8c67097bf5c77b15d6e248aa86", "sha256": "36a470f2cab64db87cb11f287e542c2b3c19fe30d2823e762aeaa8b454dd125f"}, "downloads": -1, "filename": "tinypie-0.2.tar.gz", "has_sig": false, "md5_digest": "bfa44b8c67097bf5c77b15d6e248aa86", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31008, "upload_time": "2011-03-03T07:17:00", "upload_time_iso_8601": "2011-03-03T07:17:00.314328Z", "url": "https://files.pythonhosted.org/packages/e7/8b/bfafdf8249c77929428c201a440944ea0285d11b4fe6910b23e944465de3/tinypie-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:52:58 2020"}