{"info": {"author": "Joseph Halstead", "author_email": "josephhalstead89@gmail.com", "bugtrack_url": null, "classifiers": ["Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# PyVariantFilter\n\nVersatile Python package for filtering germline genetic variants based on inheritance pattern. \n\n * Find Autosomal Dominant, Autosomal Reccessive, X Linked Reccessive, X Linked Dominant, De Novo and Compound Heterozygous variants in your dataset.\n\n * Filter variants by their annotations by applying custom python filtering functions.\n\n * Convert VEP annotated VCFs to Pandas DataFrames.\n\n## Quick Start\n\n```python\nfrom pyvariantfilter.family import Family\nfrom pyvariantfilter.variant_set import VariantSet\n\n# Create a Family object describing the relationships between samples as well as their sex and affected status\nmy_family = Family('FAM001')\nmy_family.read_from_ped_file(ped_file_path='test_data/NA12878.ped', family_id='FAM001', proband_id='NA12878i')\n\n# Associate a VariantSet object with a the Family object we just created\nmy_variant_set = VariantSet()\nmy_variant_set.add_family(my_family)\n\n# Read variants from a standard VCF and apply initial filtering function\nmy_variant_set.read_variants_from_vcf('test_data/NA12878.trio.vep.vcf', proband_variants_only=True, filter_func=import_filter, args=(new_family.get_proband_id(),) )\n\n# Get candidate compound hets\nmy_variant_set.get_candidate_compound_hets()\n\n# Filter the compound hets by phasing them using parental information\nmy_variant_set.filter_compound_hets()\n\n# Flatten the compound hets to a dictionary with each compound het as a key\nmy_variant_set.get_filtered_compound_hets_as_dict()\n\n# Create Pandas Dataframe\ndf = my_variant_set.to_df()\n\n# Filter to view variants matching any inheritiance model.\ndf[['variant_id', 'worst_consequence','inheritance_models', 'csq_SYMBOL' ]][df['inheritance_models'] != ''].head()\n\n\n```\n\nWhere the filter\\_func argument to read\\_variants\\_from\\_vcf() is something like the function below.\n\n```python\ndef import_filter(variant, proband_id):\n\n    if variant.has_alt(proband_id) and variant.passes_gt_filter(proband_id) and variant.passes_filter():\n\n        freq_filter = variant.filter_on_numerical_transcript_annotation_lte(annotation_key='gnomAD_AF',\n                                                                                          ad_het=0.01,\n                                                                                          ad_hom_alt=0.01,\n                                                                                          x_male =0.01,\n                                                                                          x_female_het=0.01,\n                                                                                          x_female_hom=0.01,\n                                                                                          compound_het=0.01,\n                                                                                          y=0.01,\n                                                                                          mt=0.01,\n                                                                                          )\n\n\n        csq_filter = False\n\n        if variant.get_worst_consequence() in {'transcript_ablation': None,\n                                               'splice_acceptor_variant': None,\n                                               'splice_donor_variant': None,\n                                               'stop_gained': None,\n                                               'frameshift_variant': None,\n                                               'stop_lost': None,\n                                               'start_lost': None}:\n\n            csq_filter = True\n\n\n        if csq_filter and freq_filter:\n\n            return True\n\n    return False\n\n```\n\n## Input Requirements\n\nWhen using the VariantSet classes read from vcf functions a decomposed (Split Multiallelic Variants) and VEP annotated VCF is required. \n\nBoth GATK and Platypus VCFs are supported.\n\nUse VT and VEP with the following commands to preprocess your VCF before analysing.\n\n* https://github.com/atks/vt\n* https://github.com/Ensembl/ensembl-vep\n\nAnnotation with VEP is only neccecary if you want to find compound hets.\n\n```\n# split multiallellics and normalise\ncat input.vcf | vt decompose -s - | vt normalize -r reference.fasta - > input.norm.vcf\n\n# Annotate with VEP\nvep --verbose --format vcf --everything --fork 1 --species homo_sapiens --assembly GRCh37 --input_file input.norm.vcf \\\n--output_file input.norm.vep.vcf --force_overwrite --cache --dir vep_cache_location \\\n--fasta reference.fasta --offline --cache_version 94 -no_escape --shift_hgvs 1 --exclude_predicted --vcf --refseq --flag_pick \\\n--custom gnomad.genomes.vcf.gz,gnomADg,vcf,exact,0,AF_POPMAX  \\\n--custom gnomad.exomes.vcf.gz,gnomADe,vcf,exact,0,AF_POPMAX \\\n\n```\n\n## Inheritance Models\n\nA lot of the rules here have been adapted from the GEMINI software which is worth checking out. https://gemini.readthedocs.io/en/latest/\n\n### Autosomal Dominant\n\n1) Variant must be on an autosome.\n\n2) All affected samples must be heterozygous or missing e.g. ./. See lenient option to allow homozygous alternate genotypes in affected samples other than the proband.\n\n3) If the variant is not in a low penetrant gene then all unaffected samples must be homozygous reference or have a missing genotype.\n\n\n### Autosomal Reccessive\n\n1) Variant must be on an Autosome.\n\n2) All affected samples must be homozygous for the alternate allele. Can be missing.\n\n3) No unaffected samples can be homozygous for the alternate allele. Can be missing.\n\n### X-Linked Reccessive\n\n1) Variant must be on the X chromosome.\n\n2) All affected female samples must be homozygous for the alternate allele or missing.\n\n3) No unaffected female samples can be homozygous for the alternate allele.\n\n4) All affected male samples must have the variant or be missing.\n\n5) No unaffected male samples can have the variant.\n\n### X-Linked Dominant\n\n1) Variant must be on the X chromosome.\n\n2) The daughters of affected male samples must be affected.\n\n3) The sons of affected males must not be affected.\n\n4) Affected male samples must have the variant or be missing.\n\n5) Affected female samples  must be heterozygous or be missing.\n\n6) Unaffected samples must not have the variant.\n\n### De Novo\n\n1) Variant must be in the proband and not in either parent.\n\n2) Parents must have a GQ value above min\\_parental\\_gq.\n\n3) Parents must have a DP value above min\\_parental\\_depth.\n\n4) Parents must have a alt/ref ratio below max\\_parental\\_alt\\_ref\\_ratio.\n\n\n### Compound Heterozygous\n\n1) No unaffected samples can have the pair of variants. Can be adjusted using the allow\\_hets\\_in\\_unaffected argument.\n\n2) All affected samples must have the pair of variants or be missing the genotype data. Can be adjusted using the check_affected argument.\n\n3) \n\na) One of the pair must be inherited from mum and the other from dad.\n\nb) If include_denovo is True then one of the pair can be de_novo and the other inherited from either parent or both can be de_novo. There are no minimum requirements e.g. depth on the de_novo calls.\n\n\n## Install\n\n### Requirements\n\n* Python 3.6 or greater\n* Pysam 0.15.0\n* Pandas 0.23.4\n\n### Install the Package\n\n`pip install pyvariantfilter `\n\nor\n\n`git clone https://github.com/josephhalstead/pyvariantfilter.git `\n\n## Examples\n\nSee the notebooks folder for some examples of using the library for WES and WGS analyses.\n\n## Test\n\n`python tests.py`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/josephhalstead/pyvariantfilter", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "pyvariantfilter", "package_url": "https://pypi.org/project/pyvariantfilter/", "platform": "", "project_url": "https://pypi.org/project/pyvariantfilter/", "project_urls": {"Homepage": "https://github.com/josephhalstead/pyvariantfilter"}, "release_url": "https://pypi.org/project/pyvariantfilter/1.0.3/", "requires_dist": ["pysam (>=0.15.2)", "pandas (>=0.23.4)"], "requires_python": "", "summary": "Python package for filtering variants.", "version": "1.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>PyVariantFilter</h1>\n<p>Versatile Python package for filtering germline genetic variants based on inheritance pattern.</p>\n<ul>\n<li>\n<p>Find Autosomal Dominant, Autosomal Reccessive, X Linked Reccessive, X Linked Dominant, De Novo and Compound Heterozygous variants in your dataset.</p>\n</li>\n<li>\n<p>Filter variants by their annotations by applying custom python filtering functions.</p>\n</li>\n<li>\n<p>Convert VEP annotated VCFs to Pandas DataFrames.</p>\n</li>\n</ul>\n<h2>Quick Start</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyvariantfilter.family</span> <span class=\"kn\">import</span> <span class=\"n\">Family</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyvariantfilter.variant_set</span> <span class=\"kn\">import</span> <span class=\"n\">VariantSet</span>\n\n<span class=\"c1\"># Create a Family object describing the relationships between samples as well as their sex and affected status</span>\n<span class=\"n\">my_family</span> <span class=\"o\">=</span> <span class=\"n\">Family</span><span class=\"p\">(</span><span class=\"s1\">'FAM001'</span><span class=\"p\">)</span>\n<span class=\"n\">my_family</span><span class=\"o\">.</span><span class=\"n\">read_from_ped_file</span><span class=\"p\">(</span><span class=\"n\">ped_file_path</span><span class=\"o\">=</span><span class=\"s1\">'test_data/NA12878.ped'</span><span class=\"p\">,</span> <span class=\"n\">family_id</span><span class=\"o\">=</span><span class=\"s1\">'FAM001'</span><span class=\"p\">,</span> <span class=\"n\">proband_id</span><span class=\"o\">=</span><span class=\"s1\">'NA12878i'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Associate a VariantSet object with a the Family object we just created</span>\n<span class=\"n\">my_variant_set</span> <span class=\"o\">=</span> <span class=\"n\">VariantSet</span><span class=\"p\">()</span>\n<span class=\"n\">my_variant_set</span><span class=\"o\">.</span><span class=\"n\">add_family</span><span class=\"p\">(</span><span class=\"n\">my_family</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Read variants from a standard VCF and apply initial filtering function</span>\n<span class=\"n\">my_variant_set</span><span class=\"o\">.</span><span class=\"n\">read_variants_from_vcf</span><span class=\"p\">(</span><span class=\"s1\">'test_data/NA12878.trio.vep.vcf'</span><span class=\"p\">,</span> <span class=\"n\">proband_variants_only</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">filter_func</span><span class=\"o\">=</span><span class=\"n\">import_filter</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">new_family</span><span class=\"o\">.</span><span class=\"n\">get_proband_id</span><span class=\"p\">(),)</span> <span class=\"p\">)</span>\n\n<span class=\"c1\"># Get candidate compound hets</span>\n<span class=\"n\">my_variant_set</span><span class=\"o\">.</span><span class=\"n\">get_candidate_compound_hets</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Filter the compound hets by phasing them using parental information</span>\n<span class=\"n\">my_variant_set</span><span class=\"o\">.</span><span class=\"n\">filter_compound_hets</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Flatten the compound hets to a dictionary with each compound het as a key</span>\n<span class=\"n\">my_variant_set</span><span class=\"o\">.</span><span class=\"n\">get_filtered_compound_hets_as_dict</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Create Pandas Dataframe</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">my_variant_set</span><span class=\"o\">.</span><span class=\"n\">to_df</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Filter to view variants matching any inheritiance model.</span>\n<span class=\"n\">df</span><span class=\"p\">[[</span><span class=\"s1\">'variant_id'</span><span class=\"p\">,</span> <span class=\"s1\">'worst_consequence'</span><span class=\"p\">,</span><span class=\"s1\">'inheritance_models'</span><span class=\"p\">,</span> <span class=\"s1\">'csq_SYMBOL'</span> <span class=\"p\">]][</span><span class=\"n\">df</span><span class=\"p\">[</span><span class=\"s1\">'inheritance_models'</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"s1\">''</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">()</span>\n</pre>\n<p>Where the filter_func argument to read_variants_from_vcf() is something like the function below.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">import_filter</span><span class=\"p\">(</span><span class=\"n\">variant</span><span class=\"p\">,</span> <span class=\"n\">proband_id</span><span class=\"p\">):</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">variant</span><span class=\"o\">.</span><span class=\"n\">has_alt</span><span class=\"p\">(</span><span class=\"n\">proband_id</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">variant</span><span class=\"o\">.</span><span class=\"n\">passes_gt_filter</span><span class=\"p\">(</span><span class=\"n\">proband_id</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">variant</span><span class=\"o\">.</span><span class=\"n\">passes_filter</span><span class=\"p\">():</span>\n\n        <span class=\"n\">freq_filter</span> <span class=\"o\">=</span> <span class=\"n\">variant</span><span class=\"o\">.</span><span class=\"n\">filter_on_numerical_transcript_annotation_lte</span><span class=\"p\">(</span><span class=\"n\">annotation_key</span><span class=\"o\">=</span><span class=\"s1\">'gnomAD_AF'</span><span class=\"p\">,</span>\n                                                                                          <span class=\"n\">ad_het</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n                                                                                          <span class=\"n\">ad_hom_alt</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n                                                                                          <span class=\"n\">x_male</span> <span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n                                                                                          <span class=\"n\">x_female_het</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n                                                                                          <span class=\"n\">x_female_hom</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n                                                                                          <span class=\"n\">compound_het</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n                                                                                          <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n                                                                                          <span class=\"n\">mt</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n                                                                                          <span class=\"p\">)</span>\n\n\n        <span class=\"n\">csq_filter</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">variant</span><span class=\"o\">.</span><span class=\"n\">get_worst_consequence</span><span class=\"p\">()</span> <span class=\"ow\">in</span> <span class=\"p\">{</span><span class=\"s1\">'transcript_ablation'</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                                               <span class=\"s1\">'splice_acceptor_variant'</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                                               <span class=\"s1\">'splice_donor_variant'</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                                               <span class=\"s1\">'stop_gained'</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                                               <span class=\"s1\">'frameshift_variant'</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                                               <span class=\"s1\">'stop_lost'</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                                               <span class=\"s1\">'start_lost'</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">}:</span>\n\n            <span class=\"n\">csq_filter</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n\n        <span class=\"k\">if</span> <span class=\"n\">csq_filter</span> <span class=\"ow\">and</span> <span class=\"n\">freq_filter</span><span class=\"p\">:</span>\n\n            <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n    <span class=\"k\">return</span> <span class=\"kc\">False</span>\n</pre>\n<h2>Input Requirements</h2>\n<p>When using the VariantSet classes read from vcf functions a decomposed (Split Multiallelic Variants) and VEP annotated VCF is required.</p>\n<p>Both GATK and Platypus VCFs are supported.</p>\n<p>Use VT and VEP with the following commands to preprocess your VCF before analysing.</p>\n<ul>\n<li><a href=\"https://github.com/atks/vt\" rel=\"nofollow\">https://github.com/atks/vt</a></li>\n<li><a href=\"https://github.com/Ensembl/ensembl-vep\" rel=\"nofollow\">https://github.com/Ensembl/ensembl-vep</a></li>\n</ul>\n<p>Annotation with VEP is only neccecary if you want to find compound hets.</p>\n<pre><code># split multiallellics and normalise\ncat input.vcf | vt decompose -s - | vt normalize -r reference.fasta - &gt; input.norm.vcf\n\n# Annotate with VEP\nvep --verbose --format vcf --everything --fork 1 --species homo_sapiens --assembly GRCh37 --input_file input.norm.vcf \\\n--output_file input.norm.vep.vcf --force_overwrite --cache --dir vep_cache_location \\\n--fasta reference.fasta --offline --cache_version 94 -no_escape --shift_hgvs 1 --exclude_predicted --vcf --refseq --flag_pick \\\n--custom gnomad.genomes.vcf.gz,gnomADg,vcf,exact,0,AF_POPMAX  \\\n--custom gnomad.exomes.vcf.gz,gnomADe,vcf,exact,0,AF_POPMAX \\\n\n</code></pre>\n<h2>Inheritance Models</h2>\n<p>A lot of the rules here have been adapted from the GEMINI software which is worth checking out. <a href=\"https://gemini.readthedocs.io/en/latest/\" rel=\"nofollow\">https://gemini.readthedocs.io/en/latest/</a></p>\n<h3>Autosomal Dominant</h3>\n<ol>\n<li>\n<p>Variant must be on an autosome.</p>\n</li>\n<li>\n<p>All affected samples must be heterozygous or missing e.g. ./. See lenient option to allow homozygous alternate genotypes in affected samples other than the proband.</p>\n</li>\n<li>\n<p>If the variant is not in a low penetrant gene then all unaffected samples must be homozygous reference or have a missing genotype.</p>\n</li>\n</ol>\n<h3>Autosomal Reccessive</h3>\n<ol>\n<li>\n<p>Variant must be on an Autosome.</p>\n</li>\n<li>\n<p>All affected samples must be homozygous for the alternate allele. Can be missing.</p>\n</li>\n<li>\n<p>No unaffected samples can be homozygous for the alternate allele. Can be missing.</p>\n</li>\n</ol>\n<h3>X-Linked Reccessive</h3>\n<ol>\n<li>\n<p>Variant must be on the X chromosome.</p>\n</li>\n<li>\n<p>All affected female samples must be homozygous for the alternate allele or missing.</p>\n</li>\n<li>\n<p>No unaffected female samples can be homozygous for the alternate allele.</p>\n</li>\n<li>\n<p>All affected male samples must have the variant or be missing.</p>\n</li>\n<li>\n<p>No unaffected male samples can have the variant.</p>\n</li>\n</ol>\n<h3>X-Linked Dominant</h3>\n<ol>\n<li>\n<p>Variant must be on the X chromosome.</p>\n</li>\n<li>\n<p>The daughters of affected male samples must be affected.</p>\n</li>\n<li>\n<p>The sons of affected males must not be affected.</p>\n</li>\n<li>\n<p>Affected male samples must have the variant or be missing.</p>\n</li>\n<li>\n<p>Affected female samples  must be heterozygous or be missing.</p>\n</li>\n<li>\n<p>Unaffected samples must not have the variant.</p>\n</li>\n</ol>\n<h3>De Novo</h3>\n<ol>\n<li>\n<p>Variant must be in the proband and not in either parent.</p>\n</li>\n<li>\n<p>Parents must have a GQ value above min_parental_gq.</p>\n</li>\n<li>\n<p>Parents must have a DP value above min_parental_depth.</p>\n</li>\n<li>\n<p>Parents must have a alt/ref ratio below max_parental_alt_ref_ratio.</p>\n</li>\n</ol>\n<h3>Compound Heterozygous</h3>\n<ol>\n<li>\n<p>No unaffected samples can have the pair of variants. Can be adjusted using the allow_hets_in_unaffected argument.</p>\n</li>\n<li>\n<p>All affected samples must have the pair of variants or be missing the genotype data. Can be adjusted using the check_affected argument.</p>\n</li>\n<li>\n</ol>\n<p>a) One of the pair must be inherited from mum and the other from dad.</p>\n<p>b) If include_denovo is True then one of the pair can be de_novo and the other inherited from either parent or both can be de_novo. There are no minimum requirements e.g. depth on the de_novo calls.</p>\n<h2>Install</h2>\n<h3>Requirements</h3>\n<ul>\n<li>Python 3.6 or greater</li>\n<li>Pysam 0.15.0</li>\n<li>Pandas 0.23.4</li>\n</ul>\n<h3>Install the Package</h3>\n<p><code>pip install pyvariantfilter</code></p>\n<p>or</p>\n<p><code>git clone https://github.com/josephhalstead/pyvariantfilter.git</code></p>\n<h2>Examples</h2>\n<p>See the notebooks folder for some examples of using the library for WES and WGS analyses.</p>\n<h2>Test</h2>\n<p><code>python tests.py</code></p>\n\n          </div>"}, "last_serial": 6881539, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "e92624e1d627e098b347d62d8aea7715", "sha256": "8284aa45be96c9dce54f54eb38eea4ff96f3762aa2226b9ea703bc67005cd50f"}, "downloads": -1, "filename": "pyvariantfilter-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "e92624e1d627e098b347d62d8aea7715", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21038, "upload_time": "2019-05-17T11:43:00", "upload_time_iso_8601": "2019-05-17T11:43:00.090573Z", "url": "https://files.pythonhosted.org/packages/b4/0a/a169343a47d4026b8844c706d739fa9ad808f5916717f9e6acdbe261f129/pyvariantfilter-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "818c01fbec313e2f422e17aa94159217", "sha256": "fae11b5cb7463932410faa70da25598fa2844ff5e06fd1c1e9e5dcef636ab8a6"}, "downloads": -1, "filename": "pyvariantfilter-0.0.1.tar.gz", "has_sig": false, "md5_digest": "818c01fbec313e2f422e17aa94159217", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19873, "upload_time": "2019-05-17T11:43:03", "upload_time_iso_8601": "2019-05-17T11:43:03.248996Z", "url": "https://files.pythonhosted.org/packages/d5/94/fcf9ee2961bd3fd5f4f653443655e6ddffa4e61d5f0cc3ac808072c90db1/pyvariantfilter-0.0.1.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "c86c26a8d74cb1fc2043b9e433e7c2a9", "sha256": "0f314ec65d25424ecc4bddc15d0585835ed8d5a4701c17fadb5cb8cf7a3c8f4b"}, "downloads": -1, "filename": "pyvariantfilter-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "c86c26a8d74cb1fc2043b9e433e7c2a9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21629, "upload_time": "2020-03-21T12:21:28", "upload_time_iso_8601": "2020-03-21T12:21:28.079846Z", "url": "https://files.pythonhosted.org/packages/c1/c4/ba856ac66818d587055257e88711c64bc5edf048e8f63a17685324dad42a/pyvariantfilter-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d9e1d3e371d190fe99ce4a69eb6b6097", "sha256": "d7aedde640bd779849630585ff7cb2160078010140478027339ecc84ed3712c6"}, "downloads": -1, "filename": "pyvariantfilter-1.0.0.tar.gz", "has_sig": false, "md5_digest": "d9e1d3e371d190fe99ce4a69eb6b6097", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18424, "upload_time": "2020-03-21T12:21:29", "upload_time_iso_8601": "2020-03-21T12:21:29.357345Z", "url": "https://files.pythonhosted.org/packages/d6/ee/73650093d510835fc121480f2b814d0e31b06b3fde46c37a3a8350bbe0fa/pyvariantfilter-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "25b02d05f5d74f04999e699f5d2eb4f1", "sha256": "d0dc411d0b1cc0b9e17316ef7da5609e75fcdae3f53ce93430fe8c4728cd6c65"}, "downloads": -1, "filename": "pyvariantfilter-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "25b02d05f5d74f04999e699f5d2eb4f1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21639, "upload_time": "2020-03-24T14:08:10", "upload_time_iso_8601": "2020-03-24T14:08:10.325690Z", "url": "https://files.pythonhosted.org/packages/b1/a6/83afc7930843cc03cca990f258931af2f9b1929a7643a18222f2eabbdd2c/pyvariantfilter-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e853f947de2e43d5b8da8291e2e18008", "sha256": "539b05edd3ddf4d1ca30bfd9cf6ad5ffaecdfef16de7d314425a7288378aa359"}, "downloads": -1, "filename": "pyvariantfilter-1.0.1.tar.gz", "has_sig": false, "md5_digest": "e853f947de2e43d5b8da8291e2e18008", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18443, "upload_time": "2020-03-24T14:08:12", "upload_time_iso_8601": "2020-03-24T14:08:12.598100Z", "url": "https://files.pythonhosted.org/packages/8b/99/d3a220972b557435cb481078de79f94a24e127953d84ab97973c95e05371/pyvariantfilter-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "6838405c22423e5451137d70d19e5f68", "sha256": "c666027b181a50f798854393d1e0707fd6302933b5aba390fd69983b9071adf9"}, "downloads": -1, "filename": "pyvariantfilter-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "6838405c22423e5451137d70d19e5f68", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21630, "upload_time": "2020-03-24T14:42:55", "upload_time_iso_8601": "2020-03-24T14:42:55.833081Z", "url": "https://files.pythonhosted.org/packages/34/dc/5f843ef189407a69a4af98c0e517a0d1bc0545acb4257f9e244a6fb3fa9c/pyvariantfilter-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c0cb4504028202744956959538b0b9e3", "sha256": "65ae17795b658cb462bf864d1851a2579dea56f563195d9f93ab19f29610be27"}, "downloads": -1, "filename": "pyvariantfilter-1.0.2.tar.gz", "has_sig": false, "md5_digest": "c0cb4504028202744956959538b0b9e3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18433, "upload_time": "2020-03-24T14:42:59", "upload_time_iso_8601": "2020-03-24T14:42:59.314469Z", "url": "https://files.pythonhosted.org/packages/1a/ea/22ba8271884e6a613d44191068abf0cb2ff8d102d3fdbed532661806a5a0/pyvariantfilter-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "d27c217a818011adb1848a2867959e96", "sha256": "080c22751ffa38a9d2a94e17a5185ae656dba26c85bd1838bc77dc39028580c2"}, "downloads": -1, "filename": "pyvariantfilter-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "d27c217a818011adb1848a2867959e96", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21759, "upload_time": "2020-03-25T15:35:41", "upload_time_iso_8601": "2020-03-25T15:35:41.727792Z", "url": "https://files.pythonhosted.org/packages/36/ea/26b2ab1d53c16e5d5cd26006c2fedfca85d11f32a42fd5978caca78b5a30/pyvariantfilter-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "abd39a0e2c3784031a2736bb2331a942", "sha256": "e6c0fcb229d65ad4ebde2ff585dac43e2bd6e45036d79acb83d99f6772c671e2"}, "downloads": -1, "filename": "pyvariantfilter-1.0.3.tar.gz", "has_sig": false, "md5_digest": "abd39a0e2c3784031a2736bb2331a942", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21373, "upload_time": "2020-03-25T15:35:43", "upload_time_iso_8601": "2020-03-25T15:35:43.033100Z", "url": "https://files.pythonhosted.org/packages/de/d0/492385b70412ec2fcc5ad3d8be9a7eedee391727766447967395ca68496f/pyvariantfilter-1.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d27c217a818011adb1848a2867959e96", "sha256": "080c22751ffa38a9d2a94e17a5185ae656dba26c85bd1838bc77dc39028580c2"}, "downloads": -1, "filename": "pyvariantfilter-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "d27c217a818011adb1848a2867959e96", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21759, "upload_time": "2020-03-25T15:35:41", "upload_time_iso_8601": "2020-03-25T15:35:41.727792Z", "url": "https://files.pythonhosted.org/packages/36/ea/26b2ab1d53c16e5d5cd26006c2fedfca85d11f32a42fd5978caca78b5a30/pyvariantfilter-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "abd39a0e2c3784031a2736bb2331a942", "sha256": "e6c0fcb229d65ad4ebde2ff585dac43e2bd6e45036d79acb83d99f6772c671e2"}, "downloads": -1, "filename": "pyvariantfilter-1.0.3.tar.gz", "has_sig": false, "md5_digest": "abd39a0e2c3784031a2736bb2331a942", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21373, "upload_time": "2020-03-25T15:35:43", "upload_time_iso_8601": "2020-03-25T15:35:43.033100Z", "url": "https://files.pythonhosted.org/packages/de/d0/492385b70412ec2fcc5ad3d8be9a7eedee391727766447967395ca68496f/pyvariantfilter-1.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:12:13 2020"}