{"info": {"author": "Adam Hooper", "author_email": "adam@adamhooper.com", "bugtrack_url": null, "classifiers": [], "description": "channels_rabbitmq\n=================\n\nA Django Channels channel layer that uses RabbitMQ as its backing store.\n\nInstallation\n------------\n\n``pip install channels_rabbitmq``\n\nUsage\n-----\n\nThen set up the channel layer in your Django settings file like so::\n\n    CHANNEL_LAYERS = {\n        \"default\": {\n            \"BACKEND\": \"channels_rabbitmq.core.RabbitmqChannelLayer\",\n            \"CONFIG\": {\n                \"host\": \"amqp://guest:guest@127.0.0.1/asgi\",\n                # \"ssl_context\": ... (optional)\n            },\n        },\n    }\n\nPossible options for ``CONFIG`` are listed below.\n\n``host``\n~~~~~~~~\n\nURL of the server to connect to, adhering to `RabbitMQ spec\n<https://www.rabbitmq.com/uri-spec.html>`_. To connect to a RabbitMQ cluster,\nuse a DNS server to resolve a hostname to multiple IP addresses.\nchannels_rabbitmq will automatically reconnect if at least one of them is\nreachable in case of a disconnection.\n\n``expiry``\n~~~~~~~~~~\n\nMinimum number of seconds a message should wait in a RabbitMQ queue, before it\nmay be silently dropped.\n\nDefaults to ``60``. You generally shouldn't need to change this, but you may\nwant to turn it down if you have peaky traffic you wish to drop, or up if you\nhave peaky traffic you want to backlog until you get to it.\n\n``local_capacity``\n~~~~~~~~~~~~~~~~~~\n\nNumber of messages queued in memory. Defaults to ``100``. (A message sent to\na group with two channels counts as two messages.) When ``local_capacity``\nmessages are queued, the message backlog will grow on RabbitMQ.\n\n``local_expiry``\n~~~~~~~~~~~~~~~~\n\nMinimum number of seconds a message received from RabbitMQ must be held in\nmemory waiting for ``receive()``, before it may be dropped. Defaults to\n``expiry``.\n\nA warning will be logged when a message expires locally. The warning can\nindicate that a channel has more messages than it can handle; or that\nmessages are being sent to a channel that does not exist. (Perhaps a missing\nchannel was implied by ``group_add()``, and a matching ``group_discard()``\nwas never called.)\n\n``remote_capacity``\n~~~~~~~~~~~~~~~~~~~\n\nNumber of messages stored on RabbitMQ for each client. Defaults to ``100``.\n(A message sent to a group with three channels on two distinct clients counts\nas two messages.) When ``remote_capacity`` messages are queued in RabbitMQ,\nthe channel will refuse new messages. Calls from any client to ``send()`` or\n``group_send()`` to the at-capacity client will raise ``ChannelFull``.\n\n``prefetch_count``\n~~~~~~~~~~~~~~~~~~\n\nNumber of messages to read from RabbitMQ at a time. Defaults to ``10``. This\nmakes ``local_capacity`` a bit of a \"loose\" setting: if messages are queued\nrapidly enough, the client may request ``prefetch_count`` messages even if it\nalready has ``local_capacity - 1`` messages in memory. Higher settings\naccelerate throughput a little bit; lower settings help adhere to\n``local_capacity`` more rigorously.\n\n``ssl_context``\n~~~~~~~~~~~~~~~\n\nAn `SSL context\n<https://docs.python.org/3/library/ssl.html#ssl-contexts>`_. Changes the\ndefault ``host`` port to 5671 (instead of 5672).\n\nFor instance, to connect to an TLS RabbitMQ service that will verify your\nclient::\n\n    import ssl\n    ssl_context = ssl.create_default_context(\n        cafile=str(Path(__file__).parent.parent / 'ssl' / 'server.cert'),\n    )\n    ssl_context.load_cert_chain(\n        certfile=str(Path(__file__).parent.parent / 'ssl' / 'client.certchain'),\n        keyfile=str(Path(__file__).parent.parent / 'ssl' / 'client.key'),\n    )\n    CHANNEL_LAYERS['default']['CONFIG']['ssl_context'] = ssl_context\n\nBy default, there is no SSL context; all messages (and passwords) are\nare transmitted in cleartext.\n\n``groups_exchange``\n~~~~~~~~~~~~~~~~~~~\n\nGlobal direct exchange name used by channels to exchange group messages.\nDefaults to ``\"groups\"``. See also `Design decisions`_.\n\nDesign decisions\n----------------\n\nTo scale enormously, this layer only creates one RabbitMQ queue per instance.\nThat means one web server gets one RabbitMQ queue, no matter how many\nwebsocket connections are open. For each message being sent, the client-side\nlayer determines the RabbitMQ queue name and uses it as the routing key.\n\nGroups are implemented using a single, global RabbitMQ direct exchange called\n\"groups\" by default. To send a message to a group, the layer sends the message to the\n\"groups\" exchange with the group name as the routing key. The client binds and\nunbinds during ``group_add()`` and ``group_remove()`` to ensure messages for\nany of its groups will reach it. See also the `groups_exchange`_ option.\n\nRabbitMQ queues are ``exclusive``: when a client disconnects (through close or\ncrash), RabbitMQ will delete the queue and unbind the groups.\n\nDjango Channels' specification does not account for \"connecting\" and\n\"disconnecting\", so this layer is always connected. It will reconnect forever\nin the event loop's background, logging warnings each time the connect fails.\n\nOnce a connection has been created, it pollutes the event loop so that\n``async_to_sync()`` will destroy the connection if it was created within\n``async_to_sync()``. Each connection starts a background async loop that pulls\nmessages from RabbitMQ and routes them to receiver queues; each ``receive()``\nqueries receiver queues. Empty queues are deleted. TODO delete queues that\nonly contain expired messages, so we don't leak when sending to dead channels.\n\nDeviations from the Channel Layer Specification\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe `Channel Layer Specification\n<https://channels.readthedocs.io/en/latest/channel_layer_spec.html>`_ bends to\nRedis-related restrictions. RabbitMQ cannot emulate Redis. Here are the\ndifferences:\n\n* **No ``flush`` extension**: To flush all state, simply disconnect all clients.\n  (RabbitMQ won't allow one client to delete another client's data structures.)\n* **No ``group_expiry`` option**: The `group_expiry option\n  <https://channels.readthedocs.io/en/latest/channel_layer_spec.html#persistence>`_\n  recovers when a ``group_add()`` has no matching ``group_discard()``. But the\n  \"group membership expiry\" logic has a fatal flaw: it disconnects legitimate\n  members. ``channels_rabbitmq`` addresses each root problem instead:\n\n  * Web-server crash: RabbitMQ wipes all state related to a web server when\n    the web server disconnects. There's no problem here for ``group_expiry``\n    to solve.\n  * Programming errors: You may err and call ``group_add()`` without\n    eventually calling ``group_discard()``. Redis can't detect this\n    programming error (because it can't detect web-server crashes). RabbitMQ\n    can. The ``local_expiry`` option keeps your site running after you\n    erroneously miss a ``group_discard()``. The channel layer warns when\n    discarding expired messages. Monitor your server logs to detect your\n    errors.\n* **No \"normal channels\"**: `Normal channels\n  <https://channels.readthedocs.io/en/latest/channel_layer_spec.html#channels>`_\n  are job queues. In most projects, \"normal channel\" readers are worker\n  processes, ideally divorced from Websockets and Django.\n\n  You are welcome to submit a ``channels_rabbitmq`` pull request to support this\n  under-specified aspect of the Channel Layer Specification. But why reinvent\n  the wheel? There are thousands of job-queue implementations out there already.\n  Django Channels is a bad fit, because it is tuned for Websockets.\n\n  If you want an async, RabbitMQ-based job queue, investigate `aiormq\n  <https://github.com/mosquito/aiormq>`_ and `aioamqp\n  <https://github.com/polyconseil/aioamqp>`_. You can even send your jobs\n  to a separate RabbitMQ server or virtual host.\n\n  Currently, this project's strategy is to wait for `Celery 5.0.0\n  <https://github.com/celery/celery/milestone/7>`_, evaluate it, and then\n  recommend an alternative to \"normal channels.\" (With Celery 4, it's\n  inefficient for workers to send messages to the Django Channels layer, because\n  they need to launch a new event loop and RabbitMQ connection per task. You can\n  use Celery 4, but it's hard to recommend it. Celery 5 may fix this.)\n\nDependencies\n------------\n\nYou'll need Python 3.6+ (lower hasn't been tested) and a RabbitMQ server.\n\nIf you have Docker, here's how to start a development server::\n\n    ssl/prepare-certs.sh  # Create SSL certificates used in tests\n    docker run --rm -it \\\n         -p 5671:5671 \\\n         -p 5672:5672 \\\n         -p 15672:15672 \\\n         -v \"/$(pwd)\"/ssl:/ssl \\\n         -e RABBITMQ_SSL_CACERTFILE=/ssl/ca.cert \\\n         -e RABBITMQ_SSL_CERTFILE=/ssl/server.cert \\\n         -e RABBITMQ_SSL_KEYFILE=/ssl/server.key \\\n         -e RABBITMQ_SSL_VERIFY=verify_peer \\\n         -e RABBITMQ_SSL_FAIL_IF_NO_PEER_CERT=true \\\n         rabbitmq:3.7.8-management-alpine\n\nYou can access the RabbitMQ management interface at http://localhost:15672.\n\nContributing\n------------\n\nTo add features and fix bugs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFirst, start a development RabbitMQ server::\n\n    ssl/prepare-certs.sh  # Create SSL certificates used in tests\n    docker run --rm -it \\\n         -p 5671:5671 \\\n         -p 5672:5672 \\\n         -p 15672:15672 \\\n         -v \"/$(pwd)\"/ssl:/ssl \\\n         -e RABBITMQ_SSL_CACERTFILE=/ssl/ca.cert \\\n         -e RABBITMQ_SSL_CERTFILE=/ssl/server.cert \\\n         -e RABBITMQ_SSL_KEYFILE=/ssl/server.key \\\n         -e RABBITMQ_SSL_VERIFY=verify_peer \\\n         -e RABBITMQ_SSL_FAIL_IF_NO_PEER_CERT=true \\\n         rabbitmq:3.7.8-management-alpine\n\nNow take on the development cycle:\n\n#. ``python ./setup.py pytest`` # to ensure tests pass.\n#. Write new tests in ``tests/`` and make sure they fail.\n#. Write new code in ``channels_rabbitmq/`` to make the tests pass.\n#. Submit a pull request.\n\nTo deploy\n~~~~~~~~~\n\nUse `semver <https://semver.org/>`_.\n\n#. Change ``__version__`` in ``channels_rabbitmq/__init__.py``.\n#. Add to ``CHANGELOG.rst``.\n#. ``git commit channels_rabbitmq/__init__.py CHANGELOG.rst -m 'vX.X.X'`` but don't push.\n#. ``git tag vX.X.X``\n#. ``git push --tags && git push``\n\nTravisCI will push to PyPi.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/CJWorkbench/channels_rabbitmq/", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "channels-rabbitmq", "package_url": "https://pypi.org/project/channels-rabbitmq/", "platform": "", "project_url": "https://pypi.org/project/channels-rabbitmq/", "project_urls": {"Homepage": "http://github.com/CJWorkbench/channels_rabbitmq/"}, "release_url": "https://pypi.org/project/channels-rabbitmq/1.2.1/", "requires_dist": null, "requires_python": "", "summary": "RabbitMQ-backed ASGI channel layer implementation", "version": "1.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A Django Channels channel layer that uses RabbitMQ as its backing store.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p><tt>pip install channels_rabbitmq</tt></p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Then set up the channel layer in your Django settings file like so:</p>\n<pre>CHANNEL_LAYERS = {\n    \"default\": {\n        \"BACKEND\": \"channels_rabbitmq.core.RabbitmqChannelLayer\",\n        \"CONFIG\": {\n            \"host\": \"amqp://guest:guest@127.0.0.1/asgi\",\n            # \"ssl_context\": ... (optional)\n        },\n    },\n}\n</pre>\n<p>Possible options for <tt>CONFIG</tt> are listed below.</p>\n<div id=\"host\">\n<h3><tt>host</tt></h3>\n<p>URL of the server to connect to, adhering to <a href=\"https://www.rabbitmq.com/uri-spec.html\" rel=\"nofollow\">RabbitMQ spec</a>. To connect to a RabbitMQ cluster,\nuse a DNS server to resolve a hostname to multiple IP addresses.\nchannels_rabbitmq will automatically reconnect if at least one of them is\nreachable in case of a disconnection.</p>\n</div>\n<div id=\"expiry\">\n<h3><tt>expiry</tt></h3>\n<p>Minimum number of seconds a message should wait in a RabbitMQ queue, before it\nmay be silently dropped.</p>\n<p>Defaults to <tt>60</tt>. You generally shouldn\u2019t need to change this, but you may\nwant to turn it down if you have peaky traffic you wish to drop, or up if you\nhave peaky traffic you want to backlog until you get to it.</p>\n</div>\n<div id=\"local-capacity\">\n<h3><tt>local_capacity</tt></h3>\n<p>Number of messages queued in memory. Defaults to <tt>100</tt>. (A message sent to\na group with two channels counts as two messages.) When <tt>local_capacity</tt>\nmessages are queued, the message backlog will grow on RabbitMQ.</p>\n</div>\n<div id=\"local-expiry\">\n<h3><tt>local_expiry</tt></h3>\n<p>Minimum number of seconds a message received from RabbitMQ must be held in\nmemory waiting for <tt>receive()</tt>, before it may be dropped. Defaults to\n<tt>expiry</tt>.</p>\n<p>A warning will be logged when a message expires locally. The warning can\nindicate that a channel has more messages than it can handle; or that\nmessages are being sent to a channel that does not exist. (Perhaps a missing\nchannel was implied by <tt>group_add()</tt>, and a matching <tt>group_discard()</tt>\nwas never called.)</p>\n</div>\n<div id=\"remote-capacity\">\n<h3><tt>remote_capacity</tt></h3>\n<p>Number of messages stored on RabbitMQ for each client. Defaults to <tt>100</tt>.\n(A message sent to a group with three channels on two distinct clients counts\nas two messages.) When <tt>remote_capacity</tt> messages are queued in RabbitMQ,\nthe channel will refuse new messages. Calls from any client to <tt>send()</tt> or\n<tt>group_send()</tt> to the at-capacity client will raise <tt>ChannelFull</tt>.</p>\n</div>\n<div id=\"prefetch-count\">\n<h3><tt>prefetch_count</tt></h3>\n<p>Number of messages to read from RabbitMQ at a time. Defaults to <tt>10</tt>. This\nmakes <tt>local_capacity</tt> a bit of a \u201cloose\u201d setting: if messages are queued\nrapidly enough, the client may request <tt>prefetch_count</tt> messages even if it\nalready has <tt>local_capacity - 1</tt> messages in memory. Higher settings\naccelerate throughput a little bit; lower settings help adhere to\n<tt>local_capacity</tt> more rigorously.</p>\n</div>\n<div id=\"ssl-context\">\n<h3><tt>ssl_context</tt></h3>\n<p>An <a href=\"https://docs.python.org/3/library/ssl.html#ssl-contexts\" rel=\"nofollow\">SSL context</a>. Changes the\ndefault <tt>host</tt> port to 5671 (instead of 5672).</p>\n<p>For instance, to connect to an TLS RabbitMQ service that will verify your\nclient:</p>\n<pre>import ssl\nssl_context = ssl.create_default_context(\n    cafile=str(Path(__file__).parent.parent / 'ssl' / 'server.cert'),\n)\nssl_context.load_cert_chain(\n    certfile=str(Path(__file__).parent.parent / 'ssl' / 'client.certchain'),\n    keyfile=str(Path(__file__).parent.parent / 'ssl' / 'client.key'),\n)\nCHANNEL_LAYERS['default']['CONFIG']['ssl_context'] = ssl_context\n</pre>\n<p>By default, there is no SSL context; all messages (and passwords) are\nare transmitted in cleartext.</p>\n</div>\n<div id=\"groups-exchange\">\n<h3><tt>groups_exchange</tt></h3>\n<p>Global direct exchange name used by channels to exchange group messages.\nDefaults to <tt>\"groups\"</tt>. See also <a href=\"#design-decisions\" rel=\"nofollow\">Design decisions</a>.</p>\n</div>\n</div>\n<div id=\"design-decisions\">\n<h2>Design decisions</h2>\n<p>To scale enormously, this layer only creates one RabbitMQ queue per instance.\nThat means one web server gets one RabbitMQ queue, no matter how many\nwebsocket connections are open. For each message being sent, the client-side\nlayer determines the RabbitMQ queue name and uses it as the routing key.</p>\n<p>Groups are implemented using a single, global RabbitMQ direct exchange called\n\u201cgroups\u201d by default. To send a message to a group, the layer sends the message to the\n\u201cgroups\u201d exchange with the group name as the routing key. The client binds and\nunbinds during <tt>group_add()</tt> and <tt>group_remove()</tt> to ensure messages for\nany of its groups will reach it. See also the <a href=\"#groups-exchange\" rel=\"nofollow\">groups_exchange</a> option.</p>\n<p>RabbitMQ queues are <tt>exclusive</tt>: when a client disconnects (through close or\ncrash), RabbitMQ will delete the queue and unbind the groups.</p>\n<p>Django Channels\u2019 specification does not account for \u201cconnecting\u201d and\n\u201cdisconnecting\u201d, so this layer is always connected. It will reconnect forever\nin the event loop\u2019s background, logging warnings each time the connect fails.</p>\n<p>Once a connection has been created, it pollutes the event loop so that\n<tt>async_to_sync()</tt> will destroy the connection if it was created within\n<tt>async_to_sync()</tt>. Each connection starts a background async loop that pulls\nmessages from RabbitMQ and routes them to receiver queues; each <tt>receive()</tt>\nqueries receiver queues. Empty queues are deleted. TODO delete queues that\nonly contain expired messages, so we don\u2019t leak when sending to dead channels.</p>\n<div id=\"deviations-from-the-channel-layer-specification\">\n<h3>Deviations from the Channel Layer Specification</h3>\n<p>The <a href=\"https://channels.readthedocs.io/en/latest/channel_layer_spec.html\" rel=\"nofollow\">Channel Layer Specification</a> bends to\nRedis-related restrictions. RabbitMQ cannot emulate Redis. Here are the\ndifferences:</p>\n<ul>\n<li><p><strong>No ``flush`` extension</strong>: To flush all state, simply disconnect all clients.\n(RabbitMQ won\u2019t allow one client to delete another client\u2019s data structures.)</p>\n</li>\n<li><p><strong>No ``group_expiry`` option</strong>: The <a href=\"https://channels.readthedocs.io/en/latest/channel_layer_spec.html#persistence\" rel=\"nofollow\">group_expiry option</a>\nrecovers when a <tt>group_add()</tt> has no matching <tt>group_discard()</tt>. But the\n\u201cgroup membership expiry\u201d logic has a fatal flaw: it disconnects legitimate\nmembers. <tt>channels_rabbitmq</tt> addresses each root problem instead:</p>\n<ul>\n<li>Web-server crash: RabbitMQ wipes all state related to a web server when\nthe web server disconnects. There\u2019s no problem here for <tt>group_expiry</tt>\nto solve.</li>\n<li>Programming errors: You may err and call <tt>group_add()</tt> without\neventually calling <tt>group_discard()</tt>. Redis can\u2019t detect this\nprogramming error (because it can\u2019t detect web-server crashes). RabbitMQ\ncan. The <tt>local_expiry</tt> option keeps your site running after you\nerroneously miss a <tt>group_discard()</tt>. The channel layer warns when\ndiscarding expired messages. Monitor your server logs to detect your\nerrors.</li>\n</ul>\n</li>\n<li><p><strong>No \u201cnormal channels\u201d</strong>: <a href=\"https://channels.readthedocs.io/en/latest/channel_layer_spec.html#channels\" rel=\"nofollow\">Normal channels</a>\nare job queues. In most projects, \u201cnormal channel\u201d readers are worker\nprocesses, ideally divorced from Websockets and Django.</p>\n<p>You are welcome to submit a <tt>channels_rabbitmq</tt> pull request to support this\nunder-specified aspect of the Channel Layer Specification. But why reinvent\nthe wheel? There are thousands of job-queue implementations out there already.\nDjango Channels is a bad fit, because it is tuned for Websockets.</p>\n<p>If you want an async, RabbitMQ-based job queue, investigate <a href=\"https://github.com/mosquito/aiormq\" rel=\"nofollow\">aiormq</a> and <a href=\"https://github.com/polyconseil/aioamqp\" rel=\"nofollow\">aioamqp</a>. You can even send your jobs\nto a separate RabbitMQ server or virtual host.</p>\n<p>Currently, this project\u2019s strategy is to wait for <a href=\"https://github.com/celery/celery/milestone/7\" rel=\"nofollow\">Celery 5.0.0</a>, evaluate it, and then\nrecommend an alternative to \u201cnormal channels.\u201d (With Celery 4, it\u2019s\ninefficient for workers to send messages to the Django Channels layer, because\nthey need to launch a new event loop and RabbitMQ connection per task. You can\nuse Celery 4, but it\u2019s hard to recommend it. Celery 5 may fix this.)</p>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"dependencies\">\n<h2>Dependencies</h2>\n<p>You\u2019ll need Python 3.6+ (lower hasn\u2019t been tested) and a RabbitMQ server.</p>\n<p>If you have Docker, here\u2019s how to start a development server:</p>\n<pre>ssl/prepare-certs.sh  # Create SSL certificates used in tests\ndocker run --rm -it \\\n     -p 5671:5671 \\\n     -p 5672:5672 \\\n     -p 15672:15672 \\\n     -v \"/$(pwd)\"/ssl:/ssl \\\n     -e RABBITMQ_SSL_CACERTFILE=/ssl/ca.cert \\\n     -e RABBITMQ_SSL_CERTFILE=/ssl/server.cert \\\n     -e RABBITMQ_SSL_KEYFILE=/ssl/server.key \\\n     -e RABBITMQ_SSL_VERIFY=verify_peer \\\n     -e RABBITMQ_SSL_FAIL_IF_NO_PEER_CERT=true \\\n     rabbitmq:3.7.8-management-alpine\n</pre>\n<p>You can access the RabbitMQ management interface at <a href=\"http://localhost:15672\" rel=\"nofollow\">http://localhost:15672</a>.</p>\n</div>\n<div id=\"contributing\">\n<h2>Contributing</h2>\n<div id=\"to-add-features-and-fix-bugs\">\n<h3>To add features and fix bugs</h3>\n<p>First, start a development RabbitMQ server:</p>\n<pre>ssl/prepare-certs.sh  # Create SSL certificates used in tests\ndocker run --rm -it \\\n     -p 5671:5671 \\\n     -p 5672:5672 \\\n     -p 15672:15672 \\\n     -v \"/$(pwd)\"/ssl:/ssl \\\n     -e RABBITMQ_SSL_CACERTFILE=/ssl/ca.cert \\\n     -e RABBITMQ_SSL_CERTFILE=/ssl/server.cert \\\n     -e RABBITMQ_SSL_KEYFILE=/ssl/server.key \\\n     -e RABBITMQ_SSL_VERIFY=verify_peer \\\n     -e RABBITMQ_SSL_FAIL_IF_NO_PEER_CERT=true \\\n     rabbitmq:3.7.8-management-alpine\n</pre>\n<p>Now take on the development cycle:</p>\n<ol>\n<li><tt>python ./setup.py pytest</tt> # to ensure tests pass.</li>\n<li>Write new tests in <tt>tests/</tt> and make sure they fail.</li>\n<li>Write new code in <tt>channels_rabbitmq/</tt> to make the tests pass.</li>\n<li>Submit a pull request.</li>\n</ol>\n</div>\n<div id=\"to-deploy\">\n<h3>To deploy</h3>\n<p>Use <a href=\"https://semver.org/\" rel=\"nofollow\">semver</a>.</p>\n<ol>\n<li>Change <tt>__version__</tt> in <tt>channels_rabbitmq/__init__.py</tt>.</li>\n<li>Add to <tt>CHANGELOG.rst</tt>.</li>\n<li><tt>git commit channels_rabbitmq/__init__.py CHANGELOG.rst <span class=\"pre\">-m</span> 'vX.X.X'</tt> but don\u2019t push.</li>\n<li><tt>git tag vX.X.X</tt></li>\n<li><tt>git push <span class=\"pre\">--tags</span> &amp;&amp; git push</tt></li>\n</ol>\n<p>TravisCI will push to PyPi.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6782504, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "cdbb0fea2da438c0b907e05e9415b81b", "sha256": "fed0596637c588e90f7902ccae69ac4d5e6b2fbe7f2d6e03a909b67a01627810"}, "downloads": -1, "filename": "channels_rabbitmq-0.0.1.tar.gz", "has_sig": false, "md5_digest": "cdbb0fea2da438c0b907e05e9415b81b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11516, "upload_time": "2018-10-23T19:02:26", "upload_time_iso_8601": "2018-10-23T19:02:26.268758Z", "url": "https://files.pythonhosted.org/packages/9e/07/502eb02015bb8f27ce526981c8b62e8ffab0b7331f1894cd4e7d1973ef58/channels_rabbitmq-0.0.1.tar.gz", "yanked": false}], "0.0.10": [{"comment_text": "", "digests": {"md5": "2cd7021cbc8ee92d0ba3e706368e0f10", "sha256": "3e1e66ddcead244b764fcc2ce5f0709be643767cad1d0edb4948e09a6ddae4f1"}, "downloads": -1, "filename": "channels_rabbitmq-0.0.10.tar.gz", "has_sig": false, "md5_digest": "2cd7021cbc8ee92d0ba3e706368e0f10", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14508, "upload_time": "2019-02-06T15:15:08", "upload_time_iso_8601": "2019-02-06T15:15:08.262668Z", "url": "https://files.pythonhosted.org/packages/fd/8f/8ef715965ba5386ba7833804f14ad0ed47f8d0662305b132f1a51dbfd882/channels_rabbitmq-0.0.10.tar.gz", "yanked": false}], "0.0.11": [{"comment_text": "", "digests": {"md5": "18e2dc7700cb77af250703383719face", "sha256": "4069914ebaeb77241db0a1ccfbf80affc543aafae4a5fb5dbd2e81d2851fec45"}, "downloads": -1, "filename": "channels_rabbitmq-0.0.11.tar.gz", "has_sig": false, "md5_digest": "18e2dc7700cb77af250703383719face", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14509, "upload_time": "2019-02-21T21:40:35", "upload_time_iso_8601": "2019-02-21T21:40:35.419954Z", "url": "https://files.pythonhosted.org/packages/4b/9c/d2e0e8b55d5af2a62f4a0f4bc7c7d5682950f30dc29b7427ead226bd7480/channels_rabbitmq-0.0.11.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "538f4b7b334673b554afa983572a1674", "sha256": "c0e153892504a7101dd723c0f576024ac767f21adebc60bab2ddb4935baa1997"}, "downloads": -1, "filename": "channels_rabbitmq-0.0.2.tar.gz", "has_sig": false, "md5_digest": "538f4b7b334673b554afa983572a1674", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11585, "upload_time": "2018-10-23T21:46:31", "upload_time_iso_8601": "2018-10-23T21:46:31.978410Z", "url": "https://files.pythonhosted.org/packages/3b/70/ecc8ca8a5bf1ac071c7992c7d4ad97706462fbbd8812a6738f91066eb607/channels_rabbitmq-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "372d16d4d27abaf421eb330230480b69", "sha256": "902a5c344b24ab1dd41ecf00c388ad02b561d348d87361e94b64a2b0dadb6880"}, "downloads": -1, "filename": "channels_rabbitmq-0.0.3.tar.gz", "has_sig": false, "md5_digest": "372d16d4d27abaf421eb330230480b69", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12297, "upload_time": "2018-10-24T16:55:23", "upload_time_iso_8601": "2018-10-24T16:55:23.030331Z", "url": "https://files.pythonhosted.org/packages/21/44/43a9e9dea80d6dbce82c51108ec64754f1eace632bcab6284ec1fca7f9e0/channels_rabbitmq-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "e095a0c75bda0c204c0f05cdf18360e2", "sha256": "1407d1a1310daf5cdd037f445d08c30e08d4b494e81db9455bbac149c06dd828"}, "downloads": -1, "filename": "channels_rabbitmq-0.0.4.tar.gz", "has_sig": false, "md5_digest": "e095a0c75bda0c204c0f05cdf18360e2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12738, "upload_time": "2019-01-31T22:43:18", "upload_time_iso_8601": "2019-01-31T22:43:18.536727Z", "url": "https://files.pythonhosted.org/packages/c0/c5/3b77556fe65c27f54bc001046f438fe31bfee0597a9ee3509cb4804c8d54/channels_rabbitmq-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "759fbbe44f281ff25eeae0fba055ab70", "sha256": "467b6e26e4ea60613a4bccb383ac7edad3f6860123f44a53e0a9fc87cc9686b2"}, "downloads": -1, "filename": "channels_rabbitmq-0.0.5.tar.gz", "has_sig": false, "md5_digest": "759fbbe44f281ff25eeae0fba055ab70", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12738, "upload_time": "2019-02-01T19:19:56", "upload_time_iso_8601": "2019-02-01T19:19:56.374552Z", "url": "https://files.pythonhosted.org/packages/37/19/bd92319e2f20ae42b7c346b1cf9471b53939499c064ee0a282472f7fccce/channels_rabbitmq-0.0.5.tar.gz", "yanked": false}], "0.0.9": [{"comment_text": "", "digests": {"md5": "a923e7ea990bf3add454d1dd2faf87b7", "sha256": "8edacf451c5b24a2400a1a6e5b7c9d3cb80b8f9bd054bdaf839856a2b32b9b92"}, "downloads": -1, "filename": "channels_rabbitmq-0.0.9.tar.gz", "has_sig": false, "md5_digest": "a923e7ea990bf3add454d1dd2faf87b7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14465, "upload_time": "2019-02-05T22:07:30", "upload_time_iso_8601": "2019-02-05T22:07:30.177414Z", "url": "https://files.pythonhosted.org/packages/98/95/8cedee784d20b2b48cae145abcf284340f5b6aebb724cfc195f2a4d9ce1d/channels_rabbitmq-0.0.9.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "5a75114d091d25acdda3e92c39c47795", "sha256": "18b62d1ef830a7021bf24acdbfafaa7a8acfcaad16d0ed82213d3fa22e08929f"}, "downloads": -1, "filename": "channels_rabbitmq-1.0.0.tar.gz", "has_sig": false, "md5_digest": "5a75114d091d25acdda3e92c39c47795", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14541, "upload_time": "2019-04-24T15:37:30", "upload_time_iso_8601": "2019-04-24T15:37:30.371976Z", "url": "https://files.pythonhosted.org/packages/7f/78/4ebb1027d9845814e7d00c6311e46bdba95d0fcf8c9026284ec42d0d9762/channels_rabbitmq-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "8d2c9c972f9d7e60dc0307d56a15004c", "sha256": "ced2786bb65bc2c5ff13f1c05d6991a8520334e7a79b95d81e21b14e21e8189c"}, "downloads": -1, "filename": "channels_rabbitmq-1.0.1.tar.gz", "has_sig": false, "md5_digest": "8d2c9c972f9d7e60dc0307d56a15004c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14606, "upload_time": "2019-05-06T15:46:29", "upload_time_iso_8601": "2019-05-06T15:46:29.954744Z", "url": "https://files.pythonhosted.org/packages/78/07/e969ac4ab432312f592d082a77ad62851b6327402820566d5109925416a4/channels_rabbitmq-1.0.1.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "ebe35798840686c159631bfd24dee268", "sha256": "eef8a89fb7caf1c0ebf81e0d0d63e5655c396f28511d511791f953957bb1114f"}, "downloads": -1, "filename": "channels_rabbitmq-1.1.0.tar.gz", "has_sig": false, "md5_digest": "ebe35798840686c159631bfd24dee268", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15671, "upload_time": "2019-05-09T21:58:36", "upload_time_iso_8601": "2019-05-09T21:58:36.200433Z", "url": "https://files.pythonhosted.org/packages/3f/d6/4daeac98d4f29568a973dd8db9976a349dee518b18a56e5d47e6d8d1e82c/channels_rabbitmq-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "fc731f744ae1dac9237a71b2200ba760", "sha256": "a967b77dc71435634e15ee8b65ba4dc0ac241fb9016bf85b614b85c8182b42b2"}, "downloads": -1, "filename": "channels_rabbitmq-1.1.1.tar.gz", "has_sig": false, "md5_digest": "fc731f744ae1dac9237a71b2200ba760", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16074, "upload_time": "2019-05-23T18:24:22", "upload_time_iso_8601": "2019-05-23T18:24:22.893668Z", "url": "https://files.pythonhosted.org/packages/cb/fc/80dde1595ac89eb7ced85fdce593ce97e5c32b5a3a96e11dadc9e8bb76bd/channels_rabbitmq-1.1.1.tar.gz", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "b64c489fbc97753d8f799d6f8d6035a5", "sha256": "b1dcc8751e12246c66fe4480f62dcd24f84f0010e5c5e03d093215414b4ba80f"}, "downloads": -1, "filename": "channels_rabbitmq-1.1.2.tar.gz", "has_sig": false, "md5_digest": "b64c489fbc97753d8f799d6f8d6035a5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16204, "upload_time": "2019-06-10T21:18:24", "upload_time_iso_8601": "2019-06-10T21:18:24.890700Z", "url": "https://files.pythonhosted.org/packages/f5/ed/2d7941410d043e3465bc3ec9abaa44e5b5537cc03eda69d7d05dac8a8b1b/channels_rabbitmq-1.1.2.tar.gz", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "eba7b822bd16769726ada2c2a42f3606", "sha256": "f1f6801497a70a1a857d8f5cc1c84fbb56be81fc26cfe6ec069c87e82b17e0de"}, "downloads": -1, "filename": "channels_rabbitmq-1.1.3.tar.gz", "has_sig": false, "md5_digest": "eba7b822bd16769726ada2c2a42f3606", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17954, "upload_time": "2019-06-16T19:26:55", "upload_time_iso_8601": "2019-06-16T19:26:55.248716Z", "url": "https://files.pythonhosted.org/packages/23/05/9ff094ce3aba57c0e5ed78ae53024588b7ef07caf6338f292444dfff3389/channels_rabbitmq-1.1.3.tar.gz", "yanked": false}], "1.1.4": [{"comment_text": "", "digests": {"md5": "81dae3a17cde2f5f332ae500756ca9e2", "sha256": "d4c10a4ed7c3c4cf98fe31f49157c943a86aef52d0f405d22d3f54bf9b67dc82"}, "downloads": -1, "filename": "channels_rabbitmq-1.1.4.tar.gz", "has_sig": false, "md5_digest": "81dae3a17cde2f5f332ae500756ca9e2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18049, "upload_time": "2019-07-09T16:25:40", "upload_time_iso_8601": "2019-07-09T16:25:40.671057Z", "url": "https://files.pythonhosted.org/packages/a0/ad/9596ac9c839c167c8b30143099e087e104c2dc8dba9fe534ae6dbe5a649e/channels_rabbitmq-1.1.4.tar.gz", "yanked": false}], "1.1.5": [{"comment_text": "", "digests": {"md5": "c729ab0e7cd965332c46b94f4310a28e", "sha256": "f9e16f2d8c6ffccb6184d4db13181c3bcbbe8cec0e126d63e4b65bcf4a2d1fbe"}, "downloads": -1, "filename": "channels_rabbitmq-1.1.5.tar.gz", "has_sig": false, "md5_digest": "c729ab0e7cd965332c46b94f4310a28e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18044, "upload_time": "2019-08-22T18:51:35", "upload_time_iso_8601": "2019-08-22T18:51:35.914439Z", "url": "https://files.pythonhosted.org/packages/43/18/e6bb3eed3b8c44be823b38cb21a1ca3292c4dbab0b5e99c50807eb3c47aa/channels_rabbitmq-1.1.5.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "e306d178982710bd60062c9f2642fadd", "sha256": "018026891ce96ecbc8ee7e7e8ab5457f59933345b92db50857efc3071c071126"}, "downloads": -1, "filename": "channels_rabbitmq-1.2.0.tar.gz", "has_sig": false, "md5_digest": "e306d178982710bd60062c9f2642fadd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20386, "upload_time": "2019-12-30T22:04:06", "upload_time_iso_8601": "2019-12-30T22:04:06.554891Z", "url": "https://files.pythonhosted.org/packages/65/9e/2229a397a0881a15ba971b83cc94af5355b9d95858c30e7430c3972007c1/channels_rabbitmq-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "63edf968a9afbcfad6604785ad83785c", "sha256": "17b3410b7c20c0ec85a2291a75f9c263ae88c3f89825711b2284df87208aaab3"}, "downloads": -1, "filename": "channels_rabbitmq-1.2.1.tar.gz", "has_sig": false, "md5_digest": "63edf968a9afbcfad6604785ad83785c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19920, "upload_time": "2020-03-10T04:12:52", "upload_time_iso_8601": "2020-03-10T04:12:52.058843Z", "url": "https://files.pythonhosted.org/packages/4f/81/efb872be0847ace0262d4c7eaab46519e50f1507f55b3d709890d199c6c2/channels_rabbitmq-1.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "63edf968a9afbcfad6604785ad83785c", "sha256": "17b3410b7c20c0ec85a2291a75f9c263ae88c3f89825711b2284df87208aaab3"}, "downloads": -1, "filename": "channels_rabbitmq-1.2.1.tar.gz", "has_sig": false, "md5_digest": "63edf968a9afbcfad6604785ad83785c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19920, "upload_time": "2020-03-10T04:12:52", "upload_time_iso_8601": "2020-03-10T04:12:52.058843Z", "url": "https://files.pythonhosted.org/packages/4f/81/efb872be0847ace0262d4c7eaab46519e50f1507f55b3d709890d199c6c2/channels_rabbitmq-1.2.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:34:29 2020"}