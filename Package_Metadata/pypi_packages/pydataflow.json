{"info": {"author": "k.r. goger", "author_email": "k.r.goger+pydataflow@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Topic :: Utilities"], "description": "\n# pydataflow\n\na simple dataflow / workflow engine\n\n# dependencies\n\nNone. Pure Python.\n\n# code\n\nthe flow definition is based on \"cells\".\nany assignment to `cell.val` will trigger dataflow in depending cells.\n\nrefer also to the other samples on github\n\n\n    from dataflow import CellDataFlow, print_error, clear_error\n\n\n    cf = CellDataFlow()\n\n    c1 = cf.create_cell() # or sorthand -> c1 = cf()\n\n    #lambda function is called with cell,cell.val\n    c2 = cf(watching=c1, func=lambda c,v: v-1 )\n    c3 = cf(watching=[c1], func=lambda c,v: v*2 )\n\n    # since watching to 2 cells its not predictable what c,v is used in the call\n    # could be any of the watches, c2 or c3\n    c4 = cf(watching=[c2,c3], func= lambda c,v: c2.val+c3.val )\n\n    c5 = cf(watching=[c4], func=lambda c,v : c2.val+c3.val+c4.val )\n\n    # use find to add all depending watches automatically\n    # print output will show that the data goes directly forward\n    # instead of arriving in one of the next round(s)\n    c6 = cf(watching=cf.find([c2,c5]), func=lambda c,v : c2.val + c5.val )\n\n    def cust_func(c,v):\n        # print(f\"do something usefull because of {v}\")\n        return v*3.14\n\n    c7 = cf(watching=c6, func=cust_func )\n    # shorthand for cf.find\n    c8 = cf(watching=cf(c6), func=lambda c,v : v*3.14 )\n\n    def sumup(c,v):\n        total = sum(map( lambda x : x.val, c.watching))\n        return total\n\n    c9 = cf(watching=cf(c8), func=sumup )\n\n    # no func provided, just get the data from the cell here\n    # remove print_error to see difference in output\n    c10 = cf(id=\"c10\", watching=c6, func=lambda c,v : 1/0 , err=print_error )\n\n    # err function is called when func fails\n    # called as errfunc( cell, val, ex )\n    # use clear_error for clean up\n    c11 = cf(id=\"c11\", watching=c6, err=print_error )\n\n\n    def strcats(c,v):\n        # watching is a set, so the result combination is unpredictable\n        return \" \".join(map( lambda x : x.val , c.watching))\n\n    cs1 = cf()\n    cs2 = cf()\n    cs3 = cf(watching=[cs1,cs2], func=strcats )\n\n    cs4 = cf(watching=[cs1,cs2], func=lambda c,v : (cs1.val + cs2.val).upper() )\n\n    # add some custom data in case val is not sufficient\n    cs4.meta[\"extra_data\"] = \"meta dict can be used for own purposes\"\n\n    # this will later removed from the flow\n    cdrop = cf(watching=c6 )\n\n    # assignment only after flow is defined\n    # assignment triggers later processing\n    c1.val = 3\n    cs1.val =\"hi\"\n    cs2.val =\"ya\"\n\n\n    def val(x):\n        if x.error:\n            return \"#ERR#\"\n        try:\n            return round(x.val,2)\n        except:\n            return x.val\n\n    for cell in cf.cells:\n        print(val(cell),end=\"\\t\")\n    print()\n\n    # propagate pushes data to the next depending cells\n    # and stops after that\n    # call propagate serveral times to push data completly\n\n    # since there is no circle defined its possible to loop\n    while cf.propagate():\n        for cell in cf.cells:\n            print(val(cell),end=\"\\t\")\n        print()\n\n\n    print(\"drop cell\")\n    cf.drop_cell( cdrop ) # remove from the flow definition\n\n\n    print(\"recalc with c1=4, change greeting, cdrop will keep old val!\")\n    c1.val = 4\n    cs2.val = \"you\"\n\n    def printit():\n        for c in cf.cells:\n            print(val(c),end=\"\\t\")\n        print(cdrop.val)\n\n    # use the loop which calls propagate \n    # max calls is number of cells involed (runs parameter set to default:-1)\n    # call func after every propagate\n    cf.loop( func=printit, runs=-1 )\n\n    print(\"--- same val---\")\n    c1.val = 4\n\n    # nothing happens here since val is unchanged\n    runs = cf.loop(func=printit)\n    print( \"runs\", runs )\n\n    printit()\n\n    print(\"---done---\")\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kr-g/pydataflow", "keywords": "utility framework dataflow workflow automation", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pydataflow", "package_url": "https://pypi.org/project/pydataflow/", "platform": "", "project_url": "https://pypi.org/project/pydataflow/", "project_urls": {"Homepage": "https://github.com/kr-g/pydataflow"}, "release_url": "https://pypi.org/project/pydataflow/0.0.3/", "requires_dist": null, "requires_python": ">=3.6", "summary": "a simple dataflow / workflow engine", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>pydataflow</h1>\n<p>a simple dataflow / workflow engine</p>\n<h1>dependencies</h1>\n<p>None. Pure Python.</p>\n<h1>code</h1>\n<p>the flow definition is based on \"cells\".\nany assignment to <code>cell.val</code> will trigger dataflow in depending cells.</p>\n<p>refer also to the other samples on github</p>\n<pre><code>from dataflow import CellDataFlow, print_error, clear_error\n\n\ncf = CellDataFlow()\n\nc1 = cf.create_cell() # or sorthand -&gt; c1 = cf()\n\n#lambda function is called with cell,cell.val\nc2 = cf(watching=c1, func=lambda c,v: v-1 )\nc3 = cf(watching=[c1], func=lambda c,v: v*2 )\n\n# since watching to 2 cells its not predictable what c,v is used in the call\n# could be any of the watches, c2 or c3\nc4 = cf(watching=[c2,c3], func= lambda c,v: c2.val+c3.val )\n\nc5 = cf(watching=[c4], func=lambda c,v : c2.val+c3.val+c4.val )\n\n# use find to add all depending watches automatically\n# print output will show that the data goes directly forward\n# instead of arriving in one of the next round(s)\nc6 = cf(watching=cf.find([c2,c5]), func=lambda c,v : c2.val + c5.val )\n\ndef cust_func(c,v):\n    # print(f\"do something usefull because of {v}\")\n    return v*3.14\n\nc7 = cf(watching=c6, func=cust_func )\n# shorthand for cf.find\nc8 = cf(watching=cf(c6), func=lambda c,v : v*3.14 )\n\ndef sumup(c,v):\n    total = sum(map( lambda x : x.val, c.watching))\n    return total\n\nc9 = cf(watching=cf(c8), func=sumup )\n\n# no func provided, just get the data from the cell here\n# remove print_error to see difference in output\nc10 = cf(id=\"c10\", watching=c6, func=lambda c,v : 1/0 , err=print_error )\n\n# err function is called when func fails\n# called as errfunc( cell, val, ex )\n# use clear_error for clean up\nc11 = cf(id=\"c11\", watching=c6, err=print_error )\n\n\ndef strcats(c,v):\n    # watching is a set, so the result combination is unpredictable\n    return \" \".join(map( lambda x : x.val , c.watching))\n\ncs1 = cf()\ncs2 = cf()\ncs3 = cf(watching=[cs1,cs2], func=strcats )\n\ncs4 = cf(watching=[cs1,cs2], func=lambda c,v : (cs1.val + cs2.val).upper() )\n\n# add some custom data in case val is not sufficient\ncs4.meta[\"extra_data\"] = \"meta dict can be used for own purposes\"\n\n# this will later removed from the flow\ncdrop = cf(watching=c6 )\n\n# assignment only after flow is defined\n# assignment triggers later processing\nc1.val = 3\ncs1.val =\"hi\"\ncs2.val =\"ya\"\n\n\ndef val(x):\n    if x.error:\n        return \"#ERR#\"\n    try:\n        return round(x.val,2)\n    except:\n        return x.val\n\nfor cell in cf.cells:\n    print(val(cell),end=\"\\t\")\nprint()\n\n# propagate pushes data to the next depending cells\n# and stops after that\n# call propagate serveral times to push data completly\n\n# since there is no circle defined its possible to loop\nwhile cf.propagate():\n    for cell in cf.cells:\n        print(val(cell),end=\"\\t\")\n    print()\n\n\nprint(\"drop cell\")\ncf.drop_cell( cdrop ) # remove from the flow definition\n\n\nprint(\"recalc with c1=4, change greeting, cdrop will keep old val!\")\nc1.val = 4\ncs2.val = \"you\"\n\ndef printit():\n    for c in cf.cells:\n        print(val(c),end=\"\\t\")\n    print(cdrop.val)\n\n# use the loop which calls propagate \n# max calls is number of cells involed (runs parameter set to default:-1)\n# call func after every propagate\ncf.loop( func=printit, runs=-1 )\n\nprint(\"--- same val---\")\nc1.val = 4\n\n# nothing happens here since val is unchanged\nruns = cf.loop(func=printit)\nprint( \"runs\", runs )\n\nprintit()\n\nprint(\"---done---\")\n</code></pre>\n\n          </div>"}, "last_serial": 6375236, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "539689bb909cd802f0b654960129454a", "sha256": "702e3c549c4290c7b0d67bc2f469c41963bb7dedb60c3980a63d40a212ddb406"}, "downloads": -1, "filename": "pydataflow-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "539689bb909cd802f0b654960129454a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 5104, "upload_time": "2019-12-29T13:12:44", "upload_time_iso_8601": "2019-12-29T13:12:44.570771Z", "url": "https://files.pythonhosted.org/packages/a7/23/a5031b860fd94266192b94ccf24eb051d407ae192389011f54030f290713/pydataflow-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e55271d9942e894b3c5eee98ca06cafe", "sha256": "a4d02e7d7a0af4717a17a9fd9a6e0f112e9a370664357cb780917429dcc99bca"}, "downloads": -1, "filename": "pydataflow-0.0.1.tar.gz", "has_sig": false, "md5_digest": "e55271d9942e894b3c5eee98ca06cafe", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4067, "upload_time": "2019-12-29T13:12:46", "upload_time_iso_8601": "2019-12-29T13:12:46.671366Z", "url": "https://files.pythonhosted.org/packages/47/ab/a5492d6469c26be645fc0dbc5cf8d1ae5482f02fd8556739e26362a1a5f0/pydataflow-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "4e54b710256b177ec5d5d18469d2312f", "sha256": "fa639951de2f3b19c06fecf52a306ea3a5832ba978b6616c2c7dbebdca2d2e18"}, "downloads": -1, "filename": "pydataflow-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "4e54b710256b177ec5d5d18469d2312f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 5342, "upload_time": "2019-12-29T17:54:04", "upload_time_iso_8601": "2019-12-29T17:54:04.781758Z", "url": "https://files.pythonhosted.org/packages/69/68/c18226b77e2f7a61ed987f38198c13abc590393f94060ed857c61e10d48b/pydataflow-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "87e54490e73d8550c9d5754592119dc2", "sha256": "f854ec6831f82c3fc243e6d2aae2a5b04c1bb80a01f3b4959cbb0669657110d8"}, "downloads": -1, "filename": "pydataflow-0.0.2.tar.gz", "has_sig": false, "md5_digest": "87e54490e73d8550c9d5754592119dc2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4273, "upload_time": "2019-12-29T17:54:07", "upload_time_iso_8601": "2019-12-29T17:54:07.588723Z", "url": "https://files.pythonhosted.org/packages/5e/69/c985c8e5a6fbbb0d1a88cd0eb3074be2bb2d83fb1b536c51f49009c28f6f/pydataflow-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "303524208b8af3dad6258c4c1039bb15", "sha256": "c9cdeab1a4bb1fab0a0ed4b5b147c017d462189e3ede5c780f3891e96cea472f"}, "downloads": -1, "filename": "pydataflow-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "303524208b8af3dad6258c4c1039bb15", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 5637, "upload_time": "2019-12-30T13:14:32", "upload_time_iso_8601": "2019-12-30T13:14:32.996954Z", "url": "https://files.pythonhosted.org/packages/34/5c/a4697f3ed000c81f480e5ec24171789d6499b11a567dc0823d31a0e447cb/pydataflow-0.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f6ae71a09c6f161ab7e24614959ce992", "sha256": "83630168fec6d6a77bf10c5581f639d8ca3ddb9299162114fcdf256f64eb72c2"}, "downloads": -1, "filename": "pydataflow-0.0.3.tar.gz", "has_sig": false, "md5_digest": "f6ae71a09c6f161ab7e24614959ce992", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4551, "upload_time": "2019-12-30T13:14:36", "upload_time_iso_8601": "2019-12-30T13:14:36.454798Z", "url": "https://files.pythonhosted.org/packages/04/df/db56590d5aec18747e0e92c574793106f2086a7a64cc426960e39269d441/pydataflow-0.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "303524208b8af3dad6258c4c1039bb15", "sha256": "c9cdeab1a4bb1fab0a0ed4b5b147c017d462189e3ede5c780f3891e96cea472f"}, "downloads": -1, "filename": "pydataflow-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "303524208b8af3dad6258c4c1039bb15", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 5637, "upload_time": "2019-12-30T13:14:32", "upload_time_iso_8601": "2019-12-30T13:14:32.996954Z", "url": "https://files.pythonhosted.org/packages/34/5c/a4697f3ed000c81f480e5ec24171789d6499b11a567dc0823d31a0e447cb/pydataflow-0.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f6ae71a09c6f161ab7e24614959ce992", "sha256": "83630168fec6d6a77bf10c5581f639d8ca3ddb9299162114fcdf256f64eb72c2"}, "downloads": -1, "filename": "pydataflow-0.0.3.tar.gz", "has_sig": false, "md5_digest": "f6ae71a09c6f161ab7e24614959ce992", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4551, "upload_time": "2019-12-30T13:14:36", "upload_time_iso_8601": "2019-12-30T13:14:36.454798Z", "url": "https://files.pythonhosted.org/packages/04/df/db56590d5aec18747e0e92c574793106f2086a7a64cc426960e39269d441/pydataflow-0.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:23 2020"}