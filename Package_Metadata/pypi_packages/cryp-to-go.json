{"info": {"author": "Matthias Huschle", "author_email": "matthiashuschle@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# cryp-to-go\n\n## What is it?\n\n- easy to use high-level crypto library for encrypted data storage/exchange\n- can use derived encryption keys from password + salt\n- can generate random keys and encrypt them by SSL public key (one or multiple)\n- can handle HMAC signatures of encrypted data\n- store multiple files in SQLite (ORM via peewee)\n- store all necessary information and data in a single SQLite file\n- store encrypted key/value pairs in SQLite (for usage in other python programs)\n- allow encryption/decryption of streams (for usage in python programs that handle large data)\n- CLI for file -> SQLite encryption\n- based on cryptography and pynacl libraries\n\n## Usage\n\n### CLI\n\nThe CLI provides one part of the functionailty: \nStore encrypted files in a SQLite database file. This is intended for quick file storage (key derivation) \nor file exchange over insecure channels (public/private key).\nMultiple files are stored inside the same database. They are identified by their relativ path \n(on encryption: relative to CWD), and all paths are stored encrypted. Asymmetric keys are\nnever stored, and symmetric encryption keys:\n- are stored asymmetrically encrypted.\n- and/or derived from a key derivation setup, that is stored in the database and \n requires the correct password.\n\nThe command `cryp-to-go` should be accessable from the command line. \n- The parameter `-s` sets the file name to use for the database. It defaults to `cryp-to-go-safe.sqlite`.\n- Always choose an action: encrypt files `--encrypt`/`-e`, decrypt files `--decrypt`/`-d`, list files `--list`/`-l`.\n- You can provide asymmetric keys:\n  - public key via `--pubkey` or `-p` as string or file path\n  - private key via `--private_key` or `-k` as path to a PEM file. A passphrase will be requested, when it is necessary.\n- Encryption keys can either be restored by public key, or by password for key derivation.\n If a new database file is created, the encryption keys will be created randomly, \n if a public key is provided, and the `--always_derive` derive flag is not set. Otherwise\n a key derivation setup will be created and a password requested.\n- The public key is used to encrypt symmetric encryption keys. \n It needs to be provided on `--encrypt` operations. It is possible to encrypt symmetric keys\n with multiple public keys, so multiple recepients get access.\n This is done via the `--append_key` parameter with any action.\n- The files to encrypt/decrypt are the trailing arguments. List operation does not use them.\n- Only files below CWD are allowed. This does not apply to the database file.\n\n#### example\n```bash\ncryp-to-go --encrypt -s /tmp/ctg_example.sqlite -p ~/.ssh/id_rsa.pub README.md setup.py\ncryp-to-go --list -s /tmp/ctg_example.sqlite -k ~/.ssh/id_rsa\ncd /tmp\ncryp-to-go --decrypt -s ctg_Example.sqlite -k ~/.ssh/id_rsa README.md\n```\n- The first line encrypts two files into a new container in `/tmp`. A public key is provided,\nso the owner of the private key can access the container. As the `--always_derive` flag is not set,\nthe encryptions keys are not derivable. This saves time, but means that the private key is the\nonly way to access the decrypted content.\n- The second line lists the files contained. The private key is necessary. \nIt's passphrase will be requested.\n- The third line switches to a different directory, as we don't want to overwrite files in the \noriginal folder. Decryption is written relative to CWD!\n- The last line executes the decryption of only one of the files. Again, the private key is required.\n\n### Core\n\nThe `core` module provides the lowest level functions and is intended for usage inside\nother python modules. Besides some auxiliary functions (`hexlify`, `unhexlify`), \nthere are two auxiliary classes that might become relevant:\n- `KeyDerivationSetup` creates and stores the settings for key derivation including salt.\n It is fully configurable and uses `nacl.pwhash.argon2i`, but you will likely either use\n `create_default` (always), or `create_minimal` (unit tests only!). The latter makes key \n derivation very cheap and is therefore not suitable for anything else than tests. It \n provides serialization methods to be jsonifiable, and creates a `CryptoHandler` with\n derived encyption keys with the `generate_keys` method.\n- `AsymKey` is a wrapper for asymmetric keys -- public or private -- that provides\n easy access to encryption and decryption of short data fragments \n (like symmetric encryption keys).\n\nThe central class is the `CryptoHandler`. It holds symmetric encryption and signature keys\nand provides methods to encrypt, decrypt, sign and verify. Also, the `create_random` factory\ncreates a new instance with random keys.\n- `encrypt_stream` and `decrypt_stream` are generators that iterate over a stream and\n yield the encrypted/decrypted content. They work in encryption chunks and use the \n `encrypt_chunk` and `decrypt_chunk` methods. They are at the core of most encryption\n operations and suitable to process large data.\n- `encrypt_snippet` and `decrypt_snippet` do the same, but without the streaming. \n They are intended for small pieces of data, like paths or dataset keys.\n- if the `CryptoHandler` has a signing key `key_sign` (usually set on creation via \n argument in factory methods), a signature can be calculated for the encrypted data.\n This happens on the fly, as the stream is encrypted, and only requires wrapping \n it in the `create_signature` context manager. It can be accessed afterwards as the\n `signature` property. The encryption method already provides signatures for all\n chunks, so a total signature ensures only correct order, which is in most cases\n not a necessary increase in security, but might help with data integrity. To verify\n encrypted data, just wrap the decryption in the `verify_signature` context manager.\n It ignores `None` signatures, so you don't need to worry about missing isgnatures.\n\n### Interface\n\nThe `interface` module contains interface(s) that provide core functionality in an \nextended context. Currently only `SQLiteFileInterface` exists. If another one is\nadded, a base class will be extracted.\n\nThe `SQLiteFileInterface` handles encryption/decryption in the context of a SQLite\ndatabase. It manages storage of the key derivation setup \n(`store_key_derivation_setup` with counterpart `load_crypto_handler`), \nof pubkey-encrypted keys (`store_keys_asymmetric` with `load_crypto_handler_async`), \nencrypted files (`store_files` and `restore_files`), and -- as additional \nfeature for potential usage in\nother projects -- encrypted key-value pairs (`store_values` with `restore_files` \n(shared with file storage)).\n\nIt is the backbone of the CLI.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/matthiashuschle/cryp-to-go", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "cryp-to-go", "package_url": "https://pypi.org/project/cryp-to-go/", "platform": "", "project_url": "https://pypi.org/project/cryp-to-go/", "project_urls": {"Homepage": "https://github.com/matthiashuschle/cryp-to-go"}, "release_url": "https://pypi.org/project/cryp-to-go/0.1.1/", "requires_dist": ["pynacl (>=1.3.0)", "cryptography (>=2.8)", "peewee"], "requires_python": ">=3.6", "summary": "easy to use high-level crypto library for encrypted data storage/exchange", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>cryp-to-go</h1>\n<h2>What is it?</h2>\n<ul>\n<li>easy to use high-level crypto library for encrypted data storage/exchange</li>\n<li>can use derived encryption keys from password + salt</li>\n<li>can generate random keys and encrypt them by SSL public key (one or multiple)</li>\n<li>can handle HMAC signatures of encrypted data</li>\n<li>store multiple files in SQLite (ORM via peewee)</li>\n<li>store all necessary information and data in a single SQLite file</li>\n<li>store encrypted key/value pairs in SQLite (for usage in other python programs)</li>\n<li>allow encryption/decryption of streams (for usage in python programs that handle large data)</li>\n<li>CLI for file -&gt; SQLite encryption</li>\n<li>based on cryptography and pynacl libraries</li>\n</ul>\n<h2>Usage</h2>\n<h3>CLI</h3>\n<p>The CLI provides one part of the functionailty:\nStore encrypted files in a SQLite database file. This is intended for quick file storage (key derivation)\nor file exchange over insecure channels (public/private key).\nMultiple files are stored inside the same database. They are identified by their relativ path\n(on encryption: relative to CWD), and all paths are stored encrypted. Asymmetric keys are\nnever stored, and symmetric encryption keys:</p>\n<ul>\n<li>are stored asymmetrically encrypted.</li>\n<li>and/or derived from a key derivation setup, that is stored in the database and\nrequires the correct password.</li>\n</ul>\n<p>The command <code>cryp-to-go</code> should be accessable from the command line.</p>\n<ul>\n<li>The parameter <code>-s</code> sets the file name to use for the database. It defaults to <code>cryp-to-go-safe.sqlite</code>.</li>\n<li>Always choose an action: encrypt files <code>--encrypt</code>/<code>-e</code>, decrypt files <code>--decrypt</code>/<code>-d</code>, list files <code>--list</code>/<code>-l</code>.</li>\n<li>You can provide asymmetric keys:\n<ul>\n<li>public key via <code>--pubkey</code> or <code>-p</code> as string or file path</li>\n<li>private key via <code>--private_key</code> or <code>-k</code> as path to a PEM file. A passphrase will be requested, when it is necessary.</li>\n</ul>\n</li>\n<li>Encryption keys can either be restored by public key, or by password for key derivation.\nIf a new database file is created, the encryption keys will be created randomly,\nif a public key is provided, and the <code>--always_derive</code> derive flag is not set. Otherwise\na key derivation setup will be created and a password requested.</li>\n<li>The public key is used to encrypt symmetric encryption keys.\nIt needs to be provided on <code>--encrypt</code> operations. It is possible to encrypt symmetric keys\nwith multiple public keys, so multiple recepients get access.\nThis is done via the <code>--append_key</code> parameter with any action.</li>\n<li>The files to encrypt/decrypt are the trailing arguments. List operation does not use them.</li>\n<li>Only files below CWD are allowed. This does not apply to the database file.</li>\n</ul>\n<h4>example</h4>\n<pre>cryp-to-go --encrypt -s /tmp/ctg_example.sqlite -p ~/.ssh/id_rsa.pub README.md setup.py\ncryp-to-go --list -s /tmp/ctg_example.sqlite -k ~/.ssh/id_rsa\n<span class=\"nb\">cd</span> /tmp\ncryp-to-go --decrypt -s ctg_Example.sqlite -k ~/.ssh/id_rsa README.md\n</pre>\n<ul>\n<li>The first line encrypts two files into a new container in <code>/tmp</code>. A public key is provided,\nso the owner of the private key can access the container. As the <code>--always_derive</code> flag is not set,\nthe encryptions keys are not derivable. This saves time, but means that the private key is the\nonly way to access the decrypted content.</li>\n<li>The second line lists the files contained. The private key is necessary.\nIt's passphrase will be requested.</li>\n<li>The third line switches to a different directory, as we don't want to overwrite files in the\noriginal folder. Decryption is written relative to CWD!</li>\n<li>The last line executes the decryption of only one of the files. Again, the private key is required.</li>\n</ul>\n<h3>Core</h3>\n<p>The <code>core</code> module provides the lowest level functions and is intended for usage inside\nother python modules. Besides some auxiliary functions (<code>hexlify</code>, <code>unhexlify</code>),\nthere are two auxiliary classes that might become relevant:</p>\n<ul>\n<li><code>KeyDerivationSetup</code> creates and stores the settings for key derivation including salt.\nIt is fully configurable and uses <code>nacl.pwhash.argon2i</code>, but you will likely either use\n<code>create_default</code> (always), or <code>create_minimal</code> (unit tests only!). The latter makes key\nderivation very cheap and is therefore not suitable for anything else than tests. It\nprovides serialization methods to be jsonifiable, and creates a <code>CryptoHandler</code> with\nderived encyption keys with the <code>generate_keys</code> method.</li>\n<li><code>AsymKey</code> is a wrapper for asymmetric keys -- public or private -- that provides\neasy access to encryption and decryption of short data fragments\n(like symmetric encryption keys).</li>\n</ul>\n<p>The central class is the <code>CryptoHandler</code>. It holds symmetric encryption and signature keys\nand provides methods to encrypt, decrypt, sign and verify. Also, the <code>create_random</code> factory\ncreates a new instance with random keys.</p>\n<ul>\n<li><code>encrypt_stream</code> and <code>decrypt_stream</code> are generators that iterate over a stream and\nyield the encrypted/decrypted content. They work in encryption chunks and use the\n<code>encrypt_chunk</code> and <code>decrypt_chunk</code> methods. They are at the core of most encryption\noperations and suitable to process large data.</li>\n<li><code>encrypt_snippet</code> and <code>decrypt_snippet</code> do the same, but without the streaming.\nThey are intended for small pieces of data, like paths or dataset keys.</li>\n<li>if the <code>CryptoHandler</code> has a signing key <code>key_sign</code> (usually set on creation via\nargument in factory methods), a signature can be calculated for the encrypted data.\nThis happens on the fly, as the stream is encrypted, and only requires wrapping\nit in the <code>create_signature</code> context manager. It can be accessed afterwards as the\n<code>signature</code> property. The encryption method already provides signatures for all\nchunks, so a total signature ensures only correct order, which is in most cases\nnot a necessary increase in security, but might help with data integrity. To verify\nencrypted data, just wrap the decryption in the <code>verify_signature</code> context manager.\nIt ignores <code>None</code> signatures, so you don't need to worry about missing isgnatures.</li>\n</ul>\n<h3>Interface</h3>\n<p>The <code>interface</code> module contains interface(s) that provide core functionality in an\nextended context. Currently only <code>SQLiteFileInterface</code> exists. If another one is\nadded, a base class will be extracted.</p>\n<p>The <code>SQLiteFileInterface</code> handles encryption/decryption in the context of a SQLite\ndatabase. It manages storage of the key derivation setup\n(<code>store_key_derivation_setup</code> with counterpart <code>load_crypto_handler</code>),\nof pubkey-encrypted keys (<code>store_keys_asymmetric</code> with <code>load_crypto_handler_async</code>),\nencrypted files (<code>store_files</code> and <code>restore_files</code>), and -- as additional\nfeature for potential usage in\nother projects -- encrypted key-value pairs (<code>store_values</code> with <code>restore_files</code>\n(shared with file storage)).</p>\n<p>It is the backbone of the CLI.</p>\n\n          </div>"}, "last_serial": 6604593, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "b174df7978c31d0ec25214da6f0b0022", "sha256": "816c88423b86139bafb2d1ccdcf86714b96f1b2a587fa8c7e089aafa7730fcf5"}, "downloads": -1, "filename": "cryp_to_go-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b174df7978c31d0ec25214da6f0b0022", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17837, "upload_time": "2020-02-10T19:46:11", "upload_time_iso_8601": "2020-02-10T19:46:11.963939Z", "url": "https://files.pythonhosted.org/packages/59/20/4aec75679d0cc0d425614dcce62b1d3745baf2c9faf04159ff155d6415b5/cryp_to_go-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b5bd028dbb5bb0347958125990a79fc6", "sha256": "4a9dd48c99e7679217d6dff9a83d8fbe477b3c2c12cf0134e48fb78852a9f052"}, "downloads": -1, "filename": "cryp-to-go-0.1.1.tar.gz", "has_sig": false, "md5_digest": "b5bd028dbb5bb0347958125990a79fc6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 17476, "upload_time": "2020-02-10T19:46:14", "upload_time_iso_8601": "2020-02-10T19:46:14.283374Z", "url": "https://files.pythonhosted.org/packages/91/a0/efc5c909ad87b68d14676c2362e2cff3ae607aa665069fe9e64ce31070d0/cryp-to-go-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b174df7978c31d0ec25214da6f0b0022", "sha256": "816c88423b86139bafb2d1ccdcf86714b96f1b2a587fa8c7e089aafa7730fcf5"}, "downloads": -1, "filename": "cryp_to_go-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b174df7978c31d0ec25214da6f0b0022", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17837, "upload_time": "2020-02-10T19:46:11", "upload_time_iso_8601": "2020-02-10T19:46:11.963939Z", "url": "https://files.pythonhosted.org/packages/59/20/4aec75679d0cc0d425614dcce62b1d3745baf2c9faf04159ff155d6415b5/cryp_to_go-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b5bd028dbb5bb0347958125990a79fc6", "sha256": "4a9dd48c99e7679217d6dff9a83d8fbe477b3c2c12cf0134e48fb78852a9f052"}, "downloads": -1, "filename": "cryp-to-go-0.1.1.tar.gz", "has_sig": false, "md5_digest": "b5bd028dbb5bb0347958125990a79fc6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 17476, "upload_time": "2020-02-10T19:46:14", "upload_time_iso_8601": "2020-02-10T19:46:14.283374Z", "url": "https://files.pythonhosted.org/packages/91/a0/efc5c909ad87b68d14676c2362e2cff3ae607aa665069fe9e64ce31070d0/cryp-to-go-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:42:01 2020"}