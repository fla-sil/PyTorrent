{"info": {"author": "MAN Alpha Technology", "author_email": "ManAlphaTech@man.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.8", "Topic :: Software Development"], "description": "# Partial Testing\n\nContinuous Integration practices enable the frequent and verified (built and tested) contribution of code to shared repositories. But, as projects grow, so do their test suites and the time it takes to run them.\nSmall and contained changes do not require all tests to be run, most of them would not be relevant. To improve developer productivy and reduce resource usage, we have implemented **Partial Testing**.\nBy recording coverage data from previous runs, it identifies which tests should be run for each new change or pull-request.\n\n\nTo maintain coverage data up-to-date, and to ensure all tests are still occasionally run, master branch builds execute the entire test suite while recording coverage at the same time. The coverage data from the master branch is saved as a `.coverage` file (which is a sqlite DB file from [coveragepy>=5.0](https://github.com/nedbat/coveragepy), details available [here](https://nedbatchelder.com/blog/201810/who_tests_what_is_here.html)) and non-master branches utilize that file to run only the relevant tests for the changes included in the branch.\n\n\nFor simplicity, we consider a file as the smallest possible changed unit (instead of doing it at the line level). That is, if a line has changed, it is treated as if the entire file has changed.\nThis approach reduces the complexity of Partial Testing and provides a wider safety net against filtering out tests that were actually relevant.\n\n\n![Partial Testing Diagram](new_pt_image.png)\n\n\nAs shown on the image above, once a file has been modified, a few different testing scenarios arise according to the type of the file. It is also possible that a combination is required.\nThe different file types are as follows:\n\n* Partial Testing only works with projects that are in **git**.\n\n### Source Code File\nIncludes any file that contains code and is not part of the test suite. They usually have the Python extension, `.py`, but could also have `.cpp`, `.c`, etc. instead.\n\nWhen modified:\n\na) check the saved coverage data to find all relevant tests (test names).\n\nb) For each test name, find which file has its definition.\n\nc) feed `pytest` (or any other testing tool) the files from step b.\n\nWhen a new file is added, the complete test suite must be run.\n\n### Test Code File\nIncludes any file that contains code and is part of the test suite, by default it includes all python files under `tests/`. They have the Python extension `.py`. When modified, run all the tests contained within the changed file.\n\nWhen a new test file is added, all the tests within itself must be run. When one is deleted, no tests from it need to be run.\n\nAdditionally, some files under the tests directory might be utility files that get imported by other test files. Because of this, for modified test files, we need 2 steps:\n\na) check which tests use the file (just like non-test code files)\n\nb) run the tests within the modified file\n\n\n### Special/Config File\nIncludes any file that does not contain code but affects the way code is run. Examples: `setup.cfg`\n\nWhen modified or when a new one is added, all tests need to be run.\n\nEach project should have the ability to specify which files and/or file extensions should be considered special files, see below for details.\n\nWe have included `conftest.py` (pytest) under this category of files, even though it initially looks like a code file (.py) or a test file (it sits under the test directories).\n\n### Non-Code File\nIncludes any file that does not contain code. For example, README or `.md` files.\n\nWhen modified or a new one is added, no tests need to be run.\n\nIn Summary,\n\n\n|           | Source Code Files           | Test Files                                             | Non-Code Files  | Special/Config Files |\n|-----------| --------------------------- | ------------------------------------------------------ | --------------- | -------------        |\n| Extension | .py, .cpp, .c               | .py                                                    | .md             |.cfg                  |\n| Modified  | Run tests that use the file | Run tests a) within modified file b) that use the file | Don't run tests |Run all tests         |\n| Added New | Run all tests               | Run tests within new file                              | Don't run tests |Run all tests         |\n| Deleted   | Run tests that use the file | Do not run that file                                   | Don't run tests |Run all tests         |\n\n\n### Usage\n\nInstallation\n\n```\npip install partialtesting  # soon to be published in pypi\n```\n\nOnce installed, the binaries `partialtest` and `partialtesting` (they are identical, the later is kept for compatibility) become available in your virtual environment:\n\n```\n$ partialtesting --help\nUsage: partialtesting [OPTIONS]\n\n  Partial Testing (PT) identifies which tests need to be run for a given\n  change set, improving the speed of testing, developer productivity and\n  resource usage. To achieve this, PT relies on enriched coverage data\n  generated before hand, generally by a master-branch build running on a CI\n  (e.g. Jenkins).\n\n  PT expects to find the coverage data in a directory with the below\n  pattern: <coverage_dir>/<project_name>. Use the options for this script to\n  specify them\n\n  More information available in the README.\n\nOptions:\n  --coverage-dir TEXT        Path to the saved coverage data. Set a default\n                             path by setting the below in ~/.partialtesting:\n                             [coverage] dir=<path>\n\n  --project-name TEXT        Project name (e.g. numpy).The name will be used\n                             to get the path to the coverage data for this\n                             project:\n                             <coverage_dir>/<project_name>/.../.coverage\n                             [required]\n```\n\n#### Partialtesting Locally\n\nThis sections shows how to use `partialtesting` locally, but its convenience and benefits are maximized when used with a continuous integration system (CI), like Jenkins. That will be explained in the section below.\n\nTo use `partialtesting` locally, specify the directory in which the coverage data will be stored. That is, the coverage data generated during a previous run of the entire test suite or from a master build, more details in the CI section above.\n\nAs an example, say your project's code repository (git) is as follows:\n```\n$ tree\n\u251c\u2500\u2500 code1.py\n\u251c\u2500\u2500 code2.py\n\u251c\u2500\u2500 .coveragerc  # explained below\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_code1.py\n```\n\nand the files have the following content:\n\n```\n$ cat code1.py\ndef myfunc1():\n    print('in myfunc1')\n\ndef myfunc2():\n    print('in myfunc2')\n    myfunc3()\n\ndef myfunc3():\n    print('in myfunc3')\n```\n\n```\n$ cat code2.py\ndef myfunc4():\n    print('in myfunc4')\n```\n\n```\n$ cat tests/test_code1.py\nimport code1\n\ndef test_code1():\n    code1.myfunc1()\n\ndef test_code2():\n    code1.myfunc2()\n```\n\nNow, run the entire test suite to generate the coverage data that `partialtesting` will use.\n\n```\n$ pip install coverage>=5 pytest\n$ PYTHONPATH='.' coverage --branch run -m pytest tests/\n================================================================================== test session starts ===================================================================================\nplatform darwin -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1\nrootdir: /Users/fersarr/workspace/fake_project\ncollected 2 items\n\ntests/test_code1.py ..                                                                                                                                                             [100%]\n\n=================================================================================== 2 passed in 0.01s ====================================================================================\n```\n\nMake sure you have `coverage>=5.0` and a `.coveragerc` file telling coverage to record test contexts ([read more here](https://nedbatchelder.com/blog/201810/who_tests_what_is_here.html))\n\n```\n$ cat .coveragerc\n[run]\ndynamic_context = test_function\n```\n\nThe `coverage ... pytest` command should have generated a `.coverage` file, which is a SQLite database:\n\n```\n$ sqlite3 .coverage \".tables\"\narc              coverage_schema  line_bits        tracer\ncontext          file             meta\n```\n\nNow, move the `.coverage` file into a directory that will hold coverage data for this project:\n```\n$ mkdir -p saved_coverage/fake_project/ && cp .coverage saved_coverage/fake_project/\n$ tree\n\u251c\u2500\u2500 saved_coverage\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 fake_project\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 .coverage\n```\n\nOkay, everything is set and ready for `partialtesting` to work, so let's modify a file and run `PT`.\n\nModified a code file by adding one line:\n```\n$ git diff\ndiff --git a/code1.py b/code1.py\nindex faecfed..40f81cc 100644\n--- a/code1.py\n+++ b/code1.py\n@@ -1,5 +1,6 @@\n def myfunc1():\n     print('in myfunc1')\n+    print('changing myfunc1')\n```\n\nRun `partialtesting`:\n\n```\n$ partialtest --coverage-dir saved_coverage --project-name fake_project --compare-to-branch master\n...\nINFO:root:Partial Testing: using coverage file 'saved_coverage/fake_project/.coverage'\n...\nINFO:root:Creating file test_files_to_run.txt\nINFO:root:Partial Testing: relevant test files:\ntests/test_code1.py\n```\n\nAs `PT` tells us, for the change we made, we need to run the tests in `tests/test_code1.py`.\n\n#### Partialtesting on a CI (e.g. Jenkins)\n\nAs mentioned above, partialtesting can be used in a Continous Integration system (CI), like Jenkins to improve resource usage and reduce build time. The process is similar to running it locally as explained in the section above, but the difference lies in setting up the master branch to produce the coverage data `.coverage` and saving it in an accessible directory so that non-master branches can run `partialtesting` and use it.\n\n1) Run the full test suite with coverage in the master branch and save the `.coverage` file to a path:\n\n```\n$ coverage run -p --branch pytest tests/\n$ cp .coverage jenkins/saved_coverage/project_x/907/  # build number 907\n```\n\nReminder: add/create a `.coveragerc` file as exlpained above to save test contexts with the coverage data.\n\n2) Use `partialtesting` on the non-master branch to get a list of the tests that should be run given the changes in the branch.\n\n```\npartialtesting --project-name project_x --coverage-dir /jenkins/saved_coverage/ --git-diff-use-head --special-files \"'setup.py', 'setup.cfg'\" --special-extensions \"'.pkl', '.h5', '.csv'\"\n```\n\nThe list of tests that need to be run is output to the file `test_files_to_run.txt` (customisable via `--output-file`)\n\nFeed those tests to `pytest` or your preferred testing tool.\n\n## Acknowledgements\n\nPartial Testing has been under active development at [Man Alpha Tech](http://www.man.com/) since 2019.\n\nOriginal concept and implementation: [Fernando Saravia Rajal](https://github.com/fersarr)\n\nContributors:\n\n * [Fernando Saravia Rajal](https://github.com/fersarr)\n\n * [Luke Fitzgerald](https://github.com/lwfitzgerald)\n\n\n## Related Links\n\n[who-tests-what in coverage.py](https://nedbatchelder.com/blog/201612/who_tests_what.html)\n\n[who-tests-what is here coverage v5](https://nedbatchelder.com/blog/201810/who_tests_what_is_here.html)\n\n[who-tests-what empty context names](https://github.com/nedbat/coveragepy/issues/796)\n\n[slower tests when recording coverage context](https://github.com/nedbat/coveragepy/issues/793)\n\n[pytest-testmon](https://github.com/tarpas/pytest-testmon)\n\n[pytest-testmon pycon video](https://www.youtube.com/watch?v=nrSZthcAN2U)\n\n[who-tests-what issue with old-style classes in PY2](https://github.com/nedbat/coveragepy/issues/797)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/man-group/partialtesting", "keywords": "testing,coverage,partialtesting", "license": "GPLv3+", "maintainer": "", "maintainer_email": "", "name": "partialtesting", "package_url": "https://pypi.org/project/partialtesting/", "platform": "", "project_url": "https://pypi.org/project/partialtesting/", "project_urls": {"Homepage": "https://github.com/man-group/partialtesting"}, "release_url": "https://pypi.org/project/partialtesting/1.0/", "requires_dist": ["click", "pytest ; extra == 'tests'"], "requires_python": "", "summary": "Partial Testing: run only the tests relevant to your changes", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Partial Testing</h1>\n<p>Continuous Integration practices enable the frequent and verified (built and tested) contribution of code to shared repositories. But, as projects grow, so do their test suites and the time it takes to run them.\nSmall and contained changes do not require all tests to be run, most of them would not be relevant. To improve developer productivy and reduce resource usage, we have implemented <strong>Partial Testing</strong>.\nBy recording coverage data from previous runs, it identifies which tests should be run for each new change or pull-request.</p>\n<p>To maintain coverage data up-to-date, and to ensure all tests are still occasionally run, master branch builds execute the entire test suite while recording coverage at the same time. The coverage data from the master branch is saved as a <code>.coverage</code> file (which is a sqlite DB file from <a href=\"https://github.com/nedbat/coveragepy\" rel=\"nofollow\">coveragepy&gt;=5.0</a>, details available <a href=\"https://nedbatchelder.com/blog/201810/who_tests_what_is_here.html\" rel=\"nofollow\">here</a>) and non-master branches utilize that file to run only the relevant tests for the changes included in the branch.</p>\n<p>For simplicity, we consider a file as the smallest possible changed unit (instead of doing it at the line level). That is, if a line has changed, it is treated as if the entire file has changed.\nThis approach reduces the complexity of Partial Testing and provides a wider safety net against filtering out tests that were actually relevant.</p>\n<p><img alt=\"Partial Testing Diagram\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e7e38de34dac461fb176906437bfddf5a6a059de/6e65775f70745f696d6167652e706e67\"></p>\n<p>As shown on the image above, once a file has been modified, a few different testing scenarios arise according to the type of the file. It is also possible that a combination is required.\nThe different file types are as follows:</p>\n<ul>\n<li>Partial Testing only works with projects that are in <strong>git</strong>.</li>\n</ul>\n<h3>Source Code File</h3>\n<p>Includes any file that contains code and is not part of the test suite. They usually have the Python extension, <code>.py</code>, but could also have <code>.cpp</code>, <code>.c</code>, etc. instead.</p>\n<p>When modified:</p>\n<p>a) check the saved coverage data to find all relevant tests (test names).</p>\n<p>b) For each test name, find which file has its definition.</p>\n<p>c) feed <code>pytest</code> (or any other testing tool) the files from step b.</p>\n<p>When a new file is added, the complete test suite must be run.</p>\n<h3>Test Code File</h3>\n<p>Includes any file that contains code and is part of the test suite, by default it includes all python files under <code>tests/</code>. They have the Python extension <code>.py</code>. When modified, run all the tests contained within the changed file.</p>\n<p>When a new test file is added, all the tests within itself must be run. When one is deleted, no tests from it need to be run.</p>\n<p>Additionally, some files under the tests directory might be utility files that get imported by other test files. Because of this, for modified test files, we need 2 steps:</p>\n<p>a) check which tests use the file (just like non-test code files)</p>\n<p>b) run the tests within the modified file</p>\n<h3>Special/Config File</h3>\n<p>Includes any file that does not contain code but affects the way code is run. Examples: <code>setup.cfg</code></p>\n<p>When modified or when a new one is added, all tests need to be run.</p>\n<p>Each project should have the ability to specify which files and/or file extensions should be considered special files, see below for details.</p>\n<p>We have included <code>conftest.py</code> (pytest) under this category of files, even though it initially looks like a code file (.py) or a test file (it sits under the test directories).</p>\n<h3>Non-Code File</h3>\n<p>Includes any file that does not contain code. For example, README or <code>.md</code> files.</p>\n<p>When modified or a new one is added, no tests need to be run.</p>\n<p>In Summary,</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Source Code Files</th>\n<th>Test Files</th>\n<th>Non-Code Files</th>\n<th>Special/Config Files</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Extension</td>\n<td>.py, .cpp, .c</td>\n<td>.py</td>\n<td>.md</td>\n<td>.cfg</td>\n</tr>\n<tr>\n<td>Modified</td>\n<td>Run tests that use the file</td>\n<td>Run tests a) within modified file b) that use the file</td>\n<td>Don't run tests</td>\n<td>Run all tests</td>\n</tr>\n<tr>\n<td>Added New</td>\n<td>Run all tests</td>\n<td>Run tests within new file</td>\n<td>Don't run tests</td>\n<td>Run all tests</td>\n</tr>\n<tr>\n<td>Deleted</td>\n<td>Run tests that use the file</td>\n<td>Do not run that file</td>\n<td>Don't run tests</td>\n<td>Run all tests</td>\n</tr></tbody></table>\n<h3>Usage</h3>\n<p>Installation</p>\n<pre><code>pip install partialtesting  # soon to be published in pypi\n</code></pre>\n<p>Once installed, the binaries <code>partialtest</code> and <code>partialtesting</code> (they are identical, the later is kept for compatibility) become available in your virtual environment:</p>\n<pre><code>$ partialtesting --help\nUsage: partialtesting [OPTIONS]\n\n  Partial Testing (PT) identifies which tests need to be run for a given\n  change set, improving the speed of testing, developer productivity and\n  resource usage. To achieve this, PT relies on enriched coverage data\n  generated before hand, generally by a master-branch build running on a CI\n  (e.g. Jenkins).\n\n  PT expects to find the coverage data in a directory with the below\n  pattern: &lt;coverage_dir&gt;/&lt;project_name&gt;. Use the options for this script to\n  specify them\n\n  More information available in the README.\n\nOptions:\n  --coverage-dir TEXT        Path to the saved coverage data. Set a default\n                             path by setting the below in ~/.partialtesting:\n                             [coverage] dir=&lt;path&gt;\n\n  --project-name TEXT        Project name (e.g. numpy).The name will be used\n                             to get the path to the coverage data for this\n                             project:\n                             &lt;coverage_dir&gt;/&lt;project_name&gt;/.../.coverage\n                             [required]\n</code></pre>\n<h4>Partialtesting Locally</h4>\n<p>This sections shows how to use <code>partialtesting</code> locally, but its convenience and benefits are maximized when used with a continuous integration system (CI), like Jenkins. That will be explained in the section below.</p>\n<p>To use <code>partialtesting</code> locally, specify the directory in which the coverage data will be stored. That is, the coverage data generated during a previous run of the entire test suite or from a master build, more details in the CI section above.</p>\n<p>As an example, say your project's code repository (git) is as follows:</p>\n<pre><code>$ tree\n\u251c\u2500\u2500 code1.py\n\u251c\u2500\u2500 code2.py\n\u251c\u2500\u2500 .coveragerc  # explained below\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_code1.py\n</code></pre>\n<p>and the files have the following content:</p>\n<pre><code>$ cat code1.py\ndef myfunc1():\n    print('in myfunc1')\n\ndef myfunc2():\n    print('in myfunc2')\n    myfunc3()\n\ndef myfunc3():\n    print('in myfunc3')\n</code></pre>\n<pre><code>$ cat code2.py\ndef myfunc4():\n    print('in myfunc4')\n</code></pre>\n<pre><code>$ cat tests/test_code1.py\nimport code1\n\ndef test_code1():\n    code1.myfunc1()\n\ndef test_code2():\n    code1.myfunc2()\n</code></pre>\n<p>Now, run the entire test suite to generate the coverage data that <code>partialtesting</code> will use.</p>\n<pre><code>$ pip install coverage&gt;=5 pytest\n$ PYTHONPATH='.' coverage --branch run -m pytest tests/\n================================================================================== test session starts ===================================================================================\nplatform darwin -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1\nrootdir: /Users/fersarr/workspace/fake_project\ncollected 2 items\n\ntests/test_code1.py ..                                                                                                                                                             [100%]\n\n=================================================================================== 2 passed in 0.01s ====================================================================================\n</code></pre>\n<p>Make sure you have <code>coverage&gt;=5.0</code> and a <code>.coveragerc</code> file telling coverage to record test contexts (<a href=\"https://nedbatchelder.com/blog/201810/who_tests_what_is_here.html\" rel=\"nofollow\">read more here</a>)</p>\n<pre><code>$ cat .coveragerc\n[run]\ndynamic_context = test_function\n</code></pre>\n<p>The <code>coverage ... pytest</code> command should have generated a <code>.coverage</code> file, which is a SQLite database:</p>\n<pre><code>$ sqlite3 .coverage \".tables\"\narc              coverage_schema  line_bits        tracer\ncontext          file             meta\n</code></pre>\n<p>Now, move the <code>.coverage</code> file into a directory that will hold coverage data for this project:</p>\n<pre><code>$ mkdir -p saved_coverage/fake_project/ &amp;&amp; cp .coverage saved_coverage/fake_project/\n$ tree\n\u251c\u2500\u2500 saved_coverage\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 fake_project\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 .coverage\n</code></pre>\n<p>Okay, everything is set and ready for <code>partialtesting</code> to work, so let's modify a file and run <code>PT</code>.</p>\n<p>Modified a code file by adding one line:</p>\n<pre><code>$ git diff\ndiff --git a/code1.py b/code1.py\nindex faecfed..40f81cc 100644\n--- a/code1.py\n+++ b/code1.py\n@@ -1,5 +1,6 @@\n def myfunc1():\n     print('in myfunc1')\n+    print('changing myfunc1')\n</code></pre>\n<p>Run <code>partialtesting</code>:</p>\n<pre><code>$ partialtest --coverage-dir saved_coverage --project-name fake_project --compare-to-branch master\n...\nINFO:root:Partial Testing: using coverage file 'saved_coverage/fake_project/.coverage'\n...\nINFO:root:Creating file test_files_to_run.txt\nINFO:root:Partial Testing: relevant test files:\ntests/test_code1.py\n</code></pre>\n<p>As <code>PT</code> tells us, for the change we made, we need to run the tests in <code>tests/test_code1.py</code>.</p>\n<h4>Partialtesting on a CI (e.g. Jenkins)</h4>\n<p>As mentioned above, partialtesting can be used in a Continous Integration system (CI), like Jenkins to improve resource usage and reduce build time. The process is similar to running it locally as explained in the section above, but the difference lies in setting up the master branch to produce the coverage data <code>.coverage</code> and saving it in an accessible directory so that non-master branches can run <code>partialtesting</code> and use it.</p>\n<ol>\n<li>Run the full test suite with coverage in the master branch and save the <code>.coverage</code> file to a path:</li>\n</ol>\n<pre><code>$ coverage run -p --branch pytest tests/\n$ cp .coverage jenkins/saved_coverage/project_x/907/  # build number 907\n</code></pre>\n<p>Reminder: add/create a <code>.coveragerc</code> file as exlpained above to save test contexts with the coverage data.</p>\n<ol>\n<li>Use <code>partialtesting</code> on the non-master branch to get a list of the tests that should be run given the changes in the branch.</li>\n</ol>\n<pre><code>partialtesting --project-name project_x --coverage-dir /jenkins/saved_coverage/ --git-diff-use-head --special-files \"'setup.py', 'setup.cfg'\" --special-extensions \"'.pkl', '.h5', '.csv'\"\n</code></pre>\n<p>The list of tests that need to be run is output to the file <code>test_files_to_run.txt</code> (customisable via <code>--output-file</code>)</p>\n<p>Feed those tests to <code>pytest</code> or your preferred testing tool.</p>\n<h2>Acknowledgements</h2>\n<p>Partial Testing has been under active development at <a href=\"http://www.man.com/\" rel=\"nofollow\">Man Alpha Tech</a> since 2019.</p>\n<p>Original concept and implementation: <a href=\"https://github.com/fersarr\" rel=\"nofollow\">Fernando Saravia Rajal</a></p>\n<p>Contributors:</p>\n<ul>\n<li>\n<p><a href=\"https://github.com/fersarr\" rel=\"nofollow\">Fernando Saravia Rajal</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/lwfitzgerald\" rel=\"nofollow\">Luke Fitzgerald</a></p>\n</li>\n</ul>\n<h2>Related Links</h2>\n<p><a href=\"https://nedbatchelder.com/blog/201612/who_tests_what.html\" rel=\"nofollow\">who-tests-what in coverage.py</a></p>\n<p><a href=\"https://nedbatchelder.com/blog/201810/who_tests_what_is_here.html\" rel=\"nofollow\">who-tests-what is here coverage v5</a></p>\n<p><a href=\"https://github.com/nedbat/coveragepy/issues/796\" rel=\"nofollow\">who-tests-what empty context names</a></p>\n<p><a href=\"https://github.com/nedbat/coveragepy/issues/793\" rel=\"nofollow\">slower tests when recording coverage context</a></p>\n<p><a href=\"https://github.com/tarpas/pytest-testmon\" rel=\"nofollow\">pytest-testmon</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=nrSZthcAN2U\" rel=\"nofollow\">pytest-testmon pycon video</a></p>\n<p><a href=\"https://github.com/nedbat/coveragepy/issues/797\" rel=\"nofollow\">who-tests-what issue with old-style classes in PY2</a></p>\n\n          </div>"}, "last_serial": 6916403, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "9f4719e2aaddc5e4c0e7f66de5efe821", "sha256": "161bbe2edcda0bbe39fbca739de34b97fdbd3b451d1ff77ed0eb6d3cc05a4665"}, "downloads": -1, "filename": "partialtesting-1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9f4719e2aaddc5e4c0e7f66de5efe821", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24884, "upload_time": "2020-03-30T15:01:38", "upload_time_iso_8601": "2020-03-30T15:01:38.279422Z", "url": "https://files.pythonhosted.org/packages/a4/91/eb13bfd3cce2f06478999775f55ee6f1ba8f0cb438a5ba90a48ff55cb7cb/partialtesting-1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d42379f5e38dcd9c32ea438180094274", "sha256": "1ab8a0ef8ad8d3cdce3cd61b99c9899b1de1e3ca10081a9be0970d132b73e35d"}, "downloads": -1, "filename": "partialtesting-1.0-py3.8.egg", "has_sig": false, "md5_digest": "d42379f5e38dcd9c32ea438180094274", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": null, "size": 21332, "upload_time": "2020-03-30T15:01:40", "upload_time_iso_8601": "2020-03-30T15:01:40.413500Z", "url": "https://files.pythonhosted.org/packages/18/82/d6f93bd4468a8e8de2e806ce474edf9cdea7a49b2021127488339b3adb9b/partialtesting-1.0-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "eaf6d65d08b72028cbc72bfd370fe6cf", "sha256": "06133d723d707c2d9c71de08dd58ac7a5ec582c84fa0675e41e023ba5a29f813"}, "downloads": -1, "filename": "partialtesting-1.0.tar.gz", "has_sig": false, "md5_digest": "eaf6d65d08b72028cbc72bfd370fe6cf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16149, "upload_time": "2020-03-30T15:01:41", "upload_time_iso_8601": "2020-03-30T15:01:41.591507Z", "url": "https://files.pythonhosted.org/packages/fe/24/6544b66b96e93baf3244e7cbe0f54d39ed391a9fdc3ad66cee0120f9a87e/partialtesting-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9f4719e2aaddc5e4c0e7f66de5efe821", "sha256": "161bbe2edcda0bbe39fbca739de34b97fdbd3b451d1ff77ed0eb6d3cc05a4665"}, "downloads": -1, "filename": "partialtesting-1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9f4719e2aaddc5e4c0e7f66de5efe821", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24884, "upload_time": "2020-03-30T15:01:38", "upload_time_iso_8601": "2020-03-30T15:01:38.279422Z", "url": "https://files.pythonhosted.org/packages/a4/91/eb13bfd3cce2f06478999775f55ee6f1ba8f0cb438a5ba90a48ff55cb7cb/partialtesting-1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d42379f5e38dcd9c32ea438180094274", "sha256": "1ab8a0ef8ad8d3cdce3cd61b99c9899b1de1e3ca10081a9be0970d132b73e35d"}, "downloads": -1, "filename": "partialtesting-1.0-py3.8.egg", "has_sig": false, "md5_digest": "d42379f5e38dcd9c32ea438180094274", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": null, "size": 21332, "upload_time": "2020-03-30T15:01:40", "upload_time_iso_8601": "2020-03-30T15:01:40.413500Z", "url": "https://files.pythonhosted.org/packages/18/82/d6f93bd4468a8e8de2e806ce474edf9cdea7a49b2021127488339b3adb9b/partialtesting-1.0-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "eaf6d65d08b72028cbc72bfd370fe6cf", "sha256": "06133d723d707c2d9c71de08dd58ac7a5ec582c84fa0675e41e023ba5a29f813"}, "downloads": -1, "filename": "partialtesting-1.0.tar.gz", "has_sig": false, "md5_digest": "eaf6d65d08b72028cbc72bfd370fe6cf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16149, "upload_time": "2020-03-30T15:01:41", "upload_time_iso_8601": "2020-03-30T15:01:41.591507Z", "url": "https://files.pythonhosted.org/packages/fe/24/6544b66b96e93baf3244e7cbe0f54d39ed391a9fdc3ad66cee0120f9a87e/partialtesting-1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:13 2020"}