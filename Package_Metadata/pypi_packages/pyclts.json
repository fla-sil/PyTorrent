{"info": {"author": "Johann-Mattis List, Cormac Anderson, Tiago Tresoldi, Christoph Rzymski, Simon Greenhill, and Robert Forkel", "author_email": "mattis.list@lingpy.org", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy"], "description": "# pyclts\n\nTooling to access and curate [CLTS data](https://github.com/cldf-clts/clts).\n\n[![Build Status](https://travis-ci.org/cldf-clts/pyclts.svg?branch=master)](https://travis-ci.org/cldf-clts/pyclts)\n[![codecov](https://codecov.io/gh/cldf-clts/pyclts/branch/master/graph/badge.svg)](https://codecov.io/gh/cldf-clts/pyclts)\n[![PyPI](https://img.shields.io/pypi/v/pyclts.svg)](https://pypi.org/project/pyclts)\n\n\nThis is an attempt to create a system that allows to translate and compare different phonetic transcription systems.\n\n\n## Install\n\n`pyclts` provides a Python API for [CLTS data](https://github.com/cldf-clts/clts).\nUsing `pyclts` requires this data to be available locally, either as repository\nclone, or as unzipped download of a [released version](https://github.com/cldf-clts/clts/releases).\n\nTo install `pyclts` run\n```\npip install pyclts\n```\nThis will install the python API as well as a command line tool `clts`.\nBoth, require the location of the data as argument:\n```python\n>>> from pyclts import CLTS\n>>> clts = CLTS('PATH/TO/clts')\n```\nor\n```bash\nclts --repos PATH/TO/clts stats\n```\n\nTo save this effort, the data location can also be looked up in a [`cldfcatalog` config file](https://github.com/cldf/cldfcatalog/#configuration), under the key `clts`.\n\nSuch a config file (and the repository clone) can be created automatically,\nby installing [`cldfbench`](https://pypi.org/cldfbench) and running\n`cldfbench config`.\n\n\n## Overview\n\nUsing `pyclts` is exemplified in this short code snippet:\n\n```python\n>>> from pyclts import CLTS\n>>> clts = CLTS('clts/')\n>>> asjp = clts.transcriptionsystem('asjpcode')\n>>> snd1 = clts.bipa['ts']\n>>> snd2 = asjp['c']\n>>> snd1.name\n'voiceless alveolar sibilant affricate consonant'\n>>> snd2.name\n'voiceless alveolar sibilant affricate consonant'\n>>> clts.bipa.translate('ts a \u014b \u0259', asjp)\n'c E N 3'\n>>> asjp.translate('C a y', clts.bipa)\n't\u0283 \u0250 j'\n```\n\nNotes:\n- Since \"bipa\" is the standard transcriptionsystem in CLTS, it's available - as shortcut -\n  directly as `bipa` attribute of `CLTS`.\n- We represent the sounds `ts` and `c`, depending on the alphabet from which they are taken.\n\n\n## Sounds\n\n`pyclts` can not only deal with sound that are already in our database. Intead, We it tries to create \"unknown\" sounds automatically and infer its features from the set of diacritics and the base sound:\n\n```python\n>>> sound = clts.bipa['d\u02b1\u02b7']\n>>> sound.name\n'labialized breathy voiced alveolar stop consonant'\n>>> sound.generated\nTrue\n>>> sound.alias\nTrue\n>>> print(sound)\nd\u02b7\u02b1\n>>> print(sound.uname)\nLATIN SMALL LETTER D / MODIFIER LETTER SMALL W / MODIFIER LETTER SMALL H WITH HOOK\n>>> print(sound.codepoints)\nU+0064 U+02b7 U+02b1\n```\n\nYou can see, since we represent breathy-voice phonation differently, we flag this sound as an alias. Also since it is not yet in our database explicitly coded, we flag it as a \"generated\" sound. In a similar way, you can generate sounds from their names:\n\n```python\n>>> sound = clts.bipa['pre-aspirated voiced aspirated bilabial stop consonant']\n>>> print(sound)\n\u02b0b\u02b0\n>>> sound.generated\nTrue\n>>> sound.name\n'pre-aspirated aspirated voiced bilabial stop consonant'\n```\n\nNote that this sound probably does not exist in any language, but we generate it from the feature components. Note also that the ```name``` that is automatically given for the sound automatically orders how the features are put together to form the sound identifier. In principle, our features bundles are unordered, but we try to decide for some explicit order of features to enhance comparison.\n\n\n## Transcription systems and sound classes\n\nYou can also use our transcription data to convert from one transcription system to a given dataset (note that backwards-conversion may not be possible, as transcription data is often limited):\n\n```python\n>>> sca = clts.soundclass('sca')\n>>> clts.bipa.translate('f a: t \u0259 r', sca)\n'B A T E R'\n```\n\nThe translation can also be done by loading the transcription data directly:\n```python\n>>> sca('v a t \u0259 r')\n['B', 'A', 'T', 'E', 'R']\n```\n\n\n## Basic Structure of the Package\n\n`pyclts` provides access to three basic types of data:\n\n* transcription systems (```pyclts.transcriptionsystems.TranscriptionSystem```), a system that can *generate* sounds\n* transcription data (```pyclts.transcriptiondata.TranscriptionData```): a dataset with a *fixed number of sounds*\n* sound classes (```pyclts.soundclasses.SoundClasses```): a dataset with a direct mapping from sounds to a concrete character (the sound class)\n\nTranscription data is linked to our transcription system by the grapheme for the B(road) IPA transcription system, which serves as our default, and the name, which follows the IPA conventions with some modifications which were needed to make sure that we can represent sounds that we regularly find in cross-linguistic datasets.\n\n\n## Parsing Procedure \n\nfeature | handled by | note | example\n--- | --- | --- | ---\nnormalized | ```ts._norm()```, ```ts[sound].normalized``` | this refers to one-to-one character replacement with obviously wrong unicode lookalikes | ```\u03bb``` (wrong) vs. ```\u028e``` (correct)\nalias | transcription system data (```+``` indicates alias), ```ts['sound'].alias``` | this refers to \"free\" IPA variants that are widely used and are therefore officially accepted for \"broad ipa\" or any other TS, but one variant is usually chosen as the preferred one | ```ts``` (normal) vs. ```\u02a6``` (alias)\nsource | ```ts['sound'].source``` | the unnormalized form as it is given to the TS | ```bipa['\u03bb'].source == '\u03bb'```\ngrapheme | ```ts[lingpy/'sound'].grapheme``` | the normalized form which has not been resolved by an alias | ```bipa['\u02a6'].grapheme == '\u02a6'\nstring/unicode | ```ts['sound'].__unicode__()``` | the normalized form in which a potential alias is replaced by its \"accepted\" counterpart | ```str(bipa['\u02a6']) == 'ts'```\nname | ```bipa['sound'].name``` | the canonical representation of the feature system that defines a sound, with the sound class (consonant, cluster, vowel, diphthong) in the end, and the feature bundle following the order given in the ```pyclts.models``` description of the corresponding sound class. This representation serves as the basis for translation among different TS. | ```bipa['ts'].name == 'voiceless alveolar sibilant-affricate consonant'```\ngenerated | ```ts['sound'].generated``` | If a sound is not yet know to a given TS, the algorithm tries to generate it by de-composing it into its *base part* and adding features to the left and to the right, based on the *diacritics*. If a sound has been generated, this is traced with help of the attribute. Normally, generated sounds need to be double-checked by the experts, as their grapheme representation may be erroneous. Thus, while the sound ```k\u02b7\u02b0``` can be regularly defined in a TS (like BIPA), a user might query ```k\u02b0\u02b7```, in which case the sound would be generated internally, the grapheme would be stored in its normalized form (which is identical with the base), but the ```str()```-representation would contain the correct order, and the character would be automatically qualified as an alias of an existing one.  | ```str(TS['k\u02b0\u02b7']) == 'k\u02b7\u02b0' and TS['k\u02b0\u02b7'].grapheme == 'k\u02b0\u02b7' and TS[''k\u02b0\u02b7'].alias and TS['k\u02b0\u02b7'].generated``` \nbase | ```ts['sound'].base``` | if a sound is being generated, the parsing algorithm first tries to identify the potential \"base\" of the sound, i.e., a sound that is already known and explicitly defined in a given transcription system. Based on this base sound, the grapheme is then constructed by following the diacritics to the left and to the right. If the so-constructed feature bundle already exists in the transcription system, the constructed sound is treated as an alias, if it does not exist, the sound is only marked as being generated. | ```str(TS['d\u0324\u02b7']) == 'd\u02b7\u02b1'```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/cldf-clts/pyclts", "keywords": "", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "pyclts", "package_url": "https://pypi.org/project/pyclts/", "platform": "any", "project_url": "https://pypi.org/project/pyclts/", "project_urls": {"Homepage": "https://github.com/cldf-clts/pyclts"}, "release_url": "https://pypi.org/project/pyclts/2.0.0/", "requires_dist": null, "requires_python": ">=3.5", "summary": "A python library to check phonetic transcriptions", "version": "2.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>pyclts</h1>\n<p>Tooling to access and curate <a href=\"https://github.com/cldf-clts/clts\" rel=\"nofollow\">CLTS data</a>.</p>\n<p><a href=\"https://travis-ci.org/cldf-clts/pyclts\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c40abf85e1d1056c85a3fd0494d7846c7bc33c92/68747470733a2f2f7472617669732d63692e6f72672f636c64662d636c74732f7079636c74732e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/cldf-clts/pyclts\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e136ebf90067f661937cf57991dd7f438f1cd270/68747470733a2f2f636f6465636f762e696f2f67682f636c64662d636c74732f7079636c74732f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://pypi.org/project/pyclts\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e10fc1d290cc8d51a2e38c81832d634ed7a69913/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7079636c74732e737667\"></a></p>\n<p>This is an attempt to create a system that allows to translate and compare different phonetic transcription systems.</p>\n<h2>Install</h2>\n<p><code>pyclts</code> provides a Python API for <a href=\"https://github.com/cldf-clts/clts\" rel=\"nofollow\">CLTS data</a>.\nUsing <code>pyclts</code> requires this data to be available locally, either as repository\nclone, or as unzipped download of a <a href=\"https://github.com/cldf-clts/clts/releases\" rel=\"nofollow\">released version</a>.</p>\n<p>To install <code>pyclts</code> run</p>\n<pre><code>pip install pyclts\n</code></pre>\n<p>This will install the python API as well as a command line tool <code>clts</code>.\nBoth, require the location of the data as argument:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pyclts</span> <span class=\"kn\">import</span> <span class=\"n\">CLTS</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">clts</span> <span class=\"o\">=</span> <span class=\"n\">CLTS</span><span class=\"p\">(</span><span class=\"s1\">'PATH/TO/clts'</span><span class=\"p\">)</span>\n</pre>\n<p>or</p>\n<pre>clts --repos PATH/TO/clts stats\n</pre>\n<p>To save this effort, the data location can also be looked up in a <a href=\"https://github.com/cldf/cldfcatalog/#configuration\" rel=\"nofollow\"><code>cldfcatalog</code> config file</a>, under the key <code>clts</code>.</p>\n<p>Such a config file (and the repository clone) can be created automatically,\nby installing <a href=\"https://pypi.org/cldfbench\" rel=\"nofollow\"><code>cldfbench</code></a> and running\n<code>cldfbench config</code>.</p>\n<h2>Overview</h2>\n<p>Using <code>pyclts</code> is exemplified in this short code snippet:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pyclts</span> <span class=\"kn\">import</span> <span class=\"n\">CLTS</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">clts</span> <span class=\"o\">=</span> <span class=\"n\">CLTS</span><span class=\"p\">(</span><span class=\"s1\">'clts/'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">asjp</span> <span class=\"o\">=</span> <span class=\"n\">clts</span><span class=\"o\">.</span><span class=\"n\">transcriptionsystem</span><span class=\"p\">(</span><span class=\"s1\">'asjpcode'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">snd1</span> <span class=\"o\">=</span> <span class=\"n\">clts</span><span class=\"o\">.</span><span class=\"n\">bipa</span><span class=\"p\">[</span><span class=\"s1\">'ts'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">snd2</span> <span class=\"o\">=</span> <span class=\"n\">asjp</span><span class=\"p\">[</span><span class=\"s1\">'c'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">snd1</span><span class=\"o\">.</span><span class=\"n\">name</span>\n<span class=\"s1\">'voiceless alveolar sibilant affricate consonant'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">snd2</span><span class=\"o\">.</span><span class=\"n\">name</span>\n<span class=\"s1\">'voiceless alveolar sibilant affricate consonant'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">clts</span><span class=\"o\">.</span><span class=\"n\">bipa</span><span class=\"o\">.</span><span class=\"n\">translate</span><span class=\"p\">(</span><span class=\"s1\">'ts a \u014b \u0259'</span><span class=\"p\">,</span> <span class=\"n\">asjp</span><span class=\"p\">)</span>\n<span class=\"s1\">'c E N 3'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">asjp</span><span class=\"o\">.</span><span class=\"n\">translate</span><span class=\"p\">(</span><span class=\"s1\">'C a y'</span><span class=\"p\">,</span> <span class=\"n\">clts</span><span class=\"o\">.</span><span class=\"n\">bipa</span><span class=\"p\">)</span>\n<span class=\"s1\">'t\u0283 \u0250 j'</span>\n</pre>\n<p>Notes:</p>\n<ul>\n<li>Since \"bipa\" is the standard transcriptionsystem in CLTS, it's available - as shortcut -\ndirectly as <code>bipa</code> attribute of <code>CLTS</code>.</li>\n<li>We represent the sounds <code>ts</code> and <code>c</code>, depending on the alphabet from which they are taken.</li>\n</ul>\n<h2>Sounds</h2>\n<p><code>pyclts</code> can not only deal with sound that are already in our database. Intead, We it tries to create \"unknown\" sounds automatically and infer its features from the set of diacritics and the base sound:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sound</span> <span class=\"o\">=</span> <span class=\"n\">clts</span><span class=\"o\">.</span><span class=\"n\">bipa</span><span class=\"p\">[</span><span class=\"s1\">'d\u02b1\u02b7'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sound</span><span class=\"o\">.</span><span class=\"n\">name</span>\n<span class=\"s1\">'labialized breathy voiced alveolar stop consonant'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sound</span><span class=\"o\">.</span><span class=\"n\">generated</span>\n<span class=\"kc\">True</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sound</span><span class=\"o\">.</span><span class=\"n\">alias</span>\n<span class=\"kc\">True</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">sound</span><span class=\"p\">)</span>\n<span class=\"n\">d\u02b7\u02b1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">sound</span><span class=\"o\">.</span><span class=\"n\">uname</span><span class=\"p\">)</span>\n<span class=\"n\">LATIN</span> <span class=\"n\">SMALL</span> <span class=\"n\">LETTER</span> <span class=\"n\">D</span> <span class=\"o\">/</span> <span class=\"n\">MODIFIER</span> <span class=\"n\">LETTER</span> <span class=\"n\">SMALL</span> <span class=\"n\">W</span> <span class=\"o\">/</span> <span class=\"n\">MODIFIER</span> <span class=\"n\">LETTER</span> <span class=\"n\">SMALL</span> <span class=\"n\">H</span> <span class=\"n\">WITH</span> <span class=\"n\">HOOK</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">sound</span><span class=\"o\">.</span><span class=\"n\">codepoints</span><span class=\"p\">)</span>\n<span class=\"n\">U</span><span class=\"o\">+</span><span class=\"mi\">0064</span> <span class=\"n\">U</span><span class=\"o\">+</span><span class=\"mi\">02</span><span class=\"n\">b7</span> <span class=\"n\">U</span><span class=\"o\">+</span><span class=\"mi\">02</span><span class=\"n\">b1</span>\n</pre>\n<p>You can see, since we represent breathy-voice phonation differently, we flag this sound as an alias. Also since it is not yet in our database explicitly coded, we flag it as a \"generated\" sound. In a similar way, you can generate sounds from their names:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sound</span> <span class=\"o\">=</span> <span class=\"n\">clts</span><span class=\"o\">.</span><span class=\"n\">bipa</span><span class=\"p\">[</span><span class=\"s1\">'pre-aspirated voiced aspirated bilabial stop consonant'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">sound</span><span class=\"p\">)</span>\n<span class=\"n\">\u02b0b\u02b0</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sound</span><span class=\"o\">.</span><span class=\"n\">generated</span>\n<span class=\"kc\">True</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sound</span><span class=\"o\">.</span><span class=\"n\">name</span>\n<span class=\"s1\">'pre-aspirated aspirated voiced bilabial stop consonant'</span>\n</pre>\n<p>Note that this sound probably does not exist in any language, but we generate it from the feature components. Note also that the <code>name</code> that is automatically given for the sound automatically orders how the features are put together to form the sound identifier. In principle, our features bundles are unordered, but we try to decide for some explicit order of features to enhance comparison.</p>\n<h2>Transcription systems and sound classes</h2>\n<p>You can also use our transcription data to convert from one transcription system to a given dataset (note that backwards-conversion may not be possible, as transcription data is often limited):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sca</span> <span class=\"o\">=</span> <span class=\"n\">clts</span><span class=\"o\">.</span><span class=\"n\">soundclass</span><span class=\"p\">(</span><span class=\"s1\">'sca'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">clts</span><span class=\"o\">.</span><span class=\"n\">bipa</span><span class=\"o\">.</span><span class=\"n\">translate</span><span class=\"p\">(</span><span class=\"s1\">'f a: t \u0259 r'</span><span class=\"p\">,</span> <span class=\"n\">sca</span><span class=\"p\">)</span>\n<span class=\"s1\">'B A T E R'</span>\n</pre>\n<p>The translation can also be done by loading the transcription data directly:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sca</span><span class=\"p\">(</span><span class=\"s1\">'v a t \u0259 r'</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"s1\">'A'</span><span class=\"p\">,</span> <span class=\"s1\">'T'</span><span class=\"p\">,</span> <span class=\"s1\">'E'</span><span class=\"p\">,</span> <span class=\"s1\">'R'</span><span class=\"p\">]</span>\n</pre>\n<h2>Basic Structure of the Package</h2>\n<p><code>pyclts</code> provides access to three basic types of data:</p>\n<ul>\n<li>transcription systems (<code>pyclts.transcriptionsystems.TranscriptionSystem</code>), a system that can <em>generate</em> sounds</li>\n<li>transcription data (<code>pyclts.transcriptiondata.TranscriptionData</code>): a dataset with a <em>fixed number of sounds</em></li>\n<li>sound classes (<code>pyclts.soundclasses.SoundClasses</code>): a dataset with a direct mapping from sounds to a concrete character (the sound class)</li>\n</ul>\n<p>Transcription data is linked to our transcription system by the grapheme for the B(road) IPA transcription system, which serves as our default, and the name, which follows the IPA conventions with some modifications which were needed to make sure that we can represent sounds that we regularly find in cross-linguistic datasets.</p>\n<h2>Parsing Procedure</h2>\n<table>\n<thead>\n<tr>\n<th>feature</th>\n<th>handled by</th>\n<th>note</th>\n<th>example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>normalized</td>\n<td><code>ts._norm()</code>, <code>ts[sound].normalized</code></td>\n<td>this refers to one-to-one character replacement with obviously wrong unicode lookalikes</td>\n<td><code>\u03bb</code> (wrong) vs. <code>\u028e</code> (correct)</td>\n</tr>\n<tr>\n<td>alias</td>\n<td>transcription system data (<code>+</code> indicates alias), <code>ts['sound'].alias</code></td>\n<td>this refers to \"free\" IPA variants that are widely used and are therefore officially accepted for \"broad ipa\" or any other TS, but one variant is usually chosen as the preferred one</td>\n<td><code>ts</code> (normal) vs. <code>\u02a6</code> (alias)</td>\n</tr>\n<tr>\n<td>source</td>\n<td><code>ts['sound'].source</code></td>\n<td>the unnormalized form as it is given to the TS</td>\n<td><code>bipa['\u03bb'].source == '\u03bb'</code></td>\n</tr>\n<tr>\n<td>grapheme</td>\n<td><code>ts[lingpy/'sound'].grapheme</code></td>\n<td>the normalized form which has not been resolved by an alias</td>\n<td>```bipa['\u02a6'].grapheme == '\u02a6'</td>\n</tr>\n<tr>\n<td>string/unicode</td>\n<td><code>ts['sound'].__unicode__()</code></td>\n<td>the normalized form in which a potential alias is replaced by its \"accepted\" counterpart</td>\n<td><code>str(bipa['\u02a6']) == 'ts'</code></td>\n</tr>\n<tr>\n<td>name</td>\n<td><code>bipa['sound'].name</code></td>\n<td>the canonical representation of the feature system that defines a sound, with the sound class (consonant, cluster, vowel, diphthong) in the end, and the feature bundle following the order given in the <code>pyclts.models</code> description of the corresponding sound class. This representation serves as the basis for translation among different TS.</td>\n<td><code>bipa['ts'].name == 'voiceless alveolar sibilant-affricate consonant'</code></td>\n</tr>\n<tr>\n<td>generated</td>\n<td><code>ts['sound'].generated</code></td>\n<td>If a sound is not yet know to a given TS, the algorithm tries to generate it by de-composing it into its <em>base part</em> and adding features to the left and to the right, based on the <em>diacritics</em>. If a sound has been generated, this is traced with help of the attribute. Normally, generated sounds need to be double-checked by the experts, as their grapheme representation may be erroneous. Thus, while the sound <code>k\u02b7\u02b0</code> can be regularly defined in a TS (like BIPA), a user might query <code>k\u02b0\u02b7</code>, in which case the sound would be generated internally, the grapheme would be stored in its normalized form (which is identical with the base), but the <code>str()</code>-representation would contain the correct order, and the character would be automatically qualified as an alias of an existing one.</td>\n<td><code>str(TS['k\u02b0\u02b7']) == 'k\u02b7\u02b0' and TS['k\u02b0\u02b7'].grapheme == 'k\u02b0\u02b7' and TS[''k\u02b0\u02b7'].alias and TS['k\u02b0\u02b7'].generated</code></td>\n</tr>\n<tr>\n<td>base</td>\n<td><code>ts['sound'].base</code></td>\n<td>if a sound is being generated, the parsing algorithm first tries to identify the potential \"base\" of the sound, i.e., a sound that is already known and explicitly defined in a given transcription system. Based on this base sound, the grapheme is then constructed by following the diacritics to the left and to the right. If the so-constructed feature bundle already exists in the transcription system, the constructed sound is treated as an alias, if it does not exist, the sound is only marked as being generated.</td>\n<td><code>str(TS['d\u0324\u02b7']) == 'd\u02b7\u02b1'</code></td>\n</tr></tbody></table>\n\n          </div>"}, "last_serial": 6008766, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "37808230e99378a17838cb853659c86d", "sha256": "5bc822e4ad420ede7f7f36f5c7a30e38caa7f8b8ae3330e156cc86be55283e6c"}, "downloads": -1, "filename": "pyclts-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "37808230e99378a17838cb853659c86d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 515920, "upload_time": "2018-04-30T08:04:17", "upload_time_iso_8601": "2018-04-30T08:04:17.771822Z", "url": "https://files.pythonhosted.org/packages/86/9c/8f7cad1566be84ac2d885c362a19b590071a2a4f97861c3ad43a06a698e9/pyclts-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "be9c834cf49ef3b38c18b85a00d3d1cb", "sha256": "87bdd112c8c57e36ec5e27e792fa6e2075aa33b7c29ba9581a852b8c91bbc6c2"}, "downloads": -1, "filename": "pyclts-0.1.0.tar.gz", "has_sig": false, "md5_digest": "be9c834cf49ef3b38c18b85a00d3d1cb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 575354, "upload_time": "2018-04-30T08:03:55", "upload_time_iso_8601": "2018-04-30T08:03:55.841453Z", "url": "https://files.pythonhosted.org/packages/3a/69/8656a58786a0809feb4e28338a1bd225c47fa933433908ff1a2ccddcf050/pyclts-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "d794b29b47e590b570ed887c145e6312", "sha256": "46b8dc6e160cd09280d17d12c096523bc9887e0cf6fae64c372caff221be3be9"}, "downloads": -1, "filename": "pyclts-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d794b29b47e590b570ed887c145e6312", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 519896, "upload_time": "2018-05-18T13:05:04", "upload_time_iso_8601": "2018-05-18T13:05:04.602447Z", "url": "https://files.pythonhosted.org/packages/74/fd/198bc71a09e5bda2de0d4a5c7c207ea95f25aaf91ca7b2049e090fc802ee/pyclts-0.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fb40660acaefa73c3a9c0ff5e2864c4b", "sha256": "634f680c8c143fb3a755f9ec072df1a131b8a260bb735701388867bb46f392d4"}, "downloads": -1, "filename": "pyclts-0.2.0.tar.gz", "has_sig": false, "md5_digest": "fb40660acaefa73c3a9c0ff5e2864c4b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 417319, "upload_time": "2018-05-18T13:04:39", "upload_time_iso_8601": "2018-05-18T13:04:39.320842Z", "url": "https://files.pythonhosted.org/packages/10/73/e77c9e835306d8976cf95bdb2bb340dd1707f174dae0016c2223c253c0f8/pyclts-0.2.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "03302cf8be440c1c291f783666831b7f", "sha256": "6b0992996c592b8680bbd68cd75e87453e83a5e645ca0f4a11f1a875d5a3a893"}, "downloads": -1, "filename": "pyclts-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "03302cf8be440c1c291f783666831b7f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 356427, "upload_time": "2018-11-28T07:49:39", "upload_time_iso_8601": "2018-11-28T07:49:39.328532Z", "url": "https://files.pythonhosted.org/packages/f8/d9/17ca9c9edfc773b696d016555f49279e6abef0261945ae83147fe67cf284/pyclts-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "069700676bd761db4cb4cd70a7b42149", "sha256": "5ecd8505a6ae6fa5fcfe588cf94633d784cd00f5fab52dbbc7c4341f56e1812c"}, "downloads": -1, "filename": "pyclts-1.0.0.tar.gz", "has_sig": false, "md5_digest": "069700676bd761db4cb4cd70a7b42149", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 420676, "upload_time": "2018-11-28T07:49:23", "upload_time_iso_8601": "2018-11-28T07:49:23.370786Z", "url": "https://files.pythonhosted.org/packages/97/e6/f25e38bb9e8d2ec48183633571e53e72b054f1f3f02e8294b4ac24ead40d/pyclts-1.0.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "a9a5534863e7b062c734225cae064d7c", "sha256": "2e251e71769f685be2203caeba3c5a5f1cc6bc3a179b1b28ffd643f73e6980fc"}, "downloads": -1, "filename": "pyclts-1.1.1.tar.gz", "has_sig": false, "md5_digest": "a9a5534863e7b062c734225cae064d7c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 423191, "upload_time": "2018-11-28T11:15:08", "upload_time_iso_8601": "2018-11-28T11:15:08.353412Z", "url": "https://files.pythonhosted.org/packages/6e/55/ebbec7b735d70e416a67419ea7955780efbe5f8d1754016303b0ca006754/pyclts-1.1.1.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "3aab00127dbed515109c3683fb566cfb", "sha256": "525daa24e27345ef4d9f8df28ba30bde95980c05882db3d10c2017b9c87b5e28"}, "downloads": -1, "filename": "pyclts-1.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "3aab00127dbed515109c3683fb566cfb", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 349521, "upload_time": "2019-04-03T07:46:37", "upload_time_iso_8601": "2019-04-03T07:46:37.403299Z", "url": "https://files.pythonhosted.org/packages/f9/eb/029023dd30f5a030a5c06b7fb6e13128e38c9f1dba94ecd6b43eef2eba69/pyclts-1.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "51f9032b225d972091e36ab389a65deb", "sha256": "0d0b3bd3aa4683ab8bdbbdf620e4a358d28ef2bdd3f2e8666bf09dead6d33604"}, "downloads": -1, "filename": "pyclts-1.2.0.tar.gz", "has_sig": false, "md5_digest": "51f9032b225d972091e36ab389a65deb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 413116, "upload_time": "2019-04-03T07:46:32", "upload_time_iso_8601": "2019-04-03T07:46:32.059845Z", "url": "https://files.pythonhosted.org/packages/4c/77/dee898d1c212e2c1e2647e5acf38c7ad9078c5fd89a5a362392667c24719/pyclts-1.2.0.tar.gz", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "0a45a6c5b8f86b75ae1de2b4b6c757d0", "sha256": "7b8f83d62786b9df4165024fe35e05a07c0545dc397df7c466ecdb0fcae4973f"}, "downloads": -1, "filename": "pyclts-1.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0a45a6c5b8f86b75ae1de2b4b6c757d0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 349304, "upload_time": "2019-09-18T16:18:53", "upload_time_iso_8601": "2019-09-18T16:18:53.061913Z", "url": "https://files.pythonhosted.org/packages/d6/bf/1ff7a86e4047231ccd268fd76b526749e15ec94a131f2065d87c43b753ec/pyclts-1.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "31a29ecc27703a55686a6cea91719e05", "sha256": "267dd6b741abd16fd613576af7c50dca7e72b10a4272d7d1127e8f66e0426a0b"}, "downloads": -1, "filename": "pyclts-1.3.0.tar.gz", "has_sig": false, "md5_digest": "31a29ecc27703a55686a6cea91719e05", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 413221, "upload_time": "2019-09-18T16:18:43", "upload_time_iso_8601": "2019-09-18T16:18:43.282615Z", "url": "https://files.pythonhosted.org/packages/48/72/b53f8f6388d7493673abb4c760aee795c63b558c9aaaa3c977e0a825375c/pyclts-1.3.0.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "8423cf5edffcf31c00ba56d4dfeb81ca", "sha256": "429ad7e45ce57e7f64622025788c5a4940506e330232ba6207d7c86fb88468be"}, "downloads": -1, "filename": "pyclts-2.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8423cf5edffcf31c00ba56d4dfeb81ca", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.5", "size": 40425, "upload_time": "2019-10-21T19:02:33", "upload_time_iso_8601": "2019-10-21T19:02:33.243968Z", "url": "https://files.pythonhosted.org/packages/e1/05/37aaf980452e9e1dbab5d7f25a40eb72a15d09d560449cbc0cec29abad68/pyclts-2.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "078af21b663e72de4c6d3ac7573d984e", "sha256": "79481f04ba0cb8c5360475657f0bcc37e6077e76f9fa91516b86dce658543447"}, "downloads": -1, "filename": "pyclts-2.0.0.tar.gz", "has_sig": false, "md5_digest": "078af21b663e72de4c6d3ac7573d984e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 35023, "upload_time": "2019-10-21T19:01:56", "upload_time_iso_8601": "2019-10-21T19:01:56.317106Z", "url": "https://files.pythonhosted.org/packages/fc/9a/42a9b4fd45f038ffb7fd9c622dba0f509adb5dce54ce6b5d6b50a9d87337/pyclts-2.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8423cf5edffcf31c00ba56d4dfeb81ca", "sha256": "429ad7e45ce57e7f64622025788c5a4940506e330232ba6207d7c86fb88468be"}, "downloads": -1, "filename": "pyclts-2.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8423cf5edffcf31c00ba56d4dfeb81ca", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.5", "size": 40425, "upload_time": "2019-10-21T19:02:33", "upload_time_iso_8601": "2019-10-21T19:02:33.243968Z", "url": "https://files.pythonhosted.org/packages/e1/05/37aaf980452e9e1dbab5d7f25a40eb72a15d09d560449cbc0cec29abad68/pyclts-2.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "078af21b663e72de4c6d3ac7573d984e", "sha256": "79481f04ba0cb8c5360475657f0bcc37e6077e76f9fa91516b86dce658543447"}, "downloads": -1, "filename": "pyclts-2.0.0.tar.gz", "has_sig": false, "md5_digest": "078af21b663e72de4c6d3ac7573d984e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 35023, "upload_time": "2019-10-21T19:01:56", "upload_time_iso_8601": "2019-10-21T19:01:56.317106Z", "url": "https://files.pythonhosted.org/packages/fc/9a/42a9b4fd45f038ffb7fd9c622dba0f509adb5dce54ce6b5d6b50a9d87337/pyclts-2.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:08:21 2020"}