{"info": {"author": "Josuah ARON", "author_email": "josuah.aron@cogitans.fr", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: Dynamic Content"], "description": "# graphene-chain-mutation\n\nProvide feature to allow chaining mutations using [Graphene-python](https://docs.graphene-python.org/en/latest/quickstart/)\n\nI created this package after [a question I asked on Stackoverflow](https://stackoverflow.com/questions/61340137/graphene-graphql-how-to-chain-mutations/) and that I had to solve by myself in the end.\n\n`graphene-chain-mutation` allow to create edge-like mutations that can reference the results of previous mutations in the same query.\n\n## Why this package ?\n\n### The requirement\n\nBasically, when want to be able to create an object and reference it in the same query. We can use nested mutations at some extend, but it have been pointed ([here](https://www.freecodecamp.org/news/organizing-graphql-mutations-653306699f3d/) and [there](https://github.com/graphql-python/graphene/issues/944#issuecomment-492462389)) that nested mutation are not guaranteed to be sequential. So if we consider a query using nesting, like the following:\n\n```graphql\nmutation ($parent: ParentInput, $child1: ChildInput, $child2: ChildInput) {\n    n1: upsertChild(data: $child1) {\n        pk\n        name\n        siblings { pk name }\n        \n        parent: createParent(data: $parent) { pk name }\n        \n        newSibling: createSibling(data: $child2) { pk name }\n        \n        # we cannot set the parent of the new sibling in this query\n        # because order is not guaranted for nested mutations\n    }\n}\n```\n\nWe see that we cannot set the parent of the new sibling because the latter may be created before the parent.\n\nSo we want to use only root query, and maybe be able to make queries such as:\n\n```graphql\nmutation ($parent: ParentInput, $child1: ChildInput, $child2: ChildInput) {\n    n1: upsertParent(data: $parent) {\n        pk\n        name\n    }\n    \n    n2: upsertChild(data: $child1) {\n        pk\n        name\n    }\n    \n    n3: upsertChild(data: $child2) {\n        pk\n        name\n    }\n    \n    e1: setParent(parent: \"n1\", child: \"n2\") { ok }\n    \n    e2: setParent(parent: \"n1\", child: \"n3\") { ok }\n    \n    e3: addSibling(node1: \"n2\", node2: \"n3\") { ok }\n}\n```\n\nWhere e1, e2 and e3 reference results of previous mutations.\n\n### The problem\n\nUnfortunately, referencing results of previous mutations is not part of the GraphQL specification.\n\nIn my opinion, this is an important feature for graph languages. We can compare this syntax with the Graphviz dot language, were could write for example:\n\n```dot\ndigraph D {\n\n  /* Nodes */\n  A \n  B\n  C\n\n  /* Edges */\n\n  A -> B\n  A -> C\n  A -> D\n\n}\n```\n\nThe feature we need is simply allowing _edge-like_ operations using _nodes_ from the same mutations.\n\n### A solution\n\nThis package provide:\n\n1. A [Graphene middleware](https://docs.graphene-python.org/en/latest/execution/middleware/) that, if used, will inject a `dict` in your root resolvers so that they can _\"share their results\"_ if needed.\n2. A mutation class that will automatically _\"share its results\"_ using the `dict` injected by the middleware.\n3. 2 base edge mutation classes, to accept GraphQL alias as input argument to retrieve the results of previous mutations in the same query.\n\n## Usage\n\n5 steps (See the [test/fake.py module](https://github.com/shinhermit/graphene-chain-mutation/blob/master/tests/fake.py) for an executable example).\n\n1. Install the package (requires [graphene](https://pypi.org/project/graphene/))\n   ```bash\n   pip install graphene-chain-mutation\n   ```\n2. Write _node-like_ mutations by inheriting `ShareResult` _before_ `graphene.Muation`:\n   ```python\n    import graphene\n    from graphene_chain_mutation import ShareResult\n    from .types import ParentType, ParentInput, ChildType, ChildInput\n   \n    class CreateParent(ShareResult, graphene.Mutation, ParentType):\n        class Arguments:\n            data = ParentInput()\n    \n        @staticmethod\n        def mutate(_: None, __: graphene.ResolveInfo,\n                   data: ParentInput = None) -> 'CreateParent':\n            return CreateParent(**data.__dict__)\n    \n    class CreateChild(ShareResult, graphene.Mutation, ChildType):\n        class Arguments:\n            data = ChildInput()\n    \n        @staticmethod\n        def mutate(_: None, __: graphene.ResolveInfo,\n                   data: ChildInput = None) -> 'CreateChild':\n            return CreateChild(**data.__dict__)\n   ```\n3. Create _edge-like_ mutations by inheriting either `ParentChildEdgeMutation` (for FK relationships) or `SiblingEdgeMutation` (for m2m relationships). Specify the type of their input nodes and implement the `set_link` method:\n   ```python\n    import graphene\n    from graphene_chain_mutation import ParentChildEdgeMutation, SiblingEdgeMutation\n    from .types import ParentType, ChildType\n    from .fake_models import FakeChildDB\n    \n    class SetParent(ParentChildEdgeMutation):\n\n        parent_type = ParentType\n        child_type = ChildType\n\n        @classmethod\n        def set_link(cls, parent: ParentType, child: ChildType):\n            FakeChildDB[child.pk].parent = parent.pk\n\n    class AddSibling(SiblingEdgeMutation):\n\n        node1_type = ChildType\n        node2_type = ChildType\n\n        @classmethod\n        def set_link(cls, node1: ChildType, node2: ChildType):\n            FakeChildDB[node1.pk].siblings.append(node2.pk)\n            FakeChildDB[node2.pk].siblings.append(node1.pk)\n   ```\n4. Create your schema as usual\n   ```python\n    class Query(graphene.ObjectType):\n        parent = graphene.Field(ParentType, pk=graphene.Int())\n        parents = graphene.List(ParentType)\n        child = graphene.Field(ChildType, pk=graphene.Int())\n        children = graphene.List(ChildType)\n\n    class Mutation(graphene.ObjectType):\n        create_parent = CreateParent.Field()\n        create_child = CreateChild.Field()\n        set_parent = SetParent.Field()\n        add_sibling = AddSibling.Field()\n\n    schema = graphene.Schema(query=Query, mutation=Mutation)\n   ```\n5. Specify the `ShareResultMiddleware` middleware while executing a query:\n   ```python\n    result = schema.execute(\n        GRAPHQL_MUTATION\n        ,variables = VARIABLES\n        ,middleware=[ShareResultMiddleware()]\n    )\n   ```\n\nNow `GRAPHQL_MUTATION` can be a query where edge-like mutation reference the results of node-like mutations:\n\n```python\nGRAPHQL_MUTATION = \"\"\"\nmutation ($parent: ParentInput, $child1: ChildInput, $child2: ChildInput) {\n    n1: createParent(data: $parent) {\n        pk\n        name\n    }\n    \n    n2: createChild(data: $child1) {\n        pk\n        name\n    }\n    \n    n3: createChild(data: $child2) {\n        pk\n        name\n    }\n    \n    e1: setParent(parent: \"n1\", child: \"n2\") { ok }\n    \n    e2: setParent(parent: \"n1\", child: \"n3\") { ok }\n    \n    e3: addSibling(node1: \"n2\", node2: \"n3\") { ok }\n}\n\"\"\"\n\nVARIABLES = dict(\n    parent = dict(\n        name = \"Emilie\"\n    )\n    ,child1 = dict(\n        name = \"John\"\n    )\n    ,child2 = dict(\n        name = \"Julie\"\n    )\n)\n```\n\n### Nesting with inline reference\n\nWe can use the referencing capability offered by `ShareResultMiddleware` to reference the result of a root mutation in a nested mutation (that uses a resolver).\n\nExample:\n\n```python\nimport graphene\nfrom graphene import ObjectType\nfrom graphene_chain_mutation import ShareResult\nfrom .types import ParentType, ParentInput, ChildType, ChildInput\n\n\nclass CreateParent(ShareResult, graphene.Mutation, ParentType):\n    class Arguments:\n        data = ParentInput()\n\n    @staticmethod\n    def mutate(_: None, __: graphene.ResolveInfo,\n               data: ParentInput = None) -> 'CreateParent':\n        return CreateParent(**data.__dict__)\n\n\nclass CreateChild(ShareResult, graphene.Mutation, ChildType):\n    class Arguments:\n        data = types.ChildInput()\n\n    ref_parent = graphene.Field(types.ParentType, ref=graphene.String())\n    \"\"\"Resolving this field sets a reference to parent from previous mutation result.\"\"\"\n\n    @staticmethod\n    def mutate(_: None, info: ResolveInfo,\n               data: types.ChildInput) -> 'CreateChild':\n        return UpdateChild(**data.__dict__)\n\n    @staticmethod\n    def resolve_ref_parent(child: 'CreateChild', _: graphene.ResolveInfo,\n                           shared_results: Dict[str, ObjectType] = None,\n                           ref: str = None):\n        \"\"\"\n        Nesting mutation by resolving a field and setting the parent of\n        this child by referencing the result of another mutation in\n        the same query.\n\n        :param child: result of the parent mutation (mutate method of this class)\n        :param _: graphene resolve info.\n        :param shared_results: result dict injected by the SharedResultMiddleware.\n        :param ref: name of the node of the PArent mutation in the query.\n        :return: the referenced parent.\n        \"\"\"\n        assert ref is not None\n        assert shared_results is not None\n        parent = shared_results.get(ref)\n        assert parent is not None\n        FakeChildDB[child.pk].parent = parent.pk\n        return parent\n```\n\nWe can resolve a query like:\n\n```graphql\nmutation ($parent: ParentInput, $child1: ChildInput, $child2: ChildInput) {\n    n1: createParent(data: $parent) {\n        pk\n        name\n    }\n    \n    n2: createChild(data: $child1) {\n        pk\n        name\n        parent: refParent(ref: \"n1\") {\n          pk\n          name\n        }\n    }\n    \n    n3: createChild(data: $child2) {\n        pk\n        name\n        parent: refParent(ref: \"n1\") {\n          pk\n          name\n        }\n    }\n}\n\n```\n\nNow keep in mind, as stated at the begining of this Readme, that nested mutation may have unpredictable results due to race condition. This is because, we recall, the order of execution of nested mutation is not guaranteed.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/shinhermit/graphene-chain-mutation", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "graphene-chain-mutation", "package_url": "https://pypi.org/project/graphene-chain-mutation/", "platform": "", "project_url": "https://pypi.org/project/graphene-chain-mutation/", "project_urls": {"Homepage": "https://github.com/shinhermit/graphene-chain-mutation"}, "release_url": "https://pypi.org/project/graphene-chain-mutation/1.0.3/", "requires_dist": null, "requires_python": "", "summary": "Provide feature to reference previous mutations results in chained mutations.", "version": "1.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>graphene-chain-mutation</h1>\n<p>Provide feature to allow chaining mutations using <a href=\"https://docs.graphene-python.org/en/latest/quickstart/\" rel=\"nofollow\">Graphene-python</a></p>\n<p>I created this package after <a href=\"https://stackoverflow.com/questions/61340137/graphene-graphql-how-to-chain-mutations/\" rel=\"nofollow\">a question I asked on Stackoverflow</a> and that I had to solve by myself in the end.</p>\n<p><code>graphene-chain-mutation</code> allow to create edge-like mutations that can reference the results of previous mutations in the same query.</p>\n<h2>Why this package ?</h2>\n<h3>The requirement</h3>\n<p>Basically, when want to be able to create an object and reference it in the same query. We can use nested mutations at some extend, but it have been pointed (<a href=\"https://www.freecodecamp.org/news/organizing-graphql-mutations-653306699f3d/\" rel=\"nofollow\">here</a> and <a href=\"https://github.com/graphql-python/graphene/issues/944#issuecomment-492462389\" rel=\"nofollow\">there</a>) that nested mutation are not guaranteed to be sequential. So if we consider a query using nesting, like the following:</p>\n<pre>mutation ($parent: ParentInput, $child1: ChildInput, $child2: ChildInput) {\n    n1: upsertChild(data: $child1) {\n        pk\n        name\n        siblings { pk name }\n        \n        parent: createParent(data: $parent) { pk name }\n        \n        newSibling: createSibling(data: $child2) { pk name }\n        \n        # we cannot set the parent of the new sibling in this query\n        # because order is not guaranted for nested mutations\n    }\n}\n</pre>\n<p>We see that we cannot set the parent of the new sibling because the latter may be created before the parent.</p>\n<p>So we want to use only root query, and maybe be able to make queries such as:</p>\n<pre>mutation ($parent: ParentInput, $child1: ChildInput, $child2: ChildInput) {\n    n1: upsertParent(data: $parent) {\n        pk\n        name\n    }\n    \n    n2: upsertChild(data: $child1) {\n        pk\n        name\n    }\n    \n    n3: upsertChild(data: $child2) {\n        pk\n        name\n    }\n    \n    e1: setParent(parent: \"n1\", child: \"n2\") { ok }\n    \n    e2: setParent(parent: \"n1\", child: \"n3\") { ok }\n    \n    e3: addSibling(node1: \"n2\", node2: \"n3\") { ok }\n}\n</pre>\n<p>Where e1, e2 and e3 reference results of previous mutations.</p>\n<h3>The problem</h3>\n<p>Unfortunately, referencing results of previous mutations is not part of the GraphQL specification.</p>\n<p>In my opinion, this is an important feature for graph languages. We can compare this syntax with the Graphviz dot language, were could write for example:</p>\n<pre>digraph D {\n\n  /* Nodes */\n  A \n  B\n  C\n\n  /* Edges */\n\n  A -&gt; B\n  A -&gt; C\n  A -&gt; D\n\n}\n</pre>\n<p>The feature we need is simply allowing <em>edge-like</em> operations using <em>nodes</em> from the same mutations.</p>\n<h3>A solution</h3>\n<p>This package provide:</p>\n<ol>\n<li>A <a href=\"https://docs.graphene-python.org/en/latest/execution/middleware/\" rel=\"nofollow\">Graphene middleware</a> that, if used, will inject a <code>dict</code> in your root resolvers so that they can <em>\"share their results\"</em> if needed.</li>\n<li>A mutation class that will automatically <em>\"share its results\"</em> using the <code>dict</code> injected by the middleware.</li>\n<li>2 base edge mutation classes, to accept GraphQL alias as input argument to retrieve the results of previous mutations in the same query.</li>\n</ol>\n<h2>Usage</h2>\n<p>5 steps (See the <a href=\"https://github.com/shinhermit/graphene-chain-mutation/blob/master/tests/fake.py\" rel=\"nofollow\">test/fake.py module</a> for an executable example).</p>\n<ol>\n<li>Install the package (requires <a href=\"https://pypi.org/project/graphene/\" rel=\"nofollow\">graphene</a>)\n<pre>pip install graphene-chain-mutation\n</pre>\n</li>\n<li>Write <em>node-like</em> mutations by inheriting <code>ShareResult</code> <em>before</em> <code>graphene.Muation</code>:\n<pre> <span class=\"kn\">import</span> <span class=\"nn\">graphene</span>\n <span class=\"kn\">from</span> <span class=\"nn\">graphene_chain_mutation</span> <span class=\"kn\">import</span> <span class=\"n\">ShareResult</span>\n <span class=\"kn\">from</span> <span class=\"nn\">.types</span> <span class=\"kn\">import</span> <span class=\"n\">ParentType</span><span class=\"p\">,</span> <span class=\"n\">ParentInput</span><span class=\"p\">,</span> <span class=\"n\">ChildType</span><span class=\"p\">,</span> <span class=\"n\">ChildInput</span>\n\n <span class=\"k\">class</span> <span class=\"nc\">CreateParent</span><span class=\"p\">(</span><span class=\"n\">ShareResult</span><span class=\"p\">,</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Mutation</span><span class=\"p\">,</span> <span class=\"n\">ParentType</span><span class=\"p\">):</span>\n     <span class=\"k\">class</span> <span class=\"nc\">Arguments</span><span class=\"p\">:</span>\n         <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">ParentInput</span><span class=\"p\">()</span>\n \n     <span class=\"nd\">@staticmethod</span>\n     <span class=\"k\">def</span> <span class=\"nf\">mutate</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">__</span><span class=\"p\">:</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">ResolveInfo</span><span class=\"p\">,</span>\n                <span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">ParentInput</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">'CreateParent'</span><span class=\"p\">:</span>\n         <span class=\"k\">return</span> <span class=\"n\">CreateParent</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">)</span>\n \n <span class=\"k\">class</span> <span class=\"nc\">CreateChild</span><span class=\"p\">(</span><span class=\"n\">ShareResult</span><span class=\"p\">,</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Mutation</span><span class=\"p\">,</span> <span class=\"n\">ChildType</span><span class=\"p\">):</span>\n     <span class=\"k\">class</span> <span class=\"nc\">Arguments</span><span class=\"p\">:</span>\n         <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">ChildInput</span><span class=\"p\">()</span>\n \n     <span class=\"nd\">@staticmethod</span>\n     <span class=\"k\">def</span> <span class=\"nf\">mutate</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">__</span><span class=\"p\">:</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">ResolveInfo</span><span class=\"p\">,</span>\n                <span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">ChildInput</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">'CreateChild'</span><span class=\"p\">:</span>\n         <span class=\"k\">return</span> <span class=\"n\">CreateChild</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">)</span>\n</pre>\n</li>\n<li>Create <em>edge-like</em> mutations by inheriting either <code>ParentChildEdgeMutation</code> (for FK relationships) or <code>SiblingEdgeMutation</code> (for m2m relationships). Specify the type of their input nodes and implement the <code>set_link</code> method:\n<pre> <span class=\"kn\">import</span> <span class=\"nn\">graphene</span>\n <span class=\"kn\">from</span> <span class=\"nn\">graphene_chain_mutation</span> <span class=\"kn\">import</span> <span class=\"n\">ParentChildEdgeMutation</span><span class=\"p\">,</span> <span class=\"n\">SiblingEdgeMutation</span>\n <span class=\"kn\">from</span> <span class=\"nn\">.types</span> <span class=\"kn\">import</span> <span class=\"n\">ParentType</span><span class=\"p\">,</span> <span class=\"n\">ChildType</span>\n <span class=\"kn\">from</span> <span class=\"nn\">.fake_models</span> <span class=\"kn\">import</span> <span class=\"n\">FakeChildDB</span>\n \n <span class=\"k\">class</span> <span class=\"nc\">SetParent</span><span class=\"p\">(</span><span class=\"n\">ParentChildEdgeMutation</span><span class=\"p\">):</span>\n\n     <span class=\"n\">parent_type</span> <span class=\"o\">=</span> <span class=\"n\">ParentType</span>\n     <span class=\"n\">child_type</span> <span class=\"o\">=</span> <span class=\"n\">ChildType</span>\n\n     <span class=\"nd\">@classmethod</span>\n     <span class=\"k\">def</span> <span class=\"nf\">set_link</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">parent</span><span class=\"p\">:</span> <span class=\"n\">ParentType</span><span class=\"p\">,</span> <span class=\"n\">child</span><span class=\"p\">:</span> <span class=\"n\">ChildType</span><span class=\"p\">):</span>\n         <span class=\"n\">FakeChildDB</span><span class=\"p\">[</span><span class=\"n\">child</span><span class=\"o\">.</span><span class=\"n\">pk</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">parent</span><span class=\"o\">.</span><span class=\"n\">pk</span>\n\n <span class=\"k\">class</span> <span class=\"nc\">AddSibling</span><span class=\"p\">(</span><span class=\"n\">SiblingEdgeMutation</span><span class=\"p\">):</span>\n\n     <span class=\"n\">node1_type</span> <span class=\"o\">=</span> <span class=\"n\">ChildType</span>\n     <span class=\"n\">node2_type</span> <span class=\"o\">=</span> <span class=\"n\">ChildType</span>\n\n     <span class=\"nd\">@classmethod</span>\n     <span class=\"k\">def</span> <span class=\"nf\">set_link</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">node1</span><span class=\"p\">:</span> <span class=\"n\">ChildType</span><span class=\"p\">,</span> <span class=\"n\">node2</span><span class=\"p\">:</span> <span class=\"n\">ChildType</span><span class=\"p\">):</span>\n         <span class=\"n\">FakeChildDB</span><span class=\"p\">[</span><span class=\"n\">node1</span><span class=\"o\">.</span><span class=\"n\">pk</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">siblings</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">node2</span><span class=\"o\">.</span><span class=\"n\">pk</span><span class=\"p\">)</span>\n         <span class=\"n\">FakeChildDB</span><span class=\"p\">[</span><span class=\"n\">node2</span><span class=\"o\">.</span><span class=\"n\">pk</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">siblings</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">node1</span><span class=\"o\">.</span><span class=\"n\">pk</span><span class=\"p\">)</span>\n</pre>\n</li>\n<li>Create your schema as usual\n<pre> <span class=\"k\">class</span> <span class=\"nc\">Query</span><span class=\"p\">(</span><span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">ObjectType</span><span class=\"p\">):</span>\n     <span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Field</span><span class=\"p\">(</span><span class=\"n\">ParentType</span><span class=\"p\">,</span> <span class=\"n\">pk</span><span class=\"o\">=</span><span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Int</span><span class=\"p\">())</span>\n     <span class=\"n\">parents</span> <span class=\"o\">=</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">ParentType</span><span class=\"p\">)</span>\n     <span class=\"n\">child</span> <span class=\"o\">=</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Field</span><span class=\"p\">(</span><span class=\"n\">ChildType</span><span class=\"p\">,</span> <span class=\"n\">pk</span><span class=\"o\">=</span><span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Int</span><span class=\"p\">())</span>\n     <span class=\"n\">children</span> <span class=\"o\">=</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">ChildType</span><span class=\"p\">)</span>\n\n <span class=\"k\">class</span> <span class=\"nc\">Mutation</span><span class=\"p\">(</span><span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">ObjectType</span><span class=\"p\">):</span>\n     <span class=\"n\">create_parent</span> <span class=\"o\">=</span> <span class=\"n\">CreateParent</span><span class=\"o\">.</span><span class=\"n\">Field</span><span class=\"p\">()</span>\n     <span class=\"n\">create_child</span> <span class=\"o\">=</span> <span class=\"n\">CreateChild</span><span class=\"o\">.</span><span class=\"n\">Field</span><span class=\"p\">()</span>\n     <span class=\"n\">set_parent</span> <span class=\"o\">=</span> <span class=\"n\">SetParent</span><span class=\"o\">.</span><span class=\"n\">Field</span><span class=\"p\">()</span>\n     <span class=\"n\">add_sibling</span> <span class=\"o\">=</span> <span class=\"n\">AddSibling</span><span class=\"o\">.</span><span class=\"n\">Field</span><span class=\"p\">()</span>\n\n <span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Schema</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"o\">=</span><span class=\"n\">Query</span><span class=\"p\">,</span> <span class=\"n\">mutation</span><span class=\"o\">=</span><span class=\"n\">Mutation</span><span class=\"p\">)</span>\n</pre>\n</li>\n<li>Specify the <code>ShareResultMiddleware</code> middleware while executing a query:\n<pre> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">schema</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span>\n     <span class=\"n\">GRAPHQL_MUTATION</span>\n     <span class=\"p\">,</span><span class=\"n\">variables</span> <span class=\"o\">=</span> <span class=\"n\">VARIABLES</span>\n     <span class=\"p\">,</span><span class=\"n\">middleware</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">ShareResultMiddleware</span><span class=\"p\">()]</span>\n <span class=\"p\">)</span>\n</pre>\n</li>\n</ol>\n<p>Now <code>GRAPHQL_MUTATION</code> can be a query where edge-like mutation reference the results of node-like mutations:</p>\n<pre><span class=\"n\">GRAPHQL_MUTATION</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">mutation ($parent: ParentInput, $child1: ChildInput, $child2: ChildInput) {</span>\n<span class=\"s2\">    n1: createParent(data: $parent) {</span>\n<span class=\"s2\">        pk</span>\n<span class=\"s2\">        name</span>\n<span class=\"s2\">    }</span>\n<span class=\"s2\">    </span>\n<span class=\"s2\">    n2: createChild(data: $child1) {</span>\n<span class=\"s2\">        pk</span>\n<span class=\"s2\">        name</span>\n<span class=\"s2\">    }</span>\n<span class=\"s2\">    </span>\n<span class=\"s2\">    n3: createChild(data: $child2) {</span>\n<span class=\"s2\">        pk</span>\n<span class=\"s2\">        name</span>\n<span class=\"s2\">    }</span>\n<span class=\"s2\">    </span>\n<span class=\"s2\">    e1: setParent(parent: \"n1\", child: \"n2\") { ok }</span>\n<span class=\"s2\">    </span>\n<span class=\"s2\">    e2: setParent(parent: \"n1\", child: \"n3\") { ok }</span>\n<span class=\"s2\">    </span>\n<span class=\"s2\">    e3: addSibling(node1: \"n2\", node2: \"n3\") { ok }</span>\n<span class=\"s2\">}</span>\n<span class=\"s2\">\"\"\"</span>\n\n<span class=\"n\">VARIABLES</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span>\n    <span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span>\n        <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s2\">\"Emilie\"</span>\n    <span class=\"p\">)</span>\n    <span class=\"p\">,</span><span class=\"n\">child1</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span>\n        <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s2\">\"John\"</span>\n    <span class=\"p\">)</span>\n    <span class=\"p\">,</span><span class=\"n\">child2</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span>\n        <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s2\">\"Julie\"</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</pre>\n<h3>Nesting with inline reference</h3>\n<p>We can use the referencing capability offered by <code>ShareResultMiddleware</code> to reference the result of a root mutation in a nested mutation (that uses a resolver).</p>\n<p>Example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">graphene</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphene</span> <span class=\"kn\">import</span> <span class=\"n\">ObjectType</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphene_chain_mutation</span> <span class=\"kn\">import</span> <span class=\"n\">ShareResult</span>\n<span class=\"kn\">from</span> <span class=\"nn\">.types</span> <span class=\"kn\">import</span> <span class=\"n\">ParentType</span><span class=\"p\">,</span> <span class=\"n\">ParentInput</span><span class=\"p\">,</span> <span class=\"n\">ChildType</span><span class=\"p\">,</span> <span class=\"n\">ChildInput</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">CreateParent</span><span class=\"p\">(</span><span class=\"n\">ShareResult</span><span class=\"p\">,</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Mutation</span><span class=\"p\">,</span> <span class=\"n\">ParentType</span><span class=\"p\">):</span>\n    <span class=\"k\">class</span> <span class=\"nc\">Arguments</span><span class=\"p\">:</span>\n        <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">ParentInput</span><span class=\"p\">()</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">mutate</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">__</span><span class=\"p\">:</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">ResolveInfo</span><span class=\"p\">,</span>\n               <span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">ParentInput</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">'CreateParent'</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">CreateParent</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">CreateChild</span><span class=\"p\">(</span><span class=\"n\">ShareResult</span><span class=\"p\">,</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Mutation</span><span class=\"p\">,</span> <span class=\"n\">ChildType</span><span class=\"p\">):</span>\n    <span class=\"k\">class</span> <span class=\"nc\">Arguments</span><span class=\"p\">:</span>\n        <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">ChildInput</span><span class=\"p\">()</span>\n\n    <span class=\"n\">ref_parent</span> <span class=\"o\">=</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">Field</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">ParentType</span><span class=\"p\">,</span> <span class=\"n\">ref</span><span class=\"o\">=</span><span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">String</span><span class=\"p\">())</span>\n    <span class=\"sd\">\"\"\"Resolving this field sets a reference to parent from previous mutation result.\"\"\"</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">mutate</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">info</span><span class=\"p\">:</span> <span class=\"n\">ResolveInfo</span><span class=\"p\">,</span>\n               <span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">ChildInput</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">'CreateChild'</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">UpdateChild</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">resolve_ref_parent</span><span class=\"p\">(</span><span class=\"n\">child</span><span class=\"p\">:</span> <span class=\"s1\">'CreateChild'</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">:</span> <span class=\"n\">graphene</span><span class=\"o\">.</span><span class=\"n\">ResolveInfo</span><span class=\"p\">,</span>\n                           <span class=\"n\">shared_results</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">ObjectType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                           <span class=\"n\">ref</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Nesting mutation by resolving a field and setting the parent of</span>\n<span class=\"sd\">        this child by referencing the result of another mutation in</span>\n<span class=\"sd\">        the same query.</span>\n\n<span class=\"sd\">        :param child: result of the parent mutation (mutate method of this class)</span>\n<span class=\"sd\">        :param _: graphene resolve info.</span>\n<span class=\"sd\">        :param shared_results: result dict injected by the SharedResultMiddleware.</span>\n<span class=\"sd\">        :param ref: name of the node of the PArent mutation in the query.</span>\n<span class=\"sd\">        :return: the referenced parent.</span>\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"k\">assert</span> <span class=\"n\">ref</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span>\n        <span class=\"k\">assert</span> <span class=\"n\">shared_results</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span>\n        <span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">shared_results</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">ref</span><span class=\"p\">)</span>\n        <span class=\"k\">assert</span> <span class=\"n\">parent</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span>\n        <span class=\"n\">FakeChildDB</span><span class=\"p\">[</span><span class=\"n\">child</span><span class=\"o\">.</span><span class=\"n\">pk</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">parent</span><span class=\"o\">.</span><span class=\"n\">pk</span>\n        <span class=\"k\">return</span> <span class=\"n\">parent</span>\n</pre>\n<p>We can resolve a query like:</p>\n<pre>mutation ($parent: ParentInput, $child1: ChildInput, $child2: ChildInput) {\n    n1: createParent(data: $parent) {\n        pk\n        name\n    }\n    \n    n2: createChild(data: $child1) {\n        pk\n        name\n        parent: refParent(ref: \"n1\") {\n          pk\n          name\n        }\n    }\n    \n    n3: createChild(data: $child2) {\n        pk\n        name\n        parent: refParent(ref: \"n1\") {\n          pk\n          name\n        }\n    }\n}\n</pre>\n<p>Now keep in mind, as stated at the begining of this Readme, that nested mutation may have unpredictable results due to race condition. This is because, we recall, the order of execution of nested mutation is not guaranteed.</p>\n\n          </div>"}, "last_serial": 7165507, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "df9f71e1a78c7893a73b7cbc4407ce85", "sha256": "7d365c4c56cda6ff8c4fbadee7f29306e4fe6d403210f87f4c4df225f4269811"}, "downloads": -1, "filename": "graphene-chain-mutation-0.0.2.tar.gz", "has_sig": false, "md5_digest": "df9f71e1a78c7893a73b7cbc4407ce85", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6495, "upload_time": "2020-04-25T18:07:15", "upload_time_iso_8601": "2020-04-25T18:07:15.596837Z", "url": "https://files.pythonhosted.org/packages/c6/3b/52ce76119fb0fa19ae10c9a1b665dd9e62742a8f37d8aabc74db0a284a1d/graphene-chain-mutation-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "9e8eed05e95022cc58cdb242380c0fc1", "sha256": "ad4c3be70fa96f80aba14d99cfbe6e46745f4944a13cf4375c742dd5caaa5ebe"}, "downloads": -1, "filename": "graphene-chain-mutation-0.0.3.tar.gz", "has_sig": false, "md5_digest": "9e8eed05e95022cc58cdb242380c0fc1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6523, "upload_time": "2020-04-25T19:05:18", "upload_time_iso_8601": "2020-04-25T19:05:18.542078Z", "url": "https://files.pythonhosted.org/packages/12/6d/0d8d41a0c88c50349d3f02959a8526c2939d169e74e606dc72478274d1ea/graphene-chain-mutation-0.0.3.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "561baf36581e6da3989d7f26c9d6f28e", "sha256": "1fa859497e605c70e4e1cdcc9893eb438262d099bf7accad84e6997be8afcb05"}, "downloads": -1, "filename": "graphene-chain-mutation-1.0.0.tar.gz", "has_sig": false, "md5_digest": "561baf36581e6da3989d7f26c9d6f28e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9006, "upload_time": "2020-04-26T10:48:54", "upload_time_iso_8601": "2020-04-26T10:48:54.391974Z", "url": "https://files.pythonhosted.org/packages/c2/d6/541e80bf1bc46afa15052fe3ddb8e3bd6f78fc795b4eb686a5a15233e6b4/graphene-chain-mutation-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "d1a0ec6d2865e83f8853851004712e30", "sha256": "976183a6b98d0e3b72c7f0255aae36ae9b306349cd7d9810ea412209c02bde93"}, "downloads": -1, "filename": "graphene-chain-mutation-1.0.1.tar.gz", "has_sig": false, "md5_digest": "d1a0ec6d2865e83f8853851004712e30", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9110, "upload_time": "2020-04-26T11:27:17", "upload_time_iso_8601": "2020-04-26T11:27:17.234283Z", "url": "https://files.pythonhosted.org/packages/ee/6a/f9fccf9f8d9b4ef2d162bdb7a5f9c0c92a4e50df7bcfb6da1265c504af8f/graphene-chain-mutation-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "43e0a4a3145587d24c83ec3362077ad7", "sha256": "d52397661f8b54b5806c65daf832b2d0a1238d6fbe24597b5b0e989c9c7b35f8"}, "downloads": -1, "filename": "graphene-chain-mutation-1.0.2.tar.gz", "has_sig": false, "md5_digest": "43e0a4a3145587d24c83ec3362077ad7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9126, "upload_time": "2020-04-26T16:52:08", "upload_time_iso_8601": "2020-04-26T16:52:08.217853Z", "url": "https://files.pythonhosted.org/packages/75/a4/cb80674f50e78adf8a4af374dc63611c0269cde2d41e18f6939b5f951cc1/graphene-chain-mutation-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "559933edec6e2f4852cead73afe1d989", "sha256": "d09c27a5c59e2d830b8b2401aa53373c4b5ac186ee9ad52bb1f073084578c5a9"}, "downloads": -1, "filename": "graphene-chain-mutation-1.0.3.tar.gz", "has_sig": false, "md5_digest": "559933edec6e2f4852cead73afe1d989", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10866, "upload_time": "2020-05-04T16:09:50", "upload_time_iso_8601": "2020-05-04T16:09:50.680479Z", "url": "https://files.pythonhosted.org/packages/67/20/01ca1d6a6f421064ffccd80df210cb7aa6f10802b3cfe25c79566aff74dc/graphene-chain-mutation-1.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "559933edec6e2f4852cead73afe1d989", "sha256": "d09c27a5c59e2d830b8b2401aa53373c4b5ac186ee9ad52bb1f073084578c5a9"}, "downloads": -1, "filename": "graphene-chain-mutation-1.0.3.tar.gz", "has_sig": false, "md5_digest": "559933edec6e2f4852cead73afe1d989", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10866, "upload_time": "2020-05-04T16:09:50", "upload_time_iso_8601": "2020-05-04T16:09:50.680479Z", "url": "https://files.pythonhosted.org/packages/67/20/01ca1d6a6f421064ffccd80df210cb7aa6f10802b3cfe25c79566aff74dc/graphene-chain-mutation-1.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:46 2020"}