{"info": {"author": "Micah Smith", "author_email": "micahjsmith@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "[![PyPI Shield](https://img.shields.io/pypi/v/stacklog.svg)](https://pypi.python.org/pypi/stacklog)\n[![Downloads](https://pepy.tech/badge/stacklog)](https://pepy.tech/project/stacklog)\n[![Travis CI Shield](https://travis-ci.com/micahjsmith/stacklog.svg?branch=master)](https://travis-ci.com/micahjsmith/stacklog)\n\n# stacklog\n\nStack log messages\n\n- Documentation: https://micahjsmith.github.io/stacklog\n- Homepage: https://github.com/micahjsmith/stacklog\n\n## Overview\n\nStacklog is a tiny Python library to stack log messages.\n\nA stack-structured log is an approach to logging in which log messages are (conceptually)\npushed onto a stack and emitted only when the corresponding block returns. \nStacklog provides a single method, `stacklog`, which serves as either a decorator or a\ncontext manager. This is exceptionally useful in small projects or one-off scripts.\n\nThis is illustrated best with an example:\n\n```python\nwith stacklog(print, 'Running some code'):\n    with stacklog(print, 'Running some other code'):\n        pass\n```\n\nThis produces the following logging output:\n\n```shell\nRunning some code...\nRunning some other code...\nRunning some other code...DONE\nRunning some code...DONE\n```\n\nWhen the code within a stacklog context completes, the provided message is echoed along with\nthe return status, one of `DONE` or `FAILURE`. That's pretty much it. \nCustomization and advanced features are available through callbacks.\n\n## Install\n\nstacklog has been developed and tested on Python 2.7 and 3.5+.\n\n```shell\npip install stacklog\n```\n\n## Quickstart\n\nHow often do you find yourself using the following logging anti-pattern in Python?\n\n```python\nimport logging\n\ndef a():\n    logging.info('Running a')\n    do_something()\n    logging.info('Done with a')\n\ndef b():\n    logging.info('Running b')\n    a()\n    logging.info('Done with b')\n\ntry:\n    b()\nexcept:\n    logging.info('There was an error running b')\n```\n\nThe intention here is to log the beginning and end of procedure calls for use in debugging\nor user monitoring. I call this an anti-pattern because:\n\n- it requires excessive manual attention to writing/updating logging calls at entry/exit sites\n- it results in redundant exception handling logic\n- the resulting log messages can be misleading if errors occur\n\nInstead, the approach taken by stacklog is to accomplish this using only decorators and\ncontext managers.\n\n### Usage as decorator\n\nHere is the above example using the stacklog as a decorator:\n\n```python\n@stacklog(logging.info, 'Running a')\ndef a():\n    raise Exception\n\n@stacklog(logging.info, 'Running b')\ndef b():\n    a()\n\nb()\n```\n\nThis produces logging output:\n\n```shell\nINFO:root:Running b...\nINFO:root:Running a...\nINFO:root:Running a...FAILURE\nINFO:root:Running b...FAILURE\n```\n\n### Usage as context manager\n\nHere is another example using stacklog as a context manager:\n\n```pycon\n>>> with stacklog(logging.info, 'Running some code'):\n...     do_something()\n...\nINFO:root:Running some code...\nINFO:root:Running some code...DONE\n```\n\n### Providing custom conditions\n\nA *condition* is a tuple `exception, status`. If the provided exception is raised during the\nexecution of the provided code, the provided status is logged instead of the default\n`FAILURE`.\n\n```pycon\n>>> with stacklog(logging.info, 'Running some code', conditions=[(NotImplementedError,\n'SKIPPED')]):\n...     raise NotImplementedError\n...\nINFO:root:Running some code...\nINFO:root:Running some code...SKIPPED\n```\n\n### Customization with callbacks\n\nThe behavior of `stacklog` is fully customizable with callbacks.\n\nThe main thing that a callback will do is call the passed `stacklog` instance's \n`log` method with some custom suffix.\n\nFirst, there are three callbacks to customize the behavior of logging at the \nbeginning of the block, at successful completion of the block, and at failure\n of the block. Only one function can be registered at a time for each of \n these events.\n- `on_begin(func: stacklog -> None)`\n- `on_success(func: stacklog -> None)`\n- `on_failure(func: stacklog -> None)`\n\nSecond, one can customize failure behavior given different possible \nexceptions that are raised, by passing a pair of functions, the first to match \nan exception that was raised during block execution and the second to respond\nto the exception. Many pairs of functions can be registered, but only the most \nrecent one to be registered will be executed in the case that multiple \nfunctions match.\n- `on_condition(match: *exc_info -> bool, func: stacklog, *exc_info -> None)`\n\nThird, one can initialize and dispose of resources before and after the \nblock's execution. This is relevant for starting/stopping timers, etc. Many \nfunctions can be registered and they will all be executed.\n- `on_enter(func: stacklog -> None)`\n- `on_exit(func: stacklog -> None)`\n\nSee the implementation of `stacktime` for an example.\n\n### Adding timing information\n\nOne can customize `stacklog` with callbacks to, for example, add information \non the duration of block execution.\n\n```pycon\n>>> with stacktime(print, 'Running some code', unit='ms'):\n...     time.sleep(1e-2)\n...\nRunning some code...\nRunning some code...DONE in 11.11 ms\n```\n\n\n# History\n\n## 1.0 (2019-12-10)\n\nInitial release.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/micahjsmith/stacklog", "keywords": "stacklog", "license": "MIT license", "maintainer": "", "maintainer_email": "", "name": "stacklog", "package_url": "https://pypi.org/project/stacklog/", "platform": "", "project_url": "https://pypi.org/project/stacklog/", "project_urls": {"Homepage": "https://github.com/micahjsmith/stacklog"}, "release_url": "https://pypi.org/project/stacklog/1.1.0/", "requires_dist": ["bumpversion (>=0.5.3) ; extra == 'dev'", "pip (>=9.0.1) ; extra == 'dev'", "watchdog (>=0.8.3) ; extra == 'dev'", "m2r (>=0.2.0) ; extra == 'dev'", "Sphinx (>=1.7.1) ; extra == 'dev'", "sphinx-rtd-theme (>=0.2.4) ; extra == 'dev'", "autodocsumm (>=0.1.10) ; extra == 'dev'", "flake8 (>=3.7.7) ; extra == 'dev'", "isort (>=4.3.4) ; extra == 'dev'", "autoflake (>=1.2) ; extra == 'dev'", "autopep8 (>=1.4.3) ; extra == 'dev'", "twine (>=1.10.0) ; extra == 'dev'", "wheel (>=0.30.0) ; extra == 'dev'", "coverage (>=4.5.1) ; extra == 'dev'", "tox (>=2.9.1) ; extra == 'dev'", "pytest (>=3.4.2) ; extra == 'dev'", "pytest-cov (>=2.6.0) ; extra == 'dev'", "pytest (>=3.4.2) ; extra == 'test'", "pytest-cov (>=2.6.0) ; extra == 'test'"], "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "summary": "Stack log messages", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://pypi.python.org/pypi/stacklog\" rel=\"nofollow\"><img alt=\"PyPI Shield\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4680e76511add05fe55e43af114fb9f256f04be7/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f737461636b6c6f672e737667\"></a>\n<a href=\"https://pepy.tech/project/stacklog\" rel=\"nofollow\"><img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b31dd4d4cf87fbb08622b4a212db77eef18c103d/68747470733a2f2f706570792e746563682f62616467652f737461636b6c6f67\"></a>\n<a href=\"https://travis-ci.com/micahjsmith/stacklog\" rel=\"nofollow\"><img alt=\"Travis CI Shield\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c1dc74972b735fb333c7e4c720e54132d3769987/68747470733a2f2f7472617669732d63692e636f6d2f6d696361686a736d6974682f737461636b6c6f672e7376673f6272616e63683d6d6173746572\"></a></p>\n<h1>stacklog</h1>\n<p>Stack log messages</p>\n<ul>\n<li>Documentation: <a href=\"https://micahjsmith.github.io/stacklog\" rel=\"nofollow\">https://micahjsmith.github.io/stacklog</a></li>\n<li>Homepage: <a href=\"https://github.com/micahjsmith/stacklog\" rel=\"nofollow\">https://github.com/micahjsmith/stacklog</a></li>\n</ul>\n<h2>Overview</h2>\n<p>Stacklog is a tiny Python library to stack log messages.</p>\n<p>A stack-structured log is an approach to logging in which log messages are (conceptually)\npushed onto a stack and emitted only when the corresponding block returns.\nStacklog provides a single method, <code>stacklog</code>, which serves as either a decorator or a\ncontext manager. This is exceptionally useful in small projects or one-off scripts.</p>\n<p>This is illustrated best with an example:</p>\n<pre><span class=\"k\">with</span> <span class=\"n\">stacklog</span><span class=\"p\">(</span><span class=\"nb\">print</span><span class=\"p\">,</span> <span class=\"s1\">'Running some code'</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">stacklog</span><span class=\"p\">(</span><span class=\"nb\">print</span><span class=\"p\">,</span> <span class=\"s1\">'Running some other code'</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n</pre>\n<p>This produces the following logging output:</p>\n<pre>Running some code...\nRunning some other code...\nRunning some other code...DONE\nRunning some code...DONE\n</pre>\n<p>When the code within a stacklog context completes, the provided message is echoed along with\nthe return status, one of <code>DONE</code> or <code>FAILURE</code>. That's pretty much it.\nCustomization and advanced features are available through callbacks.</p>\n<h2>Install</h2>\n<p>stacklog has been developed and tested on Python 2.7 and 3.5+.</p>\n<pre>pip install stacklog\n</pre>\n<h2>Quickstart</h2>\n<p>How often do you find yourself using the following logging anti-pattern in Python?</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">a</span><span class=\"p\">():</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'Running a'</span><span class=\"p\">)</span>\n    <span class=\"n\">do_something</span><span class=\"p\">()</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'Done with a'</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">b</span><span class=\"p\">():</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'Running b'</span><span class=\"p\">)</span>\n    <span class=\"n\">a</span><span class=\"p\">()</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'Done with b'</span><span class=\"p\">)</span>\n\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">b</span><span class=\"p\">()</span>\n<span class=\"k\">except</span><span class=\"p\">:</span>\n    <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'There was an error running b'</span><span class=\"p\">)</span>\n</pre>\n<p>The intention here is to log the beginning and end of procedure calls for use in debugging\nor user monitoring. I call this an anti-pattern because:</p>\n<ul>\n<li>it requires excessive manual attention to writing/updating logging calls at entry/exit sites</li>\n<li>it results in redundant exception handling logic</li>\n<li>the resulting log messages can be misleading if errors occur</li>\n</ul>\n<p>Instead, the approach taken by stacklog is to accomplish this using only decorators and\ncontext managers.</p>\n<h3>Usage as decorator</h3>\n<p>Here is the above example using the stacklog as a decorator:</p>\n<pre><span class=\"nd\">@stacklog</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">,</span> <span class=\"s1\">'Running a'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">a</span><span class=\"p\">():</span>\n    <span class=\"k\">raise</span> <span class=\"ne\">Exception</span>\n\n<span class=\"nd\">@stacklog</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">,</span> <span class=\"s1\">'Running b'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">b</span><span class=\"p\">():</span>\n    <span class=\"n\">a</span><span class=\"p\">()</span>\n\n<span class=\"n\">b</span><span class=\"p\">()</span>\n</pre>\n<p>This produces logging output:</p>\n<pre>INFO:root:Running b...\nINFO:root:Running a...\nINFO:root:Running a...FAILURE\nINFO:root:Running b...FAILURE\n</pre>\n<h3>Usage as context manager</h3>\n<p>Here is another example using stacklog as a context manager:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">with</span> <span class=\"n\">stacklog</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">,</span> <span class=\"s1\">'Running some code'</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">do_something</span><span class=\"p\">()</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">INFO:root:Running some code...</span>\n<span class=\"go\">INFO:root:Running some code...DONE</span>\n</pre>\n<h3>Providing custom conditions</h3>\n<p>A <em>condition</em> is a tuple <code>exception, status</code>. If the provided exception is raised during the\nexecution of the provided code, the provided status is logged instead of the default\n<code>FAILURE</code>.</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">with</span> <span class=\"n\">stacklog</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">,</span> <span class=\"s1\">'Running some code'</span><span class=\"p\">,</span> <span class=\"n\">conditions</span><span class=\"o\">=</span><span class=\"p\">[(</span><span class=\"ne\">NotImplementedError</span><span class=\"p\">,</span>\n<span class=\"go\">'SKIPPED')]):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">raise</span> <span class=\"ne\">NotImplementedError</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">INFO:root:Running some code...</span>\n<span class=\"go\">INFO:root:Running some code...SKIPPED</span>\n</pre>\n<h3>Customization with callbacks</h3>\n<p>The behavior of <code>stacklog</code> is fully customizable with callbacks.</p>\n<p>The main thing that a callback will do is call the passed <code>stacklog</code> instance's\n<code>log</code> method with some custom suffix.</p>\n<p>First, there are three callbacks to customize the behavior of logging at the\nbeginning of the block, at successful completion of the block, and at failure\nof the block. Only one function can be registered at a time for each of\nthese events.</p>\n<ul>\n<li><code>on_begin(func: stacklog -&gt; None)</code></li>\n<li><code>on_success(func: stacklog -&gt; None)</code></li>\n<li><code>on_failure(func: stacklog -&gt; None)</code></li>\n</ul>\n<p>Second, one can customize failure behavior given different possible\nexceptions that are raised, by passing a pair of functions, the first to match\nan exception that was raised during block execution and the second to respond\nto the exception. Many pairs of functions can be registered, but only the most\nrecent one to be registered will be executed in the case that multiple\nfunctions match.</p>\n<ul>\n<li><code>on_condition(match: *exc_info -&gt; bool, func: stacklog, *exc_info -&gt; None)</code></li>\n</ul>\n<p>Third, one can initialize and dispose of resources before and after the\nblock's execution. This is relevant for starting/stopping timers, etc. Many\nfunctions can be registered and they will all be executed.</p>\n<ul>\n<li><code>on_enter(func: stacklog -&gt; None)</code></li>\n<li><code>on_exit(func: stacklog -&gt; None)</code></li>\n</ul>\n<p>See the implementation of <code>stacktime</code> for an example.</p>\n<h3>Adding timing information</h3>\n<p>One can customize <code>stacklog</code> with callbacks to, for example, add information\non the duration of block execution.</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">with</span> <span class=\"n\">stacktime</span><span class=\"p\">(</span><span class=\"nb\">print</span><span class=\"p\">,</span> <span class=\"s1\">'Running some code'</span><span class=\"p\">,</span> <span class=\"n\">unit</span><span class=\"o\">=</span><span class=\"s1\">'ms'</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">1e-2</span><span class=\"p\">)</span>\n<span class=\"gp\">...</span>\n<span class=\"go\">Running some code...</span>\n<span class=\"go\">Running some code...DONE in 11.11 ms</span>\n</pre>\n<h1>History</h1>\n<h2>1.0 (2019-12-10)</h2>\n<p>Initial release.</p>\n\n          </div>"}, "last_serial": 6845067, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "54845576432f8e97220e6cd0ca2e7869", "sha256": "8256e97cdafb77b516f49353b14b6a6560882c0977a96e172ed32f44e429168d"}, "downloads": -1, "filename": "stacklog-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "54845576432f8e97220e6cd0ca2e7869", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*", "size": 4944, "upload_time": "2019-12-10T20:00:36", "upload_time_iso_8601": "2019-12-10T20:00:36.772211Z", "url": "https://files.pythonhosted.org/packages/16/5c/71da8e1b8f00bfe12edf1b19388f89ea6f08e31f3e7f425fbfc67ddafbf4/stacklog-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "686667a337eaf1629da5b371f9784786", "sha256": "44510eae12b804ca9a48ad1e7d7e4999ba024e62c8fa41624590ad97f85ce46f"}, "downloads": -1, "filename": "stacklog-1.0.0.tar.gz", "has_sig": false, "md5_digest": "686667a337eaf1629da5b371f9784786", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*", "size": 12725, "upload_time": "2019-12-10T20:00:38", "upload_time_iso_8601": "2019-12-10T20:00:38.818006Z", "url": "https://files.pythonhosted.org/packages/7e/cb/2b4c562509539742d0a763a8a6c53db7cac450896b4fb530387704d18945/stacklog-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "a8d7873909d8cc99ba87e42cc94b0d54", "sha256": "840f24a9cb5f317afb3778273f99a530c2213ea6e22293f6abf9d1af641ca7f7"}, "downloads": -1, "filename": "stacklog-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a8d7873909d8cc99ba87e42cc94b0d54", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 7755, "upload_time": "2020-03-19T18:37:59", "upload_time_iso_8601": "2020-03-19T18:37:59.580734Z", "url": "https://files.pythonhosted.org/packages/53/98/5021c34868daf34298f67c56708df45e27032b2093143667f6497a308ff7/stacklog-1.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7e177ec0e9eee550e454983ff3ff19ff", "sha256": "67ba527c67efa6afa7c2c217f013729fb8dc771d546671d592399467c9f78a68"}, "downloads": -1, "filename": "stacklog-1.1.0.tar.gz", "has_sig": false, "md5_digest": "7e177ec0e9eee550e454983ff3ff19ff", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 16637, "upload_time": "2020-03-19T18:38:01", "upload_time_iso_8601": "2020-03-19T18:38:01.328629Z", "url": "https://files.pythonhosted.org/packages/a6/ab/49d9536df0309c5de70108a0005f2715e7bc2611b8034c97a6b413ca0658/stacklog-1.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a8d7873909d8cc99ba87e42cc94b0d54", "sha256": "840f24a9cb5f317afb3778273f99a530c2213ea6e22293f6abf9d1af641ca7f7"}, "downloads": -1, "filename": "stacklog-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a8d7873909d8cc99ba87e42cc94b0d54", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 7755, "upload_time": "2020-03-19T18:37:59", "upload_time_iso_8601": "2020-03-19T18:37:59.580734Z", "url": "https://files.pythonhosted.org/packages/53/98/5021c34868daf34298f67c56708df45e27032b2093143667f6497a308ff7/stacklog-1.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7e177ec0e9eee550e454983ff3ff19ff", "sha256": "67ba527c67efa6afa7c2c217f013729fb8dc771d546671d592399467c9f78a68"}, "downloads": -1, "filename": "stacklog-1.1.0.tar.gz", "has_sig": false, "md5_digest": "7e177ec0e9eee550e454983ff3ff19ff", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 16637, "upload_time": "2020-03-19T18:38:01", "upload_time_iso_8601": "2020-03-19T18:38:01.328629Z", "url": "https://files.pythonhosted.org/packages/a6/ab/49d9536df0309c5de70108a0005f2715e7bc2611b8034c97a6b413ca0658/stacklog-1.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:50 2020"}