{"info": {"author": "Thomas Wolf, Victor Sanh, Tim Rault, Google AI Language Team Authors, Open AI team Authors", "author_email": "thomas@huggingface.co", "bugtrack_url": null, "classifiers": ["Intended Audience :: Science/Research", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Artificial Intelligence"], "description": "# PyTorch Pretrained BERT: The Big & Extending Repository of pretrained Transformers\n\n[![CircleCI](https://circleci.com/gh/huggingface/pytorch-pretrained-BERT.svg?style=svg)](https://circleci.com/gh/huggingface/pytorch-pretrained-BERT)\n\nThis repository contains op-for-op PyTorch reimplementations, pre-trained models and fine-tuning examples for:\n\n- [Google's BERT model](https://github.com/google-research/bert),\n- [OpenAI's GPT model](https://github.com/openai/finetune-transformer-lm),\n- [Google/CMU's Transformer-XL model](https://github.com/kimiyoung/transformer-xl), and\n- [OpenAI's GPT-2 model](https://blog.openai.com/better-language-models/).\n\nThese implementations have been tested on several datasets (see the examples) and should match the performances of the associated TensorFlow implementations (e.g. ~91 F1 on SQuAD for BERT, ~88 F1 on RocStories for OpenAI GPT and ~18.3 perplexity on WikiText 103 for the Transformer-XL). You can find more details in the [Examples](#examples) section below.\n\nHere are some information on these models:\n\n**BERT** was released together with the paper [BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding](https://arxiv.org/abs/1810.04805) by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova.\nThis PyTorch implementation of BERT is provided with [Google's pre-trained models](https://github.com/google-research/bert), examples, notebooks and a command-line interface to load any pre-trained TensorFlow checkpoint for BERT is also provided.\n\n**OpenAI GPT** was released together with the paper [Improving Language Understanding by Generative Pre-Training](https://blog.openai.com/language-unsupervised/) by Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever.\nThis PyTorch implementation of OpenAI GPT is an adaptation of the [PyTorch implementation by HuggingFace](https://github.com/huggingface/pytorch-openai-transformer-lm) and is provided with [OpenAI's pre-trained model](https://github.com/openai/finetune-transformer-lm) and a command-line interface that was used to convert the pre-trained NumPy checkpoint in PyTorch.\n\n**Google/CMU's Transformer-XL** was released together with the paper [Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context](http://arxiv.org/abs/1901.02860) by Zihang Dai*, Zhilin Yang*, Yiming Yang, Jaime Carbonell, Quoc V. Le, Ruslan Salakhutdinov.\nThis PyTorch implementation of Transformer-XL is an adaptation of the original [PyTorch implementation](https://github.com/kimiyoung/transformer-xl) which has been slightly modified to match the performances of the TensorFlow implementation and allow to re-use the pretrained weights. A command-line interface is provided to convert TensorFlow checkpoints in PyTorch models.\n\n**OpenAI GPT-2** was released together with the paper [Language Models are Unsupervised Multitask Learners](https://blog.openai.com/better-language-models/) by Alec Radford*, Jeffrey Wu*, Rewon Child, David Luan, Dario Amodei** and Ilya Sutskever**.\nThis PyTorch implementation of OpenAI GPT-2 is an adaptation of the [OpenAI's implementation](https://github.com/openai/gpt-2) and is provided with [OpenAI's pre-trained model](https://github.com/openai/gpt-2) and a command-line interface that was used to convert the TensorFlow checkpoint in PyTorch.\n\n\n## Content\n\n| Section | Description |\n|-|-|\n| [Installation](#installation) | How to install the package |\n| [Overview](#overview) | Overview of the package |\n| [Usage](#usage) | Quickstart examples |\n| [Doc](#doc) |  Detailed documentation |\n| [Examples](#examples) | Detailed examples on how to fine-tune Bert |\n| [Notebooks](#notebooks) | Introduction on the provided Jupyter Notebooks |\n| [TPU](#tpu) | Notes on TPU support and pretraining scripts |\n| [Command-line interface](#Command-line-interface) | Convert a TensorFlow checkpoint in a PyTorch dump |\n\n## Installation\n\nThis repo was tested on Python 2.7 and 3.5+ (examples are tested only on python 3.5+) and PyTorch 0.4.1/1.0.0\n\n### With pip\n\nPyTorch pretrained bert can be installed by pip as follows:\n```bash\npip install pytorch-pretrained-bert\n```\n\nIf you want to reproduce the original tokenization process of the `OpenAI GPT` paper, you will need to install `ftfy` (limit to version 4.4.3 if you are using Python 2) and `SpaCy` :\n```bash\npip install spacy ftfy==4.4.3\npython -m spacy download en\n```\n\nIf you don't install `ftfy` and `SpaCy`, the `OpenAI GPT` tokenizer will default to tokenize using BERT's `BasicTokenizer` followed by Byte-Pair Encoding (which should be fine for most usage, don't worry).\n\n### From source\n\nClone the repository and run:\n```bash\npip install [--editable] .\n```\n\nHere also, if you want to reproduce the original tokenization process of the `OpenAI GPT` model, you will need to install `ftfy` (limit to version 4.4.3 if you are using Python 2) and `SpaCy` :\n```bash\npip install spacy ftfy==4.4.3\npython -m spacy download en\n```\n\nAgain, if you don't install `ftfy` and `SpaCy`, the `OpenAI GPT` tokenizer will default to tokenize using BERT's `BasicTokenizer` followed by Byte-Pair Encoding (which should be fine for most usage).\n\nA series of tests is included in the [tests folder](https://github.com/huggingface/pytorch-pretrained-BERT/tree/master/tests) and can be run using `pytest` (install pytest if needed: `pip install pytest`).\n\nYou can run the tests with the command:\n```bash\npython -m pytest -sv tests/\n```\n\n## Overview\n\nThis package comprises the following classes that can be imported in Python and are detailed in the [Doc](#doc) section of this readme:\n\n- Eight **Bert** PyTorch models (`torch.nn.Module`) with pre-trained weights (in the [`modeling.py`](./pytorch_pretrained_bert/modeling.py) file):\n  - [`BertModel`](./pytorch_pretrained_bert/modeling.py#L639) - raw BERT Transformer model (**fully pre-trained**),\n  - [`BertForMaskedLM`](./pytorch_pretrained_bert/modeling.py#L793) - BERT Transformer with the pre-trained masked language modeling head on top (**fully pre-trained**),\n  - [`BertForNextSentencePrediction`](./pytorch_pretrained_bert/modeling.py#L854) - BERT Transformer with the pre-trained next sentence prediction classifier on top  (**fully pre-trained**),\n  - [`BertForPreTraining`](./pytorch_pretrained_bert/modeling.py#L722) - BERT Transformer with masked language modeling head and next sentence prediction classifier on top (**fully pre-trained**),\n  - [`BertForSequenceClassification`](./pytorch_pretrained_bert/modeling.py#L916) - BERT Transformer with a sequence classification head on top (BERT Transformer is **pre-trained**, the sequence classification head **is only initialized and has to be trained**),\n  - [`BertForMultipleChoice`](./pytorch_pretrained_bert/modeling.py#L982) - BERT Transformer with a multiple choice head on top (used for task like Swag) (BERT Transformer is **pre-trained**, the multiple choice classification head **is only initialized and has to be trained**),\n  - [`BertForTokenClassification`](./pytorch_pretrained_bert/modeling.py#L1051) - BERT Transformer with a token classification head on top (BERT Transformer is **pre-trained**, the token classification head **is only initialized and has to be trained**),\n  - [`BertForQuestionAnswering`](./pytorch_pretrained_bert/modeling.py#L1124) - BERT Transformer with a token classification head on top (BERT Transformer is **pre-trained**, the token classification head **is only initialized and has to be trained**).\n\n- Three **OpenAI GPT** PyTorch models (`torch.nn.Module`) with pre-trained weights (in the [`modeling_openai.py`](./pytorch_pretrained_bert/modeling_openai.py) file):\n  - [`OpenAIGPTModel`](./pytorch_pretrained_bert/modeling_openai.py#L536) - raw OpenAI GPT Transformer model (**fully pre-trained**),\n  - [`OpenAIGPTLMHeadModel`](./pytorch_pretrained_bert/modeling_openai.py#L643) - OpenAI GPT Transformer with the tied language modeling head on top (**fully pre-trained**),\n  - [`OpenAIGPTDoubleHeadsModel`](./pytorch_pretrained_bert/modeling_openai.py#L722) - OpenAI GPT Transformer with the tied language modeling head and a multiple choice classification head on top (OpenAI GPT Transformer is **pre-trained**, the multiple choice classification head **is only initialized and has to be trained**),\n\n- Two **Transformer-XL** PyTorch models (`torch.nn.Module`) with pre-trained weights (in the [`modeling_transfo_xl.py`](./pytorch_pretrained_bert/modeling_transfo_xl.py) file):\n  - [`TransfoXLModel`](./pytorch_pretrained_bert/modeling_transfo_xl.py#L983) - Transformer-XL model which outputs the last hidden state and memory cells (**fully pre-trained**),\n  - [`TransfoXLLMHeadModel`](./pytorch_pretrained_bert/modeling_transfo_xl.py#L1260) - Transformer-XL with the tied adaptive softmax head on top for language modeling which outputs the logits/loss and memory cells (**fully pre-trained**),\n\n- Three **OpenAI GPT-2** PyTorch models (`torch.nn.Module`) with pre-trained weights (in the [`modeling_gpt2.py`](./pytorch_pretrained_bert/modeling_gpt2.py) file):\n  - [`GPT2Model`](./pytorch_pretrained_bert/modeling_gpt2.py#L479) - raw OpenAI GPT-2 Transformer model (**fully pre-trained**),\n  - [`GPT2LMHeadModel`](./pytorch_pretrained_bert/modeling_gpt2.py#L559) - OpenAI GPT-2 Transformer with the tied language modeling head on top (**fully pre-trained**),\n  - [`GPT2DoubleHeadsModel`](./pytorch_pretrained_bert/modeling_gpt2.py#L624) - OpenAI GPT-2 Transformer with the tied language modeling head and a multiple choice classification head on top (OpenAI GPT-2 Transformer is **pre-trained**, the multiple choice classification head **is only initialized and has to be trained**),\n\n- Tokenizers for **BERT** (using word-piece) (in the [`tokenization.py`](./pytorch_pretrained_bert/tokenization.py) file):\n  - `BasicTokenizer` - basic tokenization (punctuation splitting, lower casing, etc.),\n  - `WordpieceTokenizer` - WordPiece tokenization,\n  - `BertTokenizer` - perform end-to-end tokenization, i.e. basic tokenization followed by WordPiece tokenization.\n\n- Tokenizer for **OpenAI GPT** (using Byte-Pair-Encoding) (in the [`tokenization_openai.py`](./pytorch_pretrained_bert/tokenization_openai.py) file):\n  - `OpenAIGPTTokenizer` - perform Byte-Pair-Encoding (BPE) tokenization.\n\n- Tokenizer for **Transformer-XL** (word tokens ordered by frequency for adaptive softmax) (in the [`tokenization_transfo_xl.py`](./pytorch_pretrained_bert/tokenization_transfo_xl.py) file):\n  - `OpenAIGPTTokenizer` - perform word tokenization and can order words by frequency in a corpus for use in an adaptive softmax.\n\n- Tokenizer for **OpenAI GPT-2** (using byte-level Byte-Pair-Encoding) (in the [`tokenization_gpt2.py`](./pytorch_pretrained_bert/tokenization_gpt2.py) file):\n  - `GPT2Tokenizer` - perform byte-level Byte-Pair-Encoding (BPE) tokenization.\n\n- Optimizer for **BERT** (in the [`optimization.py`](./pytorch_pretrained_bert/optimization.py) file):\n  - `BertAdam` - Bert version of Adam algorithm with weight decay fix, warmup and linear decay of the learning rate.\n\n- Optimizer for **OpenAI GPT** (in the [`optimization_openai.py`](./pytorch_pretrained_bert/optimization_openai.py) file):\n  - `OpenAIAdam` - OpenAI GPT version of Adam algorithm with weight decay fix, warmup and linear decay of the learning rate.\n\n- Configuration classes for BERT, OpenAI GPT and Transformer-XL (in the respective [`modeling.py`](./pytorch_pretrained_bert/modeling.py), [`modeling_openai.py`](./pytorch_pretrained_bert/modeling_openai.py), [`modeling_transfo_xl.py`](./pytorch_pretrained_bert/modeling_transfo_xl.py) files):\n  - `BertConfig` - Configuration class to store the configuration of a `BertModel` with utilities to read and write from JSON configuration files.\n  - `OpenAIGPTConfig` - Configuration class to store the configuration of a `OpenAIGPTModel` with utilities to read and write from JSON configuration files.\n  - `GPT2Config` - Configuration class to store the configuration of a `GPT2Model` with utilities to read and write from JSON configuration files.\n  - `TransfoXLConfig` - Configuration class to store the configuration of a `TransfoXLModel` with utilities to read and write from JSON configuration files.\n\nThe repository further comprises:\n\n- Five examples on how to use **BERT** (in the [`examples` folder](./examples)):\n  - [`extract_features.py`](./examples/extract_features.py) - Show how to extract hidden states from an instance of `BertModel`,\n  - [`run_classifier.py`](./examples/run_classifier.py) - Show how to fine-tune an instance of `BertForSequenceClassification` on GLUE's MRPC task,\n  - [`run_squad.py`](./examples/run_squad.py) - Show how to fine-tune an instance of `BertForQuestionAnswering` on SQuAD v1.0 and SQuAD v2.0 tasks.\n  - [`run_swag.py`](./examples/run_swag.py) - Show how to fine-tune an instance of `BertForMultipleChoice` on Swag task.\n  - [`simple_lm_finetuning.py`](./examples/lm_finetuning/simple_lm_finetuning.py) - Show how to fine-tune an instance of `BertForPretraining` on a target text corpus.\n\n- One example on how to use **OpenAI GPT** (in the [`examples` folder](./examples)):\n  - [`run_openai_gpt.py`](./examples/run_openai_gpt.py) - Show how to fine-tune an instance of `OpenGPTDoubleHeadsModel` on the RocStories task.\n\n- One example on how to use **Transformer-XL** (in the [`examples` folder](./examples)):\n  - [`run_transfo_xl.py`](./examples/run_transfo_xl.py) - Show how to load and evaluate a pre-trained model of `TransfoXLLMHeadModel` on WikiText 103.\n\n- One example on how to use **OpenAI GPT-2** in the unconditional and interactive mode (in the [`examples` folder](./examples)):\n  - [`run_gpt2.py`](./examples/run_gpt2.py) - Show how to use OpenAI GPT-2 an instance of `GPT2LMHeadModel` to generate text (same as the original OpenAI GPT-2 examples).\n\n  These examples are detailed in the [Examples](#examples) section of this readme.\n\n- Three notebooks that were used to check that the TensorFlow and PyTorch models behave identically (in the [`notebooks` folder](./notebooks)):\n  - [`Comparing-TF-and-PT-models.ipynb`](./notebooks/Comparing-TF-and-PT-models.ipynb) - Compare the hidden states predicted by `BertModel`,\n  - [`Comparing-TF-and-PT-models-SQuAD.ipynb`](./notebooks/Comparing-TF-and-PT-models-SQuAD.ipynb) - Compare the spans predicted by  `BertForQuestionAnswering` instances,\n  - [`Comparing-TF-and-PT-models-MLM-NSP.ipynb`](./notebooks/Comparing-TF-and-PT-models-MLM-NSP.ipynb) - Compare the predictions of the `BertForPretraining` instances.\n\n  These notebooks are detailed in the [Notebooks](#notebooks) section of this readme.\n\n- A command-line interface to convert TensorFlow checkpoints (BERT, Transformer-XL) or NumPy checkpoint (OpenAI) in a PyTorch save of the associated PyTorch model:\n\n  This CLI is detailed in the [Command-line interface](#Command-line-interface) section of this readme.\n\n## Usage\n\n### BERT\n\nHere is a quick-start example using `BertTokenizer`, `BertModel` and `BertForMaskedLM` class with Google AI's pre-trained `Bert base uncased` model. See the [doc section](#doc) below for all the details on these classes.\n\nFirst let's prepare a tokenized input with `BertTokenizer`\n\n```python\nimport torch\nfrom pytorch_pretrained_bert import BertTokenizer, BertModel, BertForMaskedLM\n\n# OPTIONAL: if you want to have more information on what's happening, activate the logger as follows\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\n# Load pre-trained model tokenizer (vocabulary)\ntokenizer = BertTokenizer.from_pretrained('bert-base-uncased')\n\n# Tokenized input\ntext = \"[CLS] Who was Jim Henson ? [SEP] Jim Henson was a puppeteer [SEP]\"\ntokenized_text = tokenizer.tokenize(text)\n\n# Mask a token that we will try to predict back with `BertForMaskedLM`\nmasked_index = 8\ntokenized_text[masked_index] = '[MASK]'\nassert tokenized_text == ['[CLS]', 'who', 'was', 'jim', 'henson', '?', '[SEP]', 'jim', '[MASK]', 'was', 'a', 'puppet', '##eer', '[SEP]']\n\n# Convert token to vocabulary indices\nindexed_tokens = tokenizer.convert_tokens_to_ids(tokenized_text)\n# Define sentence A and B indices associated to 1st and 2nd sentences (see paper)\nsegments_ids = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1]\n\n# Convert inputs to PyTorch tensors\ntokens_tensor = torch.tensor([indexed_tokens])\nsegments_tensors = torch.tensor([segments_ids])\n```\n\nLet's see how to use `BertModel` to get hidden states\n\n```python\n# Load pre-trained model (weights)\nmodel = BertModel.from_pretrained('bert-base-uncased')\nmodel.eval()\n\n# If you have a GPU, put everything on cuda\ntokens_tensor = tokens_tensor.to('cuda')\nsegments_tensors = segments_tensors.to('cuda')\nmodel.to('cuda')\n\n# Predict hidden states features for each layer\nwith torch.no_grad():\n    encoded_layers, _ = model(tokens_tensor, segments_tensors)\n# We have a hidden states for each of the 12 layers in model bert-base-uncased\nassert len(encoded_layers) == 12\n```\n\nAnd how to use `BertForMaskedLM`\n\n```python\n# Load pre-trained model (weights)\nmodel = BertForMaskedLM.from_pretrained('bert-base-uncased')\nmodel.eval()\n\n# If you have a GPU, put everything on cuda\ntokens_tensor = tokens_tensor.to('cuda')\nsegments_tensors = segments_tensors.to('cuda')\nmodel.to('cuda')\n\n# Predict all tokens\nwith torch.no_grad():\n    predictions = model(tokens_tensor, segments_tensors)\n\n# confirm we were able to predict 'henson'\npredicted_index = torch.argmax(predictions[0, masked_index]).item()\npredicted_token = tokenizer.convert_ids_to_tokens([predicted_index])[0]\nassert predicted_token == 'henson'\n```\n\n### OpenAI GPT\n\nHere is a quick-start example using `OpenAIGPTTokenizer`, `OpenAIGPTModel` and `OpenAIGPTLMHeadModel` class with OpenAI's pre-trained  model. See the [doc section](#doc) below for all the details on these classes.\n\nFirst let's prepare a tokenized input with `OpenAIGPTTokenizer`\n\n```python\nimport torch\nfrom pytorch_pretrained_bert import OpenAIGPTTokenizer, OpenAIGPTModel, OpenAIGPTLMHeadModel\n\n# OPTIONAL: if you want to have more information on what's happening, activate the logger as follows\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\n# Load pre-trained model tokenizer (vocabulary)\ntokenizer = OpenAIGPTTokenizer.from_pretrained('openai-gpt')\n\n# Tokenized input\ntext = \"Who was Jim Henson ? Jim Henson was a puppeteer\"\ntokenized_text = tokenizer.tokenize(text)\n\n# Convert token to vocabulary indices\nindexed_tokens = tokenizer.convert_tokens_to_ids(tokenized_text)\n\n# Convert inputs to PyTorch tensors\ntokens_tensor = torch.tensor([indexed_tokens])\n```\n\nLet's see how to use `OpenAIGPTModel` to get hidden states\n\n```python\n# Load pre-trained model (weights)\nmodel = OpenAIGPTModel.from_pretrained('openai-gpt')\nmodel.eval()\n\n# If you have a GPU, put everything on cuda\ntokens_tensor = tokens_tensor.to('cuda')\nmodel.to('cuda')\n\n# Predict hidden states features for each layer\nwith torch.no_grad():\n    hidden_states = model(tokens_tensor)\n```\n\nAnd how to use `OpenAIGPTLMHeadModel`\n\n```python\n# Load pre-trained model (weights)\nmodel = OpenAIGPTLMHeadModel.from_pretrained('openai-gpt')\nmodel.eval()\n\n# If you have a GPU, put everything on cuda\ntokens_tensor = tokens_tensor.to('cuda')\nmodel.to('cuda')\n\n# Predict all tokens\nwith torch.no_grad():\n    predictions = model(tokens_tensor)\n\n# get the predicted last token\npredicted_index = torch.argmax(predictions[0, -1, :]).item()\npredicted_token = tokenizer.convert_ids_to_tokens([predicted_index])[0]\nassert predicted_token == '.</w>'\n```\n\n### Transformer-XL\n\nHere is a quick-start example using `TransfoXLTokenizer`, `TransfoXLModel` and `TransfoXLModelLMHeadModel` class with the Transformer-XL model pre-trained on WikiText-103. See the [doc section](#doc) below for all the details on these classes.\n\nFirst let's prepare a tokenized input with `TransfoXLTokenizer`\n\n```python\nimport torch\nfrom pytorch_pretrained_bert import TransfoXLTokenizer, TransfoXLModel, TransfoXLLMHeadModel\n\n# OPTIONAL: if you want to have more information on what's happening, activate the logger as follows\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\n# Load pre-trained model tokenizer (vocabulary from wikitext 103)\ntokenizer = TransfoXLTokenizer.from_pretrained('transfo-xl-wt103')\n\n# Tokenized input\ntext_1 = \"Who was Jim Henson ?\"\ntext_2 = \"Jim Henson was a puppeteer\"\ntokenized_text_1 = tokenizer.tokenize(text_1)\ntokenized_text_2 = tokenizer.tokenize(text_2)\n\n# Convert token to vocabulary indices\nindexed_tokens_1 = tokenizer.convert_tokens_to_ids(tokenized_text_1)\nindexed_tokens_2 = tokenizer.convert_tokens_to_ids(tokenized_text_2)\n\n# Convert inputs to PyTorch tensors\ntokens_tensor_1 = torch.tensor([indexed_tokens_1])\ntokens_tensor_2 = torch.tensor([indexed_tokens_2])\n```\n\nLet's see how to use `TransfoXLModel` to get hidden states\n\n```python\n# Load pre-trained model (weights)\nmodel = TransfoXLModel.from_pretrained('transfo-xl-wt103')\nmodel.eval()\n\n# If you have a GPU, put everything on cuda\ntokens_tensor_1 = tokens_tensor_1.to('cuda')\ntokens_tensor_2 = tokens_tensor_2.to('cuda')\nmodel.to('cuda')\n\nwith torch.no_grad():\n    # Predict hidden states features for each layer\n    hidden_states_1, mems_1 = model(tokens_tensor_1)\n    # We can re-use the memory cells in a subsequent call to attend a longer context\n    hidden_states_2, mems_2 = model(tokens_tensor_2, mems=mems_1)\n```\n\nAnd how to use `TransfoXLLMHeadModel`\n\n```python\n# Load pre-trained model (weights)\nmodel = TransfoXLLMHeadModel.from_pretrained('transfo-xl-wt103')\nmodel.eval()\n\n# If you have a GPU, put everything on cuda\ntokens_tensor_1 = tokens_tensor_1.to('cuda')\ntokens_tensor_2 = tokens_tensor_2.to('cuda')\nmodel.to('cuda')\n\nwith torch.no_grad():\n    # Predict all tokens\n    predictions_1, mems_1 = model(tokens_tensor_1)\n    # We can re-use the memory cells in a subsequent call to attend a longer context\n    predictions_2, mems_2 = model(tokens_tensor_2, mems=mems_1)\n\n# get the predicted last token\npredicted_index = torch.argmax(predictions_2[0, -1, :]).item()\npredicted_token = tokenizer.convert_ids_to_tokens([predicted_index])[0]\nassert predicted_token == 'who'\n```\n\n### OpenAI GPT-2\n\nHere is a quick-start example using `GPT2Tokenizer`, `GPT2Model` and `GPT2LMHeadModel` class with OpenAI's pre-trained  model. See the [doc section](#doc) below for all the details on these classes.\n\nFirst let's prepare a tokenized input with `GPT2Tokenizer`\n\n```python\nimport torch\nfrom pytorch_pretrained_bert import GPT2Tokenizer, GPT2Model, GPT2LMHeadModel\n\n# OPTIONAL: if you want to have more information on what's happening, activate the logger as follows\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\n# Load pre-trained model tokenizer (vocabulary)\ntokenizer = GPT2Tokenizer.from_pretrained('gpt2')\n\n# Encode some inputs\ntext_1 = \"Who was Jim Henson ?\"\ntext_2 = \"Jim Henson was a puppeteer\"\nindexed_tokens_1 = tokenizer.encode(text_1)\nindexed_tokens_2 = tokenizer.encode(text_2)\n\n# Convert inputs to PyTorch tensors\ntokens_tensor_1 = torch.tensor([indexed_tokens_1])\ntokens_tensor_2 = torch.tensor([indexed_tokens_2])\n```\n\nLet's see how to use `GPT2Model` to get hidden states\n\n```python\n# Load pre-trained model (weights)\nmodel = GPT2Model.from_pretrained('gpt2')\nmodel.eval()\n\n# If you have a GPU, put everything on cuda\ntokens_tensor_1 = tokens_tensor_1.to('cuda')\ntokens_tensor_2 = tokens_tensor_2.to('cuda')\nmodel.to('cuda')\n\n# Predict hidden states features for each layer\nwith torch.no_grad():\n    hidden_states_1, past = model(tokens_tensor_1)\n    # past can be used to reuse precomputed hidden state in a subsequent predictions\n    # (see beam-search examples in the run_gpt2.py example).\n    hidden_states_2, past = model(tokens_tensor_2, past=past)\n```\n\nAnd how to use `GPT2LMHeadModel`\n\n```python\n# Load pre-trained model (weights)\nmodel = GPT2LMHeadModel.from_pretrained('gpt2')\nmodel.eval()\n\n# If you have a GPU, put everything on cuda\ntokens_tensor_1 = tokens_tensor_1.to('cuda')\ntokens_tensor_2 = tokens_tensor_2.to('cuda')\nmodel.to('cuda')\n\n# Predict all tokens\nwith torch.no_grad():\n    predictions_1, past = model(tokens_tensor_1)\n    # past can be used to reuse precomputed hidden state in a subsequent predictions\n    # (see beam-search examples in the run_gpt2.py example).\n    predictions_2, past = model(tokens_tensor_2, past=past)\n\n# get the predicted last token\npredicted_index = torch.argmax(predictions_2[0, -1, :]).item()\npredicted_token = tokenizer.decode([predicted_index])\n```\n\n## Doc\n\nHere is a detailed documentation of the classes in the package and how to use them:\n\n| Sub-section | Description |\n|-|-|\n| [Loading pre-trained weights](#loading-google-ai-or-openai-pre-trained-weights-or-pytorch-dump) | How to load Google AI/OpenAI's pre-trained weight or a PyTorch saved instance |\n| [Serialization best-practices](#serialization-best-practices) | How to save and reload a fine-tuned model |\n| [Configurations](#configurations) | API of the configuration classes for BERT, GPT, GPT-2 and Transformer-XL |\n| [Models](#models) | API of the PyTorch model classes for BERT, GPT, GPT-2 and Transformer-XL |\n| [Tokenizers](#tokenizers) | API of the tokenizers class for BERT, GPT, GPT-2 and Transformer-XL|\n| [Optimizers](#optimizers) |  API of the optimizers |\n\n### Loading Google AI or OpenAI pre-trained weights or PyTorch dump\n\nTo load one of Google AI's, OpenAI's pre-trained models or a PyTorch saved model (an instance of `BertForPreTraining` saved with `torch.save()`), the PyTorch model classes and the tokenizer can be instantiated as\n\n```python\nmodel = BERT_CLASS.from_pretrained(PRE_TRAINED_MODEL_NAME_OR_PATH, cache_dir=None)\n```\n\nwhere\n\n- `BERT_CLASS` is either a tokenizer to load the vocabulary (`BertTokenizer` or `OpenAIGPTTokenizer` classes) or one of the eight BERT or three OpenAI GPT PyTorch model classes (to load the pre-trained weights): `BertModel`, `BertForMaskedLM`, `BertForNextSentencePrediction`, `BertForPreTraining`, `BertForSequenceClassification`, `BertForTokenClassification`, `BertForMultipleChoice`, `BertForQuestionAnswering`, `OpenAIGPTModel`, `OpenAIGPTLMHeadModel` or `OpenAIGPTDoubleHeadsModel`, and\n- `PRE_TRAINED_MODEL_NAME_OR_PATH` is either:\n\n  - the shortcut name of a Google AI's or OpenAI's pre-trained model selected in the list:\n\n    - `bert-base-uncased`: 12-layer, 768-hidden, 12-heads, 110M parameters\n    - `bert-large-uncased`: 24-layer, 1024-hidden, 16-heads, 340M parameters\n    - `bert-base-cased`: 12-layer, 768-hidden, 12-heads , 110M parameters\n    - `bert-large-cased`: 24-layer, 1024-hidden, 16-heads, 340M parameters\n    - `bert-base-multilingual-uncased`: (Orig, not recommended) 102 languages, 12-layer, 768-hidden, 12-heads, 110M parameters\n    - `bert-base-multilingual-cased`: **(New, recommended)** 104 languages, 12-layer, 768-hidden, 12-heads, 110M parameters\n    - `bert-base-chinese`: Chinese Simplified and Traditional, 12-layer, 768-hidden, 12-heads, 110M parameters\n    - `openai-gpt`: OpenAI English model, 12-layer, 768-hidden, 12-heads, 110M parameters\n    - `transfo-xl-wt103`: Transformer-XL English model trained on wikitext-103, 18-layer, 1024-hidden, 16-heads, 257M parameters\n    - `gpt2`: OpenAI GPT-2 English model, 12-layer, 768-hidden, 12-heads, 117M parameters\n\n  - a path or url to a pretrained model archive containing:\n\n    - `bert_config.json` or `openai_gpt_config.json` a configuration file for the model, and\n    - `pytorch_model.bin` a PyTorch dump of a pre-trained instance of `BertForPreTraining`, `OpenAIGPTModel`, `TransfoXLModel`, `GPT2LMHeadModel` (saved with the usual `torch.save()`)\n\n  If `PRE_TRAINED_MODEL_NAME_OR_PATH` is a shortcut name, the pre-trained weights will be downloaded from AWS S3 (see the links [here](pytorch_pretrained_bert/modeling.py)) and stored in a cache folder to avoid future download (the cache folder can be found at `~/.pytorch_pretrained_bert/`).\n- `cache_dir` can be an optional path to a specific directory to download and cache the pre-trained model weights. This option is useful in particular when you are using distributed training: to avoid concurrent access to the same weights you can set for example `cache_dir='./pretrained_model_{}'.format(args.local_rank)` (see the section on distributed training for more information).\n\n`Uncased` means that the text has been lowercased before WordPiece tokenization, e.g., `John Smith` becomes `john smith`. The Uncased model also strips out any accent markers. `Cased` means that the true case and accent markers are preserved. Typically, the Uncased model is better unless you know that case information is important for your task (e.g., Named Entity Recognition or Part-of-Speech tagging). For information about the Multilingual and Chinese model, see the [Multilingual README](https://github.com/google-research/bert/blob/master/multilingual.md) or the original TensorFlow repository.\n\n**When using an `uncased model`, make sure to pass `--do_lower_case` to the example training scripts (or pass `do_lower_case=True` to FullTokenizer if you're using your own script and loading the tokenizer your-self.).**\n\nExamples:\n```python\n# BERT\ntokenizer = BertTokenizer.from_pretrained('bert-base-uncased', do_lower_case=True, do_basic_tokenize=True)\nmodel = BertForSequenceClassification.from_pretrained('bert-base-uncased')\n\n# OpenAI GPT\ntokenizer = OpenAIGPTTokenizer.from_pretrained('openai-gpt')\nmodel = OpenAIGPTModel.from_pretrained('openai-gpt')\n\n# Transformer-XL\ntokenizer = TransfoXLTokenizer.from_pretrained('transfo-xl-wt103')\nmodel = TransfoXLModel.from_pretrained('transfo-xl-wt103')\n\n# OpenAI GPT-2\ntokenizer = GPT2Tokenizer.from_pretrained('gpt2')\nmodel = GPT2Model.from_pretrained('gpt2')\n\n```\n\n### Serialization best-practices\n\nThis section explain how you can save and re-load a fine-tuned model (BERT, GPT, GPT-2 and Transformer-XL).\nThere are three types of files you need to save to be able to reload a fine-tuned model:\n\n- the model it-self which should be saved following PyTorch serialization [best practices](https://pytorch.org/docs/stable/notes/serialization.html#best-practices),\n- the configuration file of the model which is saved as a JSON file, and\n- the vocabulary (and the merges for the BPE-based models GPT and GPT-2).\n\nHere is the recommended way of saving the model, configuration and vocabulary to an `output_dir` directory and reloading the model and tokenizer afterwards:\n\n```python\nfrom pytorch_pretrained_bert import WEIGHTS_NAME, CONFIG_NAME\n\noutput_dir = \"./models/\"\n\n# Step 1: Save a model, configuration and vocabulary that you have fine-tuned\n\n# If we have a distributed model, save only the encapsulated model\n# (it was wrapped in PyTorch DistributedDataParallel or DataParallel)\nmodel_to_save = model.module if hasattr(model, 'module') else model\n\n# If we save using the predefined names, we can load using `from_pretrained`\noutput_model_file = os.path.join(output_dir, WEIGHTS_NAME)\noutput_config_file = os.path.join(output_dir, CONFIG_NAME)\n\ntorch.save(model_to_save.state_dict(), output_model_file)\nmodel_to_save.config.to_json_file(output_config_file)\ntokenizer.save_vocabulary(output_dir)\n\n# Step 2: Re-load the saved model and vocabulary\n\n# Example for a Bert model\nmodel = BertForQuestionAnswering.from_pretrained(output_dir)\ntokenizer = BertTokenizer.from_pretrained(output_dir, do_lower_case=args.do_lower_case)  # Add specific options if needed\n# Example for a GPT model\nmodel = OpenAIGPTDoubleHeadsModel.from_pretrained(output_dir)\ntokenizer = OpenAIGPTTokenizer.from_pretrained(output_dir)\n```\n\nHere is another way you can save and reload the model if you want to use specific paths for each type of files:\n\n```python\noutput_model_file = \"./models/my_own_model_file.bin\"\noutput_config_file = \"./models/my_own_config_file.bin\"\noutput_vocab_file = \"./models/my_own_vocab_file.bin\"\n\n# Step 1: Save a model, configuration and vocabulary that you have fine-tuned\n\n# If we have a distributed model, save only the encapsulated model\n# (it was wrapped in PyTorch DistributedDataParallel or DataParallel)\nmodel_to_save = model.module if hasattr(model, 'module') else model\n\ntorch.save(model_to_save.state_dict(), output_model_file)\nmodel_to_save.config.to_json_file(output_config_file)\ntokenizer.save_vocabulary(output_vocab_file)\n\n# Step 2: Re-load the saved model and vocabulary\n\n# We didn't save using the predefined WEIGHTS_NAME, CONFIG_NAME names, we cannot load using `from_pretrained`.\n# Here is how to do it in this situation:\n\n# Example for a Bert model\nconfig = BertConfig.from_json_file(output_config_file)\nmodel = BertForQuestionAnswering(config)\nstate_dict = torch.load(output_model_file)\nmodel.load_state_dict(state_dict)\ntokenizer = BertTokenizer(output_vocab_file, do_lower_case=args.do_lower_case)\n\n# Example for a GPT model\nconfig = OpenAIGPTConfig.from_json_file(output_config_file)\nmodel = OpenAIGPTDoubleHeadsModel(config)\nstate_dict = torch.load(output_model_file)\nmodel.load_state_dict(state_dict)\ntokenizer = OpenAIGPTTokenizer(output_vocab_file)\n```\n\n### Configurations\n\nModels (BERT, GPT, GPT-2 and Transformer-XL) are defined and build from configuration classes which containes the parameters of the models (number of layers, dimensionalities...) and a few utilities to read and write from JSON configuration files. The respective configuration classes are:\n\n- `BertConfig` for `BertModel` and BERT classes instances.\n- `OpenAIGPTConfig` for `OpenAIGPTModel` and OpenAI GPT classes instances.\n- `GPT2Config` for `GPT2Model` and OpenAI GPT-2 classes instances.\n- `TransfoXLConfig` for `TransfoXLModel` and Transformer-XL classes instances.\n\nThese configuration classes contains a few utilities to load and save configurations:\n\n- `from_dict(cls, json_object)`: A class method to construct a configuration from a Python dictionary of parameters. Returns an instance of the configuration class.\n- `from_json_file(cls, json_file)`: A class method to construct a configuration from a json file of parameters. Returns an instance of the configuration class.\n- `to_dict()`: Serializes an instance to a Python dictionary. Returns a dictionary.\n- `to_json_string()`: Serializes an instance to a JSON string. Returns a string.\n- `to_json_file(json_file_path)`: Save an instance to a json file.\n\n### Models\n\n#### 1. `BertModel`\n\n`BertModel` is the basic BERT Transformer model with a layer of summed token, position and sequence embeddings followed by a series of identical self-attention blocks (12 for BERT-base, 24 for BERT-large).\n\nThe inputs and output are **identical to the TensorFlow model inputs and outputs**.\n\nWe detail them here. This model takes as *inputs*:\n[`modeling.py`](./pytorch_pretrained_bert/modeling.py)\n- `input_ids`: a torch.LongTensor of shape [batch_size, sequence_length] with the word token indices in the vocabulary (see the tokens preprocessing logic in the scripts [`extract_features.py`](./examples/extract_features.py), [`run_classifier.py`](./examples/run_classifier.py) and [`run_squad.py`](./examples/run_squad.py)), and\n- `token_type_ids`: an optional torch.LongTensor of shape [batch_size, sequence_length] with the token types indices selected in [0, 1]. Type 0 corresponds to a `sentence A` and type 1 corresponds to a `sentence B` token (see BERT paper for more details).\n- `attention_mask`: an optional torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [0, 1]. It's a mask to be used if some input sequence lengths are smaller than the max input sequence length of the current batch. It's the mask that we typically use for attention when a batch has varying length sentences.\n- `output_all_encoded_layers`: boolean which controls the content of the `encoded_layers` output as described below. Default: `True`.\n\nThis model *outputs* a tuple composed of:\n\n- `encoded_layers`: controled by the value of the `output_encoded_layers` argument:\n\n  - `output_all_encoded_layers=True`: outputs a list of the encoded-hidden-states at the end of each attention block (i.e. 12 full sequences for BERT-base, 24 for BERT-large), each encoded-hidden-state is a torch.FloatTensor of size [batch_size, sequence_length, hidden_size],\n  - `output_all_encoded_layers=False`: outputs only the encoded-hidden-states corresponding to the last attention block, i.e. a single torch.FloatTensor of size [batch_size, sequence_length, hidden_size],\n\n- `pooled_output`: a torch.FloatTensor of size [batch_size, hidden_size] which is the output of a classifier pretrained on top of the hidden state associated to the first character of the input (`CLF`) to train on the Next-Sentence task (see BERT's paper).\n\nAn example on how to use this class is given in the [`extract_features.py`](./examples/extract_features.py) script which can be used to extract the hidden states of the model for a given input.\n\n#### 2. `BertForPreTraining`\n\n`BertForPreTraining` includes the `BertModel` Transformer followed by the two pre-training heads:\n\n- the masked language modeling head, and\n- the next sentence classification head.\n\n*Inputs* comprises the inputs of the [`BertModel`](#-1.-`BertModel`) class plus two optional labels:\n\n- `masked_lm_labels`: masked language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size]\n- `next_sentence_label`: next sentence classification loss: torch.LongTensor of shape [batch_size] with indices selected in [0, 1]. 0 => next sentence is the continuation, 1 => next sentence is a random sentence.\n\n*Outputs*:\n\n- if `masked_lm_labels` and `next_sentence_label` are not `None`: Outputs the total_loss which is the sum of the masked language modeling loss and the next sentence classification loss.\n- if `masked_lm_labels` or `next_sentence_label` is `None`: Outputs a tuple comprising\n\n  - the masked language modeling logits, and\n  - the next sentence classification logits.\n\nAn example on how to use this class is given in the [`run_lm_finetuning.py`](./examples/run_lm_finetuning.py) script which can be used to fine-tune the BERT language model on your specific different text corpus. This should improve model performance, if the language style is different from the original BERT training corpus (Wiki + BookCorpus).\n\n\n#### 3. `BertForMaskedLM`\n\n`BertForMaskedLM` includes the `BertModel` Transformer followed by the (possibly) pre-trained  masked language modeling head.\n\n*Inputs* comprises the inputs of the [`BertModel`](#-1.-`BertModel`) class plus optional label:\n\n- `masked_lm_labels`: masked language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size]\n\n*Outputs*:\n\n- if `masked_lm_labels` is not `None`: Outputs the masked language modeling loss.\n- if `masked_lm_labels` is `None`: Outputs the masked language modeling logits.\n\n#### 4. `BertForNextSentencePrediction`\n\n`BertForNextSentencePrediction` includes the `BertModel` Transformer followed by the next sentence classification head.\n\n*Inputs* comprises the inputs of the [`BertModel`](#-1.-`BertModel`) class plus an optional label:\n\n- `next_sentence_label`: next sentence classification loss: torch.LongTensor of shape [batch_size] with indices selected in [0, 1]. 0 => next sentence is the continuation, 1 => next sentence is a random sentence.\n\n*Outputs*:\n\n- if `next_sentence_label` is not `None`: Outputs the next sentence classification loss.\n- if `next_sentence_label` is `None`: Outputs the next sentence classification logits.\n\n#### 5. `BertForSequenceClassification`\n\n`BertForSequenceClassification` is a fine-tuning model that includes `BertModel` and a sequence-level (sequence or pair of sequences) classifier on top of the `BertModel`.\n\nThe sequence-level classifier is a linear layer that takes as input the last hidden state of the first character in the input sequence (see Figures 3a and 3b in the BERT paper).\n\nAn example on how to use this class is given in the [`run_classifier.py`](./examples/run_classifier.py) script which can be used to fine-tune a single sequence (or pair of sequence) classifier using BERT, for example for the MRPC task.\n\n#### 6. `BertForMultipleChoice`\n\n`BertForMultipleChoice` is a fine-tuning model that includes `BertModel` and a linear layer on top of the `BertModel`.\n\nThe linear layer outputs a single value for each choice of a multiple choice problem, then all the outputs corresponding to an instance are passed through a softmax to get the model choice.\n\nThis implementation is largely inspired by the work of OpenAI in [Improving Language Understanding by Generative Pre-Training](https://blog.openai.com/language-unsupervised/) and the answer of Jacob Devlin in the following [issue](https://github.com/google-research/bert/issues/38).\n\nAn example on how to use this class is given in the [`run_swag.py`](./examples/run_swag.py) script which can be used to fine-tune a multiple choice classifier using BERT, for example for the Swag task.\n\n#### 7. `BertForTokenClassification`\n\n`BertForTokenClassification` is a fine-tuning model that includes `BertModel` and a token-level classifier on top of the `BertModel`.\n\nThe token-level classifier is a linear layer that takes as input the last hidden state of the sequence.\n\n#### 8. `BertForQuestionAnswering`\n\n`BertForQuestionAnswering` is a fine-tuning model that includes `BertModel` with a token-level classifiers on top of the full sequence of last hidden states.\n\nThe token-level classifier takes as input the full sequence of the last hidden state and compute several (e.g. two) scores for each tokens that can for example respectively be the score that a given token is a `start_span` and a `end_span` token (see Figures 3c and 3d in the BERT paper).\n\nAn example on how to use this class is given in the [`run_squad.py`](./examples/run_squad.py) script which can be used to fine-tune a token classifier using BERT, for example for the SQuAD task.\n\n#### 9. `OpenAIGPTModel`\n\n`OpenAIGPTModel` is the basic OpenAI GPT Transformer model with a layer of summed token and position embeddings followed by a series of 12 identical self-attention blocks.\n\nOpenAI GPT use a single embedding matrix to store the word and special embeddings.\nSpecial tokens embeddings are additional tokens that are not pre-trained: `[SEP]`, `[CLS]`...\nSpecial tokens need to be trained during the fine-tuning if you use them.\nThe number of special embeddings can be controled using the `set_num_special_tokens(num_special_tokens)` function.\n\nThe embeddings are ordered as follow in the token embeddings matrice:\n\n```python\n    [0,                                                         ----------------------\n      ...                                                        -> word embeddings\n      config.vocab_size - 1,                                     ______________________\n      config.vocab_size,\n      ...                                                        -> special embeddings\n      config.vocab_size + config.n_special - 1]                  ______________________\n```\n\nwhere total_tokens_embeddings can be obtained as config.total_tokens_embeddings and is:\n    `total_tokens_embeddings = config.vocab_size + config.n_special`\nYou should use the associate indices to index the embeddings.\n\nThe inputs and output are **identical to the TensorFlow model inputs and outputs**.\n\nWe detail them here. This model takes as *inputs*:\n[`modeling_openai.py`](./pytorch_pretrained_bert/modeling_openai.py)\n- `input_ids`: a torch.LongTensor of shape [batch_size, sequence_length] (or more generally [d_1, ..., d_n, sequence_length] were d_1 ... d_n are arbitrary dimensions) with the word BPE token indices selected in the range [0, total_tokens_embeddings[\n- `position_ids`: an optional torch.LongTensor with the same shape as input_ids\n    with the position indices (selected in the range [0, config.n_positions - 1[.\n- `token_type_ids`: an optional torch.LongTensor with the same shape as input_ids\n    You can use it to add a third type of embedding to each input token in the sequence\n    (the previous two being the word and position embeddings). The input, position and token_type embeddings are summed inside the Transformer before the first self-attention block.\n\nThis model *outputs*:\n- `hidden_states`: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, hidden_size] (or more generally [d_1, ..., d_n, hidden_size] were d_1 ... d_n are the dimension of input_ids)\n\n#### 10. `OpenAIGPTLMHeadModel`\n\n`OpenAIGPTLMHeadModel` includes the `OpenAIGPTModel` Transformer followed by a language modeling head with weights tied to the input embeddings (no additional parameters).\n\n*Inputs* are the same as the inputs of the [`OpenAIGPTModel`](#-9.-`OpenAIGPTModel`) class plus optional labels:\n- `lm_labels`: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size].\n\n*Outputs*:\n- if `lm_labels` is not `None`:\n  Outputs the language modeling loss.\n- else:\n  Outputs `lm_logits`: the language modeling logits as a torch.FloatTensor of size [batch_size, sequence_length, total_tokens_embeddings] (or more generally [d_1, ..., d_n, total_tokens_embeddings] were d_1 ... d_n are the dimension of input_ids)\n\n#### 11. `OpenAIGPTDoubleHeadsModel`\n\n`OpenAIGPTDoubleHeadsModel` includes the `OpenAIGPTModel` Transformer followed by two heads:\n- a language modeling head with weights tied to the input embeddings (no additional parameters) and:\n- a multiple choice classifier (linear layer that take as input a hidden state in a sequence to compute a score, see details in paper).\n\n*Inputs* are the same as the inputs of the [`OpenAIGPTModel`](#-9.-`OpenAIGPTModel`) class plus a classification mask and two optional labels:\n- `multiple_choice_token_ids`: a torch.LongTensor of shape [batch_size, num_choices] with the index of the token whose hidden state should be used as input for the multiple choice classifier (usually the [CLS] token for each choice).\n- `lm_labels`: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size].\n- `multiple_choice_labels`: optional multiple choice labels: torch.LongTensor of shape [batch_size] with indices selected in [0, ..., num_choices].\n\n*Outputs*:\n- if `lm_labels` and `multiple_choice_labels` are not `None`:\n  Outputs a tuple of losses with the language modeling loss and the multiple choice loss.\n- else Outputs a tuple with:\n  - `lm_logits`: the language modeling logits as a torch.FloatTensor of size [batch_size, num_choices, sequence_length, total_tokens_embeddings]\n  - `multiple_choice_logits`: the multiple choice logits as a torch.FloatTensor of size [batch_size, num_choices]\n\n#### 12. `TransfoXLModel`\n\nThe Transformer-XL model is described in \"Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context\".\n\nTransformer XL use a relative positioning with sinusiodal patterns and adaptive softmax inputs which means that:\n\n- you don't need to specify positioning embeddings indices\n- the tokens in the vocabulary have to be sorted to decreasing frequency.\n\nThis model takes as *inputs*:\n[`modeling_transfo_xl.py`](./pytorch_pretrained_bert/modeling_transfo_xl.py)\n- `input_ids`: a torch.LongTensor of shape [batch_size, sequence_length] with the token indices selected in the range [0, self.config.n_token[\n- `mems`: an optional memory of hidden states from previous forward passes as a list (num layers) of hidden states at the entry of each layer. Each hidden states has shape [self.config.mem_len, bsz, self.config.d_model]. Note that the first two dimensions are transposed in `mems` with regards to `input_ids`.\n\nThis model *outputs* a tuple of (last_hidden_state, new_mems)\n- `last_hidden_state`: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, self.config.d_model]\n- `new_mems`: list (num layers) of updated mem states at the entry of each layer each mem state is a torch.FloatTensor of size [self.config.mem_len, batch_size, self.config.d_model]. Note that the first two dimensions are transposed in `mems` with regards to `input_ids`.\n\n##### Extracting a list of the hidden states at each layer of the Transformer-XL from `last_hidden_state` and `new_mems`:\nThe `new_mems` contain all the hidden states PLUS the output of the embeddings (`new_mems[0]`). `new_mems[-1]` is the output of the hidden state of the layer below the last layer and `last_hidden_state` is the output of the last layer (i.E. the input of the softmax when we have a language modeling head on top).\n\nThere are two differences between the shapes of `new_mems` and `last_hidden_state`: `new_mems` have transposed first dimensions and are longer (of size `self.config.mem_len`). Here is how to extract the full list of hidden states from the model output:\n\n```python\nhidden_states, mems = model(tokens_tensor)\nseq_length = hidden_states.size(1)\nlower_hidden_states = list(t[-seq_length:, ...].transpose(0, 1) for t in mems)\nall_hidden_states = lower_hidden_states + [hidden_states]\n```\n\n#### 13. `TransfoXLLMHeadModel`\n\n`TransfoXLLMHeadModel` includes the `TransfoXLModel` Transformer followed by an (adaptive) softmax head with weights tied to the input embeddings.\n\n*Inputs* are the same as the inputs of the [`TransfoXLModel`](#-12.-`TransfoXLModel`) class plus optional labels:\n- `target`: an optional torch.LongTensor of shape [batch_size, sequence_length] with the target token indices selected in the range [0, self.config.n_token[\n\n*Outputs* a tuple of (last_hidden_state, new_mems)\n- `softmax_output`: output of the (adaptive) softmax:\n  - if target is None: log probabilities of tokens, shape [batch_size, sequence_length, n_tokens] \n  - else: Negative log likelihood of target tokens with shape [batch_size, sequence_length]\n- `new_mems`: list (num layers) of updated mem states at the entry of each layer each mem state is a torch.FloatTensor of size [self.config.mem_len, batch_size, self.config.d_model]. Note that the first two dimensions are transposed in `mems` with regards to `input_ids`.\n\n#### 14. `GPT2Model`\n\n`GPT2Model` is the OpenAI GPT-2 Transformer model with a layer of summed token and position embeddings followed by a series of 12 identical self-attention blocks.\n\nThe inputs and output are **identical to the TensorFlow model inputs and outputs**.\n\nWe detail them here. This model takes as *inputs*:\n[`modeling_gpt2.py`](./pytorch_pretrained_bert/modeling_gpt2.py)\n- `input_ids`: a torch.LongTensor of shape [batch_size, sequence_length] (or more generally [d_1, ..., d_n, sequence_length] were d_1 ... d_n are arbitrary dimensions) with the word BPE token indices selected in the range [0, vocab_size[\n- `position_ids`: an optional torch.LongTensor with the same shape as input_ids\n    with the position indices (selected in the range [0, config.n_positions - 1[.\n- `token_type_ids`: an optional torch.LongTensor with the same shape as input_ids\n    You can use it to add a third type of embedding to each input token in the sequence\n    (the previous two being the word and position embeddings). The input, position and token_type embeddings are summed inside the Transformer before the first self-attention block.\n- `past`: an optional list of torch.LongTensor that contains pre-computed hidden-states (key and values in the attention blocks) to speed up sequential decoding (this is the `presents` output of the model, cf. below).\n\nThis model *outputs*:\n- `hidden_states`: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, hidden_size] (or more generally [d_1, ..., d_n, hidden_size] were d_1 ... d_n are the dimension of input_ids)\n- `presents`: a list of pre-computed hidden-states (key and values in each attention blocks) as a torch.FloatTensors. They can be reused to speed up sequential decoding (see the `run_gpt2.py` example).\n\n#### 15. `GPT2LMHeadModel`\n\n`GPT2LMHeadModel` includes the `GPT2Model` Transformer followed by a language modeling head with weights tied to the input embeddings (no additional parameters).\n\n*Inputs* are the same as the inputs of the [`GPT2Model`](#-14.-`GPT2Model`) class plus optional labels:\n- `lm_labels`: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size].\n\n*Outputs*:\n- if `lm_labels` is not `None`:\n  Outputs the language modeling loss.\n- else: a tuple of\n  - `lm_logits`: the language modeling logits as a torch.FloatTensor of size [batch_size, sequence_length, total_tokens_embeddings] (or more generally [d_1, ..., d_n, total_tokens_embeddings] were d_1 ... d_n are the dimension of input_ids)\n  - `presents`: a list of pre-computed hidden-states (key and values in each attention blocks) as a torch.FloatTensors. They can be reused to speed up sequential decoding (see the `run_gpt2.py` example).\n\n#### 16. `GPT2DoubleHeadsModel`\n\n`GPT2DoubleHeadsModel` includes the `GPT2Model` Transformer followed by two heads:\n- a language modeling head with weights tied to the input embeddings (no additional parameters) and:\n- a multiple choice classifier (linear layer that take as input a hidden state in a sequence to compute a score, see details in paper).\n\n*Inputs* are the same as the inputs of the [`GPT2Model`](#-14.-`GPT2Model`) class plus a classification mask and two optional labels:\n- `multiple_choice_token_ids`: a torch.LongTensor of shape [batch_size, num_choices] with the index of the token whose hidden state should be used as input for the multiple choice classifier (usually the [CLS] token for each choice).\n- `lm_labels`: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size].\n- `multiple_choice_labels`: optional multiple choice labels: torch.LongTensor of shape [batch_size] with indices selected in [0, ..., num_choices].\n\n*Outputs*:\n- if `lm_labels` and `multiple_choice_labels` are not `None`:\n  Outputs a tuple of losses with the language modeling loss and the multiple choice loss.\n- else Outputs a tuple with:\n  - `lm_logits`: the language modeling logits as a torch.FloatTensor of size [batch_size, num_choices, sequence_length, total_tokens_embeddings]\n  - `multiple_choice_logits`: the multiple choice logits as a torch.FloatTensor of size [batch_size, num_choices]\n  - `presents`: a list of pre-computed hidden-states (key and values in each attention blocks) as a torch.FloatTensors. They can be reused to speed up sequential decoding (see the `run_gpt2.py` example).\n\n### Tokenizers\n\n#### `BertTokenizer`\n\n`BertTokenizer` perform end-to-end tokenization, i.e. basic tokenization followed by WordPiece tokenization.\n\nThis class has five arguments:\n\n- `vocab_file`: path to a vocabulary file.\n- `do_lower_case`: convert text to lower-case while tokenizing. **Default = True**.\n- `max_len`: max length to filter the input of the Transformer. Default to pre-trained value for the model if `None`. **Default = None**\n- `do_basic_tokenize`: Do basic tokenization before wordpice tokenization. Set to false if text is pre-tokenized. **Default = True**.\n- `never_split`: a list of tokens that should not be splitted during tokenization. **Default = `[\"[UNK]\", \"[SEP]\", \"[PAD]\", \"[CLS]\", \"[MASK]\"]`**\n\nand three methods:\n\n- `tokenize(text)`: convert a `str` in a list of `str` tokens by (1) performing basic tokenization and (2) WordPiece tokenization.\n- `convert_tokens_to_ids(tokens)`: convert a list of `str` tokens in a list of `int` indices in the vocabulary.\n- `convert_ids_to_tokens(tokens)`: convert a list of `int` indices in a list of `str` tokens in the vocabulary.\n- `save_vocabulary(directory_path)`: save the vocabulary file to `directory_path`. Return the path to the saved vocabulary file: `vocab_file_path`. The vocabulary can be reloaded with `BertTokenizer.from_pretrained('vocab_file_path')` or `BertTokenizer.from_pretrained('directory_path')`.\n\nPlease refer to the doc strings and code in [`tokenization.py`](./pytorch_pretrained_bert/tokenization.py) for the details of the `BasicTokenizer` and `WordpieceTokenizer` classes. In general it is recommended to use `BertTokenizer` unless you know what you are doing.\n\n#### `OpenAIGPTTokenizer`\n\n`OpenAIGPTTokenizer` perform Byte-Pair-Encoding (BPE) tokenization.\n\nThis class has four arguments:\n\n- `vocab_file`: path to a vocabulary file.\n- `merges_file`: path to a file containing the BPE merges.\n- `max_len`: max length to filter the input of the Transformer. Default to pre-trained value for the model if `None`. **Default = None**\n- `special_tokens`: a list of tokens to add to the vocabulary for fine-tuning. If SpaCy is not installed and BERT's `BasicTokenizer` is used as the pre-BPE tokenizer, these tokens are not split. **Default= None**\n\nand five methods:\n\n- `tokenize(text)`: convert a `str` in a list of `str` tokens by performing BPE tokenization.\n- `convert_tokens_to_ids(tokens)`: convert a list of `str` tokens in a list of `int` indices in the vocabulary.\n- `convert_ids_to_tokens(tokens)`: convert a list of `int` indices in a list of `str` tokens in the vocabulary.\n- `set_special_tokens(self, special_tokens)`: update the list of special tokens (see above arguments)\n- `encode(text)`: convert a `str` in a list of `int` tokens by performing BPE encoding.\n- `decode(ids, skip_special_tokens=False, clean_up_tokenization_spaces=False)`: decode a list of `int` indices in a string and do some post-processing if needed: (i) remove special tokens from the output and (ii) clean up tokenization spaces.\n- `save_vocabulary(directory_path)`: save the vocabulary, merge and special tokens files to `directory_path`. Return the path to the three files: `vocab_file_path`, `merge_file_path`, `special_tokens_file_path`. The vocabulary can be reloaded with `OpenAIGPTTokenizer.from_pretrained('directory_path')`.\n\nPlease refer to the doc strings and code in [`tokenization_openai.py`](./pytorch_pretrained_bert/tokenization_openai.py) for the details of the `OpenAIGPTTokenizer`.\n\n#### `TransfoXLTokenizer`\n\n`TransfoXLTokenizer` perform word tokenization. This tokenizer can be used for adaptive softmax and has utilities for counting tokens in a corpus to create a vocabulary ordered by toekn frequency (for adaptive softmax). See the adaptive softmax paper ([Efficient softmax approximation for GPUs](http://arxiv.org/abs/1609.04309)) for more details.\n\nThe API is similar to the API of `BertTokenizer` (see above).\n\nPlease refer to the doc strings and code in [`tokenization_transfo_xl.py`](./pytorch_pretrained_bert/tokenization_transfo_xl.py) for the details of these additional methods in `TransfoXLTokenizer`.\n\n#### `GPT2Tokenizer`\n\n`GPT2Tokenizer` perform byte-level Byte-Pair-Encoding (BPE) tokenization.\n\nThis class has three arguments:\n\n- `vocab_file`: path to a vocabulary file.\n- `merges_file`: path to a file containing the BPE merges.\n- `errors`: How to handle unicode decoding errors. **Default = `replace`**\n\nand two methods:\n\n- `tokenize(text)`: convert a `str` in a list of `str` tokens by performing byte-level BPE.\n- `convert_tokens_to_ids(tokens)`: convert a list of `str` tokens in a list of `int` indices in the vocabulary.\n- `convert_ids_to_tokens(tokens)`: convert a list of `int` indices in a list of `str` tokens in the vocabulary.\n- `set_special_tokens(self, special_tokens)`: update the list of special tokens (see above arguments)\n- `encode(text)`: convert a `str` in a list of `int` tokens by performing byte-level BPE.\n- `decode(tokens)`: convert back a list of `int` tokens in a `str`.\n- `save_vocabulary(directory_path)`: save the vocabulary, merge and special tokens files to `directory_path`. Return the path to the three files: `vocab_file_path`, `merge_file_path`, `special_tokens_file_path`. The vocabulary can be reloaded with `OpenAIGPTTokenizer.from_pretrained('directory_path')`.\n\nPlease refer to [`tokenization_gpt2.py`](./pytorch_pretrained_bert/tokenization_gpt2.py) for more details on the `GPT2Tokenizer`.\n\n### Optimizers\n\n#### `BertAdam`\n\n`BertAdam` is a `torch.optimizer` adapted to be closer to the optimizer used in the TensorFlow implementation of Bert. The differences with PyTorch Adam optimizer are the following:\n\n- BertAdam implements weight decay fix,\n- BertAdam doesn't compensate for bias as in the regular Adam optimizer.\n\nThe optimizer accepts the following arguments:\n\n- `lr` : learning rate\n- `warmup` : portion of `t_total` for the warmup, `-1`  means no warmup. Default : `-1`\n- `t_total` : total number of training steps for the learning\n    rate schedule, `-1`  means constant learning rate. Default : `-1`\n- `schedule` : schedule to use for the warmup (see above).\n    Can be `'warmup_linear'`, `'warmup_constant'`, `'warmup_cosine'`, `'none'`, `None` or a `_LRSchedule` object (see below).\n    If `None` or `'none'`, learning rate is always kept constant.\n    Default : `'warmup_linear'`\n- `b1` : Adams b1. Default : `0.9`\n- `b2` : Adams b2. Default : `0.999`\n- `e` : Adams epsilon. Default : `1e-6`\n- `weight_decay:` Weight decay. Default : `0.01`\n- `max_grad_norm` : Maximum norm for the gradients (`-1` means no clipping). Default : `1.0`\n\n#### `OpenAIAdam`\n\n`OpenAIAdam` is similar to `BertAdam`.\nThe differences with `BertAdam` is that `OpenAIAdam` compensate for bias as in the regular Adam optimizer.\n\n`OpenAIAdam` accepts the same arguments as `BertAdam`.\n\n#### Learning Rate Schedules\nThe `.optimization` module also provides additional schedules in the form of schedule objects that inherit from `_LRSchedule`.\nAll `_LRSchedule` subclasses accept `warmup` and `t_total` arguments at construction.\nWhen an `_LRSchedule` object is passed into `BertAdam` or `OpenAIAdam`, \nthe `warmup` and `t_total` arguments on the optimizer are ignored and the ones in the `_LRSchedule` object are used. \nAn overview of the implemented schedules:\n- `ConstantLR`: always returns learning rate 1.\n- `WarmupConstantSchedule`: Linearly increases learning rate from 0 to 1 over `warmup` fraction of training steps.\n    Keeps learning rate equal to 1. after warmup.\n    ![](docs/imgs/warmup_constant_schedule.png)\n- `WarmupLinearSchedule`: Linearly increases learning rate from 0 to 1 over `warmup` fraction of training steps.\n    Linearly decreases learning rate from 1. to 0. over remaining `1 - warmup` steps.\n    ![](docs/imgs/warmup_linear_schedule.png)\n-  `WarmupCosineSchedule`: Linearly increases learning rate from 0 to 1 over `warmup` fraction of training steps.\n    Decreases learning rate from 1. to 0. over remaining `1 - warmup` steps following a cosine curve.\n    If `cycles` (default=0.5) is different from default, learning rate follows cosine function after warmup.\n    ![](docs/imgs/warmup_cosine_schedule.png)\n- `WarmupCosineWithHardRestartsSchedule`: Linearly increases learning rate from 0 to 1 over `warmup` fraction of training steps.\n    If `cycles` (default=1.) is different from default, learning rate follows `cycles` times a cosine decaying learning rate (with hard restarts).\n    ![](docs/imgs/warmup_cosine_hard_restarts_schedule.png)\n- `WarmupCosineWithWarmupRestartsSchedule`: All training progress is divided in `cycles` (default=1.) parts of equal length.\n    Every part follows a schedule with the first `warmup` fraction of the training steps linearly increasing from 0. to 1.,\n    followed by a learning rate decreasing from 1. to 0. following a cosine curve.\n    Note that the total number of all warmup steps over all cycles together is equal to `warmup` * `cycles`\n    ![](docs/imgs/warmup_cosine_warm_restarts_schedule.png)\n\n## Examples\n\n| Sub-section | Description |\n|-|-|\n| [Training large models: introduction, tools and examples](#Training-large-models-introduction,-tools-and-examples) | How to use gradient-accumulation, multi-gpu training, distributed training, optimize on CPU and 16-bits training to train Bert models |\n| [Fine-tuning with BERT: running the examples](#Fine-tuning-with-BERT-running-the-examples) | Running the examples in [`./examples`](./examples/): `extract_classif.py`, `run_classifier.py`, `run_squad.py` and `run_lm_finetuning.py` |\n| [Fine-tuning with OpenAI GPT, Transformer-XL and GPT-2](#Fine-tuning-with-OpenAI-GPT-Transformer-XL-and-GPT-2) | Running the examples in [`./examples`](./examples/): `run_openai_gpt.py`, `run_transfo_xl.py` and `run_gpt2.py` |\n| [Fine-tuning BERT-large on GPUs](#Fine-tuning-BERT-large-on-GPUs) | How to fine tune `BERT large`|\n\n### Training large models: introduction, tools and examples\n\nBERT-base and BERT-large are respectively 110M and 340M parameters models and it can be difficult to fine-tune them on a single GPU with the recommended batch size for good performance (in most case a batch size of 32).\n\nTo help with fine-tuning these models, we have included several techniques that you can activate in the fine-tuning scripts [`run_classifier.py`](./examples/run_classifier.py) and [`run_squad.py`](./examples/run_squad.py): gradient-accumulation, multi-gpu training, distributed training and 16-bits training . For more details on how to use these techniques you can read [the tips on training large batches in PyTorch](https://medium.com/huggingface/training-larger-batches-practical-tips-on-1-gpu-multi-gpu-distributed-setups-ec88c3e51255) that I published earlier this month.\n\nHere is how to use these techniques in our scripts:\n\n- **Gradient Accumulation**: Gradient accumulation can be used by supplying a integer greater than 1 to the `--gradient_accumulation_steps` argument. The batch at each step will be divided by this integer and gradient will be accumulated over `gradient_accumulation_steps` steps.\n- **Multi-GPU**: Multi-GPU is automatically activated when several GPUs are detected and the batches are splitted over the GPUs.\n- **Distributed training**: Distributed training can be activated by supplying an integer greater or equal to 0 to the `--local_rank` argument (see below).\n- **16-bits training**: 16-bits training, also called mixed-precision training, can reduce the memory requirement of your model on the GPU by using half-precision training, basically allowing to double the batch size. If you have a recent GPU (starting from NVIDIA Volta architecture) you should see no decrease in speed. A good introduction to Mixed precision training can be found [here](https://devblogs.nvidia.com/mixed-precision-training-deep-neural-networks/) and a full documentation is [here](https://docs.nvidia.com/deeplearning/sdk/mixed-precision-training/index.html). In our scripts, this option can be activated by setting the `--fp16` flag and you can play with loss scaling using the `--loss_scale` flag (see the previously linked documentation for details on loss scaling). The loss scale can be zero in which case the scale is dynamically adjusted or a positive power of two in which case the scaling is static.\n\nTo use 16-bits training and distributed training, you need to install NVIDIA's apex extension [as detailed here](https://github.com/nvidia/apex). You will find more information regarding the internals of `apex` and how to use `apex` in [the doc and the associated repository](https://github.com/nvidia/apex). The results of the tests performed on pytorch-BERT by the NVIDIA team (and my trials at reproducing them) can be consulted in [the relevant PR of the present repository](https://github.com/huggingface/pytorch-pretrained-BERT/pull/116).\n\nNote: To use *Distributed Training*, you will need to run one training script on each of your machines. This can be done for example by running the following command on each server (see [the above mentioned blog post]((https://medium.com/huggingface/training-larger-batches-practical-tips-on-1-gpu-multi-gpu-distributed-setups-ec88c3e51255)) for more details):\n```bash\npython -m torch.distributed.launch --nproc_per_node=4 --nnodes=2 --node_rank=$THIS_MACHINE_INDEX --master_addr=\"192.168.1.1\" --master_port=1234 run_classifier.py (--arg1 --arg2 --arg3 and all other arguments of the run_classifier script)\n```\nWhere `$THIS_MACHINE_INDEX` is an sequential index assigned to each of your machine (0, 1, 2...) and the machine with rank 0 has an IP address `192.168.1.1` and an open port `1234`.\n\n### Fine-tuning with BERT: running the examples\n\nWe showcase several fine-tuning examples based on (and extended from) [the original implementation](https://github.com/google-research/bert/):\n\n- a *sequence-level classifier* on nine different GLUE tasks,\n- a *token-level classifier* on the question answering dataset SQuAD, and\n- a *sequence-level multiple-choice classifier* on the SWAG classification corpus.\n- a *BERT language model* on another target corpus\n\n#### GLUE results on dev set\n\nWe get the following results on the dev set of GLUE benchmark with an uncased BERT base \nmodel. All experiments were run on a P100 GPU with a batch size of 32.\n\n| Task | Metric | Result |\n|-|-|-|\n| CoLA | Matthew's corr. | 57.29 |\n| SST-2 | accuracy | 93.00 |\n| MRPC | F1/accuracy | 88.85/83.82 |\n| STS-B | Pearson/Spearman corr. | 89.70/89.37 |\n| QQP | accuracy/F1 | 90.72/87.41 |\n| MNLI | matched acc./mismatched acc.| 83.95/84.39 |\n| QNLI | accuracy | 89.04 |\n| RTE | accuracy | 61.01 |\n| WNLI | accuracy | 53.52 |\n\nSome of these results are significantly different from the ones reported on the test set\nof GLUE benchmark on the website. For QQP and WNLI, please refer to [FAQ #12](https://gluebenchmark.com/faq) on the webite.\n\nBefore running anyone of these GLUE tasks you should download the\n[GLUE data](https://gluebenchmark.com/tasks) by running\n[this script](https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e)\nand unpack it to some directory `$GLUE_DIR`.\n\n```shell\nexport GLUE_DIR=/path/to/glue\nexport TASK_NAME=MRPC\n\npython run_classifier.py \\\n  --task_name $TASK_NAME \\\n  --do_train \\\n  --do_eval \\\n  --do_lower_case \\\n  --data_dir $GLUE_DIR/$TASK_NAME \\\n  --bert_model bert-base-uncased \\\n  --max_seq_length 128 \\\n  --train_batch_size 32 \\\n  --learning_rate 2e-5 \\\n  --num_train_epochs 3.0 \\\n  --output_dir /tmp/$TASK_NAME/\n```\n\nwhere task name can be one of CoLA, SST-2, MRPC, STS-B, QQP, MNLI, QNLI, RTE, WNLI.\n\nThe dev set results will be present within the text file 'eval_results.txt' in the specified output_dir. In case of MNLI, since there are two separate dev sets, matched and mismatched, there will be a separate output folder called '/tmp/MNLI-MM/' in addition to '/tmp/MNLI/'.\n\nThe code has not been tested with half-precision training with apex on any GLUE task apart from MRPC, MNLI, CoLA, SST-2. The following section provides details on how to run half-precision training with MRPC. With that being said, there shouldn't be any issues in running half-precision training with the remaining GLUE tasks as well, since the data processor for each task inherits from the base class DataProcessor.\n\n#### MRPC\n\nThis example code fine-tunes BERT on the Microsoft Research Paraphrase\nCorpus (MRPC) corpus and runs in less than 10 minutes on a single K-80 and in 27 seconds (!) on single tesla V100 16GB with apex installed.\n\nBefore running this example you should download the\n[GLUE data](https://gluebenchmark.com/tasks) by running\n[this script](https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e)\nand unpack it to some directory `$GLUE_DIR`.\n\n```shell\nexport GLUE_DIR=/path/to/glue\n\npython run_classifier.py \\\n  --task_name MRPC \\\n  --do_train \\\n  --do_eval \\\n  --do_lower_case \\\n  --data_dir $GLUE_DIR/MRPC/ \\\n  --bert_model bert-base-uncased \\\n  --max_seq_length 128 \\\n  --train_batch_size 32 \\\n  --learning_rate 2e-5 \\\n  --num_train_epochs 3.0 \\\n  --output_dir /tmp/mrpc_output/\n```\n\nOur test ran on a few seeds with [the original implementation hyper-parameters](https://github.com/google-research/bert#sentence-and-sentence-pair-classification-tasks) gave evaluation results between 84% and 88%.\n\n**Fast run with apex and 16 bit precision: fine-tuning on MRPC in 27 seconds!**\nFirst install apex as indicated [here](https://github.com/NVIDIA/apex).\nThen run\n```shell\nexport GLUE_DIR=/path/to/glue\n\npython run_classifier.py \\\n  --task_name MRPC \\\n  --do_train \\\n  --do_eval \\\n  --do_lower_case \\\n  --data_dir $GLUE_DIR/MRPC/ \\\n  --bert_model bert-base-uncased \\\n  --max_seq_length 128 \\\n  --train_batch_size 32 \\\n  --learning_rate 2e-5 \\\n  --num_train_epochs 3.0 \\\n  --output_dir /tmp/mrpc_output/ \\\n  --fp16\n```\n\n#### SQuAD\n\nThis example code fine-tunes BERT on the SQuAD dataset. It runs in 24 min (with BERT-base) or 68 min (with BERT-large) on a single tesla V100 16GB.\n\nThe data for SQuAD can be downloaded with the following links and should be saved in a `$SQUAD_DIR` directory.\n\n*   [train-v1.1.json](https://rajpurkar.github.io/SQuAD-explorer/dataset/train-v1.1.json)\n*   [dev-v1.1.json](https://rajpurkar.github.io/SQuAD-explorer/dataset/dev-v1.1.json)\n*   [evaluate-v1.1.py](https://github.com/allenai/bi-att-flow/blob/master/squad/evaluate-v1.1.py)\n\n```shell\nexport SQUAD_DIR=/path/to/SQUAD\n\npython run_squad.py \\\n  --bert_model bert-base-uncased \\\n  --do_train \\\n  --do_predict \\\n  --do_lower_case \\\n  --train_file $SQUAD_DIR/train-v1.1.json \\\n  --predict_file $SQUAD_DIR/dev-v1.1.json \\\n  --train_batch_size 12 \\\n  --learning_rate 3e-5 \\\n  --num_train_epochs 2.0 \\\n  --max_seq_length 384 \\\n  --doc_stride 128 \\\n  --output_dir /tmp/debug_squad/\n```\n\nTraining with the previous hyper-parameters gave us the following results:\n```bash\n{\"f1\": 88.52381567990474, \"exact_match\": 81.22043519394512}\n```\n\n#### SWAG\n\nThe data for SWAG can be downloaded by cloning the following [repository](https://github.com/rowanz/swagaf)\n\n```shell\nexport SWAG_DIR=/path/to/SWAG\n\npython run_swag.py \\\n  --bert_model bert-base-uncased \\\n  --do_train \\\n  --do_lower_case \\\n  --do_eval \\\n  --data_dir $SWAG_DIR/data \\\n  --train_batch_size 16 \\\n  --learning_rate 2e-5 \\\n  --num_train_epochs 3.0 \\\n  --max_seq_length 80 \\\n  --output_dir /tmp/swag_output/ \\\n  --gradient_accumulation_steps 4\n```\n\nTraining with the previous hyper-parameters on a single GPU gave us the following results:\n```\neval_accuracy = 0.8062081375587323\neval_loss = 0.5966546792367169\nglobal_step = 13788\nloss = 0.06423990014260186\n```\n\n#### LM Fine-tuning\n\nThe data should be a text file in the same format as [sample_text.txt](./samples/sample_text.txt)  (one sentence per line, docs separated by empty line).\nYou can download an [exemplary training corpus](https://ext-bert-sample.obs.eu-de.otc.t-systems.com/small_wiki_sentence_corpus.txt) generated from wikipedia articles and splitted into ~500k sentences with spaCy.\nTraining one epoch on this corpus takes about 1:20h on 4 x NVIDIA Tesla P100 with `train_batch_size=200` and `max_seq_length=128`:\n\n\nThank to the work of @Rocketknight1 and @tholor there are now **several scripts** that can be used to fine-tune BERT using the pretraining objective (combination of masked-language modeling and next sentence prediction loss). These scripts are detailed in the [`README`](./examples/lm_finetuning/README.md) of the [`examples/lm_finetuning/`](./examples/lm_finetuning/) folder.\n\n### OpenAI GPT, Transformer-XL and GPT-2: running the examples\n\nWe provide three examples of scripts for OpenAI GPT, Transformer-XL and OpenAI GPT-2 based on (and extended from) the respective original implementations:\n\n- fine-tuning OpenAI GPT on the ROCStories dataset\n- evaluating Transformer-XL on Wikitext 103\n- unconditional and conditional generation from a pre-trained OpenAI GPT-2 model\n\n#### Fine-tuning OpenAI GPT on the RocStories dataset\n\nThis example code fine-tunes OpenAI GPT on the RocStories dataset.\n\nBefore running this example you should download the\n[RocStories dataset](https://github.com/snigdhac/StoryComprehension_EMNLP/tree/master/Dataset/RoCStories) and unpack it to some directory `$ROC_STORIES_DIR`.\n\n```shell\nexport ROC_STORIES_DIR=/path/to/RocStories\n\npython run_openai_gpt.py \\\n  --model_name openai-gpt \\\n  --do_train \\\n  --do_eval \\\n  --train_dataset $ROC_STORIES_DIR/cloze_test_val__spring2016\\ -\\ cloze_test_ALL_val.csv \\\n  --eval_dataset $ROC_STORIES_DIR/cloze_test_test__spring2016\\ -\\ cloze_test_ALL_test.csv \\\n  --output_dir ../log \\\n  --train_batch_size 16 \\\n```\n\nThis command runs in about 10 min on a single K-80 an gives an evaluation accuracy of about 87.7% (the authors report a median accuracy with the TensorFlow code of 85.8% and the OpenAI GPT paper reports a best single run accuracy of 86.5%).\n\n#### Evaluating the pre-trained Transformer-XL on the WikiText 103 dataset\n\nThis example code evaluate the pre-trained Transformer-XL on the WikiText 103 dataset.\nThis command will download a pre-processed version of the WikiText 103 dataset in which the vocabulary has been computed.\n\n```shell\npython run_transfo_xl.py --work_dir ../log\n```\n\nThis command runs in about 1 min on a V100 and gives an evaluation perplexity of 18.22 on WikiText-103 (the authors report a perplexity of about 18.3 on this dataset with the TensorFlow code).\n\n#### Unconditional and conditional generation from OpenAI's GPT-2 model\n\nThis example code is identical to the original unconditional and conditional generation codes.\n\nConditional generation:\n```shell\npython run_gpt2.py\n```\n\nUnconditional generation:\n```shell\npython run_gpt2.py --unconditional\n```\n\nThe same option as in the original scripts are provided, please refere to the code of the example and the original repository of OpenAI.\n\n## Fine-tuning BERT-large on GPUs\n\nThe options we list above allow to fine-tune BERT-large rather easily on GPU(s) instead of the TPU used by the original implementation.\n\nFor example, fine-tuning BERT-large on SQuAD can be done on a server with 4 k-80 (these are pretty old now) in 18 hours. Our results are similar to the TensorFlow implementation results (actually slightly higher):\n```bash\n{\"exact_match\": 84.56953642384106, \"f1\": 91.04028647786927}\n```\nTo get these results we used a combination of:\n- multi-GPU training (automatically activated on a multi-GPU server),\n- 2 steps of gradient accumulation and\n- perform the optimization step on CPU to store Adam's averages in RAM.\n\nHere is the full list of hyper-parameters for this run:\n```bash\nexport SQUAD_DIR=/path/to/SQUAD\n\npython ./run_squad.py \\\n  --bert_model bert-large-uncased \\\n  --do_train \\\n  --do_predict \\\n  --do_lower_case \\\n  --train_file $SQUAD_DIR/train-v1.1.json \\\n  --predict_file $SQUAD_DIR/dev-v1.1.json \\\n  --learning_rate 3e-5 \\\n  --num_train_epochs 2 \\\n  --max_seq_length 384 \\\n  --doc_stride 128 \\\n  --output_dir /tmp/debug_squad/ \\\n  --train_batch_size 24 \\\n  --gradient_accumulation_steps 2\n```\n\nIf you have a recent GPU (starting from NVIDIA Volta series), you should try **16-bit fine-tuning** (FP16).\n\nHere is an example of hyper-parameters for a FP16 run we tried:\n```bash\nexport SQUAD_DIR=/path/to/SQUAD\n\npython ./run_squad.py \\\n  --bert_model bert-large-uncased \\\n  --do_train \\\n  --do_predict \\\n  --do_lower_case \\\n  --train_file $SQUAD_DIR/train-v1.1.json \\\n  --predict_file $SQUAD_DIR/dev-v1.1.json \\\n  --learning_rate 3e-5 \\\n  --num_train_epochs 2 \\\n  --max_seq_length 384 \\\n  --doc_stride 128 \\\n  --output_dir /tmp/debug_squad/ \\\n  --train_batch_size 24 \\\n  --fp16 \\\n  --loss_scale 128\n```\n\nThe results were similar to the above FP32 results (actually slightly higher):\n```bash\n{\"exact_match\": 84.65468306527909, \"f1\": 91.238669287002}\n```\n\n## Notebooks\n\nWe include [three Jupyter Notebooks](https://github.com/huggingface/pytorch-pretrained-BERT/tree/master/notebooks) that can be used to check that the predictions of the PyTorch model are identical to the predictions of the original TensorFlow model.\n\n- The first NoteBook ([Comparing-TF-and-PT-models.ipynb](./notebooks/Comparing-TF-and-PT-models.ipynb)) extracts the hidden states of a full sequence on each layers of the TensorFlow and the PyTorch models and computes the standard deviation between them. In the given example, we get a standard deviation of 1.5e-7 to 9e-7 on the various hidden state of the models.\n\n- The second NoteBook ([Comparing-TF-and-PT-models-SQuAD.ipynb](./notebooks/Comparing-TF-and-PT-models-SQuAD.ipynb)) compares the loss computed by the TensorFlow and the PyTorch models for identical initialization of the fine-tuning layer of the `BertForQuestionAnswering` and computes the standard deviation between them. In the given example, we get a standard deviation of 2.5e-7 between the models.\n\n- The third NoteBook ([Comparing-TF-and-PT-models-MLM-NSP.ipynb](./notebooks/Comparing-TF-and-PT-models-MLM-NSP.ipynb)) compares the predictions computed by the TensorFlow and the PyTorch models for masked token language modeling using the pre-trained masked language modeling model.\n\nPlease follow the instructions given in the notebooks to run and modify them.\n\n## Command-line interface\n\nA command-line interface is provided to convert a TensorFlow checkpoint in a PyTorch dump of the `BertForPreTraining` class  (for BERT) or NumPy checkpoint in a PyTorch dump of the `OpenAIGPTModel` class  (for OpenAI GPT).\n\n### BERT\n\nYou can convert any TensorFlow checkpoint for BERT (in particular [the pre-trained models released by Google](https://github.com/google-research/bert#pre-trained-models)) in a PyTorch save file by using the [`convert_tf_checkpoint_to_pytorch.py`](./pytorch_pretrained_bert/convert_tf_checkpoint_to_pytorch.py ) script.\n\nThis CLI takes as input a TensorFlow checkpoint (three files starting with `bert_model.ckpt`) and the associated configuration file (`bert_config.json`), and creates a PyTorch model for this configuration, loads the weights from the TensorFlow checkpoint in the PyTorch model and saves the resulting model in a standard PyTorch save file that can be imported using `torch.load()` (see examples in [`extract_features.py`](./examples/extract_features.py), [`run_classifier.py`](./examples/run_classifier.py) and [`run_squad.py`](./examples/run_squad.py)).\n\nYou only need to run this conversion script **once** to get a PyTorch model. You can then disregard the TensorFlow checkpoint (the three files starting with `bert_model.ckpt`) but be sure to keep the configuration file (`bert_config.json`) and the vocabulary file (`vocab.txt`) as these are needed for the PyTorch model too.\n\nTo run this specific conversion script you will need to have TensorFlow and PyTorch installed (`pip install tensorflow`). The rest of the repository only requires PyTorch.\n\nHere is an example of the conversion process for a pre-trained `BERT-Base Uncased` model:\n\n```shell\nexport BERT_BASE_DIR=/path/to/bert/uncased_L-12_H-768_A-12\n\npytorch_pretrained_bert convert_tf_checkpoint_to_pytorch \\\n  $BERT_BASE_DIR/bert_model.ckpt \\\n  $BERT_BASE_DIR/bert_config.json \\\n  $BERT_BASE_DIR/pytorch_model.bin\n```\n\nYou can download Google's pre-trained models for the conversion [here](https://github.com/google-research/bert#pre-trained-models).\n\n### OpenAI GPT\n\nHere is an example of the conversion process for a pre-trained OpenAI GPT model, assuming that your NumPy checkpoint save as the same format than OpenAI pretrained model (see [here](https://github.com/openai/finetune-transformer-lm))\n\n```shell\nexport OPENAI_GPT_CHECKPOINT_FOLDER_PATH=/path/to/openai/pretrained/numpy/weights\n\npytorch_pretrained_bert convert_openai_checkpoint \\\n  $OPENAI_GPT_CHECKPOINT_FOLDER_PATH \\\n  $PYTORCH_DUMP_OUTPUT \\\n  [OPENAI_GPT_CONFIG]\n```\n\n### Transformer-XL\n\nHere is an example of the conversion process for a pre-trained Transformer-XL model (see [here](https://github.com/kimiyoung/transformer-xl/tree/master/tf#obtain-and-evaluate-pretrained-sota-models))\n\n```shell\nexport TRANSFO_XL_CHECKPOINT_FOLDER_PATH=/path/to/transfo/xl/checkpoint\n\npytorch_pretrained_bert convert_transfo_xl_checkpoint \\\n  $TRANSFO_XL_CHECKPOINT_FOLDER_PATH \\\n  $PYTORCH_DUMP_OUTPUT \\\n  [TRANSFO_XL_CONFIG]\n```\n\n### GPT-2\n\nHere is an example of the conversion process for a pre-trained OpenAI's GPT-2 model.\n\n```shell\nexport GPT2_DIR=/path/to/gpt2/checkpoint\n\npytorch_pretrained_bert convert_gpt2_checkpoint \\\n  $GPT2_DIR/model.ckpt \\\n  $PYTORCH_DUMP_OUTPUT \\\n  [GPT2_CONFIG]\n```\n\n## TPU\n\nTPU support and pretraining scripts\n\nTPU are not supported by the current stable release of PyTorch (0.4.1). However, the next version of PyTorch (v1.0) should support training on TPU and is expected to be released soon (see the recent [official announcement](https://cloud.google.com/blog/products/ai-machine-learning/introducing-pytorch-across-google-cloud)).\n\nWe will add TPU support when this next release is published.\n\nThe original TensorFlow code further comprises two scripts for pre-training BERT: [create_pretraining_data.py](https://github.com/google-research/bert/blob/master/create_pretraining_data.py) and [run_pretraining.py](https://github.com/google-research/bert/blob/master/run_pretraining.py).\n\nSince, pre-training BERT is a particularly expensive operation that basically requires one or several TPUs to be completed in a reasonable amout of time (see details [here](https://github.com/google-research/bert#pre-training-with-bert)) we have decided to wait for the inclusion of TPU support in PyTorch to convert these pre-training scripts.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/huggingface/pytorch-pretrained-BERT", "keywords": "BERT NLP deep learning google", "license": "Apache", "maintainer": "", "maintainer_email": "", "name": "pytorch-pretrained-bert", "package_url": "https://pypi.org/project/pytorch-pretrained-bert/", "platform": "", "project_url": "https://pypi.org/project/pytorch-pretrained-bert/", "project_urls": {"Homepage": "https://github.com/huggingface/pytorch-pretrained-BERT"}, "release_url": "https://pypi.org/project/pytorch-pretrained-bert/0.6.2/", "requires_dist": ["torch (>=0.4.1)", "numpy", "boto3", "requests", "tqdm", "regex"], "requires_python": "", "summary": "PyTorch version of Google AI BERT model with script to load Google pre-trained models", "version": "0.6.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>PyTorch Pretrained BERT: The Big &amp; Extending Repository of pretrained Transformers</h1>\n<p><a href=\"https://circleci.com/gh/huggingface/pytorch-pretrained-BERT\" rel=\"nofollow\"><img alt=\"CircleCI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3ffcd4ccf664c8b715473e2ab07d3708537ba869/68747470733a2f2f636972636c6563692e636f6d2f67682f68756767696e67666163652f7079746f7263682d707265747261696e65642d424552542e7376673f7374796c653d737667\"></a></p>\n<p>This repository contains op-for-op PyTorch reimplementations, pre-trained models and fine-tuning examples for:</p>\n<ul>\n<li><a href=\"https://github.com/google-research/bert\" rel=\"nofollow\">Google's BERT model</a>,</li>\n<li><a href=\"https://github.com/openai/finetune-transformer-lm\" rel=\"nofollow\">OpenAI's GPT model</a>,</li>\n<li><a href=\"https://github.com/kimiyoung/transformer-xl\" rel=\"nofollow\">Google/CMU's Transformer-XL model</a>, and</li>\n<li><a href=\"https://blog.openai.com/better-language-models/\" rel=\"nofollow\">OpenAI's GPT-2 model</a>.</li>\n</ul>\n<p>These implementations have been tested on several datasets (see the examples) and should match the performances of the associated TensorFlow implementations (e.g. ~91 F1 on SQuAD for BERT, ~88 F1 on RocStories for OpenAI GPT and ~18.3 perplexity on WikiText 103 for the Transformer-XL). You can find more details in the <a href=\"#examples\" rel=\"nofollow\">Examples</a> section below.</p>\n<p>Here are some information on these models:</p>\n<p><strong>BERT</strong> was released together with the paper <a href=\"https://arxiv.org/abs/1810.04805\" rel=\"nofollow\">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a> by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova.\nThis PyTorch implementation of BERT is provided with <a href=\"https://github.com/google-research/bert\" rel=\"nofollow\">Google's pre-trained models</a>, examples, notebooks and a command-line interface to load any pre-trained TensorFlow checkpoint for BERT is also provided.</p>\n<p><strong>OpenAI GPT</strong> was released together with the paper <a href=\"https://blog.openai.com/language-unsupervised/\" rel=\"nofollow\">Improving Language Understanding by Generative Pre-Training</a> by Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever.\nThis PyTorch implementation of OpenAI GPT is an adaptation of the <a href=\"https://github.com/huggingface/pytorch-openai-transformer-lm\" rel=\"nofollow\">PyTorch implementation by HuggingFace</a> and is provided with <a href=\"https://github.com/openai/finetune-transformer-lm\" rel=\"nofollow\">OpenAI's pre-trained model</a> and a command-line interface that was used to convert the pre-trained NumPy checkpoint in PyTorch.</p>\n<p><strong>Google/CMU's Transformer-XL</strong> was released together with the paper <a href=\"http://arxiv.org/abs/1901.02860\" rel=\"nofollow\">Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context</a> by Zihang Dai*, Zhilin Yang*, Yiming Yang, Jaime Carbonell, Quoc V. Le, Ruslan Salakhutdinov.\nThis PyTorch implementation of Transformer-XL is an adaptation of the original <a href=\"https://github.com/kimiyoung/transformer-xl\" rel=\"nofollow\">PyTorch implementation</a> which has been slightly modified to match the performances of the TensorFlow implementation and allow to re-use the pretrained weights. A command-line interface is provided to convert TensorFlow checkpoints in PyTorch models.</p>\n<p><strong>OpenAI GPT-2</strong> was released together with the paper <a href=\"https://blog.openai.com/better-language-models/\" rel=\"nofollow\">Language Models are Unsupervised Multitask Learners</a> by Alec Radford*, Jeffrey Wu*, Rewon Child, David Luan, Dario Amodei** and Ilya Sutskever**.\nThis PyTorch implementation of OpenAI GPT-2 is an adaptation of the <a href=\"https://github.com/openai/gpt-2\" rel=\"nofollow\">OpenAI's implementation</a> and is provided with <a href=\"https://github.com/openai/gpt-2\" rel=\"nofollow\">OpenAI's pre-trained model</a> and a command-line interface that was used to convert the TensorFlow checkpoint in PyTorch.</p>\n<h2>Content</h2>\n<table>\n<thead>\n<tr>\n<th>Section</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#installation\" rel=\"nofollow\">Installation</a></td>\n<td>How to install the package</td>\n</tr>\n<tr>\n<td><a href=\"#overview\" rel=\"nofollow\">Overview</a></td>\n<td>Overview of the package</td>\n</tr>\n<tr>\n<td><a href=\"#usage\" rel=\"nofollow\">Usage</a></td>\n<td>Quickstart examples</td>\n</tr>\n<tr>\n<td><a href=\"#doc\" rel=\"nofollow\">Doc</a></td>\n<td>Detailed documentation</td>\n</tr>\n<tr>\n<td><a href=\"#examples\" rel=\"nofollow\">Examples</a></td>\n<td>Detailed examples on how to fine-tune Bert</td>\n</tr>\n<tr>\n<td><a href=\"#notebooks\" rel=\"nofollow\">Notebooks</a></td>\n<td>Introduction on the provided Jupyter Notebooks</td>\n</tr>\n<tr>\n<td><a href=\"#tpu\" rel=\"nofollow\">TPU</a></td>\n<td>Notes on TPU support and pretraining scripts</td>\n</tr>\n<tr>\n<td><a href=\"#Command-line-interface\" rel=\"nofollow\">Command-line interface</a></td>\n<td>Convert a TensorFlow checkpoint in a PyTorch dump</td>\n</tr></tbody></table>\n<h2>Installation</h2>\n<p>This repo was tested on Python 2.7 and 3.5+ (examples are tested only on python 3.5+) and PyTorch 0.4.1/1.0.0</p>\n<h3>With pip</h3>\n<p>PyTorch pretrained bert can be installed by pip as follows:</p>\n<pre>pip install pytorch-pretrained-bert\n</pre>\n<p>If you want to reproduce the original tokenization process of the <code>OpenAI GPT</code> paper, you will need to install <code>ftfy</code> (limit to version 4.4.3 if you are using Python 2) and <code>SpaCy</code> :</p>\n<pre>pip install spacy <span class=\"nv\">ftfy</span><span class=\"o\">==</span><span class=\"m\">4</span>.4.3\npython -m spacy download en\n</pre>\n<p>If you don't install <code>ftfy</code> and <code>SpaCy</code>, the <code>OpenAI GPT</code> tokenizer will default to tokenize using BERT's <code>BasicTokenizer</code> followed by Byte-Pair Encoding (which should be fine for most usage, don't worry).</p>\n<h3>From source</h3>\n<p>Clone the repository and run:</p>\n<pre>pip install <span class=\"o\">[</span>--editable<span class=\"o\">]</span> .\n</pre>\n<p>Here also, if you want to reproduce the original tokenization process of the <code>OpenAI GPT</code> model, you will need to install <code>ftfy</code> (limit to version 4.4.3 if you are using Python 2) and <code>SpaCy</code> :</p>\n<pre>pip install spacy <span class=\"nv\">ftfy</span><span class=\"o\">==</span><span class=\"m\">4</span>.4.3\npython -m spacy download en\n</pre>\n<p>Again, if you don't install <code>ftfy</code> and <code>SpaCy</code>, the <code>OpenAI GPT</code> tokenizer will default to tokenize using BERT's <code>BasicTokenizer</code> followed by Byte-Pair Encoding (which should be fine for most usage).</p>\n<p>A series of tests is included in the <a href=\"https://github.com/huggingface/pytorch-pretrained-BERT/tree/master/tests\" rel=\"nofollow\">tests folder</a> and can be run using <code>pytest</code> (install pytest if needed: <code>pip install pytest</code>).</p>\n<p>You can run the tests with the command:</p>\n<pre>python -m pytest -sv tests/\n</pre>\n<h2>Overview</h2>\n<p>This package comprises the following classes that can be imported in Python and are detailed in the <a href=\"#doc\" rel=\"nofollow\">Doc</a> section of this readme:</p>\n<ul>\n<li>\n<p>Eight <strong>Bert</strong> PyTorch models (<code>torch.nn.Module</code>) with pre-trained weights (in the <a href=\"./pytorch_pretrained_bert/modeling.py\" rel=\"nofollow\"><code>modeling.py</code></a> file):</p>\n<ul>\n<li><a href=\"./pytorch_pretrained_bert/modeling.py#L639\" rel=\"nofollow\"><code>BertModel</code></a> - raw BERT Transformer model (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling.py#L793\" rel=\"nofollow\"><code>BertForMaskedLM</code></a> - BERT Transformer with the pre-trained masked language modeling head on top (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling.py#L854\" rel=\"nofollow\"><code>BertForNextSentencePrediction</code></a> - BERT Transformer with the pre-trained next sentence prediction classifier on top  (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling.py#L722\" rel=\"nofollow\"><code>BertForPreTraining</code></a> - BERT Transformer with masked language modeling head and next sentence prediction classifier on top (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling.py#L916\" rel=\"nofollow\"><code>BertForSequenceClassification</code></a> - BERT Transformer with a sequence classification head on top (BERT Transformer is <strong>pre-trained</strong>, the sequence classification head <strong>is only initialized and has to be trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling.py#L982\" rel=\"nofollow\"><code>BertForMultipleChoice</code></a> - BERT Transformer with a multiple choice head on top (used for task like Swag) (BERT Transformer is <strong>pre-trained</strong>, the multiple choice classification head <strong>is only initialized and has to be trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling.py#L1051\" rel=\"nofollow\"><code>BertForTokenClassification</code></a> - BERT Transformer with a token classification head on top (BERT Transformer is <strong>pre-trained</strong>, the token classification head <strong>is only initialized and has to be trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling.py#L1124\" rel=\"nofollow\"><code>BertForQuestionAnswering</code></a> - BERT Transformer with a token classification head on top (BERT Transformer is <strong>pre-trained</strong>, the token classification head <strong>is only initialized and has to be trained</strong>).</li>\n</ul>\n</li>\n<li>\n<p>Three <strong>OpenAI GPT</strong> PyTorch models (<code>torch.nn.Module</code>) with pre-trained weights (in the <a href=\"./pytorch_pretrained_bert/modeling_openai.py\" rel=\"nofollow\"><code>modeling_openai.py</code></a> file):</p>\n<ul>\n<li><a href=\"./pytorch_pretrained_bert/modeling_openai.py#L536\" rel=\"nofollow\"><code>OpenAIGPTModel</code></a> - raw OpenAI GPT Transformer model (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling_openai.py#L643\" rel=\"nofollow\"><code>OpenAIGPTLMHeadModel</code></a> - OpenAI GPT Transformer with the tied language modeling head on top (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling_openai.py#L722\" rel=\"nofollow\"><code>OpenAIGPTDoubleHeadsModel</code></a> - OpenAI GPT Transformer with the tied language modeling head and a multiple choice classification head on top (OpenAI GPT Transformer is <strong>pre-trained</strong>, the multiple choice classification head <strong>is only initialized and has to be trained</strong>),</li>\n</ul>\n</li>\n<li>\n<p>Two <strong>Transformer-XL</strong> PyTorch models (<code>torch.nn.Module</code>) with pre-trained weights (in the <a href=\"./pytorch_pretrained_bert/modeling_transfo_xl.py\" rel=\"nofollow\"><code>modeling_transfo_xl.py</code></a> file):</p>\n<ul>\n<li><a href=\"./pytorch_pretrained_bert/modeling_transfo_xl.py#L983\" rel=\"nofollow\"><code>TransfoXLModel</code></a> - Transformer-XL model which outputs the last hidden state and memory cells (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling_transfo_xl.py#L1260\" rel=\"nofollow\"><code>TransfoXLLMHeadModel</code></a> - Transformer-XL with the tied adaptive softmax head on top for language modeling which outputs the logits/loss and memory cells (<strong>fully pre-trained</strong>),</li>\n</ul>\n</li>\n<li>\n<p>Three <strong>OpenAI GPT-2</strong> PyTorch models (<code>torch.nn.Module</code>) with pre-trained weights (in the <a href=\"./pytorch_pretrained_bert/modeling_gpt2.py\" rel=\"nofollow\"><code>modeling_gpt2.py</code></a> file):</p>\n<ul>\n<li><a href=\"./pytorch_pretrained_bert/modeling_gpt2.py#L479\" rel=\"nofollow\"><code>GPT2Model</code></a> - raw OpenAI GPT-2 Transformer model (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling_gpt2.py#L559\" rel=\"nofollow\"><code>GPT2LMHeadModel</code></a> - OpenAI GPT-2 Transformer with the tied language modeling head on top (<strong>fully pre-trained</strong>),</li>\n<li><a href=\"./pytorch_pretrained_bert/modeling_gpt2.py#L624\" rel=\"nofollow\"><code>GPT2DoubleHeadsModel</code></a> - OpenAI GPT-2 Transformer with the tied language modeling head and a multiple choice classification head on top (OpenAI GPT-2 Transformer is <strong>pre-trained</strong>, the multiple choice classification head <strong>is only initialized and has to be trained</strong>),</li>\n</ul>\n</li>\n<li>\n<p>Tokenizers for <strong>BERT</strong> (using word-piece) (in the <a href=\"./pytorch_pretrained_bert/tokenization.py\" rel=\"nofollow\"><code>tokenization.py</code></a> file):</p>\n<ul>\n<li><code>BasicTokenizer</code> - basic tokenization (punctuation splitting, lower casing, etc.),</li>\n<li><code>WordpieceTokenizer</code> - WordPiece tokenization,</li>\n<li><code>BertTokenizer</code> - perform end-to-end tokenization, i.e. basic tokenization followed by WordPiece tokenization.</li>\n</ul>\n</li>\n<li>\n<p>Tokenizer for <strong>OpenAI GPT</strong> (using Byte-Pair-Encoding) (in the <a href=\"./pytorch_pretrained_bert/tokenization_openai.py\" rel=\"nofollow\"><code>tokenization_openai.py</code></a> file):</p>\n<ul>\n<li><code>OpenAIGPTTokenizer</code> - perform Byte-Pair-Encoding (BPE) tokenization.</li>\n</ul>\n</li>\n<li>\n<p>Tokenizer for <strong>Transformer-XL</strong> (word tokens ordered by frequency for adaptive softmax) (in the <a href=\"./pytorch_pretrained_bert/tokenization_transfo_xl.py\" rel=\"nofollow\"><code>tokenization_transfo_xl.py</code></a> file):</p>\n<ul>\n<li><code>OpenAIGPTTokenizer</code> - perform word tokenization and can order words by frequency in a corpus for use in an adaptive softmax.</li>\n</ul>\n</li>\n<li>\n<p>Tokenizer for <strong>OpenAI GPT-2</strong> (using byte-level Byte-Pair-Encoding) (in the <a href=\"./pytorch_pretrained_bert/tokenization_gpt2.py\" rel=\"nofollow\"><code>tokenization_gpt2.py</code></a> file):</p>\n<ul>\n<li><code>GPT2Tokenizer</code> - perform byte-level Byte-Pair-Encoding (BPE) tokenization.</li>\n</ul>\n</li>\n<li>\n<p>Optimizer for <strong>BERT</strong> (in the <a href=\"./pytorch_pretrained_bert/optimization.py\" rel=\"nofollow\"><code>optimization.py</code></a> file):</p>\n<ul>\n<li><code>BertAdam</code> - Bert version of Adam algorithm with weight decay fix, warmup and linear decay of the learning rate.</li>\n</ul>\n</li>\n<li>\n<p>Optimizer for <strong>OpenAI GPT</strong> (in the <a href=\"./pytorch_pretrained_bert/optimization_openai.py\" rel=\"nofollow\"><code>optimization_openai.py</code></a> file):</p>\n<ul>\n<li><code>OpenAIAdam</code> - OpenAI GPT version of Adam algorithm with weight decay fix, warmup and linear decay of the learning rate.</li>\n</ul>\n</li>\n<li>\n<p>Configuration classes for BERT, OpenAI GPT and Transformer-XL (in the respective <a href=\"./pytorch_pretrained_bert/modeling.py\" rel=\"nofollow\"><code>modeling.py</code></a>, <a href=\"./pytorch_pretrained_bert/modeling_openai.py\" rel=\"nofollow\"><code>modeling_openai.py</code></a>, <a href=\"./pytorch_pretrained_bert/modeling_transfo_xl.py\" rel=\"nofollow\"><code>modeling_transfo_xl.py</code></a> files):</p>\n<ul>\n<li><code>BertConfig</code> - Configuration class to store the configuration of a <code>BertModel</code> with utilities to read and write from JSON configuration files.</li>\n<li><code>OpenAIGPTConfig</code> - Configuration class to store the configuration of a <code>OpenAIGPTModel</code> with utilities to read and write from JSON configuration files.</li>\n<li><code>GPT2Config</code> - Configuration class to store the configuration of a <code>GPT2Model</code> with utilities to read and write from JSON configuration files.</li>\n<li><code>TransfoXLConfig</code> - Configuration class to store the configuration of a <code>TransfoXLModel</code> with utilities to read and write from JSON configuration files.</li>\n</ul>\n</li>\n</ul>\n<p>The repository further comprises:</p>\n<ul>\n<li>\n<p>Five examples on how to use <strong>BERT</strong> (in the <a href=\"./examples\" rel=\"nofollow\"><code>examples</code> folder</a>):</p>\n<ul>\n<li><a href=\"./examples/extract_features.py\" rel=\"nofollow\"><code>extract_features.py</code></a> - Show how to extract hidden states from an instance of <code>BertModel</code>,</li>\n<li><a href=\"./examples/run_classifier.py\" rel=\"nofollow\"><code>run_classifier.py</code></a> - Show how to fine-tune an instance of <code>BertForSequenceClassification</code> on GLUE's MRPC task,</li>\n<li><a href=\"./examples/run_squad.py\" rel=\"nofollow\"><code>run_squad.py</code></a> - Show how to fine-tune an instance of <code>BertForQuestionAnswering</code> on SQuAD v1.0 and SQuAD v2.0 tasks.</li>\n<li><a href=\"./examples/run_swag.py\" rel=\"nofollow\"><code>run_swag.py</code></a> - Show how to fine-tune an instance of <code>BertForMultipleChoice</code> on Swag task.</li>\n<li><a href=\"./examples/lm_finetuning/simple_lm_finetuning.py\" rel=\"nofollow\"><code>simple_lm_finetuning.py</code></a> - Show how to fine-tune an instance of <code>BertForPretraining</code> on a target text corpus.</li>\n</ul>\n</li>\n<li>\n<p>One example on how to use <strong>OpenAI GPT</strong> (in the <a href=\"./examples\" rel=\"nofollow\"><code>examples</code> folder</a>):</p>\n<ul>\n<li><a href=\"./examples/run_openai_gpt.py\" rel=\"nofollow\"><code>run_openai_gpt.py</code></a> - Show how to fine-tune an instance of <code>OpenGPTDoubleHeadsModel</code> on the RocStories task.</li>\n</ul>\n</li>\n<li>\n<p>One example on how to use <strong>Transformer-XL</strong> (in the <a href=\"./examples\" rel=\"nofollow\"><code>examples</code> folder</a>):</p>\n<ul>\n<li><a href=\"./examples/run_transfo_xl.py\" rel=\"nofollow\"><code>run_transfo_xl.py</code></a> - Show how to load and evaluate a pre-trained model of <code>TransfoXLLMHeadModel</code> on WikiText 103.</li>\n</ul>\n</li>\n<li>\n<p>One example on how to use <strong>OpenAI GPT-2</strong> in the unconditional and interactive mode (in the <a href=\"./examples\" rel=\"nofollow\"><code>examples</code> folder</a>):</p>\n<ul>\n<li><a href=\"./examples/run_gpt2.py\" rel=\"nofollow\"><code>run_gpt2.py</code></a> - Show how to use OpenAI GPT-2 an instance of <code>GPT2LMHeadModel</code> to generate text (same as the original OpenAI GPT-2 examples).</li>\n</ul>\n<p>These examples are detailed in the <a href=\"#examples\" rel=\"nofollow\">Examples</a> section of this readme.</p>\n</li>\n<li>\n<p>Three notebooks that were used to check that the TensorFlow and PyTorch models behave identically (in the <a href=\"./notebooks\" rel=\"nofollow\"><code>notebooks</code> folder</a>):</p>\n<ul>\n<li><a href=\"./notebooks/Comparing-TF-and-PT-models.ipynb\" rel=\"nofollow\"><code>Comparing-TF-and-PT-models.ipynb</code></a> - Compare the hidden states predicted by <code>BertModel</code>,</li>\n<li><a href=\"./notebooks/Comparing-TF-and-PT-models-SQuAD.ipynb\" rel=\"nofollow\"><code>Comparing-TF-and-PT-models-SQuAD.ipynb</code></a> - Compare the spans predicted by  <code>BertForQuestionAnswering</code> instances,</li>\n<li><a href=\"./notebooks/Comparing-TF-and-PT-models-MLM-NSP.ipynb\" rel=\"nofollow\"><code>Comparing-TF-and-PT-models-MLM-NSP.ipynb</code></a> - Compare the predictions of the <code>BertForPretraining</code> instances.</li>\n</ul>\n<p>These notebooks are detailed in the <a href=\"#notebooks\" rel=\"nofollow\">Notebooks</a> section of this readme.</p>\n</li>\n<li>\n<p>A command-line interface to convert TensorFlow checkpoints (BERT, Transformer-XL) or NumPy checkpoint (OpenAI) in a PyTorch save of the associated PyTorch model:</p>\n<p>This CLI is detailed in the <a href=\"#Command-line-interface\" rel=\"nofollow\">Command-line interface</a> section of this readme.</p>\n</li>\n</ul>\n<h2>Usage</h2>\n<h3>BERT</h3>\n<p>Here is a quick-start example using <code>BertTokenizer</code>, <code>BertModel</code> and <code>BertForMaskedLM</code> class with Google AI's pre-trained <code>Bert base uncased</code> model. See the <a href=\"#doc\" rel=\"nofollow\">doc section</a> below for all the details on these classes.</p>\n<p>First let's prepare a tokenized input with <code>BertTokenizer</code></p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torch</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pytorch_pretrained_bert</span> <span class=\"kn\">import</span> <span class=\"n\">BertTokenizer</span><span class=\"p\">,</span> <span class=\"n\">BertModel</span><span class=\"p\">,</span> <span class=\"n\">BertForMaskedLM</span>\n\n<span class=\"c1\"># OPTIONAL: if you want to have more information on what's happening, activate the logger as follows</span>\n<span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n<span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">basicConfig</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"o\">=</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">INFO</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Load pre-trained model tokenizer (vocabulary)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Tokenized input</span>\n<span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"s2\">\"[CLS] Who was Jim Henson ? [SEP] Jim Henson was a puppeteer [SEP]\"</span>\n<span class=\"n\">tokenized_text</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">tokenize</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Mask a token that we will try to predict back with `BertForMaskedLM`</span>\n<span class=\"n\">masked_index</span> <span class=\"o\">=</span> <span class=\"mi\">8</span>\n<span class=\"n\">tokenized_text</span><span class=\"p\">[</span><span class=\"n\">masked_index</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'[MASK]'</span>\n<span class=\"k\">assert</span> <span class=\"n\">tokenized_text</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'[CLS]'</span><span class=\"p\">,</span> <span class=\"s1\">'who'</span><span class=\"p\">,</span> <span class=\"s1\">'was'</span><span class=\"p\">,</span> <span class=\"s1\">'jim'</span><span class=\"p\">,</span> <span class=\"s1\">'henson'</span><span class=\"p\">,</span> <span class=\"s1\">'?'</span><span class=\"p\">,</span> <span class=\"s1\">'[SEP]'</span><span class=\"p\">,</span> <span class=\"s1\">'jim'</span><span class=\"p\">,</span> <span class=\"s1\">'[MASK]'</span><span class=\"p\">,</span> <span class=\"s1\">'was'</span><span class=\"p\">,</span> <span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'puppet'</span><span class=\"p\">,</span> <span class=\"s1\">'##eer'</span><span class=\"p\">,</span> <span class=\"s1\">'[SEP]'</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Convert token to vocabulary indices</span>\n<span class=\"n\">indexed_tokens</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">convert_tokens_to_ids</span><span class=\"p\">(</span><span class=\"n\">tokenized_text</span><span class=\"p\">)</span>\n<span class=\"c1\"># Define sentence A and B indices associated to 1st and 2nd sentences (see paper)</span>\n<span class=\"n\">segments_ids</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Convert inputs to PyTorch tensors</span>\n<span class=\"n\">tokens_tensor</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">indexed_tokens</span><span class=\"p\">])</span>\n<span class=\"n\">segments_tensors</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">segments_ids</span><span class=\"p\">])</span>\n</pre>\n<p>Let's see how to use <code>BertModel</code> to get hidden states</p>\n<pre><span class=\"c1\"># Load pre-trained model (weights)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># If you have a GPU, put everything on cuda</span>\n<span class=\"n\">tokens_tensor</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">segments_tensors</span> <span class=\"o\">=</span> <span class=\"n\">segments_tensors</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Predict hidden states features for each layer</span>\n<span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n    <span class=\"n\">encoded_layers</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor</span><span class=\"p\">,</span> <span class=\"n\">segments_tensors</span><span class=\"p\">)</span>\n<span class=\"c1\"># We have a hidden states for each of the 12 layers in model bert-base-uncased</span>\n<span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">encoded_layers</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">12</span>\n</pre>\n<p>And how to use <code>BertForMaskedLM</code></p>\n<pre><span class=\"c1\"># Load pre-trained model (weights)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertForMaskedLM</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># If you have a GPU, put everything on cuda</span>\n<span class=\"n\">tokens_tensor</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">segments_tensors</span> <span class=\"o\">=</span> <span class=\"n\">segments_tensors</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Predict all tokens</span>\n<span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n    <span class=\"n\">predictions</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor</span><span class=\"p\">,</span> <span class=\"n\">segments_tensors</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># confirm we were able to predict 'henson'</span>\n<span class=\"n\">predicted_index</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">argmax</span><span class=\"p\">(</span><span class=\"n\">predictions</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">masked_index</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">()</span>\n<span class=\"n\">predicted_token</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">convert_ids_to_tokens</span><span class=\"p\">([</span><span class=\"n\">predicted_index</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"k\">assert</span> <span class=\"n\">predicted_token</span> <span class=\"o\">==</span> <span class=\"s1\">'henson'</span>\n</pre>\n<h3>OpenAI GPT</h3>\n<p>Here is a quick-start example using <code>OpenAIGPTTokenizer</code>, <code>OpenAIGPTModel</code> and <code>OpenAIGPTLMHeadModel</code> class with OpenAI's pre-trained  model. See the <a href=\"#doc\" rel=\"nofollow\">doc section</a> below for all the details on these classes.</p>\n<p>First let's prepare a tokenized input with <code>OpenAIGPTTokenizer</code></p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torch</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pytorch_pretrained_bert</span> <span class=\"kn\">import</span> <span class=\"n\">OpenAIGPTTokenizer</span><span class=\"p\">,</span> <span class=\"n\">OpenAIGPTModel</span><span class=\"p\">,</span> <span class=\"n\">OpenAIGPTLMHeadModel</span>\n\n<span class=\"c1\"># OPTIONAL: if you want to have more information on what's happening, activate the logger as follows</span>\n<span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n<span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">basicConfig</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"o\">=</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">INFO</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Load pre-trained model tokenizer (vocabulary)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'openai-gpt'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Tokenized input</span>\n<span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"s2\">\"Who was Jim Henson ? Jim Henson was a puppeteer\"</span>\n<span class=\"n\">tokenized_text</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">tokenize</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert token to vocabulary indices</span>\n<span class=\"n\">indexed_tokens</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">convert_tokens_to_ids</span><span class=\"p\">(</span><span class=\"n\">tokenized_text</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert inputs to PyTorch tensors</span>\n<span class=\"n\">tokens_tensor</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">indexed_tokens</span><span class=\"p\">])</span>\n</pre>\n<p>Let's see how to use <code>OpenAIGPTModel</code> to get hidden states</p>\n<pre><span class=\"c1\"># Load pre-trained model (weights)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'openai-gpt'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># If you have a GPU, put everything on cuda</span>\n<span class=\"n\">tokens_tensor</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Predict hidden states features for each layer</span>\n<span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n    <span class=\"n\">hidden_states</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor</span><span class=\"p\">)</span>\n</pre>\n<p>And how to use <code>OpenAIGPTLMHeadModel</code></p>\n<pre><span class=\"c1\"># Load pre-trained model (weights)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTLMHeadModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'openai-gpt'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># If you have a GPU, put everything on cuda</span>\n<span class=\"n\">tokens_tensor</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Predict all tokens</span>\n<span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n    <span class=\"n\">predictions</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># get the predicted last token</span>\n<span class=\"n\">predicted_index</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">argmax</span><span class=\"p\">(</span><span class=\"n\">predictions</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:])</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">()</span>\n<span class=\"n\">predicted_token</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">convert_ids_to_tokens</span><span class=\"p\">([</span><span class=\"n\">predicted_index</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"k\">assert</span> <span class=\"n\">predicted_token</span> <span class=\"o\">==</span> <span class=\"s1\">'.&lt;/w&gt;'</span>\n</pre>\n<h3>Transformer-XL</h3>\n<p>Here is a quick-start example using <code>TransfoXLTokenizer</code>, <code>TransfoXLModel</code> and <code>TransfoXLModelLMHeadModel</code> class with the Transformer-XL model pre-trained on WikiText-103. See the <a href=\"#doc\" rel=\"nofollow\">doc section</a> below for all the details on these classes.</p>\n<p>First let's prepare a tokenized input with <code>TransfoXLTokenizer</code></p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torch</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pytorch_pretrained_bert</span> <span class=\"kn\">import</span> <span class=\"n\">TransfoXLTokenizer</span><span class=\"p\">,</span> <span class=\"n\">TransfoXLModel</span><span class=\"p\">,</span> <span class=\"n\">TransfoXLLMHeadModel</span>\n\n<span class=\"c1\"># OPTIONAL: if you want to have more information on what's happening, activate the logger as follows</span>\n<span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n<span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">basicConfig</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"o\">=</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">INFO</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Load pre-trained model tokenizer (vocabulary from wikitext 103)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">TransfoXLTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'transfo-xl-wt103'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Tokenized input</span>\n<span class=\"n\">text_1</span> <span class=\"o\">=</span> <span class=\"s2\">\"Who was Jim Henson ?\"</span>\n<span class=\"n\">text_2</span> <span class=\"o\">=</span> <span class=\"s2\">\"Jim Henson was a puppeteer\"</span>\n<span class=\"n\">tokenized_text_1</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">tokenize</span><span class=\"p\">(</span><span class=\"n\">text_1</span><span class=\"p\">)</span>\n<span class=\"n\">tokenized_text_2</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">tokenize</span><span class=\"p\">(</span><span class=\"n\">text_2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert token to vocabulary indices</span>\n<span class=\"n\">indexed_tokens_1</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">convert_tokens_to_ids</span><span class=\"p\">(</span><span class=\"n\">tokenized_text_1</span><span class=\"p\">)</span>\n<span class=\"n\">indexed_tokens_2</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">convert_tokens_to_ids</span><span class=\"p\">(</span><span class=\"n\">tokenized_text_2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert inputs to PyTorch tensors</span>\n<span class=\"n\">tokens_tensor_1</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">indexed_tokens_1</span><span class=\"p\">])</span>\n<span class=\"n\">tokens_tensor_2</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">indexed_tokens_2</span><span class=\"p\">])</span>\n</pre>\n<p>Let's see how to use <code>TransfoXLModel</code> to get hidden states</p>\n<pre><span class=\"c1\"># Load pre-trained model (weights)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">TransfoXLModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'transfo-xl-wt103'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># If you have a GPU, put everything on cuda</span>\n<span class=\"n\">tokens_tensor_1</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor_1</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">tokens_tensor_2</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor_2</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n\n<span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n    <span class=\"c1\"># Predict hidden states features for each layer</span>\n    <span class=\"n\">hidden_states_1</span><span class=\"p\">,</span> <span class=\"n\">mems_1</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor_1</span><span class=\"p\">)</span>\n    <span class=\"c1\"># We can re-use the memory cells in a subsequent call to attend a longer context</span>\n    <span class=\"n\">hidden_states_2</span><span class=\"p\">,</span> <span class=\"n\">mems_2</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor_2</span><span class=\"p\">,</span> <span class=\"n\">mems</span><span class=\"o\">=</span><span class=\"n\">mems_1</span><span class=\"p\">)</span>\n</pre>\n<p>And how to use <code>TransfoXLLMHeadModel</code></p>\n<pre><span class=\"c1\"># Load pre-trained model (weights)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">TransfoXLLMHeadModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'transfo-xl-wt103'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># If you have a GPU, put everything on cuda</span>\n<span class=\"n\">tokens_tensor_1</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor_1</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">tokens_tensor_2</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor_2</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n\n<span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n    <span class=\"c1\"># Predict all tokens</span>\n    <span class=\"n\">predictions_1</span><span class=\"p\">,</span> <span class=\"n\">mems_1</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor_1</span><span class=\"p\">)</span>\n    <span class=\"c1\"># We can re-use the memory cells in a subsequent call to attend a longer context</span>\n    <span class=\"n\">predictions_2</span><span class=\"p\">,</span> <span class=\"n\">mems_2</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor_2</span><span class=\"p\">,</span> <span class=\"n\">mems</span><span class=\"o\">=</span><span class=\"n\">mems_1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># get the predicted last token</span>\n<span class=\"n\">predicted_index</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">argmax</span><span class=\"p\">(</span><span class=\"n\">predictions_2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:])</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">()</span>\n<span class=\"n\">predicted_token</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">convert_ids_to_tokens</span><span class=\"p\">([</span><span class=\"n\">predicted_index</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"k\">assert</span> <span class=\"n\">predicted_token</span> <span class=\"o\">==</span> <span class=\"s1\">'who'</span>\n</pre>\n<h3>OpenAI GPT-2</h3>\n<p>Here is a quick-start example using <code>GPT2Tokenizer</code>, <code>GPT2Model</code> and <code>GPT2LMHeadModel</code> class with OpenAI's pre-trained  model. See the <a href=\"#doc\" rel=\"nofollow\">doc section</a> below for all the details on these classes.</p>\n<p>First let's prepare a tokenized input with <code>GPT2Tokenizer</code></p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torch</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pytorch_pretrained_bert</span> <span class=\"kn\">import</span> <span class=\"n\">GPT2Tokenizer</span><span class=\"p\">,</span> <span class=\"n\">GPT2Model</span><span class=\"p\">,</span> <span class=\"n\">GPT2LMHeadModel</span>\n\n<span class=\"c1\"># OPTIONAL: if you want to have more information on what's happening, activate the logger as follows</span>\n<span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n<span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">basicConfig</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"o\">=</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">INFO</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Load pre-trained model tokenizer (vocabulary)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">GPT2Tokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'gpt2'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Encode some inputs</span>\n<span class=\"n\">text_1</span> <span class=\"o\">=</span> <span class=\"s2\">\"Who was Jim Henson ?\"</span>\n<span class=\"n\">text_2</span> <span class=\"o\">=</span> <span class=\"s2\">\"Jim Henson was a puppeteer\"</span>\n<span class=\"n\">indexed_tokens_1</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"n\">text_1</span><span class=\"p\">)</span>\n<span class=\"n\">indexed_tokens_2</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"n\">text_2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert inputs to PyTorch tensors</span>\n<span class=\"n\">tokens_tensor_1</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">indexed_tokens_1</span><span class=\"p\">])</span>\n<span class=\"n\">tokens_tensor_2</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([</span><span class=\"n\">indexed_tokens_2</span><span class=\"p\">])</span>\n</pre>\n<p>Let's see how to use <code>GPT2Model</code> to get hidden states</p>\n<pre><span class=\"c1\"># Load pre-trained model (weights)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">GPT2Model</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'gpt2'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># If you have a GPU, put everything on cuda</span>\n<span class=\"n\">tokens_tensor_1</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor_1</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">tokens_tensor_2</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor_2</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Predict hidden states features for each layer</span>\n<span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n    <span class=\"n\">hidden_states_1</span><span class=\"p\">,</span> <span class=\"n\">past</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor_1</span><span class=\"p\">)</span>\n    <span class=\"c1\"># past can be used to reuse precomputed hidden state in a subsequent predictions</span>\n    <span class=\"c1\"># (see beam-search examples in the run_gpt2.py example).</span>\n    <span class=\"n\">hidden_states_2</span><span class=\"p\">,</span> <span class=\"n\">past</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor_2</span><span class=\"p\">,</span> <span class=\"n\">past</span><span class=\"o\">=</span><span class=\"n\">past</span><span class=\"p\">)</span>\n</pre>\n<p>And how to use <code>GPT2LMHeadModel</code></p>\n<pre><span class=\"c1\"># Load pre-trained model (weights)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">GPT2LMHeadModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'gpt2'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># If you have a GPU, put everything on cuda</span>\n<span class=\"n\">tokens_tensor_1</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor_1</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">tokens_tensor_2</span> <span class=\"o\">=</span> <span class=\"n\">tokens_tensor_2</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"s1\">'cuda'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Predict all tokens</span>\n<span class=\"k\">with</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">no_grad</span><span class=\"p\">():</span>\n    <span class=\"n\">predictions_1</span><span class=\"p\">,</span> <span class=\"n\">past</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor_1</span><span class=\"p\">)</span>\n    <span class=\"c1\"># past can be used to reuse precomputed hidden state in a subsequent predictions</span>\n    <span class=\"c1\"># (see beam-search examples in the run_gpt2.py example).</span>\n    <span class=\"n\">predictions_2</span><span class=\"p\">,</span> <span class=\"n\">past</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor_2</span><span class=\"p\">,</span> <span class=\"n\">past</span><span class=\"o\">=</span><span class=\"n\">past</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># get the predicted last token</span>\n<span class=\"n\">predicted_index</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">argmax</span><span class=\"p\">(</span><span class=\"n\">predictions_2</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:])</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">()</span>\n<span class=\"n\">predicted_token</span> <span class=\"o\">=</span> <span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">([</span><span class=\"n\">predicted_index</span><span class=\"p\">])</span>\n</pre>\n<h2>Doc</h2>\n<p>Here is a detailed documentation of the classes in the package and how to use them:</p>\n<table>\n<thead>\n<tr>\n<th>Sub-section</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#loading-google-ai-or-openai-pre-trained-weights-or-pytorch-dump\" rel=\"nofollow\">Loading pre-trained weights</a></td>\n<td>How to load Google AI/OpenAI's pre-trained weight or a PyTorch saved instance</td>\n</tr>\n<tr>\n<td><a href=\"#serialization-best-practices\" rel=\"nofollow\">Serialization best-practices</a></td>\n<td>How to save and reload a fine-tuned model</td>\n</tr>\n<tr>\n<td><a href=\"#configurations\" rel=\"nofollow\">Configurations</a></td>\n<td>API of the configuration classes for BERT, GPT, GPT-2 and Transformer-XL</td>\n</tr>\n<tr>\n<td><a href=\"#models\" rel=\"nofollow\">Models</a></td>\n<td>API of the PyTorch model classes for BERT, GPT, GPT-2 and Transformer-XL</td>\n</tr>\n<tr>\n<td><a href=\"#tokenizers\" rel=\"nofollow\">Tokenizers</a></td>\n<td>API of the tokenizers class for BERT, GPT, GPT-2 and Transformer-XL</td>\n</tr>\n<tr>\n<td><a href=\"#optimizers\" rel=\"nofollow\">Optimizers</a></td>\n<td>API of the optimizers</td>\n</tr></tbody></table>\n<h3>Loading Google AI or OpenAI pre-trained weights or PyTorch dump</h3>\n<p>To load one of Google AI's, OpenAI's pre-trained models or a PyTorch saved model (an instance of <code>BertForPreTraining</code> saved with <code>torch.save()</code>), the PyTorch model classes and the tokenizer can be instantiated as</p>\n<pre><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BERT_CLASS</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">PRE_TRAINED_MODEL_NAME_OR_PATH</span><span class=\"p\">,</span> <span class=\"n\">cache_dir</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>where</p>\n<ul>\n<li>\n<p><code>BERT_CLASS</code> is either a tokenizer to load the vocabulary (<code>BertTokenizer</code> or <code>OpenAIGPTTokenizer</code> classes) or one of the eight BERT or three OpenAI GPT PyTorch model classes (to load the pre-trained weights): <code>BertModel</code>, <code>BertForMaskedLM</code>, <code>BertForNextSentencePrediction</code>, <code>BertForPreTraining</code>, <code>BertForSequenceClassification</code>, <code>BertForTokenClassification</code>, <code>BertForMultipleChoice</code>, <code>BertForQuestionAnswering</code>, <code>OpenAIGPTModel</code>, <code>OpenAIGPTLMHeadModel</code> or <code>OpenAIGPTDoubleHeadsModel</code>, and</p>\n</li>\n<li>\n<p><code>PRE_TRAINED_MODEL_NAME_OR_PATH</code> is either:</p>\n<ul>\n<li>\n<p>the shortcut name of a Google AI's or OpenAI's pre-trained model selected in the list:</p>\n<ul>\n<li><code>bert-base-uncased</code>: 12-layer, 768-hidden, 12-heads, 110M parameters</li>\n<li><code>bert-large-uncased</code>: 24-layer, 1024-hidden, 16-heads, 340M parameters</li>\n<li><code>bert-base-cased</code>: 12-layer, 768-hidden, 12-heads , 110M parameters</li>\n<li><code>bert-large-cased</code>: 24-layer, 1024-hidden, 16-heads, 340M parameters</li>\n<li><code>bert-base-multilingual-uncased</code>: (Orig, not recommended) 102 languages, 12-layer, 768-hidden, 12-heads, 110M parameters</li>\n<li><code>bert-base-multilingual-cased</code>: <strong>(New, recommended)</strong> 104 languages, 12-layer, 768-hidden, 12-heads, 110M parameters</li>\n<li><code>bert-base-chinese</code>: Chinese Simplified and Traditional, 12-layer, 768-hidden, 12-heads, 110M parameters</li>\n<li><code>openai-gpt</code>: OpenAI English model, 12-layer, 768-hidden, 12-heads, 110M parameters</li>\n<li><code>transfo-xl-wt103</code>: Transformer-XL English model trained on wikitext-103, 18-layer, 1024-hidden, 16-heads, 257M parameters</li>\n<li><code>gpt2</code>: OpenAI GPT-2 English model, 12-layer, 768-hidden, 12-heads, 117M parameters</li>\n</ul>\n</li>\n<li>\n<p>a path or url to a pretrained model archive containing:</p>\n<ul>\n<li><code>bert_config.json</code> or <code>openai_gpt_config.json</code> a configuration file for the model, and</li>\n<li><code>pytorch_model.bin</code> a PyTorch dump of a pre-trained instance of <code>BertForPreTraining</code>, <code>OpenAIGPTModel</code>, <code>TransfoXLModel</code>, <code>GPT2LMHeadModel</code> (saved with the usual <code>torch.save()</code>)</li>\n</ul>\n</li>\n</ul>\n<p>If <code>PRE_TRAINED_MODEL_NAME_OR_PATH</code> is a shortcut name, the pre-trained weights will be downloaded from AWS S3 (see the links <a href=\"pytorch_pretrained_bert/modeling.py\" rel=\"nofollow\">here</a>) and stored in a cache folder to avoid future download (the cache folder can be found at <code>~/.pytorch_pretrained_bert/</code>).</p>\n</li>\n<li>\n<p><code>cache_dir</code> can be an optional path to a specific directory to download and cache the pre-trained model weights. This option is useful in particular when you are using distributed training: to avoid concurrent access to the same weights you can set for example <code>cache_dir='./pretrained_model_{}'.format(args.local_rank)</code> (see the section on distributed training for more information).</p>\n</li>\n</ul>\n<p><code>Uncased</code> means that the text has been lowercased before WordPiece tokenization, e.g., <code>John Smith</code> becomes <code>john smith</code>. The Uncased model also strips out any accent markers. <code>Cased</code> means that the true case and accent markers are preserved. Typically, the Uncased model is better unless you know that case information is important for your task (e.g., Named Entity Recognition or Part-of-Speech tagging). For information about the Multilingual and Chinese model, see the <a href=\"https://github.com/google-research/bert/blob/master/multilingual.md\" rel=\"nofollow\">Multilingual README</a> or the original TensorFlow repository.</p>\n<p><strong>When using an <code>uncased model</code>, make sure to pass <code>--do_lower_case</code> to the example training scripts (or pass <code>do_lower_case=True</code> to FullTokenizer if you're using your own script and loading the tokenizer your-self.).</strong></p>\n<p>Examples:</p>\n<pre><span class=\"c1\"># BERT</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">,</span> <span class=\"n\">do_lower_case</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">do_basic_tokenize</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertForSequenceClassification</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'bert-base-uncased'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># OpenAI GPT</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'openai-gpt'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'openai-gpt'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Transformer-XL</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">TransfoXLTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'transfo-xl-wt103'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">TransfoXLModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'transfo-xl-wt103'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># OpenAI GPT-2</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">GPT2Tokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'gpt2'</span><span class=\"p\">)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">GPT2Model</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"s1\">'gpt2'</span><span class=\"p\">)</span>\n</pre>\n<h3>Serialization best-practices</h3>\n<p>This section explain how you can save and re-load a fine-tuned model (BERT, GPT, GPT-2 and Transformer-XL).\nThere are three types of files you need to save to be able to reload a fine-tuned model:</p>\n<ul>\n<li>the model it-self which should be saved following PyTorch serialization <a href=\"https://pytorch.org/docs/stable/notes/serialization.html#best-practices\" rel=\"nofollow\">best practices</a>,</li>\n<li>the configuration file of the model which is saved as a JSON file, and</li>\n<li>the vocabulary (and the merges for the BPE-based models GPT and GPT-2).</li>\n</ul>\n<p>Here is the recommended way of saving the model, configuration and vocabulary to an <code>output_dir</code> directory and reloading the model and tokenizer afterwards:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pytorch_pretrained_bert</span> <span class=\"kn\">import</span> <span class=\"n\">WEIGHTS_NAME</span><span class=\"p\">,</span> <span class=\"n\">CONFIG_NAME</span>\n\n<span class=\"n\">output_dir</span> <span class=\"o\">=</span> <span class=\"s2\">\"./models/\"</span>\n\n<span class=\"c1\"># Step 1: Save a model, configuration and vocabulary that you have fine-tuned</span>\n\n<span class=\"c1\"># If we have a distributed model, save only the encapsulated model</span>\n<span class=\"c1\"># (it was wrapped in PyTorch DistributedDataParallel or DataParallel)</span>\n<span class=\"n\">model_to_save</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">module</span> <span class=\"k\">if</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"s1\">'module'</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"n\">model</span>\n\n<span class=\"c1\"># If we save using the predefined names, we can load using `from_pretrained`</span>\n<span class=\"n\">output_model_file</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">output_dir</span><span class=\"p\">,</span> <span class=\"n\">WEIGHTS_NAME</span><span class=\"p\">)</span>\n<span class=\"n\">output_config_file</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">output_dir</span><span class=\"p\">,</span> <span class=\"n\">CONFIG_NAME</span><span class=\"p\">)</span>\n\n<span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"n\">model_to_save</span><span class=\"o\">.</span><span class=\"n\">state_dict</span><span class=\"p\">(),</span> <span class=\"n\">output_model_file</span><span class=\"p\">)</span>\n<span class=\"n\">model_to_save</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">to_json_file</span><span class=\"p\">(</span><span class=\"n\">output_config_file</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">save_vocabulary</span><span class=\"p\">(</span><span class=\"n\">output_dir</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Step 2: Re-load the saved model and vocabulary</span>\n\n<span class=\"c1\"># Example for a Bert model</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertForQuestionAnswering</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">output_dir</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">output_dir</span><span class=\"p\">,</span> <span class=\"n\">do_lower_case</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">do_lower_case</span><span class=\"p\">)</span>  <span class=\"c1\"># Add specific options if needed</span>\n<span class=\"c1\"># Example for a GPT model</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTDoubleHeadsModel</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">output_dir</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTTokenizer</span><span class=\"o\">.</span><span class=\"n\">from_pretrained</span><span class=\"p\">(</span><span class=\"n\">output_dir</span><span class=\"p\">)</span>\n</pre>\n<p>Here is another way you can save and reload the model if you want to use specific paths for each type of files:</p>\n<pre><span class=\"n\">output_model_file</span> <span class=\"o\">=</span> <span class=\"s2\">\"./models/my_own_model_file.bin\"</span>\n<span class=\"n\">output_config_file</span> <span class=\"o\">=</span> <span class=\"s2\">\"./models/my_own_config_file.bin\"</span>\n<span class=\"n\">output_vocab_file</span> <span class=\"o\">=</span> <span class=\"s2\">\"./models/my_own_vocab_file.bin\"</span>\n\n<span class=\"c1\"># Step 1: Save a model, configuration and vocabulary that you have fine-tuned</span>\n\n<span class=\"c1\"># If we have a distributed model, save only the encapsulated model</span>\n<span class=\"c1\"># (it was wrapped in PyTorch DistributedDataParallel or DataParallel)</span>\n<span class=\"n\">model_to_save</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">module</span> <span class=\"k\">if</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"s1\">'module'</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"n\">model</span>\n\n<span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"n\">model_to_save</span><span class=\"o\">.</span><span class=\"n\">state_dict</span><span class=\"p\">(),</span> <span class=\"n\">output_model_file</span><span class=\"p\">)</span>\n<span class=\"n\">model_to_save</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">to_json_file</span><span class=\"p\">(</span><span class=\"n\">output_config_file</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span><span class=\"o\">.</span><span class=\"n\">save_vocabulary</span><span class=\"p\">(</span><span class=\"n\">output_vocab_file</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Step 2: Re-load the saved model and vocabulary</span>\n\n<span class=\"c1\"># We didn't save using the predefined WEIGHTS_NAME, CONFIG_NAME names, we cannot load using `from_pretrained`.</span>\n<span class=\"c1\"># Here is how to do it in this situation:</span>\n\n<span class=\"c1\"># Example for a Bert model</span>\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">BertConfig</span><span class=\"o\">.</span><span class=\"n\">from_json_file</span><span class=\"p\">(</span><span class=\"n\">output_config_file</span><span class=\"p\">)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">BertForQuestionAnswering</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"p\">)</span>\n<span class=\"n\">state_dict</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">output_model_file</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">load_state_dict</span><span class=\"p\">(</span><span class=\"n\">state_dict</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">BertTokenizer</span><span class=\"p\">(</span><span class=\"n\">output_vocab_file</span><span class=\"p\">,</span> <span class=\"n\">do_lower_case</span><span class=\"o\">=</span><span class=\"n\">args</span><span class=\"o\">.</span><span class=\"n\">do_lower_case</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Example for a GPT model</span>\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTConfig</span><span class=\"o\">.</span><span class=\"n\">from_json_file</span><span class=\"p\">(</span><span class=\"n\">output_config_file</span><span class=\"p\">)</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTDoubleHeadsModel</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"p\">)</span>\n<span class=\"n\">state_dict</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">output_model_file</span><span class=\"p\">)</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">load_state_dict</span><span class=\"p\">(</span><span class=\"n\">state_dict</span><span class=\"p\">)</span>\n<span class=\"n\">tokenizer</span> <span class=\"o\">=</span> <span class=\"n\">OpenAIGPTTokenizer</span><span class=\"p\">(</span><span class=\"n\">output_vocab_file</span><span class=\"p\">)</span>\n</pre>\n<h3>Configurations</h3>\n<p>Models (BERT, GPT, GPT-2 and Transformer-XL) are defined and build from configuration classes which containes the parameters of the models (number of layers, dimensionalities...) and a few utilities to read and write from JSON configuration files. The respective configuration classes are:</p>\n<ul>\n<li><code>BertConfig</code> for <code>BertModel</code> and BERT classes instances.</li>\n<li><code>OpenAIGPTConfig</code> for <code>OpenAIGPTModel</code> and OpenAI GPT classes instances.</li>\n<li><code>GPT2Config</code> for <code>GPT2Model</code> and OpenAI GPT-2 classes instances.</li>\n<li><code>TransfoXLConfig</code> for <code>TransfoXLModel</code> and Transformer-XL classes instances.</li>\n</ul>\n<p>These configuration classes contains a few utilities to load and save configurations:</p>\n<ul>\n<li><code>from_dict(cls, json_object)</code>: A class method to construct a configuration from a Python dictionary of parameters. Returns an instance of the configuration class.</li>\n<li><code>from_json_file(cls, json_file)</code>: A class method to construct a configuration from a json file of parameters. Returns an instance of the configuration class.</li>\n<li><code>to_dict()</code>: Serializes an instance to a Python dictionary. Returns a dictionary.</li>\n<li><code>to_json_string()</code>: Serializes an instance to a JSON string. Returns a string.</li>\n<li><code>to_json_file(json_file_path)</code>: Save an instance to a json file.</li>\n</ul>\n<h3>Models</h3>\n<h4>1. <code>BertModel</code></h4>\n<p><code>BertModel</code> is the basic BERT Transformer model with a layer of summed token, position and sequence embeddings followed by a series of identical self-attention blocks (12 for BERT-base, 24 for BERT-large).</p>\n<p>The inputs and output are <strong>identical to the TensorFlow model inputs and outputs</strong>.</p>\n<p>We detail them here. This model takes as <em>inputs</em>:\n<a href=\"./pytorch_pretrained_bert/modeling.py\" rel=\"nofollow\"><code>modeling.py</code></a></p>\n<ul>\n<li><code>input_ids</code>: a torch.LongTensor of shape [batch_size, sequence_length] with the word token indices in the vocabulary (see the tokens preprocessing logic in the scripts <a href=\"./examples/extract_features.py\" rel=\"nofollow\"><code>extract_features.py</code></a>, <a href=\"./examples/run_classifier.py\" rel=\"nofollow\"><code>run_classifier.py</code></a> and <a href=\"./examples/run_squad.py\" rel=\"nofollow\"><code>run_squad.py</code></a>), and</li>\n<li><code>token_type_ids</code>: an optional torch.LongTensor of shape [batch_size, sequence_length] with the token types indices selected in [0, 1]. Type 0 corresponds to a <code>sentence A</code> and type 1 corresponds to a <code>sentence B</code> token (see BERT paper for more details).</li>\n<li><code>attention_mask</code>: an optional torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [0, 1]. It's a mask to be used if some input sequence lengths are smaller than the max input sequence length of the current batch. It's the mask that we typically use for attention when a batch has varying length sentences.</li>\n<li><code>output_all_encoded_layers</code>: boolean which controls the content of the <code>encoded_layers</code> output as described below. Default: <code>True</code>.</li>\n</ul>\n<p>This model <em>outputs</em> a tuple composed of:</p>\n<ul>\n<li>\n<p><code>encoded_layers</code>: controled by the value of the <code>output_encoded_layers</code> argument:</p>\n<ul>\n<li><code>output_all_encoded_layers=True</code>: outputs a list of the encoded-hidden-states at the end of each attention block (i.e. 12 full sequences for BERT-base, 24 for BERT-large), each encoded-hidden-state is a torch.FloatTensor of size [batch_size, sequence_length, hidden_size],</li>\n<li><code>output_all_encoded_layers=False</code>: outputs only the encoded-hidden-states corresponding to the last attention block, i.e. a single torch.FloatTensor of size [batch_size, sequence_length, hidden_size],</li>\n</ul>\n</li>\n<li>\n<p><code>pooled_output</code>: a torch.FloatTensor of size [batch_size, hidden_size] which is the output of a classifier pretrained on top of the hidden state associated to the first character of the input (<code>CLF</code>) to train on the Next-Sentence task (see BERT's paper).</p>\n</li>\n</ul>\n<p>An example on how to use this class is given in the <a href=\"./examples/extract_features.py\" rel=\"nofollow\"><code>extract_features.py</code></a> script which can be used to extract the hidden states of the model for a given input.</p>\n<h4>2. <code>BertForPreTraining</code></h4>\n<p><code>BertForPreTraining</code> includes the <code>BertModel</code> Transformer followed by the two pre-training heads:</p>\n<ul>\n<li>the masked language modeling head, and</li>\n<li>the next sentence classification head.</li>\n</ul>\n<p><em>Inputs</em> comprises the inputs of the <a href=\"#-1.-%60BertModel%60\" rel=\"nofollow\"><code>BertModel</code></a> class plus two optional labels:</p>\n<ul>\n<li><code>masked_lm_labels</code>: masked language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size]</li>\n<li><code>next_sentence_label</code>: next sentence classification loss: torch.LongTensor of shape [batch_size] with indices selected in [0, 1]. 0 =&gt; next sentence is the continuation, 1 =&gt; next sentence is a random sentence.</li>\n</ul>\n<p><em>Outputs</em>:</p>\n<ul>\n<li>\n<p>if <code>masked_lm_labels</code> and <code>next_sentence_label</code> are not <code>None</code>: Outputs the total_loss which is the sum of the masked language modeling loss and the next sentence classification loss.</p>\n</li>\n<li>\n<p>if <code>masked_lm_labels</code> or <code>next_sentence_label</code> is <code>None</code>: Outputs a tuple comprising</p>\n<ul>\n<li>the masked language modeling logits, and</li>\n<li>the next sentence classification logits.</li>\n</ul>\n</li>\n</ul>\n<p>An example on how to use this class is given in the <a href=\"./examples/run_lm_finetuning.py\" rel=\"nofollow\"><code>run_lm_finetuning.py</code></a> script which can be used to fine-tune the BERT language model on your specific different text corpus. This should improve model performance, if the language style is different from the original BERT training corpus (Wiki + BookCorpus).</p>\n<h4>3. <code>BertForMaskedLM</code></h4>\n<p><code>BertForMaskedLM</code> includes the <code>BertModel</code> Transformer followed by the (possibly) pre-trained  masked language modeling head.</p>\n<p><em>Inputs</em> comprises the inputs of the <a href=\"#-1.-%60BertModel%60\" rel=\"nofollow\"><code>BertModel</code></a> class plus optional label:</p>\n<ul>\n<li><code>masked_lm_labels</code>: masked language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size]</li>\n</ul>\n<p><em>Outputs</em>:</p>\n<ul>\n<li>if <code>masked_lm_labels</code> is not <code>None</code>: Outputs the masked language modeling loss.</li>\n<li>if <code>masked_lm_labels</code> is <code>None</code>: Outputs the masked language modeling logits.</li>\n</ul>\n<h4>4. <code>BertForNextSentencePrediction</code></h4>\n<p><code>BertForNextSentencePrediction</code> includes the <code>BertModel</code> Transformer followed by the next sentence classification head.</p>\n<p><em>Inputs</em> comprises the inputs of the <a href=\"#-1.-%60BertModel%60\" rel=\"nofollow\"><code>BertModel</code></a> class plus an optional label:</p>\n<ul>\n<li><code>next_sentence_label</code>: next sentence classification loss: torch.LongTensor of shape [batch_size] with indices selected in [0, 1]. 0 =&gt; next sentence is the continuation, 1 =&gt; next sentence is a random sentence.</li>\n</ul>\n<p><em>Outputs</em>:</p>\n<ul>\n<li>if <code>next_sentence_label</code> is not <code>None</code>: Outputs the next sentence classification loss.</li>\n<li>if <code>next_sentence_label</code> is <code>None</code>: Outputs the next sentence classification logits.</li>\n</ul>\n<h4>5. <code>BertForSequenceClassification</code></h4>\n<p><code>BertForSequenceClassification</code> is a fine-tuning model that includes <code>BertModel</code> and a sequence-level (sequence or pair of sequences) classifier on top of the <code>BertModel</code>.</p>\n<p>The sequence-level classifier is a linear layer that takes as input the last hidden state of the first character in the input sequence (see Figures 3a and 3b in the BERT paper).</p>\n<p>An example on how to use this class is given in the <a href=\"./examples/run_classifier.py\" rel=\"nofollow\"><code>run_classifier.py</code></a> script which can be used to fine-tune a single sequence (or pair of sequence) classifier using BERT, for example for the MRPC task.</p>\n<h4>6. <code>BertForMultipleChoice</code></h4>\n<p><code>BertForMultipleChoice</code> is a fine-tuning model that includes <code>BertModel</code> and a linear layer on top of the <code>BertModel</code>.</p>\n<p>The linear layer outputs a single value for each choice of a multiple choice problem, then all the outputs corresponding to an instance are passed through a softmax to get the model choice.</p>\n<p>This implementation is largely inspired by the work of OpenAI in <a href=\"https://blog.openai.com/language-unsupervised/\" rel=\"nofollow\">Improving Language Understanding by Generative Pre-Training</a> and the answer of Jacob Devlin in the following <a href=\"https://github.com/google-research/bert/issues/38\" rel=\"nofollow\">issue</a>.</p>\n<p>An example on how to use this class is given in the <a href=\"./examples/run_swag.py\" rel=\"nofollow\"><code>run_swag.py</code></a> script which can be used to fine-tune a multiple choice classifier using BERT, for example for the Swag task.</p>\n<h4>7. <code>BertForTokenClassification</code></h4>\n<p><code>BertForTokenClassification</code> is a fine-tuning model that includes <code>BertModel</code> and a token-level classifier on top of the <code>BertModel</code>.</p>\n<p>The token-level classifier is a linear layer that takes as input the last hidden state of the sequence.</p>\n<h4>8. <code>BertForQuestionAnswering</code></h4>\n<p><code>BertForQuestionAnswering</code> is a fine-tuning model that includes <code>BertModel</code> with a token-level classifiers on top of the full sequence of last hidden states.</p>\n<p>The token-level classifier takes as input the full sequence of the last hidden state and compute several (e.g. two) scores for each tokens that can for example respectively be the score that a given token is a <code>start_span</code> and a <code>end_span</code> token (see Figures 3c and 3d in the BERT paper).</p>\n<p>An example on how to use this class is given in the <a href=\"./examples/run_squad.py\" rel=\"nofollow\"><code>run_squad.py</code></a> script which can be used to fine-tune a token classifier using BERT, for example for the SQuAD task.</p>\n<h4>9. <code>OpenAIGPTModel</code></h4>\n<p><code>OpenAIGPTModel</code> is the basic OpenAI GPT Transformer model with a layer of summed token and position embeddings followed by a series of 12 identical self-attention blocks.</p>\n<p>OpenAI GPT use a single embedding matrix to store the word and special embeddings.\nSpecial tokens embeddings are additional tokens that are not pre-trained: <code>[SEP]</code>, <code>[CLS]</code>...\nSpecial tokens need to be trained during the fine-tuning if you use them.\nThe number of special embeddings can be controled using the <code>set_num_special_tokens(num_special_tokens)</code> function.</p>\n<p>The embeddings are ordered as follow in the token embeddings matrice:</p>\n<pre>    <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span>                                                         <span class=\"o\">----------------------</span>\n      <span class=\"o\">...</span>                                                        <span class=\"o\">-&gt;</span> <span class=\"n\">word</span> <span class=\"n\">embeddings</span>\n      <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">vocab_size</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span>                                     <span class=\"n\">______________________</span>\n      <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">vocab_size</span><span class=\"p\">,</span>\n      <span class=\"o\">...</span>                                                        <span class=\"o\">-&gt;</span> <span class=\"n\">special</span> <span class=\"n\">embeddings</span>\n      <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">vocab_size</span> <span class=\"o\">+</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">n_special</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span>                  <span class=\"n\">______________________</span>\n</pre>\n<p>where total_tokens_embeddings can be obtained as config.total_tokens_embeddings and is:\n<code>total_tokens_embeddings = config.vocab_size + config.n_special</code>\nYou should use the associate indices to index the embeddings.</p>\n<p>The inputs and output are <strong>identical to the TensorFlow model inputs and outputs</strong>.</p>\n<p>We detail them here. This model takes as <em>inputs</em>:\n<a href=\"./pytorch_pretrained_bert/modeling_openai.py\" rel=\"nofollow\"><code>modeling_openai.py</code></a></p>\n<ul>\n<li><code>input_ids</code>: a torch.LongTensor of shape [batch_size, sequence_length] (or more generally [d_1, ..., d_n, sequence_length] were d_1 ... d_n are arbitrary dimensions) with the word BPE token indices selected in the range [0, total_tokens_embeddings[</li>\n<li><code>position_ids</code>: an optional torch.LongTensor with the same shape as input_ids\nwith the position indices (selected in the range [0, config.n_positions - 1[.</li>\n<li><code>token_type_ids</code>: an optional torch.LongTensor with the same shape as input_ids\nYou can use it to add a third type of embedding to each input token in the sequence\n(the previous two being the word and position embeddings). The input, position and token_type embeddings are summed inside the Transformer before the first self-attention block.</li>\n</ul>\n<p>This model <em>outputs</em>:</p>\n<ul>\n<li><code>hidden_states</code>: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, hidden_size] (or more generally [d_1, ..., d_n, hidden_size] were d_1 ... d_n are the dimension of input_ids)</li>\n</ul>\n<h4>10. <code>OpenAIGPTLMHeadModel</code></h4>\n<p><code>OpenAIGPTLMHeadModel</code> includes the <code>OpenAIGPTModel</code> Transformer followed by a language modeling head with weights tied to the input embeddings (no additional parameters).</p>\n<p><em>Inputs</em> are the same as the inputs of the <a href=\"#-9.-%60OpenAIGPTModel%60\" rel=\"nofollow\"><code>OpenAIGPTModel</code></a> class plus optional labels:</p>\n<ul>\n<li><code>lm_labels</code>: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size].</li>\n</ul>\n<p><em>Outputs</em>:</p>\n<ul>\n<li>if <code>lm_labels</code> is not <code>None</code>:\nOutputs the language modeling loss.</li>\n<li>else:\nOutputs <code>lm_logits</code>: the language modeling logits as a torch.FloatTensor of size [batch_size, sequence_length, total_tokens_embeddings] (or more generally [d_1, ..., d_n, total_tokens_embeddings] were d_1 ... d_n are the dimension of input_ids)</li>\n</ul>\n<h4>11. <code>OpenAIGPTDoubleHeadsModel</code></h4>\n<p><code>OpenAIGPTDoubleHeadsModel</code> includes the <code>OpenAIGPTModel</code> Transformer followed by two heads:</p>\n<ul>\n<li>a language modeling head with weights tied to the input embeddings (no additional parameters) and:</li>\n<li>a multiple choice classifier (linear layer that take as input a hidden state in a sequence to compute a score, see details in paper).</li>\n</ul>\n<p><em>Inputs</em> are the same as the inputs of the <a href=\"#-9.-%60OpenAIGPTModel%60\" rel=\"nofollow\"><code>OpenAIGPTModel</code></a> class plus a classification mask and two optional labels:</p>\n<ul>\n<li><code>multiple_choice_token_ids</code>: a torch.LongTensor of shape [batch_size, num_choices] with the index of the token whose hidden state should be used as input for the multiple choice classifier (usually the [CLS] token for each choice).</li>\n<li><code>lm_labels</code>: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size].</li>\n<li><code>multiple_choice_labels</code>: optional multiple choice labels: torch.LongTensor of shape [batch_size] with indices selected in [0, ..., num_choices].</li>\n</ul>\n<p><em>Outputs</em>:</p>\n<ul>\n<li>if <code>lm_labels</code> and <code>multiple_choice_labels</code> are not <code>None</code>:\nOutputs a tuple of losses with the language modeling loss and the multiple choice loss.</li>\n<li>else Outputs a tuple with:\n<ul>\n<li><code>lm_logits</code>: the language modeling logits as a torch.FloatTensor of size [batch_size, num_choices, sequence_length, total_tokens_embeddings]</li>\n<li><code>multiple_choice_logits</code>: the multiple choice logits as a torch.FloatTensor of size [batch_size, num_choices]</li>\n</ul>\n</li>\n</ul>\n<h4>12. <code>TransfoXLModel</code></h4>\n<p>The Transformer-XL model is described in \"Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context\".</p>\n<p>Transformer XL use a relative positioning with sinusiodal patterns and adaptive softmax inputs which means that:</p>\n<ul>\n<li>you don't need to specify positioning embeddings indices</li>\n<li>the tokens in the vocabulary have to be sorted to decreasing frequency.</li>\n</ul>\n<p>This model takes as <em>inputs</em>:\n<a href=\"./pytorch_pretrained_bert/modeling_transfo_xl.py\" rel=\"nofollow\"><code>modeling_transfo_xl.py</code></a></p>\n<ul>\n<li><code>input_ids</code>: a torch.LongTensor of shape [batch_size, sequence_length] with the token indices selected in the range [0, self.config.n_token[</li>\n<li><code>mems</code>: an optional memory of hidden states from previous forward passes as a list (num layers) of hidden states at the entry of each layer. Each hidden states has shape [self.config.mem_len, bsz, self.config.d_model]. Note that the first two dimensions are transposed in <code>mems</code> with regards to <code>input_ids</code>.</li>\n</ul>\n<p>This model <em>outputs</em> a tuple of (last_hidden_state, new_mems)</p>\n<ul>\n<li><code>last_hidden_state</code>: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, self.config.d_model]</li>\n<li><code>new_mems</code>: list (num layers) of updated mem states at the entry of each layer each mem state is a torch.FloatTensor of size [self.config.mem_len, batch_size, self.config.d_model]. Note that the first two dimensions are transposed in <code>mems</code> with regards to <code>input_ids</code>.</li>\n</ul>\n<h5>Extracting a list of the hidden states at each layer of the Transformer-XL from <code>last_hidden_state</code> and <code>new_mems</code>:</h5>\n<p>The <code>new_mems</code> contain all the hidden states PLUS the output of the embeddings (<code>new_mems[0]</code>). <code>new_mems[-1]</code> is the output of the hidden state of the layer below the last layer and <code>last_hidden_state</code> is the output of the last layer (i.E. the input of the softmax when we have a language modeling head on top).</p>\n<p>There are two differences between the shapes of <code>new_mems</code> and <code>last_hidden_state</code>: <code>new_mems</code> have transposed first dimensions and are longer (of size <code>self.config.mem_len</code>). Here is how to extract the full list of hidden states from the model output:</p>\n<pre><span class=\"n\">hidden_states</span><span class=\"p\">,</span> <span class=\"n\">mems</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"p\">(</span><span class=\"n\">tokens_tensor</span><span class=\"p\">)</span>\n<span class=\"n\">seq_length</span> <span class=\"o\">=</span> <span class=\"n\">hidden_states</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">lower_hidden_states</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"n\">seq_length</span><span class=\"p\">:,</span> <span class=\"o\">...</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">mems</span><span class=\"p\">)</span>\n<span class=\"n\">all_hidden_states</span> <span class=\"o\">=</span> <span class=\"n\">lower_hidden_states</span> <span class=\"o\">+</span> <span class=\"p\">[</span><span class=\"n\">hidden_states</span><span class=\"p\">]</span>\n</pre>\n<h4>13. <code>TransfoXLLMHeadModel</code></h4>\n<p><code>TransfoXLLMHeadModel</code> includes the <code>TransfoXLModel</code> Transformer followed by an (adaptive) softmax head with weights tied to the input embeddings.</p>\n<p><em>Inputs</em> are the same as the inputs of the <a href=\"#-12.-%60TransfoXLModel%60\" rel=\"nofollow\"><code>TransfoXLModel</code></a> class plus optional labels:</p>\n<ul>\n<li><code>target</code>: an optional torch.LongTensor of shape [batch_size, sequence_length] with the target token indices selected in the range [0, self.config.n_token[</li>\n</ul>\n<p><em>Outputs</em> a tuple of (last_hidden_state, new_mems)</p>\n<ul>\n<li><code>softmax_output</code>: output of the (adaptive) softmax:\n<ul>\n<li>if target is None: log probabilities of tokens, shape [batch_size, sequence_length, n_tokens]</li>\n<li>else: Negative log likelihood of target tokens with shape [batch_size, sequence_length]</li>\n</ul>\n</li>\n<li><code>new_mems</code>: list (num layers) of updated mem states at the entry of each layer each mem state is a torch.FloatTensor of size [self.config.mem_len, batch_size, self.config.d_model]. Note that the first two dimensions are transposed in <code>mems</code> with regards to <code>input_ids</code>.</li>\n</ul>\n<h4>14. <code>GPT2Model</code></h4>\n<p><code>GPT2Model</code> is the OpenAI GPT-2 Transformer model with a layer of summed token and position embeddings followed by a series of 12 identical self-attention blocks.</p>\n<p>The inputs and output are <strong>identical to the TensorFlow model inputs and outputs</strong>.</p>\n<p>We detail them here. This model takes as <em>inputs</em>:\n<a href=\"./pytorch_pretrained_bert/modeling_gpt2.py\" rel=\"nofollow\"><code>modeling_gpt2.py</code></a></p>\n<ul>\n<li><code>input_ids</code>: a torch.LongTensor of shape [batch_size, sequence_length] (or more generally [d_1, ..., d_n, sequence_length] were d_1 ... d_n are arbitrary dimensions) with the word BPE token indices selected in the range [0, vocab_size[</li>\n<li><code>position_ids</code>: an optional torch.LongTensor with the same shape as input_ids\nwith the position indices (selected in the range [0, config.n_positions - 1[.</li>\n<li><code>token_type_ids</code>: an optional torch.LongTensor with the same shape as input_ids\nYou can use it to add a third type of embedding to each input token in the sequence\n(the previous two being the word and position embeddings). The input, position and token_type embeddings are summed inside the Transformer before the first self-attention block.</li>\n<li><code>past</code>: an optional list of torch.LongTensor that contains pre-computed hidden-states (key and values in the attention blocks) to speed up sequential decoding (this is the <code>presents</code> output of the model, cf. below).</li>\n</ul>\n<p>This model <em>outputs</em>:</p>\n<ul>\n<li><code>hidden_states</code>: the encoded-hidden-states at the top of the model as a torch.FloatTensor of size [batch_size, sequence_length, hidden_size] (or more generally [d_1, ..., d_n, hidden_size] were d_1 ... d_n are the dimension of input_ids)</li>\n<li><code>presents</code>: a list of pre-computed hidden-states (key and values in each attention blocks) as a torch.FloatTensors. They can be reused to speed up sequential decoding (see the <code>run_gpt2.py</code> example).</li>\n</ul>\n<h4>15. <code>GPT2LMHeadModel</code></h4>\n<p><code>GPT2LMHeadModel</code> includes the <code>GPT2Model</code> Transformer followed by a language modeling head with weights tied to the input embeddings (no additional parameters).</p>\n<p><em>Inputs</em> are the same as the inputs of the <a href=\"#-14.-%60GPT2Model%60\" rel=\"nofollow\"><code>GPT2Model</code></a> class plus optional labels:</p>\n<ul>\n<li><code>lm_labels</code>: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size].</li>\n</ul>\n<p><em>Outputs</em>:</p>\n<ul>\n<li>if <code>lm_labels</code> is not <code>None</code>:\nOutputs the language modeling loss.</li>\n<li>else: a tuple of\n<ul>\n<li><code>lm_logits</code>: the language modeling logits as a torch.FloatTensor of size [batch_size, sequence_length, total_tokens_embeddings] (or more generally [d_1, ..., d_n, total_tokens_embeddings] were d_1 ... d_n are the dimension of input_ids)</li>\n<li><code>presents</code>: a list of pre-computed hidden-states (key and values in each attention blocks) as a torch.FloatTensors. They can be reused to speed up sequential decoding (see the <code>run_gpt2.py</code> example).</li>\n</ul>\n</li>\n</ul>\n<h4>16. <code>GPT2DoubleHeadsModel</code></h4>\n<p><code>GPT2DoubleHeadsModel</code> includes the <code>GPT2Model</code> Transformer followed by two heads:</p>\n<ul>\n<li>a language modeling head with weights tied to the input embeddings (no additional parameters) and:</li>\n<li>a multiple choice classifier (linear layer that take as input a hidden state in a sequence to compute a score, see details in paper).</li>\n</ul>\n<p><em>Inputs</em> are the same as the inputs of the <a href=\"#-14.-%60GPT2Model%60\" rel=\"nofollow\"><code>GPT2Model</code></a> class plus a classification mask and two optional labels:</p>\n<ul>\n<li><code>multiple_choice_token_ids</code>: a torch.LongTensor of shape [batch_size, num_choices] with the index of the token whose hidden state should be used as input for the multiple choice classifier (usually the [CLS] token for each choice).</li>\n<li><code>lm_labels</code>: optional language modeling labels: torch.LongTensor of shape [batch_size, sequence_length] with indices selected in [-1, 0, ..., vocab_size]. All labels set to -1 are ignored (masked), the loss is only computed for the labels set in [0, ..., vocab_size].</li>\n<li><code>multiple_choice_labels</code>: optional multiple choice labels: torch.LongTensor of shape [batch_size] with indices selected in [0, ..., num_choices].</li>\n</ul>\n<p><em>Outputs</em>:</p>\n<ul>\n<li>if <code>lm_labels</code> and <code>multiple_choice_labels</code> are not <code>None</code>:\nOutputs a tuple of losses with the language modeling loss and the multiple choice loss.</li>\n<li>else Outputs a tuple with:\n<ul>\n<li><code>lm_logits</code>: the language modeling logits as a torch.FloatTensor of size [batch_size, num_choices, sequence_length, total_tokens_embeddings]</li>\n<li><code>multiple_choice_logits</code>: the multiple choice logits as a torch.FloatTensor of size [batch_size, num_choices]</li>\n<li><code>presents</code>: a list of pre-computed hidden-states (key and values in each attention blocks) as a torch.FloatTensors. They can be reused to speed up sequential decoding (see the <code>run_gpt2.py</code> example).</li>\n</ul>\n</li>\n</ul>\n<h3>Tokenizers</h3>\n<h4><code>BertTokenizer</code></h4>\n<p><code>BertTokenizer</code> perform end-to-end tokenization, i.e. basic tokenization followed by WordPiece tokenization.</p>\n<p>This class has five arguments:</p>\n<ul>\n<li><code>vocab_file</code>: path to a vocabulary file.</li>\n<li><code>do_lower_case</code>: convert text to lower-case while tokenizing. <strong>Default = True</strong>.</li>\n<li><code>max_len</code>: max length to filter the input of the Transformer. Default to pre-trained value for the model if <code>None</code>. <strong>Default = None</strong></li>\n<li><code>do_basic_tokenize</code>: Do basic tokenization before wordpice tokenization. Set to false if text is pre-tokenized. <strong>Default = True</strong>.</li>\n<li><code>never_split</code>: a list of tokens that should not be splitted during tokenization. <strong>Default = <code>[\"[UNK]\", \"[SEP]\", \"[PAD]\", \"[CLS]\", \"[MASK]\"]</code></strong></li>\n</ul>\n<p>and three methods:</p>\n<ul>\n<li><code>tokenize(text)</code>: convert a <code>str</code> in a list of <code>str</code> tokens by (1) performing basic tokenization and (2) WordPiece tokenization.</li>\n<li><code>convert_tokens_to_ids(tokens)</code>: convert a list of <code>str</code> tokens in a list of <code>int</code> indices in the vocabulary.</li>\n<li><code>convert_ids_to_tokens(tokens)</code>: convert a list of <code>int</code> indices in a list of <code>str</code> tokens in the vocabulary.</li>\n<li><code>save_vocabulary(directory_path)</code>: save the vocabulary file to <code>directory_path</code>. Return the path to the saved vocabulary file: <code>vocab_file_path</code>. The vocabulary can be reloaded with <code>BertTokenizer.from_pretrained('vocab_file_path')</code> or <code>BertTokenizer.from_pretrained('directory_path')</code>.</li>\n</ul>\n<p>Please refer to the doc strings and code in <a href=\"./pytorch_pretrained_bert/tokenization.py\" rel=\"nofollow\"><code>tokenization.py</code></a> for the details of the <code>BasicTokenizer</code> and <code>WordpieceTokenizer</code> classes. In general it is recommended to use <code>BertTokenizer</code> unless you know what you are doing.</p>\n<h4><code>OpenAIGPTTokenizer</code></h4>\n<p><code>OpenAIGPTTokenizer</code> perform Byte-Pair-Encoding (BPE) tokenization.</p>\n<p>This class has four arguments:</p>\n<ul>\n<li><code>vocab_file</code>: path to a vocabulary file.</li>\n<li><code>merges_file</code>: path to a file containing the BPE merges.</li>\n<li><code>max_len</code>: max length to filter the input of the Transformer. Default to pre-trained value for the model if <code>None</code>. <strong>Default = None</strong></li>\n<li><code>special_tokens</code>: a list of tokens to add to the vocabulary for fine-tuning. If SpaCy is not installed and BERT's <code>BasicTokenizer</code> is used as the pre-BPE tokenizer, these tokens are not split. <strong>Default= None</strong></li>\n</ul>\n<p>and five methods:</p>\n<ul>\n<li><code>tokenize(text)</code>: convert a <code>str</code> in a list of <code>str</code> tokens by performing BPE tokenization.</li>\n<li><code>convert_tokens_to_ids(tokens)</code>: convert a list of <code>str</code> tokens in a list of <code>int</code> indices in the vocabulary.</li>\n<li><code>convert_ids_to_tokens(tokens)</code>: convert a list of <code>int</code> indices in a list of <code>str</code> tokens in the vocabulary.</li>\n<li><code>set_special_tokens(self, special_tokens)</code>: update the list of special tokens (see above arguments)</li>\n<li><code>encode(text)</code>: convert a <code>str</code> in a list of <code>int</code> tokens by performing BPE encoding.</li>\n<li><code>decode(ids, skip_special_tokens=False, clean_up_tokenization_spaces=False)</code>: decode a list of <code>int</code> indices in a string and do some post-processing if needed: (i) remove special tokens from the output and (ii) clean up tokenization spaces.</li>\n<li><code>save_vocabulary(directory_path)</code>: save the vocabulary, merge and special tokens files to <code>directory_path</code>. Return the path to the three files: <code>vocab_file_path</code>, <code>merge_file_path</code>, <code>special_tokens_file_path</code>. The vocabulary can be reloaded with <code>OpenAIGPTTokenizer.from_pretrained('directory_path')</code>.</li>\n</ul>\n<p>Please refer to the doc strings and code in <a href=\"./pytorch_pretrained_bert/tokenization_openai.py\" rel=\"nofollow\"><code>tokenization_openai.py</code></a> for the details of the <code>OpenAIGPTTokenizer</code>.</p>\n<h4><code>TransfoXLTokenizer</code></h4>\n<p><code>TransfoXLTokenizer</code> perform word tokenization. This tokenizer can be used for adaptive softmax and has utilities for counting tokens in a corpus to create a vocabulary ordered by toekn frequency (for adaptive softmax). See the adaptive softmax paper (<a href=\"http://arxiv.org/abs/1609.04309\" rel=\"nofollow\">Efficient softmax approximation for GPUs</a>) for more details.</p>\n<p>The API is similar to the API of <code>BertTokenizer</code> (see above).</p>\n<p>Please refer to the doc strings and code in <a href=\"./pytorch_pretrained_bert/tokenization_transfo_xl.py\" rel=\"nofollow\"><code>tokenization_transfo_xl.py</code></a> for the details of these additional methods in <code>TransfoXLTokenizer</code>.</p>\n<h4><code>GPT2Tokenizer</code></h4>\n<p><code>GPT2Tokenizer</code> perform byte-level Byte-Pair-Encoding (BPE) tokenization.</p>\n<p>This class has three arguments:</p>\n<ul>\n<li><code>vocab_file</code>: path to a vocabulary file.</li>\n<li><code>merges_file</code>: path to a file containing the BPE merges.</li>\n<li><code>errors</code>: How to handle unicode decoding errors. <strong>Default = <code>replace</code></strong></li>\n</ul>\n<p>and two methods:</p>\n<ul>\n<li><code>tokenize(text)</code>: convert a <code>str</code> in a list of <code>str</code> tokens by performing byte-level BPE.</li>\n<li><code>convert_tokens_to_ids(tokens)</code>: convert a list of <code>str</code> tokens in a list of <code>int</code> indices in the vocabulary.</li>\n<li><code>convert_ids_to_tokens(tokens)</code>: convert a list of <code>int</code> indices in a list of <code>str</code> tokens in the vocabulary.</li>\n<li><code>set_special_tokens(self, special_tokens)</code>: update the list of special tokens (see above arguments)</li>\n<li><code>encode(text)</code>: convert a <code>str</code> in a list of <code>int</code> tokens by performing byte-level BPE.</li>\n<li><code>decode(tokens)</code>: convert back a list of <code>int</code> tokens in a <code>str</code>.</li>\n<li><code>save_vocabulary(directory_path)</code>: save the vocabulary, merge and special tokens files to <code>directory_path</code>. Return the path to the three files: <code>vocab_file_path</code>, <code>merge_file_path</code>, <code>special_tokens_file_path</code>. The vocabulary can be reloaded with <code>OpenAIGPTTokenizer.from_pretrained('directory_path')</code>.</li>\n</ul>\n<p>Please refer to <a href=\"./pytorch_pretrained_bert/tokenization_gpt2.py\" rel=\"nofollow\"><code>tokenization_gpt2.py</code></a> for more details on the <code>GPT2Tokenizer</code>.</p>\n<h3>Optimizers</h3>\n<h4><code>BertAdam</code></h4>\n<p><code>BertAdam</code> is a <code>torch.optimizer</code> adapted to be closer to the optimizer used in the TensorFlow implementation of Bert. The differences with PyTorch Adam optimizer are the following:</p>\n<ul>\n<li>BertAdam implements weight decay fix,</li>\n<li>BertAdam doesn't compensate for bias as in the regular Adam optimizer.</li>\n</ul>\n<p>The optimizer accepts the following arguments:</p>\n<ul>\n<li><code>lr</code> : learning rate</li>\n<li><code>warmup</code> : portion of <code>t_total</code> for the warmup, <code>-1</code>  means no warmup. Default : <code>-1</code></li>\n<li><code>t_total</code> : total number of training steps for the learning\nrate schedule, <code>-1</code>  means constant learning rate. Default : <code>-1</code></li>\n<li><code>schedule</code> : schedule to use for the warmup (see above).\nCan be <code>'warmup_linear'</code>, <code>'warmup_constant'</code>, <code>'warmup_cosine'</code>, <code>'none'</code>, <code>None</code> or a <code>_LRSchedule</code> object (see below).\nIf <code>None</code> or <code>'none'</code>, learning rate is always kept constant.\nDefault : <code>'warmup_linear'</code></li>\n<li><code>b1</code> : Adams b1. Default : <code>0.9</code></li>\n<li><code>b2</code> : Adams b2. Default : <code>0.999</code></li>\n<li><code>e</code> : Adams epsilon. Default : <code>1e-6</code></li>\n<li><code>weight_decay:</code> Weight decay. Default : <code>0.01</code></li>\n<li><code>max_grad_norm</code> : Maximum norm for the gradients (<code>-1</code> means no clipping). Default : <code>1.0</code></li>\n</ul>\n<h4><code>OpenAIAdam</code></h4>\n<p><code>OpenAIAdam</code> is similar to <code>BertAdam</code>.\nThe differences with <code>BertAdam</code> is that <code>OpenAIAdam</code> compensate for bias as in the regular Adam optimizer.</p>\n<p><code>OpenAIAdam</code> accepts the same arguments as <code>BertAdam</code>.</p>\n<h4>Learning Rate Schedules</h4>\n<p>The <code>.optimization</code> module also provides additional schedules in the form of schedule objects that inherit from <code>_LRSchedule</code>.\nAll <code>_LRSchedule</code> subclasses accept <code>warmup</code> and <code>t_total</code> arguments at construction.\nWhen an <code>_LRSchedule</code> object is passed into <code>BertAdam</code> or <code>OpenAIAdam</code>,\nthe <code>warmup</code> and <code>t_total</code> arguments on the optimizer are ignored and the ones in the <code>_LRSchedule</code> object are used.\nAn overview of the implemented schedules:</p>\n<ul>\n<li><code>ConstantLR</code>: always returns learning rate 1.</li>\n<li><code>WarmupConstantSchedule</code>: Linearly increases learning rate from 0 to 1 over <code>warmup</code> fraction of training steps.\nKeeps learning rate equal to 1. after warmup.\n<img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5ecd3a2cac5237a8f6125433e3e9130a97a5a945/646f63732f696d67732f7761726d75705f636f6e7374616e745f7363686564756c652e706e67\"></li>\n<li><code>WarmupLinearSchedule</code>: Linearly increases learning rate from 0 to 1 over <code>warmup</code> fraction of training steps.\nLinearly decreases learning rate from 1. to 0. over remaining <code>1 - warmup</code> steps.\n<img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9b18320cb2432a88bcc70a72b74b7e0405d205c5/646f63732f696d67732f7761726d75705f6c696e6561725f7363686564756c652e706e67\"></li>\n<li><code>WarmupCosineSchedule</code>: Linearly increases learning rate from 0 to 1 over <code>warmup</code> fraction of training steps.\nDecreases learning rate from 1. to 0. over remaining <code>1 - warmup</code> steps following a cosine curve.\nIf <code>cycles</code> (default=0.5) is different from default, learning rate follows cosine function after warmup.\n<img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/885b6577cc5ea8b172477b5332112fab262c57b6/646f63732f696d67732f7761726d75705f636f73696e655f7363686564756c652e706e67\"></li>\n<li><code>WarmupCosineWithHardRestartsSchedule</code>: Linearly increases learning rate from 0 to 1 over <code>warmup</code> fraction of training steps.\nIf <code>cycles</code> (default=1.) is different from default, learning rate follows <code>cycles</code> times a cosine decaying learning rate (with hard restarts).\n<img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/239296266f8bc90e561675e83014797e11bfdd8c/646f63732f696d67732f7761726d75705f636f73696e655f686172645f72657374617274735f7363686564756c652e706e67\"></li>\n<li><code>WarmupCosineWithWarmupRestartsSchedule</code>: All training progress is divided in <code>cycles</code> (default=1.) parts of equal length.\nEvery part follows a schedule with the first <code>warmup</code> fraction of the training steps linearly increasing from 0. to 1.,\nfollowed by a learning rate decreasing from 1. to 0. following a cosine curve.\nNote that the total number of all warmup steps over all cycles together is equal to <code>warmup</code> * <code>cycles</code>\n<img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f9b92c55b5e842f2418f59893e06f380919e1040/646f63732f696d67732f7761726d75705f636f73696e655f7761726d5f72657374617274735f7363686564756c652e706e67\"></li>\n</ul>\n<h2>Examples</h2>\n<table>\n<thead>\n<tr>\n<th>Sub-section</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"#Training-large-models-introduction,-tools-and-examples\" rel=\"nofollow\">Training large models: introduction, tools and examples</a></td>\n<td>How to use gradient-accumulation, multi-gpu training, distributed training, optimize on CPU and 16-bits training to train Bert models</td>\n</tr>\n<tr>\n<td><a href=\"#Fine-tuning-with-BERT-running-the-examples\" rel=\"nofollow\">Fine-tuning with BERT: running the examples</a></td>\n<td>Running the examples in <a href=\"./examples/\" rel=\"nofollow\"><code>./examples</code></a>: <code>extract_classif.py</code>, <code>run_classifier.py</code>, <code>run_squad.py</code> and <code>run_lm_finetuning.py</code></td>\n</tr>\n<tr>\n<td><a href=\"#Fine-tuning-with-OpenAI-GPT-Transformer-XL-and-GPT-2\" rel=\"nofollow\">Fine-tuning with OpenAI GPT, Transformer-XL and GPT-2</a></td>\n<td>Running the examples in <a href=\"./examples/\" rel=\"nofollow\"><code>./examples</code></a>: <code>run_openai_gpt.py</code>, <code>run_transfo_xl.py</code> and <code>run_gpt2.py</code></td>\n</tr>\n<tr>\n<td><a href=\"#Fine-tuning-BERT-large-on-GPUs\" rel=\"nofollow\">Fine-tuning BERT-large on GPUs</a></td>\n<td>How to fine tune <code>BERT large</code></td>\n</tr></tbody></table>\n<h3>Training large models: introduction, tools and examples</h3>\n<p>BERT-base and BERT-large are respectively 110M and 340M parameters models and it can be difficult to fine-tune them on a single GPU with the recommended batch size for good performance (in most case a batch size of 32).</p>\n<p>To help with fine-tuning these models, we have included several techniques that you can activate in the fine-tuning scripts <a href=\"./examples/run_classifier.py\" rel=\"nofollow\"><code>run_classifier.py</code></a> and <a href=\"./examples/run_squad.py\" rel=\"nofollow\"><code>run_squad.py</code></a>: gradient-accumulation, multi-gpu training, distributed training and 16-bits training . For more details on how to use these techniques you can read <a href=\"https://medium.com/huggingface/training-larger-batches-practical-tips-on-1-gpu-multi-gpu-distributed-setups-ec88c3e51255\" rel=\"nofollow\">the tips on training large batches in PyTorch</a> that I published earlier this month.</p>\n<p>Here is how to use these techniques in our scripts:</p>\n<ul>\n<li><strong>Gradient Accumulation</strong>: Gradient accumulation can be used by supplying a integer greater than 1 to the <code>--gradient_accumulation_steps</code> argument. The batch at each step will be divided by this integer and gradient will be accumulated over <code>gradient_accumulation_steps</code> steps.</li>\n<li><strong>Multi-GPU</strong>: Multi-GPU is automatically activated when several GPUs are detected and the batches are splitted over the GPUs.</li>\n<li><strong>Distributed training</strong>: Distributed training can be activated by supplying an integer greater or equal to 0 to the <code>--local_rank</code> argument (see below).</li>\n<li><strong>16-bits training</strong>: 16-bits training, also called mixed-precision training, can reduce the memory requirement of your model on the GPU by using half-precision training, basically allowing to double the batch size. If you have a recent GPU (starting from NVIDIA Volta architecture) you should see no decrease in speed. A good introduction to Mixed precision training can be found <a href=\"https://devblogs.nvidia.com/mixed-precision-training-deep-neural-networks/\" rel=\"nofollow\">here</a> and a full documentation is <a href=\"https://docs.nvidia.com/deeplearning/sdk/mixed-precision-training/index.html\" rel=\"nofollow\">here</a>. In our scripts, this option can be activated by setting the <code>--fp16</code> flag and you can play with loss scaling using the <code>--loss_scale</code> flag (see the previously linked documentation for details on loss scaling). The loss scale can be zero in which case the scale is dynamically adjusted or a positive power of two in which case the scaling is static.</li>\n</ul>\n<p>To use 16-bits training and distributed training, you need to install NVIDIA's apex extension <a href=\"https://github.com/nvidia/apex\" rel=\"nofollow\">as detailed here</a>. You will find more information regarding the internals of <code>apex</code> and how to use <code>apex</code> in <a href=\"https://github.com/nvidia/apex\" rel=\"nofollow\">the doc and the associated repository</a>. The results of the tests performed on pytorch-BERT by the NVIDIA team (and my trials at reproducing them) can be consulted in <a href=\"https://github.com/huggingface/pytorch-pretrained-BERT/pull/116\" rel=\"nofollow\">the relevant PR of the present repository</a>.</p>\n<p>Note: To use <em>Distributed Training</em>, you will need to run one training script on each of your machines. This can be done for example by running the following command on each server (see <a href=\"(https://medium.com/huggingface/training-larger-batches-practical-tips-on-1-gpu-multi-gpu-distributed-setups-ec88c3e51255)\" rel=\"nofollow\">the above mentioned blog post</a> for more details):</p>\n<pre>python -m torch.distributed.launch --nproc_per_node<span class=\"o\">=</span><span class=\"m\">4</span> --nnodes<span class=\"o\">=</span><span class=\"m\">2</span> --node_rank<span class=\"o\">=</span><span class=\"nv\">$THIS_MACHINE_INDEX</span> --master_addr<span class=\"o\">=</span><span class=\"s2\">\"192.168.1.1\"</span> --master_port<span class=\"o\">=</span><span class=\"m\">1234</span> run_classifier.py <span class=\"o\">(</span>--arg1 --arg2 --arg3 and all other arguments of the run_classifier script<span class=\"o\">)</span>\n</pre>\n<p>Where <code>$THIS_MACHINE_INDEX</code> is an sequential index assigned to each of your machine (0, 1, 2...) and the machine with rank 0 has an IP address <code>192.168.1.1</code> and an open port <code>1234</code>.</p>\n<h3>Fine-tuning with BERT: running the examples</h3>\n<p>We showcase several fine-tuning examples based on (and extended from) <a href=\"https://github.com/google-research/bert/\" rel=\"nofollow\">the original implementation</a>:</p>\n<ul>\n<li>a <em>sequence-level classifier</em> on nine different GLUE tasks,</li>\n<li>a <em>token-level classifier</em> on the question answering dataset SQuAD, and</li>\n<li>a <em>sequence-level multiple-choice classifier</em> on the SWAG classification corpus.</li>\n<li>a <em>BERT language model</em> on another target corpus</li>\n</ul>\n<h4>GLUE results on dev set</h4>\n<p>We get the following results on the dev set of GLUE benchmark with an uncased BERT base\nmodel. All experiments were run on a P100 GPU with a batch size of 32.</p>\n<table>\n<thead>\n<tr>\n<th>Task</th>\n<th>Metric</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CoLA</td>\n<td>Matthew's corr.</td>\n<td>57.29</td>\n</tr>\n<tr>\n<td>SST-2</td>\n<td>accuracy</td>\n<td>93.00</td>\n</tr>\n<tr>\n<td>MRPC</td>\n<td>F1/accuracy</td>\n<td>88.85/83.82</td>\n</tr>\n<tr>\n<td>STS-B</td>\n<td>Pearson/Spearman corr.</td>\n<td>89.70/89.37</td>\n</tr>\n<tr>\n<td>QQP</td>\n<td>accuracy/F1</td>\n<td>90.72/87.41</td>\n</tr>\n<tr>\n<td>MNLI</td>\n<td>matched acc./mismatched acc.</td>\n<td>83.95/84.39</td>\n</tr>\n<tr>\n<td>QNLI</td>\n<td>accuracy</td>\n<td>89.04</td>\n</tr>\n<tr>\n<td>RTE</td>\n<td>accuracy</td>\n<td>61.01</td>\n</tr>\n<tr>\n<td>WNLI</td>\n<td>accuracy</td>\n<td>53.52</td>\n</tr></tbody></table>\n<p>Some of these results are significantly different from the ones reported on the test set\nof GLUE benchmark on the website. For QQP and WNLI, please refer to <a href=\"https://gluebenchmark.com/faq\" rel=\"nofollow\">FAQ #12</a> on the webite.</p>\n<p>Before running anyone of these GLUE tasks you should download the\n<a href=\"https://gluebenchmark.com/tasks\" rel=\"nofollow\">GLUE data</a> by running\n<a href=\"https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e\" rel=\"nofollow\">this script</a>\nand unpack it to some directory <code>$GLUE_DIR</code>.</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">GLUE_DIR</span><span class=\"o\">=</span>/path/to/glue\n<span class=\"nb\">export</span> <span class=\"nv\">TASK_NAME</span><span class=\"o\">=</span>MRPC\n\npython run_classifier.py <span class=\"se\">\\</span>\n  --task_name <span class=\"nv\">$TASK_NAME</span> <span class=\"se\">\\</span>\n  --do_train <span class=\"se\">\\</span>\n  --do_eval <span class=\"se\">\\</span>\n  --do_lower_case <span class=\"se\">\\</span>\n  --data_dir <span class=\"nv\">$GLUE_DIR</span>/<span class=\"nv\">$TASK_NAME</span> <span class=\"se\">\\</span>\n  --bert_model bert-base-uncased <span class=\"se\">\\</span>\n  --max_seq_length <span class=\"m\">128</span> <span class=\"se\">\\</span>\n  --train_batch_size <span class=\"m\">32</span> <span class=\"se\">\\</span>\n  --learning_rate 2e-5 <span class=\"se\">\\</span>\n  --num_train_epochs <span class=\"m\">3</span>.0 <span class=\"se\">\\</span>\n  --output_dir /tmp/<span class=\"nv\">$TASK_NAME</span>/\n</pre>\n<p>where task name can be one of CoLA, SST-2, MRPC, STS-B, QQP, MNLI, QNLI, RTE, WNLI.</p>\n<p>The dev set results will be present within the text file 'eval_results.txt' in the specified output_dir. In case of MNLI, since there are two separate dev sets, matched and mismatched, there will be a separate output folder called '/tmp/MNLI-MM/' in addition to '/tmp/MNLI/'.</p>\n<p>The code has not been tested with half-precision training with apex on any GLUE task apart from MRPC, MNLI, CoLA, SST-2. The following section provides details on how to run half-precision training with MRPC. With that being said, there shouldn't be any issues in running half-precision training with the remaining GLUE tasks as well, since the data processor for each task inherits from the base class DataProcessor.</p>\n<h4>MRPC</h4>\n<p>This example code fine-tunes BERT on the Microsoft Research Paraphrase\nCorpus (MRPC) corpus and runs in less than 10 minutes on a single K-80 and in 27 seconds (!) on single tesla V100 16GB with apex installed.</p>\n<p>Before running this example you should download the\n<a href=\"https://gluebenchmark.com/tasks\" rel=\"nofollow\">GLUE data</a> by running\n<a href=\"https://gist.github.com/W4ngatang/60c2bdb54d156a41194446737ce03e2e\" rel=\"nofollow\">this script</a>\nand unpack it to some directory <code>$GLUE_DIR</code>.</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">GLUE_DIR</span><span class=\"o\">=</span>/path/to/glue\n\npython run_classifier.py <span class=\"se\">\\</span>\n  --task_name MRPC <span class=\"se\">\\</span>\n  --do_train <span class=\"se\">\\</span>\n  --do_eval <span class=\"se\">\\</span>\n  --do_lower_case <span class=\"se\">\\</span>\n  --data_dir <span class=\"nv\">$GLUE_DIR</span>/MRPC/ <span class=\"se\">\\</span>\n  --bert_model bert-base-uncased <span class=\"se\">\\</span>\n  --max_seq_length <span class=\"m\">128</span> <span class=\"se\">\\</span>\n  --train_batch_size <span class=\"m\">32</span> <span class=\"se\">\\</span>\n  --learning_rate 2e-5 <span class=\"se\">\\</span>\n  --num_train_epochs <span class=\"m\">3</span>.0 <span class=\"se\">\\</span>\n  --output_dir /tmp/mrpc_output/\n</pre>\n<p>Our test ran on a few seeds with <a href=\"https://github.com/google-research/bert#sentence-and-sentence-pair-classification-tasks\" rel=\"nofollow\">the original implementation hyper-parameters</a> gave evaluation results between 84% and 88%.</p>\n<p><strong>Fast run with apex and 16 bit precision: fine-tuning on MRPC in 27 seconds!</strong>\nFirst install apex as indicated <a href=\"https://github.com/NVIDIA/apex\" rel=\"nofollow\">here</a>.\nThen run</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">GLUE_DIR</span><span class=\"o\">=</span>/path/to/glue\n\npython run_classifier.py <span class=\"se\">\\</span>\n  --task_name MRPC <span class=\"se\">\\</span>\n  --do_train <span class=\"se\">\\</span>\n  --do_eval <span class=\"se\">\\</span>\n  --do_lower_case <span class=\"se\">\\</span>\n  --data_dir <span class=\"nv\">$GLUE_DIR</span>/MRPC/ <span class=\"se\">\\</span>\n  --bert_model bert-base-uncased <span class=\"se\">\\</span>\n  --max_seq_length <span class=\"m\">128</span> <span class=\"se\">\\</span>\n  --train_batch_size <span class=\"m\">32</span> <span class=\"se\">\\</span>\n  --learning_rate 2e-5 <span class=\"se\">\\</span>\n  --num_train_epochs <span class=\"m\">3</span>.0 <span class=\"se\">\\</span>\n  --output_dir /tmp/mrpc_output/ <span class=\"se\">\\</span>\n  --fp16\n</pre>\n<h4>SQuAD</h4>\n<p>This example code fine-tunes BERT on the SQuAD dataset. It runs in 24 min (with BERT-base) or 68 min (with BERT-large) on a single tesla V100 16GB.</p>\n<p>The data for SQuAD can be downloaded with the following links and should be saved in a <code>$SQUAD_DIR</code> directory.</p>\n<ul>\n<li><a href=\"https://rajpurkar.github.io/SQuAD-explorer/dataset/train-v1.1.json\" rel=\"nofollow\">train-v1.1.json</a></li>\n<li><a href=\"https://rajpurkar.github.io/SQuAD-explorer/dataset/dev-v1.1.json\" rel=\"nofollow\">dev-v1.1.json</a></li>\n<li><a href=\"https://github.com/allenai/bi-att-flow/blob/master/squad/evaluate-v1.1.py\" rel=\"nofollow\">evaluate-v1.1.py</a></li>\n</ul>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">SQUAD_DIR</span><span class=\"o\">=</span>/path/to/SQUAD\n\npython run_squad.py <span class=\"se\">\\</span>\n  --bert_model bert-base-uncased <span class=\"se\">\\</span>\n  --do_train <span class=\"se\">\\</span>\n  --do_predict <span class=\"se\">\\</span>\n  --do_lower_case <span class=\"se\">\\</span>\n  --train_file <span class=\"nv\">$SQUAD_DIR</span>/train-v1.1.json <span class=\"se\">\\</span>\n  --predict_file <span class=\"nv\">$SQUAD_DIR</span>/dev-v1.1.json <span class=\"se\">\\</span>\n  --train_batch_size <span class=\"m\">12</span> <span class=\"se\">\\</span>\n  --learning_rate 3e-5 <span class=\"se\">\\</span>\n  --num_train_epochs <span class=\"m\">2</span>.0 <span class=\"se\">\\</span>\n  --max_seq_length <span class=\"m\">384</span> <span class=\"se\">\\</span>\n  --doc_stride <span class=\"m\">128</span> <span class=\"se\">\\</span>\n  --output_dir /tmp/debug_squad/\n</pre>\n<p>Training with the previous hyper-parameters gave us the following results:</p>\n<pre><span class=\"o\">{</span><span class=\"s2\">\"f1\"</span>: <span class=\"m\">88</span>.52381567990474, <span class=\"s2\">\"exact_match\"</span>: <span class=\"m\">81</span>.22043519394512<span class=\"o\">}</span>\n</pre>\n<h4>SWAG</h4>\n<p>The data for SWAG can be downloaded by cloning the following <a href=\"https://github.com/rowanz/swagaf\" rel=\"nofollow\">repository</a></p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">SWAG_DIR</span><span class=\"o\">=</span>/path/to/SWAG\n\npython run_swag.py <span class=\"se\">\\</span>\n  --bert_model bert-base-uncased <span class=\"se\">\\</span>\n  --do_train <span class=\"se\">\\</span>\n  --do_lower_case <span class=\"se\">\\</span>\n  --do_eval <span class=\"se\">\\</span>\n  --data_dir <span class=\"nv\">$SWAG_DIR</span>/data <span class=\"se\">\\</span>\n  --train_batch_size <span class=\"m\">16</span> <span class=\"se\">\\</span>\n  --learning_rate 2e-5 <span class=\"se\">\\</span>\n  --num_train_epochs <span class=\"m\">3</span>.0 <span class=\"se\">\\</span>\n  --max_seq_length <span class=\"m\">80</span> <span class=\"se\">\\</span>\n  --output_dir /tmp/swag_output/ <span class=\"se\">\\</span>\n  --gradient_accumulation_steps <span class=\"m\">4</span>\n</pre>\n<p>Training with the previous hyper-parameters on a single GPU gave us the following results:</p>\n<pre><code>eval_accuracy = 0.8062081375587323\neval_loss = 0.5966546792367169\nglobal_step = 13788\nloss = 0.06423990014260186\n</code></pre>\n<h4>LM Fine-tuning</h4>\n<p>The data should be a text file in the same format as <a href=\"./samples/sample_text.txt\" rel=\"nofollow\">sample_text.txt</a>  (one sentence per line, docs separated by empty line).\nYou can download an <a href=\"https://ext-bert-sample.obs.eu-de.otc.t-systems.com/small_wiki_sentence_corpus.txt\" rel=\"nofollow\">exemplary training corpus</a> generated from wikipedia articles and splitted into ~500k sentences with spaCy.\nTraining one epoch on this corpus takes about 1:20h on 4 x NVIDIA Tesla P100 with <code>train_batch_size=200</code> and <code>max_seq_length=128</code>:</p>\n<p>Thank to the work of @Rocketknight1 and @tholor there are now <strong>several scripts</strong> that can be used to fine-tune BERT using the pretraining objective (combination of masked-language modeling and next sentence prediction loss). These scripts are detailed in the <a href=\"./examples/lm_finetuning/README.md\" rel=\"nofollow\"><code>README</code></a> of the <a href=\"./examples/lm_finetuning/\" rel=\"nofollow\"><code>examples/lm_finetuning/</code></a> folder.</p>\n<h3>OpenAI GPT, Transformer-XL and GPT-2: running the examples</h3>\n<p>We provide three examples of scripts for OpenAI GPT, Transformer-XL and OpenAI GPT-2 based on (and extended from) the respective original implementations:</p>\n<ul>\n<li>fine-tuning OpenAI GPT on the ROCStories dataset</li>\n<li>evaluating Transformer-XL on Wikitext 103</li>\n<li>unconditional and conditional generation from a pre-trained OpenAI GPT-2 model</li>\n</ul>\n<h4>Fine-tuning OpenAI GPT on the RocStories dataset</h4>\n<p>This example code fine-tunes OpenAI GPT on the RocStories dataset.</p>\n<p>Before running this example you should download the\n<a href=\"https://github.com/snigdhac/StoryComprehension_EMNLP/tree/master/Dataset/RoCStories\" rel=\"nofollow\">RocStories dataset</a> and unpack it to some directory <code>$ROC_STORIES_DIR</code>.</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">ROC_STORIES_DIR</span><span class=\"o\">=</span>/path/to/RocStories\n\npython run_openai_gpt.py <span class=\"se\">\\</span>\n  --model_name openai-gpt <span class=\"se\">\\</span>\n  --do_train <span class=\"se\">\\</span>\n  --do_eval <span class=\"se\">\\</span>\n  --train_dataset <span class=\"nv\">$ROC_STORIES_DIR</span>/cloze_test_val__spring2016<span class=\"se\">\\ </span>-<span class=\"se\">\\ </span>cloze_test_ALL_val.csv <span class=\"se\">\\</span>\n  --eval_dataset <span class=\"nv\">$ROC_STORIES_DIR</span>/cloze_test_test__spring2016<span class=\"se\">\\ </span>-<span class=\"se\">\\ </span>cloze_test_ALL_test.csv <span class=\"se\">\\</span>\n  --output_dir ../log <span class=\"se\">\\</span>\n  --train_batch_size <span class=\"m\">16</span> <span class=\"se\">\\</span>\n</pre>\n<p>This command runs in about 10 min on a single K-80 an gives an evaluation accuracy of about 87.7% (the authors report a median accuracy with the TensorFlow code of 85.8% and the OpenAI GPT paper reports a best single run accuracy of 86.5%).</p>\n<h4>Evaluating the pre-trained Transformer-XL on the WikiText 103 dataset</h4>\n<p>This example code evaluate the pre-trained Transformer-XL on the WikiText 103 dataset.\nThis command will download a pre-processed version of the WikiText 103 dataset in which the vocabulary has been computed.</p>\n<pre>python run_transfo_xl.py --work_dir ../log\n</pre>\n<p>This command runs in about 1 min on a V100 and gives an evaluation perplexity of 18.22 on WikiText-103 (the authors report a perplexity of about 18.3 on this dataset with the TensorFlow code).</p>\n<h4>Unconditional and conditional generation from OpenAI's GPT-2 model</h4>\n<p>This example code is identical to the original unconditional and conditional generation codes.</p>\n<p>Conditional generation:</p>\n<pre>python run_gpt2.py\n</pre>\n<p>Unconditional generation:</p>\n<pre>python run_gpt2.py --unconditional\n</pre>\n<p>The same option as in the original scripts are provided, please refere to the code of the example and the original repository of OpenAI.</p>\n<h2>Fine-tuning BERT-large on GPUs</h2>\n<p>The options we list above allow to fine-tune BERT-large rather easily on GPU(s) instead of the TPU used by the original implementation.</p>\n<p>For example, fine-tuning BERT-large on SQuAD can be done on a server with 4 k-80 (these are pretty old now) in 18 hours. Our results are similar to the TensorFlow implementation results (actually slightly higher):</p>\n<pre><span class=\"o\">{</span><span class=\"s2\">\"exact_match\"</span>: <span class=\"m\">84</span>.56953642384106, <span class=\"s2\">\"f1\"</span>: <span class=\"m\">91</span>.04028647786927<span class=\"o\">}</span>\n</pre>\n<p>To get these results we used a combination of:</p>\n<ul>\n<li>multi-GPU training (automatically activated on a multi-GPU server),</li>\n<li>2 steps of gradient accumulation and</li>\n<li>perform the optimization step on CPU to store Adam's averages in RAM.</li>\n</ul>\n<p>Here is the full list of hyper-parameters for this run:</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">SQUAD_DIR</span><span class=\"o\">=</span>/path/to/SQUAD\n\npython ./run_squad.py <span class=\"se\">\\</span>\n  --bert_model bert-large-uncased <span class=\"se\">\\</span>\n  --do_train <span class=\"se\">\\</span>\n  --do_predict <span class=\"se\">\\</span>\n  --do_lower_case <span class=\"se\">\\</span>\n  --train_file <span class=\"nv\">$SQUAD_DIR</span>/train-v1.1.json <span class=\"se\">\\</span>\n  --predict_file <span class=\"nv\">$SQUAD_DIR</span>/dev-v1.1.json <span class=\"se\">\\</span>\n  --learning_rate 3e-5 <span class=\"se\">\\</span>\n  --num_train_epochs <span class=\"m\">2</span> <span class=\"se\">\\</span>\n  --max_seq_length <span class=\"m\">384</span> <span class=\"se\">\\</span>\n  --doc_stride <span class=\"m\">128</span> <span class=\"se\">\\</span>\n  --output_dir /tmp/debug_squad/ <span class=\"se\">\\</span>\n  --train_batch_size <span class=\"m\">24</span> <span class=\"se\">\\</span>\n  --gradient_accumulation_steps <span class=\"m\">2</span>\n</pre>\n<p>If you have a recent GPU (starting from NVIDIA Volta series), you should try <strong>16-bit fine-tuning</strong> (FP16).</p>\n<p>Here is an example of hyper-parameters for a FP16 run we tried:</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">SQUAD_DIR</span><span class=\"o\">=</span>/path/to/SQUAD\n\npython ./run_squad.py <span class=\"se\">\\</span>\n  --bert_model bert-large-uncased <span class=\"se\">\\</span>\n  --do_train <span class=\"se\">\\</span>\n  --do_predict <span class=\"se\">\\</span>\n  --do_lower_case <span class=\"se\">\\</span>\n  --train_file <span class=\"nv\">$SQUAD_DIR</span>/train-v1.1.json <span class=\"se\">\\</span>\n  --predict_file <span class=\"nv\">$SQUAD_DIR</span>/dev-v1.1.json <span class=\"se\">\\</span>\n  --learning_rate 3e-5 <span class=\"se\">\\</span>\n  --num_train_epochs <span class=\"m\">2</span> <span class=\"se\">\\</span>\n  --max_seq_length <span class=\"m\">384</span> <span class=\"se\">\\</span>\n  --doc_stride <span class=\"m\">128</span> <span class=\"se\">\\</span>\n  --output_dir /tmp/debug_squad/ <span class=\"se\">\\</span>\n  --train_batch_size <span class=\"m\">24</span> <span class=\"se\">\\</span>\n  --fp16 <span class=\"se\">\\</span>\n  --loss_scale <span class=\"m\">128</span>\n</pre>\n<p>The results were similar to the above FP32 results (actually slightly higher):</p>\n<pre><span class=\"o\">{</span><span class=\"s2\">\"exact_match\"</span>: <span class=\"m\">84</span>.65468306527909, <span class=\"s2\">\"f1\"</span>: <span class=\"m\">91</span>.238669287002<span class=\"o\">}</span>\n</pre>\n<h2>Notebooks</h2>\n<p>We include <a href=\"https://github.com/huggingface/pytorch-pretrained-BERT/tree/master/notebooks\" rel=\"nofollow\">three Jupyter Notebooks</a> that can be used to check that the predictions of the PyTorch model are identical to the predictions of the original TensorFlow model.</p>\n<ul>\n<li>\n<p>The first NoteBook (<a href=\"./notebooks/Comparing-TF-and-PT-models.ipynb\" rel=\"nofollow\">Comparing-TF-and-PT-models.ipynb</a>) extracts the hidden states of a full sequence on each layers of the TensorFlow and the PyTorch models and computes the standard deviation between them. In the given example, we get a standard deviation of 1.5e-7 to 9e-7 on the various hidden state of the models.</p>\n</li>\n<li>\n<p>The second NoteBook (<a href=\"./notebooks/Comparing-TF-and-PT-models-SQuAD.ipynb\" rel=\"nofollow\">Comparing-TF-and-PT-models-SQuAD.ipynb</a>) compares the loss computed by the TensorFlow and the PyTorch models for identical initialization of the fine-tuning layer of the <code>BertForQuestionAnswering</code> and computes the standard deviation between them. In the given example, we get a standard deviation of 2.5e-7 between the models.</p>\n</li>\n<li>\n<p>The third NoteBook (<a href=\"./notebooks/Comparing-TF-and-PT-models-MLM-NSP.ipynb\" rel=\"nofollow\">Comparing-TF-and-PT-models-MLM-NSP.ipynb</a>) compares the predictions computed by the TensorFlow and the PyTorch models for masked token language modeling using the pre-trained masked language modeling model.</p>\n</li>\n</ul>\n<p>Please follow the instructions given in the notebooks to run and modify them.</p>\n<h2>Command-line interface</h2>\n<p>A command-line interface is provided to convert a TensorFlow checkpoint in a PyTorch dump of the <code>BertForPreTraining</code> class  (for BERT) or NumPy checkpoint in a PyTorch dump of the <code>OpenAIGPTModel</code> class  (for OpenAI GPT).</p>\n<h3>BERT</h3>\n<p>You can convert any TensorFlow checkpoint for BERT (in particular <a href=\"https://github.com/google-research/bert#pre-trained-models\" rel=\"nofollow\">the pre-trained models released by Google</a>) in a PyTorch save file by using the <a href=\"./pytorch_pretrained_bert/convert_tf_checkpoint_to_pytorch.py\" rel=\"nofollow\"><code>convert_tf_checkpoint_to_pytorch.py</code></a> script.</p>\n<p>This CLI takes as input a TensorFlow checkpoint (three files starting with <code>bert_model.ckpt</code>) and the associated configuration file (<code>bert_config.json</code>), and creates a PyTorch model for this configuration, loads the weights from the TensorFlow checkpoint in the PyTorch model and saves the resulting model in a standard PyTorch save file that can be imported using <code>torch.load()</code> (see examples in <a href=\"./examples/extract_features.py\" rel=\"nofollow\"><code>extract_features.py</code></a>, <a href=\"./examples/run_classifier.py\" rel=\"nofollow\"><code>run_classifier.py</code></a> and <a href=\"./examples/run_squad.py\" rel=\"nofollow\"><code>run_squad.py</code></a>).</p>\n<p>You only need to run this conversion script <strong>once</strong> to get a PyTorch model. You can then disregard the TensorFlow checkpoint (the three files starting with <code>bert_model.ckpt</code>) but be sure to keep the configuration file (<code>bert_config.json</code>) and the vocabulary file (<code>vocab.txt</code>) as these are needed for the PyTorch model too.</p>\n<p>To run this specific conversion script you will need to have TensorFlow and PyTorch installed (<code>pip install tensorflow</code>). The rest of the repository only requires PyTorch.</p>\n<p>Here is an example of the conversion process for a pre-trained <code>BERT-Base Uncased</code> model:</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">BERT_BASE_DIR</span><span class=\"o\">=</span>/path/to/bert/uncased_L-12_H-768_A-12\n\npytorch_pretrained_bert convert_tf_checkpoint_to_pytorch <span class=\"se\">\\</span>\n  <span class=\"nv\">$BERT_BASE_DIR</span>/bert_model.ckpt <span class=\"se\">\\</span>\n  <span class=\"nv\">$BERT_BASE_DIR</span>/bert_config.json <span class=\"se\">\\</span>\n  <span class=\"nv\">$BERT_BASE_DIR</span>/pytorch_model.bin\n</pre>\n<p>You can download Google's pre-trained models for the conversion <a href=\"https://github.com/google-research/bert#pre-trained-models\" rel=\"nofollow\">here</a>.</p>\n<h3>OpenAI GPT</h3>\n<p>Here is an example of the conversion process for a pre-trained OpenAI GPT model, assuming that your NumPy checkpoint save as the same format than OpenAI pretrained model (see <a href=\"https://github.com/openai/finetune-transformer-lm\" rel=\"nofollow\">here</a>)</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">OPENAI_GPT_CHECKPOINT_FOLDER_PATH</span><span class=\"o\">=</span>/path/to/openai/pretrained/numpy/weights\n\npytorch_pretrained_bert convert_openai_checkpoint <span class=\"se\">\\</span>\n  <span class=\"nv\">$OPENAI_GPT_CHECKPOINT_FOLDER_PATH</span> <span class=\"se\">\\</span>\n  <span class=\"nv\">$PYTORCH_DUMP_OUTPUT</span> <span class=\"se\">\\</span>\n  <span class=\"o\">[</span>OPENAI_GPT_CONFIG<span class=\"o\">]</span>\n</pre>\n<h3>Transformer-XL</h3>\n<p>Here is an example of the conversion process for a pre-trained Transformer-XL model (see <a href=\"https://github.com/kimiyoung/transformer-xl/tree/master/tf#obtain-and-evaluate-pretrained-sota-models\" rel=\"nofollow\">here</a>)</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">TRANSFO_XL_CHECKPOINT_FOLDER_PATH</span><span class=\"o\">=</span>/path/to/transfo/xl/checkpoint\n\npytorch_pretrained_bert convert_transfo_xl_checkpoint <span class=\"se\">\\</span>\n  <span class=\"nv\">$TRANSFO_XL_CHECKPOINT_FOLDER_PATH</span> <span class=\"se\">\\</span>\n  <span class=\"nv\">$PYTORCH_DUMP_OUTPUT</span> <span class=\"se\">\\</span>\n  <span class=\"o\">[</span>TRANSFO_XL_CONFIG<span class=\"o\">]</span>\n</pre>\n<h3>GPT-2</h3>\n<p>Here is an example of the conversion process for a pre-trained OpenAI's GPT-2 model.</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">GPT2_DIR</span><span class=\"o\">=</span>/path/to/gpt2/checkpoint\n\npytorch_pretrained_bert convert_gpt2_checkpoint <span class=\"se\">\\</span>\n  <span class=\"nv\">$GPT2_DIR</span>/model.ckpt <span class=\"se\">\\</span>\n  <span class=\"nv\">$PYTORCH_DUMP_OUTPUT</span> <span class=\"se\">\\</span>\n  <span class=\"o\">[</span>GPT2_CONFIG<span class=\"o\">]</span>\n</pre>\n<h2>TPU</h2>\n<p>TPU support and pretraining scripts</p>\n<p>TPU are not supported by the current stable release of PyTorch (0.4.1). However, the next version of PyTorch (v1.0) should support training on TPU and is expected to be released soon (see the recent <a href=\"https://cloud.google.com/blog/products/ai-machine-learning/introducing-pytorch-across-google-cloud\" rel=\"nofollow\">official announcement</a>).</p>\n<p>We will add TPU support when this next release is published.</p>\n<p>The original TensorFlow code further comprises two scripts for pre-training BERT: <a href=\"https://github.com/google-research/bert/blob/master/create_pretraining_data.py\" rel=\"nofollow\">create_pretraining_data.py</a> and <a href=\"https://github.com/google-research/bert/blob/master/run_pretraining.py\" rel=\"nofollow\">run_pretraining.py</a>.</p>\n<p>Since, pre-training BERT is a particularly expensive operation that basically requires one or several TPUs to be completed in a reasonable amout of time (see details <a href=\"https://github.com/google-research/bert#pre-training-with-bert\" rel=\"nofollow\">here</a>) we have decided to wait for the inclusion of TPU support in PyTorch to convert these pre-training scripts.</p>\n\n          </div>"}, "last_serial": 5189532, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "6d6af21566a328439d53694be6600b56", "sha256": "b6580020797366d64c9d65a67ecee7bdc708a8d16a7d3da1007cb40ef85d544b"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "6d6af21566a328439d53694be6600b56", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5.0", "size": 36495, "upload_time": "2018-11-17T09:58:09", "upload_time_iso_8601": "2018-11-17T09:58:09.810922Z", "url": "https://files.pythonhosted.org/packages/72/c0/6066e63eef1035dd7728f864f012da34f63637c61786f2dff5d7da1cacb6/pytorch_pretrained_bert-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8cf8e4b7e3c1b3d2bf5c8243c2c834ee", "sha256": "1d67d3e7864e6987d3582b2bc295170b8ac21c69ed298c068ba70efac0769281"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.1.1.tar.gz", "has_sig": false, "md5_digest": "8cf8e4b7e3c1b3d2bf5c8243c2c834ee", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5.0", "size": 46345, "upload_time": "2018-11-17T09:58:12", "upload_time_iso_8601": "2018-11-17T09:58:12.884739Z", "url": "https://files.pythonhosted.org/packages/87/23/89602d8312a6aed79bb9a33f9e5b0eadef3fb02875f375a9c56a224a9faf/pytorch_pretrained_bert-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "b1c00ebc17dece1330420eb7f4aeaca1", "sha256": "02ad709ec67d25d31c56e72e42815e67c45020fc40668c528b6aac0d9592721f"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "b1c00ebc17dece1330420eb7f4aeaca1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5.0", "size": 36478, "upload_time": "2018-11-17T11:09:29", "upload_time_iso_8601": "2018-11-17T11:09:29.047221Z", "url": "https://files.pythonhosted.org/packages/a2/29/2c903c09caab880c26a07c2c2054160354f6531f1ed3f1c31a56956189fd/pytorch_pretrained_bert-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dd9d9c51e87d0b8fdbf1cde1f5f69e7c", "sha256": "c7aec2fc5901a0a7b305ce1572f85cadb606ff33b7c80988de682db4bcbe4c22"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.1.2.tar.gz", "has_sig": false, "md5_digest": "dd9d9c51e87d0b8fdbf1cde1f5f69e7c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5.0", "size": 46295, "upload_time": "2018-11-17T11:09:31", "upload_time_iso_8601": "2018-11-17T11:09:31.678714Z", "url": "https://files.pythonhosted.org/packages/81/6e/b1e6f78f0d010bb3738f7f8cfcd5e472fd7c3b130a1a9a8f5507d1cdb528/pytorch_pretrained_bert-0.1.2.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "bc07789db60881fe47f610681cfcbfdd", "sha256": "8d5725e47fb833a4f38bb3b987d5f1a3dcd27d42530d08dcba0404b7edbe2a6d"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "bc07789db60881fe47f610681cfcbfdd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5.0", "size": 36715, "upload_time": "2018-11-26T09:54:15", "upload_time_iso_8601": "2018-11-26T09:54:15.543316Z", "url": "https://files.pythonhosted.org/packages/24/47/057e7998e5ac9c9a1b1f1c5a65895accec23ed414ae264af7db4fe2d5b2f/pytorch_pretrained_bert-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "daf02056cd25e50f97ca7372f31ca402", "sha256": "3e979d77cf592b4ca65e4a911914b681245e08aad1f4ada22d58bb4c97de75b9"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.2.0.tar.gz", "has_sig": false, "md5_digest": "daf02056cd25e50f97ca7372f31ca402", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5.0", "size": 46880, "upload_time": "2018-11-26T09:54:18", "upload_time_iso_8601": "2018-11-26T09:54:18.222662Z", "url": "https://files.pythonhosted.org/packages/db/32/1047ce37e9ecc1b7a6bd7af85a68eeade5cda90d9d7e01b4122188d716e3/pytorch_pretrained_bert-0.2.0.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "15c798ba65414e08bf0b66017c0bc67f", "sha256": "a8547402519be9c0b2fc22cd3bb8b3b1ddda1189364940d11f6e7d8883c93f82"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "15c798ba65414e08bf0b66017c0bc67f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5.0", "size": 37123, "upload_time": "2018-11-30T22:17:32", "upload_time_iso_8601": "2018-11-30T22:17:32.550327Z", "url": "https://files.pythonhosted.org/packages/26/85/de4dd7e018a197280752881adf7b4142886f20155145f641f7c803c0018a/pytorch_pretrained_bert-0.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "26711c69aaa823f2dcef3beeefd6c06c", "sha256": "d91e20963eca71251178c8e9e8c49af90b3bc8d81faae64f3b4aa9674b740134"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.3.0.tar.gz", "has_sig": false, "md5_digest": "26711c69aaa823f2dcef3beeefd6c06c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5.0", "size": 48155, "upload_time": "2018-11-30T22:17:34", "upload_time_iso_8601": "2018-11-30T22:17:34.026140Z", "url": "https://files.pythonhosted.org/packages/00/e3/d8d44457ed41dbe975694c893279f24901c20456f4c32e30da34c22314f6/pytorch_pretrained_bert-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "6870fdcefc98c8af2f31e1ac0e3656f8", "sha256": "cc66a6de585b5a43d4cff0fc6c0426dc3d35214d270cf207a33d7ceace8930fa"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "6870fdcefc98c8af2f31e1ac0e3656f8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5.0", "size": 45171, "upload_time": "2018-12-14T14:22:57", "upload_time_iso_8601": "2018-12-14T14:22:57.314201Z", "url": "https://files.pythonhosted.org/packages/95/68/84de54aea460eb5b2e90bf47a429aacc1ce97ff052ec40874ea38ae2331d/pytorch_pretrained_bert-0.4.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6a7a7442292df378bff23632c6666ea0", "sha256": "a1bbcf9d2ef5f894b583737bd0bcbd7f4cbffddc4722b255aaf8b93fd43892d3"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.4.0.tar.gz", "has_sig": false, "md5_digest": "6a7a7442292df378bff23632c6666ea0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5.0", "size": 50647, "upload_time": "2018-12-14T14:22:59", "upload_time_iso_8601": "2018-12-14T14:22:59.611555Z", "url": "https://files.pythonhosted.org/packages/20/87/2d6e73ec1522483de5188a3451572c725912b79f84a4b8e7fe748be97c6c/pytorch_pretrained_bert-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "dce72d74844799aba54755da2015fe26", "sha256": "303d8f7cf5d645dc2ba17aec031f213aba2ecf48f5fa11d5466d3da779d5e8de"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.5.0-py2-none-any.whl", "has_sig": false, "md5_digest": "dce72d74844799aba54755da2015fe26", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 85637, "upload_time": "2019-02-11T13:25:01", "upload_time_iso_8601": "2019-02-11T13:25:01.836722Z", "url": "https://files.pythonhosted.org/packages/b8/c5/4d769fefdd139500bf9ad30bd5a3f9901246ac70821f00209691b9100ad0/pytorch_pretrained_bert-0.5.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7de7a53305381c35aadcab080569abc2", "sha256": "c20fe5b9051ad44dca429d437fbaebf9e91932ab65e0eb87581149ccee23b5eb"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.5.0-py3.6.egg", "has_sig": false, "md5_digest": "7de7a53305381c35aadcab080569abc2", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": null, "size": 148555, "upload_time": "2019-02-11T13:25:08", "upload_time_iso_8601": "2019-02-11T13:25:08.700995Z", "url": "https://files.pythonhosted.org/packages/2e/ba/b948261e8a3dec5084c0d970cd479b57633bdbcdd256b6c6b883245abbfa/pytorch_pretrained_bert-0.5.0-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "ce150311019fc4f6e20ba4f6a592227d", "sha256": "662c96d1085a13628d2915eb3d0af442c0e2961c02131e1077f551251e80ea95"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "ce150311019fc4f6e20ba4f6a592227d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 97833, "upload_time": "2019-02-11T13:25:05", "upload_time_iso_8601": "2019-02-11T13:25:05.124725Z", "url": "https://files.pythonhosted.org/packages/3e/f6/bd094fb2cf6a3232fcb79bc4067e5322218ecc26170b4db94976fa805e30/pytorch_pretrained_bert-0.5.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "cb42b54c2f444f5e03d609e1a00b71b5", "sha256": "5a7befbe452d1ad9fcb24a1f1778e2d39844f15684d61abcc911c36efa502e16"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.5.0.tar.gz", "has_sig": false, "md5_digest": "cb42b54c2f444f5e03d609e1a00b71b5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 102459, "upload_time": "2019-02-11T13:25:10", "upload_time_iso_8601": "2019-02-11T13:25:10.995997Z", "url": "https://files.pythonhosted.org/packages/e2/89/c5b051293370399246a439dc8cf63ce55d62173b60b275cd254f285b61e9/pytorch_pretrained_bert-0.5.0.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "71e28cdbf4a706aeb508a995dd2621e4", "sha256": "d5892b714ce486df932c2d50bd74edb06300fdbf8da01bab8bd70172ad6b37f3"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.5.1-py2-none-any.whl", "has_sig": false, "md5_digest": "71e28cdbf4a706aeb508a995dd2621e4", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 86382, "upload_time": "2019-02-13T09:24:44", "upload_time_iso_8601": "2019-02-13T09:24:44.392367Z", "url": "https://files.pythonhosted.org/packages/99/dc/4e7256c85086f373cd935786484898550a394d3d91e71ca711154df8e702/pytorch_pretrained_bert-0.5.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "10f934c13590020cd5f84f63112626ef", "sha256": "89331120c15fd73c709cfe9309bcfc403855484fa75c7bed27d930d7e2541000"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.5.1-py3-none-any.whl", "has_sig": false, "md5_digest": "10f934c13590020cd5f84f63112626ef", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 86383, "upload_time": "2019-02-13T09:24:46", "upload_time_iso_8601": "2019-02-13T09:24:46.841730Z", "url": "https://files.pythonhosted.org/packages/78/1a/1d94d7725825d6c6796da00b9ad5c875eab69c15bc8ffd0d1588b83600bc/pytorch_pretrained_bert-0.5.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "52359ce7f130c24b0fdd7222b42e7d2c", "sha256": "202b0acfe985a6df477fc6b9e321b96c90732a5b941791a39541ea653e295052"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.5.1.tar.gz", "has_sig": false, "md5_digest": "52359ce7f130c24b0fdd7222b42e7d2c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 103754, "upload_time": "2019-02-13T09:24:53", "upload_time_iso_8601": "2019-02-13T09:24:53.032705Z", "url": "https://files.pythonhosted.org/packages/71/3f/cde20f22cc6551c1da5fb48f9fb543551f86ff181f32824ca9c8eb253144/pytorch_pretrained_bert-0.5.1.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "eb1a380708d4b2d8e4aad7bbed66c31b", "sha256": "d673efa78abde78cbf41caff3d7cb76ef6639721e27d620497d626f129391fb3"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.0-py2-none-any.whl", "has_sig": false, "md5_digest": "eb1a380708d4b2d8e4aad7bbed66c31b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 100198, "upload_time": "2019-02-18T10:39:20", "upload_time_iso_8601": "2019-02-18T10:39:20.814005Z", "url": "https://files.pythonhosted.org/packages/ab/28/6cd504b7b7d2bdd0d943e96c9b6a9c1b467c41eb30add5cb178c9e4a0b7b/pytorch_pretrained_bert-0.6.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "296849db41aa0ab89819c816f425698a", "sha256": "7d56ed3245571556cf3915dc1c2122e5c2928ff2a18bb7fd3c8e18b823cbbf6c"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.0-py3-none-any.whl", "has_sig": false, "md5_digest": "296849db41aa0ab89819c816f425698a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 114273, "upload_time": "2019-02-18T10:39:25", "upload_time_iso_8601": "2019-02-18T10:39:25.685172Z", "url": "https://files.pythonhosted.org/packages/a3/ac/8d72155697620bb9b453dcde3ad8520dc1464fa3abde389afbd542c50402/pytorch_pretrained_bert-0.6.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "89c45496d07d4dd031d668e1a512a490", "sha256": "92782a0f6b17b376cd792b29f5a9a91433aace31190391ff20c244ccfa625790"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.0.tar.gz", "has_sig": false, "md5_digest": "89c45496d07d4dd031d668e1a512a490", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 114959, "upload_time": "2019-02-18T10:39:30", "upload_time_iso_8601": "2019-02-18T10:39:30.363862Z", "url": "https://files.pythonhosted.org/packages/60/5b/3db9a41fe5bf837857f9ae2a653d2078396dff2c1cc6b02105f5244ef9c5/pytorch_pretrained_bert-0.6.0.tar.gz", "yanked": false}], "0.6.1": [{"comment_text": "", "digests": {"md5": "d22b92610d7410e9ddbfe68da52b3b6f", "sha256": "9ec5998f501381d86d6e0b4c4d92c1c2888f3f093e3a13177b3b94494b1bf7d7"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.1-py2-none-any.whl", "has_sig": false, "md5_digest": "d22b92610d7410e9ddbfe68da52b3b6f", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 100205, "upload_time": "2019-02-18T11:03:40", "upload_time_iso_8601": "2019-02-18T11:03:40.549570Z", "url": "https://files.pythonhosted.org/packages/d6/07/4cb27bb1a7a46bd3f165fec089acbac42b4f47111be242f62a0470c7d622/pytorch_pretrained_bert-0.6.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "07a39342dc0a3b15bf9cc5bb9fb3fb79", "sha256": "138c9702cc8da0c949a3b266a0c6e436aee4ae1c722b5d3eb1e47fb4b2b0f197"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.1-py3-none-any.whl", "has_sig": false, "md5_digest": "07a39342dc0a3b15bf9cc5bb9fb3fb79", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 114282, "upload_time": "2019-02-18T11:03:42", "upload_time_iso_8601": "2019-02-18T11:03:42.224629Z", "url": "https://files.pythonhosted.org/packages/5d/3c/d5fa084dd3a82ffc645aba78c417e6072ff48552e3301b1fa3bd711e03d4/pytorch_pretrained_bert-0.6.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d65e32a24d0ef24741657382ce71ffa4", "sha256": "f30ae5d19a95b64bd7068170640608cc457488948aa7643855aa261c2c8ab8b7"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.1.tar.gz", "has_sig": false, "md5_digest": "d65e32a24d0ef24741657382ce71ffa4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 114960, "upload_time": "2019-02-18T11:03:43", "upload_time_iso_8601": "2019-02-18T11:03:43.918963Z", "url": "https://files.pythonhosted.org/packages/ca/4d/bfa70159c912c5ec7f9a8441d102de1986009f5b577a3e4ffeffc3b74e56/pytorch_pretrained_bert-0.6.1.tar.gz", "yanked": false}], "0.6.2": [{"comment_text": "", "digests": {"md5": "d269070eba8d4d045a3a70335400fc84", "sha256": "edf4f9c2e64ef4e3cc68a335c88938fa45c17f18300952c64ba59fa66580f2f4"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.2-py2-none-any.whl", "has_sig": false, "md5_digest": "d269070eba8d4d045a3a70335400fc84", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 106890, "upload_time": "2019-04-25T19:41:59", "upload_time_iso_8601": "2019-04-25T19:41:59.731295Z", "url": "https://files.pythonhosted.org/packages/4c/a7/278bbec96c9a735049ebf5786fcbeebc8c46ab11cd4472fef77cf2db9fa1/pytorch_pretrained_bert-0.6.2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ec8ca544963299bd33fa65c7f409a233", "sha256": "ddd86f2f4ca595a2ad05d48c35d4f5c1c5f150bef79d56e3159701840a574d06"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.2-py3-none-any.whl", "has_sig": false, "md5_digest": "ec8ca544963299bd33fa65c7f409a233", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 123793, "upload_time": "2019-04-25T19:42:02", "upload_time_iso_8601": "2019-04-25T19:42:02.054902Z", "url": "https://files.pythonhosted.org/packages/d7/e0/c08d5553b89973d9a240605b9c12404bcf8227590de62bae27acbcfe076b/pytorch_pretrained_bert-0.6.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6ead9886eb52235509d54a5ae2820d79", "sha256": "9cf7c6221e854071b9844f2a9a581e05a24777351618c010493d9c76601c6747"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.2.tar.gz", "has_sig": false, "md5_digest": "6ead9886eb52235509d54a5ae2820d79", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 127408, "upload_time": "2019-04-25T19:42:04", "upload_time_iso_8601": "2019-04-25T19:42:04.571350Z", "url": "https://files.pythonhosted.org/packages/62/99/32f994e64c1f3c23f73ccff01ae7324ecd82ac2e5f16657940cb72832a06/pytorch_pretrained_bert-0.6.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d269070eba8d4d045a3a70335400fc84", "sha256": "edf4f9c2e64ef4e3cc68a335c88938fa45c17f18300952c64ba59fa66580f2f4"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.2-py2-none-any.whl", "has_sig": false, "md5_digest": "d269070eba8d4d045a3a70335400fc84", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 106890, "upload_time": "2019-04-25T19:41:59", "upload_time_iso_8601": "2019-04-25T19:41:59.731295Z", "url": "https://files.pythonhosted.org/packages/4c/a7/278bbec96c9a735049ebf5786fcbeebc8c46ab11cd4472fef77cf2db9fa1/pytorch_pretrained_bert-0.6.2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ec8ca544963299bd33fa65c7f409a233", "sha256": "ddd86f2f4ca595a2ad05d48c35d4f5c1c5f150bef79d56e3159701840a574d06"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.2-py3-none-any.whl", "has_sig": false, "md5_digest": "ec8ca544963299bd33fa65c7f409a233", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 123793, "upload_time": "2019-04-25T19:42:02", "upload_time_iso_8601": "2019-04-25T19:42:02.054902Z", "url": "https://files.pythonhosted.org/packages/d7/e0/c08d5553b89973d9a240605b9c12404bcf8227590de62bae27acbcfe076b/pytorch_pretrained_bert-0.6.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6ead9886eb52235509d54a5ae2820d79", "sha256": "9cf7c6221e854071b9844f2a9a581e05a24777351618c010493d9c76601c6747"}, "downloads": -1, "filename": "pytorch_pretrained_bert-0.6.2.tar.gz", "has_sig": false, "md5_digest": "6ead9886eb52235509d54a5ae2820d79", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 127408, "upload_time": "2019-04-25T19:42:04", "upload_time_iso_8601": "2019-04-25T19:42:04.571350Z", "url": "https://files.pythonhosted.org/packages/62/99/32f994e64c1f3c23f73ccff01ae7324ecd82ac2e5f16657940cb72832a06/pytorch_pretrained_bert-0.6.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:13:44 2020"}