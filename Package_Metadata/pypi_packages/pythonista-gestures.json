{"info": {"author": "Mikael Honkala", "author_email": "mikael.honkala@gmail.com", "bugtrack_url": null, "classifiers": ["Operating System :: iOS"], "description": "# gestures\n\nGestures wrapper for iOS\n\n# Gestures for the Pythonista iOS app\n \nThis is a convenience class for enabling gestures, including drag and drop\nsupport, in Pythonista UI applications. Main intent here has been to make\nthem Python friendly, hiding all the Objective-C details.\n\nRun the file on its own to see a demo of the supported gestures.\n\n![Demo image](https://raw.githubusercontent.com/mikaelho/pythonista-gestures/master/gestures.jpg)\n\n## Installation\n\nCopy from [GitHub](https://github.com/mikaelho/pythonista-gestures), or\n\n    pip install pythonista-gestures\n\nwith [stash](https://github.com/ywangd/stash).\n\n## Versions:\n\n* 1.2 - Adds drag and drop support.  \n* 1.1 - Adds distance parameters to swipe gestures.\n* 1.0 - First version released to PyPi. \n  Breaks backwards compatibility in syntax, adds multi-recognizer coordination,\n  and removes force press support.\n\n## Usage\n\nFor example, do something when user swipes left on a Label:\n \n    import gestures\n\n    def swipe_handler(data):\n        print(f\u2018I was swiped left, starting from {data.location}')\n     \n    label = ui.Label()\n    gestures.swipe(label, swipe_handler, direction=gestures.LEFT)\n\nYour handler method gets one `data` argument that always contains the\nattributes described below. Individual gestures may provide more\ninformation; see the API documentation for the methods used to add different\ngestures.\n  \n* `recognizer` - (ObjC) recognizer object\n* `view` - (Pythonista) view that was gestured at\n* `location` - Location of the gesture as a `ui.Point` with `x` and `y`\n  attributes\n* `state` - State of gesture recognition; one of\n  `gestures.POSSIBLE/BEGAN/RECOGNIZED/CHANGED/ENDED/CANCELLED/FAILED`\n* `began`, `changed`, `ended`, `failed` - convenience boolean properties to \n  check for these states\n* `number_of_touches` - Number of touches recognized\n\nFor continuous gestures, check for `data.began` or `data.ended` in the handler \nif you are just interested that a pinch or a force press happened.\n\nAll of the gesture-adding methods return an object that can be used\nto remove or disable the gesture as needed, see the API. You can also remove\nall gestures from a view with `remove_all_gestures(view)`.\n\n## Drag and drop\n\nThis module supports dragging and dropping both within a Pythonista app and\nbetween Pythonista and another app (only possible on iPads). These two cases\nare handled differently:\n    \n* For in-app drops, Apple method of relaying objects is skipped completely,\n  and you can refer to _any_ Python object to be dropped to the target view.\n* For cross-app drops, we have to conform to Apple method of managing data.\n  Currently only plain text and image drops are supported, in either direction.\n* It is also good to note that `ui.TextField` and `ui.TextView` views natively\n  act as receivers for both in-app and cross-app plain text drag and drop.\n\nView is set to be a sender for a drap and drop operation with the `drag`\nfunction. Drag starts with a long press, and can end in any view that has been\nset as a receiver with the `drop` function. Views show the readiness to receive\ndata with a green \"plus\" sign. You can accept only specific types of data;\nincompatible drop targets show a grey \"forbidden\" sign.\n\nFollowing example covers setting up an in-app drag and drop operation between\ntwo labels. To repeat, in the in-app case, the simple string could replaced by\nany Python object of any complexity, passed by reference:\n    \n    drag(sender_label, \"Important data\")\n    \n    drop(receiver_label,\n        lambda data, sender, receiver: setattr(receiver, 'text', data),\n        accept=str)\n\nSee the documentation for the two functions for details.\n\n## Fine-tuning gesture recognition\n\nBy default only one gesture recognizer will be successful. You can prioritize\none over the other by using the `before` method of the returned object.\nFor example, the following ensures that the swipe always has a chance to happen\nfirst:\n    \n    panner = pan(view, pan_handler)\n    swiper = swipe(view, swipe_handler, direction=RIGHT)\n    swiper.before(panner)\n    \n(For your convenience, there is also a similar `after` method.)\n\nYou can also allow gestures to be recognized simultaneously using the\n`together_with` method. For example, the following enables simultaneous panning\nand zooming (pinching):\n    \n    panner = pan(view, pan_handler)\n    pincher = pinch(view, pinch_handler)\n    panner.together_with(pincher)\n\n## Using lambdas\n\nIf there in existing method that you just want to trigger with a gesture,\noften you do not need to create an extra handler function.\nThis works best with the discrete `tap` and `swipe` gestures where we do not\nneed to worry with the state of the gesture.\n\n    tap(label, lambda _: setattr(label, 'text', 'Tapped'))\n\nThe example below triggers some kind of a database refresh when a long press is\ndetected on a button.\nAnything more complicated than this is probably worth creating a separate\nfunction.\n    \n    long_press(button, lambda data: db.refresh() if data.began else None)\n\n## Pythonista app-closing gesture\n\nWhen you use the `hide_title_bar=True` attribute with `present`, you close\nthe app with the 2-finger-swipe-down gesture. This gesture can be\ndisabled with:\n  \n    gestures.disable_swipe_to_close(view)\n    \nwhere the `view` must be the one you `present`.\n\nYou can also replace the close gesture with another, by providing the\n\"magic\" `close` string as the gesture handler. For example,\nif you feel that tapping with two thumbs is more convenient in two-handed\nphone use:\n  \n    gestures.tap(view, 'close', number_of_touches_required=2)\n\n## Other details\n \n* Adding a gesture to a view automatically sets `touch_enabled=True` for that\n  view, to avoid counter-intuitive situations where adding a gesture\n  recognizer to e.g. ui.Label produces no results.\n* It can be hard to add gestures to ui.ScrollView, ui.TextView and the like,\n  because they have complex multi-view structures and gestures already in\n  place.  \n\n# API\n\n* [Functions](#functions)\n  * [Gestures](#gestures)\n  * [Gesture management](#gesture-management)\n  * [Drag and drop](#drag-and-drop)\n\n\n# Functions\n\n\n#### GESTURES\n#### `tap(view, action,number_of_taps_required=None, number_of_touches_required=None)`\n\n  Call `action` when a tap gesture is recognized for the `view`.\n  \n  Additional parameters:\n  \n  * `number_of_taps_required` - Set if more than one tap is required for\n    the gesture to be recognized.\n  * `number_of_touches_required` - Set if more than one finger is\n    required for the gesture to be recognized.\n\n#### `doubletap(view, action,number_of_touches_required=None)`\n\n  Convenience method that calls `tap` with a 2-tap requirement.\n      \n\n#### `long_press(view, action,number_of_taps_required=None,number_of_touches_required=None,minimum_press_duration=None,allowable_movement=None)`\n\n  Call `action` when a long press gesture is recognized for the\n  `view`. Note that this is a continuous gesture; you might want to\n  check for `data.changed` or `data.ended` to get the desired results.\n  \n  Additional parameters:\n  \n  * `number_of_taps_required` - Set if more than one tap is required for\n    the gesture to be recognized.\n  * `number_of_touches_required` - Set if more than one finger is\n    required for the gesture to be recognized.\n  * `minimum_press_duration` - Set to change the default 0.5-second\n    recognition treshold.\n  * `allowable_movement` - Set to change the default 10 point maximum\n  distance allowed for the gesture to be recognized.\n\n#### `pan(view, action,minimum_number_of_touches=None,maximum_number_of_touches=None)`\n\n  Call `action` when a pan gesture is recognized for the `view`.\n  This is a continuous gesture.\n  \n  Additional parameters:\n  \n  * `minimum_number_of_touches` - Set to control the gesture recognition.\n  * `maximum_number_of_touches` - Set to control the gesture recognition.\n  \n  Handler `action` receives the following gesture-specific attributes\n  in the `data` argument:\n  \n  * `translation` - Translation from the starting point of the gesture\n    as a `ui.Point` with `x` and `y` attributes.\n  * `velocity` - Current velocity of the pan gesture as points per\n    second (a `ui.Point` with `x` and `y` attributes).\n\n#### `edge_pan(view, action, edges)`\n\n  Call `action` when a pan gesture starting from the edge is\n  recognized for the `view`. This is a continuous gesture.\n  \n  `edges` must be set to one of\n  `gestures.EDGE_NONE/EDGE_TOP/EDGE_LEFT/EDGE_BOTTOM/EDGE_RIGHT\n  /EDGE_ALL`. If you want to recognize pans from different edges,\n  you have to set up separate recognizers with separate calls to this\n  method.\n  \n  Handler `action` receives the same gesture-specific attributes in\n  the `data` argument as pan gestures, see `pan`.\n\n#### `pinch(view, action)`\n\n  Call `action` when a pinch gesture is recognized for the `view`.\n  This is a continuous gesture.\n  \n  Handler `action` receives the following gesture-specific attributes\n  in the `data` argument:\n  \n  * `scale` - Relative to the distance of the fingers as opposed to when\n    the touch first started.\n  * `velocity` - Current velocity of the pinch gesture as scale\n    per second.\n\n#### `rotation(view, action)`\n\n  Call `action` when a rotation gesture is recognized for the `view`.\n  This is a continuous gesture.\n  \n  Handler `action` receives the following gesture-specific attributes\n  in the `data` argument:\n  \n  * `rotation` - Rotation in radians, relative to the position of the\n    fingers when the touch first started.\n  * `velocity` - Current velocity of the rotation gesture as radians\n    per second.\n\n#### `swipe(view, action,direction=None,number_of_touches_required=None,min_distance=None,max_distance=None)`\n\n  Call `action` when a swipe gesture is recognized for the `view`.\n  \n  Additional parameters:\n  \n  * `direction` - Direction of the swipe to be recognized. Either one of\n    `gestures.RIGHT/LEFT/UP/DOWN`, or a list of multiple directions.\n  * `number_of_touches_required` - Set if you need to change the minimum\n    number of touches required.\n  * `min_distance` - Minimum distance the swipe gesture must travel in\n    order to be recognized. Default is 50.\n    This uses an undocumented recognizer attribute.\n  * `max_distance` - Maximum distance the swipe gesture can travel in\n    order to still be recognized. Default is a very large number.\n    This uses an undocumented recognizer attribute.\n  \n  If set to recognize swipes to multiple directions, the handler\n  does not receive any indication of the direction of the swipe. Add\n  multiple recognizers if you need to differentiate between the\n  directions.\n\n#### GESTURE MANAGEMENT\n#### `disable(handler)`\n\n  Disable a recognizer temporarily. \n\n#### `enable(handler)`\n\n  Enable a disabled gesture recognizer. There is no error if the\n  recognizer is already enabled. \n\n#### `remove(view, handler)`\n\n  Remove the recognizer from the view permanently. \n\n#### `remove_all_gestures(view)`\n\n  Remove all gesture recognizers from a view. \n\n#### `disable_swipe_to_close(view)`\n\n  Utility class method that will disable the two-finger-swipe-down\n  gesture used in Pythonista to end the program when in full screen\n  view (`hide_title_bar` set to `True`).\n  \n  Returns a tuple of the actual ObjC view and dismiss target.\n\n#### `replace_close_gesture(view, recognizer_class)`\n\n\n#### DRAG AND DROP\n#### `drag(view, payload, allow_others=False)`\n\n  Sets the `view` to be the sender in a drag and drop operation. Dragging\n  starts with a long press.\n  \n  For within-app drag and drop, `payload` can be anything, and it is passed\n  by reference.\n  \n  If the `payload` is a text string or a `ui.Image`, it can be dragged\n  (copied) to another app (on iPad).\n  There is also built-in support for dropping text to any `ui.TextField` or\n  `ui.TextView`. \n  \n  If `payload` is a function, it is called at the time when the drag starts.\n  The function receives one argument, the sending `view`, and must return the\n  data to be dragged.\n  \n  Additional parameters:\n  \n  * `allow_others` - Set to True if other gestures attached to the view\n  should be prioritized over the dragging.\n\n#### `drop(view, action, accept=None)`\n\n  Sets the `view` as a drop target, calling the `action` function with\n  dropped data.\n  \n  Additional parameters:\n  \n  * `accept` - Control which data will be accepted for dropping. Simplest\n  option is to provide an accepted Python type like `dict` or `ui.Label`.\n  \n    For cross-app drops, only two types are currently supported: `str` for\n    plain text, and `ui.Image` for images.\n    \n    For in-app drops, the `accept` argument can also be a function that will\n    be called when a drag enters the view. Function gets same parameters\n    as the main handler, and should return False if the view should not accept\n    the drop.\n  \n  `action` function has to have this signature:\n      \n      def handle_drop(data, sender, receiver):\n          ...\n          \n  Arguments of the `action` function are:\n          \n  * `data` - The dragged data.\n  * `sender` - Source view of the drag and drop. This is `None` for drags\n  between apps.\n  * `receiver` - Same as `view`.\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mikaelho/pythonista-gestures", "keywords": "", "license": "The Unlicense", "maintainer": "", "maintainer_email": "", "name": "pythonista-gestures", "package_url": "https://pypi.org/project/pythonista-gestures/", "platform": "", "project_url": "https://pypi.org/project/pythonista-gestures/", "project_urls": {"Homepage": "https://github.com/mikaelho/pythonista-gestures"}, "release_url": "https://pypi.org/project/pythonista-gestures/1.2.1/", "requires_dist": null, "requires_python": "", "summary": "Gestures wrapper for iOS", "version": "1.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>gestures</h1>\n<p>Gestures wrapper for iOS</p>\n<h1>Gestures for the Pythonista iOS app</h1>\n<p>This is a convenience class for enabling gestures, including drag and drop\nsupport, in Pythonista UI applications. Main intent here has been to make\nthem Python friendly, hiding all the Objective-C details.</p>\n<p>Run the file on its own to see a demo of the supported gestures.</p>\n<p><img alt=\"Demo image\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/998378b58a5de0afb242cd6435877b19d19957ec/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6d696b61656c686f2f707974686f6e697374612d67657374757265732f6d61737465722f67657374757265732e6a7067\"></p>\n<h2>Installation</h2>\n<p>Copy from <a href=\"https://github.com/mikaelho/pythonista-gestures\" rel=\"nofollow\">GitHub</a>, or</p>\n<pre><code>pip install pythonista-gestures\n</code></pre>\n<p>with <a href=\"https://github.com/ywangd/stash\" rel=\"nofollow\">stash</a>.</p>\n<h2>Versions:</h2>\n<ul>\n<li>1.2 - Adds drag and drop support.</li>\n<li>1.1 - Adds distance parameters to swipe gestures.</li>\n<li>1.0 - First version released to PyPi.\nBreaks backwards compatibility in syntax, adds multi-recognizer coordination,\nand removes force press support.</li>\n</ul>\n<h2>Usage</h2>\n<p>For example, do something when user swipes left on a Label:</p>\n<pre><code>import gestures\n\ndef swipe_handler(data):\n    print(f\u2018I was swiped left, starting from {data.location}')\n \nlabel = ui.Label()\ngestures.swipe(label, swipe_handler, direction=gestures.LEFT)\n</code></pre>\n<p>Your handler method gets one <code>data</code> argument that always contains the\nattributes described below. Individual gestures may provide more\ninformation; see the API documentation for the methods used to add different\ngestures.</p>\n<ul>\n<li><code>recognizer</code> - (ObjC) recognizer object</li>\n<li><code>view</code> - (Pythonista) view that was gestured at</li>\n<li><code>location</code> - Location of the gesture as a <code>ui.Point</code> with <code>x</code> and <code>y</code>\nattributes</li>\n<li><code>state</code> - State of gesture recognition; one of\n<code>gestures.POSSIBLE/BEGAN/RECOGNIZED/CHANGED/ENDED/CANCELLED/FAILED</code></li>\n<li><code>began</code>, <code>changed</code>, <code>ended</code>, <code>failed</code> - convenience boolean properties to\ncheck for these states</li>\n<li><code>number_of_touches</code> - Number of touches recognized</li>\n</ul>\n<p>For continuous gestures, check for <code>data.began</code> or <code>data.ended</code> in the handler\nif you are just interested that a pinch or a force press happened.</p>\n<p>All of the gesture-adding methods return an object that can be used\nto remove or disable the gesture as needed, see the API. You can also remove\nall gestures from a view with <code>remove_all_gestures(view)</code>.</p>\n<h2>Drag and drop</h2>\n<p>This module supports dragging and dropping both within a Pythonista app and\nbetween Pythonista and another app (only possible on iPads). These two cases\nare handled differently:</p>\n<ul>\n<li>For in-app drops, Apple method of relaying objects is skipped completely,\nand you can refer to <em>any</em> Python object to be dropped to the target view.</li>\n<li>For cross-app drops, we have to conform to Apple method of managing data.\nCurrently only plain text and image drops are supported, in either direction.</li>\n<li>It is also good to note that <code>ui.TextField</code> and <code>ui.TextView</code> views natively\nact as receivers for both in-app and cross-app plain text drag and drop.</li>\n</ul>\n<p>View is set to be a sender for a drap and drop operation with the <code>drag</code>\nfunction. Drag starts with a long press, and can end in any view that has been\nset as a receiver with the <code>drop</code> function. Views show the readiness to receive\ndata with a green \"plus\" sign. You can accept only specific types of data;\nincompatible drop targets show a grey \"forbidden\" sign.</p>\n<p>Following example covers setting up an in-app drag and drop operation between\ntwo labels. To repeat, in the in-app case, the simple string could replaced by\nany Python object of any complexity, passed by reference:</p>\n<pre><code>drag(sender_label, \"Important data\")\n\ndrop(receiver_label,\n    lambda data, sender, receiver: setattr(receiver, 'text', data),\n    accept=str)\n</code></pre>\n<p>See the documentation for the two functions for details.</p>\n<h2>Fine-tuning gesture recognition</h2>\n<p>By default only one gesture recognizer will be successful. You can prioritize\none over the other by using the <code>before</code> method of the returned object.\nFor example, the following ensures that the swipe always has a chance to happen\nfirst:</p>\n<pre><code>panner = pan(view, pan_handler)\nswiper = swipe(view, swipe_handler, direction=RIGHT)\nswiper.before(panner)\n</code></pre>\n<p>(For your convenience, there is also a similar <code>after</code> method.)</p>\n<p>You can also allow gestures to be recognized simultaneously using the\n<code>together_with</code> method. For example, the following enables simultaneous panning\nand zooming (pinching):</p>\n<pre><code>panner = pan(view, pan_handler)\npincher = pinch(view, pinch_handler)\npanner.together_with(pincher)\n</code></pre>\n<h2>Using lambdas</h2>\n<p>If there in existing method that you just want to trigger with a gesture,\noften you do not need to create an extra handler function.\nThis works best with the discrete <code>tap</code> and <code>swipe</code> gestures where we do not\nneed to worry with the state of the gesture.</p>\n<pre><code>tap(label, lambda _: setattr(label, 'text', 'Tapped'))\n</code></pre>\n<p>The example below triggers some kind of a database refresh when a long press is\ndetected on a button.\nAnything more complicated than this is probably worth creating a separate\nfunction.</p>\n<pre><code>long_press(button, lambda data: db.refresh() if data.began else None)\n</code></pre>\n<h2>Pythonista app-closing gesture</h2>\n<p>When you use the <code>hide_title_bar=True</code> attribute with <code>present</code>, you close\nthe app with the 2-finger-swipe-down gesture. This gesture can be\ndisabled with:</p>\n<pre><code>gestures.disable_swipe_to_close(view)\n</code></pre>\n<p>where the <code>view</code> must be the one you <code>present</code>.</p>\n<p>You can also replace the close gesture with another, by providing the\n\"magic\" <code>close</code> string as the gesture handler. For example,\nif you feel that tapping with two thumbs is more convenient in two-handed\nphone use:</p>\n<pre><code>gestures.tap(view, 'close', number_of_touches_required=2)\n</code></pre>\n<h2>Other details</h2>\n<ul>\n<li>Adding a gesture to a view automatically sets <code>touch_enabled=True</code> for that\nview, to avoid counter-intuitive situations where adding a gesture\nrecognizer to e.g. ui.Label produces no results.</li>\n<li>It can be hard to add gestures to ui.ScrollView, ui.TextView and the like,\nbecause they have complex multi-view structures and gestures already in\nplace.</li>\n</ul>\n<h1>API</h1>\n<ul>\n<li><a href=\"#functions\" rel=\"nofollow\">Functions</a>\n<ul>\n<li><a href=\"#gestures\" rel=\"nofollow\">Gestures</a></li>\n<li><a href=\"#gesture-management\" rel=\"nofollow\">Gesture management</a></li>\n<li><a href=\"#drag-and-drop\" rel=\"nofollow\">Drag and drop</a></li>\n</ul>\n</li>\n</ul>\n<h1>Functions</h1>\n<h4>GESTURES</h4>\n<h4><code>tap(view, action,number_of_taps_required=None, number_of_touches_required=None)</code></h4>\n<p>Call <code>action</code> when a tap gesture is recognized for the <code>view</code>.</p>\n<p>Additional parameters:</p>\n<ul>\n<li><code>number_of_taps_required</code> - Set if more than one tap is required for\nthe gesture to be recognized.</li>\n<li><code>number_of_touches_required</code> - Set if more than one finger is\nrequired for the gesture to be recognized.</li>\n</ul>\n<h4><code>doubletap(view, action,number_of_touches_required=None)</code></h4>\n<p>Convenience method that calls <code>tap</code> with a 2-tap requirement.</p>\n<h4><code>long_press(view, action,number_of_taps_required=None,number_of_touches_required=None,minimum_press_duration=None,allowable_movement=None)</code></h4>\n<p>Call <code>action</code> when a long press gesture is recognized for the\n<code>view</code>. Note that this is a continuous gesture; you might want to\ncheck for <code>data.changed</code> or <code>data.ended</code> to get the desired results.</p>\n<p>Additional parameters:</p>\n<ul>\n<li><code>number_of_taps_required</code> - Set if more than one tap is required for\nthe gesture to be recognized.</li>\n<li><code>number_of_touches_required</code> - Set if more than one finger is\nrequired for the gesture to be recognized.</li>\n<li><code>minimum_press_duration</code> - Set to change the default 0.5-second\nrecognition treshold.</li>\n<li><code>allowable_movement</code> - Set to change the default 10 point maximum\ndistance allowed for the gesture to be recognized.</li>\n</ul>\n<h4><code>pan(view, action,minimum_number_of_touches=None,maximum_number_of_touches=None)</code></h4>\n<p>Call <code>action</code> when a pan gesture is recognized for the <code>view</code>.\nThis is a continuous gesture.</p>\n<p>Additional parameters:</p>\n<ul>\n<li><code>minimum_number_of_touches</code> - Set to control the gesture recognition.</li>\n<li><code>maximum_number_of_touches</code> - Set to control the gesture recognition.</li>\n</ul>\n<p>Handler <code>action</code> receives the following gesture-specific attributes\nin the <code>data</code> argument:</p>\n<ul>\n<li><code>translation</code> - Translation from the starting point of the gesture\nas a <code>ui.Point</code> with <code>x</code> and <code>y</code> attributes.</li>\n<li><code>velocity</code> - Current velocity of the pan gesture as points per\nsecond (a <code>ui.Point</code> with <code>x</code> and <code>y</code> attributes).</li>\n</ul>\n<h4><code>edge_pan(view, action, edges)</code></h4>\n<p>Call <code>action</code> when a pan gesture starting from the edge is\nrecognized for the <code>view</code>. This is a continuous gesture.</p>\n<p><code>edges</code> must be set to one of\n<code>gestures.EDGE_NONE/EDGE_TOP/EDGE_LEFT/EDGE_BOTTOM/EDGE_RIGHT /EDGE_ALL</code>. If you want to recognize pans from different edges,\nyou have to set up separate recognizers with separate calls to this\nmethod.</p>\n<p>Handler <code>action</code> receives the same gesture-specific attributes in\nthe <code>data</code> argument as pan gestures, see <code>pan</code>.</p>\n<h4><code>pinch(view, action)</code></h4>\n<p>Call <code>action</code> when a pinch gesture is recognized for the <code>view</code>.\nThis is a continuous gesture.</p>\n<p>Handler <code>action</code> receives the following gesture-specific attributes\nin the <code>data</code> argument:</p>\n<ul>\n<li><code>scale</code> - Relative to the distance of the fingers as opposed to when\nthe touch first started.</li>\n<li><code>velocity</code> - Current velocity of the pinch gesture as scale\nper second.</li>\n</ul>\n<h4><code>rotation(view, action)</code></h4>\n<p>Call <code>action</code> when a rotation gesture is recognized for the <code>view</code>.\nThis is a continuous gesture.</p>\n<p>Handler <code>action</code> receives the following gesture-specific attributes\nin the <code>data</code> argument:</p>\n<ul>\n<li><code>rotation</code> - Rotation in radians, relative to the position of the\nfingers when the touch first started.</li>\n<li><code>velocity</code> - Current velocity of the rotation gesture as radians\nper second.</li>\n</ul>\n<h4><code>swipe(view, action,direction=None,number_of_touches_required=None,min_distance=None,max_distance=None)</code></h4>\n<p>Call <code>action</code> when a swipe gesture is recognized for the <code>view</code>.</p>\n<p>Additional parameters:</p>\n<ul>\n<li><code>direction</code> - Direction of the swipe to be recognized. Either one of\n<code>gestures.RIGHT/LEFT/UP/DOWN</code>, or a list of multiple directions.</li>\n<li><code>number_of_touches_required</code> - Set if you need to change the minimum\nnumber of touches required.</li>\n<li><code>min_distance</code> - Minimum distance the swipe gesture must travel in\norder to be recognized. Default is 50.\nThis uses an undocumented recognizer attribute.</li>\n<li><code>max_distance</code> - Maximum distance the swipe gesture can travel in\norder to still be recognized. Default is a very large number.\nThis uses an undocumented recognizer attribute.</li>\n</ul>\n<p>If set to recognize swipes to multiple directions, the handler\ndoes not receive any indication of the direction of the swipe. Add\nmultiple recognizers if you need to differentiate between the\ndirections.</p>\n<h4>GESTURE MANAGEMENT</h4>\n<h4><code>disable(handler)</code></h4>\n<p>Disable a recognizer temporarily.</p>\n<h4><code>enable(handler)</code></h4>\n<p>Enable a disabled gesture recognizer. There is no error if the\nrecognizer is already enabled.</p>\n<h4><code>remove(view, handler)</code></h4>\n<p>Remove the recognizer from the view permanently.</p>\n<h4><code>remove_all_gestures(view)</code></h4>\n<p>Remove all gesture recognizers from a view.</p>\n<h4><code>disable_swipe_to_close(view)</code></h4>\n<p>Utility class method that will disable the two-finger-swipe-down\ngesture used in Pythonista to end the program when in full screen\nview (<code>hide_title_bar</code> set to <code>True</code>).</p>\n<p>Returns a tuple of the actual ObjC view and dismiss target.</p>\n<h4><code>replace_close_gesture(view, recognizer_class)</code></h4>\n<h4>DRAG AND DROP</h4>\n<h4><code>drag(view, payload, allow_others=False)</code></h4>\n<p>Sets the <code>view</code> to be the sender in a drag and drop operation. Dragging\nstarts with a long press.</p>\n<p>For within-app drag and drop, <code>payload</code> can be anything, and it is passed\nby reference.</p>\n<p>If the <code>payload</code> is a text string or a <code>ui.Image</code>, it can be dragged\n(copied) to another app (on iPad).\nThere is also built-in support for dropping text to any <code>ui.TextField</code> or\n<code>ui.TextView</code>.</p>\n<p>If <code>payload</code> is a function, it is called at the time when the drag starts.\nThe function receives one argument, the sending <code>view</code>, and must return the\ndata to be dragged.</p>\n<p>Additional parameters:</p>\n<ul>\n<li><code>allow_others</code> - Set to True if other gestures attached to the view\nshould be prioritized over the dragging.</li>\n</ul>\n<h4><code>drop(view, action, accept=None)</code></h4>\n<p>Sets the <code>view</code> as a drop target, calling the <code>action</code> function with\ndropped data.</p>\n<p>Additional parameters:</p>\n<ul>\n<li>\n<p><code>accept</code> - Control which data will be accepted for dropping. Simplest\noption is to provide an accepted Python type like <code>dict</code> or <code>ui.Label</code>.</p>\n<p>For cross-app drops, only two types are currently supported: <code>str</code> for\nplain text, and <code>ui.Image</code> for images.</p>\n<p>For in-app drops, the <code>accept</code> argument can also be a function that will\nbe called when a drag enters the view. Function gets same parameters\nas the main handler, and should return False if the view should not accept\nthe drop.</p>\n</li>\n</ul>\n<p><code>action</code> function has to have this signature:</p>\n<pre><code>  def handle_drop(data, sender, receiver):\n      ...\n</code></pre>\n<p>Arguments of the <code>action</code> function are:</p>\n<ul>\n<li><code>data</code> - The dragged data.</li>\n<li><code>sender</code> - Source view of the drag and drop. This is <code>None</code> for drags\nbetween apps.</li>\n<li><code>receiver</code> - Same as <code>view</code>.</li>\n</ul>\n\n          </div>"}, "last_serial": 6857601, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "61ca4a951dac2b53af3444db69c8b6e2", "sha256": "3eacb71fbac3c1b509d2b6f8a32876568ce469c4d83163ea6cb21f9be32a0ee3"}, "downloads": -1, "filename": "pythonista_gestures-1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "61ca4a951dac2b53af3444db69c8b6e2", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 10408, "upload_time": "2020-03-01T13:16:02", "upload_time_iso_8601": "2020-03-01T13:16:02.383653Z", "url": "https://files.pythonhosted.org/packages/e0/76/e1766485ab9b521d9d4c304854f479b87db6df350dc54996aa5c71e4d608/pythonista_gestures-1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c22c9592d207f5f3bef3cf9683985684", "sha256": "3ce91c523a2d54fe7cb21951f79894a9894edbb40f27d0a2ad0ea68a92291f62"}, "downloads": -1, "filename": "pythonista-gestures-1.0.tar.gz", "has_sig": false, "md5_digest": "c22c9592d207f5f3bef3cf9683985684", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 112434, "upload_time": "2020-03-01T13:16:06", "upload_time_iso_8601": "2020-03-01T13:16:06.376064Z", "url": "https://files.pythonhosted.org/packages/76/da/735eff77643683323decfa650e837177de51c03d141e3683e5d53eb3fa85/pythonista-gestures-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "d512a81fe914bcfd4cf87a48721e3f53", "sha256": "4f708d7da3eba48b2069a17e819a86086fec24bc20da2e36cf6727de3e6cc2cd"}, "downloads": -1, "filename": "pythonista_gestures-1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d512a81fe914bcfd4cf87a48721e3f53", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 11179, "upload_time": "2020-03-08T13:47:06", "upload_time_iso_8601": "2020-03-08T13:47:06.341592Z", "url": "https://files.pythonhosted.org/packages/4c/70/e82eefbc9aef53b0e8b13173443bb25e4683be8c9280f7019b728c4b0494/pythonista_gestures-1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ac27ad1f36471dddd6218ba0d15cfc3d", "sha256": "1469d655e1c569479229be8ffdf65e78141f2cf954614af1497412a8f573462d"}, "downloads": -1, "filename": "pythonista-gestures-1.1.tar.gz", "has_sig": false, "md5_digest": "ac27ad1f36471dddd6218ba0d15cfc3d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 113417, "upload_time": "2020-03-08T13:47:09", "upload_time_iso_8601": "2020-03-08T13:47:09.258458Z", "url": "https://files.pythonhosted.org/packages/f3/34/b743c3e527d1a822f719969c0abce582f9f4ccb68d33256eee49aa3f4748/pythonista-gestures-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "a1b09d1e62db3112801661e7c46265f4", "sha256": "96751b3509bb41d5b89d4e12045cc8feb5092ed908c225bfd99a63ae30760c29"}, "downloads": -1, "filename": "pythonista_gestures-1.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a1b09d1e62db3112801661e7c46265f4", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15466, "upload_time": "2020-03-21T23:22:12", "upload_time_iso_8601": "2020-03-21T23:22:12.302727Z", "url": "https://files.pythonhosted.org/packages/d5/08/8e25ba5657e34a5b0a03607565c6c75b5a60503e8c9abd7db0369de7bc93/pythonista_gestures-1.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3cfcf181dbbda7467946febe44de25fa", "sha256": "9b0cc0cd4228376c7581832b461099ba0285ab97e7169cd6c798b1c1bf0e7a83"}, "downloads": -1, "filename": "pythonista-gestures-1.2.tar.gz", "has_sig": false, "md5_digest": "3cfcf181dbbda7467946febe44de25fa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 118412, "upload_time": "2020-03-21T23:22:15", "upload_time_iso_8601": "2020-03-21T23:22:15.470215Z", "url": "https://files.pythonhosted.org/packages/59/68/cdd17d93ebc0aa5e737a21e6d06d5caee9e3d2d917963a1863140d1be5c0/pythonista-gestures-1.2.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "fe160ced5c33948edc0f2496ac94ae8c", "sha256": "8a5c514ea3e0f2149a896f56a71a9085e2e0de1bd340c013f151a83c72d43baf"}, "downloads": -1, "filename": "pythonista_gestures-1.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "fe160ced5c33948edc0f2496ac94ae8c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15479, "upload_time": "2020-03-21T23:32:42", "upload_time_iso_8601": "2020-03-21T23:32:42.928236Z", "url": "https://files.pythonhosted.org/packages/40/ef/12fff202abaa18ec888e943ca3b970bcbde0d3e02218682dcf1c01ac319b/pythonista_gestures-1.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a349f3a6d16f4c86ad1861334f8e6bc8", "sha256": "1410aa0364c1d9e4707d9587985a76d2d91d877d8c8a069f4118bad02b2583c7"}, "downloads": -1, "filename": "pythonista-gestures-1.2.1.tar.gz", "has_sig": false, "md5_digest": "a349f3a6d16f4c86ad1861334f8e6bc8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 118427, "upload_time": "2020-03-21T23:32:45", "upload_time_iso_8601": "2020-03-21T23:32:45.505787Z", "url": "https://files.pythonhosted.org/packages/ae/59/3b6e6675dde3581a25533cf36095b00362bc42f4ca558a05524f52939037/pythonista-gestures-1.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fe160ced5c33948edc0f2496ac94ae8c", "sha256": "8a5c514ea3e0f2149a896f56a71a9085e2e0de1bd340c013f151a83c72d43baf"}, "downloads": -1, "filename": "pythonista_gestures-1.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "fe160ced5c33948edc0f2496ac94ae8c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15479, "upload_time": "2020-03-21T23:32:42", "upload_time_iso_8601": "2020-03-21T23:32:42.928236Z", "url": "https://files.pythonhosted.org/packages/40/ef/12fff202abaa18ec888e943ca3b970bcbde0d3e02218682dcf1c01ac319b/pythonista_gestures-1.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a349f3a6d16f4c86ad1861334f8e6bc8", "sha256": "1410aa0364c1d9e4707d9587985a76d2d91d877d8c8a069f4118bad02b2583c7"}, "downloads": -1, "filename": "pythonista-gestures-1.2.1.tar.gz", "has_sig": false, "md5_digest": "a349f3a6d16f4c86ad1861334f8e6bc8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 118427, "upload_time": "2020-03-21T23:32:45", "upload_time_iso_8601": "2020-03-21T23:32:45.505787Z", "url": "https://files.pythonhosted.org/packages/ae/59/3b6e6675dde3581a25533cf36095b00362bc42f4ca558a05524f52939037/pythonista-gestures-1.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:17:08 2020"}