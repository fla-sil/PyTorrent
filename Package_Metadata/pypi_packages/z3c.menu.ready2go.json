{"info": {"author": "Stephan Richter, Roger Ineichen and the Zope Community", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP"], "description": "This package provides a \"ready-to-go\" menu implementation based on viewlets for \nZope 3.\n\n\n.. contents::\n\n===============\nReady 2 go Menu\n===============\n\nThe z3c.menu.ready2go package provides a menu implementation which allows you\nto implement menus based on content providers and viewlets.\n\nFirst let's setup our defualt menu item template:\n\n  >>> import os\n  >>> import zope.component\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n  >>> from zope.publisher.interfaces.browser import IBrowserView\n  >>> from z3c.template.interfaces import IContentTemplate\n  >>> from z3c.template.template import TemplateFactory\n  >>> import z3c.menu.ready2go\n  >>> baseDir = os.path.split(z3c.menu.ready2go.__file__)[0]\n  >>> itemTemplate = os.path.join(baseDir, 'item.pt')\n  >>> itemTemplateFactory = TemplateFactory(itemTemplate, 'text/html')\n  >>> zope.component.provideAdapter(itemTemplateFactory,\n  ...     (IBrowserView, IDefaultBrowserLayer), IContentTemplate)\n\n\nGlobal Menu\n-----------\n\nLet's create some menu and register them as viewlet manager:\n\n  >>> from zope.viewlet.interfaces import IViewlet\n  >>> from zope.viewlet import manager\n  >>> from z3c.menu.ready2go import interfaces\n  >>> from z3c.menu.ready2go import IGlobalMenu\n  >>> from z3c.menu.ready2go import ISiteMenu\n  >>> from z3c.menu.ready2go import IContextMenu\n  >>> from z3c.menu.ready2go import IAddMenu\n  >>> from z3c.menu.ready2go.manager import MenuManager\n\nAnd we configure our menu item as viewlet Managers. This is normaly done by the\n``viewletManager`` ZCML directive:\n\n  >>> GlobalMenu = manager.ViewletManager('left', IGlobalMenu,\n  ...     bases=(MenuManager,))\n\n  >>> SiteMenu = manager.ViewletManager('left', ISiteMenu,\n  ...     bases=(MenuManager,))\n\n  >>> ContextMenu = manager.ViewletManager('left', IContextMenu,\n  ...     bases=(MenuManager,))\n\n  >>> AddMenu = manager.ViewletManager('left', IAddMenu,\n  ...     bases=(MenuManager,))\n\nOur menu managers implement IMenuManager:\n\n  >>> interfaces.IMenuManager.implementedBy(GlobalMenu)\n  True\n\n  >>> interfaces.IMenuManager.implementedBy(SiteMenu)\n  True\n\n  >>> interfaces.IMenuManager.implementedBy(ContextMenu)\n  True\n\n  >>> interfaces.IMenuManager.implementedBy(AddMenu)\n  True\n\nWe also need our checker adapter which can check if a menu item is available\nand/or selected:\n\n  >>> from z3c.menu.ready2go import checker\n  >>> zope.component.provideAdapter(checker.GlobalSelectedChecker)\n  >>> zope.component.provideAdapter(checker.SiteSelectedChecker)\n  >>> zope.component.provideAdapter(checker.ContextSelectedChecker)\n\nNow we have to define a site and a context:\n\n  >>> import zope.interface\n  >>> from zope.container import contained, btree\n  >>> from zope.container.interfaces import IContained\n  >>> from zope.component.interfaces import IPossibleSite\n  >>> from zope.site.site import SiteManagerContainer\n  >>> from zope.site.site import LocalSiteManager\n\n  >>> @zope.interface.implementer(IPossibleSite)\n  ... class Site(btree.BTreeContainer, SiteManagerContainer):\n  ...     def __init__(self):\n  ...         super(Site, self).__init__()\n  ...         self.setSiteManager(LocalSiteManager(self))\n\n  >>> @zope.interface.implementer(IContained)\n  ... class Content(contained.Contained):\n  ...     pass\n\n  >>> root['site'] = Site()\n  >>> site = root['site']\n\nNow we have to set the site object as site. This is normaly done by the\ntraverser but we do this here with the hooks helper because we do not really\ntraaverse to the site within the publisher/traverser:\n\n  >>> from zope.component import hooks\n  >>> hooks.setSite(site)\n\n  >>> site['content'] = Content()\n  >>> content = site['content']\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\nAnd we need a view which knows about it's parent:\n\n  >>> @zope.interface.implementer(IBrowserView)\n  ... class View(contained.Contained):\n  ...\n  ...     def __init__(self, context, request):\n  ...         self.__parent__ = context\n  ...         self.context = context\n  ...         self.request = request\n\n  >>> view = View(content, request)\n\nOur menus can adapt the context, request and view. See IViewletManager in\nzope.viewlet for more infos about this pattern. If we render them, there is an\nempty string returned. This means the menus don't find menu items for rendering:\n\n  >>> globalMenu = GlobalMenu(content, request, view)\n  >>> globalMenu.update()\n  >>> globalMenu.render()\n  u''\n\n  >>> siteMenu = SiteMenu(content, request, view)\n  >>> siteMenu.update()\n  >>> siteMenu.render()\n  u''\n\n  >>> contextMenu = ContextMenu(content, request, view)\n  >>> contextMenu.update()\n  >>> contextMenu.render()\n  u''\n\n  >>> addMenu = AddMenu(content, request, view)\n  >>> addMenu.update()\n  >>> addMenu.render()\n  u''\n\n\nGlobal Menu Item\n----------------\n\nNow we register a context menu item for our IGlobalMenu:\n\n  >>> from z3c.menu.ready2go.item import GlobalMenuItem\n  >>> class MyGlobalMenuItem(GlobalMenuItem):\n  ...\n  ...     viewName = 'root.html'\n\nNow we need a security checker for our menu item\n\n  >>> from zope.security.checker import NamesChecker, defineChecker\n  >>> viewletChecker = NamesChecker(('update', 'render'))\n  >>> defineChecker(MyGlobalMenuItem, viewletChecker)\n\nAnd we configure our menu item for IGlobalMenu. This is normaly done by the\n``viewlet`` ZCML directive:\n\n  >>> zope.component.provideAdapter(\n  ...     MyGlobalMenuItem,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...     IBrowserView, IGlobalMenu),\n  ...     IViewlet, name='My Global')\n\nNow let's update the menu manager and see that this manager now contains\nthe menu item:\n\n  >>> globalMenu.update()\n  >>> myGlobalMenuItem = globalMenu.viewlets[0]\n  >>> myGlobalMenuItem\n  <MyGlobalMenuItem u'My Global'>\n\nNow let's render the global menu manager and you can see that the menu item\nget rendered:\n\n  >>> print(globalMenu.render())\n  <li>\n    <a href=\"http://127.0.0.1/root.html\"><span>My Global</span></a>\n  </li>\n\n\nSite Menu Item\n--------------\n\nNow we register a context menu item for our ISiteMenu:\n\n  >>> import zope.component\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n\n  >>> from z3c.menu.ready2go.item import SiteMenuItem\n  >>> class MySiteMenuItem(SiteMenuItem):\n  ...\n  ...     viewName = 'site.html'\n\nNow we need a security checker for our menu item\n\n  >>> from zope.security.checker import NamesChecker, defineChecker\n  >>> viewletChecker = NamesChecker(('update', 'render'))\n  >>> defineChecker(MySiteMenuItem, viewletChecker)\n\nAnd we configure our menu item for ISiteMenu. This is normaly done by the\n``viewlet`` ZCML directive:\n\n  >>> zope.component.provideAdapter(\n  ...     MySiteMenuItem,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...     IBrowserView, ISiteMenu),\n  ...     IViewlet, name='My Site')\n\nNow let's render the site menu again. You can see that we ve got a menu item\nand the url points to our site:\n\n  >>> siteMenu.update()\n  >>> print(siteMenu.render())\n  <li>\n    <a href=\"http://127.0.0.1/site/site.html\"><span>My Site</span></a>\n  </li>\n\n\nContext Menu Item\n-----------------\n\nNow we register a context menu item for our IContextMenu:\n\n  >>> import zope.component\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n\n  >>> from z3c.menu.ready2go.item import ContextMenuItem\n  >>> class MyContextMenuItem(ContextMenuItem):\n  ...     viewName = 'context.html'\n  ...     weight = 1\n\nNow we need a security checker for our menu item\n\n  >>> from zope.security.checker import NamesChecker, defineChecker\n  >>> viewletChecker = NamesChecker(('update', 'render'))\n  >>> defineChecker(MyContextMenuItem, viewletChecker)\n\nAnd we configure our menu item for IContextMenu. This is normaly done by the\n``viewlet`` ZCML directive:\n\n  >>> zope.component.provideAdapter(\n  ...     MyContextMenuItem,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...     IBrowserView, IContextMenu),\n  ...     IViewlet, name='My Context')\n\nNow let's render the context menu again. You can see that we ve got a menu\nitem. Another important point here is, that the url of such ContextMemuItem\nimplementations point to the context of the view:\n\n  >>> contextMenu.update()\n  >>> print(contextMenu.render())\n  <li>\n    <a href=\"http://127.0.0.1/site/content/context.html\"><span>My Context</span></a>\n  </li>\n\nLet's set the view  __name__ to ``context.html``. This will reflect that\nthe view offers the same name that our context menu needs to get rendered as\nselected:\n\n  >>> view.__name__ = 'context.html'\n\nNow try again and see if the context menu item get rendered as selected:\n\n  >>> contextMenu.update()\n  >>> print(contextMenu.render())\n  <li class=\"selected\">\n    <a href=\"http://127.0.0.1/site/content/context.html\"><span>My Context</span></a>\n  </li>\n\nAlso, let's check that menu item is marked selected even if we provided a viewName in\nthe ``@@context.html`` form:\n\n  >>> MyContextMenuItem.viewName = '@@context.html'\n  >>> contextMenu.update()\n  >>> print(contextMenu.render())\n  <li class=\"selected\">\n    <a href=\"http://127.0.0.1/site/content/@@context.html\"><span>My Context</span></a>\n  </li>\n\nOkay, change viewName back to ``context.html`` for further tests:\n\n  >>> MyContextMenuItem.viewName = 'context.html'\n\nNow add a second context menu item and check if we can use the cssInActive\nargument which is normaly a empty string:\n\n  >>> class InActiveMenuItem(ContextMenuItem):\n  ...     viewName = 'inActive.html'\n  ...     cssInActive = 'inActive'\n  ...     weight = 2\n\n  >>> defineChecker(InActiveMenuItem, viewletChecker)\n\n  >>> zope.component.provideAdapter(\n  ...     InActiveMenuItem,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...     IBrowserView, IContextMenu),\n  ...     IViewlet, name='In Active')\n\nNow update and render again:\n\n  >>> contextMenu.update()\n  >>> print(contextMenu.render())\n  <li class=\"selected\">\n    <a href=\"http://127.0.0.1/site/content/context.html\"><span>My Context</span></a>\n  </li>\n  <li class=\"inActive\">\n    <a href=\"http://127.0.0.1/site/content/inActive.html\"><span>In Active</span></a>\n  </li>\n\nAddMenu\n-------\n\nThe add menu can be used for offering links to any kind of add forms per\ncontext. This allows us to offer independent add form links doesn't matter which\nform framework is used. Let's now define such a simple AddMenuItem pointing\nto a add form url. Not; the add form and it's url do not exist in thsi test.\nThis aslo means there is no guarantee that a form exist if a add menu item\nis configured.\n\n  >>> from z3c.menu.ready2go.item import AddMenuItem\n  >>> class MyAddMenuItem(AddMenuItem):\n  ...\n  ...     viewName = 'addSomething.html'\n\nNow we need a security checker for our menu item\n\n  >>> from zope.security.checker import NamesChecker, defineChecker\n  >>> viewletChecker = NamesChecker(('update', 'render'))\n  >>> defineChecker(MyAddMenuItem, viewletChecker)\n\nAnd we configure our menu item for IAddMenu. This is normaly done by the\n``viewlet`` ZCML directive:\n\n  >>> zope.component.provideAdapter(\n  ...     MyAddMenuItem,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...     IBrowserView, IAddMenu),\n  ...     IViewlet, name='My AddMenu')\n\nNow we can update and render our add menu:\n\n  >>> addMenu.update()\n  >>> print(addMenu.render())\n  <li>\n    <a href=\"http://127.0.0.1/site/content/addSomething.html\"><span>My AddMenu</span></a>\n  </li>\n\n\nMenu groups\n-----------\n\nThe global and the site menu items are grouped menu items. This means such menu\nitems should get rendered as selected if a context menu item is selected. This\nreflects the menu hierarchie. Let's show how we can solve this not so simple\nproblem. We offer a ISelectedChecker adapter which can decide if a menu get\nrendered as selected or not. This is very usefull because normaly a menu get\nregistered and later we add views and can not change the menu item\nimplementation. Let's see how such an adapter can handle an existing menu,\ncontext and view setup and change the selected rendering. We register a\nselected checker for our site menu item:\n\n  >>> zope.component.provideAdapter(checker.TrueSelectedChecker,\n  ...     (IContained, IDefaultBrowserLayer, None, ISiteMenu, MySiteMenuItem),\n  ...     interfaces.ISelectedChecker)\n\nNow we can render the site menu again. Note that our context is still the\nsample content object.\n\n  >>> siteMenu.update()\n  >>> print(siteMenu.render())\n  <li class=\"selected\">\n    <a href=\"http://127.0.0.1/site/site.html\"><span>My Site</span></a>\n  </li>\n\nThis reflects that the site menu is a group menu which the context menu item\nof the content object is selected too.\n\n  >>> contextMenu.update()\n  >>> print(contextMenu.render())\n  <li class=\"selected\">\n    <a href=\"http://127.0.0.1/site/content/context.html\"><span>My Context</span></a>\n  </li>\n  <li class=\"inActive\">\n    <a href=\"http://127.0.0.1/site/content/inActive.html\"><span>In Active</span></a>\n  </li>\n\n\nEmptyMenuManager\n----------------\n\nThere is a empty menu manager whihc could be used for override existing\nmenu managers.\n\n  >>> from z3c.menu.ready2go.manager import EmptyMenuManager\n  >>> emptyMenu = EmptyMenuManager(None, None, None)\n\nOur empty menu manager implements ``IMenuManager``:\n\n  >>> interfaces.IMenuManager.providedBy(emptyMenu)\n  True\n\nThis empty menu manager returns allways an empty string if we render them:\n\n  >>> emptyMenu.update()\n  >>> emptyMenu.render()\n  u''\n\n\nSpecial use case\n----------------\n\nWe have some special use case because of Zope's internals. One important part\nis that our menu heavy depend on context and it's __parent__ chain to the\nzope application root. This is not allways supported by Zopes default setup.\nOne part is the bad integrated application control part which fakes a root\nobject which doesn't know about the real childs of the real root from the\nZODB e.g. application root. Now we will show you that our menu by default\nrender no items if we get such a fake root which messes up our menu structure.\n\nLet's define a object which does not know about any __parent__.\n\n  >>> nirvana = Content()\n  >>> nirvanaView = View(nirvana, request)\n\nNow we can check what's happen to the menus if we adapt the parent less nirvana\ncontext and update and render the menus. You can see that the global menu does\nnot contain any menu item. That's because the global menu items tries to find\nthe root by traversing from the context to the root by the __parent__ chain\nand we don't support any parent for our nirvana object:\n\n  >>> globalMenu = GlobalMenu(nirvana, request, nirvanaView)\n  >>> globalMenu.update()\n  >>> globalMenu.render()\n  u''\n\nAlso the SiteMenu doesn't contain any menu item because of the parent less\nobject:\n\n  >>> siteMenu = SiteMenu(nirvana, request, nirvanaView)\n  >>> siteMenu.update()\n  >>> siteMenu.render()\n  u''\n\n  >>> contextMenu = ContextMenu(nirvana, request, nirvanaView)\n  >>> contextMenu.update()\n  >>> contextMenu.render()\n  u''\n\n  >>> addMenu = AddMenu(nirvana, request, nirvanaView)\n  >>> addMenu.update()\n  >>> addMenu.render()\n  u''\n\n\n===================\nZ3C Menu directives\n===================\n\nShow how we can use the menu directive. Register the meta configuration for \nthe directive.\n\nFirst let's setup our defualt menu item template first:\n\n  >>> import os\n  >>> import zope.component\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n  >>> from zope.publisher.interfaces.browser import IBrowserView\n  >>> from z3c.template.interfaces import IContentTemplate\n  >>> from z3c.template.template import TemplateFactory\n  >>> import z3c.menu.ready2go\n  >>> baseDir = os.path.split(z3c.menu.ready2go.__file__)[0]\n  >>> itemTemplate = os.path.join(baseDir, 'item.pt')\n  >>> itemTemplateFactory = TemplateFactory(itemTemplate, 'text/html')\n  >>> zope.component.provideAdapter(itemTemplateFactory,\n  ...     (IBrowserView, IDefaultBrowserLayer), IContentTemplate)\n\n  >>> import sys\n  >>> from zope.configuration import xmlconfig\n  >>> import z3c.menu.ready2go\n  >>> context = xmlconfig.file('meta.zcml', z3c.menu.ready2go)\n\nWe need to register our checker adapter which can check if a menu item is \nselected or not:\n\n  >>> import zope.component\n  >>> from z3c.menu.ready2go import checker\n  >>> zope.component.provideAdapter(checker.ContextSelectedChecker)\n\nLet's define a content object:\n\n  >>> from z3c.menu.ready2go import testing\n  >>> sampleContent = testing.Sample('Sample Content')\n\nNow add the content object to our site root:\n\n  >>> root['sample'] = sampleContent\n\nNow we can define our test menu manager:\n\n  >>> from zope.viewlet.manager import ViewletManager\n  >>> from z3c.menu.ready2go import manager\n  >>> FirstMenu = ViewletManager('left', testing.IFirstMenu,\n  ...     bases=(manager.MenuManager,))\n\n  >>> SecondMenu = ViewletManager('left', testing.ISecondMenu,\n  ...     bases=(manager.MenuManager,))\n\nAnd we need a view which knows about it's parent:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n  >>> firstView = testing.FirstView(sampleContent, request)\n  >>> testing.IFirstView.providedBy(firstView)\n  True\n\n  >>> secondView = testing.SecondView(sampleContent, request)\n  >>> testing.ISecondView.providedBy(secondView)\n  True\n\nAs you can see the menu is not selected if we access the page:\n\n  >>> firstMenu = FirstMenu(sampleContent, request, firstView)\n  >>> testing.IFirstMenu.providedBy(firstMenu)\n  True\n\n  >>> firstMenu.update()\n  >>> firstMenu.render()\n  u''\n\n  >>> secondMenu = SecondMenu(sampleContent, request, secondView)\n  >>> testing.ISecondMenu.providedBy(secondMenu)\n  True\n\n  >>> secondMenu.update()\n  >>> secondMenu.render()\n  u''\n\nNow we need some menu items for the first menu:\n\n  >>> from zope.publisher.interfaces.browser import IBrowserView\n  >>> from zope.publisher.interfaces.browser import IBrowserRequest\n  >>> from zope.viewlet.interfaces import IViewlet\n  >>> zope.component.provideAdapter(\n  ...     testing.FirstMenuItem,\n  ...     (zope.interface.Interface, IBrowserRequest,\n  ...     IBrowserView, testing.IFirstMenu),\n  ...     IViewlet, name='First Menu')\n\n  >>> zope.component.provideAdapter(\n  ...     testing.SecondMenuItem,\n  ...     (zope.interface.Interface, IBrowserRequest,\n  ...     IBrowserView, testing.IFirstMenu),\n  ...     IViewlet, name='Second Menu')\n\nAnd we need some menu items for the second menu:\n\n  >>> zope.component.provideAdapter(\n  ...     testing.FirstMenuItem,\n  ...     (zope.interface.Interface, IBrowserRequest,\n  ...     IBrowserView, testing.ISecondMenu),\n  ...     IViewlet, name='First Menu')\n\n  >>> zope.component.provideAdapter(\n  ...     testing.SecondMenuItem,\n  ...     (zope.interface.Interface, IBrowserRequest,\n  ...     IBrowserView, testing.ISecondMenu),\n  ...     IViewlet, name='Second Menu')\n\nNow render the menu manager again and you can see that we've got some menu\nitems. but you can see that this menu items are not selected:\n\n  >>> firstMenu = FirstMenu(sampleContent, request, firstView)\n  >>> firstMenu.update()\n  >>> print(firstMenu.render())\n  <li>\n    <a><span>First Menu</span></a>\n  </li>\n  <li>\n    <a><span>Second Menu</span></a>\n  </li>\n\n  >>> secondMenu = SecondMenu(sampleContent, request, firstView)\n  >>> secondMenu.update()\n  >>> print(secondMenu.render())\n  <li>\n    <a><span>First Menu</span></a>\n  </li>\n  <li>\n    <a><span>Second Menu</span></a>\n  </li>\n\nNow we can register a menu selector for our page whihc renders the menu\nas selected if we access the page:\n\n  >>> context = xmlconfig.string(\"\"\"\n  ... <configure\n  ...     xmlns:z3c=\"http://namespaces.zope.org/z3c\">\n  ...   <z3c:menuSelector\n  ...       view=\".testing.IFirstView\"\n  ...       manager=\".testing.IFirstMenu\"\n  ...       menu=\".testing.FirstMenuItem\"\n  ...       />\n  ... </configure>\n  ... \"\"\", context)\n\nAfter we registered a menu selector for the first view and first menu, we will\nsee that the first menu get rendered as selected on the first menu:\n\n  >>> firstMenu = FirstMenu(sampleContent, request, firstView)\n  >>> firstMenu.update()\n  >>> print(firstMenu.render())\n  <li class=\"selected\">\n    <a><span>First Menu</span></a>\n  </li>\n  <li>\n    <a><span>Second Menu</span></a>\n  </li>\n\nBut not on the second menu:\n\n  >>> secondMenu = SecondMenu(sampleContent, request, firstView)\n  >>> secondMenu.update()\n  >>> print(secondMenu.render())\n  <li>\n    <a><span>First Menu</span></a>\n  </li>\n  <li>\n    <a><span>Second Menu</span></a>\n  </li>\n\n\n=======\nCHANGES\n=======\n\n1.1.0 (2018-10-09)\n------------------\n\n- Add support for Python 3.7.\n\n- Remove all deprecation warnings.\n\n\n1.0.0 (2017-04-17)\n------------------\n\n- Pin Python support to 2.7, 3.5, 3.6 and PyPy.\n\n\n1.0.0a1 (2013-03-03)\n--------------------\n\n\n- Added support for Python 3.3.\n\n- Changed ``zope.testbrowser`` tests to ``WebTest``, since ``zope.testbrowser``\n  is not yet ported.\n\n- Replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Dropped support for Python 2.4 and 2.5.\n\n\n0.8.0 (2010-07-12)\n------------------\n\n- Replaced `zope.app.pagetemplate` test dependency by\n  `zope.browserpage` as the needed ``metaconfigure.registerType`` has\n  been moved there lately without leaving a BBB import.\n\n\n0.7.1 (2009-12-26)\n------------------\n\n- Removed dependency on ``z3c.i18n`` by declaring the z3c\n  `MessageFactory` locally.\n\n- Using python ``doctest`` module instead of\n  ``zope.testing.doctestunit`` as it deprecated now.\n\n\n0.7.0 (2009-11-30)\n------------------\n\n- Adjust dependencies and imports, to reflect changes in zope packages.\n\n\n0.6.0 (2009-02-07)\n------------------\n\n- Replaced ``zope.app.component`` by ``zope.site``.\n\n- Replaced ``zope.app.container`` by ``zope.container``.\n\n- ``zope.app.pagetemplate`` is only a test dependency.\n\n\n0.5.1 (2009-01-04)\n------------------\n\n- Add support for viewNames that start with ``@@``. They are now\n  processed properly by the ViewNameSelectedChecker.\n\n- Added documentation to Pypi home page.\n\n\n0.5.0 (2008-04-11)\n------------------\n\n- bugfix: fixed cssInActive usage. This was broken and ended in not\n  using the cssInActive CSS class argument\n\n- added more tests, now we have 100% coverage\n\n- make ISiteMenu only available for ISite but not for IContainmentRoot\n\n- make template pluggable with z3c.template pattern\n\n- initial Release", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/z3c.menu.ready2go", "keywords": "zope3 z3c ready 2 go menu", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "z3c.menu.ready2go", "package_url": "https://pypi.org/project/z3c.menu.ready2go/", "platform": "", "project_url": "https://pypi.org/project/z3c.menu.ready2go/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/z3c.menu.ready2go"}, "release_url": "https://pypi.org/project/z3c.menu.ready2go/1.1.0/", "requires_dist": null, "requires_python": "", "summary": "A ready to go menu for Zope3", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides a \u201cready-to-go\u201d menu implementation based on viewlets for\nZope 3.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#ready-2-go-menu\" id=\"id9\" rel=\"nofollow\">Ready 2 go Menu</a><ul>\n<li><a href=\"#global-menu\" id=\"id10\" rel=\"nofollow\">Global Menu</a></li>\n<li><a href=\"#global-menu-item\" id=\"id11\" rel=\"nofollow\">Global Menu Item</a></li>\n<li><a href=\"#site-menu-item\" id=\"id12\" rel=\"nofollow\">Site Menu Item</a></li>\n<li><a href=\"#context-menu-item\" id=\"id13\" rel=\"nofollow\">Context Menu Item</a></li>\n<li><a href=\"#addmenu\" id=\"id14\" rel=\"nofollow\">AddMenu</a></li>\n<li><a href=\"#menu-groups\" id=\"id15\" rel=\"nofollow\">Menu groups</a></li>\n<li><a href=\"#emptymenumanager\" id=\"id16\" rel=\"nofollow\">EmptyMenuManager</a></li>\n<li><a href=\"#special-use-case\" id=\"id17\" rel=\"nofollow\">Special use case</a></li>\n</ul>\n</li>\n<li><a href=\"#z3c-menu-directives\" id=\"id18\" rel=\"nofollow\">Z3C Menu directives</a></li>\n<li><a href=\"#changes\" id=\"id19\" rel=\"nofollow\">CHANGES</a><ul>\n<li><a href=\"#id1\" id=\"id20\" rel=\"nofollow\">1.1.0 (2018-10-09)</a></li>\n<li><a href=\"#id2\" id=\"id21\" rel=\"nofollow\">1.0.0 (2017-04-17)</a></li>\n<li><a href=\"#a1-2013-03-03\" id=\"id22\" rel=\"nofollow\">1.0.0a1 (2013-03-03)</a></li>\n<li><a href=\"#id3\" id=\"id23\" rel=\"nofollow\">0.8.0 (2010-07-12)</a></li>\n<li><a href=\"#id4\" id=\"id24\" rel=\"nofollow\">0.7.1 (2009-12-26)</a></li>\n<li><a href=\"#id5\" id=\"id25\" rel=\"nofollow\">0.7.0 (2009-11-30)</a></li>\n<li><a href=\"#id6\" id=\"id26\" rel=\"nofollow\">0.6.0 (2009-02-07)</a></li>\n<li><a href=\"#id7\" id=\"id27\" rel=\"nofollow\">0.5.1 (2009-01-04)</a></li>\n<li><a href=\"#id8\" id=\"id28\" rel=\"nofollow\">0.5.0 (2008-04-11)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"ready-2-go-menu\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Ready 2 go Menu</a></h2>\n<p>The z3c.menu.ready2go package provides a menu implementation which allows you\nto implement menus based on content providers and viewlets.</p>\n<p>First let\u2019s setup our defualt menu item template:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserView\n&gt;&gt;&gt; from z3c.template.interfaces import IContentTemplate\n&gt;&gt;&gt; from z3c.template.template import TemplateFactory\n&gt;&gt;&gt; import z3c.menu.ready2go\n&gt;&gt;&gt; baseDir = os.path.split(z3c.menu.ready2go.__file__)[0]\n&gt;&gt;&gt; itemTemplate = os.path.join(baseDir, 'item.pt')\n&gt;&gt;&gt; itemTemplateFactory = TemplateFactory(itemTemplate, 'text/html')\n&gt;&gt;&gt; zope.component.provideAdapter(itemTemplateFactory,\n...     (IBrowserView, IDefaultBrowserLayer), IContentTemplate)\n</pre>\n</blockquote>\n<div id=\"global-menu\">\n<h3><a href=\"#id10\" rel=\"nofollow\">Global Menu</a></h3>\n<p>Let\u2019s create some menu and register them as viewlet manager:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.viewlet.interfaces import IViewlet\n&gt;&gt;&gt; from zope.viewlet import manager\n&gt;&gt;&gt; from z3c.menu.ready2go import interfaces\n&gt;&gt;&gt; from z3c.menu.ready2go import IGlobalMenu\n&gt;&gt;&gt; from z3c.menu.ready2go import ISiteMenu\n&gt;&gt;&gt; from z3c.menu.ready2go import IContextMenu\n&gt;&gt;&gt; from z3c.menu.ready2go import IAddMenu\n&gt;&gt;&gt; from z3c.menu.ready2go.manager import MenuManager\n</pre>\n</blockquote>\n<p>And we configure our menu item as viewlet Managers. This is normaly done by the\n<tt>viewletManager</tt> ZCML directive:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; GlobalMenu = manager.ViewletManager('left', IGlobalMenu,\n...     bases=(MenuManager,))\n</pre>\n<pre>&gt;&gt;&gt; SiteMenu = manager.ViewletManager('left', ISiteMenu,\n...     bases=(MenuManager,))\n</pre>\n<pre>&gt;&gt;&gt; ContextMenu = manager.ViewletManager('left', IContextMenu,\n...     bases=(MenuManager,))\n</pre>\n<pre>&gt;&gt;&gt; AddMenu = manager.ViewletManager('left', IAddMenu,\n...     bases=(MenuManager,))\n</pre>\n</blockquote>\n<p>Our menu managers implement IMenuManager:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interfaces.IMenuManager.implementedBy(GlobalMenu)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; interfaces.IMenuManager.implementedBy(SiteMenu)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; interfaces.IMenuManager.implementedBy(ContextMenu)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; interfaces.IMenuManager.implementedBy(AddMenu)\nTrue\n</pre>\n</blockquote>\n<p>We also need our checker adapter which can check if a menu item is available\nand/or selected:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.menu.ready2go import checker\n&gt;&gt;&gt; zope.component.provideAdapter(checker.GlobalSelectedChecker)\n&gt;&gt;&gt; zope.component.provideAdapter(checker.SiteSelectedChecker)\n&gt;&gt;&gt; zope.component.provideAdapter(checker.ContextSelectedChecker)\n</pre>\n</blockquote>\n<p>Now we have to define a site and a context:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; from zope.container import contained, btree\n&gt;&gt;&gt; from zope.container.interfaces import IContained\n&gt;&gt;&gt; from zope.component.interfaces import IPossibleSite\n&gt;&gt;&gt; from zope.site.site import SiteManagerContainer\n&gt;&gt;&gt; from zope.site.site import LocalSiteManager\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IPossibleSite)\n... class Site(btree.BTreeContainer, SiteManagerContainer):\n...     def __init__(self):\n...         super(Site, self).__init__()\n...         self.setSiteManager(LocalSiteManager(self))\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IContained)\n... class Content(contained.Contained):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; root['site'] = Site()\n&gt;&gt;&gt; site = root['site']\n</pre>\n</blockquote>\n<p>Now we have to set the site object as site. This is normaly done by the\ntraverser but we do this here with the hooks helper because we do not really\ntraaverse to the site within the publisher/traverser:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.component import hooks\n&gt;&gt;&gt; hooks.setSite(site)\n</pre>\n<pre>&gt;&gt;&gt; site['content'] = Content()\n&gt;&gt;&gt; content = site['content']\n</pre>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n<p>And we need a view which knows about it\u2019s parent:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IBrowserView)\n... class View(contained.Contained):\n...\n...     def __init__(self, context, request):\n...         self.__parent__ = context\n...         self.context = context\n...         self.request = request\n</pre>\n<pre>&gt;&gt;&gt; view = View(content, request)\n</pre>\n</blockquote>\n<p>Our menus can adapt the context, request and view. See IViewletManager in\nzope.viewlet for more infos about this pattern. If we render them, there is an\nempty string returned. This means the menus don\u2019t find menu items for rendering:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; globalMenu = GlobalMenu(content, request, view)\n&gt;&gt;&gt; globalMenu.update()\n&gt;&gt;&gt; globalMenu.render()\nu''\n</pre>\n<pre>&gt;&gt;&gt; siteMenu = SiteMenu(content, request, view)\n&gt;&gt;&gt; siteMenu.update()\n&gt;&gt;&gt; siteMenu.render()\nu''\n</pre>\n<pre>&gt;&gt;&gt; contextMenu = ContextMenu(content, request, view)\n&gt;&gt;&gt; contextMenu.update()\n&gt;&gt;&gt; contextMenu.render()\nu''\n</pre>\n<pre>&gt;&gt;&gt; addMenu = AddMenu(content, request, view)\n&gt;&gt;&gt; addMenu.update()\n&gt;&gt;&gt; addMenu.render()\nu''\n</pre>\n</blockquote>\n</div>\n<div id=\"global-menu-item\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Global Menu Item</a></h3>\n<p>Now we register a context menu item for our IGlobalMenu:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.menu.ready2go.item import GlobalMenuItem\n&gt;&gt;&gt; class MyGlobalMenuItem(GlobalMenuItem):\n...\n...     viewName = 'root.html'\n</pre>\n</blockquote>\n<p>Now we need a security checker for our menu item</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.security.checker import NamesChecker, defineChecker\n&gt;&gt;&gt; viewletChecker = NamesChecker(('update', 'render'))\n&gt;&gt;&gt; defineChecker(MyGlobalMenuItem, viewletChecker)\n</pre>\n</blockquote>\n<p>And we configure our menu item for IGlobalMenu. This is normaly done by the\n<tt>viewlet</tt> ZCML directive:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     MyGlobalMenuItem,\n...     (zope.interface.Interface, IDefaultBrowserLayer,\n...     IBrowserView, IGlobalMenu),\n...     IViewlet, name='My Global')\n</pre>\n</blockquote>\n<p>Now let\u2019s update the menu manager and see that this manager now contains\nthe menu item:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; globalMenu.update()\n&gt;&gt;&gt; myGlobalMenuItem = globalMenu.viewlets[0]\n&gt;&gt;&gt; myGlobalMenuItem\n&lt;MyGlobalMenuItem u'My Global'&gt;\n</pre>\n</blockquote>\n<p>Now let\u2019s render the global menu manager and you can see that the menu item\nget rendered:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(globalMenu.render())\n&lt;li&gt;\n  &lt;a href=\"http://127.0.0.1/root.html\"&gt;&lt;span&gt;My Global&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"site-menu-item\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Site Menu Item</a></h3>\n<p>Now we register a context menu item for our ISiteMenu:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n</pre>\n<pre>&gt;&gt;&gt; from z3c.menu.ready2go.item import SiteMenuItem\n&gt;&gt;&gt; class MySiteMenuItem(SiteMenuItem):\n...\n...     viewName = 'site.html'\n</pre>\n</blockquote>\n<p>Now we need a security checker for our menu item</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.security.checker import NamesChecker, defineChecker\n&gt;&gt;&gt; viewletChecker = NamesChecker(('update', 'render'))\n&gt;&gt;&gt; defineChecker(MySiteMenuItem, viewletChecker)\n</pre>\n</blockquote>\n<p>And we configure our menu item for ISiteMenu. This is normaly done by the\n<tt>viewlet</tt> ZCML directive:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     MySiteMenuItem,\n...     (zope.interface.Interface, IDefaultBrowserLayer,\n...     IBrowserView, ISiteMenu),\n...     IViewlet, name='My Site')\n</pre>\n</blockquote>\n<p>Now let\u2019s render the site menu again. You can see that we ve got a menu item\nand the url points to our site:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; siteMenu.update()\n&gt;&gt;&gt; print(siteMenu.render())\n&lt;li&gt;\n  &lt;a href=\"http://127.0.0.1/site/site.html\"&gt;&lt;span&gt;My Site&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"context-menu-item\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Context Menu Item</a></h3>\n<p>Now we register a context menu item for our IContextMenu:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n</pre>\n<pre>&gt;&gt;&gt; from z3c.menu.ready2go.item import ContextMenuItem\n&gt;&gt;&gt; class MyContextMenuItem(ContextMenuItem):\n...     viewName = 'context.html'\n...     weight = 1\n</pre>\n</blockquote>\n<p>Now we need a security checker for our menu item</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.security.checker import NamesChecker, defineChecker\n&gt;&gt;&gt; viewletChecker = NamesChecker(('update', 'render'))\n&gt;&gt;&gt; defineChecker(MyContextMenuItem, viewletChecker)\n</pre>\n</blockquote>\n<p>And we configure our menu item for IContextMenu. This is normaly done by the\n<tt>viewlet</tt> ZCML directive:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     MyContextMenuItem,\n...     (zope.interface.Interface, IDefaultBrowserLayer,\n...     IBrowserView, IContextMenu),\n...     IViewlet, name='My Context')\n</pre>\n</blockquote>\n<p>Now let\u2019s render the context menu again. You can see that we ve got a menu\nitem. Another important point here is, that the url of such ContextMemuItem\nimplementations point to the context of the view:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; contextMenu.update()\n&gt;&gt;&gt; print(contextMenu.render())\n&lt;li&gt;\n  &lt;a href=\"http://127.0.0.1/site/content/context.html\"&gt;&lt;span&gt;My Context&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n<p>Let\u2019s set the view  __name__ to <tt>context.html</tt>. This will reflect that\nthe view offers the same name that our context menu needs to get rendered as\nselected:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view.__name__ = 'context.html'\n</pre>\n</blockquote>\n<p>Now try again and see if the context menu item get rendered as selected:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; contextMenu.update()\n&gt;&gt;&gt; print(contextMenu.render())\n&lt;li class=\"selected\"&gt;\n  &lt;a href=\"http://127.0.0.1/site/content/context.html\"&gt;&lt;span&gt;My Context&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n<p>Also, let\u2019s check that menu item is marked selected even if we provided a viewName in\nthe <tt>@@context.html</tt> form:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; MyContextMenuItem.viewName = '@@context.html'\n&gt;&gt;&gt; contextMenu.update()\n&gt;&gt;&gt; print(contextMenu.render())\n&lt;li class=\"selected\"&gt;\n  &lt;a href=\"http://127.0.0.1/site/content/@@context.html\"&gt;&lt;span&gt;My Context&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n<p>Okay, change viewName back to <tt>context.html</tt> for further tests:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; MyContextMenuItem.viewName = 'context.html'\n</pre>\n</blockquote>\n<p>Now add a second context menu item and check if we can use the cssInActive\nargument which is normaly a empty string:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class InActiveMenuItem(ContextMenuItem):\n...     viewName = 'inActive.html'\n...     cssInActive = 'inActive'\n...     weight = 2\n</pre>\n<pre>&gt;&gt;&gt; defineChecker(InActiveMenuItem, viewletChecker)\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     InActiveMenuItem,\n...     (zope.interface.Interface, IDefaultBrowserLayer,\n...     IBrowserView, IContextMenu),\n...     IViewlet, name='In Active')\n</pre>\n</blockquote>\n<p>Now update and render again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; contextMenu.update()\n&gt;&gt;&gt; print(contextMenu.render())\n&lt;li class=\"selected\"&gt;\n  &lt;a href=\"http://127.0.0.1/site/content/context.html\"&gt;&lt;span&gt;My Context&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n&lt;li class=\"inActive\"&gt;\n  &lt;a href=\"http://127.0.0.1/site/content/inActive.html\"&gt;&lt;span&gt;In Active&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"addmenu\">\n<h3><a href=\"#id14\" rel=\"nofollow\">AddMenu</a></h3>\n<p>The add menu can be used for offering links to any kind of add forms per\ncontext. This allows us to offer independent add form links doesn\u2019t matter which\nform framework is used. Let\u2019s now define such a simple AddMenuItem pointing\nto a add form url. Not; the add form and it\u2019s url do not exist in thsi test.\nThis aslo means there is no guarantee that a form exist if a add menu item\nis configured.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.menu.ready2go.item import AddMenuItem\n&gt;&gt;&gt; class MyAddMenuItem(AddMenuItem):\n...\n...     viewName = 'addSomething.html'\n</pre>\n</blockquote>\n<p>Now we need a security checker for our menu item</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.security.checker import NamesChecker, defineChecker\n&gt;&gt;&gt; viewletChecker = NamesChecker(('update', 'render'))\n&gt;&gt;&gt; defineChecker(MyAddMenuItem, viewletChecker)\n</pre>\n</blockquote>\n<p>And we configure our menu item for IAddMenu. This is normaly done by the\n<tt>viewlet</tt> ZCML directive:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     MyAddMenuItem,\n...     (zope.interface.Interface, IDefaultBrowserLayer,\n...     IBrowserView, IAddMenu),\n...     IViewlet, name='My AddMenu')\n</pre>\n</blockquote>\n<p>Now we can update and render our add menu:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; addMenu.update()\n&gt;&gt;&gt; print(addMenu.render())\n&lt;li&gt;\n  &lt;a href=\"http://127.0.0.1/site/content/addSomething.html\"&gt;&lt;span&gt;My AddMenu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"menu-groups\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Menu groups</a></h3>\n<p>The global and the site menu items are grouped menu items. This means such menu\nitems should get rendered as selected if a context menu item is selected. This\nreflects the menu hierarchie. Let\u2019s show how we can solve this not so simple\nproblem. We offer a ISelectedChecker adapter which can decide if a menu get\nrendered as selected or not. This is very usefull because normaly a menu get\nregistered and later we add views and can not change the menu item\nimplementation. Let\u2019s see how such an adapter can handle an existing menu,\ncontext and view setup and change the selected rendering. We register a\nselected checker for our site menu item:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(checker.TrueSelectedChecker,\n...     (IContained, IDefaultBrowserLayer, None, ISiteMenu, MySiteMenuItem),\n...     interfaces.ISelectedChecker)\n</pre>\n</blockquote>\n<p>Now we can render the site menu again. Note that our context is still the\nsample content object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; siteMenu.update()\n&gt;&gt;&gt; print(siteMenu.render())\n&lt;li class=\"selected\"&gt;\n  &lt;a href=\"http://127.0.0.1/site/site.html\"&gt;&lt;span&gt;My Site&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n<p>This reflects that the site menu is a group menu which the context menu item\nof the content object is selected too.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; contextMenu.update()\n&gt;&gt;&gt; print(contextMenu.render())\n&lt;li class=\"selected\"&gt;\n  &lt;a href=\"http://127.0.0.1/site/content/context.html\"&gt;&lt;span&gt;My Context&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n&lt;li class=\"inActive\"&gt;\n  &lt;a href=\"http://127.0.0.1/site/content/inActive.html\"&gt;&lt;span&gt;In Active&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"emptymenumanager\">\n<h3><a href=\"#id16\" rel=\"nofollow\">EmptyMenuManager</a></h3>\n<p>There is a empty menu manager whihc could be used for override existing\nmenu managers.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.menu.ready2go.manager import EmptyMenuManager\n&gt;&gt;&gt; emptyMenu = EmptyMenuManager(None, None, None)\n</pre>\n</blockquote>\n<p>Our empty menu manager implements <tt>IMenuManager</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interfaces.IMenuManager.providedBy(emptyMenu)\nTrue\n</pre>\n</blockquote>\n<p>This empty menu manager returns allways an empty string if we render them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; emptyMenu.update()\n&gt;&gt;&gt; emptyMenu.render()\nu''\n</pre>\n</blockquote>\n</div>\n<div id=\"special-use-case\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Special use case</a></h3>\n<p>We have some special use case because of Zope\u2019s internals. One important part\nis that our menu heavy depend on context and it\u2019s __parent__ chain to the\nzope application root. This is not allways supported by Zopes default setup.\nOne part is the bad integrated application control part which fakes a root\nobject which doesn\u2019t know about the real childs of the real root from the\nZODB e.g. application root. Now we will show you that our menu by default\nrender no items if we get such a fake root which messes up our menu structure.</p>\n<p>Let\u2019s define a object which does not know about any __parent__.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; nirvana = Content()\n&gt;&gt;&gt; nirvanaView = View(nirvana, request)\n</pre>\n</blockquote>\n<p>Now we can check what\u2019s happen to the menus if we adapt the parent less nirvana\ncontext and update and render the menus. You can see that the global menu does\nnot contain any menu item. That\u2019s because the global menu items tries to find\nthe root by traversing from the context to the root by the __parent__ chain\nand we don\u2019t support any parent for our nirvana object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; globalMenu = GlobalMenu(nirvana, request, nirvanaView)\n&gt;&gt;&gt; globalMenu.update()\n&gt;&gt;&gt; globalMenu.render()\nu''\n</pre>\n</blockquote>\n<p>Also the SiteMenu doesn\u2019t contain any menu item because of the parent less\nobject:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; siteMenu = SiteMenu(nirvana, request, nirvanaView)\n&gt;&gt;&gt; siteMenu.update()\n&gt;&gt;&gt; siteMenu.render()\nu''\n</pre>\n<pre>&gt;&gt;&gt; contextMenu = ContextMenu(nirvana, request, nirvanaView)\n&gt;&gt;&gt; contextMenu.update()\n&gt;&gt;&gt; contextMenu.render()\nu''\n</pre>\n<pre>&gt;&gt;&gt; addMenu = AddMenu(nirvana, request, nirvanaView)\n&gt;&gt;&gt; addMenu.update()\n&gt;&gt;&gt; addMenu.render()\nu''\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"z3c-menu-directives\">\n<h2><a href=\"#id18\" rel=\"nofollow\">Z3C Menu directives</a></h2>\n<p>Show how we can use the menu directive. Register the meta configuration for\nthe directive.</p>\n<p>First let\u2019s setup our defualt menu item template first:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserView\n&gt;&gt;&gt; from z3c.template.interfaces import IContentTemplate\n&gt;&gt;&gt; from z3c.template.template import TemplateFactory\n&gt;&gt;&gt; import z3c.menu.ready2go\n&gt;&gt;&gt; baseDir = os.path.split(z3c.menu.ready2go.__file__)[0]\n&gt;&gt;&gt; itemTemplate = os.path.join(baseDir, 'item.pt')\n&gt;&gt;&gt; itemTemplateFactory = TemplateFactory(itemTemplate, 'text/html')\n&gt;&gt;&gt; zope.component.provideAdapter(itemTemplateFactory,\n...     (IBrowserView, IDefaultBrowserLayer), IContentTemplate)\n</pre>\n<pre>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; from zope.configuration import xmlconfig\n&gt;&gt;&gt; import z3c.menu.ready2go\n&gt;&gt;&gt; context = xmlconfig.file('meta.zcml', z3c.menu.ready2go)\n</pre>\n</blockquote>\n<p>We need to register our checker adapter which can check if a menu item is\nselected or not:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from z3c.menu.ready2go import checker\n&gt;&gt;&gt; zope.component.provideAdapter(checker.ContextSelectedChecker)\n</pre>\n</blockquote>\n<p>Let\u2019s define a content object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.menu.ready2go import testing\n&gt;&gt;&gt; sampleContent = testing.Sample('Sample Content')\n</pre>\n</blockquote>\n<p>Now add the content object to our site root:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; root['sample'] = sampleContent\n</pre>\n</blockquote>\n<p>Now we can define our test menu manager:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.viewlet.manager import ViewletManager\n&gt;&gt;&gt; from z3c.menu.ready2go import manager\n&gt;&gt;&gt; FirstMenu = ViewletManager('left', testing.IFirstMenu,\n...     bases=(manager.MenuManager,))\n</pre>\n<pre>&gt;&gt;&gt; SecondMenu = ViewletManager('left', testing.ISecondMenu,\n...     bases=(manager.MenuManager,))\n</pre>\n</blockquote>\n<p>And we need a view which knows about it\u2019s parent:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; firstView = testing.FirstView(sampleContent, request)\n&gt;&gt;&gt; testing.IFirstView.providedBy(firstView)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; secondView = testing.SecondView(sampleContent, request)\n&gt;&gt;&gt; testing.ISecondView.providedBy(secondView)\nTrue\n</pre>\n</blockquote>\n<p>As you can see the menu is not selected if we access the page:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; firstMenu = FirstMenu(sampleContent, request, firstView)\n&gt;&gt;&gt; testing.IFirstMenu.providedBy(firstMenu)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; firstMenu.update()\n&gt;&gt;&gt; firstMenu.render()\nu''\n</pre>\n<pre>&gt;&gt;&gt; secondMenu = SecondMenu(sampleContent, request, secondView)\n&gt;&gt;&gt; testing.ISecondMenu.providedBy(secondMenu)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; secondMenu.update()\n&gt;&gt;&gt; secondMenu.render()\nu''\n</pre>\n</blockquote>\n<p>Now we need some menu items for the first menu:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserView\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserRequest\n&gt;&gt;&gt; from zope.viewlet.interfaces import IViewlet\n&gt;&gt;&gt; zope.component.provideAdapter(\n...     testing.FirstMenuItem,\n...     (zope.interface.Interface, IBrowserRequest,\n...     IBrowserView, testing.IFirstMenu),\n...     IViewlet, name='First Menu')\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     testing.SecondMenuItem,\n...     (zope.interface.Interface, IBrowserRequest,\n...     IBrowserView, testing.IFirstMenu),\n...     IViewlet, name='Second Menu')\n</pre>\n</blockquote>\n<p>And we need some menu items for the second menu:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     testing.FirstMenuItem,\n...     (zope.interface.Interface, IBrowserRequest,\n...     IBrowserView, testing.ISecondMenu),\n...     IViewlet, name='First Menu')\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     testing.SecondMenuItem,\n...     (zope.interface.Interface, IBrowserRequest,\n...     IBrowserView, testing.ISecondMenu),\n...     IViewlet, name='Second Menu')\n</pre>\n</blockquote>\n<p>Now render the menu manager again and you can see that we\u2019ve got some menu\nitems. but you can see that this menu items are not selected:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; firstMenu = FirstMenu(sampleContent, request, firstView)\n&gt;&gt;&gt; firstMenu.update()\n&gt;&gt;&gt; print(firstMenu.render())\n&lt;li&gt;\n  &lt;a&gt;&lt;span&gt;First Menu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n&lt;li&gt;\n  &lt;a&gt;&lt;span&gt;Second Menu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n<pre>&gt;&gt;&gt; secondMenu = SecondMenu(sampleContent, request, firstView)\n&gt;&gt;&gt; secondMenu.update()\n&gt;&gt;&gt; print(secondMenu.render())\n&lt;li&gt;\n  &lt;a&gt;&lt;span&gt;First Menu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n&lt;li&gt;\n  &lt;a&gt;&lt;span&gt;Second Menu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n<p>Now we can register a menu selector for our page whihc renders the menu\nas selected if we access the page:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; context = xmlconfig.string(\"\"\"\n... &lt;configure\n...     xmlns:z3c=\"http://namespaces.zope.org/z3c\"&gt;\n...   &lt;z3c:menuSelector\n...       view=\".testing.IFirstView\"\n...       manager=\".testing.IFirstMenu\"\n...       menu=\".testing.FirstMenuItem\"\n...       /&gt;\n... &lt;/configure&gt;\n... \"\"\", context)\n</pre>\n</blockquote>\n<p>After we registered a menu selector for the first view and first menu, we will\nsee that the first menu get rendered as selected on the first menu:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; firstMenu = FirstMenu(sampleContent, request, firstView)\n&gt;&gt;&gt; firstMenu.update()\n&gt;&gt;&gt; print(firstMenu.render())\n&lt;li class=\"selected\"&gt;\n  &lt;a&gt;&lt;span&gt;First Menu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n&lt;li&gt;\n  &lt;a&gt;&lt;span&gt;Second Menu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n<p>But not on the second menu:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; secondMenu = SecondMenu(sampleContent, request, firstView)\n&gt;&gt;&gt; secondMenu.update()\n&gt;&gt;&gt; print(secondMenu.render())\n&lt;li&gt;\n  &lt;a&gt;&lt;span&gt;First Menu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n&lt;li&gt;\n  &lt;a&gt;&lt;span&gt;Second Menu&lt;/span&gt;&lt;/a&gt;\n&lt;/li&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id19\" rel=\"nofollow\">CHANGES</a></h2>\n<div id=\"id1\">\n<h3><a href=\"#id20\" rel=\"nofollow\">1.1.0 (2018-10-09)</a></h3>\n<ul>\n<li>Add support for Python 3.7.</li>\n<li>Remove all deprecation warnings.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id21\" rel=\"nofollow\">1.0.0 (2017-04-17)</a></h3>\n<ul>\n<li>Pin Python support to 2.7, 3.5, 3.6 and PyPy.</li>\n</ul>\n</div>\n<div id=\"a1-2013-03-03\">\n<h3><a href=\"#id22\" rel=\"nofollow\">1.0.0a1 (2013-03-03)</a></h3>\n<ul>\n<li>Added support for Python 3.3.</li>\n<li>Changed <tt>zope.testbrowser</tt> tests to <tt>WebTest</tt>, since <tt>zope.testbrowser</tt>\nis not yet ported.</li>\n<li>Replaced deprecated <tt>zope.interface.implements</tt> usage with equivalent\n<tt>zope.interface.implementer</tt> decorator.</li>\n<li>Dropped support for Python 2.4 and 2.5.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id23\" rel=\"nofollow\">0.8.0 (2010-07-12)</a></h3>\n<ul>\n<li>Replaced <cite>zope.app.pagetemplate</cite> test dependency by\n<cite>zope.browserpage</cite> as the needed <tt>metaconfigure.registerType</tt> has\nbeen moved there lately without leaving a BBB import.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id24\" rel=\"nofollow\">0.7.1 (2009-12-26)</a></h3>\n<ul>\n<li>Removed dependency on <tt>z3c.i18n</tt> by declaring the z3c\n<cite>MessageFactory</cite> locally.</li>\n<li>Using python <tt>doctest</tt> module instead of\n<tt>zope.testing.doctestunit</tt> as it deprecated now.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id25\" rel=\"nofollow\">0.7.0 (2009-11-30)</a></h3>\n<ul>\n<li>Adjust dependencies and imports, to reflect changes in zope packages.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id26\" rel=\"nofollow\">0.6.0 (2009-02-07)</a></h3>\n<ul>\n<li>Replaced <tt>zope.app.component</tt> by <tt>zope.site</tt>.</li>\n<li>Replaced <tt>zope.app.container</tt> by <tt>zope.container</tt>.</li>\n<li><tt>zope.app.pagetemplate</tt> is only a test dependency.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id27\" rel=\"nofollow\">0.5.1 (2009-01-04)</a></h3>\n<ul>\n<li>Add support for viewNames that start with <tt>@@</tt>. They are now\nprocessed properly by the ViewNameSelectedChecker.</li>\n<li>Added documentation to Pypi home page.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id28\" rel=\"nofollow\">0.5.0 (2008-04-11)</a></h3>\n<ul>\n<li>bugfix: fixed cssInActive usage. This was broken and ended in not\nusing the cssInActive CSS class argument</li>\n<li>added more tests, now we have 100% coverage</li>\n<li>make ISiteMenu only available for ISite but not for IContainmentRoot</li>\n<li>make template pluggable with z3c.template pattern</li>\n<li>initial Release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4357413, "releases": {"0.5.0": [{"comment_text": "", "digests": {"md5": "7da0ad194ea7dfe28d8dae14f13afd3f", "sha256": "447566af1a5db76071e58a1103c8c4a0570dd02d8553d244b4a2cbc9653bdf43"}, "downloads": -1, "filename": "z3c.menu.ready2go-0.5.0.zip", "has_sig": false, "md5_digest": "7da0ad194ea7dfe28d8dae14f13afd3f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25643, "upload_time": "2008-04-11T12:56:48", "upload_time_iso_8601": "2008-04-11T12:56:48Z", "url": "https://files.pythonhosted.org/packages/40/3c/646f21f8bd3dc014e60ada58e0b7f31149a48de59979b81bdd9fcc4d69b4/z3c.menu.ready2go-0.5.0.zip", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "c0a4f2326f052450ff19dce0261b5dbd", "sha256": "24aef8062345ce1ee525387a5895326e86ed4fd679cc679f543c091cb07c53dc"}, "downloads": -1, "filename": "z3c.menu.ready2go-0.5.1.tar.gz", "has_sig": false, "md5_digest": "c0a4f2326f052450ff19dce0261b5dbd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22935, "upload_time": "2009-01-04T20:59:22", "upload_time_iso_8601": "2009-01-04T20:59:22Z", "url": "https://files.pythonhosted.org/packages/3d/4d/29b51bc8d69d0a203b7238617d523ec2704272b508c76d6ff1ea6086e98f/z3c.menu.ready2go-0.5.1.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "8481ec113d9b2f3e4f8892cbe92ee2e0", "sha256": "61e52404b68b77e6ae59ffaa76ccafd025eda5268a784d31292cb37e7a1d57bd"}, "downloads": -1, "filename": "z3c.menu.ready2go-0.6.0.tar.gz", "has_sig": false, "md5_digest": "8481ec113d9b2f3e4f8892cbe92ee2e0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23078, "upload_time": "2009-02-07T15:24:08", "upload_time_iso_8601": "2009-02-07T15:24:08Z", "url": "https://files.pythonhosted.org/packages/5a/ca/73f83f3358f5e12455d32f530585240cd093009d34d6c1461e6cc26b8c5a/z3c.menu.ready2go-0.6.0.tar.gz", "yanked": false}], "0.7.0": [{"comment_text": "", "digests": {"md5": "593eb88ec161484f702b7684788f6e69", "sha256": "13adf1b0c514187beac892e198fc4b0dc2b4c4312d13219e693decf15e942233"}, "downloads": -1, "filename": "z3c.menu.ready2go-0.7.0.zip", "has_sig": false, "md5_digest": "593eb88ec161484f702b7684788f6e69", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36492, "upload_time": "2009-11-30T23:08:35", "upload_time_iso_8601": "2009-11-30T23:08:35.479176Z", "url": "https://files.pythonhosted.org/packages/b3/c5/e928d39c1a935181b9f6312ee96274239e081bce74490bdf33a16b7c8a56/z3c.menu.ready2go-0.7.0.zip", "yanked": false}], "0.7.1": [{"comment_text": "", "digests": {"md5": "38241e099c4e994f0a51ab3f7f2ea077", "sha256": "a2701e6457dcb735c74c2951efa6bb74d425ab6241ecf050489d4b4582da00ca"}, "downloads": -1, "filename": "z3c.menu.ready2go-0.7.1.tar.gz", "has_sig": false, "md5_digest": "38241e099c4e994f0a51ab3f7f2ea077", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23450, "upload_time": "2009-12-26T13:06:34", "upload_time_iso_8601": "2009-12-26T13:06:34.500318Z", "url": "https://files.pythonhosted.org/packages/a7/f0/1e81d1cbcb775564047104b83ecd65f750975793fccd161c079c5ffa36d6/z3c.menu.ready2go-0.7.1.tar.gz", "yanked": false}], "0.8.0": [{"comment_text": "", "digests": {"md5": "25347fe98c73d75588199d3d42f4487a", "sha256": "e4904916718e62b6808f6a22237a41d71f8da8b1c4bb1ec6974f8fefc6f39f6e"}, "downloads": -1, "filename": "z3c.menu.ready2go-0.8.0.tar.gz", "has_sig": false, "md5_digest": "25347fe98c73d75588199d3d42f4487a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23637, "upload_time": "2010-07-12T09:15:44", "upload_time_iso_8601": "2010-07-12T09:15:44.720246Z", "url": "https://files.pythonhosted.org/packages/cf/cd/25863167886041283770d18772587665fb9cb2656896a4a426a1f790747b/z3c.menu.ready2go-0.8.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "272be174fe7fd70969f9361c3e916022", "sha256": "fb0a7e3e4692f79996ecf3ac9f9342156e6761fce9343e4c371d6c1396b31897"}, "downloads": -1, "filename": "z3c.menu.ready2go-1.0.0.tar.gz", "has_sig": false, "md5_digest": "272be174fe7fd70969f9361c3e916022", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26447, "upload_time": "2017-04-17T19:58:33", "upload_time_iso_8601": "2017-04-17T19:58:33.502580Z", "url": "https://files.pythonhosted.org/packages/54/3c/4c0c52875fab98728047696d5c89ca26fe27f20074d40b2295f4e089c492/z3c.menu.ready2go-1.0.0.tar.gz", "yanked": false}], "1.0.0a1": [{"comment_text": "", "digests": {"md5": "eacda4d77231bb960b61a091e086f639", "sha256": "a26cf7d1bf086f5b0fdeaa834f9a5ae08afdc7cdd80812dae3a31a79143eaa83"}, "downloads": -1, "filename": "z3c.menu.ready2go-1.0.0a1.zip", "has_sig": false, "md5_digest": "eacda4d77231bb960b61a091e086f639", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40595, "upload_time": "2013-03-04T04:15:23", "upload_time_iso_8601": "2013-03-04T04:15:23.495765Z", "url": "https://files.pythonhosted.org/packages/e5/95/10ddbf04a2263749282647202238bdfd9893de624613f0a995b2a73d3983/z3c.menu.ready2go-1.0.0a1.zip", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "ad0ee607b2d6be8b7947ccf62f62533f", "sha256": "fabd55ed7452ab2fa3604bd2ee78c430fdb2399d0d8f8534fbd00c52ea48ccdf"}, "downloads": -1, "filename": "z3c.menu.ready2go-1.1.0.tar.gz", "has_sig": false, "md5_digest": "ad0ee607b2d6be8b7947ccf62f62533f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26784, "upload_time": "2018-10-09T20:29:37", "upload_time_iso_8601": "2018-10-09T20:29:37.079276Z", "url": "https://files.pythonhosted.org/packages/3a/55/665bead8473c971633c326468aa108a84df536647b84974623a11fb66faf/z3c.menu.ready2go-1.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ad0ee607b2d6be8b7947ccf62f62533f", "sha256": "fabd55ed7452ab2fa3604bd2ee78c430fdb2399d0d8f8534fbd00c52ea48ccdf"}, "downloads": -1, "filename": "z3c.menu.ready2go-1.1.0.tar.gz", "has_sig": false, "md5_digest": "ad0ee607b2d6be8b7947ccf62f62533f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26784, "upload_time": "2018-10-09T20:29:37", "upload_time_iso_8601": "2018-10-09T20:29:37.079276Z", "url": "https://files.pythonhosted.org/packages/3a/55/665bead8473c971633c326468aa108a84df536647b84974623a11fb66faf/z3c.menu.ready2go-1.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:54 2020"}