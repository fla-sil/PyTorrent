{"info": {"author": "Ben Reynwar", "author_email": "ben@reynwar.net", "bugtrack_url": null, "classifiers": [], "description": ".. image:: https://travis-ci.org/benreynwar/axilent.svg?branch=master\n               :target: https://travis-ci.org/benreynwar/axilent\n\naxilent\n=======\n\naxilent provides python tools for describing a sequence of Axi4Lite command\nin python.\n\nA python test can be written describing the sequence of commands to be sent\nand the expected responses.  This test can then be run against both a\nsimulation of the design and against the implemented design running on an\nFPGA.\n\naxilent is structured so that tests can be run both against both interactive\nsimulations and simulations where inputs cannot depend on outputs such as\nfile-based testbenchs.\n\n\nHandlers\n--------\n\nCurrently there is `handler` for working with file-based testbenchs\ngenerated by `slvcodec <https://github.com/benreynwar/slvcodec>`_ and\nfor simulations on FPGAs run over JTAG using\n`pyvivado <https://github.com/benreynwar/pyvivado>`_.\nIn the likely event you are using neither of these methods, then you\nwill have to write you own handler. The handler has a single required\nmethod.\n\nhandler.send(command)\n    Sends a command to the FPGA, or adds the command to the list of commands that\n    will be run in the simulation.\n\nThe handler also processes the responses from the simulation or FPGA and updates the\n`command.future` values appropriately.  It calls the `command.process_responses` method\nto help process the responses.\n\n\nCommands\n--------\nA `Command` object represents a simple axi4lite read or write, or a more complex\naggregrate consisting of many read and write commands.\n\ncommand.get_axi_commands()\n    Returns a list of `AxiCommand` objects.  Each `AxiCommand` object is a simple\n    axi4lite read or write command to a single address or a range of addresses.\n\ncommand.process_responses(read_responses, write_responses, resolve_future)\n    Processes two lists of `AxiResponse` objects, one is a list of responses to\n    write requests and one is a list of responses to read requests.  The two lists\n    must begin with the responses to this command, and these entries are removed\n    from the lists.\n    An (exception, result) tuple is returned by the function.  If `resolve_future`\n    is True then the commands future is resolved with the result and exception.\n\nAs an example consider an AxiAdder module, which uses an Axi4Lite interface.  We can\nwrite to registers A and B, and when we read from register C the returned result is\nthe sum of the contents in regsiters A and B.  We can create a `Command` object to\nrepresent using this hardware to add two numbers.\n\n.. code:: python\n\n    class AddNumbersCommand(comms.CombinedCommand):\n        '''\n        A command that writes to the intA and intB registers\n        and then reads from the intC register.\n        The effect is the add the two inputs.\n        '''\n\n        def __init__(self, a, b, addresses):\n            write_a_command = comms.SetUnsignedCommand(\n                address=addresses['intA'], value=a,\n                description='Setting A in AddNumbers',\n            )\n            write_b_command = comms.SetUnsignedCommand(\n                address=addresses['intB'], value=b,\n                description='Setting B in AddNumbers',\n            )\n            read_c_command = comms.GetUnsignedCommand(\n                address=addresses['intC'],\n                description='Getting C from AddNumbers',\n            )\n            commands = (write_a_command, write_b_command, read_c_command)\n            super().__init__(\n                description='Add 2 numbers with AddNumber',\n                commands=commands)\n\n        def process_responses(self, read_responses, write_responses, resolve_future=True):\n            '''\n            Return the third response (from the final read command)\n            Don't return any errors.\n            '''\n            e, result = super().process_responses(read_responses, write_responses, resolve_future=False)\n            intc = result[2]\n            if resolve_future:\n                self.resolve_future(e, intc)\n            return e, intc\n\n\n\nComm\n----\nTypically command objects are hidden from the testing interface by wrapping them\nwith a Comm object.  Methods on this comm object create `Command` objects, send\nthem to a handler, and return the command futures.\n\n.. code:: python\n\n    class AxiAdderComm:\n        '''\n        Class to communicate with the AxiAdder module.\n        '''\n\n        INTA_ADDRESS = 0\n        INTB_ADDRESS = 1\n        INTC_ADDRESS = 2\n\n        def __init__(self, address_offset, handler):\n            '''\n            `address_offset` is any addition that is made to the address that is\n            consumed during routing.\n            `handler` is the object responsible for dispatching the commands.\n            '''\n            self.handler = handler\n            self.address_offset = address_offset\n            self.addresses = {\n                'intA': address_offset + self.INTA_ADDRESS,\n                'intB': address_offset + self.INTB_ADDRESS,\n                'intC': address_offset + self.INTC_ADDRESS,\n            }\n\n        def add_numbers(self, a, b):\n            '''\n            A complex complex command that write to two registers and\n            then reads from another.\n            Sets 'a' and 'b' then reads 'c' (should be a+b)\n            '''\n            command = AddNumbersCommand(a, b, self.addresses)\n            self.handler.send(command)\n            return command.future\n\nTests\n-----\nA possible way to write a test to is define a class with a `prepare` method that\ndefines the requests to send to the module, and a `check` method that analyzes\nthe responses.\n\nThe `prepare` method uses a `handler` to generate the requests and creates a\nnumber of futures to hold the results of processing the responses.\n\nThe responses are then processed by a handler-dependent method and then the\n`check` method can be run to check the contents of the resolved futures.\n\n.. code:: python\n\n    class AxiAdderTest(object):\n\n        def __init__(self):\n            self.expected_intcs = []\n            self.intc_futures = []\n\n        def prepare(self, handler):\n            '''\n            Sends a number of 'add_numbers' commands.\n            '''\n            comm = AxiAdderComm(address_offset=0, handler=handler)\n            n_data = 20\n            max_int = pow(2, 16)-1\n            logger.debug('preparing data')\n            for i in range(n_data):\n                inta = random.randint(0, max_int)\n                intb = random.randint(0, max_int)\n                self.expected_intcs.append(inta + intb)\n                future = comm.add_numbers(inta, intb)\n                self.intc_futures.append(future)\n            # Flush the communication for simulations.\n            # Ignored in FPGA.\n            handler.send(comms.FakeWaitCommand(clock_cycles=10))\n\n        def check(self):\n            '''\n            Check that the output of the commands matches the expected values.\n            '''\n            output_intcs = [f.result() for f in self.intc_futures]\n            assert output_intcs == self.expected_intcs\n            print('Success!!!!!!!!!!!!!!!')\n\n\n\nRepeatability of Simulations\n----------------------------\nAlthough the simulations are repeatable the FPGA-based tests are currently not\nrepeatable because of the changing number of clock-cycles between when requests\nare received.\nI would like to fix this by allowing the ability of specify on which clock\ncycle at AXI request should be sent (they would be gathered in a delayed in a buffer\non the FPGA until the correct clock cycle).\nTODO: Add delaying of requests to allow repeatability.\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/benreynwar/axilent", "keywords": "VHDL,hdl,rtl,FPGA,ASIC,Xilinx,Altera", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "axilent", "package_url": "https://pypi.org/project/axilent/", "platform": "", "project_url": "https://pypi.org/project/axilent/", "project_urls": {"Homepage": "https://github.com/benreynwar/axilent"}, "release_url": "https://pypi.org/project/axilent/0.1.5/", "requires_dist": ["jinja2 (>=2.8)", "pytest", "slvcodec (>=0.3.5)"], "requires_python": "", "summary": "Tools for describing a sequence of Axi4Lite commands.", "version": "0.1.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/benreynwar/axilent\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/benreynwar/axilent.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fea2119e019ea9563611f53a48452765068f04ad/68747470733a2f2f7472617669732d63692e6f72672f62656e7265796e7761722f6178696c656e742e7376673f6272616e63683d6d6173746572\"></a>\n<div id=\"axilent\">\n<h2>axilent</h2>\n<p>axilent provides python tools for describing a sequence of Axi4Lite command\nin python.</p>\n<p>A python test can be written describing the sequence of commands to be sent\nand the expected responses.  This test can then be run against both a\nsimulation of the design and against the implemented design running on an\nFPGA.</p>\n<p>axilent is structured so that tests can be run both against both interactive\nsimulations and simulations where inputs cannot depend on outputs such as\nfile-based testbenchs.</p>\n<div id=\"handlers\">\n<h3>Handlers</h3>\n<p>Currently there is <cite>handler</cite> for working with file-based testbenchs\ngenerated by <a href=\"https://github.com/benreynwar/slvcodec\" rel=\"nofollow\">slvcodec</a> and\nfor simulations on FPGAs run over JTAG using\n<a href=\"https://github.com/benreynwar/pyvivado\" rel=\"nofollow\">pyvivado</a>.\nIn the likely event you are using neither of these methods, then you\nwill have to write you own handler. The handler has a single required\nmethod.</p>\n<dl>\n<dt>handler.send(command)</dt>\n<dd>Sends a command to the FPGA, or adds the command to the list of commands that\nwill be run in the simulation.</dd>\n</dl>\n<p>The handler also processes the responses from the simulation or FPGA and updates the\n<cite>command.future</cite> values appropriately.  It calls the <cite>command.process_responses</cite> method\nto help process the responses.</p>\n</div>\n<div id=\"commands\">\n<h3>Commands</h3>\n<p>A <cite>Command</cite> object represents a simple axi4lite read or write, or a more complex\naggregrate consisting of many read and write commands.</p>\n<dl>\n<dt>command.get_axi_commands()</dt>\n<dd>Returns a list of <cite>AxiCommand</cite> objects.  Each <cite>AxiCommand</cite> object is a simple\naxi4lite read or write command to a single address or a range of addresses.</dd>\n<dt>command.process_responses(read_responses, write_responses, resolve_future)</dt>\n<dd>Processes two lists of <cite>AxiResponse</cite> objects, one is a list of responses to\nwrite requests and one is a list of responses to read requests.  The two lists\nmust begin with the responses to this command, and these entries are removed\nfrom the lists.\nAn (exception, result) tuple is returned by the function.  If <cite>resolve_future</cite>\nis True then the commands future is resolved with the result and exception.</dd>\n</dl>\n<p>As an example consider an AxiAdder module, which uses an Axi4Lite interface.  We can\nwrite to registers A and B, and when we read from register C the returned result is\nthe sum of the contents in regsiters A and B.  We can create a <cite>Command</cite> object to\nrepresent using this hardware to add two numbers.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">AddNumbersCommand</span><span class=\"p\">(</span><span class=\"n\">comms</span><span class=\"o\">.</span><span class=\"n\">CombinedCommand</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''\n    A command that writes to the intA and intB registers\n    and then reads from the intC register.\n    The effect is the add the two inputs.\n    '''</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">addresses</span><span class=\"p\">):</span>\n        <span class=\"n\">write_a_command</span> <span class=\"o\">=</span> <span class=\"n\">comms</span><span class=\"o\">.</span><span class=\"n\">SetUnsignedCommand</span><span class=\"p\">(</span>\n            <span class=\"n\">address</span><span class=\"o\">=</span><span class=\"n\">addresses</span><span class=\"p\">[</span><span class=\"s1\">'intA'</span><span class=\"p\">],</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">a</span><span class=\"p\">,</span>\n            <span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'Setting A in AddNumbers'</span><span class=\"p\">,</span>\n        <span class=\"p\">)</span>\n        <span class=\"n\">write_b_command</span> <span class=\"o\">=</span> <span class=\"n\">comms</span><span class=\"o\">.</span><span class=\"n\">SetUnsignedCommand</span><span class=\"p\">(</span>\n            <span class=\"n\">address</span><span class=\"o\">=</span><span class=\"n\">addresses</span><span class=\"p\">[</span><span class=\"s1\">'intB'</span><span class=\"p\">],</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">b</span><span class=\"p\">,</span>\n            <span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'Setting B in AddNumbers'</span><span class=\"p\">,</span>\n        <span class=\"p\">)</span>\n        <span class=\"n\">read_c_command</span> <span class=\"o\">=</span> <span class=\"n\">comms</span><span class=\"o\">.</span><span class=\"n\">GetUnsignedCommand</span><span class=\"p\">(</span>\n            <span class=\"n\">address</span><span class=\"o\">=</span><span class=\"n\">addresses</span><span class=\"p\">[</span><span class=\"s1\">'intC'</span><span class=\"p\">],</span>\n            <span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'Getting C from AddNumbers'</span><span class=\"p\">,</span>\n        <span class=\"p\">)</span>\n        <span class=\"n\">commands</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">write_a_command</span><span class=\"p\">,</span> <span class=\"n\">write_b_command</span><span class=\"p\">,</span> <span class=\"n\">read_c_command</span><span class=\"p\">)</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span>\n            <span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'Add 2 numbers with AddNumber'</span><span class=\"p\">,</span>\n            <span class=\"n\">commands</span><span class=\"o\">=</span><span class=\"n\">commands</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">process_responses</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">read_responses</span><span class=\"p\">,</span> <span class=\"n\">write_responses</span><span class=\"p\">,</span> <span class=\"n\">resolve_future</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''\n        Return the third response (from the final read command)\n        Don't return any errors.\n        '''</span>\n        <span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">process_responses</span><span class=\"p\">(</span><span class=\"n\">read_responses</span><span class=\"p\">,</span> <span class=\"n\">write_responses</span><span class=\"p\">,</span> <span class=\"n\">resolve_future</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n        <span class=\"n\">intc</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n        <span class=\"k\">if</span> <span class=\"n\">resolve_future</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">resolve_future</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">intc</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">intc</span>\n</pre>\n</div>\n<div id=\"comm\">\n<h3>Comm</h3>\n<p>Typically command objects are hidden from the testing interface by wrapping them\nwith a Comm object.  Methods on this comm object create <cite>Command</cite> objects, send\nthem to a handler, and return the command futures.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">AxiAdderComm</span><span class=\"p\">:</span>\n    <span class=\"sd\">'''\n    Class to communicate with the AxiAdder module.\n    '''</span>\n\n    <span class=\"n\">INTA_ADDRESS</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">INTB_ADDRESS</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">INTC_ADDRESS</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">address_offset</span><span class=\"p\">,</span> <span class=\"n\">handler</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''\n        `address_offset` is any addition that is made to the address that is\n        consumed during routing.\n        `handler` is the object responsible for dispatching the commands.\n        '''</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">handler</span> <span class=\"o\">=</span> <span class=\"n\">handler</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">address_offset</span> <span class=\"o\">=</span> <span class=\"n\">address_offset</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">addresses</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'intA'</span><span class=\"p\">:</span> <span class=\"n\">address_offset</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">INTA_ADDRESS</span><span class=\"p\">,</span>\n            <span class=\"s1\">'intB'</span><span class=\"p\">:</span> <span class=\"n\">address_offset</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">INTB_ADDRESS</span><span class=\"p\">,</span>\n            <span class=\"s1\">'intC'</span><span class=\"p\">:</span> <span class=\"n\">address_offset</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">INTC_ADDRESS</span><span class=\"p\">,</span>\n        <span class=\"p\">}</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">add_numbers</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''\n        A complex complex command that write to two registers and\n        then reads from another.\n        Sets 'a' and 'b' then reads 'c' (should be a+b)\n        '''</span>\n        <span class=\"n\">command</span> <span class=\"o\">=</span> <span class=\"n\">AddNumbersCommand</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">addresses</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">handler</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">command</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">command</span><span class=\"o\">.</span><span class=\"n\">future</span>\n</pre>\n</div>\n<div id=\"tests\">\n<h3>Tests</h3>\n<p>A possible way to write a test to is define a class with a <cite>prepare</cite> method that\ndefines the requests to send to the module, and a <cite>check</cite> method that analyzes\nthe responses.</p>\n<p>The <cite>prepare</cite> method uses a <cite>handler</cite> to generate the requests and creates a\nnumber of futures to hold the results of processing the responses.</p>\n<p>The responses are then processed by a handler-dependent method and then the\n<cite>check</cite> method can be run to check the contents of the resolved futures.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">AxiAdderTest</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">expected_intcs</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">intc_futures</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">prepare</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">handler</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''\n        Sends a number of 'add_numbers' commands.\n        '''</span>\n        <span class=\"n\">comm</span> <span class=\"o\">=</span> <span class=\"n\">AxiAdderComm</span><span class=\"p\">(</span><span class=\"n\">address_offset</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">handler</span><span class=\"o\">=</span><span class=\"n\">handler</span><span class=\"p\">)</span>\n        <span class=\"n\">n_data</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>\n        <span class=\"n\">max_int</span> <span class=\"o\">=</span> <span class=\"nb\">pow</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span>\n        <span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">debug</span><span class=\"p\">(</span><span class=\"s1\">'preparing data'</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n_data</span><span class=\"p\">):</span>\n            <span class=\"n\">inta</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">max_int</span><span class=\"p\">)</span>\n            <span class=\"n\">intb</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">max_int</span><span class=\"p\">)</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">expected_intcs</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">inta</span> <span class=\"o\">+</span> <span class=\"n\">intb</span><span class=\"p\">)</span>\n            <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">comm</span><span class=\"o\">.</span><span class=\"n\">add_numbers</span><span class=\"p\">(</span><span class=\"n\">inta</span><span class=\"p\">,</span> <span class=\"n\">intb</span><span class=\"p\">)</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">intc_futures</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Flush the communication for simulations.</span>\n        <span class=\"c1\"># Ignored in FPGA.</span>\n        <span class=\"n\">handler</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">comms</span><span class=\"o\">.</span><span class=\"n\">FakeWaitCommand</span><span class=\"p\">(</span><span class=\"n\">clock_cycles</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">check</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">'''\n        Check that the output of the commands matches the expected values.\n        '''</span>\n        <span class=\"n\">output_intcs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">f</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">intc_futures</span><span class=\"p\">]</span>\n        <span class=\"k\">assert</span> <span class=\"n\">output_intcs</span> <span class=\"o\">==</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">expected_intcs</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Success!!!!!!!!!!!!!!!'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"repeatability-of-simulations\">\n<h3>Repeatability of Simulations</h3>\n<p>Although the simulations are repeatable the FPGA-based tests are currently not\nrepeatable because of the changing number of clock-cycles between when requests\nare received.\nI would like to fix this by allowing the ability of specify on which clock\ncycle at AXI request should be sent (they would be gathered in a delayed in a buffer\non the FPGA until the correct clock cycle).\nTODO: Add delaying of requests to allow repeatability.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6100487, "releases": {"0.1.3": [{"comment_text": "", "digests": {"md5": "54ace4684e92f286ff580a72bb96a589", "sha256": "d97f6b3fd3fffe5dfac611a929b6f253dbdc759ac8318bd919248a861cf28f44"}, "downloads": -1, "filename": "axilent-0.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "54ace4684e92f286ff580a72bb96a589", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17331, "upload_time": "2019-03-11T22:39:52", "upload_time_iso_8601": "2019-03-11T22:39:52.158357Z", "url": "https://files.pythonhosted.org/packages/14/d9/ff94095de39c558124cdf328bba0114c80a0c3196b133f63ba4b1ae017f0/axilent-0.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4f1c2d0057a7576c3a0c75d0cb0d615e", "sha256": "43b61530f612ed2e1b4e5b50673fcdfab3f230ade6af6979809fe9c2e082943c"}, "downloads": -1, "filename": "axilent-0.1.3.tar.gz", "has_sig": false, "md5_digest": "4f1c2d0057a7576c3a0c75d0cb0d615e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15696, "upload_time": "2019-03-11T22:39:54", "upload_time_iso_8601": "2019-03-11T22:39:54.414210Z", "url": "https://files.pythonhosted.org/packages/17/2a/048aca7238cec6ced95821be22a08099d3dcafb902087132f906cfa956bb/axilent-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "a38fb8ce273e86e0697fa112a56b3840", "sha256": "c431ddf74473e731c7d042f530629cfd1356b187bcc323fb9030d4a4653e6e63"}, "downloads": -1, "filename": "axilent-0.1.4-py3-none-any.whl", "has_sig": false, "md5_digest": "a38fb8ce273e86e0697fa112a56b3840", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17967, "upload_time": "2019-03-12T02:17:15", "upload_time_iso_8601": "2019-03-12T02:17:15.184255Z", "url": "https://files.pythonhosted.org/packages/98/58/6969304386b9b5cca02a914308159398b5ef563005d7c1802060202a0e18/axilent-0.1.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5ff700d01273e7e5594b83fe4c2da013", "sha256": "adfa09e1d4d497c6e450fc1111a42447be13e8860ace900dd8ab6701645fbfde"}, "downloads": -1, "filename": "axilent-0.1.4.tar.gz", "has_sig": false, "md5_digest": "5ff700d01273e7e5594b83fe4c2da013", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15704, "upload_time": "2019-03-12T02:17:16", "upload_time_iso_8601": "2019-03-12T02:17:16.382350Z", "url": "https://files.pythonhosted.org/packages/76/99/fca45fc816030e93aa4952a273c9bc779e85fe1eddbca88ba507e08134d6/axilent-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "83c9dc65090de9031bef6bbae3f0fd04", "sha256": "1577e8cfac7b5f92540915b77cb3c01d6e62cd85f4feb2ba7c601b2d5705570f"}, "downloads": -1, "filename": "axilent-0.1.5-py3-none-any.whl", "has_sig": false, "md5_digest": "83c9dc65090de9031bef6bbae3f0fd04", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22669, "upload_time": "2019-11-08T17:27:15", "upload_time_iso_8601": "2019-11-08T17:27:15.878624Z", "url": "https://files.pythonhosted.org/packages/27/b3/f66eba4f89a8e5fba65f75d23aa6ca332a791b68083e222ef393e8dfd75f/axilent-0.1.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fad4ec539b066c3fd8407d7b84a38968", "sha256": "2247ed0c189f61a070c6354de9e9b513df5940952d46bf8e9b811cb8aae993bc"}, "downloads": -1, "filename": "axilent-0.1.5.tar.gz", "has_sig": false, "md5_digest": "fad4ec539b066c3fd8407d7b84a38968", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22062, "upload_time": "2019-11-08T17:27:17", "upload_time_iso_8601": "2019-11-08T17:27:17.296891Z", "url": "https://files.pythonhosted.org/packages/39/c2/688a19f81688f8532a79e02469190f8b953c7100d62d96b6c205c1536b32/axilent-0.1.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "83c9dc65090de9031bef6bbae3f0fd04", "sha256": "1577e8cfac7b5f92540915b77cb3c01d6e62cd85f4feb2ba7c601b2d5705570f"}, "downloads": -1, "filename": "axilent-0.1.5-py3-none-any.whl", "has_sig": false, "md5_digest": "83c9dc65090de9031bef6bbae3f0fd04", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22669, "upload_time": "2019-11-08T17:27:15", "upload_time_iso_8601": "2019-11-08T17:27:15.878624Z", "url": "https://files.pythonhosted.org/packages/27/b3/f66eba4f89a8e5fba65f75d23aa6ca332a791b68083e222ef393e8dfd75f/axilent-0.1.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fad4ec539b066c3fd8407d7b84a38968", "sha256": "2247ed0c189f61a070c6354de9e9b513df5940952d46bf8e9b811cb8aae993bc"}, "downloads": -1, "filename": "axilent-0.1.5.tar.gz", "has_sig": false, "md5_digest": "fad4ec539b066c3fd8407d7b84a38968", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22062, "upload_time": "2019-11-08T17:27:17", "upload_time_iso_8601": "2019-11-08T17:27:17.296891Z", "url": "https://files.pythonhosted.org/packages/39/c2/688a19f81688f8532a79e02469190f8b953c7100d62d96b6c205c1536b32/axilent-0.1.5.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:15:30 2020"}