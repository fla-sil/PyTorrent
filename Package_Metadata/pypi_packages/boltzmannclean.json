{"info": {"author": "Faculty", "author_email": "opensource@faculty.ai", "bugtrack_url": null, "classifiers": [], "description": "sherlockml-boltzmannclean\n=========================\n\nFill missing values in a pandas DataFrame using a Restricted Boltzmann Machine.\n\nProvides a class implementing the scikit-learn transformer interface for creating and training a Restricted Boltzmann Machine. This can then be sampled from to fill in missing values in training data or new data of the same format. Utility functions for applying the transformations to a pandas DataFrame are provided, with the option to treat columns as either continuous numerical or categorical features.\n\nInstallation\n------------\n\n.. code-block:: bash\n\n    pip install boltzmannclean\n\n\nUsage\n-----\n\nTo fill in missing values from a DataFrame with the minimum of fuss, a cleaning function is provided.\n\n.. code-block:: python\n\n    import boltzmannclean\n\n    my_clean_dataframe = boltzmannclean.clean(\n        dataframe=my_dataframe,\n        numerical_columns=['Height', 'Weight'],\n        categorical_columns=['Colour', 'Shape'],\n        tune_rbm=True  # tune RBM hyperparameters for my data\n    )\n\nTo create and use the underlying scikit-learn transformer.\n\n.. code-block:: python\n\n    my_rbm = boltzmannclean.RestrictedBoltzmannMachine(\n        n_hidden=100, learn_rate=0.01,\n        batchsize=10, dropout_fraction=0.5, max_epochs=1,\n        adagrad=True\n    )\n\n    my_rbm.fit_transform(a_numpy_array)\n\nHere the default RBM hyperparameters are those listed above, and the numpy array operated on is expected to be composed entirely of numbers in the range [0,1] or np.nan/None. The hyperparameters are:\n\n- *n_hidden*: the size of the hidden layer\n- *learn_rate*: learning rate for stochastic gradient descent\n- *batchsize*: batchsize for stochastic gradient descent\n- *dropout_fraction*: fraction of hidden nodes to be dropped out on each backward pass during training\n- *max_epochs*: maximum number of passes over the training data\n- *adagrad*: whether to use the Adagrad update rules for stochastic gradient descent\n\nExample\n-------\n\n.. code-block:: python\n\n    import boltzmannclean\n    import numpy as np\n    import pandas as pd\n    from sklearn import datasets\n\n    iris = datasets.load_iris()\n\n    df_iris = pd.DataFrame(iris.data,columns=iris.feature_names)\n    df_iris['target'] = pd.Series(iris.target, dtype=str)\n\n    df_iris.head()\n\n=   =================   ================    =================   ================    ======\n_   sepal length (cm)   sepal width (cm)    petal length (cm)   petal width (cm)    target\n=   =================   ================    =================   ================    ======\n0   5.1                  3.5                  1.4                  0.2                  0\n1   4.9                  3.0                  1.4                  0.2                  0\n2   4.7                  3.2                  1.3                  0.2                  0\n3   4.6                  3.1                  1.5                  0.2                  0\n4   5.0                  3.6                  1.4                  0.2                  0\n=   =================   ================    =================   ================    ======\n\n\nAdd some noise:\n\n.. code-block:: python\n\n    noise = [(0,1),(2,0),(0,4)]\n\n    for noisy in noise:\n        df_iris.iloc[noisy] = None\n\n    df_iris.head()\n\n=   =================   ================    =================   ================    ======\n_   sepal length (cm)   sepal width (cm)    petal length (cm)   petal width (cm)    target\n=   =================   ================    =================   ================    ======\n0   5.1                  NaN                  1.4                  0.2               None\n1   4.9                  3.0                  1.4                  0.2                  0\n2   NaN                  3.2                  1.3                  0.2                  0\n3   4.6                  3.1                  1.5                  0.2                  0\n4   5.0                  3.6                  1.4                  0.2                  0\n=   =================   ================    =================   ================    ======\n\nClean the DataFrame:\n\n.. code-block:: python\n\n    df_iris_cleaned = boltzmannclean.clean(\n        dataframe=df_iris,\n        numerical_columns=[\n            'sepal length (cm)', 'sepal width (cm)',\n            'petal length (cm)', 'petal width (cm)'\n        ],\n        categorical_columns=['target'],\n        tune_rbm=True\n    )\n\n    df_iris_cleaned.round(1).head()\n\n\n=   =================   ================    =================   ================    ======\n_   sepal length (cm)   sepal width (cm)    petal length (cm)   petal width (cm)    target\n=   =================   ================    =================   ================    ======\n0   5.1                  3.3                  1.4                  0.2                  0\n1   4.9                  3.0                  1.4                  0.2                  0\n2   6.3                  3.2                  1.3                  0.2                  0\n3   4.6                  3.1                  1.5                  0.2                  0\n4   5.0                  3.6                  1.4                  0.2                  0\n=   =================   ================    =================   ================    ======\n\nThe larger and more correlated the dataset is, the better the imputed values will be.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/facultyai/boltzmannclean", "keywords": "", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "boltzmannclean", "package_url": "https://pypi.org/project/boltzmannclean/", "platform": "", "project_url": "https://pypi.org/project/boltzmannclean/", "project_urls": {"Homepage": "https://github.com/facultyai/boltzmannclean"}, "release_url": "https://pypi.org/project/boltzmannclean/0.1.2/", "requires_dist": null, "requires_python": "", "summary": "Fill missing values in DataFrames with Restricted Boltzmann Machines", "version": "0.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Fill missing values in a pandas DataFrame using a Restricted Boltzmann Machine.</p>\n<p>Provides a class implementing the scikit-learn transformer interface for creating and training a Restricted Boltzmann Machine. This can then be sampled from to fill in missing values in training data or new data of the same format. Utility functions for applying the transformations to a pandas DataFrame are provided, with the option to treat columns as either continuous numerical or categorical features.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>pip install boltzmannclean\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>To fill in missing values from a DataFrame with the minimum of fuss, a cleaning function is provided.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">boltzmannclean</span>\n\n<span class=\"n\">my_clean_dataframe</span> <span class=\"o\">=</span> <span class=\"n\">boltzmannclean</span><span class=\"o\">.</span><span class=\"n\">clean</span><span class=\"p\">(</span>\n    <span class=\"n\">dataframe</span><span class=\"o\">=</span><span class=\"n\">my_dataframe</span><span class=\"p\">,</span>\n    <span class=\"n\">numerical_columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'Height'</span><span class=\"p\">,</span> <span class=\"s1\">'Weight'</span><span class=\"p\">],</span>\n    <span class=\"n\">categorical_columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'Colour'</span><span class=\"p\">,</span> <span class=\"s1\">'Shape'</span><span class=\"p\">],</span>\n    <span class=\"n\">tune_rbm</span><span class=\"o\">=</span><span class=\"kc\">True</span>  <span class=\"c1\"># tune RBM hyperparameters for my data</span>\n<span class=\"p\">)</span>\n</pre>\n<p>To create and use the underlying scikit-learn transformer.</p>\n<pre><span class=\"n\">my_rbm</span> <span class=\"o\">=</span> <span class=\"n\">boltzmannclean</span><span class=\"o\">.</span><span class=\"n\">RestrictedBoltzmannMachine</span><span class=\"p\">(</span>\n    <span class=\"n\">n_hidden</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">learn_rate</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span>\n    <span class=\"n\">batchsize</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">dropout_fraction</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">max_epochs</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"n\">adagrad</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">my_rbm</span><span class=\"o\">.</span><span class=\"n\">fit_transform</span><span class=\"p\">(</span><span class=\"n\">a_numpy_array</span><span class=\"p\">)</span>\n</pre>\n<p>Here the default RBM hyperparameters are those listed above, and the numpy array operated on is expected to be composed entirely of numbers in the range [0,1] or np.nan/None. The hyperparameters are:</p>\n<ul>\n<li><em>n_hidden</em>: the size of the hidden layer</li>\n<li><em>learn_rate</em>: learning rate for stochastic gradient descent</li>\n<li><em>batchsize</em>: batchsize for stochastic gradient descent</li>\n<li><em>dropout_fraction</em>: fraction of hidden nodes to be dropped out on each backward pass during training</li>\n<li><em>max_epochs</em>: maximum number of passes over the training data</li>\n<li><em>adagrad</em>: whether to use the Adagrad update rules for stochastic gradient descent</li>\n</ul>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">boltzmannclean</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"nn\">pd</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn</span> <span class=\"kn\">import</span> <span class=\"n\">datasets</span>\n\n<span class=\"n\">iris</span> <span class=\"o\">=</span> <span class=\"n\">datasets</span><span class=\"o\">.</span><span class=\"n\">load_iris</span><span class=\"p\">()</span>\n\n<span class=\"n\">df_iris</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">iris</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">,</span><span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"n\">iris</span><span class=\"o\">.</span><span class=\"n\">feature_names</span><span class=\"p\">)</span>\n<span class=\"n\">df_iris</span><span class=\"p\">[</span><span class=\"s1\">'target'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">(</span><span class=\"n\">iris</span><span class=\"o\">.</span><span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">)</span>\n\n<span class=\"n\">df_iris</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">()</span>\n</pre>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>_</th>\n<th>sepal length (cm)</th>\n<th>sepal width (cm)</th>\n<th>petal length (cm)</th>\n<th>petal width (cm)</th>\n<th>target</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>0</td>\n<td>5.1</td>\n<td>3.5</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>1</td>\n<td>4.9</td>\n<td>3.0</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>2</td>\n<td>4.7</td>\n<td>3.2</td>\n<td>1.3</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>3</td>\n<td>4.6</td>\n<td>3.1</td>\n<td>1.5</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>4</td>\n<td>5.0</td>\n<td>3.6</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>Add some noise:</p>\n<pre><span class=\"n\">noise</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">),(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">),(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">)]</span>\n\n<span class=\"k\">for</span> <span class=\"n\">noisy</span> <span class=\"ow\">in</span> <span class=\"n\">noise</span><span class=\"p\">:</span>\n    <span class=\"n\">df_iris</span><span class=\"o\">.</span><span class=\"n\">iloc</span><span class=\"p\">[</span><span class=\"n\">noisy</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n<span class=\"n\">df_iris</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">()</span>\n</pre>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>_</th>\n<th>sepal length (cm)</th>\n<th>sepal width (cm)</th>\n<th>petal length (cm)</th>\n<th>petal width (cm)</th>\n<th>target</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>0</td>\n<td>5.1</td>\n<td>NaN</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>None</td>\n</tr>\n<tr><td>1</td>\n<td>4.9</td>\n<td>3.0</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>2</td>\n<td>NaN</td>\n<td>3.2</td>\n<td>1.3</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>3</td>\n<td>4.6</td>\n<td>3.1</td>\n<td>1.5</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>4</td>\n<td>5.0</td>\n<td>3.6</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>Clean the DataFrame:</p>\n<pre><span class=\"n\">df_iris_cleaned</span> <span class=\"o\">=</span> <span class=\"n\">boltzmannclean</span><span class=\"o\">.</span><span class=\"n\">clean</span><span class=\"p\">(</span>\n    <span class=\"n\">dataframe</span><span class=\"o\">=</span><span class=\"n\">df_iris</span><span class=\"p\">,</span>\n    <span class=\"n\">numerical_columns</span><span class=\"o\">=</span><span class=\"p\">[</span>\n        <span class=\"s1\">'sepal length (cm)'</span><span class=\"p\">,</span> <span class=\"s1\">'sepal width (cm)'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'petal length (cm)'</span><span class=\"p\">,</span> <span class=\"s1\">'petal width (cm)'</span>\n    <span class=\"p\">],</span>\n    <span class=\"n\">categorical_columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'target'</span><span class=\"p\">],</span>\n    <span class=\"n\">tune_rbm</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">df_iris_cleaned</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">()</span>\n</pre>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>_</th>\n<th>sepal length (cm)</th>\n<th>sepal width (cm)</th>\n<th>petal length (cm)</th>\n<th>petal width (cm)</th>\n<th>target</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>0</td>\n<td>5.1</td>\n<td>3.3</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>1</td>\n<td>4.9</td>\n<td>3.0</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>2</td>\n<td>6.3</td>\n<td>3.2</td>\n<td>1.3</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>3</td>\n<td>4.6</td>\n<td>3.1</td>\n<td>1.5</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n<tr><td>4</td>\n<td>5.0</td>\n<td>3.6</td>\n<td>1.4</td>\n<td>0.2</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>The larger and more correlated the dataset is, the better the imputed values will be.</p>\n</div>\n\n          </div>"}, "last_serial": 6228140, "releases": {"0.1.2": [{"comment_text": "", "digests": {"md5": "29cb7c1e8788f79dfeaa67f77d73d1d7", "sha256": "e4b4ed0a7ae9c1f3dfb9283c87fd1c846d801934f16afcf0e09ce5f24bc8d073"}, "downloads": -1, "filename": "boltzmannclean-0.1.2.tar.gz", "has_sig": false, "md5_digest": "29cb7c1e8788f79dfeaa67f77d73d1d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6765, "upload_time": "2019-11-29T10:27:25", "upload_time_iso_8601": "2019-11-29T10:27:25.132003Z", "url": "https://files.pythonhosted.org/packages/ac/70/c37f6e44394f27e6c349234dcd6127ac162e8f9206ce6fdc5c12fad21972/boltzmannclean-0.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "29cb7c1e8788f79dfeaa67f77d73d1d7", "sha256": "e4b4ed0a7ae9c1f3dfb9283c87fd1c846d801934f16afcf0e09ce5f24bc8d073"}, "downloads": -1, "filename": "boltzmannclean-0.1.2.tar.gz", "has_sig": false, "md5_digest": "29cb7c1e8788f79dfeaa67f77d73d1d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6765, "upload_time": "2019-11-29T10:27:25", "upload_time_iso_8601": "2019-11-29T10:27:25.132003Z", "url": "https://files.pythonhosted.org/packages/ac/70/c37f6e44394f27e6c349234dcd6127ac162e8f9206ce6fdc5c12fad21972/boltzmannclean-0.1.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:36:47 2020"}