{"info": {"author": "Sean Gillies", "author_email": "sean.gillies@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Scientific/Engineering :: GIS"], "description": "=======================\nde9im: DE-9IM utilities\n=======================\n\nAs part of my continuing education about the theory and methods underlying\nShapely, GEOS, JTS, and the OGC's Simple Features specs, I've written a small\npackage of utilities for working with DE-9IM matrices and patterns:\nhttp://bitbucket.org/sgillies/de9im/. Shapely provides the standard (these are\nprobably my favorite OGC standards) predicates as geometry class methods::\n\n  >>> from shapely.wkt import loads\n  >>> p = loads('POLYGON ((1.0 0.0, 0.0 -1.0, -1.0 0.0, 0.0 1.0, 1.0 0.0))') \n  >>> q = loads('POLYGON ((3.0 0.0, 2.0 -1.0, 1.0 0.0, 2.0 1.0, 3.0 0.0))')\n  >>> p.disjoint(q)\n  False\n  >>> p.intersects(q)\n  True\n  >>> p.touches(q)\n  True\n\nbut what if you wanted to test whether the features touched at exactly one\npoint only? A \"side hug\", you might say. Instead of computing the intersection\nand checking its geometry type, you can use the de9im package to define a\nDE-9IM matrix pattern and test it against the relation matrix for the two\nfeatures. The `0` in the pattern below requires that the intersection of the\nboundaries of the features be a 0-dimensional figure. In other words: a point::\n\n  >>> from de9im import pattern\n  >>> side_hug = pattern('FF*F0****')\n  >>> im = p.relate(q)\n  >>> print im\n  FF2F01212\n  >>> side_hug.matches(im)\n  True\n\nOne may also use familiarly named patterns::\n\n  >>> from de9im.patterns import touches\n  >>> repr(touches)\n  \"DE-9IM or-pattern: 'FT*******||F**T*****||F***T****'\"\n  >>> touches.matches(im)\n  True", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://bitbucket.org/sgillies/de9im/", "keywords": "gis computational geometry", "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "de9im", "package_url": "https://pypi.org/project/de9im/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/de9im/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://bitbucket.org/sgillies/de9im/"}, "release_url": "https://pypi.org/project/de9im/0.1/", "requires_dist": null, "requires_python": null, "summary": "Dimensionally  Extended 9-Intersections Matrix utilities", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>As part of my continuing education about the theory and methods underlying\nShapely, GEOS, JTS, and the OGC\u2019s Simple Features specs, I\u2019ve written a small\npackage of utilities for working with DE-9IM matrices and patterns:\n<a href=\"http://bitbucket.org/sgillies/de9im/\" rel=\"nofollow\">http://bitbucket.org/sgillies/de9im/</a>. Shapely provides the standard (these are\nprobably my favorite OGC standards) predicates as geometry class methods:</p>\n<pre>&gt;&gt;&gt; from shapely.wkt import loads\n&gt;&gt;&gt; p = loads('POLYGON ((1.0 0.0, 0.0 -1.0, -1.0 0.0, 0.0 1.0, 1.0 0.0))')\n&gt;&gt;&gt; q = loads('POLYGON ((3.0 0.0, 2.0 -1.0, 1.0 0.0, 2.0 1.0, 3.0 0.0))')\n&gt;&gt;&gt; p.disjoint(q)\nFalse\n&gt;&gt;&gt; p.intersects(q)\nTrue\n&gt;&gt;&gt; p.touches(q)\nTrue\n</pre>\n<p>but what if you wanted to test whether the features touched at exactly one\npoint only? A \u201cside hug\u201d, you might say. Instead of computing the intersection\nand checking its geometry type, you can use the de9im package to define a\nDE-9IM matrix pattern and test it against the relation matrix for the two\nfeatures. The <cite>0</cite> in the pattern below requires that the intersection of the\nboundaries of the features be a 0-dimensional figure. In other words: a point:</p>\n<pre>&gt;&gt;&gt; from de9im import pattern\n&gt;&gt;&gt; side_hug = pattern('FF*F0****')\n&gt;&gt;&gt; im = p.relate(q)\n&gt;&gt;&gt; print im\nFF2F01212\n&gt;&gt;&gt; side_hug.matches(im)\nTrue\n</pre>\n<p>One may also use familiarly named patterns:</p>\n<pre>&gt;&gt;&gt; from de9im.patterns import touches\n&gt;&gt;&gt; repr(touches)\n\"DE-9IM or-pattern: 'FT*******||F**T*****||F***T****'\"\n&gt;&gt;&gt; touches.matches(im)\nTrue\n</pre>\n\n          </div>"}, "last_serial": 639538, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "0b00313663d656cc421f8952664559ab", "sha256": "5468625078a488a95ca0f0338c97368a82a9d08db3d8b2409949342329bb31b1"}, "downloads": -1, "filename": "de9im-0.1.tar.gz", "has_sig": false, "md5_digest": "0b00313663d656cc421f8952664559ab", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3321, "upload_time": "2010-03-31T13:27:20", "upload_time_iso_8601": "2010-03-31T13:27:20.819246Z", "url": "https://files.pythonhosted.org/packages/86/31/f6169b1c477b037f18146299f77f01572a3ec99aeb661f66be530a9c5239/de9im-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0b00313663d656cc421f8952664559ab", "sha256": "5468625078a488a95ca0f0338c97368a82a9d08db3d8b2409949342329bb31b1"}, "downloads": -1, "filename": "de9im-0.1.tar.gz", "has_sig": false, "md5_digest": "0b00313663d656cc421f8952664559ab", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3321, "upload_time": "2010-03-31T13:27:20", "upload_time_iso_8601": "2010-03-31T13:27:20.819246Z", "url": "https://files.pythonhosted.org/packages/86/31/f6169b1c477b037f18146299f77f01572a3ec99aeb661f66be530a9c5239/de9im-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:39:41 2020"}