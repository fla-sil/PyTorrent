{"info": {"author": "Andreas Sodeur", "author_email": "andreas.sodeur@rwe.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Compilers"], "description": "Pass-through type for Numba\n===========================\n\nTools to ferry arbitrary Python objects through `nopython` mode. This is a stand-alone version of the Numba internal\nimplementation [PR 3640](https://github.com/numba/numba/pull/3640). \n\nThis has two typical use-cases:\n  1. ferrying data structures not currently supported by Numba into `objmode` blocks via `PassThruContainer`\n  2. creating extension types that are simplified representations of the Python class and keep a link to the\n     Python object\n     \nIt's not unlikely both can be avoided completely when starting from scratch but potentially require extensive\nrefactoring when moving Numba into an existing code base.\n\nFerrying objects into `objmode` using `PassThruContainer`\n---------------------------------------------------------\n`PassThruContainer` can be used to make Python objects not supported by `nopython` available inside\n`objmode` blocks. Outside `objmode` blocks the only supported operation on `PassThruContainer` \nis `==`. Two instances are equal if the wrapped objects are identical, ie `a.obj is b.obj`.\n\nIn the following example an object unsupported in `nopython` is ferried into an `objmode` block and\nmutated there. \n```python\nfrom __future__ import annotations\nfrom numba import jit, objmode\nfrom numba_passthru import PassThruContainer\n\nclass Testee:\n    def __init__(self, value: int, invert=False):\n        self.value = value\n        self.numba_will_not_like_this = compile('pass', 'N/A', 'single')\n        \n    def __gt__(self, other):    # will be used in next example\n        return self.value > other.value\n\ntestee = Testee(1)  \ncontainer = PassThruContainer(testee)\n\n@jit(nopython=True)\ndef do_something(container):\n    with objmode(value='int64'):\n        setattr(container.obj, 'value_2', 2)\n        value = container.obj.value\n        \n    return container, value\n    \nresult, value = do_something(container)\n\nassert container is result\nassert value == 1\nassert result.obj.value_2 == 2\n```\n\nThere will be no speed-up for the code inside the `objmode` block and `container` is (un)boxed twice adding further\noverhead. Hence, this only makes sense in rarely visited code-path and if refactoring into a more Numba friendly\n form is not an option.\n \nNote that the example above already contains the most common pattern that is pretty unpleasant to refactor into a \nNumba friendly form in requiring object identity being preserved through `nopython` (`assert container is result`).\nObviously, this is a highly artificial requirement in this toy example but might get more real if the pass-through\nobject is part of conditional branches. \n\nCreating custom passthrough types\n---------------------------------\n`PassThroughContainer` does not allow attribute access on the wrapped object in `nopython` and there is no way\nto dispatch on the type of the wrapped object. To get both you can create a Numba extension type using `pass_thru_type`.\n`pass_thru_type` holds a pointer to the `PyObject` and manages references. `pass_thru_type` can be used like any \nmem-managed member on an [extension type](http://numba.pydata.org/numba-doc/latest/extending/index.html). (Some\nfamiliarity with Numba extension types is expected for the following.)  \n \nContinuing the example above let's try to get the following code working in `nopython` (another toy\nexample, no speed-up expected):\n```python\ndef find_max(testees: List[Testee]) -> Testee:\n    result = testees[0]  # testees must not be empty\n    for testee in testees[1:]:\n        if testee > result:\n            result = testee\n\n    return result     \n``` \n`PassThroughContainer` will not help here as there would be no way to dispatch `>`  to `Testee.__gt__` and there would\nbe no way to access `.value` from `nopython` inside `Testee.__gt__`. Still, since `Testee.value` is the only attribute \nbeing accessed from `nopython` there is a realistic chance to get this working. Indeed, assuming we already had the \n(un)boxer this is a straight forward Numba extension type:\n```python\nfrom numba import jit, types\nfrom numba.extending import overload\nfrom numba.typing.typeof import typeof_impl\nimport operator\n\nclass TesteeType(PassThruType):\n    def __init__(self):\n        super(TesteeType, self).__init__(name='Testee')\n\ntestee_type = TesteeType()\n\n@typeof_impl.register(Testee)\ndef type_testee(val, context):\n    return testee_type\n\n@overload(operator.gt)\ndef testee_gt(self, other):\n    if self is testee_type and other is testee_type:\n        return Testee.__gt__\n\nfind_max = jit(nopython=True)(find_max)\n```\n\nTrying to implement the (un)boxer to somehow pass the `.numba_will_not_like_this` attribute around `nopython` (sharing\na dict between boxer/unboxer etc) is not straight forward to get working for `find_max` alone and it is impossible\nto get the reference counting right in the general case. The clean approach is to have the Numba runtime manage the\nreferences by putting a NRT managed reference to the original Python object onto the extension type's data model.  \n\n`pass_thru_type` helps with the boiler-plate of boxing/unboxing the required `MemInfoPointer`. The `PyObject` \npassed into the unboxer can be unboxed directly into a `pass_thru_type`. On the way out the original `PyObject` is \nrecovered  by boxing the `pass_thru_type`. \n\n```python\nfrom numba import cgutils\nfrom numba.datamodel import models\nfrom numba.extending import make_attribute_wrapper, overload, overload_method, register_model\nfrom numba.pythonapi import NativeValue, unbox, box\nfrom numba.targets.hashing import _Py_hash_t\n\nfrom numba_passthru import pass_thru_type\n\n@register_model(TesteeType)\nclass TesteeModel(models.StructModel):\n    def __init__(self, dmm, fe_typ):\n        members = [\n            ('parent', pass_thru_type),\n            ('value', types.intp),\n        ]\n        super(TesteeModel, self).__init__(dmm, fe_typ, members)\n        \nmake_attribute_wrapper(TesteeType, 'value', 'value')\n\n@unbox(TesteeType)\ndef unbox_testee(typ, obj, context):\n    testee = cgutils.create_struct_proxy(typ)(context.context, context.builder)\n    \n    testee.parent = context.unbox(pass_thru_type, obj).value\n    \n    value = context.pyapi.object_getattr_string(obj, \"value\")\n    native_value = context.unbox(types.intp, value)\n    context.pyapi.decref(value)\n\n    testee.value = native_value.value\n\n    is_error = cgutils.is_not_null(context.builder, context.pyapi.err_occurred())\n    return NativeValue(testee._getvalue(), is_error=is_error)\n    \n@box(TesteeType)\ndef box_testee(typ, val, context):\n    val = cgutils.create_struct_proxy(typ)(context.context, context.builder, value=val)\n    obj = context.box(pass_thru_type, val.parent)\n\n    return obj\n```\nGiven the implementation above `TesteeType` is immutable from `nopython` (`make_attribute_wrapper` creates read-only\nattributes). If you made a pass-through type mutable from `nopython` you had to make sure to reflect changes back\nto the Python object in the boxer. However, given the [experience with reflected lists and sets](http://numba.pydata.org/numba-doc/latest/reference/deprecation.html#deprecation-of-reflection-for-list-and-set-types)\nthere are good reasons to be careful with this. \n\nUpward compatibility notice\n---------------------------\nThis is a stand-alone version of Numba [PR 3640](https://github.com/numba/numba/pull/3640). Import of\n`PassThruType`, `pass_thru_type`, `PassThruContainer`, `pass_thru_container_type` from `numba` is attempted first \nhence you will get the Numba internal implementations once the PR has landed.\n\nThis package contains two overloads that might break future Numba versions if Numba created diverging implementations:\n1. `int(Opaque)`\n2. `operator.is_(Opaque, Opaque)`\n\nThis was considered too unlikely to put a version constraint on the Numba dependency (which would require a new release\nof `numba-passthru` every time a new Numba versions is released)\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "numba", "license": "", "maintainer": "", "maintainer_email": "", "name": "numba-passthru", "package_url": "https://pypi.org/project/numba-passthru/", "platform": "", "project_url": "https://pypi.org/project/numba-passthru/", "project_urls": null, "release_url": "https://pypi.org/project/numba-passthru/0.2.0/", "requires_dist": ["numba"], "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*", "summary": "Stand-alone package for Numba passthrough types until PR 3640 has landed", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Pass-through type for Numba</h1>\n<p>Tools to ferry arbitrary Python objects through <code>nopython</code> mode. This is a stand-alone version of the Numba internal\nimplementation <a href=\"https://github.com/numba/numba/pull/3640\" rel=\"nofollow\">PR 3640</a>.</p>\n<p>This has two typical use-cases:</p>\n<ol>\n<li>ferrying data structures not currently supported by Numba into <code>objmode</code> blocks via <code>PassThruContainer</code></li>\n<li>creating extension types that are simplified representations of the Python class and keep a link to the\nPython object</li>\n</ol>\n<p>It's not unlikely both can be avoided completely when starting from scratch but potentially require extensive\nrefactoring when moving Numba into an existing code base.</p>\n<h2>Ferrying objects into <code>objmode</code> using <code>PassThruContainer</code></h2>\n<p><code>PassThruContainer</code> can be used to make Python objects not supported by <code>nopython</code> available inside\n<code>objmode</code> blocks. Outside <code>objmode</code> blocks the only supported operation on <code>PassThruContainer</code>\nis <code>==</code>. Two instances are equal if the wrapped objects are identical, ie <code>a.obj is b.obj</code>.</p>\n<p>In the following example an object unsupported in <code>nopython</code> is ferried into an <code>objmode</code> block and\nmutated there.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"kn\">import</span> <span class=\"n\">annotations</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numba</span> <span class=\"kn\">import</span> <span class=\"n\">jit</span><span class=\"p\">,</span> <span class=\"n\">objmode</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numba_passthru</span> <span class=\"kn\">import</span> <span class=\"n\">PassThruContainer</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Testee</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">invert</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">numba_will_not_like_this</span> <span class=\"o\">=</span> <span class=\"nb\">compile</span><span class=\"p\">(</span><span class=\"s1\">'pass'</span><span class=\"p\">,</span> <span class=\"s1\">'N/A'</span><span class=\"p\">,</span> <span class=\"s1\">'single'</span><span class=\"p\">)</span>\n        \n    <span class=\"k\">def</span> <span class=\"fm\">__gt__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>    <span class=\"c1\"># will be used in next example</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">&gt;</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">value</span>\n\n<span class=\"n\">testee</span> <span class=\"o\">=</span> <span class=\"n\">Testee</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>  \n<span class=\"n\">container</span> <span class=\"o\">=</span> <span class=\"n\">PassThruContainer</span><span class=\"p\">(</span><span class=\"n\">testee</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@jit</span><span class=\"p\">(</span><span class=\"n\">nopython</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">do_something</span><span class=\"p\">(</span><span class=\"n\">container</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">objmode</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"s1\">'int64'</span><span class=\"p\">):</span>\n        <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"n\">container</span><span class=\"o\">.</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"s1\">'value_2'</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">container</span><span class=\"o\">.</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">value</span>\n        \n    <span class=\"k\">return</span> <span class=\"n\">container</span><span class=\"p\">,</span> <span class=\"n\">value</span>\n    \n<span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">do_something</span><span class=\"p\">(</span><span class=\"n\">container</span><span class=\"p\">)</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">container</span> <span class=\"ow\">is</span> <span class=\"n\">result</span>\n<span class=\"k\">assert</span> <span class=\"n\">value</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n<span class=\"k\">assert</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">value_2</span> <span class=\"o\">==</span> <span class=\"mi\">2</span>\n</pre>\n<p>There will be no speed-up for the code inside the <code>objmode</code> block and <code>container</code> is (un)boxed twice adding further\noverhead. Hence, this only makes sense in rarely visited code-path and if refactoring into a more Numba friendly\nform is not an option.</p>\n<p>Note that the example above already contains the most common pattern that is pretty unpleasant to refactor into a\nNumba friendly form in requiring object identity being preserved through <code>nopython</code> (<code>assert container is result</code>).\nObviously, this is a highly artificial requirement in this toy example but might get more real if the pass-through\nobject is part of conditional branches.</p>\n<h2>Creating custom passthrough types</h2>\n<p><code>PassThroughContainer</code> does not allow attribute access on the wrapped object in <code>nopython</code> and there is no way\nto dispatch on the type of the wrapped object. To get both you can create a Numba extension type using <code>pass_thru_type</code>.\n<code>pass_thru_type</code> holds a pointer to the <code>PyObject</code> and manages references. <code>pass_thru_type</code> can be used like any\nmem-managed member on an <a href=\"http://numba.pydata.org/numba-doc/latest/extending/index.html\" rel=\"nofollow\">extension type</a>. (Some\nfamiliarity with Numba extension types is expected for the following.)</p>\n<p>Continuing the example above let's try to get the following code working in <code>nopython</code> (another toy\nexample, no speed-up expected):</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">find_max</span><span class=\"p\">(</span><span class=\"n\">testees</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Testee</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Testee</span><span class=\"p\">:</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">testees</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># testees must not be empty</span>\n    <span class=\"k\">for</span> <span class=\"n\">testee</span> <span class=\"ow\">in</span> <span class=\"n\">testees</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]:</span>\n        <span class=\"k\">if</span> <span class=\"n\">testee</span> <span class=\"o\">&gt;</span> <span class=\"n\">result</span><span class=\"p\">:</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">testee</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">result</span>     \n</pre>\n<p><code>PassThroughContainer</code> will not help here as there would be no way to dispatch <code>&gt;</code>  to <code>Testee.__gt__</code> and there would\nbe no way to access <code>.value</code> from <code>nopython</code> inside <code>Testee.__gt__</code>. Still, since <code>Testee.value</code> is the only attribute\nbeing accessed from <code>nopython</code> there is a realistic chance to get this working. Indeed, assuming we already had the\n(un)boxer this is a straight forward Numba extension type:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">numba</span> <span class=\"kn\">import</span> <span class=\"n\">jit</span><span class=\"p\">,</span> <span class=\"n\">types</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numba.extending</span> <span class=\"kn\">import</span> <span class=\"n\">overload</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numba.typing.typeof</span> <span class=\"kn\">import</span> <span class=\"n\">typeof_impl</span>\n<span class=\"kn\">import</span> <span class=\"nn\">operator</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">TesteeType</span><span class=\"p\">(</span><span class=\"n\">PassThruType</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">TesteeType</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'Testee'</span><span class=\"p\">)</span>\n\n<span class=\"n\">testee_type</span> <span class=\"o\">=</span> <span class=\"n\">TesteeType</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@typeof_impl</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">Testee</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">type_testee</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">testee_type</span>\n\n<span class=\"nd\">@overload</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">gt</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">testee_gt</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"bp\">self</span> <span class=\"ow\">is</span> <span class=\"n\">testee_type</span> <span class=\"ow\">and</span> <span class=\"n\">other</span> <span class=\"ow\">is</span> <span class=\"n\">testee_type</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">Testee</span><span class=\"o\">.</span><span class=\"fm\">__gt__</span>\n\n<span class=\"n\">find_max</span> <span class=\"o\">=</span> <span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">nopython</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)(</span><span class=\"n\">find_max</span><span class=\"p\">)</span>\n</pre>\n<p>Trying to implement the (un)boxer to somehow pass the <code>.numba_will_not_like_this</code> attribute around <code>nopython</code> (sharing\na dict between boxer/unboxer etc) is not straight forward to get working for <code>find_max</code> alone and it is impossible\nto get the reference counting right in the general case. The clean approach is to have the Numba runtime manage the\nreferences by putting a NRT managed reference to the original Python object onto the extension type's data model.</p>\n<p><code>pass_thru_type</code> helps with the boiler-plate of boxing/unboxing the required <code>MemInfoPointer</code>. The <code>PyObject</code>\npassed into the unboxer can be unboxed directly into a <code>pass_thru_type</code>. On the way out the original <code>PyObject</code> is\nrecovered  by boxing the <code>pass_thru_type</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">numba</span> <span class=\"kn\">import</span> <span class=\"n\">cgutils</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numba.datamodel</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numba.extending</span> <span class=\"kn\">import</span> <span class=\"n\">make_attribute_wrapper</span><span class=\"p\">,</span> <span class=\"n\">overload</span><span class=\"p\">,</span> <span class=\"n\">overload_method</span><span class=\"p\">,</span> <span class=\"n\">register_model</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numba.pythonapi</span> <span class=\"kn\">import</span> <span class=\"n\">NativeValue</span><span class=\"p\">,</span> <span class=\"n\">unbox</span><span class=\"p\">,</span> <span class=\"n\">box</span>\n<span class=\"kn\">from</span> <span class=\"nn\">numba.targets.hashing</span> <span class=\"kn\">import</span> <span class=\"n\">_Py_hash_t</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">numba_passthru</span> <span class=\"kn\">import</span> <span class=\"n\">pass_thru_type</span>\n\n<span class=\"nd\">@register_model</span><span class=\"p\">(</span><span class=\"n\">TesteeType</span><span class=\"p\">)</span>\n<span class=\"k\">class</span> <span class=\"nc\">TesteeModel</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">StructModel</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">dmm</span><span class=\"p\">,</span> <span class=\"n\">fe_typ</span><span class=\"p\">):</span>\n        <span class=\"n\">members</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n            <span class=\"p\">(</span><span class=\"s1\">'parent'</span><span class=\"p\">,</span> <span class=\"n\">pass_thru_type</span><span class=\"p\">),</span>\n            <span class=\"p\">(</span><span class=\"s1\">'value'</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">intp</span><span class=\"p\">),</span>\n        <span class=\"p\">]</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">TesteeModel</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"n\">dmm</span><span class=\"p\">,</span> <span class=\"n\">fe_typ</span><span class=\"p\">,</span> <span class=\"n\">members</span><span class=\"p\">)</span>\n        \n<span class=\"n\">make_attribute_wrapper</span><span class=\"p\">(</span><span class=\"n\">TesteeType</span><span class=\"p\">,</span> <span class=\"s1\">'value'</span><span class=\"p\">,</span> <span class=\"s1\">'value'</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@unbox</span><span class=\"p\">(</span><span class=\"n\">TesteeType</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">unbox_testee</span><span class=\"p\">(</span><span class=\"n\">typ</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"p\">):</span>\n    <span class=\"n\">testee</span> <span class=\"o\">=</span> <span class=\"n\">cgutils</span><span class=\"o\">.</span><span class=\"n\">create_struct_proxy</span><span class=\"p\">(</span><span class=\"n\">typ</span><span class=\"p\">)(</span><span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">context</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">builder</span><span class=\"p\">)</span>\n    \n    <span class=\"n\">testee</span><span class=\"o\">.</span><span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">unbox</span><span class=\"p\">(</span><span class=\"n\">pass_thru_type</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">value</span>\n    \n    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">pyapi</span><span class=\"o\">.</span><span class=\"n\">object_getattr_string</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"s2\">\"value\"</span><span class=\"p\">)</span>\n    <span class=\"n\">native_value</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">unbox</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">intp</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n    <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">pyapi</span><span class=\"o\">.</span><span class=\"n\">decref</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n\n    <span class=\"n\">testee</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">native_value</span><span class=\"o\">.</span><span class=\"n\">value</span>\n\n    <span class=\"n\">is_error</span> <span class=\"o\">=</span> <span class=\"n\">cgutils</span><span class=\"o\">.</span><span class=\"n\">is_not_null</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">builder</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">pyapi</span><span class=\"o\">.</span><span class=\"n\">err_occurred</span><span class=\"p\">())</span>\n    <span class=\"k\">return</span> <span class=\"n\">NativeValue</span><span class=\"p\">(</span><span class=\"n\">testee</span><span class=\"o\">.</span><span class=\"n\">_getvalue</span><span class=\"p\">(),</span> <span class=\"n\">is_error</span><span class=\"o\">=</span><span class=\"n\">is_error</span><span class=\"p\">)</span>\n    \n<span class=\"nd\">@box</span><span class=\"p\">(</span><span class=\"n\">TesteeType</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">box_testee</span><span class=\"p\">(</span><span class=\"n\">typ</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"p\">):</span>\n    <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">cgutils</span><span class=\"o\">.</span><span class=\"n\">create_struct_proxy</span><span class=\"p\">(</span><span class=\"n\">typ</span><span class=\"p\">)(</span><span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">context</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">builder</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">val</span><span class=\"p\">)</span>\n    <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">box</span><span class=\"p\">(</span><span class=\"n\">pass_thru_type</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"o\">.</span><span class=\"n\">parent</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">obj</span>\n</pre>\n<p>Given the implementation above <code>TesteeType</code> is immutable from <code>nopython</code> (<code>make_attribute_wrapper</code> creates read-only\nattributes). If you made a pass-through type mutable from <code>nopython</code> you had to make sure to reflect changes back\nto the Python object in the boxer. However, given the <a href=\"http://numba.pydata.org/numba-doc/latest/reference/deprecation.html#deprecation-of-reflection-for-list-and-set-types\" rel=\"nofollow\">experience with reflected lists and sets</a>\nthere are good reasons to be careful with this.</p>\n<h2>Upward compatibility notice</h2>\n<p>This is a stand-alone version of Numba <a href=\"https://github.com/numba/numba/pull/3640\" rel=\"nofollow\">PR 3640</a>. Import of\n<code>PassThruType</code>, <code>pass_thru_type</code>, <code>PassThruContainer</code>, <code>pass_thru_container_type</code> from <code>numba</code> is attempted first\nhence you will get the Numba internal implementations once the PR has landed.</p>\n<p>This package contains two overloads that might break future Numba versions if Numba created diverging implementations:</p>\n<ol>\n<li><code>int(Opaque)</code></li>\n<li><code>operator.is_(Opaque, Opaque)</code></li>\n</ol>\n<p>This was considered too unlikely to put a version constraint on the Numba dependency (which would require a new release\nof <code>numba-passthru</code> every time a new Numba versions is released)</p>\n\n          </div>"}, "last_serial": 6162532, "releases": {"0.2.0": [{"comment_text": "", "digests": {"md5": "13d778910df025f3bbe9373a6410a82a", "sha256": "a52acb01c10ed9d90eefa8115ee26e8398e23709785b7d4c5b05130987460bad"}, "downloads": -1, "filename": "numba_passthru-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "13d778910df025f3bbe9373a6410a82a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*", "size": 10714, "upload_time": "2019-11-19T15:19:17", "upload_time_iso_8601": "2019-11-19T15:19:17.410789Z", "url": "https://files.pythonhosted.org/packages/f2/71/c8b4496c2c3b4b928a9b37878a79eac2a63016c7695a1a9af78984a66578/numba_passthru-0.2.0-py2.py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "13d778910df025f3bbe9373a6410a82a", "sha256": "a52acb01c10ed9d90eefa8115ee26e8398e23709785b7d4c5b05130987460bad"}, "downloads": -1, "filename": "numba_passthru-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "13d778910df025f3bbe9373a6410a82a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*", "size": 10714, "upload_time": "2019-11-19T15:19:17", "upload_time_iso_8601": "2019-11-19T15:19:17.410789Z", "url": "https://files.pythonhosted.org/packages/f2/71/c8b4496c2c3b4b928a9b37878a79eac2a63016c7695a1a9af78984a66578/numba_passthru-0.2.0-py2.py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 00:44:17 2020"}