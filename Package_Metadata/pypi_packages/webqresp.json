{"info": {"author": "Denis Ryzhkov", "author_email": "denisr@denisr.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Topic :: Software Development :: Testing :: Traffic Generation"], "description": "Hence name: WEB Quick RESPonse.\n\nInstall::\n\n    sudo apt-get install --yes gcc libevent-dev python-dev python-pip\n    sudo pip install webqresp\n\nUsage::\n\n    webqresp http://example.com/\n    webqresp --repeat=3 --start=5 --response-seconds=0.5 --header='X-Name: Value' --content='{\"name\": \"value\"}' --method=POST http://example.com/some/page\n\n* ``--repeat`` - Number of times to repeat the test, showing aggregated stats in the end. Default: ``1``.\n* ``--start`` - Number of concurrent requests to start with. Default: ``1``.\n* ``--response-seconds`` - Maximal response time in seconds for each request to pass the test. Default: ``1``.\n* ``--header`` - Additional headers, e.g. ``--header='Content-Type: application/json' --header='X-Name: Value'``.\n* ``--content`` - Content for ``POST``, etc. E.g. ``'name1=value1&name2=value2'`` or ``'{\"name1\": \"value1\", \"name2\": \"value2\"}'``.\n* ``--method`` - HTTP Method. Default: ``GET``.\n* ``url`` - URL to test, e.g. ``http://example.com/some/page``.\n\nCriterion:\n\n    Maximal number of concurrent requests to the slowest URL\n    while each request gets successful response within a second.\n\nWhy:\n\n* Popular criterion Requests Per Second (RPS, req/s) has a great flaw of being confusing when comparing measurement before and after optimization. Please see `explanation <http://www.therailsway.com/2009/1/6/requests-per-second/>`_.\n* Another criterion - Milliseconds Per Request (ms/req) calculated as 1000/(req/s) as proposed in the article above also has flaws:\n    * It shows real response duration experienced by a user only when requests are sent sequentially, not concurrently:\n        * Let's take 100,000 requests and send them to a server in a sequence, waiting for each response before sending the next request. If server processes all this in 10 seconds, it is giving 10,000 req/s, and each request gets response in 0.1 ms - great!\n        * Now let's send 100,000 requests at the same time, not waiting for responses. If server processes all this in 10 seconds, it is giving the same 10,000 req/s, however while this criterion still shows false 0.1 ms, each request may get response in up to 10 seconds - that is not acceptable.\n    * It still keeps proportion ambiguity:\n        * Let's take 10,000 req/s == 0.1 ms/req == 10,000 concurrent requests with 1 second for each response - this is acceptable.\n        * The same 10,000 req/s == 0.1 ms/req == 100,000 requests with 10 seconds for each response - this is not acceptable.\n* Our criterion is constructed so that:\n    * It cares about real response duration for each user in the worst concurrent case.\n    * It is not a proportion. It is not ambiguous. Once 1 second is reached or failure occurs, it stops incrementing concurrent requests and returns the result.\n* Single slowest URL is chosen to save time configuring the tool, because anyway \"A chain is only as strong as its weakest link\".", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/denis-ryzhkov/webqresp", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "webqresp", "package_url": "https://pypi.org/project/webqresp/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/webqresp/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/denis-ryzhkov/webqresp"}, "release_url": "https://pypi.org/project/webqresp/0.1.1/", "requires_dist": null, "requires_python": null, "summary": "Web load test measuring how many concurrent users will get response to their actions quickly - within a second.", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Hence name: WEB Quick RESPonse.</p>\n<p>Install:</p>\n<pre>sudo apt-get install --yes gcc libevent-dev python-dev python-pip\nsudo pip install webqresp\n</pre>\n<p>Usage:</p>\n<pre>webqresp http://example.com/\nwebqresp --repeat=3 --start=5 --response-seconds=0.5 --header='X-Name: Value' --content='{\"name\": \"value\"}' --method=POST http://example.com/some/page\n</pre>\n<ul>\n<li><tt><span class=\"pre\">--repeat</span></tt> - Number of times to repeat the test, showing aggregated stats in the end. Default: <tt>1</tt>.</li>\n<li><tt><span class=\"pre\">--start</span></tt> - Number of concurrent requests to start with. Default: <tt>1</tt>.</li>\n<li><tt><span class=\"pre\">--response-seconds</span></tt> - Maximal response time in seconds for each request to pass the test. Default: <tt>1</tt>.</li>\n<li><tt><span class=\"pre\">--header</span></tt> - Additional headers, e.g. <tt><span class=\"pre\">--header='Content-Type:</span> application/json' <span class=\"pre\">--header='X-Name:</span> Value'</tt>.</li>\n<li><tt><span class=\"pre\">--content</span></tt> - Content for <tt>POST</tt>, etc. E.g. <tt>'name1=value1&amp;name2=value2'</tt> or <tt><span class=\"pre\">'{\"name1\":</span> \"value1\", \"name2\": <span class=\"pre\">\"value2\"}'</span></tt>.</li>\n<li><tt><span class=\"pre\">--method</span></tt> - HTTP Method. Default: <tt>GET</tt>.</li>\n<li><tt>url</tt> - URL to test, e.g. <tt><span class=\"pre\">http://example.com/some/page</span></tt>.</li>\n</ul>\n<p>Criterion:</p>\n<blockquote>\nMaximal number of concurrent requests to the slowest URL\nwhile each request gets successful response within a second.</blockquote>\n<p>Why:</p>\n<ul>\n<li>Popular criterion Requests Per Second (RPS, req/s) has a great flaw of being confusing when comparing measurement before and after optimization. Please see <a href=\"http://www.therailsway.com/2009/1/6/requests-per-second/\" rel=\"nofollow\">explanation</a>.</li>\n<li><dl>\n<dt>Another criterion - Milliseconds Per Request (ms/req) calculated as 1000/(req/s) as proposed in the article above also has flaws:</dt>\n<dd><ul>\n<li><dl>\n<dt>It shows real response duration experienced by a user only when requests are sent sequentially, not concurrently:</dt>\n<dd><ul>\n<li>Let\u2019s take 100,000 requests and send them to a server in a sequence, waiting for each response before sending the next request. If server processes all this in 10 seconds, it is giving 10,000 req/s, and each request gets response in 0.1 ms - great!</li>\n<li>Now let\u2019s send 100,000 requests at the same time, not waiting for responses. If server processes all this in 10 seconds, it is giving the same 10,000 req/s, however while this criterion still shows false 0.1 ms, each request may get response in up to 10 seconds - that is not acceptable.</li>\n</ul>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt>It still keeps proportion ambiguity:</dt>\n<dd><ul>\n<li>Let\u2019s take 10,000 req/s == 0.1 ms/req == 10,000 concurrent requests with 1 second for each response - this is acceptable.</li>\n<li>The same 10,000 req/s == 0.1 ms/req == 100,000 requests with 10 seconds for each response - this is not acceptable.</li>\n</ul>\n</dd>\n</dl>\n</li>\n</ul>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt>Our criterion is constructed so that:</dt>\n<dd><ul>\n<li>It cares about real response duration for each user in the worst concurrent case.</li>\n<li>It is not a proportion. It is not ambiguous. Once 1 second is reached or failure occurs, it stops incrementing concurrent requests and returns the result.</li>\n</ul>\n</dd>\n</dl>\n</li>\n<li>Single slowest URL is chosen to save time configuring the tool, because anyway \u201cA chain is only as strong as its weakest link\u201d.</li>\n</ul>\n\n          </div>"}, "last_serial": 725481, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "91d71b19226dbbcc43f0ea229880f516", "sha256": "b4b815d13ba57127b543397c4c269331061992e15e937d143b6a04fa0b6c166b"}, "downloads": -1, "filename": "webqresp-0.1.0.tar.gz", "has_sig": false, "md5_digest": "91d71b19226dbbcc43f0ea229880f516", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3420, "upload_time": "2013-03-26T08:39:55", "upload_time_iso_8601": "2013-03-26T08:39:55.183217Z", "url": "https://files.pythonhosted.org/packages/75/61/52baf4d2df026a6f8bbe6cf88a7caf927d322d7bdeb618afcd137f6344bb/webqresp-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "f96da3413162a0e19fdd85c13472d0bb", "sha256": "9d7aa28badadc90dfc69853a984140f51022320b173530c382e0aa7615aaf683"}, "downloads": -1, "filename": "webqresp-0.1.1.tar.gz", "has_sig": false, "md5_digest": "f96da3413162a0e19fdd85c13472d0bb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3473, "upload_time": "2013-03-28T11:41:31", "upload_time_iso_8601": "2013-03-28T11:41:31.313970Z", "url": "https://files.pythonhosted.org/packages/af/a8/930b5ce46136c59ecd2a87ce917f364bdcb853e622bfd5b5b97f0ded9054/webqresp-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f96da3413162a0e19fdd85c13472d0bb", "sha256": "9d7aa28badadc90dfc69853a984140f51022320b173530c382e0aa7615aaf683"}, "downloads": -1, "filename": "webqresp-0.1.1.tar.gz", "has_sig": false, "md5_digest": "f96da3413162a0e19fdd85c13472d0bb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3473, "upload_time": "2013-03-28T11:41:31", "upload_time_iso_8601": "2013-03-28T11:41:31.313970Z", "url": "https://files.pythonhosted.org/packages/af/a8/930b5ce46136c59ecd2a87ce917f364bdcb853e622bfd5b5b97f0ded9054/webqresp-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:30:52 2020"}