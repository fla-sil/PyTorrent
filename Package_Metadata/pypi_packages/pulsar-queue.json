{"info": {"author": "Luca Sbardella", "author_email": "luca@quantmind.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Utilities"], "description": "|pulsar-queue|\n\n:Badges: |license|  |pyversions| |status| |pypiversion|\n:Master CI: |master-build| |coverage-master|\n:Downloads: http://pypi.python.org/pypi/pulsar-queue\n:Source: https://github.com/quantmind/pulsar-queue\n:Mailing list: `google user group`_\n:Design by: `Quantmind`_ and `Luca Sbardella`_\n:Platforms: Linux, OSX, Windows. Python 3.5 and above\n:Keywords: server, asynchronous, concurrency, actor, process, queue, tasks, redis\n\n\n.. |pypiversion| image:: https://badge.fury.io/py/pulsar-queue.svg\n  :target: https://pypi.python.org/pypi/pulsar-queue\n.. |pyversions| image:: https://img.shields.io/pypi/pyversions/pulsar-queue.svg\n  :target: https://pypi.python.org/pypi/pulsar-queue\n.. |license| image:: https://img.shields.io/pypi/l/pulsar-queue.svg\n  :target: https://pypi.python.org/pypi/pulsar-queue\n.. |status| image:: https://img.shields.io/pypi/status/pulsar-queue.svg\n  :target: https://pypi.python.org/pypi/pulsar-queue\n.. |downloads| image:: https://img.shields.io/pypi/dd/pulsar-queue.svg\n  :target: https://pypi.python.org/pypi/pulsar-queue\n.. |master-build| image:: https://img.shields.io/travis/quantmind/pulsar-queue/master.svg\n  :target: https://travis-ci.org/quantmind/pulsar-queue\n.. |dev-build| image:: https://img.shields.io/travis/quantmind/pulsar-queue/dev.svg\n  :target: https://travis-ci.org/quantmind/pulsar-queue?branch=dev\n.. |coverage-master| image:: https://coveralls.io/repos/github/quantmind/pulsar-queue/badge.svg?branch=master\n  :target: https://coveralls.io/github/quantmind/pulsar-queue?branch=master\n.. |coverage-dev| image:: https://coveralls.io/repos/github/quantmind/pulsar-queue/badge.svg?branch=dev\n  :target: https://coveralls.io/github/quantmind/pulsar-queue?branch=dev\n\n\nAsynchronous server for consuming asynchronous IO tasks, green IO tasks,\nblocking IO tasks and long running CPU bound tasks.\n\n* Fully configurable\n* Consumers poll tasks from distributed message brokers (redis broker implemented)\n* Publish/subscribe for real-time event and logging (redis pub/sub backend)\n* Can schedule tasks when run as a scheduler (``--schedule-periodic`` flag)\n* Build on top of pulsar_ and asyncio_\n\n\nTL;DR\n========\n\nClone the repository::\n\n    git clone git@github.com:quantmind/pulsar-queue.git\n\n\nMove to the ``tests/example`` directory and run the server::\n\n    python manage.py\n\n\n\n.. contents:: **CONTENTS**\n\n\nFour steps tutorial\n========================\n\n1 - Create a script\n----------------------\n\nA simple python file which runs your application:\n\n.. code::\n\n    vim manage.py\n\n\n.. code:: python\n\n    from pq.api import PusarQueue\n\n\n    task_paths = ['sampletasks.*', 'pq.jobs']\n\n\n    def app():\n        return PusarQueue(config=__file__)\n\n    if __name__ == '__main__':\n        app().start()\n\n\n2 - Implement Jobs\n---------------------\n\nCreate the modules where Jobs_ are implemented.\nIt can be a directory containing several submodules.\n\n.. code::\n\n    mkdir sampletasks\n    cd sampletasks\n    vim mytasks.py\n\n.. code:: python\n\n    import asyncio\n    import time\n\n    from pq import api\n\n\n    @api.job()\n    def addition(self, a=0, b=0):\n        return a + b\n\n\n    @api.job()\n    async def asynchronous(self, lag=1):\n        start = time.time()\n        await asyncio.sleep(lag)\n        return time.time() - start\n\n\n3 - Run the server\n---------------------\n\nRun the server with two task consumers (pulsar actors).\n\n**NOTE**: Make sure you have Redis server up and running before you start the server.\n\n.. code::\n\n    python manage.py -w 2\n\n4 - Queue tasks\n---------------------\n\nLaunch a python shell and play with the api\n\n.. code:: python\n\n    >>> from manage import app\n    >>> api = app().api()\n    >>> task = api.tasks.queue('addition', a=4, b=6)\n    >>> task\n    <TaskFuture pending ID=i26ad5c14c5bb422e87b0f7ccbce5ba06>\n    >>> task = task.wait()\n    task.addition<i24ab99ddf2744902a375e039790dcbc4><SUCCESS>\n    >>> task.result\n    10\n    >>> task.status_string\n    'SUCCESS'\n\nYou can also queue tasks with a ``delay``\n\n.. code:: python\n\n    >>> task = api.tasks.queue('addition', a=4, b=6, callback=False, delay=2).wait()\n    >>> task.status_string\n    'QUEUED'\n    >>> task.time_queued    # timestamp\n    >>> task = task.done_callback.wait()\n    >>> task.status_string\n    'SUCCESS'\n    >>> task.time_started - task.time_queued\n    2.00\n\n**NOTE**: The ``wait`` method in a task future can only be used on the shell\nor when the event loop is not running. In all other cases one should ``await``\nfor the task future in a coroutine.\n\nAPI\n=============\n\nThe producer API is obtained from the Task application ``api`` method:\n\n.. code:: python\n\n    from pq.api import PusarQueue\n\n    api = PusarQueue(...).api()\n\n\nAPI methods\n---------------\n\n*api*.start()\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nStart listening to events. This method return a coroutine which resolve in the api:\n\n.. code:: python\n\n    api = await api.start()\n\nThe start method is used when the api is used by application to queue messages/tasks\nand listen for events published by distributed consumers.\n\n*api*.on_events(*message_type*, *event_re*, *callback*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAdd a callback invoked every time an event matching the regular expression ``event_re``\noccurs on the ``message_type`` channel. The *callback* has the following signature:\n\n.. code:: python\n\n    def event_callback(channel, event, message):\n        # event is string, the event matched\n        # message is of type message_type\n\nIf the event is a task event (see events_) the message is a Task_ object.\n\nThis method is useful when creating applications which needs to respond to the\nqueue server events in real time::\n\n    api.on_events('task', 'queued', callback)\n    api.on_events('task', 'started', callback)\n    api.on_events('task', 'done', callback)\n\n\n*api*.remove_event_callback(*message_type*, *event_re*, *callback*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRemove a previously added event callback. This method is safe.\n\n*api*.queue(*message*, *callback=True*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nQueue a message in the message queue, equivalent to:\n\n.. code:: python\n\n    api.broker.queue(message, callback)\n\nThis method returns a ``MessageFuture``, a subclass of asyncio Future_ which\nresolves in a ``message`` object.\nIf ``callback`` is True (default) the Future is resolved once the message\nis delivered (out of the queue), otherwise is is resolved once the message\nis queued (entered the queue).\n\n*api*.execute(*message*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nExecute a message without queueing. This is only supported by messages with\na message consumer which execute them (the ``tasks`` consumer for example).\nIf *message* is a Task_, this method is equivalent to:\n\n.. code:: python\n\n    api.tasks.execute(task)\n\nThis method returns a ``MessageFuture``, a subclass of asyncio Future_ which\nresolve in a ``message`` object.\n\n*api*.consumers\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nList of consumers registered with the api.\n\nTasks API\n-----------------\n\nThe tasks producer is obtained vua the ``tasks`` property from the producer API instance\n\n.. code:: python\n\n    tasks = api.tasks\n\nThe following methods are available for the tasks producer:\n\n\n*tasks*.queue(*jobname*, *\\*\\*kwargs*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nQueue a task and return a **TaskFuture** which is resolved once the task has finished.\nIt is possible to obtain a task future resolved when the task has been queued, rather than finished, by passing the **callback=False** parameter:\n\n.. code:: python\n\n    task = await tasks.queue(..., callback=False)\n    task.status_string  # QUEUED\n\nThe ``kwargs`` parameters are used as input parameters for the Job_ callable with the exception of:\n\n* ``callback``: discussed above\n* ``delay``: delay execution by a given number of seconds\n* ``queue``: overrides the Job_ [default_queue](#job-default-queue)\n* [timeout](#job-timeout)\n* ``meta_params``: dictionary of parameters used by the Job_ callable to override default values of:\n  * [max_retries](#job-max-retries)\n  * [retry_delay](#job-retry-delay)\n  * [max_concurrency](#job-max-concurrency)\n\n*tasks*.queue_local(*jobname*, *\\*\\*kwargs*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nQueue a job in the local task queue. The local task queue is processed by the same server instance. It is equivalent to execute:\n\n.. code:: python\n\n    task = await tasks.queue(..., queue=tasks.node_name)\n    task.queue  # tasks.node_name\n\n\n*tasks*.execute(*jobname*, *\\*args*, *\\*\\*kwargs*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nExecute a task immediately, it does not put the task in the task queue.\nThis method is useful for debugging and testing. It is equivalent to execute:\n\n.. code:: python\n\n    task = await tasks.queue(..., queue=False)\n    task.queue          # None\n    task.status_string  # SUCCESS\n\n\n*tasks*.queues()\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nReturn the list of queue names the backend is subscribed. This list is not empty when the backend is a task consumer.\n\n*tasks*.job_list(*jobname=None*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nReturns a list of ``job_name``, ``job_description`` tuples. The ``job_name`` is a string which must be used as the **jobname** parameter when executing or queing tasks. The ``job_description`` is a dictionary containing metadata and documentation for the job. Example:\n\n.. code:: python\n\n    jobs = dict(tasks.job_lits())\n    jobs['execute.python']\n    # {\n    #   'type': 'regular',\n    #   'concurrency': 'asyncio',\n    #   'doc_syntax': 'markdown',\n    #   'doc': 'Execute arbitrary python code on a subprocess ... '\n    # }\n\n\nThe Job class\n-----------------\n\nThe **Job** class is how task factories are implemented and added to the\ntasks backend registry. When writing a new **Job** one can either subclass:\n\n.. code:: python\n\n    import asyncio\n\n    class AsyncSleep(api.Job):\n\n        async def __call__(self, lag=1):\n            await asyncio.sleep(lag)\n\n\nor use the less verbose **job** decorator:\n\n.. code:: python\n\n    @api.job()\n    async def asyncsleep(self, lag=1):\n        await asyncio.sleep(lag)\n\n\nIn either cases the ``self`` parameter is an instance of a **Job** class and\nit has the following useful attributes and methods:\n\n*job*.backend\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe tasks backend that is processing this Task_ run\n\n*job*.default_queue\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe default queue name where tasks for this job are queued. By default it is ``None``\nin which case, if a ``queue`` is not given when queueing a task, the first queue\nfrom the `queues <#tasks_queues>`_ list taken.\n\n*job*.http\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBest possible HTTP session handler for the job concurrency mode.\n\n*job*.logger\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPython logging handler for this job. The name of this handler\nis ``<app_name>.<job.name>``.\n\n*job*.max_retries\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOptional positive integer which specify the maximum number of retries when a\ntask fails or is revoked. If not available failing tasks are not re-queued.\nIt can be specified as a class attribute or during initialisation from the task\nmeta parameters.\n\n*job*.retry_delay\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOptional positive integer which specifies the number of seconds to delay a task\nretry.\n\n*job*.name\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe name of this job. Used to queue tasks\n\n*job*.task\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe Task_ instance associated with this task run\n\n*job*.queue(*jobname*, *\\*args*, *\\*\\*kwargs*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nQueue a new job form a task run. It is equivalent to:\n\n.. code:: python\n\n    meta_params = {'from_task': self.task.id}\n    self.backend.tasks.queue(..., meta_params=meta_params)\n\n\n*job*.shell(*command*, *\\*\\*kwargs*)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nExecute a shell command and returns a coroutine:\n\n.. code:: python\n\n    await self.shell(\"...\")\n\n\nThe Task\n-----------\n\nA task contains the metadata information of a job run and it is exchanged between task producers and task consumers via a distributed task queue.\n\n\nTask States\n-----------------\n\nA Task_ can have one of the following ``task.status``:\n\n* ``QUEUED = 6`` a task queued but not yet executed.\n* ``STARTED = 5`` a task where execution has started.\n* ``RETRY = 4`` a task is retrying calculation.\n* ``REVOKED = 3`` the task execution has been revoked (or timed-out).\n* ``FAILURE = 2`` task execution has finished with failure.\n* ``SUCCESS = 1`` task execution has finished with success.\n\n\n**FULL_RUN_STATES**\n\nThe set of states for which a Task_ has run: ``FAILURE`` and ``SUCCESS``\n\n\n**READY_STATES**\n\nThe set of states for which a Task_ has finished: ``REVOKED``, ``FAILURE`` and ``SUCCESS``\n\nEvents\n-------------\n\nThe task queue broadcast several events during task execution and internal state:\n\n* ``task_queued``: a new Task_ has been queued, the message is a task instance\n* ``task_started``: a Task_ has started to be consumed by a task consumer, it is out of the task queue\n* ``task_done``: a Task_ is done, the message is a task in a **READY_STATES**\n\n\nConfiguration\n------------------\n\nThere are several parameters you can use to twick the way the task queue works.\nIn this list the name in bold is the entry point in the config file and **cfg**\ndictionary, while, the value between brackets shows the command line entry with default\nvalue.\n\n* **concurrent_tasks** (``--concurrent-tasks 5``)\n\n    The maximum number of concurrent tasks for a given worker in a task consumer server.\n\n* **data_store** (``--data-store redis://127.0.0.1:6379/7``)\n\n    Data store used for publishing and subscribing to messages (redis is the\n    only backend available at the moment)\n\n* **max_requests** (``--max-requests 0``)\n\n    The maximum number of tasks a worker will process before restarting.\n    A 0 value (the default) means no maximum number, workers will process\n    all tasks forever.\n\n* **message_broker** (``--message-broker ...``)\n\n    Data store used as distributed task queue. If not provided (default) the\n    ``data_store`` is used instead. Redis is the\n    only backend available at the moment.\n\n* **message_serializer** (``--message-serializer json``)\n\n    The decoder/encoder for messages and tasks. The default is **JSON** but **Message Pack**\n    is also available if msgpack_ is installed.\n\n* **schedule_periodic** (``--schedule-periodic``)\n\n    When ``True``, the task application can schedule periodic Jobs_.\n    Usually, only one running server is responsible for\n    scheduling tasks.\n\n* **task_pool_timeout** (``--task-pool-timeout 2``)\n\n    Timeout in seconds for asynchronously polling tasks from the queues. No need to change this parameter really.\n\n* **workers** (``--workers 4``)\n\n    Number of workers (processes) consuming tasks.\n\n\nTasks Concurrency\n======================\n\nA task can run in one of four ``concurrency`` modes.\nIf not specified by the ``Job``, the concurrency mode is ``ASYNC_IO``.\n\nASYNC_IO\n-----------\n\nThe asynchronous IO mode is associated with tasks which return\nan asyncio Future or a coroutine. These tasks run concurrently\nin the worker event loop.\nAn example can be a Job to scrape web pages and create new tasks to process the html\n\n.. code:: python\n\n    @api.job()\n    async def scrape(self, url=None):\n        assert url, \"url is required\"\n        request = await self.http.get(url)\n        html = request.text()\n        task = self.queue('process.html', html=html, callback=False)\n        return task.id\n\n\nTHREAD_IO\n-------------\n\nThis concurrency mode is best suited for tasks performing\n*blocking* IO operations.\nA ``THREAD_IO`` job runs its tasks in the event loop executor.\nYou can use this model for most blocking operation unless\n\n* Long running CPU bound\n* The operation does not release the GIL\n\nExample of tasks suitable for thread IO are IO operations on files.\nFor example the test suite uses this Job for testing ``THREAD_IO``\nconcurrency (check the ``tests.example.jobs.standard`` module\nfor the full code):\n\n\n.. code:: python\n\n    @api.job(concurrency=api.THREAD_IO)\n    def extract_docx(self, input=None, output=None):\n        \"\"\"\n        Extract text from a docx document\n        \"\"\"\n        import docx\n        assert input and output, \"input and output must be given\"\n        document = docx.Document(input)\n        text = '\\n\\n'.join(_docx_text(document))\n        with open(output, 'w') as fp:\n            fp.write(text)\n        return {\n            'thread': threading.get_ident(),\n            'text': len(text)\n        }\n\nCPUBOUND\n------------\n\nIt assumes the task performs blocking CPU bound operations.\nJobs with this consurrency mode run their tasks on sub-processeses\nusing `asyncio subprocess`_ module.\n\nExtend\n=================\n\nIt is possible to enhance the task queue application by passing\na custom ``Manager`` during initialisation.\nFor example:\n\n.. code:: python\n\n    from pq import api\n\n    class Manager(api.Manager):\n\n        async def store_message(self, message):\n            \"\"\"This method is called when a message/task is queued,\n            started and finished\n            \"\"\"\n            if message.type == 'task':\n                # save this task into a db for example\n\n        def queues(self):\n            \"\"\"List of queue names for Task consumers\n            By default it returns the node name and the task_queues\n            in the config dictionary.\n            \"\"\"\n            queues = [self.backend.node_name]\n            queues.extend(self.cfg.task_queues)\n            return queues\n\n\n    tq = PulsarQueue(Manager, ...)\n\n\nThe ``Manager`` class is initialised when the backend handler is initialised\n(on each consumer and in the scheduler).\n\nChangelog\n==============\n\n* `Versions 0.5 <https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.5.md>`_\n* `Versions 0.4 <https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.4.md>`_\n* `Versions 0.3 <https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.3.md>`_\n* `Versions 0.2 <https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.2.md>`_\n* `Versions 0.1 <https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.1.md>`_\n\nLicense\n=============\nThis software is licensed under the BSD 3-clause License. See the LICENSE\nfile in the top distribution directory for the full license text. Logo designed by Ralf Holzemer,\n`creative common license`_.\n\n\n.. _`google user group`: https://groups.google.com/forum/?fromgroups#!forum/python-pulsar\n.. _`Luca Sbardella`: http://lucasbardella.com\n.. _`Quantmind`: http://quantmind.com\n.. _`creative common license`: http://creativecommons.org/licenses/by-nc/3.0/\n.. _pulsar: https://github.com/quantmind/pulsar\n.. _asyncio: https://docs.python.org/3/library/asyncio.html\n.. _greenlet: https://greenlet.readthedocs.io/en/latest/\n.. _msgpack: https://pypi.python.org/pypi/msgpack-python\n.. _`asyncio subprocess`: https://docs.python.org/3/library/asyncio-subprocess.html\n.. _Future: https://docs.python.org/3/library/asyncio-task.html#future\n.. _Job: #the-job-class\n.. _Jobs: #the-job-class\n.. _Task: #the-task\n.. _Events: #events\n.. _events: #events\n.. |pulsar-queue| image:: https://pulsar.fluidily.com/assets/queue/pulsar-queue-banner-400-width.png\n   :target: https://github.com/quantmind/pulsar-queue\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/quantmind/pulsar-queue", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "pulsar-queue", "package_url": "https://pypi.org/project/pulsar-queue/", "platform": "", "project_url": "https://pypi.org/project/pulsar-queue/", "project_urls": {"Homepage": "https://github.com/quantmind/pulsar-queue"}, "release_url": "https://pypi.org/project/pulsar-queue/0.5.2/", "requires_dist": null, "requires_python": "", "summary": "Asynchronous task queue", "version": "0.5.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://github.com/quantmind/pulsar-queue\" rel=\"nofollow\"><img alt=\"pulsar-queue\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e9ab3a4e1dcfbb915e45532f9b05a3985b9eb8da/68747470733a2f2f70756c7361722e666c756964696c792e636f6d2f6173736574732f71756575652f70756c7361722d71756575652d62616e6e65722d3430302d77696474682e706e67\"></a></p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>Badges:</th><td><a href=\"https://pypi.python.org/pypi/pulsar-queue\" rel=\"nofollow\"><img alt=\"license\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2ee2d3dd081c5c78f8fea7f86bf1a29357849bcb/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f70756c7361722d71756575652e737667\"></a>  <a href=\"https://pypi.python.org/pypi/pulsar-queue\" rel=\"nofollow\"><img alt=\"pyversions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a8758cea46a2cc2389aee6e603fa05c44ebbd71d/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f70756c7361722d71756575652e737667\"></a> <a href=\"https://pypi.python.org/pypi/pulsar-queue\" rel=\"nofollow\"><img alt=\"status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a2d86413cfd21c51c1f173c7b1f50aa8a8b08bdf/68747470733a2f2f696d672e736869656c64732e696f2f707970692f7374617475732f70756c7361722d71756575652e737667\"></a> <a href=\"https://pypi.python.org/pypi/pulsar-queue\" rel=\"nofollow\"><img alt=\"pypiversion\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/df5757dc6f056ca7f95f45402ebc899618bab9e7/68747470733a2f2f62616467652e667572792e696f2f70792f70756c7361722d71756575652e737667\"></a></td>\n</tr>\n<tr><th>Master CI:</th><td><a href=\"https://travis-ci.org/quantmind/pulsar-queue\" rel=\"nofollow\"><img alt=\"master-build\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/eaf98a2dc2bde58871e4bcfc11b237ff418b4505/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f7175616e746d696e642f70756c7361722d71756575652f6d61737465722e737667\"></a> <a href=\"https://coveralls.io/github/quantmind/pulsar-queue?branch=master\" rel=\"nofollow\"><img alt=\"coverage-master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/04e619099b9b138bf79d74880fd3e411b29f6f92/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f7175616e746d696e642f70756c7361722d71756575652f62616467652e7376673f6272616e63683d6d6173746572\"></a></td>\n</tr>\n<tr><th>Downloads:</th><td><a href=\"http://pypi.python.org/pypi/pulsar-queue\" rel=\"nofollow\">http://pypi.python.org/pypi/pulsar-queue</a></td>\n</tr>\n<tr><th>Source:</th><td><a href=\"https://github.com/quantmind/pulsar-queue\" rel=\"nofollow\">https://github.com/quantmind/pulsar-queue</a></td>\n</tr>\n<tr><th>Mailing list:</th><td><a href=\"https://groups.google.com/forum/?fromgroups#!forum/python-pulsar\" rel=\"nofollow\">google user group</a></td>\n</tr>\n<tr><th>Design by:</th><td><a href=\"http://quantmind.com\" rel=\"nofollow\">Quantmind</a> and <a href=\"http://lucasbardella.com\" rel=\"nofollow\">Luca Sbardella</a></td>\n</tr>\n<tr><th>Platforms:</th><td>Linux, OSX, Windows. Python 3.5 and above</td>\n</tr>\n<tr><th>Keywords:</th><td>server, asynchronous, concurrency, actor, process, queue, tasks, redis</td>\n</tr>\n</tbody>\n</table>\n<p>Asynchronous server for consuming asynchronous IO tasks, green IO tasks,\nblocking IO tasks and long running CPU bound tasks.</p>\n<ul>\n<li>Fully configurable</li>\n<li>Consumers poll tasks from distributed message brokers (redis broker implemented)</li>\n<li>Publish/subscribe for real-time event and logging (redis pub/sub backend)</li>\n<li>Can schedule tasks when run as a scheduler (<tt><span class=\"pre\">--schedule-periodic</span></tt> flag)</li>\n<li>Build on top of <a href=\"https://github.com/quantmind/pulsar\" rel=\"nofollow\">pulsar</a> and <a href=\"https://docs.python.org/3/library/asyncio.html\" rel=\"nofollow\">asyncio</a></li>\n</ul>\n<div id=\"tl-dr\">\n<h2><a href=\"#id3\" rel=\"nofollow\">TL;DR</a></h2>\n<p>Clone the repository:</p>\n<pre>git clone git@github.com:quantmind/pulsar-queue.git\n</pre>\n<p>Move to the <tt>tests/example</tt> directory and run the server:</p>\n<pre>python manage.py\n</pre>\n<div id=\"contents\">\n<p><strong>CONTENTS</strong></p>\n<ul>\n<li><a href=\"#tl-dr\" id=\"id3\" rel=\"nofollow\">TL;DR</a></li>\n<li><a href=\"#four-steps-tutorial\" id=\"id4\" rel=\"nofollow\">Four steps tutorial</a><ul>\n<li><a href=\"#create-a-script\" id=\"id5\" rel=\"nofollow\">1 - Create a script</a></li>\n<li><a href=\"#implement-jobs\" id=\"id6\" rel=\"nofollow\">2 - Implement Jobs</a></li>\n<li><a href=\"#run-the-server\" id=\"id7\" rel=\"nofollow\">3 - Run the server</a></li>\n<li><a href=\"#queue-tasks\" id=\"id8\" rel=\"nofollow\">4 - Queue tasks</a></li>\n</ul>\n</li>\n<li><a href=\"#api\" id=\"id9\" rel=\"nofollow\">API</a><ul>\n<li><a href=\"#api-methods\" id=\"id10\" rel=\"nofollow\">API methods</a><ul>\n<li><a href=\"#api-start\" id=\"id11\" rel=\"nofollow\"><em>api</em>.start()</a></li>\n<li><a href=\"#api-on-events-message-type-event-re-callback\" id=\"id12\" rel=\"nofollow\"><em>api</em>.on_events(<em>message_type</em>, <em>event_re</em>, <em>callback</em>)</a></li>\n<li><a href=\"#api-remove-event-callback-message-type-event-re-callback\" id=\"id13\" rel=\"nofollow\"><em>api</em>.remove_event_callback(<em>message_type</em>, <em>event_re</em>, <em>callback</em>)</a></li>\n<li><a href=\"#api-queue-message-callback-true\" id=\"id14\" rel=\"nofollow\"><em>api</em>.queue(<em>message</em>, <em>callback=True</em>)</a></li>\n<li><a href=\"#api-execute-message\" id=\"id15\" rel=\"nofollow\"><em>api</em>.execute(<em>message</em>)</a></li>\n<li><a href=\"#api-consumers\" id=\"id16\" rel=\"nofollow\"><em>api</em>.consumers</a></li>\n</ul>\n</li>\n<li><a href=\"#tasks-api\" id=\"id17\" rel=\"nofollow\">Tasks API</a><ul>\n<li><a href=\"#tasks-queue-jobname-kwargs\" id=\"id18\" rel=\"nofollow\"><em>tasks</em>.queue(<em>jobname</em>, <em>**kwargs</em>)</a></li>\n<li><a href=\"#tasks-queue-local-jobname-kwargs\" id=\"id19\" rel=\"nofollow\"><em>tasks</em>.queue_local(<em>jobname</em>, <em>**kwargs</em>)</a></li>\n<li><a href=\"#tasks-execute-jobname-args-kwargs\" id=\"id20\" rel=\"nofollow\"><em>tasks</em>.execute(<em>jobname</em>, <em>*args</em>, <em>**kwargs</em>)</a></li>\n<li><a href=\"#tasks-queues\" id=\"id21\" rel=\"nofollow\"><em>tasks</em>.queues()</a></li>\n<li><a href=\"#tasks-job-list-jobname-none\" id=\"id22\" rel=\"nofollow\"><em>tasks</em>.job_list(<em>jobname=None</em>)</a></li>\n</ul>\n</li>\n<li><a href=\"#the-job-class\" id=\"id23\" rel=\"nofollow\">The Job class</a><ul>\n<li><a href=\"#job-backend\" id=\"id24\" rel=\"nofollow\"><em>job</em>.backend</a></li>\n<li><a href=\"#job-default-queue\" id=\"id25\" rel=\"nofollow\"><em>job</em>.default_queue</a></li>\n<li><a href=\"#job-http\" id=\"id26\" rel=\"nofollow\"><em>job</em>.http</a></li>\n<li><a href=\"#job-logger\" id=\"id27\" rel=\"nofollow\"><em>job</em>.logger</a></li>\n<li><a href=\"#job-max-retries\" id=\"id28\" rel=\"nofollow\"><em>job</em>.max_retries</a></li>\n<li><a href=\"#job-retry-delay\" id=\"id29\" rel=\"nofollow\"><em>job</em>.retry_delay</a></li>\n<li><a href=\"#job-name\" id=\"id30\" rel=\"nofollow\"><em>job</em>.name</a></li>\n<li><a href=\"#job-task\" id=\"id31\" rel=\"nofollow\"><em>job</em>.task</a></li>\n<li><a href=\"#job-queue-jobname-args-kwargs\" id=\"id32\" rel=\"nofollow\"><em>job</em>.queue(<em>jobname</em>, <em>*args</em>, <em>**kwargs</em>)</a></li>\n<li><a href=\"#job-shell-command-kwargs\" id=\"id33\" rel=\"nofollow\"><em>job</em>.shell(<em>command</em>, <em>**kwargs</em>)</a></li>\n</ul>\n</li>\n<li><a href=\"#the-task\" id=\"id34\" rel=\"nofollow\">The Task</a></li>\n<li><a href=\"#task-states\" id=\"id35\" rel=\"nofollow\">Task States</a></li>\n<li><a href=\"#events\" id=\"id36\" rel=\"nofollow\">Events</a></li>\n<li><a href=\"#configuration\" id=\"id37\" rel=\"nofollow\">Configuration</a></li>\n</ul>\n</li>\n<li><a href=\"#tasks-concurrency\" id=\"id38\" rel=\"nofollow\">Tasks Concurrency</a><ul>\n<li><a href=\"#async-io\" id=\"id39\" rel=\"nofollow\">ASYNC_IO</a></li>\n<li><a href=\"#thread-io\" id=\"id40\" rel=\"nofollow\">THREAD_IO</a></li>\n<li><a href=\"#cpubound\" id=\"id41\" rel=\"nofollow\">CPUBOUND</a></li>\n</ul>\n</li>\n<li><a href=\"#extend\" id=\"id42\" rel=\"nofollow\">Extend</a></li>\n<li><a href=\"#changelog\" id=\"id43\" rel=\"nofollow\">Changelog</a></li>\n<li><a href=\"#license\" id=\"id44\" rel=\"nofollow\">License</a></li>\n</ul>\n</div>\n</div>\n<div id=\"four-steps-tutorial\">\n<h2><a href=\"#id4\" rel=\"nofollow\">Four steps tutorial</a></h2>\n<div id=\"create-a-script\">\n<h3><a href=\"#id5\" rel=\"nofollow\">1 - Create a script</a></h3>\n<p>A simple python file which runs your application:</p>\n<pre>vim manage.py\n</pre>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pq.api</span> <span class=\"kn\">import</span> <span class=\"n\">PusarQueue</span>\n\n\n<span class=\"n\">task_paths</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'sampletasks.*'</span><span class=\"p\">,</span> <span class=\"s1\">'pq.jobs'</span><span class=\"p\">]</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">app</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"n\">PusarQueue</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"o\">=</span><span class=\"vm\">__file__</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">app</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"implement-jobs\">\n<h3><a href=\"#id6\" rel=\"nofollow\">2 - Implement Jobs</a></h3>\n<p>Create the modules where <a href=\"#the-job-class\" rel=\"nofollow\">Jobs</a> are implemented.\nIt can be a directory containing several submodules.</p>\n<pre>mkdir sampletasks\ncd sampletasks\nvim mytasks.py\n</pre>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">pq</span> <span class=\"kn\">import</span> <span class=\"n\">api</span>\n\n\n<span class=\"nd\">@api</span><span class=\"o\">.</span><span class=\"n\">job</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">addition</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n\n\n<span class=\"nd\">@api</span><span class=\"o\">.</span><span class=\"n\">job</span><span class=\"p\">()</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">asynchronous</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lag</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n    <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n    <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">lag</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">start</span>\n</pre>\n</div>\n<div id=\"run-the-server\">\n<h3><a href=\"#id7\" rel=\"nofollow\">3 - Run the server</a></h3>\n<p>Run the server with two task consumers (pulsar actors).</p>\n<p><strong>NOTE</strong>: Make sure you have Redis server up and running before you start the server.</p>\n<pre>python manage.py -w 2\n</pre>\n</div>\n<div id=\"queue-tasks\">\n<h3><a href=\"#id8\" rel=\"nofollow\">4 - Queue tasks</a></h3>\n<p>Launch a python shell and play with the api</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">manage</span> <span class=\"kn\">import</span> <span class=\"n\">app</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">api</span> <span class=\"o\">=</span> <span class=\"n\">app</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">api</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"p\">(</span><span class=\"s1\">'addition'</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"mi\">6</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span>\n<span class=\"o\">&lt;</span><span class=\"n\">TaskFuture</span> <span class=\"n\">pending</span> <span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"n\">i26ad5c14c5bb422e87b0f7ccbce5ba06</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n<span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">addition</span><span class=\"o\">&lt;</span><span class=\"n\">i24ab99ddf2744902a375e039790dcbc4</span><span class=\"o\">&gt;&lt;</span><span class=\"n\">SUCCESS</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">result</span>\n<span class=\"mi\">10</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">status_string</span>\n<span class=\"s1\">'SUCCESS'</span>\n</pre>\n<p>You can also queue tasks with a <tt>delay</tt></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"p\">(</span><span class=\"s1\">'addition'</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">delay</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">status_string</span>\n<span class=\"s1\">'QUEUED'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">time_queued</span>    <span class=\"c1\"># timestamp</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">done_callback</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">status_string</span>\n<span class=\"s1\">'SUCCESS'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">time_started</span> <span class=\"o\">-</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">time_queued</span>\n<span class=\"mf\">2.00</span>\n</pre>\n<p><strong>NOTE</strong>: The <tt>wait</tt> method in a task future can only be used on the shell\nor when the event loop is not running. In all other cases one should <tt>await</tt>\nfor the task future in a coroutine.</p>\n</div>\n</div>\n<div id=\"api\">\n<h2><a href=\"#id9\" rel=\"nofollow\">API</a></h2>\n<p>The producer API is obtained from the Task application <tt>api</tt> method:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pq.api</span> <span class=\"kn\">import</span> <span class=\"n\">PusarQueue</span>\n\n<span class=\"n\">api</span> <span class=\"o\">=</span> <span class=\"n\">PusarQueue</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">api</span><span class=\"p\">()</span>\n</pre>\n<div id=\"api-methods\">\n<h3><a href=\"#id10\" rel=\"nofollow\">API methods</a></h3>\n<div id=\"api-start\">\n<h4><a href=\"#id11\" rel=\"nofollow\"><em>api</em>.start()</a></h4>\n<p>Start listening to events. This method return a coroutine which resolve in the api:</p>\n<pre><span class=\"n\">api</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n</pre>\n<p>The start method is used when the api is used by application to queue messages/tasks\nand listen for events published by distributed consumers.</p>\n</div>\n<div id=\"api-on-events-message-type-event-re-callback\">\n<h4><a href=\"#id12\" rel=\"nofollow\"><em>api</em>.on_events(<em>message_type</em>, <em>event_re</em>, <em>callback</em>)</a></h4>\n<p>Add a callback invoked every time an event matching the regular expression <tt>event_re</tt>\noccurs on the <tt>message_type</tt> channel. The <em>callback</em> has the following signature:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">event_callback</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">):</span>\n    <span class=\"c1\"># event is string, the event matched</span>\n    <span class=\"c1\"># message is of type message_type</span>\n</pre>\n<p>If the event is a task event (see <a href=\"#events\" rel=\"nofollow\">events</a>) the message is a <a href=\"#the-task\" rel=\"nofollow\">Task</a> object.</p>\n<p>This method is useful when creating applications which needs to respond to the\nqueue server events in real time:</p>\n<pre>api.on_events('task', 'queued', callback)\napi.on_events('task', 'started', callback)\napi.on_events('task', 'done', callback)\n</pre>\n</div>\n<div id=\"api-remove-event-callback-message-type-event-re-callback\">\n<h4><a href=\"#id13\" rel=\"nofollow\"><em>api</em>.remove_event_callback(<em>message_type</em>, <em>event_re</em>, <em>callback</em>)</a></h4>\n<p>Remove a previously added event callback. This method is safe.</p>\n</div>\n<div id=\"api-queue-message-callback-true\">\n<h4><a href=\"#id14\" rel=\"nofollow\"><em>api</em>.queue(<em>message</em>, <em>callback=True</em>)</a></h4>\n<p>Queue a message in the message queue, equivalent to:</p>\n<pre><span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">broker</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"p\">)</span>\n</pre>\n<p>This method returns a <tt>MessageFuture</tt>, a subclass of asyncio <a href=\"https://docs.python.org/3/library/asyncio-task.html#future\" rel=\"nofollow\">Future</a> which\nresolves in a <tt>message</tt> object.\nIf <tt>callback</tt> is True (default) the Future is resolved once the message\nis delivered (out of the queue), otherwise is is resolved once the message\nis queued (entered the queue).</p>\n</div>\n<div id=\"api-execute-message\">\n<h4><a href=\"#id15\" rel=\"nofollow\"><em>api</em>.execute(<em>message</em>)</a></h4>\n<p>Execute a message without queueing. This is only supported by messages with\na message consumer which execute them (the <tt>tasks</tt> consumer for example).\nIf <em>message</em> is a <a href=\"#the-task\" rel=\"nofollow\">Task</a>, this method is equivalent to:</p>\n<pre><span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">)</span>\n</pre>\n<p>This method returns a <tt>MessageFuture</tt>, a subclass of asyncio <a href=\"https://docs.python.org/3/library/asyncio-task.html#future\" rel=\"nofollow\">Future</a> which\nresolve in a <tt>message</tt> object.</p>\n</div>\n<div id=\"api-consumers\">\n<h4><a href=\"#id16\" rel=\"nofollow\"><em>api</em>.consumers</a></h4>\n<p>List of consumers registered with the api.</p>\n</div>\n</div>\n<div id=\"tasks-api\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Tasks API</a></h3>\n<p>The tasks producer is obtained vua the <tt>tasks</tt> property from the producer API instance</p>\n<pre><span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">tasks</span>\n</pre>\n<p>The following methods are available for the tasks producer:</p>\n<div id=\"tasks-queue-jobname-kwargs\">\n<h4><a href=\"#id18\" rel=\"nofollow\"><em>tasks</em>.queue(<em>jobname</em>, <em>**kwargs</em>)</a></h4>\n<p>Queue a task and return a <strong>TaskFuture</strong> which is resolved once the task has finished.\nIt is possible to obtain a task future resolved when the task has been queued, rather than finished, by passing the <strong>callback=False</strong> parameter:</p>\n<pre><span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">status_string</span>  <span class=\"c1\"># QUEUED</span>\n</pre>\n<p>The <tt>kwargs</tt> parameters are used as input parameters for the <a href=\"#the-job-class\" rel=\"nofollow\">Job</a> callable with the exception of:</p>\n<ul>\n<li><tt>callback</tt>: discussed above</li>\n<li><tt>delay</tt>: delay execution by a given number of seconds</li>\n<li><tt>queue</tt>: overrides the <a href=\"#the-job-class\" rel=\"nofollow\">Job</a> [default_queue](#job-default-queue)</li>\n<li>[timeout](#job-timeout)</li>\n<li><tt>meta_params</tt>: dictionary of parameters used by the <a href=\"#the-job-class\" rel=\"nofollow\">Job</a> callable to override default values of:\n* [max_retries](#job-max-retries)\n* [retry_delay](#job-retry-delay)\n* [max_concurrency](#job-max-concurrency)</li>\n</ul>\n</div>\n<div id=\"tasks-queue-local-jobname-kwargs\">\n<h4><a href=\"#id19\" rel=\"nofollow\"><em>tasks</em>.queue_local(<em>jobname</em>, <em>**kwargs</em>)</a></h4>\n<p>Queue a job in the local task queue. The local task queue is processed by the same server instance. It is equivalent to execute:</p>\n<pre><span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">queue</span><span class=\"o\">=</span><span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">node_name</span><span class=\"p\">)</span>\n<span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">queue</span>  <span class=\"c1\"># tasks.node_name</span>\n</pre>\n</div>\n<div id=\"tasks-execute-jobname-args-kwargs\">\n<h4><a href=\"#id20\" rel=\"nofollow\"><em>tasks</em>.execute(<em>jobname</em>, <em>*args</em>, <em>**kwargs</em>)</a></h4>\n<p>Execute a task immediately, it does not put the task in the task queue.\nThis method is useful for debugging and testing. It is equivalent to execute:</p>\n<pre><span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">queue</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">queue</span>          <span class=\"c1\"># None</span>\n<span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">status_string</span>  <span class=\"c1\"># SUCCESS</span>\n</pre>\n</div>\n<div id=\"tasks-queues\">\n<h4><a href=\"#id21\" rel=\"nofollow\"><em>tasks</em>.queues()</a></h4>\n<p>Return the list of queue names the backend is subscribed. This list is not empty when the backend is a task consumer.</p>\n</div>\n<div id=\"tasks-job-list-jobname-none\">\n<h4><a href=\"#id22\" rel=\"nofollow\"><em>tasks</em>.job_list(<em>jobname=None</em>)</a></h4>\n<p>Returns a list of <tt>job_name</tt>, <tt>job_description</tt> tuples. The <tt>job_name</tt> is a string which must be used as the <strong>jobname</strong> parameter when executing or queing tasks. The <tt>job_description</tt> is a dictionary containing metadata and documentation for the job. Example:</p>\n<pre><span class=\"n\">jobs</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">job_lits</span><span class=\"p\">())</span>\n<span class=\"n\">jobs</span><span class=\"p\">[</span><span class=\"s1\">'execute.python'</span><span class=\"p\">]</span>\n<span class=\"c1\"># {</span>\n<span class=\"c1\">#   'type': 'regular',</span>\n<span class=\"c1\">#   'concurrency': 'asyncio',</span>\n<span class=\"c1\">#   'doc_syntax': 'markdown',</span>\n<span class=\"c1\">#   'doc': 'Execute arbitrary python code on a subprocess ... '</span>\n<span class=\"c1\"># }</span>\n</pre>\n</div>\n</div>\n<div id=\"the-job-class\">\n<h3><a href=\"#id23\" rel=\"nofollow\">The Job class</a></h3>\n<p>The <strong>Job</strong> class is how task factories are implemented and added to the\ntasks backend registry. When writing a new <strong>Job</strong> one can either subclass:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">AsyncSleep</span><span class=\"p\">(</span><span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">Job</span><span class=\"p\">):</span>\n\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lag</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">lag</span><span class=\"p\">)</span>\n</pre>\n<p>or use the less verbose <strong>job</strong> decorator:</p>\n<pre><span class=\"nd\">@api</span><span class=\"o\">.</span><span class=\"n\">job</span><span class=\"p\">()</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">asyncsleep</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lag</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n    <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">lag</span><span class=\"p\">)</span>\n</pre>\n<p>In either cases the <tt>self</tt> parameter is an instance of a <strong>Job</strong> class and\nit has the following useful attributes and methods:</p>\n<div id=\"job-backend\">\n<h4><a href=\"#id24\" rel=\"nofollow\"><em>job</em>.backend</a></h4>\n<p>The tasks backend that is processing this <a href=\"#the-task\" rel=\"nofollow\">Task</a> run</p>\n</div>\n<div id=\"job-default-queue\">\n<h4><a href=\"#id25\" rel=\"nofollow\"><em>job</em>.default_queue</a></h4>\n<p>The default queue name where tasks for this job are queued. By default it is <tt>None</tt>\nin which case, if a <tt>queue</tt> is not given when queueing a task, the first queue\nfrom the <a href=\"#tasks_queues\" rel=\"nofollow\">queues</a> list taken.</p>\n</div>\n<div id=\"job-http\">\n<h4><a href=\"#id26\" rel=\"nofollow\"><em>job</em>.http</a></h4>\n<p>Best possible HTTP session handler for the job concurrency mode.</p>\n</div>\n<div id=\"job-logger\">\n<h4><a href=\"#id27\" rel=\"nofollow\"><em>job</em>.logger</a></h4>\n<p>Python logging handler for this job. The name of this handler\nis <tt><span class=\"pre\">&lt;app_name&gt;.&lt;job.name&gt;</span></tt>.</p>\n</div>\n<div id=\"job-max-retries\">\n<h4><a href=\"#id28\" rel=\"nofollow\"><em>job</em>.max_retries</a></h4>\n<p>Optional positive integer which specify the maximum number of retries when a\ntask fails or is revoked. If not available failing tasks are not re-queued.\nIt can be specified as a class attribute or during initialisation from the task\nmeta parameters.</p>\n</div>\n<div id=\"job-retry-delay\">\n<h4><a href=\"#id29\" rel=\"nofollow\"><em>job</em>.retry_delay</a></h4>\n<p>Optional positive integer which specifies the number of seconds to delay a task\nretry.</p>\n</div>\n<div id=\"job-name\">\n<h4><a href=\"#id30\" rel=\"nofollow\"><em>job</em>.name</a></h4>\n<p>The name of this job. Used to queue tasks</p>\n</div>\n<div id=\"job-task\">\n<h4><a href=\"#id31\" rel=\"nofollow\"><em>job</em>.task</a></h4>\n<p>The <a href=\"#the-task\" rel=\"nofollow\">Task</a> instance associated with this task run</p>\n</div>\n<div id=\"job-queue-jobname-args-kwargs\">\n<h4><a href=\"#id32\" rel=\"nofollow\"><em>job</em>.queue(<em>jobname</em>, <em>*args</em>, <em>**kwargs</em>)</a></h4>\n<p>Queue a new job form a task run. It is equivalent to:</p>\n<pre><span class=\"n\">meta_params</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'from_task'</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">}</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">backend</span><span class=\"o\">.</span><span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">meta_params</span><span class=\"o\">=</span><span class=\"n\">meta_params</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"job-shell-command-kwargs\">\n<h4><a href=\"#id33\" rel=\"nofollow\"><em>job</em>.shell(<em>command</em>, <em>**kwargs</em>)</a></h4>\n<p>Execute a shell command and returns a coroutine:</p>\n<pre><span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shell</span><span class=\"p\">(</span><span class=\"s2\">\"...\"</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"the-task\">\n<h3><a href=\"#id34\" rel=\"nofollow\">The Task</a></h3>\n<p>A task contains the metadata information of a job run and it is exchanged between task producers and task consumers via a distributed task queue.</p>\n</div>\n<div id=\"task-states\">\n<h3><a href=\"#id35\" rel=\"nofollow\">Task States</a></h3>\n<p>A <a href=\"#the-task\" rel=\"nofollow\">Task</a> can have one of the following <tt>task.status</tt>:</p>\n<ul>\n<li><tt>QUEUED = 6</tt> a task queued but not yet executed.</li>\n<li><tt>STARTED = 5</tt> a task where execution has started.</li>\n<li><tt>RETRY = 4</tt> a task is retrying calculation.</li>\n<li><tt>REVOKED = 3</tt> the task execution has been revoked (or timed-out).</li>\n<li><tt>FAILURE = 2</tt> task execution has finished with failure.</li>\n<li><tt>SUCCESS = 1</tt> task execution has finished with success.</li>\n</ul>\n<p><strong>FULL_RUN_STATES</strong></p>\n<p>The set of states for which a <a href=\"#the-task\" rel=\"nofollow\">Task</a> has run: <tt>FAILURE</tt> and <tt>SUCCESS</tt></p>\n<p><strong>READY_STATES</strong></p>\n<p>The set of states for which a <a href=\"#the-task\" rel=\"nofollow\">Task</a> has finished: <tt>REVOKED</tt>, <tt>FAILURE</tt> and <tt>SUCCESS</tt></p>\n</div>\n<div id=\"events\">\n<h3><a href=\"#id36\" rel=\"nofollow\">Events</a></h3>\n<p>The task queue broadcast several events during task execution and internal state:</p>\n<ul>\n<li><tt>task_queued</tt>: a new <a href=\"#the-task\" rel=\"nofollow\">Task</a> has been queued, the message is a task instance</li>\n<li><tt>task_started</tt>: a <a href=\"#the-task\" rel=\"nofollow\">Task</a> has started to be consumed by a task consumer, it is out of the task queue</li>\n<li><tt>task_done</tt>: a <a href=\"#the-task\" rel=\"nofollow\">Task</a> is done, the message is a task in a <strong>READY_STATES</strong></li>\n</ul>\n</div>\n<div id=\"configuration\">\n<h3><a href=\"#id37\" rel=\"nofollow\">Configuration</a></h3>\n<p>There are several parameters you can use to twick the way the task queue works.\nIn this list the name in bold is the entry point in the config file and <strong>cfg</strong>\ndictionary, while, the value between brackets shows the command line entry with default\nvalue.</p>\n<ul>\n<li><p><strong>concurrent_tasks</strong> (<tt><span class=\"pre\">--concurrent-tasks</span> 5</tt>)</p>\n<blockquote>\n<p>The maximum number of concurrent tasks for a given worker in a task consumer server.</p>\n</blockquote>\n</li>\n<li><p><strong>data_store</strong> (<tt><span class=\"pre\">--data-store</span> <span class=\"pre\">redis://127.0.0.1:6379/7</span></tt>)</p>\n<blockquote>\n<p>Data store used for publishing and subscribing to messages (redis is the\nonly backend available at the moment)</p>\n</blockquote>\n</li>\n<li><p><strong>max_requests</strong> (<tt><span class=\"pre\">--max-requests</span> 0</tt>)</p>\n<blockquote>\n<p>The maximum number of tasks a worker will process before restarting.\nA 0 value (the default) means no maximum number, workers will process\nall tasks forever.</p>\n</blockquote>\n</li>\n<li><p><strong>message_broker</strong> (<tt><span class=\"pre\">--message-broker</span> ...</tt>)</p>\n<blockquote>\n<p>Data store used as distributed task queue. If not provided (default) the\n<tt>data_store</tt> is used instead. Redis is the\nonly backend available at the moment.</p>\n</blockquote>\n</li>\n<li><p><strong>message_serializer</strong> (<tt><span class=\"pre\">--message-serializer</span> json</tt>)</p>\n<blockquote>\n<p>The decoder/encoder for messages and tasks. The default is <strong>JSON</strong> but <strong>Message Pack</strong>\nis also available if <a href=\"https://pypi.python.org/pypi/msgpack-python\" rel=\"nofollow\">msgpack</a> is installed.</p>\n</blockquote>\n</li>\n<li><p><strong>schedule_periodic</strong> (<tt><span class=\"pre\">--schedule-periodic</span></tt>)</p>\n<blockquote>\n<p>When <tt>True</tt>, the task application can schedule periodic <a href=\"#the-job-class\" rel=\"nofollow\">Jobs</a>.\nUsually, only one running server is responsible for\nscheduling tasks.</p>\n</blockquote>\n</li>\n<li><p><strong>task_pool_timeout</strong> (<tt><span class=\"pre\">--task-pool-timeout</span> 2</tt>)</p>\n<blockquote>\n<p>Timeout in seconds for asynchronously polling tasks from the queues. No need to change this parameter really.</p>\n</blockquote>\n</li>\n<li><p><strong>workers</strong> (<tt><span class=\"pre\">--workers</span> 4</tt>)</p>\n<blockquote>\n<p>Number of workers (processes) consuming tasks.</p>\n</blockquote>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"tasks-concurrency\">\n<h2><a href=\"#id38\" rel=\"nofollow\">Tasks Concurrency</a></h2>\n<p>A task can run in one of four <tt>concurrency</tt> modes.\nIf not specified by the <tt>Job</tt>, the concurrency mode is <tt>ASYNC_IO</tt>.</p>\n<div id=\"async-io\">\n<h3><a href=\"#id39\" rel=\"nofollow\">ASYNC_IO</a></h3>\n<p>The asynchronous IO mode is associated with tasks which return\nan asyncio Future or a coroutine. These tasks run concurrently\nin the worker event loop.\nAn example can be a Job to scrape web pages and create new tasks to process the html</p>\n<pre><span class=\"nd\">@api</span><span class=\"o\">.</span><span class=\"n\">job</span><span class=\"p\">()</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">scrape</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">url</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">assert</span> <span class=\"n\">url</span><span class=\"p\">,</span> <span class=\"s2\">\"url is required\"</span>\n    <span class=\"n\">request</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">http</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">url</span><span class=\"p\">)</span>\n    <span class=\"n\">html</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"p\">()</span>\n    <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">queue</span><span class=\"p\">(</span><span class=\"s1\">'process.html'</span><span class=\"p\">,</span> <span class=\"n\">html</span><span class=\"o\">=</span><span class=\"n\">html</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">id</span>\n</pre>\n</div>\n<div id=\"thread-io\">\n<h3><a href=\"#id40\" rel=\"nofollow\">THREAD_IO</a></h3>\n<p>This concurrency mode is best suited for tasks performing\n<em>blocking</em> IO operations.\nA <tt>THREAD_IO</tt> job runs its tasks in the event loop executor.\nYou can use this model for most blocking operation unless</p>\n<ul>\n<li>Long running CPU bound</li>\n<li>The operation does not release the GIL</li>\n</ul>\n<p>Example of tasks suitable for thread IO are IO operations on files.\nFor example the test suite uses this Job for testing <tt>THREAD_IO</tt>\nconcurrency (check the <tt>tests.example.jobs.standard</tt> module\nfor the full code):</p>\n<pre><span class=\"nd\">@api</span><span class=\"o\">.</span><span class=\"n\">job</span><span class=\"p\">(</span><span class=\"n\">concurrency</span><span class=\"o\">=</span><span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">THREAD_IO</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">extract_docx</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">input</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">output</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"\n    Extract text from a docx document\n    \"\"\"</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">docx</span>\n    <span class=\"k\">assert</span> <span class=\"nb\">input</span> <span class=\"ow\">and</span> <span class=\"n\">output</span><span class=\"p\">,</span> <span class=\"s2\">\"input and output must be given\"</span>\n    <span class=\"n\">document</span> <span class=\"o\">=</span> <span class=\"n\">docx</span><span class=\"o\">.</span><span class=\"n\">Document</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">)</span>\n    <span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"se\">\\n\\n</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">_docx_text</span><span class=\"p\">(</span><span class=\"n\">document</span><span class=\"p\">))</span>\n    <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">,</span> <span class=\"s1\">'w'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">fp</span><span class=\"p\">:</span>\n        <span class=\"n\">fp</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'thread'</span><span class=\"p\">:</span> <span class=\"n\">threading</span><span class=\"o\">.</span><span class=\"n\">get_ident</span><span class=\"p\">(),</span>\n        <span class=\"s1\">'text'</span><span class=\"p\">:</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"cpubound\">\n<h3><a href=\"#id41\" rel=\"nofollow\">CPUBOUND</a></h3>\n<p>It assumes the task performs blocking CPU bound operations.\nJobs with this consurrency mode run their tasks on sub-processeses\nusing <a href=\"https://docs.python.org/3/library/asyncio-subprocess.html\" rel=\"nofollow\">asyncio subprocess</a> module.</p>\n</div>\n</div>\n<div id=\"extend\">\n<h2><a href=\"#id42\" rel=\"nofollow\">Extend</a></h2>\n<p>It is possible to enhance the task queue application by passing\na custom <tt>Manager</tt> during initialisation.\nFor example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pq</span> <span class=\"kn\">import</span> <span class=\"n\">api</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Manager</span><span class=\"p\">(</span><span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">Manager</span><span class=\"p\">):</span>\n\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">store_message</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"This method is called when a message/task is queued,\n        started and finished\n        \"\"\"</span>\n        <span class=\"k\">if</span> <span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"o\">==</span> <span class=\"s1\">'task'</span><span class=\"p\">:</span>\n            <span class=\"c1\"># save this task into a db for example</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">queues</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"List of queue names for Task consumers\n        By default it returns the node name and the task_queues\n        in the config dictionary.\n        \"\"\"</span>\n        <span class=\"n\">queues</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">backend</span><span class=\"o\">.</span><span class=\"n\">node_name</span><span class=\"p\">]</span>\n        <span class=\"n\">queues</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">cfg</span><span class=\"o\">.</span><span class=\"n\">task_queues</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">queues</span>\n\n\n<span class=\"n\">tq</span> <span class=\"o\">=</span> <span class=\"n\">PulsarQueue</span><span class=\"p\">(</span><span class=\"n\">Manager</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>The <tt>Manager</tt> class is initialised when the backend handler is initialised\n(on each consumer and in the scheduler).</p>\n</div>\n<div id=\"changelog\">\n<h2><a href=\"#id43\" rel=\"nofollow\">Changelog</a></h2>\n<ul>\n<li><a href=\"https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.5.md\" rel=\"nofollow\">Versions 0.5</a></li>\n<li><a href=\"https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.4.md\" rel=\"nofollow\">Versions 0.4</a></li>\n<li><a href=\"https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.3.md\" rel=\"nofollow\">Versions 0.3</a></li>\n<li><a href=\"https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.2.md\" rel=\"nofollow\">Versions 0.2</a></li>\n<li><a href=\"https://github.com/quantmind/pulsar-queue/blob/master/docs/history/0.1.md\" rel=\"nofollow\">Versions 0.1</a></li>\n</ul>\n</div>\n<div id=\"license\">\n<h2><a href=\"#id44\" rel=\"nofollow\">License</a></h2>\n<p>This software is licensed under the BSD 3-clause License. See the LICENSE\nfile in the top distribution directory for the full license text. Logo designed by Ralf Holzemer,\n<a href=\"http://creativecommons.org/licenses/by-nc/3.0/\" rel=\"nofollow\">creative common license</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 2488350, "releases": {"0.1.0.dev20150925153232": [], "0.1.1": [{"comment_text": "", "digests": {"md5": "5656069f57526d2d1a65cda5ecdca940", "sha256": "32e506e450b67553ccd3e60c9cebe55b2868410e40ab3c6180085ee41b3f5aaf"}, "downloads": -1, "filename": "pulsar-queue-0.1.1.tar.gz", "has_sig": false, "md5_digest": "5656069f57526d2d1a65cda5ecdca940", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20084, "upload_time": "2015-11-26T16:46:32", "upload_time_iso_8601": "2015-11-26T16:46:32.563933Z", "url": "https://files.pythonhosted.org/packages/85/8f/a2b95c0513f6d753a35f4f1b5de14b023c701c1b223a849d62e6866b5b69/pulsar-queue-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "38c52a79950bce71e85ff3c9178ce9f8", "sha256": "94b438aa013ae7bfcba50f900db5c8c1593803a65cb707821d3e66a843d33817"}, "downloads": -1, "filename": "pulsar_queue-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "38c52a79950bce71e85ff3c9178ce9f8", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 26500, "upload_time": "2016-05-12T08:42:01", "upload_time_iso_8601": "2016-05-12T08:42:01.449042Z", "url": "https://files.pythonhosted.org/packages/1d/95/ac9782fabf2a3ab67d992c643771a689e539deec0603f756743fd2d15e5c/pulsar_queue-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "74c455b1c39615cb370ca19143379eb0", "sha256": "10fbd83b85e2209624f182b51d6d0b837e0eb4606765162fdf000eb51d7bf042"}, "downloads": -1, "filename": "pulsar-queue-0.2.0.tar.gz", "has_sig": false, "md5_digest": "74c455b1c39615cb370ca19143379eb0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21371, "upload_time": "2016-05-12T08:41:53", "upload_time_iso_8601": "2016-05-12T08:41:53.930893Z", "url": "https://files.pythonhosted.org/packages/5f/3a/8bb979ee944d6339ffa93599aa1c9524722e578d894056bfaeb92360dbfc/pulsar-queue-0.2.0.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "3701b7b859062691f646b24167bc4d9b", "sha256": "318a52b0fad2752b0d50522f9c2bf62c4bdd89b31caf637e38f886e53cd26cbd"}, "downloads": -1, "filename": "pulsar_queue-0.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "3701b7b859062691f646b24167bc4d9b", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 48149, "upload_time": "2016-07-01T15:41:21", "upload_time_iso_8601": "2016-07-01T15:41:21.065989Z", "url": "https://files.pythonhosted.org/packages/3c/fa/dda4dd599ecf0dc06c1ed5427ea22a2a6fdf668421ec52cf62f1a28899a8/pulsar_queue-0.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "338ea2a891d2b661c4d584ffe5ea4d53", "sha256": "3220a4299f047e6d5ceac21fac132b17f1c61df97da6f168ed825c9be25279d3"}, "downloads": -1, "filename": "pulsar-queue-0.3.0.tar.gz", "has_sig": false, "md5_digest": "338ea2a891d2b661c4d584ffe5ea4d53", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23402, "upload_time": "2016-07-01T15:41:16", "upload_time_iso_8601": "2016-07-01T15:41:16.445119Z", "url": "https://files.pythonhosted.org/packages/d6/2b/b81a0fff539f558e985d2e9a483c81f65e00f63fed14e52ee1453508c842/pulsar-queue-0.3.0.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "cd2d698fc2d8f3af53b451d4a6d4c7d8", "sha256": "448ab1cf05016c3f29ac5b4927c962d35f732b33f543502be397f7b445f3c72b"}, "downloads": -1, "filename": "pulsar_queue-0.3.1-py3-none-any.whl", "has_sig": false, "md5_digest": "cd2d698fc2d8f3af53b451d4a6d4c7d8", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 52497, "upload_time": "2016-07-09T16:42:00", "upload_time_iso_8601": "2016-07-09T16:42:00.509396Z", "url": "https://files.pythonhosted.org/packages/f7/7d/35e421633ffc5e89ec6043084bc19f838ee1f744008d6f9d54f556894105/pulsar_queue-0.3.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2758e6502af877e56d8dfec0798f8ccb", "sha256": "d1096ea7b88b1938abf8ad0d3eb879a1d78eeb46d1a93b4e640546046546dc40"}, "downloads": -1, "filename": "pulsar-queue-0.3.1.tar.gz", "has_sig": false, "md5_digest": "2758e6502af877e56d8dfec0798f8ccb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28078, "upload_time": "2016-07-09T16:41:55", "upload_time_iso_8601": "2016-07-09T16:41:55.930078Z", "url": "https://files.pythonhosted.org/packages/c0/10/64f52518be6f5e361a3681041c3d0c633e7cf4cde0f57c9f81ba1066ca95/pulsar-queue-0.3.1.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "f524a189487051fd625eab3149b0a7f2", "sha256": "ddbdef1f744a3f93d7f47ae7db9a4ed6e3a72bdb3a7b83ac5fc1bce52f23e5b6"}, "downloads": -1, "filename": "pulsar_queue-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "f524a189487051fd625eab3149b0a7f2", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 37650, "upload_time": "2016-08-04T21:58:10", "upload_time_iso_8601": "2016-08-04T21:58:10.244349Z", "url": "https://files.pythonhosted.org/packages/41/68/ae6810e3f04cdd518ef6be7a703ce1cc4d7915e016968dc1a7a00ce6fd2c/pulsar_queue-0.4.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ce67622fe27f854fd0085aa96f0b15a6", "sha256": "7b83f66829a78c69f6da42309ca0b87891fc60940bf3b573e0389f19ce8d1dbe"}, "downloads": -1, "filename": "pulsar-queue-0.4.0.tar.gz", "has_sig": false, "md5_digest": "ce67622fe27f854fd0085aa96f0b15a6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31214, "upload_time": "2016-08-04T21:58:07", "upload_time_iso_8601": "2016-08-04T21:58:07.753750Z", "url": "https://files.pythonhosted.org/packages/fc/15/d02b33e0311d24f6a6492b57efb5991445d4111d6319ef99cf3cdb8eeffd/pulsar-queue-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "b4b94194118b9430dc059b395a798a69", "sha256": "a96d8acb695e2f02926b81eaed5cba8011877423959a673168b7386483900543"}, "downloads": -1, "filename": "pulsar_queue-0.5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b4b94194118b9430dc059b395a798a69", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 43179, "upload_time": "2016-10-11T15:40:38", "upload_time_iso_8601": "2016-10-11T15:40:38.387437Z", "url": "https://files.pythonhosted.org/packages/2f/db/7e56e71ac28c159848531dcf9fc5fd630e9d314c0a8f67b50361a5c12834/pulsar_queue-0.5.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "854c11fcf771eb17b5da77d83fd5d0da", "sha256": "db262eb982f3511aacf4a23e1f6cc4d72d74432e1dc3064677db7ea5a7a4faa8"}, "downloads": -1, "filename": "pulsar-queue-0.5.0.tar.gz", "has_sig": false, "md5_digest": "854c11fcf771eb17b5da77d83fd5d0da", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35492, "upload_time": "2016-10-11T15:40:35", "upload_time_iso_8601": "2016-10-11T15:40:35.051868Z", "url": "https://files.pythonhosted.org/packages/7b/ee/70cbce15c92355dc31ce8a20c30b984d1fbac3a24a2b7082ca3687514c43/pulsar-queue-0.5.0.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "2d3734c6c4220332d2a7244cab8a89f7", "sha256": "0c509294acebb92115f097e31ac6a22223df9d6d7783c390812781d961ae92bc"}, "downloads": -1, "filename": "pulsar_queue-0.5.1-py3-none-any.whl", "has_sig": false, "md5_digest": "2d3734c6c4220332d2a7244cab8a89f7", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 43247, "upload_time": "2016-11-25T08:10:27", "upload_time_iso_8601": "2016-11-25T08:10:27.854539Z", "url": "https://files.pythonhosted.org/packages/e1/03/0c3b510cc9bc63484665a9edfe5a5cf1b5b582aedf90b0dfdaffdfcd11b1/pulsar_queue-0.5.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d9e8f9016a021a436cfb1f307a5d9554", "sha256": "92ecc6b356915f11bc5121362ba6b176f85f58a8e34a1a6fdc65756b09483ac0"}, "downloads": -1, "filename": "pulsar-queue-0.5.1.tar.gz", "has_sig": false, "md5_digest": "d9e8f9016a021a436cfb1f307a5d9554", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36016, "upload_time": "2016-11-25T08:10:25", "upload_time_iso_8601": "2016-11-25T08:10:25.266512Z", "url": "https://files.pythonhosted.org/packages/55/f4/42cf8ea8479d810492d455457fc28bf33713caf0a580864a085e696f9d20/pulsar-queue-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "55cf9dc7084a61970bb698cbce0e3a83", "sha256": "7273e6e781f7d8dc5c77a7d0c3df82c6697506db3f9d6cb432e32e56e04baedc"}, "downloads": -1, "filename": "pulsar_queue-0.5.2-py3-none-any.whl", "has_sig": false, "md5_digest": "55cf9dc7084a61970bb698cbce0e3a83", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 43250, "upload_time": "2016-11-28T20:25:12", "upload_time_iso_8601": "2016-11-28T20:25:12.874860Z", "url": "https://files.pythonhosted.org/packages/c4/d0/1bfe7798d2a799e4a519f104bf14ad211b688c4349ccc6a70509f4a7b7e2/pulsar_queue-0.5.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "90b91d4a695b8f823892428a5aa8cd3d", "sha256": "d151138f39dd0ada0c9b32d5fdec69c5a5a5d634e5b1087185fc7d633526ad5b"}, "downloads": -1, "filename": "pulsar-queue-0.5.2.tar.gz", "has_sig": false, "md5_digest": "90b91d4a695b8f823892428a5aa8cd3d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35955, "upload_time": "2016-11-28T20:25:10", "upload_time_iso_8601": "2016-11-28T20:25:10.293670Z", "url": "https://files.pythonhosted.org/packages/16/f3/4b22a689b35926ef774e1b395f456c72782c757ddce23112bce437efdde2/pulsar-queue-0.5.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "55cf9dc7084a61970bb698cbce0e3a83", "sha256": "7273e6e781f7d8dc5c77a7d0c3df82c6697506db3f9d6cb432e32e56e04baedc"}, "downloads": -1, "filename": "pulsar_queue-0.5.2-py3-none-any.whl", "has_sig": false, "md5_digest": "55cf9dc7084a61970bb698cbce0e3a83", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 43250, "upload_time": "2016-11-28T20:25:12", "upload_time_iso_8601": "2016-11-28T20:25:12.874860Z", "url": "https://files.pythonhosted.org/packages/c4/d0/1bfe7798d2a799e4a519f104bf14ad211b688c4349ccc6a70509f4a7b7e2/pulsar_queue-0.5.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "90b91d4a695b8f823892428a5aa8cd3d", "sha256": "d151138f39dd0ada0c9b32d5fdec69c5a5a5d634e5b1087185fc7d633526ad5b"}, "downloads": -1, "filename": "pulsar-queue-0.5.2.tar.gz", "has_sig": false, "md5_digest": "90b91d4a695b8f823892428a5aa8cd3d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35955, "upload_time": "2016-11-28T20:25:10", "upload_time_iso_8601": "2016-11-28T20:25:10.293670Z", "url": "https://files.pythonhosted.org/packages/16/f3/4b22a689b35926ef774e1b395f456c72782c757ddce23112bce437efdde2/pulsar-queue-0.5.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:14:08 2020"}