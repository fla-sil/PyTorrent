{"info": {"author": "Yuval Arbel", "author_email": "yuval@arbels.net", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Utilities"], "description": "# Yutils\n>A Python utility package written by Yuval Arbel\n\n## module  base\n>yutils.base\n\n## module  conn\n>yutils.conn\n\n## module  exceptions\n>yutils.exceptions\n\n## module  ml\n>yutils.ml\n\n## module  queries\n>yutils.queries\n\n## module  tools\n>yutils.tools\n\n## function  match_arabic_nls_lang\n>yutils.match_arabic_nls_lang\n\n### module  attribute_dict\n>yutils.base.attribute_dict\n\n### module  generic_object\n>yutils.base.generic_object\n\n### module  input_checker\n>yutils.base.input_checker\n\n### module  list_container\n>yutils.base.list_container\n\n### module  pretty_printer\n>yutils.base.pretty_printer\n\n### module  updating_dict\n>yutils.base.updating_dict\n\n#### object  AttributeDict\n>yutils.base.attribute_dict.AttributeDict\n\n\n\n#### object  GenericObject\n>yutils.base.generic_object.GenericObject\n\n    A generic object you can easily use for your scripts, with a pprint and a str/repr for easy printing\n    \n\n        :param object_name: The name for your object!\n        :type object_name: str\n        \n#### function  dict_to_generic_object\n>yutils.base.generic_object.dict_to_generic_object\n\n    Converts a dictionary (recursively) to a GenericObject, with keys as attributes.\n\n    :param dictionary: dictionary to convert (key-values will be converted to attribute-values)\n    :type dictionary: dict\n    :param object_name: a name for your new object's type\n    :type object_name: str\n    :return: GenericObject object\n    \n\n\n#### object  InputChecker\n>yutils.base.input_checker.InputChecker\n\n\n        Base object for making a Python object more static-typed.\n        It is useful for checking __init__ argument inputs (type and content).\n\n        Type check is defined by _INPUT_TYPES class constant. (see yutils.tools.check_object_type for usage)\n        Option check is defined by _INPUT_OPTIONS class constant.\n\n        This also:\n            - creates self._inputs as the inputs dict given, as an AttributeDict.\n            - adds each input in inputs as an attribute to your object.\n\n        :param inputs: your __init__ inputs, can be anything you wish to check\n\n        :raises: yutils.exceptions.WrongDatatype if any input is not of the specified type, defined by _INPUT_TYPES\n                 yutils.exceptions.InputError if any input is not one of the options, defined by _INPUT_OPTIONS\n        \n\n\n#### object  ListContainer\n>yutils.base.list_container.ListContainer\n\n    An object that wraps a list, allowing you to use your object as a list and configure it as you wish.\n    \n\n        :param _list: the original list you wish to keep in the backbone of your object\n        :type _list: list\n        :param _objects_type: a plural name for your objects in your ListContainer! This is for printing your object.\n                              For Example:\n                              >>> class Students(ListContainer):\n                              >>>     def __init__(self):\n                              >>>         super(Students, self).__init__([], 'students')\n        :type _objects_type: str\n        \n\n\n#### object  PrintableObject\n>yutils.base.pretty_printer.PrintableObject\n\n    An object you can derive from, that has a pprint method - printing all set attributes\n    \n\n\n#### object  DictValueList\n>yutils.base.updating_dict.DictValueList\n\nInitialize self.  See help(type(self)) for accurate signature.\n#### object  UpdatingDict\n>yutils.base.updating_dict.UpdatingDict\n\nInitialize self.  See help(type(self)) for accurate signature.\n\n\n\n\n### module  sql_connection_details\n>yutils.conn.sql_connection_details\n\n#### object  ConnectionDetails\n>yutils.conn.sql_connection_details.ConnectionDetails\n\nInitialize self.  See help(type(self)) for accurate signature.\n#### object  ElasticConnectionDetails\n>yutils.conn.sql_connection_details.ElasticConnectionDetails\n\nInitialize self.  See help(type(self)) for accurate signature.\n#### object  MSSQLConnectionDetails\n>yutils.conn.sql_connection_details.MSSQLConnectionDetails\n\nInitialize self.  See help(type(self)) for accurate signature.\n#### object  MySQLConnectionDetails\n>yutils.conn.sql_connection_details.MySQLConnectionDetails\n\nInitialize self.  See help(type(self)) for accurate signature.\n#### object  OracleConnectionDetails\n>yutils.conn.sql_connection_details.OracleConnectionDetails\n\nInitialize self.  See help(type(self)) for accurate signature.\n\n\n\n\n### module  exceptions\n>yutils.exceptions.exceptions\n\n#### object  CodeMistake\n>yutils.exceptions.exceptions.CodeMistake\n\n    Gets raised to find mistakes when writing code\n    \n\n        :param mistake_string: an error message explaining why this was raised\n        :type mistake_string: str\n        \n#### object  InputError\n>yutils.exceptions.exceptions.InputError\n\n    Gets raised when the input wasn't as expected (e.g. isn't a valid option)\n    \n\n        :param error_string: an error message explaining the InputError\n        :type error_string: str\n        \n#### object  MissingAttribute\n>yutils.exceptions.exceptions.MissingAttribute\n\n    Gets raised when an attribute was expected in a certain class\n    \n\n        :param class_object: the object itself that is missing an attribute\n        :type class_object: object\n        :param attribute_name: the name of the attribute that is missing\n        :type attribute_name: str\n        \n#### object  MissingInput\n>yutils.exceptions.exceptions.MissingInput\n\n    Gets raised when an input was expected in a certain class but not received\n    \n\n        :param class_object: the object itself that is missing an attribute\n        :type class_object: object\n        :param attribute_name: the name of the attribute that is missing\n        :type attribute_name: str\n        \n#### object  UncaughtEndCase\n>yutils.exceptions.exceptions.UncaughtEndCase\n\n    Gets raised to catch unexpected cases in the future\n    \n\n        :param explanation: an optional string to explain the end case.\n                            Default: 'An uncaught end case was found. Check it out!'\n        :type explanation: str\n        \n#### object  UserCancellation\n>yutils.exceptions.exceptions.UserCancellation\n\n    Gets raised when a user chooses to cancel an operation, and you wish the program to abort.\n    \n\n        :param operation_name: (optional) the operation the user chose to cancel\n        :type operation_name: (optional) str\n        \n#### object  WrongDatatype\n>yutils.exceptions.exceptions.WrongDatatype\n\n    Gets raised when something isn't the right datatype as was expected\n    \n\n        :param name: object name\n        :type name: str\n        :param expectation: expected type\n        :type expectation: type or str\n        :param reality: the object's actual type\n        :type reality: type or str\n        \n#### object  WrongInputDatatype\n>yutils.exceptions.exceptions.WrongInputDatatype\n\n    Gets raised when an input argument isn't the right datatype as was expected\n    \n\n        :param name: object name\n        :type name: str\n        :param expectation: expected type\n        :type expectation: type or str\n        :param reality: the object's actual type\n        :type reality: type or str\n        \n#### object  YutilsException\n>yutils.exceptions.exceptions.YutilsException\n\nInitialize self.  See help(type(self)) for accurate signature.\n\n\n\n\n### module  classification\n>yutils.ml.classification\n\n### module  features\n>yutils.ml.features\n\n### module  linear_regression\n>yutils.ml.linear_regression\n\n### module  ml_base\n>yutils.ml.ml_base\n\n### module  regression\n>yutils.ml.regression\n\n#### object  LogisticRegression\n>yutils.ml.classification.LogisticRegression\n\n#### object  LogisticRegressionOptimizedClassifier\n>yutils.ml.classification.LogisticRegressionOptimizedClassifier\n\n#### object  MultiClassClassification\n>yutils.ml.classification.MultiClassClassification\n\n\n\n#### object  FeatureNormalizer\n>yutils.ml.features.FeatureNormalizer\n\n\n        Normalizes features for a ML object\n\n        :param info: info to normalize, across column axis (normalizes each column by different normalization data)\n        :type info:\n        \n\n\n#### object  LinearRegression\n>yutils.ml.linear_regression.LinearRegression\n\n\n        Not written yet...\n\n        :param training_data:\n        :param training_results:\n        :param learning_rate:\n        :param iterations:\n        :param normalize_data:\n        :param verbose:\n        \n#### object  NormalEquation\n>yutils.ml.linear_regression.NormalEquation\n\n\n        Not explained yet...\n\n        :param training_data:\n        :param training_results:\n        :param assess_for_warning:\n        :param verbose:\n        \n\n\n#### object  MLObject\n>yutils.ml.ml_base.MLObject\n\n\n        Base object for making a Python object more static-typed.\n        It is useful for checking __init__ argument inputs (type and content).\n\n        Type check is defined by _INPUT_TYPES class constant. (see yutils.tools.check_object_type for usage)\n        Option check is defined by _INPUT_OPTIONS class constant.\n\n        This also:\n            - creates self._inputs as the inputs dict given, as an AttributeDict.\n            - adds each input in inputs as an attribute to your object.\n\n        :param inputs: your __init__ inputs, can be anything you wish to check\n\n        :raises: yutils.exceptions.WrongDatatype if any input is not of the specified type, defined by _INPUT_TYPES\n                 yutils.exceptions.InputError if any input is not one of the options, defined by _INPUT_OPTIONS\n        \n#### function  create_data_from_text_file\n>yutils.ml.ml_base.create_data_from_text_file\n\n\n\n#### object  Regression\n>yutils.ml.regression.Regression\n\n\n\n\n\n### module  db_connection\n>yutils.queries.db_connection\n\n### module  oracle_field_list_format\n>yutils.queries.oracle_field_list_format\n\n#### module  db_connection\n>yutils.queries.db_connection.db_connection\n\n#### module  fetchers\n>yutils.queries.db_connection.fetchers\n\n##### object  DBConnection\n>yutils.queries.db_connection.db_connection.DBConnection\n\n    Wraps a connection to a DB, for executing SQL queries, using given connection_details.\n    \n\n        :param connection_details: Details for connection to the wanted DB\n        :type: connection_details: yutils.conn.sql_connection_details.ConnectionDetails\n        :param verbose: If to print warnings or not\n        :type verbose: bool\n        \n\n\n##### module  base_fetcher\n>yutils.queries.db_connection.fetchers.base_fetcher\n\n##### module  elastic\n>yutils.queries.db_connection.fetchers.elastic\n\n##### module  mssql\n>yutils.queries.db_connection.fetchers.mssql\n\n##### module  mysql\n>yutils.queries.db_connection.fetchers.mysql\n\n##### module  oracle\n>yutils.queries.db_connection.fetchers.oracle\n\n###### object  ElasticSearchFetcher\n>yutils.queries.db_connection.fetchers.elastic.ElasticSearchFetcher\n\n\n\n###### object  MSSQLFetcher\n>yutils.queries.db_connection.fetchers.mssql.MSSQLFetcher\n\n\n\n###### object  MySQLFetcher\n>yutils.queries.db_connection.fetchers.mysql.MySQLFetcher\n\n\n\n###### object  OracleFetcher\n>yutils.queries.db_connection.fetchers.oracle.OracleFetcher\n\n\n\n\n\n\n\n#### function  format_oracle_field_list\n>yutils.queries.oracle_field_list_format.format_oracle_field_list\n\n    Takes a list that can be more than 999 values long, and wraps them in SQL OR clauses.\n    This is useful because Oracle can only accept lists 1000 values long.\n\n    :param field_name: the name of the column you are querying\n    :type field_name: str\n    :param value_list: list of your values to format into the query\n    :type value_list: list of str\n\n    :return: formatted string containing your new WHERE clause\n    :rtype: unicode\n    \n\n\n\n\n### module  case_conversions\n>yutils.tools.case_conversions\n\n### module  files\n>yutils.tools.files\n\n### module  list\n>yutils.tools.list\n\n### module  numpy_tools\n>yutils.tools.numpy_tools\n\n### module  pretty_print\n>yutils.tools.pretty_print\n\n### module  str\n>yutils.tools.str\n\n### module  xlsx_creator\n>yutils.tools.xlsx_creator\n\n### function  check_object_type\n>yutils.tools.check_object_type\n\n    This checks the types of an object using a certain syntax:\n    Lets say we have an object_to_check and the types_to_validate.\n    The object_to_check is the object\n\n    :param object_to_check: the object you wish to check its type, and raise an exception should its type not be correct\n    :type object_to_check: ....that's what we're here for....\n    :param types_to_validate: defines the wanted types for the object to check:\n    :type types_to_validate:\n                type - checks that object_to_check is of that type\n                        Example: float will make sure object_to_check is a float\n                list of types - checks that object_to_check is one of the types in the list\n                        Example: [int, float] will make sure object_to_check is either an int or a float\n                tuple of types - checks hierarchically:\n                                    checks that object_to_check is of the type of the first item,\n                                    then checks that each item in object_to_check is of the type of the second item,\n                                    etc.\n                                 Remember, all types in the tuple except the last must support indexing.\n                        Example: (list, str) will make sure object_to_check is a list of strings\n                                 (tuple, [int, float]) will make sure object_to_check is a tuple of either ints or floats\n                dict - checks that object_to_check is an object. It's type is defined by key 'type',\n                       with other keys to be checked as the object's attributes.\n                        Example: {'type': Person, 'age': int} will make sure object_to_check is a Person object,\n                                 with an 'age' attribute that is an int.\n                All values can have as many recursive dimensions as wanted.\n    :param input_name: Do not use, this is for recursive inner use.\n\n    More examples\n    Lets say we create:\n\n    integer = 13\n    unicode_str = u'foo'\n    int_list = list(range(10))\n    input_object = MyObject()\n    input_object.num = 3\n    input_object.lis = [1, 'bar']\n    input_object.3dlist = [[(1, 2, 3), (1, 1, 1)], [('a', 'b', 'c'), [7, 8, 9]]]\n\n    We can send:\n    check_object_type(integer, int)\n    check_object_type(unicode_str, unicode)\n    check_object_type(int_list, (list, int))\n    check_object_type(input_object, {'type': MyObject,\n                                     'num': int,\n                                     'lis': (list, [int, str]),\n                                     '3dlist': (list, list, [tuple, list], [int, str, unicode])\n                                     })\n\n    :raises:\n             Because of invalid inputs:\n                yutils.exceptions.CodeMistake - When no 'type' key is found (for when types_to_validate is a dict)\n                yutils.exceptions.WrongDatatype - When no type type is found when isinstance-ing an object's type\n             Exceptions raised by check:\n                yutils.exceptions.WrongInputDatatype - When the type is not correct during validation\n                yutils.exceptions.MissingInput - When an attribute is missing (for when types_to_validate is a dict)\n    \n### function  equivilence\n>yutils.tools.equivilence\n\n    Divides an iterator to groups, based on the function's result of every item in the iterator.\n    Returns dict of lists.\n\n    Example:\n        >>> equivilence(range(10), lambda x: x % 3)\n        >>>out>>> {0: [0, 3, 6, 9],\n        >>>out>>>  1: [1, 4, 7],\n        >>>out>>>  2: [2, 5, 8]}\n\n    :param iterator: an iterator you wish to run on and divide into groups\n    :type iterator: iterator\n    :param func: a function to activate on each iterator item - its result decides the return dict's keys.\n    :type func: function\n\n    :rtype: dict of lists (lists are groups of original iterator)\n    \n#### function  camel_back_to_snake_case\n>yutils.tools.case_conversions.camel_back_to_snake_case\n\n    Turns a camelBack word to a snake_case word\n\n    :param camel_back_word: wordInCamelCase\n    :return: a_word_in_snake_case\n    \n#### function  camel_case_to_snake_case\n>yutils.tools.case_conversions.camel_case_to_snake_case\n\n    Turns a CamelCase word to a snake_case word\n\n    :param camel_case_word: AWordInCamelCase\n    :return: a_word_in_snake_case\n    \n#### function  snake_case_to_camel_back\n>yutils.tools.case_conversions.snake_case_to_camel_back\n\n    Turns a snake_case word to a camelBack word\n\n    :param snake_case_word: a_word_in_snake_case\n    :return: wordInCamelCase\n    \n#### function  snake_case_to_camel_case\n>yutils.tools.case_conversions.snake_case_to_camel_case\n\n    Turns a snake_case word to a CamelCase word\n\n    :param snake_case_word: a_word_in_snake_case\n    :return: AWordInCamelCase\n    \n\n\n#### function  get_file_length\n>yutils.tools.files.get_file_length\n\n    This function gets a file path and returns its length without reading it\n\n    :param file_path: path to return length of\n    :type file_path: str\n    :return: file length (in bytes)\n    :rtype: int\n    \n#### function  recursive_glob\n>yutils.tools.files.recursive_glob\n\n    Returns a list of all files in directory including sub-directories.\n\n    :param dir_name: Dir name to glob recursively on\n    :type dir_name: str\n    :param ignore_hidden: if to ignore hidden files (that start with '.')\n    :type ignore_hidden: bool\n\n    :return: list of all files in the dir_name\n    :rtype: list of str\n    \n#### function  save_file\n>yutils.tools.files.save_file\n\n    This function saves the file content to the destination dir (defaulted to \".\") as base_name + extension,\n    but adds a counter if needed.\n\n    :param content: the content of the file\n    :type content: str\n    :param file_base_name: the future file name without extension\n    :type file_base_name: str\n    :param extension: the file name extension (for example: 'xlsx')\n    :type extension: str\n    :param dest_dir: where to save the file\n                     Default: current directory\n    :type dest_dir: str\n\n    :return: full file path file was saved to\n    :rtype: unicode\n    \n\n\n#### function  make_list\n>yutils.tools.list.make_list\n\n#### function  repr_list\n>yutils.tools.list.repr_list\n\n    Returns an iterator as a string, representing the list.\n    :param iterator: the iterator you wish to represent as a list\n    :type iterator: iterator\n    :return: representation of your iterator as a list\n    :rtype: unicode\n    \n\n\n#### function  get_indices_containing_all_substrings\n>yutils.tools.numpy_tools.get_indices_containing_all_substrings\n\n#### function  is_iterable\n>yutils.tools.numpy_tools.is_iterable\n\n#### function  magic\n>yutils.tools.numpy_tools.magic\n\n    Implementation taken from https://stackoverflow.com/questions/47834140/numpy-equivalent-of-matlabs-magic\n    from user: user6655984\n    \n#### function  normalize_array\n>yutils.tools.numpy_tools.normalize_array\n\n#### function  r2c\n>yutils.tools.numpy_tools.r2c\n\n#### function  to_array\n>yutils.tools.numpy_tools.to_array\n\n\n\n#### function  pprint_dict\n>yutils.tools.pretty_print.pprint_dict\n\n    Prints a dict in a very pretty way!\n\n    :param dictionary: your dict to print\n    :type dictionary: dict\n    :param long_value_limit: when a dict value exceeds this limit, it won't be printed\n                             Default: 120\n    :type long_value_limit: int\n    :param long_value_filler: A filler to print instead of a long value, must have {type} and {length} fields!\n                              Default: '<Long {type} object with repr length {length}>'\n    :type long_value_filler: str\n    :return: None\n    \n#### function  pprint_list\n>yutils.tools.pretty_print.pprint_list\n\n    Prints a list in an easy, short way.\n\n    :param list_to_print: the list you wish to print\n    :type list_to_print: list\n    :return: None\n    \n\n\n#### function  turn_numeric\n>yutils.tools.str.turn_numeric\n\n    Turns a string into either an int or a float\n\n    :param string: a string to assess\n    :type string: str\n\n    :rtype: str or float\n\n    :raises: TypeError if no type was found\n    \n\n\n#### object  XLSXCreator\n>yutils.tools.xlsx_creator.XLSXCreator\n\n\n        A class to create an XLSX file from a table.\n        It will format the table inside an actual excel's table, according to each field's width.\n\n        :param headers: The fields of the table (headers)\n        :type headers: list of unicode\n        :param table: The table\n        :type table: matrix - list of lists of the same lengths (cells may be any datatype)\n        :param output_path: The path where to save the excel\n        :type output_path: unicode\n        \n#### function  create_xlsx\n>yutils.tools.xlsx_creator.create_xlsx\n\n    Creates an XLSX file from a table.\n    It will format the table inside an actual excel's table, according to each field's width.\n\n    :param headers: The fields of the table (headers)\n    :type headers: list of unicode\n    :param table: The table\n    :type table: matrix - list of lists of the same lengths (cells may be any datatype)\n    :param output_path: The path where to save the excel\n    :type output_path: unicode\n    \n#### function  get_next_column\n>yutils.tools.xlsx_creator.get_next_column\n\n#### function  get_next_letter\n>yutils.tools.xlsx_creator.get_next_letter\n\n#### function  table_to_str\n>yutils.tools.xlsx_creator.table_to_str\n\n    matrix good for the function xlsxwriter.Worksheet.add_table(['data': table))\n    :param table: matrix - list of lists of the same lengths (cells may be any datatype)\n    :return: fully string matrix", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/yuvalarbel/yutils/archive/1.3.2.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/yuvalarbel", "keywords": "utils,utilities,queries,ml,tools", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "yutils", "package_url": "https://pypi.org/project/yutils/", "platform": "", "project_url": "https://pypi.org/project/yutils/", "project_urls": {"Download": "https://github.com/yuvalarbel/yutils/archive/1.3.2.tar.gz", "Homepage": "https://github.com/yuvalarbel"}, "release_url": "https://pypi.org/project/yutils/1.3.2/", "requires_dist": null, "requires_python": "", "summary": "A Python utility package written by Yuval Arbel", "version": "1.3.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Yutils</h1>\n<blockquote>\n<p>A Python utility package written by Yuval Arbel</p>\n</blockquote>\n<h2>module  base</h2>\n<blockquote>\n<p>yutils.base</p>\n</blockquote>\n<h2>module  conn</h2>\n<blockquote>\n<p>yutils.conn</p>\n</blockquote>\n<h2>module  exceptions</h2>\n<blockquote>\n<p>yutils.exceptions</p>\n</blockquote>\n<h2>module  ml</h2>\n<blockquote>\n<p>yutils.ml</p>\n</blockquote>\n<h2>module  queries</h2>\n<blockquote>\n<p>yutils.queries</p>\n</blockquote>\n<h2>module  tools</h2>\n<blockquote>\n<p>yutils.tools</p>\n</blockquote>\n<h2>function  match_arabic_nls_lang</h2>\n<blockquote>\n<p>yutils.match_arabic_nls_lang</p>\n</blockquote>\n<h3>module  attribute_dict</h3>\n<blockquote>\n<p>yutils.base.attribute_dict</p>\n</blockquote>\n<h3>module  generic_object</h3>\n<blockquote>\n<p>yutils.base.generic_object</p>\n</blockquote>\n<h3>module  input_checker</h3>\n<blockquote>\n<p>yutils.base.input_checker</p>\n</blockquote>\n<h3>module  list_container</h3>\n<blockquote>\n<p>yutils.base.list_container</p>\n</blockquote>\n<h3>module  pretty_printer</h3>\n<blockquote>\n<p>yutils.base.pretty_printer</p>\n</blockquote>\n<h3>module  updating_dict</h3>\n<blockquote>\n<p>yutils.base.updating_dict</p>\n</blockquote>\n<h4>object  AttributeDict</h4>\n<blockquote>\n<p>yutils.base.attribute_dict.AttributeDict</p>\n</blockquote>\n<h4>object  GenericObject</h4>\n<blockquote>\n<p>yutils.base.generic_object.GenericObject</p>\n</blockquote>\n<pre><code>A generic object you can easily use for your scripts, with a pprint and a str/repr for easy printing\n\n\n    :param object_name: The name for your object!\n    :type object_name: str\n</code></pre>\n<h4>function  dict_to_generic_object</h4>\n<blockquote>\n<p>yutils.base.generic_object.dict_to_generic_object</p>\n</blockquote>\n<pre><code>Converts a dictionary (recursively) to a GenericObject, with keys as attributes.\n\n:param dictionary: dictionary to convert (key-values will be converted to attribute-values)\n:type dictionary: dict\n:param object_name: a name for your new object's type\n:type object_name: str\n:return: GenericObject object\n</code></pre>\n<h4>object  InputChecker</h4>\n<blockquote>\n<p>yutils.base.input_checker.InputChecker</p>\n</blockquote>\n<pre><code>    Base object for making a Python object more static-typed.\n    It is useful for checking __init__ argument inputs (type and content).\n\n    Type check is defined by _INPUT_TYPES class constant. (see yutils.tools.check_object_type for usage)\n    Option check is defined by _INPUT_OPTIONS class constant.\n\n    This also:\n        - creates self._inputs as the inputs dict given, as an AttributeDict.\n        - adds each input in inputs as an attribute to your object.\n\n    :param inputs: your __init__ inputs, can be anything you wish to check\n\n    :raises: yutils.exceptions.WrongDatatype if any input is not of the specified type, defined by _INPUT_TYPES\n             yutils.exceptions.InputError if any input is not one of the options, defined by _INPUT_OPTIONS\n</code></pre>\n<h4>object  ListContainer</h4>\n<blockquote>\n<p>yutils.base.list_container.ListContainer</p>\n</blockquote>\n<pre><code>An object that wraps a list, allowing you to use your object as a list and configure it as you wish.\n\n\n    :param _list: the original list you wish to keep in the backbone of your object\n    :type _list: list\n    :param _objects_type: a plural name for your objects in your ListContainer! This is for printing your object.\n                          For Example:\n                          &gt;&gt;&gt; class Students(ListContainer):\n                          &gt;&gt;&gt;     def __init__(self):\n                          &gt;&gt;&gt;         super(Students, self).__init__([], 'students')\n    :type _objects_type: str\n</code></pre>\n<h4>object  PrintableObject</h4>\n<blockquote>\n<p>yutils.base.pretty_printer.PrintableObject</p>\n</blockquote>\n<pre><code>An object you can derive from, that has a pprint method - printing all set attributes\n</code></pre>\n<h4>object  DictValueList</h4>\n<blockquote>\n<p>yutils.base.updating_dict.DictValueList</p>\n</blockquote>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h4>object  UpdatingDict</h4>\n<blockquote>\n<p>yutils.base.updating_dict.UpdatingDict</p>\n</blockquote>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h3>module  sql_connection_details</h3>\n<blockquote>\n<p>yutils.conn.sql_connection_details</p>\n</blockquote>\n<h4>object  ConnectionDetails</h4>\n<blockquote>\n<p>yutils.conn.sql_connection_details.ConnectionDetails</p>\n</blockquote>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h4>object  ElasticConnectionDetails</h4>\n<blockquote>\n<p>yutils.conn.sql_connection_details.ElasticConnectionDetails</p>\n</blockquote>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h4>object  MSSQLConnectionDetails</h4>\n<blockquote>\n<p>yutils.conn.sql_connection_details.MSSQLConnectionDetails</p>\n</blockquote>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h4>object  MySQLConnectionDetails</h4>\n<blockquote>\n<p>yutils.conn.sql_connection_details.MySQLConnectionDetails</p>\n</blockquote>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h4>object  OracleConnectionDetails</h4>\n<blockquote>\n<p>yutils.conn.sql_connection_details.OracleConnectionDetails</p>\n</blockquote>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h3>module  exceptions</h3>\n<blockquote>\n<p>yutils.exceptions.exceptions</p>\n</blockquote>\n<h4>object  CodeMistake</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.CodeMistake</p>\n</blockquote>\n<pre><code>Gets raised to find mistakes when writing code\n\n\n    :param mistake_string: an error message explaining why this was raised\n    :type mistake_string: str\n</code></pre>\n<h4>object  InputError</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.InputError</p>\n</blockquote>\n<pre><code>Gets raised when the input wasn't as expected (e.g. isn't a valid option)\n\n\n    :param error_string: an error message explaining the InputError\n    :type error_string: str\n</code></pre>\n<h4>object  MissingAttribute</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.MissingAttribute</p>\n</blockquote>\n<pre><code>Gets raised when an attribute was expected in a certain class\n\n\n    :param class_object: the object itself that is missing an attribute\n    :type class_object: object\n    :param attribute_name: the name of the attribute that is missing\n    :type attribute_name: str\n</code></pre>\n<h4>object  MissingInput</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.MissingInput</p>\n</blockquote>\n<pre><code>Gets raised when an input was expected in a certain class but not received\n\n\n    :param class_object: the object itself that is missing an attribute\n    :type class_object: object\n    :param attribute_name: the name of the attribute that is missing\n    :type attribute_name: str\n</code></pre>\n<h4>object  UncaughtEndCase</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.UncaughtEndCase</p>\n</blockquote>\n<pre><code>Gets raised to catch unexpected cases in the future\n\n\n    :param explanation: an optional string to explain the end case.\n                        Default: 'An uncaught end case was found. Check it out!'\n    :type explanation: str\n</code></pre>\n<h4>object  UserCancellation</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.UserCancellation</p>\n</blockquote>\n<pre><code>Gets raised when a user chooses to cancel an operation, and you wish the program to abort.\n\n\n    :param operation_name: (optional) the operation the user chose to cancel\n    :type operation_name: (optional) str\n</code></pre>\n<h4>object  WrongDatatype</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.WrongDatatype</p>\n</blockquote>\n<pre><code>Gets raised when something isn't the right datatype as was expected\n\n\n    :param name: object name\n    :type name: str\n    :param expectation: expected type\n    :type expectation: type or str\n    :param reality: the object's actual type\n    :type reality: type or str\n</code></pre>\n<h4>object  WrongInputDatatype</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.WrongInputDatatype</p>\n</blockquote>\n<pre><code>Gets raised when an input argument isn't the right datatype as was expected\n\n\n    :param name: object name\n    :type name: str\n    :param expectation: expected type\n    :type expectation: type or str\n    :param reality: the object's actual type\n    :type reality: type or str\n</code></pre>\n<h4>object  YutilsException</h4>\n<blockquote>\n<p>yutils.exceptions.exceptions.YutilsException</p>\n</blockquote>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h3>module  classification</h3>\n<blockquote>\n<p>yutils.ml.classification</p>\n</blockquote>\n<h3>module  features</h3>\n<blockquote>\n<p>yutils.ml.features</p>\n</blockquote>\n<h3>module  linear_regression</h3>\n<blockquote>\n<p>yutils.ml.linear_regression</p>\n</blockquote>\n<h3>module  ml_base</h3>\n<blockquote>\n<p>yutils.ml.ml_base</p>\n</blockquote>\n<h3>module  regression</h3>\n<blockquote>\n<p>yutils.ml.regression</p>\n</blockquote>\n<h4>object  LogisticRegression</h4>\n<blockquote>\n<p>yutils.ml.classification.LogisticRegression</p>\n</blockquote>\n<h4>object  LogisticRegressionOptimizedClassifier</h4>\n<blockquote>\n<p>yutils.ml.classification.LogisticRegressionOptimizedClassifier</p>\n</blockquote>\n<h4>object  MultiClassClassification</h4>\n<blockquote>\n<p>yutils.ml.classification.MultiClassClassification</p>\n</blockquote>\n<h4>object  FeatureNormalizer</h4>\n<blockquote>\n<p>yutils.ml.features.FeatureNormalizer</p>\n</blockquote>\n<pre><code>    Normalizes features for a ML object\n\n    :param info: info to normalize, across column axis (normalizes each column by different normalization data)\n    :type info:\n</code></pre>\n<h4>object  LinearRegression</h4>\n<blockquote>\n<p>yutils.ml.linear_regression.LinearRegression</p>\n</blockquote>\n<pre><code>    Not written yet...\n\n    :param training_data:\n    :param training_results:\n    :param learning_rate:\n    :param iterations:\n    :param normalize_data:\n    :param verbose:\n</code></pre>\n<h4>object  NormalEquation</h4>\n<blockquote>\n<p>yutils.ml.linear_regression.NormalEquation</p>\n</blockquote>\n<pre><code>    Not explained yet...\n\n    :param training_data:\n    :param training_results:\n    :param assess_for_warning:\n    :param verbose:\n</code></pre>\n<h4>object  MLObject</h4>\n<blockquote>\n<p>yutils.ml.ml_base.MLObject</p>\n</blockquote>\n<pre><code>    Base object for making a Python object more static-typed.\n    It is useful for checking __init__ argument inputs (type and content).\n\n    Type check is defined by _INPUT_TYPES class constant. (see yutils.tools.check_object_type for usage)\n    Option check is defined by _INPUT_OPTIONS class constant.\n\n    This also:\n        - creates self._inputs as the inputs dict given, as an AttributeDict.\n        - adds each input in inputs as an attribute to your object.\n\n    :param inputs: your __init__ inputs, can be anything you wish to check\n\n    :raises: yutils.exceptions.WrongDatatype if any input is not of the specified type, defined by _INPUT_TYPES\n             yutils.exceptions.InputError if any input is not one of the options, defined by _INPUT_OPTIONS\n</code></pre>\n<h4>function  create_data_from_text_file</h4>\n<blockquote>\n<p>yutils.ml.ml_base.create_data_from_text_file</p>\n</blockquote>\n<h4>object  Regression</h4>\n<blockquote>\n<p>yutils.ml.regression.Regression</p>\n</blockquote>\n<h3>module  db_connection</h3>\n<blockquote>\n<p>yutils.queries.db_connection</p>\n</blockquote>\n<h3>module  oracle_field_list_format</h3>\n<blockquote>\n<p>yutils.queries.oracle_field_list_format</p>\n</blockquote>\n<h4>module  db_connection</h4>\n<blockquote>\n<p>yutils.queries.db_connection.db_connection</p>\n</blockquote>\n<h4>module  fetchers</h4>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers</p>\n</blockquote>\n<h5>object  DBConnection</h5>\n<blockquote>\n<p>yutils.queries.db_connection.db_connection.DBConnection</p>\n</blockquote>\n<pre><code>Wraps a connection to a DB, for executing SQL queries, using given connection_details.\n\n\n    :param connection_details: Details for connection to the wanted DB\n    :type: connection_details: yutils.conn.sql_connection_details.ConnectionDetails\n    :param verbose: If to print warnings or not\n    :type verbose: bool\n</code></pre>\n<h5>module  base_fetcher</h5>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.base_fetcher</p>\n</blockquote>\n<h5>module  elastic</h5>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.elastic</p>\n</blockquote>\n<h5>module  mssql</h5>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.mssql</p>\n</blockquote>\n<h5>module  mysql</h5>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.mysql</p>\n</blockquote>\n<h5>module  oracle</h5>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.oracle</p>\n</blockquote>\n<h6>object  ElasticSearchFetcher</h6>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.elastic.ElasticSearchFetcher</p>\n</blockquote>\n<h6>object  MSSQLFetcher</h6>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.mssql.MSSQLFetcher</p>\n</blockquote>\n<h6>object  MySQLFetcher</h6>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.mysql.MySQLFetcher</p>\n</blockquote>\n<h6>object  OracleFetcher</h6>\n<blockquote>\n<p>yutils.queries.db_connection.fetchers.oracle.OracleFetcher</p>\n</blockquote>\n<h4>function  format_oracle_field_list</h4>\n<blockquote>\n<p>yutils.queries.oracle_field_list_format.format_oracle_field_list</p>\n</blockquote>\n<pre><code>Takes a list that can be more than 999 values long, and wraps them in SQL OR clauses.\nThis is useful because Oracle can only accept lists 1000 values long.\n\n:param field_name: the name of the column you are querying\n:type field_name: str\n:param value_list: list of your values to format into the query\n:type value_list: list of str\n\n:return: formatted string containing your new WHERE clause\n:rtype: unicode\n</code></pre>\n<h3>module  case_conversions</h3>\n<blockquote>\n<p>yutils.tools.case_conversions</p>\n</blockquote>\n<h3>module  files</h3>\n<blockquote>\n<p>yutils.tools.files</p>\n</blockquote>\n<h3>module  list</h3>\n<blockquote>\n<p>yutils.tools.list</p>\n</blockquote>\n<h3>module  numpy_tools</h3>\n<blockquote>\n<p>yutils.tools.numpy_tools</p>\n</blockquote>\n<h3>module  pretty_print</h3>\n<blockquote>\n<p>yutils.tools.pretty_print</p>\n</blockquote>\n<h3>module  str</h3>\n<blockquote>\n<p>yutils.tools.str</p>\n</blockquote>\n<h3>module  xlsx_creator</h3>\n<blockquote>\n<p>yutils.tools.xlsx_creator</p>\n</blockquote>\n<h3>function  check_object_type</h3>\n<blockquote>\n<p>yutils.tools.check_object_type</p>\n</blockquote>\n<pre><code>This checks the types of an object using a certain syntax:\nLets say we have an object_to_check and the types_to_validate.\nThe object_to_check is the object\n\n:param object_to_check: the object you wish to check its type, and raise an exception should its type not be correct\n:type object_to_check: ....that's what we're here for....\n:param types_to_validate: defines the wanted types for the object to check:\n:type types_to_validate:\n            type - checks that object_to_check is of that type\n                    Example: float will make sure object_to_check is a float\n            list of types - checks that object_to_check is one of the types in the list\n                    Example: [int, float] will make sure object_to_check is either an int or a float\n            tuple of types - checks hierarchically:\n                                checks that object_to_check is of the type of the first item,\n                                then checks that each item in object_to_check is of the type of the second item,\n                                etc.\n                             Remember, all types in the tuple except the last must support indexing.\n                    Example: (list, str) will make sure object_to_check is a list of strings\n                             (tuple, [int, float]) will make sure object_to_check is a tuple of either ints or floats\n            dict - checks that object_to_check is an object. It's type is defined by key 'type',\n                   with other keys to be checked as the object's attributes.\n                    Example: {'type': Person, 'age': int} will make sure object_to_check is a Person object,\n                             with an 'age' attribute that is an int.\n            All values can have as many recursive dimensions as wanted.\n:param input_name: Do not use, this is for recursive inner use.\n\nMore examples\nLets say we create:\n\ninteger = 13\nunicode_str = u'foo'\nint_list = list(range(10))\ninput_object = MyObject()\ninput_object.num = 3\ninput_object.lis = [1, 'bar']\ninput_object.3dlist = [[(1, 2, 3), (1, 1, 1)], [('a', 'b', 'c'), [7, 8, 9]]]\n\nWe can send:\ncheck_object_type(integer, int)\ncheck_object_type(unicode_str, unicode)\ncheck_object_type(int_list, (list, int))\ncheck_object_type(input_object, {'type': MyObject,\n                                 'num': int,\n                                 'lis': (list, [int, str]),\n                                 '3dlist': (list, list, [tuple, list], [int, str, unicode])\n                                 })\n\n:raises:\n         Because of invalid inputs:\n            yutils.exceptions.CodeMistake - When no 'type' key is found (for when types_to_validate is a dict)\n            yutils.exceptions.WrongDatatype - When no type type is found when isinstance-ing an object's type\n         Exceptions raised by check:\n            yutils.exceptions.WrongInputDatatype - When the type is not correct during validation\n            yutils.exceptions.MissingInput - When an attribute is missing (for when types_to_validate is a dict)\n</code></pre>\n<h3>function  equivilence</h3>\n<blockquote>\n<p>yutils.tools.equivilence</p>\n</blockquote>\n<pre><code>Divides an iterator to groups, based on the function's result of every item in the iterator.\nReturns dict of lists.\n\nExample:\n    &gt;&gt;&gt; equivilence(range(10), lambda x: x % 3)\n    &gt;&gt;&gt;out&gt;&gt;&gt; {0: [0, 3, 6, 9],\n    &gt;&gt;&gt;out&gt;&gt;&gt;  1: [1, 4, 7],\n    &gt;&gt;&gt;out&gt;&gt;&gt;  2: [2, 5, 8]}\n\n:param iterator: an iterator you wish to run on and divide into groups\n:type iterator: iterator\n:param func: a function to activate on each iterator item - its result decides the return dict's keys.\n:type func: function\n\n:rtype: dict of lists (lists are groups of original iterator)\n</code></pre>\n<h4>function  camel_back_to_snake_case</h4>\n<blockquote>\n<p>yutils.tools.case_conversions.camel_back_to_snake_case</p>\n</blockquote>\n<pre><code>Turns a camelBack word to a snake_case word\n\n:param camel_back_word: wordInCamelCase\n:return: a_word_in_snake_case\n</code></pre>\n<h4>function  camel_case_to_snake_case</h4>\n<blockquote>\n<p>yutils.tools.case_conversions.camel_case_to_snake_case</p>\n</blockquote>\n<pre><code>Turns a CamelCase word to a snake_case word\n\n:param camel_case_word: AWordInCamelCase\n:return: a_word_in_snake_case\n</code></pre>\n<h4>function  snake_case_to_camel_back</h4>\n<blockquote>\n<p>yutils.tools.case_conversions.snake_case_to_camel_back</p>\n</blockquote>\n<pre><code>Turns a snake_case word to a camelBack word\n\n:param snake_case_word: a_word_in_snake_case\n:return: wordInCamelCase\n</code></pre>\n<h4>function  snake_case_to_camel_case</h4>\n<blockquote>\n<p>yutils.tools.case_conversions.snake_case_to_camel_case</p>\n</blockquote>\n<pre><code>Turns a snake_case word to a CamelCase word\n\n:param snake_case_word: a_word_in_snake_case\n:return: AWordInCamelCase\n</code></pre>\n<h4>function  get_file_length</h4>\n<blockquote>\n<p>yutils.tools.files.get_file_length</p>\n</blockquote>\n<pre><code>This function gets a file path and returns its length without reading it\n\n:param file_path: path to return length of\n:type file_path: str\n:return: file length (in bytes)\n:rtype: int\n</code></pre>\n<h4>function  recursive_glob</h4>\n<blockquote>\n<p>yutils.tools.files.recursive_glob</p>\n</blockquote>\n<pre><code>Returns a list of all files in directory including sub-directories.\n\n:param dir_name: Dir name to glob recursively on\n:type dir_name: str\n:param ignore_hidden: if to ignore hidden files (that start with '.')\n:type ignore_hidden: bool\n\n:return: list of all files in the dir_name\n:rtype: list of str\n</code></pre>\n<h4>function  save_file</h4>\n<blockquote>\n<p>yutils.tools.files.save_file</p>\n</blockquote>\n<pre><code>This function saves the file content to the destination dir (defaulted to \".\") as base_name + extension,\nbut adds a counter if needed.\n\n:param content: the content of the file\n:type content: str\n:param file_base_name: the future file name without extension\n:type file_base_name: str\n:param extension: the file name extension (for example: 'xlsx')\n:type extension: str\n:param dest_dir: where to save the file\n                 Default: current directory\n:type dest_dir: str\n\n:return: full file path file was saved to\n:rtype: unicode\n</code></pre>\n<h4>function  make_list</h4>\n<blockquote>\n<p>yutils.tools.list.make_list</p>\n</blockquote>\n<h4>function  repr_list</h4>\n<blockquote>\n<p>yutils.tools.list.repr_list</p>\n</blockquote>\n<pre><code>Returns an iterator as a string, representing the list.\n:param iterator: the iterator you wish to represent as a list\n:type iterator: iterator\n:return: representation of your iterator as a list\n:rtype: unicode\n</code></pre>\n<h4>function  get_indices_containing_all_substrings</h4>\n<blockquote>\n<p>yutils.tools.numpy_tools.get_indices_containing_all_substrings</p>\n</blockquote>\n<h4>function  is_iterable</h4>\n<blockquote>\n<p>yutils.tools.numpy_tools.is_iterable</p>\n</blockquote>\n<h4>function  magic</h4>\n<blockquote>\n<p>yutils.tools.numpy_tools.magic</p>\n</blockquote>\n<pre><code>Implementation taken from https://stackoverflow.com/questions/47834140/numpy-equivalent-of-matlabs-magic\nfrom user: user6655984\n</code></pre>\n<h4>function  normalize_array</h4>\n<blockquote>\n<p>yutils.tools.numpy_tools.normalize_array</p>\n</blockquote>\n<h4>function  r2c</h4>\n<blockquote>\n<p>yutils.tools.numpy_tools.r2c</p>\n</blockquote>\n<h4>function  to_array</h4>\n<blockquote>\n<p>yutils.tools.numpy_tools.to_array</p>\n</blockquote>\n<h4>function  pprint_dict</h4>\n<blockquote>\n<p>yutils.tools.pretty_print.pprint_dict</p>\n</blockquote>\n<pre><code>Prints a dict in a very pretty way!\n\n:param dictionary: your dict to print\n:type dictionary: dict\n:param long_value_limit: when a dict value exceeds this limit, it won't be printed\n                         Default: 120\n:type long_value_limit: int\n:param long_value_filler: A filler to print instead of a long value, must have {type} and {length} fields!\n                          Default: '&lt;Long {type} object with repr length {length}&gt;'\n:type long_value_filler: str\n:return: None\n</code></pre>\n<h4>function  pprint_list</h4>\n<blockquote>\n<p>yutils.tools.pretty_print.pprint_list</p>\n</blockquote>\n<pre><code>Prints a list in an easy, short way.\n\n:param list_to_print: the list you wish to print\n:type list_to_print: list\n:return: None\n</code></pre>\n<h4>function  turn_numeric</h4>\n<blockquote>\n<p>yutils.tools.str.turn_numeric</p>\n</blockquote>\n<pre><code>Turns a string into either an int or a float\n\n:param string: a string to assess\n:type string: str\n\n:rtype: str or float\n\n:raises: TypeError if no type was found\n</code></pre>\n<h4>object  XLSXCreator</h4>\n<blockquote>\n<p>yutils.tools.xlsx_creator.XLSXCreator</p>\n</blockquote>\n<pre><code>    A class to create an XLSX file from a table.\n    It will format the table inside an actual excel's table, according to each field's width.\n\n    :param headers: The fields of the table (headers)\n    :type headers: list of unicode\n    :param table: The table\n    :type table: matrix - list of lists of the same lengths (cells may be any datatype)\n    :param output_path: The path where to save the excel\n    :type output_path: unicode\n</code></pre>\n<h4>function  create_xlsx</h4>\n<blockquote>\n<p>yutils.tools.xlsx_creator.create_xlsx</p>\n</blockquote>\n<pre><code>Creates an XLSX file from a table.\nIt will format the table inside an actual excel's table, according to each field's width.\n\n:param headers: The fields of the table (headers)\n:type headers: list of unicode\n:param table: The table\n:type table: matrix - list of lists of the same lengths (cells may be any datatype)\n:param output_path: The path where to save the excel\n:type output_path: unicode\n</code></pre>\n<h4>function  get_next_column</h4>\n<blockquote>\n<p>yutils.tools.xlsx_creator.get_next_column</p>\n</blockquote>\n<h4>function  get_next_letter</h4>\n<blockquote>\n<p>yutils.tools.xlsx_creator.get_next_letter</p>\n</blockquote>\n<h4>function  table_to_str</h4>\n<blockquote>\n<p>yutils.tools.xlsx_creator.table_to_str</p>\n</blockquote>\n<pre><code>matrix good for the function xlsxwriter.Worksheet.add_table(['data': table))\n:param table: matrix - list of lists of the same lengths (cells may be any datatype)\n:return: fully string matrix\n</code></pre>\n\n          </div>"}, "last_serial": 6988298, "releases": {"1.2.2": [{"comment_text": "", "digests": {"md5": "909307b30060d4777ecebdf4d894e75c", "sha256": "b1b50e805b9cd425032cbd0a503a9d9bbc59d0985b777f847ac7d1e93d5ab2a8"}, "downloads": -1, "filename": "yutils-1.2.2.tar.gz", "has_sig": false, "md5_digest": "909307b30060d4777ecebdf4d894e75c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39866, "upload_time": "2019-11-18T13:19:57", "upload_time_iso_8601": "2019-11-18T13:19:57.803151Z", "url": "https://files.pythonhosted.org/packages/79/31/4743b94b3b424e99b9a603bfac4a885ce254b4248395de2b009d1ba11f3d/yutils-1.2.2.tar.gz", "yanked": false}], "1.2.20": [{"comment_text": "", "digests": {"md5": "a1230ec2be1935f8738730706e25996e", "sha256": "f82a73b685d871bb33b2e43e25d7e377998c6564b03c9498771c7f6b6183b5db"}, "downloads": -1, "filename": "yutils-1.2.20.tar.gz", "has_sig": false, "md5_digest": "a1230ec2be1935f8738730706e25996e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39840, "upload_time": "2019-11-18T13:44:23", "upload_time_iso_8601": "2019-11-18T13:44:23.454496Z", "url": "https://files.pythonhosted.org/packages/14/83/956e480d0c3f17e4442cfeee945d96bb95a216b63b2b0b242b5c2adcfac7/yutils-1.2.20.tar.gz", "yanked": false}], "1.3.1": [{"comment_text": "", "digests": {"md5": "4e33717e1d845d5006be295dec67eb05", "sha256": "87afcad5b861efabc684096e9e10c1b46d17acc5c32917c96dd9795e70843ddf"}, "downloads": -1, "filename": "yutils-1.3.1.tar.gz", "has_sig": false, "md5_digest": "4e33717e1d845d5006be295dec67eb05", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 46641, "upload_time": "2019-12-16T16:52:06", "upload_time_iso_8601": "2019-12-16T16:52:06.672508Z", "url": "https://files.pythonhosted.org/packages/a2/df/379cffd8ffd8ba43808a68f52d40f010332373b3c7f6d0de9a189228ca75/yutils-1.3.1.tar.gz", "yanked": false}], "1.3.2": [{"comment_text": "", "digests": {"md5": "511936b6b06f0a147f96f0c919375152", "sha256": "9eb01fc56351eca0f0d3885d7118bd7b3107ad25637488246792a1ebea3cffab"}, "downloads": -1, "filename": "yutils-1.3.2.tar.gz", "has_sig": false, "md5_digest": "511936b6b06f0a147f96f0c919375152", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67862, "upload_time": "2020-04-09T18:15:37", "upload_time_iso_8601": "2020-04-09T18:15:37.905843Z", "url": "https://files.pythonhosted.org/packages/ec/29/9bc7904e56b390cf7f5de07fe173abd2fe91560e34604c0b4c545f453a26/yutils-1.3.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "511936b6b06f0a147f96f0c919375152", "sha256": "9eb01fc56351eca0f0d3885d7118bd7b3107ad25637488246792a1ebea3cffab"}, "downloads": -1, "filename": "yutils-1.3.2.tar.gz", "has_sig": false, "md5_digest": "511936b6b06f0a147f96f0c919375152", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67862, "upload_time": "2020-04-09T18:15:37", "upload_time_iso_8601": "2020-04-09T18:15:37.905843Z", "url": "https://files.pythonhosted.org/packages/ec/29/9bc7904e56b390cf7f5de07fe173abd2fe91560e34604c0b4c545f453a26/yutils-1.3.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:21:19 2020"}