{"info": {"author": "The Rekall team", "author_email": "rekall-discuss@googlegroups.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Operating System :: OS Independent", "Programming Language :: Python"], "description": "# Rekall Layout Expert\n\nLive Memory analysis on the Linux platform has traditionally been difficult to\nperform. Memory analysis requires precise knowledge of struct layout information\nin memory, usually obtained through debugging symbols generated at compile\ntime. The Linux kernel is however, highly configurable, implying that debugging\ninformation is rarely applicable to systems other than the ones that generated\nit. For incident response applications, obtaining the relevant debugging\ninformation is currently a slow and manual process, limiting its usefulness in\nrapid triaging.\n\n## How do we analyze Linux systems right now?\n\nThe current process for generating a Rekall profile for a Linux system is\ntedious:\n\n1) You must find and install the kernel headers package for the same kernel as\nthe running kernel (for example `apt-get install\nlinux-headers-3.16.0-39-generic`).\n\n2) Then you need to build a kernel module (`rekall/tools/linux/module.c`) on\nthat system to generate the debug kernel module `module_dwarf.ko`.\n\n3) Finally on a system with Rekall installed, one needs to convert this to a\nRekall profile (using `rekall convert_profile 4.2.0-generic.zip\n4.2.0-generic.json` for example).\n\nThis is hard to do in an incident response situation. Sometimes servers do not\nhave the required compilers, kernel headers etc. This is especially hard if the\nkernel was cusom made. In that case it may be difficult to even find the\nrequired kernel headers package (it may not have even been built with the custom\nkernel). In all likelyhood you may need to copy the kernel config and System.map\noff the system you want to analyze to another system (with compiler tool chains\nand kernel headers installed) so you can build the profile.\n\nThis logistical issue make it difficult to do Linux live memory analysis in\npractice - so you end up taking a memory image of the system for later analysis\n(Then you have to deal with transferring huge images around, smear and lot of\nother fun problems :-).\n\nIf you really want to be prepared, you must build a huge library of kernel\nprofiles in advance. For each released kernel version, you need to have every\nvariation released by every distribution. For example in Ubuntu, there are\ngeneric and low latency variation (e.g. `linux-headers-3.16.0-39-generic`,\n`linux-headers-3.16.0-39-lowlatency`) for each minor version). You can just\nforget about having custom kernels in your library because you can not predict\nin advance what config parameters someone will change!\n\n## Is there a better way?\n\nHave you ever found yourself uttering: \"I will pay someone $1000 to find a way\nto do Linux Memory forensics without building a *$@#!% profile for every #@$#%@#\nkernel?\" - I know I have!\n\nIn a perferct world, we would just run Rekall on any Linux system, point it at\n`/proc/kcore` or `/dev/pmem` and just go without worrying about building\nprofiles! That would be nice.\n\nWe are not quite there, but almost :-). The Layout Expert is the small step\nforward. The process using the Layout Expect is much simpler:\n\n1) On the system you want to analyze, run the Layout Expert which will download\na single Pre-AST file for every kernel version (regardless of kernel\nconfiguration, distribution flavour etc.).\n\n2) Then launch the layout expert, providing it the local system's config file and\nSystem.map:\n\n```\n$ layout_tool make_profile --config_file_path boot/config-4.2.02.0.smp \\\n    --system boot/System.map-4.2.02.0.smp pre_ast_4.2.0-22.json profile.json\n\n2016-01-23 09:44:29,416 INFO     LOADING PREPROCESSOR AST FROM: pre_ast_4.2.0-22.json\n2016-01-23 09:44:34,494 INFO     DONE\n2016-01-23 09:44:34,495 INFO     LINKING INCLUDES\n2016-01-23 09:44:34,937 INFO     LINKED\n2016-01-23 09:44:34,937 INFO     EXTRACTING CONFIG FLAGS\n2016-01-23 09:44:34,994 INFO     EXTRACTED\n2016-01-23 09:44:35,108 INFO     PREPROCESSING\n2016-01-23 09:44:50,856 INFO     PREPROCESSED\n2016-01-23 09:44:50,856 INFO     Completed preprocessing pre-ast in 16 Seconds\n2016-01-23 09:44:50,856 INFO     GENERATING PURE C FILE\n2016-01-23 09:44:53,047 INFO     GENERATED\n2016-01-23 09:44:53,048 INFO     Completed generating pure C file in 2 Seconds\n2016-01-23 09:44:53,048 INFO     TRIMMING C FILE\n2016-01-23 09:45:14,340 INFO     Completed trimming C file in 21 Seconds\n2016-01-23 09:45:14,341 INFO     TRIMMED C FILE\n2016-01-23 09:45:14,354 INFO     PARSING STRUCTS\n2016-01-23 09:45:37,853 INFO     Completed parsing struct layouts in 23 Seconds\n2016-01-23 09:45:37,853 INFO     PARSED\n2016-01-23 09:45:37,853 INFO     GENERATING PROFILE\n2016-01-23 09:45:37,949 INFO     Exporting 627 structs\n2016-01-23 09:45:38,763 INFO     GENERATED\n```\n\nThe Layout Expert is able to calculate the memory layout of critical kernel\nstructures at runtime on the target system without requiring extra tools, such\nas the compiler tool-chain to be pre-installed.\n\n## How does it work?\n\nThe main problem with memory analysis on Linux is that the Linux kernel is so\nconfigurable and customizable. For example, in order to properly parse the\nmemory layout of `struct task_struct`, we can see the source:\n\n```\nstruct task_struct {\n        volatile long state;    /* -1 unrunnable, 0 runnable, >0 stopped */\n        void *stack;\n        atomic_t usage;\n        unsigned int flags;     /* per process flags, defined below */\n        unsigned int ptrace;\n\n#ifdef CONFIG_SMP\n        struct llist_node wake_entry;\n        int on_cpu;\n        struct task_struct *last_wakee;\n        unsigned long wakee_flips;\n        unsigned long wakee_flip_decay_ts;\n\n        int wake_cpu;\n#endif\n        int on_rq;\n\n        int prio, static_prio, normal_prio;\n        unsigned int rt_priority;\n        const struct sched_class *sched_class;\n        struct sched_entity se;\n        struct sched_rt_entity rt;\n#ifdef CONFIG_CGROUP_SCHED\n        struct task_group *sched_task_group;\n#endif\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n        /* list of struct preempt_notifier: */\n        struct hlist_head preempt_notifiers;\n#endif\n\n....\n```\n\nDepending on kernel configuration options there will be different members\ninserted in the middle of the struct - even for the same kernel version. This is\nprimarily why you need to compile a debug kernel module for every single kernel\nconfiguration - even of the same version. Depending on various kernel config\noptions the layouts can change dramatically (sometimes if the profiles are very\nclose some fields will be parsed correctly by Rekall but others wont - the\nfamiliar missing data in plugin outputs).\n\n\nThe Layout Expert attempts to emulate the GCC compiler chains to the extent of\nbeing able to predict the struct layout that the compiler might decide\non. Essentially we simulate the compilation of the kernel debug module.\n\nThe GCC compiler, reads the kernel config file and then preprocesses the kernel\nheaders to add or remove code depending on these configuration options. In the\nLayout Expert we wish to have a data structure that can be re-used for different\nconfigurations without needing the kernel config.\n\nTherefore, the Layout Expert first parses all the kernel headers into a\nPreprocessor Abstract Syntax Tree (Pre-AST for short). The Pre-AST includes all\nthe possibilities of each `#ifdef` branch. This is the file which the Layout\nExpert operates on.\n\nAt runtime (i.e. during system analysis), the Layout Expert combines the system\nconfiguration with the Pre-AST to produced the Preprocessed C code. In essence,\nthe headers `#ifdef` directives are removed, and the different options are\ncombined to produce a final C file, free from preprocessing macros. In this\nphase, the Layout Expert acts as a C pre-processor. The result is a huge C file\nwith all the code in all the headers stuck together.\n\nNext, the Layout Expert applies trimming to this file. This is essentially a\nquick once over pass to identify only structs, unions, enums and typedef\ninstructions. This optimization step means that we have much less code to parse\nin the next step and that the code that we do need to parse is more consistent\nand so easier to parse.\n\nFinally the Layout Expert parses the structs that Rekall is actually interested\nin (i.e. those structs with plugins that look at them). This parsing phase\nemulates a C compiler. We then apply the GCC struct layout model to the parsed\nstructs in order to predict the precise memory layout of all fields in the\nstructs (considering attributes, e.g. ``__attribute__((packed))`,\n`__attribute__((aligned(8))`).\n\nThe last step is to generate a Rekall profile ready for use.\n\n\n## Preparation.\n\nBefore the profile generation can occur in the field, we need to build the\n`Pre-AST` file for the specific kernel version. This is easy since it does not\nrequire any specific configuration file or special tools (Remember that the\nPre-AST includes all branches of any `#ifdef` directives so we do not need to\nevaluate any macros at this stage.).\n\nYou can use the kernel headers package for the specific kernel, or the full\nkernel source. There is no need to actually compile the source (i.e. `make\ndepmod` etc). Note that the kernel header package does not include \"private\" or\nnon exported structs, so these will be missing from the profile, but current\nRekall does not need those.\n\n```\n$ layout_tool build_pre_ast --source_file_path ~/rekall/tools/linux/module.c \\\n  --linux_repository_path /usr/src/linux-headers-4.2.0-22-generic/ pre_ast_4.2.0-22.json\n\n2016-01-23 10:38:00,493 INFO     LOADING AND PARSING HEADERS\n2016-01-23 10:38:58,912 INFO     Completed built pre-ast forest in 58 Seconds\n2016-01-23 10:38:58,913 INFO     LOADED AND PARSED\n```\n\n## Bugs and support\n\nThe Layout Expert is brought to you by the same people who develop Rekall, but\nit is considered a separate project. It is available under an Apache license\n(Check the LICENSE file). However, there is no official support or warranty; not\neven for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nIf you think you've found a bug, please report it at:\n\n    https://github.com/google/rekall/issues\n\nYou can also mail to the list rekall-discuss@googlegroups.com", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://www.rekall-forensic.com/", "keywords": "", "license": "Apache", "maintainer": "", "maintainer_email": "", "name": "rekall-layout-expert", "package_url": "https://pypi.org/project/rekall-layout-expert/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/rekall-layout-expert/", "project_urls": {"Homepage": "https://www.rekall-forensic.com/"}, "release_url": "https://pypi.org/project/rekall-layout-expert/1.5.0.post4/", "requires_dist": null, "requires_python": "", "summary": "Rekall Layout Expert", "version": "1.5.0.post4", "yanked": false, "html_description": "<div class=\"project-description\">\n            # Rekall Layout Expert<br><br>Live Memory analysis on the Linux platform has traditionally been difficult to<br>perform. Memory analysis requires precise knowledge of struct layout information<br>in memory, usually obtained through debugging symbols generated at compile<br>time. The Linux kernel is however, highly configurable, implying that debugging<br>information is rarely applicable to systems other than the ones that generated<br>it. For incident response applications, obtaining the relevant debugging<br>information is currently a slow and manual process, limiting its usefulness in<br>rapid triaging.<br><br>## How do we analyze Linux systems right now?<br><br>The current process for generating a Rekall profile for a Linux system is<br>tedious:<br><br>1) You must find and install the kernel headers package for the same kernel as<br>the running kernel (for example `apt-get install<br>linux-headers-3.16.0-39-generic`).<br><br>2) Then you need to build a kernel module (`rekall/tools/linux/module.c`) on<br>that system to generate the debug kernel module `module_dwarf.ko`.<br><br>3) Finally on a system with Rekall installed, one needs to convert this to a<br>Rekall profile (using `rekall convert_profile 4.2.0-generic.zip<br>4.2.0-generic.json` for example).<br><br>This is hard to do in an incident response situation. Sometimes servers do not<br>have the required compilers, kernel headers etc. This is especially hard if the<br>kernel was cusom made. In that case it may be difficult to even find the<br>required kernel headers package (it may not have even been built with the custom<br>kernel). In all likelyhood you may need to copy the kernel config and System.map<br>off the system you want to analyze to another system (with compiler tool chains<br>and kernel headers installed) so you can build the profile.<br><br>This logistical issue make it difficult to do Linux live memory analysis in<br>practice - so you end up taking a memory image of the system for later analysis<br>(Then you have to deal with transferring huge images around, smear and lot of<br>other fun problems :-).<br><br>If you really want to be prepared, you must build a huge library of kernel<br>profiles in advance. For each released kernel version, you need to have every<br>variation released by every distribution. For example in Ubuntu, there are<br>generic and low latency variation (e.g. `linux-headers-3.16.0-39-generic`,<br>`linux-headers-3.16.0-39-lowlatency`) for each minor version). You can just<br>forget about having custom kernels in your library because you can not predict<br>in advance what config parameters someone will change!<br><br>## Is there a better way?<br><br>Have you ever found yourself uttering: \"I will pay someone $1000 to find a way<br>to do Linux Memory forensics without building a *$@#!% profile for every #@$#%@#<br>kernel?\" - I know I have!<br><br>In a perferct world, we would just run Rekall on any Linux system, point it at<br>`/proc/kcore` or `/dev/pmem` and just go without worrying about building<br>profiles! That would be nice.<br><br>We are not quite there, but almost :-). The Layout Expert is the small step<br>forward. The process using the Layout Expect is much simpler:<br><br>1) On the system you want to analyze, run the Layout Expert which will download<br>a single Pre-AST file for every kernel version (regardless of kernel<br>configuration, distribution flavour etc.).<br><br>2) Then launch the layout expert, providing it the local system's config file and<br>System.map:<br><br>```<br>$ layout_tool make_profile --config_file_path boot/config-4.2.02.0.smp \\<br>    --system boot/System.map-4.2.02.0.smp pre_ast_4.2.0-22.json profile.json<br><br>2016-01-23 09:44:29,416 INFO     LOADING PREPROCESSOR AST FROM: pre_ast_4.2.0-22.json<br>2016-01-23 09:44:34,494 INFO     DONE<br>2016-01-23 09:44:34,495 INFO     LINKING INCLUDES<br>2016-01-23 09:44:34,937 INFO     LINKED<br>2016-01-23 09:44:34,937 INFO     EXTRACTING CONFIG FLAGS<br>2016-01-23 09:44:34,994 INFO     EXTRACTED<br>2016-01-23 09:44:35,108 INFO     PREPROCESSING<br>2016-01-23 09:44:50,856 INFO     PREPROCESSED<br>2016-01-23 09:44:50,856 INFO     Completed preprocessing pre-ast in 16 Seconds<br>2016-01-23 09:44:50,856 INFO     GENERATING PURE C FILE<br>2016-01-23 09:44:53,047 INFO     GENERATED<br>2016-01-23 09:44:53,048 INFO     Completed generating pure C file in 2 Seconds<br>2016-01-23 09:44:53,048 INFO     TRIMMING C FILE<br>2016-01-23 09:45:14,340 INFO     Completed trimming C file in 21 Seconds<br>2016-01-23 09:45:14,341 INFO     TRIMMED C FILE<br>2016-01-23 09:45:14,354 INFO     PARSING STRUCTS<br>2016-01-23 09:45:37,853 INFO     Completed parsing struct layouts in 23 Seconds<br>2016-01-23 09:45:37,853 INFO     PARSED<br>2016-01-23 09:45:37,853 INFO     GENERATING PROFILE<br>2016-01-23 09:45:37,949 INFO     Exporting 627 structs<br>2016-01-23 09:45:38,763 INFO     GENERATED<br>```<br><br>The Layout Expert is able to calculate the memory layout of critical kernel<br>structures at runtime on the target system without requiring extra tools, such<br>as the compiler tool-chain to be pre-installed.<br><br>## How does it work?<br><br>The main problem with memory analysis on Linux is that the Linux kernel is so<br>configurable and customizable. For example, in order to properly parse the<br>memory layout of `struct task_struct`, we can see the source:<br><br>```<br>struct task_struct {<br>        volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */<br>        void *stack;<br>        atomic_t usage;<br>        unsigned int flags;     /* per process flags, defined below */<br>        unsigned int ptrace;<br><br>#ifdef CONFIG_SMP<br>        struct llist_node wake_entry;<br>        int on_cpu;<br>        struct task_struct *last_wakee;<br>        unsigned long wakee_flips;<br>        unsigned long wakee_flip_decay_ts;<br><br>        int wake_cpu;<br>#endif<br>        int on_rq;<br><br>        int prio, static_prio, normal_prio;<br>        unsigned int rt_priority;<br>        const struct sched_class *sched_class;<br>        struct sched_entity se;<br>        struct sched_rt_entity rt;<br>#ifdef CONFIG_CGROUP_SCHED<br>        struct task_group *sched_task_group;<br>#endif<br><br>#ifdef CONFIG_PREEMPT_NOTIFIERS<br>        /* list of struct preempt_notifier: */<br>        struct hlist_head preempt_notifiers;<br>#endif<br><br>....<br>```<br><br>Depending on kernel configuration options there will be different members<br>inserted in the middle of the struct - even for the same kernel version. This is<br>primarily why you need to compile a debug kernel module for every single kernel<br>configuration - even of the same version. Depending on various kernel config<br>options the layouts can change dramatically (sometimes if the profiles are very<br>close some fields will be parsed correctly by Rekall but others wont - the<br>familiar missing data in plugin outputs).<br><br><br>The Layout Expert attempts to emulate the GCC compiler chains to the extent of<br>being able to predict the struct layout that the compiler might decide<br>on. Essentially we simulate the compilation of the kernel debug module.<br><br>The GCC compiler, reads the kernel config file and then preprocesses the kernel<br>headers to add or remove code depending on these configuration options. In the<br>Layout Expert we wish to have a data structure that can be re-used for different<br>configurations without needing the kernel config.<br><br>Therefore, the Layout Expert first parses all the kernel headers into a<br>Preprocessor Abstract Syntax Tree (Pre-AST for short). The Pre-AST includes all<br>the possibilities of each `#ifdef` branch. This is the file which the Layout<br>Expert operates on.<br><br>At runtime (i.e. during system analysis), the Layout Expert combines the system<br>configuration with the Pre-AST to produced the Preprocessed C code. In essence,<br>the headers `#ifdef` directives are removed, and the different options are<br>combined to produce a final C file, free from preprocessing macros. In this<br>phase, the Layout Expert acts as a C pre-processor. The result is a huge C file<br>with all the code in all the headers stuck together.<br><br>Next, the Layout Expert applies trimming to this file. This is essentially a<br>quick once over pass to identify only structs, unions, enums and typedef<br>instructions. This optimization step means that we have much less code to parse<br>in the next step and that the code that we do need to parse is more consistent<br>and so easier to parse.<br><br>Finally the Layout Expert parses the structs that Rekall is actually interested<br>in (i.e. those structs with plugins that look at them). This parsing phase<br>emulates a C compiler. We then apply the GCC struct layout model to the parsed<br>structs in order to predict the precise memory layout of all fields in the<br>structs (considering attributes, e.g. ``__attribute__((packed))`,<br>`__attribute__((aligned(8))`).<br><br>The last step is to generate a Rekall profile ready for use.<br><br><br>## Preparation.<br><br>Before the profile generation can occur in the field, we need to build the<br>`Pre-AST` file for the specific kernel version. This is easy since it does not<br>require any specific configuration file or special tools (Remember that the<br>Pre-AST includes all branches of any `#ifdef` directives so we do not need to<br>evaluate any macros at this stage.).<br><br>You can use the kernel headers package for the specific kernel, or the full<br>kernel source. There is no need to actually compile the source (i.e. `make<br>depmod` etc). Note that the kernel header package does not include \"private\" or<br>non exported structs, so these will be missing from the profile, but current<br>Rekall does not need those.<br><br>```<br>$ layout_tool build_pre_ast --source_file_path ~/rekall/tools/linux/module.c \\<br>  --linux_repository_path /usr/src/linux-headers-4.2.0-22-generic/ pre_ast_4.2.0-22.json<br><br>2016-01-23 10:38:00,493 INFO     LOADING AND PARSING HEADERS<br>2016-01-23 10:38:58,912 INFO     Completed built pre-ast forest in 58 Seconds<br>2016-01-23 10:38:58,913 INFO     LOADED AND PARSED<br>```<br><br>## Bugs and support<br><br>The Layout Expert is brought to you by the same people who develop Rekall, but<br>it is considered a separate project. It is available under an Apache license<br>(Check the LICENSE file). However, there is no official support or warranty; not<br>even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<br><br>If you think you've found a bug, please report it at:<br><br>    https://github.com/google/rekall/issues<br><br>You can also mail to the list rekall-discuss@googlegroups.com\n          </div>"}, "last_serial": 2690215, "releases": {"1.4.1.post0.dev128": [], "1.5.0": [{"comment_text": "", "digests": {"md5": "09eea5590f552a1fe97b6e44f7edc3f8", "sha256": "f1967d50eb00b533b873f053e6bebb2d9806cbef6851564ebc8b6505923a062b"}, "downloads": -1, "filename": "rekall-layout-expert-1.5.0.zip", "has_sig": false, "md5_digest": "09eea5590f552a1fe97b6e44f7edc3f8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 146535, "upload_time": "2016-03-28T06:13:32", "upload_time_iso_8601": "2016-03-28T06:13:32.496139Z", "url": "https://files.pythonhosted.org/packages/bc/9a/79fee3b2140fae165c18d6eb9fd84ac0103ff937835c1a53ac3d6924b741/rekall-layout-expert-1.5.0.zip", "yanked": false}], "1.5.0.post4": [{"comment_text": "", "digests": {"md5": "3b8d7667cf2f863e01024fffdb845640", "sha256": "d599f56f732ea9de4d72f06dc8915a15ba40a46f8568059e9a5aa961f1fc8711"}, "downloads": -1, "filename": "rekall-layout-expert-1.5.0.post4.zip", "has_sig": false, "md5_digest": "3b8d7667cf2f863e01024fffdb845640", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 147491, "upload_time": "2016-03-29T00:01:29", "upload_time_iso_8601": "2016-03-29T00:01:29.033166Z", "url": "https://files.pythonhosted.org/packages/c8/73/148696164da6d7d813911a4462b9efb873b3dd5a5446586a1b5f93abb1a4/rekall-layout-expert-1.5.0.post4.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3b8d7667cf2f863e01024fffdb845640", "sha256": "d599f56f732ea9de4d72f06dc8915a15ba40a46f8568059e9a5aa961f1fc8711"}, "downloads": -1, "filename": "rekall-layout-expert-1.5.0.post4.zip", "has_sig": false, "md5_digest": "3b8d7667cf2f863e01024fffdb845640", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 147491, "upload_time": "2016-03-29T00:01:29", "upload_time_iso_8601": "2016-03-29T00:01:29.033166Z", "url": "https://files.pythonhosted.org/packages/c8/73/148696164da6d7d813911a4462b9efb873b3dd5a5446586a1b5f93abb1a4/rekall-layout-expert-1.5.0.post4.zip", "yanked": false}], "timestamp": "Fri May  8 03:05:06 2020"}