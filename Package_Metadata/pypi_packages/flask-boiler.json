{"info": {"author": "Bill Rao", "author_email": "billrao@me.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# flask-boiler\n\n[![Build Status](https://travis-ci.com/billyrrr/flask-boiler.svg?branch=master)](https://travis-ci.com/billyrrr/flask-boiler)\n[![Coverage Status](https://coveralls.io/repos/github/billyrrr/flask-boiler/badge.svg?branch=master)](https://coveralls.io/github/billyrrr/flask-boiler?branch=master)\n[![Documentation Status](https://readthedocs.org/projects/flask-boiler/badge/?version=latest)](https://flask-boiler.readthedocs.io/en/latest/?badge=latest)\n\n\"boiler\": **B**ackend-**O**riginated **I**nstantly-**L**oaded **E**ntity **R**epository \n\nFlask-boiler manages your application state with Firestore. \nYou can create view models that aggregates underlying data \nsources and store them immediately and permanently in Firestore. \nAs a result, your front end development will be as easy as \nusing Firestore. Flask-boiler is comparable to Spring Web Reactive. \n\nDemo: \n\nWhen you change the attendance status of one of the participants \nin the meeting, all other participants receive an updated version \nof the list of people attending the meeting. \n\n![Untitled_2](https://user-images.githubusercontent.com/24789156/71137341-be0e1000-2242-11ea-98cb-53ad237cac43.gif)\n\n\n\nSome reasons that you may want to use this framework:\n- The automatically documented API accelerates your development\n- You want to use Firestore to build your front end, but\n    you have to give up because your data contains many\n    relational reference\n- You want to move some business logic to back end\n- You are open to trying something new and contributing to a framework\n- You want to develop a new reactive service to your existing flask app\n\nThis framework is at ***beta testing stage***. \nAPI is not guaranteed and ***may*** change. \n\nDocumentations: [readthedocs](https://flask-boiler.readthedocs.io/)\n\nQuickstart: [Quickstart](https://flask-boiler.readthedocs.io/en/latest/quickstart_link.html)\n\nAPI Documentations: [API Docs](https://flask-boiler.readthedocs.io/en/latest/apidoc/flask_boiler.html)\n\nExample of a Project using flask-boiler: [gravitate-backend](https://github.com/billyrrr/gravitate-backend)\n\n## Installation\nIn your project's requirements.txt, \n\n```\n\n# Append to requirements, unless repeating existing requirements\n\ngoogle-cloud-firestore\nflask-boiler  # Not released to pypi yet \n\n```\n\nConfigure virtual environment \n```\npip install virtualenv\nvirtualenv env\nsource env/bin/activate\n```\n\nIn your project directory, \n\n```\npip install -r requirements.txt\n```\n\nSee more in [Quickstart](https://flask-boiler.readthedocs.io/en/latest/quickstart_link.html). \n\n<!--## Usage-->\n\n<!--### Business Properties Binding-->\n<!--You can bind a view model to its business properties (underlying domain model).-->\n<!--See `examples/binding_example.py`. (Currently breaking)-->\n\n<!--```python-->\n\n<!--vm: Luggages = Luggages.new(vm_ref)-->\n\n<!--vm.bind_to(key=id_a, obj_type=\"LuggageItem\", doc_id=id_a)-->\n<!--vm.bind_to(key=id_b, obj_type=\"LuggageItem\", doc_id=id_b)-->\n<!--vm.register_listener()-->\n\n<!--```-->\n\n### State Management\n\nYou can combine information gathered in domain models and serve them in Firestore, so \nthat front end can read all data required from a single document or collection, \nwithout client-side queries and excessive server roundtrip time. \n\nThere is a medium [article](https://medium.com/resolvejs/resolve-redux-backend-ebcfc79bbbea) \n that explains a similar architecture called \"reSolve\" architecture. \n\nSee ```examples/meeting_room/view_models``` on how to use flask-boiler \nto expose a \"view model\" in firestore that can be queried directly \nby front end without aggregation.  \n\n### Save data\n\n```python\n\ndef CityBase(DomainModel):\n    _collection_name = \"cities\"\n    \nclass City(CityBase):\n    _schema_cls = CitySchema \n    \nCity.new(\n        doc_id='SF',\n        name='San Francisco',\n        state='CA', \n        country='USA', \n        capital=False, \n        populations=860000,\n        regions=['west_coast', 'norcal']).save()\n\n# ...\n```\n\n### Relationship\n\nFlask-boiler adds an option to retrieve a relation with \nminimal steps. Take an example given from SQLAlchemy, \n\n```python\ncategory_id = utils.random_id()\npy = Category.new(doc_id=category_id)\npy.name = \"Python\"\n\npost_id = utils.random_id()\np = Post.new(doc_id=post_id)\np.title = \"snakes\"\np.body = \"Ssssssss\"\n\n# py.posts.append(p)\np.category = py\n\np.save()\n\n```\n\nSee ```examples/relationship_example.py```\n\n\n### Context Management\nIn `__init__` of your project source root:\n```python\nimport os\n\nfrom flask_boiler import context\nfrom flask_boiler import config\n\nConfig = config.Config\n\ntesting_config = Config(app_name=\"your_app_name\",\n                        debug=True,\n                        testing=True,\n                        certificate_path=os.path.curdir + \"/../your_project/config_jsons/your_certificate.json\")\n\nCTX = context.Context\nCTX.read(testing_config)\n```\n\nNote that initializing `Config` with `certificate_path` is unstable and\nmay be changed later.\n\nIn your project code,\n\n```python\nfrom flask_boiler import context\n\nCTX = context.Context\n\n# Retrieves firestore database instance \nCTX.db\n\n# Retrieves firebase app instance \nCTX.firebase_app\n\n```\n\n\n\n### Automatically Generated Swagger Docs\nYou can enable auto-generated swagger docs. See: `examples/view_example.py`\n\n\n\n### Create Flask View\nYou can create a flask view to specify how a view model is read and changed.\n\n```python\n\n\napp = Flask(__name__)\n\nmeeting_session_mediator = view_mediator.ViewMediator(\n    view_model_cls=MeetingSession,\n    app=app,\n    mutation_cls=MeetingSessionMutation\n)\nmeeting_session_mediator.add_list_get(\n    rule=\"/meeting_sessions\",\n    list_get_view=meeting_session_ops.ListGet\n)\n\nmeeting_session_mediator.add_instance_get(\n    rule=\"/meeting_sessions/<string:doc_id>\")\nmeeting_session_mediator.add_instance_patch(\n    rule=\"/meeting_sessions/<string:doc_id>\")\n\nuser_mediator = view_mediator.ViewMediator(\n    view_model_cls=UserView,\n    app=app,\n)\nuser_mediator.add_instance_get(\n    rule=\"/users/<string:doc_id>\"\n)\n\nswagger = Swagger(app)\n\napp.run(debug=True)\n\n\n```\n\n## Object Lifecycle\n\n### Once\n\nObject created with ```cls.new``` -> \nObject exported with ```obj.to_view_dict```. \n\n### Multi\n\nObject created when a new domain model is created in database -> \nObject changed when underlying datasource changes -> \nObject calls ```self.notify``` \n\n## Advantages\n\n### Decoupled Domain Model and View Model\nUsing Firebase Firestore sometimes require duplicated fields\nacross several documents in order to both query the data and\ndisplay them properly in front end. Flask-boiler solves this\nproblem by decoupling domain model and view model. View model\nare generated and refreshed automatically as domain model\nchanges. This means that you will only have to write business\nlogics on the domain model without worrying about how the data\nwill be displayed. This also means that the View Models can\nbe displayed directly in front end, while supporting\nreal-time features of Firebase Firestore.\n\n### One-step Configuration\nRather than configuring the network and different certificate\nsettings for your database and other cloud services. All you\nhave to do is to enable related services on Google Cloud\nConsole, and add your certificate. Flask-boiler configures\nall the services you need, and expose them as a singleton\nContext object across the project.\n\n### Redundancy\nSince all View Models are persisted in Firebase Firestore.\nEven if your App Instance is offline, the users can still\naccess a view of the data from Firebase Firestore. Every\nView is also a Flask View, so you can also access the data\nwith auto-generated REST API, in case Firebase Firestore is\nnot viable.\n\n### Added Safety\nBy separating business data from documents that are accessible\nto the front end, you have more control over which data is\ndisplayed depending on the user's role.\n\n### One-step Documentation\nAll ViewModels have automatically generated documentations\n(provided by Flasgger). This helps AGILE teams keep their\ndocumentations and actual code in sync.\n\n### Fully-extendable\nWhen you need better performance or relational database\nsupport, you can always refactor a specific layer by\nadding modules such as `flask-sqlalchemy`.\n\n\n## Comparisons \n\n### GraphQL\n\nIn GraphQL, the fields are evaluated with each query, but \nflask-boiler evaluates the fields if and only if the \nunderlying data source changes. This leads to faster \nread for data that has not changed for a while. Also, \nthe data source is expected to be consistent, as the \nfield evaluation are triggered after all changes made in \none transaction to firestore is read. \n\nGraphQL, however, lets front-end customize the return. You \nmust define the exact structure you want to return in flask-boiler. \nThis nevertheless has its advantage as most documentations \nof the request and response can be done the same way as REST API. \n\n### REST API / Flask\n\nREST API does not cache or store the response. When \na view model is evaluated by flask-boiler, the response \nis stored in firestore forever until update or manual removal. \n\nFlask-boiler controls role-based access with security rules \nintegrated with Firestore. REST API usually controls these \naccess with a JWT token. \n\n### Redux\n\nRedux is implemented mostly in front end. Flask-boiler targets \nback end and is more scalable, since all data are communicated \nwith Firestore, a infinitely scalable NoSQL datastore. \n\nFlask-boiler is declarative, and Redux is imperative. \nThe design pattern of REDUX requires you to write functional programming \nin domain models, but flask-boiler favors a different approach: \nViewModel reads and calculates data from domain models \nand exposes the attribute as a property getter. (When writing \nto DomainModel, the view model changes domain model and \nexposes the operation as a property setter). \nNevertheless, you can still add function callbacks that are \ntriggered after a domain model is updated, but this \nmay introduce concurrency issues and is not perfectly supported \ndue to the design tradeoff in flask-boiler. \n\n\n### Architecture Diagram: \n\n![Architecture Diagram](https://user-images.githubusercontent.com/24789156/70380617-06e4d100-18f3-11ea-9111-4398ed0e865c.png)\n\n## Contributing\nPull requests are welcome. \n\nPlease make sure to update tests as appropriate.\n\n## License\n[MIT](https://choosealicense.com/licenses/mit/)", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/billyrrr/flask-boiler/archive/v0.0.1.b7.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/billyrrr/flask-boiler", "keywords": "firebase,firestore,ORM,flasgger,flask,backend,nosql,reactive,framework", "license": "", "maintainer": "", "maintainer_email": "", "name": "flask-boiler", "package_url": "https://pypi.org/project/flask-boiler/", "platform": "", "project_url": "https://pypi.org/project/flask-boiler/", "project_urls": {"Download": "https://github.com/billyrrr/flask-boiler/archive/v0.0.1.b7.tar.gz", "Homepage": "https://github.com/billyrrr/flask-boiler"}, "release_url": "https://pypi.org/project/flask-boiler/0.0.1b7/", "requires_dist": null, "requires_python": "", "summary": "Build reactive back end with ease", "version": "0.0.1b7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>flask-boiler</h1>\n<p><a href=\"https://travis-ci.com/billyrrr/flask-boiler\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6fed8189abb03f89cf41d58e24f5b18acda07314/68747470733a2f2f7472617669732d63692e636f6d2f62696c6c797272722f666c61736b2d626f696c65722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/billyrrr/flask-boiler?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5da93fa785760c6d70c76dc50d8bb208d5f8a080/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f62696c6c797272722f666c61736b2d626f696c65722f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://flask-boiler.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ed45c4a11317a35bdb218927e209f5dd726f0692/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f666c61736b2d626f696c65722f62616467652f3f76657273696f6e3d6c6174657374\"></a></p>\n<p>\"boiler\": <strong>B</strong>ackend-<strong>O</strong>riginated <strong>I</strong>nstantly-<strong>L</strong>oaded <strong>E</strong>ntity <strong>R</strong>epository</p>\n<p>Flask-boiler manages your application state with Firestore.\nYou can create view models that aggregates underlying data\nsources and store them immediately and permanently in Firestore.\nAs a result, your front end development will be as easy as\nusing Firestore. Flask-boiler is comparable to Spring Web Reactive.</p>\n<p>Demo:</p>\n<p>When you change the attendance status of one of the participants\nin the meeting, all other participants receive an updated version\nof the list of people attending the meeting.</p>\n<p><img alt=\"Untitled_2\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5b602c6b9b916ceb7c158ef17325fa68fd827373/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f32343738393135362f37313133373334312d62653065313030302d323234322d313165612d393863622d3533616432333763616334332e676966\"></p>\n<p>Some reasons that you may want to use this framework:</p>\n<ul>\n<li>The automatically documented API accelerates your development</li>\n<li>You want to use Firestore to build your front end, but\nyou have to give up because your data contains many\nrelational reference</li>\n<li>You want to move some business logic to back end</li>\n<li>You are open to trying something new and contributing to a framework</li>\n<li>You want to develop a new reactive service to your existing flask app</li>\n</ul>\n<p>This framework is at <em><strong>beta testing stage</strong></em>.\nAPI is not guaranteed and <em><strong>may</strong></em> change.</p>\n<p>Documentations: <a href=\"https://flask-boiler.readthedocs.io/\" rel=\"nofollow\">readthedocs</a></p>\n<p>Quickstart: <a href=\"https://flask-boiler.readthedocs.io/en/latest/quickstart_link.html\" rel=\"nofollow\">Quickstart</a></p>\n<p>API Documentations: <a href=\"https://flask-boiler.readthedocs.io/en/latest/apidoc/flask_boiler.html\" rel=\"nofollow\">API Docs</a></p>\n<p>Example of a Project using flask-boiler: <a href=\"https://github.com/billyrrr/gravitate-backend\" rel=\"nofollow\">gravitate-backend</a></p>\n<h2>Installation</h2>\n<p>In your project's requirements.txt,</p>\n<pre><code>\n# Append to requirements, unless repeating existing requirements\n\ngoogle-cloud-firestore\nflask-boiler  # Not released to pypi yet \n\n</code></pre>\n<p>Configure virtual environment</p>\n<pre><code>pip install virtualenv\nvirtualenv env\nsource env/bin/activate\n</code></pre>\n<p>In your project directory,</p>\n<pre><code>pip install -r requirements.txt\n</code></pre>\n<p>See more in <a href=\"https://flask-boiler.readthedocs.io/en/latest/quickstart_link.html\" rel=\"nofollow\">Quickstart</a>.</p>\n\n\n\n\n\n\n\n\n\n\n<h3>State Management</h3>\n<p>You can combine information gathered in domain models and serve them in Firestore, so\nthat front end can read all data required from a single document or collection,\nwithout client-side queries and excessive server roundtrip time.</p>\n<p>There is a medium <a href=\"https://medium.com/resolvejs/resolve-redux-backend-ebcfc79bbbea\" rel=\"nofollow\">article</a>\nthat explains a similar architecture called \"reSolve\" architecture.</p>\n<p>See <code>examples/meeting_room/view_models</code> on how to use flask-boiler\nto expose a \"view model\" in firestore that can be queried directly\nby front end without aggregation.</p>\n<h3>Save data</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">CityBase</span><span class=\"p\">(</span><span class=\"n\">DomainModel</span><span class=\"p\">):</span>\n    <span class=\"n\">_collection_name</span> <span class=\"o\">=</span> <span class=\"s2\">\"cities\"</span>\n    \n<span class=\"k\">class</span> <span class=\"nc\">City</span><span class=\"p\">(</span><span class=\"n\">CityBase</span><span class=\"p\">):</span>\n    <span class=\"n\">_schema_cls</span> <span class=\"o\">=</span> <span class=\"n\">CitySchema</span> \n    \n<span class=\"n\">City</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">(</span>\n        <span class=\"n\">doc_id</span><span class=\"o\">=</span><span class=\"s1\">'SF'</span><span class=\"p\">,</span>\n        <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'San Francisco'</span><span class=\"p\">,</span>\n        <span class=\"n\">state</span><span class=\"o\">=</span><span class=\"s1\">'CA'</span><span class=\"p\">,</span> \n        <span class=\"n\">country</span><span class=\"o\">=</span><span class=\"s1\">'USA'</span><span class=\"p\">,</span> \n        <span class=\"n\">capital</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> \n        <span class=\"n\">populations</span><span class=\"o\">=</span><span class=\"mi\">860000</span><span class=\"p\">,</span>\n        <span class=\"n\">regions</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'west_coast'</span><span class=\"p\">,</span> <span class=\"s1\">'norcal'</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># ...</span>\n</pre>\n<h3>Relationship</h3>\n<p>Flask-boiler adds an option to retrieve a relation with\nminimal steps. Take an example given from SQLAlchemy,</p>\n<pre><span class=\"n\">category_id</span> <span class=\"o\">=</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">random_id</span><span class=\"p\">()</span>\n<span class=\"n\">py</span> <span class=\"o\">=</span> <span class=\"n\">Category</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">doc_id</span><span class=\"o\">=</span><span class=\"n\">category_id</span><span class=\"p\">)</span>\n<span class=\"n\">py</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s2\">\"Python\"</span>\n\n<span class=\"n\">post_id</span> <span class=\"o\">=</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">random_id</span><span class=\"p\">()</span>\n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">Post</span><span class=\"o\">.</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">doc_id</span><span class=\"o\">=</span><span class=\"n\">post_id</span><span class=\"p\">)</span>\n<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s2\">\"snakes\"</span>\n<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"s2\">\"Ssssssss\"</span>\n\n<span class=\"c1\"># py.posts.append(p)</span>\n<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">category</span> <span class=\"o\">=</span> <span class=\"n\">py</span>\n\n<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">()</span>\n</pre>\n<p>See <code>examples/relationship_example.py</code></p>\n<h3>Context Management</h3>\n<p>In <code>__init__</code> of your project source root:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">flask_boiler</span> <span class=\"kn\">import</span> <span class=\"n\">context</span>\n<span class=\"kn\">from</span> <span class=\"nn\">flask_boiler</span> <span class=\"kn\">import</span> <span class=\"n\">config</span>\n\n<span class=\"n\">Config</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">Config</span>\n\n<span class=\"n\">testing_config</span> <span class=\"o\">=</span> <span class=\"n\">Config</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s2\">\"your_app_name\"</span><span class=\"p\">,</span>\n                        <span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                        <span class=\"n\">testing</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                        <span class=\"n\">certificate_path</span><span class=\"o\">=</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">curdir</span> <span class=\"o\">+</span> <span class=\"s2\">\"/../your_project/config_jsons/your_certificate.json\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">CTX</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Context</span>\n<span class=\"n\">CTX</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">testing_config</span><span class=\"p\">)</span>\n</pre>\n<p>Note that initializing <code>Config</code> with <code>certificate_path</code> is unstable and\nmay be changed later.</p>\n<p>In your project code,</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">flask_boiler</span> <span class=\"kn\">import</span> <span class=\"n\">context</span>\n\n<span class=\"n\">CTX</span> <span class=\"o\">=</span> <span class=\"n\">context</span><span class=\"o\">.</span><span class=\"n\">Context</span>\n\n<span class=\"c1\"># Retrieves firestore database instance </span>\n<span class=\"n\">CTX</span><span class=\"o\">.</span><span class=\"n\">db</span>\n\n<span class=\"c1\"># Retrieves firebase app instance </span>\n<span class=\"n\">CTX</span><span class=\"o\">.</span><span class=\"n\">firebase_app</span>\n</pre>\n<h3>Automatically Generated Swagger Docs</h3>\n<p>You can enable auto-generated swagger docs. See: <code>examples/view_example.py</code></p>\n<h3>Create Flask View</h3>\n<p>You can create a flask view to specify how a view model is read and changed.</p>\n<pre><span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Flask</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n<span class=\"n\">meeting_session_mediator</span> <span class=\"o\">=</span> <span class=\"n\">view_mediator</span><span class=\"o\">.</span><span class=\"n\">ViewMediator</span><span class=\"p\">(</span>\n    <span class=\"n\">view_model_cls</span><span class=\"o\">=</span><span class=\"n\">MeetingSession</span><span class=\"p\">,</span>\n    <span class=\"n\">app</span><span class=\"o\">=</span><span class=\"n\">app</span><span class=\"p\">,</span>\n    <span class=\"n\">mutation_cls</span><span class=\"o\">=</span><span class=\"n\">MeetingSessionMutation</span>\n<span class=\"p\">)</span>\n<span class=\"n\">meeting_session_mediator</span><span class=\"o\">.</span><span class=\"n\">add_list_get</span><span class=\"p\">(</span>\n    <span class=\"n\">rule</span><span class=\"o\">=</span><span class=\"s2\">\"/meeting_sessions\"</span><span class=\"p\">,</span>\n    <span class=\"n\">list_get_view</span><span class=\"o\">=</span><span class=\"n\">meeting_session_ops</span><span class=\"o\">.</span><span class=\"n\">ListGet</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">meeting_session_mediator</span><span class=\"o\">.</span><span class=\"n\">add_instance_get</span><span class=\"p\">(</span>\n    <span class=\"n\">rule</span><span class=\"o\">=</span><span class=\"s2\">\"/meeting_sessions/&lt;string:doc_id&gt;\"</span><span class=\"p\">)</span>\n<span class=\"n\">meeting_session_mediator</span><span class=\"o\">.</span><span class=\"n\">add_instance_patch</span><span class=\"p\">(</span>\n    <span class=\"n\">rule</span><span class=\"o\">=</span><span class=\"s2\">\"/meeting_sessions/&lt;string:doc_id&gt;\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">user_mediator</span> <span class=\"o\">=</span> <span class=\"n\">view_mediator</span><span class=\"o\">.</span><span class=\"n\">ViewMediator</span><span class=\"p\">(</span>\n    <span class=\"n\">view_model_cls</span><span class=\"o\">=</span><span class=\"n\">UserView</span><span class=\"p\">,</span>\n    <span class=\"n\">app</span><span class=\"o\">=</span><span class=\"n\">app</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n<span class=\"n\">user_mediator</span><span class=\"o\">.</span><span class=\"n\">add_instance_get</span><span class=\"p\">(</span>\n    <span class=\"n\">rule</span><span class=\"o\">=</span><span class=\"s2\">\"/users/&lt;string:doc_id&gt;\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">swagger</span> <span class=\"o\">=</span> <span class=\"n\">Swagger</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">)</span>\n\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<h2>Object Lifecycle</h2>\n<h3>Once</h3>\n<p>Object created with <code>cls.new</code> -&gt;\nObject exported with <code>obj.to_view_dict</code>.</p>\n<h3>Multi</h3>\n<p>Object created when a new domain model is created in database -&gt;\nObject changed when underlying datasource changes -&gt;\nObject calls <code>self.notify</code></p>\n<h2>Advantages</h2>\n<h3>Decoupled Domain Model and View Model</h3>\n<p>Using Firebase Firestore sometimes require duplicated fields\nacross several documents in order to both query the data and\ndisplay them properly in front end. Flask-boiler solves this\nproblem by decoupling domain model and view model. View model\nare generated and refreshed automatically as domain model\nchanges. This means that you will only have to write business\nlogics on the domain model without worrying about how the data\nwill be displayed. This also means that the View Models can\nbe displayed directly in front end, while supporting\nreal-time features of Firebase Firestore.</p>\n<h3>One-step Configuration</h3>\n<p>Rather than configuring the network and different certificate\nsettings for your database and other cloud services. All you\nhave to do is to enable related services on Google Cloud\nConsole, and add your certificate. Flask-boiler configures\nall the services you need, and expose them as a singleton\nContext object across the project.</p>\n<h3>Redundancy</h3>\n<p>Since all View Models are persisted in Firebase Firestore.\nEven if your App Instance is offline, the users can still\naccess a view of the data from Firebase Firestore. Every\nView is also a Flask View, so you can also access the data\nwith auto-generated REST API, in case Firebase Firestore is\nnot viable.</p>\n<h3>Added Safety</h3>\n<p>By separating business data from documents that are accessible\nto the front end, you have more control over which data is\ndisplayed depending on the user's role.</p>\n<h3>One-step Documentation</h3>\n<p>All ViewModels have automatically generated documentations\n(provided by Flasgger). This helps AGILE teams keep their\ndocumentations and actual code in sync.</p>\n<h3>Fully-extendable</h3>\n<p>When you need better performance or relational database\nsupport, you can always refactor a specific layer by\nadding modules such as <code>flask-sqlalchemy</code>.</p>\n<h2>Comparisons</h2>\n<h3>GraphQL</h3>\n<p>In GraphQL, the fields are evaluated with each query, but\nflask-boiler evaluates the fields if and only if the\nunderlying data source changes. This leads to faster\nread for data that has not changed for a while. Also,\nthe data source is expected to be consistent, as the\nfield evaluation are triggered after all changes made in\none transaction to firestore is read.</p>\n<p>GraphQL, however, lets front-end customize the return. You\nmust define the exact structure you want to return in flask-boiler.\nThis nevertheless has its advantage as most documentations\nof the request and response can be done the same way as REST API.</p>\n<h3>REST API / Flask</h3>\n<p>REST API does not cache or store the response. When\na view model is evaluated by flask-boiler, the response\nis stored in firestore forever until update or manual removal.</p>\n<p>Flask-boiler controls role-based access with security rules\nintegrated with Firestore. REST API usually controls these\naccess with a JWT token.</p>\n<h3>Redux</h3>\n<p>Redux is implemented mostly in front end. Flask-boiler targets\nback end and is more scalable, since all data are communicated\nwith Firestore, a infinitely scalable NoSQL datastore.</p>\n<p>Flask-boiler is declarative, and Redux is imperative.\nThe design pattern of REDUX requires you to write functional programming\nin domain models, but flask-boiler favors a different approach:\nViewModel reads and calculates data from domain models\nand exposes the attribute as a property getter. (When writing\nto DomainModel, the view model changes domain model and\nexposes the operation as a property setter).\nNevertheless, you can still add function callbacks that are\ntriggered after a domain model is updated, but this\nmay introduce concurrency issues and is not perfectly supported\ndue to the design tradeoff in flask-boiler.</p>\n<h3>Architecture Diagram:</h3>\n<p><img alt=\"Architecture Diagram\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dddb48c49531a9f83ef5b37e439d38e36027dc32/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f32343738393135362f37303338303631372d30366534643130302d313866332d313165612d393131312d3433393865643065383635632e706e67\"></p>\n<h2>Contributing</h2>\n<p>Pull requests are welcome.</p>\n<p>Please make sure to update tests as appropriate.</p>\n<h2>License</h2>\n<p><a href=\"https://choosealicense.com/licenses/mit/\" rel=\"nofollow\">MIT</a></p>\n\n          </div>"}, "last_serial": 7037316, "releases": {"0.0.1a2": [{"comment_text": "", "digests": {"md5": "b3988a82f11209870696dd78037538fe", "sha256": "9129ae8690c723047dd9f48d0082fdf1d7567d7e995dec2a2ea8759650489b9f"}, "downloads": -1, "filename": "flask_boiler-0.0.1a2.tar.gz", "has_sig": false, "md5_digest": "b3988a82f11209870696dd78037538fe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22494, "upload_time": "2019-09-01T20:14:55", "upload_time_iso_8601": "2019-09-01T20:14:55.841864Z", "url": "https://files.pythonhosted.org/packages/fc/ba/ffda972c17ff141fdcec70b0cb5da6a148cfee629873b3cf1b932f5c7f5c/flask_boiler-0.0.1a2.tar.gz", "yanked": false}], "0.0.1a3": [{"comment_text": "", "digests": {"md5": "0a92f2d5d2dd2d7d7ec799e174451d83", "sha256": "c434bc3d165924556428fd530dfa0ead3af825b91312f13dd1255cb06d38fe83"}, "downloads": -1, "filename": "flask_boiler-0.0.1a3.tar.gz", "has_sig": false, "md5_digest": "0a92f2d5d2dd2d7d7ec799e174451d83", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22813, "upload_time": "2019-09-01T22:17:15", "upload_time_iso_8601": "2019-09-01T22:17:15.896155Z", "url": "https://files.pythonhosted.org/packages/fc/41/eb93dbfa2ce76c7137a17147b1b2e8ccc08ee35fa4f080ccfb4ac87ec843/flask_boiler-0.0.1a3.tar.gz", "yanked": false}], "0.0.1a4": [{"comment_text": "", "digests": {"md5": "0ea572012f30ca5607d06338210e84ef", "sha256": "bdfe7825cb4a202cf7b1947c6f13fdcc871caa060d5ec9e183bdfec261d962a7"}, "downloads": -1, "filename": "flask_boiler-0.0.1a4.tar.gz", "has_sig": false, "md5_digest": "0ea572012f30ca5607d06338210e84ef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22816, "upload_time": "2019-09-01T22:28:50", "upload_time_iso_8601": "2019-09-01T22:28:50.323641Z", "url": "https://files.pythonhosted.org/packages/25/82/c82795f050a56561fd49be64de2c94e62c9079ff9aaf242d6b8eb1a13445/flask_boiler-0.0.1a4.tar.gz", "yanked": false}], "0.0.1b1": [{"comment_text": "", "digests": {"md5": "7a757b3c4e7512bbbffa56c974430052", "sha256": "1988963bd3244ae0acb3f1406fd7514b29d53109da02579419589b3970c995f1"}, "downloads": -1, "filename": "flask_boiler-0.0.1b1.tar.gz", "has_sig": false, "md5_digest": "7a757b3c4e7512bbbffa56c974430052", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55618, "upload_time": "2020-01-09T19:33:39", "upload_time_iso_8601": "2020-01-09T19:33:39.599991Z", "url": "https://files.pythonhosted.org/packages/64/af/76c201a31e001ba15c976dbb3d62c1a16cfb2921fed87e2cd64461b8b85b/flask_boiler-0.0.1b1.tar.gz", "yanked": false}], "0.0.1b2": [{"comment_text": "", "digests": {"md5": "218576a18a93aefb0d3835a01d84a41f", "sha256": "5d8e14f59d361b30db430b27b393753ccc2192395b2b44d54ee5765eb17c0d51"}, "downloads": -1, "filename": "flask_boiler-0.0.1b2.tar.gz", "has_sig": false, "md5_digest": "218576a18a93aefb0d3835a01d84a41f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 57090, "upload_time": "2020-03-11T20:17:13", "upload_time_iso_8601": "2020-03-11T20:17:13.738437Z", "url": "https://files.pythonhosted.org/packages/c8/2b/bf31e1892ec4ec9ec73ad95b7c4bd8e7b79d8b38eb8b72c926bddc64bf5b/flask_boiler-0.0.1b2.tar.gz", "yanked": false}], "0.0.1b3": [{"comment_text": "", "digests": {"md5": "abe9eb8866700538a5d801c7debf342c", "sha256": "c987144f4e076077986997c3ef689368c2432d15c91e5ed6261148602d93682e"}, "downloads": -1, "filename": "flask_boiler-0.0.1b3.tar.gz", "has_sig": false, "md5_digest": "abe9eb8866700538a5d801c7debf342c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58249, "upload_time": "2020-03-13T20:50:22", "upload_time_iso_8601": "2020-03-13T20:50:22.917946Z", "url": "https://files.pythonhosted.org/packages/3a/d9/36f613edfbe3b3c352374f874c173a77e9dae1b841bc1e7e887174f81ff8/flask_boiler-0.0.1b3.tar.gz", "yanked": false}], "0.0.1b7": [{"comment_text": "", "digests": {"md5": "fda5e5294367ec254f53d16bae8aefae", "sha256": "70244992b673e65c539777cf06d01654e6a10f8f304827ba1fd4cd0da26ea9fb"}, "downloads": -1, "filename": "flask_boiler-0.0.1b7.tar.gz", "has_sig": false, "md5_digest": "fda5e5294367ec254f53d16bae8aefae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67189, "upload_time": "2020-04-17T04:17:28", "upload_time_iso_8601": "2020-04-17T04:17:28.015985Z", "url": "https://files.pythonhosted.org/packages/20/e6/954dbf4d6cd287e77a404abb3ad3093c4b033275777c010de48c1938fafa/flask_boiler-0.0.1b7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fda5e5294367ec254f53d16bae8aefae", "sha256": "70244992b673e65c539777cf06d01654e6a10f8f304827ba1fd4cd0da26ea9fb"}, "downloads": -1, "filename": "flask_boiler-0.0.1b7.tar.gz", "has_sig": false, "md5_digest": "fda5e5294367ec254f53d16bae8aefae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67189, "upload_time": "2020-04-17T04:17:28", "upload_time_iso_8601": "2020-04-17T04:17:28.015985Z", "url": "https://files.pythonhosted.org/packages/20/e6/954dbf4d6cd287e77a404abb3ad3093c4b033275777c010de48c1938fafa/flask_boiler-0.0.1b7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:03:04 2020"}