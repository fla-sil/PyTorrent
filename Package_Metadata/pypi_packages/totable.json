{"info": {"author": "brentp", "author_email": "bpederse@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: C", "Programming Language :: Python", "Topic :: Database :: Database Engines/Servers"], "description": "+++++++\nToTable\n+++++++\n\n.. contents ::\n\nAbout\n-----\n\nPythonic access to `tokyo cabinet`_ table database api. (NOTE: The \noriginal `cython`_ code was from `pykesto`_.)\nThe aims is to provide a simple syntax to load and query data in a table.\nMost of the work is handled by  the `Col`_ query interface. e.g.\n::\n\n    >>> from totable import ToTable, Col\n    >>> tbl = ToTable('t.tct', 'w')\n    >>> result = tbl.select(Col('age') > 18, Col('name').startswith('T'))\n\nto allow querying columns with numbers and letters transparently. Even\nthough tokyo cabinet stores all values as strings.\nAnd more syntatic sugar below.\n\nInstall\n-------\nfirst, install Tokyo-Cabinet `source`_, then,\nfrom a the directory containing this file:\n::\n\n    # requires cython for now.\n    $ cython src/ctotable.pyx\n    $ python setup.py build_ext -i\n\n    # test \n    $ PYTHONPATH=. python totable/tests/test_totable.py\n\n    # install\n    $ sudo python setup.py install\n\n\nExample Use\n-----------\nMake some fake data. Note it works just like a DBM or dictionary, except\nthat the values themselves are dictionaries.\n::\n\n    >>> from totable import ToTable, Col\n    >>> tbl = ToTable('doctest.tct', 'w')\n    >>> fnames = ['fred', 'jane', 'john', 'mark', 'bill', 'ted', 'ann']\n    >>> lnames = ['smith', 'cox', 'kit', 'ttt', 'zzz', 'ark', 'ddk']\n    >>> for i in range(len(fnames)):\n    ...     tbl[str(i)] = {'fname': fnames[i], 'lname': lnames[i],\n    ...                    'age': str((10 + i) * 2)}\n    ...     tbl[str(i + len(fnames))] = {'fname': fnames[i],\n    ...                                  'lname': lnames[len(lnames) - i - 1],\n    ...                                   'age': str((30 + i) * 2)}\n\n    >>> len(tbl)\n    14\n\nCol\n===\n\n`Col`_, as sent to the select method makes it easy to do queries on a database\nthe format is Col(colname) == 'Fred' where colname is one of the keys in the\ndictionary items in the database. or can use kwargs to select()\n::\n\n    >>> tbl.select(lname='cox')\n    [('1', {'lname': 'cox', 'age': '22', 'fname': 'jane'}), ('12', {'lname': 'cox', 'age': '70', 'fname': 'ted'})]\n\nthough using Col gives more power\n\nstartswith\n**********\n::\n\n    >>> results = tbl.select(Col('fname').startswith('j'))\n    >>> [d['fname'] + ' ' + d['lname'] for k, d in results]\n    ['jane cox', 'jane ark', 'john kit', 'john zzz']\n\nendswith\n********\n::\n\n    #and combine queries by sending them in together.\n    >>> results = tbl.select(Col('fname').startswith('j'), Col('lname').endswith('k'))\n    >>> [d['fname'] + ' ' + d['lname'] for k, d in results]\n    ['jane ark']\n\nlike\n****\nthis works like an sql query with '%' on either end. (dont attach those\nvalues to the query!). so to get everyone with and 'e' in their firstname...\n::\n\n    >>> r = tbl.select(Col('fname').like('e'))\n    >>> sorted(set([v['fname'] for k, v in r]))\n    ['fred', 'jane', 'ted']\n\nin_list\n*******\nreturn row that exactly match *1* of the values in the list.\n::\n\n    >>> r = tbl.select(Col('fname').in_list(['ted', 'fred']))\n    >>> sorted(set([v['fname'] for k, v in r]))\n    ['fred', 'ted']\n\n    >>> r = tbl.select(Col('age').in_list([20, 70]))\n    >>> sorted(set([v['age'] for k, v in r]))\n    ['20', '70']\n\nbetween\n*******\nuse for number querying between a min and max. includes the endpoints.\n::\n\n    >>> r = tbl.select(Col('age').between(68, 70))\n    >>> [v['age'] for k, v in r]\n    ['68', '70']\n\nnumeric queries (richcmp)\n*************************\nin TC, everything is stored as strings, but you can force number based \ncomparisons with ToTable by using (you guessed it) a number. Or using \na string for non-numeric comparisons.\n::\n\n    >>> results = tbl.select(Col('age') > 68)\n    >>> [d['age'] for k, d in results]\n    ['70', '72']\n\ncombining queries\n*****************\njust add multiple Col() arguments to the select() call\nand they will be essentially *and*'ed together.\n::\n\n    >>> results = tbl.select(Col('age') > 68, Col('age') < 72)\n    >>> [d['age'] for k, d in results]\n    ['70']\n\nNegate(~)\n*********\nfor example get everything that's not a given value...\n::\n\n    >>> results = tbl.select(~Col('age') <= 68)\n    >>> [d['age'] for k, d in results]\n    ['70', '72']\n\n    #all rows where fname is not 'jane' \n    >>> results = tbl.select(~Col('fname') != 'jane')\n    >>> 'jane' in [d['fname'] for k, d in results]\n    False\n\nRegular Expression Matching\n***************************\nsupports normal regular expression characters \"[ $ ^ | \" , etc.\n\n::\n\n    >>> results = tbl.select(Col('fname').matches(\"a\"))\n    >>> sorted(set([d['fname'] for k, d in results]))\n    ['ann', 'jane', 'mark']\n\n    >>> results = tbl.select(Col('fname').matches(\"^a\"))\n    >>> sorted(set([d['fname'] for k, d in results]))\n    ['ann']\n\n\nOffset/Limit\n============\njust like SQL, yo.\n\n::\n\n    >>> results = tbl.select(Col('age') < 68, limit=1)\n    >>> len(results)\n    1\n\norder\n=====\ncurrently only works for string keys. use '-' for descending and \n'+' for ascending\n\n::\n\n    >>> [v['fname'] for k, v in tbl.select(lname='cox', order='-fname')]\n    ['ted', 'jane']\n\n    # ascending\n    >>> [v['fname'] for k, v in tbl.select(lname='cox', order='+fname')]\n    ['jane', 'ted']\n\n\nvalues\n======\nTC is a key-value store, but it also acts as a table. it may be\nconvenient to get just the values as you'd expect from a database\ntable. Note in all examples above, the 'k'ey is not used, only \nthe value dictionary. This can be made simpler with 'values_only'.\nWhen 'values_only' is True, some python call overhead is removed\nas well.\n\n::\n    >>> tbl.select(Col('fname').matches(\"^a\"), values_only=True)\n    [{'lname': 'ddk', 'age': '32', 'fname': 'ann'}, {'lname': 'smith', 'age': '72', 'fname': 'ann'}]\n    \n\nSchemaless\n==========\nsince it's schemaless, you can add anything\n\n::\n\n    >>> tbl['weird'] = {\"val\": \"hello\"}\n    >>> tbl['weird']\n    {'val': 'hello'}\n\ndelete\n======\ndelete as expected for a dictionary interface.\n\n::\n\n    >>> del tbl['weird']\n    >>> print tbl.get('weird')\n    None\n\n\nput\n===\nencapsulates put, putkeep and putcat with a mode kwarg that takes\n'p' or 'k' or 'c' respectively.\n::\n\n    >>> tbl.put('a', {'a': '1'}, mode='p')\n    >>> tbl.put('a', {'a': '2'}, mode='k')\n    'keep'\n    >>> assert tbl['a'] == {'a': '1'}\n\n    >>> tbl.put('b', {'a': '3'}, mode='k')\n    'put'\n\n    >>> tbl.put('a', {'b': '99'}, 'c')\n    >>> assert tbl['a'] == {'a': '1', 'b': '99'}\n\nPerformance Tuning\n==================\nTokyo Cabinet allows you to `tune` or `optimize` a table. the available parameters are:\n\n    * `bnum` specifies the number of elements of the bucket array.\n      Suggested size of 'bnum' is about from 0.5 to 4 times of the number\n      of all records to be stored. default is about 132K.\n\n    * `apow` specifies the size of record alignment by power of 2.\n      The default value is 4 standing for 2^4=16.\n\n    * `fpow` specifies the maximum number of elements of the free block\n      pool by power of 2. The default value is 10 standing for 2^10=1024.\n\n    * `opts` specifies options by bitwise-or (|):\n\n      * 'TDBTLARGE' must be specified to use a database larger than 2GB. \n        (you must also specify a config flag when compiling the TC library to\n        enable this)\n      * 'TDBTDEFLATE' use Deflate encoding.\n      * 'TDBTBZIP' use BZIP2 encoding.\n      * 'TDBTTCBS' use TCBS encoding.\n\nThe other parameters: `cache`_ and `mmap_size`_ are explained below.\n\ntune\n****\nThe arguments can be sent to the constructor.\n::\n\n    >>> import totable\n    >>> t = ToTable(\"some.tct\", 'w', bnum=1234, fpow=6, \\\n    ...                    opts=totable.TDBTLARGE | totable.TDBTBZIP)\n\n    >>> t.close()\n\noptimize\n********\noptimize is called on an database opened with mode='w'. if no arguments are\nspecified, it will automatically adjust 'bnum' (only) according to the number\nof elements in the table.\n::\n\n    >>> t = ToTable(\"some.tct\", 'w')\n\n    # ... add some records ...\n    >>> t.optimize()\n    True\n\nmmap_size\n*********\n`mmap_size` is the size of mapped memory. default is 67,108,864 (64MB)\nset in the constructor. this is `xmsiz` in TC parlance.\n::\n\n    >>> t.close()\n    >>> t = ToTable(\"some.tct\", 'w', mmap_size=128 * 1e6) # ~128MB.\n\ncache\n*****\nTC also allows setting various caching parameters.\n* `rcnum` is the max number of records to be cached. default is 0\n* `lcnum` is the max number of leaf-nodes to be cached. default is 4096\n* `ncnum` is the max number of non-leaf nodes cached. default is 512\nthese also must be set in the constructor.\n::\n\n    >>> t.close()\n    >>> t = ToTable(\"some.tct\", 'w', rcnum=1e7, lcnum=32768)\n\n\nindex\n*****\ncreate or delete a 's'tring or 'd'ecimal index on a column for faster queries.\n::    \n\n    # create a decimal index on the number column 'age'.\n    >>> tbl.create_index('age', 'd')\n    True\n\n    # create a 'string index on the string column 'fname'.\n    >>> tbl.create_index('fname', 's')\n    True\n\n    # remove the index.\n    >>> tbl.delete_index('fname')\n    True\n\n    # optimize the index\n    >>> tbl.optimize_index('age')\n    True\n\nclear\n=====\nremove all records from the db.\n::\n\n    >>> len(tbl)\n    16\n    >>> tbl.clear()\n    >>> len(tbl)\n    0\n\ntransaction\n===========\ndo stuff in a transaction. a rollback() is performed on any exceptions.\n::\n\n    >>> try:\n    ...     with transaction(tbl):\n    ...         tbl['zzz'] = {'a': '4'}\n    ...         1/0\n    ... except: pass\n\n    >>> 'zzz' in tbl\n    False\n\n\nSee Also\n--------\n\n    * `tc`_ nice c-python bindings for all of the `tokyo cabinet`_ db types\n      including the table\n\n    * `pykesto`_ the project from which this library is taken. aims to provide\n      transactions on top of `tokyo cabinet`_ .\n\n    * to help out, see TODO list at top of `ctcable.pyx`_\n\n    * tokyo cabinet database api http://1978th.net/tokyocabinet/spex-en.html#tctdbapi\n\n    \n\n.. _`pykesto`: http://code.google.com/p/pykesto/\n.. _`tokyo cabinet`: http://1978th.net/tokyocabinet/\n.. _`tc`: http://github.com/rsms/tc\n.. _`cython`: http://cython.org/\n.. _`ctcable.pyx`: http://github.com/brentp/totable/blob/master/src/ctotable.pyx\n.. _`source`: http://sourceforge.net/projects/tokyocabinet/files/", "description_content_type": null, "docs_url": "https://pythonhosted.org/totable/", "download_url": "http://", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "totable", "package_url": "https://pypi.org/project/totable/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/totable/", "project_urls": {"Download": "http://", "Homepage": "http://"}, "release_url": "https://pypi.org/project/totable/0.1/", "requires_dist": null, "requires_python": null, "summary": "Cython wrapper for tokyo cabinet table", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#about\" id=\"id1\" rel=\"nofollow\">About</a></li>\n<li><a href=\"#install\" id=\"id2\" rel=\"nofollow\">Install</a></li>\n<li><a href=\"#example-use\" id=\"id3\" rel=\"nofollow\">Example Use</a><ul>\n<li><a href=\"#col\" id=\"id4\" rel=\"nofollow\">Col</a><ul>\n<li><a href=\"#startswith\" id=\"id5\" rel=\"nofollow\">startswith</a></li>\n<li><a href=\"#endswith\" id=\"id6\" rel=\"nofollow\">endswith</a></li>\n<li><a href=\"#like\" id=\"id7\" rel=\"nofollow\">like</a></li>\n<li><a href=\"#in-list\" id=\"id8\" rel=\"nofollow\">in_list</a></li>\n<li><a href=\"#between\" id=\"id9\" rel=\"nofollow\">between</a></li>\n<li><a href=\"#numeric-queries-richcmp\" id=\"id10\" rel=\"nofollow\">numeric queries (richcmp)</a></li>\n<li><a href=\"#combining-queries\" id=\"id11\" rel=\"nofollow\">combining queries</a></li>\n<li><a href=\"#negate\" id=\"id12\" rel=\"nofollow\">Negate(~)</a></li>\n<li><a href=\"#regular-expression-matching\" id=\"id13\" rel=\"nofollow\">Regular Expression Matching</a></li>\n</ul>\n</li>\n<li><a href=\"#offset-limit\" id=\"id14\" rel=\"nofollow\">Offset/Limit</a></li>\n<li><a href=\"#order\" id=\"id15\" rel=\"nofollow\">order</a></li>\n<li><a href=\"#values\" id=\"id16\" rel=\"nofollow\">values</a></li>\n<li><a href=\"#schemaless\" id=\"id17\" rel=\"nofollow\">Schemaless</a></li>\n<li><a href=\"#delete\" id=\"id18\" rel=\"nofollow\">delete</a></li>\n<li><a href=\"#put\" id=\"id19\" rel=\"nofollow\">put</a></li>\n<li><a href=\"#performance-tuning\" id=\"id20\" rel=\"nofollow\">Performance Tuning</a><ul>\n<li><a href=\"#tune\" id=\"id21\" rel=\"nofollow\">tune</a></li>\n<li><a href=\"#optimize\" id=\"id22\" rel=\"nofollow\">optimize</a></li>\n<li><a href=\"#mmap-size\" id=\"id23\" rel=\"nofollow\">mmap_size</a></li>\n<li><a href=\"#cache\" id=\"id24\" rel=\"nofollow\">cache</a></li>\n<li><a href=\"#index\" id=\"id25\" rel=\"nofollow\">index</a></li>\n</ul>\n</li>\n<li><a href=\"#clear\" id=\"id26\" rel=\"nofollow\">clear</a></li>\n<li><a href=\"#transaction\" id=\"id27\" rel=\"nofollow\">transaction</a></li>\n</ul>\n</li>\n<li><a href=\"#see-also\" id=\"id28\" rel=\"nofollow\">See Also</a></li>\n</ul>\n</div>\n<div id=\"about\">\n<h2><a href=\"#id1\" rel=\"nofollow\">About</a></h2>\n<p>Pythonic access to <a href=\"http://1978th.net/tokyocabinet/\" rel=\"nofollow\">tokyo cabinet</a> table database api. (NOTE: The\noriginal <a href=\"http://cython.org/\" rel=\"nofollow\">cython</a> code was from <a href=\"http://code.google.com/p/pykesto/\" rel=\"nofollow\">pykesto</a>.)\nThe aims is to provide a simple syntax to load and query data in a table.\nMost of the work is handled by  the <a href=\"#col\" rel=\"nofollow\">Col</a> query interface. e.g.</p>\n<pre>&gt;&gt;&gt; from totable import ToTable, Col\n&gt;&gt;&gt; tbl = ToTable('t.tct', 'w')\n&gt;&gt;&gt; result = tbl.select(Col('age') &gt; 18, Col('name').startswith('T'))\n</pre>\n<p>to allow querying columns with numbers and letters transparently. Even\nthough tokyo cabinet stores all values as strings.\nAnd more syntatic sugar below.</p>\n</div>\n<div id=\"install\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Install</a></h2>\n<p>first, install Tokyo-Cabinet <a href=\"http://sourceforge.net/projects/tokyocabinet/files/\" rel=\"nofollow\">source</a>, then,\nfrom a the directory containing this file:</p>\n<pre># requires cython for now.\n$ cython src/ctotable.pyx\n$ python setup.py build_ext -i\n\n# test\n$ PYTHONPATH=. python totable/tests/test_totable.py\n\n# install\n$ sudo python setup.py install\n</pre>\n</div>\n<div id=\"example-use\">\n<h2><a href=\"#id3\" rel=\"nofollow\">Example Use</a></h2>\n<p>Make some fake data. Note it works just like a DBM or dictionary, except\nthat the values themselves are dictionaries.</p>\n<pre>&gt;&gt;&gt; from totable import ToTable, Col\n&gt;&gt;&gt; tbl = ToTable('doctest.tct', 'w')\n&gt;&gt;&gt; fnames = ['fred', 'jane', 'john', 'mark', 'bill', 'ted', 'ann']\n&gt;&gt;&gt; lnames = ['smith', 'cox', 'kit', 'ttt', 'zzz', 'ark', 'ddk']\n&gt;&gt;&gt; for i in range(len(fnames)):\n...     tbl[str(i)] = {'fname': fnames[i], 'lname': lnames[i],\n...                    'age': str((10 + i) * 2)}\n...     tbl[str(i + len(fnames))] = {'fname': fnames[i],\n...                                  'lname': lnames[len(lnames) - i - 1],\n...                                   'age': str((30 + i) * 2)}\n\n&gt;&gt;&gt; len(tbl)\n14\n</pre>\n<div id=\"col\">\n<h3><a href=\"#id4\" rel=\"nofollow\">Col</a></h3>\n<p><a href=\"#col\" rel=\"nofollow\">Col</a>, as sent to the select method makes it easy to do queries on a database\nthe format is Col(colname) == \u2018Fred\u2019 where colname is one of the keys in the\ndictionary items in the database. or can use kwargs to select()</p>\n<pre>&gt;&gt;&gt; tbl.select(lname='cox')\n[('1', {'lname': 'cox', 'age': '22', 'fname': 'jane'}), ('12', {'lname': 'cox', 'age': '70', 'fname': 'ted'})]\n</pre>\n<p>though using Col gives more power</p>\n<div id=\"startswith\">\n<h4><a href=\"#id5\" rel=\"nofollow\">startswith</a></h4>\n<pre>&gt;&gt;&gt; results = tbl.select(Col('fname').startswith('j'))\n&gt;&gt;&gt; [d['fname'] + ' ' + d['lname'] for k, d in results]\n['jane cox', 'jane ark', 'john kit', 'john zzz']\n</pre>\n</div>\n<div id=\"endswith\">\n<h4><a href=\"#id6\" rel=\"nofollow\">endswith</a></h4>\n<pre>#and combine queries by sending them in together.\n&gt;&gt;&gt; results = tbl.select(Col('fname').startswith('j'), Col('lname').endswith('k'))\n&gt;&gt;&gt; [d['fname'] + ' ' + d['lname'] for k, d in results]\n['jane ark']\n</pre>\n</div>\n<div id=\"like\">\n<h4><a href=\"#id7\" rel=\"nofollow\">like</a></h4>\n<p>this works like an sql query with \u2018%\u2019 on either end. (dont attach those\nvalues to the query!). so to get everyone with and \u2018e\u2019 in their firstname\u2026</p>\n<pre>&gt;&gt;&gt; r = tbl.select(Col('fname').like('e'))\n&gt;&gt;&gt; sorted(set([v['fname'] for k, v in r]))\n['fred', 'jane', 'ted']\n</pre>\n</div>\n<div id=\"in-list\">\n<h4><a href=\"#id8\" rel=\"nofollow\">in_list</a></h4>\n<p>return row that exactly match <em>1</em> of the values in the list.</p>\n<pre>&gt;&gt;&gt; r = tbl.select(Col('fname').in_list(['ted', 'fred']))\n&gt;&gt;&gt; sorted(set([v['fname'] for k, v in r]))\n['fred', 'ted']\n\n&gt;&gt;&gt; r = tbl.select(Col('age').in_list([20, 70]))\n&gt;&gt;&gt; sorted(set([v['age'] for k, v in r]))\n['20', '70']\n</pre>\n</div>\n<div id=\"between\">\n<h4><a href=\"#id9\" rel=\"nofollow\">between</a></h4>\n<p>use for number querying between a min and max. includes the endpoints.</p>\n<pre>&gt;&gt;&gt; r = tbl.select(Col('age').between(68, 70))\n&gt;&gt;&gt; [v['age'] for k, v in r]\n['68', '70']\n</pre>\n</div>\n<div id=\"numeric-queries-richcmp\">\n<h4><a href=\"#id10\" rel=\"nofollow\">numeric queries (richcmp)</a></h4>\n<p>in TC, everything is stored as strings, but you can force number based\ncomparisons with ToTable by using (you guessed it) a number. Or using\na string for non-numeric comparisons.</p>\n<pre>&gt;&gt;&gt; results = tbl.select(Col('age') &gt; 68)\n&gt;&gt;&gt; [d['age'] for k, d in results]\n['70', '72']\n</pre>\n</div>\n<div id=\"combining-queries\">\n<h4><a href=\"#id11\" rel=\"nofollow\">combining queries</a></h4>\n<p>just add multiple Col() arguments to the select() call\nand they will be essentially <em>and</em>\u2019ed together.</p>\n<pre>&gt;&gt;&gt; results = tbl.select(Col('age') &gt; 68, Col('age') &lt; 72)\n&gt;&gt;&gt; [d['age'] for k, d in results]\n['70']\n</pre>\n</div>\n<div id=\"negate\">\n<h4><a href=\"#id12\" rel=\"nofollow\">Negate(~)</a></h4>\n<p>for example get everything that\u2019s not a given value\u2026</p>\n<pre>&gt;&gt;&gt; results = tbl.select(~Col('age') &lt;= 68)\n&gt;&gt;&gt; [d['age'] for k, d in results]\n['70', '72']\n\n#all rows where fname is not 'jane'\n&gt;&gt;&gt; results = tbl.select(~Col('fname') != 'jane')\n&gt;&gt;&gt; 'jane' in [d['fname'] for k, d in results]\nFalse\n</pre>\n</div>\n<div id=\"regular-expression-matching\">\n<h4><a href=\"#id13\" rel=\"nofollow\">Regular Expression Matching</a></h4>\n<p>supports normal regular expression characters \u201c[ $ ^ | \u201d , etc.</p>\n<pre>&gt;&gt;&gt; results = tbl.select(Col('fname').matches(\"a\"))\n&gt;&gt;&gt; sorted(set([d['fname'] for k, d in results]))\n['ann', 'jane', 'mark']\n\n&gt;&gt;&gt; results = tbl.select(Col('fname').matches(\"^a\"))\n&gt;&gt;&gt; sorted(set([d['fname'] for k, d in results]))\n['ann']\n</pre>\n</div>\n</div>\n<div id=\"offset-limit\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Offset/Limit</a></h3>\n<p>just like SQL, yo.</p>\n<pre>&gt;&gt;&gt; results = tbl.select(Col('age') &lt; 68, limit=1)\n&gt;&gt;&gt; len(results)\n1\n</pre>\n</div>\n<div id=\"order\">\n<h3><a href=\"#id15\" rel=\"nofollow\">order</a></h3>\n<p>currently only works for string keys. use \u2018-\u2018 for descending and\n\u2018+\u2019 for ascending</p>\n<pre>&gt;&gt;&gt; [v['fname'] for k, v in tbl.select(lname='cox', order='-fname')]\n['ted', 'jane']\n\n# ascending\n&gt;&gt;&gt; [v['fname'] for k, v in tbl.select(lname='cox', order='+fname')]\n['jane', 'ted']\n</pre>\n</div>\n<div id=\"values\">\n<h3><a href=\"#id16\" rel=\"nofollow\">values</a></h3>\n<p>TC is a key-value store, but it also acts as a table. it may be\nconvenient to get just the values as you\u2019d expect from a database\ntable. Note in all examples above, the \u2018k\u2019ey is not used, only\nthe value dictionary. This can be made simpler with \u2018values_only\u2019.\nWhen \u2018values_only\u2019 is True, some python call overhead is removed\nas well.</p>\n<dl>\n<dt>::</dt>\n<dd><pre>&gt;&gt;&gt; tbl.select(Col('fname').matches(\"^a\"), values_only=True)\n[{'lname': 'ddk', 'age': '32', 'fname': 'ann'}, {'lname': 'smith', 'age': '72', 'fname': 'ann'}]\n</pre>\n</dd>\n</dl>\n</div>\n<div id=\"schemaless\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Schemaless</a></h3>\n<p>since it\u2019s schemaless, you can add anything</p>\n<pre>&gt;&gt;&gt; tbl['weird'] = {\"val\": \"hello\"}\n&gt;&gt;&gt; tbl['weird']\n{'val': 'hello'}\n</pre>\n</div>\n<div id=\"delete\">\n<h3><a href=\"#id18\" rel=\"nofollow\">delete</a></h3>\n<p>delete as expected for a dictionary interface.</p>\n<pre>&gt;&gt;&gt; del tbl['weird']\n&gt;&gt;&gt; print tbl.get('weird')\nNone\n</pre>\n</div>\n<div id=\"put\">\n<h3><a href=\"#id19\" rel=\"nofollow\">put</a></h3>\n<p>encapsulates put, putkeep and putcat with a mode kwarg that takes\n\u2018p\u2019 or \u2018k\u2019 or \u2018c\u2019 respectively.</p>\n<pre>&gt;&gt;&gt; tbl.put('a', {'a': '1'}, mode='p')\n&gt;&gt;&gt; tbl.put('a', {'a': '2'}, mode='k')\n'keep'\n&gt;&gt;&gt; assert tbl['a'] == {'a': '1'}\n\n&gt;&gt;&gt; tbl.put('b', {'a': '3'}, mode='k')\n'put'\n\n&gt;&gt;&gt; tbl.put('a', {'b': '99'}, 'c')\n&gt;&gt;&gt; assert tbl['a'] == {'a': '1', 'b': '99'}\n</pre>\n</div>\n<div id=\"performance-tuning\">\n<h3><a href=\"#id20\" rel=\"nofollow\">Performance Tuning</a></h3>\n<p>Tokyo Cabinet allows you to <cite>tune</cite> or <cite>optimize</cite> a table. the available parameters are:</p>\n<blockquote>\n<ul>\n<li><cite>bnum</cite> specifies the number of elements of the bucket array.\nSuggested size of \u2018bnum\u2019 is about from 0.5 to 4 times of the number\nof all records to be stored. default is about 132K.</li>\n<li><cite>apow</cite> specifies the size of record alignment by power of 2.\nThe default value is 4 standing for 2^4=16.</li>\n<li><cite>fpow</cite> specifies the maximum number of elements of the free block\npool by power of 2. The default value is 10 standing for 2^10=1024.</li>\n<li><cite>opts</cite> specifies options by bitwise-or (|):<ul>\n<li>\u2018TDBTLARGE\u2019 must be specified to use a database larger than 2GB.\n(you must also specify a config flag when compiling the TC library to\nenable this)</li>\n<li>\u2018TDBTDEFLATE\u2019 use Deflate encoding.</li>\n<li>\u2018TDBTBZIP\u2019 use BZIP2 encoding.</li>\n<li>\u2018TDBTTCBS\u2019 use TCBS encoding.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>The other parameters: <a href=\"#cache\" rel=\"nofollow\">cache</a> and <a href=\"#mmap-size\" rel=\"nofollow\">mmap_size</a> are explained below.</p>\n<div id=\"tune\">\n<h4><a href=\"#id21\" rel=\"nofollow\">tune</a></h4>\n<p>The arguments can be sent to the constructor.</p>\n<pre>&gt;&gt;&gt; import totable\n&gt;&gt;&gt; t = ToTable(\"some.tct\", 'w', bnum=1234, fpow=6, \\\n...                    opts=totable.TDBTLARGE | totable.TDBTBZIP)\n\n&gt;&gt;&gt; t.close()\n</pre>\n</div>\n<div id=\"optimize\">\n<h4><a href=\"#id22\" rel=\"nofollow\">optimize</a></h4>\n<p>optimize is called on an database opened with mode=\u2019w\u2019. if no arguments are\nspecified, it will automatically adjust \u2018bnum\u2019 (only) according to the number\nof elements in the table.</p>\n<pre>&gt;&gt;&gt; t = ToTable(\"some.tct\", 'w')\n\n# ... add some records ...\n&gt;&gt;&gt; t.optimize()\nTrue\n</pre>\n</div>\n<div id=\"mmap-size\">\n<h4><a href=\"#id23\" rel=\"nofollow\">mmap_size</a></h4>\n<p><cite>mmap_size</cite> is the size of mapped memory. default is 67,108,864 (64MB)\nset in the constructor. this is <cite>xmsiz</cite> in TC parlance.</p>\n<pre>&gt;&gt;&gt; t.close()\n&gt;&gt;&gt; t = ToTable(\"some.tct\", 'w', mmap_size=128 * 1e6) # ~128MB.\n</pre>\n</div>\n<div id=\"cache\">\n<h4><a href=\"#id24\" rel=\"nofollow\">cache</a></h4>\n<p>TC also allows setting various caching parameters.\n* <cite>rcnum</cite> is the max number of records to be cached. default is 0\n* <cite>lcnum</cite> is the max number of leaf-nodes to be cached. default is 4096\n* <cite>ncnum</cite> is the max number of non-leaf nodes cached. default is 512\nthese also must be set in the constructor.</p>\n<pre>&gt;&gt;&gt; t.close()\n&gt;&gt;&gt; t = ToTable(\"some.tct\", 'w', rcnum=1e7, lcnum=32768)\n</pre>\n</div>\n<div id=\"index\">\n<h4><a href=\"#id25\" rel=\"nofollow\">index</a></h4>\n<p>create or delete a \u2018s\u2019tring or \u2018d\u2019ecimal index on a column for faster queries.</p>\n<pre># create a decimal index on the number column 'age'.\n&gt;&gt;&gt; tbl.create_index('age', 'd')\nTrue\n\n# create a 'string index on the string column 'fname'.\n&gt;&gt;&gt; tbl.create_index('fname', 's')\nTrue\n\n# remove the index.\n&gt;&gt;&gt; tbl.delete_index('fname')\nTrue\n\n# optimize the index\n&gt;&gt;&gt; tbl.optimize_index('age')\nTrue\n</pre>\n</div>\n</div>\n<div id=\"clear\">\n<h3><a href=\"#id26\" rel=\"nofollow\">clear</a></h3>\n<p>remove all records from the db.</p>\n<pre>&gt;&gt;&gt; len(tbl)\n16\n&gt;&gt;&gt; tbl.clear()\n&gt;&gt;&gt; len(tbl)\n0\n</pre>\n</div>\n<div id=\"transaction\">\n<h3><a href=\"#id27\" rel=\"nofollow\">transaction</a></h3>\n<p>do stuff in a transaction. a rollback() is performed on any exceptions.</p>\n<pre>&gt;&gt;&gt; try:\n...     with transaction(tbl):\n...         tbl['zzz'] = {'a': '4'}\n...         1/0\n... except: pass\n\n&gt;&gt;&gt; 'zzz' in tbl\nFalse\n</pre>\n</div>\n</div>\n<div id=\"see-also\">\n<h2><a href=\"#id28\" rel=\"nofollow\">See Also</a></h2>\n<blockquote>\n<ul>\n<li><a href=\"http://github.com/rsms/tc\" rel=\"nofollow\">tc</a> nice c-python bindings for all of the <a href=\"http://1978th.net/tokyocabinet/\" rel=\"nofollow\">tokyo cabinet</a> db types\nincluding the table</li>\n<li><a href=\"http://code.google.com/p/pykesto/\" rel=\"nofollow\">pykesto</a> the project from which this library is taken. aims to provide\ntransactions on top of <a href=\"http://1978th.net/tokyocabinet/\" rel=\"nofollow\">tokyo cabinet</a> .</li>\n<li>to help out, see TODO list at top of <a href=\"http://github.com/brentp/totable/blob/master/src/ctotable.pyx\" rel=\"nofollow\">ctcable.pyx</a></li>\n<li>tokyo cabinet database api <a href=\"http://1978th.net/tokyocabinet/spex-en.html#tctdbapi\" rel=\"nofollow\">http://1978th.net/tokyocabinet/spex-en.html#tctdbapi</a></li>\n</ul>\n</blockquote>\n</div>\n\n          </div>"}, "last_serial": 800829, "releases": {"0.0.1": [], "0.1": [{"comment_text": "", "digests": {"md5": "f7b3bc78b99b35210856d34198092622", "sha256": "f1ccacbef1104f7946872c980d3021b5aae55c622c76362c84980c95d2e800af"}, "downloads": -1, "filename": "totable-0.1.tar.gz", "has_sig": false, "md5_digest": "f7b3bc78b99b35210856d34198092622", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59056, "upload_time": "2010-01-07T19:19:32", "upload_time_iso_8601": "2010-01-07T19:19:32.354500Z", "url": "https://files.pythonhosted.org/packages/d0/15/49753ad20d8e798b54d61dcfaa0115c415f469c8b8e21bae50ab3cffcba8/totable-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f7b3bc78b99b35210856d34198092622", "sha256": "f1ccacbef1104f7946872c980d3021b5aae55c622c76362c84980c95d2e800af"}, "downloads": -1, "filename": "totable-0.1.tar.gz", "has_sig": false, "md5_digest": "f7b3bc78b99b35210856d34198092622", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59056, "upload_time": "2010-01-07T19:19:32", "upload_time_iso_8601": "2010-01-07T19:19:32.354500Z", "url": "https://files.pythonhosted.org/packages/d0/15/49753ad20d8e798b54d61dcfaa0115c415f469c8b8e21bae50ab3cffcba8/totable-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:49:34 2020"}