{"info": {"author": "\u00c1lvaro Justen, Wei Lee", "author_email": "alvarojusten@gmail.com, cl87654321@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU General Public License (GPL)", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "Templater\n=========\n\nIntroduction\n------------\n\nGiven some strings (or files), this library extracts a common template between\nthem (method ``learn``) -- some people call it \"reverse templating\". Having\nyour template created, you can parse other strings/files using it - the\n``parse`` method will return only what changes in this file (the \"blanks\"). It\ndoes something like the opposite of what template libraries (such as\n`Jinja <http://jinja.pocoo.org/>`_) do. But for now, it only can identify\nfixed variables (it can't create ``for`` and ``if`` blocks, for example).\n\nIf you have the template and the \"blanks\" you can also fill the blanks with\nthe method ``join`` - it'll return a string with the template filled. There are\nsome other features:\n\n- If you don't want/need to ``Templater`` (the main class) create the template\n  for you, you can pass a pre-processed template (created manually or created\n  before using ``learn`` and saved somewhere).\n- You can split the learning and parsing process, since the learning process\n  generally is executed one time and takes a lot of time compared to parsing\n  process. To turn this process handy, ``Templater`` has the methods ``dump``,\n  ``save``, ``load`` and ``open``, so you can learn and save a template\n  definition for later loading and parsing how many times you want (you can\n  also load, learn more and save).\n\n`templater <https://github.com/turicas/templater>`_ is simple to use, easy to\nlearn and does the hard work for you (for example: part of the learning\nalgorithm is implemented in C for performance). Do you have 5 minutes? So learn\nwith the `Examples`_.\n\n\nInstallation\n------------\n\n`templater is available at PyPI <http://pypi.python.org/pypi/templater3>`_, so\ninstalling it is as simple as executing::\n\n    pip install templater3\n\nOr you can download the latest version and install it using ``setup.py``::\n\n    git clone https://github.com/Lee-W/templater\n    cd templater\n    python setup.py build install\n\n\nTerminology\n-----------\n\nThere are some definitions/concepts we should explicit here:\n\n- **Template**: the whole object (instance of ``Templater``).\n- **Document**: a string or file that have some kind of pattern. You'll use\n  documents to make a template object learn and recognize these patterns, so\n  later you can use the template object to parse a document and get only the\n  information that is not \"static\".\n- **Blocks**: the fixed parts of a template. Can change (in number and size)\n  when ``learn`` is run.\n- **Blanks**: also called holes or variables, blanks are the parts in a\n  template that changes between documents with the same template.\n- **Template definition**: the information stored in a template that defines it\n  (it is a Python list with a very simple grammar that describes how the\n  template is composed).\n- **Markers**: when you want to save a template, something should be put\n  between blocks to \"mark\" the blanks (so the template definition can be\n  reconstructed later).\n- **Named marker**: a marker plus a header is called a named marker. They are\n  handy and more legible since you can access the \"blanks\" by names instead of\n  indexes.\n\nDoubts? Don't worry, see the `Examples`_ and you'll get it.\n\n\nExamples\n--------\n\nAll you need to know is below (and in the ``examples`` directory)::\n\n    >>> from templater import Templater\n    >>> documents_to_learn = ['<b> spam and eggs </b>', '<b> ham and spam </b>',\n                              '<b> white and black </b>'] # list of documents\n    >>> template = Templater()\n    >>> for document in documents_to_learn:\n    ...    template.learn(document)\n    ...\n\n    >>> print('Template created:', template._template # template definition)\n    Template created: [None, '<b> ', None, ' and ', None, ' </b>', None]\n\n    >>> document_to_parse = '<b> yellow and blue </b>'\n    >>> print('Parsing other document:', template.parse(document_to_parse))\n    Parsing other document: ['', 'yellow', 'blue', '']\n\n    >>> print('Filling the blanks:', template.join(['', 'red', 'orange', '']))\n    Filling the blanks: <b> red and orange </b>\n\nYou can pass pre-processed templates as a list (blanks are ``None``, blocks are\nstrings)::\n\n    >>> t2 = Templater(template=[None, 'Music: ', None, ', Band: ', None])\n    >>> print(t2.join(['', 'Welcome to the Jungle', 'Guns and Roses']))\n    Music: Welcome to the Jungle, Band: Guns and Roses\n\n...or you can pass a string with markers, then ``Templater`` will create the\nlist for you::\n\n    >>> t3 = Templater(template='language=#,cool=#', marker='#')\n    >>> print(t3.join(['', 'Python', 'YES', '']))\n    language=Python,cool=YES\n\nSaving and opening templates is easy::\n\n    >>> template.save('my-first-template.html', marker='|||')\n    >>> # and some time later...\n    >>> loaded_template = Templater.open('my-first-template.html', marker='|||')\n    >>> print(loaded_template.parse('<b> Romeo and Juliet </b>'))\n    ['', 'Romeo', 'Juliet', '']\n\nThe difference between ``save`` and ``dump`` is that ``save`` stores the\ntemplate string, filling the blanks with a marker and ``dump`` saves the whole\n``Templater`` object with ``cPickle``. The pairs are:\n\n- ``save`` and ``open`` (raw template string filled with marker)\n- ``load`` and ``dump`` (whole object)\n\n**Note**: ``save`` always add a ``\\n`` to the end of file; ``load``\ndeletes trailing ``\\r\\n`` or ``\\n`` in the end of file (if any).\n\n**Note-2**: when passing a pre-processed template (using ``Templater``\ninitializer or ``Templater.open``) make sure it **starts and ends** with a\nmarker.\n\nIf you are getting a lot of blanks you can configure the learning process: just\nadjust ``min_block_size`` - it's the minimum number of characters permitted to\ncreate a new block in template::\n\n    >>> str_1 = 'my favorite color is blue'\n    >>> str_2 = 'my favorite color is violet'\n    >>> t = Templater() # default min_block_size = 1\n    >>> t.learn(str_1)\n    >>> t.learn(str_2)\n    >>> print(t._template)\n    [None, 'my favorite color is ', None, 'l', None, 'e', None]\n\nWe don't want that ``'l'`` and ``'e'`` there, right? So::\n\n    >>> t = Templater(min_block_size=2)\n    >>> t.learn(str_1)\n    >>> t.learn(str_2)\n    >>> print(t._template)\n    [None, 'my favorite color is ', None]\n\n\nYou can also add \"headers\" to your template - the headers will be the name of\nyour markers, so you'll have a template with named markers and ``parse`` will\nreturn a ``dict`` instead of ``list``. It's more legible than using list\nindices, let's see::\n\n    >>> import re\n    >>> # Let's create a regexp that cases with '{{var}}' (it'll be our marker)\n    >>> regexp_marker = re.compile(r'{{([a-zA-Z0-9_-]*)}}')\n    >>> template = Templater('{{first-var}}<b>{{second-var}}</b>{{third-var}}',\n                             marker=regexp_marker)\n    >>> # The template knows the name of each marker just using the regexp provided\n    >>> # Passing marker as regexp to specify named markers also work for Templater.open\n\n    >>> print(template.parse('This <b> is </b> a test.'))\n    {'second-var': ' is ', 'third-var': ' a test.', 'first-var': 'This '}\n\n    >>> # To save the template with named markers we need to provide a Python string.\n    >>> # Templater will call .format() of this string for each marker with its name\n    >>> template.save('template-with-named-markers.html', marker='--{}--')\n    >>> # Will save '--first-var--<b>--second-var--</b>--third-var--\\n'\n\nAnd if you have a template without headers, just add to it with ``add_headers``\nmethod::\n\n    >>> t = Templater('+<tr><td>+</td><td>+</td></tr>+', marker='+')\n    >>> t.parse('<tr><td>hello</td><td>world</td></tr>')\n    ['', 'hello', 'world', '']\n\n    >>> t.add_headers(['before', 'first-column', 'second-column', 'after'])\n    >>> t.parse('<tr><td>hello</td><td>world</td></tr>')\n    {'after': '', 'before': '', 'first-column': 'hello', 'second-column': 'world'}\n\n**Note**: named markers have a problem: you can't run ``learn`` if you use them.\n\n\nNotes\n-----\n\nI really want to know if you are using this project and what is your impression\nabout it. If you have new ideas of features, discovered bugs or just want to\nsay \"thank you, I'm using it!\", please contact me at\n`alvarojusten at gmail <alvarojusten@gmail.com>`_.\n\nIf you want to code some stuff,\njust `fork it on GitHub <https://github.com/turicas/templater>`_ and create a\npull request. Some technical notes for you:\n\n- This project uses `Test-Driven Development\n  <http://en.wikipedia.org/wiki/Test-Driven_Development>`_.\n\n  - The tests are run using Python 3.6 on macOS 10.14.4.\n- You can see the changes between versions in\n  `CHANGELOG.rst <https://github.com/lee-W/templater/blob/master/CHANGELOG.rst>`_.\n- This project uses `semantic versioning <http://semver.org/>`_ (thanks,\n  `Tom Preston-Werner <http://tom.preston-werner.com/>`_).\n\n\n\nAuthor\n------\n\nThis software is developed by\n`\u00c1lvaro Justen aka Turicas <http://blog.justen.eng.br/>`_.\n\nMany thanks to `Adrian Holovaty <http://www.holovaty.com/>`_ - he created\n`templatemaker <http://templatemaker.googlecode.com>`_, the project which\n``templater`` was inspired in/forked from - and to\n`Escola de Matem\u00e1tica Aplicada (Funda\u00e7\u00e3o Get\u00falio Vargas) <http://emap.fgv.br>`_\nwhich gives me interesting problems to solve. :-)\n\nThis software is modified by\n`Wei Lee <https://github.com/Lee-W>`_.\n\nLicense\n-------\n\n`GPL version 2 <http://www.gnu.org/licenses/gpl-2.0.html>`_", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Lee-W/templater", "keywords": "template,reversed template,template making,wrapper induction", "license": "", "maintainer": "", "maintainer_email": "", "name": "templater3", "package_url": "https://pypi.org/project/templater3/", "platform": "", "project_url": "https://pypi.org/project/templater3/", "project_urls": {"Homepage": "https://github.com/Lee-W/templater"}, "release_url": "https://pypi.org/project/templater3/0.5.0/", "requires_dist": null, "requires_python": "", "summary": "Extract template (a pattern) from strings and parse otherstrings with this pattern.", "version": "0.5.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>Given some strings (or files), this library extracts a common template between\nthem (method <tt>learn</tt>) \u2013 some people call it \u201creverse templating\u201d. Having\nyour template created, you can parse other strings/files using it - the\n<tt>parse</tt> method will return only what changes in this file (the \u201cblanks\u201d). It\ndoes something like the opposite of what template libraries (such as\n<a href=\"http://jinja.pocoo.org/\" rel=\"nofollow\">Jinja</a>) do. But for now, it only can identify\nfixed variables (it can\u2019t create <tt>for</tt> and <tt>if</tt> blocks, for example).</p>\n<p>If you have the template and the \u201cblanks\u201d you can also fill the blanks with\nthe method <tt>join</tt> - it\u2019ll return a string with the template filled. There are\nsome other features:</p>\n<ul>\n<li>If you don\u2019t want/need to <tt>Templater</tt> (the main class) create the template\nfor you, you can pass a pre-processed template (created manually or created\nbefore using <tt>learn</tt> and saved somewhere).</li>\n<li>You can split the learning and parsing process, since the learning process\ngenerally is executed one time and takes a lot of time compared to parsing\nprocess. To turn this process handy, <tt>Templater</tt> has the methods <tt>dump</tt>,\n<tt>save</tt>, <tt>load</tt> and <tt>open</tt>, so you can learn and save a template\ndefinition for later loading and parsing how many times you want (you can\nalso load, learn more and save).</li>\n</ul>\n<p><a href=\"https://github.com/turicas/templater\" rel=\"nofollow\">templater</a> is simple to use, easy to\nlearn and does the hard work for you (for example: part of the learning\nalgorithm is implemented in C for performance). Do you have 5 minutes? So learn\nwith the <a href=\"#examples\" rel=\"nofollow\">Examples</a>.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p><a href=\"http://pypi.python.org/pypi/templater3\" rel=\"nofollow\">templater is available at PyPI</a>, so\ninstalling it is as simple as executing:</p>\n<pre>pip install templater3\n</pre>\n<p>Or you can download the latest version and install it using <tt>setup.py</tt>:</p>\n<pre>git clone https://github.com/Lee-W/templater\ncd templater\npython setup.py build install\n</pre>\n</div>\n<div id=\"terminology\">\n<h2>Terminology</h2>\n<p>There are some definitions/concepts we should explicit here:</p>\n<ul>\n<li><strong>Template</strong>: the whole object (instance of <tt>Templater</tt>).</li>\n<li><strong>Document</strong>: a string or file that have some kind of pattern. You\u2019ll use\ndocuments to make a template object learn and recognize these patterns, so\nlater you can use the template object to parse a document and get only the\ninformation that is not \u201cstatic\u201d.</li>\n<li><strong>Blocks</strong>: the fixed parts of a template. Can change (in number and size)\nwhen <tt>learn</tt> is run.</li>\n<li><strong>Blanks</strong>: also called holes or variables, blanks are the parts in a\ntemplate that changes between documents with the same template.</li>\n<li><strong>Template definition</strong>: the information stored in a template that defines it\n(it is a Python list with a very simple grammar that describes how the\ntemplate is composed).</li>\n<li><strong>Markers</strong>: when you want to save a template, something should be put\nbetween blocks to \u201cmark\u201d the blanks (so the template definition can be\nreconstructed later).</li>\n<li><strong>Named marker</strong>: a marker plus a header is called a named marker. They are\nhandy and more legible since you can access the \u201cblanks\u201d by names instead of\nindexes.</li>\n</ul>\n<p>Doubts? Don\u2019t worry, see the <a href=\"#examples\" rel=\"nofollow\">Examples</a> and you\u2019ll get it.</p>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>All you need to know is below (and in the <tt>examples</tt> directory):</p>\n<pre>&gt;&gt;&gt; from templater import Templater\n&gt;&gt;&gt; documents_to_learn = ['&lt;b&gt; spam and eggs &lt;/b&gt;', '&lt;b&gt; ham and spam &lt;/b&gt;',\n                          '&lt;b&gt; white and black &lt;/b&gt;'] # list of documents\n&gt;&gt;&gt; template = Templater()\n&gt;&gt;&gt; for document in documents_to_learn:\n...    template.learn(document)\n...\n\n&gt;&gt;&gt; print('Template created:', template._template # template definition)\nTemplate created: [None, '&lt;b&gt; ', None, ' and ', None, ' &lt;/b&gt;', None]\n\n&gt;&gt;&gt; document_to_parse = '&lt;b&gt; yellow and blue &lt;/b&gt;'\n&gt;&gt;&gt; print('Parsing other document:', template.parse(document_to_parse))\nParsing other document: ['', 'yellow', 'blue', '']\n\n&gt;&gt;&gt; print('Filling the blanks:', template.join(['', 'red', 'orange', '']))\nFilling the blanks: &lt;b&gt; red and orange &lt;/b&gt;\n</pre>\n<p>You can pass pre-processed templates as a list (blanks are <tt>None</tt>, blocks are\nstrings):</p>\n<pre>&gt;&gt;&gt; t2 = Templater(template=[None, 'Music: ', None, ', Band: ', None])\n&gt;&gt;&gt; print(t2.join(['', 'Welcome to the Jungle', 'Guns and Roses']))\nMusic: Welcome to the Jungle, Band: Guns and Roses\n</pre>\n<p>\u2026or you can pass a string with markers, then <tt>Templater</tt> will create the\nlist for you:</p>\n<pre>&gt;&gt;&gt; t3 = Templater(template='language=#,cool=#', marker='#')\n&gt;&gt;&gt; print(t3.join(['', 'Python', 'YES', '']))\nlanguage=Python,cool=YES\n</pre>\n<p>Saving and opening templates is easy:</p>\n<pre>&gt;&gt;&gt; template.save('my-first-template.html', marker='|||')\n&gt;&gt;&gt; # and some time later...\n&gt;&gt;&gt; loaded_template = Templater.open('my-first-template.html', marker='|||')\n&gt;&gt;&gt; print(loaded_template.parse('&lt;b&gt; Romeo and Juliet &lt;/b&gt;'))\n['', 'Romeo', 'Juliet', '']\n</pre>\n<p>The difference between <tt>save</tt> and <tt>dump</tt> is that <tt>save</tt> stores the\ntemplate string, filling the blanks with a marker and <tt>dump</tt> saves the whole\n<tt>Templater</tt> object with <tt>cPickle</tt>. The pairs are:</p>\n<ul>\n<li><tt>save</tt> and <tt>open</tt> (raw template string filled with marker)</li>\n<li><tt>load</tt> and <tt>dump</tt> (whole object)</li>\n</ul>\n<p><strong>Note</strong>: <tt>save</tt> always add a <tt>\\n</tt> to the end of file; <tt>load</tt>\ndeletes trailing <tt>\\r\\n</tt> or <tt>\\n</tt> in the end of file (if any).</p>\n<p><strong>Note-2</strong>: when passing a pre-processed template (using <tt>Templater</tt>\ninitializer or <tt>Templater.open</tt>) make sure it <strong>starts and ends</strong> with a\nmarker.</p>\n<p>If you are getting a lot of blanks you can configure the learning process: just\nadjust <tt>min_block_size</tt> - it\u2019s the minimum number of characters permitted to\ncreate a new block in template:</p>\n<pre>&gt;&gt;&gt; str_1 = 'my favorite color is blue'\n&gt;&gt;&gt; str_2 = 'my favorite color is violet'\n&gt;&gt;&gt; t = Templater() # default min_block_size = 1\n&gt;&gt;&gt; t.learn(str_1)\n&gt;&gt;&gt; t.learn(str_2)\n&gt;&gt;&gt; print(t._template)\n[None, 'my favorite color is ', None, 'l', None, 'e', None]\n</pre>\n<p>We don\u2019t want that <tt>'l'</tt> and <tt>'e'</tt> there, right? So:</p>\n<pre>&gt;&gt;&gt; t = Templater(min_block_size=2)\n&gt;&gt;&gt; t.learn(str_1)\n&gt;&gt;&gt; t.learn(str_2)\n&gt;&gt;&gt; print(t._template)\n[None, 'my favorite color is ', None]\n</pre>\n<p>You can also add \u201cheaders\u201d to your template - the headers will be the name of\nyour markers, so you\u2019ll have a template with named markers and <tt>parse</tt> will\nreturn a <tt>dict</tt> instead of <tt>list</tt>. It\u2019s more legible than using list\nindices, let\u2019s see:</p>\n<pre>&gt;&gt;&gt; import re\n&gt;&gt;&gt; # Let's create a regexp that cases with '{{var}}' (it'll be our marker)\n&gt;&gt;&gt; regexp_marker = re.compile(r'{{([a-zA-Z0-9_-]*)}}')\n&gt;&gt;&gt; template = Templater('{{first-var}}&lt;b&gt;{{second-var}}&lt;/b&gt;{{third-var}}',\n                         marker=regexp_marker)\n&gt;&gt;&gt; # The template knows the name of each marker just using the regexp provided\n&gt;&gt;&gt; # Passing marker as regexp to specify named markers also work for Templater.open\n\n&gt;&gt;&gt; print(template.parse('This &lt;b&gt; is &lt;/b&gt; a test.'))\n{'second-var': ' is ', 'third-var': ' a test.', 'first-var': 'This '}\n\n&gt;&gt;&gt; # To save the template with named markers we need to provide a Python string.\n&gt;&gt;&gt; # Templater will call .format() of this string for each marker with its name\n&gt;&gt;&gt; template.save('template-with-named-markers.html', marker='--{}--')\n&gt;&gt;&gt; # Will save '--first-var--&lt;b&gt;--second-var--&lt;/b&gt;--third-var--\\n'\n</pre>\n<p>And if you have a template without headers, just add to it with <tt>add_headers</tt>\nmethod:</p>\n<pre>&gt;&gt;&gt; t = Templater('+&lt;tr&gt;&lt;td&gt;+&lt;/td&gt;&lt;td&gt;+&lt;/td&gt;&lt;/tr&gt;+', marker='+')\n&gt;&gt;&gt; t.parse('&lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;td&gt;world&lt;/td&gt;&lt;/tr&gt;')\n['', 'hello', 'world', '']\n\n&gt;&gt;&gt; t.add_headers(['before', 'first-column', 'second-column', 'after'])\n&gt;&gt;&gt; t.parse('&lt;tr&gt;&lt;td&gt;hello&lt;/td&gt;&lt;td&gt;world&lt;/td&gt;&lt;/tr&gt;')\n{'after': '', 'before': '', 'first-column': 'hello', 'second-column': 'world'}\n</pre>\n<p><strong>Note</strong>: named markers have a problem: you can\u2019t run <tt>learn</tt> if you use them.</p>\n</div>\n<div id=\"notes\">\n<h2>Notes</h2>\n<p>I really want to know if you are using this project and what is your impression\nabout it. If you have new ideas of features, discovered bugs or just want to\nsay \u201cthank you, I\u2019m using it!\u201d, please contact me at\n<a href=\"mailto:alvarojusten%40gmail.com\">alvarojusten at gmail</a>.</p>\n<p>If you want to code some stuff,\njust <a href=\"https://github.com/turicas/templater\" rel=\"nofollow\">fork it on GitHub</a> and create a\npull request. Some technical notes for you:</p>\n<ul>\n<li>This project uses <a href=\"http://en.wikipedia.org/wiki/Test-Driven_Development\" rel=\"nofollow\">Test-Driven Development</a>.<ul>\n<li>The tests are run using Python 3.6 on macOS 10.14.4.</li>\n</ul>\n</li>\n<li>You can see the changes between versions in\n<a href=\"https://github.com/lee-W/templater/blob/master/CHANGELOG.rst\" rel=\"nofollow\">CHANGELOG.rst</a>.</li>\n<li>This project uses <a href=\"http://semver.org/\" rel=\"nofollow\">semantic versioning</a> (thanks,\n<a href=\"http://tom.preston-werner.com/\" rel=\"nofollow\">Tom Preston-Werner</a>).</li>\n</ul>\n</div>\n<div id=\"author\">\n<h2>Author</h2>\n<p>This software is developed by\n<a href=\"http://blog.justen.eng.br/\" rel=\"nofollow\">\u00c1lvaro Justen aka Turicas</a>.</p>\n<p>Many thanks to <a href=\"http://www.holovaty.com/\" rel=\"nofollow\">Adrian Holovaty</a> - he created\n<a href=\"http://templatemaker.googlecode.com\" rel=\"nofollow\">templatemaker</a>, the project which\n<tt>templater</tt> was inspired in/forked from - and to\n<a href=\"http://emap.fgv.br\" rel=\"nofollow\">Escola de Matem\u00e1tica Aplicada (Funda\u00e7\u00e3o Get\u00falio Vargas)</a>\nwhich gives me interesting problems to solve. :-)</p>\n<p>This software is modified by\n<a href=\"https://github.com/Lee-W\" rel=\"nofollow\">Wei Lee</a>.</p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p><a href=\"http://www.gnu.org/licenses/gpl-2.0.html\" rel=\"nofollow\">GPL version 2</a></p>\n</div>\n\n          </div>"}, "last_serial": 5123474, "releases": {"0.5.0": [{"comment_text": "", "digests": {"md5": "b6494f011ceb90127278cb1762bba9bb", "sha256": "19f93b60fcdfa48ef3f050db6e36024417698ad7294d22f39942463d1404bad8"}, "downloads": -1, "filename": "templater3-0.5.0.tar.gz", "has_sig": false, "md5_digest": "b6494f011ceb90127278cb1762bba9bb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19225, "upload_time": "2019-04-10T11:12:17", "upload_time_iso_8601": "2019-04-10T11:12:17.223678Z", "url": "https://files.pythonhosted.org/packages/27/8d/e6505dd4e4c6ab3c1f5c94694c06a6269836ae388a5aa52ea7f1e35205c0/templater3-0.5.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b6494f011ceb90127278cb1762bba9bb", "sha256": "19f93b60fcdfa48ef3f050db6e36024417698ad7294d22f39942463d1404bad8"}, "downloads": -1, "filename": "templater3-0.5.0.tar.gz", "has_sig": false, "md5_digest": "b6494f011ceb90127278cb1762bba9bb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19225, "upload_time": "2019-04-10T11:12:17", "upload_time_iso_8601": "2019-04-10T11:12:17.223678Z", "url": "https://files.pythonhosted.org/packages/27/8d/e6505dd4e4c6ab3c1f5c94694c06a6269836ae388a5aa52ea7f1e35205c0/templater3-0.5.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:42 2020"}