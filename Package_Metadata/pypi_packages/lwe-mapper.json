{"info": {"author": "linuxwhatelse", "author_email": "info@linuxwhatelse.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "mapper - Simple URL-Scheme resolver\n===================================\n[![Build Status](https://travis-ci.org/linuxwhatelse/mapper.svg?branch=master)](https://travis-ci.org/linuxwhatelse/mapper)\n[![pypi](https://img.shields.io/pypi/v/lwe-mapper.svg)](https://pypi.python.org/pypi/lwe-mapper)\n\n**mapper** is a small side-project which I created while working on other *stuff* and was in the need for a super simple url-reslover.  \nThe idea was to keep the footprint as small as possible **without** relying on none-python modules.\n\nWhat you use it for is up to you.  \n\nIf you f.e. need a simple JSON Server, check out [mjs](https://github.com/linuxwhatelse/mjs) as it follows the\nsame principle.  \nSmall footprint, easy to use, and only one dependency - mapper (obviously).\n\nHow it works? It's super simple.  \nCheck [The very basic](#the-very-basic) and go from there.\n\n## Table of Contents\n* [Requirements](#requirements)\n* [Installation](#installation)\n* [Usage](#usage)\n    * [Registering functions](#registering-functions)\n        * [The very basic](#the-very-basic)\n        * [URL with a query](#url-with-a-query)\n        * [Query value type cast](#query-value-type-cast)\n        * [Extracting values from a URLs path](#extracting-values-from-a-urls-path)\n        * [Pythons kwargs](#pythons-kwargs)\n        * [Return values](#return-values)\n        * [Using the \"add\" function instead of the decorator](#using-the-add-function-instead-of-the-decorator)\n\n## Requirements\nWhat you need:\n* Python 2.7 or up\n\n## Installation\nYou have two options:\n\n1. Install via pypi `pip install lwe-mapper`\n2. Download [mapper.py](https://github.com/linuxwhatelse/mapper/blob/master/mapper.py) and place it into the root directory of your project\n\n## Usage\n\n### Registering functions\n\n#### The very basic\n``` python\nfrom mapper import Mapper\n\nmpr = Mapper.get()\n\n# Note: A path will ALWAYS end with a \"/\" regardless\n# if your URL contains a trailing \"/\" or not\n\n# Choose one of the two decorators\n@mpr.url('^/some/path/$')  # Regex pattern\n@mpr.s_url('/some/path/')  # Simple path\ndef func():\n    print('func called')\n\n# What e.g. your webserver would do...\nmpr.call('http://some.url/some/path')\n```\n\n#### URL with a query\n``` python\nfrom mapper import Mapper\n\nmpr = Mapper.get()\n\n# Note: Adding a query does NOT change the fact that\n# the path will end with a \"/\" for the regex pattern\n@mpr.s_url('/some/path/')\ndef func(param1, param2='default'):\n    print(param1, param2)\n\n# We don't supply \"param2\" and \"param3\" which will result in \"param2\" being None and param3 being 'default'\nmpr.call('http://some.url/some/path?param1=123')\n\n# Following would cause a:\n# TypeError: func() missing 1 required positional argument: 'param1'\nmpr.call('http://some.url/some/path')\n```\n\n#### Query value type cast\n``` python\nfrom mapper import Mapper\n\nmpr = Mapper.get()\n\n# By default all parameters will be of type \"string\".\n# You can change the type by supplying a dict where the key matches your parameters name and the value is one of:\n# int, float, bool\n#\n# Note for bool:\n#  1. Casting is case-insensitive.\n#  2. 1 and 0 can be casted as well\n@mpr.s_url('/some/path/', type_cast={'a_int' : int, 'a_float' : float, 'a_bool' : bool})\ndef func(a_int, a_float, a_bool):\n    print(a_int, a_float, a_bool)\n\nmpr.call('http://some.url/some/path?a_int=123&a_float=1.0&a_bool=true')\n```\n\n#### Extracting values from a URLs path\n``` python\nfrom mapper import Mapper\n\nmpr = Mapper.get()\n\n# In pure python regex fashion we define a named capture group within our pattern to\n# match whatever we want.\n# We can use a simplified url as well though.\n# Not that type-casting works as well.\n@mpr.url('^/some/path/(?P<param1>[^/]*)/(?P<param2>[0-9]*)/$', type_cast={'param2':int}) # Regex pattern\n@mpr.s_url('/some/path/<param1>/<param2>/', type_cast={'param2':int})                    # Simple path\ndef func(param1, param2):\n    print(param1, param2)\n\nmpr.call('http://some.url/some/path/abc/456/')\n```\n\n#### Pythons kwargs\n``` python\nfrom mapper import Mapper\n\nmpr = Mapper.get()\n\n# It's pretty simple and type-casting works as well\n@mpr.s_url('/some/path/', type_cast={'param1' : int, 'param2' : float, 'param3' : bool})\ndef func(param1, **kwargs):\n    print(param1, kwargs)\n\nmpr.call('http://some.url/some/path?param1=123&param2=1.0&param3=true')\n```\n\n#### Return values\n``` python\nfrom mapper import Mapper\n\nmpr = Mapper.get()\n\n# Whatever you return will be returned by mapper\n@mpr.s_url('/some/path/')\ndef func():\n    return ('str', 1, 1.0, True)\n\na_str, a_int, a_float, a_bool = mpr.call('http://some.url/some/path')\n```\n\n#### Using the \"add\" function instead of the decorator\nSometimes you might have to register a function with the mapper at a later point. This can easily be achieved by using the mappers \"add\" function.\n``` python\nfrom mapper import Mapper\n\nmpr = Mapper.get()\n\ndef func(param1, param2):\n    print(param1, param2)\n\n# It works the same way as the decorator.\n# The only difference is, that we have to specify the function ourselves.\nmpr.add('^/some/path/(?P<param1>[0-9]*)/$', func, type_cast={'param1' : int, 'param2' : int})\nmpr.s_add('/some/path/<param1>/', func, type_cast={'param1' : int, 'param2' : int})\n\nmpr.call('http://some.url/some/path/123?param2=456')\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/linuxwhatelse/mapper", "keywords": "url scheme resolver mapper", "license": "GPLv3", "maintainer": "", "maintainer_email": "", "name": "lwe-mapper", "package_url": "https://pypi.org/project/lwe-mapper/", "platform": "", "project_url": "https://pypi.org/project/lwe-mapper/", "project_urls": {"Homepage": "https://github.com/linuxwhatelse/mapper"}, "release_url": "https://pypi.org/project/lwe-mapper/1.2.5/", "requires_dist": null, "requires_python": "", "summary": "A simple URL-Scheme resolver", "version": "1.2.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>mapper - Simple URL-Scheme resolver</h1>\n<p><a href=\"https://travis-ci.org/linuxwhatelse/mapper\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6343e0b4256b6af208905e0b43fe9b99d36e0dea/68747470733a2f2f7472617669732d63692e6f72672f6c696e757877686174656c73652f6d61707065722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.python.org/pypi/lwe-mapper\" rel=\"nofollow\"><img alt=\"pypi\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ad5581b8ec7711370109a49ffb643481e4c2771f/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6c77652d6d61707065722e737667\"></a></p>\n<p><strong>mapper</strong> is a small side-project which I created while working on other <em>stuff</em> and was in the need for a super simple url-reslover.<br>\nThe idea was to keep the footprint as small as possible <strong>without</strong> relying on none-python modules.</p>\n<p>What you use it for is up to you.</p>\n<p>If you f.e. need a simple JSON Server, check out <a href=\"https://github.com/linuxwhatelse/mjs\" rel=\"nofollow\">mjs</a> as it follows the\nsame principle.<br>\nSmall footprint, easy to use, and only one dependency - mapper (obviously).</p>\n<p>How it works? It's super simple.<br>\nCheck <a href=\"#the-very-basic\" rel=\"nofollow\">The very basic</a> and go from there.</p>\n<h2>Table of Contents</h2>\n<ul>\n<li><a href=\"#requirements\" rel=\"nofollow\">Requirements</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a>\n<ul>\n<li><a href=\"#registering-functions\" rel=\"nofollow\">Registering functions</a>\n<ul>\n<li><a href=\"#the-very-basic\" rel=\"nofollow\">The very basic</a></li>\n<li><a href=\"#url-with-a-query\" rel=\"nofollow\">URL with a query</a></li>\n<li><a href=\"#query-value-type-cast\" rel=\"nofollow\">Query value type cast</a></li>\n<li><a href=\"#extracting-values-from-a-urls-path\" rel=\"nofollow\">Extracting values from a URLs path</a></li>\n<li><a href=\"#pythons-kwargs\" rel=\"nofollow\">Pythons kwargs</a></li>\n<li><a href=\"#return-values\" rel=\"nofollow\">Return values</a></li>\n<li><a href=\"#using-the-add-function-instead-of-the-decorator\" rel=\"nofollow\">Using the \"add\" function instead of the decorator</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>Requirements</h2>\n<p>What you need:</p>\n<ul>\n<li>Python 2.7 or up</li>\n</ul>\n<h2>Installation</h2>\n<p>You have two options:</p>\n<ol>\n<li>Install via pypi <code>pip install lwe-mapper</code></li>\n<li>Download <a href=\"https://github.com/linuxwhatelse/mapper/blob/master/mapper.py\" rel=\"nofollow\">mapper.py</a> and place it into the root directory of your project</li>\n</ol>\n<h2>Usage</h2>\n<h3>Registering functions</h3>\n<h4>The very basic</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mapper</span> <span class=\"kn\">import</span> <span class=\"n\">Mapper</span>\n\n<span class=\"n\">mpr</span> <span class=\"o\">=</span> <span class=\"n\">Mapper</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Note: A path will ALWAYS end with a \"/\" regardless</span>\n<span class=\"c1\"># if your URL contains a trailing \"/\" or not</span>\n\n<span class=\"c1\"># Choose one of the two decorators</span>\n<span class=\"nd\">@mpr</span><span class=\"o\">.</span><span class=\"n\">url</span><span class=\"p\">(</span><span class=\"s1\">'^/some/path/$'</span><span class=\"p\">)</span>  <span class=\"c1\"># Regex pattern</span>\n<span class=\"nd\">@mpr</span><span class=\"o\">.</span><span class=\"n\">s_url</span><span class=\"p\">(</span><span class=\"s1\">'/some/path/'</span><span class=\"p\">)</span>  <span class=\"c1\"># Simple path</span>\n<span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">():</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'func called'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># What e.g. your webserver would do...</span>\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'http://some.url/some/path'</span><span class=\"p\">)</span>\n</pre>\n<h4>URL with a query</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mapper</span> <span class=\"kn\">import</span> <span class=\"n\">Mapper</span>\n\n<span class=\"n\">mpr</span> <span class=\"o\">=</span> <span class=\"n\">Mapper</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Note: Adding a query does NOT change the fact that</span>\n<span class=\"c1\"># the path will end with a \"/\" for the regex pattern</span>\n<span class=\"nd\">@mpr</span><span class=\"o\">.</span><span class=\"n\">s_url</span><span class=\"p\">(</span><span class=\"s1\">'/some/path/'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">param1</span><span class=\"p\">,</span> <span class=\"n\">param2</span><span class=\"o\">=</span><span class=\"s1\">'default'</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">param1</span><span class=\"p\">,</span> <span class=\"n\">param2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># We don't supply \"param2\" and \"param3\" which will result in \"param2\" being None and param3 being 'default'</span>\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'http://some.url/some/path?param1=123'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Following would cause a:</span>\n<span class=\"c1\"># TypeError: func() missing 1 required positional argument: 'param1'</span>\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'http://some.url/some/path'</span><span class=\"p\">)</span>\n</pre>\n<h4>Query value type cast</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mapper</span> <span class=\"kn\">import</span> <span class=\"n\">Mapper</span>\n\n<span class=\"n\">mpr</span> <span class=\"o\">=</span> <span class=\"n\">Mapper</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># By default all parameters will be of type \"string\".</span>\n<span class=\"c1\"># You can change the type by supplying a dict where the key matches your parameters name and the value is one of:</span>\n<span class=\"c1\"># int, float, bool</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># Note for bool:</span>\n<span class=\"c1\">#  1. Casting is case-insensitive.</span>\n<span class=\"c1\">#  2. 1 and 0 can be casted as well</span>\n<span class=\"nd\">@mpr</span><span class=\"o\">.</span><span class=\"n\">s_url</span><span class=\"p\">(</span><span class=\"s1\">'/some/path/'</span><span class=\"p\">,</span> <span class=\"n\">type_cast</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'a_int'</span> <span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"s1\">'a_float'</span> <span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"s1\">'a_bool'</span> <span class=\"p\">:</span> <span class=\"nb\">bool</span><span class=\"p\">})</span>\n<span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">a_int</span><span class=\"p\">,</span> <span class=\"n\">a_float</span><span class=\"p\">,</span> <span class=\"n\">a_bool</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">a_int</span><span class=\"p\">,</span> <span class=\"n\">a_float</span><span class=\"p\">,</span> <span class=\"n\">a_bool</span><span class=\"p\">)</span>\n\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'http://some.url/some/path?a_int=123&amp;a_float=1.0&amp;a_bool=true'</span><span class=\"p\">)</span>\n</pre>\n<h4>Extracting values from a URLs path</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mapper</span> <span class=\"kn\">import</span> <span class=\"n\">Mapper</span>\n\n<span class=\"n\">mpr</span> <span class=\"o\">=</span> <span class=\"n\">Mapper</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># In pure python regex fashion we define a named capture group within our pattern to</span>\n<span class=\"c1\"># match whatever we want.</span>\n<span class=\"c1\"># We can use a simplified url as well though.</span>\n<span class=\"c1\"># Not that type-casting works as well.</span>\n<span class=\"nd\">@mpr</span><span class=\"o\">.</span><span class=\"n\">url</span><span class=\"p\">(</span><span class=\"s1\">'^/some/path/(?P&lt;param1&gt;[^/]*)/(?P&lt;param2&gt;[0-9]*)/$'</span><span class=\"p\">,</span> <span class=\"n\">type_cast</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'param2'</span><span class=\"p\">:</span><span class=\"nb\">int</span><span class=\"p\">})</span> <span class=\"c1\"># Regex pattern</span>\n<span class=\"nd\">@mpr</span><span class=\"o\">.</span><span class=\"n\">s_url</span><span class=\"p\">(</span><span class=\"s1\">'/some/path/&lt;param1&gt;/&lt;param2&gt;/'</span><span class=\"p\">,</span> <span class=\"n\">type_cast</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'param2'</span><span class=\"p\">:</span><span class=\"nb\">int</span><span class=\"p\">})</span>                    <span class=\"c1\"># Simple path</span>\n<span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">param1</span><span class=\"p\">,</span> <span class=\"n\">param2</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">param1</span><span class=\"p\">,</span> <span class=\"n\">param2</span><span class=\"p\">)</span>\n\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'http://some.url/some/path/abc/456/'</span><span class=\"p\">)</span>\n</pre>\n<h4>Pythons kwargs</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mapper</span> <span class=\"kn\">import</span> <span class=\"n\">Mapper</span>\n\n<span class=\"n\">mpr</span> <span class=\"o\">=</span> <span class=\"n\">Mapper</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># It's pretty simple and type-casting works as well</span>\n<span class=\"nd\">@mpr</span><span class=\"o\">.</span><span class=\"n\">s_url</span><span class=\"p\">(</span><span class=\"s1\">'/some/path/'</span><span class=\"p\">,</span> <span class=\"n\">type_cast</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'param1'</span> <span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"s1\">'param2'</span> <span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"s1\">'param3'</span> <span class=\"p\">:</span> <span class=\"nb\">bool</span><span class=\"p\">})</span>\n<span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">param1</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">param1</span><span class=\"p\">,</span> <span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'http://some.url/some/path?param1=123&amp;param2=1.0&amp;param3=true'</span><span class=\"p\">)</span>\n</pre>\n<h4>Return values</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mapper</span> <span class=\"kn\">import</span> <span class=\"n\">Mapper</span>\n\n<span class=\"n\">mpr</span> <span class=\"o\">=</span> <span class=\"n\">Mapper</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Whatever you return will be returned by mapper</span>\n<span class=\"nd\">@mpr</span><span class=\"o\">.</span><span class=\"n\">s_url</span><span class=\"p\">(</span><span class=\"s1\">'/some/path/'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"s1\">'str'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">a_str</span><span class=\"p\">,</span> <span class=\"n\">a_int</span><span class=\"p\">,</span> <span class=\"n\">a_float</span><span class=\"p\">,</span> <span class=\"n\">a_bool</span> <span class=\"o\">=</span> <span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'http://some.url/some/path'</span><span class=\"p\">)</span>\n</pre>\n<h4>Using the \"add\" function instead of the decorator</h4>\n<p>Sometimes you might have to register a function with the mapper at a later point. This can easily be achieved by using the mappers \"add\" function.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mapper</span> <span class=\"kn\">import</span> <span class=\"n\">Mapper</span>\n\n<span class=\"n\">mpr</span> <span class=\"o\">=</span> <span class=\"n\">Mapper</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">param1</span><span class=\"p\">,</span> <span class=\"n\">param2</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">param1</span><span class=\"p\">,</span> <span class=\"n\">param2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># It works the same way as the decorator.</span>\n<span class=\"c1\"># The only difference is, that we have to specify the function ourselves.</span>\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"s1\">'^/some/path/(?P&lt;param1&gt;[0-9]*)/$'</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">type_cast</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'param1'</span> <span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"s1\">'param2'</span> <span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">})</span>\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">s_add</span><span class=\"p\">(</span><span class=\"s1\">'/some/path/&lt;param1&gt;/'</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"p\">,</span> <span class=\"n\">type_cast</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'param1'</span> <span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"s1\">'param2'</span> <span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">})</span>\n\n<span class=\"n\">mpr</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s1\">'http://some.url/some/path/123?param2=456'</span><span class=\"p\">)</span>\n</pre>\n\n          </div>"}, "last_serial": 3733226, "releases": {"1.1.0": [{"comment_text": "", "digests": {"md5": "26b13f2bebd86ae0653a44516369332b", "sha256": "fe6a125d82feded7c0e81fb146cc3c30c9d6b6c8faae860e8d407a036a0b017c"}, "downloads": -1, "filename": "lwe-mapper-1.1.0.tar.gz", "has_sig": false, "md5_digest": "26b13f2bebd86ae0653a44516369332b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3041, "upload_time": "2016-07-06T11:13:37", "upload_time_iso_8601": "2016-07-06T11:13:37.913219Z", "url": "https://files.pythonhosted.org/packages/3c/95/93395988b148e9e016e0c07212ddfc74751f5713aa1ff7429d906e28bc78/lwe-mapper-1.1.0.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "efd51ae8390ac295dc91bd9ab1fe56d0", "sha256": "4e10bdb311f9a581ecf435c9c546b97993b62ccbb4ad04f3dfa5301f156545ef"}, "downloads": -1, "filename": "lwe-mapper-1.2.0.tar.gz", "has_sig": false, "md5_digest": "efd51ae8390ac295dc91bd9ab1fe56d0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3035, "upload_time": "2017-07-10T14:44:48", "upload_time_iso_8601": "2017-07-10T14:44:48.796497Z", "url": "https://files.pythonhosted.org/packages/92/5a/ce380fe22e4186bbb0dfb580abdb5b48a5853debdf278b08ca67982f2551/lwe-mapper-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "6a03fc8846e7742a92b83e1bac90f339", "sha256": "3ecec6bbd6be21bc495a804d054b592c41e5ce0f52314cfcfeca95aa02ed83f0"}, "downloads": -1, "filename": "lwe-mapper-1.2.1.tar.gz", "has_sig": false, "md5_digest": "6a03fc8846e7742a92b83e1bac90f339", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3049, "upload_time": "2017-07-10T17:14:41", "upload_time_iso_8601": "2017-07-10T17:14:41.598965Z", "url": "https://files.pythonhosted.org/packages/bf/b7/a38a0aabe77ff5bc80cc09a89e36c064aca73856ab1a397946e643a24acc/lwe-mapper-1.2.1.tar.gz", "yanked": false}], "1.2.2": [{"comment_text": "", "digests": {"md5": "51e820b45df9fd08b0287cfb456c272f", "sha256": "86d0f129ac75fd77be87be39046f2328c8f1b9bfb84641d91e6eaf639a1bf7e5"}, "downloads": -1, "filename": "lwe_mapper-1.2.2-py3.6.egg", "has_sig": false, "md5_digest": "51e820b45df9fd08b0287cfb456c272f", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": null, "size": 8351, "upload_time": "2018-04-04T09:50:56", "upload_time_iso_8601": "2018-04-04T09:50:56.759851Z", "url": "https://files.pythonhosted.org/packages/c5/64/716351983db69b5dba51f0c2504ad46a1eaaf3d45a08f6e56d08f7459209/lwe_mapper-1.2.2-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "d137c5c72a0ed10cb21c059491ac1818", "sha256": "9204c4e4b7c746c1ff5c2dd15f859813edf4ece553bcb1a61e1e21471540299e"}, "downloads": -1, "filename": "lwe-mapper-1.2.2.tar.gz", "has_sig": false, "md5_digest": "d137c5c72a0ed10cb21c059491ac1818", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4909, "upload_time": "2017-09-20T12:34:11", "upload_time_iso_8601": "2017-09-20T12:34:11.873694Z", "url": "https://files.pythonhosted.org/packages/bc/27/ebf3bfeb3b3fd33b6cf91b79586ada8cf9ae7947eb075b0519e88e1a400b/lwe-mapper-1.2.2.tar.gz", "yanked": false}], "1.2.5": [{"comment_text": "", "digests": {"md5": "9d66a7afe72f5ba17e6194078f8913f4", "sha256": "365e0d94d8ef5c2c9ea7cb7ea4a722d05d0bbc1aa5e8d68e9813725bab823e29"}, "downloads": -1, "filename": "lwe-mapper-1.2.5.tar.gz", "has_sig": false, "md5_digest": "9d66a7afe72f5ba17e6194078f8913f4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5594, "upload_time": "2018-04-04T10:31:17", "upload_time_iso_8601": "2018-04-04T10:31:17.759358Z", "url": "https://files.pythonhosted.org/packages/8d/1b/2597327d64cd06ae800a61315f9678af36fa16d88619677a89bb47a66612/lwe-mapper-1.2.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9d66a7afe72f5ba17e6194078f8913f4", "sha256": "365e0d94d8ef5c2c9ea7cb7ea4a722d05d0bbc1aa5e8d68e9813725bab823e29"}, "downloads": -1, "filename": "lwe-mapper-1.2.5.tar.gz", "has_sig": false, "md5_digest": "9d66a7afe72f5ba17e6194078f8913f4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5594, "upload_time": "2018-04-04T10:31:17", "upload_time_iso_8601": "2018-04-04T10:31:17.759358Z", "url": "https://files.pythonhosted.org/packages/8d/1b/2597327d64cd06ae800a61315f9678af36fa16d88619677a89bb47a66612/lwe-mapper-1.2.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:42:51 2020"}