{"info": {"author": "Blake A. Wilson", "author_email": "blakeaw1102@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Gleipnir\n\n![Python version badge](https://img.shields.io/badge/python-3.6-blue.svg)\n[![license](https://img.shields.io/github/license/LoLab-VU/Gleipnir.svg)](LICENSE)\n![version](https://img.shields.io/badge/version-0.25.0-orange.svg)\n[![release](https://img.shields.io/github/release-pre/LoLab-VU/Gleipnir.svg)](https://github.com/LoLab-VU/Gleipnir/releases/tag/v0.18.0)\n[![anaconda cloud](https://anaconda.org/blakeaw/gleipnir/badges/version.svg)](https://anaconda.org/blakeaw/gleipnir)\n[![DOI](https://zenodo.org/badge/173688080.svg)](https://zenodo.org/badge/latestdoi/173688080)\n[![Codacy Badge](https://api.codacy.com/project/badge/Grade/e117a46ae8b241539742ab00f8cd1b38)](https://www.codacy.com/app/blakeaw1102/Gleipnir?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=LoLab-VU/Gleipnir&amp;utm_campaign=Badge_Grade)\n\n<p align=\"center\">\n  <img width=\"100\" height=\"100\" src=\"./images/gleipnir_logo_2.png\">\n</p>\n\nGleipnir is a python toolkit that provides an easy to use interface for Bayesian parameter inference and model selection using Nested Sampling. It has a built-in implementation of the Nested Sampling algorithm but also provides a common interface to the Nested Sampling implementations MultiNest, PolyChord, dyPolyChord, DNest4, and Nestle.\nAlthough Gleipnir provides a general framework for running Nested Sampling simulations, it was created with biological models in mind. It therefore supplies additional tools for working with biological models in the PySB format (see the PySB Utilities section). Likewise, Gleipnir's API was designed to be familiar to users of [PyDREAM](https://github.com/LoLab-VU/PyDREAM) and [SimplePSO](https://github.com/LoLab-VU/ParticleSwarmOptimization), which are primarily used for biological model calibration.\n\n### What is Nested Sampling?\n\nNested Sampling is a numerical integration scheme for estimating the marginal likelihood, or in Nested Sampling parlance, the 'evidence' of high-dimensional models.\nAs a side-effect of the evidence calculation, estimates of the posterior probability distributions of model parameters can also be generated.   \n\nIn particular, Nested Sampling was\ndesigned to handle evaluate the evidence of high-dimensional models where the likelihood is exponentially localized in the prior probability mass. In the Nested Sampling approach, the evidence is first converted from a (possibly) multi-dimensional integral into a one-dimensional integral taken over a mapping of the likelihood function to elements of the unit prior probability mass (X). In principle, this is achieved by using a top-down\napproach in which sample points are drawn according to the prior distribution, and the unit prior probability is subdivided\ninto equal fractional elements from X = 1 down to X = 0 and\nmapped to the likelihood function, L(X), via a likelihood sorting routine.\n\nThe Nested Sampling method was originally developed by John Skilling; see the following references:\n  1. Skilling, John. \"Nested sampling.\" AIP Conference Proceedings. Vol.\n    735. No. 1. AIP, 2004.\n  2. Skilling, John. \"Nested sampling for general Bayesian computation.\"\n    Bayesian analysis 1.4 (2006): 833-859.\n  3. Skilling, John. \"Nested sampling\u2019s convergence.\" AIP Conference\n    Proceedings. Vol. 1193. No. 1. AIP, 2009.\n\n------\n\n# Install\n\n| **! Warning** |\n| :--- |\n|  Gleipnir is still under heavy development and may rapidly change. |\n\nGleipnir installs as the `gleipnir` package. It is compatible with Python 3.6.\n\n#### conda install\nAlthough not absolutely required, we recommend using the [Anaconda](https://www.anaconda.com/) Python distribution and the [conda](https://conda.io/en/latest/) package manager.\n\n`gleipnir` can be installed from the terminal using `conda`:\n```\nconda intall -c blakeaw gleipnir\n```\nNote that `gleipnir` has the following core dependencies which will also be installed:\n   * [NumPy](http://www.numpy.org/)\n   * [SciPy](https://www.scipy.org/)\n   * [pandas](https://pandas.pydata.org/)\n\nAlternatively, for convenience, a `gleipnir` environment can be downloaded/created that has `gleipnir`, its core dependencies, as well as several optional/recommended packages; the optional/recommended packages include `pysb`, `hypbuilder`, `matplotlib`, `seaborn`, and `jupyter`.\nFrom the terminal:\n```\nconda env create blakeaw/gleipnir\n```\nand then activate it with:\n```\nconda activate gleipnir\n```\n\nAdditionally, there is another `gleipnir` environment for linux-64 that can be downloaded/created that has `gleipnir`, its core dependencies, as well as most of the recommended additional software packages; note that the versions of packages are pinned to exact version numbers in this environment file.\nFrom the terminal:\n```\nconda env create blakeaw/gleipnir-all-linux64\n```\nand then activate it with:\n```\nconda activate gleipnir\n```\n\n#### pip install\nYou can install the `gleipnir` package using `pip` sourced from the GitHub repo:\n```\npip install -e git+https://github.com/LoLab-VU/Gleipnir@v0.18.0#egg=gleipnir\n```\nHowever, this will not automatically install the core dependencies. You will have to do that separately:\n```\npip install numpy scipy pandas\n```\n\n### Recommended additional software\n\nThe following software is not required for the basic operation of Gleipnir, but provides extra capabilities and features when installed.\n\n#### PySB\n[PySB](http://pysb.org/) is needed to run PySB models and it is needed if you want to use the gleipnir.pysb_utilities module:\n```\nconda install -c alubbock pysb\n```\n\n#### HypBuilder\nIf you want use the HypSelector class from gleipnir.pysb_utilities then you\nneed to have [HypBuilder](https://github.com/LoLab-VU/HypBuilder):\n```\nconda install -c blakeaw hypbuilder\n```\n\n#### Jupyter\nIf you want to run the Jupyter IPython notebooks that come with Gleipnir then you need to install [Jupyter](https://jupyter.org/):\n```\nconda install jupyter\n```\n\n#### Plotting packages:\nWe recommend installing [Matplotlib](https://matplotlib.org/) and [seaborn](https://seaborn.pydata.org/) to generate plots. Note that some of the Gleipnir examples will use these packages if they are installed to generate sample plots. Matplotlib is also needed for one of the Jupyter notebooks.\n```\nconda install matplotlib seaborn\n```\n\n#### MultiNest\nIf you want to run Nested Sampling simulations using Gleipnir's MultiNest interface class object, MultiNestNestedSampling (from the gleipnir.multinest module), then you will need to install [PyMultiNest](https://github.com/JohannesBuchner/PyMultiNest) and [MultiNest](https://github.com/JohannesBuchner/MultiNest). Build and install instructions for getting PyMultiNest and MultiNest from source can be found at:\nhttp://johannesbuchner.github.io/PyMultiNest/install.html\n\nPyMultiNest is available on PyPI:\n```\npip install pymultinest\n```\nNote that in addition to MultiNest, `pymultinest` requires `numpy`, `scipy`, and `matplotlib` to run. It also optionally requires `mpi4py` to run MultiNest with MPI parallelization.\n\nYou can get a linux-64 conda build of MultiNest from the [blakeaw conda channel](https://anaconda.org/blakeaw/multinest):\n```\nconda install -c blakeaw multinest\n```\nNote that this conda build of MultiNest requires packages from the `anaconda` and `conda-forge` channels, so you'll need to add them to the channel list in your conda config (.condarc) file. You can also install a build of `mpi4py` that is compatible with this build of `multinest` from the [blakeaw conda channel](https://anaconda.org/blakeaw/mpi4py):\n```\nconda install -c blakeaw mpi4py\n```\n\nAdditionally, a separate set of third party instructions for building and installing on Mac OS can be found at:\nhttp://astrobetter.com/wiki/MultiNest+Installation+Notes\n\nAlso, this PyMultiNest GitHub issue may be helpful if you run into library path problems on Mac OS:\nhttps://github.com/JohannesBuchner/PyMultiNest/issues/89\n\n#### PolyChord\nIf you want run Nested Sampling simulations using [PolyChord](https://github.com/PolyChord/PolyChordLite) via the\nPolyChordNestedSampling class from the gleipnir.polychord, then you will need to install pypolychord (for PolyChordLite version >= 1.16). Build and install instructions are in the README at:\nhttps://github.com/PolyChord/PolyChordLite\n\nHowever, as per [PolyChordLite GitHub Issue 11](https://github.com/PolyChord/PolyChordLite/issues/11) there is a version of pypolychord on PyPI which should work for linux-64:\n```\npip install pypolychord\n```\nBut note that the current version of pypolychord on PyPI (as of 07-01-2019) is not the most recent version, and some of the extra functionality provided by Gleipnir will not work with it.\n\nSpecial Notes for builds from source on linux-64:\n * Installs into your .local/lib python site-packages.\n * Requires gfortran (f77 compiler) and lipopenmpi-dev (development libraries for MPI) to build the code.\n\n#### dyPolyChord\nIf you want to run Nested Sampling simulations using\n[dyPolyChord](https://github.com/ejhigson/dyPolyChord) using Gleipnir's interface object, dyPolyChordNestedSampling (from the gleipnir.dypolychord module), then you will need to install dyPolyChord (available on PyPI):\n```\npip install dyPolyChord\n```\nNote that dyPolyChord requires PolyChord to run, so its use via Gleipnir requires the pypolychord package; see the the previous section. Also note that in addition to PolyChord, `dyPolyChord` requires `numpy`, `scipy`, and `nestcheck` to run. It also optionally requires `mpi4py` to run with MPI parallelization.\nFor additional information check out the [dyPolyChord documentation](https://dypolychord.readthedocs.io/en/latest/index.html).\n\n#### DNest4\nIf you want run Nested Sampling simulations using [DNest4](https://github.com/eggplantbren/DNest4) via the DNest4NestedSampling class from the gleipnir.dnest4 module, then you will need to get DNest4 and its Python bindings. Instructions for building and installing from source can be found in the README at:\nhttps://github.com/eggplantbren/DNest4\n\nAdditionally, a linux-64 conda build of dnest4 can be installed from\nthe [blakeaw conda channel](https://anaconda.org/blakeaw/dnest4):\n```\nconda install -c blakeaw dnest4\n```\n\nSpecial Notes for building and installing from source:\n * Requires a c++ compiler with c++11 standard libraries.\n * Requires Cython and numba for python bindings to compile and install\n\n#### Nestle\nIf you want to run Nested Sampling simulations using\n[Nestle](https://github.com/kbarbary/nestle) via Gleipnir's interface object, NestleNestedSampling (from the gleipnir.nestle module), then you will need to install Nestle (available on PyPI):\n```\npip install nestle\n```\nNote that Nestle requires `numpy` to run (also required for gleipnir), and it also optionally requires `scipy`.\n\nFor additional information check out the [Nestle documentation](http://kylebarbary.com/nestle/).\n\n------\n\n# License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details\n\n------\n\n# Documentation and Usage\n\nCheckout the Jupyter Notebooks (more in the pipeline):\n 1. [Intro to Nested Sampling with Gleipnir](./jupyter_notebooks/Intro_to_Nested_Sampling_with_Gleipnir.ipynb)\n 2. [Nested Sampling Classes](./jupyter_notebooks/Nested_Sampling_classes.ipynb)\n 3. [HypSelector Example](./jupyter_notebooks/HypSelector_example.ipynb)\n 4. [ModelSelector Example](./jupyter_notebooks/ModelSelector_example.ipynb)\n\nAlso checkout the [examples](./examples) to see example scripts that show how to setup Nested Sampling runs using Gleipnir.\n\n------\n\n# Contact\n\nTo report problems or bugs please open a\n[GitHub Issue](https://github.com/LoLab-VU/Gleipnir/issues). Additionally, any\ncomments, suggestions, or feature requests for Gleipnir can also be submitted as a\n[GitHub Issue](https://github.com/LoLab-VU/Gleipnir/issues).\n\n------\n\n# PySB Utilities\n\n## nestedsample_it\nnestedsample_it is a utility that helps generate a Nested Sampling run script or NestedSampling objects for a PySB model.\n\n### Commmand line use\nnestedsample_it can be used as a command line utility to generate a template Nested Sampling run script for a PySB model. nestedsample_it reads the model file, imports and pulls out all the kinetic parameters, and then writes out a run_NS script for that model. nestedsample_it currently writes out a run script for classic Nested Sampling via Gleipnir, so you'll need to modify it to use one of the other Nested Samplers (MultiNest, PolyChord, or DNest4). And you will need to edit the run script to load any data and modify the loglikelihood function, but nestedsample_it should give you a good starting point.\n\nRun nestedsample_it from the command line with following format:\n```\npython -m glepnir.pysb_utilities.nestedsample_it model.py output_path\n```      \nwhere output_path is the directory/folder location where you want the generated script\nto be saved.\n\nThe command line version of nestedsample_it also has support for a limited set of #NESTEDSAMPLE_IT directives which can be added to model files. The current directives are:\n  * #NESTEDSAMPLE_IT prior [param_name, param_index] [norm, uniform]  \n    * Specify the type of prior to assign to a parameter. The parameter can either be specified by its name or its index (in model.parameters). The priors that can be assigned are either norm or uniform; note that uniform is the default for all parameters.  \n  * #NESTEDSAMPLE_IT no-sample [param_name, param_index]\n     * Specify a fixed parameter (i.e., not to included in sampling). The parameter can either be specified by its name or its index (in model.parameters).          \n\n\n### Progammatic use via the NestedSampleIt class\nThe nestedsample_it utility can be used progammatically via the NestedSampleIt\nclass. It's importable from the pysb_utilities module:\n```python\nfrom gleipnir.pysb_utilities import NestedSampleIt\n```\nThe NestedSampleIt class can build an instance of a NestedSampling object.  \n Here's a faux minimal example:\n```python\nfrom my_pysb_model import model as my_model\nfrom gleipnir.pysb_utilities import NestedSampleIt\nimport numpy as np\n\ntimespan = np.linspace(0., 10., 10)\ndata = np.load('my_data.npy')\ndata_sd = np.load('my_data_sd.npy')\nobservable_data = dict()\ntime_idxs = list(range(len(timespan)))\nobservable_data['my_observable'] = (data, data_sd, time_idxs)\n# Initialize the NestedSampleIt instance with the model details.\nsample_it = NestedSampleIt(my_model, observable_data, timespan)\n# Now build the NestedSampling object. -- All inputs are\n# optional keyword arguments.\nnested_sampler = sample_it(ns_version='gleipnir-classic',\n                           ns_population_size=100,\n                           ns_kwargs=dict(),\n                           log_likelihood_type='logpdf')\n# Then you can run the nested sampler.\nlog_evidence, log_evidence_error = nested_sampler.run()\n```\n\nNestedSampleIt constructs the NestedSampling object to sample all of a model's kinetic rate parameters. It assumes that the priors are uniform with size 4 orders of magnitude and centered on the values defined in the model.\n\nIn addition, NestedSampleIt crrently has three pre-defined loglikelihood functions with different estimators. They can be specified with the keyword parameter log_likelihood_type:\n```python\n# Now build the NestedSampling object.\nnested_sampler = sample_it(log_likelihood_type='logpdf')\n```\nThe options are\n  * 'logpdf'=>Compute the loglikelihood using the\nnormal distribution estimator\n  * 'mse'=>Compute the loglikelihood using the\nnegative mean squared error estimator\n  * 'sse'=>Compute the loglikelihood using\nthe negative sum of squared errors estimator.\nThe default is 'logpdf'.\nEach of these functions computes the loglikelihood estimate using the timecourse output of a model simulation for each observable defined in the `observable_data` dictionary.\nIf you want to use a different or more complicated likelihood function with NestedSampleIt then you'll need to subclass it and override one of the existing loglikelihood functions.  \n\n#### NestIt\nThe nestedsample_it module has a built-in helper class, NestIt, which can be used in conjunction of with NestedSampleIt class. NestIt can be used at the level of PySB model definition to log which parameters to include in\na Nested Sampling run. It can be imported from the pysb_utilities module:\n```python\nfrom gleipnir.pysb_utilities import NestIt\n```\nIt is passed at instantiation to the NestedSampleIt class, which uses it\nto build the sampled parameters list and parameter mask for the likelihood\nfunction.\nSee the following example files:\n\n   * [dimerization_model_nestit](./examples/pysb_dimerization_model/dimerization_model_nestit.py) - example model definition using NestIt to flag parameters.\n   * [run_NS_NestedSampleIt_NestIt_dimerization_model](./examples/pysb_dimerization_model/run_NS_NestedSampleIt_NestIt_dimerization_model.py) - example use of NestIt with NestedSampleIt.\n\nNote that if you flag a parameter for sampling without setting a prior, NestIt will by default assign the parameter a uniform prior centered on the parameter's value with a width of 4 orders of magnitude.  \n\n#### Builder class from pysb.builder\n\nThe Builder class from pysb.builder can also be used in conjunction with the NestedSampleIt class. The Builder class itself is a wrapper class that can be used to construct a PySB model and set parameter priors, logging them for sampling. Although\nthis feature was originally intended for use with the BayesSB package, the NestedSampleIt class supports it as a logger for sampled parameters.\nThe instance of the Builder is passed at instantiation to the NestedSampleIt class, which uses it to build the sampled parameters list and parameter mask for the likelihood function.\nSee the following example files:\n\n   * [dimerization_model_builder](./examples/pysb_dimerization_model/dimerization_model_builder.py) - example model definition using Builder to construct a PySB model and flag parameters for sampling.\n   * [run_NS_NestedSampleIt_Builder_dimerization_model](./examples/pysb_dimerization_model/run_NS_NestedSampleIt_Builder_dimerization_model.py) - example use of Builder with NestedSampleIt.\n\nNote that you have to explicitly set a prior for each parameter that you want to sample when you add it your model with the builder.parameter function. If no\nprior is given the parameter won't be included as a sampled parameter in the Nested Sampling run.\n\n## HypSelector\n\nHypSelector is a tool for hypothesis selection using [HypBuilder](https://github.com/LoLab-VU/HypBuilder) and Nested Sampling-based model selection. Models embodying different hypotheses (e.g., optional reactions) can be defined using the HypBuilder csv syntax. HypSelector then allows users to easily compare all the hypothetical model variants generated by HypBuilder by performing Nested Sampling to compute their evidences and thereby do model selection; HypSelector also provides functionality to estimate Bayes factors from the evidence estimates, as well as estimators for the Akaike, Bayesian, and Deviance information criteria computed from the Nested Sampling outputs. See the [grouped reactions example](./examples/HypSelector/grouped_reactions) or the [HypSelector Example Jupyter Notebook](./jupyter_notebooks/HypSelector_example.ipynb) to see example usage of HypSelector.\n\n## ModelSelector\n\nSimilar to HypSelector, ModelSelector is a tool for PySB model selection using Nested Sampling-based model selection. ModelSelector allows users to easily compare model variants written in PySB and see which one may best explain a dataset by performing Nested Sampling to compute their evidences and thereby do model selection; ModelSelector also provides functionality to estimate Bayes factors from the evidence estimates, as well as estimators for the Akaike, Bayesian, and Deviance information criteria computed from the Nested Sampling outputs. See the [ModelSelector Example Jupyter Notebook](./jupyter_notebooks/ModelSelector_example.ipynb) to see example usage of ModelSelector.\n\n------\n\n# Citing\n\nIf you use the Gleipnir software in your research, please cite it. You can export the  Gleipnir citation in your preferred format from its [Zenodo DOI](http://doi.org/10.5281/zenodo.3036345) entry.  \n\nAlso, please cite the following references as appropriate for software used with/via Gleipnir:\n\n#### Packages from the SciPy ecosystem\n\nThese include NumPy, SciPy, Pandas, and Matplotlib for which references can be obtained from:\nhttps://www.scipy.org/citing.html\n\n#### PySB\n  1. Lopez, C. F., Muhlich, J. L., Bachman, J. A. & Sorger, P. K. Programming biological models in Python using PySB. Mol Syst Biol 9, (2013). doi:[10.1038/msb.2013.1](dx.doi.org/10.1038/msb.2013.1)\n\n#### MultiNest\n  1. Feroz, Farhan, and M. P. Hobson. \"Multimodal nested sampling: an\n      efficient and robust alternative to Markov Chain Monte Carlo\n      methods for astronomical data analyses.\" Monthly Notices of the\n      Royal Astronomical Society 384.2 (2008): 449-463.\n  2. Feroz, F., M. P. Hobson, and M. Bridges. \"MultiNest: an efficient\n      and robust Bayesian inference tool for cosmology and particle\n      physics.\" Monthly Notices of the Royal Astronomical Society 398.4\n      (2009): 1601-1614.\n  3. Feroz, F., et al. \"Importance nested sampling and the MultiNest\n      algorithm.\" arXiv preprint arXiv:1306.2144 (2013).\n\n#### PyMultiNest:\n  1. Buchner, J., et al. \"X-ray spectral modelling of the AGN obscuring region in the CDFS: Bayesian model selection and catalogue.\" Astronomy & Astrophysics 564 (2014): A125.\n\n#### PolyChord\n  1. Handley, W. J., M. P. Hobson, and A. N. Lasenby. \"PolyChord: nested sampling for cosmology.\" Monthly Notices of the Royal Astronomical Society: Letters 450.1 (2015): L61-L65.\n  2. Handley, W. J., M. P. Hobson, and A. N. Lasenby. \"POLYCHORD:\n    next-generation nested sampling.\" Monthly Notices of the Royal\n    Astronomical Society 453.4 (2015): 4384-4398.\n\n#### DNest4\n\n  1. Brewer, B. J., P\u00e1rtay, L. B., & Cs\u00e1nyi, G. (2011). Diffusive nested\n        sampling. Statistics and Computing, 21(4), 649-656        \n  2. Brewer, B., & Foreman-Mackey, D. (2018). DNest4: Diffusive Nested Sampling in C++ and Python. Journal of Statistical Software, 86(7), 1 - 33. doi:[10.18637/jss.v086.i07](http://dx.doi.org/10.18637/jss.v086.i07)\n\n#### Nestle\nCite the GitHub repo: https://github.com/kbarbary/nestle\n\n\n#### seaborn\nReference can be exported from the [seaborn Zeondo DOI entry](https://doi.org/10.5281/zenodo.592845)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/LoLab-VU/Gleipnir", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "gleipnir-ns", "package_url": "https://pypi.org/project/gleipnir-ns/", "platform": "", "project_url": "https://pypi.org/project/gleipnir-ns/", "project_urls": {"Homepage": "https://github.com/LoLab-VU/Gleipnir"}, "release_url": "https://pypi.org/project/gleipnir-ns/0.25.0/", "requires_dist": ["numpy", "scipy", "pandas"], "requires_python": ">=3.6", "summary": "Python toolkit for Nested Sampling.", "version": "0.25.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Gleipnir</h1>\n<p><img alt=\"Python version badge\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/01419d339114693587408dd14856677a4789006a/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e362d626c75652e737667\">\n<a href=\"LICENSE\" rel=\"nofollow\"><img alt=\"license\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/841b4b817044a1498e54e093273d251ada7acd15/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f4c6f4c61622d56552f476c6569706e69722e737667\"></a>\n<img alt=\"version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/86ee215764543e252969774ce8a2a328d7cd8917/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f76657273696f6e2d302e32352e302d6f72616e67652e737667\">\n<a href=\"https://github.com/LoLab-VU/Gleipnir/releases/tag/v0.18.0\" rel=\"nofollow\"><img alt=\"release\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e618dc46f9fbfd98ffe75ac11925ea996183e1e3/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652d7072652f4c6f4c61622d56552f476c6569706e69722e737667\"></a>\n<a href=\"https://anaconda.org/blakeaw/gleipnir\" rel=\"nofollow\"><img alt=\"anaconda cloud\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8745ab45448111984d8c311183edeff754d79094/68747470733a2f2f616e61636f6e64612e6f72672f626c616b6561772f676c6569706e69722f6261646765732f76657273696f6e2e737667\"></a>\n<a href=\"https://zenodo.org/badge/latestdoi/173688080\" rel=\"nofollow\"><img alt=\"DOI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6342b6ea0add080d9cc300668a744c326625b97d/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f3137333638383038302e737667\"></a>\n<a href=\"https://www.codacy.com/app/blakeaw1102/Gleipnir?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=LoLab-VU/Gleipnir&amp;utm_campaign=Badge_Grade\" rel=\"nofollow\"><img alt=\"Codacy Badge\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/99a6315d669accae5e8fedb63cdeee9b295c1f30/68747470733a2f2f6170692e636f646163792e636f6d2f70726f6a6563742f62616467652f47726164652f6531313761343661653862323431353339373432616230306638636431623338\"></a></p>\n<p align=\"center\">\n  <img height=\"100\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/96d77029c82fe1be74f210292f316e1db4aa3572/2e2f696d616765732f676c6569706e69725f6c6f676f5f322e706e67\" width=\"100\">\n</p>\n<p>Gleipnir is a python toolkit that provides an easy to use interface for Bayesian parameter inference and model selection using Nested Sampling. It has a built-in implementation of the Nested Sampling algorithm but also provides a common interface to the Nested Sampling implementations MultiNest, PolyChord, dyPolyChord, DNest4, and Nestle.\nAlthough Gleipnir provides a general framework for running Nested Sampling simulations, it was created with biological models in mind. It therefore supplies additional tools for working with biological models in the PySB format (see the PySB Utilities section). Likewise, Gleipnir's API was designed to be familiar to users of <a href=\"https://github.com/LoLab-VU/PyDREAM\" rel=\"nofollow\">PyDREAM</a> and <a href=\"https://github.com/LoLab-VU/ParticleSwarmOptimization\" rel=\"nofollow\">SimplePSO</a>, which are primarily used for biological model calibration.</p>\n<h3>What is Nested Sampling?</h3>\n<p>Nested Sampling is a numerical integration scheme for estimating the marginal likelihood, or in Nested Sampling parlance, the 'evidence' of high-dimensional models.\nAs a side-effect of the evidence calculation, estimates of the posterior probability distributions of model parameters can also be generated.</p>\n<p>In particular, Nested Sampling was\ndesigned to handle evaluate the evidence of high-dimensional models where the likelihood is exponentially localized in the prior probability mass. In the Nested Sampling approach, the evidence is first converted from a (possibly) multi-dimensional integral into a one-dimensional integral taken over a mapping of the likelihood function to elements of the unit prior probability mass (X). In principle, this is achieved by using a top-down\napproach in which sample points are drawn according to the prior distribution, and the unit prior probability is subdivided\ninto equal fractional elements from X = 1 down to X = 0 and\nmapped to the likelihood function, L(X), via a likelihood sorting routine.</p>\n<p>The Nested Sampling method was originally developed by John Skilling; see the following references:</p>\n<ol>\n<li>Skilling, John. \"Nested sampling.\" AIP Conference Proceedings. Vol.</li>\n<li>No. 1. AIP, 2004.</li>\n<li>Skilling, John. \"Nested sampling for general Bayesian computation.\"\nBayesian analysis 1.4 (2006): 833-859.</li>\n<li>Skilling, John. \"Nested sampling\u2019s convergence.\" AIP Conference\nProceedings. Vol. 1193. No. 1. AIP, 2009.</li>\n</ol>\n<hr>\n<h1>Install</h1>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>! Warning</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Gleipnir is still under heavy development and may rapidly change.</td>\n</tr></tbody></table>\n<p>Gleipnir installs as the <code>gleipnir</code> package. It is compatible with Python 3.6.</p>\n<h4>conda install</h4>\n<p>Although not absolutely required, we recommend using the <a href=\"https://www.anaconda.com/\" rel=\"nofollow\">Anaconda</a> Python distribution and the <a href=\"https://conda.io/en/latest/\" rel=\"nofollow\">conda</a> package manager.</p>\n<p><code>gleipnir</code> can be installed from the terminal using <code>conda</code>:</p>\n<pre><code>conda intall -c blakeaw gleipnir\n</code></pre>\n<p>Note that <code>gleipnir</code> has the following core dependencies which will also be installed:</p>\n<ul>\n<li><a href=\"http://www.numpy.org/\" rel=\"nofollow\">NumPy</a></li>\n<li><a href=\"https://www.scipy.org/\" rel=\"nofollow\">SciPy</a></li>\n<li><a href=\"https://pandas.pydata.org/\" rel=\"nofollow\">pandas</a></li>\n</ul>\n<p>Alternatively, for convenience, a <code>gleipnir</code> environment can be downloaded/created that has <code>gleipnir</code>, its core dependencies, as well as several optional/recommended packages; the optional/recommended packages include <code>pysb</code>, <code>hypbuilder</code>, <code>matplotlib</code>, <code>seaborn</code>, and <code>jupyter</code>.\nFrom the terminal:</p>\n<pre><code>conda env create blakeaw/gleipnir\n</code></pre>\n<p>and then activate it with:</p>\n<pre><code>conda activate gleipnir\n</code></pre>\n<p>Additionally, there is another <code>gleipnir</code> environment for linux-64 that can be downloaded/created that has <code>gleipnir</code>, its core dependencies, as well as most of the recommended additional software packages; note that the versions of packages are pinned to exact version numbers in this environment file.\nFrom the terminal:</p>\n<pre><code>conda env create blakeaw/gleipnir-all-linux64\n</code></pre>\n<p>and then activate it with:</p>\n<pre><code>conda activate gleipnir\n</code></pre>\n<h4>pip install</h4>\n<p>You can install the <code>gleipnir</code> package using <code>pip</code> sourced from the GitHub repo:</p>\n<pre><code>pip install -e git+https://github.com/LoLab-VU/Gleipnir@v0.18.0#egg=gleipnir\n</code></pre>\n<p>However, this will not automatically install the core dependencies. You will have to do that separately:</p>\n<pre><code>pip install numpy scipy pandas\n</code></pre>\n<h3>Recommended additional software</h3>\n<p>The following software is not required for the basic operation of Gleipnir, but provides extra capabilities and features when installed.</p>\n<h4>PySB</h4>\n<p><a href=\"http://pysb.org/\" rel=\"nofollow\">PySB</a> is needed to run PySB models and it is needed if you want to use the gleipnir.pysb_utilities module:</p>\n<pre><code>conda install -c alubbock pysb\n</code></pre>\n<h4>HypBuilder</h4>\n<p>If you want use the HypSelector class from gleipnir.pysb_utilities then you\nneed to have <a href=\"https://github.com/LoLab-VU/HypBuilder\" rel=\"nofollow\">HypBuilder</a>:</p>\n<pre><code>conda install -c blakeaw hypbuilder\n</code></pre>\n<h4>Jupyter</h4>\n<p>If you want to run the Jupyter IPython notebooks that come with Gleipnir then you need to install <a href=\"https://jupyter.org/\" rel=\"nofollow\">Jupyter</a>:</p>\n<pre><code>conda install jupyter\n</code></pre>\n<h4>Plotting packages:</h4>\n<p>We recommend installing <a href=\"https://matplotlib.org/\" rel=\"nofollow\">Matplotlib</a> and <a href=\"https://seaborn.pydata.org/\" rel=\"nofollow\">seaborn</a> to generate plots. Note that some of the Gleipnir examples will use these packages if they are installed to generate sample plots. Matplotlib is also needed for one of the Jupyter notebooks.</p>\n<pre><code>conda install matplotlib seaborn\n</code></pre>\n<h4>MultiNest</h4>\n<p>If you want to run Nested Sampling simulations using Gleipnir's MultiNest interface class object, MultiNestNestedSampling (from the gleipnir.multinest module), then you will need to install <a href=\"https://github.com/JohannesBuchner/PyMultiNest\" rel=\"nofollow\">PyMultiNest</a> and <a href=\"https://github.com/JohannesBuchner/MultiNest\" rel=\"nofollow\">MultiNest</a>. Build and install instructions for getting PyMultiNest and MultiNest from source can be found at:\n<a href=\"http://johannesbuchner.github.io/PyMultiNest/install.html\" rel=\"nofollow\">http://johannesbuchner.github.io/PyMultiNest/install.html</a></p>\n<p>PyMultiNest is available on PyPI:</p>\n<pre><code>pip install pymultinest\n</code></pre>\n<p>Note that in addition to MultiNest, <code>pymultinest</code> requires <code>numpy</code>, <code>scipy</code>, and <code>matplotlib</code> to run. It also optionally requires <code>mpi4py</code> to run MultiNest with MPI parallelization.</p>\n<p>You can get a linux-64 conda build of MultiNest from the <a href=\"https://anaconda.org/blakeaw/multinest\" rel=\"nofollow\">blakeaw conda channel</a>:</p>\n<pre><code>conda install -c blakeaw multinest\n</code></pre>\n<p>Note that this conda build of MultiNest requires packages from the <code>anaconda</code> and <code>conda-forge</code> channels, so you'll need to add them to the channel list in your conda config (.condarc) file. You can also install a build of <code>mpi4py</code> that is compatible with this build of <code>multinest</code> from the <a href=\"https://anaconda.org/blakeaw/mpi4py\" rel=\"nofollow\">blakeaw conda channel</a>:</p>\n<pre><code>conda install -c blakeaw mpi4py\n</code></pre>\n<p>Additionally, a separate set of third party instructions for building and installing on Mac OS can be found at:\n<a href=\"http://astrobetter.com/wiki/MultiNest+Installation+Notes\" rel=\"nofollow\">http://astrobetter.com/wiki/MultiNest+Installation+Notes</a></p>\n<p>Also, this PyMultiNest GitHub issue may be helpful if you run into library path problems on Mac OS:\n<a href=\"https://github.com/JohannesBuchner/PyMultiNest/issues/89\" rel=\"nofollow\">https://github.com/JohannesBuchner/PyMultiNest/issues/89</a></p>\n<h4>PolyChord</h4>\n<p>If you want run Nested Sampling simulations using <a href=\"https://github.com/PolyChord/PolyChordLite\" rel=\"nofollow\">PolyChord</a> via the\nPolyChordNestedSampling class from the gleipnir.polychord, then you will need to install pypolychord (for PolyChordLite version &gt;= 1.16). Build and install instructions are in the README at:\n<a href=\"https://github.com/PolyChord/PolyChordLite\" rel=\"nofollow\">https://github.com/PolyChord/PolyChordLite</a></p>\n<p>However, as per <a href=\"https://github.com/PolyChord/PolyChordLite/issues/11\" rel=\"nofollow\">PolyChordLite GitHub Issue 11</a> there is a version of pypolychord on PyPI which should work for linux-64:</p>\n<pre><code>pip install pypolychord\n</code></pre>\n<p>But note that the current version of pypolychord on PyPI (as of 07-01-2019) is not the most recent version, and some of the extra functionality provided by Gleipnir will not work with it.</p>\n<p>Special Notes for builds from source on linux-64:</p>\n<ul>\n<li>Installs into your .local/lib python site-packages.</li>\n<li>Requires gfortran (f77 compiler) and lipopenmpi-dev (development libraries for MPI) to build the code.</li>\n</ul>\n<h4>dyPolyChord</h4>\n<p>If you want to run Nested Sampling simulations using\n<a href=\"https://github.com/ejhigson/dyPolyChord\" rel=\"nofollow\">dyPolyChord</a> using Gleipnir's interface object, dyPolyChordNestedSampling (from the gleipnir.dypolychord module), then you will need to install dyPolyChord (available on PyPI):</p>\n<pre><code>pip install dyPolyChord\n</code></pre>\n<p>Note that dyPolyChord requires PolyChord to run, so its use via Gleipnir requires the pypolychord package; see the the previous section. Also note that in addition to PolyChord, <code>dyPolyChord</code> requires <code>numpy</code>, <code>scipy</code>, and <code>nestcheck</code> to run. It also optionally requires <code>mpi4py</code> to run with MPI parallelization.\nFor additional information check out the <a href=\"https://dypolychord.readthedocs.io/en/latest/index.html\" rel=\"nofollow\">dyPolyChord documentation</a>.</p>\n<h4>DNest4</h4>\n<p>If you want run Nested Sampling simulations using <a href=\"https://github.com/eggplantbren/DNest4\" rel=\"nofollow\">DNest4</a> via the DNest4NestedSampling class from the gleipnir.dnest4 module, then you will need to get DNest4 and its Python bindings. Instructions for building and installing from source can be found in the README at:\n<a href=\"https://github.com/eggplantbren/DNest4\" rel=\"nofollow\">https://github.com/eggplantbren/DNest4</a></p>\n<p>Additionally, a linux-64 conda build of dnest4 can be installed from\nthe <a href=\"https://anaconda.org/blakeaw/dnest4\" rel=\"nofollow\">blakeaw conda channel</a>:</p>\n<pre><code>conda install -c blakeaw dnest4\n</code></pre>\n<p>Special Notes for building and installing from source:</p>\n<ul>\n<li>Requires a c++ compiler with c++11 standard libraries.</li>\n<li>Requires Cython and numba for python bindings to compile and install</li>\n</ul>\n<h4>Nestle</h4>\n<p>If you want to run Nested Sampling simulations using\n<a href=\"https://github.com/kbarbary/nestle\" rel=\"nofollow\">Nestle</a> via Gleipnir's interface object, NestleNestedSampling (from the gleipnir.nestle module), then you will need to install Nestle (available on PyPI):</p>\n<pre><code>pip install nestle\n</code></pre>\n<p>Note that Nestle requires <code>numpy</code> to run (also required for gleipnir), and it also optionally requires <code>scipy</code>.</p>\n<p>For additional information check out the <a href=\"http://kylebarbary.com/nestle/\" rel=\"nofollow\">Nestle documentation</a>.</p>\n<hr>\n<h1>License</h1>\n<p>This project is licensed under the MIT License - see the <a href=\"LICENSE\" rel=\"nofollow\">LICENSE</a> file for details</p>\n<hr>\n<h1>Documentation and Usage</h1>\n<p>Checkout the Jupyter Notebooks (more in the pipeline):</p>\n<ol>\n<li><a href=\"./jupyter_notebooks/Intro_to_Nested_Sampling_with_Gleipnir.ipynb\" rel=\"nofollow\">Intro to Nested Sampling with Gleipnir</a></li>\n<li><a href=\"./jupyter_notebooks/Nested_Sampling_classes.ipynb\" rel=\"nofollow\">Nested Sampling Classes</a></li>\n<li><a href=\"./jupyter_notebooks/HypSelector_example.ipynb\" rel=\"nofollow\">HypSelector Example</a></li>\n<li><a href=\"./jupyter_notebooks/ModelSelector_example.ipynb\" rel=\"nofollow\">ModelSelector Example</a></li>\n</ol>\n<p>Also checkout the <a href=\"./examples\" rel=\"nofollow\">examples</a> to see example scripts that show how to setup Nested Sampling runs using Gleipnir.</p>\n<hr>\n<h1>Contact</h1>\n<p>To report problems or bugs please open a\n<a href=\"https://github.com/LoLab-VU/Gleipnir/issues\" rel=\"nofollow\">GitHub Issue</a>. Additionally, any\ncomments, suggestions, or feature requests for Gleipnir can also be submitted as a\n<a href=\"https://github.com/LoLab-VU/Gleipnir/issues\" rel=\"nofollow\">GitHub Issue</a>.</p>\n<hr>\n<h1>PySB Utilities</h1>\n<h2>nestedsample_it</h2>\n<p>nestedsample_it is a utility that helps generate a Nested Sampling run script or NestedSampling objects for a PySB model.</p>\n<h3>Commmand line use</h3>\n<p>nestedsample_it can be used as a command line utility to generate a template Nested Sampling run script for a PySB model. nestedsample_it reads the model file, imports and pulls out all the kinetic parameters, and then writes out a run_NS script for that model. nestedsample_it currently writes out a run script for classic Nested Sampling via Gleipnir, so you'll need to modify it to use one of the other Nested Samplers (MultiNest, PolyChord, or DNest4). And you will need to edit the run script to load any data and modify the loglikelihood function, but nestedsample_it should give you a good starting point.</p>\n<p>Run nestedsample_it from the command line with following format:</p>\n<pre><code>python -m glepnir.pysb_utilities.nestedsample_it model.py output_path\n</code></pre>\n<p>where output_path is the directory/folder location where you want the generated script\nto be saved.</p>\n<p>The command line version of nestedsample_it also has support for a limited set of #NESTEDSAMPLE_IT directives which can be added to model files. The current directives are:</p>\n<ul>\n<li>#NESTEDSAMPLE_IT prior [param_name, param_index] [norm, uniform]\n<ul>\n<li>Specify the type of prior to assign to a parameter. The parameter can either be specified by its name or its index (in model.parameters). The priors that can be assigned are either norm or uniform; note that uniform is the default for all parameters.</li>\n</ul>\n</li>\n<li>#NESTEDSAMPLE_IT no-sample [param_name, param_index]\n<ul>\n<li>Specify a fixed parameter (i.e., not to included in sampling). The parameter can either be specified by its name or its index (in model.parameters).</li>\n</ul>\n</li>\n</ul>\n<h3>Progammatic use via the NestedSampleIt class</h3>\n<p>The nestedsample_it utility can be used progammatically via the NestedSampleIt\nclass. It's importable from the pysb_utilities module:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">gleipnir.pysb_utilities</span> <span class=\"kn\">import</span> <span class=\"n\">NestedSampleIt</span>\n</pre>\n<p>The NestedSampleIt class can build an instance of a NestedSampling object.<br>\nHere's a faux minimal example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">my_pysb_model</span> <span class=\"kn\">import</span> <span class=\"n\">model</span> <span class=\"k\">as</span> <span class=\"n\">my_model</span>\n<span class=\"kn\">from</span> <span class=\"nn\">gleipnir.pysb_utilities</span> <span class=\"kn\">import</span> <span class=\"n\">NestedSampleIt</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">timespan</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">10.</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'my_data.npy'</span><span class=\"p\">)</span>\n<span class=\"n\">data_sd</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'my_data_sd.npy'</span><span class=\"p\">)</span>\n<span class=\"n\">observable_data</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">()</span>\n<span class=\"n\">time_idxs</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">timespan</span><span class=\"p\">)))</span>\n<span class=\"n\">observable_data</span><span class=\"p\">[</span><span class=\"s1\">'my_observable'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">data_sd</span><span class=\"p\">,</span> <span class=\"n\">time_idxs</span><span class=\"p\">)</span>\n<span class=\"c1\"># Initialize the NestedSampleIt instance with the model details.</span>\n<span class=\"n\">sample_it</span> <span class=\"o\">=</span> <span class=\"n\">NestedSampleIt</span><span class=\"p\">(</span><span class=\"n\">my_model</span><span class=\"p\">,</span> <span class=\"n\">observable_data</span><span class=\"p\">,</span> <span class=\"n\">timespan</span><span class=\"p\">)</span>\n<span class=\"c1\"># Now build the NestedSampling object. -- All inputs are</span>\n<span class=\"c1\"># optional keyword arguments.</span>\n<span class=\"n\">nested_sampler</span> <span class=\"o\">=</span> <span class=\"n\">sample_it</span><span class=\"p\">(</span><span class=\"n\">ns_version</span><span class=\"o\">=</span><span class=\"s1\">'gleipnir-classic'</span><span class=\"p\">,</span>\n                           <span class=\"n\">ns_population_size</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span>\n                           <span class=\"n\">ns_kwargs</span><span class=\"o\">=</span><span class=\"nb\">dict</span><span class=\"p\">(),</span>\n                           <span class=\"n\">log_likelihood_type</span><span class=\"o\">=</span><span class=\"s1\">'logpdf'</span><span class=\"p\">)</span>\n<span class=\"c1\"># Then you can run the nested sampler.</span>\n<span class=\"n\">log_evidence</span><span class=\"p\">,</span> <span class=\"n\">log_evidence_error</span> <span class=\"o\">=</span> <span class=\"n\">nested_sampler</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<p>NestedSampleIt constructs the NestedSampling object to sample all of a model's kinetic rate parameters. It assumes that the priors are uniform with size 4 orders of magnitude and centered on the values defined in the model.</p>\n<p>In addition, NestedSampleIt crrently has three pre-defined loglikelihood functions with different estimators. They can be specified with the keyword parameter log_likelihood_type:</p>\n<pre><span class=\"c1\"># Now build the NestedSampling object.</span>\n<span class=\"n\">nested_sampler</span> <span class=\"o\">=</span> <span class=\"n\">sample_it</span><span class=\"p\">(</span><span class=\"n\">log_likelihood_type</span><span class=\"o\">=</span><span class=\"s1\">'logpdf'</span><span class=\"p\">)</span>\n</pre>\n<p>The options are</p>\n<ul>\n<li>'logpdf'=&gt;Compute the loglikelihood using the\nnormal distribution estimator</li>\n<li>'mse'=&gt;Compute the loglikelihood using the\nnegative mean squared error estimator</li>\n<li>'sse'=&gt;Compute the loglikelihood using\nthe negative sum of squared errors estimator.\nThe default is 'logpdf'.\nEach of these functions computes the loglikelihood estimate using the timecourse output of a model simulation for each observable defined in the <code>observable_data</code> dictionary.\nIf you want to use a different or more complicated likelihood function with NestedSampleIt then you'll need to subclass it and override one of the existing loglikelihood functions.</li>\n</ul>\n<h4>NestIt</h4>\n<p>The nestedsample_it module has a built-in helper class, NestIt, which can be used in conjunction of with NestedSampleIt class. NestIt can be used at the level of PySB model definition to log which parameters to include in\na Nested Sampling run. It can be imported from the pysb_utilities module:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">gleipnir.pysb_utilities</span> <span class=\"kn\">import</span> <span class=\"n\">NestIt</span>\n</pre>\n<p>It is passed at instantiation to the NestedSampleIt class, which uses it\nto build the sampled parameters list and parameter mask for the likelihood\nfunction.\nSee the following example files:</p>\n<ul>\n<li><a href=\"./examples/pysb_dimerization_model/dimerization_model_nestit.py\" rel=\"nofollow\">dimerization_model_nestit</a> - example model definition using NestIt to flag parameters.</li>\n<li><a href=\"./examples/pysb_dimerization_model/run_NS_NestedSampleIt_NestIt_dimerization_model.py\" rel=\"nofollow\">run_NS_NestedSampleIt_NestIt_dimerization_model</a> - example use of NestIt with NestedSampleIt.</li>\n</ul>\n<p>Note that if you flag a parameter for sampling without setting a prior, NestIt will by default assign the parameter a uniform prior centered on the parameter's value with a width of 4 orders of magnitude.</p>\n<h4>Builder class from pysb.builder</h4>\n<p>The Builder class from pysb.builder can also be used in conjunction with the NestedSampleIt class. The Builder class itself is a wrapper class that can be used to construct a PySB model and set parameter priors, logging them for sampling. Although\nthis feature was originally intended for use with the BayesSB package, the NestedSampleIt class supports it as a logger for sampled parameters.\nThe instance of the Builder is passed at instantiation to the NestedSampleIt class, which uses it to build the sampled parameters list and parameter mask for the likelihood function.\nSee the following example files:</p>\n<ul>\n<li><a href=\"./examples/pysb_dimerization_model/dimerization_model_builder.py\" rel=\"nofollow\">dimerization_model_builder</a> - example model definition using Builder to construct a PySB model and flag parameters for sampling.</li>\n<li><a href=\"./examples/pysb_dimerization_model/run_NS_NestedSampleIt_Builder_dimerization_model.py\" rel=\"nofollow\">run_NS_NestedSampleIt_Builder_dimerization_model</a> - example use of Builder with NestedSampleIt.</li>\n</ul>\n<p>Note that you have to explicitly set a prior for each parameter that you want to sample when you add it your model with the builder.parameter function. If no\nprior is given the parameter won't be included as a sampled parameter in the Nested Sampling run.</p>\n<h2>HypSelector</h2>\n<p>HypSelector is a tool for hypothesis selection using <a href=\"https://github.com/LoLab-VU/HypBuilder\" rel=\"nofollow\">HypBuilder</a> and Nested Sampling-based model selection. Models embodying different hypotheses (e.g., optional reactions) can be defined using the HypBuilder csv syntax. HypSelector then allows users to easily compare all the hypothetical model variants generated by HypBuilder by performing Nested Sampling to compute their evidences and thereby do model selection; HypSelector also provides functionality to estimate Bayes factors from the evidence estimates, as well as estimators for the Akaike, Bayesian, and Deviance information criteria computed from the Nested Sampling outputs. See the <a href=\"./examples/HypSelector/grouped_reactions\" rel=\"nofollow\">grouped reactions example</a> or the <a href=\"./jupyter_notebooks/HypSelector_example.ipynb\" rel=\"nofollow\">HypSelector Example Jupyter Notebook</a> to see example usage of HypSelector.</p>\n<h2>ModelSelector</h2>\n<p>Similar to HypSelector, ModelSelector is a tool for PySB model selection using Nested Sampling-based model selection. ModelSelector allows users to easily compare model variants written in PySB and see which one may best explain a dataset by performing Nested Sampling to compute their evidences and thereby do model selection; ModelSelector also provides functionality to estimate Bayes factors from the evidence estimates, as well as estimators for the Akaike, Bayesian, and Deviance information criteria computed from the Nested Sampling outputs. See the <a href=\"./jupyter_notebooks/ModelSelector_example.ipynb\" rel=\"nofollow\">ModelSelector Example Jupyter Notebook</a> to see example usage of ModelSelector.</p>\n<hr>\n<h1>Citing</h1>\n<p>If you use the Gleipnir software in your research, please cite it. You can export the  Gleipnir citation in your preferred format from its <a href=\"http://doi.org/10.5281/zenodo.3036345\" rel=\"nofollow\">Zenodo DOI</a> entry.</p>\n<p>Also, please cite the following references as appropriate for software used with/via Gleipnir:</p>\n<h4>Packages from the SciPy ecosystem</h4>\n<p>These include NumPy, SciPy, Pandas, and Matplotlib for which references can be obtained from:\n<a href=\"https://www.scipy.org/citing.html\" rel=\"nofollow\">https://www.scipy.org/citing.html</a></p>\n<h4>PySB</h4>\n<ol>\n<li>Lopez, C. F., Muhlich, J. L., Bachman, J. A. &amp; Sorger, P. K. Programming biological models in Python using PySB. Mol Syst Biol 9, (2013). doi:<a href=\"dx.doi.org/10.1038/msb.2013.1\" rel=\"nofollow\">10.1038/msb.2013.1</a></li>\n</ol>\n<h4>MultiNest</h4>\n<ol>\n<li>Feroz, Farhan, and M. P. Hobson. \"Multimodal nested sampling: an\nefficient and robust alternative to Markov Chain Monte Carlo\nmethods for astronomical data analyses.\" Monthly Notices of the\nRoyal Astronomical Society 384.2 (2008): 449-463.</li>\n<li>Feroz, F., M. P. Hobson, and M. Bridges. \"MultiNest: an efficient\nand robust Bayesian inference tool for cosmology and particle\nphysics.\" Monthly Notices of the Royal Astronomical Society 398.4\n(2009): 1601-1614.</li>\n<li>Feroz, F., et al. \"Importance nested sampling and the MultiNest\nalgorithm.\" arXiv preprint arXiv:1306.2144 (2013).</li>\n</ol>\n<h4>PyMultiNest:</h4>\n<ol>\n<li>Buchner, J., et al. \"X-ray spectral modelling of the AGN obscuring region in the CDFS: Bayesian model selection and catalogue.\" Astronomy &amp; Astrophysics 564 (2014): A125.</li>\n</ol>\n<h4>PolyChord</h4>\n<ol>\n<li>Handley, W. J., M. P. Hobson, and A. N. Lasenby. \"PolyChord: nested sampling for cosmology.\" Monthly Notices of the Royal Astronomical Society: Letters 450.1 (2015): L61-L65.</li>\n<li>Handley, W. J., M. P. Hobson, and A. N. Lasenby. \"POLYCHORD:\nnext-generation nested sampling.\" Monthly Notices of the Royal\nAstronomical Society 453.4 (2015): 4384-4398.</li>\n</ol>\n<h4>DNest4</h4>\n<ol>\n<li>Brewer, B. J., P\u00e1rtay, L. B., &amp; Cs\u00e1nyi, G. (2011). Diffusive nested\nsampling. Statistics and Computing, 21(4), 649-656</li>\n<li>Brewer, B., &amp; Foreman-Mackey, D. (2018). DNest4: Diffusive Nested Sampling in C++ and Python. Journal of Statistical Software, 86(7), 1 - 33. doi:<a href=\"http://dx.doi.org/10.18637/jss.v086.i07\" rel=\"nofollow\">10.18637/jss.v086.i07</a></li>\n</ol>\n<h4>Nestle</h4>\n<p>Cite the GitHub repo: <a href=\"https://github.com/kbarbary/nestle\" rel=\"nofollow\">https://github.com/kbarbary/nestle</a></p>\n<h4>seaborn</h4>\n<p>Reference can be exported from the <a href=\"https://doi.org/10.5281/zenodo.592845\" rel=\"nofollow\">seaborn Zeondo DOI entry</a></p>\n\n          </div>"}, "last_serial": 5590860, "releases": {"0.25.0": [{"comment_text": "", "digests": {"md5": "bb3e4cb6daeb0b00ffae63c22f14eb4d", "sha256": "52461411ac6942f0592db60e1f0b4aa0c1218045e9ad1877b14ce095e5de1cae"}, "downloads": -1, "filename": "gleipnir_ns-0.25.0-py3.6.egg", "has_sig": false, "md5_digest": "bb3e4cb6daeb0b00ffae63c22f14eb4d", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": ">=3.6", "size": 116231, "upload_time": "2019-07-26T21:30:38", "upload_time_iso_8601": "2019-07-26T21:30:38.212324Z", "url": "https://files.pythonhosted.org/packages/bb/31/0d1de6db9c55477cf432bcc40c2a213005baa41b6ad3ac2e053e6ebfd73d/gleipnir_ns-0.25.0-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "1aac60a83bf8faa75bb4163d44b4f8ee", "sha256": "bf281186700667dbd6a8d1f4bca739f74b7b493ed49b9ade3d84faebc23b0266"}, "downloads": -1, "filename": "gleipnir_ns-0.25.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1aac60a83bf8faa75bb4163d44b4f8ee", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 55955, "upload_time": "2019-07-26T21:30:35", "upload_time_iso_8601": "2019-07-26T21:30:35.478381Z", "url": "https://files.pythonhosted.org/packages/b1/ee/255908157b77b4e2770649477f81001fe9284aaa3a47d8cfad3ef1e8519c/gleipnir_ns-0.25.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1a2647ca5baf8a697f2f0f1896ef445f", "sha256": "4e1dfa0bd28b2718aa609b1ce4fc6791e719955cb9aa2cb9426fba578be3918d"}, "downloads": -1, "filename": "gleipnir-ns-0.25.0.tar.gz", "has_sig": false, "md5_digest": "1a2647ca5baf8a697f2f0f1896ef445f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 36659, "upload_time": "2019-07-26T21:30:40", "upload_time_iso_8601": "2019-07-26T21:30:40.411780Z", "url": "https://files.pythonhosted.org/packages/4a/18/a389337224f59d4007997a6fdf678741d381974220760396b5adb45a8a4f/gleipnir-ns-0.25.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bb3e4cb6daeb0b00ffae63c22f14eb4d", "sha256": "52461411ac6942f0592db60e1f0b4aa0c1218045e9ad1877b14ce095e5de1cae"}, "downloads": -1, "filename": "gleipnir_ns-0.25.0-py3.6.egg", "has_sig": false, "md5_digest": "bb3e4cb6daeb0b00ffae63c22f14eb4d", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": ">=3.6", "size": 116231, "upload_time": "2019-07-26T21:30:38", "upload_time_iso_8601": "2019-07-26T21:30:38.212324Z", "url": "https://files.pythonhosted.org/packages/bb/31/0d1de6db9c55477cf432bcc40c2a213005baa41b6ad3ac2e053e6ebfd73d/gleipnir_ns-0.25.0-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "1aac60a83bf8faa75bb4163d44b4f8ee", "sha256": "bf281186700667dbd6a8d1f4bca739f74b7b493ed49b9ade3d84faebc23b0266"}, "downloads": -1, "filename": "gleipnir_ns-0.25.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1aac60a83bf8faa75bb4163d44b4f8ee", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 55955, "upload_time": "2019-07-26T21:30:35", "upload_time_iso_8601": "2019-07-26T21:30:35.478381Z", "url": "https://files.pythonhosted.org/packages/b1/ee/255908157b77b4e2770649477f81001fe9284aaa3a47d8cfad3ef1e8519c/gleipnir_ns-0.25.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1a2647ca5baf8a697f2f0f1896ef445f", "sha256": "4e1dfa0bd28b2718aa609b1ce4fc6791e719955cb9aa2cb9426fba578be3918d"}, "downloads": -1, "filename": "gleipnir-ns-0.25.0.tar.gz", "has_sig": false, "md5_digest": "1a2647ca5baf8a697f2f0f1896ef445f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 36659, "upload_time": "2019-07-26T21:30:40", "upload_time_iso_8601": "2019-07-26T21:30:40.411780Z", "url": "https://files.pythonhosted.org/packages/4a/18/a389337224f59d4007997a6fdf678741d381974220760396b5adb45a8a4f/gleipnir-ns-0.25.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:37 2020"}