{"info": {"author": "Michael Hansen", "author_email": "hansen.mike@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "# Rhasspy Natural Language Understanding\n\n[![Continous Integration](https://github.com/rhasspy/rhasspy-nlu/workflows/Tests/badge.svg)](https://github.com/rhasspy/rhasspy-nlu/actions)\n[![PyPI package version](https://img.shields.io/pypi/v/rhasspy-nlu.svg)](https://pypi.org/project/rhasspy-nlu)\n[![Python versions](https://img.shields.io/pypi/pyversions/rhasspy-nlu.svg)](https://www.python.org)\n[![GitHub license](https://img.shields.io/github/license/rhasspy/rhasspy-nlu.svg)](https://github.com/rhasspy/rhasspy-nlu/blob/master/LICENSE)\n\nLibrary for parsing Rhasspy sentence templates, doing intent recognition, and generating ARPA language models.\n\n## Parsing Sentence Templates\n\nRhasspy voice commands are stored in text files formatted like this:\n\n```ini\n[Intent1]\nthis is a sentence\nthis is another sentence\n\n[Intent2]\na sentence in a different intent\n```\n\nYou can parse these into a structured representation with `rhasspynlu.parse_ini` and then convert them to a graph using `rhasspynlu.intents_to_graph`:\n\n```python\nimport rhasspynlu\n\n# Load and parse\nintents = rhasspynlu.parse_ini(\n\"\"\"\n[LightOn]\nturn on [the] (living room lamp | kitchen light){name}\n\"\"\"\n)\n\ngraph = rhasspynlu.intents_to_graph(intents)\n```\n\nThe result is a [directed graph](https://networx.github.io/documentation/networkx-2.3/reference/classes/digraph.html) whose states are words and edges are input/output labels.\n\nYou can pass an `intent_filter` function to `parse_ini` to return `True` for only the intent names you want to parse.\nAdditionally, a function can be provided for the `sentence_transform` argument that each sentence will be passed through (e.g., to lower case).\n\n### Template Syntax\n\nSentence templates are based on the [JSGF](https://www.w3.org/TR/jsgf/) standard. The following constructs are available:\n\n* Optional words\n    * `this is [a] test` - the word \"a\" may or may not be present\n* Alternatives\n    * `set color to (red | green | blue)` - either \"red\", \"green\", or \"blue\" is possible\n* Tags\n    * `turn on the [den | playroom]{location} light` - named entity `location` will be either \"den\" or \"playroom\"\n* Substitutions\n    * `make ten:10 coffees` - output will be \"make 10 coffees\"\n    * `turn off the: (television | tele):tv` - output will be \"turn off tv\"\n    * `set brightness to (medium | half){brightness:50}` - named entity `brightness` will be \"50\"\n* Rules\n    * `rule_name = rule body` can be referenced as `<rule_name>`\n* Slots\n    * `$slot` will be replaced by a list of sentences in the `replacements` argument of `intents_to_graph`\n\n#### Rules\n\nNamed rules can be added to your template file using the syntax:\n\n```ini\nrule_name = rule body\n```\n\nand then reference using `<rule_name>`. The body of a rule is a regular sentence, which may itself contain references to other rules.\n\nYou can refrence rules from different intents by prefixing the rule name with the intent name and a dot:\n\n```ini\n[Intent1]\nrule = a test\nthis is <rule>\n\n[Intent2]\nrule = this is\n<rule> <Intent1.rule>\n```\n\nIn the example above, `Intent2` uses its local `<rule>` as well as the `<rule>` from `Intent1`.\n\n#### Slots\n\nSlot names are prefixed with a dollar sign (`$`). When calling `intents_to_graph`, the `replacements` argument is a dictionary whose keys are slot names (with `$`) and whose values are lists of (parsed) `Sentence` objects. Each `$slot` will be replaced by the corresponding list of sentences, which may contain optional words, tags, rules, and other slots.\n\nFor example:\n\n```python\nimport rhasspynlu\n\n# Load and parse\nintents = rhasspynlu.parse_ini(\n\"\"\"\n[SetColor]\nset color to $color\n\"\"\"\n)\n\ngraph = rhasspynlu.intents_to_graph(\n    intents, replacements = {\n        \"$color\": [rhasspynlu.Sentence.parse(\"red | green | blue\")]\n    }\n)\n```\n\nwill replace `$color` with \"red\", \"green\", or \"blue\".\n\n## Intent Recognition\n\nAfter converting your sentence templates to a graph, you can recognize sentences. Assuming you have a `.ini` file like this:\n\n```\n[LightOn]\nturn on [the] (living room lamp | kitchen light){name}\n```\n\nYou can recognize sentences with:\n\n```python\nfrom pathlib import Path\nimport rhasspynlu\n\n# Load and parse\nintents = rhasspynlu.parse_ini(Path(\"sentences.ini\"))\ngraph = rhasspynlu.intents_to_graph(intents)\n\nrhasspynlu.recognize(\"turn on living room lamp\", graph)\n```\n\nwill return a list of `Recognition` objects like:\n\n```\n[\n    Recognition(\n        intent=Intent(name='LightOn', confidence=1.0),\n        entities=[\n            Entity(\n                entity='name',\n                value='living room lamp',\n                raw_value='living room lamp',\n                start=8,\n                raw_start=8,\n                end=24,\n                raw_end=24,\n                tokens=['living', 'room', 'lamp'],\n                raw_tokens=['living', 'room', 'lamp']\n            )\n        ],\n        text='turn on living room lamp',\n        raw_text='turn on living room lamp',\n        recognize_seconds=0.00010710899914556649,\n        tokens=['turn', 'on', 'living', 'room', 'lamp'],\n        raw_tokens=['turn', 'on', 'living', 'room', 'lamp']\n    )\n]\n\n```\n\nAn empty list means that recognition has failed. You can easily convert `Recognition` objects to JSON:\n\n```python\n...\n\nimport json\n\nrecognitions = rhasspynlu.recognize(\"turn on living room lamp\", graph)\nif recognitions:\n    recognition_dict = recognitions[0].asdict()\n    print(json.dumps(recognition_dict))\n```\n\nYou can also pass an `intent_filter` function to `recognize` to return `True` only for intent names you want to include in the search.\n\n#### Tokens\n\nIf your sentence is tokenized by something other than whitespace, pass the list of tokens into `recognize` instead of a string.\n\n#### Recognition Fields\n\nThe `rhasspynlu.Recognition` object has the following fields:\n\n* `intent` - a `rhasspynlu.Intent` instance\n    * `name` - name of recognized intent\n    * `confidence` - number for 0-1, 1 being sure\n* `text` - substituted input text\n* `raw_text` - input text\n* `entities` - list of `rhasspynlu.Entity` objects\n    * `entity` - name of recognized entity (\"name\" in `(input:output){name}`)\n    * `value` - substituted value of recognized entity (\"output\" in `(input:output){name}`)\n    * `tokens` - list of words in `value`\n    * `start` - start index of `value` in `text`\n    * `end` - end index of `value` in `text` (exclusive)\n    * `raw_value` - value of recognized entity (\"input\" in `(input:output){name}`)\n    * `raw_tokens` - list of words in `raw_value`\n    * `raw_start` - start index of `raw_value` in `raw_text`\n    * `raw_end` - end index of `raw_value` in `raw_text` (exclusive)\n* `recognize_seconds` - seconds taken for `recognize`\n\n### Stop Words\n\nYou can pass a set of `stop_words` to `recognize`:\n\n```python\nrhasspynlu.recognize(\"turn on that living room lamp\", graph, stop_words=set([\"that\"]))\n```\n\nStop words in the input sentence will be skipped over if they don't match the graph.\n\n### Strict Recognition\n\nFor faster, but less flexible recognition, set `fuzzy` to `False`:\n\n```python\nrhasspynlu.recognize(\"turn on the living room lamp\", graph, fuzzy=False)\n```\n\nThis is at least twice as fast, but will fail if the sentence is not precisely present in the graph.\n\nStrict recognition also supports `stop_words` for a little added flexibility. If recognition without `stop_words` fails, a second attempt will be made using `stop_words`.\n\n### Converters\n\nValue conversions can be applied during recognition, such as converting the string \"10\" to the integer 10. Following a word, sequence, or tag name with \"!converter\" will run \"converter\" on the string value during `recognize`:\n\n```python\nimport rhasspynlu\n\n# Load and parse\nintents = rhasspynlu.parse_ini(\n\"\"\"\n[SetBrightness]\nset brightness to (one: hundred:100)!int\n\"\"\"\n)\n\ngraph = rhasspynlu.intents_to_graph(intents)\n\nrecognitions = rhasspynlu.recognize(\"set brightness to one hundred\", graph)\nassert recognitions[0].tokens[-1] == 100\n```\n\nConverters can be applied to tags/entities as well:\n\n```python\nimport rhasspynlu\n\n# Load and parse\nintents = rhasspynlu.parse_ini(\n\"\"\"\n[SetBrightness]\nset brightness to (one:1 | two:2){value!int}\n\"\"\"\n)\n\ngraph = rhasspynlu.intents_to_graph(intents)\n\nrecognitions = rhasspynlu.recognize(\"set brightness to two\", graph)\nassert recognitions[0].tokens[-1] == 2\n```\n\nThe following default converters are available in `rhasspynlu`:\n\n* int - convert to integer\n* float - convert to real\n* bool - convert to boolean\n* lower - lower-case\n* upper - upper-case\n\nYou may override these converters by passing a dictionary to the `converters` argument of `recognize`. To supply additional converters (instead of overriding), use `extra_converters`:\n\n```python\nimport rhasspynlu\n\n# Load and parse\nintents = rhasspynlu.parse_ini(\n\"\"\"\n[SetBrightness]\nset brightness to (one:1 | two:2){value!myconverter}\n\"\"\"\n)\n\ngraph = rhasspynlu.intents_to_graph(intents)\n\nrecognitions = rhasspynlu.recognize(\n    \"set brightness to two\",\n    graph,\n    extra_converters={\n        \"myconverter\": lambda *values: [int(v)**2 for v in values]\n    }\n)\nassert recognitions[0].tokens[-1] == 4\n```\n\nLastly, you can chain converters together with multiple \"!\":\n\n```python\nimport rhasspynlu\n\n# Load and parse\nintents = rhasspynlu.parse_ini(\n\"\"\"\n[SetBrightness]\nset brightness to (one:1 | two:2){value!int!cube}\n\"\"\"\n)\n\ngraph = rhasspynlu.intents_to_graph(intents)\n\nrecognitions = rhasspynlu.recognize(\n    \"set brightness to two\",\n    graph,\n    extra_converters={\n        \"cube\": lambda *values: [v**3 for v in values]\n    }\n)\nassert recognitions[0].tokens[-1] == 8\n```\n\n## ARPA Language Models\n\nYou can compute [ngram counts](https://en.wikipedia.org/wiki/N-gram) from a `rhasspynlu` graph, useful for generating [ARPA language models](https://cmusphinx.github.io/wiki/arpaformat/). These models can be used by speech recognition systems, such as [Pocketsphinx](https://github.com/cmusphinx/pocketsphinx), [Kaldi](https://kaldi-asr.org), and [Julius](https://github.com/julius-speech/julius).\n\n```python\nimport rhasspynlu\n\n# Load and parse\nintents = rhasspynlu.parse_ini(\n\"\"\"\n[SetColor]\nset light to (red | green | blue)\n\"\"\"\n)\n\ngraph = rhasspynlu.intents_to_graph(intents)\ncounts = rhasspynlu.get_intent_ngram_counts(\n    graph,\n    pad_start=\"<s>\",\n    pad_end=\"</s>\",\n    order=3\n)\n\n# Print counts by intent\nfor intent_name in counts:\n    print(intent_name)\n    for ngram, count in counts[intent_name].items():\n        print(ngram, count)\n        \n    print(\"\")\n```\n\nwill print something like:\n\n```\nSetColor\n('<s>',) 3\n('set',) 3\n('<s>', 'set') 3\n('light',) 3\n('set', 'light') 3\n('<s>', 'set', 'light') 3\n('to',) 3\n('light', 'to') 3\n('set', 'light', 'to') 3\n('red',) 1\n('to', 'red') 1\n('light', 'to', 'red') 1\n('green',) 1\n('to', 'green') 1\n('light', 'to', 'green') 1\n('blue',) 1\n('to', 'blue') 1\n('light', 'to', 'blue') 1\n('</s>',) 3\n('red', '</s>') 1\n('green', '</s>') 1\n('blue', '</s>') 1\n('to', 'red', '</s>') 1\n('to', 'green', '</s>') 1\n('to', 'blue', '</s>') 1\n\n```\n\n### Opengrm\n\nIf you have the [Opengrm](http://www.opengrm.org/twiki/bin/view/GRM/NGramLibrary) command-line tools in your `PATH`, you can use `rhasspynlu` to generate language models in the [ARPA format](https://cmusphinx.github.io/wiki/arpaformat/). \n\nThe `graph_to_fst` and `fst_to_arpa` functions are used to convert between formats. Calling `fst_to_arpa` requires the following binaries to be present in your `PATH`:\n\n* `fstcompile` (from [OpenFST](http://www.openfst.org))\n* `ngramcount`\n* `ngrammake`\n* `ngrammerge`\n* `ngramprint`\n* `ngramread`\n\nExample:\n\n```python\n# Convert to FST\ngraph_fst = rhasspynlu.graph_to_fst(graph)\n\n# Write FST and symbol text files\ngraph_fst.write(\"my_fst.txt\", \"input_symbols.txt\", \"output_symbols.txt\")\n\n# Compile and convert to ARPA language model\nrhasspynlu.fst_to_arpa(\n    \"my_fst.txt\",\n    \"input_symbols.txt\",\n    \"output_symbols.txt\",\n    \"my_arpa.lm\"\n)\n```\n\nYou can now use `my_arpa.lm` in any speech recognizer that accepts ARPA-formatted language models.\n\n### Language Model Mixing\n\nIf you have an existing language model that you'd like to mix with Rhasspy voice commands, you will first need to convert it to an FST:\n\n```python\nrhasspynlu.fst_to_arpa(\"existing_arpa.lm\", \"existing_arpa.fst\")\n```\n\nNow when you call `fst_to_arpa`, make sure to provide the `base_fst_weight` argument. This is a tuple with the path to your existing ARPA FST and a mixture weight between 0 and 1. A weight of 0.05 means that the base language model will receive 5% of the overall probability mass in the language model. The rest of the mass will be given to your custom voice commands.\n\nExample:\n\n```python\nrhasspynlu.fst_to_arpa(\n    \"my_fst.txt\",\n    \"input_symbols.txt\",\n    \"output_symbols.txt\",\n    \"my_arpa.lm\",\n    base_fst_weight=(\"existing_arpa.fst\", 0.05)\n)\n```\n\n## Command Line Usage\n\nThe `rhasspynlu` module can be run directly to convert `sentences.ini` files into JSON graphs or FST text files:\n\n```bash\npython3 -m rhasspynlu sentences.ini > graph.json\n```\n\nYou can pass multiple `.ini` files as arguments, and they will be combined. Adding a `--fst` argument will write out FST text files instead:\n\n```\npython3 -m rhasspynlu sentences.ini --fst\n```\n\nThis will output three files in the current directory:\n\n* `fst.txt` - finite state transducer as text\n* `fst.isymbols.txt` - input symbols\n* `fst.osymbols.txt` - output symbols\n\nThese file names can be changed with the `--fst-text`, `--fst-isymbols`, and `--fst-osymbols` arguments, respectively.\n\nCompile to a binary FST using `fstcompile` (from [OpenFST](http://www.openfst.org)) with:\n\n```bash\nfstcompile \\\n    --isymbols=fst.isymbols.txt \\\n    --osymbols=fst.osymbols.txt \\\n    --keep_isymbols=1 \\\n    --keep_osymbols=1 \\\n    fst.txt \\\n    out.fst\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/rhasspy/rhasspy-nlu", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "rhasspy-nlu", "package_url": "https://pypi.org/project/rhasspy-nlu/", "platform": "", "project_url": "https://pypi.org/project/rhasspy-nlu/", "project_urls": {"Homepage": "https://github.com/rhasspy/rhasspy-nlu"}, "release_url": "https://pypi.org/project/rhasspy-nlu/0.1.8/", "requires_dist": null, "requires_python": ">=3.6", "summary": "", "version": "0.1.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Rhasspy Natural Language Understanding</h1>\n<p><a href=\"https://github.com/rhasspy/rhasspy-nlu/actions\" rel=\"nofollow\"><img alt=\"Continous Integration\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a446fd78f3ffc14fb88da96596f66315ba863d09/68747470733a2f2f6769746875622e636f6d2f726861737370792f726861737370792d6e6c752f776f726b666c6f77732f54657374732f62616467652e737667\"></a>\n<a href=\"https://pypi.org/project/rhasspy-nlu\" rel=\"nofollow\"><img alt=\"PyPI package version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8ac3229e1fda971d2779ded50585073341188273/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f726861737370792d6e6c752e737667\"></a>\n<a href=\"https://www.python.org\" rel=\"nofollow\"><img alt=\"Python versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8bb04ca644d6293b2245cc2b7b4eeb307cac85ef/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f726861737370792d6e6c752e737667\"></a>\n<a href=\"https://github.com/rhasspy/rhasspy-nlu/blob/master/LICENSE\" rel=\"nofollow\"><img alt=\"GitHub license\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a8be0e587cfd550e22f70b8adf8c4ffb5cd5c1d8/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f726861737370792f726861737370792d6e6c752e737667\"></a></p>\n<p>Library for parsing Rhasspy sentence templates, doing intent recognition, and generating ARPA language models.</p>\n<h2>Parsing Sentence Templates</h2>\n<p>Rhasspy voice commands are stored in text files formatted like this:</p>\n<pre><span class=\"k\">[Intent1]</span>\n<span class=\"na\">this is a sentence</span>\n<span class=\"na\">this is another sentence</span>\n\n<span class=\"k\">[Intent2]</span>\n<span class=\"na\">a sentence in a different intent</span>\n</pre>\n<p>You can parse these into a structured representation with <code>rhasspynlu.parse_ini</code> and then convert them to a graph using <code>rhasspynlu.intents_to_graph</code>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rhasspynlu</span>\n\n<span class=\"c1\"># Load and parse</span>\n<span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">parse_ini</span><span class=\"p\">(</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">[LightOn]</span>\n<span class=\"sd\">turn on [the] (living room lamp | kitchen light){name}</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">intents_to_graph</span><span class=\"p\">(</span><span class=\"n\">intents</span><span class=\"p\">)</span>\n</pre>\n<p>The result is a <a href=\"https://networx.github.io/documentation/networkx-2.3/reference/classes/digraph.html\" rel=\"nofollow\">directed graph</a> whose states are words and edges are input/output labels.</p>\n<p>You can pass an <code>intent_filter</code> function to <code>parse_ini</code> to return <code>True</code> for only the intent names you want to parse.\nAdditionally, a function can be provided for the <code>sentence_transform</code> argument that each sentence will be passed through (e.g., to lower case).</p>\n<h3>Template Syntax</h3>\n<p>Sentence templates are based on the <a href=\"https://www.w3.org/TR/jsgf/\" rel=\"nofollow\">JSGF</a> standard. The following constructs are available:</p>\n<ul>\n<li>Optional words\n<ul>\n<li><code>this is [a] test</code> - the word \"a\" may or may not be present</li>\n</ul>\n</li>\n<li>Alternatives\n<ul>\n<li><code>set color to (red | green | blue)</code> - either \"red\", \"green\", or \"blue\" is possible</li>\n</ul>\n</li>\n<li>Tags\n<ul>\n<li><code>turn on the [den | playroom]{location} light</code> - named entity <code>location</code> will be either \"den\" or \"playroom\"</li>\n</ul>\n</li>\n<li>Substitutions\n<ul>\n<li><code>make ten:10 coffees</code> - output will be \"make 10 coffees\"</li>\n<li><code>turn off the: (television | tele):tv</code> - output will be \"turn off tv\"</li>\n<li><code>set brightness to (medium | half){brightness:50}</code> - named entity <code>brightness</code> will be \"50\"</li>\n</ul>\n</li>\n<li>Rules\n<ul>\n<li><code>rule_name = rule body</code> can be referenced as <code>&lt;rule_name&gt;</code></li>\n</ul>\n</li>\n<li>Slots\n<ul>\n<li><code>$slot</code> will be replaced by a list of sentences in the <code>replacements</code> argument of <code>intents_to_graph</code></li>\n</ul>\n</li>\n</ul>\n<h4>Rules</h4>\n<p>Named rules can be added to your template file using the syntax:</p>\n<pre><span class=\"na\">rule_name</span> <span class=\"o\">=</span> <span class=\"s\">rule body</span>\n</pre>\n<p>and then reference using <code>&lt;rule_name&gt;</code>. The body of a rule is a regular sentence, which may itself contain references to other rules.</p>\n<p>You can refrence rules from different intents by prefixing the rule name with the intent name and a dot:</p>\n<pre><span class=\"k\">[Intent1]</span>\n<span class=\"na\">rule</span> <span class=\"o\">=</span> <span class=\"s\">a test</span>\n<span class=\"na\">this is &lt;rule&gt;</span>\n\n<span class=\"k\">[Intent2]</span>\n<span class=\"na\">rule</span> <span class=\"o\">=</span> <span class=\"s\">this is</span>\n<span class=\"na\">&lt;rule&gt; &lt;Intent1.rule&gt;</span>\n</pre>\n<p>In the example above, <code>Intent2</code> uses its local <code>&lt;rule&gt;</code> as well as the <code>&lt;rule&gt;</code> from <code>Intent1</code>.</p>\n<h4>Slots</h4>\n<p>Slot names are prefixed with a dollar sign (<code>$</code>). When calling <code>intents_to_graph</code>, the <code>replacements</code> argument is a dictionary whose keys are slot names (with <code>$</code>) and whose values are lists of (parsed) <code>Sentence</code> objects. Each <code>$slot</code> will be replaced by the corresponding list of sentences, which may contain optional words, tags, rules, and other slots.</p>\n<p>For example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rhasspynlu</span>\n\n<span class=\"c1\"># Load and parse</span>\n<span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">parse_ini</span><span class=\"p\">(</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">[SetColor]</span>\n<span class=\"sd\">set color to $color</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">intents_to_graph</span><span class=\"p\">(</span>\n    <span class=\"n\">intents</span><span class=\"p\">,</span> <span class=\"n\">replacements</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"s2\">\"$color\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">Sentence</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"red | green | blue\"</span><span class=\"p\">)]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</pre>\n<p>will replace <code>$color</code> with \"red\", \"green\", or \"blue\".</p>\n<h2>Intent Recognition</h2>\n<p>After converting your sentence templates to a graph, you can recognize sentences. Assuming you have a <code>.ini</code> file like this:</p>\n<pre><code>[LightOn]\nturn on [the] (living room lamp | kitchen light){name}\n</code></pre>\n<p>You can recognize sentences with:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pathlib</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n<span class=\"kn\">import</span> <span class=\"nn\">rhasspynlu</span>\n\n<span class=\"c1\"># Load and parse</span>\n<span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">parse_ini</span><span class=\"p\">(</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"sentences.ini\"</span><span class=\"p\">))</span>\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">intents_to_graph</span><span class=\"p\">(</span><span class=\"n\">intents</span><span class=\"p\">)</span>\n\n<span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">recognize</span><span class=\"p\">(</span><span class=\"s2\">\"turn on living room lamp\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">)</span>\n</pre>\n<p>will return a list of <code>Recognition</code> objects like:</p>\n<pre><code>[\n    Recognition(\n        intent=Intent(name='LightOn', confidence=1.0),\n        entities=[\n            Entity(\n                entity='name',\n                value='living room lamp',\n                raw_value='living room lamp',\n                start=8,\n                raw_start=8,\n                end=24,\n                raw_end=24,\n                tokens=['living', 'room', 'lamp'],\n                raw_tokens=['living', 'room', 'lamp']\n            )\n        ],\n        text='turn on living room lamp',\n        raw_text='turn on living room lamp',\n        recognize_seconds=0.00010710899914556649,\n        tokens=['turn', 'on', 'living', 'room', 'lamp'],\n        raw_tokens=['turn', 'on', 'living', 'room', 'lamp']\n    )\n]\n\n</code></pre>\n<p>An empty list means that recognition has failed. You can easily convert <code>Recognition</code> objects to JSON:</p>\n<pre><span class=\"o\">...</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">json</span>\n\n<span class=\"n\">recognitions</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">recognize</span><span class=\"p\">(</span><span class=\"s2\">\"turn on living room lamp\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">recognitions</span><span class=\"p\">:</span>\n    <span class=\"n\">recognition_dict</span> <span class=\"o\">=</span> <span class=\"n\">recognitions</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">asdict</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">recognition_dict</span><span class=\"p\">))</span>\n</pre>\n<p>You can also pass an <code>intent_filter</code> function to <code>recognize</code> to return <code>True</code> only for intent names you want to include in the search.</p>\n<h4>Tokens</h4>\n<p>If your sentence is tokenized by something other than whitespace, pass the list of tokens into <code>recognize</code> instead of a string.</p>\n<h4>Recognition Fields</h4>\n<p>The <code>rhasspynlu.Recognition</code> object has the following fields:</p>\n<ul>\n<li><code>intent</code> - a <code>rhasspynlu.Intent</code> instance\n<ul>\n<li><code>name</code> - name of recognized intent</li>\n<li><code>confidence</code> - number for 0-1, 1 being sure</li>\n</ul>\n</li>\n<li><code>text</code> - substituted input text</li>\n<li><code>raw_text</code> - input text</li>\n<li><code>entities</code> - list of <code>rhasspynlu.Entity</code> objects\n<ul>\n<li><code>entity</code> - name of recognized entity (\"name\" in <code>(input:output){name}</code>)</li>\n<li><code>value</code> - substituted value of recognized entity (\"output\" in <code>(input:output){name}</code>)</li>\n<li><code>tokens</code> - list of words in <code>value</code></li>\n<li><code>start</code> - start index of <code>value</code> in <code>text</code></li>\n<li><code>end</code> - end index of <code>value</code> in <code>text</code> (exclusive)</li>\n<li><code>raw_value</code> - value of recognized entity (\"input\" in <code>(input:output){name}</code>)</li>\n<li><code>raw_tokens</code> - list of words in <code>raw_value</code></li>\n<li><code>raw_start</code> - start index of <code>raw_value</code> in <code>raw_text</code></li>\n<li><code>raw_end</code> - end index of <code>raw_value</code> in <code>raw_text</code> (exclusive)</li>\n</ul>\n</li>\n<li><code>recognize_seconds</code> - seconds taken for <code>recognize</code></li>\n</ul>\n<h3>Stop Words</h3>\n<p>You can pass a set of <code>stop_words</code> to <code>recognize</code>:</p>\n<pre><span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">recognize</span><span class=\"p\">(</span><span class=\"s2\">\"turn on that living room lamp\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">stop_words</span><span class=\"o\">=</span><span class=\"nb\">set</span><span class=\"p\">([</span><span class=\"s2\">\"that\"</span><span class=\"p\">]))</span>\n</pre>\n<p>Stop words in the input sentence will be skipped over if they don't match the graph.</p>\n<h3>Strict Recognition</h3>\n<p>For faster, but less flexible recognition, set <code>fuzzy</code> to <code>False</code>:</p>\n<pre><span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">recognize</span><span class=\"p\">(</span><span class=\"s2\">\"turn on the living room lamp\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">fuzzy</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>This is at least twice as fast, but will fail if the sentence is not precisely present in the graph.</p>\n<p>Strict recognition also supports <code>stop_words</code> for a little added flexibility. If recognition without <code>stop_words</code> fails, a second attempt will be made using <code>stop_words</code>.</p>\n<h3>Converters</h3>\n<p>Value conversions can be applied during recognition, such as converting the string \"10\" to the integer 10. Following a word, sequence, or tag name with \"!converter\" will run \"converter\" on the string value during <code>recognize</code>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rhasspynlu</span>\n\n<span class=\"c1\"># Load and parse</span>\n<span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">parse_ini</span><span class=\"p\">(</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">[SetBrightness]</span>\n<span class=\"sd\">set brightness to (one: hundred:100)!int</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">intents_to_graph</span><span class=\"p\">(</span><span class=\"n\">intents</span><span class=\"p\">)</span>\n\n<span class=\"n\">recognitions</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">recognize</span><span class=\"p\">(</span><span class=\"s2\">\"set brightness to one hundred\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">recognitions</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">tokens</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">100</span>\n</pre>\n<p>Converters can be applied to tags/entities as well:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rhasspynlu</span>\n\n<span class=\"c1\"># Load and parse</span>\n<span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">parse_ini</span><span class=\"p\">(</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">[SetBrightness]</span>\n<span class=\"sd\">set brightness to (one:1 | two:2){value!int}</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">intents_to_graph</span><span class=\"p\">(</span><span class=\"n\">intents</span><span class=\"p\">)</span>\n\n<span class=\"n\">recognitions</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">recognize</span><span class=\"p\">(</span><span class=\"s2\">\"set brightness to two\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">recognitions</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">tokens</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">2</span>\n</pre>\n<p>The following default converters are available in <code>rhasspynlu</code>:</p>\n<ul>\n<li>int - convert to integer</li>\n<li>float - convert to real</li>\n<li>bool - convert to boolean</li>\n<li>lower - lower-case</li>\n<li>upper - upper-case</li>\n</ul>\n<p>You may override these converters by passing a dictionary to the <code>converters</code> argument of <code>recognize</code>. To supply additional converters (instead of overriding), use <code>extra_converters</code>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rhasspynlu</span>\n\n<span class=\"c1\"># Load and parse</span>\n<span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">parse_ini</span><span class=\"p\">(</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">[SetBrightness]</span>\n<span class=\"sd\">set brightness to (one:1 | two:2){value!myconverter}</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">intents_to_graph</span><span class=\"p\">(</span><span class=\"n\">intents</span><span class=\"p\">)</span>\n\n<span class=\"n\">recognitions</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">recognize</span><span class=\"p\">(</span>\n    <span class=\"s2\">\"set brightness to two\"</span><span class=\"p\">,</span>\n    <span class=\"n\">graph</span><span class=\"p\">,</span>\n    <span class=\"n\">extra_converters</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s2\">\"myconverter\"</span><span class=\"p\">:</span> <span class=\"k\">lambda</span> <span class=\"o\">*</span><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">values</span><span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">recognitions</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">tokens</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">4</span>\n</pre>\n<p>Lastly, you can chain converters together with multiple \"!\":</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rhasspynlu</span>\n\n<span class=\"c1\"># Load and parse</span>\n<span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">parse_ini</span><span class=\"p\">(</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">[SetBrightness]</span>\n<span class=\"sd\">set brightness to (one:1 | two:2){value!int!cube}</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">intents_to_graph</span><span class=\"p\">(</span><span class=\"n\">intents</span><span class=\"p\">)</span>\n\n<span class=\"n\">recognitions</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">recognize</span><span class=\"p\">(</span>\n    <span class=\"s2\">\"set brightness to two\"</span><span class=\"p\">,</span>\n    <span class=\"n\">graph</span><span class=\"p\">,</span>\n    <span class=\"n\">extra_converters</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s2\">\"cube\"</span><span class=\"p\">:</span> <span class=\"k\">lambda</span> <span class=\"o\">*</span><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">v</span><span class=\"o\">**</span><span class=\"mi\">3</span> <span class=\"k\">for</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">values</span><span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">recognitions</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">tokens</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">8</span>\n</pre>\n<h2>ARPA Language Models</h2>\n<p>You can compute <a href=\"https://en.wikipedia.org/wiki/N-gram\" rel=\"nofollow\">ngram counts</a> from a <code>rhasspynlu</code> graph, useful for generating <a href=\"https://cmusphinx.github.io/wiki/arpaformat/\" rel=\"nofollow\">ARPA language models</a>. These models can be used by speech recognition systems, such as <a href=\"https://github.com/cmusphinx/pocketsphinx\" rel=\"nofollow\">Pocketsphinx</a>, <a href=\"https://kaldi-asr.org\" rel=\"nofollow\">Kaldi</a>, and <a href=\"https://github.com/julius-speech/julius\" rel=\"nofollow\">Julius</a>.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">rhasspynlu</span>\n\n<span class=\"c1\"># Load and parse</span>\n<span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">parse_ini</span><span class=\"p\">(</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">[SetColor]</span>\n<span class=\"sd\">set light to (red | green | blue)</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">intents_to_graph</span><span class=\"p\">(</span><span class=\"n\">intents</span><span class=\"p\">)</span>\n<span class=\"n\">counts</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">get_intent_ngram_counts</span><span class=\"p\">(</span>\n    <span class=\"n\">graph</span><span class=\"p\">,</span>\n    <span class=\"n\">pad_start</span><span class=\"o\">=</span><span class=\"s2\">\"&lt;s&gt;\"</span><span class=\"p\">,</span>\n    <span class=\"n\">pad_end</span><span class=\"o\">=</span><span class=\"s2\">\"&lt;/s&gt;\"</span><span class=\"p\">,</span>\n    <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">3</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Print counts by intent</span>\n<span class=\"k\">for</span> <span class=\"n\">intent_name</span> <span class=\"ow\">in</span> <span class=\"n\">counts</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">intent_name</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">ngram</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"ow\">in</span> <span class=\"n\">counts</span><span class=\"p\">[</span><span class=\"n\">intent_name</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">ngram</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">)</span>\n        \n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"\"</span><span class=\"p\">)</span>\n</pre>\n<p>will print something like:</p>\n<pre><code>SetColor\n('&lt;s&gt;',) 3\n('set',) 3\n('&lt;s&gt;', 'set') 3\n('light',) 3\n('set', 'light') 3\n('&lt;s&gt;', 'set', 'light') 3\n('to',) 3\n('light', 'to') 3\n('set', 'light', 'to') 3\n('red',) 1\n('to', 'red') 1\n('light', 'to', 'red') 1\n('green',) 1\n('to', 'green') 1\n('light', 'to', 'green') 1\n('blue',) 1\n('to', 'blue') 1\n('light', 'to', 'blue') 1\n('&lt;/s&gt;',) 3\n('red', '&lt;/s&gt;') 1\n('green', '&lt;/s&gt;') 1\n('blue', '&lt;/s&gt;') 1\n('to', 'red', '&lt;/s&gt;') 1\n('to', 'green', '&lt;/s&gt;') 1\n('to', 'blue', '&lt;/s&gt;') 1\n\n</code></pre>\n<h3>Opengrm</h3>\n<p>If you have the <a href=\"http://www.opengrm.org/twiki/bin/view/GRM/NGramLibrary\" rel=\"nofollow\">Opengrm</a> command-line tools in your <code>PATH</code>, you can use <code>rhasspynlu</code> to generate language models in the <a href=\"https://cmusphinx.github.io/wiki/arpaformat/\" rel=\"nofollow\">ARPA format</a>.</p>\n<p>The <code>graph_to_fst</code> and <code>fst_to_arpa</code> functions are used to convert between formats. Calling <code>fst_to_arpa</code> requires the following binaries to be present in your <code>PATH</code>:</p>\n<ul>\n<li><code>fstcompile</code> (from <a href=\"http://www.openfst.org\" rel=\"nofollow\">OpenFST</a>)</li>\n<li><code>ngramcount</code></li>\n<li><code>ngrammake</code></li>\n<li><code>ngrammerge</code></li>\n<li><code>ngramprint</code></li>\n<li><code>ngramread</code></li>\n</ul>\n<p>Example:</p>\n<pre><span class=\"c1\"># Convert to FST</span>\n<span class=\"n\">graph_fst</span> <span class=\"o\">=</span> <span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">graph_to_fst</span><span class=\"p\">(</span><span class=\"n\">graph</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Write FST and symbol text files</span>\n<span class=\"n\">graph_fst</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"s2\">\"my_fst.txt\"</span><span class=\"p\">,</span> <span class=\"s2\">\"input_symbols.txt\"</span><span class=\"p\">,</span> <span class=\"s2\">\"output_symbols.txt\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Compile and convert to ARPA language model</span>\n<span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">fst_to_arpa</span><span class=\"p\">(</span>\n    <span class=\"s2\">\"my_fst.txt\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"input_symbols.txt\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"output_symbols.txt\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"my_arpa.lm\"</span>\n<span class=\"p\">)</span>\n</pre>\n<p>You can now use <code>my_arpa.lm</code> in any speech recognizer that accepts ARPA-formatted language models.</p>\n<h3>Language Model Mixing</h3>\n<p>If you have an existing language model that you'd like to mix with Rhasspy voice commands, you will first need to convert it to an FST:</p>\n<pre><span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">fst_to_arpa</span><span class=\"p\">(</span><span class=\"s2\">\"existing_arpa.lm\"</span><span class=\"p\">,</span> <span class=\"s2\">\"existing_arpa.fst\"</span><span class=\"p\">)</span>\n</pre>\n<p>Now when you call <code>fst_to_arpa</code>, make sure to provide the <code>base_fst_weight</code> argument. This is a tuple with the path to your existing ARPA FST and a mixture weight between 0 and 1. A weight of 0.05 means that the base language model will receive 5% of the overall probability mass in the language model. The rest of the mass will be given to your custom voice commands.</p>\n<p>Example:</p>\n<pre><span class=\"n\">rhasspynlu</span><span class=\"o\">.</span><span class=\"n\">fst_to_arpa</span><span class=\"p\">(</span>\n    <span class=\"s2\">\"my_fst.txt\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"input_symbols.txt\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"output_symbols.txt\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"my_arpa.lm\"</span><span class=\"p\">,</span>\n    <span class=\"n\">base_fst_weight</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s2\">\"existing_arpa.fst\"</span><span class=\"p\">,</span> <span class=\"mf\">0.05</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</pre>\n<h2>Command Line Usage</h2>\n<p>The <code>rhasspynlu</code> module can be run directly to convert <code>sentences.ini</code> files into JSON graphs or FST text files:</p>\n<pre>python3 -m rhasspynlu sentences.ini &gt; graph.json\n</pre>\n<p>You can pass multiple <code>.ini</code> files as arguments, and they will be combined. Adding a <code>--fst</code> argument will write out FST text files instead:</p>\n<pre><code>python3 -m rhasspynlu sentences.ini --fst\n</code></pre>\n<p>This will output three files in the current directory:</p>\n<ul>\n<li><code>fst.txt</code> - finite state transducer as text</li>\n<li><code>fst.isymbols.txt</code> - input symbols</li>\n<li><code>fst.osymbols.txt</code> - output symbols</li>\n</ul>\n<p>These file names can be changed with the <code>--fst-text</code>, <code>--fst-isymbols</code>, and <code>--fst-osymbols</code> arguments, respectively.</p>\n<p>Compile to a binary FST using <code>fstcompile</code> (from <a href=\"http://www.openfst.org\" rel=\"nofollow\">OpenFST</a>) with:</p>\n<pre>fstcompile <span class=\"se\">\\</span>\n    --isymbols<span class=\"o\">=</span>fst.isymbols.txt <span class=\"se\">\\</span>\n    --osymbols<span class=\"o\">=</span>fst.osymbols.txt <span class=\"se\">\\</span>\n    --keep_isymbols<span class=\"o\">=</span><span class=\"m\">1</span> <span class=\"se\">\\</span>\n    --keep_osymbols<span class=\"o\">=</span><span class=\"m\">1</span> <span class=\"se\">\\</span>\n    fst.txt <span class=\"se\">\\</span>\n    out.fst\n</pre>\n\n          </div>"}, "last_serial": 7093491, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "854f7d238d9d57c8371506f040d1f98b", "sha256": "ed7f14a3da28e448135a47131ae3e2ff771ce7c887845f14c7f46800faad0369"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.tar.gz", "has_sig": false, "md5_digest": "854f7d238d9d57c8371506f040d1f98b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 20736, "upload_time": "2019-12-10T21:43:14", "upload_time_iso_8601": "2019-12-10T21:43:14.123534Z", "url": "https://files.pythonhosted.org/packages/3d/dc/941f5bb7ae4d3dba9a1800da2484ba639ed891e836317823c7a912cf12f8/rhasspy-nlu-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "002b8c9b6951190955c7ef29f78cdd09", "sha256": "68e733b2f59625421c41d0b02bcf1c70a21aed90312711eec556f302295efedc"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.1.tar.gz", "has_sig": false, "md5_digest": "002b8c9b6951190955c7ef29f78cdd09", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 24828, "upload_time": "2019-12-11T22:11:52", "upload_time_iso_8601": "2019-12-11T22:11:52.574310Z", "url": "https://files.pythonhosted.org/packages/8d/76/d033ee6550287163d19eeffdd0105987df6b5ffb8617df3533c51eac6b9f/rhasspy-nlu-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "b17ec74602f8a7b46393a72ccabaf25f", "sha256": "f0428284f2bbf159d03db3d2e9b93c09b0c29c6370bf7efe9216aa87fa588b14"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.2.tar.gz", "has_sig": false, "md5_digest": "b17ec74602f8a7b46393a72ccabaf25f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 21810, "upload_time": "2019-12-15T19:23:43", "upload_time_iso_8601": "2019-12-15T19:23:43.435437Z", "url": "https://files.pythonhosted.org/packages/f9/f6/c1fb530b2de105155c8d1b381d463e92c9ee15b38b1cb1fe8036023eb418/rhasspy-nlu-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "39ef158c549c398b564b6ecc2bc73bcb", "sha256": "ba0ecdf610b116b9a57c9190883daf3b0956d3138669971981b5b6ffa835c28a"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.3.tar.gz", "has_sig": false, "md5_digest": "39ef158c549c398b564b6ecc2bc73bcb", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 22925, "upload_time": "2019-12-21T20:51:18", "upload_time_iso_8601": "2019-12-21T20:51:18.679399Z", "url": "https://files.pythonhosted.org/packages/e4/c5/4cd19c8099d8acc92c68f8d114462d552d5a84bb57c815c6b058e9791813/rhasspy-nlu-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "ef8d6c342085abaec45991018a37ee79", "sha256": "9225447c407adf3e8c86a1c5d2fd195a3503fe1f397f36a4115fd493da740b6b"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.4.tar.gz", "has_sig": false, "md5_digest": "ef8d6c342085abaec45991018a37ee79", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30710, "upload_time": "2020-01-03T16:46:24", "upload_time_iso_8601": "2020-01-03T16:46:24.641822Z", "url": "https://files.pythonhosted.org/packages/72/c2/717721bf11392fa9ebf3eef80db4d18e18a48d4f144bd0385e7f17d7a096/rhasspy-nlu-0.1.4.tar.gz", "yanked": false}], "0.1.4.1": [{"comment_text": "", "digests": {"md5": "5927257b82b5c31d59850daff02c7bd1", "sha256": "3cce4dfcd2aeab4f9ef637a90e3e594b5440d43f90758aabe53d6e70773a1565"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.4.1.tar.gz", "has_sig": false, "md5_digest": "5927257b82b5c31d59850daff02c7bd1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 26805, "upload_time": "2020-01-04T21:40:43", "upload_time_iso_8601": "2020-01-04T21:40:43.625859Z", "url": "https://files.pythonhosted.org/packages/1c/db/57cf2f9de50c437530dbbd73451fc620024fab374aef814aadbd2e76b764/rhasspy-nlu-0.1.4.1.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "3dbed48e96fe80bbd498d17f9077344d", "sha256": "1b9bbe8fac980b33a2498bcfc8ec5033b4a2327ba8034092f13d731bddd5c36e"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.5.tar.gz", "has_sig": false, "md5_digest": "3dbed48e96fe80bbd498d17f9077344d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 28933, "upload_time": "2020-01-20T19:45:29", "upload_time_iso_8601": "2020-01-20T19:45:29.921067Z", "url": "https://files.pythonhosted.org/packages/16/cb/2a740c6c8d2ee67f9999387a97824666f8926619fbf9bc8c99623eb17cd7/rhasspy-nlu-0.1.5.tar.gz", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "4302fc7877b2964e28f6af2a79c4b7d9", "sha256": "066a7b33ef1f44295db98f0dd02ca3837c1fe10ca4d256eec8435593ce858064"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.6.tar.gz", "has_sig": false, "md5_digest": "4302fc7877b2964e28f6af2a79c4b7d9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 39109, "upload_time": "2020-02-06T15:26:55", "upload_time_iso_8601": "2020-02-06T15:26:55.967139Z", "url": "https://files.pythonhosted.org/packages/a3/33/2f9ef0e4c410a669de0b2b4c8f01d1a765fa09aaa185c1368c8b5db3ee54/rhasspy-nlu-0.1.6.tar.gz", "yanked": false}], "0.1.8": [{"comment_text": "", "digests": {"md5": "32c335f436ac91770223713c56ed9644", "sha256": "e9421f9c7c61802ab1a4969ee01b9482b9b402f28cf96351ad6751a92c140bb6"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.8.tar.gz", "has_sig": false, "md5_digest": "32c335f436ac91770223713c56ed9644", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 43553, "upload_time": "2020-04-24T14:30:34", "upload_time_iso_8601": "2020-04-24T14:30:34.925839Z", "url": "https://files.pythonhosted.org/packages/aa/99/59ce646014d766e4c017b259951e657fbd6a8dd675fdaeaf4666bbd2fdf4/rhasspy-nlu-0.1.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "32c335f436ac91770223713c56ed9644", "sha256": "e9421f9c7c61802ab1a4969ee01b9482b9b402f28cf96351ad6751a92c140bb6"}, "downloads": -1, "filename": "rhasspy-nlu-0.1.8.tar.gz", "has_sig": false, "md5_digest": "32c335f436ac91770223713c56ed9644", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 43553, "upload_time": "2020-04-24T14:30:34", "upload_time_iso_8601": "2020-04-24T14:30:34.925839Z", "url": "https://files.pythonhosted.org/packages/aa/99/59ce646014d766e4c017b259951e657fbd6a8dd675fdaeaf4666bbd2fdf4/rhasspy-nlu-0.1.8.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:00 2020"}