{"info": {"author": "Leonard Ritter", "author_email": "contact@leonard-ritter.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Libraries"], "description": "glue.py is a single lightweight utility module expanding Python with new \npowerful idioms for accessors, callsets, weak methods, enums, singletons and \nobservable primitives that can easily be integrated with existing projects. It\nis particularly useful for writing model/view oriented applications.\n\nInstallation\n============\n\nYou'll require Python 2.7, Python 3+ or PyPy 1.9 to use glue.py. Earlier\nversions are not supported.\n\nglue.py can easily be installed from the Python package repository using\ndistutils or pip:\n\n    pip install glue.py\n\nIf you plan to make amendments to the codebase, or you're interested in the \nlatest development release, it is best to check out the source tree and\ninstall glue.py in development mode:\n\n    python setup.py develop\n\nUsage\n=====\n\nglue.py provides a larger set of interoperating utility classes and functions,\nof which only the most important ones will be described here in detail. It's\nnot a bad idea to just browse through the source and look what else is there\nbesides what's covered in this introduction.\n\nGenerated Accessors\n-------------------\n\nWhile Python supports accessors through properties, providing regulated access\nto class variables has been traditionally cumbersome and repetitive, even though\nthe syntax has somewhat improved with recent versions. Consider this classical\napproach to property access:\n\n    from types import NoneType\n\n    class Sponge(object):\n        pass\n\n    class Pineapple(object):\n        on_owner_changed = None\n        \n        def __init__(self):\n            self.__owner = None\n            \n        def get_owner(self):\n            return self.__owner\n        def set_owner(self, value):\n            if value == self.__owner:\n                return\n            assert isinstance(value, (Sponge, NoneType))\n            self.__owner = value\n            if self.on_owner_changed:\n                self.on_owner_changed(self)\n        owner = property(get_owner, set_owner, \n            doc = \"the owner of this Pineapple\")\n\napart from preventing a rewrite, the setter also provides an optional hook that\ncan be triggered when the value changes. Notice how many times the word \"owner\"\nhas to be repeated in one form or the other in order to expose this relatively\nsimple attribute. Until Python 2.7, most people adapted this handy recipe to\ncut down on repetition:\n\n         def owner():\n            doc = \"\"\"the owner of this pineapple\"\"\"\n            def fget(self):\n                return self.__owner\n            def fset(self, value):\n                if value == self.__owner:\n                    return\n                assert isinstance(value, (Sponge, NoneType))\n                self.__owner = value\n                if self.on_owner_changed:\n                    self.on_owner_changed(self)\n            return property(**locals())\n        owner = owner()\n\nThat's slightly better, but not perfect, and also a little convoluted. These\ndays, this approach is the status quo:\n\n        @property\n        def owner(self):\n            \"\"\"The owner of this pineapple\"\"\"\n            return self.__owner\n        @owner.setter\n        def owner(self, value):\n            if value == self.__owner:\n                return\n            assert isinstance(value, (Sponge, NoneType))\n            self.__owner = value\n            if self.on_owner_changed:\n                self.on_owner_changed(self)\n\nit seems like we're mostly shuffling details around... all three solutions\nvary around 12 lines, and with a bunch of these, classes may seem a lot larger\nthan they are. This is how glue.py does it:\n\n    from glue import (lazydecls, defproperty, autoinit, callset)\n    from types import NoneType\n\n    class Sponge(object):\n        pass\n\n    @lazydecls\n    class Pineapple(object):\n        on_owner_changed = callset()\n        \n        owner = defproperty(\n            default = None, types=(Sponge, NoneType), hook = on_owner_changed, \n            doc = \"The owner of this pineapple\")\n        \n        def __init__(self):\n            autoinit()\n\n...case closed. For more information, try `help(glue.defproperty)`. \n\nCallable Sets\n-------------\n\nYou may have noticed that the `Pineapple` class exposes the `on_owner_changed`\ncallback as a `callset`, which is just a short way of instantiating a\n`CallableSet`. Callable sets are a fast way to create observables:\n\n    from glue import callset\n        \n    def func1(value): \n        print(\"func1 called with value\",value)\n        return value+10\n\n    def func2(value): \n        print(\"func2 called with value\",value)\n        return value+20\n\n    def func3(value): \n        print(\"func3 called with value\",value)\n        return value+30\n\nTrying this on the command line:\n\n    >>> funcs = callset([func1,func2,func3])\n    >>> print(max(funcs(10)))\n    func1 called with value 10\n    func2 called with value 10\n    func3 called with value 10\n    40\n\nIn the pineapple example, this is how a view would typically subscribe to\nevents sent by the `Pineapple` class:\n\n    @lazydecls\n    class Squid(object):\n        neighbor_house = defproperty()\n        annoying_coworkers = defproperty(default = set)\n        \n        def __init__(self, **kwargs):\n            # auto-assign matching keyword args\n            autoinit(**kwargs)\n            # track if the owner of the neighbor house changes by registering\n            # Squid's callback. The callback will be weakly proxied, and\n            # automatically unregisters when this Squid instance is no longer\n            # referenced. \n            self.neighbor_house.on_owner_changed.addweak(self.someone_moved_in)\n            \n        def someone_moved_in(self, event):\n            # since the on_owner_changed callset is global to Pineapple, Squid\n            # would be notified of any owner changes in Pineapples, so filter\n            # for the right one.\n            if not (event.instance is self.neighbor_house):\n                return\n            # check if the new tenant is one of our annoying coworkers\n            if event.value in self.annoying_coworkers:\n                # state opinion on the situation\n                print(\"Meh.\")\n    \n\nTrying this on the command line:\n\n    >>> house = Pineapple()\n    >>> bob = Sponge()\n    >>> squidward = Squid(neighbor_house = house)\n    >>> squidward.annoying_coworkers.add(bob)\n    >>> house.owner = bob\n    Meh.\n\nAnd that's the gist of it.\n\nWeak Callable Proxies\n---------------------\n\nTODO\n\nObservable Dicts, Lists and Sets\n--------------------------------\n\nTODO\n\nEnums\n-----\n\nTODO\n\nSingletons\n----------\n\nTODO", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/duangle/glue.py", "keywords": "python glue mvc observable idioms lightweight", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "glue.py", "package_url": "https://pypi.org/project/glue.py/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/glue.py/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://bitbucket.org/duangle/glue.py"}, "release_url": "https://pypi.org/project/glue.py/0.5.1/", "requires_dist": null, "requires_python": null, "summary": "The agnostic model/view toolshed", "version": "0.5.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            glue.py is a single lightweight utility module expanding Python with new <br>powerful idioms for accessors, callsets, weak methods, enums, singletons and <br>observable primitives that can easily be integrated with existing projects. It<br>is particularly useful for writing model/view oriented applications.<br><br>Installation<br>============<br><br>You'll require Python 2.7, Python 3+ or PyPy 1.9 to use glue.py. Earlier<br>versions are not supported.<br><br>glue.py can easily be installed from the Python package repository using<br>distutils or pip:<br><br>    pip install glue.py<br><br>If you plan to make amendments to the codebase, or you're interested in the <br>latest development release, it is best to check out the source tree and<br>install glue.py in development mode:<br><br>    python setup.py develop<br><br>Usage<br>=====<br><br>glue.py provides a larger set of interoperating utility classes and functions,<br>of which only the most important ones will be described here in detail. It's<br>not a bad idea to just browse through the source and look what else is there<br>besides what's covered in this introduction.<br><br>Generated Accessors<br>-------------------<br><br>While Python supports accessors through properties, providing regulated access<br>to class variables has been traditionally cumbersome and repetitive, even though<br>the syntax has somewhat improved with recent versions. Consider this classical<br>approach to property access:<br><br>    from types import NoneType<br><br>    class Sponge(object):<br>        pass<br><br>    class Pineapple(object):<br>        on_owner_changed = None<br>        <br>        def __init__(self):<br>            self.__owner = None<br>            <br>        def get_owner(self):<br>            return self.__owner<br>        def set_owner(self, value):<br>            if value == self.__owner:<br>                return<br>            assert isinstance(value, (Sponge, NoneType))<br>            self.__owner = value<br>            if self.on_owner_changed:<br>                self.on_owner_changed(self)<br>        owner = property(get_owner, set_owner, <br>            doc = \"the owner of this Pineapple\")<br><br>apart from preventing a rewrite, the setter also provides an optional hook that<br>can be triggered when the value changes. Notice how many times the word \"owner\"<br>has to be repeated in one form or the other in order to expose this relatively<br>simple attribute. Until Python 2.7, most people adapted this handy recipe to<br>cut down on repetition:<br><br>         def owner():<br>            doc = \"\"\"the owner of this pineapple\"\"\"<br>            def fget(self):<br>                return self.__owner<br>            def fset(self, value):<br>                if value == self.__owner:<br>                    return<br>                assert isinstance(value, (Sponge, NoneType))<br>                self.__owner = value<br>                if self.on_owner_changed:<br>                    self.on_owner_changed(self)<br>            return property(**locals())<br>        owner = owner()<br><br>That's slightly better, but not perfect, and also a little convoluted. These<br>days, this approach is the status quo:<br><br>        @property<br>        def owner(self):<br>            \"\"\"The owner of this pineapple\"\"\"<br>            return self.__owner<br>        @owner.setter<br>        def owner(self, value):<br>            if value == self.__owner:<br>                return<br>            assert isinstance(value, (Sponge, NoneType))<br>            self.__owner = value<br>            if self.on_owner_changed:<br>                self.on_owner_changed(self)<br><br>it seems like we're mostly shuffling details around... all three solutions<br>vary around 12 lines, and with a bunch of these, classes may seem a lot larger<br>than they are. This is how glue.py does it:<br><br>    from glue import (lazydecls, defproperty, autoinit, callset)<br>    from types import NoneType<br><br>    class Sponge(object):<br>        pass<br><br>    @lazydecls<br>    class Pineapple(object):<br>        on_owner_changed = callset()<br>        <br>        owner = defproperty(<br>            default = None, types=(Sponge, NoneType), hook = on_owner_changed, <br>            doc = \"The owner of this pineapple\")<br>        <br>        def __init__(self):<br>            autoinit()<br><br>...case closed. For more information, try `help(glue.defproperty)`. <br><br>Callable Sets<br>-------------<br><br>You may have noticed that the `Pineapple` class exposes the `on_owner_changed`<br>callback as a `callset`, which is just a short way of instantiating a<br>`CallableSet`. Callable sets are a fast way to create observables:<br><br>    from glue import callset<br>        <br>    def func1(value): <br>        print(\"func1 called with value\",value)<br>        return value+10<br><br>    def func2(value): <br>        print(\"func2 called with value\",value)<br>        return value+20<br><br>    def func3(value): <br>        print(\"func3 called with value\",value)<br>        return value+30<br><br>Trying this on the command line:<br><br>    &gt;&gt;&gt; funcs = callset([func1,func2,func3])<br>    &gt;&gt;&gt; print(max(funcs(10)))<br>    func1 called with value 10<br>    func2 called with value 10<br>    func3 called with value 10<br>    40<br><br>In the pineapple example, this is how a view would typically subscribe to<br>events sent by the `Pineapple` class:<br><br>    @lazydecls<br>    class Squid(object):<br>        neighbor_house = defproperty()<br>        annoying_coworkers = defproperty(default = set)<br>        <br>        def __init__(self, **kwargs):<br>            # auto-assign matching keyword args<br>            autoinit(**kwargs)<br>            # track if the owner of the neighbor house changes by registering<br>            # Squid's callback. The callback will be weakly proxied, and<br>            # automatically unregisters when this Squid instance is no longer<br>            # referenced. <br>            self.neighbor_house.on_owner_changed.addweak(self.someone_moved_in)<br>            <br>        def someone_moved_in(self, event):<br>            # since the on_owner_changed callset is global to Pineapple, Squid<br>            # would be notified of any owner changes in Pineapples, so filter<br>            # for the right one.<br>            if not (event.instance is self.neighbor_house):<br>                return<br>            # check if the new tenant is one of our annoying coworkers<br>            if event.value in self.annoying_coworkers:<br>                # state opinion on the situation<br>                print(\"Meh.\")<br>    <br><br>Trying this on the command line:<br><br>    &gt;&gt;&gt; house = Pineapple()<br>    &gt;&gt;&gt; bob = Sponge()<br>    &gt;&gt;&gt; squidward = Squid(neighbor_house = house)<br>    &gt;&gt;&gt; squidward.annoying_coworkers.add(bob)<br>    &gt;&gt;&gt; house.owner = bob<br>    Meh.<br><br>And that's the gist of it.<br><br>Weak Callable Proxies<br>---------------------<br><br>TODO<br><br>Observable Dicts, Lists and Sets<br>--------------------------------<br><br>TODO<br><br>Enums<br>-----<br><br>TODO<br><br>Singletons<br>----------<br><br>TODO\n          </div>"}, "last_serial": 570995, "releases": {"0.5": [], "0.5.1": []}, "urls": [], "timestamp": "Fri May  8 00:56:27 2020"}