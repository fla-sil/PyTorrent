{"info": {"author": "James Tauber", "author_email": "jtauber@jtauber.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.3"], "description": ".. _usage:\n\nUsage\n=====\n\nIntegrating notification support into your app is a simple three-step process.\n\n  * create your notice types\n  * create your notice templates\n  * send notifications\n\nCreating Notice Types\n---------------------\n\nYou need to call ``create_notice_type(label, display, description)`` once to\ncreate the notice types for your application in the database. ``label`` is just\nthe internal shortname that will be used for the type, ``display`` is what the\nuser will see as the name of the notification type and `description` is a\nshort description.\n\nFor example::\n\n    notification.create_notice_type(\"friends_invite\", \"Invitation Received\", \"you have received an invitation\")\n\nOne good way to automatically do this notice type creation is in a\n``management.py`` file for your app, attached to the syncdb signal.\nHere is an example::\n\n    from django.conf import settings\n    from django.db.models import signals\n    from django.utils.translation import ugettext_noop as _\n    \n    if \"notification\" in settings.INSTALLED_APPS:\n        from notification import models as notification\n        \n        def create_notice_types(app, created_models, verbosity, **kwargs):\n            notification.create_notice_type(\"friends_invite\", _(\"Invitation Received\"), _(\"you have received an invitation\"))\n            notification.create_notice_type(\"friends_accept\", _(\"Acceptance Received\"), _(\"an invitation you sent has been accepted\"))\n            \n        signals.post_syncdb.connect(create_notice_types, sender=notification)\n    else:\n        print \"Skipping creation of NoticeTypes as notification app not found\"\n\nNotice that the code is wrapped in a conditional clause so if\ndjango-notification is not installed, your app will proceed anyway.\n\nNote that the display and description arguments are marked for translation by\nusing ugettext_noop. That will enable you to use Django's makemessages\nmanagement command and use django-notification's i18n capabilities.\n\nNotification templates\n----------------------\n\nThere are four different templates that can be written to for the actual content of the notices:\n\n  * ``short.txt`` is a very short, text-only version of the notice (suitable for things like email subjects)\n  * ``full.txt`` is a longer, text-only version of the notice (suitable for things like email bodies)\n  * ``notice.html`` is a short, html version of the notice, displayed in a user's notice list on the website\n  * ``full.html`` is a long, html version of the notice (not currently used for anything)\n\nEach of these should be put in a directory on the template path called ``notification/<notice_type_label>/<template_name>``.\nIf any of these are missing, a default would be used. In practice, ``notice.html`` and ``full.txt`` should be provided at a minimum.\n\nFor example, ``notification/friends_invite/notice.html`` might contain::\n    \n    {% load i18n %}{% url invitations as invitation_page %}{% url profile_detail username=invitation.from_user.username as user_url %}\n    {% blocktrans with invitation.from_user as invitation_from_user %}<a href=\"{{ user_url }}\">{{ invitation_from_user }}</a> has requested to add you as a friend (see <a href=\"{{ invitation_page }}\">invitations</a>){% endblocktrans %}\n\nand ``notification/friends/full.txt`` might contain::\n    \n    {% load i18n %}{% url invitations as invitation_page %}{% blocktrans with invitation.from_user as invitation_from_user %}{{ invitation_from_user }} has requested to add you as a friend. You can accept their invitation at:\n    \n    http://{{ current_site }}{{ invitation_page }}\n    {% endblocktrans %}\n\nThe context variables are provided when sending the notification.\n\n\nSending Notification\n====================\n\nThere are two different ways of sending out notifications. We have support\nfor blocking and non-blocking methods of sending notifications. The most\nsimple way to send out a notification, for example::\n\n    notification.send([to_user], \"friends_invite\", {\"from_user\": from_user})\n\nOne thing to note is that ``send`` is a proxy around either ``send_now`` or\n``queue``. They all have the same signature::\n\n    send(users, label, extra_context)\n\nThe parameters are:\n\n * ``users`` is an iterable of ``User`` objects to send the notification to.\n * ``label`` is the label you used in the previous step to identify the notice\n   type.\n * ``extra_content`` is a dictionary to add custom context entries to the\n   template used to render to notification. This is optional.\n\n``send_now`` vs. ``queue`` vs. ``send``\n---------------------------------------\n\nLets first break down what each does.\n\n``send_now``\n~~~~~~~~~~~~\n\nThis is a blocking call that will check each user for elgibility of the\nnotice and actually peform the send.\n\n``queue``\n~~~~~~~~~\n\nThis is a non-blocking call that will queue the call to ``send_now`` to\nbe executed at a later time. To later execute the call you need to use\nthe ``emit_notices`` management command.\n\n``send``\n~~~~~~~~\n\nA proxy around ``send_now`` and ``queue``. It gets its behavior from a global\nsetting named ``NOTIFICATION_QUEUE_ALL``. By default it is ``False``. This\nsetting is meant to help control whether you want to queue any call to\n``send``.\n\n``send`` also accepts ``now`` and ``queue`` keyword arguments. By default\neach option is set to ``False`` to honor the global setting which is ``False``.\nThis enables you to override on a per call basis whether it should call\n``send_now`` or ``queue``.\n\nOptional notification support\n-----------------------------\n\nIn case you want to use django-notification in your reusable app, you can\nwrap the import of django-notification in a conditional clause that tests\nif it's installed before sending a notice. As a result your app or\nproject still functions without notification.\n\nFor example::\n\n    from django.conf import settings\n\n    if \"notification\" in settings.INSTALLED_APPS:\n        from notification import models as notification\n    else:\n        notification = None\n\nand then, later::\n\n    if notification:\n        notification.send([to_user], \"friends_invite\", {\"from_user\": from_user})", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pinax/django-notification", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "django-anonymous-notification", "package_url": "https://pypi.org/project/django-anonymous-notification/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-anonymous-notification/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/pinax/django-notification"}, "release_url": "https://pypi.org/project/django-anonymous-notification/1.2.1/", "requires_dist": null, "requires_python": null, "summary": "User notification management for the Django web framework", "version": "1.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"id1\">\n<span id=\"usage\"></span><h2>Usage</h2>\n<p>Integrating notification support into your app is a simple three-step process.</p>\n<blockquote>\n<ul>\n<li>create your notice types</li>\n<li>create your notice templates</li>\n<li>send notifications</li>\n</ul>\n</blockquote>\n<div id=\"creating-notice-types\">\n<h3>Creating Notice Types</h3>\n<p>You need to call <tt>create_notice_type(label, display, description)</tt> once to\ncreate the notice types for your application in the database. <tt>label</tt> is just\nthe internal shortname that will be used for the type, <tt>display</tt> is what the\nuser will see as the name of the notification type and <cite>description</cite> is a\nshort description.</p>\n<p>For example:</p>\n<pre>notification.create_notice_type(\"friends_invite\", \"Invitation Received\", \"you have received an invitation\")\n</pre>\n<p>One good way to automatically do this notice type creation is in a\n<tt>management.py</tt> file for your app, attached to the syncdb signal.\nHere is an example:</p>\n<pre>from django.conf import settings\nfrom django.db.models import signals\nfrom django.utils.translation import ugettext_noop as _\n\nif \"notification\" in settings.INSTALLED_APPS:\n    from notification import models as notification\n\n    def create_notice_types(app, created_models, verbosity, **kwargs):\n        notification.create_notice_type(\"friends_invite\", _(\"Invitation Received\"), _(\"you have received an invitation\"))\n        notification.create_notice_type(\"friends_accept\", _(\"Acceptance Received\"), _(\"an invitation you sent has been accepted\"))\n\n    signals.post_syncdb.connect(create_notice_types, sender=notification)\nelse:\n    print \"Skipping creation of NoticeTypes as notification app not found\"\n</pre>\n<p>Notice that the code is wrapped in a conditional clause so if\ndjango-notification is not installed, your app will proceed anyway.</p>\n<p>Note that the display and description arguments are marked for translation by\nusing ugettext_noop. That will enable you to use Django\u2019s makemessages\nmanagement command and use django-notification\u2019s i18n capabilities.</p>\n</div>\n<div id=\"notification-templates\">\n<h3>Notification templates</h3>\n<p>There are four different templates that can be written to for the actual content of the notices:</p>\n<blockquote>\n<ul>\n<li><tt>short.txt</tt> is a very short, text-only version of the notice (suitable for things like email subjects)</li>\n<li><tt>full.txt</tt> is a longer, text-only version of the notice (suitable for things like email bodies)</li>\n<li><tt>notice.html</tt> is a short, html version of the notice, displayed in a user\u2019s notice list on the website</li>\n<li><tt>full.html</tt> is a long, html version of the notice (not currently used for anything)</li>\n</ul>\n</blockquote>\n<p>Each of these should be put in a directory on the template path called <tt><span class=\"pre\">notification/&lt;notice_type_label&gt;/&lt;template_name&gt;</span></tt>.\nIf any of these are missing, a default would be used. In practice, <tt>notice.html</tt> and <tt>full.txt</tt> should be provided at a minimum.</p>\n<p>For example, <tt>notification/friends_invite/notice.html</tt> might contain:</p>\n<pre>{% load i18n %}{% url invitations as invitation_page %}{% url profile_detail username=invitation.from_user.username as user_url %}\n{% blocktrans with invitation.from_user as invitation_from_user %}&lt;a href=\"{{ user_url }}\"&gt;{{ invitation_from_user }}&lt;/a&gt; has requested to add you as a friend (see &lt;a href=\"{{ invitation_page }}\"&gt;invitations&lt;/a&gt;){% endblocktrans %}\n</pre>\n<p>and <tt>notification/friends/full.txt</tt> might contain:</p>\n<pre>{% load i18n %}{% url invitations as invitation_page %}{% blocktrans with invitation.from_user as invitation_from_user %}{{ invitation_from_user }} has requested to add you as a friend. You can accept their invitation at:\n\nhttp://{{ current_site }}{{ invitation_page }}\n{% endblocktrans %}\n</pre>\n<p>The context variables are provided when sending the notification.</p>\n</div>\n</div>\n<div id=\"sending-notification\">\n<h2>Sending Notification</h2>\n<p>There are two different ways of sending out notifications. We have support\nfor blocking and non-blocking methods of sending notifications. The most\nsimple way to send out a notification, for example:</p>\n<pre>notification.send([to_user], \"friends_invite\", {\"from_user\": from_user})\n</pre>\n<p>One thing to note is that <tt>send</tt> is a proxy around either <tt>send_now</tt> or\n<tt>queue</tt>. They all have the same signature:</p>\n<pre>send(users, label, extra_context)\n</pre>\n<p>The parameters are:</p>\n<blockquote>\n<ul>\n<li><tt>users</tt> is an iterable of <tt>User</tt> objects to send the notification to.</li>\n<li><tt>label</tt> is the label you used in the previous step to identify the notice\ntype.</li>\n<li><tt>extra_content</tt> is a dictionary to add custom context entries to the\ntemplate used to render to notification. This is optional.</li>\n</ul>\n</blockquote>\n<div id=\"send-now-vs-queue-vs-send\">\n<h3><tt>send_now</tt> vs. <tt>queue</tt> vs. <tt>send</tt></h3>\n<p>Lets first break down what each does.</p>\n<div id=\"send-now\">\n<h4><tt>send_now</tt></h4>\n<p>This is a blocking call that will check each user for elgibility of the\nnotice and actually peform the send.</p>\n</div>\n<div id=\"queue\">\n<h4><tt>queue</tt></h4>\n<p>This is a non-blocking call that will queue the call to <tt>send_now</tt> to\nbe executed at a later time. To later execute the call you need to use\nthe <tt>emit_notices</tt> management command.</p>\n</div>\n<div id=\"send\">\n<h4><tt>send</tt></h4>\n<p>A proxy around <tt>send_now</tt> and <tt>queue</tt>. It gets its behavior from a global\nsetting named <tt>NOTIFICATION_QUEUE_ALL</tt>. By default it is <tt>False</tt>. This\nsetting is meant to help control whether you want to queue any call to\n<tt>send</tt>.</p>\n<p><tt>send</tt> also accepts <tt>now</tt> and <tt>queue</tt> keyword arguments. By default\neach option is set to <tt>False</tt> to honor the global setting which is <tt>False</tt>.\nThis enables you to override on a per call basis whether it should call\n<tt>send_now</tt> or <tt>queue</tt>.</p>\n</div>\n</div>\n<div id=\"optional-notification-support\">\n<h3>Optional notification support</h3>\n<p>In case you want to use django-notification in your reusable app, you can\nwrap the import of django-notification in a conditional clause that tests\nif it\u2019s installed before sending a notice. As a result your app or\nproject still functions without notification.</p>\n<p>For example:</p>\n<pre>from django.conf import settings\n\nif \"notification\" in settings.INSTALLED_APPS:\n    from notification import models as notification\nelse:\n    notification = None\n</pre>\n<p>and then, later:</p>\n<pre>if notification:\n    notification.send([to_user], \"friends_invite\", {\"from_user\": from_user})\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1358427, "releases": {"1.2.1": [{"comment_text": "", "digests": {"md5": "04bbdb1a27c8949d7145fee2885c8a92", "sha256": "bec442abafdc9ca141aa466152acdd2127ad5b38e29e388c3061a233872eb31d"}, "downloads": -1, "filename": "django-anonymous-notification-1.2.1.tar.gz", "has_sig": true, "md5_digest": "04bbdb1a27c8949d7145fee2885c8a92", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27642, "upload_time": "2014-10-23T10:47:43", "upload_time_iso_8601": "2014-10-23T10:47:43.682424Z", "url": "https://files.pythonhosted.org/packages/d3/5a/b3b826a7bffbdfd261752496575bbc409929996c8da0c3127ddfb6eaf7ef/django-anonymous-notification-1.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "04bbdb1a27c8949d7145fee2885c8a92", "sha256": "bec442abafdc9ca141aa466152acdd2127ad5b38e29e388c3061a233872eb31d"}, "downloads": -1, "filename": "django-anonymous-notification-1.2.1.tar.gz", "has_sig": true, "md5_digest": "04bbdb1a27c8949d7145fee2885c8a92", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27642, "upload_time": "2014-10-23T10:47:43", "upload_time_iso_8601": "2014-10-23T10:47:43.682424Z", "url": "https://files.pythonhosted.org/packages/d3/5a/b3b826a7bffbdfd261752496575bbc409929996c8da0c3127ddfb6eaf7ef/django-anonymous-notification-1.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:37:41 2020"}