{"info": {"author": "Zope Corporation and Contributors", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP"], "description": "This package provides a flexible and pluggable authentication utility for Zope\n3, using `zope.pluggableauth`. Several common plugins are provided.\n\n\n.. contents::\n\n================================\nPluggable-Authentication Utility\n================================\n\nThe Pluggable-Authentication Utility (PAU) provides a framework for\nauthenticating principals and associating information with them. It uses\nplugins and subscribers to get its work done.\n\nFor a pluggable-authentication utility to be used, it should be\nregistered as a utility providing the\n`zope.authentication.interfaces.IAuthentication` interface.\n\nAuthentication\n--------------\n\nThe primary job of PAU is to authenticate principals. It uses two types of\nplug-ins in its work:\n\n  - Credentials Plugins\n\n  - Authenticator Plugins\n\nCredentials plugins are responsible for extracting user credentials from a\nrequest. A credentials plugin may in some cases issue a 'challenge' to obtain\ncredentials. For example, a 'session' credentials plugin reads credentials\nfrom a session (the \"extraction\"). If it cannot find credentials, it will\nredirect the user to a login form in order to provide them (the \"challenge\").\n\nAuthenticator plugins are responsible for authenticating the credentials\nextracted by a credentials plugin. They are also typically able to create\nprincipal objects for credentials they successfully authenticate.\n\nGiven a request object, the PAU returns a principal object, if it can. The PAU\ndoes this by first iterateing through its credentials plugins to obtain a\nset of credentials. If it gets credentials, it iterates through its\nauthenticator plugins to authenticate them.\n\nIf an authenticator succeeds in authenticating a set of credentials, the PAU\nuses the authenticator to create a principal corresponding to the credentials.\nThe authenticator notifies subscribers if an authenticated principal is\ncreated. Subscribers are responsible for adding data, especially groups, to\nthe principal. Typically, if a subscriber adds data, it should also add\ncorresponding interface declarations.\n\nSimple Credentials Plugin\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTo illustrate, we'll create a simple credentials plugin::\n\n  >>> from zope import interface\n  >>> from zope.app.authentication import interfaces\n\n  >>> @interface.implementer(interfaces.ICredentialsPlugin)\n  ... class MyCredentialsPlugin(object):\n  ...\n  ...\n  ...     def extractCredentials(self, request):\n  ...         return request.get('credentials')\n  ...\n  ...     def challenge(self, request):\n  ...         pass # challenge is a no-op for this plugin\n  ...\n  ...     def logout(self, request):\n  ...         pass # logout is a no-op for this plugin\n\nAs a plugin, MyCredentialsPlugin needs to be registered as a named utility::\n\n  >>> myCredentialsPlugin = MyCredentialsPlugin()\n  >>> provideUtility(myCredentialsPlugin, name='My Credentials Plugin')\n\nSimple Authenticator Plugin\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nNext we'll create a simple authenticator plugin. For our plugin, we'll need\nan implementation of IPrincipalInfo::\n\n  >>> @interface.implementer(interfaces.IPrincipalInfo)\n  ... class PrincipalInfo(object):\n  ...\n  ...     def __init__(self, id, title, description):\n  ...         self.id = id\n  ...         self.title = title\n  ...         self.description = description\n  ...\n  ...     def __repr__(self):\n  ...         return 'PrincipalInfo(%r)' % self.id\n\nOur authenticator uses this type when it creates a principal info::\n\n  >>> @interface.implementer(interfaces.IAuthenticatorPlugin)\n  ... class MyAuthenticatorPlugin(object):\n  ...\n  ...     def authenticateCredentials(self, credentials):\n  ...         if credentials == 'secretcode':\n  ...             return PrincipalInfo('bob', 'Bob', '')\n  ...\n  ...     def principalInfo(self, id):\n  ...         pass # plugin not currently supporting search\n\nAs with the credentials plugin, the authenticator plugin must be registered\nas a named utility::\n\n  >>> myAuthenticatorPlugin = MyAuthenticatorPlugin()\n  >>> provideUtility(myAuthenticatorPlugin, name='My Authenticator Plugin')\n\nPrincipal Factories\n~~~~~~~~~~~~~~~~~~~\n\nWhile authenticator plugins provide principal info, they are not responsible\nfor creating principals. This function is performed by factory adapters. For\nthese tests we'll borrow some factories from the principal folder::\n\n  >>> from zope.app.authentication import principalfolder\n  >>> provideAdapter(principalfolder.AuthenticatedPrincipalFactory)\n  >>> provideAdapter(principalfolder.FoundPrincipalFactory)\n\nFor more information on these factories, see their docstrings.\n\nConfiguring a PAU\n~~~~~~~~~~~~~~~~~\n\nFinally, we'll create the PAU itself::\n\n  >>> from zope.app import authentication\n  >>> pau = authentication.PluggableAuthentication('xyz_')\n\nand configure it with the two plugins::\n\n  >>> pau.credentialsPlugins = ('My Credentials Plugin', )\n  >>> pau.authenticatorPlugins = ('My Authenticator Plugin', )\n\nUsing the PAU to Authenticate\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWe can now use the PAU to authenticate a sample request::\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> print(pau.authenticate(TestRequest()))\n  None\n\nIn this case, we cannot authenticate an empty request. In the same way, we\nwill not be able to authenticate a request with the wrong credentials::\n\n  >>> print(pau.authenticate(TestRequest(credentials='let me in!')))\n  None\n\nHowever, if we provide the proper credentials::\n\n  >>> request = TestRequest(credentials='secretcode')\n  >>> principal = pau.authenticate(request)\n  >>> principal\n  Principal('xyz_bob')\n\nwe get an authenticated principal.\n\nAuthenticated Principal Creates Events\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWe can verify that the appropriate event was published::\n\n  >>> [event] = getEvents(interfaces.IAuthenticatedPrincipalCreated)\n  >>> event.principal is principal\n  True\n  >>> event.info\n  PrincipalInfo('bob')\n  >>> event.request is request\n  True\n\nThe info object has the id, title, and description of the principal.  The info\nobject is also generated by the authenticator plugin, so the plugin may\nitself have provided additional information on the info object::\n\n  >>> event.info.title\n  'Bob'\n  >>> event.info.id # does not include pau prefix\n  'bob'\n  >>> event.info.description\n  ''\n\nIt is also decorated with two other attributes, credentialsPlugin and\nauthenticatorPlugin: these are the plugins used to extract credentials for and\nauthenticate this principal.  These attributes can be useful for subscribers\nthat want to react to the plugins used.  For instance, subscribers can\ndetermine that a given credential plugin does or does not support logout, and\nprovide information usable to show or hide logout user interface::\n\n  >>> event.info.credentialsPlugin is myCredentialsPlugin\n  True\n  >>> event.info.authenticatorPlugin is myAuthenticatorPlugin\n  True\n\nNormally, we provide subscribers to these events that add additional\ninformation to the principal. For example, we'll add one that sets\nthe title::\n\n  >>> def add_info(event):\n  ...     event.principal.title = event.info.title\n  >>> provideHandler(add_info, [interfaces.IAuthenticatedPrincipalCreated])\n\nNow, if we authenticate a principal, its title is set::\n\n  >>> principal = pau.authenticate(request)\n  >>> principal.title\n  'Bob'\n\nMultiple Authenticator Plugins\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe PAU works with multiple authenticator plugins. It uses each plugin, in the\norder specified in the PAU's authenticatorPlugins attribute, to authenticate\na set of credentials.\n\nTo illustrate, we'll create another authenticator::\n\n  >>> class MyAuthenticatorPlugin2(MyAuthenticatorPlugin):\n  ...\n  ...     def authenticateCredentials(self, credentials):\n  ...         if credentials == 'secretcode':\n  ...             return PrincipalInfo('black', 'Black Spy', '')\n  ...         elif credentials == 'hiddenkey':\n  ...             return PrincipalInfo('white', 'White Spy', '')\n\n  >>> provideUtility(MyAuthenticatorPlugin2(), name='My Authenticator Plugin 2')\n\nIf we put it before the original authenticator::\n\n  >>> pau.authenticatorPlugins = (\n  ...     'My Authenticator Plugin 2',\n  ...     'My Authenticator Plugin')\n\nThen it will be given the first opportunity to authenticate a request::\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode'))\n  Principal('xyz_black')\n\nIf neither plugins can authenticate, pau returns None::\n\n  >>> print(pau.authenticate(TestRequest(credentials='let me in!!')))\n  None\n\nWhen we change the order of the authenticator plugins::\n\n  >>> pau.authenticatorPlugins = (\n  ...     'My Authenticator Plugin',\n  ...     'My Authenticator Plugin 2')\n\nwe see that our original plugin is now acting first::\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode'))\n  Principal('xyz_bob')\n\nThe second plugin, however, gets a chance to authenticate if first does not::\n\n  >>> pau.authenticate(TestRequest(credentials='hiddenkey'))\n  Principal('xyz_white')\n\nMultiple Credentials Plugins\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs with with authenticators, we can specify multiple credentials plugins. To\nillustrate, we'll create a credentials plugin that extracts credentials from\na request form::\n\n  >>> @interface.implementer(interfaces.ICredentialsPlugin)\n  ... class FormCredentialsPlugin:\n  ...\n  ...     def extractCredentials(self, request):\n  ...         return request.form.get('my_credentials')\n  ...\n  ...     def challenge(self, request):\n  ...         pass\n  ...\n  ...     def logout(request):\n  ...         pass\n\n  >>> provideUtility(FormCredentialsPlugin(),\n  ...                name='Form Credentials Plugin')\n\nand insert the new credentials plugin before the existing plugin::\n\n  >>> pau.credentialsPlugins = (\n  ...     'Form Credentials Plugin',\n  ...     'My Credentials Plugin')\n\nThe PAU will use each plugin in order to try and obtain credentials from a\nrequest::\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode',\n  ...                              form={'my_credentials': 'hiddenkey'}))\n  Principal('xyz_white')\n\nIn this case, the first credentials plugin succeeded in getting credentials\nfrom the form and the second authenticator was able to authenticate the\ncredentials. Specifically, the PAU went through these steps:\n\n - Get credentials using 'Form Credentials Plugin'\n\n - Got 'hiddenkey' credentials using 'Form Credentials Plugin', try to\n   authenticate using 'My Authenticator Plugin'\n\n - Failed to authenticate 'hiddenkey' with 'My Authenticator Plugin', try\n   'My Authenticator Plugin 2'\n\n - Succeeded in authenticating with 'My Authenticator Plugin 2'\n\nLet's try a different scenario::\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode'))\n  Principal('xyz_bob')\n\nIn this case, the PAU went through these steps::\n\n  - Get credentials using 'Form Credentials Plugin'\n\n  - Failed to get credentials using 'Form Credentials Plugin', try\n    'My Credentials Plugin'\n\n  - Got 'scecretcode' credentials using 'My Credentials Plugin', try to\n    authenticate using 'My Authenticator Plugin'\n\n  - Succeeded in authenticating with 'My Authenticator Plugin'\n\nLet's try a slightly more complex scenario::\n\n  >>> pau.authenticate(TestRequest(credentials='hiddenkey',\n  ...                              form={'my_credentials': 'bogusvalue'}))\n  Principal('xyz_white')\n\nThis highlights PAU's ability to use multiple plugins for authentication:\n\n  - Get credentials using 'Form Credentials Plugin'\n\n  - Got 'bogusvalue' credentials using 'Form Credentials Plugin', try to\n    authenticate using 'My Authenticator Plugin'\n\n  - Failed to authenticate 'boguskey' with 'My Authenticator Plugin', try\n    'My Authenticator Plugin 2'\n\n  - Failed to authenticate 'boguskey' with 'My Authenticator Plugin 2' --\n    there are no more authenticators to try, so lets try the next credentials\n    plugin for some new credentials\n\n  - Get credentials using 'My Credentials Plugin'\n\n  - Got 'hiddenkey' credentials using 'My Credentials Plugin', try to\n    authenticate using 'My Authenticator Plugin'\n\n  - Failed to authenticate 'hiddenkey' using 'My Authenticator Plugin', try\n    'My Authenticator Plugin 2'\n\n  - Succeeded in authenticating with 'My Authenticator Plugin 2' (shouts and\n    cheers!)\n\n\nPrincipal Searching\n-------------------\n\nAs a component that provides IAuthentication, a PAU lets you lookup a\nprincipal with a principal ID. The PAU looks up a principal by delegating to\nits authenticators. In our example, none of the authenticators implement this\nsearch capability, so when we look for a principal::\n\n  >>> print(pau.getPrincipal('xyz_bob'))\n  Traceback (most recent call last):\n  zope.authentication.interfaces.PrincipalLookupError: bob\n\n  >>> print(pau.getPrincipal('white'))\n  Traceback (most recent call last):\n  zope.authentication.interfaces.PrincipalLookupError: white\n\n  >>> print(pau.getPrincipal('black'))\n  Traceback (most recent call last):\n  zope.authentication.interfaces.PrincipalLookupError: black\n\nFor a PAU to support search, it needs to be configured with one or more\nauthenticator plugins that support search. To illustrate, we'll create a new\nauthenticator::\n\n  >>> @interface.implementer(interfaces.IAuthenticatorPlugin)\n  ... class SearchableAuthenticatorPlugin:\n  ...\n  ...     def __init__(self):\n  ...         self.infos = {}\n  ...         self.ids = {}\n  ...\n  ...     def principalInfo(self, id):\n  ...         return self.infos.get(id)\n  ...\n  ...     def authenticateCredentials(self, credentials):\n  ...         id = self.ids.get(credentials)\n  ...         if id is not None:\n  ...             return self.infos[id]\n  ...\n  ...     def add(self, id, title, description, credentials):\n  ...         self.infos[id] = PrincipalInfo(id, title, description)\n  ...         self.ids[credentials] = id\n\nThis class is typical of an authenticator plugin. It can both authenticate\nprincipals and find principals given a ID. While there are cases\nwhere an authenticator may opt to not perform one of these two functions, they\nare less typical.\n\nAs with any plugin, we need to register it as a utility::\n\n  >>> searchable = SearchableAuthenticatorPlugin()\n  >>> provideUtility(searchable, name='Searchable Authentication Plugin')\n\nWe'll now configure the PAU to use only the searchable authenticator::\n\n  >>> pau.authenticatorPlugins = ('Searchable Authentication Plugin',)\n\nand add some principals to the authenticator::\n\n  >>> searchable.add('bob', 'Bob', 'A nice guy', 'b0b')\n  >>> searchable.add('white', 'White Spy', 'Sneaky', 'deathtoblack')\n\nNow when we ask the PAU to find a principal::\n\n  >>> pau.getPrincipal('xyz_bob')\n  Principal('xyz_bob')\n\nbut only those it knows about::\n\n  >>> print(pau.getPrincipal('black'))\n  Traceback (most recent call last):\n  zope.authentication.interfaces.PrincipalLookupError: black\n\nFound Principal Creates Events\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs evident in the authenticator's 'createFoundPrincipal' method (see above),\na FoundPrincipalCreatedEvent is published when the authenticator finds a\nprincipal on behalf of PAU's 'getPrincipal'::\n\n  >>> clearEvents()\n  >>> principal = pau.getPrincipal('xyz_white')\n  >>> principal\n  Principal('xyz_white')\n\n  >>> [event] = getEvents(interfaces.IFoundPrincipalCreated)\n  >>> event.principal is principal\n  True\n  >>> event.info\n  PrincipalInfo('white')\n\nThe info has an authenticatorPlugin, but no credentialsPlugin, since none was\nused::\n\n  >>> event.info.credentialsPlugin is None\n  True\n  >>> event.info.authenticatorPlugin is searchable\n  True\n\nAs we have seen with authenticated principals, it is common to subscribe to\nprincipal created events to add information to the newly created principal.\nIn this case, we need to subscribe to IFoundPrincipalCreated events::\n\n  >>> provideHandler(add_info, [interfaces.IFoundPrincipalCreated])\n\nNow when a principal is created as a result of a search, it's title and\ndescription will be set (by the add_info handler function).\n\nMultiple Authenticator Plugins\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAs with the other operations we've seen, the PAU uses multiple plugins to\nfind a principal. If the first authenticator plugin can't find the requested\nprincipal, the next plugin is used, and so on.\n\nTo illustrate, we'll create and register a second searchable authenticator::\n\n  >>> searchable2 = SearchableAuthenticatorPlugin()\n  >>> provideUtility(searchable2, name='Searchable Authentication Plugin 2')\n\nand add a principal to it::\n\n  >>> searchable.add('black', 'Black Spy', 'Also sneaky', 'deathtowhite')\n\nWhen we configure the PAU to use both searchable authenticators (note the\norder)::\n\n  >>> pau.authenticatorPlugins = (\n  ...     'Searchable Authentication Plugin 2',\n  ...     'Searchable Authentication Plugin')\n\nwe see how the PAU uses both plugins::\n\n  >>> pau.getPrincipal('xyz_white')\n  Principal('xyz_white')\n\n  >>> pau.getPrincipal('xyz_black')\n  Principal('xyz_black')\n\nIf more than one plugin know about the same principal ID, the first plugin is\nused and the remaining are not delegated to. To illustrate, we'll add\nanother principal with the same ID as an existing principal::\n\n  >>> searchable2.add('white', 'White Rider', '', 'r1der')\n  >>> pau.getPrincipal('xyz_white').title\n  'White Rider'\n\nIf we change the order of the plugins::\n\n  >>> pau.authenticatorPlugins = (\n  ...     'Searchable Authentication Plugin',\n  ...     'Searchable Authentication Plugin 2')\n\nwe get a different principal for ID 'white'::\n\n  >>> pau.getPrincipal('xyz_white').title\n  'White Spy'\n\n\nIssuing a Challenge\n-------------------\n\nPart of PAU's IAuthentication contract is to challenge the user for\ncredentials when its 'unauthorized' method is called. The need for this\nfunctionality is driven by the following use case:\n\n  - A user attempts to perform an operation he is not authorized to perform.\n\n  - A handler responds to the unauthorized error by calling IAuthentication\n    'unauthorized'.\n\n  - The authentication component (in our case, a PAU) issues a challenge to\n    the user to collect new credentials (typically in the form of logging in\n    as a new user).\n\nThe PAU handles the credentials challenge by delegating to its credentials\nplugins.\n\nCurrently, the PAU is configured with the credentials plugins that don't\nperform any action when asked to challenge (see above the 'challenge' methods).\n\nTo illustrate challenges, we'll subclass an existing credentials plugin and\ndo something in its 'challenge'::\n\n  >>> class LoginFormCredentialsPlugin(FormCredentialsPlugin):\n  ...\n  ...     def __init__(self, loginForm):\n  ...         self.loginForm = loginForm\n  ...\n  ...     def challenge(self, request):\n  ...         request.response.redirect(self.loginForm)\n  ...         return True\n\nThis plugin handles a challenge by redirecting the response to a login form.\nIt returns True to signal to the PAU that it handled the challenge.\n\nWe will now create and register a couple of these plugins::\n\n  >>> provideUtility(LoginFormCredentialsPlugin('simplelogin.html'),\n  ...                name='Simple Login Form Plugin')\n\n  >>> provideUtility(LoginFormCredentialsPlugin('advancedlogin.html'),\n  ...                name='Advanced Login Form Plugin')\n\nand configure the PAU to use them::\n\n  >>> pau.credentialsPlugins = (\n  ...     'Simple Login Form Plugin',\n  ...     'Advanced Login Form Plugin')\n\nNow when we call 'unauthorized' on the PAU::\n\n  >>> request = TestRequest()\n  >>> pau.unauthorized(id=None, request=request)\n\nwe see that the user is redirected to the simple login form::\n\n  >>> request.response.getStatus()\n  302\n  >>> request.response.getHeader('location')\n  'simplelogin.html'\n\nWe can change the challenge policy by reordering the plugins::\n\n  >>> pau.credentialsPlugins = (\n  ...     'Advanced Login Form Plugin',\n  ...     'Simple Login Form Plugin')\n\nNow when we call 'unauthorized'::\n\n  >>> request = TestRequest()\n  >>> pau.unauthorized(id=None, request=request)\n\nthe advanced plugin is used because it's first::\n\n  >>> request.response.getStatus()\n  302\n  >>> request.response.getHeader('location')\n  'advancedlogin.html'\n\nChallenge Protocols\n~~~~~~~~~~~~~~~~~~~\n\nSometimes, we want multiple challengers to work together. For example, the\nHTTP specification allows multiple challenges to be issued in a response. A\nchallenge plugin can provide a `challengeProtocol` attribute that effectively\ngroups related plugins together for challenging. If a plugin returns `True`\nfrom its challenge and provides a non-None challengeProtocol, subsequent\nplugins in the credentialsPlugins list that have the same challenge protocol\nwill also be used to challenge.\n\nWithout a challengeProtocol, only the first plugin to succeed in a challenge\nwill be used.\n\nLet's look at an example. We'll define a new plugin that specifies an\n'X-Challenge' protocol::\n\n  >>> class XChallengeCredentialsPlugin(FormCredentialsPlugin):\n  ...\n  ...     challengeProtocol = 'X-Challenge'\n  ...\n  ...     def __init__(self, challengeValue):\n  ...         self.challengeValue = challengeValue\n  ...\n  ...     def challenge(self, request):\n  ...         value = self.challengeValue\n  ...         existing = request.response.getHeader('X-Challenge', '')\n  ...         if existing:\n  ...             value += ' ' + existing\n  ...         request.response.setHeader('X-Challenge', value)\n  ...         return True\n\nand register a couple instances as utilities::\n\n  >>> provideUtility(XChallengeCredentialsPlugin('basic'),\n  ...                name='Basic X-Challenge Plugin')\n\n  >>> provideUtility(XChallengeCredentialsPlugin('advanced'),\n  ...                name='Advanced X-Challenge Plugin')\n\nWhen we use both plugins with the PAU::\n\n  >>> pau.credentialsPlugins = (\n  ...     'Basic X-Challenge Plugin',\n  ...     'Advanced X-Challenge Plugin')\n\nand call 'unauthorized'::\n\n  >>> request = TestRequest()\n  >>> pau.unauthorized(None, request)\n\nwe see that both plugins participate in the challange, rather than just the\nfirst plugin::\n\n  >>> request.response.getHeader('X-Challenge')\n  'advanced basic'\n\n\nPluggable-Authentication Prefixes\n---------------------------------\n\nPrincipal ids are required to be unique system wide. Plugins will often provide\noptions for providing id prefixes, so that different sets of plugins provide\nunique ids within a PAU. If there are multiple pluggable-authentication\nutilities in a system, it's a good idea to give each PAU a unique prefix, so\nthat principal ids from different PAUs don't conflict. We can provide a prefix\nwhen a PAU is created::\n\n  >>> pau = authentication.PluggableAuthentication('mypau_')\n  >>> pau.credentialsPlugins = ('My Credentials Plugin', )\n  >>> pau.authenticatorPlugins = ('My Authenticator Plugin', )\n\nWhen we create a request and try to authenticate::\n\n  >>> pau.authenticate(TestRequest(credentials='secretcode'))\n  Principal('mypau_bob')\n\nNote that now, our principal's id has the pluggable-authentication\nutility prefix.\n\nWe can still lookup a principal, as long as we supply the prefix::\n\n  >> pau.getPrincipal('mypas_42')\n  Principal('mypas_42', \"{'domain': 42}\")\n\n  >> pau.getPrincipal('mypas_41')\n  OddPrincipal('mypas_41', \"{'int': 41}\")\n\n\nSearching\n---------\n\nPAU implements ISourceQueriables::\n\n  >>> from zope.schema.interfaces import ISourceQueriables\n  >>> ISourceQueriables.providedBy(pau)\n  True\n\nThis means a PAU can be used in a principal source vocabulary (Zope provides a\nsophisticated searching UI for principal sources).\n\nAs we've seen, a PAU uses each of its authenticator plugins to locate a\nprincipal with a given ID. However, plugins may also provide the interface\nIQuerySchemaSearch to indicate they can be used in the PAU's principal search\nscheme.\n\nCurrently, our list of authenticators::\n\n  >>> pau.authenticatorPlugins\n  ('My Authenticator Plugin',)\n\ndoes not include a queriable authenticator. PAU cannot therefore provide any\nqueriables::\n\n  >>> list(pau.getQueriables())\n  []\n\nBefore we illustrate how an authenticator is used by the PAU to search for\nprincipals, we need to setup an adapter used by PAU::\n\n  >>> import zope.app.authentication.authentication\n  >>> provideAdapter(\n  ...     authentication.authentication.QuerySchemaSearchAdapter,\n  ...     provides=interfaces.IQueriableAuthenticator)\n\nThis adapter delegates search responsibility to an authenticator, but prepends\nthe PAU prefix to any principal IDs returned in a search.\n\nNext, we'll create a plugin that provides a search interface::\n\n  >>> @interface.implementer(interfaces.IQuerySchemaSearch)\n  ... class QueriableAuthenticatorPlugin(MyAuthenticatorPlugin):\n  ...\n  ...     schema = None\n  ...\n  ...     def search(self, query, start=None, batch_size=None):\n  ...         yield 'foo'\n  ...\n\nand install it as a plugin::\n\n  >>> plugin = QueriableAuthenticatorPlugin()\n  >>> provideUtility(plugin,\n  ...                provides=interfaces.IAuthenticatorPlugin,\n  ...                name='Queriable')\n  >>> pau.authenticatorPlugins += ('Queriable',)\n\nNow, the PAU provides a single queriable::\n\n  >>> list(pau.getQueriables()) # doctest: +ELLIPSIS\n  [('Queriable', ...QuerySchemaSearchAdapter object...)]\n\nWe can use this queriable to search for our principal::\n\n  >>> queriable = list(pau.getQueriables())[0][1]\n  >>> list(queriable.search('not-used'))\n  ['mypau_foo']\n\nNote that the resulting principal ID includes the PAU prefix. Were we to search\nthe plugin directly::\n\n  >>> list(plugin.search('not-used'))\n  ['foo']\n\nThe result does not include the PAU prefix. The prepending of the prefix is\nhandled by the PluggableAuthenticationQueriable.\n\n\nQueryiable plugins can provide the ILocation interface. In this case the\nQuerySchemaSearchAdapter's __parent__ is the same as the __parent__ of the\nplugin::\n\n  >>> import zope.location.interfaces\n  >>> @interface.implementer(zope.location.interfaces.ILocation)\n  ... class LocatedQueriableAuthenticatorPlugin(QueriableAuthenticatorPlugin):\n  ...\n  ...     __parent__ = __name__ = None\n  ...\n  >>> import zope.site.hooks\n  >>> site = zope.site.hooks.getSite()\n  >>> plugin = LocatedQueriableAuthenticatorPlugin()\n  >>> plugin.__parent__ = site\n  >>> plugin.__name__ = 'localname'\n  >>> provideUtility(plugin,\n  ...                provides=interfaces.IAuthenticatorPlugin,\n  ...                name='location-queriable')\n  >>> pau.authenticatorPlugins = ('location-queriable',)\n\nWe have one queriable again::\n\n  >>> queriables = list(pau.getQueriables())\n  >>> queriables  # doctest: +ELLIPSIS\n  [('location-queriable', ...QuerySchemaSearchAdapter object...)]\n\nThe queriable's __parent__ is the site as set above::\n\n  >>> queriable = queriables[0][1]\n  >>> queriable.__parent__ is site\n  True\n\nIf the queriable provides ILocation but is not actually locatable (i.e. the\nparent is None) the pau itself becomes the parent::\n\n\n  >>> plugin = LocatedQueriableAuthenticatorPlugin()\n  >>> provideUtility(plugin,\n  ...                provides=interfaces.IAuthenticatorPlugin,\n  ...                name='location-queriable-wo-parent')\n  >>> pau.authenticatorPlugins = ('location-queriable-wo-parent',)\n\nWe have one queriable again::\n\n  >>> queriables = list(pau.getQueriables())\n  >>> queriables  # doctest: +ELLIPSIS\n  [('location-queriable-wo-parent', ...QuerySchemaSearchAdapter object...)]\n\nAnd the parent is the pau::\n\n  >>> queriable = queriables[0][1]\n  >>> queriable.__parent__  # doctest: +ELLIPSIS\n  <zope.pluggableauth.authentication.PluggableAuthentication object ...>\n  >>> queriable.__parent__ is pau\n  True\n\n\n================\nPrincipal Folder\n================\n\nPrincipal folders contain principal-information objects that contain principal\ninformation. We create an internal principal using the `InternalPrincipal`\nclass:\n\n  >>> from zope.app.authentication.principalfolder import InternalPrincipal\n  >>> p1 = InternalPrincipal('login1', '123', \"Principal 1\",\n  ...     passwordManagerName=\"SHA1\")\n  >>> p2 = InternalPrincipal('login2', '456', \"The Other One\")\n\nand add them to a principal folder:\n\n  >>> from zope.app.authentication.principalfolder import PrincipalFolder\n  >>> principals = PrincipalFolder('principal.')\n  >>> principals['p1'] = p1\n  >>> principals['p2'] = p2\n\nAuthentication\n--------------\n\nPrincipal folders provide the `IAuthenticatorPlugin` interface. When we\nprovide suitable credentials:\n\n  >>> from pprint import pprint\n  >>> principals.authenticateCredentials({'login': 'login1', 'password': '123'})\n  PrincipalInfo(u'principal.p1')\n\nWe get back a principal id and supplementary information, including the\nprincipal title and description.  Note that the principal id is a concatenation\nof the principal-folder prefix and the name of the principal-information object\nwithin the folder.\n\nNone is returned if the credentials are invalid:\n\n  >>> principals.authenticateCredentials({'login': 'login1',\n  ...                                     'password': '1234'})\n  >>> principals.authenticateCredentials(42)\n\nSearch\n------\n\nPrincipal folders also provide the IQuerySchemaSearch interface.  This\nsupports both finding principal information based on their ids:\n\n  >>> principals.principalInfo('principal.p1')\n  PrincipalInfo('principal.p1')\n\n  >>> principals.principalInfo('p1')\n\nand searching for principals based on a search string:\n\n  >>> list(principals.search({'search': 'other'}))\n  [u'principal.p2']\n\n  >>> list(principals.search({'search': 'OTHER'}))\n  [u'principal.p2']\n\n  >>> list(principals.search({'search': ''}))\n  [u'principal.p1', u'principal.p2']\n\n  >>> list(principals.search({'search': 'eek'}))\n  []\n\n  >>> list(principals.search({}))\n  []\n\nIf there are a large number of matches:\n\n  >>> for i in range(20):\n  ...     i = str(i)\n  ...     p = InternalPrincipal('l'+i, i, \"Dude \"+i)\n  ...     principals[i] = p\n\n  >>> pprint(list(principals.search({'search': 'D'})))\n  [u'principal.0',\n   u'principal.1',\n   u'principal.10',\n   u'principal.11',\n   u'principal.12',\n   u'principal.13',\n   u'principal.14',\n   u'principal.15',\n   u'principal.16',\n   u'principal.17',\n   u'principal.18',\n   u'principal.19',\n   u'principal.2',\n   u'principal.3',\n   u'principal.4',\n   u'principal.5',\n   u'principal.6',\n   u'principal.7',\n   u'principal.8',\n   u'principal.9']\n\nWe can use batching parameters to specify a subset of results:\n\n  >>> pprint(list(principals.search({'search': 'D'}, start=17)))\n  [u'principal.7', u'principal.8', u'principal.9']\n\n  >>> pprint(list(principals.search({'search': 'D'}, batch_size=5)))\n  [u'principal.0',\n   u'principal.1',\n   u'principal.10',\n   u'principal.11',\n   u'principal.12']\n\n  >>> pprint(list(principals.search({'search': 'D'}, start=5, batch_size=5)))\n  [u'principal.13',\n   u'principal.14',\n   u'principal.15',\n   u'principal.16',\n   u'principal.17']\n\nThere is an additional method that allows requesting the principal id\nassociated with a login id.  The method raises KeyError when there is\nno associated principal::\n\n  >>> principals.getIdByLogin(\"not-there\")\n  Traceback (most recent call last):\n  KeyError: 'not-there'\n\nIf there is a matching principal, the id is returned::\n\n  >>> principals.getIdByLogin(\"login1\")\n  u'principal.p1'\n\nChanging credentials\n--------------------\n\nCredentials can be changed by modifying principal-information objects:\n\n  >>> p1.login = 'bob'\n  >>> p1.password = 'eek'\n\n  >>> principals.authenticateCredentials({'login': 'bob', 'password': 'eek'})\n  PrincipalInfo(u'principal.p1')\n\n  >>> principals.authenticateCredentials({'login': 'login1',\n  ...                                     'password': 'eek'})\n\n  >>> principals.authenticateCredentials({'login': 'bob',\n  ...                                     'password': '123'})\n\n\nIt is an error to try to pick a login name that is already taken:\n\n  >>> p1.login = 'login2'\n  Traceback (most recent call last):\n  ...\n  ValueError: Principal Login already taken!\n\nIf such an attempt is made, the data are unchanged:\n\n  >>> principals.authenticateCredentials({'login': 'bob', 'password': 'eek'})\n  PrincipalInfo(u'principal.p1')\n\nRemoving principals\n-------------------\n\nOf course, if a principal is removed, we can no-longer authenticate it:\n\n  >>> del principals['p1']\n  >>> principals.authenticateCredentials({'login': 'bob',\n  ...                                     'password': 'eek'})\n\n\n============\nVocabularies\n============\n\nThe vocabulary module provides vocabularies for the authenticator plugins and\nthe credentials plugins.\n\nThe options should include the unique names of all of the plugins that provide\nthe appropriate interface (interfaces.ICredentialsPlugin or\ninterfaces.IAuthentiatorPlugin, respectively) for the current context-- which\nis expected to be a pluggable authentication utility, hereafter referred to as\na PAU.\n\nThese names may be for objects contained within the PAU (\"contained\nplugins\"), or may be utilities registered for the specified interface,\nfound in the context of the PAU (\"utility plugins\").  Contained\nplugins mask utility plugins of the same name.  They also may be names\ncurrently selected in the PAU that do not actually have a\ncorresponding plugin at this time.\n\nHere is a short example of how the vocabulary should work.  Let's say we're\nworking with authentication plugins.  We'll create some faux\nauthentication plugins, and register some of them as utilities and put\nothers in a faux PAU.\n\n    >>> from zope.app.authentication import interfaces\n    >>> from zope import interface, component\n    >>> @interface.implementer(interfaces.IAuthenticatorPlugin)\n    ... class DemoPlugin(object):\n    ...\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...\n    >>> utility_plugins = dict(\n    ...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(4))\n    >>> contained_plugins = dict(\n    ...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(1, 5))\n    >>> sorted(utility_plugins.keys())\n    [0, 1, 2, 3]\n    >>> for p in utility_plugins.values():\n    ...     component.provideUtility(p, name=p.name)\n    ...\n    >>> sorted(contained_plugins.keys()) # 1 will mask utility plugin 1\n    [1, 2, 3, 4]\n    >>> @interface.implementer(interfaces.IPluggableAuthentication)\n    ... class DemoAuth(dict):\n    ...\n    ...     def __init__(self, *args, **kwargs):\n    ...         super(DemoAuth, self).__init__(*args, **kwargs)\n    ...         self.authenticatorPlugins = (u'Plugin 3', u'Plugin X')\n    ...         self.credentialsPlugins = (u'Plugin 4', u'Plugin X')\n    ...\n    >>> auth = DemoAuth((p.name, p) for p in contained_plugins.values())\n\n    >>> @component.adapter(interface.Interface)\n    ... @interface.implementer(component.IComponentLookup)\n    ... def getSiteManager(context):\n    ...     return component.getGlobalSiteManager()\n    ...\n    >>> component.provideAdapter(getSiteManager)\n\nWe are now ready to create a vocabulary that we can use.  The context is\nour faux authentication utility, `auth`.\n\n    >>> from zope.app.authentication import vocabulary\n    >>> vocab = vocabulary.authenticatorPlugins(auth)\n\nIterating over the vocabulary results in all of the terms, in a relatively\narbitrary order of their names.  (This vocabulary should typically use a\nwidget that sorts values on the basis of localized collation order of the\nterm titles.)\n\n    >>> [term.value for term in vocab] # doctest: +NORMALIZE_WHITESPACE\n    [u'Plugin 0', u'Plugin 1', u'Plugin 2', u'Plugin 3', u'Plugin 4',\n     u'Plugin X']\n\nSimilarly, we can use `in` to test for the presence of values in the\nvocabulary.\n\n    >>> ['Plugin %s' % i in vocab for i in range(-1, 6)]\n    [False, True, True, True, True, True, False]\n    >>> 'Plugin X' in vocab\n    True\n\nThe length reports the expected value.\n\n    >>> len(vocab)\n    6\n\nOne can get a term for a given value using `getTerm()`; its token, in\nturn, should also return the same effective term from `getTermByToken`.\n\n    >>> values = ['Plugin 0', 'Plugin 1', 'Plugin 2', 'Plugin 3', 'Plugin 4',\n    ...           'Plugin X']\n    >>> for val in values:\n    ...     term = vocab.getTerm(val)\n    ...     assert term.value == val\n    ...     term2 = vocab.getTermByToken(term.token)\n    ...     assert term2.token == term.token\n    ...     assert term2.value == val\n    ...\n\nThe terms have titles, which are message ids that show the plugin title or id\nand whether the plugin is a utility or just contained in the auth utility.\nWe'll give one of the plugins a dublin core title just to show the\nfunctionality.\n\n    >>> import zope.dublincore.interfaces\n    >>> class ISpecial(interface.Interface):\n    ...     pass\n    ...\n    >>> interface.directlyProvides(contained_plugins[1], ISpecial)\n    >>> @interface.implementer(zope.dublincore.interfaces.IDCDescriptiveProperties)\n    ... @component.adapter(ISpecial)\n    ... class DemoDCAdapter(object):\n    ...     def __init__(self, context):\n    ...         pass\n    ...     title = u'Special Title'\n    ...\n    >>> component.provideAdapter(DemoDCAdapter)\n\nWe need to regenerate the vocabulary, since it calculates all of its data at\nonce.\n\n    >>> vocab = vocabulary.authenticatorPlugins(auth)\n\nNow we'll check the titles.  We'll have to translate them to see what we\nexpect.\n\n    >>> from zope import i18n\n    >>> import pprint\n    >>> pprint.pprint([i18n.translate(term.title) for term in vocab])\n    [u'Plugin 0 (a utility)',\n     u'Special Title (in contents)',\n     u'Plugin 2 (in contents)',\n     u'Plugin 3 (in contents)',\n     u'Plugin 4 (in contents)',\n     u'Plugin X (not found; deselecting will remove)']\n\ncredentialsPlugins\n------------------\n\nFor completeness, we'll do the same review of the credentialsPlugins.\n\n    >>> @interface.implementer(interfaces.ICredentialsPlugin)\n    ... class DemoPlugin(object):\n    ...\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...\n    >>> utility_plugins = dict(\n    ...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(4))\n    >>> contained_plugins = dict(\n    ...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(1, 5))\n    >>> for p in utility_plugins.values():\n    ...     component.provideUtility(p, name=p.name)\n    ...\n    >>> auth = DemoAuth((p.name, p) for p in contained_plugins.values())\n    >>> vocab = vocabulary.credentialsPlugins(auth)\n\nIterating over the vocabulary results in all of the terms, in a relatively\narbitrary order of their names.  (This vocabulary should typically use a\nwidget that sorts values on the basis of localized collation order of the term\ntitles.) Similarly, we can use `in` to test for the presence of values in the\nvocabulary. The length reports the expected value.\n\n    >>> [term.value for term in vocab] # doctest: +NORMALIZE_WHITESPACE\n    [u'Plugin 0', u'Plugin 1', u'Plugin 2', u'Plugin 3', u'Plugin 4',\n     u'Plugin X']\n    >>> ['Plugin %s' % i in vocab for i in range(-1, 6)]\n    [False, True, True, True, True, True, False]\n    >>> 'Plugin X' in vocab\n    True\n    >>> len(vocab)\n    6\n\nOne can get a term for a given value using `getTerm()`; its token, in\nturn, should also return the same effective term from `getTermByToken`.\n\n    >>> values = ['Plugin 0', 'Plugin 1', 'Plugin 2', 'Plugin 3', 'Plugin 4',\n    ...           'Plugin X']\n    >>> for val in values:\n    ...     term = vocab.getTerm(val)\n    ...     assert term.value == val\n    ...     term2 = vocab.getTermByToken(term.token)\n    ...     assert term2.token == term.token\n    ...     assert term2.value == val\n    ...\n\nThe terms have titles, which are message ids that show the plugin title or id\nand whether the plugin is a utility or just contained in the auth utility.\nWe'll give one of the plugins a dublin core title just to show the\nfunctionality. We need to regenerate the vocabulary, since it calculates all\nof its data at once. Then we'll check the titles.  We'll have to translate\nthem to see what we expect.\n\n    >>> interface.directlyProvides(contained_plugins[1], ISpecial)\n    >>> vocab = vocabulary.credentialsPlugins(auth)\n    >>> pprint.pprint([i18n.translate(term.title) for term in vocab])\n    [u'Plugin 0 (a utility)',\n     u'Special Title (in contents)',\n     u'Plugin 2 (in contents)',\n     u'Plugin 3 (in contents)',\n     u'Plugin 4 (in contents)',\n     u'Plugin X (not found; deselecting will remove)']\n\n\n=======\nChanges\n=======\n\n4.0.0 (2017-05-02)\n------------------\n\n- Drop test dependency on zope.app.zcmlfiles and zope.app.testing.\n\n- Drop explicit dependency on ZODB3.\n\n- Add support for Python 3.4, 3.5 and 3.6, and PyPy.\n\n\n3.9 (2010-10-18)\n----------------\n\n* Move concrete IAuthenticatorPlugin implementations to\n  zope.pluggableauth.plugins. Leave backwards compatibility imports.\n\n* Use zope.formlib throughout to lift the dependency on zope.app.form. As it\n  turns out, zope.app.form is still a indirect test dependency though.\n\n3.8.0 (2010-09-25)\n------------------\n\n* Using python's ``doctest`` module instead of deprecated\n  ``zope.testing.doctest[unit]``.\n\n* Moved the following views from `zope.app.securitypolicy` here, to inverse\n  dependency between these two packages, as `zope.app.securitypolicy`\n  deprecated in ZTK 1.0:\n\n  - ``@@grant.html``\n  - ``@@AllRolePermissions.html``\n  - ``@@RolePermissions.html``\n  - ``@@RolesWithPermission.html``\n\n3.7.1 (2010-02-11)\n------------------\n\n* Using the new `principalfactories.zcml` file, from ``zope.pluggableauth``,\n  to avoid duplication errors, in the adapters registration.\n\n3.7.0 (2010-02-08)\n------------------\n\n* The Pluggable Authentication utility has been severed and released\n  in a standalone package: `zope.pluggableauth`. We are now using this\n  new package, providing backward compatibility imports to assure a\n  smooth transition.\n\n3.6.2 (2010-01-05)\n------------------\n\n* Fix tests by using zope.login, and require new zope.publisher 3.12.\n\n3.6.1 (2009-10-07)\n------------------\n\n* Fix ftesting.zcml due to ``zope.securitypolicy`` update.\n\n* Don't use ``zope.app.testing.ztapi`` in tests, use zope.component's\n  testing functions instead.\n\n* Fix functional tests and stop using port 8081. Redirecting to\n  different port without trusted flag is not allowed.\n\n3.6.0 (2009-03-14)\n------------------\n\n* Separate the presentation template and camefrom/redirection logic for the\n  ``loginForm.html`` view. Now the logic is contained in the\n  ``zope.app.authentication.browser.loginform.LoginForm`` class.\n\n* Fix login form redirection failure in some cases with Python 2.6.\n\n* Use the new ``zope.authentication`` package instead of ``zope.app.security``.\n\n* The \"Password Manager Names\" vocabulary and simple password manager registry\n  were moved to the ``zope.password`` package.\n\n* Remove deprecated code.\n\n3.5.0 (2009-03-06)\n------------------\n\n* Split password manager functionality off to the new ``zope.password``\n  package. Backward-compatibility imports are left in place.\n\n* Use ``zope.site`` instead of ``zope.app.component``. (Browser code still\n  needs ``zope.app.component`` as it depends on view classes of this\n  package.)\n\n3.5.0a2 (2009-02-01)\n--------------------\n\n* Make old encoded passwords really work.\n\n3.5.0a1 (2009-01-31)\n--------------------\n\n* Use ``zope.container`` instead of ``zope.app.container``. (Browser code\n  still needs ``zope.app.container`` as it depends on view classes of this\n  package.)\n\n* Encoded passwords are now stored with a prefix ({MD5}, {SHA1},\n  {SSHA}) indicating the used encoding schema. Old (encoded) passwords\n  can still be used.\n\n* Add an SSHA password manager that is compatible with standard LDAP\n  passwords. As this encoding gives better security agains dictionary\n  attacks, users are encouraged to switch to this new password schema.\n\n* InternalPrincipal now uses SSHA password manager by default.\n\n3.4.4 (2008-12-12)\n------------------\n\n* Depend on zope.session instead of zope.app.session. The first one\n  currently has all functionality we need.\n* Fix deprecation warnings for ``md5`` and ``sha`` on Python 2.6.\n\n3.4.3 (2008-08-07)\n------------------\n\n* No changes. Retag for correct release on PyPI.\n\n3.4.2 (2008-07-09)\n-------------------\n\n* Make it compatible with zope.app.container 3.6.1 and 3.5.4 changes,\n  Changed ``super(BTreeContainer, self).__init__()`` to\n  ``super(GroupFolder, self).__init__()`` in ``GroupFolder`` class.\n\n3.4.1 (2007-10-24)\n------------------\n\n* Avoid deprecation warning.\n\n3.4.0 (2007-10-11)\n------------------\n\n* Updated package meta-data.\n\n3.4.0b1 (2007-09-27)\n--------------------\n\n* First release independent of Zope.", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/zopefoundation/zope.app.authentication", "keywords": "zope3 authentication pluggable principal group", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "zope.app.authentication", "package_url": "https://pypi.org/project/zope.app.authentication/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/zope.app.authentication/", "project_urls": {"Homepage": "http://github.com/zopefoundation/zope.app.authentication"}, "release_url": "https://pypi.org/project/zope.app.authentication/4.0.0/", "requires_dist": ["setuptools", "zope.app.component (>=4.0.0)", "zope.app.container (>=4.0.0)", "zope.authentication", "zope.component", "zope.container", "zope.dublincore", "zope.event", "zope.exceptions", "zope.formlib (>=4.0.2)", "zope.i18n", "zope.i18nmessageid", "zope.interface", "zope.location", "zope.password (>=3.5.1)", "zope.pluggableauth (>=2.2.0)", "zope.schema", "zope.security", "zope.traversing", "zope.app.basicskin (>=4.0); extra == 'test'", "zope.app.form (>=5.0); extra == 'test'", "zope.app.rotterdam (>=4.0); extra == 'test'", "zope.app.schema; extra == 'test'", "zope.app.security (>=4.0); extra == 'test'", "zope.app.wsgi; extra == 'test'", "zope.formlib; extra == 'test'", "zope.login; extra == 'test'", "zope.principalannotation; extra == 'test'", "zope.publisher; extra == 'test'", "zope.publisher (>=4.3.1); extra == 'test'", "zope.securitypolicy; extra == 'test'", "zope.session; extra == 'test'", "zope.site; extra == 'test'", "zope.testbrowser (>=5.2); extra == 'test'", "zope.testing; extra == 'test'", "zope.testrunner; extra == 'test'"], "requires_python": "", "summary": "Principals and groups management for the pluggable authentication utility", "version": "4.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides a flexible and pluggable authentication utility for Zope\n3, using <cite>zope.pluggableauth</cite>. Several common plugins are provided.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#pluggable-authentication-utility\" id=\"id17\" rel=\"nofollow\">Pluggable-Authentication Utility</a><ul>\n<li><a href=\"#authentication\" id=\"id18\" rel=\"nofollow\">Authentication</a><ul>\n<li><a href=\"#simple-credentials-plugin\" id=\"id19\" rel=\"nofollow\">Simple Credentials Plugin</a></li>\n<li><a href=\"#simple-authenticator-plugin\" id=\"id20\" rel=\"nofollow\">Simple Authenticator Plugin</a></li>\n<li><a href=\"#principal-factories\" id=\"id21\" rel=\"nofollow\">Principal Factories</a></li>\n<li><a href=\"#configuring-a-pau\" id=\"id22\" rel=\"nofollow\">Configuring a PAU</a></li>\n<li><a href=\"#using-the-pau-to-authenticate\" id=\"id23\" rel=\"nofollow\">Using the PAU to Authenticate</a></li>\n<li><a href=\"#authenticated-principal-creates-events\" id=\"id24\" rel=\"nofollow\">Authenticated Principal Creates Events</a></li>\n<li><a href=\"#multiple-authenticator-plugins\" id=\"id25\" rel=\"nofollow\">Multiple Authenticator Plugins</a></li>\n<li><a href=\"#multiple-credentials-plugins\" id=\"id26\" rel=\"nofollow\">Multiple Credentials Plugins</a></li>\n</ul>\n</li>\n<li><a href=\"#principal-searching\" id=\"id27\" rel=\"nofollow\">Principal Searching</a><ul>\n<li><a href=\"#found-principal-creates-events\" id=\"id28\" rel=\"nofollow\">Found Principal Creates Events</a></li>\n<li><a href=\"#id1\" id=\"id29\" rel=\"nofollow\">Multiple Authenticator Plugins</a></li>\n</ul>\n</li>\n<li><a href=\"#issuing-a-challenge\" id=\"id30\" rel=\"nofollow\">Issuing a Challenge</a><ul>\n<li><a href=\"#challenge-protocols\" id=\"id31\" rel=\"nofollow\">Challenge Protocols</a></li>\n</ul>\n</li>\n<li><a href=\"#pluggable-authentication-prefixes\" id=\"id32\" rel=\"nofollow\">Pluggable-Authentication Prefixes</a></li>\n<li><a href=\"#searching\" id=\"id33\" rel=\"nofollow\">Searching</a></li>\n</ul>\n</li>\n<li><a href=\"#principal-folder\" id=\"id34\" rel=\"nofollow\">Principal Folder</a><ul>\n<li><a href=\"#id2\" id=\"id35\" rel=\"nofollow\">Authentication</a></li>\n<li><a href=\"#search\" id=\"id36\" rel=\"nofollow\">Search</a></li>\n<li><a href=\"#changing-credentials\" id=\"id37\" rel=\"nofollow\">Changing credentials</a></li>\n<li><a href=\"#removing-principals\" id=\"id38\" rel=\"nofollow\">Removing principals</a></li>\n</ul>\n</li>\n<li><a href=\"#vocabularies\" id=\"id39\" rel=\"nofollow\">Vocabularies</a><ul>\n<li><a href=\"#credentialsplugins\" id=\"id40\" rel=\"nofollow\">credentialsPlugins</a></li>\n</ul>\n</li>\n<li><a href=\"#changes\" id=\"id41\" rel=\"nofollow\">Changes</a><ul>\n<li><a href=\"#id3\" id=\"id42\" rel=\"nofollow\">4.0.0 (2017-05-02)</a></li>\n<li><a href=\"#id4\" id=\"id43\" rel=\"nofollow\">3.9 (2010-10-18)</a></li>\n<li><a href=\"#id5\" id=\"id44\" rel=\"nofollow\">3.8.0 (2010-09-25)</a></li>\n<li><a href=\"#id6\" id=\"id45\" rel=\"nofollow\">3.7.1 (2010-02-11)</a></li>\n<li><a href=\"#id7\" id=\"id46\" rel=\"nofollow\">3.7.0 (2010-02-08)</a></li>\n<li><a href=\"#id8\" id=\"id47\" rel=\"nofollow\">3.6.2 (2010-01-05)</a></li>\n<li><a href=\"#id9\" id=\"id48\" rel=\"nofollow\">3.6.1 (2009-10-07)</a></li>\n<li><a href=\"#id10\" id=\"id49\" rel=\"nofollow\">3.6.0 (2009-03-14)</a></li>\n<li><a href=\"#id11\" id=\"id50\" rel=\"nofollow\">3.5.0 (2009-03-06)</a></li>\n<li><a href=\"#a2-2009-02-01\" id=\"id51\" rel=\"nofollow\">3.5.0a2 (2009-02-01)</a></li>\n<li><a href=\"#a1-2009-01-31\" id=\"id52\" rel=\"nofollow\">3.5.0a1 (2009-01-31)</a></li>\n<li><a href=\"#id12\" id=\"id53\" rel=\"nofollow\">3.4.4 (2008-12-12)</a></li>\n<li><a href=\"#id13\" id=\"id54\" rel=\"nofollow\">3.4.3 (2008-08-07)</a></li>\n<li><a href=\"#id14\" id=\"id55\" rel=\"nofollow\">3.4.2 (2008-07-09)</a></li>\n<li><a href=\"#id15\" id=\"id56\" rel=\"nofollow\">3.4.1 (2007-10-24)</a></li>\n<li><a href=\"#id16\" id=\"id57\" rel=\"nofollow\">3.4.0 (2007-10-11)</a></li>\n<li><a href=\"#b1-2007-09-27\" id=\"id58\" rel=\"nofollow\">3.4.0b1 (2007-09-27)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"pluggable-authentication-utility\">\n<h2><a href=\"#id17\" rel=\"nofollow\">Pluggable-Authentication Utility</a></h2>\n<p>The Pluggable-Authentication Utility (PAU) provides a framework for\nauthenticating principals and associating information with them. It uses\nplugins and subscribers to get its work done.</p>\n<p>For a pluggable-authentication utility to be used, it should be\nregistered as a utility providing the\n<cite>zope.authentication.interfaces.IAuthentication</cite> interface.</p>\n<div id=\"authentication\">\n<h3><a href=\"#id18\" rel=\"nofollow\">Authentication</a></h3>\n<p>The primary job of PAU is to authenticate principals. It uses two types of\nplug-ins in its work:</p>\n<blockquote>\n<ul>\n<li>Credentials Plugins</li>\n<li>Authenticator Plugins</li>\n</ul>\n</blockquote>\n<p>Credentials plugins are responsible for extracting user credentials from a\nrequest. A credentials plugin may in some cases issue a \u2018challenge\u2019 to obtain\ncredentials. For example, a \u2018session\u2019 credentials plugin reads credentials\nfrom a session (the \u201cextraction\u201d). If it cannot find credentials, it will\nredirect the user to a login form in order to provide them (the \u201cchallenge\u201d).</p>\n<p>Authenticator plugins are responsible for authenticating the credentials\nextracted by a credentials plugin. They are also typically able to create\nprincipal objects for credentials they successfully authenticate.</p>\n<p>Given a request object, the PAU returns a principal object, if it can. The PAU\ndoes this by first iterateing through its credentials plugins to obtain a\nset of credentials. If it gets credentials, it iterates through its\nauthenticator plugins to authenticate them.</p>\n<p>If an authenticator succeeds in authenticating a set of credentials, the PAU\nuses the authenticator to create a principal corresponding to the credentials.\nThe authenticator notifies subscribers if an authenticated principal is\ncreated. Subscribers are responsible for adding data, especially groups, to\nthe principal. Typically, if a subscriber adds data, it should also add\ncorresponding interface declarations.</p>\n<div id=\"simple-credentials-plugin\">\n<h4><a href=\"#id19\" rel=\"nofollow\">Simple Credentials Plugin</a></h4>\n<p>To illustrate, we\u2019ll create a simple credentials plugin:</p>\n<pre>&gt;&gt;&gt; from zope import interface\n&gt;&gt;&gt; from zope.app.authentication import interfaces\n\n&gt;&gt;&gt; @interface.implementer(interfaces.ICredentialsPlugin)\n... class MyCredentialsPlugin(object):\n...\n...\n...     def extractCredentials(self, request):\n...         return request.get('credentials')\n...\n...     def challenge(self, request):\n...         pass # challenge is a no-op for this plugin\n...\n...     def logout(self, request):\n...         pass # logout is a no-op for this plugin\n</pre>\n<p>As a plugin, MyCredentialsPlugin needs to be registered as a named utility:</p>\n<pre>&gt;&gt;&gt; myCredentialsPlugin = MyCredentialsPlugin()\n&gt;&gt;&gt; provideUtility(myCredentialsPlugin, name='My Credentials Plugin')\n</pre>\n</div>\n<div id=\"simple-authenticator-plugin\">\n<h4><a href=\"#id20\" rel=\"nofollow\">Simple Authenticator Plugin</a></h4>\n<p>Next we\u2019ll create a simple authenticator plugin. For our plugin, we\u2019ll need\nan implementation of IPrincipalInfo:</p>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.IPrincipalInfo)\n... class PrincipalInfo(object):\n...\n...     def __init__(self, id, title, description):\n...         self.id = id\n...         self.title = title\n...         self.description = description\n...\n...     def __repr__(self):\n...         return 'PrincipalInfo(%r)' % self.id\n</pre>\n<p>Our authenticator uses this type when it creates a principal info:</p>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.IAuthenticatorPlugin)\n... class MyAuthenticatorPlugin(object):\n...\n...     def authenticateCredentials(self, credentials):\n...         if credentials == 'secretcode':\n...             return PrincipalInfo('bob', 'Bob', '')\n...\n...     def principalInfo(self, id):\n...         pass # plugin not currently supporting search\n</pre>\n<p>As with the credentials plugin, the authenticator plugin must be registered\nas a named utility:</p>\n<pre>&gt;&gt;&gt; myAuthenticatorPlugin = MyAuthenticatorPlugin()\n&gt;&gt;&gt; provideUtility(myAuthenticatorPlugin, name='My Authenticator Plugin')\n</pre>\n</div>\n<div id=\"principal-factories\">\n<h4><a href=\"#id21\" rel=\"nofollow\">Principal Factories</a></h4>\n<p>While authenticator plugins provide principal info, they are not responsible\nfor creating principals. This function is performed by factory adapters. For\nthese tests we\u2019ll borrow some factories from the principal folder:</p>\n<pre>&gt;&gt;&gt; from zope.app.authentication import principalfolder\n&gt;&gt;&gt; provideAdapter(principalfolder.AuthenticatedPrincipalFactory)\n&gt;&gt;&gt; provideAdapter(principalfolder.FoundPrincipalFactory)\n</pre>\n<p>For more information on these factories, see their docstrings.</p>\n</div>\n<div id=\"configuring-a-pau\">\n<h4><a href=\"#id22\" rel=\"nofollow\">Configuring a PAU</a></h4>\n<p>Finally, we\u2019ll create the PAU itself:</p>\n<pre>&gt;&gt;&gt; from zope.app import authentication\n&gt;&gt;&gt; pau = authentication.PluggableAuthentication('xyz_')\n</pre>\n<p>and configure it with the two plugins:</p>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = ('My Credentials Plugin', )\n&gt;&gt;&gt; pau.authenticatorPlugins = ('My Authenticator Plugin', )\n</pre>\n</div>\n<div id=\"using-the-pau-to-authenticate\">\n<h4><a href=\"#id23\" rel=\"nofollow\">Using the PAU to Authenticate</a></h4>\n<p>We can now use the PAU to authenticate a sample request:</p>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; print(pau.authenticate(TestRequest()))\nNone\n</pre>\n<p>In this case, we cannot authenticate an empty request. In the same way, we\nwill not be able to authenticate a request with the wrong credentials:</p>\n<pre>&gt;&gt;&gt; print(pau.authenticate(TestRequest(credentials='let me in!')))\nNone\n</pre>\n<p>However, if we provide the proper credentials:</p>\n<pre>&gt;&gt;&gt; request = TestRequest(credentials='secretcode')\n&gt;&gt;&gt; principal = pau.authenticate(request)\n&gt;&gt;&gt; principal\nPrincipal('xyz_bob')\n</pre>\n<p>we get an authenticated principal.</p>\n</div>\n<div id=\"authenticated-principal-creates-events\">\n<h4><a href=\"#id24\" rel=\"nofollow\">Authenticated Principal Creates Events</a></h4>\n<p>We can verify that the appropriate event was published:</p>\n<pre>&gt;&gt;&gt; [event] = getEvents(interfaces.IAuthenticatedPrincipalCreated)\n&gt;&gt;&gt; event.principal is principal\nTrue\n&gt;&gt;&gt; event.info\nPrincipalInfo('bob')\n&gt;&gt;&gt; event.request is request\nTrue\n</pre>\n<p>The info object has the id, title, and description of the principal.  The info\nobject is also generated by the authenticator plugin, so the plugin may\nitself have provided additional information on the info object:</p>\n<pre>&gt;&gt;&gt; event.info.title\n'Bob'\n&gt;&gt;&gt; event.info.id # does not include pau prefix\n'bob'\n&gt;&gt;&gt; event.info.description\n''\n</pre>\n<p>It is also decorated with two other attributes, credentialsPlugin and\nauthenticatorPlugin: these are the plugins used to extract credentials for and\nauthenticate this principal.  These attributes can be useful for subscribers\nthat want to react to the plugins used.  For instance, subscribers can\ndetermine that a given credential plugin does or does not support logout, and\nprovide information usable to show or hide logout user interface:</p>\n<pre>&gt;&gt;&gt; event.info.credentialsPlugin is myCredentialsPlugin\nTrue\n&gt;&gt;&gt; event.info.authenticatorPlugin is myAuthenticatorPlugin\nTrue\n</pre>\n<p>Normally, we provide subscribers to these events that add additional\ninformation to the principal. For example, we\u2019ll add one that sets\nthe title:</p>\n<pre>&gt;&gt;&gt; def add_info(event):\n...     event.principal.title = event.info.title\n&gt;&gt;&gt; provideHandler(add_info, [interfaces.IAuthenticatedPrincipalCreated])\n</pre>\n<p>Now, if we authenticate a principal, its title is set:</p>\n<pre>&gt;&gt;&gt; principal = pau.authenticate(request)\n&gt;&gt;&gt; principal.title\n'Bob'\n</pre>\n</div>\n<div id=\"multiple-authenticator-plugins\">\n<h4><a href=\"#id25\" rel=\"nofollow\">Multiple Authenticator Plugins</a></h4>\n<p>The PAU works with multiple authenticator plugins. It uses each plugin, in the\norder specified in the PAU\u2019s authenticatorPlugins attribute, to authenticate\na set of credentials.</p>\n<p>To illustrate, we\u2019ll create another authenticator:</p>\n<pre>&gt;&gt;&gt; class MyAuthenticatorPlugin2(MyAuthenticatorPlugin):\n...\n...     def authenticateCredentials(self, credentials):\n...         if credentials == 'secretcode':\n...             return PrincipalInfo('black', 'Black Spy', '')\n...         elif credentials == 'hiddenkey':\n...             return PrincipalInfo('white', 'White Spy', '')\n\n&gt;&gt;&gt; provideUtility(MyAuthenticatorPlugin2(), name='My Authenticator Plugin 2')\n</pre>\n<p>If we put it before the original authenticator:</p>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = (\n...     'My Authenticator Plugin 2',\n...     'My Authenticator Plugin')\n</pre>\n<p>Then it will be given the first opportunity to authenticate a request:</p>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode'))\nPrincipal('xyz_black')\n</pre>\n<p>If neither plugins can authenticate, pau returns None:</p>\n<pre>&gt;&gt;&gt; print(pau.authenticate(TestRequest(credentials='let me in!!')))\nNone\n</pre>\n<p>When we change the order of the authenticator plugins:</p>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = (\n...     'My Authenticator Plugin',\n...     'My Authenticator Plugin 2')\n</pre>\n<p>we see that our original plugin is now acting first:</p>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode'))\nPrincipal('xyz_bob')\n</pre>\n<p>The second plugin, however, gets a chance to authenticate if first does not:</p>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='hiddenkey'))\nPrincipal('xyz_white')\n</pre>\n</div>\n<div id=\"multiple-credentials-plugins\">\n<h4><a href=\"#id26\" rel=\"nofollow\">Multiple Credentials Plugins</a></h4>\n<p>As with with authenticators, we can specify multiple credentials plugins. To\nillustrate, we\u2019ll create a credentials plugin that extracts credentials from\na request form:</p>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.ICredentialsPlugin)\n... class FormCredentialsPlugin:\n...\n...     def extractCredentials(self, request):\n...         return request.form.get('my_credentials')\n...\n...     def challenge(self, request):\n...         pass\n...\n...     def logout(request):\n...         pass\n\n&gt;&gt;&gt; provideUtility(FormCredentialsPlugin(),\n...                name='Form Credentials Plugin')\n</pre>\n<p>and insert the new credentials plugin before the existing plugin:</p>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = (\n...     'Form Credentials Plugin',\n...     'My Credentials Plugin')\n</pre>\n<p>The PAU will use each plugin in order to try and obtain credentials from a\nrequest:</p>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode',\n...                              form={'my_credentials': 'hiddenkey'}))\nPrincipal('xyz_white')\n</pre>\n<p>In this case, the first credentials plugin succeeded in getting credentials\nfrom the form and the second authenticator was able to authenticate the\ncredentials. Specifically, the PAU went through these steps:</p>\n<blockquote>\n<ul>\n<li>Get credentials using \u2018Form Credentials Plugin\u2019</li>\n<li>Got \u2018hiddenkey\u2019 credentials using \u2018Form Credentials Plugin\u2019, try to\nauthenticate using \u2018My Authenticator Plugin\u2019</li>\n<li>Failed to authenticate \u2018hiddenkey\u2019 with \u2018My Authenticator Plugin\u2019, try\n\u2018My Authenticator Plugin 2\u2019</li>\n<li>Succeeded in authenticating with \u2018My Authenticator Plugin 2\u2019</li>\n</ul>\n</blockquote>\n<p>Let\u2019s try a different scenario:</p>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode'))\nPrincipal('xyz_bob')\n</pre>\n<p>In this case, the PAU went through these steps:</p>\n<pre>- Get credentials using 'Form Credentials Plugin'\n\n- Failed to get credentials using 'Form Credentials Plugin', try\n  'My Credentials Plugin'\n\n- Got 'scecretcode' credentials using 'My Credentials Plugin', try to\n  authenticate using 'My Authenticator Plugin'\n\n- Succeeded in authenticating with 'My Authenticator Plugin'\n</pre>\n<p>Let\u2019s try a slightly more complex scenario:</p>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='hiddenkey',\n...                              form={'my_credentials': 'bogusvalue'}))\nPrincipal('xyz_white')\n</pre>\n<p>This highlights PAU\u2019s ability to use multiple plugins for authentication:</p>\n<blockquote>\n<ul>\n<li>Get credentials using \u2018Form Credentials Plugin\u2019</li>\n<li>Got \u2018bogusvalue\u2019 credentials using \u2018Form Credentials Plugin\u2019, try to\nauthenticate using \u2018My Authenticator Plugin\u2019</li>\n<li>Failed to authenticate \u2018boguskey\u2019 with \u2018My Authenticator Plugin\u2019, try\n\u2018My Authenticator Plugin 2\u2019</li>\n<li>Failed to authenticate \u2018boguskey\u2019 with \u2018My Authenticator Plugin 2\u2019 \u2013\nthere are no more authenticators to try, so lets try the next credentials\nplugin for some new credentials</li>\n<li>Get credentials using \u2018My Credentials Plugin\u2019</li>\n<li>Got \u2018hiddenkey\u2019 credentials using \u2018My Credentials Plugin\u2019, try to\nauthenticate using \u2018My Authenticator Plugin\u2019</li>\n<li>Failed to authenticate \u2018hiddenkey\u2019 using \u2018My Authenticator Plugin\u2019, try\n\u2018My Authenticator Plugin 2\u2019</li>\n<li>Succeeded in authenticating with \u2018My Authenticator Plugin 2\u2019 (shouts and\ncheers!)</li>\n</ul>\n</blockquote>\n</div>\n</div>\n<div id=\"principal-searching\">\n<h3><a href=\"#id27\" rel=\"nofollow\">Principal Searching</a></h3>\n<p>As a component that provides IAuthentication, a PAU lets you lookup a\nprincipal with a principal ID. The PAU looks up a principal by delegating to\nits authenticators. In our example, none of the authenticators implement this\nsearch capability, so when we look for a principal:</p>\n<pre>&gt;&gt;&gt; print(pau.getPrincipal('xyz_bob'))\nTraceback (most recent call last):\nzope.authentication.interfaces.PrincipalLookupError: bob\n\n&gt;&gt;&gt; print(pau.getPrincipal('white'))\nTraceback (most recent call last):\nzope.authentication.interfaces.PrincipalLookupError: white\n\n&gt;&gt;&gt; print(pau.getPrincipal('black'))\nTraceback (most recent call last):\nzope.authentication.interfaces.PrincipalLookupError: black\n</pre>\n<p>For a PAU to support search, it needs to be configured with one or more\nauthenticator plugins that support search. To illustrate, we\u2019ll create a new\nauthenticator:</p>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.IAuthenticatorPlugin)\n... class SearchableAuthenticatorPlugin:\n...\n...     def __init__(self):\n...         self.infos = {}\n...         self.ids = {}\n...\n...     def principalInfo(self, id):\n...         return self.infos.get(id)\n...\n...     def authenticateCredentials(self, credentials):\n...         id = self.ids.get(credentials)\n...         if id is not None:\n...             return self.infos[id]\n...\n...     def add(self, id, title, description, credentials):\n...         self.infos[id] = PrincipalInfo(id, title, description)\n...         self.ids[credentials] = id\n</pre>\n<p>This class is typical of an authenticator plugin. It can both authenticate\nprincipals and find principals given a ID. While there are cases\nwhere an authenticator may opt to not perform one of these two functions, they\nare less typical.</p>\n<p>As with any plugin, we need to register it as a utility:</p>\n<pre>&gt;&gt;&gt; searchable = SearchableAuthenticatorPlugin()\n&gt;&gt;&gt; provideUtility(searchable, name='Searchable Authentication Plugin')\n</pre>\n<p>We\u2019ll now configure the PAU to use only the searchable authenticator:</p>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = ('Searchable Authentication Plugin',)\n</pre>\n<p>and add some principals to the authenticator:</p>\n<pre>&gt;&gt;&gt; searchable.add('bob', 'Bob', 'A nice guy', 'b0b')\n&gt;&gt;&gt; searchable.add('white', 'White Spy', 'Sneaky', 'deathtoblack')\n</pre>\n<p>Now when we ask the PAU to find a principal:</p>\n<pre>&gt;&gt;&gt; pau.getPrincipal('xyz_bob')\nPrincipal('xyz_bob')\n</pre>\n<p>but only those it knows about:</p>\n<pre>&gt;&gt;&gt; print(pau.getPrincipal('black'))\nTraceback (most recent call last):\nzope.authentication.interfaces.PrincipalLookupError: black\n</pre>\n<div id=\"found-principal-creates-events\">\n<h4><a href=\"#id28\" rel=\"nofollow\">Found Principal Creates Events</a></h4>\n<p>As evident in the authenticator\u2019s \u2018createFoundPrincipal\u2019 method (see above),\na FoundPrincipalCreatedEvent is published when the authenticator finds a\nprincipal on behalf of PAU\u2019s \u2018getPrincipal\u2019:</p>\n<pre>&gt;&gt;&gt; clearEvents()\n&gt;&gt;&gt; principal = pau.getPrincipal('xyz_white')\n&gt;&gt;&gt; principal\nPrincipal('xyz_white')\n\n&gt;&gt;&gt; [event] = getEvents(interfaces.IFoundPrincipalCreated)\n&gt;&gt;&gt; event.principal is principal\nTrue\n&gt;&gt;&gt; event.info\nPrincipalInfo('white')\n</pre>\n<p>The info has an authenticatorPlugin, but no credentialsPlugin, since none was\nused:</p>\n<pre>&gt;&gt;&gt; event.info.credentialsPlugin is None\nTrue\n&gt;&gt;&gt; event.info.authenticatorPlugin is searchable\nTrue\n</pre>\n<p>As we have seen with authenticated principals, it is common to subscribe to\nprincipal created events to add information to the newly created principal.\nIn this case, we need to subscribe to IFoundPrincipalCreated events:</p>\n<pre>&gt;&gt;&gt; provideHandler(add_info, [interfaces.IFoundPrincipalCreated])\n</pre>\n<p>Now when a principal is created as a result of a search, it\u2019s title and\ndescription will be set (by the add_info handler function).</p>\n</div>\n<div id=\"id1\">\n<h4><a href=\"#id29\" rel=\"nofollow\">Multiple Authenticator Plugins</a></h4>\n<p>As with the other operations we\u2019ve seen, the PAU uses multiple plugins to\nfind a principal. If the first authenticator plugin can\u2019t find the requested\nprincipal, the next plugin is used, and so on.</p>\n<p>To illustrate, we\u2019ll create and register a second searchable authenticator:</p>\n<pre>&gt;&gt;&gt; searchable2 = SearchableAuthenticatorPlugin()\n&gt;&gt;&gt; provideUtility(searchable2, name='Searchable Authentication Plugin 2')\n</pre>\n<p>and add a principal to it:</p>\n<pre>&gt;&gt;&gt; searchable.add('black', 'Black Spy', 'Also sneaky', 'deathtowhite')\n</pre>\n<p>When we configure the PAU to use both searchable authenticators (note the\norder):</p>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = (\n...     'Searchable Authentication Plugin 2',\n...     'Searchable Authentication Plugin')\n</pre>\n<p>we see how the PAU uses both plugins:</p>\n<pre>&gt;&gt;&gt; pau.getPrincipal('xyz_white')\nPrincipal('xyz_white')\n\n&gt;&gt;&gt; pau.getPrincipal('xyz_black')\nPrincipal('xyz_black')\n</pre>\n<p>If more than one plugin know about the same principal ID, the first plugin is\nused and the remaining are not delegated to. To illustrate, we\u2019ll add\nanother principal with the same ID as an existing principal:</p>\n<pre>&gt;&gt;&gt; searchable2.add('white', 'White Rider', '', 'r1der')\n&gt;&gt;&gt; pau.getPrincipal('xyz_white').title\n'White Rider'\n</pre>\n<p>If we change the order of the plugins:</p>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins = (\n...     'Searchable Authentication Plugin',\n...     'Searchable Authentication Plugin 2')\n</pre>\n<p>we get a different principal for ID \u2018white\u2019:</p>\n<pre>&gt;&gt;&gt; pau.getPrincipal('xyz_white').title\n'White Spy'\n</pre>\n</div>\n</div>\n<div id=\"issuing-a-challenge\">\n<h3><a href=\"#id30\" rel=\"nofollow\">Issuing a Challenge</a></h3>\n<p>Part of PAU\u2019s IAuthentication contract is to challenge the user for\ncredentials when its \u2018unauthorized\u2019 method is called. The need for this\nfunctionality is driven by the following use case:</p>\n<blockquote>\n<ul>\n<li>A user attempts to perform an operation he is not authorized to perform.</li>\n<li>A handler responds to the unauthorized error by calling IAuthentication\n\u2018unauthorized\u2019.</li>\n<li>The authentication component (in our case, a PAU) issues a challenge to\nthe user to collect new credentials (typically in the form of logging in\nas a new user).</li>\n</ul>\n</blockquote>\n<p>The PAU handles the credentials challenge by delegating to its credentials\nplugins.</p>\n<p>Currently, the PAU is configured with the credentials plugins that don\u2019t\nperform any action when asked to challenge (see above the \u2018challenge\u2019 methods).</p>\n<p>To illustrate challenges, we\u2019ll subclass an existing credentials plugin and\ndo something in its \u2018challenge\u2019:</p>\n<pre>&gt;&gt;&gt; class LoginFormCredentialsPlugin(FormCredentialsPlugin):\n...\n...     def __init__(self, loginForm):\n...         self.loginForm = loginForm\n...\n...     def challenge(self, request):\n...         request.response.redirect(self.loginForm)\n...         return True\n</pre>\n<p>This plugin handles a challenge by redirecting the response to a login form.\nIt returns True to signal to the PAU that it handled the challenge.</p>\n<p>We will now create and register a couple of these plugins:</p>\n<pre>&gt;&gt;&gt; provideUtility(LoginFormCredentialsPlugin('simplelogin.html'),\n...                name='Simple Login Form Plugin')\n\n&gt;&gt;&gt; provideUtility(LoginFormCredentialsPlugin('advancedlogin.html'),\n...                name='Advanced Login Form Plugin')\n</pre>\n<p>and configure the PAU to use them:</p>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = (\n...     'Simple Login Form Plugin',\n...     'Advanced Login Form Plugin')\n</pre>\n<p>Now when we call \u2018unauthorized\u2019 on the PAU:</p>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; pau.unauthorized(id=None, request=request)\n</pre>\n<p>we see that the user is redirected to the simple login form:</p>\n<pre>&gt;&gt;&gt; request.response.getStatus()\n302\n&gt;&gt;&gt; request.response.getHeader('location')\n'simplelogin.html'\n</pre>\n<p>We can change the challenge policy by reordering the plugins:</p>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = (\n...     'Advanced Login Form Plugin',\n...     'Simple Login Form Plugin')\n</pre>\n<p>Now when we call \u2018unauthorized\u2019:</p>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; pau.unauthorized(id=None, request=request)\n</pre>\n<p>the advanced plugin is used because it\u2019s first:</p>\n<pre>&gt;&gt;&gt; request.response.getStatus()\n302\n&gt;&gt;&gt; request.response.getHeader('location')\n'advancedlogin.html'\n</pre>\n<div id=\"challenge-protocols\">\n<h4><a href=\"#id31\" rel=\"nofollow\">Challenge Protocols</a></h4>\n<p>Sometimes, we want multiple challengers to work together. For example, the\nHTTP specification allows multiple challenges to be issued in a response. A\nchallenge plugin can provide a <cite>challengeProtocol</cite> attribute that effectively\ngroups related plugins together for challenging. If a plugin returns <cite>True</cite>\nfrom its challenge and provides a non-None challengeProtocol, subsequent\nplugins in the credentialsPlugins list that have the same challenge protocol\nwill also be used to challenge.</p>\n<p>Without a challengeProtocol, only the first plugin to succeed in a challenge\nwill be used.</p>\n<p>Let\u2019s look at an example. We\u2019ll define a new plugin that specifies an\n\u2018X-Challenge\u2019 protocol:</p>\n<pre>&gt;&gt;&gt; class XChallengeCredentialsPlugin(FormCredentialsPlugin):\n...\n...     challengeProtocol = 'X-Challenge'\n...\n...     def __init__(self, challengeValue):\n...         self.challengeValue = challengeValue\n...\n...     def challenge(self, request):\n...         value = self.challengeValue\n...         existing = request.response.getHeader('X-Challenge', '')\n...         if existing:\n...             value += ' ' + existing\n...         request.response.setHeader('X-Challenge', value)\n...         return True\n</pre>\n<p>and register a couple instances as utilities:</p>\n<pre>&gt;&gt;&gt; provideUtility(XChallengeCredentialsPlugin('basic'),\n...                name='Basic X-Challenge Plugin')\n\n&gt;&gt;&gt; provideUtility(XChallengeCredentialsPlugin('advanced'),\n...                name='Advanced X-Challenge Plugin')\n</pre>\n<p>When we use both plugins with the PAU:</p>\n<pre>&gt;&gt;&gt; pau.credentialsPlugins = (\n...     'Basic X-Challenge Plugin',\n...     'Advanced X-Challenge Plugin')\n</pre>\n<p>and call \u2018unauthorized\u2019:</p>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; pau.unauthorized(None, request)\n</pre>\n<p>we see that both plugins participate in the challange, rather than just the\nfirst plugin:</p>\n<pre>&gt;&gt;&gt; request.response.getHeader('X-Challenge')\n'advanced basic'\n</pre>\n</div>\n</div>\n<div id=\"pluggable-authentication-prefixes\">\n<h3><a href=\"#id32\" rel=\"nofollow\">Pluggable-Authentication Prefixes</a></h3>\n<p>Principal ids are required to be unique system wide. Plugins will often provide\noptions for providing id prefixes, so that different sets of plugins provide\nunique ids within a PAU. If there are multiple pluggable-authentication\nutilities in a system, it\u2019s a good idea to give each PAU a unique prefix, so\nthat principal ids from different PAUs don\u2019t conflict. We can provide a prefix\nwhen a PAU is created:</p>\n<pre>&gt;&gt;&gt; pau = authentication.PluggableAuthentication('mypau_')\n&gt;&gt;&gt; pau.credentialsPlugins = ('My Credentials Plugin', )\n&gt;&gt;&gt; pau.authenticatorPlugins = ('My Authenticator Plugin', )\n</pre>\n<p>When we create a request and try to authenticate:</p>\n<pre>&gt;&gt;&gt; pau.authenticate(TestRequest(credentials='secretcode'))\nPrincipal('mypau_bob')\n</pre>\n<p>Note that now, our principal\u2019s id has the pluggable-authentication\nutility prefix.</p>\n<p>We can still lookup a principal, as long as we supply the prefix:</p>\n<pre>&gt;&gt; pau.getPrincipal('mypas_42')\nPrincipal('mypas_42', \"{'domain': 42}\")\n\n&gt;&gt; pau.getPrincipal('mypas_41')\nOddPrincipal('mypas_41', \"{'int': 41}\")\n</pre>\n</div>\n<div id=\"searching\">\n<h3><a href=\"#id33\" rel=\"nofollow\">Searching</a></h3>\n<p>PAU implements ISourceQueriables:</p>\n<pre>&gt;&gt;&gt; from zope.schema.interfaces import ISourceQueriables\n&gt;&gt;&gt; ISourceQueriables.providedBy(pau)\nTrue\n</pre>\n<p>This means a PAU can be used in a principal source vocabulary (Zope provides a\nsophisticated searching UI for principal sources).</p>\n<p>As we\u2019ve seen, a PAU uses each of its authenticator plugins to locate a\nprincipal with a given ID. However, plugins may also provide the interface\nIQuerySchemaSearch to indicate they can be used in the PAU\u2019s principal search\nscheme.</p>\n<p>Currently, our list of authenticators:</p>\n<pre>&gt;&gt;&gt; pau.authenticatorPlugins\n('My Authenticator Plugin',)\n</pre>\n<p>does not include a queriable authenticator. PAU cannot therefore provide any\nqueriables:</p>\n<pre>&gt;&gt;&gt; list(pau.getQueriables())\n[]\n</pre>\n<p>Before we illustrate how an authenticator is used by the PAU to search for\nprincipals, we need to setup an adapter used by PAU:</p>\n<pre>&gt;&gt;&gt; import zope.app.authentication.authentication\n&gt;&gt;&gt; provideAdapter(\n...     authentication.authentication.QuerySchemaSearchAdapter,\n...     provides=interfaces.IQueriableAuthenticator)\n</pre>\n<p>This adapter delegates search responsibility to an authenticator, but prepends\nthe PAU prefix to any principal IDs returned in a search.</p>\n<p>Next, we\u2019ll create a plugin that provides a search interface:</p>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.IQuerySchemaSearch)\n... class QueriableAuthenticatorPlugin(MyAuthenticatorPlugin):\n...\n...     schema = None\n...\n...     def search(self, query, start=None, batch_size=None):\n...         yield 'foo'\n...\n</pre>\n<p>and install it as a plugin:</p>\n<pre>&gt;&gt;&gt; plugin = QueriableAuthenticatorPlugin()\n&gt;&gt;&gt; provideUtility(plugin,\n...                provides=interfaces.IAuthenticatorPlugin,\n...                name='Queriable')\n&gt;&gt;&gt; pau.authenticatorPlugins += ('Queriable',)\n</pre>\n<p>Now, the PAU provides a single queriable:</p>\n<pre>&gt;&gt;&gt; list(pau.getQueriables()) # doctest: +ELLIPSIS\n[('Queriable', ...QuerySchemaSearchAdapter object...)]\n</pre>\n<p>We can use this queriable to search for our principal:</p>\n<pre>&gt;&gt;&gt; queriable = list(pau.getQueriables())[0][1]\n&gt;&gt;&gt; list(queriable.search('not-used'))\n['mypau_foo']\n</pre>\n<p>Note that the resulting principal ID includes the PAU prefix. Were we to search\nthe plugin directly:</p>\n<pre>&gt;&gt;&gt; list(plugin.search('not-used'))\n['foo']\n</pre>\n<p>The result does not include the PAU prefix. The prepending of the prefix is\nhandled by the PluggableAuthenticationQueriable.</p>\n<p>Queryiable plugins can provide the ILocation interface. In this case the\nQuerySchemaSearchAdapter\u2019s __parent__ is the same as the __parent__ of the\nplugin:</p>\n<pre>&gt;&gt;&gt; import zope.location.interfaces\n&gt;&gt;&gt; @interface.implementer(zope.location.interfaces.ILocation)\n... class LocatedQueriableAuthenticatorPlugin(QueriableAuthenticatorPlugin):\n...\n...     __parent__ = __name__ = None\n...\n&gt;&gt;&gt; import zope.site.hooks\n&gt;&gt;&gt; site = zope.site.hooks.getSite()\n&gt;&gt;&gt; plugin = LocatedQueriableAuthenticatorPlugin()\n&gt;&gt;&gt; plugin.__parent__ = site\n&gt;&gt;&gt; plugin.__name__ = 'localname'\n&gt;&gt;&gt; provideUtility(plugin,\n...                provides=interfaces.IAuthenticatorPlugin,\n...                name='location-queriable')\n&gt;&gt;&gt; pau.authenticatorPlugins = ('location-queriable',)\n</pre>\n<p>We have one queriable again:</p>\n<pre>&gt;&gt;&gt; queriables = list(pau.getQueriables())\n&gt;&gt;&gt; queriables  # doctest: +ELLIPSIS\n[('location-queriable', ...QuerySchemaSearchAdapter object...)]\n</pre>\n<p>The queriable\u2019s __parent__ is the site as set above:</p>\n<pre>&gt;&gt;&gt; queriable = queriables[0][1]\n&gt;&gt;&gt; queriable.__parent__ is site\nTrue\n</pre>\n<p>If the queriable provides ILocation but is not actually locatable (i.e. the\nparent is None) the pau itself becomes the parent:</p>\n<pre>&gt;&gt;&gt; plugin = LocatedQueriableAuthenticatorPlugin()\n&gt;&gt;&gt; provideUtility(plugin,\n...                provides=interfaces.IAuthenticatorPlugin,\n...                name='location-queriable-wo-parent')\n&gt;&gt;&gt; pau.authenticatorPlugins = ('location-queriable-wo-parent',)\n</pre>\n<p>We have one queriable again:</p>\n<pre>&gt;&gt;&gt; queriables = list(pau.getQueriables())\n&gt;&gt;&gt; queriables  # doctest: +ELLIPSIS\n[('location-queriable-wo-parent', ...QuerySchemaSearchAdapter object...)]\n</pre>\n<p>And the parent is the pau:</p>\n<pre>&gt;&gt;&gt; queriable = queriables[0][1]\n&gt;&gt;&gt; queriable.__parent__  # doctest: +ELLIPSIS\n&lt;zope.pluggableauth.authentication.PluggableAuthentication object ...&gt;\n&gt;&gt;&gt; queriable.__parent__ is pau\nTrue\n</pre>\n</div>\n</div>\n<div id=\"principal-folder\">\n<h2><a href=\"#id34\" rel=\"nofollow\">Principal Folder</a></h2>\n<p>Principal folders contain principal-information objects that contain principal\ninformation. We create an internal principal using the <cite>InternalPrincipal</cite>\nclass:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.app.authentication.principalfolder import InternalPrincipal\n&gt;&gt;&gt; p1 = InternalPrincipal('login1', '123', \"Principal 1\",\n...     passwordManagerName=\"SHA1\")\n&gt;&gt;&gt; p2 = InternalPrincipal('login2', '456', \"The Other One\")\n</pre>\n</blockquote>\n<p>and add them to a principal folder:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.app.authentication.principalfolder import PrincipalFolder\n&gt;&gt;&gt; principals = PrincipalFolder('principal.')\n&gt;&gt;&gt; principals['p1'] = p1\n&gt;&gt;&gt; principals['p2'] = p2\n</pre>\n</blockquote>\n<div id=\"id2\">\n<h3><a href=\"#id35\" rel=\"nofollow\">Authentication</a></h3>\n<p>Principal folders provide the <cite>IAuthenticatorPlugin</cite> interface. When we\nprovide suitable credentials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; principals.authenticateCredentials({'login': 'login1', 'password': '123'})\nPrincipalInfo(u'principal.p1')\n</pre>\n</blockquote>\n<p>We get back a principal id and supplementary information, including the\nprincipal title and description.  Note that the principal id is a concatenation\nof the principal-folder prefix and the name of the principal-information object\nwithin the folder.</p>\n<p>None is returned if the credentials are invalid:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'login1',\n...                                     'password': '1234'})\n&gt;&gt;&gt; principals.authenticateCredentials(42)\n</pre>\n</blockquote>\n</div>\n<div id=\"search\">\n<h3><a href=\"#id36\" rel=\"nofollow\">Search</a></h3>\n<p>Principal folders also provide the IQuerySchemaSearch interface.  This\nsupports both finding principal information based on their ids:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals.principalInfo('principal.p1')\nPrincipalInfo('principal.p1')\n</pre>\n<pre>&gt;&gt;&gt; principals.principalInfo('p1')\n</pre>\n</blockquote>\n<p>and searching for principals based on a search string:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(principals.search({'search': 'other'}))\n[u'principal.p2']\n</pre>\n<pre>&gt;&gt;&gt; list(principals.search({'search': 'OTHER'}))\n[u'principal.p2']\n</pre>\n<pre>&gt;&gt;&gt; list(principals.search({'search': ''}))\n[u'principal.p1', u'principal.p2']\n</pre>\n<pre>&gt;&gt;&gt; list(principals.search({'search': 'eek'}))\n[]\n</pre>\n<pre>&gt;&gt;&gt; list(principals.search({}))\n[]\n</pre>\n</blockquote>\n<p>If there are a large number of matches:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; for i in range(20):\n...     i = str(i)\n...     p = InternalPrincipal('l'+i, i, \"Dude \"+i)\n...     principals[i] = p\n</pre>\n<pre>&gt;&gt;&gt; pprint(list(principals.search({'search': 'D'})))\n[u'principal.0',\n u'principal.1',\n u'principal.10',\n u'principal.11',\n u'principal.12',\n u'principal.13',\n u'principal.14',\n u'principal.15',\n u'principal.16',\n u'principal.17',\n u'principal.18',\n u'principal.19',\n u'principal.2',\n u'principal.3',\n u'principal.4',\n u'principal.5',\n u'principal.6',\n u'principal.7',\n u'principal.8',\n u'principal.9']\n</pre>\n</blockquote>\n<p>We can use batching parameters to specify a subset of results:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pprint(list(principals.search({'search': 'D'}, start=17)))\n[u'principal.7', u'principal.8', u'principal.9']\n</pre>\n<pre>&gt;&gt;&gt; pprint(list(principals.search({'search': 'D'}, batch_size=5)))\n[u'principal.0',\n u'principal.1',\n u'principal.10',\n u'principal.11',\n u'principal.12']\n</pre>\n<pre>&gt;&gt;&gt; pprint(list(principals.search({'search': 'D'}, start=5, batch_size=5)))\n[u'principal.13',\n u'principal.14',\n u'principal.15',\n u'principal.16',\n u'principal.17']\n</pre>\n</blockquote>\n<p>There is an additional method that allows requesting the principal id\nassociated with a login id.  The method raises KeyError when there is\nno associated principal:</p>\n<pre>&gt;&gt;&gt; principals.getIdByLogin(\"not-there\")\nTraceback (most recent call last):\nKeyError: 'not-there'\n</pre>\n<p>If there is a matching principal, the id is returned:</p>\n<pre>&gt;&gt;&gt; principals.getIdByLogin(\"login1\")\nu'principal.p1'\n</pre>\n</div>\n<div id=\"changing-credentials\">\n<h3><a href=\"#id37\" rel=\"nofollow\">Changing credentials</a></h3>\n<p>Credentials can be changed by modifying principal-information objects:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p1.login = 'bob'\n&gt;&gt;&gt; p1.password = 'eek'\n</pre>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'bob', 'password': 'eek'})\nPrincipalInfo(u'principal.p1')\n</pre>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'login1',\n...                                     'password': 'eek'})\n</pre>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'bob',\n...                                     'password': '123'})\n</pre>\n</blockquote>\n<p>It is an error to try to pick a login name that is already taken:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p1.login = 'login2'\nTraceback (most recent call last):\n...\nValueError: Principal Login already taken!\n</pre>\n</blockquote>\n<p>If such an attempt is made, the data are unchanged:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principals.authenticateCredentials({'login': 'bob', 'password': 'eek'})\nPrincipalInfo(u'principal.p1')\n</pre>\n</blockquote>\n</div>\n<div id=\"removing-principals\">\n<h3><a href=\"#id38\" rel=\"nofollow\">Removing principals</a></h3>\n<p>Of course, if a principal is removed, we can no-longer authenticate it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del principals['p1']\n&gt;&gt;&gt; principals.authenticateCredentials({'login': 'bob',\n...                                     'password': 'eek'})\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"vocabularies\">\n<h2><a href=\"#id39\" rel=\"nofollow\">Vocabularies</a></h2>\n<p>The vocabulary module provides vocabularies for the authenticator plugins and\nthe credentials plugins.</p>\n<p>The options should include the unique names of all of the plugins that provide\nthe appropriate interface (interfaces.ICredentialsPlugin or\ninterfaces.IAuthentiatorPlugin, respectively) for the current context\u2013 which\nis expected to be a pluggable authentication utility, hereafter referred to as\na PAU.</p>\n<p>These names may be for objects contained within the PAU (\u201ccontained\nplugins\u201d), or may be utilities registered for the specified interface,\nfound in the context of the PAU (\u201cutility plugins\u201d).  Contained\nplugins mask utility plugins of the same name.  They also may be names\ncurrently selected in the PAU that do not actually have a\ncorresponding plugin at this time.</p>\n<p>Here is a short example of how the vocabulary should work.  Let\u2019s say we\u2019re\nworking with authentication plugins.  We\u2019ll create some faux\nauthentication plugins, and register some of them as utilities and put\nothers in a faux PAU.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.app.authentication import interfaces\n&gt;&gt;&gt; from zope import interface, component\n&gt;&gt;&gt; @interface.implementer(interfaces.IAuthenticatorPlugin)\n... class DemoPlugin(object):\n...\n...     def __init__(self, name):\n...         self.name = name\n...\n&gt;&gt;&gt; utility_plugins = dict(\n...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(4))\n&gt;&gt;&gt; contained_plugins = dict(\n...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(1, 5))\n&gt;&gt;&gt; sorted(utility_plugins.keys())\n[0, 1, 2, 3]\n&gt;&gt;&gt; for p in utility_plugins.values():\n...     component.provideUtility(p, name=p.name)\n...\n&gt;&gt;&gt; sorted(contained_plugins.keys()) # 1 will mask utility plugin 1\n[1, 2, 3, 4]\n&gt;&gt;&gt; @interface.implementer(interfaces.IPluggableAuthentication)\n... class DemoAuth(dict):\n...\n...     def __init__(self, *args, **kwargs):\n...         super(DemoAuth, self).__init__(*args, **kwargs)\n...         self.authenticatorPlugins = (u'Plugin 3', u'Plugin X')\n...         self.credentialsPlugins = (u'Plugin 4', u'Plugin X')\n...\n&gt;&gt;&gt; auth = DemoAuth((p.name, p) for p in contained_plugins.values())\n</pre>\n<pre>&gt;&gt;&gt; @component.adapter(interface.Interface)\n... @interface.implementer(component.IComponentLookup)\n... def getSiteManager(context):\n...     return component.getGlobalSiteManager()\n...\n&gt;&gt;&gt; component.provideAdapter(getSiteManager)\n</pre>\n</blockquote>\n<p>We are now ready to create a vocabulary that we can use.  The context is\nour faux authentication utility, <cite>auth</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.app.authentication import vocabulary\n&gt;&gt;&gt; vocab = vocabulary.authenticatorPlugins(auth)\n</pre>\n</blockquote>\n<p>Iterating over the vocabulary results in all of the terms, in a relatively\narbitrary order of their names.  (This vocabulary should typically use a\nwidget that sorts values on the basis of localized collation order of the\nterm titles.)</p>\n<blockquote>\n<pre>&gt;&gt;&gt; [term.value for term in vocab] # doctest: +NORMALIZE_WHITESPACE\n[u'Plugin 0', u'Plugin 1', u'Plugin 2', u'Plugin 3', u'Plugin 4',\n u'Plugin X']\n</pre>\n</blockquote>\n<p>Similarly, we can use <cite>in</cite> to test for the presence of values in the\nvocabulary.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ['Plugin %s' % i in vocab for i in range(-1, 6)]\n[False, True, True, True, True, True, False]\n&gt;&gt;&gt; 'Plugin X' in vocab\nTrue\n</pre>\n</blockquote>\n<p>The length reports the expected value.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(vocab)\n6\n</pre>\n</blockquote>\n<p>One can get a term for a given value using <cite>getTerm()</cite>; its token, in\nturn, should also return the same effective term from <cite>getTermByToken</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; values = ['Plugin 0', 'Plugin 1', 'Plugin 2', 'Plugin 3', 'Plugin 4',\n...           'Plugin X']\n&gt;&gt;&gt; for val in values:\n...     term = vocab.getTerm(val)\n...     assert term.value == val\n...     term2 = vocab.getTermByToken(term.token)\n...     assert term2.token == term.token\n...     assert term2.value == val\n...\n</pre>\n</blockquote>\n<p>The terms have titles, which are message ids that show the plugin title or id\nand whether the plugin is a utility or just contained in the auth utility.\nWe\u2019ll give one of the plugins a dublin core title just to show the\nfunctionality.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.dublincore.interfaces\n&gt;&gt;&gt; class ISpecial(interface.Interface):\n...     pass\n...\n&gt;&gt;&gt; interface.directlyProvides(contained_plugins[1], ISpecial)\n&gt;&gt;&gt; @interface.implementer(zope.dublincore.interfaces.IDCDescriptiveProperties)\n... @component.adapter(ISpecial)\n... class DemoDCAdapter(object):\n...     def __init__(self, context):\n...         pass\n...     title = u'Special Title'\n...\n&gt;&gt;&gt; component.provideAdapter(DemoDCAdapter)\n</pre>\n</blockquote>\n<p>We need to regenerate the vocabulary, since it calculates all of its data at\nonce.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; vocab = vocabulary.authenticatorPlugins(auth)\n</pre>\n</blockquote>\n<p>Now we\u2019ll check the titles.  We\u2019ll have to translate them to see what we\nexpect.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope import i18n\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; pprint.pprint([i18n.translate(term.title) for term in vocab])\n[u'Plugin 0 (a utility)',\n u'Special Title (in contents)',\n u'Plugin 2 (in contents)',\n u'Plugin 3 (in contents)',\n u'Plugin 4 (in contents)',\n u'Plugin X (not found; deselecting will remove)']\n</pre>\n</blockquote>\n<div id=\"credentialsplugins\">\n<h3><a href=\"#id40\" rel=\"nofollow\">credentialsPlugins</a></h3>\n<p>For completeness, we\u2019ll do the same review of the credentialsPlugins.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @interface.implementer(interfaces.ICredentialsPlugin)\n... class DemoPlugin(object):\n...\n...     def __init__(self, name):\n...         self.name = name\n...\n&gt;&gt;&gt; utility_plugins = dict(\n...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(4))\n&gt;&gt;&gt; contained_plugins = dict(\n...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(1, 5))\n&gt;&gt;&gt; for p in utility_plugins.values():\n...     component.provideUtility(p, name=p.name)\n...\n&gt;&gt;&gt; auth = DemoAuth((p.name, p) for p in contained_plugins.values())\n&gt;&gt;&gt; vocab = vocabulary.credentialsPlugins(auth)\n</pre>\n</blockquote>\n<p>Iterating over the vocabulary results in all of the terms, in a relatively\narbitrary order of their names.  (This vocabulary should typically use a\nwidget that sorts values on the basis of localized collation order of the term\ntitles.) Similarly, we can use <cite>in</cite> to test for the presence of values in the\nvocabulary. The length reports the expected value.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; [term.value for term in vocab] # doctest: +NORMALIZE_WHITESPACE\n[u'Plugin 0', u'Plugin 1', u'Plugin 2', u'Plugin 3', u'Plugin 4',\n u'Plugin X']\n&gt;&gt;&gt; ['Plugin %s' % i in vocab for i in range(-1, 6)]\n[False, True, True, True, True, True, False]\n&gt;&gt;&gt; 'Plugin X' in vocab\nTrue\n&gt;&gt;&gt; len(vocab)\n6\n</pre>\n</blockquote>\n<p>One can get a term for a given value using <cite>getTerm()</cite>; its token, in\nturn, should also return the same effective term from <cite>getTermByToken</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; values = ['Plugin 0', 'Plugin 1', 'Plugin 2', 'Plugin 3', 'Plugin 4',\n...           'Plugin X']\n&gt;&gt;&gt; for val in values:\n...     term = vocab.getTerm(val)\n...     assert term.value == val\n...     term2 = vocab.getTermByToken(term.token)\n...     assert term2.token == term.token\n...     assert term2.value == val\n...\n</pre>\n</blockquote>\n<p>The terms have titles, which are message ids that show the plugin title or id\nand whether the plugin is a utility or just contained in the auth utility.\nWe\u2019ll give one of the plugins a dublin core title just to show the\nfunctionality. We need to regenerate the vocabulary, since it calculates all\nof its data at once. Then we\u2019ll check the titles.  We\u2019ll have to translate\nthem to see what we expect.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interface.directlyProvides(contained_plugins[1], ISpecial)\n&gt;&gt;&gt; vocab = vocabulary.credentialsPlugins(auth)\n&gt;&gt;&gt; pprint.pprint([i18n.translate(term.title) for term in vocab])\n[u'Plugin 0 (a utility)',\n u'Special Title (in contents)',\n u'Plugin 2 (in contents)',\n u'Plugin 3 (in contents)',\n u'Plugin 4 (in contents)',\n u'Plugin X (not found; deselecting will remove)']\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id41\" rel=\"nofollow\">Changes</a></h2>\n<div id=\"id3\">\n<h3><a href=\"#id42\" rel=\"nofollow\">4.0.0 (2017-05-02)</a></h3>\n<ul>\n<li>Drop test dependency on zope.app.zcmlfiles and zope.app.testing.</li>\n<li>Drop explicit dependency on ZODB3.</li>\n<li>Add support for Python 3.4, 3.5 and 3.6, and PyPy.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id43\" rel=\"nofollow\">3.9 (2010-10-18)</a></h3>\n<ul>\n<li>Move concrete IAuthenticatorPlugin implementations to\nzope.pluggableauth.plugins. Leave backwards compatibility imports.</li>\n<li>Use zope.formlib throughout to lift the dependency on zope.app.form. As it\nturns out, zope.app.form is still a indirect test dependency though.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id44\" rel=\"nofollow\">3.8.0 (2010-09-25)</a></h3>\n<ul>\n<li>Using python\u2019s <tt>doctest</tt> module instead of deprecated\n<tt>zope.testing.doctest[unit]</tt>.</li>\n<li>Moved the following views from <cite>zope.app.securitypolicy</cite> here, to inverse\ndependency between these two packages, as <cite>zope.app.securitypolicy</cite>\ndeprecated in ZTK 1.0:<ul>\n<li><tt>@@grant.html</tt></li>\n<li><tt>@@AllRolePermissions.html</tt></li>\n<li><tt>@@RolePermissions.html</tt></li>\n<li><tt>@@RolesWithPermission.html</tt></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id45\" rel=\"nofollow\">3.7.1 (2010-02-11)</a></h3>\n<ul>\n<li>Using the new <cite>principalfactories.zcml</cite> file, from <tt>zope.pluggableauth</tt>,\nto avoid duplication errors, in the adapters registration.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id46\" rel=\"nofollow\">3.7.0 (2010-02-08)</a></h3>\n<ul>\n<li>The Pluggable Authentication utility has been severed and released\nin a standalone package: <cite>zope.pluggableauth</cite>. We are now using this\nnew package, providing backward compatibility imports to assure a\nsmooth transition.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id47\" rel=\"nofollow\">3.6.2 (2010-01-05)</a></h3>\n<ul>\n<li>Fix tests by using zope.login, and require new zope.publisher 3.12.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id48\" rel=\"nofollow\">3.6.1 (2009-10-07)</a></h3>\n<ul>\n<li>Fix ftesting.zcml due to <tt>zope.securitypolicy</tt> update.</li>\n<li>Don\u2019t use <tt>zope.app.testing.ztapi</tt> in tests, use zope.component\u2019s\ntesting functions instead.</li>\n<li>Fix functional tests and stop using port 8081. Redirecting to\ndifferent port without trusted flag is not allowed.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id49\" rel=\"nofollow\">3.6.0 (2009-03-14)</a></h3>\n<ul>\n<li>Separate the presentation template and camefrom/redirection logic for the\n<tt>loginForm.html</tt> view. Now the logic is contained in the\n<tt>zope.app.authentication.browser.loginform.LoginForm</tt> class.</li>\n<li>Fix login form redirection failure in some cases with Python 2.6.</li>\n<li>Use the new <tt>zope.authentication</tt> package instead of <tt>zope.app.security</tt>.</li>\n<li>The \u201cPassword Manager Names\u201d vocabulary and simple password manager registry\nwere moved to the <tt>zope.password</tt> package.</li>\n<li>Remove deprecated code.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3><a href=\"#id50\" rel=\"nofollow\">3.5.0 (2009-03-06)</a></h3>\n<ul>\n<li>Split password manager functionality off to the new <tt>zope.password</tt>\npackage. Backward-compatibility imports are left in place.</li>\n<li>Use <tt>zope.site</tt> instead of <tt>zope.app.component</tt>. (Browser code still\nneeds <tt>zope.app.component</tt> as it depends on view classes of this\npackage.)</li>\n</ul>\n</div>\n<div id=\"a2-2009-02-01\">\n<h3><a href=\"#id51\" rel=\"nofollow\">3.5.0a2 (2009-02-01)</a></h3>\n<ul>\n<li>Make old encoded passwords really work.</li>\n</ul>\n</div>\n<div id=\"a1-2009-01-31\">\n<h3><a href=\"#id52\" rel=\"nofollow\">3.5.0a1 (2009-01-31)</a></h3>\n<ul>\n<li>Use <tt>zope.container</tt> instead of <tt>zope.app.container</tt>. (Browser code\nstill needs <tt>zope.app.container</tt> as it depends on view classes of this\npackage.)</li>\n<li>Encoded passwords are now stored with a prefix ({MD5}, {SHA1},\n{SSHA}) indicating the used encoding schema. Old (encoded) passwords\ncan still be used.</li>\n<li>Add an SSHA password manager that is compatible with standard LDAP\npasswords. As this encoding gives better security agains dictionary\nattacks, users are encouraged to switch to this new password schema.</li>\n<li>InternalPrincipal now uses SSHA password manager by default.</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3><a href=\"#id53\" rel=\"nofollow\">3.4.4 (2008-12-12)</a></h3>\n<ul>\n<li>Depend on zope.session instead of zope.app.session. The first one\ncurrently has all functionality we need.</li>\n<li>Fix deprecation warnings for <tt>md5</tt> and <tt>sha</tt> on Python 2.6.</li>\n</ul>\n</div>\n<div id=\"id13\">\n<h3><a href=\"#id54\" rel=\"nofollow\">3.4.3 (2008-08-07)</a></h3>\n<ul>\n<li>No changes. Retag for correct release on PyPI.</li>\n</ul>\n</div>\n<div id=\"id14\">\n<h3><a href=\"#id55\" rel=\"nofollow\">3.4.2 (2008-07-09)</a></h3>\n<ul>\n<li>Make it compatible with zope.app.container 3.6.1 and 3.5.4 changes,\nChanged <tt>super(BTreeContainer, <span class=\"pre\">self).__init__()</span></tt> to\n<tt>super(GroupFolder, <span class=\"pre\">self).__init__()</span></tt> in <tt>GroupFolder</tt> class.</li>\n</ul>\n</div>\n<div id=\"id15\">\n<h3><a href=\"#id56\" rel=\"nofollow\">3.4.1 (2007-10-24)</a></h3>\n<ul>\n<li>Avoid deprecation warning.</li>\n</ul>\n</div>\n<div id=\"id16\">\n<h3><a href=\"#id57\" rel=\"nofollow\">3.4.0 (2007-10-11)</a></h3>\n<ul>\n<li>Updated package meta-data.</li>\n</ul>\n</div>\n<div id=\"b1-2007-09-27\">\n<h3><a href=\"#id58\" rel=\"nofollow\">3.4.0b1 (2007-09-27)</a></h3>\n<ul>\n<li>First release independent of Zope.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 2846617, "releases": {"3.4.0": [{"comment_text": "", "digests": {"md5": "5b860e3896118680efe4dc84fa77cc90", "sha256": "c4e173700b1b61e6aaacbc664c5dbac598ac6662f5d0cc1ec1e8d8ee09a5c80f"}, "downloads": -1, "filename": "zope.app.authentication-3.4.0.tar.gz", "has_sig": false, "md5_digest": "5b860e3896118680efe4dc84fa77cc90", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 69647, "upload_time": "2007-10-11T05:03:30", "upload_time_iso_8601": "2007-10-11T05:03:30Z", "url": "https://files.pythonhosted.org/packages/59/2e/40ef4592b1c8ad53755bf1f527a71524f64d2324a27d4ecb384b588a9f44/zope.app.authentication-3.4.0.tar.gz", "yanked": false}], "3.4.0a1": [{"comment_text": "", "digests": {"md5": "f49631be64c27e5505af62bf63a2c59b", "sha256": "a345a0f622901af8e736d9266136d1efa6ccc5213027db4241dcd35e3d21f5b6"}, "downloads": -1, "filename": "zope.app.authentication-3.4.0a1.tar.gz", "has_sig": false, "md5_digest": "f49631be64c27e5505af62bf63a2c59b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47796, "upload_time": "2007-04-23T13:30:13", "upload_time_iso_8601": "2007-04-23T13:30:13Z", "url": "https://files.pythonhosted.org/packages/95/55/b8164f49672c871be9b2d017031abbaaa166ac9579f338261df0c2dc7167/zope.app.authentication-3.4.0a1.tar.gz", "yanked": false}], "3.4.1": [{"comment_text": "", "digests": {"md5": "afc91ccdd30fa46913d110a590b8c1a2", "sha256": "b9473df60dfda5bfa024ddaadfc664918468d799629d6c6028a4e304e92c3d68"}, "downloads": -1, "filename": "zope.app.authentication-3.4.1.tar.gz", "has_sig": false, "md5_digest": "afc91ccdd30fa46913d110a590b8c1a2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 70245, "upload_time": "2007-10-24T00:14:31", "upload_time_iso_8601": "2007-10-24T00:14:31Z", "url": "https://files.pythonhosted.org/packages/18/e4/e44c9ad521f77e0cbfab8eaf6bf89813be1d9f1d3aacb56847d808d37a43/zope.app.authentication-3.4.1.tar.gz", "yanked": false}], "3.4.2": [{"comment_text": "", "digests": {"md5": "1062846ab01c19e1528edbfeec8b576d", "sha256": "a1fba02fbe6300aa04c7dda03b81b36900b7d3f9ac58f716afd9873c171d49a3"}, "downloads": -1, "filename": "zope.app.authentication-3.4.2.zip", "has_sig": false, "md5_digest": "1062846ab01c19e1528edbfeec8b576d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 101884, "upload_time": "2008-07-09T09:03:15", "upload_time_iso_8601": "2008-07-09T09:03:15Z", "url": "https://files.pythonhosted.org/packages/ab/17/351f30358e1f72e3854477fe18e33daf44cb43b1dc7ad02ed420c72a9d0a/zope.app.authentication-3.4.2.zip", "yanked": false}], "3.4.3": [{"comment_text": "", "digests": {"md5": "60844130953357fd45c7026a86380210", "sha256": "d31672c18ef74f46a486659466b9897eda1ccc407338792e21e71b06976a9dc4"}, "downloads": -1, "filename": "zope.app.authentication-3.4.3-py2.4.egg", "has_sig": false, "md5_digest": "60844130953357fd45c7026a86380210", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 127857, "upload_time": "2008-08-14T20:21:16", "upload_time_iso_8601": "2008-08-14T20:21:16Z", "url": "https://files.pythonhosted.org/packages/76/4d/19e11be03a98ad9686691d7056ee89a047a52f2b436ae1718ae09e281bd7/zope.app.authentication-3.4.3-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "72bb2512ca6e1165cafd7f3d8a8afccf", "sha256": "08d4039300d5ffe02d4a4d9e5c03d38b7e08032711c9d1a8e78bb1f45f5b1565"}, "downloads": -1, "filename": "zope.app.authentication-3.4.3-py2.5.egg", "has_sig": false, "md5_digest": "72bb2512ca6e1165cafd7f3d8a8afccf", "packagetype": "bdist_egg", "python_version": "2.5", "requires_python": null, "size": 127224, "upload_time": "2008-08-14T20:14:26", "upload_time_iso_8601": "2008-08-14T20:14:26Z", "url": "https://files.pythonhosted.org/packages/da/7b/2a353282eb924d39a5e622858490360fd2ea0869c2c1a15e4907df7cd0db/zope.app.authentication-3.4.3-py2.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b5cb853370263651d7962b1057275590", "sha256": "e244b460c17216031f342cd1bfa76a3cc892375df3b56b1ff8e88a59be46f830"}, "downloads": -1, "filename": "zope.app.authentication-3.4.3.tar.gz", "has_sig": false, "md5_digest": "b5cb853370263651d7962b1057275590", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 70869, "upload_time": "2008-08-06T22:34:57", "upload_time_iso_8601": "2008-08-06T22:34:57Z", "url": "https://files.pythonhosted.org/packages/0d/83/cbacf6b0ca5fcb50ade01490d5ba0d648cde0f3c661f186b6c12800a96b8/zope.app.authentication-3.4.3.tar.gz", "yanked": false}], "3.4.4": [{"comment_text": "", "digests": {"md5": "02458f70797e29c95fca9d1f430500dd", "sha256": "a6bc36d8e456edf06f8e4dd5bd3be436db55a9214dd077386eea9cb6c12ff177"}, "downloads": -1, "filename": "zope.app.authentication-3.4.4.tar.gz", "has_sig": false, "md5_digest": "02458f70797e29c95fca9d1f430500dd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 69110, "upload_time": "2008-12-12T09:06:16", "upload_time_iso_8601": "2008-12-12T09:06:16Z", "url": "https://files.pythonhosted.org/packages/d3/f5/4af3f46ed24d7182a36ba77a1ce5182cb4a5ff04c3932cc7af4fc7436afc/zope.app.authentication-3.4.4.tar.gz", "yanked": false}], "3.4.5": [{"comment_text": "", "digests": {"md5": "b1fd53f164f319332d27f93f92f45e3e", "sha256": "95cd365ab589f6885c15bf43b62b423d013d53b0cd807351ceb4d69a9f34eb1e"}, "downloads": -1, "filename": "zope.app.authentication-3.4.5.tar.gz", "has_sig": false, "md5_digest": "b1fd53f164f319332d27f93f92f45e3e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72465, "upload_time": "2010-05-27T12:01:11", "upload_time_iso_8601": "2010-05-27T12:01:11.079891Z", "url": "https://files.pythonhosted.org/packages/95/a3/4dab69af172d4dd0dc888ca414b6989db2b3f28e62d741fe102a6c9901d8/zope.app.authentication-3.4.5.tar.gz", "yanked": false}], "3.4.6": [{"comment_text": "", "digests": {"md5": "a6cbf6b057093c556788a6eb7efa3961", "sha256": "90a77bd2eded0adc3775aec64d26292aee0f1ea1ac5908328ec764bd93be91c6"}, "downloads": -1, "filename": "zope.app.authentication-3.4.6.tar.gz", "has_sig": false, "md5_digest": "a6cbf6b057093c556788a6eb7efa3961", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72522, "upload_time": "2010-05-27T12:29:18", "upload_time_iso_8601": "2010-05-27T12:29:18.629667Z", "url": "https://files.pythonhosted.org/packages/21/71/76eede565d9dab1d8267ec4a0244086fc1ea619bd6466a6d7f47529a8aa9/zope.app.authentication-3.4.6.tar.gz", "yanked": false}], "3.5.0": [{"comment_text": "", "digests": {"md5": "8b4634a1ab1e60ec4bbfb0692ced8a1c", "sha256": "2a9d16c76f6a9cec2f5dbe2623e4fc395bdf26a20cbb19af3e666e7e5e20e4c4"}, "downloads": -1, "filename": "zope.app.authentication-3.5.0.tar.gz", "has_sig": false, "md5_digest": "8b4634a1ab1e60ec4bbfb0692ced8a1c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 69231, "upload_time": "2009-03-06T14:15:01", "upload_time_iso_8601": "2009-03-06T14:15:01.074900Z", "url": "https://files.pythonhosted.org/packages/e5/b0/57659a92e5e511c0844abf2e5be04b7e343cf013157f528783b9ecd8822a/zope.app.authentication-3.5.0.tar.gz", "yanked": false}], "3.5.0a1": [{"comment_text": "", "digests": {"md5": "3598a1708cc25bded940a525cf9cb882", "sha256": "6c8d502b379c69b4203bc8c1cc64e8a5a5909bb695c4f2c02ac266bc714fb0cb"}, "downloads": -1, "filename": "zope.app.authentication-3.5.0a1.tar.gz", "has_sig": false, "md5_digest": "3598a1708cc25bded940a525cf9cb882", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 71450, "upload_time": "2009-01-31T14:00:36", "upload_time_iso_8601": "2009-01-31T14:00:36Z", "url": "https://files.pythonhosted.org/packages/48/f8/74c5a78f5f6114683417ea74dfecbe636084bf016e922e9ce272989696fc/zope.app.authentication-3.5.0a1.tar.gz", "yanked": false}], "3.5.0a2": [{"comment_text": "", "digests": {"md5": "92230937c6592a37d495d735175c809a", "sha256": "ac16189c9099c9aab18fd189c20dbd0cef8f0737bce4a9fe2bd1c5f20d2cfe86"}, "downloads": -1, "filename": "zope.app.authentication-3.5.0a2.tar.gz", "has_sig": false, "md5_digest": "92230937c6592a37d495d735175c809a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 71809, "upload_time": "2009-02-01T13:28:19", "upload_time_iso_8601": "2009-02-01T13:28:19Z", "url": "https://files.pythonhosted.org/packages/b0/5c/8fd92e242b2dad1f40f5cda9e098e165d82544ffc36aca0a3c86a8efb4d2/zope.app.authentication-3.5.0a2.tar.gz", "yanked": false}], "3.6.0": [{"comment_text": "", "digests": {"md5": "81be670bbff197343a9c2da2c8875621", "sha256": "0c1e64ecca02bf043b6e3c77be8804122566f52b43a5cb01e974e81144173521"}, "downloads": -1, "filename": "zope.app.authentication-3.6.0.tar.gz", "has_sig": false, "md5_digest": "81be670bbff197343a9c2da2c8875621", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 70788, "upload_time": "2009-03-14T18:12:58", "upload_time_iso_8601": "2009-03-14T18:12:58.496306Z", "url": "https://files.pythonhosted.org/packages/de/28/a23f92cffa885c80b292fe9c43b783ee55cf4169715c044bd92590d7806b/zope.app.authentication-3.6.0.tar.gz", "yanked": false}], "3.6.1": [{"comment_text": "", "digests": {"md5": "c84c8b686b270e04e23f443a5a1e4a1c", "sha256": "7a0f5805f467244e1c0676088a34115daf22554ed84ddab93d5ddcb36eaca5a5"}, "downloads": -1, "filename": "zope.app.authentication-3.6.1.tar.gz", "has_sig": true, "md5_digest": "c84c8b686b270e04e23f443a5a1e4a1c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 71956, "upload_time": "2009-10-07T17:33:17", "upload_time_iso_8601": "2009-10-07T17:33:17.158763Z", "url": "https://files.pythonhosted.org/packages/b7/bd/740c2d6a060ec4ad9afd8f8308bdcecb798db29d7aeb0229fe36b57f0330/zope.app.authentication-3.6.1.tar.gz", "yanked": false}], "3.6.2": [{"comment_text": "", "digests": {"md5": "99372d62cf20418d9acb96487fee126f", "sha256": "edb7826a7c5a290ab536e89735770b4983afa9349f8a07c810d3652159530f8d"}, "downloads": -1, "filename": "zope.app.authentication-3.6.2.tar.gz", "has_sig": false, "md5_digest": "99372d62cf20418d9acb96487fee126f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 70971, "upload_time": "2010-01-05T00:05:34", "upload_time_iso_8601": "2010-01-05T00:05:34.840072Z", "url": "https://files.pythonhosted.org/packages/01/49/46ababdbab81613ded016e1d71fbc2d6b29e26ee3a0bbdbcea563d106c50/zope.app.authentication-3.6.2.tar.gz", "yanked": false}], "3.7.0": [{"comment_text": "", "digests": {"md5": "7c23268ecb2a83b788b7001fc1a33707", "sha256": "ca02f5e23f89ee3f87d89cf49b98d15253d24d28f98d70d7a3c00473a7309914"}, "downloads": -1, "filename": "zope.app.authentication-3.7.0.tar.gz", "has_sig": false, "md5_digest": "7c23268ecb2a83b788b7001fc1a33707", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63407, "upload_time": "2010-02-08T16:56:02", "upload_time_iso_8601": "2010-02-08T16:56:02.070171Z", "url": "https://files.pythonhosted.org/packages/a3/0d/4bc504d7cff15d812bbc7fe0828b29ce3781732881d7a6798e658d64ad15/zope.app.authentication-3.7.0.tar.gz", "yanked": false}], "3.7.1": [{"comment_text": "", "digests": {"md5": "bae5fdf3535b830e3aeab8f0e610ba43", "sha256": "636ff4b8da61198be0111c3acb0968968cd9ee3bb3fd262eff3db9a0e95789e1"}, "downloads": -1, "filename": "zope.app.authentication-3.7.1.tar.gz", "has_sig": false, "md5_digest": "bae5fdf3535b830e3aeab8f0e610ba43", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63565, "upload_time": "2010-02-11T20:00:55", "upload_time_iso_8601": "2010-02-11T20:00:55.595956Z", "url": "https://files.pythonhosted.org/packages/5b/a1/52fd86ff362ecf99646a91cfb5297bceac945d18f8fc3eb49296dc873c09/zope.app.authentication-3.7.1.tar.gz", "yanked": false}], "3.8.0": [{"comment_text": "", "digests": {"md5": "f8eb74fbdeebfd32c5e15c0f03aa3623", "sha256": "e203566f72d70a2a7745c12533d3892d3a1174c8298f191d6eef552d25ec8f37"}, "downloads": -1, "filename": "zope.app.authentication-3.8.0.tar.gz", "has_sig": false, "md5_digest": "f8eb74fbdeebfd32c5e15c0f03aa3623", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 76566, "upload_time": "2010-09-25T11:07:26", "upload_time_iso_8601": "2010-09-25T11:07:26.298315Z", "url": "https://files.pythonhosted.org/packages/1d/c2/7c91305c7f9d321ba4192c36cf7be11b78c82119a64dd5223d920002d179/zope.app.authentication-3.8.0.tar.gz", "yanked": false}], "3.9": [{"comment_text": "", "digests": {"md5": "55881ac16a852d756f39233ec2ee25cc", "sha256": "bf3a51fec77359da5994c9dd5f26b443ca305b140fce4fbca363befe43d05dba"}, "downloads": -1, "filename": "zope.app.authentication-3.9.tar.gz", "has_sig": false, "md5_digest": "55881ac16a852d756f39233ec2ee25cc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 71071, "upload_time": "2010-10-18T11:51:19", "upload_time_iso_8601": "2010-10-18T11:51:19.510456Z", "url": "https://files.pythonhosted.org/packages/b3/86/ba2b3ee8f19c578d68568b326da308176bd16e70f8c3e6be8c7f63784a2d/zope.app.authentication-3.9.tar.gz", "yanked": false}], "4.0.0": [{"comment_text": "", "digests": {"md5": "9a978618bbf6fefb1aecd574f9d1464d", "sha256": "30c82a7ad65c108235b0aad49b9df2cac8695508ef276501becad959193dd385"}, "downloads": -1, "filename": "zope.app.authentication-4.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9a978618bbf6fefb1aecd574f9d1464d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 100824, "upload_time": "2017-05-02T14:26:58", "upload_time_iso_8601": "2017-05-02T14:26:58.263123Z", "url": "https://files.pythonhosted.org/packages/c8/5c/368692477b7ecafc788560b3636ee126d6f3ec9584ee15cc242fb28f69d3/zope.app.authentication-4.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4f8928b6b839dd435b30eb492e2bdc49", "sha256": "52ba5d49bf1c55043eca69c0c9b02a48281c719271e4d7482fb2098eeddbf593"}, "downloads": -1, "filename": "zope.app.authentication-4.0.0.tar.gz", "has_sig": false, "md5_digest": "4f8928b6b839dd435b30eb492e2bdc49", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75890, "upload_time": "2017-05-02T14:27:00", "upload_time_iso_8601": "2017-05-02T14:27:00.360279Z", "url": "https://files.pythonhosted.org/packages/1e/30/37732e261cc731968baf44baad3870545c5832de58ec122b50375cbb7fe5/zope.app.authentication-4.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9a978618bbf6fefb1aecd574f9d1464d", "sha256": "30c82a7ad65c108235b0aad49b9df2cac8695508ef276501becad959193dd385"}, "downloads": -1, "filename": "zope.app.authentication-4.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9a978618bbf6fefb1aecd574f9d1464d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 100824, "upload_time": "2017-05-02T14:26:58", "upload_time_iso_8601": "2017-05-02T14:26:58.263123Z", "url": "https://files.pythonhosted.org/packages/c8/5c/368692477b7ecafc788560b3636ee126d6f3ec9584ee15cc242fb28f69d3/zope.app.authentication-4.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4f8928b6b839dd435b30eb492e2bdc49", "sha256": "52ba5d49bf1c55043eca69c0c9b02a48281c719271e4d7482fb2098eeddbf593"}, "downloads": -1, "filename": "zope.app.authentication-4.0.0.tar.gz", "has_sig": false, "md5_digest": "4f8928b6b839dd435b30eb492e2bdc49", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75890, "upload_time": "2017-05-02T14:27:00", "upload_time_iso_8601": "2017-05-02T14:27:00.360279Z", "url": "https://files.pythonhosted.org/packages/1e/30/37732e261cc731968baf44baad3870545c5832de58ec122b50375cbb7fe5/zope.app.authentication-4.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:14:35 2020"}