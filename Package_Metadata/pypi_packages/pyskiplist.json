{"info": {"author": "Geert Jansen", "author_email": "geertj@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4"], "description": "Welcome to PySkipList\n=====================\n\n.. image:: https://travis-ci.org/geertj/pyskiplist.svg?branch=master\n    :target: https://travis-ci.org/geertj/pyskiplist\n\n.. image:: https://coveralls.io/repos/geertj/pyskiplist/badge.svg?branch=master\n    :target: https://coveralls.io/r/geertj/pyskiplist\n\nPySkipList is a fast, pure Python implementation of an indexable skiplist. It\nimplements a ``SkipList`` data structure that provides an always sorted,\nlist-like data structure for (key, value) pairs. It efficiently supports the\nfollowing operations:\n\n* Insert a pair in the list, maintaining sorted order.\n* Find the value of a given key.\n* Remove a given pair based on a key.\n* Iterate over all pairs in sorted order.\n* Find the position of a given key.\n* Access a pair at a certain position.\n* Delete a pair at a certain position.\n  \nSince PySkipList is a pure Python implementation, it should work well on\nalternative Python implementations such as PyPy and Jython.\n\n\nExample\n-------\n\nThe following provides a few examples on how to use the ``SkipList`` API::\n\n  >>> from pyskiplist import SkipList\n  >>> sl = SkipList()\n  >>> sl.insert('foo', 'bar')\n  >>> sl.insert('baz', 'qux')\n  >>> sl\n  SkipList((('baz', 'qux'), ('foo', 'bar')))\n  >>> sl.search('foo')\n  'bar'\n  >>> sl[0]\n  ('baz', 'qux')\n  >>> sl.remove('foo')  # remove by key\n  >>> del sl[0]  # remove by position\n\n\nAsymptotic Complexity\n---------------------\n\nBelow are the Big-O complexities of the various operations implemented by\npyskiplist:\n\n==================  ==========\nOperation           Complexity\n==================  ==========\ninsertion           O(log N)\nsearch by key       O(log N)\nremoval by key      O(log N) \nforward iteration   O(1)\nfind by position    O(log N)\naccess by position  O(log N)\ndelete by position  O(log N)\n==================  ==========\n\n\nPerformance\n-----------\n\nBelow are the results of some performance tests. These are for Python 3.4.2 on\nmy Linux laptop:\n\n===================  ===================\nTest                 Operations / second\n===================  ===================\nInsert @ 1k nodes    45,056\nInsert @ 10k nodes   42,137\nInsert @ 100k nodes  28,086\nRemove @ 1k nodes    54,316\nRemove @ 10k nodes   46,240\nRemove @ 100k nodes  35,114\nSearch @ 1k nodes    137,248\nSearch @ 10k nodes   109,480\nSearch @ 100k nodes  77,939\n===================  ===================\n\n\nMemory usage\n------------\n\nPySkipList tries to be efficient with regards to memory usage. The numbers\nbelow are for Python 3.4.2 on my Linux laptop. This specific test stores pairs\nof integer keys and an integer values in a skiplist. The total size of the two\nintegers on this Python version is 56 bytes.\n\n=====  ============  =================\nNodes  Bytes / node  Overhead (fixed)\n=====  ============  =================\n1k     164           108\n10k    162           106\n100k   162           106\n=====  ============  =================\n\n\nImplementation notes\n--------------------\n\nReference papers on skiplists:\n\n* ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf (original paper)\n* http://drum.lib.umd.edu/bitstream/1903/544/2/CS-TR-2286.1.pdf (cookbook)\n\nThis implementation uses a novel (as far as I know) technique where it stores\njust a single link width per node, and only in nodes with level > 0. The link\ncorresponds to the number of nodes skipped by the highest incoming link. Other\nimplementations that I've seen all store a width for every link. This approach\nsaves a lot of memory. The overhead should just be 1/e (0.37) integers per\nnode. It makes an indexable skiplist almost as memory efficient as its\nnon-indexable cousin.\n\nDuplicate keys are allowed in this implementation, and insertion order is\nmaintained.\n\nSkiplist nodes are implemented as plain lists instead of objects. This saves\nmemory. Kudos to http://pythonsweetness.tumblr.com/post/45227295342 for the\nidea.\n\nThe built-in Mersenne Twister is used as the random source. This is preferable\nover SystemRandom since it doesn't require a system call and there is no need\nfor cryptographically secure numbers.\n", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/geertj/pyskiplist", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "pyskiplist", "package_url": "https://pypi.org/project/pyskiplist/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pyskiplist/", "project_urls": {"Homepage": "https://github.com/geertj/pyskiplist"}, "release_url": "https://pypi.org/project/pyskiplist/1.0.0/", "requires_dist": null, "requires_python": null, "summary": "Fast, pure Python indexable skip list", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/geertj/pyskiplist\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/geertj/pyskiplist.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/09f0b1f54623fc8db9fb5981bf7a2564728cb022/68747470733a2f2f7472617669732d63692e6f72672f67656572746a2f7079736b69706c6973742e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/r/geertj/pyskiplist\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/geertj/pyskiplist/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/be19d9e09e6b880ead0ed194576550a75aec1206/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f67656572746a2f7079736b69706c6973742f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<p>PySkipList is a fast, pure Python implementation of an indexable skiplist. It\nimplements a <tt>SkipList</tt> data structure that provides an always sorted,\nlist-like data structure for (key, value) pairs. It efficiently supports the\nfollowing operations:</p>\n<ul>\n<li>Insert a pair in the list, maintaining sorted order.</li>\n<li>Find the value of a given key.</li>\n<li>Remove a given pair based on a key.</li>\n<li>Iterate over all pairs in sorted order.</li>\n<li>Find the position of a given key.</li>\n<li>Access a pair at a certain position.</li>\n<li>Delete a pair at a certain position.</li>\n</ul>\n<p>Since PySkipList is a pure Python implementation, it should work well on\nalternative Python implementations such as PyPy and Jython.</p>\n<div id=\"example\">\n<h2>Example</h2>\n<p>The following provides a few examples on how to use the <tt>SkipList</tt> API:</p>\n<pre>&gt;&gt;&gt; from pyskiplist import SkipList\n&gt;&gt;&gt; sl = SkipList()\n&gt;&gt;&gt; sl.insert('foo', 'bar')\n&gt;&gt;&gt; sl.insert('baz', 'qux')\n&gt;&gt;&gt; sl\nSkipList((('baz', 'qux'), ('foo', 'bar')))\n&gt;&gt;&gt; sl.search('foo')\n'bar'\n&gt;&gt;&gt; sl[0]\n('baz', 'qux')\n&gt;&gt;&gt; sl.remove('foo')  # remove by key\n&gt;&gt;&gt; del sl[0]  # remove by position\n</pre>\n</div>\n<div id=\"asymptotic-complexity\">\n<h2>Asymptotic Complexity</h2>\n<p>Below are the Big-O complexities of the various operations implemented by\npyskiplist:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Operation</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>insertion</td>\n<td>O(log N)</td>\n</tr>\n<tr><td>search by key</td>\n<td>O(log N)</td>\n</tr>\n<tr><td>removal by key</td>\n<td>O(log N)</td>\n</tr>\n<tr><td>forward iteration</td>\n<td>O(1)</td>\n</tr>\n<tr><td>find by position</td>\n<td>O(log N)</td>\n</tr>\n<tr><td>access by position</td>\n<td>O(log N)</td>\n</tr>\n<tr><td>delete by position</td>\n<td>O(log N)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"performance\">\n<h2>Performance</h2>\n<p>Below are the results of some performance tests. These are for Python 3.4.2 on\nmy Linux laptop:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Test</th>\n<th>Operations / second</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>Insert @ 1k nodes</td>\n<td>45,056</td>\n</tr>\n<tr><td>Insert @ 10k nodes</td>\n<td>42,137</td>\n</tr>\n<tr><td>Insert @ 100k nodes</td>\n<td>28,086</td>\n</tr>\n<tr><td>Remove @ 1k nodes</td>\n<td>54,316</td>\n</tr>\n<tr><td>Remove @ 10k nodes</td>\n<td>46,240</td>\n</tr>\n<tr><td>Remove @ 100k nodes</td>\n<td>35,114</td>\n</tr>\n<tr><td>Search @ 1k nodes</td>\n<td>137,248</td>\n</tr>\n<tr><td>Search @ 10k nodes</td>\n<td>109,480</td>\n</tr>\n<tr><td>Search @ 100k nodes</td>\n<td>77,939</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"memory-usage\">\n<h2>Memory usage</h2>\n<p>PySkipList tries to be efficient with regards to memory usage. The numbers\nbelow are for Python 3.4.2 on my Linux laptop. This specific test stores pairs\nof integer keys and an integer values in a skiplist. The total size of the two\nintegers on this Python version is 56 bytes.</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Nodes</th>\n<th>Bytes / node</th>\n<th>Overhead (fixed)</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>1k</td>\n<td>164</td>\n<td>108</td>\n</tr>\n<tr><td>10k</td>\n<td>162</td>\n<td>106</td>\n</tr>\n<tr><td>100k</td>\n<td>162</td>\n<td>106</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"implementation-notes\">\n<h2>Implementation notes</h2>\n<p>Reference papers on skiplists:</p>\n<ul>\n<li><a>ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf</a> (original paper)</li>\n<li><a href=\"http://drum.lib.umd.edu/bitstream/1903/544/2/CS-TR-2286.1.pdf\" rel=\"nofollow\">http://drum.lib.umd.edu/bitstream/1903/544/2/CS-TR-2286.1.pdf</a> (cookbook)</li>\n</ul>\n<p>This implementation uses a novel (as far as I know) technique where it stores\njust a single link width per node, and only in nodes with level &gt; 0. The link\ncorresponds to the number of nodes skipped by the highest incoming link. Other\nimplementations that I\u2019ve seen all store a width for every link. This approach\nsaves a lot of memory. The overhead should just be 1/e (0.37) integers per\nnode. It makes an indexable skiplist almost as memory efficient as its\nnon-indexable cousin.</p>\n<p>Duplicate keys are allowed in this implementation, and insertion order is\nmaintained.</p>\n<p>Skiplist nodes are implemented as plain lists instead of objects. This saves\nmemory. Kudos to <a href=\"http://pythonsweetness.tumblr.com/post/45227295342\" rel=\"nofollow\">http://pythonsweetness.tumblr.com/post/45227295342</a> for the\nidea.</p>\n<p>The built-in Mersenne Twister is used as the random source. This is preferable\nover SystemRandom since it doesn\u2019t require a system call and there is no need\nfor cryptographically secure numbers.</p>\n</div>\n\n          </div>"}, "last_serial": 1609610, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "af517550031d59489edaf3161d39209c", "sha256": "5fba901abf577538f4e97e909a1b629c63550cef8c9205c2414c822a3fc7a458"}, "downloads": -1, "filename": "pyskiplist-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "af517550031d59489edaf3161d39209c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8580, "upload_time": "2015-06-27T23:51:16", "upload_time_iso_8601": "2015-06-27T23:51:16.980841Z", "url": "https://files.pythonhosted.org/packages/31/db/576c89e0f78a7b29d62633548edf7ef871f3dc62d680a315e4f49d06f0db/pyskiplist-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bfee80f564d04937315dd6cbce9c75f7", "sha256": "2296f67e6591e01c57ea1837aa7ae722fa8f4701a38069cc33ffd3e56d807ffa"}, "downloads": -1, "filename": "pyskiplist-1.0.0.tar.gz", "has_sig": false, "md5_digest": "bfee80f564d04937315dd6cbce9c75f7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7999, "upload_time": "2015-06-27T23:51:20", "upload_time_iso_8601": "2015-06-27T23:51:20.177055Z", "url": "https://files.pythonhosted.org/packages/eb/93/8263fe0e391f65f9a9ade497ff9a165f4fc9559a84aa3db15190a85e768b/pyskiplist-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "af517550031d59489edaf3161d39209c", "sha256": "5fba901abf577538f4e97e909a1b629c63550cef8c9205c2414c822a3fc7a458"}, "downloads": -1, "filename": "pyskiplist-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "af517550031d59489edaf3161d39209c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8580, "upload_time": "2015-06-27T23:51:16", "upload_time_iso_8601": "2015-06-27T23:51:16.980841Z", "url": "https://files.pythonhosted.org/packages/31/db/576c89e0f78a7b29d62633548edf7ef871f3dc62d680a315e4f49d06f0db/pyskiplist-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bfee80f564d04937315dd6cbce9c75f7", "sha256": "2296f67e6591e01c57ea1837aa7ae722fa8f4701a38069cc33ffd3e56d807ffa"}, "downloads": -1, "filename": "pyskiplist-1.0.0.tar.gz", "has_sig": false, "md5_digest": "bfee80f564d04937315dd6cbce9c75f7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7999, "upload_time": "2015-06-27T23:51:20", "upload_time_iso_8601": "2015-06-27T23:51:20.177055Z", "url": "https://files.pythonhosted.org/packages/eb/93/8263fe0e391f65f9a9ade497ff9a165f4fc9559a84aa3db15190a85e768b/pyskiplist-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:38 2020"}