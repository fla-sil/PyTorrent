{"info": {"author": "Richard Mitchell", "author_email": "richard@netsight.co.uk", "bugtrack_url": null, "classifiers": ["Framework :: Plone", "Framework :: Zope2", "Programming Language :: Python"], "description": "==============\nnetsight.async\n==============\n\nIntroduction\n============\n\nnetsight.async provides a base browser view for the Zope Web Framework\nwhich enables browser requests to run in the background whilst progress\nof the request is returned to the browser.\n\nUsage\n=====\n\nBasic\n-----\n\nFirst, subclass the ``BaseAsyncView`` class. Where you might ordinarily\nwrite code in the ``__call__`` method of a view class, to perform some\nprocess, instead, place it in the ``__run__`` method. ::\n\n    >>> import time\n    >>> from netsight.async.browser.BaseAsyncView import BaseAsyncView\n    >>> class MyView(BaseAsyncView):\n    ...    \n    ...    def __run__(self, *args, **kwargs):\n    ...         time.sleep(30)\n    ...         return \"Hello world!\"\n    ...\n    >>>\n    \nWhen you call this view from the browser, it will display whatever\noutput is configured as normal. When you perform a POST request to the\nview, however, the ``__run__`` method will be called in the background\nas if it were the ``__call__`` method of the view class. Meanwhile, a\npage displaying a spinner will be returned to the browser and will poll\nat 5 second intervals until the process defined in ``__run__``\ncompletes.\n\nOnce the ``__run__`` method has completed, the browser will redirect to\nthe result.\n\nExample timeline:\n~~~~~~~~~~~~~~~~~\n\n 1. User visits '/myview' and is shown some form.\n \n 2. User submits the form, the process is started in the background.\n \n 3. The user is redirected to\n    '/myview/processing?process_id=abcde-f01234' which shows a spinner.\n    \n 4. The user's current page polls for process status for up to 30\n    seconds via AJAX if possible, otherwise by page refresh.\n    \n 5. Once the process has completed, the user is redirected to\n    '/myview/result?process_id=abcde-f01234' and shown \"Hello world!\"\n\nUsing with page templates\n-------------------------\n\nIf you have configured a browser view for your view class with a\npage template file specified in ZCML, this will be shown by default\nwhen the view is first called. If the view is POSTed to, then the\nprocess will be kick-started. You can change the initial template and\nthe conditions under which the process is started by overriding the\n``initial_page`` and the ``run_process`` methods of the view. ::\n\n    >>> from Products.Five.browser.pagetemplatefile import \\\n    ...      ViewPageTemplateFile\n    >>>\n    >>> class MyView(BaseAsyncView):\n    ...     \n    ...     def run_process(self):\n    ...         return 'run' in self.request.form\n    ...     \n    ...     initial_page = \\\n    ...         ViewPageTemplateFile('templates/my_template.pt')\n    ...\n    >>>\n    \nOr you could use a method::\n\n    >>> class MyView(BaseAsyncView):\n    ...     \n    ...     def initial_page(self, *args, **kwargs):\n    ...         return 'Hello world!'\n    ...\n    >>>\n    \nYou can also override the page returned to the browser once the process\nhas been started by overriding the processing_page method.\n\nIf you want to call a template defined in ZCML from your ``__run__``\nmethod, you may pass a ``True`` value named ``no_process` to the call\nmethod if your ``run_process`` method would ordinarily start the\nprocess again. ::\n\n    >>> class MyView(BaseAsyncView):\n    ...     \n    ...     def __run__(self, *args, **kwargs):\n    ...         return self.__call__(message=\"Hello world\",\n    ...                              no_process=True)\n    ...\n    >>>\n\n\nChecking the status & retrieving the result\n-------------------------------------------\n\nOnce you have kicked off your ``__run__`` method,  the resulting\nresponse will redirect to the processing view, with a unique ID for the\nnewly started process given as a GET variable, ``process_id``.\n\nThis process ID can be used to retrieve information on the status of\nthe process and its result.\n\nCalling the ``completed`` method of the view with the process ID will\nreturn either a ``True`` or ``False`` completion state, or a number\nrepresenting a percentage completion out of 100 (more on recording\nprogress later). If the optional argument, ``output_json`` is set to\nsome value which evaluates to ``True``, the method returns a JSON\nobject with the single key, ``completed`` containing the same ``True``,\n``False`` or numeric value.\n\nIf your process died before it completed, it will raise an error, or if\nJSON output is chosen, it will return a ``completed`` value of the\nstring, 'ERROR'.\n\nTo retrieve the result of the ``__run__`` method once it has completed,\ncall the ``result`` method of the view with the process ID.\n\nIf your process died before it completed, this too will raise an error,\nor if JSON output is chosen, it will return a ``completed`` value of\nthe string, 'ERROR'.\n\nIf the process has not yet completed when ``result`` is called,\n``None`` will be returned.\n\nSetting process progress from your task\n---------------------------------------\n\nIf you want your task to return some measure of completion you can call\nthe ``set_progress`` method with the process ID and some numeric value.\n::\n\n    >>> class MyView(BaseAsyncView):\n    ...    \n    ...    def __run__(self, process_id=None, *args, **kwargs):\n    ...         time.sleep(15)\n    ...         self.set_progress(process_id, 50)\n    ...         time.sleep(15)\n    ...         return \"Hello world!\"\n    ...\n    >>>\n    \nWhen your task completes without raising an exception, the progress is\nautomatically set to 100 so there is no need to set this before the\nmethod returns.\n\nInstallation\n============\n\nSimply add ``netsight.async`` to the ``eggs`` section of your buildout\nconfiguration. If you also plan on using the stock 'processing' page,\nyou may also need to add it to the ``zcml`` section. ::\n\n  [buildout]\n  eggs = ...\n         netsight.async\n  zcml = ...\n         netsight.async\n\nLimitations\n===========\n\nBecause running the new process cannot be done using existing threads\nfrom the Zope pool, for the duration of the asynchronous process, an\nextra thread is created by the Zope process, beyond the normal thread\nlimit. This also means an extra connection is opened to the ZODB beyond\nthe normal connection limit which may cause a warning to be shown in\neither the console or log files.\n\nOnce the ``__run__`` method has started, it cannot be stopped by the\nuser in any way. This a feature that subclasses may implement if\nthey choose, but would be dangerous to implement in this package\nwithout knowledge of what the background task was doing & what cleanup\nmay be required.\n\nTo be improved\n==============\n\nCurrently processes are stored in memory of a particular Python\ninstance. This introduces the following issues:\n\n * If the user never retrieves the results from the ``__run__``\n   method, they are stored in the ZODB permanently.\n\nDependencies\n============\n\n * Python>=2.4.0\n\n * zope.component>=3.4.0\n \n * zope.i18n>=3.4.0\n \n * zope.i18nmessageid>=3.4.0\n \n * zope.publisher\n \n * Zope>=2.8.0\n \nThe default processing page template depends on a main template being,\nprovided, much like the one provided by Products.CMFPlone, however\nthis may be overridden by your own view, as discussed above.\n\nContributions\n=============\n\nYou can find the source code for this project at:\n\n  http://github.com/netsight/netsight.async\n\nThis product needs translations! There are only 2 strings to do, so\nthis is a really quick and easy way to contribute to an open-source\nproject.\n\nAny bug fixes, new features & documentation improvements are welcome,\njust submit a pull request on github.\n\nChangelog\n=========\n\n1.1.1 - (2011-10-27)\n--------------------\n\n - Fix process completion detection when progress is set to 100.\n\n1.1.0 - (2011-10-27)\n--------------------\n\n - Made Python 2.4 compatible.\n \n - Process progress/result storage is now held in the ZODB, rather than\n   in a Python instance's memory.\n\n1.0.1 - (2011-10-19)\n--------------------\n\n - Fixed package manifest.\n \n - Fixed markup on processing page. \n\n1.0.0 - (2011-10-19)\n--------------------\nInitial release.\n\nLicense\n=======\n\nCopyright 2011 Netsight Internet Solutions Limited\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://www.netsight.co.uk", "keywords": "Plone Zope Asynchronous Fork Process Task Browser View", "license": "Apache 2.0", "maintainer": null, "maintainer_email": null, "name": "netsight.async", "package_url": "https://pypi.org/project/netsight.async/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/netsight.async/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://www.netsight.co.uk"}, "release_url": "https://pypi.org/project/netsight.async/1.1.1/", "requires_dist": null, "requires_python": null, "summary": "Provides a base view for running asynchronous processes from Zope.", "version": "1.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>netsight.async provides a base browser view for the Zope Web Framework\nwhich enables browser requests to run in the background whilst progress\nof the request is returned to the browser.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<div id=\"basic\">\n<h3>Basic</h3>\n<p>First, subclass the <tt>BaseAsyncView</tt> class. Where you might ordinarily\nwrite code in the <tt>__call__</tt> method of a view class, to perform some\nprocess, instead, place it in the <tt>__run__</tt> method.</p>\n<pre>&gt;&gt;&gt; import time\n&gt;&gt;&gt; from netsight.async.browser.BaseAsyncView import BaseAsyncView\n&gt;&gt;&gt; class MyView(BaseAsyncView):\n...\n...    def __run__(self, *args, **kwargs):\n...         time.sleep(30)\n...         return \"Hello world!\"\n...\n&gt;&gt;&gt;\n</pre>\n<p>When you call this view from the browser, it will display whatever\noutput is configured as normal. When you perform a POST request to the\nview, however, the <tt>__run__</tt> method will be called in the background\nas if it were the <tt>__call__</tt> method of the view class. Meanwhile, a\npage displaying a spinner will be returned to the browser and will poll\nat 5 second intervals until the process defined in <tt>__run__</tt>\ncompletes.</p>\n<p>Once the <tt>__run__</tt> method has completed, the browser will redirect to\nthe result.</p>\n<div id=\"example-timeline\">\n<h4>Example timeline:</h4>\n<blockquote>\n<ol>\n<li>User visits \u2018/myview\u2019 and is shown some form.</li>\n<li>User submits the form, the process is started in the background.</li>\n<li>The user is redirected to\n\u2018/myview/processing?process_id=abcde-f01234\u2019 which shows a spinner.</li>\n<li>The user\u2019s current page polls for process status for up to 30\nseconds via AJAX if possible, otherwise by page refresh.</li>\n<li>Once the process has completed, the user is redirected to\n\u2018/myview/result?process_id=abcde-f01234\u2019 and shown \u201cHello world!\u201d</li>\n</ol>\n</blockquote>\n</div>\n</div>\n<div id=\"using-with-page-templates\">\n<h3>Using with page templates</h3>\n<p>If you have configured a browser view for your view class with a\npage template file specified in ZCML, this will be shown by default\nwhen the view is first called. If the view is POSTed to, then the\nprocess will be kick-started. You can change the initial template and\nthe conditions under which the process is started by overriding the\n<tt>initial_page</tt> and the <tt>run_process</tt> methods of the view.</p>\n<pre>&gt;&gt;&gt; from Products.Five.browser.pagetemplatefile import \\\n...      ViewPageTemplateFile\n&gt;&gt;&gt;\n&gt;&gt;&gt; class MyView(BaseAsyncView):\n...\n...     def run_process(self):\n...         return 'run' in self.request.form\n...\n...     initial_page = \\\n...         ViewPageTemplateFile('templates/my_template.pt')\n...\n&gt;&gt;&gt;\n</pre>\n<p>Or you could use a method:</p>\n<pre>&gt;&gt;&gt; class MyView(BaseAsyncView):\n...\n...     def initial_page(self, *args, **kwargs):\n...         return 'Hello world!'\n...\n&gt;&gt;&gt;\n</pre>\n<p>You can also override the page returned to the browser once the process\nhas been started by overriding the processing_page method.</p>\n<p>If you want to call a template defined in ZCML from your <tt>__run__</tt>\nmethod, you may pass a <tt>True</tt> value named <tt>no_process` to the call\nmethod if your ``run_process</tt> method would ordinarily start the\nprocess again.</p>\n<pre>&gt;&gt;&gt; class MyView(BaseAsyncView):\n...\n...     def __run__(self, *args, **kwargs):\n...         return self.__call__(message=\"Hello world\",\n...                              no_process=True)\n...\n&gt;&gt;&gt;\n</pre>\n</div>\n<div id=\"checking-the-status-retrieving-the-result\">\n<h3>Checking the status &amp; retrieving the result</h3>\n<p>Once you have kicked off your <tt>__run__</tt> method,  the resulting\nresponse will redirect to the processing view, with a unique ID for the\nnewly started process given as a GET variable, <tt>process_id</tt>.</p>\n<p>This process ID can be used to retrieve information on the status of\nthe process and its result.</p>\n<p>Calling the <tt>completed</tt> method of the view with the process ID will\nreturn either a <tt>True</tt> or <tt>False</tt> completion state, or a number\nrepresenting a percentage completion out of 100 (more on recording\nprogress later). If the optional argument, <tt>output_json</tt> is set to\nsome value which evaluates to <tt>True</tt>, the method returns a JSON\nobject with the single key, <tt>completed</tt> containing the same <tt>True</tt>,\n<tt>False</tt> or numeric value.</p>\n<p>If your process died before it completed, it will raise an error, or if\nJSON output is chosen, it will return a <tt>completed</tt> value of the\nstring, \u2018ERROR\u2019.</p>\n<p>To retrieve the result of the <tt>__run__</tt> method once it has completed,\ncall the <tt>result</tt> method of the view with the process ID.</p>\n<p>If your process died before it completed, this too will raise an error,\nor if JSON output is chosen, it will return a <tt>completed</tt> value of\nthe string, \u2018ERROR\u2019.</p>\n<p>If the process has not yet completed when <tt>result</tt> is called,\n<tt>None</tt> will be returned.</p>\n</div>\n<div id=\"setting-process-progress-from-your-task\">\n<h3>Setting process progress from your task</h3>\n<p>If you want your task to return some measure of completion you can call\nthe <tt>set_progress</tt> method with the process ID and some numeric value.</p>\n<pre>&gt;&gt;&gt; class MyView(BaseAsyncView):\n...\n...    def __run__(self, process_id=None, *args, **kwargs):\n...         time.sleep(15)\n...         self.set_progress(process_id, 50)\n...         time.sleep(15)\n...         return \"Hello world!\"\n...\n&gt;&gt;&gt;\n</pre>\n<p>When your task completes without raising an exception, the progress is\nautomatically set to 100 so there is no need to set this before the\nmethod returns.</p>\n</div>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Simply add <tt>netsight.async</tt> to the <tt>eggs</tt> section of your buildout\nconfiguration. If you also plan on using the stock \u2018processing\u2019 page,\nyou may also need to add it to the <tt>zcml</tt> section.</p>\n<pre>[buildout]\neggs = ...\n       netsight.async\nzcml = ...\n       netsight.async\n</pre>\n</div>\n<div id=\"limitations\">\n<h2>Limitations</h2>\n<p>Because running the new process cannot be done using existing threads\nfrom the Zope pool, for the duration of the asynchronous process, an\nextra thread is created by the Zope process, beyond the normal thread\nlimit. This also means an extra connection is opened to the ZODB beyond\nthe normal connection limit which may cause a warning to be shown in\neither the console or log files.</p>\n<p>Once the <tt>__run__</tt> method has started, it cannot be stopped by the\nuser in any way. This a feature that subclasses may implement if\nthey choose, but would be dangerous to implement in this package\nwithout knowledge of what the background task was doing &amp; what cleanup\nmay be required.</p>\n</div>\n<div id=\"to-be-improved\">\n<h2>To be improved</h2>\n<p>Currently processes are stored in memory of a particular Python\ninstance. This introduces the following issues:</p>\n<blockquote>\n<ul>\n<li>If the user never retrieves the results from the <tt>__run__</tt>\nmethod, they are stored in the ZODB permanently.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"dependencies\">\n<h2>Dependencies</h2>\n<blockquote>\n<ul>\n<li>Python&gt;=2.4.0</li>\n<li>zope.component&gt;=3.4.0</li>\n<li>zope.i18n&gt;=3.4.0</li>\n<li>zope.i18nmessageid&gt;=3.4.0</li>\n<li>zope.publisher</li>\n<li>Zope&gt;=2.8.0</li>\n</ul>\n</blockquote>\n<p>The default processing page template depends on a main template being,\nprovided, much like the one provided by Products.CMFPlone, however\nthis may be overridden by your own view, as discussed above.</p>\n</div>\n<div id=\"contributions\">\n<h2>Contributions</h2>\n<p>You can find the source code for this project at:</p>\n<blockquote>\n<a href=\"http://github.com/netsight/netsight.async\" rel=\"nofollow\">http://github.com/netsight/netsight.async</a></blockquote>\n<p>This product needs translations! There are only 2 strings to do, so\nthis is a really quick and easy way to contribute to an open-source\nproject.</p>\n<p>Any bug fixes, new features &amp; documentation improvements are welcome,\njust submit a pull request on github.</p>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<div id=\"id1\">\n<h3>1.1.1 - (2011-10-27)</h3>\n<blockquote>\n<ul>\n<li>Fix process completion detection when progress is set to 100.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id2\">\n<h3>1.1.0 - (2011-10-27)</h3>\n<blockquote>\n<ul>\n<li>Made Python 2.4 compatible.</li>\n<li>Process progress/result storage is now held in the ZODB, rather than\nin a Python instance\u2019s memory.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id3\">\n<h3>1.0.1 - (2011-10-19)</h3>\n<blockquote>\n<ul>\n<li>Fixed package manifest.</li>\n<li>Fixed markup on processing page.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id4\">\n<h3>1.0.0 - (2011-10-19)</h3>\n<p>Initial release.</p>\n</div>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>Copyright 2011 Netsight Internet Solutions Limited</p>\n<p>Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at</p>\n<blockquote>\n<a href=\"http://www.apache.org/licenses/LICENSE-2.0\" rel=\"nofollow\">http://www.apache.org/licenses/LICENSE-2.0</a></blockquote>\n<p>Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.</p>\n</div>\n\n          </div>"}, "last_serial": 1153332, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "7168e4942cef81f370730fdbf0c5de8a", "sha256": "b79fd5dc954509f574bdc4eab74e2d2aa68c223ece1c2c3511eabe589b14b9aa"}, "downloads": -1, "filename": "netsight.async-1.0.1.zip", "has_sig": false, "md5_digest": "7168e4942cef81f370730fdbf0c5de8a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26006, "upload_time": "2011-10-19T18:02:20", "upload_time_iso_8601": "2011-10-19T18:02:20.377155Z", "url": "https://files.pythonhosted.org/packages/e6/90/f0303c5dd0e60ec0d2db99a00f86020ebf7376af82782743b22b68f85b5d/netsight.async-1.0.1.zip", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "9c197674e6924502c22b47fdca79e2af", "sha256": "514be75d804adf1dbf3e3063a433bfebb36597a3f4e495b77adf8a2ceddaae25"}, "downloads": -1, "filename": "netsight.async-1.1.0.tar.gz", "has_sig": false, "md5_digest": "9c197674e6924502c22b47fdca79e2af", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15353, "upload_time": "2011-10-27T16:18:07", "upload_time_iso_8601": "2011-10-27T16:18:07.476447Z", "url": "https://files.pythonhosted.org/packages/3c/1e/b6c3049681e9242bc788e9105a6ec4be6fbeed02d70c557e728e3f982c6e/netsight.async-1.1.0.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "2c07b0abaa1a8a31fea4657d6718c695", "sha256": "ba1b4830283bdea901fe406db440fa8943754d2a84c5442704fd6a9941022ea5"}, "downloads": -1, "filename": "netsight.async-1.1.0.zip", "has_sig": false, "md5_digest": "2c07b0abaa1a8a31fea4657d6718c695", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27974, "upload_time": "2011-10-27T16:13:37", "upload_time_iso_8601": "2011-10-27T16:13:37.796149Z", "url": "https://files.pythonhosted.org/packages/b2/19/f4f1b795fc7883a01ee0b5a111b2afcb9567630b4455e2b097798dd61874/netsight.async-1.1.0.zip", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "90c583d4cd56eb4a5ca6f0c88dec10db", "sha256": "24e42c9e71e3cb90f0dbb7c2bce090a5f017b970edef51623f2242c77f053c46"}, "downloads": -1, "filename": "netsight.async-1.1.1.zip", "has_sig": false, "md5_digest": "90c583d4cd56eb4a5ca6f0c88dec10db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28098, "upload_time": "2011-10-27T18:53:51", "upload_time_iso_8601": "2011-10-27T18:53:51.959114Z", "url": "https://files.pythonhosted.org/packages/e2/76/0264c01369b708d28692d91de5f65caf3aad66d7465e78fb30ed67858710/netsight.async-1.1.1.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "90c583d4cd56eb4a5ca6f0c88dec10db", "sha256": "24e42c9e71e3cb90f0dbb7c2bce090a5f017b970edef51623f2242c77f053c46"}, "downloads": -1, "filename": "netsight.async-1.1.1.zip", "has_sig": false, "md5_digest": "90c583d4cd56eb4a5ca6f0c88dec10db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28098, "upload_time": "2011-10-27T18:53:51", "upload_time_iso_8601": "2011-10-27T18:53:51.959114Z", "url": "https://files.pythonhosted.org/packages/e2/76/0264c01369b708d28692d91de5f65caf3aad66d7465e78fb30ed67858710/netsight.async-1.1.1.zip", "yanked": false}], "timestamp": "Fri May  8 00:45:55 2020"}