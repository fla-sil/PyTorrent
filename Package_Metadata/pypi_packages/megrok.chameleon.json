{"info": {"author": "Uli Fouquet", "author_email": "grok-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.5", "Topic :: Internet :: WWW/HTTP"], "description": "megrok.chameleon\n****************\n\n`megrok.chameleon` makes it possible to use chameleon templates in Grok. \n\nCurrently support for chameleon genshi templates and chameleon zope\npage templates is provided.\n\nFor more information on Grok and Chameleon templates see:\n\n- http://grok.zope.org/\n- http://chameleon.repoze.org/\n- http://pypi.python.org/pypi/Chameleon\n- http://pypi.python.org/pypi/chameleon.genshi\n\n.. contents::\n\nRequirements\n============\n\n- Chameleon templates (`Chameleon`).\n- Chameleon genshi templates (`chameleon.genshi`).\n- Grok v1.0a1 or later, or five.grok 1.0 or later.\n\nInstallation\n============\n\nTo use Chameleon page templates with Grok all you need is to install\nmegrok.chameleon as an egg and include its ZCML. The best place to do\nthis is to make `megrok.chameleon` a dependency of your application by\nadding it to your ``install_requires`` list in ``setup.cfg``. If you\nused grokproject to create your application ``setup.py`` is located in the\nproject root. It should look something like this::\n\n   install_requires=['setuptools',\n                     'megrok.chameleon',\n                     # Add extra requirements here\n                     ],\n\nThen include ``megrok.chameleon`` in your ``configure.zcml``. If you\nused grokproject to create your application it's at\n``src/<projectname>/configure.zcml``. Add the include line after the\ninclude line for grok, but before the grokking of the current\npackage. It should look something like this::\n\n      <include package=\"grok\" />\n      <include package=\"megrok.chameleon\" />  \n      <grok:grok package=\".\" />\n\nIf you use ``autoInclude`` in your ``configure.zcml``, you should not\nhave to do this latter step.\n\nThen run ``bin/buildout`` again. You should now see buildout saying\nsomething like::\n\n   Getting distribution for 'megrok.chameleon'.\n   Got megrok.chameleon 0.5.\n\nThat's all. You can now start using Chameleon page templates in your\nGrok application.\n\n\nUsage\n=====\n\n``megrok.chameleon`` supports the Grok standard of placing templates\nin a templates directory, for example ``app_templates``, so you can\nuse Chameleon page templates by simply placing the Chameleon genshi\ntemplates or Chameleon Zope page templates in the templates directory,\njust as you would with regular ZPT templates.  Although chameleon\ntemplates themselves do not have a standard for the file extensions\nfor templates, Grok needs to have an association between an\nextension and a type so it knows which type of template each template\nis.  `megrok.chameleon` defines the following extensions:\n\n* ``.cpt`` (``Chameleon page template``) for Chameleon page templates\n\n* ``.cg`` (``Chameleon genshi template``) for chameleon driven genshi\n  templates\n\n* ``.cgt`` (``Chameleon genshi text template``) for chameleon driven\n  genshi text templates\n\nYou can also use Chameleon page templates inline.  The syntax for this\nis::\n\n   from megrok.chameleon.components import ChameleonPageTemplate\n   index = ChameleonPageTemplate('<html>the html code</html>') \n\nOr if you use files::\n\n   from megrok.genshi.components import ChameleonPageTemplateFile\n   index = ChameleonPageTemplateFile(filename='thefilename.html')\n\n\n\nDetailed Description\n********************\n\nGrok-support for using chameleon driven templates.\n\nWith `megrok.chameleon` you can use templates parsed and rendered by\n`Chameleon`_. Currently Zope page templates and Genshi templates are\nsupported.\n\nChameleon Zope page templates\n=============================\n\nChameleon provides support for Zope page templates which can be used\nfrom grok writing templates with the ``.cpt`` (=Chameleon Page\nTemplate) filename extension.\n\nChameleon page templates differ from standard Zope page templates in a\nfew aspects, most notably:\n\n* Expressions are parsed in ``Python-mode`` by default. This means,\n  instead of ``tal:content=\"view/value\"`` you must use\n  ``tal:content=\"view.value\"``. Every occurence of TAL-expressions\n  starting with ``python:`` now can be shortened by skipping this\n  marker.\n\n* Also genshi-like variable substitutions are supported. For example\n  you can write ``${myvar}`` instead of ``tal:content=\"myvar\"``.\n\nBeside this, most rules for regular Zope page templates apply also to\nchameleon page templates.\n\nSee the `Chameleon`_ page for more information.\n\n.. _Chameleon: http://chameleon.repoze.org/docs/latest/zpt.html\n\nPrerequisites\n-------------\n\nBefore we can see the templates in action, we care for correct\nregistration and set some used variables:\n\n    >>> import os\n    >>> testdir = os.path.join(os.path.dirname(__file__), 'tests')\n    >>> cpt_fixture = os.path.join(testdir, 'cpt_fixture')\n    >>> template_dir = os.path.join(cpt_fixture, 'app_templates')\n\nWe register everything. Before we can grok our fixture, we have to\ngrok the `megrok.chameleon` package. This way the new template types\nare registered with the framework:\n\n    >>> import grokcore.view\n    >>> grokcore.view.testing.grok('megrok.chameleon')\n    >>> grokcore.view.testing.grok('megrok.chameleon.tests.cpt_fixture')\n\nWe create a mammoth, which should provide us a bunch of chameleon page\ntemplate driven views and put it in the database to setup location\ninfo::\n\n    >>> from megrok.chameleon.tests.cpt_fixture.app import Mammoth\n    >>> manfred = Mammoth()\n    >>> getRootFolder()['manfred'] = manfred\n\nFurthermore we prepare for getting the different views on manfred:\n\n    >>> from zope.publisher.browser import TestRequest\n    >>> from zope.component import getMultiAdapter\n    >>> request = TestRequest()\n\nSimple templates\n----------------\n\nWe prepared a plain cavepainting view. The template looks like this:\n\n    >>> cavepainting_cpt = os.path.join(template_dir, 'cavepainting.cpt')\n    >>> print open(cavepainting_cpt, 'rb').read()\n    <html>\n      <body>\n        A cave painting.\n      </body>\n    </html>\n\nThe rendered view looks like this:\n\n    >>> view = getMultiAdapter((manfred, request),\n    ...                         name='cavepainting')\n    >>> print view()\n    <html>\n      <body>\n        A cave painting.\n      </body>\n    </html>\n\nSubstituting variables\n----------------------\n\nA template can access variables like ``view``, ``context`` and its\nmethods and attributes. The ``food`` view does exactly this. The\ntemplate looks like this:\n\n    >>> food_cpt = os.path.join(template_dir, 'food.cpt')\n    >>> print open(food_cpt, 'rb').read()\n    <html>\n    <body>\n    <span tal:define=\"foo 'a FOO'\">\n    ${view.me_do()}\n    <span tal:replace=\"structure view.me_do()\" />\n    CSS-URL: ${static['test.css']()}\n    My context is: ${view.url(context)}\n    ${foo}\n    <span tal:replace=\"foo\" />\n    </span>\n    </body>\n    </html>\n\nThe rendered view looks like this:\n\n    >>> view = getMultiAdapter((manfred, request), name='food')\n    >>> print view()\n    <html>\n    <body>\n    <span>\n    &lt;ME GROK EAT MAMMOTH!&gt;\n    <ME GROK EAT MAMMOTH!>\n    CSS-URL: http://127.0.0.1/@@/megrok.chameleon.tests.cpt_fixture/test.css\n    My context is: http://127.0.0.1/manfred\n    a FOO\n    a FOO\n    </span>\n    </body>\n    </html>\n\nAs we can see, there is a difference between Genshi-like substitution\nand TAL-like substitution: while both expressions::\n\n  ${view.me_do()}\n\nand::\n\n  <span tal:replace=\"view.me_do()\" />\n\nactually render the same string ``<ME GROK EAT MAMMOTH!>``, the former\ndoes this straight and plain, while the latter performs additionally\nHTML-encoding of the string. Therefore the output of both expressions\ndiffer. It's::\n\n  <ME GROK EAT MAMMOTH!>\n\nfor the former expression and::\n\n  &lt;ME GROK EAT MAMMOTH!&gt;\n\nfor the latter.\n\n\nSupported variables\n-------------------\n\nEach template provides at least the following vars:\n\n* ``template``\n    the template instance\n\n* ``view``\n    the associated view\n\n* ``context``\n    the context of the view\n\n* ``request``\n    the current request\n\n* ``static`` \n    the static dir of the application\n\nas we can see, when we look at the ``vars.cpt`` from our fixture:\n\n    >>> cpt_file = os.path.join(template_dir, 'vars.cpt')\n    >>> print open(cpt_file, 'rb').read()\n    <html>\n    <body>\n    This template knows about the following vars:\n    <BLANKLINE>\n      template (the template instance):\n       ${template}\n    <BLANKLINE>\n      view (the associated view):\n       ${view}\n    <BLANKLINE>\n      context (the context of the view):\n       ${context}\n    <BLANKLINE>\n      request (the current request):\n       ${request}\n    <BLANKLINE>\n      static (the static dir of the application):\n       ${static}\n    </body>\n    </html>\n\nand render it:\n\n    >>> view = getMultiAdapter((manfred, request), name='vars')\n    >>> print view()\n    <html>\n    <body>\n    This template knows about the following vars:\n    <BLANKLINE>\n      template (the template instance):\n       &lt;vars template in ...vars.cpt&gt;\n    <BLANKLINE>\n      view (the associated view):\n       &lt;megrok.chameleon.tests.cpt_fixture.app.Vars object at 0x...&gt;\n    <BLANKLINE>\n      context (the context of the view):\n       &lt;megrok.chameleon.tests.cpt_fixture.app.Mammoth object at 0x...&gt;\n    <BLANKLINE>\n      request (the current request):\n       CONTENT_LENGTH:\t0\n    GATEWAY_INTERFACE:\tTestFooInterface/1.0\n    HTTP_HOST:\t127.0.0.1\n    SERVER_URL:\thttp://127.0.0.1\n    <BLANKLINE>\n      static (the static dir of the application):\n       &lt;grokcore.view.components.DirectoryResource object at 0x...&gt;\n    </body>\n    </html>\n\n\nInline Templates\n----------------\n\nWe can also define inline templates. In our ``app.py`` we defined an\ninline template like this::\n\n  from megrok.chameleon import components\n\n  ...\n\n  class Inline(grokcore.view.View):\n    sometext = 'Some Text'\n\n  inline = components.ChameleonPageTemplate(\n      \"<html><body>ME GROK HAS INLINES! ${view.sometext}</body></html>\")\n\nIf we render this view we get:\n\n    >>> view = getMultiAdapter((manfred, request), name='inline')\n    >>> print view()\n    <html><body>ME GROK HAS INLINES! Some Text</body></html>\n\nTAL expressions\n---------------\n\nStarting with ``megrok.chameleon`` 0.5 we deploy the all-in-one\n`Chameleon`_ package.\n\nWhat TAL/TALES expressions in templates are supported depends mainly\nfrom the installed version of `Chameleon`, while we support some\nadditional, Zope-related TALES expressions.\n\nA list of all supported expressions and statements can be found at the\n`chameleon.zpt documentation\n<http://chameleon.repoze.org/docs/latest/zpt.html>`_. The additional\nTALES expressions provided by ``megrok.chameleon`` are:\n\n* ``exists``\n     Tell whether a name exists in the templates' namespace.\n\n* ``not``\n     Evaluate the trailing expression to a boolean value and invert it.\n\n* ``path`` \n     Handle the trailing expression as a path and not as a\n     Python expression.\n\n* ``provider``\n     Support for viewlet providers.\n\n.. warning:: `z3c.pt` support has been dropped with\n             ``megrok.chameleon`` 0.5.\n\n.. note:: Starting with ``megrok.chameleon`` 0.5 support for the\n          Python expression ``exists()`` has been dropped. The TALES\n          expression ``exists: path/to/something`` is still available.\n\nIn our ``app.py`` we defined a special view for showing some special\nexpressions. This also includes a viewlet::\n\n   import grok\n   from megrok.chameleon import components\n\n   class Mammoth(grok.Application, grok.Container):\n       pass\n\n   ...\n\n   class Expressions(grok.View):\n       pass\n\n   class MainArea(grok.ViewletManager):\n       grok.name('main')\n\n   class MainContent(grok.Viewlet):\n       grok.view(Expressions)\n       grok.viewletmanager(MainArea)\n       def render(self):\n           return 'Hello from viewlet'\n\nNow we can make use of the TALES expressions ``not:``, ``path:``,\n``exists:`` and ``provider:`` in the ``expressions.cpt`` template of\nour fixture:\n\n    >>> cpt_file = os.path.join(template_dir, 'expressions.cpt')\n    >>> print open(cpt_file, 'rb').read()\n    <html>\n    <body>\n      <div tal:define=\"food 'Yummy Dinoburger'\"\n           tal:omit-tag=\"\">\n        <!-- We support `exists` -->\n        <div tal:condition=\"exists: food\">\n          ${food}\n        </div>\n    <BLANKLINE>\n        <!-- We support `not` -->\n        <div tal:content=\"not: food\" />\n        <div tal:content=\"not('food')\" />\n        <div tal:content=\"not: 1 in [2,3]\" />\n        <div tal:content=\"not: not: food\" />\n    <BLANKLINE>\n        <!-- We support `path` -->\n        <div tal:content=\"path: food/upper\" />\n    <BLANKLINE>\n        <!-- We support `provider` -->\n        <tal:main content=\"structure provider:main\" />\n    <BLANKLINE>\n      </div>\n    </body>\n    </html>\n\nand render it:\n\n    >>> view = getMultiAdapter((manfred, request), name='expressions')\n    >>> print view()\n    <html>\n    <body>\n    <BLANKLINE>\n        <!-- We support `exists` -->\n        <div>\n          Yummy Dinoburger\n        </div>\n    <BLANKLINE>\n        <!-- We support `not` -->\n        <div>False</div>\n        <div>False</div>\n        <div>True</div>\n        <div>True</div>\n    <BLANKLINE>\n        <!-- We support `path` -->\n        <div>YUMMY DINOBURGER</div>\n    <BLANKLINE>\n        <!-- We support `provider` -->\n        Hello from viewlet\n    <BLANKLINE>\n    <BLANKLINE>\n    </body>\n    </html>\n\nMacros\n------\n\nWith ``megrok.chameleon`` we can also use macros, although it is a bit\ndifferent from regular Zope page templates.\n\nWe can define macros like this:\n\n    >>> cpt_file = os.path.join(template_dir, 'macromaster.cpt')\n    >>> print open(cpt_file, 'rb').read()\n    <p xmlns:metal=\"http://xml.zope.org/namespaces/metal\"\n       metal:define-macro=\"hello\">\n      Hello from <b metal:define-slot=\"name\">macro master</b>\n    </p>\n\nThe defined macro ``hello`` can be rendered in another Chameleon\ntemplate with the METAL attribute ``use-macro``.\n\nTo refer to a local macro, i.e. a macros defined in the same template,\nyou can use something like::\n\n  <div metal:use-macro=\"template.macros['<macro-name>']\">\n    Replaced by macro\n  </div>\n\nwhere ``<macro-name>`` must be an existing macro name.\n\nTo refer to macros in external templates, you must use the ``path:``\nexpression like this::\n\n  <div metal:use-macro=\"path:\n    context/@@<viewname>/template/macros/<macro-name>\">\n     Replaced by external macro\n  </div>\n\nwhere ``<viewname>`` refers to an existing view on ``context`` and\n``macro-name`` again refers to an existing macro in the specified template.\n\nNote, that this is different from how you refer to macros in standard\nZope page templates. The short notation ``view/macros/<macro-name>``\nworks only with regular Zope page templates.\n\nThe following template makes use of both methods:\n\n    >>> cpt_file = os.path.join(template_dir, 'macrouser.cpt')\n    >>> print open(cpt_file, 'rb').read()\n    <html xmlns:metal=\"http://xml.zope.org/namespaces/metal\">\n    <body>\n      <p metal:define-macro=\"hello\">\n        Hi there from macro user!\n      </p>\n      <div metal:use-macro=\"template.macros['hello']\">\n        Fill this\n      </div>\n    <BLANKLINE>\n      <div metal:use-macro=\"path: context/@@macromaster/template/macros/hello\">\n        <b metal:fill-slot=\"name\">user slot</b>\n        Fill this too\n      </div>\n    </body>\n    </html>\n\nWhen rendered also the slot defined in the master template is filled\nby macro user content:\n\n    >>> cpt_file = os.path.join(template_dir, 'macrouser.cpt')\n    >>> view = getMultiAdapter((manfred, request), name='macrouser')\n    >>> print view()\n    <html>\n    <body>\n      <p>\n        Hi there from macro user!\n      </p>\n      <p>\n        Hi there from macro user!\n      </p>\n    <BLANKLINE>\n    <BLANKLINE>\n      <p>\n      Hello from <b>user slot</b>\n    <BLANKLINE>\n    </p>\n    </body>\n    </html>\n\n\nClean up:\n\n    >>> del getRootFolder()['manfred']\n\n\nDifferences from regular Zope page templates\n--------------------------------------------\n\n* Macros are referenced differently. See appropriate section above.\n\n* Expressions are parsed in ``Python-mode`` by default. This means,\n  instead of ``tal:content=\"view/value\"`` you must use\n  ``tal:content=\"view.value\"``. Every occurence of TAL-expressions\n  starting with ``python:`` now can be shortened by skipping this\n  marker.\n\nChameleon Genshi templates\n==========================\n\nChameleon provides support for Genshi templates which can be used from\ngrok writing templates with the ``.cg`` filename extension.\n\nGenshi text templates can be used with the ``.cgt`` filename\nextension.\n\nNote, that chameleon genshi templates might not cover the full range\nof functionality offered by native genshi parsers. Use `megrok.genshi`\nif you want native genshi support.\n\nSee the `chameleon.genshi`_ page for more information.\n\n.. _chameleon.genshi: http://pypi.python.org/pypi/chameleon.genshi\n\n\nPrerequisites\n-------------\n\nBefore we can see the templates in action, we care for correct\nregistration and set some used variables:\n\n    >>> import os\n    >>> testdir = os.path.join(os.path.dirname(__file__), 'tests')\n    >>> genshi_fixture = os.path.join(testdir, 'genshi_fixture')\n    >>> template_dir = os.path.join(genshi_fixture, 'app_templates')\n\nWe register everything. Before we can grok our fixture, we have to\ngrok the `megrok.chameleon` package. This way the new template types\nare registered with the framework:\n\n    >>> grokcore.view.testing.grok('megrok.chameleon')\n    >>> grokcore.view.testing.grok('megrok.chameleon.tests.genshi_fixture')\n\nWe create a mammoth, which should provide us a bunch of Genshi driven\nviews and put it in the database to setup location info:\n\n    >>> from megrok.chameleon.tests.genshi_fixture.app import Mammoth\n    >>> manfred = Mammoth()\n    >>> getRootFolder()['manfred'] = manfred\n\nFurthermore we prepare for getting the different views on manfred:\n\n    >>> from zope.publisher.browser import TestRequest\n    >>> from zope.component import getMultiAdapter\n    >>> request = TestRequest()\n\n\nSimple templates\n----------------\n\nWe prepared a plain cavepainting view. The template looks like this:\n\n    >>> cavepainting_cg = os.path.join(template_dir, 'cavepainting.cg')\n    >>> print open(cavepainting_cg, 'rb').read()\n    <html>\n      <body>\n        A cave painting.\n      </body>\n    </html>\n\nThe rendered view looks like this:\n\n    >>> view = getMultiAdapter((manfred, request),\n    ...                         name='cavepainting')\n    >>> print view()\n    <html>\n      <body>\n        A cave painting.\n      </body>\n    </html>\n\n\nSubstituting variables\n----------------------\n\nA template can access variables like ``view``, ``context`` and its\nmethods and attributes. The ``food`` view does exactly this. The\ntemplate looks like this:\n\n    >>> food_cg = os.path.join(template_dir, 'food.cg')\n    >>> print open(food_cg, 'rb').read()\n    <html>\n    <body>\n    ${view.me_do()}\n    CSS-URL: ${static['test.css']()}\n    My context is: ${view.url(context)}\n    </body>\n    </html>\n\nThe rendered view looks like this:\n\n    >>> view = getMultiAdapter((manfred, request), name='food')\n    >>> print view()\n    <html>\n    <body>\n    ME GROK EAT MAMMOTH!\n    CSS-URL: http://127.0.0.1/@@/megrok.chameleon.tests.genshi_fixture/test.css\n    My context is: http://127.0.0.1/manfred\n    </body>\n    </html>\n\n\nIncluding other templates\n-------------------------\n\nWith genshi support we can also include other templates. The\n``gatherer`` view looks like this:\n\n    >>> gatherer_cg = os.path.join(template_dir, 'gatherer.cg')\n    >>> print open(gatherer_cg, 'rb').read()\n    <html xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n    <body>\n    ME GROK GATHER BERRIES!\n    <xi:include href=\"berries.cg\"/>\n    </body>\n    </html>\n\nApparently here we include a template called ``berries.cg``. It looks\nlike this:\n\n    >>> berries_cg = os.path.join(template_dir, 'berries.cg')\n    >>> print open(berries_cg, 'rb').read()\n    <strong>Lovely blueberries!</strong>\n\n\nWhen we render the former template, we get:\n\n    >>> view = getMultiAdapter((manfred, request), name='gatherer')\n    >>> print view()\n    <html>\n    <body>\n    ME GROK GATHER BERRIES!\n    <strong>Lovely blueberries!</strong>\n    </body>\n    </html>\n\nText templates\n--------------\n\nAlso genshi text templates are supported. We have a template that\nlooks like so:\n\n    >>> hunter_cgt = os.path.join(template_dir, 'hunter.cgt')\n    >>> print open(hunter_cgt, 'rb').read()\n    ME GROK HUNT ${view.game}!\n\nNote, that this template has the ``.cgt`` (= **c**\\ ameleon **g**\\ enshi\n**t**\\ ext template) file extension.\n\nIf we render it, all expressions are substituted:\n\n    >>> view = getMultiAdapter((manfred, request), name='hunter')\n    >>> print view()\n    ME GROK HUNT MAMMOTH!!\n\n\nCHANGES\n*******\n\n0.5.2 (2010-07-19)\n==================\n\n* Remove dependency on chameleon.genshi as this is now included \n  into Chameleon itself.\n\n0.5.1 (2010-05-20)\n==================\n\n* Made registering of ITranslatorExpressions conditional: if\n  ``z3c.pt`` is installed as well, we don't register our own\n  ones. Should fix DuplicationError when using megrok.chameleon\n  together with other packages that require z3c.pt like ``z3c.form``\n  and dependent packages from grok-ecosphere.\n\n* Get rid of zope.testing, zope.app.testing and z3c.testsetup for\n  tests.\n\n0.5 (2010-03-03)\n================\n\n* Added tests to show usage of macros with ``megrok.chameleon``.\n\n* Removed dependency from ``z3c.pt`` by copying the relevant bits over\n  and registering them locally.\n\n  Drop support for ``exists('varname')`` expressions. The regular\n  TALES expression ``exists: varname/path`` can still be used.\n\n* Switch to use ``Chameleon`` instead of ``chameleon.*`` packages.\n\n0.4 (2010-02-23)\n================\n\n* Declared ``megrok`` as namespace package.\n\n* Fixed order of includes in ftesting.zcml.\n\n* Moved pure test-requirements into own setup-section in order to reduce\n  dependencies in regular (non-testing) mode.\n\n0.3 (2010-02-14)\n================\n\n* Added license file.\n\n0.2 (2009-09-18)\n================\n\n* Provide macro access from templates.\n\n* Don't depend anymore on grok, but only grokcore.view.\n\n* Added support for `path()` and `exists()` in page templates. This\n  was introduced from `z3c.pt`.\n\n* Fix ZCML includes.\n\n0.1 (2009-02-22)\n================\n\n* Initial release", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/megrok.chameleon", "keywords": "grok chameleon template", "license": "ZPL", "maintainer": null, "maintainer_email": null, "name": "megrok.chameleon", "package_url": "https://pypi.org/project/megrok.chameleon/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/megrok.chameleon/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/megrok.chameleon"}, "release_url": "https://pypi.org/project/megrok.chameleon/0.5.2/", "requires_dist": null, "requires_python": null, "summary": "Chameleon page template support for Grok", "version": "0.5.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"megrok-chameleon\">\n<h2><a href=\"#id11\" rel=\"nofollow\">megrok.chameleon</a></h2>\n<p><cite>megrok.chameleon</cite> makes it possible to use chameleon templates in Grok.</p>\n<p>Currently support for chameleon genshi templates and chameleon zope\npage templates is provided.</p>\n<p>For more information on Grok and Chameleon templates see:</p>\n<ul>\n<li><a href=\"http://grok.zope.org/\" rel=\"nofollow\">http://grok.zope.org/</a></li>\n<li><a href=\"http://chameleon.repoze.org/\" rel=\"nofollow\">http://chameleon.repoze.org/</a></li>\n<li><a href=\"http://pypi.python.org/pypi/Chameleon\" rel=\"nofollow\">http://pypi.python.org/pypi/Chameleon</a></li>\n<li><a href=\"http://pypi.python.org/pypi/chameleon.genshi\" rel=\"nofollow\">http://pypi.python.org/pypi/chameleon.genshi</a></li>\n</ul>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#megrok-chameleon\" id=\"id11\" rel=\"nofollow\">megrok.chameleon</a><ul>\n<li><a href=\"#requirements\" id=\"id12\" rel=\"nofollow\">Requirements</a></li>\n<li><a href=\"#installation\" id=\"id13\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#usage\" id=\"id14\" rel=\"nofollow\">Usage</a></li>\n</ul>\n</li>\n<li><a href=\"#detailed-description\" id=\"id15\" rel=\"nofollow\">Detailed Description</a><ul>\n<li><a href=\"#chameleon-zope-page-templates\" id=\"id16\" rel=\"nofollow\">Chameleon Zope page templates</a><ul>\n<li><a href=\"#prerequisites\" id=\"id17\" rel=\"nofollow\">Prerequisites</a></li>\n<li><a href=\"#simple-templates\" id=\"id18\" rel=\"nofollow\">Simple templates</a></li>\n<li><a href=\"#substituting-variables\" id=\"id19\" rel=\"nofollow\">Substituting variables</a></li>\n<li><a href=\"#supported-variables\" id=\"id20\" rel=\"nofollow\">Supported variables</a></li>\n<li><a href=\"#inline-templates\" id=\"id21\" rel=\"nofollow\">Inline Templates</a></li>\n<li><a href=\"#tal-expressions\" id=\"id22\" rel=\"nofollow\">TAL expressions</a></li>\n<li><a href=\"#macros\" id=\"id23\" rel=\"nofollow\">Macros</a></li>\n<li><a href=\"#differences-from-regular-zope-page-templates\" id=\"id24\" rel=\"nofollow\">Differences from regular Zope page templates</a></li>\n</ul>\n</li>\n<li><a href=\"#chameleon-genshi-templates\" id=\"id25\" rel=\"nofollow\">Chameleon Genshi templates</a><ul>\n<li><a href=\"#id1\" id=\"id26\" rel=\"nofollow\">Prerequisites</a></li>\n<li><a href=\"#id2\" id=\"id27\" rel=\"nofollow\">Simple templates</a></li>\n<li><a href=\"#id3\" id=\"id28\" rel=\"nofollow\">Substituting variables</a></li>\n<li><a href=\"#including-other-templates\" id=\"id29\" rel=\"nofollow\">Including other templates</a></li>\n<li><a href=\"#text-templates\" id=\"id30\" rel=\"nofollow\">Text templates</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#changes\" id=\"id31\" rel=\"nofollow\">CHANGES</a><ul>\n<li><a href=\"#id4\" id=\"id32\" rel=\"nofollow\">0.5.2 (2010-07-19)</a></li>\n<li><a href=\"#id5\" id=\"id33\" rel=\"nofollow\">0.5.1 (2010-05-20)</a></li>\n<li><a href=\"#id6\" id=\"id34\" rel=\"nofollow\">0.5 (2010-03-03)</a></li>\n<li><a href=\"#id7\" id=\"id35\" rel=\"nofollow\">0.4 (2010-02-23)</a></li>\n<li><a href=\"#id8\" id=\"id36\" rel=\"nofollow\">0.3 (2010-02-14)</a></li>\n<li><a href=\"#id9\" id=\"id37\" rel=\"nofollow\">0.2 (2009-09-18)</a></li>\n<li><a href=\"#id10\" id=\"id38\" rel=\"nofollow\">0.1 (2009-02-22)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"requirements\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Requirements</a></h3>\n<ul>\n<li>Chameleon templates (<cite>Chameleon</cite>).</li>\n<li>Chameleon genshi templates (<cite>chameleon.genshi</cite>).</li>\n<li>Grok v1.0a1 or later, or five.grok 1.0 or later.</li>\n</ul>\n</div>\n<div id=\"installation\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Installation</a></h3>\n<p>To use Chameleon page templates with Grok all you need is to install\nmegrok.chameleon as an egg and include its ZCML. The best place to do\nthis is to make <cite>megrok.chameleon</cite> a dependency of your application by\nadding it to your <tt>install_requires</tt> list in <tt>setup.cfg</tt>. If you\nused grokproject to create your application <tt>setup.py</tt> is located in the\nproject root. It should look something like this:</p>\n<pre>install_requires=['setuptools',\n                  'megrok.chameleon',\n                  # Add extra requirements here\n                  ],\n</pre>\n<p>Then include <tt>megrok.chameleon</tt> in your <tt>configure.zcml</tt>. If you\nused grokproject to create your application it\u2019s at\n<tt><span class=\"pre\">src/&lt;projectname&gt;/configure.zcml</span></tt>. Add the include line after the\ninclude line for grok, but before the grokking of the current\npackage. It should look something like this:</p>\n<pre>&lt;include package=\"grok\" /&gt;\n&lt;include package=\"megrok.chameleon\" /&gt;\n&lt;grok:grok package=\".\" /&gt;\n</pre>\n<p>If you use <tt>autoInclude</tt> in your <tt>configure.zcml</tt>, you should not\nhave to do this latter step.</p>\n<p>Then run <tt>bin/buildout</tt> again. You should now see buildout saying\nsomething like:</p>\n<pre>Getting distribution for 'megrok.chameleon'.\nGot megrok.chameleon 0.5.\n</pre>\n<p>That\u2019s all. You can now start using Chameleon page templates in your\nGrok application.</p>\n</div>\n<div id=\"usage\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Usage</a></h3>\n<p><tt>megrok.chameleon</tt> supports the Grok standard of placing templates\nin a templates directory, for example <tt>app_templates</tt>, so you can\nuse Chameleon page templates by simply placing the Chameleon genshi\ntemplates or Chameleon Zope page templates in the templates directory,\njust as you would with regular ZPT templates.  Although chameleon\ntemplates themselves do not have a standard for the file extensions\nfor templates, Grok needs to have an association between an\nextension and a type so it knows which type of template each template\nis.  <cite>megrok.chameleon</cite> defines the following extensions:</p>\n<ul>\n<li><tt>.cpt</tt> (<tt>Chameleon page template</tt>) for Chameleon page templates</li>\n<li><tt>.cg</tt> (<tt>Chameleon genshi template</tt>) for chameleon driven genshi\ntemplates</li>\n<li><tt>.cgt</tt> (<tt>Chameleon genshi text template</tt>) for chameleon driven\ngenshi text templates</li>\n</ul>\n<p>You can also use Chameleon page templates inline.  The syntax for this\nis:</p>\n<pre>from megrok.chameleon.components import ChameleonPageTemplate\nindex = ChameleonPageTemplate('&lt;html&gt;the html code&lt;/html&gt;')\n</pre>\n<p>Or if you use files:</p>\n<pre>from megrok.genshi.components import ChameleonPageTemplateFile\nindex = ChameleonPageTemplateFile(filename='thefilename.html')\n</pre>\n</div>\n</div>\n<div id=\"detailed-description\">\n<h2><a href=\"#id15\" rel=\"nofollow\">Detailed Description</a></h2>\n<p>Grok-support for using chameleon driven templates.</p>\n<p>With <cite>megrok.chameleon</cite> you can use templates parsed and rendered by\n<a href=\"http://chameleon.repoze.org/docs/latest/zpt.html\" rel=\"nofollow\">Chameleon</a>. Currently Zope page templates and Genshi templates are\nsupported.</p>\n<div id=\"chameleon-zope-page-templates\">\n<h3><a href=\"#id16\" rel=\"nofollow\">Chameleon Zope page templates</a></h3>\n<p>Chameleon provides support for Zope page templates which can be used\nfrom grok writing templates with the <tt>.cpt</tt> (=Chameleon Page\nTemplate) filename extension.</p>\n<p>Chameleon page templates differ from standard Zope page templates in a\nfew aspects, most notably:</p>\n<ul>\n<li>Expressions are parsed in <tt><span class=\"pre\">Python-mode</span></tt> by default. This means,\ninstead of <tt><span class=\"pre\">tal:content=\"view/value\"</span></tt> you must use\n<tt><span class=\"pre\">tal:content=\"view.value\"</span></tt>. Every occurence of TAL-expressions\nstarting with <tt>python:</tt> now can be shortened by skipping this\nmarker.</li>\n<li>Also genshi-like variable substitutions are supported. For example\nyou can write <tt>${myvar}</tt> instead of <tt><span class=\"pre\">tal:content=\"myvar\"</span></tt>.</li>\n</ul>\n<p>Beside this, most rules for regular Zope page templates apply also to\nchameleon page templates.</p>\n<p>See the <a href=\"http://chameleon.repoze.org/docs/latest/zpt.html\" rel=\"nofollow\">Chameleon</a> page for more information.</p>\n<div id=\"prerequisites\">\n<h4><a href=\"#id17\" rel=\"nofollow\">Prerequisites</a></h4>\n<p>Before we can see the templates in action, we care for correct\nregistration and set some used variables:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; testdir = os.path.join(os.path.dirname(__file__), 'tests')\n&gt;&gt;&gt; cpt_fixture = os.path.join(testdir, 'cpt_fixture')\n&gt;&gt;&gt; template_dir = os.path.join(cpt_fixture, 'app_templates')\n</pre>\n</blockquote>\n<p>We register everything. Before we can grok our fixture, we have to\ngrok the <cite>megrok.chameleon</cite> package. This way the new template types\nare registered with the framework:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import grokcore.view\n&gt;&gt;&gt; grokcore.view.testing.grok('megrok.chameleon')\n&gt;&gt;&gt; grokcore.view.testing.grok('megrok.chameleon.tests.cpt_fixture')\n</pre>\n</blockquote>\n<p>We create a mammoth, which should provide us a bunch of chameleon page\ntemplate driven views and put it in the database to setup location\ninfo:</p>\n<pre>&gt;&gt;&gt; from megrok.chameleon.tests.cpt_fixture.app import Mammoth\n&gt;&gt;&gt; manfred = Mammoth()\n&gt;&gt;&gt; getRootFolder()['manfred'] = manfred\n</pre>\n<p>Furthermore we prepare for getting the different views on manfred:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; from zope.component import getMultiAdapter\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n</div>\n<div id=\"simple-templates\">\n<h4><a href=\"#id18\" rel=\"nofollow\">Simple templates</a></h4>\n<p>We prepared a plain cavepainting view. The template looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cavepainting_cpt = os.path.join(template_dir, 'cavepainting.cpt')\n&gt;&gt;&gt; print open(cavepainting_cpt, 'rb').read()\n&lt;html&gt;\n  &lt;body&gt;\n    A cave painting.\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>The rendered view looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request),\n...                         name='cavepainting')\n&gt;&gt;&gt; print view()\n&lt;html&gt;\n  &lt;body&gt;\n    A cave painting.\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"substituting-variables\">\n<h4><a href=\"#id19\" rel=\"nofollow\">Substituting variables</a></h4>\n<p>A template can access variables like <tt>view</tt>, <tt>context</tt> and its\nmethods and attributes. The <tt>food</tt> view does exactly this. The\ntemplate looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; food_cpt = os.path.join(template_dir, 'food.cpt')\n&gt;&gt;&gt; print open(food_cpt, 'rb').read()\n&lt;html&gt;\n&lt;body&gt;\n&lt;span tal:define=\"foo 'a FOO'\"&gt;\n${view.me_do()}\n&lt;span tal:replace=\"structure view.me_do()\" /&gt;\nCSS-URL: ${static['test.css']()}\nMy context is: ${view.url(context)}\n${foo}\n&lt;span tal:replace=\"foo\" /&gt;\n&lt;/span&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>The rendered view looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='food')\n&gt;&gt;&gt; print view()\n&lt;html&gt;\n&lt;body&gt;\n&lt;span&gt;\n&amp;lt;ME GROK EAT MAMMOTH!&amp;gt;\n&lt;ME GROK EAT MAMMOTH!&gt;\nCSS-URL: http://127.0.0.1/@@/megrok.chameleon.tests.cpt_fixture/test.css\nMy context is: http://127.0.0.1/manfred\na FOO\na FOO\n&lt;/span&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>As we can see, there is a difference between Genshi-like substitution\nand TAL-like substitution: while both expressions:</p>\n<pre>${view.me_do()}\n</pre>\n<p>and:</p>\n<pre>&lt;span tal:replace=\"view.me_do()\" /&gt;\n</pre>\n<p>actually render the same string <tt>&lt;ME GROK EAT MAMMOTH!&gt;</tt>, the former\ndoes this straight and plain, while the latter performs additionally\nHTML-encoding of the string. Therefore the output of both expressions\ndiffer. It\u2019s:</p>\n<pre>&lt;ME GROK EAT MAMMOTH!&gt;\n</pre>\n<p>for the former expression and:</p>\n<pre>&amp;lt;ME GROK EAT MAMMOTH!&amp;gt;\n</pre>\n<p>for the latter.</p>\n</div>\n<div id=\"supported-variables\">\n<h4><a href=\"#id20\" rel=\"nofollow\">Supported variables</a></h4>\n<p>Each template provides at least the following vars:</p>\n<ul>\n<li><dl>\n<dt><tt>template</tt></dt>\n<dd>the template instance</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>view</tt></dt>\n<dd>the associated view</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>context</tt></dt>\n<dd>the context of the view</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>request</tt></dt>\n<dd>the current request</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>static</tt></dt>\n<dd>the static dir of the application</dd>\n</dl>\n</li>\n</ul>\n<p>as we can see, when we look at the <tt>vars.cpt</tt> from our fixture:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'vars.cpt')\n&gt;&gt;&gt; print open(cpt_file, 'rb').read()\n&lt;html&gt;\n&lt;body&gt;\nThis template knows about the following vars:\n&lt;BLANKLINE&gt;\n  template (the template instance):\n   ${template}\n&lt;BLANKLINE&gt;\n  view (the associated view):\n   ${view}\n&lt;BLANKLINE&gt;\n  context (the context of the view):\n   ${context}\n&lt;BLANKLINE&gt;\n  request (the current request):\n   ${request}\n&lt;BLANKLINE&gt;\n  static (the static dir of the application):\n   ${static}\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>and render it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='vars')\n&gt;&gt;&gt; print view()\n&lt;html&gt;\n&lt;body&gt;\nThis template knows about the following vars:\n&lt;BLANKLINE&gt;\n  template (the template instance):\n   &amp;lt;vars template in ...vars.cpt&amp;gt;\n&lt;BLANKLINE&gt;\n  view (the associated view):\n   &amp;lt;megrok.chameleon.tests.cpt_fixture.app.Vars object at 0x...&amp;gt;\n&lt;BLANKLINE&gt;\n  context (the context of the view):\n   &amp;lt;megrok.chameleon.tests.cpt_fixture.app.Mammoth object at 0x...&amp;gt;\n&lt;BLANKLINE&gt;\n  request (the current request):\n   CONTENT_LENGTH:  0\nGATEWAY_INTERFACE:  TestFooInterface/1.0\nHTTP_HOST:  127.0.0.1\nSERVER_URL: http://127.0.0.1\n&lt;BLANKLINE&gt;\n  static (the static dir of the application):\n   &amp;lt;grokcore.view.components.DirectoryResource object at 0x...&amp;gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"inline-templates\">\n<h4><a href=\"#id21\" rel=\"nofollow\">Inline Templates</a></h4>\n<p>We can also define inline templates. In our <tt>app.py</tt> we defined an\ninline template like this:</p>\n<pre>from megrok.chameleon import components\n\n...\n\nclass Inline(grokcore.view.View):\n  sometext = 'Some Text'\n\ninline = components.ChameleonPageTemplate(\n    \"&lt;html&gt;&lt;body&gt;ME GROK HAS INLINES! ${view.sometext}&lt;/body&gt;&lt;/html&gt;\")\n</pre>\n<p>If we render this view we get:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='inline')\n&gt;&gt;&gt; print view()\n&lt;html&gt;&lt;body&gt;ME GROK HAS INLINES! Some Text&lt;/body&gt;&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"tal-expressions\">\n<h4><a href=\"#id22\" rel=\"nofollow\">TAL expressions</a></h4>\n<p>Starting with <tt>megrok.chameleon</tt> 0.5 we deploy the all-in-one\n<a href=\"http://chameleon.repoze.org/docs/latest/zpt.html\" rel=\"nofollow\">Chameleon</a> package.</p>\n<p>What TAL/TALES expressions in templates are supported depends mainly\nfrom the installed version of <cite>Chameleon</cite>, while we support some\nadditional, Zope-related TALES expressions.</p>\n<p>A list of all supported expressions and statements can be found at the\n<a href=\"http://chameleon.repoze.org/docs/latest/zpt.html\" rel=\"nofollow\">chameleon.zpt documentation</a>. The additional\nTALES expressions provided by <tt>megrok.chameleon</tt> are:</p>\n<ul>\n<li><dl>\n<dt><tt>exists</tt></dt>\n<dd>Tell whether a name exists in the templates\u2019 namespace.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>not</tt></dt>\n<dd>Evaluate the trailing expression to a boolean value and invert it.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>path</tt></dt>\n<dd>Handle the trailing expression as a path and not as a\nPython expression.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>provider</tt></dt>\n<dd>Support for viewlet providers.</dd>\n</dl>\n</li>\n</ul>\n<div>\n<p>Warning</p>\n<p><cite>z3c.pt</cite> support has been dropped with\n<tt>megrok.chameleon</tt> 0.5.</p>\n</div>\n<div>\n<p>Note</p>\n<p>Starting with <tt>megrok.chameleon</tt> 0.5 support for the\nPython expression <tt>exists()</tt> has been dropped. The TALES\nexpression <tt>exists: path/to/something</tt> is still available.</p>\n</div>\n<p>In our <tt>app.py</tt> we defined a special view for showing some special\nexpressions. This also includes a viewlet:</p>\n<pre>import grok\nfrom megrok.chameleon import components\n\nclass Mammoth(grok.Application, grok.Container):\n    pass\n\n...\n\nclass Expressions(grok.View):\n    pass\n\nclass MainArea(grok.ViewletManager):\n    grok.name('main')\n\nclass MainContent(grok.Viewlet):\n    grok.view(Expressions)\n    grok.viewletmanager(MainArea)\n    def render(self):\n        return 'Hello from viewlet'\n</pre>\n<p>Now we can make use of the TALES expressions <tt>not:</tt>, <tt>path:</tt>,\n<tt>exists:</tt> and <tt>provider:</tt> in the <tt>expressions.cpt</tt> template of\nour fixture:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'expressions.cpt')\n&gt;&gt;&gt; print open(cpt_file, 'rb').read()\n&lt;html&gt;\n&lt;body&gt;\n  &lt;div tal:define=\"food 'Yummy Dinoburger'\"\n       tal:omit-tag=\"\"&gt;\n    &lt;!-- We support `exists` --&gt;\n    &lt;div tal:condition=\"exists: food\"&gt;\n      ${food}\n    &lt;/div&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `not` --&gt;\n    &lt;div tal:content=\"not: food\" /&gt;\n    &lt;div tal:content=\"not('food')\" /&gt;\n    &lt;div tal:content=\"not: 1 in [2,3]\" /&gt;\n    &lt;div tal:content=\"not: not: food\" /&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `path` --&gt;\n    &lt;div tal:content=\"path: food/upper\" /&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `provider` --&gt;\n    &lt;tal:main content=\"structure provider:main\" /&gt;\n&lt;BLANKLINE&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>and render it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='expressions')\n&gt;&gt;&gt; print view()\n&lt;html&gt;\n&lt;body&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `exists` --&gt;\n    &lt;div&gt;\n      Yummy Dinoburger\n    &lt;/div&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `not` --&gt;\n    &lt;div&gt;False&lt;/div&gt;\n    &lt;div&gt;False&lt;/div&gt;\n    &lt;div&gt;True&lt;/div&gt;\n    &lt;div&gt;True&lt;/div&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `path` --&gt;\n    &lt;div&gt;YUMMY DINOBURGER&lt;/div&gt;\n&lt;BLANKLINE&gt;\n    &lt;!-- We support `provider` --&gt;\n    Hello from viewlet\n&lt;BLANKLINE&gt;\n&lt;BLANKLINE&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"macros\">\n<h4><a href=\"#id23\" rel=\"nofollow\">Macros</a></h4>\n<p>With <tt>megrok.chameleon</tt> we can also use macros, although it is a bit\ndifferent from regular Zope page templates.</p>\n<p>We can define macros like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'macromaster.cpt')\n&gt;&gt;&gt; print open(cpt_file, 'rb').read()\n&lt;p xmlns:metal=\"http://xml.zope.org/namespaces/metal\"\n   metal:define-macro=\"hello\"&gt;\n  Hello from &lt;b metal:define-slot=\"name\"&gt;macro master&lt;/b&gt;\n&lt;/p&gt;\n</pre>\n</blockquote>\n<p>The defined macro <tt>hello</tt> can be rendered in another Chameleon\ntemplate with the METAL attribute <tt><span class=\"pre\">use-macro</span></tt>.</p>\n<p>To refer to a local macro, i.e. a macros defined in the same template,\nyou can use something like:</p>\n<pre>&lt;div metal:use-macro=\"template.macros['&lt;macro-name&gt;']\"&gt;\n  Replaced by macro\n&lt;/div&gt;\n</pre>\n<p>where <tt><span class=\"pre\">&lt;macro-name&gt;</span></tt> must be an existing macro name.</p>\n<p>To refer to macros in external templates, you must use the <tt>path:</tt>\nexpression like this:</p>\n<pre>&lt;div metal:use-macro=\"path:\n  context/@@&lt;viewname&gt;/template/macros/&lt;macro-name&gt;\"&gt;\n   Replaced by external macro\n&lt;/div&gt;\n</pre>\n<p>where <tt>&lt;viewname&gt;</tt> refers to an existing view on <tt>context</tt> and\n<tt><span class=\"pre\">macro-name</span></tt> again refers to an existing macro in the specified template.</p>\n<p>Note, that this is different from how you refer to macros in standard\nZope page templates. The short notation <tt><span class=\"pre\">view/macros/&lt;macro-name&gt;</span></tt>\nworks only with regular Zope page templates.</p>\n<p>The following template makes use of both methods:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'macrouser.cpt')\n&gt;&gt;&gt; print open(cpt_file, 'rb').read()\n&lt;html xmlns:metal=\"http://xml.zope.org/namespaces/metal\"&gt;\n&lt;body&gt;\n  &lt;p metal:define-macro=\"hello\"&gt;\n    Hi there from macro user!\n  &lt;/p&gt;\n  &lt;div metal:use-macro=\"template.macros['hello']\"&gt;\n    Fill this\n  &lt;/div&gt;\n&lt;BLANKLINE&gt;\n  &lt;div metal:use-macro=\"path: context/@@macromaster/template/macros/hello\"&gt;\n    &lt;b metal:fill-slot=\"name\"&gt;user slot&lt;/b&gt;\n    Fill this too\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>When rendered also the slot defined in the master template is filled\nby macro user content:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cpt_file = os.path.join(template_dir, 'macrouser.cpt')\n&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='macrouser')\n&gt;&gt;&gt; print view()\n&lt;html&gt;\n&lt;body&gt;\n  &lt;p&gt;\n    Hi there from macro user!\n  &lt;/p&gt;\n  &lt;p&gt;\n    Hi there from macro user!\n  &lt;/p&gt;\n&lt;BLANKLINE&gt;\n&lt;BLANKLINE&gt;\n  &lt;p&gt;\n  Hello from &lt;b&gt;user slot&lt;/b&gt;\n&lt;BLANKLINE&gt;\n&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>Clean up:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del getRootFolder()['manfred']\n</pre>\n</blockquote>\n</div>\n<div id=\"differences-from-regular-zope-page-templates\">\n<h4><a href=\"#id24\" rel=\"nofollow\">Differences from regular Zope page templates</a></h4>\n<ul>\n<li>Macros are referenced differently. See appropriate section above.</li>\n<li>Expressions are parsed in <tt><span class=\"pre\">Python-mode</span></tt> by default. This means,\ninstead of <tt><span class=\"pre\">tal:content=\"view/value\"</span></tt> you must use\n<tt><span class=\"pre\">tal:content=\"view.value\"</span></tt>. Every occurence of TAL-expressions\nstarting with <tt>python:</tt> now can be shortened by skipping this\nmarker.</li>\n</ul>\n</div>\n</div>\n<div id=\"chameleon-genshi-templates\">\n<h3><a href=\"#id25\" rel=\"nofollow\">Chameleon Genshi templates</a></h3>\n<p>Chameleon provides support for Genshi templates which can be used from\ngrok writing templates with the <tt>.cg</tt> filename extension.</p>\n<p>Genshi text templates can be used with the <tt>.cgt</tt> filename\nextension.</p>\n<p>Note, that chameleon genshi templates might not cover the full range\nof functionality offered by native genshi parsers. Use <cite>megrok.genshi</cite>\nif you want native genshi support.</p>\n<p>See the <a href=\"http://pypi.python.org/pypi/chameleon.genshi\" rel=\"nofollow\">chameleon.genshi</a> page for more information.</p>\n<div id=\"id1\">\n<h4><a href=\"#id26\" rel=\"nofollow\">Prerequisites</a></h4>\n<p>Before we can see the templates in action, we care for correct\nregistration and set some used variables:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; testdir = os.path.join(os.path.dirname(__file__), 'tests')\n&gt;&gt;&gt; genshi_fixture = os.path.join(testdir, 'genshi_fixture')\n&gt;&gt;&gt; template_dir = os.path.join(genshi_fixture, 'app_templates')\n</pre>\n</blockquote>\n<p>We register everything. Before we can grok our fixture, we have to\ngrok the <cite>megrok.chameleon</cite> package. This way the new template types\nare registered with the framework:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; grokcore.view.testing.grok('megrok.chameleon')\n&gt;&gt;&gt; grokcore.view.testing.grok('megrok.chameleon.tests.genshi_fixture')\n</pre>\n</blockquote>\n<p>We create a mammoth, which should provide us a bunch of Genshi driven\nviews and put it in the database to setup location info:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from megrok.chameleon.tests.genshi_fixture.app import Mammoth\n&gt;&gt;&gt; manfred = Mammoth()\n&gt;&gt;&gt; getRootFolder()['manfred'] = manfred\n</pre>\n</blockquote>\n<p>Furthermore we prepare for getting the different views on manfred:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; from zope.component import getMultiAdapter\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n</div>\n<div id=\"id2\">\n<h4><a href=\"#id27\" rel=\"nofollow\">Simple templates</a></h4>\n<p>We prepared a plain cavepainting view. The template looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; cavepainting_cg = os.path.join(template_dir, 'cavepainting.cg')\n&gt;&gt;&gt; print open(cavepainting_cg, 'rb').read()\n&lt;html&gt;\n  &lt;body&gt;\n    A cave painting.\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>The rendered view looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request),\n...                         name='cavepainting')\n&gt;&gt;&gt; print view()\n&lt;html&gt;\n  &lt;body&gt;\n    A cave painting.\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"id3\">\n<h4><a href=\"#id28\" rel=\"nofollow\">Substituting variables</a></h4>\n<p>A template can access variables like <tt>view</tt>, <tt>context</tt> and its\nmethods and attributes. The <tt>food</tt> view does exactly this. The\ntemplate looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; food_cg = os.path.join(template_dir, 'food.cg')\n&gt;&gt;&gt; print open(food_cg, 'rb').read()\n&lt;html&gt;\n&lt;body&gt;\n${view.me_do()}\nCSS-URL: ${static['test.css']()}\nMy context is: ${view.url(context)}\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>The rendered view looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='food')\n&gt;&gt;&gt; print view()\n&lt;html&gt;\n&lt;body&gt;\nME GROK EAT MAMMOTH!\nCSS-URL: http://127.0.0.1/@@/megrok.chameleon.tests.genshi_fixture/test.css\nMy context is: http://127.0.0.1/manfred\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"including-other-templates\">\n<h4><a href=\"#id29\" rel=\"nofollow\">Including other templates</a></h4>\n<p>With genshi support we can also include other templates. The\n<tt>gatherer</tt> view looks like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; gatherer_cg = os.path.join(template_dir, 'gatherer.cg')\n&gt;&gt;&gt; print open(gatherer_cg, 'rb').read()\n&lt;html xmlns:xi=\"http://www.w3.org/2001/XInclude\"&gt;\n&lt;body&gt;\nME GROK GATHER BERRIES!\n&lt;xi:include href=\"berries.cg\"/&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>Apparently here we include a template called <tt>berries.cg</tt>. It looks\nlike this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; berries_cg = os.path.join(template_dir, 'berries.cg')\n&gt;&gt;&gt; print open(berries_cg, 'rb').read()\n&lt;strong&gt;Lovely blueberries!&lt;/strong&gt;\n</pre>\n</blockquote>\n<p>When we render the former template, we get:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='gatherer')\n&gt;&gt;&gt; print view()\n&lt;html&gt;\n&lt;body&gt;\nME GROK GATHER BERRIES!\n&lt;strong&gt;Lovely blueberries!&lt;/strong&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"text-templates\">\n<h4><a href=\"#id30\" rel=\"nofollow\">Text templates</a></h4>\n<p>Also genshi text templates are supported. We have a template that\nlooks like so:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; hunter_cgt = os.path.join(template_dir, 'hunter.cgt')\n&gt;&gt;&gt; print open(hunter_cgt, 'rb').read()\nME GROK HUNT ${view.game}!\n</pre>\n</blockquote>\n<p>Note, that this template has the <tt>.cgt</tt> (= <strong>c</strong>ameleon <strong>g</strong>enshi\n<strong>t</strong>ext template) file extension.</p>\n<p>If we render it, all expressions are substituted:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = getMultiAdapter((manfred, request), name='hunter')\n&gt;&gt;&gt; print view()\nME GROK HUNT MAMMOTH!!\n</pre>\n</blockquote>\n</div>\n</div>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id31\" rel=\"nofollow\">CHANGES</a></h2>\n<div id=\"id4\">\n<h3><a href=\"#id32\" rel=\"nofollow\">0.5.2 (2010-07-19)</a></h3>\n<ul>\n<li>Remove dependency on chameleon.genshi as this is now included\ninto Chameleon itself.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id33\" rel=\"nofollow\">0.5.1 (2010-05-20)</a></h3>\n<ul>\n<li>Made registering of ITranslatorExpressions conditional: if\n<tt>z3c.pt</tt> is installed as well, we don\u2019t register our own\nones. Should fix DuplicationError when using megrok.chameleon\ntogether with other packages that require z3c.pt like <tt>z3c.form</tt>\nand dependent packages from grok-ecosphere.</li>\n<li>Get rid of zope.testing, zope.app.testing and z3c.testsetup for\ntests.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id34\" rel=\"nofollow\">0.5 (2010-03-03)</a></h3>\n<ul>\n<li><p>Added tests to show usage of macros with <tt>megrok.chameleon</tt>.</p>\n</li>\n<li><p>Removed dependency from <tt>z3c.pt</tt> by copying the relevant bits over\nand registering them locally.</p>\n<p>Drop support for <tt><span class=\"pre\">exists('varname')</span></tt> expressions. The regular\nTALES expression <tt>exists: varname/path</tt> can still be used.</p>\n</li>\n<li><p>Switch to use <tt>Chameleon</tt> instead of <tt>chameleon.*</tt> packages.</p>\n</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id35\" rel=\"nofollow\">0.4 (2010-02-23)</a></h3>\n<ul>\n<li>Declared <tt>megrok</tt> as namespace package.</li>\n<li>Fixed order of includes in ftesting.zcml.</li>\n<li>Moved pure test-requirements into own setup-section in order to reduce\ndependencies in regular (non-testing) mode.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id36\" rel=\"nofollow\">0.3 (2010-02-14)</a></h3>\n<ul>\n<li>Added license file.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id37\" rel=\"nofollow\">0.2 (2009-09-18)</a></h3>\n<ul>\n<li>Provide macro access from templates.</li>\n<li>Don\u2019t depend anymore on grok, but only grokcore.view.</li>\n<li>Added support for <cite>path()</cite> and <cite>exists()</cite> in page templates. This\nwas introduced from <cite>z3c.pt</cite>.</li>\n<li>Fix ZCML includes.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id38\" rel=\"nofollow\">0.1 (2009-02-22)</a></h3>\n<ul>\n<li>Initial release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 794639, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "5e04abe1371602bd2bd50dc2f98ac339", "sha256": "4b1a711f1df558b9734eb0c1d14daf70895f0c13b0cc1aec2b541d9f3d134733"}, "downloads": -1, "filename": "megrok.chameleon-0.1.tar.gz", "has_sig": false, "md5_digest": "5e04abe1371602bd2bd50dc2f98ac339", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11125, "upload_time": "2009-02-22T15:01:44", "upload_time_iso_8601": "2009-02-22T15:01:44.991443Z", "url": "https://files.pythonhosted.org/packages/b2/c0/ba33ae9f5f074947413464a52bb730e783ef3f2f333d712aa8a11be187ee/megrok.chameleon-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "441c161894dc2ac1ed7ddb487b04c7cf", "sha256": "f8e81ded46ad482fa3ca204ea2f403bd6c367b5ea536f76692d4b3b657f2f366"}, "downloads": -1, "filename": "megrok.chameleon-0.2.tar.gz", "has_sig": false, "md5_digest": "441c161894dc2ac1ed7ddb487b04c7cf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19194, "upload_time": "2009-09-18T17:04:19", "upload_time_iso_8601": "2009-09-18T17:04:19.453262Z", "url": "https://files.pythonhosted.org/packages/5a/48/708fda6ca789168ec3bb44f34252e40866f77675dc7980abc3b16230212d/megrok.chameleon-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "a10ce5636bd27c10df0f41d802f665e4", "sha256": "ffa0d03df097988882d82d9e361442fdfb992c0fd1a35ec31e9a6eb7b9116661"}, "downloads": -1, "filename": "megrok.chameleon-0.3.tar.gz", "has_sig": false, "md5_digest": "a10ce5636bd27c10df0f41d802f665e4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18890, "upload_time": "2010-02-14T12:40:07", "upload_time_iso_8601": "2010-02-14T12:40:07.908767Z", "url": "https://files.pythonhosted.org/packages/7e/88/107522c7cadc3cf0137d4324bd9bca5b02f8791a0bad7065b761d17a974e/megrok.chameleon-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "9fea694e185a92a2d048db322e6ab49f", "sha256": "77f3480220b1240ea78c5d3e182195b69fd523839a2e7a910d92f86f9a1c8e2b"}, "downloads": -1, "filename": "megrok.chameleon-0.4.tar.gz", "has_sig": false, "md5_digest": "9fea694e185a92a2d048db322e6ab49f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19450, "upload_time": "2010-02-23T14:13:05", "upload_time_iso_8601": "2010-02-23T14:13:05.715487Z", "url": "https://files.pythonhosted.org/packages/4e/03/35f8171aac8942c53c9e62d576a0a40b9f5dcfe6866b865920f2c378710a/megrok.chameleon-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "1abc4ee150703a9d85d6e3597daf724f", "sha256": "487369e51ec4dae14fa45b3ec0ac4831052f40c1d25b712457f281f336221747"}, "downloads": -1, "filename": "megrok.chameleon-0.5.tar.gz", "has_sig": false, "md5_digest": "1abc4ee150703a9d85d6e3597daf724f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25941, "upload_time": "2010-03-03T13:05:54", "upload_time_iso_8601": "2010-03-03T13:05:54.202126Z", "url": "https://files.pythonhosted.org/packages/a1/22/45a189b44d0fc03c9b590c0dde4402422600722c9b2022366bfba061e23c/megrok.chameleon-0.5.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "51da4b01c5496129fb4004a0940fe0fd", "sha256": "1d1047d61708b775268edb306bcee343696580f24703888a156a8cbd7c182940"}, "downloads": -1, "filename": "megrok.chameleon-0.5.1.tar.gz", "has_sig": false, "md5_digest": "51da4b01c5496129fb4004a0940fe0fd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26508, "upload_time": "2010-05-20T15:48:45", "upload_time_iso_8601": "2010-05-20T15:48:45.121976Z", "url": "https://files.pythonhosted.org/packages/f4/db/d8065347d97b6b7ccd985ff22e1b2554e955fd630c2a6498ef197c95b452/megrok.chameleon-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "7d440eb1f16f153bf0db015c6a37b15d", "sha256": "a6084266f92b36599732c5f89f8d72eb826e63db589fe0b61c9a66ff975d3ba0"}, "downloads": -1, "filename": "megrok.chameleon-0.5.2.tar.gz", "has_sig": false, "md5_digest": "7d440eb1f16f153bf0db015c6a37b15d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20699, "upload_time": "2010-07-29T13:21:44", "upload_time_iso_8601": "2010-07-29T13:21:44.080182Z", "url": "https://files.pythonhosted.org/packages/d4/53/92f5256c9c6afba3c2cc6127e4fab85a4f107923be6fed3e11c620f9e585/megrok.chameleon-0.5.2.tar.gz", "yanked": false}], "1.0rc1": [{"comment_text": "", "digests": {"md5": "6ced6dc9648c483cb07abb871ada159e", "sha256": "aba500d4fe019bdb24e511fe56bdfc6105415cd8fb733109c4e0aae5532f7d4f"}, "downloads": -1, "filename": "megrok.chameleon-1.0rc1.tar.gz", "has_sig": false, "md5_digest": "6ced6dc9648c483cb07abb871ada159e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19859, "upload_time": "2011-05-19T15:46:56", "upload_time_iso_8601": "2011-05-19T15:46:56.816338Z", "url": "https://files.pythonhosted.org/packages/05/d6/3f596812216aebd1e389a1889f6459d6d78a83227e82bf689b13069cbf1b/megrok.chameleon-1.0rc1.tar.gz", "yanked": false}], "1.0rc2": [{"comment_text": "", "digests": {"md5": "5ba433e6262a7ec8a05e1d4a70418a31", "sha256": "a702535ff099b13d64415bab0df3ceb9036b901ad12dd662040245bd6a172889"}, "downloads": -1, "filename": "megrok.chameleon-1.0rc2.tar.gz", "has_sig": false, "md5_digest": "5ba433e6262a7ec8a05e1d4a70418a31", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22935, "upload_time": "2011-07-13T20:02:34", "upload_time_iso_8601": "2011-07-13T20:02:34.285664Z", "url": "https://files.pythonhosted.org/packages/ad/c6/8b03cf2b9630a229d894d086f9dd41e2c5e104c8570b177e12079bcfa541/megrok.chameleon-1.0rc2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7d440eb1f16f153bf0db015c6a37b15d", "sha256": "a6084266f92b36599732c5f89f8d72eb826e63db589fe0b61c9a66ff975d3ba0"}, "downloads": -1, "filename": "megrok.chameleon-0.5.2.tar.gz", "has_sig": false, "md5_digest": "7d440eb1f16f153bf0db015c6a37b15d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20699, "upload_time": "2010-07-29T13:21:44", "upload_time_iso_8601": "2010-07-29T13:21:44.080182Z", "url": "https://files.pythonhosted.org/packages/d4/53/92f5256c9c6afba3c2cc6127e4fab85a4f107923be6fed3e11c620f9e585/megrok.chameleon-0.5.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:28 2020"}