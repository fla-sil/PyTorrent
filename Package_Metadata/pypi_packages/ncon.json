{"info": {"author": "Markus Hauru", "author_email": "markus@mhauru.org", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering"], "description": "# ncon\n[![][travis-img]][travis-url] [![][codecov-img]][codecov-url]\n\nncon is a Python 3 package that implements the NCon function as described here:\nhttps://arxiv.org/abs/1402.0939\nThis Python implementation lacks some of the fancier features described in\nthe paper, but the interface is the same.\n\nncon requires numpy and works with numpy ndarrays. It also works with the\nvarious tensors from [this](https://github.com/mhauru/abeliantensors) package,\nbut does not require it.\n\n## Installation\n\n`pip install --user ncon`\n\n## Usage\n\nThe only thing this package exports is the function `ncon`. It takes a list of\ntensors to be contracted, and a list index lists that specify what gets\ncontracted with that. It returns a single tensor, that is the result of the\ncontraction. Here's how the syntax works:\n```\nncon(L, v, order=None, forder=None, check_indices=True):\n```\nThe first argument `L` is a list of tensors.\nThe second argument `v` is a list of list, one for each tensor in `L`.\nEach `v[i]` consists of integers, each of which labels an index of `L[i]`.\nPositive labels mark indices which are to be contracted (summed over).\nSo if for instance `v[m][i] == 2` and `v[n][j] == 2`, then the `i`th index of\n`L[m]` and the `j`th index of `L[n]` are to be identified and summed over.\nNegative labels mark indices which are to remain free (uncontracted).\n\nThe keyword argument `order` is a list of all the positive labels, which\nspecifies the order in which the pair-wise tensor contractions are to be done.\nBy default it is `sorted(all-positive-numbers-in-v)`, so for instance\n`[1,2,...]`. Note that whenever an index joining two tensors is about to be\ncontracted together, `ncon` contracts at the same time all indices connecting\nthese two tensors, even if some of them only come up later in order.\n\nCorrespondingly `forder` specifies the order to which the remaining free\nindices are to be permuted. By default it is\n`sorted(all-negative-numbers-in-v, reverse=True)`,\nmeaning for instance `[-1,-2,...]`.\n\nIf `check_indices=True` (the default) then checks are performed to make sure\nthe contraction is well-defined. If not, an `ValueError` with a helpful\ndescription of what went wrong is provided.\n\nIf the syntax sounds a lot like Einstein summation, as implemented for example\nby `np.einsum`, then that's because it is. The benefits of `ncon` are that many\ntensor networkers are used to its syntax, and it is easy to dynamically\ngenerate index lists and contractions.\n\n#### Examples\n\nHere's a few examples, straight from the test file.\n\nA matrix product:\n```\nfrom ncon import ncon\na = np.random.randn(3, 4)\nb = np.random.randn(4, 5)\nab_ncon = ncon([a, b], ((-1, 1), (1, -2)))\nab_np = np.dot(a, b)\nassert np.allclose(ab_ncon, ab_np)\n```\nHere the last index of `a` and the first index of `b` are contracted.\nThe result is a tensor with two free indices, labeled by `-1` and `-2`.\nThe one labeled with `-1` becomes the first index of the result. If we gave the\nadditional argument `forder=[-2,-1]` the tranpose would be returned instead.\n\nA more complicated example:\n```a = np.random.randn(3, 4, 5)\nb = np.random.randn(5, 3, 6, 7, 6)\nc = np.random.randn(7, 2)\nd = np.random.randn(8)\ne = np.random.randn(8, 9)\nresult_ncon = ncon(\n    (a, b, c, d, e), ([3, -2, 2], [2, 3, 1, 4, 1], [4, -1], [5], [5, -3])\n)\nresult_np = np.einsum(\"ijk,kilml,mh,q,qp->hjp\", a, b, c, d, e)\nassert np.allclose(result_ncon, result_np)\n```\nNotice that the network here is disconnected, `d` and `e` are not contracted\nwith any of the others. When contracting disconnected networks, the connected\nparts are always contracted first, and their tensor product is taken at the\nend. Traces are also okay, like here on two indices of `c`. By default, the\ncontractions are done in the order [1,2,3,4,5]. This may not be the optimal\nchoice, in which case we should specify a better contraction order as a keyword\nargument.\n\n[travis-img]: https://travis-ci.org/mhauru/ncon.svg?branch=master\n[travis-url]: https://travis-ci.org/mhauru/ncon\n[codecov-img]: https://codecov.io/gh/mhauru/ncon/branch/master/graph/badge.svg\n[codecov-url]: https://codecov.io/gh/mhauru/ncon\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mhauru/ncon", "keywords": "tensor networks", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "ncon", "package_url": "https://pypi.org/project/ncon/", "platform": "", "project_url": "https://pypi.org/project/ncon/", "project_urls": {"Homepage": "https://github.com/mhauru/ncon"}, "release_url": "https://pypi.org/project/ncon/1.0.0/", "requires_dist": ["numpy (>=1.11.0)", "pytest ; extra == 'tests'", "coverage ; extra == 'tests'"], "requires_python": ">=3.6", "summary": "Tensor network contraction function for Python 3.", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>ncon</h1>\n<p><a href=\"https://travis-ci.org/mhauru/ncon\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6f6a58597b4275c133dbe0c66bfd42554b58fe16/68747470733a2f2f7472617669732d63692e6f72672f6d68617572752f6e636f6e2e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://codecov.io/gh/mhauru/ncon\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1131f6ecd846839d5083797e80da44e8d490ad12/68747470733a2f2f636f6465636f762e696f2f67682f6d68617572752f6e636f6e2f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<p>ncon is a Python 3 package that implements the NCon function as described here:\n<a href=\"https://arxiv.org/abs/1402.0939\" rel=\"nofollow\">https://arxiv.org/abs/1402.0939</a>\nThis Python implementation lacks some of the fancier features described in\nthe paper, but the interface is the same.</p>\n<p>ncon requires numpy and works with numpy ndarrays. It also works with the\nvarious tensors from <a href=\"https://github.com/mhauru/abeliantensors\" rel=\"nofollow\">this</a> package,\nbut does not require it.</p>\n<h2>Installation</h2>\n<p><code>pip install --user ncon</code></p>\n<h2>Usage</h2>\n<p>The only thing this package exports is the function <code>ncon</code>. It takes a list of\ntensors to be contracted, and a list index lists that specify what gets\ncontracted with that. It returns a single tensor, that is the result of the\ncontraction. Here's how the syntax works:</p>\n<pre><code>ncon(L, v, order=None, forder=None, check_indices=True):\n</code></pre>\n<p>The first argument <code>L</code> is a list of tensors.\nThe second argument <code>v</code> is a list of list, one for each tensor in <code>L</code>.\nEach <code>v[i]</code> consists of integers, each of which labels an index of <code>L[i]</code>.\nPositive labels mark indices which are to be contracted (summed over).\nSo if for instance <code>v[m][i] == 2</code> and <code>v[n][j] == 2</code>, then the <code>i</code>th index of\n<code>L[m]</code> and the <code>j</code>th index of <code>L[n]</code> are to be identified and summed over.\nNegative labels mark indices which are to remain free (uncontracted).</p>\n<p>The keyword argument <code>order</code> is a list of all the positive labels, which\nspecifies the order in which the pair-wise tensor contractions are to be done.\nBy default it is <code>sorted(all-positive-numbers-in-v)</code>, so for instance\n<code>[1,2,...]</code>. Note that whenever an index joining two tensors is about to be\ncontracted together, <code>ncon</code> contracts at the same time all indices connecting\nthese two tensors, even if some of them only come up later in order.</p>\n<p>Correspondingly <code>forder</code> specifies the order to which the remaining free\nindices are to be permuted. By default it is\n<code>sorted(all-negative-numbers-in-v, reverse=True)</code>,\nmeaning for instance <code>[-1,-2,...]</code>.</p>\n<p>If <code>check_indices=True</code> (the default) then checks are performed to make sure\nthe contraction is well-defined. If not, an <code>ValueError</code> with a helpful\ndescription of what went wrong is provided.</p>\n<p>If the syntax sounds a lot like Einstein summation, as implemented for example\nby <code>np.einsum</code>, then that's because it is. The benefits of <code>ncon</code> are that many\ntensor networkers are used to its syntax, and it is easy to dynamically\ngenerate index lists and contractions.</p>\n<h4>Examples</h4>\n<p>Here's a few examples, straight from the test file.</p>\n<p>A matrix product:</p>\n<pre><code>from ncon import ncon\na = np.random.randn(3, 4)\nb = np.random.randn(4, 5)\nab_ncon = ncon([a, b], ((-1, 1), (1, -2)))\nab_np = np.dot(a, b)\nassert np.allclose(ab_ncon, ab_np)\n</code></pre>\n<p>Here the last index of <code>a</code> and the first index of <code>b</code> are contracted.\nThe result is a tensor with two free indices, labeled by <code>-1</code> and <code>-2</code>.\nThe one labeled with <code>-1</code> becomes the first index of the result. If we gave the\nadditional argument <code>forder=[-2,-1]</code> the tranpose would be returned instead.</p>\n<p>A more complicated example:</p>\n<pre>b = np.random.randn(5, 3, 6, 7, 6)\nc = np.random.randn(7, 2)\nd = np.random.randn(8)\ne = np.random.randn(8, 9)\nresult_ncon = ncon(\n    (a, b, c, d, e), ([3, -2, 2], [2, 3, 1, 4, 1], [4, -1], [5], [5, -3])\n)\nresult_np = np.einsum(\"ijk,kilml,mh,q,qp-&gt;hjp\", a, b, c, d, e)\nassert np.allclose(result_ncon, result_np)\n</pre>\n<p>Notice that the network here is disconnected, <code>d</code> and <code>e</code> are not contracted\nwith any of the others. When contracting disconnected networks, the connected\nparts are always contracted first, and their tensor product is taken at the\nend. Traces are also okay, like here on two indices of <code>c</code>. By default, the\ncontractions are done in the order [1,2,3,4,5]. This may not be the optimal\nchoice, in which case we should specify a better contraction order as a keyword\nargument.</p>\n\n          </div>"}, "last_serial": 6610773, "releases": {"0.9.0": [{"comment_text": "", "digests": {"md5": "167b1540e9b524a2b8624f3c127ee9eb", "sha256": "afc9e5548ee64caef673877bb8f18eb0ccb70d87c3882795de18cf92d23874cb"}, "downloads": -1, "filename": "ncon-0.9.0-py3-none-any.whl", "has_sig": false, "md5_digest": "167b1540e9b524a2b8624f3c127ee9eb", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 7776, "upload_time": "2020-02-05T10:08:30", "upload_time_iso_8601": "2020-02-05T10:08:30.736043Z", "url": "https://files.pythonhosted.org/packages/97/c9/58ad820fd1651ba871be3ff27e62227bcc59b535605ad4b3bff588027bb6/ncon-0.9.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f6acc62fc564eb350a23d59282858333", "sha256": "925eb8f64a0323e3db2810def4ef8213ba6978b8fac6ce9c56ab9f4e400e0183"}, "downloads": -1, "filename": "ncon-0.9.0.tar.gz", "has_sig": false, "md5_digest": "f6acc62fc564eb350a23d59282858333", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6935, "upload_time": "2020-02-05T10:08:33", "upload_time_iso_8601": "2020-02-05T10:08:33.160631Z", "url": "https://files.pythonhosted.org/packages/19/ed/3d5b1685ce48266fe766e08f1cc4ba3125ec81343600fda14798367149fc/ncon-0.9.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "65fd5172b68c9add6d795c1021145162", "sha256": "e13b8187cf4b72286646858b4b9bd45698f26fa57ad1ec86603b153bcdcc02e4"}, "downloads": -1, "filename": "ncon-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "65fd5172b68c9add6d795c1021145162", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 7801, "upload_time": "2020-02-11T17:05:34", "upload_time_iso_8601": "2020-02-11T17:05:34.378355Z", "url": "https://files.pythonhosted.org/packages/16/ec/0945146a1629875840fa549568254a19ea79b6901e47005647ae6e9a0c3d/ncon-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "06fc34b416692d2d5ebba70fbf8f152b", "sha256": "eb9987a315d43944571e894042b05faef5dd9202ebde77afe053e4cb5e853c0f"}, "downloads": -1, "filename": "ncon-1.0.0.tar.gz", "has_sig": false, "md5_digest": "06fc34b416692d2d5ebba70fbf8f152b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6966, "upload_time": "2020-02-11T17:05:35", "upload_time_iso_8601": "2020-02-11T17:05:35.674789Z", "url": "https://files.pythonhosted.org/packages/d0/82/f86241dd4e6f1c473963eceabf150c69a52e35c4257eaa0d29a7a104606e/ncon-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "65fd5172b68c9add6d795c1021145162", "sha256": "e13b8187cf4b72286646858b4b9bd45698f26fa57ad1ec86603b153bcdcc02e4"}, "downloads": -1, "filename": "ncon-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "65fd5172b68c9add6d795c1021145162", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 7801, "upload_time": "2020-02-11T17:05:34", "upload_time_iso_8601": "2020-02-11T17:05:34.378355Z", "url": "https://files.pythonhosted.org/packages/16/ec/0945146a1629875840fa549568254a19ea79b6901e47005647ae6e9a0c3d/ncon-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "06fc34b416692d2d5ebba70fbf8f152b", "sha256": "eb9987a315d43944571e894042b05faef5dd9202ebde77afe053e4cb5e853c0f"}, "downloads": -1, "filename": "ncon-1.0.0.tar.gz", "has_sig": false, "md5_digest": "06fc34b416692d2d5ebba70fbf8f152b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6966, "upload_time": "2020-02-11T17:05:35", "upload_time_iso_8601": "2020-02-11T17:05:35.674789Z", "url": "https://files.pythonhosted.org/packages/d0/82/f86241dd4e6f1c473963eceabf150c69a52e35c4257eaa0d29a7a104606e/ncon-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:47 2020"}