{"info": {"author": "Alessandro Genova", "author_email": "ales.genova@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Chemistry", "Topic :: Scientific/Engineering :: Physics"], "description": "\nPbcPy\n=====\n\n\n.. image:: https://img.shields.io/pypi/v/pbcpy.svg\n   :target: https://pypi.python.org/pypi/pbcpy/\n   :alt: PyPI version\n\n\n.. image:: https://img.shields.io/pypi/status/pbcpy.svg\n   :target: https://pypi.python.org/pypi/pbcpy/\n   :alt: PyPI status\n\n\n.. image:: https://gitlab.com/ales.genova/pbcpy/badges/master/pipeline.svg\n   :target: https://gitlab.com/ales.genova/pbcpy/pipelines\n   :alt: pipeline status\n\n\n.. image:: https://gitlab.com/ales.genova/pbcpy/badges/master/coverage.svg\n   :target: https://gitlab.com/ales.genova/pbcpy/pipelines\n   :alt: coverage report\n\n\n.. image:: https://img.shields.io/badge/License-MIT-blue.svg\n   :target: https://opensource.org/licenses/MIT\n   :alt: License: MIT\n\n\n``pbcpy`` is a Python3 package providing some useful abstractions to deal with\nmolecules and materials under periodic boundary conditions (PBC).\n\nIn addition, ``pbcpy`` exposes a fully periodic N-rank array, the ``pbcarray``\\ , which is derived from the ``numpy.ndarray``.\n\nFinally, ``pbcpy`` provides IO support to some common file formats:\n\n\n* Quantum Espresso ``.pp`` format (read only)\n* XCrySDen ``.xsf`` format (write only)\n\nIndex\n-----\n\n\n* `Authors <#authors>`_\n* `Fundamentals <#fundamentals>`_\n* `Installation <#installation>`_\n* `\\ **DirectCell** and **ReciprocalCell** class <#directcell-and-reciprocalcell-class>`_\n* `\\ **Coord** class <#coord-class>`_\n* `\\ **DirectGrid** and **ReciprocalGrid** class <#directgrid-and-reciprocalgrid-class>`_\n* `\\ **DirectField** and **ReciprocalField** class <#directfield-and-reciprocalfield-class>`_\n* `\\ **System** class <#system-class>`_\n* `\\ **pbcarray** class <#pbcarray-class>`_\n* `File Formats <#file-formats>`_\n\nAuthors\n-------\n\n``pbcpy`` has been developed @ `Pavanello Research Group <http://michelepavanello.com/>`_ by:\n\n\n* **Alessandro Genova**\n\nwith contributions from:\n\n\n* Tommaso Pavanello\n* Michele Pavanello\n\nFundamentals\n------------\n\n\n* ``DirectCell`` and ``Coord`` classes which define a unit cell under PBC in real space, and a cartesian/crystal coordinate respectively;\n* ``ReciprocalCell`` class which defines a cell in reciprocal space;\n* ``DirectGrid`` and ``ReciprocalGrid`` classes, which are derived from ``DirectCell`` and ``ReciprocalCell`` and provide space discretization;\n* ``DirectField`` and ``ReciprocalField``\\ , classes to represent a scalar (such as an electron density or a potential) and/or vector fields associated to either a ``DirectGrid`` or a ``ReciprocalGrid``\\ ;\n\nInstallation\n------------\n\nInstall ``pbcpy`` through ``PyPI``\n\n.. code-block::\n\n   pip install pbcpy\n\nInstall the dev version from ``gitlab``\n\n.. code-block::\n\n   git clone git@gitlab.com:ales.genova/pbcpy.git\n\nNOTE: ``pbcpy`` is in the early stages of development, classes and APIs are bound to be changed without prior notice.\n\n``DirectCell`` and ``ReciprocalCell`` class\n---------------------------------------------------\n\nA unit cell is defined by its lattice vectors. To create a ``DirectCell`` object we need to provide it a ``3x3`` matrix containing the lattice vectors (as columns).\n``pbcpy`` expects atomic units, a flexible units system might be addedd in the future.\n\n.. code-block:: python\n\n   >>> from pbcpy.base import DirectCell, ReciprocalCell\n   >>> import numpy as np\n   >>> lattice = np.identity(3)*10 # Make sure that at1 is of type numpy array.\n   >>> cell1 = DirectCell(lattice=lattice, origin=[0,0,0]) # 10 Bohr cubic cell\n\n``DirectCell`` and ``ReciprocalCell`` properties\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n* ``lattice`` : the lattice vectors (as columns)\n* ``volume`` : the volume of the cell\n* ``origin`` : the origin of the Cartesian reference frame\n\n.. code-block:: python\n\n   # the lattice\n   >>> cell1.lattice\n   array([[ 10.,   0.,   0.],\n          [  0.,  10.,   0.],\n          [  0.,   0.,  10.]])\n\n   # the volume\n   >>> cell1.volume\n   1000.0\n\n``DirectCell`` and ``ReciprocalCell`` methods\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n* \n  ``==`` operator : compare two ``Cell`` objects\n\n* \n  ``get_reciprocal``\\ : returns a new ``ReciprocalCell`` object that is the \"reciprocal\" cell of self (if self is a ``DirectCell``\\ )\n\n* ``get_direct``\\ : returns a new ``DirectCell`` object that is the \"direct\" cell of self (if self is a ``ReciprocalCell``\\ )\n\nNote, by default the physics convention is used when converting between direct and reciprocal lattice:\n\n.. code-block::\n\n   \\big[\\text{reciprocal.lattice}\\big]^T = 2\\pi \\cdot \\big[\\text{direct.lattice}\\big]^{-1}\n\n.. code-block:: python\n\n   >>> reciprocal_cell1 = cell1.get_reciprocal()\n   >>> print(reciprocal_cell1.lattice)\n   array([[ 0.62831853,  0. ,  0. ],\n          [ 0. ,  0.62831853,  0. ],\n          [ 0. ,  0. ,  0.62831853]])\n\n   >>> cell2 = reciprocal_cell1.get_direct()\n   >>> print(cell2.lattice)\n   array([[ 10.,  0.,  0.],\n          [ 0.,  10.,  0.],\n          [ 0.,  0.,  10.]])\n\n   >>> cell1 == cell2\n   True\n\n``Coord`` class\n-------------------\n\n``Coord`` is a ``numpy.array`` derived class, with some additional attributes and methods.\nCoordinates in a periodic system are meaningless without the reference unit cell, this is why a ``Coord`` object also has an embedded ``DirectCell`` attribute.\nAlso, coordinates can be either expressed in either a ``\"Cartesian\"`` or ``\"Crystal\"`` basis.\n\n.. code-block:: python\n\n   >>> from pbcpy.base import Coord\n   >>> pos1 = Coord(pos=[0.5,0.6,0.3], cell=cell1, ctype=\"Cartesian\")\n\n``Coord`` attributes\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n* ``basis`` : the coordinate type: ``'Cartesian'`` or ``'Crystal'``.\n* ``cell`` : the ``DirectCell`` object associated to the coordinates.\n\n.. code-block:: python\n\n   # the coordinate type (Cartesian or Crystal)\n   >>> pos1.basis\n   'Cartesian'\n\n   # the cell attribute is a Cell object\n   >>> type(pos1.cell)\n   pbcpy.base.DirectCell\n\n``Coord`` methods\n^^^^^^^^^^^^^^^^^^^^^\n\n\n* ``to_crys()``\\ , ``to_cart()`` : convert ``self`` to crystal or cartesian basis (returns a new ``Coord`` object).\n* ``d_mic(other)`` : Calculate the vector connecting two coordinates (from self to other), using the minimum image convention (MIC). The result is itself a ``Coord`` object.\n* ``dd_mic(other)`` : Calculate the distance between two coordinates, using the MIC.\n* ``+``\\ /\\ ``-`` operators : Calculate the difference/sum between two coordinates without using the MIC. ``basis`` conversions are automatically performed when needed. The result is itself a ``Coord`` object.\n\n.. code-block:: python\n\n   >>> pos1 = Coord(pos=[0.5,0.0,1.0], cell=cell1, ctype=\"Crystal\")\n   >>> pos2 = Coord(pos=[0.6,-1.0,3.0], cell=cell1, ctype=\"Crystal\")\n\n   # convert to Crystal or Cartesian (returns new object)\n   >>> pos1.to_cart() \n   Coord([  5.,   0.,  10.]) # the coordinate was already Cartesian, the result is still correct.\n   >>> pos1.to_crys()\n   Coord([ 0.5,  0. ,  1. ]) # the coordinate was already Crystal, the result is still correct.\n\n   ## vector connecting two coordinates (using the minimum image convention), and distance\n   >>> pos1.d_mic(pos2)\n   Coord([ 0.1,  0. ,  0. ])\n   >>> pos1.dd_mic(pos2)\n   0.99999999999999978\n\n   ## vector connecting two coordinates (without using the minimum image convention) and distance\n   >>> pos2 - pos1\n   Coord([ 0.1, -1. ,  2. ])\n   >>> (pos2 - pos1).length()\n   22.383029285599392\n\n``DirectGrid`` and ``ReciprocalGrid`` classes\n-----------------------------------------------------\n\n``DirectGrid`` and ``ReciprocalGrid`` are subclasses of ``DirectGrid`` and ``ReciprocalGrid`` respectively. ``Grid``\\ s inherit all the attributes and methods of their respective ``Cell``\\ s, and have a few of their own to deal with quantities represented on a equally spaced grid.\n\n.. code-block:: python\n\n   >>> from pbcpy.grid import DirectGrid\n   # A 10x10x10 Bohr Grid, with 100x100x100 gridpoints\n   >>> lattice = np.identity(3)*10\n   >>> grid1 = DirectGrid(lattice=lattice, nr=[100,100,100], origin=[0,0,0])\n\n``Grid`` attributes\n^^^^^^^^^^^^^^^^^^^^^^^\n\n\n* All the attributes inherited from ``Cell``\n* ``dV`` : the volume of a single point, useful when calculating integral quantities\n* ``nr`` : array, number of grid point for each direction\n* ``nnr`` : total number of points in the grid\n* ``r`` : cartesian coordinates at each grid point. A rank 3 array of type ``Coord`` (\\ ``DirectGrid`` only)\n* ``s`` : crystal coordinates at each grid point. A rank 3 array of type ``Coord`` (\\ ``DirectGrid`` only)\n* ``g`` : G vector at each grid point (\\ ``ReciprocalGrid`` only)\n* ``gg`` : Square of G vector at each grid point (\\ ``ReciprocalGrid`` only)\n\n.. code-block:: python\n\n   # The volume of each point\n   >>> grid1.dV\n   0.001\n\n   # Grid points for each direction\n   >>> grid1.nr\n   array([100, 100, 100])\n\n   # Total number of grid points\n   >>> grid1.nnr\n   1000000\n\n   # Cartesian coordinates at each grid point\n   >>> grid1.r\n   Coord([[[[ 0. ,  0. ,  0. ],\n            [ 0. ,  0. ,  0.1],\n            [ 0. ,  0. ,  0.2],\n            [ 0. ,  0. ,  0.3],\n                           ...]]])\n\n   >>> grid1.r.shape\n   (100, 100, 100, 3)\n\n   >>> grid1.r[0,49,99]\n   Coord([ 0. ,  4.9,  9.9])\n\n   # Crystal coordinates at each grid point\n   >>> grid1.s\n   Coord([[[[ 0.  ,  0.  ,  0.  ],\n        [ 0.  ,  0.  ,  0.01],\n            [ 0.  ,  0.  ,  0.02],\n            [ 0.  ,  0.  ,  0.03],\n                 ...]]]])\n\n   # Since DirectGrid inherits from DirectCell, we can still use the get_reciprocal methos\n   reciprocal_grid1 = grid1.get_reciprocal()\n\n   # reciprocal_grid1 is an instance of ReciprocalGrid\n   >>> reciprocal_grid1.g\n   array([[[[ 0.  ,  0.  ,  0.  ],\n            [ 0.  ,  0.  ,  0.01],\n            [ 0.  ,  0.  ,  0.02],\n            ..., \n            [ 0.  ,  0.  , -0.03],\n            [ 0.  ,  0.  , -0.02],\n            [ 0.  ,  0.  , -0.01]],\n                      ...]]])\n\n   >>> reciprocal_grid1.g.shape\n   (100, 100, 100, 3)\n\n   >>> reciprocal_grid1.gg\n   array([[[ 0.    ,  0.0001,  0.0004, ...,  0.0009,  0.0004,  0.0001],\n           [ 0.0001,  0.0002,  0.0005, ...,  0.001 ,  0.0005,  0.0002],\n           [ 0.0004,  0.0005,  0.0008, ...,  0.0013,  0.0008,  0.0005],\n           ..., \n           [ 0.0009,  0.001 ,  0.0013, ...,  0.0018,  0.0013,  0.001 ],\n           [ 0.0004,  0.0005,  0.0008, ...,  0.0013,  0.0008,  0.0005],\n           [ 0.0001,  0.0002,  0.0005, ...,  0.001 ,  0.0005,  0.0002]],\n           ...,\n                                                                     ]])\n\n   >>> reciprocal_grid1.gg.shape\n   (100, 100, 100)\n\n``DirectField`` and ``ReciprocalField`` class\n-----------------------------------------------------\n\nThe ``DirectField`` and ``ReciprocalField`` classes represent a scalar field on a ``DirectGrid`` and ``ReciprocalGrid`` respectively. These classes are extensions of the ``numpy.ndarray``.\n\nOperations such as interpolations, fft and invfft, and taking arbitrary 1D/2D/3D cuts are made very easy.\n\nA ``DirectField`` can be generated directly from Quantum Espresso postprocessing ``.pp`` files (see below).\n\n.. code-block:: python\n\n   # A DirectField example\n   >>> from pbcpy.field import DirectField\n   >>> griddata = np.random.random(size=grid1.nr)\n   >>> field1 = DirectField(grid=grid1, griddata_3d=griddata)\n\n   # When importing a Quantum Espresso .pp files a DirectField object is created\n   >>> from pbcpy.formats.qepp import PP\n   >>> water_dimer = PP(filepp=\"/path/to/density.pp\").read()\n   >>> rho = water_dimer.field\n   >>> type(rho)\n   pbcpy.field.DirectField\n\n``DirectField`` attributes\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n* ``grid`` : Represent the grid associated to the field (it's a ``DirectGrid`` or ``ReciprocalGrid`` object)\n* ``span`` : The number of dimensions of the grid for which the number of points is larger than 1\n* ``rank`` : The number of dimensions of the quantity at each grid point\n\n  * ``1`` : scalar field (e.g. the rank of rho is ``1``\\ )\n  * ``>1`` : vector field (e.g. the rank of the gradient of rho is ``3``\\ )\n\n.. code-block:: python\n\n   >>> type(rho.grid)\n   pbcpy.grid.DirectGrid\n\n   >>> rho.span\n   3\n\n   >>> rho.rank\n   1\n   # the density is a scalar field\n\n``DirectField`` methods\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n* Any method inherited from ``numpy.array``.\n* ``integral`` : returns the integral of the field.\n* ``get_3dinterpolation`` : Interpolates the data to a different grid (returns a new ``DirectField`` object). 3rd order spline interpolation.\n* ``get_cut(r0, [r1], [r2], [origin], [center], [nr])`` : Get 1D/2D/3D cuts of the scalar field, by providing arbitraty vectors and an origin/center.\n* ``fft`` : Calculates the Fourier transform of self, and returns an instance of ``ReciprocalField``\\ , which contains the appropriate ``ReciprocalGrid``\n\n.. code-block:: python\n\n   # Integrate the field over the whole grid\n   >>> rho.integral()\n   16.000000002898673 # the electron density of a water dimer has 16 valence electrons as expected\n\n   # Interpolate the scalar field from one grid to another\n   >>> rho.shape\n   (125, 125, 125)\n\n   >>> rho_interp = rho.get_3dinterpolation([90,90,90])\n   >>> rho_interp.shape\n   (90, 90, 90)\n\n   >> rho_interp.integral()\n   15.999915251442873\n\n\n   # Get arbitrary cuts of the scalar field.\n   # In this example get the cut of the electron density in the plane of the water molecule\n   >>> ppfile = \"/path/to/density.pp\"\n   >>> water_dimer = PP(ppfile).read()\n\n   >>> o_pos = water_dimer.ions[0].pos\n   >>> h1_pos = water_dimer.ions[1].pos\n   >>> h2_pos = water_dimer.ions[2].pos\n\n   >>> rho_cut = rho.get_cut(r0=o_h1_vec*4, r1=o_h2_vec*4, center=o_pos, nr=[100,100])\n\n   # plot_cut is itself a DirectField instance, and it can be either exported to an xsf file (see next session)\n   # or its values can be analized/manipulated in place.\n   >>> rho_cut.shape\n   (100,100)\n   >>> rho_cut.span\n   2\n   >>> rho_cut.grid.lattice\n   array([[ 1.57225214, -6.68207161, -0.43149218],\n          [-1.75366585, -3.04623853,  0.8479004 ],\n          [-7.02978121,  0.97509868, -0.30802502]])\n\n   # plot_cut is itself a Grid_Function_Base instance, and it can be either exported to an xsf file (see next session)\n   # or its values can be analized/manipulated in place.\n   >>> plot_cut.values.shape\n   (200, 200)\n\n   # Fourier transform of the DirectField\n   >>> rho_g = rho.fft()\n   >>> type(rho_g)\n   pbcpy.field.ReciprocalField\n\n``ReciprocalField`` methods\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n* ``ifft`` : Calculates the inverse Fourier transform of self, and returns an instance of ``DirectField``\\ , which contains the appropriate ``DirectGrid``\n\n.. code-block:: python\n\n   # inv fft:\n   # recall that rho_g = fft(rho)\n   >>> rho1 = rho_g.ifft()\n   >>> type(rho1)\n   pbcpy.field.DirectField\n\n   >>> rho1.grid == rho.grid\n   True\n\n   >>> np.isclose(rho1, rho).all()\n   True\n   # as expected ifft(fft(rho)) = rho\n\n``System`` class\n--------------------\n\n``System`` is simply a class containing a ``DirectCell`` (or ``DirectGrid``\\ ), a set of atoms ``ions``\\ , and a ``DirectField``\n\n``System`` attributes\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n* ``name`` : arbitrary name\n* ``ions`` : collection of atoms and their coordinates\n* ``cell`` : the unit cell of the system (\\ ``DirectCell`` or ``DirectGrid``\\ )\n* ``field`` : an optional ``DirectField`` object.\n\n``pbcarray`` class\n----------------------\n\n``pbcarray`` is a sublass of ``numpy.ndarray``\\ , and is suitable to represent periodic quantities, by including robust wrapping capabilities.\n``pbcarray`` can be of any rank, and it can be freely sliced.\n\n.. code-block:: python\n\n   # 1D example, but it is valid for any rank.\n   >>> from pbcpy.base import pbcarray\n   >>> import  matplotlib.pyplot as plt\n   >>> x = np.linspace(0,2*np.pi, endpoint=False, num=100)\n   >>> y = np.sin(x)\n   >>> y_pbc = pbcarray(y)\n   >>> y_pbc.shape\n   (100,)                          # y_pbc only has 100 elements, but we can freely do operations such as:\n   >>> plt.plot(y_pbc[-100:200])   # and get the expected result\n\nFile Formats\n------------\n\n``PP`` class\n^^^^^^^^^^^^^^^^\n\n``pbcpy`` can read a Quantum Espresso post-processing ``.pp`` file into a ``System`` object.\n\n.. code-block:: python\n\n   >>> water_dimer = PP(filepp='/path/to/density.pp').read() \n   # the output of PP.read() is a System object.\n\n``XSF`` class\n^^^^^^^^^^^^^^^^^\n\n``pbcpy`` can write a ``System`` object into a XCrySDen  ``.xsf`` file.\n\n.. code-block:: python\n\n   >>> XSF(filexsf='/path/to/output.xsf').write(system=water_dimer)\n\n   # an optional field parameter can be passed to XSF.write() in order to override the DirectField in system.\n   # This is especially useful if one wants to output one system and an arbitrary cut of the grid,\n   # such as the one we generated earlier\n   >>> XSF(filexsf='/path/to/output.xsf').write(system=water_dimer, field=rho_cut)\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://gitlab.com/ales.genova/pbcpy/", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pbcpy", "package_url": "https://pypi.org/project/pbcpy/", "platform": "", "project_url": "https://pypi.org/project/pbcpy/", "project_urls": {"Homepage": "https://gitlab.com/ales.genova/pbcpy/"}, "release_url": "https://pypi.org/project/pbcpy/0.2.7/", "requires_dist": null, "requires_python": "", "summary": "A toolbox to make it easier to deal with materials under periodc boundary conditions.", "version": "0.2.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.python.org/pypi/pbcpy/\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/73a8923e4c5bfe99a5a62f0b14b2d9a7be64a32e/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f70626370792e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/pbcpy/\" rel=\"nofollow\"><img alt=\"PyPI status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ae3f5e55b2c0fb19a90422c4b585c80d45aace5b/68747470733a2f2f696d672e736869656c64732e696f2f707970692f7374617475732f70626370792e737667\"></a>\n<a href=\"https://gitlab.com/ales.genova/pbcpy/pipelines\" rel=\"nofollow\"><img alt=\"pipeline status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0db025d14474cd6a3f1bb799b40b2ec5cd8c218b/68747470733a2f2f6769746c61622e636f6d2f616c65732e67656e6f76612f70626370792f6261646765732f6d61737465722f706970656c696e652e737667\"></a>\n<a href=\"https://gitlab.com/ales.genova/pbcpy/pipelines\" rel=\"nofollow\"><img alt=\"coverage report\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/be08bb06803a4e9dd82a4ddbcc94b070ed3df191/68747470733a2f2f6769746c61622e636f6d2f616c65732e67656e6f76612f70626370792f6261646765732f6d61737465722f636f7665726167652e737667\"></a>\n<a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img alt=\"License: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4150014b4dfdd7b565fa18de88e9bb1b8ccd7c08/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d626c75652e737667\"></a>\n<p><tt>pbcpy</tt> is a Python3 package providing some useful abstractions to deal with\nmolecules and materials under periodic boundary conditions (PBC).</p>\n<p>In addition, <tt>pbcpy</tt> exposes a fully periodic N-rank array, the <tt>pbcarray</tt>, which is derived from the <tt>numpy.ndarray</tt>.</p>\n<p>Finally, <tt>pbcpy</tt> provides IO support to some common file formats:</p>\n<ul>\n<li>Quantum Espresso <tt>.pp</tt> format (read only)</li>\n<li>XCrySDen <tt>.xsf</tt> format (write only)</li>\n</ul>\n<div id=\"index\">\n<h2>Index</h2>\n<ul>\n<li><a href=\"#authors\" rel=\"nofollow\">Authors</a></li>\n<li><a href=\"#fundamentals\" rel=\"nofollow\">Fundamentals</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#directcell-and-reciprocalcell-class\" rel=\"nofollow\">**DirectCell** and **ReciprocalCell** class</a></li>\n<li><a href=\"#coord-class\" rel=\"nofollow\">**Coord** class</a></li>\n<li><a href=\"#directgrid-and-reciprocalgrid-class\" rel=\"nofollow\">**DirectGrid** and **ReciprocalGrid** class</a></li>\n<li><a href=\"#directfield-and-reciprocalfield-class\" rel=\"nofollow\">**DirectField** and **ReciprocalField** class</a></li>\n<li><a href=\"#system-class\" rel=\"nofollow\">**System** class</a></li>\n<li><a href=\"#pbcarray-class\" rel=\"nofollow\">**pbcarray** class</a></li>\n<li><a href=\"#file-formats\" rel=\"nofollow\">File Formats</a></li>\n</ul>\n</div>\n<div id=\"id1\">\n<h2>Authors</h2>\n<p><tt>pbcpy</tt> has been developed @ <a href=\"http://michelepavanello.com/\" rel=\"nofollow\">Pavanello Research Group</a> by:</p>\n<ul>\n<li><strong>Alessandro Genova</strong></li>\n</ul>\n<p>with contributions from:</p>\n<ul>\n<li>Tommaso Pavanello</li>\n<li>Michele Pavanello</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h2>Fundamentals</h2>\n<ul>\n<li><tt>DirectCell</tt> and <tt>Coord</tt> classes which define a unit cell under PBC in real space, and a cartesian/crystal coordinate respectively;</li>\n<li><tt>ReciprocalCell</tt> class which defines a cell in reciprocal space;</li>\n<li><tt>DirectGrid</tt> and <tt>ReciprocalGrid</tt> classes, which are derived from <tt>DirectCell</tt> and <tt>ReciprocalCell</tt> and provide space discretization;</li>\n<li><tt>DirectField</tt> and <tt>ReciprocalField</tt>, classes to represent a scalar (such as an electron density or a potential) and/or vector fields associated to either a <tt>DirectGrid</tt> or a <tt>ReciprocalGrid</tt>;</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h2>Installation</h2>\n<p>Install <tt>pbcpy</tt> through <tt>PyPI</tt></p>\n<pre>pip install pbcpy\n</pre>\n<p>Install the dev version from <tt>gitlab</tt></p>\n<pre>git clone git@gitlab.com:ales.genova/pbcpy.git\n</pre>\n<p>NOTE: <tt>pbcpy</tt> is in the early stages of development, classes and APIs are bound to be changed without prior notice.</p>\n</div>\n<div id=\"id4\">\n<h2><tt>DirectCell</tt> and <tt>ReciprocalCell</tt> class</h2>\n<p>A unit cell is defined by its lattice vectors. To create a <tt>DirectCell</tt> object we need to provide it a <tt>3x3</tt> matrix containing the lattice vectors (as columns).\n<tt>pbcpy</tt> expects atomic units, a flexible units system might be addedd in the future.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pbcpy.base</span> <span class=\"kn\">import</span> <span class=\"n\">DirectCell</span><span class=\"p\">,</span> <span class=\"n\">ReciprocalCell</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">lattice</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">identity</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">10</span> <span class=\"c1\"># Make sure that at1 is of type numpy array.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cell1</span> <span class=\"o\">=</span> <span class=\"n\">DirectCell</span><span class=\"p\">(</span><span class=\"n\">lattice</span><span class=\"o\">=</span><span class=\"n\">lattice</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"c1\"># 10 Bohr cubic cell</span>\n</pre>\n<div id=\"directcell-and-reciprocalcell-properties\">\n<h3><tt>DirectCell</tt> and <tt>ReciprocalCell</tt> properties</h3>\n<ul>\n<li><tt>lattice</tt> : the lattice vectors (as columns)</li>\n<li><tt>volume</tt> : the volume of the cell</li>\n<li><tt>origin</tt> : the origin of the Cartesian reference frame</li>\n</ul>\n<pre><span class=\"c1\"># the lattice</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cell1</span><span class=\"o\">.</span><span class=\"n\">lattice</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">10.</span><span class=\"p\">,</span>   <span class=\"mf\">0.</span><span class=\"p\">,</span>   <span class=\"mf\">0.</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span>  <span class=\"mf\">0.</span><span class=\"p\">,</span>  <span class=\"mf\">10.</span><span class=\"p\">,</span>   <span class=\"mf\">0.</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span>  <span class=\"mf\">0.</span><span class=\"p\">,</span>   <span class=\"mf\">0.</span><span class=\"p\">,</span>  <span class=\"mf\">10.</span><span class=\"p\">]])</span>\n\n<span class=\"c1\"># the volume</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cell1</span><span class=\"o\">.</span><span class=\"n\">volume</span>\n<span class=\"mf\">1000.0</span>\n</pre>\n</div>\n<div id=\"directcell-and-reciprocalcell-methods\">\n<h3><tt>DirectCell</tt> and <tt>ReciprocalCell</tt> methods</h3>\n<ul>\n<li><tt>==</tt> operator : compare two <tt>Cell</tt> objects</li>\n<li><tt>get_reciprocal</tt>: returns a new <tt>ReciprocalCell</tt> object that is the \u201creciprocal\u201d cell of self (if self is a <tt>DirectCell</tt>)</li>\n<li><tt>get_direct</tt>: returns a new <tt>DirectCell</tt> object that is the \u201cdirect\u201d cell of self (if self is a <tt>ReciprocalCell</tt>)</li>\n</ul>\n<p>Note, by default the physics convention is used when converting between direct and reciprocal lattice:</p>\n<pre>\\big[\\text{reciprocal.lattice}\\big]^T = 2\\pi \\cdot \\big[\\text{direct.lattice}\\big]^{-1}\n</pre>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reciprocal_cell1</span> <span class=\"o\">=</span> <span class=\"n\">cell1</span><span class=\"o\">.</span><span class=\"n\">get_reciprocal</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">reciprocal_cell1</span><span class=\"o\">.</span><span class=\"n\">lattice</span><span class=\"p\">)</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">0.62831853</span><span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.62831853</span><span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.62831853</span><span class=\"p\">]])</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cell2</span> <span class=\"o\">=</span> <span class=\"n\">reciprocal_cell1</span><span class=\"o\">.</span><span class=\"n\">get_direct</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">cell2</span><span class=\"o\">.</span><span class=\"n\">lattice</span><span class=\"p\">)</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">10.</span><span class=\"p\">,</span>  <span class=\"mf\">0.</span><span class=\"p\">,</span>  <span class=\"mf\">0.</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"mf\">0.</span><span class=\"p\">,</span>  <span class=\"mf\">10.</span><span class=\"p\">,</span>  <span class=\"mf\">0.</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span> <span class=\"mf\">0.</span><span class=\"p\">,</span>  <span class=\"mf\">0.</span><span class=\"p\">,</span>  <span class=\"mf\">10.</span><span class=\"p\">]])</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">cell1</span> <span class=\"o\">==</span> <span class=\"n\">cell2</span>\n<span class=\"kc\">True</span>\n</pre>\n</div>\n</div>\n<div id=\"id5\">\n<h2><tt>Coord</tt> class</h2>\n<p><tt>Coord</tt> is a <tt>numpy.array</tt> derived class, with some additional attributes and methods.\nCoordinates in a periodic system are meaningless without the reference unit cell, this is why a <tt>Coord</tt> object also has an embedded <tt>DirectCell</tt> attribute.\nAlso, coordinates can be either expressed in either a <tt>\"Cartesian\"</tt> or <tt>\"Crystal\"</tt> basis.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pbcpy.base</span> <span class=\"kn\">import</span> <span class=\"n\">Coord</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos1</span> <span class=\"o\">=</span> <span class=\"n\">Coord</span><span class=\"p\">(</span><span class=\"n\">pos</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span><span class=\"mf\">0.6</span><span class=\"p\">,</span><span class=\"mf\">0.3</span><span class=\"p\">],</span> <span class=\"n\">cell</span><span class=\"o\">=</span><span class=\"n\">cell1</span><span class=\"p\">,</span> <span class=\"n\">ctype</span><span class=\"o\">=</span><span class=\"s2\">\"Cartesian\"</span><span class=\"p\">)</span>\n</pre>\n<div id=\"coord-attributes\">\n<h3><tt>Coord</tt> attributes</h3>\n<ul>\n<li><tt>basis</tt> : the coordinate type: <tt>'Cartesian'</tt> or <tt>'Crystal'</tt>.</li>\n<li><tt>cell</tt> : the <tt>DirectCell</tt> object associated to the coordinates.</li>\n</ul>\n<pre><span class=\"c1\"># the coordinate type (Cartesian or Crystal)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos1</span><span class=\"o\">.</span><span class=\"n\">basis</span>\n<span class=\"s1\">'Cartesian'</span>\n\n<span class=\"c1\"># the cell attribute is a Cell object</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">pos1</span><span class=\"o\">.</span><span class=\"n\">cell</span><span class=\"p\">)</span>\n<span class=\"n\">pbcpy</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">DirectCell</span>\n</pre>\n</div>\n<div id=\"coord-methods\">\n<h3><tt>Coord</tt> methods</h3>\n<ul>\n<li><tt>to_crys()</tt>, <tt>to_cart()</tt> : convert <tt>self</tt> to crystal or cartesian basis (returns a new <tt>Coord</tt> object).</li>\n<li><tt>d_mic(other)</tt> : Calculate the vector connecting two coordinates (from self to other), using the minimum image convention (MIC). The result is itself a <tt>Coord</tt> object.</li>\n<li><tt>dd_mic(other)</tt> : Calculate the distance between two coordinates, using the MIC.</li>\n<li><tt>+</tt>/<tt>-</tt> operators : Calculate the difference/sum between two coordinates without using the MIC. <tt>basis</tt> conversions are automatically performed when needed. The result is itself a <tt>Coord</tt> object.</li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos1</span> <span class=\"o\">=</span> <span class=\"n\">Coord</span><span class=\"p\">(</span><span class=\"n\">pos</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">0.5</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">1.0</span><span class=\"p\">],</span> <span class=\"n\">cell</span><span class=\"o\">=</span><span class=\"n\">cell1</span><span class=\"p\">,</span> <span class=\"n\">ctype</span><span class=\"o\">=</span><span class=\"s2\">\"Crystal\"</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos2</span> <span class=\"o\">=</span> <span class=\"n\">Coord</span><span class=\"p\">(</span><span class=\"n\">pos</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">0.6</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">,</span><span class=\"mf\">3.0</span><span class=\"p\">],</span> <span class=\"n\">cell</span><span class=\"o\">=</span><span class=\"n\">cell1</span><span class=\"p\">,</span> <span class=\"n\">ctype</span><span class=\"o\">=</span><span class=\"s2\">\"Crystal\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># convert to Crystal or Cartesian (returns new object)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos1</span><span class=\"o\">.</span><span class=\"n\">to_cart</span><span class=\"p\">()</span>\n<span class=\"n\">Coord</span><span class=\"p\">([</span>  <span class=\"mf\">5.</span><span class=\"p\">,</span>   <span class=\"mf\">0.</span><span class=\"p\">,</span>  <span class=\"mf\">10.</span><span class=\"p\">])</span> <span class=\"c1\"># the coordinate was already Cartesian, the result is still correct.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos1</span><span class=\"o\">.</span><span class=\"n\">to_crys</span><span class=\"p\">()</span>\n<span class=\"n\">Coord</span><span class=\"p\">([</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">1.</span> <span class=\"p\">])</span> <span class=\"c1\"># the coordinate was already Crystal, the result is still correct.</span>\n\n<span class=\"c1\">## vector connecting two coordinates (using the minimum image convention), and distance</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos1</span><span class=\"o\">.</span><span class=\"n\">d_mic</span><span class=\"p\">(</span><span class=\"n\">pos2</span><span class=\"p\">)</span>\n<span class=\"n\">Coord</span><span class=\"p\">([</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos1</span><span class=\"o\">.</span><span class=\"n\">dd_mic</span><span class=\"p\">(</span><span class=\"n\">pos2</span><span class=\"p\">)</span>\n<span class=\"mf\">0.99999999999999978</span>\n\n<span class=\"c1\">## vector connecting two coordinates (without using the minimum image convention) and distance</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">pos2</span> <span class=\"o\">-</span> <span class=\"n\">pos1</span>\n<span class=\"n\">Coord</span><span class=\"p\">([</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.</span> <span class=\"p\">,</span>  <span class=\"mf\">2.</span> <span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"n\">pos2</span> <span class=\"o\">-</span> <span class=\"n\">pos1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">length</span><span class=\"p\">()</span>\n<span class=\"mf\">22.383029285599392</span>\n</pre>\n</div>\n</div>\n<div id=\"directgrid-and-reciprocalgrid-classes\">\n<h2><tt>DirectGrid</tt> and <tt>ReciprocalGrid</tt> classes</h2>\n<p><tt>DirectGrid</tt> and <tt>ReciprocalGrid</tt> are subclasses of <tt>DirectGrid</tt> and <tt>ReciprocalGrid</tt> respectively. <tt>Grid</tt>s inherit all the attributes and methods of their respective <tt>Cell</tt>s, and have a few of their own to deal with quantities represented on a equally spaced grid.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pbcpy.grid</span> <span class=\"kn\">import</span> <span class=\"n\">DirectGrid</span>\n<span class=\"c1\"># A 10x10x10 Bohr Grid, with 100x100x100 gridpoints</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">lattice</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">identity</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">10</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid1</span> <span class=\"o\">=</span> <span class=\"n\">DirectGrid</span><span class=\"p\">(</span><span class=\"n\">lattice</span><span class=\"o\">=</span><span class=\"n\">lattice</span><span class=\"p\">,</span> <span class=\"n\">nr</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">],</span> <span class=\"n\">origin</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n</pre>\n<div id=\"grid-attributes\">\n<h3><tt>Grid</tt> attributes</h3>\n<ul>\n<li>All the attributes inherited from <tt>Cell</tt></li>\n<li><tt>dV</tt> : the volume of a single point, useful when calculating integral quantities</li>\n<li><tt>nr</tt> : array, number of grid point for each direction</li>\n<li><tt>nnr</tt> : total number of points in the grid</li>\n<li><tt>r</tt> : cartesian coordinates at each grid point. A rank 3 array of type <tt>Coord</tt> (<tt>DirectGrid</tt> only)</li>\n<li><tt>s</tt> : crystal coordinates at each grid point. A rank 3 array of type <tt>Coord</tt> (<tt>DirectGrid</tt> only)</li>\n<li><tt>g</tt> : G vector at each grid point (<tt>ReciprocalGrid</tt> only)</li>\n<li><tt>gg</tt> : Square of G vector at each grid point (<tt>ReciprocalGrid</tt> only)</li>\n</ul>\n<pre><span class=\"c1\"># The volume of each point</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">dV</span>\n<span class=\"mf\">0.001</span>\n\n<span class=\"c1\"># Grid points for each direction</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">nr</span>\n<span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Total number of grid points</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">nnr</span>\n<span class=\"mi\">1000000</span>\n\n<span class=\"c1\"># Cartesian coordinates at each grid point</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">r</span>\n<span class=\"n\">Coord</span><span class=\"p\">([[[[</span> <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.1</span><span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.2</span><span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">0.3</span><span class=\"p\">],</span>\n                        <span class=\"o\">...</span><span class=\"p\">]]])</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">r</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">49</span><span class=\"p\">,</span><span class=\"mi\">99</span><span class=\"p\">]</span>\n<span class=\"n\">Coord</span><span class=\"p\">([</span> <span class=\"mf\">0.</span> <span class=\"p\">,</span>  <span class=\"mf\">4.9</span><span class=\"p\">,</span>  <span class=\"mf\">9.9</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Crystal coordinates at each grid point</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">s</span>\n<span class=\"n\">Coord</span><span class=\"p\">([[[[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">],</span>\n     <span class=\"p\">[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.01</span><span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.02</span><span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.03</span><span class=\"p\">],</span>\n              <span class=\"o\">...</span><span class=\"p\">]]]])</span>\n\n<span class=\"c1\"># Since DirectGrid inherits from DirectCell, we can still use the get_reciprocal methos</span>\n<span class=\"n\">reciprocal_grid1</span> <span class=\"o\">=</span> <span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">get_reciprocal</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># reciprocal_grid1 is an instance of ReciprocalGrid</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reciprocal_grid1</span><span class=\"o\">.</span><span class=\"n\">g</span>\n<span class=\"n\">array</span><span class=\"p\">([[[[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.01</span><span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.02</span><span class=\"p\">],</span>\n         <span class=\"o\">...</span><span class=\"p\">,</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.03</span><span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.02</span><span class=\"p\">],</span>\n         <span class=\"p\">[</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span>  <span class=\"mf\">0.</span>  <span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.01</span><span class=\"p\">]],</span>\n                   <span class=\"o\">...</span><span class=\"p\">]]])</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reciprocal_grid1</span><span class=\"o\">.</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reciprocal_grid1</span><span class=\"o\">.</span><span class=\"n\">gg</span>\n<span class=\"n\">array</span><span class=\"p\">([[[</span> <span class=\"mf\">0.</span>    <span class=\"p\">,</span>  <span class=\"mf\">0.0001</span><span class=\"p\">,</span>  <span class=\"mf\">0.0004</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.0009</span><span class=\"p\">,</span>  <span class=\"mf\">0.0004</span><span class=\"p\">,</span>  <span class=\"mf\">0.0001</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span> <span class=\"mf\">0.0001</span><span class=\"p\">,</span>  <span class=\"mf\">0.0002</span><span class=\"p\">,</span>  <span class=\"mf\">0.0005</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.001</span> <span class=\"p\">,</span>  <span class=\"mf\">0.0005</span><span class=\"p\">,</span>  <span class=\"mf\">0.0002</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span> <span class=\"mf\">0.0004</span><span class=\"p\">,</span>  <span class=\"mf\">0.0005</span><span class=\"p\">,</span>  <span class=\"mf\">0.0008</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.0013</span><span class=\"p\">,</span>  <span class=\"mf\">0.0008</span><span class=\"p\">,</span>  <span class=\"mf\">0.0005</span><span class=\"p\">],</span>\n        <span class=\"o\">...</span><span class=\"p\">,</span>\n        <span class=\"p\">[</span> <span class=\"mf\">0.0009</span><span class=\"p\">,</span>  <span class=\"mf\">0.001</span> <span class=\"p\">,</span>  <span class=\"mf\">0.0013</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.0018</span><span class=\"p\">,</span>  <span class=\"mf\">0.0013</span><span class=\"p\">,</span>  <span class=\"mf\">0.001</span> <span class=\"p\">],</span>\n        <span class=\"p\">[</span> <span class=\"mf\">0.0004</span><span class=\"p\">,</span>  <span class=\"mf\">0.0005</span><span class=\"p\">,</span>  <span class=\"mf\">0.0008</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.0013</span><span class=\"p\">,</span>  <span class=\"mf\">0.0008</span><span class=\"p\">,</span>  <span class=\"mf\">0.0005</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span> <span class=\"mf\">0.0001</span><span class=\"p\">,</span>  <span class=\"mf\">0.0002</span><span class=\"p\">,</span>  <span class=\"mf\">0.0005</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.001</span> <span class=\"p\">,</span>  <span class=\"mf\">0.0005</span><span class=\"p\">,</span>  <span class=\"mf\">0.0002</span><span class=\"p\">]],</span>\n        <span class=\"o\">...</span><span class=\"p\">,</span>\n                                                                  <span class=\"p\">]])</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">reciprocal_grid1</span><span class=\"o\">.</span><span class=\"n\">gg</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"id6\">\n<h2><tt>DirectField</tt> and <tt>ReciprocalField</tt> class</h2>\n<p>The <tt>DirectField</tt> and <tt>ReciprocalField</tt> classes represent a scalar field on a <tt>DirectGrid</tt> and <tt>ReciprocalGrid</tt> respectively. These classes are extensions of the <tt>numpy.ndarray</tt>.</p>\n<p>Operations such as interpolations, fft and invfft, and taking arbitrary 1D/2D/3D cuts are made very easy.</p>\n<p>A <tt>DirectField</tt> can be generated directly from Quantum Espresso postprocessing <tt>.pp</tt> files (see below).</p>\n<pre><span class=\"c1\"># A DirectField example</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pbcpy.field</span> <span class=\"kn\">import</span> <span class=\"n\">DirectField</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">griddata</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"o\">=</span><span class=\"n\">grid1</span><span class=\"o\">.</span><span class=\"n\">nr</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">field1</span> <span class=\"o\">=</span> <span class=\"n\">DirectField</span><span class=\"p\">(</span><span class=\"n\">grid</span><span class=\"o\">=</span><span class=\"n\">grid1</span><span class=\"p\">,</span> <span class=\"n\">griddata_3d</span><span class=\"o\">=</span><span class=\"n\">griddata</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># When importing a Quantum Espresso .pp files a DirectField object is created</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pbcpy.formats.qepp</span> <span class=\"kn\">import</span> <span class=\"n\">PP</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">water_dimer</span> <span class=\"o\">=</span> <span class=\"n\">PP</span><span class=\"p\">(</span><span class=\"n\">filepp</span><span class=\"o\">=</span><span class=\"s2\">\"/path/to/density.pp\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho</span> <span class=\"o\">=</span> <span class=\"n\">water_dimer</span><span class=\"o\">.</span><span class=\"n\">field</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">rho</span><span class=\"p\">)</span>\n<span class=\"n\">pbcpy</span><span class=\"o\">.</span><span class=\"n\">field</span><span class=\"o\">.</span><span class=\"n\">DirectField</span>\n</pre>\n<div id=\"directfield-attributes\">\n<h3><tt>DirectField</tt> attributes</h3>\n<ul>\n<li><tt>grid</tt> : Represent the grid associated to the field (it\u2019s a <tt>DirectGrid</tt> or <tt>ReciprocalGrid</tt> object)</li>\n<li><tt>span</tt> : The number of dimensions of the grid for which the number of points is larger than 1</li>\n<li><tt>rank</tt> : The number of dimensions of the quantity at each grid point<ul>\n<li><tt>1</tt> : scalar field (e.g. the rank of rho is <tt>1</tt>)</li>\n<li><tt>&gt;1</tt> : vector field (e.g. the rank of the gradient of rho is <tt>3</tt>)</li>\n</ul>\n</li>\n</ul>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">grid</span><span class=\"p\">)</span>\n<span class=\"n\">pbcpy</span><span class=\"o\">.</span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">DirectGrid</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">span</span>\n<span class=\"mi\">3</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">rank</span>\n<span class=\"mi\">1</span>\n<span class=\"c1\"># the density is a scalar field</span>\n</pre>\n</div>\n<div id=\"directfield-methods\">\n<h3><tt>DirectField</tt> methods</h3>\n<ul>\n<li>Any method inherited from <tt>numpy.array</tt>.</li>\n<li><tt>integral</tt> : returns the integral of the field.</li>\n<li><tt>get_3dinterpolation</tt> : Interpolates the data to a different grid (returns a new <tt>DirectField</tt> object). 3rd order spline interpolation.</li>\n<li><tt>get_cut(r0, [r1], [r2], [origin], [center], [nr])</tt> : Get 1D/2D/3D cuts of the scalar field, by providing arbitraty vectors and an origin/center.</li>\n<li><tt>fft</tt> : Calculates the Fourier transform of self, and returns an instance of <tt>ReciprocalField</tt>, which contains the appropriate <tt>ReciprocalGrid</tt></li>\n</ul>\n<pre><span class=\"c1\"># Integrate the field over the whole grid</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">integral</span><span class=\"p\">()</span>\n<span class=\"mf\">16.000000002898673</span> <span class=\"c1\"># the electron density of a water dimer has 16 valence electrons as expected</span>\n\n<span class=\"c1\"># Interpolate the scalar field from one grid to another</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">125</span><span class=\"p\">,</span> <span class=\"mi\">125</span><span class=\"p\">,</span> <span class=\"mi\">125</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho_interp</span> <span class=\"o\">=</span> <span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">get_3dinterpolation</span><span class=\"p\">([</span><span class=\"mi\">90</span><span class=\"p\">,</span><span class=\"mi\">90</span><span class=\"p\">,</span><span class=\"mi\">90</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho_interp</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;</span> <span class=\"n\">rho_interp</span><span class=\"o\">.</span><span class=\"n\">integral</span><span class=\"p\">()</span>\n<span class=\"mf\">15.999915251442873</span>\n\n\n<span class=\"c1\"># Get arbitrary cuts of the scalar field.</span>\n<span class=\"c1\"># In this example get the cut of the electron density in the plane of the water molecule</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ppfile</span> <span class=\"o\">=</span> <span class=\"s2\">\"/path/to/density.pp\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">water_dimer</span> <span class=\"o\">=</span> <span class=\"n\">PP</span><span class=\"p\">(</span><span class=\"n\">ppfile</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">o_pos</span> <span class=\"o\">=</span> <span class=\"n\">water_dimer</span><span class=\"o\">.</span><span class=\"n\">ions</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pos</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">h1_pos</span> <span class=\"o\">=</span> <span class=\"n\">water_dimer</span><span class=\"o\">.</span><span class=\"n\">ions</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pos</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">h2_pos</span> <span class=\"o\">=</span> <span class=\"n\">water_dimer</span><span class=\"o\">.</span><span class=\"n\">ions</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">pos</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho_cut</span> <span class=\"o\">=</span> <span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">get_cut</span><span class=\"p\">(</span><span class=\"n\">r0</span><span class=\"o\">=</span><span class=\"n\">o_h1_vec</span><span class=\"o\">*</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">r1</span><span class=\"o\">=</span><span class=\"n\">o_h2_vec</span><span class=\"o\">*</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">center</span><span class=\"o\">=</span><span class=\"n\">o_pos</span><span class=\"p\">,</span> <span class=\"n\">nr</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># plot_cut is itself a DirectField instance, and it can be either exported to an xsf file (see next session)</span>\n<span class=\"c1\"># or its values can be analized/manipulated in place.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho_cut</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho_cut</span><span class=\"o\">.</span><span class=\"n\">span</span>\n<span class=\"mi\">2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho_cut</span><span class=\"o\">.</span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">lattice</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">1.57225214</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">6.68207161</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.43149218</span><span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">1.75366585</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">3.04623853</span><span class=\"p\">,</span>  <span class=\"mf\">0.8479004</span> <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">7.02978121</span><span class=\"p\">,</span>  <span class=\"mf\">0.97509868</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.30802502</span><span class=\"p\">]])</span>\n\n<span class=\"c1\"># plot_cut is itself a Grid_Function_Base instance, and it can be either exported to an xsf file (see next session)</span>\n<span class=\"c1\"># or its values can be analized/manipulated in place.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">plot_cut</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Fourier transform of the DirectField</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho_g</span> <span class=\"o\">=</span> <span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">fft</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">rho_g</span><span class=\"p\">)</span>\n<span class=\"n\">pbcpy</span><span class=\"o\">.</span><span class=\"n\">field</span><span class=\"o\">.</span><span class=\"n\">ReciprocalField</span>\n</pre>\n</div>\n<div id=\"reciprocalfield-methods\">\n<h3><tt>ReciprocalField</tt> methods</h3>\n<ul>\n<li><tt>ifft</tt> : Calculates the inverse Fourier transform of self, and returns an instance of <tt>DirectField</tt>, which contains the appropriate <tt>DirectGrid</tt></li>\n</ul>\n<pre><span class=\"c1\"># inv fft:</span>\n<span class=\"c1\"># recall that rho_g = fft(rho)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho1</span> <span class=\"o\">=</span> <span class=\"n\">rho_g</span><span class=\"o\">.</span><span class=\"n\">ifft</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">rho1</span><span class=\"p\">)</span>\n<span class=\"n\">pbcpy</span><span class=\"o\">.</span><span class=\"n\">field</span><span class=\"o\">.</span><span class=\"n\">DirectField</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rho1</span><span class=\"o\">.</span><span class=\"n\">grid</span> <span class=\"o\">==</span> <span class=\"n\">rho</span><span class=\"o\">.</span><span class=\"n\">grid</span>\n<span class=\"kc\">True</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">isclose</span><span class=\"p\">(</span><span class=\"n\">rho1</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">()</span>\n<span class=\"kc\">True</span>\n<span class=\"c1\"># as expected ifft(fft(rho)) = rho</span>\n</pre>\n</div>\n</div>\n<div id=\"id7\">\n<h2><tt>System</tt> class</h2>\n<p><tt>System</tt> is simply a class containing a <tt>DirectCell</tt> (or <tt>DirectGrid</tt>), a set of atoms <tt>ions</tt>, and a <tt>DirectField</tt></p>\n<div id=\"system-attributes\">\n<h3><tt>System</tt> attributes</h3>\n<ul>\n<li><tt>name</tt> : arbitrary name</li>\n<li><tt>ions</tt> : collection of atoms and their coordinates</li>\n<li><tt>cell</tt> : the unit cell of the system (<tt>DirectCell</tt> or <tt>DirectGrid</tt>)</li>\n<li><tt>field</tt> : an optional <tt>DirectField</tt> object.</li>\n</ul>\n</div>\n</div>\n<div id=\"id8\">\n<h2><tt>pbcarray</tt> class</h2>\n<p><tt>pbcarray</tt> is a sublass of <tt>numpy.ndarray</tt>, and is suitable to represent periodic quantities, by including robust wrapping capabilities.\n<tt>pbcarray</tt> can be of any rank, and it can be freely sliced.</p>\n<pre><span class=\"c1\"># 1D example, but it is valid for any rank.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pbcpy.base</span> <span class=\"kn\">import</span> <span class=\"n\">pbcarray</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span>  <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"p\">,</span> <span class=\"n\">endpoint</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">y_pbc</span> <span class=\"o\">=</span> <span class=\"n\">pbcarray</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">y_pbc</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,)</span>                          <span class=\"c1\"># y_pbc only has 100 elements, but we can freely do operations such as:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">y_pbc</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">100</span><span class=\"p\">:</span><span class=\"mi\">200</span><span class=\"p\">])</span>   <span class=\"c1\"># and get the expected result</span>\n</pre>\n</div>\n<div id=\"id9\">\n<h2>File Formats</h2>\n<div id=\"pp-class\">\n<h3><tt>PP</tt> class</h3>\n<p><tt>pbcpy</tt> can read a Quantum Espresso post-processing <tt>.pp</tt> file into a <tt>System</tt> object.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">water_dimer</span> <span class=\"o\">=</span> <span class=\"n\">PP</span><span class=\"p\">(</span><span class=\"n\">filepp</span><span class=\"o\">=</span><span class=\"s1\">'/path/to/density.pp'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n<span class=\"c1\"># the output of PP.read() is a System object.</span>\n</pre>\n</div>\n<div id=\"xsf-class\">\n<h3><tt>XSF</tt> class</h3>\n<p><tt>pbcpy</tt> can write a <tt>System</tt> object into a XCrySDen  <tt>.xsf</tt> file.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">XSF</span><span class=\"p\">(</span><span class=\"n\">filexsf</span><span class=\"o\">=</span><span class=\"s1\">'/path/to/output.xsf'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"o\">=</span><span class=\"n\">water_dimer</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># an optional field parameter can be passed to XSF.write() in order to override the DirectField in system.</span>\n<span class=\"c1\"># This is especially useful if one wants to output one system and an arbitrary cut of the grid,</span>\n<span class=\"c1\"># such as the one we generated earlier</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">XSF</span><span class=\"p\">(</span><span class=\"n\">filexsf</span><span class=\"o\">=</span><span class=\"s1\">'/path/to/output.xsf'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"o\">=</span><span class=\"n\">water_dimer</span><span class=\"p\">,</span> <span class=\"n\">field</span><span class=\"o\">=</span><span class=\"n\">rho_cut</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3603906, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "d3a1e1c984abe74e150c54cf23340b7a", "sha256": "f15d3ffbc33bdebf9b806d4cebf00233e5e9ffa4b1c05322d1af65ba9265d158"}, "downloads": -1, "filename": "pbcpy-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d3a1e1c984abe74e150c54cf23340b7a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14093, "upload_time": "2017-02-14T00:05:59", "upload_time_iso_8601": "2017-02-14T00:05:59.959671Z", "url": "https://files.pythonhosted.org/packages/0f/08/3db141a34c41a517beff26e4e47d3eda000a5bcaf3a880face30373bb89e/pbcpy-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "56866d0147d558e0460b0f68cb561d6a", "sha256": "4a45c94ad94762389981a9aaa6e263e9493684ca4432b5c5c2b1f6af077c265c"}, "downloads": -1, "filename": "pbcpy-0.1.0.tar.gz", "has_sig": false, "md5_digest": "56866d0147d558e0460b0f68cb561d6a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11296, "upload_time": "2017-02-14T00:06:00", "upload_time_iso_8601": "2017-02-14T00:06:00.804267Z", "url": "https://files.pythonhosted.org/packages/aa/4b/cb316185b777d7b5e25fa326d2ef8d68211a5169b574965e074b9c3ca033/pbcpy-0.1.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "fb613c673a3919cc04e2d8a2fb459cf9", "sha256": "10d52e73a2a609a455fe963d1ced4a805253f08f8395a2f0b6b7eb2a89cf9a9f"}, "downloads": -1, "filename": "pbcpy-0.2.1.tar.gz", "has_sig": false, "md5_digest": "fb613c673a3919cc04e2d8a2fb459cf9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15426, "upload_time": "2018-02-19T04:09:29", "upload_time_iso_8601": "2018-02-19T04:09:29.941323Z", "url": "https://files.pythonhosted.org/packages/84/94/1f3253ae7d50ff43778ffd5d3c805c8d36c43898fe17331c1a6a5a10f3bb/pbcpy-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "cc1c740f2ccff4304d5556b303b52351", "sha256": "a607fbd3109496df96800df3fd43a7c99137afac041b7c33d1ee5db4290c41f8"}, "downloads": -1, "filename": "pbcpy-0.2.2.tar.gz", "has_sig": false, "md5_digest": "cc1c740f2ccff4304d5556b303b52351", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24118, "upload_time": "2018-02-20T18:24:21", "upload_time_iso_8601": "2018-02-20T18:24:21.448127Z", "url": "https://files.pythonhosted.org/packages/74/7a/7c40f25c474554e6b195ec06af2ef79c7c5461dec9861103baf73593fde1/pbcpy-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "28e4d67c23ded70fd2b21768d292864a", "sha256": "e951e33745c285e7ae05ef1b22fa0b587d54ee0e9822bb472c87e15ccb172e5c"}, "downloads": -1, "filename": "pbcpy-0.2.3.tar.gz", "has_sig": false, "md5_digest": "28e4d67c23ded70fd2b21768d292864a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23953, "upload_time": "2018-02-21T17:12:52", "upload_time_iso_8601": "2018-02-21T17:12:52.993608Z", "url": "https://files.pythonhosted.org/packages/c3/12/c5a4a48a1c90bf6d71d846337f41d8688c236165a987398c4926aad2429f/pbcpy-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "ee4c090a00c70221deca7857f1cfac5a", "sha256": "b9f454a5ce7cbc5e775548daa2d4c1735c9879ad42fa998b9deefc1fff42ea30"}, "downloads": -1, "filename": "pbcpy-0.2.4.tar.gz", "has_sig": false, "md5_digest": "ee4c090a00c70221deca7857f1cfac5a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24533, "upload_time": "2018-02-21T17:20:34", "upload_time_iso_8601": "2018-02-21T17:20:34.357357Z", "url": "https://files.pythonhosted.org/packages/a1/14/15c033140cfeb47b305df68d7da32c9845ea82fd6f6aedb70acc0b3e7941/pbcpy-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "b6faacaa0f143b6eefe48f1b83a56999", "sha256": "ae2024c5e1f493bb33dc49ca6613051b127e8755225245752fa3c164bf960b18"}, "downloads": -1, "filename": "pbcpy-0.2.5.tar.gz", "has_sig": false, "md5_digest": "b6faacaa0f143b6eefe48f1b83a56999", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24291, "upload_time": "2018-02-21T20:07:16", "upload_time_iso_8601": "2018-02-21T20:07:16.082407Z", "url": "https://files.pythonhosted.org/packages/9d/94/ec16079f2d9ca4deb6ae0a1371894e872dd390a2a8882d039109ea3cbee5/pbcpy-0.2.5.tar.gz", "yanked": false}], "0.2.6": [{"comment_text": "", "digests": {"md5": "15604dfe746922f2c66a4ad767f97e08", "sha256": "4c7c6e01cc079775d23efe6cf6d1464d6adc56a7e5e2ffd1396d881e78f59d4a"}, "downloads": -1, "filename": "pbcpy-0.2.6.tar.gz", "has_sig": false, "md5_digest": "15604dfe746922f2c66a4ad767f97e08", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26058, "upload_time": "2018-02-21T20:41:54", "upload_time_iso_8601": "2018-02-21T20:41:54.021194Z", "url": "https://files.pythonhosted.org/packages/79/e5/8aedd33c906f4da98a54fded1c61a2677eae5407cea00a6bc7fc059cc29c/pbcpy-0.2.6.tar.gz", "yanked": false}], "0.2.7": [{"comment_text": "", "digests": {"md5": "c061838c0bbe619e014d1fbf9431b459", "sha256": "78d53b63f573aab7cb88171c3323b55cb873b51b084d0fd17a5b298ff916504f"}, "downloads": -1, "filename": "pbcpy-0.2.7.tar.gz", "has_sig": false, "md5_digest": "c061838c0bbe619e014d1fbf9431b459", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26640, "upload_time": "2018-02-22T01:12:20", "upload_time_iso_8601": "2018-02-22T01:12:20.438578Z", "url": "https://files.pythonhosted.org/packages/19/5a/8f868af17aaf4d4862769bc319c53eb3fda318ac353c173ac55b4f8612ce/pbcpy-0.2.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c061838c0bbe619e014d1fbf9431b459", "sha256": "78d53b63f573aab7cb88171c3323b55cb873b51b084d0fd17a5b298ff916504f"}, "downloads": -1, "filename": "pbcpy-0.2.7.tar.gz", "has_sig": false, "md5_digest": "c061838c0bbe619e014d1fbf9431b459", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26640, "upload_time": "2018-02-22T01:12:20", "upload_time_iso_8601": "2018-02-22T01:12:20.438578Z", "url": "https://files.pythonhosted.org/packages/19/5a/8f868af17aaf4d4862769bc319c53eb3fda318ac353c173ac55b4f8612ce/pbcpy-0.2.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:37 2020"}