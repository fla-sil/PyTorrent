{"info": {"author": "Guillaume Coffin", "author_email": "guill.coffin@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "======\npypama\n======\n\nHow to install\n--------------\n\n``pip install pypama``\n\nPresentation\n------------\n\nThis package provides a pattern matching for list of objects. Just as Regex provides regular expression for\nstrings, this package provides regular expression for other type of lists.\n\nAn example is worth a thousand words: assume you have a list\n\n>>> example_list = ['a', 'a', 1, '', None, 'b', 'c',  'e']\n\nFor some reason, you know that there is an int and a None, and you\nwant to extract that number and the 2 strings following the None\n\n>>> from pypama import build_pattern, is_int, is_none\n>>> g = build_pattern((~is_int).star(False), '(', is_int, ')', '.*', is_none, '(',ANY,ANY, ')')\n>>> g.match(example_list).groups()\n[[1], ['b', 'c']]\n\n\n\n- ``~is_int`` will matching anything that's not an integer\n- ``.star(False)``: equivalent to ``*?`` in regular expressions: repeat as many as necessary\n- parenthesis are for capturing groups\n- ``.*`` is short for ``ANY.star()`` (match anything, repeatedly)\n  \nTherefore the pattern above reads as follow: match anything that's not an int, repeatedly, \nuntil you find an int that you capture in group 1. Then match anything until you\nfind a None. That must be followed by two elements that you capture in group 2.\n  \nThis is therefore very similar to the ``re`` package, but applied to a list and with\nmatching that goes beyond strings.\n    \nUsage\n-----\n\n``build_pattern(*args, **functions)``\nwhere args is a list of strings or ``Pattern`` objects, and functions maps function names to executable.\n\nThe args can be a string or a list of strings containing:\n - ``<string>``: will match the string inside <>\n - callable unction: X will match if function(X) returns True\n - ``X?``: will be ignored or match X\n - ``X*``: will match if X matches repeatedly (greedy)\n - ``X*?``: will match if X matches repeatedly (non greedy)\n - ``(X)``: will capture the X in a group\n - ``(P<name>X)``: will capture X in a group named \"name\"\n - ``X|Y``: will match if X or Y matches\n - ``\\n``: will match the nth group previously matched\n - ``<r:X>``: will match if the word matches regexp X\n - ``<re:X>``: same as ``<r:X>``\n - ``<c:function>`` or ``<call:function>``: will match if function(X) matches. If function does not exist in the namespace of pypama, add the definition in the function call eg ``build_pattern('<c:foo>', foo=lambda x:x<2)`` will match [1]\n - ``.`` will match any item\n - ``$`` will match if at the end of the list\n - ``X{n}`` will match X exactly n times. n can be a list of integer\n - ``X!``: will match if the item doesn't match X (X must match exactly 1 element)\n\n\nBoth are equally valid and evaluate to the same result;\n - ``build_pattern('<hello>','<world>','.*')``\n - ``build_pattern('<hello><world>.*')``", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/gcoffin/pypama", "keywords": "", "license": "GPLv3", "maintainer": "", "maintainer_email": "", "name": "pypama", "package_url": "https://pypi.org/project/pypama/", "platform": "", "project_url": "https://pypi.org/project/pypama/", "project_urls": {"Homepage": "http://github.com/gcoffin/pypama"}, "release_url": "https://pypi.org/project/pypama/1.1/", "requires_dist": null, "requires_python": "", "summary": "Python Pattern Matching", "version": "1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"how-to-install\">\n<h2>How to install</h2>\n<p><tt>pip install pypama</tt></p>\n</div>\n<div id=\"presentation\">\n<h2>Presentation</h2>\n<p>This package provides a pattern matching for list of objects. Just as Regex provides regular expression for\nstrings, this package provides regular expression for other type of lists.</p>\n<p>An example is worth a thousand words: assume you have a list</p>\n<pre>&gt;&gt;&gt; example_list = ['a', 'a', 1, '', None, 'b', 'c',  'e']\n</pre>\n<p>For some reason, you know that there is an int and a None, and you\nwant to extract that number and the 2 strings following the None</p>\n<pre>&gt;&gt;&gt; from pypama import build_pattern, is_int, is_none\n&gt;&gt;&gt; g = build_pattern((~is_int).star(False), '(', is_int, ')', '.*', is_none, '(',ANY,ANY, ')')\n&gt;&gt;&gt; g.match(example_list).groups()\n[[1], ['b', 'c']]\n</pre>\n<ul>\n<li><tt>~is_int</tt> will matching anything that\u2019s not an integer</li>\n<li><tt>.star(False)</tt>: equivalent to <tt>*?</tt> in regular expressions: repeat as many as necessary</li>\n<li>parenthesis are for capturing groups</li>\n<li><tt>.*</tt> is short for <tt>ANY.star()</tt> (match anything, repeatedly)</li>\n</ul>\n<p>Therefore the pattern above reads as follow: match anything that\u2019s not an int, repeatedly,\nuntil you find an int that you capture in group 1. Then match anything until you\nfind a None. That must be followed by two elements that you capture in group 2.</p>\n<p>This is therefore very similar to the <tt>re</tt> package, but applied to a list and with\nmatching that goes beyond strings.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p><tt><span class=\"pre\">build_pattern(*args,</span> **functions)</tt>\nwhere args is a list of strings or <tt>Pattern</tt> objects, and functions maps function names to executable.</p>\n<dl>\n<dt>The args can be a string or a list of strings containing:</dt>\n<dd><ul>\n<li><tt>&lt;string&gt;</tt>: will match the string inside &lt;&gt;</li>\n<li>callable unction: X will match if function(X) returns True</li>\n<li><tt>X?</tt>: will be ignored or match X</li>\n<li><tt>X*</tt>: will match if X matches repeatedly (greedy)</li>\n<li><tt>X*?</tt>: will match if X matches repeatedly (non greedy)</li>\n<li><tt>(X)</tt>: will capture the X in a group</li>\n<li><tt>(P&lt;name&gt;X)</tt>: will capture X in a group named \u201cname\u201d</li>\n<li><tt>X|Y</tt>: will match if X or Y matches</li>\n<li><tt>\\n</tt>: will match the nth group previously matched</li>\n<li><tt>&lt;r:X&gt;</tt>: will match if the word matches regexp X</li>\n<li><tt>&lt;re:X&gt;</tt>: same as <tt>&lt;r:X&gt;</tt></li>\n<li><tt>&lt;c:function&gt;</tt> or <tt>&lt;call:function&gt;</tt>: will match if function(X) matches. If function does not exist in the namespace of pypama, add the definition in the function call eg <tt><span class=\"pre\">build_pattern('&lt;c:foo&gt;',</span> foo=lambda x:x&lt;2)</tt> will match [1]</li>\n<li><tt>.</tt> will match any item</li>\n<li><tt>$</tt> will match if at the end of the list</li>\n<li><tt>X{n}</tt> will match X exactly n times. n can be a list of integer</li>\n<li><tt>X!</tt>: will match if the item doesn\u2019t match X (X must match exactly 1 element)</li>\n</ul>\n</dd>\n<dt>Both are equally valid and evaluate to the same result;</dt>\n<dd><ul>\n<li><tt><span class=\"pre\">build_pattern('&lt;hello&gt;','&lt;world&gt;','.*')</span></tt></li>\n<li><tt><span class=\"pre\">build_pattern('&lt;hello&gt;&lt;world&gt;.*')</span></tt></li>\n</ul>\n</dd>\n</dl>\n</div>\n\n          </div>"}, "last_serial": 6562410, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "9431c3d6d6b126496a92b20b09c77cca", "sha256": "f93706e20493ea4356ead62e7eb616d2da17f9a0494c16630b9d858328d6d04f"}, "downloads": -1, "filename": "pypama-1.0.tar.gz", "has_sig": false, "md5_digest": "9431c3d6d6b126496a92b20b09c77cca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5431, "upload_time": "2020-01-17T08:23:08", "upload_time_iso_8601": "2020-01-17T08:23:08.969627Z", "url": "https://files.pythonhosted.org/packages/fb/08/6f5e1225fe73d136836e20127f8e3ca076138b718f2c87c6268ae659950a/pypama-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "7b3882de1b37d3f41814b38ee69bc80a", "sha256": "efe66ce774afd35add9b91fa1600716118d4c8ad44bf49ffc05053c0f97a3c6a"}, "downloads": -1, "filename": "pypama-1.1.tar.gz", "has_sig": false, "md5_digest": "7b3882de1b37d3f41814b38ee69bc80a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6251, "upload_time": "2020-02-03T12:36:09", "upload_time_iso_8601": "2020-02-03T12:36:09.618406Z", "url": "https://files.pythonhosted.org/packages/98/0f/f4817eff671c038a4420cab5dd5e28423e7877429f9977eb9cc16fe8c463/pypama-1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7b3882de1b37d3f41814b38ee69bc80a", "sha256": "efe66ce774afd35add9b91fa1600716118d4c8ad44bf49ffc05053c0f97a3c6a"}, "downloads": -1, "filename": "pypama-1.1.tar.gz", "has_sig": false, "md5_digest": "7b3882de1b37d3f41814b38ee69bc80a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6251, "upload_time": "2020-02-03T12:36:09", "upload_time_iso_8601": "2020-02-03T12:36:09.618406Z", "url": "https://files.pythonhosted.org/packages/98/0f/f4817eff671c038a4420cab5dd5e28423e7877429f9977eb9cc16fe8c463/pypama-1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:59:58 2020"}