{"info": {"author": "Nexedi", "author_email": "info@nexedi.com", "bugtrack_url": null, "classifiers": ["Framework :: Buildout", "Framework :: Buildout :: Recipe", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Topic :: Software Development :: Build Tools", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "********************************************\nRecipe for compiling and installing software\n********************************************\n\n.. contents::\n\nThe recipe provides the means to compile and install source distributions\nusing ``configure`` and ``make`` and other similar tools. It is inspired by\nthe hexagonit.recipe.cmmi_ recipe but provides more control over the build process.\n\n.. _hexagonit.recipe.cmmi : http://pypi.python.org/pypi/hexagonit.recipe.cmmi\n\nChanges\n=======\n\n0.16 (2020-05-08)\n-----------------\n\n* propagate strip_top_level_dir option to slapos.recipe.build:downloadunpacked\n\n0.15 (2020-04-23)\n-----------------\n\n* slapos.recipe.build.env.sh improvements/fixes.\n\n0.14 (2020-04-22)\n-----------------\n\n* Include part signature inside shared signature.\n* Drop 'dependencies' option.\n* Remove useless '_profile_base_location_' entry from shared signature.\n* Expand environment variables during install (rather than during init).\n\n0.13 (2020-03-31)\n-----------------\n\n* set -e for shell commands\n\n0.12 (2019-12-12)\n-----------------\n\n* shared: Fix recovery after an interrupted build\n\n0.11 (2019-10-02)\n-----------------\n\n* Support multiple directories for shared parts. This now uses\n  ``${buildout:shared-part-list}`` as list of directories to use.\n\n\n0.10 (2018-11-30)\n-----------------\n\n* Make sure FDs are closed before spawning subprocesses.\n\n0.9 (2018-10-29)\n----------------\n\n* More Py3 fixes.\n\n0.8 (2018-08-27)\n----------------\n\n* Add shared feature.\n\n0.7 (2017-06-06)\n----------------\n\n* Fix MANIFEST.in: some files were missing.\n\n0.6 (2017-06-05)\n----------------\n\n* Add support for Python 3.\n* Optimize wrapper to scripts with long shebangs.\n\n0.5 (2017-04-07)\n----------------\n\n* Create a wrapper shell script for very long shebang scripts.\n\n0.4 (2017-03-08)\n----------------\n\n* Use slapos.recipe.build:downloadunpacked instead of hexagonit.recipe.download.\n\n0.1.1 (2013-04-12)\n------------------\n\n* Fix the wrong name 'path_filename'\n\n0.1 (2013-04-12)\n----------------\n\n* Initial release, forking from hexagonit.recipe.cmmi (https://github.com/hexagonit/hexagonit.recipe.cmmi)\n\nSupported options\n=================\n\n``url``\n\n    URL to the package that will be downloaded and extracted. The\n    supported package formats are .tar.gz, .tar.bz2, and .zip. The\n    value must be a full URL,\n    e.g. http://python.org/ftp/python/2.4.4/Python-2.4.4.tgz. The\n    ``path`` option can not be used at the same time with ``url``.\n\n``path``\n\n    Path to a local directory containing the source code to be built\n    and installed. The directory must contain the ``configure``\n    script. The ``url`` option can not be used at the same time with\n    ``path``.\n\n``strip-top-level-dir``\n\n    Omit the topmost directory of the package when unpacking.\n    true or false. Defaults to false.\n\n``prefix``\n\n    Custom installation prefix passed to the ``--prefix`` option of the\n    ``configure`` script. Defaults to the location of the part. Note that this\n    is a convenience shortcut which assumes that the default ``configure``\n    command is used to configure the package. If the ``configure-command``\n    option is used to define a custom configure command no automatic\n    ``--prefix`` injection takes place. You can also set the ``--prefix``\n    parameter explicitly in ``configure-options``.\n\n``shared``\n\n    Specify the path in which this package is shared by many other\n    packages.\n    ``shared-part-list`` should be defined in ``[buildout]`` section\n    Shared option is True or False\n    The package will be installed on path/name/hash of options.\n\n``md5sum``\n\n    MD5 checksum for the package file. If available the MD5\n    checksum of the downloaded package will be compared to this value\n    and if the values do not match the execution of the recipe will\n    fail.\n\n``make-binary``\n\n    Path to the ``make`` program. Defaults to 'make' which\n    should work on any system that has the ``make`` program available\n    in the system ``PATH``.\n\n``make-options``\n\n    Extra ``KEY=VALUE`` options included in the invocation of the ``make``\n    program. Multiple options can be given on separate lines to increase\n    readability.\n\n``make-targets``\n\n    Targets for the ``make`` command. Defaults to 'install'\n    which will be enough to install most software packages. You only\n    need to use this if you want to build alternate targets. Each\n    target must be given on a separate line.\n\n``configure-command``\n\n    Name of the configure command that will be run to generate the Makefile.\n    This defaults to ``./configure`` which is fine for packages that come with\n    a configure script. You may wish to change this when compiling packages\n    with a different set up. See the ``Compiling a Perl package`` section for\n    an example.\n\n``configure-options``\n\n    Extra options to be given to the ``configure`` script. By default\n    only the ``--prefix`` option is passed which is set to the part\n    directory. Each option must be given on a separate line.\n\n``patch-binary``\n\n    Path to the ``patch`` program. Defaults to 'patch' which should\n    work on any system that has the ``patch`` program available in the\n    system ``PATH``.\n\n``patch-options``\n\n    Options passed to the ``patch`` program. Defaults to ``-p0``.\n\n``patches``\n\n    List of patch files to the applied to the extracted source. Each\n    file should be given on a separate line.\n\n.. _Python hook scripts:\n\n``pre-configure-hook``\n\n    Custom python script that will be executed before running the\n    ``configure`` script. The format of the options is::\n\n        /path/to/the/module.py:name_of_callable\n        url:name_of_callable\n        url#md5sum:name_of_callable\n\n    where the first part is a filesystem path or url to the python\n    module and the second part is the name of the callable in the\n    module that will be called.  The callable will be passed three\n    parameters in the following order:\n\n        1. The ``options`` dictionary from the recipe.\n\n        2. The global ``buildout`` dictionary.\n\n        3. A dictionary containing the current ``os.environ`` augmented with\n           the part specific overrides.\n\n    The callable is not expected to return anything.\n\n    .. note:: The ``os.environ`` is not modified so if the hook script is\n              interested in the environment variable overrides defined for the\n              part it needs to read them from the dictionary that is passed in\n              as the third parameter instead of accessing ``os.environ``\n              directly.\n\n``pre-make-hook``\n\n    Custom python script that will be executed before running\n    ``make``. The format and semantics are the same as with the\n    ``pre-configure-hook`` option.\n\n``post-make-hook``\n\n    Custom python script that will be executed after running\n    ``make``. The format and semantics are the same as with the\n    ``pre-configure-hook`` option.\n\n.. hook shell command:\n\n``pre-configure``\n\n    Shell command that will be executed before running ``configure``\n    script. It takes the same effect as ``pre-configure-hook`` option\n    except it's shell command.\n\n``pre-build``\n\n    Shell command that will be executed before running ``make``. It\n    takes the same effect as ``pre-make-hook`` option except it's\n    shell command.\n\n``pre-install``\n\n    Shell command that will be executed before running ``make``\n    install.\n\n``post-install``\n\n    Shell command that will be executed after running ``make``. It\n    takes the same effect as ``post-make-hook`` option except it's\n    shell command.\n\n``keep-compile-dir``\n\n    Switch to optionally keep the temporary directory where the\n    package was compiled. This is mostly useful for other recipes that\n    use this recipe to compile a software but wish to do some\n    additional steps not handled by this recipe. The location of the\n    compile directory is stored in ``options['compile-directory']``.\n    Accepted values are ``true`` or ``false``, defaults to ``false``.\n\n``promises``\n\n   List the pathes and files should be existed after install part. The\n   file or path must be absolute path. One line one item\n\n   If any item doesn't exist, the recipe shows a warning message. The\n   default value is empty.\n\n``environment-section``\n\n    Name of a section that provides environment variables that will be used to\n    augment the variables read from ``os.environ`` before executing the\n    recipe.\n\n    This recipe does not modify ``os.environ`` directly. External commands\n    run as part of the recipe (e.g. make, configure, etc.) get an augmented\n    environment when they are forked. Python hook scripts are passed the\n    augmented as a parameter.\n\n    The values of the environment variables may contain references to other\n    existing environment variables (including themselves) in the form of\n    Python string interpolation variables using the dictionary notation. These\n    references will be expanded using values from ``os.environ``. This can be\n    used, for example, to append to the ``PATH`` variable, e.g.::\n\n        [component]\n        recipe = slapos.recipe.cmmi\n        environment-section =\n            environment\n\n        [environment]\n        PATH = %(PATH)s:${buildout:directory}/bin\n\n``environment``\n\n  A sequence of ``KEY=VALUE`` pairs separated by newlines that define\n  additional environment variables used to update ``os.environ`` before\n  executing the recipe.\n\n  The semantics of this option are the same as ``environment-section``. If\n  both ``environment-section`` and ``environment`` are provided the values from\n  the former will be overridden by the latter allowing per-part customization.\n\nThe recipe uses separated part to support custom options in different\nplatforms. These platform's part has a pattern \"part:platform\" or\n\"part:platform:arch\".\n\narch could be 'x86', 'amd64', 'ia64' ... which equals\nplatform.machine().\n\nplatform could be 'linux', 'cygwin', 'macos', 'sunos', 'freebsd',\n'netbsd', 'unixware' ... which equals a formatted sys.platform.\n\nFor example::\n\n  [bzip2]\n  recipe = slapos.recipe.cmmi\n\n  [bzip2:cygwin]\n  patches = cygwin-bzip2-1.0.6.src.patch\n\nAll the options in the [part:platform] have high priority level.\n\nThe recipe first searches the exact match, if no found. Ignore arch\nand search again, if still found nothing. Use no platform part.\n\nAdditionally, the recipe honors the ``download-cache`` option set\nin the ``[buildout]`` section and stores the downloaded files under\nit. If the value is not set a directory called ``downloads`` will be\ncreated in the root of the buildout and the ``download-cache``\noption set accordingly.\n\nThe recipe will first check if there is a local copy of the package\nbefore downloading it from the net. Files can be shared among\ndifferent buildouts by setting the ``download-cache`` to the same\nlocation.\n\nThe recipe honors the ``prefix`` option set in the ``[buildout]``\nsection either. It implicts all the parts which recipe is\nslapos.recipe.cmmi in this buildout process will be installed in the\nsame ``prefix`` option in the ``[buildout]``. Besides, once it takes\neffects, recipe will return all the installed files in the prefix\ndirectory. The own ``prefix`` of part will disable this behaviour.\n\nIf the ``buildout`` section has a valid ``prefix`` option, the recipe\nwill add it to environmet variables as the following::\n\n  PATH=${buildout:prefix}/bin:$PATH\n  CPPFLAGS=-I${buildout:prefix} $CPPFLAGS\n  CFLAGS=-I${buildout:prefix} $CFFLAGS\n  CXXFLAGS=-I${buildout:prefix} $CXXFLAGS\n  LDFLAGS=-L${buildout:prefix}/lib\n\n\nExample usage\n=============\n\nWe'll use a few tarballs to demonstrate the recipe.\nWe'll modify one of them in-place but we don't want to alter the source tree.\n\n    >>> import os\n    >>> src = join(os.path.dirname(__file__), 'testdata')\n    >>> ls(src)\n    - Foo-Bar-0.0.0.tar.gz\n    - haproxy-1.4.8-dummy.tar.gz\n    - package-0.0.0.tar.gz\n    >>> package_path = join(tmpdir('testdata'), 'package-0.0.0.tar.gz')\n    >>> os.symlink(join(src, 'package-0.0.0.tar.gz'), package_path)\n\nThe package contains a dummy ``configure`` script that will simply\necho the options it was called with and create a ``Makefile`` that\nwill do the same.\n\nLet's create a buildout to build and install the package.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = true\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... \"\"\" % package_path)\n\nThis will download, extract and build our demo package with the\ndefault build options.\n\n    >>> print(system(buildout)) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Installing package.\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n    <BLANKLINE>\n\nCheck option \"promises\"\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = packagex\n    ...\n    ... [packagex]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... promises = /usr/bin/myfoo\n    ... \"\"\" % package_path)\n\nThis will download, extract and build our demo package with the\ndefault build options.\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing packagex.\n    configure --prefix=/sample_buildout/parts/packagex\n    building package\n    installing package\n    packagex: could not find promise \"/usr/bin/myfoo\"\n    <BLANKLINE>\n\nAs we can see the configure script was called with the ``--prefix``\noption by default followed by calls to ``make`` and ``make install``.\n\nInstalling a Perl package\n=========================\n\nThe recipe can be used to install packages that use a slightly different build\nprocess. Perl packages often come with a ``Makefile.PL`` script that performs\nthe same task as a ``configure`` script and generates a ``Makefile``.\n\nWe can build and install such a package by overriding the ``configure-command``\noption. The following example builds a Foo::Bar perl module and installs it in\na custom location within the buildout::\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = foobar\n    ... perl_lib = ${buildout:directory}/perl_lib\n    ...\n    ... [foobar]\n    ... recipe = slapos.recipe.cmmi\n    ... configure-command = perl -I${buildout:perl_lib}/lib/perl5 Makefile.PL INSTALL_BASE=${buildout:perl_lib}\n    ... url = file://%s/Foo-Bar-0.0.0.tar.gz\n    ... \"\"\" % src)\n\n    >>> print(system(buildout))\n    Uninstalling packagex.\n    Installing foobar.\n    building package\n    installing package\n\n.. _Installing a package without an autoconf like system:\n\nInstalling a package without an ``autoconf`` like system\n========================================================\n\nSome packages do not use a configuration mechanism and simply provide a\n``Makefile`` for building. It is common in these cases that the build process\nis controlled entirely by direct options to ``make``. We can build such a\npackage by faking a configure command that does nothing and passing the\nappropriate options to ``make``. The ``true`` utility found in most shell\nenvironments is a good candidate for this although anything that returns a\nzero exit code would do.\n\nWe are using a dummy \"HAProxy\" package as an example of a package with only a\nMakefile and using explicit ``make`` options to control the build process.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = haproxy\n    ...\n    ... [haproxy]\n    ... recipe = slapos.recipe.cmmi\n    ... configure-command = true\n    ... make-options =\n    ...     TARGET=linux26\n    ...     CPU=i686\n    ...     USE_PCRE=1\n    ... url = file://%s/haproxy-1.4.8-dummy.tar.gz\n    ... \"\"\" % src)\n\n    >>> print(system(buildout))\n    Uninstalling foobar.\n    Installing haproxy.\n    Building HAProxy 1.4.8 (dummy package)\n    TARGET: linux26\n    CPU: i686\n    USE_PCRE: 1\n    Installing haproxy\n\nInstalling checkouts\n====================\n\nSometimes instead of downloading and building an existing tarball we need to\nwork with code that is already available on the filesystem, for example an SVN\ncheckout.\n\nInstead of providing the ``url`` option we will provide a ``path`` option to\nthe directory containing the source code.\n\nLet's demonstrate this by first unpacking our test package to the filesystem\nand building that.\n\n    >>> checkout_dir = tmpdir('checkout')\n    >>> import setuptools.archive_util\n    >>> setuptools.archive_util.unpack_archive(package_path, checkout_dir)\n    >>> ls(checkout_dir)\n    d package-0.0.0\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... path = %s/package-0.0.0\n    ... \"\"\" % checkout_dir)\n\n    >>> print(system(buildout))\n    Uninstalling haproxy.\n    Installing package.\n    package: Using local source directory: /checkout/package-0.0.0\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n\nSince using the ``path`` implies that the source code has been acquired\noutside of the control of the recipe also the responsibility of managing it is\noutside of the recipe.\n\nDepending on the software you may need to manually run ``make clean`` etc.\nbetween buildout runs if you make changes to the code. Also, the\n``keep-compile-dir`` has no effect when ``path`` is used.\n\n\nAdvanced configuration\n======================\n\nThe above options are enough to build most packages. However, in some cases it\nis not enough and we need to control the build process more. Let's try again\nwith a new buildout and provide more options.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [build-environment]\n    ... CFLAGS = -I/sw/include\n    ... LDFLAGS = -I/sw/lib\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... md5sum = 6b94295c042a91ea3203857326bc9209\n    ... prefix = /somewhere/else\n    ... environment-section = build-environment\n    ... environment =\n    ...     LDFLAGS=-L/sw/lib -L/some/extra/lib\n    ... configure-options =\n    ...     --with-threads\n    ...     --without-foobar\n    ... make-targets =\n    ...     install\n    ...     install-lib\n    ... patches =\n    ...     patches/configure.patch\n    ...     patches/Makefile.dist.patch\n    ... \"\"\" % package_path)\n\nThis configuration uses custom configure options, an environment section,\nper-part customization to the environment, custom prefix, multiple make\ntargets and also patches the source code before the scripts are run.\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    package: [ENV] CFLAGS = -I/sw/include\n    package: [ENV] LDFLAGS = -L/sw/lib -L/some/extra/lib\n    package: Applying patches\n    patching file configure\n    patching file Makefile.dist\n    patched-configure --prefix=/somewhere/else --with-threads --without-foobar\n    building patched package\n    installing patched package\n    installing patched package-lib\n    <BLANKLINE>\n\nCustomizing the build process\n=============================\n\nSometimes even the above is not enough and you need to be able to control the\nprocess in even more detail. One such use case would be to perform dynamic\nsubstitutions on the source code (possible based on information from the\nbuildout) which cannot be done with static patches or to simply run arbitrary\ncommands.\n\nThe recipe allows you to write custom python scripts that hook into the build\nprocess. You can define a script to be run:\n\n - before the configure script is executed (pre-configure-hook)\n - before the make process is executed (pre-make-hook)\n - after the make process is finished (post-make-hook)\n\nEach option needs to contain the following information\n\n  /full/path/to/the/python/module.py:name_of_callable\n\nwhere the callable object (here name_of_callable) is expected to take three\nparameters:\n\n    1. The ``options`` dictionary from the recipe.\n\n    2. The global ``buildout`` dictionary.\n\n    3. A dictionary containing the current ``os.environ`` augmented with\n       the part specific overrides.\n\nThese parameters should provide the callable all the necessary information to\nperform any part specific customization to the build process.\n\nLet's create a simple python script to demonstrate the functionality. You can\nnaturally have separate modules for each hook or simply use just one or two\nhooks. Here we use just a single module.\n\n    >>> hooks = tmpdir('hooks')\n    >>> write(hooks, 'customhandlers.py',\n    ... \"\"\"\n    ... import logging\n    ... log = logging.getLogger('hook')\n    ...\n    ... def preconfigure(options, buildout, environment):\n    ...     log.info('This is pre-configure-hook!')\n    ...\n    ... def premake(options, buildout, environment):\n    ...     log.info('This is pre-make-hook!')\n    ...\n    ... def postmake(options, buildout, environment):\n    ...     log.info('This is post-make-hook!')\n    ...\n    ... \"\"\")\n\nand a new buildout to try it out\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%(package_path)s\n    ... pre-configure-hook = %(module)s:preconfigure\n    ... pre-make-hook = %(module)s:premake\n    ... post-make-hook = %(module)s:postmake\n    ... \"\"\" % dict(package_path=package_path,\n    ...            module=join(hooks, 'customhandlers.py')))\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    package: Executing pre-configure-hook\n    hook: This is pre-configure-hook!\n    configure --prefix=/sample_buildout/parts/package\n    package: Executing pre-make-hook\n    hook: This is pre-make-hook!\n    building package\n    installing package\n    package: Executing post-make-hook\n    hook: This is post-make-hook!\n\nIf you prefer to use shell script, then try these options:\n  pre-configure\n  pre-build\n  pre-install\n  post-install\n\nLet's create a buildout to use these options.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... pre-configure = echo \"Configure part: ${:_buildout_section_name_}\"\n    ... pre-build = echo \"OH OH OH\" > a.txt\n    ... pre-install = cat a.txt\n    ... post-install = rm -f a.txt && echo \"Finished.\"\n    ... \"\"\" % package_path)\n\nThis will run pre-configure, pre-build, pre-install, post-install as\nshell command in the corresponding stage.\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    package: Executing pre-configure\n    Configure part: package\n    configure --prefix=/sample_buildout/parts/package\n    package: Executing pre-build\n    building package\n    package: Executing pre-install\n    OH OH OH\n    installing package\n    package: Executing post-install\n    Finished.\n\nBuilding in multi-platforms\n===========================\n\nThe recipe can specify build options for each platform. For example,\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... pre-configure = echo \"Configure in common platform\"\n    ... post-install = echo \"Finished.\"\n    ...\n    ... [package:cygwin]\n    ... pre-configure = echo \"Configure in the CYGWIN platform\"\n    ... pre-install = echo \"Installing in the CYGWIN\"\n    ... post-install = echo -n \"CYGWIN \" && ${package:post-install}\n    ... \"\"\" % package_path)\n\nIn the linux, the recipe gets the options from part 'package', there\nare only ``pre-configure`` and ``post-install``. the output will be\n\n    #>>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    package: Executing pre-configure\n    Configure part: Configure in common platform\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n    package: Executing post-install\n    Finished.\n\nIn the cygwin, the recipe merges the options in the parts 'package'\nand 'package:cygwin'.\n\nUnion prefix\n============\n\nIf the recipe finds ``prefix`` option in the section buildout, it will\n\n  * First, use this ``prefix`` as configure prefix, if\n    ``configure-command`` isn't set in the part, or ``make-binary``\n    equals 'make' and ``make-target`` includes pattern '\\s+install.*'\n\n  * Second, return all the new installed files in the prefix when the\n    recipe returns after intall.\n\n  * Finally, change some environment variables(See first section).\n\nLet's see what happens when set prefix in the buildout section:\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... prefix = ${buildout:directory}/mylocal\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... pre-configure = mkdir -p \"${buildout:prefix}\"\n    ... \"\"\" % package_path)\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    package: Executing pre-configure\n    configure --prefix=/sample_buildout/mylocal\n    building package\n    installing package\n    <BLANKLINE>\n\nLook these environment variables and prefix's value, you know what's\nthe differences.\n\nIf part has its own ``prefix``, it will disable above behavious. For\nexample,\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... prefix = ${buildout:directory}/mylocal\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... prefix = ${buildout:parts-directory}/package\n    ... url = file://%s\n    ... pre-configure = rm -rf \"${buildout:prefix}\"\n    ... post-install = test -d \"${buildout:prefix}\" || echo \"None\"\n    ... \"\"\" % package_path)\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    package: Executing pre-configure\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n    package: Executing post-install\n    None\n\nThen no extra environment variables such as CFLAGS etc., and no\n${buildout:prefix} directory is created.\n\nThe following example shows how to install package, package-2 in one\nprefix:\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package package-2\n    ... prefix = ${buildout:directory}/mylocal\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x >\"${buildout:prefix}/a.txt\"\n    ... [package-2]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x >\"${buildout:prefix}/b.txt\"; echo\n    ... \"\"\" % (package_path, package_path))\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    configure --prefix=/sample_buildout/mylocal\n    building package\n    package: Executing pre-install\n    installing package\n    Installing package-2.\n    configure --prefix=/sample_buildout/mylocal\n    building package\n    package-2: Executing pre-install\n    <BLANKLINE>\n    installing package\n    <BLANKLINE>\n\n    >>> ls('mylocal')\n    - a.txt\n    - b.txt\n\nNext we unintall package-2, it should only remove file b.txt (which seems broken currently\nas nothing it is removing):\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... prefix = ${buildout:directory}/mylocal\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x >\"${buildout:prefix}/a.txt\"\n    ... \"\"\" % package_path)\n\n    >>> print(system(buildout))\n    Uninstalling package-2.\n    Updating package.\n\n    >>> ls('mylocal')\n    - a.txt\n    - b.txt\n\nMagic prefix\n============\n\nIf configure-command is set, the recipe wouldn't insert \"--prefix\"\ninto configure-options. Then it checks whether both of make-binary and\nmake-targets aren't set, if so, string \"prefix=xxx\" will be appended\nin the make-targets. xxx is the final prefix of this recipe. We call\nit Magic Prefix.\n\nIn these options magic prefix can be represented by ``%(prefix)s``:\n\n    ``configure-command``, ``configure-options``,\n    ``make-binary``, ``make-options``, ``make-targets``,\n    ``pre-configure``, ``pre-build``, ``pre-install``, ``post-install``\n\nFor example::\n\n  [bzip2]\n  post-install = rm %(prefix)s/*.h\n\nThe other part can refer to magic prefix of this part by\n${part:prefix}, it will return the magic prefix, other than literal\nvalue in the part section. For example::\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package package-2\n    ... prefix = /mytemp\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... configure-command = true\n    ... make-binary = true\n    ...\n    ... [package-2]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... configure-command = true\n    ... make-binary = true\n    ... post-install = echo package magic prefix is ${package:prefix}\n    ... \"\"\" % (package_path, package_path))\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    Installing package-2.\n    package-2: Executing post-install\n    package magic prefix is /mytemp\n    <BLANKLINE>\n\nHere it's another sample, we change Makefile before installing so it\ncan display \"prefix\" value in the stdout.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... configure-command = ./configure\n    ... pre-install = sed -i -e \"s/installing package/installing package at \\\\$\\\\$prefix /g\" Makefile\n    ... \"\"\" % package_path)\n\n    >>> print(system(buildout))\n    Uninstalling package-2.\n    Uninstalling package.\n    Installing package.\n    configure\n    building package\n    package: Executing pre-install\n    installing package at /sample_buildout/parts/package\n\nYou even can include pattern %(prefix)s in this option, it will be\nreplaced with the recipe final prefix.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... configure-command = ./configure\n    ... make-targets = install-lib prefix=%%(prefix)s\n    ... pre-install = sed -i -e \"s/installing package/installing package at \\\\$\\\\$prefix /g\" Makefile\n    ... \"\"\" % package_path)\n\n    >>> print(system(buildout))\n    Uninstalling package.\n    Installing package.\n    configure\n    building package\n    package: Executing pre-install\n    installing package at /sample_buildout/parts/package -lib\n\nInstall shared package\n======================\n\nUse option ``shared`` to install a shared package.\n\n    >>> import subprocess\n    >>> shared_dir = tmpdir('shared')\n    >>> another_shared_dir = tmpdir('another_shared_dir')\n    >>> __tear_downs.insert(0, lambda: subprocess.call(\n    ...     ('chmod', '-R', 'u+w', shared_dir, another_shared_dir)))\n\nIf no ``shared-part-list`` is set, and ``shared`` is True, ``shared`` feature\nis not used.\n\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... shared = True\n    ... \"\"\" % package_path)\n    \n    >>> print(system(buildout)) #doctest:+ELLIPSIS\n    Uninstalling package.\n    Installing package.\n    configure --prefix=/sample_buildout/parts/package\n    building package\n    installing package\n\nIf ``shared-part-list`` is set and shared is True, build package failed, the\nbuild directory is removed, a build directory__compile__ is left for\ndebugging.\nAlso a shell script with the environment variable is created, so that\ndeveloper can try same build process as the recipe tried.\n\n    >>> os.rename(package_path, package_path + '.bak')\n    >>> import tarfile\n    >>> from io import BytesIO\n    >>> import sys\n    >>> with tarfile.open(package_path, 'w:gz') as tar:\n    ...   configure = b'invalid'\n    ...   info = tarfile.TarInfo('configure.off')\n    ...   info.size = len(configure)\n    ...   info.mode = 0o755\n    ...   tar.addfile(info, BytesIO(configure))\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... shared-part-list = %s\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... shared = True\n    ... environment =\n    ...   FOO=bar\n    ... \"\"\" % (shared_dir, package_path))\n    >>> print(system(buildout)) #doctest:+ELLIPSIS\n    package: shared at /shared/package/<MD5SUM:0>\n    Uninstalling package.\n    Installing package.\n    package: Checking whether package is installed at shared path: /shared/package/<MD5SUM:0>\n    package: [ENV] FOO = bar\n    package: Command 'set -e;./configure --prefix=\"/shared/package/<MD5SUM:0>\"' returned non-zero exit status 127.\n    package: Compilation error. The package is left as is at /shared/package/<MD5SUM:0>__compile__ where you can inspect what went wrong.\n    A shell script slapos.recipe.build.env.sh has been generated. You can source it in your shell to reproduce build environment.\n    /bin/sh: 1: ./configure: not found\n    While:\n      Installing package.\n    Error: System error\n    >>> import glob\n    >>> cat(glob.glob(join(shared_dir, 'package/**__compile__/slapos.recipe.build.env.sh'))[0])\n    export FOO=bar\n    ...\n\nNext time buildout runs, it detects that the build failed, remove the compile dir and retry.\n\n    >>> print(system(buildout)) #doctest:+ELLIPSIS\n    package: shared at /shared/package/<MD5SUM:0>\n    Installing package.\n    package: Checking whether package is installed at shared path: /shared/package/<MD5SUM:0>\n    package: [ENV] FOO = bar\n    package: Removing already existing directory /shared/package/<MD5SUM:0>__compile__\n    package: Command 'set -e;./configure --prefix=\"/shared/package/<MD5SUM:0>\"' returned non-zero exit status 127.\n    package: Compilation error. The package is left as is at /shared/package/<MD5SUM:0>__compile__ where you can inspect what went wrong.\n    A shell script slapos.recipe.build.env.sh has been generated. You can source it in your shell to reproduce build environment.\n    /bin/sh: 1: ./configure: not found\n    While:\n      Installing package.\n    Error: System error\n\n\nBut we had a bug with version v0.11 is that if build was interrupted in the middle of the build of a\nshared part. The shared part was left in an inconsistent state that looked like installation succeeded.\n\nLet's simulate a scenario where buildout is terminated in the middle of a build.\nFor this, we need a package that takes a lot of time to install.\n\n    >>> with tarfile.open(package_path, 'w:gz') as tar:\n    ...   configure = b'#!/bin/sh\\necho configure started\\nsleep 300;'\n    ...   info = tarfile.TarInfo('configure')\n    ...   info.size = len(configure)\n    ...   info.mode = 0o755\n    ...   tar.addfile(info, BytesIO(configure))\n\nWe also need a bit more complex method to run buildout so that we send a termination signal in the\nmiddle of build process.\n\n    >>> import signal\n    >>> import time\n    >>> buildout_process = subprocess.Popen(buildout, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    >>> output_line = ''\n    >>> for _ in range(10):\n    ...   time.sleep(1)\n    ...   output_line = buildout_process.stdout.readline()\n    ...   if output_line and b'configure started' in output_line:\n    ...     print ('configure started')\n    ...     buildout_process.send_signal(signal.SIGKILL)\n    ...     print ('buildout terminated')\n    ...     break\n    configure started\n    buildout terminated\n    >>> _ = buildout_process.wait()\n\n\nIf we run buildout again, the compile dir is removed again and installation is retried. This time\ninstallation can succeed.\n\nThis was not the case in version 0.11 of this recipe. If installation of a shared part failed, this was\nnot detected and the part was considered as installed.\n\n\n    >>> os.rename(package_path + '.bak', package_path)\n    >>> print(system(buildout)) #doctest:+ELLIPSIS\n    package: shared at /shared/package/<MD5SUM:0>\n    Installing package.\n    package: Checking whether package is installed at shared path: /shared/package/<MD5SUM:0>\n    package: [ENV] FOO = bar\n    package: Removing already existing directory /shared/package/<MD5SUM:0>__compile__\n    configure --prefix=/shared/package/<MD5SUM:0>\n    building package\n    installing package\n\n\n\nIf ``shared-part-list`` is set as an option in buildout section and\n``shared`` is True, package will be installed in shared_part/package\nand a hash of the recipe's configuration options.\n\nThere can be multiple path listed in ``shared-part-list``, the recipe\nwill look in each of these paths if package was already installed and\nif not, it will install the package in the last entry the last entry\nfrom the list of ``shared-part-list``.\n\nIf package was already installed in any of the ``shared-part-list`` used, it will be\nused instead of installing if one package has been installed.\n\n    >>> remove('.installed.cfg')\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... shared-part-list =\n    ...   %s\n    ...   not/exists\n    ...   %s\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... shared = True\n    ... environment =\n    ...   FOO=bar\n    ... \"\"\" % (shared_dir, another_shared_dir, package_path))\n    >>> print(system(buildout)) #doctest:+ELLIPSIS\n    package: shared at /shared/package/<MD5SUM:0>\n    Installing package.\n    package: Checking whether package is installed at shared path: /shared/package/<MD5SUM:0>\n    package: This shared package has been installed by other package\n\nIf options change, reinstall in different location:\n    >>> write('buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... newest = false\n    ... parts = package\n    ... shared-part-list = %s\n    ...\n    ... [package]\n    ... recipe = slapos.recipe.cmmi\n    ... url = file://%s\n    ... shared =True\n    ... change = True\n    ... \"\"\" % (shared_dir, package_path))\n\n    >>> print(system(buildout)) #doctest:+ELLIPSIS\n    package: shared at /shared/package/<MD5SUM:1>\n    Uninstalling package.\n    Installing package.\n    package: Checking whether package is installed at shared path: /shared/package/<MD5SUM:1>\n    configure --prefix=/shared/package/<MD5SUM:1>\n    building package\n    installing package\n\nFor even more specific needs you can write your own recipe that uses\n``slapos.recipe.cmmi`` and set the ``keep-compile-dir`` option to ``true``.\nYou can then continue from where this recipe finished by reading the location\nof the compile directory from ``options['compile-directory']`` from your own\nrecipe.\n\n\nContributors\n============\n\n* Kai Lautaportti (dokai), Author\n* C\u00e9dric de Saint Martin (desaintmartin)\n* Marc Abramowitz (msabramo)\n* Nicolas Dumazet (nicdumz)\n* Guy Rozendorn (grzn)\n* Marco Mariani (mmariani)\n* galpin\n\nDownload\n========", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://lab.nexedi.com/nexedi/slapos.recipe.cmmi", "keywords": "development buildout recipe", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "slapos.recipe.cmmi", "package_url": "https://pypi.org/project/slapos.recipe.cmmi/", "platform": "", "project_url": "https://pypi.org/project/slapos.recipe.cmmi/", "project_urls": {"Homepage": "https://lab.nexedi.com/nexedi/slapos.recipe.cmmi"}, "release_url": "https://pypi.org/project/slapos.recipe.cmmi/0.16/", "requires_dist": null, "requires_python": "", "summary": "zc.buildout recipe for compiling and installing source distributions.", "version": "0.16", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#changes\" id=\"id17\" rel=\"nofollow\">Changes</a><ul>\n<li><a href=\"#id1\" id=\"id18\" rel=\"nofollow\">0.16 (2020-05-08)</a></li>\n<li><a href=\"#id2\" id=\"id19\" rel=\"nofollow\">0.15 (2020-04-23)</a></li>\n<li><a href=\"#id3\" id=\"id20\" rel=\"nofollow\">0.14 (2020-04-22)</a></li>\n<li><a href=\"#id4\" id=\"id21\" rel=\"nofollow\">0.13 (2020-03-31)</a></li>\n<li><a href=\"#id5\" id=\"id22\" rel=\"nofollow\">0.12 (2019-12-12)</a></li>\n<li><a href=\"#id6\" id=\"id23\" rel=\"nofollow\">0.11 (2019-10-02)</a></li>\n<li><a href=\"#id7\" id=\"id24\" rel=\"nofollow\">0.10 (2018-11-30)</a></li>\n<li><a href=\"#id8\" id=\"id25\" rel=\"nofollow\">0.9 (2018-10-29)</a></li>\n<li><a href=\"#id9\" id=\"id26\" rel=\"nofollow\">0.8 (2018-08-27)</a></li>\n<li><a href=\"#id10\" id=\"id27\" rel=\"nofollow\">0.7 (2017-06-06)</a></li>\n<li><a href=\"#id11\" id=\"id28\" rel=\"nofollow\">0.6 (2017-06-05)</a></li>\n<li><a href=\"#id12\" id=\"id29\" rel=\"nofollow\">0.5 (2017-04-07)</a></li>\n<li><a href=\"#id13\" id=\"id30\" rel=\"nofollow\">0.4 (2017-03-08)</a></li>\n<li><a href=\"#id14\" id=\"id31\" rel=\"nofollow\">0.1.1 (2013-04-12)</a></li>\n<li><a href=\"#id15\" id=\"id32\" rel=\"nofollow\">0.1 (2013-04-12)</a></li>\n</ul>\n</li>\n<li><a href=\"#supported-options\" id=\"id33\" rel=\"nofollow\">Supported options</a></li>\n<li><a href=\"#example-usage\" id=\"id34\" rel=\"nofollow\">Example usage</a></li>\n<li><a href=\"#installing-a-perl-package\" id=\"id35\" rel=\"nofollow\">Installing a Perl package</a></li>\n<li><a href=\"#id16\" id=\"id36\" rel=\"nofollow\">Installing a package without an <tt>autoconf</tt> like system</a></li>\n<li><a href=\"#installing-checkouts\" id=\"id37\" rel=\"nofollow\">Installing checkouts</a></li>\n<li><a href=\"#advanced-configuration\" id=\"id38\" rel=\"nofollow\">Advanced configuration</a></li>\n<li><a href=\"#customizing-the-build-process\" id=\"id39\" rel=\"nofollow\">Customizing the build process</a></li>\n<li><a href=\"#building-in-multi-platforms\" id=\"id40\" rel=\"nofollow\">Building in multi-platforms</a></li>\n<li><a href=\"#union-prefix\" id=\"id41\" rel=\"nofollow\">Union prefix</a></li>\n<li><a href=\"#magic-prefix\" id=\"id42\" rel=\"nofollow\">Magic prefix</a></li>\n<li><a href=\"#install-shared-package\" id=\"id43\" rel=\"nofollow\">Install shared package</a></li>\n<li><a href=\"#contributors\" id=\"id44\" rel=\"nofollow\">Contributors</a></li>\n<li><a href=\"#download\" id=\"id45\" rel=\"nofollow\">Download</a></li>\n</ul>\n</div>\n<p>The recipe provides the means to compile and install source distributions\nusing <tt>configure</tt> and <tt>make</tt> and other similar tools. It is inspired by\nthe <a href=\"http://pypi.python.org/pypi/hexagonit.recipe.cmmi\" rel=\"nofollow\">hexagonit.recipe.cmmi</a> recipe but provides more control over the build process.</p>\n<div id=\"changes\">\n<h2><a href=\"#id17\" rel=\"nofollow\">Changes</a></h2>\n<div id=\"id1\">\n<h3><a href=\"#id18\" rel=\"nofollow\">0.16 (2020-05-08)</a></h3>\n<ul>\n<li>propagate strip_top_level_dir option to slapos.recipe.build:downloadunpacked</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id19\" rel=\"nofollow\">0.15 (2020-04-23)</a></h3>\n<ul>\n<li>slapos.recipe.build.env.sh improvements/fixes.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id20\" rel=\"nofollow\">0.14 (2020-04-22)</a></h3>\n<ul>\n<li>Include part signature inside shared signature.</li>\n<li>Drop \u2018dependencies\u2019 option.</li>\n<li>Remove useless \u2018_profile_base_location_\u2019 entry from shared signature.</li>\n<li>Expand environment variables during install (rather than during init).</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id21\" rel=\"nofollow\">0.13 (2020-03-31)</a></h3>\n<ul>\n<li>set -e for shell commands</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id22\" rel=\"nofollow\">0.12 (2019-12-12)</a></h3>\n<ul>\n<li>shared: Fix recovery after an interrupted build</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id23\" rel=\"nofollow\">0.11 (2019-10-02)</a></h3>\n<ul>\n<li>Support multiple directories for shared parts. This now uses\n<tt><span class=\"pre\">${buildout:shared-part-list}</span></tt> as list of directories to use.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id24\" rel=\"nofollow\">0.10 (2018-11-30)</a></h3>\n<ul>\n<li>Make sure FDs are closed before spawning subprocesses.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id25\" rel=\"nofollow\">0.9 (2018-10-29)</a></h3>\n<ul>\n<li>More Py3 fixes.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id26\" rel=\"nofollow\">0.8 (2018-08-27)</a></h3>\n<ul>\n<li>Add shared feature.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id27\" rel=\"nofollow\">0.7 (2017-06-06)</a></h3>\n<ul>\n<li>Fix MANIFEST.in: some files were missing.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3><a href=\"#id28\" rel=\"nofollow\">0.6 (2017-06-05)</a></h3>\n<ul>\n<li>Add support for Python 3.</li>\n<li>Optimize wrapper to scripts with long shebangs.</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3><a href=\"#id29\" rel=\"nofollow\">0.5 (2017-04-07)</a></h3>\n<ul>\n<li>Create a wrapper shell script for very long shebang scripts.</li>\n</ul>\n</div>\n<div id=\"id13\">\n<h3><a href=\"#id30\" rel=\"nofollow\">0.4 (2017-03-08)</a></h3>\n<ul>\n<li>Use slapos.recipe.build:downloadunpacked instead of hexagonit.recipe.download.</li>\n</ul>\n</div>\n<div id=\"id14\">\n<h3><a href=\"#id31\" rel=\"nofollow\">0.1.1 (2013-04-12)</a></h3>\n<ul>\n<li>Fix the wrong name \u2018path_filename\u2019</li>\n</ul>\n</div>\n<div id=\"id15\">\n<h3><a href=\"#id32\" rel=\"nofollow\">0.1 (2013-04-12)</a></h3>\n<ul>\n<li>Initial release, forking from hexagonit.recipe.cmmi (<a href=\"https://github.com/hexagonit/hexagonit.recipe.cmmi\" rel=\"nofollow\">https://github.com/hexagonit/hexagonit.recipe.cmmi</a>)</li>\n</ul>\n</div>\n</div>\n<div id=\"supported-options\">\n<h2><a href=\"#id33\" rel=\"nofollow\">Supported options</a></h2>\n<p><tt>url</tt></p>\n<blockquote>\nURL to the package that will be downloaded and extracted. The\nsupported package formats are .tar.gz, .tar.bz2, and .zip. The\nvalue must be a full URL,\ne.g. <a href=\"http://python.org/ftp/python/2.4.4/Python-2.4.4.tgz\" rel=\"nofollow\">http://python.org/ftp/python/2.4.4/Python-2.4.4.tgz</a>. The\n<tt>path</tt> option can not be used at the same time with <tt>url</tt>.</blockquote>\n<p><tt>path</tt></p>\n<blockquote>\nPath to a local directory containing the source code to be built\nand installed. The directory must contain the <tt>configure</tt>\nscript. The <tt>url</tt> option can not be used at the same time with\n<tt>path</tt>.</blockquote>\n<p><tt><span class=\"pre\">strip-top-level-dir</span></tt></p>\n<blockquote>\nOmit the topmost directory of the package when unpacking.\ntrue or false. Defaults to false.</blockquote>\n<p><tt>prefix</tt></p>\n<blockquote>\nCustom installation prefix passed to the <tt><span class=\"pre\">--prefix</span></tt> option of the\n<tt>configure</tt> script. Defaults to the location of the part. Note that this\nis a convenience shortcut which assumes that the default <tt>configure</tt>\ncommand is used to configure the package. If the <tt><span class=\"pre\">configure-command</span></tt>\noption is used to define a custom configure command no automatic\n<tt><span class=\"pre\">--prefix</span></tt> injection takes place. You can also set the <tt><span class=\"pre\">--prefix</span></tt>\nparameter explicitly in <tt><span class=\"pre\">configure-options</span></tt>.</blockquote>\n<p><tt>shared</tt></p>\n<blockquote>\nSpecify the path in which this package is shared by many other\npackages.\n<tt><span class=\"pre\">shared-part-list</span></tt> should be defined in <tt>[buildout]</tt> section\nShared option is True or False\nThe package will be installed on path/name/hash of options.</blockquote>\n<p><tt>md5sum</tt></p>\n<blockquote>\nMD5 checksum for the package file. If available the MD5\nchecksum of the downloaded package will be compared to this value\nand if the values do not match the execution of the recipe will\nfail.</blockquote>\n<p><tt><span class=\"pre\">make-binary</span></tt></p>\n<blockquote>\nPath to the <tt>make</tt> program. Defaults to \u2018make\u2019 which\nshould work on any system that has the <tt>make</tt> program available\nin the system <tt>PATH</tt>.</blockquote>\n<p><tt><span class=\"pre\">make-options</span></tt></p>\n<blockquote>\nExtra <tt>KEY=VALUE</tt> options included in the invocation of the <tt>make</tt>\nprogram. Multiple options can be given on separate lines to increase\nreadability.</blockquote>\n<p><tt><span class=\"pre\">make-targets</span></tt></p>\n<blockquote>\nTargets for the <tt>make</tt> command. Defaults to \u2018install\u2019\nwhich will be enough to install most software packages. You only\nneed to use this if you want to build alternate targets. Each\ntarget must be given on a separate line.</blockquote>\n<p><tt><span class=\"pre\">configure-command</span></tt></p>\n<blockquote>\nName of the configure command that will be run to generate the Makefile.\nThis defaults to <tt>./configure</tt> which is fine for packages that come with\na configure script. You may wish to change this when compiling packages\nwith a different set up. See the <tt>Compiling a Perl package</tt> section for\nan example.</blockquote>\n<p><tt><span class=\"pre\">configure-options</span></tt></p>\n<blockquote>\nExtra options to be given to the <tt>configure</tt> script. By default\nonly the <tt><span class=\"pre\">--prefix</span></tt> option is passed which is set to the part\ndirectory. Each option must be given on a separate line.</blockquote>\n<p><tt><span class=\"pre\">patch-binary</span></tt></p>\n<blockquote>\nPath to the <tt>patch</tt> program. Defaults to \u2018patch\u2019 which should\nwork on any system that has the <tt>patch</tt> program available in the\nsystem <tt>PATH</tt>.</blockquote>\n<p><tt><span class=\"pre\">patch-options</span></tt></p>\n<blockquote>\nOptions passed to the <tt>patch</tt> program. Defaults to <tt><span class=\"pre\">-p0</span></tt>.</blockquote>\n<p><tt>patches</tt></p>\n<blockquote>\nList of patch files to the applied to the extracted source. Each\nfile should be given on a separate line.</blockquote>\n<p id=\"python-hook-scripts\"><tt><span class=\"pre\">pre-configure-hook</span></tt></p>\n<blockquote>\n<p>Custom python script that will be executed before running the\n<tt>configure</tt> script. The format of the options is:</p>\n<pre>/path/to/the/module.py:name_of_callable\nurl:name_of_callable\nurl#md5sum:name_of_callable\n</pre>\n<p>where the first part is a filesystem path or url to the python\nmodule and the second part is the name of the callable in the\nmodule that will be called.  The callable will be passed three\nparameters in the following order:</p>\n<blockquote>\n<ol>\n<li>The <tt>options</tt> dictionary from the recipe.</li>\n<li>The global <tt>buildout</tt> dictionary.</li>\n<li>A dictionary containing the current <tt>os.environ</tt> augmented with\nthe part specific overrides.</li>\n</ol>\n</blockquote>\n<p>The callable is not expected to return anything.</p>\n<div>\n<p>Note</p>\n<p>The <tt>os.environ</tt> is not modified so if the hook script is\ninterested in the environment variable overrides defined for the\npart it needs to read them from the dictionary that is passed in\nas the third parameter instead of accessing <tt>os.environ</tt>\ndirectly.</p>\n</div>\n</blockquote>\n<p><tt><span class=\"pre\">pre-make-hook</span></tt></p>\n<blockquote>\nCustom python script that will be executed before running\n<tt>make</tt>. The format and semantics are the same as with the\n<tt><span class=\"pre\">pre-configure-hook</span></tt> option.</blockquote>\n<p><tt><span class=\"pre\">post-make-hook</span></tt></p>\n<blockquote>\nCustom python script that will be executed after running\n<tt>make</tt>. The format and semantics are the same as with the\n<tt><span class=\"pre\">pre-configure-hook</span></tt> option.</blockquote>\n<p><tt><span class=\"pre\">pre-configure</span></tt></p>\n<blockquote>\nShell command that will be executed before running <tt>configure</tt>\nscript. It takes the same effect as <tt><span class=\"pre\">pre-configure-hook</span></tt> option\nexcept it\u2019s shell command.</blockquote>\n<p><tt><span class=\"pre\">pre-build</span></tt></p>\n<blockquote>\nShell command that will be executed before running <tt>make</tt>. It\ntakes the same effect as <tt><span class=\"pre\">pre-make-hook</span></tt> option except it\u2019s\nshell command.</blockquote>\n<p><tt><span class=\"pre\">pre-install</span></tt></p>\n<blockquote>\nShell command that will be executed before running <tt>make</tt>\ninstall.</blockquote>\n<p><tt><span class=\"pre\">post-install</span></tt></p>\n<blockquote>\nShell command that will be executed after running <tt>make</tt>. It\ntakes the same effect as <tt><span class=\"pre\">post-make-hook</span></tt> option except it\u2019s\nshell command.</blockquote>\n<p><tt><span class=\"pre\">keep-compile-dir</span></tt></p>\n<blockquote>\nSwitch to optionally keep the temporary directory where the\npackage was compiled. This is mostly useful for other recipes that\nuse this recipe to compile a software but wish to do some\nadditional steps not handled by this recipe. The location of the\ncompile directory is stored in <tt><span class=\"pre\">options['compile-directory']</span></tt>.\nAccepted values are <tt>true</tt> or <tt>false</tt>, defaults to <tt>false</tt>.</blockquote>\n<p><tt>promises</tt></p>\n<blockquote>\n<p>List the pathes and files should be existed after install part. The\nfile or path must be absolute path. One line one item</p>\n<p>If any item doesn\u2019t exist, the recipe shows a warning message. The\ndefault value is empty.</p>\n</blockquote>\n<p><tt><span class=\"pre\">environment-section</span></tt></p>\n<blockquote>\n<p>Name of a section that provides environment variables that will be used to\naugment the variables read from <tt>os.environ</tt> before executing the\nrecipe.</p>\n<p>This recipe does not modify <tt>os.environ</tt> directly. External commands\nrun as part of the recipe (e.g. make, configure, etc.) get an augmented\nenvironment when they are forked. Python hook scripts are passed the\naugmented as a parameter.</p>\n<p>The values of the environment variables may contain references to other\nexisting environment variables (including themselves) in the form of\nPython string interpolation variables using the dictionary notation. These\nreferences will be expanded using values from <tt>os.environ</tt>. This can be\nused, for example, to append to the <tt>PATH</tt> variable, e.g.:</p>\n<pre>[component]\nrecipe = slapos.recipe.cmmi\nenvironment-section =\n    environment\n\n[environment]\nPATH = %(PATH)s:${buildout:directory}/bin\n</pre>\n</blockquote>\n<p><tt>environment</tt></p>\n<blockquote>\n<p>A sequence of <tt>KEY=VALUE</tt> pairs separated by newlines that define\nadditional environment variables used to update <tt>os.environ</tt> before\nexecuting the recipe.</p>\n<p>The semantics of this option are the same as <tt><span class=\"pre\">environment-section</span></tt>. If\nboth <tt><span class=\"pre\">environment-section</span></tt> and <tt>environment</tt> are provided the values from\nthe former will be overridden by the latter allowing per-part customization.</p>\n</blockquote>\n<p>The recipe uses separated part to support custom options in different\nplatforms. These platform\u2019s part has a pattern \u201cpart:platform\u201d or\n\u201cpart:platform:arch\u201d.</p>\n<p>arch could be \u2018x86\u2019, \u2018amd64\u2019, \u2018ia64\u2019 \u2026 which equals\nplatform.machine().</p>\n<p>platform could be \u2018linux\u2019, \u2018cygwin\u2019, \u2018macos\u2019, \u2018sunos\u2019, \u2018freebsd\u2019,\n\u2018netbsd\u2019, \u2018unixware\u2019 \u2026 which equals a formatted sys.platform.</p>\n<p>For example:</p>\n<pre>[bzip2]\nrecipe = slapos.recipe.cmmi\n\n[bzip2:cygwin]\npatches = cygwin-bzip2-1.0.6.src.patch\n</pre>\n<p>All the options in the [part:platform] have high priority level.</p>\n<p>The recipe first searches the exact match, if no found. Ignore arch\nand search again, if still found nothing. Use no platform part.</p>\n<p>Additionally, the recipe honors the <tt><span class=\"pre\">download-cache</span></tt> option set\nin the <tt>[buildout]</tt> section and stores the downloaded files under\nit. If the value is not set a directory called <tt>downloads</tt> will be\ncreated in the root of the buildout and the <tt><span class=\"pre\">download-cache</span></tt>\noption set accordingly.</p>\n<p>The recipe will first check if there is a local copy of the package\nbefore downloading it from the net. Files can be shared among\ndifferent buildouts by setting the <tt><span class=\"pre\">download-cache</span></tt> to the same\nlocation.</p>\n<p>The recipe honors the <tt>prefix</tt> option set in the <tt>[buildout]</tt>\nsection either. It implicts all the parts which recipe is\nslapos.recipe.cmmi in this buildout process will be installed in the\nsame <tt>prefix</tt> option in the <tt>[buildout]</tt>. Besides, once it takes\neffects, recipe will return all the installed files in the prefix\ndirectory. The own <tt>prefix</tt> of part will disable this behaviour.</p>\n<p>If the <tt>buildout</tt> section has a valid <tt>prefix</tt> option, the recipe\nwill add it to environmet variables as the following:</p>\n<pre>PATH=${buildout:prefix}/bin:$PATH\nCPPFLAGS=-I${buildout:prefix} $CPPFLAGS\nCFLAGS=-I${buildout:prefix} $CFFLAGS\nCXXFLAGS=-I${buildout:prefix} $CXXFLAGS\nLDFLAGS=-L${buildout:prefix}/lib\n</pre>\n</div>\n<div id=\"example-usage\">\n<h2><a href=\"#id34\" rel=\"nofollow\">Example usage</a></h2>\n<p>We\u2019ll use a few tarballs to demonstrate the recipe.\nWe\u2019ll modify one of them in-place but we don\u2019t want to alter the source tree.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt; src = join(os.path.dirname(__file__), 'testdata')\n&gt;&gt;&gt; ls(src)\n- Foo-Bar-0.0.0.tar.gz\n- haproxy-1.4.8-dummy.tar.gz\n- package-0.0.0.tar.gz\n&gt;&gt;&gt; package_path = join(tmpdir('testdata'), 'package-0.0.0.tar.gz')\n&gt;&gt;&gt; os.symlink(join(src, 'package-0.0.0.tar.gz'), package_path)\n</pre>\n</blockquote>\n<p>The package contains a dummy <tt>configure</tt> script that will simply\necho the options it was called with and create a <tt>Makefile</tt> that\nwill do the same.</p>\n<p>Let\u2019s create a buildout to build and install the package.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = true\n... parts = package\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... \"\"\" % package_path)\n</pre>\n</blockquote>\n<p>This will download, extract and build our demo package with the\ndefault build options.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(system(buildout)) #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\nInstalling package.\nconfigure --prefix=/sample_buildout/parts/package\nbuilding package\ninstalling package\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>Check option \u201cpromises\u201d</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = packagex\n...\n... [packagex]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... promises = /usr/bin/myfoo\n... \"\"\" % package_path)\n</pre>\n</blockquote>\n<p>This will download, extract and build our demo package with the\ndefault build options.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling packagex.\nconfigure --prefix=/sample_buildout/parts/packagex\nbuilding package\ninstalling package\npackagex: could not find promise \"/usr/bin/myfoo\"\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>As we can see the configure script was called with the <tt><span class=\"pre\">--prefix</span></tt>\noption by default followed by calls to <tt>make</tt> and <tt>make install</tt>.</p>\n</div>\n<div id=\"installing-a-perl-package\">\n<h2><a href=\"#id35\" rel=\"nofollow\">Installing a Perl package</a></h2>\n<p>The recipe can be used to install packages that use a slightly different build\nprocess. Perl packages often come with a <tt>Makefile.PL</tt> script that performs\nthe same task as a <tt>configure</tt> script and generates a <tt>Makefile</tt>.</p>\n<p>We can build and install such a package by overriding the <tt><span class=\"pre\">configure-command</span></tt>\noption. The following example builds a Foo::Bar perl module and installs it in\na custom location within the buildout:</p>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = foobar\n... perl_lib = ${buildout:directory}/perl_lib\n...\n... [foobar]\n... recipe = slapos.recipe.cmmi\n... configure-command = perl -I${buildout:perl_lib}/lib/perl5 Makefile.PL INSTALL_BASE=${buildout:perl_lib}\n... url = file://%s/Foo-Bar-0.0.0.tar.gz\n... \"\"\" % src)\n\n&gt;&gt;&gt; print(system(buildout))\nUninstalling packagex.\nInstalling foobar.\nbuilding package\ninstalling package\n</pre>\n</div>\n<div id=\"id16\">\n<span id=\"installing-a-package-without-an-autoconf-like-system\"></span><h2><a href=\"#id36\" rel=\"nofollow\">Installing a package without an <tt>autoconf</tt> like system</a></h2>\n<p>Some packages do not use a configuration mechanism and simply provide a\n<tt>Makefile</tt> for building. It is common in these cases that the build process\nis controlled entirely by direct options to <tt>make</tt>. We can build such a\npackage by faking a configure command that does nothing and passing the\nappropriate options to <tt>make</tt>. The <tt>true</tt> utility found in most shell\nenvironments is a good candidate for this although anything that returns a\nzero exit code would do.</p>\n<p>We are using a dummy \u201cHAProxy\u201d package as an example of a package with only a\nMakefile and using explicit <tt>make</tt> options to control the build process.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = haproxy\n...\n... [haproxy]\n... recipe = slapos.recipe.cmmi\n... configure-command = true\n... make-options =\n...     TARGET=linux26\n...     CPU=i686\n...     USE_PCRE=1\n... url = file://%s/haproxy-1.4.8-dummy.tar.gz\n... \"\"\" % src)\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling foobar.\nInstalling haproxy.\nBuilding HAProxy 1.4.8 (dummy package)\nTARGET: linux26\nCPU: i686\nUSE_PCRE: 1\nInstalling haproxy\n</pre>\n</blockquote>\n</div>\n<div id=\"installing-checkouts\">\n<h2><a href=\"#id37\" rel=\"nofollow\">Installing checkouts</a></h2>\n<p>Sometimes instead of downloading and building an existing tarball we need to\nwork with code that is already available on the filesystem, for example an SVN\ncheckout.</p>\n<p>Instead of providing the <tt>url</tt> option we will provide a <tt>path</tt> option to\nthe directory containing the source code.</p>\n<p>Let\u2019s demonstrate this by first unpacking our test package to the filesystem\nand building that.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; checkout_dir = tmpdir('checkout')\n&gt;&gt;&gt; import setuptools.archive_util\n&gt;&gt;&gt; setuptools.archive_util.unpack_archive(package_path, checkout_dir)\n&gt;&gt;&gt; ls(checkout_dir)\nd package-0.0.0\n</pre>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... path = %s/package-0.0.0\n... \"\"\" % checkout_dir)\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling haproxy.\nInstalling package.\npackage: Using local source directory: /checkout/package-0.0.0\nconfigure --prefix=/sample_buildout/parts/package\nbuilding package\ninstalling package\n</pre>\n</blockquote>\n<p>Since using the <tt>path</tt> implies that the source code has been acquired\noutside of the control of the recipe also the responsibility of managing it is\noutside of the recipe.</p>\n<p>Depending on the software you may need to manually run <tt>make clean</tt> etc.\nbetween buildout runs if you make changes to the code. Also, the\n<tt><span class=\"pre\">keep-compile-dir</span></tt> has no effect when <tt>path</tt> is used.</p>\n</div>\n<div id=\"advanced-configuration\">\n<h2><a href=\"#id38\" rel=\"nofollow\">Advanced configuration</a></h2>\n<p>The above options are enough to build most packages. However, in some cases it\nis not enough and we need to control the build process more. Let\u2019s try again\nwith a new buildout and provide more options.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n...\n... [build-environment]\n... CFLAGS = -I/sw/include\n... LDFLAGS = -I/sw/lib\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... md5sum = 6b94295c042a91ea3203857326bc9209\n... prefix = /somewhere/else\n... environment-section = build-environment\n... environment =\n...     LDFLAGS=-L/sw/lib -L/some/extra/lib\n... configure-options =\n...     --with-threads\n...     --without-foobar\n... make-targets =\n...     install\n...     install-lib\n... patches =\n...     patches/configure.patch\n...     patches/Makefile.dist.patch\n... \"\"\" % package_path)\n</pre>\n</blockquote>\n<p>This configuration uses custom configure options, an environment section,\nper-part customization to the environment, custom prefix, multiple make\ntargets and also patches the source code before the scripts are run.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\npackage: [ENV] CFLAGS = -I/sw/include\npackage: [ENV] LDFLAGS = -L/sw/lib -L/some/extra/lib\npackage: Applying patches\npatching file configure\npatching file Makefile.dist\npatched-configure --prefix=/somewhere/else --with-threads --without-foobar\nbuilding patched package\ninstalling patched package\ninstalling patched package-lib\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"customizing-the-build-process\">\n<h2><a href=\"#id39\" rel=\"nofollow\">Customizing the build process</a></h2>\n<p>Sometimes even the above is not enough and you need to be able to control the\nprocess in even more detail. One such use case would be to perform dynamic\nsubstitutions on the source code (possible based on information from the\nbuildout) which cannot be done with static patches or to simply run arbitrary\ncommands.</p>\n<p>The recipe allows you to write custom python scripts that hook into the build\nprocess. You can define a script to be run:</p>\n<blockquote>\n<ul>\n<li>before the configure script is executed (pre-configure-hook)</li>\n<li>before the make process is executed (pre-make-hook)</li>\n<li>after the make process is finished (post-make-hook)</li>\n</ul>\n</blockquote>\n<p>Each option needs to contain the following information</p>\n<blockquote>\n/full/path/to/the/python/module.py:name_of_callable</blockquote>\n<p>where the callable object (here name_of_callable) is expected to take three\nparameters:</p>\n<blockquote>\n<ol>\n<li>The <tt>options</tt> dictionary from the recipe.</li>\n<li>The global <tt>buildout</tt> dictionary.</li>\n<li>A dictionary containing the current <tt>os.environ</tt> augmented with\nthe part specific overrides.</li>\n</ol>\n</blockquote>\n<p>These parameters should provide the callable all the necessary information to\nperform any part specific customization to the build process.</p>\n<p>Let\u2019s create a simple python script to demonstrate the functionality. You can\nnaturally have separate modules for each hook or simply use just one or two\nhooks. Here we use just a single module.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; hooks = tmpdir('hooks')\n&gt;&gt;&gt; write(hooks, 'customhandlers.py',\n... \"\"\"\n... import logging\n... log = logging.getLogger('hook')\n...\n... def preconfigure(options, buildout, environment):\n...     log.info('This is pre-configure-hook!')\n...\n... def premake(options, buildout, environment):\n...     log.info('This is pre-make-hook!')\n...\n... def postmake(options, buildout, environment):\n...     log.info('This is post-make-hook!')\n...\n... \"\"\")\n</pre>\n</blockquote>\n<p>and a new buildout to try it out</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%(package_path)s\n... pre-configure-hook = %(module)s:preconfigure\n... pre-make-hook = %(module)s:premake\n... post-make-hook = %(module)s:postmake\n... \"\"\" % dict(package_path=package_path,\n...            module=join(hooks, 'customhandlers.py')))\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\npackage: Executing pre-configure-hook\nhook: This is pre-configure-hook!\nconfigure --prefix=/sample_buildout/parts/package\npackage: Executing pre-make-hook\nhook: This is pre-make-hook!\nbuilding package\ninstalling package\npackage: Executing post-make-hook\nhook: This is post-make-hook!\n</pre>\n</blockquote>\n<dl>\n<dt>If you prefer to use shell script, then try these options:</dt>\n<dd>pre-configure\npre-build\npre-install\npost-install</dd>\n</dl>\n<p>Let\u2019s create a buildout to use these options.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... pre-configure = echo \"Configure part: ${:_buildout_section_name_}\"\n... pre-build = echo \"OH OH OH\" &gt; a.txt\n... pre-install = cat a.txt\n... post-install = rm -f a.txt &amp;&amp; echo \"Finished.\"\n... \"\"\" % package_path)\n</pre>\n</blockquote>\n<p>This will run pre-configure, pre-build, pre-install, post-install as\nshell command in the corresponding stage.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\npackage: Executing pre-configure\nConfigure part: package\nconfigure --prefix=/sample_buildout/parts/package\npackage: Executing pre-build\nbuilding package\npackage: Executing pre-install\nOH OH OH\ninstalling package\npackage: Executing post-install\nFinished.\n</pre>\n</blockquote>\n</div>\n<div id=\"building-in-multi-platforms\">\n<h2><a href=\"#id40\" rel=\"nofollow\">Building in multi-platforms</a></h2>\n<p>The recipe can specify build options for each platform. For example,</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... pre-configure = echo \"Configure in common platform\"\n... post-install = echo \"Finished.\"\n...\n... [package:cygwin]\n... pre-configure = echo \"Configure in the CYGWIN platform\"\n... pre-install = echo \"Installing in the CYGWIN\"\n... post-install = echo -n \"CYGWIN \" &amp;&amp; ${package:post-install}\n... \"\"\" % package_path)\n</pre>\n</blockquote>\n<p>In the linux, the recipe gets the options from part \u2018package\u2019, there\nare only <tt><span class=\"pre\">pre-configure</span></tt> and <tt><span class=\"pre\">post-install</span></tt>. the output will be</p>\n<blockquote>\n#&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\npackage: Executing pre-configure\nConfigure part: Configure in common platform\nconfigure \u2013prefix=/sample_buildout/parts/package\nbuilding package\ninstalling package\npackage: Executing post-install\nFinished.</blockquote>\n<p>In the cygwin, the recipe merges the options in the parts \u2018package\u2019\nand \u2018package:cygwin\u2019.</p>\n</div>\n<div id=\"union-prefix\">\n<h2><a href=\"#id41\" rel=\"nofollow\">Union prefix</a></h2>\n<p>If the recipe finds <tt>prefix</tt> option in the section buildout, it will</p>\n<blockquote>\n<ul>\n<li>First, use this <tt>prefix</tt> as configure prefix, if\n<tt><span class=\"pre\">configure-command</span></tt> isn\u2019t set in the part, or <tt><span class=\"pre\">make-binary</span></tt>\nequals \u2018make\u2019 and <tt><span class=\"pre\">make-target</span></tt> includes pattern \u2018s+install.*\u2019</li>\n<li>Second, return all the new installed files in the prefix when the\nrecipe returns after intall.</li>\n<li>Finally, change some environment variables(See first section).</li>\n</ul>\n</blockquote>\n<p>Let\u2019s see what happens when set prefix in the buildout section:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n... prefix = ${buildout:directory}/mylocal\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... pre-configure = mkdir -p \"${buildout:prefix}\"\n... \"\"\" % package_path)\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\npackage: Executing pre-configure\nconfigure --prefix=/sample_buildout/mylocal\nbuilding package\ninstalling package\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>Look these environment variables and prefix\u2019s value, you know what\u2019s\nthe differences.</p>\n<p>If part has its own <tt>prefix</tt>, it will disable above behavious. For\nexample,</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n... prefix = ${buildout:directory}/mylocal\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... prefix = ${buildout:parts-directory}/package\n... url = file://%s\n... pre-configure = rm -rf \"${buildout:prefix}\"\n... post-install = test -d \"${buildout:prefix}\" || echo \"None\"\n... \"\"\" % package_path)\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\npackage: Executing pre-configure\nconfigure --prefix=/sample_buildout/parts/package\nbuilding package\ninstalling package\npackage: Executing post-install\nNone\n</pre>\n</blockquote>\n<p>Then no extra environment variables such as CFLAGS etc., and no\n${buildout:prefix} directory is created.</p>\n<p>The following example shows how to install package, package-2 in one\nprefix:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package package-2\n... prefix = ${buildout:directory}/mylocal\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x &gt;\"${buildout:prefix}/a.txt\"\n... [package-2]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x &gt;\"${buildout:prefix}/b.txt\"; echo\n... \"\"\" % (package_path, package_path))\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\nconfigure --prefix=/sample_buildout/mylocal\nbuilding package\npackage: Executing pre-install\ninstalling package\nInstalling package-2.\nconfigure --prefix=/sample_buildout/mylocal\nbuilding package\npackage-2: Executing pre-install\n&lt;BLANKLINE&gt;\ninstalling package\n&lt;BLANKLINE&gt;\n</pre>\n<pre>&gt;&gt;&gt; ls('mylocal')\n- a.txt\n- b.txt\n</pre>\n</blockquote>\n<p>Next we unintall package-2, it should only remove file b.txt (which seems broken currently\nas nothing it is removing):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n... prefix = ${buildout:directory}/mylocal\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... pre-install = sleep 2; mkdir -p \"${buildout:prefix}\" ; echo x &gt;\"${buildout:prefix}/a.txt\"\n... \"\"\" % package_path)\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package-2.\nUpdating package.\n</pre>\n<pre>&gt;&gt;&gt; ls('mylocal')\n- a.txt\n- b.txt\n</pre>\n</blockquote>\n</div>\n<div id=\"magic-prefix\">\n<h2><a href=\"#id42\" rel=\"nofollow\">Magic prefix</a></h2>\n<p>If configure-command is set, the recipe wouldn\u2019t insert \u201c\u2013prefix\u201d\ninto configure-options. Then it checks whether both of make-binary and\nmake-targets aren\u2019t set, if so, string \u201cprefix=xxx\u201d will be appended\nin the make-targets. xxx is the final prefix of this recipe. We call\nit Magic Prefix.</p>\n<p>In these options magic prefix can be represented by <tt>%(prefix)s</tt>:</p>\n<blockquote>\n<tt><span class=\"pre\">configure-command</span></tt>, <tt><span class=\"pre\">configure-options</span></tt>,\n<tt><span class=\"pre\">make-binary</span></tt>, <tt><span class=\"pre\">make-options</span></tt>, <tt><span class=\"pre\">make-targets</span></tt>,\n<tt><span class=\"pre\">pre-configure</span></tt>, <tt><span class=\"pre\">pre-build</span></tt>, <tt><span class=\"pre\">pre-install</span></tt>, <tt><span class=\"pre\">post-install</span></tt></blockquote>\n<p>For example:</p>\n<pre>[bzip2]\npost-install = rm %(prefix)s/*.h\n</pre>\n<p>The other part can refer to magic prefix of this part by\n${part:prefix}, it will return the magic prefix, other than literal\nvalue in the part section. For example:</p>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package package-2\n... prefix = /mytemp\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... configure-command = true\n... make-binary = true\n...\n... [package-2]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... configure-command = true\n... make-binary = true\n... post-install = echo package magic prefix is ${package:prefix}\n... \"\"\" % (package_path, package_path))\n\n&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\nInstalling package-2.\npackage-2: Executing post-install\npackage magic prefix is /mytemp\n&lt;BLANKLINE&gt;\n</pre>\n<p>Here it\u2019s another sample, we change Makefile before installing so it\ncan display \u201cprefix\u201d value in the stdout.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... configure-command = ./configure\n... pre-install = sed -i -e \"s/installing package/installing package at \\\\$\\\\$prefix /g\" Makefile\n... \"\"\" % package_path)\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package-2.\nUninstalling package.\nInstalling package.\nconfigure\nbuilding package\npackage: Executing pre-install\ninstalling package at /sample_buildout/parts/package\n</pre>\n</blockquote>\n<p>You even can include pattern %(prefix)s in this option, it will be\nreplaced with the recipe final prefix.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... configure-command = ./configure\n... make-targets = install-lib prefix=%%(prefix)s\n... pre-install = sed -i -e \"s/installing package/installing package at \\\\$\\\\$prefix /g\" Makefile\n... \"\"\" % package_path)\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout))\nUninstalling package.\nInstalling package.\nconfigure\nbuilding package\npackage: Executing pre-install\ninstalling package at /sample_buildout/parts/package -lib\n</pre>\n</blockquote>\n</div>\n<div id=\"install-shared-package\">\n<h2><a href=\"#id43\" rel=\"nofollow\">Install shared package</a></h2>\n<p>Use option <tt>shared</tt> to install a shared package.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import subprocess\n&gt;&gt;&gt; shared_dir = tmpdir('shared')\n&gt;&gt;&gt; another_shared_dir = tmpdir('another_shared_dir')\n&gt;&gt;&gt; __tear_downs.insert(0, lambda: subprocess.call(\n...     ('chmod', '-R', 'u+w', shared_dir, another_shared_dir)))\n</pre>\n</blockquote>\n<p>If no <tt><span class=\"pre\">shared-part-list</span></tt> is set, and <tt>shared</tt> is True, <tt>shared</tt> feature\nis not used.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... shared = True\n... \"\"\" % package_path)\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout)) #doctest:+ELLIPSIS\nUninstalling package.\nInstalling package.\nconfigure --prefix=/sample_buildout/parts/package\nbuilding package\ninstalling package\n</pre>\n</blockquote>\n<p>If <tt><span class=\"pre\">shared-part-list</span></tt> is set and shared is True, build package failed, the\nbuild directory is removed, a build directory__compile__ is left for\ndebugging.\nAlso a shell script with the environment variable is created, so that\ndeveloper can try same build process as the recipe tried.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; os.rename(package_path, package_path + '.bak')\n&gt;&gt;&gt; import tarfile\n&gt;&gt;&gt; from io import BytesIO\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; with tarfile.open(package_path, 'w:gz') as tar:\n...   configure = b'invalid'\n...   info = tarfile.TarInfo('configure.off')\n...   info.size = len(configure)\n...   info.mode = 0o755\n...   tar.addfile(info, BytesIO(configure))\n&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n... shared-part-list = %s\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... shared = True\n... environment =\n...   FOO=bar\n... \"\"\" % (shared_dir, package_path))\n&gt;&gt;&gt; print(system(buildout)) #doctest:+ELLIPSIS\npackage: shared at /shared/package/&lt;MD5SUM:0&gt;\nUninstalling package.\nInstalling package.\npackage: Checking whether package is installed at shared path: /shared/package/&lt;MD5SUM:0&gt;\npackage: [ENV] FOO = bar\npackage: Command 'set -e;./configure --prefix=\"/shared/package/&lt;MD5SUM:0&gt;\"' returned non-zero exit status 127.\npackage: Compilation error. The package is left as is at /shared/package/&lt;MD5SUM:0&gt;__compile__ where you can inspect what went wrong.\nA shell script slapos.recipe.build.env.sh has been generated. You can source it in your shell to reproduce build environment.\n/bin/sh: 1: ./configure: not found\nWhile:\n  Installing package.\nError: System error\n&gt;&gt;&gt; import glob\n&gt;&gt;&gt; cat(glob.glob(join(shared_dir, 'package/**__compile__/slapos.recipe.build.env.sh'))[0])\nexport FOO=bar\n...\n</pre>\n</blockquote>\n<p>Next time buildout runs, it detects that the build failed, remove the compile dir and retry.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(system(buildout)) #doctest:+ELLIPSIS\npackage: shared at /shared/package/&lt;MD5SUM:0&gt;\nInstalling package.\npackage: Checking whether package is installed at shared path: /shared/package/&lt;MD5SUM:0&gt;\npackage: [ENV] FOO = bar\npackage: Removing already existing directory /shared/package/&lt;MD5SUM:0&gt;__compile__\npackage: Command 'set -e;./configure --prefix=\"/shared/package/&lt;MD5SUM:0&gt;\"' returned non-zero exit status 127.\npackage: Compilation error. The package is left as is at /shared/package/&lt;MD5SUM:0&gt;__compile__ where you can inspect what went wrong.\nA shell script slapos.recipe.build.env.sh has been generated. You can source it in your shell to reproduce build environment.\n/bin/sh: 1: ./configure: not found\nWhile:\n  Installing package.\nError: System error\n</pre>\n</blockquote>\n<p>But we had a bug with version v0.11 is that if build was interrupted in the middle of the build of a\nshared part. The shared part was left in an inconsistent state that looked like installation succeeded.</p>\n<p>Let\u2019s simulate a scenario where buildout is terminated in the middle of a build.\nFor this, we need a package that takes a lot of time to install.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; with tarfile.open(package_path, 'w:gz') as tar:\n...   configure = b'#!/bin/sh\\necho configure started\\nsleep 300;'\n...   info = tarfile.TarInfo('configure')\n...   info.size = len(configure)\n...   info.mode = 0o755\n...   tar.addfile(info, BytesIO(configure))\n</pre>\n</blockquote>\n<p>We also need a bit more complex method to run buildout so that we send a termination signal in the\nmiddle of build process.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import signal\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; buildout_process = subprocess.Popen(buildout, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n&gt;&gt;&gt; output_line = ''\n&gt;&gt;&gt; for _ in range(10):\n...   time.sleep(1)\n...   output_line = buildout_process.stdout.readline()\n...   if output_line and b'configure started' in output_line:\n...     print ('configure started')\n...     buildout_process.send_signal(signal.SIGKILL)\n...     print ('buildout terminated')\n...     break\nconfigure started\nbuildout terminated\n&gt;&gt;&gt; _ = buildout_process.wait()\n</pre>\n</blockquote>\n<p>If we run buildout again, the compile dir is removed again and installation is retried. This time\ninstallation can succeed.</p>\n<p>This was not the case in version 0.11 of this recipe. If installation of a shared part failed, this was\nnot detected and the part was considered as installed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; os.rename(package_path + '.bak', package_path)\n&gt;&gt;&gt; print(system(buildout)) #doctest:+ELLIPSIS\npackage: shared at /shared/package/&lt;MD5SUM:0&gt;\nInstalling package.\npackage: Checking whether package is installed at shared path: /shared/package/&lt;MD5SUM:0&gt;\npackage: [ENV] FOO = bar\npackage: Removing already existing directory /shared/package/&lt;MD5SUM:0&gt;__compile__\nconfigure --prefix=/shared/package/&lt;MD5SUM:0&gt;\nbuilding package\ninstalling package\n</pre>\n</blockquote>\n<p>If <tt><span class=\"pre\">shared-part-list</span></tt> is set as an option in buildout section and\n<tt>shared</tt> is True, package will be installed in shared_part/package\nand a hash of the recipe\u2019s configuration options.</p>\n<p>There can be multiple path listed in <tt><span class=\"pre\">shared-part-list</span></tt>, the recipe\nwill look in each of these paths if package was already installed and\nif not, it will install the package in the last entry the last entry\nfrom the list of <tt><span class=\"pre\">shared-part-list</span></tt>.</p>\n<p>If package was already installed in any of the <tt><span class=\"pre\">shared-part-list</span></tt> used, it will be\nused instead of installing if one package has been installed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; remove('.installed.cfg')\n&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n... shared-part-list =\n...   %s\n...   not/exists\n...   %s\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... shared = True\n... environment =\n...   FOO=bar\n... \"\"\" % (shared_dir, another_shared_dir, package_path))\n&gt;&gt;&gt; print(system(buildout)) #doctest:+ELLIPSIS\npackage: shared at /shared/package/&lt;MD5SUM:0&gt;\nInstalling package.\npackage: Checking whether package is installed at shared path: /shared/package/&lt;MD5SUM:0&gt;\npackage: This shared package has been installed by other package\n</pre>\n</blockquote>\n<dl>\n<dt>If options change, reinstall in different location:</dt>\n<dd><pre>&gt;&gt;&gt; write('buildout.cfg',\n... \"\"\"\n... [buildout]\n... newest = false\n... parts = package\n... shared-part-list = %s\n...\n... [package]\n... recipe = slapos.recipe.cmmi\n... url = file://%s\n... shared =True\n... change = True\n... \"\"\" % (shared_dir, package_path))\n</pre>\n<pre>&gt;&gt;&gt; print(system(buildout)) #doctest:+ELLIPSIS\npackage: shared at /shared/package/&lt;MD5SUM:1&gt;\nUninstalling package.\nInstalling package.\npackage: Checking whether package is installed at shared path: /shared/package/&lt;MD5SUM:1&gt;\nconfigure --prefix=/shared/package/&lt;MD5SUM:1&gt;\nbuilding package\ninstalling package\n</pre>\n</dd>\n</dl>\n<p>For even more specific needs you can write your own recipe that uses\n<tt>slapos.recipe.cmmi</tt> and set the <tt><span class=\"pre\">keep-compile-dir</span></tt> option to <tt>true</tt>.\nYou can then continue from where this recipe finished by reading the location\nof the compile directory from <tt><span class=\"pre\">options['compile-directory']</span></tt> from your own\nrecipe.</p>\n</div>\n<div id=\"contributors\">\n<h2><a href=\"#id44\" rel=\"nofollow\">Contributors</a></h2>\n<ul>\n<li>Kai Lautaportti (dokai), Author</li>\n<li>C\u00e9dric de Saint Martin (desaintmartin)</li>\n<li>Marc Abramowitz (msabramo)</li>\n<li>Nicolas Dumazet (nicdumz)</li>\n<li>Guy Rozendorn (grzn)</li>\n<li>Marco Mariani (mmariani)</li>\n<li>galpin</li>\n</ul>\n</div>\n<div id=\"download\">\n<h2><a href=\"#id45\" rel=\"nofollow\">Download</a></h2>\n</div>\n\n          </div>"}, "last_serial": 7195530, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "ded57ba367dffa91e8b59015761be1c5", "sha256": "85ef3084a38be76a08a1fc93bed3fe0a29b85a1a7fb23147c6474323ce519540"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.1.tar.gz", "has_sig": false, "md5_digest": "ded57ba367dffa91e8b59015761be1c5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45052, "upload_time": "2013-04-12T16:10:04", "upload_time_iso_8601": "2013-04-12T16:10:04.673499Z", "url": "https://files.pythonhosted.org/packages/c8/6b/7f943ba52edf442ea78440e4c8866dc1befa97c6e043bec38cef0c3928c4/slapos.recipe.cmmi-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "f7ef1bff9202b06bd8eefbc73f374528", "sha256": "0a83ffd5f16a2258f224f7be235eed8cf4a4d0d18519abdb2d9414c9d857199d"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.1.1.tar.gz", "has_sig": false, "md5_digest": "f7ef1bff9202b06bd8eefbc73f374528", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 45346, "upload_time": "2013-05-02T08:56:15", "upload_time_iso_8601": "2013-05-02T08:56:15.378206Z", "url": "https://files.pythonhosted.org/packages/1f/b8/8b281afaf548f0c74083816e3410be0ffe33e344f21d55fb7d8078316056/slapos.recipe.cmmi-0.1.1.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "30ef08e87724ad53d1b283c1e99e61ae", "sha256": "3b8fe5753144422270029c805942814f0f6986b5c5ea0e8bc8adca36b62e3e2e"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.2.tar.gz", "has_sig": false, "md5_digest": "30ef08e87724ad53d1b283c1e99e61ae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47756, "upload_time": "2013-11-07T16:25:56", "upload_time_iso_8601": "2013-11-07T16:25:56.280216Z", "url": "https://files.pythonhosted.org/packages/fc/0b/837e67dd0cdd4b615ffaf7342623084cfd4c64014720ef15e0d0ea13bd35/slapos.recipe.cmmi-0.2.tar.gz", "yanked": false}], "0.10": [{"comment_text": "", "digests": {"md5": "8392b368b32af858b0daca697de413b8", "sha256": "ec4e898f57875679b3b2e5caee4aa89b131192e3f7e666f4e08f7708cacb4075"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.10.tar.gz", "has_sig": true, "md5_digest": "8392b368b32af858b0daca697de413b8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40374, "upload_time": "2018-11-30T14:58:53", "upload_time_iso_8601": "2018-11-30T14:58:53.834842Z", "url": "https://files.pythonhosted.org/packages/3d/b2/fb8f6b7e00eab68637d07707f2d6feff842d218e13b08390f2d87a94a3b0/slapos.recipe.cmmi-0.10.tar.gz", "yanked": false}], "0.11": [{"comment_text": "", "digests": {"md5": "0dea73e2580d03b7b563a9749e44dcf4", "sha256": "9f8434674970a84a94a6fc74b155aa11c770c335a522bf1d42d94efa7e8a6aab"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.11.tar.gz", "has_sig": true, "md5_digest": "0dea73e2580d03b7b563a9749e44dcf4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42241, "upload_time": "2019-10-03T03:42:24", "upload_time_iso_8601": "2019-10-03T03:42:24.470746Z", "url": "https://files.pythonhosted.org/packages/68/0e/12c90f1eee836199455e023d6208a5168ddd6fae96f1192ef32bed2d52f4/slapos.recipe.cmmi-0.11.tar.gz", "yanked": false}], "0.12": [{"comment_text": "", "digests": {"md5": "196773b32ed7f5bf1db4c85a8c50c63f", "sha256": "57c15b2a43c5e13fe06b7390fde80a79d7eb77906e8e1094be29bdd32cc534bf"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.12.tar.gz", "has_sig": true, "md5_digest": "196773b32ed7f5bf1db4c85a8c50c63f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42514, "upload_time": "2019-12-12T01:40:20", "upload_time_iso_8601": "2019-12-12T01:40:20.171309Z", "url": "https://files.pythonhosted.org/packages/dc/b7/1dd3694cbd86ea3a754210cef7e3954e0a3c98a8e899488951d84a81588d/slapos.recipe.cmmi-0.12.tar.gz", "yanked": false}], "0.13": [{"comment_text": "", "digests": {"md5": "0be7a488b2706eee70e0fb4917acc0c1", "sha256": "d3abdcda118f0a884e1da776748f5f8f0162f5f18ab7b4cd3a2dc4a92291b116"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.13.tar.gz", "has_sig": true, "md5_digest": "0be7a488b2706eee70e0fb4917acc0c1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42680, "upload_time": "2020-03-31T04:22:50", "upload_time_iso_8601": "2020-03-31T04:22:50.101428Z", "url": "https://files.pythonhosted.org/packages/6d/ad/a6501563846666f2dbffc2b9e042f34b62dc78608f626da82a199f98d156/slapos.recipe.cmmi-0.13.tar.gz", "yanked": false}], "0.14": [{"comment_text": "", "digests": {"md5": "bd8aeff0668d2c775831491d83b0a9f9", "sha256": "af8b27c1e3c72ae0e47276758950316f8d2ee740630ae48cdacd01e17c060b8d"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.14.tar.gz", "has_sig": true, "md5_digest": "bd8aeff0668d2c775831491d83b0a9f9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41225, "upload_time": "2020-04-22T16:43:01", "upload_time_iso_8601": "2020-04-22T16:43:01.178003Z", "url": "https://files.pythonhosted.org/packages/6e/d1/e053ce74591537b180591b23985cc53df41c22ab4ee2a6bfe4c88718b047/slapos.recipe.cmmi-0.14.tar.gz", "yanked": false}], "0.15": [{"comment_text": "", "digests": {"md5": "d5e33fa9942a83ea6fef8c8d4f9b8bc2", "sha256": "d3449df382e6d3275c7dbf1b39224b88f60b705d18c796b16bcd65a8491802c1"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.15.tar.gz", "has_sig": true, "md5_digest": "d5e33fa9942a83ea6fef8c8d4f9b8bc2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41495, "upload_time": "2020-04-23T15:40:58", "upload_time_iso_8601": "2020-04-23T15:40:58.415990Z", "url": "https://files.pythonhosted.org/packages/0e/cc/b67a1df0b376eb84c18ffc4954f4f169791bd0f4e6c1d5ed76eb15fa1a6a/slapos.recipe.cmmi-0.15.tar.gz", "yanked": false}], "0.16": [{"comment_text": "", "digests": {"md5": "bbd91a038046dea8b78a529092edfca6", "sha256": "b2e89c80b17a1218a5332f5d25fe2038866c524673b55541409eb19ce1177cd0"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.16.tar.gz", "has_sig": true, "md5_digest": "bbd91a038046dea8b78a529092edfca6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44096, "upload_time": "2020-05-08T08:46:19", "upload_time_iso_8601": "2020-05-08T08:46:19.137701Z", "url": "https://files.pythonhosted.org/packages/52/d1/6049f8c89bcbdf2b73e4936eedde46fe08a298a6cd1e284f500453503f46/slapos.recipe.cmmi-0.16.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "e7f3e8cb73f229011b26e8be64840764", "sha256": "931a477f8916a60df1f88ce73286932ca97b78ca922a0179006944f7b519e41c"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.4.tar.gz", "has_sig": false, "md5_digest": "e7f3e8cb73f229011b26e8be64840764", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52286, "upload_time": "2017-03-08T16:06:51", "upload_time_iso_8601": "2017-03-08T16:06:51.168211Z", "url": "https://files.pythonhosted.org/packages/e7/74/04c052d17c18f33307cdf84c56b4454dcddbb411b772f49fc7c764c5ecd8/slapos.recipe.cmmi-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "cc71eeadf5d2ea4044af5d644529cdf6", "sha256": "ce6f8ca57dae40bad8d9168adaf4ff79a87a978e1cc92b7c251ce5efcdbda080"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.5.tar.gz", "has_sig": false, "md5_digest": "cc71eeadf5d2ea4044af5d644529cdf6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 60278, "upload_time": "2017-04-07T08:41:26", "upload_time_iso_8601": "2017-04-07T08:41:26.638808Z", "url": "https://files.pythonhosted.org/packages/ef/7c/69ee0b9c2fee0842650073c1af97f99a571d6dd8a57c3d63306a02c763f6/slapos.recipe.cmmi-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "4c5b3f5616b13621106bc194b707b281", "sha256": "f9e9af85a63e36b2ab0dd0cf7073731108c64c8b1136ca48bca0c4b4dd8c02a0"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.6.tar.gz", "has_sig": true, "md5_digest": "4c5b3f5616b13621106bc194b707b281", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38226, "upload_time": "2017-06-06T09:08:50", "upload_time_iso_8601": "2017-06-06T09:08:50.282486Z", "url": "https://files.pythonhosted.org/packages/30/0a/384efa5d113145e9896e1ce20812e5aea9db28fc33dd7792c7ce9a4f3507/slapos.recipe.cmmi-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "dc0ff633f1535b19ad4c6cc37f77262b", "sha256": "ca7a1ae56fc56e3268c3f247ea9802e326668df88b37d13f70c7bf4eab193e62"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.7.tar.gz", "has_sig": true, "md5_digest": "dc0ff633f1535b19ad4c6cc37f77262b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38439, "upload_time": "2017-06-06T09:25:51", "upload_time_iso_8601": "2017-06-06T09:25:51.048331Z", "url": "https://files.pythonhosted.org/packages/94/75/05025b3351e5f36b26cad23d7e70bf9660462b38f6c3d9e126e2d5a83855/slapos.recipe.cmmi-0.7.tar.gz", "yanked": false}], "0.8": [{"comment_text": "", "digests": {"md5": "217fe8a96ff851b5798468729026502a", "sha256": "e639e5a7def46c168f60dfc344bd7b97fbd0e5c6df94d314286d92cffbf102a1"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.8.tar.gz", "has_sig": false, "md5_digest": "217fe8a96ff851b5798468729026502a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52664, "upload_time": "2018-08-27T09:10:18", "upload_time_iso_8601": "2018-08-27T09:10:18.307438Z", "url": "https://files.pythonhosted.org/packages/c7/ff/5da2b4c7016332f1c05364018d7a182bef3fbc090d59e079377f35b5b23a/slapos.recipe.cmmi-0.8.tar.gz", "yanked": false}], "0.9": [{"comment_text": "", "digests": {"md5": "0ee0a3f1dd45698e1a03747bebbc44f6", "sha256": "d9e66ad6de8e88ca18da56c5c22ae5e5ff46640b6519bf6c4a5fc6b480e0006f"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.9.tar.gz", "has_sig": true, "md5_digest": "0ee0a3f1dd45698e1a03747bebbc44f6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40271, "upload_time": "2018-10-29T16:09:39", "upload_time_iso_8601": "2018-10-29T16:09:39.616870Z", "url": "https://files.pythonhosted.org/packages/06/1d/390905085d3f46be4b52fbbc85536e2c6bb673444409cdd2fae647a1793c/slapos.recipe.cmmi-0.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bbd91a038046dea8b78a529092edfca6", "sha256": "b2e89c80b17a1218a5332f5d25fe2038866c524673b55541409eb19ce1177cd0"}, "downloads": -1, "filename": "slapos.recipe.cmmi-0.16.tar.gz", "has_sig": true, "md5_digest": "bbd91a038046dea8b78a529092edfca6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44096, "upload_time": "2020-05-08T08:46:19", "upload_time_iso_8601": "2020-05-08T08:46:19.137701Z", "url": "https://files.pythonhosted.org/packages/52/d1/6049f8c89bcbdf2b73e4936eedde46fe08a298a6cd1e284f500453503f46/slapos.recipe.cmmi-0.16.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:08:33 2020"}