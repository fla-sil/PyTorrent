{"info": {"author": "Mirko Rossini", "author_email": "mirko.rossini@ymail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5"], "description": "=====\nzanna\n=====\n\n\n.. image:: https://img.shields.io/pypi/v/zanna.svg\n        :target: https://pypi.python.org/pypi/zanna\n\n.. image:: https://img.shields.io/travis/MirkoRossini/zanna.svg\n        :target: https://travis-ci.org/MirkoRossini/zanna\n\n.. image:: https://readthedocs.org/projects/zanna/badge/?version=latest\n        :target: https://zanna.readthedocs.io/en/latest/?badge=latest\n        :alt: Documentation Status\n\n.. image:: https://pyup.io/repos/github/mirkorossini/zanna/shield.svg\n     :target: https://pyup.io/repos/github/mirkorossini/zanna/\n     :alt: Updates\n\n.. image:: https://pyup.io/repos/github/mirkorossini/zanna/python-3-shield.svg\n     :target: https://pyup.io/repos/github/mirkorossini/zanna/\n     :alt: Python 3\n\nSimple Dependency Injection library.\nSupports python 3.5+ and makes full use of the typing annotations.\nThe design is pythonic but inspired by Guice in many aspects.\n\n* Free software: BSD license\n* Documentation: https://zanna.readthedocs.io.\n\nMotivation\n==========\n\nZanna is meant to be a modern (3.5+), well maintained injection library for Python.\n\n\nFeatures\n========\n\n* Support for typing annotations\n* Decorators are not mandatory: all the injection logic can be outside your modules\n* Supports injection by name\n* Instances can be bound directly, useful when testing (i.e. by override bindings with mocks)\n* No autodiscover for performance reasons and to avoid running into annoying bugs\n\nUsage\n=====\n\nInjecting by variable name\n--------------------------\n\nThe basic form of injection is performed by variable name.\nThe injector expects a list of modules (any callable that takes a Binder as argument).\nYou can get the bound instance by calling get_instance\n\n..  code-block:: python\n\n    from zanna import Injector, Binder\n\n    def mymodule(binder: Binder) -> None:\n        binder.bind_to(\"value\", 3)\n\n    injector = Injector(mymodule)\n    assert injector.get_instance(\"value\") == 3\n\nZanna will automatically inject the value into arguments with the same name:\n\n..  code-block:: python\n\n    from zanna import Injector, Binder\n\n    def mymodule(binder: Binder) -> None:\n        binder.bind_to(\"value\", 3)\n\n    class ValueConsumer:\n        def __init__(self, value):\n            self.value = value\n\n    injector = Injector(mymodule)\n    assert injector.get_instance(ValueConsumer).value == 3\n\n\nInjecting by type annotation\n----------------------------\n\nZanna also makes use of python typing annotations to find the right instance to inject.\n\n..  code-block:: python\n\n    from zanna import Injector, Binder\n\n    class ValueClass:\n        def __init__(self, the_value: int):\n            self.the_value = the_value\n\n    class ValueConsumer:\n        def __init__(self, value_class_instance: ValueClass):\n            self.value_class_instance = value_class_instance\n\n    def mymodule(binder: Binder) -> None:\n        binder.bind_to(\"the_value\", 3)\n        binder.bind(ValueClass)\n\n    injector = Injector(mymodule)\n    assert injector.get_instance(ValueConsumer).value_class_instance.the_value == 3\n\n\nSingleton or not singleton?\n---------------------------\n\nInstances provided by the injector are always singletons, meaning that the __init__ method of\nthe class will be called only the first time, and every subsequent call of get_instance will\nreturn the same instance:\n\n..  code-block:: python\n\n    from zanna import Injector\n\n    class MyClass:\n        pass\n    injector = Injector(lambda binder: binder.bind(MyClass))\n    assert injector.get_instance(MyClass) == injector.get_instance(MyClass)\n\n\n\nUse providers for more complex use cases\n----------------------------------------\n\nBinder instances can be used to bind providers. A provider is any callable that takes\nany number of arguments and returns any type. The injector will try to inject all the necessary\narguments. Providers can be bound explicitely or implicitely (in which case zanna will use the\nreturn annotation to bind by type).\n\n..  code-block:: python\n\n    from zanna import Injector, Binder\n\n    class AValueConsumer:\n        def __init__(self, value: int):\n            self.value = value\n\n    def explicit_provider(a_value: int) -> int:\n        return a_value + 100\n\n    def implicit_provider(value_plus_100: int) -> AValueConsumer:\n        return AValueConsumer(value_plus_100)\n\n    def mymodule(binder: Binder) -> None:\n        binder.bind_to(\"a_value\", 3)\n        binder.bind_provider(\"value_plus_100\", explicit_provider)\n        binder.bind_provider(implicit_provider)\n\n    injector = Injector(mymodule)\n    assert injector.get_instance(AValueConsumer).value == 103\n\n\nOverride existing bindings\n--------------------------\n\nBindings can be overridden. Overriding a non-existent binding will result in a ValueError being raised.\n\nOverride bindings is extremely useful when testing, as any part of your stack can be replaced with a mock.\n\n\n..  code-block:: python\n\n    from zanna import Injector, Binder\n    from unittest.mock import MagicMock\n\n    class ValueClass:\n        def __init__(self):\n            pass\n        def retrieve_something(self):\n            return ['some', 'thing']\n\n    class ValueConsumer:\n        def __init__(self, value: ValueClass):\n            self.value = value\n\n\n    def mymodule(binder: Binder) -> None:\n        binder.bind(ValueClass)\n\n    injector = Injector(mymodule)\n    assert injector.get_instance(ValueConsumer).value.retrieve_something() == ['some', 'thing']\n\n    def module_overriding_value_class(binder: Binder) -> None:\n        mock_value_class = MagicMock(ValueClass)\n        mock_value_class.retrieve_something.return_value = ['mock']\n        binder.override_binding(ValueClass, mock_value_class)\n\n    injector = Injector(mymodule, module_overriding_value_class)\n    assert injector.get_instance(ValueConsumer).value.retrieve_something() == ['mock']\n\n\nUsing the decorators\n--------------------\n\nOne of the advantages of using Zanna over other solutions is that it doesn't force you\nto pollute your code by mixing in the injection logic.\n\nIf you are working on a small project and would like to handle part (or all) of the\ninjection logic using decorators instead of modules, Zanna supports that as well.\n\nInternally, Zanna creates a module that sets up the bindings as indicated by the decorators\n(in a random order).\n\nAll Injectors initialized with use_decorators=True will run that module first on their Binder.\n\nZanna supports the following decorators:\n\n* decorators.provider, which takes a provided annotated with an appropriate return type\n* decorators.provider_for, which can be given the name or the class of the instance provided\n* decorators.inject, to annotate class to be bound/injected\n\nHere's an example:\n\n..  code-block:: python\n\n    from zanna import Injector\n    from zanna import decorators\n    class Thing:\n        pass\n\n    @decorators.provider_for(\"value\")\n    def provide_value():\n        return 3\n\n    @decorators.provider\n    def provide_thing() -> Thing:\n        return Thing()\n\n\n    @decorators.inject\n    class OtherThing:\n        def __init__(self, value, thing:Thing):\n            self.value = value\n            self.thing = thing\n\n    inj = Injector(use_decorators=True)\n    otherthing = inj.get_instance(OtherThing)\n    assert otherthing.value == 3\n    assert isinstance(otherthing.thing, Thing)\n    assert isinstance(otherthing, OtherThing)\n\n\nCredits\n-------\n\nThis package was created with Cookiecutter_ and the `audreyr/cookiecutter-pypackage`_ project template.\n\n.. _Cookiecutter: https://github.com/audreyr/cookiecutter\n.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage\n\n\n\n=======\nHistory\n=======\n\n* 0.1.0 (2016-10-13)\n* 0.3.1 (2017-01-21)", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/MirkoRossini/zanna", "keywords": "zanna", "license": "BSD license", "maintainer": "", "maintainer_email": "", "name": "zanna", "package_url": "https://pypi.org/project/zanna/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/zanna/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/MirkoRossini/zanna"}, "release_url": "https://pypi.org/project/zanna/0.3.1/", "requires_dist": null, "requires_python": "", "summary": "Simple Dependency Injection library", "version": "0.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"zanna\">\n<h2>zanna</h2>\n<a href=\"https://pypi.python.org/pypi/zanna\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/zanna.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/528276bd32bd47c17bdefbb0e74c25ab8a6f6046/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7a616e6e612e737667\"></a>\n<a href=\"https://travis-ci.org/MirkoRossini/zanna\" rel=\"nofollow\"><img alt=\"https://img.shields.io/travis/MirkoRossini/zanna.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cc943b33538a4095d990773386b471130849f07c/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f4d69726b6f526f7373696e692f7a616e6e612e737667\"></a>\n<a href=\"https://zanna.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/76cf3b357b586618b0636358ff6173e8b55cc431/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f7a616e6e612f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<a href=\"https://pyup.io/repos/github/mirkorossini/zanna/\" rel=\"nofollow\"><img alt=\"Updates\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f28bb67c0fa370973e797d6f70a5551643fb2357/68747470733a2f2f707975702e696f2f7265706f732f6769746875622f6d69726b6f726f7373696e692f7a616e6e612f736869656c642e737667\"></a>\n<a href=\"https://pyup.io/repos/github/mirkorossini/zanna/\" rel=\"nofollow\"><img alt=\"Python 3\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d5d06fc689495e9b1b52437cae5370e24d895b3d/68747470733a2f2f707975702e696f2f7265706f732f6769746875622f6d69726b6f726f7373696e692f7a616e6e612f707974686f6e2d332d736869656c642e737667\"></a>\n<p>Simple Dependency Injection library.\nSupports python 3.5+ and makes full use of the typing annotations.\nThe design is pythonic but inspired by Guice in many aspects.</p>\n<ul>\n<li>Free software: BSD license</li>\n<li>Documentation: <a href=\"https://zanna.readthedocs.io\" rel=\"nofollow\">https://zanna.readthedocs.io</a>.</li>\n</ul>\n<div id=\"motivation\">\n<h3>Motivation</h3>\n<p>Zanna is meant to be a modern (3.5+), well maintained injection library for Python.</p>\n</div>\n<div id=\"features\">\n<h3>Features</h3>\n<ul>\n<li>Support for typing annotations</li>\n<li>Decorators are not mandatory: all the injection logic can be outside your modules</li>\n<li>Supports injection by name</li>\n<li>Instances can be bound directly, useful when testing (i.e. by override bindings with mocks)</li>\n<li>No autodiscover for performance reasons and to avoid running into annoying bugs</li>\n</ul>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<div id=\"injecting-by-variable-name\">\n<h4>Injecting by variable name</h4>\n<p>The basic form of injection is performed by variable name.\nThe injector expects a list of modules (any callable that takes a Binder as argument).\nYou can get the bound instance by calling get_instance</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">zanna</span> <span class=\"kn\">import</span> <span class=\"n\">Injector</span><span class=\"p\">,</span> <span class=\"n\">Binder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">mymodule</span><span class=\"p\">(</span><span class=\"n\">binder</span><span class=\"p\">:</span> <span class=\"n\">Binder</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind_to</span><span class=\"p\">(</span><span class=\"s2\">\"value\"</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n\n<span class=\"n\">injector</span> <span class=\"o\">=</span> <span class=\"n\">Injector</span><span class=\"p\">(</span><span class=\"n\">mymodule</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">injector</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"s2\">\"value\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">3</span>\n</pre>\n<p>Zanna will automatically inject the value into arguments with the same name:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">zanna</span> <span class=\"kn\">import</span> <span class=\"n\">Injector</span><span class=\"p\">,</span> <span class=\"n\">Binder</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">mymodule</span><span class=\"p\">(</span><span class=\"n\">binder</span><span class=\"p\">:</span> <span class=\"n\">Binder</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind_to</span><span class=\"p\">(</span><span class=\"s2\">\"value\"</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ValueConsumer</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n\n<span class=\"n\">injector</span> <span class=\"o\">=</span> <span class=\"n\">Injector</span><span class=\"p\">(</span><span class=\"n\">mymodule</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">injector</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"n\">ValueConsumer</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">==</span> <span class=\"mi\">3</span>\n</pre>\n</div>\n<div id=\"injecting-by-type-annotation\">\n<h4>Injecting by type annotation</h4>\n<p>Zanna also makes use of python typing annotations to find the right instance to inject.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">zanna</span> <span class=\"kn\">import</span> <span class=\"n\">Injector</span><span class=\"p\">,</span> <span class=\"n\">Binder</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ValueClass</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">the_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">the_value</span> <span class=\"o\">=</span> <span class=\"n\">the_value</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ValueConsumer</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">value_class_instance</span><span class=\"p\">:</span> <span class=\"n\">ValueClass</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">value_class_instance</span> <span class=\"o\">=</span> <span class=\"n\">value_class_instance</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">mymodule</span><span class=\"p\">(</span><span class=\"n\">binder</span><span class=\"p\">:</span> <span class=\"n\">Binder</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind_to</span><span class=\"p\">(</span><span class=\"s2\">\"the_value\"</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">ValueClass</span><span class=\"p\">)</span>\n\n<span class=\"n\">injector</span> <span class=\"o\">=</span> <span class=\"n\">Injector</span><span class=\"p\">(</span><span class=\"n\">mymodule</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">injector</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"n\">ValueConsumer</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">value_class_instance</span><span class=\"o\">.</span><span class=\"n\">the_value</span> <span class=\"o\">==</span> <span class=\"mi\">3</span>\n</pre>\n</div>\n<div id=\"singleton-or-not-singleton\">\n<h4>Singleton or not singleton?</h4>\n<p>Instances provided by the injector are always singletons, meaning that the __init__ method of\nthe class will be called only the first time, and every subsequent call of get_instance will\nreturn the same instance:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">zanna</span> <span class=\"kn\">import</span> <span class=\"n\">Injector</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyClass</span><span class=\"p\">:</span>\n    <span class=\"k\">pass</span>\n<span class=\"n\">injector</span> <span class=\"o\">=</span> <span class=\"n\">Injector</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">binder</span><span class=\"p\">:</span> <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">MyClass</span><span class=\"p\">))</span>\n<span class=\"k\">assert</span> <span class=\"n\">injector</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"n\">MyClass</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">injector</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"n\">MyClass</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"use-providers-for-more-complex-use-cases\">\n<h4>Use providers for more complex use cases</h4>\n<p>Binder instances can be used to bind providers. A provider is any callable that takes\nany number of arguments and returns any type. The injector will try to inject all the necessary\narguments. Providers can be bound explicitely or implicitely (in which case zanna will use the\nreturn annotation to bind by type).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">zanna</span> <span class=\"kn\">import</span> <span class=\"n\">Injector</span><span class=\"p\">,</span> <span class=\"n\">Binder</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">AValueConsumer</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">explicit_provider</span><span class=\"p\">(</span><span class=\"n\">a_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n    <span class=\"k\">return</span> <span class=\"n\">a_value</span> <span class=\"o\">+</span> <span class=\"mi\">100</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">implicit_provider</span><span class=\"p\">(</span><span class=\"n\">value_plus_100</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">AValueConsumer</span><span class=\"p\">:</span>\n    <span class=\"k\">return</span> <span class=\"n\">AValueConsumer</span><span class=\"p\">(</span><span class=\"n\">value_plus_100</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">mymodule</span><span class=\"p\">(</span><span class=\"n\">binder</span><span class=\"p\">:</span> <span class=\"n\">Binder</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind_to</span><span class=\"p\">(</span><span class=\"s2\">\"a_value\"</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind_provider</span><span class=\"p\">(</span><span class=\"s2\">\"value_plus_100\"</span><span class=\"p\">,</span> <span class=\"n\">explicit_provider</span><span class=\"p\">)</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind_provider</span><span class=\"p\">(</span><span class=\"n\">implicit_provider</span><span class=\"p\">)</span>\n\n<span class=\"n\">injector</span> <span class=\"o\">=</span> <span class=\"n\">Injector</span><span class=\"p\">(</span><span class=\"n\">mymodule</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">injector</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"n\">AValueConsumer</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">==</span> <span class=\"mi\">103</span>\n</pre>\n</div>\n<div id=\"override-existing-bindings\">\n<h4>Override existing bindings</h4>\n<p>Bindings can be overridden. Overriding a non-existent binding will result in a ValueError being raised.</p>\n<p>Override bindings is extremely useful when testing, as any part of your stack can be replaced with a mock.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">zanna</span> <span class=\"kn\">import</span> <span class=\"n\">Injector</span><span class=\"p\">,</span> <span class=\"n\">Binder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">unittest.mock</span> <span class=\"kn\">import</span> <span class=\"n\">MagicMock</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ValueClass</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n    <span class=\"k\">def</span> <span class=\"nf\">retrieve_something</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"s1\">'some'</span><span class=\"p\">,</span> <span class=\"s1\">'thing'</span><span class=\"p\">]</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ValueConsumer</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">ValueClass</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">mymodule</span><span class=\"p\">(</span><span class=\"n\">binder</span><span class=\"p\">:</span> <span class=\"n\">Binder</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">ValueClass</span><span class=\"p\">)</span>\n\n<span class=\"n\">injector</span> <span class=\"o\">=</span> <span class=\"n\">Injector</span><span class=\"p\">(</span><span class=\"n\">mymodule</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">injector</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"n\">ValueConsumer</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">retrieve_something</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'some'</span><span class=\"p\">,</span> <span class=\"s1\">'thing'</span><span class=\"p\">]</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">module_overriding_value_class</span><span class=\"p\">(</span><span class=\"n\">binder</span><span class=\"p\">:</span> <span class=\"n\">Binder</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">mock_value_class</span> <span class=\"o\">=</span> <span class=\"n\">MagicMock</span><span class=\"p\">(</span><span class=\"n\">ValueClass</span><span class=\"p\">)</span>\n    <span class=\"n\">mock_value_class</span><span class=\"o\">.</span><span class=\"n\">retrieve_something</span><span class=\"o\">.</span><span class=\"n\">return_value</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'mock'</span><span class=\"p\">]</span>\n    <span class=\"n\">binder</span><span class=\"o\">.</span><span class=\"n\">override_binding</span><span class=\"p\">(</span><span class=\"n\">ValueClass</span><span class=\"p\">,</span> <span class=\"n\">mock_value_class</span><span class=\"p\">)</span>\n\n<span class=\"n\">injector</span> <span class=\"o\">=</span> <span class=\"n\">Injector</span><span class=\"p\">(</span><span class=\"n\">mymodule</span><span class=\"p\">,</span> <span class=\"n\">module_overriding_value_class</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">injector</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"n\">ValueConsumer</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">retrieve_something</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'mock'</span><span class=\"p\">]</span>\n</pre>\n</div>\n<div id=\"using-the-decorators\">\n<h4>Using the decorators</h4>\n<p>One of the advantages of using Zanna over other solutions is that it doesn\u2019t force you\nto pollute your code by mixing in the injection logic.</p>\n<p>If you are working on a small project and would like to handle part (or all) of the\ninjection logic using decorators instead of modules, Zanna supports that as well.</p>\n<p>Internally, Zanna creates a module that sets up the bindings as indicated by the decorators\n(in a random order).</p>\n<p>All Injectors initialized with use_decorators=True will run that module first on their Binder.</p>\n<p>Zanna supports the following decorators:</p>\n<ul>\n<li>decorators.provider, which takes a provided annotated with an appropriate return type</li>\n<li>decorators.provider_for, which can be given the name or the class of the instance provided</li>\n<li>decorators.inject, to annotate class to be bound/injected</li>\n</ul>\n<p>Here\u2019s an example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">zanna</span> <span class=\"kn\">import</span> <span class=\"n\">Injector</span>\n<span class=\"kn\">from</span> <span class=\"nn\">zanna</span> <span class=\"kn\">import</span> <span class=\"n\">decorators</span>\n<span class=\"k\">class</span> <span class=\"nc\">Thing</span><span class=\"p\">:</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"nd\">@decorators</span><span class=\"o\">.</span><span class=\"n\">provider_for</span><span class=\"p\">(</span><span class=\"s2\">\"value\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">provide_value</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"mi\">3</span>\n\n<span class=\"nd\">@decorators</span><span class=\"o\">.</span><span class=\"n\">provider</span>\n<span class=\"k\">def</span> <span class=\"nf\">provide_thing</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Thing</span><span class=\"p\">:</span>\n    <span class=\"k\">return</span> <span class=\"n\">Thing</span><span class=\"p\">()</span>\n\n\n<span class=\"nd\">@decorators</span><span class=\"o\">.</span><span class=\"n\">inject</span>\n<span class=\"k\">class</span> <span class=\"nc\">OtherThing</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">thing</span><span class=\"p\">:</span><span class=\"n\">Thing</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">thing</span> <span class=\"o\">=</span> <span class=\"n\">thing</span>\n\n<span class=\"n\">inj</span> <span class=\"o\">=</span> <span class=\"n\">Injector</span><span class=\"p\">(</span><span class=\"n\">use_decorators</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">otherthing</span> <span class=\"o\">=</span> <span class=\"n\">inj</span><span class=\"o\">.</span><span class=\"n\">get_instance</span><span class=\"p\">(</span><span class=\"n\">OtherThing</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">otherthing</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">==</span> <span class=\"mi\">3</span>\n<span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">otherthing</span><span class=\"o\">.</span><span class=\"n\">thing</span><span class=\"p\">,</span> <span class=\"n\">Thing</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">otherthing</span><span class=\"p\">,</span> <span class=\"n\">OtherThing</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"credits\">\n<h4>Credits</h4>\n<p>This package was created with <a href=\"https://github.com/audreyr/cookiecutter\" rel=\"nofollow\">Cookiecutter</a> and the <a href=\"https://github.com/audreyr/cookiecutter-pypackage\" rel=\"nofollow\">audreyr/cookiecutter-pypackage</a> project template.</p>\n</div>\n</div>\n</div>\n<div id=\"history\">\n<h2>History</h2>\n<ul>\n<li>0.1.0 (2016-10-13)</li>\n<li>0.3.1 (2017-01-21)</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 2589470, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "95e63ef7449a4e80a107c757285a13e6", "sha256": "83f65c2da525fb5ca48f7efd60d9496dae98a5314e98c2d2b92247bd32abb333"}, "downloads": -1, "filename": "zanna-0.1.0.tar.gz", "has_sig": false, "md5_digest": "95e63ef7449a4e80a107c757285a13e6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14139, "upload_time": "2017-01-21T15:06:30", "upload_time_iso_8601": "2017-01-21T15:06:30.819288Z", "url": "https://files.pythonhosted.org/packages/df/08/33b8386ed1f39a41b83719cf5a189c69f2582c204726cf728427496b053b/zanna-0.1.0.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "55ae31f2e51235cebc8b5226415b8892", "sha256": "64fc9e826c76280865060aa2094fa77f01a5395ad8f258cbab73cd4007118a6f"}, "downloads": -1, "filename": "zanna-0.3.1.tar.gz", "has_sig": false, "md5_digest": "55ae31f2e51235cebc8b5226415b8892", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14153, "upload_time": "2017-01-21T15:35:04", "upload_time_iso_8601": "2017-01-21T15:35:04.515631Z", "url": "https://files.pythonhosted.org/packages/ef/91/8fd80fd2b73c7ddf66b27c6d68316037dfe805cafab712631a2dcf31d469/zanna-0.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "55ae31f2e51235cebc8b5226415b8892", "sha256": "64fc9e826c76280865060aa2094fa77f01a5395ad8f258cbab73cd4007118a6f"}, "downloads": -1, "filename": "zanna-0.3.1.tar.gz", "has_sig": false, "md5_digest": "55ae31f2e51235cebc8b5226415b8892", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14153, "upload_time": "2017-01-21T15:35:04", "upload_time_iso_8601": "2017-01-21T15:35:04.515631Z", "url": "https://files.pythonhosted.org/packages/ef/91/8fd80fd2b73c7ddf66b27c6d68316037dfe805cafab712631a2dcf31d469/zanna-0.3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:19:53 2020"}