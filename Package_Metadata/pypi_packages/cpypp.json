{"info": {"author": "Wellington Rats", "author_email": "wellrats@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: Freely Distributable", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.3", "Programming Language :: Python :: 2.4", "Programming Language :: Python :: 2.5", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation", "Programming Language :: Python :: Implementation :: CPython", "Topic :: Software Development", "Topic :: Software Development :: Build Tools", "Topic :: Software Development :: Code Generators", "Topic :: Software Development :: Compilers", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "\nWelcome to repository of cpypp \n==============================\n\n**cpypp** is the implementation of a c-stype preprocessor for Python Programming Languages 2.7+\n\nA preprocessor is a program that takes a input Source Code written using some\nprogramming language syntax and outputs an output Source Code that translate,\nexpand or modify original programming language.\n\nFor example, from this:\n\n.. code:: python\n\n    from cpypp import py_preprocessor\n    PYPP = py_preprocessor()\n    PYPP.parse(__file__, __name__)\n\n    \"\"\"This source will work in both Python versions\"\"\"\n\n    def main():\n\n       #ifdef __PYTHON2__\n       #expand print \"This will work in\", \"Python 2\", \"like a charm\"\n       #else\n       print(\"This will work in Python 3 like a charm\")\n       #endif\n\n    if __name__ == \"__main__\": main()\n\nto this if we are using Python 3+\n\n.. code:: python\n\n    \"\"\"This source will work in both Python versions\"\"\"\n\n    def main():\n\n       print(\"This will work in Python 3 like a charm\")\n\n    if __name__ == \"__main__\": main()\n\nTable of Contents\n=================\n\n.. contents::\n\nIntroduction\n============\n\nI love to write code, and I love to keep my code clean and organized, specially when\nI publish it on github for example. I love to use the latest features of a\nlanguage and I specially love debug with ``print`` and a lot of dashes  ``'-'`` and so on.\n\nBut, when you write open source code, a lot of ``prints``, ``dashes`` and latest features\nare not welcome. Your code has to install and run in as many Python versions and platforms it it cans, and \nbe kept up to date, stable and without bugs. Python 2.7 support is dropped since January 2020, \nbut far away from be replaced. There is a lot of stuff that keeps working on it and still \nwill be for a long time.  Why? Because the cost of conversion is expensive, needs\ntime and effort. And all this code has to be mantained, keep evolving and will need packages \nupdates that be compatible with then and, when they began their conversion process, it will not be at once.\n\nSo this was the motivation to get the best of both worlds (thank you for Hanna Montanna). \nCreate a preprocessor for Python language that could keep final code clean, stable, runnable in \nany version of Python, working at run time, or used as a command line tool for batch conversion.\n\nInstalling\n----------\n\n**cpypp** can be easily installed via common Python package managers such as pip.\n\n::\n\n    $ pip install cpypp\n\nYou may also get the latest **cpypp** version by grabbing the source code from Github:\n\n::\n\n    $ git clone https://github.com/wellrats/cpypp\n    $ cd cpypp\n    $ python setup.py install\n\nTo test your installation, cpypp come with a set of simple tutorials that can be executed once you \nhave deployed the packages\n\n::\n\n    python -m cpypp.tests.test_helloworld\n\nor\n\n::\n\n    python3 -m cpypp.tests.test_helloworld\n\nExamples\n--------\n\ncpypp comes with some examples to check it out go to cpypp install directory\n\n::\n\n    $ cd $(dirname $(python -c \"import cpypp; print(cpypp.__file__)\"))\n    $ python tests/py2andpy3.py\n    $ python -m cpypp py2andpy3.py -o -\n    $ python -m cpypp py2andpy3.py -r -o -\n\nRuntime or command line processor?\n==================================\n\nUsually a preprocessor do its job at compile time, but Python don't have this feature \nso, pypy has two options do its job: at run time, when you are executing a source file as\na script or as a import module, or using a command line tool. Which to choose is up to you\nand your motivations to use a preprocessor. Let's see the diferences between then.\n\nRuntime preprocessor\n--------------------\n\nRunTime preprocessor is when you have the source code and wants to execute this code respecting the \npreprocessor directives. Probably you are a developer and want to insert some tests or let the code be prepared\nto future releases of Python, but don't want this ``test code`` in your final code on GitHub or in you client, or\nwants be able to generate many diferent codes from this one. \nThis source code can be executed as a script calling ``python yourscript.py`` or loaded as a module using import \n``import your_module``. Like was written before, Python does not implements a preprocessor feature at compile time, so cpypp will simulate it at run time.  \n\nBut how can we do it at runtime? How can we modify a code that is compiled and running? The answer is\nobvious: We can't. We can rewrite the code and executs it again, inside itself. In other words, we will execute\nthe source code twice. The first version is the original version where directives are seen as comments\nby compiler. This code will be compiled and executed normally. During this execution when the \n``PYPP.parse( ...`` code is executed,  the trick happens. All code is read again, preprocessed \nand directives do their job and a brand new code is created. This new code is executed and takes place \nof original code.  \n\nThere's a little difference if original code is executed as a script or is being imported. \nWhen the variable ``__name__`` has the value ``\"__main__\"``, cpypp assumes this is a script and not an\nimport module. The differences are bellow:\n\nHow Python and cpypp works when source code is a script\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst let's see a graphical flow how Python and cpypp will do their job to guarantee that the preprocessor will work\nproperly when running a script.\n\n::\n\n    Flow\n    |\n    1\ufe0f\u20e3 Python reads original .py script file\n    2\ufe0f\u20e3 compiles it in memory (.pyc)\n    3\ufe0f\u20e3 runs the compiled code\n       |\n       1\ufe0f\u20e3 All code before \"PYPP.parse( ...\" is executed \u2705\u2705\n       2\ufe0f\u20e3 When \"PYPP.parse( ...\" is called\n       |  |\n       |  1\ufe0f\u20e3 PYPP reads original .py file\n       |  2\ufe0f\u20e3 parse directives, clean the code and saves new code in memory\n       |  3\ufe0f\u20e3 call exec( ... ) to execute all new code\n       |  4\ufe0f\u20e3 call sys.exit(0) to stop old code execution\n       |    \n       3\ufe0f\u20e3 All code after \"PYPP.parse( ...\" from original compiled code is DISCARDED \u274c\u274c\n\nBe atention to step 3.2.4. When the code is executed as a script we can stop the execution of the old code, \nbecause we have sure that the new code was all executed stand alone. But we still have a problem. All the code \nbefore ``PYPP.parse( ...`` was executed twice. Right ? Yes and No. We have tools to prevent its to happen. \nLet's see an pratical example to understand better.\n\nSo the first step is instantiate a preprocessor in our source code:\n\n.. code:: python\n\n    from cpypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n\u2757\ufe0f **YOU CAN NOT** change this piece of code neither change ``PYPP.`` variable.\n\nThe reason is: When the preprocessor is doing its job, it will look for this piece of code\nand some references to ``PYPP`` variable so, it can be removed from final code.\n\nThe second step is write the directives in source code to give work to the preprocessor. \nDirectives are like coments and can be written anywhere in the code. All the directives and\nits rules will be explained bellow.\n\n.. code:: python\n\n    #ifdef debug\n    print(\"I'm a debug line running in Python __VERSION__ and won't be present in final code')\n    #endif\n\nThe third step is call the preprocessor so it can do its job:\n\n.. code:: python\n\n    PYPP.parse(__file__, __name__)\n\n\u2757\ufe0f **DON'T CHANGE** this line either.\n\nand finally we have our ``test_script01.py`` with other little stuff as :\n\n.. code:: python\n\n    import sys\n    from cpypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    #exclude\n    if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    #endexclude\n\n    print(\"PRINT me always but just once. I'm using Python __VERSION__ !!!\")\n    PYPP.parse(__file__, __name__)\n\n    #ifdef debug\n    print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n    #endif\n\nSo, let's run it using python 3.7\n\n::\n\n    $ python3 -m cpypp.tests.test_script01\n    PRINT me always but just once. I'm using Python __VERSION__ !!!\n    PRINT me always but just once. I'm using Python 3.7.6 !!!\n\n::\n\n    $ python3 -m cpypp.tests.test_script01 -d\n    PRINT me always but just once. I'm using Python __VERSION__ !!!\n    PRINT me always but just once. I'm using Python 3.7.6 !!!\n    PRINT me only if '-d' used. I'm using Python 3.7.6 !!!\n\nWell, it didn't work as expected  \ud83d\ude29. The first print was executed twice. The reason was \nexplained earlier. All code before ``PYPP.parse( ...`` is executed at original code and at \npreprocessed code. To solve this we have many options. First let's understand that this happens\nonly to code that starts at column 1 (usually), with exception to classes and functions declarations. \nAll code inside classes and funcions are executed only when called, but all the rest is executed \ninstantly.\n\nThe options to solve this issue are:\n\n#. Move ``PYPP.parse( ...`` next to top of code so, there is no relevant code before it, but only the  \n   necessary to its own execution.\n\n#. Use the special logical condition ``if PYPP.parsed():`` to all relevant code before ``PYPP.parse( ...``. This\n   will prevent this code to be executed because this condition returns always ``False``, so nothing inside will\n   be executed with original code. The preprocessor recognizes this special logical condition, removes it \n   completely from final code and reident the code to it's original position.\n\nWith option 1 we have ``test_script02.py``:\n\n.. code:: python\n\n    import sys\n    from cpypp import py_preprocessor\n\n    #exclude\n    if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    #endexclude\n\n    PYPP.parse(__file__, __name__)\n\n    print(\"PRINT me always but just once. I'm using Python __VERSION__ !!!\")\n\n    #ifdef debug\n    print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n    #endif\n\nWith option 2 we have ``test_script03.py``:\n\n.. code:: python\n\n    import sys\n    from cpypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    # This is just a comment\n\n    #exclude\n    if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    #endexclude\n\n    if PYPP.parsed():\n       print(\"PRINT me always but just once. I'm using Python __VERSION__ !!!\")\n\n       #ifdef debug\n       print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n       #endif\n\n    PYPP.parse(__file__, __name__)\n\nSo, let's try again ...\n\n::\n\n    $ python3 -m cpypp.tests.test_script02\n    PRINT me always but just once. I'm using Python 3.7.6 !!!\n\n::\n\n    $ python3 -m cpypp.tests.test_script03 -d\n    PRINT me always but just once. I'm using Python 3.7.6 !!!\n    PRINT me only if '-d' used. I'm using Python 3.7.6 !!!\n\nYeah \ud83d\ude01. So the first rule of cpypp is that for scripts, we have to keep our ``PYPP.parse( ...`` call as next from top \nof code we can, or use ``if PYPP.parsed():`` logical condition, or both, so our code can be processed the way we\nwants. Another very important rule is:\n\n\u2757\ufe0f Your original source code **HAS TO BE** compilable in all Python versions, because this original source code has to\nrun so the processor can do its job.\n\nThis means that a code like:\n\n.. code:: python\n\n    #ifdef __PYTHON2__\n    print \"This is\", \"a debug code \", \"and will NOT run  in Python 3\"\n    #else\n    print(\"This is a debug code and is executes if we are using Python 3\")\n    #endif\n\nwill not compile in Python 3 because  second line will generate a syntax error. In these case if you can't change the original code you can use the directive ``#expand`` as you see bellow.\n\n.. code:: python\n\n    #ifdef __PYTHON2__\n    #expand print \"This is\", \"a debug code \", \"and will NOT run  in Python 3\"\n    #else\n    print(\"This is a debug code and is executes if we are using Python 3\")\n    #endif\n\nHow Python and cpypp works when source code is a module to be imported\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nNow, let's see a graphical flow how Python and cpypp will do their job to guarantee that the preprocessor will work\nproperly when importing a module\n\n::\n\n    Flow\n    |\n    1\ufe0f\u20e3 Another Python scripts or module imports our original .py  file\n    2\ufe0f\u20e3 Python reads original .py module file\n    3\ufe0f\u20e3 compiles it in memory (.pyc)\n    4\ufe0f\u20e3 loads, runs the compiled code and inserts an entry for it in ``sys.modules``\n       |\n       1\ufe0f\u20e3 All code before \"PYPP.parse( ...\" is executed \u2705\u2705\n       2\ufe0f\u20e3 When \"PYPP.parse( ...\" is called\n       |  |\n       |  1\ufe0f\u20e3 PYPP reads original .py file\n       |  2\ufe0f\u20e3 parse directives, clean the code and save new code in a file\n       |  3\ufe0f\u20e3 call __import__( ... ) to load the new code in the same ``sys.modules`` entry\n       |  4\ufe0f\u20e3 new code is executed\n       |    \n       3\ufe0f\u20e3 All code after \"PYPP.parse( ...\" from original compiled code IS EXECUTED TOO \u2705\u2705\n\nThere are diferences from a script code. We have ``sys.modules`` that has to be modified at runtime, we can't call\n``sys.exit`` because Python will halt and the most important, when the source file is \na module to be imported **all the original code will be executed** no matter which place you write \n``PYPP.parse( ...``. So we **HAVE** to use ``if PYPP.parsed():`` logical condition to prevent our code to be executed twice and avoid unpredictable runtime errors write ``PYPP.parse(...`` after all references to ``PYPP.`` in source code. Let's see some pratical examples to understand better. \n\nYou can protect only what is relevant. See ``import4.py``\n\n.. code:: python\n\n    import os\n    from cpypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    class test_class(): # classes and functions are not a problem because are only compiled\n\n          def __init__(self):\n              print(\"This print has no problem\")\n\n    GLOBAL_VARIABLE = \"PYTHON vr __VERSION__\" \n    # global variable definitions are most of time safe to become unprotected\n\n    if PYPP.parsed(): # but code like this has to be protected at all\n\n       if os.path.isfile(\"/tmp/test.txt\"):\n          os.remove(\"/tmp/test.txt\")\n\n       print(\"module import4 imported and I was printed just once\")\n\n    PYPP.parse(__file__, __name__)\n\nOr you can protect the all code. See ``import5.py``\n\n.. code:: python\n\n    import os\n    from cpypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    if PYPP.parsed(): # You can protect the all code\n\n       class test_class(): # classes and functions are not a problem because are only compiled\n\n             def __init__(self):\n                 print(\"This print has no problem\")\n\n       GLOBAL_VARIABLE = \"PYTHON vr __VERSION__\" \n       # global variable definitions are most of time safe to become unprotected\n\n       if os.path.isfile(\"/tmp/test.txt\"):\n          os.remove(\"/tmp/test.txt\")\n\n       print(\"module import5 imported and I was printed just once\")\n\n    PYPP.parse(__file__, __name__)\n\nOr you can protect nothing if you code has only global, classes and defs definitions. See ``test06_import_module.py``\n\n.. code:: python\n\n    from cpypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    GLOBAL_VARIABLE = \"PYTHON vr __VERSION__\" \n    # global variable definitions are most of time safe to become unprotected\n    class test_class(): # classes and functions are not a problem because are only compiled\n\n          def __init__(self):\n              print(\"This print has no problem\")\n\n    print(\"I don't care if this line is printed twice\")\n\n    PYPP.parse(__file__, __name__)\n\nLet's import all of then\n\n>>> cpypp.tests.imports import impor4\nmodule import4 was imported and I was printed just once\n>>> cpypp.tests.imports import impor5\nmodule import5 was imported and I was printed just once\n>>> cpypp.tests.imports import impor6\nI don't care if this line is printed twice\nI don't care if this line is printed twice\n\nYeah again\ud83d\ude01. Here the rule is that for import modules, we have to use ``if PYPP.parsed():`` logical condition, in the whole code if necessary, and write ``PYPP.parse (...`` at the end of our source code, so our code can be processed the way we wants. \n\nAnother thing that is very important:\n\n| \u2757\ufe0f ``if PYPP.parsed():`` logical condition, **CAN ALSO** be replaced by ``if False and False:``. \n| \u2757\ufe0f cpypp will understand this too.\n\nCommand line preprocessor\n-------------------------\n\nCommand line preprocessor is when you have source code files and wants to generate new preprocessed files in\nbatch mode. Probably you are a developer and want to insert copyright marks, or remove something from final code, like\n``prints``, debugs and so on, or you know exactly what version of Python will execute your code and wants to\ngenerate a final code totally compatible with it. Almost like C does with ``make``.\n\nHere we have no flow. It's just a command line tool that has some parameters and you can run it from shell.\n\n::\n\n    $ python2.7+ -m cpypp -r -d debug cpypp./tests/test_commandline01.pyp \n\n\u2757\ufe0f The code generated is **DIRECTLY DEPENDENT** from the Python version you run the command line\n\nOptions\n^^^^^^^\n\nUsage: ``cpyppc [options] filename-or-directory [...]``\n\n-h, --help        show this help message and exit\n-v, --version     print cpypp version\n-d name           same as #define. Ex. ``-d`` debug or ``-d \"var=2+2\"`` (eval 4)\n-e EXT            include files with only these extensions. default is ``'.py'``\n                  and extensions must be separated with ``'|'`` char. Ex.\n                  ``'.py|.pypp'``\n-l MAXLEVELS      levels to recurse into subdirectories. Use ``'0'`` to don't\n                  recurse. Default is no limit\n-p PATH           directory to prepend to file names and paths before save\n                  processed files. The full path will be created if it does\n                  not exists\n-f                force overwrite of files when output file name has the\n                  same name of input file name\n-r                remove meta tags and commented lines from final code\n-o FILE           output file name when you are preprocessing just one file\n                  at once. Use ``'-o -'`` to stdout\n-i FILE           add all the files and directories listed in FILE to the\n                  list considered for compilation; Use ``'-'`` to read\n                  names from stdin                  \n-q                output only error messages; ``-qq`` will suppress the error\n                  messages as well\n-c, --compileall  compile each file after preprocessing. When this option is\n                  used, no preprocessed source file will be saved to disk and\n                  options ``'-o'``, ``'-r'`` and ``'-f'`` are discarded\n-b                use legacy (pre-PEP3147) compiled file locations. Valid\n                  only when ``'-c'`` is used\n\nExamples\n^^^^^^^^\n\nLet's use one of our script files ``test_script03.py``\n\n.. code:: python\n\n    import sys\n    from cpypp import py_preprocessor\n    PYPP = py_preprocessor()\n\n    # This is just a comment\n\n    #exclude\n    if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    #endexclude\n\n    if PYPP.parsed():\n       print(\"PRINT me always but just once. I'm using Python __VERSION__ !!!\")\n\n       #ifdef debug\n       print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n       #endif\n\n    PYPP.parse(__file__, __name__)\n\nNow let's run ``cpypp`` and don't remove metada to see all preprocessor work.\n\n::\n\n    $ python3 -m cpypp cpypp/tests/test_script03.py -o -  \n\n.. code:: python\n\n    import sys\n    # from cpypp import py_preprocessor\n    # PYPP = py_preprocessor()\n\n    # This is just a comment\n\n    # #exclude\n    # if len(sys.argv) > 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")\n    # #endexclude\n\n    # if PYPP.parsed():\n    print(\"PRINT me always but just once. I'm using Python 3.7.6 !!!\")\n\n    # #ifdef debug\n    # print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")\n    # #endif\n\nRealize that any references to ``py_preprocessor`` were commented and the block ``if PYPP.parsed():`` \nhas been commented too and all code bellow was reidented.\nLet's remove metada data now.\n\n::\n\n    $ python3 -m cpypp -r cpypp/tests/test_script03.py -o -  \n\n.. code:: python\n\n    import sys\n\n    # This is just a comment\n\n    print(\"PRINT me always but just once. I'm using Python 3.7.6 !!!\")\n\n\n\u2757\ufe0f As you can see there is **NO DEPENDENCY** in final code from cpypp.\n\nPreprocessing and compiling code at once\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ncpypp can compile bytecode files (.pyc) directly from the preprocessed file without need to save the new file to\ndisk an execute ``python -m compileall``, and is as simple as this. Just use ``-c`` or ``--compileall`` option.\n\n::\n\n    $ python -m cpypp --compileall diretory_or_file      # generate __pycache__/.pyc files\n    $ python -m cpypp -b --compileall diretory_or_file   # generate .pyc files at same dir\n\nYour bytecodes (.pyc) where generated using the preprocessed file and are ready to deploy. For more \ninformation and usage execute ``python cpypp --help``.\n\nExpander\n========\n\ncpypp implements some expanders that look for names and special characters in the source code and replace then\nfor defined values or expressions.\n\nName definitions expander\n-------------------------\n\nAny references to name definitions done with ``#define`` in source file will be replaced by its ``repr()`` value.\nNote than any references means any place where definition names appears, even inside strings. To avoid this\nreplacement precede the name with ``'!'``\nFor example, the code:\n\n.. code:: Python\n\n    #define SIZE 100 * 2\n    #define TEXT \"cpypp\" + \" is \" + \"the best\"\n\n    for i in range(0, SIZE): print(TEXT)\n    print(\"The value of !TEXT is TEXT\")\n\nafter preprocessing will become:\n\n.. code:: Python\n\n    for i in range(0, 200): print('cpypp is the best')\n    print(\"The value of TEXT is 'cpypp is the best'\")\n\nExpressions expander\n--------------------\n\nFor more complexes replacements there is expression expander. All text between expander begin mark ``'#{'`` and\nexpander end mark ``}#'`` will be evaluated and replaced exactly at same place by its ``str()`` value. If you wants\nthat replacement value be by its ``repr()`` value, insert a modifier at end of expression, without spaces from ``'}'``.\nThe modifiers are ``',s`` for ``str()`` value and ``',r'`` for ``repr()`` value.\nFor example, the code:\n\n.. code:: Python\n\n    #! env python#{__VERSION__[0]}#\n\n    #define VALUE 5 if __PYTHON2__ else 6\n    #define TEXT \"cpypp\" + \" is \" + \"the best\"\n\n    print(\"!VALUE + 1 = #{VALUE + 1}# and #{TEXT}# and #{TEXT,r}#\")\n\nafter preprocessing with ``python2`` will become:\n\n.. code:: Python\n\n    #! env python2\n\n    print(\"VALUE + 1 = 6 and cpypp is the best and 'cpypp is the best'\")\n\nand after preprocessing with ``python3`` will become:\n\n.. code:: Python\n\n    #! env python3\n\n    print(\"VALUE + 1 = 7 and cpypp is the best and 'cpypp is the best'\")\n\nDirectives\n==========\n\nName definitions (#define, #undef)\n----------------------------------\n\nDefine names, or names with values that will be stored in definition dictionary.\n\n``#define identifier [expression]``\n\nWhen the preprocessor encounters this directive, it creates an entry in its definition dictionary with name ``identifier`` and the value with evaluation of ``expression``. If ``expression`` is ommited, ``True`` is used. \n\n.. code:: Python\n\n    #define DEBUG\n    #define TABLE_SIZE (50 * 50 if __PYTHON2__ else 100 * 100)\n\n    block = list(\" \" * TABLE_SIZE)\n\n    #ifdef DEBUG\n    print(\"Debug is ON !!!\")\n    #endif\n\nTo remove an entry from definition dictionary use \n\n``#undef identifier``\n\nConditional inclusions (#if, #else, #endif and its variations)\n-----------------------------------------------------------------\n\nThese directives allow to include or discard part of the original code, also called code blocks if a certain \ncondition is met or not.\nIt works the same manner that ``if/elif/else`` in python. The diference is that we have ``#endif`` and its\nvariations to close opened ``#if blocks`` cause we don't have identation and there are more directives \nthat gives more flexibility.\n\nHere are all the conditional inclusions directives and how they are evalueted.\n\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#ifdef** ``identifier``       | | Opens a block of code and includes its content if ``identifier`` is a name      |\n|                                 | | in definition dictionary, no matter its value.                                  |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#ifndef** ``identifier``      | | Open a block of code and includes its content if ``identifier`` is not a name   |\n|                                 | | in definition dictionary.                                                       |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#if** ``expression``          | | Open a block of code and includes it if ``expression`` is evaluated to ``True``.|\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#else**                       | | Closes the last opened block of code,  opens a new block of code                |\n|                                 | | and includes it if any block above and at same level was not ``True``           |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#elif** ``expression``        | | Closes the last opened block of code,  opens a new block of code                |\n|                                 | | and includes it if  ``expression`` is evaluated to ``True`` and any block       |\n|                                 | | above and at same level was not ``True``                                        |\n+---------------------------------+-----------------------------------------------------------------------------------+\n|**#elifdef** ``identifier``      | | Closes the last opened block of code,  opens a new block of code                |\n|                                 | | and includes it if ``identifier`` is a name in definition dictionary,           |\n|                                 | | no matter its value and any block above and at same level was not ``True``.     |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#endif**                      | | Closes the last opened block of code at same level                              |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#endififdef** ``identifier``  | | Same as **#endif** + **#ifdef** but at the same line                            |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#endifif** ``expression``     | | Same as **#endif** + **#if** but at the same line                               |\n+---------------------------------+-----------------------------------------------------------------------------------+\n| **#endifall**                   | | Close all opened blocks no matter if they are inner or outter. Use with care.   |\n+---------------------------------+-----------------------------------------------------------------------------------+\n\nExamples of Conditional inclusions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: Python\n\n    # compile block if DEBUG was defined before\n\n    #ifdef DEBUG\n    print(\"Debug is ON !!!\")\n    #endif\n\n    # compile block if DEBUG was not defined or was excluded from definition dictionary \n\n    #undef DEBUG\n    #ifndef DEBUG\n    print(\"Debug is ON !!!\")\n    #endif\n\n    # compile block if expression is True\n\n    # define INT_VER int(VERSION[0])\n    #if DEBUG is True and INT_VER > 2\n    print(\"Debug is ON and Python is 3+!!!\")\n    #elif INT_VER == 2\n    print(\"Python certainly is 2.x\")\n    #else\n    print(\"I'm sure Debug is ON or OFF :)\")\n    #endif\n\nExclusion blocks (#exclude and #endexclude)\n-----------------------------------------------------------------\n\nDepending of your code, sometimes you want to exclude an entire block of code if some conditions are met or not\nor not, or  maybe you wants that only the preprocessor executes this portion of code, but wants remove this \nportion from final code. For this we have the directives **#exclude** and **#endexclude**. All inside this two directives will be completely exclude from final code, but will be seen by preprocessor.\n\n.. code:: Python\n\n   #define NUMPY_E __import__(\"numpy\").e\n   #define NUMPY_EULER_GAMA __import__(\"numpy\").euler_gama\n   numpy_e = NUMPY_E\n   numpy_euler_gama = NUMPY_EULER_GAMA\n\nWe imported numpy package only at preprocessor time to get the values of these two constants and set two local\nvariables. ``numpy`` package don't need to be installed where the final code will execute. Neither cpypp as \nwe already know.\n\nIgnore blocks (#ignore and #endignore)\n-----------------------------------------------------------------\n\nThese directives do exactly what their name says. They ignore from the preprocessor an entire block of code.\n\n.. code:: Python\n\n   #ignore\n   #define NONE \"This defines will never occurs because this block is ignored\"\n   #ifndef NONE\n   print(\"This !TEXT will be printed exactly how it is #{PRINT_ME#}\") # Will print always\n   #endif\n   #endignore\n\nSource file inclusion (#include and #includeident)\n-----------------------------------------------------------------\n\nWhen the preprocessor finds an ``#include`` or ``#includeident`` directive it replaces it by the entire \ncontent of the specified file. The diference between ``#include`` and ``#includeident`` is that \n``#include`` will always include each line of included file starting of column 1 and ``#includeident`` will\nalways include each line of incuded file starting at same column where ``#includeident`` was written. \nThere are two ways to use #include:\n\n+-----------------------------+------------------------------------------------------------------------------------+\n| **#include** ``<filename>`` | | When filename is specified between angle-backets, cpypp looks for the            |\n|                             | | filename in all directories listed in ``sys.path``. The first existing file      |\n|                             | | will be included.                                                                |\n+-----------------------------+------------------------------------------------------------------------------------+\n| **#include** ``expression`` | | When filename is not specified between angle-brackes, cpypp assumes that this    |\n|                             | | is an expression, evaluates it and the result as used as  absolute path of file. |\n|                             | | If the file exists it will be included.                                          |\n+-----------------------------+------------------------------------------------------------------------------------+\n\nSupose that ``include.py`` has the following content.\n\n::\n\n    print(\"I'm an included file\")\n\nNow let's see this code.\n\n.. code:: Python\n\n   #include \"include.py\"\n       #include \"include.py\"\n\n   if some_condition:\n      #includeident \"include.py\"\n\nIf we check the preprocessed file we will find:\n\n.. code:: Python\n\n   print(\"I'm an included file\")\n   print(\"I'm an included file\")\n\n   if some_condition:\n      print(\"I'm an included file\")\n\nCode protection (#expand)\n-------------------------\n\nAs you remember, the original code is compiled twice, one before the preprocessor and other after.\nSo at both compiling steps the code must be correct and without syntax or grammar errors.\n\nSometimes we want to implement some features in our code that are not available in all Python versions,\nbut we need that our code compile correctly so the preprocessor can do its work. For this we have ``#expand``\ndirective. If you had a piece of code that is not compatible with all versions of Python you put it as parameter \nof ``#expand``. The first step of compiling will consider this line as a comment and will ignore it. And the \npreprocessor will do its job. For example:\n\n.. code:: Python\n\n  #if __PYTHON2__\n  print \"This\",\"is\", \"a\",\"python\",\"program\"\n  #else\n  print (\"This is a python program\")\n  #endif\n\nThe code above will generate a compile error if we try to run it on Python 3+, because the first ``print`` statement\ndoes not meet the Python 3 syntax. So the solution is to hide this code from first compiling. ``#expand`` will do\nthis for us.\n\n.. code:: Python\n\n  #if __PYTHON2__\n  #expand print \"This\",\"is\", \"a\",\"python\",\"program\"\n  #else\n  print (\"This is a python program\")\n  #endif\n\nNow the first compiling will occur with no problem no matter what Python version is used \nand the preprocessor will go on.\n\n\nContributing\n============\n\nPlease send an email to `wellrats@gmail.com <mailto:wellrats@gmail.com>`_\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/wellrats/cpypp", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "cpypp", "package_url": "https://pypi.org/project/cpypp/", "platform": "", "project_url": "https://pypi.org/project/cpypp/", "project_urls": {"GitHub: issues": "https://github.com/wellrats/cpypp/issues", "GitHub: repo": "https://github.com/wellrats/cpypp", "Homepage": "https://github.com/wellrats/cpypp"}, "release_url": "https://pypi.org/project/cpypp/1.1.0/", "requires_dist": null, "requires_python": "", "summary": "c-style preprocessor for Python", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"welcome-to-repository-of-cpypp\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Welcome to repository of cpypp</a></h2>\n<p><strong>cpypp</strong> is the implementation of a c-stype preprocessor for Python Programming Languages 2.7+</p>\n<p>A preprocessor is a program that takes a input Source Code written using some\nprogramming language syntax and outputs an output Source Code that translate,\nexpand or modify original programming language.</p>\n<p>For example, from this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n<span class=\"n\">PYPP</span> <span class=\"o\">=</span> <span class=\"n\">py_preprocessor</span><span class=\"p\">()</span>\n<span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n<span class=\"sd\">\"\"\"This source will work in both Python versions\"\"\"</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n\n   <span class=\"c1\">#ifdef __PYTHON2__</span>\n   <span class=\"c1\">#expand print \"This will work in\", \"Python 2\", \"like a charm\"</span>\n   <span class=\"c1\">#else</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This will work in Python 3 like a charm\"</span><span class=\"p\">)</span>\n   <span class=\"c1\">#endif</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n<p>to this if we are using Python 3+</p>\n<pre><span class=\"sd\">\"\"\"This source will work in both Python versions\"\"\"</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This will work in Python 3 like a charm\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"table-of-contents\">\n<h2><a href=\"#id3\" rel=\"nofollow\">Table of Contents</a></h2>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#welcome-to-repository-of-cpypp\" id=\"id2\" rel=\"nofollow\">Welcome to repository of cpypp</a></li>\n<li><a href=\"#table-of-contents\" id=\"id3\" rel=\"nofollow\">Table of Contents</a></li>\n<li><a href=\"#introduction\" id=\"id4\" rel=\"nofollow\">Introduction</a><ul>\n<li><a href=\"#installing\" id=\"id5\" rel=\"nofollow\">Installing</a></li>\n<li><a href=\"#examples\" id=\"id6\" rel=\"nofollow\">Examples</a></li>\n</ul>\n</li>\n<li><a href=\"#runtime-or-command-line-processor\" id=\"id7\" rel=\"nofollow\">Runtime or command line processor?</a><ul>\n<li><a href=\"#runtime-preprocessor\" id=\"id8\" rel=\"nofollow\">Runtime preprocessor</a><ul>\n<li><a href=\"#how-python-and-cpypp-works-when-source-code-is-a-script\" id=\"id9\" rel=\"nofollow\">How Python and cpypp works when source code is a script</a></li>\n<li><a href=\"#how-python-and-cpypp-works-when-source-code-is-a-module-to-be-imported\" id=\"id10\" rel=\"nofollow\">How Python and cpypp works when source code is a module to be imported</a></li>\n</ul>\n</li>\n<li><a href=\"#command-line-preprocessor\" id=\"id11\" rel=\"nofollow\">Command line preprocessor</a><ul>\n<li><a href=\"#options\" id=\"id12\" rel=\"nofollow\">Options</a></li>\n<li><a href=\"#id1\" id=\"id13\" rel=\"nofollow\">Examples</a></li>\n<li><a href=\"#preprocessing-and-compiling-code-at-once\" id=\"id14\" rel=\"nofollow\">Preprocessing and compiling code at once</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#expander\" id=\"id15\" rel=\"nofollow\">Expander</a><ul>\n<li><a href=\"#name-definitions-expander\" id=\"id16\" rel=\"nofollow\">Name definitions expander</a></li>\n<li><a href=\"#expressions-expander\" id=\"id17\" rel=\"nofollow\">Expressions expander</a></li>\n</ul>\n</li>\n<li><a href=\"#directives\" id=\"id18\" rel=\"nofollow\">Directives</a><ul>\n<li><a href=\"#name-definitions-define-undef\" id=\"id19\" rel=\"nofollow\">Name definitions (#define, #undef)</a></li>\n<li><a href=\"#conditional-inclusions-if-else-endif-and-its-variations\" id=\"id20\" rel=\"nofollow\">Conditional inclusions (#if, #else, #endif and its variations)</a><ul>\n<li><a href=\"#examples-of-conditional-inclusions\" id=\"id21\" rel=\"nofollow\">Examples of Conditional inclusions</a></li>\n</ul>\n</li>\n<li><a href=\"#exclusion-blocks-exclude-and-endexclude\" id=\"id22\" rel=\"nofollow\">Exclusion blocks (#exclude and #endexclude)</a></li>\n<li><a href=\"#ignore-blocks-ignore-and-endignore\" id=\"id23\" rel=\"nofollow\">Ignore blocks (#ignore and #endignore)</a></li>\n<li><a href=\"#source-file-inclusion-include-and-includeident\" id=\"id24\" rel=\"nofollow\">Source file inclusion (#include and #includeident)</a></li>\n<li><a href=\"#code-protection-expand\" id=\"id25\" rel=\"nofollow\">Code protection (#expand)</a></li>\n</ul>\n</li>\n<li><a href=\"#contributing\" id=\"id26\" rel=\"nofollow\">Contributing</a></li>\n</ul>\n</div>\n</div>\n<div id=\"introduction\">\n<h2><a href=\"#id4\" rel=\"nofollow\">Introduction</a></h2>\n<p>I love to write code, and I love to keep my code clean and organized, specially when\nI publish it on github for example. I love to use the latest features of a\nlanguage and I specially love debug with <tt>print</tt> and a lot of dashes  <tt><span class=\"pre\">'-'</span></tt> and so on.</p>\n<p>But, when you write open source code, a lot of <tt>prints</tt>, <tt>dashes</tt> and latest features\nare not welcome. Your code has to install and run in as many Python versions and platforms it it cans, and\nbe kept up to date, stable and without bugs. Python 2.7 support is dropped since January 2020,\nbut far away from be replaced. There is a lot of stuff that keeps working on it and still\nwill be for a long time.  Why? Because the cost of conversion is expensive, needs\ntime and effort. And all this code has to be mantained, keep evolving and will need packages\nupdates that be compatible with then and, when they began their conversion process, it will not be at once.</p>\n<p>So this was the motivation to get the best of both worlds (thank you for Hanna Montanna).\nCreate a preprocessor for Python language that could keep final code clean, stable, runnable in\nany version of Python, working at run time, or used as a command line tool for batch conversion.</p>\n<div id=\"installing\">\n<h3><a href=\"#id5\" rel=\"nofollow\">Installing</a></h3>\n<p><strong>cpypp</strong> can be easily installed via common Python package managers such as pip.</p>\n<pre>$ pip install cpypp\n</pre>\n<p>You may also get the latest <strong>cpypp</strong> version by grabbing the source code from Github:</p>\n<pre>$ git clone https://github.com/wellrats/cpypp\n$ cd cpypp\n$ python setup.py install\n</pre>\n<p>To test your installation, cpypp come with a set of simple tutorials that can be executed once you\nhave deployed the packages</p>\n<pre>python -m cpypp.tests.test_helloworld\n</pre>\n<p>or</p>\n<pre>python3 -m cpypp.tests.test_helloworld\n</pre>\n</div>\n<div id=\"examples\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Examples</a></h3>\n<p>cpypp comes with some examples to check it out go to cpypp install directory</p>\n<pre>$ cd $(dirname $(python -c \"import cpypp; print(cpypp.__file__)\"))\n$ python tests/py2andpy3.py\n$ python -m cpypp py2andpy3.py -o -\n$ python -m cpypp py2andpy3.py -r -o -\n</pre>\n</div>\n</div>\n<div id=\"runtime-or-command-line-processor\">\n<h2><a href=\"#id7\" rel=\"nofollow\">Runtime or command line processor?</a></h2>\n<p>Usually a preprocessor do its job at compile time, but Python don\u2019t have this feature\nso, pypy has two options do its job: at run time, when you are executing a source file as\na script or as a import module, or using a command line tool. Which to choose is up to you\nand your motivations to use a preprocessor. Let\u2019s see the diferences between then.</p>\n<div id=\"runtime-preprocessor\">\n<h3><a href=\"#id8\" rel=\"nofollow\">Runtime preprocessor</a></h3>\n<p>RunTime preprocessor is when you have the source code and wants to execute this code respecting the\npreprocessor directives. Probably you are a developer and want to insert some tests or let the code be prepared\nto future releases of Python, but don\u2019t want this <tt>test code</tt> in your final code on GitHub or in you client, or\nwants be able to generate many diferent codes from this one.\nThis source code can be executed as a script calling <tt>python yourscript.py</tt> or loaded as a module using import\n<tt>import your_module</tt>. Like was written before, Python does not implements a preprocessor feature at compile time, so cpypp will simulate it at run time.</p>\n<p>But how can we do it at runtime? How can we modify a code that is compiled and running? The answer is\nobvious: We can\u2019t. We can rewrite the code and executs it again, inside itself. In other words, we will execute\nthe source code twice. The first version is the original version where directives are seen as comments\nby compiler. This code will be compiled and executed normally. During this execution when the\n<tt>PYPP.parse( ...</tt> code is executed,  the trick happens. All code is read again, preprocessed\nand directives do their job and a brand new code is created. This new code is executed and takes place\nof original code.</p>\n<p>There\u2019s a little difference if original code is executed as a script or is being imported.\nWhen the variable <tt>__name__</tt> has the value <tt>\"__main__\"</tt>, cpypp assumes this is a script and not an\nimport module. The differences are bellow:</p>\n<div id=\"how-python-and-cpypp-works-when-source-code-is-a-script\">\n<h4><a href=\"#id9\" rel=\"nofollow\">How Python and cpypp works when source code is a script</a></h4>\n<p>First let\u2019s see a graphical flow how Python and cpypp will do their job to guarantee that the preprocessor will work\nproperly when running a script.</p>\n<pre>Flow\n|\n1\ufe0f\u20e3 Python reads original .py script file\n2\ufe0f\u20e3 compiles it in memory (.pyc)\n3\ufe0f\u20e3 runs the compiled code\n   |\n   1\ufe0f\u20e3 All code before \"PYPP.parse( ...\" is executed \u2705\u2705\n   2\ufe0f\u20e3 When \"PYPP.parse( ...\" is called\n   |  |\n   |  1\ufe0f\u20e3 PYPP reads original .py file\n   |  2\ufe0f\u20e3 parse directives, clean the code and saves new code in memory\n   |  3\ufe0f\u20e3 call exec( ... ) to execute all new code\n   |  4\ufe0f\u20e3 call sys.exit(0) to stop old code execution\n   |\n   3\ufe0f\u20e3 All code after \"PYPP.parse( ...\" from original compiled code is DISCARDED \u274c\u274c\n</pre>\n<p>Be atention to step 3.2.4. When the code is executed as a script we can stop the execution of the old code,\nbecause we have sure that the new code was all executed stand alone. But we still have a problem. All the code\nbefore <tt>PYPP.parse( ...</tt> was executed twice. Right ? Yes and No. We have tools to prevent its to happen.\nLet\u2019s see an pratical example to understand better.</p>\n<p>So the first step is instantiate a preprocessor in our source code:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n<span class=\"n\">PYPP</span> <span class=\"o\">=</span> <span class=\"n\">py_preprocessor</span><span class=\"p\">()</span>\n</pre>\n<p>\u2757\ufe0f <strong>YOU CAN NOT</strong> change this piece of code neither change <tt>PYPP.</tt> variable.</p>\n<p>The reason is: When the preprocessor is doing its job, it will look for this piece of code\nand some references to <tt>PYPP</tt> variable so, it can be removed from final code.</p>\n<p>The second step is write the directives in source code to give work to the preprocessor.\nDirectives are like coments and can be written anywhere in the code. All the directives and\nits rules will be explained bellow.</p>\n<pre><span class=\"c1\">#ifdef debug</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"I'm a debug line running in Python __VERSION__ and won't be present in final code')</span>\n<span class=\"c1\">#endif</span>\n</pre>\n<p>The third step is call the preprocessor so it can do its job:</p>\n<pre><span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n</pre>\n<p>\u2757\ufe0f <strong>DON\u2019T CHANGE</strong> this line either.</p>\n<p>and finally we have our <tt>test_script01.py</tt> with other little stuff as :</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n<span class=\"n\">PYPP</span> <span class=\"o\">=</span> <span class=\"n\">py_preprocessor</span><span class=\"p\">()</span>\n\n<span class=\"c1\">#exclude</span>\n<span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'-d'</span><span class=\"p\">:</span> <span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">define</span><span class=\"p\">(</span><span class=\"s2\">\"debug\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endexclude</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me always but just once. I'm using Python __VERSION__ !!!\"</span><span class=\"p\">)</span>\n<span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n<span class=\"c1\">#ifdef debug</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n</pre>\n<p>So, let\u2019s run it using python 3.7</p>\n<pre>$ python3 -m cpypp.tests.test_script01\nPRINT me always but just once. I'm using Python __VERSION__ !!!\nPRINT me always but just once. I'm using Python 3.7.6 !!!\n</pre>\n<pre>$ python3 -m cpypp.tests.test_script01 -d\nPRINT me always but just once. I'm using Python __VERSION__ !!!\nPRINT me always but just once. I'm using Python 3.7.6 !!!\nPRINT me only if '-d' used. I'm using Python 3.7.6 !!!\n</pre>\n<p>Well, it didn\u2019t work as expected  \ud83d\ude29. The first print was executed twice. The reason was\nexplained earlier. All code before <tt>PYPP.parse( ...</tt> is executed at original code and at\npreprocessed code. To solve this we have many options. First let\u2019s understand that this happens\nonly to code that starts at column 1 (usually), with exception to classes and functions declarations.\nAll code inside classes and funcions are executed only when called, but all the rest is executed\ninstantly.</p>\n<p>The options to solve this issue are:</p>\n<ol>\n<li>Move <tt>PYPP.parse( ...</tt> next to top of code so, there is no relevant code before it, but only the\nnecessary to its own execution.</li>\n<li>Use the special logical condition <tt>if <span class=\"pre\">PYPP.parsed():</span></tt> to all relevant code before <tt>PYPP.parse( ...</tt>. This\nwill prevent this code to be executed because this condition returns always <tt>False</tt>, so nothing inside will\nbe executed with original code. The preprocessor recognizes this special logical condition, removes it\ncompletely from final code and reident the code to it\u2019s original position.</li>\n</ol>\n<p>With option 1 we have <tt>test_script02.py</tt>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n\n<span class=\"c1\">#exclude</span>\n<span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'-d'</span><span class=\"p\">:</span> <span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">define</span><span class=\"p\">(</span><span class=\"s2\">\"debug\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endexclude</span>\n\n<span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me always but just once. I'm using Python __VERSION__ !!!\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\">#ifdef debug</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n</pre>\n<p>With option 2 we have <tt>test_script03.py</tt>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n<span class=\"n\">PYPP</span> <span class=\"o\">=</span> <span class=\"n\">py_preprocessor</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># This is just a comment</span>\n\n<span class=\"c1\">#exclude</span>\n<span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'-d'</span><span class=\"p\">:</span> <span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">define</span><span class=\"p\">(</span><span class=\"s2\">\"debug\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endexclude</span>\n\n<span class=\"k\">if</span> <span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parsed</span><span class=\"p\">():</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me always but just once. I'm using Python __VERSION__ !!!\"</span><span class=\"p\">)</span>\n\n   <span class=\"c1\">#ifdef debug</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\"</span><span class=\"p\">)</span>\n   <span class=\"c1\">#endif</span>\n\n<span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n</pre>\n<p>So, let\u2019s try again \u2026</p>\n<pre>$ python3 -m cpypp.tests.test_script02\nPRINT me always but just once. I'm using Python 3.7.6 !!!\n</pre>\n<pre>$ python3 -m cpypp.tests.test_script03 -d\nPRINT me always but just once. I'm using Python 3.7.6 !!!\nPRINT me only if '-d' used. I'm using Python 3.7.6 !!!\n</pre>\n<p>Yeah \ud83d\ude01. So the first rule of cpypp is that for scripts, we have to keep our <tt>PYPP.parse( ...</tt> call as next from top\nof code we can, or use <tt>if <span class=\"pre\">PYPP.parsed():</span></tt> logical condition, or both, so our code can be processed the way we\nwants. Another very important rule is:</p>\n<p>\u2757\ufe0f Your original source code <strong>HAS TO BE</strong> compilable in all Python versions, because this original source code has to\nrun so the processor can do its job.</p>\n<p>This means that a code like:</p>\n<pre><span class=\"c1\">#ifdef __PYTHON2__</span>\n<span class=\"nb\">print</span> <span class=\"s2\">\"This is\"</span><span class=\"p\">,</span> <span class=\"s2\">\"a debug code \"</span><span class=\"p\">,</span> <span class=\"s2\">\"and will NOT run  in Python 3\"</span>\n<span class=\"c1\">#else</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This is a debug code and is executes if we are using Python 3\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n</pre>\n<p>will not compile in Python 3 because  second line will generate a syntax error. In these case if you can\u2019t change the original code you can use the directive <tt>#expand</tt> as you see bellow.</p>\n<pre><span class=\"c1\">#ifdef __PYTHON2__</span>\n<span class=\"c1\">#expand print \"This is\", \"a debug code \", \"and will NOT run  in Python 3\"</span>\n<span class=\"c1\">#else</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This is a debug code and is executes if we are using Python 3\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n</pre>\n</div>\n<div id=\"how-python-and-cpypp-works-when-source-code-is-a-module-to-be-imported\">\n<h4><a href=\"#id10\" rel=\"nofollow\">How Python and cpypp works when source code is a module to be imported</a></h4>\n<p>Now, let\u2019s see a graphical flow how Python and cpypp will do their job to guarantee that the preprocessor will work\nproperly when importing a module</p>\n<pre>Flow\n|\n1\ufe0f\u20e3 Another Python scripts or module imports our original .py  file\n2\ufe0f\u20e3 Python reads original .py module file\n3\ufe0f\u20e3 compiles it in memory (.pyc)\n4\ufe0f\u20e3 loads, runs the compiled code and inserts an entry for it in ``sys.modules``\n   |\n   1\ufe0f\u20e3 All code before \"PYPP.parse( ...\" is executed \u2705\u2705\n   2\ufe0f\u20e3 When \"PYPP.parse( ...\" is called\n   |  |\n   |  1\ufe0f\u20e3 PYPP reads original .py file\n   |  2\ufe0f\u20e3 parse directives, clean the code and save new code in a file\n   |  3\ufe0f\u20e3 call __import__( ... ) to load the new code in the same ``sys.modules`` entry\n   |  4\ufe0f\u20e3 new code is executed\n   |\n   3\ufe0f\u20e3 All code after \"PYPP.parse( ...\" from original compiled code IS EXECUTED TOO \u2705\u2705\n</pre>\n<p>There are diferences from a script code. We have <tt>sys.modules</tt> that has to be modified at runtime, we can\u2019t call\n<tt>sys.exit</tt> because Python will halt and the most important, when the source file is\na module to be imported <strong>all the original code will be executed</strong> no matter which place you write\n<tt>PYPP.parse( ...</tt>. So we <strong>HAVE</strong> to use <tt>if <span class=\"pre\">PYPP.parsed():</span></tt> logical condition to prevent our code to be executed twice and avoid unpredictable runtime errors write <tt><span class=\"pre\">PYPP.parse(...</span></tt> after all references to <tt>PYPP.</tt> in source code. Let\u2019s see some pratical examples to understand better.</p>\n<p>You can protect only what is relevant. See <tt>import4.py</tt></p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n<span class=\"n\">PYPP</span> <span class=\"o\">=</span> <span class=\"n\">py_preprocessor</span><span class=\"p\">()</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">test_class</span><span class=\"p\">():</span> <span class=\"c1\"># classes and functions are not a problem because are only compiled</span>\n\n      <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n          <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This print has no problem\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">GLOBAL_VARIABLE</span> <span class=\"o\">=</span> <span class=\"s2\">\"PYTHON vr __VERSION__\"</span>\n<span class=\"c1\"># global variable definitions are most of time safe to become unprotected</span>\n\n<span class=\"k\">if</span> <span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parsed</span><span class=\"p\">():</span> <span class=\"c1\"># but code like this has to be protected at all</span>\n\n   <span class=\"k\">if</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">isfile</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/test.txt\"</span><span class=\"p\">):</span>\n      <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/test.txt\"</span><span class=\"p\">)</span>\n\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"module import4 imported and I was printed just once\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n</pre>\n<p>Or you can protect the all code. See <tt>import5.py</tt></p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n<span class=\"n\">PYPP</span> <span class=\"o\">=</span> <span class=\"n\">py_preprocessor</span><span class=\"p\">()</span>\n\n<span class=\"k\">if</span> <span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parsed</span><span class=\"p\">():</span> <span class=\"c1\"># You can protect the all code</span>\n\n   <span class=\"k\">class</span> <span class=\"nc\">test_class</span><span class=\"p\">():</span> <span class=\"c1\"># classes and functions are not a problem because are only compiled</span>\n\n         <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n             <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This print has no problem\"</span><span class=\"p\">)</span>\n\n   <span class=\"n\">GLOBAL_VARIABLE</span> <span class=\"o\">=</span> <span class=\"s2\">\"PYTHON vr __VERSION__\"</span>\n   <span class=\"c1\"># global variable definitions are most of time safe to become unprotected</span>\n\n   <span class=\"k\">if</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">isfile</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/test.txt\"</span><span class=\"p\">):</span>\n      <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"s2\">\"/tmp/test.txt\"</span><span class=\"p\">)</span>\n\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"module import5 imported and I was printed just once\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n</pre>\n<p>Or you can protect nothing if you code has only global, classes and defs definitions. See <tt>test06_import_module.py</tt></p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n<span class=\"n\">PYPP</span> <span class=\"o\">=</span> <span class=\"n\">py_preprocessor</span><span class=\"p\">()</span>\n\n<span class=\"n\">GLOBAL_VARIABLE</span> <span class=\"o\">=</span> <span class=\"s2\">\"PYTHON vr __VERSION__\"</span>\n<span class=\"c1\"># global variable definitions are most of time safe to become unprotected</span>\n<span class=\"k\">class</span> <span class=\"nc\">test_class</span><span class=\"p\">():</span> <span class=\"c1\"># classes and functions are not a problem because are only compiled</span>\n\n      <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n          <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This print has no problem\"</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"I don't care if this line is printed twice\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n</pre>\n<p>Let\u2019s import all of then</p>\n<pre>&gt;&gt;&gt; cpypp.tests.imports import impor4\nmodule import4 was imported and I was printed just once\n&gt;&gt;&gt; cpypp.tests.imports import impor5\nmodule import5 was imported and I was printed just once\n&gt;&gt;&gt; cpypp.tests.imports import impor6\nI don't care if this line is printed twice\nI don't care if this line is printed twice\n</pre>\n<p>Yeah again\ud83d\ude01. Here the rule is that for import modules, we have to use <tt>if <span class=\"pre\">PYPP.parsed():</span></tt> logical condition, in the whole code if necessary, and write <tt>PYPP.parse <span class=\"pre\">(...</span></tt> at the end of our source code, so our code can be processed the way we wants.</p>\n<p>Another thing that is very important:</p>\n<div>\n<div>\u2757\ufe0f <tt>if <span class=\"pre\">PYPP.parsed():</span></tt> logical condition, <strong>CAN ALSO</strong> be replaced by <tt>if False and False:</tt>.</div>\n<div>\u2757\ufe0f cpypp will understand this too.</div>\n</div>\n</div>\n</div>\n<div id=\"command-line-preprocessor\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Command line preprocessor</a></h3>\n<p>Command line preprocessor is when you have source code files and wants to generate new preprocessed files in\nbatch mode. Probably you are a developer and want to insert copyright marks, or remove something from final code, like\n<tt>prints</tt>, debugs and so on, or you know exactly what version of Python will execute your code and wants to\ngenerate a final code totally compatible with it. Almost like C does with <tt>make</tt>.</p>\n<p>Here we have no flow. It\u2019s just a command line tool that has some parameters and you can run it from shell.</p>\n<pre>$ python2.7+ -m cpypp -r -d debug cpypp./tests/test_commandline01.pyp\n</pre>\n<p>\u2757\ufe0f The code generated is <strong>DIRECTLY DEPENDENT</strong> from the Python version you run the command line</p>\n<div id=\"options\">\n<h4><a href=\"#id12\" rel=\"nofollow\">Options</a></h4>\n<p>Usage: <tt>cpyppc [options] <span class=\"pre\">filename-or-directory</span> <span class=\"pre\">[...]</span></tt></p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><td>\n<kbd><span class=\"option\">-h</span>, <span class=\"option\">--help</span></kbd></td>\n<td>show this help message and exit</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-v</span>, <span class=\"option\">--version</span></kbd></td>\n<td>print cpypp version</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-d <var>name</var></span></kbd></td>\n<td>same as #define. Ex. <tt><span class=\"pre\">-d</span></tt> debug or <tt><span class=\"pre\">-d</span> \"var=2+2\"</tt> (eval 4)</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-e <var>EXT</var></span></kbd></td>\n<td>include files with only these extensions. default is <tt>'.py'</tt>\nand extensions must be separated with <tt>'|'</tt> char. Ex.\n<tt><span class=\"pre\">'.py|.pypp'</span></tt></td></tr>\n<tr><td>\n<kbd><span class=\"option\">-l <var>MAXLEVELS</var></span></kbd></td>\n<td>levels to recurse into subdirectories. Use <tt>'0'</tt> to don\u2019t\nrecurse. Default is no limit</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-p <var>PATH</var></span></kbd></td>\n<td>directory to prepend to file names and paths before save\nprocessed files. The full path will be created if it does\nnot exists</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-f</span></kbd></td>\n<td>force overwrite of files when output file name has the\nsame name of input file name</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-r</span></kbd></td>\n<td>remove meta tags and commented lines from final code</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-o <var>FILE</var></span></kbd></td>\n<td>output file name when you are preprocessing just one file\nat once. Use <tt><span class=\"pre\">'-o</span> <span class=\"pre\">-'</span></tt> to stdout</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-i <var>FILE</var></span></kbd></td>\n<td>add all the files and directories listed in FILE to the\nlist considered for compilation; Use <tt><span class=\"pre\">'-'</span></tt> to read\nnames from stdin</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-q</span></kbd></td>\n<td>output only error messages; <tt><span class=\"pre\">-qq</span></tt> will suppress the error\nmessages as well</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-c</span>, <span class=\"option\">--compileall</span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td>compile each file after preprocessing. When this option is\nused, no preprocessed source file will be saved to disk and\noptions <tt><span class=\"pre\">'-o'</span></tt>, <tt><span class=\"pre\">'-r'</span></tt> and <tt><span class=\"pre\">'-f'</span></tt> are discarded</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-b</span></kbd></td>\n<td>use legacy (pre-PEP3147) compiled file locations. Valid\nonly when <tt><span class=\"pre\">'-c'</span></tt> is used</td></tr>\n</tbody>\n</table>\n</div>\n<div id=\"id1\">\n<h4><a href=\"#id13\" rel=\"nofollow\">Examples</a></h4>\n<p>Let\u2019s use one of our script files <tt>test_script03.py</tt></p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">from</span> <span class=\"nn\">cpypp</span> <span class=\"kn\">import</span> <span class=\"n\">py_preprocessor</span>\n<span class=\"n\">PYPP</span> <span class=\"o\">=</span> <span class=\"n\">py_preprocessor</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># This is just a comment</span>\n\n<span class=\"c1\">#exclude</span>\n<span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'-d'</span><span class=\"p\">:</span> <span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">define</span><span class=\"p\">(</span><span class=\"s2\">\"debug\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endexclude</span>\n\n<span class=\"k\">if</span> <span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parsed</span><span class=\"p\">():</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me always but just once. I'm using Python __VERSION__ !!!\"</span><span class=\"p\">)</span>\n\n   <span class=\"c1\">#ifdef debug</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\"</span><span class=\"p\">)</span>\n   <span class=\"c1\">#endif</span>\n\n<span class=\"n\">PYPP</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span>\n</pre>\n<p>Now let\u2019s run <tt>cpypp</tt> and don\u2019t remove metada to see all preprocessor work.</p>\n<pre>$ python3 -m cpypp cpypp/tests/test_script03.py -o -\n</pre>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"c1\"># from cpypp import py_preprocessor</span>\n<span class=\"c1\"># PYPP = py_preprocessor()</span>\n\n<span class=\"c1\"># This is just a comment</span>\n\n<span class=\"c1\"># #exclude</span>\n<span class=\"c1\"># if len(sys.argv) &gt; 1 and sys.argv[1] == '-d': PYPP.define(\"debug\")</span>\n<span class=\"c1\"># #endexclude</span>\n\n<span class=\"c1\"># if PYPP.parsed():</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me always but just once. I'm using Python 3.7.6 !!!\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># #ifdef debug</span>\n<span class=\"c1\"># print(\"PRINT me only if '-d' used. I'm using Python __VERSION__ !!!\")</span>\n<span class=\"c1\"># #endif</span>\n</pre>\n<p>Realize that any references to <tt>py_preprocessor</tt> were commented and the block <tt>if <span class=\"pre\">PYPP.parsed():</span></tt>\nhas been commented too and all code bellow was reidented.\nLet\u2019s remove metada data now.</p>\n<pre>$ python3 -m cpypp -r cpypp/tests/test_script03.py -o -\n</pre>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n\n<span class=\"c1\"># This is just a comment</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"PRINT me always but just once. I'm using Python 3.7.6 !!!\"</span><span class=\"p\">)</span>\n</pre>\n<p>\u2757\ufe0f As you can see there is <strong>NO DEPENDENCY</strong> in final code from cpypp.</p>\n</div>\n<div id=\"preprocessing-and-compiling-code-at-once\">\n<h4><a href=\"#id14\" rel=\"nofollow\">Preprocessing and compiling code at once</a></h4>\n<p>cpypp can compile bytecode files (.pyc) directly from the preprocessed file without need to save the new file to\ndisk an execute <tt>python <span class=\"pre\">-m</span> compileall</tt>, and is as simple as this. Just use <tt><span class=\"pre\">-c</span></tt> or <tt><span class=\"pre\">--compileall</span></tt> option.</p>\n<pre>$ python -m cpypp --compileall diretory_or_file      # generate __pycache__/.pyc files\n$ python -m cpypp -b --compileall diretory_or_file   # generate .pyc files at same dir\n</pre>\n<p>Your bytecodes (.pyc) where generated using the preprocessed file and are ready to deploy. For more\ninformation and usage execute <tt>python cpypp <span class=\"pre\">--help</span></tt>.</p>\n</div>\n</div>\n</div>\n<div id=\"expander\">\n<h2><a href=\"#id15\" rel=\"nofollow\">Expander</a></h2>\n<p>cpypp implements some expanders that look for names and special characters in the source code and replace then\nfor defined values or expressions.</p>\n<div id=\"name-definitions-expander\">\n<h3><a href=\"#id16\" rel=\"nofollow\">Name definitions expander</a></h3>\n<p>Any references to name definitions done with <tt>#define</tt> in source file will be replaced by its <tt>repr()</tt> value.\nNote than any references means any place where definition names appears, even inside strings. To avoid this\nreplacement precede the name with <tt>'!'</tt>\nFor example, the code:</p>\n<pre><span class=\"c1\">#define SIZE 100 * 2</span>\n<span class=\"c1\">#define TEXT \"cpypp\" + \" is \" + \"the best\"</span>\n\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">SIZE</span><span class=\"p\">):</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">TEXT</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"The value of !TEXT is TEXT\"</span><span class=\"p\">)</span>\n</pre>\n<p>after preprocessing will become:</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">):</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'cpypp is the best'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"The value of TEXT is 'cpypp is the best'\"</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"expressions-expander\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Expressions expander</a></h3>\n<p>For more complexes replacements there is expression expander. All text between expander begin mark <tt><span class=\"pre\">'#{'</span></tt> and\nexpander end mark <tt>}#'</tt> will be evaluated and replaced exactly at same place by its <tt>str()</tt> value. If you wants\nthat replacement value be by its <tt>repr()</tt> value, insert a modifier at end of expression, without spaces from <tt>'}'</tt>.\nThe modifiers are <tt>',s</tt> for <tt>str()</tt> value and <tt>',r'</tt> for <tt>repr()</tt> value.\nFor example, the code:</p>\n<pre><span class=\"ch\">#! env python#{__VERSION__[0]}#</span>\n\n<span class=\"c1\">#define VALUE 5 if __PYTHON2__ else 6</span>\n<span class=\"c1\">#define TEXT \"cpypp\" + \" is \" + \"the best\"</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"!VALUE + 1 = #{VALUE + 1}# and #</span><span class=\"si\">{TEXT}</span><span class=\"s2\"># and #{TEXT,r}#\"</span><span class=\"p\">)</span>\n</pre>\n<p>after preprocessing with <tt>python2</tt> will become:</p>\n<pre><span class=\"ch\">#! env python2</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"VALUE + 1 = 6 and cpypp is the best and 'cpypp is the best'\"</span><span class=\"p\">)</span>\n</pre>\n<p>and after preprocessing with <tt>python3</tt> will become:</p>\n<pre><span class=\"ch\">#! env python3</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"VALUE + 1 = 7 and cpypp is the best and 'cpypp is the best'\"</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"directives\">\n<h2><a href=\"#id18\" rel=\"nofollow\">Directives</a></h2>\n<div id=\"name-definitions-define-undef\">\n<h3><a href=\"#id19\" rel=\"nofollow\">Name definitions (#define, #undef)</a></h3>\n<p>Define names, or names with values that will be stored in definition dictionary.</p>\n<p><tt>#define identifier [expression]</tt></p>\n<p>When the preprocessor encounters this directive, it creates an entry in its definition dictionary with name <tt>identifier</tt> and the value with evaluation of <tt>expression</tt>. If <tt>expression</tt> is ommited, <tt>True</tt> is used.</p>\n<pre><span class=\"c1\">#define DEBUG</span>\n<span class=\"c1\">#define TABLE_SIZE (50 * 50 if __PYTHON2__ else 100 * 100)</span>\n\n<span class=\"n\">block</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"s2\">\" \"</span> <span class=\"o\">*</span> <span class=\"n\">TABLE_SIZE</span><span class=\"p\">)</span>\n\n<span class=\"c1\">#ifdef DEBUG</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Debug is ON !!!\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n</pre>\n<p>To remove an entry from definition dictionary use</p>\n<p><tt>#undef identifier</tt></p>\n</div>\n<div id=\"conditional-inclusions-if-else-endif-and-its-variations\">\n<h3><a href=\"#id20\" rel=\"nofollow\">Conditional inclusions (#if, #else, #endif and its variations)</a></h3>\n<p>These directives allow to include or discard part of the original code, also called code blocks if a certain\ncondition is met or not.\nIt works the same manner that <tt>if/elif/else</tt> in python. The diference is that we have <tt>#endif</tt> and its\nvariations to close opened <tt>#if blocks</tt> cause we don\u2019t have identation and there are more directives\nthat gives more flexibility.</p>\n<p>Here are all the conditional inclusions directives and how they are evalueted.</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td><strong>#ifdef</strong> <tt>identifier</tt></td>\n<td><div>\n<div>Opens a block of code and includes its content if <tt>identifier</tt> is a name</div>\n<div>in definition dictionary, no matter its value.</div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#ifndef</strong> <tt>identifier</tt></td>\n<td><div>\n<div>Open a block of code and includes its content if <tt>identifier</tt> is not a name</div>\n<div>in definition dictionary.</div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#if</strong> <tt>expression</tt></td>\n<td><div>\n<div>Open a block of code and includes it if <tt>expression</tt> is evaluated to <tt>True</tt>.</div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#else</strong></td>\n<td><div>\n<div>Closes the last opened block of code,  opens a new block of code</div>\n<div>and includes it if any block above and at same level was not <tt>True</tt></div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#elif</strong> <tt>expression</tt></td>\n<td><div>\n<div>Closes the last opened block of code,  opens a new block of code</div>\n<div>and includes it if  <tt>expression</tt> is evaluated to <tt>True</tt> and any block</div>\n<div>above and at same level was not <tt>True</tt></div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#elifdef</strong> <tt>identifier</tt></td>\n<td><div>\n<div>Closes the last opened block of code,  opens a new block of code</div>\n<div>and includes it if <tt>identifier</tt> is a name in definition dictionary,</div>\n<div>no matter its value and any block above and at same level was not <tt>True</tt>.</div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#endif</strong></td>\n<td><div>\n<div>Closes the last opened block of code at same level</div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#endififdef</strong> <tt>identifier</tt></td>\n<td><div>\n<div>Same as <strong>#endif</strong> + <strong>#ifdef</strong> but at the same line</div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#endifif</strong> <tt>expression</tt></td>\n<td><div>\n<div>Same as <strong>#endif</strong> + <strong>#if</strong> but at the same line</div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#endifall</strong></td>\n<td><div>\n<div>Close all opened blocks no matter if they are inner or outter. Use with care.</div>\n</div>\n</td>\n</tr>\n</tbody>\n</table>\n<div id=\"examples-of-conditional-inclusions\">\n<h4><a href=\"#id21\" rel=\"nofollow\">Examples of Conditional inclusions</a></h4>\n<pre><span class=\"c1\"># compile block if DEBUG was defined before</span>\n\n<span class=\"c1\">#ifdef DEBUG</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Debug is ON !!!\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n\n<span class=\"c1\"># compile block if DEBUG was not defined or was excluded from definition dictionary</span>\n\n<span class=\"c1\">#undef DEBUG</span>\n<span class=\"c1\">#ifndef DEBUG</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Debug is ON !!!\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n\n<span class=\"c1\"># compile block if expression is True</span>\n\n<span class=\"c1\"># define INT_VER int(VERSION[0])</span>\n<span class=\"c1\">#if DEBUG is True and INT_VER &gt; 2</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Debug is ON and Python is 3+!!!\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#elif INT_VER == 2</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Python certainly is 2.x\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#else</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"I'm sure Debug is ON or OFF :)\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n</pre>\n</div>\n</div>\n<div id=\"exclusion-blocks-exclude-and-endexclude\">\n<h3><a href=\"#id22\" rel=\"nofollow\">Exclusion blocks (#exclude and #endexclude)</a></h3>\n<p>Depending of your code, sometimes you want to exclude an entire block of code if some conditions are met or not\nor not, or  maybe you wants that only the preprocessor executes this portion of code, but wants remove this\nportion from final code. For this we have the directives <strong>#exclude</strong> and <strong>#endexclude</strong>. All inside this two directives will be completely exclude from final code, but will be seen by preprocessor.</p>\n<pre><span class=\"c1\">#define NUMPY_E __import__(\"numpy\").e</span>\n<span class=\"c1\">#define NUMPY_EULER_GAMA __import__(\"numpy\").euler_gama</span>\n<span class=\"n\">numpy_e</span> <span class=\"o\">=</span> <span class=\"n\">NUMPY_E</span>\n<span class=\"n\">numpy_euler_gama</span> <span class=\"o\">=</span> <span class=\"n\">NUMPY_EULER_GAMA</span>\n</pre>\n<p>We imported numpy package only at preprocessor time to get the values of these two constants and set two local\nvariables. <tt>numpy</tt> package don\u2019t need to be installed where the final code will execute. Neither cpypp as\nwe already know.</p>\n</div>\n<div id=\"ignore-blocks-ignore-and-endignore\">\n<h3><a href=\"#id23\" rel=\"nofollow\">Ignore blocks (#ignore and #endignore)</a></h3>\n<p>These directives do exactly what their name says. They ignore from the preprocessor an entire block of code.</p>\n<pre><span class=\"c1\">#ignore</span>\n<span class=\"c1\">#define NONE \"This defines will never occurs because this block is ignored\"</span>\n<span class=\"c1\">#ifndef NONE</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This !TEXT will be printed exactly how it is #{PRINT_ME#}\"</span><span class=\"p\">)</span> <span class=\"c1\"># Will print always</span>\n<span class=\"c1\">#endif</span>\n<span class=\"c1\">#endignore</span>\n</pre>\n</div>\n<div id=\"source-file-inclusion-include-and-includeident\">\n<h3><a href=\"#id24\" rel=\"nofollow\">Source file inclusion (#include and #includeident)</a></h3>\n<p>When the preprocessor finds an <tt>#include</tt> or <tt>#includeident</tt> directive it replaces it by the entire\ncontent of the specified file. The diference between <tt>#include</tt> and <tt>#includeident</tt> is that\n<tt>#include</tt> will always include each line of included file starting of column 1 and <tt>#includeident</tt> will\nalways include each line of incuded file starting at same column where <tt>#includeident</tt> was written.\nThere are two ways to use #include:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td><strong>#include</strong> <tt>&lt;filename&gt;</tt></td>\n<td><div>\n<div>When filename is specified between angle-backets, cpypp looks for the</div>\n<div>filename in all directories listed in <tt>sys.path</tt>. The first existing file</div>\n<div>will be included.</div>\n</div>\n</td>\n</tr>\n<tr><td><strong>#include</strong> <tt>expression</tt></td>\n<td><div>\n<div>When filename is not specified between angle-brackes, cpypp assumes that this</div>\n<div>is an expression, evaluates it and the result as used as  absolute path of file.</div>\n<div>If the file exists it will be included.</div>\n</div>\n</td>\n</tr>\n</tbody>\n</table>\n<p>Supose that <tt>include.py</tt> has the following content.</p>\n<pre>print(\"I'm an included file\")\n</pre>\n<p>Now let\u2019s see this code.</p>\n<pre><span class=\"c1\">#include \"include.py\"</span>\n    <span class=\"c1\">#include \"include.py\"</span>\n\n<span class=\"k\">if</span> <span class=\"n\">some_condition</span><span class=\"p\">:</span>\n   <span class=\"c1\">#includeident \"include.py\"</span>\n</pre>\n<p>If we check the preprocessed file we will find:</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"I'm an included file\"</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"I'm an included file\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"n\">some_condition</span><span class=\"p\">:</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"I'm an included file\"</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"code-protection-expand\">\n<h3><a href=\"#id25\" rel=\"nofollow\">Code protection (#expand)</a></h3>\n<p>As you remember, the original code is compiled twice, one before the preprocessor and other after.\nSo at both compiling steps the code must be correct and without syntax or grammar errors.</p>\n<p>Sometimes we want to implement some features in our code that are not available in all Python versions,\nbut we need that our code compile correctly so the preprocessor can do its work. For this we have <tt>#expand</tt>\ndirective. If you had a piece of code that is not compatible with all versions of Python you put it as parameter\nof <tt>#expand</tt>. The first step of compiling will consider this line as a comment and will ignore it. And the\npreprocessor will do its job. For example:</p>\n<pre><span class=\"c1\">#if __PYTHON2__</span>\n<span class=\"nb\">print</span> <span class=\"s2\">\"This\"</span><span class=\"p\">,</span><span class=\"s2\">\"is\"</span><span class=\"p\">,</span> <span class=\"s2\">\"a\"</span><span class=\"p\">,</span><span class=\"s2\">\"python\"</span><span class=\"p\">,</span><span class=\"s2\">\"program\"</span>\n<span class=\"c1\">#else</span>\n<span class=\"nb\">print</span> <span class=\"p\">(</span><span class=\"s2\">\"This is a python program\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n</pre>\n<p>The code above will generate a compile error if we try to run it on Python 3+, because the first <tt>print</tt> statement\ndoes not meet the Python 3 syntax. So the solution is to hide this code from first compiling. <tt>#expand</tt> will do\nthis for us.</p>\n<pre><span class=\"c1\">#if __PYTHON2__</span>\n<span class=\"c1\">#expand print \"This\",\"is\", \"a\",\"python\",\"program\"</span>\n<span class=\"c1\">#else</span>\n<span class=\"nb\">print</span> <span class=\"p\">(</span><span class=\"s2\">\"This is a python program\"</span><span class=\"p\">)</span>\n<span class=\"c1\">#endif</span>\n</pre>\n<p>Now the first compiling will occur with no problem no matter what Python version is used\nand the preprocessor will go on.</p>\n</div>\n</div>\n<div id=\"contributing\">\n<h2><a href=\"#id26\" rel=\"nofollow\">Contributing</a></h2>\n<p>Please send an email to <a href=\"mailto:wellrats%40gmail.com\">wellrats<span>@</span>gmail<span>.</span>com</a></p>\n</div>\n\n          </div>"}, "last_serial": 6406046, "releases": {"1.0.3": [{"comment_text": "", "digests": {"md5": "b0860bb093a3e608e93e54e50bafc227", "sha256": "29b2d23f616bf3c89e2462757824f2a69cc92b8f9decf80dfd56abfe7b801aaa"}, "downloads": -1, "filename": "cpypp-1.0.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b0860bb093a3e608e93e54e50bafc227", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 31540, "upload_time": "2020-01-05T16:55:14", "upload_time_iso_8601": "2020-01-05T16:55:14.046595Z", "url": "https://files.pythonhosted.org/packages/99/f7/f3ea5a960e4a37f737d45459bea7d4136b5ce9c9285d74511565522c5133/cpypp-1.0.3-py2.py3-none-any.whl", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "d65bea3ed4563b099fc8c0b2f943ff9a", "sha256": "387395b7853a706b9f3744554cc7b22d95ee862f906921e0b321c5e44793c66a"}, "downloads": -1, "filename": "cpypp-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d65bea3ed4563b099fc8c0b2f943ff9a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 32204, "upload_time": "2020-01-07T01:28:23", "upload_time_iso_8601": "2020-01-07T01:28:23.880538Z", "url": "https://files.pythonhosted.org/packages/4f/d1/6a7d11492d2ed7f42f0c03dc95e3371011404b09275e0c0d75f6dd751412/cpypp-1.1.0-py2.py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d65bea3ed4563b099fc8c0b2f943ff9a", "sha256": "387395b7853a706b9f3744554cc7b22d95ee862f906921e0b321c5e44793c66a"}, "downloads": -1, "filename": "cpypp-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d65bea3ed4563b099fc8c0b2f943ff9a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 32204, "upload_time": "2020-01-07T01:28:23", "upload_time_iso_8601": "2020-01-07T01:28:23.880538Z", "url": "https://files.pythonhosted.org/packages/4f/d1/6a7d11492d2ed7f42f0c03dc95e3371011404b09275e0c0d75f6dd751412/cpypp-1.1.0-py2.py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 00:42:32 2020"}