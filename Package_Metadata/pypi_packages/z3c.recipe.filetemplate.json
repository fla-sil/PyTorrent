{"info": {"author": "Gary Poster", "author_email": "gary.poster@canonical.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Framework :: Buildout", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Software Development :: Build Tools"], "description": "``z3c.recipe.filetemplate``\n***************************\n\n===========\nBasic Usage\n===========\n\nWith the ``z3c.recipe.filetemplate`` buildout recipe you can automate\nthe generation of text files from templates.  Upon execution, the\nrecipe will read a number of template files, perform variable\nsubstitution and write the result to the corresponding output files.\n\nThe recipe has several features, but it always takes template files with a\n``.in`` suffix, processes the template, and writes out the file to the desired\nlocation with the same file mode, and the same name but without the ``.in``\nsuffix.\n\nFor example, consider this simple template for a text file:\n\n    >>> write(sample_buildout, 'helloworld.txt.in',\n    ... \"\"\"\n    ... Hello ${world}!\n    ... \"\"\")\n\nNow let's create a buildout configuration so that we can substitute\nthe values in this file.  All we have to do is define a part that uses\nthe ``z3c.recipe.filetemplate`` recipe.  With the ``files`` parameter\nwe specify one or more files that need substitution (separated by\nwhitespace).  Then we can add arbitrary parameters to the section.\nThose will be used to fill the variables in the template:\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... files = helloworld.txt\n    ... world = Philipp\n    ... \"\"\")\n\nAfter executing buildout, we can see that ``${world}`` has indeed been\nreplaced by ``Philipp``:\n\n    >>> print system(buildout)\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt')\n    Hello Philipp!\n\nIf you need to escape the ${...} pattern, you can do so by repeating the dollar\nsign.\n\n    >>> update_file(sample_buildout, 'helloworld.txt.in',\n    ... \"\"\"\n    ... Hello world! The double $${dollar-sign} escapes!\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt')\n    Hello world! The double ${dollar-sign} escapes!\n\nNote that dollar signs alone, without curly braces, are not parsed.\n\n    >>> update_file(sample_buildout, 'helloworld.txt.in',\n    ... \"\"\"\n    ... $Hello $$world! $$$profit!\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt')\n    $Hello $$world! $$$profit!\n\nNote that the output file uses the same permission bits as found on the input\nfile.\n\n    >>> import stat\n    >>> import os\n    >>> input = os.path.join(sample_buildout, 'helloworld.txt.in')\n    >>> output = input[:-3]\n    >>> os.chmod(input, 0755)\n    >>> stat.S_IMODE(os.stat(input).st_mode) == 0755\n    True\n    >>> stat.S_IMODE(os.stat(output).st_mode) == 0755\n    False\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n    >>> stat.S_IMODE(os.stat(output).st_mode) == 0755\n    True\n\nSource Folders and Globs\n========================\n\nBy default, the recipe looks for a ``.in`` file relative to the buildout root,\nand places it in the same folder relative to the buildout root.  However, if\nyou don't want to clutter up the destination folder, you can add a prefix to\nthe source folder.  Here is an example.\n\nFirst, we specify a ``source-directory`` in the buildout.  You can specify\n``files`` as a filter if desired, but by default it will find any file (ending\nwith \".in\"). You can also specify ``exclude-directories`` option if you want\nto exclude some paths from the ``source-directory`` search path.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... source-directory = template\n    ... world = Philipp\n    ... \"\"\")\n\nNow we'll make a \"template\" directory, as listed in the buildout configuration\nabove, and populate it for our example.\n\n    >>> mkdir(sample_buildout, 'template')\n    >>> mkdir(sample_buildout, 'template', 'etc')\n    >>> mkdir(sample_buildout, 'template', 'bin')\n    >>> write(sample_buildout, 'template', 'etc', 'helloworld.conf.in',\n    ... \"\"\"\n    ... Hello ${world} from the etc dir!\n    ... \"\"\")\n    >>> write(sample_buildout, 'template', 'bin', 'helloworld.sh.in',\n    ... \"\"\"\n    ... Hello ${world} from the bin dir!\n    ... \"\"\")\n    >>> os.chmod(\n    ...     os.path.join(\n    ...         sample_buildout, 'template', 'bin', 'helloworld.sh.in'),\n    ...     0711)\n\nNotice that, before running buildout, the ``helloworld.txt`` file is still\naround, we don't have an etc directory, and the bin directory doesn't have our\n``helloworld.sh``.\n\n    >>> ls(sample_buildout)\n    -  .installed.cfg\n    d  bin\n    -  buildout.cfg\n    d  develop-eggs\n    d  eggs\n    -  helloworld.txt\n    -  helloworld.txt.in\n    d  parts\n    d  template\n    >>> ls(sample_buildout, 'bin')\n    -  buildout\n\nNow we install.  The old \"helloworld.txt\" is gone, and we now see etc.  Note\nthat, for the destination, intermediate folders are created if they do not\nexist.\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n    >>> ls(sample_buildout)\n    -  .installed.cfg\n    d  bin\n    -  buildout.cfg\n    d  develop-eggs\n    d  eggs\n    d  etc\n    -  helloworld.txt.in\n    d  parts\n    d  template\n\nThe files exist and have the content we expect.\n\n    >>> ls(sample_buildout, 'bin')\n    - buildout\n    - helloworld.sh\n    >>> cat(sample_buildout, 'bin', 'helloworld.sh')\n    Hello Philipp from the bin dir!\n    >>> stat.S_IMODE(os.stat(os.path.join(\n    ...     sample_buildout, 'bin', 'helloworld.sh')).st_mode) == 0711\n    True\n    >>> ls(sample_buildout, 'etc')\n    - helloworld.conf\n    >>> cat(sample_buildout, 'etc', 'helloworld.conf')\n    Hello Philipp from the etc dir!\n\nIf you use the ``files`` option along with ``source-directory``, it becomes a\nfilter.  Every target file must match at least one of the names in ``files``.\nTherefore, if we only build .sh files, the etc directory will disappear.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... source-directory = template\n    ... files = *.sh\n    ... world = Philipp\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n    >>> ls(sample_buildout)\n    -  .installed.cfg\n    d  bin\n    -  buildout.cfg\n    d  develop-eggs\n    d  eggs\n    -  helloworld.txt.in\n    d  parts\n    d  template\n\n    >>> ls(sample_buildout, 'bin')\n    - buildout\n    - helloworld.sh\n\nAlso note that, if you use a source directory and your ``files`` specify a\ndirectory, the directory must match precisely.\n\nWith the ``exclude-directories`` parameter, we specify one or more directories\n(separated by whitespace) in which the recipe will not look for template\nfiles. The ``exclude-directories`` option should be used along with the\n``source-directory`` option.\nTherefore, if we set ``exclude-directories`` to ``bin``, the\n``bin/helloworld.sh`` file will disappear.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... source-directory = template\n    ... exclude-directories = bin\n    ... world = Philipp\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n    >>> ls(sample_buildout)\n    -  .installed.cfg\n    d  bin\n    -  buildout.cfg\n    d  develop-eggs\n    d  eggs\n    d  etc\n    -  helloworld.txt.in\n    d  parts\n    d  template\n\n    >>> ls(sample_buildout, 'etc')\n    - helloworld.conf\n\n    >>> ls(sample_buildout, 'bin')\n    - buildout\n\n    >>> # Clean up for later test.\n    >>> import shutil\n    >>> shutil.rmtree(os.path.join(sample_buildout, 'template', 'etc'))\n    >>> os.remove(os.path.join(\n    ...     sample_buildout, 'template', 'bin', 'helloworld.sh.in'))\n\n==============\nAdvanced Usage\n==============\n\nSubstituting from Other Sections\n================================\n\nSubstitutions can also come from other sections in the buildout, using the\nstandard buildout syntax, but used in the template.  Notice\n``${buildout:parts}`` in the template below.\n\n    >>> update_file(sample_buildout, 'helloworld.txt.in',\n    ... \"\"\"\n    ... Hello ${world}.  I used these parts: ${buildout:parts}.\n    ... \"\"\")\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... files = helloworld.txt\n    ... world = Philipp\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt')\n    Hello Philipp.  I used these parts: message.\n\nPath Extensions\n===============\n\nSubstitutions can have path suffixes using the POSIX \"/\" path separator.\nThe template will convert these to the proper path separator for the current\nOS.  They also then are part of the value passed to filters, the feature\ndescribed next.  Notice ``${buildout:directory/foo/bar.txt}`` in the template\nbelow.\n\n    >>> update_file(sample_buildout, 'helloworld.txt.in',\n    ... \"\"\"\n    ... Here's foo/bar.txt in the buildout:\n    ... ${buildout:directory/foo/bar.txt}\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt') # doctest: +ELLIPSIS\n    Here's foo/bar.txt in the buildout:\n    /.../sample-buildout/foo/bar.txt\n\nFilters\n=======\n\nYou can use pipes within a substitution to filter the original value.  This\nrecipe provides several filters for you to use.  The syntax is reminiscent of\n(and inspired by) POSIX pipes and Django template filters.  For example,\nif world = Philipp, ``HELLO ${world|upper}!`` would result in ``HELLO\nPHILIPP!``.\n\nA few simple Python string methods are exposed as filters right now:\n\n- capitalize: First letter in string is capitalized.\n- lower: All letters in string are lowercase.\n- title: First letter of each word in string is capitalized.\n- upper: All letters in string are uppercase.\n\nOther filters are important for handling paths if buildout's relative-paths\noption is true.  See `Working with Paths`_ for more details.\n\n- path-repr: Converts the path to a Python expression for the path.  If\n  buildout's relative-paths option is false, this will simply be a repr\n  of the absolute path.  If relative-paths is true, this will be a\n  function call to convert a buildout-relative path to an absolute path;\n  it requires that ``${python-relative-path-setup}`` be included earlier\n  in the template.\n\n- shell-path: Converts the path to a shell expression for the path.  Only\n  POSIX is supported at this time.  If buildout's relative-paths option\n  is false, this will simply be the absolute path.  If relative-paths is\n  true, this will be an expression to convert a buildout-relative path\n  to an absolute path; it requires that ``${shell-relative-path-setup}``\n  be included earlier in the template.\n\nCombining the three advanced features described so far, then, if the\nbuildout relative-paths option were false, we were in a POSIX system, and\nthe sample buildout were in the root of the system, the template\nexpression ``${buildout:bin-directory/data/initial.csv|path-repr}``\nwould result in ``'/sample-buildout/bin/data/initial.csv'``.\n\nHere's a real, working example of the string method filters.  We'll have\nexamples of the path filters in the `Working with Paths`_ section.\n\n    >>> update_file(sample_buildout, 'helloworld.txt.in',\n    ... \"\"\"\n    ... HELLO ${world|upper}!\n    ... hello ${world|lower}.\n    ... ${name|title} and the Chocolate Factory\n    ... ${sentence|capitalize}\n    ... \"\"\")\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... files = helloworld.txt\n    ... world = Philipp\n    ... name = willy wonka\n    ... sentence = that is a good book.\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt') # doctest: +ELLIPSIS\n    HELLO PHILIPP!\n    hello philipp.\n    Willy Wonka and the Chocolate Factory\n    That is a good book.\n\nSharing Variables\n=================\n\nThe recipe allows extending one or more sections, to decrease\nrepetition, using the ``extends`` option.  For instance, consider the\nfollowing buildout.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [template_defaults]\n    ... mygreeting = Hi\n    ... myaudience = World\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... files = helloworld.txt\n    ... extends = template_defaults\n    ...\n    ... myaudience = everybody\n    ... \"\"\")\n\nThe \"message\" section now has values extended from the \"template_defaults\"\nsection, and overwritten locally.  A template of\n``${mygreeting}, ${myaudience}!``...\n\n    >>> update_file(sample_buildout, 'helloworld.txt.in',\n    ... \"\"\"\n    ... ${mygreeting}, ${myaudience}!\n    ... \"\"\")\n\n...would thus result in ``Hi, everybody!``.\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt')\n    Hi, everybody!\n\nDefining options in Python\n==========================\n\nYou can specify that certain variables should be interpreted as Python using\n``interpreted-options``.  This takes zero or more lines.  Each line should\nspecify an option.  It can define immediately (see ``silly-range`` in\nthe example below) or point to an option to be interepreted, which can\nbe useful if you want to define a multi-line expression (see\n``first-interpreted-option`` and ``message-reversed-is-egassem``).\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... files = helloworld.txt\n    ... interpreted-options = silly-range = repr(range(5))\n    ...                       first-interpreted-option\n    ...                       message-reversed-is-egassem\n    ... first-interpreted-option =\n    ...     options['interpreted-options'].splitlines()[0].strip()\n    ... message-reversed-is-egassem=\n    ...     ''.join(\n    ...         reversed(\n    ...             buildout['buildout']['parts']))\n    ... not-interpreted=hello world\n    ... \"\"\")\n\n    >>> update_file(sample_buildout, 'helloworld.txt.in', \"\"\"\\\n    ... ${not-interpreted}!\n    ... silly-range: ${silly-range}\n    ... first-interpreted-option: ${first-interpreted-option}\n    ... message-reversed-is-egassem: ${message-reversed-is-egassem}\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt') # doctest:+ELLIPSIS\n    hello world!\n    silly-range: [0, 1, 2, 3, 4]\n    first-interpreted-option: silly-range = repr(range(5))\n    message-reversed-is-egassem: egassem\n\nWorking with Paths\n==================\n\nWe've already mentioned how to handle buildout's relative-paths option\nin the discussion of filters.  This section has some concrete examples\nand discussion of that.  It also introduces how to get a set of paths\nfrom specifying dependencies.\n\nHere are concrete examples of the path-repr and shell-path filters.\nWe'll show results when relative-paths is true and when it is false.\n\n------------------------------\nDemonstration of ``path-repr``\n------------------------------\n\nLet's say we want to make a custom Python script in the bin directory.\nIt will print some information from a file in a ``data`` directory\nwithin the buildout root.  Here's the template.\n\n    >>> write(sample_buildout, 'template', 'bin', 'dosomething.py.in', '''\\\n    ... #!${buildout:executable}\n    ... ${python-relative-path-setup}\n    ... f = open(${buildout:directory/data/info.csv|path-repr})\n    ... print f.read()\n    ... ''')\n    >>> os.chmod(\n    ...     os.path.join(\n    ...         sample_buildout, 'template', 'bin', 'dosomething.py.in'),\n    ...     0711)\n\nIf we evaluate that template with relative-paths set to false, the results\nshouldn't be too surprising.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... source-directory = template\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'bin', 'dosomething.py') # doctest: +ELLIPSIS\n    #!...\n    <BLANKLINE>\n    f = open('/.../sample-buildout/data/info.csv')\n    print f.read()\n\n``${python-relative-path-setup}`` evaluated to an empty string.  The path\nis absolute and quoted.\n\nIf we evaluate it with relative-paths set to true, the results are much...\nbigger.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ... relative-paths = true\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... source-directory = template\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'bin', 'dosomething.py') # doctest: +ELLIPSIS\n    #!...\n    import os, imp\n    # Get path to this file.\n    if __name__ == '__main__':\n        _z3c_recipe_filetemplate_filename = __file__\n    else:\n        # If this is an imported module, we want the location of the .py\n        # file, not the .pyc, because the .py file may have been symlinked.\n        _z3c_recipe_filetemplate_filename = imp.find_module(__name__)[1]\n    # Get the full, non-symbolic-link directory for this file.\n    _z3c_recipe_filetemplate_base = os.path.dirname(\n        os.path.abspath(os.path.realpath(_z3c_recipe_filetemplate_filename)))\n    # Ascend to buildout root.\n    _z3c_recipe_filetemplate_base = os.path.dirname(\n        _z3c_recipe_filetemplate_base)\n    def _z3c_recipe_filetemplate_path_repr(path):\n        \"Return absolute version of buildout-relative path.\"\n        return os.path.join(_z3c_recipe_filetemplate_base, path)\n    <BLANKLINE>\n    f = open(_z3c_recipe_filetemplate_path_repr('data/info.csv'))\n    print f.read()\n\nThat's quite a bit of code.  You might wonder why we don't just use '..' for\nparent directories.  The reason is that we want our scripts to be usable\nfrom any place on the filesystem.  If we used '..' to construct paths\nrelative to the generated file, then the paths would only work from\ncertain directories.\n\nSo that's how path-repr works.  It can really come in handy if you want\nto support relative paths in buildout.  Now let's look at the shell-path\nfilter.\n\n-------------------------------\nDemonstration of ``shell-path``\n-------------------------------\n\nMaybe you want to write some shell scripts.  The shell-path filter will help\nyou support buildout relative-paths fairly painlessly.\n\nRight now, only POSIX is supported with the shell-path filter, as mentioned\nbefore.\n\nUsage is very similar to the ``path-repr`` filter.  You need to include\n``${shell-relative-path-setup}`` before you use it, just as you include\n``${python-relative-path-setup}`` before using ``path-repr``.\n\nLet's say we want to make a custom shell script in the bin directory.\nIt will print some information from a file in a ``data`` directory\nwithin the buildout root.  Here's the template.\n\n    >>> write(sample_buildout, 'template', 'bin', 'dosomething.sh.in', '''\\\n    ... #!/bin/sh\n    ... ${shell-relative-path-setup}\n    ... cat ${buildout:directory/data/info.csv|shell-path}\n    ... ''')\n    >>> os.chmod(\n    ...     os.path.join(\n    ...         sample_buildout, 'template', 'bin', 'dosomething.sh.in'),\n    ...     0711)\n\nIf relative-paths is set to false (the default), the results are simple.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... source-directory = template\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'bin', 'dosomething.sh') # doctest: +ELLIPSIS\n    #!/bin/sh\n    <BLANKLINE>\n    cat /.../sample-buildout/data/info.csv\n\n``${shell-relative-path-setup}`` evaluated to an empty string.  The path\nis absolute.\n\nNow let's look at the larger code when relative-paths is set to true.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ... relative-paths = true\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... source-directory = template\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'bin', 'dosomething.sh') # doctest: +ELLIPSIS\n    #!/bin/sh\n    # Get full, non-symbolic-link path to this file.\n    Z3C_RECIPE_FILETEMPLATE_FILENAME=`\\\n        readlink -f \"$0\" 2>/dev/null || \\\n        realpath \"$0\" 2>/dev/null || \\\n        type -P \"$0\" 2>/dev/null`\n    # Get directory of file.\n    Z3C_RECIPE_FILETEMPLATE_BASE=`dirname ${Z3C_RECIPE_FILETEMPLATE_FILENAME}`\n    # Ascend to buildout root.\n    Z3C_RECIPE_FILETEMPLATE_BASE=`dirname ${Z3C_RECIPE_FILETEMPLATE_BASE}`\n    <BLANKLINE>\n    cat \"$Z3C_RECIPE_FILETEMPLATE_BASE\"/data/info.csv\n\nAs with the Python code, we don't just use '..' for\nparent directories because we want our scripts to be usable\nfrom any place on the filesystem.\n\n----------------------------------\nGetting Arbitrary Dependency Paths\n----------------------------------\n\nYou can specify ``eggs`` and ``extra-paths`` in the recipe.  The\nmechanism is the same as the one provided by the zc.recipe.egg, so\npertinent options such as find-links and index are available.\n\nIf you do, the paths for the dependencies will be calculated.  They will\nbe available as a list in the namespace of the interpreted options as\n``paths``.  Also, three predefined options will be available in the\nrecipe's options for the template.\n\nIf ``paths`` are the paths, ``shell_path`` is the ``shell-path`` filter, and\n``path_repr`` is the ``path-repr`` filter, then the pre-defined options\nwould be defined roughly as given here:\n\n``os-paths`` (for shell scripts)\n  ``(os.pathsep).join(shell_path(path) for path in paths)``\n\n``string-paths`` (for Python scripts)\n  ``',\\n    '.join(path_repr(path) for path in paths)``\n\n``space-paths`` (for shell scripts)\n  ``' '.join(shell_path(path) for path in paths)``\n\nTherefore, if you want to support the relative-paths option, you should\ninclude ``${shell-relative-path-setup}`` (for ``os-paths`` and\n``space-paths``) or ``${python-relative-path-setup}`` (for ``string-paths``)\nas appropriate at the top of your template.\n\nLet's consider a simple example.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... files = helloworld.txt\n    ... eggs = demo<0.3\n    ...\n    ... find-links = %(server)s\n    ... index = %(server)s/index\n    ... \"\"\" % dict(server=link_server))\n\nThe relative-paths option is false, the default.\n\n    >>> write(sample_buildout, 'helloworld.txt.in',\n    ... \"\"\"\n    ... Hello!  Here are the paths for the ${eggs} eggs.\n    ... OS paths:\n    ... ${os-paths}\n    ... ---\n    ... String paths:\n    ... ${string-paths}\n    ... ---\n    ... Space paths:\n    ... ${space-paths}\n    ... \"\"\")\n\n    >>> print system(buildout)\n    Getting distribution for 'demo<0.3'.\n    Got demo 0.2.\n    Getting distribution for 'demoneeded'.\n    Got demoneeded 1.2c1.\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt') # doctest:+ELLIPSIS\n    Hello!  Here are the paths for the demo<0.3 eggs.\n    OS paths:\n    /.../eggs/demo-0.2...egg:/.../eggs/demoneeded-1.2c1...egg\n    ---\n    String paths:\n    '/.../eggs/demo-0.2...egg',\n    '/.../eggs/demoneeded-1.2c1...egg'\n    ---\n    Space paths:\n    /.../eggs/demo-0.2...egg /.../eggs/demoneeded-1.2c1...egg\n\nYou can specify extra-paths as well, which will go at the end of the egg\npaths.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... files = helloworld.txt\n    ... eggs = demo<0.3\n    ... extra-paths = ${buildout:directory}/foo\n    ...\n    ... find-links = %(server)s\n    ... index = %(server)s/index\n    ... \"\"\" % dict(server=link_server))\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt') # doctest:+ELLIPSIS\n    Hello!  Here are the paths for the demo<0.3 eggs.\n    OS paths:\n    /...demo...:/...demoneeded...:/.../sample-buildout/foo\n    ---\n    String paths:\n    '/...demo...',\n    '/...demoneeded...',\n    '/.../sample-buildout/foo'\n    ---\n    Space paths:\n    /...demo... /...demoneeded... .../sample-buildout/foo\n\nTo emphasize the effect of the relative-paths option, let's see what it looks\nlike when we set relative-paths to True.\n\n    >>> write(sample_buildout, 'buildout.cfg',\n    ... \"\"\"\n    ... [buildout]\n    ... parts = message\n    ... relative-paths = true\n    ...\n    ... [message]\n    ... recipe = z3c.recipe.filetemplate\n    ... files = helloworld.txt\n    ... eggs = demo<0.3\n    ... extra-paths = ${buildout:directory}/foo\n    ...\n    ... find-links = %(server)s\n    ... index = %(server)s/index\n    ... \"\"\" % dict(server=link_server))\n\n    >>> print system(buildout)\n    Uninstalling message.\n    Installing message.\n\n    >>> cat(sample_buildout, 'helloworld.txt') # doctest:+ELLIPSIS\n    Hello!  Here are the paths for the demo<0.3 eggs.\n    OS paths:\n    \"$Z3C_RECIPE_FILETEMPLATE_BASE\"/eggs/demo-0.2-py...egg:\"$Z3C_RECIPE_FILETEMPLATE_BASE\"/eggs/demoneeded-1.2c1-py...egg:\"$Z3C_RECIPE_FILETEMPLATE_BASE\"/foo\n    ---\n    String paths:\n    _z3c_recipe_filetemplate_path_repr('eggs/demo-0.2-py...egg'),\n    _z3c_recipe_filetemplate_path_repr('eggs/demoneeded-1.2c1-py...egg'),\n    _z3c_recipe_filetemplate_path_repr('foo')\n    ---\n    Space paths:\n    \"$Z3C_RECIPE_FILETEMPLATE_BASE\"/eggs/demo-0.2-py...egg \"$Z3C_RECIPE_FILETEMPLATE_BASE\"/eggs/demoneeded-1.2c1-py...egg \"$Z3C_RECIPE_FILETEMPLATE_BASE\"/foo\n\n\nRemember, your script won't really work unless you include\n``${shell-relative-path-setup}`` (for ``os-paths`` and ``space-paths``)\nor ``${python-relative-path-setup}`` (for ``string-paths``) as\nappropriate at the top of your template.\n\nGetting Dependency Paths from ``zc.recipe.egg``\n-----------------------------------------------\n\nYou can get the ``eggs`` and ``extra-paths`` from another section using\nzc.recipe.egg by using the ``extends`` option from the `Sharing Variables`_\nsection above.  Then you can use the template options described above to\nbuild your paths in your templates.\n\nGetting Dependency Paths from ``z3c.recipe.scripts``\n----------------------------------------------------\n\nIf, like the Launchpad project, you are using Gary Poster's unreleased\npackage ``z3c.recipe.scripts`` to generate your scripts, and you want to\nhave your scripts use the same Python environment as generated by that\nrecipe, you can just use the path-repr and shell-path filters with standard\nbuildout directories.  Here is an example buildout.cfg.\n\n::\n\n    [buildout]\n    parts = scripts message\n    relative-paths = true\n\n    [scripts]\n    recipe = z3c.recipe.scripts\n    eggs = demo<0.3\n\n    [message]\n    recipe = z3c.recipe.filetemplate\n    files = helloworld.py\n\nThen the template to use this would want to simply put\n``${scripts:parts-directory|path-repr}`` at the beginning of Python's path.\n\nYou can do this for subprocesses with PYTHONPATH.\n\n    ${python-relative-path-setup}\n    import os\n    import subprocess\n    env = os.environ.copy()\n    env['PYTHONPATH'] = ${scripts:parts-directory|path-repr}\n    subprocess.call('myscript', env=env)\n\nThat's it.\n\nSimilarly, here's an approach to making a script that will have the\nright environment.  You want to put the parts directory of the\nz3c.recipe.scripts section in the sys.path before site.py is loaded.\nThis is usually handled by z3c.recipe.scripts itself, but sometimes you\nmay want to write Python scripts in your template for some reason.\n\n    #!/usr/bin/env python -S\n    ${python-relative-path-setup}\n    import sys\n    sys.path.insert(0, ${scripts:parts-directory|path-repr})\n    import site\n    # do stuff...\n\nIf you do this for many scripts, put this entire snippet in an option in the\nrecipe and use this snippet as a single substitution in the top of your\nscripts.\n\n\n=======\nChanges\n=======\n\n2.2.0 (2011-09-01)\n==================\n\n--------\nFeatures\n--------\n\n- Add support for excluding some subdirectories of the ``source-directory``\n  with the ``exclude-directories`` option.  [Bruno Binet]\n\n-----\nFixes\n-----\n\n- Added undeclared but necessary test dependency on `zope.testing` in a\n  test extra.\n\n- Added test dependency on `z3c.recipe.scripts` as it is required by newer\n  `zc.buildout` versions.\n\n- Using python's `doctest` module instead of deprecated\n  `zope.testing.doctest`.\n\n2.1.0 (2010-04-21)\n==================\n\n--------\nFeatures\n--------\n\n- Enable cross-platform paths by allowing an extended syntax for path\n  suffixes. Example: If ``${buildout:directory}`` resolves to\n  ``/sample_buildout`` on a POSIX system and ``C:\\sample_buildout`` in\n  Windows, ``${buildout:directory/foo.txt}`` will resolve to\n  ``/sample_buildout/foo.txt`` and ``C:\\sample_buildout\\foo.txt``,\n  respectively.\n\n- Add filters via a pipe syntax, reminiscent of UNIX pipes or Django template\n  filters. Simple example: if ``${name}`` resolves to ``harry`` then\n  ``${name|upper}`` resolves to ``HARRY``.  Simple string filters are\n  upper, lower, title, and capitalize, just like the Python string\n  methods.  Also see the next bullet.\n\n- Added support for the buildout relative-paths option.  Shell scripts should\n  include ``${shell-relative-path-setup}`` before commands with\n  buildout-generated paths are executed.  Python scripts should use\n  ``${python-relative-path-setup}`` similarly.  ``${os-paths}`` (shell),\n  ``${space-paths}`` (shell), and ``${string-paths}`` (Python) will have\n  relative paths if the buildout relative-paths option is used.  To convert\n  individual absolute paths to relative paths, use the ``path-repr`` filter\n  in Python scripts and the ``shell-path`` filter in shell scripts.  Path\n  suffixes can be combined with these filters, so, if buildout's\n  relative-paths option is true, ``${buildout:directory/foo.txt|path-repr}``\n  will produce a buildout-relative, platform appropriate path to\n  foo.txt.  Note that for shell scripts, Windows is not supported at\n  this time.\n\n- Support escaping ``${...}`` with ``$${...}`` in templates.  This is\n  particularly useful for UNIX shell scripts.\n\n-----\nFixes\n-----\n\n- Make tests less susceptible to timing errors.\n\n-------\nChanges\n-------\n\n- ``${os-paths}`` and ``${space-paths}`` no longer filter out .zip paths.\n\n- The entries in ``${string-paths}`` now are separated by newlines. Each\n  entry is indented to the level of the initial placement of the marker.\n\n2.0.3 (2009-07-02)\n==================\n\n-----\nFixes\n-----\n\n- Use ``realpath`` helper function from zc.buildout on the buildout\n  directory too, such that it goes through the same normalization as\n  the path being compared and stands a chance of working on Windows,\n  due to possible drive letter case differences.\n\n2.0.2 (2009-05-04)\n==================\n\n-----\nFixes\n-----\n\n- Turns out sorting paths was a bad idea.  They are already in a deterministic\n  order, AFAICT, because of the order or processing dependencies.  Sorting\n  them makes them *less* deterministic in practice, across machines.\n\n2.0.1 (2009-04-30)\n==================\n\n-----\nFixes\n-----\n\n- Correct sdist generation to include all necessary files.\n\n- Doc formatting fixes.\n\n- Correct \"Destinations already exist\" message to list destinations without\n  ``.in`` suffix.\n\n2.0 (2009-04-30)\n================\n\n--------\nFeatures\n--------\n\n- Store your template files in a separate directory structure, using the\n  ``source-directory`` option.\n\n- Specify multiple files automatically with globs.\n\n- Templates can reference other buildout sections using the usual syntax, e.g.\n  ${buildout:parts}\n\n- Share options with other sections using the typical ``extends`` option.\n\n- Create destination directories automatically.\n\n- Define option values for templates dynamically in Python with the\n  ``interpreted-options`` option.\n\n- Get paths for eggs by specifying ``eggs`` and ``extra-paths``, just like\n  zc.recipe.egg script recipe.  These are available in template options in\n  colon-delimited, space-delimited, and quoted variants.  You can also build\n  your own using the ``interpreted-options`` feature.\n\n- Templates are not processed if there are no changes to them or the buildout.\n\n1.0 (2007-09-30)\n================\n\nInitial release.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/z3c.recipe.filetemplate", "keywords": null, "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "z3c.recipe.filetemplate", "package_url": "https://pypi.org/project/z3c.recipe.filetemplate/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/z3c.recipe.filetemplate/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/z3c.recipe.filetemplate"}, "release_url": "https://pypi.org/project/z3c.recipe.filetemplate/2.2.0/", "requires_dist": null, "requires_python": null, "summary": "zc.buildout recipe for creating files from file templates", "version": "2.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"basic-usage\">\n<h2>Basic Usage</h2>\n<p>With the <tt>z3c.recipe.filetemplate</tt> buildout recipe you can automate\nthe generation of text files from templates.  Upon execution, the\nrecipe will read a number of template files, perform variable\nsubstitution and write the result to the corresponding output files.</p>\n<p>The recipe has several features, but it always takes template files with a\n<tt>.in</tt> suffix, processes the template, and writes out the file to the desired\nlocation with the same file mode, and the same name but without the <tt>.in</tt>\nsuffix.</p>\n<p>For example, consider this simple template for a text file:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'helloworld.txt.in',\n... \"\"\"\n... Hello ${world}!\n... \"\"\")\n</pre>\n</blockquote>\n<p>Now let\u2019s create a buildout configuration so that we can substitute\nthe values in this file.  All we have to do is define a part that uses\nthe <tt>z3c.recipe.filetemplate</tt> recipe.  With the <tt>files</tt> parameter\nwe specify one or more files that need substitution (separated by\nwhitespace).  Then we can add arbitrary parameters to the section.\nThose will be used to fill the variables in the template:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... files = helloworld.txt\n... world = Philipp\n... \"\"\")\n</pre>\n</blockquote>\n<p>After executing buildout, we can see that <tt>${world}</tt> has indeed been\nreplaced by <tt>Philipp</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print system(buildout)\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt')\nHello Philipp!\n</pre>\n</blockquote>\n<p>If you need to escape the ${\u2026} pattern, you can do so by repeating the dollar\nsign.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; update_file(sample_buildout, 'helloworld.txt.in',\n... \"\"\"\n... Hello world! The double $${dollar-sign} escapes!\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt')\nHello world! The double ${dollar-sign} escapes!\n</pre>\n</blockquote>\n<p>Note that dollar signs alone, without curly braces, are not parsed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; update_file(sample_buildout, 'helloworld.txt.in',\n... \"\"\"\n... $Hello $$world! $$$profit!\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt')\n$Hello $$world! $$$profit!\n</pre>\n</blockquote>\n<p>Note that the output file uses the same permission bits as found on the input\nfile.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import stat\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; input = os.path.join(sample_buildout, 'helloworld.txt.in')\n&gt;&gt;&gt; output = input[:-3]\n&gt;&gt;&gt; os.chmod(input, 0755)\n&gt;&gt;&gt; stat.S_IMODE(os.stat(input).st_mode) == 0755\nTrue\n&gt;&gt;&gt; stat.S_IMODE(os.stat(output).st_mode) == 0755\nFalse\n&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n&gt;&gt;&gt; stat.S_IMODE(os.stat(output).st_mode) == 0755\nTrue\n</pre>\n</blockquote>\n<div id=\"source-folders-and-globs\">\n<h3>Source Folders and Globs</h3>\n<p>By default, the recipe looks for a <tt>.in</tt> file relative to the buildout root,\nand places it in the same folder relative to the buildout root.  However, if\nyou don\u2019t want to clutter up the destination folder, you can add a prefix to\nthe source folder.  Here is an example.</p>\n<p>First, we specify a <tt><span class=\"pre\">source-directory</span></tt> in the buildout.  You can specify\n<tt>files</tt> as a filter if desired, but by default it will find any file (ending\nwith \u201c.in\u201d). You can also specify <tt><span class=\"pre\">exclude-directories</span></tt> option if you want\nto exclude some paths from the <tt><span class=\"pre\">source-directory</span></tt> search path.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... source-directory = template\n... world = Philipp\n... \"\"\")\n</pre>\n</blockquote>\n<p>Now we\u2019ll make a \u201ctemplate\u201d directory, as listed in the buildout configuration\nabove, and populate it for our example.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; mkdir(sample_buildout, 'template')\n&gt;&gt;&gt; mkdir(sample_buildout, 'template', 'etc')\n&gt;&gt;&gt; mkdir(sample_buildout, 'template', 'bin')\n&gt;&gt;&gt; write(sample_buildout, 'template', 'etc', 'helloworld.conf.in',\n... \"\"\"\n... Hello ${world} from the etc dir!\n... \"\"\")\n&gt;&gt;&gt; write(sample_buildout, 'template', 'bin', 'helloworld.sh.in',\n... \"\"\"\n... Hello ${world} from the bin dir!\n... \"\"\")\n&gt;&gt;&gt; os.chmod(\n...     os.path.join(\n...         sample_buildout, 'template', 'bin', 'helloworld.sh.in'),\n...     0711)\n</pre>\n</blockquote>\n<p>Notice that, before running buildout, the <tt>helloworld.txt</tt> file is still\naround, we don\u2019t have an etc directory, and the bin directory doesn\u2019t have our\n<tt>helloworld.sh</tt>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ls(sample_buildout)\n-  .installed.cfg\nd  bin\n-  buildout.cfg\nd  develop-eggs\nd  eggs\n-  helloworld.txt\n-  helloworld.txt.in\nd  parts\nd  template\n&gt;&gt;&gt; ls(sample_buildout, 'bin')\n-  buildout\n</pre>\n</blockquote>\n<p>Now we install.  The old \u201chelloworld.txt\u201d is gone, and we now see etc.  Note\nthat, for the destination, intermediate folders are created if they do not\nexist.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n&gt;&gt;&gt; ls(sample_buildout)\n-  .installed.cfg\nd  bin\n-  buildout.cfg\nd  develop-eggs\nd  eggs\nd  etc\n-  helloworld.txt.in\nd  parts\nd  template\n</pre>\n</blockquote>\n<p>The files exist and have the content we expect.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ls(sample_buildout, 'bin')\n- buildout\n- helloworld.sh\n&gt;&gt;&gt; cat(sample_buildout, 'bin', 'helloworld.sh')\nHello Philipp from the bin dir!\n&gt;&gt;&gt; stat.S_IMODE(os.stat(os.path.join(\n...     sample_buildout, 'bin', 'helloworld.sh')).st_mode) == 0711\nTrue\n&gt;&gt;&gt; ls(sample_buildout, 'etc')\n- helloworld.conf\n&gt;&gt;&gt; cat(sample_buildout, 'etc', 'helloworld.conf')\nHello Philipp from the etc dir!\n</pre>\n</blockquote>\n<p>If you use the <tt>files</tt> option along with <tt><span class=\"pre\">source-directory</span></tt>, it becomes a\nfilter.  Every target file must match at least one of the names in <tt>files</tt>.\nTherefore, if we only build .sh files, the etc directory will disappear.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... source-directory = template\n... files = *.sh\n... world = Philipp\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n&gt;&gt;&gt; ls(sample_buildout)\n-  .installed.cfg\nd  bin\n-  buildout.cfg\nd  develop-eggs\nd  eggs\n-  helloworld.txt.in\nd  parts\nd  template\n</pre>\n<pre>&gt;&gt;&gt; ls(sample_buildout, 'bin')\n- buildout\n- helloworld.sh\n</pre>\n</blockquote>\n<p>Also note that, if you use a source directory and your <tt>files</tt> specify a\ndirectory, the directory must match precisely.</p>\n<p>With the <tt><span class=\"pre\">exclude-directories</span></tt> parameter, we specify one or more directories\n(separated by whitespace) in which the recipe will not look for template\nfiles. The <tt><span class=\"pre\">exclude-directories</span></tt> option should be used along with the\n<tt><span class=\"pre\">source-directory</span></tt> option.\nTherefore, if we set <tt><span class=\"pre\">exclude-directories</span></tt> to <tt>bin</tt>, the\n<tt>bin/helloworld.sh</tt> file will disappear.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... source-directory = template\n... exclude-directories = bin\n... world = Philipp\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n&gt;&gt;&gt; ls(sample_buildout)\n-  .installed.cfg\nd  bin\n-  buildout.cfg\nd  develop-eggs\nd  eggs\nd  etc\n-  helloworld.txt.in\nd  parts\nd  template\n</pre>\n<pre>&gt;&gt;&gt; ls(sample_buildout, 'etc')\n- helloworld.conf\n</pre>\n<pre>&gt;&gt;&gt; ls(sample_buildout, 'bin')\n- buildout\n</pre>\n<pre>&gt;&gt;&gt; # Clean up for later test.\n&gt;&gt;&gt; import shutil\n&gt;&gt;&gt; shutil.rmtree(os.path.join(sample_buildout, 'template', 'etc'))\n&gt;&gt;&gt; os.remove(os.path.join(\n...     sample_buildout, 'template', 'bin', 'helloworld.sh.in'))\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"advanced-usage\">\n<h2>Advanced Usage</h2>\n<div id=\"substituting-from-other-sections\">\n<h3>Substituting from Other Sections</h3>\n<p>Substitutions can also come from other sections in the buildout, using the\nstandard buildout syntax, but used in the template.  Notice\n<tt>${buildout:parts}</tt> in the template below.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; update_file(sample_buildout, 'helloworld.txt.in',\n... \"\"\"\n... Hello ${world}.  I used these parts: ${buildout:parts}.\n... \"\"\")\n&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... files = helloworld.txt\n... world = Philipp\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt')\nHello Philipp.  I used these parts: message.\n</pre>\n</blockquote>\n</div>\n<div id=\"path-extensions\">\n<h3>Path Extensions</h3>\n<p>Substitutions can have path suffixes using the POSIX \u201c/\u201d path separator.\nThe template will convert these to the proper path separator for the current\nOS.  They also then are part of the value passed to filters, the feature\ndescribed next.  Notice <tt>${buildout:directory/foo/bar.txt}</tt> in the template\nbelow.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; update_file(sample_buildout, 'helloworld.txt.in',\n... \"\"\"\n... Here's foo/bar.txt in the buildout:\n... ${buildout:directory/foo/bar.txt}\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt') # doctest: +ELLIPSIS\nHere's foo/bar.txt in the buildout:\n/.../sample-buildout/foo/bar.txt\n</pre>\n</blockquote>\n</div>\n<div id=\"filters\">\n<h3>Filters</h3>\n<p>You can use pipes within a substitution to filter the original value.  This\nrecipe provides several filters for you to use.  The syntax is reminiscent of\n(and inspired by) POSIX pipes and Django template filters.  For example,\nif world = Philipp, <tt>HELLO ${world|upper}!</tt> would result in <tt>HELLO\nPHILIPP!</tt>.</p>\n<p>A few simple Python string methods are exposed as filters right now:</p>\n<ul>\n<li>capitalize: First letter in string is capitalized.</li>\n<li>lower: All letters in string are lowercase.</li>\n<li>title: First letter of each word in string is capitalized.</li>\n<li>upper: All letters in string are uppercase.</li>\n</ul>\n<p>Other filters are important for handling paths if buildout\u2019s relative-paths\noption is true.  See <a href=\"#working-with-paths\" rel=\"nofollow\">Working with Paths</a> for more details.</p>\n<ul>\n<li>path-repr: Converts the path to a Python expression for the path.  If\nbuildout\u2019s relative-paths option is false, this will simply be a repr\nof the absolute path.  If relative-paths is true, this will be a\nfunction call to convert a buildout-relative path to an absolute path;\nit requires that <tt><span class=\"pre\">${python-relative-path-setup}</span></tt> be included earlier\nin the template.</li>\n<li>shell-path: Converts the path to a shell expression for the path.  Only\nPOSIX is supported at this time.  If buildout\u2019s relative-paths option\nis false, this will simply be the absolute path.  If relative-paths is\ntrue, this will be an expression to convert a buildout-relative path\nto an absolute path; it requires that <tt><span class=\"pre\">${shell-relative-path-setup}</span></tt>\nbe included earlier in the template.</li>\n</ul>\n<p>Combining the three advanced features described so far, then, if the\nbuildout relative-paths option were false, we were in a POSIX system, and\nthe sample buildout were in the root of the system, the template\nexpression <tt><span class=\"pre\">${buildout:bin-directory/data/initial.csv|path-repr}</span></tt>\nwould result in <tt><span class=\"pre\">'/sample-buildout/bin/data/initial.csv'</span></tt>.</p>\n<p>Here\u2019s a real, working example of the string method filters.  We\u2019ll have\nexamples of the path filters in the <a href=\"#working-with-paths\" rel=\"nofollow\">Working with Paths</a> section.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; update_file(sample_buildout, 'helloworld.txt.in',\n... \"\"\"\n... HELLO ${world|upper}!\n... hello ${world|lower}.\n... ${name|title} and the Chocolate Factory\n... ${sentence|capitalize}\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... files = helloworld.txt\n... world = Philipp\n... name = willy wonka\n... sentence = that is a good book.\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt') # doctest: +ELLIPSIS\nHELLO PHILIPP!\nhello philipp.\nWilly Wonka and the Chocolate Factory\nThat is a good book.\n</pre>\n</blockquote>\n</div>\n<div id=\"sharing-variables\">\n<h3>Sharing Variables</h3>\n<p>The recipe allows extending one or more sections, to decrease\nrepetition, using the <tt>extends</tt> option.  For instance, consider the\nfollowing buildout.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [template_defaults]\n... mygreeting = Hi\n... myaudience = World\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... files = helloworld.txt\n... extends = template_defaults\n...\n... myaudience = everybody\n... \"\"\")\n</pre>\n</blockquote>\n<p>The \u201cmessage\u201d section now has values extended from the \u201ctemplate_defaults\u201d\nsection, and overwritten locally.  A template of\n<tt>${mygreeting}, ${myaudience}!</tt>\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; update_file(sample_buildout, 'helloworld.txt.in',\n... \"\"\"\n... ${mygreeting}, ${myaudience}!\n... \"\"\")\n</pre>\n</blockquote>\n<p>\u2026would thus result in <tt>Hi, everybody!</tt>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt')\nHi, everybody!\n</pre>\n</blockquote>\n</div>\n<div id=\"defining-options-in-python\">\n<h3>Defining options in Python</h3>\n<p>You can specify that certain variables should be interpreted as Python using\n<tt><span class=\"pre\">interpreted-options</span></tt>.  This takes zero or more lines.  Each line should\nspecify an option.  It can define immediately (see <tt><span class=\"pre\">silly-range</span></tt> in\nthe example below) or point to an option to be interepreted, which can\nbe useful if you want to define a multi-line expression (see\n<tt><span class=\"pre\">first-interpreted-option</span></tt> and <tt><span class=\"pre\">message-reversed-is-egassem</span></tt>).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... files = helloworld.txt\n... interpreted-options = silly-range = repr(range(5))\n...                       first-interpreted-option\n...                       message-reversed-is-egassem\n... first-interpreted-option =\n...     options['interpreted-options'].splitlines()[0].strip()\n... message-reversed-is-egassem=\n...     ''.join(\n...         reversed(\n...             buildout['buildout']['parts']))\n... not-interpreted=hello world\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; update_file(sample_buildout, 'helloworld.txt.in', \"\"\"\\\n... ${not-interpreted}!\n... silly-range: ${silly-range}\n... first-interpreted-option: ${first-interpreted-option}\n... message-reversed-is-egassem: ${message-reversed-is-egassem}\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt') # doctest:+ELLIPSIS\nhello world!\nsilly-range: [0, 1, 2, 3, 4]\nfirst-interpreted-option: silly-range = repr(range(5))\nmessage-reversed-is-egassem: egassem\n</pre>\n</blockquote>\n</div>\n<div id=\"working-with-paths\">\n<h3>Working with Paths</h3>\n<p>We\u2019ve already mentioned how to handle buildout\u2019s relative-paths option\nin the discussion of filters.  This section has some concrete examples\nand discussion of that.  It also introduces how to get a set of paths\nfrom specifying dependencies.</p>\n<p>Here are concrete examples of the path-repr and shell-path filters.\nWe\u2019ll show results when relative-paths is true and when it is false.</p>\n<div id=\"demonstration-of-path-repr\">\n<h4>Demonstration of <tt><span class=\"pre\">path-repr</span></tt></h4>\n<p>Let\u2019s say we want to make a custom Python script in the bin directory.\nIt will print some information from a file in a <tt>data</tt> directory\nwithin the buildout root.  Here\u2019s the template.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'template', 'bin', 'dosomething.py.in', '''\\\n... #!${buildout:executable}\n... ${python-relative-path-setup}\n... f = open(${buildout:directory/data/info.csv|path-repr})\n... print f.read()\n... ''')\n&gt;&gt;&gt; os.chmod(\n...     os.path.join(\n...         sample_buildout, 'template', 'bin', 'dosomething.py.in'),\n...     0711)\n</pre>\n</blockquote>\n<p>If we evaluate that template with relative-paths set to false, the results\nshouldn\u2019t be too surprising.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... source-directory = template\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'bin', 'dosomething.py') # doctest: +ELLIPSIS\n#!...\n&lt;BLANKLINE&gt;\nf = open('/.../sample-buildout/data/info.csv')\nprint f.read()\n</pre>\n</blockquote>\n<p><tt><span class=\"pre\">${python-relative-path-setup}</span></tt> evaluated to an empty string.  The path\nis absolute and quoted.</p>\n<p>If we evaluate it with relative-paths set to true, the results are much\u2026\nbigger.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n... relative-paths = true\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... source-directory = template\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'bin', 'dosomething.py') # doctest: +ELLIPSIS\n#!...\nimport os, imp\n# Get path to this file.\nif __name__ == '__main__':\n    _z3c_recipe_filetemplate_filename = __file__\nelse:\n    # If this is an imported module, we want the location of the .py\n    # file, not the .pyc, because the .py file may have been symlinked.\n    _z3c_recipe_filetemplate_filename = imp.find_module(__name__)[1]\n# Get the full, non-symbolic-link directory for this file.\n_z3c_recipe_filetemplate_base = os.path.dirname(\n    os.path.abspath(os.path.realpath(_z3c_recipe_filetemplate_filename)))\n# Ascend to buildout root.\n_z3c_recipe_filetemplate_base = os.path.dirname(\n    _z3c_recipe_filetemplate_base)\ndef _z3c_recipe_filetemplate_path_repr(path):\n    \"Return absolute version of buildout-relative path.\"\n    return os.path.join(_z3c_recipe_filetemplate_base, path)\n&lt;BLANKLINE&gt;\nf = open(_z3c_recipe_filetemplate_path_repr('data/info.csv'))\nprint f.read()\n</pre>\n</blockquote>\n<p>That\u2019s quite a bit of code.  You might wonder why we don\u2019t just use \u2018..\u2019 for\nparent directories.  The reason is that we want our scripts to be usable\nfrom any place on the filesystem.  If we used \u2018..\u2019 to construct paths\nrelative to the generated file, then the paths would only work from\ncertain directories.</p>\n<p>So that\u2019s how path-repr works.  It can really come in handy if you want\nto support relative paths in buildout.  Now let\u2019s look at the shell-path\nfilter.</p>\n</div>\n<div id=\"demonstration-of-shell-path\">\n<h4>Demonstration of <tt><span class=\"pre\">shell-path</span></tt></h4>\n<p>Maybe you want to write some shell scripts.  The shell-path filter will help\nyou support buildout relative-paths fairly painlessly.</p>\n<p>Right now, only POSIX is supported with the shell-path filter, as mentioned\nbefore.</p>\n<p>Usage is very similar to the <tt><span class=\"pre\">path-repr</span></tt> filter.  You need to include\n<tt><span class=\"pre\">${shell-relative-path-setup}</span></tt> before you use it, just as you include\n<tt><span class=\"pre\">${python-relative-path-setup}</span></tt> before using <tt><span class=\"pre\">path-repr</span></tt>.</p>\n<p>Let\u2019s say we want to make a custom shell script in the bin directory.\nIt will print some information from a file in a <tt>data</tt> directory\nwithin the buildout root.  Here\u2019s the template.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'template', 'bin', 'dosomething.sh.in', '''\\\n... #!/bin/sh\n... ${shell-relative-path-setup}\n... cat ${buildout:directory/data/info.csv|shell-path}\n... ''')\n&gt;&gt;&gt; os.chmod(\n...     os.path.join(\n...         sample_buildout, 'template', 'bin', 'dosomething.sh.in'),\n...     0711)\n</pre>\n</blockquote>\n<p>If relative-paths is set to false (the default), the results are simple.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... source-directory = template\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'bin', 'dosomething.sh') # doctest: +ELLIPSIS\n#!/bin/sh\n&lt;BLANKLINE&gt;\ncat /.../sample-buildout/data/info.csv\n</pre>\n</blockquote>\n<p><tt><span class=\"pre\">${shell-relative-path-setup}</span></tt> evaluated to an empty string.  The path\nis absolute.</p>\n<p>Now let\u2019s look at the larger code when relative-paths is set to true.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n... relative-paths = true\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... source-directory = template\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'bin', 'dosomething.sh') # doctest: +ELLIPSIS\n#!/bin/sh\n# Get full, non-symbolic-link path to this file.\nZ3C_RECIPE_FILETEMPLATE_FILENAME=`\\\n    readlink -f \"$0\" 2&gt;/dev/null || \\\n    realpath \"$0\" 2&gt;/dev/null || \\\n    type -P \"$0\" 2&gt;/dev/null`\n# Get directory of file.\nZ3C_RECIPE_FILETEMPLATE_BASE=`dirname ${Z3C_RECIPE_FILETEMPLATE_FILENAME}`\n# Ascend to buildout root.\nZ3C_RECIPE_FILETEMPLATE_BASE=`dirname ${Z3C_RECIPE_FILETEMPLATE_BASE}`\n&lt;BLANKLINE&gt;\ncat \"$Z3C_RECIPE_FILETEMPLATE_BASE\"/data/info.csv\n</pre>\n</blockquote>\n<p>As with the Python code, we don\u2019t just use \u2018..\u2019 for\nparent directories because we want our scripts to be usable\nfrom any place on the filesystem.</p>\n</div>\n<div id=\"getting-arbitrary-dependency-paths\">\n<h4>Getting Arbitrary Dependency Paths</h4>\n<p>You can specify <tt>eggs</tt> and <tt><span class=\"pre\">extra-paths</span></tt> in the recipe.  The\nmechanism is the same as the one provided by the zc.recipe.egg, so\npertinent options such as find-links and index are available.</p>\n<p>If you do, the paths for the dependencies will be calculated.  They will\nbe available as a list in the namespace of the interpreted options as\n<tt>paths</tt>.  Also, three predefined options will be available in the\nrecipe\u2019s options for the template.</p>\n<p>If <tt>paths</tt> are the paths, <tt>shell_path</tt> is the <tt><span class=\"pre\">shell-path</span></tt> filter, and\n<tt>path_repr</tt> is the <tt><span class=\"pre\">path-repr</span></tt> filter, then the pre-defined options\nwould be defined roughly as given here:</p>\n<dl>\n<dt><tt><span class=\"pre\">os-paths</span></tt> (for shell scripts)</dt>\n<dd><tt><span class=\"pre\">(os.pathsep).join(shell_path(path)</span> for path in paths)</tt></dd>\n<dt><tt><span class=\"pre\">string-paths</span></tt> (for Python scripts)</dt>\n<dd><tt><span class=\"pre\">',\\n</span>\u00a0\u00a0\u00a0 '.join(path_repr(path) for path in paths)</tt></dd>\n<dt><tt><span class=\"pre\">space-paths</span></tt> (for shell scripts)</dt>\n<dd><tt>' '.join(shell_path(path) for path in paths)</tt></dd>\n</dl>\n<p>Therefore, if you want to support the relative-paths option, you should\ninclude <tt><span class=\"pre\">${shell-relative-path-setup}</span></tt> (for <tt><span class=\"pre\">os-paths</span></tt> and\n<tt><span class=\"pre\">space-paths</span></tt>) or <tt><span class=\"pre\">${python-relative-path-setup}</span></tt> (for <tt><span class=\"pre\">string-paths</span></tt>)\nas appropriate at the top of your template.</p>\n<p>Let\u2019s consider a simple example.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... files = helloworld.txt\n... eggs = demo&lt;0.3\n...\n... find-links = %(server)s\n... index = %(server)s/index\n... \"\"\" % dict(server=link_server))\n</pre>\n</blockquote>\n<p>The relative-paths option is false, the default.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'helloworld.txt.in',\n... \"\"\"\n... Hello!  Here are the paths for the ${eggs} eggs.\n... OS paths:\n... ${os-paths}\n... ---\n... String paths:\n... ${string-paths}\n... ---\n... Space paths:\n... ${space-paths}\n... \"\"\")\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nGetting distribution for 'demo&lt;0.3'.\nGot demo 0.2.\nGetting distribution for 'demoneeded'.\nGot demoneeded 1.2c1.\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt') # doctest:+ELLIPSIS\nHello!  Here are the paths for the demo&lt;0.3 eggs.\nOS paths:\n/.../eggs/demo-0.2...egg:/.../eggs/demoneeded-1.2c1...egg\n---\nString paths:\n'/.../eggs/demo-0.2...egg',\n'/.../eggs/demoneeded-1.2c1...egg'\n---\nSpace paths:\n/.../eggs/demo-0.2...egg /.../eggs/demoneeded-1.2c1...egg\n</pre>\n</blockquote>\n<p>You can specify extra-paths as well, which will go at the end of the egg\npaths.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... files = helloworld.txt\n... eggs = demo&lt;0.3\n... extra-paths = ${buildout:directory}/foo\n...\n... find-links = %(server)s\n... index = %(server)s/index\n... \"\"\" % dict(server=link_server))\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt') # doctest:+ELLIPSIS\nHello!  Here are the paths for the demo&lt;0.3 eggs.\nOS paths:\n/...demo...:/...demoneeded...:/.../sample-buildout/foo\n---\nString paths:\n'/...demo...',\n'/...demoneeded...',\n'/.../sample-buildout/foo'\n---\nSpace paths:\n/...demo... /...demoneeded... .../sample-buildout/foo\n</pre>\n</blockquote>\n<p>To emphasize the effect of the relative-paths option, let\u2019s see what it looks\nlike when we set relative-paths to True.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; write(sample_buildout, 'buildout.cfg',\n... \"\"\"\n... [buildout]\n... parts = message\n... relative-paths = true\n...\n... [message]\n... recipe = z3c.recipe.filetemplate\n... files = helloworld.txt\n... eggs = demo&lt;0.3\n... extra-paths = ${buildout:directory}/foo\n...\n... find-links = %(server)s\n... index = %(server)s/index\n... \"\"\" % dict(server=link_server))\n</pre>\n<pre>&gt;&gt;&gt; print system(buildout)\nUninstalling message.\nInstalling message.\n</pre>\n<pre>&gt;&gt;&gt; cat(sample_buildout, 'helloworld.txt') # doctest:+ELLIPSIS\nHello!  Here are the paths for the demo&lt;0.3 eggs.\nOS paths:\n\"$Z3C_RECIPE_FILETEMPLATE_BASE\"/eggs/demo-0.2-py...egg:\"$Z3C_RECIPE_FILETEMPLATE_BASE\"/eggs/demoneeded-1.2c1-py...egg:\"$Z3C_RECIPE_FILETEMPLATE_BASE\"/foo\n---\nString paths:\n_z3c_recipe_filetemplate_path_repr('eggs/demo-0.2-py...egg'),\n_z3c_recipe_filetemplate_path_repr('eggs/demoneeded-1.2c1-py...egg'),\n_z3c_recipe_filetemplate_path_repr('foo')\n---\nSpace paths:\n\"$Z3C_RECIPE_FILETEMPLATE_BASE\"/eggs/demo-0.2-py...egg \"$Z3C_RECIPE_FILETEMPLATE_BASE\"/eggs/demoneeded-1.2c1-py...egg \"$Z3C_RECIPE_FILETEMPLATE_BASE\"/foo\n</pre>\n</blockquote>\n<p>Remember, your script won\u2019t really work unless you include\n<tt><span class=\"pre\">${shell-relative-path-setup}</span></tt> (for <tt><span class=\"pre\">os-paths</span></tt> and <tt><span class=\"pre\">space-paths</span></tt>)\nor <tt><span class=\"pre\">${python-relative-path-setup}</span></tt> (for <tt><span class=\"pre\">string-paths</span></tt>) as\nappropriate at the top of your template.</p>\n<div id=\"getting-dependency-paths-from-zc-recipe-egg\">\n<h5>Getting Dependency Paths from <tt>zc.recipe.egg</tt></h5>\n<p>You can get the <tt>eggs</tt> and <tt><span class=\"pre\">extra-paths</span></tt> from another section using\nzc.recipe.egg by using the <tt>extends</tt> option from the <a href=\"#sharing-variables\" rel=\"nofollow\">Sharing Variables</a>\nsection above.  Then you can use the template options described above to\nbuild your paths in your templates.</p>\n</div>\n<div id=\"getting-dependency-paths-from-z3c-recipe-scripts\">\n<h5>Getting Dependency Paths from <tt>z3c.recipe.scripts</tt></h5>\n<p>If, like the Launchpad project, you are using Gary Poster\u2019s unreleased\npackage <tt>z3c.recipe.scripts</tt> to generate your scripts, and you want to\nhave your scripts use the same Python environment as generated by that\nrecipe, you can just use the path-repr and shell-path filters with standard\nbuildout directories.  Here is an example buildout.cfg.</p>\n<pre>[buildout]\nparts = scripts message\nrelative-paths = true\n\n[scripts]\nrecipe = z3c.recipe.scripts\neggs = demo&lt;0.3\n\n[message]\nrecipe = z3c.recipe.filetemplate\nfiles = helloworld.py\n</pre>\n<p>Then the template to use this would want to simply put\n<tt><span class=\"pre\">${scripts:parts-directory|path-repr}</span></tt> at the beginning of Python\u2019s path.</p>\n<p>You can do this for subprocesses with PYTHONPATH.</p>\n<blockquote>\n${python-relative-path-setup}\nimport os\nimport subprocess\nenv = os.environ.copy()\nenv[\u2018PYTHONPATH\u2019] = ${scripts:parts-directory|path-repr}\nsubprocess.call(\u2018myscript\u2019, env=env)</blockquote>\n<p>That\u2019s it.</p>\n<p>Similarly, here\u2019s an approach to making a script that will have the\nright environment.  You want to put the parts directory of the\nz3c.recipe.scripts section in the sys.path before site.py is loaded.\nThis is usually handled by z3c.recipe.scripts itself, but sometimes you\nmay want to write Python scripts in your template for some reason.</p>\n<blockquote>\n#!/usr/bin/env python -S\n${python-relative-path-setup}\nimport sys\nsys.path.insert(0, ${scripts:parts-directory|path-repr})\nimport site\n# do stuff\u2026</blockquote>\n<p>If you do this for many scripts, put this entire snippet in an option in the\nrecipe and use this snippet as a single substitution in the top of your\nscripts.</p>\n</div>\n</div>\n</div>\n</div>\n<div id=\"changes\">\n<h2>Changes</h2>\n<div id=\"id1\">\n<h3>2.2.0 (2011-09-01)</h3>\n<div id=\"features\">\n<h4>Features</h4>\n<ul>\n<li>Add support for excluding some subdirectories of the <tt><span class=\"pre\">source-directory</span></tt>\nwith the <tt><span class=\"pre\">exclude-directories</span></tt> option.  [Bruno Binet]</li>\n</ul>\n</div>\n<div id=\"fixes\">\n<h4>Fixes</h4>\n<ul>\n<li>Added undeclared but necessary test dependency on <cite>zope.testing</cite> in a\ntest extra.</li>\n<li>Added test dependency on <cite>z3c.recipe.scripts</cite> as it is required by newer\n<cite>zc.buildout</cite> versions.</li>\n<li>Using python\u2019s <cite>doctest</cite> module instead of deprecated\n<cite>zope.testing.doctest</cite>.</li>\n</ul>\n</div>\n</div>\n<div id=\"id2\">\n<h3>2.1.0 (2010-04-21)</h3>\n<div id=\"id3\">\n<h4>Features</h4>\n<ul>\n<li>Enable cross-platform paths by allowing an extended syntax for path\nsuffixes. Example: If <tt>${buildout:directory}</tt> resolves to\n<tt>/sample_buildout</tt> on a POSIX system and <tt><span class=\"pre\">C:\\sample_buildout</span></tt> in\nWindows, <tt>${buildout:directory/foo.txt}</tt> will resolve to\n<tt>/sample_buildout/foo.txt</tt> and <tt><span class=\"pre\">C:\\sample_buildout\\foo.txt</span></tt>,\nrespectively.</li>\n<li>Add filters via a pipe syntax, reminiscent of UNIX pipes or Django template\nfilters. Simple example: if <tt>${name}</tt> resolves to <tt>harry</tt> then\n<tt>${name|upper}</tt> resolves to <tt>HARRY</tt>.  Simple string filters are\nupper, lower, title, and capitalize, just like the Python string\nmethods.  Also see the next bullet.</li>\n<li>Added support for the buildout relative-paths option.  Shell scripts should\ninclude <tt><span class=\"pre\">${shell-relative-path-setup}</span></tt> before commands with\nbuildout-generated paths are executed.  Python scripts should use\n<tt><span class=\"pre\">${python-relative-path-setup}</span></tt> similarly.  <tt><span class=\"pre\">${os-paths}</span></tt> (shell),\n<tt><span class=\"pre\">${space-paths}</span></tt> (shell), and <tt><span class=\"pre\">${string-paths}</span></tt> (Python) will have\nrelative paths if the buildout relative-paths option is used.  To convert\nindividual absolute paths to relative paths, use the <tt><span class=\"pre\">path-repr</span></tt> filter\nin Python scripts and the <tt><span class=\"pre\">shell-path</span></tt> filter in shell scripts.  Path\nsuffixes can be combined with these filters, so, if buildout\u2019s\nrelative-paths option is true, <tt><span class=\"pre\">${buildout:directory/foo.txt|path-repr}</span></tt>\nwill produce a buildout-relative, platform appropriate path to\nfoo.txt.  Note that for shell scripts, Windows is not supported at\nthis time.</li>\n<li>Support escaping <tt><span class=\"pre\">${...}</span></tt> with <tt><span class=\"pre\">$${...}</span></tt> in templates.  This is\nparticularly useful for UNIX shell scripts.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h4>Fixes</h4>\n<ul>\n<li>Make tests less susceptible to timing errors.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h4>Changes</h4>\n<ul>\n<li><tt><span class=\"pre\">${os-paths}</span></tt> and <tt><span class=\"pre\">${space-paths}</span></tt> no longer filter out .zip paths.</li>\n<li>The entries in <tt><span class=\"pre\">${string-paths}</span></tt> now are separated by newlines. Each\nentry is indented to the level of the initial placement of the marker.</li>\n</ul>\n</div>\n</div>\n<div id=\"id6\">\n<h3>2.0.3 (2009-07-02)</h3>\n<h3 id=\"id7\"><span class=\"section-subtitle\">Fixes</span></h3>\n<ul>\n<li>Use <tt>realpath</tt> helper function from zc.buildout on the buildout\ndirectory too, such that it goes through the same normalization as\nthe path being compared and stands a chance of working on Windows,\ndue to possible drive letter case differences.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>2.0.2 (2009-05-04)</h3>\n<h3 id=\"id9\"><span class=\"section-subtitle\">Fixes</span></h3>\n<ul>\n<li>Turns out sorting paths was a bad idea.  They are already in a deterministic\norder, AFAICT, because of the order or processing dependencies.  Sorting\nthem makes them <em>less</em> deterministic in practice, across machines.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3>2.0.1 (2009-04-30)</h3>\n<h3 id=\"id11\"><span class=\"section-subtitle\">Fixes</span></h3>\n<ul>\n<li>Correct sdist generation to include all necessary files.</li>\n<li>Doc formatting fixes.</li>\n<li>Correct \u201cDestinations already exist\u201d message to list destinations without\n<tt>.in</tt> suffix.</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3>2.0 (2009-04-30)</h3>\n<h3 id=\"id13\"><span class=\"section-subtitle\">Features</span></h3>\n<ul>\n<li>Store your template files in a separate directory structure, using the\n<tt><span class=\"pre\">source-directory</span></tt> option.</li>\n<li>Specify multiple files automatically with globs.</li>\n<li>Templates can reference other buildout sections using the usual syntax, e.g.\n${buildout:parts}</li>\n<li>Share options with other sections using the typical <tt>extends</tt> option.</li>\n<li>Create destination directories automatically.</li>\n<li>Define option values for templates dynamically in Python with the\n<tt><span class=\"pre\">interpreted-options</span></tt> option.</li>\n<li>Get paths for eggs by specifying <tt>eggs</tt> and <tt><span class=\"pre\">extra-paths</span></tt>, just like\nzc.recipe.egg script recipe.  These are available in template options in\ncolon-delimited, space-delimited, and quoted variants.  You can also build\nyour own using the <tt><span class=\"pre\">interpreted-options</span></tt> feature.</li>\n<li>Templates are not processed if there are no changes to them or the buildout.</li>\n</ul>\n</div>\n<div id=\"id14\">\n<h3>1.0 (2007-09-30)</h3>\n<p>Initial release.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 802078, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "f260ed278824e977c8064388b668d187", "sha256": "89112b61bdbd61bd81dfb6693a40813f8ecf0bd5f20770bac360447e23777188"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-1.0-py2.4.egg", "has_sig": false, "md5_digest": "f260ed278824e977c8064388b668d187", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 6293, "upload_time": "2007-09-30T20:22:26", "upload_time_iso_8601": "2007-09-30T20:22:26Z", "url": "https://files.pythonhosted.org/packages/24/17/57704a6dd2e0481c39d4e4a9151b28c307d7c8a4b5fd6e7aedbc114606bd/z3c.recipe.filetemplate-1.0-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b304eaeed61e8154bae4ac1f6291637f", "sha256": "39d847f38b49b9c546738b1646d9ede1041508ab11a9cb1b1087feaa583d5613"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-1.0.tar.gz", "has_sig": false, "md5_digest": "b304eaeed61e8154bae4ac1f6291637f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3855, "upload_time": "2007-09-30T20:22:26", "upload_time_iso_8601": "2007-09-30T20:22:26Z", "url": "https://files.pythonhosted.org/packages/d1/ca/13826b65b5eaa0b2e37a67b702e01054b1cd1ee4bcc42e998c325811528f/z3c.recipe.filetemplate-1.0.tar.gz", "yanked": false}], "2.0": [{"comment_text": "", "digests": {"md5": "b5a249ab45c3dfa43ccbd6192581d108", "sha256": "5d7909681f89755fa787d0310f1df8173028ff36ed89b35bf7c9d1e410e7531f"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-2.0.tar.gz", "has_sig": false, "md5_digest": "b5a249ab45c3dfa43ccbd6192581d108", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11355, "upload_time": "2009-04-30T21:00:16", "upload_time_iso_8601": "2009-04-30T21:00:16.395461Z", "url": "https://files.pythonhosted.org/packages/11/e7/f35b288930fc0b7265c13275de4944210e95947e4622934d4d5317496170/z3c.recipe.filetemplate-2.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "65b33d6823fe192b44902cc1e340ad58", "sha256": "dcf3257665eb109606b50ec6242c32953f367e295614c1355d04890711c0b2cd"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-2.0.1.tar.gz", "has_sig": false, "md5_digest": "65b33d6823fe192b44902cc1e340ad58", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14613, "upload_time": "2009-05-01T01:37:06", "upload_time_iso_8601": "2009-05-01T01:37:06.538616Z", "url": "https://files.pythonhosted.org/packages/3e/92/a4205c08659f75efefb3749fd46b824d8671105eeb0aaee304e2f86b9aa3/z3c.recipe.filetemplate-2.0.1.tar.gz", "yanked": false}], "2.0.2": [{"comment_text": "", "digests": {"md5": "0f646416b682758ca27a7a88acc6b86f", "sha256": "3257526182a28f3d6cc47768ab63553d735cca8e840cd8529fe55ae566d31c2b"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-2.0.2.tar.gz", "has_sig": false, "md5_digest": "0f646416b682758ca27a7a88acc6b86f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14768, "upload_time": "2009-05-04T20:32:14", "upload_time_iso_8601": "2009-05-04T20:32:14.477464Z", "url": "https://files.pythonhosted.org/packages/5c/10/d6c92bce907e56b40acd01b59181cc43827ae5d0e01c3ea731a02571d11b/z3c.recipe.filetemplate-2.0.2.tar.gz", "yanked": false}], "2.0.3": [{"comment_text": "", "digests": {"md5": "d6735ee0428f604f035f22dd9474269a", "sha256": "e1e2ac25af2c9131f8001ca9f2d8ecb4b4ec36bfdb010e881de1996939db8108"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-2.0.3.tar.gz", "has_sig": false, "md5_digest": "d6735ee0428f604f035f22dd9474269a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14540, "upload_time": "2009-07-02T21:27:28", "upload_time_iso_8601": "2009-07-02T21:27:28.180107Z", "url": "https://files.pythonhosted.org/packages/7b/3d/bc8ccb3f4ee8ce3cbc7c5e58382b9e257751d28c23d12f233677c2501ba4/z3c.recipe.filetemplate-2.0.3.tar.gz", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "6e67453819105077baea267e144e6613", "sha256": "676136e7379660516d7a59d1430d0ac98bdac827814efb6c524e9abc39e9b056"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-2.1.0.tar.gz", "has_sig": false, "md5_digest": "6e67453819105077baea267e144e6613", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34485, "upload_time": "2010-04-21T20:20:17", "upload_time_iso_8601": "2010-04-21T20:20:17.023755Z", "url": "https://files.pythonhosted.org/packages/89/92/398413e5ea51fd8e4f8893a8550d1587136c3a9d0796503103fdc6063d8f/z3c.recipe.filetemplate-2.1.0.tar.gz", "yanked": false}], "2.2.0": [{"comment_text": "", "digests": {"md5": "0c5b759b81b13021e87347fd0343a627", "sha256": "9bbc278b7b119051248dabb1e62454d3b250507bc4dc237e27b84b52ec145c70"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-2.2.0.tar.gz", "has_sig": false, "md5_digest": "0c5b759b81b13021e87347fd0343a627", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36449, "upload_time": "2011-09-02T00:06:43", "upload_time_iso_8601": "2011-09-02T00:06:43.396994Z", "url": "https://files.pythonhosted.org/packages/b1/9d/6aa1d220236c250d69ca595a13d7df7e0d93e3ae4e51d31ddc20390516ae/z3c.recipe.filetemplate-2.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0c5b759b81b13021e87347fd0343a627", "sha256": "9bbc278b7b119051248dabb1e62454d3b250507bc4dc237e27b84b52ec145c70"}, "downloads": -1, "filename": "z3c.recipe.filetemplate-2.2.0.tar.gz", "has_sig": false, "md5_digest": "0c5b759b81b13021e87347fd0343a627", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36449, "upload_time": "2011-09-02T00:06:43", "upload_time_iso_8601": "2011-09-02T00:06:43.396994Z", "url": "https://files.pythonhosted.org/packages/b1/9d/6aa1d220236c250d69ca595a13d7df7e0d93e3ae4e51d31ddc20390516ae/z3c.recipe.filetemplate-2.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:43 2020"}